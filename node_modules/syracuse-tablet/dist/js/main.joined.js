define('syracuse-tablet/html/js/ui/uiUtils',['require','exports','module'],function (require, exports, module) {"use strict";


//empty dom
var _empty = function(domNode) {
	if (domNode) {
		while (domNode.firstChild) {
			domNode.removeChild(domNode.firstChild);
		}
	}
};
//add or remove class to dom element
var _toggleClass = function(item, css, show) {
	if (item) {
		var className = item.className;
		if (show) {
			if (className.indexOf(css) < 0) {
				item.className = className + (" " + css);
			}
		} else {
			item.className = className.replace(css, "");
		}
	}
};

var _waitDefOpts = {
	className: 'waiting-circles',
	elements: 8,
	radius: 30,
	auto: true
};
/**
 * Wait plugin for global application only (no current page or application)
 */
var _waitGlobal = null;
var _wait = function(waitObject, start) {
	if (waitObject == null) {
		// use only if no current application otherwise use page's wait plugin
		if (_waitGlobal == null) _waitGlobal = _waitWheelCreate($(document.body));
		waitObject = _waitGlobal;
	}
	if (start) {
		waitObject.$$bckg.show();
		_waitPluginStatus(waitObject.$$wheel, "enable");
	} else {
		waitObject.$$bckg.hide();
		_waitPluginStatus(waitObject.$$wheel, "disable");
	}
};

var _waitWheelCreate = function($$parent, opts) {
	var waitObject = {
		$$bckg: $('<div class="waiting-background" style="display:none;z-index:2000"></div>'),
		$$wheel: $('<div class="waiting-wheel"  style="display:none;z-index:2000"></div>')
	};
	waitObject.$$bckg.appendTo($$parent);
	waitObject.$$wheel.appendTo($$parent);
	// Initialize plugin
	_waitPluginCreate(waitObject.$$wheel, _waitDefOpts);
	return waitObject;
};
/**
 * Destroy plugin
 */
var _waitPluginDestroy = function($$elmt) {
	/**
	 * We need to check data('waiting') because the plugin is not safe
	 * 	If no data('waiting') it fails
	 * 	That occurs if we remove a parent element of the plugin before destroying the plugin
	 */
	if ($$elmt && $$elmt.data('waiting')) {
		$$elmt.waiting("destroy");
		$$elmt.remove();
	}
};

var _waitPluginStatus = function($$elmt, status) {
	if ($$elmt && $$elmt.data('waiting')) {
		$$elmt.waiting(status);
		$$elmt[status === "disable" ? "hide" : "show"]();
	}
};

var _waitPluginCreate = function($$elmt, opts) {
	if (!opts) throw new Error("opts is mandatory");
	if ($$elmt) $$elmt.waiting(opts);
	return $$elmt;
};
var _waitWheelDestroy = function(waitObject) {
	if (waitObject) {
		_waitPluginDestroy(waitObject.$$wheel);
		if (waitObject.$$bckg) waitObject.$$bckg.remove();
	}
};
/**
 * Returns a dom element
 * - tag : html tag
 * - classList : array of classes
 * - content : dom.textContent
 * - attrList : various attributes list with key,value (JSON format)
 **/

var _createDomElement = function(tag, classList, content, attrList, parent) {
	if (!tag) {
		throw new Error("tag parameter is necessary !");
	}
	// create dom element
	var dom = document.createElement(tag);

	// append classes
	if (classList) {
		if ($.isArray(classList)) {
			$.each(classList, function(index, className) {
				dom.className += className + (index == classList.length - 1 ? "" : " ");
			});
		} else {
			if (typeof classList !== 'string') {
				throw new Error("classList parameter must be an array or a string");
			} else {
				dom.className += classList;
			}
		}
	}

	// set content
	dom.textContent = content ? content : "";

	if (tag === "a" || tag === "img") {
		// Disable drag - true by default for a and img
		attrList = attrList || {};
		attrList.draggable = "false";
	}
	if (attrList) {
		$.each(attrList, function(key, value) {
			dom.setAttribute(key, value);
		});
	}

	if (parent) {
		if (parent.jquery) {
			parent = parent.append(dom);
		} else {
			parent.appendChild(dom);
		}
	}

	return dom;
};

var _appendTextNode = function(e, text) {
	if (!e) return;
	var t = document.createTextNode(text || "");
	if (e.jquery) {
		e = e.append(t);
	} else {
		e.appendChild(t);
	}
	return e;
};
var _buildDom = function(domDesc, parent) {
	$.each(domDesc, function(nodeName, value) {
		var dom = _createDomElement(nodeName, value.classList, value.textContent, value.attr, parent);
		if (value.children) {
			$.each(value.children, function(index, childElement) {
				_buildDom(childElement, dom);
			});
		}
	});
};

exports.empty = _empty;
exports.toggleClass = _toggleClass;

exports.waitWheelStart = function(waitObject) {
	_wait(waitObject, true);
};
exports.waitWheelStop = function(waitObject) {
	_wait(waitObject, false);
};

exports.waitWheelCreate = _waitWheelCreate;
exports.waitWheelDestroy = _waitWheelDestroy;

/** Wait plugin SAFE call - SAFE if plugin has been remove from DOM*/
exports.waitPluginDestroy = _waitPluginDestroy;
exports.waitPluginCreate = _waitPluginCreate;
exports.waitPluginDisable = function($$elmt) {
	_waitPluginStatus($$elmt, "disable");
};
exports.waitPluginEnable = function($$elmt) {
	_waitPluginStatus($$elmt, "enable");
};

exports.createDomElement = _createDomElement;
exports.buildDom = _buildDom;

exports.appendTextNode = _appendTextNode;
/**
 * Trigger a global resize event for application
 * All layouts will be updated
 */
exports.triggerResizeInternal = function(opts) {
	$(window).triggerHandler("resizeInternal", [opts]);
};
exports.imgHeight2px = function(val) {
	val = val || "small";
	switch (val) {
		case "xsmall":
			return 25;
		case "small":
			return 50;
		case "medium":
			return 100;
		case "large":
			return 200;
		case "xlarge":
			return 300;
		default:
			return 100;
	}
};
});

define('syracuse-tablet/html/js/helpers/jsutils',['require','exports','module'],function (require, exports, module) {"use strict";

var _APP_RELEASE_REP = "/dist/";
var _APP_DVLP_REP = "/html/";
var _APP_RELEASE_INDEX = "index.html";
var _APP_DVLP_INDEX = "index_debug.html";
var _OPEN_LINK_IDEX = "open_link.html";

var _stringToHtml = function(str) {
	return (str || "").replace(/\n/g, "<br>");
};
var _strStartsWith = function(str, s) {
	if (!str || str.length == 0 || s == null || s.length === 0 || str.length < s.length) {
		return false;
	}
	return s.length === 1 ? str.charAt(0) === s.toString() : str.indexOf(s.toString()) === 0;
};
var _strEndsWith = function(str, s) {
	if (!str || str.length == 0 || s == null || str.length < s.length) {
		return false;
	}
	s = s.toString();
	return s.length === 1 ? str.charAt(str.length - 1) === s : str.lastIndexOf(s) === str.length - s.length;
};
var _strCapitalize = function(str) {
	if (!str || str.length === 0) {
		return str;
	}
	return str.charAt(0).toUpperCase() + str.slice(1);
};
/*
 * This module must only contain low level helper functions that do not have any dependencies!
 */
if (!window.exports) {
	// Trick - This file can be used in html pages outsite required loader - See open_link
	window.exports = window;
}
/** Parse an url 
 * !!! no @ character should be present in query params (keep them encoded)
 * There are @ query params in date where clauses
 **/
var _purlOptions = {
	strictMode: false,
	key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "querystring", "anchor"],
	q: {
		name: "query",
		parser: /(?:^|&)([^&=]*)=?([^&]*)/g
	},
	parser: {
		strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
		loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
	}
};
/*
 * {
  "anchor": "", "file": "", "password": "", "user": "", "userInfo": "",
  "querystring": "representation=AQTCRUDM.$edit",
  "directory": "/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies",
  "path": "/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies",
  "relative": "/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies?representation=AQTCRUDM.$edit",
  "port": "8124",
  "host": "pc101329.sagefr.adinternal.com",
  "authority": "pc101329.sagefr.adinternal.com:8124",
  "protocol": "http",
  "source": "http://pc101329.sagefr.adinternal.com:8124/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies?representation=AQTCRUDM.$edit",
  "query": {
    "representation": "AQTCRUDM.$edit"
  }
 */
var _parseURL = function(str) {
	var o = _purlOptions;
	var m = o.parser[o.strictMode ? "strict" : "loose"].exec(str);
	var uri = {};
	var i = 14;

	while (i--) uri[o.key[i]] = m[i] || "";

	uri[o.q.name] = {};
	uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) {
		if ($1) uri[o.q.name][$1] = decodeURIComponent($2);
	});
	return uri;
};
/**
 * Return a string url from u object which has been parsed with _parseURL
 */
var _urlToString = function(u) {
	if (!u) return "";
	var url = "";
	if (u.protocol && u.host) {
		url += u.protocol + "://" + u.host;
		if (u.port.length != 0) url += ":" + u.port;
	}
	url += u.directory ? u.directory.trim() : "";
	if (u.file) {
		if (!_strEndsWith(u.directory, "/")) {
			url += "/";
		}
		url += u.file;
	}
	var query = "";
	for (var p in u.query) {
		if (query.length != 0) query += "&";
		query += p + "=" + encodeURIComponent(u.query[p]);
	}
	if (query.length != 0) url += "?" + query;
	if (u.anchor) url += "#" + u.anchor;
	return url;
};
/**
 * Return the current url
 */
var _curUrl;
var _getCurrentUrl = function() {
	if (_curUrl) return _curUrl;
	_curUrl = _parseURL(window.location.href);
	return _curUrl;
};
/**
 * Returns the url that will contain the current page context to restore (ctx) (links, live tiles...)
 */
var _getOpenLinkUrl = function(ctxUuid) {
	var url = $.extend({}, exports.getCurrentUrl());
	// We open open_link.html that will remove the context from url and store it in sessionStorage (see _setUrlContextId)
	url.file = _OPEN_LINK_IDEX;
	if (ctxUuid) {
		if (!url.query) {
			url.query = {};
		}
		url.query.context = ctxUuid;
	}
	return exports.urlToString(url);
};
/**
 * Returns the context to restore if any (used by external links or live tiles to open a page)
 * Context has been stored by open_link.html page and removed from url (see getOpenLinkUrl, sessStorage)
 * return {endpoint:, applicationName:, history[state]}
 */
var _getUrlContextId = function() {
	// Read context in session storage if any (see open_link.html)
	var contextId;
	var sessStorage = typeof(window.sessionStorage) !== "undefined" ? window.sessionStorage : null;
	if (sessStorage) {
		contextId = sessStorage.getItem("__urlContext__");
		sessStorage.removeItem("__urlContext__");
	}
	if (!contextId) {
		// If no context check url context
		var url = exports.getCurrentUrl();
		contextId = url.quey ? url.query.context : null;
	}
	return contextId;
};
/**
 * Read url context and stores it in session storage if any
 * Remove the context param from url
 * Call idenx.htlk page
 */
var _setUrlContextId = function() {
	var sessStorage = typeof(window.sessionStorage) !== "undefined" ? window.sessionStorage : null;
	if (sessStorage) {
		sessStorage.removeItem("__urlContext__");
	}
	var url = _parseURL(window.location.href);
	try {
		var contextId = url.query && url.query.context;
		console.log("_setUrlContextId", contextId);
		if (sessStorage && contextId && contextId.trim().length > 0) {
			// Stores the context
			sessStorage.setItem("__urlContext__", contextId);
			// Remove it from url
			delete url.query.context;
		}
	} catch (e) {}
	// location.replace to prevent back button
	var file = url.file;
	url.file = url.path.indexOf(_APP_RELEASE_REP) > 0 ? _APP_RELEASE_INDEX : _APP_DVLP_INDEX;
	url.path = url.path.replace(file, url.file);
	window.location.replace(_urlToString(url));
};


var _isInstanceOf = function(o, name) {
	if (o == null) return false;
	var ctor = o.constructor;
	if (ctor && ctor.$smClasses) {
		return ctor.$smClasses.indexOf(name) > -1;
	}
	return false;
};

var _addInheritanceInfo = function(ctor, parent) {
	var classes = [];
	/**
	 * ctor.name comes from the constructor
	 *	var _Page = utils.defineClass(
	 *	function RegularPage($parent,
	 *	In that case name = "RegularPage"
	 */
	if (ctor.name) {
		classes.push(ctor.name);
	}
	/**
	 * FDB #7822 - we need to propagate $smClasses even if ctor.name == ""
	 * Otherwise we have to define a name for each constructor even if we just want to check the parent class name
	 * Eg: "SidePanel" - We don't want to add a constructor name for all child classes to test instanceOf ("SidePanel")
	 */
	if (parent && parent.$smClasses) {
		var i;
		for (i = 0; i < parent.$smClasses.length; i++) {
			classes.push(parent.$smClasses[i]);
		}
	}
	ctor.$smClasses = classes;
};

var _isError = function(o) {
	return o && Error.prototype.toString === o.toString;
};

var _isException = function(o) {
	return o && o.constructor && o.constructor.name === "DOMException";
};

/** 
 * Clean error stack from current base url and limit the size due to the use of deferred
 * html: true -> Display in Html
 **/
var _stackRegexp;
var _cleanStack = function(stack, max, html) {
	if (Array.isArray(stack)) return stack;
	var globals = window.$sm;
	if (!globals) return stack;
	if (!_stackRegexp && globals && globals.baseLocation()) {
		_stackRegexp = {
			r1: new RegExp(globals.baseLocation().withPath, "g"),
			r2: new RegExp(globals.baseLocation().requirePath, "g")
		};
	}

	max = max == null ? 5 : max;
	if (stack) {
		var array = (stack.split && stack.split("\n")) || stack;;
		var res;
		if (array.length > 0) {
			array.forEach(function(l) {
				var pos1 = l.lastIndexOf(".js");
				if (pos1 > 0) {
					var pos2 = l.lastIndexOf("/", pos1);
					if (pos1 > 0) {
						if (!res) res = [];
						res.push(l.substring(pos2));
					}
				} else {
					// Unknown line format (to include details at end of stack, just add line here)
					if (!res) res = [];
					res.push(l);
				}
			});
		}
		if (!res && _stackRegexp) {
			stack = _stackRegexp ? stack.replace(_stackRegexp.r1, "").replace(_stackRegexp.r2, "") : stack;
		} else {
			stack = res.join('\n');
		}
	} else {
		stack = "";
	}
	stack = stack.split("\n");
	if (max) { // Allow max level of source stack files, stack elements not pointing to a file are always added since the may include important information
		res = [];
		stack.forEach(function(l) {
			if (l.indexOf(".js") > -1) {
				if (max > 0) {
					res.push(l);
					max--;
				}
			} else {
				res.push(l);
			}
		});
		stack = res.join(html ? "<br>&nbsp&nbsp&nbsp&nbsp&nbsp" : "\n");
	}
	return stack;
};

/*
 * Takes what ever is passed as parameter and creates an object containing and $diagnoses array
 * title: Always a string
 * e: String or Error or any kind of object*
 *
 * object*:
 * {
 *   message: "text",
 *   detail: Error or Object
 * }
 *
 */
var _convertToDiagnoses = function(e, html) {
	if (e == null) {
		e = "No error message";
	}
	if (typeof e === "string") {
		// String message
		return {
			$diagnoses: [{
				$severity: "error",
				$message: html ? _stringToHtml(e) : e
			}]
		};
	} else if (_isError(e) || _isException(e)) {
		// Exception to diagnoses
		return {
			$diagnoses: [{
				$message: html ? _stringToHtml(e.message) : e.message,
				$stackTrace: _cleanStack(e.stack, null, html),
				$severity: "error"
			}]
		};
	} else {
		// If parameter is already an object with diagnoses, do not do anything special
		if (e.$diagnoses && Array.isArray(e.$diagnoses)) {
			return e;
		}
		// Arbitrary object
		var res = {
			$diagnoses: []
		};
		var diag = {
			$severity: "error",
			$message: e.message || e.$message || e.$title || "No error message"

		};
		if (html) {
			diag.$message = _stringToHtml(diag.$message);
		}
		res.$diagnoses.push(diag);
		var detail = e.detail;
		if (detail) {
			if (_isError(detail)) {
				if (detail.message) {
					diag.$stackTrace = (diag.$stackTrace ? diag.$stackTrace + "\n" : "") + detail.message;
				}
				if (detail.stack) {
					diag.$stackTrace = (diag.$stackTrace ? diag.$stackTrace + "\n" : "") + _cleanStack(detail.stack, null, html);
				}
			} else {
				diag.$stackTrace = (diag.$stackTrace ? diag.$stackTrace + "\n" : "") + JSON.stringify(detail);
			}
		}
		var xe = e;
		while (xe.$exception != null) {
			_$exceptionAdd(res, xe.$exception, html);
			xe = xe.$exception;
		}
		return res;
	}
};
// $exception returned by storage in addition to $message
var _$exceptionAdd = function(res, $exception, html) {
	if (!$exception) return;
	var msg = typeof $exception === "string" ? $exception : $exception.message || $exception.$message;
	var stk = $exception.stack;
	if (msg || stk) {
		res.$diagnoses.push({
			$message: html ? _stringToHtml(msg) : msg,
			$stackTrace: stk ? _cleanStack(stk, null, html) : "",
			$severity: "error"
		});
	}
};
/**
 * return the value of a given path
 * 	path:	String with/without '.' as separator or array of strings
 *  cache: 	null	-> No cache
 * 		    !null	-> object that stores the cache
 */
var _getPropByPath = function(object, path, cache) {
	if (path == null || object == null) return null;
	var pathStr, pathArray;
	if (Array.isArray(path)) {
		if (path.length === 0) return null;
		pathArray = path;
		pathStr = pathArray.join(".");
	} else {
		pathArray = path.split('.');
		pathStr = path;
	}
	if (cache && cache[pathStr] != null) {
		return cache[pathStr];
	}
	// Check parent if needed
	var data = object[pathArray[0]];
	for (var i = 1; i < pathArray.length; i++) {
		if (data == null) return null;
		if (!$.isPlainObject(data) == null) {
			throw new Error('_getPropByPath - Unexpected non-plainobject');
		}
		data = data[pathArray[i]];
	}
	if (cache) {
		cache[pathStr] = data;
	}
	return data;
};


/**
 * simple function bind
 * arguments that follow context are passed to fn call back after the regular parameters
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
	var args = arguments.length > 2 ? Array.prototype.splice.call(arguments, 2) : null;
	return function boundFn() {
		var callBackArgs = arguments;
		if (args && args.length > 0) {
			args.forEach(function(a) {
				Array.prototype.push.call(callBackArgs, a);
			});
		}
		return fn.apply(context ? context : this, callBackArgs);
	};
}
//http://jsperf.com/multi-array-concat/7
// concatArrays(array1, array2, array3...) - accept undefined arguments
exports.concatArrays = function() {
	var args = [];
	for (var i = 0; i < arguments.length; i++) {
		if (arguments[i] != null) args.push(arguments[i]);
	}
	return [].concat.apply([], args);
};
exports.getPropByPath = _getPropByPath;
exports.addInheritanceInfo = _addInheritanceInfo;

/**
 * return true if o is an instance of class 'name'
 * Like this process could slow down the application it's better to register only classes for which we want to check instance
 */
exports.isInstanceOf = _isInstanceOf;

exports.isError = _isError;

exports.cleanStack = _cleanStack;

exports.convertToDiagnoses = _convertToDiagnoses;

exports.bindFn = bindFn;

exports.getCurrentUrl = _getCurrentUrl;
exports.getOpenLinkUrl = _getOpenLinkUrl;
exports.getUrlContextId = _getUrlContextId;
exports.setUrlContextId = _setUrlContextId;
exports.parseURL = _parseURL;
exports.urlToString = _urlToString;
exports.strStartsWith = _strStartsWith;
exports.strEndsWith = _strEndsWith;
exports.strCapitalize = _strCapitalize;
exports.isReleaseVersion = function() {
	return document.location.href.indexOf("/index_debug.html") < 0 && document.location.href.indexOf("/index_release.html") < 0;
};
exports.isDvlpVersion = function() {
	return window.location.href.indexOf("/index_debug.html") > -1 || window.location.href.indexOf("/index_joined.html") > -1;
};
exports.isTestEnvironment = function() {
	return window.location.href.indexOf("/syracuse-tablet/test/index.html") > -1;
};
exports.getResourcesBasePath = function() {
	if (exports.isReleaseVersion()) {
		return "/syracuse-tablet" + _APP_RELEASE_REP;
	} else {
		return "/syracuse-tablet" + _APP_DVLP_REP;
	}
};
});

define('syracuse-tablet/html/js/helpers/serverLog',['require','exports','module'],function (require, exports, module) {"use strict";

var sdataHost = (window.location.protocol.toLowerCase() === "file:") ? "" : (window.location.protocol + "//" + window.location.host);

// Url that allow logging even if user is not authenticated
var _logWriteUrl = "/requireJS/log/write?text=";

var lastlog = new Date();
var num = 0;
var lastlog;
var _maxLevel = 0;

function line(text) {
	if (!text) return null;
	var now = new Date(),
		trace = null;
	if (lastlog == null || ((now.getTime() - lastlog.getTime()) > 1000)) {
		text = "********Mobile********\n" + (++num) + ": " + text;
		lastlog = now;
	}
	return text;
}
var _stdTypeToString = function(a, type) {
	if (a == null) return null;
	type = type || typeof a;
	switch (type) {
		case "number":
		case "string":
		case "boolean":
			return new String(a);
			break;
	}
	return null;
};
var _objectToString = function(a, level, flat) {
	level = level == null ? 0 : level;
	if (a == null) return null;
	if (typeof a != "object") return null;
	var res, v;
	if (Array.isArray(a)) {
		res = [];
		a.forEach(function(b) {
			v = _stdTypeToString(b);
			if (v) {
				res.push(v);
			} else if (flat !== true && level <= _maxLevel) {
				v = _objectToString(b, level + 1);
				if (v) {
					res.push(v);
				}
			}
		});
		if (res.length == 0) return null;;
	} else {
		res = {};
		for (var p in a) {
			var v = _stdTypeToString(a[p]);
			if (v) {
				res[p] = v;
			} else if (flat !== true && level <= _maxLevel) {
				v = _objectToString(a[p], level + 1);
				if (v) {
					res[p] = v;
				}
			}
		}
		if ($.isEmptyObject(res)) res = null;
	}
	return level == 0 ? JSON.stringify(res, null, 2) : res;
};
var _argsToString = function(args, flat) {
	var msg = [];
	for (var i = 0; i < args.length; i++) {
		var a = args[i];
		if (a == null) continue;
		var text = _stdTypeToString(a);
		if (text) {
			msg.push(text);
		} else {
			text = _objectToString(a, 0, flat);
			if (text) {
				msg.push(text);
			}
		}
	}
	if (msg.length == 0) return null;
	return msg.join(' ');
};
var _log = function(msg) {
	msg = line(msg);
	if (msg == null) return null;
	$.ajax({
		type: "GET",
		async: false,
		url: sdataHost + _logWriteUrl + encodeURIComponent(msg),
		success: function(xhr) { /* fire and forget */ }
	});
};
exports.log = function() {
	_log(_argsToString(arguments, false));
};
exports.logFlat = function() {
	_log(_argsToString(arguments, true));
};
});

define('syracuse-tablet/html/js/helpers/logger',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/serverLog'],function (require, exports, module) {"use strict";

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var serverLog = require('syracuse-tablet/html/js/helpers/serverLog');

// true to log on Syracuse server console
var _logOnServer = false;

var _log;

if (window.smNativeLogger && window.smNativeLogger.log) {
	_log = function() {
		var args = [];
		for (var i = 0; i < arguments.length; i++) {
			args.push(arguments[i]);
		}
		window.smNativeLogger.log(args.join(""));
	};
} else {
	var _console = _logOnServer === true ? serverLog : window.console;
	_log = function() {
		if (!_console) return;
		var text = [];
		for (var i = 0; i < arguments.length; i++) {
			var a = arguments[i];
			if (a != null) {
				if (jsutils.isError(a))
					_console && _console.log && _console.log(a.message, "\n", jsutils.cleanStack(a.stack));
				else
					text.push(a);
			}
		}
		_console && _console.log && _console.log(text.join(text, " "));
	};
}
if (window) {
	window.logger = _log;
}

function _getLogger(module, force) {
	// if (module && module.indexOf("native") > -1) force = true;
	if (!(force === true)) {
		return null;
	}
	var logger = function() {
		var text, errs;
		for (var i = 0; i < arguments.length; i++) {
			if (jsutils.isError(arguments[i])) {
				if (!errs) errs = [];
				errs.push(arguments[i]);
			} else {
				if (!text) text = ["[" + module + "]: "];
				text.push(arguments[i]);
			}
		}
		if (text && text.length > 1) _log(text.join(" "));
		if (errs) {
			errs.forEach(function(e) {
				_log("[" + module + "]: " + e.message);
				if (e.stack) _log(jsutils.cleanStack(e.stack));
			});
		}
	};
	return logger;
}

exports.log = _log;
exports.getLogger = _getLogger;
});

define('syracuse-tablet/html/js/helpers/uiSettings',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {"use strict";
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
// No required here
var _cache = {};
var _getProp = function(path, device, orientation) {
	if (path == null || arguments.length === 0) return null;
	var res = jsutils.getPropByPath(_settings.gen, path, _cache);
	if (res == null) return null;
	if (device && res[device]) {
		res = res[device];
	}
	if (orientation && res[orientation]) {
		res = res[orientation];
	}
	if (typeof res === "function") {
		res = res.call(null, device, orientation);
		_cache[Array.isArray(path) ? path.join('.') : path] = res;
	}
	// console.log(path, res);
	return res;
};
/**
 * SETTINGS
 */
var _settings = {
	ios: null,
	android: null,
	windows: null,
	/*
	surface: {
		footer: {
			height: {
				opened: 100,
				closed: 40
			}
		},
		header: {
			height: 100
		}
	},
	*/
	def: {
		hubLayout: {
			groupSpacing: 55,
			landscapeMinHeigth: function() {
				return _getProp("hubGroup.landscapeBaseSize") * 4 + _getProp("hubGroup.landscapePadY") * 5 + 40;
			}
		},
		hubGroup: {
			// Default Base size
			// Allows 8 cells from left to right on Nexus 7 portrait mode, 
			// all other devices use a bigger, recalculated base sizes
			landscapeBaseSize: 66,
			landscapePadX: 8,
			landscapePadY: 8,
			portraitPadX: 8,
			portraitPadY: 8,
			portraitWideMinWidth: 570
		},
		footer: {
			height: 50
		},
		header: {
			height: 50
		},
		breadcrumbs: {
			height: 25
		},
		chartDetailToolbar: {
			height: 40
		}
	}
};
/**
 * typeObject 	hubLayout/footer/header/..
 * path			height/groupSpacing...
 * device		tablet/smartphone
 * orientation	portrait/landscape
 */
exports.getProp = _getProp;
exports.init = function(os) {
	_cache = {};
	_settings.gen = $.extend(true, {}, _settings.def, _settings[os]);
};
});

define('syracuse-tablet/html/js/helpers/native/nativeExtCall',['require','exports','module','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {"use strict";

/*
 * This module is called JS to call methods in an by an external wrapper
 */

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeExtCall");

var _testMode = false;

/**
 * True is application runs inside a wrapper native or Javascript
 */
exports.isNativeModeEnabled = function() {
	return (window && window.smNativeInterface) || _testMode === true;
};
/**
 * Call a native method if it is available.
 * Will return true if method is available and method call returns true
 * Otherwise returns false
 */
exports.isSupported = function(domain, method) {
	var sup = false;

	domain = domain || "";
	method = method || "";

	log && log("Natve: isSupported (" + domain + ", " + method + ")");
	var caller = window && window.smNativeInterface && window.smNativeInterface.isSupported;
	if (caller && !_testMode) {
		// Do not change to caller.isSupported it will not work!!!;
		sup = window.smNativeInterface.isSupported(domain, method);
	} else if (_testMode) {
		// Arguments here should be 100% equal to the ones used for window.smNativeInterface.isSupported
		// to allow exact validation
		sup = _isSupportedTest(domain, method);
	} else {
		log && log("Natve: isSupported no such interface");
	}
	log && log("->" + sup);
	return sup;
};

/**
 * Call a native method and receive a return value
 */
exports.callMethod = function(domain, method, data) {
	var ret;

	var param = data;
	if (param != null && typeof param !== "string") {
		param = JSON.stringify(param);
	}
	domain = domain || "";
	method = method || "";
	param = param || "";

	log && log("Natve: callMethod (" + domain + ", " + method + "): " + param);
	var caller = window && window.smNativeInterface && window.smNativeInterface.callMethod;
	if (caller && !_testMode) {
		// Do not change to caller.callMethod it will not work!!!
		ret = window.smNativeInterface.callMethod(domain, method, param);
		try {
			ret = JSON.parse(ret);
		} catch (e) {}
	} else if (_testMode) {
		// Arguments here should be 100% equal to the ones used for window.smNativeInterface.callMethod
		// to allow exact validation
		ret = _callMethodTest(domain, method, param);
		try {
			ret = JSON.parse(ret);
		} catch (e) {}
	} else {
		log && log("Natve: callMethod no such interface");
	}
	return ret;
};

/**
 * Call a native method (fire and forget with no return value)
 */
exports.fireMethod = function(domain, method, data) {
	var param = data;
	if (param != null && typeof param !== "string") {
		param = JSON.stringify(param);
	}
	domain = domain || "";
	method = method || "";
	param = param || "";

	log && log("Natve: fireMethod (" + domain + ", " + method + "): " + param);
	var caller = window && window.smNativeInterface && window.smNativeInterface.fireMethod;
	if (caller && !_testMode) {
		// Do not change to caller.fireMethod it will not work!!!
		window.smNativeInterface.fireMethod(domain, method, param);
	} else if (_testMode) {
		// Arguments here should be 100% equal to the ones used for window.smNativeInterface.fireMethod
		// to allow exact validation
		_fireMethodTest(domain, method, param);
	} else {
		log && log("Natve: fireMethod no such interface");
	}
};

function _isSupportedTest(domain, method) {
	var obj = window[domain];
	var caller = obj && obj[method];
	if (!caller) {
		log && log("_isSupportedTest: No such method: window." + domain + "." + method);
		return false;
	}
	var sup = caller.call(obj);
	return sup;
}

/**
 *
 */
function _callMethodTest(domain, method, param) {
	var obj = window[domain];
	var caller = obj && obj[method];
	if (!caller) {
		log && log("_callMethodTest: No such method: window." + domain + "." + method);
		return null;
	}
	var ret = caller.call(obj, param);
	return ret;

}

/**
 *
 */
function _fireMethodTest(domain, method, param) {
	var obj = window[domain];
	var caller = obj && obj[method];
	if (!caller) {
		log && log("_fireMethodTest: No such method: window." + domain + "." + method);
		return null;
	}
	caller.call(obj, param);
}

exports.init = function(testMode) {
	_testMode = testMode === true;
};
});

/*!
  * Bowser - a browser detector
  * https://github.com/ded/bowser
  * MIT License | (c) Dustin Diaz 2015
  */

!function (name, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define('syracuse-tablet/html/deps/bowser/bowser',definition)
  else this[name] = definition()
}('bowser', function () {
  /**
    * See useragents.js for examples of navigator.userAgent
    */

  var t = true

  function detect(ua) {

    function getFirstMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[1]) || '';
    }

    function getSecondMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[2]) || '';
    }

    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
      , likeAndroid = /like android/i.test(ua)
      , android = !likeAndroid && /android/i.test(ua)
      , chromeBook = /CrOS/.test(ua)
      , edgeVersion = getFirstMatch(/edge\/(\d+(\.\d+)?)/i)
      , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
      , tablet = /tablet/i.test(ua)
      , mobile = !tablet && /[^-]mobi/i.test(ua)
      , result

    if (/opera|opr/i.test(ua)) {
      result = {
        name: 'Opera'
      , opera: t
      , version: versionIdentifier || getFirstMatch(/(?:opera|opr)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/yabrowser/i.test(ua)) {
      result = {
        name: 'Yandex Browser'
      , yandexbrowser: t
      , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/windows phone/i.test(ua)) {
      result = {
        name: 'Windows Phone'
      , windowsphone: t
      }
      if (edgeVersion) {
        result.msedge = t
        result.version = edgeVersion
      }
      else {
        result.msie = t
        result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/msie|trident/i.test(ua)) {
      result = {
        name: 'Internet Explorer'
      , msie: t
      , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
      }
    } else if (chromeBook) {
      result = {
        name: 'Chrome'
      , chromeBook: t
      , chrome: t
      , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    } else if (/chrome.+? edge/i.test(ua)) {
      result = {
        name: 'Microsoft Edge'
      , msedge: t
      , version: edgeVersion
      }
    }
    else if (/chrome|crios|crmo/i.test(ua)) {
      result = {
        name: 'Chrome'
      , chrome: t
      , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    }
    else if (iosdevice) {
      result = {
        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
      }
      // WTF: version is not part of user agent in web apps
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if (/sailfish/i.test(ua)) {
      result = {
        name: 'Sailfish'
      , sailfish: t
      , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/seamonkey\//i.test(ua)) {
      result = {
        name: 'SeaMonkey'
      , seamonkey: t
      , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/firefox|iceweasel/i.test(ua)) {
      result = {
        name: 'Firefox'
      , firefox: t
      , version: getFirstMatch(/(?:firefox|iceweasel)[ \/](\d+(\.\d+)?)/i)
      }
      if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
        result.firefoxos = t
      }
    }
    else if (/silk/i.test(ua)) {
      result =  {
        name: 'Amazon Silk'
      , silk: t
      , version : getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
      }
    }
    else if (android) {
      result = {
        name: 'Android'
      , version: versionIdentifier
      }
    }
    else if (/phantom/i.test(ua)) {
      result = {
        name: 'PhantomJS'
      , phantom: t
      , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
      result = {
        name: 'BlackBerry'
      , blackberry: t
      , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/(web|hpw)os/i.test(ua)) {
      result = {
        name: 'WebOS'
      , webos: t
      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
      };
      /touchpad\//i.test(ua) && (result.touchpad = t)
    }
    else if (/bada/i.test(ua)) {
      result = {
        name: 'Bada'
      , bada: t
      , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
      };
    }
    else if (/tizen/i.test(ua)) {
      result = {
        name: 'Tizen'
      , tizen: t
      , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
      };
    }
    else if (/safari/i.test(ua)) {
      result = {
        name: 'Safari'
      , safari: t
      , version: versionIdentifier
      }
    }
    else {
      result = {
        name: getFirstMatch(/^(.*)\/(.*) /),
        version: getSecondMatch(/^(.*)\/(.*) /)
     };
   }

    // set webkit or gecko flag for browsers based on these engines
    if (!result.msedge && /(apple)?webkit/i.test(ua)) {
      result.name = result.name || "Webkit"
      result.webkit = t
      if (!result.version && versionIdentifier) {
        result.version = versionIdentifier
      }
    } else if (!result.opera && /gecko\//i.test(ua)) {
      result.name = result.name || "Gecko"
      result.gecko = t
      result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i)
    }

    // set OS flags for platforms that have multiple browsers
    if (!result.msedge && (android || result.silk)) {
      result.android = t
    } else if (iosdevice) {
      result[iosdevice] = t
      result.ios = t
    }

    // OS version extraction
    var osVersion = '';
    if (result.windowsphone) {
      osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
    } else if (iosdevice) {
      osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (android) {
      osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
    } else if (result.webos) {
      osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
    } else if (result.blackberry) {
      osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
    } else if (result.bada) {
      osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
    } else if (result.tizen) {
      osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
    }
    if (osVersion) {
      result.osversion = osVersion;
    }

    // device type extraction
    var osMajorVersion = osVersion.split('.')[0];
    if (tablet || iosdevice == 'ipad' || (android && (osMajorVersion == 3 || (osMajorVersion == 4 && !mobile))) || result.silk) {
      result.tablet = t
    } else if (mobile || iosdevice == 'iphone' || iosdevice == 'ipod' || android || result.blackberry || result.webos || result.bada) {
      result.mobile = t
    }

    // Graded Browser Support
    // http://developer.yahoo.com/yui/articles/gbs
    if (result.msedge ||
        (result.msie && result.version >= 10) ||
        (result.yandexbrowser && result.version >= 15) ||
        (result.chrome && result.version >= 20) ||
        (result.firefox && result.version >= 20.0) ||
        (result.safari && result.version >= 6) ||
        (result.opera && result.version >= 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
        (result.blackberry && result.version >= 10.1)
        ) {
      result.a = t;
    }
    else if ((result.msie && result.version < 10) ||
        (result.chrome && result.version < 20) ||
        (result.firefox && result.version < 20.0) ||
        (result.safari && result.version < 6) ||
        (result.opera && result.version < 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
        ) {
      result.c = t
    } else result.x = t

    return result
  }

  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent : '')

  bowser.test = function (browserList) {
    for (var i = 0; i < browserList.length; ++i) {
      var browserItem = browserList[i];
      if (typeof browserItem=== 'string') {
        if (browserItem in bowser) {
          return true;
        }
      }
    }
    return false;
  }

  /*
   * Set our detect method to the main bowser object so we can
   * reuse it to test other user agents.
   * This is needed to implement future tests.
   */
  bowser._detect = detect;

  return bowser
});

define('syracuse-tablet/html/js/helpers/mobileDetect',['require','exports','module','syracuse-tablet/html/deps/bowser/bowser'],function (require, exports, module) {"use strict";

/**
 * Npm module that detects browsers - Used on desktop
 */
var _bowser = require('syracuse-tablet/html/deps/bowser/bowser');

var _defaultOS = "windows";

/**
 * Default initialization
 * http://hgoebl.github.io/mobile-detect.js/doc/MobileDetect.html#MobileDetect
 */
var _MobileDetect = (function() {
	return window.MobileDetect ? new window.MobileDetect(window.navigator.userAgent) : null;
})();

/**
 * called by application when user agent has changed (test device on chrome degugger)
 */
exports.init = function(log) {
	if (_bowser && _bowser._detect) {
		_bowser = _bowser._detect(window.navigator.userAgent);
	}
	_MobileDetect = window.MobileDetect ? new window.MobileDetect(window.navigator.userAgent) : null;
	if (log) {
		log("User agent Name", window.navigator.userAgent);
		log("Browser Name: ", exports.getBrowserName());
		log("Browser OS: ", _MobileDetect.os());
		log && log("Browser OS Style: ", exports.getStyleOS());
	}
};
//Returns the os for style ios/windows/android
exports.getStyleOS = function() {
	var os = _MobileDetect == null ? _defaultOS : _MobileDetect.os();
	switch (os) {
		case "AndroidOS":
			return "android";
		case "WindowsMobileOS":
		case "WindowsPhoneOS":
			return "windows";
		case "iOS":
			return "ios";
		case "PalmOS":
		case "BlackBerryOS":
		case "MeeGoOS":
		case "MaemoOS":
		case "JavaOS":
		case "webOS":
		case "badaOS":
		case "BREWOS":
		case "SymbianOS":
		default:
			return _defaultOS;
	}
};
// check ios/windows/android
// http://hgoebl.github.io/mobile-detect.js/doc/MobileDetect.html#os
exports.isOs = function(os) {
	if (_MobileDetect == null) {
		return os === _defaultOS;
	}
	switch (_MobileDetect.os()) {
		case "AndroidOS":
			return os === "android";
		case "WindowsMobileOS":
		case "WindowsPhoneOS":
			return os === "windows";
		case "iOS":
			return os === "ios";
		case "PalmOS":
		case "BlackBerryOS":
		case "MeeGoOS":
		case "MaemoOS":
		case "JavaOS":
		case "webOS":
		case "badaOS":
		case "BREWOS":
		case "SymbianOS":
		default:
			return os === _defaultOS;
	}
};
// http://hgoebl.github.io/mobile-detect.js/doc/MobileDetect.html#mobile
exports.isMobile = function() {
	return _MobileDetect && _MobileDetect.mobile() !== null;
};
var _mobileDetectCheckBrowser = function(name, log) {
	if (_MobileDetect == null) return null;
	var res = _MobileDetect.userAgent();
	if (!res) return null;
	res = res.toLowerCase();
	res = (res === "ie" && name === "msie") || res === name;
	if (res === true) {
		log && log(name, "detect by mobile-detect");
	}
	return res;
};
var _bowserCheckBrowser = function(name, log) {
	if (_bowser == null) return null;
	var res = _bowser[name] === true;
	if (res === true) {
		log && log(name, "detect by bowser");
	}
	return res;
};
var _checkBrowserName = function(name, log) {
	// use bowser for desktop and mobile-detect for mobile
	// FDB I did a lot of tests and it's the better way
	// - Eg safari on IOS is not detected as Safari by bowser but mobile-detect doesn't detect correctly browser on a desktop...
	var res = (exports.isMobile() ? _mobileDetectCheckBrowser : _bowserCheckBrowser)(name, log);
	if (res == null) {
		res = (exports.isMobile() ? _bowserCheckBrowser : _mobileDetectCheckBrowser)(name, log);
	}
	return res;
};
/** Key (case insensitive):
 * Accepts chrome, firefox, msie, msedge, opera, phantom, safari, seamonkey
 * Accepts multiple arguments msie, msedge...
 */
exports.checkBrowserName = function() {
	var result = false,
		name, bn;
	for (var i = 0; i < arguments.length; i++) {
		result = result || _checkBrowserName(arguments[i].toLowerCase());
	}
	return result;
};
/**
 * Just for info
 */
exports.getBrowserName = function() {
	var res = exports.isMobile() ? _MobileDetect.userAgent() : _bowser.name;
	if (res == null) {
		res = exports.isMobile() ? _bowser.name : _MobileDetect.userAgent();
	}
	return res ? res.toLowerCase() : "Not detected";
};
exports.getOsName = function() {
	return _MobileDetect.os() || "Not detected";
};
exports.testBrowserName = function(log) {
	var result = {};
	["chrome", "firefox", "msie", "msedge", "opera", "phantom", "safari", "seamonkey"].forEach(function(b) {
		result[b] = _checkBrowserName(b, log);
	});
	//log && log(JSON.stringify(_bowser, null, 2));
	log && log(JSON.stringify(result, null, 2));
	return result;
};

exports.init();
});

define('syracuse-tablet/html/js/helpers/globals',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/uiSettings','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/native/nativeExtCall','syracuse-tablet/html/js/helpers/mobileDetect'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("globals", false);
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');
var mobileDetect = require('syracuse-tablet/html/js/helpers/mobileDetect');



var _notifUserAgentChanged = function() {
	// First
	mobileDetect.init(log);
	_globals.isMobile = mobileDetect.isMobile();
	_globals.isTestNativeWrapper = false;
	try {
		var _url = jsutils.getCurrentUrl();
		// FDB I don't know who added isDesktop (we should remove it)
		_globals.isTestNativeWrapper = _url.query != null && (_url.query.testNativeWrapper === "true" || _url.query.isDesktop === "true");
	} catch (e) {}
	$(document.body).toggleClass("s-m-mobile-device", _globals.isMobile === true).attr({
		"data-style": mobileDetect.getStyleOS(),
		"data-browser": mobileDetect.getBrowserName(),
		"data-os": mobileDetect.getOsName()
	});
	log && log("Is mobile", _globals.isMobile, "is TestNativeWrapper", _globals.isTestNativeWrapper);
};

var _metaData;
var _authoringActive;
var _emptyCacheCtx = {
	"$user": "none",
	"$role": "none",
	"$lang": "none"
};

var _devOpts = {
	showUnfoundFields: false
};
var _controllersMap = {};

var _globals = {
	tabletApplication: null,
	userCtx: null,
	isTestEnvironment: false,
	baseLocation: null,
	isDvlpMode: false,
	storage: null,
	cache: null,
	modal: null,
	cacheCtx: $.extend({}, _emptyCacheCtx),
	lookAndFeel: "windows",
	userProfile: {},
	userProfileLocales: {}
};

(function() {
	_notifUserAgentChanged();
})();

var _clearUserCtx = function(userCtx) {
	return _setUserCtx(null);
};

var _setUserCtx = function(userCtx) {
	log && log("Set user context");
	var ctx = userCtx == null ? $.extend({}, _emptyCacheCtx) : userCtx;

	_globals.cache.setContext(ctx);
	_globals.cacheCtx = ctx;
	if (exports.isAutoUITestMode()) {
		exports.getUnitTestMgr().notifUserCtxChanged(ctx, exports.getEndpoint());
	}
	return _globals.userCtx = ctx;
};

var _setTabletApplication = function(appObj) {
	if (!appObj) {
		throw new Error("Null tabletApplication object");
	}
	log && log("Set tablet Application object");
	_globals.tabletApplication = appObj;
	return appObj;
};
var _isNativeScrollingStatus = null;

/**
 * Called by main.js
 */
var _init = function(dvlpMode, storage, cache, utilsModule) {
	_globals.isDvlpMode = dvlpMode;
	var bl = _globals.baseLocation = {};
	bl.host = window.location.protocol + "//" + window.location.host;
	var path = window.location.pathname.split('/').splice(0, 2).join('/');
	bl.withPath = bl.host + path;
	bl.requirePath = bl.host + "/requireJS" + path;
	bl.htmlRoot = bl.withPath + "/html";
	bl.url = bl.host + window.location.pathname;
	if (utilsModule) bl.query = utilsModule.parseQueryString();
	_globals.isTestEnvironment = jsutils.isTestEnvironment();
	_globals.storage = storage;
	_globals.cache = cache;
	_globals.unitTestMode = bl.query && bl.query.unitTestMode === "true";
};
exports.fallbackLocaleCode = "en-US";

/*************************************************************
 * APPLICATIONS DATA
 ************************************************************/
exports.isLoggedIn = function() {
	return _globals.userCtx != null && _globals.userCtx.$user !== "none";
};
exports.getUserCtx = function() {
	return _globals.userCtx;
};
exports.getGlobalCtx = function() {
	return _globals;
};
exports.getStorage = function() {
	return _globals.storage;
};
exports.getCache = function() {
	return _globals.cache;
};
exports.getCacheCtx = function() {
	return _globals.cacheCtx;
};
exports.getEmptyCacheCtx = function() {
	return _emptyCacheCtx;
};
exports.getEndpoint = function() {
	return _globals.endpoint;
};
exports.getEndpointDescr = function() {
	return _globals.endpointDescr;
};
exports.setEndpoint = function(ep, epDescr) {
	_globals.endpoint = ep;
	_globals.endpointDescr = epDescr || ep;
	if (exports.isAutoUITestMode()) {
		exports.getUnitTestMgr().notifUserCtxChanged(exports.getUserCtx(), ep);
	}
};
exports.notifUserAgentChanged = _notifUserAgentChanged;
/*
 * Returns of the application is physically running on a desktop PC
 * This function MUST ignore eventually emulation properties set by authoring
 */
exports.isDesktop = function() {
	return _globals.isMobile !== true;
};
exports.isNativeModeEnabled = function() {
	return nativeExtCall.isNativeModeEnabled();
};
exports.isMobile = function() {
	return _globals.isMobile === true;
};
exports.isNativeScrolling = function() {
	if (exports.isMobile()) {
		return true;
	}
	if (_isNativeScrollingStatus == null) {
		_isNativeScrollingStatus = nativeExtCall.isSupported("smApp", "NativeScrollingSupported");
	}
	return _isNativeScrollingStatus;
};
exports.isTestNativeWrapper = function() {
	return exports.isDesktop() && _globals.isTestNativeWrapper;
};
/**
 * Just to optimize the management of events
 */
exports.isDebugDeviceSimlator = function() {
	return exports.isMobile() && window.smNativeInterface == null;
};
exports.isDevelopmentModeAllowed = function() {
	return exports.isDesktop() && !exports.isNativeModeEnabled() && exports.isDvlpMode();
};
exports.isAuthoringModeAllowed = function() {
	return exports.isDesktop() && !exports.isNativeModeEnabled() && exports.getAuthoringLevel() !== "none";
};
exports.$config = function(prop) {
	return _globals.tabletApplication.$config(prop);
};
exports.setUserProfile = function(up) {
	if (!up || !up.user || !up.selectedRole || !up.selectedLocale) {
		throw new Error("Unexpected " + (up ? "bad" : "null") + " user profile");
	}
	if (up.selectedEndpoint) {
		// SelectedEndpoint can be null if no endpoint is assigned to the user (regular login service doesn't check it)
		// It's check when we get the user profile settings (our own service)
		// So we accept selectedEndpoint==null to let Syracuse return and error when we call sdata/syracuse/collaboration/syracuse/userProfiles/$service/settings
		exports.setEndpoint(up.selectedEndpoint.application + "." + up.selectedEndpoint.contract + "." + up.selectedEndpoint.dataset, up.selectedEndpoint.description);
	}
	// Set user context for consistency until the user change it
	exports.setUserCtx({
		"$user": up.user.$value,
		"$role": up.selectedRole.code,
		"$lang": up.selectedLocale.code
	});
	_globals.userProfileLocales = {};
	if (up.user.locales) {
		// Profile is able to return a customization of locales formats
		up.user.locales.forEach(function(locale) {
			_globals.userProfileLocales[locale.code] = {
				shortDate: locale.shortDate,
				shortTime: locale.shortTime,
				longTime: locale.longTime,
				numberDecimalSeparator: locale.numberDecimalSeparator,
				numberGroupSeparator: locale.numberGroupSeparator
			};
		});
	}
	_globals.userProfile = up;
};
exports.getUserProfileLocale = function(locale) {
	return _globals.userProfileLocales[locale];
};
exports.getUserProfile = function() {
	return _globals.userProfile;
};
exports.getUserName = function() {
	var up = _globals.userProfile;
	return up && up.user && ((up.user.firstName ? up.user.firstName + " " : "") + up.user.lastName) || "unknown";
};
exports.getUserUuid = function() {
	var up = _globals.userProfile;
	return up && up.user && up.user.$uuid;
};
exports.getUserLogin = function() {
	var up = _globals.userProfile;
	return up && up.user && up.user.login;
};

exports.getUserRole = function() {
	var up = _globals.userProfile;
	return (up && up.selectedRole && up.selectedRole.description) || "";
};
exports.getSecurityProfile = function() {
	var up = _globals.userProfile;
	return (up && up.securityProfile) || {}; //factoryId,personalizationLevel (admin,user,none)
};
exports.getAuthoringLevel = function() {
	var al = _globals.userProfile;
	return (al ? al.authoringLevel : null) || "none";
};
/** 
 * Return the current page of tablet application (not current page in a vignette)
 */
exports.getCurrentPage = function() {
	return _globals.tabletApplication.currentPage;
};
exports.getScrollingDirection = function() {
	var p = exports.getCurrentPage();
	return p.rootLayout && p.rootLayout.$type === "hub" ? p.rootLayout.scrollDirection : "v";
};
exports.getMainPageGestureMgr = function() {
	var p = exports.getCurrentPage();
	if (!p) return null;
	return p.getGestureMgr();
};
/**
 * Set the global that points to the tablet application
 */
exports.setTabletApplication = _setTabletApplication;
/**
 * Returns global tablet application
 * TODO Change the name of getApplication
 */
exports.getApplication = function() {
	return _globals.tabletApplication;
};

/*************************************************************
 * UTILS
 ************************************************************/
exports.setUserCtx = _setUserCtx;
exports.clearUserCtx = _clearUserCtx;


/**
 * Allows access to modal through globals
 */
exports.setModal = function(m) {
	_globals.modal = m;
};
exports.getModal = function() {
	return _globals.modal;
};
/**
 * base url utilities
 * 	baseLocation.host - protocol://host:port
 * 	baseLocation.withPath
 * 	baseLocation.requirePath
 * 	baseLocation.htmlRoot
 * 	baseLocation.query
 */
exports.baseLocation = function() {
	return _globals.baseLocation;
};
/**
 * True is dvlp mode - set the caller of _init function
 */
exports.isDvlpMode = function() {
	return _globals.isDvlpMode;
};
exports.isAutoUITestMode = function() {
	return _globals.unitTestMode === true;
};
exports.getUnitTestMgr = function() {
	return _globals.unitTestMgr;
};
exports.setUnitTestMgr = function(mgr) {
	_globals.unitTestMgr = mgr;
};
exports.getDvlpOpt = function(name) {
	return _globals.isDvlpMode && _devOpts[name];
};

/**
 * True if modules is loaded by unit test page
 */
exports.isTestEnvironment = function() {
	return _globals.isTestEnvironment;
};
/**
 * set/returns look and feel id : windows | android | ios
 */
exports.setLookAndFeel = function(lookAndFeel) {
	uiSettings.init(lookAndFeel);
	_globals.lookAndFeel = lookAndFeel;
};
exports.getLookAndFeel = function() {
	return _globals.lookAndFeel;
};
exports.getSiteLayout = function() {
	return _globals.siteLayout;
};
exports.setSiteLayout = function(sl) {
	_globals.siteLayout = sl;
};
exports.isSmartphone = function() {
	return _globals.siteLayout.getDeviceType() === "smartphone";
};
exports.isTablet = function() {
	return _globals.siteLayout.getDeviceType() === "tablet";
};
exports.setMetaData = function(metaData) {
	_metaData = metaData;
};
exports.getMetaData = function() {
	return _metaData;
};
exports.setOfflineManager = function(olm) {
	_globals.offlineManager = olm;
};
// offline should be a boolean
// notif (optional): info to notify the user
// byGlobalEvent (optional): True if called by a global OS hook and not detected on a network request
exports.setOffline = function(offline, notif, byGlobalEvent) {
	if (!_globals.offlineManager) return;
	_globals.offlineManager.setOffline(offline, notif, byGlobalEvent);
};
exports.setOfflineQuiet = function(offline) {
	if (!_globals.offlineManager) return;
	_globals.offlineManager.setOfflineQuiet(offline);
};
exports.isOnline = function() {
	if (_globals.offlineManager) return _globals.offlineManager.isOnline();
	return navigator.onLine;
};

exports.addController = function(c) {
	if (!c) return;
	if (!_controllersMap) _controllersMap = {};
	if (_controllersMap[c.id]) throw new Error("Controller already exists [" + c.id + "]");
	_controllersMap[c.id] = c;
	return c;
};
exports.removeController = function(c) {
	if (!c || !_controllersMap) return;
	delete _controllersMap[c.id];
	return c;
};
exports.getController = function(id) {
	if (!id || !_controllersMap) return null;
	return _controllersMap[id];
};

/*
 * Set/Check if authoring mode is active or not to change behaviour of modals
 */
exports.setAuthoringActive = function(status) {
	_authoringActive = status;
};

exports.isAuthoringActive = function() {
	return _authoringActive;
};


/*************************************************************
 * STATIQUES
 ************************************************************/
exports.ROWIDXPROP = "~ROWIDX~";
exports.SINGLEARRAYPROP = "~data~";
exports.ACTROWDETAIL = "rowDetail";
exports.ACTCHARTDETAIL = "chartDetail";
exports.ACTCARDDESIGN = "cardDesign";
exports.ACTROWDEL = "rowDelete";
exports.ACTROWSEL = "rowSelect";
exports.RECORDCLASS = "s-m-record";
exports.ACTMULTISEL = "multiSelection";

exports.PANELACTIONSREGULAR = "panelactionregular";
exports.PANELPAGESHARE = "panelpagesetting";
exports.PANELUSERSMARTPHONE = "panelusersmartphone";
exports.PANELFILTERSORT = "panelfiltersort";
exports.PANELEDITTEMPLATES = "paneledittemplates";
exports.EXCLUDEFIELDS = ["CREUSR", "CREUSR_REF", "UPDUSR", "UPDUSR_REF"];
exports.CELLDEFCOLOR = "darkgrey";
exports.TILEDEFCOLOR = "darkgrey";
exports.CARDARRAYDEFCOLOR = "darkgrey";
exports.CELLENABLEDCOLOR = "green";
exports.OFFLINEQUERYCOUNT = 30;
exports.XREF_DESCRPOS_TABLE = "bottom";
/*************************************************************
 * INIT
 ************************************************************/
/* Initialization by main.js */
exports.init = _init;
if (window) {
	window.$sm = exports;
}

exports.X3_SEVERITY_TO_BS = {
	"info": "success",
	"warning": "warning",
	"error": "error"
};

exports.getBuildTimeStamp = function() {
	// Global function injected by build process in case we use non debug client
	if (window.__sageBuildTimestamp) {
		return window.__sageBuildTimestamp();
	}
	return "dev mode";
};

/*
 * Global settings are settings stored for the current device and are not user or role dependent.
 * The goal of this method is only to store the settings in a global var to make them accessible for sync calls since
 * the are read in an async process
 */
var _globalSettings = {
	// Default
	"device-type": "auto"
};
exports.setGlobalSettings = function(settings) {
	_globalSettings = settings;
};
exports.getGlobalSettings = function() {
	return _globalSettings;
};
// This flag is used after a login to ensure the list of applications in read
// one time from the server instead of always reading from the local cache 
var _needToCheckAppsList = true;
exports.needToCheckAppsList = function() {
	return _needToCheckAppsList;
};
exports.setNeedToCheckAppsList = function(state) {
	_needToCheckAppsList = state;
};
});

define('syracuse-tablet/html/js/helpers/utils',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {"use strict";
var globals = require('syracuse-tablet/html/js/helpers/globals');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');


var _localeModule;


// Used to force the use of the cache to speed up response time for tests
var _forceUseCache = function() {
	var url = jsutils.getCurrentUrl();
	return url.query && url.query.forceUseCache === "true";
};
// Used to force the dvlp mode with minimized version - For tests
var _forceDvlpMode = function() {
	var url = jsutils.getCurrentUrl();
	return url.query && url.query.forceDvlpMode === "true";
};

var _addClassMembers = function(klass, members) {
	if (!klass || !members || !klass.prototype) return;
	var proto = klass.prototype;
	for (var name in members || {}) {
		var member = members[name];
		if (typeof member.get === "function" || typeof member.set === "function") {
			Object.defineProperty(proto, name, member);
		} else {
			proto[name] = member;
		}
	}
};

exports.init = function(locale) {
	_localeModule = locale;
};

var _defineClass = function(constructor, parent, members) {
	if (parent) constructor.prototype = Object.create(parent.prototype);
	constructor.prototype.constructor = constructor;
	_addClassMembers(constructor, members);
	// !!! The name of the class is the name of the constructor (function)
	// NOTE: THIS DOES NOT SLOW DOWN THE APPLICATION
	// Classes are defined one time at startup, there classes and baseclasses are then stored in an array only once
	// So isInstanceOf will be fast in the rare cases it is used! No need to add a specific flag on which classes to register
	jsutils.addInheritanceInfo(constructor, parent);
	return constructor;
};

/* Universal UUID - Not readable */
var _UUID = function() {
	return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,
		function(c) {
			var r = Math.random() * 16 | 0,
				v = c == 'x' ? r : (r & 0x3 | 0x8);
			return v.toString(16);
		});
};

var _getCurISODateTime = function(date) {
	var currentdate = date || new Date();
	var values = [
		currentdate.getFullYear(), 4, (currentdate.getMonth() + 1), 2,
		currentdate.getDate(), 2,
		currentdate.getHours(), 2,
		currentdate.getMinutes(), 2,
		currentdate.getSeconds(), 2
	];
	var datetime;
	for (var i = 0; i < values.length; i += 2) {
		var val = "" + values[i];
		while (val.length < values[i + 1]) {
			val = "0" + val;
		}
		if (!datetime) {
			datetime = val;
		} else {
			datetime += "-" + val;
		}
	}
	return datetime;
};
var _isoDateTimeToDate = function(stringDate) { // stringDate "2015-10-13-12-04-50"
	if (stringDate == null || typeof stringDate !== "string") {
		return new Date();
	}
	var val = stringDate.split("-");
	if (val.length !== 6) {
		return new Date();
	}
	return new Date(val[0], parseInt(val[1], 10) - 1, val[2], val[3], val[4], val[5]);
};

var _getTimeFromString = function(stringDate) { // stringDate "2015-10-13-12-04-50"
	if (stringDate) {
		var val = stringDate.split("-");
		return new Date(val[0], parseInt(val[1], 10) - 1, val[2], val[3], val[4], val[5]).getTime();
	} else {
		return new Date().getTime();
	}
};


/* Return a DOM compliant id */
var _domIdCpt = 0;
var _domId = function(id) {
	return id.replace(/([^\w-_])/g, '_');
};

/* Readable ui for html dom ids */
var _uidCpt = 0;
var _readableuid = function() {
	return _domId($.camelCase((arguments.length > 0 ? Array.prototype.join.call(arguments, '-') + '-' : "") + _uidCpt++));
};
var _unitTestId = function() {
	if (arguments.length === 0) return null;
	return Array.prototype.join.call(arguments, '-');
};
/* Parse url QS */
var _qsParser = /([^&=;]*)=?([^&;]*)/g;
var _parseQueryString = function(qs) {
	qs = qs || window.location.search;
	var res = {};
	var qs = decodeURIComponent(qs);
	var ii = qs.indexOf('?');
	if (ii >= 0) {
		qs = qs.substring(ii + 1);
	}
	qs.replace(_qsParser, function($0, $1, $2) {
		if ($1 && $1.length > 0) {
			res[$1] = decodeURIComponent($2);
		}
	});
	return res;
};
/**
 *  Resolves expression according to current dataset and prototype
 *  	expression: Syrause SData expression
 *  	dataset: optionnal - DaoSdata object (with value method to chain with a parent) or a simple JSON object
 *  			 if dataset=null prototype must be != null
 *  	prototype: optionnal - PrototypeObject
 * 		searchInParent: true to find variable in parent if not found in dataset #5793
 **/
var _exprRegExp = /\{(.*?)\}/g;
var _execExpression = function(expression, dataset, prototype, searchInParent, level, keepPlaceholder) {
	level = level || 0;
	expression = (expression || "") + "";
	//	TODO  - to remove - FDB - Expresion without brackets must return itself and must not be resolved
	//	if (level === 0 && expression.indexOf("{") < 0 && dataset) {
	//		console.log("NO BRACKET EXPRESSION " + expression);
	//		var value = dataset.getValue ? dataset.getValue(expression) : dataset[expression];
	//		return value == null ? "" : value;
	//	}
	var prevProp = null;
	var res = expression.replace(_exprRegExp,
		function(match, prop) {
			var empty = keepPlaceholder ? match : "";
			// Search in data first - "{VACBPR}~{LEG}"
			var val = dataset == null ? null : dataset.getValue ? dataset.getValue(prop, undefined, searchInParent) : dataset[prop];
			if (val != null) return val;
			if (!prototype) return empty;
			if (prop.smStartsWith('@')) {
				//Case @1234
				return prototype.localization(prop) || "";
			}
			val = prototype.data(prop, dataset, null, true);
			if (val != null && val.indexOf("{") >= 0 && level < 4) {
				// Search in prototype - ex "{@7898}", "{$baseUrl}/$prototype('{$representation}.$thumb')"
				return _execExpression(val, dataset, prototype, searchInParent, level + 1, keepPlaceholder);
			}
			return val == null ? empty : val;
		});
	return res || "";
};
/*
	Extract code from ref field prototype expression {x}
*/
var _extractCode = function($expression) {
	$expression = $expression + "";
	if ($expression.indexOf("{") >= 0) {
		return $expression.slice(1, $expression.length - 1);
	}
	return $expression;
};
var _isExpression = function(value) {
	if ($.type(value) !== "string") return false;
	return /^{@.*}$/.test(value);

};
var _sanitizeArticle = function(article) {
	if (!article) return article;
	var value = $.extend(true, {}, article);

	function _walk(value) {
		if (value == null || typeof value !== "object") return;
		// Object.keys(value).some works for both arrays and objects
		Object.keys(value).forEach(function(key) {
			var v = value[key];
			if ((key === "$title" || key === "$titleOrig") && v != "" && !_isExpression(v)) {
				// Remove titles of old version of authoring that are not localized (if any) - The title of the proto will be displayed instead
				delete value[key];
			} else {
				_walk(v);
			}
		});
	};
	_walk(value);
	return value;
};
/**
 * Only if current pages  is a dashboard
 * return the parent vignette or null
 * we assume that there are no dashboard in vignettes
 */
var _findParentVignette = function($$target, fail) {
	var app = globals.getApplication();
	if (app.currentPage && app.currentPage.isDashboard()) {
		// Find vignette controlId + get vignette control
		var $$v = $$target.closest(".s-m-control.s-m-vignette");
		var vignetteId = $$v.attr("id");
		if (fail && (vignetteId == null || vignetteId.length === 0)) throw new Error("Vignette DOM elmt not found");
		var vignette = app.currentPage.getControl(vignetteId);
		if (fail && !vignette) throw new Error("Vignette not found - id[" + vignetteId + "]");
		return vignette;
	} else if (fail) {
		throw new Error("Current page is not a dashboard");
	}
	return null;
};

/**
 * Given a dom elmt find the parent controller
 * data-controller-id is generated by controller base class to allow to retreive a control
 * Controller is not only a page and we must be able to retrieve it
 */
var _findController = function($$elmt) {
	var $$parent = $$elmt.closest("[data-controller-id]");
	if ($$parent && $$parent.length > 0) {
		var id = $$parent.attr("data-controller-id");
		return globals.getController(id);
	}
	return null;
};
/*
 * Find control instance from DOM element control or layout
 */
var _findControl = function($$ctrl) {
	var controller = _findController($$ctrl);
	if (!controller) {
		return null;
	}
	return controller.getStructElmt($$ctrl.attr("id"));
};
/**
 * For authoring - Don't stop shiftKey/altKey used by scrolling
 */
var _stopClickEvent = function(e) {
	return e.shiftKey !== true && e.altKey !== true;
};
var refTime = new Date().getTime();
var _timeLineCfg = {
	"ajax": false,
	"page": false,
	"pageLoader": false,
	"cacheUpdate": false
};

var _TimeLine = _defineClass(function(type, id) {
	this.type = type;
	this.id = id;
}, null, {
	log: function(step) {
		var time = new Date().getTime();
		var delta = this._prevTime == null ? 0 : time - this._prevTime;
		this._prevTime = time;
		console.log(time - refTime, this.type, this.id, step, "elasped=" + (time - this._start), "delta=" + delta);
	},
	start: function(step) {
		this._start = new Date().getTime();
		this.log(step ? "start " + step : "start");
	},
	step: function(step) {
		this.log(step);
	},
	stop: function(step) {
		this.log(step ? "stop " + step : "stop");
	},
	reset: function() {
		this._prevTime = null;
		this._start = null;
		return this;
	}
});
/**
 * type			page, sendHttp
 * id			url, name...
 * forceEnable	true 		Force enable
 * 				false 		Force disabled
 * 				undefined 	check _timeLineCfg[type]
 */
var _getTimeLine = function(type, id, forceEnable) {
	try {
		if (forceEnable === false) return;
		if (forceEnable !== true && _timeLineCfg[type] !== true) return null;
		if (type.indexOf("page") === -1 && id != null) {
			id = id + "";
			var p = id.indexOf("representation=");
			if (p >= 0) {
				id = id.substr(p + 15);
			} else {
				var p = id.indexOf("x3/erp/");
				if (p >= 0) {
					id = id.substr(p + 7);
				} else {
					var p = id.indexOf("collaboration/syracuse/");
					id = id.substr(p + 23);
				}
			}
			id = decodeURIComponent(id);
		}
		return new _TimeLine(type, id);
	} catch (e) {
		console.log(e);
	}
};

var _hasProp = function(obj, key) {
	return Object.prototype.hasOwnProperty.call(obj, key);
};

var _areEqual = function(obj1, obj2, strict) {
	if (strict ? obj1 === obj2 : obj1 == obj2)
		return true;
	if (obj1 == null || obj2 == null)
		return false;
	if (Array.isArray(obj1) && Array.isArray(obj2)) {
		if (obj1.length != obj2.length)
			return false;
		for (var i = 0; i < obj1.length; i++)
			if (!_areEqual(obj1[i], obj2[i]))
				return false;
		return true;
	}

	if (typeof obj1 != "object" || typeof obj2 != "object") return false;
	var combined = $.extend({}, obj1);
	$.extend(combined, obj2);
	for (var i in combined) {
		if (_hasProp(combined, i)) {
			var val1 = obj1[i];
			var val2 = obj2[i];
			if (!_areEqual(val1, val2))
				return false;
		}
	}
	return true;
};

var _typeNamesByMime = {};
var _regExpMimeToType = /-|\//g;
exports.getTypeName = function(mime) {
	var type = _typeNamesByMime[mime];
	if (!type) {
		// used to generate readable ids - type expected "application/x-name" or "text/plain"
		var a = mime.split(_regExpMimeToType);
		type = _typeNamesByMime[mime] = a[a.length - 1];
	}
	return type;
};

var _authPageProps = ["$pageActionSettings", "$allowDownload"];
/**
 * Authoring properties of a page
 */
var _authCopyPageProperties = function(src, dst) {
	if (!src || !dst) return;
	_authPageProps.forEach(function(p) {
		if (src[p] != null || (dst[p] != null && src[p] == null)) {
			dst[p] = src[p];
		}
	});
};
exports._checksum = function(text) {
	var a = 1,
		b = 0;
	for (var index = 0; index < text.length; ++index) {
		a = (a + text.charCodeAt(index)) % 65521;
		b = (b + a) % 65521;
	}
	return (b << 16) | a;
};

exports.arrayInt = function(min, max) {
	return Array(max - min + 2).join().split(',').map(function(e, i) {
		return min + i;
	});
};
exports.isPromise = function(o) {
	if (o == null) return false;
	return typeof o === "object" && typeof o.then === "function" && typeof o.fail === "function";
};
exports.toPromise = function(o) {
	if (exports.isPromise(o)) return o;
	return $.smResolve(o);
};
exports.authCopyPageProperties = _authCopyPageProperties;
exports.areEqual = _areEqual;
exports.stopClickEvent = _stopClickEvent;
exports.extractCode = _extractCode;
exports.isExpression = _isExpression;
exports.sanitizeArticle = _sanitizeArticle;
exports.UUID = _UUID;
exports.defineClass = _defineClass;
exports.addClassMembers = _addClassMembers;

exports.readableuid = _readableuid;
exports.domId = _domId;
exports.unitTestId = _unitTestId;
exports.parseQueryString = _parseQueryString;
exports.getCurISODateTime = _getCurISODateTime;
exports.isoDateTimeToDate = _isoDateTimeToDate;
exports.getTimeFromString = _getTimeFromString;
exports.parseExpression = function(expression, dataset, prototype, searchInParent, keepPlaceholder) {
	return _execExpression(expression, dataset, prototype, searchInParent, 0, keepPlaceholder);
};
//local Localization text 
exports.getArticleLocalization = function(article) {
	if (!article || !article.$localization) return null;
	var localization = $.extend(true, {}, article.$localization);
	var loc = localization && localization[_localeModule.getCurrentLocale()];
	if (loc && localization[globals.fallbackLocaleCode]) {
		loc.$fallback = $.extend(true, {}, localization && localization[globals.fallbackLocaleCode]);
	} else if (!loc) {
		if (localization && localization[globals.fallbackLocaleCode]) {
			loc = localization && localization[globals.fallbackLocaleCode];
		}
	}
	return loc;
};
//local Localization text 
exports.getCurrentPage = function() {
	return globals.getCurrentPage();
};
// Retunr fr, en .. not en-US, fr-FR
exports.getNavigatorLanguage = function(def) {
	return navigator.language || navigator.userLanguage || def;
};
exports.sameLanguage = function(l1, l2) {
	if (!l1 || !l2) return false;
	l1 = l1.toLowerCase();
	l2 = l2.toLowerCase();
	if (l2 === l1) { // en-us === en-us
		return true;
	} else { // en-us === en
		l1 = l1.split('-');
		l2 = l2.split('-');
		return l1[0] === l2[0];
	}
};
exports.splitSdataKey = function(key) {
	return key && key.split("~");
};
var _splitExp = /({)|(})/g;
exports.sdataExtractKeyFields = function(key) {
	if (key == null || key.length === 0 || !key.replace) return;
	return exports.splitSdataKey(key.replace(_splitExp, ""));
};
exports.getPropByPath = jsutils.getPropByPath;
exports.findParentVignette = _findParentVignette;
exports.findController = _findController;
exports.findControl = _findControl;
// Used to analyse performances
exports.getTimeLine = _getTimeLine;
exports.forceUseCache = _forceUseCache;
exports.forceDvlpMode = _forceDvlpMode;
});

define('syracuse-tablet/html/js/ajax/ajaxInterface',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {"use strict";
/*
 * Ajax module (Default browser implementation)
 */


var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("ajax");
var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');

// Locale module passed in init because if dependency cycle
var _locale;

function _AjaxInterface() {};

var _httpStatus = {
	"200": 'Ok',
	"201": 'Created',
	"400": 'Bad Request',
	"401": 'Unauthenticated',
	"403": 'Forbidden',
	"404": 'Not Found',
	"405": 'Method Not Allowed',
	"406": 'Not Acceptable',
	"409": 'Conflict',
	"410": 'Gone',
	"411": 'Length Required',
	"412": 'Precondition Failed',
	"413": 'Request Entity Too Large',
	"414": 'Request URI Too Long',
	"415": 'Unsupported Media Type',
	"422": 'Unprocessable Entity',
	"429": 'Too Many Requests',
	"500": 'Internal Server Error',
	"501": 'Not Implemented',
	"502": 'Bad Gateway',
	"503": 'Service Unavailable',
	"504": 'Gateway Timeout'
};
var _rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg;
var _ajaxInterfaceClass = utils.defineClass(
	_AjaxInterface,
	null, {
		/**
		 *
		 * Parameters:
		 *
		 * method: GET, PUT, POST, DELETE, HEAD
		 * url: http URL
		 * send: Data to send (Objects will be stringified to json on POST and PUT)
		 * headers: headers to add to the request
		 * options: {
		 *   noJsonParsing: true, : Returns response body as string without trying to parse and return an object. (Default: Parse and return object)
		 *   timeout: 1000 : Request timeout (Default: 0)
		 *   dontCatchHttp401: true (Default: false): true = Return 401 to caller instead of redirecting to login page
		 * }
		 *
		 * When promise is resolved, callback gets the following object as parameter:
		 * {
		 *     textStatus: e.g. "success", "errror"
		 *     status: http status code (200, 404, 500, ...)
		 *     descrHttpStatus: description of http status code (e.g. "Internal Server Error")
		 *     isSuccess: true for: status >= 200 && status < 300 || status === 304
		 *     responseJSON: Contains parsed object returned by server (Unless response did not contain JSON or option noJsonParsing was set)
		 *     responseText: Contains response as returned by server (as string)
		 *     headers: { ... } : Contains returned http headers
		 * }
		 *
		 */
		ajax: function(method, url, send, headers, options) {
			var deferred = $.Deferred();
			try {
				method = method ? method.toUpperCase() : "GET";
				/*
				 * https://github.com/Sage-ERP-X3/Syracuse/issues/6824
				 * Not sure what the intension of this is
				 * Doing a GET with payload is not valid, sending an arbitrary payload
				 * by query params is not possible and also done wrong here for object type values
				 * So removed for now
				if (method === "GET" && send) {
					if (url.indexOf('?') === -1) url += "?";
					var params = [];
					for (var p in send) {
						if (send[p] != null) {
							params.push(encodeURIComponent(p) + "=" + encodeURIComponent(send[p].toString()));
						}
					}
					url += params.join('&');
				}
				*/
				options = options || {};
				var doAjax = function() {
					try {
						var lang = _locale && _locale.getCurrentLocale();
						var allHeaders = {
							"Accept": "application/json;vnd.sage=syracuse",
						};
						if (lang) {
							allHeaders["Accept-Language"] = lang;
						}
						if (headers) {
							$.extend(allHeaders, headers);
						}
						var ajaxData = {
							headers: allHeaders,
							type: method,
							url: url,
							timeout: options.timeout == null ? 0 : options.timeout
							//processData : false
						};
						if (["PUT", "POST"].indexOf(method) >= 0 && send != null) {
							ajaxData.contentType = options.contentType || "application/json;charset=utf-8";
							if (ajaxData.contentType.indexOf("application/json") >= 0 && typeof send === "object") {
								try {
									send = JSON.stringify(send);
								} catch (e) {
									throw new Error("Error parsing send data\nurl: " + url);
								}
							};
							ajaxData.data = send;
						}
						var timeLine = utils.getTimeLine("ajax", url);
						timeLine && timeLine.start("send");
						// We need this option to deal with non-json data
						var parseJson = allHeaders.Accept.indexOf("application/json") >= 0 && options.noJsonParsing !== true;
						if (parseJson) {
							ajaxData.dataType = "json";
						}
						log && log("'" + method + "':" + url);
						// $.ajax is replaced after startup to ensure the module  ajax/ajax.is used since $.ajax will not work
						// in winJS container because of blocked CORS.
						// Here, it's ok to use $.ajax since if we are in a winJS container, this function will be replaced by a
						// function that redirects the call to a winJS function.
						// If we end up here, we are sure we are in standalone browser mode and $.ajax will work as usually

						var ajax = $.ajax_original || $.ajax;
						var promise = ajax(ajaxData);
						promise.complete(function(jqXHR, textStatus) {
							try {
								timeLine && timeLine.step("completed");
								var status = jqXHR.status != null ? jqXHR.status : textStatus == "success" ? 200 : 500;
								var result = {
									textStatus: textStatus,
									status: status,
									descrHttpStatus: _httpStatus[status] || ("unknown: " + status),
									isSuccess: (status >= 200 && status < 300) || status === 304,
									headers: {}
								};
								if (parseJson) {
									result.responseJSON = jqXHR.responseJSON;
								} else {
									result.responseText = jqXHR.responseText;
								}
								var match, headerStr = jqXHR.getAllResponseHeaders();
								if (headerStr) {
									while ((match = _rheaders.exec(headerStr))) {
										result.headers[match[1].toLowerCase()] = match[2];
									}
								}
								if (status === 0 && !(options.dontCatchHttp0 === true)) {
									_handleHttp0(deferred, result);
									return;
								}
								if (status === 401 && !(options.dontCatchHttp401 === true)) {
									_handleHttp401(deferred, result);
									return;
								}
								deferred.resolve(result);
							} catch (e) {
								deferred.reject(e);
							}
						});
					} catch (e) {
						deferred.reject(e);
					}
				};
				doAjax();
			} catch (e) {
				deferred.reject(e);
			}
			return deferred.promise();
		}
	}
);

exports.AjaxInterfaceClass = _ajaxInterfaceClass;

/*
 * config
 * locale moduel syracuse-tablet/html/js/helpers/locale passed as parameter because of dependencies
 *
 */
exports.init = function(config, locale) {
	_locale = locale;
	config = config || {};
	$.ajaxSetup({
		timeout: config.timeout == null ? 20000 : config.timeout,
		async: true
	});
};

/*
 *
 */
function _handleHttp401(deferred, result) {
	if (globals.isTestEnvironment()) {
		deferred.reject("Please login before running this testcase");
		return;
	}
	var responseJSON = result.responseJSON;
	if (!responseJSON) {
		try {
			responseJSON = JSON.parse(result.responseText);
		} catch (e) {} // if we cannot parse, we will not get a diag below and let the error bubble up
	}
	var diag = responseJSON && responseJSON.$diagnoses && responseJSON.$diagnoses[0];
	var link = diag && diag.$links && diag.$links.$redirect;
	if (!link) { // Response unexpected, resume original chain any maybe report error
		deferred.resolve(result);
		return;
	}
	// _locale can be null #8070 - An error can occure before locale hs been initilized
	var diag = {
		$message: _locale ? _locale.text("error.session.timeout") : _httpStatus["401"],
		$severity: "error",
		$links: {
			$redirect: link
		}
	};
	responseJSON = responseJSON || {};
	/* We only set our own diag on 401 and do not add it to the one comming from the server
	responseJSON.$diagnoses = responseJSON.$diagnoses || [];
	responseJSON.$diagnoses.unshift(diag);
	*/
	responseJSON.$diagnoses = [diag];
	responseJSON.$redirectPage = "login";

	result.responseJSON = responseJSON;
	deferred.resolve(result);
}
/**
 * Set the right message and $noConnectionError to true for caller
 */
function _handleHttp0(deferred, result) {
	result.responseJSON = {
		"$noConnectionError": true,
		"$diagnoses": [{
			"$message": (_locale ? _locale.text("no.connection") : "No network connection") + " - HttpStatus=0",
			"$severity": "error"
		}]
	};
	deferred.resolve(result);
}
});

define('syracuse-tablet/html/js/ajax/ajax',['require','exports','module','syracuse-tablet/html/js/ajax/ajaxInterface'],function (require, exports, module) {"use strict";
/*
 * Ajax module
 */


var ajaxInterface = require('syracuse-tablet/html/js/ajax/ajaxInterface');

var _ajax;

exports.getAjax = function() {
	if (!_ajax) {
		_ajax = new ajaxInterface.AjaxInterfaceClass();
	}
	return _ajax;
};

exports.init = function(config, locale) {
	ajaxInterface.init(config, locale);
};
exports.rejectHttpResult = function(title, result, url) {
	if (result && result.responseJSON && result.responseJSON.$diagnoses) {
		// $noConnectionError to notify caller that fail is due to network connection broke down
		if (result.responseJSON.$diagnoses.length === 0) {
			result.responseJSON.$diagnoses = [{
				$message: title,
				$severity: "error"
			}];
		}
		return $.smReject({
			$noConnectionError: result.responseJSON.$noConnectionError,
			$redirectPage: result.responseJSON.$redirectPage,
			$title: title,
			$diagnoses: result.responseJSON.$diagnoses
		});
	}
	return $.smReject({
		$title: title,
		$diagnoses: [{
			$message: "Unexpected empty data"
		}]
	});
};
});

define('syracuse-tablet/html/js/helpers/locale',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ajax/ajax'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var ajax = require('syracuse-tablet/html/js/ajax/ajax').getAjax().ajax;

var _currentLocale = null;
var _resources = {};

var _datetimeInformationKey = "$datetimeInformation";
var _decimalInformationKey = "$decimalInformation";
var _upLocalePreferences;

var _txtRegexp = /\{([\w-]+)\}/g;
var _localeHashUser = "*";

var _userProfileSettings = {};


var _text = function(key, args) {
	var resources = _resources && _resources[_currentLocale];
	if (!resources) {
		return;
	}
	//	if (!resources[key]) {
	//		console.log(key);
	//	}
	var text = resources[key] || "Resource key not found[" + key + "]";

	if (args) {
		if (!Array.isArray(args)) {
			// We accept multiple arguments following the key
			args = Array.prototype.slice.call(arguments, 1);
		}
		text = text.replace(_txtRegexp, function(match, p1) {
			var idx = +p1;
			if (idx >= 0 && idx < args.length) {
				return args[idx];
			}
			return "?";
		});
	}

	return text;
};

var _textNoFail = function(key, args) {
	var resources = _resources && _resources[_currentLocale];
	if (!resources || !resources[key]) {
		return null;
	}
	var text = resources[key];
	if (args) {
		if (!Array.isArray(args)) {
			// We accept multiple arguments following the key
			args = Array.prototype.slice.call(arguments, 1);
		}
		text = text.replace(_txtRegexp, function(match, p1) {
			var idx = +p1;
			if (idx >= 0 && idx < args.length) {
				return args[idx];
			}
			return "?";
		});
	}
	return text;
};

var _textOpt = function(key) {
	var resources = _resources && _resources[_currentLocale];
	if (!resources) {
		return;
	}
	return resources[key];
};

var _getDatetimeInfo = function() {
	var resources = _resources && _resources[_currentLocale];
	if (!resources) {
		return;
	}
	return resources[_datetimeInformationKey];
};

var _getDecimalInfo = function() {
	var resources = _resources && _resources[_currentLocale];
	if (!resources) {
		return;
	}
	return resources[_decimalInformationKey];
};

var _setLocale = function(locale, upLocalePreferences) {
	var deferred = new $.Deferred();
	_upLocalePreferences = upLocalePreferences;

	// Everytime a locale is set, the user is remembered
	// this is because formatters created afterwards are cached
	// and need to be linked to locale + user (because of user defined locale settings)
	// See getCurrentLocaleHash()
	var ctx = globals.getUserCtx();
	_localeHashUser = ctx && ctx.$user || "*";
	/**
	 * Locales coming from user-profile if any allow the customization of the formats
	 */
	_userProfileSettings = globals.getUserProfileLocale(locale) || {};

	var resources = _resources && _resources[locale];
	if (resources) {
		_currentLocale = locale;
		deferred.resolve();
	} else if (locale === _currentLocale) {
		deferred.resolve();
	} else {
		var rsrcPath = jsutils.getResourcesBasePath();
		_loadFile(rsrcPath + "js/resources", "strings", locale, "en")
			.then(function(data) {
				_currentLocale = locale;
				_resources[locale] = data;
			})
			.then(function() {
				return _loadFile(rsrcPath + "js/resources/locales", "date", locale, "en-GB");
			})
			.then(function(data) {
				// join strings-xx-XX and date-xx-XX
				_resources[locale][_datetimeInformationKey] = data;
			})
			.then(function() {
				return _loadFile(rsrcPath + "js/resources/locales", "decimal", locale, "en-GB");
			})
			.then(function(data) {
				// join strings-xx-XX and decimal-xx-XX
				_resources[locale][_decimalInformationKey] = data;
			})
			.then(function() {
				deferred.resolve();
			}).fail(function(e) {
				deferred.resolve();
			});
	}
	return deferred.promise();
};

var _loadFile = function(path, file, locale, defLocale) {
	var deferred = new $.Deferred();
	var segs = locale.split("-");
	var loadedLocale;

	function _load() {
		if (segs.length === 0) {
			// Fallback to default
			var url = path + "/" + file + "-" + defLocale + ".json";
			ajax("GET", url, null, null)
				.then(function(data) {
					if (data && data.responseJSON) {
						deferred.resolve(data.responseJSON);
					}
					deferred.resolve({});
				}).fail(function(e) {
					deferred.reject(e);
				});
		} else {
			var code = segs.join("-");
			var url = path + "/" + file + "-" + code + ".json";
			ajax("GET", url, null, null)
				.then(function(data) {
					if (data && data.responseJSON) {
						if (code !== defLocale) {
							url = path + "/" + file + "-" + defLocale + ".json";
							ajax("GET", url, null, null)
								.then(function(dataEn) {
									if (dataEn && dataEn.responseJSON) {
										var mergedStrings = $.extend(true, {}, dataEn.responseJSON, data.responseJSON);
										deferred.resolve(mergedStrings);
									} else {
										deferred.resolve(data.responseJSON);
									}
								})
								.fail(function(e) {
									// Fail silently since it's only about fallback language
									deferred.resolve(data.responseJSON);
								});
							return;
						}
						deferred.resolve(data.responseJSON);
					} else {
						segs.pop();
						_load();
					}
				}).fail(function(e) {
					segs.pop();
					_load();
				});
		}
	}
	_load();
	return deferred.promise();
};

var _isCurrent = function(locale, strict) {
	if (!locale || !_currentLocale) return false;
	if (_currentLocale === locale) return true;
	return strict ? false : (locale.split('-'))[0] === _currentLocale;
};

/*
 * TODO: Use prefered format from _upLocalePreferences if set
 */
exports.getDateFormat = function() {
	var di = _getDatetimeInfo();
	return _userProfileSettings.shortDate || (di && di.formatPatterns && di.formatPatterns.shortDate) || "dd/MM/yyyy";
};

exports.getDateTimeFormat = function() {
	var di = _getDatetimeInfo();
	var date = _userProfileSettings.shortDate || (di && di.formatPatterns && di.formatPatterns.shortDate) || "dd/MM/yyyy";
	var time = _userProfileSettings.shortTime || (di && di.formatPatterns && di.formatPatterns.shortTime) || "HH:mm:ss";
	return date + " " + time;
};
exports.getTimeFormat = function() {
	var di = _getDatetimeInfo();
	return _userProfileSettings.longTime || (di && di.formatPatterns && di.formatPatterns.longTime || "HH:mm:ss");
};
exports.getTimeFormatShort = function() {
	var di = _getDatetimeInfo();
	return _userProfileSettings.shortTime || (di && di.formatPatterns && di.formatPatterns.shortTime || "HH:mm");
};

exports.getNumberFormat = function(type) {
	return (type === "application/x-integer" ? "#,##0" : "#,##0.##");
};

exports.getNumberGroupSeparator = function() {
	var di = _getDecimalInfo();
	var gs = _userProfileSettings.numberGroupSeparator || (di && di.numberGroupSeparator) || ",";
	return gs;
};

exports.getNumberDecimalSeparator = function() {
	var di = _getDecimalInfo();
	var ds = _userProfileSettings.numberDecimalSeparator || (di && di.numberDecimalSeparator) || ".";
	return ds;
};

exports.setLocale = _setLocale;
exports.text = _text;;
exports.textNoFail = _textNoFail;
exports.textOpt = _textOpt;
exports.isCurrent = _isCurrent;

// Get Month names, etc for parsers
exports.getDatetimeInfo = _getDatetimeInfo;
exports.getCurrentLocale = function() {
	return _currentLocale;
};
exports.getCurrentLocaleHash = function() {
	return _currentLocale + "#" + _localeHashUser;
};

exports.getProductLabels = function() {
	var data = {};
	data.brand = exports.text("global.label.brand");
	data.product = exports.text("global.label.product");
	return data;
};
});

define('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestHelpers',['require','exports','module','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {"use strict";
var globals = require('syracuse-tablet/html/js/helpers/globals');


var _handlebars = {
	mailTo: ' <a id ="testNativeMailto" href="mailto:?subject={{subject}}&body={{body}}" class="s-m-link">\
		<i class="fa fa-envelope">\
		</i>\
		<span>{{title}}</span>\
		</a>',
	handleLink: ' <a id ="testNativeHandleLink" href="{{href}}" class="s-m-link">\
		<i class="fa fa-hand-pointer-o">\
		</i>\
		<span>{{title}}</span>\
		</a>'
};
var _getHtml = function(tmpl, ctx) {
	return Handlebars.compile(_handlebars[tmpl])(ctx);
};
/**
 * Call mobile application interface
 */
exports.callAppNativeInterface = function(moduleName, actionName) {
	var app = globals.getApplication();
	if (!app) return null;
	return app.nativeWrapperJSInterface.apply(app, arguments);
};

/**
 * Add a clickable email icon
 * options.subject	subject
 * options.url		url
 * options.timeout	timeout
 */
exports.addTestEmail = function($$parent, options) {
	if (!options) return;
	$(_getHtml("mailTo", {
		title: "Send email",
		subject: encodeURIComponent(options.subject || "No subject"),
		body: encodeURIComponent(options.url)
	})).appendTo($$parent);
	setTimeout(function() {
		$("#testNativeMailto").off().remove();
	}, options.timeout || 5000);
};
/**
 * Add a clickable hand icon
 * options.clickHandler	callback on click
 * options.url			link url
 * options.timeout		timeout
 */
exports.addHandleLink = function($$parent, options) {
	if (!options) return null;
	var $$elmt = $(_getHtml("handleLink", {
		title: options.title || "HandleLink",
		href: options.url || "#"
	})).appendTo($$parent);
	if (options.css) {
		$$elmt.css(options.css);
	}
	if (options.clickHandler) {
		$$elmt.click(function() {
			options.clickHandler();
		});
	}
	setTimeout(function() {
		$("#testNativeHandleLink").off().remove();
	}, options.timeout || 5000);
	return $$elmt;
};

exports.notify = function(title, text) {
	globals.getModal().notify({
		severityClass: "success",
		title: title,
		body: text,
		onlyWebapp: true
	});
};
});

define('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestShare',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestHelpers'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var testHelpers = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestHelpers');

var _TestNativeWrapper = function() {

	this.sharePageLinkSupported = function() {
		return true;
	};
	this.sharePageLink = function(data) {
		var parsedData = data ? JSON.parse(data) : null;
		if (!parsedData) return;
		// Add icons to test email and click on tile
		testHelpers.addTestEmail($('.s-m-footer-left'), {
			subject: parsedData.DeepLink.Title,
			url: parsedData.DeepLink.Url
		});
		testHelpers.addHandleLink($('.s-m-footer-left'), {
			clickHandler: function() {
				setTimeout(function() {
					globals.getApplication().gotoWelcomeApplication().then(function() {
						setTimeout(function() {
							window.smShareJS.handleLink(parsedData.DeepLink);
						});
					});
				});
			}
		});
		if (!window.smShareJS) return;
		setTimeout(function() {
			window.smShareJS.shareFinished({
				action: "ok",
			});
		});
	};
};

exports.create = function() {
	return new _TestNativeWrapper();
};
});

define('syracuse-tablet/html/js/helpers/native/nativeHelpers',['require','exports','module','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {"use strict";
var globals = require('syracuse-tablet/html/js/helpers/globals');

/**
 * Call mobile application interface
 */
exports.callAppNativeInterface = function(moduleName, actionName) {
	var app = globals.getApplication();
	if (!app) return null;
	return app.nativeWrapperJSInterface.apply(app, arguments);
};
});

define('syracuse-tablet/html/js/helpers/notifications',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("notifs");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
/**
 * publish/subscribe - Observer/Observable pattern with jQuery
 * TODO - !!! Attach a _subscriptions to application and one per page
 * --> Switch the page _subscriptions with the page in order to not notify inactive pages (parent page)
 * Temporarily we check inactive in page notif methods
 *
 **/

var _nameSpace = "sm";
var _subscriptions = {};

/**
 * _callHandler outside _publish function to preserve args if call to multiple objects in the loop
 */
var _callCheck = function(object) {
	// Don't notify object that are not active (ex: cached pages)
	if (jsutils.isInstanceOf(object, "Page") && !object.isActive()) return false;
	if (jsutils.isInstanceOf(object, "StructElmt") && (object.controller == null || !object.controller.isActive())) return false;
	return true;
};
var _callHandler = function(callBack, object, args) {
	if (!_callCheck(object)) return;
	return setTimeout(function() {
		callBack.apply(object, args);
	}, 0);
};
var _callHandlerSynch = function(callBack, object, args) {
	if (!_callCheck(object)) return;
	callBack.apply(object, args);
};

/**
 *  publish an event ("sm.logged.in") or an array of events ["sm.logged.in"...]
 * 		Functional Object Subscribers
 * 			 notified through method notifEventname - object.notifLogin, object.notifLogout
 * 		Simple callBack Subscriber
 * 			called with event as first parameter
 * 	Argument that follow events parameter are passed to the Subscriber
 *  If event starts with 'synch.' all the callback will be called synchronously otherwise they will be called asynchronously (setTimeout)
 * */
var _publish = function(events) {
	if (!events) {
		throw new Error("No topic to publish");
	}
	var events = typeof events === "string" ? [events] : events;
	log && log("Publish " + events.join(" - "));
	var args, subscription, subscription, res;
	var count = 0,
		array;
	var objArgs, args = arguments,
		synch, callHandler;
	events.forEach(function(evt) {
		synch = evt.smStartsWith("synch.");
		if (synch) {
			evt = evt.split("synch.")[1];
			callHandler = _callHandlerSynch;
		} else {
			callHandler = _callHandler;
		}
		array = _subscriptions[evt];
		if (array) {
			array = array.slice();
			for (var i = 0, l = array.length; i < l; i++) {
				subscription = array[i];
				if (subscription.object) {
					if (!objArgs) objArgs = Array.prototype.slice.call(args, 1);
					// Remove first argument and call the method - setTimeout(0) for asynchronism and release call stack
					res = callHandler(subscription.callBack, subscription.object, objArgs);
				} else {
					// call the function with evt as first parameter - setTimeout(0) for asynchronism and release call stack
					args[0] = evt;
					res = callHandler(subscription.callBack, null, args);
				}
				count++;
				// TO SEE - -stop is res = false if ( res === false ) { break; }
			}
		} else {
			// No subscribers is not an error!
			// throw new Error("Unknown notification event " + evt);
		}
	});
};

/**
 *  Same as _publish with options
 *  TODO -> Merge both
 * */
var _publishEx = function(events, opts) {
	if (!events) {
		throw new Error("No topic to publish");
	}
	var events = typeof events === "string" ? [events] : events;
	log && log("Publish " + events.join(" - "));
	var args, subscription, subscription, res;
	var count = 0,
		array;
	var exclude = opts && opts.exclude || [];
	var objArgs, args = arguments;
	var synch, callHandler;
	events.forEach(function(evt) {
		synch = evt.smStartsWith("synch.");
		if (synch) {
			evt = evt.split("synch.")[1];
			callHandler = _callHandlerSynch;
		} else {
			callHandler = _callHandler;
		}
		array = _subscriptions[evt];
		if (array) {
			array = array.slice();
			for (var i = 0, l = array.length; i < l; i++) {
				subscription = array[i];
				if (subscription.object) {
					if ((!exclude || exclude.indexOf(subscription.object)) < 0) {
						if (!objArgs) objArgs = Array.prototype.slice.call(args, 2);
						// Remove first argument and call the method - setTimeout(0) for asynchronism and release call stack
						res = callHandler(subscription.callBack, subscription.object, objArgs);
					}
				} else {
					// call the function with evt as first parameter - setTimeout(0) for asynchronism and release call stack
					args[0] = evt;
					res = callHandler(subscription.callBack, null, args);
				}
				count++;
				// TO SEE - -stop is res = false if ( res === false ) { break; }
			}
		} else {
			// No subscribers is not an error!
			// throw new Error("Unknown notification event " + evt);
		}
	});
};


/**
 * object subscribes for events (string or array)
 * 		object can be an functional Object or a function
 * 		functional Object must implement a method notifEventName  sm.my.event -> Method notifMyEvent
 * Events starts with "sm"
 * High priority subscriptions are called first
 */
var _subscribe = function(object, events, priority) {
	if (!events) {
		throw new Error("Notification - No topic to publish");
	}
	if (!object) {
		throw new Error("Notification - Null object");
	}
	priority = priority || 10;
	var events = typeof events === "string" ? [events] : events;
	log && log("Subscribe " + events.join(" - ") + " - priority=" + priority);
	var objectArray, removeIdx;
	events.forEach(function(evt) {
		var callBackFct, callBackObj;
		if (typeof object == "function") {
			callBackFct = object;
			callBackObj = null;
		} else {
			callBackObj = object;
			var methodName = evt.split('.');
			if (methodName[0] != _nameSpace) throw new Error("Notification - Bad event domain name");
			methodName = $.camelCase("notif-" + methodName.splice(1).join('-'));
			callBackFct = object[methodName];
			if (!callBackFct) {
				throw new Error("Notification - Object must implement " + methodName);
			}
		}
		var added = false;
		objectArray = _subscriptions[evt];
		if (!objectArray) {
			objectArray = _subscriptions[evt] = [];
		} else {
			// check if object has already subscribed
			var removeIdx = -1;
			objectArray.some(function(o, idx) {
				if (o && (o.object === object || o.callBack === object)) {
					removeIdx = idx;
					return true;
				}
			});
			if (removeIdx >= 0) {
				objectArray.splice(removeIdx, 1);
			}
		}
		var subscriptionInfo = {
			callBack: callBackFct,
			object: callBackObj,
			priority: priority
		};
		for (var i = objectArray.length - 1; i >= 0; i--) {
			if (objectArray[i].priority <= priority) {
				objectArray.splice(i + 1, 0, subscriptionInfo);
				added = true;
				break;
			}
		}
		if (!added) {
			objectArray.unshift(subscriptionInfo);
		}
	});
};

/**
 * object unsubscribes for events
 *  object != null
 * 		Remove all object's subscription for given events
 * 		object can be an Object or a function
 *  object == null
 * 		Remove all subscription for given events
 *  events string or array
 * 		null -> unsubscribe for allevent
 */
var _unsubscribe = function(object, events) {
	if (!events) {
		events = Object.keys(_subscriptions);
	} else if (typeof events == "string") {
		events = [events];
	}

	var propToCheck = typeof object === "function" ? "callBack" : "object";
	events.forEach(function(evt) {
		var array = _subscriptions[evt];
		if (array) {
			var lg = array.length;
			for (var i = 0, l = lg; i < l; i++) {
				if (object == null || array[i][propToCheck] === object) {
					array.splice(i, 1);
					// Adjust counter and length for removed item
					i--;
					l--;
				}
			}
			if (false && lg != array.length) {
				console.log("_unsubscribe ", evt, object == null ? "all" : propToCheck, lg, array.length, _check().total);
			}
		}

	});
};

// Remove all subscription
var _reset = function(object, events) {
	log && log("Reset");
	// For tests
	_unsubscribe(null, null);
	// We could just do _subscriptions = {};
};

// the number of subscriptions per event (for object if != null)
var _check = function(object) {
	var res = {};
	res.total = 0;
	var propToCheck = typeof object === "function" ? "callBack" : "object";
	Object.keys(_subscriptions).forEach(function(key) {
		res.total += _subscriptions[key].length;
		if (object == null) {
			res[key] = _subscriptions[key].length;
		} else {
			res[key] = 0;
			var arr = _subscriptions[key];
			for (var i = 0, l = arr.length; i < l; i++) {
				if (arr[i][propToCheck] === object) res[key] = res[key] + 1;
			}
		}
	});
	return res;
};
/**
 * Notify a specified page or the current one
 * We can't used the standard notification process for pages because we need to notify only one page
 * We can have potentially multiple pages objects (vignettes, disabled pages..)
 * We keep the subscription/publication method to to call asynchronously the method to release the stack
 * TODO - Review/improve later the project according to global needs
 * event: 	only one event
 * page:	second parameter - no parameter for current page
 * arguments:	callback arguments
 */
var _notifyController = function(event, page) {
	if (!event) throw new Error("_notifyController - Unexpected empty event");
	if (typeof event !== "string") throw new Error("_notifyController - string event expected");
	log && log("notifyController " + event);
	var args;
	if (page !== null) {
		args = Array.prototype.slice.call(arguments, 2);
	} else {
		page = globals.getCurrentPage();
		args = Array.prototype.slice.call(arguments, 1);
	}
	if (!page) throw new Error("_notifyController - Unexpected null page");
	var synch = event.smStartsWith("synch.");
	var callHandler;
	if (synch) {
		event = event.split("synch.")[1];
		callHandler = _callHandlerSynch;
	} else {
		callHandler = _callHandler;
	}
	var array = _subscriptions[event];
	if (array) {
		for (var i = 0, l = array.length; i < l; i++) {
			if (array[i].object === page) {
				return callHandler(array[i].callBack, page, args);
			}
		}
	} else {
		console.log("_notifyController - No sunsciption for event " + event);
	}
};
exports.check = _check;
exports.reset = _reset;
exports.subscribe = _subscribe;
exports.unsubscribe = _unsubscribe;
exports.publish = _publish;
exports.publishEx = _publishEx;
exports.notifyController = _notifyController;
});

define('syracuse-tablet/html/js/helpers/native/nativeShare',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestShare','syracuse-tablet/html/js/helpers/native/nativeHelpers','syracuse-tablet/html/js/helpers/native/nativeExtCall','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeShare");
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var nativeTestShare = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestShare');
var nativeHelpers = require('syracuse-tablet/html/js/helpers/native/nativeHelpers');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');



var _ShareManager = function() {

	this.enabled = false;
	this.pendingLinks = null;
	this._currentDeferred = null;

	/*
	 *  This method will be invoked from wrapper once the pen input has finished or failed
	 *  data:
	 *  {
	 *  	action: "ok" | "cancelled",
	 *  }
	 */
	this.shareFinished = function(data) {
		if (this._currentDeferred) {
			var def = this._currentDeferred;
			this._currentDeferred = null;
			log && log("Got share: " + JSON.stringify(data || {}));
			def.resolve(data);
		}
	},

	/*
	 * Called by wrapper when the app is activated by a link
	 * data:
	 * {
	 * 	Url: url (url containing all information to go back to a specific page, sent as url option by sharePageLink)
	 *  Title: Title of url (sent as title option by sharePageLink)
	 * }
	 */
	this.handleLink = function(data) {
		log && log("handleLink: " + JSON.stringify(data, null, 2));
		if (this.enabled === true) {
			this.triggerLink(data);
		} else {
			log && log("handleLink: add pending link");
			this.pendingLinks = this.pendingLinks || [];
			this.pendingLinks.push(data);
		}
	};
	/**
	 * Enables shareManager to actually handle link
	 * Process pending links
	 * When we open a page from a live tile the wrapper triggers handleLink after having been notified that application has been loaded (notifLoaded)
	 * But the link can be actually triggered once the user has been logged in (if any) and application is ready (sm.application.ready)
	 * notifApplicationReady tells that sahreManager can execute handle link
	 */
	this.notifApplicationReady = function(ok) {
		this.enabled = true;
		if (this.pendingLinks) {
			log && log("handleLink: trigger pending link");
			// Only the last pushed linked
			this.triggerLink(this.pendingLinks.pop());
			this.pendingLinks = null;
		}
	};

	this.triggerLink = function(data) {
		log && log("handleLink: triggerLink " + JSON.stringify(data, null, 2));
		if (!data || !data.Url) return;
		try {
			var url = jsutils.parseURL(data.Url);
			log && log("url: " + JSON.stringify(url, null, 2));
			if (!url || !url.query || !url.query.context) return;
			var contextId = url.query.context;
			log && log("context: " + contextId);
			nativeHelpers.callAppNativeInterface("share", "handleLink", contextId);
		} catch (e) {
			log && log("handleLink: failed", e);
			return;
		}
	};

	notifications.subscribe(this, ["sm.application.ready"]);
};

// Global object to be called by native code on pencil events
if (!(window.smShareJS)) {
	window.smShareJS = new _ShareManager();
}
/**
 *
 */
exports.supports = function(capability) {
	if (capability === "share") {
		return nativeExtCall.isSupported("smShare", "sharePageLinkSupported");
	}
	return false;
};

/**
 * options:
 * {	
      pageData: {
		title: "Customers" // title that will be shown when page is shared
		url: url that is embedded in sent message and will be passed to handleLink method once the user clicks on the message 
		
		--- optional for now:
		
		id:"..."
		sdataParameters:"..."
		endPoint: "x3.erp.SEEDAMBAS"
		htmlRoot: "http://pc101458:8124/syracuse-tablet/html"
		language: "en-US"
		name: "x3.erp.GX3APP.BPCUSTOMERM.$query"
		sDataUrl: "http://pc101458:8124/mobile1/x3/erp/GX3APP/BPCUSTOMER?representation=BPCUSTOMERM.$query",
		
		DeepLink: {
			Title,
			Url,
		}
	  }
 * }
 */
exports.sharePageLink = function(options) {
	// DeepLink.Url must contain all information required to allow the webapp to navigate back to the current page including it's
	// eventual state (like filters)
	// DeepLink data structure will be shared by other similar functions
	// DeepLink: {
	//		Title: 
	//		Url: 
	//	}

	var param = {
		Title: options.pageData.Title,
		Description: options.pageData.Description,
		DeepLink: options.pageData.DeepLink
	};
	var data = JSON.stringify(param);
	_ShareManager._currentDeferred = $.Deferred();
	nativeExtCall.fireMethod("smShare", "sharePageLink", data);
	return _ShareManager._currentDeferred.promise();
};
/**
 * Returns the test js wrapper
 */
exports.init = function(testMode) {
	if (window && window.smShare) return;
	if (!testMode) return;
	log && log("Creating native share test wrapper");
	window.smShare = nativeTestShare.create();
	return window.smShare;
};
});

define('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestLiveTile',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestHelpers'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeLiveTile");
var testHelpers = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestHelpers');

var _TestNativeWrapper = function() {
	/**
	 * OPTIONS
		{
		  "Id": "x3.erp.GX3APP.EXPENENTM.$query_http://pc101329.sagefr.adinternal.com:8124/mobile1/x3/erp/GX3APP/EXPENSES?representation=EXPENENTM.$query",
		  "Title": "Frais non visés",
		  "Description": "TEST",
		  "BackgroundColor": "#ff5800",
		  "ForegroundColor": "#41a940",
		  "SdataUrl": "http://pc101329.sagefr.adinternal.com:8124/mobile1/x3/erp/GX3APP/EXPENSES?representation=EXPENENTM.$query",
		  "DeepLink": {
		    "Title": "Frais non visés",
		    "Url": "http://pc101329.sagefr.adinternal.com:8124/syracuse-tablet/html/open_link.html?testNativeWrapper=true&context=1a8be16b-883a-45be-9b2e-1c96c29226fe"
		  },
		  "BindArray": "$resources",
		  "BindDetail": ""
		}
	 */
	this.addLiveTileSupported = function() {
		return true;
	};
	this.addLiveTile = function(options) {
		if (!options) return;
		try {
			options = JSON.parse(options);
		} catch (e) {
			return;
		}
		console.log(JSON.stringify(options, null, 2));
		var id = options.Id;
		var title = [];
		if (options.Title) {
			title.push(options.Title);
		}
		if (options.Description) {
			title.push(options.Description);
		}
		title = title.join(" - ");
		setTimeout(function() {
			log && log("LIVE TILE ADD - Succeeded - " + title);
			testHelpers.addHandleLink($('.s-m-footer-left'), {
				url: options.DeepLink.Url,
				timeout: 10000,
				title: title
			}).find("i").css({
				"color": options.ForegroundColor || "white",
				"background-color": options.BackgroundColor
			});
			window.smLiveTileJS.addLiveTileFinished(null);
		}, 100);
	};
};

exports.create = function() {
	return new _TestNativeWrapper();
};
});

define('syracuse-tablet/html/js/helpers/native/nativeLiveTile',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestLiveTile','syracuse-tablet/html/js/helpers/native/nativeExtCall'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeLiveTile");
var nativeTestLiveTile = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestLiveTile');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');

var _currentDeferred;
//Global object to be called by native code on pencil events
if (!(window.smLiveTileJS)) {
	window.smLiveTileJS = {

		/*
		 *  This method will be invoked from wrapper when there was a live tile action executed.
		 *  data {
		 *  	action :"add" //"remove" "get"
		 *  	content:{ (null in case of get if not tile found)
		 *  			id:"id passed",
		 *  			title:"my customers",
		 *  			...
		 * 		}
		 *  	error:{ (if error occurs)
		 *  		no:"132001"
		 *  		text:"Not found", "unexpected error" ...
		 *  	}
		 *  }
		 * On error return is:
		 * {
		 *   error: {
		 *     text: "<error removing tile, for reason xxx>"
		 *   }
		 * }
		 */
		addLiveTileFinished: function(data) {
			if (_currentDeferred) {
				var def = _currentDeferred;
				_currentDeferred = null;
				log && log("Command live tile add finished: " + JSON.stringify(data || {}));
				def.resolve(data);
			}
		}
	};
}

/**
 *
 */
exports.supports = function(capability) {
	if (capability === "liveTile") {
		return nativeExtCall.isSupported("smLiveTile", "addLiveTileSupported");
	}
	return false;
};

/**
	options:{
		"name":"x3.erp.GX3APP.BPCUSTOMERM.$query",
		"title":"Clients",
		"id":"x3.erp.GX3APP.BPCUSTOMERM.$query_http://pc101458:8124/mobile1/x3/erp/GX3APP/BPCUSTOMER?representation=BPCUSTOMERM.$query",
		"icon":"star",
		"sDataUrl":"http://pc101458:8124/mobile1/x3/erp/GX3APP/BPCUSTOMER?representation=BPCUSTOMERM.$query",
		"representation":"BPCUSTOMERM",
		"facet":"$query",
		"action":"$query",
		"entity":"BPCUSTOMER",
		"endpoint":"x3.erp.GX3APP",
		"applicationName":"sagesalescustomers"
	}
	
	Return see addLiveTileFinished
 */
exports.addLiveTile = function(options) {
	_currentDeferred = $.Deferred();
	var data = JSON.stringify(_getTileDataStruct(options));
	nativeExtCall.fireMethod("smLiveTile", "addLiveTile", data);
	return _currentDeferred.promise();
};

/*
 * Pack everything into a structure understood by native code
 */
function _getTileDataStruct(options) {
	var param = {
		Id: options.id,
		Title: options.title,
		Description: options.description,
		BackgroundColor: options.backgroundColor,
		ForegroundColor: options.color,
		SdataUrl: options.sDataUrl,
		DeepLink: options.DeepLink,

		UserLogin: globals.getUserLogin(),

		// Data extraction:

		BindArray: options.bind || "$resources", // Name of array property to use for live tile. 
		// E.g. $resources = array so it will be the number of records in the array shown on the live tile.
		BindDetail: "" // Name of property to read value for live tile
		// E.g. BPCNAM = property, so value of property BPCNAM will be used in live tile
		// NOTE:
		// If BindArray and BindDetail are both given, the live tile will 
		// show the value of BindDetail column of the first record of the array 
		// given by BindArray 
	};
	return param;
}
/**
 * Returns the test js wrapper
 */
exports.init = function(testMode) {
	if (window && window.smLiveTile) return;
	if (!testMode) return;
	log && log("Creating native Live Tile test wrapper");
	window.smLiveTile = nativeTestLiveTile.create();
	return window.smLiveTile;
};
});

define('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestMessages',['require','exports','module','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestHelpers'],function (require, exports, module) {"use strict";

var testHelpers = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestHelpers');

var _TestNativeWrapper = function() {

	this.toastMsgSupported = function() {
		return true;
	};
	this.toastMsg = function() {};

	this.scheduledMsgSupported = function() {
		return true;
	};
	this.scheduledMsg = function(data) {
		if (data) {
			data = JSON.parse(data);
			testHelpers.notify(data.Text1 && data.Text2 ? data.Text1 + " - " + data.Text2 : data.Text1 || data.Text2, data.ScheduleTime);
		} else {
			testHelpers.notify("Empty toast message");
		}
	};
};

exports.create = function() {
	return new _TestNativeWrapper();
};
});

define('syracuse-tablet/html/js/helpers/native/nativeMessages',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestMessages','syracuse-tablet/html/js/helpers/native/nativeExtCall'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeMsg");
var nativeTestMessages = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestMessages');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');

var _currentDeferred;

if (!(window.smMsgJS)) {
	window.smMsgJS = {};
}

/**
 *
 */
exports.supports = function(capability) {
	if (capability === "toastMessages") {
		return nativeExtCall.isSupported("smMsg", "toastMsgSupported");
	}
	if (capability === "scheduleMessage") {
		return nativeExtCall.isSupported("smMsg", "scheduledMsgSupported");
	}
	return false;
};

/**
 * Sends a toast message
 * options: {
 *	Text1: options.title,
 *	Text2: options.body, // optional
 *  Severity: "error" | "success",
 *	DeepLink: { // optional
 *		Title,
 *		Url,
 *	}
 * }
 */
exports.showToastMessage = function(options) {
	var data = JSON.stringify(options);
	nativeExtCall.fireMethod("smMsg", "toastMsg", data);
};

/**
 * Sends a toast message
 * options: {
 *	Text1: options.title,
 *	Text2: options.body, // optional
 *  Severity: "error" | "success",
 *  ScheduleTime, // yyyy-MM-dd hh:mm:ss
 *  Tag: Group id to be able to enum tiles of a specific group at a later time
 *	DeepLink: { // optional
 *		Title,
 *		Url,
 *	}
 * }
 */
exports.scheduledMsg = function(options) {
	var data = JSON.stringify(options);
	nativeExtCall.fireMethod("smMsg", "scheduledMsg", data);
};
/**
 * Returns the test js wrapper
 */
exports.init = function(testMode) {
	if (window && window.smMsg) return;
	if (!testMode) return;
	log && log("Creating native msg test wrapper");
	window.smMsg = nativeTestMessages.create();
	return window.smMsg;
};
});

define('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestPenInput',['require','exports','module','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativePenInput");

var _TestNativeWrapper = function() {

	this.getPenTextInputSupported = function() {
		return true;
	};
	this.getAnnotatedImageSupported = function() {
		return true;
	};
	this.getSignatureImageSupported = function(options) {
		return true;
	};
	this.getPenTextInput = function(context) {
		context = context ? JSON.parse(context) : {};
		var text = window.prompt(context.Title || "Enter the text", context.Value || "");
		var data = {
			Action: text == null || text.trim().length === 0 ? "cancelled" : "ok",
			//Returns an array of words
			Matches: text ? text.split(' ') : null
		};
		setTimeout(function() {
			window.smPenInputJS.penInputTextFinished(data);
		}, 50);
	};
	this.getAnnotatedImage = function(options) {
		var img = "";
		setTimeout(function() {
			var data = {
				Action: "ok",
				ImageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsSAAALEgHS3X78AAAAGklEQVR42mOYacxANmIY1TyqeVTzqOaB1QwApdw+0KHEWp0AAAAASUVORK5CYII="
			};
			log && log("Annotated Image GET ");
			window.smPenInputJS.penAnnotateImageFinished(data);
		}, 100);
	};
	this.getSignatureImage = function(options) {
		var img = "";
		setTimeout(function() {
			var data = {
				Action: "ok",
				ImageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsSAAALEgHS3X78AAAAGklEQVR42mOYacxANmIY1TyqeVTzqOaB1QwApdw+0KHEWp0AAAAASUVORK5CYII="
			};
			log && log("Signature Image GET ");
			window.smPenInputJS.penSignatureImageFinished(data);
		}, 100);
	};

};

exports.create = function() {
	return new _TestNativeWrapper();
};
});

define('syracuse-tablet/html/js/helpers/native/nativePenInput',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestPenInput','syracuse-tablet/html/js/helpers/native/nativeExtCall'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativePenInput");
var nativeTestPenInput = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestPenInput');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');

var _currentInputDeferred;

// Global object to be called by native code on pencil events
if (!(window.smPenInputJS)) {
	window.smPenInputJS = {

		/*
		 *  This method will be invoked from wrapper once the pen input has finished or failed
		 *  data:
		 *  {
		 *  	Action: "ok" | "cancelled",
		 *  	Matches: ["match 1", "match 2"]
		 *  }
		 */
		penInputTextFinished: function(data) {
			if (_currentInputDeferred) {
				var def = _currentInputDeferred;
				_currentInputDeferred = null;
				log && log("Got pen input: " + JSON.stringify(data || {}));
				def.resolve({
					action: data.Action,
					matches: data.Matches
				});
			}
		},
		/*
		 *  This method will be invoked from wrapper once the user
		 *  finished drawing lines on the image he wants to draw annotations on
		 *  data:
		 *  {
		 *  	Action: "ok" | "cancelled",
		 *  	ImageData: "base64string with new image data" (data:image/jpeg;base64,AFHXSJKAHSFKLJH)
		 *  }
		 */
		penAnnotateImageFinished: function(data) {
			if (_currentInputDeferred) {
				var def = _currentInputDeferred;
				_currentInputDeferred = null;
				def.resolve({
					action: data.Action,
					imageData: data.ImageData
				});
			}
		},

		/*
		 *  This method will be invoked from wrapper once the user
		 *  finished to draw his signature
		 *  data:
		 *  {
		 *  	Action: "ok" | "cancelled",
		 *  	ImageData: "base64string with new image data" (data:image/jpeg;base64,AFHXSJKAHSFKLJH)
		 *  }
		 */
		penSignatureImageFinished: function(data) {
			if (_currentInputDeferred) {
				var def = _currentInputDeferred;
				_currentInputDeferred = null;
				def.resolve({
					action: data.Action,
					imageData: data.ImageData
				});
			}
		}
	};
}

/**
 *
 */
exports.supports = function(capability) {
	log && log("Pen check support: " + capability);
	if (capability === "penTextInput") {
		return nativeExtCall.isSupported("smPenInput", "getPenTextInputSupported");
	}
	if (capability === "penAnnotatedImage") {
		return nativeExtCall.isSupported("smPenInput", "getAnnotatedImageSupported");
	}
	if (capability === "penSignatureImage") {
		return nativeExtCall.isSupported("smPenInput", "getSignatureImageSupported");
	}
	return false;
};

/**
 * Trigger pen input modal in native shell
 * options:
 * {
 *      title: Title to display above input area,
 *      value: Current field value // Must be of type string!
 * }
 */
exports.getPenTextInput = function(options) {
	if (options && options.value != null) {
		options.value = "" + options.value;
	}
	var data = JSON.stringify({
		Title: options.title,
		Value: options.value
	});
	_currentInputDeferred = $.Deferred();
	nativeExtCall.fireMethod("smPenInput", "getPenTextInput", data);
	return _currentInputDeferred.promise();
};

/**
 * Trigger pen input on an image to allow highlighting with pencil
 * options:
 * {
 *      title: Title of image property
 *      imageData: base64 string containing image data (data:image/jpeg;base64,AFHXSJKAHSFKLJH)
 * }
 */
exports.getAnnotatedImage = function(options) {
	var data = JSON.stringify({
		Title: options.title,
		ImageData: options.imageData
	});
	_currentInputDeferred = $.Deferred();
	nativeExtCall.fireMethod("smPenInput", "getAnnotatedImage", data);
	return _currentInputDeferred.promise();

};

/**
 * Trigger pen input to allow user to input his signature
 * options:
 * {
 *      title: Title of page
 *      watermark: Text that will be embedded in the image (e.g. a timestamp)
 *		maxWidth: 640 - Max width of signature image in pixels
 *		maxHeight: 480 - Max height of signature image in pixels
 *      watermarkSize: 16 - Height of watermark text. If text is too long or to high to fit, this size may be shrinked
 * }
 */
exports.getSignatureImage = function(options) {
	var data = JSON.stringify({
		Title: options.title,
		Watermark: (options.watermark != null ? ("" + options.watermark) : ""),
		MaxWidth: (options.maxWidth != null ? (+options.maxWidth) : 640),
		MaxHeight: (options.maxHeight != null ? (+options.maxHeight) : 480),
		WatermarkSize: (options.watermarkSize != null ? (+options.watermarkSize) : 16)
	});
	_currentInputDeferred = $.Deferred();
	nativeExtCall.fireMethod("smPenInput", "getSignatureImage", data);
	return _currentInputDeferred.promise();

};
/**
 * Returns the test js wrapper
 */
exports.init = function(testMode) {
	if (window && window.smPenInput) return;
	if (!testMode) return;
	log && log("Creating native Pen Input test wrapper");
	window.smPenInput = nativeTestPenInput.create();
	return window.smPenInput;
};
});

define('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestImage',['require','exports','module'],function (require, exports, module) {"use strict";

var _TestNativeWrapper = function() {

	this.getPictureFromCameraSupported = function() {
		return true;
	};
	this.getScaledImageSupported = function() {
		return true;
	};
	this.getPictureFromCamera = function(options) {
		setTimeout(function() {
			var data = {
				Action: "ok",
				ImageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsSAAALEgHS3X78AAAAGklEQVR42mOYacxANmIY1TyqeVTzqOaB1QwApdw+0KHEWp0AAAAASUVORK5CYII="
			};
			window.smImageJS.getPictureFromCameraFinished(data);
		}, 100);
	};
	this.getScaledImage = function(options) {
		setTimeout(function() {
			var data = {
				Action: "ok",
				ImageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsSAAALEgHS3X78AAAAGklEQVR42mOYacxANmIY1TyqeVTzqOaB1QwApdw+0KHEWp0AAAAASUVORK5CYII="
			};
			window.smImageJS.getScaledImageFinished(data);
		}, 100);
	};
};

exports.create = function() {
	return new _TestNativeWrapper();
};
});

define('syracuse-tablet/html/js/helpers/native/nativeImage',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestImage','syracuse-tablet/html/js/helpers/native/nativeExtCall'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeCamera");
var nativeTestImage = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestImage');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');

var _currentDeferred;

// Global object to be called by native code on pencil events
if (!(window.smImageJS)) {
	window.smImageJS = {

		/*
		 *  data:
		 *  {
		 *  	Action: "ok" || "cancelled" || "error"
		 *  	ImageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhE....",
		 *  	Message: "Error message in case action=error"
		 *  }
		 */
		getPictureFromCameraFinished: function(data) {
			log && log("Got image!");
			if (_currentDeferred) {
				var def = _currentDeferred;
				_currentDeferred = null;
				log && log("Got image: " + JSON.stringify(data || {}));
				def.resolve({
					action: data.Action,
					imageData: data.ImageData
				});
			}
		},
		/*
		 *  	Action: "ok" || "error" || "unchanged"
		 *  	ImageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhE....",
		 *  	Width: width
		 *  	Height: height
		 */
		getScaledImageFinished: function(data) {
			log && log("Got scaled image!");
			if (_currentDeferred) {
				var def = _currentDeferred;
				_currentDeferred = null;
				log && log("Got scaled image: " + JSON.stringify(data || {}));
				def.resolve({
					action: data.Action,
					imageData: data.ImageData,
					width: data.Width,
					height: data.Height
				});
			}
		}
	};
}
/**
 *
 */
exports.supports = function(capability) {
	if (capability === "camera") {
		return nativeExtCall.isSupported("smImage", "getPictureFromCameraSupported");
	}
	if (capability === "imageScale") {
		return nativeExtCall.isSupported("smImage", "getScaledImageSupported");
	}
	return false;
};

/**
 * Options are available as parameter but it's not used yet!
 * options:
 * {
 * }
 */
exports.getPictureFromCamera = function(options) {
	// No options yet!
	var param = {};
	_currentDeferred = $.Deferred();
	nativeExtCall.fireMethod("smImage", "getPictureFromCamera", param);
	return _currentDeferred.promise();
};

/**
 * options: {
 *   imageData: Data of image to scale: data:image/png;base64,iVBORw0KGgoAAAANSUh
 *   width: Desired width
 *   height: Desired height,
 *
 *   mode: "LIMIT_MAX_WIDTH_AND_HEIGHT"
 * }
 *
 *  Modes:
 *  LIMIT_MAX_WIDTH_AND_HEIGHT:
 *  Ensures that width and height do not exceed the values given in the options
 *  If one of the two is bigger that desired, both are scaled down to preserver the aspect ratio
 */
exports.getScaledImage = function(options) {
	var data = {
		ImageData: options.imageData,
		Width: options.width,
		Height: options.height,
		Mode: options.mode
	};
	_currentDeferred = $.Deferred();
	nativeExtCall.fireMethod("smImage", "getScaledImage", data);
	return _currentDeferred.promise();
};
/**
 * Returns the test js wrapper
 */
exports.init = function(testMode) {
	if (window && window.smImage) return;
	if (!testMode) return;
	log && log("Creating native image test wrapper");
	window.smImage = nativeTestImage.create();
	return window.smImage;
};
});

define('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestVoiceCommands',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {"use strict";

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

var _phraseListHtml = '\
	<div id="phraseListId" class="s-m-test-wrapper" title="Test voice commands">\
		<div class="dropdown" style="padding-right:0px">\
	  		<span class="dropdown-toggle fa fa-microphone" data-toggle="dropdown" aria-expanded="true">\
	  		</span>\
	  		<ul class="dropdown-menu dropdown-menu-left" role="menu">\
				{{#each list}}\
					<li><a style="" draggable="false" href="#">{{title}}</a></li>\
				{{/each}}\
			</ul>\
		</div>\
	</div>';

var _getPhraseListMenu = function(ctx) {
	return Handlebars.compile(_phraseListHtml)(ctx);
};



var _TestNativeWrapper = function() {

	this.onClickPhrase = function(event) {
		var $$t = $(event.target);
		var text = $$t.text();
		if (!text || text.trim().length === 0) return;
		setTimeout(function() {
			window.smVoiceJS.executeVoiceCommand({
				Command: "openBookmark",
				Text: text
			});
		});
	};

	// phraseList: Array[24]
	this.phraseList = null;

	this.setPhraseListSupported = function() {
		return true;
	};

	this.setPhraseList = function(data) {
		data = data ? JSON.parse(data) : null;
		this.phraseList = null;
		if (data && data.PhraseList && data.PhraseList.length > 0) {
			var self = this;
			this.phraseList = [];
			data.PhraseList.forEach(function(item) {
				self.phraseList.push({
					title: item
				});
			});
		};
	};
	/**
	 * Adds a button (mic) in header that displays a dropdown list to allow to test voice commands
	 * Selecting an item will trigger a voice command
	 */
	this.appendHeaderTestCmds = function($$root) {
		if (!$$root || !this.setPhraseListSupported()) return;
		$$root.find("#phraseListId").off().remove();
		var $$html = this.phraseList ? $(_getPhraseListMenu({
			list: this.phraseList
		})) : null;
		if ($$html == null) return;
		$$html.appendTo($$root).click(jsutils.bindFn(this.onClickPhrase, this));
	};
};


exports.create = function() {
	var url = jsutils.getCurrentUrl();
	if (window.smVoiceJS && url.query && url.query.voiceCommand) {
		try {
			window.smVoiceJS.executeVoiceCommand({
				command: "openBookmark",
				text: url.query.voiceCommand
			});
		} catch (e) {}
	}
	return new _TestNativeWrapper();
};
});

define('syracuse-tablet/html/js/helpers/native/nativeVoiceCommands',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestVoiceCommands','syracuse-tablet/html/js/helpers/native/nativeHelpers','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/native/nativeExtCall'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeVoice");
var locale = require('syracuse-tablet/html/js/helpers/locale');
var nativeTestVoiceCommands = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestVoiceCommands');
var nativeHelpers = require('syracuse-tablet/html/js/helpers/native/nativeHelpers');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');

var _VoiceCommandsMgr = function(bookmarks) {

	this.isReady = false;

	this.init = function(mobileCommands) {
		notifications.subscribe(this, ["sm.application.ready"]);
		this.availableCommands = [];
		if (!mobileCommands || mobileCommands.length === 0) return false;
		var self = this,
			ok = false;
		mobileCommands.forEach(function(b) {
			ok = self.add(b) || ok;
		});
		return ok;
	};
	/**
	 * {type: "openBookmark", title: "...", other props}
	 */
	this.add = function(mobileCommand) {
		if (!mobileCommand || !mobileCommand.title) {
			return false;
		}
		if (this.getAvailableCommand(mobileCommand.title)) {
			log && log("add voice command - Command already exists '" + mobileCommand.title + "'");
			return false;
		}
		log && log("add voice command - '" + mobileCommand.title + "'");
		// Last are shown first (test wrapper)
		this.availableCommands.unshift(mobileCommand);
		return true;
	};

	this.remove = function(title) {
		if (!title) return false;
		var idx;
		if (this.availableCommands.some(function(b, i) {
			if (b.title === title) {
				idx = i;
				return true;
			}
		})) {
			this.availableCommands.splice(idx, 1);
			log && log("remove voice command - '" + title + "'");
			return true;
		}
		return false;
	};
	/**
	 * Returns the command if keyword matches with a command's title
	 */
	this.getAvailableCommand = function(keyWord) {
		var mobileCommand = null,
			self = this;
		this.availableCommands.some(function(b, i) {
			if (b.title === keyWord) {
				mobileCommand = self.availableCommands[i];
				return true;
			}
		});
		return mobileCommand;
	};
	/**
	 *
	 */
	this.executeOperation = function(operation) {
		if (!operation) return;
		var refresh = false;
		switch (operation) {
			case "set":
				refresh = this.init(arguments[1]);
				break;
			case "add":
				refresh = this.add(arguments[1]);
				break;
			case "remove":
				refresh = this.remove(arguments[1]);
				break;
			default:
				return;
		}
		if (refresh) {
			var phraseList = [];
			this.availableCommands.forEach(function(b) {
				phraseList.push(b.title);
			});
			var data = JSON.stringify({
				Phrase: "bookmark",
				PhraseList: phraseList,
				Language: locale.getCurrentLocale().toLowerCase()
			});
		}
		if (data) {
			log && log("Update voiceCommands: " + JSON.stringify(data, null, 2));
			nativeExtCall.fireMethod("smVoice", "setPhraseList", data);
		}
	};
	/**
	 * Application is ready
	 */
	this.notifApplicationReady = function() {
		// First
		this.isReady = true;
		// Check pending commands
		var cmd = this.getPendingCommand("openBookmark");
		if (cmd) {
			log && log("Execute pending command - '" + cmd.title + "'");
			this.executeVoiceCommand(cmd);
		}
		this.pendingCommands = null;
	};

	this.executeVoiceCommand = function(data) {
		if (this.isReady) {
			if (!data || !data.command || !data.text) return;
			var cmd = this.getAvailableCommand(data.text);
			if (!cmd || data.command !== cmd.type) return;
			log && log("Execute voice command - '" + cmd.title + "'");
			nativeHelpers.callAppNativeInterface("voiceCommands", "executeVoiceCommand", cmd);
			return;
		}
		// Stores the command
		if (!this.pendingCommands) {
			this.pendingCommands = [];
		}
		log && log("Stores pending voice command - '" + data.text + "'");
		this.pendingCommands.push(data);
	};

	this.getPendingCommand = function(type) {
		if (!this.pendingCommands) return null;
		var bmk = null;
		this.pendingCommands.some(function(cmd) {
			if (!cmd || cmd.command !== type) return;
			bmk = cmd;
			return true;
		});
		return bmk;
	};

	this.hasPendingCommand = function(type) {
		return this.getPendingCommand(type) != null;
	};

	// At the end
	this.init();
};
/**
 * Manages bookmarks
 * Created here to be available ASAP
 */
var _voiceCommandsManager = new _VoiceCommandsMgr();

//Global object to be called by native code on pencil events
if (!(window.smVoiceJS)) {
	window.smVoiceJS = {

		/*
		 *  This method will be invoked from wrapper when there was a voice command
		 *
		 *  return true - Command has been handled by webapp
		 *  return false - Command has not been handled, will raise an error message
		 *
		 *  For Hey cortana, show my customers
		 *  data {
		 *  	Command: "openBookmark",
		 *  	Text: "my customers"
		 *  }
		 */
		executeVoiceCommand: function(data) {
			if (!_voiceCommandsManager || !data) return;
			_voiceCommandsManager.executeVoiceCommand({
				command: data.Command,
				text: data.Text
			});
		}
	};
}
/**
 *
 */
exports.supports = function(capability) {
	if (capability === "voiceCommands") {
		return nativeExtCall.isSupported("smVoice", "setPhraseListSupported");
	}
	return false;
};
/**
 *commands [{type: "openBookmark", title: "...", context: { see page.getRestoreContext }}
 */
exports.setVoiceCommands = function(commands) {
	_voiceCommandsManager.executeOperation.call(_voiceCommandsManager, "set", commands);
};
/**
 * {type: "openBookmark", title: "...", context: { see page.getRestoreContext }
 */
exports.addVoiceCommand = function(command) {
	_voiceCommandsManager.executeOperation.call(_voiceCommandsManager, "add", command);
};
/**
 * Remove the command identified by tutle
 */
exports.removeVoiceCommand = function(title) {
	_voiceCommandsManager.executeOperation.call(_voiceCommandsManager, "remove", title);
};
/**
 * True if there is a pending command of the given type to execute
 * type: openBookmark...
 */
exports.hasPendingCommand = function(type) {
	return _voiceCommandsManager.hasPendingCommand(type);
};
/**
 * Create a voice command from a pinned page
 * voiceCommandContext is the context used to restore the page
 */
exports.createCommandFromPage = function(pinnedPage, alternativeTitle) {
	if (!pinnedPage) return null;
	if (!pinnedPage.voiceCommandContext) return null;
	if (!alternativeTitle && !pinnedPage.title) return null;

	return {
		type: "openBookmark",
		title: alternativeTitle || pinnedPage.title,
		context: $.extend(true, {}, pinnedPage.voiceCommandContext)
	};
};
/**
 * Create a voice command from a application description
 * It switches to the application and opens the home page of application
 */
exports.createCommandFromAppli = function(title, appInfo) {
	if (!title || !appInfo || !appInfo.applicationName) return null;
	return {
		type: "openBookmark",
		title: title,
		context: {
			applicationName: appInfo.applicationName,
			// Just in case we want to ask user to select a endpoint when we switch to this application
			endpoints: appInfo.endpoints
		}
	};
};
/**
 * Returns the test js wrapper
 */
exports.init = function(testMode) {
	if (window && window.smVoice) return;
	if (!testMode) return;
	log && log("Creating native voice commands test wrapper");
	window.smVoice = nativeTestVoiceCommands.create();
	return window.smVoice;
};
});

define('syracuse-tablet/html/js/storage/localStorage',['require','exports','module','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {"use strict";

/**
 * Local storage
 * Uses only window local storage
 */

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("sessstorage");

var _available = null;

var _isAvailable = function() {
	if (_available !== null) {
		return _available;
	}
	_available = false;
	try {
		window.localStorage.setItem("__test_availability__", "__test_availability__");
		_available = true;
	} catch (e) {}
	return _available;
};

var _getItem = function(key, removeAfter) {
	if (!_isAvailable()) {
		log && log("local.unsupported.getItem(" + key + "):" + val);
		return;
	}
	var val = window.localStorage.getItem(key);
	log && log("local.getItem(" + key + "):" + val);
	if (true === removeAfter) {
		_removeItem(key);
	}
	return val;
};

var _setItem = function(key, value) {
	if (!_isAvailable()) {
		log && log("local.unsupported.setItem(" + key + "):" + value);
		return;
	}
	log && log("local.setItem(" + key + "):" + value);
	return window.localStorage.setItem(key, value);
};

var _removeItem = function(key) {
	if (!_isAvailable()) {
		log && log("local.unspported.removeItem(" + key + ")");
		return;
	}
	log && log("local.removeItem(" + key + ")");
	return window.localStorage.removeItem(key);
};

exports.removeItem = _removeItem;
exports.setItem = _setItem;
exports.getItem = _getItem;
});

define('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestApp',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/storage/localStorage','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestHelpers'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("X3WUPApp", false);
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var localStorage = require('syracuse-tablet/html/js/storage/localStorage');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var nativeHelpers = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestHelpers');

var _closeAppliBtn = '\
	<div id="x3wupappclosebtn" class="s-m-test-wrapper" title="Close application">\
		<a href="#" draggable="false" style= "color:#41a940";>\
		<i class="fa fa-power-off"></i>\
		</a>\
	</div>';

var _addCloseAppliBtn = function($$root) {
	$$root.find("#x3wupappclosebtn").off().remove();
	return $(Handlebars.compile(_closeAppliBtn)()).appendTo($$root);
	//	.css({
	//		"color": "#41a940",
	//		"float": "right",
	//		"padding-left": "8px",
	//		"font-size": ".7em",
	//		"top": "8px",
	//		"position": "relative"
	//	})
};

var _TestNativeWrapper = function() {

	this.nativeWrapperSupported = function() {
		return true;
	};
	this.openExternalLinkSupported = function() {
		return true;
	};

	// This will hide html back button and only allow the one of the browser toolbar
	this.hardwareBackButtonSupported = function() {
		return true;
	};

	this.notifApplicationReady = function(ok) {
		// To not reaload a bad context
		localStorage.removeItem("$reconnectContext");
	};

	this.onClickCloseAppli = function() {
		this.onWebappUnloaded();
	};

	this.onWebappLoaded = function() {};
	/**
	 * historyContext is s a string
	 */
	this.onWebappUnloaded = function() {
		if (!window.smWrapperJS) return;
		try {
			this.setReconnectContext(nativeHelpers.callAppNativeInterface("nativeApp", "applicationClosing"));
			setTimeout(function() {
				window.location.reload();
			}, 100);
		} catch (e) {
			console.log(e.stack);
			return e.message;
		}
	};
	/**
	 *
	 */
	this.webappConfigServer = function() {};
	this.webappSelectServer = function() {};
	/**
	 * context is s a string
	 */
	this.setReconnectContext = function(context) {
		try {
			log && log("setReconnectContext", context);
			localStorage.setItem("$reconnectContext", context);
		} catch (e) {
			log && log("setReconnectContext", JSON.stringify(e));
		}
	};
	/**
	 * Returns a String
	 */
	this.getReconnectContext = function() {
		try {
			var context = localStorage.getItem("$reconnectContext");
			log && log("getReconnectContext", context);
			return context;
		} catch (e) {
			log && log("getReconnectContext", JSON.stringify(e));
			return null;
		}
	};
	/**
	 * Returns a String
	 */
	this.getReconnectToken = function() {
		try {
			var token = localStorage.getItem("$reconnectToken");
			log && log("getReconnectToken", token);
			return token;
		} catch (e) {
			log && log("getReconnectToken", JSON.stringify(e));
			return null;
		}
	};
	/**
	 * token is a string
	 *{
	 *		SyracuseSidLogin: token,
	 *		UserLogin: userLogin
	 *};
	 */
	this.setReconnectToken = function(token, userLogin) {
		try {
			log && log("setReconnectToken", token, userLogin);
			token = token ? JSON.parse(token) : null;
			token = token && token.SyracuseSidLogin;
			localStorage.setItem("$reconnectToken", token);
		} catch (e) {
			log && log("setReconnectToken", JSON.stringify(e));
		}
	};
	/**
	 * Add a button into the header to simulate a close-application event from native wrapper + reload the application and restore the context
	 */
	this.appendHeaderTestCmds = function($$root) {
		if (!$$root || !this.nativeWrapperSupported()) return;
		_addCloseAppliBtn($$root).click(jsutils.bindFn(this.onClickCloseAppli, this));
	};

	// at the end
	notifications.subscribe(this, ["sm.application.ready"]);

};
exports.create = function() {
	return new _TestNativeWrapper();
};
});

define('syracuse-tablet/html/js/helpers/native/nativeApp',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/ajax/ajax','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestApp','syracuse-tablet/html/js/helpers/native/nativeHelpers','syracuse-tablet/html/js/helpers/native/nativeExtCall'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeWUPApp");
var ajax = require('syracuse-tablet/html/js/ajax/ajax').getAjax().ajax;
var nativeTestApp = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestApp');
var nativeHelpers = require('syracuse-tablet/html/js/helpers/native/nativeHelpers');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');


//Global object to be called by native code on low level events
if (!(window.smWrapperJS)) {
	window.smWrapperJS = {

		/*
		 *  This method will be invoked from wrapper when the user clicks the
		 *  hardware back button
		 *
		 *  return "true" - Back action is handled by JS code
		 *  return "false" - Back action is handled by native code (usually to close app).
		 */
		backButtonPressed: function() {
			return nativeHelpers.callAppNativeInterface("nativeApp", "backButtonPressed") ? "true" : "false";
		},

		/*
		 * Called by native wrapper when the application is going to terminate
		 */
		applicationClosing: function() {
			var currentHistoryStack = nativeHelpers.callAppNativeInterface("nativeApp", "applicationClosing");
			return currentHistoryStack;
		},

		/*
		 * Called only on the following scenaria
		 * Application is loaded but the user navigates back on a page that is driven by native code
		 * so the web app becomes invisible
		 * As soon as the user decides to start the same web app again (make it visible again) this method is called.
		 *
		 * The intention of this method is to check for online/offline mode and other things that may have changed
		 * since the web app was visible for the last time
		 */
		applicationActivated: function() {
			nativeHelpers.callAppNativeInterface("nativeApp", "applicationActivated");
		},

		/*
		 * connected:
		 * true: The index.html used to start this app can be accessed by the wrapper which usually means network is ok
		 * false: Network is down, index.html is not accessible
		 */
		connectivityChanged: function(connected) {
			log && log("connectivityChanged: " + connected);
			globals.setOffline(connected != true, false, true);
		}
	};
}


/**
 * Running inside a native container?
 * !!! Return a boolean
 */
exports.supports = function(capability) {
	if (capability === "nativeApp") {
		return nativeExtCall.isSupported("smApp", "nativeWrapperSupported");
	}
	if (capability === "hardwareBackButton") {
		return nativeExtCall.isSupported("smApp", "hardwareBackButtonSupported");
	}
	if (capability === "dispatcherListener") {
		return nativeExtCall.isSupported("smApp", "dispatcherListenerSupported");
	}
	if (capability === "extLink") {
		return nativeExtCall.isSupported("smApp", "openExternalLinkSupported");
	}
	return false;
};

/**
 * Opens a link in a new browser window
 */
exports.openExternalLink = function(url) {
	nativeExtCall.fireMethod("smApp", "openExternalLink", url);
};

/**
 * Management of reconnection
 * Returns the login token (reconnectToken) as string
 */
exports.getReconnectToken = function() {
	var token = nativeExtCall.callMethod("smApp", "getReconnectToken");
	if (token) {
		try {
			token = JSON.parse(token);
			return token.SyracuseSidLogin;
		} catch (e) {}
		return token;
	}
	return null;
};
/**
 * Management of reconnection
 * Stores the login token (reconnectToken)
 * Native method is called with a stringified context
 * token: login cookie provided by syracuse server
 * userLogin: user name (login) stored in login cookie
 */
exports.setReconnectToken = function(token, userLogin) {
	if (typeof token === "string") {
		token = {
			SyracuseSidLogin: token,
			UserLogin: userLogin
		};
	}
	nativeExtCall.fireMethod("smApp", "setReconnectToken", token);
};
/**
 * Management of reconnection
 * Returns the user context to restore (context) as string
 * {
 * 		userCtx:
 * 		userProfile:
 *  	context:
 *  }
 */
exports.getReconnectContext = function() {
	return nativeExtCall.callMethod("smApp", "getReconnectContext");
};
/**
 * Management of reconnection
 * Stores the user context
 * Native method is called with a stringified context
 */
exports.setReconnectContext = function(context) {
	nativeExtCall.fireMethod("smApp", "setReconnectContext", context);
};
exports.configServer = function() {
	nativeExtCall.fireMethod("smApp", "configServer");
};
exports.selectServer = function() {
	nativeExtCall.fireMethod("smApp", "selectServer");
};

/*
 * This is ment to allow the wrapper to listen to dispatched sdata events
 * Can be used to trigger actions on the native side transparently
 *
 * E.g. if a native wrapper shows a live feed of data somewhere (live tiles) he can check if the sdata
 * url dispatched here concerns the same class as the data feed and trigger an internal update
 * without forcing the JS code to know about it
 *
 * link:
 * {
 * 	 Method: PUT|GET|POST
 * 	 Url: what ever url
 * }
 */
exports.dispatcherNotifyAfter = function(link) {
	nativeExtCall.fireMethod("smApp", "dispatcherNotifyAfter", link);
};


/*
 * Invokes the native app to tell loading the app has been finished to avoid a timeout
 */
exports.notifLoaded = function() {
	log && log("notifLoaded");
	nativeExtCall.fireMethod("smApp", "webappLoaded");
};

/*
 * Invokes the native app to tell application is unloaded
 * historyContext	Page history stack
 * 					Used by natoveTestWrapper top store history
 * Can return a message to display (error)
 */
exports.notifUnloaded = function(historyContext) {
	// This is only used by test code
	log && log("OnWebappUnloaded");
	if (window && window.smApp && window.smApp.onWebappUnloaded) {
		return window.smApp.onWebappUnloaded(historyContext ? JSON.stringify(historyContext, null, 2) : null);
	}
};

/*
 * Invokes native app to signal there was a critical error loading the app
 */
exports.notifStartFail = function(msg) {
	nativeExtCall.fireMethod("smApp", "webappLoadFail", msg);
};
/**
 * Returns the test js wrapper
 */
exports.init = function(testMode) {
	if (window && window.smApp) return;
	if (!testMode) return;
	log && log("Creating native nativeApp test wrapper");
	window.smApp = nativeTestApp.create();
	return window.smApp;
};
});

define('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestSensors',['require','exports','module'],function (require, exports, module) {"use strict";

var _TestNativeWrapper = function() {

	this.getGPSCoordinatesSupported = function() {
		return true;
	};
	this.getGPSCoordinates = function(options) {
		setTimeout(function() {
			var data = {
				Latitude: Math.random() * 100,
				Longitude: Math.random() * 100,
				Succeeded: true
			};
			window.smSensorsJS.getGPSCoordinatesFinished(data);
		}, 1000);
	};
};

exports.create = function() {
	return new _TestNativeWrapper();
};
});

define('syracuse-tablet/html/js/helpers/native/nativeSensors',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestSensors','syracuse-tablet/html/js/helpers/native/nativeExtCall'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeSensors", true);
var nativeTestSensors = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestSensors');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');

var _currentDeferred;

// Global object to be called by native code on pencil events
if (!(window.smSensorsJS)) {
	window.smSensorsJS = {

		/*
		 *  data:
		 *  {
		 *  	Latitude: 1.289374,
		 *  	Longitude: 14.1234124,
		 *  	Succeeded: true/false,
		 *  	Error: unknown,timeout,denied
		 *  }
		 */
		getGPSCoordinatesFinished: function(data) {
			log && log("Got GPS");
			if (_currentDeferred) {
				var def = _currentDeferred;
				_currentDeferred = null;
				log && log("Got GPS: " + JSON.stringify(data || {}));

				def.resolve({
					latitude: data.Latitude,
					longitude: data.Longitude,
					succeeded: data.Succeeded,
					error: data.Error
				});
			}
		}
	};
}
/**
 *
 */
exports.supports = function(capability) {
	if (capability === "GPS") {
		return nativeExtCall.isSupported("smSensors", "getGPSCoordinatesSupported");
	}
	return false;
};

/**
 */
exports.getGPSCoordinates = function() {
	_currentDeferred = $.Deferred();
	nativeExtCall.fireMethod("smSensors", "getGPSCoordinates");
	return _currentDeferred.promise();
};
/**
 * Returns the test js wrapper
 */
exports.init = function(testMode) {
	if (window && window.smSensors) return;
	if (!testMode) return;
	log && log("Creating native gps test wrapper");
	window.smSensors = nativeTestSensors.create();
	return window.smSensors;
};
});

define('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestBarcode',['require','exports','module'],function (require, exports, module) {"use strict";

var _TestNativeWrapper = function() {
	this.scanBarcodeSupported = function() {
		return true;
	};
	this.scanBarcode = function(options) {
		var bc = window.prompt("Enter the barcode", "");
		var data = {
			Action: bc == null || bc.trim().length === 0 ? "cancelled" : "ok",
			Content: bc,
			Format: "QR_CODE"
		};
		setTimeout(function() {
			window.smBarcodeJS.scanBarcodeFinished(data);
		}, 100);
	};
};

exports.create = function() {
	return new _TestNativeWrapper();
};
});

define('syracuse-tablet/html/js/helpers/native/nativeBarcode',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestBarcode','syracuse-tablet/html/js/helpers/native/nativeExtCall'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeCamera");
var nativeTestBarcode = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestBarcode');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');

var _currentDeferred;

// Global object to be called by native code on pencil events
if (!(window.smBarcodeJS)) {
	window.smBarcodeJS = {

		/*
		 *  data:
		 *  {
		 *  	Action: "ok" || "cancelled" || "error"
		 *  	Content: "Content of scanned barcode"
		 *  	Format: "Barcode format",
		 *  }
		 */
		scanBarcodeFinished: function(data) {
			log && log("Got image!");
			if (_currentDeferred) {
				var def = _currentDeferred;
				_currentDeferred = null;
				log && log("Got barcode: " + JSON.stringify(data || {}));
				def.resolve({
					action: data.Action,
					content: data.Content,
					format: data.Format
				});
			}
		}
	};
}
/**
 *
 */
exports.supports = function(capability) {
	if (capability === "scanBarcode") {
		return nativeExtCall.isSupported("smBarcode", "scanBarcodeSupported");
	}
	return false;
};

/**
 * Options are available as parameter but it's not used yet!
 * options:
 * {
 * }
 */
exports.scanBarcode = function(options) {
	// No options yet!
	var param = {};
	_currentDeferred = $.Deferred();
	nativeExtCall.fireMethod("smBarcode", "scanBarcode", param);
	return _currentDeferred.promise();
};

exports.init = function(testMode) {
	if (window && window.smBarcode) return;
	if (!testMode) return;
	log && log("Creating native barcode test wrapper");
	window.smBarcode = nativeTestBarcode.create();
};
});

define('syracuse-tablet/html/js/helpers/native/native',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/native/nativeExtCall','syracuse-tablet/html/js/helpers/native/nativeShare','syracuse-tablet/html/js/helpers/native/nativeLiveTile','syracuse-tablet/html/js/helpers/native/nativeMessages','syracuse-tablet/html/js/helpers/native/nativePenInput','syracuse-tablet/html/js/helpers/native/nativeImage','syracuse-tablet/html/js/helpers/native/nativeVoiceCommands','syracuse-tablet/html/js/helpers/native/nativeApp','syracuse-tablet/html/js/helpers/native/nativeSensors','syracuse-tablet/html/js/helpers/native/nativeBarcode'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("native");
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');

var _modules = {
	"nativeShare": require('syracuse-tablet/html/js/helpers/native/nativeShare'),
	"nativeLiveTile": require('syracuse-tablet/html/js/helpers/native/nativeLiveTile'),
	"nativeMessages": require('syracuse-tablet/html/js/helpers/native/nativeMessages'),
	"nativePenInput": require('syracuse-tablet/html/js/helpers/native/nativePenInput'),
	"nativeImage": require('syracuse-tablet/html/js/helpers/native/nativeImage'),
	"nativeVoiceCommands": require('syracuse-tablet/html/js/helpers/native/nativeVoiceCommands'),
	"nativeApp": require('syracuse-tablet/html/js/helpers/native/nativeApp'),
	"nativeSensors": require('syracuse-tablet/html/js/helpers/native/nativeSensors'),
	"nativeBarcode": require('syracuse-tablet/html/js/helpers/native/nativeBarcode')
};

var _capabilities = {
	"nativeApp": "nativeApp",
	"dispatcherListener": "nativeApp",
	"hardwareBackButton": "nativeApp",

	"extLink": "nativeShare",
	"share": "nativeShare",

	"liveTile": "nativeLiveTile",

	"scheduleMessage": "nativeMessages",
	"toastMessages": "nativeMessages",

	"penTextInput": "nativePenInput",
	"penAnnotatedImage": "nativePenInput",
	"penSignatureImage": "nativePenInput",

	"camera": "nativeImage",
	"imageScale": "nativeImage",

	"voiceCommands": "nativeVoiceCommands",

	"scanBarcode": "nativeBarcode",
	"GPS": "nativeSensors"
};

var _capabilitiesModules = {};
/**
 * Initialization is required here to be able to call
 * var nativeVoiceCommmands = require('syracuse-tablet/html/js/helpers/native/native').getModule("voiceCommands");
 */
var _testMode = false;
var _testWrappers = {};
try {
	var _url = jsutils.getCurrentUrl();
	_testMode = _url.query && _url.query.testNativeWrapper === "true";
	nativeExtCall.init(_testMode);
	for (var m in _modules) {
		if (_modules[m].init) {
			_testWrappers[m] = _modules[m].init(_testMode);
		}
	}
	var module, moduleName;
	Object.keys(_capabilities).forEach(function(capability) {
		_capabilitiesModules[capability] = null;
		moduleName = _capabilities[capability];
		if (moduleName == null) {
			console.log("Native initialization", "No module has been found for capability [" + capability + "]");
			return;
		}
		module = _modules[moduleName];
		if (module == null) {
			console.log("Native initialization", "Unknown native module [" + module + "]");
			return;
		}
		if (module.supports == null) {
			console.log("Native initialization", "Module [" + moduleName + "] must implement 'supports' method");
			return;
		}
		if (module.supports(capability) !== true) {
			return null;
		}
		_capabilitiesModules[capability] = module;
	});
} catch (e) {
	console.log("native initialization failed");
	console.log(e);
}
exports.isTestMode = function() {
	return _testMode;
};
exports.hasCapability = function(capability) {
	return exports.getModule(capability) != null;
};
exports.getModule = function(capability) {
	return _capabilitiesModules[capability];
};

exports.callModule = function(capability, functionName) {
	var module = exports.getModule(capability);
	if (!module || !module[functionName]) return null;
	var args = Array.prototype.slice.call(arguments, 2);
	return module[functionName].apply(null, args);
};
/**
 * Allows the test wrapper to add commands in header
 * Must implement appendHeaderTestCmds
 */
exports.appendHeaderTestCmds = function($$root) {
	if (!exports.isTestMode()) return;
	Object.keys(_testWrappers).forEach(function(name) {
		// We call the test wrapper to keep the native interface clean
		var testWrapper = _testWrappers[name];
		if (testWrapper == null || !testWrapper.appendHeaderTestCmds) return;
		testWrapper.appendHeaderTestCmds($$root);
	});
};
});

define('syracuse-tablet/html/js/ui/rect',['require','exports','module','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');

var _Klass = utils.defineClass(function rect(top, left, height, width) {
	this.top = top;
	this.left = left;
	this.setHeight(height);
	this.setWidth(width);
}, null, {
	// Accept null for x or y 
	isPointInside: function(x, y) {
		return (x == null || (x >= this.left && x <= this.right)) && (y == null || (y >= this.top && y <= this.bottom));
	},
	/**
	 * rectOffset!=null means that the main has scrolled and we need to to correct the coordinates because pageX/pageY are relative document
	 */
	isEvtInside: function(evt, rectOffset) {
		if (evt.type.smStartsWith("touch")) {
			// Touch events are managed completely differently from mouse events - depends on the number of fingers in contact...
			if (evt.changedTouches && evt.changedTouches.length === 1) {
				evt = evt.changedTouches[0];
			} else if (evt.touches && evt.touches.length === 1) {
				evt = evt.touches[0];
			} else {
				// No control -> OK
				return true;
			}
		}
		var y = rectOffset != null && rectOffset.top != null ? evt.pageY - rectOffset.top : evt.pageY;
		var x = rectOffset != null && rectOffset.left != null ? evt.pageX - rectOffset.left : evt.pageX;
		return this.isPointInside(x, y);
	},
	intersectsWith: function(rect) {
		return this.left <= rect.right && rect.left < this.right && this.top < rect.bottom && rect.top < this.bottom;
	},
	contains: function(rect) {
		if (rect == null) return true;
		return this.isPointInside(rect.left, rect.top) && this.isPointInside(rect.right, rect.bottom);
	},
	equals: function(rect, justSize) {
		if (rect.width === this.width && rect.height === this.height) {
			return justSize === true || (rect.top === this.top && rect.left === this.left);
		}
		return false;
	},
	/**
	 * relative	true/false
	 */
	intersectRect: function(rect, relative) {
		if (!this.intersectsWith(rect)) return null;
		var top = Math.max(this.top, rect.top);
		var left = Math.max(this.left, rect.left);
		var right = Math.min(this.right, rect.right);
		var bottom = Math.min(this.bottom, rect.bottom);
		return new _Klass(relative ? 0 : top, relative ? 0 : left, bottom - top, right - left);
	},
	setHeight: function(h) {
		this.height = Math.max(h, 0);
		this.bottom = this.top + this.height;
	},
	setWidth: function(w) {
		this.width = Math.max(w, 0);
		this.right = this.left + this.width;
	},
	moveLeft: function(l) {
		this.left = this.left + l;
		this.right = this.width + this.left;
	},
	toString: function() {
		return "t:" + this.top + " l:" + this.left + " r:" + this.right + " b:" + this.bottom + " h:" + this.height + " w:" + this.width;
	},
	toRelative: function(offet) {
		if (offet == null) offet = {};
		if (offet.top == null) offet.top = 0;
		if (offet.left == null) offet.left = 0;
		return new _Klass(offet.top, offet.left, this.height, this.width);
	},
	/**
	 * timeoutOrColor	optional
	 * 						timeout in ms to delete the div
	 * 						name/code of border color
	 */
	showInDocument: function(options) {
		options = options || {};
		// To pass has param if needed
		var pos = "fixed";
		var $$parent = $(document.body);
		var $$elmt = $('<div class = "s-m-rect">').appendTo($$parent).css({
			position: pos,
			top: this.top + "px",
			left: this.left + "px",
			height: this.height + "px",
			width: this.width + "px",
			backgroundColor: options.color,
			zIndex: options.zIndex != null ? options.zIndex : undefined
		});
		if (options.timeout != null) {
			setTimeout(function() {
				$$elmt.remove();
			}, options.timeout);
		}
		return $$elmt;
	},
	clone: function() {
		return new _Klass(this.top, this.left, this.height, this.width);
	},
	applyTransformScale: function(scale, clone) {
		if (scale == null || scale <= 0 || typeof scale != "number") return;
		var res = clone === true ? this.clone() : this;
		res.width = res.width * scale;
		res.height = res.height * scale;
		// TODO - left / right - ok if they are equal to 0
		return res;
	}
});
var _meths = {
	outer: ["outerWidth", "outerHeight"],
	inner: ["innerWidth", "innerHeight"],
	computed: ["width", "height"],
	fixed: "position",
	relative: "offset"
};
/**
 * Returns the rectangle of $$elmt
 * 	type:		outer / inner / computed
 * 	position	fixed, relative
 * 	myOffset	my offset to shift the rect if any
 */
exports.elmtRect = function($$elmt, typeRect, position) {
	var o = $$elmt[_meths[position || "relative"]]();
	var m = _meths[typeRect || "outer"];
	return new _Klass(o.top, o.left, $$elmt[m[1]](), $$elmt[m[0]]());
};
exports.newRect = function(top, left, height, width) {
	return new _Klass(top, left, height, width);
};
});

/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge]
 * @returns {Object} dest
 */
function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
function merge(dest, src) {
    return extend(dest, src, true);
}

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        extend(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument;
    return (doc.defaultView || doc.parentWindow);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = last.deltaX - input.deltaX;
        var deltaY = last.deltaY - input.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.allow = true; // used by Input.TouchMouse to disable mouse events
    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down, and mouse events are allowed (see the TouchMouse input)
        if (!this.pressed || !this.allow) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */
function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        // when we're in a touch event, so  block all upcoming mouse events
        // most mobile browser also emit mouseevents, right after touchstart
        if (isTouch) {
            this.mouse.allow = false;
        } else if (isMouse && !this.mouse.allow) {
            return;
        }

        // reset the allowMouse when we're done
        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
            this.mouse.allow = true;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        // not needed with native support for the touchAction property
        if (NATIVE_TOUCH_ACTION) {
            return;
        }

        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // pan-x and pan-y can be combined
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.id = uniqueId();

    this.manager = null;
    this.options = merge(options || {}, this.defaults);

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        extend(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(withState) {
            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(true);
        }

        emit(); // simple 'eventName' events

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(true);
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = extend({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {
        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        this._super.emit.call(this, input);
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            this.manager.emit(this.options.event + inOut, input);
        }
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 500, // minimal time of the pointer to be pressed
        threshold: 5 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.65,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.velocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.velocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.velocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.direction &&
            input.distance > this.options.threshold &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 2, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED ) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create an manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.4';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, { enable: false }],
        [PinchRecognizer, { enable: false }, ['rotate']],
        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],
        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    options = options || {};

    this.options = merge(options, Hammer.defaults);
    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        extend(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        var recognizers = this.recognizers;
        recognizer = this.get(recognizer);
        recognizers.splice(inArray(recognizers, recognizer), 1);

        this.touchAction.update();
        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    each(manager.options.cssProps, function(value, name) {
        element.style[prefixed(element.style, name)] = add ? value : '';
    });
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

extend(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

if (typeof define == TYPE_FUNCTION && define.amd) {
    define('syracuse-tablet/html/deps/hammerjs-2.0.4/hammer',[],function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');
define('syracuse-tablet/html/js/helpers/scroller/scrollerBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/rect'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var _scrolId = 0;
var _Klass = utils.defineClass(function scroller($$elmt, options) {
	this.options = options = $.extend(true, {}, options);
	this.name = options.name || ("scroller-" + _scrolId++);
	this.$$elmt = $$elmt;
	this.isPageScroller = options.isPageScroller === true;
	this._initDir(options.direction);
	// Max top always 0 because we scroll in relative / parent - If needed pass it in parameter
	// options.valMax kept for compatibility with previous version
	this.scrollMax = options.valMax != null ? options.valMax : options.scrollMax != null ? options.scrollMax : 0;
	this.restoredScroll = null;
}, null, {
	destroy: function() {
		this.reset();
		this.$$elmt = null;
	},
	isNative: function() {
		return false;
	},
	_initDir: function(dir) {
		if (dir == null) {
			if (this.dir != null) return;
			this.dir = "v";
			return;
		}
		this.dir = dir;
	},
	init: function(viewRect, dir, scrollMax, preserveScroll) {
		if (viewRect == null) {
			throw new Error("Unexpected null viewRect");
		}
		var scroll = this.getScroll();
		if (preserveScroll === true && this.restoredScroll == null && scroll != null && scroll !== this.scrollMax) {
			// preserve the current scrolling - Just set restoredScroll
			// ! in charge to the parent class to refresh with restoredScroll 
			this.restoredScroll = scroll;
		}
		this.reset(true);
		this._initDir(dir);
		if (scrollMax != null) {
			this.scrollMax = scrollMax;
		}
		this.viewRect = viewRect;
		this._doInit(viewRect, dir, scrollMax, preserveScroll);
		var refreshed = false;
		if (preserveScroll === true && this.restoredScroll != null) {
			// If preserveScroll we have to adjust in case the newValMin < previousVal < newscrollMax
			refreshed = this.adjust(this.restoredScroll);
		}
		if (!refreshed) {
			this._refresh(this.restoredScroll, true);
		}
		this.restoredScroll = null;
		this.$$elmt.removeClass('scrollDisabled').addClass('scrollEnabled');
	},
	/**
	 * Child classes initialization
	 */
	_doInit: function(viewRect, dir, scrollMax, preserveScroll) {
		throw new Error("Not implemented");
	},
	isInitialized: function() {
		return this.$$elmt != null && this.viewRect != null;
	},
	/**
	 * Disable scroll but keep the capability to re-initialize it
	 */
	reset: function(dontResetValue) {
		if (dontResetValue !== true) {
			// Put initial value
			this._refresh(this.scrollMax);
		}
		this.viewRect = null;
		if (this.$$elmt) {
			this.$$elmt.removeClass('scrollEnabled').addClass('scrollDisabled');
		}
	},
	/**
	 * Applies the scrolling
	 */
	_refresh: function(scroll, force) {
		throw new Error("Not implemented");
	},
	/**
	 * Context management on back to restore the scrolling
	 */
	savedCtxCreate: function() {
		return {
			scroll: this.getScroll()
		};
	},
	savedCtxRestore: function(ctx, refresh) {
		if (ctx == null || ctx.scroll == null) return;
		if (refresh && this.isInitialized()) {
			this._refresh(ctx.scroll);
		} else {
			this.restoredScroll = ctx.scroll;
		}
	},
	getOffset: function() {
		return {
			top: this.dir == "v" ? this.getScroll() : 0,
			left: this.dir == "h" ? this.getScroll() : 0
		};
	},
	/**
	 * Make $$e visible
	 */
	makeVisible: function($$e) {
		throw new Error("Not implemented");
	},
	/**
	 * Auto-scroll to  value
	 */
	autoScroll: function(value) {
		throw new Error("Not implemented");
	},
	/**
	 * Returns the current scrolling
	 */
	getScroll: function(value) {
		throw new Error("Not implemented");
	},
	/**
	 * Returns the min scrolling (rather the max)
	 */
	_getScrollMin: function() {
		throw new Error("Not implemented");
	},
	/**
	 * Check if the current scroll element is contained by  viewRect
	 * If true -> reset scrolling Else re-init scrolling
	 */
	checkViewRect: function(viewRect, preserveScroll) {
		var reset = true;
		if (viewRect && this.$$elmt) {
			// For multi-selection in card mode we can hide cards. We need to scroll to beginning in order to calculate the right rect
			var val = this.getScroll();
			this._scrollToBeginning();
			var myRect = uiRect.elmtRect(this.$$elmt, "computed");
			var intersectRect = viewRect.intersectRect(myRect, false);
			if (intersectRect != null) {
				if (preserveScroll) {
					this.resoredVal = val;
				}
				this.init(intersectRect, null, null);
				reset = false;
				if (preserveScroll) {
					// If preserveScroll we have to adjust in case the newValMin < previousVal < newscrollMax
					this.adjust();
				}
			}
		}
		if (reset) {
			this.reset();
		}
	},
	/**
	 * Move to beginning
	 */
	_scrollToBeginning: function() {
		this._refresh(this.scrollMax);
	},
	/**
	 *  Adjust the scroller after modification of DOM to make this.$$elmt visible
	 *  By example after an action which have hidden lines we need to call this method to adjust scrolling because the visible area can be outside the viewRect
	 */
	adjust: function(restoredScroll) {
		throw new Error("Not implemented");
	}
});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/helpers/scroller/hammerScroller',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/deps/hammerjs-2.0.4/hammer','syracuse-tablet/html/js/helpers/scroller/scrollerBase'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("scroll", false);
var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var Hammer = require('syracuse-tablet/html/deps/hammerjs-2.0.4/hammer');
var Base = require('syracuse-tablet/html/js/helpers/scroller/scrollerBase').Klass;

/**
 * True if hammer event has the dir direction
 * dir	h or v
 * 		   -90			+180<-- -->0
 * 			^			       |
 * 			|                 +90
 * -180 <-- -->   0
 */
var _isEvtDirection = function(evt, dir, forceTrueIfNull) {
	// If hammer as no event it's - we can have the case with panup pandown without velocity
	// by default if work with if (ui.isEvtDirection(evt, "v")) return; - null evt means we continue
	if (evt == null) return forceTrueIfNull === true;
	if (evt.angle == null) throw new Error("this is not a hammer.js event");
	if ((evt.angle > 45 && evt.angle < 135) || (evt.angle < -45 && evt.angle > -135)) return dir == "v";
	return dir == "h";
};



var _stopClickEvent = function(mgr, evt, reason) {
	log && log("Clicked canceled", reason, mgr.id);
	evt.stopPropagation();
	evt.preventDefault();
	evt.$stop = true;
};
// Time to wait before allowing click events a scrolling
var _lastClickTO = 400;
// Enable the slowdown process - scroll continue after panend (mouse up ) like on native devices
var _slowDown = true;
// Move the $$elmt after _slowDownTO in slowdown process
var _slowDownTO = 10;
/**
 * returns the distance to _move according to velocity v
 */
var _velocityToDist = function(velocity) {
	// Velocity of the _move - 0 if we _move the finger slowly and ~ 2 for fast - TO IMPROVE REGARDING THE CONTEXT - TOUCH/DESKTOP 
	var v = Math.abs(Math.round(velocity * 4));
	// Distance to _move - square function of velocity (non linear) 
	// Allow to _move slow and fast if we increase the speed of the finger
	return Math.max(1, v * v / 2);
};
/**
 * Creates a vertical/horizontal scroller which emulates the tablet native behavior
 * 		$$elmt		element to scroll
 * 		options		scrollMax			maximum top - 0 by default - 50 for pages with header...
 * 					direction		h/v
 * 					isPageScroller	true/false
 * 		parentMgr	parent scroll manager (the page's one for an array scroller)
 * 					used to deal with click event
 * 		$$nativeScroll 	div that will take the native scroll when we disable the scrolling (for test and authoring)
 * 						optional - $elmt if null
 */
var _consts = {
	pan: {
		v: "panup pandown panstart panend",
		h: "panleft panright panstart panend"
	},
	dir: {
		v: Hammer.DIRECTION_VERTICAL,
		h: Hammer.DIRECTION_HORIZONTAL
	},
	upEvt: {
		v: "panup",
		h: "panleft"
	}
};
var _Klass = utils.defineClass(function HammerScroller($$elmt, options, parentMgr) {
	options = options || {};
	Base.call(this, $$elmt, options);
	this.id = $$elmt.closest("[id]").attr("id");
	this.parentMgr = parentMgr;
	// Init hammer manager
	this.hammer = new Hammer(this.$$elmt.get(0));
	// evts enabled - false by default
	this._evtsEnabled = false;
}, Base, {
	/**
	 * We need to initialize the scroll after creation
	 * Scrollable object arrays/pages have an empty scroll which is initialized if needed
	 * Initialization needs to be called when the object has been displayed (after show) to make sure that viewRect is ok
	 * To manage savedCtxRestore it's also the better way
	 * 		- save ctx (top)is stored and took into account at initialization
	 * Params
	 * 		viewRect		rectangle (uiUtils/rect class) of the view within we will _move the content of $$elmt (kind of window)
	 * 						!!!top/left must be in fixed coordinates (relative to document)
	 * 						in order to be able to check if mouse pointer belongs to this rect on mousemove/pandown
	 * 		dir				To change dir if needed (orientation changed)
	 * 		scrollMax			To change scrollMax if needed (orientation changed)
	 * 		preserveScroll	true to init scrollRect and preserve the scrolling
	 * 						used to for child pages
	 */
	init: function(viewRect, dir, scrollMax, preserveScroll) {
		if (viewRect && globals.getSiteLayout().getTransformScale() != 1) {
			// Developement mode - scaling 
			viewRect = viewRect.applyTransformScale(globals.getSiteLayout().getTransformScale(), true);
		}
		Base.prototype.init.call(this, viewRect, dir, scrollMax, preserveScroll);
	},
	_initDir: function(dir) {
		Base.prototype._initDir.call(this, dir);
		// event than means up or right
		this.upEvtType = _consts.upEvt[this.dir];
	},
	_doInit: function(viewRect, dir, scrollMax, preserveScroll) {
		// We need pan and not swipe
		this.hammer.get("pan").set({
			threshold: 0, // Small threshold to bloc the click (mouseup) as son as pan start- To test on mobile devices
			direction: _consts.dir[this.dir]
		});
		// We need press to stop the scolling
		this.hammer.get("press").set({
			time: 1 //Small timeout needed to stop immediately when press
		});
		// Create handlers
		this._panHandler = Hammer.bindFn(this._onPan, this);
		this._pressHandler = Hammer.bindFn(this._onPress, this);
		this._clickHandler = Hammer.bindFn(this._onClick, this);
		// - altClick enable/disable the scrolling
		this.$$elmt.on('click', this._clickHandler);
		// Bind events
		// Original rectangle - used to enable/disable scrolling
		// !!! Images and components loaded by URL need to have a fix height !!! otherwise we can't calculate the height
		this._originalRect = uiRect.elmtRect(this.$$elmt);
		// Store the original offset because it's the reference (only for embedded object like page into vignette and arrays)
		// globals.getCurrentPage() can be nul since we use scroller in modal (globals.getCurrentPage() is null if an error occure on page loading)
		this._originalScrollOffset = this.isPageScroller || !globals.getCurrentPage() ? null : globals.getCurrentPage().getScrollOffset();
		this._enableEvents(true);
	},
	/**
	 * Enable / Disable events
	 * Used by reset and Alt Click
	 * toggleStatus: true means that we toggle 'native scroll' <-> 'hammer scroll'
	 */
	_enableEvents: function(yes) {
		if (!this.hammer) return;
		var wasDisabled = this._evtsEnabled === false;
		// ENABLED
		if (yes === true && this._evtsEnabled !== true) {
			this._evtsEnabled = true;
			this.hammer.on(_consts.pan[this.dir], this._panHandler);
			this.hammer.on("press", this._pressHandler);
			// Just to find elmt with debugger
			this.$$elmt.addClass("s-m-scroll" + this.dir);
		}
		// DISABLED
		if (yes === false && this._evtsEnabled !== false) {
			this._evtsEnabled = false;
			if (this.hammer) {
				this.hammer.off(_consts.pan[this.dir], this._panHandler);
				this.hammer.off("press", this._pressHandler);
			}
			this.$$elmt.removeClass("s-m-scroll" + this.dir);
		}
		// IN ANY CASES
		if (wasDisabled) {
			// Nothing
		} else {
			this.panStart = false;
			this._stopSlowingDown();
			this.cancelClick = false;
			this.lastClickAllowed = null;
		}
	},
	/**
	 * Disable scroll but keep the capability to re-initialize it
	 */
	reset: function(dontResetValue) {
		Base.prototype.reset.call(this, dontResetValue);
		// !! FIRST - Disable events
		this._enableEvents(false);
		// Disable click - No mo more scrolling compared to disable/enable
		if (this.$$elmt) {
			this.$$elmt.off('click', this._clickHandler);
		}
		// True if panstart - mouse start to _move
		this.panStart = false;
		// True if the scroll is slowing down after panend (mouse up)
		this._stopSlowingDown();
		// Cancel click on a link
		this.cancelClick = false;
		//Prevent click after _lastClickTO ms after a panend
		this.lastClickAllowed = null;
		// Null to force to set value on init ( context restored)
		this.val = null;
		this.isLocked = false;
		// !! DO NOT RESET - dir, scrollMax, parentMgr, restoredScroll
	},
	/**
	 * Destroy scroller
	 */
	destroy: function() {
		Base.prototype.destroy.call(this);
		// After
		if (this.hammer) {
			this.hammer.destroy();
			this.hammer = null;
		}
		this._panHandler = null;
		this._pressHandler = null;
		this._toggleRect(false);
		this._clickHandler = null;
		notifications.unsubscribe(this);
	},
	/**
	 * Refresh scrolling
	 * 	internal call or called to refresh scrolling when we activate cached pages
	 *  scroll: optional
	 */
	_refresh: function(scroll, force) {
		if (!this.$$elmt) return;
		this._setScroll(scroll);
		if (this.dir == "v") {
			this.$$elmt.css({
				top: this.getScroll() + "px"
			});
		} else {
			this.$$elmt.css({
				left: this.getScroll() + "px"
			});
		}
	},
	_getScrollOffset: function() {
		if (this.isPageScroller || this._originalScrollOffset == null) return null;
		var o = globals.getCurrentPage().getScrollOffset();
		if (o == null) return null;
		return {
			top: o.top - this._originalScrollOffset.top,
			left: o.left - this._originalScrollOffset.left
		};
	},
	_toggleRect: function(remove) {
		// Debug show the rectangle - fixed position 
		if (this._$$viewRect) {
			this._$$viewRect.remove();
			this._$$viewRect.off('click', this._clickHandler);
			this._$$viewRect = null;
		} else if (remove !== false) {
			this._$$viewRect = this.viewRect.showInDocument();
			var o = this._getScrollOffset();
			if (o) {
				this._$$viewRect.css({
					marginTop: "+=" + o.top,
					marginLeft: "+=" + o.left
				});
			}
			this._$$viewRect.on('click', this._clickHandler);
		}
	},
	/**
	 * Intercept click/mouseup events for filtering
	 * We need to filter click events to control the triggering of links
	 * altClick 	-> Enables/Disables scrolling
	 * shiftClick	-> Displays/Hides the viewRect
	 */
	_onClick: function(evt) {
		log && log("onClick Status", "slowingDown:", this.slowingDown, "panStart:", this.panStart, "cancelClick:", this.cancelClick, "lastClickAllowed:", this.lastClickAllowed ? new Date().getTime() - this.lastClickAllowed : null);
		evt.$stop = false;
		if (evt.shiftKey) {
			this._toggleRect();
			return _stopClickEvent(this, evt, "Show rectangle");
		}
		// If disable we skip
		if (this._evtsEnabled === false) return;
		if (this.slowingDown) {
			return _stopClickEvent(this, evt, "slowing down");
		}
		if (this.cancelClick) {
			this.cancelClick = false;
			return _stopClickEvent(this, evt, "Click canceled");
		}
		if (this.lastClickAllowed != null && ((new Date().getTime() - this.lastClickAllowed) < 0)) {
			// Click is authorized if not slowingDown or if not cancelClick
			// We wait _lastClickTO after panend (mouseup) to allow click
			this.lastClickAllowed = null;
			return _stopClickEvent(this, evt, "Last click timeout");
		}
		if (this.parentMgr && this.parentMgr.dir != this.dir) {
			// For double scroll direction one by parent and one by a grid we need to sak the parent to cancel the click 
			this.parentMgr._onClick(evt);
			if (evt.$stop === true) {
				return _stopClickEvent(this, evt, "Parent stopped click");
			}
		}
		log && log("onClick not stopped");
	},
	/**
	 * Used to stop the slowdown process
	 */
	_onPress: function(evt) {
		this.lastPress = new Date().getTime();
		if (this.slowingDown) {
			this._stopSlowingDown();
			// Last click is avoided - The click evt that is always triggered after press a event
			this.cancelClick = true;
		}
		if (this.parentMgr) this.parentMgr.isLocked = false;
		log && log(this.id, "onPress", "slowingDown=" + this.slowingDown, "panStart=" + this.panStart, "cancelClick =" + this.cancelClick, "lastClickAllowed =" + this.lastClickAllowed);
	},
	/**
	 * pan event - mousedown/mousemove/mouseup
	 */
	_onPan: function(evt) {
		log && log(this.id, evt.type, this.dir, _isEvtDirection(evt, this.dir), "isLocked", this.isLocked);
		if (!_isEvtDirection(evt, this.dir)) return;
		if (this.isLocked === true) return;
		try {
			if (evt.type === "panstart") {
				// Mouse mousedown + mousemove event - start the process
				log && log(evt.type);
				this.panStart = true;
				this.cancelClick = true;
				this._stopSlowingDown();
				if (this.parentMgr && (this.parentMgr.dir === this.dir)) this.parentMgr.isLocked = true;
			} else if (evt.type === "panend") {
				// mouseup  - we continue to scroll (_slowDown) until the user do a press event to stop scrolling
				log && log(evt.type);
				this.panStart = false;
				if (_slowDown && this.lastVelocity != null) {
					// We keep the last velocity for slowdown process
					this.lastVelocity = Math.abs(this.lastVelocity);
					if (this.lastVelocity > 0.3 && this.lastVelocity < 1) {
						// If velocity is too small we keep 1
						this.lastVelocity = 1;
					} else {
						// under.3 we consider that we need to stop scrolling
						this.lastVelocity = Math.min(this.lastVelocity, 2);
					}
					if (this.lastVelocity >= 1) {
						// _slowDown option continue the process by decreasing the speed slowly and moving $$elmt
						this.slowingDown = true;
						this._slowDown(this.lastVelocity, this.lastUp);
						this.lastVelocity = this.lastUp = null;
					} else {
						if (this.parentMgr) this.parentMgr.isLocked = false;
					}
				} else {
					// avoid click on mouse up
					this.lastClickAllowed = new Date().getTime() + _lastClickTO;
					if (this.parentMgr) this.parentMgr.isLocked = false;
				}
				return;
			}
			// Direction of the scroll
			// Up means up or right 
			var up = evt.type === this.upEvtType || evt.type === "panstart" && evt.deltaY < 0;
			if (this._move(_velocityToDist(evt.velocity), up)) {
				this.lastVelocity = Math.abs(evt.velocity);
				this.lastUp = up;
			} else {
				this.lastVelocity = this.lastUp = null;
			}
		} catch (e) {
			console.log(JSON.stringify(jsutils.convertToDiagnoses(e), null, 2));
			return false;
		}
	},
	_stopSlowingDown: function() {
		this.slowingDown = false;
		if (this.parentMgr) this.parentMgr.isLocked = false;
	},
	/**
	 * Keep the last speed to continue scrolling process until the user do a press evt
	 */
	_slowDown: function(v, up) {
		var self = this;
		if (self.panStart || !self.slowingDown) {
			this._stopSlowingDown();
			return;
		}
		// keep the same velocity - to improve - we can decrease...
		if (v < 1) {
			this._stopSlowingDown();
			return;
		}
		if (self._move(_velocityToDist(v), up)) {
			// Move until stop with _slowDownTO timeout
			setTimeout(function() {
				self._slowDown(v, up);
			}, _slowDownTO);
		} else {
			this._stopSlowingDown();
		}
	},
	/**
	 * Move $$elmt vertically
	 */
	_move: function(dist, up) {
		if (!this.isInitialized() || dist == 0) {
			return;
		}
		try {
			var scroll = this.getScroll();
			// Check boundaries
			var val = up ? scroll - dist : scroll + dist;
			var valMin = this._getScrollMin();
			val = Math.max(Math.min(this.scrollMax, val), valMin);
			if (val === this.scrollMax || val === valMin) {
				log && log(this.id, "end scrolling");
				// avoid click during xx ms on mouse up at the end of scrolling
				this.lastClickAllowed = new Date().getTime() + _lastClickTO;
				this.cancelClick = false;
				if (scroll === val) {
					// Overflow -> Stop
					// log && log("_move overflow")
					return false;
				}
			}
			// Move elmt
			this._refresh(val);
			return true;
		} catch (e) {
			console.log(JSON.stringify(jsutils.convertToDiagnoses(e), null, 2));
			return false;
		}
	},
	/**
	 * Show element in page - scroll if needed
	 * c is a JQuery elmt or an object with $$elmt property
	 */
	makeVisible: function($$e) {
		if (!$$e || !this.isInitialized() || $$e.is(":visible")) return;
		if (this.slowingDown) {
			this._stopSlowingDown();
			// Last click is avoided - The click evt that is always triggered after press a event
			this.cancelClick = true;
		}
		if (!$$e || !$$e.jquery || $$e.length == 0) return;
		if (!$$e.is(":visible")) {
			$$e.parents(".s-m-stack").map(function(stack) {
				var stackLayout = globals.getCurrentPage().getLayout($(this).attr("id"));
				stackLayout && stackLayout.setAuthState({
					"collapsed": false
				});
			});
		}
		if ($$e.closest(this.$$elmt).length === 0) return;
		if (!this._evtsEnabled) return;
		var prop = this.dir === "v" ? "top" : "left";
		var size = this.dir === "v" ? "height" : "width";
		var o = $$e.offset();
		var offset = globals.getSiteLayout().getTransformScale() * $$e[size]() / 2;
		o[prop] = o[prop] + offset;
		if (o[prop] > this.viewRect[prop] && o[prop] < (this.viewRect[prop] + this.viewRect[size] - 10)) {
			return;
		}
		this.$$elmt.css("visibility", "hidden");
		var f = o[prop] > this.viewRect[prop] ? -1 : +1;
		//$$e.css("background-color", "red");
		// FDB - Best way I found to right position $$e - Perhaps we can do that in one shot
		// Comparing this.$elmt.offset et $e.offset doesn't work
		var stopPos = this.viewRect[prop] + this.viewRect[size] / 2;
		var stop = !$$e.is(":visible");
		while (!stop) {
			var pos = $$e.offset()[prop] + offset;
			stop = f > 0 ? pos > stopPos : pos < stopPos;
			if (!stop) {
				this._refresh(this.getScroll() + 50 * f);
			}
		}
		var valMin = this._getScrollMin();
		if (this.getScroll() < valMin) {
			this._refresh(valMin);
		}
		if (this.getScroll() > this.scrollMax) {
			this._refresh(this.scrollMax);
		}
		this.$$elmt.css("visibility", "visible");
	},
	autoScroll: function(value) {
		this._move(Math.abs(value), value < 0);
	},
	/**
	 * Calculated dynamically because the content of the page can be modified after initisalization of scroller
	 */
	_getScrollMin: function() {
		var prop = this.dir == "v" ? "height" : "width";
		var x = this.$$elmt[prop]();
		if (false && globals.getSiteLayout().getTransformScale() != 1) {
			// disabled because doesn't work fine - Like we scaled viewRect we should scale x 
			x = x * globals.getSiteLayout().getTransformScale();
		}
		// 30 pixel more
		return Math.min(this.scrollMax - x + this.viewRect[prop] - 30, this.scrollMax);
	},
	_setScroll: function(v) {
		if (v == null || isNaN(v)) {
			v = this.scrollMax;
		}
		this.val = v;
	},
	getScroll: function() {
		return this.val;
	},
	/**
	 *  Adjust the scroller after modification of DOM to make this.$$elmt visible
	 *  By example after an action which have hidden lines we need to call this method to adjust scrolling because the visible area can be outside the viewRect
	 */
	adjust: function(restoredScroll) {
		if (!this.isInitialized()) return false;
		var elmtRect = uiRect.elmtRect(this.$$elmt);
		if (this.viewRect.contains(elmtRect)) {
			// No scroll we set scrollMax
			this._refresh(this.scrollMax);
		} else {
			restoredScroll = restoredScroll == null ? this.getScroll() : restoredScroll;
			if (restoredScroll > this.scrollMax) {
				// outside the scop we set scrollMax
				restoredScroll = this.scrollMax;
			}
			var prop = this.dir == "v" ? "height" : "width";
			var valmin = this.scrollMax - elmtRect[prop] + this.viewRect[prop];
			if (restoredScroll < valmin) {
				// outside the scop we set scrollMin
				restoredScroll = this._getScrollMin();
			}
			this._refresh(restoredScroll);
		}
		return true;
	}
});

exports.Klass = _Klass;
exports.Hammer = Hammer;
exports.isEvtDirection = _isEvtDirection;
});

define('syracuse-tablet/html/js/helpers/scroller/nativeScroller',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/scroller/scrollerBase','syracuse-tablet/html/js/ui/rect'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/helpers/scroller/scrollerBase').Klass;
var uiRect = require('syracuse-tablet/html/js/ui/rect');

var _consts = {
	dirToAxis: {
		v: "y",
		h: "x"
	},
	dirToOtherAxis: {
		v: "x",
		h: "y"
	}
};

var _Klass = utils.defineClass(function NativeScroller($$elmt, options) {
	Base.call(this, $$elmt, options);
}, Base, {
	isNative: function() {
		return true;
	},
	_doInit: function(viewRect, dir, scrollMax, preserveScroll) {
		var css = {};
		css["overflow-" + _consts.dirToAxis[this.dir]] = "auto"; // scrolling axis
		css["overflow-" + _consts.dirToOtherAxis[this.dir]] = "hidden"; // "unused" or fixed axis
		this.$$elmt.addClass("isScrollElmt").parent().css(css).addClass("isScrollWrapper");
		// remove default touch action on all elements
		// would be better if doing this by loading a css file with the appropriate * {} selector instead of setting it on each element
		var css = {};
		if (this.scrollMax === 0 && this.options.nopadding !== true) {
			var prop = this.dir === "h" ? "right" : "bottom";
			// blank line of 10 pixels at the end of scrolling
			css["padding-" + prop] = "10px";
		}
		var prop = this.dir === "h" ? "width" : "height";
		var valProp = this.viewRect[prop];
		if (false) {
			css["border"] = "red solid 1px";
			// To actually see the rectangle
			valProp -= 2;
		}
		this.$$elmt.parent()[prop](valProp).css(css);
	},
	reset: function(dontResetValue) {
		var wasInitialized = this.isInitialized();
		Base.prototype.reset.call(this, dontResetValue);
		if (!this.$$elmt || !wasInitialized) return;
		var prop = this.dir === "h" ? "width" : "height";
		// We restore 100% rather than auto (auto doesn't work i panels when we switch orientation) - 100% is better for the wrapper
		this.$$elmt.parent().css(prop, "100%");
	},
	getScroll: function() {
		return this.$$elmt ? this.$$elmt.parent()[this.dir === "h" ? "scrollLeft" : "scrollTop"]() : this.scrollMax;
	},
	_refresh: function(scroll, force) {
		if (!this.$$elmt) return;
		if (scroll == null && force !== true) return;
		scroll = Math.max(scroll == null ? this.scrollMax : scroll, this.scrollMax);
		var cur = this.getScroll();
		if (cur === scroll && force !== true) return;
		this.$$elmt.parent()[this.dir === "h" ? "scrollLeft" : "scrollTop"](scroll);
	},
	makeVisible: function($$e) {
		if (!$$e || $$e.length === 0 || $$e.is(":visible") || !$$e.get(0).scrollIntoView) {
			return;
		}
		$$e.get(0).scrollIntoView(false);
	},
	autoScroll: function(value) {
		if (!this.isInitialized()) {
			// Set at initialization
			this.restoredScroll = value;
		} else {
			this._refresh(value, true);
		}
	},
	_getScrollMin: function() {
		return this.$$elmt ? this.$$elmt.height() : 0;
	},
	/**
	 *  Adjust the scroller after modification of DOM to make this.$$elmt visible
	 *  By example after an action which have hidden lines we need to call this method to adjust scrolling because the visible area can be outside the viewRect
	 */
	adjust: function(restoredScroll) {
		if (!this.isInitialized()) return false;
		if (this.viewRect.contains(uiRect.elmtRect(this.$$elmt))) {
			// No scroll we set scrollMax
			this._refresh(this.scrollMax);
		} else {
			this._refresh(restoredScroll == null ? this.getScroll() : restoredScroll);
		}
		return true;
	}
});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers',['require','exports','module','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/scroller/hammerScroller','syracuse-tablet/html/js/helpers/scroller/nativeScroller','syracuse-tablet/html/js/helpers/scroller/hammerScroller','syracuse-tablet/html/js/helpers/scroller/nativeScroller'],function (require, exports, module) {"use strict";

var uiRect = require('syracuse-tablet/html/js/ui/rect');
var globals = require('syracuse-tablet/html/js/helpers/globals');

var _scrollerId = 1;
var _ctor = {
	desktop: require('syracuse-tablet/html/js/helpers/scroller/hammerScroller'),
	native: require('syracuse-tablet/html/js/helpers/scroller/nativeScroller')
};

var _createSimpleScroller = function($$elmt) {
	var $$scrolls = $$elmt.find(".s-m-scroll-element");
	var i;
	var scrollers = {};

	for (i = 0; i < $$scrolls.length; i++) {
		_scrollerId++;

		var $$se = $($$scrolls[i]);
		var $$wrapper = $$se.parent();
		var dir = $$wrapper.hasClass("s-m-scroll-wrapper-h") ? "h" : "v";

		$$wrapper.attr("data-scroller-id", _scrollerId);

		var parentScroller = null;
		var $$parentScroller = $$wrapper.parent().closest(".s-m-scroll-wrapper");
		if ($$parentScroller.length > 0) {
			parentScroller = scrollers[$$parentScroller.attr("data-scroller-id")];
		}

		var css = {};
		css["overflow-" + dir] = "auto";
		$$wrapper.css(css);

		var gestureMgr = _newScroller($$se, {
			direction: dir,
			valMax: 0,
			name: "_scroller_" + _scrollerId,
			isPageScroller: false
		}, parentScroller);
		scrollers[_scrollerId] = gestureMgr;
		// reset old scrolling to calculate width/height (mandatory in native mode)
		gestureMgr.reset();
		var scrollRect = uiRect.elmtRect($$se, "outer");
		var wrapperRect = uiRect.elmtRect($$wrapper, "outer");
		var viewRect = wrapperRect.intersectRect(scrollRect);
		if (viewRect && !viewRect.contains(scrollRect)) {
			gestureMgr.init(viewRect);
		}
	}

	return scrollers;
};

var _newScroller = function($$elmt, options, parentMgr) {
	var name;
	if (globals.isNativeScrolling()) {
		name = "native";
	} else {
		name = "desktop";
	}
	var Klass = _ctor[name];
	if (!Klass) throw new Error("Scroller not initialized");
	$$elmt.addClass(name + "Scroll");
	return new Klass($$elmt, options, parentMgr);
};
exports.newScroller = _newScroller;
exports.createSimpleScroller = _createSimpleScroller;
exports.init = function() {
	_ctor.desktop = require('syracuse-tablet/html/js/helpers/scroller/hammerScroller').Klass;
	_ctor.native = require('syracuse-tablet/html/js/helpers/scroller/nativeScroller').Klass;
};
});

define('syracuse-tablet/html/js/ui/modals/modalDialog',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/scroller/scrollerHelpers','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var _dialogTpl = '\
	<div class="modal {{displayFlags.modalClass}}" tabindex="-1" role="dialog">\
	<div class="modal-dialog">\
	<div class="modal-content"> \
		{{{header}}} \
		<div class="modal-body">{{{content}}}</div> \
		{{{footer}}} \
	</div> \
	</div>\
	</div>';

var _openModalsPromises = [];

/**
 *
 */
var _Klass = utils.defineClass(

	function BaseModal() {
		var self = this;
		var site = globals.getSiteLayout();
		self.deviceType = site.getDeviceType(); // tablet or smartphone
		self.displayFlags = {
			modalClass: ""
		};
	}, null, {
		destroy: function() {
			if (this.$$elmt) {
				this.$$elmt.unbind();
				this.$$elmt.remove();
			}
			this._checkShowNextModal();
			notifications.unsubscribe(this);
		},

		_checkShowNextModal: function() {
			_openModalsPromises.shift();
			if (_openModalsPromises.length > 0) {
				_openModalsPromises[0].resolve();
			}
		},
		/*
		 * =======================================
		 * Functions that must be overiden
		 * =======================================
		 */

		/*
		 * Needs to be overiden by dialog implementations
		 * Returns html template per device (or only std if no special ones)
		 */
		_getTemplates: function() {
			return {
				std: {},
				tablet: {},
				smartphone: {}
			};
		},

		/*
		 * Needs to be overiden by dialog implementations
		 * Returns data to merge into template
		 */
		_getDataContext: function() {
			return {};
		},


		/*
		 * Can be overidden to handle clicks on data-action=$validate.
		 * Should set value returned by _getResult()
		 * Return false to NOT close dialog
		 */
		_onValidate: function() {

		},

		/*
		 * Can be overidden to handle clicks on data-action=$cancel.
		 * Should set value returned by _getResult()
		 * Return false to NOT close dialog
		 */
		_onCancel: function() {

		},

		/*
		 * Can be overidden to set result of dialog when it is closed
		 *
		 */
		_getResult: function() {

		},

		/*
		 * =======================================
		 * Functions that may be overiden
		 * =======================================
		 */

		/*
		 * Can be overidden to handle clicks on data-action dom elements.
		 * param=data-param
		 * Return false to NOT close dialog
		 */
		_onAction: function(action, param) {

		},

		_compileTpl: function() {
			var self = this;
			var htmlTpls = self._getTemplates();
			var htmlTpl = htmlTpls[self.deviceType] || htmlTpls["std"];

			var tpl = {
				header: Handlebars.compile(htmlTpl.header),
				content: Handlebars.compile(htmlTpl.content),
				footer: Handlebars.compile(htmlTpl.footer),
			};
			return tpl;
		},

		_getWrapperTemplate: function() {
			return Handlebars.compile(_dialogTpl);
		},

		_ensureParent: function() {
			var self = this;
			var parentName = globals.isAuthoringActive() ? "s-m-modal-parent-auth" : "s-m-modal-parent";
			var $$parent = $("#" + parentName);
			if ($$parent.length < 1) {
				$$parent = $("<div>");
				$$parent.attr("id", parentName);
				if (globals.isAuthoringActive()) {
					$("body").append($$parent);
				} else {
					// If application not initialized we must display the message (error in init process)
					$("#s-m-app-container-id").css({
						width: "100%",
						height: "100%"
					});
					$("#s-m-app-id").show().addClass("s-m-modal-parent").append($$parent);
				}
			}
			self.$$parent = $$parent;
		},

		_createDOM: function() {
			var self = this;
			self.$$elmt = $(self.html);
		},

		getDisplayFlags: function() {
			var self = this;
			return self.displayFlags;
		},

		_hookEvents: function() {
			var self = this;
			self.$$elmt.on("shown.bs.modal", self._onShow.bind(self));
			self.$$elmt.on("hide.bs.modal", self._onHide.bind(self));

			self.$$elmt.delegate("[data-action]", "click", self._onButton.bind(self));
		},

		_attachDOM: function() {
			var self = this;
			self.$$parent.toggle(true);
			self.$$parent.append(self.$$elmt);
			self.$$elmt.modal({
				keyboard: false,
				backdrop: "static"
			});
		},

		_onShow: function(evt) {
			var self = this;
			self.$$elmt.css("padding-left", "");
			self._calcSize();
			var app = globals.getApplication();
			if (app) {
				app.notifModalOpen();
				self._initScrollers();
				notifications.subscribe(self, "sm.main.layout.changed");
			}
		},

		notifMainLayoutChanged: function(info, orientation, deviceType) {
			// Used by some dialogs
		},

		_onHide: function(evt) {
			var self = this;
			self.$$parent.toggle(false);
			var app = globals.getApplication();
			if (app) {
				app.notifModalClose();
			}
			self.deferred.resolve(self._getResult());
			self.destroy();
		},

		_onButton: function(evt) {
			var self = this;
			var $$t = $(evt.currentTarget);

			var param = $$t.attr("data-params");
			var act = $$t.attr("data-action");
			if (act) {
				evt.preventDefault();
				evt.stopPropagation();

				var res;
				if (act === "$validate") {
					res = self._onValidate();
				} else if (act === "$cancel") {
					res = self._onCancel();
				} else {
					res = self._onAction(act, param);
				}
				//_onCancel/_onCancel/_onAction can return either a promise or a data
				// So we can call asynchronous processes in theses methods
				utils.toPromise(res).then(function(res) {
					if (res !== false) {
						self.$$elmt.modal('hide');
					}
				});
			} else {
				// Close modal
				self.$$elmt.modal('hide');
			}
		},

		/**
		 * This is the only function to be called from a dialog user
		 * It shows the dialog and resolves the returned promise as soon as the dialog is closed
		 * forceDisplay: error forces the display of the modal
		 */
		show: function(forceDisplay) {
			var self = this;
			var startShow = new $.Deferred();
			if (forceDisplay === true) {
				_openModalsPromises = [];
			}
			_openModalsPromises.push(startShow);
			// First modal to open, so execute immediately
			if (_openModalsPromises.length === 1 || forceDisplay === true) {
				startShow.resolve();
			}

			self.deferred = new $.Deferred();
			startShow.then(function() {
				return self._getDataContext();
			}).then(function(data) {
				self.data = data;
			})
				.then(function() {
					self.template = self._compileTpl();
					var outerTpl = self._getWrapperTemplate();

					var header = self.template.header(self.data);
					var footer = self.template.footer(self.data);

					if (header.length > 0) {
						header = '<div class="modal-header">' + header + '</div>';
					}
					if (footer.length > 0) {
						footer = '<div class="modal-footer">' + footer + '</div>';
					}

					self.html = outerTpl({
						header: header,
						content: self.template.content(self.data),
						footer: footer,
						displayFlags: self.getDisplayFlags()
					});
					self._ensureParent();
					self._createDOM();
					self._hookEvents();
					self._attachDOM();
				}).fail(function(e) {
					// Cancel pending dialogs
					_openModalsPromises = [];
					self.deferred.reject(e);
				});

			return self.deferred.promise();
		},

		/*
		 *
		 */
		_initScrollers: function() {
			scroller.createSimpleScroller(this.$$elmt);
		},

		_calcSize: function() {
			var self = this;

			var df = self.getDisplayFlags();
			if (df.modalClass.indexOf("half_center") > -1 ||
				df.modalClass.indexOf("half_right") > -1 ||
				df.modalClass.indexOf("full") > -1) {
				var $$content = self.$$elmt.find(".modal-content");
				var $$header = self.$$elmt.find(".modal-header");
				var $$body = self.$$elmt.find(".modal-body");
				var $$footer = self.$$elmt.find(".modal-footer");

				var header = $$header.length > 0 ? uiRect.elmtRect($$header, "outer").height : 0;
				var footer = $$footer.length > 0 ? uiRect.elmtRect($$footer, "outer").height : 0;

				$$body.css({
					"top": header,
					"height": $$content.height() - header - footer
				});
			}
		}
	}
);

var _checkMsg = function(msg) {
	return msg ? msg.replace(/\n/g, "<br>") : "";
};

exports.checkMsg = _checkMsg;
exports.ModalBase = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalDiagnoses',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/helpers/scroller/scrollerHelpers','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/scroller/hammerScroller'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var hammerScroller = require('syracuse-tablet/html/js/helpers/scroller/hammerScroller');

var _templateAll = {
	header: '\
		<div class="modal-title {{severity}}">{{title}}</div>',
	content: '\
		<div class="s-m-modal-diag-content">\
			{{#each diags}} \
				<message id="s-m-msg-block-{{id}}" role="alert" style="display:{{this.display}}"> \
					<div style="white-space: pre-line;">{{this.message}}</div> \
					{{#if stack}} \
						<a id="s-m-msg-stack-{{id}}" draggable="false" name="more" href="#" data-action="more">{{../../stackShow}}</a> \
						<section>\
							<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
								<stack name="s-m-scroll-element stack" class="s-m-msg-stack-content"> \
									{{{this.stack}}} \
								</stack> \
							</div> \
						</section>\
					{{/if}} \
				</message> \
			{{/each}}\
		</div>\
		<div class="s-m-modal-diag-goto">\
			{{#each diags}}\
				<a id="s-m-msg-goto-{{id}}" data-action="goto" data-params="{{id}}">\
					<i class="fa fa-circle-o" data-action="goto" data-params="{{id}}"></i>\
				</a>\
			{{/each}}\
		</div>',
	footer: '<div style="width:100%; display: inline-block;"></div><button type="button" class="btn btn-default" data-action="$cancel">{{close}}</button>'
};


var _Klass = utils.defineClass(
	function ModalDiagnoses(title, diag) {
		var self = this;
		modalDialog.ModalBase.call(self);
		// Init params
		self.title = title;
		self.diag = diag;
		self.diagId = 0;
		self.curMsg = 0;
	}, modalDialog.ModalBase, {
		destroy: function() {
			var self = this;
			// destroy hammer component
			this._destroySwiper();
			// destroy gestureMgr (used for vertical swipe within the stack)
			if (this._gestureMgrMap && !$.isEmptyObject(this._gestureMgrMap)) {
				$.each(this._gestureMgrMap, function(key, gestureMgr) {
					gestureMgr.destroy();
				});
				this._gestureMgrMap = null;
			}
			modalDialog.ModalBase.prototype.destroy.call(self);
		},
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},
		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "diagnoses tablet";
			} else {
				displayFlags.modalClass = "diagnoses mobile";
			}
			return displayFlags;
		},
		_getDataContext: function() {
			var self = this;
			var ctx = {
				close: locale.text("modal.btn.close") || "Close",
				stackShow: locale.text("modal.diagnoses.btnstack_show"),
				severity: "info",
				diags: []
			};
			self.diag.$diagnoses.forEach(function(d) {
				var sev;
				if (d.$severity === "success" || d.$severity === "info" || d.$severity === "warning") {
					sev = d.$severity;
				} else {
					sev = "danger";
					ctx.severity = "error";
				}
				ctx.diags.push({
					id: self.diagId,
					display: self.diagId === 0 ? "block" : "none",
					message: d.$message,
					severity: sev,
					severityLabel: locale.text("severity." + sev),

					stack: globals.isDvlpMode() ? (d.$stackTrace && d.$stackTrace.replace(/\n/g, "<BR/>")) : null
				});

				self.diagId++;
			});

			self.title = self.title || (ctx.severity === "error" ? locale.text("modal.error.ttl") : locale.text("modal.info.ttl"));
			ctx.title = self.title;

			return ctx;
		},
		_onAction: function(action, param) {
			var self = this;
			switch (action) {
				case "next":
					self._next();
					break;
				case "prev":
					self._prev();
					break;
				case "more":
					self._more();
					break;
				case "goto":
					self._goTo(param);
					break;
			}

			// dont close on actions
			return false;
		},
		_goTo: function(id) {
			var self = this;
			for (var ii = 0, jj = self.diagId; ii < jj; ii++) {
				$("#s-m-msg-block-" + ii, self.$$elmt).css("display", ii == id ? "block" : "none");
			}
			self.curMsg = parseInt(id, 10);
			self._updateButtons();
		},
		_next: function() {
			var self = this;
			if (self.curMsg < (self.diagId - 1)) {
				$("#s-m-msg-block-" + self.curMsg, self.$$elmt).css("display", "none");
				self.curMsg++;
				$("#s-m-msg-block-" + self.curMsg, self.$$elmt).css("display", "block");
				self._updateButtons();
			}
		},
		_prev: function() {
			var self = this;
			if (self.curMsg > 0) {
				$("#s-m-msg-block-" + self.curMsg, self.$$elmt).css("display", "none");
				self.curMsg--;
				$("#s-m-msg-block-" + self.curMsg, self.$$elmt).css("display", "block");
				self._updateButtons();
			}
		},
		_more: function() {
			var self = this;
			var $$btn = $("#s-m-msg-stack-" + self.curMsg, self.$$elmt);
			var $$stackSection = $("section", $$btn.parent());
			if ($$stackSection.css("display") === "none") {
				$$stackSection.css("display", "block");
				$$btn.text(locale.text("modal.diagnoses.btnstack_hide"));
				self._handleGesture();
			} else {
				$$stackSection.css("display", "none");
				$$btn.text(locale.text("modal.diagnoses.btnstack_show"));
			}
		},
		_updateButtons: function() {
			var self = this;

			for (var ii = 0, jj = self.diagId; ii < jj; ii++) {
				var $$navDot = $("a#s-m-msg-goto-" + ii + " i", self.$$elmt);
				$$navDot.toggleClass("fa-circle", ii == self.curMsg);
				$$navDot.toggleClass("fa-circle-o", ii !== self.curMsg);
			}

			// Only show x of y in case there are more than 1 diagnoses
			if (self.diagId > 1) {
				$(".modal-title", self.$$elmt).text(self.title + " (" + (self.curMsg + 1) + "/" + self.diagId + ")");
			} else {
				// hide nav circles if one diag only
				$(".s-m-modal-diag-goto", self.$$elmt).css("display", "none");
			}
		},
		_onShow: function(evt) {
			var self = this;
			modalDialog.ModalBase.prototype._onShow.call(self, evt);
			self._updateButtons();

			self._checkSize();
			// init swype handler if more than one diagnose
			if (self.diagId > 1) {
				self._initSwiper();
			}
		},
		_handleGesture: function() {
			var self = this;
			self._gestureMgrMap = self._gestureMgrMap || {};

			if (!self._gestureMgrMap["gestureMgr" + self.curMsg]) {
				var $$scrollElmt = $(".s-m-msg-stack-content", $("#s-m-msg-block-" + self.curMsg, self.$$elmt));
				var $$wrapper = $(".s-m-scroll-wrapper", $("#s-m-msg-block-" + self.curMsg, self.$$elmt));

				self._gestureMgrMap["gestureMgr" + self.curMsg] = scroller.newScroller($$scrollElmt, {
					direction: "v"
				});
				var scrollRect = uiRect.elmtRect($$wrapper, "outer");
				self._gestureMgrMap["gestureMgr" + self.curMsg].init(scrollRect);
			}
		},
		/*
		 * User can navigate from one diagnose to another with a swipe gesture.
		 * This method will display appropriate diagnose message depending on the swipe gesture
		 */
		_onSwipe: function(evt) {
			if (hammerScroller.isEvtDirection(evt, "v")) return;

			var self = this;
			setTimeout(function() {
				var next = evt ? evt.type === "swipeleft" : null;
				if (next) {
					self._next();
				} else {
					self._prev();
				}
			});
		},
		_destroySwiper: function() {
			var self = this;
			if (self.hammer) {
				self.hammer.destroy();
				self.hammer = null;
			}
		},
		_initSwiper: function() {
			var self = this;
			self._destroySwiper();
			self.hammer = new hammerScroller.Hammer($(".s-m-modal-diag-content", self.$$elmt).get(0));
			self.hammer.get("swipe").set({
				direction: hammerScroller.Hammer.DIRECTION_HORIZONTAL
			});
			// listen to events...
			this.hammer.on("swipeleft swiperight", hammerScroller.Hammer.bindFn(self._onSwipe, self));
		},
		_checkSize: function() {
			var self = this;
			var $$app = $("#s-m-app-id");
			var $$stacks = $("message > section", self.$$elmt);
			$$stacks.css({
				"max-height": ($$app.height() - 200) + "px"
			});
		}
	}
);
exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalConfirm',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _templateAll = {
	header: '\
		<div class="modal-title">{{title}}</div>',
	content: '\
			<div class="s-m-modal-content">\
				{{message}}\
			</div>',
	footer: '\
		<button type="button" class="btn btn-default" data-action="yes">{{yes}}</button> \
		<button type="button" class="btn btn-default" data-action="no">{{no}}</button>'
};

var _Klass = utils.defineClass(
	function ModalConfirm(message, action, isSimpleConfirm) {
		var self = this;
		modalDialog.ModalBase.call(self);
		// Init params
		self.message = message;
		self.action = action;
		self.isSimpleConfirm = isSimpleConfirm;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},
		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "confirm tablet";
			} else {
				displayFlags.modalClass = "confirm mobile";
			}
			return displayFlags;
		},
		_getDataContext: function() {
			var self = this;
			var ctx = {};
			ctx.title = self.isSimpleConfirm ? null : locale.text("modal.confirm.ttl");
			// different message depending on whether the calling modal.js method is confirm() or simpleConfirm()
			ctx.message = self.action ? modalDialog.checkMsg(locale.text("modal.confirm.msg", [self.action])) : modalDialog.checkMsg(self.message);
			ctx.yes = locale.text("yes");
			ctx.no = locale.text("no");
			return ctx;
		},
		_onAction: function(action, param) {
			var self = this;
			self.selectedAction = action;
			// close on actions
			return true;
		},
		_getResult: function() {
			var self = this;
			return self.selectedAction;
		}
	}
);
exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalField',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _templateAll = {
	header: '\
		<buttons class="pull-right"> \
			<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
		</buttons> \
		<div class="modal-title">{{title}}</div>',
	content: '{{{domBody}}}',
	footer: ''
};


var _Klass = utils.defineClass(
	function ModalField(title, domBody, cb) {
		var self = this;
		modalDialog.ModalBase.call(self);
		// Init params
		self.title = title || "Warning";
		self.domBody = domBody;
		self.cb = cb;
	}, modalDialog.ModalBase, {
		destroy: function() {
			modalDialog.ModalBase.prototype.destroy.call(this);
			this.domBody = null;
			this.cb = null;
		},
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},
		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "field tablet";
			} else {
				displayFlags.modalClass = "field mobile";
			}
			return displayFlags;
		},
		_getDataContext: function() {
			var self = this;
			return {
				title: self.title,
				domBody: self.domBody,
				close: locale.text("modal.btn.close")
			};
		},
		_onShow: function(evt) {
			var self = this;
			modalDialog.ModalBase.prototype._onShow.call(self, evt);
			self._execCb(self.cb, "shown.bs.modal", self.$$elmt);
		},
		_onCancel: function() {
			return true;
		},
		_onHide: function(evt) {
			var self = this;
			modalDialog.ModalBase.prototype._onHide.call(self, evt);
			self._execCb(self.cb, "hide.bs.modal", self.$$elmt);
		},
		_execCb: function(cb, msg, data) {
			if (!cb || arguments.length == 0) return;
			var cb = arguments[0];
			var args = Array.prototype.slice.call(arguments, 1);
			cb.apply(null, args);
		}
	}
);
exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modal',['require','exports','module','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/ui/modals/modalDiagnoses','syracuse-tablet/html/js/ui/modals/modalConfirm','syracuse-tablet/html/js/ui/modals/modalField'],function (require, exports, module) {"use strict";

var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var native = require('syracuse-tablet/html/js/helpers/native/native');

// Separated module for showing diagnoses since it may be replaced depending on device/OS
var ModalDiagnoses = require('syracuse-tablet/html/js/ui/modals/modalDiagnoses').Modal;
var ModalConfirm = require('syracuse-tablet/html/js/ui/modals/modalConfirm').Modal;
var ModalField = require('syracuse-tablet/html/js/ui/modals/modalField').Modal;

var _templates = {
	actionMessage: '\
		<div class="s-m-act-msg {{severityClass}}">\
			<a draggable="false" href="#"><span class="glyphicon glyphicon-remove"></span></a>\
			<header>\
				<div>{{title}}</div>\
			</header>\
			<section>\
				<article>{{message}}</article>\
			</section>\
			<footer></footer>\
		</div>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

/* First param : cb - Second msg - Third data ...*/
var _execCb = function(cb, msg, data) {
	if (!cb || arguments.length == 0) return;
	var cb = arguments[0];
	var args = Array.prototype.slice.call(arguments, 1);
	cb.apply(null, args);
};


/************************************************************************
 ** IMPORTANT
 * The code of the callback parameter in the exported methods :
 * error(), info(), diagnoses(), field(), confirm(), simpleconfirm(), modal()
 * has to indicate whether the callback is called :
 * - when the modal opens
 * - when the modal closes
 * - at both events
 *
 * Here is an example :
 * function (modalEvent, $$modalElmt) {
 *        // build content on open
 *       if (modalEvent == 'shown.bs.modal') {
 *           // code which is run on modal opening
 *       }
 *
 *       // run actions on close 'hidden.bs.modal'
 *       else {
 *       	// code which is run on modal closing
 *       }
 * });
 *************************************************************************/



/*
 * Examples
 * 
 * error("There was an error");
 * 
 * error("There was an error", "I am the detail text");
 *
 * error("There was an error", new Error("I am an exception"));
 * 
 * error("There was an error", {
 *   $diagnoses: [{
 *	   $message: "Message 1",
 *     $severity: "error",
 *     $stackTrace: "bla"
 *	 }, {
 * 	   $message: "Message 2",
 *	   $severity: "info",
 * 	   $stackTrace: "bla"
 *   }]
 * });
 * 
 * error("There was an error", {
 *   message: "I am the message", 
 *   detail: "I am the detail message"
 * });

 * error("There was an error", {
 *   message: "I am the message", 
 *   detail: new Error("I am an exception")
 * });
 * 
 */
var _error = function(title, e, cb) {
	// in the code we can have error(e)
	var error = e;
	var callBack = cb;
	if (title != null && typeof title !== "string") {
		error = title;
		title = null;
	}
	if (typeof e === "function") {
		callBack = e;
	}
	var diag;
	diag = jsutils.convertToDiagnoses(error);
	if (title == null && error && error.$title) {
		title = error.$title;
	}
	return _diagnoses(title, diag, callBack, true);
};

/*
 * title. Title of dialog
 * diag: Object containing diagnoses
 *       {
 *           $diagnoses: [{
 *               $message: "bla...",
 *               $severity: "error", // success, info, warning, error
 *               $stackTrace: "Stacktrace as string, formatted"
 *           }, {
 *               ...
 *           }]
 *       }
 * cb: Callback
 */
var _diagnoses = function(title, diag, cb, forceDisplay) {
	var modal = new ModalDiagnoses(title, diag);
	modal.show(forceDisplay === true).then(function(result) {
		if (cb) {
			cb(result);
		}
	});
	//return modalDiag.show(title, diag, cb);
};

/* 
 * Wrap info text into diagnoses and display it in the generic diagnoses dialog
 */
var _info = function(title, text, cb) {
	var infoDiag = {
		"$diagnoses": [{
			"$severity": "info",
			"$message": text
		}]
	};
	_diagnoses(title, infoDiag, cb);
};
var _warning = function(title, text, cb) {
	_diagnoses(title, {
		"$diagnoses": [{
			"$severity": "warning",
			"$message": text
		}]
	}, cb);
};
var _confirm = function(action, cb) {

	var modal = new ModalConfirm(null, action);

	modal.show().then(function(result) {
		if (cb && (result === "yes" || result === "no")) {
			cb(result, "yes" === result);
		}
	});
};

var _simpleConfirm = function(message, cb) {
	var modal = new ModalConfirm(message, null, true);

	modal.show().then(function(result) {
		if (cb && (result === "yes" || result === "no")) {
			cb(result, "yes" === result);
		}
	});
};

/*
 * simpleConfirmPromise({
 *   message: "Are you sure?"
 *   }).then(function(result) {
 *      if (result.action === "yes") {
 *      } else if (result.action === "no") {
 *      }
 *   });
 */
exports.simpleConfirmPromise = function(options) {
	var deferred = $.Deferred();
	var modal = new ModalConfirm(options.message, null, true);

	modal.show().then(function(result) {
		if (result === "yes" || result === "no") {
			deferred.resolve({
				action: result
			});
		}
	});

	return deferred.promise();
};
/*
 * Open a modal window linked to a field
 */
var _field = function(title, domBody, cb) {
	var modal = new ModalField(title, domBody, cb);
	modal.show();
};

var _actionResult = function(title, obj, forceToast) {
	if (obj && obj.$noConnectionError == true) {
		//	FDB - Changed to _notificationHandler for drafts - exports.noConnectionModal();
		_notificationHandler({
			title: locale.text("action.title.offline"),
			body: locale.text("action.needs.net"),
			severityClass: "warning",
			$$parentSlot: globals.getApplication().getMessageSlot()
		});
		return;
	}
	obj = jsutils.convertToDiagnoses(obj);
	if (!obj || !obj.$diagnoses || obj.$diagnoses.length == 0) return;
	var hasStack = false,
		hasError = false;
	var text = [];
	obj.$diagnoses.forEach(function(diag) {
		text.push(diag.$message);
		if (diag.$severity == "error") {
			hasError = true;
			hasStack = hasStack || diag.$stackTrace != null;
		}
	});
	if (!hasStack || forceToast === true) {
		var options = {
			title: title,
			body: text.join('\n'),
			severityClass: hasError ? "error" : "success",
			$$parentSlot: globals.getApplication().getMessageSlot()
		};

		if (options.onlyWebapp === false && native.hasCapability("toastMessages")) {
			// Adds the message on the toast message stack on windows
			native.getModule("toastMessages").showToastMessage({
				Text1: options.title,
				Text2: options.body,
				Severity: hasError ? "error" : "success"
			});
		} else {
			_notificationHandler(options);
		}
	} else {
		_diagnoses(title, obj);
	}
};

/* options properties are :
- severityClass : css class depending on severity
- title : title text value used in the template
- text : body text value used in the template
- $$parentSlot : parent to which modal is appended, depends on device type
*/
var _notificationHandler = function(options) {

	// create html
	var h = _getHtml("actionMessage", {
		title: options.title,
		message: options.body,
		severityClass: options.severityClass
	});

	var isClosing;
	// append to app according to device type
	var $$actionModal = $(h);
	options.$$parentSlot.prepend($$actionModal);

	// show parentSlot
	options.$$parentSlot.show();

	// close anchor
	var $$closer = $$actionModal.find("a");

	function toggle() {
		$$actionModal.toggleClass("show");
	}
	var delay = options.delay || "medium";
	delay = delay === "short" ? 1500 : delay === "long" ? 7000 : 5000;

	function clear() {
		toggle();
		// set timeout in order to have css animation visible before removing DOM
		setTimeout(function() {
			$$actionModal.remove();

			// hide parent slot if last item removed
			if (options.$$parentSlot.children().length == 0) {
				options.$$parentSlot.hide();
			}
		}, 500);
	};

	// bind click action on closer button. triggers close action
	$$closer.bind("click", function() {
		clear();
		isClosing = true;
	});

	// display
	// setTimeout is necessary to have the display css animation working
	setTimeout(function() {
		toggle();
	}, 50);

	// toggle after 5 seconds
	var toggleTimeout = setTimeout(function() {
		if (!isClosing) {
			clear();
		}
	}, delay);
};


var _modal = function(html, cb) {
	// Disable wait wheel if any
	uiutils.waitWheelStop();
	var app = globals.getApplication();
	if (app && app.currentPage) {
		app.currentPage.waitWheelStop();
	}
	/* Always to retry read template and display alert if not found */
	var h = $(html).modal({
		keyboard: false,
		backdrop: "static"
	});
	var viewportHeight = $(window).height();
	$('.modal-body', h).css('max-height', viewportHeight * 0.7);

	// move modal within the app dom element
	var $$md = $(h);
	var $$parent = $("#s-m-modal-parent") && $("#s-m-modal-parent").length > 0 ? $("#s-m-modal-parent") : $("<div>").attr("id", "s-m-modal-parent");
	$$parent.append($$md);
	$("#s-m-app-id").append($$parent);
	$$parent.toggle(true);

	var done = false;


	// Use <button data-dismiss"modal" for close action
	// Use <button data-action"myaction" for action other than
	// close
	h.on("shown.bs.modal", function(evt) {
		try {
			_execCb(cb, "shown.bs.modal", h);
		} catch (e) {
			alert("Modal open - call back error" + e.stack);
		}
		// !!We need a synchronous call
		app.notifModalOpen();
	});
	// hide.bs.modal is better than hidden.bs.modal be cause it comes sooner
	// Like open modals are accounted in aplication it's better to notifModalClose ASAP otherwise changePage doesn't work fine (no changePage if a modal is opened)
	app.notifModalClose();
	h.on("hide.bs.modal", function() {
		$("#s-m-modal-parent").toggle(false);

		// !!We need a synchronous call
		app.notifModalClose();
		// Call cb only if no click action
		if (!done && cb) {
			try {
				_execCb(cb, "hide.bs.modal", h);
			} catch (e) {
				alert("Modal close - call back error" + e.stack);
			}
		}
		// Called when dialog is close - data-dismiss = "modal"
		// or m.modal('hide')
		h.unbind();
		h.remove();
	});
	// For dialogs with option
	h.delegate("button[data-action]", "click", function(evt) {
		var t = $(evt.target);
		var act = t.attr("data-action");
		if (act) {
			done = true;
			evt.preventDefault();
			evt.stopPropagation();
			_execCb(cb, act, h, t.attr("data-params"));
		}
		// Close modal
		h.modal('hide');
	});
	return h;
};

/**
 * options.onlyWebapp = true if set, notification is not send to operation system but only showen inside application
 */
exports.notify = function(options) {
	var supportsToast = native.hasCapability("toastMessages");
	var onlyWebapp = (options && options.onlyWebapp);
	onlyWebapp = onlyWebapp != null ? onlyWebapp : true;

	if (onlyWebapp || !supportsToast) {
		options.$$parentSlot = options.$$parentSlot || (globals.getApplication() && globals.getApplication().getMessageSlot());
		_notificationHandler(options);
		return;
	}
	if (supportsToast) {
		// Adds the message on the toast message stack on windows
		native.getModule("toastMessages").showToastMessage({
			Text1: options.title,
			Text2: options.body,
			Severity: options.severityClass
		});
	}
};

var _displayActionMsg = function(success, name, proto, data) {
	var obj;
	if (data && data.$diagnoses && data.$diagnoses.length > 0) {
		obj = data;
	} else {
		obj = {
			$diagnoses: [{
				$message: locale.text("modal.action." + (success ? "success" : "fail")),
				$severity: success ? "success" : "error",
				$stackTrace: JSON.stringify(data)
			}]
		};
	}
	var title = name;
	if (proto) {
		var links = proto.data("$links");
		var link = links && links[name];
		if (!link) { // Fallback to check if link is set on a query item
			links = proto.getPrototype("$properties.$resources.$item");
			links = links && links.data("$links");
			link = links && links[name];
		}
		if (link && link.$title) {
			title = proto.resolveExpression(link.$title);
		}
	}
	_actionResult(title, obj);
};

exports.noConnectionModal = function() {
	return _error(
		locale.text("action.title.offline"),
		locale.text("action.needs.net"));
};


/*
 * Creates a diagnoses that contains a general message reporting there was a technical isse
 * This must be used whenever there is an error that the user cannot understand anyway to hide technical
 * defauls from the user
 */
exports.createGeneralErrorDiag = function(source) {
	return {
		$diagnoses: [{
			$message: locale.text("technical.error.message"),
			$severity: "error",
			$stackTrace: JSON.stringify(source)
		}]
	};
};

exports.error = _error;
exports.info = _info;
exports.warning = _warning;
exports.diagnoses = _diagnoses;
exports.field = _field;
exports.confirm = _confirm;
exports.simpleConfirm = _simpleConfirm;
exports.modal = _modal;
exports.actionResult = _actionResult;
exports.displayActionMsg = _displayActionMsg;
});

define('syracuse-tablet/html/js/init/initStyles',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/mobileDetect'],function (require, exports, module) {"use strict";

/*
 * Module to initialize CSS for used OS/Platform
 *
 */
var globals = require('syracuse-tablet/html/js/helpers/globals');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var mobileDetect = require('syracuse-tablet/html/js/helpers/mobileDetect');

function _loadCss(file) {
	var ref = document.createElement("link");

	ref.setAttribute("rel", "stylesheet");
	ref.setAttribute("type", "text/css");
	ref.setAttribute("href", file);

	document.getElementsByTagName("head")[0].appendChild(ref);
}

function _isSurfaceTablet() {
	navigator.userAgent.toLowerCase().indexOf("tablet pc") > -1 && navigator.userAgent.toLowerCase().indexOf("windows") > -1;
}

exports.init = function() {
	var deferred = new $.Deferred();
	var os = mobileDetect.getStyleOS();
	var styles;
	//	if (_isSurfaceTablet()) {
	//		styles = "surface";
	//	} else {
	styles = os;
	//	}
	var cssPlatform = "./css/gen/" + styles + (jsutils.isReleaseVersion() ? ".min" : "") + ".css";
	_loadCss(cssPlatform);
	var cssGeneral = "./css/default" + (jsutils.isReleaseVersion() ? ".min" : "") + ".css";
	_loadCss(cssGeneral);
	deferred.resolve();
	globals.setLookAndFeel(styles);

	return deferred.promise();
};
});

define('syracuse-tablet/html/js/init/initLocale',['require','exports','module','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var locale = require('syracuse-tablet/html/js/helpers/locale');

exports.init = function() {
	var lang = "en-GB";
	return locale.setLocale(lang);
};
});

define('syracuse-tablet/html/js/controls/ctrlFactory',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("factory");
var globals = require('syracuse-tablet/html/js/helpers/globals');

var _ctor = {};

var _types = {
	// official types
	string: "application/x-string",
	password: "application/x-password",
	text: "text/plain",
	integer: "application/x-integer",
	real: "application/x-real",
	decimal: "application/x-decimal",
	quantity: "application/x-quantity",
	choice: "application/x-choice",
	boolean: "application/x-boolean",
	date: "application/x-date",
	time: "application/x-time",
	datetime: "application/x-datetime",
	reference: "application/x-reference",
	array: "application/x-array",
	image: "image",
	doc: "application/x-document",
	binary: "application/x-binary",
	soapObject: "application/x-object",
	textRtf: "text/rtf",
	textHtml: "text/html",
	textPlain: "text/plain",
	// our own types
	vignette: "tablet/x-vignette",
	layout: "tablet/x-layout",
	filter: "application/x-filter",
	// !!! tablet/x-page- prefix means page control !!!
	breadcrumbs: "tablet/x-page-breadcrumbs",
	pageheader: "tablet/x-page-header",
	pagefooter: "tablet/x-page-footer",
	vignettefooter: "tablet/x-page-vignette-footer",
	vignetteheader: "tablet/x-page-vignette-header",
	panelactionregular: "tablet/x-page-panel-actionregular",
	panelusersmartphone: "tablet/x-page-panel-usersmartphone",
	panelfiltersort: "tablet/x-page-panel-filtersort",
	panelpageshare: "tablet/x-page-panel-pageshare",
	panelpageedittemplate: "tablet/x-page-panel-edittemplates",
	// end page controls
	icon: "tablet/x-icon",
	button: "tablet/x-button",
	unfound: "tablet/x-unfound",
	rowStatus: "tablet/x-row-status",
	rowIndex: "tablet/x-row-index",
	chartDetailToolbar: "tablet/x-chartdetail-toolbar"
};
/**
 * Create a control and insert DOM element in a grid cell
 * 	TODO - Use an HTML builder instead of a control
 */
var _createCellFieldCtrl = function($$parentCell, controller, ctrlArticle, ctrlProto, options) {
	// need to extend because the control can add options
	options = $.extend(true, {}, options);
	// True if the field id added to a cell of a table - Array with table display
	options.displayCtx = "table";
	return _createControl(controller, null, ctrlArticle, ctrlProto, options);
};
/**
 * Create a control
 * 	Add control to controller
 * 	Append control as a child of parentStructElmt
 *  options: arrayCtx : context of array filed display
 */
var _createControl = function(controller, parentStructElmt, article, prototype, options) {
	if (!controller) throw new Error("createControl - null parent or controller");
	// need to extend because the control can add options
	options = $.extend(true, {}, options);
	var c;
	var type = prototype.data("$type");
	switch (type) {
		case _types.string:
		case _types.password:
			switch (prototype.data("$format")) {
				case "$phone":
					c = new _ctor.PhoneField(controller, article, prototype, options);
					break;
				case "$email":
					c = new _ctor.EmailField(controller, article, prototype, options);
					break;
				case "$url":
					c = new _ctor.UrlField(controller, article, prototype, options);
					break;
				default:
					c = new _ctor.Alphanum(controller, article, prototype, options);
			}
			break;
		case _types.integer:
		case _types.real:
		case _types.decimal:
		case _types.quantity:

			// "$numDisplay" is an authoring property used to select how to display numeric value (either "gauge" or "normal")
			if (article.$numDisplay) {
				// important in case we switch from "normal" to "gauge"
				if (!article.$gauge && article.$numDisplay === "gauge") {
					article.$gauge = {};
				}
				if (article.$numDisplay === "normal") {
					if (type === _types.quantity) {
						c = new _ctor.Quantity(controller, article, prototype, options);
					} else {
						c = new _ctor.Numeric(controller, article, prototype, options);
					}
				} else {
					c = new _ctor.Gauge(controller, article, prototype, options);
				}
			} else {
				if (article.$gauge) {
					c = new _ctor.Gauge(controller, article, prototype, options);
				} else if (type === _types.quantity) {
					c = new _ctor.Quantity(controller, article, prototype, options);
				} else {
					c = new _ctor.Numeric(controller, article, prototype, options);
				}
			}
			break;
		case _types.choice:
			c = new _ctor.Combo(controller, article, prototype, options);
			break;
		case _types.boolean:
			switch (prototype.data("$format")) {
				case "$switch":
					c = new _ctor.Switch(controller, article, prototype, options);
					break;
				default:
					c = new _ctor.CheckBox(controller, article, prototype, options);
			};
			break;
		case _types.date:
		case _types.time:
		case _types.datetime:
			c = new _ctor.Date(controller, article, prototype, options);
			break;
		case _types.reference:
			c = new _ctor.Reference(controller, article, prototype, options);
			break;
		case _types.array:
			// Array or request
			if (prototype.data("$cube")) {
				// We always instantiate an ArrayChart because whatever $display chart/table/card...
				// ArrayChart manages the links to detail chart and is needed if we display a "$cube" as a table/card...
				c = new _ctor.ArrayChart(controller, article, prototype, options);
			} else {
				c = new _ctor.Array(controller, article, prototype, options);
			}
			break;
		case _types.vignette:
			c = new _ctor.Vignette(controller, article, prototype, options);
			break;
		case _types.image:
			c = new _ctor.Image(controller, article, prototype, options);
			break;
		case _types.doc:
			c = new _ctor.Document(controller, article, prototype, options);
			break;
		case _types.binary:
			c = new _ctor.Binary(controller, article, prototype, options);
			break;
		case _types.icon:
			c = new _ctor.Icon(controller, article, prototype, options);
			break;
		case _types.button:
			c = new _ctor.Button(controller, article, prototype, options);
			break;
		case _types.textRtf:
		case _types.textHtml:
		case _types.textPlain:
			c = new _ctor.Text(controller, article, prototype, options);
			break;
		case _types.soapObject:
			throw new Error("not implemented");
			break;
		case _types.unfound:
			c = new _ctor.FieldUnfound(controller, article, prototype, options);
			break;
		case _types.rowStatus:
			c = new _ctor.FieldRowStatus(controller, article, prototype, options);
			break;
		case _types.rowIndex:
			c = new _ctor.FieldRowIndex(controller, article, prototype, options);
			break;
		case _types.filter:
			c = new _ctor.Filter(controller, article, prototype, options);
			break;
		default:
			if (globals.isDvlpMode()) {
				c = new _ctor.TypeUnknown(controller, article, prototype, options);
			} else {
				return;
			}
			break;
	}
	//Field inside a table cell - Nothing - Control is used only to build html - TODO use html Builders instead of control
	if (options.displayCtx === "table") return c;
	if (!parentStructElmt) throw new Error("createControl - Parent's control is mandatory");
	// Add control elmt in a tree
	parentStructElmt.appendStructElmt(c);
	// Add control to controller
	if (options.displayCtx !== "card") {
		controller.addControl(c);
	} // Else array card context we don't add control but build tree - tree is used as a html generator
	return c;
};
var _createLayout = function(controller, parentStructElmt, article, opts) {
	// need to extend because the control can add options
	opts = $.extend(true, {}, opts);
	var type = article.$layoutType || "stack";
	var klass;
	if (type == "stack") {
		klass = _ctor.LayoutStack;
	} else if (type == "row") {
		klass = _ctor.LayoutRow;
	} else if (type == "tab") {
		klass = _ctor.LayoutTab;
	} else if (type == "hub") {
		klass = _ctor.LayoutHub;
	} else if (type == "hubGroup") {
		klass = _ctor.LayoutHubGroup;
	} else if (type == "tile") {
		klass = _ctor.LayoutTile;
	} else if (type == "cell") {
		klass = _ctor.LayoutCell;
	} else {
		log && log("layout type=" + type + " is not implemented");
		return null;
	}
	var l = new klass(controller, type, article, opts);
	if (parentStructElmt) {
		parentStructElmt.appendStructElmt(l);
	} else {
		// Root layout
		l.parent = controller;
	}
	controller.addLayout(l);
	return l;
};
/**
 * Creates page static controls - header/footer
 */
var _createPageControl = function(type, controller, options) {
	// need to extend because the control can add options
	options = $.extend(true, {}, options);
	var c;
	switch (type) {
		case "breadcrumbs":
			c = new _ctor.BreadCrumbs(_types.breadcrumbs, controller, options);
			break;
		case "header":
			c = new _ctor.PageHeader(_types.pageheader, controller, options);
			break;
		case "footer":
			c = new _ctor.PageFooter(_types.pagefooter, controller, options);
			break;
		case "topToolbarChartDetail":
			c = new _ctor.ChartDetailToolbar(_types.chartDetailToolbar, controller, options);
			break;
		default:
			throw new Error("Unknown page control[" + type + "]");
			break;
	}
	controller.addControl(c);
	return c;
};
var _createActionControl = function(type, vignette, options) {
	// need to extend because the control can add options
	options = $.extend(true, {}, options);
	if (type === "footer") return new _ctor.VignetteFooter(_types.vignettefooter, vignette, options);
	if (type === "header") return new _ctor.VignetteHeader(_types.vignetteheader, vignette, options);
	throw new Error("Unknown vignette action control[" + type + "]");
};
/**
 * Creates panels
 * id	globals.PANELACTIONSREGULAR, globals.PANELUSERSMARTPHONE, globals.PANELFILTERSORT
 */
var _createPanel = function(controller, panelId, options) {
	// need to extend because the control can add options
	options = $.extend(true, {}, options);
	var deviceType = globals.getSiteLayout().getDeviceType();
	// We need to store device type to detect changes and recreate panels if needed
	options = options || {
		deviceType: deviceType
	};
	switch (panelId) {
		case globals.PANELACTIONSREGULAR:
			return new _ctor.PageActionPanelRegular(controller, _types.panelactionregular, panelId, options);
		case globals.PANELUSERSMARTPHONE:
			return new _ctor.UserPanelSmartphone(controller, _types.panelusersmartphone, panelId, options);
			break;
		case globals.PANELFILTERSORT:
			return new _ctor.FilterSortPanel(controller, _types.panelfiltersort, panelId, options);
		case globals.PANELPAGESHARE:
			return new _ctor.PageSharePanel(controller, _types.panelpageshare, panelId, options);
		case globals.PANELEDITTEMPLATES:
			return new _ctor.PageTemplatePanel(controller, _types.panelpageedittemplate, panelId, options);
		default:
			throw new Error("Unknown page control[" + panelId + "]");
	}
	// Control is not added here but by panel manager
};

/*
 * This is a trick used by authoring
 * We create a dummy control that only returns an article with a $bind node
 * This allows authoring to only add this kind of untyped controls and after a refresh,
 * the base system creates the "real" control.
 */
var _createBindControl = function(controller, parentStructElmt, article) {
	if (!controller) throw new Error("Control - null parent or controller");
	var c = new _ctor.StructElmt(controller, "$dummyBind", article, {}, {});
	if (parentStructElmt) {
		// Add control elmt in a tree
		parentStructElmt.appendStructElmt(c);
	} else {
		throw new Error("Parent's control is mandatory");
	}
	return c;
};


exports.createPanel = _createPanel;
exports.createControl = _createControl;
exports.createLayout = _createLayout;
exports.createPageControl = _createPageControl;
exports.createActionControl = _createActionControl;
exports.createCellFieldCtrl = _createCellFieldCtrl;
exports.createBindControl = _createBindControl;

exports.type = function(name) {
	return _types[name];
};
exports.setImpl = function(name, ctor) {
	_ctor[name] = ctor;
};
});

define('syracuse-tablet/html/js/helpers/articleParser',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/controls/ctrlFactory','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("articleParser");
var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

/**
 * Return true if jsonArrayProto is a single array
 * For one cell array prototype doesn't contain $properties
 * For one x-reference cell array $properties of prototype isn't $properties of the array but $properties of the reference field
 * This code is shared with prototype class
 */
var _isSingleArray = function(jsonArrayProto) {
	return jsonArrayProto.$item.$properties == null || jsonArrayProto.$type == "application/x-reference";
};
/**
 * Parses an article and generate the control tree structure
 */
var _Parser = utils.defineClass(
	function(page) {
		// Controller
		var self = this;
		self.page = page;
	}, null, {
		_doParse: function(article, prototype, parent, opts, unfounds) {
			var self = this;
			if (article.$layoutType) {
				if (opts.index == null) {
					opts.index = 0;
				} else {
					opts.index++;
				}
				var lyt = ctrlFactory.createLayout(self.page, parent, article, opts);
				if (lyt && article.$items) {
					article.$items.forEach(function($itm) {
						// Important: Do not clone article here since full tree has to be preserved	
						self._doParse($itm, prototype, lyt, opts, unfounds);
					});
				}
				return lyt;
			} else if (article.$bind) {
				var fieldProto = prototype.getPrototype(article.$bind);
				if (fieldProto == null && article.$isUnfound !== true) {
					unfounds.push(article);
				} else {
					if (article.$isUnfound) {
						fieldProto = prototype.create({
							$type: "tablet/x-unfound"
						});
					}
					if (!fieldProto.data("$isExcluded")) {
						// Important: Do not clone article here since full tree has to be preserved
						ctrlFactory.createControl(self.page, parent, article, fieldProto, opts);
					}
				}
			} else {
				log && log("$layoutType or $bind exspected");
				//throw new Error ("$layoutType or $bind expected");
			}
		},
		parse: function(article, prototype, opts) {
			var self = this;
			try {
				if (!article || !prototype) throw new Error("Not empty article and prototype are expected");
				if (!article.$layoutType) {
					//Mandatory - Better than an exception	
					article.$layoutType = "stack";
				}
				var unfounds = [];
				opts.$localization = utils.getArticleLocalization(article);
				var root = self._doParse(article, prototype, null, opts, unfounds);
				if (unfounds.length > 0 && globals.getDvlpOpt("showUnfoundFields")) {
					var article = {
						$layoutType: "stack",
						$items: []
					};
					unfounds.forEach(function(f) {
						article.$items.push($.extend(true, f, {
							$isUnfound: true
						}));
					});
					self._doParse(article, prototype, root, opts, null);
				}
				return root;
			} catch (e) {
				log && log('article parser error', e);
				throw new Error("Error parsing article [" + e.message + "]\n" + jsutils.cleanStack(e.stack));
			}
		}
	}
);

/**
 * Parses article and calls the controls factory
 * 		article: json description
 *  	prototype: prototype object (Prototype class)
 *  Return root element (layout)
 */
var _article2Controls = function(page, article, prototype, opts) {
	var p = new _Parser(page);
	return p.parse(article, prototype, opts);
};

/**
 * Convert a desktop article to tablet one
 * 		article:  desktop json description
 *  	prototype: prototype object (Prototype class)
 */
var _defOption = {
	skipblock: true,
	skipsection: true,
	include: ["$category", "$layoutType", "$title", "$bind"],
	exclude: ["$items", "$widths"],
	protoExclude: ["application/x-array", "application/json"]
};

var _convertWidth = function(widths) {
	var r = [];
	widths = widths.split(",");
	// temporarily - We can also embed cells into 
	if (widths.length === 0) throw new Error("Number of cells/rows must be > 0");
	if (widths.length > 12) throw new Error("Number of cells/rows must be <= 12");
	var sum = 0;
	widths.forEach(function(w) {
		w = parseInt(w, 10);
		w = Math.ceil(w / 12);
		sum += w;
		r.push(w);
	});
	if (sum > 12) {
		var d = sum - 12;
		r.sort();
		while (d > 0) {
			// Remove excess starting from large cells
			for (var i = r.length - 1; i >= 0; i--) {
				if (d > 0 && r[i] > 1) {
					r[i] = r[i] - 1;
					d--;
				}
			}
		}
	} else if (sum < 12) {
		var d = 12 - sum;
		r.sort();
		while (d > 0) {
			// Add shortage starting from small cells
			for (var i = 0; i < r.length; i++) {
				if (d > 0) {
					r[i] = r[i] + 1;
					d--;
				}
			}
		}
	}
	return r.join(",");
};
var _scanDesktop = function(json, options) {

	if (!json) return null;
	// we skip $layout
	var res;
	if (json.$layout) {
		res = _scanDesktop(json.$layout, options);
	} else {
		res = {};
	}
	if (json.$layoutType) {
		if (!json.$items) throw new Error("$items is missing");
		res.$items = [];
		json.$items.forEach(function(itm) {
			res.$items.push(_scanDesktop(itm, options));
		});
	}
	for (var p in json) {
		if (p === "$widths") {
			res[p] = _convertWidth(json[p]);
		} else if (options.exclude.indexOf(p) === -1 && options.include.indexOf(p) >= 0) {
			res[p] = json[p];
		}
	}
	return res;
};

var _convertDesktop = function(article, prototype, options) {
	options = $.extend({}, _defOption, options);
	return _scanDesktop(article, options);
};



var _coreLayout2DefaultLayout = function(coreLayout, article, props) {
	var p = new _LayoutParser();
	p.parse(coreLayout, article, props);
};
var _LayoutParser = utils.defineClass(
	function() {
		var self = this;
	}, null, {
		_doParse: function(coreLayout, article, props) {
			var self = this;
			if (!coreLayout) return;
			var idx, idx1;
			coreLayout.$items.forEach(function($itm) {
				switch ($itm.$category) {
					case "section":
						{
							idx = article.$items.push({
								"$title": $itm.$title,
								"$layoutType": "stack",
								"$items": []
							});
							self._doParse($itm.$layout, article.$items[idx - 1], props);
							break;
						};
					case "block":
						{
							idx = article.$items.push({
								"$title": $itm.$title,
								"$layoutType": "stack",
								"$items": []
							});
							idx1 = article.$items[idx - 1].$items.push({
								"$layoutType": "row",
								"$items": []
							});
							self._doParse($itm.$layout, article.$items[idx - 1].$items[idx1 - 1], props);
							break;
						};
					default:
						{
							if (props[$itm.$bind] && !props[$itm.$bind].$isExcluded) {
								idx = article.$items.push({
									"$layoutType": "cell",
									"$bgColor": "",
									/*to avoid default cell color*/
									"$items": []
								});

								article.$items[idx - 1].$items.push({
									"$bind": $itm.$bind,
								});
							}
							return;
						}
				}
			});
		},
		parse: function(proto, article, props) {
			this._doParse(proto.$article.$layout, article, props);
		}
	}
);
exports.coreLayout2DefaultLayout = _coreLayout2DefaultLayout;
exports.article2Controls = _article2Controls;
exports.convertDesktop = _convertDesktop;
exports.isSingleArray = _isSingleArray;
});

define('syracuse-tablet/html/js/helpers/prototype',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/articleParser'],function (require, exports, module) {"use strict";
var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');

/**
 * Return json prototype of an array or null if proto is not an array
 * proto is a prototype object or a JSON object
 * This code is shared with prototype class
 */
var _getArrayJsonProto = function(proto) {
	if (!proto) return null;
	var json;
	if (!$.isPlainObject(proto)) {
		if (proto.isArray()) {
			json = proto.json;
		} else if (proto.parent) {
			json = proto.parent.json;
		}
	} else {
		json = proto;
	}
	if (json == null || json.$type !== "application/x-array") return null;
	return json;
};

var _testFacet = /representation=.*\.\$(\w+)[&]*/;

/**
 * getFieldNameForValue
 */
var _reg1 = /{[^}]+}/g,
	_reg2 = /[{}]/g;
/**
 * Prototype class
 * 	Provides all the method to deal with prototype
 * 	manage prototype chaining parent -> child
 * !!use Prototype methods instead of dealing directly with JSON
 */
var _Prototype = utils.defineClass(function Prototype(json, parent) {
	var self = this;
	this.json = json || {};
	if (typeof this.json == "string") {
		this.json = JSON.parse(self.json);
	}
	if (parent) {
		this.parent = parent;
	}
	this.init();
}, null, {
	init: function() {
		var props = this.json.$properties;
		if (!props) return;
		for (var p in props) {
			if (props[p].$type === "application/x-reference") {
				this.initRefField(props[p], p);
			}
		}
	},
	destroy: function() {
		// Just set to null
		this.parent = null;
		// Just set to null
		this.json = null;
	},
	/**
	 * returns json[prop]
	 * 	ignoreParent: true -> Don't read property in parent
	 */
	data: function(prop, dataContext, ignoreParent, noResolve) {
		if (!prop || prop.length == 0) return null;
		var val = this.json[prop];
		if (val == null) {
			if (ignoreParent == null) {
				if (["$title", "$description"].indexOf(prop) > -1) {
					ignoreParent = true;
				}
			}
			var pVal = ignoreParent !== true && this.parent ? this.parent.data(prop, dataContext, null, true) : val;
			if (pVal != null) {
				this.json[prop] = pVal;
			}
			return pVal;
		}
		if (noResolve) {
			return val;
		}
		// #5793 we resolve with searchInParents = true -> expression variable will be searched in dataContext and parent
		return this.resolveExpression(val, dataContext, true);
	},
	/**
	 * returns JSON for json.$properties[name]
	 * If prop!=null returns json.$properties[name][prop]
	 * dataContext: optional
	 */
	property: function(name, prop, dataContext) {
		if (!name || name.length === 0) return null;
		var o = this.json.$properties ? this.json.$properties[name] : this.parent ? this.parent.property(name) : null;
		if (!o || !prop) return o;
		return this.resolveExpression(o[prop], dataContext);
	},
	/**
	 * True if the property prop is a x-reference
	 */
	isReference: function(propname) {
		var res;
		if (this._cacheRef != null) {
			res = this._cacheRef[propname];
			if (res != null) return res;
		}
		var p = this.property(propname);
		res = p != null && p.$type === "application/x-reference";
		if (!this._cacheRef) this._cacheRef = {};
		this._cacheRef[propname] = res;
		return res;
	},
	/**
	 * True proto is a x-array
	 */
	isArray: function() {
		return this.json.$type === "application/x-array";
	},
	/**
	 * True proto is a x-array
	 */
	isBlob: function() {
		var t = this.json.$type;
		return t === "image" || t === "application/x-document" || t === "application/x-array";
	},
	isHidden: function() {
		return this.json.$isHidden === true || false;
	},
	/**
	 * Check value and resolve if it's an expression or title otherwise return val
	 * 	dataContext optional (used for expressions other than localization)
	 */
	resolveExpression: function(val, dataContext, searchInParent, keepPlaceholder) {
		if (val && val.indexOf && val.indexOf('{') >= 0) {
			val = utils.parseExpression(val, dataContext, this, searchInParent, keepPlaceholder);
		}
		return val;
	},
	localization: function(val) {
		var self = this;
		var loc = self.json.$localization || {};
		return loc[val] ? loc[val] : self.parent ? self.parent.localization(val) : null;
	},
	/**
	 * returns a prototype object for json.$properties[prop] or $item proto for grids
	 * prop			$items for arrays
	 * 				propertyName for fields
	 * 				path with . as separator of data in other cases (rowDetail)
	 *  override: 	optional - override JSON properties
	 *  			used by row detail to get page prototype from array field proto
	 *  facet		force facet
	 */
	getPrototype: function(prop, override, facet) {
		var json;
		if (prop.indexOf(".") > 0) {
			json = this.getDataByPath(prop);
		} else if (prop === "$item") {
			json = this.data(prop);
			if (this.isSingleArray(true)) { /** we create a standard proto compliant with multiple columns arrays **/
				var newJson = {
					$properties: {},
					$type: "application/json"
				};
				newJson.$properties[globals.SINGLEARRAYPROP] = json;
				json = newJson;
			}
		} else {
			json = this.property(prop);
		}
		if (!json) return null;
		override = $.extend(true, {}, json, override);
		var proto = exports.create(override, this);
		if (proto.json.$links) {
			Object.keys(proto.json.$links).forEach(function(key) {
				if (key.indexOf("$") != 0 && ((proto.json.$links[key].$url && proto.json.$links[key].$url.indexOf("http") == 0) || proto.json.$links[key].$url === "")) {
					proto.json.$format = proto.json.$format || "$url";
					proto.json.$urlkey = key;
				}
			});

		}
		if (facet) {
			proto._facet = facet;
		}
		return proto;
	},
	/**
	 * Stats prototype
	 */
	isCube: function() {
		return this.isFacet("cube");
	},
	/**
	 * Query prototype
	 */
	isQuery: function() {
		return this.isFacet("query");
	},
	/**
	 * Lookup prototype
	 */
	isLookup: function() {
		return this.isFacet("lookup");
	},
	isQueryLikeFacet: function() {
		return this.isQuery() || this.isLookup() || this.isCube() || this.isRequest();
	},
	isDetails: function() {
		return this.isFacet("details");
	},
	isRequest: function() {
		return this.json.codeRequest != null && this.json.codeRequest.length > 0;
	},
	isStatistics: function() {
		return this.json.codeStat != null && this.json.codeStat.length > 0;
	},
	acceptServerPagination: function() {
		return this.isQuery() || this.isLookup() || this.isRequest();
	},
	/**
	 * return true if aguments contain the facet
	 * Ex: 	isFacet("edit, "detail") return true if edit OR detail
	 * 		isFacet("detail") return true if detail
	 */
	isFacet: function() {
		return Array.prototype.indexOf.call(arguments, this.getFacet()) >= 0;
	},
	/**
	 * Format for display a value according to proto description
	 * Temporarily
	 */
	formatDisplay: function(prop, dataContext) {
		var self = this;
		var info = self.property(prop);

	},
	/**
	 * Temporarily - Add our own property - TODO Find another way
	 * 		Add row index in prototype for grids
	 */
	addProperty: function(name, descr) {
		var self = this;
		if (descr && self.json.$properties && !self.json.$properties[name]) {
			self.json.$properties[name] = descr;
		}
	},
	getPropTitle: function(propName) {
		var self = this;
		var prop = self.property(propName);
		return prop && prop.$title ? self.resolveExpression(prop.$title) : "";

	},
	getUrlLink: function(propName) {
		var prop = this.property(propName, "$links");
		return prop ? prop[this.json.$urlkey] : null;
	},
	getFacet: function() {
		if (this._facet == null) {
			// We read the facet from this -> parent and keep the first one
			// !! do not take the one of root parent 
			var p = this,
				t;
			while (p != null && t == null) {
				if (p.json.$url != null && p.json.$url.trim().length != 0) {
					t = _testFacet.exec(p.json.$url);
					t = t != null && t.length == 2 ? t[1] : null;
				}
				p = p.parent;
			}
			this._facet = t || "";
		}
		return this._facet;
	},
	/**
	 * Returns the name of the field that contains the value ($refValue)
	 * 	For std type it returns name
	 * 	For reference type
	 * 		Set $refValue in prototype
	 * 		Set $lookupdescr - I don't remember if it will be used in tablet but I suppose - TODO remove if not used
	 * 		In mobile client this method was called after having loaded the prototype to calculated additionnal information needed by the client
	 */

	getFieldNameForValue: function(name) {
		var prop = this.property(name);
		if (!prop || !prop.$item) return name;
		// reference fiels have been initialized at creation of proto object - initRefField
		return prop.$item.$refValue || name;
	},
	getFieldTypeForValue: function(name) {
		var prop = this.property(name);
		// String by default to not fail
		var $type = prop && prop.$type ? prop.$type : "application/x-string";
		if ($type === "application/x-quantity") {
			if (prop.$value) {
				$type = prop.$value.$type;
			}
			$type = $type || "application/x-integer";
		} else if ($type === "application/x-reference") {
			if (prop.$item) {
				$type = prop.$item.$refValueType;
			}
			$type = $type || "application/x-string";
		}
		return $type;
	},
	/**
	 * TODO - Test with Syracuse entities and X3 test screens
	 */
	initRefField: function(protoField, name) {
		var self = this;
		if (!protoField) throw new Error("Field proto expected[" + name + "]");
		var item = protoField.$item;
		if (!item || item.$refValue) return;
		item.$refValue = item.$lookupValue = name;
		if (item.$value && typeof item.$value == "string") {
			var vals = item.$value.match(_reg1);
			if (vals && vals.length == 1) {
				// In X3 we expect only one param in $values -> "{CUR}"
				// v : must point to key of cd object - { $value:"{F1}", F1:"{F2}"} - F2 must be a field of cd parent
				var f1 = vals[0].replace(_reg2, "").trim();
				// See AQTCRUDM Tabel Diverse -> $value = {CODE} means that value of xref field value is given by the field CODE
				item.$lookupValue = f1;
				if (item[f1]) {
					var f2 = item[f1].replace(_reg2, "").trim();
					if (self.property(f2)) {
						// Field that contains the value in the prototype - Same field in collaboration - Dedicated field in X3 :-(
						item.$refValue = f2;
					} // else field not found in parent keep $$refValue = property
				} else {
					item.$refValue = f1; // else item  key not found keep $refValue = property
				}
			} else {
				throw new Error("Prototype.initRefField - Only one value is expected");
			}
		}
		if (item.$refValue) {
			var p = self.property(item.$refValue);
			if (p && p.$type) {
				item.$refValueType = p.$type;
			}
		}
		if (item.$autoLookWhere == null) {
			this._setAutoLookupWhere(item);
		}
	},
	_setAutoLookupWhere: function(item) {
		var url = item.$links && item.$links.$lookup ? item.$links.$lookup.$url : "";
		if (url && item.$key && item.$value != item.$key) {
			var key = utils.splitSdataKey(item.$key);
			var where = null;
			key.forEach(function(k) {
				if (!k || k == item.$value) {
					return;
				}
				// check if it's a field  #7830
				if (!k.smStartsWith('{') && !k.smEndsWith('}')) {
					return;
				}
				var propName = k.replace(/[{}]/g, ""); // Remove leading and trailing {}
				var valName = propName;
				if (item[propName]) { // value property may be mapped like {PROJECT} and in item there is "PROJECT" : "{CTASK_PROJECT}" 
					valName = item[propName];
					valName = valName && valName.replace(/[{}]/g, "");
				}
				where = where || {};
				where[propName] = valName;
			});
			if (where) {
				item.$autoLookWhere = where;
			}
		}
	},
	/**
	 * return the value of a given path
	 * 	path:	String with/without '.' as separator or array of strings
	 */
	getDataByPath: function(path) {
		if (!this._cachePath) this._cachePath = {};
		return utils.getPropByPath(this.json, path, this._cachePath);
	},
	getVignetteGadget: function() {
		return this.data("$gadget");
	},
	/**
	 * Calculates the prototype and other info for unit field
	 */
	getUnitFieldInfo: function() {
		var self = this;
		var res = {};
		res.$unit = self.data("$unit");
		if (typeof res.$unit == "object") {
			res.unitBindName = "$unit";
			res.unitFieldProto = exports.create($.extend({}, self.$unit));
		} else if (typeof res.$unit == "string") {
			res.unitBindName = res.$unit;
			var parent = self.parent;
			while (parent) {
				var unitProto = parent.property(res.$unit);
				if (unitProto) {
					res.unitFieldProto = exports.create($.extend({}, unitProto));
					break;
				}
				parent = parent.parent;
			}
		}
		return res;
	},

	/**
	 * True if array has one column - Single array
	 * Protocole isn't consistent because there a confusion with x-reference fields
	 * current object is array proto or array.$item proto
	 * field!=null -> Check field's proto
	 **/
	isSingleArray: function(noFail, field) {
		var jsonArray;
		if (field != null) {
			jsonArray = this.property(field);
		} else {
			if (this.$singleArray) return this.$singleArray;
			jsonArray = _getArrayJsonProto(this);
		}
		if (jsonArray == null && noFail) return false;
		if (jsonArray == null) throw new Error("Unexpected parent array");
		var res = articleParser.isSingleArray(jsonArray);
		if (field != null) {
			// Cache
			this.$singleArray = res;
		}
		return res;
	},
	getPropertyNames: function() {
		var props = this.json.$properties;
		if (props) {
			return Object.keys(props);
		}
		return [];
	},
	getProperties: function(select) {
		var props = this.json.$properties;
		var $properties = [];
		Object.keys(props).forEach(function(v) {
			if (select(props[v], v)) {
				$properties[v] = $.extend(true, {}, props[v], {});
			}
		});
		return $properties;
	},
	/**
	 * Create a child proto from JSON
	 * Used by example for unknown fields
	 */
	create: function(json, notChild) {
		return exports.create($.extend(true, {}, json), notChild === true ? null : this);
	},
	/**
	 * this is the prototype of an array field
	 * return information on columns to display
	 * $bindValue is the field that contains the value - For non-refrence bindValue = $bind
	 */
	arrayTableGetColInfo: function() {
		var base = {
			$title: "",
			$titleOrig: "", // title not resolved
			$type: "",
			$bind: "",
			$widthType: "auto",
			$imgHeight: "small",
			$widthVal: 0,
			$capabilities: ""
		};
		var res = [];
		if (this.isSingleArray()) {
			var prop = this.getDataByPath("$item");
			var p = $.extend({}, base, prop);
			p.$title = this.resolveExpression(this.$title);
			p.$titleOrig = this.$title;
			p.$bind = globals.SINGLEARRAYPROP;
			res.push(p);
		} else {
			var props = this.getDataByPath("$item.$properties");
			if (!props) return null;
			var prop;
			var self = this;
			var itemProto = this.getPrototype("$item");
			Object.keys(props).forEach(function(key) {
				prop = props[key];
				// #6792  we exclude hidden columns because the protocol doesn't allow to sho/hide columns - hidden means excluded
				if (prop.$isHidden !== true && prop.$isExcluded !== true && (globals.EXCLUDEFIELDS.indexOf(key) < 0)) {
					var p = $.extend({}, base, prop);
					p.$title = self.resolveExpression(prop.$title);
					p.$titleOrig = prop.$title;
					// Bind field - Ex SITE_REF
					p.$bind = key;
					// Name of the field that contains the value - !=$bind for non reference fields - Ex For SITE_REF -> SITE
					p.$bindValue = itemProto.getFieldNameForValue(key);
					// Type of the field that contains the value - !=$type for non reference fields - Ex For SITE -> "application/x-string"
					p.$bindType = itemProto.getFieldTypeForValue(key);
					res.push(p);
				}
			});
		}
		return res;
	},
	chartGetMeasureInfo: function() {
		var res = {}, prop;
		var props = this.getDataByPath("$item.$properties");
		var measures = this.getDataByPath("$cube.$measures");
		if (measures) {
			Object.keys(measures).forEach(function(key) {
				prop = props[key];
				prop.$bind = key;
				res[key] = prop;
			});
		}
		return res;
	},
	chartGetNbMeasures: function() {
		var res = 0;
		var measures = this.getDataByPath("$cube.$measures");
		if (measures) {
			Object.keys(measures).forEach(function(key) {
				res++;
			});
		}
		return res;
	},
	getRepDotFacet: function() {
		var self = this;
		return self.data("$type").split(".").slice(-2).join(".");
	},
	isValid: function() {
		return this.json != null;
	},
	getLayoutCategoriesTitle: function() {
		var title = [];
		var uniqTitle = {};
		var self = this;

		function _walk($layout) {
			if (!$layout)
				return;
			$layout.$items.forEach(function(item) {
				var tit = {};
				if (item.$title && !uniqTitle[item.$title]) {
					uniqTitle[item.$title] = {};
					tit.value = item.$title;
					tit.title = self.resolveExpression(item.$title);
					title.push(tit);
				}
				_walk(item.$layout);
			});
			return title;
		};
		_walk(this.getDataByPath("$article.$layout"));
		return title;
	},
	getAllX3Title: function() {
		var title = [],
			self = this,
			localization = self.json.$localization || {};
		Object.keys(localization).forEach(function(key) {
			var tit = {};
			tit.value = "{" + key + "}";
			tit.title = localization[key];
			title.push(tit);
		});
		return title.sort(function(a, b) {
			var aTit = a.title.toLowerCase();
			var bTit = b.title.toLowerCase();
			return ((aTit < bTit) ? -1 : ((aTit > bTit) ? 1 : 0));
		});
	}
});
/**
 * To manage a row index in arrays
 */
exports.getRowIdxProto = function() {
	return exports.create({
		$type: "tablet/x-row-index"
	});
};
/**
 * Constructor
 */
exports.create = function(json, parent) {
	return new _Prototype(json, parent);
};
});

define('syracuse-tablet/html/js/authoring/authoringArticleGen',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/articleParser'],function (require, exports, module) {"use strict";

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');

/*
 * Generator for articles of different page types and scrolling models
 *
 */

var _testFacet = /representation=.*\.\$(\w+)[&]*/;
var _getFacet = function($url) {
	var t = _testFacet.exec($url || "");
	return t != null && t.length == 2 ? t[1] : null;
};
exports.genNewArticle = function(opts, synch) {
	var proto;
	proto = opts.page.prototype;

	if (jsutils.isInstanceOf(opts.page, "DashboardPage")) {
		return exports.generateDashboardArticle(proto, opts.orientation, opts.template, synch);
	} else {
		return _generateRegularArticle(proto, opts.orientation, opts.template, synch);
	}
};

exports.generateDashboardArticle = function(proto, orientation, tpl, synch) {

	var article;
	proto = $.isPlainObject(proto) ? proto : proto.json;
	var props = proto.$properties;

	if (orientation === "horizontal") {
		article = {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "",
				"$items": []
			}]
		};

		// Just create root and return if requested
		if (tpl === false) {
			return $.smResolve(article);
		}

		Object.keys(props).forEach(function(key) {
			var prop = props[key];
			article.$items[0].$items.push({
				"$layoutType": "tile",
				"$size": "medium",
				"$items": [{
					"$bind": key,
				}]
			});

		});
	} else {
		article = {
			"$layoutType": "stack",
			"$items": []
		};

		// Just create root and return if requested
		if (tpl === false) {
			return $.smResolve(article);
		}

		var cellCount = 4;
		var row;
		Object.keys(props).forEach(function(key) {
			if (cellCount === 4) {
				cellCount = 0;
				row = {
					"$layoutType": "row",
					"$items": []
				};
				article.$items.push(row);
			}
			var prop = props[key];
			row.$items.push({
				"$layoutType": "cell",
				"$widthXs": 12,
				"$widthSm": 6,
				"$widthMd": 4,
				"$widthLg": 3,
				"$items": [{
					"$bind": key,
				}]
			});
		});
	}
	return synch === true ? article : $.smResolve(article);
};

function _generateRegularArticle(proto, orientation, tpl, synch) {
	proto = $.isPlainObject(proto) ? proto : proto.json;
	if (proto.$type === "application/x-array") {
		proto = proto.$item;
	}
	var props = proto.$properties;
	var $items, prop;
	var forceNoTitle = _getFacet(proto.$url) === "query";
	if (orientation === "horizontal") {
		article = {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "",
				"$items": []
			}]
		};

		// Just create root and return if requested
		if (tpl === false) {
			return $.smResolve(article);
		}

		var groupItems = article.$items[0].$items;
		var maxItemsPerGroup = 4;
		var itemsPerGroup = maxItemsPerGroup;
		var tileItems;
		var singlePropTypes = ["application/x-array", "application/x-document", "image"];
		for (var p in props) {
			prop = props[p];
			if (prop.$isExcluded !== true) {
				if (singlePropTypes.indexOf(prop.$type) > -1) {
					var tile = {
						"$layoutType": "tile",
						"$size": "large",
						"$items": []
					};
					groupItems.push(tile);
					tileItems = tile.$items;
					itemsPerGroup = maxItemsPerGroup;
				} else
				if (itemsPerGroup >= maxItemsPerGroup) {
					itemsPerGroup = 0;
					var tile = {
						"$layoutType": "tile",
						"$size": "large",
						"$items": []
					};
					groupItems.push(tile);
					tileItems = tile.$items;
				}
				itemsPerGroup = itemsPerGroup + 1;
				var a = {
					$bind: p
				};
				if (forceNoTitle) {
					a.$isTitleHidden = forceNoTitle;
				} else {
					a.$labelPosition = "top";
				}
				tileItems.push(a);
			}
		}

	} else {
		var article = {
			$layoutType: "stack",
			$items: []
		};

		// Just create root and return if requested
		if (tpl === false) {
			return $.smResolve(article);
		}
		if (!proto || !proto.$article || !proto.$article.$layout) {
			$items = article.$items;
			for (var p in props) {
				prop = props[p];
				if (prop.$isExcluded !== true) {
					var a = {
						$bind: p
					};
					if (forceNoTitle) {
						a.$isTitleHidden = forceNoTitle;
					}
					$items.push(a);
				}
			}
		} else {
			articleParser.coreLayout2DefaultLayout(proto, article, props);
		}
	}
	return synch === true ? article : $.smResolve(article);
};
});

define('syracuse-tablet/html/js/helpers/dashboardUtils',['require','exports','module','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/authoring/authoringArticleGen'],function (require, exports, module) {"use strict";

var prototype = require('syracuse-tablet/html/js/helpers/prototype');
var authArticleGen = require('syracuse-tablet/html/js/authoring/authoringArticleGen');

/**
 *  Generates proto form dashBoard description
 **/
var _getDashboardProto = function(dash) {
	var proto = {
		$title: dash.$title,
		$description: dash.$description,
		$properties: {},
		$dashboardName: dash.$dashboardName
	};
	var vignetteIds = Object.keys(dash.$vignettes || []);
	for (var i = 0; i < vignetteIds.length; i++) {
		var vignetteId = vignetteIds[i];
		var property = $.extend({}, dash.$vignettes[vignetteId]);
		var gadgetId = property.$uuid;

		property.$gadget = dash.$gadgets[gadgetId];
		if (property.$gadget) {
			property.$gadget = $.extend({}, property.$gadget);
			// Set gadget uuid
			property.$gadget.$uuid = gadgetId;
			// Set vignette uuid
			property.$uuid = vignetteId;
			// Set type - "application/x-string"
			property.$type = "tablet/x-vignette";
			property.$title = property.$gadget.$title;
		} else {
			property.$gadget = {
				$uuid: gadgetId,
				$type: "$gadgetMissing"
			};
			property.$uuid = vignetteId;
			property.$type = "tablet/x-vignette";

		}
		proto.$properties[vignetteId] = property;
	}
	return prototype.create(proto);
};

/**
 * Returns $article from dashBoard info
 * 		Calculates and Sets $article if no $article was found
 */
var _getDashboardArticle = function(proto) {
	return authArticleGen.generateDashboardArticle(proto, "orientation");
};

var _getDashboardInfo = function(dashboardMetaData) {
	return $.smResolve()
		.then(function() {
			var article = dashboardMetaData.$article;
			var proto = _getDashboardProto(dashboardMetaData);
			var views = dashboardMetaData.$views;
			if (!article) {
				return _getDashboardArticle(proto)
					.then(function(article) {
						dashboardMetaData.$article = article;
						return {
							article: $.extend({}, article),
							prototype: proto,
							views: views
						};
					});
			} else {
				return {
					article: $.extend({}, article),
					prototype: proto,
					views: views
				};
			}
		});

};

exports.getDashboardInfo = _getDashboardInfo;
exports.getDashboardArticle = _getDashboardArticle;
exports.getDashboardProto = _getDashboardProto;
});

define('syracuse-tablet/html/js/application/appFactory',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/dashboardUtils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var dashboardUtils = require('syracuse-tablet/html/js/helpers/dashboardUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _ctor = {
	Application: function() {
		throw new Error("Not implemented");
	},
	DashoardPage: function() {
		throw new Error("Not implemented");
	},
	RegularPage: function() {
		throw new Error("Not implemented");
	},
	RequestPage: function() {
		throw new Error("Not implemented");
	},
	RowDetailPage: function() {
		throw new Error("Not implemented");
	},
	ChartDetailPage: function() {
		throw new Error("Not implemented");
	},
	LookupPage: function() {
		throw new Error("Not implemented");
	},
	LoginPage: function() {
		throw new Error("Not implemented");
	},
	DaoApp: function() {
		throw new Error("Not implemented");
	},
	DaoSdata: function() {
		throw new Error("Not implemented");
	},
	DaoSdataWrkcpy: function() {
		throw new Error("Not implemented");
	},
	DraftsPage: function() {
		throw new Error("Not implemented");
	}
};

var _createApplication = function($$elmt) {
	var res = new _ctor.Application($$elmt, exports);
	res.init();
	return res;
};

// $forceLinkArticle is used in test entities to attach a $article to a $link vignette
// -> convenient for unit test
var _createPage = function($parent, state, parentPage, $forceLinkArticle) {
	var res = null;
	var type = state.type;
	var deferred = $.Deferred();
	var options = {};
	try {
		switch (type) {
			case "static":
				if (state.subtype === "html") {
					switch (state.name) {
						case "login":
							res = new _ctor.LoginPage($parent, state, options);
							break;
						case "pageDrafts":
							res = new _ctor.DraftsPage($parent, state, options);
							break;
						default:
							throw new Error("_createPage - unknown html page [" + state.name + "]");
					}
				} else {
					throw new Error("_createPage - unknown static subtype [" + state.subtype + "]");
				}
				break;
			case "dashboard":
				globals.getMetaData().getDashboard(state.dashboardName)
					.then(function(dashboardMetaData) {
						if (!dashboardMetaData) {
							return $.smReject({
								message: locale.text("error.page.not.found", [state.dashboardName])
							});
						}
						return dashboardUtils.getDashboardInfo(dashboardMetaData);
					})
					.then(function(dashboardInfo) {
						options.views = $.extend([], dashboardInfo.views);
						if (state.isWelcomePage === true) {
							res = new _ctor.WelcomeDashoardPage($parent, state, dashboardInfo.prototype, dashboardInfo.article, options);
						} else {
							res = new _ctor.DashoardPage($parent, state, dashboardInfo.prototype, dashboardInfo.article, options);
						}
						deferred.resolve(res);
					})
					.fail(function(e) {
						deferred.reject(e);
					});
				break;
			case "chartdetail":
			case "regular":
			case "rowdetail":
			case "carddesign":
				globals.getMetaData().getPageDetails(state)
					.then(function(info) {
						if (!info) {
							return $.smReject({
								message: locale.text("error.page.not.found", [state.name])
							});
						}
						if (info.prototype.isLookup()) {
							res = new _ctor.LookupPage($parent, state, info.prototype, info.article, options);
						} else if (type === "rowdetail") {
							res = new _ctor.RowDetailPage($parent, state, info.prototype, info.article, parentPage, options);
						} else if (type === "regular") {
							if ($forceLinkArticle) {
								// ONLY FOR TEST ENTITIES - Store article attached to a link in order to magae the back
								state.forceLinkArticle = $forceLinkArticle;
							}
							options.views = $.extend([], info.views);
							if (info.prototype && (info.prototype.isRequest() || info.prototype.isStatistics())) {
								res = new _ctor.RequestPage($parent, state, info.prototype, $forceLinkArticle ? $forceLinkArticle : info.article, options);
							} else {
								res = new _ctor.RegularPage($parent, state, info.prototype, $forceLinkArticle ? $forceLinkArticle : info.article, options);
							}
						} else if (type === "carddesign") {
							res = new _ctor.CardDesignPage($parent, state, info.prototype, info.article, parentPage, options);
						} else if (type === "chartdetail") {
							res = new _ctor.ChartDetailPage($parent, state, info.prototype, info.article, parentPage, options);
						}
						deferred.resolve(res);
					}).fail(function(e) {
						deferred.reject(e);
					});
				break;
			default:
				throw new Error("Unknown page type[" + type + "]");
				break;
		}
		if (res) {
			// Synchronous result
			deferred.resolve(res);
		}
	} catch (e) {
		deferred.reject(e);
	} finally {
		return deferred.promise();
	}
};

var _createDaoApp = function(appli) {
	return new _ctor.DaoApp(appli);
};
/**
 * options: see DaoSdata class
 */
var _createDaoSdata = function(data, prototype, options) {
	options = options || {};
	return new _ctor[options.enableWorkingCopy === true ? "DaoSdataWrkcpy" : "DaoSdata"](data, prototype, options);
};
/**
 * Create the prototype and dao for a row detail page
 * parentDao: 	dao of the row - we clone it beacuse it's another page
 * controller:	controller
 * proto:		prototype of the parent array
 */
var _createDaoRowDetail = function(parentDao, controller, proto) {
	// parentDao is needed to resolve some properties in prototype taht needs parent data (url's of images...)
	return _createDaoSdata($.extend(true, {}, parentDao.data), proto, {
		isRowDetailDao: true,
		enableWorkingCopy: false, // No working copy for DAO - TODO - parentDao.enableWorkingCopy === true,
		parent: parentDao.parent,
		$bind: parentDao.$bind
	});
};

exports.setImpl = function(name, ctor) {
	_ctor[name] = ctor;
};

exports.createApplication = _createApplication;
exports.createPage = _createPage;
exports.createDaoApp = _createDaoApp;
exports.createDaoSdata = _createDaoSdata;
exports.createDaoRowDetail = _createDaoRowDetail;
});

define('syracuse-tablet/html/js/sdata/sdataUtils',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var _rID = /^(.*)\(\'(.*)\'\)$/i;
/**
 * nofail= true	return null if error
 */
var _parseSDataURL = function(url, noFail) {
	var res = jsutils.parseURL(url);
	if (res.query && res.query.representation) {
		res.representation = res.query.representation;
		res.facet = null;
		var p = res.representation.indexOf('.');
		if (p != -1) {
			res.facet = res.representation.substr(p + 1);
			if (res.facet.charAt(0) == '$') res.facet = res.facet.substr(1);
			res.representation = res.representation.substr(0, p);
		}
	}
	var a;
	if (res.directory) {
		var idx = res.directory.indexOf("/$services/");
		if (idx > -1) {
			res.$services = res.directory.substring(idx + 11);
		}
		a = res.directory.split('/');
	}
	if (a == null || a.length <= 4) {
		if (noFail === true) return null;
		throw new Error("Bad sdata url:" + url);
	}
	res.dispatch = a[1];
	if (res.dispatch !== "mobile1" && res.dispatch !== "sdata") {
		if (noFail === true) return null;
		throw new Error("Bad sdata url:" + url);
	}
	res.application = a[2];
	res.contract = a[3];
	res.dataset = a[4];
	if (a.length === 4) return res;
	var match = _rID.exec(a[5]);
	if (match && (match.length == 3)) {
		res.entity = match[1];
		res.id = match[2];
		if (res.id && res.id.trim().Length === 0) res.id = null;
	} else {
		res.entity = a[5];
		res.id = null;
	}
	if (a.length === 5) return res;
	return res;
};

/**
 * Resolve sdataurl and return navigation info to generate the <a>/<button> link
 * nofail= true	return null if error
 */
var _getLinkInfo = function(sDataUrl, dao, nofail) {
	// dao is optional since a link can be a link without dataset (e.g. prev/next)
	sDataUrl = dao ? dao.parseExpression(sDataUrl) : sDataUrl;
	var url = _parseSDataURL(sDataUrl, nofail);
	if (url == null) return null;
	if (url.entity === "$mobileDashboards") {
		var res = {
			page: url.query.dashboard + ".$mobileDashboard"
		};
		if (url.query.parameters) {
			res.parameters = utils.parseExpression(url.query.parameters, dao);
		}
		return res;
	}
	if (url.query.representation) {
		var ep = url.application + "." + url.contract + "." + url.dataset;
		var res = {
			page: ep + (url.query.representation ? "." + url.query.representation : ""),
			sDataUrl: sDataUrl
		};
		if (url.$services) {
			// Mandatory to make the difference between a page link and action link
			res.$services = url.$services;
		}
		return res;
	}
	if (nofail === true) return null;
	throw new Error("getLinkInfo - Unexpected empty representaion in ul " + sDataUrl);
};
/**
 * Returns attributes for link tag
 * 	linkInfo: 	object returned by _getLinkInfo
 * 				or sdataUrl
 * dao:			mandatory if linkInfo is a sdataUrl
 */
var _getLinkAttrs = function(linkInfo, dao) {
	if (typeof linkInfo === "string") {
		// We assume that linkInfo is the url - we need dao
		linkInfo = _getLinkInfo(linkInfo, dao);
	}
	if (linkInfo.type === "navig") {
		return 'data-nav="' + linkInfo.page + '" data-sdata-url="' + encodeURIComponent(linkInfo.sDataUrl) + '"';
	} else if (linkInfo.type === "act") {
		return 'data-action="' + linkInfo.action + '" data-params="' + encodeURIComponent((linkInfo.params || "")) + '"';
	} else {
		throw new Error("_getLinkAttrs - unknonwn type\n" + linkInfo.type);
	}
};
/**
 * SCan diagnoses in a sdata response
 * TODO TEST
 */
var _clearSyracuseStack = function(d) {
	if (d.$stackTrace && d.$stackTrace.indexOf("node_modules\syracuse-x3") >= 0) {
		if (d.$message && d.$stackTrace.indexOf(d.$message) >= 0) {
			// No need of stack
			delete d.$stackTrace;
		} else {
			// Remove stack because too long
			d.$stackTrace = d.$stackTrace.split("\n")[0];
		}
	}
	return d;
};
var _scanDiagnoses = function(data) {
	var result = [];
	var done = [];
	var _scan = function(o, prop, path) {
		if (!path) path = [];
		if (done.indexOf(o) >= 0) return;
		if (Array.isArray(o)) {
			done.push(o);
			if (prop) path.push(prop);
			o.forEach(function(e, idx) {
				_scan(e, idx + "", path);
			});
			if (prop) path.pop(prop);
		} else if ($.isPlainObject(o)) {
			done.push(o);
			for (var p in o) {
				if (p === "$diagnoses") {
					o[p].forEach(function(d) {
						var $path = [].concat(path);
						if (prop) $path.push(prop);
						if (p) $path.push(p);
						d = _clearSyracuseStack($.extend({}, d));
						d.$path = $path.join('.');
						result.push(d);
					});
				} else {
					if (prop) path.push(prop);
					_scan(o[p], p, path);
					if (prop) path.pop(prop);
				}
			}
		}
	};
	if (data != null) _scan(data);
	return result;

};

var _addWhereClause = function(url, where, params) {
	params = params || {};
	var allParamsSet = true;
	where = where.value;
	var res = where.replace(/\{(\w*?)\}/g, function(m, p1) {
		var value = params[p1];
		if (value == null) {
			allParamsSet = false;
		}
		return value != null ? value : "";
	});
	if (allParamsSet) {
		url = url + "&where=" + res;
	}
	return url;
};

exports.parseSDataURL = _parseSDataURL;
exports.getLinkInfo = _getLinkInfo;
exports.getLinkAttrs = _getLinkAttrs;
exports.scanDiagnoses = _scanDiagnoses;
exports.addWhereClause = _addWhereClause;
});

define('syracuse-tablet/html/js/sdata/sdataHttp',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/ajax/ajax','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("sDataHttp");
var ajax = require('syracuse-tablet/html/js/ajax/ajax').getAjax().ajax;
var locale = require('syracuse-tablet/html/js/helpers/locale');

// We force no parsing
var _forceOptions = {
	noJsonParsing: true
};
/* 
 * params : {method, url, send, headers, options, login}
 * optional : send, headers, options, login = {user,password}
 * Return a promise
 * Resolve with result {status, isSuccess, responseText, jsonData, textStatus, descrHttpStatus, headers}
 * Never rejects
 * status = 600 if Java Script exception
 */

var _send = function(params) {
	var deferred = $.Deferred();
	var params = params || {};

	params.options = $.extend(params.options || {}, _forceOptions);
	params.headers = params.headers || {};
	params.headers["Accept-Language"] = locale.getCurrentLocale();

	try {
		log && log("_httpSend - Begin - Method:" + params.method + "\n\t" + params.url);

		ajax(params.method, params.url, params.send, params.headers, params.options)
			.then(function(result) {
				log && log("_httpSend - End - status=" + result.status + " - " + result.textStatus);
				// Try to parse data even if fail status - we can have a $diagnose in response
				if (!result.responseJSON) {
					var responseText = result.responseText ? result.responseText.trim() : "";
					if (responseText.length > 0 && ['{', '['].indexOf(responseText.charAt(0)) >= 0) {
						result.responseJSON = JSON.parse(responseText);
					} else {
						result.responseJSON = null;
					}
				}
				if (result.status === 404) {
					if (!result.responseJSON) {
						result.responseJSON = {};
					}
					if (!result.responseJSON.$diagnoses) {
						result.responseJSON.$diagnoses = [];
					}
					// X3 returns a 'not found' error message with an unreadable stack trace
					result.responseJSON.$diagnoses.unshift({
						$message: locale.text("http404"),
						$stackTrace: params.url,
						$severity: "error"
					});
				}
				deferred.resolve(result);
			}).fail(function(e) {
				deferred.reject(e);
			});
	} catch (e) {
		deferred.reject(e);
	}
	return deferred.promise();
};

exports.send = _send;
});

define('syracuse-tablet/html/js/sdata/sdataCommonResources',['require','exports','module','syracuse-tablet/html/js/sdata/sdataUtils','syracuse-tablet/html/js/sdata/sdataHttp','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ajax/ajax'],function (require, exports, module) {"use strict";

var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var sdataHttp = require('syracuse-tablet/html/js/sdata/sdataHttp');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var ajax = require('syracuse-tablet/html/js/ajax/ajax');

/*
 * This file should be the only file containing direct, non generic access to server side supporting entities/services
 */
var _appListUrl = "/sdata/syracuse/collaboration/syracuse/mobileApplications/$service/availableApplications";
var _localePreferencesUrl = "/sdata/syracuse/collaboration/syracuse/localePreferences?representation=localePreference.$bulk";
var _userProfileUrl = "/sdata/syracuse/collaboration/syracuse/userProfiles/$service/current";
var _userProfileUpdtUrl = "/sdata/syracuse/collaboration/syracuse/userProfiles/$service/updateProfile";
var _userProfileSettingsUrl = "/sdata/syracuse/collaboration/syracuse/userProfiles/$service/settings";
var _createSharedContextUrl = "/requireJS/sharedContext/create";
var _readSharedContextUrl = "/requireJS/sharedContext/read?uuid=";
var _connectionAliveUrl = "/requireJS/misc/connectionAlive";

function _checkResult(result) {
	return result && result.isSuccess && result.responseJSON && !$.isEmptyObject(result.responseJSON);
}

exports.queryAllApplications = function() {
	try {
		var params = {
			method: "GET",
			url: _appListUrl
		};
		params.parsedUrl = sdataUtils.parseSDataURL(params.url);
		return sdataHttp.send(params)
			.then(function(result) {
				if (_checkResult(result)) {
					return result.responseJSON.$resources;
				}
				return ajax.rejectHttpResult(locale.text("err.load.applst"), result, params.url);
			});
	} catch (e) {
		return $.smReject(e);
	}
};

exports.queryApplicationDetail = function(appHeader, endpoint) {
	try {
		var params = {
			method: "GET",
			url: appHeader.$metaDataUrl + "?endpoint=" + endpoint
		};
		params.parsedUrl = sdataUtils.parseSDataURL(params.url);
		return sdataHttp.send(params)
			.then(function(result) {
				if (_checkResult(result)) {
					return result.responseJSON;
				}
				return ajax.rejectHttpResult(locale.text("err.load.appdetail", [appHeader.applicationName]), result, params.url);
			});
	} catch (e) {
		return $.smReject(e);
	}
};
/**
 * noFailIfNoConnection	see _fetchAll
 */
exports.queryLocalePreferences = function(noFailIfNoConnection) {
	return _fetchAll(_localePreferencesUrl, noFailIfNoConnection)
		.then(function(result) {
			var locales = [];
			result.forEach(function(locale) {
				locales.push({
					"$uuid": locale.$uuid,
					"code": locale.code,
					"description": locale.description
				});
			});
			return locales;
		});
};
exports.getUserProfile = function() {
	try {
		var params = {
			method: "GET",
			url: _userProfileUrl
		};
		params.parsedUrl = sdataUtils.parseSDataURL(params.url);
		return sdataHttp.send(params)
			.then(function(result) {
				if (_checkResult(result)) {
					return result.responseJSON;
				}
				return ajax.rejectHttpResult(locale.text("err.load.profile"), result, params.url);
			});
	} catch (e) {
		return $.smReject(e);
	}
};
exports.updateUserProfile = function(changes) {
	try {
		var params = {
			method: "POST",
			url: _userProfileUpdtUrl,
			send: changes
		};
		params.parsedUrl = sdataUtils.parseSDataURL(params.url);
		return sdataHttp.send(params)
			.then(function(result) {
				if (_checkResult(result)) {
					return result.responseJSON;
				}
				return ajax.rejectHttpResult("Error updating profile", result, params.url);
			});
	} catch (e) {
		return $.smReject(e);
	}
};
exports.getUserProfileSettings = function() {
	try {
		var params = {
			method: "GET",
			url: _userProfileSettingsUrl
		};
		params.parsedUrl = sdataUtils.parseSDataURL(params.url);
		return sdataHttp.send(params)
			.then(function(result) {
				if (_checkResult(result)) {
					result = result.responseJSON;
					// Check settings just in case - Checking is done on Syracuse side
					var err = [];
					if (result.roles.length < 1) {
						err.push("unexpected empty roles list");
					}
					if (result.locales.length < 1) {
						err.push(locale.text("unexpected empty languages list"));
					}
					if (err.length == 0) {
						return result;
					}
					err.push(locale.text("contact.admin"));
					return $.smReject({
						$redirectPage: "login",
						$title: "Bad user configuration",
						$diagnoses: [{
							$message: err.join('\n')
						}]
					});
				}
				return ajax.rejectHttpResult("Error reading profile settings", result, params.url);
			});
	} catch (e) {
		return $.smReject(e);
	}
};

/**
 * noFailIfNoConnection	true to resolve with an empty list if httpstatus 0 (no network connection)
 * if noFailIfNoConnection == true and a network connection occurred -> Resolve with [] and true
 */
function _fetchAll(urlQuery, noFailIfNoConnection) {
	var deferred = $.Deferred();
	var list = [];

	function _fetchPage(url) {
		var params = {
			method: "GET",
			url: url
		};

		params.parsedUrl = sdataUtils.parseSDataURL(params.url);
		sdataHttp.send(params)
			.then(function(result) {
				var data = result && result.responseJSON;
				if (data && data.$noConnectionError === true && noFailIfNoConnection === true) {
					deferred.resolve([], true);
					return;
				}
				if (result && result.status !== 200) {
					var message;
					if (result.status === 401) {
						message = locale.text("error.session.timeout");
					} else if (data && data.$diagnoses && data.$diagnoses.length > 0) {
						message = data.$diagnoses[0].$message;
					} else {
						message = locale.text("fetchurl.error", [params.parsedUrl.contract + "/" + params.parsedUrl.entity, result.status]);
					}
					deferred.reject({
						$message: message,
						$redirectPage: "login"
					});
				}
				data && data.$resources && data.$resources.forEach(function(i) {
					list.push(i);
				});
				if (data && data.$links && data.$links.$next && data.$links.$next.$url) {
					// Scan all resources
					_fetchPage(data.$links.$next.$url);
				} else {
					// Resolve in no $links 
					deferred.resolve(list, false);
				}
			})
			.fail(function(e) {
				deferred.reject(e);
			});
	}

	_fetchPage(urlQuery);
	return deferred.promise();
}
// lifespan in days
exports.createSharedContext = function(linkCtx, lifespan) {
	// convert to hours
	lifespan = (lifespan == undefined ? 3 : lifespan) * 24;
	var params = {
		method: "POST",
		url: _createSharedContextUrl,
		send: {
			lifespan: lifespan,
			linkCtx: linkCtx
		}
	};
	return sdataHttp.send(params).then(function(result) {
		if (result.isSuccess && result.responseJSON && result.responseJSON.$uuid) {
			return result.responseJSON.$uuid;
		}
		return null;
	});
};
exports.readSharedContext = function(uuid) {
	// convert to hours
	if (!uuid) {
		// Null uuid accepted
		$.smResolve(null);
	}
	var params = {
		method: "get",
		url: _readSharedContextUrl + uuid
	};
	return sdataHttp.send(params).then(function(result) {
		var context = result.isSuccess ? result.responseJSON : null;
		if (!context || !context.endpoint || !context.currentState || !context.applicationName) {
			if (globals.getModal()) {
				globals.getModal().notify(locale.text("urlcontext.bad"), locale.text("urlcontext.cantopen"));
			}
			console.log("Bad url context", "Can't open the page", JSON.stringify(context, null, 2));
			return null;
		}
		return context;
	}).fail(function(e) {
		console.log("readSharedContext error", e.message);
		return null;
	});
};

exports.isConnectionAlive = function() {
	return sdataHttp.send({
		method: "get",
		url: _connectionAliveUrl
	}).then(function(result) {
		return result && result.isSuccess;
	}).fail(function(e) {
		return false;
	});
};
});

define('syracuse-tablet/html/js/helpers/base64',['require','exports','module'],function (require, exports, module) {"use strict";

/**
 *
 *  Base64 encode / decode
 *  http://www.webtoolkit.info/
 *
 **/

var Base64 = exports.Base64 = {

	// private property
	_keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

	// public method for encoding
	encode: function(input) {
		var output = "";
		var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
		var i = 0;

		input = Base64._utf8_encode(input);

		while (i < input.length) {

			chr1 = input.charCodeAt(i++);
			chr2 = input.charCodeAt(i++);
			chr3 = input.charCodeAt(i++);

			enc1 = chr1 >> 2;
			enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
			enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
			enc4 = chr3 & 63;

			if (isNaN(chr2)) {
				enc3 = enc4 = 64;
			} else if (isNaN(chr3)) {
				enc4 = 64;
			}

			output = output + this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) + this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);

		}

		return output;
	},

	// public method for decoding
	decode: function(input) {
		var output = "";
		var chr1, chr2, chr3;
		var enc1, enc2, enc3, enc4;
		var i = 0;

		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

		while (i < input.length) {

			enc1 = this._keyStr.indexOf(input.charAt(i++));
			enc2 = this._keyStr.indexOf(input.charAt(i++));
			enc3 = this._keyStr.indexOf(input.charAt(i++));
			enc4 = this._keyStr.indexOf(input.charAt(i++));

			chr1 = (enc1 << 2) | (enc2 >> 4);
			chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
			chr3 = ((enc3 & 3) << 6) | enc4;

			output = output + String.fromCharCode(chr1);

			if (enc3 != 64) {
				output = output + String.fromCharCode(chr2);
			}
			if (enc4 != 64) {
				output = output + String.fromCharCode(chr3);
			}

		}

		output = Base64._utf8_decode(output);

		return output;

	},

	// private method for UTF-8 encoding
	_utf8_encode: function(string) {
		string = string.replace(/\r\n/g, "\n");
		var utftext = "";

		for (var n = 0; n < string.length; n++) {

			var c = string.charCodeAt(n);

			if (c < 128) {
				utftext += String.fromCharCode(c);
			} else if ((c > 127) && (c < 2048)) {
				utftext += String.fromCharCode((c >> 6) | 192);
				utftext += String.fromCharCode((c & 63) | 128);
			} else {
				utftext += String.fromCharCode((c >> 12) | 224);
				utftext += String.fromCharCode(((c >> 6) & 63) | 128);
				utftext += String.fromCharCode((c & 63) | 128);
			}

		}

		return utftext;
	},

	// private method for UTF-8 decoding
	_utf8_decode: function(utftext) {
		var string = "";
		var i = 0;
		var c1, c2, c3;
		var c = c1 = c2 = 0;

		while (i < utftext.length) {

			c = utftext.charCodeAt(i);

			if (c < 128) {
				string += String.fromCharCode(c);
				i++;
			} else if ((c > 191) && (c < 224)) {
				c2 = utftext.charCodeAt(i + 1);
				string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
				i += 2;
			} else {
				c2 = utftext.charCodeAt(i + 1);
				c3 = utftext.charCodeAt(i + 2);
				string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
				i += 3;
			}

		}

		return string;
	},

	// public method for decoding
	raw_decode: function(input) {
		var output = "";
		var chr1, chr2, chr3;
		var enc1, enc2, enc3, enc4;
		var i = 0;

		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

		while (i < input.length) {

			enc1 = this._keyStr.indexOf(input.charAt(i++));
			enc2 = this._keyStr.indexOf(input.charAt(i++));
			enc3 = this._keyStr.indexOf(input.charAt(i++));
			enc4 = this._keyStr.indexOf(input.charAt(i++));

			chr1 = (enc1 << 2) | (enc2 >> 4);
			chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
			chr3 = ((enc3 & 3) << 6) | enc4;

			output = output + String.fromCharCode(chr1);

			if (enc3 != 64) {
				output = output + String.fromCharCode(chr2);
			}
			if (enc4 != 64) {
				output = output + String.fromCharCode(chr3);
			}

		}

		//		output = Base64._utf8_decode(output);

		return output;

	}
};

exports.encode = function(text) {
	return Base64.encode(text);
};
});

define('syracuse-tablet/html/js/application/authentication',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ajax/ajax','syracuse-tablet/html/js/sdata/sdataCommonResources','syracuse-tablet/html/js/helpers/base64','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("app");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var ajaxLib = require('syracuse-tablet/html/js/ajax/ajax');
var ajax = ajaxLib.getAjax().ajax;
var sdataCommonRes = require('syracuse-tablet/html/js/sdata/sdataCommonResources');
var base64 = require('syracuse-tablet/html/js/helpers/base64');
var locale = null; // On demand

var _getText = function(id) {
	if (!locale) {
		locale = require('syracuse-tablet/html/js/helpers/locale');
	}
	return locale.text(id);
};
/**
 * Login services are temporarily implemented in requireJSDispatcher._js
 * - tabletCheckLogin
 * 		Return 403 if login failed because 401 forces the browser to display the authentication dialog
 * - tabletDoLogin
 *      Return user's profile if OK
 */
var _config = {
	svcLogin: "/auth/login/submit",
	svcLogout: "/logout",
	svcForgetMe: "/auth/forgetMe/submit",
	userProfile: "/sdata/syracuse/collaboration/syracuse/userProfiles/$service/current",
	svcReconnectGetToken: "/requireJS/reconnect/getToken",
	svcReconnectSetToken: "/requireJS/reconnect/setToken",
	svcAvailableAuth: "/requireJS/misc/availableAuth"
};
/**
 * True if user is logged in
 * Resolves with user profile or null if 401 authentication error ONLY
 * Reject if other errors
 */
var _check = function() {
	return ajax("GET", _config.userProfile, null, null, {
		dontCatchHttp401: true
	}).then(function(result) {
		if (result && result.status === 200 && result.responseJSON) {
			return result.responseJSON;
		} else if (result && result.status === 401) {
			return null;
		} else {
			// No local resources here - unexpected error
			return ajaxLib.rejectHttpResult("Check authentication failed", result);
		}
	});
};
var _getLoginHeader = function(user, password) {
	return {
		"Authorization": 'Basic ' + base64.encode(user + ":" + password),
		"accept": "application/json"
	};
};
var _getLoginData = function(rememberMe) {
	/** To force the server to take into account a new credentials - see SAM 112730
	 */
	var data = {
		forgetme: true
	};
	if (rememberMe === true) {
		// Enable remember me one credentials s have been validated
		data["keepConnected"] = true;
	}
	return data;
};
/**
 * Resolve with user's profile and reconnect token
 * Reject with error and offlineMode true/false
 **/
var _login = function(user, password, rememberMe) {
	var deferred = $.Deferred();
	ajax("POST", _config.svcLogin, _getLoginData(rememberMe), _getLoginHeader(user, password), {
		dontCatchHttp401: true
	}).then(function(result) {
		if (result.status === 0) {
			deferred.reject(_getText("no.connection"), true);
		}
		if (result.status !== 200) {
			var e = result.responseJSON && result.responseJSON.$diagnoses && result.responseJSON.$diagnoses.length > 0 ? result.responseJSON : "Httpstatus: " + result.status;
			deferred.reject(e);
		}
		sdataCommonRes.getUserProfile().then(function(profile) {
			if (profile) {
				deferred.resolve(profile);
			} else {
				deferred.reject("Unexpected null user profile");
			}
		}).fail(function(e) {
			deferred.reject(e);
		});
	}).fail(function(e) {
		deferred.reject(e);
	});
	return deferred.promise();
};
/**
 * Disable automatic login
 */
var _forgetme = function() {
	var deferred = $.Deferred();
	ajax("POST", globals.baseLocation().host + _config.svcForgetMe, {
		forgetme: true
	}).then(function(result) {
		log && log("_forgetme succeeded");
		deferred.resolve(true);
	});
	return deferred.promise();
};
/**
 * Logout
 */
var _logout = function() {
	var deferred = $.Deferred();
	ajax("POST", globals.baseLocation().host + _config.svcLogout).then(function(result) {
		var msg;
		// There's a bug in Syracuse sessionmanager which returns sometimes 401 on logout - Aurelien is aware
		// We consider that logout is ok and do not display a message
		var isSuccess = result.isSuccess || result.status === 401 || result.status === 0;
		if (!isSuccess) {
			msg = "Httpstatus: " + result.status;
			var diag = result.responseJSON ? result.responseJSON.$diagnoses : null;
			if (diag) {
				diag.forEach(function(d) {
					msg += "\n" + d.$message;
				});
			}
		}
		deferred.resolve(isSuccess, msg);
	});
	return deferred.promise();
};
/**
 * Same code as server one
 * Extract the login from the cookie
 */
var _parseReconnectCookie = function(cookie) {
	if (!cookie) return null;
	cookie = cookie.split("/");
	if (cookie.length < 3) return null;
	var token = cookie.pop();
	var series = cookie.pop();
	var login = cookie.join("/");
	return login;
};
/**
 * Resolve with a reconnect token used by _reconnectSetToken
 */
var _reconnectGetToken = function() {
	var deferred = new $.Deferred();
	ajax("GET", _config.svcReconnectGetToken, null, {
		"accept": "application/json"
	}).always(function(result) {
		if (result && result.status === 200 && result.headers) {
			var token = result.headers["x-reconnect-token"];
			log && log("_reconnectGetToken", token);
			var login = _parseReconnectCookie(token);
			deferred.resolve(login ? token : null, login);
		} else {
			deferred.resolve(null);
		}
	});
	return deferred.promise();
};
/**
 * Call a service that set the session cookie contained in reconnectToken
 */
var _reconnectSetToken = function(reconnectToken) {
	var deferred = new $.Deferred();
	ajax("GET", _config.svcReconnectSetToken, null, {
		"accept": "application/json",
		"x-reconnect-token": reconnectToken || ""
	}).then(function(result) {
		log && log("_reconnectSetToken succeeded", reconnectToken);
		deferred.resolve();
	}).fail(function(result) {
		log && log("_reconnectSetToken failed");
		deferred.resolve();
	});
	return deferred.promise();
};

var _availableAuthentications = null;
var _checkAvailableAuthentications = function() {
	var deferred = new $.Deferred();
	ajax("GET", _config.svcAvailableAuth, null, {
		"accept": "application/json"
	}).then(function(result) {
		_availableAuthentications = result.isSuccess && result.responseJSON ? result.responseJSON : null;
		log && log("_availableAuthentications succeeded", JSON.stringify(_availableAuthentications, null, 2));
		deferred.resolve(_availableAuthentications);
	}).fail(function(result) {
		log && log("_availableAuthentications failed");
		deferred.resolve(null);
	});
	return deferred.promise();
};
/*
 * Sage ID signin
 */
var _sageidsigin = function() {
	window.location.href = "/auth/sage-id/signOnStart";
};

exports.check = _check;
exports.login = _login;
exports.forgetme = _forgetme;
exports.logout = _logout;
exports.reconnectGetToken = _reconnectGetToken;
exports.reconnectSetToken = _reconnectSetToken;
exports.sageidsignin = _sageidsigin;
exports.checkAvailableAuthentications = _checkAvailableAuthentications;
// Eg: sage-id
exports.isAuthenticationAvail = function(auth) {
	return _availableAuthentications != null && _availableAuthentications[auth] === true;
};
});

define('syracuse-tablet/html/js/ui/feedback',['require','exports','module'],function (require, exports, module) {"use strict";

var _highlightTO = 200;

/*
 * Called by event listener when the event listener registeres it's own events
 * This is ment to add UI only events to give visual feedback without triggering any actions
 */
exports.bindActions = function($$elmt) {
	$$elmt.on("mousedown", ":not(select)[data-nav], :not(select)[data-nav-refresh], :not(select)[data-action]", _armMouseDown);
	$$elmt.on("mouseup", _armMouseUp);
};

/*
 * Called by event listener when he recognized the user clicked an element starting an action
 * This is ment to highligth the element for a very short time and the continue the work of the
 * event listener
 * Note that setting a too high timeout here will delay the execution of the user action which
 * makes the app feel slow!
 */
exports.highlight = function($$elmt, cb) {
	if (_highlightTO <= 0) {
		cb();
		return;
	}

	$$elmt.addClass("s-m-highlighted");
	setTimeout(function() {
		$$elmt.removeClass("s-m-highlighted");
		cb();
	}, _highlightTO);
};

var _armedItems = [];

// This function is ment to affect parent elements of the one the action has been triggered for
// E.g. instead of only affecting the link in a tile, the tile can be determined and affected
//
// return: null - do not affect any element
// return: array - affect returned array elements
function _armFindRelated($$elmt) {
	if ($$elmt.hasClass("s-m-link-page")) { // vignette containing a link only
		var $$parent = $$elmt.closest(".s-m-tile"); // If the link is in a tile, better "arm" the tile
		if ($$parent && $$parent.length > 0) {
			return [$$parent];
		}
	}
	return [$$elmt];
}

// Called on ever mouse down to arm the elements the pointer is on
function _armMouseDown(evt) {
	var $$target = $(evt.target);
	var $$actionElmt = $$target.closest("[data-nav], [data-nav-refresh], [data-action]");
	if ($$actionElmt.length > 0) {
		var rels = _armFindRelated($$actionElmt);
		if (rels && rels.length > 0) {
			var i;
			for (i = 0; i < rels.length; i++) {
				rels[i].addClass("s-m-armed");
			}
			Array.prototype.push.apply(_armedItems, rels);
		}
	}
}
// Called on ever mouse up to remove previous "armed" states
function _armMouseUp(evt) {
	var i;
	for (i = 0; i < _armedItems.length; i++) {
		_armedItems[i].removeClass("s-m-armed");
	}
	_armedItems = [];
}
});

define('syracuse-tablet/html/js/application/eventListener',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/ui/feedback'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("evts");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var feedback = require('syracuse-tablet/html/js/ui/feedback');
// var serverLog = require('syracuse-tablet/html/js/helpers/serverLog');
var _lastClick = null;

var _executeLink = function(handler, $$actionElmt) {
	if (_lastClick != null && ((new Date()).getTime() - _lastClick) < 500) {
		// it seems that it fixes the issue #7824  (double click)
		if (arguments[6]) {
			arguments[6].stopPropagation();
			arguments[6].preventDefault();
		}
		return;
	} else {
		_lastClick = (new Date()).getTime();
	}
	if (arguments.length < 2) return;
	var args = Array.prototype.splice.call(arguments, 2);
	if ($$actionElmt) {
		feedback.highlight($$actionElmt, function() {
			handler.apply(null, args);
		});
	} else {
		return handler.apply(null, args);
	}
};

/**
 * Returns id of parent array
 */
var _findParentCtrlId = function($$target, selector) {
	// Find a control array with an ID
	var p = $$target.closest(".s-m-control" + (selector || "") + "[id]");
	return p.length > 0 ? _attr(p, "id") : null;
};
/**
 * Returns attribute, decode and parse if it's a json
 */
var _attr = function($$e, name, nullIfEmpty, decode) {
	var a = $$e.attr(name);
	if (a == null) {
		a = "";
	} else if (typeof a !== "string") {
		a = new String(a);
	}
	a = a.trim();
	if (decode === true) {
		a = decodeURIComponent(a);
		if (a.smStartsWith('{') && a.smEndsWith('}')) {
			// We allow serialized JSON objects in attributes
			try {
				var json = JSON.parse(a);
				return json;
			} catch (e) {
				log.console("Error reading JSON attribute " + name + "\n\t" + a);
			}
		}
	}
	return nullIfEmpty && a.length === 0 ? null : a;
};
/**
 * Parse code=abc&value=cde to
 * {
 * code: "abc",
 * value: "cde"
 * }
 */
var _parseParameters = function(params) {
	var p = params.split("&");
	var res = {};
	for (var i = 0; i < p.length; i++) {
		var v = p[i].split("=");
		res[v[0]] = v[1];
	}
	return res;
};

var _findControlById = function(app, ctrlId, $$target) {
	if (!app.currentPage) throw new Error("No current page");
	var ctrl = app.currentPage.getControl(ctrlId);
	if (ctrl) return ctrl;
	/**
	 * data-controller-id is generated by controller base class to allow to retreive a control
	 * Controller is not only a page and we must be able to retrieve it
	 */
	var controller = $$target.closest("[data-controller-id]");
	if (controller.length === 0) {
		controller = $("#" + ctrlId).closest("[data-controller-id]");
	}
	if (controller.length > 0) {
		var id = controller.attr("data-controller-id");
		controller = globals.getController(id);
		if (controller) {
			ctrl = controller.getStructElmt(ctrlId);
		}
	}
	if (ctrl) return ctrl;
	//!! FDB - Do not remove this error - If this error occurs that means that there is something wrong somewhere
	// This error allows us to improve the application model and events management
	//Removing this error won't fix the issue - Eg:  issue #7426 see app.isLoading() 
	throw new Error("Control not found - ctrlid[" + ctrlId + "]");
};
/**
 * Calls an action given by data-action
 * params a string or a JSON object
 * if parans is a string and contains ',' separator params is split the callBack is called with as many parameters as split elements
 * $$target can be NULL
 * !!!! FDB do not stoppropagation - see below
 */
var _doAction = function($$target, act, params, controlId, evt) {
	var app = globals.getApplication();
	var _fail = function(e) {
		var title = locale.text("actions.error");
		e = e || {};
		e.stack = e.stack ? e.stack + "\n---\n" : "";
		e.stack = e.stack + "Action: " + act + "\nControl: " + (controlId || "?");
		modal.error(title, e);
	};
	try {
		var method = "_act" + $.camelCase("-" + act);
		var object;
		if ($$target) {
			if (!controlId) {
				// look for the first parent array if any
				// data-action in a row should invoke the method on array control
				controlId = _findParentCtrlId($$target, ".s-m-array");
			}
			if (controlId) {
				if (app.isLoadingPage()) {
					evt.stopPropagation();
					evt.preventDefault();
					return;
				}
				// Find control in current page and vignettes if dashboard
				object = _findControlById(app, controlId, $$target);
			} else {
				// Find if it's an action off a vignette (contains a page)
				var vignette = utils.findParentVignette($$target, false);
				if (vignette) {
					if (vignette[method]) {
						object = vignette;
					} else {
						var p = vignette.getPage();
						if (p && p[method]) object = p;
					}
				}
			}
		}
		// Find if it's a current page action
		if (object == null && app.currentPage[method]) object = app.currentPage;
		// Find if it's a global action
		if (object == null) object = app;
		if (!object[method]) throw new Error("Method [" + method + "] not found in object/application/current page)");
		var args = [];
		if (params && typeof params === "string") {
			// Create a array of parameters ( ','  as separator
			// Remove leading/trailing spaces
			params = params.split(',');
			params.forEach(function(p, idx) {
				args.push(p.trim());
			});
		} else {
			args.push(params);
		}
		// Add $target at the end
		args.push($$target);
		// Add event - In case the caller wants to stop propagation - caller responsibility
		args.push(evt);
		$.smResolve(function() {
			return object[method].apply(object, args);
		}).then(function(todo) {
			// Not used
			if (!todo || !todo.page) return;
			globals.getApplication().changePage(todo.page);
		}).fail(function(e) {
			_fail(e);
		});
	} catch (e) {
		_fail(e);
	}
};
/** NAVIGATION 
 * clickedElmt:	jQuery element or JSON object that provides attr() method
 * app			global application
 * $$target		$$target event for click in page
 * 				Element from which we searcg for the vignette if any
 * !!!! FDB do not stoppropagation - see below
 *
 */
var _doNavigation = function(clickedElmt, $$target) {
	var app = globals.getApplication();
	var options = {}, attr;
	attr = _attr(clickedElmt, "data-external-link");
	if (attr.length > 0) {
		window.open(attr, "s-m-external-window");
		return;
	}
	// Page to open
	attr = _attr(clickedElmt, "data-sdata-url");
	if (attr.length > 0) {
		// !! do not call decode URI because we must keep query parameters encoded
		options["sdata-url"] = attr;
	}
	attr = _attr(clickedElmt, "data-sdata-method");
	if (attr.length > 0) {
		options["sdata-method"] = attr;
	}
	// Link type : pagination...
	attr = _attr(clickedElmt, "data-nav-type");
	if (attr.length > 0) {
		options["type"] = attr;
	}
	// Id of parent page
	attr = _attr(clickedElmt, "data-parent-id");
	if (attr.length > 0) {
		options["parentId"] = attr;
	}
	// Control that rated the link - used by refresh and action on child pages like lookup
	attr = _attr(clickedElmt, "data-control-id");
	if (attr.length > 0) {
		options["controlId"] = attr;
	}
	// Initial Control that rated the link - used by dilldown authoring
	attr = _attr(clickedElmt, "data-origin-id");
	if (attr.length > 0) {
		options["controlOriginId"] = attr;
	}
	// Parameters are passed in page options - data navigation accepts Stringify JSON
	attr = _attr(clickedElmt, "data-params", false, true);
	// If attribute starts with { and ends with } it is parsed
	options["dataParams"] = attr || "";

	// Target - vignette -> Change/Refresh the page in the vignette - null or "application" Change/Refresh  application currentpage
	attr = _attr(clickedElmt, "data-nav-target");
	var navTarget;
	if ($$target) {
		if (attr === "vignette") {
			// data-nav-target allows to specify the target for navigation link - Ex pagination
			navTarget = utils.findParentVignette($$target, true);
		} else if (attr !== "application" && app.$config("openLinkInVignette")) {
			// Navigation in vignette - Just a  try but it works - Vignette display back/home icon in icon bar
			navTarget = utils.findParentVignette($$target, false);
		}

	}
	// default navigation is done at application level
	if (!navTarget) {
		navTarget = app;
	}

	// Page refresh instead of opening a new page
	var refreshPage = _attr(clickedElmt, "data-nav-refresh");
	if (refreshPage === "true") {
		// options.controlId points Control to refresh if any
		navTarget.refreshPage(options);
		return;
	}
	attr = _attr(clickedElmt, "data-application-name");
	var applicatioName;
	if (attr.length > 0) {
		applicatioName = attr;
	}

	var pageName;
	attr = _attr(clickedElmt, "data-nav");
	if (attr.length > 0) {
		pageName = attr;
	}

	if (applicatioName) {
		options["applicationName"] = applicatioName;
	}

	// Gadget - Page opener
	attr = _attr(clickedElmt, "data-gadget-id");
	if (attr.length > 0) {
		options["gadget-id"] = attr;
	}

	// Used to put a $article in a $link vignette - test entities
	attr = _attr(clickedElmt, "data-link-article");
	if (attr.length > 0) {
		options["linkArticle"] = attr;
	}
	// Used to filter gadgets in dashboard pages
	attr = _attr(clickedElmt, "data-sdata-parameters");
	if (attr && attr.length > 0) {
		options["sdataParameters"] = _parseParameters(attr);
	}

	// history.back not allowed - TODO See how to pass options	JSON in params ?	
	attr = _attr(clickedElmt, "data-nav-noback");
	options["noHistoryBack"] = attr === "true";

	navTarget.changePage(pageName, options);
};

/** 
 * Bind actions declared by data-nav or data-action/data-params attributes to an object
 *      for navigation data-nav  contains the name of the targeted page
 * 		for action method name is : _actActionName with ActionName the name of action declared in data-action attribute
 * object	: object that processes the actions
 * 				Check current page and application if method not found in object
 * 				if data-control-id attribute call control's action on current page
 * $$elmt 	: optional if object.$$elmt - element to bind event
 * selector : optional
 * 		Default selector is "[data-nav], [data-action]"
 *
 * !!!! FDB - About stopPropagations !!!
 * Like data-action can be used inside a bootstrap componant (ex dropdown) we need to propagate the event (no stopPropagations)
 * For dropdown it allows BS to close the opup window
 * I removed the stopPropagation in _bindActions
 * If we need to add it we will have to add a param in html that tells _bindActions to stop or not event propagation
 *
 */
var _handleActionEvt = function(evt, app) {
	var _fail = function(e) {
		var title = "_bindActions error";
		log && log(title, e);
		modal.error(title, e);
	};
	try {
		if (app.hasModalOpen()) {
			// If we have a modal in front of a page with a default button and if we press enter to close the dialog we trigger default action of the page
			// This test block the action - TODO improve
			log && log("!!! Tries to execute an action data-action with a MODAL open.\nAction is skipped");
			return;
		}
		var $$target = $(evt.target);
		// data-nav opens a page - data-application-name opens an application - data-external-link opens anexternal link - data-nav-refresh refreshes the page
		var $$actionElmt = $$target.closest("[data-action], [data-nav], [data-nav-refresh], [data-application-name], [data-external-link]");
		if ($$actionElmt.length === 0 || $$actionElmt.attr("data-disabled") != null || $$actionElmt.is(".disabled")) {
			return;
		}
		if ($$actionElmt.is("[data-action]")) {
			// ACTION
			var param;
			var act = _attr($$actionElmt, "data-action");
			if ($$actionElmt.is("select")) {
				param = $(this).val();
			} else {
				// Actions on arrays rows
				if (act === globals.ACTROWDETAIL || act === globals.ACTROWDEL || act === globals.ACTROWSEL || act === globals.ACTCARDDESIGN) {
					// We search the record of a the line that contains the row id indata-params attribute
					// We just have one elmt tha stores the rowId
					$$actionElmt = $$actionElmt.closest("." + globals.RECORDCLASS);
				}
				// data action parameters
				// if attr starts with { and ends with } it is parsed
				// if there's a ',' separator parameters are splited and become action arguments
				param = _attr($$actionElmt, "data-params", false, true);
			}
			var controlId = _attr($$actionElmt, "data-control-id", true);
			_executeLink(_doAction, $$actionElmt, $$target, act, param, controlId, evt);
		} else {
			// NAVIGATION
			_executeLink(_doNavigation, $$actionElmt, $$actionElmt, $$target);
			// evt.stopPropagation();has been removed and tested (#5359)
			// #5359 works fine without stopPropagation - Ex: click on an item of right panel - There's a click listener on the panel to close it - if no stopPropagation click on panel is triggered 
			// We need to propagate the event for bootstrap components - Eg: we click on pageDrafts menu when we are on this page - the menu doesn't close if event is not propagated
		}
	} catch (e) {
		_fail(e);
	}
};
var _bindActions = function(app) {
	// Action are bound to application $$elmt and dispatcched to current page or control
	if (!app.$$elmt) throw new Error("_bindActions - null $$elmt");
	var handler = jsutils.bindFn(_handleActionEvt, null, app);
	// No click event on select - only change
	app.$$elmt.on("click", ":not(select)[data-nav], :not(select)[data-nav-refresh], :not(select)[data-action], :not(select)[data-application-name], :not(select)[data-external-link]", handler);
	feedback.bindActions(app.$$elmt);

	// For select tag
	app.$$elmt.on("change", "select[data-nav], select[data-nav-refresh], select[data-action]", handler);
};

/**
 * Add event handlers for controls
 * 		put a ctrl-evt- + evtName in the class attribute of the dom element you want to enable
 * 		handler will call ctrl.onEventName (onClick, onBlur...)
 * !!!! FDB do not stoppropagation - see above
 */
var _bindControlEvents = function(app) {
	var _fail = function(e) {
		var title = "_bindControlEvents error";
		log && log(title, e);
		modal.error(title, e);
	};
	var events = ["click", "blur", "change", "focus", "input"];
	// Use forEach instead of for(var i =...) to preserve evtname closure context otherwise evtname has always the last value
	events.forEach(function(evtname) {
		app.$$elmt.on(evtname, ".ctrl-evt-" + evtname, function(event) {
			//TODO - ee if we could remove stopPropagation like in _bindAtion
			event.preventDefault();
			event.stopPropagation();
			try {
				var $$target = $(event.target);
				var ctrlId;
				if ($$target.hasClass("s-m-control")) {
					ctrlId = _attr($$target, "id");
				} else {
					// We can force control-id if it's not a parent of $$target
					ctrlId = _attr($$target, "data-control-id", true);
					if (!ctrlId) {
						// We search for the first control parent with an ID
						// Controls in arrays don't have an id - So click on a card/row will return the array control
						ctrlId = _findParentCtrlId($$target);
					}
				}
				if (app.isLoadingPage()) {
					event.stopPropagation();
					event.preventDefault();
					return;
				}
				var ctrl = _findControlById(app, ctrlId, $$target);
				var method = "on" + evtname.smCapitalize();
				var controllerListener = ctrl.controller ? ctrl.controller.getEventListener(evtname) : null;
				if (controllerListener && controllerListener("before", ctrl, $$target, event) === true) {
					// Skip control
					return;
				}
				if (!ctrl[method]) {
					log && log("!!! Method[" + method + "] not found - ctrlid[" + ctrlId + "]");
					return;
				}
				ctrl[method](event);
				controllerListener && controllerListener("after", ctrl, $$target, event);
			} catch (e) {
				_fail(e);
			}
			return;
		});
	});
};

/**
 * Application event listener
 */
var _bindEvents = function(app) {

	$(window).bind("popstate", function(event) {
		var state = event.originalEvent.state;
		// We've to check state to not call historyPop on click on href="#"
		// FIREFOX
		//		Previous fix #8072 - old code was  if (state || /Firefox/.test(navigator.userAgent)) {app.historyPop}
		//			FF was trigering only one event with null state on back
		//	    After fix #8072
		//			Now FF seems to trigger only one event with state != null except when we open the mobile client from another tab with window.open (like does the desktop)
		//			If the client is opened with window.open, the first click in the breadcrum or first back generates popstate with null state  (??)
		//			So the code below fixes this bug and works for all browsers FF
		// CHROME
		// 		When we click back 2 events are triggered (one with state == null that we skip)
		// IE
		// 		When we click back one event is triggered with state != null like FF
		if (state) {
			app.historyPop(event);
		}
	});
	// Bind action/navigation call to click/select/change 
	_bindActions(app);
	// Bind control events
	_bindControlEvents(app);
	// triggered by browser window size oand orientation change for desktop
	$(window).on("resize", globals.getSiteLayout().onWindowResize);
	if (globals.isMobile()) {
		// JQuery mobile helpers that provides Orientationchanged better than we can do
		$.event.special.orientationchange.setup();
		$(window).on("orientationchange", globals.getSiteLayout().onWindowOrientation);
	}
	// Resize triggered internally
	$(window).on("resizeInternal", globals.getSiteLayout().onWindowResizeInteral);
	// Page reload
	$(window).on("unload", app.onUnload.bind(app));
	$(window).on("beforeunload", app.onBeforeUnload.bind(app));
};
/**
 * Trigger an action
 * 		$$elmt: JQL element - $$elmt of a control or page by example
 * 				if null trigger elemt at current page level (controlId is ignored)
 */
var _triggerAction = function($$elmt, act, params, controlId) {
	window.setTimeout(function() {
		_doAction($$elmt, act, params, controlId);
	});
};
/**
 * Triggers a navigation (open link) according to attributes params
 * $$elmt			JQ element to search for parent vignette  if any
 * attributes		SAme attributes as $$element
 */
var _triggerNavigation = function($$elmt, attributes) {
	// Simulate a Jquery object that provides attr() method
	var attrs = function(jsonAttrs) {
		var _jsonAttrs = jsonAttrs;
		Object.keys(_jsonAttrs).forEach(function(key) {
			if ($.isPlainObject(_jsonAttrs[key])) {
				_jsonAttrs[key] = JSON.stringify(_jsonAttrs[key]);
			}
		});
		this.attr = function(name) {
			return _jsonAttrs[name];
		};
	};
	_doNavigation(new attrs(attributes), $$elmt);
};
/*
 * Trigger refresh - used by filterSort
 */
var _triggerRefreshPage = function($$elmt, attributes) {
	setTimeout(function() {
		attributes = attributes || {};
		attributes["data-nav-refresh"] = "true";
		_triggerNavigation($$elmt, attributes);
	});
};
exports.bindEvents = _bindEvents;
exports.triggerAction = _triggerAction;
exports.triggerNavigation = _triggerNavigation;
exports.triggerRefreshPage = _triggerRefreshPage;
});

define('syracuse-tablet/html/js/application/pageLoader',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("pageLoader");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var locale = require('syracuse-tablet/html/js/helpers/locale');

/**
 * Load a page in a container
 * 	container must provide the following interface
 * 	Use by application and vignette - code factorization
 * 	callerInterface - see CALLER INTERFACE below
 */
var _PageLoader = utils.defineClass(
	function PageLoader(callerInterface) {
		this.callerInterface = callerInterface;
		this.factory = globals.getApplication().factory;
	}, null, {

		destroy: function() {
			this.destroyed = true;
			this.callerInterface = null;
			this.factory = null;
		},
		/**
		 * loadOptions
		 * 		dontDisplayLoadErr = true to not display a modal,
		 * 		restoreSavedContext: true to restore the savedContext even if it's not a back (open a link by email)
		 */
		load: function(state, back, loadOptions) {
			var self = this;
			if (self.destroyed) {
				return $.smResolve();
			}
			var deferred = $.Deferred();
			self.beforeLoading();
			var pageToOpen = null;
			var pageToClose = null;
			state.options = state.options || {};
			loadOptions = loadOptions || {};
			var _fail = function(e) {
				if (self.destroyed) {
					return deferred.reject(e);
				}
				self.loading = false;
				if (!back && (!e || !e.$redirectPage)) {
					if (pageToOpen) {
						// Only if !back
						pageToOpen.destroy();
					}
					// Stay on the same page - Mode offline if we click on a detail that doesn't exist we stay on the list
					e.$redirectPage = "current";
				}
				// Otherwise we goto welcome page
				self.waitWheelStop();
				if (self.callerInterface.loadingError) {
					self.callerInterface.loadingError(deferred, state, e);
				} else if (loadOptions.dontDisplayLoadErr !== true) {
					if (e && e.$noConnectionError === true) {
						globals.setOffline(true, {
							severityClass: "success",
							body: locale.text("no.local.data.available")
						});
						deferred.reject(e);
					} else {
						modal.error(locale.text("error.page.loading"), e, function() {
							deferred.reject(e);
						});
					}
				} else {
					deferred.reject(e);
				}
			};
			var timeLine = utils.getTimeLine("pageLoader", state.name);
			timeLine && timeLine.start();
			var _success = function(pageToOpen, pageToClose, parentNotifInfo) {
				if (self.destroyed) {
					return deferred.resolve(null);
				}
				self.loading = false;
				self.waitWheelStop();
				if (pageToOpen) {
					if (back !== true && state.options.noHistoryBack !== true) {
						// Store page in history - noHistoryBack option is used by example for pagination actions
						if (pageToOpen.prototype) {
							pageToOpen.state.$title = pageToOpen.prototype.data("$title");
						}
						self.historyPush(pageToOpen.state);
					}
					self.succeeded(pageToOpen, pageToClose, parentNotifInfo, back, loadOptions);
					timeLine && timeLine.stop(pageToOpen.isNew ? "newPage" : "existingPage");
					pageToOpen.activated();
				}
				deferred.resolve(pageToOpen);
			};
			try {
				if (self.loading) {
					_success(null);
				}
				self.loading = true;
				if (state === null || typeof state != "object") throw new Error("Bad state object");
				log && log("_gotoPage", "start", "page: " + state.uuid);
				pageToClose = self.getCurrentPage();
				if (pageToClose && pageToClose.getProp("uuid") === state.uuid) {
					log && log("\tPage is current -> Skip");
					return;
				}
				var parentNotifInfo = null;
				var childNotifInfo = null;
				if (pageToClose && pageToClose.isChild) {
					/**
					 * If the current page is a child and wants to notify the parent (ex lookup...) it should provide at least
					 * a JSONobject that contains a notifyId with the id of notification
					 * We need to store this data before the page it's destroyed
					 * Information is passed to parent in succeeded interface method (at the end of the process)
					 */
					parentNotifInfo = pageToClose.getParentNotif();
				}
				self.waitWheelStart();
				pageToOpen = $("#" + state.uuid).smPageController();
				// Page found -> Direct access -> Activate and remove childs
				if (pageToOpen != null) {
					log && log("\tPage found in dom -> Activate");
					if (!pageToOpen) throw new Error("Unexpected null page data");
					// Page retrieve from cache
					pageToOpen.isNew = false;
					self._pageActivate(pageToOpen, function() {
						timeLine && timeLine.step("activated");
						// After activation to keep current page for transition
						// No siblings expected
						pageToOpen.destroySiblings();
						_success(pageToOpen, pageToClose, parentNotifInfo);
					}, back);
					return deferred.promise();
				}
				// Page not found -> Create and display
				var parentPage = null;
				if (state.options.parentId) {
					// For child page like state.type === "carddesign" || state.type === "rowdetail"
					parentPage = globals.getController(state.options.parentId);
				}
				var $forceLinkArticle;
				if (pageToClose) {
					// linkArticle contains the id of the vignette that contains the page article
					// Used in test entities to attach a $article to a $link vignette
					// -> convenient for unit test
					var ctrlId = state.options["linkArticle"];
					$forceLinkArticle = back ? state.forceLinkArticle : pageToClose.getLinkedPageArticle(ctrlId);
				}
				self.factory.createPage(self.getRootElmt(), state, parentPage, $forceLinkArticle)
					.then(function(p) {
						if (self.destroyed) return;
						timeLine && timeLine.step("created");
						pageToOpen = p;
						// Page created
						pageToOpen.isNew = true;
						// Context to restore
						var savedContext = state.savedContext;
						// By default we restore nothing - clear the context
						state.savedContext = null;
						if (pageToOpen.isNew) {
							if (!back && pageToOpen.isVignette && pageToClose == null) {
								// Restore the context of a page nested in a vignette after it has been loaded (only - pageToClose == null)
								// E.g. 	when we open a detail form a vignette we need to store the status (scroll, selection...) of the vignette to restore it on back
								state.savedContext = self.getSavedCtxVignette();
							} else if (back || loadOptions.restoreSavedContext == true) {
								// Originally the savedContext was restored on back (last clicked row, searchInfo, scroll...)
								// --> Back in full page or vignette page - we restore context
								// When we implemented the capability to restore a page from a link we allowed the restoration of savedContext when we open the page
								// --> loadOptions.restoreSavedContext = true just means that it's not the regular back proccess
								state.savedContext = savedContext;
							}
						}
						return pageToOpen.load(loadOptions);
					})
					.then(function() {
						if (self.destroyed) return;
						timeLine && timeLine.step("loaded");
						self._pageActivate(pageToOpen, function() {
							timeLine && timeLine.step("activated");
							_success(pageToOpen, pageToClose, parentNotifInfo);
						}, back);
					}).fail(function(e) {
						_fail(e);
					});
			} catch (e) {
				_fail(e);
			}
			return deferred.promise();
		},

		_pageActivate: function(pageToOpen, cb, back) {
			var self = this;
			if (self.destroyed) return;
			var pageToClose = self.getCurrentPage();
			if (pageToClose && pageToClose.destroyed === true) {
				// Unexpected but...
				pageToClose = null;
			}
			// Destroy=true if the pageToClose has to be destroyed
			// We destroy the page if back or if pageToClose is not cached or if pageToOpen is a not child
			var destroy = pageToClose && (back === true || (pageToClose.getProp("cached") !== true && pageToOpen.isChild !== true));
			if (pageToClose) {
				// Update the saved context before closing to allow restoration
				// only if destroy and !back -if not destroy (cahed ) page no need to save context (idem if back)
				var clearCtx = (!destroy || back);
				pageToClose.updateSavedContext(clearCtx);
			}
			pageToOpen.activate(pageToClose, function() {
				self.setCurrentPage(pageToClose, pageToOpen, destroy);
				if (cb) cb();
			});
		},

		/**
		 * CALLER INTERFACE BEGIN
		 */
		beforeLoading: function() {
			if (this.callerInterface.beforeLoading) {
				this.callerInterface.beforeLoading();
			}
		},
		/* Methods MUST be implemented */
		historyPush: function(state) {
			this.callerInterface.historyPush(state);
		},

		waitWheelStop: function() {
			this.callerInterface.waitWheelStop();
		},

		waitWheelStart: function() {
			this.callerInterface.waitWheelStart();
		},

		getRootElmt: function() {
			return this.callerInterface.getRootElmt();
		},

		getCurrentPage: function() {
			return this.callerInterface.getCurrentPage();
		},
		getSavedCtxVignette: function() {
			var meth = this.callerInterface.getSavedCtxVignette;
			return meth ? meth() : null;
		},
		setCurrentPage: function(pageToClose, pageToOpen, destroy) {
			var self = this;
			if (pageToClose) {
				if (destroy === true) {
					// To postpone destroy and let asynchronous processes stop (prevent bugs when we work on local data)
					setTimeout(function() {
						pageToClose.destroy();
					});
				} else {
					// Keep cached page only if not back - Ex: List -> Detail
					pageToClose.deactivate();
				}
			}
			self.callerInterface.setCurrentPage(pageToOpen);
		},

		succeeded: function(pageToOpen, pageToClose, parentNotifInfo, back, loadOptions) {
			var self = this;
			notifications.publish("sm.page.loaded", self.getCurrentPage());
			if (this.callerInterface.succeeded) {
				this.callerInterface.succeeded(pageToOpen, pageToClose, parentNotifInfo, back, loadOptions);
			}
		}
		/**
		 * CALLER INTERFACE END
		 */
	});

exports.Klass = _PageLoader;
});

define('syracuse-tablet/html/js/ui/modals/modalSelectContext',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var globals = require('syracuse-tablet/html/js/helpers/globals');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				{{#if allow_logout}} \
					<button type="button" class="btn btn-default s-m-modal-btn-logout" data-action="logout"></button> \
				{{/if}} \
				{{#unless label_offline}} \
				<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
				{{/unless}} \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
			<div class="s-m-scroll-element"> \
				{{#if label_warning}}\
					<div class="alert alert-warning" role="alert">\
						{{label_warning}}\
					</div>\
				{{/if}}\
				{{#if label_offline}}\
					<div class="alert alert-warning" role="alert">\
						{{label_offline}}\
					</div>\
				{{/if}}\
				{{#if showRoles}} \
				<div class="form-group"> \
					<label>{{label_roles}}</label>\
					<select class="form-control" id="login-select-role"> \
					{{#each roles}}\
						<option value="{{this.code}}" {{#if this.selected}}selected{{/if}}>\
						{{this.description}}\
						</option>\
					{{/each}}\
					</select>\
				</div> \
				{{/if}} \
				{{#if showEndpoints}} \
				<div class="form-group"> \
					<label>{{label_endpoints}}</label>\
					<select class="form-control" id="login-select-endpoint"> \
					{{#each endpoints}}\
						<option value="{{this.code}}" {{#if this.selected}}selected{{/if}}>\
						{{this.description}}\
						</option>\
					{{/each}}\
					</select>\
				</div> \
				{{/if}} \
				{{#if showLanguages}} \
				<div class="form-group"> \
					<label>{{label_languages}}</label>\
					<select class="form-control" id="login-select-language"> \
					{{#each languages}}\
						<option value="{{this.code}}" {{#if this.selected}}selected{{/if}}>\
						{{this.description}}\
						</option>\
					{{/each}}\
					</select>\
				</div> \
				{{/if}} \
			</div> \
			</div>',
	footer: ''
};
var _myTemplates = {
	endpoints: '\
		{{#each endpoints}}\
				<option value="{{ep.code}}" {{#if selected}}selected{{/if}}>{{description}}{{#unless description}}{{code}}{{/unless}}</option>\
		{{/each}}'
};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _myTemplates[key];
	if (!tmpl) {
		tmpl = _myTemplates[name];
		tmpl = _myTemplates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};
var _Klass = utils.defineClass(
	function ModalSelectContext(context, settings, displayOpts, isOffline) {
		if (!isOffline && (settings == null || !settings.roles || settings.roles.length == 0)) {
			throw new Error("Unexpected wrong user settings");
		}
		var self = this;
		self.isOffline = isOffline;
		self.displayOpts = displayOpts || {};
		if (isOffline) {
			self.displayOpts.hideEndpoints = true;
			self.displayOpts.hideRoles = true;
			self.displayOpts.hideLanguages = true;
		}
		modalDialog.ModalBase.call(self);
		self.initParam = {
			context: $.extend(true, {}, context),
			setttings: $.extend(true, {}, settings),
			warn: true
		};
		if (!self.initParam.context.role) {
			self.initParam.context.role = self.initParam.setttings.roles[0].code;
		}
		if (!self.initParam.context.language) {
			self.initParam.context.language = utils.getNavigatorLanguage("en-US");
		}
		// Result
		self.result = null;
	}, modalDialog.ModalBase, {
		destroy: function() {
			if (this._$$roles) {
				this._$$roles.off();
				this._$$roles = null;
			}
			if (this._$$endPoints) {
				this._$$endPoints.off();
				this._$$endPoints = null;
			}
			modalDialog.ModalBase.prototype.destroy.call(this);
			this.initParam = null;
			this.result = null;
		},

		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},
		_getRoles: function() {
			var self = this;
			var roles = self.initParam.setttings.roles || [];
			var found = false;
			roles.forEach(function(r) {
				r.selected = r.code === self.initParam.context.role;
			});
			return roles;
		},
		_getLanguages: function() {
			var self = this;
			var languages = this.initParam.setttings.locales || [];
			languages.forEach(function(lang) {
				lang.selected = lang.code === self.initParam.context.language;
			});
			return languages;
		},
		_getEndPoints: function(roles) {
			var self = this;
			var endPoints;
			(roles || self._getRoles()).some(function(r) {
				if (r.selected === true) {
					endPoints = r.endPoints;
					return true;
				}
			});
			endPoints = endPoints || [];
			endPoints.forEach(function(ep) {
				ep.selected = ep.code === self.initParam.context.endpoint;
			});
			return endPoints;
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "select-context half_right";
			} else {
				displayFlags.modalClass = "select-context full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			var roles = self._getRoles();
			var languages = self._getLanguages();
			// Last
			var endPoints = self._getEndPoints(roles);
			var showEndpoints = self.displayOpts.hideEndpoints !== true;
			var showRoles = self.displayOpts.hideRoles !== true;
			var showLanguages = self.displayOpts.hideLanguages !== true && languages.length > 0;
			var label_warning = self.initParam.warn && locale.text("modal.context.warning");
			var label_offline = locale.text("modal.context.offline");
			if (self.isOffline !== true) {
				label_offline = null;
			} else {
				label_warning = null;
			}
			var curApp = globals.getApplication();
			var curPage = curApp && curApp.currentPage;
			if (curPage && jsutils.isInstanceOf(curPage, "WelcomeDashboardPage")) {
				label_warning = false;
			}
			var data = {
				title: locale.text("modal.context.title"),
				label_endpoints: locale.text("modal.context.endpoints"),
				showEndpoints: showEndpoints,
				endpoints: endPoints,
				label_roles: locale.text("modal.context.roles"),
				showRoles: showRoles,
				roles: roles,
				label_languages: locale.text("modal.context.languages"),
				showLanguages: showLanguages,
				languages: languages,
				label_logout: locale.text("modal.context.logout"),
				label_ok: locale.text("modal.context.ok"),
				label_cancel: locale.text("modal.context.cancel"),
				label_warning: label_warning,
				label_offline: label_offline,
				allow_logout: self.initParam.context != null,
			};
			return data;
		},
		_attachDOM: function() {
			modalDialog.ModalBase.prototype._attachDOM.call(this);
			this._$$roles = this.$$elmt.find("#login-select-role");
			if (this._$$roles.length > 0) {
				this._$$roles.on('change', jsutils.bindFn(this.onRoleChanged, this));
			}
			this._$$endPoints = this.$$elmt.find("#login-select-endpoint");
			if (this._$$endPoints.length > 0) {
				this._$$endPoints.on('change', jsutils.bindFn(this.onEnpointChanged, this));
			}
		},
		onEnpointChanged: function(event) {
			// just to save the last selected one to select it by default
			this.initParam.context.endpoint = this._$$endPoints.val();
		},
		onRoleChanged: function(event) {
			this.initParam.context.role = this._$$roles.val();
			this._$$endPoints.html(_getHtml("endpoints", {
				endpoints: this._getEndPoints()
			})).show();
		},
		_saveSettings: function() {
			// Not used currently but can be used to persist settings on modal closing
			return $.smResolve();
		},
		/**
		 * Overridden
		 */
		_onAction: function(action, param) {
			var self = this;
			return self._saveSettings().then(function() {
				if (action === "logout") {
					self.result = {
						"action": "logout"
					};
					return true;
				}
				return false;
			});
		},
		/**
		 * Overridden
		 */
		_onValidate: function() {
			var self = this;
			return self._saveSettings().then(function() {
				var epCode = self._$$endPoints.val();
				var ept;
				self._getEndPoints().some(function(e) {
					if (e.code === epCode) {
						ept = e;
						return true;
					}
				});
				self.result = {
					"action": "ok",
					"endpoint": epCode,
					"endpointDescr": ept && ept.description ? ept.description : epCode,
					"role": self._$$roles.val(),
					"language": self.$$elmt.find("#login-select-language").val()
				};
			});
		},
		/**
		 * Overridden
		 */
		_onCancel: function() {
			var self = this;
			if (self.initParam.context) {
				self.result = {
					"action": "cancel"
				};
			} else {
				// if there is no context yet and we cancel, we handle it like a logout
				self.result = {
					"action": "logout"
				};
			}
		},
		/**
		 * Overridden
		 */
		_getResult: function() {
			return this.result;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/storage/storageInterface',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {"use strict";

/*
 * Default interface for mobile application metadata, favorites, drafts and templates, ...
 */


var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

var _statusCodes = {
	OK: 1,
	NOT_FOUND: 2,
	ERROR: 3
};

/*
 * All storage interfaces must inherit the "Not implemented" methods of this super class
 */
var _Klass = utils.defineClass(
	function(infoString, databaseVersion) {
		this.infoString = infoString;
		this.databaseName = exports.databaseName;
		this.databaseVersion = databaseVersion;
		this.useTestDatabase = false;
		this.db = null;
	},
	null, {
		getInfo: function() {
			return this.infoString;
		},

		/**
		 * Init storage
		 *
		 * Return:
		 * Resolve:
		 * {
		 *   $status: StatusCodes.OK,
		 *   $data: { }
		 * }
		 *
		 * Reject:
		 * {
		 *   $status: StatusCodes.ERROR,
		 *   $message: "Error message",
		 *   $exception: { ... }
		 * }
		 *
		 */
		init: function() {
			throw new Error("Not implemented!");
		},

		/**
		 * Query a list of items
		 *
		 * Parameters:
		 * opts: {
		 *   $context: {
		 *     $user,
		 *     $role,
		 *     $lang
		 *   },
		 *   $endpoint,
		 *   $collection: "users.$query",
		 *   $orderBy: "name, email" // optional
		 * }
		 *
		 * Return:
		 * Resolve:
		 * {
		 *   $status: StatusCodes.OK,
		 *   $data: [record1, record2, ...]
		 * }
		 *
		 * Reject:
		 * {
		 *   $status: StatusCodes.ERROR,
		 *   $message: "Error message",
		 *   $exception: { ... }
		 * }
		 *
		 */
		query: function(opts) {
			throw new Error("Not implemented!");
		},

		/**
		 * Does a create or update if record is there already
		 *
		 * Parameters:
		 * opts: {
		 *   $context: {
		 *     $user,
		 *     $role,
		 *     $lang
		 *   },
		     $endpoint,
		 *   $collection: "users.$query",
		 *   $data: {},
		 *   $key: "abc~def"
		 * }
		 *
		 * Return:
		 * Resolve:
		 * {
		 *   $status: StatusCodes.OK,
		 *   $data: { }
		 * }
		 *
		 * Reject:
		 * {
		 *   $status: StatusCodes.ERROR,
		 *   $message: "Error message",
		 *   $exception: { ... }
		 * }
		 *
		 */
		put: function(opts) {
			throw new Error("Not implemented!");
		},

		/**
		 * Reads exactly one record by it's key
		 *
		 * Parameters:
		 * opts: {
		 *   $context: {
		 *     $user,
		 *     $role,
		 *     $lang
		 *   },
		     $endpoint,
		 *   $collection: "users.$query",
		 *   $key: "abc~def"
		 * }
		 *
		 * Return:
		 * Resolve:
		 * {
		 *   $status: StatusCodes.OK or StatusCodes.NOT_FOUND
		 *   $data: { }
		 * }
		 *
		 * Reject:
		 * {
		 *   $status: StatusCodes.ERROR,
		 *   $message: "Error message",
		 *   $exception: { ... }
		 * }
		 *
		 */
		read: function(opts) {
			throw new Error("Not implemented!");
		},

		/**
		 * Delete exactly one record by it's key
		 *
		 * Parameters:
		 * opts: {
		 *   $context: {
		 *     $user,
		 *     $role,
		 *     $lang
		 *   },
		     $endpoint,
		 *   $collection: "users.$query",
		 *   $key: "abc~def"
		 * }
		 *
		 * Return:
		 * Resolve:
		 * {
		 *   $status: StatusCodes.OK or StatusCodes.NOT_FOUND
		 * }
		 *
		 * Reject:
		 * {
		 *   $status: StatusCodes.ERROR,
		 *   $message: "Error message",
		 *   $exception: { ... }
		 * }
		 *
		 */
		remove: function(opts) {
			throw new Error("Not implemented!");
		},

		/**
		 * Delete exactly one record by it's key
		 *
		 * Parameters:
		 * opts: {
		 *   $context: {
		 *     $user,
		 *     $role,
		 *     $lang
		 *   },
		     $endpoint,
		 *   $collection: "users.$query", // string or regex
		 * }
		 *
		 * Return:
		 * Resolve:
		 * {
		 *   $status: StatusCodes.OK
		 * }
		 *
		 * Reject:
		 * {
		 *   $status: StatusCodes.ERROR,
		 *   $message: "Error message",
		 *   $exception: { ... }
		 * }
		 *
		 */
		clearCollection: function() {
			throw new Error("Not implemented!");
		},
		computeCollectionSize: function() {
			throw new Error("Not implemented!");
		},
		clearDatabaseSupported: function() {
			return false;
		},
		/**
		 * Drafts and working copies
		 * op: Operation CRUD and Query
		 */
		draftOperation: function(op) {},
		/**
		 * Templates
		 * op: Operation CRUD and Query
		 */
		templateOperation: function(op) {}
	}
);

function resultToString(result) {
	if (!result) return "";
	if (jsutils.isError(result)) {
		return JSON.stringify(jsutils.convertToDiagnoses(result), null, 2);
	}
	var res = [];
	if (result.$status) res.push("status: " + result.$status);
	if (result.$message) res.push("Message: " + result.$message);
	if (result.$exception && result.$exception.message) res.push("Exception: " + result.$exception.message);
	if (result.$exception && result.$exception.stack) res.push("Stack: " + result.$exception.stack);
	return res.join('\n');
}

function buildResult(status, data, message, exception, metaData) {
	var res = {
		$status: status
	};
	if (data) res.$data = data;
	if (metaData) res.$metaData = metaData;
	if (message) res.$message = message;
	if (exception) res.$exception = exception;
	return res;
}

function buildErrResult(message, exception) {
	return buildResult(_statusCodes.ERROR, null, message, exception);
}
exports.Klass = _Klass;
exports.StatusCodes = _statusCodes;
exports.buildResult = buildResult;
exports.buildErrResult = buildErrResult;
exports.resultToString = resultToString;

// Same db name for all kind of database - !!must be different from mobile application name
exports.databaseName = "sage-tablet-db";
});

define('syracuse-tablet/html/js/storage/storageWebSQLBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {"use strict";

/*
 * WebSQL storage interface (Chrome, Safari)
 */
var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var Base = storageInterface.Klass;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("webSQL", false);

//Increase this number to upgrade database to schema described in _objectStores
var _databaseVersion = 21;
var _databaseSize = 2 * 1024 * 1024;

var _Klass = utils.defineClass(
	function() {
		Base.call(this, "WebSQL storage interface", _databaseVersion);
		this.databaseSize = _databaseSize;
	},
	Base, {
		init: function() {
			var deferred = $.Deferred();
			var self = this;
			$.smResolve().then(function() {
				self.useTestDatabase = globals.isTestEnvironment();
				self.databaseName = storageInterface.databaseName + (self.useTestDatabase ? "-test" : "");
				if (self.useTestDatabase === false && self.db) {
					return $.smResolve(storageInterface.StatusCodes.OK);
				} else {
					return self._openDB();
				}
			}).then(function(status) {
				deferred.resolve(status);
			}).fail(function(e) {
				log && log("Open database exception", JSON.stringify(storageInterface.buildErrResult(e), null, 2));
				deferred.reject(storageInterface.buildErrResult(locale.text("db.err.init"), e));
			});
			return deferred.promise();
		},
		_openDB: function() {
			var self = this;
			return $.smResolve().then(function() {
				var request;
				log && log("Open database, request version: " + self.databaseVersion);
				self.db = window.openDatabase(self.databaseName, 7, 'Database', self.databaseSize);
				return self._readCurrentVersion().then(function(version) {
					log && log("Current version: " + version);
					// In test framework create DB every time
					if (version === self.databaseVersion && self.useTestDatabase !== true) {
						return storageInterface.StatusCodes.OK;
					} else {
						return self._createTables().then(function(status) {
							return self._writeCurrentVersion();
						});
					}
				});
			});
		},
		_writeCurrentVersion: function() {
			var self = this;
			var deferred = $.Deferred();
			self._executeSql('DELETE FROM version', null).then(function(result) {
				return self._executeSql('INSERT INTO version (version) values (?)', [_databaseVersion]).then(function(status) {
					deferred.resolve(status);
				});
			}).fail(function(e) {
				log && log("_writeCurrentVersion exception", JSON.stringify(storageInterface.buildErrResult(e), null, 2));
				deferred.reject(storageInterface.buildErrResult("writeCurrentVersion", e));
			});
			return deferred.promise();
		},
		/**
		 * Returns the tables to create
		 */
		getTables: function() {
			return {};
		},
		_executeSql: function(sql, params) {
			var deferred = $.Deferred();
			var self = this;
			try {
				self.db.transaction(function(tx) {
					try {
						log && log("SQL: " + sql);
						log && log(params);
						tx.executeSql(sql, params, function(tx, result) {
							deferred.resolve(result);
						}, function(tx, error) {
							deferred.reject(storageInterface.buildErrResult("DB error initializing database: " + self.sqlErrorToMessage(error, sql, params)));
						});
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error running SQL statement", e));
					}
				}, function(error) {
					deferred.reject(storageInterface.buildErrResult("DB transaction error: " + self.sqlErrorToMessage(error, sql, params) + ". Try to reload the page"));
				});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error running SQL statement", e));
			}
			return deferred.promise();
		},
		_readCurrentVersion: function() {
			var deferred = $.Deferred();
			var self = this;
			self._executeSql('SELECT version FROM version', null).then(function(result) {
				try {
					var len = result.rows.length;
					if (len === 1) {
						var version = result.rows.item(0).version;
						log && log("Read version: " + version);
						deferred.resolve(+version);
					}
					deferred.resolve(-1);
				} catch (e) {
					deferred.reject(storageInterface.buildErrResult("error reading database version", e));
				}
			}).fail(function(e1) {
				// Assume table does not exist, create it
				log && log("Creating version table");
				self._executeSql('CREATE TABLE version (version TEXT)').then(function(status) {
					deferred.resolve(-1);
				}).fail(function(e2) {
					log && log("Error creating version table", JSON.stringify(storageInterface.buildErrResult(e2), null, 2));
					deferred.reject(storageInterface.buildErrResult("error reading database version", e1));
				});
			});
			return deferred.promise();
		},
		_createTables: function() {
			var deferred = $.Deferred();
			var self = this;
			var p = [];
			var errors = [];
			var nbExec = 0;
			var tables = this.getTables();
			// FDB - Redid this way because the old implementation with $.when() didn't bubble up errors rejected to the main process
			for (var name in tables) {
				nbExec += tables[name].length;
			}
			for (var name in tables) {
				tables[name].forEach(function(descr) {
					self._executeSql(descr).then(function() {
						nbExec--;
						if (nbExec === 0) {
							if (errors.length > 0) {
								deferred.reject(storageInterface.buildErrResult("Error creating database tables", errors.join('\n')));
							} else {
								deferred.resolve(storageInterface.StatusCodes.OK);
							}
						}
					}, function(status) {
						nbExec--;
						errors.push(status.$message);
						if (nbExec === 0) {
							deferred.reject(storageInterface.buildErrResult("Error creating database tables", errors.join('\n')));
						}
					});
				});
			};
			return deferred.promise();
		},
		sqlErrorToMessage: function(error, sql, params) {
			if (log) {
				var e = {};
				for (var p in error) {
					if (typeof error[p] === "function") continue;
					if (error[p] == "object" && (!Array.isArray(error[p]) || !$.isPlainObject(error[p]))) continue;
					e[p] = error[p];
				}
				log && log("ERROR REQUEST:", sql);
				log && log("ERROR PARAMS:", params);
				log && log(JSON.stringify(e, null, 2));
			}
			return "CODE: " + error.code + " MESSAGE: " + error.message;
		},
		// No need because we can clear the cache manually - #7942
		clearDatabaseSupported: function() {
			return false;
		}
	}
);

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/storage/storageWebSQLSData',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/storage/storageWebSQLBase','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {"use strict";

/**
 * WebSQL storage interface - SDATA (META + DATA) MANAGEMENT
 * Members added to of _storageInterfaceWebSQLClass
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var Base = require('syracuse-tablet/html/js/storage/storageWebSQLBase').Klass;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("webSQL", false);

var _tables = {
	"sdata_meta": [
		// meta data table for handling etags, ttl, size, ..
		"DROP TABLE IF EXISTS sdata_meta",
		"CREATE TABLE sdata_meta ( " +
		"key text, " +
		"collection text, " +
		"endpoint text, " +
		"context text, " +
		"id text, " +
		"etag text, " +
		"last_read text, " +
		"last_updated text" +
		")",
		"DROP INDEX IF EXISTS sdata_meta_pk",
		"CREATE UNIQUE INDEX sdata_meta_pk ON sdata_meta (key, collection, endpoint, context)",
		"DROP INDEX IF EXISTS sdata_meta_id",
		"CREATE UNIQUE INDEX sdata_meta_id ON sdata_meta (id)"
	],
	"sdata_objects": [
		// data table
		"DROP TABLE IF EXISTS sdata_objects",
		"CREATE TABLE sdata_objects ( " +
		"id text, " +
		"data text " +
		")",
		"DROP INDEX IF EXISTS sdata_objects_pk",
		"CREATE UNIQUE INDEX sdata_objects_pk ON sdata_objects (id)"
	]
};
var _Klass = utils.defineClass(
	function() {
		Base.call(this);
	}, Base, {
		getTables: function() {
			var res = Base.prototype.getTables.call(this);
			$.extend(res, _tables);
			return res;
		},
		put: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("PUT: ", JSON.stringify(opts));

				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [opts.$key, opts.$collection, opts.$endpoint, context];

				var insertData = function(metaData) {
					self._executeSql("INSERT INTO sdata_objects (data, id) values (?, ?)", [JSON.stringify(opts.$data), metaData.$id])
						.then(function() {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
						}).fail(function(status) {
							deferred.reject(status);
						});
				};

				var updateData = function(metaData) {
					self._executeSql("UPDATE sdata_objects set data = ? where id = ?", [JSON.stringify(opts.$data), metaData.$id])
						.then(function(result) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
						}).fail(function(status) {
							deferred.reject(status);
						});
				};

				// handle meta data
				self._readMetaData(context, params)
					.then(function(metaData) {
						if (metaData && metaData.$etag === opts.$data.$etag) {
							// record has not changed
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
						} else if (metaData) {
							// update
							metaData.$etag = opts.$data.$etag;
							metaData.$lastUpdated = utils.getCurISODateTime();
							self._writeMetaData(metaData)
								.then(function() {
									updateData(metaData);
								}).fail(function(status) {
									deferred.reject(status);
								});
						} else {
							// insert
							metaData = {
								$key: opts.$key,
								$collection: opts.$collection,
								$endpoint: opts.$endpoint,
								$context: opts.$context,
								$etag: opts.$data.$etag,
								$lastUpdated: utils.getCurISODateTime()
							};
							self._writeMetaData(metaData)
								.then(function(metaData) {
									insertData(metaData);
								}).fail(function(status) {
									deferred.reject(status);
								});
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error writing to database", e));
			} finally {
				return deferred.promise();
			}
		},

		read: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("READ: ", JSON.stringify(opts));

				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [opts.$key, opts.$collection, opts.$endpoint, context];

				self._readMetaData(context, params)
					.then(function(metaData) {
						if (!metaData) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						} else {
							self._executeSql("SELECT * FROM sdata_objects where id = ?", [metaData.$id])
								.then(function(result) {
									try {
										if (result.rows.length <= 0) {
											deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
										} else {
											deferred.resolve(storageInterface.buildResult(
												storageInterface.StatusCodes.OK,
												JSON.parse(result.rows.item(0).data),
												null,
												null, {
													$lastRead: metaData.$lastRead,
													$lastUpdated: metaData.$lastUpdated
												}));
										}
									} catch (e) {
										deferred.reject(storageInterface.buildErrResult("error reading from database", e));
									}
								}).fail(function(status) {
									deferred.reject(status);
								});
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		query: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("QUERY: ", JSON.stringify(opts));

				if (!opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [opts.$collection, opts.$endpoint, context];

				self._executeSql("SELECT o.*, m.last_read, m.last_updated FROM sdata_objects o INNER JOIN sdata_meta m ON (o.id = m.id and m.collection = ? and m.endpoint = ? and m.context = ?)", params)
					.then(function(result) {
						var ret = [];
						var meta = [];
						try {
							for (var i = 0; i < result.rows.length; i++) {
								var item = result.rows.item(i);
								ret.push(JSON.parse(item.data));
								meta.push({
									$lastRead: item.last_read,
									$lastUpdated: item.last_updated
								});
							}
						} catch (e) {
							deferred.reject(storageInterface.buildErrResult("error reading from database", e));
							return;
						}
						// Exception are handled by our jq deferred hack
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, ret, null, null, meta));
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		remove: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("REMOVE: ", JSON.stringify(opts));

				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [opts.$key, opts.$collection, opts.$endpoint, context];
				self._removeMetaData(context, params)
					.then(function(metaData) {
						if (!metaData) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						} else {
							self._executeSql("DELETE FROM sdata_objects where id = ?", [metaData.$id])
								.then(function() {
									deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
								}).fail(function(status) {
									deferred.reject(status);
								});
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error writing to database", e));
			} finally {
				return deferred.promise();
			}
		},
		clearCollection: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("CLEAR: ", JSON.stringify(opts));

				if (!opts.$collection || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [context];

				//self._executeSql("SELECT * FROM sdata_meta where context = ?", params)
				self._executeSql("SELECT * FROM sdata_meta")
					.then(function(result) {
						var ret = [];
						try {
							for (var i = 0; i < result.rows.length; i++) {
								var item = result.rows.item(i);
								if (opts.$collection.test(item.collection)) {
									if (!opts.$not_read_since || item.last_read < opts.$not_read_since) {
										ret.push({
											$context: opts.$context,
											$collection: item.collection,
											$endpoint: item.endpoint,
											$key: item.key
										});
									}
								}
							}
							$.smForEachPromise(ret, function(item) {
								return self.remove(item);
							}).then(function() {
								deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
							}).fail(function(e) {
								deferred.reject(e);
							});
						} catch (e) {
							deferred.reject(storageInterface.buildErrResult("error reading from database", e));
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		computeCollectionSize: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("CHECK SIZE: ", JSON.stringify(opts));

				if (!opts.$collection || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [context];
				//self._executeSql("SELECT * FROM sdata_meta where context = ?", params)
				self._executeSql("SELECT m.collection, m.endpoint, m.key, m.last_read, d.data FROM sdata_meta m INNER JOIN sdata_objects d ON (d.id = m.id)")
					.then(function(result) {
						var returnData = {
							numRecords: 0,
							sizeRecords: 0
						};
						var ret = [];
						try {
							for (var i = 0; i < result.rows.length; i++) {
								var item = result.rows.item(i);
								if (opts.$collection.test(item.collection)) {
									if (!opts.$not_read_since || item.last_read < opts.$not_read_since) {
										returnData.numRecords++;
										returnData.sizeRecords += item.data.length;
									}
								}
							}
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, returnData));
						} catch (e) {
							deferred.reject(storageInterface.buildErrResult("error reading from database", e));
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		_readMetaData: function(context, params, noUpdate) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				self._executeSql("SELECT * FROM sdata_meta where key = ? and collection = ? and endpoint = ? and context = ?", params)
					.then(function(result) {
						try {
							if (result.rows.length <= 0) {
								deferred.resolve(null);
							} else {
								var item = result.rows.item(0);
								var metaData = {
									$key: item.key,
									$collection: item.collection,
									$endpoint: item.endpoint,
									$context: item.context,
									$id: item.id,
									$etag: item.etag,
									$lastRead: item.last_read,
									$lastUpdated: item.last_updated
								};
								log && log("Read meta data: " + JSON.stringify(metaData));
								if (noUpdate === true) {
									deferred.resolve(metaData);
								} else {
									self._writeMetaData(metaData)
										.then(function() {
											// allways resolve and ignore errors
											deferred.resolve(metaData);
										}).fail(function(e) {
											deferred.reject(storageInterface.buildErrResult("error reading from database", e));
										});
								}
							}
						} catch (e) {
							deferred.reject(storageInterface.buildErrResult("error reading from database", e));
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},
		// #8093 Locks the key and returns true if key wasn't locked
		_conflictMetaLock: function(metaId) {
			var locked = false;
			if (!this._lockedMeta) {
				this._lockedMeta = [];
			} else {
				locked = this._lockedMeta.indexOf(metaId) >= 0;
			}
			if (locked === false) {
				this._lockedMeta.push(metaId);
			}
			return locked === false;
		},
		// #8093 Put deferred and meta in waiting queue
		_conflictMetaWait: function(metaId, deferred, metaData) {
			log && log("!!CONFLICT WAIT", metaId);
			if (!this._pendingMeta) {
				this._pendingMeta = {};
			}
			var stack = this._pendingMeta[metaId];
			if (!stack) {
				stack = this._pendingMeta[metaId] = [];
			}
			stack.push({
				deferred: deferred,
				metaData: metaData
			});
		},
		// #8093 Unlock the key and process pending metaData (UPDATE) for this key if any
		_conflictMetaUnlock: function(metaId) {
			var idx = this._lockedMeta.indexOf(metaId);
			if (idx >= 0) {
				this._lockedMeta.splice(idx, 1);
			}
			var stack = this._pendingMeta ? this._pendingMeta[metaId] : null;
			if (!stack) {
				return;
			}
			var data = stack.pop();
			if (stack.length === 0) {
				delete this._pendingMeta[metaId];
			}
			if (!data) {
				return;
			}
			log && log("!!CONFLICT RETRY", metaId);
			this._writeMetaData(data.metaData).then(function(metaData) {
				data.deferred.resolve(metaData);
			}).fail(function(status) {
				data.deferred.reject(status);
			});
		},
		_writeMetaData: function(metaData) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				metaData.$lastRead = utils.getCurISODateTime();
				if (!metaData.$id) {
					// #8093 - Set metaData.$id first to force UPDATE if a retry is needed in case of conflict (It will update existing record)
					metaData.$id = utils.UUID();
					// Unique key that could create conflict (Index)
					var metaId = [
						metaData.$key,
						metaData.$collection,
						metaData.$endpoint,
						JSON.stringify(metaData.$context)
					].join('-');
					// Chek if key is locked
					if (self._conflictMetaLock(metaId)) {
						self._executeSql("INSERT INTO sdata_meta (key, collection, endpoint, context, id, etag, last_read, last_updated) values (?, ?, ?, ?, ?, ?, ?, ?)", [
							metaData.$key,
							metaData.$collection,
							metaData.$endpoint,
							JSON.stringify(metaData.$context),
							metaData.$id,
							metaData.$etag,
							metaData.$lastRead,
							metaData.$lastUpdated
						])
							.then(function() {
								// Unnlock key
								self._conflictMetaUnlock(metaId);
								deferred.resolve(metaData);
							}).fail(function(status) {
								// Unnlock key
								self._conflictMetaUnlock(metaId);
								deferred.reject(status);
							});
					} else {
						// Save deferred and data - Lets retry when key is unlocked
						self._conflictMetaWait(metaId, deferred, metaData);
					}
				} else {
					self._executeSql("UPDATE sdata_meta set etag = ?, last_read = ?, last_updated = ? where id = ?", [metaData.$etag, metaData.$lastRead, metaData.$lastUpdated, metaData.$id])
						.then(function(result) {
							deferred.resolve(metaData);
						}).fail(function(status) {
							deferred.reject(status);
						});
				}
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error writing meta data", e));
			} finally {
				return deferred.promise();
			}
		},

		_removeMetaData: function(context, params) {
			var deferred = $.Deferred();
			var self = this;
			try {
				self._readMetaData(context, params, true)
					.then(function(metaData) {
						if (!metaData) {
							deferred.resolve(null);
						} else {
							self._executeSql("DELETE FROM sdata_meta where id = ?", [metaData.$id])
								.then(function() {
									deferred.resolve(metaData);
								}).fail(function(status) {
									deferred.reject(status);
								});
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/storage/storageWebSQLDrafts',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/storage/storageWebSQLSData','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var Base = require('syracuse-tablet/html/js/storage/storageWebSQLSData').Klass;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("drafts", false);
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
/**
 * WebSQL storage interface - DRAFTS MANAGEMENT
 * Inherits from storageWebSQLSData only to split the code
 */

var _DRAFT_INSERT = "INSERT INTO sdata_drafts (id, endpoint, representation, comment, status, errorMsg, dataSet, restoredContext, saveLink, title, creation_date) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
var _DRAFT_DELETE_ALL = "DELETE FROM sdata_drafts";
var _DRAFT_DELETE = "DELETE FROM sdata_drafts where id = ?";
var _DRAFT_READ = "SELECT * FROM sdata_drafts where id = ?";
var _DRAFT_READ_LIST = "SELECT id, endpoint, representation, comment, status, errorMsg, title, creation_date FROM sdata_drafts";
var _DRAFT_COUNT = "SELECT COUNT(*) AS counter FROM sdata_drafts";
var _tables = {
	"sdata_drafts": [
		"DROP TABLE IF EXISTS sdata_drafts",
		"CREATE TABLE sdata_drafts ( " +
		"id text, " +
		"endpoint text, " +
		"representation text, " +
		"comment text, " +
		"status text, " +
		"errorMsg, " +
		"dataSet text, " +
		"restoredContext text, " +
		"saveLink text, " +
		"title text, " +
		"creation_date text" +
		")",
		"DROP INDEX IF EXISTS sdata_drafts_id",
		"CREATE UNIQUE INDEX sdata_drafts_id ON sdata_drafts (id)"
	],
	"sdata_wrkcpy": [
		// Workingcopy
		"DROP TABLE IF EXISTS sdata_wrkcpy",
		"CREATE TABLE sdata_wrkcpy ( " +
		"id text, " +
		"dataSet text, " +
		"creation_date text" +
		")",
		"DROP INDEX IF EXISTS sdata_wrkcpy_id",
		"CREATE UNIQUE INDEX sdata_wrkcpy_id ON sdata_wrkcpy (id)"
	]
};

var _logError = function(title, status) {
	log && log(title + " ERROR");
	log && log(storageInterface.resultToString(status));
};
/**
 * Manages drafts and working copies storage
 */
var _Klass = utils.defineClass(
	function() {
		Base.call(this);
		this._wrkcpyAllDeleted = false;
	}, Base, {
		getTables: function() {
			var res = Base.prototype.getTables.call(this);
			$.extend(res, _tables);
			return res;
		},
		/**
		 * Resolve with true/false
		 */
		_wrkcpyExists: function(id) {
			var self = this;
			return self._executeSql("SELECT * FROM sdata_wrkcpy where id = ?", [id])
				.then(function(result) {
					if (result && result.rows && result.rows.length > 0) {
						return true;
					}
					return false;
				}).fail(function(status) {
					_logError("_wrkcpyExists", status);
					return false;
				});
		},
		/**
		 * Resolve with data/null
		 */
		_wrkcpyRead: function(id) {
			var self = this;
			return self._executeSql("SELECT * FROM sdata_wrkcpy where id = ?", [id])
				.then(function(result) {
					if (!result || !result.rows || result.rows.length == 0) return null;
					try {
						result = JSON.parse(result.rows.item(0).dataSet);
						log && log("_wrkcpyRead", id, "OK");
						return result;
					} catch (e) {
						log && log("_wrkcpyRead", "KO", id);
						return null;
					}
				}).fail(function(status) {
					_logError("_wrkcpyRead", status);
					return null;
				});
		},
		/**
		 * Resolve with  true/false
		 * Delete all the working copies that belong to transaction_id
		 */
		_wrkcpyDelete: function(id) {
			var self = this;
			return self._executeSql("DELETE FROM sdata_wrkcpy where id = ?", [id]).then(function(result) {
				log && log("_wrkcpyDelete", id, result ? "OK" : "KO");
				return true;
			}).fail(function(status) {
				_logError("_wrkcpyDelete", status);
				return false;
			});
		},
		/**
		 * Resolve with true/false
		 */
		_wrkcpyDeleteAll: function() {
			var self = this;
			if (self._wrkcpyAllDeleted === true) {
				// Optimization
				return $.smResolve(null);
			}
			return self._executeSql("DELETE FROM sdata_wrkcpy").then(function(result) {
				log && log("_wrkcpyDeleteAll OK");
				self._wrkcpyAllDeleted = true;
				return true;
			}).fail(function(status) {
				_logError("_wrkcpyDeleteAll", status);
				return false;
			});
		},
		/**
		 * Resolve with dataSet/null
		 */
		_wrkcpyCreate: function(dataSet) {
			var self = this;
			if (!dataSet || !dataSet.$uuid) {
				log && log("_wrkcpyCreate error", "Invalid parameters");
				return $.smResolve(null);
			}
			return self._wrkcpyDelete(dataSet.$uuid).then(function() {
				return self._wrkcpyDoInsert(dataSet);
			});
		},
		_wrkcpyDoInsert: function(dataSet) {
			var self = this;
			return self._executeSql("INSERT INTO sdata_wrkcpy (dataSet, id) values (?, ?)", [JSON.stringify(dataSet), dataSet.$uuid])
				.then(function() {
					log && log("_wrkcpyDoInsert", dataSet.$uuid, "OK");
					self._wrkcpyAllDeleted = false;
					return dataSet;
				}).fail(function(status) {
					_logError("_wrkcpyDoInsert", status);
					return null;
				});
		},
		_wrkcpyDoUpdate: function(dataSet) {
			var self = this;
			return self._executeSql("UPDATE sdata_wrkcpy set dataSet = ? where id = ?", [JSON.stringify(dataSet), dataSet.$uuid]).then(function(result) {
				log && log("_wrkcpyDoUpdate", "OK");
				return dataSet;
			}).fail(function(status) {
				_logError("_wrkcpyDoUpdate", status);
				return null;
			});
		},
		_wrkcpyUpdate: function(dataSet) {
			var self = this;
			if (!dataSet || !dataSet.$uuid) {
				log && log("_wrkcpyUpdate error", "Invalid parameters");
				return $.smResolve(null);
			}
			return self._wrkcpyExists(dataSet.$uuid).then(function(exists) {
				if (exists === true) {
					log && log("_wrkcpyUpdate UPDATE", dataSet.$uuid);
					return self._wrkcpyDoUpdate(dataSet);
				} else {
					log && log("_wrkcpyUpdate CREATE", dataSet.$uuid);
					return self._wrkcpyDoInsert(dataSet);
				}
			});
		},
		_draftReadInfo: function(item) {
			if (!item) return null;
			try {
				return {
					id: item.id,
					endpoint: item.endpoint || "",
					representation: item.representation || "",
					comment: item.comment || "",
					status: item.status || "none",
					errorMsg: item.errorMsg || "",
					dataSet: item.dataSet ? JSON.parse(item.dataSet) : null,
					restoredContext: item.restoredContext ? JSON.parse(item.restoredContext) : null,
					saveLink: item.saveLink ? JSON.parse(item.saveLink) : null,
					title: item.title || "",
					creation_date: item.creation_date
				};
			} catch (e) {
				log && log("_draftReadInfo", "KO", item.id);
				return null;
			}
		},
		/**
		 * Resolve with [resources]/[]
		 */
		_draftReadList: function() {
			var self = this;
			return self._executeSql(_DRAFT_READ_LIST)
				.then(function(result) {
					if (!result || !result.rows || result.rows.length == 0) return [];
					var resources = [],
						rec;
					for (var i = 0; i < result.rows.length; i++) {
						rec = self._draftReadInfo(result.rows.item(i));
						if (rec) {
							resources.push(rec);
						}
					}
					log && log("_draftReadList", "OK");
					return resources;
				}).fail(function(status) {
					_logError("_draftReadList", status);
					return [];
				});
		},
		/**
		 * Resolve with data/null
		 */
		_draftRead: function(id) {
			var self = this;
			return self._executeSql(_DRAFT_READ, [id])
				.then(function(result) {
					if (!result || !result.rows || result.rows.length == 0) return null;
					log && log("_draftRead", id, "OK");
					return self._draftReadInfo(result.rows.item(0));
				}).fail(function(status) {
					_logError("_draftRead", status);
					return null;
				});
		},
		/**
		 * Resolve with  true/false
		 */
		_draftDelete: function(id) {
			var self = this;
			return self._executeSql(_DRAFT_DELETE, [id]).then(function(result) {
				log && log("_draftDelete", id, result ? "OK" : "KO");
				self._draftNotifyChanged();
				return true;
			}).fail(function(status) {
				_logError("_draftDelete", status);
				return false;
			});
		},
		/**
		 * Resolve with true/false
		 */
		_draftDeleteAll: function() {
			var self = this;
			return self._executeSql(_DRAFT_DELETE_ALL).then(function(result) {
				log && log("_draftDeleteAll OK");
				self._draftNotifyChanged();
				return true;
			}).fail(function(status) {
				_logError("_draftDeleteAll", status);
				return false;
			});
		},
		/**
		 * Resolve with draft context or reject with an exception
		 */
		_draftSave: function(ctx) {
			var self = this;
			var deferred = $.Deferred();
			if (!ctx || !ctx.id) {
				log && log("_draftSave error", "Invalid parameters");
				deferred.reject(new Error("Invalid parameters"));
			} else {
				self._draftDelete(ctx.id).then(function() {
					return self._executeSql(_DRAFT_INSERT, [ctx.id, ctx.endpoint, ctx.representation, ctx.comment, ctx.status, ctx.errorMsg, JSON.stringify(ctx.dataSet), JSON.stringify(ctx.restoredContext), JSON.stringify(ctx.saveLink), ctx.title, ctx.creation_date]);
				}).then(function() {
					log && log("_draftSave", ctx.id, "OK");
					self._draftNotifyChanged();
					deferred.resolve(ctx);
				}).fail(function(status) {
					_logError("_draftSave", status);
					deferred.reject(status.$exception || new Error(status.message));
				});
			}
			return deferred.promise();
		},
		_draftCount: function(notify) {
			return this._executeSql(_DRAFT_COUNT).then(function(result) {
				var count = result && result.rows.length > 0 ? result.rows.item(0).counter : 0;
				if (notify) {
					notifications.publish("sm.drafts.changed", count);
				}
				return count;
			}).fail(function(status) {
				_logError("_draftCount", status);
				return 0;
			});
		},
		/**
		 * Notifies to update the number of draft in menu
		 */
		_draftNotifyChanged: function() {
			return this._draftCount(true);
		},
		/**
		 * Drafts
		 * op: Operation
		 * 		save
		 * 			args(1) create true/false
		 * 		read
		 * 		query
		 * 		delete
		 * 		switchStatus
		 */
		draftOperation: function(op) {
			switch (op) {
				case "wrkcpyUpdate":
					return this._wrkcpyUpdate(arguments[1]);
				case "wrkcpyRead":
					return this._wrkcpyRead(arguments[1]);
				case "wrkcpyDelete":
					return this._wrkcpyDelete(arguments[1]);
				case "wrkcpyCreate":
					return this._wrkcpyCreate(arguments[1], arguments[2]);
				case "wrkcpyDeleteAll":
					return this._wrkcpyDeleteAll(arguments[1]);
				case "draftSave":
					return this._draftSave(arguments[1]);
				case "draftDelete":
					return this._draftDelete(arguments[1]);
				case "draftDeleteAll":
					return this._draftDeleteAll();
				case "draftRead":
					return this._draftRead(arguments[1]);
				case "draftReadList":
					return this._draftReadList();
				case "draftCount":
					return this._draftCount(false);
				case "draftNotifyChanged":
					var self = this;
					setTimeout(function() {
						self._draftNotifyChanged();
					});
					return;
				default:
					return $.smReject(storageInterface.buildErrResult("Unknown Draft operation[" + op + "]"));
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/storage/storageWebSQLTemplates',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/storage/storageWebSQLDrafts','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var Base = require('syracuse-tablet/html/js/storage/storageWebSQLDrafts').Klass;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("templates", false);
/**
 * WebSQL storage interface - TEMPLATES MANAGEMENT
 * Inherits from storageWebSQLSData only to split the code
 */

var _TMPL_INSERT = "INSERT INTO sdata_templates (id, endpoint, representation, title, dataSet, creation_date) values (?, ?, ?, ?, ?, ?)";
var _TMPL_DELETE_ALL = "DELETE FROM sdata_templates";
var _TMPL_DELETE = "DELETE FROM sdata_templates where id = ?";
var _TMPL_READ = "SELECT * FROM sdata_templates where id = ?";
var _TMPL_QUERY = "SELECT id, endpoint, representation, title, creation_date FROM sdata_templates";
var _TMPL_COUNT = "SELECT COUNT(*) AS counter FROM sdata_templates";
var _tables = {
	"sdata_templates": [
		"DROP TABLE IF EXISTS sdata_templates",
		"CREATE TABLE sdata_templates ( " +
		"id text, " +
		"endpoint text, " +
		"representation text, " +
		"title text, " +
		"dataSet text, " +
		"creation_date text" +
		")",
		"DROP INDEX IF EXISTS sdata_templates",
		"CREATE UNIQUE INDEX sdata_templates_id ON sdata_templates (id)"
	]
};

var _logError = function(title, status) {
	log && log(title + " ERROR");
	log && log(storageInterface.resultToString(status));
};
/**
 * Manages templates (edit/create facets) storage
 */
var _Klass = utils.defineClass(
	function() {
		Base.call(this);
	}, Base, {
		getTables: function() {
			var res = Base.prototype.getTables.call(this);
			$.extend(res, _tables);
			return res;
		},
		_tmplReadInfo: function(item) {
			if (!item) return null;
			try {
				return {
					"id": item.id,
					"endpoint": item.endpoint || "",
					"representation": item.representation || "",
					"title": item.title || "",
					"dataSet": item.dataSet ? JSON.parse(item.dataSet) : null,
					"creation_date": item["creation_date"]
				};
			} catch (e) {
				log && log("_tmplReadInfo", "KO", item.id);
				return null;
			}
		},
		/**
		 * Resolve with [resources]/[] or reject with a exception
		 */
		_tmplQuery: function(representation, endpoint) {
			var self = this;
			var deferred = $.Deferred();
			var req = _TMPL_QUERY;
			var params = [];
			if (representation || endpoint) {
				req += " where ";
				if (representation) {
					req += "representation = ?";
					params.push(representation);
					if (endpoint) {
						req += " and ";
					}
				}
				if (endpoint) {
					req += "endpoint = ?";
					params.push(endpoint);
				}
			}
			self._executeSql(req, params)
				.then(function(result) {
					log && log("_tmplQuery", "OK");
					if (!result || !result.rows || result.rows.length == 0) {
						return deferred.resolve([]);
					}
					var resources = [],
						rec;
					for (var i = 0; i < result.rows.length; i++) {
						rec = self._tmplReadInfo(result.rows.item(i));
						if (rec) {
							resources.push(rec);
						}
					}
					deferred.resolve(resources);
				}).fail(function(status) {
					_logError("_tmplQuery", status);
					deferred.reject(status.$exception || new Error(status.message));
				});
			return deferred.promise();
		},
		/**
		 * Resolve with data/null or reject with a exception
		 */
		_tmplRead: function(id) {
			var self = this;
			var deferred = $.Deferred();
			self._executeSql(_TMPL_READ, [id]).then(function(result) {
				log && log("_tmplRead", id, "OK");
				if (!result || !result.rows || result.rows.length == 0) {
					return deferred.resolve(null);
				}
				deferred.resolve(self._tmplReadInfo(result.rows.item(0)));
			}).fail(function(status) {
				_logError("_tmplRead", status);
				deferred.reject(status.$exception || new Error(status.message));
			});
			return deferred.promise();
		},
		/**
		 * Resolve or reject with a exception
		 */
		_tmplUpdate: function(id, ctx) {
			var self = this;
			return self._tmplRead(id).then(function(result) {
				if (!result || !ctx) return;
				return self._tmplSave($.extend(result, ctx), false);
			});
		},
		/**
		 * Resolve or reject with a exception
		 */
		_tmplDelete: function(id) {
			var self = this;
			var deferred = $.Deferred();
			self._executeSql(_TMPL_DELETE, [id]).then(function(result) {
				log && log("_tmplDelete", id, result ? "OK" : "KO");
				deferred.resolve();
			}).fail(function(status) {
				_logError("_tmplDelete", status);
				deferred.reject(status.$exception || new Error(status.message));
			});
			return deferred.promise();
		},
		/**
		 * Resolve or reject with a exception
		 */
		_tmplDeleteAll: function() {
			var self = this;
			var deferred = $.Deferred();
			self._executeSql(_TMPL_DELETE_ALL).then(function(result) {
				log && log("_tmplDeleteAll OK");
				deferred.resolve();
			}).fail(function(status) {
				_logError("_tmplDeleteAll", status);
				deferred.reject(status.$exception || new Error(status.message));
			});
			return deferred.promise();
		},
		/**
		 * Resolve with template context or reject with an exception
		 */
		_tmplSave: function(ctx, updateDate) {
			var self = this;
			var deferred = $.Deferred();
			if (!ctx || !ctx.id) {
				log && log("_tmplSave error", "Invalid parameters");
				deferred.reject(new Error("Invalid parameters"));
			} else {
				self._tmplDelete(ctx.id).then(function() {
					if (ctx["creation_date"] == null || updateDate) {
						ctx["creation_date"] = utils.getCurISODateTime(new Date());
					}
					return self._executeSql(_TMPL_INSERT, [ctx.id, ctx.endpoint, ctx.representation, ctx.title, JSON.stringify(ctx.dataSet), ctx.creation_date]);
				}).then(function() {
					log && log("_tmplSave", ctx.id, "OK");
					deferred.resolve(ctx);
				}).fail(function(status) {
					_logError("_tmplSave", status);
					deferred.reject(status.$exception || new Error(status.message));
				});
			}
			return deferred.promise();
		},
		_tmplCount: function() {
			return this._executeSql(_TMPL_COUNT, []).then(function(result) {
				return result && result.rows.length > 0 ? result.rows.item(0).counter : 0;
			}).fail(function(status) {
				_logError("_tmplCount", status);
				return 0;
			});
		},
		/**
		 * Templates
		 * op: Operation
		 */
		templateOperation: function(op) {
			switch (op) {
				case "save":
					return this._tmplSave(arguments[1], true);
				case "delete":
					return this._tmplDelete(arguments[1]);
				case "deleteAll":
					return this._tmplDeleteAll();
				case "read":
					return this._tmplRead(arguments[1]);
				case "update":
					return this._tmplUpdate(arguments[1], arguments[2]);
				case "query":
					return this._tmplQuery(arguments[1], arguments[2], arguments[3]);
				case "readall":
					return this._tmplQuery(arguments[1]);
				case "count":
					return this._tmplCount();
				default:
					return $.smReject(storageInterface.buildErrResult("Unknown template operation[" + op + "]"));
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/storage/storageWebSQL',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/mobileDetect','syracuse-tablet/html/js/storage/storageWebSQLTemplates'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("webSQL", false);
var mobileDetect = require('syracuse-tablet/html/js/helpers/mobileDetect');

/*
 * WebSQL storage interface (Chrome, Safari)
 */

/**
 * The top class is storageWebSQLTemplates
 * It's just a trick to split the code that manages Templates/Drafts from the one that manages SDtata in 3 sub classes of storageWebSQLBase
 */
var _storageInterface = require('syracuse-tablet/html/js/storage/storageWebSQLTemplates').Klass;


exports.getStorageInterface = function() {
	return _storageInterface;
};
exports.isAvailable = function() {
	if (mobileDetect.checkBrowserName("chrome") && mobileDetect.isOs("ios")) {
		// IndexedDB works fine also on Chrome/Desktop - We should use it instead of WebSQL
		log && log("chrome on ios - force indexedDB");
		return null;
	}
	return window.openDatabase != null;
};
});

define('syracuse-tablet/html/js/storage/storageIndexedDBBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {"use strict";

/*
 * IndexDB storage interface (Internet Explorer, Firefox)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var Base = storageInterface.Klass;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("indexedDB", false);

// Increase this number to upgrade database to schema described in objectStores
var _databaseVersion = 22;
var _indexedDB = window.indexedDB || window.webkitIndexedDB;

var _logError = function(title, status) {
	log && log(title + " ERROR");
	if (!status) return;
	var request = status.target || status.currentTarget || status.originalTarget;
	if (request && request.error && request.error.message) {
		log && log((request.error.name ? "[" + request.error.name + "]" : "") + request.error.message);
		return;
	}
	log && log(storageInterface.resultToString(status));
};

var _Klass = utils.defineClass(
	function() {
		Base.call(this, "IndexedDB storage interface", _databaseVersion);
	},
	Base, {

		init: function(requester) {
			var self = this;
			requester = requester || "";
			log && log("_INIT " + requester);
			var deferred = $.Deferred();
			var step = globals.isTestEnvironment() ? self._initTestDB() : $.smResolve();
			step.then(function() {
				if (self.db) {
					log && log("DATABASE ALREADY INITIALIZED!");
					return (storageInterface.buildResult(storageInterface.StatusCodes.OK));
				}
				log && log("DATABASE INIT!");
				return self._openDB();
			}).then(function(status) {
				log && log("_openDB OK " + requester);
				deferred.resolve(status);
			}).fail(function(e) {
				_logError("_openDB KO " + requester);
				var msg = self._eventToMessage(e);
				if (msg && msg.toLowerCase().indexOf("versionerrror")) {
					msg += "<br>" + locale.text("db.err.version");
				}
				deferred.reject(storageInterface.buildErrResult(locale.text("db.err.init"), msg));
			});
			return deferred.promise();
		},

		_initTestDB: function(requester) {
			var self = this;
			var deferred = $.Deferred();
			$.smResolve().then(function() {
				if (self.db) {
					self.db.close();
					self.db = null;
				}
				self.useTestDatabase = true;
				self.databaseName = storageInterface.databaseName + "-test";
				log && log("DATABASE IN TEST MODE! " + requester);
				var req = _indexedDB.deleteDatabase(self.databaseName);
				req.onsuccess = function() {
					deferred.resolve();
				};
				req.onerror = function(e) {
					_logError("REQUEST ERROR! " + requester);
					deferred.reject(e);
				};
				req.onblocked = function(e) {
					_logError("REQUEST BLOCKED! " + requester);
					deferred.reject(e);
				};
			}).fail(function(e) {
				_logError("_initTestDB KO " + requester);
				deferred.reject(e);
			});
			return deferred.promise();
		},

		_openDB: function() {
			var deferred = $.Deferred();
			var self = this;
			if (self.useTestDatabase === false && self.db) {
				deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
			} else {
				var request;
				try {
					log && log("Open database, request version: " + self.databaseVersion);
					request = _indexedDB.open(self.databaseName, self.databaseVersion);
					request.onupgradeneeded = function(e) {
						log && log("Open database, need upgrade");
						self.db = (e.target.result || e.target.source);
						self._createObjectStore();
					};
					request.onsuccess = function(e) {
						log && log("Open database, success");
						var db = (e.target.result || e.target.source);
						if (!db.setVersion && (self.databaseVersion != db.version)) {
							log && log("Open database, versions missmatch: " + self.DatabaseVersion + " != " + db.version);
							var sdv = db.setVersion(self.databaseVersion);
							sdv.onsuccess = function(e) {
								log && log("Open database, setting version, success");
								self.db = db;
								self._createObjectStore();
								log && log("Open database, opened");
								deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
							};
							sdv.onerror = function(e) {
								log && log("Open database, setting version, error", e);
								self.db = null;
								deferred.reject(e);
							};
						} else {
							log && log("Open database, opened");
							self.db = db;
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
						}
					};
					request.onerror = function(e) {
						_logError("Open database, error", e);
						self.db = null;
						deferred.reject(e);
					};
				} catch (ex) {
					_logError("Open database, exception", ex);
					self.db = null;
					deferred.reject(ex);
				}
			}
			return deferred.promise();
		},
		/**
		 * Returns the objectStore to create
		 */
		getObjectStores: function() {
			return {};
		},
		// Create schema of database on version change
		_createObjectStore: function() {
			var self = this;
			var db = self.db;
			log && log("Updating database");
			try {
				var objectStores = this.getObjectStores();
				Object.keys(objectStores).forEach(function(name) {
					var os = objectStores[name];
					if (db.objectStoreNames.contains(name)) {
						log && log("Deleting objectStore: " + name);
						db.deleteObjectStore(name);
					}
					log && log("Creating objectStore: " + name);
					var obj = db.createObjectStore(name, os.options);
					Object.keys(os.indexes).forEach(function(iname) {
						var idx = os.indexes[iname];
						log && log("Creating index: " + iname);
						obj.createIndex(iname, idx.key, idx.options);
					});
				});
			} catch (e) {
				// Log because error doesn't bubble to the mail caller (caught by onupgradeneeded)
				_logError("_createObjectStore, error", e);
				throw e;
			}
		},
		_eventToMessage: function(event) {
			var request = event.target || event.currentTarget || event.originalTarget;
			if (request && request.error && request.error.message) {
				return (request.error.name ? "[" + request.error.name + "]" : "") + request.error.message;
			}
			return JSON.stringify(event);
		},
		// Needed because we can't clear the cache manually on FF and IE - #7942
		clearDatabaseSupported: function() {
			return true;
		},
		clearDatabase: function() {
			var self = this;
			var deferred = $.Deferred();
			$.smResolve().then(function() {
				var req = window.indexedDB.deleteDatabase(self.databaseName);
				req.onsuccess = function() {
					deferred.resolve(true);
				};
				req.onerror = function(e) {
					deferred.resolve(false);
					console.log("Database deletion failed");
					console.log(e);
				};
			}).fail(function() {
				deferred.resolve(false);
			});
			return deferred.promise();
		}

	}
);

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/storage/storageIndexedDBSData',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/storage/storageIndexedDBBase','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {"use strict";

/*
 * IndexDB storage interface (Internet Explorer, Firefox)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/storage/storageIndexedDBBase').Klass;
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("sData", false);

var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
var IDBDatabaseException = window.IDBDatabaseException || window.webkitIDBDatabaseException;

var READ_ONLY = (IDBTransaction && IDBTransaction.READ_ONLY) || "readonly";
var READ_WRITE = (IDBTransaction && IDBTransaction.READ_WRITE) || "readwrite";

var _objectStores = {
	"sdata": {
		"options": {
			"autoIncrement": true
		},
		"indexes": {
			"read_write_one": {
				"key": "key_collection_endpoint_context",
				"options": {
					"unique": true
				}
			},
			"read_write_all": {
				"key": "collection_endpoint_context",
				"options": {
					"unique": false
				}
			},
			"read_write_ctx": {
				"key": "context",
				"options": {
					"unique": false
				}
			}
		}
	}
};

var _Klass = utils.defineClass(
	function() {
		Base.call(this);
	},
	Base, {

		getObjectStores: function() {
			var res = Base.prototype.getObjectStores.call(this);
			$.extend(res, _objectStores);
			return res;
		},

		put: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("PUT: ", JSON.stringify(opts));
				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$key, opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_one");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);
				var mustInsert = true;
				var datetime = utils.getCurISODateTime();
				var doInsert = function() {
					var obj = {
						"context": context,
						"collection": opts.$collection,
						"endpoint": opts.$endpoint,
						"key": opts.$key,
						"last_updated": datetime,
						"last_read": datetime,
						"key_collection_endpoint_context": key,
						"collection_endpoint_context": [opts.$collection, opts.$endpoint, context].join("_"),
						"data": opts.$data,
					};
					var reqt = objectStore.add(obj);
					reqt.onerror = function(event) {
						deferred.reject(storageInterface.buildErrResult("error writing to database: " + self._eventToMessage(event)));
					};
					reqt.onsuccess = function(event) {
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
					};
				};
				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							if (opts.$data.$etag) {
								var etag = cr.value && cr.value.data.$etag;
								if (etag === opts.$data.$etag) {
									deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
									return;
								}
							}
							cr["delete"]();
							cr["continue"]();
						} else {
							doInsert();
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error writing to database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						doInsert();
					} else {
						deferred.reject(storageInterface.buildErrResult("error writing to database: " + self._eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error writing to database", e));
			} finally {
				return deferred.promise();
			}
		},

		read: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("READ: ", JSON.stringify(opts));
				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");
				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);
				var key = [opts.$key, opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_one");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);

				request.onsuccess = function(event) {
					try {
						var cr = event.target && event.target.result && event.target.result.value;
						if (!cr) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						} else {
							deferred.resolve(storageInterface.buildResult(
								storageInterface.StatusCodes.OK,
								cr.data,
								null,
								null, {
									$lastRead: cr.last_read,
									$lastUpdated: cr.last_updated
								}));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						// Resolve since it's a logical issue and not neccessarily an error
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + self._eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		query: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("QUERY: ", JSON.stringify(opts));
				if (!opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_all");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);
				var results = [];
				var meta = [];

				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							var data = cr.value.data;
							results.push(data);
							meta.push({
								$lastRead: cr.value.last_read,
								$lastUpdated: cr.value.last_updated
							});
							cr["continue"]();
						} else {
							deferred.resolve(storageInterface.buildResult(
								storageInterface.StatusCodes.OK,
								results,
								null,
								null,
								meta));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						// Resolve since it's a logical issue and not neccessarily an error
						deferred.resolve(storageInterface.buildResult(
							storageInterface.StatusCodes.OK,
							results,
							null,
							null,
							meta));
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + self._eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		remove: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("REMOVE: ", JSON.stringify(opts));
				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$key, opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_one");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);

				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							cr["delete"]();
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
						} else {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error deleting from database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						// Resolve since it's a logical issue and not neccessarily an error
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + self._eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error deleting from database", e));
			} finally {
				return deferred.promise();
			}
		},

		clearCollection: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("CLEAR: ", JSON.stringify(opts));
				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = context;

				//				var index = objectStore.index("read_write_ctx");
				//				var keyRange = IDBKeyRange.only(key);
				//				var request = index.openCursor(keyRange);
				var request = objectStore.openCursor();

				var records = [];

				var deleteMatches = function() {
					$.smForEachPromise(records, function(rec) {
						return self.remove({
							$context: opts.$context,
							$collection: rec.collection,
							$endpoint: rec.endpoint,
							$key: rec.key
						});
					}).then(function() {
						deferred.resolve();
					}).fail(function(e) {
						deferred.reject(e);
					});
				};
				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							if (opts.$collection.test(cr.value.collection)) {
								if (!opts.$not_read_since || cr.value.last_read < opts.$not_read_since) {
									records.push(cr.value);
								}
							}
							cr["continue"]();
						} else {
							deleteMatches();
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						deleteMatches();
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + self._eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		computeCollectionSize: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("SIZE: ", JSON.stringify(opts));
				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = context;

				//				var index = objectStore.index("read_write_ctx");
				//				var keyRange = IDBKeyRange.only(key);
				//				var request = index.openCursor(keyRange);
				var request = objectStore.openCursor();
				var returnData = {
					numRecords: 0,
					sizeRecords: 0
				};

				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							if (opts.$collection.test(cr.value.collection)) {
								if (!opts.$not_read_since || cr.value.last_read < opts.$not_read_since) {
									returnData.numRecords++;
									returnData.sizeRecords += JSON.stringify(cr.value).length;
								}
							}
							cr["continue"]();
						} else {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, returnData));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						deferred.resolve();
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + self._eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		}
	}
);

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/storage/storageIndexedDBDrafts',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/storage/storageIndexedDBSData','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {"use strict";

/*
 * IndexDB storage interface (Internet Explorer, Firefox)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var Base = require('syracuse-tablet/html/js/storage/storageIndexedDBSData').Klass;
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("drafts", false);
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
var IDBDatabaseException = window.IDBDatabaseException || window.webkitIDBDatabaseException;

var READ_ONLY = (IDBTransaction && IDBTransaction.READ_ONLY) || "readonly";
var READ_WRITE = (IDBTransaction && IDBTransaction.READ_WRITE) || "readwrite";


var _objectStores = {
	"drafts": {
		"options": {
			"keyPath": "id",
			"autoIncrement": true
		},
		"indexes": {}
	},
	"workingcopies": {
		"options": {
			"keyPath": "id",
			"autoIncrement": true
		},
		"indexes": {}
	}
};

var _logError = function(who, e) {
	if (!log) return;
	log("INDEXED DB - ERROR");
	for (var i = 0; i < arguments.length; i++) {
		var e = arguments[i];
		if (typeof e === "string") {
			log(e);
			continue;
		}
		if (e && e.target) {
			if (e.target.errorCode != IDBDatabaseException.NOT_FOUND_ERR) {
				log(JSON.stringify(e, null, 2));
				continue;
			}
		}
		log(JSON.stringify(jsutils.convertToDiagnoses(e), null, 2));
	}
};

var _objName = function(type) {
	return type === "d" ? "drafts" : "workingcopies";
};
/**
 * Manages drafts and working copies storage
 */
var _Klass = utils.defineClass(
	function() {
		Base.call(this);
	},
	Base, {
		/** Overridden method */
		getObjectStores: function() {
			var res = Base.prototype.getObjectStores.call(this);
			$.extend(res, _objectStores);
			return res;
		},

		/** OMethods below are private - Use a dedicated name specific to the class */

		/**
		 * type: d for drafts -  w for workingcopies
		 * Resolves with object store or rejects
		 */
		_draftsObjectStore: function(type, readOpt) {
			var self = this;
			var deferred = $.Deferred();
			try {
				var tx = self.db.transaction([_objName(type)], readOpt || READ_WRITE);
				tx.oncomplete = function(event) {
					log && log("tx.oncomplete", JSON.stringify(event, null, 2));
				};
				tx.onerror = function(event) {
					log && log("tx.onerror", JSON.stringify(event, null, 2));
					//_logError({$diagnoses: [{$message : _objName(type) + " - - IndexedDB.Transaction error", $stackTrace: self._eventToMessage(event)}]});
				};
				deferred.resolve(tx.objectStore(_objName(type)));
			} catch (e) {
				_logError('_draftsObjectStore - ' + _objName(type), e);
				deferred.reject(e);
			}
			return deferred.promise();
		},
		/**
		 * type: d for drafts -  w for workingcopies
		 * Resolves with data if record identified by id or null
		 * fail = true to reject if error
		 */
		_draftGetObject: function(type, id, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._draftsObjectStore(type, READ_ONLY).then(function(objectStore) {
				var request = objectStore.get(id);
				request.onsuccess = function(event) {
					try {
						var result = request.result && request.result.data ? JSON.parse(request.result.data) : null;
						deferred.resolve(result);
						log && log("_draftGetObject - " + _objName(type), "OK");
					} catch (e) {
						log && log("_draftGetObject - " + _objName(type), "Error parsing data");
						if (fail) {
							deferred.reject({
								$diagnoses: [{
									$message: "_draftGetObject - " + _objName(type) + " - Error parsing data"
								}]
							});
						} else {
							deferred.resolve(null);
						}
					}
				};
				request.onerror = function(event) {
					_logError("_draftGetObject - " + _objName(type), event);
					if (fail) {
						deferred.reject({
							$diagnoses: [{
								$message: _objName(type) + " - IndexedDB.OpenCursor error",
								$stackTrace: self._eventToMessage(event)
							}]
						});
					} else {
						deferred.resolve(null);
					}
				};
			}).fail(function(e) {
				if (fail) {
					deferred.reject(e);
				} else {
					deferred.resolve(null);
				}
			});
			return deferred.promise();
		},
		/**
		 * type: d for drafts -  w for workingcopies
		 * Resolves with and array of all records or []
		 * fail = true to reject if error
		 */
		_draftGetAllObjects: function(type, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._draftsObjectStore(type, READ_ONLY).then(function(objectStore) {
				// objectStore.getAll not implemented in FF
				var request = objectStore.openCursor();
				var result = [],
					data;
				request.onsuccess = function(event) {
					var cursor = event.target.result;
					if (cursor) {
						try {
							data = cursor.value && cursor.value.data ? JSON.parse(cursor.value.data) : null;
							if (data) {
								result.push(data);
							}
						} catch (e) {
							log && log("_draftGetAllObjects - " + _objName(type), "Error parsing data");
						}
						cursor.continue ();
					} else {
						log && log("_draftGetAllObjects - " + _objName(type), "OK");
						deferred.resolve(result);
					}
				};
				request.onerror = function(event) {
					_logError("_draftGetAllObjects - " + _objName(type), event);
					if (fail) {
						deferred.reject({
							$diagnoses: [{
								$message: _objName(type) + " - IndexedDB.openCursor error",
								$stackTrace: self._eventToMessage(event)
							}]
						});
					} else {
						deferred.resolve([]);
					}
				};
			}).fail(function(e) {
				if (fail) {
					deferred.reject(e);
				} else {
					deferred.resolve([]);
				}
			});
			return deferred.promise();
		},
		/**
		 * type: d for drafts - w for workingcopies
		 * Create a record of update the existing one if any
		 * Resolves with data  and true if record has been created
		 * fail = true to reject if error
		 */
		_draftPutObject: function(type, id, data, fail) {
			var self = this;
			var deferred = $.Deferred();
			if (!data || !id) {
				_logError("_draftPutObject - " + _objName(type), "Invalid parameters");
				if (fail) {
					deferred.reject({
						$diagnoses: [{
							$message: "_draftPutObject - " + _objName(type) + " - Invalid parameters"
						}]
					});
				} else {
					deferred.resolve(null);
				}
			} else {
				self._draftsObjectStore(type, READ_WRITE).then(function(objectStore) {
					var _put = function(created) {
						var request = objectStore.put({
							"id": id,
							"data": JSON.stringify(data),
							"creation_date": utils.getCurISODateTime(new Date())
						});
						request.onsuccess = function(event) {
							log && log("_draftPutObject - " + _objName(type), "OK");
							deferred.resolve(data, created);
						};
						request.onerror = function(event) {
							_logError("_draftPutObject - " + _objName(type), event);
							if (fail) {
								deferred.reject({
									$diagnoses: [{
										$message: _objName(type) + " - IndexedDB.put error",
										$stackTrace: self._eventToMessage(event)
									}]
								});
							} else {
								deferred.resolve(null);
							}
						};
					};
					// Just to return created or updated
					var request = objectStore.get(id);
					request.onsuccess = function(event) {
						_put(true);
					};
					request.onerror = function(event) {
						_put(false);
					};
				}).fail(function(e) {
					if (fail) {
						deferred.reject(e);
					} else {
						deferred.resolve(null);
					}
				});
			}
			return deferred.promise();
		},
		/**
		 * type: d for drafts - w for workingcopies
		 * Delete a record if any
		 * Resolves with true (deleted) or false (no record deleted)
		 * fail = true to reject if error
		 */
		_draftDeleteObject: function(type, id, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._draftsObjectStore(type, READ_WRITE).then(function(objectStore) {
				var request = objectStore["delete"](id);
				request.onsuccess = function(event) {
					log && log("_draftDeleteObject - " + _objName(type), "OK");
					deferred.resolve(true);
				};
				request.onerror = function(event) {
					_logError("_draftDeleteObject - " + _objName(type), event);
					if (fail) {
						deferred.reject({
							$diagnoses: [{
								$message: _objName(type) + " -  IndexedDB.delete error",
								$stackTrace: self._eventToMessage(event)
							}]
						});
					} else {
						deferred.resolve(false);
					}
				};
			}).fail(function(e) {
				if (fail) {
					deferred.reject(e);
				} else {
					deferred.resolve(false);
				}
			});
			return deferred.promise();
		},
		/**
		 * type: d for drafts - w for workingcopies
		 * Delete all records
		 * Resolves with true (deleted) or false (no record deleted)
		 * fail = true to reject if error
		 */
		_draftDeleteAllObjects: function(type, id, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._draftsObjectStore(type, READ_WRITE).then(function(objectStore) {
				var request = objectStore.clear();
				request.onsuccess = function(event) {
					log && log("_draftDeleteAllObjects" + _objName(type), "OK");
					deferred.resolve(true);
				};
				request.onerror = function(event) {
					_logError("_draftDeleteAllObjects" + _objName(type), event);
					if (fail) {
						deferred.reject({
							$diagnoses: [{
								$message: _objName(type) + " -  IndexedDB.clear error",
								$stackTrace: self._eventToMessage(event)
							}]
						});
					} else {
						deferred.resolve(false);
					}
				};
			}).fail(function(e) {
				if (fail) {
					deferred.reject(e);
				} else {
					deferred.resolve(false);
				}
			});
			return deferred.promise();
		},
		/**
		 * type: d for drafts - w for workingcopies
		 * Count all records
		 * Resolves with count
		 * fail = true to reject if error
		 */
		_draftCountAllObjects: function(type, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._draftsObjectStore(type, READ_ONLY).then(function(objectStore) {
				var request = objectStore.count();
				request.onsuccess = function(event) {
					log && log("_draftCountAllObjects" + _objName(type), "OK", request.result);
					deferred.resolve(request.result);
				};
				request.onerror = function(event) {
					_logError("_draftCountAllObjects" + _objName(type), event);
					if (fail) {
						deferred.reject({
							$diagnoses: [{
								$message: _objName(type) + " -  IndexedDB.count error",
								$stackTrace: self._eventToMessage(event)
							}]
						});
					} else {
						deferred.resolve(0);
					}
				};
			}).fail(function(e) {
				if (fail) {
					deferred.reject(e);
				} else {
					deferred.resolve(0);
				}
			});
			return deferred.promise();
		},
		/**
		 * Resolve with data/null
		 */
		_wrkcpyRead: function(id) {
			return this._draftGetObject("w", id, false);
		},
		/**
		 * Resolve with  true/false
		 * Delete all the working copies that belong to transaction_id
		 */
		_wrkcpyDelete: function(id) {
			return this._draftDeleteObject("w", id, false);
		},
		/**
		 * Resolve with true/false
		 */
		_wrkcpyDeleteAll: function() {
			return this._draftDeleteAllObjects("w", false);
		},
		/**
		 * Resolve with dataSet/null
		 */
		_wrkcpyUpdate: function(dataSet) {
			if (!dataSet) {
				return $.smResolve(null);
			}
			return this._draftPutObject("w", dataSet.$uuid, dataSet, false);
		},
		_wrkcpyCreate: function(dataSet) {
			return this._wrkcpyUpdate(dataSet);
		},
		/**
		 * Resolve with [resources]/[]
		 */
		_draftReadList: function() {
			return this._draftGetAllObjects("d", false);
		},
		/**
		 * Resolve with data/null
		 */
		_draftRead: function(id) {
			return this._draftGetObject("d", id, false);
		},
		/**
		 * Resolve with  true/false
		 */
		_draftDelete: function(id) {
			var self = this;
			return self._draftDeleteObject("d", id, false).then(function(result) {
				self._draftNotifyChanged();
				return result;
			});
		},
		/**
		 * Resolve with true/false
		 */
		_draftDeleteAll: function() {
			var self = this;
			return self._deleteAllObject("d", false).then(function(result) {
				self._draftNotifyChanged();
				return result;
			});
		},
		/**
		 * Resolve with draft context or reject with an exception
		 */
		_draftSave: function(ctx) {
			if (!ctx) {
				return $.smResolve(null);
			}
			var self = this;
			return self._draftPutObject("d", ctx.id, ctx, false).then(function(data, created) {
				if (created) {
					self._draftNotifyChanged();
				}
				return data;
			});
		},
		_draftCount: function(notify) {
			return this._draftCountAllObjects("d", false).then(function(count) {
				if (notify) {
					notifications.publish("sm.drafts.changed", count);
				}
				return count;
			});
		},
		/**
		 * Notifies to update the number of draft in 'List of draft' menu item
		 */
		_draftNotifyChanged: function() {
			return this._draftCount(true);
		},
		/**
		 * Drafts
		 * op: Operation
		 * 		save
		 * 			args(1) create true/false
		 * 		read
		 * 		query
		 * 		delete
		 * 		switchStatus
		 */
		draftOperation: function(op) {
			switch (op) {
				case "wrkcpyUpdate":
					return this._wrkcpyUpdate(arguments[1]);
				case "wrkcpyRead":
					return this._wrkcpyRead(arguments[1]);
				case "wrkcpyDelete":
					return this._wrkcpyDelete(arguments[1]);
				case "wrkcpyCreate":
					return this._wrkcpyCreate(arguments[1], arguments[2]);
				case "wrkcpyDeleteAll":
					return this._wrkcpyDeleteAll(arguments[1]);
				case "draftSave":
					return this._draftSave(arguments[1]);
				case "draftDelete":
					return this._draftDelete(arguments[1]);
				case "draftDeleteAll":
					return this._draftDeleteAll();
				case "draftRead":
					return this._draftRead(arguments[1]);
				case "draftReadList":
					return this._draftReadList();
				case "draftCount":
					return this._draftCount(false);
				case "draftNotifyChanged":
					var self = this;
					setTimeout(function() {
						self._draftNotifyChanged();
					});
					return;
				default:
					return $.smReject(storageInterface.buildErrResult("Unknown Draft operation[" + op + "]"));
			}
		}
	}
);

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/storage/storageIndexedDBTemplates',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/storage/storageIndexedDBDrafts','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var Base = require('syracuse-tablet/html/js/storage/storageIndexedDBDrafts').Klass;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("templates", false);

var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
var IDBDatabaseException = window.IDBDatabaseException || window.webkitIDBDatabaseException;

var READ_ONLY = (IDBTransaction && IDBTransaction.READ_ONLY) || "readonly";
var READ_WRITE = (IDBTransaction && IDBTransaction.READ_WRITE) || "readwrite";


var _objectStores = {
	"edittemplates": {
		"options": {
			"keyPath": "id",
			"autoIncrement": true
		},
		"indexes": {
			"repandep": {
				"key": ["representation", "endpoint"],
				"options": {
					"unique": false
				}
			}
		}
	}
};

var _logError = function(who, e) {
	if (!log) return;
	log("INDEXED DB - ERROR");
	for (var i = 0; i < arguments.length; i++) {
		var e = arguments[i];
		if (typeof e === "string") {
			log(e);
			continue;
		}
		if (e && e.target) {
			if (e.target.errorCode != IDBDatabaseException.NOT_FOUND_ERR) {
				log(JSON.stringify(e, null, 2));
				continue;
			}
		}
		log(JSON.stringify(jsutils.convertToDiagnoses(e), null, 2));
	}
};

var _Klass = utils.defineClass(
	function() {
		Base.call(this);
	},
	Base, {
		/** Overridden method */
		getObjectStores: function() {
			return $.extend(Base.prototype.getObjectStores.call(this), _objectStores);
		},

		/** !! Methods below are private - Use a dedicated name specific to the class - Not shared with drafts or sdata*/
		_tmplOnError: function(deferred, event, fail, value, caller) {
			_logError(caller, event);
			if (fail) {
				deferred.reject({
					$diagnoses: [{
						$message: "IndexedDB Error - " + caller,
						$stackTrace: this._eventToMessage(event)
					}]
				});
			} else {
				deferred.resolve(value);
			}
		},
		_tmplOnExcep: function(deferred, fail, e, value) {
			if (fail) {
				deferred.reject(e);
			} else {
				deferred.resolve(value);
			}
		},
		/**
		 * Resolves with object store or rejects
		 */
		_tmplObjectStore: function(readOpt) {
			var self = this;
			var deferred = $.Deferred();
			try {
				var tx = self.db.transaction("edittemplates", readOpt || READ_WRITE);
				tx.oncomplete = function(event) {
					log && log("tx.oncomplete", JSON.stringify(event, null, 2));
				};
				tx.onerror = function(event) {
					log && log("tx.onerror", JSON.stringify(event, null, 2));
				};
				deferred.resolve(tx.objectStore("edittemplates"));
			} catch (e) {
				_logError('_tmplObjectStore', e);
				deferred.reject(e);
			}
			return deferred.promise();
		},
		/**
		 * Resolves with data if record identified by id or null
		 * fail = true to reject if error
		 */
		_tmplGetObject: function(id, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._tmplObjectStore(READ_ONLY).then(function(objectStore) {
				var request = objectStore.get(id);
				request.onsuccess = function(event) {
					deferred.resolve(request.result);
				};
				request.onerror = function(event) {
					self._tmplOnError(deferred, event, fail, null, "_tmplGetObject");
				};
			}).fail(function(e) {
				self._tmplOnExcep(deferred, fail, e, null);
			});
			return deferred.promise();
		},
		/**
		 * Resolves with and array of all records or []
		 * fail = true to reject if error
		 */
		_tmplGetAllObjects: function(fail, filter) {
			var self = this;
			var deferred = $.Deferred();
			self._tmplObjectStore(READ_ONLY).then(function(objectStore) {
				var request = objectStore.openCursor();
				var result = [],
					data;
				request.onsuccess = function(event) {
					var cursor = event.target.result;
					if (cursor) {
						if (cursor.value && (filter == null || filter(cursor.value) === true)) {
							result.push(cursor.value);
						}
						cursor.continue ();
					} else {
						deferred.resolve(result);
					}
				};
				request.onerror = function(event) {
					self._tmplOnError(deferred, event, fail, [], "_tmplGetAllObjects");
				};
			}).fail(function(e) {
				self._tmplOnExcep(deferred, fail, e, []);
			});
			return deferred.promise();
		},
		/**
		 * Create a record of update the existing one if any
		 * Resolves with data  and true if record has been created
		 * fail = true to reject if error
		 */
		_tmplPutObject: function(data, updateDate, fail) {
			var self = this;
			var deferred = $.Deferred();
			if (!data || !data.id) {
				if (fail) {
					deferred.reject({
						$diagnoses: [{
							$message: "_tmplPutObject - Invalid parameters"
						}]
					});
				} else {
					deferred.resolve(null);
				}
			} else {
				var id = data.id;
				self._tmplObjectStore(READ_WRITE).then(function(objectStore) {
					var _put = function(created) {
						data = $.extend(true, {}, data);
						if (data["creation_date"] == null || updateDate) {
							data["creation_date"] = utils.getCurISODateTime(new Date());
						}
						var request = objectStore.put(data);
						request.onsuccess = function(event) {
							deferred.resolve(data, created);
						};
						request.onerror = function(event) {
							self._tmplOnError(deferred, event, fail, null, "_tmplPutObject");
						};
					};
					// Just to return created or updated
					var request = objectStore.get(id);
					request.onsuccess = function(event) {
						_put(true);
					};
					request.onerror = function(event) {
						_put(false);
					};
				}).fail(function(e) {
					self._tmplOnExcep(deferred, fail, e, null);
				});
			}
			return deferred.promise();
		},
		/**
		 * Delete a record if any
		 * Resolves with true (deleted) or false (no record deleted)
		 * fail = true to reject if error
		 */
		_tmplDeleteObject: function(id, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._tmplObjectStore(READ_WRITE).then(function(objectStore) {
				var request = objectStore["delete"](id);
				request.onsuccess = function(event) {
					deferred.resolve(true);
				};
				request.onerror = function(event) {
					self._tmplOnError(deferred, event, fail, false, "_tmplDeleteObject");
				};
			}).fail(function(e) {
				self._tmplOnExcep(deferred, fail, e, false);
			});
			return deferred.promise();
		},
		/**
		 * Delete all records
		 * Resolves with true (deleted) or false (no record deleted)
		 * fail = true to reject if error
		 */
		_tmplDeleteAllObjects: function(id, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._tmplObjectStore(READ_WRITE).then(function(objectStore) {
				var request = objectStore.clear();
				request.onsuccess = function(event) {
					deferred.resolve(true);
				};
				request.onerror = function(event) {
					self._tmplOnError(deferred, event, fail, false, "_tmplDeleteAllObjects");
				};
			}).fail(function(e) {
				self._tmplOnExcep(deferred, fail, e, false);
			});
			return deferred.promise();
		},
		/**
		 * Count all records
		 * Resolves with count
		 * fail = true to reject if error
		 */
		_tmplCountAllObjects: function(fail) {
			var self = this;
			var deferred = $.Deferred();
			self._tmplObjectStore(READ_ONLY).then(function(objectStore) {
				var request = objectStore.count();
				request.onsuccess = function(event) {
					deferred.resolve(request.result);
				};
				request.onerror = function(event) {
					self._tmplOnError(deferred, event, fail, 0, "_tmplCountAllObjects");
				};
			}).fail(function(e) {
				self._tmplOnExcep(deferred, fail, e, 0);
			});
			return deferred.promise();
		},
		_tmplReadInfo: function(data) {
			if (!data) return null;
			try {
				return {
					"id": data.id,
					"endpoint": data.endpoint || "",
					"representation": data.representation || "",
					"title": data.title || "",
					"dataSet": data.dataSet,
					"creation_date": data["creation_date"]
				};
			} catch (e) {
				log && log("_tmplReadInfo", "KO", data.id);
				return null;
			}
		},
		/**
		 * Resolve with [resources]/[] or reject with a exception
		 * Not supported by IE
		 */
		_tmplQueryWidthCompoundIndex: function(representation, endpoint, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._tmplObjectStore(READ_ONLY).then(function(objectStore) {
				var request;
				if (representation || endpoint) {
					var index = objectStore.index('repandep');
					request = index.openCursor(IDBKeyRange.only([representation, endpoint]));
				} else {
					request = objectStore.openCursor();
				}
				var result = [],
					data;
				request.onsuccess = function(event) {
					var cursor = event.target.result;
					if (cursor && cursor.value) {
						result.push(cursor.value);
						cursor.continue ();
					} else {
						log && log("_tmplQuery - OK");
						deferred.resolve(result);
					}
				};
				request.onerror = function(event) {
					self._tmplOnError(deferred, event, fail, [], "_tmplGetAllObjects");
				};
			}).fail(function(e) {
				self._tmplOnExcep(deferred, fail, e, []);
			});
			return deferred.promise();
		},
		/**
		 * Resolve with [resources]/[] or reject with a exception
		 */
		_tmplQuery: function(representation, endpoint, fail) {
			return this._tmplGetAllObjects(fail, function(value) {
				if (representation != null && representation != value.representation) return false;
				if (endpoint != null && endpoint != value.endpoint) return false;
				return true;
			});
		},
		/**
		 * Resolve with data/null or reject with a exception
		 */
		_tmplRead: function(id) {
			return this._tmplGetObject(id, false);
		},
		/**
		 * Resolve or reject with a exception
		 */
		_tmplUpdate: function(id, ctx) {
			var self = this;
			return self._tmplRead(id).then(function(result) {
				if (!result || !ctx) return;
				return self._tmplSave($.extend(result, ctx), false);
			});
		},
		/**
		 * Resolve or reject with a exception
		 */
		_tmplDelete: function(id) {
			return this._tmplDeleteObject(id, false);
		},
		/**
		 * Resolve or reject with a exception
		 */
		_tmplDeleteAll: function() {
			return this._tmplDeleteAllObjects(false);
		},
		/**
		 * Resolve with template context or reject with an exception
		 */
		_tmplSave: function(ctx, updateDate) {
			var self = this;
			var deferred = $.Deferred();
			if (!ctx || !ctx.id) {
				log && log("_tmplSave error", "Invalid parameters");
				deferred.reject(new Error("Invalid parameters"));
			} else {
				self._tmplDelete(ctx.id).then(function() {
					return self._tmplPutObject(ctx, updateDate, false);
				}).then(function() {
					log && log("_tmplSave", ctx.id, "OK");
					deferred.resolve(ctx);
				}).fail(function(status) {
					_logError("_tmplSave", status);
					deferred.reject(status.$exception || new Error(status.message));
				});
			}
			return deferred.promise();
		},
		_tmplCount: function() {
			return this._tmplCountAllObjects();
		},
		templateOperation: function(op) {
			switch (op) {
				case "save":
					return this._tmplSave(arguments[1], true);
				case "delete":
					return this._tmplDelete(arguments[1]);
				case "deleteAll":
					return this._tmplDeleteAll(arguments[1], arguments[2]);
				case "read":
					return this._tmplRead(arguments[1]);
				case "update":
					return this._tmplUpdate(arguments[1], arguments[2]);
				case "query":
					return this._tmplQuery(arguments[1], arguments[2], arguments[3]);
				case "readall":
					return this._tmplQuery(arguments[1]);
				case "count":
					return this._tmplCount();
				default:
					return $.smReject(storageInterface.buildErrResult("Unknown template operation[" + op + "]"));
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/storage/storageIndexedDB',['require','exports','module','syracuse-tablet/html/js/storage/storageIndexedDBTemplates'],function (require, exports, module) {"use strict";

/*
 * IndexDB storage interface (Internet Explorer, Firefox)
 */

/**
 * The top class is storageIndexedDBTemplates
 * It's just a trick to split the code that manages Templates/Drafts from the one that manages SDtata in 3 sub classes of storageIndexedDBBase
 */
var _storageInterface = require('syracuse-tablet/html/js/storage/storageIndexedDBTemplates').Klass;


exports.getStorageInterface = function() {
	return _storageInterface;
};
exports.isAvailable = function() {
	var indexedDB = window.indexedDB || window.webkitIndexedDB;
	return indexedDB != null;
};
});

define('syracuse-tablet/html/js/storage/storage',['require','exports','module','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/storage/storageWebSQL','syracuse-tablet/html/js/storage/storageIndexedDB'],function (require, exports, module) {"use strict";

/*
 * Storage module (Selects implementation depending on what's available in the current browser
 */

var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');

var _impls = [
	require('syracuse-tablet/html/js/storage/storageWebSQL'),
	require('syracuse-tablet/html/js/storage/storageIndexedDB')
];

var _storageImpl;

// Choose the first supported storage engine
// #8136 noFail used in main error handler 
function _getStorageImpl(noFail) {
	if (_storageImpl) {
		return _storageImpl;
	}

	_impls.some(function(impl) {
		if (impl.isAvailable()) {
			var ctor = impl.getStorageInterface();
			_storageImpl = new ctor();
			return true;
		}
		return false;
	});

	if (_storageImpl == null && noFail !== true) {
		throw new Error("No storage interface (indexedDB or WebSQL) has been found");
	}

	return _storageImpl;
}

exports.getStorage = _getStorageImpl;
exports.StatusCodes = storageInterface.StatusCodes;
});

define('syracuse-tablet/html/js/application/settings',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/storage/storage','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/native/native'],function (require, exports, module) {"use strict";

/*
 * This module should be used to persist user specific settings
 */

var globals = require('syracuse-tablet/html/js/helpers/globals');
var storageModule = require('syracuse-tablet/html/js/storage/storage');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("settings");
var nativeVoiceCommmands = require('syracuse-tablet/html/js/helpers/native/native').getModule("voiceCommands");

var _currentContextUserRole = {};
var _currentContextUser = {};

var _settingsUserRole = null;
var _settingsUser = null;

/*
 *
 */
function _getContext() {
	var ctx = globals.getUserCtx();
	if (!ctx) { // In case not logged in yet!
		return {
			$user: "none",
			$role: "none",
			$lang: "en-US",
		};
	}
	return ctx;
}

/*
 *
 */
function _checkContextUserRole() {
	var ctx = _getContext();
	if (_currentContextUserRole.user != ctx.$user ||
		_currentContextUserRole.role != ctx.$role) {
		_currentContextUserRole.user = ctx.$user;
		_currentContextUserRole.role = ctx.$role;
		_currentContextUserRole.lang = ctx.$lang;
		_settingsUserRole = null;
	}
}

/*
 *
 */
function _readSettingsUserRole() {
	var storage = globals.getStorage();

	var ctx = {
		"$user": _currentContextUserRole.user,
		"$role": _currentContextUserRole.role,
		"$lang": "none"
	};

	return storage.read({
		$context: ctx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: "$user_and_role"
	}).then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			return result.$data;
		} else {
			return {};
		}
	});
}

/*
 *
 */
function _checkContextUser() {
	var ctx = _getContext();
	if (_currentContextUser.user != ctx.$user ||
		_currentContextUser.role != ctx.$role) {
		_currentContextUser.user = ctx.$user;
		_currentContextUser.role = ctx.$role;
		_currentContextUser.lang = ctx.$lang;
		_settingsUser = null;
	}
}

/*
 *
 */
function _readSettingsUser() {
	if (_settingsUser == null) {
		var storage = globals.getStorage();
		var ctx = {
			"$user": _currentContextUser.user,
			"$role": "none",
			"$lang": "none"
		};
		return storage.read({
			$context: ctx,
			$collection: "$settings",
			$endpoint: "$local",
			$key: "$user"
		}).then(function(result) {
			if (result.$status === storageModule.StatusCodes.OK) {
				_settingsUser = result.$data;
			} else {
				_settingsUser = {};
			}
			log && log("Read user settings...");
			log && log(_settingsUser);
		});
	} else {
		return $.smResolve();
	}
}

/*
 *
 */
function _writeSettingsUser() {
	var storage = globals.getStorage();

	var ctx = {
		"$user": _currentContextUser.user,
		"$role": "none",
		"$lang": "none"
	};

	log && log("Writing user settings...");
	log && log(_settingsUser);
	return storage.put({
		$context: ctx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: "$user",
		$data: _settingsUser
	}).then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			return result.$data;
		} else {
			return {};
		}
	});
}

/*
 * ======================================================
 * Pages pinned on welcome page
 * ======================================================
 */

/*
 *
 */
exports.getPinnedPages = function() {
	return _readSettingsUser().then(function() {
		_settingsUser.pinnedPages = _settingsUser.pinnedPages || [];
		return _settingsUser.pinnedPages;
	});
};

/*
 *
 */
exports.addPinnedPage = function(page) {
	return exports.getPinnedPages().then(function(pinnedPages) {
		if (!pinnedPages.some(function(p, idx) {
			if (p.id === page.id) {
				pinnedPages[idx] = page; // Overwrite existing
				return true;
			}
		})) {
			pinnedPages.push(page);
		}
		if (nativeVoiceCommmands) {
			nativeVoiceCommmands.addVoiceCommand(nativeVoiceCommmands.createCommandFromPage(page));
		}
		// No return ... then, because can be done async
		_writeSettingsUser();
		return page;
	});
};

/*
 *
 */
exports.isPinnedPage = function(id) {
	return exports.getPinnedPages().then(function(pinnedPages) {
		return pinnedPages.some(function(p, idx) {
			if (p.id === id) {
				return true;
			}
		});
	});
};

/*
 *
 */
exports.removePinnedPage = function(id) {
	return exports.getPinnedPages().then(function(pinnedPages) {
		if (pinnedPages.some(function(p, idx) {
			if (p.id === id) {
				if (nativeVoiceCommmands) {
					nativeVoiceCommmands.removeVoiceCommand(p.title);
				}

				// ID see also welcomeApplication.js if you change here!
				exports.removeTileConfig("pin-" + p.id);

				pinnedPages.splice(idx, 1); // remove and stop
				return true;
			}
		})) {
			// Only write if there was a change
			// No return ... then, because can be done async
			_writeSettingsUser();
		}
	});
};

/*
 * ======================================================
 * Apps hidden on welcome page
 * ======================================================
 */
/*
 *
 */
exports.getHiddenApplications = function() {
	return _readSettingsUser().then(function() {
		_settingsUser.hiddenApplications = _settingsUser.hiddenApplications || [];
		return _settingsUser.hiddenApplications;
	});
};

/*
 *
 */
exports.unhideApplication = function(applicationName) {
	return exports.getHiddenApplications().then(function(apps) {
		if (apps.some(function(app, idx) {
			if (app === applicationName) {
				apps.splice(idx, 1); // remove and stop
				return true;
			}
		})) {
			// Only write if there was a change
			// No return ... then, because can be done async
			_writeSettingsUser();
		}
	});
};

/*
 *
 */
exports.hideApplication = function(applicationName) {
	return exports.getHiddenApplications().then(function(apps) {
		if (!apps.some(function(app, idx) {
			if (app === applicationName) {
				return true;
			}
		})) {
			apps.push(applicationName);
			// No return ... then, because can be done async
			_writeSettingsUser();
		}
	});
};

/*
 * ======================================================
 * Tiles on welcome page
 * ======================================================
 */
exports.getTileConfigs = function() {
	return _readSettingsUser().then(function() {
		_settingsUser.tileConfigs = _settingsUser.tileConfigs || {};
		return _settingsUser.tileConfigs;
	});
};

exports.setTileConfig = function(tile) {
	return exports.getTileConfigs().then(function(configs) {
		configs[tile.tileId] = tile;
		_writeSettingsUser();
	});
};

exports.removeTileConfig = function(id) {
	return exports.getTileConfigs().then(function(configs) {
		if (configs && configs[id]) {
			delete configs[id];
			_writeSettingsUser();
		}
	});
};


/*
 *
 */
exports.getLastUserProfile = function(profile) {
	var ctx = {
		"$user": "none",
		"$role": "none",
		"$lang": "none"
	};
	var storage = globals.getStorage();
	return storage.read({
		$context: ctx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: "$last_user_profile"
	}).then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			return result.$data;
		} else {
			return null;
		}
	});
};

/*
 *
 */
exports.setLastUserProfile = function(profile) {
	var ctx = {
		"$user": "none",
		"$role": "none",
		"$lang": "none"
	};
	var storage = globals.getStorage();
	return storage.put({
		$context: ctx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: "$last_user_profile",
		$data: profile
	}).then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			return result.$data;
		} else {
			return null;
		}
	});
};


/*
 * These are settings that are understood to be global for the device
 * This should be things that are common for all users, roles, languages that use the current device
 * E.g. is the device type ("auto", "tablet", "smartphone")
 */
exports.getGlobalSettings = function() {
	var storage = globals.getStorage();

	var ctx = {
		"$user": "none",
		"$role": "none",
		"$lang": "none"
	};

	return storage.read({
		$context: ctx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: "$global_settings"
	}).then(function(result) {
		var settings;
		if (result.$status === storageModule.StatusCodes.OK) {
			settings = result.$data;
		} else {
			settings = {
				"device-type": "auto"
			};
		}
		// Store last read settings in a global variable to make the accessible from elsewhere
		globals.setGlobalSettings(settings);
		return settings;
	});
};

exports.setGlobalSettings = function(settings) {
	var storage = globals.getStorage();
	var ctx = {
		"$user": "none",
		"$role": "none",
		"$lang": "none"
	};
	var def = $.Deferred();
	storage.put({
		$context: ctx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: "$global_settings",
		$data: settings
	}).then(function() {
		// Store last stored settings in a global variable to make the accessible from elsewhere
		globals.setGlobalSettings(settings);
		def.resolve(settings);
	}).fail(function(e) {
		def.resolve();
	});
	return def.promise();
};
/*
 * ======================================================
 * Apps hidden on welcome page
 * ======================================================
 */

/**
 * Only purpose it to set the default value of the check box on the login page
 * There is no other functional use case of this setting after login
 * resolve with true/false
 */
exports.getLoginRememberMe = function() {
	return _readSettingsUser().then(function() {
		if (_settingsUser.loginRememberMe !== true) {
			return false;
		}
		return true;
	});
};
/**
 * Only purpose it to save the default value of the check box on the login page
 * There is no other functional use case of this setting after login
 * value: true or false
 */
exports.setLoginRememberMe = function(value) {
	return _readSettingsUser().then(function(apps) {
		value = value !== false;
		if (_settingsUser.loginRememberMe !== value) {
			_settingsUser.loginRememberMe = value;
			_writeSettingsUser();
		}
	});
};
});

define('syracuse-tablet/html/js/init/initContext',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalSelectContext','syracuse-tablet/html/js/sdata/sdataCommonResources','syracuse-tablet/html/js/storage/localStorage','syracuse-tablet/html/js/application/settings'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalSelectContext = require('syracuse-tablet/html/js/ui/modals/modalSelectContext');
var sdataCommonResources = require('syracuse-tablet/html/js/sdata/sdataCommonResources');
var localStorage = require('syracuse-tablet/html/js/storage/localStorage');
var settings = require('syracuse-tablet/html/js/application/settings');

/**
 * Save user profile settings
 */
var _profileSettings = null;
/**
 * True if language exists
 */
var _checkNavigatorLang = function() {
	var navLang = utils.getNavigatorLanguage();
	var result;
	if (_profileSettings && _profileSettings.locales) {
		_profileSettings.locales.some(function(l) {
			if (utils.sameLanguage(l.code, navLang)) {
				result = l.code;
				return true;
			}
		});
	}
	return result || "en-US";
};
/**
 * Read last user context in storage
 */
exports.getLastUsedContext = function(userName) {
	var context;
	try {
		var settingsKey = userName + "_lastContext";
		var contextString = localStorage.getItem(settingsKey);
		if (contextString && contextString.length > 0) {
			context = JSON.parse(contextString);
		}
	} catch (e) {}
	return context;
};
/**
 * Write last user context in storage
 */
exports.setLastUsedContext = function(userName, context) {
	try {
		var settingsKey = userName + "_lastContext";
		var contextString = JSON.stringify(context);
		localStorage.setItem(settingsKey, contextString);
	} catch (e) {}
};
/**
 * Check if context is valid
 */
var _checkContext = function(context) {
	return context && context.language && context.role && context.endpoint ? context : null;
};
/**
 * Display the settings modal dialog to select end-point/role/language
 */
var _askUserSettings = function(currentContext, contextToRestore, fromUserAction, isOffLine) {
	var deferred = $.Deferred();
	// When we open from a link/voice command we hide the endpoints because it's given by contextToRestore
	// We hide the roles if there's a role provided by url context
	// We don't hide the language because it's not provided by contextToRestore (we select the language of the current user)
	var opts = {
		offline: isOffLine,
		hideEndpoints: contextToRestore != null && contextToRestore.endpoint != null,
		hideRoles: contextToRestore != null && contextToRestore.role != null
	};
	// Ask user to select a context or to logout
	new modalSelectContext.Modal(currentContext, _profileSettings, opts, isOffLine).show()
		.then(function(selectedContext) {
			if (selectedContext == null || selectedContext.action !== "ok") {
				// Process canceled
				if ((selectedContext && selectedContext.action === "logout") || fromUserAction !== true) {
					// Goto login if logout or settings canceled in init process
					// message/title are used to manage the user message in login page
					deferred.reject({
						$redirectPage: "login",
						message: "login.authentication",
						title: "logout.msg"
					});
				} else {
					deferred.resolve(null);
				}
				return;
			}
			// Set hidden end-point/role with the values provided by contextToRestore if any
			// Eg voice command: endpoint/role is provided by the context so we set the current user context with these values
			if (opts.hideEndpoints === true) {
				selectedContext.endpoint = contextToRestore.endpoint;
			}
			if (opts.hideRoles === true) {
				selectedContext.role = contextToRestore.role;
			}
			deferred.resolve(selectedContext);
		}).fail(function(e) {
			deferred.reject(e);
		});
	return deferred.promise();
};
/**
 * Resolve with new user context or null
 */
var _updateServerUserProfile = function(userProfile, context, fromUserAction) {
	var change = false;
	var upChanges = {};
	var endPoints = null;
	change = _profileSettings.roles.some(function(role) {
		if (role.code === context.role) {
			endPoints = role.endPoints;
			if (role.$uuid !== userProfile.selectedRole.$uuid) {
				upChanges.selectedRole = {
					$uuid: role.$uuid
				};
				return true;
			}
		}
		return false;
	}) || change;
	change = endPoints && endPoints.some(function(ep) {
		if (ep.code === context.endpoint && (userProfile.selectedEndpoint == null || ep.$uuid !== userProfile.selectedEndpoint.$uuid)) {
			upChanges.selectedEndpoint = {
				$uuid: ep.$uuid
			};
			return true;
		}
		return false;
	}) || change;
	change = _profileSettings.locales.some(function(lang) {
		if (lang.code === context.language && lang.$uuid !== userProfile.selectedLocale.$uuid) {
			upChanges.selectedLocale = {
				$uuid: lang.$uuid
			};
			return true;
		}
		return false;
	}) || change;
	if (change) {
		if (fromUserAction) {
			//#8000  needed for user feedback 
			globals.getApplication().waitWheelStart();
		}
		return sdataCommonResources.updateUserProfile(upChanges).then(function(newProfile) {
			globals.setUserProfile(newProfile);
			return settings.setLastUserProfile(newProfile);
		}).then(function(newProfile) {
			//newProfile null if error saving profile
			return newProfile ? $.extend(context, {
				role: newProfile.selectedRole.code,
				language: newProfile.selectedLocale.code,
				endpoint: newProfile.selectedEndpoint.code
			}) : null;
		});
	} else {
		// make sure userProfile is always up to date on client side
		return settings.setLastUserProfile(userProfile)
			.then(function() {
				return null;
			});
	}
};
/**
 * We assume that
 * 		the user is logged in (userCtx and Syracuse session)
 * 		the user profile is available (read after login)
 * fromUserAction	true if it's the user who asks for switching the context (-> dialog)
 * 					false if it's called from an initialization process (after login)
 * contextToRestore	Only if called from initialization process
 * 					Context to restore after login
 * offlineLogin		true if init is called from offline login page
 * Resolve with
 * 					userContext - Null if login needed
 * 					contextToRestore - null if not valid
 */
exports.init = function(fromUserAction, contextToRestore, offlineLogin) {
	if (fromUserAction !== true) {
		// Clear on init or after new login
		_profileSettings = null;
	}
	var userProfile = globals.getUserProfile();
	if (!userProfile) {
		throw new Error("Unexpected empty user profile");
	}
	var userName = userProfile.user.$value;
	// True if an http status 0 occurred
	var isOffLine = offlineLogin == true || globals.isOnline() !== true;
	// About getGlobalSettings:
	// -> Settings are read here just so they are put into the globals to make them available later,
	// -> they are not needed here at all but it's a good place to read them
	var step = settings.getGlobalSettings();
	var def = $.Deferred();
	if (offlineLogin) {
		step.then(function() {
			// If init-context is called from offlineLogin login we need a context
			if (_checkContext(exports.getLastUsedContext(userName))) {
				return;
			}
			return $.smReject(new Error("offline.nocontext"));
		})
			.then(function(e) {
				def.resolve(e);
			})
			.fail(function(e) {
				def.reject(e);
			});
	} else if (_profileSettings) {
		step.then(function() {
			return sdataCommonResources.isConnectionAlive();
		})
			.then(function(alive) {
				isOffLine = alive !== true;
			})
			.then(function(e) {
				def.resolve(e);
			})
			.fail(function(e) {
				def.reject(e);
			});
	} else {
		step.then(function() {
			// Read settings in one shot
			return sdataCommonResources.getUserProfileSettings();
		}).then(function(profileSettings) {
			_profileSettings = profileSettings;
			def.resolve();
		}).fail(function(e) {
			if (e.$noConnectionError) {
				isOffLine = true;
				def.resolve();
				return;
			}
			def.reject(e);
		});
	}
	return def.then(function() {
		if (contextToRestore) {
			var lastCtx = exports.getLastUsedContext(userName);
			// Like language is not provided contextToRestore we take the last context language or navigator language to avoid display of modalSelectContext
			contextToRestore.language = lastCtx ? lastCtx.language : _checkNavigatorLang();
			// Context set to null if not valid
			contextToRestore = _checkContext(contextToRestore);
			if (contextToRestore) {
				// No setting dialog - context provided by contextToRestore
				return $.smResolve(contextToRestore);
			}
		}
		var currentContext = _checkContext(exports.getLastUsedContext(userName));
		// !!! Dialog is displayed if:
		//  -> Initcontext called by the user (change profile)
		//  -> No context at initialization even if connectionFailedError (only logout button in that case)
		if (fromUserAction === true || currentContext == null) {
			if (currentContext == null) {
				// Set the context given by user profile (values to select)
				currentContext = {
					role: userProfile.selectedRole.code,
					language: userProfile.selectedLocale.code,
					endpoint: userProfile.selectedEndpoint.code
				};
			}
			return _askUserSettings(currentContext, contextToRestore, fromUserAction, isOffLine);
		} else {
			// Restore the context provided or the last context
			return $.smResolve(currentContext);
		}
	}).then(function(selectedContext) {
		if (selectedContext == null) {
			// Null selectedContext means process has been canceled
			return null;
		}
		if (offlineLogin === true) {
			// In offline mode we just enable logout or cancel
			return null;
		}
		// Set user context in any case
		globals.setUserCtx({
			"$user": userName,
			"$role": selectedContext.role,
			"$lang": selectedContext.language
		});
		// Locale for client UI
		locale.setLocale(selectedContext.language);
		// Endpoint for storing records locally and to use for gadgets with default endpoint usage
		globals.setEndpoint(selectedContext.endpoint, selectedContext.endpointDescr);
		exports.setLastUsedContext(userName, selectedContext);
		return _updateServerUserProfile(userProfile, selectedContext, fromUserAction);
	}).then(function(selectedContext) {
		// contextToRestore is null null if not valid
		// canceled (selectedContext==null) is used fromUserAction=true only
		return $.smResolve(contextToRestore, fromUserAction ? selectedContext == null : null);
	});
};
/**
 * Context asked by user
 * Resolves with cancel true/false
 */
exports.askNewContext = function() {
	return exports.init(true).then(function(contextToRestore, canceled) {
		return canceled;
	});
};
/**
 * Switch to contextToRestore
 * User context endpoint will be set to contextToRestore.endpoint if any
 * Used by voice command to set the current context with the one of the command (pinned page)
 */
exports.switchContext = function(contextToRestore) {
	if (!contextToRestore) return;
	var contextToRestore = $.extend(true, {}, contextToRestore);
	if (!contextToRestore.endpoint) {
		contextToRestore.endpoint = globals.getEndpoint();
	}
	var userCtx = globals.getUserCtx();
	if (!contextToRestore.language) {
		contextToRestore.language = userCtx.$lang;
	}
	if (!contextToRestore.role) {
		contextToRestore.role = userCtx.$role;
	}
	return exports.init(false, contextToRestore);
};
});

define('syracuse-tablet/html/js/sdata/entities/clientContract',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/sdata/sdataUtils'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');

var _LOCAL_ENTITIES_URL = "http://localhost:8124/mobile1/x3/erp/local";

var _entities = {};

var _propertiesToCopy = [
	// ui related
	"$title",
	"$isExcluded",
	"$isHidden",
	"$isMandatory",
	"$isReadOnly",
	"$isDisabled",

	// for formats
	"$format",
	"$x3Format",

	// for quantity and ref fields
	"$unit",
	"$value",
	"$shortTitle",
	"$capabilities",
	"$item",

	// constraints according to https://github.com/Sage-ERP-X3/platform/wiki/Resource-Prototypes
	"$minimum",
	"$maximum",
	"$exclusiveMinimum",
	"$exclusiveMaximum",
	"$minItems",
	"$maxItems",
	"$isNullable",
	"$isUnique",
	"$pattern",
	"$minLength",
	"$maxLength",
	"$precision",
	"$scale",
	"$enum",
	"$format",

	// For stored data
	"$url"
];

exports.registerApp = function(app) {
	globals.getMetaData().registerStaticApp(app);
};

exports.registerEntity = function(entity) {
	_entities[entity.$entityName] = entity;
};

exports.getEntity = function(entity) {
	return _entities[entity];
};


exports.getPageInfo = function(name, options) {
	var repr = name.split(".");
	if (repr.length === 5) {
		repr = repr.slice(3, 5);
	}
	if (repr[0].smStartsWith("QUERY~") || repr[0].smStartsWith("STATS~")) {
		var p = repr[0].split("~");
		repr[0] = p[1];
	}
	var ent = _entities[repr[0]];
	if (!ent) {
		return null;
	}
	var state = {
		home: false,
		type: "regular",
		subtype: repr[1] ? repr[1].substring(1) : "unknown",
		cached: false,
		refreshed: false
	};
	state.name = name;
	return state;
};

exports.getRegularPageInfo = function(pageId) {
	var repr = pageId.split(".");
	if (repr.length === 5) {
		repr = repr.slice(3, 5);
	}

	if (repr[0].smStartsWith("QUERY~") || repr[0].smStartsWith("STATS~")) {
		var p = repr[0].split("~");
		repr[0] = p[1];
	}

	var ent = _entities[repr[0]];
	var pageInfo;
	if (ent) {
		pageInfo = _buildPageInfo(repr[0], repr[1], ent);
	}
	return $.smResolve(pageInfo);
};

function _buildPageInfo(repr, facet, entity) {
	var page = {
		$page: {},
		$cache: {}
	};
	_buildPage(repr, facet, entity, page.$page);
	return page;
}

function _buildPage(repr, facet, entity, page) {
	if (facet.smStartsWith("$cube")) {
		// FDB - smStartsWith tto be able to have multiple facets $cube$, $cubechart in an entity for test
		// $cube for table display $cubechart for chart
		page.$prototype = entity.$createProto();
	} else if (facet === "$query" || facet === "$lookup") {
		page.$prototype = {
			$properties: {
				$resources: {
					$type: "application/x-array",
					$item: _buildPrototype(repr, facet),
					$url: "{$baseUrl}/" + repr + "('{$key}')?representation=" + repr + ".$queryItem",
				}
			}
		};
		page.$prototype.$url = "{$baseUrl}/" + repr + "?representation=" + repr + "." + facet;
		page.$prototype.$properties.$resources.$item.$key = "{$uuid}";
		page.$prototype.$properties.$resources.$item.$value = entity.$value;
		page.$prototype.$properties.$resources.$item.$links = {
			$details: {
				$url: "{$baseUrl}/" + repr + "('{$key}')?representation=" + repr + ".$details",
				$title: "Details"
			},
			$edit: {
				$url: "{$baseUrl}/" + repr + "('{$key}')?representation=" + repr + ".$edit",
				$title: "Edit"
			}
		};
		page.$prototype.$links = {
			$create: {
				$url: "{$baseUrl}/" + repr + "('{$key}')?representation=" + repr + ".$create",
				$title: "Create New"
			}
		};
		page.$prototype.$key = "{$uuid}";
	} else {

		page.$prototype = _buildPrototype(repr, facet);
		page.$prototype.$url = "{$baseUrl}/" + repr + "('{$key}')?representation=" + repr + "." + facet;
		page.$prototype.$key = "{$uuid}";
		page.$prototype.$links = {};

		// links to set in a json variable
		var links = {
			$edit: {
				$url: "{$baseUrl}/" + repr + "('{$key}')?representation=" + repr + ".$edit",
				$title: "Edit"
			},
			$query: {
				$url: "{$baseUrl}/" + repr + "?representation=" + repr + ".$query",
				$title: "List"
			},
			$save: {
				$url: "{$baseUrl}/" + repr + "('{$key}')?representation=" + repr + ".$save",
				$title: "Save"
			},
			$details: {
				$url: "{$baseUrl}/" + repr + "('{$key}')?representation=" + repr + ".$details",
				$title: "Detail"
			}
		};

		// add links according to facet (remainting facets are '$details', '$edit', '$create')
		switch (facet) {
			case "$create":
				page.$prototype.$links["$save"] = links["$save"];
				page.$prototype.$links["$query"] = links["$query"];
				break;
			case "$details":
				page.$prototype.$links["$edit"] = links["$edit"];
				page.$prototype.$links["$query"] = links["$query"];
				break;
			case "$edit":
				page.$prototype.$links["$save"] = links["$save"];
				page.$prototype.$links["$details"] = links["$details"];
				page.$prototype.$links["$query"] = links["$query"];
				break;
			default:
				throw new Error(facet ? "facet " + facet + " not handled yet" : "No facet specified");
		}
	}
	var $article = entity.$articles && entity.$articles[facet];
	if ($article) {
		page.$article = $article;
	}
	// not used at all but needs to be set since it's syntactically checked later
	page.$prototype.$baseUrl = _LOCAL_ENTITIES_URL;
	if (entity.$prototype) {
		entity.$prototype(page.$prototype, repr, facet);
	}
}

function _buildPrototype(repr, facet) {
	var entity = _entities[repr];
	if (!entity) {
		return null;
	}
	var proto = {
		$properties: {}
	};
	Object.keys(entity.$properties).forEach(function(key) {
		var prop = entity.$properties[key];
		var $type = prop.$type || "application/x-string";
		var propNew = proto.$properties[key] = {
			$type: $type
		};
		for (var i = 0; i < _propertiesToCopy.length; i++) {
			var pname = _propertiesToCopy[i];
			var p = prop[pname];
			if (p) {
				propNew[pname] = p;
			}
		}
	});
	return proto;
}

exports.getPrototype = function(repr, facet) {
	return _buildPrototype(repr, facet);
};


exports.isLocalEntityUrl = function(url) {
	return url ? url.smStartsWith(_LOCAL_ENTITIES_URL) : false;
};

exports.getLocalEntityUrl = function(entity, path) {
	return _LOCAL_ENTITIES_URL + "/" + entity + (path ? path : "");
};
// Returns the content of the url according to the context
// Used to return datacontent for clobs, blobs in slient entities
exports.callLocalEntityUrl = function(url) {
	var sdataUrl = sdataUtils.parseSDataURL(url);
	if (!sdataUrl || !sdataUrl.entity) return null;
	var entity = exports.getEntity(sdataUrl.entity);
	if (!entity || !entity.$urlCall) return null;
	//sdataUrl 	parsed url
	//path 		array thath contains th end of the path following entity name
	return entity.$urlCall(sdataUrl, sdataUrl.path.split('/').splice(6));
};
});

define('syracuse-tablet/html/js/application/pageRegistry',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/sdata/entities/clientContract'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');

var _staticPages = {};
/**
 * resolves with a copy if meta-data
 */
var _getPageInfo = function(pageName, options, currentPage) {
	options = options || {};
	return $.smResolve()
		.then(function() {
			// Check if a static page is requested first
			var pageInfo = _staticPages[pageName];
			return pageInfo;
		})
		.then(function(pageInfo) {
			// Check for client side page definition
			if (!pageInfo) {
				pageInfo = clientContract.getPageInfo(pageName, options);
			}
			return pageInfo;
		})
		.then(function(pageInfo) {
			if (pageName === "rowdetail" || pageName === "carddesign" || pageName === "chartdetail") {
				if (!currentPage) {
					throw new Error(pageName + " - Not null currentPage expected");
				}
				var ctrl = currentPage.getControl ? currentPage.getControl(options.controlId) : null;
				if (!ctrl) {
					throw new Error(pageName + " - Control not found - id:" + options.controlId);
				}
				if (!ctrl.childPageGetPageInfo) {
					throw new Error(pageName + " - Control must implement childPageGetPageInfo");
				}
				return ctrl.childPageGetPageInfo(pageName);
			}
			// Check for pages defined by "real" mobile applications
			if (!pageInfo) {
				pageInfo = globals.getMetaData().getPageInfo(pageName);
			}
			return pageInfo;
		})
		.then(function(pageInfo) {
			if (!pageInfo) {
				// Workaround for all that is lazy loaded
				pageInfo = _createDummyPageInfo(pageName);
			}
			_addAuthoringInfo(pageInfo);
			return pageInfo;
		})
		.then(function(pageInfo) {
			_addOptions(pageName, pageInfo, options, currentPage);
			pageInfo.uuid = utils.readableuid("page", pageInfo.type, pageInfo.name);
			pageInfo.applicationName = globals.getApplication().dao.getApplicationName();
			return $.extend(true, {}, pageInfo);
		});
};

function _addOptions(pageName, pageInfo, options, currentPage) {
	options = options || {};
	pageInfo.options = $.extend(true, {}, options);
	_addGadgetData(pageInfo, currentPage);
}

function _addGadgetData(pageInfo, currentPage) {
	var gadgetId = pageInfo.options["gadget-id"];
	if (gadgetId) {
		var $properties = currentPage && currentPage.prototype && currentPage.prototype.json && currentPage.prototype.json.$properties;
		if ($properties) {
			Object.keys($properties).some(function(vignetteId) {
				var vignette = $properties[vignetteId];
				if (vignette && vignette.$gadget && vignette.$gadget.$uuid === gadgetId) {
					var json = vignette.$gadget;
					// Returns JSON - not gadget object - pageInfo MUST contain only JSON (restore context)
					pageInfo.options.gadget = json;
					return true;
				}
				return false;
			});
		}
	}
}

function _createDummyPageInfo(pageName) {
	var pageInfo = {
		name: pageName,
		home: false,
		type: "regular",
		subtype: "",
		cached: false,
		refreshed: false
	};
	if (pageName) {
		var x = pageName.split('.');
		if (x.length > 0 && x[x.length - 1].smStartsWith('$')) {
			pageInfo.subtype = x[x.length - 1].substring(1);
		}
	}
	return pageInfo;
}

function _addAuthoringInfo(pageInfo) {
	if (!pageInfo.authoringName) {
		// Compute page name used by authoring
		var segs = pageInfo.name.split(".");
		var authoringName;
		if (segs.length === 5) {
			// remove dataset (e.g. SUPERV, ...)
			authoringName = segs[0] + "." + segs[1] + "." + segs[3] + "." + segs[4];
		} else {
			authoringName = pageInfo.name;
		}
		if (segs.length === 2) {
			authoringName = "syracuse.collaboration." + authoringName;
		}
		pageInfo.authoringName = authoringName;
	}
}

var _defStaticInfo = function(name) {
	return {
		name: name,
		type: "static",
		subtype: "html",
		cached: false,
		refreshed: false,
		home: false,
		disableAuthoring: true,
		isLogin: name === "login",

		/**
		 * Html have an empty proto and are base on a stacked layout for compatibility with other pages
		 * Html is appended to layout root elmt
		 * We add the proto/article in state for convenience - it can be enhanced according to the needs
		 * Currently we need only static html pages
		 */
		$prototype: {
			$properties: {}
		},
		$article: {
			$layoutType: "stack",
			$items: []
		}
	};
};
/**
 * Static preloaded pages
 * Pages belongs to all mobile applications
 */
function _registerStaticPages() {
	var pages = {
		"login": null,
		"pageDrafts": {
			$prototype: {
				$title: locale.text("drafts.page.title")
			}
		}
	};
	for (var name in pages) {
		_staticPages[name] = $.extend(true, _defStaticInfo(name), pages[name]);
	}
}
exports.getPageInfo = _getPageInfo;
exports.init = function() {
	// Called only once to register static html pages
	_registerStaticPages();
};
});

define('syracuse-tablet/html/js/authoring/authoringSData',['require','exports','module','syracuse-tablet/html/js/sdata/sdataHttp'],function (require, exports, module) {"use strict";

var sdataHttp = require('syracuse-tablet/html/js/sdata/sdataHttp');
var _DEVICE_NAME = "mobile";

/*
 * pageData: {
 *   application: "x3",
 *   contract: "erp",
 *   representation: "BPCUSTOMERM"
 *   facet: "$details"
 * }
 */
exports.getPageVariants = function(pageData) {
	return $.smResolve()
		.then(function() {
			pageData = $.extend(true, {}, {
				device: _DEVICE_NAME
			}, pageData);

			if (!pageData.application || !pageData.contract || !pageData.representation || !pageData.facet || !pageData.device) {
				return $.smReject("Not all mandatory parameters present: " + JSON.stringify(pageData));
			}

			var code = [pageData.application, pageData.contract, pageData.representation, pageData.facet, pageData.device].join(".");
			var key = encodeURIComponent(code).replace(/'/g, "''");
			var req = {
				url: "/sdata/syracuse/collaboration/syracuse/pageDefs(code%20eq%20'" + key + "')?representation=pageDef.$details"
			};

			return sdataHttp.send(req);
		})
		.then(function(response) {
			if (response && response.isSuccess) {
				return response.responseJSON.variants || [];
			}
			if (response.status === 404) {
				return [];
			}
			if (response && response.responseJSON && response.responseJSON.$diagnoses) {
				return $.smReject(response.responseJSON);
			}
			return $.smReject("Unknown error");
		});
};

exports.deletePageVariants = function(pageData) {
	return $.smResolve()
		.then(function() {
			pageData = $.extend(true, {}, {
				device: _DEVICE_NAME
			}, pageData);

			if (!pageData.application || !pageData.contract || !pageData.representation || !pageData.facet || !pageData.device) {
				return $.smReject("Not all mandatory parameters present: " + JSON.stringify(pageData));
			}

			var code = [pageData.application, pageData.contract, pageData.representation, pageData.facet, pageData.device].join(".");
			var key = encodeURIComponent(code).replace(/'/g, "''");
			var req = {
				url: "/sdata/syracuse/collaboration/syracuse/pageDefs(code%20eq%20'" + key + "')?representation=pageDef.$edit",
				method: "DELETE"
			};

			return sdataHttp.send(req)
				.then(function(response) {
					if (response && response.isSuccess) {
						return;
					}
					if (response && response.responseJSON && response.responseJSON.$diagnoses) {
						return $.smReject(response.responseJSON);
					}
					return $.smReject("Unknown error");
				});
		});
};

var _createPageDefinitionWC = function(opts) {
	var params = {
		"pageContext": [opts.application, opts.contract, opts.representation, opts.facet].join("."),
		"device": _DEVICE_NAME,
		"representation": "pageAuth.$edit"
	};

	var url = "/sdata/syracuse/collaboration/syracuse/pageAuths" +
		(opts.variant != null ? ("('" + opts.variant + "')") : "/$template") +
		"/$workingCopies?" +
		Object.keys(params).map(function(key) {
			return key + "=" + params[key];
		}).join("&");

	var req = {
		url: url,
		method: "POST"
	};

	return sdataHttp.send(req)
		.then(function(response) {
			if (response && response.isSuccess) {
				return response.responseJSON;
			}
			if (response && response.responseJSON && response.responseJSON.$diagnoses) {
				return $.smReject(response.responseJSON);
			}
			return $.smReject("Unknown error");
		});
};
var _savePageDefinitionWC = function(opts, wc) {
	var parameters = {
		"roles": opts.roles,
		"users": opts.users,
		"endpoints": opts.endpoints,
		"saveAsOption": opts.saveAsOption,
		"isFactory": false,
		"isModelRepresentation": false,
		"personalCopy": false,
		"variantCode": opts.variantCode,
		"variantTitle": opts.variantTitle,
		"variantDescription": opts.variantDescription
	};
	switch (opts.saveAsOption) {
		case "factory_variant":
			parameters.isFactory = true;
			break;
		case "personal_copy":
			parameters.personalCopy = true;
			break;
		case "shared_copy":
			break;
		case "global_variant":
			break;
	}

	wc.$actions = {};
	var save;
	if (opts.variant) {
		save = wc.$actions["$save"] = {};
		delete parameters.saveAsOption;
	} else {
		save = wc.$actions["saveAs"] = {};
	}
	save.$isRequested = true;
	save.$parameters = parameters;

	var req = {
		url: wc.$url,
		method: "PUT",
		send: wc
	};
	return sdataHttp.send(req)
		.then(function(response) {
			if (response && response.isSuccess) {
				return response.responseJSON;
			}
			if (response && response.responseJSON && response.responseJSON.$diagnoses) {
				return $.smReject(response.responseJSON);
			}
			return $.smReject("Unknown error");
		});
};

exports.savePageDefinition = function(opts) {
	var workingCopy;
	return _createPageDefinitionWC(opts)
		.then(function(wc) {
			workingCopy = wc;
			var send = $.extend(true, {}, workingCopy);
			send.content = send.content || {};
			send.content.$article = opts.article;
			return _savePageDefinitionWC(opts, send);
		}).then(function(wcSaved) {
			var data = $.extend(true, {}, workingCopy, wcSaved);
			var result = _extractErrors(data);
			if (result.errors) {
				return $.smReject(result.diags);
			}
			return data;
		});
};

function _extractErrors(data, result) {
	if (result == null) {
		result = {
			errors: false,
			diags: {
				$diagnoses: []
			}
		};
	}
	Object.keys(data).forEach(function(key) {
		var value = data[key];
		if (key === "$diagnoses") {
			value.forEach(function(d) {
				result.diags.$diagnoses.push(d);
				if (d.$severity == "error") {
					result.errors = true;
				}
			});
		} else if (value && typeof value === "object") {
			_extractErrors(value, result);
		}
	});
	return result;
}
});

define('syracuse-tablet/html/js/authoring/authoringHtml',['require','exports','module'],function (require, exports, module) {"use strict";

/*
 * Authoring panel main layout
 */
var _templates = {
	authPanelHeader: '\
		<div style="display:table;table-layout:fixed;;width:100%;">\
			<div style="display:table-row;width:100%; ">\
				<div style="display:table-cell;width:300px;">\
					<div style="display:table;">\
						<div style="display:table-row;position:absolute;top:0;">\
							<div style="display:table-cell;">\
								<button class="btn btn-auth-header" id="s-m-auth-settings-id" type="button"><label class="glyphicon glyphicon-cog"></label>{{label_settings}}</button> \
							</div>\
							<div style="display:table-cell;" >\
								<div class="btn-group" id="s-m-auth-orientation-id" data-toggle="buttons">\
									<button class="btn btn-auth-header active" id="s-m-auth-vertical-id" data-auth-orientation="portrait" title="{{label_preview_portrait}}"> \
										<input type="radio" name="orientation" checked> \
										<label class="glyphicon glyphicon-resize-vertical"></label> \
									</button> \
									<button class="btn btn-auth-header" id="s-m-auth-horizontal-id" data-auth-orientation="landscape" title="{{label_preview_landscape}}"> \
										<input type="radio" name="orientation"> \
										<label class="glyphicon glyphicon-resize-horizontal"></label> \
									</button> \
								</div>\
							</div>\
							<div style="display:table-cell;">\
								<button class="btn btn-auth-header" id="s-m-auth-scale-id" type="button" title="{{label_scale_to_fit}}"><label class="glyphicon glyphicon-fullscreen"></button> \
							</div>\
						</div>\
					</div>\
				</div>\
				<div style="display:table-cell;" id="s-m-auth-header-actions-id">\
					<div style="display:table;">\
						<div style="display:table-row;position:absolute;top:0;">\
							<button style="display:table-cell;" class="btn btn-auth-header" id="s-m-auth-new-layout-id" type="button"><label class="glyphicon glyphicon-blackboard"></label><span>{{label_new_layout}}</span></button> \
							<button style="display:table-cell;" class="btn btn-auth-header" id="s-m-auth-remove-all-id" type="button"><label class="glyphicon glyphicon-erase"></label><span>{{label_remove_all}}</span></button> \
							<button style="display:table-cell;" class="btn btn-auth-header disabled" id="s-m-auth-remove-id" type="button"><label class="glyphicon glyphicon-trash"></label><span>{{label_remove}}</span></button> \
							<button style="display:table-cell;" class="btn btn-auth-header disabled" id="s-m-auth-remove-cnt-id" type="button"><label class="glyphicon glyphicon-erase"></label><span>{{label_remove_container}}</span></button> \
						</div>\
					</div>\
				</div>\
				<div style="display:table-cell;width:300px;">\
					<button id="auth-btn-undo-id"  class="btn btn-auth-header" type="button"><div class="icon-undo"></label>{{label_undo}}</button> \
					<button id="auth-btn-undo-all-id"  class="btn btn-auth-header" type="button"><div class="icon-undoall"></label>{{label_undo_all}}</button> \
					<button id="auth-btn-close-id" style="float:right;" class="btn btn-danger" type="button"><div class="glyphicon glyphicon-remove"></label></button> \
					<button id="auth-btn-save-id" style="float:right;" class="btn btn-default" type="button"><div class="glyphicon glyphicon-ok"></label></button> \
				</div>\
			</div>\
		</div>',

	authPanelFooter: '\
		<div class="btn-group"> \
		</div>',

	authPanelRightStructure: '\
		<div class="s-m-site-auth-panel-content"> \
			<header id="authPanelControlType">{{label_design}}</header> \
			<p class="form-control-static" id="authPanelControlTitle"> </p> \
			<div id="authPanelControl" class="tab-pane panel-body active"> \
				<div id="authPanelControlSimple"> \
				</div> \
			</div> \
		</div>',

	authPanelLeftStructure: '\
		<div class="s-m-site-auth-panel-content"> \
			<ul class="nav nav-pills" role="tablist"> \
				<li class="active"><a aria-expanded="true" href="#s-m-auth-tree-box" role="tab" data-toggle="tab">{{label_content}}</a></li> \
				<li><a href="#s-m-auth-insert-box" role="tab" data-toggle="tab">{{label_insert}}</a></li> \
			</ul> \
			<div class="tab-content"> \
				<div id="s-m-auth-tree-box" class="tab-pane active"> \
					<ul class="s-m-auth-tree" id="auth-structure-root-id"></ul> \
				</div> \
				<div id="s-m-auth-insert-box" class="tab-pane"> \
					<div class="panel panel-primary s-m-panel-auth-prop"> \
						<div class="panel-heading" role="tab" id="auth-lp-cnt-containers-header"> \
							<a data-toggle="collapse" data-parent="#accordion" href="#auth-lp-cnt-containers-clpse" \
								aria-expanded="true" aria-controls="auth-lp-cnt-containers-clpse" \
								<h4 class="panel-title"> \
									{{label_containers}}\
								</h4> \
							</a> \
						</div> \
						<div id="auth-lp-cnt-containers-clpse" class="panel-collapse collapse in" \
							role="tabpanel" aria-labelledby="auth-lp-cnt-containers-header"> \
							<label>{{lab_drag_to_add}}</label><br> \
							<div class="s-m-auth-btn-container s-m-draggable fa fa-th" data-auth-bind="group" title="{{lab_group}}" data-auth-drag-action="add_layout"></div> \
							<div class="s-m-auth-btn-container s-m-draggable fa fa-square-o" data-auth-bind="tile" title="{{lab_tile}}" data-auth-drag-action="add_layout"></div> \
							<div class="s-m-auth-btn-container s-m-draggable fa fa-bars" data-auth-bind="stack" title="{{lab_stack}}" data-auth-drag-action="add_layout"></div> \
						</div> \
					</div> \
					<div class="panel panel-primary s-m-panel-auth-prop"> \
						<div class="panel-heading" role="tab" id="auth-lp-cnt-props-header"> \
							<a data-toggle="collapse" data-parent="#accordion" href="#auth-lp-cnt-props-clpse" \
								aria-expanded="true" aria-controls="auth-lp-cnt-props-clpse">\
								<h4 class="panel-title"> \
									{{label_fields}}\
								</h4> \
							</a> \
						</div> \
						<div id="auth-lp-cnt-props-clpse" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="auth-lp-cnt-props-header"> \
						</div> \
					</div> \
				</div> \
			</div> \
		</div>',

	authPanelPropertyGroup: ' \
		<div class="panel panel-primary s-m-panel-auth-prop s-m-auth-prop-type-{{type}}"> \
			<div class="panel-heading" role="tab" id="heading_{{id}}"> \
				<a data-toggle="collapse" data-parent="#{{#if parentId}}{{parentId}}{{/if}}{{#unless parentId}}accordion{{/unless}}" href="#collapse_{{id}}" {{#if expanded}} aria-expanded="true"{{/if}} aria-controls="collapse_{{id}}" {{#unless expanded}}class="collapsed"{{/unless}}>\
					<h4 class="panel-title"> \
						{{label}}\
					</h4> \
				</a> \
			</div> \
			<div id="collapse_{{id}}" class="panel-collapse collapse {{#if expanded}}in{{/if}}" role="tabpanel" aria-labelledby="heading_{{id}}"> \
			</div> \
		</div>',
	authPanelPropertySeperator: ' \
		<div class="auth-group-seperator"></div> \
		',

	authPanelPropertyRadio: ' \
		<div class="btn-group" data-toggle="buttons" style="width: 100%;"> \
			{{#each options}} \
				<div class="btn-group" style="width: 100%; display: {{this.display}};" id="{{this.id}}"> \
					<label class="s-m-auth-btn-radio-icon s-m-auth-btn-block" id="{{this.id}}_lab" data-s-m-auth-value="{{this.value}}"> \
						<input type="radio" name="{{group}}" id="{{this.id}}">{{this.label}} \
					</label> \
				</div> \
			{{/each}} \
		</div>',
	authPanelPropertyRadioIcon: ' \
		<div class="btn-group" data-toggle="buttons" style="width: 100%;"> \
			{{#each options}} \
				<div class="btn-group"> \
					<label class="auth-btn-icon {{icon}}" id="{{this.id}}_lab" data-s-m-auth-value="{{this.value}}"> \
						<input type="radio" name="{{group}}" id="{{this.id}}"> \
					</label> \
				</div> \
			{{/each}} \
		</div>',

	authPanelPropertyCheckbox: ' \
		<div class="btn-group" style="width: 100%;"> \
			{{#each options}} \
				<div class="btn-group" style="width: 100%; display: {{this.display}};" id="{{this.id}}"> \
					<label class="s-m-auth-btn-checkbox-icon s-m-auth-btn-block" id="{{this.id}}_lab" data-s-m-auth-value="{{this.value}}"> \
							<i class="fa fa-square {{#if checked}}fa-check-square{{/if}}" style="margin-right:5px"></i>{{this.label}} \
					</label> \
				</div> \
			{{/each}} \
		</div>',

	authPanelPropertyInput: ' \
			<div class="form-group"> \
				<input class="form-control" id="{{id}}" value="{{value}}" /> \
			</div>',
	authPanelPropertyInputLocale: ' \
		<div class="form-group"> \
			<input class="form-control" id="{{id}}" value="{{value}}" data-old-value="{{oldValue}}" data-old-uuid="{{oldUUID}}"/> \
		</div>',

	authPanelSliderStep: ' \
		<div class="form-group"> \
			<section style="padding-left:10px;padding-right:10px;">\
				<input id="{{id}}" type="text" data-slider-min="{{min}}" data-slider-max="{{max}}" data-slider-step="{{step}}"  data-slider-value="{{value}}" data-slider-orientation="horizontal" data-slider-tooltip="hide">\
				{{#if displayValue}}<span class="s-m-slider-value">{{#if valText}}{{valText}}{{/if}}{{#unless valText}}{{value}}{{/unless}}</span>{{/if}}\
			</section>\
		</div>',

	authPanelGaugeSlider: '\
		<div class="form-group s-m-auth-g-slider"> \
			<section>\
				<input id="{{id}}" type="text" data-slider-min="{{min}}" data-slider-max="{{max}}" data-slider-step="{{step}}"  data-slider-value="{{value}}" data-slider-orientation="horizontal" data-slider-tooltip="hide" class="s-m-auth-g-range">\
				<span id="{{id}}SliderVal">{{value}}</span>\
			</section>\
		</div>\
	',
	authPanelPropertyCellSize: ' \
		<section>\
			<label class="s-m-auth-btn-checkbox-icon s-m-auth-btn-block">\
				<input type="checkbox">\
				{{sameSize}}\
			</label>\
			{{#each sizes}} \
				<section class = "{{prop}}">\
					<label class="{{class}} auth-size-device-header" style="width: 100%">{{this.label}}</label> \
					<div class="btn-group" data-toggle="buttons" style="width: 100%;"> \
						{{#each ../values}} \
							<div class="btn-group"> \
								<label class="auth-btn-size-sel" id="{{this.id}}_lab" data-s-m-auth-prop="{{../this.prop}}" data-s-m-auth-value="{{this}}"> \
									<input type="radio" name="{{group}}" id="{{../this.prop}}={{this}}">{{this}} \
								</label> \
							</div> \
						{{/each}} \
					</div> \
				</section>\
			{{/each}}\
		</section>',

	authPanelPropertyJSON: ' \
			<div class="form-group"> \
				<textarea class="form-control" id="{{id}}" rows="10">{{value}}</textarea> \
				<div class="btn-group btn-group-justified" role="group">\
					<a class="btn btn-default" data-action="jsonApply">{{label_apply}}</a> \
					<a class="btn btn-default" data-action="openInNewTab">{{label_display}}</a> \
				</div>\
			</div><div style="clear: both;"></div>',

	authPanelPropertyPROTOTYPE: ' \
			<div class="form-group"> \
				<textarea readonly class="form-control" id="{{id}}" rows="10">{{value}}</textarea> \
				<div class="btn-group btn-group-justified" role="group">\
					<a class="btn btn-default" data-action="openInNewTab">{{label_display}}</a> \
				</div>\
			</div>',

	authPanelPropertyGBorderValues: '\
		<div class="form-group">\
			<p class="s-m-auth-g-borders-tip">{{label_tip}}</p>\
			<label>{{label_min}}</label>\
			{{{markupMin}}}\
			<label>{{label_max}}</label>\
			{{{markupMax}}}\
			<button class="btn btn-default btn-block" style="margin-top:5%;">{{label_apply}}</button> \
		</div>\
	',
	authPanelPropertyGSegmentsNumber: '\
		<div class="form-group">\
			{{{value}}} \
			<button class="btn btn-default btn-block" style="margin-top:5%;">{{label_apply}}</button> \
		</div>\
	',
	gaugeBorderInput: '\
		<textarea class="form-control" id={{id}} rows="1">{{value}}</textarea>\
	',
	gaugeSelect: '\
		<select id={{id}} style="color:black;" class="form-control">\
			{{#each options}}\
				<option value="{{option_value}}" {{#if selected}}selected=true{{/if}}>{{option_value}}</option>\
			{{/each}}\
		</select>\
	',
	gaugeSegment: '\
		<div id="{{id}}" class="s-m-auth-seg-slot">\
			<div class="s-m-g-seg-info-block">\
				<div class="s-m-g-seg-label">\
					<label>{{label_valstart}}</label>\
				</div>\
				<div class="s-m-g-seg-value">\
					<input type="text" class="form-control" value="{{value_valstart}}" id="{{id}}-valstart">\
				</div>\
			</div>\
			<div class="s-m-g-seg-info-block">\
				<div class="s-m-g-seg-label">\
					<label>{{label_valend}}</label>\
				</div>\
				<div class="s-m-g-seg-value">\
					<input type="text" class="form-control" value="{{value_valend}}" id="{{id}}-valend">\
				</div>\
			</div>\
			<div class="s-m-g-seg-info-block">\
				<div class="s-m-g-seg-label">\
					<label>{{label_propstart}}</label>\
				</div>\
				<div class="s-m-g-seg-value">\
					{{{value_propstart}}}\
				</div>\
			</div>\
			<div class="s-m-g-seg-info-block">\
				<div class="s-m-g-seg-label">\
					<label>{{label_propend}}</label>\
				</div>\
				<div class="s-m-g-seg-value">\
					{{{value_propend}}}\
				</div>\
			</div>\
			<div class="s-m-g-seg-info-block">\
				<div class="s-m-g-seg-label">\
					<label>{{label_color}}</label>\
				</div>\
				<div class="s-m-g-seg-value">\
					<input type="text" class="form-control" value="{{value_color}}" id="{{id}}-color">\
				</div>\
			</div>\
		</div>\
	',
	authPanelButton: '\
		<div class="s-m-auth-g-apply-slot">\
			<button class="btn btn-default btn-block {{css}}" style="margin-top:5%;">{{label}}</button> \
		</div>\
	'
};

var _compiled = {};

function _getCompiled(name) {
	var c = _compiled[name];
	if (c) {
		return c;
	}

	var t = _templates[name];
	c = Handlebars.compile(t);
	_compiled[name] = c;
	return c;
}

exports.execute = function(name, ctx) {
	var c = _getCompiled(name);
	return c(ctx);
};
});

define('syracuse-tablet/html/js/authoring/authoringVal',['require','exports','module','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/modals/modal'],function (require, exports, module) {"use strict";

var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');

var _authProperties;

exports.setProperties = function(properties) {
	_authProperties = properties;
};

function getAuthoringPropertiesLayouts() {
	return _authProperties && _authProperties.getPropertiesLayouts();
}
/*
 *
 * Simple article validation module
 *
 */


exports.validateJSON = function(fullPage, jsonText, properties) {
	var obj;
	try {
		if ($.isPlainObject(jsonText)) {
			obj = jsonText;
		} else if (jsonText != null && jsonText.length > 0) {
			obj = JSON.parse(jsonText);
		} else {
			throw new Error("Unexpected bad JSONtext");
		}

		var errors = _validate(fullPage, obj, properties);
		if (errors.length > 0) {
			var text = "\n" + errors.join("\n");
			modal.error(locale.text("auth.panel.save_error_title"), {
				message: locale.text("auth.panel.save_error_json"),
				detail: text
			});
		} else {
			return obj;
		}
	} catch (e) {
		modal.error(locale.text("auth.panel.save_error_title"), {
			message: locale.text("auth.panel.save_error_json"),
			detail: e
		});
	}
};

/*
 * display $items and $article nodes at the end of JSON
 */
exports.toSortedJSON = function(obj) {
	var toJSON = function() {
		var self = this;
		var that = {};
		var $items;
		var $article;
		Object.keys(self).forEach(function(key) {
			if (self.hasOwnProperty(key)) {
				if (key === "$items") {
					$items = self[key];
				} else if (key === "$article") {
					$article = self[key];
				} else if (key === "toJSON") {
					// Do nothing
				} else {
					that[key] = self[key];
				}
			}
		});
		if ($article) {
			that.$article = $article;
		}
		if ($items) {
			that.$items = $items;
		}
		if (self.toJSON) {
			delete self.toJSON;
		}
		if (that.toJSON) {
			delete that.toJSON;
		}
		return that;
	};
	// Step one: Hook property ordering
	JSON.stringify(obj,
		function replacer(key, value) {
			if ($.isPlainObject(value)) {
				value.toJSON = toJSON;
			}
			return value;
		});
	// Build json
	var str = JSON.stringify(obj, null, " ");
	return str;
};

/*
 * fullPage: true = article is an object describing a full page so also nesting constraints can be checked
 * fullPage: false = article is an object describing a control or container so nesting constraints cannot be fully checked
 * article: Article object
 */
function _validate(fullPage, article, properties) {

	var errors = [];
	try {
		_checkNode(fullPage, null, article, properties, errors);
	} catch (e) {
		errors.push("javascriptException - validate\n" + jsutils.cleanStack(e.stack));
	}
	return errors;
};

var _propertiesToCheck = {
	$layoutType: _checkLayoutType,
	$size: _checkTileSize,
	$widthXs: _checkCellSize,
	$widthSm: _checkCellSize,
	$widthMd: _checkCellSize,
	$widthLg: _checkCellSize
};

function _checkNode(fullPage, parent, node, properties, errors) {

	Object.keys(_propertiesToCheck).some(function(key) {
		if (node[key] !== undefined) {
			_propertiesToCheck[key](fullPage, parent, node, key, properties, errors);
		}
	});

	var children;
	if (node.$items) {
		children = node.$items;
	} else if (node.$article) {
		children = [node.$article];
	}
	if (children) {
		children.forEach(function(child) {
			_checkNode(fullPage, node, child, properties, errors);
		});
	}
}

function _checkLayoutType(fullPage, parent, node, key, properties, errors) {
	var type = node.$layoutType;
	var ptype = parent && parent.$layoutType;
	var known = ["stack", "row", "cell", "hub", "hubGroup", "tile"];
	if (known.indexOf(type) < 0) {
		errors.push(locale.text("auth.err.unknown.layout", [type]));
		return;
	}
	if (!fullPage) {
		return;
	}
	switch (type) {
		case "hub":
			if (parent != null) {
				errors.push(locale.text("auth.err.hub.notroot"));
			}
			break;
		case "hubGroup":
			if (ptype != "hub") {
				errors.push(locale.text("auth.err.hubgroup.nohub"));
			}
			break;
		case "tile":
			if (ptype != "hubGroup") {
				errors.push(locale.text("auth.err.tile.nohubgroup"));
			}
			break;
	}
}

function _checkCellSize(fullPage, parent, node, key, properties, errors) {
	var value = +node[key];
	if (!(value >= 1 && value <= 12)) {
		errors.push(locale.text("auth.err.cellSize", [key, value]));
	}
}

function _checkTileSize(fullPage, parent, node, key, properties, errors) {
	var value = node[key];
	var valid = getAuthoringPropertiesLayouts().properties.tileSize.values.map(function(e) {
		return e.value;
	});

	if (valid.indexOf(value) < 0) {
		errors.push(locale.text("auth.err.tileSize", [valid.join(", "), value]));
	}
}
});

define('syracuse-tablet/html/js/authoring/authoringComponents',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');


var _templates = {
	genericSlider: '\
		<div class="form-group" {{#if margin}}style="margin-bottom:{{margin}}px;"{{/if}}> \
			<section style="padding-left:10px;padding-right:10px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis">\
				<input id="{{id}}" type="text" data-slider-min="{{min}}" data-slider-max="{{max}}" data-slider-step="{{step}}"  data-slider-value="{{value}}" data-slider-orientation="horizontal" data-slider-tooltip="hide">\
				{{#if displayValue}}<p class="s-m-slider-value">{{#if valText}}{{valText}}{{/if}}{{#unless valText}}{{value}}{{/unless}}</p>{{/if}}\
			</section>\
		</div>',
	flatRadio: '\
		<div class="btn-group" style="margin-bottom:10px;" data-toggle="buttons">\
			{{#each btns}}\
				<label class="btn btn-primary">\
					<input type="radio" autocomplete="off" value="{{value}}">\
					{{title}}\
				</label>\
			{{/each}}\
		</div>',
	select: '\
		<div style="position:relative;{{#if margin}}margin-bottom:{{margin}}px;{{/if}}">\
		  <select class="selectpicker {{css}}"  data-width="100%" {{#if dataSize}}data-size="{{dataSize}}"{{/if}}>\
		  	{{#each options}}\
		     	<option value="{{value}}">{{title}}</option>\
			{{/each}}\
		  </select>\
		</div>',
	actionBtns: '\
		<div style="text-align:center;">\
			<div class="btn-group" role="group" style="margin-bottom:10px;">\
				{{#each btns}}\
					<button type="button" class="btn btn-default" value="{{value}}">{{title}}</button>\
				{{/each}}\
			</div>\
		</div>',
	colorPicker: '\
		<input type="text" {{#if id}}id="{{id}}"{{/if}} class="form-control {{css}}""></input>',
	editableList: '\
		<section class = "auth-editableList  {{css}}" {{#if id}}id="{{id}}"{{/if}} >\
			<ul class="list-group auth-editableList"></ul>\
			<div class="authMsg"></div>\
			<div class="btn-group btn-group-justified" role="group">\
				<a type="button" class="btn btn-default authLstAct" data-action="append">\
					<i class="fa fa-plus"></i>\
					<span>{{addTitle}}</span>\
				</a>\
				<a style="display:none" type="button" class="btn btn-default authLstAct" data-action="validate">\
					<i class="fa fa-check"></i>\
					<span>{{validateTitle}}</span>\
				</a>\
				<a style="display:none" type="button" class="btn btn-default authLstAct" data-action="cancel">\
					<i class="fa fa-times"></i>\
					<span>{{cancelTitle}}</span>\
				</a>\
			</div>\
		</section>',
	editableListItem: '\
		<li class="list-group-item {{css}}" data-params="{{id}}">\
			<span>\
				<span>{{#if title}}{{title}}{{/if}}{{#if titleHtml}}{{{titleHtml}}}{{/if}}</span>\
				<span class="fa fa-pencil" data-action="editItem"></span>\
				<span class="fa fa-times" data-action="deleteItem"></span>\
			</span>\
		</li>',
	colorPalettePicker: '\
		<section class="auth-colorPalettePicker {{dropDirection}}">\
			<div class="input-group" data-toggle="dropdown" aria-expanded="false">\
				<span class="form-control auth-paletteColor"></span>\
				<span class="input-group-addon"><div class="fa fa-times"></div></span>\
			</div>\
			<div class="dropdown-menu" style="width: 100%;width: 100%;padding-left: 5px;padding-right: 5px;">\
				<div class="auth-paletteRoot" data-toggle="buttons" style="width: 100%;white-space: normal;" >\
				</div>\
		  	</div>\
		</section>',
	colorPaletteItem: '\
		<div class="auth-paletteItem {{css}}" data-id="{{id}}" data-name="{{name}}" data-css="{{css}}">\
		</div>',
	iconPalettePicker: '\
		<section class="auth-iconPalettePicker {{dropDirection}}">\
			<div class="input-group" data-toggle="dropdown" aria-expanded="false">\
				<span class="form-control auth-paletteIcon"></span>\
				<span class="input-group-addon"><div class="fa fa-times"></div></span>\
			</div>\
			<div class="dropdown-menu">\
				<div class="auth-paletteRoot" data-toggle="buttons" style="width: 100%;white-space: normal;" >\
				</div>\
		  	</div>\
		</section>',
	iconPaletteItem: '\
		<div class="auth-paletteItem {{css}}" data-params="{{name}}" data-css="{{css}}">\
		</div>',
	switcher: '\
		 <input {{#if id}}id="{{id}}"{{/if}} type="checkbox">',
	checkboxList: ' \
		<section class="auth-checkboxList {{css}}" {{#if id}}id="{{id}}"{{/if}}/>',
	checkboxListContent: ' \
		<div class="btn-group s-m-list">\
			{{#each list}} \
				<div class="s-m-item btn-group" data-id = "{{id}}"> \
					<label> \
						<input type="checkbox" {{#if checked}}checked{{/if}}>{{label}} \
					</label> \
				</div> \
			{{/each}}\
		</div>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};

var _components = {
	"editableList": function(options, name) {
		options = options || {};
		this.options = options;
		this.name = name || "editableList";
		this.createMarkup = function($$parent) {
			this.$$panel = $(_getHtml("editableList", {
				id: options.id,
				css: options.css || "",
				addTitle: options.appendTitle || locale.text("append"),
				validateTitle: options.validateTitle || locale.text("validate"),
				cancelTitle: options.cancelTitle || locale.text("cancel")
			})).appendTo($$parent);
			if (options.isHidden === true) {
				this.hide();
			}
			if (this.options.doAction) {
				this.$$panel.on('click', "[data-action]", jsutils.bindFn(this.onClick, this));
			}
			this.$$list = this.$$panel.find("ul");
			return this.$$panel;
		};
		this.onClick = function(event) {
			var $$target = $(event.target).closest("[data-action]");
			var action = $$target.attr("data-action");
			var id;
			if (action === "append" || action === "cancel") {
				id = "";
			} else if (action === "editItem" || action === "deleteItem") {
				id = $$target.closest("[data-params]").attr("data-params") || "";
			} else if (action === "validate") {
				id = $$target.attr("data-params") || "";
			}
			var done = this.options.doAction(action, id, this);
			if (done == true) {
				if (action === "deleteItem") {
					$$target.closest("li").off().remove();
				} else if (action === "editItem" || action === "append") {
					this.toggleEditStatus(true, id);
				} else if (action === "validate" || action === "cancel") {
					this.toggleEditStatus(false);
				}
			}
		};
		this.insertRecords = function(records) {
			if (!records || !this.$$list) return;
			if ($.isPlainObject(records)) records = [records];
			if (!Array.isArray(records)) return;
			var self = this;
			records.forEach(function(record) {
				if (!record || !record.id) return;
				var $$newRec = $(_getHtml("editableListItem", {
					id: record.id,
					css: record.css || "",
					titleHtml: record.titleHtml,
					title: record.title
				}));
				var $$oldRec = self.$$list.find('[data-params="' + record.id + '"]');
				if ($$oldRec.length > 0) {
					$$oldRec.before($$newRec);
					$$oldRec.remove();
				} else {
					$$newRec.appendTo(self.$$list);
				}
			});
		};
		this.destroyMarkup = function() {
			this.options = null;
			if (this.$$list) {
				this.$$list.off();
				this.$$list = null;
			}
			this.$$panel = null;
		};
		this.clear = function() {
			if (!this.$$list) return;
			this.$$list.find("li").remove();
		};
		this.toggleEditStatus = function(editMode, recordId) {
			if (!this.$$panel) return;
			this.$$panel.find('[data-action="append"]').toggle(editMode !== true);
			this.$$panel.find('[data-action="validate"]').toggle(editMode === true).attr("data-params", editMode === true ? recordId : "");
			this.$$panel.find('[data-action="cancel"]').toggle(editMode === true);
		};
		this.disableAppendBtn = function(disabled) {
			this.$$panel.find('[data-action="append"]').attr("disabled", disabled === true);
		};
		/**
		 * type info/warning/error
		 */
		this.toggleMessage = function(msgText, type) {
			if (!this.$$panel) return;
			var $$msg = this.$$panel.find('.authMsg');
			$$msg.empty().removeClass();
			if (msgText && msgText.trim().length > 0) {
				$$msg.text(msgText);
				if (type) {
					$$msg.addClass("s-m-" + type);
				}
			}
			$$msg.addClass("authMsg");
		};
	},
	"colorPicker": function(options, name) {
		options = options || {};
		this.options = options;
		this.name = name || "colorPicker";
		this.createMarkup = function($$parent) {
			this.$$picker = $(_getHtml("colorPicker", {
				id: options.id,
				css: options.css || "",
			})).appendTo($$parent);
			if (options.isHidden === true) {
				this.$$picker.hide();
			}
			this.$$picker.minicolors({
				control: options.control || "hue",
				defaultValue: options.value || '',
				inline: options.inline === true,
				letterCase: options.letterCase || 'lowercase',
				opacity: options.opacity === true,
				position: options.position || 'top left',
				theme: 'bootstrap',
				change: options.onChange ? jsutils.bindFn(this.onChange, this) : null
			});
			this.$$panel = this.$$picker;
			return this.$$panel;
		};
		this.onChange = function(event) {
			this.options.onChange(event, this);
		};
		this.destroyMarkup = function() {
			this.options.onChange = null;
			this.options = null;
			if (this.$$picker) {
				this.$$picker.minicolors('destroy');
				this.$$picker = null;
			}
		};
		this.getValue = function(type) {
			if (!this.$$picker) return;
			var meth;
			if (type === "rgbObject" || type === "rgbString" || type === "rgbaString") {
				meth = type;
			} else {
				meth = "value";
			}
			return this.$$picker.minicolors(meth);
		};
		this.setValue = function(valueHexa) {
			if (!this.$$picker) return;
			return this.$$picker.minicolors("value", valueHexa);
		};
	},
	"colorPalettePicker": function(options, name) {
		options = options || {};
		this.options = options;
		this.name = name || "colorPalettePicker";
		this.createMarkup = function($$parent) {
			var css = options.css || "";
			this.$$panel = $(_getHtml("colorPalettePicker", {
				id: options.id,
				css: css,
				dropDirection: options.dropUp === true ? "dropup" : "dropdown"
			})).appendTo($$parent);
			this.$$rootPalette = this.$$panel.find(".auth-paletteRoot");
			this.$$input = this.$$panel.find(".auth-paletteColor");
			this.$$clearBtn = this.$$panel.find(".input-group-addon").on('click', jsutils.bindFn(this.onClear, this));
			this.$$rootPalette.on('click', '[data-id]', jsutils.bindFn(this.onSelectColor, this));
			if (options.isHidden === true) {
				this.$$panel.hide();
			}
			if (options.palette) {
				this.updatePalette(options.palette);
			}
			this.setValue(options.color);
			return this.$$panel;
		};
		this.updatePalette = function(palette) {
			if (!palette) return;
			var html = [];
			palette.forEach(function(item) {
				if (item.items) {
					if (item.title) {
						html.push('<div class ="authPaletteSection">' + item.title + '</div>');
					}
					item.items.forEach(function(subItem) {
						subItem.name = subItem.name || subItem.id;
						html.push(_getHtml("colorPaletteItem", subItem));
					});
				} else {
					html.push(_getHtml("colorPaletteItem", item));
				}
			});
			this.$$rootPalette.html(html.join(''));
		};
		this.onClear = function(event) {
			if (!this.$$panel.is(".open")) {
				event.stopPropagation();
				this.setValue(null);
				if (this.options.onSelectColor) {
					this.options.onSelectColor(null);
				}
			}
		};
		this.onSelectColor = function(event) {
			var $$t = $(event.target);
			var value = {
				id: $$t.attr("data-id") || "",
				name: $$t.attr("data-name") || "",
				css: $$t.attr("data-css"),
				bgColor: $$t.css("background-color"),
				color: $$t.css("color"),
				hex: this.getHexColor($$t.css("background-color"))
			};
			this.setValue(value);
			if (this.options.onSelectColor) {
				this.options.onSelectColor(value);
			}
		};
		this.destroyMarkup = function() {
			if (this.$$rootPalette) {
				this.$$rootPalette.off();
				this.$$rootPalette = null;
			}
			this.options = null;
			this.$$clearBtn.off();
			this.$$clearBtn = this.$$input = this.$$panel = null;
		};
		this.getValue = function() {
			var $$selected = this.$$panel.find(".auth-paletteItem.current");
			if ($$selected.length == 0) return null;
			// Returns color and background-color in case the caller can't use css
			return {
				css: $$selected.attr("data-css") || "",
				name: $$selected.attr("data-name") || "",
				id: $$selected.attr("data-id") || "",
				bgColor: $$selected.css("background-color"),
				color: $$selected.css("color"),
				hex: this.getHexColor($$selected.css("background-color"))
			};
		};
		this.setValue = function(color) {
			this.$$panel.find(".auth-paletteItem.current").removeClass("current");
			if (color) {
				this.$$panel.find('[data-id="' + color.id + '"]').addClass("current");
			}
			this.$$input.removeClass().addClass("form-control").text(color ? color.name : locale.text("auth.components.palette.nocolor"));
			if (color) {
				this.$$input.addClass(color.css);
			}
		};
		this.getHexColor = function(color) {
			var value = "#";
			var toHex = function(n) {
				n = parseInt(n, 10);
				return ("00" + n.toString(16)).slice(-2);
			};
			if (/^rgb\(.*\)$/.test(color)) {
				color.match(/([0-9]+)/g).forEach(function(val) {
					value += toHex(val);
				});
				return value;
			};
			return null;
		};
	},
	"iconPalettePicker": function(options, name) {
		options = options || {};
		this.options = options;
		this.name = name || "iconPalettePicker";
		this.createMarkup = function($$parent) {
			var css = options.css || "";
			this.$$panel = $(_getHtml("iconPalettePicker", {
				id: options.id,
				css: css,
				dropDirection: options.dropUp === true ? "dropup" : "dropdown"
			})).appendTo($$parent);
			this.$$rootPalette = this.$$panel.find(".auth-paletteRoot");
			this.$$input = this.$$panel.find(".auth-paletteIcon");
			this.$$clearBtn = this.$$panel.find(".input-group-addon").on('click', jsutils.bindFn(this.onClear, this));
			this.$$rootPalette.on('click', '[data-params]', jsutils.bindFn(this.onSelectIcon, this));
			if (options.isHidden === true) {
				this.$$panel.hide();
			}
			if (options.palette) {
				this.updatePalette(options.palette);
			}
			this.setValue(options.icon);
			return this.$$panel;
		};
		this.updatePalette = function(palette) {
			if (!palette) return;
			var html = [];
			palette.forEach(function(item) {
				html.push(_getHtml("iconPaletteItem", item));
			});
			this.$$rootPalette.html(html.join(''));
		};
		this.onClear = function(event) {
			if (!this.$$panel.is(".open")) {
				event.stopPropagation();
				this.setValue(null);
			}
		};
		this.onSelectIcon = function(event) {
			var $$t = $(event.target);
			var old = this.getValue();
			var value = {
				name: $$t.attr("data-params"),
				css: $$t.attr("data-css")
			};
			if (old && old.name == value.name && old.css == value.css) return;
			this.setValue(value);
			if (this.options.onSelectIcon) {
				this.options.onSelectIcon(value);
			}
		};
		this.destroyMarkup = function() {
			if (this.$$rootPalette) {
				this.$$rootPalette.off();
				this.$$rootPalette = null;
			}
			this.options = null;
			this.$$clearBtn.off();
			this.$$clearBtn = this.$$input = this.$$panel = null;
		};
		this.getValue = function() {
			var $$selected = this.$$panel.find(".auth-paletteItem.current");
			if ($$selected.length == 0) return null;
			return {
				css: $$selected.attr("data-css") || "",
				name: $$selected.attr("data-params") || ""
			};
		};
		this.setValue = function(icon) {
			this.$$panel.find(".auth-paletteItem.current").removeClass("current");
			if (icon) {
				this.$$panel.find('[data-params="' + icon.name + '"]').addClass("current");
			}
			this.$$input.removeClass().addClass("form-control").empty();
			if (icon) {
				this.$$input.html('<div class="iconIcon ' + icon.css + '"></div><div class="iconName">' + icon.name + '</div>');
			} else {
				this.$$input.text(locale.text("auth.components.palette.noicon"));
			}
		};
	},
	"select": function(options, name) {
		options = options || {};
		if (!options.onChange) throw new Error("select component - onChange is mandatory");
		// Allows empty option because we can use update method
		options.options = options.options || [];
		if (options.value == null) {
			options.value = Object.keys(options.options)[0];
		}
		this.name = name || "select";
		this.options = options;
		var optselect = {
			options: options.options || [],
			css: options.css || ""
		};
		if (options.dataSize) {
			optselect.dataSize = options.dataSize;
		};
		this.createMarkup = function($$parent) {
			this.$$panel = $(_getHtml("select", optselect)).appendTo($$parent);
			this.$$select = this.$$panel.find("select");
			this.$$select.selectpicker();
			this.$$select.selectpicker('val', options.value);
			this.$$select.on('change', jsutils.bindFn(this.onChange, this));
			if (options.isHidden === true) {
				this.$$select.selectpicker('hide');
			}
			return this.$$panel;
		};
		this.onChange = function(event) {
			this.options.onChange(event, this);
		};
		this.destroyMarkup = function() {
			this.options.onChange = null;
			this.options = null;
			if (this.$$select) {
				this.$$select.off();
				this.$$select.selectpicker('destroy');
				this.$$select = null;
			}
		};
		this.getValue = function() {
			if (!this.$$select) return;
			return this.$$select.selectpicker('val');
		};
		this.setValue = function(value) {
			if (!this.$$select) return;
			return this.$$select.selectpicker('val', value);
		};
		this.update = function(selectOpts, defValue) {
			if (!this.$$select) return;
			selectOpts = selectOpts || [];
			this.$$select.find("option").remove();
			var self = this;
			selectOpts.forEach(function(v, idx) {
				self.$$select.append('<option value="' + v.value + '">' + v.title + '</option>');
			});
			if (defValue == null && selectOpts.length > 0) {
				defValue = selectOpts[0].value;
			}
			if (defValue != null) {
				this.$$select.selectpicker('val', defValue);
			}
			this.$$select.selectpicker('refresh');
		};
		this.clear = function() {
			this.update(null);
		};
	},
	"flatRadio": function(options, name) {
		this.name = name || "flatRadio";
		this.options = options;
		this.createMarkup = function($$parent) {
			this.$$panel = $(_getHtml("flatRadio", {
				btns: this.options.btns
			})).appendTo($$parent).on('change', "input", this.options.onClick);
			this.$$panel.find('input[value="' + this.options.value + '"]').parent().button('toggle');
			return this.$$panel;
		};
		this.destroyMarkup = function() {
			this.options.onClick = null;
			this.options = null;
			if (this.$$panel) {
				this.$$panel.off();
				this.$$panel = null;
			}
		};
	},
	"switcher": function(options, name) {
		this.name = name || "switcher";
		this.options = options;
		this.createMarkup = function($$parent) {
			this.$$panel = $(_getHtml("switcher", {
				id: this.options.id
			})).appendTo($$parent);
			this.setValue(this.options.checked);
			this.$$panel.bootstrapSwitch('onText', this.options.onText || locale.text("auth.switcher.onText"));
			this.$$panel.bootstrapSwitch('offText', this.options.offText || locale.text("auth.switcher.offText"));
			this.$$panel.bootstrapSwitch('size', this.options.size || "small");
			this.$$panel.bootstrapSwitch('onColor', this.options.onColor || "default");
			this.$$panel.bootstrapSwitch('offColor', this.options.offColor || "default");
			if (this.options.onSwitchChange) {
				this.$$panel.bootstrapSwitch('onSwitchChange', jsutils.bindFn(this.onSwitchChange, this));
			}
			return this.$$panel;
		};
		this.onSwitchChange = function(event, state) {
			this.options.onSwitchChange(event, state);
		};
		this.destroyMarkup = function() {
			this.options = null;
			if (this.$$panel) {
				this.$$panel.bootstrapSwitch('destroy');
				this.$$panel = null;
			}
		};
		this.getValue = function(value) {
			if (!this.$$panel) return;
			return this.$$panel.bootstrapSwitch('state');
		};
		this.setValue = function(value) {
			if (!this.$$panel) return;
			this.$$panel.bootstrapSwitch('state', value === true, true);
		};
	},
	"actionBtns": function(options, name) {
		this.name = name || "actionBtns";
		this.options = options;
		this.createMarkup = function($$parent) {
			this.$$panel = $(_getHtml("actionBtns", {
				btns: this.options.btns
			})).on('click', this.options.onClick).appendTo($$parent);
			return this.$$panel;
		};
		this.destroyMarkup = function() {
			this.options.onClick = null;
			this.options = null;
			if (this.$$panel) {
				this.$$panel.off();
				this.$$panel = null;
			}
		};
	},
	/**
	 * options.slideHandler(value, this) 	optional - returns the text to display
	 * options.stopHandler(value, this) 	optional
	 * options.startHandler(value, this)	optional
	 *
	 */
	"genericSlider": function(options, name) {
		this.name = name || "genericSlider";
		this.options = options;
		this.label = options.label;
		this.createMarkup = function($$parent) {
			var displayValue = this.options.displayValue || this.options.slideHandler != null;
			this.$$panel = $(_getHtml("genericSlider", {
				value: this.options.value,
				min: this.options.min,
				max: this.options.max,
				step: this.options.step || 1,
				valText: this.options.value != null ? this.options.slideHandler ? this.options.slideHandler(this.options.value, this) : this.options.value : "",
				displayValue: displayValue,
				margin: this.options.margin + ""
			}));
			$$parent.append(this.$$panel);
			this.$$textValue = $(".s-m-slider-value", this.$$panel);
			this.$$slider = $("input", this.$$panel).slider({});
			if (displayValue) {
				this.$$slider.on("slide", jsutils.bindFn(this.onSlider, this, "slide"));
			}
			if (this.options.stopHandler) {
				this.$$slider.on("slideStop", jsutils.bindFn(this.onSlider, this, "stop"));
			}
			if (this.options.startHandler) {
				this.$$slider.on("slideStart", jsutils.bindFn(this.onSlider, this, "start"));
			}
			if (displayValue === "above") {
				this.$$panel.find(".s-m-slider-value").detach().prependTo(this.$$panel.find("section"));
			}

		};

		this.destroyMarkup = function() {
			this.options.startHandler = null;
			this.options.stopHandler = null;
			this.options.slideHandler = null;
			this.options = null;
			if (this.$$slider) {
				this.$$slider.off();
				this.$$slider.slider('destroy');
				this.$$slider = null;
			}
			if (this.$$panel) {
				this.$$panel.remove();
			}
		};

		this.onSlider = function(slideEvt, action) {
			if (action === "start") {
				this.options.startHandler(slideEvt.value, this);
				return;
			}
			if (action === "slide") {
				this.$$textValue.text(this.options.slideHandler ? this.options.slideHandler(slideEvt.value, this) : slideEvt.value);
				return;
			}
			if (action === "stop") {
				if (this.options.value != slideEvt.value) {
					this.options.value = slideEvt.value;
					this.options.stopHandler(slideEvt.value, this);
				}
				return;
			}
		};

		this.update = function(opts) {
			if (!opts) return;
			if (opts.min != null) this.$$slider.slider('setAttribute', 'min', opts.min);
			if (opts.max != null) this.$$slider.slider('setAttribute', 'max', opts.max);
			if (opts.step != null) this.$$slider.slider('setAttribute', 'step', opts.step);
			if (opts.value != null) {
				this.$$slider.slider('setValue', opts.value);
				this.$$textValue.text(this.options.slideHandler ? this.options.slideHandler(opts.value) : opts.value);
			}
		};
	},
	/**
	 * lis:[{label, checked}]
	 */
	"checkboxList": function(options, name) {
		options = options || {};
		this.options = options;
		this.name = name || "checkboxList";
		this.createMarkup = function($$parent) {
			this.$$panel = $(_getHtml("checkboxList", {
				id: options.id,
				css: options.css || ""
			})).appendTo($$parent);
			if (options.isHidden === true) {
				this.hide();
			}
			if (this.options.onClick) {
				this.$$panel.on('click', 'input[type="checkbox"]', jsutils.bindFn(this.onClick, this));
			}
			this._createList(options.list);
			return this.$$panel;
		};
		this.destroyMarkup = function() {
			if (this.$$panel) {
				this.$$panel.find('input[type="checkbox"]').off();
				this.$$panel.off();
				this.$$panel = null;
			}
			this.options = null;
		};
		this.onClick = function(evt) {
			var $$input = $(evt.target);
			this.options.onClick($$input.closest(".s-m-item").attr("data-id"), $$input.is(":checked"));
		};
		/**
		 * Format	array 	-> [{id:id1, checked: true},{id2, checked: false}]
		 * Format	object 	-> {id1: true, id2:false}
		 * Default is object
		 */
		this.getValue = function(format) {
			if (!this._$$list) return null;
			var obj = format !== "array";
			var res = obj ? {} : [];
			this._$$list.find(".s-m-item").each(function() {
				var $$this = $(this);
				if (!$$this.is(":visible")) return;
				var checked = $$this.find("input:checkbox").prop("checked") === true;
				var id = $$this.attr("data-id");
				if (obj) {
					res[id] = checked;
				} else {
					res.push({
						checked: checked,
						id: id
					});
				}
			});
			return res;
		};
		this.setValue = function(list) {
			this.updateValue(list);
		};
		this.reset = function() {
			this.updateValue(null);
		};
		/**
		 * accept list
		 * 	{id1: true, id2:false}
		 * 	[{id:id1, checked: true},{id2, checked: false}]
		 */
		this.updateValue = function(list) {
			if (!this.$$panel) return;
			var self = this;
			self._$$list.find("[data-id]").each(function() {
				$(this).val(false);
			});
			list = this._checkInputList(list);
			if (list.length === 0) return;
			list.forEach(function(itm) {
				if (!itm || !itm.id) return;
				var $$item = self._$$list.find('[data-id="' + itm.id + '"]');
				if ($$item.length === 0) return;
				if (itm.isHidden === true) $$item.hide();
				if (itm.checked !== true) return;
				$$item.attr("data-id", itm.id);
				$$item.find("input:checkbox").prop("checked", itm.checked === true);
				$$item.find("label").text(itm.label);
			});
		};
		/**
		 * accept list
		 * 	{id1: true, id2:false}
		 * 	[{id:id1, checked: true},{id2, checked: false}]
		 */
		this._createList = function(list) {
			if (!this.$$panel) return;
			if (this._$$list) this._$$list.remove();
			list = this._checkInputList(list);
			var newList = [];
			list.forEach(function(itm) {
				if (itm.id) {
					itm.id = itm.id;
					itm.checked = itm.checked === true;
					itm.label = itm.label || itm.id;
					newList.push(itm);
				}
			});
			this._$$list = $(_getHtml("checkboxListContent", {
				list: newList
			})).appendTo(this.$$panel);
		};
		this._arrayToPlainobject = function() {

		};
		// accept {id1: true, id2:false} and return [{id:id1, checked: true},{id2, checked: false}]
		this._checkInputList = function(list) {
			if (!list) return [];
			if (Array.isArray(list)) return list;
			if (!$.isPlainObject(list)) return [];
			var res = [];
			for (var p in list) {
				res.push({
					id: p,
					checked: list[p] === true
				});
			}
			return res;
		};
	}
};
/**
 * type:	genericSlider, flatRadio, select, actionBtns
 * opts:	depends on component
 * name:	name of property / optional
 */
exports.newComponent = function(type, opts, name) {
	var f = _components[type];
	if (!f) throw new Error("Unknown authoring component [" + type + "]");
	return new f(opts, name);
};
});

define('syracuse-tablet/html/js/ui/modals/modalTranslationPage',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
		<buttons class="pull-right"> \
			<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
			<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
		</buttons> \
		<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="form-group"> \
					<table class="s-m-translation" >\
					<tr>\
					<th>{{currentLang.title}}</th><th>{{translateLang.title}}</th>\
					</tr>\
					{{#each localizations}}\
					<tr>\
					<td>{{this.value}}</td><td><input type="text" id="{{this.key}}" value="{{this.valueTranslate}}"></td>\
					</tr>\
					{{/each}}\
					</table>\
				</div> \
			</div>',

	footer: '',
};

var _Klass = utils.defineClass(
	function ModalTranslationPage(ctx) {
		this.context = $.extend(true, {}, ctx);
		modalDialog.ModalBase.call(this);
		this.result = null;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			return {
				std: _templateAll
			};
		},
		_getDataContext: function() {
			var localizations = [],
				$localization = this.context.$localization,
				currentLang = this.context.currentLang,
				translateLang = this.context.translateLang;
			if (!$localization[currentLang.value]) return [];
			Object.keys($localization[currentLang.value]).forEach(function(key) {
				if ($localization[currentLang.value][key]) {
					localizations.push({
						'key': key,
						'value': $localization[currentLang.value][key],
						'valueTranslate': ($localization[translateLang.value] && $localization[translateLang.value][key]) ? $localization[translateLang.value][key] : "",
					});
				}
			});
			var data = {};
			data.localizations = localizations;
			data.currentLang = currentLang;
			data.translateLang = translateLang;
			data.title = this.context.pageTitle;
			return data;
		},
		_onShow: function() {
			modalDialog.ModalBase.prototype._onShow.call(this);
		},
		_onValidate: function() {
			var currentLang = this.context.currentLang.value,
				translateLang = this.context.translateLang.value,
				localization = this.context.$localization,
				value, res;

			Object.keys(localization[currentLang]).forEach(function(key) {
				value = $("input[id='" + key + "'").val();
				if (localization[translateLang] && localization[translateLang][key] !== "") { //keep existing value
					if (!res) res = {};
					res[key] = localization[translateLang][key];
				}
				if ((!localization[translateLang] && value !== "") || //no localization and at less a value filled
					(localization[translateLang] &&
						((localization[translateLang][key] && value != localization[translateLang][key]) || //key but value dif
							(!localization[translateLang][key] && value)))) { //no key new value
					if (!res) res = {};
					res[key] = value;
				}
			});
			if (res) {
				localization[translateLang] = res;
				this.result = localization;
			}
		},
		_onCancel: function() {
			this.result = null;
		},
		_getResult: function() {
			return this.result;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral',['require','exports','module','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/authoring/authoringVal','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/sdata/sdataCommonResources','syracuse-tablet/html/js/ui/modals/modalTranslationPage'],function (require, exports, module) {"use strict";
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var authVal = require('syracuse-tablet/html/js/authoring/authoringVal');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var sdataCommonResources = require('syracuse-tablet/html/js/sdata/sdataCommonResources');
var modalTranslationPage = require('syracuse-tablet/html/js/ui/modals/modalTranslationPage');

var _colorPalette = [{
	title: "primecolor",
	items: ["sagegreen", "green", "blue", "darkgrey", "white", "black"]
}, {
	title: "secondcolor",
	items: ["lightgreen", "grey", "medium-grey", "orange", "purple", "medium-purple", "skyblue"]
}, {
	title: "notifcolors",
	items: ["alert", "warning"]
}];
var _cachePalette = {};
var _getColorPalette = function() {
	if (_cachePalette.colorPalette) {
		return _cachePalette.colorPalette;
	}
	_cachePalette.colorPalette = [];
	var _scan = function(items, array) {
		array = array || [];
		items.forEach(function(item) {
			if (item.items) {
				var items = _scan(item.items);
				array.push({
					title: item.title ? locale.text("colorsPalette." + item.title) : null,
					items: items
				});
			} else if (typeof item === "string") {
				var id = item.toLowerCase();
				array.push({
					id: id,
					name: locale.textNoFail("colorsPalette.colors." + id) || item.smCapitalize(),
					css: "s-m-color-" + id
				});
			}
		});
		return array;
	};
	return _scan(_colorPalette, _cachePalette.colorPalette);
};
/**
 * Returns a standard value/label list
 */
var _getColorValues = function() {
	if (_cachePalette.colorValues) {
		return _cachePalette.colorValues;
	}
	_cachePalette.colorValues = [];
	var _scan = function(items) {
		items.forEach(function(item) {
			if (item.items) {
				_scan(item.items);
			} else if (typeof item === "string") {
				_cachePalette.colorValues.push({
					value: item.toLowerCase(),
					label: locale.textNoFail("colorsPalette.colors." + item) || item.smCapitalize()
				});
			}
		});
	};
	_scan(_colorPalette);
	return _cachePalette.colorValues;
};
/**
 * Returns info  for color id
 */
var _getColorInfo = function(id) {
	if (_cachePalette.colorInfos) {
		return _cachePalette.colorInfos[id];
	}
	_cachePalette.colorInfos = {};
	_getColorValues().forEach(function(color) {
		_cachePalette.colorInfos[color.value] = {
			id: color.value,
			name: color.label,
			css: "s-m-color-" + color.value
		};
	});
	return _cachePalette.colorInfos[id];
};
var _openInNewTab = function(tabid, jsonString, title) {
	if (!jsonString || jsonString.trim().length === 0) return;
	var myWindow = window.open("about:blank", tabid, undefined, true);
	setTimeout(function() {
		myWindow.document.write("<html><body><pre>" + (title ? title + "\n" : "") + locale.text("auth.panel.label_date") + ": " + (new Date()).toLocaleString() + "</pre><pre>" + jsonString + "</pre></body></html>");
	});
};

var _properties = {
	/*
	 * Dummy to add a separator
	 */
	"SEPARATOR": {
		isSeparatror: true
	},

	/*
	 * Full JSON article of selection for experts
	 */
	"JSON": {
		"key": "$JSON",
		createMarkup: _createMarkupJSON,
		type: "expert"
	},
	/*
	 * Read only display of prototype
	 */
	"PROTOTYPE": {
		"key": "$PROTOYPE",
		createMarkup: _createMarkupPrototype,
		type: "expert"
	},
	"translation": function(controller, sel, data) {
		if (!data.articleSelection.$localization || $.isEmptyObject(data.articleSelection.$localization[globals.getUserCtx().$lang])) return null;
		this.name = "translation";
		this.type = "expert";
		this.createMarkup = function($$parent, prop, sel, data) {
			var self = this;
			sdataCommonResources.queryLocalePreferences().then(function(ls) {
				var selectOpts = [];
				ls.forEach(function(v) {
					selectOpts.push({
						'title': v.description,
						'value': v.code
					});
				});
				var opts = {
					options: selectOpts,
					//onChange: self.onChange.bind(self, $$parent)
					onChange: self.onChange.bind(self, $$parent, data)

				};
				self.langList = authComponents.newComponent("select", opts, "selectLang");
				self.langList.createMarkup($$parent);
			});

		};
		this.onChange = function($$parent, data, event, componentSelect) {
			var context = {};
			context.$localization = data.articleSelection.$localization;
			context.currentLang = {
				'value': globals.getUserCtx().$lang,
				'title': getLangDescription(globals.getUserCtx().$lang, componentSelect.options.options)
			};
			context.translateLang = {
				'value': componentSelect.getValue(),
				'title': getLangDescription(componentSelect.getValue(), componentSelect.options.options)
			};
			this.buildPanel($$parent, data, context);
		};
		this.buildPanel = function($$parent, data, context) {
			if (this.$$panel == undefined) {
				var html = authHtml.execute("authPanelButton", {
					label: locale.text("auth.translation.openPage"),
					css: "s-m-auth-translation-open"
				});
				this.$$panel = $(html);
				this.$$panel.attr("data-action", "openTranslation");
				$$parent.append(this.$$panel);
			} else {
				this.$$panel.off("click");
			}
			var eventData = {};
			eventData.$$parent = $$parent;
			eventData.data = data;
			eventData.context = context;
			eventData.context.pageTitle = locale.text("auth.translation.page"),
			this.$$panel.click(eventData, function() {
				var modal = new modalTranslationPage.Modal(eventData.context);
				modal.show().then(function(result) {
					if (result) {
						eventData.data.articleSelection.$localization = result;
						_notifyChangePropUI(eventData.$$parent, null, eventData.data);
					}
				}).fail(function(e) {
					globals.getModal().error(e);
				});
			});
		};
	}
};

function _createMarkupJSON($$parent, prop, sel, data) {
	// This is only displayed if the full page is selected, so we always show the article of the page and not the article
	// of the selected UI compontent (UI component is always the page)
	var value = authVal.toSortedJSON(data.articlePage);
	var html = authHtml.execute("authPanelPropertyJSON", {
		id: "auth_opt_" + prop.name,
		value: value,
		label_apply: locale.text("auth.panel.label_apply"),
		label_display: locale.text("auth.panel.label_display")
	});
	var $$panel = $(html);
	var title = sel.$$elmt.text();
	var _getJson = function(validate) {
		var val = $("textarea", $$panel).val();
		var articleParsed;
		if (validate) {
			articleParsed = authVal.validateJSON(true, $("textarea", $$panel).val(), _properties);
		} else {
			try {
				articleParsed = JSON.parse(val);
			} catch (e) {
				return jsutils.convertToDiagnoses(e);
			}
		}
		return articleParsed ? authVal.toSortedJSON(articleParsed) : null;
	};
	$("a[data-action]", $$panel).click(function() {
		var act = $(this).attr("data-action");
		try {
			if (act === "jsonApply") {
				// Full page article exchange
				var articleString = _getJson(true);
				if (articleString) {
					notifications.publish(["sm.auth.change.prop.ui"], articleString);
				}
			} else if (act === "openInNewTab") {
				var title = globals.getApplication().currentPage.prototype;
				if (title) title = title.data("$title");
				title = title && title.length > 0 ? locale.text("auth.panel.label_page") + ": " + title : "";
				_openInNewTab("sageMobileJsonAuthoring", _getJson(false), title);
			}
		} catch (e) {
			console.log(e.stack);
			throw (e);
		}
	});
	$$parent.append($$panel);
}

function _createMarkupPrototype($$parent, prop, sel, data) {
	var json;
	var isPage = sel.$$elmt && sel.$$elmt.is(".s-m-page");
	var title;
	if (data.control) {
		json = data.control.prototype && data.control.prototype.json;
		title = data.control.$bind || data.control.id;
	} else if (isPage) {
		var controller = sel.$$elmt.smPageController();
		if (controller) {
			title = controller.prototype.data("$title");
			json = controller.prototype && controller.prototype.json;
		}
	}
	var value;
	if (json) {
		value = JSON.stringify(json, null, " ");
	} else {
		value = locale.text("auth.PROTOTYPE_NONE");
	}
	var html = authHtml.execute("authPanelPropertyPROTOTYPE", {
		id: "auth_opt_" + prop.name,
		value: value,
		label_display: locale.text("auth.panel.label_display")
	});
	var $$panel = $(html);
	$$parent.append($$panel);
	if (json && !$.isEmptyObject(json)) {
		$("a[data-action]", $$panel).click(function() {
			var act = $(this).attr("data-action");
			if (act === "openInNewTab") {
				title = locale.text("auth.panel.label_" + (isPage ? "page" : "control")) + ": " + title;
				_openInNewTab("sageMobilePrototype", authVal.toSortedJSON(json), title);
			}
		});
	}
}
var _initProperty = function(p) {
	var pre = "auth";
	var lk = pre + "." + p.name;
	if (p.label == null) {
		p.label = locale.text(lk);
	}
	if (p.values) {
		p.values.forEach(function(v, idx) {
			if ($.isPlainObject(v)) {
				var vk = lk + "." + ("" + ((v.value != null ? v.value : v.key)));
				if (v.label == null) {
					v.label = locale.text(vk);
				}
			} else {
				p.values[idx] = {
					label: v + "",
					valu: v
				};
			}
		});
	}
};
var _initProperties = function(properties, dest) {
	var pre = "auth";
	Object.keys(properties).forEach(function(prop) {
		var p = properties[prop];
		if (dest) {
			dest[prop] = p;
		}
		if (typeof p === "function") {
			return;
		}
		p.name = prop;
		_initProperty(p);
	});
};

var _err = function(title, ee) {
	modal.error(title, ee);
	return true;
};

function getLangDescription(lang, langList) {
	var desc;
	langList.forEach(function(v) {
		if (v.value === lang) {
			desc = v.title;
		}
	});
	return desc;
}

function _getValueOrDefault(prop, sel, data) {
	var value = data.articleSelection && data.articleSelection[prop.key];
	value = (value != null) ? value : prop["default"];
	return value;
}

function _setValue(prop, sel, data, value) {
	data.articleSelection[prop.key] = value;

	// To flag control that has been changed
	data.articleSelection["$isDirty"] = data.articleSelection["$isDirty"] || {};
	data.articleSelection["$isDirty"][prop.key] = true;
}

function _notifyChangePropUI($$parent, sel, data) {
	var $$json = $("textarea#auth_opt_JSON");
	$$json.val(authVal.toSortedJSON(data.articleSelection));
	notifications.publish(["sm.auth.change.item.prop.ui"], data);
}

function _notifyAuthVariantChange(article) {
	var articleString = authVal.toSortedJSON(article);
	$("textarea#auth_opt_JSON").val(articleString);
	notifications.publish(["sm.auth.change.prop.ui"], articleString);
}

function _createMarkupRadio($$parent, prop, sel, data) {

	var ctx = {
		group: "auth_opt_" + prop.name,
		options: []
	};

	var value = _getValueOrDefault(prop, sel, data);
	var allHidden = true;

	prop.values.forEach(function(v) {
		ctx.options.push({
			id: ctx.group + "_" + v.value,
			value: "" + v.value,
			label: v.label,
			display: (v.isHidden ? "none" : "block")
		});
		allHidden = allHidden && v.isHidden;
	});

	var html = authHtml.execute("authPanelPropertyRadio", ctx);
	var $$panel = $(html);
	$("label[data-s-m-auth-value='" + ("" + value) + "']", $$panel).eq(0).button("toggle");
	$("label", $$panel).on("click", function(e) {
		var $$ct = $(e.currentTarget);
		var value = $$ct.attr("data-s-m-auth-value");
		$$ct.eq(0).button("toggle");

		/*
		 * Important! Use boolean datatype for boolean properties!
		 */
		if (value === "true") {
			value = true;
		} else if (value === "false") {
			value = false;
		}
		_setValue(prop, sel, data, value);
		_notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);

	if (allHidden) {
		$$parent.parent(".s-m-panel-auth-prop").hide();
	} else {
		$$parent.parent(".s-m-panel-auth-prop").show();
	}
}

function _refreshMarkupRadio($$parent, prop, sel, data) {
	var allHidden = true;
	prop.values.forEach(function(v) {
		var id = "auth_opt_" + prop.name + "_" + v.value;
		var $$btn = $("#" + id, $$parent);
		var display = v.isHidden ? "none" : "block";
		$$btn.css("display", display);
		allHidden = allHidden && v.isHidden;
	});
	if (allHidden) {
		$$parent.parent(".s-m-panel-auth-prop").hide();
	} else {
		$$parent.parent(".s-m-panel-auth-prop").show();
	}
}

function _createMarkupCheckboxes($$parent, prop, sel, data) {

	var ctx = {
		group: "auth_opt_" + prop.name,
		options: []
	};

	var allHidden = true;

	var value = data.articleSelection && data.articleSelection[prop.key] || {};
	prop.values.forEach(function(v) {
		var cb = value[v.key] != null ? value[v.key] : v["default"];
		ctx.options.push({
			id: ctx.group + "_" + v.key,
			value: v.key,
			label: v.label,
			checked: cb,
			display: (v.isHidden ? "none" : "block")
		});
		allHidden = allHidden && v.isHidden;
	});

	var html = authHtml.execute("authPanelPropertyCheckbox", ctx);
	var $$panel = $(html);

	$("label", $$panel).on("click", function(e) {
		// #7840 We use an icon instead of a check box because click with input tag doesn't work fin with the label
		var $$ct = $(e.target);
		var key = $$ct.attr("data-s-m-auth-value");
		var $$cb = $("i", $$ct);
		var value = $("i", $$ct).toggleClass("fa-check-square").is(".fa-check-square");
		var v = data.articleSelection[prop.key] = data.articleSelection[prop.key] || {};
		v[key] = value;
		_notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);

	if (allHidden) {
		$$parent.parent(".s-m-panel-auth-prop").hide();
	} else {
		$$parent.parent(".s-m-panel-auth-prop").show();
	}
}

function _refreshMarkupCheckboxes($$parent, prop, sel, data) {
	var allHidden = true;
	prop.values.forEach(function(v) {
		var id = "auth_opt_" + prop.name + "_" + v.key;
		var $$btn = $("#" + id, $$parent);
		var display = v.isHidden ? "none" : "block";
		$$btn.css("display", display);
		allHidden = allHidden && v.isHidden;
	});
	if (allHidden) {
		$$parent.parent(".s-m-panel-auth-prop").hide();
	} else {
		$$parent.parent(".s-m-panel-auth-prop").show();
	}
}

function _createMarkupIconPicker($$parent, prop, sel, data) {
	var value = data.articleSelection && data.articleSelection[prop.key] || null;
	var opts = {
		palette: prop["values"] || [],
		dropUp: prop["dropUp"] || true,
		onSelectIcon: function(value) {
			_setValue(prop, sel, data, value);
			_notifyChangePropUI($$parent, sel, data);
		}
	};
	prop._paletteIcon = authComponents.newComponent("iconPalettePicker", opts);
	prop._paletteIcon.createMarkup($$parent);
	prop._paletteIcon.setValue(data.articleSelection[prop.key] || prop["default"]);
}

function _destroyMarkupIconPicker($$parent, prop, sel, data) {
	if (prop._paletteIcon) {
		prop._paletteIcon.destroyMarkup();
		prop._paletteIcon = null;
	}
}

exports.getColorValues = _getColorValues;
exports.getColorPalette = _getColorPalette;
exports.getColorInfo = _getColorInfo;

exports.properties = _properties;
exports.err = _err;
exports.createMarkupIconPicker = _createMarkupIconPicker;
exports.destroyMarkupIconPicker = _destroyMarkupIconPicker;
exports.createMarkupRadio = _createMarkupRadio;
exports.refreshMarkupRadio = _refreshMarkupRadio;
exports.createMarkupCheckboxes = _createMarkupCheckboxes;
exports.refreshMarkupCheckboxes = _refreshMarkupCheckboxes;
exports.getValueOrDefault = _getValueOrDefault;
exports.setValue = _setValue;
exports.notifyAuthVariantChange = _notifyAuthVariantChange;
exports.notifyChangePropUI = _notifyChangePropUI;
exports.initProperties = _initProperties;
exports.initProperty = _initProperty;
exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	// Always add JSON editting and proto display
	props.push(_properties.SEPARATOR);
	if ($$elmt.is(".s-m-page")) {
		props.push(_properties.JSON);
		props.push(_properties.SEPARATOR);
		props.push(_properties.PROTOTYPE);
		props.push(_properties.SEPARATOR);
		props.push(_properties.translation);
	} else if (data && data.control && data.control.prototype) {
		props.push(_properties.PROTOTYPE);
	}
};
exports.initModuleProperties = function(dest) {
	exports.initProperties(_properties, dest);
};
});

define('syracuse-tablet/html/js/authoring/arrays/authArrayGeneral',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {"use strict";
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

var _templates = {
	subtitle: '\
		<section class="s-m-prop-subtitle" {{#if id}}id="{{id}}"{{/if}} style="{{#if notHidden}}overflow:hidden;{{/if}}white-space:nowrap;text-overflow:ellipsis;{{#if margin}}margin-bottom:{{margin}}px;{{/if}}">\
			{{#if title}}<p>{{title}}</p>{{/if}}\
			<div></div>\
		</section>',
	subPropTitle: ' \
		<div class="panel panel-primary s-m-panel-auth-prop s-m-auth-prop-type-{{type}}"> \
			<div style="overflow:hidden;" class="panel-heading" role="tab" id="heading_{{id}}"> \
				<a style="width:100%;display:table;" data-toggle="collapse" data-parent="#{{#if parentId}}{{parentId}}{{/if}}{{#unless parentId}}accordion{{/unless}}" href="#collapse_{{id}}" {{#if expanded}} aria-expanded="true"{{/if}} aria-controls="collapse_{{id}}" {{#unless expanded}}class="collapsed"{{/unless}}>\
					<div style="display:table-row;white-space: nowrap;">\
						<h4 class="panel-title" style="display:table-cell;"> \
							{{label}}\
						</h4> \
						{{#if info}}<span style="padding-left: 10px;font-size:x-small;display:table-cell;text-align: right;"><i>{{info}}</i></span>{{/if}}\
					</div>\
				</a> \
			</div> \
			<div id="collapse_{{id}}" class="panel-collapse collapse {{#if expanded}}in{{/if}}" role="tabpanel" aria-labelledby="heading_{{id}}"> \
			</div> \
		</div>',
	statusLine: '\
		<span style="display:table;table-layout:fixed;width:100%">\
			<span style="display:table-row;">\
				<span style="display:table-cell;overflow:hidden;text-overflow:ellipsis;white-space: nowrap;">{{field}} {{operator}} {{value}}</span>\
				<span class="{{css}}" style="{{style}}display:table-cell;width:{{sizeColor}}px;height:{{sizeColor}}px;margin-right:5px;"></span>\
			</span>\
		</span>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};

var _properties = {
	/**
	 * Optional sel, data
	 * 	 not null when button property is created like a regular panel propety
	 *	 null when property is created from rightPanel (back from cardDesign to array)
	 */
	"chartDetailButton": function(controller, sel, data) {
		this.name = null;
		this.label = null;
		this.key = null;
		this.controller = controller;
		this.control = data.control;
		this.createButtonMarkup = function() {
			var level = this.control.level;
			var label = "auth." + ((level > 0 && this.control.hasSublevel()) ? "subLevel" : "chartDetail") + ".openDesign";
			this.$$OpenButton = $('<button id="auth_opt_chart_design" type="button" class="btn btn-default">' + locale.text(label) + '</button>');
			this.$$OpenButton.on("click", jsutils.bindFn(this.onClickButton, this));
			return this.$$OpenButton;
		};

		this.destroyButtonMarkup = function(context) {
			this.control = null;
			this.controller = null;
			if (this.$$OpenButton) {
				// $$slider.find(".$$slider") to make sur the plugin has been initialized
				this.$$OpenButton.off("click");
				this.$$OpenButton.remove();
				this.$$OpenButton = null;
			}
		};

		this.onClickButton = function(evt) {
			var opt = null,
				level = 0;
			if (this.control.hasSublevel()) {
				level = this.control.level + 1;
				var rowId = this.control.rowIdx2Id(0);
				opt = this.control.drillDownOpt(rowId);
				opt.level = level;
				if (level > 1) {
					opt.action = "$drillDown";
				}
			};
			this.control.triggerOpenChartDetail(opt);
			this.destroyButtonMarkup();
		};
	},
	"arrayDisplay": function(controller, sel, data) {
		this.name = "arrayDisplay";
		this.label = null;
		this.key = "$display";
		this["default"] = "table";
		this.values = [];
		var self = this;
		["table", "separator", "card", "carousel", "chart"].forEach(function(val) {
			if (data.control.isAuthoringPropAllowed == null || data.control.isAuthoringPropAllowed("arrayDisplay", val)) {
				self.values.push({
					value: val
				});
			}
		});
		this.createMarkup = authPropsGeneral.createMarkupRadio;
		this.refreshMarkup = authPropsGeneral.refreshMarkupRadio;

	},
	// only card
	"arraySeparator": {
		"key": "$separator",
		"default": "blank",
		values: [{
			value: "blank"
		}, {
			value: "dash"
		}, {
			value: "colon"
		}, {
			value: "semicolon"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio
	},
	// only query array
	"arrayProtoFilters": function(controller, sel, data) {
		this.name = "arrayProtoFilters";
		this.label = null;
		this.key = "$filters";
		// No filters displayed by default for vignette
		this["default"] = controller.isVignette ? "none" : "list";
		this.values = [{
			value: "list"
		}, {
			value: "tabs"
		}, {
			value: "none"
		}];
		this.createMarkup = authPropsGeneral.createMarkupRadio;
		this.refreshMarkup = authPropsGeneral.refreshMarkupRadio;
	},

	// only query array - link to details values are created dynamically
	"arrayQueryLink": function(controller, sel, data) {
		this.name = "arrayQueryLink";
		this.label = null;
		this.isHidden = true;
		this.values = [];
		this.key = "$detailsLink";
		this["default"] = "$details";
		this.createMarkup = authPropsGeneral.createMarkupRadio;
		this.refreshMarkup = authPropsGeneral.refreshMarkupRadio;

		this.initMarkup = function(controller, sel, data) {
			var links = data.control.prototype.getDataByPath("$item.$links");
			if (!links || links.length === 0) return;
			if (controller.isVignette) {
				// Add the capability to open query full page - Default option
				this["default"] = "$queryfullpage";
				this.values.push({
					value: "$queryfullpage",
					label: locale.text("auth.arrayQueryLink.queryfullpage")
				});
			}
			var self = this;
			// Add $links
			$.each(links, function(key, link) {
				var method = (link && link.$method) || "GET";
				if (link && method === "GET") {
					// For system level links (starting with $, we only allow the ones we know they are supported right now)
					if (key.indexOf("$") !== 0 || ["$edit", "$details"].indexOf(key) > -1) {
						self.values.push({
							value: key,
							label: link.$title ? controller.prototype.resolveExpression(link.$title) + " - " + key : key
						});
					}
				}
			});
			this.isHidden = (this.values.length === 1 && this.values[0].value === "$details");
		};
	},

	// Options of array
	"arrayOptions": function(controller, sel, data) {
		this.name = "arrayOptions";
		this.label = null;
		this.key = "$arrayOptions";
		var ctrl = data.control;
		this.values = [];
		if (ctrl.$display === "card" && ctrl.isCarouselDisplay()) {
			// Only rowIndex for carousel
			this.values.push({
				"key": "rowIndex",
				"default": true
			});
		} else if (ctrl.isArrayChart() && ctrl.isHighChart()) {
			// Only pagination for array in chart display
			this.values.push({
				"key": "showPagination",
				"default": false
			});
		} else {
			// Other than chart display
			if (!ctrl.isArrayField()) {
				// Arrays outside a details page
				this.values.push({
					"key": "showPagination",
					"default": controller.isVignette ? false : true
				});
				if (!ctrl.isArrayChart()) {
					// Filter and search disabled for request and stats
					this.values.push({
						"key": "showSortFilter",
						"default": controller.isVignette ? false : true
					});
					this.values.push({
						"key": "showSearch",
						"default": controller.isVignette ? false : true
					});
				}
			}
			if (ctrl.$display === "table" && !ctrl.prototype.isSingleArray() && !ctrl.isArrayChart()) {
				this.values.push({
					"key": "showRowDetailLink",
					// No row detail link by default
					"default": false
				});
			}
			this.values.push({
				"key": "rowIndex",
				"default": ctrl.$display === "card"
			});
			if (ctrl.$display === "card") {
				this.values.push({
					"key": "hideEmptyRows",
					"default": false
				});
			}
		}
		this.createMarkup = authPropsGeneral.createMarkupCheckboxes;
		this.refreshMarkup = authPropsGeneral.refreshMarkupCheckboxes;
	}
};

exports.getHtml = _getHtml;

exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	if (data.control.isArrayChart() && (controller.state.type !== "chartdetail" || data.control.hasSublevel())) {
		// button to open the detail of the chart (to design it)
		// Also button to open sub level design
		props.push(_properties.chartDetailButton);
	}
	props.push(_properties.arrayDisplay);
	if (data.control.$display === "separator") {
		props.push(_properties.arraySeparator);
	} else {
		// For chart and other arrays
		props.push(_properties.arrayOptions);
		if (!sel.$$elmt.is(".s-m-control.s-m-chart")) {
			// For non-chart arrays
			if (!data.control.isArrayField() && controller.$filtersGet() && controller.$filtersGet().length > 1) {
				props.push(_properties.arrayProtoFilters);
			}
			if (controller.prototype.isQuery()) {
				props.push(_properties.arrayQueryLink);
			}
		}
	}
};
});

define('syracuse-tablet/html/js/ui/fontUtils',['require','exports','module'],function (require, exports, module) {"use strict";
var _paginBtns = {
	"$first": "glyphicon glyphicon-step-backward",
	"$previous": "glyphicon glyphicon-chevron-left",
	"$next": "glyphicon glyphicon-chevron-right",
	"$last": "glyphicon glyphicon-step-forward"
};

var _tileIcons = [
	'adjust',
	'adn',
	'ambulance',
	'anchor',
	'android',
	'angellist',
	'apple',
	'archive',
	'asterisk',
	'automobile',
	'ban',
	'bank',
	'barcode',
	'bell',
	'bicycle',
	'binoculars',
	'bitbucket',
	'bolt',
	'book',
	'bookmark',
	'briefcase',
	'building',
	'bullhorn',
	'bullseye',
	'calculator',
	'calendar',
	'camera',
	'certificate',
	'chain',
	'child',
	'circle',
	'clipboard',
	'codepen',
	'cog',
	'cogs',
	'columns',
	'compass',
	'dashboard',
	'database',
	'envelope',
	'exclamation',
	'eye',
	'fax',
	'file',
	'flag',
	'flash',
	'folder',
	'globe',
	'heart',
	'home',
	'image',
	'inbox',
	'info',
	'institution',
	'key',
	'laptop',
	'leaf',
	'legal',
	'lock',
	'magic',
	'money',
	'paperclip',
	'phone',
	'plane',
	'rocket',
	'search',
	'shield',
	'sitemap',
	'sliders',
	'star',
	'steam',
	'stethoscope',
	'stop',
	'suitcase',
	'th',
	'tumblr',
	'twitch',
	'twitter',
	'umbrella',
	'warning',
	'wrench'
];

var _getIconByName = function(name) {
	switch (name) {
		case "$multiSelection":
			return "glyphicon glyphicon-list-alt";
		case "$cancelMultiSel":
		case "$cancelEdit":
			return "fa fa-undo";
		case "$edit":
			return "fa fa-edit";
		case "$query":
			return "fa fa-list";
		case "$save":
			return "fa fa-save";
		case "$details":
			return "fa fa-level-down";
		case "$delete":
			return "fa fa-trash-o";
		case "$create":
			return "fa fa-plus-square";
		case "$image-sign":
			return "fa fa-pencil";
		case "$image-camera":
			return "fa fa-camera";
		case "$image-ink":
			return "fa fa-paint-brush";
		case "appUpdate":
			return "fa fa-history";
		case "appSetup":
			return "fa fa-download";
		case "gear":
			return "fa fa-gear";
		case "expand":
			return "fa fa-expand";
		case "compress":
			return "fa fa-compress";
		case "GPSPicker":
			return "fa fa-dot-circle-o";
		case "scanBarcodePicker":
			return "fa fa-barcode";
		case "penTextInputPicker":
			return "fa fa-pencil-square-o";
		case "$showtemplates":
			return "fa fa-file-text-o";
		case "$showtemplatesEmpty":
			return "fa fa-file-o";
		case "$apply":
			return "fa fa-check";
		case "$refresh":
			return "fa fa-save";
		case "lookupPicker":
			return "glyphicon glyphicon-eye-open";
		case "datePicker":
			return "glyphicon glyphicon-calendar";
		case "timePicker":
			return "glyphicon glyphicon-time";
	}
	// Icon names used for tiles or tile headers
	if (_tileIcons.indexOf(name) > -1) {
		return "fa fa-" + name;
	}

	return "";
};

exports.getIconByName = _getIconByName;
exports.checkBoxIcon = function(val) {
	return ["glyphicon", val ? "glyphicon-ok" : "glyphicon-remove"];
};
exports.phoneFieldIcon = function() {
	return "fa fa-phone";
};
exports.emailFieldIcon = function() {
	return "fa fa-envelope-o";
};
exports.documentFieldIcon = function() {
	return "fa fa-file-text";
};
exports.binaryFieldIcon = function() {
	return "fa fa-file-0";
};
exports.paginationIcon = function(linkName) {
	return _paginBtns[linkName];
};
exports.layoutExpandCollapseIcon = function(collapse, advancedTheme) {
	if (collapse) {
		return advancedTheme ? "fa fa-ellipsis-h" : "fa fa-chevron-down";
	} else {
		return advancedTheme ? "fa fa-times" : "fa fa-chevron-up";
	}
};
exports.pageIcon = function(name) {
	if (name === "settings") return "fa fa-gear";
	if (name === "clearCache") return "fa fa-history";
	if (name === "switchContext") return "fa fa-user";
	if (name === "search") return "fa fa-search";
	if (name === "sidePanelL") return "fa fa-caret-square-o-left";
	if (name === "sidePanelR") return "fa fa-angle-double-right";
	//if (name === "sidePanelR") return "fa fa-caret-square-o-right";
	if (name === "home") return "fa fa-home";
	if (name === "designPage") return "fa fa-paint-brush";
	if (name === "back") return "fa fa-arrow-circle-o-left";
	if (name === "developmentPage") return "fa fa-wrench";
	if (name === "bars") return "fa fa-bars";
	if (name === "backIphone") return "fa fa-angle-left";
	if (name === "about") return "fa fa-info-circle";
	if (name === "logout") return "fa fa-sign-out";
	if (name === "pinPage_1") return "fa fa-thumb-tack";
	if (name === "pinPage_2") return "fa fa-times";
	if (name === "pageConfig") return "fa fa-paint-brush";
	if (name === "nativeShare") return "fa fa-share-alt";
	if (name === "mailto") return "fa fa-envelope";
	if (name === "freshness") return "fa fa-bookmark";
	if (name === "drafts") return "fa fa-building-o";
};
exports.ctrlIcon = function(name) {
	if (name === "editrow") return "fa fa-pencil-square-o";
	if (name === "detailrow") return "fa fa-hand-o-right";
	if (name === "delrow") return "fa fa-remove";
	if (name === "addrow") return "fa fa-plus";
};
exports.vignetteIcons = function(name) {
	if (name === "home") return "fa fa-home";
	if (name === "back") return "fa fa fa-arrow-circle-o-left";
	if (name === "refresh") return "fa fa-history";
};

exports.sortIcon = function(name) {
	if (name === "asc") return "fa fa-long-arrow-up";
	if (name === "none") return "fa fa-times";
	if (name === "desc") return "fa fa-long-arrow-down";
};

exports.filterIcon = function(name) {
	if (name === "panel") return "fa fa-bars";
	if (name === "filtered") return "fa fa-filter";
	if (name === "edit") return "fa fa-pencil";
	if (name === "delete") return "fa fa-times";
	if (name === "separator") return "fa fa-plus";
};
exports.sortFilterTab = function(name) {
	if (name === "sort") return "fa fa-arrows-v";
	if (name === "filter") return "fa fa-filter";
	if (name === "memo") return "fa fa-star";
	if (name === "apply") return "fa fa-check";
};
/* 
 * List of icon names that can be selected by tile customisation
 * These are only the FA icons that look appropriate
 */
exports.getTileIconList = function() {
	return _tileIcons;
};
var _arrayStatusIconNames = ["thumbs-down", "thumbs-o-down", "thumbs-up", "thumbs-o-up", "hand-o-down", "hand-o-up", "lock", "unlock", "unlock-alt", "smile-o", "meh-o", "check", "check-circle", "check-circle-o", "check-square", "check-square-o", "square", "square-o", "circle", "circle-thin", "circle-o", "close", "comment", "comment-o", "comments", "comments-o", "photo", "film", "barcode", "bars", "plus", "plus-circle", "plus-square", "plus-square-o", "minus", "minus-circle", "minus-square", "minus-square-o", "question", "question-circle", "trash", "trash-o", "info", "info-circle", "flag", "flag-checkered", "flag-o", "female", "male", "mars", "venus", "user", "users", "user-plus", "user-times", "user-secret", "facebook-official", "file", "file-o", "dollar", "eur", "gbp", "yen", "rub", "rupee", "shekel", "cny", "ils", "inr", "krw", "money", "turkish-lira", "won", "envelope-square", "envelope-o", "envelope", "exclamation", "exclamation-circle", "exclamation-triangle"];
var _arrayStatusIcons = null;
var _getArrayStatusIconList = function() {
	if (_arrayStatusIcons == null) {
		_arrayStatusIcons = [];
		_arrayStatusIconNames.forEach(function(name) {
			_arrayStatusIcons.push({
				css: "fa fa-" + name,
				name: name
			});
		});
	}
	return _arrayStatusIcons;
};
exports.getArrayStatusIconList = _getArrayStatusIconList;

exports.getArrayStatusDefIcon = function() {
	return {
		name: "circle",
		css: "fa fa-circle"
	};
};

/* Actions control - authoring */
var _arrayActionsIconNames = _arrayStatusIconNames.slice(0);
var _arrayActionsIcons = null;
var _getPageActionIcon = function() {
	if (_arrayActionsIcons == null) {
		_arrayActionsIconNames = _arrayActionsIconNames.concat(["download", "save", "undo", "edit", "history", "eraser", "reply", "refresh"]);
		_arrayActionsIcons = [];
		_arrayActionsIconNames.forEach(function(name) {
			_arrayActionsIcons.push({
				css: "fa fa-" + name,
				name: name
			});
		});
	}
	return _arrayActionsIcons;
};
exports.getPageActionIcon = _getPageActionIcon;

var _emptyImageIconNames = ["image", "user", "users", "warning", "file-movie-o", "file-image-o", "paperclip", "film"];
var _emptyImageIcons = null;
exports.getEmptyImageIconList = function() {
	if (_emptyImageIcons == null) {
		_emptyImageIcons = [];
		_emptyImageIconNames.forEach(function(name) {
			_emptyImageIcons.push({
				css: "fa fa-" + name,
				name: name
			});
		});
	}
	return _emptyImageIcons;
};
exports.getEmptyImageDefIcon = function() {
	return {
		name: "image",
		css: "fa fa-image"
	};
};
exports.getEmptyFileDefIcon = function() {
	return {
		name: "file",
		css: "fa fa-file"
	};
};

var _urlIconNames = ["globe", "map-marker", "street-view", "road", "link", "cloud", "database", "bed", "cutlery", "glass", "train", "subway", "taxi", "ship", "plane"];
var _urlIcons = null;
exports.getUrlIconList = function() {
	if (_urlIcons == null) {
		_urlIcons = [];
		_urlIconNames.forEach(function(name) {
			_urlIcons.push({
				css: "fa fa-" + name,
				name: name
			});
		});
	}
	return _urlIcons;
};
exports.getUrlDefIcon = function() {
	return {
		name: "Url",
		css: "fa fa-globe"
	};
};
var _colImageIconNames = ["image", "user", "users", "warning", "file-movie-o", "file-image-o", "paperclip", "film"];
var _colImageIcons = null;
exports.getColImageIconList = function() {
	if (_colImageIcons == null) {
		_colImageIcons = [];
		_colImageIconNames.forEach(function(name) {
			_colImageIcons.push({
				css: "fa fa-" + name,
				name: name
			});
		});
	}
	return _colImageIcons;
};
exports.getColImageDefIcon = function(emptyImage) {
	return {
		name: "image",
		css: emptyImage === true ? "fa fa-times" : "fa fa-image"
	};
};
exports.getPinVignetteIcon = function(what) {
	return what == "all" ? "fa fa-toggle-on fa-toggle-off" : what == "on" ? "fa fa-toggle-on" : "fa fa-toggle-off";
};
exports.getCarouselIcon = function(what) {
	return what == "left" ? "glyphicon glyphicon-chevron-left" : what == "right" ? "glyphicon glyphicon-chevron-right" : "";
};
exports.getDraftIcons = function(name) {
	switch (name) {
		case "synch":
			return "fa fa-upload";
		case "remove":
			return "fa fa-trash";
		case "stop":
			return "fa fa-stop";
	}
};
});

define('syracuse-tablet/html/js/authoring/arrays/authArrayTable',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/arrays/authArrayGeneral','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {"use strict";
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authArrayGeneral = require('syracuse-tablet/html/js/authoring/arrays/authArrayGeneral');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _maxCharWidth = 50;
var _defCharWidth = 20;
var _defPercentWidth = 20;
var _tableConfigKeys = ["$bind", "$type", "$titleOrig", "$widthType", "$widthVal", "$refDescFormat", "$refDescPosition", "$imgIcon", "$imgDisplayIcon", "$imgHeight"];

/**
 * Panel which displays the settings of a columns
 * 	FIELD - WIDTH - X-REFERENCE params
 */
var _TableColumnPanel = function(parent, colInfo) {
	this.name = "arrayTableColumn";
	this.label = colInfo.$title || colInfo.$bind;
	this.parent = parent;
	this.colInfo = colInfo;
	if (parent.isSingleArray || !this.colInfo.$widthType) {
		this.colInfo.$widthType = "auto";
	}
	this._myProperties = [];

	this.createMarkup = function($$parent) {
		this.$$parent = $$parent;
		if (!parent.isSingleArray) {
			this.colNameChoiceAdd();
			this.colWidthTypeAdd();
			this.colWidthValAdd();
		}
		this.colXrefAdd();
		this.colImageAdd();
		this.colImgHeightAdd();
	};

	this._add2PropHeading = function(title, prop, $$forceParent) {
		var $$root = $(authArrayGeneral.getHtml('subtitle', {
			title: title,
			margin: 10,
			id: prop.name
		})).appendTo($$forceParent || this.$$parent).find("div");
		if (prop.name === "selectName") {
			$$root.css({
				textOverflow: "inherit"
			});
		}
		if (prop.createMarkup) {
			prop.createMarkup($$root);
			this._myProperties.push(prop);
		} else if (prop.jquery) {
			$$root.append(prop);
		}
		return prop;
	};
	// COL NAME CHOICE
	this.colNameChoiceAdd = function() {
		var idx = this.parent.getFieldProto(this.colInfo.$bind).idx;
		var selectOpts = [];
		this.parent._protoValue.forEach(function(v) {
			selectOpts.push({
				title: v.$title,
				value: v.$bind
			});
		});
		var opts = {
			value: this.colInfo.$bind,
			options: selectOpts,
			onChange: jsutils.bindFn(this.colNameSelect, this),
		};
		this._add2PropHeading(locale.text('auth.tableDesign.selColName'), authComponents.newComponent("select", opts, "selectName"));
	};
	this.colNameSelect = function(event, prop) {
		this.colInfo = this.parent.getFieldProto($(event.target).val()).value;
		var $$title = prop.$$panel.closest(".panel-primary").find(".panel-title");
		$$title.text(this.colInfo.$title);
		$$title.next("span").find("i").text(this.colInfo ? this.colInfo.$bind : "");
		this.$$xrefroot.toggle(this.colInfo.$type === "application/x-reference");
		this.$$imageroot.toggle(this.colInfo.$type === "image");
	};
	// COL TYPE WIDTH	
	this.colWidthTypeAdd = function() {
		this._add2PropHeading(locale.text("auth.tableDesign.width"), authComponents.newComponent("flatRadio", {
			btns: [{
				value: "auto",
				title: locale.text("auth.tableDesign.auto")
			}, {
				value: "fixed",
				title: locale.text("auth.tableDesign.fixed")
			}, {
				value: "percent",
				title: "%"
			}],
			onClick: jsutils.bindFn(this.colWidthTypeChanged, this),
			value: this.colInfo.$widthType || "auto"
		}));
	};
	this.colWidthTypeChanged = function(evt) {
		if ($(evt.target).val() !== this.colInfo.$widthType) {
			this.colInfo.$widthType = $(evt.target).val();
			this.colWidthValUpdt();
		}
	};
	// COL VALUE	
	this.colWidthValAdd = function() {
		var opts = {
			slideHandler: jsutils.bindFn(this.colWidthValSlide, this),
			stopHandler: jsutils.bindFn(this.colWidthValChange, this),
			value: this.colInfo.$widthVal || 0,
			min: 0,
			max: this.colInfo.$widthType === "percent" ? 100 : _maxCharWidth,
			margin: 0
		};
		this.propWidthVal = this._add2PropHeading(locale.text("auth.tableDesign.selWidth"), authComponents.newComponent("genericSlider", opts));
		this.colWidthValUpdt(opts.value);
	};
	this.colWidthValSlide = function(val, prop) {
		return this.colInfo.$widthType === "percent" ? val + "%" : val + " " + locale.text("auth.tableDesign.characters");
	};
	this.colWidthValChange = function(val, prop) {
		this.colInfo.$widthVal = val;
	};
	this.colWidthValUpdt = function(forceValue) {
		var show = this.colInfo.$widthType !== "auto";
		this._toggleProp(this.propWidthVal, show);
		if (!show) {
			return;
		}
		this.propWidthVal.update({
			value: forceValue || (this.colInfo.$widthType === "percent" ? _defPercentWidth : _defCharWidth),
			max: this.colInfo.$widthType === "percent" ? 100 : _maxCharWidth,
		});
	};
	// COL X-REFERENCE
	this.colXrefAdd = function() {
		var style = this.colInfo.$type !== "application/x-reference" ? "display:none" : "";
		this.$$xrefroot = $('<section class="xrefColumn" style="' + style + '" ></section>').appendTo(this.$$parent);
		// Description format - $refDescPosition, $refDescFormat are x-reference properties
		// First
		var pos = this.colInfo["$refDescPosition"] || globals.XREF_DESCRPOS_TABLE;
		this._xrefDescrPos = this._createXRefSelect("pos", ["bottom", "right", "left", "top", "none"], pos);
		// Second
		this._xrefDescrFmt = this._createXRefSelect("fmt", ["desc", "title", "desctitle", "titledesc"], this.colInfo["$refDescFormat"] || "desc");
		// hide fmt if pos == none
		this.$$xrefroot.find("#selectDescrfmt").toggle(pos !== "none");
	};
	this._createXRefSelect = function(type, codes, def) {
		var selectOpts = [];
		var defIdx = codes.indexOf(def);
		if (defIdx == -1) defIdx = 0;
		var textRoot = "auth." + (type == "fmt" ? "refDescFormat" : "refDescPosition");
		codes.forEach(function(code, idx) {
			selectOpts.push({
				// Used by colXrefChange
				code: code,
				title: locale.text(textRoot + "." + code),
				value: idx
			});
		});
		var opts = {
			value: defIdx,
			options: selectOpts,
			onChange: jsutils.bindFn(this.colXrefChange, this, type)
		};
		this._add2PropHeading(locale.text(textRoot), authComponents.newComponent("select", opts, "selectDescr" + type), this.$$xrefroot);
		return selectOpts;
	},
	this.colXrefChange = function(event, prop, type) {
		var idx = parseInt($(event.target).val(), 10);
		var ref = type === "fmt" ? this._xrefDescrFmt : this._xrefDescrPos;
		ref = ref[idx].code;
		if (type == "pos") {
			// hide fmt if pos == none
			this.$$xrefroot.find("#selectDescrfmt").toggle(ref !== "none");
		}
		this.colInfo["$refDesc" + (type === "fmt" ? "Format" : "Position")] = ref;
	};
	// COL IMAGE
	this.colImageAdd = function() {
		var style = this.colInfo.$type !== "image" ? "display:none" : "";
		this.$$imageroot = $('<section class="ximageColumn" style="' + style + '" ></section>').appendTo(this.$$parent);
		// Switch
		var displayIcon = this.colInfo["$imgDisplayIcon"] === true;
		var opts = {
			checked: displayIcon,
			size: "small",
			onSwitchChange: this.onImgDisplayIconChanged.bind(this)
		};
		this._add2PropHeading(locale.text("auth.imgcol.displayIcon"), authComponents.newComponent("switcher", opts), this.$$imageroot);
		// Icon
		opts = {
			palette: fontUtils.getColImageIconList(),
			dropUp: true,
			icon: this.colInfo["$imgIcon"] || fontUtils.getColImageDefIcon(),
			onSelectIcon: this.onImgIconChanged.bind(this)
		};
		this.propImageIcon = this._add2PropHeading(locale.text("auth.imgcol.iconPicker"), authComponents.newComponent("iconPalettePicker", opts), this.$$imageroot);
		this._toggleProp(this.propImageIcon, displayIcon);
	};
	this.onImgIconChanged = function(icon) {
		this.colInfo["$imgIcon"] = icon;
	};
	this.onImgDisplayIconChanged = function(event, status) {
		this.colInfo["$imgDisplayIcon"] = status;
		this._toggleProp(this.propImageIcon, status);
	};
	this.colImgHeightAdd = function() {
		var opts = {
			value: this.colInfo["$imgHeight"] || "medium",
			options: [],
			onChange: jsutils.bindFn(this.imgHeightSelect, this),
		};
		["xsmall", "small", "medium", "large", "xlarge"].forEach(function(s) {
			opts.options.push({
				title: locale.text("auth.imgHeight." + s),
				value: s
			});
		});
		var prop = this._add2PropHeading(locale.text("auth.imgHeight"), authComponents.newComponent("select", opts));
		this._toggleProp(prop, this.colInfo.$type === "image");
	};
	this.imgHeightSelect = function(event, prop, type) {
		this.colInfo["$imgHeight"] = $(event.target).val();
	};
	this._toggleProp = function(prop, show) {
		return prop.$$panel.closest("section.s-m-prop-subtitle").toggle(show);
	};
	this.destroyMarkup = function() {
		this.parent = null;
		this.colInfo = null;
		// Before
		if (this._myProperties) {
			this._myProperties.forEach(function(p) {
				if (p.destroyMarkup) p.destroyMarkup();
			});
			this._myProperties = null;
		}
		// After
		if (this.$$parent) {
			this.$$parent.closest(".s-m-panel-auth-prop").remove();
			this.$$parent = null;
		}
	};
};
/**
 * General properties for 'table' array
 */
var _properties = {
	// Header of the table
	"arrayTableHeader": {
		"key": "$tableHeaderShow",
		"default": true,
		values: [{
			value: true
		}, {
			value: false
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio
	},

	// Design of columns
	// 		Number of columns
	//		Parameters of each column
	"arrayTableDesign": function(controller, sel, data) {
		this.isHidden = false;
		this.name = "arrayTableDesign";
		this.label = null;
		this.key = "$table";
		this.controller = controller;
		this.ctrlArray = data.control;
		this._generalProperties = [];
		this._columnProperties = [];
		this._protoValue = [];

		this.initMarkup = function(controller, sel, data) {
			//reduce protoValue to columns not hidden by X3
			this._protoValue = this.ctrlArray.getColumnsInfo(true);
			this.isSingleArray = this.ctrlArray.prototype.isSingleArray() || this._protoValue.length <= 1;
			this._orginalValue = data.articleSelection.$table;
			var hasValue = this._orginalValue != null && this._orginalValue.length > 0;
			if (!hasValue) {
				this._orginalValue = null;
			}
			this._initProps(hasValue ? this._orginalValue : this._protoValue);
			if (!this.isSingleArray) {
				this.addPropNbColumns();
			} else {
				this.isHidden = this._protoValue.length === 0 || this._protoValue[0].$type !== "application/x-reference";
			}
			if (!this.isHidden) {
				this.addPropActionButtons(sel, data);
			}
		};

		this._initProps = function(props, createEntry) {
			var self = this;
			self._columnProperties = [];
			props.forEach(function(prop) {
				self._createColumnProperty(prop, createEntry);
			});
		};

		this.addPropNbColumns = function() {
			var opts = {
				slideHandler: function(val) {
					return val + " columns";
				},
				stopHandler: jsutils.bindFn(this.updateColumns, this),
				value: this._columnProperties.length,
				min: 1,
				max: this._protoValue.length,
				displayValue: "above"
			};
			this._generalProperties.push(authComponents.newComponent("genericSlider", opts, "nbcolumns"));
		};

		this._updateNbCols = function() {
			var prop;
			this._generalProperties.some(function(p) {
				if (p.name === "nbcolumns") {
					prop = p;
					return true;
				}
			});
			prop.update({
				value: this._columnProperties.length
			});
		};

		this.addPropActionButtons = function(sel, data) {
			var btns = [{
				value: "save",
				title: locale.text("auth.tableDesign.save")
			}];
			this._generalProperties.push(authComponents.newComponent("actionBtns", {
				btns: btns,
				onClick: jsutils.bindFn(this.onClickAction, this, sel, data)
			}));
		};

		this.onClickAction = function(evt, sel, data) {
			var action = $(evt.target).val();
			if (action === "save") {
				var value = [],
					entry;
				var self = this,
					conf;
				this._columnProperties.forEach(function(prop) {
					if (!prop.colInfo) return;
					entry = {};
					_tableConfigKeys.forEach(function(p) {
						if (p !== "$titleOrig" || utils.isExpression(prop.colInfo[p])) {
							conf = prop.colInfo[p];
							if (conf != null) {
								entry[p] = $.isPlainObject(conf) ? $.extend(true, {}, conf) : conf;
							}
						}
					});
					value.push(entry);
				});
				//console.log(JSON.stringify(value, null, 2));
				authPropsGeneral.setValue(this, sel, data, value);
				authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
				return;
			}
			// restore/all - Not used - Wait for the global undo button implementation to remove them
			if (action === "restore") {
				if (this._orginalValue) {
					this._clearColumns();
					this._initProps($.extend(true, [], this._orginalValue), true);
					this._updateNbCols();
					return;
				}
				action = "all";
			}
			if (action === "all") {
				this.updateColumns(null);
				this._updateNbCols();
				return;
			}
		};

		this.createMarkup = function($$parent, prop, sel, data) {
			this.$$parent = $$parent;
			this._accordionId = utils.UUID();
			this.$$myAccordion = $('<div id="' + this._accordionId + '" ></div>');
			$$parent.append(this.$$myAccordion);
			var self = this,
				$$entry;
			self._generalProperties.forEach(function(prop) {
				$$entry = $(authArrayGeneral.getHtml('subtitle', {
					title: prop.label ? prop.label || prop.name : null,
				}));
				// create sub-property
				prop.createMarkup($$entry.find("div"));
				self.$$myAccordion.append($$entry);
			});
			self._columnProperties.forEach(function(prop) {
				self._createColEntry(prop);
			});
		};

		this._createColEntry = function(prop) {
			var id = utils.UUID();
			var $$parent;
			if (!this.isSingleArray) {
				var $$propGroup = $(authArrayGeneral.getHtml("subPropTitle", {
					id: id,
					type: "child columns",
					label: prop.label,
					info: prop.colInfo ? prop.colInfo.$bind : null,
					expanded: false,
					parentId: this._accordionId
				}));
				$$parent = $$propGroup.find("#collapse_" + id);
				this.$$myAccordion.append($$propGroup);
			} else {
				this.$$myAccordion.append($$propGroup);
				$$parent = $('<div style="padding-left:10px;padding-right:10px;"></div>').appendTo(this.$$myAccordion);
			}
			// create sub-property
			prop.createMarkup($$parent);
		};

		this.destroyMarkup = function() {
			this.$$parent = null;
			this.ctrlArray = null;
			this.controller = null;
			this._getAllProps().forEach(function(p) {
				p.destroyMarkup();
			});
			this._generalProperties = null;
			this._columnProperties = null;
		};

		this._getAllProps = function() {
			return (this._generalProperties || []).concat(this._columnProperties || []);
		};

		this.updateColumns = function(nbCols) {
			if (this.$$myAccordion) {
				this.$$myAccordion.find(".collapse").collapse('hide');
			}
			var init = nbCols == null;
			nbCols = init ? this._protoValue.length : nbCols;
			var startFrom = 0;
			if (init) {
				this._clearColumns();
			} else if (this._columnProperties.length > 0) {
				for (var i = this._columnProperties.length - 1; i >= nbCols; i--) {
					this._columnProperties[i].destroyMarkup();
					this._columnProperties.splice(i, 1);
				}
				startFrom = this._columnProperties.length;
			};
			for (var i = startFrom; i < nbCols; i++) {
				this._createColumnProperty(this._protoValue[i], true);
			}
		};

		this._createColumnProperty = function(config, createEntry) {
			var proto = this.getFieldProto(config.$bind, true);
			if (!proto) return null;
			// Update properties from prototype
			config.$title = this.controller.prototype.resolveExpression(proto.value.$title) || config.$bind;
			config.$type = proto.value.$type;
			config.$titleOrig = proto.value.$titleOrig;
			var prop = new _TableColumnPanel(this, config);
			this._columnProperties.push(prop);
			if (createEntry) {
				this._createColEntry(prop);
			}
			return prop;
		};

		this._clearColumns = function() {
			if (this._columnProperties) {
				this._columnProperties.forEach(function(p) {
					p.destroyMarkup();
				});
			}
			this._columnProperties = [];
		};

		this.getProtoValByIdx = function(idx) {
			if (idx < 0 || idx >= this._protoValue.length) throw new Error("unexpected bad index[" + idx + "]");
			return this._protoValue[idx];

		};

		this.getFieldProto = function(bind, noFail) {
			var res = null;
			this._protoValue.some(function(v, idx) {
				if (v.$bind === bind) {
					res = {
						idx: idx,
						value: v
					};
					return true;
				}
			});
			if (res == null && noFail !== true) throw new Error("unexpected null value - bind=[" + bind + "]");
			return res;
		};
	}
};
exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	if (!data.control.prototype.isSingleArray()) {
		props.push(_properties.arrayTableHeader);
	}
	props.push(_properties.arrayTableDesign);
};
});

define('syracuse-tablet/html/js/authoring/arrays/authArrayCard',['require','exports','module','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/application/eventListener','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {"use strict";
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

var _properties = {

	// only card
	"arrayCardsPerRow": {
		"key": "$cardsPerRow",
		"default": "2",
		values: [{
			value: "1"
		}, {
			value: "2"
		}, {
			value: "3"
		}, {
			value: "4"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio
	},

	/*
	 * Color of tile and layout cell
	 */
	"arrayBgColor": {
		"key": "$arrayBgColor",
		"default": "",
		"colorChange": function(value, sel, data, prop) {
			authPropsGeneral.setValue(this, sel, data, (value ? value.id : ""));
			authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
		},
		"createMarkup": function($$parent, prop, sel, data) {
			var opts = {
				color: "",
				palette: authPropsGeneral.getColorPalette(),
				dropUp: false,
				onSelectColor: jsutils.bindFn(this.colorChange, this, sel, data, prop)
			};
			this.paletteColor = authComponents.newComponent("colorPalettePicker", opts);
			this.paletteColor.createMarkup($$parent);
			this.paletteColor.setValue(authPropsGeneral.getColorInfo(data.control.article.$arrayBgColor));
		}
	},
	// only card
	"arrayCardsMinWidth": function(controller, sel, data) {
		this.name = "arrayCardsMinWidth";
		this.label = null;
		this.key = "$minWidth";
		this["default"] = 1;
		this.min = 0;
		this.max = 20;
		this.step = 1;

		this.createMarkup = function($$parent, prop, sel, data) {
			this.ctrl = data.control;
			this.$$parent = $$parent;
			this.originValue = authPropsGeneral.getValueOrDefault(this, sel, data);
			var opts = {
				id: "auth_opt_" + this.name,
				value: this.originValue,
				min: this.min,
				max: this.max,
				step: this.step || 1,
				slideHandler: jsutils.bindFn(this.onSlide, this, "slide"),
				startHandler: jsutils.bindFn(this.onSlide, this, "start"),
				stopHandler: jsutils.bindFn(this.onSlide, this, "stop", sel, data)
			};
			this._slider = authComponents.newComponent("genericSlider", opts);
			this._slider.createMarkup($$parent);
		};

		this.onSlide = function(value, prop, action, sel, data) {
			var res = this.ctrl.authOnSlideMinSize(value, action);
			if (action === "slide") return res;
			if (action === "stop" && this.originValue != value) {
				authPropsGeneral.setValue(this, sel, data, value);
				authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
			}
		};

		this.destroyMarkup = function() {
			this.ctrl = null;
			this.$$parent = null;
			if (this.$$slider) {
				this.$$slider.slider('destroy');
				this.$$slider = null;
			}
		};

		this._sliderSetValue = function(slideEvt, $$parent, sel, data, originValue) {
			this.ctrl.authOnSlideMinSize(slideEvt, "stop");
			if (originValue != slideEvt.value) {
				authPropsGeneral.setValue(this, sel, data, slideEvt.value);
				authPropsGeneral.notifyChangePropUI($$parent, sel, data);
			}
		};


	},
	/**
	 * Optional sel, data
	 * 	 not null when button property is created like a regular panel propety
	 *	 null when property is created from rightPanel (back from cardDesign to array)
	 */
	"arrayCardButton": function(controller, sel, data) {
		this.name = null;
		this.label = null;
		this.key = null;
		this.controller = controller;
		this.control = data.control;
		this.createButtonMarkup = function() {
			this.$$OpenButton = $('<button id="auth_opt_card_design" type="button" class="btn btn-default">' + locale.text("auth.tableDesign.openDesign") + '</button>');
			this.$$OpenButton.on("click", jsutils.bindFn(this.onClickOpenButton, this));
			return this.$$OpenButton;
		};

		this.destroyButtonMarkup = function(context) {
			this.control = null;
			this.controller = null;
			if (this.$$OpenButton) {
				// $$slider.find(".$$slider") to make sur the plugin has been initialized
				this.$$OpenButton.off("click");
				this.$$OpenButton.remove();
				this.$$OpenButton = null;
			}
		};

		this.onClickOpenButton = function(evt) {
			if (!this.control) return;
			// Trigger a navigation to carddesign page
			var attrs = {
				"data-control-id": this.control.id,
				"data-parent-id": this.controller.id,
				"data-nav": "carddesign",
				"data-nav-target": "application"
			};
			eventListener.triggerNavigation(this.control.$$elmt, attrs);
			this.destroyButtonMarkup();
		};
	},

	// only card
	"arrayCardsEmptyCells": {
		"key": "$emptycell",
		"default": "nodisplay",
		values: [{
			value: "filled"
		}, {
			value: "withtitle"
		}, {
			value: "nodisplay"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio
	}
};

exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	if (!data.control.prototype.isSingleArray()) {
		props.push(_properties.arrayCardsPerRow, _properties.arrayCardsMinWidth, _properties.arrayCardsEmptyCells, _properties.arrayCardButton, _properties.arrayBgColor);
	}
};

exports.getCardDesignButton = function(controller) {
	return new _properties.arrayCardButton(controller);
};
});

define('syracuse-tablet/html/js/helpers/fieldOperators',['require','exports','module','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var locale = require('syracuse-tablet/html/js/helpers/locale');

var _excludedTypes = ["application/x-array", "image", "application/x-document", "application/x-binary", "application/x-object", "text/rtf", "text/html", "application/x-password"];

var _numberOperators = ["gt", "ge", "lt", "le", "eq", "ne"];
var _stringOperators = ["like", "gt", "ge", "lt", "le", "eq", "ne", "like_s"];
var _defOperators = ["eq", "ne"];

var _DATE = {
	type: "application/x-date",
	checkFieldValue: function(fieldValue) {
		return String(fieldValue);
	},
	checkValue: function(value) {
		return String(value);

	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _TIME = {
	type: "application/x-time",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return value;

	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _DATETIME = {
	type: "application/x-datetime",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return value;

	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _DEC = {
	type: "application/x-decimal",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return parseFloat(value);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _REAL = {
	type: "application/x-real",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return parseFloat(value);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _INT = {
	type: "application/x-integer",
	checkFieldValue: function(fieldValue) {
		return parseInt(fieldValue, 10);
	},
	checkValue: function(value) {
		return parseInt(value, 10);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _QTY = {
	type: "application/x-quantity",
	checkFieldValue: function(fieldValue) {
		return parseFloat(fieldValue);
	},
	checkValue: function(value) {
		return parseFloat(value);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _STR = {
	type: "application/x-string",
	checkFieldValue: function(fieldValue) {
		return String(fieldValue);
	},
	checkValue: function(value) {
		return String(value);
	},
	operators: _stringOperators,
	defOperator: "like"
};
var _TEXT = {
	type: "text/plain",
	checkFieldValue: function(fieldValue) {
		return String(fieldValue);
	},
	checkValue: function(value) {
		return String(value);
	},
	operators: _stringOperators,
	defOperator: "like"
};
var _REF = {
	type: "application/x-reference",
	checkFieldValue: function(fieldValue) {
		return fieldValue && fieldValue.$value ? String(fieldValue.$value).toUpperCase() : null;
	},
	checkValue: function(value) {
		return value ? String(value).toUpperCase() : null;

	},
	operators: _stringOperators,
	defOperator: "like"
};
var _CHOICE = {
	type: "application/x-choice",
	checkFieldValue: function(fieldValue) {
		return parseInt(fieldValue, 10);
	},
	checkValue: function(value) {
		return parseInt(value, 10);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
/**
 * Boolean
 */
var _BOOL = {
	type: "application/x-boolean",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return value;
	},
	operators: _defOperators,
	defOperator: "eq"
};


var _types = {};
[_DATE, _TIME, _DATETIME, _DEC, _REAL, _INT, _QTY, _STR, _TEXT, _REF, _BOOL, _CHOICE].forEach(function(t) {
	_types[t.type] = t;
});


var _operatorsWithTitle = {};
/**
 * Return array of operators according to field type
 */
var _operatorsByType = function($type) {
	var t = _types[$type];
	return t ? t.operators : _defOperators;
};

var _getOperators = function($type, withTitle, exclude) {
	var operators;
	if (withTitle === true) {
		if (_operatorsWithTitle[$type] == null) {
			var ops = _operatorsByType($type);
			var res = [];
			ops.forEach(function(op) {
				res.push({
					title: locale.text("field.operator." + op),
					value: op
				});
			});
			_operatorsWithTitle[$type] = res;
		}
		operators = _operatorsWithTitle[$type];
	} else {
		operators = _operatorsByType($type);
	}
	if (exclude && exclude.length > 0) {
		var tmp = operators;
		operators = [];
		tmp.forEach(function(o) {
			if (exclude.indexOf(o) < 0) {
				operators.push(o);
			}
		});
	}
	return operators;
};

var _getDefaultOperator = function($type) {
	var t = _types[$type];
	return t ? t.defOperator : "eq";
};
var _evaluateOperator = function($type, fieldValue, operator, value) {
	var fieldType = _types[$type];
	if (fieldType == null) {
		console.log("_evaluateOperator - Type [" + $type + "] not evaluated");
		return false;
	}
	if (fieldType.operators.indexOf(operator) < 0) return false;
	fieldValue = fieldType.checkFieldValue(fieldValue);
	value = fieldType.checkValue(value);
	if (fieldValue == null || value == null) return false;
	if (operator === "eq") {
		return fieldValue == value;
	}
	if (operator === "ne") {
		return fieldValue != value;
	}
	if (operator === "like") {
		return fieldValue.indexOf ? fieldValue.indexOf(value) >= 0 : false;
	}
	if (operator === "like_s") {
		return fieldValue.smStartsWith ? fieldValue.smStartsWith(value) : false;
	}
	if (operator === "gt") {
		return fieldValue > value;
	}
	if (operator === "ge") {
		return fieldValue >= value;
	}
	if (operator === "lt") {
		return fieldValue < value;
	}
	if (operator === "le") {
		return fieldValue <= value;
	}
	return false;
};

exports.getDefaultOperator = _getDefaultOperator;
exports.getOperators = _getOperators;
exports.evaluateOperator = _evaluateOperator;
exports.acceptOperator = function($type) {
	return _excludedTypes.indexOf($type) < 0;
};
exports.checkValue = function($type, value) {
	var fieldType = _types[$type];
	return fieldType ? fieldType.checkValue(value) : null;
};
});

define('syracuse-tablet/html/js/helpers/types/date',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require("syracuse-tablet/html/js/helpers/locale");

var _dateInfo = locale.getDatetimeInfo;

function _padLeft(str, len, ch) {
	str = str ? str.toString() : '';
	if (!ch || ch.length == 0)
		ch = " ";
	while (str.length < len)
		str = ch + str;
	return str;
};

exports.validate = function(value, constraints, errors) {
	if (value == null) {
		if (constraints.$isMandatory)
			return errors.push(locale.text("date.valMan"));
		if (!constraints.$isNullable)
			return errors.push(locale.text("date.valNull"));
		return;
	}
	if (!(value instanceof DateObj)) {
		errors.push(locale.text("date.valDate"));
		return;
	}

	// month value check
	if (!(value.month >= 1 && value.month <= 12)) {
		errors.push(locale.text("date.invMonth"));
		return;
	}

	// day value check
	if (!(value.day >= 1 && value.day <= _daysInMonth(value.year, value.month))) {
		errors.push(locale.text("date.invDay"));
		return;
	}

};

var _monthOffsets = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var _monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

// internal value is integer yyyymmdd
// this is a very simple and compact representation that leads to
// very efficient component extraction and formatting. 
// Also nice for debugging

function DateObj(value) {
	this._value = value;
	//Object.freeze(this); -- confuses JSON, reenable later
}

function _dayName(weekDay, abbrev) {
	return abbrev ? _dateInfo().abbreviatedDayNames[weekDay] : _dateInfo().dayNames[weekDay];
}

function _monthName(month, abbrev) {
	return abbrev ? _dateInfo().abbreviatedMonthNames[month - 1] : _dateInfo().monthNames[month - 1];
}

function _pad2(val) {
	var s = val.toString();
	return (s.length == 1) ? "0" + s : s;
}

function _toOffset(date) {
	var year = date.year;
	var month = date.month;
	var day = date.day;
	// Compute the number of leap days since Jan 1st, 1970.
	// The trick is to use the previous year if month is January or February,
	// the current year otherwise.
	// Then, we compute the number of multiples of 4, 100 and 400 since 1970.
	var y = month <= 2 ? year - 1 : year;

	var n4 = Math.floor(y / 4) - Math.floor(1970 / 4);
	var n100 = Math.floor(y / 100) - Math.floor(1970 / 100);
	var n400 = Math.floor(y / 400) - Math.floor(1970 / 400);

	// Years that are multiple of 400 (like 2000) contribute by 1 (1 -1 +1 in expression below)
	// Years that are multiple of 100 but not of 400 contribute by 0 (1 -1 +0 in expression below)
	// Years that are multiple of 4 but not 100 nor 400 contribute by 1 (1 -0 +0 in expression below).
	var nLeap = n4 - n100 + n400;

	// The offset is straightforward at this point.
	// The February/March transition on leap days will be handled by the fact that the
	// 'y' value above will change, and hence the 'nLeap' value.
	return (year - 1970) * 365 + nLeap + _monthOffsets[month - 1] + day - 1;
}

function _fromOffset(offset) {
	var julian = 2440588 + offset;
	var l = julian + 68569;
	var n = Math.floor((4 * l) / 146097);
	l = l - Math.floor((146097 * n + 3) / 4);
	var i = Math.floor((4000 * (l + 1)) / 1461001);
	l = l - Math.floor((1461 * i) / 4) + 31;
	var j = Math.floor((80 * l) / 2447);
	var day = l - Math.floor((2447 * j) / 80);
	l = Math.floor(j / 11);
	var month = j + 2 - (12 * l);
	var year = 100 * (n - 49) + i + l;
	return new DateObj(year * 10000 + month * 100 + day);
}

function _make(year, month, day) {
	return new DateObj(year * 10000 + month * 100 + day);
}

function _isLeap(year) {
	return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}

function _daysInMonth(year, month) {
	return month == 2 ? (_isLeap(year) ? 29 : 28) : _monthLengths[month - 1];
}

function _isWorkDay(weekDay) {
	return weekDay != 0 && weekDay != 6;
}

function _amDesignator() {
	return _dateInfo().amDesignator || "AM";
}

function _pmDesignator() {
	return _dateInfo().pmDesignator || "PM";
}

exports.amDesignator = _amDesignator;
exports.pmDesignator = _pmDesignator;

// do not export the class
utils.defineClass(DateObj, null, {
	year: {
		get: function() {
			return Math.floor(this._value / 10000);
		}
	},
	month: {
		get: function() {
			return Math.floor(this._value / 100) % 100;

		}
	},
	day: {
		get: function() {
			return this._value % 100;
		}
	},
	weekDay: {
		get: function() {
			// Add Julian offset (+1 because Julian origin is Monday) 
			// so that modulo is on positive value even if date is before 1970
			return ((2440588 + 1 + _toOffset(this)) % 7);
		}
	},
	yearDay: {
		get: function() {
			var month = this.month;
			var leap = month > 2 && _isLeap(this.year) ? 1 : 0;
			return _monthOffsets[month - 1] + leap + this.day;
		}
	},
	week: {
		// ISO 8601 with week 0
		get: function() {
			// week 1 is the beg of week that contains Jan 4th.
			var begOfWeek1 = _make(this.year, 1, 4).begOfWeek(1);
			return Math.floor((7 + _toOffset(this) - _toOffset(begOfWeek1)) / 7);
		}
	},

	valueOf: function() {
		return this.toString();
	},
	compare: function(date) {
		return this._value - date._value;
	},
	equals: function(date) {
		return this._value === date._value;
	},
	between: function(begin, end) {
		return begin._value <= this._value && this._value <= end._value;
	},

	isLeapYear: function() {
		return _isLeap(this.year);
	},
	isWorkDay: function() {
		return _isWorkDay(this.weekDay);
	},
	daysInMonth: function() {
		return _daysInMonth(this.year, this.month);
	},

	begOfYear: function() {
		return _make(this.year, 1, 1);
	},
	endOfYear: function() {
		return _make(this.year, 12, 31);
	},
	begOfQuarter: function() {
		return _make(this.year, Math.floor((this.month - 1) / 3) * 3 + 1, 1);
	},
	endOfQuarter: function() {
		return this.begOfQuarter().addMonths(2).endOfMonth();
	},
	begOfMonth: function() {
		return _make(this.year, this.month, 1);
	},
	endOfMonth: function() {
		return _make(this.year, this.month, this.daysInMonth());
	},
	sameMonth: function(day) {
		day = Math.min(day, this.daysInMonth());
		return _make(this.year, this.month, day);
	},
	pastDay: function(day, includeThis) {
		var delta = day - this.day;
		return (delta > 0 || delta == 0 && !includeThis) ? this.addMonths(-1).sameMonth(day) : this.sameMonth(day);
	},
	futureDay: function(day, includeThis) {
		var delta = day - this.day;
		return (delta < 0 || delta == 0 && !includeThis) ? this.addMonths(1).sameMonth(day) : this.sameMonth(day);
	},
	pastMonth: function(month, includeThis) {
		var delta = this.month - month;
		delta = delta == 0 ? (includeThis ? 0 : 12) : delta > 0 ? delta : delta + 12;
		return this.addMonths(-delta);
	},
	futureMonth: function(month, includeThis) {
		var delta = month - this.month;
		delta = delta == 0 ? (includeThis ? 0 : 12) : delta > 0 ? delta : delta + 12;
		return this.addMonths(delta);
	},
	begOfWeek: function(startDay) { // 0: Sunday (default), 1: Monday
		var delta = this.weekDay - (startDay || 0);
		return delta == 0 ? this : delta > 0 ? this.addDays(-delta) : this.addDays(-delta - 7);
	},
	endOfWeek: function(startDay) {
		return this.begOfWeek(startDay).addDays(6);
	},
	sameWeek: function(weekDay, startDay) {
		return this.begOfWeek(startDay).futureWeekDay(weekDay, true);
	},
	pastWeekDay: function(weekDay, includeThis) {
		var result = this.begOfWeek(weekDay);
		return !includeThis && result.equals(this) ? this.addWeeks(-1) : result;
	},
	futureWeekDay: function(weekDay, includeThis) {
		return this.pastWeekDay(weekDay, !includeThis).addWeeks(1);
	},
	addYears: function(years) {
		if (years == 0)
			return this;
		var year = this.year + years;
		var month = this.month;
		var day = Math.min(this.day, _daysInMonth(year, month));
		return _make(year, month, day);
	},
	addMonths: function(months) {
		if (months == 0)
			return this;
		var self = this;
		var day = self.day;
		var month0 = self.month - 1;
		var year = self.year;
		month0 += months;
		year += Math.floor(month0 / 12);
		var month = (month0 + 120000) % 12 + 1;
		var monthLen = _daysInMonth(year, month);
		day = day < monthLen ? day : monthLen;
		return _make(year, month, day);
	},
	addWeeks: function(weeks) {
		return this.addDays(7 * weeks);
	},
	addDays: function(days) {
		if (days == 0)
			return this;
		return _fromOffset(_toOffset(this) + days);
	},

	daysDiff: function(date) {
		return _toOffset(this) - _toOffset(date);
	},

	/**
     * Adds (or subtracts) to the value of the year, month, day, hour, minute, second, millisecond of the date instance using given configuration object. Positive and Negative values allowed.
     * Example
     <pre><code>
     Date.today().add( { day: 1, month: 1 } )
     </code></pre>
     * @param {Object}   Configuration object containing attributes (month, day, etc.)
     * @return {Date}    this
     */
	add: function(delta) {
		return this.addYears(delta.years || 0).addMonths(delta.months || 0).addWeeks(delta.weeks || 0).addDays(delta.days || 0);
	},

	// format as 
	toString: function(format) {
		var self = this;
		if (format == null) {
			// RFC 3339 by default -- very fast
			var str = self._value.toString();
			str = _padLeft(str, 8, "0");
			return str.substring(0, 4) + "-" + str.substring(4, 6) + "-" + str.substring(6, 8);
		} else {
			var result = '';
			_walkFormat(format, {
				literal: function(lit) {
					result += lit;
				},
				d: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.day.toString();
							break;
						case 2:
							result += _pad2(self.day);
							break;
						case 3:
							result += _dayName(self.weekDay, true);
							break;
						case 4:
							result += _dayName(self.weekDay);
							break;
						default:
							throw new Error(locale.text("date.formatd", repeat));
					}
				},
				M: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.month.toString();
							break;
						case 2:
							result += _pad2(self.month);
							break;
						case 3:
							result += _monthName(self.month, true);
							break;
						case 4:
							result += _monthName(self.month);
							break;
						default:
							throw new Error(locale.text("date.formatM", repeat));
					}
				},
				y: function(repeat) {
					switch (repeat) {
						case 2:
							result += self.year.toString().substring(2, 4);
							break;
						case 4:
							result += self.year.toString();
							break;
						default:
							throw new Error(locale.text("date.formatM", repeat));
					}
				}
			});
			return result;
		}
	},

	at: function(time, millisecond) {
		throw new Error(locale.text("date.notInstalled"));
	},

	toJsDate: function(utc) {
		return utc ? new Date(Date.UTC(this.year, this.month - 1, this.day)) : new Date(this.year, this.month - 1, this.day);
	},

	isNull: function() {
		return this._value == 0;
	}
});

exports.monthName = _monthName;

/**
 * Gets the month number (1-12) if given a Culture Info specific string which is a valid monthName or abbreviatedMonthName.
 * @param {String}   The name of the month (eg. "February, "Feb", "october", "oct").
 * @return {Number}  The day number
 */
exports.monthFromName = function(name) {
	var n = _dateInfo().monthNames,
		m = _dateInfo().abbreviatedMonthNames,
		s = name.toLowerCase();
	for (var i = 0; i < n.length; i++) {
		if (n[i].toLowerCase() == s || m[i].toLowerCase() == s) {
			return i + 1;
		}
	}
	return -1;
};

exports.dayName = _dayName;

/**
 * Gets the day number (0-6) if given a CultureInfo specific string which is a valid dayName, abbreviatedDayName or shortestDayName (two char).
 * @param {String}   The name of the day (eg. "Monday, "Mon", "tuesday", "tue", "We", "we").
 * @return {Number}  The day number
 */
exports.weekDayFromName = function(name) {
	var n = _dateInfo().dayNames,
		m = _dateInfo().abbreviatedDayNames,
		o = _dateInfo().shortestDayNames,
		s = name.toLowerCase();
	for (var i = 0; i < n.length; i++) {
		if (n[i].toLowerCase() == s || m[i].toLowerCase() == s) {
			return i;
		}
	}
	return -1;
};

exports.isLeap = _isLeap;

exports.daysInMonth = _daysInMonth;

exports.today = function(utc) {
	return exports.fromJsDate(new Date(), utc);
};

function _walkFormat(format, map) {
	var i = 0,
		len = format.length;

	function count(i) {
		var ch = format[i],
			k = 1;
		while (format[i + k] === ch)
			k++;
		return k;
	}

	while (i < len) {
		var c = format[i];
		switch (c) {
			case "'":
				i++;
				var literal = '';
				// going to the end of the following litteral or to the format end
				for (; i < len; i++) {
					if (format[i] === "'") {
						i++;
						// check wether the "'" is not doubled
						if (format[i] === "'") {
							literal += "'";
						} else
							break;
					} else {
						literal += format[i];
					}
				}
				map.literal(literal);
				break;
			case "d":
			case "M":
			case "y":
				var repeat = count(i);
				map[c](repeat);
				i += repeat;
				break;
			default:
				map.literal(c);
				i++;

		}
	}
}

function _parse(str, format) {
	var day, weekday, month, year;
	// position in str
	var j = 0;

	function parseInteger(max) {
		if (!/\d/.test(str[j])) {
			throw new Error(locale.text("date.notNumber", str.substring[j]));
		}
		var beg = j++;
		while (j < beg + max && /\d/.test(str[j]))
			j++;
		return parseInt(str.substring(beg, j), 10);
	}

	function parseName(names) {
		for (var k = 0; k < names.length; k++) {
			var name = names[k],
				len = name.length;
			if (str.substring(j, j + len).toUpperCase() == name.toUpperCase()) {
				j += len;
				return k;
			}
		}
		throw new Error(locale.text("date.unknown", str.substring(j)));
	}

	_walkFormat(format, {
		literal: function(literal) {
			if (str.substring(j, j + literal.length) !== literal)
				throw new Error(locale.text("date.wrongFormat", literal, str.substring(j)));
			j += literal.length;
		},
		d: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					day = parseInteger(2);
					break;
				case 3:
					weekday = parseName(_dateInfo().abbreviatedDayNames);
					break;
				case 4:
					weekday = parseName(_dateInfo().dayNames);
					break;
				default:
					throw new Error(locale.text("date.badDay", format.substring(j))); // replaced i with j
			}
		},
		M: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					month = parseInteger(2);
					break;
				case 3:
					month = parseName(_dateInfo().abbreviatedMonthNames) + 1;
					break;
				case 4:
					month = parseName(_dateInfo().monthNames) + 1;
					break;
				default:
					throw new Error(locale.text("date.badDay", format.substring(j))); // replaced i with j
			}
		},
		y: function(arg) {
			switch (arg) {
				case 2:
					year = parseInteger(2);
					year = year < 40 ? 2000 + year : 1900 + year;
					break;
				case 4:
					year = parseInteger(4);
					year = year > 99 ? year : year < 40 ? 2000 + year : 1900 + year;
					break;
				default:
					throw new Error(locale.text("date.badYear", format.substring(j))); // replaced i with j
			}
		}
	});

	// ignore weekday
	return _make(year, month, day);
}

exports.parse = function(str, format) {
	if (str == null)
		throw new Error(locale.text("date.dateNull"));

	if (format == null) {
		// RFC 3339 by default -- very fast
		if (str.length != 10)
			throw new Error(locale.text("date.badFormat", str));
		var value = parseInt(str.replace(/-/g, ''), 10);
		return new DateObj(value);
	} else {
		return _parse(str, format);
	}
};

// used for format conversions
exports.walkFormat = _walkFormat;

exports.fromJsDate = function(jsDate, utc) {
	return utc ? _make(jsDate.getUTCFullYear(), jsDate.getUTCMonth() + 1, jsDate.getUTCDate()) : _make(jsDate.getFullYear(), jsDate.getMonth() + 1, jsDate.getDate());
};

exports.fromInternalValue = function(value) {
	return new DateObj(value);
};

exports.makeInWeek = function(year, week, wday) {
	var dday = wday ? wday - 1 : 6;
	return _make(year, 1, 4).begOfWeek(1).addDays(7 * (week - 1) + dday);
};
exports.isDate = function(obj) {
	return obj instanceof DateObj;
};


exports.sunday = 0;
exports.Sunday = 0;
exports.monday = 1;
exports.Monday = 1;
exports.tuesday = 2;
exports.Tuesday = 2;
exports.wednesday = 3;
exports.Wednesday = 3;
exports.thursday = 4;
exports.Thursday = 4;
exports.friday = 5;
exports.Friday = 5;
exports.saturday = 6;
exports.Saturday = 6;

exports.make = _make;

exports.getLocalShortDate = function(dateISOString) {
	if (!dateISOString || dateISOString.length < 6)
		return "";

	var tmp = dateISOString.split("-");
	var d = _make(+tmp[0], +tmp[1], +tmp[2]);

	return d.toString(locale.getDateFormat());
};
});

define('syracuse-tablet/html/js/helpers/types/time',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require("syracuse-tablet/html/js/helpers/locale");
var _dateInfo = locale.getDatetimeInfo;

exports.validate = function(value, constraints, errors) {
	if (value == null) {
		if (constraints.$isMandatory) return errors.push(locale.text("time.valMan"));
		if (!constraints.$isNullable) return errors.push(locale.text("time.valNull"));
		return;
	}
	if (!(value instanceof Time)) {
		errors.push(locale.text("time.valTime"));
		return;
	}
};

function Time(value) {
	// force modulo on value to bring it back in range
	value = (value + 86400 * 365 * 10000) % 86400;
	this._value = value;
}

function _pad2(val) {
	var s = val.toString();
	return (s.length == 1) ? "0" + s : s;
}

function _parse2(str, beg, end) {
	return parseInt(str.substring(beg, end), 10);
}

function _make(hour, minute, second) {
	return new Time(hour * 3600 + (minute || 0) * 60 + (second || 0));
}

function _amDesignator() {
	return _dateInfo().amDesignator || "AM";
}

function _pmDesignator() {
	return _dateInfo().pmDesignator || "AM";
}

utils.defineClass(Time, null, {
	hour: {
		get: function() {
			return Math.floor(this._value / 3600);
		}
	},
	minute: {
		get: function() {
			return Math.floor(this._value / 60) % 60;
		}
	},
	second: {
		get: function() {
			return this._value % 60;
		}
	},
	value: {
		get: function() {
			return this._value;
		}
	},
	valueOf: function() {
		return this.toString();
	},
	compare: function(time) {
		return this._value - time._value;
	},
	equals: function(time) {
		return this._value === time._value;
	},
	between: function(begin, end) {
		return begin._value <= this._value && this._value <= end._value;
	},

	begOfDay: function() {
		return _make(0, 0, 0);
	},
	endOfDay: function() {
		return _make(23, 59, 59);
	},
	begOfHour: function() {
		return _make(this.hour, 0, 0);
	},
	endOfHour: function() {
		return _make(this.hour, 59, 59);
	},
	begOfMinute: function() {
		return _make(this.hour, this.minute, 0);
	},
	endOfMinute: function() {
		return _make(this.hour, this.minute, 59);
	},

	// format as
	toString: function(format) {
		var self = this;
		if (format == null) {
			return _pad2(self.hour) + ":" + _pad2(self.minute) + ":" + _pad2(self.second);
		} else {
			var result = '';
			_walkFormat(format, {
				literal: function(lit) {
					result += lit;
				},
				H: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.hour;
							break;
						case 2:
							result += _pad2(self.hour);
							break;
						default:
							throw new Error(locale.text("time.formatH", repeat));
					}
				},
				h: function(repeat) {
					switch (repeat) {
						case 1:
							var hour = self.hour;
							if (hour === 0) {
								result += 12;
							} else {
								result += hour > 12 ? hour - 12 : hour;
							}
							break;
						case 2:
							var hour = self.hour;
							if (hour === 0) {
								result += 12;
							} else {
								result += hour > 12 ? _pad2(hour - 12) : _pad2(hour);
							}
							break;
						default:
							throw new Error(locale.text("time.formath", repeat));
					}
				},
				m: function(repeat) {
					switch (repeat) {
						case 2:
							result += _pad2(self.minute);
							break;
						default:
							throw new Error(locale.text("time.formatm", repeat));
					}
				},
				s: function(repeat) {
					switch (repeat) {
						case 2:
							result += _pad2(self.second);
							break;
						default:
							throw new Error(locale.text("time.formats", repeat));
					}
				},
				t: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.hour < 12 ? _amDesignator().substring(0, 1) : _pmDesignator().substring(0, 1);
							break;
						case 2:
							result += self.hour < 12 ? _amDesignator() : _pmDesignator();
							break;
						default:
							throw new Error(locale.text("time.formata", repeat));
					}
				}
			});
			return result;
		}

	},

	secondsDiff: function(t) {
		return this._value - t._value;
	},

	// add functions circle from 23:59:59 to 00:00:00 without warning
	addHours: function(hours) {
		return hours == 0 ? this : new Time(this._value + hours * 3600);
	},
	addMinutes: function(minutes) {
		return minutes == 0 ? this : new Time(this._value + minutes * 60);
	},
	addSeconds: function(seconds) {
		return seconds == 0 ? this : new Time(this._value + seconds);
	},
	add: function(delta) {
		return this.addHours(delta.hours || 0).addMinutes(delta.minutes || 0).addSeconds(delta.seconds || 0);
	},
	isNull: function() {
		return this._value == 0;
	}
});

exports.make = _make;

exports.fromSeconds = function(seconds) {
	return new Time(seconds);
};

exports.fromJsDate = function(js, utc) {
	return utc ? _make(js.getUTCHours(), js.getUTCMinutes(), js.getUTCSeconds()) : _make(js.getHours(), js.getMinutes(), js.getSeconds());
};

exports.now = function(utc) {
	return exports.fromJsDate(new Date(), utc);
};

exports.parse = function(str, format) {
	if (str == null) throw new Error(locale.text("time.isNull"));

	if (format == null) {
		// RFC 3339 full time without fraction -- very fast
		// hh:mm
		if (str.length != 5 && str.length != 8) throw new Error(locale.text("time.badFormat", str));

		var value = str.length == 8 ? _parse2(str, 0, 2) * 3600 + _parse2(str, 3, 5) * 60 + _parse2(str, 6, 8) : _parse2(str, 0, 2) * 3600 + _parse2(str, 3, 5) * 60;
		return new Time(value);
	} else {
		return _parse(str, format);
	}
};

function _walkFormat(format, map) {
	var i = 0,
		len = format.length;

	function count(i) {
		var ch = format[i],
			k = 1;
		while (format[i + k] === ch)
			k++;
		return k;
	}

	while (i < len) {
		var c = format[i];
		switch (c) {
			case "'":
				i++;
				var literal = '';
				// going to the end of the following literal or to the format end
				for (; i < len; i++) {
					if (format[i] === "'") {
						i++;
						// check whether the "'" is not doubled
						if (format[i] === "'") {
							literal += "'";
						} else break;
					} else {
						literal += format[i];
					}
				}
				map.literal(literal);
				break;
			case "H":
			case "h":
			case "m":
			case "s":
			case "t":
				var repeat = count(i);
				map[c](repeat);
				i += repeat;
				break;
			default:
				map.literal(c);
				i++;
		}
	}
}

function _parse(str, format) {
	var hour, minute, second, timeMode, abbrTimeMode;
	var timeModes = [_amDesignator(), _pmDesignator()];
	var abbrTimeModes = [timeModes[0].substring(0, 1), timeModes[1].substring(0, 1)];
	// position in str
	var j = 0;

	function parseInteger(max) {
		if (!/\d/.test(str[j])) {
			throw new Error(locale.text("time.noNumber", str.substring[j]));
		}
		var beg = j++;
		while (j < beg + max && /\d/.test(str[j]))
			j++;
		return parseInt(str.substring(beg, j), 10);
	}

	function parseName(names) {
		for (var k = 0; k < names.length; k++) {
			var name = names[k],
				len = name.length;
			if (str.substring(j, j + len).toUpperCase() == name.toUpperCase()) {
				j += len;
				return k;
			}
		}
		throw new Error(locale.text("time.unknown", str.substring(j)));
	}

	_walkFormat(format, {
		literal: function(literal) {
			if (str.substring(j, j + literal.length) !== literal) throw new Error(locale.text("time.wrongFormat", literal, str.substring(j)));
			j += literal.length;
		},
		H: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					hour = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("time.badHour", format.substring(j))); // replaced i with j
			}
		},
		h: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					hour = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("time.badHour", format.substring(j)));
			}
		},
		m: function(arg) {
			switch (arg) {
				case 2:
					minute = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("time.badMin", format.substring(j)));
			}
		},
		s: function(arg) {
			switch (arg) {
				case 2:
					second = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("time.badSec", format.substring(j)));
			}
		},
		t: function(arg) {
			switch (arg) {
				case 1:
					abbrTimeMode = parseName(abbrTimeModes);
					break;
				case 2:
					timeMode = parseName(timeModes);
					break;
				default:
					throw new Error(locale.text("time.badMarker", format.substring(j)));
			}
		}
	});

	// from 12 format to 24 format, used when necessary

	function from12to24(mode, index) {
		switch (mode[index]) {
			case mode[0]:
				// AM
				hour = hour === 12 ? 0 : hour;
				break;
			case mode[1]:
				// PM
				if (hour >= 1 && hour <= 11) {
					hour += 12;
				}
				break;
		}
	}

	if (timeMode != null || abbrTimeMode != null) {
		if (hour > 12) throw new Error(locale.text("time.badHourVal", hour, timeMode));
		var mode = timeMode != null ? timeModes : abbrTimeModes;
		var index = timeMode != null ? timeMode : abbrTimeMode;
		from12to24(mode, index);
	}

	return _make(hour, minute, second);
}

exports.amDesignator = _amDesignator;
exports.pmDesignator = _pmDesignator;
});

define('syracuse-tablet/html/js/helpers/types/datetime',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/types/date','syracuse-tablet/html/js/helpers/types/time','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var date = require('syracuse-tablet/html/js/helpers/types/date');
var time = require('syracuse-tablet/html/js/helpers/types/time');
var locale = require("syracuse-tablet/html/js/helpers/locale");

var _dateInfo = locale.getDatetimeInfo;

exports.validate = function(value, constraints, errors) {
	if (value == null) {
		if (constraints.$isMandatory) return errors.push(locale.text("datetime.valMand"));
		if (!constraints.$isNullable) return errors.push(locale.text("datetime.valNull"));
		return;
	}
	if (!(value instanceof Datetime)) {
		errors.push(locale.text("datetime.valDT"));
		return;
	}

	// month value check
	if (!(value.month >= 1 && value.month <= 12)) {
		errors.push(locale.text("datetime.valMon"));
		return;
	}

	// day value check
	if (!(value.day >= 1 && value.day <= date.daysInMonth(value.year, value.month))) {
		errors.push(locale.text("datetime.valDay"));
		return;
	}
};

function _pad2(val) {
	var s = val.toString();
	return (s.length == 1) ? "0" + s : s;
}

function _pad3(val) {
	var s = val.toString();
	switch (s.length) {
		case 1:
			return "00" + s;
		case 2:
			return "0" + s;
		default:
			return s;
	}
}

// internal value is GMT millis since origin (Jan 1st, 1970).
// We also cache the local and utc values separately as _local and _utc, when
// they are requested.

function Datetime(value, tzOffset) {
	this._value = value;
	if (tzOffset != null) this._tzOffset = tzOffset;
}

// returns millis value for seconds and milliseconds part

function _ms(dt) {
	// add millis for approx 2000 years to ensure positive before applying modulo
	return (dt._value + 2000 * 365 * 24 * 3600 * 1000) % 1000;
}

// get UTC components packed into an int
// millis are not included as they are independent from UTC/local

function _utc(dt) {
	var utc = dt._utc;
	if (!utc) {
		var d = new Date(dt._value);
		utc = d.getUTCFullYear() * 10000 * 100000 + (d.getUTCMonth() + 1) * 100 * 100000 + d.getUTCDate() * 100000 + d.getUTCHours() * 3600 + d.getUTCMinutes() * 60 + d.getUTCSeconds();
		d._utc = utc;
	}
	return utc;
}

// get local components packed into an int
// millis are not included as they are independent from UTC/local

function _local(dt) {
	var local = dt._local;
	if (!local) {
		var d = new Date(dt._value);
		local = d.getFullYear() * 10000 * 100000 + (d.getMonth() + 1) * 100 * 100000 + d.getDate() * 100000 + d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds();
		d._local = local;
	}
	return local;
}

exports.Datetime = utils.defineClass(Datetime, null, {
	date: {
		get: function() {
			return date.fromInternalValue(Math.floor(_local(this) / 100000));
		}
	},
	time: {
		get: function() {
			return time.fromSeconds(_local(this) % 100000);
		}
	},
	year: {
		get: function() {
			return this.date.year;
		}
	},
	month: {
		get: function() {
			return this.date.month;
		}
	},
	day: {
		get: function() {
			return this.date.day;
		}
	},
	weekDay: {
		get: function() {
			return this.date.weekDay;
		}
	},
	yearDay: {
		get: function() {
			return this.date.yearDay;
		}
	},
	hour: {
		get: function() {
			return this.time.hour;
		}
	},
	minute: {
		get: function() {
			return this.time.minute;
		}
	},
	second: {
		get: function() {
			return this.time.second;
		}
	},
	millisecond: {
		get: function() {
			return _ms(this);
		}
	},

	utcDate: {
		get: function() {
			return date.fromInternalValue(Math.floor(_utc(this) / 100000));
		}
	},
	utcTime: {
		get: function() {
			return time.fromSeconds(_utc(this) % 100000);
		}
	},
	utcYear: {
		get: function() {
			return this.utcDate.year;
		}
	},
	utcMonth: {
		get: function() {
			return this.utcDate.month;
		}
	},
	utcDay: {
		get: function() {
			return this.utcDate.day;
		}
	},
	utcWeekDay: {
		get: function() {
			return this.utcDate.weekDay;
		}
	},
	utcYearDay: {
		get: function() {
			return this.utcDate.yearDay;
		}
	},
	utcHour: {
		get: function() {
			return this.utcTime.hour;
		}
	},
	utcMinute: {
		get: function() {
			return this.utcTime.minute;
		}
	},
	utcSecond: {
		get: function() {
			return this.utcTime.second;
		}
	},
	utcMillisecond: {
		get: function() {
			return _ms(this);
		}
	},
	value: {
		get: function() {
			return this._value;
		}
	},
	timezoneOffset: {
		get: function() {
			if (this._tzOffset == null) this._tzOffset = this.toJsDate().getTimezoneOffset();
			return this._tzOffset;
		}
	},

	compare: function(dt) {
		return this._value - dt._value;
	},
	equals: function(dt) {
		return this._value === dt._value;
	},
	between: function(begin, end) {
		return begin._value <= this._value && this._value <= end._value;
	},

	addYears: function(years) {
		return this.date.addYears(years).at(this.time, this.millisecond);
	},
	addMonths: function(months) {
		return this.date.addMonths(months).at(this.time, this.millisecond);
	},
	addWeeks: function(weeks) {
		return this.date.addWeeks(weeks).at(this.time, this.millisecond);
	},
	addDays: function(days) {
		return this.date.addDays(days).at(this.time, this.millisecond);
	},
	addHours: function(hours) {
		return new Datetime(this._value + hours * 3600 * 1000);
	},
	addMinutes: function(minutes) {
		return new Datetime(this._value + minutes * 60 * 1000);
	},
	addSeconds: function(seconds) {
		return new Datetime(this._value + seconds * 1000);
	},
	addMilliseconds: function(millis) {
		return new Datetime(this._value + millis);
	},
	addDayFractions: function(fraction) {
		return new Datetime(this._value + fraction * 86400 * 1000);
	},

	millisDiff: function(dt) {
		return this._value - dt._value;
	},
	begOfMonth: function() {
		return _make(this.year, this.month, 1);
	},
	begOfWeek: function(startDay) { // 0: Sunday (default), 1: Monday
		var delta = this.weekDay - (startDay || 0);
		return delta == 0 ? this : delta > 0 ? this.addDays(-delta) : this.addDays(-delta - 7);
	},

	/**
     * Adds (or subtracts) to the value of the year, month, day, hour, minute, second, millisecond of the date instance using given configuration object. Positive and Negative values allowed.
     * Example
     <pre><code>
     Date.today().add( { day: 1, month: 1 } )
     </code></pre>
     * @param {Object}   Configuration object containing attributes (month, day, etc.)
     * @return {Date}    this
     */
	add: function(delta) {
		return this.addYears(delta.years || 0).addMonths(delta.months || 0).addWeeks(delta.weeks || 0).addDays(delta.days || 0).addHours(delta.hours || 0).addMinutes(delta.minutes || 0).addSeconds(delta.seconds || 0).addMillis(delta.millis || 0);
	},

	// format as
	toString: function(format) {
		var self = this;
		if (format == null) {
			return new Date(this._value).toISOString();
		} else {
			var utc = _getIndexOfZ(format);
			var _date = utc ? self.utcDate : self.date;
			var _time = utc ? self.utcTime : self.time;

			var result = '';
			_walkFormat(format, {
				literal: function(lit) {
					result += lit;
				},
				H: function(repeat) {
					switch (repeat) {
						case 1:
							result += _time.hour.toString();
							break;
						case 2:
							result += _pad2(_time.hour);
							break;
						default:
							throw new Error(locale.text("datetime.formatH", repeat));
					}
				},
				h: function(repeat) {
					switch (repeat) {
						case 1:
							result += _time.hour < 13 ? _time.hour : (_time.hour - 12);
							break;
						case 2:
							result += _pad2(_time.hour < 13 ? _time.hour : (_time.hour - 12));
							break;
						default:
							throw new Error(locale.text("datetime.formath", repeat));
					}
				},
				m: function(repeat) {
					switch (repeat) {
						case 2:
							result += _pad2(_time.minute);
							break;
						default:
							throw new Error(locale.text("datetime.formatm", repeat));
					}
				},
				s: function(repeat) {
					switch (repeat) {
						case 2:
							result += _pad2(self.second);
							break;
						default:
							throw new Error(locale.text("datetime.formats", repeat));
					}
				},
				t: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.hour < 12 ? _dateInfo().amDesignator.substring(0, 1) : _dateInfo().pmDesignator.substring(0, 1);
							break;
						case 2:
							result += self.hour < 12 ? _dateInfo().amDesignator : _dateInfo().pmDesignator;
							break;
						default:
							throw new Error(locale.text("datetime.formata", repeat));
					}
				},
				d: function(repeat) {
					switch (repeat) {
						case 1:
							result += _date.day.toString();
							break;
						case 2:
							result += _pad2(_date.day);
							break;
						case 3:
							result += date.dayName(_date.weekDay, true);
							break;
						case 4:
							result += date.dayName(_date.weekDay);
							break;
						default:
							throw new Error(locale.text("datetime.formatd", repeat));
					}
				},
				M: function(repeat) {
					switch (repeat) {
						case 1:
							result += _date.month.toString();
							break;
						case 2:
							result += _pad2(_date.month);
							break;
						case 3:
							result += date.monthName(_date.month, true);
							break;
						case 4:
							result += date.monthName(_date.month);
							break;
						default:
							throw new Error(locale.text("datetime.formatM", repeat));
					}
				},
				y: function(repeat) {
					switch (repeat) {
						case 2:
							result += _date.year.toString().substring(2, 4);
							break;
						case 4:
							result += _date.year.toString();
							break;
						default:
							throw new Error(locale.text("datetime.formaty", repeat));
					}
				},
				S: function(repeat) {
					if (repeat === 3) result += _pad3(self.millisecond);
					else new Error(locale.text("datetime.formatS", repeat));
				}
			});
			return result;
		}
	},
	toJsDate: function() {
		return new Date(this._value);
	},
	withoutTimezoneOffset: function() {
		return new Datetime(this._value);
	},
	isNull: function() {
		return this._value == 0;
	}
});

function _formatTzOffset(offset, len) {
	var s = "-";
	if (offset < 0) {
		s = "+";
		offset = -offset;
	}
	var hr = Math.round(offset / 60);
	var min = offset - hr * 60;
	s += len > 1 ? _pad2(hr) : hr;
	s += len > 2 || min ? (":" + (len > 1 ? _pad2(min) : min)) : "";
	return s;
}

function _parseIso(str) {
	var year = 0,
		month = 0,
		day = 0,
		hours = 0,
		minutes = 0,
		seconds = 0,
		ms = 0,
		offset = 0,
		convertError = true;
	var d = /(\d{4})-(\d{2})-(\d{2})([T\s]?)(\d{2})?(:)?(\d{2})?(:)?(\d{2})?(\.(\d{3}))?(Z)?(([+-])(\d{2}))?(.*$)/.exec(str);
	if (d) {
		convertError = false;
		year = +d[1];
		month = d[2] - 1;
		day = +d[3];
		hours = +(d[5] || 0);
		minutes = +(d[7] || 0);
		seconds = +(d[9] || 0);
		ms = +(d[11] || 0);
		if (d[12] === "Z") {
			if (d[14] === '-') offset = (d[15] || 0) * 60;
			else if (d[14] === '+') offset = -(d[15] || 0) * 60;
			var utc = Date.UTC(year, month, day, hours, minutes + offset, seconds, ms);
			return new Datetime(utc);
		} else {
			var jsDate = new Date(year, month, day, hours, minutes + offset, seconds, ms);
			return new Datetime(jsDate.getTime(), jsDate.getTimezoneOffset());
		}
	}
	if (convertError) throw new Error(locale.text("datetime.noParse", str));
}

exports.now = function(withMillis) {
	var jsDate = new Date();
	var millis = jsDate.getTime();
	if (!withMillis) millis = Math.floor(millis / 1000) * 1000;
	return new Datetime(millis, jsDate.getTimezoneOffset());
};

exports.parse = function(str, format) {
	if (str == null) throw new Error(locale.text("datetime.isNull"));

	if (format == null) {
		return _parseIso(str);
	} else {
		return _parse(str, format);
	}
};

exports.fromJsDate = function(jsDate) {
	return new Datetime(jsDate.getTime(), jsDate.getTimezoneOffset());
};

exports.isDatetime = function(obj) {
	return obj instanceof Datetime;
};

exports.fromInternalValue = function(value) {
	return new Datetime(value);
};

exports.dayName = function(weekDay, abbrev) {
	return abbrev ? _dateInfo().abbreviatedDayNames[weekDay] : _dateInfo().dayNames[weekDay];
};

exports.monthName = function(month, abbrev) {
	return abbrev ? _dateInfo().abbreviatedMonthNames[month - 1] : _dateInfo().monthNames[month - 1];
};

function _make(year, month, day, hour, minute, second, millis) {
	var jsDate = new Date(year, month - 1, day, hour || 0, minute || 0, second || 0, millis || 0);
	return new Datetime(jsDate.getTime(), jsDate.getTimezoneOffset());
}

exports.make = _make;
exports.makeUtc = _makeUtc;

function _makeUtc(year, month, day, hour, minute, second, millis) {
	var jsDate = new Date(Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millis || 0));
	return new Datetime(jsDate.getTime(), jsDate.getTimezoneOffset());
}

// hack to install "at" method in date, without require cycles
date.make(1, 1, 1).constructor.prototype.at = function(time, millisecond) {
	return exports.make(this.year, this.month, this.day, time.hour, time.minute, time.second, millisecond);
};

exports.sunday = 0;
exports.Sunday = 0;
exports.monday = 1;
exports.Monday = 1;
exports.tuesday = 2;
exports.Tuesday = 2;
exports.wednesday = 3;
exports.Wednesday = 3;
exports.thursday = 4;
exports.Thursday = 4;
exports.friday = 5;
exports.Friday = 5;
exports.saturday = 6;
exports.Saturday = 6;

function _walkFormat(format, map) {
	var i = 0,
		len = format.length;

	function count(i) {
		var ch = format[i],
			k = 1;
		while (format[i + k] === ch)
			k++;
		return k;
	}

	while (i < len) {
		var c = format[i];
		switch (c) {
			case "'":
				i++;
				var literal = '';
				// going to the end of the following litteral or to the format end
				for (; i < len; i++) {
					if (format[i] === "'") {
						i++;
						// check wether the "'" is not doubled
						if (format[i] === "'") {
							literal += "'";
						} else break;
					} else {
						literal += format[i];
					}
				}
				map.literal(literal);
				break;
			case "H":
			case "h":
			case "m":
			case "s":
			case "S":
			case "t":
			case "d":
			case "M":
			case "y":
				var repeat = count(i);
				map[c](repeat);
				i += repeat;
				break;
			default:
				map.literal(c);
				i++;
		}
	}
}

exports.walkFormat = _walkFormat;

function _parse(str, format) {
	var day, weekday, month, year, hour, minute, second, millis, timeMode, abbrTimeMode;
	var timeModes = [date.amDesignator(), date.pmDesignator()];
	//var timeModes = _dateInfo().amDesignator ? [_dateInfo().amDesignator, _dateInfo().pmDesignator] : ["AM", "PM"];
	var abbrTimeModes = [timeModes[0].substring(0, 1), timeModes[1].substring(0, 1)];
	//var abbrTimeModes = _dateInfo().amDesignator ? [_dateInfo().amDesignator.substring(0, 1), _dateInfo().pmDesignator.substring(0, 1)] : ["A", "P"];

	// position in str
	var j = 0;

	function parseInteger(max) {
		if (!/\d/.test(str[j])) {
			throw new Error(locale.text("datetime.noNumber", str.substring[j]));
		}
		var beg = j++;
		while (j < beg + max && /\d/.test(str[j]))
			j++;
		return parseInt(str.substring(beg, j), 10);
	}

	function parseName(names) {
		for (var k = 0; k < names.length; k++) {
			var name = names[k],
				len = name.length;
			if (str.substring(j, j + len).toUpperCase() == name.toUpperCase()) {
				j += len;
				return k;
			}
		}
		throw new Error(locale.text("datetime.unknown", str.substring(j)));
	}

	_walkFormat(format, {
		literal: function(literal) {
			if (str.substring(j, j + literal.length) !== literal) throw new Error(locale.text("datetime.formatMis", literal, str.substring(j)));
			j += literal.length;
		},
		d: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					day = parseInteger(2);
					break;
				case 3:
					weekday = parseName(_dateInfo().abbreviatedDayNames);
					break;
				case 4:
					weekday = parseName(_dateInfo().dayNames);
					break;
				default:
					throw new Error(locale.text("datetime.badDay", format.substring(j))); // replaced i with j
			}
		},
		M: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					month = parseInteger(2);
					break;
				case 3:
					month = parseName(_dateInfo().abbreviatedMonthNames) + 1;
					break;
				case 4:
					month = parseName(_dateInfo().monthNames) + 1;
					break;
				default:
					throw new Error(locale.text("datetime.badDay", format.substring(j))); // replaced i with j
			}
		},
		y: function(arg) {
			switch (arg) {
				case 2:
					year = parseInteger(2);
					year = year < 40 ? 2000 + year : 1900 + year;
					break;
				case 4:
					year = parseInteger(4);
					year = year > 99 ? year : year < 40 ? 2000 + year : 1900 + year;
					break;
				default:
					throw new Error(locale.text("datetime.badYear", format.substring(j))); // replaced i with j
			}
		},
		H: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					hour = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("datetime.badHour", format.substring(j)));
			}
		},
		h: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					hour = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("datetime.badHour", format.substring(j)));
			}
		},
		m: function(arg) {
			switch (arg) {
				case 2:
					minute = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("datetime.badMin", format.substring(j)));
			}
		},
		s: function(arg) {
			switch (arg) {
				case 2:
					second = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("datetime.badSec", format.substring(j)));
			}
		},
		t: function(arg) {
			switch (arg) {
				case 1:
					abbrTimeMode = parseName(abbrTimeModes);
					break;
				case 2:
					timeMode = parseName(timeModes);
					break;
				default:
					throw new Error(locale.text("datetime.badMarker", format.substring(j)));
			}
		}
	});

	// from 12 format to 24 format, used when necessary

	function from12to24(mode, index) {
		switch (mode[index]) {
			case mode[0]:
				// AM
				hour = hour === 12 ? 0 : hour;
				break;
			case mode[1]:
				// PM
				if (hour >= 1 && hour <= 11) {
					hour += 12;
				}
				break;
		}
	}

	if (timeMode != null || abbrTimeMode != null) {
		if (hour > 12) throw new Error(locale.text("datetime.badHourVal", hour, timeMode));
		var mode = timeMode != null ? timeModes : abbrTimeModes;
		var index = timeMode != null ? timeMode : abbrTimeMode;
		from12to24(mode, index);
	}

	// ignore weekday
	return _make(year, month, day, hour, minute, second, millis);
}

function _getIndexOfZ(format) {
	var i = 0,
		len = format.length;

	function count(i) {
		var ch = format[i],
			k = 1;
		while (format[i + k] === ch)
			k++;
		return k;
	}

	while (i < len) {
		var c = format[i];
		if (c === "'") {
			i++;
			var literal = '';
			// going to the end of the following litteral or to the format end
			for (; i < len; i++) {
				if (format[i] === "'") {
					i++;
					// check wether the "'" is not doubled
					if (format[i] === "'") {
						literal += "'";
					} else break;
				} else {
					literal += format[i];
				}
			}
		} else if (c === 'Z') {
			return i;
		} else {
			i++;
		}
	}
}
});

define('syracuse-tablet/html/js/helpers/types/numberFormat',['require','exports','module','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var locale = require("syracuse-tablet/html/js/helpers/locale");

//======================
//	Useful elements
//======================

/**
 * Format object used to handle format. Useful for the formatting and parsing methods
 * @param {Object} prefix	Any text before directives
 * @param {Object} postfix	Any text after directives
 * @param {Object} properties	Properties are : hasDecimalSeparator, hasGroupSeparator, mandatoryAfter, maxAfter, groupSize, mandatoryBefore, directive, hasPercent, hasPermil, hasSignFormat
 */
function FormatObj(prefix, postfix, properties) {
	this.prefix = prefix;
	this.postfix = postfix;
	this.properties = properties;
}

/**
 * Set number format properties from directive parameter.
 * @param {String}	directive
 * @param {Object}	fObj
 * @return {Object}	Returns a formatObj with properties set
 */
function _processDirective(directive, fObj) {
	// properties to set:   

	// result
	var f = new FormatObj(fObj.prefix, fObj.postfix, fObj.properties);

	var hasDecimalSeparator, hasGroupSeparator;

	var dsIndex = directive.indexOf('.');
	var gsIndex = directive.indexOf(',');

	// decimal and group separator properties
	f.properties.hasDecimalSeparator = hasDecimalSeparator = dsIndex > -1;
	f.properties.hasGroupSeparator = hasGroupSeparator = gsIndex > -1;

	// after properties	
	if (hasDecimalSeparator) {
		var decimal = directive.substring(dsIndex + 1);
		f.properties.mandatoryAfter = decimal.indexOf("0") > -1 ? decimal.match(/0/g).length : 0;
		f.properties.maxAfter = decimal.length;
	}

	// group size property
	if (hasGroupSeparator) {
		f.properties.groupSize = hasDecimalSeparator ? dsIndex - gsIndex - 1 : directive.substring(gsIndex + 1).length;
	}

	// before property
	var integer = hasDecimalSeparator ? directive.substring(0, dsIndex) : directive;
	f.properties.mandatoryBefore = integer.indexOf("0") > -1 ? integer.match(/0/g).length : 0;

	// directive
	f.properties.directive = directive;

	// percent/permil property
	f.properties.hasPercent = directive.indexOf("%") > -1;
	f.properties.hasPermil = directive.indexOf("‰") > -1;

	// sign format
	f.properties.hasSignFormat = directive.indexOf('+') > -1 && directive.indexOf('+') === 0;

	return f;
}

/**
 * Walk through the given format and run functions in map
 * @param {Object} format
 * @param {Object} map
 */
function _walkFormat(format, map) {
	var i = 0,
		len = format.length;

	// valid directive characters in format (except ';')
	var validDir = "0#.,%‰+"; //	'E' or 'e' are not supported yet
	function count(i) {
		var ch = format[i],
			k = 1;
		while (validDir.indexOf(format[i + k]) > -1)
			k++;
		return k;
	}

	while (i < len) {
		var c = format[i];
		switch (c) {
			case "'":
				i++;
				var literal = '';
				// going to the end of the following litteral or to the format end
				for (; i < len; i++) {
					if (format[i] === "'") {
						i++;
						// check wether the "'" is not doubled
						if (format[i] === "'") {
							literal += "'";
						} else break;
					} else {
						literal += format[i];
					}
				}
				map.literal(literal);
				break;
			case "0":
			case "#":
			case ".":
			case "%":
			case "‰":
			case "+":
				var directiveLength = count(i);
				map.directive(i, i + directiveLength);
				i += directiveLength;
				break;
			case ";":
				map.listSeparator();
				i++;
				break;
			default:
				map.literal(c);
				i++;
		}
		// at the end of the loop
		if (i === len) {
			map.listSeparator();
		}
	}
}

/**
 * Add separator parameter after every digits group of size value to the number paramater.
 * @param {Object} num
 * @param {Object} gs
 * @param {Object} size
 */
function _addSeparator(num, gs, size) {
	var result = "";
	var len = num.length;
	var c = "";
	var count = 0;
	for (var i = len - 1; i >= 0; i--) {
		c = num[i];
		result += c;
		++count;
		if ((count % size === 0) && i > 0) {
			result += gs;
		}
	}
	return result.split("").reverse().join("");
}

//======================
//	Format functions
//======================

/**
 * Forat a number
 * @param {Object} val	Raw number
 * @param {Object} format	Format to apply
 * @return {String} Returns a string value containing formatted number
 */
exports.format = function(val, format) {

	//	if (!val)
	//		throw new Error("empty number value");

	if (isNaN(val)) throw new Error(locale.text("numberFormat.notNumber", val));

	if (format == null) {
		val = val.toString();
		var dsIndex = val.indexOf('.');
		var hasDecimal = dsIndex > -1;
		var intPart = hasDecimal ? val.substring(0, dsIndex) : val;
		var decimalPart = hasDecimal ? val.substring(dsIndex + 1) : '';
		var gs = locale.getNumberGroupSeparator() || "";
		var ds = hasDecimal ? (locale.getNumberDecimalSeparator() || ".") : '';
		return _addSeparator(intPart, gs, 3) + ds + decimalPart;
	} else {
		return _format(val, format);
	}

};

function _format(val, format) {
	var prefix, postfix;
	// position in val
	var j = 0;
	// format list (used in case of list of formats separated with ';', empty otherwise)
	var formatsList = [];

	var directiveProcessed = false;

	var f = new FormatObj('', '', {});

	_walkFormat(format, {
		literal: function(literal) {
			// set prefix or postfix value
			directiveProcessed ? f.postfix += literal : f.prefix += literal;
		},
		directive: function(beg, end) {
			// get directive part of the format
			var directive = format.substring(beg, end);

			// process directive
			f = _processDirective(directive, f);

			directiveProcessed = true;
		},
		listSeparator: function() {
			directiveProcessed = false;
			formatsList.push(f);
			f = new FormatObj('', '', {});
			prefix = '';
			postfix = '';
		}
	});

	var flen = formatsList.length;
	switch (flen) {
		case 1:
			return _formatNumber(val, formatsList[0]);
			break;
		case 2:
		case 3:
			if (val === 0) return _formatZero(formatsList[2]);
			else return val < 0 ? _formatNumber(val.toString().substring(1), formatsList[1]) : _formatNumber(val, formatsList[0]);
			break;
		default:
			throw new Error(flen === 0 ? locale.text("numberFormat.noFormat") : locale.text("numberFormat.manyFormat"));
	}
}

function _formatZero(fObj) {
	return fObj.prefix;
}

function _formatNumber(num, fObj) {
	var res = '';

	// locale separators
	var gs = locale.getNumberGroupSeparator();
	var ds = locale.getNumberDecimalSeparator();

	var directive = fObj.properties.directive;

	// special case for percentages
	num = fObj.properties.hasPercent ? num * 100 : num;
	num = fObj.properties.hasPermil ? num * 1000 : num;

	// #6292 - Format can be wrong - TODO add a isValid method to format object
	if (directive == null) return num;

	// == decimal ==
	if (fObj.properties.hasDecimalSeparator) {
		var decimalPart = '';
		var maxAfter = fObj.properties.maxAfter;
		var decimalFormat = directive.substr(directive.indexOf('.') + 1, maxAfter);
		var decimalValue = num % 1;
		var decimalString = '' + decimalValue.toFixed(maxAfter);
		decimalString = decimalString.substring(decimalString.indexOf('.') + 1);
		for (var i = 0; i < maxAfter; i++) {
			var f = decimalFormat.charAt(i);
			var n = decimalString.charAt(i);
			if (f === '0') {
				decimalPart += n;
			} else if (f === '#' && n !== '0') {
				decimalPart += n;
			} else if (f === '#' && n === '0') { // end loop if only '0' left in decimalString
				var notParsed = decimalString.substring(i);
				if (notParsed.match('[1-9]')) decimalPart += n;
				else break;
			}
		}
		res = decimalPart ? ds + decimalPart : res; // in case of integer value, decimalPart --> ''
	} else {
		// it is possible to have decimal number and format not containing decimal separator
		num = Math.round(num);
	}

	// == integer ==
	var intPart = num < 0 ? '' + Math.ceil(num) : '' + Math.floor(num);
	intPart = intPart.replace(/[^\d]+/g, '');
	var intFormat = directive.indexOf('.') === -1 ? directive : directive.substring(0, directive.indexOf('.'));
	// padding if necessary
	if (intPart.length < fObj.properties.mandatoryBefore) {
		var missing = fObj.properties.mandatoryBefore - intPart.length;
		var toAdd = '';
		for (var i = 0; i < missing; i++) {
			toAdd += '0';
		}
		intPart = toAdd + intPart;
	}
	// adding group separator if needed
	if (fObj.properties.hasGroupSeparator) {
		if (fObj.properties.groupSize < intPart.length) {
			intPart = _addSeparator(intPart, gs, fObj.properties.groupSize);
		}
	}

	// in case of no mandatory digit before decimal separator, no character for int part
	intPart = (parseInt(intPart, 10) === 0 && fObj.properties.mandatoryBefore === 0) ? '' : intPart;

	intPart = intPart && num < 0 ? '-' + intPart : intPart;
	res = intPart + res;

	// == specific cases ==
	// sign format
	res = fObj.properties.hasSignFormat && num > 0 ? '+' + res : res;

	// percent and/or permil
	res += fObj.properties.hasPercent ? "%" : '';
	res += fObj.properties.hasPermil ? "‰" : '';

	return fObj.prefix + res + fObj.postfix;
}

//======================
//	Parsing functions
//======================

// * @param {Object} fn	Function called if number returned doesn't match with the integer type (only use)
// exports.parse = function(str, format, fn){
/**
 * Get a number from a formatted number string value
 * @param {Object} str	Formatted number
 * @param {Object} format	Format supposedly used
 * @return {Object}	Returns a number (integer : floor(number), decimal : BigDecimal, real : number)
 */
exports.parse = function(str, format) {
	if (!str) return 0;
	//throw new Error("number string is null");

	if (format == null) {
		return parseFloat(str);
	} else {
		return _parse(str, format);
	}
};

function _parse(str, format) {
	//format = /[0-9-+,.#eE%‰;()\s]/g.exec();
	var prefix, postfix;

	// position in str
	var j = 0;

	// format list (used in case of list of formats separated with ';', empty otherwise)
	var formatsList = [];

	var directiveProcessed = false;

	var f = new FormatObj('', '', {});

	_walkFormat(format, {
		literal: function(literal) {
			// set prefix or postfix value
			directiveProcessed ? f.postfix += literal : f.prefix += literal;
		},
		directive: function(beg, end) {
			// get directive part of the format
			var directive = format.substring(beg, end);

			// process directive
			f = _processDirective(directive, f);

			directiveProcessed = true;
		},
		listSeparator: function() {
			directiveProcessed = false;
			formatsList.push(f);
			f = new FormatObj('', '', {});
			prefix = '';
			postfix = '';
		}
	});

	return _parseFormats(str, formatsList);
}

function _parseFormats(str, formatsList, negative) {
	var flen = formatsList.length;
	var num;
	// locale separators
	var gs = locale.getNumberGroupSeparator();
	var ds = locale.getNumberDecimalSeparator();

	switch (flen) {
		case 1:
			var fObj = formatsList[0];
			var formatNumber = str;
			var integerPart, decimalPart;
			// extract prefix and postfix
			var prefix = fObj.prefix;
			var postfix = fObj.postfix;
			formatNumber = prefix ? formatNumber.substring(prefix.length) : formatNumber;
			formatNumber = postfix ? formatNumber.substring(0, formatNumber.length - postfix.length) : formatNumber;

			// splitting into integer and decimal parts
			var splitted = formatNumber.split(ds);
			// error : too many periods
			if (splitted.length > 2) throw new Error(locale.text("numberFormat.oneSep", formatNumber));
			// setting integer and decimal parts values
			integerPart = splitted[0] ? splitted[0].match(/[0-9]/g).join('') : '0';
			decimalPart = splitted.length > 1 ? splitted[1].match(/[0-9]/g).join('') : '';
			num = parseFloat(decimalPart ? integerPart + "." + decimalPart : integerPart);

			// == specific cases ==
			// negative value
			num = formatNumber.charAt(0) === '-' ? parseFloat('-' + num) : num;
			// percent or permil
			num = fObj.properties.hasPercent ? num / 100 : num;
			num = fObj.properties.hasPermil ? num / 1000 : num;
			// negative value set for list separator cases
			num = negative ? parseFloat('-' + num) : num;
			break;
		case 2:
		case 3:
			// valid characters in formatted number
			var validFormat = "1234567890" + ds + gs + "%‰-+"; // 'E' or 'e' are not supported yet
			var len = formatsList.length;
			var slen = str.length;

			for (var i = 0; i < len; i++) {
				var f = formatsList[i];
				var prefix = f.prefix;
				var postfix = f.postfix;

				var prefixDefined = prefix ? true : false;
				var postfixDefined = postfix ? true : false;

				var pre, post;

				pre = prefixDefined ? str.substring(0, prefix.length) : '';
				post = postfixDefined ? str.substring(slen - postfix.length) : '';

				if (((prefixDefined && !postfixDefined) && pre.indexOf(prefix) > -1) || ((prefixDefined && postfixDefined) && (pre.indexOf(prefix) > -1 && post.indexOf(postfix) > -1)) || ((!prefixDefined && postfixDefined) && post.indexOf(postfix) > -1) || ((!prefixDefined && !postfixDefined) && (validFormat.indexOf(str.charAt(0)) > -1 && validFormat.indexOf(str.charAt(slen - 1)) > -1))) {
					break;
				}
			}
			var flist = [];
			flist.push(formatsList[i]);
			switch (i) {
				case 0:
					num = _parseFormats(str, flist);
					break;
				case 1:
					num = _parseFormats(str, flist, true);
					break;
				case 2:
					num = 0;
					break;
				default:
					throw new Error(locale.text("numberFormat.cannotParse"));
			}
			break;
		default:
			throw new Error(flen === 0 ? locale.text("numberFormat.noFormat") : locale.text("numberFormat.manyFormats"));
	}
	return num;
}
});

define('syracuse-tablet/html/js/helpers/formatApi',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/types/date','syracuse-tablet/html/js/helpers/types/datetime','syracuse-tablet/html/js/helpers/types/time','syracuse-tablet/html/js/helpers/types/numberFormat'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var date = require('syracuse-tablet/html/js/helpers/types/date');
var datetime = require('syracuse-tablet/html/js/helpers/types/datetime');
var time = require('syracuse-tablet/html/js/helpers/types/time');
var numberFormat = require('syracuse-tablet/html/js/helpers/types/numberFormat');

var _cache = {};
var _cacheLocaleHash;

exports.getFormatter = function($type, $format) {
	if ($format == "$url") {
		// #6292 Some numeric field have $format = $url - AQMFIELDM
		// Formatter is skipped - TODO we should add a isValid method to format object
		return null;
	}
	var ctor = _formatters[$type];
	if (!ctor) {
		return null;
	}
	var curLocaleHash = locale.getCurrentLocaleHash();
	if (curLocaleHash !== _cacheLocaleHash) {
		_cacheLocaleHash = curLocaleHash;
		_cache = {};
	}
	var cache = _cache[$type];
	if (!cache) cache = _cache[$type] = {};
	var key = $format || "noformat";
	var fmt = cache[key];
	if (fmt) return fmt;
	fmt = new ctor($type, $format);
	cache[key] = fmt;
	return fmt;
};

var Formatter = utils.defineClass(function($type, $format) {
	this.$format = $format;
	this.$type = $type;
}, null, {

	_isEmpty: function(value) {
		if (value == null)
			return true;
		value = "" + value;
		value = value.trim();
		if (value === "")
			return true;
		return false;
	},

	/*
	 * Format a value for displaying
	 * This will be used on read only fields to format the internal value to a human readable localized pattern.
	 * Also, this will be used to format values in editable fields BEFORE putting the focus into the field for editing
	 * editMode: true if edit mode
	 */
	formatValue: function(value, editMode) {
		return value;
	},

	/*
	 * Format a value for editing it
	 *
	 * This will be used to format values in editable fields AFTER putting the focus into the field for editing.
	 *
	 * Example, in case of dates:
	 * A field displays "April, 1. 2014"
	 * Once the focus is put into the field, it will render the value as "01.04.2014" since it's easier to edit
	 */
	formatValueEdit: function(value) {
		return this.formatValue(value, true);
	},

	/* 
	 * Parse any kind of input string to the internal representation
	 */
	parseValue: function(value, errors) {
		errors.push("No parser for this type, return this dummy error to not override value by null");
	},

	getFormat: function() {
		return this.format;
	}
});

var DateFormatter = utils.defineClass(function($type, $format) {
	Formatter.call(this, $type, $format);
	this.format = locale.getDateFormat();
	this.twoDigitYearSwitch = 40;
}, Formatter, {
	_isEmpty: function(value) {
		if (value == null)
			return true;
		value = "" + value;
		value = value.trim();
		if (value === "")
			return true;

		if (value === "0000-00-00")
			return true;

		return false;
	},

	_checkShortYear: function(year) {
		if (year.year) {
			// Date object
			var y = year.year;
			if (y < 100) {
				year.add({
					years: y < this.twoDigitYearSwitch ? 2000 : 1900
				});
			}
		} else {
			// Number
			year = year > 99 ? year : (year < this.twoDigitYearSwitch ? 2000 + year : 1900 + year);
		}
		return year;
	},

	/**
	 * value expected to be a date string like "2014-08-19"
	 */
	formatValue: function(value, editMode) {
		if (this._isEmpty(value)) {
			return "";
		}
		var p = value.split(/[^\d]+/);
		var format;
		if (p.length >= 3) {
			p[0] = this._checkShortYear(+p[0]);
			var d = date.make(+p[0], +p[1], +p[2]);
			format = d.toString(this.format);
		} else {
			format = value;
		}
		return format;
	},
	parseValue: function(value, errors) {
		var fmt;
		if (this._isEmpty(value)) {
			return "";
		}
		try {
			fmt = date.parse(value, this.format);
			fmt = this._checkShortYear(fmt);
		} catch (e) {
			errors.push(locale.text("field.invalidInput", [this.format]));
			return value;
		}
		return fmt.toString("yyyy-MM-dd");
	}
});

var DateTimeFormatter = utils.defineClass(function($type, $format) {
	DateFormatter.call(this, $type, $format);
	this.format = locale.getDateTimeFormat();
}, DateFormatter, {
	_isEmpty: function(value) {
		if (value == null)
			return true;
		value = "" + value;
		value = value.trim();
		if (value === "")
			return true;

		if (value === "0000-00-00T00:00:00Z")
			return true;

		return false;
	},
	/**
	 * value expected to be a date string like "2010-10-13T13:25:03.424Z"
	 * Accept "2010-10-13-14-25-03"
	 */
	formatValue: function(value, editMode) {
		if (this._isEmpty(value)) {
			// We return "" in display mode for compatibility with other fields
			// In edit mode we choose th current date time - L.Seyssel
			return editMode === true ? datetime.now().toString(this.format) : "";
		}
		var p = value.split(/[^\d]+/);
		var format;
		if (p.length >= 6) {
			p[0] = this._checkShortYear(+p[0]);
			var d = datetime.make(+p[0], +p[1], +p[2], +p[3], +p[4], +p[5]);
			format = d.toString(this.format);
		} else {
			format = value;
		}
		return format;
	},
	parseValue: function(value, errors) {
		var fmt;
		if (this._isEmpty(value)) {
			return "";
		}

		try {
			fmt = datetime.parse(value, this.format);
			fmt = this._checkShortYear(fmt);
		} catch (e) {
			errors.push(locale.text("field.invalidInput", [this.format]));
			return value;
		}
		return fmt.toString("yyyy-MM-ddTHH:mm:ss.SSS") + "Z";
	}
});

var TimeFormatter = utils.defineClass(function($type, $format) {
	Formatter.call(this, $type, $format);
	if (this.$format === "TT") {
		this.format = locale.getTimeFormat();
	} else {
		this.format = locale.getTimeFormatShort();
	}
}, Formatter, {
	/**
	 * value expected to be a date string like "13:25:03"
	 */
	formatValue: function(value, editMode) {
		if (this._isEmpty(value)) {
			return "";
		}

		var p = value.split(/[^\d]+/);
		var format;
		if (p.length >= 2) {
			var t = time.make(+p[0], +p[1], +p[2]);
			format = t.toString(this.format);
		} else {
			format = value;
		}
		return format;
	},
	parseValue: function(value, errors) {
		if (this._isEmpty(value)) {
			return "";
		}
		var p = value.split(/[^\d]+/);
		if (p.length >= 1) {
			var t = time.make(+p[0], +p[1], +p[2]);
			return t.toString("HH:mm:ss");
		}
	}
});

var NumberFormatter = utils.defineClass(function($type, $format) {
	Formatter.call(this, $type, $format);
	this.format = this.$format || locale.getNumberFormat(this.$type);
}, Formatter, {
	/*
	 * value to be expected to be a number
	 */
	formatValue: function(value, editMode) {
		if (this._isEmpty(value)) {
			return "";
		}
		var format = numberFormat.format(value, this.format);
		return format;
	},
	parseValue: function(value, errors) {
		if (this._isEmpty(value)) {
			return "";
		}
		try {
			var fmt = numberFormat.parse(value, this.format);
		} catch (e) {
			errors.push(locale.text("field.invalidInput", [this.format]));
			return value;

		}
		return fmt;
	}
});

var _formatters = {
	"application/x-integer": NumberFormatter,
	"application/x-decimal": NumberFormatter,
	"application/x-real": NumberFormatter,

	"application/x-date": DateFormatter,
	"application/x-time": TimeFormatter,
	"application/x-datetime": DateTimeFormatter
};
});

define('syracuse-tablet/html/js/authoring/arrays/authArrayStatus',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/arrays/authArrayGeneral','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/fieldOperators','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {"use strict";
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authArrayGeneral = require('syracuse-tablet/html/js/authoring/arrays/authArrayGeneral');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _noValue = "$$novalue$$";

var _properties = {

	"arrayStatusEnabled": function(controller, sel, data) {
		this.key = "$statusEnabled";
		this.name = "arrayStatusEnabled";
		this["default"] = "none";
		this.values = [{
			"value": "none",
		}, {
			"value": "mono"
		}];
		if (data.control.$display === "card") {
			this.values.push({
				"value": "multi"
			});
		}
		this.createMarkup = authPropsGeneral.createMarkupRadio;
		this.refreshMarkup = authPropsGeneral.refreshMarkupRadio;
	},

	"arrayStatus": function(controller, sel, data) {
		this.name = "arrayStatus";
		this.label = null;
		this["default"] = null;
		this.key = "$status";
		this.ctrlArray = data.control;
		this.isTable = (this.ctrlArray.article.$display || "table") === "table";
		this._myProperties = [];
		/** 
		 	data structure data.articleSelection.$status
		 		[{
					field: "BPCNUM",
					$type: "application/x-string",
					operator: "eq",
					value: 10,
					color:{
						name: "red",
						css: "s-m-color-ok",
						bgcolor: "#FF0000",
						color: "#FFFFFF"
					}
				}]
		*/
		this.initMarkup = function(controller, sel, data) {
			this._protoValue = this.ctrlArray.getColumnsInfo();
			var authStatus = data.articleSelection[this.key] || [];
			this.statusList = [];
			var self = this,
				proto;
			authStatus.forEach(function(c) {
				proto = self.getFieldProto(c.field);
				if (proto != null) {
					c = $.extend(true, {}, c);
					c.id = utils.UUID();
					self.statusList.push(c);
				}
			});
		};
		this.getFieldProto = function(bind) {
			var res = null;
			this._protoValue.some(function(v, idx) {
				if (v.$bind === bind) {
					res = v;
					return true;
				}
			});
			return res;
		};
		this.getRecordInfo = function(id) {
			if (!id) return null;
			var idx = -1;
			var rec = null;
			this.statusList.some(function(c, i) {
				if (c.id === id) {
					rec = c;
					idx = i;
					return true;
				}
			});
			return idx === -1 ? null : {
				record: rec,
				idx: idx
			};
		};
		this.destroyMarkup = function() {
			this.ctrl = null;
			this.$$parent = null;
			this._protoValue = null;
			this.ctrlArray = null;
			if (this._myProperties) {
				this._myProperties.forEach(function(p) {
					if (p.destroyMarkup) p.destroyMarkup();
				});
				this._myProperties = null;
			}
		};

		this.createMarkup = function($$parent, prop, sel, data) {
			this.ctrl = data.control;
			this.$$parent = $$parent;
			this.statusListAdd(sel, data);
			this.editSectionAdd();
		};
		this.statusListAdd = function(sel, data) {
			var opts = {
				css: "statuslist",
				doAction: jsutils.bindFn(this.listCallBackAction, this, sel, data),
				appendTitle: locale.text("auth.arrayStatus.append")
			};
			this.listStatusDisplayer = authComponents.newComponent("editableList", opts);
			this._addParam("statuslist", this.listStatusDisplayer, true);
			this.updateStatusList();
		};
		this.editSectionAdd = function() {
			this.editStatusSection = this._addSubSection("editstatus");
			this.editStatusSection.$$panel.hide();
			this.editStatusSection.$$content.css("padding-left", "7px");
			this.editStatusSection.$$title.css("font-weight", "bold");
			var $$rootComponents = this.editStatusSection.$$content;
			this.paramFieldAdd($$rootComponents);
			this.paramOperatorAdd($$rootComponents);
			this.paramValueAdd($$rootComponents);
			this.paramColorAdd($$rootComponents);
			this.paramIconAdd($$rootComponents);
		};
		this.listCallBackAction = function(action, recordId, listStatusDisplayer, sel, data) {
			if (action === "append") {
				this._updateParams(null);
				return true;
			}
			if (action === "cancel") {
				this._resetParams();
				this.editStatusSection.$$panel.hide();
				return true;
			}
			var recInfo = this.getRecordInfo(recordId);
			if (action === "validate") {
				var newRecord = this.validateRecord(true);
				if (newRecord) {
					if (recInfo == null) {
						// Validate Append
						this.statusList.push(newRecord);
					} else {
						// Validate Edit
						this.statusList.splice(recInfo.idx, 1);
						this.statusList.splice(recInfo.idx, 0, newRecord);
					}
					this.updateStatusList(true, sel, data);
					// Clears params
					this._resetParams();
					// Removes validate/cancel - Switchs to e'Append status'
					return true;
				} else {
					return false;
				}
			}
			if (action === "deleteItem") {
				if (!recInfo) return false;
				this.statusList.splice(recInfo.idx, 1);
				this.updateStatusList(true, sel, data);
				return true;
			}
			if (action === "editItem") {
				if (!recInfo) return false;
				this._updateParams(recInfo.record);
				return true;
			}
		};
		this.validateRecord = function(errorMsg) {
			var self = this;
			var _fail = function(msg) {
				if (errorMsg === true) {
					var text = msg || locale.text("auth.arrayStatus.invalid");
					self.listStatusDisplayer.toggleMessage(text, "error");
					setTimeout(function() {
						self.listStatusDisplayer.toggleMessage(null);
					}, 2500);
				}
				return null;
			};
			var rec = {};
			rec.field = this.fieldSelector.getValue();
			rec.operator = this.operatorSelector.getValue();
			var proto = this.getFieldProto(rec.field);
			if (!proto) {
				return _fail();
			}
			rec.$type = proto.$type;
			rec.$format = proto.$format;
			if (rec.$type === "application/x-boolean") {
				rec.value = this.componentBoolVal.getValue();
			} else {
				rec.value = this.$$valueElmt.val() || "";
			}
			var formatter = formatApi.getFormatter(rec.$type, proto.$format);
			if (formatter) {
				var errors = [];
				rec.value = formatter.parseValue(rec.value, errors);
				if (errors.length > 0) {
					return _fail(errors.join(''));
				}
				if (rec.value != null && rec.value != this.$$valueElmt.val()) {
					this.$$valueElmt.val(formatter.formatValueEdit(rec.value));
				}
			}
			if (rec.$type == "application/x-reference") {
				rec.value = (rec.value || "").toUpperCase();
			}
			if (this.paletteColor) {
				rec.color = this.paletteColor.getValue();
			}
			if (this.paletteIcon) {
				rec.icon = this.paletteIcon.getValue();
			}
			rec.id = utils.UUID();
			if (rec.field == _noValue || rec.operator == _noValue || rec.color == null) {
				return _fail();
			}
			return rec;
		};
		this._updateParams = function(record) {
			var edit = record != null;
			record = record || {};
			this.editStatusSection.$$panel.show();
			this.fieldSelector.setValue(record.field || _noValue);
			this.updateOperators(record.$type, record.operator || _noValue);
			if (this.paletteColor) {
				this.paletteColor.setValue(record.color);
			}
			if (this.paletteIcon) {
				this.paletteIcon.setValue(record.icon);
			}
			var val = record.value;
			if (val != null) {
				var formatter = formatApi.getFormatter(record.$type, record.$format);
				val = formatter ? formatter.formatValueEdit(val) : val;
			}
			// We create a section for booleans
			var isBool = record.$type === "application/x-boolean";
			this.$$valSection.toggle(!isBool);
			this.$$boolValSection.toggle(isBool);
			this.componentBoolVal.setValue(isBool && val === true);
			this.$$valueElmt.val(isBool || val == null ? "" : val);
		};
		this._resetParams = function() {
			this.editStatusSection.$$panel.hide();
			this.fieldSelector.setValue(_noValue);
			this.operatorSelector.clear();
			this.paletteColor.setValue("");
			this.$$valueElmt.val("");
		};
		this.updateStatusList = function(updateAuthoring, sel, data) {
			var clearBefore = true;
			if (clearBefore) {
				this.listStatusDisplayer.clear();
			}
			var records = [],
				style, css;
			this.statusList.forEach(function(c) {
				if (c.icon) {
					css = c.icon.css;
					style = "color:" + c.color.bgColor + ";font-size:1.4em;";
				} else {
					css = c.color ? c.color.css : "";
					style = "";
				}
				records.push({
					titleHtml: authArrayGeneral.getHtml("statusLine", {
						field: c.field,
						operator: c.operator,
						value: c.value,
						css: css,
						style: style,
						sizeColor: 15
					}),
					id: c.id
				});
			});
			this.listStatusDisplayer.insertRecords(records);
			if (updateAuthoring == true) {
				var value = [];
				this.statusList.forEach(function(c) {
					c = $.extend(true, {}, c);
					delete c.id;
					value.push(c);
				});
				authPropsGeneral.setValue(this, sel, data, value);
				authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
				return;
			}
		};
		this.paramFieldAdd = function($$root) {
			var selectOpts = [{
				"title": locale.text('auth.arrayStatus.novalue'),
				"value": _noValue
			}];
			this._protoValue.forEach(function(v, idx) {
				if (fieldOperators.acceptOperator(v.$type)) {
					selectOpts.push({
						title: v.$title,
						value: v.$bind
					});
				}
			});
			var opts = {
				value: _noValue,
				options: selectOpts,
				css: "statusField",
				onChange: jsutils.bindFn(this.onParamFieldSelect, this),
				isHidden: false
			};
			this.fieldSelector = authComponents.newComponent("select", opts);
			this._addParam("field", this.fieldSelector, true, $$root, true);
		};

		this.paramOperatorAdd = function($$root) {
			var opts = {
				value: _noValue,
				options: [{
					"title": locale.text('auth.arrayStatus.novalue'),
					"value": _noValue
				}],
				css: "statusOperator",
				onChange: jsutils.bindFn(this.onParamOperatorSelect, this),
				isHidden: false
			};
			this.operatorSelector = authComponents.newComponent("select", opts);
			this._addParam("operator", this.operatorSelector, true, $$root, true);
			this.updateOperators();
		};
		this.paramValueAdd = function($$root) {
			this.$$valueElmt = $('<input class="form-control statusValue"></input>');
			var opts = {
				size: "small",
				onText: "True",
				offText: "False",

			};
			this.$$valSection = this._addParam("value", this.$$valueElmt, true, $$root).hide();
			this.componentBoolVal = authComponents.newComponent("switcher", opts);
			this.$$boolValSection = this._addParam("value", this.componentBoolVal, true, $$root).hide();
		};
		this.paramColorAdd = function($$root) {
			var opts = {
				palette: authPropsGeneral.getColorPalette(),
				dropUp: true
			};
			this.paletteColor = authComponents.newComponent("colorPalettePicker", opts);
			this._addParam("color", this.paletteColor, true, $$root, true);
		};
		this.paramIconAdd = function($$root) {
			var opts = {
				palette: fontUtils.getArrayStatusIconList(),
				dropUp: true
			};
			this.paletteIcon = authComponents.newComponent("iconPalettePicker", opts);
			this._addParam("icon", this.paletteIcon, true, $$root, false);
		};
		this.onParamFieldSelect = function(event, prop) {
			var field = this.getFieldProto($(event.target).val());
			this.updateOperators(field.$type, "eq");
			this.$$valSection.toggle(!this.$$boolValSection.toggle(field.$type === "application/x-boolean").is(":visible"));
		};
		this.updateOperators = function(typeField, defValue) {
			defValue = defValue == null ? _noValue : defValue;
			var selectOpts = [{
				"title": locale.text('auth.arrayStatus.novalue'),
				"value": _noValue
			}];
			var ops = fieldOperators.getOperators(typeField, true);
			if (ops) {
				ops.forEach(function(v, idx) {
					selectOpts.push({
						title: v.title,
						value: v.value
					});
				});
			}
			this.operatorSelector.update(selectOpts, defValue);
		};
		this.onParamOperatorSelect = function(event, prop) {};
		this._addParam = function(prop, component, title, $$parent, mandatory) {
			var $$parent = $$parent || this.$$parent;
			var $$title;
			var $$root;
			if (title) {
				var res = this._addSubSection(prop, $$parent, mandatory);
				$$root = res.$$content;
				$$title = res.$$panel;
			} else {
				$$root = $$parent;
			}
			if (component == null) throw new Error("unexpected null component");
			var $$panel;
			if (component.createMarkup) {
				component.createMarkup($$root);
				this._myProperties.push(component);
				$$panel = component.$$panel;
			} else if (component.jquery) {
				$$root.append(component);
				$$panel = component;
			}
			return $$title ? $$title : $$panel;
		};
		this._addSubSection = function(textId, $$parent, mandatory) {
			var $$panel = $(authArrayGeneral.getHtml('subtitle', {
				title: locale.text('auth.arrayStatus.' + textId) + (mandatory === true ? "*" : ""),
				margin: 10,
				id: "arrayStatus" + textId.smCapitalize()
			})).appendTo($$parent || this.$$parent);
			return {
				$$panel: $$panel,
				$$content: $$panel.children("div"),
				$$title: $$panel.children("p")
			};
		};
	}
};

exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	if (!controller.prototype.isLookup()) {
		props.push(_properties.arrayStatusEnabled);
		var status = data.control.getAuthoring("$statusEnabled");
		if (status === "mono" || status === "multi") {
			props.push(_properties.arrayStatus);
		}
	}
};
});

define('syracuse-tablet/html/js/authoring/arrays/authArrayCarousel',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral'],function (require, exports, module) {"use strict";
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');


var _properties = {

	"arrayCarouselPeriod": {
		"key": "$carouselPeriod",
		"default": "none",
		values: [{
			value: "none"
		}, {
			value: "slow"
		}, {
			value: "normal"
		}, {
			value: "fast"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio
	}
};

exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	props.push(_properties.arrayCarouselPeriod);
};
});

define('syracuse-tablet/html/js/authoring/arrays/authoringPropertiesChart',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {"use strict";

var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var _err = authPropsGeneral.err;
var _noValue = "$$novalue$$";
var _templates = {
	subtitle: '\
		<section {{#if id}}id="{{id}}"{{/if}} style="{{#if notHidden}}overflow:hidden;{{/if}}white-space:nowrap;text-overflow:ellipsis;{{#if margin}}margin-bottom:{{margin}}px;{{/if}}">\
			{{#if title}}<p>{{title}}</p>{{/if}}\
			<div></div>\
		</section>',
	serieTitle: ' \
		<div class="panel panel-primary s-m-panel-auth-prop s-m-auth-prop-type-{{type}}"> \
			<div style="overflow:hidden;" class="panel-heading" role="tab" id="heading_{{id}}"> \
				<a id="serie_{{id}}" style="width:100%;display:table;" data-toggle="collapse" data-parent="#{{#if parentId}}{{parentId}}{{/if}}{{#unless parentId}}accordion{{/unless}}" href="#collapse_{{id}}" {{#if expanded}} aria-expanded="true"{{/if}} aria-controls="collapse_{{id}}" {{#unless expanded}}class="collapsed"{{/unless}}>\
					<div style="display:table-row;white-space: nowrap;">\
						<h4 class="panel-title" style="display:table-cell;"> \
							{{label}}\
						</h4> \
					</div>\
				</a> \
			</div> \
			<div id="collapse_{{id}}" class="panel-collapse collapse {{#if expanded}}in{{/if}}" role="seriepanel" aria-labelledby="heading_{{id}}"> \
			</div> \
		</div>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};
var _SeriePanel = function(parent, serieInfo) {
	this.name = serieInfo.name;
	this.label = serieInfo.$title;
	this.parent = parent;
	this.bind = serieInfo.$bind;
	this.color = serieInfo.color;
	this.isHidden = serieInfo.isHidden;
};
var _properties = {
	"chartHeight": {
		"key": "$chartHeight",
		"default": "medium",
		"values": [{
			"value": "xsmall"
		}, {
			"value": "small"
		}, {
			"value": "medium"
		}, {
			"value": "large"
		}, {
			"value": "xlarge"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio
	},
	/*
	 *	$Chart type (pie, line bar)
	 */
	"chartStyle": function(controller, sel, data) {
		this.name = "chartStyle";
		this.key = "$style";
		this["default"] = "line";
		this._chartGetMeasureCountVisible = function() {
			var count = data.control.prototype.chartGetNbMeasures();
			if (data.articleSelection.$seriesOptions) {
				Object.keys(data.articleSelection.$seriesOptions).forEach(function(key) {
					if (data.articleSelection.$seriesOptions[key].isHidden) {
						count--;
					}
				});
			};
			return count;
		};
		this.values = [{
			value: "line"
		}, {
			value: "bar"
		}, {
			value: "column"
		}];
		if (this._chartGetMeasureCountVisible() === 1) {
			this.values.push({
				value: "pie"
			});
		};
		this.createMarkup = authPropsGeneral.createMarkupRadio;
	},
	"chartOptions": function(controller, sel, data) {
		var values = [{
			"key": "isTitleHidden",
			"default": false
		}];
		var valuesPie = [{
			"key": "isLabelsHidden",
			"default": false
		}];
		var valueslineBarColumn = [{
			"key": "isLegendHidden",
			"default": false
		}, {
			"key": "isGridLineHidden",
			"default": false
		}, {
			"key": "isXLabelHidden",
			"default": false
		}, {
			"key": "isXLabelsHidden",
			"default": false
		}, {
			"key": "isYLabelHidden",
			"default": false
		}, {
			"key": "isYLabelsHidden",
			"default": false
		}];
		this.name = "chartOptions";
		this.key = "$chartOptions";
		this.values = values.concat((data.articleSelection.$style === "pie") ? valuesPie : valueslineBarColumn);
		this.createMarkup = authPropsGeneral.createMarkupCheckboxes;
	},
	/*Not implemented for moment*/
	"chartInverted": {
		"key": "$inverted",
		"default": false,
		"values": [{
			"value": false
		}, {
			"value": true
		}],
		createMarkup: authPropsGeneral.createMarkupRadio
	},
	"seriesOptions": function(controller, sel, data) {
		this.name = "seriesOptions";
		this.key = "$seriesOptions";
		this._serieProperties = [];

		this.initMarkup = function(controller, sel, data) {
			this._protoValue = data.control.prototype.chartGetMeasureInfo();
			this._orginalValue = data.articleSelection[this.key];
			var hasValue = this._orginalValue != null;
			this._initProps(hasValue ? this._mergeValue() : this._protoValue);
		};
		this.createMarkup = function($$parent, prop, sel, data) {
			this.$$parent = $$parent;
			this._accordionId = utils.UUID();
			this.$$myAccordion = $('<div id="' + this._accordionId + '" ></div>');
			$$parent.append(this.$$myAccordion);
			var self = this;
			self._serieProperties.forEach(function(prop) {
				self._createSerieEntry(prop, sel, data);
			});
		};
		this.destroyMarkup = function() {
			if (this._serieProperties) {
				this._serieProperties.forEach(function(prop) {
					if (prop.destroyMarkup) {
						prop.destroyMarkup();
					}
				});
			}
			this._serieProperties = null;
			if (this.$$parent) {
				this.$$parent.closest(".s-m-panel-auth-prop").remove();
				this.$$parent = null;
			}
			if (this.$$parent) {
				this.$$myAccordion = null;
			}
		};
		this._mergeValue = function() {
			var res = {}, self = this;
			Object.keys(self._protoValue).forEach(function(key) {
				res[key] = $.extend(true, {}, self._protoValue[key]);
				Object.keys((self._orginalValue && self._orginalValue[key]) || {}).forEach(function(prop) {
					res[key][prop] = self._orginalValue[key][prop];
				});
			});
			return res;
		};
		this._initProps = function(props, createEntry) {
			var self = this;
			self._serieProperties = [];
			Object.keys(props).forEach(function(key) {
				self._createSerieProperty(props[key], createEntry);
			});
		};

		this._createSerieProperty = function(prop, createEntry) {
			var prop = new _SeriePanel(this, prop);
			this._serieProperties.push(prop);
			if (createEntry) {
				this._createSerieEntry(prop);
			}
		};
		this._createSerieEntry = function(prop, sel, data) {
			var id = prop.bind;
			var $$parent;
			var $$propGroup = $(_getHtml("serieTitle", {
				id: id,
				type: "child",
				label: prop.label,
				expanded: false,
				parentId: this._accordionId
			}));
			$$parent = $$propGroup.find("#collapse_" + id);
			this.$$myAccordion.append($$propGroup);
			this.paramHiddenAdd($$parent, sel, data, prop);
			if (data.articleSelection.$style !== "pie") {
				this.paramColorAdd($$parent, sel, data, prop);
			}
		};
		this.paramHiddenAdd = function($$root, sel, data, prop) {
			var opts = {
				size: "small",
				onText: "True",
				offText: "False",
				onSwitchChange: this.onSwitchChange.bind(this, sel, data, prop)

			};
			this.componentBoolVal = authComponents.newComponent("switcher", opts);
			this._addParam(prop, "isHidden", this.componentBoolVal, true, $$root, false);
			var value = this._getPropValue(prop.bind, 'isHidden') || false;
			this.componentBoolVal.setValue(!value);
		};
		this.onSwitchChange = function(sel, data, prop, event, value) {
			var seriesOptions = $.extend(true, {}, data.articleSelection[this.key]);
			seriesOptions[prop.bind] = seriesOptions[prop.bind] || {};
			seriesOptions[prop.bind].isHidden = !value;
			authPropsGeneral.setValue(this, sel, data, seriesOptions);
			authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
		};
		this.paramColorAdd = function($$root, sel, data, prop) {
			var opts = {
				color: "",
				palette: authPropsGeneral.getColorPalette(),
				dropUp: true,
				onSelectColor: jsutils.bindFn(this.colorChange, this, sel, data, prop)
			};
			this.paletteColor = authComponents.newComponent("colorPalettePicker", opts);
			var param = this._addParam(prop, "color", this.paletteColor, true, $$root, false);
			if (this._getPropValue(prop.bind, 'isHidden')) {
				param.hide();
			}
			this.paletteColor.setValue(this._getPropValue(prop.bind, 'color'));
		};
		this._getPropValue = function(bind, property) {
			var res = null;
			this._serieProperties.forEach(function(prop) {
				if (prop.bind === bind) {
					res = prop[property];
				}
			});
			return res;
		};
		this.colorChange = function(value, sel, data, prop) {
			var seriesOptions = $.extend(true, {}, data.articleSelection[this.key]);
			seriesOptions[prop.bind] = seriesOptions[prop.bind] || {};
			seriesOptions[prop.bind].color = value;
			authPropsGeneral.setValue(this, sel, data, seriesOptions);
			authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
		};
		this._addParam = function(prop, textId, component, title, $$parent, mandatory) {
			var $$parent = $$parent || this.$$parent;
			var $$title;
			var $$root;
			if (title) {
				var res = this._addSubSection(prop, textId, $$parent, mandatory);
				$$root = res.$$content;
				$$title = res.$$panel;
			} else {
				$$root = $$parent;
			}
			if (component == null) throw new Error("unexpected null component");
			var $$panel;
			if (component.createMarkup) {
				component.createMarkup($$root);
				this._serieProperties.push(component);
				$$panel = component.$$panel;
			} else if (component.jquery) {
				$$root.append(component);
				$$panel = component;
			}
			return $$title ? $$title : $$panel;
		};
		this._addSubSection = function(prop, textId, $$parent, mandatory) {
			var $$panel = $(_getHtml('subtitle', {
				title: locale.text('auth.seriesOptions.' + textId) + (mandatory === true ? "*" : ""),
				margin: 10,
				id: "seriesColor" + prop.bind.smCapitalize()
			})).appendTo($$parent || this.$$parent);
			return {
				$$panel: $$panel,
				$$content: $$panel.children("div"),
				$$title: $$panel.children("p")
			};
		};
	},
	"axisLabels": function(controller, sel, data) {
		this.name = "axisLabels";
		this.key = "$axisLabels";
		//Authoring is yet stored by level but to keep existing authoring, we keep the key "this.labels" but always 1
		this.labels = 1;
		this.selectOpts = _getSelectOptions(data.control);
		if (this.selectOpts.length <= 1) return null;
		this.createMarkup = function($$parent, prop, sel, data) {
			var opts = {
				value: _noValue,
				options: [{
					"title": "",
					"value": _noValue
				}].concat(this.selectOpts),
				onChange: this.onChange.bind(this, $$parent, data)
			};
			this.fieldLabelList = authComponents.newComponent("select", opts, "selectLabel");
			this.fieldLabelList.createMarkup($$parent);
			if (data.articleSelection && data.articleSelection[this.key] && data.articleSelection[this.key][this.labels]) {
				this.fieldLabelList.setValue(data.articleSelection[this.key][this.labels]);
			};
		};
		this.onChange = function($$parent, data, event, componentSelect) {
			var axisOptions = $.extend(true, {}, data.articleSelection[this.key]);
			if (componentSelect.getValue() === _noValue && axisOptions[this.labels]) {
				delete(axisOptions[this.labels]);
			} else {
				axisOptions[this.labels] = componentSelect.getValue();
			}
			authPropsGeneral.setValue(this, sel, data, axisOptions);
			authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
		};
	}
};

var _getSelectOptions = function(control) {
	var selectOpts = [];
	var measures = control.prototype.chartGetMeasureInfo();
	var dataset = control.builder.getDataSet();
	var $properties = control.prototype.getProperties(function(prop, $bind) {
		if (dataset && dataset.length > 0) {
			//Must be in dataset but not a measure
			return (dataset[0][$bind] !== undefined && measures[$bind] === undefined);
		} else {
			return false;
		}
	});
	Object.keys($properties).forEach(function(v) {
		if (!$properties[v].$title) {
			var ids = v.split("_");
			if (ids.lenght >= 2 && ids[0] === "C") {
				$properties[v].$title = ($properties[v.substr(2)] ? $properties[v.substr(2)].$title : "") + " (" + v + ")";
			}
		}
		if ($properties[v].$title) {
			selectOpts.push({
				'title': $properties[v].$title,
				'value': v
			});
		}
	});
	return selectOpts;
};
exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};
exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	if (data.control.chartNeedsHeight && data.control.chartNeedsHeight()) {
		props.push(_properties.chartHeight);
	}
	props.push(_properties.chartStyle, _properties.chartOptions, _properties.seriesOptions, _properties.axisLabels);
};
});

define('syracuse-tablet/html/js/authoring/arrays/authoringPropertiesArrays',['require','exports','module','syracuse-tablet/html/js/authoring/arrays/authArrayGeneral','syracuse-tablet/html/js/authoring/arrays/authArrayTable','syracuse-tablet/html/js/authoring/arrays/authArrayCard','syracuse-tablet/html/js/authoring/arrays/authArrayStatus','syracuse-tablet/html/js/authoring/arrays/authArrayCarousel','syracuse-tablet/html/js/authoring/arrays/authoringPropertiesChart'],function (require, exports, module) {"use strict";
var authArrayGeneral = require('syracuse-tablet/html/js/authoring/arrays/authArrayGeneral');
var authArrayTable = require('syracuse-tablet/html/js/authoring/arrays/authArrayTable');
var authArrayCard = require('syracuse-tablet/html/js/authoring/arrays/authArrayCard');
var authArrayStatus = require('syracuse-tablet/html/js/authoring/arrays/authArrayStatus');
var authArrayCarousel = require('syracuse-tablet/html/js/authoring/arrays/authArrayCarousel');
var authoringPropertiesChart = require('syracuse-tablet/html/js/authoring/arrays/authoringPropertiesChart');

exports.initModuleProperties = function(dest) {
	authArrayGeneral.initModuleProperties(dest);
	authArrayCard.initModuleProperties(dest);
	authArrayTable.initModuleProperties(dest);
	authArrayStatus.initModuleProperties(dest);
	authArrayCarousel.initModuleProperties(dest);
	authoringPropertiesChart.initModuleProperties(dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	if (sel.$$elmt.is(".s-m-control.s-m-chart")) {
		// Type display and pagination only
		authArrayGeneral.getModuleProperties($$elmt, controller, props, sel, data);
		// Properties for charts authoring
		authoringPropertiesChart.getModuleProperties($$elmt, controller, props, sel, data);
	} else {
		// Commons settings
		authArrayGeneral.getModuleProperties($$elmt, controller, props, sel, data);
		// Design cards/Columns
		if (data.control.$display === "separator") {
			// Nothing
		} else {
			if (data.control.$display === "card") {
				if (data.control.isCarouselDisplay()) {
					authArrayCarousel.getModuleProperties($$elmt, controller, props, sel, data);
				}
				authArrayCard.getModuleProperties($$elmt, controller, props, sel, data);
			} else if (data.control.$display === "table") {
				if (!data.control.prototype.isSingleArray()) {
					authArrayTable.getModuleProperties($$elmt, controller, props, sel, data);
				}
			}
			// Status management on cards and tables
			authArrayStatus.getModuleProperties($$elmt, controller, props, sel, data);
		}
	}
};
});

define('syracuse-tablet/html/js/authoring/authoringPropertiesGauge',['require','exports','module','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral'],function (require, exports, module) {"use strict";

var locale = require('syracuse-tablet/html/js/helpers/locale');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');

var _err = authPropsGeneral.err;
var maxSegments = 5;

var _properties = {
	/*
	 *	Display numeric data either as normal number field or as gauge
	 */
	"numDisplay": {
		"key": "$numDisplay",
		"default": "normal",
		values: [{
			value: "normal"
		}, {
			value: "gauge"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Sets gauge range (min/max) values origin. Either "default", "bind", or "value"
	 *	- default : gauge component default range values
	 *	- bind : use one field value as range value
	 *	- value : user specified directly range values in input field
	 */
	"gSetBorderValues": {
		"key": "$gSetBorderValues",
		"default": "default",
		values: [{
			value: "default"
		}, {
			value: "value"
		}, {
			value: "bind"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio,
		type: "child"
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Set border values (min/max). It will be either a textarea or a selector
	 */
	"gBorderValues": {
		"default": "",
		createMarkup: _createMarkupGBorderValues,
		type: "child"
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Number of gauge segmets
	 */
	"gSegmentsNumber": {
		"default": "",
		createMarkup: _createMarkupGSegmentsNumbers,
		type: "child"
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Configure gauge segments
	 */
	"gSegmentsConfig": {
		"default": "",
		createMarkup: _createMarkupGSegmentsConfig,
		type: "child",
		destroyMarkup: _destroySlider
	},
	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Apply button for segments configuration
	 */
	"gSegmentsConfigApply": {
		applyMarkup: _createMarkupApply
	}
};



function _createMarkupGBorderValues($$parent, prop, sel, data) {
	var ctx = {};
	ctx.label_apply = locale.text("auth.g.label_apply");
	var idMin = "s-m-auth-g-borders-min";
	var idMax = "s-m-auth-g-borders-max";

	// markup depends if border is value or bind
	var isProperty = data.articleSelection.$gSetBorderValues === "bind" ? true : false;

	// if property, build a selection markup, filled with numeric types within the prototype
	if (isProperty) {
		var valMin = data.articleSelection.$gauge.$bindMin;
		var valMax = data.articleSelection.$gauge.$bindMax;

		ctx.label_tip = locale.text("auth.gBorderValues.label_tip.property");
		ctx.label_min = locale.text("auth.gBorderValues.label_min.property");
		ctx.label_max = locale.text("auth.gBorderValues.label_max.property");

		// get number properties from prototype
		var optionsMin = [];
		var optionsMax = [];
		optionsMin.push({
			option_value: "0",
			selected: valMin === "0"
		});

		if (data.control.controller.prototype && data.control.controller.prototype.json && data.control.controller.prototype.json.$properties) {
			$.each(data.control.controller.prototype.json.$properties, function(bind, value) {
				if (_isGaugeValuePropertyType(value.$type) && bind !== data.control.$bind && bind !== data.articleSelection.$bind) {
					optionsMin.push({
						option_value: bind,
						selected: valMin === bind
					});
					optionsMax.push({
						option_value: bind,
						selected: valMax === bind
					});
				}
			});

			ctx.markupMin = authHtml.execute("gaugeSelect", {
				id: idMin,
				options: optionsMin
			});

			ctx.markupMax = authHtml.execute("gaugeSelect", {
				id: idMax,
				options: optionsMax
			});
		} else {
			_err(locale.text("auth.gBorderValues.err.prototype.title"), locale.text("auth.gBorderValues.err.prototype.msg"));
			return;
		}

	}

	// if input, build input markup
	else {
		var valMin, valMax;
		// set valMin considering that user switched from "property" to "input"
		if (data.articleSelection.$gauge.$bindMin && typeof data.articleSelection.$gauge.$bindMin == "string") {
			valMin = data.control.controller.dao.data[data.articleSelection.$gauge.$bindMin];
		} else {
			valMin = data.articleSelection.$gauge.$bindMin;
		}

		// set valMax considering that user switched from "property" to "input"
		if (data.articleSelection.$gauge.$bindMax && typeof data.articleSelection.$gauge.$bindMax == "string") {
			valMax = data.control.controller.dao.data[data.articleSelection.$gauge.$bindMax];
		} else {
			valMax = data.articleSelection.$gauge.$bindMax;
		}

		ctx.label_tip = locale.text("auth.gBorderValues.label_tip.input");
		ctx.label_min = locale.text("auth.gBorderValues.label_min.input");
		ctx.label_max = locale.text("auth.gBorderValues.label_max.input");
		ctx.markupMin = authHtml.execute("gaugeBorderInput", {
			id: idMin,
			value: valMin
		});
		ctx.markupMax = authHtml.execute("gaugeBorderInput", {
			id: idMax,
			value: valMax
		});
	}

	var html = authHtml.execute("authPanelPropertyGBorderValues", ctx);
	var $$panel = $(html);

	// /!\ In bind, allow use of 0
	// onclick, update data and refresh
	$("button", $$panel).on("click", function(e) {
		var err = false;
		var vvMin = $(e.target).parent().find("#" + idMin).val();
		var vvMax = $(e.target).parent().find("#" + idMax).val();
		var errTitle = locale.text("auth.gBorderValues.err.title");

		// min and max are both numbers
		if (!isNaN(parseInt(vvMin), 10) && !isNaN(parseInt(vvMax), 10)) {

			if (vvMax < vvMin) {
				err = _err(errTitle, locale.text("auth.gBorderValues.err.msg.lowerMax", [vvMax, vvMin]));
			}
		} else {

			// min and max should both be string values
			if (!(typeof vvMin == "string" && typeof vvMax == "string")) {
				err = _err(errTitle, locale.text("auth.gBorderValues.err.msg.bothString", [vvMin, vvMax]));
			}

			if (vvMin === vvMax) {
				err = _err(errTitle, locale.text("auth.gBorderValues.err.msg.samebind"));
			}
		}

		if (!err) {
			data.articleSelection.$gauge.$bindMin = vvMin;
			data.articleSelection.$gauge.$bindMax = vvMax;
			authPropsGeneral.notifyChangePropUI($$parent, sel, data);
		}
	});

	// append html
	$$parent.append($$panel);
}


function _createMarkupGSegmentsNumbers($$parent, prop, sel, data) {
	// build html
	var value = data.articleSelection.$gauge.segments ? data.articleSelection.$gauge.segments.length : "";
	var options = [];
	for (var ii = 0, jj = (maxSegments + 1); ii < jj; ii++) {
		var opt = {};
		if (ii == 0) {
			opt.option_value = locale.text("auth.gSegmentsNumber.default");
			opt.selected = value ? true : false;
		} else {
			opt.option_value = ii;
			opt.selected = value == ii;
		}
		options.push(opt);
	}
	var ctx = {
		value: authHtml.execute("gaugeSelect", {
			id: "s-m-auth-g-segnumbers-txt",
			options: options
		}),
		label_apply: locale.text("auth.g.label_apply")

	};

	var html = authHtml.execute("authPanelPropertyGSegmentsNumber", ctx);
	var $$panel = $(html);


	// bind click on apply button
	// onclick, update data and refresh
	$("button", $$panel).on("click", function(e) {

		var vv = $(e.target).prev().val();

		if (value != vv) {
			if (vv && isNaN(parseInt(vv, 10))) {
				_err(locale.text("auth.gSegmentsNumber.err.title"), locale.text("auth.gSegmentsNumber.err.msg.expectedNumber", [vv]));
			} else {
				if (vv) {
					data.articleSelection.$gauge.segments = data.articleSelection.$gauge.segments || [];
					if (data.articleSelection.$gauge.segments.length > vv) {
						data.articleSelection.$gauge.segments.splice(vv);
					}
					for (var ii = 0, jj = vv; ii < jj; ii++) {
						data.articleSelection.$gauge.segments[ii] = data.articleSelection.$gauge.segments[ii] || {};
					}
				} else {
					data.articleSelection.$gauge.segments = null;
				}
				authPropsGeneral.notifyChangePropUI($$parent, sel, data);
			}
		}
	});

	// append html
	$$parent.append($$panel);
}

function _createMarkupGSegmentsConfig($$parent, prop, sel, data) {

	// build html

	var seg = data.articleSelection.$gauge.segments[prop.segIdx];
	var idRoot = "s-m-auth-seg-";
	var idx = prop.segIdx;

	var segInfo = {};
	segInfo.id = idRoot + idx;

	segInfo.label_valstart = locale.text("auth.gSegmentsConfig.label_valstart");
	segInfo.value_valstart = seg.valStart;

	segInfo.label_valend = locale.text("auth.gSegmentsConfig.label_valend");
	segInfo.value_valend = seg.valEnd;

	segInfo.label_propstart = locale.text("auth.gSegmentsConfig.label_propstart");
	segInfo.value_propstart = authHtml.execute("authPanelGaugeSlider", {
		id: segInfo.id + "-propstart",
		min: 0,
		max: 1,
		step: 0.1,
		value: seg.propStart
	});

	segInfo.label_propend = locale.text("auth.gSegmentsConfig.label_propend");
	segInfo.value_propend = authHtml.execute("authPanelGaugeSlider", {
		id: segInfo.id + "-propend",
		min: 0,
		max: 1,
		step: 0.1,
		value: seg.propEnd
	});

	segInfo.label_color = locale.text("auth.gSegmentsConfig.label_color");
	segInfo.value_color = seg.color;
	segInfo.label_apply = locale.text("auth.g.label_apply");

	var html = authHtml.execute("gaugeSegment", segInfo);
	var $$panel = $(html);

	/*
	 *	Bind events
	 */
	// generate slider
	var $$rangeInputArr = $("input.s-m-auth-g-range", $$panel);
	$$rangeInputArr.slider();
	// update range output value
	$$rangeInputArr.on("slide", function(slideEvt) {
		var $$input = $(slideEvt.target);
		var $$output = $$input.next();
		$$output.text(slideEvt.value);
	});

	$$parent.append($$panel);
}

function _createMarkupApply($$parent, prop, sel, data) {
	var html = authHtml.execute("authPanelButton", {
		label: locale.text("auth.gSegmentsConfigApply.label"),
		css: "s-m-auth-g-apply"
	});
	var $$panel = $(html);

	/* bind click on button. apply segments configuration */
	$("button", $$panel).on("click", function(e) {
		var segs = [];
		var $$segments = $(e.target).parent().parent().find(".s-m-auth-seg-slot");
		for (var ii = 0, jj = $$segments.length; ii < jj; ii++) {
			var $$seg = $($$segments[ii]);
			var id = $$seg.attr("id");
			var segInfo = {};
			segInfo.valStart = $("#" + id + "-valstart", $$seg).val();
			segInfo.valEnd = $("#" + id + "-valend", $$seg).val();
			segInfo.propStart = $("#" + id + "-propstart", $$seg).val();
			segInfo.propEnd = $("#" + id + "-propend", $$seg).val();
			segInfo.color = $("#" + id + "-color", $$seg).val();

			// if valStart, valEnd, propStart, propEnd, color value == "", set it to null 
			// this is necessary to comply with the gauge ctrl behavior
			segInfo.valStart = segInfo.valStart === "" ? null : segInfo.valStart;
			segInfo.valEnd = segInfo.valEnd === "" ? null : segInfo.valEnd;
			segInfo.propStart = segInfo.propStart === "" ? null : segInfo.propStart;
			segInfo.propEnd = segInfo.propEnd === "" ? null : segInfo.propEnd;
			segInfo.color = segInfo.color === "" ? null : segInfo.color;

			// check if valStart and valEnd are numeric values
			var vStart = segInfo.valStart;
			var vEnd = segInfo.valEnd;
			if (vStart && isNaN(parseInt(vStart.replace(".", "").replace(",", ""), 10))) {
				_err(locale.text("auth.gSegmentsConfig.err.title"), locale.text("auth.gSegmentsConfig.err.msg.expectedNumber", [locale.text("auth.gSegmentsConfig.label_valstart"), vStart]));
				return;
			}
			if (vEnd && isNaN(parseInt(vEnd.replace(".", "").replace(",", ""), 10))) {
				_err(locale.text("auth.gSegmentsConfig.err.title"), locale.text("auth.gSegmentsConfig.err.msg.expectedNumber", [locale.text("auth.gSegmentsConfig.label_valend"), vEnd]));
				return;
			}
			segs.push(segInfo);
		}
		data.articleSelection.$gauge.segments = segs;
		authPropsGeneral.notifyChangePropUI($$parent, sel, data);
	});

	$$parent.append($$panel);
}

function _destroySlider($$parent, prop) {
	var $$slider = $$parent.find('input.s-m-auth-g-range');
	if ($$slider.length > 0 && $$slider.slider) {
		$$slider.slider('destroy');
	}
}



function _getModuleProperties($$elmt, controller, props, sel, data) {

	if (_isGaugeValuePropertyType(data.type)) {

		var isGauge;

		if (data.articleSelection.$numDisplay) {
			isGauge = data.articleSelection.$numDisplay === "gauge";
		} else {
			// set $numDisplay article value if not set
			isGauge = data.articleSelection.$gauge ? true : false;
			data.articleSelection.$numDisplay = isGauge ? "gauge" : "normal";
		}

		props.push(_properties.numDisplay);

		// push gauge authoring properties according to article values
		if (isGauge) {

			if (!data.articleSelection.$gSetBorderValues) {
				// set the value of "gSetBorderValues" property
				if (data.articleSelection.$gauge.$bindMax) {
					data.articleSelection.$gSetBorderValues = typeof data.articleSelection.$gauge.$bindMax == "string" ? "bind" : "value";
				} else {
					data.articleSelection.$gSetBorderValues = "default";
				}
			}

			// add "gSetBorderValues" property
			props.push(_properties.gSetBorderValues);

			// if "gSetBorderValues" is not "default"
			// add "gBorderValues" properties
			if (data.articleSelection.$gSetBorderValues !== "default") {
				props.push(_properties.gBorderValues);
			}

			// add "gSegmentsNumber" property
			props.push(_properties.gSegmentsNumber);

			// add segments if necessary
			if (data.articleSelection.$gauge.segments && data.articleSelection.$gauge.segments.length > 0) {
				for (var ii = 0, jj = data.articleSelection.$gauge.segments.length; ii < jj; ii++) {
					var name = "gSegmentsConfig" + ii;
					_properties[name] = {
						"default": "",
						createMarkup: _createMarkupGSegmentsConfig,
						type: "child-child",
						destroyMarkup: _destroySlider,
						label: locale.text("auth.gSegmentsConfig", [(ii + 1)]),
						segIdx: ii,
						name: name
					};
					props.push(_properties[name]);
				}
				props.push(_properties.gSegmentsConfigApply);
			}
		}
	}
}

function _isGaugeValuePropertyType(type) {
	if (type.indexOf("integer") >= 0 || type.indexOf("real") >= 0 || type.indexOf("decimal") >= 0 || type.indexOf("quantity") >= 0) {
		return true;
	}
	return false;
}
exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};
exports.getModuleProperties = _getModuleProperties;
});

define('syracuse-tablet/html/js/authoring/authoringPropertiesCtrls',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/arrays/authoringPropertiesArrays','syracuse-tablet/html/js/authoring/authoringPropertiesGauge','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {"use strict";

var authUtils = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authoringPropertiesArrays = require('syracuse-tablet/html/js/authoring/arrays/authoringPropertiesArrays');
var authoringPropertiesGauge = require('syracuse-tablet/html/js/authoring/authoringPropertiesGauge');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _modules = [authoringPropertiesArrays, authoringPropertiesGauge];

var _canBeEmpty = function(typ) {
	switch (typ) {
		case "integer":
		case "real":
		case "decimal":
		case "quantity":
		case "boolean":
			return false;
		default:
			return true;
	}
};
var _ctrlFieldsProperties = {
	"checkBoxDisplayAs": {
		"key": "$displayAs",
		"default": "icon",
		"values": [{
			"value": "icon"
		}, {
			"value": "text"
		}],
		createMarkup: authUtils.createMarkupRadio
	},
	/*
	 * Title hidden
	 */
	"isTitleHidden": {
		"key": "$isTitleHidden",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: authUtils.createMarkupRadio,
		type: "default" // Default, just for header color selection
	},
	/*
	 * Hide if empty value
	 */
	"hideIfEmpty": {
		"key": "$hideIfEmpty",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: authUtils.createMarkupRadio
	},
	/*
	 * Is signature
	 */
	"isSignature": {
		"key": "$isSignature",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: authUtils.createMarkupRadio
	},
	/*
	 * scale
	 */
	"imgScale": {
		"key": "$imgScale",
		"default": "original",
		"values": [{
			"value": "original"
		}, {
			"value": "small"
		}, {
			"value": "medium"
		}, {
			"value": "large"
		}],
		createMarkup: authUtils.createMarkupRadio
	},
	/*
	 * Is GPS
	 */
	"scanGPS": {
		"key": "$scanGPS",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: authUtils.createMarkupRadio
	},

	/*
	 * Barcode scanning
	 */
	"scanBarcode": {
		"key": "$scanBarcode",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: authUtils.createMarkupRadio
	},

	/* 
	 * Position of label
	 * left:   <label> <value>
	 *
	 * top:    <label>
	 * 		   <value>
	 */
	"labelPosition": {
		"key": "$labelPosition",
		"default": "left",
		"values": [{
			"value": "left"
		}, {
			"value": "top"
		}],
		createMarkup: authUtils.createMarkupRadio
	},

	/* 
	 * Text alignment of label and values
	 * Wee keep $labelAlign for compatibility
	 */
	"labelAlign": {
		"key": "$labelAlign",
		"default": "left",
		"values": [{
			"value": "left"
		}, {
			"value": "center"
		}, {
			"value": "right"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	},

	/* 
	 * Theme for control
	 */
	"theme": {
		"key": "$theme",
		"default": "none",
		"values": [{
			"value": "none"
		}, {
			"value": "largetitle"
		}],
		createMarkup: authUtils.createMarkupRadio,
		toggleTheme: function($$elmt, theme) {
			this.removeTheme($$elmt, theme);
			this.addTheme($$elmt, theme);
		},
		removeTheme: function($$elmt, theme) {
			var e = $$elmt.get(0);
			if (!e.className || e.className.indexOf("s-m-theme") === -1) return;
			var newClassName = [];
			e.className.split(" ").forEach(function(c) {
				if (c && !c.smStartsWith("s-m-theme")) {
					newClassName.push(c);
				}
			});
			if (e.className.length === 0) return;
			e.className = newClassName.join(' ');
		},
		addTheme: function($$elmt, theme) {
			if (!theme || theme === "none") return;
			$$elmt.addClass("s-m-theme-" + theme);
		}
	},

	/*
	 * Reference field description position
	 * bottom: <value>
	 *         <desc>
	 *
	 * right:  <value> <desc>
	 * left:   <desc> <value>
	 *
	 * top:    <desc>
	 *         <value>
	 */
	"refDescPosition": {
		"key": "$refDescPosition",
		"default": "right",
		"values": [{
			"value": "bottom"
		}, {
			"value": "right"
		}, {
			"value": "left"
		}, {
			"value": "top"
		}, {
			"value": "none"
		}],
		createMarkup: authUtils.createMarkupRadio
	},

	/*
	 * Reference field description format
	 * desc:      <desc>
	 *         
	 * title:     <title>

	 * desctitle: <desc> - <title>
	 * -> If both values are equal, skip display of second value
	 * 
	 * titledesc: <title> - <desc>
	 * -> If both values are equal, skip display of second value
	 */
	"refDescFormat": {
		"key": "$refDescFormat",
		"default": "desc",
		"values": [{
			"value": "desc"
		}, {
			"value": "title"
		}, {
			"value": "desctitle"
		}, {
			"value": "titledesc"
		}],
		createMarkup: authUtils.createMarkupRadio
	},
	// only CLOB field (text plain, text html, text rtf)
	"textHeight": {
		"key": "$textHeight",
		"default": "medium",
		values: [{
			value: "small"
		}, {
			value: "medium"
		}, {
			value: "large"
		}, {
			value: "xlarge"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	},
	"emptyImageIcon": {
		"key": "$emptyImageIcon",
		"default": fontUtils.getEmptyImageDefIcon(),
		"values": fontUtils.getEmptyImageIconList(),
		createMarkup: authUtils.createMarkupIconPicker,
		destroyMarkup: authUtils.destroyMarkupIconPicker
	},
	"emptyIconSize": {
		"key": "$emptyIconSize",
		"default": "small",
		values: [{
			value: "small"
		}, {
			value: "medium"
		}, {
			value: "large"
		}, {
			value: "xlarge"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	},
	"urlIcon": {
		"key": "$urlIcon",
		"default": fontUtils.getUrlDefIcon(),
		"values": fontUtils.getUrlIconList(),
		createMarkup: authUtils.createMarkupIconPicker,
		destroyMarkup: authUtils.destroyMarkupIconPicker
	},
	"urlIconSize": {
		"key": "$urlIconSize",
		"default": "small",
		values: [{
			value: "small"
		}, {
			value: "medium"
		}, {
			value: "large"
		}, {
			value: "xlarge"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	},
	"imgHeight": {
		"key": "$imgHeight",
		"default": "small",
		values: [{
			value: "xsmall"
		}, {
			value: "small"
		}, {
			value: "medium"
		}, {
			value: "large"
		}, {
			value: "xlarge"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	}
};

exports.initModuleProperties = function(dest) {
	// Init fields properties
	authUtils.initProperties(_ctrlFieldsProperties, dest);
	// Init other type of fields properties
	_modules.forEach(function(module) {
		module.initModuleProperties(dest);
	});
};
exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	var isField = sel.$$elmt.is(".s-m-control.s-m-field");
	var isArray = sel.$$elmt.is(".s-m-control.s-m-array");
	if (isField || (isArray && !controller.prototype.isQueryLikeFacet())) {
		props.push(_ctrlFieldsProperties.isTitleHidden);
		var labelPosition = true,
			alignment = true;
		if (authUtils.getValueOrDefault(_ctrlFieldsProperties.isTitleHidden, sel, data)) {
			labelPosition = false;
		} else if (authUtils.getValueOrDefault(_ctrlFieldsProperties.labelPosition, sel, data) !== "top") {
			alignment = false;
		}
		if (labelPosition) {
			props.push(_ctrlFieldsProperties.labelPosition);
		}
		if (alignment) {
			props.push(_ctrlFieldsProperties.labelAlign);
		}
	} else if (sel.$$elmt.is(".s-m-control.s-m-chart-array")) {
		// To deal with title
		props.push(_ctrlFieldsProperties.isTitleHidden);
	}
	// ctrlFieldBase
	if (isField) {
		if (_canBeEmpty(data.type)) {
			props.push(_ctrlFieldsProperties.hideIfEmpty);
		}
		props.push(_ctrlFieldsProperties.theme);
		if (data.type === "boolean") {
			props.push(_ctrlFieldsProperties.checkBoxDisplayAs);
		}
		// Properties for reference fields only 
		if (data.type === "reference") {
			props.push(_ctrlFieldsProperties.refDescFormat);
			props.push(_ctrlFieldsProperties.refDescPosition);
		}
		// Properties for enriched text fields only (html, plain, rtf)
		if (data.type === "rtf" || data.type === "html" || data.type === "plain") {
			props.push(_ctrlFieldsProperties.textHeight);
		}
		if (data.type === "image") {
			props.push(_ctrlFieldsProperties.emptyImageIcon, _ctrlFieldsProperties.emptyIconSize, _ctrlFieldsProperties.imgHeight);
			if (controller.isEditMode()) {
				props.push(_ctrlFieldsProperties.imgScale, _ctrlFieldsProperties.isSignature);
			}
		}
		if (data.type === "string" && data.control && data.control.cssType === "s-m-url") {
			props.push(_ctrlFieldsProperties.urlIcon, _ctrlFieldsProperties.urlIconSize);
		}
		if (controller.isEditMode()) {
			if (data.control.getNativeCapabilityAuthoring("GPS") != null) {
				props.push(_ctrlFieldsProperties.scanGPS);
			}
			if (data.control.getNativeCapabilityAuthoring("scanBarcode") != null) {
				props.push(_ctrlFieldsProperties.scanBarcode);
			}
		}
		// Properties for numeric field
		authoringPropertiesGauge.getModuleProperties($$elmt, controller, props, sel, data);
	} else if (isArray) {
		if (data.control.$display === "separator") {
			props.push(_ctrlFieldsProperties.theme);
		}
		// ctrlFieldArray
		authoringPropertiesArrays.getModuleProperties($$elmt, controller, props, sel, data);
	}
};

exports.toggleTheme = function($$elmt, theme) {
	if (!$$elmt) return;
	return _ctrlFieldsProperties.theme.toggleTheme($$elmt, theme);
};
});

define('syracuse-tablet/html/js/authoring/authoringPropertiesLayouts',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/modals/modal'],function (require, exports, module) {"use strict";

var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');

var _properties = {
	/*
	 * Color of tile and layout cell
	 */
	"tileColor": {
		"key": "$bgColor",
		"default": "",
		//For compatibility with previous version - used by modalConfigTiles
		"values": authPropsGeneral.getColorValues(),
		"colorChange": function(value, sel, data, prop) {
			authPropsGeneral.setValue(this, sel, data, (value ? value.id : ""));
			authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
		},
		"createMarkup": function($$parent, prop, sel, data) {
			var opts = {
				color: "",
				palette: authPropsGeneral.getColorPalette(),
				dropUp: false,
				onSelectColor: jsutils.bindFn(this.colorChange, this, sel, data, prop)
			};
			this.paletteColor = authComponents.newComponent("colorPalettePicker", opts);
			this.paletteColor.createMarkup($$parent);
			this.paletteColor.setValue(authPropsGeneral.getColorInfo(data.articleSelection.$bgColor));
		}
	},
	/*
	 * Size of tile
	 */
	"tileSize": {
		"key": "$size",
		"default": "medium",
		"values": [{
			"value": "small"
		}, {
			"value": "medium"
		}, {
			"value": "wide"
		}, {
			"value": "large"
		}, {
			"value": "full"
		}, {
			"value": "all"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio
	},

	/*
	 * Title of layout node
	 */
	"layoutTitle": function(controller, sel, data) {
		this.name = "layoutTitle";
		this.key = "$title";
		var titleList = controller.prototype.getAllX3Title();
		if (!titleList || !titleList.length) {
			this["default"] = "";
			this.createMarkup = _createMarkupInputLocale;
			return;
		};
		this.values = titleList;
		this.createMarkup = function($$parent, prop, sel, data) {
			var opts = {
				value: "",
				options: titleList,
				onChange: jsutils.bindFn(this.valueChange, this, sel, data, prop),
				dataSize: 20
			};
			this.titleSelect = authComponents.newComponent("select", opts);
			this.titleSelect.createMarkup($$parent);
			if (data.articleSelection && data.articleSelection.$title) {
				this.titleSelect.setValue(data.articleSelection.$title);
			};
		};
		this.valueChange = function(event, titleSelect, sel, data, prop) {
			authPropsGeneral.setValue(this, sel, data, titleSelect.getValue());
			authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
		};
	},

	/*
	 * Title of layout node
	 */
	"layoutCollapsible": {
		"key": "$collapsible",
		"default": "notcollapsible",
		"values": [{
			"value": "notcollapsible"
		}, {
			"value": "expanded"
		}, {
			"value": "collapsed"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio
	},

	/*
	 * Icon of a tile
	 */
	"tileIcon": {
		"key": "$icon",
		"default": "",
		createMarkup: _createMarkupIcon
	},

	/*
	 * Size of tile
	 *
	 * Handles the following elements: $widthXs, $widthSm, $widthMd, $widthLg
	 */
	"cellSize": function(controller, sel, data) {
		this["default"] = 4;
		this["name"] = "cellSize";

		this.destroyMarkup = function() {
			this.$$parent = null;
			if (this._$$panel) {
				this._$$panel.off();
				this._$$panel = null;
			}
		};

		this.createMarkup = function($$parent, prop, sel, data) {
			var self = this;
			self.$$parent = $$parent;
			var values = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
			self._sizes = [{
				"prop": "widthAll",
				"label": locale.text("auth.cellSize.widthAll"),
				"class": "s-m-auth-highlight-all"
			}, {
				"prop": "widthXs",
				"label": locale.text("auth.cellSize.$widthXs"),
				"class": "s-m-auth-highlight-xs"
			}, {
				"prop": "widthSm",
				"label": locale.text("auth.cellSize.$widthSm"),
				"class": "s-m-auth-highlight-sm"
			}, {
				"prop": "widthMd",
				"label": locale.text("auth.cellSize.$widthMd"),
				"class": "s-m-auth-highlight-md"
			}, {
				"prop": "widthLg",
				"label": locale.text("auth.cellSize.$widthLg"),
				"class": "s-m-auth-highlight-lg"
			}];
			self._$$panel = $(authHtml.execute("authPanelPropertyCellSize", {
				id: "auth_opt_" + prop.name,
				sizes: self._sizes,
				values: values,
				sameSize: locale.text("auth.cellSize.sameSize"),
			}));
			var last = "12";
			self._sizes.forEach(function(size) {
				var value = data.articleSelection && data.articleSelection["$" + size.prop];
				value = value || last;
				last = value;
				$("label[data-s-m-auth-prop='" + size.prop + "'][data-s-m-auth-value='" + value + "']", self._$$panel).button("toggle");
			});
			self._$$panel.on("click", "label.auth-btn-size-sel", jsutils.bindFn(self.onClickSize, this, sel, data));
			self._$$panel.on("click", 'input[type="checkbox"]', jsutils.bindFn(self.onClickSameSize, this, sel, data));
			self._$$panel.appendTo($$parent);
			self.toggleSameSize($$parent, data.articleSelection["$sameSize"]);
		},
		this.onClickSize = function(e, sel, data) {
			var self = this;
			var $$ct = $(e.currentTarget);
			$$ct.eq(0).button("toggle");
			self._sizes.forEach(function(size) {
				$$ct = self._$$panel.find("label.active[data-s-m-auth-prop='" + size.prop + "']");
				if ($$ct.length > 0) {
					var value = $$ct.attr("data-s-m-auth-value");
					data.articleSelection["$" + size.prop] = value;
				}
			});
			authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
		},
		this.onClickSameSize = function(e, sel, data) {
			data.articleSelection["$sameSize"] = $(e.currentTarget).prop("checked");
			authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
		},
		this.toggleSameSize = function($$parent, yes) {
			yes = yes === true;
			this._$$panel.find('section.widthAll').toggle(yes);
			this._$$panel.find('section:not(.widthAll)').toggle(!yes);
			this._$$panel.find('input[type="checkbox"]').prop("checked", yes);
		};
	},
	"layoutTheme": function(controller, sel, data) {
		if (data.articleSelection.$collapsible === undefined || data.articleSelection.$collapsible === "notcollapsible") return null;
		var level = data.control.$$elmt.parents(".s-m-stack").length;
		//if (level < 2) return null;
		this.name = "layoutTheme";
		this.key = "$theme";
		this["default"] = String.fromCharCode(96 + level);
		this.values = [];
		this.values.push({
			"value": String.fromCharCode(96 + level)
		});
		this.values.push({
			"value": "advanced"
		});
		this.createMarkup = authPropsGeneral.createMarkupRadio;
	}
};


/*
 * Which layout node supports which properties to edit in authoring
 */
var _layoutProps = {
	"stack": [_properties.tileColor, _properties.layoutTitle, _properties.layoutCollapsible, _properties.layoutTheme],
	"row": [_properties.tileColor],
	"hub-group": [_properties.layoutTitle],
	"tile": [_properties.layoutTitle, _properties.tileColor, _properties.tileSize, , _properties.tileIcon],
	"cell": [_properties.tileColor, _properties.cellSize]
};

function _createMarkupInput($$parent, prop, sel, data) {
	var value = authPropsGeneral.getValueOrDefault(prop, sel, data);
	var html = authHtml.execute("authPanelPropertyInput", {
		id: "auth_opt_" + prop.name,
		value: value
	});
	var $$panel = $(html);
	$("input", $$panel).blur(function() {
		var value = $(this).val();
		authPropsGeneral.setValue(prop, sel, data, value);
		authPropsGeneral.notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);
}

function _createMarkupInputLocale($$parent, prop, sel, data) {
	var oldUUID = authPropsGeneral.getValueOrDefault(prop, sel, data);
	var value;
	oldUUID = oldUUID || "";
	if (oldUUID.indexOf("{@") < 0) {
		value = oldUUID; // Plain text in article
		oldUUID = "";
	} else {
		var loc = data.articlePage.$localization && data.articlePage.$localization[locale.getCurrentLocale()];
		value = oldUUID.replace(/\{\@(\S+)\}/g, function(m, g) {
			return loc && loc[g] || m;
		});
		if (value === oldUUID) {
			value = data.control.controller.prototype.resolveExpression(oldUUID, null, true);
		};
	}
	var html = authHtml.execute("authPanelPropertyInputLocale", {
		id: "auth_opt_" + prop.name,
		value: value,
		oldValue: value,
		oldUUID: oldUUID
	});
	var $$panel = $(html);
	$("input", $$panel).blur(function() {
		var value = $(this).val();
		var oldValue = $(this).attr("data-old-value");
		var oldUUID = $(this).attr("data-old-uuid");

		// If plain text value did not change and there is an uuid already, we just re assign the uuid
		// otherwise, plain text is set, which will result in recreation of a new uuid later during article generation 
		if (value === oldValue) {
			if (oldUUID.length > 0) {
				value = oldUUID;
			}
			_setValue($$parent, prop, sel, data, value);
		} else {
			if (oldValue && value && _isLocalizationExits(data.articlePage.$localization, oldUUID)) {
				modal.simpleConfirmPromise({
					message: locale.text("auth.msg.keepTranslation")
				}).then(function(result) {
					if (result.action === "yes") {
						data.articleSelection.keepKey = oldUUID;
					}
					_setValue($$parent, prop, sel, data, value);
				});
			} else {
				_setValue($$parent, prop, sel, data, value);
			}
		}

	});
	$$parent.append($$panel);
}

function _setValue($$parent, prop, sel, data, value) {
	authPropsGeneral.setValue(prop, sel, data, value);
	authPropsGeneral.notifyChangePropUI($$parent, sel, data);
}

function _isLocalizationExits($localization, uiId) {
	if (!$localization || !uiId) return false;
	var uuid = uiId.match(/\{\@(\S+)\}/),
		count = 0;
	Object.keys($localization).forEach(function(key) {
		if ($localization[key][uuid[1]] && $localization[key][uuid[1]] !== "") {
			count++;
		}
	});
	return count > 1;
}



function _createMarkupIcon($$parent, prop, sel, data) {

	var ctx = {
		group: "auth_opt_" + prop.name,
		options: []
	};

	var value = authPropsGeneral.getValueOrDefault(prop, sel, data);
	ctx.options.push({
		id: ctx.group + "_none",
		value: "",
		icon: "fa fa-remove"
	});

	fontUtils.getTileIconList().forEach(function(v) {
		var css = fontUtils.getIconByName(v);
		ctx.options.push({
			id: ctx.group + "_" + v,
			value: v,
			icon: css
		});
	});

	var html = authHtml.execute("authPanelPropertyRadioIcon", ctx);
	var $$panel = $(html);
	$("label[data-s-m-auth-value='" + ("" + value) + "']", $$panel).eq(0).button("toggle");
	$("label", $$panel).on("click", function(e) {
		var $$ct = $(e.currentTarget);
		var value = $$ct.attr("data-s-m-auth-value");
		$$ct.eq(0).button("toggle");
		authPropsGeneral.setValue(prop, sel, data, value);
		authPropsGeneral.notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);
}

exports.properties = _properties;

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	Object.keys(_layoutProps).some(function(key) {
		var cls = "s-m-" + key;
		if ($$elmt.hasClass(cls)) {
			_layoutProps[key].forEach(function(p) {
				props.push(p);
			});
		}
	});
};
exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};
});

define('syracuse-tablet/html/js/authoring/page/authoringActions',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {"use strict";
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _templates = {
	subtitle: '\
		<section class="s-m-prop-subtitle" {{#if id}}id="{{id}}"{{/if}} style="{{#if notHidden}}overflow:hidden;{{/if}}white-space:nowrap;text-overflow:ellipsis;{{#if margin}}margin-bottom:{{margin}}px;{{/if}}">\
			{{#if title}}<p>{{title}}</p>{{/if}}\
			<div></div>\
		</section>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};

var _addSubSection = function(title, id, $$parent) {
	var $$panel = $(_getHtml('subtitle', {
		title: title,
		margin: 10,
		id: id
	})).appendTo($$parent || this.$$parent);
	return {
		$$panel: $$panel,
		$$content: $$panel.children("div"),
		$$title: $$panel.children("p")
	};
};

var _optionsProperties = ["footerHeader", "refreshPage", "multiselection", "backIfSuccess"];

/**
 * Property that contains actions authoring
 * 		$pageActionSettings
 * 		[{name: actionName, $title:"", icon:"", options: {footerHeader: true/false, refreshPage:true/false, multiselection: true/false}]
 * Sub properties names
 * 		"footerHeader", "refreshPage", "multiselection"
 */

var _noValue = "$$novalue$$";
var _properties = {

	"actionSettings": function(controller, sel, data) {
		this.name = "actionSettings";
		this.label = null;
		this["default"] = null;
		this.key = "$pageActionSettings";
		this._myProperties = [];
		this._page = data.page;
		this.controller = controller;

		this.initMarkup = function(controller, sel, data) {
			if (!this._page) return;
			var $links = this._page.getProtoLinks();
			this._$links = [];
			if ($links) {
				for (var l in $links) {
					var entry = $.extend(true, {}, $links[l]);
					entry.name = l;
					entry.$title = this._page.prototype.resolveExpression(entry.$title) || entry.name;
					this._$links.push(entry);
				}
			}
			var baseArticle = data.articleSelection || {};
			baseArticle = baseArticle[this.key] || [];
			this._actionList = [];
			var self = this;
			baseArticle.forEach(function(act) {
				// Check if action is still in the proto
				if (self.getActionProto(act.name)) {
					act.$title = self._page.prototype.resolveExpression(act.$title) || entry.name;
					act.options = act.options || {};
					self._actionList.push($.extend(true, {}, act));
				}
			});
		};
		this.getActionProto = function(name) {
			var res = null;
			this._$links.some(function(v, idx) {
				if (v.name === name) {
					res = v;
					return true;
				}
			});
			return res;
		};
		this.getActionInfo = function(actName) {
			if (!actName) return null;
			var idx = -1;
			var rec = null;
			this._actionList.some(function(c, i) {
				if (c.name === actName) {
					rec = c;
					idx = i;
					return true;
				}
			});
			return idx === -1 ? null : {
				record: rec,
				idx: idx
			};
		};
		this.destroyMarkup = function() {
			this._page = null;
			this.$$parent = null;
			this.controller = null;
			this._$links = null;
			if (this._myProperties) {
				this._myProperties.forEach(function(p) {
					if (p.destroyMarkup) p.destroyMarkup();
				});
				this._myProperties = null;
			}
		};

		this.createMarkup = function($$parent, prop, sel, data) {
			if (!this._page) return;
			this.$$parent = $$parent;
			if (this._page.prototype.isQuery()) {
				this.downloadOptAdd(sel, data);
			}
			this.actionListAdd(sel, data);
			this.editSectionAdd();
			this.checkAppendButton();
		};
		this.downloadOptAdd = function(sel, data) {
			var value = authPropsGeneral.getValueOrDefault({
				"key": "$allowDownload",
				"default": false
			}, sel, data);
			var opts = {
				size: "small",
				onText: "True",
				offText: "False",
				onSwitchChange: this.onAllowDownloadChanged.bind(this, sel, data)
			};
			this.allowDownload = authComponents.newComponent("switcher", opts);
			this.$$allowDownload = this._addParam("allowDownload", this.allowDownload, true);
			this.allowDownload.setValue(value);
		};
		this.onAllowDownloadChanged = function(sel, data, event, value) {
			authPropsGeneral.setValue({
				key: "$allowDownload"
			}, sel, data, value);
			authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
		};

		this.actionListAdd = function(sel, data) {
			var opts = {
				css: "actionlist",
				doAction: jsutils.bindFn(this.listCallBackAction, this, sel, data),
				appendTitle: locale.text("auth.actionSettings.append")
			};
			this.listActionDisplayer = authComponents.newComponent("editableList", opts);
			this._addParam("actionlist", this.listActionDisplayer, true);
			this.updateActionList();
		};
		this.editSectionAdd = function() {
			this.editActionSection = this._addSubSection("editaction");
			this.editActionSection.$$panel.hide();
			this.editActionSection.$$content.css("padding-left", "7px");
			this.editActionSection.$$title.css("font-weight", "bold");
			var $$rootComponents = this.editActionSection.$$content;
			this.paramActionAdd($$rootComponents);
			this.paramOptionsAdd($$rootComponents);
			this.paramIconAdd($$rootComponents);
		};
		// No append if no actions to add
		this.checkAppendButton = function() {
			if (!this.listActionDisplayer) return;
			this.listActionDisplayer.disableAppendBtn(this._actionList.length >= this._$links.length);
		};
		this.listCallBackAction = function(action, recordId, listActionDisplayer, sel, data) {
			if (action === "append") {
				this._updateParams(null);
				return true;
			}
			if (action === "cancel") {
				this._resetEditParams();
				this.editActionSection.$$panel.hide();
				this.checkAppendButton();
				return true;
			}
			var recInfo = this.getActionInfo(recordId);
			if (action === "validate") {
				var newRecord = this.validateRecord(true);
				if (newRecord) {
					if (recInfo == null) {
						// Validate Append
						this._actionList.push(newRecord);
					} else {
						// Validate Edit
						this._actionList.splice(recInfo.idx, 1);
						this._actionList.splice(recInfo.idx, 0, newRecord);
					}
					this.updateActionList(true, sel, data);
					// Clears params
					this._resetEditParams();
					// Removes validate/cancel - Switchs to e'Append status'
					this.checkAppendButton();
					return true;
				} else {
					return false;
				}
			}
			if (action === "deleteItem") {
				if (!recInfo) return false;
				this._actionList.splice(recInfo.idx, 1);
				this.checkAppendButton();
				this.updateActionList(true, sel, data);
				return true;
			}
			if (action === "editItem") {
				if (!recInfo) return false;
				this._updateParams(recInfo.record);
				return true;
			}
		};
		this.validateRecord = function(errorMsg) {
			var self = this;
			var rec = {};
			var _fail = function(msg, params) {
				if (errorMsg === true) {
					var text = locale.text("auth.actionSettings.invalid" + (msg || ""), params);
					self.listActionDisplayer.toggleMessage(text, "error");
					setTimeout(function() {
						self.listActionDisplayer.toggleMessage(null);
					}, 2500);
				}
				return null;
			};
			rec.name = this.actionSelector.getValue();
			if (!rec.name || rec.name == _noValue) {
				return _fail();
			}
			rec.icon = this.paletteIcon.getValue();
			var info = this.getActionProto(rec.name);
			if (!info) return _fail(".action", [rec.name]);
			rec.$title = info.$title;
			rec.options = this.optionsList.getValue();
			var nbChecked = 0;
			for (var p in rec.options) {
				if (rec.options[p] === true) {
					nbChecked++;
				}
			}
			// No check is not allowed
			if (nbChecked === 0 && !rec.icon) {
				return _fail(".empty");
			}
			if (rec.options.footerHeader && !rec.icon) {
				return _fail(".icon");
			}
			return rec;
		};
		this._updateParams = function(record) {
			var edit = record != null;
			record = record || {};
			this.editActionSection.$$panel.show();
			this.paramActionUpdate(record.name || _noValue, true, record.options);
			this.optionsList.updateValue(record.options);
			this.paletteIcon.setValue(record.icon);
		};
		this._resetEditParams = function() {
			this.editActionSection.$$panel.hide();
			this.actionSelector.setValue(_noValue);
		};
		this.updateActionList = function(updateAuthoring, sel, data) {
			var clearBefore = true;
			if (clearBefore) {
				this.listActionDisplayer.clear();
			}
			var records = [];
			this._actionList.forEach(function(c) {
				records.push({
					titleHtml: "<span>" + (c.$title || c.name) + "</span>",
					id: c.name
				});
			});
			this.listActionDisplayer.insertRecords(records);
			if (updateAuthoring == true) {
				var value = [];
				this._actionList.forEach(function(c) {
					c = $.extend(true, {}, c);
					value.push(c);
				});
				authPropsGeneral.setValue(this, sel, data, value);
				authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
				return;
			}
		};
		/**
		 * Edit empty record
		 */
		this.paramActionAdd = function($$root) {
			var opts = {
				css: "actionName",
				onChange: jsutils.bindFn(this.onParamActionSelect, this),
				isHidden: false
			};
			this.actionSelector = authComponents.newComponent("select", opts);
			this._addParam("action", this.actionSelector, true, $$root, true);
			this.paramActionUpdate(_noValue);
		};

		this.onParamActionSelect = function(event, prop) {};
		/**
		 * value: 			value to select
		 * forceAddValue:	true to add value to select
		 * options:			check action to add according to options
		 */
		this.paramActionUpdate = function(value, forceAddValue, options) {
			var selectOpts = [{
				"title": locale.text('auth.actionSettings.novalue'),
				"value": _noValue
			}];
			var self = this;
			this._$links.forEach(function(v, idx) {
				if (options && options.multiselection === true && v.name.smStartsWith("$")) {
					return;
				}
				// Filters actions that are not already in the list
				if ((forceAddValue === true && value === v.name) || !self.getActionInfo(v.name)) {
					selectOpts.push({
						title: v.$title,
						value: v.name
					});
				}
			});
			this.actionSelector.update(selectOpts, value || _noValue);
		};

		this.paramOptionsAdd = function($$root) {
			var opts = {
				list: [],
				onClick: jsutils.bindFn(this.onClickOptions, this)
			};
			var self = this;
			_optionsProperties.forEach(function(x) {
				if (x === "multiselection" && !self._page.prototype.isQuery()) return;
				opts.list.push({
					id: x,
					label: locale.text('auth.actionSettings.' + x)
				});
			});
			this.optionsList = authComponents.newComponent("checkboxList", opts);
			this._addParam("options", this.optionsList, true, $$root, false);
		};
		this.onClickOptions = function(id, checked) {
			this.paramActionUpdate(this.actionSelector.getValue(), true, this.optionsList.getValue());
		};
		this.paramIconAdd = function($$root) {
			var opts = {
				palette: fontUtils.getPageActionIcon(),
				dropUp: true
			};
			this.paletteIcon = authComponents.newComponent("iconPalettePicker", opts);
			this._addParam("icon", this.paletteIcon, true, $$root, false);
		};

		this._addParam = function(prop, component, title, $$parent, mandatory) {
			var $$parent = $$parent || this.$$parent;
			var $$title;
			var $$root;
			if (title) {
				var res = this._addSubSection(prop, $$parent, mandatory);
				$$root = res.$$content;
				$$title = res.$$panel;
			} else {
				$$root = $$parent;
			}
			if (component == null) throw new Error("unexpected null component [" + prop + "]");
			var $$panel;
			if (component.createMarkup) {
				component.createMarkup($$root);
				this._myProperties.push(component);
				$$panel = component.$$panel;
			} else if (component.jquery) {
				$$root.append(component);
				$$panel = component;
			}
			return $$title ? $$title : $$panel;
		};

		this._addSubSection = function(textId, $$parent, mandatory) {
			var title = locale.text('auth.actionSettings.' + textId) + (mandatory === true ? "*" : "");
			var id = "actionSettings" + textId.smCapitalize();
			return _addSubSection(title, id, $$parent || this.$$parent);
		};
	}
};

exports.addSubSection = _addSubSection;

exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	props.push(_properties.actionSettings);
};
});

define('syracuse-tablet/html/js/authoring/page/authoringChartDetail',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral'],function (require, exports, module) {"use strict";

var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');


var _properties = {
	"chartDetailDisplay": {
		"key": "$display",
		"default": "bothSideToSide",
		"values": [{
			"value": "chartOnly"
		}, {
			"value": "arrayOnly"
		}, {
			"value": "bothSideToSide"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio
	}
};
exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};
exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	props.push(_properties.chartDetailDisplay);
};
});

define('syracuse-tablet/html/js/authoring/authoringPropertiesPages',['require','exports','module','syracuse-tablet/html/js/authoring/page/authoringActions','syracuse-tablet/html/js/authoring/page/authoringChartDetail','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var authoringActions = require('syracuse-tablet/html/js/authoring/page/authoringActions');
var authoringChartDetail = require('syracuse-tablet/html/js/authoring/page/authoringChartDetail');
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _getPage = function($$elmt, control) {
	if (control && control.isVignette()) {
		return control.getPage();
	} else if ($$elmt && $$elmt.is(".s-m-page")) {
		return $$elmt.smPageController();
	}
	return null;
};
var _properties = {
	"variants": function(controller, sel, data) {
		this.key = "$variant";
		this.views = controller.views;
		if (!this.views || this.views.length <= 1) {
			return;
		};
		var titles = [];
		var currentSelection;
		this.views.forEach(function(view, idx) {
			titles.push({
				"title": view.$title,
				"value": view.uuid || view.$url,
				"selected": view.$selected
			});
			if (view.$selected) currentSelection = view.uuid || view.$url;
		});
		this.applyMarkup = function($$parent, prop, sel, data) {
			var subsection = this._addSubSection($$parent);
			var opts = {
				css: "variants-list",
				value: currentSelection,
				options: titles,
				onChange: jsutils.bindFn(this.valueChange, this, sel, data, prop),
				dataSize: 20
			};
			this.viewSelect = authComponents.newComponent("select", opts);
			this.viewSelect.createMarkup(subsection.$$content);
			if (data.articleSelection && data.articleSelection.$variant) {
				this.viewSelect.setValue(data.articleSelection.$variant);
			};
		};

		this._addSubSection = function($$parent) {
			var title = locale.text("auth.page.views");
			var id = "pageViewsList";
			return authoringActions.addSubSection(title, id, $$parent);
		};

		this.valueChange = function(event, viewSelect, sel, data, prop) {
			var uuid = viewSelect.getValue();
			var self = this;
			var variants = data && data.page && data.page.variants;
			if (!variants) return;

			var variantSelected = variants.find(function(variant) {
				if (uuid.indexOf(variant.$uuid) > -1) {
					return true;
				};
				return false;
			});
			if (variantSelected) {
				this.views.forEach(function(view) {
					view.$selected = false;
					if (view.$url === uuid || view.uuid == uuid) {
						view.$selected = true;
					}
				});
				authPropsGeneral.notifyAuthVariantChange(JSON.parse(variantSelected.pageData.content).$article);
			}
		};
	}
};

var _modules = [authoringActions, authoringChartDetail];

exports.initModuleProperties = function(dest) {
	_modules.forEach(function(module) {
		module.initModuleProperties(dest);
	});
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	data.page = _getPage($$elmt, data.control);
	if (data.page == null) return;
	if (data.page.state.type === "chartdetail") {
		authoringChartDetail.getModuleProperties($$elmt, controller, props, sel, data);
	}
	props.push(_properties.variants);
	// #6820 Also there are no actions, we show the options to allow to set the download option
	// else if (data.page.getProtoLinks()) {
	authoringActions.getModuleProperties($$elmt, controller, props, sel, data);
	//}
};
});

define('syracuse-tablet/html/js/authoring/authoringProperties',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/authoringPropertiesCtrls','syracuse-tablet/html/js/authoring/authoringPropertiesLayouts','syracuse-tablet/html/js/authoring/authoringPropertiesPages'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var authoringPropertiesGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authoringPropertiesCtrls = require('syracuse-tablet/html/js/authoring/authoringPropertiesCtrls');
var authoringPropertiesLayouts = require('syracuse-tablet/html/js/authoring/authoringPropertiesLayouts');
var authoringPropertiesPages = require('syracuse-tablet/html/js/authoring/authoringPropertiesPages');

var _propsModules = [authoringPropertiesPages, authoringPropertiesLayouts, authoringPropertiesCtrls, authoringPropertiesGeneral];

var _properties;

exports.initProperties = function(force) {
	if (_properties != null && force != true) {
		return;
	}
	_properties = {};
	_propsModules.forEach(function(module) {
		module.initModuleProperties(_properties);
	});
};

exports.getAllProperties = function() {
	return _properties;
};

exports.getProperties = function(sel, data) {

	var $$elmt = sel.$$elmt;
	var props = [];

	var controller = $$elmt.is(".s-m-page") ? $$elmt.smPageController() : utils.findController($$elmt);

	_propsModules.forEach(function(module) {
		module.getModuleProperties($$elmt, controller, props, sel, data);
	});
	props.forEach(function(p, idx) {
		if (typeof p === "function") {
			var prop = props[idx] = new p(controller, sel, data);
			// to simplify the code writing in function object
			if (prop.initMarkup) {
				prop.initMarkup(controller, sel, data);
			}
			authoringPropertiesGeneral.initProperty(prop);
		}
	});
	return props;
};

/* The following getters are used to avoid some cyclic deps in authoring modules
 */
exports.getPropertiesLayouts = function() {
	return authoringPropertiesLayouts;
};
});

define('syracuse-tablet/html/js/authoring/authoringHelpers',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/authoring/authoringSData','syracuse-tablet/html/js/authoring/authoringProperties','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/authoring/authoringVal','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/ui/uiUtils'],function (require, exports, module) {"use strict";

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var authoringSData = require('syracuse-tablet/html/js/authoring/authoringSData');
var authProps = require('syracuse-tablet/html/js/authoring/authoringProperties');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var authVal = require('syracuse-tablet/html/js/authoring/authoringVal');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');

var _openPanels = [];

exports.triggerResizeInternal = function(opts) {
	uiutils.triggerResizeInternal(opts);
};

exports.selectElement = function(sel) {
	$(".s-m-auth-selected").removeClass("s-m-auth-selected");
	var $$elmt = $("#" + sel.id, $("#s-m-app-id"));
	var domItem = $$elmt[0];
};

/*
 * Find control instance from DOM element
 */
exports.findControl = function($$ctrl) {
	return utils.findControl($$ctrl);
};

exports.getSelectionById = function(id) {
	var $$item = $("#s-m-app-id #" + id);
	if ($$item.length <= 0) {
		return null;
	}
	return {
		$$elmt: $$item,
		id: id
	};
};

exports.getSelectionData = function(sel) {
	if (!sel || !sel.id) {
		return null;
	}
	var app = globals.getApplication();
	var article = $.extend(true, {}, app.currentPage.article);

	var title;
	var type;
	var control = exports.findControl(sel.$$elmt);
	if (control && control.isControl()) {
		title = control.prototype && control.prototype.data("$title");
		if (title) {
			title += " (" + control.$bind + ")";
		} else {
			title = control.$bind;
		}
		type = control.typeName;
	} else {
		title = locale.text("auth.label_layout");
		type = sel.$$elmt.attr("id");
		type = type.replace(/\d/g, "");
	}
	// If no control it means that it's a page authring
	// -> we pass the authoring of the page not cloned like for controls to be able to manage authoring properties for the page
	var articleSelection = (control && control.getArticle()) || app.currentPage.article;
	return {
		articlePage: article,
		articleSelection: articleSelection,
		title: title,
		type: type,
		control: control
	};
};

var _PropertyPanel = function($$parent) {
	this.$$parent = $$parent;
	// For properties that are not objects
	this.destroyHandlers = [];
	this.propInstances = [];
	this.destroy = function() {
		// First
		this.destroyHandlers.forEach(function(h) {
			if (h) h();
		});
		this.propInstances.forEach(function(p) {
			if (p.destroyMarkup) p.destroyMarkup();
		});
		this.destroyHandlers = this.propInstances = null;
		// Second
		if (this.$$parent) {
			this.$$parent.empty();
		}
	};
	this.addDestroyHandler = function($$content, prop) {
		this.destroyHandlers.push(jsutils.bindFn(prop.destroyMarkup, null, $$content, prop));
	};
	this.addPropInstance = function(prop) {
		this.propInstances.push(prop);
	};
};
// sm.auth.articlechange.ui
exports.createPropertyPanel = function($$parent, sel, data) {
	var props = authProps.getProperties(sel, data);
	if (!props) {
		return;
	}
	var propertyPanel = new _PropertyPanel($$parent);
	var $$accord = $('<div class="panel-group" id="accordion" role="tablist" aria-multiselectable="true">');
	var id;
	var num = 0;
	var toDestroy = [];
	var article = sel.articleSelection;
	var topButtons = [];
	props.forEach(function(prop) {
		id = "auth_prop_" + prop.name;
		var expanded = false;
		if (prop.createMarkup) {
			var $$block = $(
				authHtml.execute("authPanelPropertyGroup", {
					id: id,
					expanded: expanded,
					label: prop.label,
					type: prop.type || "default"
				}));
			var $$content = $('#collapse_' + id, $$block);
			prop.createMarkup($$content, prop, sel, data);
			if ($.isPlainObject(prop) && prop.destroyMarkup) {
				propertyPanel.addDestroyHandler($$content, prop);
			} else if (prop.constructor) {
				propertyPanel.addPropInstance(prop);
			}
			if (prop.isHidden === true) {
				$$block.hide();
			}
		} else if (prop.createButtonMarkup) {
			// Add button at the top of property panel
			topButtons.unshift(prop);
		} else {
			if (prop.applyMarkup) {
				prop.applyMarkup($$accord, prop, sel, data);
			} else if (prop.isSeparatror) {
				var $$block = $(
					authHtml.execute("authPanelPropertySeperator", {
						id: id,
						expanded: expanded,
						label: prop.label,
						type: prop.type || "default"
					}));
			}
		}
		$$accord.append($$block);
		num++;
	});
	topButtons.forEach(function(prop) {
		notifications.publish("sm.auth.top.button", "add", prop);
	});
	$$parent.append($$accord);
	// Expand all collapsible saved into _openPanels (all levels - see cahrts authoring)
	_openPanels.forEach(function(id) {
		$$parent.find("#" + id).collapse({
			toggle: true
		});
	});
	return propertyPanel;
};

exports.refreshPropertyPanels = function(sel, data) {
	var props = authProps.getProperties(sel, data);
	if (!props) {
		return;
	}
	props.forEach(function(prop) {
		if (prop.refreshMarkup) {
			var id = "#collapse_auth_prop_" + prop.name;
			var $$panel = $(id);
			prop.refreshMarkup($$panel, prop, sel, data);
		}
	});
};

exports.savePanelStates = function() {
	// Saved all expanded collapsibles (all levels - see cahrts authoring)
	_openPanels = [];
	$(".collapse.in", "#authPanelControlSimple").each(function() {
		_openPanels.push($(this).attr("id"));
	});
};
exports.getPageVariants = function(page) {
	var segs = page.split(".");
	return authoringSData.getPageVariants({
		application: segs[0],
		contract: segs[1],
		representation: segs[2],
		facet: segs[3]
	});
};
exports.saveAuthoring = function(page, opts) {
	return $.smResolve().then(function() {
		var segs = page.split(".");
		var pageData = {
			application: segs[0], // x3
			contract: segs[1], // erp
			representation: segs[2], // ACTIV
			facet: segs[3], // $query

			roles: [],
			users: [],
			endpoints: [],

			saveAsOption: opts.variantType,

			variantCode: opts.code,
			variantTitle: opts.title,
			variantDescription: opts.description,

			article: opts.article,
			variant: opts.uuid
		};
		if (pageData.saveAsOption === "personal_copy") {
			pageData.users.push({
				$uuid: globals.getUserUuid()
			});
		};
		return pageData;
	}).then(function(pageData) {
		var promise = authoringSData.savePageDefinition(pageData);
		var isCreation = pageData.variant == null;
		if (!isCreation) {
			return promise;
		}
		return promise.then(function(data) {
			var view = data.$actions.saveAs.$links.$view;
			view.$selected = true;
			var page = globals.getApplication().currentPage;
			var segs = page.state.authoringName.split(".");
			//Refresh variants if new one
			return authoringSData.getPageVariants({
				application: segs[0],
				contract: segs[1],
				representation: segs[2],
				facet: segs[3]
			}).then(function(variants) {
				page.variants = variants;
				//if (!page.views) return;
				page.views = page.views || [];
				page.views.forEach(function(view) {
					view.$selected = false;
				});
				// Laurent the code below is wrong I pu it in comments.
				// Fred, for me it's ok: when you create a new variant you need to add the new linked view (localy)
				page.views.push(view);
				return view;
			});
		});
	});
};
exports.getPropertiesVariants = function(page) {
	var propertiesVariants = [],
		properties = {}, viewSelected, isPersonal, self = this;
	if (!page || !page.views || !page.views.length || !page.variants || page.variants.length === 0) {
		return propertiesVariants;
	}
	viewSelected = page.views.find(function(view) {
		return view.$selected;
	});
	page.variants.forEach(function(variant) {
		isPersonal = (!variant.$factory &&
			(!variant.roles || !variant.roles.length) &&
			(!variant.endpoints || !variant.endpoints.length) &&
			(variant.users && variant.users.length === 1));
		properties = {
			description: variant.description,
			isFactory: variant.$factory,
			isPersonal: isPersonal,
			isGlobal: (!variant.$factory && !isPersonal),
			title: variant.title,
			code: variant.code,
			comment: variant.comment,
			factoryOwner: variant.$factoryOwner,
			uuid: variant.$uuid,
			isSelected: viewSelected != null && viewSelected.$url && viewSelected.$url.indexOf(variant.$uuid) > -1
		};
		propertiesVariants.push(properties);
	});
	return propertiesVariants;
},

exports.getPropertiesCurrentVariant = function(page) {
	var properties = {};
	if (!page || !page.views || !page.views.length || !page.variants || !page.variants.length) return properties;
	var viewSelected = page.views.find(function(view) {
		return view.$selected;
	});
	if (!viewSelected) return properties;
	var variantSelected = page.variants.find(function(variant) {
		if (viewSelected.$url.indexOf(variant.$uuid) > -1) {
			return true;
		};
		return false;
	});
	if (!variantSelected) return properties;
	var isPersonal = (!viewSelected.$isFactory && !variantSelected.roles.length && !variantSelected.endpoints.length && variantSelected.users.length === 1);
	/* Be carefull : shared are not managed !!!
	 * shared is when !viewSelected.isFactory && (viewSelected.roles.length!=0 || viewSelected.roles.length!=0 || viewSelected.endpoints.users.length> 1
	 */
	properties = {
		description: viewSelected.$description,
		isFactory: viewSelected.$isFactory,
		isPersonal: isPersonal,
		isGlobal: (!viewSelected.$isFactory && !isPersonal),
		title: viewSelected.$title,
		url: viewSelected.$url,
		code: variantSelected.code,
		comment: variantSelected.comment,
		factoryOwner: variantSelected.$factoryOwner,
		uuid: variantSelected.$uuid
	};
	return properties;
},
exports.rebuildArticleByPageStruct = function(page, states) {

	function _copyLocNode(uuid) {
		Object.keys($localization).forEach(function(lang) {
			var texts = $localizationNew[lang] = $localizationNew[lang] || {};
			texts[uuid] = $localization[lang][uuid];
		});
	}

	function _findLocMatch(text) {
		var oldTexts = $localization[curLang] || {};
		var match;
		Object.keys(oldTexts).some(function(uuid) {
			if (oldTexts[uuid] === text) {
				match = uuid;
				return true;
			}
			return false;
		});
		return match;
	}

	function _checkLocalization(nodeArticle) {
		var propsPerNode = ["$title"];
		propsPerNode.forEach(function(key) {
			var text = nodeArticle[key];
			if (nodeArticle.$theme === "advanced") {
				/*
				the title of "advanced" stack is wrongly stored as translated text (because of previous authoring).
				The goal of this hack is to clean the article.
				Can be removed for avengers version (after Laurent will do the authoring with his hack).
				*/
				text = "";
				nodeArticle[key] = "";
			}
			if (text) {
				var uuid = text.match(/\{\@(\S+)\}/);
				if (uuid && uuid[1]) { // text is already a placeholder, just copy to new structure
					_copyLocNode(uuid[1]);
				} else {
					uuid = _findLocMatch(text);
					if (!uuid) { // Create new ID or keep existing key (modify value only)
						var keepKey = nodeArticle.keepKey ? nodeArticle.keepKey.match(/\{\@(\S+)\}/) : null;
						uuid = keepKey ? keepKey[1] : utils.UUID();
						if (keepKey) {
							_copyLocNode(uuid);
							delete(nodeArticle.keepKey);
						}
						var texts = $localizationNew[curLang] = $localizationNew[curLang] || {};
						texts[uuid] = text;
					} else {
						_copyLocNode(uuid);
					}
					nodeArticle[key] = "{@" + uuid + "}";
				}
			}
		});
	}

	function _walkNode(article, node) {
		var nodeArticle = node.getAuthArticle();
		_checkLocalization(nodeArticle);
		if (states) {
			var state = node.getAuthState(nodeArticle.$isDirty || {});
			if (state) {
				var path = node.getPathInTree();
				path = path.join(".");
				states[path] = state;
			}
		}
		// Remove dirty flags
		delete nodeArticle.$isDirty;
		Object.keys(nodeArticle).forEach(function(key) {
			article[key] = nodeArticle[key];
		});

		if (node.isVignette()) {
			var page = node.getPage();
			if (page) { // Page is set if content of vignette is not a link
				var rootLayout = page.rootLayout;
				article.$article = {};
				_walkNode(article.$article, rootLayout);
			}
		} else {
			if (node.children && node.children.length > 0) {
				article.$items = [];
				node.children.forEach(function(child) {
					var childArticle = {};
					article.$items.push(childArticle);
					_walkNode(childArticle, child);
				});
			}
		}
	}
	var curLang = locale.getCurrentLocale();
	var rootLayout = page.rootLayout;
	var $localization = page.article && page.article.$localization || {};
	var $localizationNew = {};
	var jsonArticlePage = {};
	utils.authCopyPageProperties(page.article, jsonArticlePage);
	_walkNode(jsonArticlePage, rootLayout);
	jsonArticlePage.$localization = $localizationNew;
	var articleJSON = authVal.toSortedJSON(jsonArticlePage);
	return articleJSON;
};
});

define('syracuse-tablet/html/js/authoring/authoringPanelRight',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/authoring/authoringHtml'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');

exports.Panel = utils.defineClass(function AuthoringPanelRight() {
	var self = this;
	self.$$panel = null;
	self.topButtons = [];
}, null, {
	show: function() {
		var self = this;

		self._ensurePanel();
		self._subscribe();

		self.$$panel.show();
		self.$$splitter.show();
		/* Min width for drag - self.$$splitter.width is 0 - We should improve that*/
		self._minWidth = 4 * globals.getSiteLayout().splitterWidth;;
		self._initDefaults();

		$('.btn', self.$$panelSave).eq(0).button("toggle");
		$('.nav-pills a[href="#authPanelControl"]').tab('show');
	},

	hide: function() {
		var self = this;
		self._ensurePanel();
		self.$$panel.hide();
		self.$$splitter.hide();
		self._unscribe();
	},
	_subscribe: function() {
		var self = this;
		notifications.subscribe(self, ["sm.main.layout.changed"]);
		notifications.subscribe(self, ["sm.auth.set.page"]);
		notifications.subscribe(self, ["sm.auth.set.selection"]);
		notifications.subscribe(self, ["sm.auth.change.prop.ui"]);
		notifications.subscribe(self, ["sm.auth.top.button"]);
	},

	_unscribe: function() {
		var self = this;
		notifications.unsubscribe(self, ["sm.main.layout.changed"]);
		notifications.unsubscribe(self, ["sm.auth.set.page"]);
		notifications.unsubscribe(self, ["sm.auth.set.selection"]);
		notifications.unsubscribe(self, ["sm.auth.change.prop.ui"]);
		notifications.unsubscribe(self, ["sm.auth.top.button"]);
	},

	notifMainLayoutChanged: function() {
		var self = this;
		self.$$panel.find(".tab-content").css({
			"height": self.$$panel.height() - 100
		});
	},

	_ensurePanel: function() {
		var self = this;
		if (this.$$panel) {
			return;
		}

		var ctx = {
			label_design: locale.text("auth.panel.label_design")
		};

		self.$$panel = $("#s-m-auth-panel-right-id");
		$(authHtml.execute("authPanelRightStructure", ctx)).appendTo(self.$$panel);
		self.$$panelRightStruct = self.$$panel.find("#authPanelControlTitle");

		self._getDomObjects();
		self._initSplitter();
		self._initDomEvents();
	},

	_getDomObjects: function() {
		var self = this;
		self.$$panelControlSimple = $("#authPanelControlSimple");
		self.$$panelControlExpert = $("#authPanelControlExpert");
		self.$$authPageName = $("#authPageName");
		self.$$panelControlTitle = $("#authPanelControlTitle");
		self.$$panelControlType = $("#authPanelControlType");

		self.$$panelEdit = $("#authPanelEdit");
	},

	_initDomEvents: function() {
		var self = this;
	},

	_initDefaults: function() {
		var self = this;
		self.$$panelControlTitle.text("");
		self.$$panelControlType.text(locale.text("auth.panel.label_design"));
		self.destroyPropertyPanel();
	},
	/**
	 * context	indicates the context of destroy: selection...
	 * 		origin	"selection" -> destroy called by a selection of ctrl.layout
	 * context is used by topButtons destroyButtonMarkup
	 * 		destroyButtonMarkup returns false if button has not been destroyed
	 * -> destroyButtonMarkup/createButtonMarkup facilitate the search for buttons properties
	 */
	destroyPropertyPanel: function(context) {
		if (this.topButtons) {
			var preserveButtons = [];
			this.topButtons.forEach(function(prop) {
				if (prop.destroyButtonMarkup) {
					if (prop.destroyButtonMarkup(context) === false) {
						preserveButtons.push(prop);
					};
				}
			});
			this.topButtons = preserveButtons;
		}
		if (this._propertyPanel) {
			this._propertyPanel.destroy();
			this._propertyPanel = null;
		}
	},

	notifAuthSetPage: function(page) {
		var self = this;
		self.currentPageName = page.state.authoringName;
		self.currentPageId = page.id;
		self.$$authPageName.text(self.currentPageName);
		self._initDefaults();
		var saveAttr;
		if (page.state.type == "carddesign") {
			saveAttr = "saveCardDesign";
		} else if (page.state.type == "chartdetail") {
			saveAttr = "saveChartDetail";
		}
		if (saveAttr) {
			$("#auth-btn-save-id").attr("data-save-type", saveAttr);
		} else {
			$("#auth-btn-save-id").removeAttr("data-save-type");
		}
	},


	// Called by panel if a property like color has been changed using the simple ui
	notifAuthChangePropUi: function(articlePage) {
		var self = this;
	},

	/**
	 * path = null to remove current selection
	 */
	notifAuthSetSelection: function(id) {
		var self = this;
		self.$$panelControlTitle.text("");
		self.$$panelControlType.text(locale.text("auth.panel.label_design"));

		var sel = id ? authHelpers.getSelectionById(id) : null;

		authHelpers.savePanelStates();
		self.destroyPropertyPanel({
			origin: "selection"
		});
		var data;
		if (sel) {
			data = authHelpers.getSelectionData(sel);
			if (data) {
				self.$$panelControlTitle.text(data.title || "");
				self.$$panelControlType.text(locale.text("auth.panel.label_design") + " " + data.type || "");
				var article = data.articleSelection;
				if (article) {
					this._propertyPanel = authHelpers.createPropertyPanel(self.$$panelControlSimple, sel, data);
				}
			}
		}
		if (globals.isAutoUITestMode()) {
			var i = data ? data.control ? data.control.getUnitTestId() : data.page.state.name : null;
			globals.getUnitTestMgr().authAddRightPanelId(self.$$panelControlTitle.parent(), i);
		}
	},

	getPageArticle: function() {
		return this.getPage().article;
	},
	getPage: function() {
		var page = $("#s-m-app-id").find("#" + this.currentPageId).smPageController();
		if (!page) throw new Error("Page not found " + this.currentPageId);
		if (!page.isActive()) throw new Error("Page not active " + this.currentPageId);
		return page;
	},
	_initSplitter: function() {
		var self = this;
		self.$$splitter = $("#s-m-auth-splitter-right-id");
		self.$$splitter.draggable({
			axis: "x",
			stop: function(e, ui) {
				var $$splitter = $(this);
				var pos = $$splitter.position();
				var width = $$splitter.width();
				var panelRightSize = Math.max(self._minWidth, $(window).width() - pos.left - width);
				// Normally we should block on drag event
				$$splitter.css({
					left: ($(window).width() - panelRightSize - width) + "px"
				});
				authHelpers.triggerResizeInternal({
					layout: {
						authPanelRight: {
							width: panelRightSize
						}
					}
				});
			}
		});
	},
	/**
	 * Ad a button at the top of property panel
	 */
	notifAuthTopButton: function(action, prop) {
		if (!this.$$panelRightStruct || !prop.createButtonMarkup) return;
		this.topButtons.push(prop);
		this.$$panelRightStruct.after(prop.createButtonMarkup(this.getPage()));
	}
});
});

define('syracuse-tablet/html/js/authoring/authoringDrag',['require','exports','module','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/controls/ctrlFactory','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {"use strict";

var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');

var _$$lastElements = [];


/*
	Drag and drop helpers
*/

/*
 * Gets the control/drag element a dragged DOM element belongs to
 * (The DOM element on drag start can be a child of the actual draggable, this is why we need to go up the tree)
 */
exports.getClosestDragElement = function($$source) {
	var $$draggable = $$source.closest(".ui-draggable");
	return $$draggable;
};

exports.dropDrop = function($$drop, $$helper, $$draggable) {
	// We always drop to the highest element in the stack which belongs to the drop description
	// visible in the UI
	$$drop = _$$lastElements.length > 0 && _$$lastElements[_$$lastElements.length - 1];
	_$$lastElements = []; // There may be more drop events, we ignore all subsequent ones
	if (!$$drop) {
		return;
	}

	var data = _getDropData($$drop, $$draggable);
	if (!_isDropAllowed(data)) {
		return;
	}

	if (data.action === "add_layout") {
		_addLayout(data);
	} else if (data.action == "add_bind") {
		_addBind(data);
	} else if (data.action == "move_ctrl") {
		_moveControl(data);
	} else if (data.action == "move_layout") {
		_moveLayout(data);
	}

};

exports.dropAccept = function($$drop, $$draggable) {
	var data = _getDropData($$drop, $$draggable);
	return true;
};

exports.dropOut = function($$drop, $$helper, $$draggable) {
	$$drop.removeClass("s-m-top-stack");
	var $$top = _updateHoverStack();
	if ($$top) {
		_updateDragHelper($$top, $$helper, $$draggable);
	}
};

exports.dropOver = function($$drop, $$helper, $$draggable) {
	_$$lastElements.push($$drop);
	_updateHoverStack();
	_updateDragHelper($$drop, $$helper, $$draggable);
};

function _updateHoverStack() {
	var newList = [];
	$.each(_$$lastElements, function(idx, $$last) {
		$$last.removeClass("s-m-top-stack");
		if ($$last.hasClass("s-m-auth-hover-droptarget")) {
			newList.push($$last);
		}
	});
	var $$last = newList[newList.length - 1];
	if ($$last) {
		$$last.addClass("s-m-top-stack");
	}
	_$$lastElements = newList;
	return $$last;
}

function _updateDragHelper($$drop, $$helper, $$draggable) {
	var data = _getDropData($$drop, $$draggable);
	var allowed = _isDropAllowed(data);

	$$helper.removeClass("drop_move");
	$$helper.removeClass("drop_add");
	$$helper.removeClass("drop_disabled");
	if (!allowed) {
		$$helper.addClass("drop_disabled");
		$('#s-m-auth-drag-helper-desc-id', $$helper).text("");
		return;
	}

	var desc = "";
	var title;

	if (data.moveBeforeCtrl) {
		title = _controlTitle(data.moveBeforeCtrl);
	} else {
		title = _controlTitle(data.toContainer);
	}

	switch (data.action) {
		case "add_layout":
			if (data.moveBeforeCtrl) {
				desc = locale.text("auth.drag.add.before", [title]);
			} else {
				desc = locale.text("auth.drag.add.intoend", [title]);
			}
			$$helper.addClass("drop_add");
			break;
		case "add_bind":
			if (data.moveBeforeCtrl) {
				desc = locale.text("auth.drag.add.before", [title]);
			} else {
				desc = locale.text("auth.drag.add.intoend", [title]);
			}
			$$helper.addClass("drop_add");
			break;
		case "move_ctrl":
			if (data.moveBeforeCtrl) {
				desc = locale.text("auth.drag.move.before", [title]);
			} else {
				desc = locale.text("auth.drag.move.intoend", [title]);
			}
			$$helper.addClass("drop_move");
			break;
		case "move_layout":
			if (data.moveBeforeCtrl) {
				desc = locale.text("auth.drag.move.before", [title]);
			} else {
				desc = locale.text("auth.drag.move.intoend", [title]);
			}
			$$helper.addClass("drop_move");
			break;
	}

	$('#s-m-auth-drag-helper-desc-id', $$helper).text(desc);
}

function _isDropAllowed(data) {
	if (!data.toType) {
		return false;
	}

	var targetLayout;
	var container;

	if (data.ctrl) {
		data.container = data.ctrl.parent;
	}

	if (data.toCtrl && data.toCtrl.isLayout()) {
		container = data.toCtrl;
		targetLayout = data.toType;
	} else if (data.toCtrl) {
		container = data.toCtrl.parent;
		targetLayout = container.$type;
		data.moveBeforeCtrl = data.toCtrl;
	}
	data.toContainer = container;

	// Check layout constraints
	if (data.action === "add_layout") {
		if (data.bind == "stack") {
			if (targetLayout !== "stack" && targetLayout !== "cell" && targetLayout !== "tile") {
				return false;
			}
		} else if (data.bind == "group") {
			if (targetLayout !== "stack" && targetLayout !== "hub") {
				return false;
			}
		} else if (data.bind == "tile") {
			if (targetLayout !== "row" && targetLayout !== "hubGroup" && targetLayout !== "stack" && targetLayout !== "hub") {
				return false;
			}
		}
		return true;
	}

	// Check adding of controls
	if (data.action === "add_bind") {
		// Controlls in a vignette may only be added to the vignette the control belongs too but not to another one
		if (data.parent != data.toParent) {
			return false;
		}
		// Controls may only be added in a stack
		if (targetLayout === "stack" || targetLayout === "tile" || targetLayout === "cell" || targetLayout === "hubGroup") {
			return true;
		}
	}

	if (data.action === "move") {
		/* 
		 * Move of control
		 */
		if (data.ctrl && !data.ctrl.isLayout()) {
			data.action = "move_ctrl";
			if (data.parent != data.toParent) {
				return false;
			}

			// Controls may only be added in a stack
			if (targetLayout === "stack" || targetLayout === "tile" || targetLayout === "cell" || targetLayout === "hubGroup") {
				return true;
			}
		} else if (data.ctrl && data.ctrl.isLayout()) {
			data.action = "move_layout";
			if (data.type == "stack") {
				if (targetLayout !== "stack" && targetLayout !== "cell" && targetLayout !== "tile") {
					return false;
				}
			} else if (data.type == "tile") {
				if (targetLayout !== "hubGroup") {
					return false;
				}
			} else if (data.type == "cell") {
				if (targetLayout !== "row") {
					return false;
				}
			} else if (data.type == "row") {
				if (targetLayout !== "stack" && targetLayout !== "cell" && targetLayout !== "tile") {
					return false;
				}
			} else if (data.type == "hubGroup") {
				if (targetLayout !== "hub") {
					return false;
				}
			}

			// Check drop into self
			var $$dropToChildren = data.toCtrl.$$elmt.closest("#" + data.ctrl.id);
			if ($$dropToChildren.length > 0) { // Drop layout into a children of itself
				return false;
			}

			// Check vignette scope
			var vignetteScopeOk = true;
			var $$fromVignette = data.ctrl.$$elmt.closest(".s-m-control.s-m-vignette");
			var $$toVignette = data.toCtrl.$$elmt.closest(".s-m-control.s-m-vignette");
			if ($$fromVignette.length !== $$toVignette.length) { // From/to vignette to non vignette scope or other way around
				vignetteScopeOk = false;
			} else if ($$toVignette.length === 0) { // No vignettes involved, always ok
				vignetteScopeOk = true;
			} else if ($$fromVignette.length === 1 && $$toVignette.length === 1) { // From vignette to vignette scope
				if ($$fromVignette.attr("id") === $$toVignette.attr("id")) {
					vignetteScopeOk = true; // Same vignette	
				} else {
					vignetteScopeOk = false; // Vignette a -> vignette b = not allowed
				}
			}
			return vignetteScopeOk;
		}
	}
	return false;
}

function _getDropData($$drop, $$draggable) {
	var action;
	var fromId;
	var toId;
	var bind;
	var parent;

	action = $$draggable.attr("data-auth-drag-action");
	switch (action) {
		case "move":
			fromId = $$draggable.attr("data-ctrl-id");
			break;
		case "add_bind":
			bind = $$draggable.attr("data-auth-bind");
			parent = $$draggable.attr("data-auth-bind-parent");
			parent = parent === "" ? null : parent;
			break;
		case "add_layout":
			bind = $$draggable.attr("data-auth-bind");
			break;
		default:
			// drop from page (events currently disabled)
			action = "move";
			fromId = $$draggable.attr("id");
			break;
	}

	var ctrl;
	var $$ctrl;
	if (fromId && fromId.length > 0) {
		$$ctrl = $("#" + fromId);
		ctrl = authHelpers.findControl($$ctrl);
		var v = ctrl && ctrl.controller.getParentVignette();
		if (v) {
			parent = v.$bind; // Name of the vignette that is bound to the controller of the current element
		}
	}

	// drop control or layout
	toId = $$drop.attr("data-ctrl-id"); // drop inside tree
	if (toId && toId.length > 0) {
		$$ctrl = $("#" + toId);
	} else {
		toId = $$drop.attr("id"); // Drop inside page
		$$ctrl = $$drop;
	}

	var toParent;
	var toCtrl = authHelpers.findControl($$ctrl);
	if (toCtrl) {
		if (toCtrl.controller.isVignette) {
			var v = toCtrl.controller.getParentVignette();
			if (v) {
				toParent = v.$bind; // Name of the vignette that is bound to the controller of the current element
			}
		}
	}

	if (!toCtrl && $$ctrl.is(".s-m-page,.s-m-full")) { // Dropping on the page is dropping into the page's root layout container
		toCtrl = globals.getApplication().currentPage.rootLayout;
	}

	return {
		//		$$draggable: $$draggable,	// Debugging
		//		$$drop: $$drop,				// Debugging

		action: action, // move, add_bind, add_layout
		bind: bind, // $bind or name of layout in case of add*
		ctrl: ctrl,
		type: ctrl && ctrl.$type, // Type of drag target
		parent: parent, // parent $bind (e.g. vignette name)
		fromId: fromId, // ctrlId (when dragging existing ctrl)
		toId: toId, // ctrlId of drop target
		toType: toCtrl && toCtrl.$type, // Type of drop target
		toCtrl: toCtrl,
		toParent: toParent
	};
}

function _addLayout(data) {
	var layoutType = "stack";
	var toContainer = data.toContainer;
	var parent;

	switch (data.bind) {
		case "group":
			if (data.toType == "hub") {
				layoutType = "hubGroup";
			} else {
				layoutType = "row";
			}
			break;
		case "tile":
			if (data.toType == "hubGroup") {
				layoutType = "tile";
			} else if (data.toType == "row") {
				layoutType = "cell";
			} else if (data.toType == "stack") {
				parent = ctrlFactory.createLayout(data.toCtrl.controller, toContainer, {
					$layoutType: "row"
				}, {});
				layoutType = "cell";
				toContainer = parent;
			} else if (data.toType == "hub") {
				parent = ctrlFactory.createLayout(data.toCtrl.controller, toContainer, {
					$layoutType: "hubGroup"
				}, {});
				layoutType = "tile";
				toContainer = parent;
			}

			break;
		case "stack":
			layoutType = "stack";
			break;
	}

	var article = {
		$layoutType: layoutType
	};

	// Create new layout node
	var ctrl = ctrlFactory.createLayout(data.toCtrl.controller, toContainer, article, {});

	// Move before desired sibling
	if (data.moveBeforeCtrl) {
		if (parent) { // Handle autoboxing
			data.toContainer.removeChildRef(parent);
			data.toContainer.addChildBefore(parent, data.moveBeforeCtrl);
		} else {
			toContainer.removeChildRef(ctrl);
			toContainer.addChildBefore(ctrl, data.moveBeforeCtrl);
		}
	}

	notifications.publish(["sm.auth.change.item.prop.ui"]);
}

function _addBind(data) {
	var article = {
		$bind: data.bind
	};
	var toContainer = data.toContainer;
	if (data.toType == "hubGroup") {
		var parent = ctrlFactory.createLayout(data.toCtrl.controller, toContainer, {
			$layoutType: "tile"
		}, {});
		toContainer = parent;
	}

	var ctrl = ctrlFactory.createBindControl(data.toCtrl.controller, toContainer, article, {});

	// Move before desired sibling
	if (data.moveBeforeCtrl) {
		data.toContainer.removeChildRef(ctrl);
		data.toContainer.addChildBefore(ctrl, data.moveBeforeCtrl);
	}

	notifications.publish(["sm.auth.change.item.prop.ui"]);
}

function _moveControl(data) {
	data.container.removeChildRef(data.ctrl);
	var toContainer = data.toContainer;
	if (data.toType == "hubGroup") {
		var parent = ctrlFactory.createLayout(data.toCtrl.controller, toContainer, {
			$layoutType: "tile"
		}, {});
		toContainer.removeChildRef(parent);
		toContainer.addChildBefore(parent, data.moveBeforeCtrl);
		parent.addChildBefore(data.ctrl, null);
	} else {
		toContainer.addChildBefore(data.ctrl, data.moveBeforeCtrl);
	}
	notifications.publish(["sm.auth.change.item.prop.ui"]);
}

function _moveLayout(data) {
	data.container.removeChildRef(data.ctrl);
	data.toContainer.addChildBefore(data.ctrl, data.moveBeforeCtrl);
	notifications.publish(["sm.auth.change.item.prop.ui"]);
}

function _controlTitle(ctrl) {
	var title = ctrl.prototype && ctrl.prototype.data("$title");

	if (!title) {
		title = ctrl.$bind;
	} else if (ctrl.$bind) {
		title = title + " (" + ctrl.$bind + ")";
	}

	if (!title) {
		title = ctrl.$type;
	}
	return title;
}
});

define('syracuse-tablet/html/js/authoring/authoringPanelLeft',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/authoring/authoringDrag'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var authDrag = require('syracuse-tablet/html/js/authoring/authoringDrag');

var $$lastHoverList;

exports.Panel = utils.defineClass(function AuthoringPanelLeft() {
	var self = this;
	self.$$panel = null;
	self.$$page = $("#s-m-app-id");
	self._bindsOnPage = [];
}, null, {
	show: function() {
		var self = this;

		self._ensurePanel();
		self._subscribe();

		self.$$panel.show();
		self.$$splitter.show();
		/* Min width for drag - width of tabs - self.$$splitter.width is 0 - We should improve that*/
		self._minWidth = 2 * globals.getSiteLayout().splitterWidth;
		self.$$panel.find(".s-m-site-auth-panel-content > ul.nav.nav-pills > li").each(function() {
			self._minWidth += $(this).outerWidth();
		});
	},

	hide: function() {
		var self = this;
		self._ensurePanel();
		self.$$panel.hide();
		self.$$splitter.hide();
		self._unscribe();
	},

	_subscribe: function() {
		var self = this;
		notifications.subscribe(self, ["sm.main.layout.changed"]);
		notifications.subscribe(self, ["sm.auth.set.page"]);
		notifications.subscribe(self, ["sm.auth.change.prop.ui"]);

		notifications.subscribe(self, ["sm.auth.set.selection"]);
		notifications.subscribe(self, ["sm.auth.remove.selection"]);

		notifications.subscribe(self, ["sm.auth.hover.in"]);
		notifications.subscribe(self, ["sm.auth.hover.out"]);
		notifications.subscribe(self, ["sm.page.loaded"]);
	},

	_unscribe: function() {
		var self = this;
		notifications.unsubscribe(self, ["sm.main.layout.changed"]);
		notifications.unsubscribe(self, ["sm.auth.set.page"]);
		notifications.unsubscribe(self, ["sm.auth.change.prop.ui"]);

		notifications.unsubscribe(self, ["sm.auth.set.selection"]);
		notifications.unsubscribe(self, ["sm.auth.remove.selection"]);

		notifications.unsubscribe(self, ["sm.auth.hover.in"]);
		notifications.unsubscribe(self, ["sm.auth.hover.out"]);
		notifications.unsubscribe(self, ["sm.page.loaded"]);
	},

	notifMainLayoutChanged: function() {
		var self = this;

		$("#s-m-auth-tree-box", self.$$panel).css({
			"height": self.$$panel.height() - 45
		});
		$("#s-m-auth-insert-box", self.$$panel).css({
			"height": self.$$panel.height() - 40
		});
	},

	_ensurePanel: function() {
		var self = this;
		if (this.$$panel) {
			return;
		}
		var ctx = {
			label_content: locale.text("auth.panel.label_content"),
			label_insert: locale.text("auth.panel.label_insert"),
			label_containers: locale.text("auth.panel.label_containers"),
			label_fields: locale.text("auth.panel.label_fields"),
			lab_drag_to_add: locale.text("auth.label_layout.drag"),
			lab_group: locale.text("auth.label_layout.group"),
			lab_tile: locale.text("auth.label_layout.tile"),
			lab_stack: locale.text("auth.label_layout.stack"),
		};

		self.$$panel = $("#s-m-auth-panel-left-id");
		self.$$panel.append($(authHtml.execute("authPanelLeftStructure", ctx)));

		self._getDomObjects();
		self._initSplitter();
	},

	_getDomObjects: function() {
		var self = this;
		self.$$structureRoot = $("#auth-structure-root-id", self.$$panel);
		self.$$prototypeRoot = $("#auth-lp-cnt-props-clpse", self.$$panel);
	},

	_initSplitter: function() {
		var self = this;
		self.$$splitter = $("#s-m-auth-splitter-left-id");
		self.$$splitter.draggable({
			axis: "x",
			stop: function(e, ui) {
				var $$splitter = $(this);
				var pos = $$splitter.position();
				var width = $$splitter.width();
				var panelLeftSize = Math.max(self._minWidth, pos.left);
				// Normally we should block on drag event
				$$splitter.css({
					left: panelLeftSize + "px"
				});
				authHelpers.triggerResizeInternal({
					layout: {
						authPanelLeft: {
							width: panelLeftSize
						}
					}
				});
			}
		});
	},

	notifAuthSetPage: function(page) {
		var self = this;
		self._resetContent(page.article);
	},

	notifAuthChangePropUi: function(articlePage) {
		var self = this;
		var article = JSON.parse(articlePage);
		self._resetContent(article);
	},

	notifPageLoaded: function(page) {
		var self = this;
		if (globals.getCurrentPage().isDashboard()) {
			self._resetContent(globals.getCurrentPage().article);
		}
	},

	_resetContent: function(article) {
		var self = this;
		self._buildPageStructTree();
		self._buildProtoStructTree();
		self._initDomEvents();
		self._initDrag();
	},

	notifAuthSetSelection: function(id) {
		var self = this;
		var $$item = self._getItemById(id);
		if ($$item.length > 0) {
			$$item.addClass("s-m-auth-selected");
			var $$tb = $("#s-m-auth-tree-box", self.$$panel);
			var o1 = $$tb.offset();
			var o2 = $$item.offset();
			if (o2.top < o1.top || o2.top > (o1.top + $$tb.height())) {
				var scroll = o2.top - (o1.top + $$tb.height() / 2);
				$("#s-m-auth-tree-box", self.$$panel).animate({
					scrollTop: scroll
				}, 500);
			}
		}
	},

	notifAuthRemoveSelection: function(id) {
		var self = this;
		var $$item = self._getItemById(id);
		$$item.removeClass("s-m-auth-selected");
	},

	notifAuthHoverIn: function(id) {
		var self = this;
		var $$item = self._getItemById(id);
		$$item.addClass("s-m-auth-hover");
	},

	notifAuthHoverOut: function(id) {
		var self = this;
		var $$item = self._getItemById(id);
		$$item.removeClass("s-m-auth-hover");
	},

	_getItemById: function(id) {
		var self = this;
		return $('[data-ctrl-id="' + id + '"]', self.$$panel);
	},

	_buildPageStructTree: function() {
		var self = this;
		self._bindsOnPage = [];

		function _walkNode(node, $$parent, bindParent, level) {
			var nodeArticle = node.getArticle();
			var id = node.id;
			var typeClass;
			var label;

			// Never show root level layout node since it cannot be changed at all
			if (level === 1) {
				if (node.children && node.children.length > 0) {
					node.children.forEach(function(child) {
						if (child.article.$noAuthoring) {
							return;
						}
						var $$ul = $('<ul class="s-m-auth-tree">').appendTo($$parent);
						_walkNode(child, $$ul, bindParent, level + 1);
					});
				}
				return;
			}

			if (node.isControl()) {
				var title = node.prototype && node.prototype.data("$title");
				typeClass = node.typeName;
				label = title ? title : nodeArticle.$bind;
				var bind = bindParent != null ? bindParent + "." + node.$bind : node.$bind;
				self._bindsOnPage.push(bind);
			} else {
				typeClass = nodeArticle.$layoutType || node.typeName;
				label = nodeArticle.$title ? node.getArticleText("$title") + " (" + typeClass + ")" : typeClass;
			}
			var $$item = $('<li class="s-m-auth-tree s-m-auth-tree-' + typeClass + '">').appendTo($$parent);
			if (globals.isAutoUITestMode() && node.getUnitTestId) {
				var i = node.getUnitTestId();
				if (i) {
					globals.getUnitTestMgr().authAddTreeElmtId($$item, i);
				}
			}
			var $$p = $('<p title="' + nodeArticle.$bind + '" data-ctrl-id="' + id + '" class="s-m-draggable s-m-droppable" data-auth-drag-action="move">' + label + '</p>');
			$$item.append($$p);
			if (node.isVignette()) {
				self._bindsOnPage.push(node.$bind);
				var page = node.getPage();
				if (page) { // Page is set if content of vignette is not a link
					var rootLayout = page.rootLayout;
					var $$ul = $('<ul class="s-m-auth-tree">').appendTo($$item);
					var $$li = _walkNode(rootLayout, $$ul, node.$bind, level + 1);
					$(">p", $$li).removeClass("s-m-draggable");
				}
			} else {
				if (node.children && node.children.length > 0) {
					node.children.forEach(function(child) {
						if (child.article.$noAuthoring) {
							return;
						}
						var $$ul = $('<ul class="s-m-auth-tree">').appendTo($$item);
						_walkNode(child, $$ul, bindParent, level + 1);
					});
				}
			}
			return $$item;
		}

		var page = globals.getApplication().currentPage;
		var rootLayout = page.rootLayout;
		var label = page.prototype.data("$title") || locale.text("page");

		self.$$structureRoot.empty();
		var $$item = $('<li class="s-m-auth-tree s-m-auth-tree-page">').appendTo(self.$$structureRoot);
		$$item.append('<p data-ctrl-id="' + page.id + '">' + label + '</p>');
		var $$ul = $('<ul class="s-m-auth-tree">').appendTo($$item);

		var $$li = _walkNode(rootLayout, $$ul, null, 1);
		$(">p", $$li).removeClass("s-m-draggable");
	},

	/*
	 * Show page prototype tree, only show items that are not yet bound (referenced with $bind) on the page
	 * To only allow to add each field exactly one time.
	 */
	_buildProtoStructTree: function() {
		var self = this;
		var page = globals.getApplication().currentPage;
		var label = page.prototype.data("$title");
		self.$$prototypeRoot.empty();
		var $$item = $('<li class="s-m-auth-tree s-m-auth-tree-page">').appendTo(self.$$prototypeRoot);
		$$item.append('<p data-ctrl-id="' + page.id + '">' + label + '</p>');
		var $$ul = $('<ul class="s-m-auth-tree">').appendTo($$item);

		if (jsutils.isInstanceOf(page, "DashboardPage")) {
			var props = page.prototype.getPropertyNames();
			props.forEach(function(key) {
				self._addVignette(page, key, $$ul);
			});
		} else {
			self._addPage(page, $$ul);
		}
		/* Do not show "nothing to add..." for now
		var $$children = $("li", $$ul);
		if ($$children.length <= 0) {
			$$item = $('<li class="s-m-auth-tree s-m-auth-tree-nothing">' + locale.text("auth.panel.label_nothing") + '</li>').appendTo(self.$$prototypeRoot);
		}
		*/
	},

	_addVignette: function(page, vignette, $$parent) {
		var self = this;
		var proto = page.prototype;
		var prop = proto.property(vignette);
		var title = proto.property(vignette, "$title");
		var label = title ? title + " (" + vignette + ")" : vignette;
		var $$item = $('<li class="s-m-auth-tree s-m-auth-tree-vignette">').appendTo($$parent);
		$$item.append('<p class="s-m-draggable" data-auth-bind="' + vignette + '"  data-auth-drag-action="add_bind">' + label + '</p>');

		var ctrlVignette = page.getControlByBind(vignette);
		if (ctrlVignette) { // may be null, if vignette is not loaded yet
			$$item.removeClass("s-m-draggable");
			$$item.addClass("disabled");

			page = ctrlVignette.getPage();

			// May be null if vignette is not displaying the content but only a link
			if (page) {
				var $$ul = $('<ul class="s-m-auth-tree">').appendTo($$item);
				self._addPage(page, $$ul, vignette);

				var $$children = $("li", $$ul);
				// vignette used on page already and also all it's children, so no need to show
				if (self._bindsOnPage.indexOf(vignette) > -1) {
					if ($$children.length <= 0) {
						$$item.remove();
					}
				}
				if ($$children.length <= 0) {
					$$ul.remove();
				}
			} else {
				// Vignette is only a link and already used on page
				if (self._bindsOnPage.indexOf(vignette) > -1) {
					$$item.remove();
				}
			}
		}
	},

	_addPage: function(page, $$parent, bindParent) {
		var self = this;
		var label = "?";
		var proto = page.prototype;
		var props = proto.getPropertyNames();
		props.forEach(function(key) {
			if (proto.property(key, "$isExcluded") !== true) {;
				var bind = bindParent != null ? bindParent + "." + key : key;
				if (self._bindsOnPage.indexOf(bind) < 0) {
					var title = proto.property(key, "$title");
					var type = proto.property(key, "$type");
					var typeClass = utils.getTypeName(type);
					var label = title ? title + " (" + key + ")" : key;
					var $$item = $('<li class="s-m-auth-tree s-m-auth-tree-' + typeClass + '">').appendTo($$parent);
					$$item.append('<p class="s-m-draggable" data-auth-bind="' + key + '" data-auth-bind-parent="' + (bindParent || '') + '" data-auth-drag-action="add_bind">' + label + '</p>');
				}
			}
		});
	},

	_initDomEvents: function() {
		var self = this;
		$("li.s-m-auth-tree > p", $("#auth-structure-root-id")).not('li.s-m-auth-hidden > p').mouseover(function(e) {
			var $$o = $(e.currentTarget);
			if ($$lastHoverList) {
				$$lastHoverList.removeClass("s-m-auth-hover");
				var id = $$lastHoverList.attr("id");
				notifications.publishEx(["sm.auth.hover.out"], {
					exclude: [self]
				}, id);
			}
			$$o.addClass("s-m-auth-hover");
			$$lastHoverList = $$o;

			var id = $$o.attr("data-ctrl-id");
			notifications.publishEx(["sm.auth.hover.in"], {
				exclude: [self]
			}, id);
			return false;
		});

		$("li.s-m-auth-tree > p", $("#auth-structure-root-id")).not('li.s-m-auth-hidden > p').mouseout(function(e) {
			var $$o = $(e.currentTarget);
			$$o.removeClass("s-m-auth-hover");
			var id = $$o.attr("data-ctrl-id");
			notifications.publishEx(["sm.auth.hover.out"], {
				exclude: [self]
			}, id);
		});

		$("li.s-m-auth-tree > p", $("#auth-structure-root-id")).not('li.s-m-auth-hidden > p').click(function(e) {
			self.setSelection($(e.currentTarget), false);
			return false;
		});
		$("li.s-m-auth-tree > p", $("#auth-structure-root-id")).not('li.s-m-auth-hidden > p').dblclick(function(e) {
			self.makeVisibleInPage($(e.currentTarget));
			return false;
		});
	},

	/**
	 * Set current selection
	 * if $$newSel = null just remove the current selection
	 */
	setSelection: function($$newSel, noScroll) {
		var self = this;
		var $$old = $(".s-m-auth-selected", self.$$panel);
		$$old.removeClass("s-m-auth-selected");
		var id = $$old.attr("data-ctrl-id");
		notifications.publishEx(["sm.auth.remove.selection"], {
			exclude: [self]
		}, id);
		if ($$newSel) {
			// new sitem to select
			$$newSel.addClass("s-m-auth-selected");
			id = $$newSel.attr("data-ctrl-id");
		} else {
			// just remove selection
			id = null;
		}
		notifications.publishEx(["sm.auth.set.selection"], {
			exclude: [self]
		}, id, noScroll == null ? true : noScroll);
	},

	makeVisibleInPage: function($$sel) {
		var self = this;
		self.setSelection($$sel, false);
	},

	_initDrag: function() {
		var self = this;
		var dragParam = {
			scroll: false,
			containment: $("body"),
			helper: function(event) {
				var $$source = $(event.target);
				return self._createDragHelper($$source);
			},
			appendTo: "body",
		};
		$(".s-m-draggable", self.$$panel).draggable(dragParam);
		$(".s-m-droppable", self.$$structureRoot).droppable({
			greedy: true,
			hoverClass: "s-m-auth-hover-droptarget",
			tolerance: "pointer",
			drop: function(event, ui) {
				var $$helper = ui.helper;
				var $$draggable = ui.draggable;
				return authDrag.dropDrop($(this), $$helper, $$draggable);
			},
			accept: function($$draggable) {
				return authDrag.dropAccept($(this), $$draggable);
			},
			over: function(event, ui) {
				var $$helper = ui.helper;
				var $$draggable = ui.draggable;
				return authDrag.dropOver($(this), $$helper, $$draggable);
			}
		});
	},

	_createDragHelper: function($$source) {
		var $$dragSource = authDrag.getClosestDragElement($$source);
		var text;

		// Layout icon
		if ($$dragSource.attr("data-auth-drag-action") === "add_layout") {
			var name = $$dragSource.attr("data-auth-bind");
			text = locale.text("auth.drag." + name);
		} else {
			text = $$dragSource.text();
		}
		var $$helper = $('<div class="s-m-auth-drag-helper"><p id="s-m-auth-drag-helper-label-id">&nbsp;</p><p id="s-m-auth-drag-helper-desc-id">&nbsp;</p><div style="clear:both;"></div></div>');
		$('#s-m-auth-drag-helper-label-id', $$helper).text(text);
		return $$helper[0];
	},
});
});

define('syracuse-tablet/html/js/authoring/authoringPage',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/authoring/authoringDrag'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var authDrag = require('syracuse-tablet/html/js/authoring/authoringDrag');

var _selectedRecord = "s-m-auth-rec-selected";
var $$lastHoverElement;

//Controls and layout classes that cannot be selected during authoring
var _elementsNoAuthoring = [
	".s-m-array .s-m-control",
	".s-m-array .s-m-layout",
	".s-m-control.header",
	".s-m-control.footer",
	".s-m-control.navigationpanel",
	".s-m-control.pageactionpanelregular",
	".s-m-control.breadcrumbs",
	".s-m-control.toolbar",
	".s-m-control.s-m-field > .s-m-value.edit > .s-m-control.s-m-unit", // Disable to select unit control of a quantity field
	".s-m-layout.s-m-hub", // do not allow to select root level hub (hub is always at root level, that's why there is no qualification like for the stack)
	".s-m-main-content > .s-m-scroll-elmt > .s-m-stack", // do not allow to select root level stack
	".s-m-main-content > .s-m-stack" // do not allow to select root level stack
];

exports.AuthPage = utils.defineClass(
	function AuthPage() {
		var self = this;

		self.__onElementClick = self._onElementClick.bind(self);
		self.__onElementMouseOver = self._onElementMouseOver.bind(self);
		self.__onElementMouseOut = self._onElementMouseOut.bind(self);

		self.$$page = $("#s-m-app-id");
	}, null, {

		enable: function() {
			var self = this;
			self._subscribe();
		},

		disable: function() {
			var self = this;
			self._unscribe();
		},

		/*
		 * Enable hover and click events in page
		 */
		enableAuthCss: function() {
			var self = this;
			// !! disableAuthCss is not well managed and if we call enableAuthCss without having called disableAuthCss we add multiple handlers
			// TODO - Review the destroy/disable process
			self.disableAuthCss();
			$(".s-m-control").addClass("s-m-auth");
			$(".s-m-layout").addClass("s-m-auth");
			$(".s-m-layout").addClass("s-m-auth");
			$(".s-m-page").addClass("s-m-auth");
			$("section.s-m-card").addClass("s-m-auth");

			_elementsNoAuthoring.forEach(function(e) {
				$(e).removeClass("s-m-auth");
			});

			$(".s-m-auth", self.$$page).on("click", self.__onElementClick);
			$(".s-m-auth", self.$$page).on("mouseover", self.__onElementMouseOver);
			$(".s-m-auth", self.$$page).on("mouseout", self.__onElementMouseOut);

			self._enableDrop();
		},

		/*
		 * Disable all events in page that were used for authoring interaction
		 */
		disableAuthCss: function() {
			var self = this;
			self._disableDrop();
			var $$smAuth = $(".s-m-auth", self.$$page);
			$$smAuth.off("click", self.__onElementClick);
			$$smAuth.off("mouseover", self.__onElementMouseOver);
			$$smAuth.off("mouseout", self.__onElementMouseOut);
			$$smAuth.removeClass("s-m-auth");
			$(".s-m-record." + _selectedRecord, self.$$page).removeClass(_selectedRecord);
		},

		_subscribe: function() {
			var self = this;
			notifications.subscribe(self, ["sm.auth.hover.in"]);
			notifications.subscribe(self, ["sm.auth.hover.out"]);
			notifications.subscribe(self, ["sm.auth.set.selection"]);
			notifications.subscribe(self, ["sm.auth.remove.selection"]);
		},

		_unscribe: function() {
			var self = this;
			notifications.unsubscribe(self, ["sm.auth.hover.in"]);
			notifications.unsubscribe(self, ["sm.auth.hover.out"]);
			notifications.unsubscribe(self, ["sm.auth.set.selection"]);
			notifications.unsubscribe(self, ["sm.auth.remove.selection"]);
		},

		_enableDrop: function() {
			var self = this;
			var dragParam = {
				scroll: false,
				containment: $("body"),
				tolerance: "pointer",
				helper: function(event) {
					var $$source = $(event.target);
					return self._createDragHelper($$source);
				},
				appendTo: "body",
				revert: function($$drop) {
					return "invalid";
				},
				start: function() {},
				stop: function() {}
			};

			$(".s-m-auth").droppable({
				greedy: false,
				hoverClass: "s-m-auth-hover-droptarget",
				tolerance: "pointer",
				drop: function(event, ui) {
					var $$helper = ui.helper;
					var $$draggable = ui.draggable;
					return authDrag.dropDrop($(this), $$helper, $$draggable);
				},
				accept: function($$draggable) {
					return authDrag.dropAccept($(this), $$draggable);
				},
				over: function(event, ui) {
					var $$helper = ui.helper;
					var $$draggable = ui.draggable;
					return authDrag.dropOver($(this), $$helper, $$draggable);
				},
				out: function(event, ui) {
					var $$helper = ui.helper;
					var $$draggable = ui.draggable;
					return authDrag.dropOut($(this), $$helper, $$draggable);
				}
			});
		},

		_disableDrop: function() {
			$(".s-m-auth.ui-droppable").droppable("destroy");
		},

		_createDragHelper: function($$source) {
			var $$dragSource = authDrag.getClosestDragElement($$source);
			var control = authHelpers.findControl($$dragSource);
			if (!control) {
				return;
			}

			var $$helper = $('<p class="s-m-auth-drag-helper">');
			var text;
			if (control.prototype) {
				// it's a control
				text = control.prototype.data("$title");
				if (text) {
					text = text + "(" + control.$bind + ")";
				} else {
					text = control.$bind;
				}
			} else {
				// it's a layout
				text = control.title;
				if (text) {
					text = text + " (" + control.typeName + ")";
				} else {
					text = control.typeName;
				}
			}
			$$helper.text(text);
			return $$helper[0];
		},

		_onElementClick: function(e) {
			var self = this;
			var $$o = $(e.currentTarget);

			if ($$o.is("section.s-m-card")) {
				$$o.closest("table").find(".s-m-record." + _selectedRecord).removeClass(_selectedRecord);
				$$o.closest(".s-m-record").addClass(_selectedRecord);
				// Select the card - Event bubbles
				return;
			}
			var id = this.getCurrentSelected().removeClass("s-m-auth-selected").attr("id");
			if (id) {
				// synchronous is better
				notifications.publishEx(["synch.sm.auth.remove.selection"], {
					exclude: [self]
				}, id);
			}
			id = $$o.addClass("s-m-auth-selected").attr("id");
			// synchronous is better
			notifications.publishEx(["synch.sm.auth.set.selection"], {
				exclude: [self]
			}, id);
			// Scrolling needs shiftClick and altClick
			if (utils.stopClickEvent(e)) return false;
		},

		_onElementMouseOver: function(e) {
			var self = this;
			var $$o = $(e.currentTarget);
			if ($$lastHoverElement) {
				$$lastHoverElement.removeClass("s-m-auth-hover");
				notifications.publishEx(["sm.auth.hover.out"], {
					exclude: [self]
				}, $$lastHoverElement.attr("id"));
			}
			notifications.publishEx(["sm.auth.hover.in"], {
				exclude: [self]
			}, $$o.attr("id"));
			$$o.addClass("s-m-auth-hover");
			$$lastHoverElement = $$o;
			return false;
		},

		_onElementMouseOut: function(e) {
			var self = this;
			var $$o = $(e.currentTarget);
			$$o.removeClass("s-m-auth-hover");
			notifications.publishEx(["sm.auth.hover.out"], {
				exclude: [self]
			}, $$o.attr("id"));
		},

		notifAuthHoverIn: function(id) {
			var self = this;
			var $$pageItem = self._getItemById(id);
			$$pageItem.addClass("s-m-auth-hover");
		},

		notifAuthHoverOut: function(id) {
			var self = this;
			var $$pageItem = self._getItemById(id);
			$$pageItem.removeClass("s-m-auth-hover");
		},

		notifAuthSetSelection: function(id, noScroll) {
			var self = this;
			var $$item = self._getItemById(id);
			if ($$item && $$item.length > 0) {
				$$item.addClass("s-m-auth-selected");
				if (noScroll !== true) {
					self._scrollToVisibleArea($$item);
				}
			}
		},

		notifAuthRemoveSelection: function(id) {
			var self = this;
			var $$item = self._getItemById(id);
			$$item.removeClass("s-m-auth-selected");
		},

		_getItemById: function(id) {
			return $("#" + id, this.$$page);
		},

		getCurrentSelectionId: function() {
			return this.getCurrentSelected().attr("id");
		},

		getCurrentSelected: function() {
			// :visible because in the case of chartDetail page (child page) we have the parent page hidden
			return $(".s-m-auth-selected:visible", this.$$page);
		},

		_scrollToVisibleArea: function($$item) {
			var self = this;
			var page = globals.getApplication().currentPage;
			var scroller =
				page && page._gestureMgr ||
				page && page.rootLayout && page.rootLayout._gestureMgr;
			if (scroller) {
				scroller.makeVisible($$item);
			}
		}
	});
});

define('syracuse-tablet/html/js/ui/modals/modalChooseDevice',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="form-group s-m-scroll-element"> \
					<div class="list-group" id="modal-device-select-list-id"> \
						{{#each devices}} \
							<a draggable="false" href="#" class="list-group-item" data-action="clickDevice" data-params="{{name}}">{{label}}</a> \
						{{/each}} \
					</div> \
				</div> \
		    </div>',
	footer: ''
};

var _Klass = utils.defineClass(
	function ModalChooseDevice(device) {
		var self = this;
		modalDialog.ModalBase.call(self);
		// Init params
		self.selectedDevice = device;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "config-tile half_right";
			} else {
				displayFlags.modalClass = "config-tile full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			var devices = [];

			var site = globals.getSiteLayout();
			var devs = site.getDeviceTemplates();
			for (var dev in devs) {
				devices.push({
					name: dev,
					label: locale.textOpt("auth.device." + dev + ".title") || dev
				});
			}

			var data = {
				title: locale.text("auth.device.title"),
				devices: devices,
			};

			return data;
		},

		_onShow: function() {
			var self = this;
			modalDialog.ModalBase.prototype._onShow.call(self);
			$('a[data-params="' + self.selectedDevice + '"]').addClass("active");
		},

		// could be removed, result is set in _onAction
		_onValidate: function() {

		},
		_onCancel: function() {
			var self = this;
			self.selectedApps = {};
		},

		_onAction: function(action, param) {
			var self = this;
			if (action === "clickDevice") {
				self.selectedDevice = param;
				return true;
			}
			// dont close on actions
			return false;
		},

		_getResult: function() {
			var self = this;
			return self.selectedDevice;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalNewLayout',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
		<buttons class="pull-right"> \
			<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
			<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
		</buttons> \
		<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="alert alert-warning" role="alert"> \
					{{warning}} \
				</div> \
				<div class="form-group" id="dir"> \
					<label>{{lab_dir}}</label> \
        			<div class="btn-group btn-group-vertical btn-group-justified" data-toggle="buttons"> \
						<label class="btn btn-default {{#if horizontal}}active{{/if}}"> \
							<input type="radio" id="horizontal" name="scroll" value="horizontal" {{#if horizontal}}checked{{/if}}/>{{lab_horizontal}}\
						</label> \
						<label class="btn btn-default {{#unless horizontal}}active{{/unless}}"> \
							<input type="radio" id="vertical" name="scroll" value="vertical" {{#unless horizontal}}checked{{/unless}}/>{{lab_vertical}}\
						</label> \
					</div> \
				</div> \
				<div class="form-group" id="tpl"> \
					<label>{{lab_tpl}}</label> \
					<div class="btn-group btn-group-vertical btn-group-justified" data-toggle="buttons"> \
						<label class="btn btn-default {{#if template}}active{{/if}}"> \
							<input type="radio" id="template" name="empty" value="true" {{#if template}}checked{{/if}}/>{{lab_template}}\
						</label> \
						<label class="btn btn-default {{#unless template}}active{{/unless}}"> \
							<input type="radio" id="empty" name="empty" value="false" {{#unless template}}checked{{/unless}}/>{{lab_empty}}\
						</label> \
					</div> \
				</div> \
			</div>',
	footer: '',
};

var _Klass = utils.defineClass(
	function ModalNewLayout(_defaults) {
		var self = this;
		modalDialog.ModalBase.call(self);

		// Init params
		self._defaults = _defaults;
		// Result
		self.result = null;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "half_right";
			} else {
				displayFlags.modalClass = "full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			var data = {
				label_validate: locale.text("modal.ok"),
				label_cancel: locale.text("modal.cancel"),
				title: locale.text("modal.newlayout.title"),

				warning: locale.text("modal.newLayout.warning"),
				lab_horizontal: locale.text("modal.newLayout.horizontal"),
				lab_vertical: locale.text("modal.newLayout.vertical"),
				lab_template: locale.text("modal.newLayout.template"),
				lab_empty: locale.text("modal.newLayout.empty"),
				lab_dir: locale.text("modal.newLayout.dir"),
				lab_tpl: locale.text("modal.newLayout.tpl"),

				horizontal: self._defaults.scroll === "horizontal",
				template: self._defaults.template
			};

			return data;
		},

		_onValidate: function() {
			var self = this;
			var dir = self.$$elmt.find('#dir label.active input').val();
			var tpl = self.$$elmt.find('#tpl label.active input').val();

			self.result = {
				scroll: dir,
				template: tpl === "true"
			};
		},
		_onCancel: function() {
			var self = this;
			self.result = null;
		},

		_getResult: function() {
			var self = this;
			return self.result;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/authoring/authoringHeader',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/modals/modalChooseDevice','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/ui/modals/modalNewLayout'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var modalChooseDevice = require('syracuse-tablet/html/js/ui/modals/modalChooseDevice');
var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var modalNewLayout = require('syracuse-tablet/html/js/ui/modals/modalNewLayout');

exports.Panel = utils.defineClass(function AuthoringPanelHeader() {
	var self = this;
	self.$$panel = null;
}, null, {

	show: function() {
		var self = this;
		self._ensurePanel();
		self._subscribe();
		self.$$panel.show();
		self._initDefaults();
	},
	hide: function() {
		var self = this;
		self._ensurePanel();
		self.$$panel.hide();
		self._unscribe();
	},

	_ensurePanel: function() {
		var self = this;
		if (this.$$panel) {
			return;
		}
		var ctx = {
			label_settings: locale.text("auth.device.settings"),
			label_save: locale.text("auth.panel.label_save"),
			label_remove: locale.text("auth.panel.label_remove"),
			label_remove_container: locale.text("auth.panel.label_remove_container"),
			label_remove_all: locale.text("auth.panel.label_remove_all"),
			label_new_layout: locale.text("auth.panel.label_new_layout"),
			label_preview_portrait: locale.text("auth.panel.label_preview_portrait"),
			label_preview_landscape: locale.text("auth.panel.label_preview_landscape"),
			label_scale_to_fit: locale.text("auth.panel.label_scale_to_fit"),
			label_undo: locale.text("auth.label_undo"),
			label_undo_all: locale.text("auth.label_undo_all"),
		};

		self.$$panel = $("#s-m-auth-panel-header-id");
		self.$$panel.append($(authHtml.execute("authPanelHeader", ctx)));
		self._getDomObjects();
		self._initDomEvents();
	},

	_getDomObjects: function() {
		var self = this;
		self.$$orientation = $("#s-m-auth-orientation-id", self.$$panel);
		self.$$removeItem = $("#s-m-auth-remove-id", self.$$panel);
		self.$$removeCnt = $("#s-m-auth-remove-cnt-id", self.$$panel);
		self.$$removeAllItems = $("#s-m-auth-remove-all-id", self.$$panel);
		self.$$newLayout = $("#s-m-auth-new-layout-id", self.$$panel);
		self.$$undo = $("#auth-btn-undo-id", self.$$panel);
		self.$$undoAll = $("#auth-btn-undo-all-id", self.$$panel);
	},

	_initDomEvents: function() {
		var self = this;

		// preview options
		$("#s-m-auth-settings-id").on("click", self._onChooseDevice.bind(self));
		$("#s-m-auth-scale-id").on("click", self._onScaleDevice.bind(self));
		$("#s-m-auth-vertical-id").on("click", self._onOrientation.bind(self));
		$("#s-m-auth-horizontal-id").on("click", self._onOrientation.bind(self));
		// Delete
		self.$$removeItem.on("click", self._onRemoveItem.bind(self));
		self.$$removeCnt.on("click", self._onRemoveCnt.bind(self));
		self.$$removeAllItems.on("click", self._onRemoveAllItems.bind(self));
		self.$$newLayout.on("click", self._onNewLayout.bind(self));
		self.$$undo.on("click", self._onUndo.bind(self));
		self.$$undoAll.on("click", self._onUndoAll.bind(self));
		// save/close
		$("#auth-btn-save-id").on("click", self._onSave.bind(self));
		$("#auth-btn-close-id").on("click", self._onClose.bind(self));
	},

	_initDefaults: function() {
		var self = this;
	},

	_subscribe: function() {
		var self = this;
		notifications.subscribe(self, ["sm.main.layout.changed"]);
		notifications.subscribe(self, ["sm.auth.set.selection"]);
		notifications.subscribe(self, ["sm.auth.change.prop.ui"]);
		notifications.subscribe(self, ["sm.auth.history.change"]);
	},

	_unscribe: function() {
		var self = this;
		notifications.unsubscribe(self, ["sm.main.layout.changed"]);
		notifications.unsubscribe(self, ["sm.auth.set.selection"]);
		notifications.unsubscribe(self, ["sm.auth.change.prop.ui"]);
		notifications.unsubscribe(self, ["sm.auth.history.change"]);
	},

	notifMainLayoutChanged: function() {
		var self = this;
		var site = globals.getSiteLayout();
		var cur = site.getCurrentLayoutSettings();

		if (cur.pageParameters.forceAutoScale === true) {
			$("#s-m-auth-scale-id").addClass('active');
		} else {
			$("#s-m-auth-scale-id").removeClass('active');
		}
		if (cur.pageParameters.orientation === "landscape") {
			$("#s-m-auth-horizontal-id").addClass('active');
			$("#s-m-auth-vertical-id").removeClass('active');
		} else {
			$("#s-m-auth-horizontal-id").removeClass('active');
			$("#s-m-auth-vertical-id").addClass('active');
		}

	},

	// Called by panel if a property like color has been changed using the simple ui
	notifAuthChangePropUi: function(articlePage) {
		var self = this;
	},

	notifAuthSetSelection: function(id) {
		var self = this;
		self._currentSelectionId = id;
		self._enableRemoveBtn();
	},

	notifAuthHistoryChange: function(pageHistory) {
		var self = this;
		if (pageHistory.length > 0) {
			self.$$undo.removeClass("disabled");
			self.$$undoAll.removeClass("disabled");
		} else {
			self.$$undo.addClass("disabled");
			self.$$undoAll.addClass("disabled");
		}
	},

	_enableRemoveBtn: function() {
		var self = this;
		var stateRemove = false;
		var stateRemoveCnt = false;
		var sel, data, parent;

		if (self._currentSelectionId) {
			sel = authHelpers.getSelectionById(self._currentSelectionId);
			data = sel && authHelpers.getSelectionData(sel);
			if (!data || !data.control) {
				stateRemove = false;
			} else {
				stateRemove = true;
			}
		}

		if (data && data.control && data.control) {
			if (data.control.isRoot()) { // Never allow to remove root layout node, in page and/or in vignette
				stateRemove = false;
			}

			if (data.control.isLayout()) {
				stateRemoveCnt = true;
			}
		}

		if (stateRemove !== false) {
			self.$$removeItem.removeClass("disabled");
		} else {
			self.$$removeItem.addClass("disabled");
		}
		if (stateRemoveCnt !== false) {
			self.$$removeCnt.removeClass("disabled");
		} else {
			self.$$removeCnt.addClass("disabled");
		}
	},
	_setDeviceSize: function(size, orientation) {
		var params = {
			layout: {
				pageParameters: {}
			}
		};

		if (size) {
			params.layout.pageParameters.device = size;
		}
		if (orientation) {
			params.layout.pageParameters.orientation = orientation;
		}
		// To manage the deviceChanged	and set the device type in page root element that drives css
		params.layout.pageParameters.forcePreview = true;
		authHelpers.triggerResizeInternal(params);
	},

	_onRemoveItem: function() {
		if (!this._currentSelectionId) {
			return;
		}
		var sel = authHelpers.getSelectionById(this._currentSelectionId);
		var data = sel && authHelpers.getSelectionData(sel);
		if (!data || !data.control || data.control.isRoot()) {
			return;
		}
		this._enableRemoveBtn(false);
		// Change widget tree
		data.control.parent.removeChild(data.control);
		notifications.publish(["sm.auth.change.item.prop.ui"]);
	},

	_onRemoveCnt: function() {
		if (!this._currentSelectionId) {
			return;
		}
		var sel = authHelpers.getSelectionById(this._currentSelectionId);
		var data = sel && authHelpers.getSelectionData(sel);
		if (!data || !data.control) {
			return;
		}

		data.control.removeChildren();
		notifications.publish(["sm.auth.change.item.prop.ui"]);
	},

	_onRemoveAllItems: function() {
		// Rebuild and apply new article
		var page = globals.getApplication().currentPage;
		page.rootLayout.removeChildren();
		notifications.publish(["sm.auth.change.item.prop.ui"]);
	},

	_onClose: function() {
		notifications.publish(["sm.auth.close"]);
	},

	_onSave: function(evt) {
		notifications.publish(["sm.auth.save"], $("#auth-btn-save-id").attr("data-save-type"));
	},

	_onChooseDevice: function(elmt) {
		var self = this;
		var site = globals.getSiteLayout();
		var cur = site.getCurrentLayoutSettings();

		var modal = new modalChooseDevice.Modal(cur.pageParameters.device);
		modal.show().then(function(result) {
			if (result != null) {
				self._setDeviceSize(result);
				notifications.publish(["sm.auth.display.changed"], "device");
			}
		});
	},

	_onScaleDevice: function(elmt) {
		var site = globals.getSiteLayout();
		var cur = site.getCurrentLayoutSettings();

		var params = {
			layout: {
				pageParameters: {
					forceAutoScale: cur.pageParameters.forceAutoScale === false
				}
			}
		};
		authHelpers.triggerResizeInternal(params);
		notifications.publish(["sm.auth.display.changed"], "scale");
	},

	_onOrientation: function(elmt) {
		var self = this;
		var orient = $(elmt.currentTarget).attr("data-auth-orientation");
		if (orient) {
			self._setDeviceSize(null, orient);
			notifications.publish(["sm.auth.display.changed"], "orientation");
		}
	},

	_onNewLayout: function() {
		var self = this;

		var page = globals.getApplication().currentPage;
		var data = {
			scroll: jsutils.isInstanceOf(page, "DashboardPage") ? "horizontal" : "vertical",
			template: true
		};
		var modal = new modalNewLayout.Modal(data);
		modal.show().then(function(result) {
			if (result != null) {
				notifications.publish(["sm.auth.new.layout"], result.scroll, result.template);
			}
		});
	},

	_onUndo: function() {
		notifications.publish(["sm.auth.undo"], false);
	},

	_onUndoAll: function() {
		notifications.publish(["sm.auth.undo"], true);
	}
});
});

define('syracuse-tablet/html/js/authoring/authoringFooter',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/authoring/authoringHtml'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');

exports.Panel = utils.defineClass(function AuthoringPanelFooter() {
	var self = this;
	self.$$panel = null;
}, null, {
	show: function() {
		var self = this;

		self._ensurePanel();
		self._subscribe();

		self.$$panel.show();

		self._initDefaults();
	},
	hide: function() {
		var self = this;
		self._ensurePanel();
		self.$$panel.hide();

		self._unscribe();
	},

	_ensurePanel: function() {
		var self = this;
		if (this.$$panel) {
			return;
		}

		var ctx = {};

		self.$$panel = $("#s-m-auth-panel-footer-id");
		self.$$panel.append($(authHtml.execute("authPanelFooter", ctx)));

		self._getDomObjects();
		self._initDomEvents();
	},

	_getDomObjects: function() {
		var self = this;
	},

	_initDomEvents: function() {
		var self = this;
	},

	_initDefaults: function() {
		var self = this;
	},

	_subscribe: function() {
		var self = this;
		notifications.subscribe(self, ["sm.main.layout.changed"]);
		notifications.subscribe(self, ["sm.auth.set.selection"]);
		notifications.subscribe(self, ["sm.auth.change.prop.ui"]);
	},

	_unscribe: function() {
		var self = this;
		notifications.unsubscribe(self, ["sm.main.layout.changed"]);
		notifications.unsubscribe(self, ["sm.auth.set.selection"]);
		notifications.unsubscribe(self, ["sm.auth.change.prop.ui"]);
	},

	notifMainLayoutChanged: function() {
		var self = this;
	},

	// Called by panel if a property like color has been changed using the simple ui
	notifAuthChangePropUi: function(articlePage) {
		var self = this;
	},

	notifAuthSetSelection: function(id) {
		var self = this;
	}
});
});

define('syracuse-tablet/html/js/ui/modals/modalSaveAuth',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
			<div class="s-m-scroll-element"> \
		 		{{#each fields}}\
				<div class="form-group"> \
					<label>{{label}}</label> \
					<input class="{{css}} form-control" id="{{id}}" type="text" value="{{value}}" {{readonly}}/> \
				</div> \
				{{/each}}\
				<label id="saveType" params="{{saveType}}" >{{label_save_type}}</label> \
				<div class="btn-group btn-group-justified" data-toggle="buttons"> \
			   {{#each buttons}}\
					<div class="btn-group"> \
					<label class="{{css}} btn btn-primary {{active}}" data-action="clickType" data-params="{{id}}"  >\
					<input type="radio"  name="options" id="{{id}}" {{checked}}>{{label}} \
					</label>\
					</div>\
				{{/each}}\
				</div> \
			</div> \
			</div>',
	footer: ''
};

var _Klass = utils.defineClass(
	function ModalSaveAuth(saveContext) {
		var self = this;
		modalDialog.ModalBase.call(self);

		self.saveContext = saveContext;

		// Result
		self.result = null;
	}, modalDialog.ModalBase, {
		destroy: function() {
			$("input.evt-input", this.$$elmt).off();
			modalDialog.ModalBase.prototype.destroy.call(this);
		},
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},
		/**
		 * Always Half-right because only on desktop
		 */
		getDisplayFlags: function() {
			var displayFlags = this.displayFlags || {};
			displayFlags.modalClass = "config-tile half_right";
			return displayFlags;
		},
		_getDataContext: function() {
			var self = this;
			self.currentVariant = self.saveContext.variants.find(function(variant) {
				return variant.isSelected;
			}) || {};
			self.currentVariant.comment = self.currentVariant.comment || self.saveContext.comment;
			var readonly = "readonly";
			var data = {
				title: locale.text("auth.save.title"),
				page: self.saveContext.pageName,
				fields: [{
					id: "authCode",
					label: locale.text("auth.panel.label_code"),
					value: self.currentVariant.code,
					readonly: readonly,
					css: "evt-input"
				}, {
					id: "authTitle",
					label: locale.text("auth.panel.label_title"),
					value: self.currentVariant.title,
					readonly: readonly,
					css: "evt-input"
				}, {
					id: "authDescription",
					label: locale.text("auth.panel.label_description"),
					value: self.currentVariant.description,
					readonly: readonly,
					css: "evt-input"
				}, {
					id: "authComment",
					label: locale.text("auth.panel.label_comment"),
					value: self.currentVariant.comment || self.saveContext.comment,
				}],
				saveType: "save",
				label_save_type: locale.text("auth.panel.label_save"),

				buttons: [{
					id: "personal_copy",
					label: locale.text("auth.panel.label_personal"),
					active: (self.currentVariant.isPersonal && self._isPersonelVariantAutorized()) ? "active" : "",
					css: (!self._isPersonelVariantAutorized()) ? "disabled" : ""
				}, {
					id: "global_variant",
					label: locale.text("auth.panel.label_global"),
					active: (self.currentVariant.isGlobal && self._isGlobalVariantAutorized()) ? "active" : "",
					css: (!self._isGlobalVariantAutorized()) ? "disabled" : ""
				}, {
					id: "factory_variant",
					label: locale.text("auth.panel.label_factory"),
					active: (self.currentVariant.isFactory && self._canUpdateFactory(self.currentVariant)) ? "active" : "",
					css: (!self._canManageFactory()) ? "disabled" : ""
				}, ]
			};
			return data;
		},
		_canUpdateFactory: function(variant) {
			return (this._canManageFactory() && (this.saveContext.securityProfile.factoryId === variant.factoryOwner));
		},
		_canManageFactory: function() {
			return (this.saveContext.securityProfile.factoryId != "" && this._isGlobalVariantAutorized());
		},
		_isGlobalVariantAutorized: function() {
			return this.saveContext.securityProfile.personalizationLevel === "admin";
		},
		_isPersonelVariantAutorized: function() {
			return this.saveContext.securityProfile.personalizationLevel === "admin" || this.saveContext.securityProfile.personalizationLevel === "user";
		},
		_onShow: function(evt) {
			var self = this;
			modalDialog.ModalBase.prototype._onShow.call(this, evt);
			//this.$$element.on('click', 'input[type="checkbox"]', jsutils.bindFn(this._onInput, this));
			$("input.evt-input", self.$$elmt).on("input", self._onInput.bind(self));
			self._refreshBtnValidate();
		},
		_onAction: function(action, param) {
			if (action !== "clickType") return false;
			var self = this;
			var ctxUI = {};
			var create = false;
			switch (param) {
				case "factory_variant":
					if (self._canManageFactory()) {
						self.currentVariant = self.saveContext.variants.find(function(variant) {
							return variant.isFactory && variant.factoryOwner === self.saveContext.securityProfile.factoryId;
						});
						if (!self.currentVariant) {
							create = true;
							self.currentVariant = {
								isFactory: true,
								code: this.saveContext.securityProfile.factoryId,
								title: this.saveContext.securityProfile.factoryId,
								description: this.saveContext.securityProfile.factoryId,
								factoryOwner: this.saveContext.securityProfile.factoryId,
								comment: "",
							};
						}
					};
					break;
				case "global_variant":
					self.currentVariant = self.saveContext.variants.find(function(variant) {
						return variant.isGlobal;
					});
					if (!self.currentVariant) {
						create = true;
						this.currentVariant = {
							isGlobal: true,
							code: "GLOBAL",
							title: "GLOBAL",
							description: "GLOBAL",
							comment: "",
						};
					}
					break;
				case "personal_copy":
					self.currentVariant = self.saveContext.variants.find(function(variant) {
						return variant.isPersonal;
					});
					if (!self.currentVariant) {
						create = true;
						this.currentVariant = {
							isPersonal: true,
							code: "PERSONAL",
							title: "PERSONAL",
							description: "PERSONAL",
							comment: "",
						};
					}
					break;
			};
			$("label[data-params='" + param + "']", self.$$elmt).eq(0).button("toggle");
			if (create) {
				var UI = {
					saveType: "saveAs",
					label_save_type: locale.text("auth.panel.label_saveas_option"),
				};
			} else {
				var UI = {
					saveType: "save",
					label_save_type: locale.text("auth.panel.label_save"),
				};
			}
			UI.fields = [{
				id: "authCode",
				value: self.currentVariant.code,
				readonly: !create
			}, {
				id: "authTitle",
				value: self.currentVariant.title,
				readonly: !create
			}, {
				id: "authDescription",
				value: self.currentVariant.description,
				readonly: !create
			}, {
				id: "authComment",
				value: self.currentVariant.comment,
				readonly: false
			}];
			self._changeUI(UI);
			return false;
		},
		_changeUI: function(ctx) {
			var self = this;
			var $$saveType = self.$$elmt.find("#saveType");
			$$saveType.attr("params", ctx.saveType);
			$$saveType.text(ctx.label_save_type);
			var field;
			ctx.fields.forEach(function(item) {
				field = self.$$elmt.find("#" + item.id);
				field.val(item.value);
				if (item.readonly) {
					field.attr("readonly", "readonly");
				} else {
					field.removeAttr("readonly");
				}
			});
			this._refreshBtnValidate(true);
		},
		_onValidate: function() {
			var self = this;
			self.result = {
				code: self.$$elmt.find("#authCode").val(),
				title: self.$$elmt.find("#authTitle").val(),
				description: self.$$elmt.find("#authDescription").val(),
				comment: self.$$elmt.find("#authComment").val(),
				variantType: $("label[data-action='clickType'].active", self.$$elmt).attr("data-params"),
				uuid: self.currentVariant.uuid
			};
		},
		_onCancel: function() {
			var self = this;
			self.result = null;
		},
		/**
		 * Manages create button status
		 */
		_onInput: function(evt) {
			this._refreshBtnValidate();
		},
		_refreshBtnValidate: function(focus) {
			var disabled = false,
				$$field;
			disabled = (!$("label[data-action='clickType'].active", this.$$elmt).attr("data-params"));
			if (!disabled) {
				$$field = this.$$elmt.find("#authCode");
				if (!(disabled = ($$field.val().trim().length <= 0))) {
					$$field = this.$$elmt.find("#authTitle");
					if (!(disabled = ($$field.val().trim().length <= 0))) {
						$$field = this.$$elmt.find("#authDescription");
						disabled = ($$field.val().trim().length <= 0);
					}
				}
			}
			if (focus && disabled && $$field) $$field.focus();
			$("button[data-action='$validate']").toggleClass("disabled", disabled);
		},
		_getResult: function() {
			var self = this;
			return self.result;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/authoring/authoring',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/authoring/authoringPanelRight','syracuse-tablet/html/js/authoring/authoringPanelLeft','syracuse-tablet/html/js/authoring/authoringPage','syracuse-tablet/html/js/authoring/authoringHeader','syracuse-tablet/html/js/authoring/authoringFooter','syracuse-tablet/html/js/authoring/authoringArticleGen','syracuse-tablet/html/js/authoring/authoringVal','syracuse-tablet/html/js/ui/modals/modalSaveAuth','syracuse-tablet/html/js/application/eventListener','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/authoring/authoringProperties','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var authoringPanelRight = require('syracuse-tablet/html/js/authoring/authoringPanelRight');
var authoringPanelLeft = require('syracuse-tablet/html/js/authoring/authoringPanelLeft');
var authoringPage = require('syracuse-tablet/html/js/authoring/authoringPage');
var authoringHeader = require('syracuse-tablet/html/js/authoring/authoringHeader');
var authoringFooter = require('syracuse-tablet/html/js/authoring/authoringFooter');
var authoringArticleGen = require('syracuse-tablet/html/js/authoring/authoringArticleGen');
var authVal = require('syracuse-tablet/html/js/authoring/authoringVal');
var modalSaveAuth = require('syracuse-tablet/html/js/ui/modals/modalSaveAuth');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var authProps = require('syracuse-tablet/html/js/authoring/authoringProperties');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _authInterface;

var _authEvents = ["sm.page.loaded", "sm.auth.change.item.prop.ui", "sm.auth.change.prop.ui", "sm.auth.close", "sm.auth.save", "sm.auth.new.layout", "sm.auth.set.page", "sm.auth.display.changed", "sm.auth.undo"];
/*
 * This module glues together the action done in the page and the two panels
 */

exports.toggleDesignPage = function() {
	if (!_authInterface) {
		_authInterface = new AuthInterface();
	}

	_authInterface.toggleDesignPage();
};
exports.isEnabled = function() {
	return _authInterface && _authInterface.isActive;
};
/**
 * Returns true if back process can continue
 */
exports.checkBack = function() {
	if (!exports.isEnabled()) return true;
	return _authInterface.checkBack();
};
// Called on unload event - application.onUnload
exports.destroy = function() {
	if (!_authInterface) return;
	_authInterface.destroy();
	_authInterface = null;
};
var AuthInterface = utils.defineClass(function AuthoringInterface() {
	var self = this;
	self.$$authPanel = null;
	self.isActive = false;

	self.undoPageHistory = {};
	self.isDirty = false // True if not all changes are saved yet, used by close button;

	/*
	 * Right panel interaction
	 */
	self.rightPanel = new authoringPanelRight.Panel();

	/*
	 * Left panel interaction
	 */
	self.leftPanel = new authoringPanelLeft.Panel();

	/*
	 * Header
	 */
	self.headerPanel = new authoringHeader.Panel();

	/*
	 * Footer
	 */
	self.footerPanel = new authoringFooter.Panel();

	/*
	 * Page interaction
	 */
	self.authPage = new authoringPage.AuthPage();

	authProps.initProperties(authHelpers);
	authVal.setProperties(authProps);
}, null, {

	destroy: function() {
		var self = this;
		// TODO - improve destroy
		["rightPanel", "leftPanel", "headerPanel", "authPage"].forEach(function(p) {
			if (self[p] && self[p].destroy) {
				self[p].destroy();
			}
			self[p] = null;
		});
	},

	toggleDesignPage: function(forceStatus) {
		if (this.isActive || forceStatus === false) {
			this.disable();
		} else {
			this.enable();
		}
	},

	enable: function() {
		var self = this;

		self._subscribe();

		self.authPage.enable();
		self.rightPanel.show();
		self.leftPanel.show();
		self.headerPanel.show();
		self.footerPanel.show();

		var page = globals.getApplication().currentPage;
		authHelpers.getPageVariants(page.state.authoringName).then(function(variants) {
			page.variants = variants;
			notifications.publish(["sm.auth.set.page"], page);
			authHelpers.triggerResizeInternal({
				preserveScroll: true,
				layout: {
					authPanelLeft: {
						visible: true
					},
					authPanelRight: {
						visible: true
					},
					authPanelHeader: {
						visible: true
					},
					authPanelFooter: {
						visible: true
					},
					pageParameters: {
						forcePreview: true
					}
				}
			});

			self.authPage.enableAuthCss();

			self.isActive = true;
			self.isDirty = false;
			globals.setAuthoringActive(true);
		});
	},

	disable: function() {
		var self = this;

		self.authPage.disable();
		self.rightPanel.hide();
		self.leftPanel.hide();
		self.headerPanel.hide();
		self.footerPanel.hide();
		self.isActive = false;

		self.authPage.disableAuthCss();

		authHelpers.triggerResizeInternal({
			preserveScroll: true,
			layout: {
				authPanelLeft: {
					visible: false
				},
				authPanelRight: {
					visible: false
				},
				authPanelHeader: {
					visible: false
				},
				authPanelFooter: {
					visible: false
				},
				pageParameters: {
					forcePreview: false
				}
			}
		});
		self.isActive = false;
		self._unscribe();
		globals.setAuthoringActive(false);
	},

	_subscribe: function() {
		notifications.subscribe(this, _authEvents);
	},

	_unscribe: function() {
		notifications.unsubscribe(this, _authEvents);
	},

	notifPageLoaded: function(page) {
		var self = this;
		if (!self.isActive) {
			return;
		}

		if (page && page.state && page.state.disableAuthoring) {
			self.authPage.disableAuthCss();
			self.toggleDesignPage();
			return;
		}

		if (page && !page.isVignette) {
			notifications.publish(["sm.auth.set.page"], page);
		}
		self.authPage.enableAuthCss();
	},

	notifAuthSetPage: function(page) {
		var self = this;
		var parentAuthoringName = self.currentPageName;
		self.currentPageName = page.state.authoringName;
		self.currentPageFullName = page.state.name;

		// Copy of article before we start changing it
		self.displayedArticle = JSON.stringify(page.article);
		// init history on page change
		if (!self.undoPageHistory[self.currentPageName]) {
			self.undoPageHistory[self.currentPageName] = {
				parentPageName: parentAuthoringName,
				articles: []
			};
		}
		notifications.publish(["sm.auth.history.change"], self.undoPageHistory[self.currentPageName].articles);
	},

	// Called if a new article is to be applied on the page by a user interaction
	// Here, we need to put the previous article in the undo buffer
	notifAuthChangePropUi: function(articlePage, states, vignetteToUpdt) {
		var self = this;

		if (self.displayedArticle != null) {
			self.isDirty = true; // As soon as we put something into the undo history, we got dirty changes we need to save
			self.undoPageHistory[self.currentPageName].articles.push(self.displayedArticle);
			notifications.publish(["sm.auth.history.change"], self.undoPageHistory[self.currentPageName].articles);
			self.displayedArticle = null;
		}
		self._updateLayoutPage(articlePage, states, vignetteToUpdt);
	},

	// Called by panels if something has changed to trigger a repaint of the page content and also reinitialize the panels
	notifAuthChangeItemPropUi: function(data) {
		var self = this;
		var page = globals.getApplication().currentPage;
		var states = {};
		var articleJSON = authHelpers.rebuildArticleByPageStruct(page, states);
		var vignetteToUpdt = null;
		if (data && data.control && data.control.controller) {
			vignetteToUpdt = data.control.controller.getParentVignette();
		}
		notifications.publish(["sm.auth.change.prop.ui"], articleJSON, states, vignetteToUpdt);
	},

	notifAuthClose: function(articlePage) {
		var self = this;
		var pageType = globals.getApplication().currentPage.state.type;
		if (pageType === "carddesign" || pageType === "chartdetail") {
			self._authGoBackAuthoring(articlePage);
		} else {
			self._authCloseAuthoring(articlePage);
		}
	},
	_authCloseAuthoring: function(articlePage) {
		var self = this;
		var _end = function() {
			self.undoPageHistory = {};
			notifications.publish(["sm.auth.history.change"], []);
			self.disable();
		};
		if (self.isDirty === true) {
			modal.simpleConfirmPromise({
				message: locale.text("auth.msg.close")
			})
				.then(function(result) {
					if (result.action === "yes") {
						_end();
					}
				});
		} else {
			_end();
		}
	},
	_authGoBackAuthoring: function(articlePage) {
		// No close authoring - Just back to previous page - TODO Improve to reselect the control in main page
		var self = this;
		if (this._isArticleChange(this.displayedArticle)) {
			modal.simpleConfirmPromise({
				message: locale.text("auth.msg.close")
			})
				.then(function(result) {
					if (result.action === "yes") {
						var article = self.undoPageHistory[self.currentPageName].articles.shift();
						self.undoPageHistory[self.currentPageName].articles = [];
						notifications.publish(["sm.auth.history.change"], self.undoPageHistory[self.currentPageName].articles);
						notifications.publishEx(["sm.auth.change.prop.ui"], {
							exclude: [self]
						}, article);
						globals.getApplication().goBack();
					}
				});
		} else {
			globals.getApplication().goBack();
		}
	},
	/**
	 * When we change orientation, device, scale
	 * type = orientation, device, scale
	 */
	notifAuthDisplayChanged: function(type) {
		// We need to remove current selection
		// Indeed, sometimes authoring depends on the type of device or orientation
		// We remove the current selection in order to recreate it on click with new context
		// Ex: query filters are forced to tabs' for smartphone so we must not display property 'Filters' for $resources if device= smartphone
		this.leftPanel.setSelection(null);
	},


	notifAuthSave: function(typeSave) {
		var self = this;
		if (typeSave) {
			if (this._isArticleChange(this.displayedArticle)) {
				self.undoPageHistory[self.currentPageName].articles = [];
				var parentPageName = self.undoPageHistory[self.currentPageName].parentPageName;
				if (parentPageName) {
					notifications.publish(["sm.auth.history.change"], self.undoPageHistory[parentPageName].articles);
				}
			}
			// saveCardDesign / saveChartDetail
			eventListener.triggerAction(globals.getApplication().currentPage.$$elmt, typeSave);
			return;
		}
		var article = self.rightPanel.getPageArticle();
		var articleParsed = authVal.validateJSON(true, article, authProps.getAllProperties());
		if (!articleParsed) {
			return;
		}
		var propertiesVariantSelected = authHelpers.getPropertiesCurrentVariant(self.rightPanel.getPage());
		var comment = articleParsed && articleParsed.$comment;
		var context = {
			code: propertiesVariantSelected.code || locale.text("auth.panel.authCodeDefault"),
			title: propertiesVariantSelected.title || locale.text("auth.panel.authTitleDefault"),
			description: propertiesVariantSelected.description || locale.text("auth.panel.authDescriptionDefault"),
			isFactory: propertiesVariantSelected.isFactory,
			isGlobal: propertiesVariantSelected.isGlobal,
			isPersonal: propertiesVariantSelected.isPersonal,
			factoryOwner: propertiesVariantSelected.factoryOwner,
			securityProfile: globals.getSecurityProfile(),
			uuid: propertiesVariantSelected.uuid,
			comment: propertiesVariantSelected.comment || comment,
			variants: authHelpers.getPropertiesVariants(self.rightPanel.getPage()),
		};
		context.pageName = self.currentPageName;
		var modal = new modalSaveAuth.Modal(context);
		var canceled = false;
		var modalCtx;
		modal.show()
			.then(function(ctx) {
				modalCtx = ctx;
				canceled = modalCtx == null;
				if (canceled) return;
				articleParsed.$comment = ctx.comment;
				var params = {
					code: ctx.code,
					title: ctx.title,
					description: ctx.description,
					variantType: ctx.variantType,
					uuid: ctx.uuid,
					article: articleParsed
				};
				params.article = utils.sanitizeArticle(params.article);
				return authHelpers.saveAuthoring(self.currentPageName, params);
			}).then(function(newView) {
				if (canceled) return;
				if (!modalCtx.uuid) { //refresh right panel because of new view
					self.rightPanel.notifAuthSetSelection();
				}
				self.isDirty = false;
				var opt = {
					"articleParsed": articleParsed,
					"view": newView
				};
				// Update application metaData to avoid the reloading of the page - currentPageFullName != currentPageName (authoringName)
				return globals.getMetaData().updatePageAuthoring(self.currentPageFullName, opt);
			}).then(function() {
				if (canceled) return;
				globals.getModal().info(locale.text("auth.panel.save_ok_title"), locale.text("auth.panel.save_ok_text"));
			}).fail(function(e) {
				globals.getModal().error(locale.text("auth.panel.save_error_title"), e);
			});
	},
	notifAuthNewLayout: function(type, template) {
		var page = globals.getApplication().currentPage;
		authoringArticleGen.genNewArticle({
			page: page,
			orientation: type,
			template: template
		})
			.then(function(article) {
				var articleJSON = authVal.toSortedJSON(article);
				notifications.publish(["sm.auth.change.prop.ui"], articleJSON);
			})
			.fail(function(e) {
				modal.error(e);
			});
	},
	notifAuthUndo: function(all) {
		var self = this;
		var article;
		if (all) {
			article = self.undoPageHistory[self.currentPageName].articles.shift();
			self.undoPageHistory[self.currentPageName].articles = [];
		} else {
			article = self.undoPageHistory[self.currentPageName].articles.pop();
		}

		notifications.publish(["sm.auth.history.change"], self.undoPageHistory[self.currentPageName].articles);
		notifications.publishEx(["sm.auth.change.prop.ui"], {
			exclude: [self]
		}, article);

		self._updateLayoutPage(article);
	},
	/**
	 * vignetteToUpdt!=null means just reload this vignette  - see pageDashboard.authUpdateLayout
	 */
	_updateLayoutPage: function(articlePage, states, vignetteToUpdt) {
		var self = this;
		var page = globals.getApplication().currentPage;
		try {
			var articleParsed = JSON.parse(articlePage);
		} catch (e) {
			// Never end up here because validated before
		}
		if (!articleParsed) {
			return;
		}

		var path = self._findSelectionPath();

		authHelpers.savePanelStates();

		// Copy of article before we start changing it once again
		self.displayedArticle = articlePage;
		self.authPage.disableAuthCss();
		page.authUpdateLayout(articleParsed, vignetteToUpdt)
			.then(function() {
				self.authPage.enableAuthCss();
				if (states) {
					self._applyPreviousStates(states);
				}
				self._selectByPath(path);
			});

	},
	_applyPreviousStates: function(states) {
		var self = this;
		var page = globals.getApplication().currentPage;
		for (var statePath in states) {
			statePath = statePath.length > 0 ? statePath.split(".") : [];
			var node = page.rootLayout.findChildByPath(statePath);
			if (node) {
				node.setAuthState(states[statePath]);
			}
		}
	},
	/**
	 * returns $$currentpage$$ if root page elmt is selected
	 */
	_findSelectionPath: function() {
		var id = this.authPage.getCurrentSelectionId();
		if (id === globals.getApplication().currentPage.id) {
			return "$$currentpage$$";
		}
		var sel = id && authHelpers.getSelectionById(id);
		var data = sel && authHelpers.getSelectionData(sel);
		if (!data || !data.control) {
			return null;
		}
		var path = data.control.getPathInTree();
		return path;
	},

	_selectByPath: function(path) {
		var page = globals.getApplication().currentPage;
		if (!path || !page) {
			return;
		}
		if (path === "$$currentpage$$") {
			path = page.id;
		} else {
			var node = page.rootLayout.findChildByPath(path);
			path = node ? node.id : null;
		}
		if (path) {
			notifications.publishEx(["sm.auth.set.selection"], {
				exclude: [this]
			}, path);
		}
	},
	_isArticleChange: function(articleBefore) {
		//Be careful : article is a string of json 
		//			   Only for carddesign and chartdetail
		var article = JSON.stringify(globals.getApplication().currentPage.article);
		return (articleBefore !== article);
	},
	checkBack: function() {
		var pageType = globals.getApplication().currentPage.state.type;
		if (pageType === "carddesign" || pageType === "chartdetail") {
			return true;
		}
		notifications.publish(["sm.auth.close"]);
		return false;
	}
});
});

define('syracuse-tablet/html/js/ui/developmentPage',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/storage/localStorage'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var localStorage = require('syracuse-tablet/html/js/storage/localStorage');

var _template = '\
	<div id="page_dev_mode" style="margin: 0; width: auto; position: absolute; z-index: 9999"> \
    <div class="modal-dialog" style="margin: 0; width: auto;"> \
		<div class="modal-content" style="width: 230px;"> \
		    <div class="modal-header"> \
				<h4 class="modal-title">{{title}}</h4> \
		    </div> \
		    <div class="modal-body"> \
				<div class="form-group"> \
					<label>{{label_device}}</label>\
					<select class="form-control" id="dev-select-device"> \
					{{#each devices}}\
						<option value="{{this.device}}.{{this.orientation}}" {{#if this.selected}}selected{{/if}}>\
						{{this.description}}\
						</option>\
					{{/each}}\
					</select>\
					<span class="input-group"> \
						<input id="dev-device-scale" type="checkbox" {{#if scaleChecked}}checked{{/if}}>{{label_scale}} \
					</span> \
				</div> \
				<div class="form-group"> \
					<span class="input-group"> \
						<input id="dev-cache" type="checkbox" {{#if cacheChecked}}checked{{/if}}>{{label_cache}} \
	  				</span> \
				</div> \
			</div> \
		    <div class="modal-footer"> \
				<button type="button" class="btn" id="btn_dev_close">{{label_close}}</button> \
				<button type="button" class="btn btn-default" disabled="true" id="btn_dev_apply">{{label_apply}}</button> \
    			<button type="button" class="btn" id="btn_dev_ok">{{label_ok}}</button> \
			</div> \
		</div> \
	</div> \
	</div>';

var _show = function() {
	_setActive(true);

	if ($("#page_dev_mode").is(":visible")) {
		return;
	}
	var modalHtml = Handlebars.compile(_template);
	var cache = globals.getCache();
	var site = globals.getSiteLayout();
	var devs = site.getDeviceTemplates();

	var ctx = {
		title: "Development settings",

		label_device: "Device",
		devices: [],

		label_scale: "Scale if needed",

		label_cache: "Disable caching",

		label_close: "Cancel",
		label_ok: "Ok",
		label_apply: "Apply",

		scaleChecked: localStorage.getItem("devPanelScale") === "true",
		cacheChecked: localStorage.getItem("devPanelCache") === "true"
	};

	ctx.devices.push({
		device: "<No emulation>",
		orientation: "landscape",
		description: "<No emulation>"
	});

	for (var dev in devs) {
		devs[dev].orientations.forEach(function(o) {
			var devName = dev;
			var orientName = o;

			var opt = {
				device: dev,
				orientation: o,
				description: devName + " (" + o + ")"
			};
			ctx.devices.push(opt);
		});
	}
	var lastDev = localStorage.getItem("devPanelDevice") || "<No emulation>.landscape";
	ctx.devices.forEach(function(d) {
		d.selected = (lastDev === d.device + "." + d.orientation);
	});
	modalHtml = modalHtml(ctx);
	$("body").append($(modalHtml));
	var $$page = $("#page_dev_mode");
	$$page.draggable();

	$("#btn_dev_ok", $$page).on("click", function() {
		apply();
		$$page.remove();
	});
	$("#btn_dev_apply", $$page).on("click", function() {
		apply();
		// If we click a second time on the button the rendering is not good (panels)
		$("#btn_dev_apply", $$page).attr("disabled", "true");
	});

	$("#btn_dev_close", $$page).on("click", function() {
		_setActive(false);
		$$page.remove();
	});
	$("#dev-select-device", $$page).on("change", function() {
		$("#btn_dev_apply", $$page).removeAttr("disabled");
	});
	$('input[type="checkbox"]', $$page).on("click", function() {
		$("#btn_dev_apply", $$page).removeAttr("disabled");
	});
	var apply = function() {
		var device = $$page.find("#dev-select-device").val();
		var dev = device.split(".");
		var params = {
			layout: {
				pageParameters: {}
			}
		};
		localStorage.setItem("devPanelDevice", device);
		if (device === "<No emulation>.landscape") {
			params.layout.pageParameters.forcePreview = false;
			params.layout.pageParameters.forceAutoScale = false;
			params.layout.pageParameters.device = "tablet";
			params.layout.pageParameters.orientation = "landscape";
		} else {
			params.layout.pageParameters.device = dev[0];
			params.layout.pageParameters.orientation = dev[1];
			params.layout.pageParameters.forcePreview = true;

			if ($("#dev-device-scale", $$page).is(":checked") === true) {
				params.layout.pageParameters.forceAutoScale = true;
				localStorage.setItem("devPanelScale", "true");
			} else {
				params.layout.pageParameters.forceAutoScale = false;
				localStorage.setItem("devPanelScale", "false");
			}
		}

		if ($("#dev-cache", $$page).is(":checked") === true) {
			localStorage.setItem("devPanelCache", "true");
			cache.disableCache(true);
		} else {
			localStorage.setItem("devPanelCache", "false");
			cache.disableCache(false);
		}

		uiutils.triggerResizeInternal(params);
	};

	apply();
};

function _setActive(flag) {
	localStorage.setItem("devPanelOpen", flag ? "true" : "false");
}

exports.wasActive = function() {
	return localStorage.getItem("devPanelOpen") === "true";
};

exports.show = _show;
});

define('syracuse-tablet/html/js/ui/modals/modalShowLegal',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/sdata/sdataHttp','syracuse-tablet/html/js/helpers/types/date'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var sdataHttp = require('syracuse-tablet/html/js/sdata/sdataHttp');
var date = require('syracuse-tablet/html/js/helpers/types/date');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
			<div class="s-m-scroll-element"> \
				<div class="form-group"> \
					<div class="s-m-header-brand"> \
						<span class="s-m-brand">{{label_brand}}</span> \
						<span class="s-m-product">{{label_product}}</span> \
					</div> \
					<span class="s-m-product-update-label">{{label_update}}</span><span class="s-m-product-update-value">{{update}}</span> \
				</div> \
				<div class="form-group"> \
					<h3>{{label_legal}}</h3> \
					<label>{{text1}}</label> \
					<label>{{text2}}</label> \
					<label>{{text3}}</label> \
					<label>{{text4}}</label> \
					<label>{{text5}}</label> \
					<label>{{text6}}</label> \
				</div> \
				{{#if licenses}} \
				<div class="form-group"> \
					<h3>{{label_license}}</h3> \
					{{#each licenses}} \
						<div class="s-m-field"><div class="s-m-title">{{../label_registrationNumber}}</div><div class="s-m-value">{{toRegNum}}</div></div> \
						<div class="s-m-field"><div class="s-m-title">{{../label_licensedTo}}</div><div class="s-m-value">{{toName}}</div></div> \
						<div class="s-m-field"><div class="s-m-title">{{../label_reference}}</div><div class="s-m-value">{{toRefNum}}</div></div> \
						<div class="s-m-field"><div class="s-m-title">{{../label_installedBy}}</div><div class="s-m-value">{{installedBy}}</div></div> \
						<div class="s-m-field"><div class="s-m-title">{{../label_expiryDate}}</div><div class="s-m-value">{{expiryDate}}</div></div> \
					{{/each}} \
				</div> \
				{{/if}} \
				{{#if userAgent}} \
					<h3>{{label_user_agent}}</h3> \
					<div class="form-group"> \
						<label>{{userAgent}}</label> \
						<label>{{lookAndFeel}}</label> \
					</div> \
				{{/if}} \
				{{#if builddate}} \
					<div class="form-group"> \
						<label>{{builddate}}</label> \
					</div> \
				{{/if}} \
				{{#if pageInfo}} \
					<h3>{{pageInfo.label}}</h3> \
					<div class="form-group pageInfo"> \
						{{#each pageInfo.properties}} \
							<div class="s-m-field"><div class="s-m-title">{{label}}:</div><div class="s-m-value">{{value}}</div></div> \
						{{/each}} \
					</div> \
				{{/if}} \
			</div> \
			</div>',
	footer: ''
};

var _Klass = utils.defineClass(
	function ModalShowLegal() {
		var self = this;
		modalDialog.ModalBase.call(self);
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "show-legal half_right";
			} else {
				displayFlags.modalClass = "show-legal full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			return sdataHttp.send({
				method: "GET",
				url: "/sdata/syracuse/collaboration/syracuse/licenses/$service/current"
			}).
			then(function(data) {
				var version = null;
				var licenses = [];
				if (data && data.isSuccess && data.responseJSON) {
					data.responseJSON.forEach(function(lic) {
						var l = {};
						l.expiryDate = locale.text("modal.legal.license.expiryDateValue", [date.getLocalShortDate(lic.validFrom), date.getLocalShortDate(lic.expiryDate)]);
						l.toName = lic.licensedTo.name;
						l.toRegNum = lic.licensedTo.registrationNumber;
						l.toRefNum = lic.licensedTo.reference;
						l.installedBy = lic.reseller.name;

						licenses.push(l);
						if (!version) {
							version = lic.productVersion;
						}
					});
					return {
						version: version,
						licenses: licenses
					};
				}
			})
				.then(function(licData) {
					var labels = locale.getProductLabels();
					var showBuildDate = window.location.href.indexOf("SHOW_VERSION_NUMBER") > -1;
					var pageInfo;
					var currPage = globals.getApplication().currentPage;
					if (globals.isDvlpMode() && currPage && currPage.state) {
						// We add the pageId to facilitate retrieving page's authoring in mongoDB
						pageInfo = {
							label: locale.text("modal.legal.pageinfo.lablel"),
							properties: [{
								value: currPage.state.authoringName ? currPage.state.authoringName + ".mobile" : "",
								label: locale.text("modal.legal.pageinfo.authname")
							}]
						};
					}
					var data = {
						title: locale.text("modal.legal.title"),
						label_brand: labels.brand,
						label_product: labels.product,
						label_update: locale.text("modal.legal.update"),
						label_license: locale.text("modal.legal.about.license"),
						label_legal: locale.text("modal.legal.about.legal"),
						label_user_agent: locale.text("modal.legal.about.user_agent"),
						update: (licData && licData.version) || "?",
						licenses: licData && licData.licenses,
						builddate: showBuildDate && locale.text("modal.legal.builddate", [globals.getBuildTimeStamp()]),
						text1: locale.text("modal.legal.text1"),
						text2: locale.text("modal.legal.text2"),
						text3: locale.text("modal.legal.text3"),
						text4: locale.text("modal.legal.text4"),
						text5: locale.text("modal.legal.text5"),
						text6: locale.text("modal.legal.text6"),
						label_registrationNumber: locale.text("modal.legal.license.registrationNumber"),
						label_licensedTo: locale.text("modal.legal.license.licensedTo"),
						label_reference: locale.text("modal.legal.license.reference"),
						label_userLicense: locale.text("modal.legal.license.userLicense"),
						label_installedBy: locale.text("modal.legal.license.installedBy"),
						label_server: locale.text("modal.legal.license.server"),
						label_expiryDate: locale.text("modal.legal.license.expiryDate"),
						userAgent: globals.isDvlpMode() ? navigator.userAgent : "",
						lookAndFeel: globals.isDvlpMode() ? globals.getLookAndFeel() : "",
						pageInfo: pageInfo
					};

					return data;
				});
		},

		_onValidate: function() {},

		_onCancel: function() {},

		_getResult: function() {}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalSettings',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/native/native'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var native = require('syracuse-tablet/html/js/helpers/native/native');

var _cacheOptions = {
	"1week": {
		days: 7
	},
	"2week": {
		days: 14
	},
	"month": {
		days: 30
	},
	"all": {
		days: null
	},
};
var _templateAll = {
	header: '\
		<buttons class="pull-right"> \
			<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
		</buttons> \
		<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="form-group s-m-scroll-element"> \
					<header>{{label_device}}</header> \
					<div class="btn-group btn-group-justified" data-toggle="buttons" id="s-m-radio-type-id"> \
						<div class="btn-group"> \
							<label class="btn btn-primary" data-action="clickType" data-params="auto"> \
								<input type="radio" name="s-m-radio-type">{{label_auto}} \
							</label> \
						</div> \
						<div class="btn-group"> \
							<label class="btn btn-primary" data-action="clickType" data-params="smartphone"> \
								<input type="radio" name="s-m-radio-type">{{label_smartphone}} \
							</label> \
						</div> \
						<div class="btn-group"> \
							<label class="btn btn-primary" data-action="clickType" data-params="tablet"> \
								<input type="radio" name="s-m-radio-type">{{label_tablet}} \
							</label> \
						</div> \
					</div> \
					{{#if showConfigServers}} \
						<header>{{label_servers}}</header> \
						<div class="btn-group btn-group-justified"> \
							<div class="btn-group"> \
								<label class="btn btn-primary" data-action="selectServer" data-params="">{{label_switch_server}}</label> \
							</div> \
						</div> \
					{{/if}} \
					<header id="s-m-cache-id">{{label_cache}}</header> \
					<span id="s-m-cache-explain">{{label_cache_clear}} \
					<div id="s-m-cache-btns-id" class="btn-group btn-group-justified"> \
						<label id="s-m-cache-clear-all-id" class="btn btn-primary s-m-cache-btn" data-action="clearCache" data-params="clear,all">{{label_cache_all}}<div></div></label> \
						<label id="s-m-cache-clear-1week-id" class="btn btn-primary s-m-cache-btn" data-action="clearCache" data-params="clear,1week">{{label_cache_week1}}<div></div></label> \
						<label id="s-m-cache-clear-2week-id" class="btn btn-primary s-m-cache-btn" data-action="clearCache" data-params="clear,2week">{{label_cache_week2}}<div></div></label> \
						<label id="s-m-cache-clear-month-id" class="btn btn-primary s-m-cache-btn" data-action="clearCache" data-params="clear,month">{{label_cache_month}}<div></div></label> \
					</div> \
					<div style="display:table-row;"> \
					<label id="s-m-cache-confirm-id" class="btn btn-primary s-m-confirm" data-action="clearCache" data-params="confirm,all" style="display: none;">{{label_cache_confirm}}</label> \
					<label id="s-m-cache-cancel-id" class="btn btn-warning s-m-cancel" data-action="clearCache" data-params="cancel" style="display: none;">{{label_cancel}}</label> \
					</div> \
					<div id="s-m-cache-progress-id" class="progress" style="display: none;"> \
						<div class="progress-bar progress-bar-striped active" role="progressbar" aria-valuenow="45" aria-valuemin="0" aria-valuemax="100" style="width: 100%">{{label_clearing}}</div> \
					</div> \
					\
					<div id="s-m-cache-ok-id" class="alert alert-success" role="alert" style="display: none">{{label_clearing_ok}}</div> \
					<div style="width:100%; display: inline-block;"></div> \
				</div> \
			</div>',

	footer: '',
};

var _Klass = utils.defineClass(
	function ModalSettings(settings) {
		var self = this;
		modalDialog.ModalBase.call(self);

		self.settings = settings && $.extend(true, {}, settings) || {};
		self.settings["device-type"] = self.settings["device-type"] || "auto";

		// Result
		self.result = null;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll,
				smartphone: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "settings half_right";
			} else {
				displayFlags.modalClass = "settings full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			var data = {
				title: locale.text("settings.title"),

				label_device: locale.text("settings.device.label"),
				label_auto: locale.text("settings.device.auto"),
				label_smartphone: locale.text("settings.device.smartphone"),
				label_tablet: locale.text("settings.device.tablet"),

				label_cache: locale.text("settings.cache.label"),
				label_cache_clear: locale.text("settings.cache.clear"),
				label_cache_week1: locale.text("settings.cache.week1"),
				label_cache_week2: locale.text("settings.cache.week2"),
				label_cache_month: locale.text("settings.cache.month"),
				label_cache_all: locale.text("settings.cache.all"),
				label_cache_confirm: locale.text("settings.cache.confirm"),

				label_clearing: locale.text("settings.cache.clearing"),
				label_clearing_ok: locale.text("settings.cache.clearing_ok"),

				label_apps: locale.text("settings.apps.label"),
				label_apps_update: locale.text("settings.apps.update"),
				label_apps_confirm: locale.text("settings.apps.confirm"),

				label_apps_wait: locale.text("settings.apps.wait"),
				label_apps_ok: locale.text("settings.apps.ok"),

				label_cancel: "", //locale.text("settings.cache.cancel"),
			};
			if (native.hasCapability("nativeApp")) {
				data.showConfigServers = true;
				data.label_servers = locale.text("settings.servers.servers");
				data.label_switch_server = locale.text("settings.servers.switch");
			}
			return data;
		},
		_onShow: function() {
			var self = this;
			modalDialog.ModalBase.prototype._onShow.call(self);

			// Apply UI states
			$("label[data-params='" + self.settings["device-type"] + "']", self.$$elmt).eq(0).button("toggle");

			self._computeCacheSize();
		},
		// could be removed, result is set in _onAction
		_onValidate: function() {
			var self = this;
			var $$active = $("#s-m-radio-type-id .active ", this.$$elmt);
			var deviceType = $$active.length < 1 ? "auto" : $$active.attr("data-params") || "auto";
			self.settings["device-type"] = deviceType;
			self.result = self.settings;
		},
		_onCancel: function() {
			var self = this;
			self.result = null;
		},

		_onAction: function(action, param) {
			var self = this;
			switch (action) {
				case "clickType":
					$("label[data-params='" + param + "']", self.$$elmt).eq(0).button("toggle");
					break;
				case "clearCache":
					self._clearCache(param);
					break;

					// Not used right now, keep it for reference, see commented html at top of file
				case "clearApps":
					self._clearApps(param);
					break;
				case "selectServer":
					if (native.hasCapability("nativeApp")) {
						native.getModule("nativeApp").selectServer();
					}
					return true; // Close settings if we go to server config
					break;
			}
			// dont close on actions
			return false;
		},

		_clearApps: function(param) {
			var self = this;
			var p = param.split(",");
			var action = p[0];
			var data = p[1];
			self._setButtons("clearApps", "apps", action, data);
			if (action === "confirm") {
				return globals.getMetaData().removeApplications()
					.always(function() {
						globals.setNeedToCheckAppsList(true); // Force read of applications list
						self._setButtons("clearApps", "apps", "ok", "");
					});
			}
		},

		_clearCache: function(param) {
			var self = this;
			var p = param.split(",");
			var action = p[0];
			var data = p[1];
			self._setButtons("clearCache", "cache", action, data);
			if (action === "confirm") {
				// data: 1week, 2week, month, all
				var dt = self._getDateBefore(_cacheOptions[data].days);
				return globals.getCache().clearCache({
					$not_read_since: dt
				})
					.always(function() {
						self._setButtons("clearCache", "cache", "ok", "");
						self._computeCacheSize();
					});
			}
		},

		_setButtons: function(action, prefix, state, data) {
			var self = this;
			switch (state) {
				case "confirm":
					$("#s-m-" + prefix + "-progress-id", self.$$elmt).show();
					$("#s-m-" + prefix + "-confirm-id", self.$$elmt).hide();
					$("#s-m-" + prefix + "-cancel-id", self.$$elmt).hide();
					break;
				case "cancel":
					$("#s-m-" + prefix + "-btns-id", self.$$elmt).show();
					$("#s-m-" + prefix + "-confirm-id", self.$$elmt).hide();
					$("#s-m-" + prefix + "-cancel-id", self.$$elmt).hide();
					break;
				case "clear":
					$("#s-m-" + prefix + "-confirm-id", self.$$elmt).show();
					$("#s-m-" + prefix + "-cancel-id", self.$$elmt).show();
					$("#s-m-" + prefix + "-btns-id", self.$$elmt).hide();
					$("#s-m-" + prefix + "-confirm-id", self.$$elmt).attr("data-params", "confirm," + (data || ""));
					break;
				case "ok":
					$("#s-m-" + prefix + "-progress-id", self.$$elmt).hide();
					$("#s-m-" + prefix + "-ok-id", self.$$elmt).show();
					setTimeout(function() {
						$("#s-m-" + prefix + "-ok-id", self.$$elmt).hide();
						$("#s-m-" + prefix + "-btns-id", self.$$elmt).show();
					}, 3000);
					break;
			}
		},

		_getDateBefore: function(days) {
			if (!days) {
				return "9999-99-99-00-00-00";
			}
			var today = new Date();
			var dt = new Date(today);
			dt.setDate(today.getDate() - days);
			dt = dt.toJSON().slice(0, 10) + "-00-00-00";
			return dt;
		},

		_computeCacheSize: function() {
			var self = this;
			Object.keys(_cacheOptions).forEach(function(co) {
				var dt = self._getDateBefore(_cacheOptions[co].days);
				return globals.getCache().computeCacheSize({
					$not_read_since: dt
				})
					.always(function(result) {
						self._updateCacheSize(co, result);
					});
			});
		},

		_updateCacheSize: function(key, result) {
			var self = this;
			var $$div = $("#s-m-cache-clear-" + key + "-id > div", self.$$elmt);

			var units = [locale.text("global.units.kilobytes"),
				locale.text("global.units.megabytes")
			];

			$$div.empty();
			if (result && result.$data) {
				var size = result.$data.sizeRecords;
				var sizeUnit = locale.text("global.units.bytes");
				while (size >= 1024 && units.length > 0) {
					size = (size + 1023) / 1024;
					sizeUnit = units.shift();
				}
				var sizeText = Math.round(size) + " " + sizeUnit;
				$$div.append($("<span>" + result.$data.numRecords + " " + locale.text("global.units.files") + "</span><span>" + sizeText + "</span>"));
			}
		},

		_getResult: function() {
			var self = this;
			return self.result;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/application/application',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/application/authentication','syracuse-tablet/html/js/application/eventListener','syracuse-tablet/html/js/application/pageLoader','syracuse-tablet/html/js/init/initContext','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/application/pageRegistry','syracuse-tablet/html/js/authoring/authoring','syracuse-tablet/html/js/ui/developmentPage','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/application/settings','syracuse-tablet/html/js/ui/modals/modalShowLegal','syracuse-tablet/html/js/ui/modals/modalSettings','syracuse-tablet/html/js/ui/modals/modalConfirm','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/sdata/sdataCommonResources'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("app");
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var auth = require('syracuse-tablet/html/js/application/authentication');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var pageLoader = require('syracuse-tablet/html/js/application/pageLoader');
var initContext = require('syracuse-tablet/html/js/init/initContext');
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var pageRegistry = require('syracuse-tablet/html/js/application/pageRegistry');
var authoring = require('syracuse-tablet/html/js/authoring/authoring');
var developmentPage = require('syracuse-tablet/html/js/ui/developmentPage');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var settings = require('syracuse-tablet/html/js/application/settings');
var modalShowLegal = require('syracuse-tablet/html/js/ui/modals/modalShowLegal');
var modalSettings = require('syracuse-tablet/html/js/ui/modals/modalSettings');
var modalConfirm = require('syracuse-tablet/html/js/ui/modals/modalConfirm');
var native = require('syracuse-tablet/html/js/helpers/native/native');
var sdataCommonResources = require('syracuse-tablet/html/js/sdata/sdataCommonResources');
/**
 * Default application config
 */
var _appConfig = {
	transition: null,
	// FDB - openLinkInVignette=true to allow test in vignettes (children page, lookup...)
	// MW - Changed to false as default since this is more what we are going to use.
	openLinkInVignette: false,
	// FK - to allow display of user photo
	loadUserImage: true
};
/**
 * Subscriptions
 */
var _subscribe = function(self) {
	notifications.subscribe(self, ["sm.modal.open", "sm.modal.close", "sm.main.layout.changed", "sm.user.logged.in"], 1);
};
/**
 * Tablet application class
 */
var _Application = utils.defineClass(
	function($$elmt, factory) {
		this.$$elmt = $$elmt;
		this.currentPage = null;
		this._$config = $.extend(true, {}, _appConfig);
		this.factory = factory;
		this._pageLoader = null;
		this._nbModals = 0;
		this._wait = uiutils.waitWheelCreate($$elmt);
		// Id of the home dashboard of current application
		// Used to go to home page
		this.homePageId = null;
		// Default appid when login page is loaded without current application
		this.uuid = "root";
		// Application history stack
		this.history = [];
		// Force pushState on first page
		this.pushState = true;
	}, null, {
		/**
		 * Called after object has been created
		 **/
		init: function() {
			// Can't be called in constructor
			eventListener.bindEvents(this);
			this.dao = this.factory.createDaoApp(this);
			_subscribe(this);
			this.$$elmt.show();
		},

		destroy: function() {
			authoring.destroy();
			if (this._wait) {
				uiutils.waitWheelDestroy(this._wait);
				this._wait = null;
			}
			if (this.currentPage) {
				this.currentPage.destroy();
				this.currentPage = null;
			}
			if (this.$$elmt) {
				this.removeAllChildPages(this.$$elmt);
				this.$$elmt.unbind();
				this.$$elmt.remove();
				this.$$elmt = null;
			}
			if (this.dao) {
				this.dao.destroy();
				this.dao = null;
			}
			if (this._pageLoader) {
				this._pageLoader.destroy();
				this._pageLoader = null;
			}
			notifications.unsubscribe();
			$(window).unbind();
		},
		isLoadingPage: function() {
			// Returns true if page is loading - #7426
			// When we click back arrow of the browser with the focus on an input field JQuery triggers a blur evt which is processed while the page is loading
			// We skip blur/click events on controls
			return this._pageLoader != null && this._pageLoader.loading === true;
		},
		// Called on page unload
		onUnload: function() {
			console.log("onUnload");
			this.destroy();
		},
		// Called on page onBeforeUnload - We have time to call processes
		// Can return a message to display (error if any)
		onBeforeUnload: function() {
			// TEST USE CLOSE APP BUTTON
			if (false && native.hasCapability("nativeApp")) {
				return native.getModule("nativeApp").notifUnloaded();
			}
		},
		/**
		 * True if current 'mobile application' is welcome application
		 */
		isWelcomeApplication: function() {
			return this.uuid === "$welcomeApplication";
		},
		/**
		 * For page display
		 */
		getTitle: function() {
			return this.dao.getApplicationTitle();
		},
		/**
		 * Goto home page of current 'mobile application'
		 */
		gotoHome: function() {
			var self = this;
			var deferred = $.Deferred();
			setTimeout(function() {
				self.changePage(self.homePageId).then(function() {
					deferred.resolve();
				}).fail(function(e) {
					deferred.reject(e);
				});
			});
			return deferred.promise();
		},
		/**
		 * Accept path like "array.gridMaxCols"
		 */
		$config: function(id) {
			return utils.getPropByPath(this._$config, id);
		},

		notifModalOpen: function() {
			this._nbModals++;
			log && log("notifModalOpen nbModals=" + this._nbModals);
		},

		notifModalClose: function() {
			this._nbModals = Math.max(this._nbModals - 1, 0);
			log && log("notifModalClose nbModals=" + this._nbModals);
		},
		/**
		 * info - sizes of application and main page components header/footer/content - see siteLayout
		 * 		application.width	Application width
		 * 		application.weight	Application height
		 * 		content.width		Main page content width
		 * 		content.height		Main page content height
		 * 		...footer and header
		 * orientation	portrait/landscape
		 */
		notifMainLayoutChanged: function(info, orientation, deviceType) {
			var self = this;
			//	self.orientation = orientation;
			// Container including header, content, footer
			// Set fixed with/height for application
			self.$$elmt.width(info.application.width);
			self.$$elmt.height(info.application.height);
			if (self.currentPage) {
				self.currentPage.onMainPageResize(info, orientation, deviceType);
				if (info.afterMainPageLoaded === true && globals.isAutoUITestMode()) {
					globals.getUnitTestMgr().notifPageLoaded("after", self.currentPage);
				}
			}
			if (info.deviceChanged) {
				// Like we change the device we rebuilt the header and must refresh darft count
				self.triggerUpdtDraftsCount();
			}
		},
		/**
		 * Application can be scrolled (native scroll) in authoring mode
		 */
		getScrollOffset: function() {
			return {
				top: this.$$elmt.scrollTop(),
				left: this.$$elmt.scrollLeft()
			};
		},
		hasModalOpen: function() {
			log && log("_nbModals=" + this._nbModals);
			return this._nbModals > 0;
		},

		_actGotoWelcomeApplication: function() {
			return this.gotoWelcomeApplication();
		},
		_actLogout: function(actionName) {
			this.logout("logout.msg");
		},
		/**
		 * Opens a draft and switch context ( endpoint) if needed
		 */
		_actOpenDraft: function(draftId) {
			var self = this;
			if (!draftId) return;
			return globals.getStorage().draftOperation("draftRead", draftId).then(function(ctx) {
				if (!ctx || !ctx.restoredContext) return;
				self._swicthToContext(ctx.restoredContext);
			});
		},
		/**
		 * Called by link with data-action = historyBack
		 */
		_actHistoryBack: function() {
			window.history.back();
		},
		// Switch role, endpoint, language
		_actSwitchContext: function() {
			var self = this;
			initContext.askNewContext()
				.then(function(canceled) {
					if (canceled == true) {
						// Operation canceled
						return;
					}
					self.gotoWelcomeApplication();
				})
				.fail(function(e) {
					//#8000  needed to stop waitWheel trigger by changeProfile if failure
					self.waitWheelStop();
					if (e != null && e.$redirectPage === "login") {
						var msg;
						// Error management is a little messy
						if (e.$diagnoses && e.$diagnoses.length > 0) {
							msg = e.$diagnoses[0].$message;
						} else {
							msg = e.message || e.$message;
						}
						self.logout(msg);
					} else {
						globals.getModal().error(locale.text("user.context.error"), e);
					}
				});
		},
		_actDevelopmentPage: function() {
			developmentPage.show();
		},
		_actSettings: function() {
			var self = this;
			return settings.getGlobalSettings()
				.then(function(set) {
					var modal = new modalSettings.Modal(set);
					return modal.show();
				})
				.then(function(result) {
					if (result) {
						return settings.setGlobalSettings(result);
					}
				});
		},
		_actDesignPage: function() {
			authoring.toggleDesignPage();
		},
		_addRemovePinPage: function(add) {
			if (add === undefined) return;
			var self = this;
			var pageData = self.currentPage.getPinPageData() // allow to add information by subclasses;
			if (add) {
				if (pageData.dashboardName && pageData.applicationName === self.dao.getApplicationName() && pageData.dashboardName === self.dao.getHomeDashboardName()) {
					// We keep the application Icon if we pin the home dashboard
					pageData.icon = self.dao.getApplicationIcon();
				}
				settings.addPinnedPage(pageData)
					.then(function() {
						var notify = {
							severityClass: "success",
							title: "",
							body: locale.text("pin.page.add.ok", [pageData.title]),
							onlyWebapp: true
						};
						globals.getModal().notify(notify);
						notifications.publish("sm.page.pin.state.change", 2);
					});
			} else {
				settings.removePinnedPage(pageData.id)
					.then(function() {
						var notify = {
							severityClass: "success",
							title: "",
							body: locale.text("pin.page.remove.ok", [pageData.title]),
							onlyWebapp: true
						};
						globals.getModal().notify(notify);
						notifications.publish("sm.page.pin.state.change", 1);
					});
			}
		},
		/**
		 * Open about page
		 */
		_actAbout: function() {
			var modal = new modalShowLegal.Modal();
			modal.show();
		},
		/**
		 * options	: {noPageChange:true} to not display the home page
		 */
		_switchToApplication: function(appName, options) {
			var self = this;
			return globals.getMetaData().checkApplicationUpdate(appName)
				.then(function(update) {
					if (update !== true) { // no new version available
						return false;
					}
					var modal = new modalConfirm.Modal(locale.text("modal.confirm.update"), null, true);
					return modal.show().then(function(result) {
						return result === "yes";
					});
				})
				.then(function(forceUpdate) {
					return globals.getMetaData().getApplication(appName, false, forceUpdate);
				})
				.then(function(appDetails) {
					return self._setCurrentApplication(appDetails, options);
				})
				.fail(function(e) {
					// In wheel is not stop (can occur with unexpected errors)
					self.waitWheelStop();
					if (e && e.$noConnectionError == true) {
						// Error reading meta data
						globals.setOffline(true, {
							severityClass: "error",
							body: locale.text("action.needs.net")
						});
					}
					return $.smReject(e);
				});
		},

		/**
		 * Goto tablet applications home page  - Welcome dashboard
		 * Ex: For login page we display the error in login page instead of modal
		 */
		gotoWelcomeApplication: function() {
			var self = this,
				step;
			if (globals.isLoggedIn()) {
				step = globals.getMetaData().getApplication("$welcomeApplication").then(function(appDetails) {
					return self._setCurrentApplication(appDetails);
				});
			} else {
				step = this.gotoLogin();
			}
			return step;
		},
		/**
		 * Goto login page
		 */
		gotoLogin: function(reason, isError, offlineHint) {
			var self = this;
			var deferred = $.Deferred();
			setTimeout(function() {
				self.changePage("login", {
					reason: reason,
					isError: isError === true,
					offlineHint: offlineHint
				}).then(function() {
					deferred.resolve();
				}).fail(function(e) {
					deferred.reject(e);
				});
			}, 0);
			return deferred.promise();
		},
		/**
		 * Set the current 'mobile application'
		 * Called after a switch context (application selection) or when tablet application is launched
		 * 'Welcome dashboard' page is a real application with only one dashboard
		 * options
		 * {
		 *    noPageChange: Don't change to application home dashboard
		 * }
		 *
		 */
		_setCurrentApplication: function(appInfo, options) {
			var self = this;
			var deferred = $.Deferred();
			options = options || {};
			try {
				if (!appInfo) {
					throw new Error("Null appInfo");
				}
				log && log("Switch to Syracuse Mobile Application " + appInfo.applicationName);
				if (self.currentPage) {
					// Keep the current page for next step (change page)
					// Used for child pages and by welcome page to calculate the gadget of pinned pages
					self.currentPage.deactivate();
				}
				if (!appInfo.$application.$uuid) {
					throw new Error("No application $uuid - " + appInfo.applicationName);
				}
				if (self.uuid !== appInfo.$application.$uuid) {
					// Application changed
					self.dao.setApplication(appInfo);
					self.homePageId = globals.getMetaData().getDashboardPageName(self.dao.getHomeDashboardName());
					self.uuid = appInfo.$application.$uuid;
					self.applicationName = appInfo.$application.applicationName || self.uuid;
				}
				if (options.noPageChange !== true) {
					self.gotoHome().then(function() {
						deferred.resolve();
					}).fail(function(e) {
						deferred.reject(e);
					});
				} else {
					deferred.resolve();
				}
			} catch (e) {
				if (self.currentPage) {
					self.currentPage.activate();
				}
				if (options.dontDiplayErrors === true) {
					deferred.reject(e);
				} else {
					modal.error("Error switching application", e, function() {
						deferred.reject(e);
					});
				}
			}
			return deferred.promise();
		},
		/**
		 * Open a page
		 * !! Do not call directly - Use changePage
		 * loadOptions
		 * 		dontDisplayLoadErr = true to not display a modal
		 */
		_gotoPage: function(state, back, loadOptions) {
			var self = this;
			if (!self._pageLoader) {
				self._pageLoader = self._createPageLoader();
			}
			/**
			 * Page loader shared with vignette
			 * Load a page
			 */
			if (state.isLogin === false && !globals.isLoggedIn()) {
				self.gotoLogin("Authentication is required");
				return $.smResolve();
			} else if (self._pageLoader.loading) {
				// Nothing if a page is currently loading
				// #5872 - We could load a login page two time that causes an error (called from http401Error and init login) 
				return $.smResolve();
			} else {
				return self._pageLoader.load(state, back, loadOptions)
					.then(function(page) {
						// Notify that main page has been loaded
						notifications.publish(["sm.mainpage.loaded"], self.history);
						return page;
					});
			}
		},

		_createPageLoader: function() {
			var self = this;
			var loader = new pageLoader.Klass({
				beforeLoading: function() {
					if (globals.isAutoUITestMode()) {
						globals.getUnitTestMgr().notifPageLoaded("before");
					}
				},
				waitWheelStop: function() {
					self.waitWheelStop();
				},
				getRootElmt: function() {
					return self.$$elmt;
				},
				waitWheelStart: function() {
					self.waitWheelStart();
				},
				getCurrentPage: function() {
					return self.currentPage;
				},
				setCurrentPage: function(page) {
					self.currentPage = page;
					if (page.state.isLogin === true) {
						self.historyReset(page);
					} else if (page.state.name === self.homePageId) {
						// Destroy all cached pages except current home page
						log && log("Home page " + self.homePageId + " - Destroy all pages except current");
						self.removeAllChildPages(self.$$elmt, page);
					}
				},
				historyPush: function(state) {
					self.history.push(state);
					// Refresh browser history to keep only one page in history for tablet application
					if (self.pushState) {
						window.history.pushState({
							x: new Date()
						}, utils.UUID(), null);
					} else {
						window.history.replaceState({
							x: new Date()
						}, utils.UUID(), null);
					}
					// self.historyLog("historyPush");
				},
				succeeded: function(dstPage, pageToClose, parentNotifInfo, back, loadOptions) {
					log && log("succeeded" + " - win=" + window.history.length + " - app=" + self.history.length);
					// dstPage.isNew - > Page has been created -> trigger resize
					// back && !dstPage.isNew -> dstPage was stored in the cache - back from child page (pageToClose.isChild should be true)
					// -> We resize on only if size has changed - Otherwise we just show the page
					if (dstPage.isNew || (back && pageToClose && pageToClose.isChild && pageToClose.sizeModified)) {
						uiutils.triggerResizeInternal({
							afterMainPageLoaded: true
						});
					}
					if (globals.isAutoUITestMode()) {
						globals.getUnitTestMgr().notifPageLoaded("after", dstPage);
					}
					if (parentNotifInfo && parentNotifInfo.notifId) {
						/**
						 * If the child application wants to notify the parent it should return info for notification
						 * parentNotifInfo contain :
						 * 		notifId:  	with the notification id
						 * 		notifData: 	with data  needed for processing this event
						 * 		controlId: 	If action as been trigered by a control
						 * 		parentId: 	id of the controller to notify
						 */
						var controllerToNotify = globals.getController(parentNotifInfo.parentId);
						if (controllerToNotify) {
							notifications.notifyController(parentNotifInfo.notifId, controllerToNotify, parentNotifInfo.notifData, parentNotifInfo.controlId);
						} else {
							// if no controller id is provided we publish a global event - Eg: in dashboard we want to notify oal the nested pages - see sm.updt.chart.dashboard
							notifications.publish(parentNotifInfo.notifId, parentNotifInfo.notifData);
						}
					}
					// Update drafts counter in header menu or smatphone panel when page is loaded
					self.triggerUpdtDraftsCount();
				}
			});

			return loader;
		},
		triggerUpdtDraftsCount: function() {
			globals.getStorage().draftOperation("draftNotifyChanged");
		},
		historyReset: function(page) {
			// Destroy all cached pages except page parameter
			this.removeAllChildPages(this.$$elmt, page);
			this.history = [];
		},
		/**
		 * Call cb(state)
		 * Stop if cb returns true
		 */
		historyScan: function(cb) {
			for (var i = this.history.length - 1; i >= 0; i--) {
				if (cb(this.history[i]) === true) break;
			}
		},
		historyLog: function(title) {
			this.historyScan(function(state) {
				console.log("\t", state.name);
			});
		},
		/**
		 * !!!! returns a boolean or a promise
		 *  - true if back is allowed
		 *  - false if back is not allowed
		 *  - promise:  the promise must resolve with true or false
		 *  			used if a dialog is displayed
		 */
		_checkBack: function() {
			if (authoring && !authoring.checkBack()) {
				return false;
			}
			return this.currentPage ? this.currentPage.checkBack() : true;
		},
		/**
		 * event dom event or null
		 * pageFilter callback to select the targetPage
		 * 		If pageFilter == null goto previous page
		 * 		pageFilter(pageState)
		 * 		returns true/false
		 * 		If true goto a selected page
		 * 		if false  back is canceled
		 * Returns a promise
		 * 		Resolve with the page displayed or null
		 */
		historyPop: function(event, pageFilter) {
			var self = this;
			var deferred = $.Deferred();
			// Can be asynchronous (dialog)
			var res = self._checkBack();
			var step;
			if (utils.isPromise(res)) {
				step = res;
			} else {
				step = $.smResolve(res);
			}
			step.then(function(kontinue) {
				if (kontinue !== true) {
					// Stop process
					return deferred.resolve(null);
				}
				log && log("History pop before" + " - win=" + window.history.length + " - app=" + self.history.length);
				// No back if a modal is open
				if (self._nbModals > 0) {
					if (event) {
						event.preventDefault();
					}
					return deferred.resolve(null);
				}
				if (self.uuid === "root" || self.history.length === 0) {
					// No application has been loaded - Goto previous browser history
					// ?? return without preventDefault doesn't continue back action on browser side
					// -> We repost a back
					window.history.back();
					return deferred.resolve(null);
				}
				if (pageFilter && self.history.length > 0) {
					var selectedIdx = -1;
					for (var i = self.history.length - 1; i >= 0; i--) {
						if (pageFilter(self.history[i])) {
							selectedIdx = i;
							break;
						}
					}
					if (selectedIdx < 0) {
						if (event) {
							event.preventDefault();
						}
						return deferred.resolve(null);
					}
					while (self.history.length > (selectedIdx + 2)) {
						var state = self.history.pop();
						var pageToRemove = $("#" + state.uuid).smPageController();
						// !! Don't remove the current page - it will be removed bythe regular process when the new page will be activated (pageLoader)
						if (pageToRemove && pageToRemove != self.currentPage) {
							pageToRemove.destroy();
						}
					}
				}
				// Remove current state
				var state = self.history.length > 0 ? self.history.pop() : null;
				if (state && (state.isWelcomePage || state.isLogin)) {
					// Homepage if login or welcome
					// ?? return without preventDefault doesn't continue back action on browser side
					// -> We repost a back

					// MW 2015-02-9 commented since it caused a double back action
					//window.history.back();
					return deferred.resolve(null);
				} else {
					// Get previous state
					state = self.history.length > 0 ? self.history[self.history.length - 1] : null;
				}
				if (event) {
					event.preventDefault();
				}
				// Force pushState on display page - Last state has been removed
				self.pushState = true;
				// self.historyLog("historyPop");
				// Open page
				if (state) {
					setTimeout(function() {
						var step;
						if (state.isWelcomePage) {
							step = self.gotoWelcomeApplication();
						} else {
							step = self._gotoPage(state, true);
						}
						step.then(function(newPage) {
							deferred.resolve(newPage);
						}).fail(function(e) {
							deferred.reject(e);
						});
					}, 0);
				}
			}).fail(function(e) {
				deferred.reject(e);
			});
			return deferred.promise();
		},
		/**
		 * Goto to previous page if any
		 * pageFilter == null	-> Goto to previous page
		 * pageFilter != null	-> Goto to selected page  - see historyPop
		 * 						   pageFilter is a function taht recieve the current hostory page state in parameter
		 * 						   it returns true to stop the historyPop
		 * 						   it's used if we want to stop at a given page
		 * Resolve 	with newPage when the new page is display
		 * 			with null if process has been canceled
		 */
		goBack: function(pageFilter) {
			var deferred = $.Deferred();
			this.historyPop(null, pageFilter).then(function(newPage) {
				deferred.resolve(newPage);
			}).fail(function(e) {
				globals.getModal().error(null, e, function() {
					deferred.reject(e);
				});
			});
			return deferred.promise();
		},
		/** 
		 * pageName - name of the page - nul/empty for homepage
		 * pageOptions - Option override standard pageInfo and allows to store a context
		 * 		{
		 *   		applicationName: allows to switch application before changing page
		 * 		}
		 * Opts - Opts methods options
		 * 		callerhandlesErrors = true  - caller handle loading errors (message and redirection)
		 * savedContext 	savedContext to restore (normapreviously the savedContext was restored on back)
		 **/
		changePage: function(pageName, pageOptions, changePageOpts, savedContext) {
			var self = this;
			pageOptions = pageOptions || {};
			changePageOpts = changePageOpts || {};
			var step;
			var switchApplication = pageOptions.applicationName && self.applicationName != pageOptions.applicationName;
			if (switchApplication) {
				step = self._switchToApplication(pageOptions.applicationName, {
					noPageChange: true
				});
			} else {
				step = $.smResolve();
			}
			return step
				.then(function() {
					if (!pageName) {
						// Go to home if no page
						pageName = self.homePageId;
					}
					var curPage;
					if (pageOptions.parentId && pageOptions.parentId.length > 0) {
						// Open a child page in fullpage mode
						curPage = globals.getController(pageOptions.parentId);
						if (!curPage) {
							throw new Error("changePage - Can't find parent page - " + pageOptions.parentId);
						}
					} else {
						curPage = self.currentPage;
					}
					return pageRegistry.getPageInfo(pageName, pageOptions, curPage);
				})
				.then(function(pageInfo) {
					if (switchApplication !== true && self.currentPage && self.currentPage.isSamePage(pageInfo)) {
						return $.smResolve(self.currentPage);
					}
					if (savedContext) {
						// We want to restore savedContext so we copy it in the state provided by meta-data
						pageInfo["savedContext"] = savedContext;
					}
					return self._gotoPage(pageInfo, false, {
						dontDisplayLoadErr: changePageOpts.callerhandlesErrors,
						// Just to inform the page loader that it's not the regular process (back)
						restoreSavedContext: savedContext != null
					});
				})
				.fail(function(e) {
					self.waitWheelStop();
					var next = e && e.$redirectPage || "welcomePage";
					if (next === "current" && self.currentPage) {
						self.refreshPage();
					} else if (next === "login") {
						self.gotoLogin(locale.text("login.timeout.message"), true);
					} else if (changePageOpts.callerhandlesErrors !== true) {
						// callerhandlesErrors = true means that it's the caller that will hanlde the redirection
						// 	On an error, we will go to the welcome page
						if (e && e.$noConnectionError == true) {
							self.gotoWelcomeApplication();
						} else {
							globals.getModal().error(null, e, function() {
								self.gotoWelcomeApplication();
							});
						}
					}
					return (e);
				});
		},
		logout: function(msgOrLocaleId, isError, offlineHint) {
			var deferred = $.Deferred();
			var self = this;
			var _loggedOut = function() {
				log && log("User Logged out");
				globals.clearUserCtx();
				deferred.resolve();
				if (!msgOrLocaleId) {
					isError = false;
				}
				var text = locale.textNoFail(msgOrLocaleId);
				if (!text) {
					// We assume it's a message (X3...)
					text = msgOrLocaleId;
				}
				self.gotoLogin(text, isError, offlineHint);
			};
			self.waitWheelStart();
			auth.logout().then(function(ok, message) {
				self.waitWheelStop();
				if (ok) {
					_loggedOut(msgOrLocaleId);
				} else {
					_loggedOut(message);
				}
			}).fail(function(e) {
				self.waitWheelStop();
				modal.error("Logout error", e, function() {
					_loggedOut();
				});
			});
			return deferred.promise();
		},

		/**
		 * Refresh current page - called from eventListener
		 */
		refreshPage: function(options) {
			var self = this;
			if (!self.currentPage || self.currentPage.destroyed) {
				// If an exception occurs during page loading we can have currentPage.destroyed
				self.gotoWelcomeApplication();
				return;
			}
			self.currentPage.refresh(options).then(function() {
				//	Eventually do something in vignette control	
			}).fail(function(e) {
				globals.getModal().error(locale.text("err.load.main"), e, function() {
					var next = e && e.$redirectPage;
					if (next === "login") {
						self.gotoLogin(locale.text("login.timeout.message"), true);
					} else {
						self.gotoWelcomeApplication();
					}
				});
			});
		},
		/**
		 * One waiting plugin per page
		 */
		waitWheelStart: function() {
			uiutils.waitWheelStart(this._wait);
		},
		waitWheelStop: function() {
			uiutils.waitWheelStop(this._wait);
		},
		getMessageSlot: function() {
			if (!this._$$actMsgSlot) this._$$actMsgSlot = {};
			var deviceType = globals.getSiteLayout().getDeviceType();
			var orientation = globals.getSiteLayout().getPageOrientation();
			var key = deviceType + orientation;
			if (this._$$actMsgSlot[key]) return this._$$actMsgSlot[key];
			var $$slot = this._$$actMsgSlot[key] = $("<div>").addClass("s-m-act-msg-slot").addClass(deviceType).addClass(orientation);
			this.$$elmt.prepend($$slot);
			return $$slot;
		},
		_actPinPage: function() {
			var self = this;
			var pin = false;
			var liveTileRemove = false;
			var nativeLiveTile = self.currentPage.nativeCapabilities.liveTile ? native.getModule("liveTile") : null;
			settings.isPinnedPage(self.currentPage.getPinPageId())
				.then(function(isPinned) {
					pin = !isPinned;
					var message = locale.text("pin.page." + (pin ? "add" : "remove") + ".confirm");
					return globals.getModal().simpleConfirmPromise({
						message: message
					});
				})
				.then(function(result) {
					if (result.action !== "yes") return;
					self._addRemovePinPage(pin);
				})
				.fail(function(e) {
					globals.getModal().error(e);
				});

		},
		removeAllChildPages: function($$elmt) {
			if (!$$elmt) return;
			if (!$$elmt.jquery) $$elmt = $($$elmt);
			var exclude = Array.prototype.slice.call(arguments, 1);
			$$elmt.children(".s-m-page").each(function(idx) {
				var page = $(this).smPageController();
				if (page && Array.prototype.indexOf.call(exclude, page) == -1) {
					page.destroy();
				}
			});
		},
		getHistory: function() {
			return this.history;
		},
		_nativeGetContextToRestore: function() {
			var self = this;
			if (!self.currentPage || self.currentPage.state.isLogin || self.currentPage.state.isWelcomePage) return null;
			var stackHistory = [];
			if (self.history) {
				self.history.forEach(function(state) {
					// Don't restore child pages - TODO
					if (state.isLogin || state.isWelcomePage || (state.options && state.options.parentId != null)) return;
					stackHistory.push(state);
				});
			}
			//stackHistory contains the actual pages to restore
			var history = null;
			// We skip the last state (currentState to restore) and push the other ones in history
			var start = stackHistory && stackHistory.length > 0 ? stackHistory.length - 2 : -1,
				state;
			for (var i = start; i >= 0; i--) {
				state = stackHistory[i];
				if (!history) {
					history = [];
				}
				history.unshift(state);
				if (state.name === self.homePageId) break;
			}
			var context;
			if (self.currentPage.isChild) {
				// Current page is not the current state to restore (child pages not restored)
				// We take the last state of stackHistory (parent page of child pages)
				var state = stackHistory[stackHistory.length - 1];
				if (!state) return;
				context = {
					endpoint: globals.getEndpoint(),
					applicationName: state.applicationName,
					role: globals.getUserRole(),
					currentState: state
				};
			} else {
				// Current page is the current state to restore
				context = self.currentPage.getRestoreContext("nativeAppClosing");
			}
			if (!context) return;
			// Add history to context
			context.history = history;
			return context;
		},
		/**
		 * fromInitProcess	true if login occurred after initialization of the application
		 * restoredContext	Context to restore if any (url context in email link or context provided by nativeWrapper)
		 * 					We assume that enpoint is ok
		 */
		notifUserLoggedIn: function(fromInitProcess, restoredContext) {
			var self = this;
			self._restoreHistoryContext(restoredContext).then(function() {
				if (fromInitProcess === true) {
					notifications.publish(["sm.application.ready"], true);
				}
			}).fail(function() {
				// If retore context failed we goto welcome mage and notify application.ready with false
				self.gotoWelcomeApplication().always(function() {
					if (fromInitProcess === true) {
						notifications.publish(["sm.application.ready"], false);
					}
				});
			});
		},
		/**
		 * restoredContext
		 * 		historyContext to restore if any (url context in email link or context provided by nativeWrapper at initialization)
		 * 		restoredContext.history is the histpory stack
		 * 		restoredContext.currentState is the page to open
		 */
		_restoreHistoryContext: function(restoredContext) {
			var self = this;
			// Restores the context
			// -1- gotoWelcomeApplication is mandatory (this page needs to be displayed to continue)
			// If historyContext:
			// -2- Push context states in history (except the last one)
			// -3- Goto the page given by the last state
			var step = self.gotoWelcomeApplication();
			if (!restoredContext || restoredContext.applicationName == null) {
				return step;
			}
			return step.then(function() {
				var appName = restoredContext.applicationName;
				if (appName !== self.applicationName || appName !== self.uuid) {
					// Check application name
					return globals.getMetaData().getApplication(appName).then(function(app) {
						var def = $.Deferred();
						if (app) {
							def.resolve(restoredContext);
						} else {
							// Cancel historyContext
							globals.getModal().notify(locale.text("restorecontext.bad"), locale.text("restorecontext.badapp", [appName]));
							restoredContext = null;
							def.resolve();
						}
						return def.promise();
					});
				} else {
					// History is Ok
					return $.smResolve(restoredContext);
				}
			}).then(function() {
				if (!restoredContext || !restoredContext.currentState) return null;
				if (restoredContext.history && restoredContext.history.length > 0) {
					// Restores the stack if any - No stack for page link only for close/resume application
					restoredContext.history.forEach(function(state) {
						self.history.push(state);
					});
				}
				var opts = $.extend(true, {}, restoredContext.currentState.options);
				opts.applicationName = restoredContext.applicationName;
				return self.changePage(restoredContext.currentState.name, opts, null, restoredContext.currentState.savedContext);
			});
		},
		/**
		 * Interface called by smWrapperJS
		 */
		nativeWrapperJSInterface: function(moduleName, action) {
			var self = this;
			if (moduleName === "nativeApp" && action === "applicationClosing") {
				// Called when application close (onBeforeUnload in test mode)
				// Returns histopry context stringify
				var ctx = self._nativeGetContextToRestore(true);
				//console.log(JSON.stringify(ctx, null, 2));
				return ctx ? JSON.stringify(ctx, null, 2) : null;
			}
			if (moduleName === "nativeApp" && action === "backButtonPressed") {
				// returns false to let the native wrapper handle the back action
				if (!self.currentPage || self.currentPage.state.isLogin || self.currentPage.state.isWelcomePage) {
					// On the login page, we can never go back, let the wrapper handle the back button
					return false;
				}
				setTimeout(function() {
					// No result expected from historyPop
					self.goBack();
				});
				// True to tell the wrapper that it's the application taht handles the back
				return true;
			}
			if (moduleName === "nativeApp" && action === "applicationActivated") {
				if (!self.currentPage || !self.currentPage.state.isLogin) {
					return;
				}
				// If we are on the login page, we reload it to allow to detect online mode changes
				// If we do not do this, the user has to do an offline login (with hidden user and password fields) 
				// to do an online login again later
				// self.gotoLogin();

				// Instead of the above, it's better to do a full reload.
				// Like this, depending if there is a login cookie or not, the user will end up on the 
				// login page (cookie not there) or on the welcome page (Login can be done automatically).
				// Using self.gotoLogin() will end up on the "logout" page when there is a login cookie which feels strange
				// for the user
				window.location.reload();
			}
			if (moduleName === "voiceCommands" && action === "executeVoiceCommand") {
				// cmd : {type: "openBookmark...", context: "", title:""}
				var cmd = arguments[2];
				if (!cmd) return;
				if (cmd.type === "openBookmark") {
					// Link to a page given by cmd.context
					if (!cmd.context) return;
					log && log("Bookmark: " + JSON.stringify(cmd || {}));
					self._swicthToContext(cmd.context);
					return;
				}
			}
			if (moduleName === "share" && action === "handleLink") {
				var contextId = arguments[2];
				//!! we need a connection to Syracuse server to restore a context (handle links on the same device don't work)
				var step = contextId ? sdataCommonResources.readSharedContext(contextId) : $.smResolve(null);
				step.then(function(context) {
					self._restoreHistoryContext(context);
				});
				return;
			}
		},
		/**
		 * Switch to the given context (used by voice commands)
		 * if context.endpoint -> switch endpoint
		 * switch to the given application context.applicationName
		 * if context.currentState!= null goto this page otherwise displays application home page
		 * context given by page.getRestoreContext: {
		 * 		endpoint:
		 * 		applicationName:
		 * 		currentState:
		 * }
		 */
		_swicthToContext: function(context) {
			var self = this;
			if (!context) return;
			var step, context;
			if (context.endpoint && context.endpoint !== globals.getEndpoint()) {
				// We need to swicth the endpoint
				step = initContext.switchContext(context).then(function(contextToRestore) {
					// Force gotoWelcomeApplication
					return $.smResolve(contextToRestore && contextToRestore.applicationName, true);
				});
			} else {
				// No need to switch endpoint
				step = $.smResolve(context.applicationName, false);
			}
			step.then(function(applicationName, forceGotoWelcomeApp) {
				// We need to be on the welcome application page to switch to another application
				var step = forceGotoWelcomeApp === true ? self.gotoWelcomeApplication() : $.smResolve();
				return step.then(function() {
					if (applicationName) {
						// noPageChange: true to not display homePage because 
						return self._switchToApplication(applicationName, {
							noPageChange: true
						});
					}
				});
			}).then(function() {
				if (!context.currentState) {
					// Only if no currentState
					// if we pin the homepage of an application the currentState is the home page
					// -> so we don't goto home page otherwise we have 2 home pages opened
					return self.gotoHome();
				}
				// Open the page
				var opts = $.extend(true, {}, context.currentState.options);
				return self.changePage(context.currentState.name, opts);
			}).fail(function(e) {
				if (e && e.$noConnectionError == true) {
					// Nothing - no modal
				} else {
					globals.getModal().error(e);
				}
			});
		}
	});


exports.Application = _Application;
});

define('syracuse-tablet/html/js/helpers/controller',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/articleParser','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var _Klass = utils.defineClass(
	function(id, prototype, article, options) {
		this.options = options || {};
		this.id = id || utils.UUID();
		this.prototype = prototype;
		this.article = article;
		this.rootLayout = null;
		this.dao = null;
		this._evtListener = null;
		this.isVignette = false;
		this._controlsMap = {};
		this._layoutsMap = {};
		// read/edit/create - read by default
		this.$activity = "read";
		globals.addController(this);
		notifications.subscribe(this, ["sm.lookup.selection"], 1);
		this.destroyed = false;
	}, null, {
		/**
		 * Used by page updateLayouts
		 */
		resetMaps: function() {
			this._controlsMap = {};
			this._layoutsMap = {};
		},
		destroy: function() {
			if (this.destroyed) return;
			globals.removeController(this);
			this._controlsMap = null;
			this._layoutsMap = null;
			if (this.dao) {
				this.dao.destroy();
				this.dao = null;
			}
			if (this.rootLayout) {
				this.rootLayout.destroy();
				this.rootLayout = null;
			}
			if (this.prototype) {
				this.prototype.destroy();
				this.prototype = null;
			}
			this.removeEventListener();
			notifications.unsubscribe(this);
			this.article = null;
			this.prototype = null;
			// in asynch process we sometimes need to check if controller have been destroyer - Paged loaded but controller destroyed
			this.destroyed = true;
		},
		addControl: function(c) {
			if (!c || !this._controlsMap) return;
			this._controlsMap[c.id] = c;
		},
		removeControl: function(c) {
			if (!c || !this._controlsMap) return;
			delete this._controlsMap[c.id];
		},
		addLayout: function(c) {
			if (!c || !this._layoutsMap) return;
			this._layoutsMap[c.id] = c;
		},
		getControl: function(id) {
			return this._controlsMap && this._controlsMap[id];
		},
		getLayout: function(id) {
			return this._layoutsMap && this._layoutsMap[id];
		},
		getStructElmt: function(id) {
			return this.getControl(id) || this.getLayout(id);
		},
		/**
		 * scans _controlsMap and calls callBack
		 * -> callBack returns true to stop
		 * returns control that stopped the scan
		 */
		forEachControl: function(callBack) {
			if (!callBack) return;
			var c = null;
			for (var id in this._controlsMap) {
				if (callBack(id, this._controlsMap[id])) {
					c = this._controlsMap[id];
					break;
				}
			}
			return c;
		},
		getControlByBind: function($bind) {
			for (var p in this._controlsMap) {
				if (this._controlsMap[p].$bind === $bind) return this._controlsMap[p];
			}
			return null;
		},
		setDao: function(dao) {
			if (this.dao && this.dao.destroy) this.dao.destroy();
			this.dao = dao;
		},
		isEditMode: function() {
			return this.$activity === "edit" || this.$activity === "create";
		},
		setActivity: function(activity) {
			this.$activity = activity || "read";
		},
		buildControlsTree: function(opts) {
			if (this.rootLayout) {
				this.rootLayout.destroy();
			}
			this.rootLayout = articleParser.article2Controls(this, this.article, this.prototype, opts || {});
			return this.rootLayout;
		},
		render: function($$parent, buildOpts) {
			if (!this.rootLayout) return;
			this.rootLayout.buildHtml($$parent, this.dao, buildOpts);
			// USed to retrieve the controller on events
			this.rootLayout.$$elmt.attr("data-controller-id", this.id);
		},
		/**
		 * Refresh the page
		 */
		refresh: function(options, callBackInterface) {
			throw new Error("Not implemeneted");
		},
		/**
		 * Used by refresh method to update controls after having loaded new data
		 * ids == null means all controls
		 * Returns the list controls with an error
		 */
		refreshControls: function(ids, options) {
			var self = this;
			if (self.destroyed) return;
			var errors = [];
			if (self.destroyed) return errors;
			var _refresh = function(ctrl) {
				if (!ctrl) return;
				ctrl.refresh(self.dao, options);
				if (ctrl.hasError()) {
					errors.push(ctrl);
				}
			};
			if (ids && ids.length > 0) {
				ids.forEach(function(id) {
					_refresh(self._controlsMap[id]);
				});
			} else {
				Object.keys(self._controlsMap).forEach(function(key) {
					_refresh(self._controlsMap[key]);
				});
			}
			return errors;
		},
		/** Event sm.action.link
		 *  Notified when a action succeeded - sdata link - see action manager
		 *  success:	true/false
		 *  link:		Link info
		 *  result:		Json response
		 */
		notifActionLink: function(success, link, result, options) {
			throw new Error("not implemented");
		},
		/**
		 * When we select a value in a lookup
		 * 		rowData:	Selected row  - {data, proto} - data: selected JSON data - proto - prototype of row data
		 * 		controlId:	Id of control to refresh
		 */
		notifLookupSelection: function(rowData, controlId) {
			try {
				var ctrl = this.getControl(controlId);
				if (!ctrl) throw new Error("Control not found '" + controlId + "'");
				if (!ctrl.setLookupValue) throw new Error("Control must implement setLookupValue '" + controlId + "'");
				ctrl.setLookupValue(rowData);
			} catch (e) {
				globals.getModal().error("notifLookupSelection failed", e);
			}
		},
		/**
		 * Check controls data - Edit mode only
		 * Return true if ok
		 * Display fields errors if any
		 */
		checkControlsData: function() {
			if (!this.isEditMode()) return true;
			var self = this;
			var ok = true;
			var firstError, c;
			Object.keys(self._controlsMap).forEach(function(key) {
				c = self._controlsMap[key];
				if (c && c.checkData) {
					ok = ok && c.checkData();
					if (!ok && firstError == null) firstError = c;
				}
			});
			if (firstError) {
				firstError.setFocus();
			}
			return ok;
		},
		/**
		 * Show element in page - scroll if needed
		 * c is a JQuery elmt or an object with $$elmt property
		 */
		makeVisible: function(c) {
			// TODO - Implement a gestureManager in base controller to allow makeVisible
		},
		applyChange: function(newData) {
			if (!newData || !this.dao) return;
			this.dao.applyChange(newData);
			this.refreshControls(null, {
				refreshValue: true
			});
		},
		/**
		 * Allows child controllers to listen events
		 * controller event listener is called before coaling control listener
		 * Signature		mylistener(when, ctrl, $$target, event)
		 * 					when		"before" or "after"
		 * 									"before"	call before calling control event
		 * 										return false 	to continue
		 * 										return true 	to stop the process and not call control's listener
		 * 									"after" 	call after calling control event
		 * 					ctrl		control object
		 * 					$$target	target elmt
		 * 					event		event
		 * eventName		click, change, blur...
		 */
		addEventListener: function(eventName, method) {
			if (!method || typeof method !== "function") return;
			if (!this._evtListener) {
				this._evtListener = {};
			}
			this._evtListener[eventName] = jsutils.bindFn(method, this);
		},
		removeEventListener: function(eventName) {
			if (!this._evtListener) return;
			if (eventName) {
				this._evtListener[eventName] = null;
			} else {
				for (var p in this._evtListener) {
					this._evtListener = null;
				}
			}
		},
		getEventListener: function(eventName) {
			return this._evtListener ? this._evtListener[eventName] : null;
		}
	});


exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/pages/helpers/helpers',['require','exports','module','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {"use strict";

var native = require('syracuse-tablet/html/js/helpers/native/native');
var globals = require('syracuse-tablet/html/js/helpers/globals');

/**
 * Dispatching of actions according to the type of device
 */
var _linksMap = {
	header: {
		smartphone: {
			details: {
				$edit: true,
				$delete: true
			},
			edit: {
				$canceledit: true,
				$save: true
			},
			query: {
				$create: true
			},
			create: {
				$save: true,
				$canceledit: true
			}
		},
		tablet: {}
	},
	footer: {
		smartphone: {},
		tablet: {
			details: {
				$edit: true,
				$delete: true,
				$query: true
			},
			edit: {
				$save: true,
				$canceledit: true
			},
			query: {
				$create: true
			},
			create: {
				$save: true,
				$canceledit: true
			}
		}
	},
	actionpanel: {}
};
var _isSingleItemLink = function(url) {
	// Ensure it is an sdata link and not any other external link by checking for ?representation=
	// Also check if there are brackets ( <key> ) including a key with dynamic place holders {code}
	if (/\((\S*\{\S*\}\S*)\).*\?.*representation=/.test(url)) {
		return true;
	}
	return false;
};
var _isOfficeLink = function(name, info) {
	return name.smStartsWith("$word") || name.smStartsWith("$excel") || (info.$type != null && info.$type.indexOf("openxml") >= 0);
};
var _isPaginLink = function(name) {
	return name === "$first" || name === "$previous" || name === "$next" || name === "$last";
};
/**
 * Native capabilities per page's type/subtype
 */
var _nativeCapabilities = {
	liveTile: {
		regular: {
			query: true,
			stat: true,
			cube: true
		}
	},
	scheduleMessage: {
		regular: {
			query: true,
			details: true,
			edit: false
		},
		dashboard: {
			std: true,
			welcome: false
		}
	},
	share: {
		regular: {
			query: true,
			details: true
		},
		dashboard: {
			std: true,
			welcome: false
		}
	}
};
var _nonNativeCapabilities = {
	mailto: {
		regular: {
			query: true,
			details: true
		},
		dashboard: {
			std: true,
			welcome: false
		}
	}
};
/**
 * REGULAR PAGE
 * Actions that are NOT displayed in a panel
 */
var _notInPanel = ["$edit", "$create", "$delete", "$details", "$query", "$save", "$canceledit"];
exports.excludeFromPanel = function(name, forceFooterHeader, link, facet) {
	if (_notInPanel.indexOf(name) >= 0) return true;
	if (facet === "query" && link && link.$url && _isSingleItemLink(link.$url)) return true;
	return forceFooterHeader === true;
};
/**
 * REGULAR PAGE
 * Returns false if a link is not displayed
 */
exports.checkLink = function(name, info) {
	if (info == null || info.$isExcluded === true) {
		return false;
	}
	if (_isPaginLink(name)) {
		return false;
	}
	if (name.smStartsWith('$') && _isOfficeLink(name, info)) {
		return false;
	}
	return true;
};
/**
 * REGULAR PAGE
 * Returns the links to display in toolbar according to the type of device
 */
exports.getLinkMap = function(toolbar, deviceType, facet) {
	var lMap = _linksMap[toolbar];
	if (!lMap) {
		throw new Error("Unexpected toolbar parameter [" + toolbar + "]. Expected 'header', 'footer' or 'actionpanel'");
	}
	if (toolbar === "actionpanel") return lMap;
	lMap = lMap[deviceType || "tablet"];
	if (!lMap) {
		throw new Error("Unexpected deviceType parameter [" + deviceType + "]. Expected 'tablet', 'smartphone'");
	}
	if (facet === "lookup") facet = "query";
	if (facet === "summary") facet = "details";
	lMap = lMap[facet];
	if (!lMap) {
		throw new Error("Unexpected facet parameter [" + facet + "]");
	}
	return lMap;
};
/**
 * REGULAR PAGE
 * Returns appropriate right value for where request
 * For example, for the filter 'CODE contains aa', the where clause should look like
 * CODE like '%aa%'. This function will return '%aa%'
 */
exports.setFilterRightValue = function(filter) {
	var cp = filter.prop;
	var cv, value = (filter.originalValue || filter.value) == null ? "" : (filter.originalValue || filter.value);
	switch (cp.$type) {
		case "application/x-password":
		case "application/x-string":
			cv = value.replace(/'/g, "\\'");
			if (filter.operator === "like") cv = '%' + cv + '%';
			else if (filter.operator === "like_s") cv = cv + '%';
			cv = "'" + cv + "'";
			return cv;
		case "application/x-integer":
		case "application/x-real":
		case "application/x-decimal":
		case "application/x-quantity":
			return value;
		case "application/x-date":
			if (!value) return null;
			return '@' + value + '@';
		case "application/x-datetime":
			return '@' + value + '@';
		case "application/x-time":
			return null;
		case "application/x-boolean":
			return value ? "true" : "false";
		case "application/x-choice":
			if (cp.$value && cp.$value.$type === "application/x-string") {
				return "'" + value.replace(/'/g, "\\'") + "'";
			} else return value + "";
			break;
		case "application/x-reference":
			if (typeof value != "string") {
				value = filter.value;
			}
			cv = (value || '').replace(/'/g, "\\'");
			cv = "'" + cv + "'";
			return cv;
		default:
			break;

	}
	return null;
};

var _pageSubType = function(page) {
	return page ? page.state.subtype.split(" ")[0] : null;
};
//Need to be called after module's initialization
exports.getNativeCapabilities = function(page) {
	var result = {};
	if (!page || !page.state || !page.state.type || !page.state.subtype) return result;
	var subtype = _pageSubType(page),
		pageCapability;
	["liveTile", "scheduleMessage", "share"].forEach(function(capability) {
			pageCapability = _nativeCapabilities[capability];
			result[capability] = pageCapability && native.hasCapability(capability);
			if (result[capability]) {
				result[capability] = pageCapability[page.state.type] != null && pageCapability[page.state.type][subtype] === true;
			}
		});
	return result;
};
/**
 * Capabilities available in non-native mode
 */
exports.getNonNativeCapabilities = function(page) {
	var result = {};
	if (globals.isNativeModeEnabled() || !page || !page.state || !page.state.type || !page.state.subtype) {
		return result;
	}
	var subtype = _pageSubType(page);
	var cpblties;
	["mailto"].forEach(function(cpb) {
		cpblties = _nonNativeCapabilities[cpb];
		result[cpb] = cpblties && cpblties[page.state.type] != null && cpblties[page.state.type][subtype] === true;
	});
	return result;
};
//!! Array sorted from top position to bottom
exports.insidePageControls = ["header", "breadcrumbs", "topToolbar", "footer"];
exports.topPageControls = ["header", "breadcrumbs", "topToolbar"];
});

define('syracuse-tablet/html/js/pages/helpers/panelsManager',['require','exports','module','syracuse-tablet/html/js/pages/helpers/helpers','syracuse-tablet/html/js/controls/ctrlFactory'],function (require, exports, module) {"use strict";

var pageHelpers = require('syracuse-tablet/html/js/pages/helpers/helpers');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');

/*********** PANELS MANAGER ***********
 * !! Created/Destroyed only on main page (not on vignettes)
 * page		Main/Current page
 *************************************/
var _PanelManager = function(page) {
	this.controller = page;
	this.$$dismissPanel = page.$$elmt.children(".s-m-side-panel-dismiss");
	this.$$panels = {
		left: page.$$elmt.children("aside.s-m-panel.s-m-left"),
		right: page.$$elmt.children("aside.s-m-panel.s-m-right")
	};
	/**
	 *
	 */
	this.destroy = function() {
		this.controller = null;
		this.$$dismissPanel = null;
		this.$$panels = null;
	};
	/**
	 *
	 */
	this.checkDestroyed = function() {
		return this.controller == null || this.$$dismissPanel == null || this.controller.destroyed;
	};
	/**
	 * Adds a panel to left or right sections - sidePanel class
	 *  If not exists create it
	 * where	"left" or "right"
	 * panel	panel object
	 */
	this.panelAttach = function(where, panel, action) {
		if (this.checkDestroyed() || !panel || (where != "right" && where != "left")) return;
		var currentPanel = this.controller.getPageControl(where);
		if (currentPanel && currentPanel != panel) {
			this.panelDetach(where);
		}
		if (!panel.isAttached(where)) {
			var $$parent = this.$$panels[where];
			if ($$parent.length != 1) return;
			// Add the control to the list
			this.controller.addControl(panel);
			this.controller._pageControls.add(where, panel).attach($$parent, where);
		}
		return this.panelToggle(where, panel, action);
	};
	/**
	 * Toggle panel
	 * where: left/right
	 * panel: control panel
	 * action: toggle/close/resize
	 */
	this.panelToggle = function(where, panel, action) {
		var self = this;
		if (self.checkDestroyed()) {
			return;
		}
		var $$root = self.$$panels[where];
		if (!$$root) {
			return;
		}
		if (!panel) {
			panel = self.controller.getPageControl(where);
		}
		if (!panel || !panel.$$elmt) {
			return null;
		}
		var wasVisible = $$root.is(':visible');
		if (action === "resize") {
			if (!wasVisible) return null;
			//Panel already visible
		} else {
			$$root.toggle(action === "close" ? false : undefined);
		}
		var isVisible = $$root.is(':visible');
		if (wasVisible !== isVisible) {
			// Only if status changed
			// Toggle before calculating the new width
			panel.notifyToggled(where, action, isVisible);
		}
		var newWidth = isVisible ? $$root.width() : 0;
		if (panel.closeBox != true) {
			self.$$dismissPanel[isVisible ? "addClass" : "removeClass"](where).css(where, newWidth);
		}
		if (panel.overlap != true) {
			// Shifts $$contentElmt and "insidePageControls" (header footer breadcrumb) elements
			var shiftElmts = [self.controller.$$contentElmt];
			pageHelpers.insidePageControls.forEach(function(id) {
				var c = self.controller.getPageControl(id);
				if (c && c.$$elmt) {
					shiftElmts.push(c.$$elmt.parent());
				}
			});
			shiftElmts.forEach(function($$elmt) {
				$$elmt.css("left", (isVisible ? (where === "right" ? -1 : 1) * newWidth : 0) + "px");
			});
		}
		return panel;
	};
	/**
	 * Removes the panel but not destroy it
	 * where	"left" or "right"
	 */
	this.panelDetach = function(where) {
		if (this.checkDestroyed()) return;
		var p = this.controller.getPageControl(where);
		if (!p) return;
		this.panelToggle(where, p, "close");
		this.controller.removeControl(p);
	};
	/**
	 * Returns a panel - Just to have ctrlFactory declared here
	 * id	globals.PANELACTIONSREGULAR, globals.PANELUSERSMARTPHONE, globals.PANELFILTERSORT
	 * actionController: controller that handles actions (in vignette it'sthe one of the vignette)
	 */
	this.panelCreate = function(panelId, options, actionController) {
		// Extended top preserve original options
		options = $.extend({}, options);
		// controller of the control is the current page because we could need to access to this page from the panel (Ex for a panel attached to a vignette)
		return ctrlFactory.createPanel(actionController || this.controller, panelId, options);
	};
	/**
	 * Call resize method of current panels
	 */
	this.panelResize = function(context) {
		context = context || {};
		var self = this;
		setTimeout(function() {
			self.forEachPanel(function(where, panel) {
				if (context.deviceChanged === true) {
					self.panelToggle(where, panel, "close");
					return;
				} else {
					self.panelToggle(where, panel, "resize");
					if (panel.onResize) {
						panel.onResize(context);
					}
				}
			});
		});
	};
	this.forEachPanel = function(cb) {
		if (this.checkDestroyed()) return;
		var controller = this.controller;
		["right", "left"].forEach(function(w) {
			var p = controller.getPageControl(w);
			if (p) cb(w, p);
		});
	};
};

exports.Klass = _PanelManager;
});

define('syracuse-tablet/html/js/pages/helpers/pageControlsManager',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/pages/helpers/helpers'],function (require, exports, module) {"use strict";

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var pageHelpers = require('syracuse-tablet/html/js/pages/helpers/helpers');

/*********** PAGE CONTROLS MANAGER ***********
 * Page controls are not attached to rootLayout
 * header/footer/breadcrumbs...
 ************************************************/
var PageControlsManager = function(page) {
	this.page = page;
	this.map = {};
	this.statics = {};
	this.add = function(id, ctrl) {
		if (!ctrl) return;
		if (this.map[id]) {
			console.log("Page Control " + id + " already exists");
		}
		this.map[id] = ctrl;
		if (pageHelpers.insidePageControls.indexOf(id) >= 0) {
			this.statics[id] = ctrl;
		}
		return ctrl;
	};
	this.get = function(id) {
		return this.map[id];
	};
	this.remove = function(ctrl) {
		if (!ctrl) return;
		var ctrlType = null;
		for (var id in this.map) {
			if (this.map[id] === ctrl) {
				ctrlType = id;
				break;
			}
		}
		if (ctrlType) {
			// Delete - Do not set to undefined because we want to remove the entry
			delete this.map[ctrlType];
			delete this.statics[ctrlType];
		}
		if (ctrl.detach) {
			ctrl.detach();
		} else if (ctrl.$$elmt) {
			ctrl.$$elmt.detach();
		}
		return ctrl;
	};
	this.destroyControls = function() {
		if (!this.map) return;
		var c;
		for (var id in this.map) {
			c = this.map[id];
			// SidePanel: it's the responsibility of the creator to destroy it
			if (c && !jsutils.isInstanceOf(c, "SidePanel")) {
				c.destroy();
			}
		}
		this.map = {};
		this.statics = {};
	};
	this.status = function() {
		var x = [];
		for (var id in this.map) {
			x.push(id + "=" + this.map[id].id);
		}
		return x.join('/');
	};
	this.destroy = function() {
		this.page = null;
		this.destroyControls();
	};
	/**
	 * Only on static controls header/footer
	 */
	this.buildHtml = function(dao, buildOptions) {
		for (var id in this.statics) {
			var $$parent = this.page.$$elmt.children(id); // id = tag name of container (for footer/header)
			if ($$parent.length < 1) {
				$$parent = this.page.$$elmt.children(".s-m-" + id); // id = class name tag name of container (for breadcrumbs)
			}
			this.statics[id].buildHtml($$parent, dao, buildOptions);
		}
	};
	this.afterRender = function(buildOpts) {
		for (var id in this.statics) {
			if (this.statics[id].afterRender) this.statics[id].afterRender(buildOpts);
		}
	};
	/**
	 * All controls header/footer/leftPanel/rightPanel
	 */
	this.forAllCtrls = function(cb) {
		for (var id in this.map) {
			cb(id, this.map[id]);
		}
	};
	this.closeSidePanel = function() {
		// TODO
	};
	// Called when we skip controls - Refresh them
	this.doAfterPageReload = function(addToControlMap) {
		var c;
		for (var id in this.map) {
			var c = this.map[id];
			// Put the controls in control map
			if (addToControlMap) {
				this.page.addControl(c);
			}
			// Refresh the controls 
			if (c.refresh) {
				c.refresh();
			}
		}
	};
};

exports.Klass = PageControlsManager;
});

define('syracuse-tablet/html/js/pages/page',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/uiSettings','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/controller','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/controls/ctrlFactory','syracuse-tablet/html/js/helpers/scroller/scrollerHelpers','syracuse-tablet/html/js/application/settings','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/sdata/sdataCommonResources','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/pages/helpers/helpers','syracuse-tablet/html/js/pages/helpers/panelsManager','syracuse-tablet/html/js/pages/helpers/pageControlsManager'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/helpers/controller').Klass;;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("page");
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');
var settings = require('syracuse-tablet/html/js/application/settings');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var native = require('syracuse-tablet/html/js/helpers/native/native');
var sdataCommonResources = require('syracuse-tablet/html/js/sdata/sdataCommonResources');
var nativeExtLink = require('syracuse-tablet/html/js/helpers/native/native').getModule("extLink");
var pageHelpers = require('syracuse-tablet/html/js/pages/helpers/helpers');
var PanelManager = require('syracuse-tablet/html/js/pages/helpers/panelsManager').Klass;
var PageControlsMgr = require('syracuse-tablet/html/js/pages/helpers/pageControlsManager').Klass;

/**
 * s-m-side-panel-dismiss: div that traps the events outside the panel when a panel if open
 */
var _templates = {
	fullpage: '\
		<section class="s-m-page s-m-full {{type}} {{subtype}}" id="{{pageid}}" {{#if parentId}}data-parent-id="{{parentId}}"{{/if}}> \
			<header></header> \
			<section class="s-m-breadcrumbs" style="display:none"></section> \
			<section class="s-m-topToolbar"  style="display:none"></section> \
			<section class="s-m-main-content"></section> \
			<footer style="display:none"></footer> \
		</section> \
	',
	vignette: '<section class= "s-m-page s-m-nested {{type}} {{subtype}}" id="{{pageid}}"></section>',
	panels: '\
		<div class="s-m-side-panel-dismiss" data-action="toggleSidePanel" data-params="close,all"></div> \
		<aside class="s-m-panel s-m-left"></aside> \
		<aside class="s-m-panel s-m-right"></aside>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx || {});
};

/****************** PAGE CLASS *********************
 * Base class for all pages
 *  $$parent: Parent element
 * 	state: Page information - JSON structure stored in history
 *  prototype: Prototype object (class prototype)
 *  article: JSON article
 *  !! Temporarily prototype and article can be null for html pages
 ***************************************************/
var _defOpts = {
	header: true,
	footer: true,
	breadcrumbs: false,
	topToolbar: false
};

var _Page = utils.defineClass(
	function Page($$parent, state, prototype, article, options) {
		Base.call(this, state.uuid, prototype, article, $.extend({}, _defOpts, options));
		this.views = options.views;
		this._pageControls = null;
		this._panelsManager = null;
		this._$$parent = $$parent;
		this.state = state;
		this.state.options = state.options || {};
		this.ctrlAfterRenderCalls = [];
		this.ctrlSaveCtxCalls = [];
		this._offline = false;
		this.isVignette = state.options.vignette === true;
		this.isChild = state.options.parentId != null;
		this.nativeCapabilities = pageHelpers.getNativeCapabilities(this);
		this.nonNativeCapabilities = pageHelpers.getNonNativeCapabilities(this);
		if (this.isChild) {
			// Children pages are cached - no destry if we open a child page from this page
			this.state.cached = true;
		}
		this._initRootElmt($$parent);
		// true if page is created - set by page loader when page is activated
		this.isNew = false;
		// Last selected row - Used to save/restore context of last selected row
		this.lastSelectedRow = null;
		this.nbCharts = 0;
		// Panel that displays shared Settings
		this._panelSharedSettings = null;
		notifications.subscribe(this, ["sm.select.row", "sm.updt.card.article", "sm.updt.chart.detail.article", "sm.scroller.update"], 1);
	}, Base, {
		resetMaps: function() {
			Base.prototype.resetMaps.call(this);
			// Contains controls that need to be called after Render - outside pageControls
			this.ctrlAfterRenderCalls = [];
			// Contains controls that have a context to save in order to retrieve it when page will be load (eg: back navigation)
			this.ctrlSaveCtxCalls = [];
		},
		/**
		 * Create and return root DOM element of every page
		 * 		DOM element is hidden and contains only the structure
		 * 		Page object is stored in DOM element under data("smcontroller")
		 */
		_initRootElmt: function($$parent) {
			var self = this;
			var type = self.state.type;
			var root, ctx = {
					pageid: self.id,
					type: type, // regular/html/dashboard
					subtype: self.state.subtype, // regular - > facet - dashboard -> std/welcome/home - html -> login/about...
					parentId: self.getParentId()
				};
			if (self.isVignette) {
				// only content in a vignette
				self.$$contentElmt = self.$$elmt = $(_getHtml("vignette", ctx));
				if (self.state.options.parentVignette == null) throw new Error("Unexpected null dparent vignette");
				// for a vignette _panelsManager is the dashboard one - Eg: used to display filters and sort in query vignette
				self._panelsManager = self.state.options.parentVignette.controller._panelsManager;
			} else {
				self.$$elmt = $(_getHtml("fullpage", ctx));
				self.$$contentElmt = self.$$elmt.children("section.s-m-main-content");
				// Page controls only for main page
				self._pageControls = new PageControlsMgr(self);
				var shift = 0;
				pageHelpers.topPageControls.forEach(function(id) {
					if (self.options[id] === true) {
						shift += uiSettings.getProp(id + ".height");
					}
				});
				if (shift > 0) {
					// It's better to fix the top before mainResize even if it can change
					// When we restore context (scroll...) on back we need that because restore context is done before mainREsize
					self.$$contentElmt.css({
						top: shift
					});
				};
				// Add pannels
				self.$$elmt.append($(_getHtml("panels")));
				self._panelsManager = new PanelManager(self);
			}
			if (self.scrollAllowed()) {
				// Scroll in page is allowed for $details and $edit
				// For dashboard this is the layout which scrolls (not the page)
				// For query this si the array  which scrolls (not the page)
				// Only if scroll allowed - Ex: In wignette with charts we musn't have the scroll wrapper becaus eit breaks size calculation 
				self.$$scrollWrapper = $('<div class="s-m-scroll-wrapper"/>').appendTo(self.$$contentElmt);
				self.$$scrollWrapper.css({
					height: "auto"
				});
				self.$$ctrlsRootElmt = self.$$scrollWrapper;
				// Create scroll manager here because it must be created when we restore the context on back
				self._gestureMgr = scroller.newScroller(self.$$scrollWrapper, {
					// isPageScroller: true for full page
					// isPageScroller: false for vignette - The view rectangle scolls with the content of the page
					isPageScroller: !self.isVignette
				});
			} else {
				self.$$ctrlsRootElmt = self.$$contentElmt;
			}
			self.$$elmt.hide();
			self.$$elmt.appendTo($$parent);
			// attaches page object to DOM element
			// !!Important because it allows the application/vignette to remove all pages/subpages by using the dom - See application.removeAllChildPages
			self.$$elmt.smPageController(self);
		},
		destroy: function() {
			if (this.destroyed) return;
			// Fisrt to destroy the rootLayout
			Base.prototype.destroy.call(this);
			// Destoy own stuff
			this._$$parent = null;
			if (this._pageControls) {
				this._pageControls.destroy();
				this._pageControls = null;
			}
			if (this._panelsManager) {
				if (!this.isVignette) {
					this._panelsManager.destroy();
				} // for a vignette _panelsManager is the dashboard one
				this._panelsManager = null;
			}
			if (this._waiting) {
				uiutils.waitWheelDestroy(this._waiting);
				this._waiting = null;
			}
			this.ctrlAfterRenderCalls = null;
			this.ctrlSaveCtxCalls = null;
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
			if (this.$$elmt) {
				this.$$elmt.smPageRemoveController(this);
				this.$$elmt.unbind();
				this.$$elmt.remove();
				this.$$elmt = null;
			}
			if (this._panelSharedSettings) {
				notifications.unsubscribe(this, "sm.page.share");
				this._panelSharedSettings.destroy();
				this._panelSharedSettings = null;
			}
		},
		/**
		 * Called be pageLoader - TODO TEST
		 */
		destroySiblings: function() {
			if (this.$$elmt) {
				log && log("Page destroySiblings", "destroySiblings");
				var next = this.$$elmt.siblings(function(idx) {
					var ctrl = $(this).smPageController();
					if (ctrl) ctrl.destroy();
				});
			}
		},
		_actPageShare: function() {
			if (native.hasCapability("liveTile")) {
				if (!this._panelSharedSettings) {
					notifications.subscribe(this, "sm.page.share");
					this._panelSharedSettings = this.panelCreate(globals.PANELPAGESHARE);
				}
				this.panelAttach("right", this._panelSharedSettings, "toggle");
			}
		},
		getPageShareContext: function() {
			var settings = {
				opt: this.nativeCapabilities,
				ctx: {
					pageTitle: this.state.$title
				},
				vignettes: []
			};
			if (this.vignettes) {
				this.vignettes.forEach(function(vignette) {
					var page = vignette.getPage();
					if (page && page.showPageShare()) {
						settings.vignettes.push({
							id: vignette.id,
							opt: page.nativeCapabilities,
							ctx: {
								pageTitle: page.state.$title || vignette.parent.title
							}
						});
					}
				});
			}
			return settings;
		},
		/**
		 * dashboard/regular/html
		 */
		getType: function() {
			return this.state.type;
		},
		/**
		 * Allows prop = "options.parentId"
		 */
		getProp: function(prop) {
			return utils.getPropByPath(this.state, prop);
		},
		/**
		 * typeControl: "header", "breadcrumbs", "topToolbar", "footer"
		 */
		getPageControl: function(typeControl) {
			return this._pageControls ? this._pageControls.get(typeControl) : false;
		},
		/**
		 * Set by vignette at page loading
		 */
		openLinkInVignette: function() {
			return this.state.options.openLinkInVignette === true;
		},
		/**
		 * Load the page
		 * 		The result is that the page is created and attached to DOM document and hidden
		 * 		the contoller of the page (applictaion/vignette) has to call activate method to display the page (see pageLoader module)
		 * loadOptions:
		 * 		updateLayout -> true to not load the data and update only main layout
		 */
		load: function(loadOptions) {
			var self = this;
			loadOptions = loadOptions || {};
			var timeLine = utils.getTimeLine("page", self.state.name);
			timeLine && timeLine.start();
			return $.smResolve()
				.then(function() {
					return self.initOnLoad();
				})
				.then(function() {
					return self.buildHtmlOption(loadOptions);
				})
				.then(function(opts) {
					self.buildOpts = opts;
					return self.loadStructure(loadOptions);
				})
				.then(function() {
					timeLine && timeLine.step("loadStructure");
					if (self.destroyed) {
						return;
					}
					return self.loadData(loadOptions);
				})
				.then(function() {
					timeLine && timeLine.step("loadData");
					if (self.destroyed) {
						return;
					}
					return self.render(loadOptions, self.buildOpts);
				})
				.then(function() {
					timeLine && timeLine.step("render");
					if (self.destroyed) {
						return;
					}
					return self.afterRender(loadOptions, self.buildOpts);
				})
				.then(function() {
					timeLine && timeLine.stop();
				});
		},
		/**
		 * Create layout/control tree structure according to article
		 */
		loadStructure: function(loadOptions) {
			var self = this;
			return $.smResolve().then(function() {
				if (!self.article || !self.prototype) throw new Error("loadStructure - NULL article or prototype");
				if (self._pageControls && loadOptions.skipPageControls !== true) {
					var top = 0;
					pageHelpers.insidePageControls.forEach(function(id) {
						if (self.options[id] === true) {
							var ctrl = self.createPageControl(id);
							if (ctrl) {
								// Save orginal header in case we can change it (vignette context) _pageHeader, _pageFooter...
								self["_page" + id.smCapitalize()] = self._pageControls.add(id, ctrl);
								if (pageHelpers.topPageControls.indexOf(id) >= 0) {
									// Save root and show - _$$breadcrumbs, _$$topTolBar
									self["_$$" + id] = self.$$elmt.children("section.s-m-" + id).show().css("top", top);
									// Set top in advanced to avoid moving elements
									top += uiSettings.getProp(id + ".height");
								}
							}
						};
					});
				}
				// Creates control / fields tree(from article)
				var opts = {
					// If edit/create in vignette we need to notify focus on fields to enbable/disable vignette selection
					notifyFocus: self.isVignette && self.isEditMode()
				};
				self.buildControlsTree(opts);
			});
		},
		/**
		 * Can be overridden
		 */
		createPageControl: function(id) {
			return ctrlFactory.createPageControl(id, this);
		},
		/**
		 * Load page data
		 */
		loadData: function(loadOptions) {
			var self = this;
			return $.smResolve().then(function() {
				self.setDao(null);
			});
		},
		/**
		 * Rendering - Build html and attachs dom elements to document
		 */
		render: function(loadOptions, buildOpts) {
			var self = this;
			return $.smResolve().then(function() {
				if (!self.rootLayout) {
					throw new Error("buildHtml - NULL rootLayout");
				}
				// Renders header/footer
				if (self._pageControls && loadOptions.skipPageControls !== true) {
					self._pageControls.buildHtml(self.dao, buildOpts);
				}

				if (self.$$ctrlsRootElmt) {
					self.beforeAddContent();
					// Renders tree controls (article)
					Base.prototype.render.call(self, self.$$ctrlsRootElmt, buildOpts);
				}
			});
		},

		/*
		 * First action (deferred) called on page loading
		 * Can be used to cache data from async operations that are needed later in
		 * page loading in sync processes
		 */
		initOnLoad: function() {
			return $.smResolve();
		},

		/**
		 * return build options for controls
		 * Set options for all controls
		 * Header -> options for header control
		 * Can be overridden
		 */
		buildHtmlOption: function(loadOptions) {
			var self = this;
			var resultOpts = {
				authoringUpdate: loadOptions.authoringUpdate === true,
				updateLayout: loadOptions.updateLayout === true,
				makeFullHeight: self.isVignette,
				toolBars: {
					showAuthoring: self.state.disableAuthoring !== true,
					showUserMenuLinks: !self.isChild,
					showHome: !self.isChild && !this.state.isWelcomePage,
					showActions: true,
					showNativeShare: self.nativeCapabilities.share,
					showPageShare: self.showPageShare(),
					showPageMailto: this.nonNativeCapabilities["mailto"] === true,
					showDrafts: true,
					showDevelopment: globals.isDesktop() && globals.isDvlpMode()
				}
			};
			return settings.isPinnedPage(self.getPinPageId())
				.then(function(isPinned) {
					resultOpts.toolBars.statusPinPage = !self.isChild ? (isPinned ? 2 : 1) : 0;
				})
				.then(function() {
					if (self.isChild) {
						// Child pages are not allowed to be authored, except for lookups
						if (self.$facet === "lookup") {
							resultOpts.showAuthoring = resultOpts.showAuthoring && true;
						} else {
							resultOpts.showAuthoring = false;
						}
					}
				})
				.then(function() {
					return resultOpts;
				});
		},
		/**
		 * Called from authoring to update the page's article
		 */
		authUpdateLayout: function(article, options) {
			this.article = article;
			options = options || {};
			options.authoringUpdate = true;
			return this.reload(options);
		},
		/**
		 * Same as reload - Reload the page by default
		 * Overridden - pageRegular refresh sdataUrl....
		 */
		refresh: function(options, callBackInterface) {
			var self = this;
			if (!self.isActive()) {
				// in some case we've to acticate the page
				return $.smResolve().then(function() {
					var deferred = $.Deferred();
					self.activate(null, function() {
						return deferred.resolve();
					});
					return deferred.promise();
				}).then(function() {
					return self.reload();
				});
			} else {
				return this.reload();
			}
		},
		/**
		 * Reload page - Only Data
		 */
		reload: function(options) {
			var self = this;
			self.waitWheelStart();
			// Init controsl maps
			self.resetMaps();
			// destroy all controls and layouts
			self.rootLayout.destroy();
			// $pageActionSettings needs to redraw the header/footer
			var updatePageControls = (self.article.$allowDownload != null || self.article.$pageActionSettings != null) && self._pageControls != null;
			if (updatePageControls) {
				self._pageControls.destroyControls();
			}
			// Clear dom
			self.$$ctrlsRootElmt.empty();
			options = options || {};
			// Reload with updateLayout and skipPageControls option
			// 	-> don't load data
			//	-> don't create page controls
			// Don't forget to check overridden method if we add new properties in options
			if (options.updateLayout == null) {
				// options.updateLayout can be != null - In certain rare cases we want to force to load data
				options.updateLayout = true;
			}
			options.reload = true;
			options.skipPageControls = updatePageControls === false;
			return self.load(options).then(function() {
				// Add page controls to maps
				if (self._pageControls) {
					self._pageControls.doAfterPageReload(options.skipPageControls);
				}
				// Recalculate layouts
				uiutils.triggerResizeInternal(options);
			}).then(function() {
				self.waitWheelStop();
			}).fail(function(e) {
				self.waitWheelStop();
				globals.getModal().error("Error", e);
			});
		},
		/**
		 * Resize of application main page
		 * info give the size in pixels of mainContent/header/footer - see siteLayout
		 * We need it to pass to rootLayout without having to set the size od $$contentElmt
		 * $$contentElmt must have css.height set to auto for scrolling
		 * info.updateLayout = true if page updated by authoring
		 */
		onMainPageResize: function(info, orientation, deviceType) {
			var self = this;
			if (self.destroyed) return;
			if (!this.isVignette) {
				if (this._prevPageInfo == null || info.orientationChanged || info.deviceChanged) {
					if (this._prevPageInfo) {
						this.$$elmt.removeClass(this._prevPageInfo.deviceType + " " + this._prevPageInfo.orientation);
					}
					this.$$elmt.addClass(deviceType + " " + orientation);
					if (info.deviceChanged) {
						// Restore the regular header/footer - Modified by actions in vignettes
						// Needed to apply onMainPageResize on the right controls
						this.toggleHeaderFooter("header", null, true);
						this.toggleHeaderFooter("footer", null, true);
					}
					this._prevPageInfo = {
						deviceType: deviceType,
						orientation: orientation
					};
				}
				/**
				 * or main page we calculate the H/W in pixels - BAs of calculation comes from application/SiteLayout
				 */
				var top = 0,
					left = 0;
				var contentHeight = info.application.height;
				var contentWidth = info.application.width;
				if (self._pageControls) {
					info.contentWidth = contentWidth;
					info.contentHeight = contentHeight;
					self._pageControls.forAllCtrls(function(id, ctrl) {
						if (ctrl.onMainPageResize) {
							ctrl.onMainPageResize(info, orientation, deviceType);
						}
					});
					// We need to iterate on pageHelpers.insidePageControls with the right to to bottom order
					var ctrl;
					pageHelpers.insidePageControls.forEach(function(id) {
						ctrl = self.getPageControl(id);
						if (ctrl && ctrl.isVisible()) {
							var ch = ctrl.getHeight();
							contentHeight -= ch;
							if (pageHelpers.topPageControls.indexOf(id) >= 0) {
								var $$root = self["_$$" + id];
								if ($$root) {
									$$root.css({
										top: top
									});
									top += ch;
								}
							}
						}
					});
				}
				self.$$contentElmt.css({
					top: top + "px",
					left: left + "px",
					width: contentWidth + "px",
					height: contentHeight + "px"
				});
			} else {
				/**
				 * For vignette we don't calculate the H/W in pixels.
				 * To do the calculatation we need to propagate the calculation from dashboard tile -> Control (not done and needed)
				 * H/W calculation is based on css style height auto for the wrapper et 100% for $$contentElmt
				 */
			}
			/**
			 * We need to create the scroller for main page and page embeded in vignette
			 */
			// Save content rectangle for scrolling and hub layout - "computed" to ignore padding
			self._mainContentRect = uiRect.elmtRect(self.$$contentElmt, "computed");
			// We need to set the right coordinates for intersectRect with scroller
			self._mainContentRect.moveLeft(parseInt(self.$$contentElmt.css("padding-left"), 10));
			// info is the context of resize - info.u^dateLayout = true if page updated by authoring
			self.onResize(info);
			// After onResize because the resize re-initialized the native scrolling
			self._initScroll(info && info.preserveScroll);
		},
		/**
		 * returns main content rect for hub layout
		 */
		getMainContentRect: function() {
			return this._mainContentRect;
		},
		/**
		 * Resize handler called by window.resize
		 */
		onResize: function(context) {
			if (this.sizeModified != true) {
				if (this._resizeContext && context) {
					// Optimization for triggerResize on back - We need to know if sized changed (orientation/device type...)
					this.sizeModified = this._resizeContext.contentHeight != context.contentHeight || this._resizeContext.contentWidth != context.contentWidth;
				} else {
					this.sizeModified = false;
				}
			}
			this._resizeContext = $.extend({}, context);
			// Call resize handler in tree hierachy
			if (this.rootLayout && this.rootLayout.onResize) {
				this.rootLayout.onResize(context);
			}
			if (!this.isVignette && this._panelsManager) {
				//!! No propagation of resize if vignette
				this._panelsManager.panelResize(context);
			}
		},
		/**
		 * Specific procces after rendering
		 */
		afterRender: function(loadOptions, buildOpts) {
			var self = this;
			return $.smResolve().then(function() {
				// afterRender for controls - outside pageControls
				self.ctrlAfterRenderCalls.forEach(function(c) {
					c.afterRender(buildOpts);
				});
				if (self._pageControls && loadOptions.skipPageControls !== true) {
					// for _pageControls afterRender is called only at the creation of the page
					self._pageControls.afterRender(buildOpts);
				}
			});
		},
		beforeAddContent: function() {},
		addTitle: function(title, description) {
			var html = "";
			if (title) html = '<header class="s-m-page-title">' + title + '</header>';
			if (description) html += '<p>' + description + '<p>';
			if (html.length > 0) $(html).prependTo(this.$$ctrlsRootElmt);
		},
		/**
		 *  called each tile a control/layout is created
		 **/
		addControl: function(c) {
			Base.prototype.addControl.call(this, c);
			// For controls others that page Controls
			if (!c.isPageControl()) {
				// stores controls that need specific processes
				// !!! It's the simplest way to identify controls by testing the presence of the method when we add them
				// Another way woud be that it's the control that asks the page to be notified
				// After render
				if (c.afterRender) this.ctrlAfterRenderCalls.push(c);
				// Save context
				if (c.savedCtxCreate && c.savedCtxRestore) this.ctrlSaveCtxCalls.push(c);
			} // PageControls are managed separately because of updateLayout 
			if (c.$type === "application/x-array" && jsutils.isInstanceOf(c, "CtrlArrayChart") && c.isHighChart()) {
				//#6974 Fix svg issue in chrome - see dashBoard page
				this.nbCharts++;
			}
		},
		removeControl: function(c) {
			if (!c) {
				return;
			}
			Base.prototype.removeControl.call(this, c);
			if (this._pageControls && c.isPageControl()) {
				// removeControl if any
				this._pageControls.remove(c);
			}
			return c;
		},
		/**
		 * Display the page and hides currentPage
		 * 		Manage transitions (effect) according  to self.getProp("transition")
		 *		Do not call show directly
		 * 		cb is called after oage hs been displayed (we don't use deferred)
		 * pageToClose is the page ths will be replaced by this
		 * 		For a child page currentPage is the parent page
		 *			Used by rowdetail page to read the DAO
		 */
		activate: function(pageToClose, cb) {
			var self = this;
			self._show(pageToClose, function() {
				if (self.getSavedContext()) {
					self.savedCtxRestore(self.getSavedContext());
				} else if (self.lastSelectedRow) {
					// We allways restore last selected row because it is stored in page when we clik the link that opens the 'child' page
					self._hilightLastSelectedRow(self.lastSelectedRow);
				}
				if (cb) cb();
			});

		},
		/**
		 * Called after the page have bee activated
		 * Page and controls are visible
		 */
		activated: function() {},
		/**
		 * Hide the page
		 * 	Do not call hide or show directly
		 * A "cached" page is deactivated instead of being destroyed on navigation event
		 */
		deactivate: function(cb) {
			this._hide(cb);
		},
		/**
		 * returns the context to save
		 * It scanss al the controls taht implement savedCtxCreate (self.ctrlSaveCtxCalls)
		 * To add data to savedContext we just need to impement this methid on the control and return a JSON object
		 * Can be overridden (ex dashboard to manage contexts of vignettes)
		 * type		added for context restoration needs for links (email, handleLink see nativeShare)
		 * 			it's used to manage the content of the context and the restoration (see pageLoader)
		 * 			Values:
		 * 				"back"
		 * 					by default the type is "back" because originally the savedContext was used to manage context restoration on back
		 * 				"link"
		 * 					tells the page/controls that the context will be used in a link
		 *
		 */
		savedCtxCreate: function(type) {
			var self = this;
			type = type || "back";
			var ctx = {
				type: type,
				pageName: this.state.name,
				lastSelectedRow: self.lastSelectedRow
			};
			if (self._gestureMgr) {
				// Save page scrolling
				ctx.scroll = self._gestureMgr.savedCtxCreate(type);
			}
			if (self.ctrlSaveCtxCalls && self.ctrlSaveCtxCalls.length > 0) {
				ctx.ctxCtrls = {};
				// Save controls contexts - All controls who implement savedCtxCreate are added to ctrlSaveCtxMap
				// We take $bind as control ID because id is changed each time we create a control
				self.ctrlSaveCtxCalls.forEach(function(c) {
					var ctrlCtx = c.savedCtxCreate(type);
					if (ctrlCtx) ctx.ctxCtrls[c.$bind] = ctrlCtx;
				});
			}
			return ctx;
		},
		/**
		 * Restore page context - Called after activation (show)
		 * Restore page + controls contexts
		 */
		savedCtxRestore: function(ctx) {
			var self = this;
			if (!ctx) return;
			if (ctx.pageName != this.state.name) {
				// The page is not able to restore child pages inside a vignette - TODO if needed
				// If we go to detail page in ful page from a dashboard and go back a vignette that contains a detail page will not restore the context if current page was a child page
				// -> Only main parent page is restored
				return;
			}
			if (self._gestureMgr && ctx.scroll) {
				// Restore page scrolling
				self._gestureMgr.savedCtxRestore(ctx.scroll, true);
			}
			if (ctx.ctxCtrls) {
				// Restore controls context
				// We take $bind as control ID because id is changed each time we create a control
				for (var bind in ctx.ctxCtrls) {
					var c = self.getControlByBind(bind);
					var ctrlCtx = self.getCtrlSavedContext(bind);
					if (c && c.savedCtxRestore && ctrlCtx) {
						c.savedCtxRestore(ctrlCtx);
					}
				}
			}
		},
		/**
		 * returns the saved context
		 */
		getSavedContext: function(propName) {
			var ctx = this.state.savedContext;
			if (!propName || !ctx) return ctx;
			return ctx[propName];
		},
		/**
		 * Update the saved context when the page is closed - Called by pageLoader
		 * SavedContext  is stored in page state to be persistent
		 */
		updateSavedContext: function(clear) {
			this.state.savedContext = clear ? null : this.savedCtxCreate();
		},
		/**
		 * The regular context management restores the context when the page is activated (see savedCtxRestore)
		 * This process is generic and works fine for page and controls
		 * In some particular cases we need to restore the context before activating the page (when we create the control)
		 * The only case is the restauration of the search criteria for the array in query facet. We need the value (if any) before loading the page for sDataUrl
		 * This method is called by the control if it's absolutely needed otherwise we should keep the regular process
		 * Returns the context for 'bind' contrl if any
		 */
		getCtrlSavedContext: function(bind) {
			var ctx = this.getSavedContext('ctxCtrls');
			return ctx && bind ? ctx[bind] : null;
		},
		_hilightLastSelectedRow: function(lastSelectedRow, old) {
			var self = this;
			var toggle = function(rowInfo, show) {
				// We take array$Bind as control ID because id is changed each time we create a control
				var c = self.getControlByBind(rowInfo.array$Bind);
				if (c && c.selectLastSelectedRow) {
					c.selectLastSelectedRow(rowInfo.rowId, show);
				}
			};
			if (old) toggle(old, false);
			if (lastSelectedRow) {
				toggle(lastSelectedRow, true);
				return true;
			}
			return false;
		},
		_show: function(currentPage, cb) {
			var self = this;
			var transition = self.getProp("transition");
			if (currentPage) {
				currentPage._hide(function() {
					self.$$elmt.show(transition || 0, function() {
						if (cb) cb();
					});
				});
				return;
			}
			self.$$elmt.show(transition == null ? 0 : transition, cb);
		},
		_hide: function(cb) {
			if (!this.$$elmt) {
				if (cb) cb();
				// page has been destroyed
				return;
			}
			// Close panels
			if (this._pageControls) {
				this._pageControls.closeSidePanel("all");
			}
			var transition = this.getProp("transition");
			this.$$elmt.hide(transition == null ? 0 : transition, cb);
		},
		isActive: function() {
			return this.$$elmt && this.$$elmt.is(":visible");
		},
		/**
		 * True is page is a lookup
		 */
		isLookup: function() {
			return this.prototype && this.prototype.isLookup();
		},
		isAppHomePage: function() {
			return this.state.name === globals.getApplication().homePageId;
		},
		/**
		 * Return the info to notify parent when the child page is closed
		 * It depends on the kind of page
		 * Ex: lookup notifies parent control with selected value
		 */
		getParentNotif: function() {
			throw new Error("not implemented");
		},
		/**
		 * Return the id of parent page if any
		 */
		getParentId: function() {
			return this.isChild ? this.state.options.parentId : null;
		},

		/**
		 * Returns attribute for the link that opens this page (used to open this page from a vignette to full page)
		 * Overriden by regular page to put s-data-url
		 */
		getOpenLinkAttrs: function() {
			return {
				"data-nav": this.state.name
			};
		},

		/***
		 * Test action
		 */
		_actTest: function(params) {
			var e = $('<h5 style="color:red">Action test succeeded</h5>').prependTo(this.$$elmt);
			window.setTimeout(function() {
				e.remove();
			}, 2000);
		},
		/**
		 * Click on home in footer/header
		 * Can be overrridden - rowDetail
		 */
		_actHome: function() {
			globals.getApplication().gotoWelcomeApplication();
		},
		/**
		 * Wait wheel management
		 * We need one plugin per page
		 */
		waitWheelStart: function(controlId) {
			if (controlId) {
				var c = this.getControl(controlId);
				if (c && c.waitWheelStart) c.waitWheelStart();
				return;
			}
			if (this.getParentVignette()) {
				this.getParentVignette().waitWheelStart();
				return;
			}
			if (!this._waiting) {
				this._waiting = uiutils.waitWheelCreate(this.$$elmt);
			}
			uiutils.waitWheelStart(this._waiting);
		},
		waitWheelStop: function(controlId) {
			if (controlId) {
				var c = this.getControl(controlId);
				if (c && c.waitWheelStop) c.waitWheelStop();
				return;
			}
			if (this.getParentVignette()) {
				this.getParentVignette().waitWheelStop();
				return;
			}
			if (this._waiting) {
				uiutils.waitWheelStop(this._waiting);
			}
		},
		/**
		 * Called synchronously by an array when a row has been selected
		 * 	arrayId		Id of array
		 * 	rowId		Id of row
		 * 	rowdata		data of the row used by loojup page
		 */
		notifSelectRow: function(arrayId, rowId, rowdata) {
			var c = this.getControl(arrayId);
			if (!c) return;
			// !! selections works with $uuid - it doesn't work if no $uuid or same $uuid whihc occurs sometime in X3 dvlp folders 
			var old = this.lastSelectedRow;
			this.lastSelectedRow = {
				array$Bind: c.$bind,
				rowId: rowId
			};
			this._hilightLastSelectedRow(this.lastSelectedRow, old);
		},
		/**
		 * !!!! returns a boolean or a promise
		 *  - true if back is allowed
		 *  - false if back is not allowed
		 *  - promise:  the promise must resolve with true or false
		 *  			used if a dialog is displayed
		 */
		checkBack: function() {
			return true;
		},
		goBack: function() {
			if (this.isVignette) {
				return this.getParentVignette().goBack();
			} else {
				// checkBack is called by application.historyPop
				return globals.getApplication().goBack();
			}
		},
		/**
		 * Update the scroll for a vignette
		 *
		 */
		initVignetteScroll: function(back) {
			if (!this._gestureMgr) return;
			var viewRect = this.getParentVignette().getScrollViewRect();
			//if (back === true || (viewRect.height < this.$$scrollWrapper.height())) {
			// If back into a vignette we keep old scrolling - To improve 
			var keepOldScrolling = back === true;
			this._gestureMgr.init(viewRect, "v", 0, keepOldScrolling);
			//}
		},
		/**
		 * Enable/Disable scrolling
		 */
		_initScroll: function(preserveScroll) {
			if (!this._gestureMgr) return;
			if (this.scrollAllowed()) {
				var viewRect = this.isVignette ? this.getParentVignette().getScrollViewRect() : this._mainContentRect;
				// Force $$scrollWrapper to full heigth of childrens
				// We scroll if childen height is greater than childrenRect height
				if (viewRect && viewRect.height < this.$$scrollWrapper.height()) {
					var valMax = 0;
					// If not new -> back on a cahced page - We keep scrolling
					preserveScroll = preserveScroll === true || this.isNew !== true;
					//viewRect has fixed coordinate to check if the 'finger' is inside on mousemouve event
					// A page always scolls verticaly - In dashboard this is the layout that scrolls horizontally
					this._gestureMgr.init(viewRect, "v", valMax, preserveScroll);
					var autoScroll = this.state.options["auto-scroll"];
					if (autoScroll != null) {
						// When we go to $edit form $details we keep the scrolling in order to stay at the same location (see actionManager)
						this.autoScroll(autoScroll);
						// Only when we loadd the page
						this.state.options["auto-scroll"] = undefined;
					}
				} else {
					this._gestureMgr.reset();
				}
			} else {
				// Disable _gestureMgr if any
				this._gestureMgr.reset();
			}
		},
		/**
		 * Update the scroller - needed for staked layouts
		 * In stacked/row layout the height of the page is given by the height of the content of the vignette
		 * Used by charts and vignettes
		 * force= true to force recalculation if caller nows that scolling area changed
		 */
		notifScrollerUpdate: function(force) {
			// _gestureMgr != null for stack (not hub structure)
			if (!this._gestureMgr) return;
			// Optimization - If the height/width din't change we skip init Scroll (works only if (scale factor == 1)
			if (force !== true && this._gestureMgr.viewRect && this._mainContentRect.equals(this._gestureMgr.viewRect, true)) {
				return;
			}
			// Init scroll because hight has changed - True to preserve scroll for authoring
			this._initScroll(true);
		},
		/**
		 * Scroll the page
		 */
		autoScroll: function(value) {
			// TODO - scroll the rootLayout for the dashboard
			if (this._gestureMgr) this._gestureMgr.autoScroll(value);
		},
		/**
		 * True if scroll enabled in page
		 * By default we can scroll a page in full display
		 * In vignettes only details/edit facet are allowed to scroll - See regular page
		 * In Dashboard hub this is the layout that scrolls - Page doesn't scroll
		 */
		scrollAllowed: function() {
			return !this.isVignette && !this.isDashboard("hub");
		},
		/**
		 * typeDashboard = hub / stack / undefined
		 */
		isDashboard: function(typeDashboard) {
			return false;
		},
		isNestedInDashboard: function(typeDashboard) {
			if (!this.isVignette) return false;
			if (!this.getParentVignette()) return false;
			return this.getParentVignette().controller.isDashboard(typeDashboard);
		},
		/**
		 * Returns the offset of the scrollRect top/left in fixed position (document)
		 * Overridden by dashboard
		 */
		getScrollOffset: function() {
			// Application content can be scrcolled (native in authoring)
			return globals.getApplication().getScrollOffset();
		},
		/**
		 * returns the value of the page's scroller
		 * 0 by default even if no scroller		 *
		 */
		getScrollValue: function() {
			return this._gestureMgr ? this._gestureMgr.getScroll() : 0;
		},
		getParentVignette: function() {
			return this.state.options.parentVignette;
		},
		getVignettePageDashboard: function() {
			if (!this.isVignette || !this.getParentVignette()) {
				// If not avail we take the currentpage of mobile application (setParentVignette not initialized)
				return globals.getApplication().currentPage;
			};
			return this.getParentVignette().controller;
		},
		/**
		 * Return null, stack, hub
		 */
		getParentDashboardType: function() {
			if (!this.isVignette || !this.getParentVignette()) return null;
			return jsutils.isInstanceOf(this.getParentVignette().parent, "LayoutTile") ? "hub" : "stack";
		},
		getGestureMgr: function() {
			return this._gestureMgr;
		},
		/**
		 * Show element in page - scroll if needed
		 * c is a JQuery elmt or an object with $$elmt property
		 */
		makeVisible: function(c) {
			if (!c || !this.getGestureMgr() || !c.$$elmt) {
				return;
			}
			this.getGestureMgr().makeVisible(c.$$elmt);
		},
		/**
		 * Adds a panel to left or right sections - sidePanel class
		 */
		panelAttach: function(where, panel, action) {
			return this._panelsManager ? this._panelsManager.panelAttach(where, panel, action) : null;
		},
		/**
		 * Detach a panel from left or right sections - sidePanel class - needed by header
		 */
		panelDetach: function(where) {
			return this._panelsManager ? this._panelsManager.panelDetach(where) : null;
		},
		/**
		 * Returns a panel - Just to have ctrlFactory declared here
		 * actionController: controller that handle actions
		 * - In a full page it's the ccontroller of the page
		 * - in a vignette it's the embeded controller
		 */
		panelCreate: function(panelId, options) {
			// !!The contoller that controls the panelManager is always the main page controller
			// Controller that handles actions is this (Eg: the one of a vignette)
			var actionController = this;
			return this._panelsManager ? this._panelsManager.panelCreate(panelId, options, actionController) : null;
		},
		/**
		 * Toggle left/right panel - data-action="sidePanel"
		 * 	panel : left or right
		 * 	action toggle
		 */
		_actToggleSidePanel: function(action, side) {
			if (!this._panelsManager) return;
			var self = this;
			var side = side == null || side === "all" ? ["left", "right"] : [side];
			side.forEach(function(where) {
				self._panelsManager.panelToggle(where, null, action);
			});
		},
		externalLink: function(param) {
			if (nativeExtLink) {
				nativeExtLink.openExternalLink(param);
			} else {
				window.open(param);
			}
		},
		_actExternalLink: function(param) {
			/* sometime the link can contains coma. but the caller of _act (_doAct) split params form coma.
			 *
			 */
			var Url = "";
			for (var i = 0, l = arguments.length; i < l; i++) {
				if (typeof arguments[i] === "string") {
					Url = Url ? Url + "," : "";
					Url += arguments[i];
				}
			}
			this.externalLink(Url);
		},
		getPinPageId: function() {
			// Overridden by child classes!
		},
		getPinPageData: function() {
			return {
				name: this.state.name,
				title: this.prototype.data("$title") || locale.text("no.title"),
				id: this.getPinPageId(),
				icon: "star",
				applicationName: this.state.applicationName,
				voiceCommandContext: this.getRestoreContext("pinPage")
			};
		},
		/**
		 * Returns an object that allows the application to reopen the page
		 * reason: nativeAppClosing, pinPage, sharedLink...
		 */
		getRestoreContext: function(reason) {
			var self = this;
			var ctx = {
				endpoint: globals.getEndpoint(),
				applicationName: self.state.applicationName,
				role: globals.getUserRole(),
				currentState: {
					// Used by draft to getPageDetails
					type: self.state.type,
					name: self.state.name,
					savedContext: self.savedCtxCreate("link"),
					options: {}
				}
			};
			if (self.state.options) {
				// sdata-url is set in pageRegular
				["dataParams"].forEach(function(p) {
					ctx.currentState.options[p] = self.state.options[p];
				});
			}
			return ctx;
		},
		getTileLinkContext: function() {
			var self = this;
			return sdataCommonResources.createSharedContext(this.getRestoreContext("sharedLink")).then(function(uuid) {
				return {
					Title: self.state.$title,
					DeepLink: {
						Title: self.state.$title,
						Url: jsutils.getOpenLinkUrl(uuid)
					}
				};
			}).fail(function() {
				return null;
			});
		},
		/**
		 * Returns page authoring property
		 * path: string with or without '.' separator or array of string
		 */
		getAuthoring: function(path, defValue) {
			var val = utils.getPropByPath(this.article, path);
			return val != null ? val : defValue;
		},
		notifUpdtCardArticle: function(notifData, controlId) {
			var array = this.getControl(controlId);
			if (!array || !notifData) return;
			array.setCardAuthoring(notifData.article);
		},
		notifUpdtChartDetailArticle: function(notifData, controlId) {
			var chart = this.getControl(controlId);
			if (!chart || !notifData) return;
			chart.setChartDetailAuthoring(notifData.article, notifData.level);
		},
		/**
		 * Used by test entities to attach an article to a link
		 * - When we open a detail from a query (array)
		 * 		$detailLinkArticle attribute
		 * 		$queryLinkArticle attribute
		 * - when we open a facet form a $link vignette
		 * 		$linkArticle attribute
		 */
		getLinkedPageArticle: function(ctrlId) {
			if (!ctrlId) return;
			var ctrl = utils.findControl($("#" + ctrlId, this.$$elmt));
			if (!ctrl || !ctrl.getLinkedPageArticle) return;
			return ctrl.getLinkedPageArticle();
		},
		getToolbarLinks: function() {
			return null;
		},
		getProtoLinks: function() {
			return null;
		},
		getMultiSelectionLinks: function() {
			return null;
		},
		/**
		 * actName	action's name
		 * prop		null -> All properties
		 * 			"options", "icon"
		 * 			options: {footerHeader:true/false, multiselection/false, refreshPage: true/false}}
		 */
		actionGetSettings: function(actName, prop) {
			var $actionsSettings = this.getAuthoring("$pageActionSettings");
			if (!$actionsSettings) return null;
			var res;
			$actionsSettings.some(function(setting) {
				if (setting.name === actName) {
					res = setting;
					return true;
				}
				return false;
			});
			return res == null ? null : prop == null ? res : res[prop];
		},
		isMultiSelectionEnabled: function() {
			return this.getAuthoring("$allowDownload") === true || this.getMultiSelectionLinks() != null;
		},
		hasFooterHeaderActions: function() {
			return false;
		},
		/**
		 * typeControl= "header" or "footer"
		 * newControl= Header or Footer control
		 * Switchs current footer/header by newControl
		 * Returns the current footer/header
		 * newControl =  null -> Restores the original footer/header
		 * show:	undefined toggle current footer/header with
		 * 			true display newControl
		 * 			false remove newControl
		 */
		toggleHeaderFooter: function(typeControl, newControl, show) {
			if (this.destroyed) return null;
			var originalControl = this["_page" + typeControl.smCapitalize()];
			if (originalControl == null) {
				// Some page like login don't manage a footer/header - We exit if no control
				return null;
			}
			var currentControl = this.getPageControl(typeControl);
			if (newControl == null) {
				// Default control
				newControl = originalControl;
				// Regular toggle
				show = undefined;
			}
			if (show === true && newControl === currentControl) {
				// Already displayed
				return currentControl;
			}
			if (show === false && newControl !== currentControl) {
				// Already removed
				return currentControl;
			}
			if (currentControl) {
				this.removeControl(currentControl);
				if (newControl === currentControl && show === false) {
					// We set the regular footer/header
					newControl = originalControl;
				}
			}
			this._pageControls.add(typeControl, newControl);
			this.addControl(newControl);
			var $$root = this.$$elmt.children(typeControl);
			if (!newControl.$$elmt) {
				newControl.buildHtml($$root, this.dao);
			} else {
				$$root.append(newControl.$$elmt);
				// JQuery work around for 'a' tags - the JQuery.defaultDisplay function returns 'inline' for a and we need 'inline-block'
				// if we attach a footer and reattach it, call show/hide restores the defaultDisplay instead the orginal one 
				// if we don't detach the footer it works ok so we force inline-block
				newControl.$$elmt.find("a").css("display", "inline-block");
			}
			newControl.notifToggled(true);
			return currentControl;
		},
		showPageShare: function() {
			if (!this.nativeCapabilities) return false;
			return this.nativeCapabilities.liveTile || this.nativeCapabilities.scheduleMsg || this.nativeCapabilities.share;
		},
		/**
		 * Switch from oof to on line
		 * yes	trus/false
		 * TODO - Do not manage at page level but as a global level to not notify user each time we open a page
		 */
		setOffLine: function(yes, notify) {
			this._offline = yes === true;
		},
		isOffLine: function() {
			return this._offline === true;
		},
		/**
		 * Called by sharePanel
		 */
		notifPageShare: function(action, data) {
			switch (action) {
				case "link":
					this._sharePageLink();
					break;
				case "liveTile":
					this._shareAddLiveTile(data);
					break;
				case "schedule":
					this._shareScheduleMessage(data);
					break;
			}
		},
		_sharePageLink: function() {
			this.getTileLinkContext().then(function(ctx) {
				native.getModule("share").sharePageLink({
					pageData: ctx
				});
			});
		},
		_shareAddLiveTile: function(data) {
			var liveTileModule = native.getModule("liveTile");
			if (!data || !liveTileModule) return;
			var options = {}, self = this;
			self.getTileLinkContext().then(function(ctx) {
				var page = data.vignette ? self.getControl(data.vignette).getPage() : self;
				var pageData = page.getPinPageData(); // allow to add information by subclasses;
				options = $.extend(true, {}, pageData, ctx, data);
				options.applicationName = self.state.applicationName;
				options.endpoint = pageData.endpoint || globals.getEndpoint();
				return liveTileModule.addLiveTile(options);
			}).then(function(result) {
				var notify;
				if (result && result.error) {
					notify = {
						severityClass: "warning",
						body: result.error.text,
						onlyWebapp: false
					};
				} else {
					notify = {
						severityClass: "success",
						title: "",
						body: locale.text("liveTile.page.add.ok"),
						onlyWebapp: false
					};
				}
				globals.getModal().notify(notify);
			});
		},
		_shareScheduleMessage: function(data) {
			var scheduleMessageModule = native.getModule("scheduleMessage");
			if (!data || !scheduleMessageModule) return;
			this.getTileLinkContext().then(function(ctx) {
				if (!ctx) return;
				data.DeepLink = ctx.DeepLink;
				scheduleMessageModule.scheduledMsg(data);
			});
		},
		/**
		 * True if the page is the same as state
		 */
		isSamePage: function(state) {
			return !this.destroyed && this.isActive() && state && state.name === this.state.name;
		},
		_actPageMailto: function() {
			var self = this;
			sdataCommonResources.createSharedContext(this.getRestoreContext("sharedLink")).then(function(uuid) {
				var email = ["mailto:?subject="];
				email.push(encodeURIComponent(self.state.$title || ""));
				email.push("&body=");
				email.push(encodeURIComponent(jsutils.getOpenLinkUrl(uuid)));
				var win = window.open(email.join(''));
				if (win) { // Can be null if there is a popup blocker
					setTimeout(function() {
						win.close();
					}, 100);
				}
			}).fail(function() {
				return null;
			});
		}
	}
);

exports.Page = _Page;
});

define('syracuse-tablet/html/js/ui/modals/modalMultiButtons',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
		{{#if title}}<div class="modal-title">{{title}}</div>{{/if}}',
	content: '\
		<div class="s-m-modal-content">\
			<p>{{{message}}}</p>\
		</div>',
	footer: '\
	{{#each buttons}}\
		<button type="button" {{#if isHidden}}style="display:none"{{/if}} class="btn btn-default {{#if smallBtns}}btn-sm{{/if}}{{#if isDisabled}}disabled{{/if}}" data-action="{{action}}">{{label}}</button>\
	{{/each}}'
};
/**
 * Displays a dialog yes/no - yes/no/cancel ... according to opts
 * opts : {
 * 		buttons:[{action:"yes", label:"yes", isHidden: false, , isDisabled: false}],
 * 		defaultAction: "no"
 * }
 */
var _Klass = utils.defineClass(
	function ModalMultiButtons(title, message, opts) {
		modalDialog.ModalBase.call(this);
		this._dataContext = $.extend({
			title: title,
			message: modalDialog.checkMsg(message || "")
		}, opts);
		this.selectedAction = opts.defaultAction || null;
		var sl = globals.getSiteLayout();
		this._dataContext.buttons.forEach(function(b) {
			b.smallBtns = sl.getDeviceType() === "smartphone" && sl.getPageOrientation() === "portrait";
		});
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			return {
				std: _templateAll
			};
		},
		getDisplayFlags: function() {
			var res = this.displayFlags || {};
			res.modalClass = "multibuttons " + this.deviceType;
			return res;
		},
		_getDataContext: function() {
			return this._dataContext;
		},
		_onAction: function(action, param) {
			this.selectedAction = action;
			// close on actions
			return true;
		},
		_getResult: function() {
			return this.selectedAction;
		},

		_checkButtonSize: function() {
			var sl = globals.getSiteLayout();
			this.$$elmt.find("button").toggleClass("btn-sm", sl.getDeviceType() === "smartphone" && sl.getPageOrientation() === "portrait");
		},

		notifMainLayoutChanged: function(info, orientation, deviceType) {
			this._checkButtonSize();
		}
	}
);
exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/pages/pageDashboard',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/pages/page','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/ui/modals/modalMultiButtons','syracuse-tablet/html/js/helpers/mobileDetect'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/pages/page').Page;
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var modalMultiButtons = require('syracuse-tablet/html/js/ui/modals/modalMultiButtons');
var mobileDetect = require('syracuse-tablet/html/js/helpers/mobileDetect');

var _Page = utils.defineClass(

	function DashboardPage($parent, state, prototype, article, options) {
		if (options.breadcrumbs == null) options.breadcrumbs = true;
		Base.call(this, $parent, state, prototype, article, options);
		this.vignettes = [];
		this._vignettesLoaderStates = [];
		var app = globals.getApplication();
		if (app.dao.isSageApplication() && this.state.dashboardName === app.dao.getHomeDashboardName()) {
			this.$$contentElmt.addClass(app.dao.getAppBackGroundClass());
		}
		this._nbCharts = 0;
		this._editModeVignettes = null;
	}, Base, {

		destroy: function() {
			if (this.destroyed) return;
			Base.prototype.destroy.call(this);
			this._editModeVignettes = null;
			this.vignettes = null;
			this._vignettesLoaderStates = null;
		},

		loadData: function(loadOptions) {
			return null;
		},
		reload: function(options) {
			this.vignettes = [];
			return Base.prototype.reload.call(this, options);
		},
		beforeAddContent: function() {
			// #5583 - disabled rendering of title because redundant with header title
		},

		addControl: function(c) {
			Base.prototype.addControl.call(this, c);
			if (c && c.isVignette && c.isVignette()) {
				this.vignettes.push(c);
			}
		},
		afterRender: function(loadOptions, buildOpts) {
			var self = this;
			return Base.prototype.afterRender.call(self, loadOptions, buildOpts).then(function() {
				if (self.vignettes == null || self.vignettes.length == 0) return;
				var vignetteNum = 0;
				var dashName = self.prototype.data("$dashboardName");
				var join = $.Deferred();
				// If authoring is active we wait until all vignettes are loaded (needed by the ui)
				loadOptions.forceSynchroVignettes = globals.isAuthoringActive() || loadOptions.forceSynchroVignettes || globals.isAutoUITestMode();
				setTimeout(function() {
					if (self.destroyed || !self.vignettes) return;
					self.vignettes.forEach(function(v) {
						vignetteNum++;
						// Load all async and maybe join at the end
						var vignetteId = dashName + "#" + vignetteNum;
						// Context to restore if any - see getRestoredContext
						var restoredState = self.state.options.vignettesPageStates && self.state.options.vignettesPageStates[vignetteId];
						var pageOptions = restoredState || {};
						pageOptions.sdataParameters = self.state.options && self.state.options.sdataParameters || {};
						var vLoadOptions = {
							updateLayout: loadOptions.updateLayout === true
						};
						v.load(vignetteId, pageOptions, vLoadOptions).then(function(page, error) {
							self._checkVignetteLoadError(error);
							if (vignetteNum === self.vignettes.length) {
								join.resolve();
							}
							if (page && page.nbCharts != null) {
								//#6974 Fix svg issue in chrome - see countChartLoaded
								self.nbCharts += page.nbCharts;
							}
							if (page && page.isEditMode && page.isEditMode()) {
								if (!self._editModeVignettes) {
									self._editModeVignettes = [];
								}
								self._editModeVignettes.push(page);
							}
							return page;
						});
					});
				});
				if (loadOptions.forceSynchroVignettes === true) {
					// Wait until all vignettes have been loaded
					return join.promise();
				} else {
					// DOn't wait so user can navigate without having to wait
					return $.smResolve();
				}
			});
		},

		/*
		 * Called once a vignette has been loaded
		 * Once all vignettes are loaded, we check if there was an error we need to handle globally
		 */
		_checkVignetteLoadError: function(error) {
			var self = this;
			if (!self.vignettes || !self._vignettesLoaderStates) {
				// dashboard could have been destroyed when afterRender is called
				return;
			}
			self._vignettesLoaderStates.push({
				error: error
			});
			// We got a state from all vignettes that are pending to load
			if (self._vignettesLoaderStates.length === this.vignettes.length) {
				// Check if we went offline
				var goLogin = false;
				var e;
				self._vignettesLoaderStates.some(function(s) {
					if (s.error && s.error.$redirectPage === "login") {
						e = s.error;
						return true;
					}
				});
				self._vignettesLoaderStates = [];
				if (e) {
					modal.error(locale.text("error.page.loading"), e, function() {
						globals.getApplication().gotoLogin(locale.text("login.timeout.message"));
					});
				}
			}
		},
		onMainPageResize: function(info, orientation, deviceType) {
			Base.prototype.onMainPageResize.call(this, info, orientation, deviceType);
			//#6974 Fix svg issue in chrome - see countChartLoaded
			this._chartsCounter = 0;
			/**
			 * We need to load the vignettes after having resized the main page
			 * otherwise we load page which is nested in the vignette two times, onMainPageResize and after the vignette has been loaded (asynch)
			 * If we load vignette here we make sure that onMainPageResize resizes only the vignette (not the nested page)
			 * Nested page will be resized after having been loaded
			 */
			this.vignettes.forEach(function(v) {
				v.onMainPageResize(info, orientation, deviceType);
			});
		},
		/** 
		 * #6974 Fix svg issue in chrome
		 * Chrome displays partially the charts in test hub dahsborad when we change the orientation
		 * It's a bug is due to svg engine in chrome
		 * We force to create a link tag in header and just remove it to trigger a redraw of svg object after having loaded all the charts
		 * Calling the svg forceRedraw method or modifying the chart or svg dom attribute/style has no effect
		 * This trick solves the bug :-(
		 */
		countChartLoaded: function(chart) {
			if (this._chartsCounter == null || !globals.getCurrentPage().isDashboard("hub") || !mobileDetect.checkBrowserName("chrome")) return;
			this._chartsCounter++;
			if (this._chartsCounter === this.nbCharts) {
				if (!this._$$fakeLink) {
					this._$$fakeLink = $('<link rel="stylesheet" type="text/css">');
				}
				this._$$fakeLink.appendTo($("head")).detach();
				this._chartsCounter = null;
			}
		},
		authUpdateLayout: function(article, vignetteToUpdt) {
			// Set new article which comes from authoring panel
			this.article = article;
			if (vignetteToUpdt) {
				return vignetteToUpdt.reloadPage({
					updateLayout: true,
					authoringUpdate: true
				});
			}
			this.vignettes = [];
			return Base.prototype.authUpdateLayout.call(this, article);
		},
		/**
		 * Context to store when dashboard is destroyed
		 * We save the context for each vignette (scroll, selection....)
		 * Context of the vignette will be retrieved with the index which is the identifier
		 * Vignette id is recalculated at creation and changes each time the vignette is loaded
		 * type	back/link - Used to manage the content according to the type
		 */
		savedCtxCreate: function(type) {
			var ctx = Base.prototype.savedCtxCreate.call(this, type);
			ctx.vignettes = [];
			var p;
			this.vignettes && this.vignettes.forEach(function(v) {
				p = v.getPage();
				// We store a context even if p == null - Vignette can be destroyed before the end of load process and we must preserve the index in vignette array
				// Vignette is identified by its index
				ctx.vignettes.push(p ? p.savedCtxCreate(type) : null);
			});
			if (this.isDashboard("hub") && this.rootLayout) {
				// Store the scroll of hub layout
				ctx.hubCtx = this.rootLayout.savedCtxCreate(type);
			}
			return ctx;
		},
		/**
		 * Restore the context for the dashboard (not for the vignette)
		 */
		savedCtxRestore: function(ctx) {
			// Std restore for all page
			Base.prototype.savedCtxRestore.call(this, ctx);
			// store vignettes context
			this._savedVignetteContext = ctx.vignettes;
			if (ctx.hubCtx && this.isDashboard("hub")) {
				// Restore the scroll of hub layout
				this.rootLayout.savedCtxRestore(ctx.hubCtx);
			}
		},
		/**
		 * Returns the context of a vignette v
		 * Called by the vignette  -Vignettes contexts is stored in dashboard context
		 */
		getSavedCtxVignette: function(v) {
			if (v == null || this._savedVignetteContext == null) return null;
			var idx = this.vignettes.indexOf(v);
			if (idx == -1 || idx > this._savedVignetteContext.length - 1) return null;
			return this._savedVignetteContext[idx];
		},
		getPinPageId: function() {
			var self = this;
			return self.state.dashboardName + "_" + JSON.stringify(self.state.options.sdataParameters);
		},
		_sdataParam2String: function() {
			var self = this;
			var params;
			if (self.state.options.sdataParameters) {
				Object.keys(self.state.options.sdataParameters).forEach(function(key) {
					var opt = key + "=" + self.state.options.sdataParameters[key];
					if (params) {
						params += "&" + opt;
					} else {
						params = opt;
					}
				});
			};
			return params;
		},
		getPinPageData: function() {
			var pageData = Base.prototype.getPinPageData.call(this);
			pageData.dashboardName = this.state.dashboardName;
			// See vignetteBase - Used to set the application icon if isAppHomePage = true
			pageData.$type = this.state.options && this.isAppHomePage() === true ? "$application" : "$dashboard";
			// sdataParameters is serialized to put in a link
			pageData.sdataParameters = this._sdataParam2String(); // In case of a filtered dashboard, may be null
			pageData.endpoint = globals.getEndpoint();
			return pageData;
		},
		/**
		 * Returns an object that allows the application to reopen the page
		 * reason: nativeAppClosing, pinPage, sharedLink...
		 */
		getRestoreContext: function(reason) {
			var ctx = Base.prototype.getRestoreContext.call(this, reason);
			if (this.state.options.sdataParameters) {
				// Not serialized
				ctx.currentState.options["sdataParameters"] = this.state.options.sdataParameters;
			}
			// If there are edit/create facets in the dashboard we save the context
			if (!this.vignettes) return;
			var vStates = ctx.currentState.options.vignettesPageStates;
			this.vignettes.forEach(function(v) {
				var p = v.getPage();
				if (p) {
					var state = p.getRestoreContext(reason);
					if (!state.currentState || !state.currentState.options) return;
					if (!vStates) {
						vStates = ctx.currentState.options.vignettesPageStates = {};
					}
					vStates[v.vignetteId] = state.currentState.options;
				}
			});
			return ctx;
		},
		/**
		 * typeDashboard = hub / stack / undefined
		 */
		isDashboard: function(typeDashboard) {
			return typeDashboard && this.article ? this.article.$layoutType === typeDashboard : true;
		},
		getGestureMgr: function() {
			return this.isDashboard("hub") && this.rootLayout ? this.rootLayout.getGestureMgr() : Base.prototype.getGestureMgr.call(this);
		},
		getScrollOffset: function() {
			var offset = globals.getApplication().getScrollOffset();
			if (this.isDashboard("hub") && this.getGestureMgr()) {
				var o = this.getGestureMgr().getOffset();
				// Application content can be scrolled (native in authoring)
				offset.top += o.top;
				offset.left += o.left;
				return o;
			} else {
				// No offset
				return offset;
			}
		},
		/**
		 * Return a boolean or promise
		 */
		checkBack: function() {
			if (!this._editModeVignettes || this._editModeVignettes.length == 0) {
				return Base.prototype.checkBack.call(this);
			}
			if (this._editModeVignettes.length === 1) {
				// If there's only one page in edit mode this is this page that manages the chekBack
				return this._editModeVignettes[0].checkBack();
			} else {
				// If there are more than one pages in edit mode we check the global dirty
				// No draft management - User have to activate the vignette and clcik cancel
				var isDirty = this._editModeVignettes.some(function(page) {
					return page && page.dao && page.dao.isDirty;
				});
				if (!isDirty) return true;
				return this.askDiscardChanges();
			}
		},
		/**
		 * Returns a wich resolves with true to discard and false to stay on the current page
		 */
		askDiscardChanges: function() {
			var opts = {
				buttons: [],
				defaultAction: "no"
			};
			// Buttons displayed in dialog
			["no", "yes"].forEach(function(act) {
				opts.buttons.push({
					action: act,
					label: locale.text(act)
				});
			});
			return new modalMultiButtons.Modal(locale.text("dashboard.discardchanges.title"), locale.text("dashboard.discardchanges.info"), opts).show().then(function(result) {
				return result === "yes";
			});

		},
		/**
		 * Scroll handled by hub
		 */
		scrollAllowed: function() {
			return !this.isDashboard("hub");
		}
	});

exports.Page = _Page;
});

define('syracuse-tablet/html/js/sdata/entities/welcomeApplication',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/application/settings','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/native/native'],function (require, exports, module) {"use strict";

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var settings = require('syracuse-tablet/html/js/application/settings');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var nativeVoiceCommmands = require('syracuse-tablet/html/js/helpers/native/native').getModule("voiceCommands");

var _appList = {
	hidden: [],
	visible: []
};

var _welcomeApplication = {
	"$application": {
		"$uuid": "$welcomeApplication",

		"applicationName": "$welcomeApplication",
		"title": "",
		"description": "",
		"iconName": "gears",

		"$homeDashboard": {
			"$uuid": "$welcomeDashboard",
			"dashboardName": "$welcomeDashboard"
		},
	},
	"$dashboards": {
		"$welcomeDashboard": {
			"$pageInfo": {
				// Don't remove it - used to identify application welcome page
				"isWelcomePage": true,
				"disableAuthoring": true
			},
			"$update": function(dashboard) {
				return _updateWelcomeDashboard(dashboard);
			},
			"$dashboardName": "$welcomeDashboard",
			/* It's the first page, no need to explain that using title or description */
			"$title": "",
			"$description": "",
		}
	}
};

function _buildGadget(page) {
	if (page.dashboardName) {
		return _buildDashboardGadget(page);
	} else {
		return _buildRepresentationGadget(page);
	}
}

function _buildRepresentationGadget(page) {
	return {
		"$type": "$representation",
		"$title": page.title,
		"entity": page.entity,
		"action": page.action,
		"representation": page.representation,
		"facet": page.facet,
		"keyParameter": page.key,
		"endpoint": page.endpoint,
		"applicationName": page.applicationName,
		"icon": page.icon,
	};
}

function _buildDashboardGadget(page) {
	return {
		"$type": page.$type || "$dashboard",
		"$title": page.title,
		"dashboardName": page.dashboardName,
		"applicationName": page.applicationName,
		"sdataParameters": page.sdataParameters, // Contains url with key value pairs like code=444&group=123&bpcnum=123
		"endpoint": page.endpoint,
		"icon": page.icon,
	};
}

function _addPinnedPages(dashboard, apps, voiceBookmarks) {
	var grp;
	var pageId = 1;
	var tileConfigs;
	var endpoint = globals.getEndpoint();
	var appNames;

	appNames = apps.map(function(a) {
		return a.applicationName;
	});

	return settings.getTileConfigs()
		.then(function(tc) {
			tileConfigs = tc;
		})
		.then(function() {
			return settings.getPinnedPages();
		})
		.then(function(pp) {
			if (pp.length <= 0) {
				return;
			}
			grp = {
				"$layoutType": "hubGroup",
				"$title": locale.text("welcome.myquicklinks"),
				"$items": []
			};
			pp.forEach(function(page) {
				if (appNames.indexOf(page.applicationName) >= 0) {

					// ID see also settings.js if you change here!
					var config = tileConfigs["pin-" + page.id];

					config = config || {};
					var gadgetName = "$$$" + pageId;
					pageId++;
					var vignetteName = gadgetName;
					var gadget = _buildGadget(page);
					// No filter on endpoint (switch endpoint)
					if (nativeVoiceCommmands) {
						var voiceCmd = nativeVoiceCommmands.createCommandFromPage(page, config.title);
						if (voiceCmd) voiceBookmarks.push(voiceCmd);
					}
					if (gadget.endpoint === endpoint) {
						gadget.$title = config.title || gadget.$title;
						gadget.icon = config.icon || gadget.icon;
						// Used to find which page was pinned in this gadget in case we remove directly on welcome page
						gadget.pinPageId = page.id;
						dashboard.$gadgets[gadgetName] = gadget;
						dashboard.$vignettes[vignetteName] = {
							"$uuid": gadgetName,
							"$displayStyle": "$link"
						};
						grp.$items.push({
							$layoutType: "tile",
							$bgColor: config.color || "darkgrey",
							$items: [{
								$bind: vignetteName
							}],
							$size: config.size || "medium"
						});
					}
				}
			});
		})
		.then(function() {
			if (grp && grp.$items && grp.$items.length > 0) {
				dashboard.$article.$items.push(grp);
			}
		});

}

function _addApps(dashboard, apps, voiceBookmarks) {

	var apps;
	var hiddenApps;
	var groups = {
		sageAppli: {
			"$layoutType": "hubGroup",
			"$title": locale.text("welcome.sageapp"),
			"$items": []
		},
		byDefault: {
			"$layoutType": "hubGroup",
			"$title": locale.text("welcome.myapps"),
			"$items": []
		}
	};
	var tileConfigs;
	return settings.getTileConfigs()
		.then(function(tc) {
			tileConfigs = tc;
		})
		.then(function() {
			return settings.getHiddenApplications();
		})
		.then(function(hiddenAppsList) {
			hiddenApps = hiddenAppsList;

			// Make list availabe for later use in page
			_appList.hidden = [];
			_appList.visible = [];
			hiddenApps.forEach(function(name) {
				apps.forEach(function(appInfo) {
					if (name === appInfo.applicationName) {
						_appList.hidden.push(appInfo);
					}
				});
			});

			apps.forEach(function(appInfo) {
				var name = appInfo.applicationName;
				if (appInfo.applicationName !== _welcomeApplication.$application.applicationName && hiddenApps.indexOf(name) < 0) {
					_appList.visible.push(name);

					var config = tileConfigs["app-" + name];
					config = config || {};
					var name = "$welcome_" + appInfo.applicationName;
					var gadget = {
						"$type": "$application",
						"$title": config.title || appInfo.title,
						"applicationName": appInfo.applicationName,
						"icon": config.icon || appInfo.iconName
					};
					var vignette = {
						"$uuid": name
					};
					if (nativeVoiceCommmands) {
						var voiceCmd = nativeVoiceCommmands.createCommandFromAppli(gadget.$title, appInfo);
						if (voiceCmd) voiceBookmarks.push(voiceCmd);
					}
					dashboard.$gadgets[name] = gadget;
					dashboard.$vignettes[name] = vignette;
					var appTile = {
						$layoutType: "tile",
						$bgColor: config.color,
						$items: [{
							$bind: name
						}],
						$size: config.size || "medium"
					};
					_checkTileStatus(appInfo, appTile);
					groups[appInfo.isSageApplication ? "sageAppli" : "byDefault"].$items.push(appTile);
				}
			});
			for (var p in groups) {
				if (globals.isDvlpMode() || p !== "sageAppli") {
					if (groups[p].$items.length > 0) {
						dashboard.$article.$items.push(groups[p]);
					}
				}
			}
		});
}

function _checkTileStatus(app, appTile) {
	if (app.versionNumber == null) { // No version number, so it's a client side app, no need to test any states
		return;
	}
	if (app.localVersionNumber == null) { // App is not yet in the cache and needs to be setup
		// Do not show the setup icon since it was recognized as missleading by some users
		//appTile.$icon = "appSetup";
	} else if (app.localVersionNumber != app.versionNumber) {
		appTile.$icon = "appUpdate";
	}
}

/* we pass appMetaData as parameter to allow $update to refresh it (original appMetaData has been cloned) - see getAppDetail*/
function _updateWelcomeDashboard(dashboard) {
	var meta = globals.getMetaData();
	var appList;
	dashboard.$gadgets = {};
	dashboard.$vignettes = {};
	dashboard.$article = {
		"$layoutType": "hub",
		"$items": []
	};

	// All titles of the welcome page will be put into this list to allow the user
	// to start the application and invoke a bookmark by a voice command
	var voiceBookmarks = nativeVoiceCommmands ? [] : null;

	dashboard.$title = locale.text("welcome.title.home");
	return $.smResolve()
		.then(function() {
			var forceReadApps = globals.needToCheckAppsList();
			globals.setNeedToCheckAppsList(false);
			forceReadApps = forceReadApps && globals.isOnline();
			return meta.getApplications(forceReadApps);
		})
		.then(function(apps) {
			appList = apps;
		})
		.then(function() {
			return _addPinnedPages(dashboard, appList, voiceBookmarks);
		})
		.then(function() {
			return _addApps(dashboard, appList, voiceBookmarks);
		})
		.then(function() {
			// Make all gadgets present on welcomepage accessible by voice commands
			if (voiceBookmarks) {
				nativeVoiceCommmands.setVoiceCommands(voiceBookmarks);
			}
			return dashboard;
		})
		.fail(function(e) {
			console.log(e);
			return $.smReject(e);
		});
}

exports.register = function() {
	clientContract.registerApp(_welcomeApplication);
};

/* 
 * Returns the list of applications available to the user that were hidden by settings during
 * the last initialisation of the dashboard.
 * This list is the list of applications that the user could add to the welcome page if he want's to
 */
exports.getApplicationLists = function() {
	return _appList;
};
});

define('syracuse-tablet/html/js/ui/modals/modalChooseApps',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="form-group s-m-scroll-element"> \
					<div class="list-group">\
						{{#each appList}} \
							<a draggable="false" href="#" class="list-group-item" data-action="clickApp" data-params="{{applicationName}}">\
								<h4 class="list-group-item-heading">{{title}}</h4>\
								<p class="list-group-item-text">{{description}}</p>\
							</a>\
						{{/each}} \
					</div> \
				</div> \
			</div>',
	footer: ''
};

var _Klass = utils.defineClass(
	function ModalChooseApps(appList) {
		var self = this;
		modalDialog.ModalBase.call(self);
		// Init params
		self.appList = [];
		appList.forEach(function(a) {
			self.appList.push(a);
		});

		// Result
		self.selectedApps = {};
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "half_right";
			} else {
				displayFlags.modalClass = "full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			return {
				label_validate: locale.text("welcome.select.app.add"),
				label_cancel: locale.text("welcome.select.app.cancel"),
				title: locale.text("welcome.select.app.title"),
				appList: self.appList
			};
		},

		// could be removed, result is set in _onAction
		_onValidate: function() {

		},
		_onCancel: function() {
			var self = this;
			self.selectedApps = {};
		},

		_onAction: function(action, param) {
			var self = this;
			if (action === "clickApp") {
				var $$app = self.$$elmt.find('[data-params="' + param + '"]');
				if (self.selectedApps[param]) {
					$$app.removeClass("active");
					delete self.selectedApps[param];
				} else {
					$$app.addClass("active");
					self.selectedApps[param] = true;
				}
			}
			// dont close on actions
			return false;
		},

		_getResult: function() {
			var self = this;
			return Object.keys(self.selectedApps);
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalConfigTile',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/authoring/authoringProperties'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var authoringProperties = require('syracuse-tablet/html/js/authoring/authoringProperties');

var _templateAll = {
	header: '\
		<buttons class="pull-right"> \
			<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
			<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
		</buttons> \
		<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="form-group s-m-scroll-element"> \
					<label>{{lab_title}}</label> \
					<input id="tile_title" value="{{tileTitle}}"> \
					<label>{{lab_color}}</label> \
					<div class="s-m-list-colors">\
						{{#each colors}} \
							<a draggable="false" href="#" {{#if active}}class="active"{{/if}} data-action="clickColor" data-params="{{value}}">\
								<div class="s-m-bg s-m-color-{{value}}"> \
								</div> \
							</a>\
						{{/each}} \
					</div> \
					<label>{{lab_size}}</label> \
					<div class="s-m-list-sizes">\
						{{#each sizes}} \
							<a draggable="false" href="#" {{#if active}}class="active"{{/if}} data-action="clickSize" data-params="{{value}}">{{label}}</a>\
						{{/each}} \
					</div> \
					<label>{{lab_icon}}</label> \
					<div class="s-m-list-icons">\
						{{#each icons}} \
							<a draggable="false" href="#" {{#if active}}class="active"{{/if}} data-action="clickIcon" data-params="{{value}}"> \
								<i class="{{label}}"/> \
							</a>\
						{{/each}} \
					</div> \
					<div style="width:100%; display: inline-block;"></div> \
				</div> \
			</div>',

	footer: '',
};

var _Klass = utils.defineClass(
	function ModalConfigTile(tile) {
		var self = this;
		modalDialog.ModalBase.call(self);

		// Init params
		self.tile = tile;
		// Result
		self.result = null;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "config-tile half_right";
			} else {
				displayFlags.modalClass = "config-tile full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			authoringProperties.initProperties();

			var properties = authoringProperties.getAllProperties();
			var data = {
				label_validate: locale.text("welcome.tile.cfg.ok"),
				label_cancel: locale.text("welcome.tile.cfg.cancel"),
				title: locale.text("welcome.tile.cfg.title"),

				lab_title: locale.text("welcome.tile.cfg.lab_title"),
				lab_color: locale.text("welcome.tile.cfg.lab_color"),
				lab_size: locale.text("welcome.tile.cfg.lab_size"),
				lab_icon: locale.text("welcome.tile.cfg.lab_icon")
			};

			data.colors = properties.tileColor.values.map(function(e) {
				return {
					active: self.tile.color === e.value,
					value: e.value,
					label: e.label
				};
			});

			data.sizes = properties.tileSize.values.map(function(e) {
				return {
					active: self.tile.size === e.value,
					value: e.value,
					label: e.label
				};
			});

			data.icons = fontUtils.getTileIconList().map(function(e) {
				var cls = fontUtils.getIconByName(e);
				return {
					active: self.tile.icon === e,
					value: e,
					label: cls
				};
			});

			data.tileTitle = self.tile.title;
			return data;
		},

		// could be removed, result is set in _onAction
		_onValidate: function() {
			var self = this;
			var $$selected = self.$$elmt.find('a.active');
			var i;

			var tile = $.extend(true, {}, self.tile);

			tile.title = self.$$elmt.find("#tile_title").val();

			for (i = 0; i < $$selected.length; i++) {
				var action = $($$selected[i]).attr("data-action");
				var param = $($$selected[i]).attr("data-params");
				switch (action) {
					case "clickColor":
						tile.color = param;
						break;
					case "clickSize":
						tile.size = param;
						break;
					case "clickIcon":
						tile.icon = param;
						break;
				}
			}
			self.result = tile;
		},
		_onCancel: function() {
			var self = this;
			self.result = null;
		},

		_onAction: function(action, param) {
			var self = this;
			switch (action) {
				case "clickColor":
				case "clickSize":
				case "clickIcon":
					var $$old = self.$$elmt.find('a.active[data-action="' + action + '"]');
					var $$new = self.$$elmt.find('a[data-action="' + action + '"][data-params="' + param + '"]');
					$$old.removeClass("active");
					$$new.addClass("active");
					break;
			}
			// dont close on actions
			return false;
		},

		_getResult: function() {
			var self = this;
			return self.result;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/pages/pageWelcomeDashboard',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/pages/pageDashboard','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/application/settings','syracuse-tablet/html/js/sdata/entities/welcomeApplication','syracuse-tablet/html/js/ui/modals/modalChooseApps','syracuse-tablet/html/js/ui/modals/modalConfigTile'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/pages/pageDashboard').Page;
var locale = require('syracuse-tablet/html/js/helpers/locale');
var settings = require('syracuse-tablet/html/js/application/settings');
var welcomeApplication = require('syracuse-tablet/html/js/sdata/entities/welcomeApplication');
var modalChooseApps = require('syracuse-tablet/html/js/ui/modals/modalChooseApps');
var modalConfigTile = require('syracuse-tablet/html/js/ui/modals/modalConfigTile');

var _initConfigPage = false;

var _Page = utils.defineClass(

	function WelcomeDashboardPage($parent, state, prototype, article) {
		Base.call(this, $parent, state, prototype, article, {
			breadcrumbs: false
		});
		this.vignettes = [];
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
		},

		beforeAddContent: function() {
			// We do not show a title on the welcome page
			//this.addTitle(this.prototype.data("$title"), this.prototype.data("$description"));
			this.$$elmt.addClass("s-m-page-welcome-background");
		},

		buildHtmlOption: function(loadOptions) {
			var self = this;
			return Base.prototype.buildHtmlOption.call(self, loadOptions)
				.then(function(opts) {
					return $.extend(true, {}, opts, {
						makeFullHeight: false,
						toolBars: {
							showAuthoring: false,
							showUserMenuLinks: true,
							showHome: false,
							showPageConfig: true,
							showDrafts: true,
							statusPinPage: 0
						}
					});
				});
		},

		afterRender: function(loadOptions, buildOpts) {
			var self = this;
			// This page is loaded synchronously - We need to wait until all vignettes has been loaded to continue
			// Needed by the restoreContext process (see application.notifUserLoggedIn)
			loadOptions.forceSynchroVignettes = true;
			return Base.prototype.afterRender.call(self, loadOptions, buildOpts).then(function() {
				if (_initConfigPage) {
					self._initConfigUI();
				}
				_initConfigPage = false;
			});
		},

		_actPageConfig: function() {
			var self = this;
			self._initConfigUI();
		},

		_actCancelPageConfig: function() {
			var self = this;

			self._destroyConfigUI();
		},

		_actRemoveTile: function(vignetteId) {
			var self = this;
			var tile = self._getTileInfo(vignetteId);

			var first;
			if (tile.gadget.pinPageId) {
				first = settings.removePinnedPage(tile.gadget.pinPageId);
			} else {
				first = settings.hideApplication(tile.gadget.applicationName);
			}

			first.then(function() {
				return self._afterChangePage();
			});
		},

		_actAddWelcomeApp: function() {
			var self = this;
			var modal = new modalChooseApps.Modal(self._appList.hidden);
			modal.show().then(function(result) {
				if (result && result.length > 0) {
					$.smForEachPromise(result, function(app) {
						return settings.unhideApplication(app);
					})
						.then(function() {
							return self._afterChangePage();
						});
				}
			});
		},

		_afterChangePage: function() {
			var self = this;
			_initConfigPage = true; // Force auto start of page config on reload
			globals.getApplication().gotoWelcomeApplication(null, true);
		},

		_actConfigTile: function(vignetteId) {
			var self = this;

			var ti = self._getTileInfo(vignetteId);
			var classes = ti.$$tile.attr("class");

			var size = "medium";
			var cls = classes.split(" ");
			var validSizes = ["small", "medium", "wide", "large", "full", "all"];
			cls && cls.some(function(c) {
				if (validSizes.indexOf(c) > -1) {
					size = c;
					return true;
				}
				return false;
			});

			var color = /s-m-color-(\w+)/.exec(classes);
			color = (color && color.length > 1 && color[1]) || "darkgrey";
			var tile = {
				title: ti.gadget.$title,
				color: color,
				size: size,
				icon: ti.gadget.icon
			};
			var modal = new modalConfigTile.Modal(tile);
			modal.show().then(function(result) {
				if (result != null) {
					self._applyTileChanges(ti, result);
				}
			});
		},

		_applyTileChanges: function(tileInfo, tile) {
			var self = this;
			var tileId;
			if (tileInfo.gadget.pinPageId) {
				tileId = "pin-" + tileInfo.gadget.pinPageId;
			} else {
				tileId = "app-" + tileInfo.gadget.applicationName;
			}
			tile.tileId = tileId;
			settings.setTileConfig(tile)
				.then(function() {
					self._afterChangePage();
				});
		},

		_initConfigUI: function() {
			var self = this;

			self._appList = welcomeApplication.getApplicationLists();

			var $$header = $(".s-m-control.header", self.$elmt);
			self.$$pageConfigHeader = $(
				'<div class="s-m-page-config-header">\
					<div class="pull-left">\
						<btn class="hidden addapp btn fa fa-cubes" data-action="addWelcomeApp">' + locale.text("page.configure.add.app") + '\
						</btn>\
					</div>\
			  	<div class="pull-right">\
					<btn class="cancel btn glyphicon glyphicon-remove" data-action="cancelPageConfig"></btn>\
				</div>\
			</div>');

			$$header.append(self.$$pageConfigHeader);

			if (self._appList.hidden.length > 0) {
				$('[data-action=addWelcomeApp]', $$header).removeClass("hidden");
			}
			var $$tiles = $(".s-m-tile", self.$$elmt);
			$$tiles.addClass("s-m-tile-edit");
			for (var i = 0; i < $$tiles.length; i++) {
				var $$tile = $($$tiles[i]);
				$$tile.attr("data-tile-config-id", i);

				var $$vignette = $(".s-m-vignette", $$tile);
				$$tile.append($('<btn class="cfg config fa fa-pencil" data-action="configTile" data-params="' + $$vignette.attr('id') + '">'));
				$$tile.append($('<btn class="cfg remove fa fa-trash-o" data-action="removeTile" data-params="' + $$vignette.attr('id') + '">'));
			}

			$(".s-m-control.footer", self.$elmt).css({
				display: "none"
			});
		},

		_destroyConfigUI: function() {
			var self = this;
			if (self.$$pageConfigHeader) {
				self.$$pageConfigHeader.remove();
				self.$$pageConfigHeader = null;
			}

			$(".s-m-control.footer", self.$elmt).css({
				display: "block"
			});

			$(".s-m-tile-edit").removeClass("s-m-tile-edit");
			$(".s-m-tile btn.remove", self.$elmt).remove();
			$(".s-m-tile btn.config", self.$elmt).remove();
		},

		_getTileInfo: function(vignetteId) {
			var ctrl = this.getControl(vignetteId);
			if (!ctrl) {
				return;
			}
			var $$vignette = $("#" + vignetteId);
			var $$tile = $$vignette.closest(".s-m-tile");
			return {
				$$tile: $$tile,
				$$vignette: $$vignette,
				$$remove: $(".s-m-tile btn.remove", $$tile),
				ctrl: ctrl,
				gadget: ctrl.prototype.data("$gadget"),
			};
		},
		/**
		 * Return always false to force to load this page even if it's the current one (context could change and we need to reload the page))
		 */
		isSamePage: function(state) {
			return false;
		}
	});

exports.Page = _Page;
});

define('syracuse-tablet/html/js/sdata/sdatawhere/operator',['require','exports','module','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {"use strict";
var helpers = require('syracuse-tablet/html/js/helpers/utils');

exports.Operator = function(code, text, precedence, isPrefix, isInfix, isAssociative, isPredicate) {
	var self = this;
	self.code = code;
	self.text = text;
	self.precedence = precedence;
	self.isPrefix = isPrefix;
	self.isInfix = isInfix;
	self.isAssociative = isAssociative;
	self.isPredicate = isPredicate;
};
helpers.defineClass(exports.Operator, null, {
	toString: function() {
		return this.text;
	}
});

exports.operators = new function() {
	var self = this;
	self.operators = { //length : 0
	};

	init();

	function createOp(code, text, precedence, isPrefix, isInfix, isAssociative, isPredicate) {
		var op = new exports.Operator(code || text, text, precedence, isPrefix, isInfix, isAssociative, isPredicate);
		self.operators[op.text] = op;
		//self.operators.length++;
	}

	function init() {
		// codes are SQL operators - makes SQL conversion easy
		createOp(null, ".", 1, false, true, true, false);
		createOp(null, "not", 2, true, false, false, false);
		createOp("*", "mul", 3, false, true, true, false);
		createOp("/", "div", 3, false, true, true, false);
		createOp("%", "mod", 3, false, true, true, false);
		createOp(null, "+", 4, false, true, true, false);
		createOp(null, "-", 4, true, true, true, false);
		createOp("=", "eq", 5, false, true, false, true);
		createOp("<>", "ne", 5, false, true, false, true);
		createOp("<", "lt", 5, false, true, false, true);
		createOp("<=", "le", 5, false, true, false, true);
		createOp(">", "gt", 5, false, true, false, true);
		createOp(">=", "ge", 5, false, true, false, true);
		createOp(null, "between", 5, false, true, false, true);
		createOp(null, "in", 5, false, true, false, true);
		createOp(null, "like", 5, false, true, false, true);
		createOp(null, "and", 6, false, true, true, true);
		createOp(null, "or", 7, false, true, true, true);
		createOp(null, "(", 8, true, false, false, false);
		createOp(null, ")", 8, false, false, false, false);
		createOp(null, ",", 8, false, false, false, false);
	}

	return self;

};
});

define('syracuse-tablet/html/js/sdata/sdatawhere/token',['require','exports','module','syracuse-tablet/html/js/helpers/utils','./operator'],function (require, exports, module) {"use strict";
var helpers = require('syracuse-tablet/html/js/helpers/utils');
var operators = require('./operator');

exports.tokenType = {
	identifier: 'identifier',
	operator: 'operator',
	literal: 'literal'
};

exports.Token = function(type, line, offset, length, val) {
	var self = this;
	self.type = type;
	self.value = val;

	var _line = line;
	var _offset = offset;
	var _length = length;
	self.getRemainingText = function() {
		return _line.substring(_offset, _line.length);
	};
};

helpers.defineClass(exports.Token, null, {
	matches: function(code) {
		return this.value instanceof operators.Operator && this.value.code == code;
	}
});
});

define('syracuse-tablet/html/js/sdata/sdatawhere/tokenizer',['require','exports','module','./token','./operator'],function (require, exports, module) {"use strict";

var token = require('./token');
var operators = require('./operator');

exports.Tokenizer = new function() {
	var self = this;

	function _skipSpaces(chars, i) {
		while (i < chars.length && chars[i] === " ") {
			i++;
		}
		return i;
	}

	function _isDigit(str) {
		return new RegExp('[0-9]').test(str);
	}

	function _isLetter(str) {
		return new RegExp('[\$a-zA-Z%\']').test(str);
	}

	function _isWordChar(str) {
		return new RegExp('[\$a-zA-Z0-9_%\']').test(str);
	}

	function _parseNumber(line, chars, i, tokens) {
		var end = i + 1;
		while (end < chars.length && _isDigit(chars[end])) {
			end++;
		}
		var val;
		if (end < chars.length && chars[end] === '.') {
			end++;
			while (end < chars.length && _isDigit(chars[end])) {
				end++;
			}
			val = parseFloat(line.substring(i, end));

		} else {
			val = parseInt(line.substring(i, end), 10);
		}
		tokens.push(new token.Token(token.tokenType.literal, line, i, end - i,
			val));
		return end;
	}

	var _literals = {
		"true": true,
		"false": false,
		"null": null,
	};

	function _parseWord(line, chars, i, tokens) {
		var end = i + 1;
		while (end < chars.length && _isWordChar(chars[end])) {
			end++;
		}
		var word = chars.substr(i, end - i);
		var op = operators.operators.operators[word.toLowerCase()];
		if (op != null) {
			tokens.push(new token.Token(token.tokenType.operator, line, i, end - i, op));
		} else {
			var lit;
			if ((lit = _literals[word]) !== undefined) {
				tokens.push(new token.Token(token.tokenType.literal, line, i,
					end - i, lit));
			} else {
				tokens.push(new token.Token(token.tokenType.identifier, line,
					i, end - i, word));
			}
		}
		return end;
	}

	function _parseQuotedString(line, chars, i, tokens) {
		var quote = chars[i];
		var end = i + 1;
		var dest = 0;
		var res = "";
		while (end < chars.length) {
			if (chars[end] === quote) {
				end++;
				if (end === chars.length || chars[end] !== quote) {
					tokens.push(new token.Token(token.tokenType.literal, line,
						i, end - i, res));
					return end;
				}
			}
			res += chars[end++];
		}
		throw new Error('quoted string not terminated: ' + line.substring(i));
	}

	function _parseOperator(line, ch, i, tokens) {
		var op = operators.operators.operators[ch];
		tokens.push(new token.Token(token.tokenType.operator, line, i, 1, op));
		return i + 1;
	}

	function _parseDateTime(line, chars, i, tokens) {
		var end = i + 1,
			len = chars.length;
		while (end < len) {
			if (chars[end] == '@')
				break;
			end++;
		}
		if (end === chars.length) {
			throw new Error('Where parser: date constant not terminated:' + line.substring(i, line.length));
		}
		var str = chars.substr(i + 1, end - i - 1);
		var dt = new Date(str);
		if (dt != null) {
			var nt = new token.Token(token.tokenType.literal, line, i, end + 1 - i, dt);
			nt.dataType = "datetime";
			nt.svalue = str;
			tokens.push(nt);
		}
		return end + 1;
	}

	self.tokenize = function(line) {
		var tokens = [];
		var i = 0;
		while (i < line.length) {
			i = _skipSpaces(line, i);
			var ch = line[i];
			switch (ch) {
				case '@':
					i = _parseDateTime(line, line, i, tokens);
					break;
				case '"':
				case '\'':
					i = _parseQuotedString(line, line, i, tokens);
					break;
				case '.':
				case '-':
				case '+':
				case '(':
				case ')':
				case ',':
					i = _parseOperator(line, ch, i, tokens);
					break;
				default:
					if (_isLetter(ch)) {
						i = _parseWord(line, line, i, tokens);
					} else if (_isDigit(ch)) {
						i = _parseNumber(line, line, i, tokens);
					} else {
						throw new Error('invalid character: ' + line.substring(i));
					}
					break;
			}
		}

		return tokens;
	};

	return self;
};
});

define('syracuse-tablet/html/js/sdata/sdatawhere/expression',['require','exports','module','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {"use strict";
var helpers = require('syracuse-tablet/html/js/helpers/utils');

exports.Expression = function(config) {
	var self = this;

	self.children = null;
	if (config.operator) {
		self.type = "operator";
		self.value = config.operator;
		self.children = [];
		if (config.expression1) {
			self.children.push(config.expression1);
		}
		if (config.expression2) {
			self.children.push(config.expression2);
		}
	} else if (config.expressionType) {
		self.type = config.expressionType;
		self.value = config.value;
		self.svalue = config.svalue;
		self.dataType = config.dataType;
		if (self.type === "function") {
			self.children = [];
		}
	}
};
helpers.defineClass(exports.Expression, null, {
	isPredicate: function() {
		switch (this.type) {
			case "operator":
				return this.value.isPredicate;
			case "identifier":
				return true; // don't know
			case "function":
				return true; // don't know -- will improve later
			case "literal":
				return false;
			default:
				throw new Error("invalid expression type: " + this.type);
		}
	},
	toString: function() {
		if (this.children == null) {
			return this.value.toString();
		}
		var sb = [];
		sb.push("[" + this.value.toString());
		for (var i = 0; i < this.children.length; i++) {
			sb.push(" " + this.children[i].toString());
		}
		sb.push("]");
		return sb.join('');
	}

});
});

define('syracuse-tablet/html/js/sdata/sdatawhere/parser',['require','exports','module','./token','./operator','./tokenizer','./expression'],function (require, exports, module) {"use strict";
var token = require('./token');
var operators = require('./operator');
var tokenizer = require('./tokenizer');
var expression = require('./expression');

exports.Parser = new function() {
	var self = this;
	var _maxPrecedence = 8;

	function _finishBetween(tokens, tokenIndex, exp, precedence) {
		if (tokenIndex[0] == tokens.length || !tokens[tokenIndex[0]].matches("and")) {
			throw new Error("invalid expression: expected 'and' after " + tokens[tokenIndex[0] - 1].getRemainingText());
		}
		tokenIndex[0]++;
		var arg = _parseExpression(tokens, tokenIndex, precedence);
		exp.children.push(arg);
	}

	function _parseExpression(tokens, tokenIndex, precedence) {
		var exp = _parseTerm(tokens, tokenIndex);
		while (tokenIndex[0] < tokens.length) {
			var tk = tokens[tokenIndex[0]];
			var op = tk.value instanceof operators.Operator ? tk.value : null;
			if (op == null || !op.isInfix || op.precedence > precedence) {
				break;
			}
			tokenIndex[0]++;
			if (op.code == "in") {
				if (tokenIndex[0] === tokens.length || !tokens[tokenIndex[0]].matches("(")) {
					throw new Error("invalid expression: '(' expected after " + tk.getRemainingText());
				}
				tokenIndex[0]++;
				exp = new expression.Expression({
					operator: op,
					expression1: exp
				});
				_parseArguments(tokens, tk, tokenIndex, exp.children);
			} else {
				var arg = _parseExpression(tokens, tokenIndex, op.precedence - 1);
				exp = new expression.Expression({
					operator: op,
					expression1: exp,
					expression2: arg
				});
				if (op.code == "between") {
					_finishBetween(tokens, tokenIndex, exp, op.precedence);
				}
			}
			if (!op.isAssociative && op.precedence == precedence) {
				return exp;
			}
		}
		return exp;
	}

	function _parseTerm(tokens, tokenIndex) {
		if (tokenIndex[0] == tokens.length) {
			throw new Error("premature end of expression");
		}
		var tk = tokens[tokenIndex[0]];
		switch (tk.type) {
			case token.tokenType.identifier:
				tokenIndex[0]++;
				if (tokenIndex[0] < tokens.length && tokens[tokenIndex[0]].matches("(")) {
					return _parseFunctionCall(tokens, tk, tokenIndex);
				} else {
					return new expression.Expression({
						expressionType: "identifier",
						value: tk.value
					});
				}
			case token.tokenType.literal:
				tokenIndex[0]++;
				return new expression.Expression({
					expressionType: "literal",
					value: tk.value,
					svalue: tk.svalue,
					dataType: tk.dataType
				});
			case token.tokenType.operator:
				var op = tk.value;
				if (!op.isPrefix) {
					throw new Error("invalid expression: expected beginning of term at " + tk.getRemainingText());
				}
				tokenIndex[0]++;
				return _parsePrefixOperator(tokens, op, tokenIndex);
			default:
				throw new Error("internal error: bad token type " + tk.type);
		}
	}

	function _parseArguments(tokens, tk, tokenIndex, arguments0) {
		if (tokenIndex[0] < tokens.length && tokens[tokenIndex[0]].matches(")")) {
			tokenIndex[0]++;
			return;
		}
		while (tokenIndex[0] < tokens.length) {
			var arg = _parseExpression(tokens, tokenIndex, _maxPrecedence);
			arguments0.push(arg);
			if (tokenIndex[0] < tokens.length && tokens[tokenIndex[0]].matches(")")) {
				tokenIndex[0]++;
				return;
			}
			if (tokenIndex[0] == tokens.length || !tokens[tokenIndex[0]].matches(",")) {
				throw new Error("invalid expression: expected ',' or ')' at " + tokens[tokenIndex[0]].getRemainingText());
			}
			tokenIndex[0]++;
		}
		throw new Error("invalid function call syntax: argument missing after " + tk.getRemainingText());
	}

	function _parsePrefixOperator(tokens, op, tokenIndex) {
		var arg1;
		switch (op.code) {
			case "-":
			case "not":
				arg1 = _parseExpression(tokens, tokenIndex, 1);
				return new expression.Expression({
					operator: op,
					expression1: arg1
				});
			case "(":
				arg1 = _parseExpression(tokens, tokenIndex, op.precedence);
				//require('term').stream.print('???' + tokens[tokenIndex[0]].value);
				if (tokenIndex[0] == tokens.length || !tokens[tokenIndex[0]].matches(")")) {
					throw new Error("invalid expression: expected ')' after " + tokens[tokenIndex[0] - 1].getRemainingText());
				}
				tokenIndex[0]++;
				return arg1;
			default:
				throw new Error("internal error: bad prefix operator " + op.code);
		}
	}

	function _parseFunctionCall(tokens, tk, tokenIndex) {
		tokenIndex[0]++;
		var exp = new expression.Expression({
			expressionType: "function",
			value: tk.value
		});
		_parseArguments(tokens, tk, tokenIndex, exp.children);
		return exp;
	}

	self.parse = function(str) {
		if (str == null || str.length == 0) {
			return null;
		}
		var tokens = tokenizer.Tokenizer.tokenize(str);
		var tokenIndex = [];
		tokenIndex[0] = 0;
		var exp = _parseExpression(tokens, tokenIndex, _maxPrecedence);
		if (tokenIndex[0] != tokens.length) {
			throw new Error("invalid expression: unexpected token at " + tokens[tokenIndex[0]].getRemainingText());
		}
		return exp;
	};

	return self;
};
});

define('syracuse-tablet/html/js/sdata/sdatawhere/whereUtils',['require','exports','module'],function (require, exports, module) {"use strict";

function _exec(data, exp, proto) {
	if (exp.type == "identifier") {
		exp.property = data[exp.value];
		// issue #3744 in X3 boolean properties has numeric values
		// and in the x3 filters (where clauses use numeric values 1(false) and
		// 2(true) for boolean properties)
		var item = proto && proto.$properties && proto.$properties.$resources ? proto.$properties.$resources.$item : null;
		if (item && item.$properties && item.$properties[exp.value] && item.$properties[exp.value].$type === "application/x-boolean") {
			exp.property = exp.property === true ? 2 : 1;
		}
	} else if (exp.type == "literal") {
		exp.property = (exp.dataType == "datetime") ? exp.svalue : exp.value;
	} else {
		if (exp.children) {
			var property = null;

			// propagate property from child to parent if operator if low level
			// operator
			if (exp.type == "operator") {
				switch (exp.value.code) {

					case "and":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property && exp.children[1].property);
						break;
					case "or":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property || exp.children[1].property);
						break;
					case "between":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property >= exp.children[1].property) && (exp.children[0].property <= exp.children[2].property);
						break;
					case ">=":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property >= exp.children[1].property);
						break;
					case ">":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property > exp.children[1].property);
						break;
					case "<=":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property <= exp.children[1].property);
						break;
					case "<":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property < exp.children[1].property);
						break;
					case "like_s":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property.toUpperCase()
							.indexOf(exp.children[1].property.toUpperCase()) === 0);
						break;
					case "like":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						var val = exp.children[1].property.toUpperCase().replace(
							/%/g, '');
						exp.property = (exp.children[0].property.toUpperCase()
							.indexOf(val) >= 0);
						break;
					case "=":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						if (exp.children[0].property == "0000-00-00" && exp.children[1].dataType === "datetime") {
							exp.children[0].property = "";
						}
						if (exp.children[1].property == "0000-00-00" && exp.children[0].dataType === "datetime") {
							exp.children[1].property = "";
						}
						exp.property = (exp.children[0].property == exp.children[1].property);
						break;
					case "<>":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						if (exp.children[0].property == "0000-00-00" && exp.children[1].dataType === "datetime") {
							exp.children[0].property = "";
						}
						if (exp.children[1].property == "0000-00-00" && exp.children[0].dataType === "datetime") {
							exp.children[1].property = "";
						}
						exp.property = (exp.children[0].property != exp.children[1].property);
						break;
					case ".":
						_exec(data, exp.children[0], proto);
						_exec(exp.children[0].property, exp.children[1], proto);
						exp.property = exp.children[1].property;
						break;
					default:
						exp.property = property;
						// propagate to literals
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
							if (child.type == "literal")
								child.property = property;
						});
				}
			} else if (exp.type == "function") {
				throw new Error("exp.type == 'function' not implemented");
			}
		}
	}
};

exports.execWhere = function(dataContext, exp, proto) {

	if (exp == null) {
		return true;
	}

	_exec(dataContext, exp, proto);

	return exp.property;

};
});

define('syracuse-tablet/html/js/sdata/sdataDispatcherLocal',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/sdata/sdatawhere/parser','syracuse-tablet/html/js/sdata/sdatawhere/whereUtils'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var parser = require('syracuse-tablet/html/js/sdata/sdatawhere/parser').Parser;
var whereUtils = require('syracuse-tablet/html/js/sdata/sdatawhere/whereUtils');

exports.Dispatcher = utils.defineClass(function() {}, null, {
	"getEntity": function($representation) {
		var repr = $representation && $representation.split(".");
		if (repr && repr[0] && repr[0].smStartsWith("QUERY~")) {
			repr = repr[0].split("~")[1];
		} else if (repr && repr[0] && repr[0].smStartsWith("STATS~")) {
			repr = repr[0].split("~")[1];
		} else {
			repr = repr && repr[0];
		}
		return repr && clientContract.getEntity(repr);
	},
	"accept": function(op, data) {
		var self = this;
		var deferred = $.Deferred();
		deferred.resolve(self.getEntity(op.$representation) != null);
		return deferred.promise();
	},

	"prototype": function(op, data) {
		var deferred = $.Deferred();
		deferred.reject("Dispatcher should never request for prototypes since they are cached in the application model on client side");
		return deferred.promise();
	},

	"new": function(op, data) {
		var self = this;
		var ent = self.getEntity(op.$representation);
		return ent.$services["$new"](op, data);
	},

	"read": function(op, data) {
		var self = this;
		var ent = self.getEntity(op.$representation);
		return ent.$services["$read"](op, data);
	},

	"query": function(op, data) {
		var self = this;
		var ent = self.getEntity(op.$representation);
		var list = ent.$services["$query"](op, data);

		// Apply where condition
		if (op.$where) {
			var deferred = $.Deferred();
			list.then(function(resources) {
				var list = resources.$resources;
				var exp = parser.parse(op.$where);
				var repr = op.$representation && op.$representation.split(".");
				var $proto = clientContract.getPrototype(repr[0], repr[1]);
				var res = [];
				list.forEach(function(item, i) {
					if (whereUtils.execWhere(item, exp, $proto)) {
						res.push(item);
					}
				});
				deferred.resolve({
					$resources: res
				});
			}).fail(function(e) {
				deferred.reject(e);
			});
			return deferred.promise();
		}
		return list;
	},

	"save": function(op, data) {
		var self = this;
		var ent = self.getEntity(op.$representation);
		return ent.$services["$save"](op, data);
	},

	"delete": function(op, data) {
		var self = this;
		var ent = self.getEntity(op.$representation);
		return ent.$services["$delete"](op, data);
	},
	"service": function(op, data) {
		var self = this;
		var ent = self.getEntity(op.$representation);
		return ent.$services[op.$service](op, data);
	}
});
});

define('syracuse-tablet/html/js/sdata/sdataDispatcherHttp',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/sdata/sdataHttp'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("sdataDispatcher");
var sdataHttp = require('syracuse-tablet/html/js/sdata/sdataHttp');

/**
 * Stores temporarily the whole JSON data of a 'query like' page
 */
var _authQueryCache = {};

// Set if cache is update is waiting to finish before sending result to caller or
// if cache is updated in parallel to get faster response times to the caller 
var _writeCacheModeSync = {
	// For query operations
	query: false,
	// For read operations
	read: false
};

// This function either returns a promise (sync stack execution) or the value
// expected to be returned by the promise (async stack execution)
function _returnSyncAsync(promise, result, sync) {
	if (sync) {
		var timeLine = utils.getTimeLine("cacheUpdate", utils.UUID());
		timeLine && timeLine.start("Start writing to cache");
		return promise.then(function() {
			timeLine && timeLine.step("completed");
			return result;
		});
	} else {
		return result;
	}
}

exports.Dispatcher = utils.defineClass(function() {
	notifications.subscribe(this, "sm.authcache.destroy");
}, null, {
	/**
	 * Called when a 'query like' page is destroyed to remove the cache stored in _authQueryCache
	 * See regularPage.destroy
	 */
	notifAuthcacheDestroy: function(pageId) {
		if (!pageId) return;
		//console.log("notifAuthcacheDestroy", pageId, _authQueryCache[pageId]!=null);
		_authQueryCache[pageId] = null;
	},
	"accept": function() {
		var deferred = $.Deferred();
		deferred.resolve(true);
		return deferred.promise();
	},

	_isOnline: function() {
		// Just wrapped here to have eventual dedicated tracing posibility
		return globals.isOnline();
	},

	/*
	 * Returns true if the ajax response is considered to be an offline error message
	 */
	_isOfflineError: function(result) {
		if (result && result.status < 100) {
			return true;
		}
		return false;
	},

	_networkError: function(titleId, result) {
		var title = locale.text(titleId, [result ? " - status=" + result.status : ""]);
		if (result && result.responseJSON && result.responseJSON.$diagnoses) {
			result.responseJSON.$title = title;
			// In case we want to dispatch process error differently
			result.responseJSON.$httpStatus = result.status;
			return $.smReject(result.responseJSON);
		}
		var detail = null;
		if (result && result.responseText) {
			// Sometimes X3 returns an error like a plain text (we display it)
			detail = result.responseText.trim();
			if (detail.smStartsWith('{') || detail.toLowerCase().indexOf('<html') >= 0) {
				detail = null;
			}
		}
		return $.smReject({
			$httpStatus: result.status,
			$title: title,
			detail: detail
		});
	},

	_offlineNoCachedDataMessage: function() {
		return $.smReject({
			$noConnectionError: true,
			$diagnoses: [{
				$message: locale.text("error.network.offline.cache"),
				$severity: "error"
			}]
		});
	},

	/**
	 *  Called for every request handled by the dispatcher
	 *  Can be used to disable caching in general or for specific representations
	 */
	_useCache: function(op, action) {
		var cache = globals.getCache();
		if (cache.isDisabled()) { // Disabled by dev features?
			return false;
		}

		var nocache = op.$parsedUrl && op.$parsedUrl.query && op.$parsedUrl.query.nocache;
		if (nocache && action === "read") {
			return false;
		}

		//		See #8448 I do not understand why we introduced this with #5191, so disabled		
		//		if (op.$representation.indexOf(".$edit") > 0 && action === "read") {
		//			return false;
		//		}
		return true;
	},

	// GET: {$baseUrl}/SUPERV//$prototypes('AQTCRUD.$query')
	"prototype": function(op, data, options) {
		var deferred = $.Deferred();
		deferred.reject("Dispatcher should never request for prototypes since they are cached in the application model on client side");
		return deferred.promise();
	},

	//GET: {$baseUrl}/SUPERV/AQTCRUD/$template?representation=AQTCRUD.$create
	"new": function(op, data, options) {
		var self = this;

		var cacheRead;
		var usedCache;
		if (self._isOnline()) {
			cacheRead = $.smResolve();
			usedCache = false;
		} else {
			cacheRead = self._newGetCache(op, data);
			usedCache = true;
		}

		return cacheRead.then(function(result) {
			// got new template from cache
			if (result) {
				log && log("Read template from cache: " + op.$representation);
				// Change UUID since we create a new record!
				result.$uuid = utils.UUID();
				return result;
			}
			return self._newDoHttp(op, data)
				.then(function(result) {
					if (result.isSuccess) {
						var data = result.responseJSON;
						return self._newPutCache(op, data)
							.then(function() {
								return data;
							});
					}
					if (!usedCache && (result.responseJSON == null || result.responseJSON.$noConnectionError === true)) {
						var netResult = result;
						return self._newGetCache(op, data)
							.then(function(result) {
								if (result) {
									log && log("Read template from cache fallback: " + op.$representation);
									// Change UUID since we create a new record!
									result.$uuid = utils.UUID();
									return result;
								}
								return self._networkError("sdata.error.template", netResult);
							});
					}
					return self._networkError("sdata.error.template", netResult);
				});
		});
	},

	_newGetCache: function(op) {
		var self = this;
		if (self._useCache(op, "read")) {
			var cache = globals.getCache();
			log && log("Reading template from cache: " + op.$representation);
			return cache.read({
				$representation: "$templates",
				$endpoint: op.$endpoint,
				$key: op.$representation
			});
		}
		log && log("Disabled reading template from cache : " + op.$representation);
		return $.smResolve();
	},
	_newDoHttp: function(op, data) {
		var send = {
			method: "GET",
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_newPutCache: function(op, data) {
		var self = this;
		if (self._useCache(op, "write")) {
			log && log("Writing template to cache: " + op.$representation);
			var cache = globals.getCache();
			return cache.put({
				$representation: "$templates",
				$key: op.$representation,
				$endpoint: op.$endpoint,
				$data: data
			});
		}
		log && log("Disabled writing template to cache : " + op.$representation);
		return $.smResolve();
	},

	//GET: {$baseUrl}/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$create
	"read": function(op, data, options) {
		var self = this;
		var cacheRead;
		var forceUseCache = options.forceUseCache;
		var usedCache;
		if (self._isOnline() && forceUseCache !== true) {
			cacheRead = $.smResolve();
			usedCache = false;
		} else {
			cacheRead = self._readGetCache(op, data);
			usedCache = true;
		}

		return cacheRead.then(function(result) {
			if (result) {
				log && log("Read data from cache: " + op.$representation);
				// $cacheHint tells caller that the cache has been used
				result.$cacheHint = {};
				return result;
			}
			return self._readDoHttp(op, data)
				.then(function(result) {
					if (result.isSuccess) {
						var data = result.responseJSON;
						var prom = self._readPutCache(op, data)
							.then(function() {
								return data;
							});
						return _returnSyncAsync(prom, data, _writeCacheModeSync.read);
					}
					if (!self._isOfflineError(result)) {
						return self._networkError("sdata.error.read", result);
					}
					if (!usedCache) {
						return self._readGetCache(op, data)
							.then(function(data) {
								if (data) {
									// $cacheHint tells caller that the cache has been used
									data.$cacheHint = {};
									return data;
								}
								return forceUseCache === true ? null : self._offlineNoCachedDataMessage();
							});
					}
					return forceUseCache === true ? null : self._offlineNoCachedDataMessage();
				});
		});
	},

	_readGetCache: function(op) {
		var self = this;
		if (self._useCache(op, "read")) {
			var cache = globals.getCache();
			log && log("Reading data from cache: " + op.$representation);
			return cache.read({
				$representation: op.$representation,
				$endpoint: op.$endpoint,
				$key: op.$key
			});
		}
		log && log("Disabled reading data from cache : " + op.$representation);
		return $.smResolve();
	},
	_readDoHttp: function(op, data) {
		var send = {
			method: "GET",
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_readPutCache: function(op, data) {
		var self = this;
		if (self._useCache(op, "write")) {
			log && log("Writing data to cache: " + op.$representation);
			var cache = globals.getCache();
			return cache.put({
				$representation: op.$representation,
				$key: op.$key,
				$endpoint: op.$endpoint,
				$data: data
			});
		}
		log && log("Disabled writing data to cache : " + op.$representation);
		return $.smResolve();
	},

	// GET: {$baseUrl}/SUPERV/AQTCRUD?representation=AQTCRUD.$create?where=xxx
	// dataToSend is unused
	"query": function(op, dataToSend, options) {
		var self = this;
		var cacheRead;
		var usedCache;
		var forceUseCache = options.forceUseCache;
		var isStatsRequest = op.$isRequest === true || op.$isStats === true;
		if ((self._useCache(op, "read") !== true) || (self._isOnline() && forceUseCache !== true)) {
			cacheRead = $.smResolve(null);
			usedCache = false;
		} else {
			cacheRead = self._queryReadCache(op, options);
			usedCache = true;
		}

		return cacheRead.then(function(cacheResult, isAuthCache) {
			var step;
			if (cacheResult != null) {
				log && log("Queried data from cache: " + op.$representation);
				if (isStatsRequest) {
					// STATS or REQUEST
					// for stats and requests we store the full page
					var response = cacheResult;
					if (!response) {
						response = {};
					}
					if (!response.$resources) {
						response.$resources = [];
					}
					step = $.smResolve(response);
				} else if (isAuthCache === true) {
					step = $.smResolve(cacheResult);
				} else {

					// QUERY
					// For queries we store the rows
					var response = {};
					step = self._queryCutAndAddLinks(op, cacheResult, response).then(function() {
						if (!response.$resources) {
							response.$resources = [];
						}
						if (response.$resources.length > 0) {
							// $cacheHint tells caller that the cache has been used
							response.$cacheHint = {};
						}
						return response;
					});
				}
			} else {
				step = $.smResolve(null);
			}

			return step.then(function(cacheResponse) {
				if (cacheResponse && cacheResponse.$resources && cacheResponse.$resources.length > 0) {
					return cacheResponse;
				}
				return self._queryDoHttp(op)
					.then(function(httpResult) {
						if (httpResult.isSuccess) {
							var data = httpResult.responseJSON || {};
							data.$resources = data.$resources || [];
							var prom;
							if (self._useCache(op, "write")) {
								var prom = self._queryPutCache(op, data, options)
									.then(function() {
										return data;
									});
							} else {
								// No cache
								log && log("Disabled writing data to cache : " + op.$representation);
								var prom = $.smResolve(data);
							}
							return _returnSyncAsync(prom, data, _writeCacheModeSync.query);
						}
						if (!self._isOfflineError(httpResult)) {
							return self._networkError("sdata.error.read", httpResult);
						}
						if (!usedCache) {
							// read the cache if not done before
							return self._queryReadCache(op, options)
								.then(function(cacheResult) {
									if (!cacheResult) {
										return forceUseCache === true ? null : self._offlineNoCachedDataMessage();
									}
									log && log("Queried data from cache: " + op.$representation);
									if (isStatsRequest) {
										// STATS or REQUEST
										var response = cacheResult;
										if (!response) {
											response = {};
										}
										if (!response.$resources) {
											response.$resources = [];
										}
										if (response.$resources.length > 0) {
											// $cacheHint tells caller that the cache has been used
											response.$cacheHint = {};
										}
										return $.smResolve(response);
									} else {
										// QUERY
										var response = {};
										return self._queryCutAndAddLinks(op, cacheResult, response).then(function() {
											if (!response.$resources) {
												response.$resources = [];
											}
											if (response.$resources.length > 0) {
												// $cacheHint tells caller that the cache has been used
												response.$cacheHint = {};
												return response;
											}
										});
									}
								});
						}
						return forceUseCache === true ? null : self._offlineNoCachedDataMessage();
					});
			});
		});
	},
	// Calculates pagination links according to data (rows) stored in the cache
	_queryCutAndAddLinks: function(op, result, response) {
		result = result || [];
		var self = this;
		var baseUrl = op.$parsedUrl.source.split("?")[0];
		var query = "";
		var key;
		var max = globals.OFFLINEQUERYCOUNT;
		var orderBy = "";

		if (op.$parsedUrl.query && op.$parsedUrl.query.where) {
			query += "&where=" + op.$parsedUrl.query.where;
		}

		key = op.$parsedUrl.query && op.$parsedUrl.query.key;
		var firstKeyRead;
		var lastKeyRead;

		var resources = response.$resources = [];
		var hasNextPage = false;
		var hasPreviousPage = false;
		var i;

		var pageName = op.$endpoint + "." + op.$representation;
		return globals.getMetaData().getPrototype(pageName)
			.then(function(proto) {
				var val;
				var kv;
				var orderBy = "";
				proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
				var keyField;
				if (proto.$key) {
					keyField = proto.$key.replace(/{/g, "").replace(/}/g, "");
				} else {
					keyField = "$uuid";
				}
				if (op.$parsedUrl.query && op.$parsedUrl.query.orderBy) {
					orderBy = self._buildOrderBy(op, keyField, op.$parsedUrl.query.orderBy);
					query += "&orderBy=" + orderBy;
				}

				var keyType = proto.$properties[keyField];
				var isNumericKey = keyType && keyType.$type && keyType.$type !== "application/x-string";
				var gotMatch = false;
				if (key && key.smStartsWith("gt")) {
					val = key.substr(3);
					val = isNumericKey ? +val : val;

					for (i = 0; i < result.length; i++) {
						if (!gotMatch) {
							kv = self._calculateKey(proto, result[i]);
							kv = isNumericKey ? +kv : "" + kv;
						}
						if (kv == val && !gotMatch) {
							gotMatch = true;
						} else if (gotMatch) {
							resources.push(result[i]);
							if (resources.length > max) {
								break;
							}
						} else {
							hasPreviousPage = true;
						}
					}
					if (resources.length > 0) {
						if (resources.length > max) {
							resources.pop();
							hasNextPage = true;
						}
						firstKeyRead = self._calculateKey(proto, resources[0]);
						lastKeyRead = self._calculateKey(proto, resources[resources.length - 1]);
					}
				} else if (key && key.smStartsWith("lt")) {

					if (key.length > 3) {
						val = isNumericKey ? +key.substr(3) : "" + key.substr(3);

						for (i = result.length - 1; i >= 0; i--) {
							if (!gotMatch) {
								kv = self._calculateKey(proto, result[i]);
								kv = isNumericKey ? 0 + kv : "" + kv;
							}

							if (kv == val && !gotMatch) {
								gotMatch = true;
							} else if (gotMatch) {
								resources.push(result[i]);
								if (resources.length > max) {
									break;
								}
							} else {
								hasNextPage = true;
							}
						}
						if (resources.length > max) {
							hasPreviousPage = true;
							resources.pop();
						}
					} else {
						for (i = result.length - 1; i >= 0; i--) {
							resources.push(result[i]);
							if (resources.length > max) {
								break;
							}
						}
					}
					if (resources.length > 0) {
						if (resources.length > max) {
							hasPreviousPage = true;
							resources.pop();
						}
						response.$resources = resources = resources.reverse();

						firstKeyRead = self._calculateKey(proto, resources[0]);
						lastKeyRead = self._calculateKey(proto, resources[resources.length - 1]);
					}
				} else {
					for (i = 0; i < result.length; i++) {
						resources.push(result[i]);
						if (resources.length > max) {
							break;
						}
					}
					if (resources.length > 0) {
						if (resources.length > max) {
							hasNextPage = true;
							resources.pop();
						}

						firstKeyRead = self._calculateKey(proto, resources[0]);
						lastKeyRead = self._calculateKey(proto, resources[resources.length - 1]);
					}
				}

				var links = response.$links = {};
				if (key) {
					links.$first = {
						$url: baseUrl + "?representation=" + op.$representation + query
					};
				}

				if (key && firstKeyRead && hasPreviousPage) {
					if (key !== "gt") { // not on first page?
						links.$previous = {
							$url: baseUrl + "?representation=" + op.$representation + query + "&key=lt." + firstKeyRead
						};
					}
				}

				if (key !== "lt" && lastKeyRead && hasNextPage) { // not on last page and more records
					links.$next = {
						$url: baseUrl + "?representation=" + op.$representation + query + "&key=gt." + lastKeyRead
					};
				}
				if (key !== "lt" && hasNextPage) {
					links.$last = {
						$url: baseUrl + "?representation=" + op.$representation + query + "&key=lt"
					};
				}
			});
	},
	_reqStatsGetCacheOpts: function(op, data) {
		// representation -> QUERY~QAQTGRA2~1.$query
		var key = "";
		var q = op.$parsedUrl.query;
		Object.keys(q).forEach(function(param) {
			key += param + q[param];
		});
		key = utils._checksum(key);
		var opts = {
			$representation: op.$representation,
			$endpoint: op.$endpoint,
			$key: key
		};
		if (data != null) {
			opts.$data = data;
		}
		return opts;
	},
	_queryReadCache: function(op, options) {
		var self = this;
		var cache = globals.getCache();
		log && log("Querying data from cache: " + op.$representation);
		var p = op.$endpoint + "." + op.$representation;
		// Ususally this should never be called since the sync call above
		// returns the prototype already.
		return globals.getMetaData().getPrototype(p).then(function(proto) {
			self._checkQueryPrototype(op, proto);
			if (op.$isRequest === true || op.$isStats === true) {
				return cache.read(self._reqStatsGetCacheOpts(op)).fail(function(e) {
					return $.smReject(e);
				});
			} else {
				if (globals.isAuthoringActive() && options.$authCacheId && _authQueryCache[options.$authCacheId]) {
					// returns the whole JSON data with $links and count parameter in authoring
					// When we refresh authoring forceUseCache=true and the pagination is broken (see _queryCutAndAddLinks)
					// -> count is wrong
					// The goal is to display the same rendering as in non-authoring mode
					// When we exit the authoring we don't refresh the page so the redering should be the same in both modes
					return $.smResolve(_authQueryCache[options.$authCacheId], true);
				}
				var filters = proto.$filters;
				var where = self._extendWhereWithFilter(op, filters);
				var proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
				var keyField;
				if (proto.$key) {
					keyField = proto.$key.replace(/{/g, "").replace(/}/g, "");
				} else {
					keyField = "$uuid";
				}
				var orderBy = self._parseOrderBy(op.$orderBy, keyField);
				return cache.query({
					$proto: proto,
					$endpoint: op.$endpoint,
					$where: where,
					$orderBy: orderBy
				}).fail(function(e) {
					return $.smReject(e);
				});
			}
		});
	},
	_queryDoHttp: function(op) {
		var send = {
			method: "GET",
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_queryPutCache: function(op, data, options) {
		var self = this;
		log && log("Writing data to cache: " + op.$representation);
		var cache = globals.getCache();
		var pageName = op.$endpoint + "." + op.$representation;
		if (!data) {
			data = {};
		}
		if (!data.$resources) {
			data.$resources = [];
		}
		return globals.getMetaData().getPrototype(pageName).then(function(proto) {
			if (op.$isRequest === true || op.$isStats === true) {
				// Stores the whole JSON data
				return cache.put(self._reqStatsGetCacheOpts(op, data));
			} else {
				if (options.$authCacheId) {
					// $authCacheId is the page id
					// Stores the last whole JSON data for this page
					// data will be read in _queryReadCache (see comments)
					// Te data are removed when the page is destroyed (see notifAuthcacheDestroy)
					_authQueryCache[options.$authCacheId] = data;
					// console.log("write _authQueryCache", options.$authCacheId)
				}
				// Store the lines
				proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
				return $.smForEachPromise(data.$resources, function(item) {
					var key = self._calculateKey(proto, item);
					if (!key) {
						key = item.$uuid;
					}
					return cache.put({
						$representation: op.$representation,
						$key: key,
						$endpoint: op.$endpoint,
						$data: item
					});
				});
			}
		});
	},


	// PUT: {$baseUrl}/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$edit
	// POST: {$baseUrl}/SUPERV/AQTCRUD?representation=AQTCRUD.$create
	"save": function(op, data, options) {
		var self = this;
		return self._saveDoHttp(op, data)
			.then(function(result) {
				if (result.isSuccess) {
					var data = result.responseJSON;
					return self._savePutCache(op, data)
						.then(function() {
							// #7701 result is expected by caller - Tested
							return result;
						});
				}
				// #7701 result is expected by caller - Tested
				return result;
			});
	},

	_saveDoHttp: function(op, data) {
		var send = {
			method: op.$link.$method,
			url: op.$link.$url,
			send: data
		};
		return sdataHttp.send(send);
	},

	_savePutCache: function(op, data) {
		var self = this;
		try {
			if (self._useCache(op, "write")) {
				log && log("Writing data to cache: " + op.$representation);
				var cache = globals.getCache();
				var key = op.$key;
				var step;
				if (!key) {
					var pageName = op.$endpoint + "." + op.$representation;
					step = globals.getMetaData().getPrototype(pageName).then(function(proto) {
						proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
						key = self._calculateKey(proto, data);
						return key;
					});
				} else {
					step = $.smResolve(key);
				}
				// write to cache is async, this is why there is not "return step.then(...)"
				step.then(function(key) {
					self._removeFromCache({
						$representation: op.$representation,
						$key: key,
						$endpoint: op.$endpoint
					}).then(function() {
						return cache.put({
							$representation: op.$representation,
							$key: key,
							$endpoint: op.$endpoint,
							$data: data
						});
					});
				});
			}
			log && log("Disabled writing data to cache : " + op.$representation);
			return $.smResolve();
		} catch (e) {
			return $.smReject(e);
		}
	},

	// DELETE: {$baseUrl}/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$query
	"delete": function(op, data, options) {
		var self = this;
		var deferred = $.Deferred();
		try {
			self._deleteDoHttp(op, data)
				.then(function(result) {
					if (result.isSuccess) {
						var data = result.responseJSON;
						return self._deleteRemoveCache(op, data)
							.then(function() {
								// #7701 result is expected by caller - Tested
								return result;
							});
					}
					// #7701 result is expected by caller - Tested
					return result;
				})
				.then(function(result) {
					deferred.resolve(result);
				}).fail(function(e) {
					deferred.reject(e);
				});
		} catch (e) {
			deferred.reject(e);
		}
		return deferred.promise();
	},
	_deleteDoHttp: function(op, data) {
		var send = {
			method: op.$link.$method,
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_deleteRemoveCache: function(op, data) {
		var self = this;
		if (self._useCache(op, "write")) {
			log && log("Deleting data from cache: " + op.$representation);
			var cache = globals.getCache();
			self._removeFromCache({
				$representation: op.$representation,
				$key: op.$key,
				$endpoint: op.$endpoint
			}).then(function() {
				return cache.remove({
					$representation: op.$representation,
					$key: op.$key,
					$endpoint: op.$endpoint
				});
			});
		}
		log && log("Disabled deleting data from cache : " + op.$representation);
		return $.smResolve();
	},

	"service": function(op, data, options) {
		if (this._isOnline()) {
			var send = {
				method: op.$link.$method,
				url: op.$link.$url,
				send: data
			};
			return sdataHttp.send(send);
		} else {
			return $.smResolve({
				"$diagnoses": [{
					"$severity": "error",
					"$message": locale.text("error.service.offline")
				}]
			});
		}
	},
	_calculateKey: function(proto, item) {
		var key;
		if (proto.$key) {
			key = proto.$key.replace(/\{(.*?)\}/g, function(match, prop) {
				return item[prop];
			});
		} else {
			key = item.$uuid;
		}
		return key;
	},
	_getKeyFields: function(proto) {
		var key = proto.$key ||
			proto.$properties &&
			proto.$properties.$resources &&
			proto.$properties.$resources.$item &&
			proto.$properties.$resources.$item.$key;
		if (key) {
			var list = [];
			key.replace(/\{(.*?)\}/g, function(match, prop) {
				list.push(prop);
			});
			if (list.length < 1) {
				return ["$uuid"];
			}
			return list;
		} else {
			return ["$uuid"];
		}
	},
	_checkQueryPrototype: function(op, proto) {
		// https://github.com/Sage-ERP-X3/Syracuse/issues/6003
		// Type of $item in queries is application/json but the cache needs a concrete type to be able to store the data
		// For requester requests, type is empty and will also be generated here
		if (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) {
			proto.$properties.$resources.$item.$type = "{$baseType}." + op.$representation;
		}
	},
	_removeFromCache: function(op) {
		var self = this;

		var cache = globals.getCache();

		var facets = ["$edit", "$create", "$details", "$query", "$lookup"];
		var rep = op.$representation.split(".")[0];

		return $.smForEachPromise(facets, function(facet) {
			if (op.$representation.indexOf("." + facet) > 0) {
				return $.smResolve();
			}
			return cache.remove({
				$representation: rep + "." + facet,
				$key: op.$key,
				$endpoint: op.$endpoint
			});
		});
	},

	_parseOrderBy: function(orderBy, keyField) {
		if (!orderBy) {
			return [{
				property: keyField,
				sort: "ASC"
			}];
		}
		var o = [];
		orderBy.split(",").map(function(field) {
			field = field.trim();
			var d = field.split(" ");
			var f = d[0].trim();
			if (f.length > 0) {
				var dir = "ASC";
				if (d.length > 1) {
					dir = d[1].toUpperCase();
					dir = dir !== "DESC" ? "ASC" : "DESC";
				}
				o.push({
					property: f,
					sort: dir
				});
			}
		});
		return o;
	},

	_buildOrderBy: function(op, keyField, orderBy) {
		if (!orderBy) {
			return keyField;
		}

		if (!(orderBy === keyField || orderBy.indexOf(keyField + " ") > -1 || orderBy.indexOf(keyField + ",") > -1)) {
			// Key field not yet in order by
			if (orderBy.indexOf(" DESC") > -1) {
				orderBy += ", " + keyField + " DESC";
			} else {
				orderBy += ", " + keyField + " ASC";
			}
		}
		return orderBy;
	},

	_extendWhereWithFilter: function(op, filters) {
		var self = this;

		var where = op.$where;
		if (!filters) {
			return where;
		}
		var filterName = op.$parsedUrl && op.$parsedUrl.query && op.$parsedUrl.query.filter;
		if (!filterName) {
			return where;
		}
		var filter = filters && filters[filterName];
		if (!filter) {
			return where;
		}

		var fw = self._checkFilterWhere(filterName, filter.$where);
		if (!fw) {
			return where;
		}

		if (where) {
			where = "(" + where + ") and (" + fw + ")";
		} else {
			where = "(" + fw + ")";
		}

		return where;
	},

	/*
	 * Check if X3 filter contains invalid references of screen elements which are not valid on client side
	 * In case it's true, the filter will be ignored and an error message will be displayer
	 */
	_checkFilterWhere: function(filterName, where) {
		var invalid = where.match(/(\[F\:\w+\]?)/g);
		if (invalid) {
			globals.getModal().error(
				locale.text("sdata.error.filter.screenFieldTitle"),
				locale.text("sdata.error.filter.screenFieldDetails", [filterName, invalid.join(","), where])
			);
			// Do not use filter, it will cause errors
			return null;
		}
		return where;
	}
});
});

define('syracuse-tablet/html/js/sdata/sdataDispatcher',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/sdata/sdataUtils','syracuse-tablet/html/js/sdata/sdataDispatcherLocal','syracuse-tablet/html/js/sdata/sdataDispatcherHttp','syracuse-tablet/html/js/helpers/native/native'],function (require, exports, module) {"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("sdataDispatcher");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');

var dispLocal = require('syracuse-tablet/html/js/sdata/sdataDispatcherLocal').Dispatcher;
var dispHttp = require('syracuse-tablet/html/js/sdata/sdataDispatcherHttp').Dispatcher;

var nativeDispatcherListener = require('syracuse-tablet/html/js/helpers/native/native').getModule("dispatcherListener");

var _dispatchers = [
	new dispLocal(),
	new dispHttp()
];

/**
 * link
 * {
 * 	 $url: ...,
 * 	 $method: "GET", ...
 * }
 * data
 * {
 *   ...
 * }
 */
exports.dispatch = function(link, data, options) {
	var deferred = $.Deferred();
	var notifyNativeAfter;
	// notifiy native shell that a request has been executed to allow triggereing of related native actions 
	if (nativeDispatcherListener) {
		notifyNativeAfter = function() {
			nativeDispatcherListener.dispatcherNotifyAfter({
				Method: link.$method,
				Url: link.$url
			});
		};
	}

	try {
		log && log("Dispatch: " + link.$method + ": " + link.$url);

		options = options || {};
		var op = exports.parseLink(link);
		var dispatcher;
		$.smForEachPromise(_dispatchers, function(disp) {
			return disp.accept(op, data);
		}, function(disp, result) {
			if (result === true) {
				dispatcher = disp;
				return true;
			}
			return false;
		});
		var cacheStatus;
		if (options.forceUseCache) {
			cacheStatus = globals.getCache().isDisabled();
			globals.getCache().disableCache(false);
		}
		var prom = dispatcher[op.$operation](op, data, options);
		if (!prom) {
			notifyNativeAfter && notifyNativeAfter();
			throw new Error("Could not dispatch: " + link.$method + ": " + link.$url + " (" + op.$operation + ")");
		}
		prom.then(function(result) {
			if (options.forceUseCache) {
				globals.getCache().disableCache(cacheStatus);
			}
			notifyNativeAfter && notifyNativeAfter();
			deferred.resolve(result);
		}).fail(function(e) {
			if (options.forceUseCache) {
				globals.getCache().disableCache(cacheStatus);
			}
			notifyNativeAfter && notifyNativeAfter();
			deferred.reject(e);
		});
	} catch (e) {
		deferred.reject(e);
	}
	return deferred.promise();
};

/**
 * Parse link to identify which kind of operation it's intended to start
 *
 * link:
 * {
 * 	 $url: ...,
 * 	 $method: "GET", ...
 * }
 *
 * Return:
 * {
 *    "$link":{
 *       "$method":"DELETE",
 *       "$url":"http://localhost:8124/sdata/x3/erp/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$query"
 *    },
 *    "$parsedUrl":{
 * ...
 *       "directory":"/sdata/x3/erp/SUPERV/AQTCRUD('10')",
 *       "path":"/sdata/x3/erp/SUPERV/AQTCRUD('10')",
 *       "relative":"/sdata/x3/erp/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$query",
 * ...
 *       "query":{
 *          "representation":"AQTCRUD.$query"
 *       },
 * ...
 *       "representation":"AQTCRUD",
 *    },
 *    "$operation":"delete",
 *    "$key":"10",
 *    "$representation":"AQTCRUD.$query"
 * }
 *
 */
var _repExp = /\$prototypes\('(.*?)'\)/;
var _keyExp = /\('(.*?)'\)/;

exports.parseLink = function(link) {
	var url = link.$url;
	var result = {
		$link: link,
		$parsedUrl: sdataUtils.parseSDataURL(link.$url)
	};
	result.$endpoint = result.$parsedUrl.application + "." + result.$parsedUrl.contract + "." + result.$parsedUrl.dataset;
	var dir = result.$parsedUrl.directory; // All except query parameters
	var idx;
	if (link.$method === "GET") {
		if (url.indexOf("$prototypes") > -1) {
			result.$operation = "prototype";
			result.$representation = _repExp.exec(url)[1];
		} else if (dir.indexOf("$template") > -1) {
			result.$operation = "new";
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
		} else if (result.$parsedUrl.$services) {
			result.$operation = "service";
			result.$service = result.$parsedUrl.$services;
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
		} else {
			var key = _keyExp.exec(dir);
			result.$isStats = dir.indexOf("/STATS(") > -1;
			result.$isRequest = dir.indexOf("/QUERY(") > -1;
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
			if (key && !(result.$isStats || result.$isRequest)) {
				result.$operation = "read";
				result.$key = key[1];
			} else {
				result.$operation = "query";
			}
		}
		if (result.$parsedUrl.query && result.$parsedUrl.query.where) {
			result.$where = result.$parsedUrl.query.where;
		}
		if (result.$parsedUrl.query && result.$parsedUrl.query.orderBy) {
			result.$orderBy = result.$parsedUrl.query.orderBy;
		}
	} else if (result.$parsedUrl.$services) {
		result.$operation = "service";
		result.$service = result.$parsedUrl.$services;
		result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
	} else if (link.$method === "DELETE") {
		var key = _keyExp.exec(dir);
		result.$operation = "delete";
		result.$key = key[1];
		result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
	} else {
		// PUT/POST and no service
		var key = _keyExp.exec(dir);
		if (key) {
			result.$operation = "save";
			result.$key = key[1];
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
		} else {
			result.$operation = "save";
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
		}
	}

	return result;
};
});

define('syracuse-tablet/html/js/helpers/deltaManager',['require','exports','module'],function (require, exports, module) {"use strict";


function _isVariantArray(list) {
	var first = list && list.length > 0 ? list[0] : null;
	if (first) {
		if (first.$uuid == undefined) {
			if (typeof(first) == 'object' && Object.keys(first).length == 1) {
				return true;
			}
		}
	}
	return false;
}

function _ensureServerIndex(list) {
	if (_isVariantArray(list)) {
		for (var ii = 0, jj = list.length; ii < jj; ii++) {
			var record = list[ii];
			if (typeof(record) == 'object') {
				record[Object.keys(record)[0]].$serverIndex = ii;
			}
		}
	} else {
		if (list.length && typeof(list[0]) == 'object' && list[0].$uuid !== undefined) {
			for (var ii = 0, jj = list.length; ii < jj; ii++) {
				list[ii].$serverIndex = ii;
			}
		}
	}
}

function _applyPageRecordDelta(options, record, subRecord, targetMap, targetList, variantKey) {
	if (subRecord.$uuid !== undefined) {
		if (!subRecord.$isDeleted) {
			if ((subRecord.$uuid !== undefined) && targetMap[subRecord.$uuid]) {
				if (variantKey) {
					var newNecord = _applyObjectDelta(options, targetMap[subRecord.$uuid], subRecord);
					record = {};
					record[variantKey] = newNecord;
					targetList.push(record);
				} else {
					targetList.push(_applyObjectDelta(options, targetMap[subRecord.$uuid], subRecord));
				}
			} else {
				targetList.push(record);
			}
		}
	} else {
		targetList.push(record);
	}
}

function _applyObjectArrayDelta(options, targetList, sourceList) {
	if (sourceList) {
		if (targetList.length == sourceList.length) {
			for (var ii = 0, jj = sourceList.length; ii < jj; ii++) {
				_applyObjectDelta(options, targetList[ii], sourceList[ii]);
			}
		} else {
			targetList.splice(0, targetList.length);
			for (var ii = 0, jj = sourceList.length; ii < jj; ii++) {
				targetList.push(sourceList[ii]);
			}
		}
	}
	return targetList;
}

function _applyObjectDelta(options, target, source, isObjectDelta) {
	options = options || {};
	if (source) {
		var properties = Object.keys(source);
		var isData;
		for (var ii = 0, jj = properties.length; ii < jj; ii++) {
			var property = properties[ii];
			isData = property.charAt(0) != "$";
			var targetValue = target[property];
			var sourceValue = source[property];
			if (typeof(sourceValue) == 'object') {
				if (!(targetValue == null || sourceValue === null)) {
					if (Array.isArray(sourceValue)) {
						// isData: applyPageArrayDelta only for data not for meta-data
						if (isObjectDelta || !isData) {
							sourceValue = _applyObjectArrayDelta(options, targetValue, sourceValue);
						} else {
							if (options.$isEditMode || options.$isPartialDelta) {
								// applyPageArrayDelta update the targetValue by comparison of $uuids
								sourceValue = exports.applyPageArrayDelta(options, targetValue, sourceValue);
							}
						}
					} else {
						sourceValue = _applyObjectDelta(options, targetValue, sourceValue, isObjectDelta);
					}
				}
				if (Array.isArray(sourceValue) && isData) {
					_ensureServerIndex(sourceValue);
				}
			}
			target[property] = sourceValue;
		}
	}
	return target;
}


exports.cleanServerIndex = function(source) {
	if (source && (typeof(source) == 'object')) {
		if (Array.isArray(source)) {
			for (var ii = 0, jj = source.length; ii < jj; ii++) {
				exports.cleanServerIndex(source[ii]);
			}
		} else {
			delete source.$serverIndex;
			var properties = Object.keys(source);
			for (var ii = 0, jj = properties.length; ii < jj; ii++) {
				exports.cleanServerIndex(source[properties[ii]]);
			}
		}
	}
	return source;
};

exports.applyObjectDelta = _applyObjectDelta;

exports.applyPageArrayDelta = function(options, targetList, sourceList) {
	options = options || {};
	if (sourceList) {
		var targetMap = {};
		var isVariant = _isVariantArray(sourceList);
		if (options.$isPartialDelta || (sourceList.length == 1 && sourceList[0].$index !== undefined)) {
			var found, foundIndex;
			for (var ii = 0, jj = sourceList.length; ii < jj; ii++) {
				found = null;
				var sourceRecord = sourceList[ii];
				foundIndex = 0;
				for (var mm = targetList.length; foundIndex < mm; foundIndex++) {
					found = targetList[foundIndex];
					if (found.$uuid == sourceRecord.$uuid) {
						break;
					} else {
						found = null;
					}
				}
				if (found) {
					if (sourceRecord.$isDeleted) {
						targetList.splice(foundIndex, 1);
					} else {
						_applyObjectDelta(options, found, sourceRecord);
						if (sourceRecord.$index !== undefined && sourceRecord.$index != foundIndex) {
							targetList.splice(foundIndex, 1);
							targetList.splice(sourceRecord.$index, 0, found);
							delete found.$index;
						}
					}
				} else {
					if (!sourceRecord.$isDeleted) {
						if (sourceRecord.$index !== undefined) {
							targetList.splice(sourceRecord.$index, 0, sourceRecord);
						} else {
							targetList.push(sourceRecord);
						}
					}
				}
			}
		} else {
			for (var ii = 0, jj = targetList.length; ii < jj; ii++) {
				var record = targetList[ii];
				if (record) {
					if (record.$uuid !== undefined) {
						targetMap[record.$uuid] = record;
					} else {
						if (isVariant) {
							record = record[Object.keys(record)[0]];
							if (record.$uuid !== undefined) {
								targetMap[record.$uuid] = record;
							}
						}
					}

				}
			}
			targetList = [];
			for (var ii = 0, jj = sourceList.length; ii < jj; ii++) {
				var record = sourceList[ii];
				if (isVariant) {
					var variantKey = Object.keys(record)[0];
					_applyPageRecordDelta(options, record, record[variantKey], targetMap, targetList, variantKey);
				} else {
					_applyPageRecordDelta(options, record, record, targetMap, targetList);
				}

			}
		}
	}
	return targetList;
};
});

define('syracuse-tablet/html/js/application/daoSdata',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/articleParser','syracuse-tablet/html/js/helpers/deltaManager','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');
var deltaManager = require('syracuse-tablet/html/js/helpers/deltaManager');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("daoSData", false);

var _linksNameTampering = function($link) {
	var $linkRenamed = {}, name = "";
	if (!$link) return $linkRenamed;
	Object.keys($link).forEach(function(key) {
		switch (key) {
			case "levelDown":
				name = "$drillUp";
				break;
			case "levelUp":
				name = "$drillDown";
				break;
			default:
				name = key;
		}
		$linkRenamed[name] = $link[key];
	});
	return $linkRenamed;
};

/**
 * Process data by walking through a data object and applying operations
 */
var _DataProcessor = function() {
	/**
	 * operation.regExp		Expression that gives the properties to remove
	 * operation.exclude	Array that contains the names of the properties to exclude
	 * Return true if walk can continue inside o[name]
	 */
	this.removeprop = function(operation, o, name, result) {
		if (!operation) {
			// Process is stopped - unexpected null removeProp
			return false;
		}
		if (operation.exclude != null && operation.exclude.indexOf(name) >= 0) {
			// Property excluded -> Recursion is stopped
			return false;
		}
		if (!operation.regExp) {
			// Process is stopped - unexpected null regExp
			return false;
		}
		if (!operation.regExp.test(name)) {
			// Prop not removed - We walk inside
			return true;
		}
		// Perhaps  o[name]= undefined; is better
		delete o[name];
		if (result) {
			// Add to result if test mode
			if (result.removeprop == null) {
				result.removeprop = {
					_nbRemoved: 0
				};
			}
			if (result.removeprop[name] == null) {
				result.removeprop[name] = 0;
			}
			result.removeprop[name]++;
			result.removeprop._nbRemoved++;
		}
		// Property deleted - no walk
		return false;
	};
	/**
	 * Keeps only functional fields
	 */
	this.dataToTemplate = function(operation, o, name, result) {
		if (!operation) {
			// Process is stopped - unexpected null removeProp
			return false;
		}
		if (name === "$uuid") {
			o["hasUUID"] = true;
			return false;
		}
		if (name.toLowerCase() === "etag" || name.smStartsWith("$")) {
			delete o[name];
			return false;
		}
		return true;
	};
	this._walkArray = function(o, operation, result) {
		if (!o) return;
		var self = this;
		o.forEach(function(e) {
			if (typeof(e) === 'object') {
				self._walk(e, operation, result);
			} else {
				// nothing
			}
		});
	};
	this._walkPlainObject = function(o, operation, result) {
		if (!o) return;
		var p = Object.keys(o),
			e, name, walkInside;
		for (var ii = 0, jj = p.length; ii < jj; ii++) {
			name = p[ii];
			e = o[name];
			walkInside = true;
			for (var opName in operation) {
				if (this[opName]) {
					walkInside = this[opName](operation[opName], o, name, result);
				}
			}
			if (walkInside && typeof(e) === 'object') {
				this._walk(e, operation, result);
			} else {
				// Nothing
			}
		}
	};

	this._walk = function(o, operation, result) {
		if (!o || !operation) return;
		if (typeof o == 'object') {
			if (Array.isArray(o)) {
				this._walkArray(o, operation, result);
			} else if ($.isPlainObject(o)) {
				this._walkPlainObject(o, operation, result);
			}
		} else {
			// Nothing
		}
	};
	/**
	 * Process the given operation on data
	 */
	this.process = function(operation, data) {
		var result;
		if (log != null) {
			result = {
				startTime: new Date().getTime()
			};
		}
		this._walk(data, operation, result);
		// For test- 
		if (log != null && result) {
			log("getActionPayload - operations - Elsaped=", new Date().getTime() - result.startTime, "ms");
			log("Result: ", JSON.stringify(result, null, 2));
		}
		return result;
	};
};
var _getResourcesTime = function($resources) {
	var utcTime = new Date().getTime();
	if (!$resources) return utcTime;
	$resources.forEach(function(item) {
		if (item.$cache) {
			utcTime = Math.min(utils.getTimeFromString(item.$cache.$lastUpdated), utcTime);
		}
	});
	return utcTime;
};

var _defMetaData = {
	$properties: {
		"$isExcluded": false,
		"$isHidden": false,
		"$isMandatory": false,
		"$isReadOnly": false,
		"$isDisabled": false,
		"$diagnoses": null,
		"$x3Format": null,
		"$value": null,
		"$format": null,
		"$capabilities": null
	},
	$links: {
		"$isDisabled": false,
		"$isHidden": false,
		"$style": false,
		"$isRequested": false
	}
};
/**
 * Recursive update of meta-data
 */
var _updt = function(src, dst) {
	var m = {}, j;
	for (var p in _defMetaData) {
		j = src[p];
		if (j && !$.isEmptyObject(j)) m[p] = j;
	}
	if (!$.isEmptyObject(m)) {
		$.extend(dst, m);
		return m;
	}
	return null;
};
var _updateMeta = function(fromData, toData, properties, isRowData) {
	if (!fromData || !toData) return false;
	var meta = _updt(fromData, toData);
	if (isRowData == true && meta && meta.$properties) {
		// We need to update the parent that there's a child on error 
		// If there's an error in a nested array we need to display the row in error at the first level
		for (var p in meta.$properties) {
			if (meta.$properties[p].$diagnoses != null) {
				toData.$arrayUpdateError = true;
				break;
			}
		}
	}
	var done = meta != null;
	if (properties) {
		for (var name in properties) {
			var proto = properties[name];
			if (proto && proto.$type === "application/x-array" && fromData[name]) {
				if (!articleParser.isSingleArray(proto)) {
					var arrSrc = fromData[name];
					var arrDst = toData[name];
					if (!arrDst) throw new Error("Unexpected empty data array - " + name);
					for (var idx = 0; idx < arrSrc.length && idx < arrDst.length; idx++) {
						// _updateMeta first
						var rowData = arrDst[idx];
						meta = _updateMeta(arrSrc[idx], rowData, proto.$item.$properties, true);
						if (rowData.$arrayUpdateError && isRowData) {
							toData.$arrayUpdateError = true;
						}
						done = meta != null || done;
					}
				} else if (proto.$item.$type === "application/x-reference") {
					// meta of x-reference single arrays are sent in data			
					var arrSrc = fromData[name];
					var arrDst = toData[name];
					var dst, src;
					for (var idx = 0; idx < arrSrc.length && idx < arrDst.length; idx++) {
						dst = arrDst[idx];
						src = arrSrc[idx];
						for (var p in _defMetaData.$properties) {
							if (src && src[p] != null) {
								dst[p] = src[p];
							} else if (proto.$item[p] != null) {
								dst[p] = proto.$item[p];
							} else {
								dst[p] = _defMetaData.$properties[p];
							}
						}
					}
				}
			}
		}
	}
	return done;
};
/**
 * Class that manages access to sdata data structure
 *  	data: 		JOSN data
 *  	prototype: 	Prototype
 *  	options.parent:		Parent DAO (see getPrototype)
 *  	options.$bind		For a child it's the name of the field from which dao has bee created
 * Manages DAO chaining parent -> child
 * !!use DAO methods instead of dealing directly with JSON
 */
var _Dao = utils.defineClass(function DaoSdata(data, prototype, options) {
	options = options || {};
	if (!prototype) throw new Error("Prototype is mandatory");
	this.prototype = prototype;
	this.data = data || {};
	this.$bind = options.$bind || "";
	this.parent = options.parent;
	if (!this.parent) {
		this._creationDate = new Date();
	}
	this.resetCache();
	this.enableWorkingCopy = false;
	this._initDirty();
	this.isRowDetailDao = options.isRowDetailDao === true;
}, null, {
	/**
	 * destroyProto: true in some cases (rowDetail dao - see notifRowdetailUpdate)
	 */
	destroy: function(destroyProto) {
		this.parent = null;
		this.data = null;
		if (destroyProto === true && this.prototype) {
			this.prototype.destroy();
		}
		this.prototype = null;
		this._dataProcessor = null;
	},
	resetCache: function() {
		this._cache = {
			metaData: {},
			queryData: null
		};
	},
	/**
	 * Set field's value
	 * For x-reference fields value can be a string or an object {$value,$description, $title}
	 */
	setValue: function(name, value, notify) {
		var done = false;
		var curVal = this.data[name];
		if (this.prototype.isReference(name)) {
			var valName = this.prototype.getFieldNameForValue(name);
			if (valName !== name) {
				// X3 entities 
				var strVal;
				if (typeof value === "object") {
					strVal = value.$value || "";
				} else {
					strVal = value + "";
				}
				if (strVal != this.data[valName]) {
					// Reset value
					this.data[name] = curVal = {};
					// Set field value
					this.data[valName] = strVal;
					// Set value
					if (strVal === value) {
						// value is a string - TODO remove all other properties??
						curVal.$value = strVal;
					} else {
						// set _REF value/descr/ttl to allow refresh of all fields data
						for (var p in value) {
							curVal[p] = value[p];
						}
					}
					// for ref fields in single arrays we've to set this value {$value:"ASN", FCY:"ASN"}
					curVal[valName] = strVal;
					done = true;
				}
			} else if (curVal == null || curVal.$value != value) {
				throw new Error("Syracuse entities - x-refrence setValue not implemented");
			}
		} else if (curVal == null || curVal !== value) {
			this.data[name] = value;
			done = true;
		}
		if (done) {
			this.setDirty();
		}
		return done;
	},
	_initDirty: function() {
		if (this.prototype.isSingleArray(true)) {
			// For a single array there's only one field
			// - > We force dirty in any case to enable save without having to click outside the field to enable save
			this.isDirty = true;
			notifications.publish("sm.dao.dirty", true, this.data.$uuid);
			return;
		}
		// No notification - save is disabled by default
		this.resetDirty(true);
	},
	resetDirty: function(forceNotify) {
		this._toggleDirty(false, forceNotify);
	},
	/**
	 * !! Do not call this.isDirty = true - use this methode because overridden for working copies
	 */
	setDirty: function(forceNotify) {
		this._toggleDirty(true, forceNotify);
	},
	/**
	 * !! Do not call this.isDirty = true - use this methode because overridden for working copies
	 */
	_toggleDirty: function(yes, forceNotify) {
		if (this.prototype.isSingleArray(true)) {
			// Only one field - Save sstays enabled - see _initDirty
			this.isDirty = true;
			return;
		}
		yes = yes === true;
		this.publishDirty(yes, forceNotify);
		// after publishDirty
		this.isDirty = yes;
	},
	/**
	 * Called by draftManager
	 */
	publishDirty: function(dirty, forceNotify) {
		// Only page dao
		if (!this.isRowDetailDao && (this.$bind == null || this.$bind.length > 0)) return;
		// Notifies only if status has changed
		if (forceNotify !== true && this.isDirty === dirty) return;
		notifications.publish("sm.dao.dirty", dirty === true, this.data.$uuid);
	},
	/**
	 * Get field's value
	 * searchInParents should be equals to true - remove it if not used
	 * For xref fields returns an object with {$value, $title:...}
	 */
	getValue: function(name, defValue, searchInParents) {
		if (!name || name.length === 0) return defValue;
		var val = this.data[name];
		if (val == null) {
			if (searchInParents && this.parent) {
				return this.parent.getValue(name, defValue, searchInParents);
			}
			return defValue;
		}
		if (this.prototype.isReference(name)) {
			// Add $value in value with the value of the linked field 
			var nameValue = this.prototype.getFieldNameForValue(name);
			if (nameValue != name) {
				// X3
				if (typeof val !== "object") {
					// unexpected - we should have SITE_REF = {$value, $title:...}
					val = {};
				}
				val.$value = this.getValue(nameValue, defValue);
			} else {
				// Collaboration - Just to be compliant with X3 ref fields - TODO test Collaboration entities
				val = {
					$value: val
				};
			}
		}
		return val;
	},
	getPathValue: function(path) {
		return jsutils.getPropByPath(this.data, path);
	},
	/**
	 * Return the 'type' meta-data
	 * 	type		$properties for fields
	 * 				$links for actions
	 *  propName 	Name of the field for type = $properties
	 */
	getMetaData: function(type, propName) {
		if (!type) throw new Error("getMetaData - type expected");
		if (propName == null) return;
		/* NOTE: #6097 For Reference fields, meta data like $isHidden is set on e.g. CRY_REF NOT on CRY so there must be NO mapping from CRY_REF->CRY
		 */
		var protoPropName = propName;
		if (type === "$properties" && this.prototype.isReference(propName)) {
			propName = this.prototype.getFieldNameForValue(propName);
		}

		var meta = this._cache.metaData[type];
		if (meta) {
			if (propName == null) return meta;
			if (propName != null && meta[propName] != null) return meta[propName];
			meta = meta[propName] = {};
		} else {
			meta = this._cache.metaData[type] = {};
			if (propName != null) meta = meta[propName] = {};
		}
		var proto = this.prototype.data(type);
		if (proto && propName != null) proto = proto[protoPropName];
		var data = this.data[type];
		if (data && propName != null) data = data[propName];
		var props = _defMetaData[type];
		if (!props) throw new Error("getMetaData - unexpected type[" + type + "]");
		for (var p in props) {
			if (data && data[p] != null) {
				meta[p] = data[p];
				continue;
			} else if (proto && proto[p] != null) {
				meta[p] = proto[p];
			} else {
				meta[p] = props[p];
			}
		}
		return meta;
	},
	/**
	 * Fields $diagnoses are removed after having being displayed
	 */
	removeMetaDiagnoses: function(fieldName) {
		if (this.prototype.isReference(fieldName)) {
			fieldName = this.prototype.getFieldNameForValue(fieldName);
		}
		[this.data, this._cache.metaData].forEach(function(data) {
			var meta = data.$properties;
			if (meta && meta[fieldName]) meta[fieldName]["$diagnoses"] = undefined;
		});
	},
	getFieldInfo: function(name) {
		return {
			meta: this.getMetaData(),
			value: this.getValue()
		};
	},
	/**
	 * current proto is controller's proto
	 * name: array field name
	 * protoArray: prototype of array field
	 * Returns Array field data
	 * 	$resources an array of dao per row
	 *  No server pagination for array field in Syracuse
	 */
	getArrayData: function($bind, protoArray, localPaginator) {
		if (!protoArray) throw new Error("getArrayData - Prototype Array is mandatory");
		var arrayData;
		if (protoArray.isSingleArray()) {
			// $resources contains an array of single type $resource:[2,6,8,9], $resources:[{$description:,$title:,FCY:},{$description:,$title:,FCY:}]
			// We create the same field structure as multiple columns arrays with a hard coded field name SINGLEARRAYPROP {$data:1} {$data:{$description:,$title:,FCY:}}
			arrayData = [];
			var rsrcs = this.getValue($bind) || [];
			var meta = this.data.$properties && this.data.$properties[$bind];
			meta = meta ? meta.$items : null;
			var proto = protoArray.getPrototype("$item");
			var self = this;
			rsrcs.forEach(function(rsrc, idx) {
				var data = {};
				data[globals.SINGLEARRAYPROP] = rsrc;
				data.$uuid = utils.UUID();
				var diag = null;
				var errEntry;
				if (proto.property(globals.SINGLEARRAYPROP).$type === "application/x-reference") {
					// Add the field's value in data object {CUR_REF:{}, CUR:"USD"} -> {"~data~":{...}, CUR:"USD"}
					var valFld = proto.getFieldNameForValue(globals.SINGLEARRAYPROP);
					if (valFld) {
						data[valFld] = rsrc[valFld];
					}
					if (rsrc.$diagnoses) {
						diag = rsrc.$diagnoses;
						// Error is given by valFld $properties 
						errEntry = valFld;
					}
				} else {
					if (meta && meta[idx]) {
						diag = meta[idx].$diagnoses;
					}
					errEntry = globals.SINGLEARRAYPROP;
				}
				if (diag && diag.length > 0) {
					// add diagnoses returned by backoffice
					data.$arrayUpdateError = true;
					data.$properties = {};
					data.$properties[errEntry] = {
						$diagnoses: diag
					};
				}
				arrayData.push(new _Dao(data, proto, {
					parent: self,
					$bind: $bind
				}));
			});
		} else {
			arrayData = this._createArrayData($bind, protoArray, localPaginator);
		}
		return {
			$resources: arrayData || []
		};
	},
	/**
	 * localPaginator is defined in ctrlArray - It manages local pagination if any
	 */
	_createArrayData: function($bind, protoArray, localPaginator) {
		var res = [];
		var rsrcs = this.getValue($bind);
		if (rsrcs && rsrcs.length > 0) {
			var startIdx = localPaginator ? Math.max(0, localPaginator.currentIdx) : 0;
			var length = localPaginator ? Math.min(rsrcs.length, startIdx + localPaginator.count) : rsrcs.length;
			var protoRow = protoArray.getPrototype("$item");
			for (var i = startIdx; i < length; i++) {
				res.push(new _Dao(rsrcs[i], protoRow, {
					parent: this,
					$bind: $bind
				}));
			}
		}
		return res;
	},
	/**
	 * Returns query info
	 * 	Pagination info : 	$itemsPerPage $links
	 * 	Data : 				$resources an array of dao per row
	 */
	getQueryData: function(protoArray, localPaginator) {
		if (!protoArray) throw new Error("getQueryData - Prototype Array is mandatory");
		var protoLinks = _linksNameTampering(protoArray.getDataByPath("$item.$links"));
		protoLinks = $.extend(true, {}, protoLinks, this.getValue("$links"));
		var dataLinks = _linksNameTampering(this.getPathValue("$properties.$resources.$item.$links"));

		var res = {
			$itemsPerPage: this.getValue("$itemsPerPage"),
			$links: $.extend(true, {}, protoLinks, dataLinks) //,this.getValue("$links")
		};
		res.$resources = this._createArrayData("$resources", protoArray, localPaginator);
		return res;
	},
	/**
	 * Lookup info
	 */
	getLookupData: function(protoArray, localPaginator) {
		return this.getQueryData(protoArray, localPaginator);
	},
	/**
	 * Cube
	 */
	getCubeData: function($bind, protoArray, localPaginator) {
		var protoLinks = _linksNameTampering(protoArray.getDataByPath("$item.$links"));
		var dataLinks = _linksNameTampering(this.getPathValue("$properties.$resources.$item.$links"));
		var res = {
			// Data override proto - drillDown.$isHidden returned by server stops the drill down
			$links: $.extend(true, {}, protoLinks, dataLinks),
			$properties: this.getPathValue("$properties.$resources.$item.$properties")
		};
		res.$resources = this._createArrayData($bind, protoArray, localPaginator);
		return res;
	},
	getQueryResources: function() {
		return this.getValue("$resources") || [];
	},
	/* Resolve expression according to current dataset and prototype*/
	parseExpression: function(expression) {
		return utils.parseExpression(expression, this, this.prototype);
	},
	/**
	 * Set row index for arrays
	 */
	setRowIndex: function(value) {
		this.setValue(globals.ROWIDXPROP, value, false);
	},
	/**
	 * return action's payload
	 * $method: "POST"
	 * $url: "{$baseUrl}/AQMDEVICE?representation=AQMCRUDM.$create"
	 * $uuid: "6cdcb613-323f-495d-8a29-f54efad77f53"
	 * name: "$save"
	 * page: "x3.erp.SUPERV.AQMCRUDM.$create"
	 * sdataurl: "/sdata/x3/erp/SUPERV/AQMDEVICE?representation=AQMCRUDM.$create"
	 */
	getActionPayload: function(link, isEditMode) {
		// !! We remove unused properties from dataset before sending a request
		var operations = {
			removeprop: {
				regExp: /^\$/,
				// Exclude $links for drafts - We need the $links when we reload the drafts to enable actions
				exclude: ["$links", "$parameters", "$uuid", "$index", "$serverIndex", "$etag", "$trackingId"]
			}
		};
		var result = this._processData(operations);
		if (!link) return;
		var payload;
		if ((link.$method === "PUT" || link.$method === "POST") && isEditMode === true) {
			payload = $.extend(true, {}, this.data);
		} else {
			payload = {};
		}
		payload.$parameters = payload.$parameters || {};
		var self = this;
		$.each(link.$parameters || [], function(name, value) {
			payload.$parameters[name] = self.parseExpression(value);
		});
		return payload;
	},
	clone: function() {
		return new _Dao($.extend(true, {}, this.data), this.prototype, {
			parent: this.parent,
			$bind: this.$bind,
			isRowDetailDao: this.isRowDetailDao === true
		});
	},
	workingCopyGetId: function(onlyIfDirty) {
		return null;
	},
	/**
	 * Merge dao with json (json is by example the result of an action)
	 * We take into account the meta $properties and $links
	 * -> It's work only with meta - Should be replaced by applyChange
	 * retuns true if meta to refresh
	 */
	updateMeta: function(src) {
		if (!src) return false;
		this.resetCache();
		var done = _updateMeta(src, this.data, this.prototype.data("$properties"));
		if (done) {
			this.setDirty();
		}
		return done;
	},
	/**
	 * Update the parent dao - used by child pages
	 * Retrun true if change has been detected
	 * create				add new row
	 * singleArrayRowIdx	index of row for singleArrayRowIdx because no $uuid
	 */
	updateParentRow: function(create, singleArrayRowIdx) {
		if (!this.parent || !this.data || $.isEmptyObject(this.data)) return false;
		var id = this.data.$uuid;
		var grid = this.parent.data[this.$bind];
		if (!grid) {
			if (!create) return false;
			grid = this.parent.data[this.$bind] = [];
		}
		var single = this.prototype.isSingleArray();
		if (create) {
			var newdata = single ? this.data[globals.SINGLEARRAYPROP] : this.data;
			grid.push($.isPlainObject(newdata) ? $.extend({}, newdata) : newdata);
		} else {
			var idx = -1;
			var newdata = this.data;
			if (single) {
				// in single arrays there's no uuid
				if (grid.length > singleArrayRowIdx) idx = singleArrayRowIdx;
				if (idx < 0) return false;
				// In signle arrays we manage data in SINGLEARRAYPROP field for compliance with other arrays
				newdata = this.data[globals.SINGLEARRAYPROP];
			} else {
				grid.some(function(r, i) {
					if (r.$uuid == id) {
						idx = i;
						return true;
					}
				});
				if (idx < 0) return false;
			}
			if (utils.areEqual(newdata, grid[idx])) return false;
			grid[idx] = $.isPlainObject(newdata) ? $.extend({}, newdata) : newdata;
		}
		this.parent.setDirty();
		return true;
	},
	/**
	 * Delete a row
	 * 	isSingleArray		> rowidoridx is the index beacuse there's no uuid in data
	 * 	not isSingleArray	-> rowidoridx is the uuid
	 */
	deleteRow: function(field, rowidoridx) {
		var grid = this.data[field];
		if (!grid) return false;
		var idx = -1;
		if (this.prototype.isSingleArray(false, field)) {
			rowidoridx = parseInt(rowidoridx, 10);
			// in single arrays there's no uuid
			if (grid.length > rowidoridx) idx = rowidoridx;
		} else {
			grid.some(function(r, i) {
				if (r.$uuid == rowidoridx) {
					idx = i;
					return true;
				}
			});
		}
		if (idx < 0) return false;
		grid.splice(idx, 1);
		this.setDirty();
		return true;
	},
	/**
	 * Called when we save a rowDetail page
	 * If the dao has errors it keeps error status ($arrayUpdateError) at true
	 * If no error it sets $arrayUpdateError to false
	 * If we save a representation with nested arrays and have an error in the last level the parent lines are shown with errors (red border)
	 * If we change the value in error we clear the error
	 * If no error remains we have to remove the error status ($arrayUpdateError) in parent lines
	 */
	checkArrayUpdateError: function() {
		var d = this.data,
			errors = false;
		if (d.$properties) {
			// check diagnoes in fields
			for (var p in d.$properties) {
				if (p.$diagnoses && p.$diagnoses.length > 0) {
					errors = true;
					break;
				}
			}
		}
		if (!errors) {
			// check error status ($arrayUpdateError) in array fields lines
			var props = this.prototype.data("$properties") || {};
			for (var p in props) {
				if (props[p].$type === "application/x-array" && this.data[p] && this.data[p].some(function(r) {
					if (r.$arrayUpdateError) return true;
				})) {
					errors = true;
					break;
				}
			}
		}
		if (!errors) {
			// If no error found reser error status to not display the red border for this row
			d.$arrayUpdateError = false;
		}
	},
	/**
	 * This is the method we shoudl call to update data + metat data
	 * It uses Daniels's deltaManager
	 * TODO - Re-implement the management of data/meta-data like in desktop client
	 */
	applyChange: function(newData, opts) {
		if (!newData) newData = {};
		this.resetCache();
		if (!opts) opts = {};
		if (opts.$isPartialDelta == null) opts.$isPartialDelta = true;
		if (opts.$isEditMode == null) opts.$isEditMode = true;
		//console.log("BEFORE", JSON.stringify(this.data, null, 2));
		deltaManager.applyObjectDelta(opts, this.data, newData);
		//console.log("AFTER", JSON.stringify(this.data, null, 2));
		this.setDirty();
	},
	isValid: function() {
		return this.prototype != null && this.data != null && this.prototype.isValid();
	},
	expired: function(timeout) {
		var creDate, dao = this;
		while (dao != null && ((creDate = dao._creationDate) != null)) {
			dao = this.parent;
		}
		if (!creDate) return false;
		return (new Date().getTime() - creDate.getTime()) > timeout;
	},
	/**
	 * Process the given operation on data || this.data
	 */
	_processData: function(operation, data) {
		if (!this._dataProcessor) {
			this._dataProcessor = new _DataProcessor();
		}
		return this._dataProcessor.process(operation, data || this.data);
	},

	/** data.$cacheHint:{}
	 *data.$cache: Object
	 *	$lastRead: "2015-11-10-12-05-53"
	 *		$lastUpdated: "2015-11-10-12-04-50"
	 *
	 * data.$cacheHint:{}
	 * data.$resources[0].$cache
	 *		$lastRead: "2015-11-10-12-05-53"
	 * 	    $lastUpdated: "2015-11-10-12-04-50
	 */
	dataFreshness: function() {
		var freshNess = {
			dateTime: 0
		};
		if (this.data) {
			freshNess.dateTime = new Date().getTime();
			if (this.data.dateTime) {
				//nothing for moment
				freshNess.dateTime = Math.min(freshNess.dateTime, new Date().getTime());
			}
			if (this.data.$cacheHint) {
				if (this.data.$cache) {
					freshNess.dateTime = Math.min(freshNess.dateTime, utils.getTimeFromString(this.data.$cache.$lastUpdated));
				} else {
					freshNess.dateTime = Math.min(freshNess.dateTime, _getResourcesTime(this.data.$resources));
				}
			};
		}
		return freshNess;
	},
	/**
	 * Returns the data to save as a template
	 */
	getTemplateData: function() {
		var op = {
			dataToTemplate: {}
		};
		var data = $.extend(true, {}, this.data);
		this._processData(op, data);
		return data;
	},
	/**
	 * Check data accdoring to the prototype
	 * Remove the keys from tmpl data
	 */
	_setTmplWalkProto: function(proto, data, dataSet) {
		var self = this;
		if (!data || !proto || !proto.$properties) return;
		var parentKey;
		if (proto && proto.$key) {
			parentKey = utils.sdataExtractKeyFields(proto.$key);
		}
		for (var p in proto.$properties) {
			var prop = proto.$properties[p];
			if (prop == null || data[p] == null) {
				continue;
			}
			if (parentKey && parentKey.indexOf(p) >= 0) {
				/**
				 * Keys are not copied to be able to inject template data into a create facets
				 * Eg create an new order from an existing one
				 */
				continue;
			}
			if (prop.$type === "application/x-array") {
				// Currently we replace the rows
				// TODO - Eventually do a merge of rows by comparing records keys
				dataSet[p] = [];
				if (data[p].length == 0) continue;
				var protoArray = prop.$item;
				data[p].forEach(function(rowData, idx) {
					if (protoArray.$type === "application/json") {
						var filteredRowData = self._setTmplWalkProto(protoArray, rowData, {});
						if (!$.isEmptyObject(filteredRowData)) {
							dataSet[p].push(self._setTmplWalkProto(protoArray, rowData, {}));
						}
					} else {
						dataSet[p].push(rowData);
					}
				});
			} else {
				dataSet[p] = data[p];
			}
		}
		if (data["hasUUID"] == true && dataSet["$uuid"] == null) {
			// TODO - see if really needed - Should we remove all $uuid or amlways create new ones
			dataSet["$uuid"] = utils.UUID();
		}
		return dataSet;
	},
	/**
	 * Update ethe currentj datasEt with the data comming froma template
	 */
	setTemplateData: function(data) {
		if (!this.prototype) return;
		this._setTmplWalkProto(this.prototype.json, data, this.data);
		this.setDirty();
	},

	/*
	 * Used to set values in a newly created row by setting a value read from the parent
	 */
	initParentBasedDefaultValues: function() {
		var self = this;
		if (!this.parent) { // No parent, so we are not able to set default values. This should never happen since this 
			return; // method is called for row detail dao only
		}
		var parentRepr = this.parent.prototype.data("$representation");
		if (!parentRepr) {
			return;
		}
		var rowProperties = this.prototype.data("$properties");
		var parentProperties = this.parent.prototype.data("$properties");
		if (!rowProperties || !parentProperties) {
			return;
		}
		$.each(rowProperties, function(name, rowProperty) {
			if (rowProperty.$type === "application/x-reference") {
				var $itemUrl = rowProperty.$item && rowProperty.$item.$url;
				var itemRepr = /representation=(.+?)\./.exec($itemUrl);
				itemRepr = itemRepr && itemRepr.length > 1 ? itemRepr[1] : null;
				// Is the row property is a reference field to the same type as the row parent?
				// If yes, we can set the value of the row property to the key of the parent 
				if (itemRepr === parentRepr) {
					var $refValue = rowProperty.$item.$refValue;
					var $lookupValue = rowProperty.$item.$lookupValue;

					var parentValue = self.parent.getValue($lookupValue);
					if (parentValue != null) {
						self.setValue(name, parentValue);
					}
				}
			}
		});
	}
});
// for override only
exports.Dao = _Dao;
exports.emptyDao = function(prototype) {
	return new _Dao({
		$properties: {}
	}, prototype);
};
});

define('syracuse-tablet/html/js/storage/sessionStorage',['require','exports','module','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {"use strict";

/**
 * Session storage
 * 	Uses windows session storage or local hash map if not available
 */

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("sessstorage");

var _available = null;
var _backupMap = {};

var _isAvailable = function() {
	if (_available !== null) {
		return _available;
	}
	_available = false;
	try {
		window.sessionStorage.setItem("__test_availability_session__", "__test_availability_session__");
		_available = true;
	} catch (e) {}
	return _available;
};

var _getItem = function(key) {
	if (!_isAvailable()) {
		log && log("session.fallback.getItem(" + key + "):" + val);
		return _backupMap[key];
	}
	var val = window.sessionStorage.getItem(key);
	log && log("session.getItem(" + key + "):" + val);
	return val;
};

var _setItem = function(key, value) {
	if (!_isAvailable()) {
		log && log("session.fallback.setItem(" + key + "):" + value);
		_backupMap[key] = value;
		return;
	}
	log && log("session.setItem(" + key + "):" + value);
	return window.sessionStorage.setItem(key, value);
};

var _removeItem = function(key) {
	if (!_isAvailable()) {
		log && log("session.fallback.removeItem(" + key + ")");
		delete _backupMap[key];
		return;
	}
	log && log("session.removeItem(" + key + ")");
	return window.sessionStorage.removeItem(key);
};

exports.removeItem = _removeItem;
exports.setItem = _setItem;
exports.getItem = _getItem;
});

define('syracuse-tablet/html/js/application/gadget',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');

var _Gadget = utils.defineClass(function(jsonData) {
	var self = this;
	self._data = jsonData;
}, null, {

	destroy: function() {
		var self = this;
		self._data = null;
	},

	isRequest: function() {
		return this._data.$type === "$request";
	},

	isStatistics: function() {
		return this._data.$type === "$stats";
	},

	data: function(prop) {
		return this._data ? this._data[prop] : null;
	},

	getEndPoint: function() {
		// Default endpoint if not specified
		return this._data.endpoint || globals.getEndpoint();
	},

	isDefaultEndpoint: function() {
		return !this._data.endpoint;
	},

	getPageName: function() {
		var self = this;
		if (!self.isValid()) return null;
		var rep;

		if (self.isRequest()) {
			rep = self.getRequestRepresentation();
		} else if (self.isStatistics()) {
			var rep = self.getStatsRepresentation();
		} else {
			var rep = self._data.representation;
		}

		return self.getEndPoint() + "." + rep + "." + self._data.facet;
	},

	getSDataUrl: function(proto) {
		var self = this;
		var url;
		switch (self._data.$type) {
			case "$representation":
				if (["$details", "$edit"].indexOf(self._data.action) > -1) {
					url = proto.data("$url", {
						$key: self._data.keyParameter
					});
				} else if (["$create"].indexOf(self._data.action) > -1) {
					url = proto.data("$url");
					url = url.replace(/\((.*?)\)/, "/$template");
				} else {
					url = proto.data("$url");
				}
				break;
			case "$request":
				url = proto.data("$baseUrl");
				// Calculated instead of using $url - We need to add the requestlevel
				url = url + "/QUERY('" + self._data.requestName + "')?representation=" + self.getRequestRepresentation() + ".$query";
				self._data.parameters && Object.keys(self._data.parameters).forEach(function(name) {
					var value = self._data.parameters[name].value;
					if (!value) {
						return;
					}
					if (name === "where") { // if parameter is where and contains placeholders, it's applied later by dashboard. Else it's directly added to url here since it's static
						if (/{\S+}/.test(value)) {
							return;
						}
					}
					url = url + "&" + name + "=" + value;
				});
				break;
			case "$stats":
				url = proto.data("$baseUrl");
				url = url + "/STATS('" + self._data.statName + "')?representation=" + self.getStatsRepresentation() + ".$cube";
				self._data.parameters && Object.keys(self._data.parameters).forEach(function(name) {
					var value = self._data.parameters[name].value;
					if (!value) {
						return;
					}
					if (name === "where") { // if parameter is where and contains placeholders, it's applied later by dashboard. Else it's directly added to url here since it's static
						if (/{\S+}/.test(value)) {
							return;
						}
					}
					url = url + "&" + name + "=" + value;
				});
				break;
		}
		return url;
	},
	getRequestRepresentation: function() {
		return "QUERY~" + this._data.requestName + "~" + this._data.requestLevel;
	},
	getStatsRepresentation: function() {
		return "STATS~" + this._data.statName;
	},
	getJSON: function() {
		return $.extend(true, {}, this._data);
	},
	isValid: function() {
		// to complete
		return this.getInvalidReason() == null;
	},
	getInvalidReason: function() {
		var t = this._data.$type;
		if (t === "$representation" || t === "$stats" || t === "$request") {
			// When we import mobile apps we could have such error
			// tablet client displays a user friendly message
			// to complete
			if (this._data.$uuid.smStartsWith("test")) return null;
			return (this.getEndPoint() || "").trim().length == 0 ? "No endpoint" : null;
		}
		// TODO
		return null;
	},
	getParameters: function() {
		return this._data.parameters || {};
	}
});

exports.Klass = _Gadget;
});

define('syracuse-tablet/html/js/ui/modals/modalSaveDraft',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/modals/modalMultiButtons','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/ui/modals/modalMultiButtons').Modal;
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _template = {
	comment: '\
		<div style="display:table;">\
			<div style="display:table-row;">\
				<div style="display:table-cell;padding-right: 20px;">\
					{{comment}}\
				</div>\
				<div style="display:table-cell;width:100%;">\
					<input type="text" style="width: 100%;">\
				</div>\
			</div>\
		</div>'
};
/**
 * comment: comment input by the user
 * offline: true if user is asked to save an offline draft
 */
var _Klass = utils.defineClass(
	function ModalSaveDraft(comment, offline) {
		var opts = {
			buttons: []
		};
		["cancel", "save"].forEach(function(act) {
			opts.buttons.push({
				action: act,
				label: locale.text(act)
			});
		});
		var type = offline === true ? "offline" : "online";
		Base.call(this, locale.text("drafts.dlog.save.title." + type), locale.text("drafts.dlog.save.info." + type), opts);
		this._comment = comment || "";
	}, Base, {
		_attachDOM: function() {
			Base.prototype._attachDOM.call(this);
			$(Handlebars.compile(_template.comment)({
				comment: locale.text("comment").smCapitalize()
			})).appendTo(this.$$elmt.find(".s-m-modal-content")).find('input[type="text"]').val(this._comment).focus();
		},
		_getResult: function() {
			return {
				action: Base.prototype._getResult.call(this),
				comment: this.$$elmt.find('input[type="text"]').val()
			};
		}
	}
);
exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/pages/helpers/draftManager',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalMultiButtons','syracuse-tablet/html/js/ui/modals/modalSaveDraft'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalMultiButtons = require('syracuse-tablet/html/js/ui/modals/modalMultiButtons');
var modalSaveDraft = require('syracuse-tablet/html/js/ui/modals/modalSaveDraft');

/**
 * Manages the drafts process in pageRegular
 * 		Asks user to save the draft on back/cancel page.chekBack
 * 		Load the draft from DB in page.loadData process
 */
var _DraftMgr = function(page) {
	this._page = page;
	this._draftStatus = null;
	this._errMsg = null;

	this.destroy = function() {
		this._page = null;
	};
	/**
	 * !! Return always promise (true to continue back process)
	 * Ask user to save the draft or to remove an offline draft
	 */
	this.checkBack = function() {
		var self = this;
		if (self._offlineDraftId) {
			//  Ask user to remove offline draft which has been created automatically on connection error
			return self.offlineDraftAskRemove();
		}
		//  No modification in dao - skip checkBack
		if (!self._page.dao || !self._page.dao.isDirty) {
			return $.smResolve(true);
		}
		if (this._pageLoadedFromDraft()) {
			// We save without asking the user
			return this.save(false, false);
		}
		//  Ask user to discard changes or save as draft
		return self.askSaveDraft();
	};
	/**
	 * Ask user to discard changes or save as draft
	 * Resolves with true if save has been skipped or succeeded
	 * Resolves false if user canceled the operation
	 */
	this.askSaveDraft = function() {
		var self = this;
		var opts = {
			buttons: [],
			defaultAction: "no"
		};
		// Buttons displayed in dialog
		["drafts.dlog.savedraft.button", "no", "yes"].forEach(function(act) {
			opts.buttons.push({
				action: act,
				label: locale.text(act)
			});
		});
		// Id of label is taken as action id for convenience
		var modal = new modalMultiButtons.Modal(locale.text("drafts.dlog.savedraft.title"), locale.text("drafts.dlog.savedraft.info"), opts);
		return modal.show().then(function(result) {
			if (result === "drafts.dlog.savedraft.button") {
				return self.save(false, true).then(function(saved, draftCtx) {
					// back is allowed if no error otherwise we need to save again and say no is error is persisting
					return saved === true;
				});
			} else {
				return result !== "no";
			}
		});
	};
	/**
	 * offline: 	true if user is asked to save an offline draft
	 * confirm: 	Ask user to input a comment and save/cancel action
	 * Resolve 		with true/false and draft context
	 */
	this.save = function(offline, confirm) {
		var self = this;
		var deferred = $.Deferred();
		var step;
		if (confirm === true) {
			step = new modalSaveDraft.Modal(self._comment || "", offline === true).show();
		} else {
			step = $.smResolve({
				action: "save",
				comment: self._comment
			});
		}
		step.then(function(result) {
			if (result == null || result.action != "save") return null;
			return self.saveInDB(result.comment, offline);
		}).then(function(ctx) {
			if (ctx) {
				globals.getModal().notify({
					severityClass: offline ? "warning" : "success",
					title: locale.text("drafts.notify.saved" + (offline ? ".offline" : "")),
					body: offline ? locale.text("drafts.notify.saved") : null,
					delay: offline ? "medium" : "short"
				});
			}
			deferred.resolve(ctx != null, ctx);
		}).fail(function(e) {
			globals.getModal().error(locale.text("drafts.error.saving"), e, function() {
				deferred.resolve(false, null);
			});
		});
		return deferred.promise();
	};
	/**
	 *Save draft in DB
	 */
	this.saveInDB = function(comment, offline) {
		var self = this;
		var uuid = jsutils.getPropByPath(self._page, "dao.data.$uuid");
		if (!uuid) {
			return $.smReject("Unexpected null uuid");
		}
		var restoredCtx = self._page.getRestoreContext();
		restoredCtx.currentState.options["workingCopy-Id"] = null;
		restoredCtx.currentState.options["draft-id"] = uuid;
		if (!self._draftSaveLink) {
			var links = self._page.getProtoLinks();
			Object.keys(links).some(function(key) {
				if (key === "$save") {
					self._draftSaveLink = links[key];
					return true;
				}
			});
		}
		if (!self._draftSaveLink) {
			return $.smReject("Unexpected $save link not found in prototype");
		}
		var draftContext = {
			"id": uuid,
			"endpoint": globals.getEndpointDescr(),
			"representation": self._page.prototype.data("$representation"),
			"status": offline ? "offline" : self._draftStatus || "unsavedchanges",
			"errorMsg": self._draftStatus === "error" ? self._errMsg : "",
			"title": self._page.prototype.data("$title") || "",
			"comment": comment || "",
			"restoredContext": restoredCtx,
			"dataSet": self._page.dao.data,
			"saveLink": self._draftSaveLink,
			"creation_date": utils.getCurISODateTime(new Date())
		};
		return globals.getStorage().draftOperation("draftSave", draftContext);
	};
	/**
	 * New data loaded in parent's page
	 */
	this.notifDataLoaded = function(refreshed) {
		// No need to wait the promise
		this.offlineDraftRemove();
		this._draftStatus = null;
		this._errMsg = null;
		// !! No dao.setDirty because if user click back he goes back to list (no dialog)
		// If data have been loaded from a draft we enable only save button by calling publishDirty and keep dao not dirty
		this._page.dao.publishDirty(this._pageLoadedFromDraft(), true);

	};
	this._pageLoadedFromDraft = function() {
		return this._page._dataLoadedFrom === "draft";
	};
	/**
	 * Save action succeeded in parent's page
	 */
	this.notifSaveSucceeded = function(result) {
		// No need to wait the promise
		this.offlineDraftRemove();
		if (result && result.responseJSON && result.responseJSON.$uuid) {
			return globals.getStorage().draftOperation("draftDelete", result.responseJSON.$uuid);
		} else {
			return $.smResolve();
		}
	};
	/**
	 * Save action failed in parent's page
	 * Return false if no user message to display
	 */
	this.notifSaveFailed = function(result) {
		var self = this;
		var responseJSON = result && result.responseJSON ? result.responseJSON : {};
		if (responseJSON.$noConnectionError === true) {
			/**
			 * No connection - we save the draft and keep the id to ask user to remove it when he/she will exit the page
			 * We don't display offline error - Notification is displayed in save method
			 */
			// self._offlineDraftId != null - Save dialog only he first time we save the offline draft 
			// _pageLoadedFromDraft == true we also don't ask the user
			self.save(true, self._offlineDraftId == null && !self._pageLoadedFromDraft()).then(function(saved, draftCtx) {
				if (saved) {
					self._offlineDraftId = draftCtx.id;
					// To not be prompt if we exit (back) or cancel edit
					self._page.dao.resetDirty();
					// Store the comment to recall it (see checkBack with _offlineDraftId)
					self._comment = draftCtx.comment;
				} else {
					self._offlineDraftId = null;
					self._comment = null;
				}
			});
			// No message to display
			return false;
		}
		self._offlineDraftId = null;
		// No need to wait the promise
		self.offlineDraftRemove();
		self._draftStatus = "error";
		self._errMsg = responseJSON && responseJSON.$diagnoses && responseJSON.$diagnoses.length > 0 ? responseJSON.$diagnoses[0].$message : 0;
		return true;
	};
	/**
	 * Ask user to remove of keep the current draft
	 * Resolves with false if user canceled the action
	 * Resolves false if user canceled the operation
	 */
	this.offlineDraftAskRemove = function() {
		var self = this;
		var opts = {
			buttons: [],
			defaultAction: "no"
		};
		// Buttons displayed in dialog
		["cancel", "no", "drafts.dlog.removeoffline.button"].forEach(function(act) {
			opts.buttons.push({
				action: act,
				label: locale.text(act)
			});
		});
		var modal = new modalMultiButtons.Modal(locale.text("drafts.dlog.removeoffline.title"), locale.text("drafts.dlog.removeoffline.info"), opts);
		return modal.show().then(function(result) {
			if (result === "drafts.dlog.removeoffline.button") {
				return self.offlineDraftRemove().always(function() {
					self._offlineDraftId = null;
					return "removed";
				});
			} else if (result === "cancel") {
				return "cancel";
			} else {
				return "kept";
			}
		}).then(function(result) {
			if (result === "cancel") return false;
			self._offlineDraftId = null;
			if (result === "removed") return true;
			// Result = kept
			if (self._page.dao.isDirty) {
				// Data has been modified since last save. Save with previous comment and offline mode
				return self.saveInDB(self._comment, true).always(function() {
					return true;
				});
			}
			return true;
		});
	};
	/**
	 * Removes an offline draft
	 */
	this.offlineDraftRemove = function() {
		var self = this;
		var deferred = $.Deferred();
		if (!self._offlineDraftId) {
			deferred.resolve();
		} else {
			globals.getStorage().draftOperation("draftDelete", self._offlineDraftId).always(function() {
				self._offlineDraftId = null;
				deferred.resolve();
			});
		}
		return deferred.promise();
	};
	/**
	 * Called by parent's page if there's a draft-id in state.options (edit draft action in pageDrafts)
	 * Read draft from DB
	 * Resolves with data or null
	 */
	this.loadFromDraft = function(draftId) {
		var self = this;
		self._comment = null;
		return globals.getStorage().draftOperation("draftRead", draftId).then(function(ctx) {
			var data;
			if (ctx && ctx.dataSet) {
				data = ctx.dataSet;
				// Used in order to propagate the comment if we save the draft again
				self._comment = ctx.comment;
				// To restore the status if back without modification - see notifDataLoaded loadedFrom == draft
				self._draftStatus = ctx.status;
				self._errMsg = ctx.errorMsg;
			}
			return $.smResolve(data, data != null ? "draft" : null);
		}).fail(function(e) {
			// Eventually display an error
			return null;
		});
	};
};

exports.Klass = _DraftMgr;
});

define('syracuse-tablet/html/js/pages/pageRegular',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/pages/page','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/sdata/sdataDispatcher','syracuse-tablet/html/js/application/appFactory','syracuse-tablet/html/js/application/daoSdata','syracuse-tablet/html/js/sdata/sdataUtils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/storage/sessionStorage','syracuse-tablet/html/js/application/eventListener','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/application/gadget','syracuse-tablet/html/js/pages/helpers/draftManager','syracuse-tablet/html/js/pages/helpers/helpers','syracuse-tablet/html/js/helpers/fieldOperators'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var Base = require('syracuse-tablet/html/js/pages/page').Page;
var globals = require('syracuse-tablet/html/js/helpers/globals');
var dispatcher = require('syracuse-tablet/html/js/sdata/sdataDispatcher');
var factory = require('syracuse-tablet/html/js/application/appFactory');
var daoSdata = require('syracuse-tablet/html/js/application/daoSdata');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var sessStorage = require('syracuse-tablet/html/js/storage/sessionStorage');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var native = require('syracuse-tablet/html/js/helpers/native/native');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var Gadget = require('syracuse-tablet/html/js/application/gadget').Klass;
var draftMgr = require('syracuse-tablet/html/js/pages/helpers/draftManager');
var pageHelpers = require('syracuse-tablet/html/js/pages/helpers/helpers');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');

/**
 * Page with representation and sdata back-end
 */
var _Page = utils.defineClass(
	function RegularPage($parent, state, prototype, article, options) {
		if (options.breadcrumbs == null) {
			// Show breadcrumbs by default if not hidden by child class
			options.breadcrumbs = true;
		}
		Base.call(this, $parent, state, prototype, article, options);
		// Gadget is created her because this.state must contain only JSON (restore context)
		this.gadget = this.state.options.gadget ? new Gadget(this.state.options.gadget) : null;
		this.openedFromDashboard = this.gadget != null;
		this._originalSdataUrl = this.state.options["sdata-url"];
		if (!this._originalSdataUrl) {
			if (this.gadget) {
				this._originalSdataUrl = this.gadget.getSDataUrl(this.prototype);
			} else {
				this._originalSdataUrl = this.prototype.data("$url");
			}
		}
		this._init$Filters();
		this._initSdataInfo();
		notifications.subscribe(this, ["sm.rowdetail.update", "sm.rowdetail.delete", "sm.action.link"], 1);
		var url = this.prototype.data("$url");
		var facet;
		if (url && url.length > 0) {
			facet = sdataUtils.parseSDataURL(url).facet;
		} else if (this.parentPage) {
			facet = this.parentPage.$facet;
		}
		// Override the standard "display" activity
		if (facet) {
			this.$facet = facet;
			this.setActivity(facet === "edit" ? "edit" : facet === "create" ? "create" : "read");
		}
		// Working copy is managed only if nativeApp because it is used to restore the context on nativeAppClosing/nativeAppResume events
		// Disabled temporarily for rowDetail see class
		this.enableWorkingCopy = this.isEditMode() && native.hasCapability("nativeApp") && !this.isChild;
		if (this.isEditMode() && !this.isChild) {
			this._draftMgr = new draftMgr.Klass(this);
		}
		this.representation = this.prototype.data("$representation");
	}, Base, {
		_init$Filters: function() {
			var savedCtx = this.getSavedContext();
			// Rstoration of sort/filter if any (only if page is restored from a link)
			if (savedCtx && savedCtx.sortInfo) {
				this.filterSortWrite("sort", savedCtx.sortInfo);
			}
			if (savedCtx && savedCtx.filterInfo) {
				this.filterSortWrite("filter", savedCtx.filterInfo);
			}
			// Restore the selected $filters (filters given by prototype)
			var $filterId = savedCtx ? savedCtx.$filterId : null;
			this._$filters = [{
				id: "nofilter",
				$title: locale.text("nofilter")
			}];
			// Authoring on filters - none/list/tabs
			var auth = this.$filtersGetAuthoring();
			var filters = $.extend(true, {}, this.prototype.data("$filters"));
			if (auth === "none" || !filters || $.isEmptyObject(filters)) {
				this._$filtersDisabled = true;
				return;
			}
			var defFilter = null;
			for (var p in filters) {
				var ttl = this.prototype.resolveExpression(filters[p].$title);
				if (ttl) {
					var f = $.extend(true, {}, filters[p]);
					f.$title = ttl;
					f.id = p;
					f.$isDefault = false;
					if ($filterId && f.id === $filterId) {
						defFilter = f;
					} else if (!defFilter && f.$isDefault === true) {
						defFilter = f;
					}
					this._$filters.push(f);
				}
			}
			if (this._$filters.length == 0) return;
			if (defFilter) {
				defFilter.$isDefault = true;
			} else {
				this._$filters[0].$isDefault = true;
			}
		},

		/**
		 *  Init sdata url - Called in constructor and page refresh
		 * 	sdataUrl is optional in case of a gadget (to see with Mathias)
		 *  Can be overridden - rowdetail
		 */
		_initSdataInfo: function(sdataUrl) {
			if (!sdataUrl) sdataUrl = this._originalSdataUrl;
			if (this.gadget) {
				var params = this.gadget.getParameters();
				if (params.where) {
					sdataUrl = sdataUtils.addWhereClause(sdataUrl, params.where, this.state.options.sdataParameters);
				}
			}
			if (!sdataUrl) throw new Error("$url (sDataUrl) is expected");
			this.state.options["sdata-url"] = this.sDataUrl = sdataUrl;
			this.sDataMethod = this.state.options["sdata-method"] || "GET";
		},
		getOriginalSdataUrl: function() {
			return this._originalSdataUrl;
		},
		destroy: function() {
			if (this.destroyed) return;
			if (this._draftMgr) {
				this._draftMgr.destroy();
				this._draftMgr = null;
			}
			if (this.prototype && !this.prototype.isLookup()) {
				var keepWorkingCopy = this.enableWorkingCopy === true && this.state.options["workingCopy-Id"];
				if (!this.isVignette && !keepWorkingCopy && !this.isChild) {
					// Delete all the working copies because not needed any more - Page will not be restored
					globals.getStorage().draftOperation("wrkcpyDeleteAll");
				} else if (this.isVignette && !keepWorkingCopy && this.dao && this.dao.workingCopyGetId()) {
					// in a dashboard with multiple create/edit facest we just delete the current WorkingCopy (transaction) because we don't know if other pages will be restored
					globals.getStorage().draftOperation("wrkcpyDelete", this.dao.workingCopyGetId());
				}
			}
			if (this.prototype && this.prototype.acceptServerPagination() && !globals.isAuthoringActive()) {
				// Clear the cache used by authoring for this page - Only if authoring not active
				// On a dashboard when we change an authoring property the page is destroyed and recreated so we don't destroy the cache
				notifications.publish("sm.authcache.destroy", this.id);
			}
			Base.prototype.destroy.call(this);
			if (this._editTemplatesPanel) {
				this._editTemplatesPanel.destroy();
				this._editTemplatesPanel = null;
			}
			this.gadget = null;
		},
		/**
		 * True if the page is the same as state
		 */
		isSamePage: function(state) {
			return Base.prototype.isSamePage.call(this) && state && state.options && state.options["sdata-url"] === this.sDataUrl;
		},
		initOnLoad: function() {
			// TODO: Load filter settings
		},
		beforeAddContent: function() {
			if (false && !this.isVignette) {
				// #5583 - disabled because redundant with header title
				var ttl = this.prototype.data("$title");
				this.addTitle(globals.getApplication().getTitle() + (ttl ? " - " + ttl : ""));
			}
		},
		afterRender: function(loadOptions, buildOpts) {
			var self = this;
			return Base.prototype.afterRender.call(self, loadOptions, buildOpts).then(function() {
				if (self.isVignette) return;
				var diags = self.dao && self.dao.data && self.dao.data.$diagnoses;
				if (diags && diags.length > 0) {
					diags.forEach(function(diag) {
						var notify = {
							severityClass: globals.X3_SEVERITY_TO_BS[diag.$severity] || diag.$severity || "error",
							title: diag.$message
						};
						globals.getModal().notify(notify);
					});
				}
			});
		},
		activate: function(pageToClose, cb) {
			Base.prototype.activate.call(this, pageToClose, cb);
			// !!! Notification is called (not on loadData) here because we the current page should be activated to trigger the notification event
			notifications.publish("sm.data.freshness.change", this.dao.dataFreshness());
		},
		/**
		 * Used by html builder to create a link to full page
		 */
		getOpenLinkAttrs: function() {
			var res = Base.prototype.getOpenLinkAttrs.call(this);
			res["data-sdata-url"] = this.sDataUrl;
			res["data-sdata-method"] = this.sDataMethod;
			res["data-gadget-id"] = this.gadget.data("$uuid");
			return res;
		},

		/**
		 * Refresh the page - Specific to pageRegular - The standard method is page.reload
		 * Manages specific options ( TODO override reload)
		 * 	Called from a vignette or full page (callBackInterface)
		 * 	options.sdata-url -> New url
		 * 	options.controlId!=null -> refresh the control
		 *  options.type Type of refresh (pagination...)
		 *  callBackInterface
		 *  	waitWheelStop(ctrlId) / waitWheelStart(ctrlId)
		 */
		refresh: function(options, callBackInterface) {
			var self = this;
			options = options || {};
			var deferred = $.Deferred();
			var url = options["sdata-url"];
			var controlId = options["controlId"];
			var type = options.type || "";
			var force = type === "filtersort" || options.forceRefresh === true;
			var _wait = function(status) {
				var meth = "waitWheel" + status.smCapitalize();
				if (callBackInterface) {
					if (callBackInterface[meth]) {
						callBackInterface[meth].call(null, controlId);
					}
					return;
				}
				if (self[meth]) {
					self[meth].call(self, controlId);
					return;
				}
			};
			try {
				var _succeeded = function() {
					_wait("stop");
					self.refreshControls(controlId ? [controlId] : null, options);
					deferred.resolve();
				};
				if (!url && force !== true) {
					_succeeded();
				} else {
					_wait("start");
					if (url) {
						/* url can change on refresh (paginations)*/
						self._initSdataInfo(url);
					}
					self.loadData({
						refresh: true
					})
						.then(function() {
							_succeeded();
						}).fail(function(e) {
							_wait("stop");
							deferred.reject(e);
						});
				}
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},
		/**
		 * Url with where clause
		 */
		_getFullSdataUrl: function() {
			return this._filterSortAllowed() ? this._filterSortUpdateUrl() : this.sDataUrl;
		},
		/**
		 * reason: nativeAppClosing, pinPage, sharedLink...
		 */
		getRestoreContext: function(reason) {
			var ctx = Base.prototype.getRestoreContext.call(this, reason);
			if (!ctx) return ctx;
			if (this.state.options.sdataParameters) {
				ctx.currentState.options["sdataParameters"] = this.state.options.sdataParameters;
			}
			ctx.currentState.options["sdata-url"] = this.sDataUrl;
			if (this.dao && reason === "nativeAppClosing" && this.enableWorkingCopy === true) {
				ctx.currentState.options["workingCopy-Id"] = this.dao.workingCopyGetId(true);
			}
			return ctx;
		},
		savedCtxCreate: function(type) {
			var ctx = Base.prototype.savedCtxCreate.call(this, type);
			var $f = this._$filterGetInfo();
			// Save $filter info to restore it
			ctx.$filterId = $f && $f.id;
			if (type != "link" || !this._filterSortAllowed()) {
				return ctx;
			}
			// For a link context we save the filterSortInfo
			// -> By default this info is saved in sessionStorage (user prefs)
			ctx.sortInfo = this.filterSortRead("sort");
			ctx.filterInfo = this.filterSortRead("filter");
			return ctx;
		},
		loadData: function(loadOptions) {
			var self = this;
			loadOptions = loadOptions || {};
			var step;
			var enableWorkingCopy = this.enableWorkingCopy === true;
			// If the page is opened with state.options.draft-id we try to read the draft (used by editDraft action)
			if (loadOptions.reload !== true && this.state.options["draft-id"] && self._draftMgr) {
				// First
				step = self._draftMgr.loadFromDraft(this.state.options["draft-id"]);
			} else if (enableWorkingCopy) {
				// If the page is opened with state.options.workingCopy-Id" we try to read the workng copy (used when we restore a context)
				step = self.loadCheckWorkingCopy(loadOptions);
			} else {
				// Read data from sdata dispatcher (server or sdata cache)
				step = $.smResolve(null);
			}
			return step.then(function(data, loadedFrom) {
				if (data) return $.smResolve(data, loadedFrom);
				return self.loadFromSData(loadOptions);
			}).then(function(data, loadedFrom) {
				// Eventually to put an icon/info to let the user know
				if (self.destroyed) {
					// Security - Page can be destroyed while loading in dashboard  
					return;
				}
				data = self._processSdataParams(data);
				self._dataLoadedFrom = loadedFrom;
				// If no json returned we create en empty dao
				self.setDao(data ? factory.createDaoSdata(data, self.prototype, {
					enableWorkingCopy: enableWorkingCopy
				}) : self.getEmptyDao(self.prototype));
				if (loadOptions.refresh === true) {
					// Only on page refresh otherwise see activate method - next/previous datas in grid...
					notifications.publish("sm.data.freshness.change", self.dao.dataFreshness());
				}
				if (loadedFrom === "workingCopy") {
					// To force save button enabled and ask user to save draft
					self.dao.setDirty();
				}
				if (loadedFrom === "draft") {
					// Remove the draft id - A new one will be created if the form is saved again or reloaded
					self.state.options["draft-id"] = null;
					// !! No dao.setDirty because if user click back he goes back to list (no dialog)
					// We enable only save button with getLinksInitStatus and keep dao not dirty
				}
				if (self._draftMgr) {
					self._draftMgr.notifDataLoaded();
				}
			});
		},
		// #7811 - take into account the sdataParameter to update the create facte dao with selected values
		// TODO - Finalize
		_processSdataParams: function(data) {
			if (this.$activity !== "create" || this.gadget == null) return data;
			var params = this.gadget.getParameters();
			if (!params || !params.context) return data;
			if ($.isEmptyObject(this.state.options.sdataParameters)) return data;
			var ctx = {}, prop, val, suffix, fldName;
			for (var p in params.context) {
				// To improve - Just a proof of concept
				fldName = p + "_REF";
				prop = this.prototype.property(fldName);
				if (prop) {
					// Add the value
					val = utils.parseExpression(params.context[p], this.state.options.sdataParameters);
					if (prop.$type === "application/x-reference") {
						ctx[fldName] = {
							"$value": val
						};
						ctx[p] = val;
					} else {
						val = fieldOperators.checkValue(prop.$type, val);
						ctx[p] = val;
					}
				}
			}
			return $.isEmptyObject(ctx) ? data : $.extend(data, ctx);
		},
		/**
		 * Returns the status of save/showTemplates link to enable/disable the button when header/footer is created
		 * See ctrlHelpers.checkLinkInitStatus
		 */
		getLinksInitStatus: function() {
			var self = this;
			if (!self.dao || self.destroyed) {
				return $.smResolve(null);
			}
			var res = {
				dirtyDao: {
					// We force true if the page is loaded from a draft because the user can save without having modified the page
					isDirty: self.dao.isDirty || self._dataLoadedFrom === "draft",
					$uuid: self.dao.data.$uuid
				}
			};
			return globals.getStorage().templateOperation("count", globals.getEndpoint(), self.representation).then(function(count) {
				res.editTemplates = {
					count: count
				};
				return res;
			});
		},
		/**
		 * Resolves with data or null
		 * Null -> Data are loaded from sData dispatcher
		 */
		loadCheckWorkingCopy: function(loadOptions) {
			if (loadOptions.reload === true) {
				// Page reloaded we delete the current working copy 
				// No need to wait - wrkcpyDelete resolves with true/false
				if (this.dao && this.dao.workingCopyGetId()) {
					globals.getStorage().draftOperation("wrkcpyDelete", this.dao.workingCopyGetId());
				}
				return $.smResolve(null);
			} else if (this.state.options["workingCopy-Id"]) {
				var id = this.state.options["workingCopy-Id"];
				//Delete workingCopy-Id - It will be set by getRestoreContext if we need to keep the working copy
				this.state.options["workingCopy-Id"] = null;
				// Page not reloaded we read the current working copy 
				return globals.getStorage().draftOperation("wrkcpyRead", id).then(function(data) {
					return $.smResolve(data, data != null ? "workingCopy" : null);
				});
			}
			// Nothing
			return $.smResolve(null);
		},
		loadFromSData: function(loadOptions) {
			var self = this;
			// Force to read data in the cache to speed up rendering
			var forceUseCache = loadOptions.updateLayout || utils.forceUseCache();
			var dispatchOptions = {
				forceUseCache: forceUseCache
			};
			if (self.prototype.acceptServerPagination()) {
				// Tells the dispatcher to store locally the whole JSON of the page to be used in authoring mode 
				// If forceUseCache=true the pagination managed by the cache doesn't work the same way
				// cache is cleared when the page is destroyed
				dispatchOptions.$authCacheId = self.id;
			}
			return dispatcher.dispatch({
				$url: self._getFullSdataUrl(),
				$method: self.sDataMethod
			}, null, dispatchOptions).then(function(data) {
				if (!forceUseCache) {
					// if forceUseCache we don't know if we on/off line
					globals.setOffline(data != null && (data.$cache != null || data.$cacheHint != null));
				}
				return $.smResolve(data, "sdata");
			});
		},
		/**
		 * Lookup notification
		 * 		rowData:	Selected row data
		 * 		controlId:	Id of control to refresh
		 */
		notifLookupSelection: function(rowData, controlId) {
			if (!this.isActive()) return;
			Base.prototype.notifLookupSelection.call(this, rowData, controlId);
		},
		/** Event sm.action.link
		 *  Notified when a action succeeded - sdata link - see action manager
		 *  success:	true/false
		 *  link:		Link info
		 *  result:		Json response
		 */
		notifActionLink: function(success, link, result, options) {
			var self = this;
			if (!self.isActive()) return;
			try {
				result = result || {};
				result.responseJSON = result.responseJSON || {};
				var _displayMessage = function(thereIsFieldErrors) {
					if (thereIsFieldErrors === true && success === true) {
						// No success message if fields errors
						return;
					}
					globals.getModal().displayActionMsg(success, link.name, self.prototype, result.responseJSON);
				};
				switch (link.name) {
					case "$save":
						self._doActSave(success, link, result, options);
						break;
					case "$delete":
						self.goBack().always(function() {
							_displayMessage();
						});
						break;
					case "$canceledit":
						self.checkBack().then(function(kontinue) {
							if (kontinue != true) {
								// Process stopped because user canced saveDraft action - We stay on the form
								return;
							}
							// If data loaded from draft we go back to draft list
							if (self.$activity === "create" && self._dataLoadedFrom !== "draft") {
								self.reload();
							} else {
								// To avoid chekBack to display save draft
								self.dao.resetDirty();
								var autoScroll = self.getScrollValue();
								self.goBack().then(function(newPage) {
									if (newPage == null || self._dataLoadedFrom === "draft") return;
									// Cancel in edit facet - We try to keep the scrolling of the page
									// We stay at the same location - .8 because the height of the page is less in detail than edit
									// in actionManager we also preserve scrolling when we go from edit to detail
									setTimeout(function() {
										newPage.autoScroll(autoScroll * 0.8);
									});
								});
							}
						});
						break;
					case "$showtemplates":
						if (!this._editTemplatesPanel) {
							this._editTemplatesPanel = this.panelCreate(globals.PANELEDITTEMPLATES, {
								fromActionMgrUUID: options.fromActionMgrUUID
							});
						}
						this.panelAttach("right", this._editTemplatesPanel, "toggle");
						break;
					default:
						var thereIsFieldErrors = false;
						if (link.$isAction === true && result.responseJSON) {
							thereIsFieldErrors = self._myApplyChange(result.responseJSON);
						}
						var settings = self.actionGetSettings(link.name, "options");
						if (success === true && settings && settings.backIfSuccess === true) {
							self.goBack().then(function() {
								_displayMessage(thereIsFieldErrors);
							});
						} else if (settings && settings.refreshPage === true) {
							self.refresh({
								forceRefresh: true
							}).then(function() {
								_displayMessage(thereIsFieldErrors);
							});
						} else {
							_displayMessage(thereIsFieldErrors);
						}
						break;
				}
			} catch (e) {
				globals.getModal().error("notifActionLink failed", e);
			}
		},
		/**
		 * For right panel action we call standard applyChange that check DATA + META-DATA and refresh controls
		 * TODO - Use always this process after having removed the old _updateMeta in daoSData
		 * Return true if field errors
		 */
		_myApplyChange: function(responseJSON) {
			this.dao.applyChange(responseJSON, {
				$isPartialDelta: false,
				$isEditMode: this.isEditMode()
			});
			var errors = this.refreshControls(null, {
				refreshValue: true
			});
			if (errors.length > 0) {
				// Set focus on the first error field
				errors[0].setFocus();
			}
			if (this._gestureMgr) {
				// We need to adjust the scroller because line can be removed -> Make content visible
				this._gestureMgr.adjust();
			}
			return errors.length > 0;
		},
		/**
		 * Validate data before sending an action
		 */
		validateBeforeActionLink: function(link) {
			if (!link) return true;
			if (link.$method !== "POST" && link.$method !== "PUT") return true;
			return this.checkControlsData();
		},
		// Action on child pages
		_doActSave: function(success, link, result, options) {
			var self = this;
			if (success) {
				// To not ask the user to save as draft when page change
				self.dao.resetDirty();
				var step;
				if (self._draftMgr) {
					// Removes the current draft
					step = self._draftMgr.notifSaveSucceeded(result);
				} else {
					step = $.smResolve();
				}
				step.always(function() {
					if (self.openedFromDashboard && self.$activity === "create") {
						// When we open a create form from the dashboard we stay on the page and relaod it to allow a new creation - No back
						// Displays diagnoses contained in response
						globals.getModal().displayActionMsg(success, link.title || link.name, self.prototype, result.responseJSON);
						self.reload();
					} else {
						self.goBack().always(function(dstPage) {
							// Displays diagnoses contained in response if any once the back page has been displayed
							globals.getModal().displayActionMsg(success, link.title || link.name, self.prototype, result.responseJSON);
							if (dstPage && dstPage.$activity === "create") {
								// If we stay on a create page we reload it - Create page inside the vignette - goBAck returns the initial $create page
								dstPage.reload();
							}
						});
					}
				});
			} else {
				// !! We expect that input fields errors come always with success = false
				// We just update the meta to extract diagnoses
				if (self.dao.updateMeta(result.responseJSON)) {
					// Update controls - Display diagnoses
					var errors = self.refreshControls(null, {});
					if (errors.length > 0) {
						// Set focus on the first error field
						errors[0].setFocus();
					}
					if (self._gestureMgr) {
						// We need to adjust the scroller because line can be removed -> Make content visible
						self._gestureMgr.adjust();
					}
				}
				if (self._draftMgr == null || self._draftMgr.notifSaveFailed(result)) {
					// Display global message
					globals.getModal().actionResult(locale.text("action.save.failed"), result.responseJSON);
				}
			}
		},
		/**
		 * True if scroll enabled in page
		 * edit/detail allows scroll in vignette
		 * query/lookup doesn't allow because scroll is done by the array
		 */
		scrollAllowed: function() {
			if (this.prototype.isQueryLikeFacet()) {
				// This is the array which scrolls
				return false;
			}
			return true;
		},
		/**
		 * Save a rowDetail dao (childDao) into the current dao
		 */
		notifRowdetailUpdate: function(info, arrayId) {
			if (!info) return;
			var childDao = info.dao;
			if (!childDao) return;
			// singleArrayRowIdx needed for single arrays
			var array = this.getControl(arrayId);
			if (!array) return;
			var create = info.activity === "create";
			var singleArrayRowIdx;
			if (!create && array.prototype.isSingleArray()) {
				// For single arrays we added a $uuid in arrayData to manage them as other arrays
				// When we update the dao we need to retreive the index from the uuid because there's no uuid in for theses row in parent dao
				singleArrayRowIdx = array.rowId2Idx(childDao.getValue("$uuid"));
			} // If not singleArray the row will be rtreive in parent from th uuid contained in childDao
			if (childDao.updateParentRow(create, singleArrayRowIdx)) {
				var errors = this.refreshControls([arrayId], {});
				if (errors.length > 0) {
					// Set focus on the firts error field
					errors[0].setFocus();
				}
			}
			// True to destroy the prototype
			// The prototype has been created with the row detail dao and we need them in parent page (here)
			// So we have to destroy them once we have updated the parent page dao (not destroyed when row detail page is destroyed)
			childDao.destroy(true);
		},
		/**
		 * Delete a row (data.uuid) in current dao - Row has been deleted by Delete footer action
		 */
		notifRowdetailDelete: function(data, arrayId) {
			if (!data || !data.uuid) return;
			var array = this.getControl(arrayId);
			if (!array) return;
			var rowidOrIdx = data.uuid;
			if (array.prototype.isSingleArray()) {
				rowidOrIdx = array.rowId2Idx(data.uuid);
			}
			// Remove the row in dao by idx or rowid 
			this.dao.deleteRow(array.$bind, rowidOrIdx);
			// Remove html identofied by uuid
			array.removeRow(data.uuid);
		},
		getPinPageId: function() {
			return this.state.name + "_" + this.sDataUrl;
		},
		getPinPageData: function() {
			var self = this;
			var pageData = Base.prototype.getPinPageData.call(self);

			pageData.sDataUrl = self.sDataUrl;
			pageData.key = self.prototype.data("$key", self.dao);

			var pu = jsutils.parseURL(pageData.sDataUrl);
			var repr = pu.query.representation.split(".");
			pageData.representation = repr[0];
			pageData.facet = repr[1];
			pageData.action = repr[1];

			var ps = pu.path.split("/");
			pageData.entity = ps[5];
			pageData.endpoint = pu.path.split("/").slice(2, 5).join(".");

			var value = self.prototype.data("$value", self.dao);
			if (value) {
				pageData.title = self.prototype.data("$title") + " - " + value;
			}
			return pageData;
		},
		filterSortRead: function(type) {
			if (!this._filterSortAllowed()) return null;
			var id = this._filterInfoSaveId(type);
			if (!this._filterSortInfo) this._filterSortInfo = {};
			var info = this._filterSortInfo[id];
			if (info) return info;
			info = sessStorage.getItem(id);
			if (info) {
				try {
					info = JSON.parse(info);
					return info;
				} catch (e) {}
			}
			return null;
		},
		filterSortWrite: function(type, info, refresh) {
			if (!this._filterSortAllowed()) return null;
			var id = this._filterInfoSaveId(type);
			var save = false;
			if (info && info.length > 0) {
				var old = this.filterSortRead(type);
				if (old == null || !this._filterSortEquals(type, info, old)) {
					save = true;
				}
			} else {
				save = info != this._filterSortInfo[id];
			}
			if (save !== true) return;
			sessStorage.setItem(id, info ? JSON.stringify(info) : null);
			this._filterSortInfo[id] = info;
			if (refresh === true) {
				this._filterSortRefresh();
			}
		},
		searchRefresh: function() {
			this._filterSortRefresh();
		},
		searchInfoRead: function() {
			// Like it's a query lookup we assume that field's name is $resources
			// We need to know the id of array to apply the search clause at page loading when we restore the context (detail to list)
			if (!this._filterSortAllowed()) return;
			var field = this.getControlByBind("$resources");
			if (!field || !field.searchInfoGet) return null;
			var info = field.searchInfoGet();
			if (info == null || info.length == 0) return null;
			return info;
		},
		_filterSortRefresh: function() {
			if (!this._filterSortAllowed()) return;
			var ctrlArray = this.getControlByBind("$resources");
			if (!ctrlArray) return;
			var attrs = {
				"data-control-id": ctrlArray.id,
				"data-nav-target": this.isVignette ? "vignette" : "application",
				"data-nav-type": "filtersort"
			};
			// Set original URL - Remove pagination - Ex we change the filter/sort criteria in a pagination 
			this._initSdataInfo(null);
			eventListener.triggerRefreshPage(ctrlArray.$$elmt, attrs);
		},
		/**
		 * Only for query and lookup in current version
		 */
		_filterSortAllowed: function() {
			return this.prototype.isLookup() || this.prototype.isQuery();
		},
		_filterInfoSaveId: function(type) {
			if (!this._filterSortAllowed()) return;
			if (!this._filtersortUrlId) {
				this._filtersortUrlId = this._originalSdataUrl;
			}
			var id = this._filtersortUrlId + "#" + type;
			if (this.isVignette && this.getParentVignette()) {
				var vid = this.getParentVignette().vignetteId;
				if (vid) {
					id = vid + "#" + id;
				}
			}
			return id;
		},

		/*
		 * Check if sort or filter has changed
		 * This is just to detect changes to trigger a page reload
		 * If e.g. sort criterias are not change, the page will not be reloaded
		 */
		_filterSortEquals: function(type, info, old) {
			if (info == null || old == null) return true;
			if (type == "sort") {
				if (old.length != info.length) return false;
				for (var i = 0; i < info.length; i++) {
					if (info[i].sort !== old[i].sort) return false;
					if (info[i].field !== old[i].field) return false;
				}
				return true;
			} else if (type == "filter") {
				// Filters are hard to compare because the can change and still be logically the same
				// So we always asume changed filter conditions here
				return false;
			}
		},
		_filterSortUpdateUrl: function() {
			var self = this;
			var sdataUrl = jsutils.parseURL(self.sDataUrl);
			// Add filters describe in proto - the filter is selected by the user ($isDefault === true)
			var $f = this._$filterGetInfo();
			if ($f) {
				if (!sdataUrl.query) {
					sdataUrl.query = {};
				}
				if ($f.id === "nofilter") {
					delete sdataUrl.query.filter;
				} else {
					sdataUrl.query.filter = $f.id;
				}
			}
			if (!self._filterSortAllowed()) {
				return jsutils.urlToString(sdataUrl);
			}
			// Add filter/sort clause for Lookup and Query if any
			// build sort clause
			var sortClause = null;
			var info = self.filterSortRead("sort");
			if (info != null && info.length != 0) {
				info.some(function(i) {
					if (i.sort != "none") {
						sortClause = {
							order: i.sort,
							field: i.id
						};
						return true;
					}
				});
			}
			// build filter clause
			var filterClause = '';
			info = self.filterSortRead("filter");
			if (info != null && info.length != 0) {
				$.each(info, function(idx, filter) {
					var cf = '(' + filter.id + ' ' + (filter.operator === "like_s" ? "like" : filter.operator) + ' ' + pageHelpers.setFilterRightValue(filter) + ')';
					filterClause = filterClause.length == 0 ? cf : filterClause + ' and ' + cf;
				});
			}
			// build search clause
			var searchClause = '';
			var searchInfo = self.searchInfoRead();
			if (searchInfo) {
				$.each(searchInfo, function(idx, search) {
					var cf = '(' + search.id + ' ' + search.operator + ' ' + pageHelpers.setFilterRightValue(search) + ')';
					searchClause = searchClause.length == 0 ? cf : searchClause + ' or ' + cf;
				});
				if (searchClause) {
					searchClause = '(' + searchClause + ')';
				}
			}
			// apply sort clause
			if (!sortClause && !filterClause && !searchClause) return jsutils.urlToString(sdataUrl);;
			// sdataUrl.query.key != null means it's a pagination request
			// -> The pagination request contains already the sort criteria so we don't add them
			// -> Otherwise we add sort criteria to the request
			if (sortClause && sdataUrl.query.key == null) {
				var old = sdataUrl.query.orderBy;
				sdataUrl.query.orderBy = sortClause.field + ' ' + sortClause.order;
				if (old) sdataUrl.query.orderBy = ", " + old;
			}
			// apply filter clause
			if (filterClause && sdataUrl.query.key == null) {
				var old = sdataUrl.query.where;
				sdataUrl.query.where = filterClause;
				if (old) sdataUrl.query.where = old + ' and ' + sdataUrl.query.where;
			}

			// apply search clause
			if (searchClause && sdataUrl.query.key == null) {
				var old = sdataUrl.query.where;
				sdataUrl.query.where = searchClause;
				if (old) sdataUrl.query.where = old + ' and ' + sdataUrl.query.where;
			}

			return jsutils.urlToString(sdataUrl);
		},
		_$filterGetInfo: function() {
			if (this.$filtersGet().length === 0 || this._$filtersDisabled === true) return null;
			var f = null;
			this.$filtersGet().some(function(x) {
				if (x.$isDefault === true) {
					f = x;
					return true;
				}
			});
			return f;
		},
		/**
		 * List of filters given by the prototype ($filters)
		 */
		$filtersGet: function() {
			return this._$filters;
		},
		/**
		 * Select a filter
		 */
		$filtersSelect: function(filterId) {
			if (!this._$filters) return;
			this._$filtersDisabled = false;
			this._$filters.forEach(function(f) {
				f.$isDefault = false;
				if (filterId === f.id) {
					f.$isDefault = true;
				}
			});
			this._filterSortRefresh();
		},
		/**
		 * none/tabs/list
		 * Stored in $resources array
		 */
		$filtersGetAuthoring: function() {
			var c = this.getControlByBind("$resources");
			if (c && c.$filtersGetAuthoring) {
				return c.$filtersGetAuthoring();
			}
			return null;
		},
		setDao: function(dao) {
			Base.prototype.setDao.call(this, dao);
			this._multiSelectionLinks = this._protoLinks = this._toolbarLinks = null;
		},
		getMultiSelectionLinks: function() {
			var self = this;
			if (!self.prototype.isQuery()) return null;
			if (self._multiSelectionLinks == null) {
				self._multiSelectionLinks = [];
				var $links = self.getProtoLinks(),
					info, link;
				if ($links) {
					var actSettings;
					$.each($links, function(name, value) {
						if (!pageHelpers.checkLink(name, value) || value.$url == null || value.$url.length == 0) {
							return;
						}
						// Multiselection is given by authoring waiting for having this flaging the prototype
						actSettings = self.actionGetSettings(name);
						if (actSettings == null || (actSettings.options != null && actSettings.options.multiselection !== true)) {
							return;
						}
						info = $.extend({}, link, value);
						info.css = (info.css || "") + " s-m-ismultisel";
						if (actSettings && actSettings.icon != null) {
							info.icon = actSettings.icon.css;
						}
						self._multiSelectionLinks.push(info);
					});
				}
			}
			return self._multiSelectionLinks.length == 0 ? null : self._multiSelectionLinks;
		},
		/**
		 * onlyFooterHeader		true: 	take into account links with footerHeader property == true (defined by authoring on actions)
		 * onlyFooterHeader		false:	take into account all links
		 */
		hasFooterHeaderActions: function(onlyFooterHeader) {
			var tl = this.getToolbarLinks(globals.getSiteLayout().getDeviceType() === "smartphone" ? "header" : "footer");
			if (tl.length === 0) return false;
			if (onlyFooterHeader === true) {
				for (var i = 0; i < tl.length; i++) {
					if (tl[i].footerHeader === true) return true;
				}
				return false;
			} else {
				return tl.length > 0;
			}
		},
		/**
		 * Accept getProtoLinks("$query", $details"...)
		 */
		getProtoLinks: function() {
			var self = this;
			if (self._protoLinks == null) {
				var $links = $.extend(true, {}, self.prototype.data("$links", null, true), self.dao ? self.dao.getValue("$links") : null);
				self._protoLinks = {};
				var info, sdataInfo;
				if (this.prototype.isQuery()) {
					// This code is disabled - It adds the actions tied to the $resources for queries
					var queryLinks = this.prototype.getDataByPath("$properties.$resources.$item.$links");
					if (queryLinks) {
						$.extend(true, $links, queryLinks);
					}
				}
				$.each($links, function(name, info) {
					if (!pageHelpers.checkLink(name, info)) {
						return;
					}
					info.name = name;
					info.title = info.$title ? self.prototype.resolveExpression(info.$title) : "";
					info.icon = fontUtils.getIconByName(name);
					if (info.$type == null || info.$type.length !== 0 || info.$type === "application/json;vnd.sage=syracuse") {
						if (info.$url) {
							info.$parameters && $.each(info.$parameters, function(paramName, paramValue) {
								// PARAMETER_ESCAPING
								// If there are placeholders in a parameters value, we try to resolve them here
								// In any case, the result is encoded to ensure sdataUtils.getLinkInfo will not fail if there
								// are non valid characters in the url
								// As a result, in multiselection, eventually left over encoded placeholders need to be
								// unescaped and replaced later in the process (see multiSelectionMgr.js -> PARAMETER_ESCAPING)
								if (paramValue.indexOf("{") > -1 && self.dao) {
									var pv2 = self.prototype.resolveExpression(paramValue, self.dao);
									if (pv2 && pv2.length > 0) {
										paramValue = encodeURIComponent(pv2);
									} else {
										paramValue = encodeURIComponent(paramValue);
									}
								}
								info.$url = info.$url.replace("{" + paramName + "}", paramValue);
							});
							var urlParsed = self.prototype.resolveExpression(info.$url, self.dao, false, true);
							if (urlParsed.indexOf("/mobile1/") > -1) { // mobile1 means it's an sdata request
								sdataInfo = sdataUtils.getLinkInfo(info.$url, self.dao, true);
								if (!sdataInfo) return;
								$.extend(info, sdataInfo);
								if (info.$services) {
									info.$isAction = true;
								}
							} else {
								// Free type link (for maps)
								info.externalUrl = info.$url;
							}
						} else {
							// Force notification
							info.$isAction = true;
						}
						if (info.$uuid == null) {
							info.$uuid = utils.UUID();
						}
						info.css = info.css || [];
						if (info.$isHidden === true) info.css.push("hidden");
						if (info.$isDisabled === true) info.css.push("disabled");
						info.css = info.css.join(' ');
						self._protoLinks[name] = info;
						return;
					}
				});
			}
			if (arguments.length == 0) {
				return $.isEmptyObject(self._protoLinks) ? null : self._protoLinks;
			}
			var res;
			for (var i = 0; i < arguments.length; i++) {
				if (self._protoLinks[arguments[i]]) {
					if (res == null) res = {};
					res[arguments[i]] = self._protoLinks[arguments[i]];
				}
			}
			return res;

		},
		/**
		 * Return an array of link info according to toolbar
		 *		toolbar - can be "header", "footer", "actionpanel"
		 * !!! There's a hack in \lib\sdataStatelessHack._js that transform the original proto to put $actions in $links
		 * 		Set a $isAction = true for actions (false for $links)
		 */
		getToolbarLinks: function(toolbar, options) {
			var self = this;
			options = options || {};
			if (!self.dao) {
				// non regular pages
				return [];
			}
			if (self._toolbarLinks == null) self._toolbarLinks = {};
			var device = globals.getSiteLayout().getDeviceType();
			var facet = self.prototype.getFacet();
			var key = toolbar + device + facet;
			if (self._toolbarLinks[key]) return self._toolbarLinks[key];
			var links = self._toolbarLinks[key] = [];
			var $links = self.getProtoLinks();
			if ($links) {
				var lMap = pageHelpers.getLinkMap(toolbar, device, facet);
				var authSettings, forceFooterHeader;
				$.each($links, function(name, value) {
					// authSettings -> {multiselection:true/false, authSettings.footerHeader:true/false}
					authSettings = self.actionGetSettings(name) || {};
					if (!$.isEmptyObject(authSettings)) {
						// Customized icon - we clone value - Todo not needed ?
						value = $.extend(true, {}, value);
						if (authSettings.icon != null) {
							value.icon = authSettings.icon.css;
						}
						value.footerHeader = authSettings.options != null && authSettings.options.footerHeader === true;
					}
					// multiselection action are not displayed in panel or footer/header - Managed by multiselection manager
					if (authSettings.options && authSettings.options.multiselection === true) return;
					// forceFooterHeader only for tablet - TODO see how we could add action in smartphone header
					forceFooterHeader = value.footerHeader && (device !== "smartphone");
					if (forceFooterHeader !== true && toolbar !== "actionpanel" && !lMap[name]) {
						return;
					}
					if (toolbar === "actionpanel" && pageHelpers.excludeFromPanel(name, forceFooterHeader, value, facet)) {
						return;
					}
					links.push(value);
				});
			}
			return links;
		},
		getEmptyDao: function(proto) {
			return daoSdata.emptyDao(proto);
		},
		/**
		 * !! Must always returns a promise (see checkBack in cancelEdit)
		 */
		checkBack: function() {
			return this._draftMgr ? this._draftMgr.checkBack() : $.smResolve(true);
		}
	});

exports.Page = _Page;
});

define('syracuse-tablet/html/js/pages/pageRequest',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/pages/pageRegular'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/pages/pageRegular').Page;

/**Temporarily - exclude fields other than $resources
 *
 */
var _hideUnusedFields = function(proto) {
	var props = proto.data("$properties");
	if (!props) return proto;
	for (var p in props) {
		props[p]["$isExcluded"] = (p !== "$resources");
	}
	return proto;
};
/**
 * Request page/controller
 * Used for requests and statistics to hide all controls except the chart or table
 */
var _Klass = utils.defineClass(
	function RequestPage($parent, state, prototype, article, options) {
		Base.call(this, $parent, state, _hideUnusedFields(prototype), article, options);
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
		}

	});

exports.Page = _Klass;
});

define('syracuse-tablet/html/js/pages/pageRowDetail',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/pages/pageRegular'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/pages/pageRegular').Page;

/**
 * Child page that displays row detail in edit and details mode
 */
var _Page = utils.defineClass(
	function RowDetailPage($parent, state, prototype, article, parentPage, options) {
		this.parentPage = parentPage;
		if (this.parentPage.state.type === "rowdetail") {
			this.mainPageId = this.parentPage.mainPageId;
		} else {
			this.mainPageId = this.parentPage.state.uuid;
		}
		if (!this.parentPage) throw new Error("rowdetail page - Unexpected empty parent page");
		/** Set parentpage before **/
		Base.call(this, $parent, state, prototype, article, options);
		// Activity and facet - This page has no url
		this.setActivity(this.parentPage.$activity);
		// Disabled temporarily
		this.enableWorkingCopy = false;
	}, Base, {

		_initSdataInfo: function(sdataUrl, sdataMethod) {
			// nothing no sdataUrl
		},

		destroy: function() {
			if (this.destroyed) return;
			Base.prototype.destroy.call(this);
			this.parentPage = null;
			this._notifData = null;
			if (this._originalDao) {
				this._originalDao.destroy();
				this._originalDao = null;
			}
		},

		isEditMode: function() {
			return this.parentPage && this.parentPage.isEditMode();
		},
		/**
		 *  Modify title for dvlp tests
		 */
		buildHtmlOption: function(loadOptions) {
			return Base.prototype.buildHtmlOption.call(this, loadOptions).
			then(function(opts) {
				opts.toolBars.showHome = true;
				return opts;
			});
		},
		/**
		 * Click on home in footer/header
		 * -> Goto main parent page
		 */
		_actHome: function() {
			if (!this.parentPage) return;
			if (this.isVignette) {
				this.getParentVignette().goHome();
			} else {
				var self = this;
				globals.getApplication().goBack(function(state) {
					// returns true if state.uuid is the main page
					// Click on home returns to the main page (not to application home)
					return state.uuid === self.mainPageId;
				});
			}
		},

		/**
		 * this.state.options.dataParams is an object that gives:
		 * 	rowId:	id of the row - empty if creation
		 *  activity:	"create/edit/detail" if it's a creation
		 */
		loadData: function(loadOptions) {
			if (loadOptions.reload) {
				if (!this._originalDao) {
					return;
				}
				this.setDao(this._originalDao.clone());
				return $.smResolve();
			}
			// We get the row DAO - !!! Do not store parentPage
			var ctrl = this.parentPage.getControl(this.state.options.controlId);
			if (!ctrl) throw new Error("rowdetail page - Array datasource not found");
			// Dao of the row to display - dao is calculated by the array when user click on action 'rosDetail'
			var info = ctrl.rowDetailGetInfo();
			if (!info.dao) throw new Error("rowdetail page - Row data not found");
			// Activity is given by array (info)
			// E.g. if we create an expense we have a not empty 'dimension type array' returned by the server.
			// We are able to edit the row to modify the content so it's an edit activity (not a create like this.parentPage.$activity)
			// Create adds a new line in the array / edit modifies
			this.setActivity(info.activity);
			if (this.$activity !== "read") {
				// For the reload we need to keep a copy to restore it
				this._originalDao = info.dao;
				this.setDao(info.dao.clone());
			} else {
				this.setDao(info.dao);
			}
			// For single arrays we need idx to update parent on save  because there's no uuid in dao
			this.singleArrayRowIdx = info.singleArrayRowIdx;
			return $.smResolve();
		},
		/**
		 * Process action
		 */
		notifActionLink: function(success, link, result, options) {
			switch (link.name) {
				case "$save":
					this._doActSave(success, link, options);
					break;
				case "$delete":
					this._doActDelete(success, link, options);
					break;
				case "$canceledit":
					this.goBack();
					break;
				default:
					// Call the regular process
					Base.prototype.notifActionLink.call(this, success, link, result, options);
					break;
			}
		},
		/**
		 * Validate data before sending an action
		 */
		validateBeforeActionLink: function(link) {
			return this.checkControlsData();
		},
		_doActSave: function(success, link, responseJSON, options) {
			if (success) {
				// Check if the row is still in error - If we change the value of a field in error it resets the error status
				this.dao.checkArrayUpdateError();
				// Notify parent to update its dao
				this._notifData = {
					notifId: "sm.rowdetail.update",
					notifData: {
						dao: this.dao,
						activity: this.$activity,
						singleArrayRowIdx: this.singleArrayRowIdx
					}
				};
				// To not destroy them because we need them in parent page to update parent page dao
				// Destroyed by parent page
				this.dao = null;
				this.prototype = null;
				this.goBack();
			}
		},
		_doActDelete: function(success, link, responseJSON, options) {
			// Stores data for parent which will be notified before closing the child page
			this._notifData = {
				notifId: "sm.rowdetail.delete",
				notifData: {
					uuid: this.dao.getValue("$uuid")
				}
			};
			this.goBack();
		},
		/**
		 * Return data for parent
		 */
		getParentNotif: function() {
			if (this._notifData) {
				//ID of parent page
				this._notifData.parentId = this.state.options.parentId;
				// Notify parent to update its dao
				this._notifData.controlId = this.state.options.controlId;
				return this._notifData;
			}
		}
	});

exports.Page = _Page;
});

define('syracuse-tablet/html/js/helpers/userPrefs',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/storage/localStorage','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var localStorage = require('syracuse-tablet/html/js/storage/localStorage');
var globals = require('syracuse-tablet/html/js/helpers/globals');

var _Klass = utils.defineClass(function userPrefs(type, id) {
	this._id = id;
	this._type = type;
}, null, {
	destroy: function() {},
	_read: function() {
		var info = localStorage.getItem(this._getStorageId());
		if (!info) return null;
		try {
			return JSON.parse(info);
		} catch (e) {};
		return null;
	},
	_getStorageId: function() {
		return globals.getUserCtx().$user + "_" + this._id + "_" + this._type;
	},
	getPrefs: function() {
		return this._read(this) || {};
	},
	savePrefs: function(opts) {
		var prefs = null;
		if (opts !== null) {
			var prefs = this.getPrefs();
			for (var p in opts) {
				prefs[p] = opts[p];
			}
		}
		localStorage.setItem(this._getStorageId(), prefs ? JSON.stringify(prefs) : null);
	},
	reset: function(opts) {
		this.savePrefs(null);
	}
});

exports.createUserPrefs = function(type, id) {
	return new _Klass(type, id);
};
});

define('syracuse-tablet/html/js/controls/chart/chartsUtils',['require','exports','module'],function (require, exports, module) {"use strict";

var _getChartDetailArticle = function(opt, $bind, chartArticle, arrayArticle) {
	opt = opt || {};
	// !! set opts with the right values - used by caller
	opt.display = opt.display || "bothSideToSide";
	opt.style = opt.style || (chartArticle ? chartArticle.$style : "bar");
	if (!chartArticle) {
		chartArticle = {
			"$bind": $bind,
			// Use this property name to be compliant with existing authoring - False identify the chart control
			"$forceArray": false,
			"$isTitleHidden": true,
			"$arrayOptions": {}
		};
	} else {
		chartArticle = $.extend(true, {}, chartArticle);
	}
	if (!chartArticle.$display) {
		// If no authoring
		chartArticle.$display = "chart";
	}
	chartArticle.$arrayOptions = chartArticle.$arrayOptions || {};
	// Pagination only if alone
	chartArticle.$arrayOptions.showPagination = opt.display === "chartOnly";
	if (!arrayArticle) {
		arrayArticle = {
			"$bind": $bind,
			// Use this property name to be compliant with existing authoring - True identify the chart control
			"$forceArray": true,
			"$isTitleHidden": true,
			"$arrayOptions": {}
		};
	} else {
		arrayArticle = $.extend(true, {}, arrayArticle);
	}
	if (!arrayArticle.$display) {
		// If no authoring
		arrayArticle.$display = "table";
	}
	if (!arrayArticle.$arrayOptions) {
		arrayArticle.$arrayOptions = {};
		// Show pagination by default
		arrayArticle.$arrayOptions.showPagination = true;
	}
	var res;
	// $isHidden = false -> keeps the control in page to be able to preserve article
	chartArticle.$isHidden = arrayArticle.$isHidden = false;
	switch (opt.display) {
		case "chartOnly":
			arrayArticle.$isHidden = true;
			res = {
				"$layoutType": "stack",
				"$items": [{
					"$layoutType": "row",
					"$items": [chartArticle, arrayArticle]
				}]
			};
			break;
		case "arrayOnly":
			chartArticle.$isHidden = true;
			res = {
				"$layoutType": "stack",
				"$items": [{
					"$layoutType": "row",
					"$items": [arrayArticle, chartArticle]
				}]
			};
			break;
		case "bothStacked":
			res = {
				"$layoutType": "stack",
				"$items": [{
					"$layoutType": "row",
					"$items": [chartArticle, arrayArticle]
				}]
			};
			break;
		default:
			res = {
				"$layoutType": "stack",
				"$items": [{
					"$layoutType": "row",
					"$items": [{
						"$layoutType": "cell",
						"$widthAll": "6",
						"$sameSize": true,
						"$bgColor": "transparent",
						"$items": [chartArticle]
					}, {
						"$layoutType": "cell",
						"$widthAll": "6",
						"$sameSize": true,
						"$bgColor": "transparent",
						"$items": [arrayArticle]
					}]
				}]
			};
			break;
	}
	// Pass the display info to the page - needed to set the tool bar
	chartArticle.$style = opt.style;
	// Pass the display info to the page - needed to set the tool bar
	res.$display = opt.display;
	return res;
};
var _getChartDetailArticlePropertyName = function(level) {
	return (level > 1) ? ("$chartDetail_" + level) : "$chartDetail";
};
exports.getChartDetailArticlePropertyName = _getChartDetailArticlePropertyName;
exports.getChartDetailArticle = _getChartDetailArticle;
});

define('syracuse-tablet/html/js/pages/pageChartDetail',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/pages/pageRegular','syracuse-tablet/html/js/controls/ctrlFactory','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/userPrefs','syracuse-tablet/html/js/controls/chart/chartsUtils','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/pages/pageRegular').Page;
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var userPreferences = require('syracuse-tablet/html/js/helpers/userPrefs');
var chartsUtils = require('syracuse-tablet/html/js/controls/chart/chartsUtils');

var notifications = require('syracuse-tablet/html/js/helpers/notifications');


/**
 * Child page that displays chart detail
 */
var _Page = utils.defineClass(
	// Name ChartDetailPage used for instanceof
	function ChartDetailPage($parent, state, prototype, article, parentPage, options) {
		if (globals.isAuthoringActive()) {
			options.header = false;
			options.footer = false;
			options.breadcrumbs = false;
		}
		// For parent page to create the container
		options.topToolbar = true;
		if (!article.$display) {
			article.$display = "bothSideToSide";
		}
		this.parentPage = parentPage;
		if (!this.parentPage) throw new Error("chartdetail page - Unexpected empty parent page");
		Base.call(this, $parent, state, prototype, article, options);
		// Preference id is passed by parent control 
		this._userPrefs = userPreferences.createUserPrefs("toolbar", state.options["dataParams"]);
	}, Base, {

		destroy: function() {
			if (this.destroyed) return;
			Base.prototype.destroy.call(this);
			this.parentPage = null;
			this._notifData = null;
			if (this._userPrefs) {
				this._userPrefs.destroy();
				this._userPrefs = null;
			}
		},
		/**
		 * Create the toolbar
		 */
		createPageControl: function(id) {
			if (id === "topToolbar") {
				return globals.isAuthoringActive() ? null : ctrlFactory.createPageControl("topToolbarChartDetail", this);
			}
			return ctrlFactory.createPageControl(id, this);
		},
		buildHtmlOption: function(loadOptions) {
			if (loadOptions) {
				// No need to send a request - data are in the cache because already read by the dashboard
				loadOptions.updateLayout = (this.state.level != null && this.state.level > 1) ? false : true;
			}
			return Base.prototype.buildHtmlOption.call(this, loadOptions).then(function(opts) {
				return $.extend(true, {}, opts, {
					toolBars: {
						showAuthoring: false,
						showUserMenuLinks: true,
						showHome: true,
						showActions: false,
						statusPinPage: false
					}
				});

			});
		},
		afterRender: function(loadOptions, buildOpts) {
			var self = this;
			return Base.prototype.afterRender.call(this, loadOptions, buildOpts).then(function() {
				var chart = self.getChart();
				var array = self.getArray();
				if (chart && chart.article.$isHidden === false && array && array.article.$isHidden === false) {
					// Both controls are
					array.paginAddSynchro(chart);
				}
			});
		},
		/**
		 * Page is visible
		 */
		activated: function() {
			var opts = {
				display: this.article.$display,
				style: this.getChart().article.$style
			};
			notifications.publish("sm.chartdetail.updt.toolbar", opts);
		},
		/**
		 * Return data for parent
		 */
		getParentNotif: function() {
			if (this._notifData) {
				return {
					parentId: this.state.options.parentId,
					controlId: this.state.options.controlOriginId || this.state.options.controlId,
					notifId: "sm.updt.chart.detail.article",
					notifData: this._notifData
				};
			} else if (this.parentPage && this.parentPage.isVignette) {
				/**
				 * #6843
				 * Multiple charts in dashboards
				 * If we click on a chart detail before all the charts have been loaded the size of the charts could be wrong
				 * --> because chart in dashboard could be rendered while the chartDetail page is loading
				 * So when the chartDetail is closed it publishes this notification to allow the charts in parent's dashboard to check the height
				 */
				return {
					// no parentId is provided because we want to notify all the nested pages in the dashboard
					notifId: "sm.updt.chart.dashboard",
					notifData: this.state.options.parentId
				};
			}
			return null;
		},
		scrollAllowed: function() {
			return true;
		},

		getChart: function() {
			return this._findArrayCtrl(true);
		},
		getArray: function() {
			return this._findArrayCtrl(false);
		},
		getControl: function(controlId) {
			var control = this._controlsMap && this._controlsMap[controlId];
			if (control) return control;
			if (this.parentPage) return this.parentPage.getControl(controlId);
			return null;
		},
		_findArrayCtrl: function(chartDisplay) {
			var self = this;
			var res;
			this.forEachControl(function(id, ctrl) {
				if (jsutils.isInstanceOf(ctrl, "CtrlArrayChart") && (chartDisplay ? ctrl.isHighChart() : !ctrl.isHighChart())) {
					res = ctrl;
					return true;
				}
			});
			return res;
		},
		_actSaveChartDetail: function() {
			this._notifData = {};
			this._notifData.article = $.extend(true, {}, this.article);
			this._notifData.level = this.state.level == null ? 0 : this.state.level;
			// Do not create redundant data here on save, the separated information can be extracted also shortly before rendering
			// Also, the change below broke existing page definitions because json changed completely
			// --- old comment below here ---
			// We save the chart article and the array article to be able to rebuild the chartDetail layout (which is fixed sideToSie, chartOnly, arrayOnly)
			//this._notifData.article.$chartArticle = $.extend(true, {}, this.getChart().article);
			//this._notifData.article.$arrayArticle = $.extend(true, {}, this.getArray().article);

			globals.getApplication().goBack();
		},
		authUpdateLayout: function(article, vignetteToUpdt) {
			// Clear preferences in order to see the changes when we exit authoring
			// Otherwise the preferences will override the authoring
			this._userPrefs.savePrefs(null);
			return Base.prototype.authUpdateLayout.call(this, article);
		},
		_setDisplay: function() {
			var chart = this.getChart();
			var array = this.getArray();
			if (!chart || !array) return false;
			// If authoring we take the article of the controls chart and array and force display to bothside2side
			var prefs = this._userPrefs.getPrefs();
			var opts = {
				display: prefs ? prefs.display : null,
				style: prefs ? prefs.style : null
			};
			// Create structure article (chart) by using the article of the controls to preserve authoring 
			var article = chartsUtils.getChartDetailArticle(opts, chart.$bind, chart ? chart.article : null, array ? array.article : null);
			// Copy the properties specific to the page article - e.g $display..
			for (var p in this.article) {
				if (p != "$layoutType" && p != "$items") {
					article[p] = this.article[p];
				}
			}
			// Update layout
			var self = this;
			var pagingInfo;
			if (array && array.article.$isHidden === true) {
				pagingInfo = chart.paginGetInfo();
			} else {
				pagingInfo = array.paginGetInfo();
			}
			Base.prototype.authUpdateLayout.call(this, article).then(function() {
				notifications.publish("sm.chartdetail.updt.toolbar", opts);
				if (pagingInfo && pagingInfo.currentIdx > 0) {
					self.getChart().paginSetInfo(pagingInfo);
					self.getArray().paginSetInfo(pagingInfo);
				}
			});
			return true;
		},
		actToolbarSetDisplay: function(opts) {
			if (globals.isAuthoringActive()) return;
			this._userPrefs.savePrefs(opts);
			this._setDisplay();
		}
	});

exports.Page = _Page;
});

define('syracuse-tablet/html/js/pages/pageCardDesign',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/pages/pageRegular','syracuse-tablet/html/js/application/daoSdata'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/pages/pageRegular').Page;
var daoSdata = require('syracuse-tablet/html/js/application/daoSdata');

/**
 * Child page that displays card detail for design
 */
var _Page = utils.defineClass(
	function CardDesignPage($parent, state, prototype, article, parentPage, options) {
		options.header = false;
		options.footer = false;
		options.breadcrumbs = false;
		if (!parentPage) throw new Error("carddesign page - Unexpected empty parent page");
		this.parentPage = parentPage;
		Base.call(this, $parent, state, prototype, article, options);
	}, Base, {

		_initSdataInfo: function(sdataUrl, sdataMethod) {
			// nothing no sdataUrl
		},

		destroy: function() {
			if (this.destroyed) return;
			Base.prototype.destroy.call(this);
			this.parentPage = null;
			this._notifData = null;
			this._row = null;
		},
		buildHtmlOption: function(loadOptions) {
			return Base.prototype.buildHtmlOption.call(this, loadOptions).
			then(function(opts) {
				opts.toolBars.showHome = true;
				opts.cardDesign = true;
				return opts;
			});
		},
		isEditMode: function() {
			return false;
		},

		loadData: function(loadOptions) {
			// We get the row DAO - !!! Do not store parentPage
			var ctrl = this.parentPage.getControl(this.state.options.controlId);
			if (!ctrl) throw new Error("cardDesign page - Array datasource not found");
			var dao;
			if (ctrl.getArrayData() && ctrl.getArrayData().$resources.length > 0) {
				if (!this._row) {
					// We store to keep the same record when we change an authoring property
					this._row = ctrl.getRowById(ctrl.$$elmt.find(".s-m-record.s-m-auth-rec-selected").attr("data-params"));
					this._row = this._row ? this._row.row : ctrl.getArrayData().$resources[0];
					this._row = $.extend(true, {}, this._row.data);
				}
				dao = new daoSdata.Dao(this._row, this.prototype, {
					parent: null,
					$bind: "carddesign"
				});
			} else {
				dao = ctrl.getArrayEmptyRow(this, ctrl.prototype, "carddesign", ctrl.getDao());
			}
			this.setDao(dao);
			return $.smResolve();
		},
		/**
		 * Return data for parent
		 */
		getParentNotif: function() {
			if (this._notifData) {
				return {
					parentId: this.state.options.parentId,
					controlId: this.state.options.controlId,
					notifId: "sm.updt.card.article",
					notifData: this._notifData
				};
			}
			return null;
		},
		_actSaveCardDesign: function() {
			this._notifData = {};
			this._notifData.article = $.extend(true, {}, this.article);
			globals.getApplication().goBack();
		}
	});

exports.Page = _Page;
});

define('syracuse-tablet/html/js/pages/pageLookup',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/pages/pageRegular'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/pages/pageRegular').Page;

var _noDataHtml = '	<br><br><br>\
					<h3 class="alert alert-info" style= "text-align:center" role="alert">\
					No data\
					</h3>\
					<br>\
					<div  style= "font-size:xx-large;text-align:center">\
					<a draggable="false" href="#" data-action="lookupBack" class="fa fa fa-arrow-circle-o-left" style="display: inline-block;"/>\
					</div>';
/**
 * Lookup page that handles selection
 * TODO - eventually if we have to merge wit regular page later
 */
var _Page = utils.defineClass(
	function LookupPage($parent, state, prototype, article, options) {
		options.footer = false;
		Base.call(this, $parent, state, prototype, article, options);
		this.selectedRowJson = null;
	}, Base, {

		destroy: function() {
			if (this.destroyed) return;
			Base.prototype.destroy.call(this);
			this.selectedRowJson = null;
		},
		buildHtmlOption: function(loadOptions) {
			return Base.prototype.buildHtmlOption.call(this, loadOptions).
			then(function(opts) {
				opts.toolBars.showBack = true;
				return opts;
			});
		},
		/**
		 * sm-select-row notification event - Do not call super (Page) because we just need to store the rowDao and close the page
		 * Data selected will be passed to parent page by pageLoader via standard parent notification process - getParentNotif
		 * {data, proto} - data: selected JSON data - proto - prototype of rrow data
		 */
		notifSelectRow: function(arrayId, rowId, data) {
			if (!data) return;
			// Clone JSON because array dao is destroyed with the page
			this.selectedRowJson = data;
			this._actLookupBack();
		},
		afterRender: function(loadOptions, buildOpts) {
			var self = this;
			return Base.prototype.afterRender.call(self, loadOptions, buildOpts).then(function() {
				// Check if array is empty
				var c = self.forEachControl(function(id, c) {
					return c.$type === "application/x-array";
				});
				if (c && c.isEmpty == true) {
					self.$$elmt.html(_noDataHtml);
				}
			});
		},
		/**
		 * getParentNotif method is called by pageLoader to notify parent page
		 */
		getParentNotif: function() {
			if (!this.selectedRowJson) return null;
			return {
				parentId: this.state.options.parentId,
				controlId: this.state.options.controlId,
				notifId: "sm.lookup.selection",
				notifData: this.selectedRowJson
			};
		},
		_actLookupBack: function() {
			this.goBack();
		}
	});

exports.Page = _Page;
});

define('syracuse-tablet/html/js/pages/pageHtml',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/pages/page'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var prototype = require('syracuse-tablet/html/js/helpers/prototype');
var Base = require('syracuse-tablet/html/js/pages/page').Page;


var _Page = utils.defineClass(

	function HtmlPage($$parent, state, options) {
		Base.call(this, $$parent, state, prototype.create(state.$prototype), state.$article, options);
	}, Base, {

		afterRender: function(loadOptions, buildOpts) {
			var self = this;
			return Base.prototype.afterRender.call(self, loadOptions, buildOpts).then(function() {
				self.$$htmlRoot = self.rootLayout.$$elmt;
				self.appendHtml(self.$$htmlRoot, buildOpts);
			}).then(function() {
				uiUtils.triggerResizeInternal();
			});
		},
		/**
		 * Append html to the root layout $$elmt
		 */
		appendHtml: function($$parent, buildOpts) {

		}
	});

exports.Page = _Page;
});

define('syracuse-tablet/html/js/init/initLogin',['require','exports','module','syracuse-tablet/html/js/application/authentication','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/init/initContext','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/sdata/sdataCommonResources'],function (require, exports, module) {"use strict";

var auth = require('syracuse-tablet/html/js/application/authentication');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var initContext = require('syracuse-tablet/html/js/init/initContext');
var native = require('syracuse-tablet/html/js/helpers/native/native');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("initLogin");
var sdataCommonRes = require('syracuse-tablet/html/js/sdata/sdataCommonResources');
var nativeApp = native.getModule("nativeApp");
var nativeVoiceCommands = native.getModule("voiceCommands");

var _readRestoredContext = function(fromInitProcess) {
	if (fromInitProcess && nativeVoiceCommands && nativeVoiceCommands.hasPendingCommand("openBookmark")) {
		// No context is restored because there's a pending voice command triggered by the native wrapper
		// This command provides a context that is restored once application is ready (see application.notifUserLoggedIn)
		// The list of commands is not available when _notifLoggedIn is called
		return $.smResolve();
	}
	var ctxUuid = jsutils.getUrlContextId();
	var step;
	if (ctxUuid) {
		// Url context (email link) - We first read the context stored in syracuse
		step = sdataCommonRes.readSharedContext(ctxUuid);
	} else {
		step = $.smResolve();
	}
	return step.then(function(urlCtxToRestore) {
		var contextToRestore;
		if (urlCtxToRestore) {
			contextToRestore = urlCtxToRestore;
			// Url context (email link)
			contextToRestore.type = "url";
		} else if (nativeApp) {
			// Context provided by native wrapper
			contextToRestore = nativeApp.getReconnectContext();
			if (contextToRestore) {
				contextToRestore.type = "native";
			}
		}
		return contextToRestore;
	});
};
/**
 * Resolves with true if user is logged in or false if login is required
 * Notified after login request succeeded
 * -> Set the context according to contextToRestore or userProfile
 * -> If Ok set the current page (welcome application) and resume with true
 * -> If not Of resume with false
 * offlineLogin:	true if offline login
 * fromInitProcess	true if login occurred after initialization of the application
 */
var _notifLoggedIn = function(userProfile, offlineLogin, fromInitProcess) {
	if (!userProfile) {
		return $.smReject({
			$redirectPage: "login"
		});
	}
	// Mandatory here - Can be modified in initcontext (dialog)
	globals.setUserProfile(userProfile);
	return _readRestoredContext(fromInitProcess).then(function(contextToRestore) {
		if (fromInitProcess !== true && nativeApp) {
			log && log("Getting reconnect token");
			// Get ask for the reconnection token after login action to save it
			return auth.reconnectGetToken().then(function(token, userLogin) {
				// Stores the new reconnection token
				log && log("Getting reconnect token: " + token, userLogin);
				nativeApp.setReconnectToken(token, userLogin);
				return contextToRestore;
			});
		}
		return contextToRestore;
	}).then(function(contextToRestore) {
		globals.setNeedToCheckAppsList(true);
		//contextToRestore passed to be checked
		return initContext.init(false, contextToRestore, offlineLogin);
	}).then(function(contextToRestore) {
		// contextToRestore checked (endpoint, role..) and set to null if not valid
		notifications.publish("sm.user.logged.in", fromInitProcess, contextToRestore);
	});
};
/**
 * Resolves with true if user is logged in or false if login is required
 * Rejects if error
 */
exports.init = function() {
	/**
	 * reconnectToken is used to skip login if session is still alive
	 * Used by native wrapper when application resumed - See also notifLogin
	 */
	var step;
	var reconnectToken = nativeApp ? nativeApp.getReconnectToken() : null;
	if (reconnectToken) {
		// Call a request that sets the session cookie to reconnect Syracuse server
		step = auth.reconnectSetToken(reconnectToken);
	} else {
		step = $.smResolve();
	}
	var def = $.Deferred();
	step.then(function() {
		return auth.checkAvailableAuthentications();
	}).then(function(auths) {
		// Resolves with userProfile if user authenticated or null if 401 only
		return auth.check();
	}).then(function(profile) {
		if (profile) {
			// userProfile!= null if connection OK - userProfile == null to force login
			_notifLoggedIn(profile, false, true).then(function() {
				def.resolve(true);
			}).fail(function(e) {
				def.reject(e);
			});
		} else {
			def.resolve(false);
		}
	}).fail(function(e) {
		if (!e) e = {};
		e.$redirectPage = "login";
		// This is a real error other than 401
		def.reject(e);
	});
	return def.promise();
};
exports.notifLoggedIn = _notifLoggedIn;
});

define('syracuse-tablet/html/js/pages/pageLogin',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/pages/pageHtml','syracuse-tablet/html/js/application/authentication','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/application/settings','syracuse-tablet/html/js/helpers/scroller/scrollerHelpers','syracuse-tablet/html/js/init/initLogin','syracuse-tablet/html/js/application/authentication','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/pages/pageHtml').Page;
var auth = require('syracuse-tablet/html/js/application/authentication');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var settings = require('syracuse-tablet/html/js/application/settings');
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');
var initLogin = require('syracuse-tablet/html/js/init/initLogin');
var auth = require('syracuse-tablet/html/js/application/authentication');
var nativeApp = require('syracuse-tablet/html/js/helpers/native/native').getModule("nativeApp");
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var _templates = {
	main: '\
		<div class="s-m-loginform s-m-scroll-elmt" style="display:none;position: relative;">\
			<div class="row s-m-login-info">\
				<div class="col-xs-offset-1 col-xs-10 col-sm-offset-3 col-sm-6 col-md-offset-4 col-md-4 col-lg-offset-4 col-lg-4">\
					<div id="login-reason" style="display: none" class="alert alert-info" role="alert"></div>\
					<div id="login-success" style="display: none" class="alert alert-success" role="alert"></div>\
					<div id="login-fail" style="display:none;max-height:100px;overflow:hidden;" class="alert alert-danger" role="alert"></div>\
				</div>\
			</div>\
			<div id="s-m-login-online" class="row">\
				<div class="col-xs-offset-1 col-xs-10 col-sm-offset-3 col-sm-6 col-md-offset-4 col-md-4 col-lg-offset-4 col-lg-4">\
					<div class="panel panel-default">\
						<div id="s-m-login-withcookie" style="display: none;">\
							<div class="panel-body s-m-login-body">\
								<center>\
									<div id="s-m-rememberme-user-id"></div>\
								</center>\
							</div>\
							<div class="panel-body s-m-login-body">\
								<button  data-action="forgetme" type="button" class="btn btn-primary s-m-signin-btn">{{label_forgetme}}</button>\
							</div>\
							<div class="panel-body s-m-login-body" id="s-m-login-changeuser">\
								<button  data-action="changeuser" type="button" class="btn btn-primary s-m-signin-btn">{{label_changeuser}}</button>\
							</div>\
						</div>\
						<div  id="s-m-login-withoutcookie">\
							<div class="s-m-login-header main">\
								<span class="s-m-signin">{{label_signin}}</span>\
								<span class="s-m-brand">{{label_brand}}</span>\
								<span class="s-m-product">{{label_product}}</span>\
							</div>\
							<div class="panel-body s-m-login-body" id="s-m-login-basic-fields-id">\
								<br>\
								<div class="form-group">\
									<input type="text" autocorrect="off" autocapitalize="off" value="" class="form-control s-m-login-form-input" placeholder="{{label_user}}"	id="login-user">\
								</div>\
								<br>\
								<div class="form-group">\
									<input type="password" autocorrect="off" autocapitalize="off" class="form-control s-m-login-form-input" placeholder="{{label_password}}" id="login-password">\
								</div>\
								<div class="form-group">\
									<center>\
										<input type="checkbox" id="s-m-remember-me-id">{{label_rememberme}}</input>\
									</center>\
								</div>\
								<button id="login-login" data-action="login" type="button" class="btn btn-primary s-m-signin-btn">{{act_login}}</button>\
							</div>\
							<div class="s-m-login-header" id="s-m-sageid-header">\
								<span class="s-m-signin">{{sageid_label_header}}</span>\
							</div>\
							<div class="panel-body s-m-login-body" id="s-m-sageid-body">\
								<button id="s-m-sageid-signin" data-action="sageidsignin" type="button" class="btn btn-primary s-m-signin-btn">{{sageid_label_signin}}</button>\
							</div>\
						</div>\
					</div>\
				</div>\
			</div>\
			<div id="s-m-login-offline" class="row" style="display: none;">\
				<div class="col-xs-offset-1 col-xs-10 col-sm-offset-3 col-sm-6 col-md-offset-4 col-md-4 col-lg-offset-4 col-lg-4">\
					<div class="panel panel-default">\
						<div class="s-m-login-header"><span class="s-m-signin">{{label_signin}} </span> <span class="s-m-brand">{{label_brand}}</span> <span class="s-m-product">{{label_product}}</span></div>\
						<div class="s-m-login-header" id="s-m-offline-header">\
							<span class="s-m-signin">{{offline_label_header}}</span>\
						</div>\
						<div class="panel-body s-m-login-body" id="s-m-sageid-body">\
							<button id="s-m-offline-signin" data-action="offlinesignin" type="button" class="btn btn-primary s-m-signin-btn"> \
								<div id="s-m-offline-label">{{offline_label_signin_as}}</div> \
								<div id="s-m-offline-user"></div> \
							</button>\
						</div>\
					</div>\
				</div>\
			</div>\
			<div id="s-m-login-nooffline" class="row" style="display: none;">\
				<div class="col-xs-offset-1 col-xs-10 col-sm-offset-3 col-sm-6 col-md-offset-4 col-md-4 col-lg-offset-4 col-lg-4">\
					<div class="panel panel-default">\
						<div class="s-m-login-header" id="s-m-offline-header">\
								{{offline_notavail}}\
						</div>\
						<div class="panel-body s-m-login-body" id="s-m-sageid-body">\
							<div>{{offline_emptydb}}</div> \
						</div>\
					</div>\
				</div>\
			</div>\
		</div>\
	',
	message: '{{title}}<p>{{message}}</p>{{stack}}'
};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};

var lang;
var _Page = utils.defineClass(

	function LoginPage($parent, state, options) {
		options.header = false;
		options.footer = false;
		Base.call(this, $parent, state, options);
	}, Base, {

		appendHtml: function($$parent, loadOpts) {
			var self = this;

			// Add class login to add background
			self.$$elmt.addClass("login");
			var labels = locale.getProductLabels();
			var _pageContext = {
				"label_user": locale.text("login.label.user"),
				"label_password": locale.text("login.label.password"),
				"act_login": locale.text("login.label.signinaction"),
				"label_signin": locale.text("login.label.signin"),
				"label_brand": labels.brand,
				"label_product": labels.product,
				"sageid_label_header": locale.text("sageid.label.header"),
				"sageid_label_signin": locale.text("sageid.label.signin"),
				"offline_label_header": locale.text("login.label.offline"),
				"offline_label_signin_as": locale.text("login.label.login_as"),
				"offline_notavail": locale.text("login.offline.notavail"),
				"offline_emptydb": locale.text("login.offline.emptydb"),
				"label_forgetme": locale.text("login.forgetme"),
				"label_changeuser": locale.text("login.changeuser"),
				"label_rememberme": locale.text("login.rememberme")
			};
			$$parent.html(_getHtml("main", _pageContext));
			// Sage-id button
			$$parent.find("#s-m-login-online").find("#s-m-sageid-header, #s-m-sageid-body").toggle(auth.isAuthenticationAvail("sage-id"));

			var msg;
			if (self.state.options.reason) {
				if (self.state.options.isError === true) {
					msg = self.state.options.reason;
				} else {
					self._displayText($$parent.find("#login-reason"), self.state.options.reason);
				}
			}
			// Use global offline state
			var offlineState = !globals.isOnline();

			// Offline state may be overridden by the caller of the login page
			// in case the caller can determine online/offline mode more relyably (for example because he did an request just before)
			if (self.state.options && self.state.options.offlineHint != null) {
				offlineState = self.state.options.offlineHint;
			}
			self._updateStatus(msg, offlineState);
			// We listen on enter key on the basic authentication fields only for now
			// to simplify usage on android tablets
			$('#s-m-login-basic-fields-id input', self.$$elmt).on('keyup', jsutils.bindFn(self._onEnterPressed, self));
		},
		_onEnterPressed: function(e) {
			var self = this;
			if (e.which == 13 || e.keyCode == 13) {
				e.preventDefault();

				// This will check mandatory fields and set focus accordingly
				self._actLogin();
			}
		},
		_actLogin: function() {
			var self = this;
			var usr = self.$$elmt.find("#login-user").val();
			var pwd = self.$$elmt.find("#login-password").val();

			// User mandatory, so focus there
			if (usr == null || usr.length < 1) {
				self.$$elmt.find("#login-usr").focus();
				return;
			}
			// Password mandatory, so focus there
			if (pwd == null || pwd.length < 1) {
				self.$$elmt.find("#login-password").focus();
				return;
			}

			self.$$elmt.find("#login-reason").hide();
			self.waitWheelStart();

			var rememberMe = $("#s-m-remember-me-id").is(':checked');
			if (nativeApp) {
				rememberMe = true;
			}
			return settings.setLoginRememberMe(rememberMe)
				.then(function() {
					return auth.login(usr, pwd, rememberMe);
				})
				.then(function(userProfile) {
					return initLogin.notifLoggedIn(userProfile);
				}).then(function() {
					self.waitWheelStop();
				}).fail(function(e, offline) {
					self.waitWheelStop();
					self._updateStatus(e, offline);
				});
		},
		_checkMessage: function(e) {
			var self = this;
			self.message = null;
			self.stack = null;
			var diag = jsutils.convertToDiagnoses(e);
			if (diag && diag.$diagnoses && diag.$diagnoses.length > 0) {
				diag = diag.$diagnoses[0];
			}
			if (diag && diag.$message) {
				self.message = locale.textNoFail(diag.$message) || diag.$message;
				self.stack = diag.$stackTrace;
			}
			if (e && e.$redirectPage === "login") {
				if (!self.message) {
					self._displayText($("#login-reason"), locale.text("login.authentication"));
				}
			} else if (!self.message) {
				self.message = "Unexpected empty error message";
			}
			var $$fail = $("#login-fail");
			if (self.message) {
				var title = e.title ? locale.textNoFail(e.title) : (locale.text("login.failed") || "Login failed");
				// locale is not initilized in some particular cases
				self._displayText($$fail, _getHtml("message", {
					title: title,
					message: self.message || "",
					stack: self.stack || ""
				}));
			} else {
				$$fail.empty().hide();
			}
		},
		_updateStatus: function(e, forceOffLine) {
			var self = this;
			if (forceOffLine) {
				self.setOffLine(true);
			}
			if (e) {
				self._checkMessage(e);
			}
			var step;
			self._offLineProfile = null;
			if (self.isOffLine()) {
				step = settings.getLastUserProfile().then(function(profile) {
					self._offLineProfile = profile;
					return $.smResolve();
				}).fail(function(e) {
					self._checkMessage(e);
					return $.smResolve();
				});
			} else {
				/* We check if there's a loginCookie and if it is valid*/
				step = auth.reconnectGetToken().then(function(loginCookie, loginCookieUser) {
					return $.smResolve(loginCookie, loginCookieUser);
				});
			};
			step.then(function(loginCookie, loginCookieUser) {
				$("#s-m-offline-user").text("");
				if (self.isOffLine()) {
					// Offline login - Only one choice - Connect with last user profile (stored locally)
					$("#s-m-login-online").hide();
					if (self._offLineProfile) {
						$("#s-m-offline-user").text((self._offLineProfile.user.firstName || "") + " " + (self._offLineProfile.user.lastName || ""));
						$("#s-m-login-offline").show();
						$("#s-m-login-nooffline").hide();
					} else {
						// No _offLineProfile found - Occurs if cache as been cleared before offline - No data in local db
						$("#s-m-login-offline").hide();
						$("#s-m-login-nooffline").show();
					}
				} else if (loginCookie) {
					// Valid login cookie - User is 'still' connected - We ask him/her forgetMe or change user
					$("#s-m-login-offline").hide();
					$("#s-m-login-withoutcookie").hide().find(".s-m-login-header.main").hide();
					$("#s-m-login-nooffline").hide();
					$("#s-m-login-withcookie").show();
					$("#s-m-rememberme-user-id").text(locale.text("login.label.login.cookie", [loginCookieUser]));
				} else {
					// Regular login
					$("#s-m-login-online").show();
					$("#s-m-login-offline").hide();
				}
			})
				.then(function() {
					return settings.getLoginRememberMe();
				})
				.then(function(rememberMe) {
					var $$check = $("#s-m-remember-me-id");
					if (nativeApp) {
						rememberMe = true;
						$$check.closest(".form-group").hide();
					}
					$$check.attr('checked', rememberMe);
				})
				.fail(function(e) {
					self._checkMessage(e);
				});
		},
		/**
		 * Sends forgetMe request and goto login
		 */
		_actForgetme: function() {
			auth.forgetme().then(function() {
				globals.getApplication().logout("logout.msg");
			});
		},
		/**
		 * Displays user/password credentials
		 */
		_actChangeuser: function() {
			this._displayText($("#login-reason"), locale.text("login.authentication"));
			$("#s-m-login-withoutcookie").show();
			$("#s-m-login-changeuser").hide();
			// Usefull for hammer to update the scroller (better than calling notifScrollerUpdate)
			notifications.notifyController("sm.scroller.update", this);
		},
		_displayText: function($$parent, text) {
			if (!$$parent) return;
			if (!text) {
				$$parent.empty().hide();
				return;
			}
			$$parent.show().html(text.replace(/\n/g, "<br>"));
		},
		_actSageidsignin: function() {
			this.waitWheelStart();
			this.$$elmt.find("#login-reason").hide();
			auth.sageidsignin();
		},
		_actOfflinesignin: function() {
			var self = this;
			self.$$elmt.find("#login-reason").hide();
			initLogin.notifLoggedIn(self._offLineProfile, true).then(function() {
				// Nothing - Home page is opened by login notification
			}).fail(function(e) {
				self._updateStatus(e);
			});
		},
		onMainPageResize: function(info, orientation, deviceType) {
			if (this.destroyed) return;
			// Show the form before 
			this.$$htmlRoot.find("div.s-m-loginform").show();
			Base.prototype.onMainPageResize.call(this, info, orientation, deviceType);
		},
		scrollAllowed: function() {
			return true;
		},
		destroy: function() {
			Base.prototype.destroy.call(this);
		},
		isOffLine: function() {
			return Base.prototype.isOffLine.call(this) || !globals.isOnline();
		},
		/**
		 * Return always false to force to laod this page even if it's the current one (to display messaeg or manage status)
		 */
		isSamePage: function(state) {
			return false;
		}
	});

exports.Page = _Page;
});

define('syracuse-tablet/html/js/application/daoApp',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');

/**
 * Class that manage access to application DATA
 *  	appli: 		Application object
 * !!use DAO methods instead of dealing directly with JSON
 */
var _Dao = utils.defineClass(
	function(appli) {
		var self = this;
		self._appli = appli;
		self.appMetaData = null;
	}, null, {

		destroy: function() {
			var self = this;
			self._appli = null;
		},
		/**
		 *Returns the JSON description of application
		 */
		isApplicationLoaded: function() {
			var self = this;
			return (self.appMetaData != null);
		},

		/**
		 * Set the JSON description of application
		 */
		setApplication: function(appMetaData) {
			var self = this;
			if (appMetaData) {
				self.appMetaData = $.extend(true, {}, appMetaData);
			}
		},

		getApplicationName: function() {
			var self = this;
			return self.appMetaData && self.appMetaData.$application.applicationName || "";
		},

		getApplicationTitle: function() {
			var self = this;
			return (self.appMetaData && (self.appMetaData.$application.title || self.appMetaData.$application.applicationName)) || "";
		},

		getApplicationIcon: function() {
			return this.appMetaData && this.appMetaData.$application.iconName;
		},
		isSageApplication: function() {
			return this.appMetaData != null && this.appMetaData.$application.isSageApplication === true;
		},
		getAppBackGroundClass: function() {
			// No background class - we removed the background image
			return "";
		},
		/*
		 * Return name of home dashboard of this application or null if not available
		 */
		getHomeDashboardName: function() {
			var self = this;
			var homeDash = (self.appMetaData.$application.$homeDashboard.dashboardName || "").trim();
			if (homeDash.length == 0) {
				new Error(locale.text("error.page.homenotdefined", [self.getApplicationName()]));
			}
			if (self.appMetaData && self.appMetaData.$dashboards) {
				for (var p in self.appMetaData.$dashboards) {
					var data = self.appMetaData.$dashboards[p];
					if (data.$dashboardName === homeDash) {
						return data.$dashboardName;
					}
				}
			}
			throw new Error(locale.text("error.page.homenotfound", [self.getApplicationName(), homeDash]));
		},
	});

exports.Dao = _Dao;
});

define('syracuse-tablet/html/js/application/daoSdataWrkcpy',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/application/daoSdata'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/application/daoSdata').Dao;

/**
 * Class DAO that manages a working copy
 * Currently we don't manage a working copy on rowDetail DAO - TODO
 */
var _Klass = utils.defineClass(function(data, prototype, options) {
	options = options || {};
	Base.call(this, data, prototype, options);
	// Not managed for row detail dataSet
	this.enableWorkingCopy = this.isRowDetailDao ? false : true;
}, Base, {
	destroy: function(destroyProto) {
		Base.prototype.destroy.call(this, destroyProto);
	},
	setDirty: function() {
		Base.prototype.setDirty.call(this);
		this._workingCopyUpdate();
	},
	_workingCopyUpdate: function() {
		var self = this;
		if (self.enableWorkingCopy !== true) return;
		var step;
		if (self.wrkCpyDirty) {
			console.log("_workingCopyUpdate", "update");
			return globals.getStorage().draftOperation("wrkcpyUpdate", self.data);
		} else {
			self.wrkCpyDirty = true;
			console.log("_workingCopyUpdate", "create");
			return globals.getStorage().draftOperation("wrkcpyCreate", self.data).then(function(data) {
				self.enableWorkingCopy = data != null;
			});
		}
	},
	workingCopyGetId: function(onlyIfDirty) {
		if (this.enableWorkingCopy !== true && this.data == null) return null;
		if (onlyIfDirty === true && this.wrkCpyDirty !== true) return null;
		return this.data.$uuid;
	},
	clone: function() {
		return new _Klass($.extend(true, {}, this.data), this.prototype, {
			parent: this.parent,
			$bind: this.$bind,
			isRowDetailDao: this.isRowDetailDao === true
		});
	},
	updateParentRow: function(create, singleArrayRowIdx) {
		var res = Base.prototype.updateParentRow.call(this, create, singleArrayRowIdx);
		// Delete the working copy because parent has bee updated
		globals.getStorage().draftOperation("wrkcpyDelete", this.workingCopyGetId());
		return res;

	}
});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/pages/pageDrafts',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/pages/pageHtml','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/application/eventListener','syracuse-tablet/html/js/application/appFactory','syracuse-tablet/html/js/sdata/sdataDispatcher','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/scroller/scrollerHelpers','syracuse-tablet/html/js/helpers/formatApi'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var Base = require('syracuse-tablet/html/js/pages/pageHtml').Page;
var locale = require('syracuse-tablet/html/js/helpers/locale');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var factory = require('syracuse-tablet/html/js/application/appFactory');
var dispatcher = require('syracuse-tablet/html/js/sdata/sdataDispatcher');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');


var _templates = {
	error: '<section class="draft-error"><h1>{{error}}<h1><h2>{{contact}}<h2></section>',
	spinner: '\
		<div id="draftSpinner">\
   			<div>\
				<div class="spinner-loader"></div>\
			</div>\
		</div>',
	record: '\
			<section id="{{id}}" data-action="clickRecord" data-params="select" class="list-group-item s-m-draft-item {{status}}">\
				<div>\
					<div>\
						<div class="draft-title">{{title}}</div>\
						<div class="draft-date">{{creation_date}}</div>\
					</div>\
					<div>\
						<div><span class="draft-status">{{statusText}}</span><span class="draft-errorMsg">{{error}}</span></div>\
						<div class="draft-endpoint">{{endpoint}}</div>\
					</div>\
					<div>\
						<div class="draft-comment"><i class="fa fa-comment-o"></i>{{comment}}</div>\
						<div class="draft-actions">\
							<span data-params="edit" class="fa fa-edit"></span>\
						</div>\
					</div>\
				</div>\
				<span class="badge checked fa fa-check">&nbsp;</span>\
				<span style="{{#unless index}}display:none;{{/unless}}" class="badge index">{{index}}</span>\
			</section>',
	content: '\
			<div class="s-m-draft-header" style="display:none">\
				<div>\
					{{{selectMenu}}}\
				</div>\
				<div>\
					{{{filtersMenu}}}\
				</div>\
			</div>\
			<div id="draftInfo"  style="display:none">{{info}}</div>\
			<div id="draftPageWrapper" class="s-m-scroll-wrapper">\
				<div class="list-group s-m-draft-list">\
				</div>\
			</div>\
		</div>',
	selectMenu: '\
		<div id="draftSelectMenuId" class="btn-group">\
			<div class="{{dropDirection}}">\
				<button type="button" class="btn btn-primary dropdown-toggle" data-toggle="dropdown" aria-expanded="false">\
					<span class="badge"></span>{{title}}<span class="caret"></span>\
				</button>\
				<ul class="dropdown-menu dropdown-menu-left" role="menu">\
					{{#each links}}\
						<li><a  {{#if $isHidden}}style="display:none"{{/if}} draggable="false"  data-action="selectMenu" data-params="{{params}}" href="#">{{title}}</a></li>\
					{{/each}}\
				</ul>\
			</div>\
		</div>',
	filtersMenu: '\
		<select id="draftFiltersMenu" data-action="filter">\
		{{#each filterOptions}}\
			<option value="{{value}}" {{#if selected}}selected{{/if}}>{{title}}</option>\
		{{/each}}\
		<select>'
};
//http://www.css-spinners.com/	
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};

var _selectOptionsList = ["unselectall", "selectall", "hideunselected", "showunselected"];
var _toolbarLinks = [{
	name: "stop",
	$isHidden: true
}, {
	name: "synch",
	$isDisabled: true,
	$confirm: true
}, {
	name: "remove",
	$isDisabled: true,
	$confirm: true
}];

var _Page = utils.defineClass(
	function DraftsPage($parent, state, options) {
		options.header = true;
		options.breadcrumbs = true;
		options.footer = true;
		Base.call(this, $parent, state, options);
		this._selectedFilter = "creation_date:dsc";
		this._initLabels();
		notifications.subscribe(this, ["sm.action.link"]);
		this.dateFormatter = formatApi.getFormatter("application/x-datetime");
	}, Base, {
		scrollAllowed: function() {
			return false;
		},
		_initLabels: function() {
			this._filterOptions = [{
				value: "creation_date:asc",
				title: locale.text("drafts.filters.dateasc")
			}, {
				value: "creation_date:dsc",
				title: locale.text("drafts.filters.datedsc")
			}];
		},
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._myGestureMgr) {
				this._myGestureMgr.destroy();
				this._myGestureMgr = null;
			}
		},
		appendHtml: function($$parent, loadOpts) {
			var self = this;
			self.$$elmt.addClass("drafts");
			self.$$htmlRoot.html(_getHtml("content", {
				"filtersMenu": self._buildSortMenu(),
				"selectMenu": self._buildSelectMenu()
			}));
			self._$$selectMenu = self.$$htmlRoot.find("#draftSelectMenuId");
			self.$$info = self.$$htmlRoot.find("#draftInfo");
			self.$$listHeader = self.$$htmlRoot.find(".s-m-draft-header");
			self._$$list = self.$$htmlRoot.find(".s-m-draft-list");
			self.$$myScrollWrapper = self.$$elmt.find("#draftPageWrapper");
			self.$$myScrollWrapper.css({
				height: "auto"
			});
			self._myGestureMgr = scroller.newScroller(self._$$list, {
				isPageScroller: true,
				direction: "v"
			});
			self._updateList();
		},
		/**
		 * Update the content of the list
		 */
		_updateList: function() {
			var self = this;
			self._$$list.empty();
			self._$$spinner = null;
			self.$$info.hide();
			self.$$listHeader.hide();
			globals.getStorage().draftOperation("draftReadList").then(function(resources) {
				resources = self._applyFilters(resources || []);
				var content;
				if (resources.length > 0) {
					var recordsHtml = [];
					resources.forEach(function(rsrc, idx) {
						recordsHtml.push(self._getRecordHtml(rsrc, idx));
					});
					content = recordsHtml.join('\n');
				}
				self._$$list.html(content);
				self._$$spinner = $(_getHtml("spinner")).appendTo(self._$$list);
				self._updateUI();
			}).fail(function(e) {
				globals.getModal().error(locale.text("drafts.error.loading"), e, function() {
					self._$$list.html(_getHtml("error", {
						error: locale.text("error"),
						contact: locale.text("contact.admin")
					}));
					self._updateMyGesture();
				});
			});
		},
		/**
		 * Update gesture manager on page resize
		 */
		onMainPageResize: function(info, orientation, deviceType) {
			var self = this;
			if (self.destroyed) return;
			Base.prototype.onMainPageResize.call(self, info, orientation, deviceType);
			setTimeout(function() {
				var preserveScroll = info ? info.preserveScroll : false;
				if (info.orientationChanged || info.deviceChanged) {
					// To update action status beacause header has been rebuilt
					self._updateUI(preserveScroll);
				} else {
					self._updateMyGesture(preserveScroll);
				}
			});
		},
		/**
		 * Update gesture manager
		 */
		_updateMyGesture: function(preserveScroll) {
			if (!this._myGestureMgr) return;
			var mainRect = uiRect.elmtRect(this.$$contentElmt, "outer");
			var viewRect = uiRect.elmtRect(this.$$myScrollWrapper, "outer");
			var scrollRect = mainRect.intersectRect(viewRect);
			if (scrollRect && scrollRect.height < this._myGestureMgr.$$elmt.height()) {
				this._myGestureMgr.init(scrollRect, null, null, preserveScroll);
			} else {
				this._myGestureMgr.reset();
			}
		},
		/**
		 * Returns the html of a record
		 */
		_getRecordHtml: function(rsrc, index) {
			rsrc = $.extend({}, rsrc);
			rsrc.index = index == null ? null : index + 1;
			var date = rsrc["creation_date"];
			if (date) {
				rsrc["creation_date"] = this.dateFormatter.formatValue(date);
			}
			rsrc["statusText"] = locale.text("drafts.status." + rsrc.status);
			rsrc["error"] = rsrc.errorMsg || "";
			return _getHtml("record", rsrc);
		},
		_buildSelectMenu: function() {
			var links = [];
			_selectOptionsList.forEach(function(id) {
				links.push({
					title: locale.text("multiselect.action." + id),
					params: id,
					$isHidden: false
				});
			});
			return _getHtml("selectMenu", {
				links: links,
				title: locale.text("multiselect.selected"),
				dropDirection: "dropdown"
			});
		},
		_buildSortMenu: function() {
			var self = this;
			self._selectedFilter = self._selectedFilter || "creation_date:asc";
			var opts = [];
			self._filterOptions.forEach(function(item) {
				item = $.extend({}, item);
				item.selected = item.value === self._selectedFilter;
				opts.push(item);
			});
			return _getHtml("filtersMenu", {
				"filterOptions": opts
			});
		},
		/**
		 * Update select menu according to the status of the records
		 * Update eth number of selected records
		 */
		_updateUI: function(preserveScroll) {
			var allRecords = this._selectRecords("all").length;
			var selectedRecords = this._selectRecords(".selected").length;
			// Update the selection menu
			this._$$selectMenu.find('a[data-action]').toggle(selectedRecords > 0);
			this._$$selectMenu.find('a[data-params="selectall"]').toggle(allRecords !== selectedRecords);
			var hiddenUnselRecords = this._selectRecords(":not(.selected):not(:visible)").length;
			this._$$selectMenu.find('a[data-params="hideunselected"]').toggle(selectedRecords > 0 && selectedRecords < allRecords && hiddenUnselRecords == 0);
			this._$$selectMenu.find('a[data-params="showunselected"]').toggle(selectedRecords > 0 && hiddenUnselRecords > 0);
			this._$$selectMenu.find('.badge').text(selectedRecords);
			// Toggles the footer/header actions
			this.$$elmt.find(".draft-synch, .draft-remove").toggleClass("disabled", selectedRecords == 0);
			// Updates draft counter
			this.$$info.text(locale.text("drafts.info", [allRecords]));
			// Updates list
			var isEmpty = allRecords == 0;
			if (isEmpty) {
				this._$$list.html(locale.text("drafts.emptyList"));
			}
			this._$$list.toggleClass("empty", isEmpty);
			// Updates header and info
			this.$$info.toggle(!isEmpty);
			this.$$listHeader.toggle(!isEmpty);
			// Recalculates the scroll because the number of records can change (hide/show)
			this._updateMyGesture(preserveScroll);
		},
		/**
		 * Select records accordinbt to cssSelector
		 */
		_selectRecords: function(cssSelector) {
			var selector = "";
			if (cssSelector != "all") {
				selector += cssSelector;
			}
			return this._$$list.find("section.s-m-draft-item" + selector);
		},
		/**
		 * Filter records
		 */
		_actFilter: function() {
			if (this._busy === true) {
				return;
			}
			var val = $(arguments[1]).val();
			if (val == this._selectedFilter) {
				return;
			}
			this._selectedFilter = val;
			this._updateList();
		},
		_applyFilters: function(resources) {
			if (!this._selectedFilter) {
				return resources;
			}
			var f = this._selectedFilter.split(":");
			if (f.length != 2) {
				return resources;
			}
			var property = f[0];
			var order = f[1];
			resources.sort(function(a, b) {
				a = a[property];
				b = b[property];
				if (a == b) return 0;
				if (a > b) return order == "asc" ? +1 : -1;
				if (a < b) return order == "asc" ? -1 : +1;
			});
			return resources;
		},
		/**
		 * Secltion/Unselection of records
		 */
		_actSelectMenu: function(action) {
			var self = this;
			switch (action) {
				case "selectall":
				case "unselectall":
					// First show all
					var elmts = self._selectRecords("all").show();
					if (action == "unselectall") {
						elmts = self._selectRecords(".selected");
					}
					elmts.each(function() {
						self._toggleRecordSelection($(this), action === "selectall");
					});
					break;
				case "hideunselected":
					self._selectRecords(":not(.selected)").hide();
					break;
				case "showunselected":
					self._selectRecords(":not(.selected)").show();
					break;
			}
			this._updateUI();
		},
		/**
		 * Handle clien on record
		 * - actions: Select/unselect record or edit record
		 * We put only one data-action for record's dom elemt and check the data-param attribute
		 * - main record elemt has the 'select' attribut
		 * - edit icon has the 'edit' attribut
		 */
		_actClickRecord: function(params, $$elmt, evt) {
			evt.stopPropagation();
			if (this._busy === true) {
				return;
			}
			var $$rec = $$elmt.closest(".s-m-draft-item");
			if (!$$rec) return;
			var action = $$elmt.closest("[data-params]").attr("data-params");
			if (action === "select") {
				this._toggleRecordSelection($$rec);
				// Preserve the scroll
				this._updateUI(true);
			} else if (action === "edit") {
				var id = $$rec.attr("id");
				if (!id) {
					return;
				}
				// Get the id and triggers application.openDraft
				eventListener.triggerAction(this.$$elmt, "openDraft", id);
			}
		},
		/**
		 * force true/false/undefined
		 */
		_toggleRecordSelection: function($$rec, force) {
			if (!$$rec || $$rec.length == 0) return;
			$$rec.toggleClass("selected", force);
		},
		/**
		 * Start upload/remove
		 */
		_mainUploadBegin: function(name, ids) {
			this._stop = false;
			this._busy = true;
			this._logData = {
				nbSuccess: 0,
				nbErrors: 0
			};
			this.$$elmt.find(".draft-stop").removeClass("disabled").show();
			this._selectRecords(":not(.selected)").hide();
		},
		/**
		 * End upload/remove
		 */
		_mainUploadEnd: function(name) {
			this._busy = false;
			this.$$elmt.find(".draft-stop").hide();
			this.$$elmt.find(".synchronized").removeClass("synchronized");
			this._selectRecords(":not(.selected)").show();
			this._refreshIndexes();
			// At the end
			this._updateUI();
		},
		_refreshIndexes: function() {
			this._$$list.find(".s-m-draft-item").each(function(idx) {
				$(this).find(".badge.index").text(idx + 1).show();
			});
		},
		/**
		 * Upload alld the records given by ids array and resolve like _uploadPop
		 * Resolves stoppewith stopped/completed
		 */
		_upload: function(ids) {
			var self = this;
			self._mainUploadBegin("upload", ids);
			var join = $.Deferred();
			self._uploadPop(ids).then(function(status) {
				self._mainUploadEnd("upload");
				join.resolve(status);
			}).fail(function(e) {
				self._mainUploadEnd("upload");
				join.reject(e);
			});
			return join.promise();
		},
		/**
		 * Pop the ids ids array and upload them
		 * Returns the promise that will be resolve when:
		 * 	- upload succeeded (status = completed)
		 * 	- upload failed with an exception
		 * 	- upload stopped (status = stopped)
		 * _mainDeferred is null when we call _uploadPop outside the method
		 */
		_uploadPop: function(ids, _mainDeferred) {
			var first = _mainDeferred == null;
			if (first) {
				_mainDeferred = $.Deferred();
			}
			try {
				if (this._stop === true) {
					_mainDeferred.resolve("stopped");
					return;
				}
				if (!ids || ids.length == 0) {
					_mainDeferred.resolve("completed");
					return;
				}
				var self = this;
				self._uploadOne(ids.pop()).then(function() {
					setTimeout(function() {
						self._uploadPop(ids, _mainDeferred);
					});
				}).fail(function(e) {
					_mainDeferred.reject(e);
				});
			} catch (e) {
				_mainDeferred.reject(e);
			}
			return first ? _mainDeferred.promise() : null;
		},
		/**
		 * Upload the record given by id
		 * Resolve if no exception
		 * If upload succeeds 		-> Remove the draft and resolve
		 * If upload not succeeds 	-> Update the draft with new error and resolve
		 * If exception --> Reject
		 */
		_uploadOne: function(id) {
			var self = this;
			var deferred = $.Deferred();
			self._uploadOneBegin(id).then(function(ctx) {
				if (!ctx || !ctx.restoredContext) {
					throw new Error("unexpected null draft context");
				}
				if (!ctx.saveLink || !ctx.saveLink.sDataUrl) {
					throw new Error("unexpected null save link info");
				}
				return globals.getMetaData().getPageDetails(ctx.restoredContext.currentState).then(function(info) {
					return $.smResolve(ctx, info);
				}).fail(function(e) {
					return $.smReject(e);
				});
			}).then(function(draftCtx, info) {
				var dao = factory.createDaoSdata(draftCtx.dataSet, info.prototype);
				var payload = dao.getActionPayload(draftCtx.saveLink, true);
				return dispatcher.dispatch({
					$url: draftCtx.saveLink.sDataUrl,
					$method: draftCtx.saveLink.$method
				}, payload).then(function(result) {
					if (!result) {
						throw new Error("unexpected null http response");
					}
					var responseJSON = result.responseJSON || {};
					var next;
					if (!result.isSuccess) {
						if (result.status === 401) {
							// KO - Reject to display a dialog and stop process
							next = $.smReject(locale.text("drafts.error.unauthorized"));
						} else if (result.responseJSON && result.responseJSON.$noConnectionError === true) {
							// KO - Reject to display a dialog and stop process
							next = $.smReject(locale.text("drafts.error.noconnection"));
						} else {
							// KO - Set up draft with new error and date
							dao.updateMeta(responseJSON);
							draftCtx.status = "error";
							draftCtx.errMsg = responseJSON && responseJSON.$diagnoses && responseJSON.$diagnoses.length > 0 ? responseJSON.$diagnoses[0].$message : "";
							draftCtx["creation_date"] = utils.getCurISODateTime(new Date());
							next = self._uploadOneEnd(id, "saveFailed", {
								draftCtx: draftCtx
							});
						}
					} else {
						// OK
						next = self._uploadOneEnd(id, "saveSucceeded");
					}
					return next;
				});
			}).then(function() {
				deferred.resolve();
			}).fail(function(e) {
				if (typeof e === "string") {
					e = {
						$diagnoses: [{
							$message: e
						}]
					};
				}
				// Exception expected
				return self._uploadOneEnd(id, "exception", {
					exception: e
				}).always(function(e) {
					deferred.reject(e);
				});
			});
			return deferred.promise();
		},
		/**
		 * Init the spinner before processing record (sunch, remove..)
		 */
		_processRecordBegin: function($$rec) {
			if (this._$$spinner) {
				var pos = $$rec.position();
				this._$$spinner.css({
					top: pos.top + "px",
					display: 'table'
				});
				this._$$spinner.children().outerHeight($$rec.outerHeight()).show();
			}
			if (this._myGestureMgr) {
				this._myGestureMgr.makeVisible($$rec);
			}
		},
		/**
		 * Reset the spinner
		 */
		_processRecordEnd: function($$rec) {
			if (this._$$spinner) {
				this._$$spinner.hide();
			}
			if ($$rec) {
				// nothing
			}
		},
		/**
		 * Set the ui context
		 * Reads the draft
		 */
		_uploadOneBegin: function(id) {
			this._processRecordBegin(this.$$elmt.find("#" + id));
			return globals.getStorage().draftOperation("draftRead", id);
		},
		/**
		 * Set ui context
		 * Save/Delete the draft according to the status
		 */
		_uploadOneEnd: function(id, status, opts) {
			var self = this;
			var $$record = this.$$elmt.find("#" + id);
			this._processRecordEnd($$record);
			if (status === "saveSucceeded") {
				return globals.getStorage().draftOperation("draftDelete", id).then(function() {
					self._logData.nbSuccess++;
					$$record.remove();
				}).fail(function(e) {
					return $.smReject(e);
				});
			} else if (status === "saveFailed") {
				self._logData.nbErrors++;
				return globals.getStorage().draftOperation("draftSave", opts.draftCtx).then(function() {
					var $$newRecord = $(self._getRecordHtml(opts.draftCtx)).addClass("selected synchronized");
					$$record.after($$newRecord);
					$$record.remove();
				}).fail(function(e) {
					return $.smReject(e);
				});
			} else if (status === "exception") {
				return $.smReject(opts.exception);
			} else {
				// Exception
				return $.smReject(new Error("Unexpected draft status"));
			}
		},
		/**
		 * Synchronize the selected drafts
		 */
		_actSynch: function() {
			var self = this;
			self._upload(self._selectRecords(".selected").map(function() {
				return this.id;
			}).get().reverse()).then(function(status) {
				var nbSuccess = self._logData.nbSuccess;
				var nbErrors = self._logData.nbErrors;
				var count = nbSuccess + nbErrors;
				globals.getModal().notify({
					title: locale.text("drafts.synch." + status),
					body: locale.text("drafts.synch.result", [count, nbSuccess, nbErrors]),
					severityClass: nbErrors > 0 ? "warning" : "success",
					delay: nbErrors > 0 ? "medium" : "short"
				});
			}).fail(function(e, status) {
				globals.getModal().error(locale.text("drafts.error.uploading"), e);
			});
		},
		/**
		 * Pop a record and removes it
		 * Resolves or rejects mainDeferred if an error occurs
		 * Returns the promise on first call
		 */
		_removePop: function($$records, mainDeferred) {
			var self = this;
			var first = mainDeferred == null;
			if (first) {
				mainDeferred = $.Deferred();
			}
			var $$rec = $$records.length > 0 ? $$records.pop() : null;
			if ($$rec == null) {
				mainDeferred.resolve();
				return;
			}
			self._processRecordBegin($$rec);
			globals.getStorage().draftOperation("draftDelete", $$rec.attr("id")).then(function() {
				self._logData.nbSuccess++;
				$$rec.remove();
				setTimeout(function() {
					self._removePop($$records, mainDeferred);
				}, 500);
			}).fail(function(e) {
				mainDeferred.reject(e);
			});
			return first ? mainDeferred.promise() : null;
		},
		/**
		 * Remove selected records
		 */
		_actRemove: function() {
			var self = this;
			$.smResolve().then(function() {
				self._busy = true;
				self._logData = {
					nbSuccess: 0
				};
				// List of ids to delete
				return self._selectRecords(".selected").map(function() {
					return $(this);
				}).get().reverse();
			}).then(function($$records) {
				var deferred = $.Deferred();
				// Delete selected drafts
				self._removePop($$records).then(function() {
					globals.getModal().notify({
						title: locale.text("drafts.remove.completed", [self._logData.nbSuccess]),
						severityClass: "success",
						delay: "short"
					});
					deferred.resolve(true);
				}).fail(function(e) {
					globals.getModal().error(locale.text("drafts.error.removing"), e, function() {
						deferred.resolve(false);
					});
				});
				return deferred.promise();
			}).always(function() {
				self._busy = false;
				self._processRecordEnd(null);
				self._updateUI();
				self._refreshIndexes();
			});
		},
		/** Event sm.action.link
		 *  Notified when a action succeeded - sdata link - see action manager
		 *  success:	true/false
		 *  link:		Link info
		 *  result:		Json response
		 */
		notifActionLink: function(success, link, result, options) {
			if (!this.isActive()) return;
			switch (link.name) {
				case "synch":
					this._actSynch();
					break;
				case "remove":
					this._actRemove();
					break;
				case "stop":
					this._stop = true;
					break;
			}
		},
		/**
		 * Returns the links to display in the header/footer
		 */
		getToolbarLinks: function(toolbar, options) {
			var device = globals.getSiteLayout().getDeviceType();
			if ((device === "tablet" && toolbar === "footer") || (device === "smartphone" && toolbar === "header")) {
				var result = [];
				_toolbarLinks.forEach(function(act) {
					result.push({
						"name": act.name,
						"title": locale.text("drafts.action." + act.name),
						"icon": fontUtils.getDraftIcons(act.name),
						"$uuid": utils.UUID(),
						"css": "draft-" + act.name,
						"footerHeader": true,
						"isClientAction": true,
						"$confirm": act.$confirm === true ? locale.text("drafts.dlog.confirm." + act.name) : null,
						"$isHidden": act.$isHidden === true,
						"$isDisabled": act.$isDisabled === true
					});
				});
				return result;
			}
			return null;
		}
	});

exports.Page = _Page;
});

define('syracuse-tablet/html/js/application/appFactoryDeps',['require','exports','module','syracuse-tablet/html/js/application/application','syracuse-tablet/html/js/pages/pageDashboard','syracuse-tablet/html/js/pages/pageWelcomeDashboard','syracuse-tablet/html/js/pages/pageRegular','syracuse-tablet/html/js/pages/pageRequest','syracuse-tablet/html/js/pages/pageRowDetail','syracuse-tablet/html/js/pages/pageChartDetail','syracuse-tablet/html/js/pages/pageCardDesign','syracuse-tablet/html/js/pages/pageLookup','syracuse-tablet/html/js/pages/pageLogin','syracuse-tablet/html/js/application/daoApp','syracuse-tablet/html/js/application/daoSdata','syracuse-tablet/html/js/application/daoSdataWrkcpy','syracuse-tablet/html/js/pages/pageDrafts','syracuse-tablet/html/js/application/appFactory'],function (require, exports, module) {"use strict";

var Application = require('syracuse-tablet/html/js/application/application').Application;
var DashoardPage = require('syracuse-tablet/html/js/pages/pageDashboard').Page;
var WelcomeDashoardPage = require('syracuse-tablet/html/js/pages/pageWelcomeDashboard').Page;
var RegularPage = require('syracuse-tablet/html/js/pages/pageRegular').Page;
var RequestPage = require('syracuse-tablet/html/js/pages/pageRequest').Page;
var RowDetailPage = require('syracuse-tablet/html/js/pages/pageRowDetail').Page;
var ChartDetailPage = require('syracuse-tablet/html/js/pages/pageChartDetail').Page;
var CardDesignPage = require('syracuse-tablet/html/js/pages/pageCardDesign').Page;
var LookupPage = require('syracuse-tablet/html/js/pages/pageLookup').Page;
var LoginPage = require('syracuse-tablet/html/js/pages/pageLogin').Page;
var DaoApp = require('syracuse-tablet/html/js/application/daoApp').Dao;
var DaoSdata = require('syracuse-tablet/html/js/application/daoSdata').Dao;
var DaoSdataWrkcpy = require('syracuse-tablet/html/js/application/daoSdataWrkcpy').Klass;
var DraftsPage = require('syracuse-tablet/html/js/pages/pageDrafts').Page;


var factory = require('syracuse-tablet/html/js/application/appFactory');

exports.init = function() {
	factory.setImpl("Application", Application);
	factory.setImpl("DashoardPage", DashoardPage);
	factory.setImpl("WelcomeDashoardPage", WelcomeDashoardPage);
	factory.setImpl("RegularPage", RegularPage);
	factory.setImpl("RequestPage", RequestPage);
	factory.setImpl("RowDetailPage", RowDetailPage);
	factory.setImpl("ChartDetailPage", ChartDetailPage);
	factory.setImpl("CardDesignPage", CardDesignPage);
	factory.setImpl("LookupPage", LookupPage);
	factory.setImpl("LoginPage", LoginPage);
	factory.setImpl("DaoApp", DaoApp);
	factory.setImpl("DaoSdata", DaoSdata);
	factory.setImpl("DaoSdataWrkcpy", DaoSdataWrkcpy);
	factory.setImpl("DraftsPage", DraftsPage);
};
});

define('syracuse-tablet/html/js/controls/structElmt',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {"use strict";

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

/**
 * Base class for controls and layouts
 *
 * controller: page (or child controller)
 * 		must implements addControl Method
 *
 */
var _Klass = utils.defineClass(
	function StructElmt(controller, $type, article, options) {
		this.options = options || {};
		this.controller = controller;
		this.$type = $type;
		this.typeName = utils.getTypeName($type);
		this.article = article || {};
		this.children = null;
		this.parent = null;
		this._dao = null;
		this.initReuseProperties();
		this.destroyed = false;
		/* It's the responsibility of each structElmt to set isEmpty = true */
		this.isEmpty = false;
	}, null, {
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			this.$$elmt = null;
			this.id = this.createId(this.typeName);
		},
		destroy: function() {
			// First destroy the children before removing $$elmt
			if (this.children) {
				this.children.forEach(function(child) {
					if (child) child.destroy();
				});
				this.children = null;
			}
			if (this._htmlGeneratorContexts) {
				this.destroyHtmlGeneratorContexts();
			}
			notifications.unsubscribe(this);
			if (this.$$elmt) {
				this.$$elmt.unbind();
				this.$$elmt.remove();
				this.$$elmt = null;
			}
			this.controller = null;
			this._dao = null;
			this.parent = null;
			// Used to prevent error in asynchronous processes
			this.destroyed = true;
		},
		isRoot: function() {
			return this.parent == null || this.parent === this.controller;
		},
		/**
		 * Generate html
		 * Use the same control buildHtml multiple html with different id's
		 * It's used by cards to build the tree structure for a card and reuse it for all the cards instead of creating a new tree structure for each card
		 * Same as buildHtml but:
		 * 		calls initReuseProperties to reset ID and properties used by previous build (cache, dom elmts...)
		 * !! It's the responsibility of the caller to destroy or not the control after having set $$elmt to null
		 * Returns $$elmt
		 */
		generateHtml: function($$parent, controllerDao, htmlRootCtrl, updateLayout) {
			var opts = this.options;
			this.isEmpty = false;
			if (htmlRootCtrl) {
				opts.htmlRootCtrl = htmlRootCtrl;
			}
			opts.isHtmlGenerator = true;
			opts.updateLayout = updateLayout === true;
			/**
			 * !! When we build html of a rootLayout with isHtmlGenerator = true we call afterRender (recursively) after having called buildHtml to apply meta-data
			 * It's done in LayoutBase buildChildrenHtml
			 */
			this.buildHtml($$parent, controllerDao, opts);
			if (this.afterRender) {
				// Call afterRender on current element - afterRender is called by LayoutBase.buildChildrenHtml for children if any
				this.afterRender(opts);
			}
			return this.$$elmt;
		},
		applyMetaData: function(metaData, buildOptions) {
			// Nothing by default - used by controls
		},
		getDao: function() {
			if (this.destroyed) return null;
			if (this._dao && !this._dao.isValid()) {
				// Trick - Like we store the dao we don't know if it's still valid - It'd be better to not store the dao but not easy for arrays
				this._dao = null;
			}
			return this._dao ? this._dao : this.controller ? this.controller.dao : null;
		},
		/**
		 * Build html for a control/layout
		 * !! CHILD CLASSES BUILDHTML METHOD MUST CALL THIS METHOD BEFORE PROCESSING
		 */
		buildHtml: function($$parent, controllerDao, buildOptions) {
			/**
			 * We need to store the dao to build cards - dao is the data row which is different from controller.dao
			 * It's better to store it for asynchronous calls
			 */
			this._dao = controllerDao;
			this.isEmpty = false;
			if (buildOptions && buildOptions.isHtmlGenerator === true) {
				if (this._needReuse) {
					this.initReuseProperties();
				} else {
					// First call don't call _initReuse
					this._needReuse = true;
				}
			}
		},
		/**
		 * Only for controls by method is need for all structElmts
		 */
		getMetaData: function(metaProp) {
			return null;
		},
		/**
		 * Returns field/layout authoring
		 * path: string with or without '.' separator or array of string
		 */
		getAuthoring: function(path, defValue) {
			var val = utils.getPropByPath(this.article, path);
			return val != null ? val : defValue;
		},
		/**
		 * Appends style authoring to classArray
		 * It's a draft just to start dealing with authoring
		 * classArray: 	array of classes used by createDomElement
		 * pathOrData: 	string or array of string that points points to an authoring value
		 * 				JS plain object that is the authoring object
		 */
		appendStyleAuthoring: function(classArray, pathOrData) {
			classArray = classArray || [];
			if (!pathOrData) return classArray;
			if ($.isPlainObject(pathOrData)) {
				// pathOrData is the authoring object
				var data = pathOrData;
			} else {
				// pathOrData points to an authoring value
				var data = this.getAuthoring(pathOrData);
			}
			if (!data) return classArray;
			// Apply style classes - To improve/enhance
			for (var p in data) {
				if (["$theme", "$fontStyle", "$fontSize"].indexOf(p) >= 0) {
					classArray.push(data[p]);
				}
			}
			return classArray;
		},
		/**
		 * Empty current element
		 * 	Called before a refresh
		 *  Keep control objects
		 */
		empty: function() {
			if (this.children) {
				this.children.forEach(function(child) {
					if (child) child.empty();
				});
			}
			if (this.$$elmt) {
				this.$$elmt.empty();
			}
		},
		isLayout: function() {
			return false;
		},
		isVignette: function() {
			return false;
		},
		isControl: function() {
			return false;
		},
		createId: function(typeName) {
			return utils.readableuid(typeName);
		},
		/**
		 * Append structElmt c as a child of this
		 */
		appendStructElmt: function(c) {
			if (!c) return;
			if (!this.children) this.children = [];
			c.parent = this;
			this.children.push(c);
		},

		getNbChilds: function() {
			return this.children && this.children.length > 0;
		},
		/**
		 * Create the root element of the control/layout/vignette
		 * 	This element is identified by this.id
		 */
		createRootElement: function(css, $$parent) {
			// No id for generated html
			var e = this.setRootElement(uiUtils.createDomElement("div", css, null, this.options.isHtmlGenerator === true ? null : {
				"id": this.id
			}), $$parent);
			return e;
		},
		setRootElement: function(e, $$parent) {
			if (!e) {
				return null;
			}
			if (!e.jquery) {
				e = $(e);
			}
			this.$$elmt = e;
			if ($$parent) {
				if (!$$parent.jquery) {
					$$parent = $($$parent);
				}
				e.appendTo($$parent);
			}
			if (globals.isAutoUITestMode()) {
				var i = this.getUnitTestId();
				if (i) {
					globals.getUnitTestMgr().addStructElmtId(this.$$elmt, i);
				}
			}
			return e;
		},
		getUnitTestId: function() {
			return null;
		},
		isVisible: function() {
			return this.$$elmt && this.$$elmt.is(":visible");
		},
		isHidden: function() {
			return !this.isVisible();
		},
		show: function() {
			if (this.$$elmt) this.$$elmt.show();
		},
		hide: function() {
			if (this.$$elmt) this.$$elmt.hide();
		},
		/**
		 * Set the focus on this field and scroll
		 */
		setFocus: function() {

		},
		/*
		 * Must return the article of this control/layout node
		 * The article must only contain static authoring.
		 * Dynamic settings that are added by payload must not be part of the returned data structure
		 * since this structure will be used to create the article tree for the page and will
		 * be stored on the server!
		 */
		getArticle: function() {
			return this.article;
		},

		/*
		 * Called by authoring if a control or layout is removed by the user
		 */
		removeChild: function(structElmt) {
			var _children = [];
			this.children.forEach(function(child) {
				if (child && child.id === structElmt.id) {
					child.destroy();
				} else {
					_children.push(child);
				}
			});
			this.children = _children;
		},
		/*
		 * Called by authoring if a control or layout is removed by the user
		 */
		removeChildren: function() {
			this.children && this.children.forEach(function(child) {
				child.destroy();
			});
			this.children = [];
		},
		getIndexOfChild: function(child) {
			var idx = -1;
			this.children && this.children.some(function(c) {
				idx = idx + 1;
				if (c === child) {
					return true;
				}
				return false;
			});
			return idx;
		},
		getChildByIndex: function(idx) {
			return this.children && this.children[idx];
		},

		/*
		 * Add new child before nextChild
		 * If nextChild is null, it's added at the end of the container
		 */
		addChildBefore: function(ctrl, nextChild) {
			var added = false;
			var _children = [];
			this.children && this.children.forEach(function(c) {
				if (nextChild && (c.id === nextChild.id)) {
					_children.push(ctrl);
					added = true;
				}
				if (c.id !== ctrl.id) {
					_children.push(c);
				}
			});

			if (!added) {
				_children.push(ctrl);
			}
			this.children = _children;
		},

		/*
		 * Removes reference to child without destorying the child!
		 */
		removeChildRef: function(c) {
			var _children = [];
			this.children && this.children.forEach(function(child) {
				if (child.id !== c.id) {
					_children.push(child);
				}
			});
			this.children = _children;
		},

		/*
		 * Start by this node and go up the layout tree storing all the indexes of the current not in the parent container
		 */
		getPathInTree: function() {
			var ctrl = this;
			var parent;
			var path = [];
			parent = this.parent;

			// The intention of this function is to stop at root level, not at the first controller found
			// The first controller might be the vignette containing the control, but we want to get the page/dashboard
			// containing the full screen not only a single vignette
			//while (parent && parent != this.controller) {
			while (parent) {
				var idx;
				if (jsutils.isInstanceOf(parent, "Page")) {
					if (parent.isVignette) {
						var vgnt = parent.getParentVignette();
						idx = 0;
						parent = vgnt.parent;
					} else { // We reached the root page -> done
						break;
					}
				} else {
					idx = parent.getIndexOfChild(ctrl);
				}
				path.push(idx);
				ctrl = parent;
				parent = parent.parent;
			}
			path.reverse();
			return path;
		},

		/*
		 * Resolve the path generated by getPathInTree to find the children again
		 */
		findChildByPath: function(path) {
			if (!path) {
				return;
			}

			var node = this;
			path.some(function(idx) {
				if (jsutils.isInstanceOf(node, "VignetteBase")) {
					if (node.getPage()) {
						node = node.getPage().rootLayout;
					} else {
						node = null;
						return true;
					}
				}
				node = node.getChildByIndex(+idx);
			});
			return node;
		},

		/*
		 * Returns the article used for authoring of this element
		 * Note that sub level informations usually nested in $items MUST NOT be returned here
		 */
		getAuthArticle: function() {
			var authArticle = {};
			var nodeArticle = this.getArticle();
			Object.keys(nodeArticle).forEach(function(key) {
				if (key !== "$items") {
					authArticle[key] = nodeArticle[key];
				}
			});
			return authArticle;
		},

		getAuthState: function(dirtyKeys) {
			return null;
		},
		setAuthState: function(state) {

		},
		getArticleText: function(property) {
			if (!this.article[property]) {
				return "";
			}
			var self = this;
			var text = self.article[property] && self.article[property].replace(/\{\@(\S+)\}/g, function(m, g) {
				var localization = self.options.$localization;
				if (self.isVignette && !localization) {
					localization = utils.getArticleLocalization(utils.getCurrentPage().article);
				}
				return (localization && localization[g]) ||
					(localization && localization.$fallback && localization.$fallback[g]) ||
					(m);
			});
			if (text && this.article[property] === text) {
				text = this.controller.prototype.resolveExpression(text, null, true);
			};
			return text || "";
		},
		/**
		 * Stores all objects created by html generator which need to be destroyed
		 * ctx.handler 	= the ctx.handler called to destoy data
		 * ctx.data		= data to destroy
		 * When we generate HTML from a tree structure we pass the htmlRootCtrl in build options (see this.generate html)
		 * 	Example for customer addresses we generate multiple cards (which contains carousel) with the same tree structure
		 * All the controls generated can store a context in htmlRootCtrl to be destroyed with htmlRootCtrl
		 * Example for carousel generated inside a card (customer addresses)
		 * 	Carousel uses carousel plugin and eventually a slider
		 * 	We need to destroy them when we destroy htmlRootCtrl (the card's array)
		 */
		addHtmlGeneratorContext: function(ctx) {
			if (!ctx) return;
			if (!this._htmlGeneratorContexts) {
				this._htmlGeneratorContexts = [];
			}
			this._htmlGeneratorContexts.push(ctx);
		},
		/**
		 * Destroy all contexts created by htmt generator
		 */
		destroyHtmlGeneratorContexts: function() {
			if (!this._htmlGeneratorContexts) return;
			this._htmlGeneratorContexts.forEach(function(ctx) {
				if (ctx.handler && ctx.data) {
					ctx.handler(ctx.data);
				}
			});
			this._htmlGeneratorContexts = null;
		},
		/**
		 * Used by unit test entities to display info
		 */
		getUnitTestMsg: function() {
			return this.article && this.article.$unitTest ? this.article.$unitTest.message : null;
		}
	}
);

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/ctrlBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/controls/structElmt'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/structElmt').Klass;
/**
 * Used to generate the html of control Icon/Button
 * generate a link and call cb to get the content of the control (icon/button...)
 * cb	Add html text to html param
 */
var _genHtmlCtrlLink = function(proto, dao, options, cb) {
	var self = this;
	options = options || {};
	var html = [];
	var url = proto.data("$url");
	var tag = options.tag || 'a';
	var css = options.css || 'a';
	if (url && url.length) {
		html.push('<');
		html.push(tag);
		html.push(' href="' + url + '"');
		if (css) {
			html.push(' class="' + css + '"');
		}
		html.push('>');
	} else {
		// attributes for data-nav or data-action
		var action = proto.data("$action") || self.prototype.data("$navigation");
		if (action) {
			html.push('<');
			html.push(tag);
			html.push(' href="#"');
			for (var p in action) {
				html.push(' ' + p + '="' + encodeURIComponent(dao ? dao.parseExpression(action[p]) : action[p]) + '"');
			}
			if (css) {
				html.push(' class="' + css + '"');
			}
			html.push('>');
		}
	}
	if (cb) cb(html);
	if (html.length > 1) {
		html.push('</');
		html.push(tag);
		html.push('>');
	}
	return html.join('');
};

var _Klass = utils.defineClass(

	function CtrlBase(controller, article, prototype, options) {
		var self = this;
		options = options || {};
		self.prototype = prototype;
		self.$bind = article.$bind;
		Base.call(self, controller, prototype.data('$type'), article, options);
		self.$isEditMode = controller.isEditMode();
		if (options.displayCtx === "table") {
			self.$isEditMode = false;
		}
	}, Base, {
		destroy: function() {
			var self = this;
			Base.prototype.destroy.call(self);
			if (self.prototype) {
				// We destroy the proto
				self.prototype.destroy();
				self.prototype = null;
			}
		},
		createId: function(typeName) {
			// Add $bind in id for readability - Id can be minimized in non debug version
			return utils.readableuid(this.$bind, typeName.substr(0, 3));
		},
		/**
		 * Controls manage by the page (outside the tree structure given by article)
		 * footer/header...
		 */
		isPageControl: function() {
			return this.$type.smStartsWith("tablet/x-page-");
		},
		/**
		 * controllerDao is the page dao or the row data for a grid
		 * 	We need to store it to keep acces
		 */
		buildHtml: function($$parent, controllerDao, buildOptions, classes) {
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions);
			var css = ["s-m-control"];
			var $theme = this.getAuthoring("$theme");
			if ($theme && $theme !== "none") {
				css.push("s-m-theme-" + $theme);
			}
			if (classes) css.push(classes.join(' '));
			this.createRootElement(css, $$parent);
			this._oldValue = this.getValue();

			if (globals.isAutoUITestMode()) {
				globals.getUnitTestMgr().addBindAttribute(this);
			}
		},
		getUnitTestId: function() {
			if (this.$bind) {
				return utils.unitTestId(this.$bind);
			} else {
				return utils.unitTestId(this.typeName);
			}
		},
		afterRender: function(buildOpts) {
			// Apply meta after build html - !! Called aftrt buildHtml if isHtmlGenerator = true
			this.applyMetaData(this.getMetaData(), buildOpts);
		},
		/**
		 * Refreshes the control
		 * We have to apply meta-data
		 */
		refresh: function(controllerDao, options) {
			if (options && options.refreshValue) {
				// Used by simple controllers - To improve with meta-data management imrpovement
				var newValue = this.getValue();
				if (!utils.areEqual(newValue, this._oldValue)) {
					// Enabled only wit simple controller
					this.refreshValue(newValue);
					this._oldValue = newValue;
				}
			}
			this.applyMetaData(this.getMetaData(), options);
		},
		refreshValue: function(value) {

		},
		/**
		 * dao.getMetaData does the merge between prototype and data
		 * metaProp		optional - name of the meta $readonly...
		 * 				if null returns all the meta
		 */
		getMetaData: function(metaProp) {
			var dao = this.getDao();
			var meta = dao ? dao.getMetaData("$properties", this.$bind) : null;
			if (metaProp) return meta ? meta[metaProp] : null;
			return meta;
		},
		getTitle: function() {
			var ttl = (this.article && this.article.$title) || this.prototype.data("$title") || this.prototype.getPropTitle(this.$bind);
			if ((!ttl || ttl.length === 0) && globals.isAuthoringActive() && this.prototype.isFacet("details", "edit")) {
				// #7148- It's better to display title if no title and force the user to hide them in authoring mode
				ttl = this.$bind;
			}
			return ttl;
		},
		/**
		 * Applies meta-data
		 * In edit mode the dom element to which meta-data apply is identify by s-m-meta class
		 * In detail mode meta-data apply to fieldSlot
		 * buildOptions give the context displayCtx to manage error messages
		 */
		applyMetaData: function(metaData, buildOptions) {
			if (metaData == null) return;
			if (this.$isEditMode) {
				// default
				var e = this.$$elmt.find(".s-m-meta");
				if (e.length > 0) {
					// Apply $isDisabled and $isReadOnly
					// is("input") returns true for button tags -> we check the BS class .btn
					if (e.is("input") && !e.is(".btn")) {
						// only for input tags
						e[metaData.$isReadOnly === true ? "attr" : "removeAttr"]("readonly", "");
						e[metaData.$isDisabled === true ? "attr" : "removeAttr"]("disabled", "");
					} else {
						// other tags
						e[metaData.$isReadOnly === true || metaData.$isDisabled === true ? "attr" : "removeAttr"]("disabled", "");
					}
				}
			}
			// We can for a control to be hidden by authoring - see _getChartDetailArticle
			if (this.article.$isHidden != null || metaData.$isHidden != null) {
				this.$$elmt.toggleClass('s-m-hidden', this.article.$isHidden === true || metaData.$isHidden === true);
			}
		},
		getValue: function() {
			var dao = this.getDao();
			return dao ? dao.getValue(this.$bind) : null;
		},
		/**
		 * Change internal value (non UI only)
		 * value parameter must be a correct datatype value without UI specific formatting
		 */
		setValue: function(value) {
			this.getDao().setValue(this.$bind, value);
		},
		/**
		 *  Validate the value and display error if any
		 *  returns true if OK
		 *  Used to validate a form
		 */
		checkData: function() {
			// Only field controls check the value
			return true;
		},
		setErrorStatus: function(yes) {
			if (!this.$$elmt) return;
			this.$$elmt[yes === true ? "addClass" : "removeClass"]("error");
		},
		/**
		 * True if ctrl has an error
		 */
		hasError: function() {
			return this.$$elmt && this.$$elmt.hasClass("error");
		},
		/**
		 * Set the focus on this field and scroll
		 */
		setFocus: function() {
			if (!this.controller) return;
			// Just make ctrl visible
			this.controller.makeVisible(this);
			// Focus is set on CtrlFields with inputs fields for the moment
		},
		isControl: function() {
			return true;
		},
		// called by authoring right panel for special cases
		// returns true if property is allowed 
		isAuthoringPropAllowed: function(property, value) {
			return true;
		}
	}
);

exports.genHtmlCtrlLink = _genHtmlCtrlLink;
exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/validator',['require','exports','module','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var locale = require('syracuse-tablet/html/js/helpers/locale');

/*
 *
 * Collection of all SData contraints and a validation function per constraint
 *
 */

var _validator = {
	validate: function(ctrl, value, errors, constraints) {
		var proto = ctrl.prototype;
		var ok = true;
		for (var i = 0; i < constraints.length; i++) {
			var c = constraints[i];
			var prop = null;
			if (ctrl && ctrl.getMetaData) {
				// We check metadata first - check $properties[constraints] in data and proto
				// Ex: $isMandatory
				prop = ctrl.getMetaData(c);
			}
			if (prop == null) {
				// If it's not a meta ($properties) we check the proto value
				prop = proto && proto.data(c);
			}
			if (prop != null) { // constraint set in prototype
				var fn = _validator[c];
				if (fn) {
					ok = fn(value, errors, prop) && ok;
				} else {
					errors.push(locale.text("field.unknownConstraint", [c]));
					ok = false;
				}
			}
		}
		return ok;
	},

	// General
	$isMandatory: function(value, errors, constraint) {
		if (constraint && (value == null || value === "")) {
			errors.push(locale.text("field.valMand"));
			return false;
		}
		return true;
	},

	// Strings
	$pattern: function(value, errors, constraint) {
		var self = this;
		if (value && constraint) {
			var re = new RegExp(constraint);
			if (!re.test(value)) {
				errors.push(locale.text("field.patternError", [constraint]));
				return false;
			}
		}
		return true;
	},

	// Numeric
	$minimum: function(value, errors, constraint) {
		var self = this;
		if (value != null && value < constraint) {
			errors.push(locale.text("field.minimum", [constraint]));
			return false;
		}
		return true;
	},
	$maximum: function(value, errors, constraint) {
		var self = this;
		if (value != null && value > constraint) {
			errors.push(locale.text("field.maximum", [constraint]));
			return false;
		}
		return true;
	},
	$exclusiveMinimum: function(value, errors, constraint) {
		var self = this;
		if (value != null && value <= constraint) {
			errors.push(locale.text("field.exclusiveMinimum", [constraint]));
			return false;
		}
		return true;
	},
	$exclusiveMaximum: function(value, errors, constraint) {
		var self = this;
		if (value != null && value >= constraint) {
			errors.push(locale.text("field.exclusiveMaximum", [constraint]));
			return false;
		}
		return true;
	},
	$minLength: function(value, errors, constraint) {
		var self = this;
		if (!value || value.length < constraint) {
			errors.push(locale.text("field.minLength", [constraint]));
			return false;
		}
		return true;
	},
	$maxLength: function(value, errors, constraint) {
		var self = this;
		if (value && value.length > constraint) {
			errors.push(locale.text("field.maxLength", [constraint]));
			return false;
		}
		return true;
	},
	$precision: function(value, errors, constraint) {
		var self = this;
		if (value) {
			var txt = ("" + value).split(".").join("");
			if (txt.length > constraint) {
				errors.push(locale.text("field.precision", [constraint]));
				return false;
			}
		}
		return true;
	},
	$scale: function(value, errors, constraint) {
		var self = this;
		if (value) {
			var txt = ("" + value).split(".");
			txt = txt && txt[1] || "";
			if (txt.length > constraint) {
				errors.push(locale.text("field.scale", [constraint]));
				return false;
			}
		}
		return true;
	}

};

exports.Validator = _validator;
});

define('syracuse-tablet/html/js/controls/field/ctrlFieldBase',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/controls/validator','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/native/native'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var validator = require('syracuse-tablet/html/js/controls/validator').Validator;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var native = require('syracuse-tablet/html/js/helpers/native/native');
var _label_pos = ["top", "left"];
var _texr_align = ["right", "left", "center"];
/**
 * Give the authoring property that enables the capability if any
 */
var _nativeCapabilityAutoring = {
	"scanBarcode": "$scanBarcode",
	"GPS": "$scanGPS"
};
/**
 * Base class for controls that display exactly one value/property
 */
var _Klass = utils.defineClass(

	function CtrlFieldBase(controller, article, prototype, options) {
		Base.call(this, controller, article, prototype, options);
		this.formatter = this.initFormatter();
		this._nativeCapabilities = this._initNativeCapabilities(options);
		// css to add to fieldSlot elmt
		this.cssType = null;
	}, Base, {
		_initNativeCapabilities: function(options) {
			if (!options || !options.nativeCapabilities) return null;
			var res = {};
			for (var capability in options.nativeCapabilities) {
				res[capability] = options.nativeCapabilities[capability] === true && native.hasCapability(capability) === true;
			}
			return res;
		},
		initFormatter: function(forceType, forceFormat) {
			if (forceType == null) {
				forceType = this.$type;
			}
			// undefined to accept forceFormat = null
			if (forceFormat == undefined) {
				forceFormat = this.prototype.data('$format');
			}
			return formatApi.getFormatter(forceType, forceFormat);
		},
		/**
		 * authoringOnly: force to skip native interface capability
		 * -> Used to display the pickers in authoring mode
		 */
		isNativeCapabilityEnabled: function(capability, authoringOnly) {
			if (authoringOnly === true && globals.isAuthoringActive()) {
				// Forces to display pickers in authoring mode to make user aware
				var authoring = this.getNativeCapabilityAuthoring(capability);
				return authoring != null && this.article[authoring] === true;
			}
			if (this._nativeCapabilities == null || this._nativeCapabilities[capability] !== true) {
				return false;
			}
			var authoring = this.getNativeCapabilityAuthoring(capability);
			return authoring == null || this.article[authoring] === true;
		},
		getNativeCapabilityAuthoring: function(capability) {
			// use this.options.nativeCapabilities because it's not filtered by native.hasCapability
			// Authoring doesn't require the native wrapper
			if (!this.options || this.options.nativeCapabilities == null || this.options.nativeCapabilities[capability] !== true) {
				return null;
			}
			return _nativeCapabilityAutoring[capability];
		},
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			this.$$input = null;
			this.$$message = null;
			this.$$value = null; // To force to recreate the value
		},
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.formatter = null;
		},
		/**
		 */
		buildHtml: function($$parent, controllerDao, buildOptions) {
			var classes = ["s-m-field"];
			// add the type of field if needed for css selector
			if (this.cssType) classes.push(this.cssType);
			if (this.getAuthoring("$value.$valueFirst", false)) classes.push("s-m-valueFirst");
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions, classes);
			var fieldSlot = this.$$elmt.get(0);
			this.buildFieldTitle(fieldSlot, buildOptions);
			this.buildFieldValue(fieldSlot, buildOptions);
			// authoring
			this._applyLabelAuthoring();
			this.checkDiagnoses(buildOptions);
			this.checkEmptyValue();
			this._checkNumVisiblePickers();
		},
		/**
		 * Refresh only the value
		 */
		refreshValue: function(buildOptions) {
			if (!this.$$value) return;
			this.buildFieldValue(this.$$elmt.get(0), buildOptions);
			this.checkEmptyValue();
		},
		/**
		 * Can be overridden - gauge
		 * forceEmpty used by asynchronous processes (ctrlText)
		 */
		checkEmptyValue: function(forceEmpty) {
			if (this.$isEditMode) return;
			/**
			 * We add a blank value if top aligned in order to align fields in a cell
			 * To improve if needed
			 */
			this.$$elmt.css("display", "");
			this.isEmpty = forceEmpty === true || this.$$value == null || this.$$value.is(":empty");
			this.$$elmt.toggleClass("s-m-empty", this.isEmpty);
			if (!this.isEmpty) return;
			// Capability to hide the field if no value
			if (this.getAuthoring("$hideIfEmpty") === true) {
				// No title and No value -> No display
				this.$$elmt.css("display", "none");
				return;
			}
			if (this.getAuthoring("$labelPosition") === "top") {
				// For alignment 
				if (!this.$$value) this.$$value = this._create$$value();
				this.$$value.html("&nbsp;");
			}
		},
		/*
		 * Apply authoring properties related to the label:
		 * - labelPosition which can have values top,right,bottom,left
		 * - textAlignment which can have values left, right
		 */
		_applyLabelAuthoring: function() {
			// Code below could be optimized by using classList
			var val = this.getAuthoring("$labelPosition");
			this.$$elmt.removeClass("s-m-top");
			if (val == "top") {
				this.$$elmt.addClass("s-m-top");
			}
			this.$$elmt.removeClass("s-m-left s-m-right s-m-center");
			if (val === "top") {
				val = this.getAuthoring("$labelAlign");
				if (val != null && _texr_align.indexOf(val) >= 0) {
					this.$$elmt.addClass("s-m-" + val);
				}
			}
		},
		_getNativePicker: function() {
			if (!this._nativeCapabilities) return null;
			if (this.isNativeCapabilityEnabled("scanBarcode")) {
				return "scanBarcode";
			} else if (this.isNativeCapabilityEnabled("GPS")) {
				return "GPS";
			} else if (this.isNativeCapabilityEnabled("penTextInput")) {
				return "penTextInput";
			}
			return null;
		},
		_addNativePickers: function() {
			if (!this._nativeCapabilities) return;
			if (globals.isMobile()) {
				var nativeCapability = this._getNativePicker();
				if (nativeCapability) {
					// First
					this.addNativePicker(nativeCapability);
				}
				return;
			}
			// In desktop mode, for authoring, we add all the pickers and show hide them according to the $ property on sm.auth.close/sm.auth.set.page events
			var self = this;
			["penTextInput", "GPS", "scanBarcode"].forEach(function(nativeCapability) {
				self.addNativePicker(nativeCapability).toggle(self.isNativeCapabilityEnabled(nativeCapability, true));
			});
			// USed to toggle the pickers
			notifications.subscribe(this, ["sm.auth.close", "sm.auth.set.page"]);
		},
		/**
		 * Create the main input field that is bind to blur event and other event
		 * s-m-meta indicates the element to which meta will be applied in edit mode
		 */
		createMainInput: function(parent, value, type, attrs) {
			type = type || "text";
			this._addNativePickers();
			var checkBox = "checkbox" === type;
			var css = ["s-m-meta"];
			attrs = attrs || {};
			attrs.type = type;
			var element = "input";
			if ("text" === type) {
				css.push("form-control");
				css.push("ctrl-evt-blur");
				attrs.value = value;
			} else if ("textplain" === type) {
				element = "textarea";
				css.push("form-control");
				css.push("ctrl-evt-blur");
			} else if (checkBox) {
				css.push("ctrl-evt-click");
			}
			if (this.options.notifyFocus === true) {
				css.push("ctrl-evt-focus");
			}
			this.$$input = $(uiUtils.createDomElement(element, css, null, attrs)).prependTo(this._$$inputGroup || this.$$value);
			if (checkBox) {
				this.$$input.prop("checked", value);
			}
			return this.$$input;
		},
		/**
		 * Pickers are displayed in authoring mode even if capability is not enabled to make user aware
		 * We toggle them when we clode authoring
		 */
		notifAuthClose: function() {
			if (!this.$$elmt) return;
			for (var p in _nativeCapabilityAutoring) {
				// Restore according to native capabilities - false to say that it's not authoring mode
				this.$$elmt.find('button[data-action="' + p + 'Picker"]').toggle(this.isNativeCapabilityEnabled(p, false));
			}
			this._checkNumVisiblePickers();
		},
		/**
		 * Pickers are displayed in authoring mode even if capability is not enabled to make user aware
		 * We toggle them when we open authoring
		 */
		notifAuthSetPage: function() {
			if (!this.$$elmt) return;
			for (var p in _nativeCapabilityAutoring) {
				this.$$elmt.find('button[data-action="' + p + 'Picker"]').toggle(this.isNativeCapabilityEnabled(p, true));
			}
			this._checkNumVisiblePickers();
		},
		_checkNumVisiblePickers: function() {
			if (!this._$$inputGroupBtn) return;
			var $$pickers = $("button", this._$$inputGroupBtn);
			var count = 0;
			$.each($$pickers, function(idx, picker) {
				// We do not is $.is..or :visible because elements may not be attached to the dom yet
				if ($(picker).css("display") !== "none") {
					count = count + 1;
				}
			});
			this._$$inputGroupBtn.toggle(count > 0);
		},
		addNativePicker: function(nativeCapability) {
			return this.addPicker(nativeCapability, fontUtils.getIconByName(nativeCapability + "Picker"));
		},
		/**
		 * Add a picker on the left hand side of the control
		 * Must be called before calling createMainInput
		 */
		addPicker: function(type, icon) {
			if (!this._pickers) {
				this._pickers = {};
			}
			if (this._pickers[type]) {
				return this._pickers[type];
			}
			this._pickers = this._pickers || {};
			var $$input;
			if (!this._$$inputGroup) {
				$$input = this.$$input ? this.$$input.detach() : null;
				this._$$inputGroup = $('<div class="input-group"/>').appendTo(this.$$value);
			}
			if (!this._$$inputGroupBtn) {
				this._$$inputGroupBtn = $('<span class="input-group-btn"/>').appendTo(this._$$inputGroup);
			}
			var $$picker = this._pickers[type] = $('<button data-control-id="' + this.id + '" data-action="' + type + 'Picker" class="btn btn-default s-m-meta"><span class="' + icon + '"></span></button>');
			if ($$input) {
				$$input.prependTo(this._$$inputGroup);
			}
			return $$picker.appendTo(this._$$inputGroupBtn);
		},
		_actPenTextInputPicker: function() {
			var self = this;
			native.getModule("penTextInput").getPenTextInput({
				title: self.getTitle(),
				value: self.getValue()
			}).then(
				function(data) {
					if (data.action === "ok") {
						if (data.matches && data.matches.length) {
							var values = [];
							data.matches.forEach(function(val) {
								val = self.parseValue(val);
								if (val != null || val != "") {
									values.push(val);
								}
							});
							if (values.length === 0) return;
							// Only the first one if it's a number
							values = self.typeName === "string" ? values.join(' ') : values[0];
							self.setFieldValue(values);
						}
					}
				}
			);
		},
		_actGPSPicker: function() {
			var self = this;
			globals.getApplication().currentPage.waitWheelStart();
			native.getModule("GPS").getGPSCoordinates().then(
				function(data) {
					if (data.succeeded === true) {
						self.setFieldValue(data.latitude + ", " + data.longitude);
					} else {
						globals.getModal().notify({
							severityClass: "error",
							title: locale.text("gps.error")
						});
					}
					globals.getApplication().currentPage.waitWheelStop();
				}
			).fail(function() {
				globals.getApplication().currentPage.waitWheelStop();
			});
		},
		_actScanBarcodePicker: function() {
			var self = this;
			globals.getApplication().currentPage.waitWheelStart();
			native.getModule("scanBarcode").scanBarcode().then(
				function(data) {
					if (data.action === "ok") {
						self.setFieldValue(data.content);
					} else if (data.action === "cancelled") {
						globals.getModal().notify({
							severityClass: "info",
							title: locale.text("barcode.cancelled")
						});
					} else {
						globals.getModal().notify({
							severityClass: "error",
							title: locale.text("barcode.error")
						});
					}
					globals.getApplication().currentPage.waitWheelStop();
				}
			).fail(function() {
				globals.getApplication().currentPage.waitWheelStop();
			});

		},
		onFocus: function(justCheck) {
			notifications.publish("sm.field.focus", this);
		},
		/**
		 * Displays title under fieldSlot ($$elmt)
		 */
		buildFieldTitle: function(fieldSlot, buildOptions) {
			this.$$elmt.removeClass("s-m-title-hidden");
			if (this.getAuthoring("$isTitleHidden")) {
				this.$$elmt.addClass("s-m-title-hidden");
				return;
			}
			// don't build field title if grid cell
			if (buildOptions && buildOptions.displayCtx === "table") return;
			var ttl = (this.getTitle() || "").trim();
			if (ttl.length > 0) {
				if (this.getMetaData("$isMandatory") === true) ttl += "*";
				this.$$title = $(uiUtils.createDomElement("div", ["s-m-title"], ttl, null, fieldSlot));
			}
			if (!ttl.length) {
				this.$$elmt.addClass("s-m-title-hidden");
			}
		},

		/**
		 * Just create the value slot under fieldSlot ($$elmt)
		 * Child class has to add the value
		 */
		buildFieldValue: function(fieldSlot, buildOptions) {
			if (this.$$value) {
				this._clear$$value();
				this.clearInputErrors();
				this.$$message = null;
			} else {
				this._create$$value(fieldSlot);
			}
			return this.$$value.get(0);
		},
		_create$$value: function(fieldSlot) {
			if (this.$$value) {
				this._clear$$value();
			} else {
				this.$$value = $(uiUtils.createDomElement("div", ["s-m-value", (this.$isEditMode ? "edit" : "")], null, null, fieldSlot || this.$$elmt));
			}
			return this.$$value;
		},
		_clear$$value: function() {
			if (this.$$value) {
				this.$$value.empty();
			}
			if (this._pickers) {
				this._pickers = null;
			}
			this.$$input = null;
			this._$$inputGroup = null;
			this._$$inputGroupBtn = null;
		},
		/**
		 * Add a text value to the valueSlot
		 * USed by default to display value with $details facet
		 */
		appendTextValue: function(valueSlot, value) {
			if (valueSlot == null || value == null) return;
			if (typeof value !== "string") value = value.toString ? value.toString() : "??Can't display??";
			value = value.trim();
			if (value.length > 0) uiUtils.appendTextNode(valueSlot, value);
		},

		/*
		 * value: value inputed into the field as string
		 * errors: array where to add validation errors as strings
		 * return true if ok
		 */
		validateValue: function(value, errors) {
			return validator.validate(this, value, errors, ["$isMandatory"]);
		},

		/*
		 * value: value inputed into the field as string
		 * errors: array where to add parsing errors as strings
		 *
		 * return: Parsed value as represented in sdata data
		 * E.g. "2014-12-31" for dates or 123 for numbers
		 */
		parseValue: function(value, errors) {
			if (!this.formatter) {
				return value;
			}
			return this.formatter.parseValue(value, errors);
		},

		applyMetaData: function(metaData, buildOptions) {
			Base.prototype.applyMetaData.call(this, metaData, buildOptions);
			if (buildOptions && buildOptions.displayCtx === "table") return;
			if (metaData && metaData.$diagnoses) {
				var errors = [];
				metaData.$diagnoses.forEach(function(d) {
					errors.push(d.$message);
				});
				this.showInputErrors(errors);
			}
		},
		showInputErrors: function(errors) {
			if (!this.$$elmt) return;
			this.$$elmt.removeClass("error");
			if (this.$$message) {
				this.$$message.empty();
			}
			if (typeof errors === "string") errors = [errors];
			if (!errors || errors.length === 0) {
				return;
			}
			if (!this.$$message) {
				this.$$message = $('<span class="s-m-error"/>').appendTo(this.$$elmt);
			}

			this.$$elmt.addClass("error");
			var self = this;
			errors.forEach(function(error) {
				if (error != null && (error + "").trim().length > 0) {
					self.$$message.append($("<p>").text(error));
				}
			});
		},
		clearInputErrors: function() {
			this.showInputErrors(null);
		},

		/*
		 * Get value as string to be displayed in control (ev. formatted specific to locale)
		 */
		getFormattedValue: function(value) {
			if (!this.formatter) {
				return value == null ? "" : new String(value);
			}
			try {
				return this.$isEditMode === true ? this.formatter.formatValueEdit(value) : this.formatter.formatValue(value);
			} catch (e) {
				// We display the message instead of an error dialog
				this.showInputErrors([e.message]);
				return "";
			}
		},
		setValue: function(value) {
			Base.prototype.setValue.call(this, value);
		},
		/**
		 * Set internal value (controller) and visible formatted value (UI) by applying formatting if needed
		 * value parameter must be a correct datatype value without UI specific formatting
		 * data: 		string/int
		 * 				object with {$value:,$description:,$title:} for x-reference
		 */
		setFieldValue: function(value) {
			this.setDisplayValue(this.getFormattedValue(value));
			this.setValue(value);
		},
		/**
		 * Field value (input) is set by an external widget (date picker, lookup...)
		 * We force the focus in the field - Use to switch the status of an editable vignette
		 */
		setFieldValueFromSelector: function(value) {
			this.setFieldValue(value);
			// Enable to put focus into field after a value has been selected by lookup
			// On last discussion, we decided to not put the focus is the better choice
			// this.setFocus();
		},
		/**
		 * Return true if value OK
		 * justCheck	true to not set the value
		 */
		onBlur: function(justCheck) {
			this.clearInputErrors();
			if (!this.$$input) return true;
			var value = this.$$input.val();
			var errors = [];
			value = this.parseValue(value, errors);
			if (errors.length === 0) {
				this.validateValue(value, errors);
				if (justCheck !== true) {
					// Set displayed value, also it may violate constraints later
					// This is because a parseable value is reformatted here to emiminate wrong characters
					// Internat value remains unchanged until all constraints are met
					this.setDisplayValue(this.getFormattedValue(value));
					if (errors.length === 0) {
						this.setValue(value);
					}
				}
			}
			if (errors.length > 0) {
				this.showInputErrors(errors);
			}
			return errors.length == 0;
		},
		/**
		 * Change visible value (UI only)
		 * value parameter must be formatted already!
		 */
		setDisplayValue: function(value) {
			if (this.$$input) {
				this.$$input.val(value);
			}
			this.clearInputErrors();
			this.removeDiagnoses();
		},
		refresh: function(controllerDao, options) {
			//Std method checks the diagnoses
			Base.prototype.refresh.call(this, controllerDao, options);
		},
		checkDiagnoses: function(options) {
			var errors = [];
			var diags = this.getMetaData("$diagnoses");
			if (diags && diags.length > 0) {
				diags.forEach(function(d) {
					if (d.$severity === "error") {
						errors.push(d.$message);
					}
				});
			}
			if (errors.length > 0) {
				if (options && options.displayCtx === "table") {
					// We just highlight the elemt - no message is displayed in a table - displayed in rowDetail page
					this.$$elmt.addClass("error");
				} else {
					this.showInputErrors(errors);
				}
			}
			return errors.length === 0;
		},
		/**
		 *  Validate the value and display error if any
		 *  returns true if OK
		 *  Use to validate a form
		 */
		checkData: function() {
			this.clearInputErrors();
			var meta = this.getMetaData();
			if (meta && (meta.$isDisabled === true || meta.$isReadOnly === true || meta.$isHidden === true)) return true;
			if (!this.onBlur(true)) {
				return false;
			}
			var errors = [];
			var value = this.getValue();
			this.validateValue(value, errors);
			if (errors.length > 0) {
				this.showInputErrors(errors);
			}
			return errors.length === 0;
		},
		removeDiagnoses: function() {
			if (this.getDao()) {
				this.getDao().removeMetaDiagnoses(this.$bind);
			}
		},
		/**
		 * Set the focus on this field and scroll
		 */
		setFocus: function() {
			// !! First make visible
			Base.prototype.setFocus.call(this);
			if (this.acceptFocus()) {
				// !! Second setFocus
				// !! setFocus scrolls the page and we don't want that because we don't use native scrolling 
				// We need to make th control visible before focus in order to not scroll the page
				// If it doesn't work fine we can save/srestore the page scrolling
				if (this.getFocusElmt().is("input, select")) {
					// focus evt is triggered by dom focus
					this.getFocusElmt().focus();
				} else {
					// focus evt is triggered by application because the elmt doesn't actually take the focus
					// In next brother versions all kind of elements should accept focus
					notifications.publish("sm.field.focus", this);
				}
			}
		},
		/**
		 * Can be overridden (ctrlBinary...)
		 * Regular fields have an input
		 */
		getFocusElmt: function() {
			return this.$$input;
		},
		acceptFocus: function() {
			return this.getFocusElmt() != null;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/field/ctrlAlphanum',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/controls/validator','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var validator = require('syracuse-tablet/html/js/controls/validator').Validator;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _AlphaNum = utils.defineClass(
	function CtrlAlphaNum(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = {
			"penTextInput": true,
			"GPS": true,
			"scanBarcode": true
		};
		Base.call(this, controller, article, prototype, options);
	}, Base, {

		validateValue: function(value, errors) {
			var ok = Base.prototype.validateValue.call(this, value, errors);
			return ok && validator.validate(this, value, errors, ["$pattern", "$minLength", "$maxLength"]);
		},

		buildFieldValue: function(fieldSlot, buildOptions) {
			var valueSlot = Base.prototype.buildFieldValue.call(this, fieldSlot, buildOptions);
			var value = this.getFormattedValue(this.getValue());
			if (this.$isEditMode) {
				this.createMainInput(valueSlot, value);
			} else {
				this.appendTextValue(valueSlot, value);
			};
			return valueSlot;
		}

	});

var _PhoneField = utils.defineClass(

	function CtrlPhoneField(controller, article, prototype, options) {
		_AlphaNum.call(this, controller, article, prototype, options);
		this.cssType = "s-m-phone";
	}, _AlphaNum, {

		buildFieldValue: function(fieldSlot, buildOptions) {
			if (this.$isEditMode) {
				_AlphaNum.prototype.buildFieldValue.call(this, fieldSlot, buildOptions);
			} else {
				var value = this.getFormattedValue(this.getValue());
				var link = uiUtils.createDomElement("span", [], "", {
					"data-action": "externalLink",
					"data-params": "tel:" + value
				});
				if (value) {
					link.appendChild(uiUtils.createDomElement("span", fontUtils.phoneFieldIcon()));
					$(link).append(value);
				}
				fieldSlot.appendChild(link);
			}
		}
	});


var _EmailField = utils.defineClass(

	function CtrlEmailField(controller, article, prototype, options) {
		_AlphaNum.call(this, controller, article, prototype, options);
		this.cssType = "s-m-email";
	}, _AlphaNum, {

		buildFieldValue: function(fieldSlot, buildOptions) {
			if (this.$isEditMode) {
				_AlphaNum.prototype.buildFieldValue.call(this, fieldSlot, buildOptions);
			} else {
				var value = this.getFormattedValue(this.getValue());
				var link = uiUtils.createDomElement("span", [], "", {
					"data-action": "externalLink",
					"data-params": "mailto:" + value
				});
				if (value) {
					link.appendChild(uiUtils.createDomElement("span", fontUtils.emailFieldIcon()));
					$(link).append(value);
				}
				fieldSlot.appendChild(link);
			}
		}
	});
var _UrlField = utils.defineClass(

	function CtrlUrlField(controller, article, prototype, options) {
		_AlphaNum.call(this, controller, article, prototype, options);
		this.cssType = "s-m-url";
	}, _AlphaNum, {

		buildFieldValue: function(fieldSlot, buildOptions) {
			if (this.$isEditMode) {
				_AlphaNum.prototype.buildFieldValue.call(this, fieldSlot, buildOptions);
			} else {
				var value, link, asValue, $urlLink = this.prototype.getUrlLink(this.$bind),
					valueSlot;
				if ($urlLink.$url) {
					asValue = this.getValue() ? true : false;
					if (asValue) {
						valueSlot = _AlphaNum.prototype.buildFieldValue.call(this, fieldSlot, buildOptions);
					}
					if ($urlLink.$url.indexOf('{' + this.$bind + '}') < 0 || asValue) {
						value = this.prototype.resolveExpression($urlLink.$url, this._dao.data, true);
					}
				} else {
					value = this.getFormattedValue(this.getValue());
				}
				link = value ? uiUtils.createDomElement("span", [], "", {
					"class": "s-m-icon-link",
					"data-action": "externalLink",
					"data-params": value
				}) : null;
				if (link) {
					link.appendChild(uiUtils.createDomElement("span", []));
					$(link).addClass(this._getDefaultIcon());
					if (valueSlot) {
						valueSlot.appendChild(link);
					} else {
						fieldSlot.appendChild(link);
					}
				}
			}
		},
		_getDefaultIcon: function() {
			var css = "s-m-icon-" + (this.article.$urlIconSize || "small") + " ";
			return css + (this.article.$urlIcon || fontUtils.getUrlDefIcon()).css;
		}
	});
exports.Klass = _AlphaNum;
exports.PhoneField = _PhoneField;
exports.EmailField = _EmailField;
exports.UrlField = _UrlField;
});

define('syracuse-tablet/html/js/controls/field/ctrlFilter',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/field/ctrlFieldBase'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;

/**
 * application/x-filter type - found in requests prototypes
 * Added just to not have a Unknown field -TODO see what we should do with this field
 */
var _Filter = utils.defineClass(
	function CtrlFilter(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		Base.call(this, controller, article, prototype, options);
	}, Base, {

		buildFieldValue: function(fieldSlot, buildOptions) {
			var valueSlot = Base.prototype.buildFieldValue.call(this, fieldSlot, buildOptions);
			this.appendTextValue(valueSlot, this.getValue() || "");
		}

	});

exports.Klass = _Filter;
});

define('syracuse-tablet/html/js/controls/field/ctrlProgress',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/controls/field/ctrlFieldBase'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;

var defaultValues = {
	$valueMin: 0,
	$valueMax: 100
};

var _Klass = utils.defineClass(

	function CtrlProgress(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		Base.call(this, controller, article, prototype);
	}, Base, {
		buildFieldValue: function(fieldSlot, buildOptions) {
			var valueSlot = Base.prototype.buildFieldValue.call(this, fieldSlot, buildOptions);
			// building progress bar layout based on bootstrap component
			var value = this.getValue();
			var progressContainer = uiUtils.createDomElement("div", ["progress"]);
			var progressBar = uiUtils.createDomElement("div", ["progress-bar"], value, {
				"role": "progressbar",
				"aria-valuenow": value,
				"aria-valuemin": this.article.$valueMin || defaultValues.$valueMin,
				"aria-valuemax": this.article.$valueMax || defaultValues.$valueMax,
				"style": "width:" + value + "%;"
			});
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/field/ctrlNumeric',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/controls/validator','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var validator = require('syracuse-tablet/html/js/controls/validator').Validator;
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _Klass = utils.defineClass(

	function CtrlNumeric(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = {
			"penTextInput": true
		};
		Base.call(this, controller, article, prototype, options);
	}, Base, {

		buildFieldValue: function(fieldSlot, buildOptions) {
			var self = this;
			var valueSlot = Base.prototype.buildFieldValue.call(self, fieldSlot, buildOptions);
			$(valueSlot).addClass("s-m-numeric");
			var value = self.getFormattedValue(self.getValue());
			if (self.$isEditMode) {
				self.createMainInput(valueSlot, value);
			} else {
				self.appendTextValue(valueSlot, value);
			}
		},

		parseValue: function(value, errors) {
			var self = this;
			if (self.formatter) {
				var format = self.formatter.getFormat();
				if (format) {
					var gs = locale.getNumberGroupSeparator();
					var ds = locale.getNumberDecimalSeparator();

					if (format.indexOf(",") < 0 && gs && gs.length > 0) {
						// Format with no GS, consider eventual GS as DS
						value = value.replace(new RegExp("\\" + gs, "g"), ds);
					}
					if (format.indexOf(",") > 0 && format.indexOf(".") > 0 && gs && gs.length > 0) {
						// Format with GS and DS, consider GS as DS if no DS entered
						if (value.indexOf(gs) > -1 && value.indexOf(ds) < 0) {
							value = value.replace(new RegExp(gs, "g"), ds);
						}
					}
				}
			}
			return Base.prototype.parseValue.call(self, value, errors);
		},

		validateValue: function(value, errors) {
			var self = this;
			var ok = Base.prototype.validateValue.call(self, value, errors);
			ok = validator.validate(self, value, errors, ["$minimum", "$maximum", "$exclusiveMinimum", "$exclusiveMaximum", "$precision"]) && ok;
			if (self.$type !== "application/x-integer") {
				ok = validator.validate(self, value, errors, ["$scale"]) && ok;
			}
			return ok;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/field/ctrlQuantity',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/controls/ctrlFactory'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');

var _Klass = utils.defineClass(

	function CtrlQuantity(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		Base.call(this, controller, article, prototype, options);
		this.unitFieldInfo = prototype.getUnitFieldInfo();
		// Create extra control for UNIT in read only mode
		// !! if grid Cell we ca't create the control with createControl
		this.displayUnit = false;
		if (this.unitFieldInfo && this.unitFieldInfo.unitFieldProto && !this.unitFieldInfo.unitFieldProto.data("$isExcluded")) {
			this.displayUnit = options && options.displayCtx !== "table";
		}
		this.unitCtrl = null;
	}, Base, {

		initFormatter: function() {
			var valueProto = this.prototype.data('$value');
			if (!valueProto || !valueProto.$type) return null;
			return Base.prototype.initFormatter.call(this, valueProto.$type, valueProto.$format);
		},

		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this.unitCtrl) {
				this.unitCtrl.destroy();
				this.unitCtrl = null;
			}
		},

		buildHtml: function($$parent, controllerDao, buildOptions) {
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions);
			(this.$$elmt).addClass("s-m-qty");
			if (this.displayUnit) {
				this.unitCtrl = ctrlFactory.createControl(this.controller, this, {
					"$bind": this.unitFieldInfo.unitBindName,
					"$noAuthoring": true,
				}, this.unitFieldInfo.unitFieldProto, {
					isUnit: true
				});
				this.unitCtrl.buildHtml(this.$$value, controllerDao, buildOptions);
			}
		},

		buildFieldValue: function(fieldSlot, buildOptions) {
			var valueSlot = Base.prototype.buildFieldValue.call(this, fieldSlot, buildOptions);;
			$(valueSlot).addClass("s-m-numeric");
			var value = this.getFormattedValue(this.getValue());
			if (this.$isEditMode) {
				this.createMainInput(valueSlot, value);
			} else {
				this.appendTextValue(valueSlot, value);
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/field/ctrlCheckbox',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _Klass = utils.defineClass(

	function CtrlCheckbox(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		Base.call(this, controller, article, prototype, options);
	}, Base, {
		buildFieldValue: function(fieldSlot, buildOptions) {
			var valueSlot = Base.prototype.buildFieldValue.call(this, fieldSlot, buildOptions);
			var val = this.getValue();
			// Nothing displayed if no values otherwise we see only the icon (empty array cards)
			if (val == null && !this.$isEditMode) return;
			val = val === true;
			if (this.$isEditMode) {
				this.createMainInput(valueSlot, val, "checkbox");
			} else if (this.getAuthoring("$displayAs") === "text") {
				this.$$value.text(locale.text(val === true ? "yes" : "no"));
			} else {
				valueSlot.appendChild(uiUtils.createDomElement("span", fontUtils.checkBoxIcon(val)));
			}
		},
		onClick: function(evt) {
			var self = this;
			setTimeout(function() {
				var checked = !self.$$input.prop("checked");
				self.$$input.prop("checked", checked);
				self.setValue(checked);
			}, 50);
		}

	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/field/ctrlSwitch',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _Klass = utils.defineClass(

	function CtrlSwitch(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		Base.call(this, controller, article, prototype, options);
	}, Base, {
		destroy: function() {
			if (this.$$panel) {
				this.$$panel.bootstrapSwitch('destroy');
				this.$$panel = null;
			};
			Base.prototype.destroy.call(this);
		},
		buildFieldValue: function(fieldSlot, buildOptions) {
			var valueSlot = Base.prototype.buildFieldValue.call(this, fieldSlot, buildOptions);
			var val = this.getValue();
			// Nothing displayed if no values otherwise we see only the icon (empty array cards)
			if (val == null) return;
			val = val === true;
			if (this.$isEditMode) {
				var attrs = {
					"type": "checkbox"
				};
				this.$$panel = $(uiUtils.createDomElement("input", "", null, attrs, valueSlot));
				this.$$panel.bootstrapSwitch('state', val === true, true);
				this.$$panel.bootstrapSwitch('onText', locale.text("auth.switcher.onText"));
				this.$$panel.bootstrapSwitch('offText', locale.text("auth.switcher.offText"));
				this.$$panel.bootstrapSwitch('size', "small");
				this.$$panel.bootstrapSwitch('onColor', "default");
				this.$$panel.bootstrapSwitch('offColor', "default");
				this.$$panel.bootstrapSwitch('onSwitchChange', jsutils.bindFn(this.onSwitchChange, this));
			} else {
				valueSlot.appendChild(uiUtils.createDomElement("span", fontUtils.checkBoxIcon(val)));
			}
		},
		onSwitchChange: function() {
			this.setValue(this.$$panel.bootstrapSwitch('state'));
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/field/ctrlCombo',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/controls/field/ctrlFieldBase'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;

var _compareEnum = function(enum1, enum2) {
	if (!enum1 || !enum2) return false;
	if (enum1.length != enum2.length) return false;
	for (var i = 0, l = enum1.length; i < l; i++) {
		if (enum1.$value != enum2.$value) return false;
		if (enum1.$title != enum2.$title) return false;
	}
	return true;
};
var _Klass = utils.defineClass(

	function CtrlCombo(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		Base.call(this, controller, article, prototype, options);
	}, Base, {
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			this.radioItemList = null;
			this._choiceList = null;
			this.valueSlot = null;
		},
		/**
		 * Not called on refreshValue - only at creation
		 */
		buildFieldValue: function(fieldSlot, buildOptions) {
			// create the $$value slot at creation
			this.valueSlot = Base.prototype.buildFieldValue.call(this, fieldSlot, buildOptions);
			// Else _updateList manages the update of list and value
			this._updateList(this.getMetaData(), false);
		},
		/**
		 * Refresh only the value if it changed
		 */
		refreshValue: function(buildOptions) {
			this._updateList(this.getMetaData(), true);
		},
		_updateList: function(metaData, valueChanged) {
			var self = this;
			if (!self.valueSlot) return;
			var newList = metaData && metaData.$value ? metaData.$value.$enum : null;
			if (valueChanged !== true && _compareEnum(newList, self._choiceList)) return;
			$(self.valueSlot).empty();
			// We need to clone because the deltaManager modifies the content of the list
			self._choiceList = $.extend(true, [], newList);
			if (self.$isEditMode) {
				var $format = metaData ? metaData.$format : null;
				if (!$format) {
					$format = self.prototype.data("$format");
				}
				// if '$format' is set it can only have values '$combo' or '$radio'
				if ($format && ($format != '$radios' && $format != '$combo')) {
					$format = '$combo';
				}
				// ## set display in case of edit mode ##
				var value = self.currentValue = self.getValue();
				var domValue;
				if (self._choiceList.length > 0) {
					// display in case of '$radios' format
					if ($format == '$radios') {
						self.radioItemList = [];
						$.each(self._choiceList, function(index, choiceItem) {
							// building choice item display
							var choiceItemDom = uiUtils.createDomElement("div", ["s-m-field-radio-item"]);
							var inputDom = uiUtils.createDomElement("input", ["s-m-field-choice-radio", "ctrl-evt-click", "s-m-meta"], null, {
								"type": "radio",
								"value": index,
								"name": "s-m-radio-" + self.id
							});
							if (value && choiceItem.$value == value) {
								inputDom.setAttribute("checked", true);
							}
							var titleDom = uiUtils.createDomElement("div", ["s-m-field-choice-radio-title"], choiceItem.$title);

							// build radioItemList array
							self.radioItemList.push({
								"inputDom": inputDom,
								"titleDom": titleDom
							});
							// appending to parent layout
							self.valueSlot.appendChild(inputDom);
							self.valueSlot.appendChild(titleDom);
						});
					}
					// default format is '$combo'
					else {
						var selectDom = uiUtils.createDomElement("select", ["form-control ctrl-evt-change", "s-m-meta"]);
						// build list
						var selected = false;
						var opts = [],
							optDom;
						$.each(self._choiceList, function(index, choiceItem) {
							var parsedTitle = self.prototype.resolveExpression(choiceItem.$title);
							optDom = uiUtils.createDomElement("option", null, parsedTitle, {
								"value": choiceItem.$value
							}, null);
							if (choiceItem.$value == value) {
								optDom.setAttribute("selected", true);
								selected = true;
							}
							opts.push(optDom);
						});
						self.valueSlot.appendChild(selectDom);
						// Apply metaData.$isReadOnly and/or metaData.$isDisabled on select
						// select can only be set as readonly with the 'disabled' attribute
						if (metaData.$isReadOnly || metaData.$isDisabled) {
							selectDom.setAttribute("disabled", true);
						} else {
							selectDom.removeAttribute("disabled");
						}
						if (!selected) {
							if (opts.length > 0) {
								//#7129 - If no value provided by the server we display a blank line and select it
								// This case is not usual if functional developer takes care of providing a value
								// No text like 'Choose a value...' because we don't know the size of the select - TODO Improve
								// The best way would be to manage our own select without select tag
								opts.push(uiUtils.createDomElement("option", ["empty"], "", {
									"value": "",
									"selected": true
								}, null));
								if (metaData && metaData.$isMandatory) {
									//#7129 - If it's a mandatory field we remove the blank line after having selecting a value
									$(selectDom).addClass("removeEmptyOption");
								}
							}
							if (value != null) {
								//#7129 - If value is defined but not found in list we display an error message - For quality to detect inconsistencies
								// Message is removed on click
								this.showInputErrors(locale.text("unexpected.value", [" (" + value + ")"]));
								$(selectDom).addClass("ctrl-evt-click", true);
							}
						}
						//#7129 - IE doesn't work fine if we insert an empty option in the dom $(select).prepend($opt)- So we attach options at the end 
						opts.forEach(function(opt) {
							selectDom.appendChild(opt);
						});
					}
				}
			} else if (self._choiceList.length > 0) {
				// ## set display in case of edit mode ##
				var value = self.currentValue = self.getValue();
				value = self._getChoiceTitle(value);
				value = self.prototype.resolveExpression(value);
				self.appendTextValue(self.valueSlot, value);
			}
		},
		_getChoiceTitle: function(value) {
			var res;
			$.each(this._choiceList, function(index, choice) {
				res = choice.$value == value ? choice.$title : res;
				if (res) {
					return false;
				}
			});
			return res;
		},
		getChoiceTitles: function() {
			var res = [],
				self = this;
			$.each(this._choiceList, function(index, choice) {
				res.push({
					$value: choice.$value,
					title: self.prototype.resolveExpression(choice.$title)
				});
			});
			return res;
		},
		_getChoiceValue: function(title) {
			var res;
			$.each(this._choiceList, function(index, choice) {
				res = choice.$title == title ? choice.$value : res;
				if (res) {
					return false;
				}
			});
			return res;
		},
		setDisplayValue: function(value, index) {
			var self = this;
			if (self.$isEditMode) {
				// in case of radio choice
				if (self.prototype.data("$format") == '$radios') {
					// apply change if new value
					if (value != self.currentValue) {
						// update widget
						$.each(self.radioItemList, function(idx, radioItem) {
							setTimeout(function() {
								// if new choice index is defined
								if (index) {
									radioItem.inputDom.checked = index == idx;
								}
								// if new choice index is not defined
								else {
									radioItem.inputDom.checked = self._choiceList[idx].$value == value;
								}
							}, 5);
						});
					}
				}

			}
		},

		setFieldValue: function(value, index) {
			this.setDisplayValue(value, index);
			this.currentValue = value;
			this.setValue(value);
		},

		onClick: function(evt) {
			var $$t = $(evt.target);
			if (this.prototype.data("$format") == '$radios') {
				this.setFieldValue(this._getChoiceValue(evt.target.nextElementSibling.textContent), $(evt.target.parentNode).index());
			} else if ($$t.is("select")) {
				////#7129 - Clear unexpected value error message if any
				this.clearInputErrors();
				// No more click
				$$t.removeClass("ctrl-evt-click");
			}
		},

		onChange: function(evt) {
			var $$t = $(evt.target);
			if ($$t.is("select") && $$t.is(".removeEmptyOption")) {
				// //#7129 - remove the empty option
				$$t.removeClass("removeEmptyOption").find("option.empty").remove();
			}
			this.setFieldValue(evt.target.value, evt.target.selectedIndex);
		},
		applyMetaData: function(metaData, buildOptions) {
			Base.prototype.applyMetaData.call(this, metaData, buildOptions);
			this._updateList(metaData);
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/monthChoice',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/types/date'],function (require, exports, module) {"use strict";
var utils = require('syracuse-tablet/html/js/helpers/utils');
var _dateApi = require('syracuse-tablet/html/js/helpers/types/date');

var _Klass = utils.defineClass(

	function() {

	}, null, {
		create: function(parentSlot, dateValue, handler) {
			this.parent = parentSlot;
			this.handler = handler;
			this.domItem = document.createElement("nav");
			this.domItem.className = "s-calendar-quick-list";
			this._dateValue = dateValue;
			var table = document.createElement("table");
			table.className = "s-calendar-month-choice";
			var tbody = document.createElement("tbody");
			for (var ii = 0; ii < 6; ii++) {
				var row = document.createElement("tr");
				row.appendChild(this.drawCell(ii + 1, _dateApi.monthName(ii + 1, true), this._dateValue.month));
				row.appendChild(this.drawCell(ii + 7, _dateApi.monthName(ii + 7, true), this._dateValue.month));
				tbody.appendChild(row);
			}
			table.appendChild(tbody);
			this.domItem.appendChild(table);
			this.parent.appendChild(this.domItem);
			this.bindEvents(true);
		},
		drawCell: function(value, text, selValue) {
			var td = document.createElement("td");
			td.className = "s-calendar-my-item";
			td.syraOnClick = "onMonthClick";
			td.syraValue = value;
			td.textContent = text;
			if (value == selValue) {
				td.className += " s-calendar-select";
				this.selectedCell = td;
			}
			return td;
		},
		toggle: function(show) {
			if (show) {
				this.domItem.style.display = "";
			} else {
				this.domItem.style.display = "none";
			}
		},
		onMonthClick: function(picker) {
			if (this.selectedCell) {
				this.selectedCell.className = "s-calendar-my-item";
			}
			(this.selectedCell = picker).className = "s-calendar-my-item s-calendar-select";
			this._selectedMonth = picker.syraValue;
			var month = this._selectedMonth ? this._selectedMonth : this._dateValue.month;
			this._currentDate = this._dateValue = _dateApi.fromJsDate(new Date(this._dateValue.year, month - 1, this._dateValue.day));
			this.handler.onEvent("onCalendarUpdate", this);
		},
		bindEvents: function(bind) {
			var self = this;
			if (bind) {
				$(self.domItem).delegate("td", "click", function(evt) {
					self.onClick(evt);
					evt.preventDefault();
					evt.stopPropagation();
				});
			} else {
				$(self.domItem).undelegate();
			}
		},
		onClick: function(evt) {
			var self = this;
			while (evt.target) {
				if (evt.target.syraOnClick) {
					this[evt.target.syraOnClick](evt.target, evt);
					return;
				} else {
					evt.target = evt.target.parentNode;
				}
			}
		},
		destroy: function() {
			this.bindEvents(false);
			this.domItem = this._dateValue = this.selectedCell = null;
		}
	});

exports.MonthChoice = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/yearChoice',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/types/date'],function (require, exports, module) {"use strict";
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var _dateApi = require('syracuse-tablet/html/js/helpers/types/date');


var _Klass = utils.defineClass(

	function() {

	}, null, {
		create: function(parentSlot, dateValue, handler) {
			this.parent = parentSlot;
			this.domItem = document.createElement("nav");
			this.domItem.className = "s-calendar-quick-list";
			this.handler = handler;
			this._dateValue = dateValue;
			this._selectedYear = this._dateValue.year;
			var table = document.createElement("table");
			table.className = "s-calendar-year-choice";
			var tbody = document.createElement("tbody");
			this.rows = [];
			for (var ii = 0; ii < 6; ii++) {
				var row = document.createElement("tr");
				if (ii == 0) {
					this.addPrevNextCell(row, true);
					this.addPrevNextCell(row, false);
				} else {
					var cuYear = this._dateValue.year + ii - 4;
					row.appendChild(this.drawCell(cuYear, cuYear));
					row.appendChild(this.drawCell(cuYear + 5, cuYear + 5));
				}
				tbody.appendChild(row);
				this.rows.push(row);
			}
			table.appendChild(tbody);
			this.domItem.appendChild(table);
			this.parent.appendChild(this.domItem);
			this.bindEvents(true);
		},
		addPrevNextCell: function(row, isPrev) {
			var td = document.createElement("td");
			td.className = "s-calendar-my-link-cell";
			var link = document.createElement("a");
			link.className = (link.syraIsPrev = isPrev) ? "s-calendar-prev-year" : "s-calendar-next-year";
			link.textContent = (link.syraIsPrev = isPrev) ? locale.text("date.month.label.prev") : locale.text("date.month.label.next");
			link.syraOnClick = "onChangeYear";
			td.appendChild(link);
			row.appendChild(td);
		},
		drawCell: function(value, text) {
			var td = document.createElement("td");
			td.className = "s-calendar-my-item";
			td.syraOnClick = "onSelectYear";
			td.syraValue = value;
			td.textContent = text;
			if (value == this._selectedYear) {
				td.className += " s-calendar-select";
				this.selectedCell = td;
			}
			return td;
		},
		toggle: function(show) {
			if (show) {
				this.domItem.style.display = "";
			} else {
				this.domItem.style.display = "none";
			}
		},
		_refreshYearCell: function(td, step) {
			td.syraValue += step;
			td.textContent = td.syraValue;
			if (td.syraValue == this._selectedYear) {
				td.className += " s-calendar-select";
				this.selectedCell = td;
			}
		},
		onChangeYear: function(picker) {
			var step = picker.syraIsPrev ? (-10) : 10;
			for (var ii = 1, jj = this.rows.length; ii < jj; ii++) {
				var nodes = this.rows[ii].childNodes;
				this._refreshYearCell(nodes[0], step);
				this._refreshYearCell(nodes[1], step);
			}
		},
		onSelectYear: function(picker) {
			if (this.selectedCell) {
				this.selectedCell.className = "s-calendar-my-item";
			}(this.selectedCell = picker).className = "s-calendar-my-item s-calendar-select";
			this._selectedYear = picker.syraValue;
			var year = this._selectedYear ? this._selectedYear : this._dateValue.year;
			this._currentDate = this._dateValue = _dateApi.fromJsDate(new Date(year, this._dateValue.month, this._dateValue.day));
			this.handler.onEvent("onCalendarUpdate", this);
		},
		bindEvents: function(bind) {
			var self = this;
			if (bind) {
				$(self.domItem).delegate("td", "click", function(evt) {
					self.onClick(evt);
					evt.preventDefault();
					evt.stopPropagation();
				});
			} else {
				$(self.domItem).undelegate();
			}
		},
		onClick: function(evt) {
			var self = this;
			while (evt.target) {
				if (evt.target.syraOnClick) {
					this[evt.target.syraOnClick](evt.target, evt);
					return;
				} else {
					evt.target = evt.target.parentNode;
				}
			}
		},
		destroy: function() {
			this.bindEvents(false);
			//this.parent.removeChild(this.domItem);
			this.rows = this.domItem = this._dateValue = this.selectedCell = null;
		}
	});

exports.YearChoice = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/types/date','syracuse-tablet/html/js/ui/datetimeSelectors/monthChoice','syracuse-tablet/html/js/ui/datetimeSelectors/yearChoice'],function (require, exports, module) {"use strict";
var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var _dateApi = require('syracuse-tablet/html/js/helpers/types/date');
var MonthChoice = require('syracuse-tablet/html/js/ui/datetimeSelectors/monthChoice').MonthChoice;
var YearChoice = require('syracuse-tablet/html/js/ui/datetimeSelectors/yearChoice').YearChoice;

var _Klass = utils.defineClass(

	function() {

	}, null, {
		onClick: function(evt) {
			var self = this,
				close;
			while (evt.target && evt.target != self.handler.parentSlot) {
				if (evt.target.getAttribute("data-s-syraOnClick")) {
					close = this[evt.target.getAttribute("data-s-syraOnClick")](evt.target, evt);
					if (close) {
						this.handler.closeContainer();
					}
					return;
				} else {
					evt.target = evt.target.parentNode;
				}
			}
		},
		onTodayClick: function() {
			this._currentDate = _dateApi.today();
			this.field.setFieldValueFromSelector(_dateApi.fromInternalValue(this._currentDate._value).toString());
			return true;
		},
		onDayClick: function(picker) {
			this.field.setFieldValueFromSelector(_dateApi.fromInternalValue(picker.getAttribute("data-s-syraValue")).toString());
			return true;
		},
		onChangePeriode: function(picker) {
			if (picker.getAttribute("data-s-syraPeriod") == "month") {
				this._currentDate = this._currentDate.addMonths(picker.getAttribute("data-s-syraIsPrev") ? -1 : 1);
			} else if (picker.getAttribute("data-s-syraPeriod") == "year") {
				this._currentDate = this._currentDate.addYears(picker.getAttribute("data-s-syraIsPrev") ? -1 : 1);
			} else {
				this._currentDate = this._currentDate.addDays(picker.getAttribute("data-s-syraIsPrev") ? -7 : 7);
			}
			this.handler.onEvent("onCalendarUpdate", this);
		},
		onMonthClick: function() {
			this.handler.onEvent("onMonthClick", this);
		},
		onYearClick: function() {
			this.handler.onEvent("onYearClick", this);
		},
		getValueForSelector: function(field) {
			return field.getValue() && field.getValue().slice(0, 10);
		},
		create: function(field, handler) {
			this.domItem = document.createElement("div");
			this.domItem.className = "s-calendar";

			var value = this.getValueForSelector(field) || "";

			this._selectedDate = value ? _dateApi.parse(value) : _dateApi.today();
			this._selectedDate = this._selectedDate._value == 0 ? _dateApi.today() : this._selectedDate;
			this._currentDate = handler._currentDate || _dateApi.fromInternalValue(this._selectedDate._value);

			this.field = field;
			this.handler = handler;

			this._table = document.createElement("table");
			this._table.setAttribute("cellspacing", 0);
			this._table.className = "s-calendar-content";
			this._table.appendChild(this._appendHead());
			this._table.appendChild(this.body = document.createElement("tbody"));
			this._table.appendChild(this._appendFoot());
			this.domItem.appendChild(this._table);

			this._drawBody();

			return this.domItem;
		},
		_appendHead: function() {
			var head = document.createElement("thead");
			var row = document.createElement("tr");
			var cell = document.createElement("th");
			cell.setAttribute("colspan", 8);
			cell.className = "s-calendar-month-year";

			var slot = document.createElement("div");
			slot.className = "s-calendar-month-year-slot";
			cell.appendChild(slot);

			// prev year link
			var link = document.createElement("a");
			link.setAttribute("data-s-syraOnClick", "onChangePeriode");
			link.setAttribute("data-s-syraIsPrev", true);
			link.setAttribute("data-s-syraPeriod", "year");
			link.className = "s-calendar-prev s-calendar-prev-year glyphicon glyphicon-fast-backward";
			slot.appendChild(link);

			// prev month link
			link = document.createElement("a");
			link.setAttribute("data-s-syraOnClick", "onChangePeriode");
			link.setAttribute("data-s-syraIsPrev", true);
			link.setAttribute("data-s-syraPeriod", "month");
			link.className = "s-calendar-prev s-calendar-prev-month glyphicon glyphicon-step-backward";
			slot.appendChild(link);

			this._monthLink = document.createElement("a");
			this._monthLink.className = "s-month s-calendar-month-year-link";
			slot.appendChild(this._monthLink).setAttribute("data-s-syraOnClick", "onMonthClick");

			this._yearLink = document.createElement("a");
			this._yearLink.className = "s-year s-calendar-month-year-link";
			slot.appendChild(this._yearLink).setAttribute("data-s-syraOnClick", "onYearClick");

			// next month link
			link = document.createElement("a");
			link.setAttribute("data-s-syraOnClick", "onChangePeriode");
			link.setAttribute("data-s-syraPeriod", "month");
			link.className = "s-calendar-next s-calendar-next-month glyphicon glyphicon-step-forward";
			slot.appendChild(link);

			// next year link
			link = document.createElement("a");
			link.setAttribute("data-s-syraOnClick", "onChangePeriode");
			link.setAttribute("data-s-syraPeriod", "year");
			link.className = "s-calendar-next s-calendar-next-year glyphicon glyphicon-fast-forward";
			slot.appendChild(link);

			row.appendChild(cell);
			head.appendChild(row);

			row = document.createElement("tr");
			var cell = document.createElement("th");
			cell.className = "s-calendar-week-day";
			row.appendChild(cell);

			var days = [1, 2, 3, 4, 5, 6, 0];
			for (var ii = 0, jj = days.length; ii < jj; ii++) {
				var cell = document.createElement("th");
				cell.className = "s-calendar-week-day";
				cell.title = _dateApi.dayName(days[ii]);
				cell.textContent = _dateApi.dayName(days[ii], true);
				row.appendChild(cell);
			}
			head.appendChild(row);
			return head;
		},
		_appendFoot: function() {
			var row = document.createElement("tr");
			var cell = document.createElement("td");
			cell.setAttribute("colspan", 3);
			cell.className = "s-calendar-foot-week";

			var link = document.createElement("a");
			link.setAttribute("data-s-syraOnClick", "onChangePeriode");
			link.setAttribute("data-s-syraPeriod", "week");
			link.className = "s-calendar-prev s-calendar-prev-week glyphicon glyphicon-chevron-left";
			link.setAttribute("data-s-syraIsPrev", true);
			cell.appendChild(link);

			var label = document.createElement("label");
			label.className = "s-calendar-foot-week-title";
			label.textContent = locale.text("date.label.week");
			cell.appendChild(label);

			this._weekNumber = document.createElement("label");
			this._weekNumber.className = "s-calendar-foot-week-title-num";
			cell.appendChild(this._weekNumber);

			link = document.createElement("a");
			link.setAttribute("data-s-syraOnClick", "onChangePeriode");
			link.setAttribute("data-s-syraPeriod", "week");
			link.className = "s-calendar-next s-calendar-next-week glyphicon glyphicon-chevron-right";
			cell.appendChild(link);
			row.appendChild(cell);

			cell = document.createElement("td");
			cell.setAttribute("colspan", 3);
			cell.className = "s-calendar-foot-today";
			link = document.createElement("a");
			link.className = "s-calendar-today-link";
			link.setAttribute("data-s-syraOnClick", "onTodayClick");

			link.textContent = locale.text("date.label.today");
			cell.appendChild(link);
			row.appendChild(cell);

			cell = document.createElement("td");
			cell.setAttribute("colspan", 2);

			row.appendChild(cell);

			var foot = document.createElement("tfoot");
			foot.appendChild(row);
			return foot;
		},
		_drawBody: function() {

			var curMonth = this._currentDate.month || 9;
			var month = _dateApi.monthName(curMonth);

			this._monthLink.textContent = month;
			this._yearLink.textContent = this._currentDate.year || 2014;

			uiUtils.empty(this.body);

			var curDate = _dateApi.fromInternalValue(this._currentDate._value);
			var begOfMonth = curDate = curDate.begOfMonth();
			curDate = curDate.begOfWeek(1);

			for (var weekRow = 0; weekRow < 6; weekRow++) {
				var row = document.createElement("tr");
				var weekDay = (weekRow == 0) ? begOfMonth : curDate;
				var cell = document.createElement("td");
				cell.className = "s-calendar-week-num";
				row.appendChild(cell);
				cell.textContent = weekDay.week;
				for (var day = 0; day < 7; day++) {
					var cell = document.createElement("td");
					cell.className = "s-calendar-day-link";
					cell.setAttribute("data-s-syraOnClick", "onDayClick");
					cell.setAttribute("data-s-syraValue", curDate._value);
					var link = document.createElement("a");
					link.textContent = curDate.day;
					if (curMonth != curDate.month) {
						cell.className += " s-calendar-other-month";
					}
					if (this._currentDate.equals(curDate)) {
						cell.className += " s-calendar-select";
						link.className = "s-calendar-select";
					}
					cell.appendChild(link);
					row.appendChild(cell);
					curDate = curDate.addDays(1);
				}
				this.body.appendChild(row);
			}
			this._weekNumber.textContent = this._currentDate.week;
		},
		bindEvents: function(bind) {
			var self = this;
			var parentSlot = self.handler.getParentSlot();
			if (bind) {
				$(parentSlot).delegate("td, a", "click", function(evt) {
					self.onClick(evt);
					evt.preventDefault();
					evt.stopPropagation();
				});
			} else {
				$(parentSlot).undelegate();

				// unbind monthchoice and yearchoice components if necessary
				if (self._month) {
					self._month.bindEvents(false);
				}
				if (self._year) {
					self._year.bindEvents(false);
				}
			}
		},
		destroy: function() {
			this.bindEvents(false);
			this._currentDate = this.field = this._currentDate = this.quickList = this._month = this._year = this._selectedDate = this._monthLink = this._yearLink = this._weekNumber = this._quick = this.body = this.domItem = null;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/timeSelector',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/types/time','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";
var utils = require('syracuse-tablet/html/js/helpers/utils');
var _timeApi = require('syracuse-tablet/html/js/helpers/types/time');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _Klass = utils.defineClass(

	function() {

	}, null, {
		onClick: function(evt) {
			var self = this,
				close;
			while (evt.target) {
				if (evt.target.getAttribute("data-s-syraOnClick")) {
					close = this[evt.target.getAttribute("data-s-syraOnClick")](evt.target, evt);
					if (close) {
						this.handler.closeContainer();
					}
					return;
				} else {
					evt.target = evt.target.parentNode;
				}
			}
		},
		setContainer: function($$modalElmt) {
			this.$$modalElmt = $$modalElmt;
		},
		create: function(field, handler, cb) {

			this.domItem = document.createElement("div");
			this.domItem.className = "s-time-choice";

			var options = options || {};
			this.columns = options.columns || 2;
			this.interval = options.interval || 60;

			this.field = field;
			this.handler = handler;
			this.cb = cb;

			this.curTime = _timeApi.now();

			var cellCount = (24 * 60) / this.interval;
			var rowCount = cellCount / this.columns;

			var table = document.createElement("table");
			table.className = "s-time-choice-table";
			table.setAttribute("cellspacing", "0");
			table.setAttribute("cellpadding", "0");

			var row, cell;
			var cellIndex = 0;
			var timeHour = _timeApi.parse("00:00:00");
			for (var rr = 0; rr < rowCount; rr++) {
				row = document.createElement("tr");
				for (var col = 0; col < this.columns; col++) {
					cell = document.createElement("td");
					cell.className = "s-time-choice-td";
					if (cellIndex < cellCount) {
						var link = document.createElement("a");
						link.className = "s-time-choice-a";
						link.setAttribute("data-s-syraOnClick", "onTimeClick");
						if (timeHour.hour == this.curTime.hour) {
							link.className += " s-time-select";
						}
						link.textContent = timeHour.toString(locale.getTimeFormat());
						cell.appendChild(link);
					}
					row.appendChild(cell);
					timeHour = timeHour.addMinutes(this.interval);
					cellIndex++;
				}
				table.appendChild(row);
			}
			this.domItem.appendChild(table);
			return this.domItem;
		},
		onTimeClick: function(picker) {
			var self = this;
			var fieldVal = _timeApi.parse(picker.textContent, locale.getTimeFormat()).toString();
			if (!this.cb) {
				self.field.setFieldValueFromSelector(fieldVal);
				return true;
			} else {
				self.cb(fieldVal, self.handler);
			}
		},
		bindEvents: function(bind) {
			var self = this;
			var parentSlot = self.handler.getParentSlot();
			if (bind) {
				$(parentSlot).delegate("a", "click", function(evt) {
					self.onClick(evt);
					evt.preventDefault();
					evt.stopPropagation();
				});
			} else {
				$(parentSlot).undelegate();
			}
		},
		destroy: function() {
			this.bindEvents(false);
			this.domItem = this.field = this.selectedLink = null;
		}
	});
exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/selectorSwitchHandler',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/datetimeSelectors/monthChoice','syracuse-tablet/html/js/ui/datetimeSelectors/yearChoice','syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector','syracuse-tablet/html/js/ui/datetimeSelectors/timeSelector'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require("syracuse-tablet/html/js/ui/uiUtils");
var MonthChoice = require('syracuse-tablet/html/js/ui/datetimeSelectors/monthChoice').MonthChoice;
var YearChoice = require('syracuse-tablet/html/js/ui/datetimeSelectors/yearChoice').YearChoice;
var DateSelector = require('syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector').Klass;
var TimeSelector = require('syracuse-tablet/html/js/ui/datetimeSelectors/timeSelector').Klass;

var _Klass = utils.defineClass(

	function(field) {
		this.field = field;
	}, null, {
		/**
		Triggers an action when the following events occurs :
		- onMonthClick : When user clicks on month selection link
		- onYearClick : When user clicks on year selection link
		- onOpenTime : In case of datetime field, when user has selected the date, time selector must be displayed afterwards
		- onCalendarUpdate : When user clicks on links that will reshape the calendar (change month, change year, change week, select month, select year)
		- onSelectTime : In case of datetime field, when user has selected the time, field must be set with appropriate date + time value

		@param	evt 		Triggered event in set as string
		@param	selector 	The selector object. Use to get value and for destroy action
		*/
		onEvent: function(evt, selector) {
			this[evt](selector);
		},

		/*
			Set the $$container of the date / time selectors which is likely to be the modal.
			It will make it easier to close it from within the library
			@param	$$container 	Jquery container object (the modal)
		*/
		setContainer: function($$container) {
			this.$$container = $$container;
		},

		/*
			Set parentSlot dom parameter. Useful to make some dom actions like emptying or appending.
			It is the modal body
			@param parentSlot Modal body.

		*/
		setParentSlot: function(parentSlot) {
			this.parentSlot = parentSlot;
		},


		/*
			Returns parentSlot dom parameter
		*/
		getParentSlot: function() {
			return this.parentSlot;
		},

		/*
			Triggered when user clicks on month selection link. It builds the month selector
			@param 	selector 	The selector object. Use to get value and for destroy action
		*/
		onMonthClick: function(selector) {
			var self = this;
			// save date
			var date = selector._currentDate;

			// clear previous selector
			uiUtils.empty(self.parentSlot);
			selector.destroy();

			// create month selector
			var monthChoice = new MonthChoice();
			monthChoice.create(this.parentSlot, date, self);
		},

		/*
			Triggered when user clicks on year selection link. It builds the year selector
			@param 	selector 	The selector object. Use to get value and for destroy action
		*/
		onYearClick: function(selector) {
			var self = this;
			// save date
			var date = selector._currentDate;

			// clear previous selector
			uiUtils.empty(self.parentSlot);
			selector.destroy();

			// create month selector
			var yearChoice = new YearChoice();
			yearChoice.create(self.parentSlot, date, self);
		},


		/*
			Triggered in case of datetime field. It builds time selector after user clicked on date
			@param 	selector 	The selector object. Use to get value and for destroy action
		*/
		onOpenTime: function(selector) {
			var self = this;

			// save date
			self.dateValue = selector.dateValue;

			// clear previous selector
			uiUtils.empty(self.parentSlot);
			selector.destroy();

			// create time selector
			var timeSelector = new TimeSelector();
			var sDom = timeSelector.create(self.field, self, self.onSelectTime);
			self.parentSlot.appendChild(sDom);
			timeSelector.bindEvents(true);
		},

		/*
			Triggered when user clicks on link that will update the calendar. It builds the calendar with updated value
			@param 	selector 	The selector object. Use to get value and for destroy action
		*/
		onCalendarUpdate: function(selector) {
			var self = this;

			// save date
			self._currentDate = selector._currentDate;

			// clear previous selector
			uiUtils.empty(self.parentSlot);
			selector.destroy();

			// create back date selector
			var dateSelector = new DateSelector();
			var sDom = dateSelector.create(self.field, self);
			self.parentSlot.appendChild(sDom);
			dateSelector.bindEvents(true);
		},

		/*
			Triggered in case of datetime field. It sets the final field value and closes the container (the modal)
			@param 	selector 	The selector object. Use to get value and for destroy action
		*/
		onSelectTime: function(timeVal, handler) {
			var self = handler;
			self.field.setFieldValueFromSelector(self.dateValue + " " + timeVal);
			self.closeContainer();
		},

		/*
			Closes the container (the modal here)
		*/
		closeContainer: function() {
			this.$$container.modal("hide");
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/datetimeSelector',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/types/date','syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector'],function (require, exports, module) {"use strict";
var utils = require('syracuse-tablet/html/js/helpers/utils');
var _dateApi = require('syracuse-tablet/html/js/helpers/types/date');
var Base = require('syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector').Klass;

var _Klass = utils.defineClass(

	function() {

	}, Base, {
		onTodayClick: function() {
			this._currentDate = _dateApi.today();
			this.dateValue = _dateApi.fromInternalValue(this._currentDate._value).toString();
			this.handler.onEvent("onOpenTime", this);
		},
		onDayClick: function(picker) {
			this.dateValue = _dateApi.fromInternalValue(picker.getAttribute("data-s-syraValue")).toString();
			this.handler.onEvent("onOpenTime", this);
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/ui/selectorFactory',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector','syracuse-tablet/html/js/ui/datetimeSelectors/selectorSwitchHandler','syracuse-tablet/html/js/ui/datetimeSelectors/datetimeSelector','syracuse-tablet/html/js/ui/datetimeSelectors/selectorSwitchHandler','syracuse-tablet/html/js/ui/datetimeSelectors/timeSelector','syracuse-tablet/html/js/ui/datetimeSelectors/selectorSwitchHandler'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');

var _selectors = {
	date: {
		"windows": null,
		"android": null,
		"ios": null,
		"default": require('syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector').Klass,
		"handler": require('syracuse-tablet/html/js/ui/datetimeSelectors/selectorSwitchHandler').Klass
	},
	datetime: {
		"windows": null,
		"android": null,
		"ios": null,
		"default": require('syracuse-tablet/html/js/ui/datetimeSelectors/datetimeSelector').Klass,
		"handler": require('syracuse-tablet/html/js/ui/datetimeSelectors/selectorSwitchHandler').Klass
	},
	time: {
		"windows": null,
		"android": null,
		"ios": null,
		"default": require('syracuse-tablet/html/js/ui/datetimeSelectors/timeSelector').Klass,
		"handler": require('syracuse-tablet/html/js/ui/datetimeSelectors/selectorSwitchHandler').Klass
	}
};
var getType = function(propertyType) {
	var type;
	switch (propertyType) {
		case "application/x-date":
			type = "date";
			break;
		case "application/x-datetime":
			type = "datetime";
			break;
		case "application/x-time":
			type = "time";
			break;
		default:
			type = null;
	}
	return type;
};
/*
	Returns appropriate selector controller according to field type
	@param	propertyType 	Field property type application/x-{date,time,datetime}
*/
var getSelector = function(propertyType) {
	var type = getType(propertyType);
	if (type === null)
		throw new Error("Expected date/time/datetime type. Got " + propertyType);
	var laf = globals.getLookAndFeel();
	var selector = _selectors[type]; // select for type
	if (selector) {
		selector = selector[laf] || selector["default"]; // select per OS or use default
	}

	if (!selector) {
		throw new Error("Expected type. Got " + propertyType);
	}
	return new selector();
};

var getHandler = function(field) {
	var type = getType(field.$type);
	if (type === null)
		throw new Error("Expected date/time/datetime type. Got " + field.$type);
	var selector = _selectors[type]; // handler for type
	if (selector) {
		var handler = selector["handler"];
	}

	if (!handler) {
		return null;
	}
	return new handler(field);
};

/*
	Creates selector widget
	@param	field 	Field controller
*/
var _createSelector = function(field) {
	if (!field || !field.setFieldValueFromSelector) {
		throw new Error("_createSelector - Field must implement setFieldValueFromSelector");
	}
	// selector handler

	var sHandler = getHandler(field);

	// selector controller (date/time/datetime according to type)
	var ctrlSelector = getSelector(field.$type);

	// selector dom
	var selectorDom = ctrlSelector.create(field, sHandler);

	var $$selectorModal = modal.field(field.getTitle(), selectorDom.outerHTML, function(modalEvent, $$modalElmt) {
		// build content on open
		if (modalEvent == 'shown.bs.modal') {
			if (sHandler) {
				sHandler.setContainer($$modalElmt);
				sHandler.setParentSlot($$modalElmt.find(".modal-body")[0]);
			}
			ctrlSelector.bindEvents(true);

		}
		// run actions on close 'hidden.bs.modal'
		else {
			ctrlSelector.destroy();
		}
	});

};

exports.createSelector = _createSelector;
});

define('syracuse-tablet/html/js/controls/field/ctrlDate',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/ui/selectorFactory','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var selectorFactory = require('syracuse-tablet/html/js/ui/selectorFactory');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _Klass = utils.defineClass(

	function CtrlBase(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		Base.call(this, controller, article, prototype, options);
	}, Base, {
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
		},
		buildFieldValue: function(fieldSlot, buildOptions) {
			var valueSlot = Base.prototype.buildFieldValue.call(this, fieldSlot, buildOptions);
			var value = this.getFormattedValue(this.getValue());
			if (this.$isEditMode) {
				// first
				this.addPicker("date", fontUtils.getIconByName(this.$type === "application/x-date" ? "datePicker" : "timePicker"));
				this.createMainInput(valueSlot, value);
			} else {
				this.appendTextValue(valueSlot, value);
			}
		},
		_actDatePicker: function() {
			selectorFactory.createSelector(this);
		},
		setFieldValue: function(value) {
			if (this.$type.indexOf("datetime") > -1 && value.length <= 10) {
				value += "T00:00:00.0Z";
			}
			Base.prototype.setFieldValue.call(this, value);
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/array/searchArray',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/fieldOperators'],function (require, exports, module) {"use strict";
var utils = require('syracuse-tablet/html/js/helpers/utils');
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');

var _templates = {
	basicSearch: '\
		<nav class="s-m-search">\
            <div class="input-group stylish-input-group">\
                <input type="text" class="form-control"  placeholder="Search"  value="{{searchValue}}" >\
                <span class="input-group-addon">\
                    <span style="visibility:{{visibleRemove}}" class="glyphicon glyphicon-remove" data-action="actionArray" data-params="removeSearch"></span>\
					<span class="glyphicon glyphicon-search" data-action="actionArray" data-params="search"></span>\
                </span>\
            </div>\
		</nav>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

var _exclude = ["application/x-boolean"];

var _Klass = utils.defineClass(
	/**
	 * savedContext is the context stored when we go to a child/detail page (see this.savedCtxCreate)
	 * It allows the page (query) to add the clause in sdataUrl at loading
	 */
	function(savedContext) {
		this.searchValue = savedContext ? savedContext.searchValue || "" : "";
		this.searchInfos = this.searchValue ? savedContext.searchInfos || [] : [];
		this.maxCrit = 13;
	}, null, {
		destroy: function() {
			this.searchValue = null;
			this.$$search = null;
			this.searchInfos = null;
		},
		getHtml: function() {
			var self = this;
			self.$$search = $(_getHtml("basicSearch", {
				searchValue: self.searchValue,
				visibleRemove: self.searchValue !== "" ? "visible" : "hidden"
			}));
			return self.$$search;
		},
		removeSearch: function(ctrl) {
			this.searchValue = "";
			this.searchInfos = [];
		},
		search: function(ctrl) {
			this.searchValue = $(":input", this.$$search).val();
			this.searchInfos = (this.searchValue != "") ? this._filterInfosGet(ctrl) : [];
		},
		_filterInfosGet: function(ctrl) {
			var columnInfo = ctrl.builder.getColumnsInfo(true);
			var proto = ctrl.prototype.create(ctrl.prototype.getDataByPath("$item"));
			var props = proto.data("$properties");
			var control, $bind, $type, $capabilities, self = this,
				formatter,
				criteria = [],
				errors, val, $isReference;

			columnInfo.forEach(function(column) {
				control = column.control;
				$bind = column.$bindValue;
				$type = (column.$type != "application/x-choice") ? column.$bindType : column.$type;
				$isReference = (column.$type.indexOf("x-reference") >= 0);
				$capabilities = column.$capabilities || "";
				if ($capabilities.indexOf("filter") >= 0 && criteria.length < self.maxCrit) {
					if (_exclude.indexOf($type) < 0 && self._hackFormat(props[$bind])) {
						if ($type !== "application/x-choice") {
							errors = [];
							val = null;
							formatter = formatApi.getFormatter($type, props[$bind].$format);
							if (!formatter) {
								val = self.searchValue;
							} else {
								val = formatter.parseValue(self.searchValue, errors);
							}
							if ($isReference && val) val = val.toUpperCase();
							if (errors.length === 0 && val !== undefined) {
								criteria.push({
									operator: fieldOperators.getDefaultOperator($type),
									id: $bind,
									value: val,
									prop: props[$bind],
									isReference: $isReference
								});
							}
						} else {
							var valueList = self._getChoiceTitles(column.$value, proto);
							valueList.forEach(function(val) {
								if (val.title.indexOf(self.searchValue) > -1 && criteria.length < self.maxCrit) {
									criteria.push({
										operator: fieldOperators.getDefaultOperator($type),
										id: $bind,
										value: val.$value,
										prop: props[$bind],
										isReference: $isReference
									});
								}
							});
						}
					}
				}
			});
			return criteria;
		},
		_getChoiceTitles: function($value, proto) {
			var res = [],
				self = this;
			$.each($value.$enum, function(index, choice) {
				res.push({
					$value: choice.$value,
					title: proto.resolveExpression(choice.$title)
				});
			});
			return res;
		},
		//Waitting for X3 format manager with strict mode
		_hackFormat: function(proto) {
			var searchable = true;
			switch (proto.$type) {
				case "application/x-integer":
					var gs = locale.getNumberGroupSeparator();
					var ds = locale.getNumberDecimalSeparator();
					searchable = !isNaN((gs && gs.length > 0) ? this.searchValue.replace(new RegExp("\\" + gs + "|\\s", "g"), "") : this.searchValue);
					searchable = searchable && ((ds && ds.length > 0) ? this.searchValue.indexOf(ds) < 0 : true);
					break;
				case "application/x-decimal":
				case "application/x-real":
				case "application/x-integer":
				case "application/x-quantity":
					searchable = !isNaN(this.searchValue.replace(new RegExp("\\.|,|\\s", "g"), ""));
					break;
				default:
					searchable = (proto.$maxLength) ? (this.searchValue.length <= proto.$maxLength) : true;
			};
			return searchable;
		},
		getSearchInfos: function() {
			return this.searchInfos;
		},
		// type	back/link - Used to manage the content according to the type
		savedCtxCreate: function(type) {
			return {
				searchValue: this.searchValue,
				searchInfos: this.searchInfos,
			};
		},
		savedCtxRestore: function(ctx) {
			// No need because ut's done at the creation of the array - Not the regular process	
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/array/builderBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/scroller/scrollerHelpers','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var _filterSortPanelId = globals.PANELFILTERSORT;

var _templates = {
	pagin: '\
			<nav class="s-m-pagin"> \
				<ul class="pagination"> \
					{{#each links}}\
						<li>\
							<a class="s-m-link {{css}}"\
								href = "#"\
								data-action="pagination"\
								data-params="{{type}}"\
								data-control-id="{{id}}"\
								draggable="false">\
							</a>\
						</li>\
					{{/each}}\
				</ul> \
			</nav> \
		',
	filterSort: '\
		<div class="s-m-filterSort" data-action="actionArray" data-params="{{panelId}}">\
			<i class="s-m-sorted" style="display:none"></i>\
			<i class="s-m-filtered ' + fontUtils.filterIcon("filtered") + '" style="display:none"></i>\
			<i class="' + fontUtils.filterIcon("panel") + '"></i>\
		</div>',
	$filtersList: '\
		<nav class="s-m-filterslist">\
			<select	class="form-control" data-action="actionArray">\
				{{#each filters}}\
					<option value="filterSelected,{{id}}" {{#if $isDefault}}selected=""{{/if}}>{{$title}}</option>\
				{{/each}}\
			</select>\
		</nav>',
	$filterstabs: '\
		<nav class="s-m-filtertabs">\
			<ul class="nav nav-pills nav-justified">\
				{{#each filters}}\
					<li role="presentation" role="tab" data-toggle="tab" data-action="actionArray" data-params="filterSelected,{{id}}" class="{{#if $isDefault}}active{{/if}}"><a href="#">{{$title}}</a></li>\
				{{/each}}\
			</ul>\
		</nav>'

};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	if (!tmpl) alert("template " + name + " not found");
	return tmpl(ctx);
};

var _isExcluded = ["application/x-password"];
var _paginLinks = ["$first", "$previous", "$next", "$last"];
/**
 * Array builder base class
 * Authoring global properties
 * 		$isTitleHidden		Hide the column title
 * 		$rowIdx				Show/Hide row index
 */
var _Klass = utils.defineClass(
	function(control, disp, options) {
		this.$display = disp;
		this.options = options || {};
		if (control == null) throw new Error("Null control");
		this.control = control;
		this.$articleArray = control.article;
		this.$arrayOptions = this.$articleArray.$arrayOptions;
		this.$itemProto = control.prototype.getPrototype("$item");
		this._gestureMgr = null;
		this._lastSelectedRow = null;
	}, null, {
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			// Nested array controls are not stored in controller (gerenateHtml)
			// We need to destoy the scroller
			// To not destroy the scroller we should keep the context off the builder in parent control to destroy all children context when we destroy the parent
			this.destroyScroller();
			this._$$stdHeader = null;
			this._lastSelectedRow = null;

		},
		destroy: function() {
			this.control = null;
			if (this.$itemProto) {
				// We destroy the proto
				this.$itemProto.destroy();
				this.$itemProto = null;
			}
			this.destroyScroller();
		},
		isDestroyed: function() {
			return this.control == null || this.control.destroyed;
		},
		refresh: function(arrayData, buildOptions) {
			buildOptions = buildOptions || {};
			// Option for buildHtml
			buildOptions.refresh = true;
			this.buildHtml(arrayData, buildOptions);
		},
		/**
		 * $$value parent that contains the table - same strcture for all controls
		 * 	arrayData is an object that contains all data needed by array
		 * 	arrayData.$resources contains rows data - Array of dao
		 */
		buildHtml: function(arrayData, buildOptions, classes) {},
		isRefreshContext: function(buildOpts) {
			// We force display if it's an array in a card because there's no resize in that case
			return (buildOpts && (buildOpts.refresh === true || buildOpts.cardDesign === true)) || (this.options && this.options.displayCtx === "card");
		},
		checkEmptyArray: function() {
			if (!this.control._displayArray()) {
				this.control.$$value.empty();
				if (this.control.isEmpty) {
					this.refreshHeaderAndGesture();
					this.control.setEmptyArrayMsg();
				}
				return false;
			}
			return true;
		},
		/**
		 * Parent control notifies the builder taht it's going to clear the content
		 * Overridden by chart builder
		 */
		notifClearContent: function(refresh) {
			// Nothing 
		},
		/**
		 * Can be overridden to clear cached data
		 */
		notifyArrayDataChanged: function(refresh, arrayData, isEmpty) {
			this.destroyScroller();
		},
		onResize: function(context) {
			this.refreshHeaderAndGesture(context);
		},
		doAfterBuild: function(resizeContext, refreshHeaderGesture) {
			if (refreshHeaderGesture || this._needToBuildHeader()) {
				// refreshes the gestureMgr
				this.refreshHeaderAndGesture(resizeContext);
			}
			if (this.control.controller.prototype.isFacet("details", "edit", "create")) {
				// We notify the controller because arrays are built asynchronously - #6541
				// Only detail/edit because for queries the scroller is managed by the array (refreshHeaderAndGesture);
				notifications.notifyController("sm.scroller.update", this.control.controller);
			}
		},
		_needToBuildHeader: function() {
			if (this._arrayHeaderWasCreated === true) {
				return false;
			}
			var $filtersAuth = null;
			var headerOpts = this.getHeaderOptions();
			if (headerOpts && headerOpts.$filters && headerOpts.$filters.length > 1) {
				$filtersAuth = this.control.controller.$filtersGetAuthoring ? this.control.controller.$filtersGetAuthoring() : null;
			}
			return this._isHeaderVisible($filtersAuth);
		},

		/**
		 * Init gesture manager on onResize because we need to calculate the viewRect
		 */
		refreshHeaderAndGesture: function(resizeContext) {
			var scrollOnly = resizeContext != null && resizeContext.scrollOnly;
			var preserveScroll = resizeContext != null && resizeContext.preserveScroll;
			// we refresh only if it's a windows resize (other type if internalResize)
			var justRefresh = resizeContext != null && resizeContext.resizeEvent && resizeContext.resizeEvent.type === "resize";
			/**
			 * Workaround to check if the display of filters changed
			 */
			if (scrollOnly !== true) {
				this._refreshHeader(justRefresh);
			}
			this._initGestureMgr(preserveScroll);
			if (this._lastSelectedRow) {
				/**
				 * Workaround to preserve last selected line
				 * onResize broke the regular process and onResize is call when we activate a cached page
				 * lastRowSelection is done before the onResize (page.activate) so we need to preserve the selection
				 * Here because the build of array is asynchronous so we can't call this code in ctrlArray.onResize
				 */
				this.selectLastSelectedRow(this._lastSelectedRow, true);
			}
		},
		_initGestureMgr: function(preserveScroll) {
			if (this._gestureMgr) {
				if (this.isScrollable()) {
					// ScrollViewRect has changed so we check to re-init or reset _gestureMgr 
					this._gestureMgr.checkViewRect(this.control.getScrollViewRect(), preserveScroll);
				} else {
					this._gestureMgr.reset();
				}
			}
			if (this._restoreSelectedRowId) {
				// Restore the selected row - We do the job here to be able to make the line visible 
				var $$row = this.selectLastSelectedRow(this._restoreSelectedRowId, true);
				if ($$row && this._gestureMgr) {
					// Scroll to make row visible
					this._gestureMgr.makeVisible($$row);
				}
				this._restoreSelectedRowId = null;
			}
		},
		/**
		 * Can be overridden
		 */
		isScrollable: function() {
			return this.control.getArrayData().$resources.length > 0;
		},
		/**
		 * Display an error
		 */
		insertError: function(html) {
			$(['<span class="s-m-error">', html, "</span>"].join('')).prependTo(this.control.$$elmt);
		},
		/**
		 * Returns the option for header
		 * Can be overridden by a child builder
		 */
		getHeaderOptions: function() {
			var queryOrLookup = !this.control.isArrayField();
			var controller = this.control.controller;
			var opts = {};
			// This is a query array
			// Manual sort/filters
			opts.filterEnabled = opts.sortEnabled = opts.searchEnabled = queryOrLookup;
			opts.paginEnabled = opts.searchEnabled = queryOrLookup || this.control.hasLocalPagination();
			opts.searchEnabled = (opts.searchEnabled && !controller.offLine);
			// Filters given by prototype
			opts.$filters = queryOrLookup && controller.$filtersGet ? controller.$filtersGet() : null;
			// No search and filters for requests
			if (controller.prototype.isRequest() || controller.prototype.isStatistics()) {
				opts.sortEnabled = opts.searchEnabled = opts.filterEnabled = false;
				opts.$filters = null;
			}
			return opts;
		},
		/**
		 * Refreshed header and filters
		 * We need to call _refreshHeader in onResize and buildHtml
		 * We display filters/sort and $filter when array is empty -> We need to be able to modify the filter if result returns no data
		 */
		_refreshHeader: function(justRefresh) {
			var $filtersAuth = null;
			var headerOpts = this.getHeaderOptions();
			if (headerOpts && headerOpts.$filters && headerOpts.$filters.length > 1) {
				$filtersAuth = this.control.controller.$filtersGetAuthoring ? this.control.controller.$filtersGetAuthoring() : null;
			}
			if (justRefresh !== true && this._isHeaderVisible($filtersAuth)) {
				this.control.$$header.children(".s-m-stdheader").remove();
				this._buildArrayHeader(this.control.getArrayData(), $filtersAuth);
			}
			if ($filtersAuth === "tabs") {
				// Displayed below  _$$stdHeader
				this.control.$$header.find(".s-m-filtertabs").remove();
				this._build$Filters(headerOpts.$filters, $filtersAuth);
			}
		},
		_isHeaderVisible: function($filtersAuth) {
			return this.$arrayOptions.showPagination ||
				this.$arrayOptions.showSortFilter ||
				this.$arrayOptions.showSearch ||
				$filtersAuth === "list";

		},
		_buildArrayHeader: function(arrayData, $filtersAuth) {
			var headerOpts = this.getHeaderOptions() || {};
			var empty = true;
			this._arrayHeaderWasCreated = true;
			this._$$stdHeader = $('<nav class="s-m-stdheader"/>').prependTo(this.control.$$header);
			if (headerOpts.paginEnabled === true && this.$arrayOptions.showPagination === true && !this.control.isCarouselDisplay()) {
				if (this.control.isEmpty !== true || globals.isAuthoringActive()) {
					// Displays pagination on empty array if authoring mode
					this._buildPagin(this._$$stdHeader, arrayData);
				}
				empty = false;
			}

			// Search displayed even if array is empty in case it returns no data
			if (headerOpts.searchEnabled === true && this.$arrayOptions.showSearch === true) {
				this._$$stdHeader.append(this.control.getSearcher().getHtml());
				empty = false;
			}
			// Filters displayed even if array is empty in case the filter returns no data
			if ((headerOpts.filterEnabled === true || headerOpts.sortEnabled === true) &&
				this.$arrayOptions.showSortFilter === true) {
				this._buildSortFilter(this._$$stdHeader);
				empty = false;
			}
			if ($filtersAuth === "list") {
				this._build$Filters(headerOpts.$filters, $filtersAuth);
				empty = false;
			}
			this._$$stdHeader.toggle(!this._$$stdHeader.is(":empty"));
		},
		_build$Filters: function(filters, $filtersAuth) {
			if (!$filtersAuth || $filtersAuth == "none") return;
			if ($filtersAuth == "list") {
				$(_getHtml("$filtersList", {
					filters: filters
				})).appendTo(this._$$stdHeader);
				return;
			}
			if ($filtersAuth == "tabs") {
				// #6725 in tab mode, we do not show the "all" filter since it feels strange
				var filtersWithoutAll = [];
				for (var i = 1; i < filters.length; i++) {
					filtersWithoutAll.push(filters[i]);
				}
				// #6884 if there's only one filter we don't show it since  it feels also strange
				if (filtersWithoutAll.length > 1) {
					$(_getHtml("$filterstabs", {
						filters: filtersWithoutAll
					})).appendTo(this.control.$$header);
				}
				return;
			}
		},
		_buildPagin: function($$parent, arrayData) {
			var self = this;
			var ctxLinks = {
				links: []
			};
			var designMode = globals.isAuthoringActive();
			var nbEnabled = 0;
			var noPagin = false;
			if ((designMode && self.control.getLocalPaginator() != null) || self.control.hasLocalPagination()) {
				noPagin = !self.control.hasLocalPagination();
				var paginator = self.control.getLocalPaginator();
				_paginLinks.forEach(function(linkName) {
					var ctx = {
						css: fontUtils.paginationIcon(linkName)
					};
					if (!noPagin && paginator.isActionEnabled(linkName)) {
						ctx.type = linkName;
						ctx.id = self.control.id;
						nbEnabled++;
					} else {
						ctx.css += " disabled";
					}
					ctxLinks.links.push(ctx);
				});
			} else if (designMode || (arrayData.$links && !$.isEmptyObject(arrayData.$links))) {
				noPagin = arrayData.$links == null || $.isEmptyObject(arrayData.$links);
				// We display pagination in authoring even if no links
				_paginLinks.forEach(function(linkName) {
					var ctx = {
						css: fontUtils.paginationIcon(linkName)
					};
					if (!noPagin && arrayData.$links && arrayData.$links[linkName] != null) {
						ctx.type = linkName;
						ctx.id = self.control.id;
						nbEnabled++;
					} else {
						// Always disable in designMode
						ctx.css += " disabled";
					}
					ctxLinks.links.push(ctx);
				});
			}
			// FDB - If all actions are disabled we don't display pagination
			if (nbEnabled > 0 && ctxLinks.links.length > 0) {
				$(_getHtml("pagin", ctxLinks)).prependTo($$parent);
			}
		},
		_buildSortFilter: function($$parent) {
			this._$$sortFilter = $(_getHtml("filterSort", {
				ctrlId: this.control.id,
				panelId: _filterSortPanelId
			}));
			$$parent.append(this._$$sortFilter);
			var sortOrder = null,
				sortField = null,
				hasFilter = false;
			var info = this.control.sortInfoGet();
			if (info) {
				// select the first sorted column
				// Currently we support sorting on only one column
				// -> We can display a asc/desc icon in the header
				// Sort panel can manage sorting on multiple columns but it's disabled
				info.some(function(i) {
					if (i.sort != "none") {
						sortOrder = i.sort;
						sortField = i.id;
						return true;
					}
				});
			}
			var info = this.control.filterInfoGet();
			hasFilter = info && info.length > 0;
			this.filterSortUpdate(sortOrder, sortField, hasFilter);
		},
		/**
		 * Update icons when sort change
		 * Can be overridden
		 */
		filterSortUpdate: function(sortOrder, sortField, hasFilter) {
			if (!this._$$stdHeader) return;
			var $$icon = this._$$stdHeader.find(".s-m-sorted").toggle(sortOrder != null).removeClass();
			if (sortOrder != null) {
				$$icon.addClass("s-m-sorted " + fontUtils.sortIcon(sortOrder));
			}
			this._$$stdHeader.find(".s-m-filtered").toggle(hasFilter === true);
		},
		/**
		 * Can be overridden - lookup
		 * This is the DOM element that contains the record
		 * 	class		s-m-record
		 * 	data-params	rowId
		 * Action (edit/detail/delete) which are children of this element use data-param as parameter see hack in eventistener._bindActions
		 * 	rowId is generated only one time
		 */
		buildRecordMainElmt: function(rowData, options, idx) {
			if (!options || !options.tag) {
				throw new Error("buildRecordMainElmt - Bad options");
			}
			options.css = options.css || [];
			options.css.unshift(globals.RECORDCLASS);
			var rowId = rowData ? rowData.getValue("$uuid") : null;
			if (rowId && this.control.acceptRowSelection() === true) {
				this._addRowSelAction(options, rowId);
			}
			var elmt = uiUtils.createDomElement(options.tag, options.css, options.title, options.attrs, options.parent);
			if (globals.isAutoUITestMode()) {
				globals.getUnitTestMgr().arrayAddRowIndex($(elmt), idx, rowData);
			}
			return elmt;
		},
		/**
		 * Add Row Select action
		 */
		_addRowSelAction: function(options, rowId) {
			options.attrs = options.attrs || {};
			// We set data-params on the main dom element of the record (RECORDCLASS)
			options.attrs["data-params"] = encodeURIComponent(rowId);
			if (!this.control.controller.isEditMode()) {
				if (options.tag === "a") {
					options.attrs["href"] = "#";
				}
				// Trigger an action in array control for additional processes before open link
				options.attrs["data-action"] = globals.ACTROWSEL;
			} // In edit mode we just put the rowID - no select action (edit row action)
		},
		/**
		 * True if field is excluded
		 */
		isExcluded: function(proto) {
			return proto == null || proto.$isExcluded === true || _isExcluded.indexOf(proto.$type) >= 0;
		},
		/**
		 * Returns control id eventually concatenated with arguments
		 * 	Allows to get unic ids for control childs if needed
		 */
		getId: function() {
			var self = this;
			if (arguments.length > 0) {
				return self.control.id + " - " + Array.prototype.join.call(arguments, '-');
			} else {
				return self.control.id;
			}
		},
		_getRowById: function(rowId) {
			return this.control.$$elmt.find('tbody .' + globals.RECORDCLASS + '[data-params="' + rowId + '"]');
		},
		removeRowById: function(rowId) {
			return this._getRowById(rowId).remove();
		},
		/**
		 * lastSelectedRow is restored when after a back action - See page.savedCtxRestore
		 */
		selectLastSelectedRow: function(rowId, show) {
			this._lastSelectedRow = rowId ? rowId : null;
			if (rowId == null) {
				this.control.$$value.find('.s-m-last-selected').removeClass("s-m-last-selected");
			} else {
				return this._getRowById(rowId)[show ? "addClass" : "removeClass"]("s-m-last-selected");
			}
		},
		getSelectedRowId: function() {
			return this.control.$$elmt.find("." + globals.RECORDCLASS + ".s-m-last-selected").attr('data-params');
		},
		callGenerateHtml: function(ctrlToGenerate, $$parent, rowData, destroyAfter, buildOptions, idx) {
			buildOptions = buildOptions || {};
			// htmlRootCtrl is the array control that is stored in memory
			// If we have a card array X with other arrays displayed inside the card (multiple levels) htmlRootCtrl is X
			// -> used to store info if needed (rowDetail links/edit/delete) (see array.rowDetailAdd)
			// -> Like controls are not stord as object in memory (we just generate html) we need to store info for actions in htmlRootCtrl
			var htmlRootCtrl = buildOptions.htmlRootCtrl || this.control;
			// Build HTML
			var $$elmt = ctrlToGenerate.generateHtml($$parent, rowData, htmlRootCtrl, buildOptions.updateLayout);
			if (this.control.prototype.isSingleArray() && idx != null) {
				var meta = ctrlToGenerate.getMetaData();
				// For single array we hide the row if the cell is hidden
				// We hide also the edit/delete buttons if readOnly or disabled
				var d;
				if (ctrlToGenerate.$type === "application/x-reference") {
					//#5344 - $isHidden is stored in data ??
					d = rowData.getValue(globals.SINGLEARRAYPROP);
				} else if (rowData.parent && rowData.parent.data.$properties) {
					// For int collection meta are stores in an array in $properties of array field 
					d = rowData.parent.data.$properties;
					if (d && d[rowData.$bind]) {
						d = d[rowData.$bind].$items[idx];
					}
				}
				if (d) {
					if (!meta) meta = {};
					["$isHidden", "$isReadOnly", "$isDisabled"].forEach(function(p) {
						if (d[p] != null) meta[p] = d[p];
					});
				}
				if (meta.$isHidden === true || meta.$isReadOnly) {
					// Hide row or hide button with readonly
					$$elmt.closest(".s-m-record").addClass(meta.$isHidden ? "hidden" : "readonly");
				}
				ctrlToGenerate.applyMetaData(meta, buildOptions);
			}
			// reste $$elmt to not destroy it when we'll destroy the control
			ctrlToGenerate.$$elmt = null;
			if (destroyAfter === true) {
				// Destroy if needed
				ctrlToGenerate.destroy();
			}
			return $$elmt;
		},
		addEmptyCells: function(rootLayout, $$row, nb, buildOptions, $$wrapper) {
			var self = this;
			if (nb < 1) return;
			// dispEmpty: withtitle, filled, empty
			var dispEmpty = self.$articleArray.$emptycell;
			if (dispEmpty === "withtitle" || dispEmpty === "filled") {
				var $$td = $('<td class="s-m-empty s-m-' + dispEmpty + ' nohover">');
				if ($$wrapper) {
					$$parent = $$wrapper.appendTo($$td);
				}
				var $$parent;
				for (var i = 0; i < nb; i++) {
					$$parent = $$td.clone().appendTo($$row);
					if ($$wrapper) $$parent = $$parent.children().first();
					this.callGenerateHtml(rootLayout, $$parent, null, false, buildOptions);
				}
			}
			return $$row.children("td.s-m-empty");
		},
		/**
		 * Return the context to save.
		 * It will be be restored afer page has been loaded
		 * The context is saved and restored by the page
		 * Stores the scroll index
		 * type	back/link
		 */
		savedCtxCreate: function(type) {
			var ctx = {
				$display: this.$display,
				lastSelectedRow: this._lastSelectedRow
			};
			if (type === "link" || !this._gestureMgr) {
				// When we send a link by email we don't restore the scroll
				return ctx;
			}
			ctx.gestureMgr = this._gestureMgr.savedCtxCreate();
			return ctx;
		},
		savedCtxRestore: function(ctx) {
			if (ctx.gestureMgr != null && this.$display === ctx.$display) {
				if (this._gestureMgr) {
					// Restore context and refresh only if $display didn't change
					this._gestureMgr.savedCtxRestore(ctx.gestureMgr, true);
				} else {
					this._restoreGestureMgr = ctx.gestureMgr;
				}
			}
			if (ctx.lastSelectedRow) {
				this._restoreSelectedRowId = ctx.lastSelectedRow;
			}
		},
		newScroller: function(type, $$elmt, options) {
			// Set gesture manager - disabled - Enabled onResize
			this.destroyScroller();
			/**
			 * We wrap a parent that will give the Height/Width for scrolling
			 */
			options = $.extend({
				direction: type,
				name: this.control.$bind,
				isPageScroller: false
			}, options);
			if (options.valMax == null) {
				options.valMax = 0;
			};
			this._gestureMgr = scroller.newScroller($$elmt, options, globals.getMainPageGestureMgr());
			if (this._restoreGestureMgr != null) {
				this._gestureMgr.savedCtxRestore(this._restoreGestureMgr, false);
				this._restoreGestureMgr = null;
			}
			return this._gestureMgr;
		},
		destroyScroller: function() {
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},
		hasScroller: function() {
			return this._gestureMgr != null;
		},
		/**
		 * Must be called after buildHtml
		 * True if a singme array is empty - $isHidden on all records
		 */
		isEmptySingleArray: function() {
			if (!this.control || !this.control.getArrayData()) return false;
			if (this.control.getArrayData().length > 0) return false;
			return this.control.prototype.isSingleArray() && this.control.$$value.find(".s-m-record.hidden").length === this.control.getArrayData().$resources.length;
		},
		isColumnDisplayed: function($bind) {
			var cols = this.getColumnsInfo(true);
			if (!cols) return false;
			return cols.some(function(c) {
				return c.$bind === $bind;
			});
		},
		getColumnsInfo: function(onlyVisible) {
			throw new Error("Not implemented");
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/array/builderTable',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/controls/array/builderBase','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/controls/ctrlFactory'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var builderBase = require('syracuse-tablet/html/js/controls/array/builderBase');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var Base = builderBase.Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var reqProto = require('syracuse-tablet/html/js/helpers/prototype');;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');

var _fixedSzInfo = {};
/**
 * Calculates the sizes for characters, iconCells
 */
var _getFixedSizeInfo = function($$table) {
	var dev = globals.getSiteLayout().getDeviceType();
	var r = _fixedSzInfo[dev];
	if (r) return r;
	var $$body = $('<tbody></body>').appendTo($$table);
	var $$tr = $('<tr class="s-m-record"><td><div class="s-m-control s-m-field" style="width:100%"><div class="s-m-value" style="width:100%" ><span style="width:100%" id="text">MMMMMMMMMM</span></div></div></td><td class="s-m-icon"><div class="s-m-control s-m-icon"><a href="#" class="a"><span class="fa fa-hand-o-right"></span></a></div></td></tr>');
	$$tr.appendTo($$body);
	var tdWidth = $$tr.find("td").outerWidth();
	var valWidth = $$tr.find(".s-m-value").outerWidth();
	var textWidth = $$tr.find("#toto").width();
	r = {
		cellPadding: tdWidth - valWidth,
		charWidth: Math.ceil($$tr.find("#text").width() / 10),
		iconWidth: $$tr.find("td.s-m-icon").outerWidth()
	};
	$$body.remove();
	_fixedSzInfo[dev] = r;
	return r;
};


/**
 * Return a table cell control
 * Article is calculated from the fieldProto
 */
var _createCellControl = function(arrayCtrl, $$parent, colInfo, fieldProto) {
	var article = {
		"$bind": colInfo.$bind
	};
	return ctrlFactory.createCellFieldCtrl($$parent, arrayCtrl.controller, colInfo.article || colInfo, fieldProto);
};

var _isExcluded = ["application/json", "application/x-array", "application/x-document", "application/x-binary"];
var _ADDROW = "$ADDROW";
// !! $activity same code as page.$activity
var _addRowBtn = {
	$activity: "create",
	$type: "tablet/x-button",
	$icon: "addrow",
	$bind: _ADDROW,
	$text: "grid.addrow.label",
	$action: "rowCreate",
	$capabilities: ["append"]
};
var _additionalCols = [{
	$type: "tablet/x-icon",
	css: ["s-m-icon"],
	$activity: "edit",
	$icon: "editrow",
	$bind: "$EDITROW",
	$action: globals.ACTROWDETAIL
}, {
	$type: "tablet/x-icon",
	css: ["s-m-icon"],
	$activity: "edit",
	$icon: "delrow",
	$bind: "$DELETEROW",
	$action: globals.ACTROWDEL,
	$capabilities: "delete"
}, {
	$type: "tablet/x-icon",
	css: ["s-m-icon"],
	$activity: "read",
	$icon: "detailrow",
	$bind: "$DETAILROW",
	$action: globals.ACTROWDETAIL
}];

var _templates = {
	sortedHeader: '<div><span>{{title}}</span><i class="{{css}}"></i></div>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};
/**
 * x-array control class
 * Array authoring - $article
 * 		$items 				Columns authoring
 * 				$title			Override the title
 * 				$width			Set the width
 * 				$isAdvanced		Not displayed in grid
 */
var _Klass = utils.defineClass(
	function(control, disp, options) {
		Base.call(this, control, disp, options);
		this._columnInfo = null;
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._columnInfo) {
				this._columnInfo.forEach(function(col) {
					if (col.control) col.control.destroy();
				});
				this._columnInfo = null;
			}
		},
		buildHtml: function(arrayData, buildOpts) {
			buildOpts = buildOpts || {};
			Base.prototype.buildHtml.call(this, arrayData, buildOpts);
			if (this._createColumnInfo(buildOpts).length > 0) {
				if (this.isRefreshContext(buildOpts)) {
					// Force display because there's no resize
					this._build(buildOpts);
				} // Otherwise build is done on resize
			} else {
				this.control.$$value.addClass("empty");
			}
		},
		notifyArrayDataChanged: function(refresh, arrayData, isEmpty) {
			Base.prototype.notifyArrayDataChanged.call(this, refresh, arrayData, isEmpty);
			// Clear cached data here
		},
		onResize: function(context) {
			if (this.isDestroyed()) return;
			// Used by multi-selection - we just want to refresh the scroll
			var scrollOnly = context != null && context.scrollOnly === true;
			if (scrollOnly != true && this._columnInfo && this._columnInfo.length > 0) {
				var buildOpts = {
					updateLayout: context && context.updateLayout
				};
				this._build(buildOpts, context);
			} else {
				Base.prototype.onResize.call(this, context);
			}
		},
		/**
		 * We need to build the table on resize when the table is visible to calculate widths		 *
		 */
		_build: function(buildOpts, resizeContext) {
			if (!this.checkEmptyArray()) {
				return;
			}
			buildOpts = buildOpts || {};
			var self = this;
			var initScroll = buildOpts.refresh === true || resizeContext;
			self.control.$$value.empty();
			var arrayData = self.control.getArrayData();
			if (!arrayData) return;
			var scrollMax = 0;
			var $$table = $('<table class="table table-condensed"/>').appendTo(self.control.$$value);
			self._calulateWidths($$table, arrayData);
			// _buildTableHead build the regular header and return a clone of it
			// To scroll the body we need two tables
			// -> one that displays only the header
			// -> another one that display the body with same header (to preserve columns widths) but this heaedr is hidden
			// $$headerScroll is a clone of the regular header 
			var $$headerScroll = self._buildTableHead($$table, buildOpts);
			if (arrayData.$resources.length > 0 || self.control.controller.isEditMode) {
				var scrollable = this.isScrollable();
				// We create an other table without header to scroll the body
				if (scrollable) {
					$$table = $('<table class="table table-condensed"/>').appendTo(self.control.$$value);
					// We can't hide the header of the row that scrolls - We pu visibility hidden and minimize the height
					// We put an offset of -1 * $$headerScroll.height() to the scrollwrapper to better hide $headerScroll
					$$headerScroll.css({
						fontSize: "0px",
						visibility: "hidden"
					}).appendTo($$table);
					if (self.$$tabHead && self.$$tabHead.length > 0 && $$headerScroll != self.$$tabHead) {
						var top = -1 * $$headerScroll.height();
						$$table.css("top", top + "px");
						self.$$tabHead.css("z-index", 500000);
						if (!globals.isNativeScrolling()) {
							// We need to shift up the scroll in hammerScroll
							scrollMax = top;
						}
					}
				}
				var $$body = $(uiUtils.createDomElement('tbody', null, null, null, $$table));
				var size = _getFixedSizeInfo($$body);
				// Build rows
				for (var i = 0; i < arrayData.$resources.length; i++) {
					self._buildTableRow($$body, arrayData.$resources[i], i, buildOpts);
				}
				self._buildTableFoot($$table, arrayData, buildOpts);
				// Create a scroller -> initialized onResize
				if (scrollable) {
					// WE SCROLL ONLY ARRAYS IN QUERY OR LOOKUP
					// Set gesture manager - disabled - Enabled onResize
					self.newScroller("v", $$table.addClass("s-m-scroll-elmt").wrap('<div class="s-m-scroll-wrapper"/>'), {
						nopadding: true,
						valMax: scrollMax
					});
				} else {

				}
			}
			this.doAfterBuild(resizeContext, true);
		},
		isScrollable: function() {
			return this.control.$type === ctrlFactory.type("arrayChart") || (!this.control.isArrayField() && !this.control.controller.isNestedInDashboard("stack"));
		},
		/**
		 * Caluclate fixed widths according to authoring properties
		 * To improve
		 */
		_calulateWidths: function($$table, arrayData) {
			var self = this;
			var size = _getFixedSizeInfo($$table);
			// We substract the icon (edit/delete/detailRow)
			var maxWidth = self.control.$$value.width() - (self._nbAdditionalCols * size.iconWidth);
			var fixedWidth = 0,
				width;
			// Caluclate fixed width
			self._columnInfo.forEach(function(i) {
				var art = i.article;
				i.fixedWidth = 0;
				if (art && art.$widthType === "fixed" && art.$widthVal > 0) {
					width = (size.charWidth * art.$widthVal) + size.cellPadding;
					if (width > 0 && ((fixedWidth + width) < maxWidth)) {
						i.fixedWidth = width;
						fixedWidth += width;
					}
				}
			});
			var remainingWidth = maxWidth - fixedWidth;
			var percentWidth = 0;
			// Caluclate % widths
			self._columnInfo.forEach(function(i) {
				var art = i.article;
				if (art && art.$widthType === "percent" && art.$widthVal > 0) {
					width = ((art.$widthVal * remainingWidth) / 100) + size.cellPadding;
					if (width > 0 && ((percentWidth + width) < remainingWidth)) {
						i.fixedWidth = width;
						percentWidth += width;
					}
				}
			});
		},
		// get columns that should be displayed
		_createColumnInfo: function(buildOpts) {
			var self = this;
			if (self._columnInfo) return self._columnInfo;
			self._nbAdditionalCols = 0;
			self._columnInfo = [];
			var nonDataCol = 0;
			if (self.$arrayOptions.rowIndex) {
				self._columnInfo.push({
					"$bind": globals.ROWIDXPROP,
					"proto": reqProto.getRowIdxProto(),
					"cssHeader": "s-m-rowidx"
				});
				nonDataCol++;
			}
			this._statusList = this.control.getRowStatusInfo();
			if (this._statusList != null) {
				self._columnInfo.push({
					$bind: "$ROWSTATUS",
					css: "s-m-row-status",
					proto: reqProto.create({
						$type: "tablet/x-row-status"
					})
				});
				nonDataCol++;
			}
			var proto,
				unfound = [],
				col;
			var items = self.$articleArray.$table;
			var protocols = self.control.getColumnsInfo();
			if (!items) items = protocols;
			var dataProps = self.control.getArrayData();
			dataProps = dataProps ? dataProps.$properties : null;
			items.forEach(function(item, idx) {
				/* #6148 - skip these columns - No possibility to show/hide columns currently*/
				if (item.$isHidden || (dataProps && dataProps[item.$bind] && dataProps[item.$bind].$isHidden)) return;
				item.$widthType = item.$widthType ? item.$widthType : "auto";
				item.$widthVal = parseInt(item.$widthType === "auto" ? 0 : item.$widthVal, 10);
				item.$imgHeight = item.$imgHeight || "small";
				if (isNaN(item.$widthVal)) item.$widthVal = 0;
				proto = self.$itemProto.property(item.$bind);
				if (!proto) {
					unfound.push(item);
					// TODO - Display error
				} else {
					if (!self.isExcluded(item, proto)) {
						col = {
							"$bind": item.$bind,
							"proto": self.$itemProto.create(proto),
							"article": item,
						};
						// Added as class to identify the column by field name - see sortInfoUpdate
						col.css = [self.$itemProto.getFieldNameForValue(item.$bind)];
						if (col.article.$isTitleHidden === true) {
							col.title = "";
						} else if (col.article.$title != null && col.article.$title != item.$bind && col.article.$titleOrig.indexOf('{@') >= 0) { // some translated titles are wrongly in article
							// Authoring save $title with sometimes $bind - we don't display it in the page
							// Title can be overridden bay article - TODO translation
							//col.title = self.$itemProto.resolveExpression(col.article.$title) || "";
							col.title = self.$itemProto.resolveExpression(col.article.$titleOrig || col.article.$title) || "";
						} else {
							col.title = col.proto.data('$title') || "";
						}
						self._columnInfo.push(col);
					}
				}
			});
			var edit = self.control.controller.isEditMode();
			// if we don't display all the columns of the prototype we add the link to the detail of the row
			var overflow = !this.control.prototype.isSingleArray() && ((self._columnInfo.length - nonDataCol) != protocols.length);
			if (this.$arrayOptions.showRowDetailLink === false) {
				// For to not display the icon to display row'w detail
				overflow = false;
			}
			var c;
			_additionalCols.forEach(function(col) {
				if ((edit && col.$activity === "edit") || (!edit && overflow && col.$activity === "read")) {
					if (self.control.checkCapabilities(col.$capabilities)) {
						c = $.extend(true, {}, col);
						c.$widthType = "auto";
						self._columnInfo.push(c);
						self._nbAdditionalCols++;
					}
				}
			});
			if (unfound.length > 0 && globals.getDvlpOpt("showUnfoundFields")) {
				// Add unfound columns
				var html = ['Field(s) not found<ul>'];
				unfound.forEach(function(x) {
					html.push("<li><b>" + x.$bind + "</b></li>");
				});
				html.push("</ul>");
				self.insertError(html.join(''));
			}
			return self._columnInfo;
		},
		getColumnInfo: function() {
			return this._columnInfo;
		},
		isExcluded: function(item, proto) {
			var self = this;
			if (Base.prototype.isExcluded.call(self, proto)) return true;
			return _isExcluded.indexOf(proto.$type) >= 0 || item.$isAdvanced === true;
		},
		_buildTableHead: function($$table, buildOpts) {
			var self = this;
			var $$tabHead = $(uiUtils.createDomElement('thead', null, null, null));
			var tr = uiUtils.createDomElement('tr', null, null, null, $$tabHead);
			var th;
			self._columnInfo.forEach(function(col) {
				th = uiUtils.createDomElement('th', col.cssHeader || col.css, col.title, null, tr);
				if (col.fixedWidth != null && col.fixedWidth > 0) {
					$(th).width(col.fixedWidth);
				}
			});
			var $$headerScroll;
			if (this.control.getAuthoring("$tableHeaderShow") !== false) {
				$$headerScroll = $$tabHead.clone();
				this.$$tabHead = $$tabHead.appendTo($$table);

			} else {
				$$headerScroll = $$tabHead;
			}
			return $$headerScroll;
		},
		_buildTableFoot: function($$table, arrayData, buildOpts) {
			var self = this;
			if (self.control.controller.isEditMode() && this.control.checkCapabilities(_addRowBtn.$capabilities)) {
				//#5529 - we add addRow in any case
				var $$cell = $('<tfoot><tr><td colspan="' + self._columnInfo.length + '"></td></tr></tfoot>').appendTo($$table).find("td");
				var fieldProto = self._getOtherColProto(_addRowBtn, "");
				/**
				 * Build cell html and append it to parent
				 * Control is used only one time
				 */
				var ctrl = _createCellControl(self.control, $$cell, _addRowBtn, fieldProto);
				self.callGenerateHtml(ctrl, $$cell, self.control.controller.getEmptyDao(fieldProto), true, buildOpts);
			}
		},
		_buildTableRow: function($$body, rowData, idx, buildOpts) {
			var self = this;
			var cssRowIdx;
			if (self.$arrayOptions.rowIndex) {
				rowData.setRowIndex(idx + 1);
			}
			var css = [];
			var error = rowData.data.$arrayUpdateError;
			if (error === true) {
				css.push("error");
			}
			if (idx % 2 === 0) {
				css.push("s-m-even");
			}
			var tr = self.buildRecordMainElmt(rowData, {
				tag: "tr",
				parent: $$body,
				css: css
			}, idx);
			var $$cell, fieldProto;
			self._columnInfo.forEach(function(col, idx) {
				// We display the css stored in _columnInfo
				// Used by rowIndex (to apply a style) and columns with icon (to set width)
				$$cell = $(uiUtils.createDomElement('td', col.css || "", null, null, tr));
				fieldProto = col.$activity != null ? self._getOtherColProto(col, rowData.data.$uuid, rowData, buildOpts) : col.proto;
				if (!col.control) {
					// Creates the control used for generating html in cells
					col.control = _createCellControl(self.control, $$cell, col, fieldProto);
				}
				self.callGenerateHtml(col.control, $$cell, rowData, false, buildOpts, idx);
			});
			return tr;
		},
		/**
		 * Returns the proto for button, icons for actions
		 * 		Add new row			array._actRowDetail
		 * 		Detelete row		array._actDelrow
		 * 		Goto row detail		array._actRowDetail
		 * 		Edit row detail		array._actRowDetail
		 * In row detail page we will get a null rowid for creation
		 */
		_getOtherColProto: function(colInfo, rowId, rowData, buildOpts) {
			var self = this;
			// mainArrayCtrl is the array control at the origin of the creation of the table/card
			// When we generate html cards for arrays nested is a parent array the main control is propagated by buildOpts.htmlRootCtrl
			// Otherwise the maincontrol is self.control
			var mainArrayCtrl = buildOpts && buildOpts.htmlRootCtrl ? buildOpts.htmlRootCtrl : self.control;
			var action = colInfo.$action;
			var rowInfo = {
				pathBind: [],
				pathId: [],
				activity: colInfo.$activity
			};
			var create = colInfo.$activity === "create";
			if (create) {
				// CREATE ROW - Build the path to retrieve the row when we click on AddRow
				rowId = utils.UUID();
				rowInfo.pathId.unshift(rowId);
				rowInfo.pathBind.unshift(self.control.$bind);
			} else {
				if (!rowData) throw new Error("unexpected null row data");
				// Build the path of array field and rowsid's and stores it in mainArrayCtrl
				var rd = rowData;
				// EDIT/DETAIL ROW
				rowInfo.pathId.unshift(rowId);
				rowInfo.pathBind.unshift(rd.$bind);
				// Build the path id/bind to access to the resource. We need to store it because the controls/dao/proto are destroyed after creation
				// rd.parent.$bind && rd.parent.$bind.length >0 added to build the bing array working with a protoRow = protoArray.getPrototype("$item"); - sess getArrayData in prototype
				// To test multiple level in display mode pput card display in 'Collection Object' of AQMCRUDM. We see the card with an array inside. If we click on 'rowDetail' icon we've pathBind/pathId.length == 2 
				while (rd.$bind !== mainArrayCtrl.$bind) {
					rowInfo.pathId.unshift(rd.parent.getValue("$uuid"));
					rowInfo.pathBind.unshift(rd.parent.$bind);
					rd = rd.parent;
				}
			}
			// Registers the row info into the main Array control
			// Like html generator destroy the control and dao after generation we need to store the paths (ids and $bind) to retreive row dao and proto
			mainArrayCtrl.rowDetailAdd(rowId, rowInfo);
			var json = {
				$action: {
					"data-action": action
				}
			};
			if (create) {
				// For create we add the parameter in data-params
				json.$action["data-params"] = rowId;
			} else {
				// For other action than create the id of the row is added in the dom elmt of the record - see builderBase.buildRecordMainElmt
				// It allows to not add uuid for each action delete/select/edit...
			}
			// Additional info needed to create the control (button, icon...)
			["$type", "$icon", "$text"].forEach(function(x) {
				if (x != null && x != "$activity") {
					json[x] = colInfo[x];
					if (x === "$text") {
						json[x] = locale.text(json[x]);
					}
				}
			});
			return reqProto.create(json);
		},
		/**
		 * Update icons when sort/filter change
		 */
		filterSortUpdate: function(sortOrder, sortField, hasFilters) {
			Base.prototype.filterSortUpdate.call(this, sortOrder, sortField, hasFilters);
			if (sortOrder && sortField && this.$$tabHead) {
				var $$th = this.$$tabHead.find(".s-m-sorted");
				if ($$th.length > 1) {
					// remove the current - To test because necer occurs as the array is rebuilt on refresh
					var text = $$th.find("div > span")[0].text();
					$$th.removeClass();
				}
				// set the content with sort info
				$$th = this.$$tabHead.find("." + sortField);
				if ($$th.length > 0) {
					var title = $$th.text();
					$$th.html(_getHtml("sortedHeader", {
						title: title,
						css: fontUtils.sortIcon(sortOrder)
					}));
					$$th.addClass("s-m-sorted " + sortOrder);
				}
			};
			this.searchUpdate();
		},
		searchUpdate: function() {
			var $$th, searcher = this.control.getSearcher(),
				self = this;
			if (self.$$tabHead) {
				self.$$tabHead.find(".s-m-search").removeClass("s-m-search");
				if (searcher) {
					searcher.searchInfos.forEach(function(column) {
						$$th = self.$$tabHead.find("." + column.id);
						$$th.addClass("s-m-search ");
					});
				}
			}
		},
		getColumnsInfo: function(onlyVisible) {
			var cols;
			if (!this.control.prototype.isSingleArray() && onlyVisible === true) {
				var ci = this._createColumnInfo();
				if (ci && ci.length > 0) {
					var cols = [];
					ci.forEach(function(c) {
						if (c.$action !== true) {
							cols.push(c.$bind);
						}
					});
				}
			}
			var protoCols = this.control.getColumnsInfo();
			if (cols == null) {
				return protoCols;
			}
			var res = [];
			protoCols.forEach(function(c) {
				if (cols.indexOf(c.$bind) >= 0) {
					res.push(c);
				}
			});
			return res;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/layout/layoutBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/structElmt','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/structElmt').Klass;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _Klass = utils.defineClass(function LayoutBase(controller, type, article, opts) {
	Base.call(this, controller, type, article, opts);
	this.title = article.$title;
}, Base, {
	/**
	 * Init the properties to allow reuse of this control
	 */
	initReuseProperties: function() {
		Base.prototype.initReuseProperties.call(this);
		this.$$header = null;
	},
	destroy: function() {
		Base.prototype.destroy.call(this);
	},
	createId: function(typeName) {
		return utils.readableuid(typeName);
	},
	buildHtml: function($$parent, controllerDao, buildOptions) {
		Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions);
		this.createRootElement(["s-m-layout"], $$parent);

		if (this.article.$title && (buildOptions == null || buildOptions.noTitle !== true)) {
			this.buildTitle();
		}
		if (this.article.$icon && (buildOptions == null || buildOptions.noIcon !== true)) {
			this.buildIcon();
		}
	},
	/**
	 * Built with the rank of the layout in generation process to be reliable
	 */
	getUnitTestId: function() {
		if (this.options.index == null) return;
		return utils.unitTestId(this.typeName.toLowerCase(), this.options.index);
	},
	/**
	 * Needed to call afterRender in mode generator - isHtmlGenerator
	 * afterRender applies the meta-data - Used to apply meta-data in cards
	 */
	buildChildrenHtml: function($parent, controllerDao, buildOptions) {
		this.isEmpty = true;
		if (this.children) {
			var self = this;
			$.each(self.children, function(index, child) {
				child.buildHtml($parent, controllerDao, buildOptions);
				/**
				 * TODO - call build html inside a render method that call a process before (sets Dao and after removes dao and calls afterRender
				 */
				if (child.afterRender && buildOptions && (buildOptions.isHtmlGenerator === true || buildOptions.afterRender === true)) {
					child.afterRender(buildOptions);
				}
				self.isEmpty = self.isEmpty && child.isEmpty;
			});
		}
		if (buildOptions && buildOptions.hideEmptyRows === true) {
			// This option allows to hide empty rows and optimize display
			this.$$elmt.toggleClass("s-m-empty", this.isEmpty);
		}
	},
	onResize: function(context) {
		if (!this.children) return;
		this.children.forEach(function(child) {
			if (child.onResize) child.onResize(context);
		});
	},
	// $$root to force the rot if it's not $$elmt - cell
	_ensureHeader: function($$root) {
		if (!this.$$header) {
			this.$$header = $('<header>').prependTo($$root || this.$$elmt);
		}
		return this.$$header;
	},
	buildIcon: function($$rootLyt, $$parent, controllerDao, destroyAfter) {
		this._ensureHeader();
		var icon = fontUtils.getIconByName(this.article.$icon);
		if (icon) {
			this.$$header.addClass("s-m-has-ttl-icon").prepend('<i class="s-m-ttl-icon ' + icon + '">');
		}
	},
	buildTitle: function($$rootLyt, $$parent, controllerDao, destroyAfter) {
		this._ensureHeader();
		this.$$header.find("span.title").remove();
		this.$$header.prepend('<span class="title">' + this.getArticleText("$title") + '</span>');
	},
	// Only hub layout is able to scroll
	getGestureMgr: function() {
		return null;
	},
	isLayout: function() {
		return true;
	}
});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/layout/layoutRow',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/layout/layoutBase'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/layout/layoutBase').Klass;

/**
 * Detects empty rows and hide them with the class .s-m-empty.s-m-fullwidth
 * An empty cell (s-m-empty) is hidden if the cell is full width
 * 		takes the full width of the row - depends on bootstrap grid classes)
 * If all non full width cells (emptyNotfw) are empty
 * 		eg; 2 empty cells with width=50% (6/12  of the row) + another one with width=100% (12/12  of the row)
 * A row is hidden if
 * 		All the cells are empty (s-m-empty)
 *
 */
var _checkEmptyRow = function($$row) {
	if (!$$row) return;
	var fullCellMinWidth = $$row.width();
	fullCellMinWidth = fullCellMinWidth - fullCellMinWidth / 12;
	var emptyNotfw = [];
	$$row.children().each(function() {
		var $$cell = $(this);
		if ($$cell.width() > fullCellMinWidth) {
			$$cell.addClass("s-m-fullwidth");
		} else {
			$$cell.removeClass("s-m-fullwidth");
			if (emptyNotfw && $$cell.is(".s-m-empty")) {
				emptyNotfw.push($$cell);
			} else {
				// Breaks the process on first non empty cell
				emptyNotfw = null;
			}
		}
	});
	if (emptyNotfw) {
		// Hide all these cells
		emptyNotfw.forEach(function($$cell) {
			$$cell.addClass("s-m-fullwidth");
		});
	}
};

var _checkEmptyRows = function($$rows) {
	if (!$$rows) return;
	$$rows.each(function() {
		_checkEmptyRow($(this));
	});
};

/**
 */
var _Klass = utils.defineClass(

	function LayoutRow(controller, type, article, opts) {
		var self = this;
		Base.call(self, controller, type, article, opts);
	}, Base, {

		buildHtml: function($$parent, controllerDao, buildOptions) {
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions);
			this.$$elmt.addClass("s-m-row row");
			this._setRowColorClass();
			this.buildChildrenHtml(this.$$elmt, controllerDao, buildOptions);
			if (this.$$elmt.is(":empty")) {
				this.$$elmt.hide();
			}
		},
		_setRowColorClass: function() {
			var self = this;
			var color = self.article.$bgColor;
			if (color) {
				self.$$elmt.addClass("s-m-bg s-m-color-" + color);
			}
		},
	}
);

exports.Klass = _Klass;
exports.checkEmptyRows = _checkEmptyRows;
});

define('syracuse-tablet/html/js/controls/array/builderCardBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/array/builderBase','syracuse-tablet/html/js/helpers/articleParser','syracuse-tablet/html/js/authoring/authoringArticleGen','syracuse-tablet/html/js/helpers/fieldOperators','syracuse-tablet/html/js/controls/layout/layoutRow'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/array/builderBase').Klass;
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');
var articleGen = require('syracuse-tablet/html/js/authoring/authoringArticleGen');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');
var layoutRow = require('syracuse-tablet/html/js/controls/layout/layoutRow');


var _Klass = utils.defineClass(
	function(control, disp, options) {
		Base.call(this, control, disp, options);
		this._layoutRoot = null;
		this._$$cellTmpl = $('<section class="s-m-card"/>');
	}, Base, {
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			// Initialize properties when we generate multiple card with the same control tree
			// No destroy because this._$$body is in the dom - we create another one
			this._$$body = null;
			this._$$rows = null;
			this._statusInfo = null;
		},
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._layoutRoot) {
				this._layoutRoot.destroy();
				this._layoutRoot = null;
			}
			if (this._$$body) {
				// Destroy all children carousel  - if cards nested in cards to make sure we clear handlers and data
				this._$$body.find(".carousel").remove();
				// To remove the handlers/data attach to dom elements and descendants (carousel)
				this._$$body.remove();
				this._$$body = null;
			}
			this._$$cellTmpl = null;
			if (!this._$$rows) {
				this._$$rows = null;
			}
		},
		buildHtml: function(arrayData, buildOpts) {
			Base.prototype.buildHtml.call(this, arrayData, buildOpts);
			if (this._layoutRoot == null) {
				var cardArticle = this.$articleArray.$card;
				if (!cardArticle) {
					cardArticle = articleGen.genNewArticle({
						page: {
							prototype: this.control.prototype
						}
					}, true);
				};
				var options = {
					displayCtx: "card",
					displayAsCarousel: buildOpts.htmlRootCtrl !== null,
					hideEmptyRows: this.$arrayOptions.hideEmptyRows === true
				};
				this._layoutRoot = articleParser.article2Controls(this.control.controller, cardArticle, this.$itemProto, options);
			}
			this._statusInfo = this.control.getRowStatusInfo();
			if (this.isRefreshContext(buildOpts)) {
				// Force display because there's no resize
				this._callBuildCards(buildOpts);
			} // Otherwise build is done on resize
		},
		createCard: function($$parent, idx, rowData, buildOpts) {
			var $$card = this._$$cellTmpl.clone().appendTo($$parent);
			if (this.$arrayOptions.rowIndex === true) {
				$('<span class="badge index">' + (idx + 1) + '</span>').appendTo($$card);
			}
			if (this._statusInfo) {
				this.checkStatusManagement($$parent, this._statusInfo, $$card, rowData);
			}
			this.callGenerateHtml(this._layoutRoot, $$card, rowData, false, buildOpts, idx);
			return $$card;
		},
		checkStatusManagement: function($$parent, statusInfo, $$cell, rowData) {
			if (!statusInfo) return;
			var $$rootIcon = $$cell.find(".s-m-status");
			if ($$rootIcon.length === 0) {
				$$rootIcon = $('<div class="s-m-status"/>').appendTo($$cell);
			}
			var nbBckg = 0;
			statusInfo.list.some(function(s) {
				if (s.color && fieldOperators.evaluateOperator(s.$type, rowData.getValue(s.field), s.operator, s.value)) {
					/**
					 * We need to set color and bg-color because using css property doesn't work due to css inheritance
					 * Using css forces to declare all css selectors (td:not(.s-m-multi-selected)...) for each color of the palette
					 */
					if (s.icon) {
						$('<div class="s-m-status-icon ' + s.icon.css + '" style="color:' + s.color.bgColor + '"/>').appendTo($$rootIcon);
						return statusInfo.type === "mono";
					} else if (s.color.css && nbBckg === 0) {
						$$parent.addClass('s-m-status-color ' + s.color.css);
						nbBckg++;
					}
					return statusInfo.type === "mono";
				}
			});
		},
		onResize: function(context) {
			if (this.destroyed) return;
			// Used by multi-selection - we just want to refresh the scroll
			var scrollOnly = context != null && context.scrollOnly === true;
			if (scrollOnly !== true) {
				/**
				 * We rebuild in any cases in order to have a good display
				 * To be able to calculate  parentH in nested pages we use table display for s-m-control and table-row for children
				 * --> In that case control.$$value has the right height
				 * For non nested paged table display doens't allow to calculate the height of the array without removing the old one...
				 * Other option was to check if $$value height changed to rebuild array
				 */
				var buildOpts = {
					updateLayout: context && context.updateLayout
				};
				this._callBuildCards(buildOpts, context);
			} else {
				Base.prototype.onResize.call(this, context);
			}
		},
		_callBuildCards: function(buildOpts, context) {
			if (!this.checkEmptyArray()) {
				return;
			}
			this.buildCards(buildOpts, context);
		},
		/**
		 * !! check the multi-selection if we modify  buildCards
		 */
		buildCards: function(buildOpts, resizeContext) {
			throw new Error("Not implemented");
		},
		authMinSize2Pixels: function(val) {
			var max = 700,
				min = 100;
			val = parseInt(val, 10);
			if (val == null || isNaN(val)) return 200;
			if (val > 20) return max;
			if (val < 1) return min;
			return min + (val * (max - min) / 20);
		},
		/**
		 * Like the rows are not stored as controls (html generated) we get the $$row and apply the rocess to detect empty row
		 * Same process for the row layout
		 */
		checkEmptyRows: function() {
			if (!this._$$body) return;
			if (!this._$$rows) {
				this._$$rows = this._$$body.find(".s-m-row");
			}
			layoutRow.checkEmptyRows(this._$$rows);
		},
		getColumnsInfo: function(onlyVisible) {
			var cols = null;
			if (!this.control.prototype.isSingleArray() && onlyVisible === true && this._layoutRoot) {
				cols = [];
				var _scan = function(node) {
					if (!node || !node.children) return;
					node.children.forEach(function(c) {
						if (c.isControl() && c.$bind) {
							cols.push(c.$bind);
						} else {
							_scan(c);
						}
					});
				};
				_scan(this._layoutRoot);
			}
			var protoCols = this.control.getColumnsInfo();
			if (cols == null) {
				return protoCols;
			}
			var res = [];
			protoCols.forEach(function(c) {
				if (cols.indexOf(c.$bind) >= 0) {
					res.push(c);
				}
			});
			return res;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/array/builderCard',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/controls/array/builderCardBase'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/array/builderCardBase').Klass;

/**
 * CARD BUILDER
 */
var _Klass = utils.defineClass(
	function(control, disp, options) {
		Base.call(this, control, disp, options);
	}, Base, {
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			// Initialize properties when we generate multiple card with the same control tree
			this.resetProps(false);
		},
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.resetProps(true);
		},
		/**
		 * remove
		 * 	true means that we can destroy all the $$elments (remove)
		 * 	false when we want to keep elements (htmlGenerator mode)
		 * 	We use only one control to generate multiple html cards with one layout (tree structure) (use only with carousel)
		 */
		resetProps: function(remove) {
			this._tds = null;
			this._dirArray = null;
			if (this._$$body) {
				if (remove) {
					if (this._$$body.length) {
						this._$$body.remove();
					}
					// Like we rebuild a new _$$body we have to destroy the scroller
					this.destroyScroller();
				}
				this._$$body = null;
			}
		},
		/**
		 * Just build $$td cells
		 * Build of array will be done on resize because we need to have the height of the parent control.$$value to calculate the number of roww
		 */
		buildHtml: function(arrayData, buildOpts) {
			this.$articleArray.$minWidth = this.$articleArray.$minWidth || 6;
			Base.prototype.buildHtml.call(this, arrayData, buildOpts);
		},
		/**
		 * Can be overridden to clear cached data
		 */
		notifyArrayDataChanged: function(refresh, arrayData, isEmpty) {
			Base.prototype.notifyArrayDataChanged.call(this, refresh, arrayData, isEmpty);
			this.resetProps(true);
		},
		/**
		 * !! check the multi-selection if we modify  buildCards
		 */
		buildCards: function(buildOpts, resizeContext) {
			buildOpts = buildOpts || {};
			if (!this._$$body) {
				// Like we rebuild a new _$$body we have to destroy the scroller
				this.destroyScroller();
				this._$$body = $('<tbody>').appendTo($('<table/>').appendTo(this.control.$$value));
				var $$td;
				this._tds = [];
				var self = this;
				this.control.getArrayData().$resources.forEach(function(rowData, idx) {
					$$td = $(self.buildRecordMainElmt(rowData, {
						tag: "td",
						parent: null
					}, idx));
					self._tds.push({
						"$$td": $$td,
						rowData: rowData
						//"$$card" is created when $$td is attached to the dom because nested element need width/height calculation (carousel)
					});
				});
			}
			var dirArray, initScroll = false;
			dirArray = globals.getScrollingDirection() || "v";
			initScroll = buildOpts.refresh === true || resizeContext;
			dirArray = this.control.isArrayField() ? "h" : dirArray === "h" ? "v" : "v"; //"h";
			buildOpts.cardAuthoring = {
				$emptycell: this.$articleArray.$emptycell || "nodisplay",
				$minWidth: this.authMinSize2Pixels(this.$articleArray.$minWidth),
				$cardsPerRow: parseInt(this.$articleArray.$cardsPerRow, 10) || 2
			};
			var sz = this.control.getAvailableSize();
			var parentH = sz.height;
			var parentW = sz.width;
			// Border spacing used for calculation
			var bs = this._$$body.parent().css("border-spacing");
			if (bs) {
				bs = bs.split("px");
				bs = bs && bs.length > 0 ? parseInt(bs[0], 10) : 0;
			}
			//parentH = parentH - bs;
			//parentW = parentW - bs;
			var $$hiddenRow;
			var visibleTds = [];
			// We keep the $$td's to not recreate them and arrange according the new configuration
			// We first detach them and select the visible ones (used by multiselection)
			// We put non-visible ones in $$hiddenRow to let them available in the dom (used by multiselection)
			this._tds.forEach(function(o, idx) {
				if (o.$$card) {
					// Clear the height/width because they are calculated according to the device/parent size
					o.$$card.css({
						height: "",
						width: ""
					});
				}
				o.$$td.detach();
				if (o.$$td.css('display') != "none") {
					visibleTds.push(o);
				} else {
					if (!$$hiddenRow) {
						$$hiddenRow = $("<tr>").hide();
					}
					o.$$td.appendTo($$hiddenRow);
				}
			});
			// !! Call $$body after having detached $$td because empty() removes the data attached to the node ($.smData) used by multi-selection (diagnoses)
			this._$$body.empty();
			if ($$hiddenRow) {
				$$hiddenRow.appendTo(this._$$body);
			}
			if (visibleTds.length === 0) return;
			if (dirArray === "h") {
				this.buildCardH(visibleTds, bs, parentH, parentW, buildOpts);
			} else {
				this.buildCardV(visibleTds, bs, parentH, parentW, buildOpts);
			}
			// Center the table in the parent - only if fixed height
			if (!this.control.isArrayField() && !this.control.controller.isNestedInDashboard("stack")) {
				var top = Math.max(0, (parentH - this._$$body.parent().outerHeight()) / 2);
				this._$$body.parent().css({
					top: top + "px"
				});
			}
			if ((this._dirArray == null || this._dirArray != dirArray) && (dirArray === "h" || (dirArray === "v" && !this.control.controller.isNestedInDashboard("stack")))) {
				this._dirArray = dirArray;
				this.newScroller(dirArray, this._$$body.parent());
				initScroll = true;
			}
			this.doAfterBuild(resizeContext, initScroll);

		},
		buildCardV: function(visibleTds, bs, parentH, parentW, buildOpts) {
			this._$$body.parent().width("100%");
			var $$row, realW, nbCardPerRow;
			var minWidth = buildOpts.cardAuthoring.$minWidth;
			var remaining = 0;
			var self = this;
			visibleTds.some(function(o, idx) {
				if (idx === 0 || nbCardPerRow == 1 || (nbCardPerRow > 1 && idx % nbCardPerRow === 0)) {
					$$row = $("<tr>").appendTo(self._$$body);
					remaining = nbCardPerRow;
				}
				remaining--;
				o.$$td.appendTo($$row);
				if (!o.$$card) {
					// !! We create the card here because we need to have the $$card attached to the dom to calculate children width/row... eg: cards inside card
					// If we crate the card at the same time as $$td the generation of html is wrong
					o.$$card = self.createCard(o.$$td, idx, o.rowData, buildOpts);
				}
				if (idx === 0) {
					var padding = o.$$card.outerWidth() - o.$$card.width();
					nbCardPerRow = buildOpts.cardAuthoring.$cardsPerRow;
					while (nbCardPerRow > 1) {
						realW = Math.round((parentW - ((nbCardPerRow + 1) * bs)) / nbCardPerRow) - padding;
						if (realW >= minWidth) break;
						nbCardPerRow--;
					}
					if (nbCardPerRow > 1) {
						realW = Math.min(Math.max(minWidth, realW));
					}
				}
				if (nbCardPerRow > 1) {
					o.$$card.width(realW);
				} else {
					o.$$card.css({
						width: "100%"
					});
				}
			});
			if (remaining && buildOpts.cardAuthoring.$emptyCell !== "nodisplay") {
				this.addEmptyCells(this._layoutRoot, $$row, remaining, buildOpts, this._$$cellTmpl);
			}
			if (this.$arrayOptions.hideEmptyRows === true) {
				this.checkEmptyRows();
			}
		},
		buildCardH: function(visibleTds, bs, parentH, parentW, buildOpts) {
			var $$row, realH, realW;
			var nbCardPerRow, numberOfRows;
			var nbVisiblecardsPerRow = buildOpts.cardAuthoring.$cardsPerRow;
			var minWidth = buildOpts.cardAuthoring.$minWidth;
			parentH = parentH - bs;
			var remaining = 0;
			var self = this;
			var maxHeight = 0,
				h, heightChanged;
			visibleTds.some(function(o, idx) {
				if (idx == 0 || nbCardPerRow == 1 || (nbCardPerRow > 1 && idx % nbCardPerRow === 0)) {
					$$row = $("<tr>").appendTo(self._$$body);
					remaining = nbCardPerRow;
				}
				o.$$td.appendTo($$row);
				if (!o.$$card) {
					// !! We create the card here because we need to have the $$card attached to the dom to calculate children width/row... eg: cards inside card
					// If we crate the card at the same time as $$td the generation of html is wrong
					o.$$card = self.createCard(o.$$td, idx, o.rowData, buildOpts);
				}
				if (idx === 0) {
					// Calculate the number of rows after having create the first cell
					realH = o.$$td.height() + bs;
					parentW = parentW - ((nbVisiblecardsPerRow + 1) * bs);
					var padding = o.$$card.outerWidth() - o.$$card.width();
					realW = Math.round(parentW / nbVisiblecardsPerRow) - padding;
					if (self.control.isArrayField() || (visibleTds.length * realW < parentW)) {
						// Force to display all the cells on one line because there's enough room
						numberOfRows = 1;
						nbCardPerRow = visibleTds.length;
					} else {
						// Calculate the number of rows to fit the parent height
						numberOfRows = Math.max(1, Math.floor(parentH / realH));
						nbCardPerRow = Math.ceil(visibleTds.length / numberOfRows);
						if (visibleTds.length <= numberOfRows * nbVisiblecardsPerRow) {
							// Dispatch the cards by filling the lines from the top to bottom
							nbCardPerRow = nbVisiblecardsPerRow;
						}
					}
					remaining = nbCardPerRow;
				}
				o.$$card.width(Math.min(parentW, Math.max(minWidth, realW)));
				var h = o.$$card.height();
				if (maxHeight === 0) {
					maxHeight = h;
				} else if (maxHeight != h) {
					heightChanged = true;
					maxHeight = Math.max(maxHeight, h);
				}
				remaining--;
			});
			if (heightChanged) {
				// Set the same height for cards (could occurs if there are arrays in cards)
				visibleTds.forEach(function(o) {
					o.$$card.height(maxHeight);
				});
			}
			if (remaining && buildOpts.cardAuthoring.$emptyCell !== "nodisplay") {
				var $$emptyCells = this.addEmptyCells(this._layoutRoot, $$row, remaining, buildOpts, this._$$cellTmpl);
				if (heightChanged) {
					$$emptyCells.height(maxHeight);
				}
			}
			if (this.$arrayOptions.hideEmptyRows === true) {
				this.checkEmptyRows();
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/array/builderCarousel',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/array/builderCardBase','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/scroller/hammerScroller'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/array/builderCardBase').Klass;
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var hammerScroller = require('syracuse-tablet/html/js/helpers/scroller/hammerScroller');

var _templates = {
	main: '<div id="{{id}}" class="carousel slide">\
					<div class="carousel-inner" role="listbox">\
					</div>\
					<footer>\
						<ul class="s-m-carousel-indicators">\
							<span class="first active"></span>\
							{{#if middle}}\
								<span class="middle"></span>\
							{{/if}}\
							{{#if last}}\
								<span class="last"></span>\
							{{/if}}\
						</ul>\
						<span class="left carousel-control {{leftIcon}}" aria-hidden="true"  href="#{{id}}" role="button" data-slide="prev"></span>\
						<span class="right carousel-control {{rightIcon}}" aria-hidden="true" href="#{{id}}" role="button" data-slide="next"></span>\
					</footer>\
			</div>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

var _createHtmlGeneratorContext = function(carousel) {
	return {
		handler: _destroyHtmlGeneratorContext,
		data: {
			// To destroy the plugin - One plugin per carousel generated
			$$body: carousel._$$body,
			// To destroy the swiper - One swiper per carousel generated
			swiper: carousel._swiper
		}
	};
};
var _destroyHtmlGeneratorContext = function(data) {
	if (!data) return;
	if (data.$$body && data.$$body.length) {
		// There's no destroy in carousel plugin ??
		// We call remove to clear all handlers and data attached to dom elemt an children
		data.$$body.remove();
		data.$$body = null;
	}
	if (data.swiper) {
		data.swiper.destroy();
		data.swiper = null;
	}
};
var _getInterval = function(period) {
	if (period === "slow") {
		return 6000;
	} else if (period === "normal") {
		return 3000;
	} else if (period === "fast") {
		return 1000;
	}
	return -1;
};
/**
 * CARD CAROUSEL BUILDER
 */
var _Klass = utils.defineClass(
	function(control, disp, options) {
		Base.call(this, control, disp, options);
	}, Base, {
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			this.resetProps(false);
		},
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.resetProps(true);
		},
		/**
		 * Called also by card destroy
		 * remove
		 * 	true means that we can destroy all the $$elments (remove)
		 * 	false when we want to keep elements (htmlGenerator mode)
		 * 		We use only one control to generate multiple html carousels with one layout (tree structure) (eg BPCUSTOMER Addresses)
		 *  	swiper are destroyed with the main parent array control - see addHtmlGeneratorContext/removeHtmlGeneratorContext
		 */
		resetProps: function(remove) {
			if (remove) {
				this._destroySwiper();
			}
			if (remove && this._$$body && this._$$body.length) {
				this._$$body.remove();
			}
			this._$$body = null;
			this._cards = null;
		},
		notifyArrayDataChanged: function(arrayData) {
			Base.prototype.notifyArrayDataChanged.call(this, arrayData);
			this.resetProps(true);
		},
		getHeaderOptions: function() {
			return {
				filterEnabled: false,
				sortEnabled: false,
				searchEnabled: false,
				paginEnabled: false,
				$filters: null
			};
		},
		buildCards: function(buildOpts, resizeContext) {
			if (!this.checkEmptyArray()) {
				return;
			}
			buildOpts = buildOpts || {};
			var interval = _getInterval(this.$articleArray.$carouselPeriod);
			if (!this._$$body) {
				var ctx = {
					id: "carousel" + this.control.id,
					leftIcon: fontUtils.getCarouselIcon("left"),
					rightIcon: fontUtils.getCarouselIcon("right")
				};
				if (this.control.getNbRecords() > 0) {
					ctx.last = (this.control.getNbRecords() - 1);
				}
				if (this.control.getNbRecords() > 1) {
					ctx.middle = true;
				}
				this._$$body = $(_getHtml("main", ctx)).appendTo(this.control.$$value);
				var $$root = this._$$body.find(".carousel-inner");
				this._cards = [];
				var baseItm = $('<div class="item">');
				var $$item;
				var $$record;
				var self = this;
				this.control.getArrayData().$resources.forEach(function(rowData, idx) {
					$$item = baseItm.clone().attr("data-idx", idx).appendTo($$root);
					if (idx === 0) {
						$$item.addClass("active");
					}
					$$record = $(self.buildRecordMainElmt(rowData, {
						tag: "div",
						parent: $$item
					}, idx));
					self._cards.push(self.createCard($$record, idx, rowData, buildOpts));
				});
				if (buildOpts.isHtmlGenerator === true) {
					// Carousel's html is generated (Carousel's object not stored in memory) 
					// We need to store object to destroy in array parent control htmlRootCtrl. They will be destroyed with htmlRootCtrl 
					if (buildOpts.htmlRootCtrl) {
						buildOpts.htmlRootCtrl.addHtmlGeneratorContext(_createHtmlGeneratorContext(this));
					}
				}
			}
			// We can change hasNavigation by authoring (interval or not)
			var hasNextPrev = !isNaN(interval) && interval <= 0;
			this._$$body.find("footer").toggle(hasNextPrev);
			this._destroySwiper();
			this._$$body.off('slid.bs.carousel');
			if (hasNextPrev) {
				this._$$body.carousel('pause');
				this._$$body.on('slid.bs.carousel', jsutils.bindFn(this._onEndSlide, this, this._$$body, this.control.getNbRecords() - 1));
				if (buildOpts.isHtmlGenerator !== true) {
					// No swiper if nested in a card - TODO because it doesn't work fine
					this._initSwiper(this._$$body);
				}
			} else {
				this._$$body.carousel({
					interval: interval
				});
				this._$$body.carousel("cycle");
			}
			var maxHeight = 0,
				h, heightChanged;
			this._cards.forEach(function($$card, idx) {
				$$card.css({
					height: "",
					width: ""
				});
				h = $$card.height();
				if (maxHeight === 0) {
					maxHeight = h;
				} else if (maxHeight != h) {
					heightChanged = true;
					maxHeight = Math.max(maxHeight, h);
				}
			});
			if (heightChanged === true) {
				// Set the same height for cards (could occurs if there are arrays in cards)
				this._cards.forEach(function($$card) {
					$$card.css("height", maxHeight + "px");
				});
			}
			if (this.$arrayOptions.hideEmptyRows === true) {
				this.checkEmptyRows();
			}
			this.control.$$value.height(this._$$body.height() + "px");
			this.doAfterBuild(resizeContext, false);
		},
		_onEndSlide: function(evt, $$body, maxIdx) {
			var $$active = $(evt.relatedTarget);
			var idx = parseInt($$active.attr("data-idx"), 10);
			if (idx !== maxIdx && idx !== 0) {
				if (evt.direction === "right") {
					idx = idx === 0 ? maxIdx : idx - 1;
				} else {
					idx = idx === maxIdx ? 0 : idx + 1;
				}
			}
			$$body.find("span.middle").toggleClass("active", idx > 0 && idx < maxIdx);
			$$body.find("span.first").toggleClass("active", idx === 0);
			$$body.find("span.last").toggleClass("active", idx === maxIdx);
		},
		_onSwipe: function(evt, $$body) {
			if ((evt.type !== "swipeleft" && evt.type !== "swiperight") || hammerScroller.isEvtDirection(evt, "v")) return;
			$$body.carousel(evt.type === "swipeleft" ? 'next' : 'prev');
		},
		_destroySwiper: function() {
			if (this._swiper) {
				this._swiper.destroy();
				this._swiper = null;
			}
		},
		_initSwiper: function($$parent) {
			this._destroySwiper();
			this._swiper = new hammerScroller.Hammer($$parent.get(0));
			this._swiper.get("swipe").set({
				direction: hammerScroller.Hammer.DIRECTION_HORIZONTAL
			});
			this._swiper.on("swipeleft swiperight", jsutils.bindFn(this._onSwipe, this, $$parent));
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/array/builderSeparator',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/array/builderBase','syracuse-tablet/html/js/controls/ctrlFactory'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/array/builderBase').Klass;
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');

/**
 * Display the control with displayCtx = "table"
 * I didn't want to change the displayCtx in all fields control so I kept "table"
 */
var _createCellControl = function(arrayCtrl, $$parent, colInfo, fieldProto) {
	var article = {
		"$bind": colInfo.$bind
	};
	return ctrlFactory.createCellFieldCtrl($$parent, arrayCtrl.controller, colInfo.article || colInfo, fieldProto);
};
var _seps = {
	semicolon: ",",
	colon: ":",
	blank: " ",
	dash: "-"
};
/**
 * Display a single array with a separator
 * To improve
 */
var _Klass = utils.defineClass(
	function(control, disp, options) {
		Base.call(this, control, disp, options);
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._columnInfo) {
				this._columnInfo.forEach(function(col) {
					if (col.control) col.control.destroy();
				});
				this._columnInfo = null;
			}
		},
		buildHtml: function(arrayData, buildOpts) {
			buildOpts = buildOpts || {};
			Base.prototype.buildHtml.call(this, arrayData, buildOpts);
			this._createColumnInfo();
			this._build(arrayData, buildOpts);
		},
		notifyArrayDataChanged: function(refresh, arrayData, isEmpty) {
			Base.prototype.notifyArrayDataChanged.call(this, refresh, arrayData, isEmpty);
			// Clear cached data here
		},
		_createColumnInfo: function() {
			if (this._columnInfo) return this._columnInfo;
			this._columnInfo = [];
			var items = this.control.getColumnsInfo();
			var self = this;
			var proto, col;
			items.forEach(function(item, idx) {
				if (item.$isHidden) return;
				proto = self.$itemProto.property(item.$bind);
				if (!proto) return;
				if (!self.isExcluded(item, proto)) {
					col = {
						"$bind": item.$bind,
						"proto": self.$itemProto.create(proto),
						"article": item,
					};
					col.css = [self.$itemProto.getFieldNameForValue(item.$bind)];
					col.title = "";
					self._columnInfo.push(col);
				}
			});
			return this._columnInfo;
		},
		_isHeaderVisible: function() {
			return false;
		},
		_getSep: function() {
			return _seps[this.control.article.$separator || "blank"] || " ";
		},
		_build: function(arrayData, buildOpts) {
			this.control.$$value.empty();
			var $$section = $('<section/>').appendTo(this.control.$$value);
			var self = this;
			var sep = this._getSep(),
				$$sep;
			arrayData.$resources.forEach(function(data, idx) {
				if (idx > 0) {
					$$sep = $('<span class="s-m-separator"/>').appendTo($$section).text(sep);
					if (sep === ",") {
						$$sep.css("text-align", "left");
					}
				}
				self._buildCell($$section, data, idx, buildOpts);
			});
		},
		_buildCell: function($$parent, rowData, idx, buildOpts) {
			var self = this;
			self._columnInfo.forEach(function(col, idx) {
				if (!col.control) {
					col.control = _createCellControl(self.control, $$parent, col, col.proto);
				}
				self.callGenerateHtml(col.control, $$parent, rowData, false, buildOpts, idx);
			});
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/array/ctrlArray',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/application/eventListener','syracuse-tablet/html/js/sdata/sdataUtils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/fieldOperators','syracuse-tablet/html/js/controls/array/searchArray','syracuse-tablet/html/js/application/appFactory','syracuse-tablet/html/js/controls/array/builderTable','syracuse-tablet/html/js/controls/array/builderCard','syracuse-tablet/html/js/controls/array/builderCarousel','syracuse-tablet/html/js/controls/array/builderSeparator'],function (require, exports, module) {"use strict";


var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');
var SearchArray = require('syracuse-tablet/html/js/controls/array/searchArray').Klass;
var factory = require('syracuse-tablet/html/js/application/appFactory');

var _typeDefValue = function(prop) {
	switch (prop.$type) {
		case "application/x-password":
		case "application/x-string":
			return "";
		case "application/x-quantity":
			return 0.0;
		case "application/x-decimal":
		case "application/x-real":
			return 0.0;
		case "application/x-integer":
			return 0;
		case "application/x-boolean":
			return false;
		case "application/x-date":
			return '';
		case "application/x-datetime":
			return '';
		case "application/x-time":
			return '';
		case "application/x-choice":
			return prop.$value.$enum[0].$value;
		case "application/x-reference":
			return {
				$value: "",
				$description: "",
				$title: ""
			};
		case "application/x-array":
			return [];
		default:
			return null;
	}
};
var _dataProps = ["$isMandatory", "$isReadOnly", "$isHidden", "$isExcluded", "$isDisabled", "$actions", "$format"];
var _proto2Instance = function(protoArray) {
	var res;
	if (protoArray.isSingleArray()) {
		res = {
			$properties: {
				"~data~": ""
			}
		};
	} else {
		res = {
			$properties: {}
		};
		var props = protoArray.getDataByPath("$item.$properties");
		for (var propName in props) {
			if (!propName.smStartsWith("$")) {
				var prop = props[propName];
				res[propName] = _typeDefValue(prop);
				var $properties = res.$properties[propName] = {};
				_dataProps.forEach(function(p) {
					if (prop[p] != null) {
						$properties[p] = prop[p];
					}
				});
			}
		}
	}
	return res;
};
/**
 * Manages local pagination
 */
var _LocalPaginator = utils.defineClass(function(arrayCtrl, options) {
	options = options || {};
	this._length = options.length;
	this.count = options.count || 10;
	this._arrayCtrl = arrayCtrl;
	this._nbPagin = Math.floor(this._length / this.count);
	this._lastIdx = this.count * (this._length % this.count === 0 ? this._nbPagin - 1 : this._nbPagin);
	if (this._lastIdx < this.count) this._lastIdx = 0;
	this.first();

}, null, {
	destroy: function(destroyProto) {
		this._arrayCtrl = null;
	},
	first: function() {
		this.currentIdx = 0;
		return this.currentIdx;
	},
	last: function() {
		this.currentIdx = this._lastIdx;
		return this._lastIdx;
	},
	next: function() {
		this.currentIdx = Math.min(this._lastIdx, this.currentIdx + this.count);
		return this.currentIdx;
	},
	prev: function() {
		this.currentIdx = Math.max(0, this.currentIdx - this.count);
		return this.currentIdx;
	},
	isActionEnabled: function(act) {
		switch (act) {
			case "$last":
			case "$next":
				return this.currentIdx < this._lastIdx;
			case "$first":
			case "$previous":
				return this.currentIdx > 0;
		}
	},
	isEnabled: function() {
		return this._length > this.count;
	},
	doAction: function(act) {
		switch (act) {
			case "$next":
				return this.next();
			case "$previous":
				return this.prev();
			case "$first":
				return this.first();
			case "$last":
				return this.last();
		}
	}
});

var _sortFilterExclude = ["application/x-array", "image", "application/x-document", "application/x-binary", "application/x-object", "text/rtf", "text/html", "text/plain"];

var _notImplemented = function(text) {
	throw new Error("The following feature in not implemented -> " + text);
};
var Builders = {
	table: require('syracuse-tablet/html/js/controls/array/builderTable').Klass,
	card: require('syracuse-tablet/html/js/controls/array/builderCard').Klass,
	carousel: require('syracuse-tablet/html/js/controls/array/builderCarousel').Klass,
	separator: require('syracuse-tablet/html/js/controls/array/builderSeparator').Klass
};
var _destroyArrayData = function(a) {
	if (!a || !a.$resources) return null;
	a.$resources.forEach(function(r) {
		if (r) r.destroy();
	});
	return null;
};
/**
 * x-array control class
 * Authoring
 * 			$isTitleHidden: 		true/false
 * 			$height					height of array - if no height displays full array
 * 									add pan event to scroll(no swipe)
 * 			$width					100% by default - not needed
 * 			$displayIfEmpty:		true/false - Maybe a general property for fields to not display the control if empty
 *                              	If false we display the label and default value
 *      							Useful to optimize display
 *  		$emptycell				Ford cards mode - Value! ’empty’, ‘filled’, ‘withtitle’
 * 				empty:		 			doesn't fill grid with empty cells
 * 				filled:					fills grid with empty cells
 * 				withtitle:				fills grid with cards wit titles and default field values
 * 			$display				display mode table / card
 * 			for card
 * 				$cardMode	 			Display mode
 * 					single 					to display one card at a time with a swipe to walk inside the collection
 * 					multiple 				to display a list of cards
 * 				$cardsPerRow 			number of cards per row
 * 										height is calculated in percentage based on control width (full parent page with by default)
 * 				for field array 		s-m-control.s-m-array parent page has class detail or edit
 * 					$pagination				Displays N cards at a time on other ones on swipe
 *         $onselect 					detail 		Open detail fullpage
 *         								fullpage	Open query fullpage
 */
var _Klass = utils.defineClass(
	// CtrlArray used by isInstanceOf 
	function CtrlArray(controller, article, prototype, options) {
		Base.call(this, controller, article, prototype, options);
		this._initArrayAuththoring();
		this._newBuilder(options);
		this._arrayData = null;
		// #6734 - we need to restore the search context (if any) at the creation of SearchArray to allow the page controller to add the clause in sdataUrl
		// This is not the regular process but it's needed
		var savedContext = controller.getCtrlSavedContext(this.$bind);
		this._search = new SearchArray(savedContext ? savedContext.$search : null);
		// All the rows with a link to rowDetail are registered in _rowDetailCache - id: {pathId,pathBind}
		// When we display arrays nested in arrays in card mode we need to store the path to access to the data/proto of the selected row
		// -> Cards Html is generated and the control object is not stored so we need to store the path to retrieve it from mainControl (htmlRootCtrl)
		this._rowDetailCache = {};
		// Info of the clicked row
		this._rowDetailInfo = null;
		// Set the default color - Forced to be modified by authoring
		if (article.$arrayBgColor == null) {
			// Used only in card mode - table has no color
			article.$arrayBgColor = globals.CARDARRAYDEFCOLOR;
		}
	}, Base, {
		_initArrayAuththoring: function() {
			this.$display = this.controller.isEditMode() || !this.article.$display ? "table" : this.article.$display;
			var defaults;
			if (this.controller.isVignette) {
				defaults = {
					showPagination: false,
					showSortFilter: false
				};
			} else if (this.controller.state.type === "chartdetail") {
				defaults = {
					showPagination: false,
					showSortFilter: false,
					showSearch: false
				};
			} else {
				defaults = {
					showPagination: true,
					showSortFilter: true,
					showSearch: true
				};
			}
			defaults.rowIndex = this.$display === "card";
			this.article.$arrayOptions = $.extend(defaults, this.article.$arrayOptions || {});
			if (this.controller.state.type === "chartdetail") {
				// No row detail in chart detail
				this.article.$arrayOptions.showRowDetailLink = false;
			} else if (this.controller.state.type === "rowdetail") {
				// Force in row detail because no authoring
				this.article.$arrayOptions.showRowDetailLink = true;
			} else if (this.article.$arrayOptions.showRowDetailLink == null) {
				// False by default in other pages
				this.article.$arrayOptions.showRowDetailLink = false;
			}
		},
		_newBuilder: function(options) {
			if (this.$display === "carousel") {
				// To keep card mode - carousel is based on card mode
				this.$display = "card";
				options.displayAsCarousel = true;
			}
			// Force one card display for cards nested in cards
			var BuilderClass = Builders[this.$display == "card" ? options.displayAsCarousel ? "carousel" : "card" : this.$display];
			if (!BuilderClass) {
				this.$display = "table";
				BuilderClass = Builders.table;
			}
			this.builder = new BuilderClass(this, this.$display, options);
		},
		isCarouselDisplay: function() {
			return this.$display === "card" && this.options.displayAsCarousel === true;
		},
		getMode: function() {
			return this.builder && this.builder.$display;
		},
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			if (this._arrayData) this._arrayData = _destroyArrayData(this._arrayData);
			if (this.builder) this.builder.initReuseProperties();
			this.$$ttl = null;
		},
		destroy: function() {
			this._multiSelStop();
			// Just set to null - destroyed by rowDetail page
			this._rowDetailInfo = null;
			// Just set to null
			this._rowDetailCache = null;
			if (this._localPaginator) {
				this._localPaginator.destroy();
				this._localPaginator = null;
			}
			Base.prototype.destroy.call(this);
			this.prototype = null;
			if (this.builder) {
				this.builder.destroy();
				this.builder = null;
			}
			if (this._arrayData) {
				this._arrayData = _destroyArrayData(this._arrayData);
				this._arrayData = null;
			}
			if (this._waiting) {
				uiUtils.waitWheelDestroy(this._waiting);
				this._waiting = null;
			}
			if (this._filterSortPanel) {
				this._filterSortPanel.destroy();
				this._filterSortPanel = null;
			}
			if (this._search) {
				this._search.destroy();
				this._search = null;
			}
		},
		isArrayField: function() {
			if (!this.controller) return false;
			return !this.controller.prototype.isQueryLikeFacet();
		},
		/**
		 * Overridden
		 */
		isArrayChart: function() {
			return false;
		},
		/**
		 *	Build html DOM object + bind event
		 **/
		buildHtml: function($$parent, controllerDao, buildOptions) {
			if (this.builder == null) {
				throw new Error("Null builder");
			} else if (this.builder.$display !== this.$display) {
				// Changing display via authoring recreates controls
				throw new Error("Unexpected display type", "Current display", this.builder.$display, "New display", this.$display);
			}
			var css = "s-m-" + this.$display;
			// Build root elm
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions, ["s-m-array", css]);
			// Set up array data and isEmpty property used to managed authoring - Display title
			this._setArrayData(controllerDao, false);
			var hasFilerSort = !this.isArrayField();
			if (hasFilerSort) {
				this._filterSortPanel = this.controller.panelCreate(globals.PANELFILTERSORT, {
					parentArray: this,
					filter: true,
					sort: true
				});
			}
			this.builder.buildHtml(this._arrayData, buildOptions);
			if (this.prototype.isSingleArray() && this.builder.isEmptySingleArray()) {
				// #5529 Special case -> single array and all records with $isHidden = true -> test AQMCRUDM
				this.isEmpty = true;
			}
			// Hidden if no data and no title - take into account this.isEmpty for singleArrays
			//  #6887 Only if array field - For query/Lookup we display no Record
			if (this.isArrayField() && !this._displayArray() && (this.$$ttl == null || this.$$ttl.empty())) {
				this.$$elmt.hide();
			}
		},
		/**
		 * Refreshes the control
		 */
		refresh: function(controllerDao, options) {
			this._rowDetailInfo = null;
			this._capabilities = null;
			if (this.builder == null) throw new Error("Null builder");
			this.builder.refresh(this._setArrayData(controllerDao, true), options);
		},
		onResize: function(context) {
			/**
			 * Add with collapsible stack
			 * We don't display array if not visible because not needed and because card needs a visible element to calculate width/height/padding...
			 * :visible takes into account parents (maybe costly in cpu)
			 * subscibes event expand layout to render the array
			 */
			if (!this.$$elmt || !this.$$elmt.is(':visible')) {
				if (!this._subscribedExpand) {
					this._subscribedExpand = true;
					notifications.subscribe(this, ["sm.layout.expanded"]);
				}
				// No display
				return;
			} else if (this._subscribedExpand) {
				notifications.unsubscribe(this, ["sm.layout.expanded"]);
				this._subscribedExpand = false;
			}
			this.builder.onResize(context);
			//Notifies cell/Tile parent - Display optimization
			this.notifyVignetteArrayHosted();
		},
		/**
		 * synch to select the row before switching tp selected page
		 */
		_notifSelectedRow: function(rowId, rowData) {
			notifications.notifyController("synch.sm.select.row", this.controller, this.id, rowId, rowData);
		},
		/**
		 * handle selection of a row for lookup
		 */
		_actRowSelect: function(rowId, $$target) {
			if (this._multiSelSelect($$target)) {
				return;
			}
			var rowData = this.getRowById(rowId);
			if (!rowData) return;
			rowData = rowData.row;
			if (this.controller.isLookup()) {
				/** SELECTION ON LOOKUP ARRAY**/
				// Proto to allow caller to read/display $description, $title... 
				var proto = $.extend(true, {}, this.prototype.getDataByPath("$item"));
				var data = $.extend(true, {}, rowData.data);
				// Notify selection to lookup page
				this._notifSelectedRow(rowId, {
					data: data,
					proto: proto
				});
			} else {
				/** SELECTION ON REGULAR ARRAY**/
				var links = this.builder.$itemProto.data("$links");
				// We can force the detail link by authoring (Fixed Assets)
				var forceLink = this.getAuthoring("$detailsLink");
				var link;
				if (forceLink == null) {
					forceLink = this.controller.isVignette ? "$queryfullpage" : "$details";
				}
				if (forceLink === "$queryfullpage") {
					if (!this.controller.isVignette) throw new Error("Vignette context expected");
					link = {
						page: this.controller.state.name
					};
					// No selected row in that case
					// Check if there is an article for query link - ONLY FOR TEST ENTITIES
					this._forceArticle = this.article ? this.article.$queryLinkArticle : null;
				} else {
					var linkProto = links[forceLink] ? links[forceLink] : links.$details;
					link = linkProto ? sdataUtils.getLinkInfo(linkProto.$url, rowData) : null;
					// Notify last selected row to current page
					this._notifSelectedRow(rowId, rowData);
					// Check if there is an article for detail link - ONLY FOR TEST ENTITIES
					this._forceArticle = this.article ? this.article.$detailLinkArticle : null;
				}
				if (link) {
					var attrs = {};
					attrs["data-nav"] = link.page;
					attrs["data-nav-target"] = this.controller.openLinkInVignette() ? "vignette" : "application";
					if (link.sDataUrl) {
						attrs["data-sdata-url"] = link.sDataUrl;
					}
					if (link.parameters) {
						var params = utils.parseExpression(link.parameters, rowData);
						attrs["data-sdata-parameters"] = params;
					}
					if (this._forceArticle) {
						attrs["data-link-article"] = this.id;
					}
					eventListener.triggerNavigation(this.$$elmt, attrs);
				}
			}
		},
		/**
		 * Called when we click on editRow, detailRow, createRow
		 * Calculate information dao/proto/name for rorwDetail page
		 * Each time a rowDetail link is generated, we store link info in _rowDetailCache
		 * 		Path of array from the current array
		 * 		Path of row ids from current array
		 * This method retrieve dao/proto objects from stored info
		 * 		rowDetail page needs _rowDetailInfo.dao in lodaData method
		 *  	pageHelpers._getRowdetailPage needs _rowDetailInfo.proto and _rowDetailInfo.pathBind to build rowDetail page proto
		 *
		 *  rowInfofId is the id of the cached info
		 */
		_openDetailRow: function(rowInfofId, activity) {
			var self = this;
			try {
				// Info that has been set by the builder - Contains path of $binds and ids for each row displayed
				var info = self._rowDetailCache[rowInfofId];
				if (!info) throw new Error("rowDetailGetDao - Unexpected null row info");
				var isRowCreation = activity === "create";
				// Path of parent arrays
				var pathBind = info.pathBind;
				if (isRowCreation && pathBind.length > 1) {
					// TODO - Create new row in an array embedded inside a card
					// Currently we force table mode in edit mode
					_notImplemented("Creating row in an array embedded inside a card");
				} else {
					// Ok if not patpathBindhBind.length > 1 in display mode 
					// We allow display of row detail in an arrayy embedded inside a card - Tested
				}
				// Id of parent rows
				var pathId = info.pathId;
				var proto = self.prototype.parent;
				var protoPath = ["$properties"];
				var dao = self.getDao();
				for (var i = 0; i < pathBind.length; i++) {
					protoPath.push(pathBind[i]);
					// Get Proto and dao for the ith array
					proto = proto.getPrototype(protoPath.join("."));
					// Some explanations about the way to retreive the right row dao
					// When we generate cards or grids we don't store controls and associated dao object (see html generator) - We keep only the generated html
					// We need a way to retreive the right row dao when we click on a row Detail link (there are complex use cases with cards arrays inside cards arrays)
					// -> We save the path of row ids and path of $bind in _rowDetailCache
					// To retreive the row dao we scan the current Dao from to pathBinds and pathRowIds
					var arrayData;
					if (self.$bind === pathBind[i]) {
						// We are on the current dao -> we take the current object dao
						// It's important in order to set rowDetail parent with the right dao object
						//  -> pageRegular.notifRowdetailUpdate -> childDao.updateParentRow will update the right parent dao
						arrayData = self._arrayData;
					} else {
						if (!dao) throw new Error("Unexpected null dao");
						// We are on a parent of the current dao -> we create a new dao object
						arrayData = dao.getArrayData(pathBind[i], proto);
					}
					// Search the row by id in dao
					var res = self.getRowById(pathId[i], arrayData);
					if (!res) {
						if (!isRowCreation) throw new Error("Unexpected empty row");
						res = {
							row: self.getArrayEmptyRow(this.controller, proto, pathBind[i], dao)
						};
					}
					// Current dao	
					dao = res.row;
					// Current path root in protoype
					protoPath = ["$item.$properties"];
				}
				if (!dao || dao === self.getDao()) return;
				// Create the dao AND the proto of rowDetail page
				var rowDetailDao = factory.createDaoRowDetail(dao, self.controller, self._getProtoRowDetail(proto));
				if (isRowCreation) {
					rowDetailDao.initParentBasedDefaultValues();
				}
				pathBind = info.pathBind.join('.');
				// Stores row Detail in info - RowDetail info will be requested by rowDetail page in loadData method
				self._rowDetailInfo = {
					// Path of the array from root (page) - use dto calculated the id of the rowDetail page
					pathBind: pathBind,
					dao: rowDetailDao,
					activity: activity
				};
				// Trigger a navigation to rowDetail page
				var attrs = {
					"data-control-id": self.id,
					"data-parent-id": self.controller.id,
					"data-nav": "rowdetail",
					"data-params": dao.getValue("$uuid")
				};
				if (self.controller.isVignette) {
					// It's the vignette which will load the page
					// We open row detail in the same vignette
					attrs["data-nav-target"] = "vignette";
				}
				// Notify last selected row - see selectLastSelectedRow - true to update UI because link doesn't destroy the page
				if (!isRowCreation) {
					// Synch because we want to make sure that controller has been notofied before calling eventListener.triggerNavigation 
					notifications.notifyController("synch.sm.select.row", self.controller, self.id, dao.getValue("$uuid"), null);
				}
				eventListener.triggerNavigation(self.$$elmt, attrs);
			} catch (e) {
				globals.getModal().error("Error loading row detail page", e);
			}
		},
		_getProtoRowDetail: function(proto) {
			var protoJson = {
				$url: "",
				$typ: "rowdetail",
				$links: {}
			};
			// add $links
			if (this.controller.isEditMode()) {
				protoJson.$links.$save = {
					"$title": locale.text("array.links.save")
				};
				// TODO - delete is always possible in rowDetail - for tests
				if (true || this.controller.prototype.getDataByPath("$links.$delete")) {
					protoJson.$links.$delete = {
						"$title": locale.text("array.links.delete"),
						"$confirm": locale.text("actions.del.confirm")
					};
				}
			}
			protoJson.$title = proto.data("$title");
			if (proto.isSingleArray()) {
				var p = $.extend({}, proto.getDataByPath("$item"));
				p.$isMandatory = true;
				p.$isReadOnly = p.$isHidden = p.$isDisabled = false;
				protoJson.$properties = {
					"~data~": p
				};
				return proto.create(protoJson);
			} else {
				return proto.getPrototype("$item", protoJson, this.controller.$activity === "read" ? "details" : "edit");
			}
		},
		getArrayEmptyRow: function(controller, proto, bind, parentDao) {
			var rsrc = _proto2Instance(proto);
			rsrc.$uuid = utils.UUID();
			// We path pathBind as $bind in empty dao to be able to retrieve the full path of prototype in nested arrays
			return factory.createDaoSdata(rsrc, this._getProtoRowDetail(proto), {
				parent: parentDao,
				$bind: bind,
				enableWorkingCopy: parentDao.enableWorkingCopy
			});
		},
		/**
		 * Click on display or edit row detail
		 * Id is stored in s-m-record parent dom elment
		 */
		_actRowDetail: function(rowInfofId, target, event) {
			this._openDetailRow(rowInfofId, this.controller.isEditMode() ? "edit" : "read");
			if (event) {
				event.stopPropagation();
			}
		},
		/**
		 * Click on create a new row
		 * Id is stored data-cation element
		 * This action is not really a row action, it's an array action
		 */
		_actRowCreate: function(rowInfofId) {
			this._openDetailRow(rowInfofId, "create");
		},
		/**
		 * handle delete row
		 */
		_actRowDelete: function(rowId) {
			var self = this;
			// Info that has been set by the builder - Contains path of $binds and ids for each row displayed
			var info = self._rowDetailCache[rowId];
			if (!info) return;
			modal.simpleConfirm(locale.text("actions.del.confirm"), function(confirmed) {
				if (confirmed) {
					// Retreive the current array in path
					var pathBind = info.pathBind;
					var pathId = info.pathId;
					while (pathBind.length != 0 && pathBind[0] != self.$bind) {
						pathBind.shift();
						pathId.shift();
					}
					if (pathBind.length == 0) throw new Error("Unexpected null pathBind");
					var field = pathBind.pop();
					/**
					 * pathBind.length > 1 means that we have to retreive the row in a child according to pathId
					 * We can have this case if we edit an array cards inside a card. The current array is th card's parent and we wantto delete the row in a child array
					 * --> Not implemented for the moment because not tested
					 */
					if (pathBind.length > 1 || field !== self.$bind) {
						_notImplemented("Deleting row in an array embedded inside a card");
					} else {
						// TODO - Retreive the row in newted child arrays (id is unic) and delete it
					}
					// Temporarily - Remove row in current array
					self.removeRow(rowId);
				}
			});
		},
		/**
		 * Remove rowId in datasets and html
		 * Can be called also from regularPage when we click on Delete action in rowDetail footer
		 */
		removeRow: function(rowId) {
			// Remove the row in _arrayData
			var array = this._arrayData;
			if (!array || !array.$resources || array.$resources.length == 0) return;
			var idx = -1;
			array.$resources.some(function(r, i) {
				if (r.getValue("$uuid") === rowId) {
					idx = i;
					return true;
				}
			});
			if (idx < 0 || idx >= array.$resources.length) return;
			array.$resources.splice(idx, 1);
			// Remove the row in html	
			this.builder.removeRowById(rowId);
			// Remove the row in dao - If it's a single array we use idx becaus there's no uuid in backoffice data (uuid is added by tablet client in arrayData to manage singleArrasy like other arrays)
			this.getDao().deleteRow(this.$bind, this.prototype.isSingleArray() ? idx : rowId);
		},
		/**
		 * Register a row in rowDetail cache to be able to reteive infortiaon on ckcik on 'rowDetail' Link (_actRowDetail)
		 */
		rowDetailAdd: function(id, data) {
			this._rowDetailCache[id + ""] = data;
		},
		/**
		 *  Return the dao and other information of the selected row (see _actRowDetail)		 *
		 **/
		rowDetailGetInfo: function(create) {
			// Read/ Edit row detail
			return this._rowDetailInfo;
		},
		/**
		 * Return the page info used buy pageRegistry
		 */
		childPageGetPageInfo: function(typePage) {
			var pageInfo = {
				home: false,
				type: typePage,
				cached: false,
				refreshed: false
			};
			if (typePage === "rowdetail") {
				if (!this._rowDetailInfo) throw new Error("childPageGetPageInfo - Null details row data");
				// Proto is given by dao
				pageInfo.prototype = this._rowDetailInfo.dao.prototype;
				pageInfo.subtype = this.controller.isEditMode() ? "edit" : "details";
				pageInfo.article = null;
				// To store the generated page in aplication page we nee the full path of the selected row
				// By exmaple for AQMCRUDM -  if we add a $article to the array level 1 we display i the card array level 2
				// When we click on rowDetail we need to display the row of level 2 ADEVADEVICEL.ADEVADEVICELADEVICELL
				// Page name is 
				//		AQMCRUDM.$details.ADEVADEVICEL if no article in ADEVADEVICEL
				//		AQMCRUDM.$details.ADEVADEVICEL.ADEVADEVICELADEVICELL if there's an article in ADEVADEVICEL
				//		AQMCRUDM.$details.ADEVADEVICEL.ADEVADEVICELADEVICELL.ADEVADEVICELADEVICELLDLLLif there's an article in ADEVADEVICEL.ADEVADEVICELADEVICELL
				pageInfo.name = this.controller.state.name + "." + this._rowDetailInfo.pathBind;
			} else if (typePage === "carddesign") {
				pageInfo.prototype = this._getProtoCardDesign();
				pageInfo.subtype = "details";
				pageInfo.article = this.article.$card ? this.article.$card : null;
				pageInfo.name = this.controller.state.name + "." + this.$bind + "." + typePage;
			}
			return pageInfo;
		},
		/**
		 * Select the last selected row
		 * lastSelectedrow is stored in page context and restores on back
		 * It highlights the last selected row
		 * Done by builder because depends on the way array has been rendered
		 */
		selectLastSelectedRow: function(rowId, show) {
			this.builder.selectLastSelectedRow(rowId, show);
		},
		/**
		 *	returns array rows
		 *		depends on the kind of page query/lookup or detail/edit
		 *		called one time to create the dao - then use getArrayData()
		 **/
		readArrayData: function(controllerDao) {
			if (this.options.localPagination === true && this._localPaginator == null) {
				this._localPaginator = this.createLocalPaginator(controllerDao);
				if (this._localPaginator == null) {
					this.options.localPagination = false;
				}
			}
			var res;
			if (this.prototype.isQuery()) {
				res = controllerDao.getQueryData(this.prototype, this._localPaginator);
			} else if (this.prototype.isLookup()) {
				res = controllerDao.getLookupData(this.prototype, this._localPaginator);
			} else if (this.prototype.isCube()) {
				res = controllerDao.getCubeData(this.$bind, this.prototype, this._localPaginator);
			} else {
				res = controllerDao.getArrayData(this.$bind, this.prototype, this._localPaginator);
			}
			if (!res || !res.$resources) {
				res = {
					$resources: []
				};
			}
			return res;
		},
		hasLocalPagination: function() {
			return this._localPaginator != null && this._localPaginator.isEnabled();
		},
		createLocalPaginator: function(controllerDao) {
			throw new Error("Not implemented");
		},
		getLocalPaginator: function() {
			return this._localPaginator;
		},
		_actPagination: function(linkName, target, event) {
			if (this._localPaginator) {
				this._localPaginator.doAction(linkName);
				this.refresh(this.controller.dao);
			} else {
				var attrs = {
					"data-nav-refresh": true,
					"data-nav-type": linkName,
					"data-sdata-url": this.prototype.resolveExpression(this.getArrayData().$links[linkName].$url),
					"data-control-id": this.id,
					"data-nav-target": this.controller.isVignette ? "vignette" : "application"
				};
				eventListener.triggerNavigation(this.$$elmt, attrs);
			}
		},
		/**
		 *	Set array data - depends on array type
		 **/
		_setArrayData: function(controllerDao, refresh) {
			this._multiSelReset();
			this.isEmpty = true;
			if (!this.hasLocalPagination()) {
				_destroyArrayData(this._arrayData);
			}

			this._arrayData = this.readArrayData(controllerDao);
			this.isEmpty = this._arrayData.$resources.length === 0;
			this.$$elmt.toggleClass("empty", this.isEmpty);
			if (this.builder) {
				this.builder.notifyArrayDataChanged(refresh, this._arrayData, this.isEmpty);
			}
			// Clear control content
			this.clearContent(refresh);
			if (!refresh) {
				// Build the base structure common to all ctrls - Title and value
				var title = this.getTitle();
				if (this._displayTitle(title)) {
					if (!this.$$ttl) this.$$ttl = $(uiUtils.createDomElement('div', ["s-m-title"])).appendTo(this.$$elmt);
					this.$$ttl.text(title);
				} else if (this.$$ttl) {
					this.$$ttl.empty();
				}
				// After title
				this.$$value = $(uiUtils.createDomElement('div', ["s-m-value"], null, null, this.$$elmt));
				this.$$value.before(this.$$header = $('<header/>'));
				if (this.$display === "card") {
					var bgColor = (this.article.$arrayBgColor || "").toLowerCase();
					if (bgColor.length > 0) {
						bgColor = "s-m-color-" + bgColor;
					}
					if (bgColor) {
						this.$$value.addClass("s-m-bg " + bgColor);
					}
				}
			}
			return this._arrayData;
		},
		/**
		 * !! Notify the builder that the content is cleared - chart builder destroy the plugin highchart
		 */
		clearContent: function(refresh) {
			if (this.builder) {
				this.builder.notifClearContent(refresh);
			}
			if (refresh) {
				this.$$value.empty();
			} else {
				this.$$elmt.empty();
			}
		},
		_displayTitle: function(title) {
			if (title == null || title.trim().length === 0) return false;
			if (this.getAuthoring("$isTitleHidden") === true) return false;
			return this._displayArray();
		},
		_displayArray: function() {
			return this.controller.isEditMode() === true || this.isEmpty !== true || this.getAuthoring("$displayIfEmpty") === true;
		},
		/**
		 *	returns array rows
		 *		controllerDao optional
		 **/
		getArrayData: function() {
			return this._arrayData;
		},
		getNbRecords: function() {
			return this._arrayData ? this._arrayData.$resources.length : 0;
		},
		waitWheelStart: function() {
			if (!this._waiting) {
				// TODO - Optimization
				this._waiting = uiUtils.waitWheelCreate(this.$$elmt.parent());
				this._waiting.$$bckg.css({
					position: "absolute"
				});
				this._waiting.$$wheel.css({
					position: "absolute"
				});
			}
			uiUtils.waitWheelStart(this._waiting);
		},
		waitWheelStop: function() {
			if (this._waiting) {
				uiUtils.waitWheelStop(this._waiting);
			}
		},
		// arrayData is used for recursice search in arrays nested in arrays
		getRowById: function(rowId, arrayData) {
			var self = this;
			arrayData = arrayData || self._arrayData;
			if (!arrayData || !arrayData.$resources || arrayData.$resources.length == 0) return null;
			var idx = 0;
			var result = null;
			arrayData.$resources.some(function(r) {
				if (r.getValue("$uuid") === rowId) {
					result = r;
					return true;
				}
				idx++;
			});
			return result ? {
				row: result,
				idx: idx
			} : null;
		},
		// Used for single Arrays
		_getRowByIdx: function(idx, arrayData) {
			arrayData = arrayData || this._arrayData;
			idx = parseInt(idx, 10);
			if (!arrayData || !arrayData.$resources || arrayData.$resources.length <= idx) return null;
			return {
				row: arrayData.$resources[idx],
				idx: idx
			};
		},
		/**
		 * return the context to save. It will be be restored afer page has been loaded
		 * type	back/link - Used to manage the content according to the type
		 */
		savedCtxCreate: function(type) {
			if (!this.builder) return;
			var res = {
				$builder: this.builder.savedCtxCreate(type)
			};
			if (this._search) {
				// Stores the search context to restore it on back - detail -> list #6734
				res.$search = this._search.savedCtxCreate(type);
			}
			return res;
		},
		/**
		 * Called by the page to restore the context
		 */
		savedCtxRestore: function(ctx) {
			// $search context is not restored beacause it's done in constructor (not regular process)
			if (ctx && ctx.$builder) {
				this.builder.savedCtxRestore(ctx.$builder);
			}
		},
		getScrollViewRect: function() {
			if (this.controller.isVignette) {
				var v = this.controller.getParentVignette();
				return v ? v.getScrollViewRect() : null;
			} else {
				return this.controller.getMainContentRect();
			}
		},
		/**
		 * Returns idx from rowId
		 * Used by single arrays
		 */
		rowId2Idx: function(uuid) {
			if (!this._arrayData || !this._arrayData.$resources) return -1;
			var rowIdx = -1;
			this._arrayData.$resources.some(function(r, idx) {
				if (r.getValue("$uuid") === uuid) {
					rowIdx = idx;
					return true;
				}
			});
			return rowIdx;
		},
		_actActionArray: function(id, param) {
			if (id === globals.PANELFILTERSORT) {
				// Manual filters
				this.controller.panelAttach("right", this._filterSortPanel, "toggle");
				notifications.publish("sm.click.icon.filterSort", param.context);
				return;
			}
			if (id === "filterSelected") {
				// Selection of a filter given by the proto
				this.controller.$filtersSelect(param);
				return;
			}
			if (id === "search") {
				this.getSearcher().search(this);
				this.controller.searchRefresh();
				return;
			}
			if (id === "removeSearch") {
				this.getSearcher().removeSearch(this);
				this.controller.searchRefresh();
				return;
			}
		},
		/**
		 *  return array of sortInfo (not null)
		 */
		sortInfoGet: function() {
			var info = this.controller.filterSortRead("sort");
			if (info == null || info.length === 0) {
				var cols = this.builder.getColumnsInfo(true);
				if (cols) {
					info = [];
					cols.forEach(function(c) {
						if (_sortFilterExclude.indexOf(c.$type) === -1 && c.$capabilities && c.$capabilities.indexOf("sort") >= 0) {
							info.push({
								name: c.$title,
								// $bindValue is $bind for non reference field
								id: c.$bindValue,
								sort: "none"
							});
						}
					});
				}
				this.sortInfoSet(info, false);
			}
			return info;
		},
		sortInfoSet: function(info, refresh) {
			this.controller.filterSortWrite("sort", info, refresh);
		},
		/**
		 *  returns an array of filterInfo
		 */
		filterInfoGet: function() {
			var info = this.controller.filterSortRead("filter");
			return info;
		},
		/**
		* Sets filter info. Array of objects 
		* {
		*	fieldName : "fieldName",
		*	operatorLabel: "operator label",
		*	value: "value",
		*	operator: "operator code"
		}
		*/
		filterInfoSet: function(info, refresh) {
			this.controller.filterSortWrite("filter", info, refresh);
		},

		/**
		 * Returns filters map with following structure
		 *  [{
		 *		fieldName: 'field name',
		 *		operators: [], // array of possible operators according to field type,
		 *		id: proto.getFieldNameForValue(key),
		 *		prop: propertyValue, // Object
		 *		isReference: isReference // Boolean. Whether property is a reference or not
		 *	}, ...]
		 */
		searchInfoGet: function() {
			return this.getSearcher().getSearchInfos();
		},
		filterMapGet: function() {
			var self = this;
			var map = [];
			var props = this.builder.getColumnsInfo(false);
			if (props) {
				props.forEach(function(prop) {
					if (_sortFilterExclude.indexOf(prop.$type) === -1 && prop.$capabilities && prop.$capabilities.indexOf("filter") >= 0) {
						map.push({
							fieldName: prop.$title,
							operators: fieldOperators.getOperators(prop.$type),
							// $bindValue is $bind for non reference field
							id: prop.$bindValue,
							prop: prop,
							isReference: prop.$type.indexOf("x-reference") >= 0
						});
					}
				});
			}
			return map;
		},
		/**
		 * Retunrs the option for header - Should work in buildHtml and refresh
		 */
		getHeaderOptions: function() {
			var queryOrLookup = !this.isArrayField();
			var opts = {};
			// This is a query array
			// Manual sort/filters
			opts.filterEnabled = opts.sortEnabled = opts.paginEnabled = opts.searchEnabled = queryOrLookup;
			opts.searchEnabled = (opts.searchEnabled && !this.controller.offLine);
			// Filters given by prototype
			opts.$filters = queryOrLookup && this.controller.$filtersGet ? this.controller.$filtersGet() : null;
			// No search and filters for requests
			if (this.controller.prototype.isRequest() || this.controller.prototype.isStatistics()) {
				opts.sortEnabled = opts.searchEnabled = opts.filterEnabled = false;
				opts.$filters = null;
			}
			return opts;
		},
		/**
-		 * none/tabs/list
		 */
		$filtersGetAuthoring: function() {
			var auth = this.getAuthoring("$filters", this.controller.isVignette ? "none" : "list");
			if (auth !== "none" && globals.getSiteLayout().getDeviceType() === "smartphone") {
				auth = "tabs";
			}
			return auth;
		},
		/**
		 * enable/disable multiselection
		 */
		multiSelSetMgr: function(mgr) {
			if (this._multiselHandler) {
				this._multiselHandler = null;
			}
			if (mgr) {
				this._multiselHandler = jsutils.bindFn(mgr.callbackArray, mgr);
			}
		},
		/**
		 * Array as changed - Exit multisselection if any
		 */
		_multiSelStop: function() {
			if (this._multiselHandler) {
				this._multiselHandler(this, "$stopmultisel", null);
			}
		},
		_multiSelReset: function() {
			if (this._multiselHandler) {
				this._multiselHandler(this, "$reset", null);
			}
		},
		/**
		 * Row selection
		 */
		_multiSelSelect: function($$target) {
			if (this._multiselHandler) {
				this._multiselHandler(this, "$selectmultisel", $$target);
				return true;
			}
			return false;
		},
		/**
		 * Multiselection action is selectAll, unselectAll
		 * data-action with ctrlmId == array's id
		 */
		_actMultiSelectionAction: function(params, $target) {
			if (!this._multiselHandler) return;
			this._multiselHandler(this, params, $target);
		},
		authOnSlideMinSize: function(size, action) {
			if (!this.builder.authMinSize2Pixels) return;
			if (this.builder.$display != "card" || !this._arrayData || this._arrayData.length > 0) return;
			var value = this.builder.authMinSize2Pixels(size);
			var left = ((this.$$value.width() - value) / 2) + "px";
			value += "px";
			if (action == "start") {
				var height = this.$$value.find(this.$$value.find('[data-params="' + this._arrayData.$resources[0].getValue("$uuid") + '"]')).height();
				this.$$value.css({
					opacity: "0.3"
				});
				this._$$cardSize = $('<div class="s-m-auth-minsize"><span>Min size' + value + '</span></div>').appendTo(this.$$elmt);
				this._$$cardSize.css({
					height: height + "px",
					width: value,
					top: ((this.$$value.height() - height) / 2) + "px",
					left: left
				});
				return;
			}
			if (action == "stop") {
				this.$$value.css({
					opacity: "inherit"
				});
				this._$$cardSize.remove();
				this._$$cardSize = null;
				return;
			}
			if (action == "slide") {
				if (this._$$cardSize) {
					// slide action is called to get the text to display before starting the slider
					this._$$cardSize.css({
						width: value,
						left: left
					});
					if (!this._minCardText) {
						this._minCardText = locale.text("array.minCardWidth") + " ";
						this._minCardSpan = this._$$cardSize.children("span");
					}
					this._minCardSpan.text(this._minCardText + value);
				}
				return value;
			}
		},
		setCardAuthoring: function(article) {
			this.article.$card = article;
			notifications.publish("sm.auth.change.item.prop.ui");
		},
		// Only for test entities - We can attach an article to a link to detail or query
		getLinkedPageArticle: function() {
			return this._forceArticle;
		},
		notifLayoutExpanded: function() {
			// If we display an array on bloc expand we need to rfresh the scroller onec array has been displayed - #6541
			var self = this;
			setTimeout(function() {
				// Resize the array to rebuild it
				self.onResize({
					// To force array to build
					scrollOnly: false,
					// To notify controller
					layoutExpanded: true
				});
				var controller = self.controller;
				if (controller.isVignette) {
					var dashBoard = controller.getVignettePageDashboard();
					if (dashBoard.isDashboard("stack")) {
						controller = dashBoard;
					}
				}
				notifications.notifyController("sm.scroller.update", controller);
			});
		},
		getSearcher: function() {
			return this._search;
		},
		checkCapabilities: function(value) {
			if (value == null) return true;
			if (!this._capabilities) {
				this._capabilities = {};
				var self = this;
				(this.getMetaData("$capabilities") || "").split(',').forEach(function(c) {
					c = c.trim();
					if (c.length > 0) {
						self._capabilities[c.trim()] = true;
					}
				});
			}
			return this._capabilities[value] === true;
		},
		getRowStatusInfo: function() {
			var type = this.getAuthoring("$statusEnabled");
			if (type === "mono" || type === "multi") {
				var status = this.getAuthoring("$status");
				if (!status || status.length === 0) return null;
				return {
					type: type,
					list: status
				};
			}
			return null;
		},
		/**
		 * Used by external tools (multiselection) to disable status temprorarily in cards
		 */
		toggleCardStatusColor: function(disable) {
			if (this.$display === "table") return;
			if (!this.getRowStatusInfo()) return;
			var style = disable ? "inherit" : "";
			this.$$value.find(".s-m-status-color").css({
				"background-color": style,
				"color": style
			});
		},
		/**
		 * Height/Width available to render the array
		 */
		getAvailableSize: function() {
			return {
				height: this.$$elmt.height() - this.$$header.height(),
				width: this.$$value.width()
			};
		},
		_actExternalLink: function(param) {
			this.controller.externalLink(param);
		},
		// Called by builder - can be overriden (chart array)
		setEmptyArrayMsg: function() {
			if (!this.isArrayField()) {
				var title = this.getTitle();
				if (title) {
					// Set in $$value to be removed on refresh
					$('<div class="s-m-no-data-title"/>').appendTo(this.$$value).text(title);
				}
				// Set in $$value to be removed on refresh
				$('<div class="s-m-no-data-label"/>').appendTo(this.$$value).text(locale.text("array.empty"));
			} else {
				// No label
			}
		},
		/**
		 * Call cell/tile parent (if any) to inform the that a array is nested in a vignette (query/stats/request only)
		 * Used to improve display - call notifSpecialArrayHosted method directly
		 * typeArray: chart/carousel
		 */
		notifyVignetteArrayHosted: function() {
			if (this.isArrayField() || this.prototype.isLookup() || !this.controller.isVignette || !this.controller.getParentVignette()) return;
			// Query/stats/requests....only
			var parent = this.controller.getParentVignette().parent;
			// Notifies cell/tile to improve display when a chart/carousel is nested
			// hack to remove the background color since we manage it by js (not css)
			if (parent && parent.notifSpecialArrayHosted) {
				var typeArray = this.isCarouselDisplay() ? "carousel" : this.$display;
				parent.notifSpecialArrayHosted(typeArray);
			}
		},
		_getProtoCardDesign: function() {
			var proto = this.prototype;
			var protoJson = {
				$url: "",
				$typ: "carddesign",
				$title: this.$bind,
				$links: {}
			};
			if (proto.isSingleArray()) {
				throw new Error("No card design for single array");
			} else {
				proto = proto.getPrototype("$item", protoJson, "details");
				var props = proto.data("$properties");
				Object.keys(props).forEach(function(key) {
					props[key].$isHidden = false;
				});
				return proto;
			}
		},
		isAuthoringPropAllowed: function(property, value) {
			if (property !== "arrayDisplay") {
				return Base.prototype.isAuthoringPropAllowed.call(this, property, value);
			}
			switch (value) {
				case "table":
					return true;
				case "separator":
					return this.prototype.isSingleArray();
				case "card":
				case "carousel":
					return !this.prototype.isSingleArray();
				default:
					return false;
			};
		},
		getColumnsInfo: function(onlyVisible) {
			var protoInfo = this.prototype.arrayTableGetColInfo();
			if (onlyVisible !== true || this._arrayData == null || this._arrayData.$properties == null) return protoInfo;
			// check if column is visible
			var res = [];
			var dataProps = this._arrayData.$properties;
			protoInfo.forEach(function(prop) {
				if (dataProps[prop.$bind] == null || dataProps[prop.$bind].$isHidden !== true) {
					res.push(prop);
				}
			});
			return res;
		},
		acceptRowSelection: function() {
			if (this.controller.isEditMode()) {
				// In order to generate the rowID in record dom element
				return true;
			}
			if (this.article.$arrayOptions.showRowDetailLink === true) {
				return true;
			}
			if (this.prototype.isLookup()) return true;
			var links = this.builder.$itemProto.data("$links");
			if (!links) return false;
			var forceLink = this.getAuthoring("$detailsLink");
			return (forceLink && links[forceLink] != null) || links.$details != null;
		}
	});

exports.Klass = _Klass;
exports.LocalPaginator = _LocalPaginator;
});

define('syracuse-tablet/html/js/controls/chart/cubeChartsTheme',['require','exports','module'],function (require, exports, module) {"use strict";

var theme = {
	//colors: ['#007f64', '#34b233', '#4d4f53', '#9a9b9c', '#ff5800', '#009fda', '#6639b7' /*green brightgreen darkgrey midgray orange blue purple*/ , '#409f8b', '#67c566', '#7a7b7e', '#b3b4b5', '#ff8240', '#40b7e3', '#8c6bc9', /*75%*/ /*'#7fbfb1','#99d899','#a6a7a9','#cccdcd','#ffab7f','#7fcfec','#b29cdb',50%*/ ],
	colors: ['#BF7070', '#BFB730', '#7ABF30', '#7373FF', '#BF7730', '#BF3080', '#30BF9F', '#FF7373', '#FFF773', '#85FF00', '#3030BF', '#FF9F40', '#FF40BC', '#1699A6', '#FF0000', '#FFF100', '#00FF00', '#0000FF', '#FF7F00', '#FF00A6', '#00FFC6', '#A60000', '#A69C00', '#56A600', '#90B2FF', '#A65200', '#A6006C', '#00A681', '#FF4040', '#FFF440', '#A3FF40', '#3673FF', '#FFB873', '#FF76CE', '#73FFED'],
	chart: {
		borderRadius: '0',
		spacingTop: 10,
		backgroundColor: '#fff',
		borderColor: '#ccc',
		borderWidth: 1,
		className: 'dark-container',
		// backgroundColor: {
		//	linearGradient: [250, 250, 250, 400],
		// 	stops: [
		// 		[0, 'rgb(250, 250, 250)'],
		// 		[1, 'rgb(240, 240, 240)']
		// 	]
		// },
		resetZoomButton: {
			theme: {
				fill: 'white',
				stroke: '#dddddd',
				r: 0,
				states: {
					hover: {
						fill: '#00a1de',
						style: {
							color: 'white'
						}
					}
				}
			},
			position: {
				// align: 'right', // by default
				// verticalAlign: 'top', // by default
				x: -50,
				y: 5
			},
			relativeTo: 'chart'
		}
	},
	title: {
		style: {
			color: '#464646',
			font: 'bold 16px "Trebuchet MS", Verdana, sans-serif'
		}
	},
	subtitle: {
		style: {
			color: '#464646',
			font: 'bold 12px "Trebuchet MS", Verdana, sans-serif'
		}
	},
	xAxis: {
		gridLineColor: 'rgba(0, 0, 0, 0.05)',
		gridLineDashStyle: 'longdash',
		gridLineWidth: 1,
		labels: {
			style: {
				color: '#A0A0A0'
			}
		},
		lineColor: 'rgba(0, 0, 0, 0.2)',
		tickColor: 'rgba(0, 0, 0, 0.2)',
		title: {
			style: {
				color: '#464646',
				fontWeight: 'bold',
				fontSize: '15px',
				fontFamily: 'arial',
			}
		}
	},
	yAxis: {
		minorGridLineColor: 'rgba(0, 0, 0, 0.05)',
		minorTickInterval: 'auto',
		/*alternateGridColor: 'rgba(0, 0, 0, 0.02)',*/
		gridLineWidth: 2,
		gridLineColor: 'rgba(0, 0, 0, 0.07)',
		labels: {
			align: 'left',
			x: 0,
			y: 12,
			style: {
				color: '#A0A0A0'
			}
		},
		lineColor: 'rgba(0, 0, 0, 0.07)',
		/*minorTickInterval: null,*/

		title: {
			style: {
				color: '#CCC',
				fontSize: '16px',
				fontFamily: 'Georgia, Verdana, sans-serif',
				fontStyle: 'italic',
			}
		}
	},
	tooltip: { /*backgroundColor: 'rgba(250,250, 250, 0.75)',*/
		backgroundColor: '#464646',
		borderRadius: '0',
		style: {
			color: '#fff',
			/*fontFamily: '"georgia"',
			fontStyle: 'italic',*/
			fontSize: '12px',
			padding: '5px',
			whiteSpace: 'nowrap',

		}
	},
	toolbar: {
		itemStyle: {
			color: 'silver'
		}
	},
	plotOptions: {
		series: {
			marker: { /*	fillColor: '#FFFFFF',*/
				lineWidth: 2,
				lineColor: null,
				// inherit from series,
				radius: 4,
				states: {
					hover: {
						radius: 8,
						lineColor: null,
					}
				}
			}
		},
		area: {
			fillOpacity: 0.15

		},
		areaspline: {
			fillOpacity: 0.15
		},
		line: {
			dataLabels: {
				color: '#CCC'
			},
			marker: {
				lineColor: '#FFFFFF',
			}
		},
		spline: {
			marker: {
				lineColor: '#FFFFFF',
			}
		},
		scatter: {
			marker: {
				lineColor: '#FFFFFF'
			}
		},
		candlestick: {
			lineColor: '#FFFFFF',
			animation: {
				duration: 2000,
				easing: 'easeOutBounce'
			}
		},
		pie: {
			allowPointSelect: true,
			cursor: 'pointer',
			borderColor: 'rgba(250,250,250,0.3)',
			borderWidth: 0.5,
			dataLabels: {
				enabled: true,
				connectorWidth: 2,
				color: '#464646',
				style: {
					fontWeight: 'bold'
				}
			},
		},

	},
	legend: {
		borderRadius: 0,
		borderWidth: 1,
		// borderColor: '#dddddd',
		backgroundColor: 'white',
		//shadow: true,
		itemMarginTop: 8,
		itemStyle: {
			color: '#464646',
			fontFamily: '"arial"',
			fontWeight: 'bold',
			/*fontStyle: 'italic',*/
			fontSize: '8pt ',
		},
		itemHoverStyle: {
			color: '#00a1de'
		},
		itemHiddenStyle: {
			color: '#555'
		},
		title: {
			style: {
				color: '#464646',
				fontWeight: 'bold',
				fontSize: '8pt',
				fontFamily: 'arial',
			}
		}
	},
	credits: {
		enabled: false,
		style: {
			color: '#666'
		}
	},
	labels: {
		style: {
			color: '#CCC'
		}
	},

	exporting: {
		buttons: {
			drillUp: {
				symbolStroke: '#fff',
				symbolFill: 'rgba(250,250,250,0.5)',
				hoverSymbolStroke: '#fff',
				hoverSymbolFill: 'rgba(250,250,250,0.5)',

			},
			exportButton: {
				symbolStroke: '#fff',
				symbolFill: 'rgba(250,250,250,0.5)',
				hoverSymbolStroke: '#fff',
				hoverSymbolFill: 'rgba(250,250,250,0.5)',

			},
			printButton: {
				symbolStroke: '#fff',
				symbolFill: 'rgba(250,250,250,0.5)',
				hoverSymbolStroke: '#fff',
				hoverSymbolFill: 'rgba(250,250,250,0.5)',
			}
		}
	},

	// scroll charts
	rangeSelector: {
		buttonTheme: {
			fill: {
				linearGradient: [0, 0, 0, 20],
				stops: [
					[0.4, '#888'],
					[0.6, '#555']
				]
			},
			stroke: '#000000',
			style: {
				color: '#CCC',
				fontWeight: 'bold'
			},
			states: {
				hover: {
					fill: {
						linearGradient: [0, 0, 0, 20],
						stops: [
							[0.4, '#BBB'],
							[0.6, '#888']
						]
					},
					stroke: '#000000',
					style: {
						color: 'white'
					}
				},
				select: {
					fill: {
						linearGradient: [0, 0, 0, 20],
						stops: [
							[0.1, '#000'],
							[0.3, '#333']
						]
					},
					stroke: '#000000',
					style: {
						color: 'yellow'
					}
				}
			}
		},
		inputStyle: {
			backgroundColor: '#333',
			color: 'silver'
		},
		labelStyle: {
			color: 'silver'
		}
	},

	navigator: {
		handles: {
			backgroundColor: '#666',
			borderColor: '#AAA'
		},
		outlineColor: '#CCC',
		maskFill: 'rgba(16, 16, 16, 0.5)',
		series: {
			color: '#7798BF',
			lineColor: '#A6C7ED'
		}
	},

	scrollbar: {
		barBackgroundColor: {
			linearGradient: [0, 0, 0, 20],
			stops: [
				[0.4, '#888'],
				[0.6, '#555']
			]
		},
		barBorderColor: '#CCC',
		buttonArrowColor: '#CCC',
		buttonBackgroundColor: {
			linearGradient: [0, 0, 0, 20],
			stops: [
				[0.4, '#888'],
				[0.6, '#555']
			]
		},
		buttonBorderColor: '#CCC',
		rifleColor: '#FFF',
		trackBackgroundColor: {
			linearGradient: [0, 0, 0, 10],
			stops: [
				[0, '#000'],
				[1, '#333']
			]
		},
		trackBorderColor: '#666'
	},

	// special colors for some of the
	legendBackgroundColor: 'rgba(0, 0, 0, 0.5)',
	legendBackgroundColorSolid: 'rgb(35, 35, 70)',
	dataLabelsColor: '#444',
	textColor: '#C0C0C0',
	maskColor: 'rgba(255,255,255,0.3)'
};

var colors = theme.colors;

// Options for Org chart view
theme.orgChart = {
	node: {
		textColor: 'black ',
		borderColor: colors[1],
		borderWidth: 2,
		backgroundColor: 'white ',
		fontWeight: 'normal ',
		hover: {
			backgroundColor: colors[3],
			textColor: 'white '
		}
	},
	junction: {
		lineColor: colors[3],
		lineWidth: 2
	},
	dropMarker: {
		borderColor: colors[1],
		borderWidth: 0,
		backgroundColor: colors[4],
		backgroundOpacity: 1
	},
	tooltip: {
		backgroundColor: colors[1],
		backgroundOpacity: 1,
		borderWidth: 2,
		borderRadius: 0,
		borderColor: colors[2],
		style: {
			color: '#fff',
			/*fontFamily: '"georgia"',
			fontStyle: 'italic',*/
			fontSize: '12px',
			padding: '5px',
			whiteSpace: 'nowrap',
		}
	}
};

theme.version = Highcharts.version.split(".").map(function(e) {
	return parseInt(e, 10);
});

if (theme.version[0] === 2) {
	// theme.navigation = {
	// 	buttonOptions: {
	// 		borderRadius: 50,
	// 		height: 24,
	// 		width: 24,
	// 		backgroundColor: '#00acec',
	// 		borderColor: '#00a1de',
	// 		symbolX: 12,
	// 		symbolY: 12,
	// 	}
	// },
} else if (theme.version[0] === 3) {
	theme.navigation = {
		buttonOptions: {
			symbolStroke: '#DDDDDD',
			hoverSymbolStroke: '#FFFFFF',
			theme: {
				fill: {
					linearGradient: {
						x1: 0,
						y1: 0,
						x2: 0,
						y2: 1
					},
					stops: [
						[0.4, '#606060'],
						[0.6, '#333333']
					]
				},
				stroke: '#000000'
			}
		}
	};

	delete theme.exporting;
}

exports.theme = theme;
});

define('syracuse-tablet/html/js/controls/array/builderChartBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/array/builderBase','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/controls/chart/cubeChartsTheme','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/array/builderBase').Klass;
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var theme = require('syracuse-tablet/html/js/controls/chart/cubeChartsTheme').theme;
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');

var _merge = Highcharts.merge;
var objectClone = function(o) {
	return $.extend({}, o);
};

Highcharts.theme = theme;
Highcharts.setOptions(Highcharts.theme);

var colors = Highcharts.theme.colors;

var _style = function($style) {
	var map = {
		xy: "line",
		point: "scatter",
		stick: "column",
		radar: "spiderweb"
	};

	return $style && (map[$style] || $style);
};

function _isCubeValid(cube, proto) {
	return !!(cube && cube.$hierarchies && proto.$axes && proto.$axes.length > 0 && //
		proto.$axes[0].$hierarchies && proto.$axes[0].$hierarchies.length > 0);
}
/**
 * cube chart control class
 *
 * article:
 * $isLegendHidden: true/false
 * $isXLabelHidden: true/false
 * $isYLabelHidden: true/false
 * $isXLabelsHidden: true/false
 * $isYLabelsHidden: true/false
 * $style: line, spline, area, areaspline, bar, stick, pie
 */
var _Klass = utils.defineClass(function(control, disp, options) {
	Base.call(this, control, disp, options);
	// #6974 Add this stuff there for compatibility with desktop code
	// This block assigns some variables so that the implementations
	// in ctrlCubeChartBase which have been migrated from the desktop client
	// do not need to be modified too much!
	this.$prototype = control.prototype.json;
	this.$prototype.$properties = this.$prototype.$item.$properties;
	this._localize = {
		highCharts_showHideLegend: locale.text("highCharts_showHideLegend"),
		highCharts_seriesTitle: locale.text("highCharts_seriesTitle")
	};
	this._initializeMeta();
}, Base, {
	destroy: function() {
		Base.prototype.destroy.call(this);
		this.clearChart();
		this._localize = this._meta = this._dataset = this.$prototype = this.currentMetaData = null;
	},
	//#6974 clear existing chart
	clearChart: function() {
		if (this.highchartObject) {
			this.highchartObject.destroy();
		}
		this.highchartObject = null;
	},
	_mergeMetaData: function(metadata) {
		var m = {};
		if (metadata && metadata.$chartOptions) {
			metadata.$isXLabelsHidden = metadata.$chartOptions.isXLabelsHidden || false;
			metadata.$isYLabelsHidden = metadata.$chartOptions.isYLabelsHidden || false;
			metadata.$isXLabelHidden = metadata.$chartOptions.isXLabelHidden || false;
			metadata.$isYLabelHidden = metadata.$chartOptions.isYLabelHidden || false;
			metadata.$isLegendHidden = metadata.$chartOptions.isLegendHidden || false;
			metadata.$isGridLineHidden = metadata.$chartOptions.isGridLineHidden || false;
			metadata.$isTitleHidden = metadata.$chartOptions.isTitleHidden || false;
			metadata.$isLabelsHidden = metadata.$chartOptions.isLabelsHidden || false; // Only for pie
		}
		if (metadata && metadata.$axisLabels) m.$axisLabels = metadata.$axisLabels;
		if (metadata && metadata.$cube) m.$cube = metadata.$cube;
		if (metadata && metadata.$axes) m.$axes = metadata.$axes;
		if (metadata && metadata.$style) m.$style = metadata.$style;
		if (metadata && metadata.$color) m.$color = metadata.$color;
		if (metadata && metadata.$isLegendHidden) m.$isLegendHidden = metadata.$isLegendHidden;
		if (metadata && metadata.$isXLabelHidden) m.$isXLabelHidden = metadata.$isXLabelHidden;
		if (metadata && metadata.$isYLabelHidden) m.$isYLabelHidden = metadata.$isYLabelHidden;
		if (metadata && metadata.$isXLabelsHidden) m.$isXLabelsHidden = metadata.$isXLabelsHidden;
		if (metadata && metadata.$isYLabelsHidden) m.$isYLabelsHidden = metadata.$isYLabelsHidden;
		if (metadata && metadata.$isGridLineHidden) m.$isGridLineHidden = metadata.$isGridLineHidden;
		if (metadata && metadata.$isTitleHidden) m.$isTitleHidden = metadata.$isTitleHidden;
		if (metadata && metadata.$isLabelsHidden) m.$isLabelsHidden = metadata.$isLabelsHidden;
		if (metadata && metadata.$inverted) m.$inverted = metadata.$inverted;
		if (metadata && metadata.$seriesOptions) {
			m.$cube = m.$cube || {};
			m.$cube.$measures = m.$cube.$measures || {};
			Object.keys(metadata.$seriesOptions).forEach(function(key) {
				if (metadata.$seriesOptions[key]) {
					m.$cube.$measures[key] = m.$cube.$measures[key] || {};
					if (metadata.$seriesOptions[key].color) {
						m.$cube.$measures[key].$color = metadata.$seriesOptions[key].color.bgColor;
					}
					m.$cube.$measures[key].$isHidden = metadata.$seriesOptions[key].isHidden;
				}
			});
		}
		this.currentMetaData = _merge(this.currentMetaData || {}, m);

		if (metadata && metadata.$item && metadata.$item.$properties && this.currentMetaData && this.currentMetaData.$cube && this.currentMetaData.$cube.$measures) {
			$.smForEachKey(this.currentMetaData.$cube.$measures, function(key, m) {
				if (metadata.$item.$properties[key] && metadata.$item.$properties[key].$title) {
					m.$title = metadata.$item.$properties[key].$title;
				} else {
					m.$title = key;
				}
			});
		}

		return this.currentMetaData;
	},
	getDataSet: function() {
		return this._dataset || [];
	},
	_ensureFormatter: function(measure) {
		measure.formatApi = {
			format: function(val, localFormat) {
				return val;
			}
		};
	},
	_localizedText: function(key) {
		return key;
	},
	_getFieldEvalTitle: function() {
		return [];
	},
	// Each time the dataset of array changes
	notifyArrayDataChanged: function(refresh, arrayData, isEmpty) {
		var self = this;
		Base.prototype.notifyArrayDataChanged.call(self, refresh, arrayData, isEmpty);
		var chartDataset = [];
		if (arrayData && arrayData.$resources) {
			arrayData.$resources.forEach(function(dao) {
				chartDataset.push(dao.data);
			});
		}
		self._dataset = chartDataset;
		self._links = null;
		if (arrayData && arrayData.$links) {
			self._links = {};
			Object.keys(arrayData.$links).forEach(function(key) {
				if (!arrayData.$links[key].$isHidden) self._links[key] = arrayData.$links[key];
			});
		}
	},
	_settingsFromValue: function() {
		var self = this,
			$cube = this.currentMetaData.$cube,
			icolor = 0,
			settings;

		var dataset = self.getDataSet();
		if ($cube && $cube.$style === "spiderweb") {
			settings = {};
			settings.categories = Object.keys(self._meta.series).map(function(key) {
				return self._meta.series[key].options.name;
			});

			settings.series = {};
			dataset && dataset.reduce(function(res, current) {
				var serie = {
					name: self._getMeasureLabel(current, self._meta.xAxis[0].code),
					color: colors[icolor++],
					data: [],
					pointPlacement: 'on'
				};
				if (serie.name) {
					serie.id = "#s-" + serie.name;
					$.smForEachKey(self._meta.series, function(key, s) {
						if (!s.isHidden) self._pushData(serie, key, key, current);
					});
					res.series[serie.name] = serie;
				}
				return res;
			}, settings);
		} else {
			settings = {
				categories: [],
				series: {}
			};
			dataset && dataset.reduce(function(res, current) {
				var categoryName = self._getMeasureLabel(current, self._meta.xAxis[0].code);
				if (categoryName != null) {
					res.categories.push(categoryName);
					$.smForEachKey(self._meta.series, function(key, s) {
						var serie = res.series[key];
						if (!serie) {
							serie = objectClone(s.options);
							serie.data = [];
							res.series[key] = serie;
						}
						self._pushData(serie, categoryName, key, current);
					});
				}
				return res;
			}, settings);
		}
		return settings;
	},

	_pushData: function(serie, categoryName, key, data) {
		var val = parseFloat(data.$rawV && data.$rawV[key] && data.$rawV[key].v || data[key]) || 0;
		if (this.useLogarithmicAxis) {
			this.maxValue = Math.max(this.maxValue || -Infinity, val);
			this.minValue = Math.min(this.maxValue || Infinity, val);
		}
		serie.data.push({
			name: categoryName,
			y: val,
			"rowId": data.$uuid
		});
	},
	//#6974 add options height/width.onComplete/zoomType
	createChart: function(settings, $$parent, options) {
		var self = this,
			options = _merge(self._getPref(), self._getOptions(self.$prototype, $$parent, options));
		if (self.highchartObject) {
			//#6974 clear existing chart
			self.clearChart();
		}
		if (settings) {
			options.xAxis[0].categories = settings.categories;
			$.smForEachKey(settings.series, function(key, s) {
				var serie = objectClone(s),
					serieMeta = self._meta.series[key];
				if (options.chart.polar && serie && serie.type) {
					delete serie.type;
				}
				if (!(serieMeta && serieMeta.isHidden) && !(serieMeta && serieMeta.options && serieMeta.options.isHidden)) {
					options.series.push(serie);
				}
			});
		} else {
			$.smForEachKey(self._meta.series, function(key, s) {
				var serie = objectClone(s.options);
				if (options.chart.polar && serie && serie.type) {
					delete serie.type;
				}
				serie.data = [0];
				if (!s.isHidden) {
					options.series.push(serie);
				}
			});
		}
		if (!(self.$prototype.$cube && self.$prototype.$cube.$style == "spiderweb")) {
			options.series.reverse();
		}
		if (this.useLogarithmicAxis) {
			if ((this.maxValue || 0) / (this.minValue || 1) > 10) {
				options.yAxis.type = 'logarithmic';
			}
		}
		self.highchartObject = new Highcharts.Chart(options);

		var legend = this.highchartObject.legend;
		self.displayLegend = legend && legend.display;

		var chartSeries = self.highchartObject.series,
			serie, serieMeta;
		for (var j = chartSeries.length - 1; j >= 0; j--) {
			serie = chartSeries[j];
			serieMeta = serie && serie.options.id && self._meta.series[serie.options.id.slice(3)];
			if (serieMeta && serieMeta.measure) {
				serieMeta.measure.$color = serieMeta.options.color = serie.color;
			}
		}
	},
	//#6974 add options height/width.onComplete/zoomType
	_getOptions: function(proto, $$parent, options) {
		options = options || {};
		var self = this;
		var $cube = this.currentMetaData.$cube;
		var defOptions = Highcharts.getOptions();
		var buttons = defOptions.exporting.buttons;
		var enuml;
		var $style = this.currentMetaData.$style || ($cube && $cube.$style) || (proto.$cube && proto.$cube.$style);
		var axe = proto.$axes && proto.$axes[0] || {};
		var titleCode = this._getMeasureCode(axe.$hierarchies[0][0]);
		var hierarchy = $cube.$hierarchies && $cube.$hierarchies[titleCode];
		var axeTitle = hierarchy ? hierarchy.$title : null;
		if (axeTitle === null && proto.$properties && proto.$properties[titleCode]) {
			axeTitle = proto.$properties[titleCode].$title || "";
		};
		var margin = {
			top: (this.currentMetaData.$isTitleHidden && $style !== "bar" ? 0 : null),
			bottom: (this.currentMetaData.$isXLabelsHidden && $style !== "bar" ? 0 : null),
			left: (this.currentMetaData.$isYLabelsHidden && $style !== "bar" ? 2 : null)
		};
		var legend = {};
		if (globals.getSiteLayout().getDeviceType() === "smartphone") {
			legend.layout = 'horizontal';
			legend.align = 'center';
			legend.verticalAlign = 'bottom';
			legend.floating = 'bottom';
			legend.notitle = true;
		};
		var options = {
			chart: {
				renderTo: $$parent.get(0),
				reflow: false,
				zoomType: options.zoomType || 'x',
				ignoreHiddenSeries: false,
				width: options.width,
				height: options.height,
				inverted: this.currentMetaData.$inverted,
				marginTop: margin.top,
				marginBottom: (!this.currentMetaData.$inverted ? margin.bottom : margin.left),
				marginLeft: (!this.currentMetaData.$inverted ? margin.left : margin.bottom),
				marginRight: (!this.currentMetaData.$inverted ? margin.left : margin.bottom),
				events: {
					load: options.onComplete,
				}
			},
			lang: {
				showHideLegend: self._localize.highCharts_showHideLegend
			},

			legend: {
				layout: legend.layout ? legend.layout : 'vertical',
				align: legend.align ? legend.align : 'right',
				verticalAlign: legend.verticalAlign ? legend.verticalAlign : 'top',
				y: legend.notitle ? 0 : 60,
				x: legend.notitle ? 0 : -10,
				title: {
					text: (legend.notitle ? '' : ':::: ' + self._localize.highCharts_seriesTitle)
				},
				borderWidth: legend.notitle ? 0 : 1,
				floating: legend.notitle ? false : true,
				draggable: legend.notitle ? false : true,
				zIndex: 20,
				enabled: !(this.currentMetaData.$isLegendHidden === true) && ($style !== "pie")
			},
			title: {
				text: (!this.currentMetaData.$isTitleHidden && $cube && self._localizedText($cube.$title)) || null
			},
			subtitle: {
				text: null
			},
			xAxis: [{
				categories: [],
				title: {
					text: (!this.currentMetaData.$isXLabelHidden && self._localizedText(axeTitle)) || null
				},
				labels: {
					rotation: -45,
					align: 'right',
					enabled: !(this.currentMetaData.$isXLabelsHidden === true)
				},
				gridLineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
				minorGridLineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
				lineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
				tickWidth: (this.currentMetaData.$isXLabelsHidden ? 0 : 1)
			}],

			yAxis: [{
				title: {
					text: null
				},
				labels: {
					align: 'right',
					enabled: !(this.currentMetaData.$isYLabelsHidden === true)
				},
				gridLineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
				minorGridLineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
				lineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
				tickWidth: (this.currentMetaData.$isYLabelsHidden ? 0 : 1)
			}],

			plotOptions: {
				series: {
					pointPadding: 0,
					groupPadding: 0.1,
					cursor: 'pointer',
					events: {},
					point: {
						events: {
							click: self.control ? self.control.getChartClickHandler() : null
						}
					},
					stacking: self._meta.stacking,
					animation: false
				}
			},

			tooltip: {
				formatter: function() {
					var seriesMeta = self._meta.series,
						serie = this.key && seriesMeta[this.key] || seriesMeta[this.series.options.id.slice(3)],
						measure = serie && serie.measure,
						data = this.series.processedYData,
						y = this.y;

					if (measure) {
						self._ensureFormatter(measure);
					}
					var label = this.series.name || measure && measure.$title,
						mformat = measure && measure.formatter;
					label = (label ? label + "<br>" : "") + (this.x || this.key) + ': <b> ' + (mformat ? mformat.format(y) : y) + '</b>';
					if (measure && (measure.$isNormalized) && data.length > 0) {
						var sum = data.reduce(function(a, b) {
							return a + b;
						});
						label += ' (' + (mformat ? mformat.formatValue(y / sum * 100) : y / sum * 100) + '%)';
					}

					return label;
				}
			},

			series: [],
		};
		if ($style === "pie") {
			options.plotOptions.pie = options.plotOptions.pie || {};
			options.plotOptions.pie.dataLabels = options.plotOptions.pie.datalabels || {};
			options.plotOptions.pie.dataLabels.enabled = (this.currentMetaData.$isLabelsHidden ? false : true);
		}
		if (Highcharts.theme.version[0] === 3) {
			// For Highcarts 3.0.0
			options.exporting = {
				type: 'image/png',
				url: 'http://export.highcharts.com/',
				buttons: {
					contextButton: { // docs
						//x: -10, // docs: x is different now
						symbol: 'menu',
						enabled: false,
						_titleKey: 'contextButtonTitle',
						menuItems: [{
							textKey: 'showHideLegend',
							onclick: function() {
								setTimeout(function() {
									self._toggleLegendDisplay();
								}, 100);
							}
						}]
					},
					legendButton: {
						enabled: false,
						textKey: 'showHideLegend',
						symbol: 'menu',
						onclick: function() {
							setTimeout(function() {
								self._toggleLegendDisplay();
							}, 100);
						}
					}
				}
			};
			var menuItems = options.exporting.buttons.contextButton.menuItems || [];
			if (this._printSupported()) {
				menuItems.push({
					text: 'Print chart',
					onclick: function() {
						this.print(self);
					}
				});
			}
			if (this._exportSupported()) {
				menuItems.push({
					separator: true
				});
				menuItems.push({
					textKey: 'downloadPNG',
					onclick: function() {
						this.exportChart();
					}
				});
				menuItems.push({
					textKey: 'downloadJPEG',
					onclick: function() {
						this.exportChart({
							type: 'image/jpeg'
						});
					}
				});
				menuItems.push({
					textKey: 'downloadPDF',
					onclick: function() {
						this.exportChart({
							type: 'application/pdf'
						});
					}
				});
				menuItems.push({
					textKey: 'downloadSVG',
					onclick: function() {
						this.exportChart({
							type: 'image/svg+xml'
						});
					}
				});
			}
		}

		if (options.xAxis[0].title.text !== options.title.text) {
			options.xAxis[0].title.text = (options.xAxis[0].title.text ? options.xAxis[0].title.text : options.title.text);
		}
		options.chart.type = self._meta.defaultStyle;

		return options;
	},

	_initializeMeta: function() {
		this._mergeMetaData(this.$prototype);
		this._mergeMetaData(this.$articleArray);

		var proto = this.$prototype;
		var cube = this.currentMetaData;

		this._meta = {
			xAxis: [{}],
			series: {},
			displaysOneMeasure: cube && cube.$displaysOneMeasure,
			hasMeasureSelector: cube && cube.$hasMeasureSelector,
			hasStyleSelector: cube && cube.$hasStyleSelector,
			defaultStyle: _style(cube.$style) || 'column',
			drill: {
				minLevel: 1,
				maxLevel: 0,
				currLevel: 1,
				currAxisHier: 0,
				levelsProperties: [],
				members: [],
				stack: [{
					$axes: proto.$axes,
					$item: proto.$item,
					$slicer: proto.$slicer
				}]
			}
		};
		this.__processMeta(proto, true);
	},

	_exportSupported: function() {
		return true;
	},

	_printSupported: function() {
		return true;
	},

	__processMeta: function(metaData, init) {
		this._processMeasures(metaData, init);
		this._processAxes(metaData, init);
	},

	_processMeasures: function(metaData, init) {
		this._mergeMetaData(metaData);

		var self = this,
			items = this.$prototype.$properties;

		// Get measures definition. If measures are not defined in the second axis members (Cf. specs),
		// we used all the measures defined in the cube
		var measures = this._getRestraintMeasures(),
			icolor = 0;
		if (measures) {
			$.smForEachKey(measures, function(key, m) {
				// Because duplicate properties is possible for cube definition... we keep the last defined
				var code = (m.$property || key);
				var measure = _merge(items[code], m);
				if (metaData && metaData.$item && metaData.$item.$properties) {
					measure = _merge(measure, metaData.$item.$properties[code]);
				}
				if (!measure.$title || measure.$title === "") {
					measure.$title = key;
				}
				// measures[key] = measure;
				var serie = self._meta.series[code];

				if (init) {
					self._ensureFormatter(measure);

					serie = self._meta.series[code] = {
						options: {
							id: '#s-' + code,
							// legendIndex: "",
							name: self._localizedText(measure.$title) || String.fromCharCode(160),
							// visible: measure.$title !== "" && !!(!self._meta.displaysOneMeasure || measure.$isDefault)
						},
						measure: measure
					};
				}
				if (serie) {
					serie.isHidden = measure.$title === "";
					serie.options.type = _style(measure.$style);
					serie.options.color = measure.$color || colors[icolor++];
					serie.options.name = self._localizedText(measure.$title) || String.fromCharCode(160);
					serie.options.visible = measure.$title !== "" && !! (!self._meta.displaysOneMeasure || measure.$isDefault);
					serie.options.isHidden = measure.$isHidden;
				}

				if (measure.$isStacked || measure.$stackingGroup) {
					serie.options.stack = measure.$stackingGroup || 0; // a stack ID
					self._meta.stacking = measure.$isNormalized ? 'percent' : self._meta.stacking || 'normal';
				}
			});
		}
	},

	_getRestraintMeasures: function() {
		var proto = this.currentMetaData,
			$cube = proto.$cube,
			measures = $cube && $cube.$measures,
			restraintMeasures = measures;
		if (measures) {
			if (proto.$axes && proto.$axes.length > 1 && proto.$axes[1].$members && proto.$axes[1].$members[0][0].length > 0) {
				restraintMeasures = {};
				$.smForEach(proto.$axes[1].$members[0][0], function(measureCode) {
					restraintMeasures[measureCode] = measures[measureCode];
				});
			}
		}
		return restraintMeasures;
	},

	_processAxes: function(proto, init) {
		var cube = this.$prototype.$cube;
		if (!_isCubeValid(cube, proto)) return false;

		var self = this,
			currAxisHier = 0,
			axis0 = proto.$axes && proto.$axes[0];

		// TODO: review this
		// Get axis analysis
		var mainHLevelsTab = null;
		if (axis0) {
			$.smForEachKey(axis0.$hierarchies, function(idx, hierarchy) {
				if (!mainHLevelsTab && hierarchy.length > 1 && hierarchy[1] == 1) {
					mainHLevelsTab = cube.$hierarchies[hierarchy[0]].$properties;
					if (mainHLevelsTab) {
						self._meta.xAxis[0].code = mainHLevelsTab[hierarchy.length > 2 ? hierarchy[2] : 0];
						currAxisHier = idx;
					}
				}
			});
			if (!mainHLevelsTab && axis0.$hierarchies[0].length > 0) {
				mainHLevelsTab = cube.$hierarchies[axis0.$hierarchies[0][0]].$properties;
				if (mainHLevelsTab && mainHLevelsTab.length > 0) self._meta.xAxis[0].code = mainHLevelsTab[0];
			}
			// Get drill definition
			var properties;
			$.smForEach(axis0.$hierarchies, function(hierarchie) {
				properties = cube.$hierarchies[hierarchie[0]].$properties;
				$.smForEach(properties, function(property) {
					this.levelsProperties[this.maxLevel++] = property;
				}, self._meta.drill);
			});
			if (axis0.$members) {
				$.smForEach(axis0.$members, function(tuple) {
					$.smForEach(tuple, function(value) {
						if (value.length > 0) {
							this.members[(this.currLevel++) - 1] = value[0];
						}
					}, this);
				}, self._meta.drill);
			}
		}
		self._meta.drill.code = proto.$codeStat || "UNKNOWN";
		self._meta.drill.axis0FieldCode = self._meta.xAxis[0].code || "";
		self._meta.drill.maxLevel = Math.max(self._meta.drill.maxLevel, self._meta.drill.minLevel);
	},

	_getPref: function() {
		return Highcharts.getOptions();
	},
	//get the measure code depending on level. May be not the best way to do that (see desktop release).
	_getMeasureCode: function(code) {
		var level = this.control.level;
		var measureCode = ((level > 1) && this.$prototype.$axes[0].$hierarchies.length >= level) ? this.$prototype.$axes[0].$hierarchies[level - 1][0] : null;
		//Authoring is yet stored by level but to keep existing authoring, we keep the key but always 1
		measureCode = (this.currentMetaData.$axisLabels) ? this.currentMetaData.$axisLabels[1] : measureCode;
		return measureCode || code;
	},
	_getMeasureLabel: function(measure, code) {
		var self = this;
		var label = this._localizedText(measure.$title);
		if (label) return label;
		code = this._getMeasureCode(code);
		if (!measure[code]) return "";
		var item = self.$prototype.$properties[code];
		if (!item) return null;
		switch (item.$type) {
			case "application/x-choice":
				label = measure[code];
				item.$value.$enum.some(function(element, i, array) {
					if (element.$value === label) {
						label = self._localizedText(element.$title);
						return true;
					}
					return false;
				});
				break;
			case "application/x-date":
				item.formatter = formatApi.getFormatter(item.$type, locale.getDateFormat(item.$type));
				label = item.formatter.formatValue(measure[code]);
				break;
			case "application/x-integer":
			case "application/x-decimal":
				item.formatter = formatApi.getFormatter(item.$type, locale.getNumberFormat(item.$type));
				label = item.formatter.formatValue(measure[code]);
				break;
			default:
				label = "" + measure[code];
				break;
		}
		return label;
	},
	_toggleLegendDisplay: function() {
		var legend = this.highchartObject.legend;
		legend && this._displayLegend(!legend.display);
	},
	_displayLegend: function(display) {
		var legend = this.highchartObject.legend;
		if (!legend) return;
		if (display) {
			legend.group.show();
			legend.box.show();
		} else {
			legend.group.hide();
			legend.box.hide();
		}
		this.displayLegend = legend.display = display;
	}
});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/array/builderChart',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/controls/array/builderChartBase','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var Base = require('syracuse-tablet/html/js/controls/array/builderChartBase').Klass;
var notifications = require('syracuse-tablet/html/js/helpers/notifications');


var _getHeight = function(h) {
	if (h === "xsmall") return 50;
	if (h === "small") return 100;
	if (h === "medium") return 200;
	if (h === "large") return 400;
	if (h === "xlarge") return 700;
	return 200;
};

/**
 * HIGHCHART BUILDER
 */
var _Klass = utils.defineClass(
	function(control, disp, options) {
		Base.call(this, control, disp, options);
	}, Base, {
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			this.resetProps(false);
		},
		destroy: function() {
			Base.prototype.destroy.call(this);
			this._$$chartSlot = this._$$catchEvt = null;
		},
		buildHtml: function(arrayData, buildOpts) {
			Base.prototype.buildHtml.call(this, arrayData, buildOpts);
			var article = this.$articleArray;
			// sometimes we need the height - see chartNeedsHeight
			this._height = _getHeight(article.$chartHeight);
			this._$$chartSlot = $('<div class="s-m-slot"/>').appendTo(this.control.$$value);
			if (this.getDataSet().length > 0) {
				//isAuthoringActive to allow the selection of the chart
				if (globals.isAuthoringActive() || this.control.isOpenDetailEnabled()) {
					// Catch chart events
					this._$$catchEvt = $('<div class="s-m-catchevt"/>').appendTo(this.control.$$value);
					if (this.control.isOpenDetailEnabled()) {
						this.control.addChartDetailLink(this._$$catchEvt);
					}
				}
			} else {
				var title = this.control.prototype.getDataByPath("$cube.$title");
				if (title) {
					$('<div class="s-m-no-data-title"/>').appendTo(this._$$chartSlot).text(title);
				}
				$('<div class="s-m-no-data-label"/>').appendTo(this._$$chartSlot).text(locale.text("label.chart.nodata"));
				this._$$chartSlot.css("position", "relative");
			}
			// Create the header - Pagination if any
			this.refreshHeaderAndGesture();
			if (this.isRefreshContext(buildOpts)) {
				// Force display because there's no resize (refresh - pagin)
				this._displayChart(false, true);
			}
		},
		onResize: function(context) {
			if (this.isDestroyed()) return;
			var dataset = this.getDataSet();
			if (dataset == null || dataset.length === 0) {
				// It needs to count all charts even empty ones
				this._notifyChartCounter();
				return;
			}
			if (!this.control.$$value || !this.control.$$value.is(':visible')) {
				if (!this._subscribedExpand) {
					this._subscribedExpand = true;
					notifications.subscribe(this, ["sm.layout.expanded"]);
				}
			}
			if (this._layouytType == null) {
				// Needed here to access to all elements (getParentVignette)
				// We do that just once
				if (this.control.isDisplayedInDetailPage()) {
					// in that case the chart is displayed in a 'detail's page
					this._layouytType = "stack";
				} else {
					// Chart in vignettes
					this._layouytType = this.control.controller.getParentDashboardType();
				}
			}
			this._displayChart(true, false);
		},
		_checkHeaderHeight: function(height) {
			if (this.control.$$header.is(":visible")) {
				var hh = this.control.$$header.height();
				var phh = this.control.parent.$$header ? this.control.parent.$$header.height() + 2 : 0; //+2 to display bottom border (???)
				if (height == null) {
					var css = {
						top: hh + "px",
						height: (this.control.$$value.height() - hh - phh) + "px"
					};
					this._$$chartSlot.css(css);
					if (this._$$catchEvt) {
						this._$$catchEvt.css(css);
					}
				} else {
					height = height - hh - phh;
				}
			}
			return height;
		},
		_displayChart: function(updtScroller, isRefresh) {
			var self = this;
			if (self.isDestroyed() || !self._$$chartSlot) return;
			// SetTimeout to improve UX when there are multiple charts to display (dashboard)
			setTimeout(function() {
				if (self.isDestroyed()) return;
				var stackController, height;
				if (self._layouytType === "stack") {
					// relative is needed - set each time because aof refresh
					self._$$chartSlot.css("position", "relative");
					// in stack mode we need a height
					if (self.control.isDisplayedInDetailPage()) {
						stackController = self.control.controller;
						// Height set to device height
						height = stackController.getMainContentRect().height - 10;
					} else if (self.control.controller.isVignette) {
						stackController = self.control.controller.getParentVignette().controller;
						// Height always less or equal than the device height
						height = Math.min(self._height, stackController.getMainContentRect().height - 10);
					} else {
						throw new Error("Unexpected chart page context");
					}
				} else {
					// Parent's height
					height = null;
				}
				height = self._checkHeaderHeight(height);
				self.createChart(self._settingsFromValue(), self._$$chartSlot, {
					height: height,
					// Parent's width
					width: null,
					onComplete: function() {
						if (!isRefresh) {
							//#6974 Fix svg issue in chrome
							self._notifyChartCounter();
						}
					}
				});
				if (updtScroller && stackController) {
					// Needed to update the scroller
					notifications.notifyController("sm.scroller.update", stackController);
				}
			}, 10);
		},
		/**
		 * Parent control notifies the builder that it's going to clear the content
		 */
		notifClearContent: function(refresh) {
			this.clearChart();
		},
		notifLayoutExpanded: function() {
			this._displayChart(false, false);
		},
		/**
		 * #6974 When all the charts are loaded we force the browser to redraw (svg bug in chrome)
		 * We need to count the charts
		 */
		_notifyChartCounter: function() {
			if (globals.getCurrentPage().countChartLoaded) {
				globals.getCurrentPage().countChartLoaded(this);
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/array/ctrlArrayChart',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/controls/array/ctrlArray','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/controls/array/builderChart','syracuse-tablet/html/js/helpers/userPrefs','syracuse-tablet/html/js/controls/chart/chartsUtils','syracuse-tablet/html/js/application/eventListener','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {"use strict";


var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var array = require('syracuse-tablet/html/js/controls/array/ctrlArray');
var Base = array.Klass;
var locale = require('syracuse-tablet/html/js/helpers/locale');
var BuiderCart = require('syracuse-tablet/html/js/controls/array/builderChart').Klass;
var userPreferences = require('syracuse-tablet/html/js/helpers/userPrefs');
var chartsUtils = require('syracuse-tablet/html/js/controls/chart/chartsUtils');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

/**
 * Make sure that we've the $forceArray property
 * For compliance with existing authoring - #7719
 */
var _checkChartArticle = function(article, $bind) {
	if (!article) return;
	var arrayArticle = _traverseArticleNodes(article, function(node) {
		return node.$bind === $bind && node.$forceArray === true;
	});
	// Ok because we expect a $forceArray in arrayArticle
	if (arrayArticle) {
		return article;
	}
	// No $forceArray has been found and we need it
	arrayArticle = _traverseArticleNodes(article, function(node) {
		if (node.$bind != $bind || node.$display == "chart" || node.$seriesOptions != null) {
			return false;
		}
		if (node.$display != null) {
			// Its an array
			return true;
		}
		// Unexpected null $display -  #7719 - We should find a way to detect the array
		if (node.$table || node.$card != null || node.$separator !== null) {
			// It's an array
			return true;
		}
		if (node.arrayOptions && node.rowIndex) {
			// It's an array
			return true;
		}
		return false;
	});
	if (arrayArticle) {
		// Set mandatory $forceArray
		arrayArticle.$forceArray = true;
	}
	return article;
};
/**
 * Retrieve chart and array article in chart Detail page article
 */
var _findChartArticle = function(article, $bind) {
	var self = this;
	var chartNode = _traverseArticleNodes(article, function(node) {
		// We got the chart not if forceArray is not set or is false
		if (node.$bind === $bind && node.$forceArray !== true) {
			return true;
		}
	});
	return chartNode;
};
var _findArrayArticle = function(article, $bind) {
	var arrayNode = _traverseArticleNodes(article, function(node) {
		if (node.$bind === $bind && node.$forceArray === true) {
			return true;
		}
	});
	return arrayNode;
};
var _traverseArticleNodes = function(node, matcher) {
	if (matcher(node) === true) {
		return node;
	}
	if (node.$items && node.$items.length > 0) {
		var i;
		var match;
		for (i = 0; i < node.$items.length; i++) {
			match = _traverseArticleNodes(node.$items[i], matcher);
			if (match) {
				return match;
			}
		}
	}
	return null;
};
/**
 * Array tied to a chart
 * Can be displayed as a grid/card/chart (article.$display = "chart" or "card" or "table")
 */
var _Klass = utils.defineClass(
	function CtrlArrayChart(controller, article, prototype, options) {
		options = options || {};
		options.localPagination = prototype.isCube();
		article.$arrayOptions = article.$arrayOptions || {};
		// Disabled for statistics and requests
		article.$arrayOptions.showSortFilter = false;
		article.$arrayOptions.showSearch = false;
		if (!article.$display) {
			article.$display = "chart";
		}
		this.level = controller.state.level == null ? 0 : controller.state.level;
		Base.call(this, controller, article, prototype, options);

	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this._paginSynchro = null;
		},
		isArrayChart: function() {
			return true;
		},
		buildHtml: function($$parent, controllerDao, buildOptions) {
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions);
			if (this.isHighChart()) {
				this.$$elmt.addClass("s-m-chart");
			} else {
				if (this.isOpenDetailEnabled()) {
					// action on $$value not on $$elmt ( pagination)
					this.addChartDetailLink(this.$$value);
				}
				this.$$elmt.addClass("s-m-chart-array");
			}
		},
		/**
		 * Called also by builderChart
		 */
		isOpenDetailEnabled: function() {
			if (this.isChartDetailPage()) return false;
			// We can't manage click to chart detail and click to next slide - TODO
			if (this.isCarouselDisplay()) return false;
			if (this.controller.isVignette) return this.article.$openDetail !== false;
			return true;
		},
		/**
		 * Called also by builderChart
		 */
		addChartDetailLink: function($$elmt) {
			$$elmt.attr("data-control-id", this.id).attr("data-action", globals.ACTCHARTDETAIL);
		},
		isDisplayedInDetailPage: function() {
			return this.isChartDetailPage() || !this.controller.isVignette;
		},
		isChartDetailPage: function() {
			return this.controller.state.type === "chartdetail";
		},
		isHighChart: function() {
			return this.$display === "chart";
		},
		_newBuilder: function(options) {
			if (this.isHighChart()) {
				if (this.$$value) {
					this.$$value.empty();
				}
				// Display as chart
				this.builder = new BuiderCart(this, this.$display, options);
			} else {
				// Display as table or card
				Base.prototype._newBuilder.call(this, options);
			}
		},
		//drillDown on select line in grid
		_actRowSelect: function(rowId, $$target) {
			var opt = this.drillDownOpt(rowId);
			opt.action = "$drillDown";
			this.triggerOpenChartDetail(opt);

		},
		drillDownOpt: function(rowId) {
			var self = this;
			var opt = {
				rowId: rowId,
				controlOriginId: (self.controller.state.options.controlOriginId || self.id), //Propagate control id
				forceDetailTitle: self._getCurrentMeasureLabel(rowId),
			};
			if (self._dataProperties) { //get options from data
				Object.keys(self._dataProperties).forEach(function(propertyName) {
					opt[propertyName] = self._dataProperties[propertyName];
				});
			}
			return opt;
		},
		//To provide the label of the measure selected by user to display in the breadcrumb (like a page title)
		_getCurrentMeasureLabel: function(rowId) {
			var hierarchieIndex = this.level === 0 ? 0 : this.level - 1;
			if (hierarchieIndex < 0) return;
			var code = this.prototype.getDataByPath("$axes.0.$hierarchies." + hierarchieIndex + ".0");
			if (!code) return;
			var dataRow = this.getRowById(rowId, this._arrayData);
			if (!dataRow || !dataRow.row) return;
			var $item = this.prototype.getPrototype("$item");
			var item = $item ? $item.property(code) : null;
			if (!item) return "";
			var label = dataRow.row.getValue(code);
			if (item.$type === "application/x-choice") {
				item.$value.$enum.some(function(element, i, array) {
					if (element.$value === label) {
						label = element.$title;
						return true;
					}
					return false;
				});
			}
			return label;
		},
		_actChartDetail: function() {
			if (this.isEmpty) return;
			this.triggerOpenChartDetail();
		},
		_setDataProperties: function(data) {
			var self = this;
			if (data) {
				var properties = ["ifCube", "level_c", "level_m", "level_p", , "recordsPerPage", "refreshLink", "req_id", "displayLineNum"];
				self._dataProperties = {};
				properties.forEach(function(propertyName) {
					if (data[propertyName] !== undefined) {
						self._dataProperties[propertyName] = data[propertyName];
					}
				});
			}
		},
		_setArrayData: function(controllerDao, refresh) {
			var res = Base.prototype._setArrayData.call(this, controllerDao, refresh);
			if (this.$$ttl) {
				this.$$ttl.removeClass("s-m-no-data-title");
			};
			this._setDataProperties(controllerDao.data);
			return res;
		},
		getTitle: function() {
			return this.isHighChart() ? Base.prototype.getTitle.call(this) : this._findTitle();
		},
		/** 
		 * Traverses the prototype hierarchy to find a title for the array that can be
		 * accessed later if there is no data
		 */
		_findTitle: function(proto) {
			proto = proto || this.prototype;
			var $title = proto.data("$title");
			if ($title) {
				return $title;
			}
			var $cube = proto.data("$cube");
			$title = $cube && $cube.$title;
			if ($title) {
				return $title;
			}

			if (proto.parent) {
				return this._findTitle(proto.parent);
			}
			return "";
		},
		_displayTitle: function(title) {
			if (title == null || title.trim().length === 0 || this.getAuthoring("$isTitleHidden") === true) {
				return false;
			}
			// Display the title if empty
			return true;
		},
		/**
		 *  Same look and size as chart for table mode
		 */
		setEmptyArrayMsg: function() {
			if (!this.isArrayField()) {
				if (this.$$ttl) {
					// !! remove it on refresh
					this.$$ttl.addClass("s-m-no-data-title");
				}
				// Set in $$value to be removed on refresh
				$('<div class="s-m-no-data-label"/>').appendTo(this.$$value).text(locale.text("label.chart.nodata"));

			}
		},
		/**
		 * Local pagination for stats
		 */
		createLocalPaginator: function(controllerDao) {
			if (!this.prototype.isCube()) return null;
			var gadget = this.controller.state.type == "chartdetail" ? this.controller.parentPage.gadget : this.controller.gadget;
			if (!gadget) return null;
			var rsrcs = controllerDao.getValue(this.$bind);
			if (!rsrcs) return null;
			var count = gadget.parameters && gadget.parameters.count != null ? gadget.parameters.count : 10;
			if (rsrcs.length <= count) return null;
			return new array.LocalPaginator(this, {
				count: count,
				length: rsrcs.length
			});
		},
		/**
		 * Returns the id for user preferences to store chart details
		 */
		_getChartDetailUserPrefsId: function() {
			var id = [];
			var controller = this._getMainController(this.controller);
			if (controller.isVignette && controller.getParentVignette()) {
				var vignette = controller.getParentVignette();
				var prototype = vignette.prototype;
				// Dashboard name - 1th key
				var uuid = vignette.controller.state.dashboardName || vignette.controller.state.name;
				if (uuid) {
					id.push(uuid);
				}
				// Vignette id - 2d key
				uuid = prototype.data("$uuid");
				if (uuid) {
					id.push('-');
					id.push(uuid);
				};
				var level = this.level + 1;
				if (level > 1) {
					id.push('-');
					id.push(level);
				}
			}
			if (id.length === 0) {
				// In case it's not a vignette - unexpected
				id.push(this.$bind);
				id.push('-');
				id.push(controller.getOriginalSdataUrl());
			}
			return id.join('');
		},
		/**
		 * Opens chart detail page
		 * Called also from authoring
		 */
		triggerOpenChartDetail: function(opt) {
			this.forceDetailTitle = (opt && opt.forceDetailTitle) ? opt.forceDetailTitle : null // title also for breadcrumb;
			if (!this.$$elmt) return;
			var attrs = {
				"data-control-id": this.id,
				"data-origin-id": (opt && opt.controlOriginId) ? opt.controlOriginId : this.id, //id control initial
				"data-parent-id": this.controller.id,
				"data-nav": "chartdetail",
				"data-nav-target": "application",
				"data-sdata-url": this._getSdataUrl(opt),
				"data-params": this._getChartDetailUserPrefsId()
			};
			eventListener.triggerNavigation(this.$$elmt, attrs);
		},
		_getMainController: function(controller) {
			if (controller.parentPage) {
				return this._getMainController(controller.parentPage);
			} else {
				return controller;
			}
		},
		/**
		 * Save chart detail article in control's article
		 */
		setChartDetailAuthoring: function(article, level) {
			level = level == null ? 0 : level;
			this.article[chartsUtils.getChartDetailArticlePropertyName(level)] = article;
			notifications.publish("sm.auth.change.item.prop.ui");
		},
		/**
		 * Return the page info proto/article for the chart detail page
		 */
		childPageGetPageInfo: function(typePage) {
			if (typePage === "chartdetail") {
				return this._getChartDetailPageInfo(typePage);
			} else {
				// Row detail/card detail
				return Base.prototype.childPageGetPageInfo.call(this, typePage);
			}
		},
		_getChartDetailPageInfo: function(typePage) {
			var userPrefs = userPreferences.createUserPrefs("toolbar", this._getChartDetailUserPrefsId());
			if (globals.isAuthoringActive()) {
				// Clear prefs when we open chartDetail in authoring to design from regular layout (side2Side)
				userPrefs.reset();
			}
			var level = this.level + 1;
			//sublevel authored article are stored in the main control article ($chartDetail_2 sibling $chartDetail_2... sibling $chartDetail
			// so "hack" to get the good article when level >1)
			var article = (level > 1) ? this._getMainController(this.controller).getControl(this.controller.state.options.controlOriginId).article : this.article;
			article = _checkChartArticle(article[chartsUtils.getChartDetailArticlePropertyName(level)], this.$bind);
			var chartArticle = article && _findChartArticle(article, this.$bind);
			var arrayArticle = article && _findArrayArticle(article, this.$bind);

			var opt = {
				display: article ? article.$display : null
			};
			// We need the prefs to define the right layout and the preferences of chart
			opt = $.extend(true, opt, (userPrefs.getPrefs() || {}));
			var pageInfo = {
				home: false,
				type: typePage,
				cached: false,
				refreshed: false,
				subtype: "details",
				article: chartsUtils.getChartDetailArticle(opt, this.$bind, chartArticle, arrayArticle),
				level: level
			};
			var parentVignette = this.controller.getParentVignette();
			var protoJson = $.extend(true, {}, this.controller.prototype.json);
			if (parentVignette) {
				// The name of a chart detail page is the name of the dashboard 
				// it is opened from plus the id of the vignetted container to get a unique name of the page
				// Be careful, a page name must be <name> . <facet> , no more that exactly one dot in the name
				// this is why dashboard name and vignette are concatenated with an underscore
				pageInfo.name = parentVignette.controller.prototype.getDataByPath("$dashboardName");
				pageInfo.name += "_" + parentVignette.$bind + ".$" + typePage;
				protoJson.$title = this.prototype.getDataByPath("$cube.$title") || locale.text("chartdetail.page.name");
			} else {
				pageInfo.name = this.controller.state.name;
				protoJson.$title = this.forceDetailTitle || (locale.text("chartdetail.page.level") + " " + pageInfo.level);
			}
			pageInfo.prototype = this.prototype.create(protoJson, true);
			return pageInfo;
		},
		/**
		 * Called by chart authoring to know if we should display height property
		 * Mandatory for charts in a row/cell layout because we need to fix the height of the chart
		 * For hub the height is given by the tile
		 */
		chartNeedsHeight: function() {
			return this.$display === "chart" && this._layouytType === "stack" && !this.isDisplayedInDetailPage();
		},
		_actPagination: function(linkName) {
			Base.prototype._actPagination.call(this, linkName);
			if (this._paginSynchro) {
				this._paginSynchro.forEach(function(ctrl) {
					setTimeout(function() {
						ctrl._actPagination(linkName);
					});
				});
			}
		},
		/**
		 * Used by chartDetail - Synchronization of pagination between chart and array
		 * Allow the array to trigger pagination to chart - when we paginate on array the chart is synchronized
		 * Only for local pagination
		 */
		paginAddSynchro: function(ctrl) {
			if (!ctrl || !ctrl.paginAddSynchro) return;
			if (!this._paginSynchro) {
				this._paginSynchro = [];
			}
			if (this._paginSynchro.indexOf(ctrl) >= 0) return;
			this._paginSynchro.push(ctrl);
		},
		/**
		 * Used by chartDetail - Synchronization of pagination between chart and array
		 * Only for local pagination
		 */
		paginGetInfo: function() {
			if (!this._localPaginator) return null;
			return {
				local: true,
				currentIdx: this._localPaginator.currentIdx
			};
		},
		/**
		 * Used by chartDetail - Synchronization of pagination between chart and array
		 * Only for local pagination
		 */
		paginSetInfo: function(paginInfo) {
			if (!paginInfo || !paginInfo.local || !this._localPaginator) return null;
			this._localPaginator.currentIdx = paginInfo.currentIdx;
			this.refresh(this.controller.dao);
		},
		isAuthoringPropAllowed: function(property, value) {
			if (property !== "arrayDisplay") {
				return Base.prototype.isAuthoringPropAllowed.call(this, property, value);
			}
			if (value === "separator") {
				return false;
			}
			if (!this.isChartDetailPage()) {
				// All properties included chart
				return true;
			}
			// Chart only for chart (left control) - Table/Card for array (right control)
			return this.article.$forceArray === true ? value !== "chart" : value === "chart";
		},
		hasSublevel: function() {
			if (this._arrayData.$links == null || this._arrayData.$links.$drillDown == null) return false;
			return this._arrayData.$links.$drillDown.$isHidden !== true;
		},
		acceptRowSelection: function() {
			// No $detail link on arrayChart - only drill up/down
			return this.hasSublevel() && !this.controller.isVignette;
		},
		/**
		 * Returns the handler attached to the click event in the chart
		 */
		getChartClickHandler: function(rowId) {
			if (!this.acceptRowSelection()) return null;
			var self = this;
			return function() {
				// this points to the clicked data of the chart
				self._actRowSelect(this.rowId, null);
				return true;
			};
		},
		//Used when authoring to go to sublevel. the goal is to select the first record.
		rowIdx2Id: function(idx) {
			if (!this._arrayData || !this._arrayData.$resources) return -1;
			var rowId = -1;
			rowId = this._arrayData.$resources[idx].getValue("$uuid");
			return rowId;
		},
		_getSdataUrl: function(opt) {
			if (!opt || !opt.action) return this._getMainController(this.controller).getOriginalSdataUrl();
			var row = this.getRowById(opt.rowId, this._arrayData);
			Object.keys(row.row.data).forEach(function(key) {
				opt[key] = row.row.data[key];
			});
			return this.prototype.resolveExpression(this._arrayData.$links[opt.action].$url, opt, true);
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/field/ctrlReference',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/sdata/sdataUtils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/application/eventListener','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var globals = require('syracuse-tablet/html/js/helpers/globals');

/**
 *
 */

var _Klass = utils.defineClass(

	function CtrlReference(controller, article, prototype, options) {
		options = options || {};
		// See ctrlQuantity - Control that displays the unit
		this.isUnit = options.isUnit === true;
		options.nativeCapabilities = {
			"scanBarcode": !this.isUnit
		};
		Base.call(this, controller, article, prototype, options);
		if (this.isUnit) {
			this.$isEditMode = false;
			this.cssType = "s-m-unit";
		} else {
			this.cssType = "s-m-ref";
		}
		this._isNumeric = false;
	}, Base, {
		initFormatter: function() {
			var type = this.prototype.getFieldTypeForValue(this.$bind);
			if (type == null || type.length === 0) return null;
			return Base.prototype.initFormatter.call(this, type, null);
		},
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			this.picker = null;
		},
		getValue: function(prop) {
			var val = this.getObjectValue()[prop || "$value"];
			return val == null ? "" : val;
		},
		/**
		 * return {$value, $title, $descr}
		 */
		getObjectValue: function() {
			var val = Base.prototype.getValue.call(this);
			if (val === null || typeof val !== "object") {
				// Unexpected
				val = {
					$value: val
				};
			}
			if (!val.$description) {
				val.$description = "";
			}
			if (!val.$title) {
				val.$title = "";
			}
			return val;
		},
		buildFieldTitle: function(fieldSlot, buildOptions) {
			if (this.isUnit) return;
			Base.prototype.buildFieldTitle.call(this, fieldSlot, buildOptions);
		},
		buildFieldValue: function(fieldSlot, buildOptions) {
			var self = this;
			var parentElmt = Base.prototype.buildFieldValue.call(self, fieldSlot);
			if (self.formatter && self.formatter.$type === "application/x-integer") {
				$(parentElmt).addClass("s-m-numeric");
			}
			if (self.$isEditMode) {
				self.buildEditValue(parentElmt, self.getValue());
			} else {
				var val = self.getObjectValue();
				if (self.isUnit) {
					self.buildUnitValue(parentElmt, val.$value, val.$description, val.$title);
				} else {
					self.buildDetailValue(parentElmt, self.getFormattedValue(val.$value), val.$description, val.$title, buildOptions);
				}
			}
		},
		buildEditValue: function(parentElmt, value) {
			var $lookuplink = this.getMetaData("$isReadOnly") !== true && this.getMetaData("$isDisabled") !== true ? this.prototype.getDataByPath("$item.$links.$lookup") : null;
			if ($lookuplink) {
				this.addPicker("lookup", fontUtils.getIconByName("lookupPicker"));
			}
			this.createMainInput(parentElmt, this.getFormattedValue(value));
		},
		// value: string expected
		buildDetailValue: function(parentElmt, value, descr, title, buildOptions) {
			var self = this;
			// build container - Disable link to lookup entity in tables
			var container = buildOptions && buildOptions.displayCtx === "table" ? parentElmt : self.addDetailLink(parentElmt);

			// build container of reference value if any
			if (value.length > 0) {
				// set description content according to authoring value of $refDescFormat
				// Available values are desc, title, desctitle, and titledesc. Default is "desc"
				var descContent;
				var $refDescFormat = self.getAuthoring("$refDescFormat");
				switch ($refDescFormat) {
					case "title":
						descContent = title;
						break;
					case "desctitle":
						descContent = self._combineTexts(descr, title);
						break;
					case "titledesc":
						descContent = self._combineTexts(title, descr);
						break;
						// "desc" will be considered as default
					default:
						descContent = descr;
						break;
				}

				// build content and set position according to description content authoring position $refDescPosition
				// available values are bottom, right, left, top, none. Default is "right"
				var $refDescPosition = self.getAuthoring("$refDescPosition");
				if ($refDescPosition == null || $refDescPosition.length === 0) {
					$refDescPosition = self.options.displayCtx === "table" ? globals.XREF_DESCRPOS_TABLE : "right";
				}
				var $$value = $("<div>").addClass("s-m-ref-val").text(value);
				var $$desc = $("<div>").addClass("s-m-descr").text(descContent);
				var arr;
				switch ($refDescPosition) {
					case "bottom":
						$(container).append($$value).append($$desc);
						break;
					case "left":
						$(container).append($$desc).append($$value);
						arr = [$$value, $$desc];
						$.each(arr, function(index, $$ee) {
							$$ee.css("display", "inline-block");
						});
						$$desc.css("padding-right", "5px");
						break;
					case "top":
						$(container).append($$desc).append($$value);
						break;
					case "none":
						$(container).append($$value);
						break;
					case "right": // "right" will be considered as default
					default:
						arr = [$$value, $$desc];
						$(container).append($$value).append($$desc);
						$.each(arr, function(index, $$ee) {
							$$ee.css("display", "inline-block");
						});
						$$desc.css("padding-left", "5px");
				}
			}
		},
		buildUnitValue: function(parentElmt, value, descr, title) {
			var self = this;
			var label = descr.length > 0 ? descr : title.length > 0 ? title : value;
			// TODO See how we display unit
			label = value || "";
			if (label && label.toLowerCase) label = label.toLowerCase().smCapitalize();
			uiUtils.createDomElement("span", ["s-m-descr"], label, null, self.addDetailLink(parentElmt));
		},
		addDetailLink: function(parentElmt) {
			var self = this;
			if (self.options.displayCtx === "card") return parentElmt;
			if (self.prototype.getDataByPath("$item.$links.$details")) {
				// get dom link parameters/attributes (we consider only $details)
				return uiUtils.createDomElement("span", null, null, self._getLinkAttrs("$details"), parentElmt);
			} else {
				return parentElmt;
			}
		},
		// lookupData - {data, proto} - data: selected JSON data - proto - prototype of row data
		setLookupValue: function(lookupData) {
			if (!lookupData) {
				console.log("setLookupValue Error - bind", this.$bind, "No lookupData");
				return;
			}
			if (!lookupData.data) {
				console.log("setLookupValue Error - bind", this.$bind, "No data");
				return;
			}
			var field = (this.prototype.getDataByPath("$item") || {}).$lookupValue;
			if (!field) {
				console.log("setLookupValue Error - bind", this.$bind, "No $lookupValue");
				return;
			}
			var proto = lookupData.proto;
			if (proto) {
				// proto allows to read $title, $description in lookupData.data if we want to diplay them
			}
			var value = lookupData.data[field];
			if (value == null) {
				value = "";
				console.log("setLookupValue Error - bind", this.$bind, "No field value", field);
			}
			this.setFieldValueFromSelector(value);
		},
		/**
		 * data: 		string with value
		 * 				object with {$value:,$description:,$title:}
		 */
		setDisplayValue: function(value) {
			var strData;
			if ($.isPlainObject(value)) {
				strData = value.$value || "";
			} else {
				strData = value || "";
			}
			Base.prototype.setDisplayValue.call(this, strData);
		},
		_getLinkAttrs: function(type) {
			return {
				"href": "#",
				"data-action": "ctrlRefLink",
				"data-params": type,
				"data-control-id": this.id
			};
		},
		_actLookupPicker: function(type) {
			this._actCtrlRefLink("$lookup");
		},
		/**
		 * Process the click here instead of generating the sdata Url in the link with data-nav attr (old version)
		 * We need to process $url with the current dao context
		 */
		_actCtrlRefLink: function(type) {
			var self = this;
			var $url;
			$url = (this.prototype.getDataByPath("$item.$links." + type) || {}).$url;
			if (type === "$lookup" && $url) {
				// Auto generated dynamic filter bases on compound key of item to lookup
				var $lookupWhere = this.prototype.getDataByPath("$item.$autoLookWhere");
				var whereElements;
				$lookupWhere && $.each($lookupWhere, function(property, valueProperty) {
					var fieldValue = self._dao && self._dao.getValue(valueProperty);
					if (fieldValue != null) {
						whereElements = whereElements || [];
						whereElements.push("(" + property + " eq '{" + valueProperty + "}')");
					}
				});

				var autoLookupWhere = whereElements && whereElements.join(" and ");
				if (autoLookupWhere) {
					if ($url.indexOf("?") < 0) {
						$url = $url + "?where=" + autoLookupWhere;
					} else {
						$url = $url + "&where=" + autoLookupWhere;
					}
				}
			}

			// Resolve parameters if any with the current dao - see $myLookupUrl
			// myLookupUrl must be resolve with the lats input data in edit facets 
			var link = $url ? sdataUtils.getLinkInfo($url, this.controller.dao) : null;
			if (!link) {
				return;
			}
			var attrs = {
				"data-nav": link.page,
				"data-sdata-url": link.sDataUrl
			};
			if (type === "$lookup") {
				attrs["data-parent-id"] = this.controller.id;
				attrs["data-control-id"] = this.id;
			}
			if (this.controller.isVignette) {
				// We alway open a lookup in full page
				// This old code set the target according to the context - attrs["data-nav-target"] = this.controller.openLinkInVignette() ? "vignette" : "application";
				attrs["data-nav-target"] = "application";
			}
			eventListener.triggerNavigation(this.$$elmt, attrs);
		},
		_combineTexts: function(el1, el2) {
			var res;
			// el1-el2 || el1 || el2
			res = (el1 && el2) ? (el1 === el2 ? el1 : el1 + "-" + el2) : (el1 || el2 || "");
			return res;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/layout/layoutStack',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/controls/layout/layoutBase','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/layout/layoutBase').Klass;
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

/**
 * cssOptions
 * 		cssLayout, cssCell: class added to default ones
 * default classes can  be overridden
 */
var _Klass = utils.defineClass(
	function LayoutStack(controller, type, article, opts) {
		var self = this;
		Base.call(self, controller, type, article, opts);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this.$$btnCollapse) {
				this.$$btnCollapse.off();
				this.$$btnCollapse = null;
			}
		},

		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions);

			self.$$elmt.addClass("s-m-stack");
			if (buildOptions && buildOptions.makeFullHeight === true) {
				self.$$elmt.height("100%");
			}
			var css = [];
			var level = $$parent.parents(".s-m-stack").length;
			if (level) {
				var $theme = (self.article && self.article.$theme) || String.fromCharCode(96 + Math.min(level, 3));
				css.push("s-m-theme-" + $theme);
			}
			this.isAdvanced = ($theme === "advanced");

			var $collapsible = (self.article && self.article.$collapsible) || "notcollapsible";
			var $title = (this.getArticleText("$title") || "").trim();
			if ($collapsible !== "notcollapsible") {
				css.push("s-m-collapsible");
			}
			if ($title.length) {
				css.push("s-m-title");
			}
			if (css.length) {
				self.$$elmt.addClass(css.join(" "));
			}
			if ($collapsible !== "notcollapsible" || $title.length > 0) {
				self._addHeader($collapsible, $title);
			}
			self.$$content = $("<content>");
			self._setStackColorClass();
			self.$$elmt.append(self.$$content);
			self.buildChildrenHtml(self.$$content, controllerDao, buildOptions);
			self._updateCollapseState();
		},
		_setStackColorClass: function() {
			var self = this;
			var color = self.article.$bgColor;
			if (color) {
				self.$$content.addClass("s-m-bg s-m-color-" + color);
			}
		},
		buildTitle: function($$rootLyt, $$parent, controllerDao, destroyAfter) {
			// When there is a $title attribute in the article,
			// layoutBase will create the title for all child classes
			// Since a stack layout generates a "special" title which allows collapsing, we override
			// the function here to not get two titles
		},

		_addHeader: function(state, title) {
			var self = this;
			self.$$header = $('<header>') //.text(title);
			if (state !== "notcollapsible") {
				/* We don't use data-action because collapse button must work in authoring mode - data-action click handler is overridden by select authoring handler */
				self.$$btnCollapse = $('<btn class="' + state + ' ' + fontUtils.layoutExpandCollapseIcon(state === "collapsed", this.isAdvanced) + '">').appendTo(self.$$header);
				self.$$header.on("click", jsutils.bindFn(this._actCollapse, this));
			}
			var $$title = $('<div class="s-m-title">');
			$$title.append(title);
			self.$$elmt.append(self.$$header);
			self.$$header.append($$title);
		},
		_actCollapse: function(events, setCollapse) {
			// Propagate to authoring for selection
			if (events && !globals.isAuthoringActive()) {
				events.stopPropagation();
			}
			if (!this.$$btnCollapse) return;
			if (setCollapse === true) {
				this.$$btnCollapse.removeClass("expanded " + fontUtils.layoutExpandCollapseIcon(setCollapse, this.isAdvanced)).addClass("collapsed " + fontUtils.layoutExpandCollapseIcon(!setCollapse, this.isAdvanced));
			} else if (setCollapse === false) {
				this.$$btnCollapse.removeClass("collapsed " + fontUtils.layoutExpandCollapseIcon(!setCollapse, this.isAdvanced)).addClass("expanded " + fontUtils.layoutExpandCollapseIcon(setCollapse, this.isAdvanced));
			} else {
				this.$$btnCollapse.toggleClass("collapsed " + fontUtils.layoutExpandCollapseIcon(setCollapse, this.isAdvanced)).toggleClass("expanded " + fontUtils.layoutExpandCollapseIcon(!setCollapse, this.isAdvanced));
			}
			this._updateCollapseState();
			if (!this.$$btnCollapse.hasClass("collapsed")) {
				/**
				 * We need to notify elements like array to refresh them - They are not displayed if !.is(":visible")
				 */
				notifications.publish("sm.layout.expanded");
			}
			/**
			 * We need to update the scroller because height has changed
			 */
			notifications.notifyController("sm.scroller.update", this.controller);
		},

		_updateCollapseState: function() {
			var self = this;
			if (!self.$$btnCollapse || !self.$$content) {
				return;
			}
			var collapse = self.$$btnCollapse.hasClass("expanded");
			self.$$content.toggle(collapse);
		},

		getAuthState: function(dirtyKeys) {
			var self = this;
			// If collapsed state has been changed, we do not store that state
			if (dirtyKeys.$collapsible) {
				return null;
			}
			return {
				collapsed: self.$$btnCollapse ? self.$$btnCollapse.hasClass("collapsed") : false
			};
		},

		setAuthState: function(state) {
			if (state && state.collapsed != null) {
				this._actCollapse(null, state.collapsed);
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/layout/layoutTab',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/layout/layoutBase','syracuse-tablet/html/js/ui/uiUtils'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/layout/layoutBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');

var _Klass = utils.defineClass(
	function LayoutTab(controller, type, article, opts) {
		var self = this;
		Base.call(self, controller, type, article, opts);
	}, Base, {
		/**
		 * Build Html recursively
		 */

		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions);
			self.$$elmt.addClass("s-m-tabs");
			var slot = uiUtils.createDomElement("div", [self.article.$layoutType]);
			$.each(self.children, function(index, layout) {
				layout.isTabSection = true;
				var item = uiUtils.createDomElement("div", ["s-m-layout-cell"], null, {
					"style": "display:" + (index != 0 ? "none" : "")
				}, slot);
				layout.buildHtml($(item), controllerDao, buildOptions);
			});
		},
		/**
		 * TODO - FDB - DOESNT WORK - Not attached to DOM
		 */
		buildTitle: function() {
			/*
			var self = this;
			var header = uiUtils.createDomElement('header', ["s-m-layout-header"]);
			var tabSlot = uiUtils.createDomElement("div", ["s-m-tabs-slot"]);
			var tabsContainer = uiUtils.createDomElement("ul", ["nav,nav-tabs"], null, {
				"role": "tablist"
			});
			$.each(self.children, function(index, layout) {
				var tabClass = index == 0 ? ["active"] : null;
				var tab = uiUtils.createDomElement("li", tabClass);
				var tabLink = uiUtils.createDomElement("a", ["s-m-tab"], layout.article.$title, {
					"href": "#"
				});
				tab.appendChild(tabLink);
				tabsContainer.appendChild(tab);
			});
			tabSlot.appendChild(tabsContainer);
			container.appendChild(header);
			*/
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/layout/layoutHub',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/layout/layoutBase','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/scroller/scrollerHelpers','syracuse-tablet/html/js/helpers/uiSettings'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/layout/layoutBase').Klass;
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');

/**
 * Top level layout node that must only contain layoutHubGroups as children
 * This "hub" expands horizontally and only uses the available vertical space
 * Use this to define pages which only scroll horizontally
 */
var _Klass = utils.defineClass(
	function LayoutHub(controller, type, article, opts) {
		var self = this;
		Base.call(self, controller, type, article, opts);
		this._gestureMgr = null;
		this._tilesGroupSpacing = uiSettings.getProp("hubLayout.groupSpacing");
		this._minLandscapeHeigth = uiSettings.getProp("hubLayout.landscapeMinHeigth");
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},

		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			buildOptions = buildOptions || {};
			Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions);
			self.$$elmt.addClass("s-m-hub");
			self.$$scrollElmt = $('<div class="s-m-scroll-elmt">').appendTo(self.$$elmt);
			self.buildChildrenHtml(self.$$scrollElmt, controllerDao, buildOptions);
			if (self._gestureMgr) {
				self._gestureMgr.destroy();
			}
			/**
			 * New $$scrollElmt -> New scroller
			 */
			self._gestureMgr = scroller.newScroller(self.$$scrollElmt, {
				isPageScroller: true
			});
		},
		/**
		 * Resize handler called by window.resize
		 */
		onResize: function(context) {
			var self = this;
			/**
			 * Returns the visible rectangle of main page content
			 *
			 */
			var parentRect = self.controller.getMainContentRect();
			var pos = self.$$elmt.position();

			var w = parentRect.width;
			var h = parentRect.height - pos.top; // - 10;

			var rel = w / h;
			var posX = 0;
			var posY = 0;
			var opts;
			/* Layout orientation */
			self.scrollDirection = (rel > 1.2 && h >= this._minLandscapeHeigth) ? "h" : "v";
			if (self.scrollDirection === "h") {
				self.$$elmt.css({
					width: "100%",
					height: h + "px"
				});
			} else {
				self.$$elmt.css({
					width: w + "px",
					height: "100%"
				});
			}
			if (self.children) {
				var last = self.children.length - 1;
				self.children.forEach(function(child, idx) {
					opts = {
						posX: posX,
						posY: posY,
						maxHeight: h,
						maxWidth: w,
						scrollDirection: self.scrollDirection,
						allowSmallTiles: rel > 1.2
					};
					child.onResize(context, opts);
					if (self.scrollDirection === "h") {
						posX += child.getWidth() + (idx < last ? self._tilesGroupSpacing : 0);
					} else {
						posY += child.getHeight() + (idx < last ? self._tilesGroupSpacing : 0);
					}
				});
			}
			var width, height;
			if (self.scrollDirection === "h") {
				width = posX;
				height = h;
			} else {
				width = w;
				height = posY;
			}
			var oldScroll = null;
			if (context && context.preserveScroll === true) {
				oldScroll = self._gestureMgr.getScroll();
			}
			// reset old scrolling to calculate width/height (mandatory in native mode)
			self._gestureMgr.reset();
			self.$$scrollElmt.width(width);
			self.$$scrollElmt.height(height);
			var scrollRect = uiRect.elmtRect(self.$$scrollElmt, "outer");
			var viewRect = parentRect.intersectRect(scrollRect);
			viewRect != null && !viewRect.contains(scrollRect) ? viewRect : null;
			if (!viewRect) return;
			self._gestureMgr.init(viewRect, self.scrollDirection, 0);
			if (oldScroll != null) {
				self._gestureMgr.autoScroll(oldScroll);
			}
		},
		/**
		 * layout hub gesture manager is the gesture manager of the dashboard
		 * in dashborad we don't scroll the whole page but just the content ofthe layout hub
		 * This method returns the _gestureMgr attached to the dashboard
		 */
		getGestureMgr: function() {
			return this._gestureMgr;
		},
		/**
		 * Context to store when dashboard is destroyed
		 * We save gesture manager context (scroll)
		 * type	back/link - Used to manage the content according to the type
		 */
		savedCtxCreate: function(type) {
			if (type === "link") {
				// Scroll is not saved when we send a link by email
				return null;
			}
			return this._gestureMgr ? {
				hubScroll: this._gestureMgr.savedCtxCreate()
			} : null;
		},
		/**
		 * Restore the context for the hublayout
		 */
		savedCtxRestore: function(ctx) {
			if (ctx != null && this._gestureMgr) {
				// Restore the scroll of hub layout
				this._gestureMgr.savedCtxRestore(ctx.hubScroll);
			}
		},
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/layout/layoutHubGroup',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/layout/layoutBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/uiSettings'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/layout/layoutBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');

var _validSizes = ["small", "medium", "wide", "large", "full", "all"];

/**
 * Layout node that can only be used inside layoutHub parent nodes
 * Renders a group of tiles using the available space from top to bottom and then wraps to the right
 * Child elements bound to this layout may set "$size" attribute to define their size:
 * - small		- four tiles will fit into one group from left to right
 * - medium		- two tiles fit into one group from left to right, also double height of "small"
 * - wide		- one tile fits into one group from left to right, same height as "medium"
 * - large		- same width as "wide" and double height of "wide"/"medium"
 * - full		- same width as "wide", uses one full column (rounded to tile size medium)
 */
var _Klass = utils.defineClass(
	function LayoutHubGroup(controller, type, article, opts) {
		var self = this;
		Base.call(self, controller, type, article, opts);
		self._settings = uiSettings.getProp("hubGroup");
	}, Base, {
		/**
		 * Build full html structed but do not yet apply position and size attributes (Will be done in a later step or on resize)
		 */
		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions);
			self.$$elmt.addClass("s-m-hub-group");

			self._buildCellStructure(controllerDao, buildOptions);
		},

		_buildCellStructure: function(controllerDao, buildOptions) {
			var self = this;
			self.cells = [];
			var cell = null;
			var notLinksCpt = 0;
			self.children && self.children.forEach(function(layout) {
				if (layout.isLinkVignette == null || layout.isLinkVignette() !== true) {
					notLinksCpt++;
				}
				var size = (layout.article && layout.article.$size) || "medium";
				if (_validSizes.indexOf(size) < 0) {
					size = _validSizes[1];
					layout.article = layout.article || {};
					layout.article.$size = size;
				}
				if (!cell) {
					cell = self._createCell(size);
					cell.domItem = uiUtils.createDomElement("div", null, null, null, self.$$elmt);
					self.cells.push(cell);
				}
				if (size === "small") {
					layout.buildHtml($(cell.domItem), controllerDao, buildOptions);
					cell.children.push(layout);
					if (cell.children.length === 4) {
						cell = null;
					}
				} else {
					if (cell.children.length > 0) {
						cell = self._createCell(size);
						cell.domItem = uiUtils.createDomElement("div", null, null, null, self.$$elmt);
						self.cells.push(cell);
					}
					layout.buildHtml($(cell.domItem), controllerDao, buildOptions);
					cell.children.push(layout);
					cell = null;
				}
			});
			// True if the group contains only links
			self._linksOnly = notLinksCpt === 0;
		},

		_createCell: function(size) {
			var self = this;
			size = (size === "small" ? "medium" : size);
			var cell = {
				size: size,
				children: []
			};
			return cell;
		},

		onResize: function(context, options) {
			this.calculateLayout(options);
			Base.prototype.onResize.call(this, context);
		},


		calculateLayout: function(options) {
			var self = this;
			var size;

			self._headerSpace = self.$$header ? self.$$header.height() : 0;
			self._width = 0;
			self._height = 0;

			self.hubGroupOptions = options;

			if (self.hubGroupOptions.scrollDirection === "h") {
				self._calculateLayoutHorizontal();
			} else {
				self._calculateLayoutVertical();
			}

			self.cells.forEach(function(cell) {
				size = cell.size;
				cell.domItem.style.left = cell.x + "px";
				cell.domItem.style.top = (cell.y + self._headerSpace) + "px";
				cell.domItem.style.width = self._sizes[size].width + "px";
				cell.domItem.style.height = self._sizes[size].height + "px";
				cell.domItem.style.position = "absolute";

				if (cell.x + self._sizes[size].width > self._width) {
					self._width = cell.x + self._sizes[size].width;
				}
				if (cell.y + self._sizes[size].height > self._height) {
					self._height = cell.y + self._sizes[size].height;
				}

				var x = 0;
				var y = 0;
				cell.children.forEach(function(tileLayout) {
					size = tileLayout.getAuthoringSize();
					tileLayout.calculateLayout(x, y, size, self._sizes[size]);
					if (x !== 0) {
						x = 0;
						y += self._sizes[size].height + self.hubGroupOptions.padY;
					} else {
						x += self._sizes[size].width + self.hubGroupOptions.padX;
					}
				});
			});

			var style = self.$$elmt.get(0).style;
			if (self.hubGroupOptions.scrollDirection === "h") {
				if (self.cells.length < 1 && globals.isAuthoringActive()) {
					self._width = self.hubGroupOptions.maxGroupWidth;
				}
				style.top = "0px";
				style.left = self.hubGroupOptions.posX + "px";
				style.width = 6 + self._width + "px";
				style.height = (self.hubGroupOptions.maxHeight - 6) + "px";
			} else {
				if (self.cells.length < 1 && globals.isAuthoringActive()) {
					self._height = self.hubGroupOptions.baseSize;
				}
				style.top = self.hubGroupOptions.posY + "px";
				style.left = "0px";
				self._width = self._width;
				style.width = self._width + "px";
				self._height += self._headerSpace + self._settings.portraitPadY;
				style.height = self._height + "px";
				if (self.cells.length < 1 && globals.isAuthoringActive()) {

				}
			}
		},

		/**
		 * Calc tile positions in horizontal scrolling model
		 */
		_calculateLayoutHorizontal: function() {
			var self = this;

			// Asume default base size
			self.hubGroupOptions.baseSize = self._settings.landscapeBaseSize;
			self.hubGroupOptions.padX = self._settings.landscapePadX;
			self.hubGroupOptions.padY = self._settings.landscapePadY;
			self.hubGroupOptions.maxGroupHeight = self.hubGroupOptions.maxHeight - self._headerSpace; //- 6;

			// How many tiles fit vertically?
			var maxTiles = self.hubGroupOptions.maxGroupHeight / (self.hubGroupOptions.baseSize + self.hubGroupOptions.padY);
			var remainPixels = self.hubGroupOptions.maxGroupHeight - Math.floor(maxTiles) * (self.hubGroupOptions.baseSize + self.hubGroupOptions.padY);
			var remainPerTile = Math.floor(remainPixels / maxTiles);
			var paddingPerTile = Math.floor(remainPixels / maxTiles / 2);
			self.hubGroupOptions.baseSize += remainPerTile;
			self.hubGroupOptions.paddingPerTile = paddingPerTile;

			self.hubGroupOptions.maxGroupWidth = 4 * self.hubGroupOptions.baseSize + 3 * self.hubGroupOptions.padX;

			self.hubGroupOptions.maxFullTileHeight = Math.floor((self.hubGroupOptions.maxGroupHeight + self.hubGroupOptions.padY) / (self.hubGroupOptions.baseSize + self.hubGroupOptions.padY) / 2) * (self.hubGroupOptions.baseSize + self.hubGroupOptions.padY) * 2 - self.hubGroupOptions.padY;
			self.hubGroupOptions.maxAllTileHeight = self.hubGroupOptions.maxFullTileHeight;
			self.hubGroupOptions.maxAllTileWidth = self.hubGroupOptions.maxWidth; //Math.floor((self.hubGroupOptions.maxWidth + self.hubGroupOptions.padX) / (self.hubGroupOptions.baseSize + self.hubGroupOptions.padX) / 2) * (self.hubGroupOptions.baseSize + self.hubGroupOptions.padX) * 2 - self.hubGroupOptions.padX;

			self._sizes = {
				small: {
					width: self.hubGroupOptions.baseSize,
					height: self.hubGroupOptions.baseSize,
					paddingX: self.hubGroupOptions.paddingPerTile,
					paddingY: self.hubGroupOptions.paddingPerTile
				},
				medium: {
					width: self.hubGroupOptions.baseSize * 2 + self.hubGroupOptions.padX,
					height: self.hubGroupOptions.baseSize * 2 + self.hubGroupOptions.padY,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 2,
					paddingY: self.hubGroupOptions.paddingPerTile, // * 2,
				},
				wide: {
					width: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padX * 3,
					height: self.hubGroupOptions.baseSize * 2 + self.hubGroupOptions.padY,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 4,
					paddingY: self.hubGroupOptions.paddingPerTile, // * 2,
				},
				large: {
					width: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padX * 3,
					height: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padY * 3,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 4,
					paddingY: self.hubGroupOptions.paddingPerTile, // * 4,
				},
				full: {
					width: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padX * 3,
					height: self.hubGroupOptions.maxFullTileHeight,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 4,
					paddingY: self.hubGroupOptions.paddingPerTile,
				},
				all: {
					height: self.hubGroupOptions.maxAllTileHeight,
					width: self.hubGroupOptions.maxAllTileWidth,
					paddingX: self.hubGroupOptions.paddingPerTile,
					paddingY: self.hubGroupOptions.paddingPerTile,
				}
			};

			var relX = 0;
			var relY = 0;
			var x = 0;
			var y = 0;

			self.cells.forEach(function(cell) {
				cell.w = self._sizes[cell.size].width;
				cell.h = self._sizes[cell.size].height;
				if ((y + cell.h > self.hubGroupOptions.maxGroupHeight) ||
					(y !== 0 && (cell.size === "full" || cell.size === "all"))) // full/all size cell always use one full column 
				{
					y = 0;
					relX += self.hubGroupOptions.maxGroupWidth + self.hubGroupOptions.padX;
					x = relX;
				}
				if (cell.size === "medium") {
					if ((x - relX) + cell.w > self.hubGroupOptions.maxGroupWidth) {
						x = relX;
						y += cell.h + self.hubGroupOptions.padY;
					}
					if (y + cell.h > self.hubGroupOptions.maxGroupHeight) {
						y = 0;
						relX += self.hubGroupOptions.maxGroupWidth + self.hubGroupOptions.padX;
						x = relX;
					}
					cell.x = x;
					cell.y = y;
					x += cell.w + self.hubGroupOptions.padX;
				} else {
					if (x !== relX) {
						x = relX;
						y += self._sizes.medium.height + self.hubGroupOptions.padY;
					}
					if (y + cell.h > self.hubGroupOptions.maxGroupHeight) {
						y = 0;
						relX += self.hubGroupOptions.maxGroupWidth + self.hubGroupOptions.padX;
						x = relX;
					}
					cell.x = x;
					cell.y = y;
					y += cell.h + self.hubGroupOptions.padY;

					if (cell.size === "all") {
						y = 0;
						relX += cell.w + self.hubGroupOptions.padX;
						x = relX;
					}
				}
			});
		},

		/**
		 * Calc tile positions in vertical scrolling model
		 */
		_calculateLayoutVertical: function() {
			var self = this;
			var centerPadX;
			self.hubGroupOptions.paddingPerTile = 0;
			self.hubGroupOptions.maxGroupHeight = self.hubGroupOptions.maxHeight - self._headerSpace;
			self.hubGroupOptions.padX = self._settings.portraitPadX;
			self.hubGroupOptions.padY = self._settings.portraitPadY;
			self.hubGroupOptions.maxFullTileHeight = self.hubGroupOptions.maxGroupHeight - self.hubGroupOptions.padY;
			var small = false;
			if (self.hubGroupOptions.maxWidth >= self._settings.portraitWideMinWidth ||
				(self.hubGroupOptions.allowSmallTiles === true && self._linksOnly === true)) {
				// #7898 allowSmallTiles & _linksOnly -> A group with only links - display smaller tiles - We have more freedom to show more tiles
				// Tablet default, display maximum of 8 tiles in a row in portrait mode
				self.hubGroupOptions.baseSize = Math.floor((self.hubGroupOptions.maxWidth - 7 * self.hubGroupOptions.padX) / 8);
				self.hubGroupOptions.maxGroupWidth = 8 * self.hubGroupOptions.baseSize + 7 * self.hubGroupOptions.padX;
			} else {
				// For smaller devices: display maximum of 4 tiles in a row in portrait mode
				self.hubGroupOptions.baseSize = Math.floor((self.hubGroupOptions.maxWidth - 3 * self.hubGroupOptions.padX) / 4);
				self.hubGroupOptions.maxGroupWidth = 4 * self.hubGroupOptions.baseSize + 3 * self.hubGroupOptions.padX;
			}
			self.hubGroupOptions.maxAllTileHeight = self.hubGroupOptions.maxFullTileHeight;
			self.hubGroupOptions.maxAllTileWidth = self.hubGroupOptions.maxWidth; //Math.floor((self.hubGroupOptions.maxWidth + self.hubGroupOptions.padX) / (self.hubGroupOptions.baseSize + self.hubGroupOptions.padX) / 2) * (self.hubGroupOptions.baseSize + self.hubGroupOptions.padX) * 2 - self.hubGroupOptions.padX;
			centerPadX = (self.hubGroupOptions.maxWidth - self.hubGroupOptions.maxGroupWidth) / 2;
			self.hubGroupOptions.maxGroupWidth += centerPadX;

			self._sizes = {
				small: {
					width: self.hubGroupOptions.baseSize,
					height: self.hubGroupOptions.baseSize,
					paddingX: self.hubGroupOptions.paddingPerTile,
					paddingY: self.hubGroupOptions.paddingPerTile,
				},
				medium: {
					width: self.hubGroupOptions.baseSize * 2 + self.hubGroupOptions.padX,
					height: self.hubGroupOptions.baseSize * 2 + self.hubGroupOptions.padY,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 2,
					paddingY: self.hubGroupOptions.paddingPerTile, // * 2
				},
				wide: {
					width: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padX * 3,
					height: self.hubGroupOptions.baseSize * 2 + self.hubGroupOptions.padY,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 4,
					paddingY: self.hubGroupOptions.paddingPerTile, // * 2
				},
				large: {
					width: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padX * 3,
					height: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padY * 3,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 4,
					paddingY: self.hubGroupOptions.paddingPerTile, // * 4
				},
				full: {
					width: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padX * 3,
					height: self.hubGroupOptions.maxFullTileHeight,
					paddingX: self.hubGroupOptions.paddingPerTile,
					paddingY: self.hubGroupOptions.paddingPerTile
				},
				all: {
					width: self.hubGroupOptions.maxAllTileWidth,
					height: self.hubGroupOptions.maxAllTileHeight,
					paddingX: self.hubGroupOptions.paddingPerTile,
					paddingY: self.hubGroupOptions.paddingPerTile
				}
			};

			var x = centerPadX;
			var y = 0;
			var yInc = 0;
			self.cells.forEach(function(cell) {
				cell.w = self._sizes[cell.size].width;
				cell.h = self._sizes[cell.size].height;

				cell.x = x;
				cell.y = y;

				if (x + cell.w > self.hubGroupOptions.maxGroupWidth) {
					x = centerPadX;
					y += yInc + self.hubGroupOptions.padY;
					cell.x = x;
					cell.y = y;
					yInc = cell.h;
					x += cell.w + self.hubGroupOptions.padX;
				} else {
					x += cell.w + self.hubGroupOptions.padX;
					yInc = cell.h > yInc ? cell.h : yInc;
				}
			});
		},

		getWidth: function() {
			return this._width;
		},
		getHeight: function() {
			return this._height;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/layout/layoutTile',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/controls/layout/layoutBase'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/layout/layoutBase').Klass;

var _Klass = utils.defineClass(function LayoutTile(controller, type, article, opts) {
	Base.call(this, controller, type, article, opts);
	// Set the default color - Forced to be modified by authoring	
	if (article.$bgColor == null) {
		article.$bgColor = globals.TILEDEFCOLOR;
	}
	article.$bgColor = article.$bgColor.toLowerCase();
}, Base, {

	initReuseProperties: function() {
		Base.prototype.initReuseProperties.call(this);
	},
	buildHtml: function($$parent, controllerDao, buildOptions) {
		var self = this;
		Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions);
		self.$$elmt.addClass("s-m-tile");
		self.$$body = self.$$elmt;
		self._setCellColorClass();
		self.buildChildrenHtml(self.$$body, controllerDao, buildOptions);
	},
	_setCellColorClass: function() {
		var bg = (this.article.$bgColor || "").toLowerCase();
		if (bg === "transparent" || bg.length === 0) {
			// No color if bg == "" or transparent color for compatibility
			return;
		}
		bg = "s-m-color-" + bg;
		this.$$elmt.addClass("s-m-bg " + bg);
	},
	/**
	 * Set attribute according to sizeInfo given by layoutHub
	 * Shit (padding top) if there's a title
	 */
	calculateLayout: function(x, y, authSize, sizeInfo) {
		var css = {
			left: x + "px",
			top: y + "px",
			width: sizeInfo.width + "px",
			height: sizeInfo.height + "px",
			position: "absolute",
			"padding-left": sizeInfo.paddingX + "px",
			"padding-right": sizeInfo.paddingX + "px",
			"padding-bottom": sizeInfo.paddingY + "px",
			"padding-top": ((this.$$header ? this.$$header.height() : 0) + sizeInfo.paddingY) + "px"
		};
		this.$$elmt.css(css);
		this.$$elmt.addClass(authSize);
	},
	getAuthoringSize: function() {
		return (this.article && this.article.$size) || "medium";
	},
	/**
	 * Called only for arrays nested in query/stats/requests
	 * Used to adapt the behavior according to the kind of hosted array
	 * typeArray: chart/carousel
	 * Chart:
	 * 	remove the default color for charts
	 * 	Hack: Done by programming since we don't manage default color by css
	 * 	Add s-m-chart to tune display fo these tiles by css
	 * Carousel:
	 * 	Remove fixed height - To improve
	 */
	notifSpecialArrayHosted: function(typeArray) {
		if (!this.$$elmt) return;
		// For authoring we can switch from carousel to chart to table...
		this.$$elmt.removeClass("s-m-carousel s-m-chart");
		if (typeArray === "carousel") {
			// set a class to remove padding by css to better fit
			this.$$elmt.addClass("s-m-carousel");
		} else if (typeArray === "chart") {
			// Remove Bg color and set a class to add border by css
			this.$$elmt.removeClass("s-m-bg s-m-color-" + this.article.$bgColor).addClass("s-m-chart");
		}
	},
	isLinkVignette: function() {
		var child = this.children ? this.children[0] : null;
		if (!child || child.$type !== "tablet/x-vignette") return false;
		return child.isLinkVignette();
	}
});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/layout/layoutCell',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/controls/layout/layoutBase','syracuse-tablet/html/js/ui/uiUtils'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/layout/layoutBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');

var _sizes = [{
	$prop: "$widthXs",
	$prefix: "col-xs-",
	$def: 12
}, {
	$prop: "$widthSm",
	$prefix: "col-sm-",
	$def: 6
}, {
	$prop: "$widthMd",
	$prefix: "col-md-",
	$def: 4
}, {
	$prop: "$widthLg",
	$prefix: "col-lg-",
	$def: 3
}];

var _Klass = utils.defineClass(function LayoutCell(controller, type, article, opts) {
	Base.call(this, controller, type, article, opts);
	// Set the default color - Forced to be modified by authoring
	if (article.$bgColor == null) {
		article.$bgColor = globals.CELLDEFCOLOR;
	}
	article.$bgColor = article.$bgColor.toLowerCase();
}, Base, {
	/**
	 * Init the properties to allow reuse of this control
	 */
	initReuseProperties: function() {
		Base.prototype.initReuseProperties.call(this);
		this.$$cell = null;
	},
	buildHtml: function($$parent, controllerDao, buildOptions) {
		Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions);
		this.$$elmt.addClass("s-m-cell");
		if (this.controller.isDashboard()) {
			// To identify in css cells of a dashboard from cell of a page
			this.$$elmt.addClass("dashboard");
		}
		this.$$cell = $(uiUtils.createDomElement("div", ["cell"], null, null, this.$$elmt));
		this._setCellColorClass();
		this._setCellSizeClasses();
		this.buildChildrenHtml(this.$$cell, controllerDao, buildOptions);
	},
	_setCellColorClass: function() {
		var bg = this.article.$bgColor;
		if (bg === "transparent" || bg.length === 0) {
			// No color if bg == "" or transparent color for compatibility
			return;
		}
		this.$$cell.addClass("s-m-bg s-m-color-" + bg);
	},
	_setCellSizeClasses: function() {
		var self = this;
		if (self.article.$sameSize !== true) {
			var widthFound = false;
			var sizes = [],
				sz;
			_sizes.forEach(function(size) {
				sz = self.article[size.$prop];
				if (sz != null && sz >= 1 && sz <= 12) {
					sizes.push(size.$prefix + sz);
				};
			});
			if (sizes.length == 0) {
				self.article.$sameSize = true;
				self.article.$widthAll = 12;
			}
		}
		if (self.article.$sameSize === true) {
			if (self.article.$widthAll == null) self.article.$widthAll = 12;
			sizes = ["col-xs-" + Math.min(12, Math.max(1, self.article.$widthAll), self.article.$widthAll)];
		}
		self.$$elmt.addClass(sizes.join(" "));
	},
	_ensureHeader: function() {
		// header is created under $$cell - used by vignette to display icon on/off like in tiles
		return Base.prototype._ensureHeader.call(this, this.$$cell);
	},
	/**
	 * Used to adapt the behavior according to the kind of hhosted array
	 * typeArray: chart/carousel
	 * Chart:
	 * 	remove the default color for charts
	 * 	Hack: Done by programming since we don't manage default color by css
	 * 	Add s-m-chart to tune display fo these tiles by css
	 * Carousel:
	 * 	Remove fixed height
	 */
	notifSpecialArrayHosted: function(typeArray) {
		if (!this.$$cell) return;
		if (typeArray === "chart") {
			this.$$cell.removeClass("s-m-bg s-m-color-" + this.article.$bgColor);
			this.$$elmt.addClass("s-m-chart");
		} else if (typeArray === "carousel") {
			this.$$elmt.addClass("s-m-carousel");
		}
	}
});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/vignetteBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/application/pageLoader','syracuse-tablet/html/js/application/pageRegistry','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/controls/ctrlFactory','syracuse-tablet/html/js/application/gadget'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var PageLoader = require('syracuse-tablet/html/js/application/pageLoader').Klass;
var pageRegistry = require('syracuse-tablet/html/js/application/pageRegistry');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("app");
var locale = require('syracuse-tablet/html/js/helpers/locale');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');
var Gadget = require('syracuse-tablet/html/js/application/gadget').Klass;

var _actionTitleMgr = {
	action: "togglePinVignette",
	/**
	 * Allows vignetteCtrl to add title to cell/tile
	 * Returns true if action bar found
	 */
	iconActionAdd: function(vignetteCtrl) {
		if (vignetteCtrl._$$actionIcon) {
			// We store the icon to not add it multiple time
			return true;
		}
		var icon = fontUtils.getPinVignetteIcon("off") || "";
		var iconBarCtrl = _actionTitleMgr.getIconBarCtrl(vignetteCtrl);
		if (!iconBarCtrl || icon.length === 0) {
			return false;
		}
		iconBarCtrl.$$header.addClass("s-m-has-act-icon").attr({
			"data-action": _actionTitleMgr.action,
			"data-control-id": vignetteCtrl.id
		}).append($('<i class="s-m-tile-act ' + icon + '" style="float:right"/>'));
		if (vignetteCtrl.controller.isDashboard("hub")) {
			iconBarCtrl.$$elmt.css("padding-top", iconBarCtrl.$$header.height() + "px");
		}
		vignetteCtrl._$$actionIcon = _actionTitleMgr.iconActionToggleStatus(vignetteCtrl, "off");
		return true;
	},
	/**
	 * Allows vignetteCtrl to toggle the status of the action's icon
	 * status on/off
	 */
	iconActionToggleStatus: function(vignetteCtrl, status) {
		status = status || "off";
		var iconBarCtrl = _actionTitleMgr.getIconBarCtrl(vignetteCtrl);
		if (!iconBarCtrl) return;
		// We need to force it because of default tile color which is hard coded
		//	(vignetteCtrl._currentPage.isEditMode() ? iconBarCtrl.$$header : iconBarCtrl.$$elmt).toggleClass("s-m-color-" + globals.CELLENABLEDCOLOR, status === "on");
		iconBarCtrl.$$header.toggleClass("s-m-color-" + globals.CELLENABLEDCOLOR, status === "on");
		var $$res = iconBarCtrl.$$header.find('i.s-m-tile-act');
		$$res.removeClass(fontUtils.getPinVignetteIcon("all")).addClass(fontUtils.getPinVignetteIcon(status));
		return $$res;
	},
	/**
	 * Returns the parent controls that handles the icon bar
	 * tile or cell
	 */
	getIconBarCtrl: function(vignetteCtrl) {
		var ctrl = vignetteCtrl.parent;
		if (!ctrl || !ctrl._ensureHeader || !ctrl.$$elmt) return null;
		// creates header
		ctrl._ensureHeader();
		return ctrl;
	}
};
var _waitConfig = {
	className: 'waiting-blocks',
	elements: 5,
	auto: true,
	speed: 200
};
var _templates = {
	main: '\
		<section/>\
		<footer style="display:none"/> \
		<div class="s-m-waiting bckg" style="display:none"/> \
		<div class="s-m-waiting wheel" style="display:none"/> \
	',
	iframe: '\
		<br><iframe src="{{url}}" style="position: absolute; top: 0px; left: 0px; height: 100vh; width: 100vh;"/>\
	',
	navbtns: '\
		<span data-action="vignetteBack" class="' + fontUtils.vignetteIcons("back") + '" style="display:none"></span>\
		<span  data-action="vignetteHome" class="' + fontUtils.vignetteIcons("home") + '" style="display:none"></span>\
	',
	vignetteError: '\
		<a draggable="false" href="#" data-action="vignetteError">{{text}}</a>\
	',
	linkPage: '\
		<div draggable="false" href="{{href}}"\
			class="s-m-link-page">\
				{{#if icon}}\
					<section class="s-m-icon">\
						<div>\
							<div class="{{icon}}"></div>\
						</div>\
					</section>\
				{{/if}}\
				<section class="s-m-title">\
					<div>{{title}}</div>\
				</section>\
		</div>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};


var _Klass = utils.defineClass(

	function VignetteBase(controller, article, prototype, opts) {
		article.$article = article.$article || {};
		Base.call(this, controller, article, prototype, opts);
		this._currentPage = null;
		this._pageLoader = null;
		this._$$wait = null;
		this._stateStack = [];
		this._error = null;
		this.displayStyle = prototype.data("$displayStyle");
		this.openLinkInVignette = globals.$config("openLinkInVignette");
		this._actionsEnabled = false;
		this._gadget = new Gadget(this.prototype.getVignetteGadget());
		if (!this._gadget.isValid()) {
			this._badGadgetReason = this._gadget.getInvalidReason();
			this._gadget = null;
		}
	}, Base, {
		destroy: function() {
			this.destroyActionControls();
			this._error = null;
			// First - destroy all pages attached to the vignette - Otherwise removing this.$$elmt removes all data (smPageController) in children
			this.clearContent();
			if (this._$$wait) {
				uiUtils.waitPluginDestroy(this._$$wait);
			}
			if (this._pageLoader) {
				this._pageLoader.destroy();
				this._pageLoader = null;
			}
			if (this._gadget) {
				this._gadget.destroy();
				this._gadget = null;
			}
			this._$$actionIcon = null;
			Base.prototype.destroy.call(this);
		},
		clearContent: function() {
			if (this._currentPage) {
				// Current page
				this._currentPage.destroy();
				this._currentPage = null;
			}
			if (this._$$content) {
				// cached pages and all pending pages if navigation allowed in the vignette
				globals.getApplication().removeAllChildPages(this._$$content);
				this._$$content.empty();
			}
			this._stateStack = [];
		},
		/**
		 * If vignette contains a page return the control object identified by id
		 */
		getPageControl: function(ctrlId) {
			return this._currentPage && this._currentPage.getControl && this._currentPage.getControl(ctrlId);
		},
		getPageLayout: function(id) {
			return this._currentPage && this._currentPage.getLayout && this._currentPage.getLayout(id);
		},
		getPageStructElmt: function(id) {
			return this.getPageControl(id) || this.getPageLayout(id);
		},
		getPage: function() {
			return this._currentPage;
		},
		onMainPageResize: function(info, orientation, deviceType) {
			if (this._actionsEnabled && info.deviceChanged) {
				// Disable
				this._doTogglePinVignette(false);
				// Destroy controls to force create new ones - smartphone: headerControl - tablet: footerControl
				this.destroyActionControls();
			}
			if (this._currentPage == null || this._currentPage.state.options.$displayStyle !== "$full") return;
			this._currentPage.onMainPageResize(info, orientation, deviceType);
		},
		/**
		 * Change current page - called from eventListener
		 * 	data-nav action has been clicked in a vignette's link
		 * 	we could have a parameter that indicates if the link has to be opened full page or inside the vignette
		 */
		changePage: function(state, options) {
			options = options || {};
			// Propagate openLinkInVignette to child page - used to open reflinks...
			options.openLinkInVignette = this._openLinkInsideVignette();
			// Always full page
			options.$displayStyle = "$full";
			this._loadPage("openNewPage", state, options);
		},
		/**
		 * Refresh current page - called from eventListener
		 */
		refreshPage: function(options) {
			var self = this;
			if (!self._currentPage) throw new Error("No current page");
			if (self._error) this._removeError();
			self._currentPage.refresh(options, {
				waitWheelStart: function(controlId) {
					// Wait managed by vignette
					self.waitWheelStart();
				},
				waitWheelStop: function(controlId) {
					self.waitWheelStop();
				}
			}).then(function() {
				//	Eventually do something in vignette control	
			}).fail(function(e) {
				modal.error(locale.text("err.load.main"), e);
			});
		},
		hasBtnsBar: function() {
			return this._openLinkInsideVignette();
		},
		_openLinkInsideVignette: function(state) {
			if (this.openLinkInVignette === true) return true;
			var name;
			if (state == null) {
				name = this._currentPage ? this._currentPage.state.name : null;
			} else if ($.isPlainObject(state)) {
				name = state.name;
			} else {
				name = state;
			}
			if (typeof name === "string" && (name === "rowdetail" || name === "carddesign" || name.smEndsWith("$lookup"))) {
				this.openLinkInVignette = true;
			}
			if (this._currentPage && this._currentPage.isChild) this.openLinkInVignette = true;;
			return this.openLinkInVignette;
		},
		/**
		 * Mainly used by authoring to reload the page
		 * Returns a promise
		 */
		reloadPage: function(loadOptions) {
			if (!this.$displayStyle === "$full" || !this._currentPage) {
				return $.smResolve();
			}
			this._reloadSavedCtx = null;
			if (loadOptions && loadOptions.authoringUpdate === true && this.getPage()) {
				// Save the current context (scroll)
				this._reloadSavedCtx = this.getPage().savedCtxCreate();
			}
			var pageInfo = $.extend(true, {}, this._currentPage.state);
			this.clearContent();
			if (!this._pageLoader) {
				this._initPageLoader();
			}
			var self = this;
			return $.smResolve().then(function() {
				return self._pageLoader.load(pageInfo, false, loadOptions);
			}).fail(function(e) {
				self._displayError(locale.text("error.page.loading"), e);
			});
		},
		/**
		 * Load a page
		 * 	state
		 * 				state of the  page - stored in page object
		 * 	pageOptions
		 * 				options of the  page - stored in page object
		 * 	action: 	back for a back in vignette actions
		 * 				home for a home in vignette actions
		 * 	loadOptions
		 * 				updateLayout...
		 */
		_loadPage: function(action, state, pageOptions, loadOptions) {
			var self = this;
			self._error = null;
			if (!self._pageLoader) {
				self._initPageLoader();
			}
			var step;
			if (action === "back" || action === "home" || (action === "openNewPage" && typeof state === "object")) {
				step = $.smResolve(state);
			} else if (action === "openNewPage" && typeof state === "string") {
				// Read page info
				pageOptions = pageOptions || {};
				pageOptions.vignette = true;
				var articleCopy = pageOptions.vignetteArticle; // Backup of original article, this MUST NOT be cloned
				step = pageRegistry.getPageInfo(state, pageOptions, self._currentPage)
					.then(function(pageInfo) {
						pageInfo.options = pageInfo.options || {};
						if (articleCopy) {
							pageInfo.options.vignetteArticle = articleCopy;
						}
						// Pass the parentVignette to the page
						pageInfo.options.parentVignette = self;
						return pageInfo;
					});
			} else {
				throw new Error("Unexpected object state");
			}
			return step.then(function(pageInfo) {
				if (pageInfo.options && pageInfo.options.$displayStyle === "$full") {
					// action "home" is not a back. It's like an open page because we want to store the state in history
					return self._pageLoader.load(pageInfo, action === "back", loadOptions);
				} else if (pageOptions.gadget) {
					// Recreate the gadget because it can comes only in JSON format in pageOptions
					if (self._gadget) {
						self._gadget.destroy();
					}
					self._gadget = new Gadget(pageOptions.gadget);
					var icon = self._getCssIcon("s-m-sage-gadget-icon");
					var attrs = {
						"data-nav": pageInfo.name,
						"data-gadget-id": self._gadget.data("$uuid"),
						"data-application-name": self._gadget.data("applicationName"),
						"title": self.article && self.article.$article && self.article.$article.$title ? self.article.$article.$title : self._gadget.data("$title"),
						"icon": icon
					};
					if (pageInfo.options.$displayStyle === "$link" && self.article && self.article.$linkArticle) {
						// Used by test entities to pass an article to the page
						attrs["data-link-article"] = self.id;
					}
					self._addPicker(attrs);
					return $.smResolve();
				} else {
					throw new Error("Unexpected vignette page");
				}
			}).fail(function(e) {
				self._displayError(locale.text("error.page.loading"), e);
			});
		},

		_initPageLoader: function() {
			var self = this;
			/**
			 * Page loader shared with application
			 * Load a page
			 */
			self._pageLoader = new PageLoader({
				waitWheelStop: function() {
					self.waitWheelStop();
				},
				waitWheelStart: function() {
					self.waitWheelStart();
				},
				getRootElmt: function() {
					return self._$$content;
				},
				getCurrentPage: function() {
					return self._currentPage;
				},
				setCurrentPage: function(page) {
					self._currentPage = page;
					if (page != null) {
						// $full vignettes must be notified if a create/edit vignette takes the focus in order to toggle selection
						notifications.subscribe(self, ["sm.field.focus"]);
					} else {
						notifications.unsubscribe(self, ["sm.field.focus"]);
					}
				},
				historyPush: function(state) {
					// Add state in stack in all case - We need it for link to row Detail
					self._stateStack.push(state);
				},
				succeeded: function(dstPage, pageToClose, parentNotifInfo, back, loadOptions) {
					if (globals.isAutoUITestMode()) {
						globals.getUnitTestMgr().notifPageLoaded("after", dstPage);
					}

					if (!self.controller) return; //Vignette destroyed before end of load process
					if (self.hasBtnsBar()) {
						self.refreshBtnsBar();
					}
					if (parentNotifInfo && parentNotifInfo.notifId) {
						/**
						 * _notifyController  to notify only the page
						 */
						if (dstPage.id === parentNotifInfo.parentId) {
							notifications.notifyController(parentNotifInfo.notifId, self._currentPage, parentNotifInfo.notifData, parentNotifInfo.controlId);
						} else {
							modal.error("Child page notification warning", "Parent page is not the current page");
						}
					}
					// page has been loaded - Used to prevent multiple onresize calls to current page
					log && log("vignette loaded" + self.id);
					// Call resize handler each time a page has been loaded for calculations
					if (dstPage.state.options.$displayStyle === "$full") {
						/* setTimeout to resize dstPage after current process - #5737*/
						self._initActionDashboard(dstPage);
						setTimeout(function() {
							// Propagate load options
							var info = $.extend(true, {}, loadOptions);
							info.updateLayout = back === true || (loadOptions && loadOptions.updateLayout);
							dstPage.onMainPageResize(info);
						});
					}
				},
				loadingError: function(deferred, state, e) {
					self._displayError(locale.text("error.page.loading"), e);

					// No reject
					deferred.resolve(null, e);
				},
				/**
				 * Specific interface method for vignettes
				 * Returns the context of a page nested in a vignette and also context of the vignette (selection)
				 * Called by the pageLoader after the vignette has been displayed
				 */
				getSavedCtxVignette: function() {
					if (self._reloadSavedCtx != null) {
						// Restore the current context (scroll)
						var ctx = self._reloadSavedCtx;
						self._reloadSavedCtx = null;
						return ctx;
					}
					// It's the dashboard that manage the storage when we load a vignette
					if (!self.controller) {
						//Page has been destroyed before calling this method
						// If we have multiple vignettes and we click a link before all vignettes has been displayed we get this case
						return;
					}
					// The context has been saved before loading the vignettes and stored in self.controller(dashboard)
					return self.controller.getSavedCtxVignette(self);
				}
			});
		},
		/**
		 * If multiselection is enabled for the page we enable the switch of footer
		 * An icon in tile/cells's title allows the user to swicth the current footer by the one of the nested page (dstPage)
		 */
		_initActionDashboard: function(dstPage) {
			if (!dstPage) return;
			if (dstPage.isChild) {
				// Child page - wee add the actionControl
				this._updateActionControl();
			} else {
				// hasFooterHeaderActions(true) to enable action only if we declared footerHeader action in authoring
				// eg: all the query have a $create and we do'nt want to allow $create in vignettes - Only if we add $creatin in 'Action control' authoring
				this._typeAction = dstPage.isMultiSelectionEnabled() ? globals.ACTMULTISEL : dstPage.hasFooterHeaderActions(true) ? "footerHeader" : null;
				if (this._typeAction == null) return;
				this.openLinkInVignette = this._typeAction === "footerHeader";
				// True is action are allowed  - multiselection or crud
				this._actionsEnabled = _actionTitleMgr.iconActionAdd(this);
				notifications[this._actionsEnabled ? "subscribe" : "unsubscribe"](this, ["sm.vignette.pinned", "sm.multisel.stopped"]);
			}
		},
		/**
		 * Disables the vignette if we stop multi-selection (download)
		 */
		notifMultiselStopped: function(pageId) {
			// MultiselStopped notifies all the vignettes - In a dashboard it's only the vignette that embeds the page (pageId) that processes the event
			if (this._currentPage == null || this._currentPage.id !== pageId) return;
			if (!this._actionsEnabled || !this._actionControl) return;
			this._doTogglePinVignette(false);
		},
		/**
		 * Click on icon in tile/cells's header
		 */
		_actTogglePinVignette: function() {
			if (!this._actionControl) {
				// If the current vignette doesn't have the focus we disable the vignette which as the focus (notification)
				//!! notifications is synchrounous - We must disable the current enabled tile/cell (if any) before enabling
				notifications.publish("synch.sm.vignette.pinned", this.id);
			}
			// Toggles current vignette status after
			this._doTogglePinVignette();
		},
		/**
		 * Toggle the status of vignettes other than the vignette that has publihed the notification
		 */
		notifVignettePinned: function(skipThisId) {
			if (this.id == skipThisId) return;
			if (!this._actionsEnabled || !this._actionControl) return;
			// disable the vignette
			this._doTogglePinVignette(false);
		},
		/**
		 * Focus on a field
		 * If it's a field of the vignette we enable the vignette otherwise we disable
		 */
		notifFieldFocus: function(control) {
			if (!control || !control.controller.isVignette) return;
			var enable = control.controller.getParentVignette() === this;
			if ((enable && this._actionControl) || (!enable && !this._actionControl)) return;
			this._doTogglePinVignette();
		},
		/**
		 * Toggle icon status and switchs the footer
		 * id is used to select only the current object when we notify synch.sm.vignette.pinned
		 * show:	true force show
		 * 			false hide
		 * 			undefined toggle status
		 */
		_doTogglePinVignette: function(show) {
			if (!this._actionsEnabled || !this._currentPage) return;
			// Disables the vignette that have the focus and switchs current status
			//show =  show === false ? false :  show === true ? true : undefined;
			var status = show === false ? "off" : show === true ? "on" : this._actionControl ? "off" : "on";
			var controlToggle;
			var type = this.getTypeActionControl();
			if (status === "on") {
				this._actionControl = this._getActionControl(true);
				// We take the type header/footer depending on the device
				type = this.getTypeActionControl();
				controlToggle = this._actionControl;
			} else {
				if (!this._actionControl) {
					// nothing to restore
					return;
				}
				controlToggle = this._actionControl;
				// We take the type header/footer of the current control (can be different from current device when we switch device in developement mode)
				type = controlToggle.getPageControlType();
				this._actionControl = null;
			}
			// this._actionControl = null forces to restore the regular footer/header
			this.controller.toggleHeaderFooter(type, controlToggle, status === "on");
			// Toggle status and header icon
			_actionTitleMgr.iconActionToggleStatus(this, status);
		},
		/**
		 * Restore the right actionControl (footer/header) - used when navigation inside the vignette
		 */
		_updateActionControl: function() {
			if (!this._actionsEnabled) return;
			this._actionControl = this._getActionControl(true);
			this._doTogglePinVignette(true);
		},
		_getActionControl: function(create) {
			// _actionControlsCache because we can have multiple pages in a vignette
			// eg: Main page + child page (row detail..)
			// when we create X3 oject in vignettes we need to store the action control (header/footer) per page to restore it on back
			// id of control is the id of the page
			if (!this._actionControlsCache) this._actionControlsCache = {};
			var ctrl = this._actionControlsCache[this._currentPage.id];
			if (!ctrl && create) {
				ctrl = ctrlFactory.createActionControl(this.getTypeActionControl(), this, {
					multiSelectionOnly: this._typeAction === globals.ACTMULTISEL,
					//buildOpts are the one of the dashboard - #7932
					buildOpts: $.extend(true, {}, (this.controller.buildOpts || {}).toolBars)
				});
				this._actionControlsCache[this._currentPage.id] = ctrl;
			}
			return ctrl;
		},
		destroyActionControls: function() {
			if (!this._actionControlsCache || !this.controller) return;
			if (this._actionControl) {
				// remove from controller and restore regular one (null)
				this.controller.toggleHeaderFooter(this._actionControl.getPageControlType(), null);
			}
			var ctrl;
			for (var p in this._actionControlsCache) {
				ctrl = this._actionControlsCache[p];
				if (ctrl) {
					this.controller.removeControl(ctrl);
					ctrl.destroy();
				}
			}
			this._actionControl = this._actionControlsCache = null;
		},

		getTypeActionControl: function() {
			return globals.getSiteLayout().getDeviceType() === "smartphone" ? "header" : "footer";
		},

		_loadRepresentation: function(pageOptions, loadOptions) {
			var name = this._gadget.getPageName();
			pageOptions = $.extend({}, pageOptions);
			pageOptions.openLinkInVignette = this._openLinkInsideVignette(name);
			pageOptions.$displayStyle = this.displayStyle;
			// !!pageOptions MUST contains only JSON (not class object) - Restore context
			pageOptions.gadget = this._gadget.getJSON();
			pageOptions.vignetteArticle = this.article.$article; // sub article in case the layout of a vignette is defined in the dashboard layout
			// authoring properties of the page are stored by the vignette ($actionSettings..) and passed to  the page when we create the article
			// it's better to pass them independently from vignetteArticle to be able to merge them with a generated article if any
			pageOptions.vignetteAuthPageProps = {};
			utils.authCopyPageProperties(this.article, pageOptions.vignetteAuthPageProps);
			return this._loadPage("openNewPage", name, pageOptions, loadOptions);
		},

		_displayError: function(msg, detail) {
			this._error = {
				message: msg,
				detail: detail
			};
			if (this.$$elmt) {
				this._$$content.hide();
				this.$$elmt.addClass("s-m-error");
				this.$$elmt.prepend(_getHtml("vignetteError", {
					text: locale.text("vignette.load.failed")
				}));
				this.refreshBtnsBar();
			} else {
				globals.getModal().actionResult(locale.text("error.page.loading"), this._error, true);
			}
		},

		_removeError: function() {
			this.$$elmt.children('a[data-action="vignetteError"]').remove();
			this.$$elmt.removeClass("s-m-error");
			this._$$content.show();
			this._error = null;
		},

		buildHtml: function($$parent, controllerDao, buildOptions) {
			if (this._stateStack.length > 0) {
				// There could be cached pages

			} else {
				Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions, ["s-m-vignette"]);
				this.$$elmt.html(_getHtml("main", {}));
				this._$$content = this.$$elmt.children("section");
				this.$$footer = this.$$elmt.children("footer");
				this._$$waitBckg = this.$$elmt.children(".s-m-waiting.bckg");
			}
		},

		/**
		 * First load of the page
		 */
		load: function(vignetteId, pageOptions, loadOptions) {
			var self = this;
			// id that identify the vignette dahsboardName + vignette index
			self.vignetteId = vignetteId;
			pageOptions = pageOptions || {};

			var deferred = $.Deferred();

			var _finalize = function(page, error) {
				deferred.resolve(page, error);
				if (page != null) {
					// With stack layout the content (height) of the controller depends on vignette's size
					// We need to notify the controller to update the scroller - see #6401
					notifications.notifyController("sm.scroller.update", self.controller, self.id, page, error);
				}
			};
			var _fail = function(e) {
				self._displayError(locale.text("error.page.loading"), e);
				// Deferred is not rejected because error is displayed in the vignette
				_finalize();
			};
			try {
				if (this._gadget) {
					if (pageOptions.resize === true) {
						// Always clear content if resize to rebuild a new one
						this.clearContent();
					}
					switch (this._gadget.data("$type")) {
						case "$representation":
						case "$stats":
						case "$request":
							self._loadRepresentation(pageOptions, loadOptions)
								.then(function(page, error) {
									_finalize(page, error);
								})
								.fail(function(e) {
									_fail(e);
								});
							break;
						case "$dashboard":
							self._loadDashboard();
							_finalize();
							break;
						case "$application":
							self._loadApplication();
							_finalize();
							break;
						case "$external":
							self._loadExternal();
							_finalize();
							break;
						case "$gadgetMissing":
							self._displayError(locale.text("vignette.load.gadget.missing", [this._gadget.data("$uuid")]));
							_finalize();
							break;
						default:
							self._displayError(locale.text("vignette.load.gadget.unsupported", [this._gadget.data("$type")]));
							_finalize();
							break;
					}
				} else {
					self._displayError(locale.text("vignette.load.gadget.invalid", [this._badGadgetReason || "Unknown reason"]));
					_finalize();
				}
			} catch (e) {
				_fail(e);
			} finally {
				return deferred.promise();
			}
		},

		_getCssIcon: function(sageBaseCss) {
			var icon = this._gadget.data("icon") || this.article && this.article.$icon;
			if (icon) {
				if (icon.smStartsWith("s-m-")) {
					// our own gadget icons
					icon = sageBaseCss + " " + icon;
				} else {
					// FontAwesome
					icon = fontUtils.getIconByName(icon);
				}
			}
			return icon || "";
		},

		_loadDashboard: function() {
			this._addPicker({
				"data-nav": globals.getMetaData().getDashboardPageName(this._gadget.data("dashboardName")),
				"data-application-name": this._gadget.data("applicationName"),
				"data-gadget-id": this._gadget.data("$uuid"),
				"data-sdata-parameters": this._gadget.data("sdataParameters"),
				"title": this._gadget.data("$title"),
				"icon": this._getCssIcon("s-m-sage-gadget-icon")
			});
		},

		_loadApplication: function() {
			this._addPicker({
				"data-application-name": this._gadget.data("applicationName"),
				"title": this._gadget.data("$title"),
				"icon": this._getCssIcon("s-m-sage-app-icon"),
			});
		},

		_loadExternal: function() {
			var self = this,
				url = this._gadget.data("externalUrl");
			self._addPicker({
				"data-external-link": url,
				"title": this._gadget.data("$title")
			});
			if (self.displayStyle !== "$link") {
				var iFrame = _getHtml("iframe", {
					url: url
				});
				$(iFrame).appendTo(self._$$content);
			}
		},

		_addPicker: function(context) {
			// #8095 we add the link attributes to parent (tile/cell/stack) to have the whole area sentive/clickable
			var linkAttrs = {
				"data-nav-target": "application"
			};
			var vignetteCtx = {};
			for (var p in context) {
				if (p.smStartsWith("data-")) {
					linkAttrs[p] = context[p];
				} else {
					vignetteCtx[p] = context[p];
				}
			}
			$(_getHtml("linkPage", vignetteCtx)).appendTo(this._$$content);
			(this.parent.$$elmt || this.$$elmt).attr(linkAttrs);
		},

		waitWheelStart: function() {
			var self = this;
			if (!self._$$wait) {
				self._$$wait = uiUtils.waitPluginCreate(self.$$elmt.children(".s-m-waiting.wheel"), _waitConfig).wrap('<div class="s-m-wait-root"/>');
			}
			uiUtils.waitPluginEnable(this._$$wait);
			this._$$waitBckg.show();
		},
		waitWheelStop: function() {
			if (this._$$wait) {
				uiUtils.waitPluginDisable(this._$$wait);
			}
			this._$$waitBckg.hide();
		},

		refreshBtnsBar: function() {
			if (this._openLinkInsideVignette()) {
				var show = false;
				if (!this.$$icnBack) {
					this.$$footer.prepend(_getHtml("navbtns"));
					this.$$icnBack = this.$$footer.children("[data-action=vignetteBack]");
					this.$$icnHome = this.$$footer.children("[data-action=vignetteHome]");
				}
				var l = this._stateStack.length;
				this.$$icnBack.toggle(l > 1);
				this.$$icnHome.toggle(l > 2 && !this._currentPage.prototype.isLookup());
				show = this._stateStack.length > 1;
				this.$$footer.toggle(show);
				this.$$elmt.toggleClass("footer", show);
			}
		},
		/**
		 * Return a promise - Resolve with the displayed page
		 */
		_actVignetteHome: function() {
			var self = this;
			if (self._stateStack.length == 0) return $.smResolve(this._currentPage);
			var state = self._stateStack[0];
			self._stateStack = []; // to force clearContent
			return self._loadPage("home", state).then(function(page, error) {
				self._updateActionControl();
				return $.smResolve(page);
			});
		},
		/**
		 * Return a promise - Resolve with the displayed page
		 */
		_actVignetteBack: function() {
			var self = this;
			if (self._stateStack.length <= 1) return $.smResolve(this._currentPage);
			self._stateStack.pop();
			// !!! true for BACK in order to unstack the current page
			return self._loadPage("back", self._stateStack[self._stateStack.length - 1]).then(function(page, error) {
				self._updateActionControl();
				return $.smResolve(page);
			});
		},
		// Allows call from extern module 
		goBack: function() {
			return this._actVignetteBack();
		},
		// Allows call from extern module 
		goHome: function() {
			return this._actVignetteHome();
		},
		_actVignetteError: function() {
			var self = this;
			if (self._error.detail) {
				modal.error(self._error.message, self._error.detail);
			} else {
				modal.error("Vignette load error", self._error);
			}
		},
		_actVignetteRefresh: function() {
			this.refreshPage({});
		},
		isOverflow: function() {
			if (!this._currentPage) return;
			return (this._currentPage.$$elmt.height() - this.$$elmt.height()) > 0;

		},
		getScrollViewRect: function() {
			return uiRect.elmtRect(this._$$content, "inner");
		},
		isVignette: function() {
			return true;
		},
		// Only for test entities - We can attache an article to a $link vignette
		getLinkedPageArticle: function() {
			return this.article ? this.article.$linkArticle : null;
		},
		// True if the vignette is displayed as a picker (link)
		isLinkVignette: function() {
			switch (this._gadget.data("$type")) {
				case "$representation":
				case "$stats":
				case "$request":
					return this.displayStyle === "$link";
					break;
				case "$dashboard":
				case "$application":
				case "$external":
					return true;
				default:
					return false;
					break;
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/ctrlBreadCrumbs',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/helpers/uiSettings','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var globals = require('syracuse-tablet/html/js/helpers/globals');
var prototype = require('syracuse-tablet/html/js/helpers/prototype');
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var _templates = {
	items: '\
		<div class="s-m-items">\
		{{#each items}}{{{html}}}{{/each}}\
		</ul>\
		',
	item: '<a draggable="false" href="#" data-action="breadcrumb-click" data-control-id="{{ctrlId}}" data-params="{{data}}"><div class="s-m-item"><div class="s-m-text">{{text}}</div>{{#if notLast}}<div class="fa fa-caret-right s-m-icon-small"></div>{{/if}}</div></a>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};

var _Klass = utils.defineClass(
	function CtrlBreadCrumbs($type, controller, options) {
		Base.call(this, controller, {
			$bind: "breadcrumbs"
		}, prototype.create({
			$type: $type
		}), options);

		notifications.subscribe(this, ["sm.mainpage.loaded"]);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			this._pageStates = [];
		},

		buildHtml: function($$parent, controllerDao, buildOptions) {
			this._height = uiSettings.getProp("breadcrumbs.height");
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions, [this.typeName]);
			this.$$elmt.css("height", this._height);
		},
		onMainPageResize: function(info, orientation) {
			var deviceType = globals.getSiteLayout().getDeviceType();
			this.$$elmt.parent().toggle(deviceType === "tablet");
		},
		afterRender: function(updateLayout, buildOpts) {},
		applyMetaData: function(metaData, buildOptions) {
			//  No meta for this control 
			return;
		},
		getHeight: function() {
			return this.$$elmt.is(":visible") ? this._height : 0;
		},
		/**
		 * Needed after authoring update
		 */
		refresh: function() {
			this._buildBreadcrumbs();
		},
		notifMainpageLoaded: function() {
			this._buildBreadcrumbs();
		},
		_buildBreadcrumbs: function() {
			var history = globals.getApplication().history;
			var self = this;
			if (!self.$$elmt) {
				return;
			}
			var items = this._getItems(history);
			var crumbs = [];
			self._pageStates = [];
			$.each(items, function(idx, state) {
				var uuid = utils.UUID();
				self._pageStates[uuid] = $.extend(true, {}, state, {
					stackNum: idx
				});
				crumbs.push({
					html: _getHtml("item", {
						text: state.$title,
						notLast: (idx + 1 < items.length),
						ctrlId: self.id,
						data: uuid
					})
				});
			});
			var html = _getHtml("items", {
				items: crumbs
			});

			this.$$elmt.empty();
			this.$$elmt.append(html);
		},
		_getItems: function(history) {
			history = history || [];
			history = history.slice(0);
			history = history.reverse(); // Latest is first
			var stackToHome = [];

			// Filter history to only show stack until we reach welcome page for the first time to keep it as small as possible
			history.some(function(state) {
				stackToHome.push(state);
				if (state.isWelcomePage) {
					return true;
				}
				return false;
			});
			return stackToHome;
		},
		_actBreadcrumbClick: function(uuid) {
			var self = this;
			var state = self._pageStates[uuid];
			if (!state) return;
			var num = state.stackNum;
			if (num <= 0) return; // Click on current page, no need to do an action
			globals.getApplication().goBack(function PageFilter(histState) {
				if (num === 0) {
					return true;
				}
				num--;
			});
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/application/actionManager',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/sdata/sdataDispatcher','syracuse-tablet/html/js/sdata/sdataUtils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var dispatcher = require('syracuse-tablet/html/js/sdata/sdataDispatcher');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

/**
 * Parse code=abc&value=cde to
 * {
 * code: "abc",
 * value: "cde"
 * }
 */
var _parseParameters = function(params) {
	var p = params.split("&");
	var res = {};
	for (var i = 0; i < p.length; i++) {
		var v = p[i].split("=");
		res[v[0]] = v[1];
	}
	return res;
};

/**
 * Set pageOpts with auto scroll value to preserve scrolling when we go from detail -> edit
 * We do the same for cancelEdit action in pageRegular when we go from edit -> detail
 */
var _preserveScrolling = function(page, link, pageOpts) {
	if (!page || !link || !pageOpts) return;
	var val = page.getScrollValue();
	// Auto-scroll - If we edit a page we keep the scrolling
	if (!isNaN(val) && val !== 0) {
		// 1.2 because the height of the page is higher in edit mode 
		// To improve or disable but to me it's great to keep the scrolling when we edit a page
		pageOpts["auto-scroll"] = page.getScrollValue() * 1.2;
	}
};
/**
 * Default message display
 * TODO - Message + detail
 */
var _displayMessage = function(title, data, cb) {
	if (data === null) data = "";
	if (jsutils.isError(data)) {
		data = data.message;
	} else if (typeof data === "string") {
		// Nothing
	} else {
		var diags = sdataUtils.scanDiagnoses(data);
		if (diags.length > 0) {
			var msg = [];
			diags.forEach(function(d) {
				msg.push(d.$message);
			});
			data = msg.join('\n');
		} else {
			data = JSON.stringify(data, null, 2);
		}
	};
	globals.getModal().info(title, data, cb);
};
/**
 * Manage action on links given by prototype
 * Used by footer/header/navigation panel
 */
var _Klass = utils.defineClass(

	function(controller, toolbar, options) {
		this.options = options || {};
		this.toolbar = toolbar;
		this.controller = controller;
		this._initLinks();
		this.uuid = utils.UUID();
	}, null, {

		destroy: function() {
			this.options = null;
			this.controller = null;
		},
		/**
		 * To update links if by example deviceType changed
		 */
		_initLinks: function() {
			var self = this;
			var deviceType = globals.getSiteLayout().getDeviceType();
			var beginLinks = [];
			if (self.options.addMultiSelection && !self.controller.isEditMode()) {
				beginLinks.push(self.getMultiSelectionLink());
			}
			// multiSelectionOnly = true - Only multi-selection is enabled - Used by vignettes
			// In that case it's not necessary to set addMultiSelection = true
			if (self.options.multiSelectionOnly != true) {
				var toolBarLinks = self.controller.getToolbarLinks(self.toolbar) || [];
				var endLinks = [];
				if (self.controller.isEditMode()) {
					if (self.options.addCancelEditAction) {
						endLinks.push(self.getCancelEditAction(self.options.addCancelEditAction));
					}
					// No template for rowDetail
					if (self.options.addShowTemplatesAction && !self.controller.isChild) {
						endLinks.push(self.getEditTemplatesAction(self.options.addCancelEditAction));
					}
				}
			}
			self.links = jsutils.concatArrays(beginLinks, toolBarLinks, endLinks);
			if (globals.isAutoUITestMode()) {
				self.links.forEach(function(l) {
					l.x3LinkName = l.name;
				});
			}
		},
		addLink: function(lnk) {
			if (!lnk || this.findLink(lnk.$uuid) != null) return lnk;
			if (!this.links) this.links = [];
			this.links.push(lnk);
			if (globals.isAutoUITestMode()) {
				lnk.x3LinkName = lnk.name;
			}
			return lnk;
		},
		/**
		 * Add action to links
		 */
		getCancelEditAction: function(actionName) {
			return {
				name: "$canceledit",
				icon: fontUtils.getIconByName("$cancelEdit"),
				isClientAction: true,
				action: actionName || "cancelEdit",
				title: locale.text("action.cancelEdit"),
				$uuid: utils.UUID()
			};
		},
		getEditTemplatesAction: function(actionName) {
			return {
				name: "$showtemplates",
				icon: fontUtils.getIconByName("$showtemplates"),
				isClientAction: true,
				action: actionName || "showtemplates",
				title: locale.text("action.showtemplates"),
				$uuid: utils.UUID()
			};
		},
		getMultiSelectionLink: function() {
			return {
				name: "$multiSelection",
				icon: fontUtils.getIconByName("$multiSelection"),
				isClientAction: true,
				action: globals.ACTMULTISEL,
				css: ["s-m-ismultisel"],
				title: locale.text("action.multiselect"),
				$uuid: utils.UUID()
			};
		},
		/**
		 * exclude: array/string of $uuid to exclude
		 */
		getLinks: function(exclude, filter) {
			if (exclude && typeof exclude === "string") {
				exclude = [exclude];
			}
			if (this.links == null || exclude == null || exclude.length == 0 || !filter) {
				return this.links;
			}
			filter = filter || [];
			var lnks = [];
			this.links.forEach(function(l) {
				if (!exclude.some(function($uuid) {
						return l.$uuid === $uuid;
					})) {
					if (filter.some(function(props) {
							var found = true;
							Object.keys(props).forEach(function(key) {
								if ((l[key] && props[key] != l[key]) || (l[key] == null && props[key] != false)) {
									found = false;
								}
							});
							return found;
						})) {
						lnks.push(l);
					}
				}
			});
			return lnks;
		},
		hasLinks: function() {
			return this.links && this.links.length > 0;
		},
		findLink: function(uuid) {
			if (!this.links) return null;
			var lnk;
			this.links.some(function(l) {
				if (l.$uuid === uuid) {
					lnk = l;
					return true;
				}
			});
			return lnk;
		},
		/**
		 *  Triggers a link action/navigation and resolve/reject
		 *  		displayed eventually a message if diagnoses have been returned by server
		 *  uuid
		 *  		Id of the link which has been stored in the html (data-params)
		 *  page: optional - page that will be notified with data returned by action
		 *  	  mandatory for cancelEdit action
		 * 	options
		 * 		For a navigation link
		 * 			If options.noRedirection == true resolve with the following data
		 * 				{
		 * 					gotoPage:{
		 * 						name:"PageName",
		 * 						options{Pages options}
		 * 					}
		 * 				}
		 * 				It's the caller that calls application.changepage
		 * 			Else it does redirection to the target page
		 */
		triggerLink: function(uuid, page) {
			var deferred = $.Deferred();
			try {
				var self = this;
				// reads link info
				var link = this.findLink(uuid);
				if (!link) return;
				// ACTION WITH CONFIRMATION
				if (link.$confirm) {
					// Action with confirmation asked by server
					globals.getModal().simpleConfirm(link.$confirm, function(confirmed) {
						if (confirmed === "yes") {
							self._execLink(deferred, page, link);
						}
					});
					return;
				} else {
					self._execLink(deferred, page, link);
				}

			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},
		_execLink: function(deferred, page, link) {
			var self = this;
			// CLIENT ACTION - NON SDATA ACTION
			if (link.isClientAction) {
				if (!page) throw new Error("triggerLink - Page is expected");
				self._notifyAndResolve(page, deferred, true, link);
				return;
			}
			/**
			 * $isAction comes from prototype (true for save, delete...)
			 * If url contains $services $isAction is set to true (see prototype.getLinks)
			 * 		$services urls are considered as actions
			 * !! No url and $isAction means child page action
			 */
			// ACTION - #6195 we consider DELETE to be an action because we stay on the same page
			if (link.$isAction || link.$method === "DELETE") {
				// Action which stays on the same page
				self._doLinkAction(deferred, page, link);
				return;
			}
			// NAVIGATION
			if (link.page) {
				// Navigation to a page
				var pageOpts = {
					"sdata-url": link.sDataUrl,
					"sdata-method": link.$method,
					"sdata-parameter": link.parameters
				};
				if (pageOpts["sdata-parameter"]) {
					pageOpts["sdataParameters"] = _parseParameters(pageOpts["sdata-parameter"]);
				}

				if (page) {
					// Auto-scroll - If we edit a page we keep the scrolling
					if (page.state.name.replace(".$details", ".$edit") === link.page) {
						_preserveScrolling(page, link, pageOpts);
					}
				};
				if (self.options.noRedirection === true) {
					// Caller wants to manage redirection
					self._notifyAndResolve(page, deferred, true, link, {
						gotoPage: {
							name: link.page,
							options: pageOpts
						}
					}, self.options);
				} else {
					// callerhandlesErrors: we don't want the caller to redirect to homepage if there's an error
					// -> We stay on the current page
					var opts = {
						callerhandlesErrors: true
					};
					globals.getApplication().changePage(link.page, pageOpts, opts).then(function() {
						// Page is changed so it's not necessary
						deferred.resolve();
					}).fail(function(e) {
						// Display error message and stays on current page
						if (e) {
							var diags;
							if (e.responseJSON && e.responseJSON.$diagnoses) {
								// Check http result
								diags = e.responseJSON.$diagnoses;
							} else if (e.$diagnoses) {
								// Some processes return the responseJSON (displatcher http _networkError)
								diags = e.$diagnoses;
							}
							if (diags && diags.length > 0) {
								e = {
									$diagnoses: diags
								};
							} else {
								var msg = "";
								if (e.status != null) {
									msg += "httpStatus=" + e.status;
								}
								if (e.message != null) {
									msg += " - " + e.message;
								}
								e = {
									$diagnoses: [{
										$severity: "error",
										$message: msg
									}]
								};
							}
						}
						globals.getModal().actionResult(locale.text("error.page.loading"), e);
						deferred.resolve();
					});
				}
				return;
			} else if (link.externalUrl) {
				var url = utils.parseExpression(link.externalUrl, page.dao, page.prototype);
				window.open(url);
				return;
			}
			// Unexpected case
			_displayMessage("Unexpected link type", link, function() {
				self._notifyAndResolve(page, deferred, false, link, null, self.options);
			});
		},

		/**
		 * Send an action to server and process result
		 * Resolve/reject deferred
		 */
		_doLinkAction: function(deferred, page, link) {
			var self = this;
			var _end = function(success, data) {
				self._notifyAndResolve(page, deferred, success, link, data);
			};
			try {
				// Validate the data before processing - Synchronous call
				if (page && page.validateBeforeActionLink && page.validateBeforeActionLink(link) === false) {
					// Just resolve - No notification because action has not been sent
					deferred.resolve(false);
					return;
				}
				if (link.sDataUrl) {
					if (page) page.waitWheelStart();
					// Call always getActionPayload  (remove dioagnoses)
					var payload = page.dao.getActionPayload(link, page.isEditMode());
					dispatcher.dispatch({
							$url: link.sDataUrl,
							$method: link.$method || "GET"
						}, payload)
						.then(function(result) {
							// We also end up here when there is a http 500 return code
							if (page) page.waitWheelStop();
							if (!result) {
								//#7701 not expected - we assume it's ok but we could throw an error - For compatibility only
								result = {
									isSuccess: true,
									status: 200,
									responseJSON: {}
								};
							}
							// TODO: Review this, should be done at a lower level
							if (result && result.status === 500) {
								// wrap initial diags by a general message that does not scare the user and hides
								// Technical error
								result.responseJSON = globals.getModal().createGeneralErrorDiag(result);
								_end(false, result);
								return;
							} else if (result && !result.isSuccess) {
								// #7701 - Application error
								_end(false, result);
								return;
							}
							// True for success
							_end(true, result);
						})
						.fail(function(e) {
							if (page) page.waitWheelStop();
							// #7701  only exception are expected here
							// Exception - we display the message
							_displayMessage("Action '" + link.title + "' failed", e, function() {
								deferred.reject(e);
							});
						});
				} else {
					// Child page action - True for success - no data
					_end(true);
				}
			} catch (e) {
				_displayMessage("Action '" + link.title + "' javascript exception", e, function() {
					deferred.reject(e);
				});
			}
		},
		/**
		 * Notify (the page controller) to do some stuff after an action succeeded
		 * Save/Delete...
		 */
		_notifyAndResolve: function(page, deferred, success, link, result) {
			if (page) {
				var opts = $.extend({}, this.options);
				// Used to identify the actionMgr that processed the action 
				opts.fromActionMgrUUID = this.uuid;
				notifications.notifyController("sm.action.link", page, success, link, result, opts);
			}
			if (deferred) {
				deferred.resolve(success, link, result, this.options);
			}
		}
	});

exports.Klass = _Klass;

/**
 * toolbar	header, footer, actionpanel...
 * opts
 * 			addCancelEditAction
 * 				Name aof action to trigger (headerAction; footerAction...)
 * 				Link is not added if null
 * 			noMessage
 */
exports.create = function(controller, toolbar, opts) {
	return new _Klass(controller, toolbar, opts || {});
};
});

define('syracuse-tablet/html/js/sdata/sdataSyncUtils',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/prototype'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var prototypeModule = require('syracuse-tablet/html/js/helpers/prototype');

var _syncMaxLevels = 6;

exports.getSyncStructure = function(prototype) {
	var node = {
		$title: prototype.data("$title")
	};
	var urlList = [];
	return _resolvePrototype({
		prototype: prototype,
		level: 1,
		maxLevels: _syncMaxLevels
	}, node, urlList);
};

function _resolvePrototype(opts, node, urlList) {
	node.uuid = utils.UUID();
	node.$children = [];
	if (opts.level >= opts.maxLevels) {
		return $.smResolve(node);
	}

	var $links;

	// For query facet, only take $details link into account
	if (opts.prototype.getFacet() === "query") {
		var $resources = opts.prototype.property("$resources");
		if ($resources && $resources.$item && $resources.$item.$links && $resources.$item.$links.$details) {
			$links = {
				$details: $resources.$item.$links.$details
			};
		}
	} else if (opts.prototype.getFacet() === "details") {
		$links = opts.prototype.data("$links");
		if ($links && $links.$edit) {
			node.$canEdit = true;
		}
	} else {
		// Only $details and $query facets allowed, we should never end up here, just for safety
		return $.smResolve(node);
	}
	if (!$links) {
		return $.smResolve(node);
	}

	return $.smForEachPromise(Object.keys($links), function(name) {
		var link = $links[name];
		if (_isCacheableLink(link, name, urlList)) {
			//var url = sdataUtils.parseSDataURL(link.$url);
			var repr = _getRepresentation(link);
			if (repr) {
				urlList.push(link.$url);

				var child = {
					$name: name,
					$title: utils.parseExpression(link.$title, null, opts.prototype, true),
					$link: link,
					$representation: repr
				};
				node.$children.push(child);
				return _processNode(child, opts, urlList);
			}
		}
		return $.smResolve(node);
	})
		.then(function() {
			if (node.$canEdit) {
				node.$editLink = $links["$edit"];
				var repr = _getRepresentation(node.$editLink);
				var protoName = _getProtoName({
					$representation: repr
				}, {
					prototype: opts.prototype // Only $baseUrl is extracted
				});
				var meta = globals.getMetaData();
				return meta.getPrototype(protoName)
					.then(function(proto) {
						node.$editPrototype = prototypeModule.create(proto);
					});
			}
		})
		.then(function() {
			return node;
		});
}

function _isCacheableLink(link, name, urlList) {
	if (urlList.indexOf(link.$url) > -1) {
		return false;
	}
	if (name.indexOf("$") === 0 && name !== "$details") {
		return false;
	}
	if (link.$method !== "GET") {
		return false;
	}
	if (link.$url.indexOf("/$services/") > -1) {
		return false;
	}
	if (link.$url.indexOf("representation=") < 0) {
		return false;
	}
	var repr = _getRepresentation(link);
	if (!repr || repr.indexOf(".$details") < 0 && repr.indexOf(".$query") < 0) {
		return false;
	}
	return true;
}

function _getRepresentation(link) {
	var repr = /[\?\&]representation=(\S+?)(&|$)/.exec(link.$url);
	return repr && repr[1];
}

function _processNode(node, opts, urlList) {
	var meta = globals.getMetaData();
	var protoName = _getProtoName(node, opts);
	return meta.getPrototype(protoName)
		.then(function(proto) {
			if (proto) {
				proto = prototypeModule.create(proto);
				node.$prototype = proto;
				if (node.$name === "$details") {
					node.$title = proto.data("$title");
					node.$isDetails = true;
				}

				return _resolvePrototype({
					prototype: proto,
					level: opts.level + 1,
					maxLevels: opts.maxLevels
				}, node, urlList);
			}
		});
}

function _getProtoName(node, opts) {
	var endpoint = opts.prototype.data("$baseUrl");
	endpoint = endpoint.split("/");
	endpoint = endpoint.slice(endpoint.length - 3, endpoint.length).join(".");
	return endpoint + "." + node.$representation;
}
});

define('syracuse-tablet/html/js/ui/modals/modalSyncOffline',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/sdata/sdataDispatcher','syracuse-tablet/html/js/sdata/sdataSyncUtils'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var sdataDispatcher = require('syracuse-tablet/html/js/sdata/sdataDispatcher');
var sdataSyncUtils = require('syracuse-tablet/html/js/sdata/sdataSyncUtils');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
			<div class="s-m-scroll-element"> \
				<div class="form-group" id="s-m-sync-no-data-id"> \
					<div class="panel s-m-panel-diag-error"><div class="panel-heading">{{label_errors}}</div><ul></ul></div> \
					<center>{{label_no_data}}</center>\
				</div> \
				<div class="form-group" id="s-m-sync-actions-id"> \
					<center> \
						<button type="button" class="btn btn-default s-m-modal-btn-sync" data-action="modal-sync">{{label_sync}}</button> \
						<button type="button" class="btn btn-default s-m-modal-btn-sync-stop hidden" data-action="modal-sync-stop">{{label_sync_stop}}<div class="s-m-sync-total"><span class="label label-success ok"></span><span class="label label-danger error"></span></div></button> \
					</center> \
				</div> \
				<div class="form-group" id="s-m-sync-tree-id"> \
					<label>{{label_tree}}</label> \
					<div id="s-m-sync-tree-id"></div> \
				</div> \
			</div> \
			</div>',
	footer: ''
};

var _Klass = utils.defineClass(
	function ModalSyncOffline(syncRootData) {
		var self = this;
		modalDialog.ModalBase.call(self);
		self.syncRootData = syncRootData;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "sync-offline half_right";
			} else {
				displayFlags.modalClass = "sync-offline full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			var data = {
				title: locale.text("modal.sync.title"),
				label_tree: locale.text("modal.sync.header.tree"),
				label_sync: locale.text("modal.sync.label_sync"),
				label_sync_stop: locale.text("modal.sync.label_sync_stop"),
				label_no_data: locale.text("modal.sync.nodata"),
				label_errors: locale.text("modal.sync.errors")
			};
			return data;
		},

		_onShow: function() {
			var self = this;
			modalDialog.ModalBase.prototype._onShow.call(self);
			sdataSyncUtils.getSyncStructure(self.syncRootData.pageProto)
				.then(function(tree) {
					self.syncTreeRoot = tree;
					if (self.syncTreeRoot) {
						self._buildStructHtml(tree);
					} else {
						self._noData();
					}
				})
				.fail(function(e) {
					self._noData(e);
				});
		},

		_noData: function(e) {
			var self = this;
			$("#s-m-sync-no-data-id").show();
			$("#s-m-sync-actions-id").hide();
			$("#s-m-sync-tree-id").hide();

			var $$ul = $("#s-m-sync-no-data-id ul");
			$$ul.empty();
			e = e && e.$diagnoses;
			if (e && e.length) {
				$("#s-m-sync-no-data-id .panel").show();
				var i;
				for (i = 0; i < e.length; i++) {
					var msg = e[i] && e[i].$message;
					if (msg) {
						var $$li = $("<li>");
						$$li.text(msg);
						$$ul.append($$li);
					}
				}
			} else {
				$("#s-m-sync-no-data-id .panel").hide();
			}
		},
		_buildStructHtml: function(node) {
			var self = this;
			$("#s-m-sync-no-data-id").hide();
			$("#s-m-sync-actions-id").show();
			$("#s-m-sync-tree-id").show();
			var $$sync = $("#s-m-sync-tree-id");
			var $$ul = $("<ul>");
			self._addNode($$ul, node, 0);
			$$sync.append($$ul);
		},

		_addNode: function($$parent, node, level) {
			var self = this;
			var cls = level > 0 ? "collapsed" : "expanded";
			cls = cls + (level < 1 ? " selected" : "");
			var $$li = $('\
				<li class="s-m-sync-tree-item ' + cls + '" data-params="' + node.uuid + '"> \
					<div class="s-m-tree-icon-expand" data-action="tree-click-expand" data-params="' + node.uuid + '"></div> \
					<div class="s-m-tree-label" data-action="tree-click-select" data-params="' + node.uuid + '"></div> \
					<div class="s-m-sync-count hidden"><div>"\
				</li>');
			$("div.s-m-tree-label", $$li).text(node.$title);
			$$parent.append($$li);
			if (node.$children.length > 0) {
				var $$ul = $("<ul>");
				if (node.$isDetails !== true) {
					// For $query parent, the single $details link is not added to the tree it will be handled implicitly
					var child = node.$children[0];
					if (child && child.$children && child.$children.length > 0) {
						$$li.append($$ul);
						child.$children.forEach(function(child) {
							self._addNode($$ul, child);
						});
					}
				} else {
					if (node.$children && node.$children.length > 0) {
						$$li.append($$ul);
						// For a $details parent, all child links are added as new tree level
						node.$children.forEach(function(child) {
							self._addNode($$ul, child);
						});
					}
				}
			}
			// No children added
			if ($("ul", $$li).length < 1) {
				var $$expand = $(">.s-m-tree-icon-expand", $$li);
				$$expand.removeClass("s-m-tree-icon-expand");
				$$expand.addClass("s-m-tree-icon-leaf");
				$$expand.attr("data-action", null);
			}
		},
		_onAction: function(action, param) {
			var self = this;
			if (action === "tree-click-expand") {
				self._onTreeClickExpand(param);
			} else if (action === "tree-click-select") {
				self._onTreeClickSelect(param);
			} else if (action === "modal-sync") {
				self._syncData();
			} else if (action === "modal-sync-stop") {
				self.stopSync = true;
			}

			return false;
		},
		_onValidate: function() {},

		_onCancel: function() {},

		_getResult: function() {
			return "done";
		},
		_onTreeClickExpand: function(param) {
			var self = this;
			var $$li = $('li[data-params="' + param + '"]');
			if ($$li.hasClass("expanded")) {
				$$li.removeClass("expanded");
				$$li.addClass("collapsed");
			} else {
				$$li.addClass("expanded");
				$$li.removeClass("collapsed");
			}
		},
		_onTreeClickSelect: function(param) {
			var self = this;
			var $$li = $('li[data-params="' + param + '"]');
			if ($$li.hasClass("selected")) {
				$$li = $$li.add("li", $$li);
				$$li.removeClass("selected");
			} else {
				$$li = $$li.add("li", $$li);
				$$li.addClass("selected");
			}
		},

		_syncData: function() {
			var self = this;
			self.stopSync = false;

			var $$li = $('li[data-params="' + self.syncTreeRoot.uuid + '"]');

			$('button[data-action="modal-sync"]', self.$$elmt).addClass("hidden");
			$('button[data-action="modal-sync-stop"]', self.$$elmt).removeClass("hidden");

			self.syncCount = 0;
			self.errorCount = 0;
			self._updateErrorCount();
			$.smForEachPromise(self.syncRootData.rowsData, function(row, idx, cnt) {
				if (self.stopSync) {
					return $.smResolve();
				}
				self._updateSyncCount($$li, idx, cnt);
				return self._syncNodeData(self.syncTreeRoot, row.rowData.data);
			})
				.always(function(e) {
					$('button[data-action="modal-sync"]', self.$$elmt).removeClass("hidden");
					$('button[data-action="modal-sync-stop"]', self.$$elmt).addClass("hidden");
				});
		},

		_updateSyncCount: function($$li, idx, cnt) {
			var self = this;
			var $$state = $(">div.s-m-sync-count", $$li);
			$$state.removeClass("hidden");
			$$state.text((idx + 1) + " / " + cnt);
			var $$states = $("li>div.s-m-sync-count", $$li);
			$$states.addClass("hidden");
		},

		_updateErrorCount: function() {
			var self = this;

			var $$total = $('button[data-action="modal-sync-stop"]>.s-m-sync-total', self.$$elmt);
			var $$ok = $(">.ok", $$total);
			var $$error = $(">.error", $$total);
			$$ok.text(self.syncCount);
			$$error.text(self.errorCount);
		},

		_syncNodeData: function(node, parentData) {
			var self = this;
			var $$li;

			if (self.stopSync) {
				return $.smResolve();
			}

			if (node.$isDetails !== true) {
				$$li = $('li[data-params="' + node.uuid + '"]');
				if ($$li.length < 1) {
					return $.smResolve();
				}
				if (!$$li.hasClass("selected")) {
					return $.smResolve();
				}
				node.$$listItem = $$li;
			}

			node.$$listItem.addClass("sync-progress");

			var nodeData;
			if (node.$link) {
				nodeData = self._readNodeData(node, parentData);
			} else {
				nodeData = $.smResolve(parentData);
			}
			return nodeData
				.then(function(nodeData) {
					var dataItems = nodeData && nodeData.$resources;
					if (!dataItems && nodeData) {
						dataItems = [nodeData];
					}
					if (!dataItems) {
						return $.smResolve(null);
					}
					return $.smForEachPromise(dataItems, function(dataItem, idx, cnt) {
						if (self.stopSync) {
							return $.smResolve();
						}

						if (nodeData.$resources) {
							self._updateSyncCount($$li, idx, cnt);
						}
						return $.smForEachPromise(node.$children, function(child) {
							if (self.stopSync) {
								return $.smResolve();
							}

							child.$$listItem = $$li;
							return self._syncNodeData(child, dataItem);
						}).
						then(function() {
							// Children may set the same node to finished which may be wrong
							node.$$listItem.addClass("sync-progress");
						});
					});
				})
				.then(function() {
					node.$$listItem.removeClass("sync-progress");
				});
		},
		_readNodeData: function(node, parentData) {
			var self = this;
			var deferred = $.Deferred();
			var linkUrl = utils.parseExpression(node.$link.$url, parentData, node.$prototype);
			linkUrl = linkUrl + "&nocache=true"; // Always force to not use the cache

			sdataDispatcher.dispatch({
				$url: linkUrl,
				$method: "GET"
			})
				.then(function(data) {
					// No edit link, so we are done for detail record
					if (!node.$editLink) {
						self.syncCount++;
						self._updateErrorCount();
						deferred.resolve(data);

						return data;
					}

					// We also have to fetch $edit
					return self._readEditNodeData(node, data)
						.then(function() {
							self.syncCount++;
							self._updateErrorCount();
							deferred.resolve(data);

							return data;
						});
				})
				.fail(function() {
					self.errorCount++;
					self._updateErrorCount();
					deferred.resolve(null);
				});

			return deferred.promise();
		},
		_readEditNodeData: function(node, parentData) {
			var self = this;
			var deferred = $.Deferred();

			var linkUrl = utils.parseExpression(node.$editLink.$url, parentData, node.$editPrototype);
			linkUrl = linkUrl + "&nocache=true"; // Always force to not use the cache

			sdataDispatcher.dispatch({
				$url: linkUrl,
				$method: "GET"
			})
				.then(function(data) {
					deferred.resolve(data);
					return data;
				})
				.fail(function() {
					deferred.resolve(null);
				});
			return deferred.promise();
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/application/multiSelectionMgr',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/sdata/sdataUtils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/sdata/sdataDispatcher','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalSyncOffline'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var dispatcher = require('syracuse-tablet/html/js/sdata/sdataDispatcher');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalSyncOffline = require('syracuse-tablet/html/js/ui/modals/modalSyncOffline');

var _actionMenuId = "multiSelMenuActions";
var _selectedClass = "s-m-multi-selected";

var _templates = {
	buttonLinks: '\
		{{#each links}}\
			<a draggable="false"  href="#" class="s-m-link {{css}}" data-action="multiSelectionAction" data-params="{{$uuid}}" data-control-id="{{../ctrlId}}">\
				<i class="{{icon}}"/>\
				<span>{{{title}}}</>\
			</a>\
		{{/each}}',
	menuActions: '\
		<div id="{{id}}" class="btn-group s-m-link s-m-ismultisel">\
			<div class="{{dropDirection}}">\
				<button type="button" class="btn btn-primary dropdown-toggle" data-toggle="dropdown" aria-expanded="false">\
					<span class="badge"></span><span class="title">{{title}}</span><span class="caret"></span>\
				</button>\
				<ul class="dropdown-menu dropdown-menu-{{dropPosition}}" role="menu">\
					{{#each links}}\
						<li><a  {{#if style}}style="{{style}}"{{/if}} draggable="false"  data-action="multiSelectionAction" data-params="{{params}}" data-control-id="{{../ctrlId}}" href="#">{{title}}</a></li>\
					{{/each}}\
				</ul>\
			</div>\
		</div>',
	menuLinks: '\
		<div  class="btn-group s-m-ismultisel s-m-link">\
			<div class="{{dropDirection}}">\
				<button type="button" class="btn btn-primary dropdown-toggle" data-toggle="dropdown" aria-expanded="false">\
				{{title}}<span class="caret"></span>\
				</button>\
				<ul class="dropdown-menu dropdown-menu-{{dropPosition}}" role="menu">\
					{{#each links}}\
						<li>\
							<a draggable="false"  href="#" class="s-m-link {{css}}" data-action="multiSelectionAction" data-params="{{$uuid}}" data-control-id="{{../ctrlId}}">\
								{{title}}\
							</a>\
						</li>\
					{{/each}}\
				</ul>\
			</div>\
		</div>',
	processMenu: '\
		<a draggable="false"  href="#" class="s-m-link s-m-ismultisel" data-action="multiSelectionAction" data-params="$exitrun" data-control-id="{{ctrlId}}">\
			<i class="{{icon}}"/>\
		</a>'
};
var _actionsList = ["download", "unselectall", "selectall", "invert", "hideunselected", "showunselected"];

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	if (!tmpl) alert(locale.text("multiselect.gethtml.alert", name));
	return tmpl(ctx);
};

/**
 * Manages MultiSelection
 */
var _Klass = utils.defineClass(

	function(controller, cssToToggle) {
		this.controller = controller;
		this.cssToToggle = cssToToggle;
	}, null, {

		destroy: function() {
			// needed because the array that enabled multisel can be stil alive (multiselection in vignette)
			this.disable();
			this.controller = null;
			this._$$ownerParent = null;
			this._ctrlOwner = null;
		},
		getLinks: function() {
			if (this._multiSelLinks) return this._multiSelLinks;
			// there can be a null array in case multi select is only used for download action
			return this._multiSelLinks = this.controller.getMultiSelectionLinks() || [];
		},

		isEnabled: function() {
			return this._$$ownerParent != null;
		},
		disable: function() {
			if (this.isEnabled()) {
				this._stopMultiSel(this._getArray());
			}
		},
		_getArray: function() {
			var array = this.controller.getControlByBind("$resources");
			if (!array) throw new Error(locale.text("multiselect.getArray.error"));
			return array;
		},

		/**
		 * enable/disable multi-selection
		 * Called from footer or header
		 * dropPosition: Position of menu action (select)
		 */
		toggle: function(ctrlOwner, $$parent, dropDirection, dropPosition) {
			this._ctrlOwner = ctrlOwner;
			var array = this._getArray();
			if (this._$$ownerParent) {
				this._stopMultiSel(array);
			} else {
				this._startMultiSel($$parent, array, dropDirection, dropPosition);
			}
			return this._$$ownerParent != null;
		},
		/**
		 * Called from array
		 */
		callbackArray: function(ctrlArray, params, $target) {
			if (params == "$selectmultisel") {
				this._toggleSelectStatus(ctrlArray, $target.closest(".s-m-record"));
				return;
			}
			if (params == "$showdiagnoses") {
				this._showDiagnoses($target);
				return;
			}
			if (params == "$exitrun") {
				this._processExit(ctrlArray);
				return;
			}
			if (params == "$stopmultisel") {
				this._stopMultiSel(ctrlArray);
				return;
			}
			if (params == "$download") {
				this._startDownloadAction(ctrlArray);
				return;
			}
			if (params == "$unselectall" || params == "$reset") {
				this._toggleUnselected(ctrlArray, true);
				this._toggleSelectStatus(ctrlArray, this._$$Selected(ctrlArray), false);
				if (params == "$reset") {
					this._processExit(ctrlArray);
				}
				return;
			}
			if (params == "$selectall") {
				this._toggleUnselected(ctrlArray, true);
				this._toggleSelectStatus(ctrlArray, this._$$Unselected(ctrlArray), true);
				this._updateUI(ctrlArray, ctrlArray.getNbRecords());
				return;
			}
			if (params == "$invert") {
				var unSelected = this._$$Unselected(ctrlArray);
				var selected = this._$$Selected(ctrlArray);
				this._toggleSelectStatus(ctrlArray, unSelected, true);
				this._toggleSelectStatus(ctrlArray, selected, false);
				return;
			}
			if (params === "$hideunselected" || params === "$showunselected") {
				this._toggleUnselected(ctrlArray, params === "$showunselected");
				this._$$action("$hideunselected").toggle(params === "$showunselected");
				this._$$action("$showunselected").toggle(params === "$hideunselected");
				this._updateUI(ctrlArray, null);
				return;
			}
			/**
			 * EXECUTE ACTIONS - params is the id of the link
			 */
			if (this.nbSelected > 0) {
				var self = this;
				setTimeout(function() {
					self._processAll(ctrlArray, params);
				});
			}
		},
		_toggleSelectStatus: function(ctrlArray, elmtList, select) {
			var selected = elmtList.toggleClass(_selectedClass, select).hasClass(_selectedClass);
			if (ctrlArray.$display === "card") {
				var $$card = elmtList.find(".s-m-card");
				if (selected) {
					$$card.append('<span class="badge checked fa fa-check">&nbsp;</span>');
				} else {
					$$card.find(".badge.checked").remove();
				}
			}
			this._updateUI(ctrlArray, this._$$Selected(ctrlArray).length);
		},
		/**
		 * Show/Hide buttons in parent's owner (foorter/header...)
		 */
		_toggleOwnerActions: function(show) {
			var selector = "a:not(.s-m-ismultisel)";
			if (this.cssToToggle) {
				selector += ", " + this.cssToToggle;
			}
			this._$$ownerParent.closest(".s-m-control").find(selector).toggle(show);
		},
		_startMultiSel: function($$parent, array, dropDirection, dropPosition) {
			this._$$ownerParent = $$parent;
			this._$$ownerAction().addClass("enabled");
			array.multiSelSetMgr(this);
			$$parent.append(this._$$linksMenuHtml(array, dropDirection));
			$$parent.append(this._$$actionMenuHtml(array, dropDirection, dropPosition));
			// Hide all action other than multisel ones
			this._toggleOwnerActions(false);
			// Disable last selected line
			array.selectLastSelectedRow(null);
			// Disable status management if any
			array.toggleCardStatusColor(true);
			var self = this;
			// setTimeout otherwise $selectall is not shown
			setTimeout(function() {
				self._updateUI(array, 0);
			});
		},
		_stopMultiSel: function(array) {
			if (!this._$$ownerParent) return;
			this._processExit(array);
			array.multiSelSetMgr(null);
			this._toggleSelectStatus(array, this._$$Selected(array), false);
			this._$$ownerParent.find('.s-m-ismultisel.s-m-link:not([data-action="' + globals.ACTMULTISEL + '"])').remove();
			this._$$menu(_actionMenuId).remove();
			this._$$ownerAction().removeClass("enabled");
			// Enable status management if any
			array.toggleCardStatusColor(false);
			// Show all action other than multisel ones
			this._toggleOwnerActions(true);
			this._resizeArray(array);
			// If the multiselestion if not closed by header/footer (download)
			this._$$ownerParent.find('.s-m-ismultisel[data-action="' + globals.ACTMULTISEL + '"]').hide();
			// Used to disable the vignette if we exit download
			notifications.publish("sm.multisel.stopped", this.controller.id);
			if (this._ctrlOwner) {
				// Update header/Footer (header width)
				this._ctrlOwner.refresh();
			}
			this._$$ownerParent = null;
			this._ctrlOwner = null;
		},

		_$$linksMenuHtml: function(array, dropDirection) {
			var self = this;
			var links = this.getLinks();
			var menuLinks = [],
				footerHeaderLinks = [],
				settings;
			links.forEach(function(l) {
				settings = self.controller.actionGetSettings(l.name);
				if (settings.options == null || settings.options.footerHeader !== true) {
					menuLinks.push(l);
				} else {
					footerHeaderLinks.push(l);
				}
			});
			var html = [];
			if (menuLinks.length > 0) {
				html.push(_getHtml("menuLinks", {
					links: menuLinks,
					ctrlId: array.id,
					title: locale.text("actions"),
					dropDirection: dropDirection || "dropdown",
					dropPosition: "right"
				}));
			}
			if (footerHeaderLinks.length > 0) {
				html.push(_getHtml("buttonLinks", {
					links: footerHeaderLinks,
					ctrlId: array.id
				}));
			}
			return html.join('');
		},

		_$$actionMenuHtml: function(array, dropDirection, dropPosition) {
			var links = [];
			_actionsList.forEach(function(id) {
				links.push({
					title: locale.text("multiselect.action." + id),
					params: "$" + id,
					style: "display:none"
				});
			});
			return _getHtml("menuActions", {
				id: _actionMenuId,
				links: links,
				ctrlId: array.id,
				title: locale.text("multiselect.selected"),
				dropDirection: dropDirection || "dropdown",
				dropPosition: dropPosition || "right"
			});
		},

		_resizeArray: function(array) {
			/**
			 * To recalculate the scroller beacuse we hide/show cells
			 */
			array.onResize({
				scrollOnly: true
			});
		},
		_getSelectedData: function(array) {
			var selected = this._$$Selected(array);
			var data = [];
			selected.each(function(idx, record) {
				var $$record = $(record);
				// avoid click
				$$record.attr("data-disabled", "true");
				var rowId = $$record.attr("data-params");
				var rowdata = array.getRowById(rowId);
				if (rowdata) {
					data.push({
						rowData: rowdata.row,
						rowId: rowId,
						$$record: $$record,
						idx: idx,
						status: "init"
					});
				}
			});
			return data;
		},
		_processStart: function(array, uuid) {
			var deferred = $.Deferred();
			try {
				array.waitWheelStart();
				this._toggleUnselected(array, false);
				this._$$ownerParent.find(".s-m-ismultisel").hide();
				this._resizeArray(array);
				this._$$ownerParent.prepend(_getHtml("processMenu", {
					title: "Exit",
					ctrlId: array.id,
					icon: fontUtils.getIconByName("$cancelMultiSel")
				}));
				var data = this._getSelectedData(array);
				// reads link info
				var link = null;
				var self = this;
				this.getLinks().some(function(l) {
					if (l.$uuid === uuid) {
						link = l;
						return true;
					}
				});
				deferred.resolve(link, data);
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},
		_processAll: function(array, uuid) {
			var self = this;
			var _data;
			self._processStart(array, uuid).then(function(link, data) {
				_data = data;
				var deferred = $.Deferred();
				var _run = function(idx) {
					if (idx >= data.length) {
						deferred.resolve(link, data);
					} else {
						self._processOne(array, link, data[idx], idx).then(function(ok) {
							_run(idx + 1);
						});
					}
				};
				_run(0);
				return deferred.promise();
			}).then(function(link, data) {
				self._processEnd(data, array);
			}).fail(function(e) {
				globals.getModal().error(locale.text("multiselect.processAll.fail"), e, function() {
					self._processEnd(_data, array);
				});
			});
		},
		_toggleUnselected: function(array, show) {
			this._$$Unselected(array).toggle(show);
			if (array.$display == "card") {
				// Hide empty rows to remove the height of empty tr elements
				array.$$elmt.find("tr").each(function() {
					var e = $(this);
					e.toggle(show ? show : e.find("td").length != e.find("td.s-m-record:not(:visible)").length);
				});
			}
		},
		_processEnd: function(data, array) {
			var res = {
				ok: 0,
				ko: 0,
				init: 0
			};
			data.forEach(function(d) {
				res[d.status]++;
			});
			this._$$ownerParent.prepend('<span class="s-m-multiselmsg">' + res.ok + ' successes - ' + res.ko + ' failures</span>');
			this._resizeArray(array);
			array.waitWheelStop();
		},
		_processExit: function(array) {
			if (!this._$$ownerParent) return;
			// Clear status
			this._toggleUnselected(array, true);
			this._toggleSelectStatus(array, this._$$Selected(array), false);
			// Clear messages
			this._$$All(array).show().removeClass("error success").removeAttr("data-disabled");
			// Remove buttons in footer/header
			this._$$ownerParent.find('[data-params="$exitrun"], .s-m-multiselmsg').remove();
			this._$$ownerParent.find(".s-m-ismultisel").show();
			// Clear disgnoses attached to error records
			array.$$value.find(".s-m-multisel-diag").smRemoveData('diagnoses').remove();
			this._resizeArray(array);
		},
		_processOne: function(array, link, data, idx) {
			var self = this;
			var deferred = $.Deferred();
			var _end = function(success, result) {
				try {
					var diagsMsg = [],
						diagsErr = [];
					if ($.isPlainObject(result)) {
						var diags = sdataUtils.scanDiagnoses(result);
						if (diags) {
							diags.forEach(function(d) {
								if (d.$severity === "error") {
									diagsErr.push(d);
								} else {
									diagsMsg.push(d);
								}
							});
						}
					}
					success = success && diagsErr.length == 0;
					if (!success) {
						if (jsutils.isError(result)) {
							// console.log(JSON.stringify(result.stack, null, 2));
							data.$diagnoses = [{
								$message: result.message,
								$stackTrace: result.stack
							}];
						} else {
							data.$diagnoses = diagsErr;
						}
					} else {
						data.$diagnoses = diagsMsg;
						// console.log(JSON.stringify(result, null, 2));
					}
				} catch (e) {
					success = false;
					data.$diagnoses = [{
						$message: e.message,
						$stackTrace: e.stack
					}];
				} finally {
					data.status = success ? "ok" : "ko";
					data.$$record.addClass(success ? "success" : "error");
					self._addDiagnoses(array, data);
					deferred.resolve(success);
				}
			};
			try {
				if (link.$url) {
					var sdataUrl;
					if (data && data.rowData) {
						var urlTmp = data.rowData.parseExpression(link.$url);
						// PARAMETER_ESCAPING
						// Url may contain escaped placeholders the need to be replaced by actual values
						// (see pageRegular.js -> PARAMETER_ESCAPING)
						link.$parameters && $.each(link.$parameters, function(paramName, paramValue) {
							if (paramValue.indexOf("{") > -1) {
								var pv2 = encodeURIComponent(paramValue);
								var finalValue = encodeURIComponent(data.rowData.parseExpression(paramValue));
								urlTmp = urlTmp.replace(pv2, finalValue);
							}
						});
						sdataUrl = urlTmp;
					} else {
						sdataUrl = data && data.rowData ? data.rowData.parseExpression(link.$url) : link.sDataUrl;
					}
					var payload = data && data.rowData ? data.rowData.getActionPayload(link, self.controller.isEditMode()) : null;
					dispatcher.dispatch({
						$url: sdataUrl,
						$method: link.$method || "GET"
					}, payload).then(function(data) {
						_end(true, data);
					}).fail(function(e) {
						_end(false, e);
					});
				} else {
					_end(true);
				}
			} catch (e) {
				_end(false, e);
			} finally {
				return deferred.promise();
			}
		},
		_addDiagnoses: function(array, data) {
			var $$root = null,
				colSpan, $$diag, isTable = array.getMode() === "table";
			if (isTable) {
				colSpan = data.$$record.children('td').length;
			} else {
				$$root = $('<section data-action="multiSelectionAction" data-params="$showdiagnoses"/>').addClass("s-m-multisel-diag").prependTo(data.$$record);
				$$root.width(data.$$record.width());
				$$root.smData('diagnoses', data.$diagnoses);
			}
			data.$diagnoses.forEach(function(d, idx) {
				$$diag = $('<div data-idx="' + idx + '" class="alert alert-' + (d.$severity === "error" ? "danger" : "success") + '" role="alert">' + d.$message + '</div>');
				if (isTable) {
					$$root = $('<tr  data-action="multiSelectionAction"  data-params="$showdiagnoses"><td colspan="' + colSpan + '"/></tr>').addClass("s-m-multisel-diag");
					$$root.smData('diagnoses', data.$diagnoses);
					data.$$record.after($$root);
					$$root = $$root.children()[0];
				}
				$$diag.appendTo($$root);
			});
		},
		_showDiagnoses: function($$elmt) {
			$$elmt = $$elmt.closest(".s-m-multisel-diag");
			var diags = $$elmt.smData('diagnoses');
			if (diags == null || diags.length == 0) return;
			globals.getModal().error("", {
				$diagnoses: diags
			});
		},
		_$$ownerAction: function() {
			return this._$$ownerParent.find('[data-action="' + globals.ACTMULTISEL + '"]');
		},
		_$$Unselected: function(array) {
			return array.$$value.find(".s-m-record:not(." + _selectedClass + ")");
		},
		_$$Selected: function(array) {
			return array.$$value.find(".s-m-record." + _selectedClass);
		},
		_$$All: function(array) {
			return array.$$value.find(".s-m-record");
		},
		_$$action: function(id) {
			return this._$$ownerParent.find('[data-params="' + id + '"]');
		},
		_$$menu: function(id) {
			return this._$$ownerParent.find("#" + id);
		},
		_updateUI: function(array, nb) {
			if (!this._$$ownerParent) return;
			if (nb != null) {
				this.nbSelected = Math.max(0, nb);
				var $$e = this._$$menu(_actionMenuId);
				$$e.find(".badge").text(this.nbSelected);
				$$e.find(".title").text(locale.text(this.nbSelected > 1 ? "multiselect.selected.plural" : "multiselect.selected"));
			}
			var noSel = this.nbSelected == 0;
			var allSel = this.nbSelected === array.getNbRecords();
			this._$$ownerParent.find('.s-m-ismultisel.s-m-link:not([data-action="' + globals.ACTMULTISEL + '"])').toggleClass("disabled", noSel);
			if (noSel || allSel) {
				this._$$action("$hideunselected").hide();
				this._$$action("$showunselected").hide();
			} else if (this.nbSelected > 0 && !this._$$action("$showunselected").is(":visible")) {
				this._$$action("$hideunselected").show();
			}
			this._$$action("$unselectall").toggle(this.nbSelected > 0);
			this._$$action("$selectall").toggle(true);
			this._$$action("$invert").toggle(this.nbSelected > 0);
			this._$$action("$download").toggle(this.nbSelected > 0);
		},
		_startDownloadAction: function(ctrlArray) {
			var self = this;

			var data = self._getSelectedData(ctrlArray);
			var pageProto = ctrlArray.prototype;
			while (pageProto.parent) {
				pageProto = pageProto.parent;
			}
			var syncRootData = {
				pageProto: pageProto,
				rowsData: []
			};
			data.forEach(function(rowData) {
				syncRootData.rowsData.push(rowData);
			});

			var modal = new modalSyncOffline.Modal(syncRootData);
			modal.show().then(function(result) {
				if (result === "done") {
					self._stopMultiSel(ctrlArray);
				}
			});
		}
	});


exports.create = function(controller, cssToToggle) {
	if (!controller.isMultiSelectionEnabled()) return null;
	return new _Klass(controller, cssToToggle);
};
});

define('syracuse-tablet/html/js/controls/ctrlHelpers',['require','exports','module','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {"use strict";
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _toggleAttr = function($$e, attr, toggle) {
	if (!$$e) return;
	$$e.toggleClass('disabled', toggle);
	if ($$e.is('[' + attr + ']')) {
		if (toggle === true) return $$e;
		return $$e.removeAttr(attr);
	} else {
		if (toggle === false) return $$e.removeAttr(attr);
		return $$e.attr(attr, '');
	}
};
/**
 * Adds the count info to the 'List of drafts' menu
 */
var _notifDraftsChanged = function(ctrl, count) {
	if (!ctrl || !ctrl.$$elmt) return;
	var $$e = ctrl.$$elmt.find('[data-nav="pageDrafts"]');
	_toggleAttr($$e, 'data-disabled', count <= 0);
	$$e = $$e.find(".isLabel");
	var $b = $$e.find("span.badge");
	if ($b.length === 0) {
		$b = $('<span class="badge"/>').appendTo($$e);
	}
	$b.text(count);
};
/**
 * Update save button when dao status changes dirty/not dirty
 */
var _notifDaoDirty = function(ctrl, isDirty, uuid) {
	if (!ctrl || !ctrl.$$elmt || !ctrl._saveLinkId) return;
	var actController = ctrl.getActionController();
	if (!actController.isEditMode() || actController.dao.data.$uuid != uuid) return;
	var $$e = ctrl.$$elmt.find('[data-params="' + ctrl._saveLinkId + '"]');
	if ($$e && $$e.length > 0) {
		$$e.toggleClass("disabled", isDirty !== true);
	}
};
/**
 * Update editTemplates button when templates has been created/removed
 * Called also by footer/header on sm.edit.templates.changed
 */
var _notifEditTemplatesChanged = function(ctrl, count) {
	if (!ctrl || !ctrl.$$elmt || !ctrl._showtemplatesId) return;
	var actController = ctrl.getActionController();
	if (!actController.isEditMode()) return;
	var $$e = ctrl.$$elmt.find('[data-params="' + ctrl._showtemplatesId + '"]');
	if ($$e && $$e.length > 0) {
		if ($$e.is(".disabled")) {
			$$e.removeClass("disabled");
		}
		$$e = $$e.children("i");
		$$e.removeClass(fontUtils.getIconByName(count === 0 ? "$showtemplates" : "$showtemplatesEmpty"));
		$$e.addClass(fontUtils.getIconByName(count === 0 ? "$showtemplatesEmpty" : "$showtemplates"));
	}
};
/**
 * Add control subscription according to the link
 * Ex: dirty dao, templates changed....
 */
var _checkLinkSubscriptions = function(control, link) {
	// the controller of action (controller of embedded page for a vignette's footer)
	var actController = control.getActionController();
	if (!actController || !actController.isEditMode()) return;
	// we save the link id to retrieve the dom elmt - see _notifDaoDirty
	if (link.name === "$save") {
		control._saveLinkId = link.$uuid;
		link.$isDisabled = true;
		notifications.subscribe(control, ["sm.dao.dirty"]);
		return;
	}
	if (link.name === "$showtemplates") {
		control._showtemplatesId = link.$uuid;
		link.$isDisabled = true;
		notifications.subscribe(control, ["sm.edit.templates.changed"]);
		return;
	}
};
/**
 * Update the status of save/showTemplates button after having built the footer/header
 * The notification sm.dao.dirty occurs before the creation of the control so we need to check the status in build method
 */
var _checkLinkInitStatus = function(ctrl) {
	var actController = ctrl ? ctrl.getActionController() : null;
	if (!actController || !actController.getLinksInitStatus || !actController.isEditMode()) return;
	// The status is given by the controller
	actController.getLinksInitStatus().then(function(data) {
		if (!data) return;
		if (data.dirtyDao != null) {
			// Asks the controller to know if we can enable save button 
			_notifDaoDirty(ctrl, data.dirtyDao.isDirty, data.dirtyDao.$uuid);
		}
		if (data.editTemplates !== null) {
			// Asks the controller to know if we can enable save button 
			_notifEditTemplatesChanged(ctrl, data.editTemplates.count);
		}
	});
};
exports.notifEditTemplatesChanged = _notifEditTemplatesChanged;
exports.checkLinkSubscriptions = _checkLinkSubscriptions;
exports.checkLinkInitStatus = _checkLinkInitStatus;
exports.notifDaoDirty = _notifDaoDirty;
exports.notifDraftsChanged = _notifDraftsChanged;
exports.toggleAttr = _toggleAttr;
});

define('syracuse-tablet/html/js/controls/page/ctrlHeaderBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/uiSettings','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/application/eventListener','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/application/actionManager','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/application/multiSelectionMgr','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/controls/ctrlHelpers','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var globals = require('syracuse-tablet/html/js/helpers/globals');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var prototype = require('syracuse-tablet/html/js/helpers/prototype');
var actionManager = require('syracuse-tablet/html/js/application/actionManager');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var multiSelectionMgr = require('syracuse-tablet/html/js/application/multiSelectionMgr');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var native = require('syracuse-tablet/html/js/helpers/native/native');
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var ctrlHelpers = require('syracuse-tablet/html/js/controls/ctrlHelpers');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var _userPanelId = globals.PANELUSERSMARTPHONE;
var _actionPanelId = globals.PANELACTIONSREGULAR;

var _templates = {
	main: '\
		<div class="s-m-header {{deviceType}}">\
			{{{contentHtml}}}\
		</div>',
	freshness: '\
		<div class="s-m-freshness s-m-fresh" data-action="showFreshness" data-control-id="{{ctrlId}}">\
			<i class="' + fontUtils.pageIcon("freshness") + '"></i>\
		</div>',
	tablet: {
		main: '\
			<div class="s-m-header-nav">\
				{{#if showBack}} \
					<a href="#" draggable="false" data-action="historyBack">\
						<i class="' + fontUtils.pageIcon("back") + '" />\
						</a>\
				{{/if}} \
			</div>\
			<div class="s-m-header-labels">\
				{{#if showBrand}}\
					<div class="s-m-header-brand">\
						<span class="s-m-brand">{{labelBrand}}</span>\
						<span class="s-m-product">{{labelProduct}}</span>\
					</div>\
				{{/if}}\
				<span class="s-m-header-label">{{headerLabel}}</span>\
			</div>\
			<div class="s-m-header-links">\
				{{{userContent}}}\
			</div>',
		userInfo: '\
			<div>\
				<span class="s-m-nav-text username">{{username}}</span>\
				<span class="s-m-nav-text userrole">{{userrole}}</span>\
			</div>\
			<span class="usericon ' + fontUtils.pageIcon("switchContext") + '" />\
			',
		infoOnly: '\
			<div>{{{userInfo}}}</div>',
		dropDown: '\
			<div class="s-m-header-user-info dropdown">\
				<a href="#" draggable="false" data-toggle="dropdown" role="button" id="{{dropdownId}}" aria-haspopup="true" aria-expanded="false">\
					{{{userInfo}}}\
				</a>\
				{{{dropDownMenu}}}\
			</div>',
		dropDownMenu: '\
			<ul class="dropdown-menu dropdown-menu-right" role="menu" aria-labelledby="{{dropdownId}}">\
				{{#each links}}\
					{{#if dividerTop}} \
						<li role="presentation" class="divider"></li>\
					{{/if}} \
					<li>\
						<a href="#" {{#if data-nav}}data-nav="{{data-nav}}"{{else}}data-action="linkClicked"{{/if}}draggable="false" data-params="{{data-params}}" data-control-id="{{ctrlId}}" class="list-group-item {{css}}">\
							<span class="{{icon}}" />\
							<span class="isLabel">{{label}}</span>\
						</a>\
					</li>\
					{{#if dividerBottom}} \
						<li role="presentation" class="divider"></li>\
					{{/if}} \
				{{/each}}\
			</ul>'
	},
	smartphone: {
		main: '\
			<div class="s-m-header-nav">\
				{{#if showUserpanel}}\
					<a href="#" draggable="false" data-action="headerAction" data-params="{{panelId}}" data-control-id="{{ctrlId}}">\
						<span class="' + fontUtils.pageIcon("bars") + '" />\
					</a>\
				{{/if}}\
			</div>\
			<div class="s-m-header-labels">\
				{{{labelContent}}}\
			</div>\
			<div class="s-m-header-links">\
				{{{linksContent}}}\
			</div>',
		brandDom: '\
			<div class="s-m-header-brand">\
				<span class="s-m-brand">{{labelBrand}}</span>\
				<span class="s-m-product">{{labelProduct}}</span>\
			</div>',
		labelDom: '\
			<span class="s-m-header-label">{{label}}</span>',
		actionLink: '\
			<a href="#" draggable="false" class="s-m-link {{css}}{{#if $isDisabled}} disabled{{/if}}"\
				{{#if $isHidden}}style="display:none"{{/if}}\
				data-action="{{#if action}}{{action}}{{else}}headerLink{{/if}}"\
				data-params="{{$uuid}}"\
				{{#if x3LinkName}} data-s-ut-link-x3name="{{x3LinkName}}"{{/if}}\
				data-control-id="{{ctrlId}}">\
				<i class="{{icon}}"></i>\
			</a>',
		actionPanelToggle: '\
			<a href="#" class="s-m-link" \
			data-action="headerAction" \
			draggable="false" \
			data-params="{{panelId}}" \
			data-s-ut-x3-link-name="$$openRightPanel" \
			data-control-id="{{ctrlId}}">\
				<i class="' + fontUtils.pageIcon("sidePanelR") + '" />\
				<span>{{{title}}}</span>\
			</a>'
	}
};

var _linksCtx = {
	showAuthoring: {
		"dividerBottom": true,
		items: [{
			"data-params": "designPage",
			"icon": "designPage",
			"label": "header.links.designPage"
		}]
	},
	showPageMailto: {
		items: [{
			"data-params": "pageMailto",
			"icon": "mailto",
			"label": "header.links.page.mailto"
		}]
	},
	showPageShare: {
		items: [{
			"data-params": "pageShare",
			"icon": "nativeShare",
			"label": "header.links.page.share"
		}]
	},
	showUserMenuLinks: {
		items: [{
			"data-params": "switchContext",
			"icon": "switchContext",
			"label": "header.links.switchContext"
		}, {
			"data-params": "settings",
			"icon": "settings",
			"label": "header.links.settings"
		}, {
			"data-params": "about",
			"icon": "about",
			"label": "header.sm.links.about"
		}]
	},
	showDevelopment: {
		"dividerTop": true,
		items: [{
			"data-params": "developmentPage",
			"icon": "developmentPage",
			"label": "header.links.development"
		}]
	},
	showDrafts: {
		"dividerTop": true,
		items: [{
			"data-nav": "pageDrafts",
			"icon": "drafts",
			"label": "header.links.page.drafts"
		}]
	}
};

var _getHtml = function(type, name, ctx) {
	type = type || "";
	var key = type + name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = type.length == 0 ? _templates[name] : _templates[type][name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};

var _hideSoftwareBackButton;
var _mustHideSoftwareBackButton = function() {
	if (_hideSoftwareBackButton != null) {
		return _hideSoftwareBackButton;
	}
	_hideSoftwareBackButton = native.hasCapability("hardwareBackButton");
};

/**
 * Page header Generate Html
 */
var _Klass = utils.defineClass(

	function CtrlHeaderBase($type, controller, options) {
		Base.call(this, controller, {
			$bind: "header"
		}, prototype.create({
			$type: $type
		}), options);
		if (options.freshness !== false) {
			notifications.subscribe(this, ["sm.data.freshness.change"]);
		}
	}, Base, {

		destroy: function() {
			this.resetSmartphonePanels();
			if (this._actionManager) {
				this._actionManager.destroy();
				this._actionManager = null;
			}
			if (this._multiSelManager) {
				this._multiSelManager.destroy();
				this._multiSelManager = null;
			}
			// end
			this._dataFreshness = null;
			this._$$freshness = null;
			Base.prototype.destroy.call(this);
		},
		/**
		 * Use refresh to update the width from outside the component
		 */
		refresh: function(controllerDao, options) {
			Base.prototype.refresh.call(this, controllerDao, options);
			this._updateWidth();

		},
		getPageControlType: function() {
			return "header";
		},
		resetSmartphonePanels: function() {
			if (this.controller) {
				// Detach the panels from main page - Used by vignette header for smartphone
				this.controller.panelDetach("right");
				this.controller.panelDetach("left");
			}
			if (this._smphUserpanel) {
				this._smphUserpanel.destroy();
				this._smphUserpanel = null;
			}
			if (this._smphPageactionpanel) {
				this._smphPageactionpanel.destroy();
				this._smphPageactionpanel = null;
			}
		},
		buildHtml: function($$parent, controllerDao, buildOptions) {
			buildOptions = buildOptions || {};
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions, [this.typeName]);
			this.headerOptions = this.getHeaderOptions(buildOptions);
			// Build the header with default deviceType - To avoid flickering of the page - Improvement is done in onMainPageResize
			if (buildOptions.refresh === true || this.headerOptions.forceRefresh) {
				// Avoid double build
				// If it's not a refresh build is called on onResize - there's always a triggerResize when we rendre a page
				this._build();
			}
		},

		// Can be overridden
		getHeaderOptions: function(buildOptions) {
			var opts = $.extend({}, buildOptions.footer, buildOptions.toolBars);
			opts.showDevelopment = globals.isDevelopmentModeAllowed();
			opts.showAuthoring = globals.isAuthoringModeAllowed() && opts.showAuthoring === true;
			// Show full feature authoring only if on PC
			return opts;
		},
		applyMetaData: function(metaData, buildOptions) {
			//  No meta for this control 
			return;
		},
		onMainPageResize: function(info, orientation) {
			// In any case because we need to have the content width	
			this.$$elmt.parent().css({
				width: info.contentWidth + "px"
			});
			this._build();
			// In any case because we need to have the width tho calculate text-overflow elipsis
			this._updateHeaderStyle(this._deviceType);
		},
		/**
		 *	Update some header css properties.
		 */
		_updateHeaderStyle: function(deviceType) {
			return;
			// tablet
			// calculate and set s-m-header-labels div width according
			// to widths of s-m-header-nav and s-m-header-links div elements.
			var self = this;
			var $$header = self.$$elmt.find(".s-m-header");
			var $$links = self.$$elmt.find(".s-m-header-links");
			var $$nav = self.$$elmt.find(".s-m-header-nav");
			var $$label = self.$$elmt.find(".s-m-header-label");
			var offset = 10;
			if (deviceType === "tablet") {

				// for pages other than welcome page, update label width
				if (!self.controller.state.isWelcomePage) {
					var maxWidth = $$header.width() - ($$nav[0].scrollWidth + $$links[0].scrollWidth + offset);
					$$label.css("max-width", maxWidth);
				}
				// on welcome page, if header is too small, label will be hidden for a better display
				else {
					$$label.css("max-width", "inherit");
					var $$brand = self.$$elmt.find(".s-m-header-brand");

					// hide label if brand + label + links > header (in term of width)
					var hideLabel = $$brand.width() + $$label.width() + $$nav.width() + $$links.width() + offset > $$header.width();
					$$label.toggle(hideLabel ? false : true);

					// if label hidden and header still too small, reduce brand fontsize until header has better display
					var sum = $$brand.width() + $$nav.width() + $$links.width();
					var off = 3;
					if (hideLabel == true && (sum > $$header.width())) {
						while (sum > $$header.width()) {
							$$brand.css("font-size", ($$brand.css("font-size").match(/\d+/)[0] - off) + "px");
							off += 3;
							sum = $$brand.width() + $$nav.width() + $$links.width();
						}
					} else {
						$$brand.css("font-size", "2.5em");
					}

				}
			}
			// smartphone
			else {
				// only not on welcome page
				if (!self.controller.state.isWelcomePage) {
					var maxWidth = $$header.width() - ($$nav[0].scrollWidth + $$links[0].scrollWidth + offset);
					$$label.css("max-width", maxWidth);
				}
			};
		},
		getHeight: function() {
			return this.$$elmt.is(":visible") ? this._height : 0;
		},
		/**
		 * Update width for cells other than s-m-header-labels in order to manage long titles
		 * s-m-header-labels is set to with auto and will fit into the remaining space - Text will be truncated
		 */
		_updateWidth: function() {
			if (!this.$$header || this.destroyed) return;
			var freshVisible = this._$$freshness && this._$$freshness.is(":visible");
			if (freshVisible) {
				// We need to hide _$$freshness to calculate the width
				// _$$freshness is positioned in absolute and is dispayed over the header
				this._$$freshness.hide();
			}
			var $$label, width, $$nav;
			var maxWidth = this.$$elmt.width();
			var fullWidth = 0;
			this.$$header.children().each(function() {
				$$nav = $(this);
				if (!$$nav.is(".s-m-header-labels")) {
					width = 0;
					$$nav.children().each(function(idx) {
						width += $(this).outerWidth() + 1;
					});
					if ((fullWidth + width) > maxWidth) {
						width = Math.max(maxWidth - fullWidth, 0);
					}
					fullWidth += width;
					$$nav.width(width);
				} else {
					$$label = $$nav;
				}
			});
			$$label.width("auto");
			if (freshVisible) {
				this._$$freshness.show();
			}
		},
		/**
		 * Allows to build header in build html (better UX)
		 */
		_build: function() {
			var deviceType = globals.getSiteLayout().getDeviceType();
			if (this._deviceType != null && this._deviceType === deviceType) {
				this._updateWidth();
				return;
			}
			if (this._multiSelManager) {
				this._multiSelManager.destroy();
				this._multiSelManager = null;
			}
			if (this._actionManager) {
				this._actionManager.destroy();
				this._actionManager = null;
			}
			this._deviceType = deviceType;
			this._height = uiSettings.getProp("header.height");
			this.$$elmt.css({
				height: this._height + "px"
			});
			/*this.$$elmt.height(h);*/
			var $$parent = this.$$elmt.parent();
			$$parent.css({
				left: 0 + "px",
				height: this._height + "px"
			});
			var opts = this.headerOptions;
			var labels = locale.getProductLabels();
			opts.labelBrand = labels.brand;
			opts.labelProduct = labels.product;
			// Controller that handle action - different from current page for vignettes
			var actionController = this.getActionController();
			// Controller that displays the footer
			var displayController = this.controller;
			var contentHtml;
			if (deviceType === "smartphone") {
				contentHtml = this._smartPhoneHtml(opts, displayController, actionController);
				// 'Lisft of draft' menu is managed by left panel
				notifications.unsubscribe(this, "sm.drafts.changed");
			} else {
				contentHtml = this._tabletHtml(opts, displayController, actionController);
				// 'Lisft of draft' menu is managed by this control (user menu)
				notifications.subscribe(this, "sm.drafts.changed");
			}
			if (this.$$header) this.$$header.remove();
			this.$$header = $(_getHtml(null, "main", {
				contentHtml: contentHtml,
				deviceType: deviceType
			}));
			if (native && native.isTestMode()) {
				native.appendHeaderTestCmds(this.$$header.find(".s-m-header-nav"));
			}
			this.$$header.appendTo(this.$$elmt);
			var freshWasVisible = false;
			if (this._$$freshness) {
				// When we switch from tablet to smartphone we've to preserve the status of _$$freshness 
				freshWasVisible = this._$$freshness.is(":visible");
				this._$$freshness.remove();
			}
			if (this.options.freshness !== false) {
				this._$$freshness = $(_getHtml(null, "freshness", {
					ctrlId: this.id
				})).appendTo(this.$$elmt).toggle(freshWasVisible);
			}
			// Check if dao dirty to update save satus
			ctrlHelpers.checkLinkInitStatus(this);
			this._updateWidth();
		},
		/**
		 * Controller that handles actions
		 * For actions in dashboard this controller is the page nested in the vignette
		 * Can be overridden
		 */
		getActionController: function() {
			return this.controller;
		},

		/**
		 * Returns HTML for tablet
		 */
		_tabletHtml: function() {
			var self = this;
			var lknCtx = {
				dropdownId: utils.UUID(),
				links: []
			};
			var opts = self.headerOptions;
			var linksCpt = 0;
			for (var p in _linksCtx) {
				if (opts[p] === true) {
					var l = _linksCtx[p];
					l.items.forEach(function(x, idx) {
						x = $.extend({}, x);
						x.label = locale.text(x.label);
						x.ctrlId = self.id;
						x.icon = fontUtils.pageIcon(x.icon);
						if (idx === 0 && lknCtx.links.length > 1) x.dividerTop = l.dividerTop;
						x.dividerBottom = l.dividerBottom;
						lknCtx.links.push(x);
					});
				}
			}
			// showBack force show back
			var _mainCtx = {
				showBack: (_mustHideSoftwareBackButton() === false) ? (opts.showHome || opts.showBack === true) : false,
				showHome: opts.showHome,
				showBrand: self.controller.state.isWelcomePage,
				labelBrand: opts.labelBrand || "Sage",
				labelProduct: opts.labelProduct || "ERP X3",
				headerLabel: self.getProtoTitle(),
				ctrlId: self.id
			};
			var htmlUserInfo = _getHtml("tablet", "userInfo", {
				username: globals.getUserName(),
				userrole: globals.getUserRole()
			});
			if (lknCtx.links.length === 0) {
				_mainCtx.userContent = _getHtml("tablet", "infoOnly", {
					userInfo: htmlUserInfo
				});
			} else {
				_mainCtx.userContent = _getHtml("tablet", "dropDown", {
					userInfo: htmlUserInfo,
					dropDownMenu: _getHtml("tablet", "dropDownMenu", lknCtx)
				});
				/** Force overflow visible on s-m-control to display the dropDownMenu**/
				self.$$elmt.css({
					overflow: "visible"
				});
			}
			return _getHtml("tablet", "main", _mainCtx);
		},
		/**
		 * Returns HTML for smartphone
		 */
		_smartPhoneHtml: function(opts, displayController, actionController) {
			var self = this;
			this.resetSmartphonePanels();
			if (opts.showUserpanel) {
				// actionController that handles actions
				self._smphUserpanel = actionController.panelCreate(_userPanelId, opts);
			}
			var showActions = opts.showActions !== false;
			if (showActions && opts.showActionpanel) {
				// actionController that handles actions
				self._smphPageactionpanel = actionController.panelCreate(_actionPanelId, opts);
			}
			var labelContent = "";
			var linksContent = "";
			// build label content. 
			labelContent = self._getLabelContent(opts);
			// build links content.
			var hasPanelLinks = self._smphPageactionpanel && self._smphPageactionpanel.hasLinks();
			linksContent = self._getSmartphoneLinksContent(displayController, actionController, hasPanelLinks, showActions);
			var ctx = {
				labelContent: labelContent,
				linksContent: linksContent,
				panelId: _userPanelId,
				ctrlId: self.id,
				showUserpanel: opts.showUserpanel === true
			};
			return _getHtml("smartphone", "main", ctx);
		},
		/**
		 *	/!\ SMARTPHONE ONLY
		 *	Returns header label content which depends on the current page.
		 *	Label depends whether user is located in home page, app dashboard page, inside an app, or anywhere else
		 */
		_getLabelContent: function(opts) {
			var self = this;
			var labelContent;

			function getContent(isLabelDom, labelVal, opts) {
				if (isLabelDom) {
					return _getHtml("smartphone", "labelDom", {
						label: labelVal
					});
				}
				// brand name
				else {
					return _getHtml("smartphone", "brandDom", {
						labelBrand: opts.labelBrand || "Sage",
						labelProduct: opts.labelProduct || "ERP X3",
					});
				}
			}

			// home page --> brand name
			if (this.controller.state.isWelcomePage) {
				labelContent = getContent(false, null, opts);
			} else {
				// app dashboard page --> app title
				labelContent = getContent(true, self.getProtoTitle());
				if (!labelContent) {
					// other cases (for example html static page)
					labelContent = getContent(false, null, opts);
				}
			}
			return labelContent;
		},
		getProtoTitle: function() {
			return this.controller.prototype.data("$title");
		},
		/**
		 *	/!\ SMARTPHONE ONLY
		 *	Returns header links content which depends on the current page.
		 *	- No link on welcome page and application dashboard
		 *	- On query page, links will be "create" and an anchor to open the actions panel (on the right)
		 *	- On detail page, links will be "edit" and an anchor to open the actions panel (on the right)
		 *	- On edit page, links will be "save", "cancel" and an anchor to open the actions panel (on the right)
		 *	Some actions will be displayed in the footer
		 */
		_getSmartphoneLinksContent: function(displayController, actionController, hasPanelLinks, showActions) {
			var self = this;
			var linksContent = "";
			self._multiSelManager = multiSelectionMgr.create(actionController, ".s-m-header-nav, .s-m-header-labels, a:not(.s-m-ismultisel)");
			notifications.subscribe(self, ["sm.panel.multiselection.toggle"]);
			self._actionManager = actionManager.create(actionController, "header", {
				addCancelEditAction: "headerLink",
				addShowTemplatesAction: "headerLink",
				addMultiSelection: self._multiSelManager && !self.headerOptions.multiSelectionOnly && actionController.isMultiSelectionEnabled(),
				multiSelectionOnly: self.headerOptions.multiSelectionOnly
			});
			var linksArr = self._actionManager.getLinks();
			var cc = [];
			if (hasPanelLinks) {
				cc.push(_getHtml("smartphone", "actionPanelToggle", {
					panelId: _actionPanelId,
					ctrlId: self.id
				}));
			}
			if (showActions && linksArr && linksArr.length > 0) {
				linksArr.forEach(function(ll, idx) {
					cc.push(_getHtml("smartphone", "actionLink", $.extend(ll, {
						ctrlId: self.id,
						$isHidden: ll.action === globals.ACTMULTISEL || ll.$isHidden === true
					})));
					ctrlHelpers.checkLinkSubscriptions(self, ll);
				});
			}
			linksContent = cc.join("");
			return linksContent;
		},
		_actHeaderLink: function(uuid) {
			this._actionManager.triggerLink(uuid, this.getActionController()).then(function(success, link, data, options) {
				// Message is displayed 
			}).fail(function(e) {
				if (jsutils.isError(e)) {
					// We shouldn't expect an error except exceptions
					globals.getModal().error("Header action error (smartphone)", e);
				}
			});
		},
		_actHeaderAction: function(id) {
			var panel = id === _actionPanelId ? this._smphPageactionpanel : this._smphUserpanel;
			var side = id === _actionPanelId ? "right" : "left";
			this.controller.panelAttach(side, panel, "toggle");
		},
		_actLinkClicked: function(actionName) { /* triggering action */
			eventListener.triggerAction(this.$$elmt, actionName);
		},

		notifPanelMultiselectionToggle: function(uuid, $$target) {
			this.toggleMultiSelection();
		},

		toggleMultiSelection: function() {
			this._actMultiSelection();
		},

		_actMultiSelection: function(uuid, $$target) {
			var $$hLinks = this.$$elmt.find(".s-m-header-links");
			var enabled = this._multiSelManager.toggle(this, $$hLinks, "dropdown", "left");
			$$hLinks.width(enabled ? "100%" : "initial");
			this.$$elmt.find(".s-m-header-nav, .s-m-header-labels, a:not(.s-m-ismultisel)").toggle(!enabled);
			this.$$elmt.find('[data-action="' + globals.ACTMULTISEL + '"]').toggle(enabled);
			this._updateWidth();
		},

		/**
		 * Page footer can be changed
		 * This method is called each time the header is toggled
		 */
		notifToggled: function(shown) {
			if (shown === false) {
				if (this._multiSelManager) {
					this._multiSelManager.disable();
				}
				this._updateWidth();
				return;
			}
			this._updateWidth();
		},
		notifDataFreshnessChange: function(data) {
			this._dataFreshness = this._dataFreshness || {
				oldest: data.dateTime,
				recent: 0
			};
			/**
			 * Solve the case of vignette in dashboard - select the oldes data
			 */
			this._dataFreshness.oldest = Math.min(this._dataFreshness.oldest, data.dateTime);
			this._dataFreshness.recent = Math.max(this._dataFreshness.recent, data.dateTime);
			if (!this._$$freshness) return;
			var diffDays = Math.round((new Date().getTime() - this._dataFreshness.oldest) / (24 * 60 * 60 * 1000));
			var freshness = "verytainted";
			if (diffDays <= 7) freshness = "tainted";
			if (diffDays <= 1) freshness = "fresh";
			this._dataFreshness.value = freshness;
			this._$$freshness.removeClass("s-m-fresh s-m-tainted s-m-verytainted");
			this._$$freshness.addClass("s-m-" + freshness);
			this._$$freshness.show();
		},
		/**
		 * Displays freshness info
		 */
		_actShowFreshness: function() {
			if (!this._dataFreshness) return;
			var formatter = formatApi.getFormatter("application/x-datetime");
			var dateTime = formatter.formatValue(utils.getCurISODateTime(new Date(this._dataFreshness.oldest)), false);
			var notify = {
				severityClass: this._dataFreshness.value,
				title: locale.text("page.data.freshness.last") + " : " + dateTime,
				body: locale.text("page.data.freshness." + this._dataFreshness.value),
				onlyWebapp: true
			};
			globals.getModal().notify(notify);
		},
		/**
		 * Detach from document
		 */
		detach: function() {
			this.notifToggled(false);
			if (this.$$elmt) {
				this.$$elmt.detach();
			}
		},
		/**
		 * Manage the count info in 'List of draft' menu
		 */
		notifDraftsChanged: function(count) {
			ctrlHelpers.notifDraftsChanged(this, count);
		},
		/**
		 * Toggle $save status
		 */
		notifDaoDirty: function(isDirty, uuid) {
			ctrlHelpers.notifDaoDirty(this, isDirty, uuid);
		},
		/**
		 * Toggle $$showTemplates status
		 */
		notifEditTemplatesChanged: function(fromActionMgrUUID, count) {
			// Event is triggered by templaetPanel for all suscribers but only one can handle it
			// -> The one thas contains the actionManager taht trigered the link 
			if (!this._actionManager || this._actionManager.uuid != fromActionMgrUUID) return;
			ctrlHelpers.notifEditTemplatesChanged(this, count);
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/ctrlPageHeader',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/page/ctrlHeaderBase'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/page/ctrlHeaderBase').Klass;
/**
 * Page main header
 */
var _Klass = utils.defineClass(

	function CtrlPageHeader($type, controller, options) {
		Base.call(this, $type, controller, options);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
		},

		getHeaderOptions: function(buildOptions, device) {
			var stdOpts = Base.prototype.getHeaderOptions.call(this, buildOptions);
			stdOpts.showUserpanel = true;
			stdOpts.showActionpanel = true;
			return stdOpts;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/ctrlFooterBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/uiSettings','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/application/actionManager','syracuse-tablet/html/js/application/multiSelectionMgr','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/controls/ctrlHelpers'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var globals = require('syracuse-tablet/html/js/helpers/globals');
var actionManager = require('syracuse-tablet/html/js/application/actionManager');
var multiSelectionMgr = require('syracuse-tablet/html/js/application/multiSelectionMgr');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var prototype = require('syracuse-tablet/html/js/helpers/prototype');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var ctrlHelpers = require('syracuse-tablet/html/js/controls/ctrlHelpers');

var _actionPanelId = globals.PANELACTIONSREGULAR;
var _templates = {
	main: '\
		<div class="s-m-footer s-m-opened container-fluid {{deviceType}}">\
			{{{contentHtml}}}\
		</div>',
	tablet: {
		main: '\
			<div class="s-m-footer-left">\
				{{#if homeLink}}{{{homeLink}}}{{/if}}\
				{{#if configLink}}{{{configLink}}}{{/if}}\
				{{#if pinPage}}{{{pinPage}}}{{/if}}\
			</div>\
			<div class="s-m-footer-right">\
				{{#if rightLinks}}{{{rightLinks}}}{{/if}}\
			</div>\
		',
		rightLinks: '\
			{{#each links}}\
				<a draggable="false" {{#if $isHidden}}style="display:none"{{/if}} href="#" class="s-m-link {{css}} {{#if $isDisabled}} disabled{{/if}}"\
						data-action="{{#if action}}{{action}}{{else}}footerLink{{/if}}"\
						data-params="{{$uuid}}"\
						data-control-id="{{../ctrlId}}"\
						{{#if x3LinkName}} data-s-ut-link-x3name="{{x3LinkName}}"{{/if}}>\
					<i class="{{icon}}"/>\
					<span>{{{title}}}</>\
				</a>\
			{{/each}}\
		',
		action: '\
			<a href="#" class="s-m-link" data-action="{{action}}">\
				<i class="{{icon}}"/>\
				<span>{{{title}}}</span>\
			</a>'
	},
	smartphone: {
		main: ""
	}
};

var _getHtml = function(type, name, ctx) {
	type = type || "";
	var key = type + name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = type.length == 0 ? _templates[name] : _templates[type][name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	if (!tmpl) alert("footer template " + name + " not found");
	return tmpl(ctx);
};
/**
 * Base footer class
 */
var _Klass = utils.defineClass(
	function CtrlFooterBase($type, controller, options) {
		Base.call(this, controller, {
			$bind: "footer"
		}, prototype.create({
			$type: $type
		}), options);
		this._actionManager = null;
		this._multiSelManager = null;
		this._actionPanel = null;
	}, Base, {

		destroy: function() {
			if (this._actionManager) {
				this._actionManager.destroy();
				this._actionManager = null;
			}
			if (this._multiSelManager) {
				this._multiSelManager.destroy();
				this._multiSelManager = null;
			}
			this.resetActionPanel();
			Base.prototype.destroy.call(this);
			notifications.unsubscribe(this);
		},
		getPageControlType: function() {
			return "footer";
		},
		/**
		 * Controller that handles actions
		 * For actions in dashboard this controller is the page nested in the vignette
		 * Can be overridden
		 */
		getActionController: function() {
			return this.controller;
		},

		resetActionPanel: function() {
			if (this._actionPanel) {
				this._actionPanel.destroy();
				this._actionPanel = null;
			}

		},
		buildHtml: function($$parent, controllerDao, buildOptions) {
			buildOptions = buildOptions || {};
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions, [this.typeName]);
			this.footerOptions = this.getFooterOptions(buildOptions);
			this._$$parent = this.$$elmt.closest("footer");
			if (buildOptions.refresh === true || this.footerOptions.forceRefresh) {
				// Avoid double build
				// If it's not a refresh build is called on onResize - there's always a triggerResize when we rendre a page
				this._build();
			}
		},

		// Can be overridden
		getFooterOptions: function(buildOptions) {
			return $.extend({}, buildOptions.footer, buildOptions.toolBars);
		},

		applyMetaData: function(metaData, buildOptions) {
			//  No meta for this control 
			return;
		},

		_actFooterLink: function(uuid) {
			this._actionManager.triggerLink(uuid, this.getActionController()).then(function(success, link, data, options) {
				// Message is displayed 
			}).fail(function(e) {
				if (jsutils.isError(e)) {
					// We shouldn't expect an error except exceptions
					globals.getModal().error("Footer action error", e);
				}
			});
		},
		/**
		 * Click on icon action
		 */
		_actMultiSelection: function(uuid, $$target) {
			this.toggleMultiSelection();
		},
		// Called by vignette footer
		toggleMultiSelection: function() {
			if (this._multiSelManager) {
				this._multiSelManager.toggle(this, this.$$elmt.find(".s-m-footer-right"), "dropup", "right");
			}
		},

		_actFooterAction: function(id) {
			if (id === _actionPanelId) {
				this.controller.panelAttach("right", this._actionPanel, "toggle");
			}
		},

		onMainPageResize: function(info, orientation) {
			var deviceType = globals.getSiteLayout().getDeviceType();
			this._build(deviceType);
			if (this.$$footer) {
				// Set height/top of footer in any cases
				// Cancel bottom:0px of buildHtml
				this._$$parent.css({
					top: (info.contentHeight - this._height) + "px",
					width: info.contentWidth + "px",
				});
				// Sow needed to allow page to get height for scroller
				this._$$parent.show();
			} else {
				this.resetActionPanel();
			}
		},
		getHeight: function() {
			return this._height;
		},
		/**
		 */
		_build: function(deviceType) {
			deviceType = deviceType || globals.getSiteLayout().getDeviceType();
			if (this._deviceType != null && this._deviceType === deviceType) return;
			this._deviceType = deviceType;
			if (this.$$footer) {
				this.$$footer.remove();
				this.$$footer = null;
			}
			if (deviceType === "smartphone") {
				this.$$elmt.hide();
				return;
			}
			this._height = uiSettings.getProp("footer.height");
			this._$$parent.css({
				left: 0 + "px",
				height: this._height + "px"
			});
			var htmlCtx = {};
			// Controller that handles action - different from current page for vignettes
			var actionController = this.getActionController();
			// Controller that displays the footer
			var displayController = this.controller;
			if (!this._multiSelManager) {
				this._multiSelManager = multiSelectionMgr.create(actionController);
			}
			var contentHtml;
			this._actionManager = actionManager.create(actionController, "footer", {
				addCancelEditAction: "footerLink",
				addShowTemplatesAction: "footerLink",
				addMultiSelection: !this.footerOptions.multiSelectionOnly && actionController.isMultiSelectionEnabled(),
				multiSelectionOnly: this.footerOptions.multiSelectionOnly
			});
			this._addActionMgrHtmlCtx(htmlCtx, actionController, displayController);
			this.$$footer = $(_getHtml(null, "main", {
				contentHtml: _getHtml("tablet", "main", htmlCtx),
				deviceType: deviceType
			}));
			this.$$footer.appendTo(this.$$elmt.show());
			// Check if dao dirty to update save satus
			ctrlHelpers.checkLinkInitStatus(this);
		},
		/**
		 * Return the html context to display actions/panel - Action comes from $links
		 */
		_addActionMgrHtmlCtx: function(ctx, actionController, displayController) {
			if (!this._actionManager) return;
			var showActions = this.footerOptions.showActions !== false;
			var rightLinks;
			if (showActions && this._actionManager.hasLinks()) {
				rightLinks = this._actionManager.getLinks();
			}
			if (showActions && !this._actionPanel && actionController.state.type === "regular") {
				// Add open/close action panel - We are not on smartPhone -> We display it
				// actionController that handles actions
				this._actionPanel = actionController.panelCreate(_actionPanelId);
			}
			if (this._actionPanel && this._actionPanel.hasLinks()) {
				if (!rightLinks) rightLinks = [];
				rightLinks.push({
					action: "footerAction",
					icon: fontUtils.pageIcon("sidePanelR"),
					$uuid: _actionPanelId,
					title: "&nbsp;",
					x3LinkName: "$$openRightPanel"
				});
			}
			if (rightLinks) {
				var self = this;
				rightLinks.forEach(function(rlnk) {
					ctrlHelpers.checkLinkSubscriptions(self, rlnk);
				});
				// BUILD RIGHT LINKS HTML
				ctx.rightLinks = _getHtml("tablet", "rightLinks", {
					ctrlId: this.id,
					// Links are float right
					links: rightLinks.reverse()
				});
			}
			// BUILD HOME LINK IF SHOWHOME OK (goes on the left)
			if (this.footerOptions.showHome) {
				ctx.homeLink = _getHtml("tablet", "action", {
					action: "home",
					icon: fontUtils.pageIcon("home"),
					title: locale.text("action.home")
				});
			}
			// BUILD HOME LINK IF SHOWHOME OK (goes on the left)
			if (this.footerOptions.showPageConfig) {
				ctx.configLink = _getHtml("tablet", "action", {
					action: "pageConfig",
					icon: fontUtils.pageIcon("pageConfig"),
					title: locale.text("action.pageConfig")
				});
			}
			// 0 = don't show
			// 1 = show inactive
			// 2 = show active
			if (this.footerOptions.statusPinPage > 0) {
				ctx.pinPage = _getHtml("tablet", "action", {
					action: "pinPage",
					icon: fontUtils.pageIcon("pinPage_" + this.footerOptions.statusPinPage),
					title: locale.text(this.footerOptions.statusPinPage === 1 ? "action.pin" : "action.unpin")
				});
			}
		},

		/**
		 * Page footer can be changed
		 * This method is called each time the footer is toggled
		 */
		notifToggled: function(shown) {
			if (shown === false) {
				if (this._multiSelManager) {
					this._multiSelManager.disable();
				}
				return;
			}
		},
		/**
		 * Detach from document
		 */
		detach: function() {
			this.notifToggled(false);
			if (this.$$elmt) {
				this.$$elmt.detach();
			}
		},
		/**
		 * Toggle $save status
		 */
		notifDaoDirty: function(isDirty, uuid) {
			ctrlHelpers.notifDaoDirty(this, isDirty, uuid);
		},
		/**
		 * Toggle $$showTemplates status
		 */
		notifEditTemplatesChanged: function(fromActionMgrUUID, count) {
			// Event is triggered by templaetPanel for all suscribers but only one can handle it
			// -> The one thas contains the actionManager taht trigered the link 
			if (!this._actionManager || this._actionManager.uuid != fromActionMgrUUID) return;
			ctrlHelpers.notifEditTemplatesChanged(this, count);
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/ctrlPageFooter',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/controls/page/ctrlFooterBase','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var Base = require('syracuse-tablet/html/js/controls/page/ctrlFooterBase').Klass;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');


/**
 * Page main footer
 */
var _Klass = utils.defineClass(
	function CtrlPageFooter($type, controller, options) {
		Base.call(this, $type, controller, options);
		notifications.subscribe(this, ["sm.page.pin.state.change"]);
	}, Base, {
		// newState
		// 0 = don't show
		// 1 = show inactive
		// 2 = show active
		notifPagePinStateChange: function(newState) {
			var $$root = this.$$elmt.find("[data-action=pinPage]");
			var $$icon = $$root.find("i");
			if ($$icon.length > 0) {
				$$icon.attr("class", fontUtils.pageIcon("pinPage_" + newState));
				$$root.find("span").text(locale.text(newState === 1 ? "action.pin" : "action.unpin"));
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/ctrlVignetteFooter',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/page/ctrlFooterBase'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/page/ctrlFooterBase').Klass;


/**
 * Vignette footer - USed to call action in dashboards
 * Created only for smartphone devices
 */
var _Klass = utils.defineClass(
	function CtrlVignetteFooter($type, vignette, options) {
		Base.call(this, $type, vignette.controller, options);
		this._vignette = vignette;
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			this._vignette = null;
		},

		getFooterOptions: function(buildOptions) {
			return {
				showHome: false,
				showPageConfig: false,
				statusPinPage: false,
				multiSelectionOnly: this.options.multiSelectionOnly === true,
				// To force build
				forceRefresh: true
			};
		},

		getActionController: function() {
			if (!this._vignette) return null;
			return this._vignette.getPage();
		},

		/**
		 * Called after the footer has been attached
		 * Enable multiselection
		 */
		notifToggled: function(shown) {
			Base.prototype.notifToggled.call(this, shown);
			if (shown !== true) return;
			if (this._multiSelManager) {
				this.toggleMultiSelection();
			}
		}

	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/ctrlVignetteHeader',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/controls/page/ctrlHeaderBase','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/page/ctrlHeaderBase').Klass;
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

/**
 * Header displayed when a vignette is pinned (action triggering is enabled)
 */
var _Klass = utils.defineClass(

	function CtrlVignetteHeader($type, vignette, options) {
		options = options || {};
		this._vignette = vignette;
		options.freshness = this._vignette.getPage() != null && this._vignette.getPage().dao != null;
		Base.call(this, $type, vignette.controller, options);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			this._vignette = null;
		},

		buildHtml: function($$parent, controllerDao, buildOptions) {
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions);
			// Update drafts menu item - Vignette header is created on demand and has not been notified previouly
			globals.getStorage().draftOperation("draftNotifyChanged");
		},

		getHeaderOptions: function(buildOptions) {
			//buildOpts are the one of the dashboard - #7932
			var opts = $.extend(true, {}, this.options.buildOpts);
			opts.forceRefresh = true;
			opts.multiSelectionOnly = this.options.multiSelectionOnly === true;
			opts.showUserpanel = true;
			opts.showDrafts = true;
			return opts;
		},

		getActionController: function() {
			return this._vignette.getPage();
		},

		/**
		 * Called after the header has been attached
		 * Enable multiselection
		 */
		notifToggled: function(shown) {
			Base.prototype.notifToggled.call(this, shown);
			if (shown !== true) return;
			if (this._multiSelManager) {
				this.toggleMultiSelection();
			}
			if (this.options.freshness == true) {
				notifications.publish("sm.data.freshness.change", this._vignette.getPage().dao.dataFreshness());
			}
		}

	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/sidePanel',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/application/eventListener','syracuse-tablet/html/js/helpers/scroller/scrollerHelpers','syracuse-tablet/html/js/ui/rect'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var prototype = require('syracuse-tablet/html/js/helpers/prototype');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');
var uiRect = require('syracuse-tablet/html/js/ui/rect');

/**
 * Base left/right panel control for dashBoards and regular pages
 * 	Adapted from Metro Bootstrap navbar-side
 */
var _Klass = utils.defineClass(
	/**
	 * SidePanel used by instanceOf
	 */
	function SidePanel(controller, $type, panelId, options) {
		this.panelId = panelId;
		this.actionManager = null;
		// Close on click by default
		this.closeBox = options.closeBox === true;
		// Overlap by default
		this.overlap = options.overlap !== false;
		// False by default - !! If true the child class must provide a DOM elmt with s-m-scroll-elmt class
		this.enableGesture = options.enableGesture === true;
		Base.call(this, controller, {
			$bind: this.panelId + "panel"
		}, prototype.create({
			$type: $type
		}), options);
		this._gestureMgr = null;
	}, Base, {
		destroy: function() {
			if (this.actionManager) {
				this.actionManager.destroy();
				this.actionManager = null;
			}
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
			this._$$scrollElmt = null;
			this._$$scrollWrapper = null;
			this.detach();
			Base.prototype.destroy.call(this);
		},
		/**
		 * Build doesn't attach $$elmt to a parent - see attach/detach
		 */
		buildHtml: function(side) {
			this.side = side;
			Base.prototype.buildHtml.call(this, null, this.controller.dao, {}, [this.typeName]);
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},
		attach: function($$parent, side) {
			if (this.$$elmt && (this.side != null && side != this.side)) {
				this.$$elmt.remove();
				this.$$elmt = null;
			}
			if (!this.$$elmt) {
				this.buildHtml(side);
			};
			if (this.isAttached()) {
				console.log("sidePanel.attach - Unexpected attached $$elmt");
				this.detach();
			}
			if (!$$parent) return;
			$$parent.append(this.$$elmt);
		},
		isAttached: function(side) {
			return this.$$elmt != null && this.$$elmt.closest(".s-m-panel").length > 0 && this.side == side;
		},
		detach: function() {
			if (!this.$$elmt) return;
			this.$$elmt.detach();
		},
		isEnabled: function() {
			return true;
		},
		/**
		 * Notified by page when toggled
		 */
		notifyToggled: function(side, action, visible) {
			if (!visible) return;
			this._updateGesture();
		},
		applyMetaData: function(metaData, buildOptions) {
			//  No meta for this control 
			return;
		},
		onClick: function(evt) {
			this.close();
		},
		// Trigger evt to let page manage the close and all additional actions
		close: function() {
			eventListener.triggerAction(this.$$elmt, "toggleSidePanel", "close," + this.side);
		},
		setActionManager: function(amgr) {
			if (this.actionManager) {
				this.actionManager.destroy();
			}
			this.actionManager = amgr;
		},
		_actActionLink: function(uuid) {
			if (!this.actionManager) return;
			this.actionManager.triggerLink(uuid, this.controller);
		},
		hasLinks: function() {
			throw new Error("Not implemented");
		},
		/**
		 * Called if orientation/device/size changes
		 */
		onResize: function(context) {
			if (this._gestureMgr) {
				this._updateGesture();
			}
		},
		_updateGesture: function() {
			if (this.enableGesture !== true) return;
			if (!this.$$elmt || !this.$$elmt.is(':visible')) {
				if (this._gestureMgr) {
					this._gestureMgr.reset();
				}
				return;
			}
			if (!this._gestureMgr) {
				this.$$scrollElmt = this.$$elmt.find(".s-m-scroll-elmt");
				if (this.$$scrollElmt.length === 0) {
					if (globals.isDvlpMode()) {
						globals.getModal().notify({
							severityClass: "error",
							body: "Panel scrolling - Unexpected empty .s-m-scroll-elmt dom element"
						});
					}
					this.enableGesture = false;
					return;
				}
				// $$scrollWrapper is generally this.$$elmt
				this.$$scrollWrapper = this.$$elmt.find(".s-m-scroll-wrapper");
				if (this.$$scrollWrapper.length === 0) {
					this.$$scrollWrapper = this.$$elmt;
				}
				this._gestureMgr = scroller.newScroller(this.$$scrollElmt, {
					direction: "v",
					valMax: 0,
					name: this.$bind,
					isPageScroller: false
				});
			}
			// reset old scrolling to calculate width/height (mandatory in native mode)
			this._gestureMgr.reset();
			// top=0px needed to calculate the right viewrect
			var scrollRect = uiRect.elmtRect(this.$$scrollElmt.css({
				top: "0px"
			}), "outer");
			var wrapperRect = uiRect.elmtRect(this.$$scrollWrapper, "outer");
			var viewRect = wrapperRect.intersectRect(scrollRect);
			if (viewRect && !viewRect.contains(scrollRect)) {
				// Keep scrolling
				this._gestureMgr.init(viewRect, null, null, true);
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/actionPanel',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/page/panels/sidePanel'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/page/panels/sidePanel').Klass;

var _templates = {
	main: '\
			<nav class="navbar s-m-side-panel {{side}} navbar-inverse ctrl-evt-click" role="navigation">\
				<div class="s-m-panel-content s-m-scroll-elmt">\
					{{#each items}}\
						{{#if html}}\
							{{#if title}}\
								<div class="container-fluid">\
									<div class="navbar-header">\
										<span class="navbar-brand" href="#"><span>{{title}}</span></a>\
									</div>\
								</div>\
							{{/if}}\
							<ul class="nav navbar-nav">\
								{{{html}}}\
							</ul>\
						{{/if}}\
					{{/each}}\
				</div>\
			</nav>'
};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	if (!tmpl) alert("template " + name + " not found");
	return tmpl(ctx);
};
/**
 * Base left/right panel control for dashBoards and regular pages
 * 	Adapted from Metro Bootstrap navbar-side
 */
var _Klass = utils.defineClass(

	function(controller, $type, panelId, options) {
		options = options || {};
		// true to enable display on two columns when height is too small (avoid scroll)
		this.enableTwoColumns = options.enableTwoColumns === true;
		options.enableGesture = this.enableTwoColumns !== true;
		Base.call(this, controller, $type, panelId, options);
	}, Base, {
		buildHtml: function(side) {
			Base.prototype.buildHtml.call(this, side);
			this.$$elmt.addClass(this.typeName);
			var context = {
				ctrlId: this.id,
				side: side
			};
			if (this.$$panel) {
				this.$$panel.remove();
			}
			this.$$panel = this.buildPanel(context, side);
			if (this.$$panel && this.$$panel.length) {
				this.$$elmt.append(this.$$panel);
			}
			this.$$panelContent = this.$$panel.find(".s-m-panel-content");
		},
		/**
		 * Override this method to build child class
		 */
		buildPanel: function(context, side) {
			return $(_getHtml("main", context));
		},
		isEnabled: function() {
			return true;
		},
		notifyToggled: function(side, action, visible) {
			Base.prototype.notifyToggled.call(this, side, action, visible);
			if (this.enableTwoColumns) {
				this._toggleTwoColumns(visible !== true);
			}
		},
		onResize: function(context) {
			Base.prototype.onResize.call(this, context);
			if (this.enableTwoColumns && (context.deviceChanged || context.orientationChanged)) {
				this._toggleTwoColumns();
			}
		},
		_toggleTwoColumns: function(disable) {
			this.$$elmt.parent().removeClass("s-m-two-columns");
			if (disable !== true && this.$$panelContent.height() > this.$$elmt.height()) {
				this.$$elmt.parent().addClass("s-m-two-columns");
				return;
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/pageActionPanelRegular',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/controls/page/panels/actionPanel','syracuse-tablet/html/js/application/actionManager','syracuse-tablet/html/js/application/multiSelectionMgr','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/page/panels/actionPanel').Klass;
var actionManager = require('syracuse-tablet/html/js/application/actionManager');
var multiSelectionMgr = require('syracuse-tablet/html/js/application/multiSelectionMgr');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var _templates = {
	actionLink: '\
	{{#each links}}\
		<li class="s-m-link">\
			<a draggable="false" href="#" class="{{css}}" \
				data-action="actionLink" \
				data-params="{{$uuid}}" \
				{{#if x3LinkName}} data-s-ut-link-x3name="{{x3LinkName}}"{{/if}}\
				data-control-id="{{../ctrlId}}">\
				<i style="font-size: large" class="{{icon}}"/>\
				<span>{{title}}</span>\
			</a>\
		</li>\
	{{/each}}\
	{{#if links}}\
		{{#if actions}}\
			<li class="s-m-separator">&nbsp;</li>\
		{{/if}}\
	{{/if}}\
	{{#each actions}}\
		<li class="s-m-action">\
			<a draggable="false" href="#" class="{{css}}" \
				data-action="actionLink" \
				data-params="{{$uuid}}" \
				{{#if x3LinkName}} data-s-ut-link-x3name="{{x3LinkName}}"{{/if}}\
				data-control-id="{{../ctrlId}}">\
				<i style="font-size: large" class="{{icon}}"/>\
				<span>{{title}}</span>\
			</a>\
		</li>\
	{{/each}}'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

/**
 * Regular page action panel
 */
var _Klass = utils.defineClass(

	function(controller, $type, panelId, options) {
		Base.call(this, controller, $type, panelId, options);
	}, Base, {

		destroy: function() {
			if (this._multiSelManager) {
				this._multiSelManager.destroy();
				this._multiSelManager = null;
			}
			Base.prototype.destroy.call(this);
		},

		buildPanel: function(context, side) {
			if (!this.actionManager) {
				this._createActionManager();
			}
			context.items = [];
			// Top level links - no title
			if (this._smartPhoneMultiselLink()) {
				this._multiSelManager = multiSelectionMgr.create(this.controller);
				var info = this.actionManager.getMultiSelectionLink();
				info.$isAction = true;
				info.$uuid = "togglemultiselection";
				context.items.push({
					title: null,
					html: _getHtml("actionLink", {
						ctrlId: this.id,
						links: [info]
					})
				});
			}
			// Specific additional links
			var backToList;
			if (this._smartPhoneBackToQueryLink()) {
				// Add back to list to be processed by action manager
				backToList = this.controller.getProtoLinks("$query").$query;
				this.actionManager.addLink(backToList);
				context.items.push({
					title: locale.text("actionpanel.label.links"),
					html: _getHtml("actionLink", {
						ctrlId: this.id,
						links: [backToList]
					})
				});
			}
			// Prototype action links
			if (this._hasActionLinks()) {
				// Exclude back to list because already displayed in label.links section
				var exclude = [backToList ? backToList.$uuid : null];
				context.items.push({
					title: locale.text("actions"),
					html: _getHtml("actionLink", {
						ctrlId: this.id,
						links: this.actionManager.getLinks(exclude, [{
							$isAction: false
						}]),
						actions: this.actionManager.getLinks(exclude, [{
							$isAction: true
						}]),
					})
				});
			}
			return Base.prototype.buildPanel.call(this, context);
		},
		_smartPhoneMultiselLink: function() {
			return globals.isSmartphone() && this.controller.isMultiSelectionEnabled();
		},

		_smartPhoneBackToQueryLink: function() {
			return globals.isSmartphone() && this.controller.prototype.isDetails() && this.controller.getProtoLinks("$query") != null;
		},

		_hasActionLinks: function() {
			return this._createActionManager().hasLinks();
		},

		_actActionLink: function(uuid, $$target, evt) {
			if (evt) {
				// We stop propagation because we are sure there no need to propagate
				// See #6497 - Some times the propagation tries to close the panel but page has been already destroyed
				evt.stopPropagation();
			}
			this.close("close");
			if (uuid === "togglemultiselection") {
				notifications.publish("sm.panel.multiselection.toggle");
				return;
			} else {
				Base.prototype._actActionLink.call(this, uuid);
			}
		},
		_createActionManager: function() {
			if (this.actionManager) return this.actionManager;
			this.setActionManager(actionManager.create(this.controller, "actionpanel"));
			return this.actionManager;
		},
		hasLinks: function() {
			return this._hasActionLinks() || this._smartPhoneBackToQueryLink() || this._smartPhoneMultiselLink();
		},
		_actActionNavigation: function(uuid, $$target, evt) {
			if (evt) {
				// We stop propagation because we are sure there no need to propagate
				// See #6497 - Some times the propagation tries to close the panel but page has been already destroyed
				evt.stopPropagation();
			}
			if (this.actionManager) {
				this.actionManager.triggerLink(uuid, this.controller);
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/scroller/scrollerHelpers'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');

/**
 * Base tab
 */
var _Klass = utils.defineClass(
	function(panel, id, options) {
		this.id = id;
		this.options = options || {};
		this.panel = panel;
		this.$$tab = this.panel.$$panel.find('[href="#' + id + '"]');
		this.$$tab.on('shown.bs.tab', jsutils.bindFn(this._onTabShown, this));
		this.$$content = this.panel.$$panel.find('#' + this.id);
		this.$$content.on("click", '[data-params]', jsutils.bindFn(this.onTabContentClick, this));
		if (this._gestureMgr) {
			this._gestureMgr.destroy();
			this._gestureMgr = null;
		}
		this.buildHtml();
		// Create gesture mgr
		this.$$scrollWrapper = this.$$content.find(".s-m-scroll-wrapper");
		this.$$scrollElmt = this.$$content.find(".s-m-scroll-elmt");
		if (this.$$scrollElmt.length > 0 && this.$$scrollWrapper.length > 0) {
			this._gestureMgr = scroller.newScroller(this.$$scrollElmt, {
				direction: "v",
				valMax: 0,
				isPageScroller: false
			});
		}
	}, null, {
		destroy: function() {
			this.panel = null;
			if (this.$$tab) {
				this.$$tab.unbind();
				this.$$tab.remove();
				this.$$tab = null;
			}
			if (this.$$content) {
				this.$$content.unbind();
				this.$$content.remove();
				this.$$content = null;
			}
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
			this.$$scrollElmt = null;
			this.$$scrollWrapper = null;
		},
		/**
		 * Hide the tab
		 */
		hide: function() {
			this.$$tab.parent().hide();
			this.$$content.hide();
		},
		setWidth: function(w) {
			this.$$tab.parent().width(w);
		},
		triggerActivate: function() {
			var self = this;
			if (self.$$tab.parent().hasClass("active")) {
				self._onTabShown();
			} else {
				window.setTimeout(function() {
					self.$$tab.tab('show');
				});
			}
		},
		/**
		 * Tab becomes visible - No override - Override doTabShow
		 */
		_onTabShown: function(event) {
			//Calls panel to set active tab
			this.panel.notifyActiveTab(this);
			this.doTabShow();
			this.updateGesture();
		},
		/**
		 * Overridden by child class
		 */
		doTabShow: function() {

		},
		/**
		 * Build HTML
		 */
		buildHtml: function() {

		},
		/**
		 * Click on content
		 */
		onTabContentClick: function(evt) {
			evt.preventDefault();
			evt.stopPropagation();
			this.doContentAction(evt, $(evt.target), $(evt.target).attr("data-params"));
		},
		/**
		 * Called when user clicks on an action in tab content
		 * Action is identified by data-param attribute
		 */
		doContentAction: function(evt, $$target, params) {},
		/**
		 * Called when user clicks on Apply button
		 */
		doActionApply: function(evt, $$target) {},
		/**
		 * Panel is resized
		 */
		onResize: function(context) {
			if (this._gestureMgr && this.$$content.is(':visible')) {
				this.updateGesture(context);
			}
		},
		/**
		 * Panel is opened
		 */
		notifyOpenPanel: function() {},
		/**
		 * Panel is closed
		 */
		notifyClosePanel: function() {},
		updateGesture: function(context) {
			if (!this._gestureMgr) return;
			// reset old scrolling to calculate width/height (mandatory in native mode)
			this._gestureMgr.reset();
			var viewRect = uiRect.elmtRect(this.$$scrollWrapper).intersectRect(uiRect.elmtRect(this.panel.$$elmt));
			if (viewRect.height < this.$$scrollElmt.height()) {
				this._gestureMgr.init(viewRect);
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabSort',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/page/panels/sortfilter/tabBase','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabBase').Klass;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _templates = {
	main: '\
		<div id="sorttabroot" class="s-m-scroll-wrapper">\
			<ul class="list-group s-m-scroll-elmt"/>\
		</div>',
	items: '\
		{{#each items}}\
			<li class="list-group-item" data-params="{{id}}">\
				<span>{{name}}</span>\
				<span class="s-m-order ' + fontUtils.sortIcon("desc") + '  {{#smCompare sort "desc"}}enabled{{/smCompare}}" data-params="desc"></span>\
				<span class="s-m-order ' + fontUtils.sortIcon("asc") + '  {{#smCompare sort "asc"}}enabled{{/smCompare}}" data-params="asc"></span>\
			</li>\
		{{/each}}',
	/** Add this line to add the remove icon
	 * <span class="s-m-order ' + fontUtils.sortIcon("none") + ' " data-params="none"></span>
	 */
};


var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};
/**
 * Sort tab
 */
var _Klass = utils.defineClass(
	function(panel, id, options) {
		options = options || {};
		options.hidden = options.hidden === true || panel.getParentArray().sortInfoGet(false).length === 0;
		Base.call(this, panel, id, options);
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.$$list = null;
		},
		buildHtml: function() {
			this.$$content.append($(_getHtml("main", {})));
			this.$$list = this.$$content.find("ul.list-group");
		},
		/**
		 * Save sort info
		 */
		doActionApply: function(evt, $$target) {
			// Set and refresh - clone to keep a different copy from array one
			this.panel.getParentArray().sortInfoSet($.extend(true, [], this.sortInfo), true);
			return true;
		},
		saveInfos: function() {
			var values = this.panel.saveInfos();
			if (values) {
				var notify = {
					severityClass: "success",
					title: values.title,
					body: locale.text("panels.array.memo.created"),
					onlyWebapp: true
				};
				globals.getModal().notify(notify);
			}
		},
		_buildSortInfo: function() {
			var status = {};
			this.$$content.find(".s-m-order.enabled").each(function(idx, $$e) {
				$$e = $($$e);
				status[$$e.parent().attr("data-params")] = $$e.attr("data-params");
			});
			this.sortInfo = this.sortInfo || [];
			this.sortInfo.forEach(function(i) {
				i.sort = status[i.id] || "none";
			});
		},
		getInfo: function() {
			this._buildSortInfo();
			return $.extend(true, [], this.sortInfo);
		},
		doContentAction: function(evt, $$target, dataParams) {
			if ($$target.hasClass("enabled")) {
				$$target.removeClass('enabled');
			} else {
				(this.options.singleCriteria === true ? this.$$content : $$target.parent()).find(".s-m-order.enabled").removeClass('enabled');
				$$target.addClass("enabled");
			};
			this._buildSortInfo();
		},
		/**
		 * We remove the content on close to cancel modifications
		 */
		notifyClosePanel: function() {
			Base.prototype.notifyClosePanel.call(this);
			if (this.$$items) {
				this.$$items.remove();
				this.$$items = null;
			}
			this.sortInfo = null;
		},
		/**
		 * Tab becomes Active - we create content
		 */
		doTabShow: function() {
			Base.prototype.doTabShow.call(this);
			if (this.$$items) this.$$items.remove();
			// We clone to keep a different copy from array one		
			this.sortInfo = this.sortInfo || $.extend(true, [], this.panel.getParentArray().sortInfoGet());
			this.$$items = $(_getHtml("items", {
				items: this.sortInfo
			}));
			this.$$list.append(this.$$items);
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/helpers/formController',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/helpers/controller'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var reqProto = require('syracuse-tablet/html/js/helpers/prototype');
var Base = require('syracuse-tablet/html/js/helpers/controller').Klass;

var _createProto = function(protoJson, protoParent, baseUrl) {
	if (!protoParent && baseUrl) {
		protoJson.$baseUrl = baseUrl;
	}
	return reqProto.create(protoJson, protoParent);
};

var _createArticle = function(proto) {
	var article = {
		"$layoutType": "stack",
		"$items": []
	};
	var protoJson = proto.data("$properties");
	Object.keys(protoJson).forEach(function(key) {
		if (!protoJson[key].$isExcluded) {
			article.$items.push({
				"$bind": key
			});
		}
	});
	return article;
};
/**
 * options
 * 		$activity	read by default
 */
var _Klass = utils.defineClass(
	function(id, proto, article, dao, options) {
		if (article == null) {
			article = _createArticle(proto);
		}
		Base.call(this, id, proto, article, options);
		this.setActivity(this.options.$activity);
		this.setDao(dao);
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
		},
		render: function($$parent, opts) {
			if (this.rootLayout == null) {
				this.buildControlsTree();
			}
			var opts = $.extend(opts, {
				afterRender: true
			});
			Base.prototype.render.call(this, $$parent, opts);
		},
		/**
		 * Show element in page - scroll if needed
		 * c is a JQuery elmt or an object with $$elmt property
		 */
		makeVisible: function(c) {
			// TODO - Implement a gestureManager in base controller to allow makeVisible
		}
	});


exports.createProto = _createProto;
exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabFilterEdit',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/formController','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/application/daoSdata','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/fieldOperators'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var formController = require('syracuse-tablet/html/js/helpers/formController');
var prototype = require('syracuse-tablet/html/js/helpers/prototype');
var daoSdata = require('syracuse-tablet/html/js/application/daoSdata');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');


var _templates = {
	main: '\
		<section id="formtabroot">\
			<div class="s-m-scroll-wrapper">\
				<div id="formtabform"/>\
			</div>\
			<div class="btn-group btn-group-justified" role="group">\
				<a type="button" class="btn btn-default" data-params="cancelFilterEdit">\
					<i class="fa fa-times" data-params="cancelFilterEdit"></i>\
				</a>\
				<a type="button" class="btn btn-default disabled" data-params="submitFilterEdit">\
					<i class="fa fa-check" data-params="submitFilterEdit"></i>\
				</a>\
			</div>\
		</section>'
};


var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

var _buildOperatorsEnum = function(operators) {
	var res = [];
	$.each(operators, function(idx, op) {
		res.push({
			$value: op,
			$title: locale.text("field.operator." + op)
		});
	});
	return res;
};

var FormKlass = utils.defineClass(
	function(proto, dao, filtersMap, $$formParent) {
		formController.Klass.call(this, utils.readableuid("FILTERFORM"), proto, null, dao, {
			$activity: "edit"
		});
		this.$$formParent = $$formParent;
		this.filtersMap = filtersMap;
		this.addEventListener("change", this.onEvtChange);
		this.addEventListener("blur", this.onEvtBlur);
	}, formController.Klass, {
		destroy: function() {
			formController.Klass.prototype.destroy.call(this);
		},
		/**
		 * 	when	"before" or "after"
		 * 				"before"	call before calling control event
		 * 					return false 	to continue
		 * 					return true 	to stop the process and not call control's listener
		 * 				"after" 	call after calling control event
		 *	crl		control object
		 */
		onEvtChange: function(when, ctrl, $$target, event) {
			var self = this;
			if (when === "before") {
				var res = false;

				switch (ctrl.$bind) {
					case "FIELDS":

						// nothing to do. user selected "select field" option
						if ($$target.val() == 0) {
							// set button validate disabled
							this._toggleSave(false);
							return;
						} else {
							// set button validate enabled
							this._toggleSave(true);
							var fm = self.filtersMap[$$target.val() - 1];
							// UPDATE OPERATORS CHOICE CTRL & VALUE FIELD TYPE

							// build new enum
							var operators = fm.operators;
							var $newEnum = _buildOperatorsEnum(operators);

							var newData = {
								"$properties": {
									"OPERATORS": {
										"$value": {
											$enum: $newEnum
										},
										$isReadOnly: false
									}
								},
								"OPERATORS": $newEnum[0].$value
							};
							// hide previously displayed value field
							if (self.keyToHide) {
								newData.$properties[self.keyToHide] = {
									$isHidden: true
								};
							}
							// For reference fields, meta-data ($properties) is given by the field that contains the data
							var keyToShow = fm.isReference ? fm.id : "VALUE-" + fm.id;
							newData.$properties[keyToShow] = {
								$isHidden: false
							};
							self.keyToHide = keyToShow;

							// apply change
							window.setTimeout(function() {
								self.applyChange($.extend(true, {}, newData));
							});
						}
						break;
					case "OPERATORS":
						// TODO handle specific operators such as "between", "empty", "not empty"
						break;
				}
				return res;
			}
		},
		onEvtBlur: function(when, ctrl, $$target, event) {
			//TODO ?
		},
		// check that data is set
		validateForm: function() {
			var self = this;
			var res = true;
			this.forEachControl(function(id, ctrl) {
				var bind = ctrl.$bind;
				if (ctrl.prototype.isReference(bind)) {
					// Field that contains the value
					bind = ctrl.prototype.getFieldNameForValue(bind);
				}
				res = (bind === "OPERATORS" || bind !== "FIELDS" || bind !== self.keyToHide) ? res : (ctrl.checkData() ? res : false);
			});
			return res;
		},
		applyChange: function(newData) {
			formController.Klass.prototype.applyChange.call(this, newData);
			this._toggleSave(newData != null && !$.isEmptyObject(newData));
		},
		render: function($$parent, buildOpts) {
			formController.Klass.prototype.render.call(this, $$parent, buildOpts);
			this._toggleSave(false);
		},
		_toggleSave: function(enable) {
			$("a[data-params='submitFilterEdit']", this.$$formParent).toggleClass("disabled", !enable);
		}
	});
/**
 * Filter edit tab
 */
var _Klass = utils.defineClass(
	function(parentTab) {
		this.controller = null;
		this.$$content = $(_getHtml("main", {}));
		this.$$formtabform = this.$$content.find("#formtabform");
		this.parentTab = parentTab;
		this.panel = parentTab.panel;
	}, null, {
		destroy: function() {
			if (this.controller) {
				this.controller.destroy();
				this.controller = null;
			}
			this.$$content = null;
			this.$$formtabform = null;
			this.parentTab = null;
			this.panel = null;
			this.panel = null;
		},
		/**
		 * Create content
		 */
		create: function($$container) {
			var self = this;

			if (self.$$content.parent().length == 0) {
				$$container.append(self.$$content);
			}

			self.$$formtabform.empty();

			var array = self.panel.getParentArray();

			var protoJson;
			var dataJson;

			var res = self._buildProtoJson();
			protoJson = res.protoJson;
			dataJson = res.dataJson;


			var proto = formController.createProto(protoJson, null, array.prototype.data("$baseUrl"));
			var dao = new daoSdata.Dao($.extend(true, {}, dataJson), proto);

			self.controller = new FormKlass(proto, dao, self.filtersMap, self.$$content);
			self.controller.render(self.$$formtabform, {});
			self.updateGesture();
			if (self.initData) {
				window.setTimeout(function() {
					// Enable save if a filter exists
					self.controller.applyChange($.extend(true, {}, self.initData), true);
					self.controller.keyToHide = self.initKeyToHide;
				});
			}

		},
		updateGesture: function() {
			this.parentTab.updateGesture();
		},
		_getFiltersMap: function() {
			var self = this;
			self.filtersMap = self.filtersMap || self.panel.getParentArray().filterMapGet();
			return self.filtersMap;
		},
		_buildProtoJson: function() {
			var self = this;

			var choiceData = {};

			self.filtersMap = self._getFiltersMap();

			// init json
			var protoJson = {
				"$properties": {
					"FIELDS": {
						"$title": locale.text("panels.array.filterForm.field"),
						"$type": "application/x-choice",
						"$capabilities": "sort,filter",
						"$value": {
							"$type": "application/x-integer",
							"$enum": []
						},
						"$isMandatory": true
					},
					"OPERATORS": {
						"$title": locale.text("panels.array.filterForm.operator"),
						"$type": "application/x-choice",
						"$capabilities": "sort,filter",
						"$value": {
							"$type": "application/x-string",
							"$enum": []
						},
						"$isReadOnly": true
					}
				},
				$localization: self.panel.getParentArray().prototype.data("$localization")
			};

			for (var ii = 0, jj = self.filtersMap.length; ii < jj; ii++) {

				var ff = self.filtersMap[ii];
				var key = "VALUE-" + ff.id;
				protoJson.$properties[key] = {
					$title: locale.text("panels.array.filterForm.value"),
					$type: ff.prop.$type,
					$isHidden: true,
					$item: ff.prop.$item,
					$value: ff.prop.$value
				};
				if (ff.isReference) {
					protoJson.$properties[ff.prop.$bindValue] = {
						$type: protoJson.$properties[ff.prop.$bindType],
						$isHidden: true,
						$isExcluded: true
					};
				}
				// in case of application/x-choice field, first value must be added to init dao
				if (ff.prop.$type.indexOf("choice") >= 0) {
					choiceData[key] = ff.prop.$value.$enum[0].$value;
				} else if (ff.prop.$type.indexOf("boolean") >= 0) {
					choiceData[key] = true;
					protoJson.$properties[key].$format = "$switch";
				}
			}


			// set fields choice ctrl values
			// protoJson.$properties.FIELDS.$value.$enum
			var $fieldEnum = [];
			$fieldEnum.push({
				$value: 0,
				$title: locale.text("panels.array.filterForm.fieldDefault")
			});
			$.each(self.filtersMap, function(idx, ff) {
				$fieldEnum.push({
					$value: idx + 1,
					$title: ff.fieldName
				});
			});
			protoJson.$properties.FIELDS.$value.$enum = $fieldEnum;

			// set operators choice ctrl default value
			// protoJson.$properties.OPERATORS.$value.$enum
			var $operatorDefEnum = [];
			var operators = fieldOperators.getOperators();
			protoJson.$properties.OPERATORS.$value.$enum = _buildOperatorsEnum(operators);

			var result = {
				protoJson: protoJson,
				dataJson: choiceData
			};


			return result;
		},
		/**
		 * Save sort info
		 */
		doActionApply: function(evt, $$target) {
			if (!this.controller) return;
			if (!this.controller.checkControlsData()) {
				globals.getModal().error("Data are invalid");
			} else {
				globals.getModal().info("Data are valid");
			}
		},
		doContentAction: function(evt, $$target, params) {
			var self = this;
			switch (params) {
				case "submitFilterEdit":
					self.onFilterEditSubmit();
					break;
				case "cancelFilterEdit":
					self.onCancelEdit();
					break;
			}
		},
		/*
		 * If user submits filter edit, update filter tab info,
		 */
		onFilterEditSubmit: function() {
			var self = this;
			if (self.controller.validateForm()) {
				// build filterInfo object with the following format
				/* {
					filterMapIdx: 'index in filterMap array',
					fieldName: "fieldName",
					operatorLabel: "operator label",
					value: "value to filter by",
					operator: "filter operator"
					id: "field code",
					prop: "field $value object"
				}
				*/
				self.filtersMap = self._getFiltersMap();
				var dao = self.controller.dao.data;
				var filterMapIdx = parseInt(dao.FIELDS, 10) - 1;
				var operator = dao.OPERATORS;
				var value = dao["VALUE-" + self.filtersMap[filterMapIdx].id];
				var prop = self.filtersMap[filterMapIdx].prop;

				var info = {
					filterMapIdx: filterMapIdx,
					fieldName: self.filtersMap[filterMapIdx].fieldName,
					operatorLabel: locale.text("field.operator." + operator),
					value: self._getValue(prop, value),
					operator: operator,
					id: self.filtersMap[filterMapIdx].id,
					prop: prop,
					originalValue: value,
					isReference: self.filtersMap[filterMapIdx].isReference
				};


				self.filterTab = self.filterTab || self.panel.getTabs().filter;
				self.filterTab.onFilterUpdate(info, !isNaN(parseInt(self.initIdx, 10)) && self.initIdx >= 0 ? self.initIdx : null);

				self._onTabClose();
			}
		},
		/* 	get value to be displayed in filter list (text value)
		 * 	this is particularly useful in case of application/x-choice fields
		 */
		_getValue: function(prop, value) {
			var self = this;
			var vv;
			if (typeof value === 'object') {
				vv = value.$value || value.$description || value.$title;
			} else {
				// in case of application/x-choice item, 
				// value to display should be $title of $enum if $value.$type -> 'application/x-integer'
				// else, value parameter is already ok
				if (prop.$type.indexOf("choice") >= 0) {
					vv = prop.$value.$type.indexOf("integer") >= 0 ? self.controller.prototype.resolveExpression(prop.$value.$enum[parseInt(value - 1, 10)].$title) : value;
				} else {
					vv = value;
				}
			}
			return vv;
		},
		/*
		 * If user cancels filter edit, hide form and show filters list
		 */
		onCancelEdit: function() {
			var self = this;
			self._onTabClose();
			self.parentTab.toggleList(true);
		},
		/*
		* Create init data for that will be used to create the filter edit
		* init data JSON structure is {
			"FIELDS": "index among enum, as a string",
			"OPERATORS": "operator value",
			"VALUE": "filter value"
		}

		info parameter JSON structure is {
			filterMapIdx: 'index in filterMap array',
			fieldName: "fieldName",
			operatorLabel: "operator label",
			value: "value to filter by",
			operator: "filter operator"
			id: "field code",
			prop: "field $value object"
		}
		*/
		setInitData: function(info, initIdx) {
			var self = this;

			self.filtersMap = self._getFiltersMap();

			// get idx
			var filterMapIdx = info.filterMapIdx;
			var ff = self.filtersMap[filterMapIdx];

			// build init data
			self.initData = {
				$properties: {
					OPERATORS: {
						$value: {
							$enum: _buildOperatorsEnum(ff.operators)
						},
						$isReadOnly: false
					}
				},
				FIELDS: filterMapIdx + 1,
				OPERATORS: info.operator
			};

			self.initData["VALUE-" + ff.id] = info.originalValue;
			// For reference fields, meta-data ($properties) is given by the field that contains the data
			var bind = ff.isReference ? ff.id : "VALUE-" + ff.id;

			self.initData.$properties[bind] = {
				$isHidden: false
			};

			self.initIdx = initIdx;

			// bind key will be used by the formController
			self.initKeyToHide = bind;
		},
		/*
		 * Cleaning actions
		 */
		_onTabClose: function() {
			var self = this;
			self.controller.destroy();
			self.controller = null;
			self.initData = null;
			self.initIdx = null;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabFilter',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/page/panels/sortfilter/tabBase','syracuse-tablet/html/js/controls/page/panels/sortfilter/tabFilterEdit','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabBase').Klass;
var FilterEdit = require('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabFilterEdit').Klass;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');

var _templates = {
	main: '\
		<div class="s-m-scroll-wrapper" style="height:100%">\
			<div  class="s-m-scroll-elmt">\
				<section id="filterlist">\
				</section>\
				<section id="filteredit">\
				</section>\
			</div>\
		</div>',
	filterList: '\
		<div id="filterListEmpty" style="display:none">\
			{{emptyList}}\
		</div>\
		<ul class="list-group"/>\
		<div class="btn-group btn-group-justified" role="group">\
			<a type="button" class="btn btn-default" data-params="addFilter">\
				<i class="fa fa-plus" data-params="addFilter"></i>\
			</a>\
		</div>',
	items: '\
		{{#each items}}\
			{{#unless  @first }}\
			<span class="s-m-filter-separator ' + fontUtils.filterIcon("separator") + '" ></span>\
			{{/unless}}\
			<li class="list-group-item" data-params="{{id}}">\
				<span class="s-m-filter-info"> \
					<span class="s-m-filter-field">{{fieldName}}</span>\
					<span class="s-m-filter-operator">{{operatorLabel}}</span>\
					<span class="s-m-filter-value">{{value}}</span>\
				</span>\
				<span class="s-m-filter ' + fontUtils.filterIcon("edit") + '" data-params="edit,{{@index}}"></span>\
				<span class="s-m-filter ' + fontUtils.filterIcon("delete") + '" data-params="delete,{{@index}}"></span>\
			</li>\
		{{/each}}'
};


var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

/**
 * Filter tab
 */
var _Klass = utils.defineClass(

	function(panel, id, options) {
		Base.call(this, panel, id, options);
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this.filterEdit) {
				this.filterEdit.destroy();
				this.filterEdit = null;
			}
			this.filterInfo = null;
			this.$$listSectio = null;
			this.$$list = null;
			this.$$editSection = null;
		},
		buildHtml: function() {
			this.$$content.append($(_getHtml("main", {})));
			this.$$editSection = this.$$content.find("#filteredit");
			this.$$listSection = this.$$content.find("#filterlist");
			$(_getHtml("filterList", {
				addFilter: locale.text("panels.array.addFilter"),
				emptyList: locale.text("panels.array.emptyList")
			})).appendTo(this.$$listSection);
			this.$$list = this.$$listSection.find(".list-group");
			this.$$emptyList = this.$$content.find("#filterListEmpty");
		},
		/**
		 * Tab becomes Active - we create content
		 */
		doTabShow: function() {
			if (this.initOpened) return;
			this.updateFilterList();
			this.initOpened = true;
		},
		/**
		 * Update filter list . If no filter set, display no filter information
		 **/
		updateFilterList: function(list) {
			// We clone to keep a different copy from array one
			this.filterInfo = list || (this.filterInfo && this.filterInfo.length > 0) ? this.filterInfo : $.extend(true, [], this.panel.getParentArray().filterInfoGet());
			this.$$emptyList.toggle(false);
			// clean current list
			this.$$list.empty();
			if (this.filterInfo && this.filterInfo.length > 0) {
				// append list
				var $$items = $(_getHtml("items", {
					items: this.filterInfo
				}));
				this.$$list.append($$items);
			} else {
				// no filter set
				this.$$emptyList.toggle(true);
			}
			this.updateGesture();
		},
		/**
		 * Save sort info
		 */
		doActionApply: function(evt, $$target) {
			this.panel.getParentArray().filterInfoSet($.extend(true, [], this.filterInfo), true);
			return true;
		},
		saveInfos: function() {
			var values = this.panel.saveInfos();
			if (values) {
				var notify = {
					severityClass: "success",
					title: values.title,
					body: locale.text("panels.array.memo.created"),
					onlyWebapp: true
				};
				globals.getModal().notify(notify);
			}
		},
		getInfo: function() {
			return $.extend(true, [], this.filterInfo);
		},
		/**
		 * Click on an element with data-param - edit delete...
		 */
		doContentAction: function(evt, $$target, dataParams) {
			if (!dataParams) return;
			var params = dataParams.split(",");
			switch (params[0]) {
				case "addFilter":
					this._openFilterEdit();
					break;
				case "cancelFilterEdit":
					this.filterEdit.onCancelEdit();
					break;
				case "submitFilterEdit":
					this.filterEdit.onFilterEditSubmit();
					break;
				case "delete":
					var idx = params[1];
					this._onFilterDelete(idx);
					break;
				case "edit":
					var idx = params[1];
					this._openFilterEdit(idx);
					break;
				default:
					return;
			}
		},
		/*
		 *	When user deletes one filter in filter list
		 */
		_onFilterDelete: function(idx) {
			if (this._isIndexValid(idx)) {
				this._removeFilter(idx);
				// argument this.fileterInfo when call updateFilterList to avoid get list from cache.
				this.updateFilterList(this.filterInfo);
			}
		},
		/*
		* Adds new filter info
		* {
			fieldName: "field name",
			operator: "selected operator label",
			value: "filtering value"
		}
		*/
		_addFilter: function(newFilterInfo) {
			this.filterInfo.push(newFilterInfo);
		},
		/*
		 * Remove filter
		 */
		_removeFilter: function(idx) {
			if (this._isIndexValid(idx)) {
				this.filterInfo.splice(idx, 1);
			}
		},
		/*
		 * Update filter
		 */
		_updateFilter: function(idx, updateFilterInfo) {
			if (this._isIndexValid(idx)) {
				this.filterInfo.splice(idx, 1, updateFilterInfo);
			}
		},
		/*
		 * If user cancels filter edit, hide form and show filters list
		 */
		_onCancelEdit: function() {
			this.$$editSection.empty();
			this.$$listSection.toggle(true);
		},
		/*Build filter set/add form */
		_openFilterEdit: function(filterIdx) {
			// get filter edit object
			this.filterEdit = this.filterEdit || new FilterEdit(this);

			// set init data
			if (this._isIndexValid(filterIdx)) {
				this.filterEdit.setInitData(this.filterInfo[filterIdx], filterIdx);
			}

			// create filter edit content
			this.filterEdit.create(this.$$editSection);

			// hide filter list
			this.toggleList(false);

		},
		_isIndexValid: function(idx) {
			return !isNaN(parseInt(idx, 10)) && idx >= 0;
		},
		onFilterUpdate: function(filterInfo, filterIdx) {
			if (this._isIndexValid(filterIdx)) {
				this._updateFilter(filterIdx, filterInfo);
			} else {
				this._addFilter(filterInfo);
			}

			// update list
			this.updateFilterList();

			// show list
			this.toggleList(true);
		},
		toggleList: function(show) {
			this.$$listSection.toggle(show);
			if (this.filterEdit) {
				this.filterEdit.$$content.toggle(!show);
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabMemo',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/controls/page/panels/sortfilter/tabBase','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var Base = require('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabBase').Klass;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _templates = {
	main: '\
		<div id="memotabroot" class="s-m-scroll-wrapper" style="height:100%">\
			<div  class="s-m-scroll-elmt">\
				<ul class="list-group"/>\
			</div>\
		</div>',
	items: '\
		{{#each items}}\
			<li class="list-group-item" data-params="{{@index}}">\
				<span class="s-m-memo-info"><a draggable="false" href="#" data-params="click">{{title}}</a>\
				<div style="display:none" class="s-m-value edit"><input class="s-m-meta form-control" type="text" value="{{title}}"></div>\
				</span>\
				<span class="s-m-memo ' + fontUtils.filterIcon("edit") + '" data-params="edit"></span>\
				<span class="s-m-memo ' + fontUtils.filterIcon("delete") + '" data-params="delete"></span>\
			</li>\
		{{/each}}',
	/** Add this line to add the remove icon
	 * <span class="s-m-order ' + fontUtils.sortIcon("none") + ' " data-params="none"></span>
	 */
};


var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};
/**
 * Sort tab
 */
var _Klass = utils.defineClass(
	function(panel, id, options) {
		options = options || {};
		options.hidden = false;
		Base.call(this, panel, id, options);
		this.currentSelection = null;
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.$$edit = null;
			this.$$display = null;
			this.currentSelection = null;
		},
		buildHtml: function() {
			this.$$content.append($(_getHtml("main", {})));
			this.$$list = this.$$content.find("ul.list-group");
			this.$$list.css({
				height: "auto",
				position: "relative"
			});
			this.$$list.on('blur', "input", jsutils.bindFn(this.onBlur, this));
		},
		/**
		 * We remove the content on close to cancel modifications
		 */
		notifyClosePanel: function() {
			Base.prototype.notifyClosePanel.call(this);
			if (this.$$items) {
				this.$$items.remove();
				this.$$items = null;
			}
		},
		/**
		 * Tab becomes Active - we create content
		 */
		doTabShow: function() {
			Base.prototype.doTabShow.call(this);
			this._render();
			this._setButtonsState();
		},
		_setButtonsState: function() {
			this.panel.setButtonsState(false, this.currentSelection != null); //currentSelection could be undefined
		},
		_render: function() {
			if (this.$$items) this.$$items.remove();
			// We clone to keep a different copy from array one		
			this.$$items = $(_getHtml("items", {
				items: this.panel.items,
			}));
			this.$$list.append(this.$$items);
			if (this.currentSelection != null) this._selectCurrent(this.currentSelection);
			this.updateGesture();
		},
		doContentAction: function(evt, $$target, dataParams) {
			if (!dataParams) return;
			switch (dataParams) {
				case "delete":
					var idx = $$target.closest("li").index();
					this._onMemoDelete(idx);
					break;
				case "edit":
					this._openMemoEdit($$target.closest("li"));
					break;
				case "click":
					var idx = $$target.closest("li").index();
					this._onMemoClick(idx);
					break;
				default:
					return;
			}
		},
		saveInfos: function() {
			if (this.panel.saveInfos()) {
				this.panel.savePrefs();
				this._render();
			}
		},
		_onMemoDelete: function(idx) {
			this._unSelectCurrent();
			this.panel.items.splice(idx, 1);
			this.panel.savePrefs();
			this._render();
		},
		_openMemoEdit: function(li) {
			this.$$edit = $(li).find(".s-m-value.edit");
			this.$$display = $(li).find("a");
			this._setEditMode();

		},
		_onMemoClick: function(idx) {
			if (idx != this.currentSelection) {
				this._unSelectCurrent();
			};
			this._selectCurrent(idx);
		},
		_unSelectCurrent: function() {
			this.$$list.find(".selected").toggleClass("selected");
			this.currentSelection = null;
			this._setButtonsState();
		},
		_selectCurrent: function(idx) {
			this.currentSelection = idx;
			this.$$list.find("[data-params='" + this.currentSelection + "']").toggleClass("selected");
			this._setButtonsState();
		},
		onBlur: function() {
			this._updateValue();
			this._setDisplayMode();
		},
		_setDisplayMode: function() {
			this.$$edit.toggle(false);
			this.$$display.toggle(true);
			this.$$edit = null;
			this.$$display = null;
		},
		_setEditMode: function() {
			this._unSelectCurrent();
			this.$$edit.toggle(true);
			this.$$display.toggle(false);
			this.$$edit.children().focus();
			this.$$edit.children().select();
		},
		_updateValue: function() {
			var idx = this.$$display.closest("li").index();
			var value = this.$$edit.children().val();
			this.$$display.text(value);
			this.panel.items[idx].title = value;
			this.panel.savePrefs();
		},
		doActionApply: function() {
			if (this.currentSelection !== null) {
				this.panel.getParentArray().sortInfoSet($.extend(true, [], this.panel.items[this.currentSelection].sort), false);
				this.panel.getParentArray().filterInfoSet($.extend(true, [], this.panel.items[this.currentSelection].filter), true);
				this.panel.close();
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/sortfilter/filterSortPanel',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/controls/page/panels/sidePanel','syracuse-tablet/html/js/controls/page/panels/sortfilter/tabSort','syracuse-tablet/html/js/controls/page/panels/sortfilter/tabFilter','syracuse-tablet/html/js/controls/page/panels/sortfilter/tabMemo','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/userPrefs'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var Base = require('syracuse-tablet/html/js/controls/page/panels/sidePanel').Klass;
var _Sort = require('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabSort').Klass;
var _Filter = require('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabFilter').Klass;
var _Memo = require('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabMemo').Klass;
var locale = require('syracuse-tablet/html/js/helpers/locale');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var userPreferences = require('syracuse-tablet/html/js/helpers/userPrefs');
var _templates = {
	main: '\
		<section class="s-m-side-panel {{side}}">\
			<nav class="nav-header">\
				<nav class="title">\
					<div >{{title}}</div>\
				</nav>\
				<div class="btn-group header-btn" role="group">\
					<a type="button" class="btn btn-default ' + fontUtils.sortFilterTab("memo") + '" data-params="memo"></a>\
					<a type="button" class="btn btn-default ' + fontUtils.sortFilterTab("apply") + '" data-params="apply"></a>\
				</div>\
			</nav>\
			<ul class="nav nav-pills" role="tablist"> \
				{{#each tabs}}\
					<li><a href="#{{id}}" class="" role="tab" data-toggle="tab">{{title}}</a></li> \
				{{/each}}\
			</ul> \
			<div class="tab-content">\
				{{#each tabs}}\
					<div id="{{id}}" role="tabpanel" class="tab-pane {{type}}">\
					</div>\
				{{/each}}\
			</div> \
		</section>',
};


var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

var _tabDescr = [{
	klass: _Sort,
	options: {
		name: "sort",
		isActive: true,
		singleCriteria: true,
	}
}, {
	klass: _Filter,
	options: {
		name: "filter",
		isActive: false,
	}
}, {
	klass: _Memo,
	options: {
		name: "memo",
		isActive: false
	}
}];

/**
 * Arrays Sort/Filter panel
 * Options
 * 		parentArray: 	parent array control
		filter: 		false to hide filter tab
		sort: 			false to hide sort tab
 */
var _Klass = utils.defineClass(
	function(controller, $type, panelId, options) {
		options = options || {};
		// Scroller is managed by tabs
		options.enableGesture = false;
		this._tabs = {};
		Base.call(this, controller, $type, panelId, options);
		this._userPrefs = userPreferences.createUserPrefs("memo", controller.sDataUrl);
		var prefs = this._userPrefs.getPrefs();
		if (prefs && prefs.params) {
			this.items = prefs.params;
		}
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._userPrefs) {
				this._userPrefs.destroy();
				this._userPrefs = null;
			}
			this._activeTab = null;
			this.options.parentArray = null;
			var self = this;
			notifications.unsubscribe(self, ["sm.click.icon.filterSort"]);
			if (this._tabs) {
				$.each(this._tabs, function(key, value) {
					value.destroy();
				});
				this._tabs = null;
			}
			if (this.$$btnBar) {
				this.$$btnBar.unbind();
				this.$$btnBar.remove();
				this.$$btnBar = null;
			}
		},
		getParentArray: function() {
			return this.options.parentArray;
		},
		/**
		 * Build panel and tabs html
		 */
		buildHtml: function(side) {
			var self = this;
			notifications.subscribe(self, ["sm.click.icon.filterSort"]);
			Base.prototype.buildHtml.call(this, side);
			self.$$elmt.addClass(self.typeName);
			if (self.$$panel) {
				self.$$panel.remove();
			}
			var ctx = {
				title: locale.text("panels.array.title"),
				ctrlId: self.id,
				side: side,
				apply: locale.text("panels.array.apply"),
				close: locale.text("panels.array.close"),
				/* There's no titles for queries*/
				tabs: [],
			};
			var descriptions = [];
			/**
			 * We can disable filter or sort with self.options.filter = false or  self.options.sort
			 */
			_tabDescr.forEach(function(descr) {
				descr = $.extend({}, descr);
				descr.options.hidden = self.options[descr.options.name] === false;
				descriptions.push(descr);
			});
			var ids = {};
			descriptions.forEach(function(descr) {
				ids[descr.options.name] = utils.readableuid("array" + descr.options.name);
				ctx.tabs.push({
					id: ids[descr.options.name],
					//title: descr.title || locale.text("panels.array." + descr.options.name),
					icon: fontUtils.sortFilterTab(descr.options.name),
					type: descr.options.name,
					buttons: descr.options.buttons,
					title: locale.text("panels.array." + descr.options.name),
				});
			});
			self.$$panel = $(_getHtml("main", ctx));
			if (self.$$panel && self.$$panel.length) {
				self.$$elmt.append(self.$$panel);
				var visibleTabs = [];
				var activeIdx = -1;
				// Create tabs
				descriptions.forEach(function(descr, idx) {
					var t = new descr.klass(self, ids[descr.options.name], descr.options);
					if (descr.options.hidden) {
						t.hide();
					} else {
						visibleTabs.push(t);
						if (descr.options.isActive) {
							activeIdx = idx;
						}
					}
					self._tabs[descr.options.name] = t;
				});
				if (visibleTabs.length > 0) {
					this._activeTab = visibleTabs[activeIdx === -1 ? 0 : activeIdx];
					// Adjust width
					var width = visibleTabs.length === 1 ? "100%" : Math.round(1000 * 100 / visibleTabs.length) / 1000 + "%";
					visibleTabs.forEach(function(t) {
						t.setWidth(width);
					});
					self.$$btnBar = self.$$panel.find('.nav-header>.btn-group.header-btn');
					self.$$btnBar.on('click', '[data-params]', jsutils.bindFn(self.onBtnBarClick, this));
				} else {
					this.close();
				}
			}
		},
		/**
		 * Notification when panel is opened/closed
		 * Pass event to tabs
		 */
		notifyToggled: function(side, action, visible) {
			Base.prototype.notifyToggled.call(this, side, action, visible);
			$.each(this._tabs, function(id, tab) {
				tab[visible ? "notifyOpenPanel" : "notifyClosePanel"]();
			});
			if (visible && this._activeTab) {
				this._activeTab.triggerActivate();
			}
		},
		onResize: function(context) {
			Base.prototype.onResize.call(this, context);
			if (this.destoyed || !this._tabs) return;
			$.each(this._tabs, function(id, tab) {
				tab.onResize(context);
			});
		},
		onBtnBarClick: function(evt) {
			evt.preventDefault();
			evt.stopPropagation();
			var $$target = $(evt.target);
			var params = $$target.attr("data-params");
			switch (params) {
				case "apply":
					if (this._activeTab && this._activeTab.doActionApply(evt, $$target) === true) {
						this.close();
					}
					break;
				case "memo":
					if (this._activeTab) {
						this._activeTab.saveInfos();
					}
					break;
			}
		},
		saveInfos: function() {
			var values = null;
			this.items = this.items || [];
			$.each(this._tabs, function(key, value) {
				if (value.getInfo) {
					values = values || {};
					values[key] = value.getInfo();
				}
			});
			if (values) {
				values.title = locale.text("panels.array.memo") + " " + utils.getCurISODateTime();
				this.items.push(values);
				this.savePrefs();
			};
			return values;
		},
		savePrefs: function() {
			this._userPrefs.savePrefs({
				params: this.items
			});
		},
		notifyActiveTab: function(tab) {
			this._activeTab = tab;
			this.setButtonsState(true, true);
		},
		/*
		 *	Returns panel tabs
		 */
		getTabs: function() {
			return this._tabs;
		},
		notifClickIconFilterSort: function(context) {
			if (context && context.className) {
				if (context.className.indexOf("sorted") >= 0) {
					this.getTabs()["sort"].triggerActivate();
				} else if (context.className.indexOf("filtered") >= 0) {
					this.getTabs()["filter"].triggerActivate();
				}
			}
		},
		setButtonsState: function(memo, apply) {
			this.$$btnBar.find("[data-params='memo']").toggleClass("disabled", !memo);
			this.$$btnBar.find("[data-params='apply']").toggleClass("disabled", !apply);
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/dialogPanel',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/page/panels/sidePanel'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/page/panels/sidePanel').Klass;

var _templates = {
	header: '\
		<div class="header">\
		<buttons class="pull-right"> \
			<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-control-id="{{ctrlId}}" data-action="cancel"></button>\
		</buttons> \
		<div class="modal-title">{{title}}</div> \
		</div>\
		'
};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	if (!tmpl) alert("template " + name + " not found");
	return tmpl(ctx);
};
/**
 * Base left/right panel control for dashBoards and regular pages
 * 	Adapted from Metro Bootstrap navbar-side
 */
var _Klass = utils.defineClass(

	function(controller, $type, panelId, options) {
		options = options || {};
		options.enableGesture = true;
		Base.call(this, controller, $type, panelId, options);
	}, Base, {

		buildHtml: function(side, title) {
			Base.prototype.buildHtml.call(this, side);
			this.$$elmt.addClass("s-m-dialogPanel");
			if (this.$$header) {
				this.$$header.remove();
			}
			var ctx = {
				side: side,
				ctrlId: this.id,
				title: title
			};
			this.$$header = this.buildHeader(ctx);
			if (this.$$header && this.$$header.length) {
				this.$$elmt.append(this.$$header);
			}
		},
		buildHeader: function(ctx) {
			return $(_getHtml("header", ctx));
		},
		isEnabled: function() {
			return true;
		},
		_actCancel: function() {
			this.close();
		},
		_actValidate: function() {
			this.close();
		},
		onClick: function(evt) {
			return true;
		},
		// To allow display
		hasLinks: function() {
			return true;
		},
		/**
		 * dialogpanel class to adapt the with for dialog panel
		 */
		attach: function($$parent, side) {
			Base.prototype.attach.call(this, $$parent, side);
			$$parent.addClass("dialogpanel");
		},
		detach: function() {
			if (this.$$elmt) {
				this.$$elmt.parent().removeClass("dialogpanel");
			}
			Base.prototype.detach.call(this);
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/pageSharePanel',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/page/panels/dialogPanel','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/selectorFactory','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/page/panels/dialogPanel').Klass;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var selectorFactory = require('syracuse-tablet/html/js/ui/selectorFactory');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');

var locale = require('syracuse-tablet/html/js/helpers/locale');
var _templates = {
	main: '\
			<nav class="navbar s-m-side-panel {{side}} navbar-inverse" role="navigation">\
				<div class="s-m-scroll-elmt">\
				{{#if liveTile}}\
					<div class="modal-subtitle">{{liveTile.title}}</div> \
					<div class=""> \
						<div class="form-group"> \
							<table class="s-m-livetile">\
							{{#each liveTile.items}}\
							{{# unless this.disabled}}\
							<tr>\
							<td>{{this.label}}</td>\
							<td>\
							{{#if this.picker }}\
								<div  class="input-group" id="{{this.id}}" style="width:100%">\
								<\div>\
							{{else}}\
								<input type="text" \
								{{#if this.mandatory}}\
									mandatory="mandatory"\
								{{/if}}\
								class="form-control" size="{{this.size}}" id="{{this.id}}" value="{{defaultValue}}">\
							{{/if}}\
							</td>\
							</tr> \
							{{/unless}}\
							{{/each}}\
							</table> \
							<div class="btn-group btn-group-justified" role="group">\
								<a type="button" class="btn btn-default" data-action="liveTileCreate" data-control-id="{{ctrlId}}" disabled>{{liveTile.btnApply}}</a>\
							</div>\
						</div> \
					</div>\
				{{/if}}\
				{{#if vignette.liveTile}}\
					<div class="modal-subtitle">{{vignette.liveTile.title}}</div> \
					<div class=""> \
						<div class="form-group"> \
							<table class="s-m-livetile">\
							{{#each vignette.liveTile.items}}\
							{{# unless this.disabled}}\
							<tr>\
							{{#if this.picker }}\
								<td>{{this.label}}</td>\
								<td>\
								<div  class="input-group" id="{{this.id}}" style="width:100%">\
								<\div>\
								</td>\
							{{else}}\
								{{#if this.select}}\
									{{#if ../../../../singleVignette}}\
										<input type="hidden" id="{{this.id}}" value="{{../../../../../singleVignette}}">\
									{{else}}\
									<td>{{this.label}}</td>\
									<td>\
									<select class="form-control"  id="{{this.id}}" data-action="{{this.dataAction}}" data-control-id="{{../../../../../ctrlId}}">\
										<option value="">{{this.emptyOptionLabel}}</option>\
									{{#each ../../../../../vignette.items}}\
										<option value="{{this.id}}">{{this.title}}</option>\
									{{/each}}\
									</select>\
									</td>\
									{{/if}}\
								{{else}}\
									<td>{{this.label}}</td>\
									<td>\
									<input type="text"  \
										{{#if this.mandatory}}\
										mandatory="mandatory"\
										{{/if}}\
										class="form-control" size="{{this.size}}" id="{{this.id}}" value="">\
									</td>\
								{{/if}}\
							{{/if}}\
							</tr> \
							{{/unless}}\
							{{/each}}\
							</table> \
							<div class="btn-group btn-group-justified" role="group">\
								<a type="button" class="btn btn-default" data-action="liveTileCreate" data-control-id="{{ctrlId}}">{{vignette.liveTile.btnApply}}</a>\
							</div>\
						</div> \
					</div>\
				{{/if}}\
				{{#if scheduleMessage}}\
					<div class="modal-subtitle">{{scheduleMessage.title}}</div> \
					<div class=""> \
						<div class="form-group"> \
							<table class="s-m-schedulemsg">\
							{{#each scheduleMessage.items}}\
							<tr>\
							<td>{{this.label}}</td>\
							<td>\
							{{#if this.picker }}\
								<div  class="input-group">\
									<input type="text" readonly="true" class="form-control" size="{{this.size}}" id="{{this.id}}" value="">\
									<span class="input-group-btn">\
										<button data-control-id="{{../../ctrlId}}" data-action="{{this.dataAction}}" data-params="{{this.id}} "class="btn btn-default">\
										<span class="{{this.icon}}"></span>\
									<\span>\
								<\div>\
							{{else}}\
								<input type="text"  \
								{{#if this.mandatory}}\
									mandatory="mandatory"\
								{{/if}}\
								class="form-control" size="{{this.size}}" id="{{this.id}}" value="">\
							{{/if}}\
							</td>\
							</tr>\
							{{/each}}\
							</table> \
							<div class="btn-group btn-group-justified" role="group">\
								<a type="button" class="btn btn-default" data-action="reminderCreate" data-control-id="{{ctrlId}}">{{scheduleMessage.btnApply}}</a>\
							</div>\
						</div> \
					</div>\
				{{/if}}\
				{{#if share}}\
					<div class="modal-subtitle" >{{share.title}}</div> \
					<div class="btn-group btn-group-justified" role="group">\
						<a type="button" href="#" class="btn btn-default" data-control-id="{{ctrlId}}" data-action="sharePageLink">\
							<i class="{{share.icon}}"/>\
						<span>{{{share.label}}}</span>\
						</a>\
					</div> \
				{{/if}}\
				<\div>\
			</nav>',
};
var _liveTile = [{
	disabled: true,
	id: "vignette",
	select: true,
	dataAction: "choice",
	mandatory: true
}, {
	disabled: false,
	id: "backgroundColor",
	size: 10,
	picker: true,
	component: "colorPalettePicker"
}, {
	disabled: false,
	id: "description",
	size: 50,
	type: "application/x-string",
	defaultValue: "",
	mandatory: true
}];
var _scheduleMsgItems = [{
	id: "date",
	size: 10,
	type: "application/x-date",
	icon: fontUtils.getIconByName("datePicker"),
	picker: true,
	dataAction: "datePicker",
	mandatory: true
}, {
	id: "time",
	size: 10,
	type: "application/x-time",
	icon: fontUtils.getIconByName("timePicker"),
	picker: true,
	dataAction: "timePicker",
	mandatory: true
}, {
	id: "description",
	size: 50,
	type: "application/x-string",
	mandatory: true
}];
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	if (!tmpl) alert("template " + name + " not found");
	return tmpl(ctx);
};

var _Klass = utils.defineClass(

	function(controller, $type, panelId, options) {
		Base.call(this, controller, $type, panelId, options);
	}, Base, {
		buildHtml: function(side) {
			var self = this;
			this._context = this._getContext();
			Base.prototype.buildHtml.call(this, side, this._context.title);
			if (this.$$panel) {
				this.$$panel.remove();
			}
			this.$$panel = this.buildPanel(this._context);
			if (this.$$panel && this.$$panel.length) {
				this.$$elmt.append(this.$$panel);
				var component;
				_liveTile.forEach(function(item) {
					if (item.component) {
						self.components = self.components || {};
						var $$item = self.$$elmt.find(".s-m-livetile #" + item.id);
						var opts = {};
						switch (item.component) {
							case "colorPalettePicker":
								opts = {
									id: item.id,
									palette: authPropsGeneral.getColorPalette(),
									dropUp: false,
									onSelectColor: jsutils.bindFn(self._colorChange, self)
								};
								break;
						}
						self.components[item.id] = authComponents.newComponent(item.component, opts);
						self.components[item.id].createMarkup($$item);

					};
				});
			};
			this.$$panel.on('blur', "[mandatory]", jsutils.bindFn(this.onBlur, this));
		},
		_colorChange: function(value) {
			/*
			 * bgColor: "rgb(0, 159, 218)"
				color: "rgb(255, 255, 255)"
				css: "s-m-color-blue"
				id: "blue"
				name: "Blue",
				hex:""
			 */
			// colors are given by componet (jQuery.css)
			this.liveTile.backgroundColor = value ? value.hex : null;
			// Color is set even if not needed - Code review
			this.liveTile.color = value ? value.hex : null;
		},
		/**
		 * Override this method to build child class
		 */
		buildPanel: function(context) {
			return $(_getHtml("main", context));
		},
		hasLinks: function() {
			return true;
		},
		_getContext: function() {
			var pageContext = this.controller.getPageShareContext();
			var ctx = {
				ctrlId: this.id,
				side: this.side
			};
			var buildCtxLiveTile = function(ctx) {
				var ctx;
				_liveTile.forEach(function(item) {
					item.label = locale.text("liveTile." + item.id + ".label");
					if (item.select) item.emptyOptionLabel = locale.text("liveTile." + item.id + ".label.emptychoice");
					if (item.defaultValue !== undefined) {
						item.defaultValue = ctx.title;
					}
				});
				ctx = {
					title: locale.text("liveTile.page.subtitle"),
					btnApply: locale.text("liveTile.apply.label"),
					items: _liveTile
				};
				return ctx;
			};
			var buildCtxScheduleMessage = function() {
				var ctx;
				_scheduleMsgItems.forEach(function(item) {
					item.label = locale.text("schedule.message." + item.id + ".label");
				});
				ctx = {
					title: locale.text("schedule.message.page.subtitle"),
					btnApply: locale.text("schedule.message.apply.label"),
					items: _scheduleMsgItems
				};
				return ctx;
			};
			var builCtxShare = function() {
				var ctx;
				ctx = {
					title: locale.text("share.page.subtitle"),
					icon: fontUtils.pageIcon("nativeShare"),
					label: locale.text("action.nativeShare")
				};
				return ctx;
			};
			ctx.title = pageContext.ctx.pageTitle || "";
			if (pageContext.opt.liveTile) {
				ctx.liveTile = buildCtxLiveTile(ctx);
			};
			if (pageContext.opt.scheduleMessage) {
				ctx.scheduleMessage = buildCtxScheduleMessage();
			};
			if (pageContext.opt.share) {
				ctx.share = builCtxShare();
			};
			pageContext.vignettes.forEach(function(vignette) {
				ctx.vignette = ctx.vignette || {};
				ctx.vignette.items = ctx.vignette.items || [];
				ctx.vignette.items.push({
					opt: vignette.opt,
					title: vignette.ctx.pageTitle,
					id: vignette.id
				});
				Object.keys(vignette.opt).forEach(function(key) {
					ctx.vignette[key] = ctx.vignette[key] || vignette.opt[key] || false;
				});
			});
			ctx.singleVignette = (pageContext.vignettes.length === 1) ? ctx.vignette.items[0].id : false;
			if (ctx.vignette && ctx.vignette.liveTile) {
				this._getItemLiveTile("vignette").disabled = false;
				ctx.vignette.liveTile = buildCtxLiveTile(ctx);
			} else {
				this._getItemLiveTile("vignette").disabled = true;
			}
			return ctx;
		},
		_setData: function() {
			var self = this;
			if (!self._context) return;
			this.liveTile = {};
			if (self._context.scheduleMessage) {
				_scheduleMsgItems.forEach(function(item) {
					var $$item = self.$$elmt.find(".s-m-schedulemsg #" + item.id);
					$$item.val("");
					$$item.attr("isoValue", "");
				});
			}
			if (self._context.vignette) {
				if (self._context.singleVignette) {
					self.$$elmt.find(".s-m-livetile #description").val(self._context.vignette.items[0].title);
				} else {
					_liveTile.forEach(function(item) {
						if (!item.disabled) {
							if (!item.component) {
								self.$$panel.find(".s-m-livetile #" + item.id).val("");
							}
						}
					});
				}
			};
			if (self.components) {
				Object.keys(self.components).forEach(function(key) {
					self.components[key].setValue("");
				});
			}
			this._setButtonsStat();
		},
		_setButtonsStat: function() {
			var self = this;
			var btnCreate = self.$$elmt.find("a[data-action='liveTileCreate']"),
				disable = false,
				val = "";
			_liveTile.forEach(function(item) {
				if (!item.disabled && item.mandatory) {
					disable = disable || (self.$$panel.find(".s-m-livetile #" + item.id).val() == "");
				}
			});
			if (disable) {
				btnCreate.attr("disabled", "disabled");
			} else {
				btnCreate.removeAttr("disabled");
			};
			btnCreate = self.$$elmt.find("a[data-action='reminderCreate']"), disable = false, val = "";
			_scheduleMsgItems.forEach(function(item) {
				if (!item.disabled && item.mandatory) {
					disable = disable || (self.$$panel.find(".s-m-schedulemsg #" + item.id).val() == "");
				}
			});
			if (disable) {
				btnCreate.attr("disabled", "disabled");
			} else {
				btnCreate.removeAttr("disabled");
			};
		},
		onBlur: function() {
			this._setButtonsStat();
		},
		onValueChange: function() {
			this._setButtonsStat();
		},
		notifyToggled: function(side, action, visible) {
			Base.prototype.notifyToggled.call(this, side, action, visible);
			if (visible) this._setData();
		},
		_getItemLiveTile: function(id) {
			var found;
			_liveTile.some(function(item) {
				if (item.id === id) {
					found = item;
					return true;
				}
			});
			return found;
		},
		_actChoice: function(id) {
			var btnCreate = this.$$elmt.find("a[data-action='liveTileCreate']");
			var value = this.$$elmt.find(".s-m-livetile #vignette").val();
			var itemDescription = this._getItemLiveTile("description");
			if (itemDescription && !itemDescription.disabled && itemDescription.defaultValue !== undefined) {
				this.$$elmt.find(".s-m-livetile #description").val(value ? this.$$elmt.find(".s-m-livetile #vignette option:selected").text() : "");
			}
			this._setButtonsStat();
		},
		_actDatePicker: function(id) {
			selectorFactory.createSelector(new _Field("application/x-date", this.$$panel.find(".s-m-schedulemsg #" + id), locale.text("schedule.message." + id + ".label"), this));
		},
		_actTimePicker: function(id) {
			selectorFactory.createSelector(new _Field("application/x-time", this.$$panel.find(".s-m-schedulemsg #" + id), locale.text("schedule.message." + id + ".label"), this));
		},
		_actReminderCreate: function() {
			var schedule = {}, self = this;
			_scheduleMsgItems.forEach(function(item) {
				var val = self.$$panel.find(".s-m-schedulemsg #" + item.id).attr("isoValue");
				if (val) {
					schedule[item.id] = schedule[item.id] || {};
					schedule[item.id].$type = item.$type;
					schedule[item.id].value = val;
				}
			});
			if (schedule.date && schedule.time) {
				var content = {
					Severity: "reminder",
					Text1: self._context.title,
					Text2: schedule["description"] ? schedule["description"].value : "",
					ScheduleTime: schedule["date"].value + " " + schedule["time"].value
				};
				notifications.notifyController("sm.page.share", this.controller, "schedule", content);
				_scheduleMsgItems.forEach(function(item) {
					self.$$panel.find(".s-m-schedulemsg #" + item.id).val("");
				});
			}
			self.close("close");
		},
		_actSharePageLink: function() {
			notifications.notifyController("sm.page.share", this.controller, "link");
			this.close("close");
		},
		_actLiveTileCreate: function() {
			var self = this,
				content = {};
			var val;
			_liveTile.forEach(function(item) {
				if (!item.disabled) {
					if (self.liveTile && self.liveTile[item.id]) {
						content[item.id] = self.liveTile[item.id];
					} else {
						content[item.id] = self.$$panel.find(".s-m-livetile #" + item.id).val();
					}
				}
			});
			if (content) {
				if (self.liveTile.color) {
					// color of the text is propagated
					content.color = self.liveTile.color;
				}
				content.title = content.description;
				delete content.description;
				notifications.notifyController("sm.page.share", this.controller, "liveTile", content);
			}
			this.close("close");
		}
	});

var _Field = utils.defineClass(
	function(type, item, title, panel) {
		this.$type = type;
		this.$title = title;
		this.$$item = item;
		this.panel = panel;
	}, null, {
		setFieldValueFromSelector: function(value) {
			this.$$item.attr("isoValue", value);
			this.$$item.val(this._getFormattedValue(value));
			if (this.panel.onValueChange) {
				this.panel.onValueChange();
			};
			this.destroy();
		},
		_getFormattedValue: function(value) {
			var formatter = formatApi.getFormatter(this.$type);
			return formatter.formatValue(value, false);
		},
		getValue: function() {
			return this.$$item.attr("isoValue");
		},
		getTitle: function() {
			return this.$title;
		},
		destroy: function() {;
			this.$$item = this.panel = null;
		}
	});
exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/pageTemplatePanel',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/controls/page/panels/dialogPanel','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var Base = require('syracuse-tablet/html/js/controls/page/panels/dialogPanel').Klass;
var locale = require('syracuse-tablet/html/js/helpers/locale');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

// !! Id's and classes are used in side-panel.less
var CREATE_BTN = "tmpl-panel-create-btn";
var CREATE_BTN_ADDON = "tmpl-panel-create-btn-clear-addon";
var ITEM_TTL = "s-m-tmpl-itm-ttl";
var ITEM_INFO = "s-m-tmpl-itm-info";
var ITEM_TABLE = "s-m-tmpl-itm";
var ITEM_ACT = "s-m-tmpl-itm-act";
var LST_WRAP = "s-m-list-wrapper";
var LST_SCROLL = "s-m-scroll-elmt";
var ITEM_INPUT_TTL = "tmpl-panel-item-input-ttl";
var ITEM_INPUT_TTL_ADDON = "tmpl-panel-item-input-ttl-addon";
var FILTER_MENU = "tmpl-panel-filter";

var _txt = function(id) {
	return locale.text("edit.templates.dlog." + id);
};
var _templates = {
	error: '<section class="draft-error"><h1>{{error}}<h1><h2>{{contact}}<h2></section>',
	main: '\
		<article style="height:100%">\
			<section class="panel panel-default create">\
				<div class="panel-heading">{{createSection}}</div>\
				<div class="panel-body">\
					<table style="width:100%"><tr>\
						<td>{{name}}</td>\
						<td>\
							<div class="input-group {{#if smartphone}}input-group-sm{{/if}}">\
								<input id="{{CREATE_BTN}}" class="ctrl-evt-input form-control" aria-describedby="create-clear-addon" type="text"/>\
								<span  data-action="clearname" data-control-id="{{ctrlId}}" class="input-group-addon" id="{{CREATE_BTN_ADDON}}">X</span>\
							</div>\
						</td>\
						<td>\
							<span class="btn btn-default disabled" data-action="create" data-control-id="{{ctrlId}}">\
								<i class="{{createicn}}"></i>\
								<span>{{create}}</span>\
							</span>\
						</td>\
					</tr></table>\
				</div>\
			</section>\
			<section class="panel panel-default avail">\
				<div class="panel-heading">\
					<span>{{availSection}}</span>\
				</div>\
				<div class="{{LST_WRAP}}">\
					<ul class="list-group {{LST_SCROLL}}">\
					</ul>\
				</div>\
			</section>\
		</article>',
	items: '\
		{{#each items}}\
			<li class="list-group-item" data-params="{{tmplId}}">\
				<table class="{{../ITEM_TABLE}}"><tr>\
					<td>\
						<div class="{{../ITEM_TTL}}" data-action="changeItemTitle" data-control-id="{{../ctrlId}}">{{title}}</div>\
						<div class="{{../ITEM_INFO}}"style="overflow: hidden">\
							<span>{{date}}</span>\
							<span>{{representation}}</span>\
						</div>\
					</td>\
					<td>\
						<table class="{{../ITEM_ACT}}">\
							<tr>\
								<td>\
									<span  class="btn btn-default {{#unless applicable}}disabled{{/unless}}" data-action="apply" data-control-id="{{../ctrlId}}">\
										<i class="{{../applyicn}}"></i>\
										<span>{{../apply}}</span>\
									</span>\
								</td>\
								<td>\
									<span  class="btn btn-default {{#unless applicable}}disabled{{/unless}}" data-action="update" data-control-id="{{../ctrlId}}">\
										<i class="{{../updateicn}}"></i>\
									</span>\
								</td>\
								<td>\
									<span  class="btn btn-default" data-action="delete" data-control-id="{{../ctrlId}}">\
										<i class="{{../deleteicn}}"></i>\
									</span>\
								</td>\
							</tr>\
						</table>\
					</td>\
				</tr></table>\
			</li>\
		{{/each}}',
	noitems: '\
		<div class="s-m-noitem"><b>{{text}}</b></div>\
		',
	changeItemTitle: '\
		<div>\
			<div class="input-group {{#if smartphone}}input-group-sm{{/if}}">\
				<input id="{{ITEM_INPUT_TTL}}" style="font-weight:bold;" class="ctrl-evt-input form-control" type="text" aria-describedby="{{ITEM_INPUT_TTL_ADDON}}" >\
				<span data-action="saveItemTitle" data-control-id="{{ctrlId}}" class="btn input-group-addon" id="{{ITEM_INPUT_TTL_ADDON}}" style="background-color:inherit">\
					<i class="{{icon}}"/>\
				</span>\
			</div>\
		</div>',
	filtersMenu: '\
		<select id="{{FILTER_MENU}}" data-action="filter" data-control-id="{{ctrlId}}">\
			{{#each filterOptions}}\
				<option value="{{value}}" {{#if selected}}selected{{/if}}>{{title}}</option>\
			{{/each}}\
		<select>'
};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	if (!tmpl) alert("template " + name + " not found");
	return tmpl(ctx);
};

var _Klass = utils.defineClass(

	function(controller, $type, panelId, options) {
		options = options || {};
		options.enableGesture = true;
		this.fromActionMgrUUID = options.fromActionMgrUUID;
		Base.call(this, controller, $type, panelId, options);
		this.representation = controller.representation;
		this.dateFormatter = formatApi.getFormatter("application/x-datetime");
		this._initLabels();
	}, Base, {
		_initLabels: function() {
			this._selectedFilter = "current";
			this._filterOptions = [{
				value: "current",
				title: _txt("currendpoint")
			}, {
				value: "all",
				title: _txt("allendpoint")
			}];
		},
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.dateFormatter = null;
			this.$$content = null;
			this.$$list = null;
		},
		buildHtml: function(side) {
			if (this.$$content) {
				this.$$content.remove();
			}
			Base.prototype.buildHtml.call(this, side, _txt("title"));
			this.$$content = this._buildContent().appendTo(this.$$elmt);
			this.$$list = this.$$content.find(".panel.avail ul");
			// trick to manage the save totle button
			this.$$elmt.off().on('click', jsutils.bindFn(this.onMainClick, this));
		},
		/**
		 * Build the main content synchronously (without tmpl list)
		 * We need to build at least s-m-scroll-elmt synchronously to be compliant with sidePanel gesture management
		 */
		_buildContent: function() {
			var context = {
				createSection: _txt("createSection"),
				availSection: _txt("availSection"),
				name: _txt("name"),
				create: _txt("create"),
				createicn: fontUtils.getIconByName("$apply"),
				ctrlId: this.id,
				CREATE_BTN: CREATE_BTN,
				CREATE_BTN_ADDON: CREATE_BTN_ADDON,
				LST_WRAP: LST_WRAP,
				LST_SCROLL: LST_SCROLL,
				smartphone: globals.getSiteLayout().getDeviceType() === "smartphone"
			};
			return $(_getHtml("main", context));
		},
		/**
		 * Build the list of templates asynchronously
		 */
		_buildItems: function() {
			var self = this;
			self.$$list.off().empty();
			var context = {
				ctrlId: self.id,
				updateicn: fontUtils.getIconByName("$refresh"),
				deleteicn: fontUtils.getIconByName("$delete"),
				applyicn: fontUtils.getIconByName("$apply"),
				apply: _txt("apply"),
				ITEM_TTL: ITEM_TTL,
				ITEM_INFO: ITEM_INFO,
				ITEM_TABLE: ITEM_TABLE,
				ITEM_ACT: ITEM_ACT,
				items: []
			};
			globals.getStorage().templateOperation("count").then(function(count) {
				var deferred = $.Deferred();
				var queryRep = self._selectedFilter === "all" ? null : self.representation;
				var queryEp = self._selectedFilter === "all" ? null : globals.getEndpoint();
				globals.getStorage().templateOperation("query", queryRep, queryEp, true).then(function(templates) {
					deferred.resolve(count, templates);
				}).fail(function(e) {
					deferred.reject(e);
				});
				return deferred.promise();
			}).then(function(count, templates) {
				templates = (templates || []);
				templates.sort(function(a, b) {
					if (b["endpoint"] === a["endpoint"]) {
						return b["creation_date"] > a["creation_date"];
					}
					return b["endpoint"] > a["endpoint"];
				});
				if (templates.length > 0) {
					var ep = globals.getEndpoint();
					templates.forEach(function(tmpl, idx) {
						context.items.push({
							title: tmpl.title,
							date: self.dateFormatter.formatValue(tmpl["creation_date"]),
							tmplId: tmpl.id,
							applicable: tmpl.representation === self.representation, // We don't test endpoint
							representation: self._selectedFilter === "all" ? tmpl.representation || "" : null
						});
					});
					$(_getHtml("items", context)).appendTo(self.$$list);
				} else {
					$(_getHtml("noitems", {
						text: _txt("noitem")
					})).appendTo(self.$$list);
				}
				if (!self._$$filter) {
					self._$$filter = $(self._buildFilterMenu()).appendTo(self.$$content.find(".panel.avail > .panel-heading"));
				}
				self._$$filter.val(self._selectedFilter).toggle(self._selectedFilter === "all" || count > templates.length);
				// An update is needed because height changed
				self._updateGesture();
			}).fail(function(e) {
				globals.getModal().error(_txt("readallerr"), e, function() {
					self.$$content.html($(_getHtml("error", {
						error: locale.text("error"),
						contact: locale.text("contact.admin")
					})));
				});
			});
		},
		_buildFilterMenu: function() {
			var self = this;
			self._selectedFilter = self._selectedFilter || "current";
			var opts = [];
			self._filterOptions.forEach(function(item) {
				item = $.extend({}, item);
				item.selected = item.value === self._selectedFilter;
				opts.push(item);
			});
			return _getHtml("filtersMenu", {
				"filterOptions": opts,
				"ctrlId": self.id,
				"FILTER_MENU": FILTER_MENU
			});
		},
		_actFilter: function() {
			var f = this._$$filter.val();
			if (f === this._selectedFilter) return;
			this._selectedFilter = f;
			this._buildItems();
		},
		refresh: function() {
			this._buildItems();
			this._actClearname();
		},
		_notify: function(text) {
			var notify = {
				severityClass: "success",
				body: text,
				onlyWebapp: true,
				delay: "short"
			};
			globals.getModal().notify(notify);
		},
		_getTmplId: function($$target, event, propagate) {
			if (propagate !== true) {
				event.stopPropagation();
			}
			return $$target.closest("li[data-params]").attr("data-params");
		},
		_actApply: function(param, $$target, event) {
			var self = this;
			var tmplId = self._getTmplId($$target, event);
			if (!tmplId) return;
			globals.getStorage().templateOperation("read", tmplId).then(function(data) {
				self.close();
				if (data) {
					self.controller.dao.setTemplateData(data.dataSet);
					self.controller.refresh({
						refreshValue: true
					});
				}
			}).fail(function(e) {
				globals.getModal().error("Error deleting template", e);
			});
		},
		_actUpdate: function(param, $$target, event) {
			var self = this;
			var tmplId = self._getTmplId($$target, event);
			if (!tmplId) return;
			globals.getStorage().templateOperation("update", tmplId, {
				dataSet: self.controller.dao.getTemplateData()
			}, false).then(function() {
				self.close();
				self._notify(_txt("updt.success"));
			}).fail(function(e) {
				globals.getModal().error("Error updating template", e);
			});
		},
		_actDelete: function(param, $$target, event) {
			var self = this;
			var tmplId = self._getTmplId($$target, event);
			if (!tmplId) return;
			globals.getStorage().templateOperation("delete", tmplId).then(function() {
				self.refresh();
			}).fail(function(e) {
				globals.getModal().error("Error deleting template", e);
			});
		},
		_actCreate: function(param, $$target, event) {
			var self = this;
			var ctx = {
				id: utils.UUID(),
				endpoint: globals.getEndpoint(),
				representation: self.representation,
				title: self.$$content.find("#" + CREATE_BTN).val(),
				dataSet: self.controller.dao.getTemplateData()
			};
			globals.getStorage().templateOperation("save", ctx).then(function() {
				self.close();
				self._notify("Template has been created successfully");
			}).fail(function(e) {
				globals.getModal().error("Error saving template", e);
			});
		},
		_actClearname: function(param, $$target, event) {
			this.refreshCreateBtn("");
		},
		_actChangeItemTitle: function(param, $$target, event) {
			var tmplId = this._getTmplId($$target, event);
			if (!tmplId) return;
			if (!this._$$changeItemTitle) {
				this._$$changeItemTitle = $(_getHtml('changeItemTitle', {
					ctrlId: this.id,
					icon: fontUtils.getIconByName("$refresh"),
					ITEM_INPUT_TTL: ITEM_INPUT_TTL,
					ITEM_INPUT_TTL_ADDON: ITEM_INPUT_TTL_ADDON,
					smartphone: globals.getSiteLayout().getDeviceType() === "smartphone"
				}));
				// Trick to manage the save title button
				this._$$changeItemTitle.find("span").on('click', jsutils.bindFn(this.onClickSaveItemTitle, this));
			}
			// _$$changeItemTitle is detached to be re-attached and shown
			$$target.before(this._$$changeItemTitle.detach().css({
				position: "relative",
				left: ""
			})).hide();
			this.refreshSaveItemTitleBtn(this._$$changeItemTitle.find("#" + ITEM_INPUT_TTL).val($$target.text()));
		},
		/**
		 * This event is trigerred before onMainClick
		 * So we can save before detaching _$$changeItemTitle elmt
		 */
		onClickSaveItemTitle: function(event) {
			var self = this;
			// true to allow bubbling and trigger onMainClick
			var tmplId = self._getTmplId($(event.target), event, true);
			if (!tmplId) return;
			var $$display = self._$$changeItemTitle.parent().find("." + ITEM_TTL);
			var title = self._$$changeItemTitle.find("#" + ITEM_INPUT_TTL).val();
			if ($$display.text() === title) {
				// No change
				return;
			}
			// Set new title
			$$display.text(title).show();
			// Partial update
			globals.getStorage().templateOperation("update", tmplId, {
				title: title
			}, true).fail(function(e) {
				globals.getModal().error("Error saving template title", e);
			});
		},
		/**
		 * Trick to manage the save title button
		 * We can't use the blur event to hide/detach the input title elmt because hide.detch fire the pending events
		 * --> So if we click on "SaveItemTitle" we get first the blur event which fires the click evt and event is not triggered
		 * We handle the clicks evnts on panel to manage _$$changeItemTitle
		 */
		onMainClick: function(evt) {
			if (this._$$changeItemTitle && this._$$changeItemTitle.is(":visible")) {
				this.$$content.find("." + ITEM_TTL).show();
				this._$$changeItemTitle.detach();
			}
		},
		/**
		 * Manages create button status
		 */
		onInput: function(evt) {
			var $$target = $(evt.target);
			if ($$target.is("#" + CREATE_BTN)) {
				this.refreshCreateBtn();
				return;
			}
			if ($$target.is("#" + ITEM_INPUT_TTL)) {
				this.refreshSaveItemTitleBtn($$target);
				return;
			}
		},
		refreshSaveItemTitleBtn: function($$input) {
			$$input.focus().parent().find("#" + ITEM_INPUT_TTL_ADDON).toggleClass("disabled", $$input.val().trim().length === 0);
		},
		refreshCreateBtn: function(val) {
			if (!this._$$create) {
				this._$$create = this.$$content.find('.panel.create .btn[data-action="create"]');
				this._$$input = this.$$content.find('.panel.create input[type="text"]');
			}
			if (val != null) {
				this._$$input.val(val);
			}
			this._$$create.toggleClass("disabled", this._$$input.val().trim().length <= 0);
			this._$$input.focus();
		},
		notifyToggled: function(side, action, visible) {
			if (visible === true) {
				this.refresh();
				return;
			} else {
				var self = this;
				globals.getStorage().templateOperation("count").then(function(count) {
					// notify new count - fromActionMgrUUID is used to retreive the control that triggerd the linsk (which header/footer)
					// In dahsboard we can have multiple vignettes that can trigger seach event
					notifications.publish("sm.edit.templates.changed", self.fromActionMgrUUID, count);
				});
				return;
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/userPanelSmartphone',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/controls/page/panels/actionPanel','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/application/eventListener','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/controls/ctrlHelpers','syracuse-tablet/html/js/helpers/native/native'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var Base = require('syracuse-tablet/html/js/controls/page/panels/actionPanel').Klass;
var globals = require('syracuse-tablet/html/js/helpers/globals');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var ctrlHelpers = require('syracuse-tablet/html/js/controls/ctrlHelpers');
var native = require('syracuse-tablet/html/js/helpers/native/native');


var _hideDevFeatures;
var _mustHideDevFeatures = function() {
	if (_hideDevFeatures != null) {
		return _hideDevFeatures;
	}
	_hideDevFeatures = !native.isTestMode() && native.hasCapability("nativeApp");
};

var _templates = {
	navigLink: '<li class="">\
		<a draggable="false"  href="#" {{#if openPage}}data-nav="{{openPage}}"{{else}}data-action="{{action}}" data-params="{{params}}"{{/if}} data-control-id="{{ctrlId}}">\
			<i class="{{icon}}"></i>\
			&nbsp;\
			<span class="isLabel">{{title}}</span>\
		</a>\
	</li>'
};

var _panelLinks = {
	home: {
		label: "header.sm.links.home",
		icon: "home",
		action: "gotoWelcomeApplication",
		target: "application"
	},
	switchContext: {
		label: "header.sm.links.switchContext",
		icon: "switchContext",
		params: "switchContext",
		action: "linkClicked",
		target: "panel"
	},
	pageShare: {
		label: "header.links.page.share",
		icon: "nativeShare",
		params: "pageShare",
		action: "linkClicked",
		target: "panel"
	},
	pageMailTo: {
		label: "header.links.page.mailto",
		icon: "mailto",
		action: "pageMailto",
		target: "application"
	},
	clearCache: {
		label: "header.sm.links.settings",
		icon: "settings",
		action: "linkClicked",
		params: "settings",
		target: "panel"
	},
	about: {
		label: "header.sm.links.about",
		icon: "about",
		action: "linkClicked",
		params: "about",
		target: "panel"
	},
	logout: {
		label: "header.sm.links.logout",
		icon: "logout",
		action: "logout",
		target: "application"
	},
	development: {
		label: "header.links.development",
		icon: "developmentPage",
		action: "developmentPage",
		target: "application"
	},
	pinPage: {
		label: "",
		icon: "",
		action: "pinPage",
		target: "application"
	},
	pageConfig: {
		label: "page.configure.btn",
		icon: "pageConfig",
		action: "pageConfig",
		target: "application"
	},
	drafts: {
		label: "header.links.page.drafts",
		icon: "drafts",
		openPage: "pageDrafts",
		target: "application"
	}
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

/**
 * Regular page left panel
 */
var _Klass = utils.defineClass(

	function(controller, $type, panelId, options) {
		options = options || {};
		// Just to test this mode that pushs the content
		options.overlap = false;
		options.enableGesture = false;
		options.enableTwoColumns = true;
		Base.call(this, controller, $type, panelId, options);
		notifications.subscribe(this, ["sm.page.pin.state.change", "sm.drafts.changed"]);
		this._initPanelItems(controller, options);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			this._doAfterBuildHandlers = null;
		},

		buildPanel: function(context, side) {
			var self = this;
			var actionsHtml = [];
			var keys = Object.keys(self._panelLinks);
			keys.forEach(function(kk, idx) {
				var link = self._panelLinks[kk];
				if (link.hidden !== true) {
					actionsHtml.push(_getHtml("navigLink", {
						title: locale.text(link.label),
						action: link.action || "",
						openPage: link.openPage || "",
						params: link.params || "",
						icon: fontUtils.pageIcon(link.icon),
						ctrlId: link.target === "panel" ? self.id : null
					}));
				}
			});
			context.items = [{
				title: globals.getUserName(),
				html: actionsHtml.join('')
			}];
			return Base.prototype.buildPanel.call(self, context, side);
		},

		attach: function($$parent, side) {
			Base.prototype.attach.call(this, $$parent, side);
			if (this._doAfterBuildHandlers) {
				// Postponed processes
				// Update panel with events that occurs when it was hidden/not built
				this._doAfterBuildHandlers.forEach(function(handler) {
					handler();
				});
				this._doAfterBuildHandlers = null;
			}
		},
		_initPanelItems: function(page, options) {
			var toolBars = options || {};
			this._panelLinks = $.extend(true, {}, _panelLinks);
			this._panelLinks["development"].hidden = (_mustHideDevFeatures() === true || globals.isMobile()) ? true : !toolBars.showDevelopment;
			this._panelLinks["home"].hidden = !toolBars.showHome;
			this._panelLinks["pageConfig"].hidden = !toolBars.showPageConfig;
			this._panelLinks["pageShare"].hidden = !page.showPageShare();
			this._panelLinks["pageMailTo"].hidden = toolBars.showPageMailto !== true;
			this._panelLinks["drafts"].hidden = !toolBars.showDrafts;
			//page.nativeCapabilities.share,
			var pinPage = this._panelLinks["pinPage"];
			switch (toolBars.statusPinPage) {
				case 1:
					pinPage.label = "pin.page.panel.label.pin";
					pinPage.hidden = false;
					pinPage.icon = "pinPage_1";
					break;
				case 2:
					pinPage.label = "pin.page.panel.label.unpin";
					pinPage.hidden = false;
					pinPage.icon = "pinPage_2";
					break;
				default:
					pinPage.hidden = true;
					break;
			}
		},

		_actLinkClicked: function(actionName) {
			/* triggering action */
			eventListener.triggerAction(this.$$elmt, actionName);
		},

		// newState
		// 0 = don't show
		// 1 = show inactive
		// 2 = show active
		notifPagePinStateChange: function(newState) {
			var $$icon = this.$$elmt.find("[data-action=pinPage] i");
			if ($$icon.length > 0) {
				$$icon.attr("class", fontUtils.pageIcon("pinPage_" + newState));
			}
			var $$text = this.$$elmt.find("[data-action=pinPage] span");
			if ($$text.length > 0) {
				var text;
				if (newState != 2) {
					text = locale.text("pin.page.panel.label.pin");
				} else {
					text = locale.text("pin.page.panel.label.unpin");
				}

				$$text.text(text);
			}
		},
		hasLinks: function() {
			return true;
		},
		_afterBuildPush: function(handler) {
			if (this._doAfterBuildHandlers == null) {
				this._doAfterBuildHandlers = [];
			}
			if (this._doAfterBuildHandlers.indexOf(handler) >= 0) {
				return;
			}
			this._doAfterBuildHandlers.push(handler);
		},
		/**
		 * Manage the count info in 'List of draft' menu
		 */
		notifDraftsChanged: function(count) {
			if (!this.$$elmt) {
				// Postpone the change if control not built
				this._afterBuildPush(jsutils.bindFn(this.notifDraftsChanged, this, count));
			} else {
				ctrlHelpers.notifDraftsChanged(this, count);
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/ctrlTypeUnknown',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/ctrlBase'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;

/**
 * Base class for controls that display exactly one value/property
 */
var _Klass = utils.defineClass(

	function CtrlTypeUnknown(controller, article, prototype) {
		Base.call(this, controller, article, prototype);
	}, Base, {
		buildHtml: function($$parent, controllerDao, buildOptions) {
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions, ["s-m-unknown"]);
			this.$$elmt.html('<div class="s-m-value">Field ' + this.$bind + ' - Unknown type: ' + this.$type + '</div>');
		}
	}
);

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/ctrlUnfound',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/ctrlBase'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;

/**
 * Unfound fields in prototype
 */
var _Klass = utils.defineClass(

	function CtrlUnfound(controller, article, prototype) {
		Base.call(this, controller, article, prototype);
	}, Base, {
		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions, ["s-m-unfound"]);
			self.$$elmt.html('<div class="s-m-value">Field <b>' + self.$bind + '</b> unfound</div>');
		}
	}
);

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/field/ctrlImage',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/helpers/native/native'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var native = require('syracuse-tablet/html/js/helpers/native/native');

var _handlersMap = {
	"$delete": "_onClearClick",
	"$edit": "_onEditClick",
	"$sign": "_onSignClick",
	"$camera": "_onCameraClick",
	"$select": "_onUploadClick",
};

var _templates = {
	footer: '\
			<footer> \
					{{#each actions}}\
						{{#if active}}\
							<a class="ctrl-evt-click"\
								href = "#"\
								draggable="false"\
								action="{{id}}">\
								<span \
								{{#if css}}\
									class="{{css}}"\
								{{/if}}\
								>\
								{{#if text}}\
									{{text}}\
								{{/if}}\
								</span>\
							</a>\
						{{/if}}\
					{{/each}}\
			</footer> \
		'
};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	if (!tmpl) alert("template " + name + " not found");
	return tmpl(ctx);
};


/**
 * Image  field
 * authoring:
 * 		$imgHeight	set the height of the image - xsmall, small...
 */
var _Klass = utils.defineClass(

	function CtrlImage(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = {
			"penAnnotatedImage": true,
			"penSignatureImage": true,
			"camera": true
		};
		Base.call(this, controller, article, prototype, options);
		this.cssType = "s-m-img";
	}, Base, {
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			this.$$layout = null;
		},
		applyMetaData: function(metaData, buildOptions) {
			Base.prototype.applyMetaData.call(this, metaData, buildOptions);
			if (this.$isEditMode && this.$$layout) {
				var disabled = metaData ? metaData.$isReadOnly || metaData.$isDisabled : false;
				this.$$layout.children("footer").toggle(disabled !== true);
			}
		},

		buildFieldValue: function(parentSlot, buildOptions) {
			if (!this.article.$imgHeight) {
				this.article.$imgHeight = buildOptions && (buildOptions.displayCtx === "table" || buildOptions.displayCtx === "card") ? "small" : "medium";
			}
			var value = this.getFormattedValue(this.getValue());
			// Create the image stuff under the standard s-m-value parent
			var imgParent = Base.prototype.buildFieldValue.call(this, parentSlot, buildOptions);
			var docUrl = this._getLocalUrlValue();
			if (!docUrl) {
				docUrl = this.prototype.data("$url", this.getDao()) || "";
				if (clientContract.isLocalEntityUrl(docUrl)) {
					// Used to returned data in client entities
					docUrl = clientContract.callLocalEntityUrl(docUrl);
				} else {
					//TODO use $etag or else - No need to force reload if updateLayout - data are in the browser's cache
					if (buildOptions.updateLayout !== true) {
						docUrl += '?salt=' + ((new Date()).getTime());
					}
				}
			}
			var empty = value == null || value === "" || !docUrl || docUrl.length === 0;
			if (empty) $(imgParent).addClass("s-m-empty");
			// if FileReader not supported by the browser, we display detail view (fix for Safari)
			if (this.$isEditMode && typeof FileReader !== "undefined") {
				this._buildEditImageField(imgParent, docUrl, empty);
			} else {
				if (this.article.$imgDisplayIcon === true) {
					// We want to display images as icons - enabled only for arrays in table mode
					var css;
					if (empty) {
						css = fontUtils.getColImageDefIcon(true).css;
					} else {
						css = (this.article.$imgIcon || fontUtils.getColImageDefIcon(false)).css;
					}
					return $(imgParent).addClass(css);
				} else if (empty) {
					// Only icon
					if (buildOptions && buildOptions.displayCtx === "card") {
						// same height for all cards -> We set the height
						this._defaultImg(imgParent, null);
					} else {
						$(imgParent).addClass(this._getDefaultIcon());
					}
				} else {
					// link - Maybe we could manage a modal to display the image 
					var e = uiUtils.createDomElement("a", ["img-responsive ctrl-evt-click"], null, {
						"href": "#"
					}, imgParent);
					// Image with link
					e = this._newImg(e, docUrl);
				}
			}
		},
		_isBtnActive: function(btnId) {
			var isSignature = this.article.$isSignature ? true : false;
			var isActive = false;
			switch (btnId) {
				case "$select":
					isActive = !isSignature;
					break;
				case "$edit":
					isActive = (!isSignature && this.isNativeCapabilityEnabled("penAnnotatedImage"));
					break;
				case "$camera":
					isActive = (!isSignature && this.isNativeCapabilityEnabled("camera"));
					break;
				case "$sign":
					isActive = (isSignature && this.isNativeCapabilityEnabled("penSignatureImage"));
					break;
				case "$delete":
					isActive = true;
					break;
				default:
					isActive = false;
			}
			return isActive;
		},
		_buildEditImageField: function(parentSlot, docUrl, empty) {
			// layout structure
			this.$$layout = $('<div class="s-m-img-layout">');
			// building 3 components. clear button, core and upload button. All clickable.

			var core = uiUtils.createDomElement("a", ["img-responsive", "s-m-field-img", "ctrl-evt-click"], null, {
				"href": "#"
			}, $("<section>").appendTo(this.$$layout));
			var actions = [{
				id: "$select",
				active: this._isBtnActive("$select"),
				css: "s-m-select",
				text: locale.text("image.label.selectimage")
			}, {
				id: "$edit",
				active: this._isBtnActive("$edit"),
				css: "s-m-edit " + fontUtils.getIconByName("$image-ink")
			}, {
				id: "$sign",
				active: this._isBtnActive("$sign"),
				css: "s-m-sign " + fontUtils.getIconByName("$image-sign")
			}, {
				id: "$camera",
				active: this._isBtnActive("$camera"),
				css: "s-m-camera " + fontUtils.getIconByName("$image-camera")
			}, {
				id: "$delete",
				active: this._isBtnActive("$delete"),
				css: "s-m-delete " + fontUtils.getIconByName("$delete")
			}];

			$(_getHtml("footer", {
				actions: actions
			})).appendTo(this.$$layout);

			// use default image if empty content
			if (empty) {
				core = uiUtils.createDomElement("span", [this._getDefaultIcon(), "s-m-empty", "img-responsive"], null, null, core);
			} else {
				core = this._newImg(core, docUrl);
				this.img = core;
			}
			parentSlot.appendChild(this.$$layout[0]);

			var inputDom = uiUtils.createDomElement("input", ["ctrl-evt-change"], null, {
				"type": "file",
				"accept": "image/*"
			}, parentSlot);
			this.$$elmt.find(".s-m-img-layout > footer > a[action='$delete']").toggle(!empty);
			this.$$elmt.find(".s-m-img-layout > footer > a[action='$edit']").toggle(!empty);
		},
		onClick: function(evt) {
			var dom = evt.target.nodeName.toLowerCase() === "span" ? evt.target.parentNode : evt.target;
			var parentDom;
			// detail mode
			if (!this.$isEditMode && dom.nodeName.toLowerCase() === "a") {
				parentDom = dom;
			}
			// edit mode
			else {
				parentDom = dom.parentNode;
			}
			if (!parentDom) return;
			var hdl = _handlersMap[$(dom).attr("action") || parentDom.nodeName.toLowerCase()];
			if (!hdl) return;
			this[hdl](evt, dom);
		},
		_getBinaryContent: function() {
			var binary = this.getDao().getValue(this.$bind + "-LOCALURL");
			if (!binary && this.img) {
				var canvas = document.createElement('canvas');
				var ctx = canvas.getContext("2d");
				ctx.canvas.width = this.img.naturalWidth;
				ctx.canvas.height = this.img.naturalHeight;
				ctx.drawImage(this.img, 0, 0, this.img.naturalWidth, this.img.naturalHeight);
				binary = canvas.toDataURL();
			}
			return binary;
		},
		/*
			When clear button is clicked
			- Removes  content
			- Hide clear button
			- Update upload button text if image
		*/
		_onClearClick: function(evt, dom) {
			var clearBtn = dom;
			// get core elmt (the anchor containing the image or the file)
			var core = this.$$elmt.find(".s-m-img-layout > section > a")[0];
			// remove image/doc
			uiUtils.empty(core);
			// update image/doc
			core = uiUtils.createDomElement("span", [this._getDefaultIcon(), "s-m-empty"], null, null, core);
			// update dao
			this.setValue(null);
			var element = this.$$elmt.find(".s-m-value > input");
			//element.val(''); // to trigger onchange
			element.replaceWith(element = element.clone(true)); // element.val('') does not work with IE
			$(clearBtn).toggle();
			if (this._isBtnActive('$edit')) {
				var editBtn = this.$$elmt.find(".s-m-img-layout > footer > a[action='$edit']")[0];
				$(editBtn).toggle();
			}
			// update upload button
			this._setLocalUrlValue(null);
		},
		_onEditClick: function(evt, dom) {
			var self = this;
			var editBtn = this.$$elmt.find(".s-m-img-layout > footer > a[action='$edit']")[0];
			$(editBtn).toggle();
			native.getModule("penAnnotatedImage").getAnnotatedImage({
				title: self.getTitle(),
				imageData: self._getBinaryContent()
			}).then(
				function(data) {
					if (data && data.action === "ok") {
						if (data.imageData && data.imageData.length) {
							// No need to scale here
							// The image is scaled before adding it and making inking available
							self.setValue(self._getImageDataValue(data.imageData));
							self._setImage(data.imageData);
						}
					} else {
						$(editBtn).toggle();
					};
				}
			);
		},
		_onSignClick: function(evt, dom) {
			var self = this;
			var signBtn = this.$$elmt.find(".s-m-img-layout > footer > a[action='$sign']")[0];
			$(signBtn).toggle();
			native.getModule("penAnnotatedImage").getSignatureImage({
				title: self.getTitle(),
				watermark: ""
			}).then(
				function(data) {
					if (data && data.action === "ok") {
						if (data.imageData && data.imageData.length) {
							// We do not scale images that are input as a signature since
							// signature images created by the wrapper have a defined size already 
							self.setValue(self._getImageDataValue(data.imageData));
							self._setImage(data.imageData);
						}
					}
					$(signBtn).toggle();
				}
			);
		},
		_onCameraClick: function(evt, dom) {
			var self = this;
			var signBtn = this.$$elmt.find(".s-m-img-layout > footer > a[action='$camera']")[0];
			$(signBtn).toggle();
			native.getModule("camera").getPictureFromCamera({})
				.then(function(data) {
					if (data && data.action === "ok") {
						if (data.imageData && data.imageData.length > 0) {
							return self._checkScale(data.imageData);
						}
					}
					return null;
				})
				.then(function(imageData) {
					if (imageData) {
						self.setValue(self._getImageDataValue(imageData));
						self._setImage(imageData);
					}
				})
				.always(function() {
					$(signBtn).toggle();
				});
		},
		/* 
		When upload button is clicked (or empty image), run upload and update dao
	*/
		_onUploadClick: function(evt, dom) {
			var $$inputDom = this.$$elmt.find(".s-m-value > input");
			try {
				$$inputDom.trigger("click");
			} catch (e) {
				//In case of wrapper and close the dialog box without any file selected, jquery catch 
				//on statement "Prevent re-triggering of the same event" (jQuery 2.1.1 line 4357) 
				//and does not reinit the property "triggered".
				// So we do it in place of jquery !
				jQuery.event.triggered = undefined;
			}
		},
		/*
		Runs image selection within the client device
		Updates dao
	*/
		onChange: function(evt) {
			var self = this;

			if (evt.target.nodeName.toLowerCase() === 'input') {
				var files = evt.target.files; // FileList object
				var res = {};
				if (files && files.length) {
					var f = files[0];
					if (!f.type.match('image.*')) return;
					res.$contentType = f.type;
					res.$fileName = f.name;
					res.$type = "image";

					var reader = new FileReader();
					reader.onload = (function(theFile, cont) {
						return function(e) {
							self._checkScale(e.target.result).then(function(src) {
								cont.$value = self._getImageDataValue(src);
								delete cont.$url;
								self.setValue(cont.$value);
								self.setFocus();
								self._setImage(src);
							});
						};
					})(f, res);
					reader.readAsDataURL(f);

				}
			}
		},
		_getImageDataValue: function(content) {
			var i = content.indexOf("base64,");
			if (i > 0) {
				return content.substring(i + 7);
			} else {
				return content.result;
			}
		},
		_setLocalUrlValue: function(src) {
			this.getDao().setValue(this.$bind + "-LOCALURL", src);
		},
		_getLocalUrlValue: function() {
			return this.getDao().getValue(this.$bind + "-LOCALURL");
		},
		/*
		Set image based on client image src
		*/
		_setImage: function(src) {
			this._setLocalUrlValue(src);
			// get core elmt (the anchor containing the image)
			var core = this.$$elmt.find(".s-m-img-layout > section > a")[0];
			// remove image
			uiUtils.empty(core);
			// update image
			core = this._newImg(core, src);
			// toggle clearBtn
			this.$$elmt.find(".s-m-img-layout > footer > a[action='$delete']").toggle(true);
			if (this._isBtnActive('$edit')) {
				this.$$elmt.find(".s-m-img-layout > footer > a[action='$edit']").toggle(true);
			}
		},

		/*
		 *  src: data:image/png;base64,iVBORw0KGgoAAAAN
		 */
		_checkScale: function(src) {
			if (!src) return $.smResolve(src);

			// If no authoring done or value is noscale, return source image like:
			// return $.smResolve(src);

			var scaler = native.getModule("imageScale");
			if (!scaler) return $.smResolve(src);

			var scaleMap = {
				small: {
					width: 640,
					height: 480
				},
				medium: {
					width: 1024,
					height: 768
				},
				large: {
					width: 1920,
					height: 1440
				}
			};
			var scale = scaleMap[(this.getAuthoring("$imgScale") || "original")];
			if (!scale) return $.smResolve(src);

			return scaler.getScaledImage({
				width: scale.width,
				height: scale.height,
				imageData: src,
				mode: "LIMIT_MAX_WIDTH_AND_HEIGHT" // Only supported mode right now
			})
				.then(function(result) {
					// Change so return  new image
					if (result.action === "ok") {
						return result.imageData;
					}
					// No change, maybe because size was ok already
					if (result.action === "nochange") {
						return src;
					}
					// Here we got an error but we still can return the original image
					return src;
				});
		},

		_newImg: function(parent, src) {
			return this._setImgHeight(uiUtils.createDomElement("img", ["img-responsive"], null, {
				src: src
			}, parent));
		},
		_defaultImg: function(parent, css) {
			return this._setImgHeight(uiUtils.createDomElement("span", this._getDefaultIcon() + (" " + (css || "")), null, null, parent));
		},
		_setImgHeight: function(i) {
			return $(i).height(uiUtils.imgHeight2px(this.getAuthoring("$imgHeight") || "small")).get(0);
		},
		_getDefaultIcon: function() {
			var css = "s-m-icon-" + (this.article.$emptyIconSize || "small") + " ";
			return css + (this.article.$emptyImageIcon || fontUtils.getEmptyImageDefIcon()).css;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/field/ctrlDocument',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

/**
 * Binary and document field. For moment quite same later ???
 * authoring:
 * 		$imgHeight	set the height of the image - xsmall, small...
 */
var _Document = utils.defineClass(

	function CtrlDocument(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		Base.call(this, controller, article, prototype, options);
		// Add cssType in root element
		this.cssType = "s-m-document";
	}, Base, {

		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			this.$$layout = null;
		},

		applyMetaData: function(metaData, buildOptions) {
			Base.prototype.applyMetaData.call(this, metaData, buildOptions);
			if (this.$isEditMode && this.$$layout) {
				var disabled = metaData ? metaData.$isReadOnly || metaData.$isDisabled : false;
			}
		},

		buildFieldValue: function(parentSlot, buildOptions) {
			var self = this;
			var value = self.getFormattedValue(self.getValue());
			// Create the image stuff under the standard s-m-value parent
			var imgParent = Base.prototype.buildFieldValue.call(self, parentSlot, buildOptions);
			var docUrl = self._getLocalUrlValue();
			if (!docUrl) {
				docUrl = self.prototype.data("$url", self.getDao()) || "";
				//TODO use $etag or else - No need to force reload if updateLayout - data are in the browser's cache
				if (buildOptions.updateLayout !== true) {
					docUrl += '?salt=' + ((new Date()).getTime());
				}
			}
			var empty = value == null || value === "" || docUrl.length === 0;
			if (empty) $(imgParent).addClass("s-m-empty");

			//if (self.$isEditMode)     For moment no dif between edit and not edit
			if (!empty) {
				var classcss = ["img-responsive ctrl-evt-click"];
				classcss.push(this._getIcon());
				// link - Maybe we could manage a modal to display the image 
				var e = uiUtils.createDomElement("span", classcss, null, {
					"href": "#"
				}, imgParent);
			}
		},
		_getIcon: function() {
			return fontUtils.documentFieldIcon();
		},
		onClick: function(evt) {
			var dom = evt.target.parentNode;
			var parentDom;
			if (this.$isEditMode) return;
			this._onDocumentClick(evt, dom); // For moment only open doc.
		},
		/*
			When document is clicked
			- If empty, nothing
			- If not empty, open document
		*/
		_onDocumentClick: function(evt, dom) {
			var self = this;
			var value = self.getFormattedValue(self.getValue());
			var docUrl = self.prototype.data("$url", self.getDao()) || "";
			var empty = value == null || value === "" || docUrl.length === 0;
			if (!empty) {
				window.open(docUrl, "_blank");
			}
		},
		_getLocalUrlValue: function() {
			return this.getDao().getValue(this.$bind + "-LOCALURL");
		}
	});
var _Binary = utils.defineClass(
	function CtrlBinaryd(controller, article, prototype, options) {
		var self = this;
		_Document.call(self, controller, article, prototype, options);
		self.cssType = "s-m-binary";
	}, _Document, {

		_getIcon: function() {
			return fontUtils.binaryFieldIcon();
		},
	});

exports.Klass = _Document;
exports.Binary = _Binary;
});

define('syracuse-tablet/html/js/helpers/html-escape/lib/escape',['require','exports','module'],function (require, exports, module) {"use strict";

function fixOptions(options) {
	options = options || {};
	options.allowedTags = (options.allowedTags || []).concat( //
		['h1', 'h2', 'h3', 'h4', 'h5', 'h6', //
			'blockquote', 'p', 'a', 'ul', 'ol', 'nl', 'li', //
			'b', 'i', 'strong', 'em', 'strike', 'code', //
			'hr', 'br', 'div', 'pre', //
			'table', 'thead', 'caption', 'tbody', 'tr', 'th', 'td', 'pre'
		]);
	options.allowedAttributes = (options.allowedAttributes || []).concat( //
		['class', 'href', 'src', 'name', 'target']);
	options.allowedSchemes = (options.allowedSchemes || []).concat( //
		['http', 'https', 'mailto']);
	return options;
}

function map(array) {
	return array.reduce(function(map, key) {
		map[key] = true;
		return map;
	}, {});
}

function escapeText(str) {
	return str.replace(/>/g, '&gt;');
}

function escapeComment(str) {
	return str.replace(/-->/g, '__>');
}

function escapeStyle(str) {
	// brutal: will cripple all occurrences of javascript, expression and url
	return str.replace(/\/\*.*?\*\//g, '').replace(/(\\|\b)(j\\?a\\?v\\?a\\?s\\?c\\?r\\?i\\?p\\?t|e\\?x\\?p\\?r\\?e\\?s\\?s\\?i\\?o\\?n|u\\?r\\?l)\b/ig, 'disabled-$1$2');
}

function escapeType(str) {
	// cripple type="text/javascript"
	return str.replace(/javascript/i, "disabled-javascript");
}

exports.escaper = function(options) {
	options = fixOptions(options);
	var allowedTags = map(options.allowedTags);
	var allowedAttributes = map(options.allowedAttributes);
	var allowedSchemes = map(options.allowedSchemes);
	var urlAttributes = /^(href|src|dynsrc|lowsrc|background)$/i;
	var preserve = options.preserve;
	var warn = options.warn;

	function checkChange(oldVal, newVal, prefix) {
		if (warn && newVal !== oldVal) warn(prefix + ": " + oldVal + " -> " + newVal);
		return newVal;
	}

	function escapeValue(key, val) {
		if (key === 'style') return checkChange(val, escapeStyle(val), "sanitized style");
		if (key === 'type') return checkChange(val, escapeType(val), "sanitized type attribute");
		return val;
	}

	function create() {
		var result = "";
		var inside = "text";

		function skipTillMarker(frag, marker, repl) {
			var i = frag.indexOf(marker);
			if (i >= 0) {
				if (preserve) result += escapeComment(frag.substring(0, i)) + repl + '-->';
				result += escapeText(frag.substring(i + marker.length));
				inside = "text";
			} else {
				if (preserve) result += escapeComment(frag);
			}
			return result;
		}

		function skipTillClosing(frag, tag, allowed) {
			var re = new RegExp('^/' + tag + '>', 'i');
			var m = re.exec(frag);
			if (m) {
				if (allowed) result += '</' + tag + '>';
				else if (preserve) result += '</' + tag + '>-->';
				result += escapeText(frag.substring(m[0].length));
				inside = "text";
			} else {
				if (allowed) result += escapeValue(tag, '<' + frag);
				else if (preserve) result += escapeComment('<' + frag);
			}
			return result;
		}

		function reject(frag, warn) {
			if (warn) warn("malformed element: " + frag);
			if (preserve) result += '<!--<' + escapeComment(frag) + '-->';
			return result;
		}

		function allowedValue(atb, val) {
			if (urlAttributes.test(atb)) {
				var colon = val.indexOf(':');
				if (colon < 0 || !allowedSchemes[val.substring(0, colon)]) return false;
			}
			return true;
		}

		function escapeTag(tag, closing, atbs, autoClosed) {
			if (closing) {
				result += '</' + tag + '>';
				atbs = atbs.trim();
				if (preserve && atbs) result += '<!--@' + escapeComment(atbs) + '-->';
				return;
			}
			result += '<' + tag;
			var end = 0;
			var re = /^\s*(\w+)(?:\s*=\s*(?:(["'])(.*?)\2|()([\w_-]+)))?/,
				m;
			while (m = re.exec(atbs)) {
				atbs = atbs.substring(m[0].length);
				var atb = m[1].toLowerCase();
				var quote = m[2] || '"';
				var val = m[3] || m[5];
				if (!allowedAttributes[atb] || !allowedValue(atb, val)) {
					if (warn) warn("forbidden attribute: " + atb);
					if (preserve) atb = "disabled-" + atb;
					else continue;
				}
				result += ' ' + atb + (val === undefined ? '' : '=' + quote + escapeValue(atb, val) + quote);
			}
			if (autoClosed) result += '/>';
			else result += '>';
			atbs = atbs.trim();
			if (warn && atbs) warn("malformed attribute: " + atbs);
			if (preserve && atbs) {
				result += '<!--@' + escapeComment(atbs) + '-->';
			}
		}

		return function(frag) {
			result = "";
			if (inside === "comment") return skipTillMarker('<' + frag, '-->', '');
			if (inside === "cdata") return skipTillMarker('<' + frag, ']]>', ']]');
			if (inside === "script") return skipTillClosing(frag, 'script');
			if (inside === "style") return skipTillClosing(frag, 'style', allowedTags.style);

			if (/^!--/.test(frag)) {
				inside = "comment";
				if (preserve) result += '<!-- '; // extra space marks as original comment for roundtripping
				return skipTillMarker(frag.substring(3), '-->', '');
			}
			if (/^!\[CDATA\[/.test(frag)) {
				inside = "cdata";
				if (warn) warn("forbidden CDATA");
				if (preserve) result += '<!--';
				return skipTillMarker(frag.substring(1), ']]>', ']]');
			}
			if (/^script\b/i.test(frag)) {
				inside = "script";
				if (warn) warn("forbidden *** SCRIPT *** element");
				if (preserve) result += '<!--';
				return skipTillClosing(frag, 'script');
			}
			if (/^style\b/i.test(frag)) {
				inside = "style";
				if (!allowedTags.style && warn) warn("forbidden STYLE element");
				if (preserve && !allowedTags.style) result += '<!--';
				return skipTillClosing(frag, 'style', allowedTags.style);
			}
			// Special contents have been intercepted.
			// Reject malformed tags
			var end = frag.indexOf('>');
			if (end < 0) return reject(frag, warn); // not closed
			var m = /^(\/?)(\w+)/.exec(frag);
			if (!m) return reject(frag, warn); // invalid syntax: tag name not found
			var tag = m[2].toLowerCase();
			if (!allowedTags[tag]) {
				if (warn && !m[1]) warn("forbidden " + tag.toUpperCase() + " element");
				if (preserve) reject(frag.substring(0, end + 1));
				escapeText(frag.substring(0, end + 1));
			} else {
				// tag is allowed
				var autoClosed = frag[end - 1] === '/';;
				escapeTag(tag, m[1], frag.substring(m[1].length + tag.length, autoClosed ? end - 1 : end), autoClosed);
			}
			result += escapeText(frag.substring(end + 1));
			return result;
		};
	};

	if (options.streaming) {
		return (function() {
			var process;
			return function(text) {
				if (text.indexOf('<') >= 0) throw new Error('internal error: bad HTML fragment');
				if (!process) {
					process = create();
					return escapeText(text);
				} else {
					return process(text);
				}
			};
		})();
	} else {
		return function(text) {
			var process = create();
			var frags = text.split('<');
			var result = escapeText(frags[0]);
			return frags.slice(1).reduce(function(r, frag) {
				return r + process(frag);
			}, result);
		};
	}
};
});

define('syracuse-tablet/html/js/helpers/html-escape/lib/unescape',['require','exports','module'],function (require, exports, module) {"use strict";

exports.unescaper = function(options) {
	options = options || {};

	function uncomment(str) {
		return str.replace(/__>/g, '-->');
	}

	function process(str) {
		return str.replace(/disabled-(\w+=?)/g, '$1').replace(/(.?)<!--(.*?)-->/g, function(all, ch, commented) {
			if (commented[0] === ' ') return ch + '<!--' + commented.substring(1) + '-->';
			if (commented[0] === '[') return ch + '<!' + uncomment(commented) + '>';
			if (commented[0] === '<') return ch + uncomment(commented);
			if (commented[0] === '@') return uncomment(commented.substring(1)) + ch;
			throw new Error("cannot unescape: " + commented);
		});
	}
	if (options.streaming) {
		var buf = "";
		return function(str) {
			if (str === undefined) return process(buf);
			var start = Math.max(0, buf.length - 2);
			buf += str;
			var end = buf.indexOf('-->', start);
			if (end < 0) return '';
			var r = process(buf.substring(0, end + 3));
			buf = buf.substring(end + 3);
			return r;
		};
	} else {
		return process;
	}
};
});

define('syracuse-tablet/html/js/helpers/html-escape/index',['require','exports','module','./lib/escape','./lib/unescape'],function (require, exports, module) {"use strict";
exports.escaper = require('./lib/escape').escaper;
exports.unescaper = require('./lib/unescape').unescaper;
});

define('syracuse-tablet/html/js/helpers/syracuse-rtf/lib/rtfparse',['require','exports','module'],function (require, exports, module) {"use strict";

var lowerLetter = {},
	digit = {},
	LF = '\n'.charCodeAt(0),
	SP = ' '.charCodeAt(0),
	BSLASH = '\\'.charCodeAt(0),
	OPEN = '{'.charCodeAt(0),
	CLOSE = '}'.charCodeAt(0),
	DASH = '-'.charCodeAt(0),
	QUOTE = "\'".charCodeAt(0),
	STAR = "*".charCodeAt(0);

(function() {
	function add(clas, chs, i) {
		chs.split('').forEach(function(ch) {
			clas[ch.charCodeAt(0) + (i || 0)] = true;
		});
	}
	for (var i = 0; i <= 9; i++) add(digit, '0', i);
	for (var i = 0; i < 26; i++) add(lowerLetter, 'a', i);
})();

function builder(error) {
	var group = [],
		stack = [group];
	return {
		open: function() {
			var g = [];
			group.push(g);
			stack.push(g);
			group = g;
		},
		close: function() {
			if (stack.length <= 1) error("too many }");
			group = stack.pop();
			group = stack[stack.length - 1];
		},

		text: function(str) {
			group.push(str);
		},

		control: function(word, arg) {
			var obj = {
				word: word
			};
			if (arg != null) obj.arg = arg;
			group.push(obj);
		},

		/*star: function() {
			group.push({word: "*"});
		},*/

		getResult: function() {
			if (stack.length !== 1) error("missing }");
			return stack[0][0];
		}
	};
}

// returns tree. 
// intermediate nodes are arrays and correspond to rtf groups ({ ...})
// leaf nodes are either
// * strings (text elements)
// * control directives { word: w, arg: a }
exports.parse = function(str) {
	str = str.replace(/\r\n/g, '\n');
	var pos = 0,
		begText = 0,
		len = str.length,
		line = 1,
		bld = builder(error);

	function error(msg) {
		var end = str.indexOf(/[\n>]/, pos);
		if (end < 0) end = str.length;
		return new Error("Invalid RTF: " + msg + " at line " + line + " near " + str.substring(pos, end));
	}

	function flush() {
		if (pos > begText) bld.text(str.substring(begText, pos));
	}
	while (pos < len) {
		var ch = str.charCodeAt(pos);
		switch (ch) {
			case BSLASH:
				flush();
				var beg = ++pos;
				while (lowerLetter[ch = str.charCodeAt(pos)]) pos++;
				if (pos > beg) {
					var word = str.substring(beg, pos),
						arg = undefined;
					if (ch === DASH || digit[ch]) {
						beg = pos;
						pos++;
						while (digit[ch = str.charCodeAt(pos)]) pos++;
						arg = parseInt(str.substring(beg, pos), 10);
					}
					if (ch === SP || ch === LF || (word === "u" && ch !== BSLASH && ch !== OPEN && ch !== CLOSE)) {
						pos++;
					}
					bld.control(word, arg);
				} else if (ch === QUOTE) {

					var symb = String.fromCharCode(parseInt(str.substring(pos + 1, pos + 3), 16));
					bld.text(symb);
					pos = pos + 3;
				} else if (ch === STAR) {
					bld.control("*");
					pos++;
				}

				begText = pos;
				break;
			case OPEN:
				flush();
				bld.open();
				begText = ++pos;
				break;
			case CLOSE:
				flush();
				bld.close();
				begText = ++pos;
				break;
			case LF:
				flush(); // to discard newline from output
				line++;
				begText = ++pos;
				break;
			default:
				pos++;
		}
	}
	flush();
	return bld.getResult();
};
});

define('syracuse-tablet/html/js/helpers/syracuse-rtf/lib/rtfinterpret',['require','exports','module'],function (require, exports, module) {"use strict";

//var rtfparser = require('./rtfparse');

exports.interpret = function(root) {

	var group;
	var documentModel = {
		deffont: "",
		fonts: {},
		colors: [],
		styles: {},
	};
	var fontfamgroups = {
		fnil: "Sans-serif",
		froman: "Sans-serif",
		fswiss: "Serif",
		fmodern: "Monospace",
		fscript: "Cursive",
		fdecor: "Cursive"
	};

	var supported = ["rtf", "ansi", "ansicpg", "deff", "fonttbl", "colortbl", "stylesheet", //
		"fs", "f", "cf", "highlight", "i", //
		"b", "ul", "strike", "plain", //
		"qc", "ql", "qr", "qj", "par", "pard", "pn"
	];

	function interpretFont(features, index, fonts) {
		var fname = features[0].word + features[0].arg;
		var font = (documentModel.fonts[fname] = {});
		for (var i = 1; i < features.length; i++) {
			interpretFontFeature(features[i], font);
		}
	}

	function interpretFontFeature(feature, font) {
		var sep;
		if (typeof feature == "string" && (sep = feature.indexOf(';')) > 0) {
			font.name = feature.substring(0, sep);
		}
	}

	function interpretStylesheet(features, index, styles) {
		var fname, style;
		if (features[0].word) {
			fname = features[0].word + features[0].arg;
			style = (documentModel.styles[fname] = {});
			for (var i = 1; i < features.length; i++) {
				interpretStyleFeature(features[i], style);
			}
		}
	}

	function interpretStyleFeature(feature, style) {
		var sep;
		if (typeof feature == "string" && (sep = feature.indexOf(';')) > 0) {
			style.name = feature.substring(0, sep);
		}
	}

	function interpretControl(node, parent, index) {
		switch (node.word) {
			case "rtf":
			case "ansi":
			case "ansicpg":
				break;
			case "stylesheet":
				parent.slice(1).filter(function(item) {
					// keep only arrays, remove newlines
					return Array.isArray(item);
				}).forEach(interpretStylesheet);
				//documentModel.stylesheet ="";
				break;
			case "deff":
				documentModel.deffont = "f" + node.arg;
				break;
			case "fonttbl":
				parent.slice(1).filter(function(item) {
					// keep only arrays, remove newlines
					return Array.isArray(item);
				}).forEach(interpretFont);
				break;
			case "colortbl":
				// semicolon counts for one item => skip 2 items first
				var i = 1;
				if (parent[i] === ';') {
					documentModel.colors.push([0, 0, 0]);
					i++;
				}
				while (i < parent.length) {
					documentModel.colors.push([parent[i].arg, parent[i + 1].arg, parent[i + 2].arg]);
					i += 4; // skip semicolon too
				} // while
				break;

			case "*":
				/*console.log(parent[index+1].word) ;*/
				if (supported.indexOf(parent[index + 1].word) == -1) parent.splice(index, parent.length - index);
				break;
		} //switch

	}

	function interpretNode(node, index, array) {
		if (Array.isArray(node)) {
			// child nodes will receive node as array argument.
			node.forEach(interpretNode);
		} else if (typeof node === "object") {
			interpretControl(node, array, index);
		}
	}

	/* on copie fonts et colors dans styles */
	interpretNode(root);
	return documentModel;
};
});

define('syracuse-tablet/html/js/helpers/syracuse-rtf/lib/buildhtml',['require','exports','module'],function (require, exports, module) {"use strict";

// ===================================================================================================================================================
// ===================================================================================================================================================
// ===================================================================================================================================================
// ===================================================================================================================================================
//	<div class="s-rtf-root">
//	<div class="s-rtf-section">
//		<p></p>
//		<p></p>
//	</div>
//	<div class="s-rtf-section">
//		<ul>
//			<li></li>
//			<li></li>
//			<li></li>
//		</ul>
//	</div>
//</div>
var styleName = {
	cf: "color",
	highlight: "background-color"
};

function rgbToHex(rgb) {
	if (rgb) {
		return toHex(rgb[0]) + toHex(rgb[1]) + toHex(rgb[2]);
	} else {
		return "000000"; //default color
	}
}

function toHex(n) {
	return ("00" + n.toString(16)).slice(-2);
}

function twipsToPoint(t) {
	return t / 20;
}

function indentCount(t) {
	return t / 600;
}

function indentBulletCount(t) {
	return t / 420;
}

function twipsToPixel(t) {
	return t / 15;
}

function builder(documentModel) {
	var rtffonts = documentModel.fonts,
		deffont = documentModel.deffont,
		colors = documentModel.colors,
		styles = documentModel.styles,
		htmltext = "",
		$rootdiv = $("<div>").addClass('s-rtf-root'),
		$current = null,
		$section = null,
		$worker = null,
		context;

	newSection();

	function newWorker() {
		$current = $worker = $("<div>").addClass('s-rtf-worker').addClass('s-rtf-clean');
		return $worker.appendTo($section);
	}

	function newSection() {
		$section = $("<div>").addClass('s-rtf-section').addClass('s-rtf-clean');
		newWorker();
		return $section.appendTo($rootdiv);
	}

	function characterFormatting(node) {
		switch (node.word) {

			case "f":
				/*case "pnf":*/
				var fontface = rtffonts[node.word + node.arg].name;
				return $("<font face='" + fontface + "'>");

			case "fs":
				//case "pnfs":
				return $("<span style='font-size: " + node.arg / 2 + "pt;'>");
			case "tab":
				//case "pnfs":
				//return $("<span style='margin-left: 10pt'>");//be  carrefull depending on navigator
				return $("<blockquote>"); //be  carrefull depending on navigator
			case "cf":
				//if(!node.arg) return null;
			case "highlight":
				// do not use css() because it converts hex value into rgb style
				// return $("<span>").css(styleName[node.word], "#" + rgbToHex(colors[node.arg]));
				return $("<span style='" + styleName[node.word] + ": #" + rgbToHex(colors[node.arg]) + ";'>");

			case "b":
				return $("<b>");
			case "i":
				return $("<i>");
			case "ul":
				return $("<u>");
			case "strike":
				return $("<s>");
				/*
		case "plain":
			return ["<pre>", "</pre>"];
		case "list":
			return ["<ul>", "</ul>"];
		case "pntext":*/
				/*case "bullet":
			return $("<li>");
		case "line":
			return $("<br>");*/
			default:
				// ; //$("");
		}
	}

	function paragraphFormatting(elt, node) {
		elt.addClass('s-rtf-format');

		dirty();

		switch (node.word) {
			case "ql":
				return elt.attr("align", "left");
			case "qc":
				return elt.attr("align", "center");
			case "qr":
				return elt.attr("align", "right");
			case "qj":
				return elt.attr("align", "justify");
			case "li":
				// return elt.css("margin-left", twipsToPixel(node.arg) + "px");
				if (node.arg > 0)
					return elt.css("margin-left", twipsToPoint(node.arg) + "pt");
				else
					return elt;
			case "ri":
				// return elt.css("margin-right", twipsToPixel(node.arg) + "px");
				if (node.arg > 0)
					return elt.css("margin-right", twipsToPoint(node.arg) + "pt");
				else
					return elt;
			default:
				return elt;
		}

	}

	function dirty() {
		$worker && $worker.removeClass("s-rtf-clean");
		// if we want to always have a paragraph, uncomment this line
		// $worker && $worker.addClass("s-rtf-paragraph");
		$section && $section.removeClass("s-rtf-clean");
	}

	function append(elt) {
		dirty();
		$current.append(elt);
	}

	function wrapIn(elt) {
		dirty();
		$current = elt.appendTo($current);
	}

	context = (function() {
		var stack = [{
			format: {}
		}],
			current = stack[0];

		function flattenFormat() {
			var f, fmt = {};
			stack.forEach(function(ctx) {
				f = ctx.format;
				Object.keys(f).forEach(function(key) {
					if (typeof(fmt[key]) === "undefined") {
						fmt[key] = f[key];
					}
				});
			});
			return fmt;
		}

		return {
			open: function() {
				stack.push(current = {
					format: {}
				});
			},

			close: function(idx, parent) {
				stack.pop();
				current = stack[stack.length - 1];
				if (idx < parent.length - 1) {
					this.pending = true;
				}
			},

			update: function(prop, el) {
				if (el === null) {
					delete current.format[prop];
				} else {
					current.format[prop] = el;
				}
			},

			startOver: function() {
				if (!this.pending) return;
				var fmt = flattenFormat();
				Object.keys(fmt).forEach(function(key) {
					$current = fmt[key].clone().appendTo($current);
				});
				this.pending = false;
			}
		};
	})();

	return {
		text: function(str) {
			dirty();
			context && context.startOver();
			var content = $current.html();
			$current.html(content + str);
		},

		open: function() {
			context.open();
		},

		close: function(idx, parent) {
			$current = $worker;
			if ($current.length === 0) $current = $rootdiv;
			context.close(idx, parent);
		},

		control: function(node) {
			switch (node.word) {

				case "par":
					dirty();
					$worker.removeClass("s-rtf-worker").addClass("s-rtf-paragraph");
					$current = $worker = newWorker();
					context && (context.pending = true);
					break;

				case "pard":
					if (!$section.hasClass("s-rtf-clean")) {
						$section = newSection();
						context && (context.pending = true);
					}
					break;

				case "pn":
					$section.addClass("s-rtf-list");
					break;

				case "u":
					this.unicodechar(node.arg);
					break;

				case "qc":
				case "ql":
				case "qr":
				case "qj":
				case "ri":
					paragraphFormatting($section, node);
					break;
				case "li":
					if ($section.hasClass("s-rtf-list")) {
						$section.attr("indent", indentBulletCount(node.arg));
					} else {
						if (!$section.hasClass("s-rtf-clean") && !$section.hasClass("s-rtf-format")) {
							$section = newSection();
							context && (context.pending = true);
						}
						$section.addClass("s-rtf-left-indent");
						$section.attr("indent", indentCount(node.arg));
					}
					break;
				case "lquote":
				case "rquote":
					this.text("'");
					break;

				case "line":
					append("<br>");
					break;
				case "bullet":
					// var el = $("<li>");
					// var dd = 1;
					// if ($current.is("li")) {
					//	$current.parent().append(el);
					// } else {
					//	$current.append(el);
					// }
					// $current = el;
					break;

				case "i":
				case "b":
				case "strike":
				case "ulnone":
				case "ul":
					if (node.arg === 0 || node.word === "ulnone") {
						var tagname;
						if (node.word === "strike") {
							tagname = "s";
						} else if (node.word === "ulnone") {
							tagname = "u";
						} else {
							tagname = node.word;
						}
						if ($current.is(tagname)) {
							$current = $current.parent();
						} else {
							if ($current.html() !== "") {
								var tag = $current.closest(tagname);
								$current = tag.parent();
							}
						}

						context.update(node.word, null);
						break;
					}
				default:
					var el = characterFormatting(node);

					if (el) {
						context.update(node.word, el.clone());
						!context.pending && wrapIn(el);
					}
			}
			//console.log(node.word + "\n"+$rootdiv.html())
		},
		unicodechar: function(code) {
			dirty();
			var content = $current.html();
			$current.html(content + String.fromCharCode(code));
		},

		getHtml: function() {
			//console.log($rootdiv.html())
			// cleanup
			$rootdiv.find(".s-rtf-clean").remove();
			// replace <div> by <ul>
			var sections = $rootdiv.find(".s-rtf-section.s-rtf-list") //.removeAttr("class");
			sections.map(function(i, e) {
				var $e = $(e);
				var i = parseInt($e.attr("indent"), 10);
				var w = [];
				while (w.length < i) {
					w.push("<ul>");
				}
				$e.wrap(w.join("")).contents();
				//$e.removeAttr("indent");
			});
			var workers = sections.find(".s-rtf-paragraph");
			workers.wrap("<li>").contents().unwrap();
			//sections.unwrap();
			var indent = $rootdiv.find(".s-rtf-section.s-rtf-left-indent").removeClass("s-rtf-left-indent");
			indent.map(function(i, e) {
				var $e = $(e);
				var i = parseInt($e.attr("indent"), 10);
				var w = [];
				while (w.length < i) {
					w.push("<blockquote>");
				}
				$e.wrap(w.join("")).contents();
				$e.removeAttr("indent");
			});



			sections = $rootdiv.find(".s-rtf-section");

			// replace <div> by <p>
			sections.find(".s-rtf-paragraph").removeAttr("class").wrap("<p>").contents().unwrap();
			sections.find("div:empty").remove();



			// cleanup
			sections.find(".s-rtf-worker:empty").remove();
			sections.filter(":not(.s-rtf-format)").contents().unwrap();
			while ($rootdiv.find("span:empty").length) {
				$rootdiv.find("span:empty").remove();
			};
			$rootdiv.find(".s-rtf-worker").removeAttr("class").contents().unwrap();
			$rootdiv.find(".s-rtf-format").removeAttr("class");

			return $rootdiv.html();
		}
	};
}

// HTML builder
exports.buildHtml = function(root, documentModel) {
	var bld = builder(documentModel);

	function interpretNode(node, index, array) {
		if (typeof node == "string") {
			bld.text(node);
			return;
		}
		if (Array.isArray(node) && node.length > 0) {
			if (node[0]) {
				switch (node[0].word) {
					case 'fonttbl':
					case 'colortbl':
					case 'stylesheet':
					case 'pntxtb':
					case 'pntext':
					case 'pict':
						return;
				}
			}
			bld.open();
			node.forEach(interpretNode);
			bld.close(index, array);

			return;
		}

		if (typeof(node) === "object") {
			bld.control(node);

		}
	}

	interpretNode(root, 0, []);
	if (!root) return "<div></div>";
	return bld.getHtml();
};
});

define('syracuse-tablet/html/js/helpers/syracuse-rtf/lib/buildrtf',['require','exports','module'],function (require, exports, module) {"use strict";
var colors = {
	"aliceblue": "#f0f8ff",
	"antiquewhite": "#faebd7",
	"aqua": "#00ffff",
	"aquamarine": "#7fffd4",
	"azure": "#f0ffff",
	"beige": "#f5f5dc",
	"bisque": "#ffe4c4",
	"black": "#000000",
	"blanchedalmond": "#ffebcd",
	"blue": "#0000ff",
	"blueviolet": "#8a2be2",
	"brown": "#a52a2a",
	"burlywood": "#deb887",
	"cadetblue": "#5f9ea0",
	"chartreuse": "#7fff00",
	"chocolate": "#d2691e",
	"coral": "#ff7f50",
	"cornflowerblue": "#6495ed",
	"cornsilk": "#fff8dc",
	"crimson": "#dc143c",
	"cyan": "#00ffff",
	"darkblue": "#00008b",
	"darkcyan": "#008b8b",
	"darkgoldenrod": "#b8860b",
	"darkgray": "#a9a9a9",
	"darkgreen": "#006400",
	"darkkhaki": "#bdb76b",
	"darkmagenta": "#8b008b",
	"darkolivegreen": "#556b2f",
	"darkorange": "#ff8c00",
	"darkorchid": "#9932cc",
	"darkred": "#8b0000",
	"darksalmon": "#e9967a",
	"darkseagreen": "#8fbc8f",
	"darkslateblue": "#483d8b",
	"darkslategray": "#2f4f4f",
	"darkturquoise": "#00ced1",
	"darkviolet": "#9400d3",
	"deeppink": "#ff1493",
	"deepskyblue": "#00bfff",
	"dimgray": "#696969",
	"dodgerblue": "#1e90ff",
	"firebrick": "#b22222",
	"floralwhite": "#fffaf0",
	"forestgreen": "#228b22",
	"fuchsia": "#ff00ff",
	"gainsboro": "#dcdcdc",
	"ghostwhite": "#f8f8ff",
	"gold": "#ffd700",
	"goldenrod": "#daa520",
	"gray": "#808080",
	"green": "#008000",
	"greenyellow": "#adff2f",
	"honeydew": "#f0fff0",
	"hotpink": "#ff69b4",
	"indianred ": "#cd5c5c",
	"indigo ": "#4b0082",
	"ivory": "#fffff0",
	"khaki": "#f0e68c",
	"lavender": "#e6e6fa",
	"lavenderblush": "#fff0f5",
	"lawngreen": "#7cfc00",
	"lemonchiffon": "#fffacd",
	"lightblue": "#add8e6",
	"lightcoral": "#f08080",
	"lightcyan": "#e0ffff",
	"lightgoldenrodyellow": "#fafad2",
	"lightgrey": "#d3d3d3",
	"lightgreen": "#90ee90",
	"lightpink": "#ffb6c1",
	"lightsalmon": "#ffa07a",
	"lightseagreen": "#20b2aa",
	"lightskyblue": "#87cefa",
	"lightslategray": "#778899",
	"lightsteelblue": "#b0c4de",
	"lightyellow": "#ffffe0",
	"lime": "#00ff00",
	"limegreen": "#32cd32",
	"linen": "#faf0e6",
	"magenta": "#ff00ff",
	"maroon": "#800000",
	"mediumaquamarine": "#66cdaa",
	"mediumblue": "#0000cd",
	"mediumorchid": "#ba55d3",
	"mediumpurple": "#9370d8",
	"mediumseagreen": "#3cb371",
	"mediumslateblue": "#7b68ee",
	"mediumspringgreen": "#00fa9a",
	"mediumturquoise": "#48d1cc",
	"mediumvioletred": "#c71585",
	"midnightblue": "#191970",
	"mintcream": "#f5fffa",
	"mistyrose": "#ffe4e1",
	"moccasin": "#ffe4b5",
	"navajowhite": "#ffdead",
	"navy": "#000080",
	"oldlace": "#fdf5e6",
	"olive": "#808000",
	"olivedrab": "#6b8e23",
	"orange": "#ffa500",
	"orangered": "#ff4500",
	"orchid": "#da70d6",
	"palegoldenrod": "#eee8aa",
	"palegreen": "#98fb98",
	"paleturquoise": "#afeeee",
	"palevioletred": "#d87093",
	"papayawhip": "#ffefd5",
	"peachpuff": "#ffdab9",
	"peru": "#cd853f",
	"pink": "#ffc0cb",
	"plum": "#dda0dd",
	"powderblue": "#b0e0e6",
	"purple": "#800080",
	"red": "#ff0000",
	"rosybrown": "#bc8f8f",
	"royalblue": "#4169e1",
	"saddlebrown": "#8b4513",
	"salmon": "#fa8072",
	"sandybrown": "#f4a460",
	"seagreen": "#2e8b57",
	"seashell": "#fff5ee",
	"sienna": "#a0522d",
	"silver": "#c0c0c0",
	"skyblue": "#87ceeb",
	"slateblue": "#6a5acd",
	"slategray": "#708090",
	"snow": "#fffafa",
	"springgreen": "#00ff7f",
	"steelblue": "#4682b4",
	"tan": "#d2b48c",
	"teal": "#008080",
	"thistle": "#d8bfd8",
	"tomato": "#ff6347",
	"turquoise": "#40e0d0",
	"violet": "#ee82ee",
	"wheat": "#f5deb3",
	"white": "#ffffff",
	"whitesmoke": "#f5f5f5",
	"yellow": "#ffff00",
	"yellowgreen": "#9acd32",
	// system colors
	"window": "#ffffff",
	"windowframe": "#000000",
	"windowtext": "#000000"
};

function colourNameToHex(color) {
	return colors[color.toLowerCase()];
}

function rtfContext() {
	return {
		open: function(key) {
			if (!this[key]) {
				this[key] = {};
				this[key].current = 0;
			}
			this[key].current++;
			this[key].pending = true;
			if (this[key].value && this[key].value[this[key].current - 1]) {
				this[key].value.pop();
			}
		},
		close: function(key) {
			this[key].current--;
			if (!this[key].current) this[key].pending = false;
			else this[key].pending = true;
		},
		current: function(key) {
			return (this[key] ? this[key].current : 0);
		},
		pending: function(key, val) {
			if (val !== undefined) {
				if (!this[key]) this[key] = {};
				this[key].pending = val;
			};
			return (this[key] ? this[key].pending : false);

		},
		value: function(key, val) {
			if (!this[key]) return 0;
			if (val !== undefined) {
				val = parseInt(val, 10);
				if (this[key].value === undefined) this[key].value = [];
				this[key].value.push(((this[key].current - 1) ? (this[key].value[this[key].current - 2] + val) : val));
				//this[key].value[this[key].current-1]=((this[key].current-2)? (this[key].value[this[key].current-2]+val):val);
			};
			// console.log("Value:" + this[key].value[this[key].current-1] + " val:"+val);
			return ((this[key] && this[key].value) ? this[key].value[this[key].current - 1] : 0);

		},
		nl: false,
		par: false,
		ulindent: 0
	};
};

function builder(documentModel) {
	var rtffonts = documentModel.fonts,
		colors = documentModel.colors,
		// deffont = null,
		rtftext = "",
		needSpace = false,
		ctx = rtfContext();

	function has(obj, key) {
		return Object.prototype.hasOwnProperty.call(obj, key);
	}

	function isEmpty(obj) {
		if (obj == null) return true;
		for (var key in obj)
			if (has(obj, key)) return false;
		return true;
	}

	if (!isEmpty(rtffonts)) {
		rtftext += "{\\fonttbl";
		Object.keys(rtffonts).forEach(function(key) {
			rtftext += "{\\" + key + " " + rtffonts[key].name + ";}";
		});
		rtftext += "}";
	}

	if (colors.length > 1) {
		rtftext += "{\\colortbl";
		colors.forEach(function(e) {
			if (e[0] === 0 && e[1] === 0 && e[2] === 0) {
				rtftext += ';';
			} else {
				rtftext += "\\red" + e[0] + "\\green" + e[1] + "\\blue" + e[2] + ";";
			}
		});
		rtftext += "}";
	}

	rtftext += "\\uc0\\pard";

	function fromHtmlTag(tag) {
		tag = tag.toLowerCase();
		switch (tag) {
			case "p":
				return "\\par";
			case "b":
				return "\\b";
			case "i":
				return "\\i";
			case "u":
				return "\\ul";
			case "s":
				return "\\strike";
			case "br":
				return "\\par";
			case "blockquote":
				return "";
				//	case "li":
				//		return "\\bullet";
			default:
				return ""; //<!-- " + tag + " -->"; "\\"+tag ;
		}
	}

	return {
		//header: function(){
		//	rtftext=header+rtftext ;
		//},
		open: function() {
			rtftext += "{";
			needSpace = false;
		},
		text: function(str) {
			var pos = 0,
				beg = pos,
				c;

			while (pos < str.length) {
				while (str.charCodeAt(pos) <= 128 && str.charCodeAt(pos) != 10) {
					pos++;
				}
				if (pos > beg) {
					rtftext += (needSpace ? " " : "") + str.substring(beg, pos);
				} else if (str.charCodeAt(pos) == 10) {
					rtftext += (needSpace ? " " : "");
				}
				needSpace = false;
				if (pos < str.length) {
					c = str.charCodeAt(pos);
					// replace nbsp and \n by space
					if (c === 160 || c === 10) {
						rtftext += " ";
					} else {
						this.controlarg("u", str.charCodeAt(pos));
					}
					pos++;
				}
				beg = pos;
			}
		},
		fragment: function(str) {
			rtftext += str;
			needSpace = false;
		},
		font: function(fid) {
			if (fid !== "") {
				rtftext += "\\" + fid;
				needSpace = true;
			}
		},
		controlarg: function(word, arg) {
			rtftext += "\\" + word + arg;
			needSpace = true;
		},
		control: function(word) {
			ctx.par = (word == "par");
			rtftext += "\\" + word;
			needSpace = true;
		},
		htmltag: function(word) {
			var rtf = fromHtmlTag(word);
			if (rtf) {
				ctx.par = (rtf == "\\par");
			}
			rtftext += rtf;
			needSpace = true;
		},
		star: function() {
			rtftext += "\\*";
			needSpace = false;
		},
		close: function() {
			if (!ctx.par) rtftext += "\\par";
			rtftext = "{\\rtf1\\ansi" + rtftext + "}";
			needSpace = false;
		},
		getRtf: function() {
			return rtftext;
		},
		context: ctx
	};
}

var tagMap = {
	"margin-left": "li",
	"margin-right": "ri",
	"margin-top": "sb",
	"margin-bottom": "sa"
},
	toTwips = (function(unit, v) {
		// see http://publib.boulder.ibm.com/infocenter/domhelp/v8r0/index.jsp?topic=%2Fcom.ibm.productivity.tools.help%2Ftext%2Fcommon%2F00%2F00000003.html
		var ratio = {
			"pt": 20,
			"px": 15,
			"mm": 56.7,
			"cm": 567,
			"in": 1440.18
		};

		return function(unit, v) {
			return v * (ratio[unit] || ratio["px"]);
		};
	})();

exports.buildRtf = function(html) {
	var documentModel = {};
	documentModel.deffont = "";
	documentModel.fonts = {};
	documentModel.colors = [];
	documentModel.styles = {};
	var fontfamgroups = {
		fnil: "Sans-serif",
		froman: "Sans-serif",
		fswiss: "Serif",
		fmodern: "Monospace",
		fscript: "Cursive",
		fdecor: "Cursive"
	};
	var align = {
		left: "ql",
		center: "qc",
		right: "qr",
		justify: "qj"
	};
	var pointPxTable = [{
		pt: 6,
		px: 7
	}, {
		pt: 7,
		px: 9
	}, {
		pt: 40,
		px: 50
	}];
	var bld;
	var $root = $('<div>').append(html);
	//var $root = $(html);
	var rtffonts = [];
	//var first = false ;
	function findColor(arr, obj) {
		if (!obj) return -1;
		for (var i = 0; i < arr.length; i++) {
			if (arr[i][0] == obj[0] && arr[i][1] == obj[1] && arr[i][2] == obj[2]) {
				return i;
			}
		}
		return -1;
	}

	function isLeftIndent(n) {
		return ($(n).is("div[style]") ? ($(n).attr('style').search("margin-left") > -1) : false);
	}

	function addFont(face) {
		rtffonts.indexOf(face) < 0 && rtffonts.push(face);
	}

	function findFont(fontname) {
		var fonts = documentModel.fonts,
			keys = Object.keys(fonts);
		for (var i = 0; i < keys.length; i++) {
			if (fonts[keys[i]].name === fontname) return keys[i];
		}
		return "";
	}

	function isList(n) {
		return (($(n).is("ul") || $(n).is("li")) || (n.childElementCount > 0 && n.firstChild.nodeName === "UL"));
	}

	function processNode(n, i) {
		var clr, idx, colorid;
		//console.log(((n.nodeType!==3)?n.nodeName:n.nodeValue) + " " + (n.id?n.id:""))
		if (bld.context.pending("blockquote") && !bld.context.current("list") && !$(n).is("blockquote") && !$(n).is("div") && !bld.context.current("list") && !isList(n)) {
			bld.control("li" + (bld.context.current("blockquote") * 600));
			bld.context.pending("blockquote", false);
		}
		if (n.nodeType === 3) { // TEXT node
			bld.text(n.nodeValue);
			bld.context.par = false;
			if (n.nextSibling && $(n.nextSibling).is("blockquote")) {
				bld.control("par");
			}
		} else if ($(n).is("*[style]") && !$(n).is("blockquote")) {
			var rules = $(n).attr('style').split(';');
			var drill = !(($(n).attr('style').search("text-align") > -1) && ($(n).attr('style').search("margin-left") > -1)),
				tal = null;
			if (n.nodeName == "B") {
				bld.htmltag(n.nodeName);
			}
			rules.forEach(function(e) {
				var stylerule = e.split(':');
				if (stylerule[0] != null) stylerule[0] = stylerule[0].replace(/^\s*/, '').replace(/\s*$/, '');
				if (stylerule[1] != null) stylerule[1] = stylerule[1].replace(/^\s*/, '').replace(/\s*$/, '');
				switch (stylerule[0]) {
					case 'color':
						if (stylerule[1].substring(0, 3) === 'rgb') {
							clr = rgbColor(stylerule[1]);
							idx = findColor(documentModel.colors, clr);
						} else {
							idx = findColorInColortbl(stylerule[1]);
						}

						colorid = "cf";
						bld.controlarg(colorid, idx);
						break;

					case 'background-color':
						if (stylerule[1].substring(0, 3) === 'rgb') {
							clr = rgbColor(stylerule[1]);
							idx = findColor(documentModel.colors, clr);
						} else {
							idx = findColorInColortbl(stylerule[1]);
						}

						colorid = "highlight";
						bld.controlarg(colorid, idx);
						break;

					case 'text-decoration':
						if (stylerule[1] === 'underline') bld.control('ul');
						else if (stylerule[1] === 'line-through') bld.control('strike');
						break;
					case 'font-style':
						if (stylerule[1] === 'italic') bld.control('i');
						break;
					case 'font-weight':
						if (stylerule[1] === 'bold') bld.control('b');
						break;

					case 'font-size':
						var tmp = $(n).attr("style");
						var m = /([0-9\.\-]+)([A-Za-z]*)/g.exec(stylerule[1]),
							unit = m[2] && m[2].toLowerCase();
						//console.log(unit)
						if (unit != "em") {
							var points = parseFloat(stylerule[1]);
							var halfpoints = Math.round(points * 2);
							bld.controlarg("fs", halfpoints);
							bld.context.fs = true;
						}
						break;
					case 'margin-left':
						var m = /([0-9\.\-]+)([A-Za-z]*)/g.exec(stylerule[1]),
							unit = m[2] && m[2].toLowerCase() || "px",
							val = parseInt(m[1], 10);
						if ($(n).is("ul")) {
							bld.context.ulindent = val / 40;
							bld.context.open("list");
						} else if ($(n).is("div") || $(n).is("p")) {
							bld.context.open("lindent");
							bld.context.value("lindent", val);
							bld.controlarg(tagMap[stylerule[0]], toTwips(unit, bld.context.value("lindent")));
							//bld.context.pending("lindent",false)
							if (tal) {
								bld.control(align[tal]);
							}
						};
						if (drill) {
							$(n).contents().each(visit);
							if (n.nodeName === "P") {
								bld.context.close("lindent");
								bld.control("par");
							} else if (n.nodeName === "DIV") {
								bld.context.close("lindent");
							};
							if (bld.context.current("lindent")) {
								bld.controlarg(tagMap[stylerule[0]], toTwips(unit, bld.context.value("lindent")));
							} else {
								bld.control("pard");
							}
							//bld.context.pending("lindent",false)
						};
						drill = true;
						break;
					case 'margin-right':
					case 'margin-top':
					case 'margin-bottom':
						var m = /([0-9\.\-]+)([A-Za-z]*)/g.exec(stylerule[1]),
							unit = m[2] && m[2].toLowerCase() || "px",
							val = parseInt(m[1], 10);
						bld.controlarg(tagMap[stylerule[0]], toTwips(unit, val));
						$(n).contents().each(visit);
						if (n.nodeName === "P") {
							bld.control("par");
						}
						bld.control("pard");
						break;
					case 'margin':
						$(n).contents().each(visit);
						if (n.nodeName === "P") {
							bld.control("par");
						}
						break;
					case 'text-align':
						if (drill) {
							bld.control("pard");
							var alignment = stylerule[1];
							bld.control(align[alignment]);
							$(n).contents().each(visit);
							bld.control("par");
							bld.control("pard");
						} else {
							tal = stylerule[1];
						}
						drill = true;
						break;
				}
			});
		} else if ($(n).is("font")) {
			if ($(n).is("font[face]")) {
				var face = $(n).attr("face");
				bld.font(findFont(face));
			}
			if ($(n).is("font[color]")) {
				idx = findColorInColortbl($(n).attr("color"));
				colorid = "cf"; //+ idx;
				bld.controlarg(colorid, idx);
			}
			if ($(n).is("font[bgcolor]")) {
				idx = findColorInColortbl($(n).attr("bgcolor"));
				colorid = "highlight"; //+ idx; //"cb"+(idx);
				bld.controlarg(colorid, idx);
			}
			//Even if "SIZE" attribute of "FONT" html tag is obsolete, when copy/paste from Word document, attribute could be present.
			if ($(n).is("font[size]")) {
				idx = findFontSize($(n).attr("size"));
				bld.controlarg("fs", idx);
			}
		} else if ($(n).is("div[align]")) {
			var alignment = $(n).attr("align");
			bld.control("pard");
			bld.control(align[alignment]);

			$(n).contents().each(visit);
			if (!(n.childElementCount > 0 && n.firstChild.nodeName === "P")) {
				bld.control("par");
			}
			bld.control("pard");
		} else if (n.nodeName === "UL") {
			bld.control("pard");
			bld.context.open("list");
		} else if (n.nodeName === "LI") {
			bld.fragment("{\\pntext");
			bld.font(findFont("Symbol"));
			bld.fragment("\\'B7\\tab}");
			if (bld.context.pending("list")) {
				var uls = bld.context.current("list") + bld.context.current("blockquote") + bld.context.ulindent;
				uls = uls + bld.context.current("lindent");
				bld.fragment("{\\*\\pn\\pnlvlblt\\pnf1\\pnindent0{\\pntxtb\\'B7}}\\f0\\li" + (uls * 420));
				bld.context.ulindent = 0;
				bld.context.pending("list", false);
			}
		} else if (n.nodeName === "P") {
			bld.control("par");
		} else {
			bld.htmltag(n.nodeName);
		}
	}

	function parseColor(color) {
		var match = /#(..)(..)(..)/.exec(color) || /#(..)(..)(..)/.exec(colourNameToHex(color));
		return match && match.slice(1).map(function(v) {
			return parseInt(v, 16);
		});
	}

	function findColorInColortbl(colorstr) {
		var parsedclr = parseColor(colorstr);
		/*if (parsedclr[0]==0 && parsedclr[1]==0 && parsedclr[2]==0)
			return 0 ;*/
		var idx = findColor(documentModel.colors, parsedclr);
		if (idx == -1) return -1;
		else return idx;
	}

	function findFontSize(size) {
		size = parseInt(size, 10);
		if (size < 0 || size > 7) return 0;
		return [0, 18, 20, 24, 28, 36, 48, 72][size];
	}

	function scan(n) {
		if (!n) return;
		n.each(visit);
	}

	function processColor(coln, atb) {
		coln.each(function(i, e) {
			var tmp = $(e).attr(atb);
			var rgb = parseColor(tmp);
			if (rgb && findColor(documentModel.colors, rgb) == -1) {
				documentModel.colors.push(rgb); /*(rgb[0]!=0 || rgb[1]!=0 || rgb[2]!=0) &&*/
			}
		});
	}

	function processColorStyle(coln) {
		var clr, idx;
		coln.each(function(i, e) {
			var s = $(e).attr("style"),
				styles = s && s.replace(/[\n\r]*\s*/g, '').split(';'),
				colorstyles = styles && styles.filter(function(e) {
					var rule = e.split(':');
					rule[0] = rule[0].replace(/^\s*/, '').replace(/\s*$/, '');
					return ['color', 'background-color', 'background'].indexOf(rule[0]) != -1;
				});

			var stylerule = colorstyles && colorstyles[0] && colorstyles[0].split(':');
			if (stylerule && stylerule[1]) {
				stylerule[1] = stylerule[1].replace(/^\s*/, '').replace(/\s*$/, '');
				if (stylerule[1].substring(0, 3) === 'rgb') {
					clr = rgbColor(stylerule[1]);
					idx = findColor(documentModel.colors, clr);
				} else {
					idx = findColorInColortbl(stylerule[1]);
					clr = parseColor(stylerule[1]);
				}
				if (idx == -1) {
					clr && documentModel.colors.push(clr);
				}
			}
		});
	}

	function extractFontsAndColors() {
		var fnts = $root.find('font[face]');
		var clrs = $root.find('font[color]');
		var bgclrs = $root.find('font[bgcolor]');
		var stylebgclrs = $root.find('*[style*="background-color"]');
		var styleclrs = $root.find('*[style*="color"]');
		addFont("MS Sans Serif"); //default
		fnts.each(function(i, e) {
			addFont($(e).attr("face"));
		});
		// For bullets
		if ($root.find("ul").length > 0) {
			addFont("Symbol");
		}

		// {\\f1\\fnil\\fcharset2 Symbol;		}
		/*if (documentModel.colors.length==0)
			documentModel.colors.push([0,0,0]) ;*/
		processColor(clrs, "color");
		processColor(bgclrs, "bgcolor");
		processColorStyle(stylebgclrs);
		processColorStyle(styleclrs);
	}

	function rgbColor(colorString) {
		var match = /\s*rgb\(\s*(\d+),\s*(\d+),\s*(\d+)\s*\);*/.exec(colorString);
		if (!match) return [];
		return match.slice(1).map(function(elt) {
			return parseInt(elt, 10);
		});
	}

	function visit(i, e) {
		var $e = $(e),
			$contents;
		//	    console.log("visit >>>>>>>>" + ((e.nodeType!==3)?e.nodeName:e.nodeValue) + " " + (e.id?e.id:""))
		if ($e.is("blockquote")) {
			bld.context.open("blockquote");
		} else if ($e.is("div[align]") || ($e.is('*[style*=text-align]') || $e.is('*[style*=margin]'))) {
			//console.log("div align || text-align || margin")
			processNode(e, i);
			if (e.nodeName === "UL" /*|| $e.is('div[style*=margin]')*/ ) {
				bld.control("pard");
			}
			return;
		}

		var grp, nl, sibling = e.nextSibling,
			crlf = (e.nodeName === "P" && e.childElementCount === 1 && e.firstChild.nodeName === "BR") //in somme case,on enter,  Chrome  can  build br in p;
			$contents = $e.contents();
		if (!$e.is("blockquote") && sibling && sibling.nodeName === "DIV" && !isLeftIndent(e) && !isLeftIndent(sibling)) {
			if (!(sibling.childElementCount > 0 && (sibling.firstChild.nodeName === "BR" || sibling.firstChild.nodeName === "P")) && !crlf) {
				nl = true;
			}
		} else if ($contents.length > 0 && sibling && !$e.is("ul") && !$e.is("li") && !$e.is("blockquote") && !$e.is("p")) {
			grp = true;
			bld.fragment("{");
		}
		if ($e.is("p[align]")) {
			var alignment = $e.attr("align");
			bld.control("pard");
			bld.control(align[alignment]);
		}
		if (!$e.is("p")) {
			processNode(e, i);
		}
		/*if (e.nodeName === "UL") {
			bld.control("pard");
		}*/
		$contents.each(visit);
		if (e.nodeName === "P" && !nl && !crlf) {
			processNode(e, i);
		}
		if (e.nodeName === "B" || $e.is('*[style*=font-weight]')) {
			bld.control("b0");
		}
		if (e.nodeName === "U" || $e.is('*[style*=text-decoration]')) {
			bld.control("ul0");
		}
		if ($e.is('*[style*=font-size]') && bld.context.fs) {
			bld.context.fs = false;
			if (!grp) {
				bld.control("fs16");
			}
		}
		if (e.nodeName === "I" || $e.is('*[style*=font-style]')) {
			bld.control("i0");
		}
		if ($e.is('*[style*=color]') && !$e.is('*[style*=background-color]') && !grp) {
			bld.control("cf0");
		}
		if (e.nodeName === "UL") {
			bld.context.close("list");
			bld.control("pard");
			bld.context.par = true;
			if (bld.context.current("blockquote")) {
				bld.context.pending("blockquote", true);
			}
			if (bld.context.current("lindent") && e.nextSibling && e.nextSibling.nodeType === 3) {
				bld.control("li" + toTwips("px", bld.context.value("lindent")));
			}
		} else if ($e.is("li")) {
			bld.control("par");
		}

		if (grp) {
			bld.fragment("}");
		}
		if ($e.is("blockquote") && bld.context.current("blockquote")) {
			if (bld.context.pending("blockquote")) {
				bld.context.close("blockquote");
				if (!bld.context.current("blockquote") && sibling && !$(sibling).html()) {
					bld.context.nl = true;
				}
			} else {
				if (!bld.context.par) {
					bld.control("par");
				}
				bld.control("pard");
				bld.context.close("blockquote");
			}
		}
		if (nl || bld.context.nl) {
			bld.context.nl = false;
			bld.control("par");
		}
	}

	function createFontTable() {
		var fname;
		for (var i = 0; i < rtffonts.length; i++) {
			fname = "f" + i;
			documentModel.fonts[fname] = {
				name: rtffonts[i]
			};
		}
	}

	documentModel.colors.push([0, 0, 0]);
	extractFontsAndColors();
	createFontTable();
	bld = builder(documentModel);
	//bld.header() ;
	//console.log("buildRtf --->"+$root.html());
	scan($root);

	bld.close();
	var rtftxt = bld.getRtf();
	//console.log("buildRtf --->"+rtftxt);
	return rtftxt;
};
});

define('syracuse-tablet/html/js/helpers/syracuse-rtf/lib/index',['require','exports','module','./rtfparse','./rtfinterpret','./buildhtml','./buildrtf'],function (require, exports, module) {"use strict";
var rtfParser = require("./rtfparse"),
	rtfInterpreter = require("./rtfinterpret"),
	htmlBuilder = require("./buildhtml"),
	rtfBuilder = require("./buildrtf");

/// !doc
/// # RTF converter
/// Helper functions to convert RTF text from and to HTML.
/// 
/// `var convert = require('syracuse-rtf');`  
/// `var html = convert.toHtml(rtf, options);`  
/// `var rtf = convert.fromHtml(html, options);`  
// will see about options later
module.exports = {
	toHtml: function(rtf, options) {
		rtf = rtf || "";
		var root = rtfParser.parse(rtf);
		var model = rtfInterpreter.interpret(root);
		return htmlBuilder.buildHtml(root, model);
	},
	fromHtml: function(html, options) {
		return rtfBuilder.buildRtf(html);
	}
};
});

define('syracuse-tablet/html/js/helpers/syracuse-rtf/index',['require','exports','module','./lib/index'],function (require, exports, module) {"use strict";
module.exports = require('./lib/index');
});

define('syracuse-tablet/html/js/controls/field/ctrlText',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/html-escape/index','syracuse-tablet/html/js/ajax/ajax','syracuse-tablet/html/js/helpers/syracuse-rtf/index','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/sdata/entities/clientContract'],function (require, exports, module) {"use strict";
var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var escaper = require('syracuse-tablet/html/js/helpers/html-escape/index').escaper({
	warn: console.warn.bind(console),
	allowedAttributes: ["style"],
	allowedTags: ["span"]
});
var ajax = require('syracuse-tablet/html/js/ajax/ajax').getAjax().ajax;
var rtf = require('syracuse-tablet/html/js/helpers/syracuse-rtf/index');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');

var _baseHeight = 34; // based on input height within the app


/**
 * Text field
 * authoring:
 * 		$height	set the height of the image - default is _defHeight
 */
var _Klass = utils.defineClass(

	function CtrlText(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		if (article && !article.$labelPosition) {
			article.$labelPosition = "top";
		}
		Base.call(this, controller, article, prototype, options);
		this.cssType = "s-m-clob s-m-" + this.$type.replace("/", "-");
	}, Base, {
		destroy: function() {
			$(this.$$input).off('keyup input');
			Base.prototype.destroy.call(this);
		},
		_getHeightPixelValue: function(authH) {
			switch (authH) {
				case "medium":
					return 2 * _baseHeight;
				case "large":
					return 4 * _baseHeight;
				case "xlarge":
					return 8 * _baseHeight;
				default:
					return _baseHeight;
			}
		},
		buildFieldValue: function(parentSlot, buildOptions) {
			var self = this;
			self.$$elmt.css("display", "");

			// Create the enriched text content under the standard s-m-value parent
			var parent = Base.prototype.buildFieldValue.call(self, parentSlot, buildOptions);

			// enriched text container div
			var $$container = $('<section><div class="s-m-enriched-text"></div></section>').appendTo(parent).children(":first-child");

			// dom element which will contain the text
			var $$textContent = $(uiUtils.createDomElement("div", ["s-m-enriched-text-content"], null, null, $$container));

			/**
			 * !!! It's mandatory to have a fixed height for $$container because we need it to calculate the height of the page
			 * If no height is specified it will be set after the data has been loaded (too late)
			 */
			self.authH = self.getAuthoring("$textHeight", "medium");
			self.authH = self._getHeightPixelValue(self.authH);

			// If a new record is created there is hardly a linked text clob that can be shown, so we jump out here
			if (this.controller.$facet === "create") {
				$$textContent.html("&nbsp"); // Just to align hight with other fields, otherwise it looks wired
				return;
			}
			var docUrl = self.prototype.data("$url", self.getDao()) || "";
			var deferred;
			if (clientContract.isLocalEntityUrl(docUrl)) {
				// Used to returned data in client entities
				deferred = $.smResolve(clientContract.callLocalEntityUrl(docUrl));
			} else {
				deferred = ajax("GET", docUrl, null, null, {
					noJsonParsing: true
				});
			}
			deferred.then(function(result) {
				if (self.destroyed) return;
				var responseText = result ? result.responseText || "" : "";
				var empty = (responseText == null || responseText.length === 0) && !self.$isEditMode;
				self.$$elmt.toggleClass("s-m-empty", empty);
				self.asynchCheckEmptyValue(empty);
				if (empty) {
					$$container.remove();
					return;
				}
				// put text content
				var $$dataArr = [];
				switch (self.$type) {
					case "text/plain":
						self.buildFieldFromPlain(responseText, $$textContent);
						break;
					case "text/html":
						self.buildFieldFromHtml(responseText, $$textContent);
						break;
					case "text/rtf":
						self.buildFieldFromRtf(responseText, $$textContent);
						break;
				}

				/*
				 *	Set text-content height so that line of text is not half cut.
				 *	We use text line-height css property value
				 */
				var lineheight = parseInt($$textContent.css("line-height").replace("px", ""), 10);
				var multiplier = Math.floor(self.authH / lineheight);
				self.computedHeight = lineheight * multiplier;

				$$textContent.css({
					height: self.computedHeight + "px"
				});
				self.appendExpander($$textContent);
			}).fail(function(e) {
				self.insertError(e.message);
			});
		},

		onBlur: function(justCheck) {
			var res = Base.prototype.onBlur.call(this, justCheck);
			if (this.controller._gestureMgr && !this.controller._gestureMgr.isNative()) {
				// In ctrlText in edit mode with a text area
				// If we input a lot of lines the browser scrolls up the parent to keep the cursor at the same position
				// We need to reset it to 0 in non-native scrolling
				this.controller._gestureMgr.$$elmt.parent().scrollTop(0);
				// We need to update the scroller in any cases
				notifications.notifyController("sm.scroller.update", this.controller, true);
			}
			return res;
		},
		/**
		 * Can be overridden - gauge
		 * forceEmpty used by asynchronous processes (ctrlText)
		 */
		checkEmptyValue: function(forceEmpty) {
			return;
		},
		asynchCheckEmptyValue: function(forceEmpty) {
			Base.prototype.checkEmptyValue.call(this, forceEmpty);
		},

		/*
		 *	Append an expander button for the text field.
		 *	Button is appended only if full text height (scrollheight) is higher than self.authH by at least 5px
		 */
		appendExpander: function($$container) {
			var self = this;
			var scrollHeight = self.$$input ? self.$$input.scrollHeight : $$container.get(0).scrollHeight;
			if (scrollHeight > self.computedHeight && ((scrollHeight - self.computedHeight) > 5)) {

				// build expander button
				var buttonTmpl = '<a href="#" class="' + fontUtils.getIconByName("expand") + '" data-action="toggleText"\
				data-control-id="' + self.id + '" data-params="more"></a>';
				var $$expander = self.$$expander = $(buttonTmpl);

				// append the button
				$$expander.insertBefore($$container);

				$$expander.css("float", "right");

				$$expander.wrap("<div class='s-m-enriched-text-expander'></div>");

				$$expander.parent().height($$expander.outerHeight());
			}
		},
		/**
		 * Display an error
		 */
		insertError: function(msg) {
			var err = ['<span class="s-m-error"><p>'];
			err.push(msg);
			err.push("<p></span>");
			$(err.join('')).appendTo(this.$$elmt);
		},
		buildFieldFromPlain: function(data, $$parent) {
			var self = this;
			if (this.$isEditMode) {
				self.createMainInput($$parent, data, "textplain", {
					"wrap": "soft",
					"spellcheck": false,
					"autocorrect": "off",
					"autocomplete": "off",
					"style": "overflow-y:hidden;box-size:border-box;resize:none;width:100%;height:100%",
					"row": "2"
				});
				this.$$input.val(data);
				this.$$input.on('keyup input', function() {
					self._triggerResizeInput();
				});
			} else {
				$$parent.append($.parseHTML(escaper(data.replace(/\n/g, "<BR/>"))));
			}
		},
		_triggerResizeInput: function() {
			var triggerResize = false;
			if (this.$$expander && this.$$expander.attr("data-params") === "more") {
				this._expandText(this.$$input.parent());
				triggerResize = true;
			};
			this._resizeInput();
			if (triggerResize) {
				uiUtils.triggerResizeInternal({
					preserveScroll: true
				});
			}
		},
		_resizeInput: function(options) {
			if (!this.$$input) return false;
			this.$$input.parent().css('height', 'auto');
			this.$$input.css('height', 'auto');
			var domElmt = this.$$input.get(0);
			var height = (options && options.height != null) ? options.height : (domElmt.scrollHeight + (domElmt.offsetHeight - domElmt.clientHeight));
			this.$$input.css('height', height);
			return false;
		},
		_expandText: function($textContent) {
			$textContent.css({
				height: "auto"
			});
			this.$$expander.toggleClass(fontUtils.getIconByName("expand"), false);
			this.$$expander.toggleClass(fontUtils.getIconByName("compress"), true);
			this.$$expander.attr("data-params", "less");
		},
		_compressText: function($textContent) {
			$textContent.css({
				height: this.computedHeight + "px"
			});
			this.$$expander.toggleClass(fontUtils.getIconByName("compress"), false);
			this.$$expander.toggleClass(fontUtils.getIconByName("expand"), true);
			this.$$expander.attr("data-params", "more");
		},
		/*
		 * Toggle enriched text. It will either show more or hide
		 */
		_actToggleText: function(param) {
			// show whole text field
			// change button label
			var $textContent = this.$$input ? this.$$input.parent() : this.$$elmt.find(".s-m-enriched-text-content");
			if (param === "more") {
				this.currentHeight = null;
				this._expandText($textContent);
				this._resizeInput();
			}
			// decrease text field height
			else {
				this._compressText($textContent);
				this._resizeInput({
					"height": "100%"
				});
			}
			uiUtils.triggerResizeInternal({
				preserveScroll: true
			});
		},

		buildFieldFromRtf: function(data, $$parent) {
			this.buildFieldFromHtml(rtf.toHtml(data), $$parent);
		},
		buildFieldFromHtml: function(data, $$parent) {
			$$parent.append($.parseHTML(escaper(data)));
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/ctrlIcon',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/controls/ctrlBase'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var ctrlBase = require('syracuse-tablet/html/js/controls/ctrlBase');
var Base = ctrlBase.Klass;

/**
 * Icon used by arrays
 * Displays an icon according to the value of $icon in prototype
 * prototype properties
 * 		$url to attach a link to the icon
 * 		$action to attach an action/navigation to the icon
 * 			Contains all the parameters for the link (data-action, data-params...)
 */
var _Klass = utils.defineClass(

	function CtrlIcon(controller, article, prototype) {
		Base.call(this, controller, article, prototype);
	}, Base, {

		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions, ["s-m-icon"]);
			self.$$elmt.html(ctrlBase.genHtmlCtrlLink(self.prototype, controllerDao, {
				tag: 'a',
				css: ''
			}, function(html) {
				html.push('<span class="');
				html.push(fontUtils.ctrlIcon(self.prototype.data('$icon')));
				html.push('"></span>');
			}));
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/ctrlButton',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/controls/ctrlBase'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var ctrlBase = require('syracuse-tablet/html/js/controls/ctrlBase');
var Base = ctrlBase.Klass;

/**
 * Icon used by arrays
 * Displays an icon according to the value of $icon in prototype
 * prototype properties
 * 		$url to attach a link to the icon
 * 		$action to attach an action/navigation to the icon
 * 			Contains all the parameters for the link (data-action, data-params...)
 */
var _Klass = utils.defineClass(

	function CtrlButton(controller, article, prototype) {
		Base.call(this, controller, article, prototype);
	}, Base, {

		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions, ["s-m-btn"]);
			self.$$elmt.html(ctrlBase.genHtmlCtrlLink(self.prototype, controllerDao, {
				tag: 'button',
				css: 'btn btn-info btn-large'
			}, function(html) {
				var param = self.prototype.data('$icon') || "";
				if (param.length > 0) html.push('<i class="' + fontUtils.ctrlIcon(self.prototype.data('$icon')) + '"></i>');
				param = self.prototype.data('$text') || "";
				if (param.length > 0) html.push(param);
			}));
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/chart/gaugeChartstheme',['require','exports','module'],function (require, exports, module) {"use strict";

exports.ChartsTheme = {
	"colors": ["#2f7ed8", "#0d233a", "#8bbc21", "#910000", "#1aadce", "#492970", "#f28f43", "#77a1e5", "#c42525", "#a6c96a"],
	"symbols": ["circle", "diamond", "square", "triangle", "triangle-down"],
	"lang": {
		"loading": "Loading...",
		"months": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
		"shortMonths": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
		"weekdays": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
		"decimalPoint": ".",
		"numericSymbols": ["k", "M", "G", "T", "P", "E"],
		"resetZoom": "Reset zoom",
		"resetZoomTitle": "Reset zoom level 1:1",
		"thousandsSep": ","
	},
	"global": {
		"useUTC": true,
		"canvasToolsURL": "http://code.highcharts.com/3.0.2/modules/canvas-tools.js",
		"VMLRadialGradientURL": "http://code.highcharts.com/3.0.2/gfx/vml-radial-gradient.png"
	},
	"chart": {
		"borderColor": "#4572A7",
		"borderRadius": 5,
		"defaultSeriesType": "line",
		"ignoreHiddenSeries": true,
		"spacingTop": 10,
		"spacingRight": 10,
		"spacingBottom": 15,
		"spacingLeft": 10,
		"style": {
			"fontFamily": "\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif",
			"fontSize": "12px"
		},
		"backgroundColor": "#FFFFFF",
		"plotBorderColor": "#C0C0C0",
		"resetZoomButton": {
			"theme": {
				"zIndex": 20
			},
			"position": {
				"align": "right",
				"x": -10,
				"y": 10
			}
		}
	},
	"title": {
		"text": "Chart title",
		"align": "center",
		"y": 15,
		"style": {
			"color": "#666",
			"fontSize": "16px"
		}
	},
	"subtitle": {
		"text": "",
		"align": "center",
		"y": 30,
		"style": {
			"color": "#4d759e"
		}
	},
	"plotOptions": {
		"line": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": {
				"enabled": true,
				"lineWidth": 0,
				"radius": 4,
				"lineColor": "#FFFFFF",
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": "bottom"
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true
		},
		"area": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": {
				"enabled": true,
				"lineWidth": 0,
				"radius": 4,
				"lineColor": "#FFFFFF",
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": "bottom"
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true,
			"threshold": 0
		},
		"spline": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": {
				"enabled": true,
				"lineWidth": 0,
				"radius": 4,
				"lineColor": "#FFFFFF",
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": "bottom"
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true
		},
		"areaspline": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": {
				"enabled": true,
				"lineWidth": 0,
				"radius": 4,
				"lineColor": "#FFFFFF",
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": "bottom"
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true,
			"threshold": 0
		},
		"column": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": null,
				"x": 0,
				"y": null,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null
			},
			"cropThreshold": 50,
			"pointRange": null,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": 0.1,
					"shadow": false
				},
				"select": {
					"marker": {

					},
					"color": "#C0C0C0",
					"borderColor": "#000000",
					"shadow": false
				}
			},
			"stickyTracking": false,
			"borderColor": "#FFFFFF",
			"borderWidth": 1,
			"borderRadius": 0,
			"groupPadding": 0.2,
			"pointPadding": 0.1,
			"minPointLength": 0,
			"threshold": 0
		},
		"bar": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": null,
				"x": 0,
				"y": null,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null
			},
			"cropThreshold": 50,
			"pointRange": null,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": 0.1,
					"shadow": false
				},
				"select": {
					"marker": {

					},
					"color": "#C0C0C0",
					"borderColor": "#000000",
					"shadow": false
				}
			},
			"stickyTracking": false,
			"borderColor": "#FFFFFF",
			"borderWidth": 1,
			"borderRadius": 0,
			"groupPadding": 0.2,
			"pointPadding": 0.1,
			"minPointLength": 0,
			"threshold": 0
		},
		"scatter": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 0,
			"marker": {
				"enabled": true,
				"lineWidth": 0,
				"radius": 4,
				"lineColor": "#FFFFFF",
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": "bottom"
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": false,
			"tooltip": {
				"headerFormat": "<span style=\"font-size: 10px; color:{series.color}\">{series.name}</span><br/>",
				"pointFormat": "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>",
				"followPointer": true
			}
		},
		"pie": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": true,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": "bottom",
				"distance": 30
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": false,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": 0.1,
					"shadow": false
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": false,
			"borderColor": "#FFFFFF",
			"borderWidth": 1,
			"center": [
				null, null
			],
			"clip": false,
			"colorByPoint": true,
			"ignoreHiddenPoint": true,
			"legendType": "point",
			"size": null,
			"slicedOffset": 10,
			"tooltip": {
				"followPointer": true
			}
		},
		"arearange": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 1,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null,
				"xLow": 0,
				"xHigh": 0,
				"yLow": 0,
				"yHigh": 0
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true,
			"threshold": null,
			"tooltip": {
				"pointFormat": "<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.low}</b> - <b>{point.high}</b><br/>"
			},
			"trackByArea": true
		},
		"areasplinerange": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 1,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null,
				"xLow": 0,
				"xHigh": 0,
				"yLow": 0,
				"yHigh": 0
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true,
			"threshold": null,
			"tooltip": {
				"pointFormat": "<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.low}</b> - <b>{point.high}</b><br/>"
			},
			"trackByArea": true
		},
		"columnrange": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 1,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null,
				"xLow": 0,
				"xHigh": 0,
				"yLow": 0,
				"yHigh": 0
			},
			"cropThreshold": 300,
			"pointRange": null,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": 0.1,
					"shadow": false
				},
				"select": {
					"marker": {

					},
					"color": "#C0C0C0",
					"borderColor": "#000000",
					"shadow": false
				}
			},
			"stickyTracking": true,
			"borderColor": "#FFFFFF",
			"borderWidth": 1,
			"borderRadius": 0,
			"groupPadding": 0.2,
			"pointPadding": 0.1,
			"minPointLength": 0,
			"threshold": null,
			"tooltip": {
				"pointFormat": "<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.low}</b> - <b>{point.high}</b><br/>"
			},
			"trackByArea": true
		},
		"gauge": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": {
				"enabled": true,
				"lineWidth": 0,
				"radius": 4,
				"lineColor": "#FFFFFF",
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": true,
				"align": "center",
				"x": 0,
				"y": 5,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "16px",
					"lineHeight": "24px",
					"fontWeight": "normal"
				},
				"verticalAlign": "top",
				"borderWidth": 0,
				"borderColor": null,
				"borderRadius": 3,
				"zIndex": 2
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": false,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true,
			"dial": {

			},
			"pivot": {

			},
			"tooltip": {
				"style": {
					"color": "#666"
				},
				"headerFormat": ""
			}
		},
		"boxplot": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 1,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": null,
				"x": 0,
				"y": null,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null
			},
			"cropThreshold": 50,
			"pointRange": null,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": -0.3,
					"shadow": false
				},
				"select": {
					"marker": {

					},
					"color": "#C0C0C0",
					"borderColor": "#000000",
					"shadow": false
				}
			},
			"stickyTracking": false,
			"borderColor": "#FFFFFF",
			"borderWidth": 1,
			"borderRadius": 0,
			"groupPadding": 0.2,
			"pointPadding": 0.1,
			"minPointLength": 0,
			"threshold": null,
			"fillColor": "#FFFFFF",
			"medianWidth": 2,
			"tooltip": {
				"pointFormat": "<span style=\"color:{series.color};font-weight:bold\">{series.name}</span><br/>Minimum: {point.low}<br/>Lower quartile: {point.q1}<br/>Median: {point.median}<br/>Higher quartile: {point.q3}<br/>Maximum: {point.high}<br/>"
			},
			"whiskerLength": "50%",
			"whiskerWidth": 2
		},
		"errorbar": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 1,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": null,
				"x": 0,
				"y": null,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null
			},
			"cropThreshold": 50,
			"pointRange": null,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": -0.3,
					"shadow": false
				},
				"select": {
					"marker": {

					},
					"color": "#C0C0C0",
					"borderColor": "#000000",
					"shadow": false
				}
			},
			"stickyTracking": false,
			"borderColor": "#FFFFFF",
			"borderWidth": 1,
			"borderRadius": 0,
			"groupPadding": 0.2,
			"pointPadding": 0.1,
			"minPointLength": 0,
			"threshold": null,
			"fillColor": "#FFFFFF",
			"medianWidth": 2,
			"tooltip": {
				"pointFormat": "<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.low}</b> - <b>{point.high}</b><br/>"
			},
			"whiskerLength": "50%",
			"whiskerWidth": null,
			"color": "#000000",
			"grouping": false,
			"linkedTo": ":previous"
		},
		"waterfall": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 1,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": null,
				"x": 0,
				"y": null,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null
			},
			"cropThreshold": 50,
			"pointRange": null,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": 0.1,
					"shadow": false
				},
				"select": {
					"marker": {

					},
					"color": "#C0C0C0",
					"borderColor": "#000000",
					"shadow": false
				}
			},
			"stickyTracking": false,
			"borderColor": "#333",
			"borderWidth": 1,
			"borderRadius": 0,
			"groupPadding": 0.2,
			"pointPadding": 0.1,
			"minPointLength": 0,
			"threshold": 0,
			"lineColor": "#333",
			"dashStyle": "dot"
		},
		"bubble": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 0,
			"marker": {
				"enabled": true,
				"lineWidth": 1,
				"radius": 4,
				"lineColor": null,
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "white",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px",
					"textShadow": "0px 0px 3px black"
				},
				"verticalAlign": "middle",
				"inside": true
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": false,
			"tooltip": {
				"headerFormat": "<span style=\"font-size: 10px; color:{series.color}\">{series.name}</span><br/>",
				"pointFormat": "({point.x}, {point.y}), Size: {point.z}",
				"followPointer": true
			},
			"minSize": 8,
			"maxSize": "20%",
			"zThreshold": 0
		}
	},
	"labels": {
		"style": {
			"position": "absolute",
			"color": "#3E576F"
		}
	},
	"legend": {
		"enabled": true,
		"align": "center",
		"layout": "horizontal",
		"borderWidth": 1,
		"borderColor": "#909090",
		"borderRadius": 5,
		"navigation": {
			"activeColor": "#274b6d",
			"inactiveColor": "#CCC"
		},
		"shadow": false,
		"itemStyle": {
			"cursor": "pointer",
			"color": "#274b6d",
			"fontSize": "12px"
		},
		"itemHoverStyle": {
			"color": "#000"
		},
		"itemHiddenStyle": {
			"color": "#CCC"
		},
		"itemCheckboxStyle": {
			"position": "absolute",
			"width": "13px",
			"height": "13px"
		},
		"symbolWidth": 16,
		"symbolPadding": 5,
		"verticalAlign": "bottom",
		"x": 0,
		"y": 0,
		"title": {
			"style": {
				"fontWeight": "bold"
			}
		}
	},
	"loading": {
		"labelStyle": {
			"fontWeight": "bold",
			"position": "relative",
			"top": "1em"
		},
		"style": {
			"position": "absolute",
			"backgroundColor": "white",
			"opacity": 0.5,
			"textAlign": "center"
		}
	},
	"tooltip": {
		"enabled": true,
		"animation": true,
		"backgroundColor": "rgba(255, 255, 255, .85)",
		"borderWidth": 1,
		"borderRadius": 3,
		"dateTimeLabelFormats": {
			"millisecond": "%A, %b %e, %H:%M:%S.%L",
			"second": "%A, %b %e, %H:%M:%S",
			"minute": "%A, %b %e, %H:%M",
			"hour": "%A, %b %e, %H:%M",
			"day": "%A, %b %e, %Y",
			"week": "Week from %A, %b %e, %Y",
			"month": "%B %Y",
			"year": "%Y"
		},
		"headerFormat": "<span style=\"font-size: 10px\">{point.key}</span><br/>",
		"pointFormat": "<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.y}</b><br/>",
		"shadow": true,
		"snap": 10,
		"style": {
			"color": "#333333",
			"cursor": "default",
			"fontSize": "12px",
			"padding": "8px",
			"whiteSpace": "nowrap"
		}
	},
	"credits": {
		"enabled": false,
		"text": "Highcharts.com",
		"href": "http://www.highcharts.com",
		"position": {
			"align": "right",
			"x": -10,
			"verticalAlign": "bottom",
			"y": -5
		},
		"style": {
			"cursor": "pointer",
			"color": "#909090",
			"fontSize": "9px"
		}
	}
};
});

define('syracuse-tablet/html/js/controls/field/ctrlGaugeChart',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/controls/chart/gaugeChartstheme'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var chartsTheme = require('syracuse-tablet/html/js/controls/chart/gaugeChartstheme').ChartsTheme;

var _Klass = utils.defineClass(function CtrlGaugeChart(controller, article, prototype, options) {
	options = options || {};
	options.nativeCapabilities = null;
	Base.call(this, controller, article, prototype, options);
}, Base, {

	_defaultGaugeSegments: [{
		propStart: 0,
		propEnd: 0.25,
		valStart: null,
		valEnd: null,
		color: '#41A940'
	}, {
		propStart: 0.25,
		propEnd: 0.75,
		valStart: null,
		valEnd: null,
		color: '#FF5800'
	}, {
		propStart: 0.75,
		propEnd: 1,
		valStart: null,
		valEnd: null,
		color: '#CB3500'
	}],
	buildFieldValue: function(fieldSlot, buildOptions) {
		var self = this;

		var localeDecimalSep = locale.getNumberDecimalSeparator();
		var localeThousandSep = locale.getNumberGroupSeparator();

		if (!self.chartsTheme) {
			self.chartsTheme = chartsTheme;
		}
		if (!self.chartsTheme.themeWasSet || self.chartsTheme.decimalPoint !== localeDecimalSep || self.chartsTheme.thousandsSep !== localeThousandSep) {
			self.chartsTheme.decimalPoint = localeDecimalSep;
			self.chartsTheme.thousandsSep = localeThousandSep;

			Highcharts.setOptions(self.chartsTheme);
			self.chartsTheme.themeWasSet = true;
		}

		self._renderGauge();
	},

	checkEmptyValue: function() {
		return;
	},

	buildFieldTitle: function(fieldSlot, buildOptions) {
		// override because nothing to do
	},
	_resolveExpr: function(expr, data, cp) {
		if (typeof expr !== "string") return expr;
		return expr.replace(/\{(\w+)\}/g, function(d0, d1) {
			if (data[d1] != null) return data[d1];
			if (cp[d1] != null) return cp[d1];
			return d0;
		});
	},
	// Merge default values for gauge segments with data comming from the authoring
	_mergeAuthoringAndDefaults: function() {
		var self = this;
		var $gauge = self.article.$gauge;
		if (!$gauge.segments) // Not authoring on segments
			return self._defaultGaugeSegments;
		if ($gauge.segments.length === 0) // Not authoring on segments
			return self._defaultGaugeSegments;

		var s, def, auth, res = [];
		for (s = 0; s < $gauge.segments.length; s++) {
			def = self._defaultGaugeSegments[Math.min(s, self._defaultGaugeSegments.length - 1)];
			auth = $gauge.segments[s];
			if (!auth) {
				// no authoring for this segment, use default
				res.push(def);
			} else {
				if ((auth.propStart == null || auth.propEnd == null) && (auth.valStart == null || auth.valEnd == null)) {
					// not range defined, use default, not authoring
					auth.propStart = def.propStart;
					auth.propEnd = def.propEnd;
					auth.valStart = def.valStart;
					auth.valEnd = def.valEnd;
				}
				if (auth.color == null) {
					auth.color = def.color;
				}
				res.push(auth);
			}
		}
		return res;
	},
	// Create segment definitions for gauge
	_createBands: function(cp, valMin, valMax) {
		var self = this;
		var bands = [];

		// Grey background is always present
		bands.push({
			from: valMin,
			to: valMax,
			color: '#ccc',
			innerRadius: '79%',
			outerRadius: '101%'
		});

		var data = self.getValue();
		var bandsDef = self._mergeAuthoringAndDefaults();
		var seg;
		var s;
		var band;
		var range = valMax - valMin;
		for (s = 0; s < bandsDef.length; s++) {
			seg = bandsDef[s];
			band = {
				innerRadius: '79%',
				outerRadius: '101%',
				color: seg.color
			};
			if (seg.valStart != null && seg.valEnd != null) {
				band.from = self._resolveExpr(seg.valStart, data, cp);
				band.to = self._resolveExpr(seg.valEnd, data, cp);
			} else if (seg.propStart != null && seg.propEnd != null) {
				band.from = valMin + range * self._resolveExpr(seg.propStart, data, cp);
				band.to = valMin + range * self._resolveExpr(seg.propEnd, data, cp);
			}
			bands.push(band);
		}
		return bands;
	},
	_getScale: function() {
		var self = this;

		function getScaleFromFormat($format) {
			var match = $format.match(/\.(.*)/g);
			return match.length >= 1 ? match.length : 0;
		}

		if (self.article.$scale) {
			return self.article.$scale;
		} else {
			if (self.article.$format) {
				return getScaleFromFormat(self.article.$format);
			} else {
				return 0;
			}
		}
	},

	_renderGauge: function() {
		var self = this;

		var $$chartSlot = $(".s-m-gauge-container", self.$$elmt);
		if ($$chartSlot && $$chartSlot.length > 0) {
			$$chartSlot.remove();
		}

		$$chartSlot = $("<div>").addClass("s-m-gauge-container");
		self.$$elmt.append($$chartSlot);

		var gauge = self.article.$gauge;
		var labelColor = !self.$isEditMode ? "#34B233" : "#666";

		var val = self.getValue();
		var valMin = 0;
		var valMax = 100;

		if (gauge.$bindMin != null && gauge.$bindMax != null) {
			if (isNaN(gauge.$bindMin)) {
				valMin = self.getDao().getValue(gauge.$bindMin);
			} else {
				valMin = gauge.$bindMin;
			}
			if (isNaN(gauge.$bindMax)) {
				valMax = self.getDao().getValue(gauge.$bindMax);
			} else {
				valMax = gauge.$bindMax;
			}
		}

		try {
			if (typeof val === "string") val = parseFloat(val);
		} catch (e) {}
		try {
			if (typeof valMin === "string") valMin = parseFloat(valMin);
		} catch (e) {}
		try {
			if (typeof valMax === "string") valMax = parseFloat(valMax);
		} catch (e) {}

		var cp = self.prototype.json;

		var uom = "";
		if (cp.$unit && cp.$properties && cp.$properties[cp.$unit] && val && val[cp.$unit] && val[cp.$unit].$symbol) {
			uom = val[cp.$unit].$symbol;
		}

		var label = self.getTitle();
		var decimals = self._getScale();
		var plotBands = self._createBands(cp, valMin, valMax);

		self._calcDesiredHeight();
		var spacingBottom = 35;
		var height = self.desiredHeight;
		var centerA = "50%";
		var centerB = (height - 20) / height * 100 + "%";
		var size = height - 30;

		$$chartSlot.highcharts({
			chart: {
				type: 'gauge',
				plotBackgroundColor: null,
				plotBackgroundImage: null,
				plotBorderWidth: 0,
				plotShadow: false,
				backgroundColor: null,
				height: height,
				borderWidth: 0,
				spacingBottom: spacingBottom
			},
			title: {
				text: label,
				style: {
					color: labelColor,
					fontWeight: "normal",
					textTransform: "uppercase"
				},
				verticalAlign: "bottom",
				y: 27
			},
			pane: {
				startAngle: -90,
				endAngle: 90,
				center: [centerA, centerB],
				size: size,
				background: [{
					backgroundColor: '#FFF',
					borderWidth: 0
				}]
			},
			yAxis: {
				min: valMin,
				max: valMax,

				minorTickWidth: 1,
				minorTickInterval: 'auto',
				minorTickLength: 20,
				minorTickPosition: 'inside',
				minorTickColor: '#fff',

				tickPixelInterval: 30,
				tickWidth: 0,
				tickPosition: 'inside',
				tickLength: 15,
				tickColor: '#FFF',
				labels: {
					step: 1,
					rotation: 'auto',
					style: {
						color: "#666",
						cursor: "default",
						fontSize: "0.9em",
						fontFamily: "Arial",
						lineHeight: "14px"
					},
					distance: 10,
					y: 0,
					verticalAlign: 'center',
					align: 'center'
				},
				title: {
					text: uom,
					style: {
						color: "#666"
					}
				},
				plotBands: plotBands
			},
			plotOptions: {
				gauge: {
					dataLabels: {
						enabled: true,
						format: "{point.y:,." + decimals + "f}",
						style: {
							fontFamily: "Arial"
						}
					}
				}
			},
			exporting: {
				buttons: null
			},
			series: [{
				name: label,
				data: [val],
				tooltip: {
					valueSuffix: ' ' + uom
				}
			}]

		}, function() {});
	},
	onResize: function() {
		var self = this;
		self._renderGauge();
	},
	_calcDesiredHeight: function() {
		var self = this;
		var $$pscroll = self.$$elmt.closest(".s-m-scroll-wrapper");
		var isSingleChild = $(".s-m-control", $$pscroll).length < 2;
		var isInTile = $$pscroll.closest(".s-m-tile").length > 0;

		if (isInTile && isSingleChild) {
			// if we are the only control in a tile, we use up the full space
			var $$tile = $$pscroll.parent();
			self.desiredHeight = $$tile.height() - 20; // 20 for eventual header
		} else {
			// use a default size if there are other items or we are not in a tile
			self.desiredHeight = 200;
		}
	},
	destroy: function() {
		var self = this;
		Base.prototype.destroy.call(self);
		var $$chartSlot = $(".s-m-gauge-container", self.$$elmt);
		if ($$chartSlot && $$chartSlot.length > 0) {
			$$chartSlot.remove();
		}
	}
});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/array/ctrlRowStatus',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/helpers/fieldOperators','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

/**
 * Display the row status in table array mode
 * Enabled by authoring 'manage a status'
 */
var _Klass = utils.defineClass(

	function CtrlRowStatus(controller, article, prototype) {
		Base.call(this, controller, article, prototype);
	}, Base, {
		buildHtml: function($$parent, rowData, buildOptions) {
			var self = this;
			var ctrlArray = buildOptions.htmlRootCtrl;
			if (!ctrlArray) return;
			var statusInfo = ctrlArray.getRowStatusInfo();
			if (!statusInfo) return;
			Base.prototype.buildHtml.call(self, $$parent, rowData, buildOptions, ["s-m-row-status"]);
			var h, defIcon = fontUtils.getArrayStatusDefIcon(),
				icon;
			statusInfo.list.some(function(s) {
				if (s.color && fieldOperators.evaluateOperator(s.$type, rowData.getValue(s.field), s.operator, s.value)) {
					icon = s.icon || defIcon;
					// We use background color for color icon
					self.$$elmt.html('<div class="' + icon.css + '" style="color:' + s.color.bgColor + '"/>');
					return true;
				}
			});
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/array/ctrlRowIndex',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/ctrlBase'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;

/**
 * Display the row index
 */
var _Klass = utils.defineClass(

	function CtrlRowStatus(controller, article, prototype) {
		Base.call(this, controller, article, prototype);
	}, Base, {
		buildHtml: function($$parent, rowData, buildOptions) {
			Base.prototype.buildHtml.call(this, $$parent, rowData, buildOptions, ["s-m-row-index"]);
			this.$$elmt.append('<span class="badge">' + this.getValue() + '</span>');
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/ctrlChartDetailToolbar',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/helpers/uiSettings','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var prototype = require('syracuse-tablet/html/js/helpers/prototype');
var ctrlBase = require('syracuse-tablet/html/js/controls/ctrlBase');
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var Base = ctrlBase.Klass;

var _actions = [{
	params: "arrayOnly",
	icon: "fa fa-table"
}, {
	params: "chartOnly",
	icon: "fa fa-bar-chart"
}, {
	params: "bothSideToSide",
	icon: "fa fa-columns"
}];
var _chartStyle = [{
	params: "column",
	icon: "fa fa-bar-chart",
	enabled: true
}, {
	params: "bar",
	icon: "fa fa-bar-chart fa-rotate-90",
	enabled: true
}, {
	params: "area",
	icon: "fa fa-area-chart",
	enabled: true
}, {
	params: "line",
	icon: "fa fa-line-chart",
	enabled: true
}, {
	params: "pie",
	icon: "fa fa-pie-chart",
	enabled: true
}];
var _templates = {
	toolbar: '\
		<div class="btn-toolbar" role="toolbar">\
			<div class="btn-group">\
				{{#each actions}}\
					<button type="button" class="btn btn-default" data-action="toolbar" data-control-id="{{../ctrlId}}" data-params="{{params}}"><span class="{{icon}}"></span></button>\
				{{/each}}\
		    </div>\
			<div class="btn-group">\
				{{#each chartStyle}}\
					{{#if enabled}}\
					<button type="button" class="btn btn-default" data-action="chartstyle" data-control-id="{{../../ctrlId}}" data-params="{{params}}"><span class="{{icon}}"></span></button>\
					{{/if}}\
				{{/each}}\
		    </div>\
	    </div>'

};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	if (!tmpl) alert("template " + name + " not found");
	return tmpl(ctx);
};


/**
 * chartDetail Tool bar
 */
var _Klass = utils.defineClass(

	function CtrlChartDetailToolbar($type, controller, options) {
		Base.call(this, controller, {
			$bind: "chartDetailToolbar"
		}, prototype.create({
			$type: $type
		}), options);
		notifications.subscribe(this, "sm.chartdetail.updt.toolbar");
	}, Base, {
		buildHtml: function($$parent, controllerDao, buildOptions) {
			this._height = uiSettings.getProp("chartDetailToolbar.height");
			var measureCount = this._getChartMeasureCount();
			_chartStyle.forEach(function(itm) {
				if (itm.params == "pie") {
					itm.enabled = (measureCount == 1);
				}
			});
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions, [this.typeName]);
			this.$$elmt.html(_getHtml('toolbar', {
				ctrlId: this.id,
				actions: _actions,
				chartStyle: _chartStyle
			}));
			this.$$elmt.css("height", this._height);
		},
		_getChartMeasureCount: function() {
			var chart = this.controller.getChart();
			if (!chart) return 0;
			var count = chart.prototype.chartGetNbMeasures();
			var $seriesOptions = chart.article.$seriesOptions;
			if (!$seriesOptions) return count;
			Object.keys($seriesOptions).forEach(function(key) {
				if ($seriesOptions[key].isHidden) {
					count--;
				}
			});
			return count;
		},
		getHeight: function() {
			return this.$$elmt.is(":visible") ? this._height : 0;
		},
		_actToolbar: function(display, $$target) {
			if ($$target.closest(".btn").is(".s-m-selected")) return;
			this.controller.actToolbarSetDisplay({
				"display": display
			});
		},
		_actChartstyle: function(chartType, $$target) {
			if ($$target.closest(".btn").is(".s-m-selected")) return;
			this.controller.actToolbarSetDisplay({
				"style": chartType,
				"display": "bothSideToSide"
			});
		},
		notifChartdetailUpdtToolbar: function(opts) {
			if (!opts) return;
			if (opts.display) {
				this._updateDisplay(opts.display, "toolbar");
			}
			if (opts.display) {
				this._updateDisplay(opts.style, "chartstyle");
			}
		},
		_updateDisplay: function(display, dataAction) {
			if (globals.isAuthoringActive()) {
				this.$$elmt.find('.btn').prop("disabled", false);
			} else {
				this.$$elmt.find('.btn[data-action="' + dataAction + '"]').removeClass("s-m-selected");
				this.$$elmt.find('[data-params="' + display + '"][data-action="' + dataAction + '"]').addClass("s-m-selected");
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/ctrlFactoryDeps',['require','exports','module','syracuse-tablet/html/js/controls/field/ctrlAlphanum','syracuse-tablet/html/js/controls/field/ctrlAlphanum','syracuse-tablet/html/js/controls/field/ctrlFilter','syracuse-tablet/html/js/controls/field/ctrlAlphanum','syracuse-tablet/html/js/controls/field/ctrlAlphanum','syracuse-tablet/html/js/controls/field/ctrlProgress','syracuse-tablet/html/js/controls/field/ctrlNumeric','syracuse-tablet/html/js/controls/field/ctrlQuantity','syracuse-tablet/html/js/controls/field/ctrlCheckbox','syracuse-tablet/html/js/controls/field/ctrlSwitch','syracuse-tablet/html/js/controls/field/ctrlCombo','syracuse-tablet/html/js/controls/field/ctrlDate','syracuse-tablet/html/js/controls/array/ctrlArray','syracuse-tablet/html/js/controls/array/ctrlArrayChart','syracuse-tablet/html/js/controls/field/ctrlReference','syracuse-tablet/html/js/controls/layout/layoutRow','syracuse-tablet/html/js/controls/layout/layoutStack','syracuse-tablet/html/js/controls/layout/layoutTab','syracuse-tablet/html/js/controls/layout/layoutHub','syracuse-tablet/html/js/controls/layout/layoutHubGroup','syracuse-tablet/html/js/controls/layout/layoutTile','syracuse-tablet/html/js/controls/layout/layoutCell','syracuse-tablet/html/js/controls/vignetteBase','syracuse-tablet/html/js/controls/page/ctrlBreadCrumbs','syracuse-tablet/html/js/controls/page/ctrlPageHeader','syracuse-tablet/html/js/controls/page/ctrlPageFooter','syracuse-tablet/html/js/controls/page/ctrlVignetteFooter','syracuse-tablet/html/js/controls/page/ctrlVignetteHeader','syracuse-tablet/html/js/controls/page/panels/pageActionPanelRegular','syracuse-tablet/html/js/controls/page/panels/sortfilter/filterSortPanel','syracuse-tablet/html/js/controls/page/panels/pageSharePanel','syracuse-tablet/html/js/controls/page/panels/pageTemplatePanel','syracuse-tablet/html/js/controls/page/panels/userPanelSmartphone','syracuse-tablet/html/js/controls/ctrlTypeUnknown','syracuse-tablet/html/js/controls/ctrlUnfound','syracuse-tablet/html/js/controls/field/ctrlImage','syracuse-tablet/html/js/controls/field/ctrlDocument','syracuse-tablet/html/js/controls/field/ctrlDocument','syracuse-tablet/html/js/controls/field/ctrlText','syracuse-tablet/html/js/controls/ctrlIcon','syracuse-tablet/html/js/controls/ctrlButton','syracuse-tablet/html/js/controls/field/ctrlGaugeChart','syracuse-tablet/html/js/controls/structElmt','syracuse-tablet/html/js/controls/array/ctrlRowStatus','syracuse-tablet/html/js/controls/array/ctrlRowIndex','syracuse-tablet/html/js/controls/page/ctrlChartDetailToolbar','syracuse-tablet/html/js/controls/ctrlFactory'],function (require, exports, module) {"use strict";

var Alphanum = require('syracuse-tablet/html/js/controls/field/ctrlAlphanum').Klass;
var PhoneField = require('syracuse-tablet/html/js/controls/field/ctrlAlphanum').PhoneField;
var Filter = require('syracuse-tablet/html/js/controls/field/ctrlFilter').Klass;
var EmailField = require('syracuse-tablet/html/js/controls/field/ctrlAlphanum').EmailField;
var UrlField = require('syracuse-tablet/html/js/controls/field/ctrlAlphanum').UrlField;
var ProgressField = require('syracuse-tablet/html/js/controls/field/ctrlProgress').Klass;
var Numeric = require('syracuse-tablet/html/js/controls/field/ctrlNumeric').Klass;
var Quantity = require('syracuse-tablet/html/js/controls/field/ctrlQuantity').Klass;
var CheckBox = require('syracuse-tablet/html/js/controls/field/ctrlCheckbox').Klass;
var Switch = require('syracuse-tablet/html/js/controls/field/ctrlSwitch').Klass;
var Combo = require('syracuse-tablet/html/js/controls/field/ctrlCombo').Klass;
var Date = require('syracuse-tablet/html/js/controls/field/ctrlDate').Klass;
var Array = require('syracuse-tablet/html/js/controls/array/ctrlArray').Klass;
var ArrayChart = require('syracuse-tablet/html/js/controls/array/ctrlArrayChart').Klass;
var Reference = require('syracuse-tablet/html/js/controls/field/ctrlReference').Klass;
var LayoutRow = require('syracuse-tablet/html/js/controls/layout/layoutRow').Klass;
var LayoutStack = require('syracuse-tablet/html/js/controls/layout/layoutStack').Klass;
var LayoutTab = require('syracuse-tablet/html/js/controls/layout/layoutTab').Klass;
var LayoutHub = require('syracuse-tablet/html/js/controls/layout/layoutHub').Klass;
var LayoutHubGroup = require('syracuse-tablet/html/js/controls/layout/layoutHubGroup').Klass;
var LayoutTile = require('syracuse-tablet/html/js/controls/layout/layoutTile').Klass;
var LayoutCell = require('syracuse-tablet/html/js/controls/layout/layoutCell').Klass;
var Vignette = require('syracuse-tablet/html/js/controls/vignetteBase').Klass;
var BreadCrumbs = require('syracuse-tablet/html/js/controls/page/ctrlBreadCrumbs').Klass;
var PageHeader = require('syracuse-tablet/html/js/controls/page/ctrlPageHeader').Klass;
var PageFooter = require('syracuse-tablet/html/js/controls/page/ctrlPageFooter').Klass;
var VignetteFooter = require('syracuse-tablet/html/js/controls/page/ctrlVignetteFooter').Klass;
var VignetteHeader = require('syracuse-tablet/html/js/controls/page/ctrlVignetteHeader').Klass;
var PageActionPanelRegular = require('syracuse-tablet/html/js/controls/page/panels/pageActionPanelRegular').Klass;;
var FilterSortPanel = require('syracuse-tablet/html/js/controls/page/panels/sortfilter/filterSortPanel').Klass;
var PageSharePanel = require('syracuse-tablet/html/js/controls/page/panels/pageSharePanel').Klass;
var PageTemplatePanel = require('syracuse-tablet/html/js/controls/page/panels/pageTemplatePanel').Klass;
var UserPanelSmartphone = require('syracuse-tablet/html/js/controls/page/panels/userPanelSmartphone').Klass;
var TypeUnknown = require('syracuse-tablet/html/js/controls/ctrlTypeUnknown').Klass;
var FieldUnfound = require('syracuse-tablet/html/js/controls/ctrlUnfound').Klass;
var Image = require('syracuse-tablet/html/js/controls/field/ctrlImage').Klass;
var Document = require('syracuse-tablet/html/js/controls/field/ctrlDocument').Klass;
var Binary = require('syracuse-tablet/html/js/controls/field/ctrlDocument').Binary;
var EnrichedText = require('syracuse-tablet/html/js/controls/field/ctrlText').Klass;
var Icon = require('syracuse-tablet/html/js/controls/ctrlIcon').Klass;
var Button = require('syracuse-tablet/html/js/controls/ctrlButton').Klass;
var Gauge = require('syracuse-tablet/html/js/controls/field/ctrlGaugeChart').Klass;
var StructElmt = require('syracuse-tablet/html/js/controls/structElmt').Klass;
var FieldRowStatus = require('syracuse-tablet/html/js/controls/array/ctrlRowStatus').Klass;
var FieldRowIndex = require('syracuse-tablet/html/js/controls/array/ctrlRowIndex').Klass;
var ChartDetailToolbar = require('syracuse-tablet/html/js/controls/page/ctrlChartDetailToolbar').Klass;
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');

exports.init = function() {
	ctrlFactory.setImpl("Alphanum", Alphanum);
	ctrlFactory.setImpl("PhoneField", PhoneField);
	ctrlFactory.setImpl("Filter", Filter);
	ctrlFactory.setImpl("EmailField", EmailField);
	ctrlFactory.setImpl("UrlField", UrlField);
	ctrlFactory.setImpl("ProgressField", EmailField);
	ctrlFactory.setImpl("Numeric", Numeric);
	ctrlFactory.setImpl("Quantity", Quantity);
	ctrlFactory.setImpl("CheckBox", CheckBox);
	ctrlFactory.setImpl("Switch", Switch);
	ctrlFactory.setImpl("Combo", Combo);
	ctrlFactory.setImpl("Date", Date);
	ctrlFactory.setImpl("Array", Array);
	ctrlFactory.setImpl("Reference", Reference);
	ctrlFactory.setImpl("LayoutRow", LayoutRow);
	ctrlFactory.setImpl("LayoutStack", LayoutStack);
	ctrlFactory.setImpl("LayoutTab", LayoutTab);
	ctrlFactory.setImpl("LayoutHub", LayoutHub);
	ctrlFactory.setImpl("LayoutHubGroup", LayoutHubGroup);
	ctrlFactory.setImpl("LayoutTile", LayoutTile);
	ctrlFactory.setImpl("LayoutCell", LayoutCell);
	ctrlFactory.setImpl("Vignette", Vignette);
	ctrlFactory.setImpl("BreadCrumbs", BreadCrumbs);
	ctrlFactory.setImpl("PageHeader", PageHeader);
	ctrlFactory.setImpl("PageFooter", PageFooter);
	ctrlFactory.setImpl("VignetteFooter", VignetteFooter);
	ctrlFactory.setImpl("VignetteHeader", VignetteHeader);
	ctrlFactory.setImpl("PageActionPanelRegular", PageActionPanelRegular);
	ctrlFactory.setImpl("UserPanelSmartphone", UserPanelSmartphone);
	ctrlFactory.setImpl("FilterSortPanel", FilterSortPanel);
	ctrlFactory.setImpl("PageSharePanel", PageSharePanel);
	ctrlFactory.setImpl("PageTemplatePanel", PageTemplatePanel);
	ctrlFactory.setImpl("TypeUnknown", TypeUnknown);
	ctrlFactory.setImpl("FieldUnfound", FieldUnfound);
	ctrlFactory.setImpl("ArrayChart", ArrayChart);
	ctrlFactory.setImpl("Binary", Binary);
	ctrlFactory.setImpl("Image", Image);
	ctrlFactory.setImpl("Document", Document);
	ctrlFactory.setImpl("Text", EnrichedText);
	ctrlFactory.setImpl("Icon", Icon);
	ctrlFactory.setImpl("Gauge", Gauge);
	ctrlFactory.setImpl("Button", Button);
	ctrlFactory.setImpl("StructElmt", StructElmt);
	ctrlFactory.setImpl("FieldRowStatus", FieldRowStatus);
	ctrlFactory.setImpl("FieldRowIndex", FieldRowIndex);
	ctrlFactory.setImpl("ChartDetailToolbar", ChartDetailToolbar);
};
});

define('syracuse-tablet/html/js/sdata/sdataSort',['require','exports','module'],function (require, exports, module) {"use strict";

/*
 *
 */

function _sdataSortArray(data, proto, orderBy) {

	var comparators = [];
	var properties = (proto.$properties.$resources && proto.$properties.$resources.$item && proto.$properties.$resources.$item.$properties) || proto.$properties;

	orderBy.forEach(function(exp) {
		var prop = exp.property;
		var sort = ((exp.sort === "DESC" || exp.sort === "desc") ? "DESC" : "ASC");
		var type = (properties[prop] && properties[prop].$type) || "application/x-string";

		if (type === "application/x-decimal") {
			if (sort === "ASC") {
				try {
					comparators.push(function(a, b) {
						var vala = a[prop];
						var valb = b[prop];
						return (+vala) - (+valb);
					});
				} catch (e) {}
				return 0;
			} else {
				try {
					comparators.push(function(a, b) {
						var vala = a[prop];
						var valb = b[prop];
						return (+valb) - (+vala);
					});
				} catch (e) {}
				return 0;
			}
		} else {
			if (sort === "ASC") {
				comparators.push(function(a, b) {
					try {
						var vala = a[prop];
						var valb = b[prop];
						if (vala > valb) {
							return 1;
						} else if (vala < valb) {
							return -1;
						}
					} catch (e) {}
					return 0;
				});
			} else {
				comparators.push(function(a, b) {
					try {
						var vala = a[prop];
						var valb = b[prop];
						if (vala > valb) {
							return -1;
						} else if (vala < valb) {
							return 1;
						}
					} catch (e) {}
					return 0;
				});
			}
		}
	});

	data.sort(function(a, b) {
		var c = 0;
		for (var i = 0; i < comparators.length; i++) {
			c = comparators[i](a, b);
			if (c !== 0) {
				break;
			}
		}
		return c;
	});
}
exports.sdataSortArray = _sdataSortArray;
});

define('syracuse-tablet/html/js/sdata/sdataCache',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/storage/storage','syracuse-tablet/html/js/sdata/sdatawhere/parser','syracuse-tablet/html/js/sdata/sdatawhere/whereUtils','syracuse-tablet/html/js/sdata/sdataSort','syracuse-tablet/html/js/storage/localStorage'],function (require, exports, module) {"use strict";

/*
 *
 */

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("SDataCache");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var storageModule = require('syracuse-tablet/html/js/storage/storage');
var parser = require('syracuse-tablet/html/js/sdata/sdatawhere/parser').Parser;
var whereUtils = require('syracuse-tablet/html/js/sdata/sdatawhere/whereUtils');
var sdataSort = require('syracuse-tablet/html/js/sdata/sdataSort');
var localStorage = require('syracuse-tablet/html/js/storage/localStorage');

// all storage entries created by the case will be prefixed with this to be able to empty the cache w/o removing settings
var _cachePrefix = "$cache_";
var _keyRegExp = /\{(.*?)\}/g;

function _SDataCache(storage) {
	this.storage = storage;
	this.context = null;
};

/*
 *
 */
var _SDataCacheClass = utils.defineClass(
	_SDataCache,
	null, {
		setContext: function(context) {
			log && log("Changing cache context: " + JSON.stringify(context));
			this.context = context;
		},

		cachePrefix: _cachePrefix,

		/**
		 * Put an instance of an sdata object into the cache
		 *
		 * Parameters:
		 * data
		 * {
		 *   $data: {} - Data to store in cache (mandatory)
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 *   $key: "mawal" - Key of data
		 * }
		 * Note that $proto OR $representation AND $key must be set
		 *
		 * Return:
		 * Resolve:
		 * null
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		put: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				if (!data.$data) {
					throw new Error("PUT: No data specified");
				}
				var repr;
				var key;
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
					key = self._getKeyValue(data.$data, $proto);
				} else if (data.$representation && data.$key) {
					repr = data.$representation;
					key = data.$key;
				} else {
					throw new Error("PUT: Neither proto nor representation and key specified");
				}
				self.storage.put({
					$context: self.context,
					$collection: _cachePrefix + repr,
					$endpoint: data.$endpoint,
					$key: key,
					$data: {
						$item: data.$data
					}
				}).then(function(result) {
					deferred.resolve();
				}).fail(function(error) {
					deferred.reject(error);
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 * Query an array of instances from cache
		 *
		 * Parameters:
		 * data
		 * {
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 *   $where: "user eq 'admin' - Optional where clause
		 *   $orderBy: [{ "property": "user", "sort" : "ASC"}, { "property": "login", "sort" : "desc"}] - Optional array of sort conditions
		 * }
		 * Note that $proto OR $representation must be set
		 *
		 * Return:
		 * Resolve:
		 * Matched instances of queried representation
		 * [
		 *   {},
		 *   {}
		 * ]
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		query: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var repr;
				log && log("Query by: " + JSON.stringify(data));
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
				} else if (data.$representation) {
					if (data.$where) {
						throw new Error("QUERY: Where clause parsing requires prototype");
					}
					if (data.$orderBy) {
						throw new Error("QUERY: Order by requires prototype");
					}
					repr = data.$representation;
				} else {
					throw new Error("QUERY: Neither proto nor representation specified");
				}
				self.storage.query({
					$context: self.context,
					$endpoint: data.$endpoint,
					$collection: _cachePrefix + repr
				}).then(function(result) {
					var res = [];
					if (data.$where) {
						var exp = parser.parse(data.$where);
						result.$data.forEach(function(item, i) {
							if (whereUtils.execWhere(item.$item, exp, $proto)) {
								var d = item.$item;
								var m = result.$metaData[i];
								d.$cache = {
									$lastRead: m.$lastRead,
									$lastUpdated: m.$lastUpdated
								};
								res.push(d);
							}
						});
					} else {
						result.$data.forEach(function(item, i) {
							var d = item.$item;
							var m = result.$metaData[i];
							d.$cache = {
								$lastRead: m.$lastRead,
								$lastUpdated: m.$lastUpdated
							};
							res.push(d);
						});
					}
					if (data.$orderBy) {
						sdataSort.sdataSortArray(res, $proto, data.$orderBy);
					}
					// Exception are handled by ou jq deferred hack
					deferred.resolve(res);
				}).fail(function(error) {
					deferred.reject(error);
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 * Read one instance from cache using given key
		 *
		 * Parameters:
		 * data
		 * {
		 *   $key: "abc~def" - Key of object to read
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 * }
		 * Note that $proto OR $representation must be set
		 *
		 * Return:
		 * Resolve:
		 * Instance for given key or null if no match
		 * { ... }
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		read: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var repr;
				if (!data.$key) {
					throw new Error("READ: No key specified");
				}
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
				} else if (data.$representation) {
					repr = data.$representation;
				} else {
					throw new Error("READ: Neither proto nor representation specified");
				}
				self.storage.read({
					$context: self.context,
					$collection: _cachePrefix + repr,
					$endpoint: data.$endpoint,
					$key: data.$key
				}).then(function(result) {
					if (result.$status === storageModule.StatusCodes.OK) {
						var res = result.$data.$item;
						res.$cache = {
							$lastRead: result.$metaData.$lastRead,
							$lastUpdated: result.$metaData.$lastUpdated
						};
						deferred.resolve(res);
					} else {
						deferred.resolve(null);
					}
				}).fail(function(error) {
					deferred.reject(error);
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 * Delete instance from cache by given key
		 *
		 * Parameters:
		 * data
		 * {
		 *   $key: "abc~def" - Key of object to read
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 * }
		 * Note that $proto OR $representation must be set
		 *
		 * Return:
		 * Resolve:
		 * null
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		remove: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var repr;
				if (!data.$key) {
					throw new Error("REMOVE: No key specified");
				}
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
				} else if (data.$representation) {
					repr = data.$representation;
				} else {
					throw new Error("READ: Neither proto nor representation specified");
				}
				self.storage.remove({
					$context: self.context,
					$collection: _cachePrefix + repr,
					$endpoint: data.$endpoint,
					$key: data.$key
				}).then(function() {
					deferred.resolve();
				}).fail(function(error) {
					deferred.reject(error);
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 *
		 * options: {
		 * $not_read_since: "2015-01-20 11-22-33"
		 * }
		 */
		clearCache: function(options) {
			var deferred = $.Deferred();
			var self = this;
			var re = new RegExp(self.cachePrefix.replace(/([\$\_]+)/g, "\\$1"));
			var opts = {
				$context: self.context,
				$collection: re
			};
			if (options && options.$not_read_since) {
				opts.$not_read_since = options.$not_read_since;
			}
			try {
				self.storage.clearCollection(opts)
					.then(function() {
						deferred.resolve();
					}).fail(function(error) {
						deferred.reject(error);
					});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 *
		 * options: {
		 * $not_read_since: "2015-01-20 11-22-33"
		 * }
		 */
		computeCacheSize: function(options) {
			var deferred = $.Deferred();
			var self = this;
			var re = new RegExp(self.cachePrefix.replace(/([\$\_]+)/g, "\\$1"));
			var opts = {
				$context: self.context,
				$collection: re
			};
			if (options && options.$not_read_since) {
				opts.$not_read_since = options.$not_read_since;
			}
			try {
				self.storage.computeCollectionSize(opts)
					.then(function(result) {
						deferred.resolve(result);
					}).fail(function(error) {
						deferred.reject(error);
					});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		_getProto: function(proto) {
			var itemProto = (proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
			// item type of query and lookup is e.g. $queryItem
			// We want to use the base $type here ($query or $lookup)
			itemProto.$type = proto.$type;
			return itemProto;
		},
		_getRepresentation: function(proto) {
			return proto.$type.split(".").slice(1, 3).join(".").replace("$queryItem", "$query");
		},
		_getKeyValue: function(data, proto) {
			return proto.$key.replace(_keyRegExp, function(m, p) {
				return data[p];
			});
		},

		disableCache: function(isDisabled) {
			if (globals.isDvlpMode()) {
				localStorage.setItem("s.m.cache.disabled", isDisabled);
			}
			this._isDisabled = isDisabled;
		},
		isDisabled: function() {
			if (this._isDisabled == null) {
				if (globals.isDvlpMode()) {
					this._isDisabled = localStorage.getItem("s.m.cache.disabled");
					this._isDisabled = this._isDisabled === true || this._isDisabled === "true";
				} else {
					this._isDisabled = false;
				}
			}
			return this._isDisabled;
		}
	}
);

exports.SDataCache = _SDataCacheClass;
});

define('syracuse-tablet/html/js/helpers/siteLayout',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {"use strict";

// var serverLog = require('syracuse-tablet/html/js/helpers/serverLog');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

/*
 *
 * This module is responsibe to layout main layout components in the browser window:
 *
 * HEADER    | AUTHORING
 * CONTENT   | PANEL
 * FOOTER    |
 *
 */


/*
 * Bootstrap min sizes per level
 * =============================
 *
 * xs:                  480px;
 * sm:                  768px;
 * md:                  992px;
 * lg:                  1200px;
 *
 */

/*
 * Some devices
 * ============
 *
 * iPad: 1024×768
 * Nexus 7: 1920 × 1200
 * Nexus 10: 2560x1600
 *
 */

/*
 * Needs to be aligned with bootstrap responsiveness!
 * Not, pixel sized defined here match values of media queries or top / left / width /height css attributes.
 * But these are not physical pixels because some devices have a pixel ration physical > logical
 *
 * See: http://bjango.com/articles/min-device-pixel-ratio/
 * We need to work with logical pixel units
 *
 * E.g. Nexus 10 has a 2560x1600 display but reports 1280x800 because ratio is 2.0
 * E.g. Nexus 5 has a 1080x1920 display but reports 360x1080 because ratio is 3.0
 *
 */
//Parameters that are actually used (calculated and maybe changed based on _layoutParameters)
var _internalParameters;
var _lastWindowWidth;
var _lastWindowHeight;
$(function() {
	_lastWindowWidth = $(window).width();
	_lastWindowHeight = $(window).height();
});

/*
 * To detect orientation change in browser window compared to last call of this function
 */
function _getWindowOrientation() {
	var width = $(window).width();
	var height = $(window).height();
	var ratio = width / height;
	if (ratio < 1) {
		return "portrait";
	} else {
		return "landscape";
	}
}

var _getCurrentDeviceType = function() {
	var currentDeviceType;
	var a = navigator.userAgent.toLowerCase();

	if (a.indexOf("iphone") >= 0) {
		currentDeviceType = "smartphone";
	} else if (a.indexOf("ipad") >= 0) {
		currentDeviceType = "tablet";
	} else {
		if (a.indexOf("mobile") >= 0) { // android smartphones report "mobile" while tablets do not
			currentDeviceType = "smartphone";
		} else {
			currentDeviceType = "tablet";
		}
	}
	return currentDeviceType;
};

/*
 *
 * NOTE: IF you change s-m-auth-col-simulate* classes assigned to a device here, you need to also check
 * the CSS media selectors in thirdparty_custom.less
 *
 */
var _deviceSizes = {
	nexus5: {
		width: 640, // Nexus 5
		height: 360,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-xs",
			landscape: "s-m-auth-col-simulate-sm"
		},
		deviceType: "smartphone",
		orientations: ["portrait", "landscape"]
	},
	nexus7: { // Nexus 7
		width: 960,
		height: 600,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-sm",
			landscape: "s-m-auth-col-simulate-md"
		},
		deviceType: "tablet",
		orientations: ["portrait", "landscape"]
	},
	nexus10: { // Nexus 10
		width: 1280,
		height: 800,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-sm",
			landscape: "s-m-auth-col-simulate-lg"
		},
		deviceType: "tablet",
		orientations: ["portrait", "landscape"]
	},
	ipad: {
		width: 1024,
		height: 768,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-sm",
			landscape: "s-m-auth-col-simulate-lg"
		},
		deviceType: "tablet",
		orientations: ["portrait", "landscape"]
	},
	iphone4: {
		width: 480,
		height: 320,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-xs",
			landscape: "s-m-auth-col-simulate-xs"
		},
		deviceType: "smartphone",
		orientations: ["portrait", "landscape"]
	},
	iphone5: {
		width: 568,
		height: 320,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-xs",
			landscape: "s-m-auth-col-simulate-xs"
		},
		deviceType: "smartphone",
		orientations: ["portrait", "landscape"]
	},
	iphone6: {
		width: 667,
		height: 375,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-xs",
			landscape: "s-m-auth-col-simulate-sm"
		},
		deviceType: "smartphone",
		orientations: ["portrait", "landscape"]
	},
	iphone6plus: {
		width: 960,
		height: 540,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-xs",
			landscape: "s-m-auth-col-simulate-md"
		},
		deviceType: "smartphone",
		orientations: ["portrait", "landscape"]
	}
};

/*
 * Classes that can be put on a container to override the css media selector that use device screen sizes
 */
var _bootstrapTweakClasses = ["s-m-auth-col-simulate-xs", "s-m-auth-col-simulate-sm", "s-m-auth-col-simulate-md", "s-m-auth-col-simulate-lg"];


var _currentOrientation = _getWindowOrientation();
var _splitterWidth = 15;
// Parameters that are currently applied
var _layoutParameters = {
	authPanelRight: {
		width: 230,
		splitterWidth: _splitterWidth,
		visible: false
	},
	authPanelLeft: {
		width: 300,
		splitterWidth: _splitterWidth,
		visible: false
	},
	authPanelHeader: {
		height: 34,
	},
	authPanelFooter: {
		height: 34,
	},
	pageParameters: {
		forcePreview: false,
		forceAutoScale: true,
		scale: 1
	},
};
// Better initilization for pageParameters
_layoutParameters.pageParameters.orientation = _currentOrientation;
_layoutParameters.pageParameters.deviceType = _getCurrentDeviceType();


/** Header/Footer height */
var _heights = {
	"tablet": {
		header: 50,
		footer: {
			opened: 50,
			closed: 20
		}
	},
	"smartphone": {
		header: 50,
		footer: {
			opened: 0,
			closed: 0
		}
	}
};
/*
 * Triggered by JqueryMobile helpers - Only on mobile device
 */
exports.onWindowOrientation = function(evt, opts) {
	if (!evt || evt.orientation == null) return;
	opts = opts || {};
	// serverLog.log("onWindowOrientation")
	opts.orientationChanged = evt.orientation !== _currentOrientation;
	opts.deviceChanged = false;
	_currentOrientation = evt.orientation;
	// 200 is important to avoid some refresh issues
	setTimeout(function() {
		_layoutMainContainers(evt, opts);
	});
};

/*
 * Triggered by browser window resize on the desktop
 *
 * This event is triggered also on mobile devices even if we can't change the size of the browser
 * (e.g. on orientation change or keyboard popup, fullscreen browser, non fullscreen browser)
 */
var _lastUserAgent = null;
exports.onWindowResize = function(evt, opts) {
	if (!evt) return;
	opts = opts || {};
	opts.orientationChanged = false;
	opts.deviceChanged = false;
	var userAgentChanged = _lastUserAgent == null || _lastUserAgent !== navigator.userAgent.toLowerCase();
	// serverLog.log("onWindowResize");
	if (_internalParameters && _internalParameters.pageParameters.forcePreview !== true) {
		// In preview mode orientation is given by the device
		// In !isDesktop mode orientation is handled by onWindowOrientation
		// We have to set orientation in desktop without preview mode
		if (globals.isDesktop()) {
			var prev = _currentOrientation;
			_currentOrientation = _getWindowOrientation();
			opts.orientationChanged = prev !== _currentOrientation;
		}
		// _lastUserAgent checked for mobile and desktop devices to allow CHrome Mobile Devices Simulator on desktop
		if (userAgentChanged) {
			_lastUserAgent = navigator.userAgent.toLowerCase();
			// In simulation assume that device changes with user agent
			opts.deviceChanged = true;
		}
	}
	if (userAgentChanged) {
		// In any cases 
		var wasMobile = globals.isMobile();
		globals.notifUserAgentChanged();
		if (wasMobile !== globals.isMobile()) {
			// Reload the page if we pass from desktop to mobile (occurs with chrome device simulator only)
			// We need to create new scroller native <--> desktop
			document.location.reload();
			return;
		}
	}
	// If we are on a desktop, just resize all the time, no need to make it more complicated than that.
	if (globals.isDesktop()) {
		_layoutMainContainers(evt, opts);
	}

	// We endup here, if we are on a mobile device

	// On a mobile device there are only a few options when a resize is actually triggered:
	// 1) Orientation has changed: Size change event because width and height have been swapped. 
	//    => We need to revalidate the layout (!)
	//
	// 2) Go to browser fullscreen: Revalidate layout (realign footer/header, scrollers)
	//    => We need to revalidate the layout (!)
	//
	// 3) Keyboard shows up: 
	//    => WE DO NOT WANT DO REVALIDATE THE LAYOUT SINCE WE WILL LOOSE FOCUS

	var width = $(window).width();
	var height = $(window).height();

	// Keyboard show up detection is done by ensuring the width of the screen has not changed during the resize

	// Special case height changes but width does not change:
	// If the width did not change during a resize BUT the height got bigger,
	// this is an indicator that the keyboard has disappeared.
	// If the keyboard disappeared its safe to to a re-validation of the layout
	// in fact, ITS NECESSARRY. Since a switch between portrait and landscape mode while
	// the keyboard is active triggers a re-validation of the layout using the smaller layout (minus the keyboard)
	// So once the keyboard disappears the revalidation ensures the footer is not in the middle of the screen

	if (width === _lastWindowWidth && height <= _lastWindowHeight) {
		notifications.publish("sm.scroller.update", true);
		return;
	}

	// One more special case
	// On android, the software keyboards height depends on the
	// type of input field.
	// So on focus change, there is a resize since the keyboard may shrink or grow
	// This is why we take into account the new height only if:
	// Width changed also (orientation change)
	// Height gets bigger (keyboard disappears)
	if (width !== _lastWindowWidth || height > _lastWindowHeight) {
		// Wrapped by "if" to ensure we remember only the maximum height of the current orientation
		_lastWindowHeight = height;
	}

	_lastWindowWidth = width;
	_layoutMainContainers(evt, opts);
};

/*
 * Triggered by application JS code - triggerResizeInternal handler
 */
exports.onWindowResizeInteral = function(evt, opts) {
	if (!evt) return;
	opts = opts || {};
	var params = opts.layout ? opts.layout.pageParameters : null;
	if (params && params.orientation && params.forcePreview) {
		opts.orientationChanged = _currentOrientation !== params.orientation;
		_currentOrientation = params.orientation;
	}
	if (params && params.device && params.forcePreview) {
		var typ = _deviceSizes[params.device];
		typ = typ ? typ.deviceType : "";
		opts.deviceChanged = typ !== _getDeviceType();
	}
	_layoutMainContainers(evt, opts);
};
/*
 * Layout main containers like header, content, footer, authoring panel
 */
function _layoutMainContainers(resizeEvt, opts) {
	var firstCall = _lastUserAgent == null;
	if (_lastUserAgent == null) {
		// Optimization for device simulator - prevent a deviceChanged at the first orientation changed
		_lastUserAgent = navigator.userAgent.toLowerCase();
	}
	opts = opts || {};
	opts.resizeEvent = resizeEvt;
	if (opts.layout) {
		_layoutParameters = $.extend(true, {}, _layoutParameters, opts.layout);
	}
	var width = $(window).width();
	var height = $(window).height();
	var appClass = null;

	var authPanelRightWidth = 0;
	var authPanelLeftWidth = 0;
	var authPanelHeaderHeight = 0;
	var authPanelFooterHeight = 0;
	var authPanelRightSplitterWidth = 0;
	var authPanelLeftSplitterWidth = 0;

	var $$authRight = $("#s-m-auth-panel-right-id");
	var $$authLeft = $("#s-m-auth-panel-left-id");
	var $$app = $("#s-m-app-id");
	var $$appContainer = $("#s-m-app-container-id");

	_internalParameters = $.extend(true, {}, _layoutParameters);
	var pageParams = _internalParameters.pageParameters;
	if (_internalParameters.authPanelRight.visible) {
		authPanelRightWidth = _internalParameters.authPanelRight.width;
		authPanelRightSplitterWidth = _internalParameters.authPanelRight.splitterWidth;

		_layoutAuthPanelRight(width, height);
		pageParams.forcePreview = true;
	}
	if (_internalParameters.authPanelLeft.visible) {
		authPanelLeftWidth = _internalParameters.authPanelLeft.width;
		authPanelLeftSplitterWidth = _internalParameters.authPanelLeft.splitterWidth;

		_layoutAuthPanelLeft(width, height);
		pageParams.forcePreview = true;
	}
	if (_internalParameters.authPanelHeader.visible) {
		authPanelHeaderHeight = _internalParameters.authPanelHeader.height;
		_layoutAuthPanelHeader(width, height);
	}
	if (_internalParameters.authPanelFooter.visible) {
		authPanelFooterHeight = _internalParameters.authPanelFooter.height;
		_layoutAuthPanelFooter(width, height);
	}
	var applicationWidth = width - authPanelRightWidth - authPanelRightSplitterWidth - authPanelLeftWidth - authPanelLeftSplitterWidth;
	var applicationHeight = height - authPanelHeaderHeight - authPanelFooterHeight;

	var appView;
	var forcePreview = pageParams.forcePreview === true;
	// Remove wrapper if exists
	if ($$app.parent().is(".s-m-device-wrapper")) {
		$$app.unwrap();
	}
	// if forcePreview adds a wrapper to simulate the tablet/iphone body
	if (forcePreview && globals.isDesktop()) {
		var template = pageParams.device ? _deviceSizes[pageParams.device] : null;
		if (!template) {
			template = _deviceSizes["nexus10"];
		}
		// Border for application wrapper
		var wrapBorder = 15;
		// Unscaled application view rectangle
		appView = {
			left: 0,
			top: 0,
			width: pageParams.orientation === "landscape" ? template.width : template.height,
			height: pageParams.orientation === "landscape" ? template.height : template.width,
		};
		// Wrapper W/H
		var wrapH = appView.height + 2 * wrapBorder,
			wrapW = appView.width + 2 * wrapBorder;
		// Auto scale
		if (pageParams.forceAutoScale) {
			pageParams.scale = Math.min(Math.min(applicationWidth / wrapW, applicationHeight / wrapH), 1);
		}
		//Center
		appView.left = Math.max((applicationWidth - wrapW * pageParams.scale) / 2, 0);
		appView.top = Math.max((applicationHeight - wrapH * pageParams.scale) / 2, 0);
		// Class that indicates device simulation status
		appClass = template.bootstrapTweakClass[pageParams.orientation];
		// Wrapp the application into device container to better display the devise structure with round corners...
		var $$wrapper = $('<section class="s-m-device-wrapper"></section>"');
		var wrapCss = {
			top: appView.top + "px",
			left: appView.left + "px",
			width: wrapW + "px",
			height: wrapH + "px"
		};
		if (pageParams.scale !== 1) {
			wrapCss["transform"] = "scale(" + pageParams.scale + ", " + pageParams.scale + ")",
			wrapCss["transform-origin"] = "left top";
		}
		$$wrapper.css(wrapCss);
		$$app.wrap($$wrapper);
		// Container including header, content, footer
		$$app.css({
			top: wrapBorder + "px",
			left: wrapBorder + "px",
			width: appView.width + "px",
			height: appView.height + "px",
			position: "absolute"
		});
	} else {
		// No preview - application is displayed full page
		appView = {
			left: 0,
			top: 0,
			width: applicationWidth,
			height: applicationHeight
		};
		pageParams.orientation = _currentOrientation;
		// Container including header, content, footer
		$$app.css({
			top: appView.top,
			left: appView.left,
			width: appView.width,
			height: appView.height
		});
	}
	// keeps only the right class
	$$app.removeClass(_bootstrapTweakClasses.join(' '));
	if (appClass) {
		$$app.addClass(appClass);
	}
	// Container including header, content, footer
	$$appContainer.css({
		top: authPanelHeaderHeight,
		left: authPanelLeftWidth + authPanelLeftSplitterWidth,
		width: applicationWidth,
		height: applicationHeight
	});
	// Status to manage css
	$$appContainer.toggleClass("s-m-preview", forcePreview);
	// Allow other components like authoring panel or page content to be resized
	var info = {
		// updateLayout = true - no deend to relaod data - needed for arrays or other controls that are build onResize (calculate width/height)
		updateLayout: true,
		application: appView,
		// True if resize triggered by authoring
		authoringUpdate: opts.authoringUpdate === true,
		// Action want to preserve the scrolling of the page
		preserveScroll: opts.preserveScroll === true || opts.authoringUpdate === true,
		afterMainPageLoaded: opts.afterMainPageLoaded === true
	};
	if (opts.resizeEvent) {
		/**
		 * Propagated to onResize method to be able to identify resizeEvent.type - 'resize' or 'resizeInternal'
		 **/
		info.resizeEvent = opts.resizeEvent;
	}
	info.orientationChanged = opts.orientationChanged;
	info.deviceChanged = opts.deviceChanged;
	if (globals.isAutoUITestMode() && (firstCall || info.orientationChanged || info.deviceChanged)) {
		globals.getUnitTestMgr().notifDeviceChanged(_getDeviceType(), pageParams.orientation);
	}
	notifications.publish("sm.main.layout.changed", info, pageParams.orientation, _getDeviceType());
}

function _layoutAuthPanelRight(width, height) {
	var $$auth = $("#s-m-auth-panel-right-id");
	var $$splitter = $("#s-m-auth-splitter-right-id");

	var authPanelHeaderHeight = 0;
	var authPanelFooterHeight = 0;
	if (_internalParameters.authPanelHeader.visible) {
		authPanelHeaderHeight = _internalParameters.authPanelHeader.height;
	}
	if (_internalParameters.authPanelFooter.visible) {
		authPanelFooterHeight = _internalParameters.authPanelFooter.height;
	}

	$$auth.css({
		left: width - _internalParameters.authPanelRight.width,
		top: authPanelHeaderHeight,
		width: _internalParameters.authPanelRight.width,
		height: height - authPanelHeaderHeight - authPanelFooterHeight
	});
	$$splitter.css({
		left: width - _internalParameters.authPanelRight.width - _internalParameters.authPanelRight.splitterWidth,
		top: authPanelHeaderHeight,
		width: _internalParameters.authPanelRight.splitterWidth,
		height: height - authPanelHeaderHeight - authPanelFooterHeight
	});
}

function _layoutAuthPanelLeft(width, height) {
	var $$auth = $("#s-m-auth-panel-left-id");
	var $$splitter = $("#s-m-auth-splitter-left-id");

	var authPanelHeaderHeight = 0;
	var authPanelFooterHeight = 0;
	if (_internalParameters.authPanelHeader.visible) {
		authPanelHeaderHeight = _internalParameters.authPanelHeader.height;
	}
	if (_internalParameters.authPanelFooter.visible) {
		authPanelFooterHeight = _internalParameters.authPanelFooter.height;
	}

	$$auth.css({
		left: 0,
		top: authPanelHeaderHeight,
		width: _internalParameters.authPanelLeft.width,
		height: height - authPanelHeaderHeight - authPanelFooterHeight
	});
	$$splitter.css({
		left: _internalParameters.authPanelLeft.width,
		top: authPanelHeaderHeight,
		width: _internalParameters.authPanelLeft.splitterWidth,
		height: height - authPanelHeaderHeight - authPanelFooterHeight
	});
}

function _layoutAuthPanelHeader(width, height) {
	var $$auth = $("#s-m-auth-panel-header-id");
	$$auth.css({
		left: 0,
		top: 0,
		width: width,
		height: _internalParameters.authPanelHeader.height,
		overflow: "hidden"
	});
}

function _layoutAuthPanelFooter(width, height) {
	var $$auth = $("#s-m-auth-panel-footer-id");
	$$auth.css({
		left: 0,
		top: height - _internalParameters.authPanelFooter.height,
		width: width,
		height: _internalParameters.authPanelFooter.height
	});
}

exports.getDeviceTemplates = function() {
	return _deviceSizes;
};
/**
 * return smartphone/tablet
 */
var _getDeviceType = function() {
	// Preview mode?
	if (_internalParameters && _internalParameters.pageParameters && _internalParameters.pageParameters.forcePreview === true) {
		var device = _internalParameters.pageParameters.device;
		return device && _deviceSizes[device] ? _deviceSizes[device].deviceType : "tablet";
	}
	// Check if auto device recognition is overridden by user settings
	var settings = globals.getGlobalSettings();
	if (settings == null || settings["device-type"] === "auto") {
		return _getCurrentDeviceType();
	}
	return settings["device-type"];
};
/* 
 * only tablet or smartphone
 * Use this to detect if it's a "smartphone" or a "tablet"
 * This function will return the physical device or the simulated one of dev mode or authoring is active.
 */
exports.getDeviceType = _getDeviceType;

exports.getPageOrientation = function() {
	return _internalParameters.pageParameters.orientation;
};

exports.getCurrentLayoutSettings = function() {
	var o = $.extend(true, {}, _layoutParameters);
	return o;
};
exports.getTransformScale = function() {
	var res = _internalParameters && _internalParameters.pageParameters ? _internalParameters.pageParameters.scale : null;
	return res == null || res <= 0 ? 1 : res;
};

exports.splitterWidth = _splitterWidth;
exports.onWindoReisze = _splitterWidth;
});

define('syracuse-tablet/html/js/application/metaDataCache',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/storage/storage','syracuse-tablet/html/js/sdata/sdataCommonResources','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ajax/ajax'],function (require, exports, module) {"use strict";

/*
 * This module handles level 2 meta data access and persistance of meta data on client side
 * See metaData.js for details
 */

var globals = require('syracuse-tablet/html/js/helpers/globals');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("metaData");
var storageModule = require('syracuse-tablet/html/js/storage/storage');
var sdataCommonRes = require('syracuse-tablet/html/js/sdata/sdataCommonResources');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var ajax = require('syracuse-tablet/html/js/ajax/ajax').getAjax().ajax;

function _startWait() {
	var app = globals.getApplication();
	if (app) {
		app.waitWheelStart();
	}
}

function _stopWait() {
	var app = globals.getApplication();
	if (app) {
		app.waitWheelStop();
	}
}

/*
 * Gets all application stored on the client or
 * asks the server in case there is nothing stored on the client
 *
 * Note: This reads ALL applications known, not only the ones matching the role and endpoint
 */
exports.getKnownApplications = function(context, forceReadFromServer) {
	var storage = globals.getStorage();

	var ctx = {
		"$user": "none",
		"$role": "none",
		"$lang": context.lang
	};

	var readCache;
	var cache = globals.getCache();
	if (cache.isDisabled()) { // Disabled by dev features?
		readCache = $.smResolve({
			$status: storageModule.StatusCodes.NOT_FOUND
		});
	} else {
		readCache = storage.read({
			$context: ctx,
			$collection: "$metacache_$meta_apps",
			$endpoint: "$local",
			$key: "$applications"
		});
	}
	var def = $.Deferred();
	readCache.then(function(result) {
		// If we do not request an update from the server and data is there, we are done
		if (!forceReadFromServer && result.$status === storageModule.StatusCodes.OK) {
			var apps = result.$data;
			log && log("Application list from cache");
			def.resolve(apps);
			return;
		}
		log && log("Fetching remote application list");
		sdataCommonRes.queryAllApplications()
			.then(function(apps) {
				return _storeKnownApplications(apps, ctx)
					.then(function() {
						def.resolve(apps);
					});
			})
			.fail(function(e) {
				// If we fail because of a connection issue, we will
				// fall back to the cache
				if (e && e.$noConnectionError === true && result && result.$data) {
					def.resolve(result.$data);
				}
				def.reject(e);
			});
	});
	return def.promise();
};

/*
 * Store list of apps locally
 */
function _storeKnownApplications(apps, ctx) {
	var storage = globals.getStorage();
	return storage.put({
		$context: ctx,
		$collection: "$metacache_$meta_apps",
		$endpoint: "$local",
		$key: "$applications",
		$data: apps
	}).then(function(result) {
		return apps;
	});
}

/*
 * Cached in the context of user, role and language
 * Return application detail for a given JSON description
 */
exports.getApplication = function(header, context, localOnly, forceUpdate) {
	var storage = globals.getStorage();
	var ctx = {
		"$user": context.user,
		"$role": context.role,
		"$lang": context.lang
	};

	var readCache;
	if (forceUpdate === true) {
		readCache = $.smResolve({
			$status: storageModule.StatusCodes.NOT_FOUND
		});
	} else {
		readCache = storage.read({
			$context: ctx,
			$collection: "$metacache_$meta_app",
			$endpoint: context.endpoint,
			$key: "$application_" + header.applicationName
		});
	}
	return readCache
		.then(function(result) {
			if (result.$status === storageModule.StatusCodes.OK) {
				log && log("Application details from cache");
				return result.$data;
			} else {
				if (localOnly === true) { // App not cached yet!
					return null;
				}
				log && log("Fetching remote application details");
				_startWait();
				return sdataCommonRes.queryApplicationDetail(header, context.endpoint)
					.then(function(app) {
						return _storeApplicationDetail(app, ctx, context.endpoint).then(function() {
							return app;
						});
					})
					.then(function(app) {
						_stopWait();
						return app;
					})
					.fail(function(e) {
						_stopWait();
						return $.smReject(e);
					});
			}
		});
};

/*
 * Remove all application details from local storage so they are update by querying the server
 *
 */
exports.removeApplications = function(context) {
	var storage = globals.getStorage();
	var ctx = {
		"$user": context.user,
		"$role": context.role,
		"$lang": context.lang
	};
	return storage.query({
		$context: ctx,
		$collection: "$metacache_$meta_app",
		$endpoint: context.endpoint
	})
		.then(function(result) {
			if (result.$status === storageModule.StatusCodes.OK) {
				return $.smForEachPromise(result.$data, function(app) {
					var key = "$application_" + app.$application.applicationName;
					return storage.remove({
						$context: ctx,
						$collection: "$metacache_$meta_app",
						$endpoint: context.endpoint,
						$key: key
					})
						.always(function() {
							return $.smResolve();
						});
				});
			}
		});
};

/*
 * Store details of single app locally
 */
function _storeApplicationDetail(app, ctx, ep) {
	var storage = globals.getStorage();
	return storage.put({
		$context: ctx,
		$collection: "$metacache_$meta_app",
		$endpoint: ep,
		$key: "$application_" + app.$application.applicationName,
		$data: app
	});
}

exports.updateApplicationDetail = function(app, ctx, ep) {
	return _storeApplicationDetail(app, ctx, ep);
};
/*
 * Gets a prototype
 * Asks the server in case there is nothing stored on the client
 *
 */
exports.getPrototype = function(name, context) {
	var storage = globals.getStorage();

	var ctx = {
		"$user": context.user,
		"$role": context.role,
		"$lang": context.lang
	};

	var readCache;
	readCache = storage.read({
		$context: ctx,
		$collection: "$metacache_$meta_proto",
		$endpoint: "$local",
		$key: "$prototype_" + name
	});
	return readCache.then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			var proto = result.$data;
			log && log("Prototype from cache");
			return proto;
		} else {
			log && log("Fetching remote prototype");
			return _fetchRemotePrototype(name)
				.then(function(prototype) {
					return _storePrototype(name, prototype, ctx).then(function() {
						return prototype;
					});
				});
		}
	});
};

/*
 *
 */
function _fetchRemotePrototype(name) {
	var deferred = $.Deferred();
	try {
		var base = globals.baseLocation();
		var segs = name.split(".");
		var ep = segs.slice(0, 3).join("/");
		var repr = segs.slice(3, 5).join(".");
		var url = base.host + "/mobile1/" + ep + "/$prototypes('" + repr + "')";

		var headers = {
			"Accept-Language": locale.getCurrentLocale()
		};

		ajax("GET", url, null, headers)
			.then(function(data) {
				if (data.isSuccess) {
					deferred.resolve(data.responseJSON);
				} else {
					return $.smReject(data.responseJSON);
				}
			}).fail(function(e) {
				deferred.reject(e);
			});
	} catch (e) {
		deferred.reject(e);
	} finally {
		return deferred.promise();
	}
}

function _storePrototype(name, prototype, ctx) {
	var storage = globals.getStorage();
	return storage.put({
		$context: ctx,
		$collection: "$metacache_$meta_proto",
		$endpoint: "$local",
		$key: "$prototype_" + name,
		$data: prototype
	});
}
});

define('syracuse-tablet/html/js/application/metaData',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/application/metaDataCache','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/authoring/authoringArticleGen'],function (require, exports, module) {"use strict";

/*
 * This module should be used to access any kind of meta data
 * It either queries the local database or fetches the information
 * remotely and adds it to the local database
 *
 * Getting meta data is done in three levels for performance and maintainance reasons
 * 1 - In memory JS objects, once a piece of metadata has been read from level 2
 *     This level should be handled in this file
 * 2 - IndexedDB/WebSQL, persistent over restarts but slower than level 1
 *     This level should be handled in metaDataCache.js
 * 3 - Remote access to the server
 *     This level should be handled in metaDataCache.js
 */

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var metaDataCache = require('syracuse-tablet/html/js/application/metaDataCache');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("metaData");
var prototypeModule = require('syracuse-tablet/html/js/helpers/prototype');
var articleGen = require('syracuse-tablet/html/js/authoring/authoringArticleGen');

/**
 * Added to page class attribute to identify requests
 */
var _REQUEST_SUBTYPE = "query request";
var _STAT_SUBTYPE = "stat";
var _mobileDashSuffix = ".$mobileDashboard";
var _currentApplicationContext = {};
var _currentPrototypeContext = {};

// Applications depending on context
var _applications = null;
var _applicationDetails = {};
// Applications defined client side (always available)
var _applicationsStatic = {};

// Prototypes
var _prototypes = {};

/*
 *
 */
function _checkApplicationCtx() {
	var ctx = globals.getUserCtx();
	var endpoint = globals.getEndpoint();
	if (_currentApplicationContext.user != ctx.$user ||
		_currentApplicationContext.role != ctx.$role ||
		_currentApplicationContext.lang != ctx.$lang ||
		_currentApplicationContext.endpoint != endpoint) {
		_currentApplicationContext.user = ctx.$user;
		_currentApplicationContext.role = ctx.$role;
		_currentApplicationContext.lang = ctx.$lang;
		_currentApplicationContext.endpoint = endpoint;
		log && log("Application context changed to: " + JSON.stringify(_currentApplicationContext));
		_resetApplicationCache();
	}
}

/*
 *
 */
function _resetApplicationCache() {
	_applications = null;
	_applicationDetails = {};
}

function _readApplications(forceReadFromServer) {
	var deferred = $.Deferred();
	forceReadFromServer = forceReadFromServer && globals.isOnline();
	metaDataCache.getKnownApplications(_currentApplicationContext, forceReadFromServer).then(function(apps) {
		deferred.resolve(apps);
	}).fail(function(e) {
		if (forceReadFromServer === true && e && e.$noConnectionError === true) {
			// Try to read cached data to allow to build welcome page if no network connection 
			metaDataCache.getKnownApplications(_currentApplicationContext, false).then(function(apps) {
				deferred.resolve(apps);
			}).fail(function(e) {
				deferred.reject(e);
			});
		} else {
			deferred.reject(e);
		}
	});
	return deferred.promise();
}
/*
 *
 */
function _initApplications(forceReadFromServer) {
	log && log("Reading applications");
	var step = _readApplications(forceReadFromServer).then(function(apps) {
		var matchedApps = [];
		apps.forEach(function(app) {
			var epMatch = true;
			if (app.endpoints && app.endpoints.length > 0) {
				epMatch = epMatch && app.endpoints.some(function(ep) {
					return (ep.application + "." + ep.contract + "." + ep.dataset === _currentApplicationContext.endpoint);
				});
			}
			var roleMatch = true;
			if (globals.isDvlpMode()) {
				roleMatch = true;
			} else {
				if (app.roles && app.roles.length > 0 && epMatch) {
					roleMatch = roleMatch && app.roles.some(function(role) {
						return (role.code === _currentApplicationContext.role);
					});

				}
			}
			if (roleMatch && epMatch) {
				matchedApps.push(app);
			}
		});

		// Always add static resources
		Object.keys(_applicationsStatic).forEach(function(name) {
			matchedApps.push(_applicationsStatic[name].$application);
		});
		_applications = matchedApps;
		log && log("Number of applications: " + _applications.length);
	});
	// Scan version number after valid apps have been fetched
	return step.then(function() {
		return $.smForEachPromise(_applications, function(app) {
			return exports.getApplication(app.applicationName, true)
				.then(function(appData) {
					if (appData) {
						app.localVersionNumber = appData.$application.versionNumber; // This is the version number in the local cache
					} else {
						app.localVersionNumber = null; // Need to setup first
					}
				});
		});
	});
}

/*
 * Returns true if there is an update for this application
 */
exports.checkApplicationUpdate = function(appName) {
	var appHeader;
	return _getApplicationHeaderByName(appName)
		.then(function(_appHeader) {
			appHeader = _appHeader;
			return exports.getApplication(appName, true);
		})
		.then(function(appDetails) {
			if (!appDetails || !appHeader) { // not installed yet, so return false -> no update question to the user
				return false;
			}

			if (appHeader.versionNumber === appDetails.$application.versionNumber) {
				return false;
			}

			return true;
		});
};

/*
 *
 */
function _getApplicationHeaderByName(name) {
	var match = null;
	return $.smResolve()
		.then(function() {
			if (!_applications) {
				return _initApplications();
			}
		})
		.then(function() {
			_applications && _applications.some(function(app) {
				if (app.applicationName == name) {
					match = app;
					return true;
				}
			});
			return match;
		});
}

/*
 *
 */
exports.registerStaticApp = function(app) {
	if (!app || !app.$application) return;
	log && log("Register static application: " + app.$application.applicationName);
	app.isStaticApp = true;
	_applicationsStatic[app.$application.applicationName] = app;
};

/*
 * Return full details of requested application
 * name:
 * Name of application
 */
exports.getApplication = function(name, localOnly, forceUpdate) {
	// Application details already available?
	var app = forceUpdate !== true ? (_applicationsStatic[name] || _applicationDetails[name]) : null;
	if (app) {
		log && log("Application from cache: " + name);
		return $.smResolve(app);
	}
	return _getApplicationHeaderByName(name)
		.then(function(header) {
			if (header) {
				return metaDataCache.getApplication(header, _currentApplicationContext, localOnly, forceUpdate)
					.then(function(app) {
						if (app) {
							_applicationDetails[name] = app;
						}
						return app;
					})
					.then(function(app) {
						if (app && !localOnly) {
							$.each(_applications, function(idx, app1) {
								if (app1.applicationName === app.$application.applicationName) {
									app1.localVersionNumber = app.$application.versionNumber;
									app1.versionNumber = app.$application.versionNumber;
								}
							});
						}
						return app;
					});
			}
			log && log("Unknown application: " + name);
			return null;
		});
};

/*
 * Return all applications available for current context
 */
exports.getApplications = function(forceReadFromServer) {
	_checkApplicationCtx();
	if (_applications != null && forceReadFromServer !== true) {
		return $.smResolve(_applications);
	}
	return _initApplications(forceReadFromServer).then(function() {
		return _applications;
	});
};

exports.removeApplications = function() {
	return metaDataCache.removeApplications(_currentApplicationContext)
		.then(function() {
			_resetApplicationCache();
		});
};

/*
 *
 */
function _checkPrototypeCtx() {
	var ctx = globals.getUserCtx();
	var endpoint = globals.getEndpoint();
	if (_currentPrototypeContext.user != ctx.$user ||
		_currentPrototypeContext.role != ctx.$role ||
		_currentPrototypeContext.lang != ctx.$lang ||
		_currentPrototypeContext.endpoint != endpoint) {
		_currentPrototypeContext.user = ctx.$user;
		_currentPrototypeContext.role = ctx.$role;
		_currentPrototypeContext.lang = ctx.$lang;
		_currentPrototypeContext.endpoint = endpoint;
		log && log("Prototype context changed to: " + JSON.stringify(_currentPrototypeContext));
		_resetPrototypeCache();
	}
}

/*
 *
 */
function _resetPrototypeCache() {
	_prototypes = {};
}

/*
 * name:
 * application.protocol.dataset.representation.facet
 */
exports.getPrototype = function(name) {
	log && log("Getting prototype: " + name);
	var repr = name.split(".");
	if (repr.length < 5) { // Client side representations names are not fully qualified
		proto = clientContract.getPrototype(repr[0], repr[1]);
		log && log("Prototype (client side entitiy): " + name);
		return $.smResolve(proto);
	}

	_checkPrototypeCtx();
	var proto = _prototypes[name];
	if (proto) {
		return $.smResolve(proto);
	}
	var app = globals.getApplication();
	var appMetaData = app && app.dao && app.dao.appMetaData;
	var page = appMetaData && appMetaData.$pages && appMetaData.$pages[name];
	proto = page && page.$page && page.$page.$prototype;
	if (proto) {
		_prototypes[name] = proto;
		return $.smResolve(proto);
	}

	return metaDataCache.getPrototype(name, _currentPrototypeContext).then(function(proto) {
		log && log("Got prototype: " + name);
		_prototypes[name] = proto;
		return proto;
	});
};
/**
 * Update authoring of pageId in local database
 * The purpose is to avoid the reloading of the appplication each time we save an authoring (too long)
 * updatePageAuthoring is called by authoring after the article has been saved successfully in mongo DB
 */
exports.updatePageAuthoring = function(pageName, opt) {
	var $article = opt.articleParsed;
	var view = opt.view;
	if (!pageName || !$article || $.isEmptyObject($article)) {
		return $.smResolve(false);
	}
	return $.smResolve().then(function() {
		var ctx = globals.getUserCtx();
		var endpoint = globals.getEndpoint();
		var cac = _currentApplicationContext;
		if (!cac || cac.user != ctx.$user || cac.role != ctx.$role || cac.lang != ctx.$lang || cac.endpoint != endpoint) {
			throw new Error("unexpected bad context");
		}
		var app = globals.getApplication();
		var isDashBoard = pageName.smEndsWith(_mobileDashSuffix);
		if (isDashBoard) {
			pageName = pageName.split(_mobileDashSuffix)[0];
		}
		var appMetaData = app && app.dao && app.dao.appMetaData;
		if (!appMetaData) {
			throw new Error("Unknown appMetaData " + pageName);
		}
		appMetaData = $.extend(true, {}, appMetaData);
		// Just to force the saving
		appMetaData.$etag = utils.UUID();
		// Array because there are dots inpage name
		var pageInfo = isDashBoard ? _getDashboardByName(pageName, appMetaData) : jsutils.getPropByPath(appMetaData, ["$pages", pageName, "$page"]);
		if (!pageInfo) {
			throw new Error("Unknown page " + pageName);
		}
		pageInfo.$article = $.extend(true, {}, $article);
		pageInfo.$views = pageInfo.$views || [];
		pageInfo.$views.push(view);
		if (_applicationsStatic[app.applicationName]) {
			_applicationsStatic[app.applicationName] = appMetaData;
			return $.smResolve(appMetaData);
		}
		return metaDataCache.updateApplicationDetail(appMetaData, ctx, endpoint).then(function() {
			if (_applicationDetails[app.applicationName]) {
				_applicationDetails[app.applicationName] = appMetaData;
			}
			// Dashboards are not cached
			app.dao.setApplication(appMetaData);
		});
	});
};
// Parameter appMetaData in case of need to keep a pointer on dashboard found
function _getDashboardByName(name, appMetaData) {
	appMetaData = appMetaData || globals.getApplication().dao.appMetaData;
	var $dashboards = appMetaData.$dashboards;

	var dashboard;
	if (!Object.keys($dashboards).some(function(key) {
		dashboard = $dashboards[key];
		if (dashboard.$dashboardName === name) {
			return true;
		}
	})) {
		dashboard = null;
	};

	return dashboard;
}
/*
 * name:
 * Name of dashboard
 *
 * Returns full meta data of dashboard
 * Gadgets will be added in node $gadget of the dashboard data so that
 * there is no need to query the application later
 */
exports.getDashboard = function(name) {
	var appMetaData = globals.getApplication().dao.appMetaData;
	var $dashboards = appMetaData.$dashboards;

	var dashboard = _getDashboardByName(name);
	//console.log(name);
	//console.log(dashboard);
	return $.smResolve()
		.then(function() {
			if (dashboard) {
				if (dashboard && dashboard.$update) {
					return dashboard.$update(dashboard);
				} else {
					return dashboard;
				}
			}
		})
		.then(function(dashboard) {
			if (dashboard) {
				dashboard.$gadgets = dashboard.$gadgets || {};
				// Copy gadgets to dashboard
				if (appMetaData.$gadgets) {
					for (var vignette in dashboard.$vignettes) {
						var v = dashboard.$vignettes[vignette];
						if (appMetaData.$gadgets[v.$uuid]) {
							dashboard.$gadgets[v.$uuid] = appMetaData.$gadgets[v.$uuid];
						}
					}
				}
			}
			return dashboard;
		});
};

/*
 *
 */
exports.getDashboardPageName = function(dashboardName) {
	return dashboardName + _mobileDashSuffix;
};

/*
 * For the name of a page, get it's type (dashboard, regular =proto based, static =html based)
 * Also return some other flags like, cached page, etc...
 */
exports.getPageInfo = function(pageName) {
	return _getDashboardPageInfo(pageName)
		.then(function(pageInfo) {
			if (pageInfo) {
				return pageInfo;
			}
			return _getRegularPageInfo(pageName);
		});
};

function _getDashboardPageInfo(pageName) {
	if (!pageName.smEndsWith(_mobileDashSuffix)) {
		return $.smResolve(null);
	}
	var dashboardName = pageName.substring(0, pageName.length - 17);
	var dashboard = _getDashboardByName(dashboardName);
	if (!dashboard) {
		return $.smResolve(null);
	}
	var pageInfo = dashboard.$pageInfo || {};
	pageInfo.name = pageName;
	pageInfo.type = "dashboard";
	pageInfo.subtype = pageInfo.isWelcomePage ? "welcome" : "std";
	pageInfo.dashboardName = dashboard.$dashboardName;
	pageInfo.cached = false;
	pageInfo.refreshed = false;
	return $.smResolve(pageInfo);
}

function _getRegularPageInfo(pageName) {
	var appMetaData = globals.getApplication().dao.appMetaData;
	var $pages = appMetaData && appMetaData.$pages;
	var page = $pages && $pages[pageName];
	if (!page) {
		return $.smResolve(null);
	}

	var pageInfo = {
		name: pageName,
		home: false,
		type: "regular",
		subtype: "unknown",
		cached: false,
		refreshed: false
	};

	return $.smResolve(page.$page.$prototype)
		.then(function(prototype) {
			if (!prototype) {
				return exports.getPrototype(pageInfo.name);
			}
			return prototype;
		})
		.then(function(prototype) {
			if (prototype) {
				if (prototype.codeRequest != null) {
					// To confirm E Boyard
					pageInfo.subtype = _REQUEST_SUBTYPE;
				} else if (prototype.codeStat != null) {
					pageInfo.subtype = _STAT_SUBTYPE;
				} else {
					var facet = prototype.$type;
					if (!facet) {
						// if no type we take $url - in test representation  $type is not set
						facet = prototype.$url;
					}
					pageInfo.subtype = facet.substring(facet.lastIndexOf('.$') + 2);
					if (!pageInfo.subtype) {
						throw new Error("Unexpected facet for page " + pageName + "\n$url=" + prototype.$url);
					}
				}
			}
		})
		.then(function() {
			return pageInfo;
		});
}

/*
 * For a prototype based page, return article and prototype
 */
exports.getPageDetails = function(pageInfo) {
	var pageDetails;
	if (pageInfo.type === "regular") {
		return _getRegularPageDetails(pageInfo);
	}
	if (pageInfo.type === "rowdetail" || pageInfo.type === "carddesign" || pageInfo.type === "chartdetail") {
		return _getArrayChildPageDetails(pageInfo);
	}
	throw new Error("Unsupported page type: " + pageInfo.type);
};

function _getRegularPageDetails(pageInfo) {
	var pageDetails;
	var appMetaData = globals.getApplication().dao.appMetaData;
	var $pages = appMetaData && appMetaData.$pages;


	return $.smResolve().
	then(function() {
		// Get page from application meta data
		var page = $pages && $pages[pageInfo.name];
		if (page) {
			return {
				prototype: page.$page && page.$page.$prototype,
				article: page.$page && page.$page.$article,
				views: page.$page && page.$page.$views
			};
		}
	})
		.then(function(pageDetails) {
			if (!pageDetails) {
				// Check if this page is defined by a client side JS entity
				return clientContract.getRegularPageInfo(pageInfo.name)
					.then(function(page) {
						if (page) {
							return {
								prototype: page.$page && page.$page.$prototype,
								article: page.$page && page.$page.$article
							};
						}
					});
			}
			return pageDetails;
		})
		.then(function(pageDetails) {
			// Page not found in app meta data and not in client side contract, must be lazy loaded representation
			if (!pageDetails) {
				return exports.getPrototype(pageInfo.name)
					.then(function(proto) {
						if (proto) {
							return {
								prototype: proto,
							};
						}
					});
			}
			// Maybe there is an article on the client but prototype is comming from server
			if (!pageDetails.prototype) {
				return exports.getPrototype(pageInfo.name)
					.then(function(proto) {
						if (proto) {
							pageDetails.prototype = proto;
							return pageDetails;
						}
					});
			}
			return pageDetails;
		})
		.then(function(pageDetails) {
			if (pageDetails) {
				// Wrap prototype in class
				pageDetails.prototype = prototypeModule.create(pageDetails.prototype); //, parentProto)
			}
			return pageDetails;
		})
		.then(function(pageDetails) {
			if (pageDetails) {
				return _ensureRegularPageDetailsArticle(pageInfo, pageDetails)
					.then(function() {
						if (pageDetails.prototype && pageDetails.prototype.data("codeRequest") != null) {
							// To confirm E Boyard
							pageInfo.subtype = _REQUEST_SUBTYPE;
						}
						return pageDetails;
					});
			}
			// Page not found
			return null;
		});
}

function _getArrayChildPageDetails(pageInfo) {
	return $.smResolve()
		.then(function() {
			var pageDetails = {
				prototype: pageInfo.prototype,
				article: pageInfo.article
			};
			return _ensureRegularPageDetailsArticle(pageInfo, pageDetails)
				.then(function() {
					return pageDetails;
				});
		});
}

function _ensureRegularPageDetailsArticle(pageInfo, pageDetails) {
	// If !vignetteArticle we take the one of the pageDetails if any
	var article;
	var genArticle;
	var vignetteArticle = pageInfo.options.vignetteArticle;
	var emptyVignetteArticle = vignetteArticle && $.isEmptyObject(vignetteArticle);
	if (vignetteArticle && !emptyVignetteArticle) {
		// In dashboard page's article is given by the vignette (stored in in vignette's article
		article = vignetteArticle;
	} else {
		// Page article if any
		article = pageDetails.article;
	}
	if (article && !$.isEmptyObject(article)) {
		genArticle = $.smResolve(article);
	} else {
		genArticle = $.smResolve().then(function() {
			return articleGen.genNewArticle({
				page: {
					prototype: pageDetails.prototype
				}
			}).then(function(protoArticle) {
				article = protoArticle;
			});
		});
	}
	return genArticle.then(function() {
		if (emptyVignetteArticle) {
			//#6861 - !! we need to keep the same json object in order to be able to modify it by authoring
			// That means that in a dasboard all page article should be attached to the articel of the dasboard
			// So like we created a new article we need to keep the empty vignette object and copy all the properties or new article
			for (var p in article) {
				vignetteArticle[p] = article[p];
			}
			pageDetails.article = vignetteArticle;
		} else {
			pageDetails.article = article;
		}
		/**
		 * We add authoring properties of the page given by the vignette (E.g: actionsSettings...
		 * Doing this way we get the layout article form vignette or from generator and add these props after
		 */
		var vignetteAuthPageProps = pageInfo.options.vignetteAuthPageProps;
		if (!$.isEmptyObject(vignetteAuthPageProps)) {
			utils.authCopyPageProperties(vignetteAuthPageProps, pageDetails.article);
		}
	});
}
});

define('syracuse-tablet/html/js/helpers/offlineManager',['require','exports','module','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {"use strict";

var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');

function _setAppOfflineState(offline) {
	$("#s-m-app-id").toggleClass("offline", offline);
}

var _OffLineMgr = function() {
	this._offline = null;

	// Be careful "notif" parameter not null or not undefined, we force notification display!
	//
	// byGlobalEvent (optional): True if called by a global OS hook and not detected on a network request 
	this.setOffline = function(offline, notif, byGlobalEvent) {
		offline = offline || false;
		//If this._offline==null we notify only the offline mode (otherwise the online message is always display we load a page)
		var stateChange = this._offline == null ? offline === true : offline !== this._offline;
		this._offline = offline;
		if (stateChange || notif) {
			notif = notif || {};
			notif = $.extend(true, {
				severityClass: offline ? "warning" : "success",
				title: locale.text("info.network." + (offline ? "offline" : "online") + ".title"), // You are online, You are offline
				body: byGlobalEvent != true ?
					locale.text("info.network." + (offline ? "offline.outdated" : "online.uptodate")) : // Data read from server / cache
				"" // If event is global, there was not server roundtrip, so do not show the message body, it would be confusing
			}, notif);
			globals.getModal().notify(notif);
			_setAppOfflineState(offline);
		}
	};
	this.setOfflineQuiet = function(offline) {
		this._offline = offline;
		_setAppOfflineState(offline);
	};
	this.isOnline = function() {
		return navigator.onLine;
	};
};


exports.init = function() {
	globals.setOfflineManager(new _OffLineMgr());
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/example',['require','exports','module'],function (require, exports, module) {"use strict";

var _data = [];
for (var i = 0; i < 100; i++) {
	_data.push({
		$uuid: "" + i,
		name: "My name is: " + i,
		desc: "My desc is: " + i,
		desc2: "My desc2 is: " + i,
		amount: i * 100,
	});
}

exports.entity = {
	$entityName: "example",
	$value: "{name}",
	$properties: {
		name: {
			$type: "application/x-string",
			$title: "My name"
		},
		desc: {
			$type: "application/x-string",
			$title: "My description"
		},
		desc2: {
			$type: "application/x-string",
			$title: "My description 2"
		},
		amount: {
			$type: "application/x-integer",
			$title: "My amount",
			$isExcluded: false,
			$isHidden: false,
			$isMandatory: false,
			$isReadOnly: false,
			$isDisabled: false
		}
	},
	$relations: {
		values: {
			$type: "exampleChild"
		}
	},
	$articles: {
		$details: {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "name",
						"$isTitleHidden": false
					}]
				}, {
					"$bind": "desc",
					"$isTitleHidden": false
				}],
			}, {
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "desc2",
						"$isTitleHidden": false
					}]
				}, {
					"$bind": "amount",
					"$isTitleHidden": false
				}]
			}]
		},
		$edit: {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "name",
						"$isTitleHidden": true
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "desc",
						"$isTitleHidden": true
					}]
				}],
			}, {
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "desc2",
						"$isTitleHidden": false
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "amount",
						"$isTitleHidden": false
					}]
				}]
			}]
		}
	},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			// only works because op.$key is equal the array index and equal the $uuid
			deferred.resolve(_data[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/exampleHubLayout',['require','exports','module'],function (require, exports, module) {"use strict";

var _data = [];
for (var i = 0; i < 100; i++) {
	_data.push({
		$uuid: "" + i,
		name: "My name is: " + i,
		desc: "My desc is: " + i,
		desc2: "My desc2 is: " + i,
		amount: i * 100,
	});
}

exports.entity = {
	$entityName: "exampleHubLayout",
	$value: "{name}",
	$properties: {
		name: {
			$type: "application/x-string",
			$title: "My name"
		},
		desc: {
			$type: "application/x-string",
			$title: "My description"
		},
		desc2: {
			$type: "application/x-string",
			$title: "My description 2"
		},
		amount: {
			$type: "application/x-integer",
			$title: "My amount",
			$isExcluded: false,
			$isHidden: false,
			$isMandatory: false,
			$isReadOnly: false,
			$isDisabled: false
		}
	},
	$relations: {
		values: {
			$type: "exampleChild"
		}
	},
	$articles: {
		$details: {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Layout group 1",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$size": "full",
					"$items": [{
						"$layoutType": "stack",
						"$items": [{
							"$layoutType": "row",
							"$items": [{
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "desc",
								"$isTitleHidden": false
							}],
						}]
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$size": "medium",
					"$items": [{
						"$layoutType": "stack",
						"$items": [{
							"$layoutType": "row",
							"$items": [{
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "desc",
								"$isTitleHidden": false
							}],
						}]
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "purple",
					"$size": "medium",
					"$items": [{
						"$layoutType": "stack",
						"$items": [{
							"$layoutType": "row",
							"$items": [{
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "desc",
								"$isTitleHidden": false
							}],
						}]
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$size": "wide",
					"$items": [{
						"$layoutType": "stack",
						"$items": [{
							"$layoutType": "row",
							"$items": [{
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "desc",
								"$isTitleHidden": false
							}],
						}]
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Layout group 2",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "orange",
					"$size": "large",
					"$items": [{
						"$layoutType": "stack",
						"$items": [{
							"$layoutType": "row",
							"$items": [{
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "desc",
								"$isTitleHidden": false
							}],
						}]
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$size": "medium",
					"$items": [{
						"$layoutType": "stack",
						"$items": [{
							"$layoutType": "row",
							"$items": [{
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "desc",
								"$isTitleHidden": false
							}],
						}]
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "purple",
					"$size": "green",
					"$items": [{
						"$layoutType": "stack",
						"$items": [{
							"$layoutType": "row",
							"$items": [{
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "desc",
								"$isTitleHidden": false
							}],
						}]
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$size": "wide",
					"$items": [{
						"$layoutType": "stack",
						"$items": [{
							"$layoutType": "row",
							"$items": [{
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "desc",
								"$isTitleHidden": false
							}],
						}]
					}]
				}]
			}]
		},
		$edit: {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$widthMd": "6,6",
				"$items": [{
					"$bind": "name",
					"$isTitleHidden": true
				}, {
					"$bind": "desc",
					"$isTitleHidden": true
				}],
			}, {
				"$layoutType": "row",
				"$widthMd": "6,6",
				"$items": [{
					"$bind": "desc2",
					"$isTitleHidden": false
				}, {
					"$bind": "amount",
					"$isTitleHidden": false
				}]
			}]
		}
	},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			// only works because op.$key is equal the array index and equal the
			// $uuid
			deferred.resolve(_data[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testDatatypes',['require','exports','module'],function (require, exports, module) {"use strict";

var _data = [];
var _switch = false;
for (var i = 0; i < 10; i++) {
	_data.push({
		$uuid: "" + i,
		propString: "Simple String=" + i,
		propDate: "2014-03-" + (i + 20),
		propDateTime: "2014-06-" + (i + 10) + "T12:45:" + (i + 44) + ".123Z",
		propTime: "15:45:" + (i + 34),
		propTimeShort: "15:45:" + (i + 34),
		propInt: (i * 1000 + i * 10),
		propDecimal: Math.sqrt(i * 1000 + i * 10),
		propReal: Math.sqrt(i * 1000 + i * 30),
		propBoolean: (_switch = !_switch),
		propChoice: "mr",
		propQuantity: i * 123,
		propStringUnit: "EUR",
		propStringMandatory: "Mandatory",
		propDecimalMandatory: "",
		propStringMinMax: "",
		propStringMinMaxValue: "",
		propStringPattern: "",
		propPhone: "0402030506",
		propEmail: "laurent.varciat@sage.com"
	});
}

var _$details = {
	"$layoutType": "stack",
	"$items": [{
		"$layoutType": "stack",
		"$title": "String types",
		"$collapsible": "expanded",
		"$items": [{
			"$bind": "propString",
			"$scanGPS": true,
		}, {
			"$bind": "propStringMandatory"
		}, {
			"$bind": "propStringMinMax"
		}, {
			"$bind": "propStringPattern"
		}, {
			"$bind": "propStringM"
		}]
	}, {
		"$layoutType": "stack",
		"$title": "Numerical",
		"$collapsible": "collapsed",
		"$items": [{
			"$bind": "propTimeShort"
		}, {
			"$bind": "propDecimal"
		}, {
			"$bind": "propReal"
		}, {
			"$bind": "propIntM"
		}, {
			"$bind": "propDecimalMandatory"
		}, {
			"$bind": "propRealM"
		}, {
			"$bind": "propDecimalM"
		}, {
			"$bind": "propStringMinMaxValue"
		}, {
			"$bind": "propInt"
		}]
	}, {
		"$layoutType": "stack",
		"$title": "Date and Time",
		"$items": [{
			"$bind": "propDateTime"
		}, {
			"$bind": "propDateTimeM"
		}, {
			"$bind": "propDateM"
		}, {
			"$bind": "propTime"
		}, {
			"$bind": "propDate"
		}, {
			"$bind": "propTimeM"
		}]
	}, {
		"$layoutType": "stack",
		"$title": "Complex",
		"$collapsible": "collapsed",
		"$items": [{
			"$bind": "propQuantity"
		}, {
			"$bind": "propBoolean"
		}, {
			"$bind": "propChoice"
		}, {
			"$bind": "propBooleanM"
		}]
	}, {
		"$layoutType": "stack",
		"$title": "Divers",
		"$collapsible": "expanded",
		"$items": [{
			"$bind": "propPhone"
		}, {
			"$bind": "propEmail"
		}]
	}]
};
var _entity = {
	$entityName: "testDataTypes",
	$properties: {
		propString: {
			$type: "application/x-string",
			$isMandatory: false,
			$title: "My name (max len 25)",
			$maxLength: 25
		},
		propStringMandatory: {
			$type: "application/x-string",
			$isMandatory: true,
			$title: "String Madatory"
		},
		propStringMinMax: {
			$type: "application/x-string",
			$title: "String MinMaxLength(3-5)",
			$minLength: 3,
			$maxLength: 5
		},
		propStringMinMaxValue: {
			$type: "application/x-integer",
			$isMandatory: false,
			$title: "Integer MinMaxValue(3-50)",
			$minimun: "3",
			$maximun: "50"
		},
		propStringPattern: {
			$type: "application/x-string",
			$title: "Pattern",
			$maxLength: 40
		},
		propDate: {
			$type: "application/x-date",
			$isMandatory: false,
			$title: "Date"
		},

		propDateTime: {
			$type: "application/x-datetime",
			$isMandatory: false,
			$title: "Date+Time"
		},
		propTime: {
			$type: "application/x-time",
			$isMandatory: false,
			$title: "Time long",
			$format: "TT"
		},
		propTimeShort: {
			$type: "application/x-time",
			$isMandatory: false,
			$title: "Time",
		},
		propInt: {
			$type: "application/x-integer",
			$isMandatory: false,
			$title: "Integer (1-7000 Max)",
			$minimun: "1",
			$maximun: "7000"
		},

		propDecimalMandatory: {
			$type: "application/x-decimal",
			$isMandatory: true,
			$title: "Decimal mandatory(2.4)",
			$scale: 2,
			$precision: 4,
			$format: "0.00"
		},
		propDecimal: {
			$type: "application/x-decimal",
			$isMandatory: false,
			$title: "Decimal(4.7)",
			$scale: 4,
			$precision: 7,
			$format: "0.0000"
		},
		propReal: {
			$type: "application/x-real",
			$isMandatory: false,
			$title: "Real",
		},

		propBoolean: {
			$type: "application/x-boolean",
			$isMandatory: false,
			$title: "Boolean"
		},
		propChoice: {
			$type: "application/x-choice",
			$isMandatory: false,
			$title: "Choice",
			//$format: "$radios",
			$value: {
				$enum: [{
					$title: "Mr.",
					$value: "mr"
				}, {
					$title: "Mrs.",
					$value: "mrs"
				}],
				$type: "application/x-string"
			}
		},
		propQuantity: {
			$title: "Quantity",
			$type: "application/x-quantity",
			$value: {
				$title: "{$value} {$unit}",
				$type: "application/x-decimal",
				$scale: 9,
				$precision: 2,
				$format: "0.00"
			},
			$unit: "propStringUnit"
		},
		propStringUnit: {
			$type: "application/x-string",
			$isMandatory: false,
			$isExcluded: true,
			$title: "Unit for quantity"
		},
		propStringM: {
			$type: "application/x-string",
			$isMandatory: true,
			$title: "My name"
		},
		propDateM: {
			$type: "application/x-date",
			$isMandatory: true,
			$title: "Date (Mandatory)"
		},
		propDateTimeM: {
			$type: "application/x-datetime",
			$isMandatory: true,
			$title: "Date+Time (Mandatory)"
		},
		propTimeM: {
			$type: "application/x-time",
			$isMandatory: true,
			$title: "Time (Mandatory)",
		},
		propIntM: {
			$type: "application/x-integer",
			$isMandatory: true,
			$title: "Integer (Mandatory)",
		},
		propDecimalM: {
			$type: "application/x-decimal",
			$isMandatory: true,
			$title: "Decimal (Mandatory)",
		},
		propRealM: {
			$type: "application/x-real",
			$isMandatory: true,
			$title: "Real (Mandatory)",
		},
		propBooleanM: {
			$type: "application/x-boolean",
			$isMandatory: true,
			$title: "Boolean (Mandatory)"
		},
		propPhone: {
			$title: "Phone Number",
			$type: "application/x-string",
			$format: "$phone"
		},
		propEmail: {
			$title: "Email",
			$type: "application/x-string",
			$format: "$email"
		}
	},
	$relations: {},
	$articles: {
		$details: _$details,
		$edit: _$details,
	},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			// template when creating a new record
			var i = 15;
			var tpl = {
				$uuid: "" + i,
				propString: "Simple String=" + i,
				propDate: "2014-03-" + i,
				propDateTime: "2014-06-" + i + "T12:45:" + (i + 44) + ".234Z",
				propTime: "15:45:" + (i + 34),
				propInt: (i * 1000 + i * 10),
				propDecimal: Math.sqrt(i * 1000 + i * 10),
				propReal: Math.sqrt(i * 1000 + i * 30),
				propBoolean: (_switch = !_switch)
			};

			deferred.resolve(tpl);
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			// only works because op.$key is equal the array index and equal the $uuid
			deferred.resolve(_data[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};


exports.entity = _entity;
});

define('syracuse-tablet/html/js/demos/clientTestApp/testFormats',['require','exports','module'],function (require, exports, module) {"use strict";

var _data = [];
var _switch = false;
for (var i = 0; i < 10; i++) {
	_data.push({
		$uuid: "" + i,
		propDate1: "2014-03-" + (i + 20),
		propDateTime1: "2014-06-" + (i + 10) + " 12:45:" + (i + 44),
		propTime1: "15:45:" + (i + 34),
		propInt1: (i * 1000 + i * 10),
		propDecimal1: Math.sqrt(i * 1000 + i * 10),
		propReal1: Math.sqrt(i * 1000 + i * 30),
		propDate2: "2014-03-" + (i + 20),
		propDateTime2: "2014-06-" + (i + 10) + " 12:45:" + (i + 44),
		propTime2: "15:45:" + (i + 34),
		propInt2: (i * 1000 + i * 10),
		propDecimal2: Math.sqrt(i * 1000 + i * 10),
		propReal2: Math.sqrt(i * 1000 + i * 30),
		propString: "Test"

	});
}

exports.entity = {
	$entityName: "testFormats",
	$properties: {
		propDate1: {
			$type: "application/x-date",
			$title: "Date"
		},
		propDateTime1: {
			$type: "application/x-datetime",
			$title: "Date+Time"
		},
		propTime1: {
			$type: "application/x-time",
			$title: "Time",
		},
		propInt1: {
			$type: "application/x-integer",
			$title: "Integer",
		},
		propDecimal1: {
			$type: "application/x-decimal",
			$title: "Decimal",
		},
		propReal1: {
			$type: "application/x-real",
			$title: "Real",
		},
		propDate2: {
			$type: "application/x-date",
			$title: "Date"
		},
		propDateTime2: {
			$type: "application/x-datetime",
			$title: "Date+Time"
		},
		propTime2: {
			$type: "application/x-time",
			$title: "Time",
		},
		propInt2: {
			$type: "application/x-integer",
			$title: "Integer",
		},
		propDecimal2: {
			$type: "application/x-decimal",
			$title: "Decimal",
		},
		propReal2: {
			$type: "application/x-real",
			$title: "Real",
		},
		propString: {
			$type: "application/x-string",
			$title: "String",
		},
	},
	$relations: {},
	$articles: {},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({});
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve(_data[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testFormatsReference',['require','exports','module'],function (require, exports, module) {"use strict";


var $descriptionSamples = ["Labe", "Labuan", "La Rochelle", "Las Vegas", "Las Palmas", "Liege", "Libreville", "Lille", "Liverpool", "Leipzig", "Lucknow", "London"];
var $codeSamples = ["LEK", "LBU", "LRH", "LAS", "LPA", "LGG", "LBV", "LIL", "LPL", "LEJ", "LKO", "LON"];

var _data = {
	SITE_REF: {
		$description: "Paris",
		FCY: "PAR"
	},
	SITE_REF_1: {
		$description: "Yaounde",
		FCY: "YDE"
	},
	SITE_REF_2: {
		$description: "London",
		FCY: "LON"
	},
	SITE_REF_3: {
		$description: "Lisbon",
		FCY: "LIS"
	}
};

var _qData = [];
var j = -1;
var m = -1;
for (var i = 0; i < 3; i++) {
	_qData.push({
		$uuid: "" + i,
		SITE_REF: {
			$description: $descriptionSamples[++j],
			FCY: $codeSamples[++m]
		},
		SITE_REF_1: {
			$description: $descriptionSamples[++j],
			FCY: $codeSamples[++m]
		},
		SITE_REF_2: {
			$description: $descriptionSamples[++j],
			FCY: $codeSamples[++m]
		},
		SITE_REF_3: {
			$description: $descriptionSamples[++j],
			FCY: $codeSamples[++m]
		}
	});
}

exports.entity = {
	$entityName: "testFormatsReference",
	$baseUrl: "http://localhost:8124/mobile1/x3/erp/SUPERV",
	$properties: {
		"SITE": {
			"$type": "application/x-string",
			"$maxLength": 5,
			"$isExcluded": true
		},
		"SITE_REF": {
			$type: "application/x-reference",
			$title: "Reference",
			$shortTitle: "Reference",
			$capabilities: "sort,filter",
			$item: {
				$url: "{$baseUrl}/testFormatsReference('{$key}')?representation=testFormatsReference.$lookup",
				$value: "{FCY}",
				"FCY": "{SITE}",
				"$key": "{FCY}",
				"$properties": {
					"FCY": {
						"$type": "application/x-string"
					}
				},
				"$links": {
					"$details": {
						"$title": "details",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference('{SITE}')?representation=testFormatsReference.$details",
						"$method": "GET"
					},
					"$lookup": {
						"$title": "lookup",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference?representation=testFormatsReference.$lookup",
						"$method": "GET"
					},
					"$query": {
						"$title": "query",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference?representation=testFormatsReference.$query",
						"$method": "GET"
					},
					"SIT1": {
						"$title": "SIT1",
						"$target": "main",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "https://maps.google.de/maps?q={SITE}&t=Default",
						"$method": "GET"
					}
				}
			}
		},
		"SITE_REF_1": {
			$type: "application/x-reference",
			$title: "Reference 1",
			$shortTitle: "Reference 1",
			$capabilities: "sort,filter",
			$item: {
				$url: "{$baseUrl}/testFormatsReference('{$key}')?representation=testFormatsReference.$lookup",
				$value: "{FCY}",
				"FCY": "{SITE}",
				"$key": "{FCY}",
				"$properties": {
					"FCY": {
						"$type": "application/x-string"
					}
				},
				"$links": {
					"$details": {
						"$title": "details",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference('{SITE}')?representation=testFormatsReference.$details",
						"$method": "GET"
					},
					"$lookup": {
						"$title": "lookup",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference?representation=testFormatsReference.$lookup",
						"$method": "GET"
					},
					"$query": {
						"$title": "query",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference?representation=testFormatsReference.$query",
						"$method": "GET"
					},
					"SIT1": {
						"$title": "SIT1",
						"$target": "main",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "https://maps.google.de/maps?q={SITE}&t=Default",
						"$method": "GET"
					}
				}
			}
		},
		"SITE_REF_2": {
			$type: "application/x-reference",
			$title: "Reference 2",
			$shortTitle: "Reference 2",
			$capabilities: "sort,filter",
			$item: {
				$url: "{$baseUrl}/testFormatsReference('{$key}')?representation=testFormatsReference.$lookup",
				$value: "{FCY}",
				"FCY": "{SITE}",
				"$key": "{FCY}",
				"$properties": {
					"FCY": {
						"$type": "application/x-string"
					}
				},
				"$links": {
					"$details": {
						"$title": "details",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference('{SITE}')?representation=testFormatsReference.$details",
						"$method": "GET"
					},
					"$lookup": {
						"$title": "lookup",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference?representation=testFormatsReference.$lookup",
						"$method": "GET"
					},
					"$query": {
						"$title": "query",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference?representation=testFormatsReference.$query",
						"$method": "GET"
					},
					"SIT1": {
						"$title": "SIT1",
						"$target": "main",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "https://maps.google.de/maps?q={SITE}&t=Default",
						"$method": "GET"
					}
				}
			}
		},
		"SITE_REF_3": {
			$type: "application/x-reference",
			$title: "Reference 3",
			$shortTitle: "Reference 3",
			$capabilities: "sort,filter",
			$item: {
				$url: "{$baseUrl}/testFormatsReference('{$key}')?representation=testFormatsReference.$lookup",
				$value: "{FCY}",
				"FCY": "{SITE}",
				"$key": "{FCY}",
				"$properties": {
					"FCY": {
						"$type": "application/x-string"
					}
				},
				"$links": {
					"$details": {
						"$title": "details",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference('{SITE}')?representation=testFormatsReference.$details",
						"$method": "GET"
					},
					"$lookup": {
						"$title": "lookup",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference?representation=testFormatsReference.$lookup",
						"$method": "GET"
					},
					"$query": {
						"$title": "query",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference?representation=testFormatsReference.$query",
						"$method": "GET"
					},
					"SIT1": {
						"$title": "SIT1",
						"$target": "main",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "https://maps.google.de/maps?q={SITE}&t=Default",
						"$method": "GET"
					}
				}
			}
		}
	},
	$relations: {},
	$articles: {
		$details: {
			"$layoutType": "stack",
			$items: [{
				$bind: "SITE_REF",
				$title: "Ref field 1"
			}, {
				$bind: "SITE_REF_1",
				$title: "Ref field 2"
			}, {
				$bind: "SITE_REF_2",
				$title: "Ref field 3"
			}, {
				$bind: "SITE_REF_3",
				$title: "Ref field 4"
			}]
		},
		$edit: {
			"$layoutType": "stack",
			$items: [{
				$bind: "SITE_REF",
				$title: "Ref field 1"
			}, {
				$bind: "SITE_REF_1",
				$title: "Ref field 2"
			}, {
				$bind: "SITE_REF_2",
				$title: "Ref field 3"
			}, {
				$bind: "SITE_REF_3",
				$title: "Ref field 4"
			}]
		}
	},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({});
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve(_data);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _qData
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testCharts',['require','exports','module'],function (require, exports, module) {"use strict";

var _data = [{
	part: "Gear",
	value: 50,
	revenue: 40,
	margin: 10
}, {
	part: "Motor",
	value: 60,
	revenue: 40,
	margin: 20
}, {
	part: "Head drive",
	value: 60,
	revenue: 80,
	margin: -20
}, {
	part: "Handwheel",
	value: 70,
	revenue: 90,
	margin: 10
}, {
	part: "Crank",
	value: 70,
	revenue: 70,
	margin: 0
}, {
	part: "Saddle",
	value: 80,
	revenue: 30,
	margin: 50
}, {
	part: "Base",
	value: 20,
	revenue: 40,
	margin: -20
}, {
	part: "Spindle",
	value: 10,
	revenue: 0,
	margin: 10
}];


exports.entity = {
	$entityName: "testCharts",
	$properties: {
		part: {
			$type: "application/x-string",
			$title: "Item"
		},
		value: {
			$type: "application/x-decimal",
			$title: "Value",
			$format: "0.0000"
		},
		revenue: {
			$type: "application/x-decimal",
			$title: "Revenue",
			$format: "0.0000"
		},
		margin: {
			$type: "application/x-decimal",
			$title: "Margin",
			$format: "0.0000"
		}
	},

	// invoked after protype generation to do adjustments
	$prototype: function(proto) {

		// Add some chart information in $query prototype
		var res = proto.$properties && proto.$properties.$resources;
		if (res) {
			res.$axes = [{
				$title: "Item",
				$hierarchies: [
					["part"]
				]
			}, {
				$hierarchies: [
					["$measures"]
				]
			}];
			res.$cube = {
				$title: "Sales overview",
				$hierarchies: {
					part: {
						$properties: ["part"]
					}
				},
				$measures: {
					value: {},
					revenue: {},
					margin: {}
				}
			};
		}
	},
	$relations: {},
	$articles: {},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve(_data[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testConstraints',['require','exports','module'],function (require, exports, module) {"use strict";

var _data = [];
var _switch = false;
for (var i = 0; i < 10; i++) {
	_data.push({
		$uuid: "" + i,
		propString: "Test " + i,
		propString2: "Some text " + i,
		propString3: "Fill me " + i,
		propInt: (i * 1000 + i * 10),
		propInt2: (i * 1000 + i * 100),
		propDecimal: Math.sqrt(i * 1000 + i * 10),
		propDecimal2: Math.sqrt(i * 1000 + i * 100),
		propDecimal3: Math.sqrt(i * 1000 + i * 110),
		propDecimal4: Math.sqrt(i * 1000 + i * 120),
		propQuantity: i * 123,
		propStringUnit: "EUR"
	});
}

exports.entity = {
	$entityName: "testConstraints",
	$properties: {
		propString: {
			$title: "Test: $pattern=Test.*\\d$",
			$type: "application/x-string",
			$isMandatory: true,
			$pattern: "Test.*\\d$"
		},
		propString2: {
			$title: "Test: $minLength=5, $maxLength=15",
			$type: "application/x-string",
			$isMandatory: true,
			$minLength: 5,
			$maxLength: 15
		},
		propString3: {
			$title: "Test: $minLength=5, $maxLength=15, $pattern=Fill me.*\\d$",
			$type: "application/x-string",
			$isMandatory: true,
			$pattern: "Fill me.*\\d$",
			$minLength: 5,
			$maxLength: 15
		},
		propInt: {
			$title: "Test: $minimum=100, $maximum=200",
			$type: "application/x-integer",
			$isMandatory: true,
			$minimum: 100,
			$maximum: 200
		},
		propInt2: {
			$title: "Test: $exclusiveMinimum=100, $exclusiveMaximum=200",
			$type: "application/x-integer",
			$isMandatory: true,
			$exclusiveMinimum: 100,
			$exclusiveMaximum: 200
		},
		propDecimal: {
			$title: "Test: $format=0.0000",
			$type: "application/x-decimal",
			$isMandatory: true,
			$format: "0.0000"
		},
		propDecimal2: {
			$title: "Test: $format=0.00",
			$type: "application/x-decimal",
			$isMandatory: true,
			$format: "0.00"
		},
		propDecimal3: {
			$title: "Test: $precision=10",
			$type: "application/x-decimal",
			$isMandatory: true,
			$precision: 10
		},
		propDecimal4: {
			$title: "Test: $scale=3",
			$type: "application/x-decimal",
			$isMandatory: true,
			$scale: 3,
			$format: "0.00000"
		},
		propQuantity: {
			$title: "Test: $format=0.00",
			$isMandatory: true,
			$type: "application/x-quantity",
			$value: {
				$title: "{$value} {$unit}",
				$type: "application/x-decimal",
				$scale: 9,
				$precision: 2,
				$format: "0.00"
			},
			$unit: "propStringUnit"
		},
		propStringUnit: {
			$title: "Unit for quantity",
			$type: "application/x-string",
			$isMandatory: false,
			$isExcluded: true
		},
	},
	$relations: {},
	$articles: {},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			// template when creating a new record
			var i = 15;
			var tpl = {
				$uuid: "" + i,
				propString: "Simple String=" + i,
				propInt: (i * 1000 + i * 10),
				propDecimal: Math.sqrt(i * 1000 + i * 10),
			};
			deferred.resolve(tpl);
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			// only works because op.$key is equal the array index and equal the $uuid
			deferred.resolve(_data[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testNavigateTo',['require','exports','module','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {"use strict";
var utils = require('syracuse-tablet/html/js/helpers/utils');

var _data = [];

for (var i = 0; i < 10; i++) {
	_data.push({
		$uuid: "" + i,
		name: "Customer group " + i,
		group: "" + i
	});

}

exports.entity = {
	$entityName: "testNavigateTo",
	$properties: {
		name: {
			$title: "Customer group name",
			$type: "application/x-string",
		},
		group: {
			$title: "Customer group",
			$type: "application/x-string",
		},
	},
	$prototype: function(proto) {
		// Add some chart information in $query prototype
		var res = utils.getPropByPath(proto, "$properties.$resources.$item.$links") || {};
		res["DASHBOARD"] = {
			$title: "Detail dashboard",
			$url: "{$baseUrl}/$mobileDashboards?dashboard=testContextDashboardChild&parameters=group%3D%7Bgroup%7D"
		};
	},
	$relations: {},
	$articles: {
		$query: {
			"$layoutType": "stack",
			"$items": [{
				"$bind": "$resources",
				"$detailsLink": "DASHBOARD",
				"$isTitleHidden": true,
				"$article": {
					"$items": [{
						"$bind": "group"
					}, {
						"$bind": "name"
					}]
				},
				"$display": "table"
			}]
		}
	},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			// template when creating a new record
			var i = 15;
			var tpl = {
				$uuid: "" + i,
				propString: "Simple String=" + i,
				propInt: (i * 1000 + i * 10),
				propDecimal: Math.sqrt(i * 1000 + i * 10),
			};
			deferred.resolve(tpl);
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			// only works because op.$key is equal the array index and equal the $uuid
			deferred.resolve(_data[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testNavigateToChild',['require','exports','module'],function (require, exports, module) {"use strict";

var _data = [];

for (var i = 0; i < 10; i++) {
	for (var j = 0; j < 10; j++) {
		_data.push({
			$uuid: "" + ((i * 10) + j),
			name: "Customer " + (i * 10) + j,
			desc: "Belongs to group " + i,
			group: "" + i
		});
	}
}

exports.entity = {
	$entityName: "testNavigateToChild",
	$properties: {
		name: {
			$title: "Customer name",
			$type: "application/x-string",
		},
		desc: {
			$title: "Description",
			$type: "application/x-string",
		},
		group: {
			$title: "Customer group",
			$type: "application/x-string",
		},
	},
	$relations: {},
	$articles: {},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			// template when creating a new record
			var i = 15;
			var tpl = {
				$uuid: "" + i,
				propString: "Simple String=" + i,
				propInt: (i * 1000 + i * 10),
				propDecimal: Math.sqrt(i * 1000 + i * 10),
			};
			deferred.resolve(tpl);
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			// only works because op.$key is equal the array index and equal the $uuid
			deferred.resolve(_data[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testPropertyHideShow',['require','exports','module'],function (require, exports, module) {"use strict";

var _data = [];
var _switch = false;
for (var i = 0; i < 10; i++) {
	_data.push({
		$uuid: "" + i,
		propStringShow: "Simple String=" + i,
		propStringHide: "Simple String=" + i,
		propStringReadOnly: "ReadOnly String=" + i,
		propStringDisabled: "Disabled=true String=" + i,
		propStringDisabledFalse: "Disabled=false String=" + i,

		propDate: "2014-03-" + (i + 20),
		propDateHide: "2014-03-" + (i + 20),
		propDateDisabled: "2014-03-" + (i + 20),
		propDateReadOnly: "2014-03-" + (i + 20),

		propDateTime: "2014-06-" + (i + 10) + "T12:45:" + (i + 44) + ".123Z",
		propDateTimeHide: "2014-06-" + (i + 10) + "T12:45:" + (i + 44) + ".123Z",
		propDateTimeDisabled: "2014-06-" + (i + 10) + "T12:45:" + (i + 44) + ".123Z",

		propTime: "15:45:" + (i + 34),
		propTimeHide: "15:45:" + (i + 34),
		propTimeDisabled: "15:45:" + (i + 34),


		propInt: (i * 1000 + i * 10),
		propIntHide: (i * 1000 + i * 10),
		propIntDisabled: (i * 1000 + i * 10),
		propIntReadOnly: (i * 1000 + i * 10),

		propDecimal: Math.sqrt(i * 1000 + i * 10),
		propDecimalHide: Math.sqrt(i * 1000 + i * 10),
		propDecimalDisabled: Math.sqrt(i * 1000 + i * 10),
		propDecimalReadOnly: Math.sqrt(i * 1000 + i * 10),

		propReal: Math.sqrt(i * 1000 + i * 30),

		propBoolean: (_switch = !_switch),
		propBooleanHidden: (_switch = !_switch),
		propBooleanDisabled: (_switch = !_switch),

		propChoice: "mr",
		propChoiceHidden: "mr",
		propChoiceDisabled: "mr",

		propQuantity: i * 123,
		propStringUnit: "EUR",
		propQuantityExcluded: i * 123,
		propStringUnitExcluded: "USD"

	});
}

exports.entity = {
	$entityName: "testPropertyHideShow",
	$properties: {
		propStringShow: {
			$type: "application/x-string",
			$isMandatory: true,
			$title: "String Mandatory $isHidden: false",
			$isHidden: false
		},
		propStringHide: {
			$type: "application/x-string",
			$isMandatory: false,
			$title: "String $isHidden: true",
			$isHidden: true
		},
		propStringReadOnly: {
			$type: "application/x-string",
			$title: "String $isReadOnly: true",
			$isReadOnly: true
		},
		propStringDisabledFalse: {
			$type: "application/x-string",
			$title: "String $isDisabled: false",
			$isDisabled: false
		},
		propStringDisabled: {
			$type: "application/x-string",
			$title: "String $isDisabled: true",
			$isDisabled: true
		},
		propDate: {
			$type: "application/x-date",
			$isMandatory: false,
			$title: "Date $isHidden: false",
			$isHidden: false
		},
		propDateHide: {
			$type: "application/x-date",
			$isMandatory: false,
			$title: "Date $isHidden: true",
			$isHidden: true
		},
		propDateDisabled: {
			$type: "application/x-date",
			$isMandatory: false,
			$title: "Date $isDisabled: true",
			$isDisabled: true
		},
		propDateReadOnly: {
			$type: "application/x-date",
			$isMandatory: false,
			$title: "Date $isReadOnly: true",
			$isReadOnly: true
		},

		propDateTime: {
			$type: "application/x-datetime",
			$isMandatory: false,
			$title: "Date+Time $isHidden: false",
			$isHidden: false
		},
		propDateTimeHide: {
			$type: "application/x-datetime",
			$isMandatory: false,
			$title: "Date+Time $isHidden: true",
			$isHidden: true
		},
		propDateTimeDisabled: {
			$type: "application/x-datetime",
			$isMandatory: false,
			$title: "Date+Time $isDisabled: true",
			$isDisabled: true
		},

		propTime: {
			$type: "application/x-time",
			$isMandatory: false,
			$title: "Time long",
			$format: "TT"
		},
		propTimeHide: {
			$type: "application/x-time",
			$isMandatory: false,
			$title: "Time $isHidden: true",
			$isHidden: true
		},
		propTimeDisabled: {
			$type: "application/x-time",
			$isMandatory: false,
			$title: "Time $isDisabled: true",
			$isDisabled: true
		},

		propInt: {
			$type: "application/x-integer",
			$isMandatory: false,
			$title: "Integer ($isHidden: false)",
			$isHidden: false
		},
		propIntHide: {
			$type: "application/x-integer",
			$isMandatory: false,
			$title: "Integer ($isHidden: true)",
			$isHidden: true
		},
		propIntDisabled: {
			$type: "application/x-integer",
			$isMandatory: false,
			$title: "Integer ($isDisabled: true)",
			$isDisabled: true
		},
		propIntReadOnly: {
			$type: "application/x-integer",
			$isMandatory: false,
			$title: "Integer ($isReadOnly: true)",
			$isReadOnly: true
		},
		propDecimal: {
			$type: "application/x-decimal",
			$isMandatory: false,
			$title: "Decimal $isHidden: false",
			$isHidden: false
		},
		propDecimalHide: {
			$type: "application/x-decimal",
			$isMandatory: false,
			$title: "Decimal $isHidden: true",
			$isHidden: true
		},
		propDecimalDisabled: {
			$type: "application/x-decimal",
			$isMandatory: false,
			$title: "Decimal $isDisabled: true",
			$isDisabled: true
		},
		propDecimalReadOnly: {
			$type: "application/x-decimal",
			$isMandatory: false,
			$title: "Decimal $isReadOnly: true",
			$isReadOnly: true
		},

		propReal: {
			$type: "application/x-real",
			$isMandatory: false,
			$title: "Real"
		},

		propBoolean: {
			$type: "application/x-boolean",
			$isMandatory: false,
			$title: "Boolean"
		},
		propBooleanHidden: {
			$type: "application/x-boolean",
			$isMandatory: false,
			$title: "Boolean ($isHidden: true)",
			$isHidden: true
		},
		propBooleanDisabled: {
			$type: "application/x-boolean",
			$isMandatory: false,
			$title: "Boolean ($isDisabled: true)",
			$isDisabled: true
		},

		propChoice: {
			$type: "application/x-choice",
			$isMandatory: false,
			$title: "Choice",
			//$format: "$radios",
			$value: {
				$enum: [{
					$title: "Mr.",
					$value: "mr"
				}, {
					$title: "Mrs.",
					$value: "mrs"
				}],
				$type: "application/x-string"
			}
		},
		propChoiceHidden: {
			$type: "application/x-choice",
			$isMandatory: false,
			$title: "Choice($isHidden: true)",
			$isHidden: true,
			//$format: "$radios",
			$value: {
				$enum: [{
					$title: "Mr.",
					$value: "mr"
				}, {
					$title: "Mrs.",
					$value: "mrs"
				}],
				$type: "application/x-string"
			}
		},
		propChoiceDisabled: {
			$type: "application/x-choice",
			$isMandatory: false,
			$title: "Choice ($isDisabled: true)",
			$isDisabled: true,
			//$format: "$radios",
			$value: {
				$enum: [{
					$title: "Mr.",
					$value: "mr"
				}, {
					$title: "Mrs.",
					$value: "mrs"
				}],
				$type: "application/x-string"
			}
		},
		propQuantity: {
			$title: "Quantity ($unit $isExcluded: false)",
			$type: "application/x-quantity",
			$value: {
				$title: "{$value} {$unit}",
				$type: "application/x-decimal",
				$scale: 9,
				$precision: 2,
				$format: "0.00"
			},
			$unit: "propStringUnit"
		},
		propStringUnit: {
			$type: "application/x-string",
			$isMandatory: false,
			$isExcluded: false,
			$title: "Unit for quantity ($isExcluded: false)"
		},
		propQuantityExcluded: {
			$title: "Quantity($unit $isExcluded: true)",
			$type: "application/x-quantity",
			$value: {
				$title: "{$value} {$unit}",
				$type: "application/x-decimal",
				$scale: 9,
				$precision: 2,
				$format: "0.00"
			},
			$unit: "propStringUnitExcluded"
		},
		propStringUnitExcluded: {
			$type: "application/x-string",
			$isMandatory: false,
			$isExcluded: true,
			$title: "Unit for quantity ($isExcluded: true)"
		}

	},
	$relations: {},
	$articles: {},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			// template when creating a new record
			var i = 15;
			var tpl = {
				$uuid: "" + i,
				propString: "Simple String=" + i,
				propDate: "2014-03-" + i,
				propDateTime: "2014-06-" + i + "T12:45:" + (i + 44) + ".234Z",
				propTime: "15:45:" + (i + 34),
				propInt: (i * 1000 + i * 10),
				propDecimal: Math.sqrt(i * 1000 + i * 10),
				propReal: Math.sqrt(i * 1000 + i * 30),
				propBoolean: (_switch = !_switch)
			};

			deferred.resolve(tpl);
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			// only works because op.$key is equal the array index and equal the $uuid
			deferred.resolve(_data[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testGaugeChart',['require','exports','module'],function (require, exports, module) {"use strict";

var _data = {
	"salesOp": "75.0000000000",
	"salesValue": "133000.0000000000",
	"salesValueMin": "100000.0000000000",
	"salesValueMax": "150000.0000000000"
};

var _entity = {
	$entityName: "testGaugeChart",
	$properties: {
		"salesOp": {
			"$title": "sale opportunity",
			"$type": "application/x-decimal",
			"$capabilities": "sort,filter"
		},
		"salesValue": {
			"$title": "sales value",
			"$type": "application/x-decimal",
			"$capabilities": "sort,filter"
		},
		"salesValueMin": {
			"$title": "sales value min",
			"$type": "application/x-decimal",
			"$capabilities": "sort,filter"
		},
		"salesValueMax": {
			"$title": "sales value max",
			"$type": "application/x-decimal",
			"$capabilities": "sort,filter"
		}
	},
	$relations: {},
	$articles: {},
	$services: {
		$read: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve(_data);
			return deferred.promise();
		}
	}
};

exports.entity = _entity;
});

define('syracuse-tablet/html/js/demos/clientTestApp/testHomeDashboard',['require','exports','module'],function (require, exports, module) {"use strict";
exports.dashboards = {
	"testHomeDashboard": {
		"$dashboardName": "testHomeDashboard",
		"$title": "Main test dashboard",
		"$description": "This dashboard links to different dashboards used for every kind of UI tests",
		"$vignettes": {
			"testLayoutsDashboard": {
				"$uuid": "testLayoutsDashboard",
				"$displayStyle": "$link"
			},
			"testTypesDashboard": {
				"$uuid": "testTypesDashboard",
				"$displayStyle": "$link"
			},
			"testTypesDashboard2": {
				"$uuid": "testTypesDashboard2",
				"$displayStyle": "$link"
			},
			"testFormatsDashboard": {
				"$uuid": "testFormatsDashboard",
				"$displayStyle": "$link"
			},
			"testGX3APPDashboard": {
				"$uuid": "testGX3APPDashboard",
				"$displayStyle": "$link"
			},
			"testSUPERVDashboard": {
				"$uuid": "testSUPERVDashboard",
				"$displayStyle": "$link"
			},
			"testChartsHubDashboard": {
				"$uuid": "testChartsHubDashboard",
				"$displayStyle": "$link"
			},
			"testChartsStackDashboard": {
				"$uuid": "testChartsStackDashboard",
				"$displayStyle": "$link"
			},
			"testSUPERVDashboard2": {
				"$uuid": "testSUPERVDashboard2",
				"$displayStyle": "$link"
			},
			"testGX3APPDashboard2": {
				"$uuid": "testGX3APPDashboard2",
				"$displayStyle": "$link"
			},
			"testConstraintsDashboard": {
				"$uuid": "testConstraintsDashboard",
				"$displayStyle": "$link"
			},
			"testPropertyHideShowDashboard": {
				"$uuid": "testPropertyHideShowDashboard",
				"$displayStyle": "$link"
			},
			"testAQTACTNPDashboard": {
				"$uuid": "testAQTACTNPDashboard",
				"$displayStyle": "$link"
			},
			"testQAQTGRAPDashboard": {
				"$uuid": "testQAQTGRAPDashboard",
				"$displayStyle": "$link"
			},
			"testSTATISTICDashboard": {
				"$uuid": "testSTATISTICDashboard",
				"$displayStyle": "$link"
			},
			"testAQMPROJECTMDashboard": {
				"$uuid": "testAQMPROJECTMDashboard",
				"$displayStyle": "$link"
			},
			"testAQMOPERATMDashboard": {
				"$uuid": "testAQMOPERATMDashboard",
				"$displayStyle": "$link"
			},

			"testAQMINTIMESMDashboard": {
				"$uuid": "testAQMINTIMESMDashboard",
				"$displayStyle": "$link"
			},
			"testGaugeChartDashboard": {
				"$uuid": "testGaugeChartDashboard",
				"$displayStyle": "$link"
			},
			"testExternalLink": {
				"$uuid": "testExternalLink",
				"$displayStyle": "$link"
			},
			"testGridDashboard": {
				"$uuid": "testGridDashboard",
				"$displayStyle": "$link"
			},
			"testDefaultAQTCRUDM": {
				"$uuid": "testDefaultAQTCRUDM",
				"$displayStyle": "$link"
			},
			"testDefaultAQMCRUDM": {
				"$uuid": "testDefaultAQMCRUDM",
				"$displayStyle": "$link"
			},
			"testDefaultAQMFIELDSM": {
				"$uuid": "testDefaultAQMFIELDSM",
				"$displayStyle": "$link"
			},
			"testDefaultAQMSEARCHM": {
				"$uuid": "testDefaultAQMSEARCHM",
				"$displayStyle": "$link"
			},
			"unitTestsDashboard": {
				"$uuid": "unitTestsDashboard",
				"$displayStyle": "$link"
			},
			"testAQMBLOBM": {
				"$uuid": "testAQMBLOBM",
				"$displayStyle": "$link"
			},
			"testAQMCLOBM": {
				"$uuid": "testAQMCLOBM",
				"$displayStyle": "$link"
			},
			"testAUTILISM": {
				"$uuid": "testAUTILISM",
				"$displayStyle": "$link"
			},
			// UI TEST VIGNETTES
			"testAutoUI_ContextDashboard": {
				"$uuid": "testAutoUI_ContextDashboard",
				"$displayStyle": "$link"
			},
			"testAutoUI_AQMDEVICE_Query": {
				"$uuid": "testAutoUI_AQMDEVICE_Query",
				"$displayStyle": "$link"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Client only",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "purple",
					"$items": [{
						"$bind": "testLayoutsDashboard"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "testFormatsDashboard"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "testTypesDashboard"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$bgColor": "medium-grey",
					"$items": [{
						"$bind": "testConstraintsDashboard",
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$title": "Test title",
					"$icon": "adjust",
					"$items": [{
						"$bind": "testChartsHubDashboard"
					}],
					"$size": "medium"
				}, {
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$title": "Test title",
					"$icon": "adjust",
					"$items": [{
						"$bind": "testChartsStackDashboard"
					}],
					"$size": "medium"
				}, {
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$items": [{
						"$bind": "testPropertyHideShowDashboard"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$items": [{
						"$bind": "testGaugeChartDashboard"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$items": [{
						"$bind": "testExternalLink"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$bgColor": "alert",
					"$items": [{
						"$bind": "unitTestsDashboard"
					}],
					"$size": "medium"
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "SUPERV endpoint",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "green",
					"$items": [{
						"$bind": "testSUPERVDashboard"
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$items": [{
						"$bind": "testGridDashboard"
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "GX3APP endpoint",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "blue",
					"$items": [{
						"$bind": "testGX3APPDashboard"
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$items": [{
						"$bind": "testGX3APPDashboard2"
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Tests LAM",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "purple",
					"$items": [{
						"$bind": "testQAQTGRAPDashboard"
					}],
				}, {
					"$layoutType": "tile",
					"$bgColor": "green",
					"$items": [{
						"$bind": "testAQMPROJECTMDashboard"
					}],
				}, {
					"$layoutType": "tile",
					"$bgColor": "purple",
					"$items": [{
						"$bind": "testAQMOPERATMDashboard"
					}],
				}, {
					"$layoutType": "tile",
					"$bgColor": "purple",
					"$items": [{
						"$bind": "testAQMINTIMESMDashboard"
					}],
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Default endpoint",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "mediumgrey",
					"$items": [{
						"$bind": "testAQTACTNPDashboard"
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "testTypesDashboard2",
					}],
					"$size": "medium"
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$items": [{
						"$bind": "testDefaultAQTCRUDM"
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$items": [{
						"$bind": "testDefaultAQMCRUDM"
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$items": [{
						"$bind": "testDefaultAQMFIELDSM"
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$items": [{
						"$bind": "testDefaultAQMSEARCHM"
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$items": [{
						"$bind": "testAQMBLOBM"
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$items": [{
						"$bind": "testAQMCLOBM"
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$items": [{
						"$bind": "testAUTILISM"
					}]
				}]

			}, {
				/*
				 * Test pages for automated us tests to make you aware when changing them
				 */
				"$layoutType": "hubGroup",
				"$title": "Automated tests",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "blue",
					"$size": "small",
					"$items": [{
						"$bind": "testAutoUI_ContextDashboard"
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "blue",
					"$size": "small",
					"$items": [{
						"$bind": "testAutoUI_AQMDEVICE_Query"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testLayoutsDashboard": {
		"$type": "$dashboard",
		"$title": "Layout tests",
		"$description": "Layout tests",
		"dashboardName": "testLayoutsDashboard"
	},
	"testTypesDashboard": {
		"$type": "$dashboard",
		"$title": "Datatype tests",
		"$description": "Datatype tests",
		"dashboardName": "testTypesDashboard"
	},
	"testTypesDashboard2": {
		"$type": "$dashboard",
		"$title": "Datatype AQTCRUD",
		"$description": "Datatype AQTCRUD",
		"dashboardName": "testTypesDashboard2"
	},
	"testFormatsDashboard": {
		"$type": "$dashboard",
		"$title": "Formats tests",
		"$description": "Formats tests",
		"dashboardName": "testFormatsDashboard"
	},
	"testGX3APPDashboard": {
		"$type": "$dashboard",
		"$title": "GX3APP tests",
		"$description": "GX3APP tests",
		"dashboardName": "testGX3APPDashboard"
	},
	"testSUPERVDashboard": {
		"$type": "$dashboard",
		"$title": "SUPERV tests",
		"$description": "SUPERV tests",
		"dashboardName": "testSUPERVDashboard"
	},
	"testChartsHubDashboard": {
		"$type": "$dashboard",
		"$title": "Charts tests (hub)",
		"$description": "Charts tests (hub)",
		"dashboardName": "testChartsHubDashboard"
	},
	"testChartsStackDashboard": {
		"$type": "$dashboard",
		"$title": "Charts tests (stack)",
		"$description": "Charts tests  (stack)",
		"dashboardName": "testChartsStackDashboard"
	},
	"testSUPERVDashboard2": {
		"$type": "$dashboard",
		"$title": "AQMCRUDM",
		"$description": "AQMCRUDM default endpoint",
		"dashboardName": "testSUPERVDashboard2"
	},
	"testGX3APPDashboard2": {
		"$type": "$dashboard",
		"$title": "GX3APP Cost",
		"$description": "GX3APP Cost",
		"dashboardName": "testGX3APPDashboard2"
	},
	"testConstraintsDashboard": {
		"$type": "$dashboard",
		"$title": "SData constraints",
		"$description": "SData constraints",
		"dashboardName": "testConstraintsDashboard"
	},
	"testPropertyHideShowDashboard": {
		"$type": "$dashboard",
		"$title": "Property Hide Show",
		"$description": "Dashboard PropertyHideShow",
		"dashboardName": "testPropertyHideShowDashboard"
	},
	"testAQTACTNPDashboard": {
		"$type": "$dashboard",
		"$title": "AQTACTNP Create facet",
		"$description": "AQTACTNP Create facet",
		"dashboardName": "testAQTACTNPDashboard"
	},
	"testQAQTGRAPDashboard": {
		"$type": "$dashboard",
		"$title": "test QAQTGRAP",
		"$description": "test QAQTGRAP ",
		"dashboardName": "testQAQTGRAPDashboard"
	},
	"testSTATISTICDashboard": {
		"$type": "$dashboard",
		"$title": "test STATISTIC",
		"$description": "test STATISTIC",
		"dashboardName": "testSTATISTICDashboard"
	},
	"testAQMPROJECTMDashboard": {
		"$type": "$dashboard",
		"$title": "test AQMPROJECTM",
		"$description": "test AQMPROJECTM",
		"dashboardName": "testAQMPROJECTMDashboard"
	},

	"testAQMOPERATMDashboard": {
		"$type": "$dashboard",
		"$title": "test AQMOPERATM",
		"$description": "test AQMOPERATM",
		"dashboardName": "testAQMOPERATMDashboard"
	},

	"testAQMINTIMESMDashboard": {
		"$type": "$dashboard",
		"$title": "test AQMINTIMESM",
		"$description": "test AQMINTIMESM",
		"dashboardName": "testAQMINTIMESMDashboard"
	},

	"testGaugeChartDashboard": {
		"$type": "$dashboard",
		"$title": "Test gauge chart",
		"$description": "Test gauge chart",
		"dashboardName": "testGaugeChartDashboard"
	},
	"testExternalLink": {
		"$type": "$external",
		"$title": "Test external link",
		"$description": "Test external link",
		"externalUrl": "http://sage.com"
	},
	"unitTestsDashboard": {
		"$type": "$dashboard",
		"$title": "Unit tests",
		"$description": "Unit tests",
		"dashboardName": "unitTestsDashboard"
	},
	"testGridDashboard": {
		"$type": "$dashboard",
		"$title": "Test grid authoring",
		"$description": "Test grid authoring",
		"dashboardName": "testGridDashboard"
	},
	"testDefaultAQTCRUDM": {
		"$type": "$dashboard",
		"$title": "AQTCRUDM",
		"$description": "Test AQTCRUDM",
		"dashboardName": "testDefaultAQTCRUDM"
	},
	"testDefaultAQMCRUDM": {
		"$type": "$dashboard",
		"$title": "AQMCRUDM",
		"$description": "Test AQMCRUDM",
		"dashboardName": "testDefaultAQMCRUDM"
	},
	"testDefaultAQMFIELDSM": {
		"$type": "$dashboard",
		"$title": "AQMFIELDSM",
		"$description": "Test AQMFIELDSM",
		"dashboardName": "testDefaultAQMFIELDSM"
	},
	"testDefaultAQMSEARCHM": {
		"$type": "$dashboard",
		"$title": "AQMSEARCHM",
		"$description": "Test AQMSEARCHM",
		"dashboardName": "testDefaultAQMSEARCHM"
	},
	"testAQMBLOBM": {
		"$type": "$representation",
		"$title": "AQMBLOBM",
		"action": "$query",
		"representation": "AQMBLOBM",
		"facet": "$query"
	},
	"testAQMCLOBM": {
		"$type": "$representation",
		"$title": "AQMCLOBM",
		"action": "$query",
		"representation": "AQMCLOBM",
		"facet": "$query"
	},
	"testAUTILISM": {
		"$type": "$representation",
		"$title": "AUTILISM",
		"action": "$query",
		"representation": "AUTILISM",
		"facet": "$query"
	},

	// Auto UI Test gadgets
	"testAutoUI_ContextDashboard": {
		"$type": "$dashboard",
		"$title": "Dashboard with context",
		"$description": "Dashboard with context",
		"dashboardName": "testContextDashboard"
	},
	"testAutoUI_AQMDEVICE_Query": {
		"$type": "$representation",
		"$title": "AQMCRUDM",
		"entity": "AQMDEVICE",
		"action": "$query",
		"representation": "AQMCRUDM",
		"facet": "$query",
		"endpoint": "x3.erp.SUPERV"
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testLayoutsDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testLayoutsDashboard": {
		"$dashboardName": "testLayoutsDashboard",
		"$title": "Layout test dashboard",
		"$description": "Test different kinds of layouts",
		"$vignettes": {
			"testLayoutHubDashboard": {
				"$uuid": "testLayoutHubDashboard",
				"$displayStyle": "$link"
			},
			"testLayoutRowsDashboard": {
				"$uuid": "testLayoutRowsDashboard",
				"$displayStyle": "$link"
			},
			"testLongQuery": {
				"$uuid": "testLongQuery",
				"$displayStyle": "$link"
			},
			"testHubLayoutEntity": {
				"$uuid": "testHubLayoutEntity",
				"$displayStyle": "$link"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLayoutHubDashboard"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLayoutRowsDashboard"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLongQuery"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testHubLayoutEntity"
					}]
				}]
			}]
		}
	},
	"testLayoutHubDashboard": {
		"$dashboardName": "testLayoutHubDashboard",
		"$title": "Hub dashboard (scroll horizontal)",
		"$description": "Horizontal scrolling dashboard",
		"$vignettes": {
			"testDummyTile": {
				"$uuid": "testDummyTile",
				"$displayStyle": "$full"
			},
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Layout group 1",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$items": [{
						"$bind": "testDummyTile",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "name",
							}, {
								"$bind": "name",
								"$labelPosition": "left"
							}, {
								"$bind": "desc",
								"$labelPosition": "top"
							}, {
								"$bind": "desc2",
								"$labelPosition": "right"
							}, {
								"$bind": "desc2",
								"$labelAlign": "right"
							}, {
								"$bind": "amount",
								"$labelPosition": "bottom"
							}, {
								"$bind": "amount",
								"$isTitleHidden": true
							}]
						}
					}],
					"$size": "full" // as wide as a column, as high as the screen (rounded/snapped to the next "medium" size tile coordinates)
				}, {
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "medium" // square, half the width of a column
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "small" // square, quarter size of a column
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bgColor": "darkgrey",
						"$bind": "testDummyTile"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$bgColor": "skyblue",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "wide" // fill width of a column, and half the height of the width
				}, {
					"$layoutType": "tile",
					"$bgColor": "orange",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "large" // square, width and heigth as big as a column
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Layout group 2",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "blue",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "medium",
				}, {
					"$layoutType": "tile",
					"$bgColor": "mediumgrey",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "medium",
				}, {
					"$layoutType": "tile",
					"$bgColor": "green",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "medium",
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Layout group 3",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "wide"
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "medium"
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "medium"
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Layout group 4",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "large"
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "medium"
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "medium"
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Layout group 5",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "wide"
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "full"
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "small",
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "small"
				}]
			}]
		}
	},
	"testLayoutRowsDashboard": {
		"$dashboardName": "testLayoutRowsDashboard",
		"$title": "Row layout dashboard (scroll vertical)",
		"$description": "Vertical scrolling dashboard",
		"$vignettes": {
			"testDummyTile": {
				"$uuid": "testDummyTile",
				"$displayStyle": "$full"
			},
			"testDummyTileLink": {
				"$uuid": "testDummyTile",
				"$displayStyle": "$link"
			},
		},
		"$article": {
			"$layoutType": "stack",
			"$localization": {
				"en-US": {
					"67bfa0d4-958f-4929-9bd4-05a248e594c4": "On tablet portrait mode, this shows 4 cells in a line. On Mini-Tablet landscape (Nexus7) it shows three ons one cell per line. On Tablet landscape, it 2 per line. On phone or smaller its one per line"
				}
			},
			"$items": [{
				"$layoutType": "stack",
				"$title": "{@67bfa0d4-958f-4929-9bd4-05a248e594c4}",
				"$items": [{
					"$layoutType": "row",
					"$items": [{
						"$layoutType": "cell",
						"$widthLg": "3",
						"$widthSm": "6",
						"$widthXs": "12",
						"$widthMd": "4",
						"$items": [{
							"$layoutType": "stack",
							"$items": [{
								"$bind": "testDummyTileLink",
								"$article": {}
							}]
						}]
					}, {
						"$layoutType": "cell",
						"$widthLg": "3",
						"$widthSm": "6",
						"$widthXs": "12",
						"$widthMd": "4",
						"$items": [{
							"$layoutType": "stack",
							"$items": [{
								"$bind": "testDummyTileLink",
								"$article": {}
							}]
						}]
					}, {
						"$layoutType": "cell",
						"$widthLg": "3",
						"$widthSm": "6",
						"$widthXs": "12",
						"$widthMd": "4",
						"$items": [{
							"$layoutType": "stack",
							"$items": [{
								"$bind": "testDummyTileLink",
								"$article": {}
							}]
						}]
					}, {
						"$layoutType": "cell",
						"$widthLg": "3",
						"$widthSm": "6",
						"$widthXs": "12",
						"$widthMd": "12",
						"$items": [{
							"$layoutType": "stack",
							"$items": [{
								"$bind": "testDummyTileLink",
								"$article": {}
							}]
						}]
					}]
				}]
			}, {
				"$layoutType": "stack",
				"$items": [{
					"$layoutType": "row",
					"$items": [{
						"$layoutType": "cell",
						"$widthLg": "6",
						"$widthSm": "6",
						"$widthXs": "12",
						"$items": [{
							"$bind": "testDummyTile",
							"$article": {
								"$layoutType": "stack",
								"$items": [{
									"$bind": "name"
								}, {
									"$bind": "desc"
								}, {
									"$bind": "desc2"
								}, {
									"$bind": "amount"
								}]
							}
						}]
					}, {
						"$layoutType": "cell",
						"$widthLg": "6",
						"$widthSm": "6",
						"$widthXs": "12",
						"$items": [{
							"$bind": "testDummyTile",
							"$article": {
								"$layoutType": "stack",
								"$items": [{
									"$bind": "name"
								}, {
									"$bind": "desc"
								}, {
									"$bind": "desc2"
								}, {
									"$bind": "amount"
								}]
							}
						}]
					}, {
						"$layoutType": "cell",
						"$items": [{
							"$widthLg": "3",
							"$widthSm": "4",
							"$widthXs": "12",
							"$bind": "testDummyTile",
							"$article": {
								"$layoutType": "stack",
								"$items": [{
									"$bind": "name"
								}, {
									"$bind": "desc"
								}, {
									"$bind": "desc2"
								}, {
									"$bind": "amount"
								}]
							}
						}]
					}, {
						"$layoutType": "cell",
						"$items": [{
							"$widthLg": "3",
							"$widthSm": "12",
							"$widthXs": "12",
							"$bind": "testDummyTile",
							"$article": {
								"$layoutType": "stack",
								"$items": [{
									"$bind": "name"
								}, {
									"$bind": "desc"
								}, {
									"$bind": "desc2"
								}, {
									"$bind": "amount"
								}]
							}
						}]
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testLayoutHubDashboard": {
		"$type": "$dashboard",
		"$title": "Hub Layout tests",
		"$description": "Hub Layout tests",
		"dashboardName": "testLayoutHubDashboard"
	},
	"testLayoutRowsDashboard": {
		"$type": "$dashboard",
		"$title": "Rows Layout tests",
		"$description": "Rows Layout tests",
		"dashboardName": "testLayoutRowsDashboard"
	},
	"testDummyTile": {
		"$type": "$representation",
		"$title": "Dummy",
		"$description": "Dummy",
		"entity": "example",
		"action": "$details",
		"representation": "example",
		"facet": "$details",
		"keyParameter": "5"
	},
	"testLongQuery": {
		"$type": "$representation",
		"$title": "Long query",
		"$description": "Query",
		"entity": "example",
		"action": "$query",
		"representation": "example",
		"facet": "$query"
	},
	"testHubLayoutEntity": {
		"$type": "$representation",
		"$title": "Hub Layout on Representation",
		"$description": "Hub Layout on Representation",
		"entity": "exampleHubLayout",
		"action": "$details",
		"representation": "exampleHubLayout",
		"facet": "$details",
		"keyParameter": "5"
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testTypesDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testTypesDashboard": {
		"$dashboardName": "testTypesDashboard",
		"$title": "Datatypes test dashboard",
		"$description": "Test different kinds of datatypes",
		"$vignettes": {
			"testLinkQueryRecord": {
				"$uuid": "testDisplayQueryRecord",
				"$displayStyle": "$link"
			},
			"testLinkDetailsRecord": {
				"$uuid": "testDisplayDetailsRecord",
				"$displayStyle": "$link"
			},
			"testLinkEditRecord": {
				"$uuid": "testDisplayEditRecord",
				"$displayStyle": "$link"
			},
			"testLinkCreateRecord": {
				"$uuid": "testDisplayCreateRecord",
				"$displayStyle": "$link"
			},
			"testDisplayQueryRecord": {
				"$uuid": "testDisplayQueryRecord",
				"$displayStyle": "$full"
			},
			"testDisplayDetailsRecord": {
				"$uuid": "testDisplayDetailsRecord",
				"$displayStyle": "$full"
			},
			"testDisplayEditRecord": {
				"$uuid": "testDisplayEditRecord",
				"$displayStyle": "$full"
			},
			"testDisplayCreateRecord": {
				"$uuid": "testDisplayCreateRecord",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkQueryRecord"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkDetailsRecord"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkEditRecord"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkCreateRecord"
					}]
				}]
			}, {
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayQueryRecord"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayDetailsRecord"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayEditRecord"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayCreateRecord"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testDisplayDetailsRecord": {
		"$type": "$representation",
		"$title": "Details facet",
		"entity": "testDataTypes",
		"action": "$details",
		"representation": "testDataTypes",
		"facet": "$details",
		"keyParameter": "5"
	},
	"testDisplayEditRecord": {
		"$type": "$representation",
		"$title": "Edit facet",
		"entity": "testDataTypes",
		"action": "$edit",
		"representation": "testDataTypes",
		"facet": "$edit",
		"keyParameter": "5"
	},
	"testDisplayCreateRecord": {
		"$type": "$representation",
		"$title": "Create facet",
		"entity": "testDataTypes",
		"action": "$create",
		"representation": "testDataTypes",
		"facet": "$create",
		"keyParameter": "5"
	},
	"testDisplayQueryRecord": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "testDataTypes",
		"action": "$query",
		"representation": "testDataTypes",
		"facet": "$query",
		"keyParameter": "5"
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testFormatsDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testFormatsDashboard": {
		"$dashboardName": "testFormatsDashboard",
		"$title": "Formatting test dashboard",
		"$description": "Test different kinds of formats",
		"$vignettes": {
			"testFormatEditRecord": {
				"$uuid": "testFormatEditRecord",
				"$displayStyle": "$full"
			},
			"testFormatReferenceDetail": {
				"$uuid": "testFormatReferenceDetail",
				"$displayStyle": "$full"
			},
			"testFormatReferenceEdit": {
				"$uuid": "testFormatReferenceEdit",
				"$displayStyle": "$full"
			},
			"testFormatReferenceQuery": {
				"$uuid": "testFormatReferenceQuery",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testFormatEditRecord"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testFormatReferenceDetail"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testFormatReferenceEdit"
					}]
				}]
			}, {
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testFormatReferenceQuery"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testFormatEditRecord": {
		"$type": "$representation",
		"$title": "Details facet",
		"entity": "testFormats",
		"action": "$edit",
		"representation": "testFormats",
		"facet": "$edit",
		"keyParameter": "5"
	},
	"testFormatReferenceDetail": {
		"$type": "$representation",
		"$title": "Details facet reference fields",
		"entity": "testFormatsReference",
		"action": "$details",
		"representation": "testFormatsReference",
		"facet": "$details",
		"keyParameter": "5"
	},
	"testFormatReferenceEdit": {
		"$type": "$representation",
		"$title": "Edit facet reference fields",
		"entity": "testFormatsReference",
		"action": "$edit",
		"representation": "testFormatsReference",
		"facet": "$edit",
		"keyParameter": "5"
	},
	"testFormatReferenceQuery": {
		"$type": "$representation",
		"$title": "Query facet reference fields",
		"entity": "testFormatsReference",
		"action": "$query",
		"representation": "testFormatsReference",
		"facet": "$query",
		"keyParameter": "5"
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testGX3APPDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testGX3APPDashboard": {
		"$dashboardName": "testGX3APPDashboard",
		"$title": "Display data from GX3APP",
		"$description": "Test different representations on GX3APP",
		"$vignettes": {
			"testACTIVQuery": {
				"$uuid": "testACTIVQuery",
				"$displayStyle": "$full"
			},
			"testRequestVEN085": {
				"$uuid": "testRequestVEN085",
				"$displayStyle": "$full"
			}
		},

		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Some data...",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testACTIVQuery"
					}],
					"$size": "full"
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Some fancy chart",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestVEN085"
					}],
					"$size": "large"
				}]
			}]
		},
	}
};

exports.gadgets = {
	"testACTIVQuery": {
		"$type": "$representation",
		"$title": "Query ACTIV",
		"entity": "ACTIV",
		"action": "$query",
		"representation": "ACTIV",
		"endpoint": "x3.erp.GX3APP",
		"facet": "$query"
	},
	"testRequestVEN085": {
		"$type": "$request",
		"$title": "Request VEN085",
		"requestName": "VEN085",
		"requestLevel": "1",
		"action": "$query",
		"endpoint": "x3.erp.GX3APP",
		"facet": "$query"
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testSUPERVDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

var _detailLinkArticle = {
	"$layoutType": "stack",
	"$title": "Test collapsed",
	"$collapsible": "collapsed",
	"$items": [{
		"$layoutType": "row",
		"$items": [{
			"$layoutType": "cell",
			"$widthXs": "6",
			"$widthSm": "6",
			"$widthMd": "6",
			"$widthLg": "6",
			"$bgColor": "sagegreen",
			"$items": [{
				"$bind": "MODULE"
			}, {
				"$bind": "UPDUSR_REF"
			}, {
				"$bind": "CREUSR_REF"
			}, {
				"$bind": "UNIT_REF"
			}, {
				"$bind": "TDCB2"
			}, {
				"$bind": "SITE_REF"
			}, {
				"$bind": "QTY",
				"$numDisplay": "normal"
			}, {
				"$bind": "WCUR_REF"
			}, {
				"$bind": "TEL"
			}, {
				"$bind": "TEXTAXX"
			}, {
				"$bind": "TDCB",
				"$items": [{
					"$bind": "WCUR_REF"
				}]
			}, {
				"$bind": "TEL"
			}, {
				"$bind": "TDATE"
			}]
		}, {
			"$layoutType": "cell",
			"$widthXs": "6",
			"$widthSm": "6",
			"$widthMd": "6",
			"$widthLg": "6",
			"$bgColor": "orange",
			"$items": [{
				"$bind": "CODE"
			}, {
				"$bind": "CODECHR"
			}, {
				"$bind": "TEXTDES0"
			}, {
				"$bind": "TEXTE"
			}, {
				"$bind": "CRY_REF"
			}, {
				"$bind": "CPY_REF"
			}, {
				"$bind": "CUR_REF"
			}, {
				"$bind": "TYPEATT"
			}, {
				"$bind": "HIDEWHOW"
			}, {
				"$bind": "EMAIL"
			}, {
				"$bind": "TEXTAXX"
			}, {
				"$bind": "TDCB3"
			}, {
				"$bind": "DIVERS0"
			}, {
				"$bind": "TPOSIF"
			}]
		}]
	}, {
		"$layoutType": "stack",
		"$title": "Test collapsed",
		"$collapsible": "collapsed",
		"$items": [{
			"$layoutType": "row",
			"$items": [{
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "6",
				"$widthMd": "6",
				"$widthLg": "6",
				"$items": [{
					"$bind": "PBLOB"
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "6",
				"$widthMd": "6",
				"$widthLg": "6",
				"$items": [{
					"$bind": "PBLOB2"
				}]
			}]
		}]
	}, {
		"$layoutType": "stack",
		"$collapsible": "expanded",
		"$title": "Test collapsible",
		"$items": [{
			"$layoutType": "row",
			"$items": [{
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "6",
				"$widthMd": "6",
				"$widthLg": "6",
				"$items": [{
					"$bind": "ADEVCOLREF2",
					"$article": {}
				}, {
					"$bind": "ADEVADEVCOL1",
					"$article": {}
				}, {
					"$bind": "ADEVTABL",
					"$article": {}
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "6",
				"$widthMd": "6",
				"$widthLg": "6",
				"$items": [{
					"$bind": "ADEVCOLREF1",
					"$article": {}
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "6",
				"$widthMd": "6",
				"$widthLg": "6",
				"$items": [{
					"$bind": "ADEVCTINT",
					"$article": {}
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "6",
				"$widthMd": "6",
				"$widthLg": "6",
				"$items": [{
					"$bind": "ADEVTABDATE",
					"$article": {}
				}]
			}]
		}]
	}, {
		"$layoutType": "stack",
		"$title": "Test collapsible",
		"$collapsible": "expanded",
		"$items": [{
			"$layoutType": "row",
			"$items": [{
				"$layoutType": "cell",
				"$items": [{
					"$bind": "ADEVADEVICEL",
					"$display": "card",
					"$article": {}
				}]
			}]
		}]
	}, {
		"$layoutType": "stack",
		"$collapsible": "expanded",
		"$title": "Test collapsible",
		"$items": [{
			"$layoutType": "row",
			"$items": [{
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "6",
				"$widthMd": "6",
				"$widthLg": "6",
				"$items": [{
					"$bind": "PCLOB"
				}, {
					"$bind": "TEXTHTML",
					"$labelPosition": "top"
				}, {
					"$bind": "TYEPACD",
					"$labelPosition": "top"
				}, {
					"$bind": "TYEPACB"
				}, {
					"$bind": "TEXTRTF",
					"$labelPosition": "top"
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "6",
				"$widthMd": "6",
				"$widthLg": "6",
				"$items": [{
					"$bind": "TEXTHTML",
					"$labelPosition": "top"
				}, {
					"$bind": "TYEPACD",
					"$labelPosition": "top"
				}, {
					"$bind": "TEXTPLAIN",
					"$labelPosition": "top"
				}]
			}]
		}]
	}]
};
var _queryLinkArticle = {
	"$layoutType": "stack",
	"$items": [{
		"$bind": "$resources",
		"$display": "table",
		"$detailLinkArticle": _detailLinkArticle,
		"$table": [{
			"$bind": "CODE",
			"$title": "Code",
			"$type": "application/x-integer",
			"$titleOrig": "{@5296}",
			"$widthType": "fixed",
			"$widthVal": 4
		}, {
			"$bind": "TEXTDES0",
			"$title": "Description",
			"$type": "application/x-string",
			"$titleOrig": "{@282}",
			"$widthType": "auto",
			"$widthVal": 0
		}, {
			"$bind": "CUR_REF",
			"$title": "Currency",
			"$type": "application/x-reference",
			"$titleOrig": "{@323}",
			"$widthType": "fixed",
			"$widthVal": 6,
			"$refDescPosition": "bottom"
		}, {
			"$bind": "TDATE",
			"$title": "Date",
			"$type": "application/x-date",
			"$titleOrig": "{@212}",
			"$widthType": "fixed",
			"$widthVal": 6
		}, {
			"$bind": "CPY_REF",
			"$title": "Company",
			"$type": "application/x-reference",
			"$titleOrig": "{@1343}",
			"$widthType": "fixed",
			"$widthVal": 6,
			"$refDescPosition": "bottom"
		}, {
			"$bind": "SITE_REF",
			"$title": "Site",
			"$type": "application/x-reference",
			"$titleOrig": "{@1344}",
			"$widthType": "fixed",
			"$widthVal": 6,
			"$refDescPosition": "bottom"
		}, {
			"$bind": "CRY_REF",
			"$title": "Country",
			"$type": "application/x-reference",
			"$titleOrig": "{@263}",
			"$widthType": "fixed",
			"$widthVal": 6,
			"$refDescPosition": "bottom"
		}, {
			"$bind": "TDCB2",
			"$title": "4-décimal",
			"$type": "application/x-decimal",
			"$titleOrig": "{@28715}",
			"$widthType": "fixed",
			"$widthVal": 6
		}, {
			"$bind": "UNIT_REF",
			"$title": "Unit",
			"$type": "application/x-reference",
			"$titleOrig": "{@2685}",
			"$widthType": "fixed",
			"$widthVal": 6,
		}],
		"$article": {}
	}]
};

exports.dashboards = {
	"testSUPERVDashboard": {
		"$dashboardName": "testSUPERVDashboard",
		"$title": "Display Query AQMCRUDM",
		"$description": "",
		"$vignettes": {
			"testAQMDEVICEQuery": {
				"$uuid": "testAQMDEVICEQuery",
				"$displayStyle": "$full"
			},
			"testAQMDEVICEQueryLink": {
				"$uuid": "testAQMDEVICEQuery",
				"$displayStyle": "$link"
			},
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$items": [{
					"$layoutType": "tile",
					"$title": "QUERY display in table mode 1",
					"$size": "full",
					"$items": [{
						"$bind": "testAQMDEVICEQuery",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$arrayOptions": {
									"showSortFilter": true
								},
								"$display": "table",
								"$queryLinkArticle": _queryLinkArticle,
								"$detailLinkArticle": _detailLinkArticle,
								"$table": [{
									"$bind": "CODE",
									"$widthType": "fixed",
									"$widthVal": "3"
								}, {
									"$bind": "TDATE",
									"$widthType": "fixed",
									"$widthVal": "4"
								}, {
									"$bind": "CUR_REF",
									"$widthType": "fixed",
									"$widthVal": "3",
									"$refDescPosition": "bottom"
								}, {
									"$bind": "CPY_REF",
									"$widthType": "fixed",
									"$widthVal": "3",
									"$refDescPosition": "none"
								}]
							}]
						}
					}]
				}, {
					"$layoutType": "tile",
					"$title": "QUERY display in table mode 2",
					"$size": "full",
					"$items": [{
						"$bind": "testAQMDEVICEQuery",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$arrayOptions": {
									"showSortFilter": true
								},
								"$display": "table",
								"$queryLinkArticle": _queryLinkArticle,
								"$detailLinkArticle": _detailLinkArticle,
								"$table": [{
									"$bind": "CODE",
									"$widthType": "fixed",
									"$widthVal": "3"
								}, {
									"$bind": "TDATE",
									"$widthType": "fixed",
									"$widthVal": "4"
								}, {
									"$bind": "CUR_REF",
									"$widthType": "fixed",
									"$widthVal": "3",
									"$refDescPosition": "bottom"
								}, {
									"$bind": "CPY_REF",
									"$widthType": "fixed",
									"$widthVal": "3",
									"$refDescPosition": "none"
								}]
							}]
						}
					}]
				}, {
					"$layoutType": "tile",
					"$title": "Open in card mode",
					"$size": "medium",
					"$items": [{
						"$bind": "testAQMDEVICEQueryLink",
						"$linkArticle": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$display": "card",
								"$detailLinkArticle": _detailLinkArticle,
								"$card": {
									"$layoutType": "stack",
									"$items": [{
										"$layoutType": "row",
										"$items": [{
											"$layoutType": "cell",
											"$widthXs": "6",
											"$widthSm": "6",
											"$widthMd": "6",
											"$widthLg": "6",
											"$bgColor": "sagegreen",
											"$items": [{
												"$bind": "MODULE"
											}, {
												"$bind": "UPDUSR_REF"
											}, {
												"$bind": "CREUSR_REF"
											}, {
												"$bind": "UNIT_REF"
											}, {
												"$bind": "TDCB2"
											}, {
												"$bind": "SITE_REF"
											}, {
												"$bind": "TDATE"
											}]
										}, {
											"$layoutType": "cell",
											"$widthXs": "6",
											"$widthSm": "6",
											"$widthMd": "6",
											"$widthLg": "6",
											"$bgColor": "orange",
											"$items": [{
												"$bind": "CODE"
											}, {
												"$bind": "CODECHR"
											}, {
												"$bind": "TEXTDES0"
											}, {
												"$bind": "TEXTE"
											}, {
												"$bind": "CRY_REF"
											}, {
												"$bind": "CPY_REF"
											}, {
												"$bind": "CUR_REF"
											}]
										}]
									}]
								},
								"$minWidth": 4
							}]
						}
					}]
				}, {
					"$layoutType": "tile",
					"$title": "Open in table mode",
					"$size": "medium",
					"$items": [{
						"$bind": "testAQMDEVICEQueryLink",
						"$linkArticle": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "table",
								"$detailLinkArticle": _detailLinkArticle,
								"$table": [{
									"$bind": "CODE",
									"$widthType": "fixed",
									"$widthVal": "5"
								}, {
									"$bind": "TDATE",
									"$widthType": "fixed",
									"$widthVal": "6"
								}, {
									"$bind": "CUR_REF",
									"$widthType": "fixed",
									"$widthVal": "3",
									"$refDescPosition": "none"
								}, {
									"$bind": "CPY_REF",
									"$widthType": "fixed",
									"$widthVal": "6",
									"$refDescPosition": "top"
								}, {
									"$bind": "SITE_REF",
									"$widthType": "fixed",
									"$widthVal": "10",
									"$refDescFormat": "titledesc",
									"$refDescPosition": "bottom"
								}, {
									"$bind": "TEXTDES0"
								}]
							}]
						}
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testAQMDEVICEQuery": {
		"$type": "$representation",
		"$title": "Query AQMCRUDM",
		"entity": "AQMDEVICE",
		"action": "$query",
		"representation": "AQMCRUDM",
		"facet": "$query"
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testChartsHubDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testChartsHubDashboard": {
		"$dashboardName": "testChartsHubDashboard",
		"$title": "Display charts (Hub)",
		"$description": "Test different kind of charts",
		"$vignettes": {
			"testRequestChart": {
				"$uuid": "testRequestChart",
				"$displayStyle": "$full"
			},
			"testRequestChart1": {
				"$uuid": "testRequestChart",
				"$displayStyle": "$full"
			},
			"testRequestChart2": {
				"$uuid": "testRequestChart",
				"$displayStyle": "$full"
			}
		},

		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Big chart (!)",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "bar" // default = stick = colum = bar chart
							}]
						}
					}],
					"$size": "full",

				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart1",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "bar"
							}]
						}
					}],
					"$size": "large",

				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Bar charts",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart2",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "stick" // default = stick = colum = bar chart
							}]
						}
					}],
					"$size": "large",

				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "bar"
							}]
						}
					}],
					"$size": "large",

				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Line charts",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "line"
							}]
						}
					}],
					"$size": "large",

				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "area"
							}]
						}
					}],
					"$size": "large",

				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Spline charts",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "spline"
							}]
						}
					}],
					"$size": "large",

				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "areaspline"
							}]
						}
					}],
					"$size": "large",

				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Pie chart",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "pie"
							}]
						}
					}],
					"$size": "large",

				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Test different sizes/legends",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$isLegendHidden": false,
								"$style": "line"
							}]
						}
					}],
					"$size": "large",

				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$isLegendHidden": true,
								"$style": "line"
							}]
						}
					}],
					"$size": "large",

				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$isLegendHidden": true,
								"$isXLabelHidden": true,
								"$isYLabelHidden": true,
								"$isXLabelsHidden": true,
								"$isYLabelsHidden": true,
								"$style": "line"
							}]
						}
					}],
					"$size": "wide",

				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$isLegendHidden": true,
								"$isXLabelHidden": true,
								"$isYLabelHidden": true,
								"$isXLabelsHidden": true,
								"$isYLabelsHidden": true,
								"$style": "bar"
							}]
						}
					}],
					"$size": "medium",
				}]
			}]
		},
	}
};

exports.gadgets = {
	"testRequestChart": {
		"$type": "$request",
		"$title": "Request test",
		"requestName": "testCharts",
		"requestLevel": "1",
		"action": "$query",
		"facet": "$query"
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testChartsStackDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testChartsStackDashboard": {
		"$dashboardName": "testChartsStackDashboard",
		"$title": "Display charts (stack)",
		"$description": "Test different kind of charts",
		"$vignettes": {
			"testRequestChart": {
				"$uuid": "testRequestChart",
				"$displayStyle": "$full"
			}
		},

		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "12",
					"$widthSm": "6",
					"$widthMd": "6",
					"$widthLg": "6",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is coming from this layout embedded in the dashboard */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "bar" // default = stick = colum = bar chart
							}]
						}
					}]

				}, {
					"$layoutType": "cell",
					"$widthXs": "12",
					"$widthSm": "6",
					"$widthMd": "6",
					"$widthLg": "6",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "bar"
							}]
						}
					}]
				}]
			}, {
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "12",
					"$widthSm": "6",
					"$widthMd": "6",
					"$widthLg": "6",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "stick" // default = stick = colum = bar chart
							}]
						}
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "12",
					"$widthSm": "6",
					"$widthMd": "6",
					"$widthLg": "6",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "bar"
							}]
						}
					}]
				}]
			}, {
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "12",
					"$widthSm": "6",
					"$widthMd": "6",
					"$widthLg": "6",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "line"
							}]
						}
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "12",
					"$widthSm": "6",
					"$widthMd": "6",
					"$widthLg": "6",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "area"
							}]
						}
					}]
				}]
			}, {
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "12",
					"$widthSm": "6",
					"$widthMd": "6",
					"$widthLg": "6",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "spline"
							}]
						}
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "12",
					"$widthSm": "6",
					"$widthMd": "6",
					"$widthLg": "6",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "areaspline"
							}]
						}
					}]
				}]
			}, {
				"$layoutType": "row",
				"$title": "Pie chart",
				"$items": [{
					"$layoutType": "cell",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "pie"
							}]
						}
					}]
				}]
			}, {
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "12",
					"$widthSm": "6",
					"$widthMd": "3",
					"$widthLg": "3",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$isLegendHidden": false,
								"$style": "line"
							}]
						}
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "12",
					"$widthSm": "6",
					"$widthMd": "3",
					"$widthLg": "3",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$isLegendHidden": true,
								"$style": "line"
							}]
						}
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "12",
					"$widthSm": "6",
					"$widthMd": "3",
					"$widthLg": "3",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$isLegendHidden": true,
								"$isXLabelHidden": true,
								"$isYLabelHidden": true,
								"$isXLabelsHidden": true,
								"$isYLabelsHidden": true,
								"$style": "line"
							}]
						}
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "12",
					"$widthSm": "6",
					"$widthMd": "3",
					"$widthLg": "3",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$isLegendHidden": true,
								"$isXLabelHidden": true,
								"$isYLabelHidden": true,
								"$isXLabelsHidden": true,
								"$isYLabelsHidden": true,
								"$style": "bar"
							}]
						}
					}]
				}]
			}]
		},
	}
};

exports.gadgets = { //testRequestChart already exported by testChartsHubDashboard
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testSUPERVDashboard2',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testSUPERVDashboard2": {
		"$dashboardName": "testSUPERVDashboard2",
		"$title": "AQMCRUDM default endpoint",
		"$description": "Test representation AQMCRUDM",
		"$vignettes": {
			"testAQTCRUDQuery": {
				"$uuid": "testAQTCRUDQuery",
				"$displayStyle": "$full"
			},
			"testAQTCRUDQueryLink": {
				"$uuid": "testAQTCRUDQuery",
				"$displayStyle": "$link"
			},
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$widthXs": "6,1",
				"$items": [{
					"$bind": "testAQTCRUDQuery"
				}, {
					"$bind": "testAQTCRUDQueryLink"
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testAQTCRUDQuery": {
		"$type": "$representation",
		"$title": "Query AQMCRUDM",
		"entity": "AQMCRUDM",
		"action": "$query",
		"representation": "AQMCRUDM",
		"facet": "$query"
	},
	"testAQTCRUDQueryLink": {
		"$type": "$representation",
		"$title": "Query 10 AQMCRUDM",
		"requestName": "10",
		"requestLevel": "1",
		"action": "$query",
		"facet": "$query"
	}

};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testGX3APPDashboard2',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testGX3APPDashboard2": {
		"$dashboardName": "testGX3APPDashboard2",
		"$title": "Display data from GX3APP",
		"$description": "Test PRPCOSTCTR representation on GX3APP",
		"$vignettes": {
			"testPRPCOSTCTRQuery": {
				"$uuid": "testPRPCOSTCTRQuery",
				"$displayStyle": "$full"
			}
		},

		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Some data Spending cost...",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testPRPCOSTCTRQuery"
					}],
					"$size": "full"
				}]

			}]
		},
	}
};
exports.gadgets = {
	"testPRPCOSTCTRQuery": {
		"$type": "$representation",
		"$title": "Query PRPCOSTCTR",
		"entity": "PRPCOSTCTR",
		"action": "$query",
		"representation": "PRPCOSTCTR",
		"endpoint": "x3.erp.GX3APP",
		"facet": "$query"
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testConstraintsDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testConstraintsDashboard": {
		"$dashboardName": "testConstraintsDashboard",
		"$title": "Constraints test dashboard",
		"$description": "Test SData constraints: https://github.com/Sage-ERP-X3/platform/wiki/Resource-Prototypes#type-constraints",
		"$vignettes": {
			"testConstraintsEditRecord": {
				"$uuid": "testConstraintsEditRecord",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "12",
					"$items": [{
						"$bind": "testConstraintsEditRecord"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testConstraintsEditRecord": {
		"$type": "$representation",
		"$title": "Edit facet",
		"entity": "testConstraints",
		"action": "$edit",
		"representation": "testConstraints",
		"facet": "$edit",
		"keyParameter": "5"
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testNavigateToDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testContextDashboard": {
		"$dashboardName": "testContextDashboard",
		"$title": "Test dashboard parameters",
		"$description": "Test navigation to a dashboard with parameters",
		"$vignettes": {
			"testRecordLinkToDashboard": {
				"$uuid": "testRecordLinkToDashboard",
				"$displayStyle": "$full"
			},
			"testRecordLinkToDashboardLink": {
				"$uuid": "testRecordLinkToDashboardLink",
				"$displayStyle": "$full"
			},
			"testRecordLinkToDashboardSUPERV": {
				"$uuid": "testRecordLinkToDashboardSUPERV",
				"$displayStyle": "$full"
			},
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testRecordLinkToDashboard"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testRecordLinkToDashboardLink"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testRecordLinkToDashboardSUPERV"
					}]
				}]
			}]
		}
	},
	"testContextDashboardChild": {
		"$dashboardName": "testContextDashboardChild",
		"$title": "Child dashboard",
		"$description": "Child dashboard getting parameters that are applied to the first to vignettes but not to the last one using the same representation to gather data",
		"$vignettes": {
			"testRecordWithContext1": {
				"$uuid": "testRecordWithContext",
				"$displayStyle": "$full"
			},
			"testRecordWithContext2": {
				"$uuid": "testRecordWithContext",
				"$displayStyle": "$full"
			},
			"testRecordWithoutContext": {
				"$uuid": "testRecordWithoutContext",
				"$displayStyle": "$full"
			},
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testRecordWithContext1"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testRecordWithContext2"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testRecordWithoutContext"
					}]
				}]
			}]
		}
	},
	"testContextDashboardChildSUPERV": {
		"$dashboardName": "testContextDashboardChildSUPERV",
		"$title": "Child dashboard",
		"$description": "Child dashboard getting parameters",
		"$vignettes": {
			"testRecordWithContextSUPERV": {
				"$uuid": "testRecordWithContextSUPERV",
				"$displayStyle": "$full"
			},
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "12",
					"$items": [{
						"$bind": "testRecordWithContextSUPERV"
					}]
				}]
			}]
		}
	}

};

exports.gadgets = {
	"testRecordLinkToDashboard": {
		"$type": "$representation",
		"$title": "Click to navigate",
		"entity": "testNavigateTo",
		"action": "$query",
		"representation": "testNavigateTo",
		"facet": "$query"
	},
	"testRecordWithContext": {
		"$type": "$representation",
		"$title": "Click to navigate",
		"entity": "testNavigateToChild",
		"action": "$query",
		"representation": "testNavigateToChild",
		"facet": "$query",
		"parameters": {
			"where": {
				"value": "group eq '{group}'"
			}
		}
	},
	"testRecordLinkToDashboardLink": {
		"$type": "$dashboard",
		"$title": "Open dashboard w/o params",
		"dashboardName": "testContextDashboardChild"
	},
	"testRecordWithoutContext": {
		"$type": "$representation",
		"$title": "Click to navigate",
		"entity": "testNavigateToChild",
		"action": "$query",
		"representation": "testNavigateToChild",
		"facet": "$query"
	},
	"testRecordLinkToDashboardSUPERV": {
		"$type": "$representation",
		"$title": "Click to navigate",
		"entity": "AQMDEVICEM",
		"action": "$query",
		"representation": "AQMDEVICEM",
		"facet": "$query",
		"endpoint": "x3.erp.SUPERV"
	},
	"testRecordWithContextSUPERV": {
		"$type": "$representation",
		"$title": "Click to navigate",
		"entity": "AQMDEVICEM",
		"action": "$query",
		"representation": "AQMDEVICEM",
		"facet": "$query",
		"endpoint": "x3.erp.SUPERV",
		"parameters": {
			"where": {
				"value": "CODE eq {CODE}"
			}
		}
	},
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testPropertyHideShowDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testPropertyHideShowDashboard": {
		"$dashboardName": "testPropertyHideShowDashboard",
		"$title": "PropertyHideShow test dashboard",
		"$description": "Test different kinds of PropertyHideShow",
		"$vignettes": {
			"testLinkQueryRecordHS": {
				"$uuid": "testDisplayQueryRecordHS",
				"$displayStyle": "$link"
			},
			"testLinkDetailsRecordHS": {
				"$uuid": "testDisplayDetailsRecordHS",
				"$displayStyle": "$link"
			},
			"testLinkEditRecordHS": {
				"$uuid": "testDisplayEditRecordHS",
				"$displayStyle": "$link"
			},
			"testLinkCreateRecordHS": {
				"$uuid": "testDisplayCreateRecordHS",
				"$displayStyle": "$link"
			},
			"testDisplayQueryRecordHS": {
				"$uuid": "testDisplayQueryRecordHS",
				"$displayStyle": "$full"
			},
			"testDisplayDetailsRecordHS": {
				"$uuid": "testDisplayDetailsRecordHS",
				"$displayStyle": "$full"
			},
			"testDisplayEditRecordHS": {
				"$uuid": "testDisplayEditRecordHS",
				"$displayStyle": "$full"
			},
			"testDisplayCreateRecordHS": {
				"$uuid": "testDisplayCreateRecordHS",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkQueryRecordHS"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkDetailsRecordHS"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkEditRecordHS"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkCreateRecordHS"
					}]
				}]
			}, {
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayQueryRecordHS"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayDetailsRecordHS"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayEditRecordHS"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayCreateRecordHS"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testDisplayDetailsRecordHS": {
		"$type": "$representation",
		"$title": "Details facet",
		"entity": "testPropertyHideShow",
		"action": "$details",
		"representation": "testPropertyHideShow",
		"facet": "$details",
		"keyParameter": "5"
	},
	"testDisplayEditRecordHS": {
		"$type": "$representation",
		"$title": "Edit facet",
		"entity": "testPropertyHideShow",
		"action": "$edit",
		"representation": "testPropertyHideShow",
		"facet": "$edit",
		"keyParameter": "5"
	},
	"testDisplayCreateRecordHS": {
		"$type": "$representation",
		"$title": "Create facet",
		"entity": "testPropertyHideShow",
		"action": "$create",
		"representation": "testPropertyHideShow",
		"facet": "$create",
		"keyParameter": "5"
	},
	"testDisplayQueryRecordHS": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "testPropertyHideShow",
		"action": "$query",
		"representation": "testPropertyHideShow",
		"facet": "$query",
		"keyParameter": "5"
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testAQTACTNPDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testAQTACTNPDashboard": {
		"$dashboardName": "testAQTACTNPDashboard",
		"$title": "AQTACTNP Facet Create",
		"$description": "Test Facet Create AQTACTNP",
		"$vignettes": {
			"testAQTACTNPCreate": {
				"$uuid": "testAQTACTNPCreate",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "testAQTACTNPCreate"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testAQTACTNPCreate": {
		"$type": "$representation",
		"$title": "Facet Create AQTACTNP",
		"entity": "AQTACTNP",
		"action": "$create",
		"representation": "AQTACTNP",
		"facet": "$create"
	}

};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testQAQTGRAPDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testQAQTGRAPDashboard": {
		"$dashboardName": "testQAQTGRAPDashboard",
		"$title": "Display Query testQAQTGRAPDashboard",
		"$description": "Test testQAQTGRAPDashboard SUPERV",
		"$vignettes": {
			"testQAQTGRAP_Request": {
				"$uuid": "testQAQTGRAP_Request",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testQAQTGRAP_Request",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "chart",
								"$arrayOptions": {
									"showPagination": true,
									"rowIndex": true,
								},
								"$chartOptions": {
									"isLegendHidden": true
								}
							}]
						}
					}],
					"$size": "all"
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testQAQTGRAP_Request": {
		"$type": "$request",
		"$title": "Request QAQTGRAP",
		"requestName": "QAQTGRA2",
		"requestLevel": "99",
		"action": "$query",
		"endpoint": "",
		"facet": "$query"
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testSTATISTICDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testSTATISTICDashboard": {
		"$dashboardName": "testSTATISTICDashboard",
		"$title": "Display Query testSTATISTICDashboard",
		"$description": "testSTATISTICDashboard SUPERV",
		"$vignettes": {
			"$testSTAT_Request": {
				"$uuid": "$testSTAT_Request",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "$testSTAT_Request",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "chart",
								"$arrayOptions": {
									"showPagination": true,
									"rowIndex": true,
								},
								"$chartOptions": {
									"isLegendHidden": true
								}
							}]
						}
					}],
					"$size": "all"
				}]
			}]
		}
	}
};

exports.gadgets = {
	"$testSTAT_Request": {
		"entity": "ZAQT",
		"$type": "$stats",
		"$title": "Stat ZAQT",
		"statName": "ZAQT",
		"action": "$query",
		"representation": "STATS~ZAQT.$cube",
		"facet": "$cube",
		"endpoint": "",
		"$uuid": "$testSTAT_Request"

	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testAQMPROJECTMDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testAQMPROJECTMDashboard": {
		"$dashboardName": "testAQMPROJECTMDashboard",
		"$title": "PROJECT Management",
		"$description": "AQMPROJECTM Representation",
		"$vignettes": {
			"testDefaultAQMPROJECTM_QUERY": {
				"$uuid": "testDefaultAQMPROJECTM_QUERY",
				"$displayStyle": "$full"
			}

		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "testDefaultAQMPROJECTM_QUERY"
					}]
				}, {


				}]
			}]
		}
	},
	"LISTTASKBUD": {
		"$dashboardName": "LISTTASKBUD",
		"$title": "Budget-Task list",
		"$description": "Budget Task List",
		"$vignettes": {
			"testDefaultAQMTASKM_QUERY": {
				"$uuid": "testDefaultAQMTASKM_QUERY",
				"$displayStyle": "$full"
			},
			"testDefaultAQMBUDGETM_QUERY": {
				"$uuid": "testDefaultAQMBUDGETM_QUERY",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$sameSize": true,
					"$widthAll": 6,
					"$items": [{
						"$bind": "testDefaultAQMTASKM_QUERY"
					}]
				}, {
					"$layoutType": "cell",
					"$sameSize": true,
					"$widthAll": 6,
					"$items": [{
						"$bind": "testDefaultAQMBUDGETM_QUERY"
					}]
				}]
			}]
		}
	},
	"LISTOPERAT": {
		"$dashboardName": "LISTOPERAT",
		"$title": "Operation list",
		"$description": "Operation list",
		"$vignettes": {
			"testDefaultAQMOPERATM_QUERY": {
				"$uuid": "testDefaultAQMOPERATM_QUERY",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$sameSize": true,
					"$widthAll": 6,
					"$items": [{
						"$bind": "testDefaultAQMOPERATM_QUERY"
					}]

				}]
			}]
		}

	}
};

exports.gadgets = {
	"testDefaultAQMPROJECTM_QUERY": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "AQMPROJECT",
		"action": "$query",
		"representation": "AQMPROJECTM",
		"facet": "$query"
	},
	"testDefaultAQMTASKM_QUERY": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "AQMTASK",
		"action": "$query",
		"representation": "AQMTASKM",
		"facet": "$query",
		"parameters": {
			"where": {
				"value": "(PROJECT eq '{WCODE}')"
			}
		}

	},
	"testDefaultAQMBUDGETM_QUERY": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "AQMBUDGET",
		"action": "$query",
		"representation": "AQMBUDGETM",
		"facet": "$query",
		"parameters": {
			"where": {
				"value": "(PROJECT eq '{WCODE}')"
			}
		}

	},
	"testDefaultAQMOPERATM_QUERY": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "AQMOPERAT",
		"action": "$query",
		"representation": "AQMOPERATM",
		"facet": "$query",
		"parameters": {
			"where": {
				"value": "(PROJECT eq '{WCODE}' and TASKCODE eq '{WTASK}')"
			}

		}
	}



};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testAQMOPERATMDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testAQMOPERATMDashboard": {
		"$dashboardName": "testAQMOPERATMDashboard",
		"$title": "AQMOPERATM default endpoint",
		"$description": "AQMOPERATM Representation",
		"$vignettes": {
			"testDefaultAQMOPERATM_QUERY": {
				"$uuid": "testDefaultAQMOPERATM_QUERY_2",
				"$displayStyle": "$full"
			}

		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "testDefaultAQMOPERATM_QUERY"
					}]
				}, {


				}]
			}]
		}
	},
	"INPUTTIMES": {
		"$dashboardName": "INPUTTIMES",
		"$title": "Input times",
		"$description": "Input times",
		"$vignettes": {
			"testDefaultAQMINTIMESM_QUERY": {
				"$uuid": "testDefaultAQMINTIMESM_QUERY",
				"$displayStyle": "$full"
			},
			"testDefaultAQMINTIMESM_CREATE": {
				"$uuid": "testDefaultAQMINTIMESM_CREATE",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$sameSize": true,
					"$widthAll": 6,
					"$items": [{
						"$bind": "testDefaultAQMINTIMESM_QUERY"
					}]
				}, {
					"$layoutType": "cell",
					"$sameSize": true,
					"$widthAll": 6,
					"$items": [{
						"$bind": "testDefaultAQMINTIMESM_CREATE"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testDefaultAQMOPERATM_QUERY_2": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "AQMOPERATM",
		"action": "$query",
		"representation": "AQMOPERATM",
		"facet": "$query",
		"parameters": {
			"where": {
				"value": "(PROJECT eq '{WCODE}' and TASKCODE eq '{WTASK}')"
			}

		}
	},
	"testDefaultAQMINTIMESM_CREATE": {
		"$type": "$representation",
		"$title": "Create facet",
		"entity": "AQMINTIMES",
		"action": "$create",
		"representation": "AQMINTIMESM",
		"facet": "$create",
		"parameters": {
			"context": {
				"PROJECT": "{WPJM}",
				"TASKCODE": "{WTASK}",
				"OPERAT": "{WOPER}"
			}
		}

	}

};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testAQMINTIMESMDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testAQMINTIMESMDashboard": {
		"$dashboardName": "testAQMINTIMESMDashboard",
		"$title": "AQMINTIMESM default endpoint",
		"$description": "AQMINTIMESM Representation",
		"$vignettes": {
			"testDefaultAQMINTIMESM_QUERY": {
				"$uuid": "testDefaultAQMINTIMESM_QUERY",
				"$displayStyle": "$full"
			}

		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "testDefaultAQMINTIMESM_QUERY"
					}]
				}, {

				}]
			}]
		}
	}
};

exports.gadgets = {
	"testDefaultAQMINTIMESM_QUERY": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "AQMINTIMESM",
		"action": "$query",
		"representation": "AQMINTIMESM",
		"facet": "$query",
		"parameters": {
			"where": {
				"value": "(PROJECT eq '{WPJM}' and TASKCODE eq '{WTASK}' and OPERAT eq {WOPER} )"
			}
		}
	}

};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testGridDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testGridDashboard": {
		"$dashboardName": "testGridDashboard",
		"$title": "Arrays - Test dashboard",
		"$description": "Arrays - Test dashboard",
		"$vignettes": {
			"testAQMDEVICEQueryGrid": {
				"$uuid": "testAQMDEVICEQueryGrid",
				"$displayStyle": "$full"
			},
			"testAQMDEVICEDetailGrid": {
				"$uuid": "testAQMDEVICEDetailGrid",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "AQMCRUDM.$Query - Table Mode",
				"$items": [{
					"$layoutType": "tile",
					"$size": "full",
					"$items": [{
						"$bind": "testAQMDEVICEQueryGrid",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$title": "QUERY - $display=table",
								"$display": "table",
								"$table": [{
									"$bind": "CODE"
								}, {
									"$bind": "CODECHR"
								}, {
									"$bind": "TEXTDES0"
								}, {
									"$bind": "CUR_REF"
								}]
							}]
						}
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "AQMCRUDM.$Query - Vertical Cards - Multiple",
				"$items": [{
					"$layoutType": "tile",
					"$size": "full",
					"$items": [{
						"$bind": "testAQMDEVICEQueryGrid",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "card",
								"$cardsPerRow": 1,
								"$emptycell": "filled",
								"$article": {
									"$items": [{
										"$bind": "CODE"
									}, {
										"$bind": "CODECHR"
									}, {
										"$bind": "TEXTDES0"
									}, {
										"$bind": "CUR_REF"
									}]
								}
							}]
						}
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "AQMCRUDM.$Query - Vertical Cards - Single",
				"$items": [{
					"$layoutType": "tile",
					"$size": "full",
					"$items": [{
						"$bind": "testAQMDEVICEQueryGrid",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "card",
								"$cardsPerRow": 3,
								"$emptycell": "filled",
								"$article": {
									"$items": [{
										"$bind": "CODE"
									}, {
										"$bind": "CODECHR"
									}, {
										"$bind": "TEXTDES0"
									}, {
										"$bind": "CUR_REF"
									}]
								}
							}]
						}
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "$Details facet",
				"$items": [{
					"$layoutType": "tile",
					"$size": "full",
					"$items": [{
						"$bind": "testAQMDEVICEDetailGrid"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testAQMDEVICEQueryGrid": {
		"$type": "$representation",
		"$title": "Query AQMCRUDM",
		"entity": "AQMDEVICE",
		"action": "$query",
		"representation": "AQMCRUDM",
		"facet": "$query"
	},
	"testAQMDEVICEDetailGrid": {
		"$type": "$representation",
		"$title": "Detail AQMCRUDM",
		"entity": "AQMDEVICE",
		"action": "$details",
		"representation": "AQMCRUDM",
		"facet": "$details",
		"keyParameter": "1"
	}

};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testSUPERVAQTCRUDMDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testDefaultAQTCRUDM": {
		"$dashboardName": "testDefaultAQTCRUDM",
		"$title": "AQTCRUDM default endpoint",
		"$description": "AQTCRUDM Representation",
		"$vignettes": {
			"testDefaultAQTCRUDM_AQTCRUDM_QUERY": {
				"$uuid": "testDefaultAQTCRUDM_AQTCRUDM_QUERY",
				"$displayStyle": "$full"
			},
			"testDefaultAQTCRUDM_AQTCRUDM_DETAIL": {
				"$uuid": "testDefaultAQTCRUDM_AQTCRUDM_DETAIL",
				"$displayStyle": "$full"
			},
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "testDefaultAQTCRUDM_AQTCRUDM_QUERY"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "testDefaultAQTCRUDM_AQTCRUDM_DETAIL"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testDefaultAQTCRUDM_AQTCRUDM_QUERY": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "AQTCRUDM",
		"action": "$query",
		"representation": "AQTCRUDM",
		"facet": "$query"
	},
	"testDefaultAQTCRUDM_AQTCRUDM_DETAIL": {
		"$type": "$representation",
		"$title": "Details facet",
		"entity": "AQTCRUDM",
		"action": "$details",
		"representation": "AQTCRUDM",
		"facet": "$details",
		"keyParameter": "10"
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testSUPERVAQMCRUDMDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testDefaultAQMCRUDM": {
		"$dashboardName": "testDefaultAQMCRUDM",
		"$title": "AQMCRUDM default endpoint",
		"$description": "AQMCRUDM Representation",
		"$vignettes": {
			"testDefaultAQMCRUDM_AQMCRUDM_QUERY": {
				"$uuid": "testDefaultAQMCRUDM_AQMCRUDM_QUERY",
				"$displayStyle": "$full"
			},
			"testDefaultAQMCRUDM_AQMCRUDM_DETAIL": {
				"$uuid": "testDefaultAQMCRUDM_AQMCRUDM_DETAIL",
				"$displayStyle": "$full"
			},
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "testDefaultAQMCRUDM_AQMCRUDM_QUERY",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "table",
								"$table": [{
									"$bind": "CODE"
								}, {
									"$bind": "CPY_REF"
								}, {
									"$bind": "CUR_REF"
								}, {
									/* to test  globals.getDvlpOpt("showUnfoundFields") option */
									"$bind": "I_do_not_exist"
								}]
							}]
						}
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "testDefaultAQMCRUDM_AQMCRUDM_DETAIL"
					}]
				}]
			}]
		}
	},
	"MobileDashboardOverview": {
		"$dashboardName": "MobileDashboardOverview",
		"$title": "MobileDashboardOverview",
		"$description": "",
		"$vignettes": {
			"testDefaultAQTCRUDM_QUERY": {
				"$uuid": "testDefaultAQTCRUDM_QUERY",
				"$displayStyle": "$full"
			}
		}
	}
};

exports.gadgets = {
	"testDefaultAQMCRUDM_AQMCRUDM_QUERY": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "AQMCRUDM",
		"action": "$query",
		"representation": "AQMCRUDM",
		"facet": "$query"
	},
	"testDefaultAQMCRUDM_AQMCRUDM_DETAIL": {
		"$type": "$representation",
		"$title": "Details facet",
		"entity": "AQMCRUDM",
		"action": "$details",
		"representation": "AQMCRUDM",
		"facet": "$details",
		"keyParameter": "10"
	},
	"testDefaultAQTCRUDM_QUERY": {
		"$type": "$representation",
		"$title": "AQTCRUDM",
		"action": "$query",
		"representation": "AQTCRUDM",
		"facet": "$query",
		"parameters": {
			"where": {
				"value": "(CODE eq {WCODE})"
			}
		}
	}

};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testSUPERVAQMTABLEMDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testDefaultAQMFIELDSM": {
		"$dashboardName": "testDefaultAQMFIELDSM",
		"$title": "AQMFIELDSM SUPERV endpoint",
		"$description": "AQMFIELDSM Representation",
		"$vignettes": {
			"testDefaultAQMFIELDSM_AQMFIELDSM_QUERY": {
				"$uuid": "testDefaultAQMFIELDSM_AQMFIELDSM_QUERY",
				"$displayStyle": "$full"
			},
			"testDefaultAQMFIELDSM_AQMFIELDSM_DETAIL": {
				"$uuid": "testDefaultAQMFIELDSM_AQMFIELDSM_DETAIL",
				"$displayStyle": "$full"
			},
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "testDefaultAQMFIELDSM_AQMFIELDSM_QUERY"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "testDefaultAQMFIELDSM_AQMFIELDSM_DETAIL"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testDefaultAQMFIELDSM_AQMFIELDSM_QUERY": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "AQMDEVICE",
		"action": "$query",
		"representation": "AQMFIELDSM",
		"facet": "$query"
	},
	"testDefaultAQMFIELDSM_AQMFIELDSM_DETAIL": {
		"$type": "$representation",
		"$title": "Details facet",
		"entity": "AQMDEVICE",
		"action": "$details",
		"representation": "AQMFIELDSM",
		"facet": "$details",
		"keyParameter": "10"
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testSUPERVAQMSEARCHMDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testDefaultAQMSEARCHM": {
		"$dashboardName": "testDefaultAQMSEARCHM",
		"$title": "AQMSEARCHM SUPERV",
		"$description": "AQMSEARCHM Representation",
		"$vignettes": {
			"testDefaultAQMSEARCHM_AQMSEARCHM_QUERY": {
				"$uuid": "testDefaultAQMSEARCHM_AQMSEARCHM_QUERY",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "12",
					"$items": [{
						"$bind": "testDefaultAQMSEARCHM_AQMSEARCHM_QUERY"
					}]
				}]
			}]
		}
	}
};
exports.gadgets = {
	"testDefaultAQMSEARCHM_AQMSEARCHM_QUERY": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "AQMSEARCH",
		"action": "$query",
		"representation": "AQMSEARCHM",
		"facet": "$query"
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/unitTests/entities/entityCtrlField',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract'],function (require, exports, module) {"use strict";

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');

var _entityName = "controlField";

var _details = {
	"decimalEmpty": null,
	"decimalFilled": 123456.789,
	"integerEmpty": null,
	"integerFilled": 123456789,
	"realEmpty": null,
	"realFilled": 123456.789,
	"quantityEmpty": null,
	"quantityFilled": 123,
	"quantityUnit": {
		"$description": "EURO euro",
		"$precision": 11,
		"$scale": 2,
		"$symbol": "€",
		"$title": "Euro"
	},
	"quantityUnitVal": "EUR",
	"dateEmpty": "",
	"dateFilled": "2015-01-23",
	"timeEmpty": "",
	"timeFilled": "11:12:13",
	"datetimeEmpty": "",
	"datetimeFilled": "2015-01-23T11:12:13Z",
	"choiceEmpty": "",
	"choiceFilled": "MYCHOICE",
	"booleanFilled": true,
	"booleanEmpty": null,
	"referenceEmptyVal": "",
	"referenceFilledVal": "MYREF",
	"referenceFilled": {
		"$description": "My description",
		"$title": "My title"
	},
	"stringEmpty": "",
	"stringFilled": "MY STRING",
	"textRtfEmpty": "",
	"textRtfFilled": "",
	"textHtmlEmpty": "",
	"textHtmlFilled": "<b>MY HTML</b>",
	"textPlainEmpty": "",
	"textPlainFilled": "MY TEXT",
	"imageEmpty": "",
	"imageFilled": {}
};
var _fields = ["decimal", "integer", "real", "quantity", "date", "time", "datetime", "choice", "boolean", "reference", "string", "textPlain", "textRtf", "textHtml", "image"];
var _unitTestCallBack = function(structElmt) {

};
var _buildDetailsLayout = function() {
	var _addUnitTestInfo = function(article, message) {
		article.$unitTest = {
			message: message,
		};
	};
	var rows = [];
	_fields.forEach(function(field) {
		var row = {
			"$layoutType": "row",
			"$items": []
		};
		rows.push(row);
		var cells = row.$items;
		["filled", "empty"].forEach(function(type) {
			var cell = {
				"$layoutType": "cell",
				"$sameSize": true,
				"$widthAll": 4,
				"$items": [{
					"$bind": field + type.smCapitalize()
				}]
			};
			if (type === "filled") {
				_addUnitTestInfo(cell.$items[0], "Title and value should be displayed");
			} else {
				_addUnitTestInfo(cell.$items[0], field === "image" ? "Only title and empty image icon should be displayed" : "Only title should be displayed");
				cells.push(cell);
				cell = $.extend(true, {}, cell);
				cell.$items[0].$hideIfEmpty = true;
				_addUnitTestInfo(cell.$items[0], "No title and value should be displayed");
			}
			cells.push(cell);
		});
	});
	return {
		"$layoutType": "stack",
		"$items": rows
	};

};
var _entity = {
	$entityName: _entityName,
	$properties: {
		"decimalEmpty": {
			"$title": "decimalEmpty",
			"$type": "application/x-decimal"
		},
		"decimalFilled": {
			"$title": "decimalFilled",
			"$type": "application/x-decimal"
		},
		"integerEmpty": {
			"$title": "integerEmpty",
			"$type": "application/x-integer"
		},
		"integerFilled": {
			"$title": "integerFilled",
			"$type": "application/x-integer"
		},
		"realEmpty": {
			"$title": "realEmpty",
			"$type": "application/x-real"
		},
		"realFilled": {
			"$title": "realFilled",
			"$type": "application/x-real"
		},
		"quantityEmpty": {
			"$title": "quantityEmpty",
			"$type": "application/x-quantity",
		},
		"quantityFilled": {
			"$title": "quantityFilled",
			"$type": "application/x-quantity",
			"$unit": "quantityUnit",
			"$value": {
				"$title": "{$value} {$unit}",
				"$type": "application/x-decimal",
				"$precision": 9,
				"$scale": 2,
				"$format": "0.00"
			}
		},
		"quantityUnit": {
			"$title": "quantityUnit",
			"$type": "application/x-reference",
			"$item": {
				"$value": "{quantityUnitVal}"
			}
		},
		"dateEmpty": {
			"$title": "dateEmpty",
			"$type": "application/x-date"
		},
		"dateFilled": {
			"$title": "dateFilled",
			"$type": "application/x-date"
		},
		"timeEmpty": {
			"$title": "timeEmpty",
			"$type": "application/x-time"
		},
		"timeFilled": {
			"$title": "timeFilled",
			"$type": "application/x-time"
		},
		"datetimeEmpty": {
			"$title": "datetimeEmpty",
			"$type": "application/x-datetime"
		},
		"datetimeFilled": {
			"$title": "datetimeFilled",
			"$type": "application/x-datetime"
		},
		"choiceEmpty": {
			"$title": "choiceEmpty",
			"$type": "application/x-choice"
		},
		"choiceFilled": {
			"$title": "choiceFilled",
			"$type": "application/x-choice"
		},
		"booleanFilled": {
			"$title": "booleanFilled",
			"$type": "application/x-boolean"
		},
		"booleanEmpty": {
			"$title": "booleanEmpty",
			"$type": "application/x-boolean"
		},
		"referenceEmpty": {
			"$title": "referenceEmpty",
			"$type": "application/x-reference",
			"$item": {
				"$value": "{VALUE}",
				"$key": "{VALUE}",
				"$properties": {
					"VALUE": {
						"$type": "application/x-string"
					}
				},
				"VALUE": "{referenceEmptyVal}"
			}
		},
		"referenceFilled": {
			"$title": "referenceFilled",
			"$type": "application/x-reference",
			"$item": {
				"$value": "{referenceFilledVal}"
			}
		},
		"stringEmpty": {
			"$title": "stringEmpty",
			"$type": "application/x-string"
		},
		"stringFilled": {
			"$title": "stringFilled",
			"$type": "application/x-string"
		},
		"textRtfEmpty": {
			"$title": "textRtfEmpty",
			"$type": "text/rtf",
			"$url": clientContract.getLocalEntityUrl(_entityName, "/textRtfEmpty")
		},
		"textRtfFilled": {
			"$title": "textRtfFilled",
			"$type": "text/rtf",
			"$acceptedTypes": ["text/rtf"],
			"$url": clientContract.getLocalEntityUrl(_entityName, "/textRtfFilled")
		},
		"textHtmlEmpty": {
			"$title": "textHtmlEmpty",
			"$type": "text/html",
			"$url": clientContract.getLocalEntityUrl(_entityName, "/textHtmlEmpty")
		},
		"textHtmlFilled": {
			"$title": "textHtmlFilled",
			"$type": "text/html",
			"$url": clientContract.getLocalEntityUrl(_entityName, "/textHtmlFilled")
		},
		"textPlainEmpty": {
			"$title": "textPlainEmpty",
			"$type": "text/plain",
			"$url": clientContract.getLocalEntityUrl(_entityName, "/textPlainEmpty")
		},
		"textPlainFilled": {
			"$title": "textPlainFilled",
			"$type": "text/plain",
			"$acceptedTypes": ["text/plain"],
			"$url": clientContract.getLocalEntityUrl(_entityName, "/textPlainFilled")
		},
		"imageEmpty": {
			"$title": "imageEmpty",
			"$type": "image",
			"$url": clientContract.getLocalEntityUrl(_entityName, "/imageEmpty")
		},
		"imageFilled": {
			"$title": "imageFilled",
			"$type": "image",
			"$url": clientContract.getLocalEntityUrl(_entityName, "/imageFilled")
		}
	},
	$relations: {},
	$articles: {
		$details: _buildDetailsLayout()
	},
	$services: {
		$read: function(op, data) {
			var deferred = $.Deferred();
			var result = op.$representation && op.$representation.endsWith("$details") ? _details : null;
			deferred.resolve($.extend({}, result));
			return deferred.promise();
		}
	},
	//sdataUrl 	parsed url
	//path 		array that contains th end of the path following entity name
	$urlCall: function(sdataUrl, path) {
		if (!path || path.length == 0) return "";
		switch (path[0]) {
			case "textRtfEmpty":
				return null;
			case "textRtfFilled":
				return {
					responseText: "{\\rtf1\\ansi{\\fonttbl{\\f0 MS Sans Serif;}}\\uc0\\pard MY RTF CONTENT\\par}"
				};
			case "textHtmlEmpty":
				return null;
			case "textHtmlFilled":
				return {
					responseText: '<span style="color:red"><b>MY HTML CONTENT</b></span>'
				};
			case "textPlainEmpty":
				return null;
			case "textPlainFilled":
				return {
					responseText: 'MY TEXT PLAIN CONTENT'
				};
			case "imageEmpty":
				return null;
			case "imageFilled":
				return "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAUDBAQEAwUEBAQFBQUGBwwIBwcHBw8LCwkMEQ8SEhEPERETFhwXExQaFRERGCEYGh0dHx8fExciJCIeJBweHx7/2wBDAQUFBQcGBw4ICA4eFBEUHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh7/wAARCAAzAHEDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD7Looqrqd5b6dp91qF3II7a2heaZiPuooyx/IUCbSV2Wsj1oyK+V9e+NHj7xRrR0/whbvZxO5EEFrbCe4kUd2JB57/ACgY9+8Vxqfx90qP7bN/wkQjQZJa3WYAepUKePwrT2TPBfENFt+zhKSXVLQ+rcj1or5hs/jd8RG8JXlz/YlvcG3kWKTVBbNshJ7Oo+Xd+QHAwcisq1vfjv4ij/tC0l8RtE4LK0a+RGw65UYUH2xR7N9QfEFF2VKEpN9kfWeR60ZHrXyZp/xW+JvgrV0sfEYuLpUwXtNSh2uy9Mq+N3Y4b5h7GrHjb45+LNe1EWnhZZNJtGKpGiRrJcyk9icHBz0C4PuaPZMX+seFUG5JqS6W1PqvI9aMj1FfKdr4x+NvhhF1jU7bWJrBfmlXULImPb/tHAKfXIrIi+NPjkeIUv5NWlewF2JmsdsYUxb8+Vu25xt+XPWn7JilxJh4WU4ST81+O59h5FGRXyna+PfjJ48vph4cNwsMZyY7GBEjiz0BkbnP1b8Kvjx/8Xvh/ewN4wsp7uwd9pW5RCreoWaPPze2T9D1pezZa4gov3uSXJ/NbQ+nciisTwb4j03xX4dttc0ty1vOM7WwGjYdVYA8EGtsdKzPbhONSKlF3TCiiigsKyfFmlrrvhnVNGaQR/bbWW3Dn+AspAb8Cc/hWtXPePfE9p4Q8NXWuXlvcXMcOAIoEJLMemT0UepPT3OAWt9DKu4KnJ1Phtr6HydpM3jT4R+LXvX0r7Pcqj27faYS8EyEg8MMZGQDlW9vau9tf2kdWX/j58M2EowOY7l05/EGuh8H/tCaJfI0HirT5dOkLHEsCGWErngEfeBxx0OcE8ZxWh4j+JfwYu9Pna5js9XYr/qRpT73OP7zoADwOcjHFbPV6o+Qw8YUoN4XFqMd7O36/wCRnW/7QPhN9CuJLnw7dRXrvlrJQjxyk9WLkD05JXPTg84x5P2lLouRH4RhC5woa/JP4/JXgxe3N6X8hlt/Mz5av8wXP3QcHnHfFfVvhXxp8FxpMMVk+jafGqD9xcWex145BJX5j6nJ+tOUYx6EYLMcXjG4uvGFvJa/f/XkeE/F34iv8QpdNmk0aPTnsVkXKTeYZA+08nAxgqcdeprq/wBkmwguPG+o30sSO1rY/uiRyjO4GR6HaCM+h96yP2hvEnhLxBrenx+E47cw2sbieeG28pZGYgccAnAXr78VlfBLxxD4G8WvfX0MsthdQGC4EWNyjIIcA4BIIxj0J9qpr3NDghWjTzRTrTUkmry6beXY+ypESSNo3VXUjDKwyCPevhHxxZW+m+Ndd060XZbWuo3EMK5zhFkZVH5AV9Q3nx1+HkGnm4h1G7uZdpP2eO0kD59MsAv618o63fNqes32pPGI2u7iScoDkKWYtj8M1NJNbnocS4rD1401Tkm1fbU9f+HHxr0vwf4QstCi8LSSvACZZUulXzXLEliNvuB16AelT+PPjjpnivwnf6DN4UlT7VEVjke7DeXIOVbG3sRV34P+PPhpH4Xs9H8U6Vp1nqFopQ3E+niVJxkkHcFJDeueOOD2Gx4u+J/wm0m226L4c0zXLo4+SPT0ijHP8TOnp6A/hSsr7FU61R4RJ4qKja1rK+21txv7H13K/h7XrJmJhhuo5VHoXQg/oi17wOlcl8MtV8N694bXWfDWmR2FvO+2WMWohO9eoOBhsZxkZH4giutHQVlN3Z9LllFUcLCClzK24UUUVJ3hUckayIyOisrAqVIyCD1BqSigDzfxJ8FfAOtzvcf2ZLpsz53NYSeWD9EIKj8AKxrb9njwPFOskl5rtwB1SS4jAb2O2MH8jXsNFVzy7nBPK8HOXM6av6HES/CrwFJoI0Y+G7VbdTuDqW84N6+Znd+ZxXHT/s6eDnn3RaprkUR6p5sZ/IlP8fxr2iihTkuo6mWYSpbmprTyPIdV+AXgy6tLS2tZtQsTBu3yo6tJOTjlywPTbwAABk8c1hX3gj4LQTWfgy/1tYdXtkfN2k6xyElydsj48veN2ACN2FA9K93kUOGRlypBByOteGeOP2ebC+vJb3wxqZ08yMWa0uVLxg/7Lj5gPYhqqMr7s87HZdGlHmw1CMn1T7abdPn+ZbX4V/CbwlbtrOs6jJd28A3qt9eIytjnAVFXefRec14x4EtovFXxrsnt7FFtbrV2vDbBBsWFXMpUjptCjGPw712Vl+zj4re4C3utaLFDnl4mlkbH0KL/ADr2f4XfDPQ/AUEj2bSXmozLsmvJlAYr12qB91c84yScDJOBV8yit7nmwy6ti6sL0VShF3fd/qY2ufAfwFqdwZ4YL/SyxJK2VwAh+gdWA+gwKNC+A/gLTLgTzQX+plSCq3twCoI9kVQfxzXqY6UVlzy7n0X9l4Pm5/Zq/oQWtvDa20dvbQRwwxqFSONAqqB2AHAFTjpRRUnclbYKKKKBhRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf/9k=";
			default:
				return null;
		}
	}
};


exports.entity = _entity;
});

define('syracuse-tablet/html/js/demos/clientTestApp/unitTests/unitTestCtrlField',['require','exports','module'],function (require, exports, module) {"use strict";

exports.init = function(nameModule, dashboards, gadgets) {
	gadgets[nameModule] = {
		"$type": "$representation",
		"$title": "Control Field",
		"entity": "controlField",
		"action": "$details",
		"representation": "controlField",
		"facet": "$details",
		"$article": {}
	};
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/unitTestsDashboard',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/clientTestApp/unitTests/entities/entityCtrlField','syracuse-tablet/html/js/demos/clientTestApp/unitTests/unitTestCtrlField'],function (require, exports, module) {"use strict";

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');

var entities = [
	require('syracuse-tablet/html/js/demos/clientTestApp/unitTests/entities/entityCtrlField')
];

var modules = {
	unitTestCtrlField: require('syracuse-tablet/html/js/demos/clientTestApp/unitTests/unitTestCtrlField')
};

var _initModules = function() {
	var vignettes = exports.dashboards.unitTestsDashboard.$vignettes;
	var tiles = exports.dashboards.unitTestsDashboard.$article.$items[0].$items;
	for (var name in modules) {
		vignettes[name] = {
			"$uuid": name,
			"$displayStyle": "$link"
		};
		tiles.push({
			"$layoutType": "tile",
			"$bgColor": "lightgreen",
			"$items": [{
				"$bind": name
			}],
			"$size": "medium"
		});
		// The modules add their own dashboard/gadget/entities
		modules[name].init(name, exports.dashboards, exports.gadgets);
		entities.forEach(function(entity) {
			if (entity.entity) {
				clientContract.registerEntity(entity.entity);
			}
		});
	}
};
exports.dashboards = {
	"unitTestsDashboard": {
		"$dashboardName": "unitTestsDashboard",
		"$title": "Unit Tests Dashboard",
		"$description": "",
		"$vignettes": {},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Unit Tests Group 1",
				"$items": []
			}]
		}
	}
};

exports.gadgets = {};

_initModules();
});

define('syracuse-tablet/html/js/demos/clientTestApp/testGaugeChartDashboard',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"testGaugeChartDashboard": {
		"$dashboardName": "testGaugeChartDashboard",
		"$title": "Gauge chart test dashboard",
		"$description": "Test different gauge charts authoring",
		"$vignettes": {
			"testGauge": {
				"$uuid": "testGauge",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testGauge",
						$article: {
							$layoutType: "stack",
							$items: [{
								$bind: "salesOp",
								/* GAUGE 1 */
								$gauge: {}
							}]
						}
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testGauge",
						$article: {
							$layoutType: "stack",
							$items: [{
								$bind: "salesOp",
								/* GAUGE 2 */
								"$gauge": {
									"segments": [{
										"propStart": 0,
										"propEnd": 0.75
									}, {
										"propStart": 0.75,
										"propEnd": 0.85
									}, {
										"propStart": 0.85,
										"propEnd": 1
									}]
								}
							}]
						}
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testGauge",
						$article: {
							$layoutType: "stack",
							$items: [{
								$bind: "salesValue",
								/* GAUGE 3 */
								"$gauge": {
									"$bindMin": "salesValueMin",
									"$bindMax": "salesValueMax",
									"segments": [{
										"propStart": 0,
										"propEnd": 0.75
									}, {
										"propStart": 0.75,
										"propEnd": 0.85
									}, {
										"propStart": 0.85,
										"propEnd": 1
									}]
								}
							}]
						}
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testGauge",
						$article: {
							$layoutType: "stack",
							$items: [{
								$bind: "salesValue",
								/* GAUGE 4 */
								"$gauge": {
									"$bindMin": "salesValueMin",
									"$bindMax": "salesValueMax",
									"segments": [{
										"valStart": 100000,
										"valEnd": 130000,
										"color": "#DF5353"
									}, {
										"valStart": 130000,
										"valEnd": 140000
									}, {
										"valStart": 140000,
										"valEnd": 150000,
										"color": "#55BF3B"
									}]
								}
							}]
						}
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testGauge": {
		"$type": "$representation",
		"$title": "Gauge 1",
		"entity": "testGaugeChart",
		"action": "$details",
		"representation": "testGaugeChart",
		"facet": "$details"
	}
};
});

define('syracuse-tablet/html/js/demos/clientTestApp/testApplication',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/clientTestApp/example','syracuse-tablet/html/js/demos/clientTestApp/exampleHubLayout','syracuse-tablet/html/js/demos/clientTestApp/testDatatypes','syracuse-tablet/html/js/demos/clientTestApp/testFormats','syracuse-tablet/html/js/demos/clientTestApp/testFormatsReference','syracuse-tablet/html/js/demos/clientTestApp/testCharts','syracuse-tablet/html/js/demos/clientTestApp/testConstraints','syracuse-tablet/html/js/demos/clientTestApp/testNavigateTo','syracuse-tablet/html/js/demos/clientTestApp/testNavigateToChild','syracuse-tablet/html/js/demos/clientTestApp/testPropertyHideShow','syracuse-tablet/html/js/demos/clientTestApp/testGaugeChart','syracuse-tablet/html/js/demos/clientTestApp/testHomeDashboard','syracuse-tablet/html/js/demos/clientTestApp/testLayoutsDashboard','syracuse-tablet/html/js/demos/clientTestApp/testTypesDashboard','syracuse-tablet/html/js/demos/clientTestApp/testFormatsDashboard','syracuse-tablet/html/js/demos/clientTestApp/testGX3APPDashboard','syracuse-tablet/html/js/demos/clientTestApp/testSUPERVDashboard','syracuse-tablet/html/js/demos/clientTestApp/testChartsHubDashboard','syracuse-tablet/html/js/demos/clientTestApp/testChartsStackDashboard','syracuse-tablet/html/js/demos/clientTestApp/testSUPERVDashboard2','syracuse-tablet/html/js/demos/clientTestApp/testGX3APPDashboard2','syracuse-tablet/html/js/demos/clientTestApp/testConstraintsDashboard','syracuse-tablet/html/js/demos/clientTestApp/testNavigateToDashboard','syracuse-tablet/html/js/demos/clientTestApp/testPropertyHideShowDashboard','syracuse-tablet/html/js/demos/clientTestApp/testAQTACTNPDashboard','syracuse-tablet/html/js/demos/clientTestApp/testQAQTGRAPDashboard','syracuse-tablet/html/js/demos/clientTestApp/testSTATISTICDashboard','syracuse-tablet/html/js/demos/clientTestApp/testAQMPROJECTMDashboard','syracuse-tablet/html/js/demos/clientTestApp/testAQMOPERATMDashboard','syracuse-tablet/html/js/demos/clientTestApp/testAQMINTIMESMDashboard','syracuse-tablet/html/js/demos/clientTestApp/testGridDashboard','syracuse-tablet/html/js/demos/clientTestApp/testSUPERVAQTCRUDMDashboard','syracuse-tablet/html/js/demos/clientTestApp/testSUPERVAQMCRUDMDashboard','syracuse-tablet/html/js/demos/clientTestApp/testSUPERVAQMTABLEMDashboard','syracuse-tablet/html/js/demos/clientTestApp/testSUPERVAQMSEARCHMDashboard','syracuse-tablet/html/js/demos/clientTestApp/unitTestsDashboard','syracuse-tablet/html/js/demos/clientTestApp/testGaugeChartDashboard'],function (require, exports, module) {"use strict";

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');

var _example = require('syracuse-tablet/html/js/demos/clientTestApp/example');
var _exampleHubLayout = require('syracuse-tablet/html/js/demos/clientTestApp/exampleHubLayout');
var _testDatatypes = require('syracuse-tablet/html/js/demos/clientTestApp/testDatatypes');
var _testFormats = require('syracuse-tablet/html/js/demos/clientTestApp/testFormats');
var _testFormatsReference = require('syracuse-tablet/html/js/demos/clientTestApp/testFormatsReference');
var _testCharts = require('syracuse-tablet/html/js/demos/clientTestApp/testCharts');
var _testConstraints = require('syracuse-tablet/html/js/demos/clientTestApp/testConstraints');
var _testNavigateTo = require('syracuse-tablet/html/js/demos/clientTestApp/testNavigateTo');
var _testNavigateToChild = require('syracuse-tablet/html/js/demos/clientTestApp/testNavigateToChild');
var _testPropertyHideShow = require('syracuse-tablet/html/js/demos/clientTestApp/testPropertyHideShow');
var _testGaugeChart = require('syracuse-tablet/html/js/demos/clientTestApp/testGaugeChart');

var _testHomeDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testHomeDashboard');
var _testLayoutsDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testLayoutsDashboard');
var _testTypesDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testTypesDashboard');
//var _testTypesDashboard2 = require('syracuse-tablet/html/js/demos/clientTestApp/testTypesDashboard2');
var _testFormatsDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testFormatsDashboard');
var _testGX3APPDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testGX3APPDashboard');
var _testSUPERVDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testSUPERVDashboard');
var _testChartsHubDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testChartsHubDashboard');
var _testChartsStackDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testChartsStackDashboard');
var _testSUPERVDashboard2 = require('syracuse-tablet/html/js/demos/clientTestApp/testSUPERVDashboard2');
var _testGX3APPDashboard2 = require('syracuse-tablet/html/js/demos/clientTestApp/testGX3APPDashboard2');
var _testConstraintsDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testConstraintsDashboard');
var _testNavigateToDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testNavigateToDashboard');
var _testPropertyHideShowDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testPropertyHideShowDashboard');
var _testAQTACTNPDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testAQTACTNPDashboard');
var _testQAQTGRAPDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testQAQTGRAPDashboard');
var _testSTATISTICDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testSTATISTICDashboard');

var _testAQMPROJECTMDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testAQMPROJECTMDashboard');

var _testAQMOPERATMDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testAQMOPERATMDashboard');
var _testAQMINTIMESMDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testAQMINTIMESMDashboard');

var _testGridDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testGridDashboard');
var _testDefaultAQTCRUDM = require('syracuse-tablet/html/js/demos/clientTestApp/testSUPERVAQTCRUDMDashboard');
var _testDefaultAQMCRUDM = require('syracuse-tablet/html/js/demos/clientTestApp/testSUPERVAQMCRUDMDashboard');
var _testDefaultAQMFIELDSM = require('syracuse-tablet/html/js/demos/clientTestApp/testSUPERVAQMTABLEMDashboard');
var _testDefaultAQMSEARCHM = require('syracuse-tablet/html/js/demos/clientTestApp/testSUPERVAQMSEARCHMDashboard');
var _unitTestsDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/unitTestsDashboard');

var _testGaugeChartDashboard = require('syracuse-tablet/html/js/demos/clientTestApp/testGaugeChartDashboard');

var _testApplication = {
	"$application": {
		"$uuid": "clientTestApplication",

		"applicationName": "clientTestApplication",
		"title": "Client test application",
		"description": "Application for testing client features without server dependencies",
		"iconName": "th",

		"$homeDashboard": {
			"$uuid": "testHomeDashboard",
			"dashboardName": "testHomeDashboard"
		},
	},
	"$dashboards": {},
	"$gadgets": {},
	"$pages": {
		/*
		 * Example on how to define a default article for an X3 representation
		 * that is used in a client side defined application
		 */
		"x3.erp.SUPERV.AQMCRUDM.$details": {
			"$page": {
				"$article": {
					"$layoutType": "stack",
					"$items": [{
						"$bind": "CODE"
					}, {
						"$bind": "PBLOB"
					}, {
						"$bind": "CODECHR"
					}, {
						"$bind": "WCUR_REF"
					}, {
						"$bind": "FLGTEST"
					}, {
						"$bind": "WMENU"
					}, {
						"$bind": "SIMUL1"
					}, {
						"$bind": "PCLOB"
					}, {
						"$bind": "TEXTAXX"
					}, {
						"$bind": "TEXTE"
					}, {
						"$bind": "TPOSIF"
					}, {
						"$bind": "CUR_REF"
					}, {
						"$bind": "SITE_REF"
					}, {
						"$bind": "TDCB2"
					}, {
						"$bind": "TDCB3",
						"$gauge": {}
					}, {
						"$bind": "TDCB"
					}, {
						"$bind": "TDATE"
					}, {
						"$bind": "UNIT_REF"
					}, {
						"$bind": "CRY_REF"
					}, {
						"$bind": "TEL"
					}, {
						"$bind": "EMAIL"
					}, {
						"$bind": "TEXTPLAIN"
					}, {
						"$bind": "TEXTHTML"
					}, {
						"$bind": "TEXTRTF"
					}, {
						"$bind": "CREUSR_REF"
					}, {
						"$bind": "UPDUSR_REF"
					}, {
						"$bind": "ADEVCOLREF1"
					}, {
						"$bind": "ADEVCOLREF2"
					}, {
						"$bind": "ADEVCTINT"
					}, {
						"$bind": "ADEVADEVICEL"
					}]
				}
			}
		}
	}
};

function _addToApp(app) {
	if (app.gadgets) {
		Object.keys(app.gadgets).forEach(function(key) {
			if (_testApplication.$gadgets[key]) {
				console.log("Duplicate gadget name: " + key);
			}
			_testApplication.$gadgets[key] = app.gadgets[key];
		});
	}
	if (app.dashboards) {
		Object.keys(app.dashboards).forEach(function(key) {
			if (_testApplication.$dashboards[key]) {
				console.log("Duplicate dashboard name: " + key);
			}
			_testApplication.$dashboards[key] = app.dashboards[key];
		});
	}
}

exports.register = function() {
	clientContract.registerEntity(_example.entity);
	clientContract.registerEntity(_exampleHubLayout.entity);

	clientContract.registerEntity(_testDatatypes.entity);
	clientContract.registerEntity(_testFormats.entity);
	clientContract.registerEntity(_testFormatsReference.entity);
	clientContract.registerEntity(_testCharts.entity);
	clientContract.registerEntity(_testConstraints.entity);
	clientContract.registerEntity(_testNavigateTo.entity);
	clientContract.registerEntity(_testNavigateToChild.entity);
	clientContract.registerEntity(_testPropertyHideShow.entity);
	clientContract.registerEntity(_testGaugeChart.entity);

	_addToApp(_testHomeDashboard);
	_addToApp(_testLayoutsDashboard);
	_addToApp(_testTypesDashboard);
	//	_addToApp(_testTypesDashboard2);
	_addToApp(_testFormatsDashboard);
	_addToApp(_testGX3APPDashboard);
	_addToApp(_testSUPERVDashboard);
	_addToApp(_testChartsHubDashboard);
	_addToApp(_testChartsStackDashboard);
	_addToApp(_testSUPERVDashboard2);
	_addToApp(_testGX3APPDashboard2);
	_addToApp(_testConstraintsDashboard);
	_addToApp(_testNavigateToDashboard);
	_addToApp(_testPropertyHideShowDashboard);
	_addToApp(_testAQTACTNPDashboard);
	_addToApp(_testQAQTGRAPDashboard);
	_addToApp(_testSTATISTICDashboard);


	_addToApp(_testAQMPROJECTMDashboard);

	_addToApp(_testAQMOPERATMDashboard);
	_addToApp(_testAQMINTIMESMDashboard);


	_addToApp(_testGaugeChartDashboard);
	_addToApp(_testGridDashboard);
	_addToApp(_testDefaultAQTCRUDM);
	_addToApp(_testDefaultAQMCRUDM);
	_addToApp(_testDefaultAQMFIELDSM);
	_addToApp(_testDefaultAQMSEARCHM);
	_addToApp(_unitTestsDashboard);

	clientContract.registerApp(_testApplication);
};
});

define('syracuse-tablet/html/js/demos/salesMyCustomers/dashCustomers',['require','exports','module'],function (require, exports, module) {"use strict";
var _customerArticle = {
	"$layoutType": "stack",
	"$localization": {
		"en-US": {
			"8124be4e-b79c-478e-93c0-14ffb0ed2fb7": "More",
			"a9560852-5799-4a6f-8ab5-d74996f0ef2a": "Contact",
			"4917745c-ce70-4c3a-b381-06491e1fe87a": "Address",
			"d257c14a-c94f-40c1-98cd-313e81b7864b": "Management",
			"948d336a-45c7-467e-be87-f1de6d6b4702": "Credit level",
			"ae370435-b808-4b6d-b0de-c782f4292437": "In progress",
			"849efb71-386e-4ac2-b37c-0e35f81499c8": "Credit level by company"
		}
	},
	"$comment": "",
	"$items": [{
		"$layoutType": "stack",
		"$items": [{
			"$layoutType": "row",
			"$items": [{
				"$layoutType": "cell",
				"$bgColor": "transparent",
				"$widthXs": "12",
				"$widthSm": "8",
				"$widthMd": "8",
				"$widthLg": "6",
				"$items": [{
					"$bind": "BPCBPRC_BPRNAM",
					"$display": "table",
					"$arrayOptions": {
						"showPagination": true,
						"showSortFilter": true,
						"showSearch": true,
						"rowIndex": false
					},
					"$labelPosition": "top",
					"$isTitleHidden": true
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "4",
				"$widthMd": "4",
				"$widthLg": "6",
				"$bgColor": "darkgrey",
				"$items": [{
					"$bind": "BPCNUM",
					"$labelPosition": "top",
					"$labelAlign": "left"
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "4",
				"$widthMd": "4",
				"$widthLg": "6",
				"$bgColor": "darkgrey",
				"$items": [{
					"$bind": "BPCSHO",
					"$labelPosition": "top",
					"$labelAlign": "left",
					"$isTitleHidden": false
				}]
			}]
		}]
	}, {
		"$layoutType": "stack",
		"$items": [{
			"$layoutType": "row",
			"$items": [{
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "4",
				"$widthMd": "4",
				"$widthLg": "3",
				"$bgColor": "green",
				"$items": [{
					"$bind": "BPRLOG",
					"$labelPosition": "top",
					"$labelAlign": "left"
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "4",
				"$widthMd": "4",
				"$widthLg": "3",
				"$bgColor": "green",
				"$items": [{
					"$bind": "BPCSTA",
					"$labelPosition": "top",
					"$labelAlign": "left",
					"$isTitleHidden": false
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "4",
				"$widthMd": "4",
				"$widthLg": "3",
				"$bgColor": "green",
				"$items": [{
					"$bind": "LEGETT",
					"$labelPosition": "top",
					"$labelAlign": "left"
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "4",
				"$widthMd": "4",
				"$widthLg": "3",
				"$bgColor": "green",
				"$items": [{
					"$bind": "CRY_REF",
					"$labelPosition": "top",
					"$labelAlign": "left"
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "4",
				"$widthMd": "4",
				"$widthLg": "3",
				"$bgColor": "green",
				"$items": [{
					"$bind": "LAN_REF",
					"$labelPosition": "top",
					"$labelAlign": "left",
					"$refDescPosition": "right"
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "4",
				"$widthMd": "4",
				"$widthLg": "3",
				"$bgColor": "green",
				"$items": [{
					"$bind": "BCGCOD",
					"$labelPosition": "top",
					"$labelAlign": "left"
				}]
			}]
		}]
	}, {
		"$layoutType": "stack",
		"$collapsible": "collapsed",
		"$title": "{@8124be4e-b79c-478e-93c0-14ffb0ed2fb7}",
		"$items": [{
			"$layoutType": "row",
			"$items": [{
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "4",
				"$widthMd": "4",
				"$widthLg": "3",
				"$bgColor": "lightgreen",
				"$items": [{
					"$bind": "FCY_REF",
					"$labelPosition": "top"
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "4",
				"$widthMd": "4",
				"$widthLg": "3",
				"$bgColor": "lightgreen",
				"$items": [{
					"$bind": "BPCPYR_REF",
					"$labelPosition": "top"
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "4",
				"$widthMd": "4",
				"$widthLg": "3",
				"$bgColor": "lightgreen",
				"$items": [{
					"$bind": "EECNUM",
					"$labelPosition": "top"
				}]
			}]
		}, {
			"$layoutType": "row",
			"$items": [{
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "4",
				"$widthMd": "4",
				"$widthLg": "3",
				"$bgColor": "lightgreen",
				"$items": [{
					"$bind": "BETFCY",
					"$labelPosition": "top"
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "4",
				"$widthMd": "4",
				"$widthLg": "3",
				"$bgColor": "lightgreen",
				"$items": [{
					"$bind": "CUR_REF",
					"$labelPosition": "top"
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "4",
				"$widthMd": "4",
				"$widthLg": "3",
				"$bgColor": "lightgreen",
				"$items": [{
					"$bind": "NAF",
					"$labelPosition": "top"
				}]
			}]
		}]
	}, {
		"$layoutType": "stack",
		"$collapsible": "collapsed",
		"$title": "{@a9560852-5799-4a6f-8ab5-d74996f0ef2a}",
		"$items": [{
			"$bind": "BPCBPRBPA",
			"$display": "card",
			"$arrayOptions": {
				"showPagination": true,
				"showSortFilter": true,
				"showSearch": true,
				"rowIndex": false
			},
			"$isTitleHidden": true,
			"$tableHeaderShow": true,
			"$minWidth": 6,
			"$card": {
				"$layoutType": "stack",
				"$localization": {},
				"$items": [{
					"$layoutType": "stack",
					"$items": [{
						"$layoutType": "row",
						"$items": [{
							"$layoutType": "cell",
							"$widthXs": "12",
							"$widthSm": "12",
							"$widthMd": "12",
							"$widthLg": "12",
							"$bgColor": "sagegreen",
							"$items": [{
								"$bind": "BPABPAADDLIG1",
								"$labelPosition": "top",
								"$isTitleHidden": true
							}]
						}, {
							"$layoutType": "cell",
							"$bgColor": "sagegreen",
							"$items": [{
								"$bind": "BPABPAADDLIG2",
								"$labelPosition": "top",
								"$isTitleHidden": true
							}]
						}, {
							"$layoutType": "cell",
							"$bgColor": "sagegreen",
							"$items": [{
								"$bind": "BPABPAADDLIG3",
								"$labelPosition": "top",
								"$isTitleHidden": true
							}]
						}]
					}, {
						"$layoutType": "row",
						"$items": [{
							"$layoutType": "cell",
							"$widthXs": "6",
							"$widthSm": "6",
							"$widthMd": "6",
							"$widthLg": "6",
							"$bgColor": "transparent",
							"$items": [{
								"$bind": "BPAPOSCOD",
								"$labelPosition": "top",
								"$isTitleHidden": true
							}]
						}, {
							"$layoutType": "cell",
							"$widthXs": "6",
							"$widthSm": "6",
							"$widthMd": "6",
							"$widthLg": "6",
							"$bgColor": "transparent",
							"$items": [{
								"$bind": "BPACTY",
								"$labelPosition": "top",
								"$isTitleHidden": true
							}]
						}, {
							"$layoutType": "cell",
							"$widthXs": "12",
							"$widthSm": "12",
							"$widthMd": "12",
							"$widthLg": "12",
							"$bgColor": "transparent",
							"$items": [{
								"$bind": "BPACRYNAM",
								"$isTitleHidden": true
							}]
						}]
					}, {
						"$layoutType": "row",
						"$items": [{
							"$layoutType": "cell",
							"$widthXs": "6",
							"$widthSm": "6",
							"$widthMd": "6",
							"$widthLg": "6",
							"$bgColor": "transparent",
							"$items": [{
								"$bind": "BPABPAADD",
								"$labelPosition": "top"
							}]
						}, {
							"$layoutType": "cell",
							"$widthXs": "6",
							"$widthSm": "6",
							"$widthMd": "6",
							"$widthLg": "6",
							"$bgColor": "transparent",
							"$items": [{
								"$bind": "BPABPADES",
								"$labelPosition": "top"
							}]
						}, {
							"$layoutType": "cell",
							"$widthXs": "6",
							"$widthSm": "6",
							"$widthMd": "6",
							"$widthLg": "6",
							"$bgColor": "transparent",
							"$items": [{
								"$bind": "BPADEFFLG",
								"$labelPosition": "top"
							}]
						}, {
							"$layoutType": "cell",
							"$widthXs": "6",
							"$widthSm": "6",
							"$widthMd": "6",
							"$widthLg": "6",
							"$bgColor": "transparent",
							"$items": [{
								"$bind": "ADRVAL",
								"$labelPosition": "top"
							}]
						}]
					}]
				}, {
					"$layoutType": "stack",
					"$items": [{
						"$layoutType": "row",
						"$items": [{
							"$layoutType": "cell",
							"$bgColor": "transparent",
							"$items": [{
								"$bind": "FCYWEB",
								"$labelPosition": "top"
							}]
						}]
					}]
				}, {
					"$bind": "BPCBPRBPACOLTEL",
					"$display": "card",
					"$arrayOptions": {
						"showPagination": true,
						"showSortFilter": true,
						"showSearch": true,
						"rowIndex": false
					},
					"$minWidth": 6
				}, {
					"$bind": "BPCBPRBPACOLWEB",
					"$display": "card",
					"$arrayOptions": {
						"showPagination": true,
						"showSortFilter": true,
						"showSearch": true,
						"rowIndex": false
					},
					"$minWidth": 6
				}]
			},
			"$statusEnabled": "mono"
		}]
	}, {
		"$layoutType": "stack",
		"$collapsible": "collapsed",
		"$title": "{@4917745c-ce70-4c3a-b381-06491e1fe87a}",
		"$items": [{
			"$bind": "BPCBPRCNT",
			"$display": "card",
			"$arrayOptions": {
				"showPagination": true,
				"showSortFilter": true,
				"showSearch": true,
				"rowIndex": false
			},
			"$isTitleHidden": true,
			"$minWidth": 6,
			"$card": {
				"$layoutType": "stack",
				"$localization": {},
				"$items": [{
					"$layoutType": "stack",
					"$items": [{
						"$layoutType": "row",
						"$items": [{
							"$layoutType": "cell",
							"$widthXs": "2",
							"$widthSm": "2",
							"$widthMd": "2",
							"$widthLg": "2",
							"$bgColor": "transparent",
							"$items": [{
								"$bind": "CNTCNTTTL",
								"$isTitleHidden": true
							}]
						}, {
							"$layoutType": "cell",
							"$widthXs": "4",
							"$widthSm": "4",
							"$widthMd": "4",
							"$widthLg": "4",
							"$bgColor": "transparent",
							"$items": [{
								"$bind": "CNTCNTFNA",
								"$labelPosition": "top",
								"$isTitleHidden": true
							}]
						}, {
							"$layoutType": "cell",
							"$widthXs": "6",
							"$widthSm": "6",
							"$widthMd": "6",
							"$widthLg": "6",
							"$bgColor": "transparent",
							"$items": [{
								"$bind": "CNTCNTLNA",
								"$labelPosition": "top",
								"$isTitleHidden": true
							}]
						}, {
							"$layoutType": "cell",
							"$widthXs": "6",
							"$widthSm": "6",
							"$widthMd": "6",
							"$widthLg": "6",
							"$bgColor": "transparent",
							"$items": [{
								"$bind": "CNTCNTFNC",
								"$labelPosition": "top"
							}]
						}, {
							"$layoutType": "cell",
							"$widthXs": "6",
							"$widthSm": "6",
							"$widthMd": "6",
							"$widthLg": "6",
							"$bgColor": "transparent",
							"$items": [{
								"$bind": "CNTCNTSRV",
								"$labelPosition": "top"
							}]
						}]
					}]
				}, {
					"$layoutType": "stack",
					"$items": [{
						"$layoutType": "row",
						"$items": [{
							"$layoutType": "cell",
							"$bgColor": "transparent",
							"$widthXs": "6",
							"$widthSm": "6",
							"$widthMd": "6",
							"$widthLg": "6",
							"$items": [{
								"$bind": "CNTFAX",
								"$labelPosition": "top"
							}]
						}, {
							"$layoutType": "cell",
							"$bgColor": "transparent",
							"$widthXs": "6",
							"$widthSm": "6",
							"$widthMd": "6",
							"$widthLg": "6",
							"$items": [{
								"$bind": "CNTTEL",
								"$labelPosition": "top"
							}]
						}, {
							"$layoutType": "cell",
							"$bgColor": "transparent",
							"$widthXs": "6",
							"$widthSm": "6",
							"$widthMd": "6",
							"$widthLg": "6",
							"$items": [{
								"$bind": "CNTMOB",
								"$labelPosition": "top"
							}]
						}, {
							"$layoutType": "cell",
							"$bgColor": "transparent",
							"$widthXs": "6",
							"$widthSm": "6",
							"$widthMd": "6",
							"$widthLg": "6",
							"$items": [{
								"$bind": "CNTWEB",
								"$labelPosition": "top"
							}]
						}]
					}]
				}, {
					"$layoutType": "stack",
					"$items": [{
						"$layoutType": "row",
						"$items": [{
							"$layoutType": "cell",
							"$widthXs": "6",
							"$widthSm": "6",
							"$widthMd": "6",
							"$widthLg": "6",
							"$bgColor": "transparent",
							"$items": [{
								"$bind": "CNTCNTBIR",
								"$labelPosition": "top"
							}]
						}, {
							"$layoutType": "cell",
							"$widthXs": "6",
							"$widthSm": "6",
							"$widthMd": "6",
							"$widthLg": "6",
							"$bgColor": "transparent",
							"$items": [{
								"$bind": "CNTCNTMSS_REF",
								"$labelPosition": "top"
							}]
						}, {
							"$layoutType": "cell",
							"$widthXs": "6",
							"$widthSm": "6",
							"$widthMd": "6",
							"$widthLg": "6",
							"$bgColor": "transparent",
							"$items": [{
								"$bind": "CNTTCDEFFLG",
								"$labelPosition": "top"
							}]
						}, {
							"$layoutType": "cell",
							"$widthXs": "6",
							"$widthSm": "6",
							"$widthMd": "6",
							"$widthLg": "6",
							"$bgColor": "transparent",
							"$items": [{
								"$bind": "CNTCNTFBDMAG",
								"$labelPosition": "top"
							}]
						}]
					}]
				}]
			}
		}]
	}, {
		"$layoutType": "stack",
		"$collapsible": "collapsed",
		"$title": "{@d257c14a-c94f-40c1-98cd-313e81b7864b}",
		"$items": [{
			"$layoutType": "row",
			"$items": [{
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "4",
				"$widthMd": "4",
				"$widthLg": "3",
				"$bgColor": "green",
				"$items": [{
					"$bind": "BPCSNCDAT",
					"$labelPosition": "top"
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "4",
				"$widthMd": "4",
				"$widthLg": "3",
				"$bgColor": "green",
				"$items": [{
					"$bind": "PTE_REF",
					"$labelPosition": "top"
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "4",
				"$widthMd": "4",
				"$widthLg": "3",
				"$bgColor": "green",
				"$items": [{
					"$bind": "DEP",
					"$labelPosition": "top"
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "4",
				"$widthMd": "4",
				"$widthLg": "3",
				"$bgColor": "green",
				"$items": [{
					"$bind": "VACBPR_REF",
					"$labelPosition": "top"
				}]
			}]
		}, {
			"$layoutType": "stack",
			"$collapsible": "collapsed",
			"$title": "{@8124be4e-b79c-478e-93c0-14ffb0ed2fb7}",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$widthSm": "4",
					"$widthMd": "4",
					"$widthLg": "3",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "FREINV",
						"$labelPosition": "top"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "6",
					"$widthSm": "4",
					"$widthMd": "4",
					"$widthLg": "3",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "IME",
						"$labelPosition": "top"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "6",
					"$widthSm": "4",
					"$widthMd": "4",
					"$widthLg": "3",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "INVPER",
						"$labelPosition": "top"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "6",
					"$widthSm": "4",
					"$widthMd": "4",
					"$widthLg": "3",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "BPCINV",
						"$labelPosition": "top"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "6",
					"$widthSm": "4",
					"$widthMd": "4",
					"$widthLg": "3",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "BPCRSK",
						"$labelPosition": "top"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "6",
					"$widthSm": "4",
					"$widthMd": "4",
					"$widthLg": "3",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "BPCGRU",
						"$labelPosition": "top"
					}]
				}]
			}]
		}, {
			"$layoutType": "stack",
			"$title": "{@948d336a-45c7-467e-be87-f1de6d6b4702}",
			"$collapsible": "collapsed",
			"$items": [{
				"$layoutType": "stack",
				"$title": "{@ae370435-b808-4b6d-b0de-c782f4292437}",
				"$collapsible": "collapsed",
				"$items": [{
					"$layoutType": "row",
					"$items": [{
						"$layoutType": "cell",
						"$widthXs": "6",
						"$widthSm": "6",
						"$widthMd": "6",
						"$widthLg": "6",
						"$bgColor": "transparent",
						"$items": [{
							"$bind": "ROSTCTL",
							"$labelPosition": "top"
						}]
					}, {
						"$layoutType": "cell",
						"$widthXs": "6",
						"$widthSm": "6",
						"$widthMd": "6",
						"$widthLg": "6",
						"$bgColor": "transparent",
						"$items": [{
							"$bind": "ROSTCTLLEV",
							"$labelPosition": "top"
						}]
					}, {
						"$layoutType": "cell",
						"$widthXs": "6",
						"$widthSm": "6",
						"$widthMd": "6",
						"$widthLg": "6",
						"$bgColor": "transparent",
						"$items": [{
							"$bind": "ROSTAUZ",
							"$labelPosition": "top"
						}]
					}, {
						"$layoutType": "cell",
						"$widthXs": "6",
						"$widthSm": "6",
						"$widthMd": "6",
						"$widthLg": "6",
						"$bgColor": "transparent",
						"$items": [{
							"$bind": "ROST",
							"$labelPosition": "top"
						}]
					}]
				}]
			}, {
				"$layoutType": "stack",
				"$collapsible": "collapsed",
				"$title": "{@849efb71-386e-4ac2-b37c-0e35f81499c8}",
				"$items": [{
					"$bind": "OSTCLTCPY",
					"$display": "card",
					"$arrayOptions": {
						"showPagination": true,
						"showSortFilter": true,
						"showSearch": true,
						"rowIndex": false
					},
					"$isTitleHidden": true,
					"$minWidth": 6,
					"$card": {
						"$layoutType": "stack",
						"$localization": {},
						"$items": [{
							"$layoutType": "stack",
							"$items": [{
								"$layoutType": "row",
								"$items": [{
									"$layoutType": "cell",
									"$bgColor": "transparent",
									"$items": [{
										"$bind": "ROSTCPY_REF",
										"$labelPosition": "top"
									}]
								}]
							}, {
								"$layoutType": "row",
								"$items": [{
									"$layoutType": "cell",
									"$widthXs": "12",
									"$widthSm": "12",
									"$widthMd": "12",
									"$widthLg": "12",
									"$bgColor": "transparent",
									"$items": [{
										"$bind": "ROSTCPYAUZ",
										"$labelPosition": "top",
										"$labelAlign": "left",
										"$items": [{
											"$bind": "ROSTCPYCUR_REF"
										}]
									}]
								}]
							}]
						}]
					}
				}]
			}]
		}]
	}]
};
exports.dashboards = {
	"$customersDashboard": {
		"$dashboardName": "$customersDashboard",
		"$title": "Customer Dashboard",
		"$description": "",
		"$vignettes": {
			"$x3CustomersList": {
				"$uuid": "$x3CustomersList",
				"$displayStyle": "$full"
			},
			"$x3CustomersListIco": {
				"$uuid": "$x3CustomersList",
				"$displayStyle": "$link"
			},
			"$tasksList": {
				"$uuid": "$tasksList",
				"$displayStyle": "$full"
			},
			"$localCustomerTotals": {
				"$uuid": "$localCustomerTotals",
				"$displayStyle": "$full"
			},
			"$localOverviewSales_rev_perc": {
				"$uuid": "$localOverviewSales_rev_perc",
				"$displayStyle": "$full"
			},
			"$localOverviewSalesLeads": {
				"$uuid": "$localOverviewSalesLeads",
				"$displayStyle": "$full"
			},
			"$localStatVEN42": {
				"$uuid": "$localStatVEN42",
				"$displayStyle": "$full"
			},
			"$localStatVEN420": {
				"$uuid": "$localStatVEN420",
				"$displayStyle": "$full"
			},
			"CRM074": {
				"$uuid": "CRM074",
				"$displayStyle": "$full"
			},
			"CRM075": {
				"$uuid": "CRM075",
				"$displayStyle": "$full"
			},
			"VEN076": {
				"$uuid": "VEN076",
				"$displayStyle": "$full"
			},
			"VEN007": {
				"$uuid": "VEN007",
				"$displayStyle": "$full"
			},
			"VEN073": {
				"$uuid": "VEN073",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Dashboard",
				"$items": [{
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3CustomersListIco"
					}]
				}, {
					"$layoutType": "tile",
					"$size": "medium",
					"$bgColor": "skyblue",
					"$title": "Quote values",
					"$items": [{
						"$bind": "$localCustomerTotals",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "quotesValue",
								"$gauge": {
									"$bindMin": "min",
									"$bindMax": "quotesMax",
									"segments": [{
										"propStart": 0,
										"propEnd": 0.75,
										"color": "#DF5353"
									}, {
										"propStart": 0.75,
										"propEnd": 0.85,
									}, {
										"propStart": 0.85,
										"propEnd": 1,
										"color": "#55BF3B"
									}]
								}
							}]
						}
					}]

				}, {
					"$layoutType": "tile",
					"$title": "Sales leads",
					"$size": "large",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "$localOverviewSalesLeads",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": false,
								"$style": "line",
								"$display": "table",
								"$article": {
									"$items": [{
										"$bind": "date"
									}, {
										"$bind": "numLeads"
									}, {
										"$bind": "numDeals"
									}]
								}
							}]
						}
					}]
				}, {
					"$layoutType": "tile",
					"$title": "Test Stats VEN42",
					"$size": "full",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "$localStatVEN42"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "Test Stats VEN42",
					"$size": "full",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "$localStatVEN420"
					}]
				}, {
					"$layoutType": "tile",
					"$size": "large",
					"$bgColor": "skyblue",
					"$title": "Monthly revenues",
					"$items": [{
						"$bind": "$localOverviewSales_rev_perc",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "revMonthly",
								"$gauge": {
									"$bindMin": "revMonthlyMin",
									"$bindMax": "revMonthlyMax",
									"segments": [{
										"propStart": 0,
										"propEnd": 0.75,
										"color": "#DF5353"
									}, {
										"propStart": 0.75,
										"propEnd": 0.85,
										"color": "#FF5800"
									}, {
										"propStart": 0.85,
										"propEnd": 1,
										"color": "#55BF3B"
									}]
								}
							}]
						}
					}]
				}]
			}, {

				"$layoutType": "hubGroup",
				"$title": "Requests",
				"$items": [{
					"$layoutType": "tile",
					"$title": "CRM074",
					"$size": "full",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "CRM074",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$layoutType": "row"
							}, {
								"$bind": "$criteria",
								"$isTitleHidden": true
							}, {
								"$bind": "headerMessage",
								"$isTitleHidden": true
							}, {
								"$bind": "levelMessage",
								"$isTitleHidden": true
							}, {
								"$bind": "$resources",
								"$isTitleHidden": false,
								"$seriesOptions": {
									"COUNT": {
										"isHidden": false
									}
								},
								"$style": "pie",
								"$chartOptions": {
									"isLegendHidden": true
								},
								"$isXLabelsHidden": false,
								"$isYLabelsHidden": false,
								"$isXLabelHidden": false,
								"$isYLabelHidden": false,
								"$isLegendHidden": true,
								"$isGridLineHidden": false,
								"$openDetail": true,
								"$isLabelsHidden": false
							}]

						}
					}]
				}, {
					"$layoutType": "tile",
					"$size": "large",
					"$bgColor": "skyblue",
					"$title": "CRM075",
					"$items": [{
						"$bind": "CRM075",
					}]
				}, {
					"$layoutType": "tile",
					"$size": "large",
					"$bgColor": "skyblue",
					"$title": "VEN076",
					"$items": [{
						"$bind": "VEN076",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$criteria",
								"$isTitleHidden": true
							}, {
								"$bind": "headerMessage",
								"$isTitleHidden": true
							}, {
								"$bind": "levelMessage",
								"$isTitleHidden": true
							}, {
								"$bind": "$resources",
								"$isTitleHidden": false,
								"$style": "bar",
								"$chartOptions": {
									"isXLabelHidden": false,
									"isLegendHidden": true
								},
								"$isXLabelsHidden": false,
								"$isYLabelsHidden": false,
								"$isXLabelHidden": false,
								"$isYLabelHidden": false,
								"$isLegendHidden": true,
								"$isGridLineHidden": false,
								"$openDetail": true,
								"$isLabelsHidden": false
							}]
						}
					}]
				}, {
					"$layoutType": "tile",
					"$size": "large",
					"$bgColor": "skyblue",
					"$title": "VEN007",
					"$items": [{
						"$bind": "VEN007",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$criteria",
								"$isTitleHidden": true
							}, {
								"$bind": "headerMessage",
								"$isTitleHidden": true
							}, {
								"$bind": "levelMessage",
								"$isTitleHidden": true
							}, {
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$display": "table",
								"$arrayOptions": {
									"showPagination": true,
									"showSortFilter": true,
									"rowIndex": true,
									"showSearch": true
								},
								"$tableHeaderShow": true,
								"$table": [{
									"$bind": "BPCNAM",
									"$title": "Company Name",
									"$type": "application/x-string",
									"$titleOrig": "Company Name",
									"$widthType": "percent",
									"$widthVal": 65,
									"$imgHeight": "small"
								}, {
									"$bind": "BCGCOD",
									"$title": "Category",
									"$type": "application/x-string",
									"$titleOrig": "Category",
									"$widthType": "percent",
									"$widthVal": 35,
									"$imgHeight": "small"
								}]
							}]
						}
					}]
				}, {
					"$layoutType": "tile",
					"$size": "large",
					"$bgColor": "skyblue",
					"$title": "VEN073",
					"$items": [{
						"$bind": "VEN073",
					}]
				}]

			}, {
				"$layoutType": "hubGroup",
				"$title": "Customer List",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Customers list",
					"$size": "all",
					"$items": [{
						"$bind": "$x3CustomersList",
						"$article": {
							"$pageActionSettings": [{
								"name": "BPCLOCK",
								"icon": {
									"css": "fa fa-lock",
									"name": "lock"
								},
								"$title": "Bloquer",
								"options": {
									"footerHeader": true,
									"refreshPage": false,
									"multiselection": true
								}
							}, {
								"name": "BPCUNLOCK",
								"icon": {
									"css": "fa fa-unlock-alt",
									"name": "unlock-alt"
								},
								"$title": "Débloquer",
								"options": {
									"footerHeader": true,
									"refreshPage": false,
									"multiselection": true
								}
							}],
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "card",
								"$detailsLink": "$details",
								"$detailLinkArticle": _customerArticle,
								"$card": {
									"$layoutType": "stack",
									"$items": [{
										"$bind": "BPCNUM"
									}, {
										"$bind": "BPCNAM"
									}, {
										"$bind": "TEXTDES0"
									}, {
										"$bind": "RPOSCOD"
									}, {
										"$bind": "BPCSTA"
									}, {
										"$bind": "BPCTYP"
									}]
								}
							}]
						}
					}]
				}, {
					"$layoutType": "tile",
					"$title": "Some tasks",
					"$size": "all",
					"$items": [{
						"$bind": "$tasksList"
					}]
				}]
			}]
		}
	},
	"STD_X3_CUSTOMER_DETAILS_DASHBOARD": {
		"$dashboardName": "STD_X3_CUSTOMER_DETAILS_DASHBOARD",
		"$title": "STD_X3_CUSTOMER_DETAILS_DASHBOARD",
		"$description": "",
		"$vignettes": {
			"$x3CustomersList": {
				"$uuid": "$x3CustomersList",
				"$displayStyle": "$full"
			}
		}
	}
};

exports.gadgets = {
	"$x3CustomersList": {
		"$type": "$representation",
		"$title": "Customers list",
		"entity": "BPCUSTOMER",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "BPCUSTOMERM",
		"facet": "$query",
		"icon": "s-m-sales-customers-list"
	},
	"$tasksList": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "$localTodo",
		"action": "$query",
		"representation": "$localTodo",
		"facet": "$query"
	},
	"$localCustomerTotals": {
		"$type": "$representation",
		"$title": "Totals",
		"entity": "$localCustomer",
		"action": "$details",
		"representation": "$localCustomer",
		"facet": "$details",
		"keyParameter": "10"
	},
	"$localOverviewSalesLeads": {
		"$type": "$representation",
		"$title": "Leads vs Deals",
		"entity": "$localOverviewSalesLeads",
		"action": "$query",
		"representation": "$localOverviewSalesLeads",
		"facet": "$query",
	},
	"$localOverviewSales_rev_perc": {
		"$type": "$representation",
		"$title": "Overview",
		"entity": "$localOverviewSales",
		"action": "$details",
		"representation": "$localOverviewSales",
		"facet": "$details",
		"keyParameter": "10"
	},
	"$localStatVEN42": {
		"entity": "$localVEN42",
		"$type": "$stats",
		"$title": "Test stats VEN42",
		"$description": "Sales by Region",
		"icon": "",
		"parameters": {
			"portview": {
				"title": "portview",
				"value": "TESTLOCAL"
			},
			"count": {
				"title": "count",
				"value": "10"
			}
		},
		"statName": "$localVEN42",
		"action": "$query",
		"representation": "STATS~$localVEN42.$cube",
		"facet": "$cube",
		"$uuid": "$uuidVEN42"
	},
	"$localStatVEN420": {
		"entity": "$localVEN42",
		"$type": "$stats",
		"$title": "Test stats VEN42",
		"$description": "Sales by Region",
		"icon": "",
		"parameters": {
			"portview": {
				"title": "portview",
				"value": "TESTLOCAL"
			},
			"count": {
				"title": "count",
				"value": "10"
			}
		},
		"statName": "$localVEN42",
		"action": "$query",
		"representation": "STATS~$localVEN42.$cube",
		// FDB - This is the facet that allow the cart display
		"facet": "$cubechart",
		"$uuid": "$uuidVEN42"
	},
	"VEN073": {
		"$type": "$request",
		"$title": "My customers without any orders (3 months)",
		"$description": "My customers without any orders (3 months)",
		"parameters": {
			"forcedExecution": {
				"title": "forcedExecution",
				"value": "true"
			},
			"frequency": {
				"title": "frequency",
				"value": "1"
			},
			"level": {
				"title": "level",
				"value": "1"
			},
			"displayLineNum": {
				"title": "displayLineNum",
				"value": "false"
			}
		},
		"requestName": "VEN073",
		"requestLevel": "99",
		"action": "$query",
		"representation": "QUERY~VEN073~99",
		"facet": "$query",
		"endpoint": "x3.erp.GX3APP",
		"$uuid": "VEN073"
	},
	"VEN007": {
		"$type": "$request",
		"$title": "Inactive Customers",
		"$description": "Inactive Customers",
		"parameters": {
			"forcedExecution": {
				"title": "forcedExecution",
				"value": "true"
			},
			"frequency": {
				"title": "frequency",
				"value": "1"
			},
			"level": {
				"title": "level",
				"value": "1"
			},
			"displayLineNum": {
				"title": "displayLineNum",
				"value": "false"
			}
		},
		"requestName": "VEN007",
		"requestLevel": "99",
		"action": "$query",
		"representation": "QUERY~VEN007~99",
		"facet": "$query",
		"endpoint": "x3.erp.GX3APP",
		"$uuid": "VEN007"
	},
	"VEN076": {
		"$type": "$request",
		"$title": "Annual ranking of customers margin",
		"$description": "Annual ranking of customers margin",
		"parameters": {
			"forcedExecution": {
				"title": "forcedExecution",
				"value": "true"
			},
			"frequency": {
				"title": "frequency",
				"value": "1"
			},
			"displayLineNum": {
				"title": "displayLineNum",
				"value": "false"
			},
			"level": {
				"title": "level",
				"value": "2"
			}
		},
		"requestName": "VEN076",
		"requestLevel": "99",
		"action": "$query",
		"representation": "QUERY~VEN076~99",
		"facet": "$query",
		"endpoint": "x3.erp.GX3APP",
		"$uuid": "VEN076"
	},
	"CRM075": {
		"$type": "$request",
		"$title": "Annual ranking of customers appointments",
		"$description": "Annual ranking of customers appointments",
		"parameters": {
			"forcedExecution": {
				"title": "forcedExecution",
				"value": "true"
			},
			"frequency": {
				"title": "frequency",
				"value": "1"
			},
			"level": {
				"title": "level",
				"value": "2"
			},
			"displayLineNum": {
				"title": "displayLineNum",
				"value": "false"
			}
		},
		"requestName": "CRM075",
		"requestLevel": "99",
		"action": "$query",
		"representation": "QUERY~CRM075~99",
		"facet": "$query",
		"endpoint": "x3.erp.GX3APP",
		"$uuid": "CRM075"
	},
	"CRM074": {
		"$type": "$request",
		"$title": "Annual ranking of customers calls",
		"$description": "Annual ranking of customers calls",
		"parameters": {
			"forcedExecution": {
				"title": "forcedExecution",
				"value": "true"
			},
			"frequency": {
				"title": "frequency",
				"value": "1"
			},
			"level": {
				"title": "level",
				"value": "2"
			},
			"displayLineNum": {
				"title": "displayLineNum",
				"value": "false"
			}
		},
		"requestName": "CRM074",
		"requestLevel": "99",
		"action": "$query",
		"representation": "QUERY~CRM074~99",
		"facet": "$query",
		"endpoint": "x3.erp.GX3APP",
		"$uuid": "CRM074"
	}
};
});

define('syracuse-tablet/html/js/demos/utils',['require','exports','module'],function (require, exports, module) {"use strict";


exports.addToApp = function(app, toAdd) {
	if (toAdd.gadgets) {
		Object.keys(toAdd.gadgets).forEach(function(key) {
			if (app.$gadgets[key]) {
				console.log("Duplicate gadget name: " + key);
			}
			app.$gadgets[key] = toAdd.gadgets[key];
		});
	}
	if (toAdd.dashboards) {
		Object.keys(toAdd.dashboards).forEach(function(key) {
			if (app.$dashboards[key]) {
				console.log("Duplicate dashboard name: " + key);
			}
			app.$dashboards[key] = toAdd.dashboards[key];
		});
	}
};
});

define('syracuse-tablet/html/js/demos/_entities/entTodos',['require','exports','module'],function (require, exports, module) {"use strict";

var _todos = [{
	$uuid: "1",
	date: "2015-02-01 09:00:00",
	who: "Mr. Miller",
	desc: "Call",
	phone: "+771 896520 4183"
}, {
	$uuid: "2",
	date: "2015-02-09 10:00:00",
	who: "Mr. Miller",
	desc: "Meeting"
}, {
	$uuid: "3",
	date: "2015-03-04 09:00:00",
	who: "Mr. Heinz",
	desc: "Milestone definition"
}, {
	$uuid: "4",
	date: "2015-03-05 15:00:00",
	who: "Mr. Schmidt",
	desc: "Project review",
	phone: "+771 896520 4183"
}, {
	$uuid: "5",
	date: "2015-03-08 14:00:00",
	who: "Mr. Miller",
	desc: "Call"
}, {
	$uuid: "6",
	date: "2015-03-09 15:40:00",
	who: "Mr. Miller",
	desc: "Call"
}, {
	$uuid: "7",
	date: "2015-03-10 15:50:00",
	who: "Mr. Miller",
	desc: "Call"
}, {
	$uuid: "8",
	date: "2015-03-11 14:00:00",
	who: "Mr. Miller",
	desc: "Call"
}, {
	$uuid: "9",
	date: "2015-03-11 14:00:00",
	who: "Mr. Miller",
	desc: "Call"
}, {
	$uuid: "10",
	date: "2015-03-11 14:00:00",
	who: "Mr. Miller",
	desc: "Call"
}, {
	$uuid: "11",
	date: "2015-03-11 14:00:00",
	who: "Mr. Miller",
	desc: "Call"
}, {
	$uuid: "12",
	date: "2015-03-11 14:00:00",
	who: "Mr. Miller",
	desc: "Call"
}, {
	$uuid: "13",
	date: "2015-03-11 14:00:00",
	who: "Mr. Miller",
	desc: "Call",
}];

exports.entity = {
	$entityName: "$localTodo",
	$value: "{desc}",
	$properties: {
		who: {
			$type: "application/x-string",
			$title: "Who"
		},
		desc: {
			$type: "application/x-string",
			$title: "Description"
		},
		phone: {
			$type: "application/x-string",
			$title: "Phone",
			$format: "$phone"
		},
		date: {
			$type: "application/x-datetime",
			$title: "Date"
		},
	},
	$articles: {},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve(_todos[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _todos
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/_entities/entOverviewSales',['require','exports','module'],function (require, exports, module) {"use strict";

var _data = {
	$uuid: "1",
	revMonthlyMin: 100000,
	revMonthly: 180000,
	revMonthlyMax: 200000,
	revMonthlyPerc: 92
};

exports.entity = {
	$entityName: "$localOverviewSales",
	$value: "{revMonthly}",
	$properties: {
		revMonthlyMin: {
			$type: "application/x-decimal",
			$title: "Min"
		},
		revMonthlyMax: {
			$type: "application/x-decimal",
			$title: "Target"
		},
		revMonthly: {
			$type: "application/x-decimal",
			$title: "Revenue"
		},
		revMonthlyPerc: {
			$type: "application/x-decimal",
			$title: "Monthly Target"
		},
	},
	$articles: {},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve(_data);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: [_data]
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/_entities/entOverviewSalesLeads',['require','exports','module'],function (require, exports, module) {"use strict";

var _data = [{
	$uuid: "1",
	date: "2014-12-05",
	numLeads: 50,
	numDeals: 40,
}, {
	$uuid: "1",
	date: "2014-12-12",
	numLeads: 53,
	numDeals: 45,
}, {
	$uuid: "1",
	date: "2014-12-15",
	numLeads: 54,
	numDeals: 47,
}, {
	$uuid: "1",
	date: "2014-12-22",
	numLeads: 53,
	numDeals: 49,
}, {
	$uuid: "1",
	date: "2014-12-29",
	numLeads: 52,
	numDeals: 52,
}];

exports.entity = {
	$entityName: "$localOverviewSalesLeads",
	$value: "{date}",
	$properties: {
		date: {
			$type: "application/x-date",
			$title: "Date"
		},
		numLeads: {
			$type: "application/x-decimal",
			$title: "Leads"
		},
		numDeals: {
			$type: "application/x-decimal",
			$title: "Deals"
		}
	},
	$articles: {},
	$prototype: function(proto) {

		// Add some chart information in $query prototype
		var res = proto.$properties && proto.$properties.$resources;
		if (res) {
			res.$axes = [{
				$title: "Date",
				$hierarchies: [
					["date"]
				]
			}, {
				$title: "Number",
				$hierarchies: [
					["$measures"]
				]
			}];
			res.$cube = {
				$style: "column",
				$title: "Leads vs Deals",
				$hierarchies: {
					date: {
						$properties: ["date"]
					}
				},
				$measures: {
					numLeads: {},
					numDeals: {}
				}
			};
		}
	},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve(_data[0]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/_entities/entCustomers',['require','exports','module','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {"use strict";
var utils = require('syracuse-tablet/html/js/helpers/utils');

var _names = [
	"Acme, inc.",
	"Widget Corp",
	"123 Warehousing",
	"Demo Company",
	"Smith and Co.",
	"Foo Bars",
	"ABC Telecom",
	"Fake Brothers",
	"QWERTY Logistics",
	"Demo, inc.",
	"Sample Company",
	"Sample, inc",
	"Acme Corp",
	"Allied Biscuit",
	"Ankh-Sto Associates",
	"Extensive Enterprise",
	"Galaxy Corp",
	"Globo-Chem",
	"Mr. Sparkle",
	"Globex Corporation",
	"LexCorp",
	"LuthorCorp",
	"North Central Positronics",
	"Omni Consimer Products",
	"Praxis Corporation",
	"Sombra Corporation",
	"Sto Plains Holdings",
	"Tessier-Ashpool",
	"Wayne Enterprises",
	"Wentworth Industries",
	"ZiffCorp",
	"Bluth Company",
	"Strickland Propane",
	"Thatherton Fuels",
	"Three Waters",
	"Water and Power",
	"Western Gas & Electric",
	"Mammoth Pictures",
	"Mooby Corp",
	"Gringotts",
	"Thrift Bank",
	"Flowers By Irene",
	"The Legitimate Businessmens Club",
	"Osato Chemicals",
	"Transworld Consortium",
	"Universal Export",
	"United Fried Chicken",
	"Virtucon",
	"Kumatsu Motors",
	"Keedsler Motors",
	"Powell Motors",
	"Industrial Automation",
	"Sirius Cybernetics Corporation",
	"U.S. Robotics and Mechanical Men",
	"Colonial Movers",
	"Corellian Engineering Corporation",
	"Incom Corporation",
	"General Products",
	"Leeding Engines Ltd.",
	"Blammo",
	"Input, Inc.",
	"Mainway Toys",
	"Videlectrix",
	"Zevo Toys",
	"Ajax",
	"Axis Chemical Co.",
	"Barrytron",
	"Carrys Candles",
	"Cogswell Cogs",
	"Spacely Sprockets",
	"General Forge and Foundry",
	"Duff Brewing Company",
	"Dunder Mifflin",
	"General Services Corporation",
	"Monarch Playing Card Co.",
	"Krustyco",
	"Initech",
	"Roboto Industries",
	"Primatech",
	"Sonky Rubber Goods",
	"St. Anky Beer",
	"Stay Puft Corporation",
	"Vandelay Industries",
	"Wernham Hogg",
	"Gadgetron",
	"Burleigh and Stronginthearm",
	"BLAND Corporation",
	"Nordyne Defense Dynamics",
	"Petrox Oil Company",
	"Roxxon",
	"McMahon and Tate",
	"Sixty Second Avenue",
	"Charles Townsend Agency",
	"Spade and Archer",
	"Megadodo Publications",
	"Rouster and Sideways",
	"C.H. Lavatory and Sons",
	"Globo Gym American Corp",
	"The New Firm"
];

var _customers = [];
for (var c = 10000; c < 10100; c++) {
	_customers.push({
		$uuid: "" + (c - 10000), // to match array index
		bpcnum: "" + c,
		name: _names[c - 10000],

		ordersValue: 1000000 + ((c - 10000) * 200000 % 500000),
		ordersMax: 1800000,
		quotesValue: 500000 + ((c - 10000) * 2000 % 50000),
		quotesMax: 1200000,
		invoicesValue: 10000 + ((c - 10000) * 2000 % 50000),
		invoicesMax: 120000,
		min: 1000,
		addr1: "Rue Fructidor",
		addr2: "75834 Paris Cedex 17"
	});
}

exports.entity = {
	$entityName: "$localCustomer",
	$value: "{name}",
	$properties: {
		bpcnum: {
			$type: "application/x-string",
			$title: "Customer"
		},
		name: {
			$type: "application/x-string",
			$title: "Name",
		},
		addr1: {
			$type: "application/x-string",
			$title: "Street",
		},
		addr2: {
			$type: "application/x-string",
			$title: "Address",
		},
		ordersValue: {
			$type: "application/x-decimal",
			$title: "Orders value"
		},
		min: {
			$type: "application/x-decimal",
			$title: "General min value"
		},
		quotesValue: {
			$type: "application/x-decimal",
			$title: "Quotes value"
		},
		invoicesValue: {
			$type: "application/x-decimal",
			$title: "Invoices value"
		},
		ordersMax: {
			$type: "application/x-decimal",
			$title: "Max"
		},
		quotesMax: {
			$type: "application/x-decimal",
			$title: "Max"
		},
		invoicesMax: {
			$type: "application/x-decimal",
			$title: "Max"
		}
	},
	$prototype: function(proto) {
		// Add some chart information in $query prototype
		var res = utils.getPropByPath(proto, "$properties.$resources.$item.$links") || {};
		// Link to use when user click on row detail link
		res["DASHBOARD"] = {
			$title: "Detail dashboard",
			$url: "{$baseUrl}/$mobileDashboards?dashboard=$localCustomerDashboard&parameters=bpcnum%3D%7Bbpcnum%7D"
		};
	},
	$articles: {
		$query: {
			"$layoutType": "stack",
			"$items": [{
				"$bind": "$resources",
				"$detailsLink": "DASHBOARD",
				"$display": "card",
				"$cardsPerLine": 4,
				"$article": {
					"$items": [{
						"$bind": "bpcnum"
					}, {
						"$bind": "name"
					}, {
						"$bind": "addr1"
					}, {
						"$bind": "addr2"
					}]
				}
			}]
		}
	},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve(_customers[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _customers
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/_entities/entCustomerRevenues',['require','exports','module'],function (require, exports, module) {"use strict";

var _months = [
	"January",
	"February",
	"March",
	"April",
	"May",
	"June",
	"July",
	"August",
	"September",
	"October",
	"November",
	"December"
];

var _revs = [];
var _uuid = 0;
for (var c = 10000; c < 10100; c++) {
	for (var m = 0; m < 12; m++) {
		_revs.push({
			$uuid: "" + _uuid,
			bpcnum: "" + c,
			month: _months[m],
			revenue: 20000 + (m * (12 + (c % 12)) % 40) * 20000
		});

		_uuid++;
	}
}

exports.entity = {
	$entityName: "$localCustomerRevenue",
	$value: "{name}",
	$properties: {
		bpcnum: {
			$type: "application/x-string",
			$title: "ID"
		},
		month: {
			$type: "application/x-string",
			$title: "Month"
		},
		revenue: {
			$type: "application/x-decimal",
			$title: "Revenue"
		}
	},
	$prototype: function(proto) {
		// Add some chart information in $query prototype
		var res = proto.$properties && proto.$properties.$resources;
		if (res) {
			res.$axes = [{
				$title: "Month",
				$hierarchies: [
					["month"]
				]
			}, {
				$hierarchies: [
					["$measures"]
				]
			}];
			res.$cube = {
				$title: "Revenue",
				$hierarchies: {
					month: {
						$properties: ["month"]
					}
				},
				$measures: {
					revenue: {}
				}
			};
		}
	},
	$articles: {},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve(_revs[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _revs
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/_entities/entStatsVEN42',['require','exports','module'],function (require, exports, module) {"use strict";

var _proto = {

	"$baseUrl": "/mobile1/x3/erp/SEEDTEST",
	"$url": "{$baseUrl}/STATS('$localVEN42')?representation=STATS~$localVEN42.$cube&role={$role}",
	"$title": "Sales by Region",
	"$type": "application/json; vnd.sage=syracuse.presentation=x3.erp.superv/STATS('$localVEN42')",
	"$methods": "GET",
	"codeStat": "$localVEN42",
	"$properties": {
		"datstart1": {
			"$type": "application/x-date",
			"$title": "Period start 1",
			"$isAdvanced": true,
			"$links": {
				"$details": {
					"$url": "{$baseUrl}/STATS('$localVEN42')?representation=STATS~$localVEN42.$cube&{linkstartP}",
					"$type": "application/json;vnd.sage=syracuse"
				}
			},
			"$isExcluded": true
		},
		"datstart2": {
			"$type": "application/x-date",
			"$title": "Period start 2",
			"$isAdvanced": true,
			"$links": {
				"$details": {
					"$url": "{$baseUrl}/STATS('VEN42')?representation=STATS~VEN42.$cube&{linkstartP}",
					"$type": "application/json;vnd.sage=syracuse"
				}
			},
			"$isExcluded": true
		},
		"linkstartP": {
			"$type": "application/x-string",
			"$isExcluded": true
		},
		"datend1": {
			"$type": "application/x-date",
			"$title": "Period end 1",
			"$isAdvanced": true,
			"$links": {
				"$details": {
					"$url": "{$baseUrl}/STATS('VEN42')?representation=STATS~VEN42.$cube&{linkendP}",
					"$type": "application/json;vnd.sage=syracuse"
				}
			},
			"$isExcluded": true
		},
		"datend2": {
			"$type": "application/x-date",
			"$title": "Period end 2",
			"$isAdvanced": true,
			"$links": {
				"$details": {
					"$url": "{$baseUrl}/STATS('VEN42')?representation=STATS~VEN42.$cube&{linkendP}",
					"$type": "application/json;vnd.sage=syracuse"
				}
			},
			"$isExcluded": true
		},
		"linkendP": {
			"$type": "application/x-string",
			"$isExcluded": true
		},
		"def_company": {
			"$type": "application/x-string",
			"$title": "Company",
			"$isAdvanced": true,
			"$links": {
				"$details": {
					"$type": "application/json;vnd.sage=syracuse",
					"$url": "{$baseUrl}/COMPANY('{def_company}')?representation=COMPANY.$details&role={$role}"
				}
			},
			"$isExcluded": true
		},
		"$resources": {
			"$type": "application/x-array",
			"$provType": "PORTALSTA",
			"$criteria": {
				"COMPANY": {
					"$type": "application/x-string",
					"$maxlength": 5,
					"$title": "Company",
					"$links": {
						"$details": {
							"$type": "application/json;vnd.sage=syracuse",
							"$url": "{$baseUrl}/COMPANY('{COMPANY}')?representation=COMPANY.$details&role={$role}",
							"$target": "main"
						}
					}
				},
				"DATBEG1": {
					"$type": "application/x-date",
					"$title": ""
				},
				"DATEND1": {
					"$type": "application/x-date",
					"$title": ""
				},
				"DATBEG2": {
					"$type": "application/x-date",
					"$title": ""
				},
				"DATEND2": {
					"$type": "application/x-date",
					"$title": ""
				}
			},
			"$item": {
				"$type": "application/json",
				"$url": "{$baseUrl}/stats('VEN42')?representation=$cube('VEN42')&role={$role}",
				"$title": "Sales by Region",
				"$properties": {
					"linkDown": {
						"$type": "application/x-string",
						"$isExcluded": true
					},
					"dateStat": {
						"$type": "application/x-date",
						"$capabilities": "sort,filter",
						"$isExcluded": true
					},
					"CRY": {
						"$title": "Pays",
						"$capabilities": "sort,filter",
						"$type": "application/x-string",
						"$links": {
							"$details": {
								"$type": "application/json;vnd.sage=syracuse",
								"$url": "{$baseUrl}/TABCOUNTRY('{CRY}')?representation=TABCOUNTRY.$details&role={$role}",
								"$target": "main"
							}
						}
					},
					"C_CRY": {
						"$capabilities": "sort,filter",
						"$type": "application/x-string"
					},
					"POSCOD": {
						"$title": "Code postal",
						"$capabilities": "sort,filter",
						"$type": "application/x-string",
						"$constraints": {
							"$maxLength": 3
						},
						"$isHidden": false,
						"$isParameter": true
					},
					"C_POSCOD": {
						"$capabilities": "sort,filter",
						"$type": "application/x-string"
					},
					"CTY": {
						"$title": "Ville",
						"$capabilities": "sort,filter",
						"$type": "application/x-string",
						"$constraints": {
							"$maxLength": 3
						},
						"$isHidden": false,
						"$isParameter": true
					},
					"C_CTY": {
						"$capabilities": "sort,filter",
						"$type": "application/x-string"
					},
					"BPCNUM": {
						"$title": "Client",
						"$capabilities": "sort,filter",
						"$type": "application/x-string",
						"$links": {
							"$details": {
								"$type": "application/json;vnd.sage=syracuse",
								"$url": "{$baseUrl}/BPARTNER('{BPCNUM}')?representation=BPARTNER.$details&role={$role}",
								"$target": "main"
							}
						}
					},
					"C_BPCNUM": {
						"$capabilities": "sort,filter",
						"$type": "application/x-string"
					},
					"amount1": {
						"$type": "application/x-decimal",
						"$precision": 15,
						"$scale": 2,
						"$format": "#,###.00",
						"$title": "Actual Year N"
					},
					"amount2": {
						"$type": "application/x-decimal",
						"$precision": 15,
						"$scale": 2,
						"$format": "#,###.00",
						"$title": "Actual Year N-1"
					},
					"amount3": {
						"$type": "application/x-decimal",
						"$precision": 15,
						"$scale": 2,
						"$format": "#,###.00",
						"$title": "Actual variance N and N-1"
					},
					"amount4": {
						"$type": "application/x-decimal",
						"$precision": 15,
						"$scale": 2,
						"$format": "#,###.00",
						"$title": "Margin Year N"
					},
					"amount5": {
						"$type": "application/x-decimal",
						"$precision": 15,
						"$scale": 2,
						"$format": "#,###.00",
						"$title": "Résult"
					},
					"amount6": {
						"$type": "application/x-decimal",
						"$precision": 15,
						"$scale": 2,
						"$format": "#,###.00",
						"$title": "Actual Tax Incl. Year N"
					},
					"amount7": {
						"$type": "application/x-decimal",
						"$precision": 15,
						"$scale": 2,
						"$format": "#,###.00",
						"$title": "Quantity"
					},
					"linkUp": {
						"$type": "application/x-string",
						"$isExcluded": true
					}
				},
				"$links": {}
			},
			"$cube": {
				"$mode": "table",
				"$title": "Inv. / Zone",
				"$displaysOneMeasure": true,
				"$hierarchies": {
					"CRY": {
						"$title": "Pays",
						"$properties": ["CRY"]
					},
					"POSCOD": {
						"$title": "Code postal",
						"$properties": ["POSCOD"]
					},
					"CTY": {
						"$title": "Ville",
						"$properties": ["CTY"]
					},
					"BPCNUM": {
						"$title": "Client",
						"$properties": ["BPCNUM"]
					},
					"date": {
						"properties": ["dateStat"],
						"periods": "YSQMD"
					}
				},
				"$measures": {
					"amount1": {
						"$isDefault": true
					},
					"amount2": {},
					"amount3": {},
					"amount4": {},
					"amount5": {},
					"amount6": {},
					"amount7": {}
				}
			},
			"$axes": [{
				"$title": "Pays",
				"$hierarchies": [
					["CRY", 1, 0],
					["POSCOD", 0, 0],
					["CTY", 0, 0],
					["BPCNUM", 0, 0]
				]
			}, {
				"$title": "Measures",
				"$hierarchies": [
					["$measures"]
				]
			}],
			"$slicer": {
				"$title": "CRY",
				"$hierarchies": [
					["CRY", 1, 0]
				]
			},
			"$isExcluded": false
		}
	}

};
var _countries = [{
	name: 'Afghanistan',
	code: 'AF'
}, {
	name: 'Åland Islands',
	code: 'AX'
}, {
	name: 'Albania',
	code: 'AL'
}, {
	name: 'Algeria',
	code: 'DZ'
}, {
	name: 'American Samoa',
	code: 'AS'
}, {
	name: 'AndorrA',
	code: 'AD'
}, {
	name: 'Angola',
	code: 'AO'
}, {
	name: 'Anguilla',
	code: 'AI'
}, {
	name: 'Antarctica',
	code: 'AQ'
}, {
	name: 'Antigua and Barbuda',
	code: 'AG'
}, {
	name: 'Argentina',
	code: 'AR'
}, {
	name: 'Armenia',
	code: 'AM'
}, {
	name: 'Aruba',
	code: 'AW'
}, {
	name: 'Australia',
	code: 'AU'
}, {
	name: 'Austria',
	code: 'AT'
}, {
	name: 'Azerbaijan',
	code: 'AZ'
}, {
	name: 'Bahamas',
	code: 'BS'
}, {
	name: 'Bahrain',
	code: 'BH'
}, {
	name: 'Bangladesh',
	code: 'BD'
}, {
	name: 'Barbados',
	code: 'BB'
}, {
	name: 'Belarus',
	code: 'BY'
}, {
	name: 'Belgium',
	code: 'BE'
}, {
	name: 'Belize',
	code: 'BZ'
}, {
	name: 'Benin',
	code: 'BJ'
}, {
	name: 'Bermuda',
	code: 'BM'
}, {
	name: 'Bhutan',
	code: 'BT'
}, {
	name: 'Bolivia',
	code: 'BO'
}, {
	name: 'Bosnia and Herzegovina',
	code: 'BA'
}, {
	name: 'Botswana',
	code: 'BW'
}, {
	name: 'Bouvet Island',
	code: 'BV'
}, {
	name: 'Brazil',
	code: 'BR'
}, {
	name: 'British Indian Ocean Territory',
	code: 'IO'
}, {
	name: 'Brunei Darussalam',
	code: 'BN'
}, {
	name: 'Bulgaria',
	code: 'BG'
}, {
	name: 'Burkina Faso',
	code: 'BF'
}, {
	name: 'Burundi',
	code: 'BI'
}, {
	name: 'Cambodia',
	code: 'KH'
}, {
	name: 'Cameroon',
	code: 'CM'
}, {
	name: 'Canada',
	code: 'CA'
}, {
	name: 'Cape Verde',
	code: 'CV'
}, {
	name: 'Cayman Islands',
	code: 'KY'
}, {
	name: 'Central African Republic',
	code: 'CF'
}, {
	name: 'Chad',
	code: 'TD'
}, {
	name: 'Chile',
	code: 'CL'
}, {
	name: 'China',
	code: 'CN'
}, {
	name: 'Christmas Island',
	code: 'CX'
}, {
	name: 'Cocos (Keeling) Islands',
	code: 'CC'
}, {
	name: 'Colombia',
	code: 'CO'
}, {
	name: 'Comoros',
	code: 'KM'
}, {
	name: 'Congo',
	code: 'CG'
}, {
	name: 'Congo, The Democratic Republic of the',
	code: 'CD'
}, {
	name: 'Cook Islands',
	code: 'CK'
}, {
	name: 'Costa Rica',
	code: 'CR'
}, {
	name: 'Cote D\'Ivoire',
	code: 'CI'
}, {
	name: 'Croatia',
	code: 'HR'
}, {
	name: 'Cuba',
	code: 'CU'
}, {
	name: 'Cyprus',
	code: 'CY'
}, {
	name: 'Czech Republic',
	code: 'CZ'
}, {
	name: 'Denmark',
	code: 'DK'
}, {
	name: 'Djibouti',
	code: 'DJ'
}, {
	name: 'Dominica',
	code: 'DM'
}, {
	name: 'Dominican Republic',
	code: 'DO'
}, {
	name: 'Ecuador',
	code: 'EC'
}, {
	name: 'Egypt',
	code: 'EG'
}, {
	name: 'El Salvador',
	code: 'SV'
}, {
	name: 'Equatorial Guinea',
	code: 'GQ'
}, {
	name: 'Eritrea',
	code: 'ER'
}, {
	name: 'Estonia',
	code: 'EE'
}, {
	name: 'Ethiopia',
	code: 'ET'
}, {
	name: 'Falkland Islands (Malvinas)',
	code: 'FK'
}, {
	name: 'Faroe Islands',
	code: 'FO'
}, {
	name: 'Fiji',
	code: 'FJ'
}, {
	name: 'Finland',
	code: 'FI'
}, {
	name: 'France',
	code: 'FR'
}, {
	name: 'French Guiana',
	code: 'GF'
}, {
	name: 'French Polynesia',
	code: 'PF'
}, {
	name: 'French Southern Territories',
	code: 'TF'
}, {
	name: 'Gabon',
	code: 'GA'
}, {
	name: 'Gambia',
	code: 'GM'
}, {
	name: 'Georgia',
	code: 'GE'
}, {
	name: 'Germany',
	code: 'DE'
}, {
	name: 'Ghana',
	code: 'GH'
}, {
	name: 'Gibraltar',
	code: 'GI'
}, {
	name: 'Greece',
	code: 'GR'
}, {
	name: 'Greenland',
	code: 'GL'
}, {
	name: 'Grenada',
	code: 'GD'
}, {
	name: 'Guadeloupe',
	code: 'GP'
}, {
	name: 'Guam',
	code: 'GU'
}, {
	name: 'Guatemala',
	code: 'GT'
}, {
	name: 'Guernsey',
	code: 'GG'
}, {
	name: 'Guinea',
	code: 'GN'
}, {
	name: 'Guinea-Bissau',
	code: 'GW'
}, {
	name: 'Guyana',
	code: 'GY'
}, {
	name: 'Haiti',
	code: 'HT'
}, {
	name: 'Heard Island and Mcdonald Islands',
	code: 'HM'
}, {
	name: 'Holy See (Vatican City State)',
	code: 'VA'
}, {
	name: 'Honduras',
	code: 'HN'
}, {
	name: 'Hong Kong',
	code: 'HK'
}, {
	name: 'Hungary',
	code: 'HU'
}, {
	name: 'Iceland',
	code: 'IS'
}, {
	name: 'India',
	code: 'IN'
}, {
	name: 'Indonesia',
	code: 'ID'
}, {
	name: 'Iran, Islamic Republic Of',
	code: 'IR'
}, {
	name: 'Iraq',
	code: 'IQ'
}, {
	name: 'Ireland',
	code: 'IE'
}, {
	name: 'Isle of Man',
	code: 'IM'
}, {
	name: 'Israel',
	code: 'IL'
}, {
	name: 'Italy',
	code: 'IT'
}, {
	name: 'Jamaica',
	code: 'JM'
}, {
	name: 'Japan',
	code: 'JP'
}, {
	name: 'Jersey',
	code: 'JE'
}, {
	name: 'Jordan',
	code: 'JO'
}, {
	name: 'Kazakhstan',
	code: 'KZ'
}, {
	name: 'Kenya',
	code: 'KE'
}, {
	name: 'Kiribati',
	code: 'KI'
}, {
	name: 'Korea, Democratic People\'S Republic of',
	code: 'KP'
}, {
	name: 'Korea, Republic of',
	code: 'KR'
}, {
	name: 'Kuwait',
	code: 'KW'
}, {
	name: 'Kyrgyzstan',
	code: 'KG'
}, {
	name: 'Lao People\'S Democratic Republic',
	code: 'LA'
}, {
	name: 'Latvia',
	code: 'LV'
}, {
	name: 'Lebanon',
	code: 'LB'
}, {
	name: 'Lesotho',
	code: 'LS'
}, {
	name: 'Liberia',
	code: 'LR'
}, {
	name: 'Libyan Arab Jamahiriya',
	code: 'LY'
}, {
	name: 'Liechtenstein',
	code: 'LI'
}, {
	name: 'Lithuania',
	code: 'LT'
}, {
	name: 'Luxembourg',
	code: 'LU'
}, {
	name: 'Macao',
	code: 'MO'
}, {
	name: 'Macedonia, The Former Yugoslav Republic of',
	code: 'MK'
}, {
	name: 'Madagascar',
	code: 'MG'
}, {
	name: 'Malawi',
	code: 'MW'
}, {
	name: 'Malaysia',
	code: 'MY'
}, {
	name: 'Maldives',
	code: 'MV'
}, {
	name: 'Mali',
	code: 'ML'
}, {
	name: 'Malta',
	code: 'MT'
}, {
	name: 'Marshall Islands',
	code: 'MH'
}, {
	name: 'Martinique',
	code: 'MQ'
}, {
	name: 'Mauritania',
	code: 'MR'
}, {
	name: 'Mauritius',
	code: 'MU'
}, {
	name: 'Mayotte',
	code: 'YT'
}, {
	name: 'Mexico',
	code: 'MX'
}, {
	name: 'Micronesia, Federated States of',
	code: 'FM'
}, {
	name: 'Moldova, Republic of',
	code: 'MD'
}, {
	name: 'Monaco',
	code: 'MC'
}, {
	name: 'Mongolia',
	code: 'MN'
}, {
	name: 'Montserrat',
	code: 'MS'
}, {
	name: 'Morocco',
	code: 'MA'
}, {
	name: 'Mozambique',
	code: 'MZ'
}, {
	name: 'Myanmar',
	code: 'MM'
}, {
	name: 'Namibia',
	code: 'NA'
}, {
	name: 'Nauru',
	code: 'NR'
}, {
	name: 'Nepal',
	code: 'NP'
}, {
	name: 'Netherlands',
	code: 'NL'
}, {
	name: 'Netherlands Antilles',
	code: 'AN'
}, {
	name: 'New Caledonia',
	code: 'NC'
}, {
	name: 'New Zealand',
	code: 'NZ'
}, {
	name: 'Nicaragua',
	code: 'NI'
}, {
	name: 'Niger',
	code: 'NE'
}, {
	name: 'Nigeria',
	code: 'NG'
}, {
	name: 'Niue',
	code: 'NU'
}, {
	name: 'Norfolk Island',
	code: 'NF'
}, {
	name: 'Northern Mariana Islands',
	code: 'MP'
}, {
	name: 'Norway',
	code: 'NO'
}, {
	name: 'Oman',
	code: 'OM'
}, {
	name: 'Pakistan',
	code: 'PK'
}, {
	name: 'Palau',
	code: 'PW'
}, {
	name: 'Palestinian Territory, Occupied',
	code: 'PS'
}, {
	name: 'Panama',
	code: 'PA'
}, {
	name: 'Papua New Guinea',
	code: 'PG'
}, {
	name: 'Paraguay',
	code: 'PY'
}, {
	name: 'Peru',
	code: 'PE'
}, {
	name: 'Philippines',
	code: 'PH'
}, {
	name: 'Pitcairn',
	code: 'PN'
}, {
	name: 'Poland',
	code: 'PL'
}, {
	name: 'Portugal',
	code: 'PT'
}, {
	name: 'Puerto Rico',
	code: 'PR'
}, {
	name: 'Qatar',
	code: 'QA'
}, {
	name: 'Reunion',
	code: 'RE'
}, {
	name: 'Romania',
	code: 'RO'
}, {
	name: 'Russian Federation',
	code: 'RU'
}, {
	name: 'RWANDA',
	code: 'RW'
}, {
	name: 'Saint Helena',
	code: 'SH'
}, {
	name: 'Saint Kitts and Nevis',
	code: 'KN'
}, {
	name: 'Saint Lucia',
	code: 'LC'
}, {
	name: 'Saint Pierre and Miquelon',
	code: 'PM'
}, {
	name: 'Saint Vincent and the Grenadines',
	code: 'VC'
}, {
	name: 'Samoa',
	code: 'WS'
}, {
	name: 'San Marino',
	code: 'SM'
}, {
	name: 'Sao Tome and Principe',
	code: 'ST'
}, {
	name: 'Saudi Arabia',
	code: 'SA'
}, {
	name: 'Senegal',
	code: 'SN'
}, {
	name: 'Serbia and Montenegro',
	code: 'CS'
}, {
	name: 'Seychelles',
	code: 'SC'
}, {
	name: 'Sierra Leone',
	code: 'SL'
}, {
	name: 'Singapore',
	code: 'SG'
}, {
	name: 'Slovakia',
	code: 'SK'
}, {
	name: 'Slovenia',
	code: 'SI'
}, {
	name: 'Solomon Islands',
	code: 'SB'
}, {
	name: 'Somalia',
	code: 'SO'
}, {
	name: 'South Africa',
	code: 'ZA'
}, {
	name: 'South Georgia and the South Sandwich Islands',
	code: 'GS'
}, {
	name: 'Spain',
	code: 'ES'
}, {
	name: 'Sri Lanka',
	code: 'LK'
}, {
	name: 'Sudan',
	code: 'SD'
}, {
	name: 'Suriname',
	code: 'SR'
}, {
	name: 'Svalbard and Jan Mayen',
	code: 'SJ'
}, {
	name: 'Swaziland',
	code: 'SZ'
}, {
	name: 'Sweden',
	code: 'SE'
}, {
	name: 'Switzerland',
	code: 'CH'
}, {
	name: 'Syrian Arab Republic',
	code: 'SY'
}, {
	name: 'Taiwan, Province of China',
	code: 'TW'
}, {
	name: 'Tajikistan',
	code: 'TJ'
}, {
	name: 'Tanzania, United Republic of',
	code: 'TZ'
}, {
	name: 'Thailand',
	code: 'TH'
}, {
	name: 'Timor-Leste',
	code: 'TL'
}, {
	name: 'Togo',
	code: 'TG'
}, {
	name: 'Tokelau',
	code: 'TK'
}, {
	name: 'Tonga',
	code: 'TO'
}, {
	name: 'Trinidad and Tobago',
	code: 'TT'
}, {
	name: 'Tunisia',
	code: 'TN'
}, {
	name: 'Turkey',
	code: 'TR'
}, {
	name: 'Turkmenistan',
	code: 'TM'
}, {
	name: 'Turks and Caicos Islands',
	code: 'TC'
}, {
	name: 'Tuvalu',
	code: 'TV'
}, {
	name: 'Uganda',
	code: 'UG'
}, {
	name: 'Ukraine',
	code: 'UA'
}, {
	name: 'United Arab Emirates',
	code: 'AE'
}, {
	name: 'United Kingdom',
	code: 'GB'
}, {
	name: 'United States',
	code: 'US'
}, {
	name: 'United States Minor Outlying Islands',
	code: 'UM'
}, {
	name: 'Uruguay',
	code: 'UY'
}, {
	name: 'Uzbekistan',
	code: 'UZ'
}, {
	name: 'Vanuatu',
	code: 'VU'
}, {
	name: 'Venezuela',
	code: 'VE'
}, {
	name: 'Viet Nam',
	code: 'VN'
}, {
	name: 'Virgin Islands, British',
	code: 'VG'
}, {
	name: 'Virgin Islands, U.S.',
	code: 'VI'
}, {
	name: 'Wallis and Futuna',
	code: 'WF'
}, {
	name: 'Western Sahara',
	code: 'EH'
}, {
	name: 'Yemen',
	code: 'YE'
}, {
	name: 'Zambia',
	code: 'ZM'
}, {
	name: 'Zimbabwe',
	code: 'ZW'
}];

var _resources = [];
_countries
	.forEach(function(ctry, idx) {
		_resources
			.push({
				"level": 1,
				"CRY": ctry.code,
				"$uuid": "uuid" + ctry.code,
				"$title": ctry.name,
				"linkUp": "DATBEG1=2015-01-01&DATEND1=2015-12-31&DATBEG2=2014-01-01&DATEND2=2014-12-31&COMPANY=&CRY=" + ctry.code,
				"linkDown": "DATBEG1=2015-01-01&DATEND1=2015-12-31&DATBEG2=2014-01-01&DATEND2=2014-12-31&COMPANY=",
				"amount1": 1000 + idx * 10,
				"amount2": 2000 + idx * 10,
				"amount3": 3000 + idx * 10,
				"amount4": 4000 + idx * 10,
				"amount5": 5000 + idx * 10,
				"amount6": 6000 + idx * 10,
				"amount7": 7000 + idx * 10,
			});
	});
// test pagination - lastIndex
// _resources.splice (_resources.length - 4, 3)
// _resources.splice (_resources.length - 3, 2)
// _resources.splice (_resources.length - 2, 1)
var _data = {
	"$properties": {
		"$resources": {
			"$item": {
				"$properties": {
					"CRY": {
						"$isHidden": false
					},
					"POSCOD": {
						"$isHidden": true
					},
					"CTY": {
						"$isHidden": true
					},
					"BPCNUM": {
						"$isHidden": true
					}
				},
				"$links": {}
			}
		}
	},
	"linkstartP": "DATBEG1=2014-01-01&DATEND1=2014-12-31&DATBEG2=2013-01-01&DATEND2=2013-12-31&COMPANY=",
	"linkendP": "DATBEG1=2016-01-01&DATEND1=2016-12-31&DATBEG2=2015-01-01&DATEND2=2015-12-31&COMPANY=",
	"datstart1": "2015-01-01",
	"datend1": "2015-12-31",
	"datstart2": "2014-01-01",
	"datend2": "2014-12-31",
	"def_company": "",
	"$resources": _resources
};

var _chartDetail = {
	"$layoutType": "stack",
	"$display": "bothSideToSide",
	"$localization": {},
	"$items": [{
		"$layoutType": "row",
		"$items": [{
			"$layoutType": "cell",
			"widthAll": "6",
			"$widthSm": "6",
			"$widthMd": "6",
			"$widthLg": "6",
			"$bgColor": "transparent",
			"$items": [{
				"$bind": "$resources",
				"$isTitleHidden": true,
				"$display": "chart",
				"$isHidden": false,
				"$style": "line",
				"$arrayOptions": {
					"showPagination": false,
					"showSortFilter": false,
					"showSearch": false,
					"rowIndex": false
				},
				"$arrayBgColor": "darkgrey"
			}]
		}, {
			"$layoutType": "cell",
			"$widthXs": "12",
			"$widthSm": "6",
			"$widthMd": "6",
			"$widthLg": "6",
			"$bgColor": "transparent",
			"$items": [{
				"$bind": "$resources",
				"$isTitleHidden": true,
				"$display": "table",
				"$isHidden": false,
				"$arrayOptions": {
					"showPagination": true,
					"showSortFilter": false,
					"showSearch": false,
					"rowIndex": true,
					"showRowDetailLink": false
				},
				"$arrayBgColor": "darkgrey",
				"$table": [{
					"$bind": "CRY",
					"$title": "Pays",
					"$type": "application/x-string",
					"$titleOrig": "Pays",
					"$widthType": "auto",
					"$widthVal": 0,
					"$imgHeight": "small"
				}, {
					"$bind": "amount1",
					"$title": "Actual Year N",
					"$type": "application/x-decimal",
					"$titleOrig": "Actual Year N",
					"$widthType": "auto",
					"$widthVal": 0,
					"$imgHeight": "small"
				}, {
					"$bind": "amount2",
					"$title": "Actual Year N-1",
					"$type": "application/x-decimal",
					"$titleOrig": "Actual Year N-1",
					"$widthType": "auto",
					"$widthVal": 0,
					"$imgHeight": "small"
				}, {
					"$bind": "amount3",
					"$title": "Actual variance N and N-1",
					"$type": "application/x-decimal",
					"$titleOrig": "Actual variance N and N-1",
					"$widthType": "auto",
					"$widthVal": 0,
					"$imgHeight": "small"
				}, {
					"$bind": "amount4",
					"$title": "Margin Year N",
					"$type": "application/x-decimal",
					"$titleOrig": "Margin Year N",
					"$widthType": "auto",
					"$widthVal": 0,
					"$imgHeight": "small"
				}]
			}]
		}]
	}]
};

exports.entity = {
	$entityName: "$localVEN42",
	$value: "{date}",
	$proto: _proto,
	$createProto: function(prototype) {
		return $.extend(true, {}, exports.entity.$proto);
	},
	$properties: {},
	$articles: {
		$cube: {
			"$layoutType": "stack",
			"$items": [{
				"$bind": "$resources",
				"$display": "table",
				"$arrayOptions": {
					"showPagination": true,
					"rowIndex": true,
				},
				"$table": [{
					"$bind": "CRY"
				}, {
					"$bind": "amount1"
				}, {
					"$bind": "amount2"
				}, {
					"$bind": "amount3"
				}],
				/*
				 * { "$bind": "amount4" }, { "$bind": "amount5" }, {
				 * "$bind": "amount6" }, { "$bind": "amount7" }],
				 */
				$chartDetail: _chartDetail
			}]
		},
		$cubechart: {
			"$layoutType": "stack",
			"$items": [{
				"$bind": "$resources",
				"$display": "chart",
				"$arrayOptions": {
					"showPagination": true,
					"rowIndex": true,
				},
				"$chartOptions": {
					"isLegendHidden": true
				},
				"$table": [{
					"$bind": "CRY"
				}, {
					"$bind": "amount1"
				}, {
					"$bind": "amount2"
				}, {
					"$bind": "amount3"
				}],
				$chartDetail: _chartDetail
			}]
		}
	},
	$services: {
		$query: function(op, data) {
			return $.smResolve($.extend(true, {}, _data));
		}
	}
};
});

define('syracuse-tablet/html/js/demos/_entities/main',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/_entities/entTodos','syracuse-tablet/html/js/demos/_entities/entOverviewSales','syracuse-tablet/html/js/demos/_entities/entOverviewSalesLeads','syracuse-tablet/html/js/demos/_entities/entCustomers','syracuse-tablet/html/js/demos/_entities/entCustomerRevenues','syracuse-tablet/html/js/demos/_entities/entStatsVEN42'],function (require, exports, module) {"use strict";

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var entTodos = require('syracuse-tablet/html/js/demos/_entities/entTodos');
var entOverviewSales = require('syracuse-tablet/html/js/demos/_entities/entOverviewSales');
var entOverviewSalesLeads = require('syracuse-tablet/html/js/demos/_entities/entOverviewSalesLeads');
var entCustomers = require('syracuse-tablet/html/js/demos/_entities/entCustomers');
var entCustomerRevenues = require('syracuse-tablet/html/js/demos/_entities/entCustomerRevenues');
var entStatsVEN42 = require('syracuse-tablet/html/js/demos/_entities/entStatsVEN42');

exports.registerAll = function() {
	clientContract.registerEntity(entTodos.entity);
	clientContract.registerEntity(entOverviewSales.entity);
	clientContract.registerEntity(entOverviewSalesLeads.entity);
	clientContract.registerEntity(entCustomers.entity);
	clientContract.registerEntity(entCustomerRevenues.entity);
	clientContract.registerEntity(entStatsVEN42.entity);
};
});

define('syracuse-tablet/html/js/demos/salesMyCustomers/main',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/salesMyCustomers/dashCustomers','syracuse-tablet/html/js/demos/utils','syracuse-tablet/html/js/demos/_entities/main'],function (require, exports, module) {"use strict";

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var dashCustomers = require('syracuse-tablet/html/js/demos/salesMyCustomers/dashCustomers');
var demoUtils = require('syracuse-tablet/html/js/demos/utils');
var entities = require('syracuse-tablet/html/js/demos/_entities/main');


var _demoApp = {
	"$application": {
		"$uuid": "$demoCustomers",
		"applicationName": "sagesalescustomers",
		"title": "Sales - My Customers",
		"description": "",
		"isSageApplication": true,
		"iconName": "s-m-sales-customers",
		"$homeDashboard": {
			"$uuid": "$customersDashboard",
			"dashboardName": "$customersDashboard"
		}
	},
	"$dashboards": {},
	"$gadgets": {}
};

exports.register = function() {
	entities.registerAll();
	demoUtils.addToApp(_demoApp, dashCustomers);
	clientContract.registerApp(_demoApp);
};
});

define('syracuse-tablet/html/js/demos/salesMyInquiries/dashSalesInquiries',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"$salesMyInquiriesDashboard": {
		"$dashboardName": "$salesMyInquiriesDashboard",
		"$title": "Sales - My Inquiries Dashboard",
		"$description": "",
		"$vignettes": {
			"$x3PriceInquiries": {
				"$uuid": "$x3PriceInquiries",
				"$displayStyle": "$link"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Price Inquiry",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Sales Price Inquiry",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3PriceInquiries"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"$x3PriceInquiries": {
		"$type": "$representation",
		"$title": "Price Inquiry",
		"entity": "SPRICESEARCH",
		"endpoint": "x3.erp.GX3APP",
		"action": "$create",
		"representation": "SPRICESEAM",
		"facet": "$create",
		"icon": "s-m-sales-priceinquiry"
	}
};
});

define('syracuse-tablet/html/js/demos/salesMyInquiries/main',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/salesMyInquiries/dashSalesInquiries','syracuse-tablet/html/js/demos/utils'],function (require, exports, module) {"use strict";

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var dashSalesInquiries = require('syracuse-tablet/html/js/demos/salesMyInquiries/dashSalesInquiries');
var demoUtils = require('syracuse-tablet/html/js/demos/utils');


var _demoApp = {
	"$application": {
		"$uuid": "$demoSalesMyInquiries",
		"applicationName": "sagesalesinquiries",
		"title": "Sales - My Inquiries",
		"description": "",
		"isSageApplication": true,
		"iconName": "s-m-sales-inquiries",
		"$homeDashboard": {
			"$uuid": "$salesMyInquiriesDashboard",
			"dashboardName": "$salesMyInquiriesDashboard"
		}
	},
	"$dashboards": {},
	"$gadgets": {}
};

exports.register = function() {
	demoUtils.addToApp(_demoApp, dashSalesInquiries);
	clientContract.registerApp(_demoApp);
};
});

define('syracuse-tablet/html/js/demos/salesMyActions/dashSalesMyActions',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"$salesMyActionsDashboard": {
		"$dashboardName": "$salesMyActionsDashboard",
		"$title": "Sales - My Actions Dashboard",
		"$description": "",
		"$vignettes": {
			"$x3Orders2Sign": {
				"$uuid": "$x3Orders2Sign",
				"$displayStyle": "$full"
			},
			"$x3Quotes2Sign": {
				"$uuid": "$x3Quotes2Sign",
				"$displayStyle": "$full"
			},
			"$x3Orders2SignIco": {
				"$uuid": "$x3Orders2Sign",
				"$displayStyle": "$link"
			},
			"$x3Quotes2SignIco": {
				"$uuid": "$x3Quotes2Sign",
				"$displayStyle": "$link"
			},
			"$x3OpenOrders2Sign": {
				"$uuid": "$x3OpenOrders2Sign",
				"$displayStyle": "$link"
			},
			"$x3QuotesSigned": {
				"$uuid": "$x3QuotesSigned",
				"$displayStyle": "$link"
			},
			"$x3OrdersSigned": {
				"$uuid": "$x3OrdersSigned",
				"$displayStyle": "$link"
			},
			"$x3OpenOrdersSigned": {
				"$uuid": "$x3OpenOrdersSigned",
				"$displayStyle": "$link"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Sales - my actions",
				"$items": [{
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3Quotes2SignIco"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3Orders2SignIco"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3OpenOrders2Sign"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3QuotesSigned"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3OrdersSigned"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3OpenOrdersSigned"
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Orders to sign",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Orders to sign",
					"$size": "full",
					"$items": [{
						"$bind": "$x3Orders2Sign"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "Quotes to sign",
					"$size": "full",
					"$items": [{
						"$bind": "$x3Quotes2Sign",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "card",
								"$article": {
									"$items": [{
										"$bind": "DEST_REF"
									}, {
										"$bind": "RCLEDEC"
									}, {
										"$bind": "RVALCTX7"
									}, {
										"$bind": "RVALCTX2_REF"
									}]
								}
							}]
						}
					}]
				}]
			}]
		}
	}
};
exports.gadgets = {
	"$x3Orders2Sign": {
		"$type": "$representation",
		"$title": "Orders to sign",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "POHTOSIGM",
		"facet": "$query",
		"icon": "s-m-sales-orders2sign"
	},
	"$x3Quotes2Sign": {
		"$type": "$representation",
		"$title": "Quotes to sign",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "SQHTOSIGM",
		"facet": "$query",
		"icon": "s-m-sales-quotes2sign"
	},
	"$x3OpenOrders2Sign": {
		"$type": "$representation",
		"$title": "Open orders to sign",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "SOCTOSIGM",
		"facet": "$query",
		"icon": "s-m-sales-openorders2sign"
	},
	"$x3QuotesSigned": {
		"$type": "$representation",
		"$title": "Quotes signed",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "SQHSIGM",
		"facet": "$query",
		"icon": "s-m-sales-quotessigned"
	},
	"$x3OrdersSigned": {
		"$type": "$representation",
		"$title": "Quotes signed",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "SOHSIGM",
		"facet": "$query",
		"icon": "s-m-sales-orderssigned"
	},
	"$x3OpenOrdersSigned": {
		"$type": "$representation",
		"$title": "Quotes signed",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "SOCSIGM",
		"facet": "$query",
		"icon": "s-m-sales-openorderssigned"
	}
};
});

define('syracuse-tablet/html/js/demos/salesMyActions/main',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/salesMyActions/dashSalesMyActions','syracuse-tablet/html/js/demos/utils'],function (require, exports, module) {"use strict";

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var dashSalesMyActions = require('syracuse-tablet/html/js/demos/salesMyActions/dashSalesMyActions');
var demoUtils = require('syracuse-tablet/html/js/demos/utils');


var _demoApp = {
	"$application": {
		"$uuid": "$demoSalesMyActions",
		"applicationName": "sagsalesactions",
		"title": "Sales - My Actions",
		"description": "",
		"isSageApplication": true,
		"iconName": "s-m-sales-actions",
		"$homeDashboard": {
			"$uuid": "$salesMyActionsDashboard",
			"dashboardName": "$salesMyActionsDashboard"
		}
	},
	"$dashboards": {},
	"$gadgets": {}
};

exports.register = function() {
	demoUtils.addToApp(_demoApp, dashSalesMyActions);
	clientContract.registerApp(_demoApp);
};
});

define('syracuse-tablet/html/js/demos/purchaseMyActions/dashPurchaseMyActions',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"$purchaseMyActionsDashboard": {
		"$dashboardName": "$purchaseMyActionsDashboard",
		"$title": "Purchase My Actions Dashboard",
		"$description": "",
		"$vignettes": {
			"$x3Orders2Sign": {
				"$uuid": "$x3Orders2Sign",
				"$displayStyle": "$full"
			},
			"$x3Purchases2Sign": {
				"$uuid": "$x3Purchases2Sign",
				"$displayStyle": "$full"
			},
			"$x3Orders2SignIco": {
				"$uuid": "$x3Orders2Sign",
				"$displayStyle": "$link"
			},
			"$x3Purchases2SignIco": {
				"$uuid": "$x3Purchases2Sign",
				"$displayStyle": "$link"
			},
			"$x3OpenOrders2Sign": {
				"$uuid": "$x3OpenOrders2Sign",
				"$displayStyle": "$link"
			},
			"$x3PurchasesSigned": {
				"$uuid": "$x3PurchasesSigned",
				"$displayStyle": "$link"
			},
			"$x3OrdersSigned": {
				"$uuid": "$x3OrdersSigned",
				"$displayStyle": "$link"
			},
			"$x3OpenOrdersSigned": {
				"$uuid": "$x3OpenOrdersSigned",
				"$displayStyle": "$link"
			},
			"$x3PurchasePriceInquiry": {
				"$uuid": "$x3PurchasePriceInquiry",
				"$displayStyle": "$link"
			}

		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Purchases - my actions",
				"$items": [{
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3Orders2SignIco"
					}]

				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3Purchases2SignIco"
					}]

				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3OpenOrders2Sign"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3PurchasesSigned"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3OrdersSigned"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3OpenOrdersSigned"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3PurchasePriceInquiry"
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Purchase action",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Orders to sign",
					"$size": "full",
					"$items": [{
						"$bind": "$x3Orders2Sign"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "Requests to sign",
					"$size": "full",
					"$items": [{
						"$bind": "$x3Purchases2Sign"
					}]
				}]
			}]
		}
	}
};
exports.gadgets = {
	"$x3Orders2Sign": {
		"$type": "$representation",
		"$title": "Orders to sign",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "POHTOSIGM",
		"facet": "$query",
		"icon": "s-m-purchase-orders2sign"
	},
	"$x3Purchases2Sign": {
		"$type": "$representation",
		"$title": "Purchases Requests to sign",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "PSHTOSIGM",
		"facet": "$query",
		"icon": "s-m-purchase-quotes2sign"
	},
	"$x3OpenOrders2Sign": {
		"$type": "$representation",
		"$title": "Open Orders to sign",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "POCTOSIGM",
		"facet": "$query",
		"icon": "s-m-purchase-openorders2sign"
	},
	"$x3PurchasesSigned": {
		"$type": "$representation",
		"$title": "Purchase Requests signed",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "PSHSIGM",
		"facet": "$query",
		"icon": "s-m-purchase-quotessigned"
	},
	"$x3OrdersSigned": {
		"$type": "$representation",
		"$title": "Orders signed",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "POHSIGM",
		"facet": "$query",
		"icon": "s-m-purchase-orderssigned"
	},
	"$x3OpenOrdersSigned": {
		"$type": "$representation",
		"$title": "Open Orders signed",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "POCSIGM",
		"facet": "$query",
		"icon": "s-m-purchase-openorderssigned"
	},
	"$x3PurchasePriceInquiry": {
		"$type": "$representation",
		"$title": "Purchase price inquiry",
		"entity": "PPRICESEARCH",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "PPRICSEARCHM",
		"facet": "$query",
		"icon": "s-m-purchase-priceinquiry"
	}
};
});

define('syracuse-tablet/html/js/demos/purchaseMyActions/main',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/purchaseMyActions/dashPurchaseMyActions','syracuse-tablet/html/js/demos/utils'],function (require, exports, module) {"use strict";

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var dashPurchaseMyActions = require('syracuse-tablet/html/js/demos/purchaseMyActions/dashPurchaseMyActions');
var demoUtils = require('syracuse-tablet/html/js/demos/utils');


var _demoApp = {
	"$application": {
		"$uuid": "$demoPurchaseMyActions",
		"applicationName": "sagepurchaseactions",
		"title": "Purchase My Actions",
		"description": "",
		"isSageApplication": true,
		"iconName": "s-m-purchase-actions",
		"$homeDashboard": {
			"$uuid": "$purchaseMyActionsDashboard",
			"dashboardName": "$purchaseMyActionsDashboard"
		}
	},
	"$dashboards": {},
	"$gadgets": {}
};

exports.register = function() {
	demoUtils.addToApp(_demoApp, dashPurchaseMyActions);
	clientContract.registerApp(_demoApp);
};
});

define('syracuse-tablet/html/js/demos/purchaseMyInquiries/dashPurchaseMyInquiries',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"$purchaseMyInquiriesDashboard": {
		"$dashboardName": "$purchaseMyInquiriesDashboard",
		"$title": "Purchase My Inquiries Dashboard",
		"$description": "",
		"$vignettes": {
			"$x3PriceInquiry": {
				"$uuid": "$x3PriceInquiry",
				"$displayStyle": "$link"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Purchase My Inquiries",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Price Inquiriy",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3PriceInquiry"
					}]
				}]
			}]
		}
	}
};
exports.gadgets = {
	"$x3PriceInquiry": {
		"$type": "$representation",
		"$title": "Price inquiry",
		"entity": "PPRICESEARCH",
		"endpoint": "x3.erp.GX3APP",
		"action": "$create",
		"representation": "PPRICSEARCHM",
		"facet": "$create",
		"icon": "s-m-purchase-priceinquiry"
	}
};
});

define('syracuse-tablet/html/js/demos/purchaseMyInquiries/main',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/purchaseMyInquiries/dashPurchaseMyInquiries','syracuse-tablet/html/js/demos/utils'],function (require, exports, module) {"use strict";

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var dashPurchaseMyInquiries = require('syracuse-tablet/html/js/demos/purchaseMyInquiries/dashPurchaseMyInquiries');
var demoUtils = require('syracuse-tablet/html/js/demos/utils');


var _demoApp = {
	"$application": {
		"$uuid": "$demoPurchaseMyInquiries",
		"applicationName": "sagepurchaseinquiries",
		"title": "Purchase - My Inquiries",
		"description": "",
		"isSageApplication": true,
		"iconName": "s-m-purchase-inquiries",
		"$homeDashboard": {
			"$uuid": "$purchaseMyInquiriesDashboard",
			"dashboardName": "$purchaseMyInquiriesDashboard"
		}
	},
	"$dashboards": {},
	"$gadgets": {}
};

exports.register = function() {
	demoUtils.addToApp(_demoApp, dashPurchaseMyInquiries);
	clientContract.registerApp(_demoApp);
};
});

define('syracuse-tablet/html/js/demos/myExpenses/dashExpenses',['require','exports','module'],function (require, exports, module) {"use strict";

var _$queryLinkArticle = {
	"$layoutType": "stack",
	"$localization": {},
	"$items": [{
		"$bind": "$resources",
		"$isTitleHidden": true,
		"$arrayOptions": {
			"showPagination": true,
			"showSortFilter": true,
			"showSearch": true,
			"rowIndex": false,
			"showRowDetailLink": false
		},
		"$arrayBgColor": "darkgrey",
		"$table": [{
			"$bind": "DATEXS",
			"$type": "application/x-date",
			"$titleOrig": "{@212}",
			"$widthType": "fixed",
			"$widthVal": 8,
			"$imgHeight": "small",
			"$title": "Date"
		}, {
			"$bind": "FCY_REF",
			"$type": "application/x-reference",
			"$titleOrig": "{@1344}",
			"$widthType": "auto",
			"$widthVal": 0,
			"$refDescPosition": "right",
			"$imgHeight": "small",
			"$title": "Site"
		}, {
			"$bind": "CODEXP_REF",
			"$type": "application/x-reference",
			"$titleOrig": "{@41193}",
			"$widthType": "fixed",
			"$widthVal": 8,
			"$refDescPosition": "none",
			"$imgHeight": "small",
			"$title": "Code frais"
		}, {
			"$bind": "QTY",
			"$type": "application/x-integer",
			"$titleOrig": "{@271}",
			"$widthType": "fixed",
			"$widthVal": 5,
			"$imgHeight": "small",
			"$title": "Quantité"
		}]
	}]
};
exports.dashboards = {
	"$expensesDashboard": {
		"$dashboardName": "$expensesDashboard",
		"$title": "Expenses Dashboard",
		"$description": "",
		"$vignettes": {
			"$x3expensesList": {
				"$uuid": "$x3expensesList",
				"$displayStyle": "$full"
			},
			"$x3expensesList1": {
				"$uuid": "$x3expensesList",
				"$displayStyle": "$full"
			},
			"$x3expensesNotApproved": {
				"$uuid": "$x3expensesNotApproved",
				"$displayStyle": "$full"
			},
			"$x3expensesCreate": {
				"$uuid": "$x3expensesCreate",
				"$displayStyle": "$link"
			},
			"$x3expensesCreateVignette": {
				"$uuid": "$x3expensesCreate",
				"$displayStyle": "$full"
			},
			"$x3expensesNotApprovedIco": {
				"$uuid": "$x3expensesNotApproved",
				"$displayStyle": "$link"
			},
			"$x3expensesListIco": {
				"$uuid": "$x3expensesList",
				"$displayStyle": "$link"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Expenses",
				"$items": [{
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3expensesCreate"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3expensesNotApprovedIco"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3expensesListIco"
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Expenses Create",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Expenses Create",
					"$size": "full",
					"$items": [{
						"$bind": "$x3expensesCreateVignette",
						"$pageActionSettings": [{
							"name": "$save",
							"icon": {
								"css": "fa fa-check",
								"name": "check"
							},
							"$title": "Enregistrer",
							"options": {
								"footerHeader": true,
								"refreshPage": false,
								"multiselection": false
							}
						}],
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "CLB_REF"
							}, {
								"$bind": "DATEXS"
							}, {
								"$bind": "FCY_REF"
							}, {
								"$bind": "CODEXP_REF"
							}, {
								"$bind": "NBREXS"
							}, {
								"$bind": "ACCNUM"
							}, {
								"$bind": "QTY"
							}, {
								"$bind": "AMTPAY"
							}, {
								"$bind": "CUR_REF"
							}, {
								"$bind": "AMTATI"
							}, {
								"$bind": "DES"
							}, {
								"$bind": "BEXS",
								"$imgHeight": "medium"
							}, {
								"$bind": "EXSDIMCEN",
								"$arrayOptions": {
									"showPagination": false,
									"showSortFilter": false,
									"rowIndex": false,
									"showRowDetailLink": false
								}
							}]
						}
					}]
				}, {
					"$layoutType": "tile",
					"$title": "Expenses Create",
					"$size": "full",
					"$items": [{
						"$bind": "$x3expensesCreateVignette",
						"$pageActionSettings": [{
							"name": "$save",
							"icon": {
								"css": "fa fa-check",
								"name": "check"
							},
							"$title": "Enregistrer",
							"options": {
								"footerHeader": true,
								"refreshPage": false,
								"multiselection": false
							}
						}],
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "CLB_REF"
							}, {
								"$bind": "DATEXS"
							}, {
								"$bind": "FCY_REF"
							}, {
								"$bind": "CODEXP_REF"
							}, {
								"$bind": "NBREXS"
							}, {
								"$bind": "ACCNUM"
							}, {
								"$bind": "QTY"
							}, {
								"$bind": "AMTPAY"
							}, {
								"$bind": "CUR_REF"
							}, {
								"$bind": "AMTATI"
							}, {
								"$bind": "DES"
							}, {
								"$bind": "BEXS",
								"$imgHeight": "medium"
							}, {
								"$bind": "EXSDIMCEN",
								"$arrayOptions": {
									"showPagination": false,
									"showSortFilter": false,
									"rowIndex": false,
									"showRowDetailLink": false
								}
							}]
						}
					}]
				}]

			}, {
				"$layoutType": "hubGroup",
				"$title": "Expenses List",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Expenses list",
					"$size": "full",
					"$items": [{
						"$bind": "$x3expensesList",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "card",
								"$article": {
									"$queryLinkArticle": _$queryLinkArticle,
									"$items": [{
										"$bind": "CLB_REF"
									}, {
										"$bind": "DATEXS"
									}, {
										"$bind": "CODEXP_REF"
									}, {
										"$bind": "AMTPAY"
									}, {
										"$bind": "CUR_REF"
									}]
								}
							}]
						}
					}]
				}, {
					"$layoutType": "tile",
					"$title": "Expenses list",
					"$size": "full",
					"$items": [{
						"$bind": "$x3expensesList1",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources"
							}]
						}
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Expenses Not Approved",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Expenses Not Approved",
					"$size": "all",
					"$items": [{
						"$bind": "$x3expensesNotApproved",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$queryLinkArticle": _$queryLinkArticle,
								"$display": "table",
								"$arrayOptions": {
									"showPagination": true,
									"showSortFilter": true,
									"showSearch": true,
									"rowIndex": false
								},
								"$article": {
									"$items": [{
										"$bind": "CLB_REF"
									}, {
										"$bind": "DATEXS"
									}, {
										"$bind": "CODEXP_REF"
									}, {
										"$bind": "AMTPAY"
									}, {
										"$bind": "CUR_REF"
									}]
								}
							}]
						}
					}]
				}]
			}]
		}
	}
};
exports.gadgets = {
	"$x3expensesList": {
		"$type": "$representation",
		"$title": "All Expenses",
		"entity": "EXPENSES",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "EXPENCNSM",
		"facet": "$query",
		"icon": "s-m-expenses-all"
	},
	"$x3expensesNotApproved": {
		"$type": "$representation",
		"$title": "Expenses not approved",
		"entity": "EXPENSES",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "EXPENENTM",
		"facet": "$query",
		"icon": "s-m-expenses-notapproved"
	},
	"$x3expensesCreate": {
		"$type": "$representation",
		"$title": "Create expense",
		"entity": "EXPENSES",
		"endpoint": "x3.erp.GX3APP",
		"action": "$create",
		"representation": "EXPENENTM",
		"facet": "$create",
		"icon": "s-m-expenses-create"
	}
};
});

define('syracuse-tablet/html/js/demos/myExpenses/main',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/myExpenses/dashExpenses','syracuse-tablet/html/js/demos/utils'],function (require, exports, module) {"use strict";

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var dashExpenses = require('syracuse-tablet/html/js/demos/myExpenses/dashExpenses');
var demoUtils = require('syracuse-tablet/html/js/demos/utils');


var _demoApp = {
	"$application": {
		"$uuid": "$demoExpenses",
		"applicationName": "sageexpenses",
		"title": "My Expenses",
		"isSageApplication": true,
		"description": "",
		"iconName": "s-m-expenses",
		"$homeDashboard": {
			"$uuid": "$expensesDashboard",
			"dashboardName": "$expensesDashboard"
		}
	},
	"$dashboards": {},
	"$gadgets": {}
};

exports.register = function() {
	demoUtils.addToApp(_demoApp, dashExpenses);
	clientContract.registerApp(_demoApp);
};
});

define('syracuse-tablet/html/js/demos/fixedAssets/dashFixedAssets',['require','exports','module'],function (require, exports, module) {"use strict";
var _queryLinkArticlePA = {
	"$layoutType": "stack",
	"$items": [{
		"$bind": "$resources",
		"$display": "card",
		"$cardsPerRow": 3,
		"$card": {
			"$items": [{
				"$bind": "LCTCOD_REF"
			}, {
				"$bind": "PHYDES1"
			}, {
				"$bind": "PHYREF"
			}, {
				"$bind": "BAC"
			}, {
				"$bind": "PHOTO"
			}]
		}
	}]

};
var _queryLinkArticleLOC = {
	"$layoutType": "stack",
	"$items": [{
		"$bind": "$resources",
		"$display": "card",
		"$queryLinkArticle": _queryLinkArticleLOC,
		"$cardsPerRow": 3,
		"$card": {
			"$layoutType": "stack",
			"$items": [{
				"$bind": "BUICOD_REF"
			}, {
				"$bind": "LCTDES"
			}, {
				"$bind": "LCTCOD"
			}, {
				"$bind": "FLOOR"
			}, {
				"$bind": "BAC"
			}, {
				"$bind": "PHOTO"
			}]
		}
	}]
};

exports.dashboards = {
	"$fixedassetsDashboard": {
		"$dashboardName": "$fixedassetsDashboard",
		"$title": "Fixed Assets Dashboard",
		"$description": "",
		"$vignettes": {
			"$x3fixedassetsList": {
				"$uuid": "$x3fixedassetsList",
				"$displayStyle": "$full"
			},
			"$x3LocationList": {
				"$uuid": "$x3LocationList",
				"$displayStyle": "$full"
			},
			"$x3LocationCreateLink": {
				"$uuid": "$x3LocationCreate",
				"$displayStyle": "$link"
			},
			"$x3LocationListIco": {
				"$uuid": "$x3LocationList",
				"$displayStyle": "$link"
			},
			"$x3FixedAssetCreateLink": {
				"$uuid": "$x3FixedAssetCreate",
				"$displayStyle": "$link"
			},
			"$x3fixedassetsListIco": {
				"$uuid": "$x3fixedassetsList",
				"$displayStyle": "$link"
			},
			"$x3FixedAssetCreate": {
				"$uuid": "$x3FixedAssetCreate",
				"$displayStyle": "$full"
			},
			"$x3LocationCreate": {
				"$uuid": "$x3LocationCreate",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Create",
				"$items": [{
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3LocationCreateLink"
					}]

				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3LocationListIco"
					}]

				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3FixedAssetCreateLink"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3fixedassetsListIco"
					}]
				}]

			}, {
				"$layoutType": "hubGroup",
				"$title": "Queries",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Physical Assets - List",
					"$size": "full",
					"$items": [{
						"$bind": "$x3fixedassetsList",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "card",
								"$queryLinkArticle": _queryLinkArticlePA,
								"$cardsPerRow": 3,
								"$card": {
									"$items": [{
										"$bind": "LCTCOD_REF"
									}, {
										"$bind": "PHYDES1"
									}, {
										"$bind": "PHYREF"
									}, {
										"$bind": "BAC"
									}, {
										"$bind": "PHOTO"
									}]
								},
								"$arrayOptions": {
									"showSearch": true
								}
							}]
						}
					}]
				}, {
					"$layoutType": "tile",
					"$title": "Locations - List",
					"$size": "full",
					"$items": [{
						"$bind": "$x3LocationList",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "card",
								"$queryLinkArticle": _queryLinkArticleLOC,
								"$cardsPerRow": 3,
								"$card": {
									"$layoutType": "stack",
									"$items": [{
										"$bind": "BUICOD_REF"
									}, {
										"$bind": "LCTDES"
									}, {
										"$bind": "LCTCOD"
									}, {
										"$bind": "FLOOR"
									}, {
										"$bind": "BAC"
									}, {
										"$bind": "PHOTO"
									}]
								},
								"$arrayOptions": {
									"showSearch": true
								}
							}]
						}
					}]

				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Creations",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Physical Assets - Create",
					"$size": "full",
					"$items": [{
						"$bind": "$x3FixedAssetCreate",
						"$pageActionSettings": [{
							"name": "$save",
							"icon": {
								"css": "fa fa-check",
								"name": "check"
							},
							"$title": "Enregistrer",
							"options": {
								"footerHeader": true,
								"refreshPage": false,
								"multiselection": false
							}
						}],
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "LCTCOD_REF"
							}, {
								"$bind": "PHYDES1"
							}, {
								"$bind": "PHYREF"
							}, {
								"$bind": "BAC"
							}]

						}
					}]
				}, {
					"$layoutType": "tile",
					"$title": "Locations - Create",
					"$size": "full",
					"$items": [{
						"$bind": "$x3LocationCreate",
						"$pageActionSettings": [{
							"name": "$save",
							"icon": {
								"css": "fa fa-check",
								"name": "check"
							},
							"$title": "Enregistrer",
							"options": {
								"footerHeader": true,
								"refreshPage": false,
								"multiselection": false
							}
						}],
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "BUICOD_REF"
							}, {
								"$bind": "LCTDES"
							}, {
								"$bind": "LCTCOD"
							}, {
								"$bind": "FCY_REF"
							}, {
								"$bind": "BAC"
							}, {
								"$bind": "PHOTO"
							}]

						}
					}]

				}]
			}]
		}
	}
};
exports.gadgets = {
	"$x3fixedassetsList": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "PHYELT",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "PHYELTM",
		"facet": "$query",
		"icon": "s-m-physical-asset-query"
	},
	"$x3LocationList": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "PHYLCT",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "PHYLCTM",
		"facet": "$query",
		"icon": "s-m-location-query"
	},
	"$x3FixedAssetCreate": {
		"$type": "$representation",
		"$title": "Create Fixed Asset",
		"entity": "PHYELT",
		"endpoint": "x3.erp.GX3APP",
		"action": "$create",
		"representation": "PHYELTM",
		"facet": "$create",
		"icon": "s-m-physical-asset-create"
	},
	"$x3LocationCreate": {
		"$type": "$representation",
		"$title": "Create Location",
		"entity": "PHYLCT",
		"endpoint": "x3.erp.GX3APP",
		"action": "$create",
		"representation": "PHYLCTM",
		"facet": "$create",
		"icon": "s-m-location-create"
	}
};
});

define('syracuse-tablet/html/js/demos/fixedAssets/main',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/fixedAssets/dashFixedAssets','syracuse-tablet/html/js/demos/utils'],function (require, exports, module) {"use strict";

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var dashFixedAssets = require('syracuse-tablet/html/js/demos/fixedAssets/dashFixedAssets');
var demoUtils = require('syracuse-tablet/html/js/demos/utils');


var _demoApp = {
	"$application": {
		"$uuid": "$demoFixedassets",
		"applicationName": "PHYELT_MOBILE",
		"title": "Fixed Assets",
		"isSageApplication": true,
		"description": "",
		"iconName": "s-m-physical-assets",
		"$homeDashboard": {
			"$uuid": "$fixedassetsDashboard",
			"dashboardName": "$fixedassetsDashboard"
		}
	},
	"$dashboards": {},
	"$gadgets": {}
};

exports.register = function() {
	demoUtils.addToApp(_demoApp, dashFixedAssets);
	clientContract.registerApp(_demoApp);
};
});

define('syracuse-tablet/html/js/demos/availableStock/dashStock',['require','exports','module'],function (require, exports, module) {"use strict";

exports.dashboards = {
	"$stockDashboard": {
		"$dashboardName": "$stockDashboard",
		"$title": "Available Stock Dashboard",
		"$description": "",
		"$vignettes": {
			"$x3stockInquiry": {
				"$uuid": "$x3stockInquiry",
				"$displayStyle": "$link"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Available Stock",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Available Stock",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3stockInquiry"
					}]
				}]
			}]
		}
	}
};
exports.gadgets = {
	"$x3stockInquiry": {
		"$type": "$representation",
		"$title": "Stock inquiry",
		"entity": "STKCNSSDI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$create",
		"representation": "STKCNSSDIM",
		"facet": "$create",
		"icon": "s-m-sales-stockinquiry"
	}
};
});

define('syracuse-tablet/html/js/demos/availableStock/main',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/availableStock/dashStock','syracuse-tablet/html/js/demos/utils'],function (require, exports, module) {"use strict";

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var dashStock = require('syracuse-tablet/html/js/demos/availableStock/dashStock');
var demoUtils = require('syracuse-tablet/html/js/demos/utils');


var _demoApp = {
	"$application": {
		"$uuid": "$demoStock",
		"applicationName": "sageavailablestock",
		"title": "Available Stock",
		"isSageApplication": true,
		"description": "",
		"iconName": "s-m-stock-available",
		"$homeDashboard": {
			"$uuid": "$stockDashboard",
			"dashboardName": "$stockDashboard"
		}
	},
	"$dashboards": {},
	"$gadgets": {}
};

exports.register = function() {
	demoUtils.addToApp(_demoApp, dashStock);
	clientContract.registerApp(_demoApp);
};
});

define('syracuse-tablet/html/js/demos/main',['require','exports','module','syracuse-tablet/html/js/demos/salesMyCustomers/main','syracuse-tablet/html/js/demos/salesMyInquiries/main','syracuse-tablet/html/js/demos/salesMyActions/main','syracuse-tablet/html/js/demos/purchaseMyActions/main','syracuse-tablet/html/js/demos/purchaseMyInquiries/main','syracuse-tablet/html/js/demos/myExpenses/main','syracuse-tablet/html/js/demos/fixedAssets/main','syracuse-tablet/html/js/demos/availableStock/main'],function (require, exports, module) {"use strict";
var _demos = {
	salesMyCustomers: require('syracuse-tablet/html/js/demos/salesMyCustomers/main'),
	salesMyInquiries: require('syracuse-tablet/html/js/demos/salesMyInquiries/main'),
	salesMyActions: require('syracuse-tablet/html/js/demos/salesMyActions/main'),
	purchaseMyActions: require('syracuse-tablet/html/js/demos/purchaseMyActions/main'),
	purchaseMyInquiries: require('syracuse-tablet/html/js/demos/purchaseMyInquiries/main'),
	myExpenses: require('syracuse-tablet/html/js/demos/myExpenses/main'),
	fixedAssets: require('syracuse-tablet/html/js/demos/fixedAssets/main'),
	availableStock: require('syracuse-tablet/html/js/demos/availableStock/main')
};

exports.init = function() {
	for (var p in _demos) {
		try {
			_demos[p].register();
		} catch (e) {
			console.error("!!Error registering demo[" + p + "]", e.stack);
		}
	}
};
});

define('syracuse-tablet/html/js/helpers/unitTestManager',['require','exports','module','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var _application = globals.getApplication();

var _notifPageLoaded = function(step, page) {
	if (step == "before") {
		$('[data-s-ut-page-is-current]').removeAttr("data-s-ut-page-is-current");
		return;
	}
	if (step == "after") {
		if (!page) {
			return;
		}
		// Put page name on vignettes too once they are loaded so we can easily find them too
		page.$$elmt.attr("data-s-ut-page-name", page.state.name);
		if (page.isVignette) {
			return;
		}
		// Put current page flag on top level page only
		page.$$elmt.attr("data-s-ut-page-is-current", page.state.name);
		return;
	}
};
var _notifUserCtxChanged = function(ctx, endpoint) {
	globals.getApplication().$$elmt.removeAttr("data-s-ut-user-ctx");
	if (ctx && endpoint) {
		var data = [ctx.$user || "", ctx.$role || "", ctx.$lang || "", endpoint || ""];
		globals.getApplication().$$elmt.attr("data-s-ut-user-ctx", data.join(','));
	}
};
var _notifDeviceChanged = function(device, orientation) {
	globals.getApplication().$$elmt.attr("data-s-ut-device", device + "," + orientation);
};
var _arrayAddRowInfo = function($$elmt, idx, rowData) {
	$$elmt.attr("data-s-ut-row-idx", idx);
};
var _addStructElmtId = function($$elmt, info) {
	$$elmt.attr("data-s-ut-elmt-id", info);
};
var _authAddRightPanelId = function($$elmt, id) {
	if (id) {
		$$elmt.attr("data-s-ut-auth-selected-elmt", id);
	} else {
		$$elmt.removeAttr("data-s-ut-auth-selected-elmt");
	}

};
var _addBindAttribute = function(ctrl) {
	if (ctrl && ctrl.$$elmt && ctrl.$bind) {
		ctrl.$$elmt.attr("data-s-ut-field-x3name", ctrl.$bind);
	}
};

var _authAddTreeElmtId = function($$elmt, info) {
	$$elmt.attr("data-s-ut-auth-elmt-id", info);
};

var _init = function() {
	globals.setUnitTestMgr(exports);
};


exports.notifPageLoaded = _notifPageLoaded;
exports.notifUserCtxChanged = _notifUserCtxChanged;
exports.notifDeviceChanged = _notifDeviceChanged;
exports.arrayAddRowIndex = _arrayAddRowInfo;
exports.addStructElmtId = _addStructElmtId;
exports.authAddRightPanelId = _authAddRightPanelId;
exports.authAddTreeElmtId = _authAddTreeElmtId;
exports.addBindAttribute = _addBindAttribute;
exports.init = _init;

// Make available externally so selenium can interact with this module (Especially functions following below) 
window.$unitTestManager = exports;

// Used to trigger blur event on the element that got the focus
exports.blurFocusElmt = function() {
	$(":focus").blur();
};
});

define('syracuse-tablet/html/js/init/initModules',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/application/appFactory','syracuse-tablet/html/js/application/appFactoryDeps','syracuse-tablet/html/js/controls/ctrlFactoryDeps','syracuse-tablet/html/js/ajax/ajax','syracuse-tablet/html/js/storage/storage','syracuse-tablet/html/js/sdata/sdataCache','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/helpers/siteLayout','syracuse-tablet/html/js/application/metaData','syracuse-tablet/html/js/ui/developmentPage','syracuse-tablet/html/js/helpers/uiSettings','syracuse-tablet/html/js/helpers/offlineManager','syracuse-tablet/html/js/application/pageRegistry','syracuse-tablet/html/js/demos/clientTestApp/testApplication','syracuse-tablet/html/js/sdata/entities/welcomeApplication','syracuse-tablet/html/js/demos/main','syracuse-tablet/html/js/helpers/unitTestManager'],function (require, exports, module) {"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var factory = require('syracuse-tablet/html/js/application/appFactory');
var appFactoryDeps = require('syracuse-tablet/html/js/application/appFactoryDeps');
var ctrlFactoryDeps = require('syracuse-tablet/html/js/controls/ctrlFactoryDeps');

var ajax = require('syracuse-tablet/html/js/ajax/ajax');
var storage = require('syracuse-tablet/html/js/storage/storage');
var sdataCache = require('syracuse-tablet/html/js/sdata/sdataCache');

var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var siteLayout = require('syracuse-tablet/html/js/helpers/siteLayout');
var metaData = require('syracuse-tablet/html/js/application/metaData');
var developmentPage = require('syracuse-tablet/html/js/ui/developmentPage');
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');
var offlineManager = require('syracuse-tablet/html/js/helpers/offlineManager');
var pageRegistry = require('syracuse-tablet/html/js/application/pageRegistry');

//fully client side configured application to add tests later
var testApplication = require('syracuse-tablet/html/js/demos/clientTestApp/testApplication');
var welcomeApplication = require('syracuse-tablet/html/js/sdata/entities/welcomeApplication');
var demos = require('syracuse-tablet/html/js/demos/main');

exports.init = function() {
	return $.smResolve().then(function() {
		var st;
		var cache;
		uiSettings.init();
		offlineManager.init();
		pageRegistry.init();
		globals.setSiteLayout(siteLayout);
		// Can potentially throw an exception
		st = storage.getStorage();
		return st.init()
			.then(function() {
				cache = new sdataCache.SDataCache(st);
			})
			.then(function() {
				globals.init(jsutils.isDvlpVersion() || utils.forceDvlpMode(), st, cache, utils);
				globals.setMetaData(metaData);
			})
			.then(function() {
				return appFactoryDeps.init();
			})
			.then(function() {
				return ctrlFactoryDeps.init();
			})
			.then(function() {
				ajax.init({}, locale);
				utils.init(locale);
			})
			.then(function() {
				welcomeApplication.register();
				demos.init();
			})
			.then(function() {
				if (globals.isDvlpMode()) {
					testApplication.register();
				}
				if (globals.isAutoUITestMode()) {
					require('syracuse-tablet/html/js/helpers/unitTestManager').init();
				}
			})
			.then(function() {
				var app = factory.createApplication($("#s-m-app-id"));
				globals.setTabletApplication(app);
				globals.setModal(modal);
			})
			.then(function() {
				_applyDevelopmentSettings();
			})
			.then(function() {
				uiutils.triggerResizeInternal();
			});
	});
};

function _applyDevelopmentSettings() {
	if (globals.isDvlpMode() && globals.isDesktop()) {
		if (developmentPage.wasActive()) {
			developmentPage.show();
		}
	}
}
});

define('syracuse-tablet/html/js/helpers/native/nativeJSCall',['require','exports','module','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {"use strict";

/*
 * This module is called by an external wrapper and maps the calls to javascript methods
 */

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeJSCall");

exports.init = function() {

	if (!(window.smJSCall)) {
		/*
		 * This method is the only one that will ever be invoked by wrapper code
		 * It dispatches all incomming calls to dedicated objects per domain
		 */
		window.smJSCall = function(objectName, methodName, jsonParam) {
			try {
				log && log("smJSCall (objectName): " + objectName);
				log && log("smJSCall (methodName): " + methodName);
				log && log("smJSCall (jsonParam): " + jsonParam);

				var obj = window[objectName];
				var method = obj && obj[methodName];
				var data = jsonParam;
				try { // try to parse json, if it fails, data is assumed to be a plain string
					data = JSON.parse(jsonParam);
				} catch (e) {}
				var ret = method && method.call(obj, data);

				// Only strings supported right now!
				if (typeof ret !== "string") {
					ret = "" + ret;
				}
				log && log("smJSCall (return): " + ret);
				return ret;
			} catch (ex) {
				log && log(JSON.stringify(ex));
				throw ex;
			}
		};
	}
};
});

/*!

 handlebars v2.0.0

Copyright (C) 2011-2014 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license
*/
/* exported Handlebars */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define('syracuse-tablet/html/deps/handlebars-latest',[], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    root.Handlebars = root.Handlebars || factory();
  }
}(this, function () {
// handlebars/safe-string.js
var __module4__ = (function() {
  "use strict";
  var __exports__;
  // Build out our basic SafeString type
  function SafeString(string) {
    this.string = string;
  }

  SafeString.prototype.toString = function() {
    return "" + this.string;
  };

  __exports__ = SafeString;
  return __exports__;
})();

// handlebars/utils.js
var __module3__ = (function(__dependency1__) {
  "use strict";
  var __exports__ = {};
  /*jshint -W004 */
  var SafeString = __dependency1__;

  var escape = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "`": "&#x60;"
  };

  var badChars = /[&<>"'`]/g;
  var possible = /[&<>"'`]/;

  function escapeChar(chr) {
    return escape[chr];
  }

  function extend(obj /* , ...source */) {
    for (var i = 1; i < arguments.length; i++) {
      for (var key in arguments[i]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
          obj[key] = arguments[i][key];
        }
      }
    }

    return obj;
  }

  __exports__.extend = extend;var toString = Object.prototype.toString;
  __exports__.toString = toString;
  // Sourced from lodash
  // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
  var isFunction = function(value) {
    return typeof value === 'function';
  };
  // fallback for older versions of Chrome and Safari
  /* istanbul ignore next */
  if (isFunction(/x/)) {
    isFunction = function(value) {
      return typeof value === 'function' && toString.call(value) === '[object Function]';
    };
  }
  var isFunction;
  __exports__.isFunction = isFunction;
  /* istanbul ignore next */
  var isArray = Array.isArray || function(value) {
    return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
  };
  __exports__.isArray = isArray;

  function escapeExpression(string) {
    // don't escape SafeStrings, since they're already safe
    if (string instanceof SafeString) {
      return string.toString();
    } else if (string == null) {
      return "";
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = "" + string;

    if(!possible.test(string)) { return string; }
    return string.replace(badChars, escapeChar);
  }

  __exports__.escapeExpression = escapeExpression;function isEmpty(value) {
    if (!value && value !== 0) {
      return true;
    } else if (isArray(value) && value.length === 0) {
      return true;
    } else {
      return false;
    }
  }

  __exports__.isEmpty = isEmpty;function appendContextPath(contextPath, id) {
    return (contextPath ? contextPath + '.' : '') + id;
  }

  __exports__.appendContextPath = appendContextPath;
  return __exports__;
})(__module4__);

// handlebars/exception.js
var __module5__ = (function() {
  "use strict";
  var __exports__;

  var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

  function Exception(message, node) {
    var line;
    if (node && node.firstLine) {
      line = node.firstLine;

      message += ' - ' + line + ':' + node.firstColumn;
    }

    var tmp = Error.prototype.constructor.call(this, message);

    // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
    for (var idx = 0; idx < errorProps.length; idx++) {
      this[errorProps[idx]] = tmp[errorProps[idx]];
    }

    if (line) {
      this.lineNumber = line;
      this.column = node.firstColumn;
    }
  }

  Exception.prototype = new Error();

  __exports__ = Exception;
  return __exports__;
})();

// handlebars/base.js
var __module2__ = (function(__dependency1__, __dependency2__) {
  "use strict";
  var __exports__ = {};
  var Utils = __dependency1__;
  var Exception = __dependency2__;

  var VERSION = "2.0.0";
  __exports__.VERSION = VERSION;var COMPILER_REVISION = 6;
  __exports__.COMPILER_REVISION = COMPILER_REVISION;
  var REVISION_CHANGES = {
    1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
    2: '== 1.0.0-rc.3',
    3: '== 1.0.0-rc.4',
    4: '== 1.x.x',
    5: '== 2.0.0-alpha.x',
    6: '>= 2.0.0-beta.1'
  };
  __exports__.REVISION_CHANGES = REVISION_CHANGES;
  var isArray = Utils.isArray,
      isFunction = Utils.isFunction,
      toString = Utils.toString,
      objectType = '[object Object]';

  function HandlebarsEnvironment(helpers, partials) {
    this.helpers = helpers || {};
    this.partials = partials || {};

    registerDefaultHelpers(this);
  }

  __exports__.HandlebarsEnvironment = HandlebarsEnvironment;HandlebarsEnvironment.prototype = {
    constructor: HandlebarsEnvironment,

    logger: logger,
    log: log,

    registerHelper: function(name, fn) {
      if (toString.call(name) === objectType) {
        if (fn) { throw new Exception('Arg not supported with multiple helpers'); }
        Utils.extend(this.helpers, name);
      } else {
        this.helpers[name] = fn;
      }
    },
    unregisterHelper: function(name) {
      delete this.helpers[name];
    },

    registerPartial: function(name, partial) {
      if (toString.call(name) === objectType) {
        Utils.extend(this.partials,  name);
      } else {
        this.partials[name] = partial;
      }
    },
    unregisterPartial: function(name) {
      delete this.partials[name];
    }
  };

  function registerDefaultHelpers(instance) {
    instance.registerHelper('helperMissing', function(/* [args, ]options */) {
      if(arguments.length === 1) {
        // A missing field in a {{foo}} constuct.
        return undefined;
      } else {
        // Someone is actually trying to call something, blow up.
        throw new Exception("Missing helper: '" + arguments[arguments.length-1].name + "'");
      }
    });

    instance.registerHelper('blockHelperMissing', function(context, options) {
      var inverse = options.inverse,
          fn = options.fn;

      if(context === true) {
        return fn(this);
      } else if(context === false || context == null) {
        return inverse(this);
      } else if (isArray(context)) {
        if(context.length > 0) {
          if (options.ids) {
            options.ids = [options.name];
          }

          return instance.helpers.each(context, options);
        } else {
          return inverse(this);
        }
      } else {
        if (options.data && options.ids) {
          var data = createFrame(options.data);
          data.contextPath = Utils.appendContextPath(options.data.contextPath, options.name);
          options = {data: data};
        }

        return fn(context, options);
      }
    });

    instance.registerHelper('each', function(context, options) {
      if (!options) {
        throw new Exception('Must pass iterator to #each');
      }

      var fn = options.fn, inverse = options.inverse;
      var i = 0, ret = "", data;

      var contextPath;
      if (options.data && options.ids) {
        contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
      }

      if (isFunction(context)) { context = context.call(this); }

      if (options.data) {
        data = createFrame(options.data);
      }

      if(context && typeof context === 'object') {
        if (isArray(context)) {
          for(var j = context.length; i<j; i++) {
            if (data) {
              data.index = i;
              data.first = (i === 0);
              data.last  = (i === (context.length-1));

              if (contextPath) {
                data.contextPath = contextPath + i;
              }
            }
            ret = ret + fn(context[i], { data: data });
          }
        } else {
          for(var key in context) {
            if(context.hasOwnProperty(key)) {
              if(data) {
                data.key = key;
                data.index = i;
                data.first = (i === 0);

                if (contextPath) {
                  data.contextPath = contextPath + key;
                }
              }
              ret = ret + fn(context[key], {data: data});
              i++;
            }
          }
        }
      }

      if(i === 0){
        ret = inverse(this);
      }

      return ret;
    });

    instance.registerHelper('if', function(conditional, options) {
      if (isFunction(conditional)) { conditional = conditional.call(this); }

      // Default behavior is to render the positive path if the value is truthy and not empty.
      // The `includeZero` option may be set to treat the condtional as purely not empty based on the
      // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
      if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
        return options.inverse(this);
      } else {
        return options.fn(this);
      }
    });

    instance.registerHelper('unless', function(conditional, options) {
      return instance.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn, hash: options.hash});
    });

    instance.registerHelper('with', function(context, options) {
      if (isFunction(context)) { context = context.call(this); }

      var fn = options.fn;

      if (!Utils.isEmpty(context)) {
        if (options.data && options.ids) {
          var data = createFrame(options.data);
          data.contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]);
          options = {data:data};
        }

        return fn(context, options);
      } else {
        return options.inverse(this);
      }
    });

    instance.registerHelper('log', function(message, options) {
      var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
      instance.log(level, message);
    });

    instance.registerHelper('lookup', function(obj, field) {
      return obj && obj[field];
    });
  }

  var logger = {
    methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

    // State enum
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3,
    level: 3,

    // can be overridden in the host environment
    log: function(level, message) {
      if (logger.level <= level) {
        var method = logger.methodMap[level];
        if (typeof console !== 'undefined' && console[method]) {
          console[method].call(console, message);
        }
      }
    }
  };
  __exports__.logger = logger;
  var log = logger.log;
  __exports__.log = log;
  var createFrame = function(object) {
    var frame = Utils.extend({}, object);
    frame._parent = object;
    return frame;
  };
  __exports__.createFrame = createFrame;
  return __exports__;
})(__module3__, __module5__);

// handlebars/runtime.js
var __module6__ = (function(__dependency1__, __dependency2__, __dependency3__) {
  "use strict";
  var __exports__ = {};
  var Utils = __dependency1__;
  var Exception = __dependency2__;
  var COMPILER_REVISION = __dependency3__.COMPILER_REVISION;
  var REVISION_CHANGES = __dependency3__.REVISION_CHANGES;
  var createFrame = __dependency3__.createFrame;

  function checkRevision(compilerInfo) {
    var compilerRevision = compilerInfo && compilerInfo[0] || 1,
        currentRevision = COMPILER_REVISION;

    if (compilerRevision !== currentRevision) {
      if (compilerRevision < currentRevision) {
        var runtimeVersions = REVISION_CHANGES[currentRevision],
            compilerVersions = REVISION_CHANGES[compilerRevision];
        throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. "+
              "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").");
      } else {
        // Use the embedded version info since the runtime doesn't know about this revision yet
        throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. "+
              "Please update your runtime to a newer version ("+compilerInfo[1]+").");
      }
    }
  }

  __exports__.checkRevision = checkRevision;// TODO: Remove this line and break up compilePartial

  function template(templateSpec, env) {
    /* istanbul ignore next */
    if (!env) {
      throw new Exception("No environment passed to template");
    }
    if (!templateSpec || !templateSpec.main) {
      throw new Exception('Unknown template object: ' + typeof templateSpec);
    }

    // Note: Using env.VM references rather than local var references throughout this section to allow
    // for external users to override these as psuedo-supported APIs.
    env.VM.checkRevision(templateSpec.compiler);

    var invokePartialWrapper = function(partial, indent, name, context, hash, helpers, partials, data, depths) {
      if (hash) {
        context = Utils.extend({}, context, hash);
      }

      var result = env.VM.invokePartial.call(this, partial, name, context, helpers, partials, data, depths);

      if (result == null && env.compile) {
        var options = { helpers: helpers, partials: partials, data: data, depths: depths };
        partials[name] = env.compile(partial, { data: data !== undefined, compat: templateSpec.compat }, env);
        result = partials[name](context, options);
      }
      if (result != null) {
        if (indent) {
          var lines = result.split('\n');
          for (var i = 0, l = lines.length; i < l; i++) {
            if (!lines[i] && i + 1 === l) {
              break;
            }

            lines[i] = indent + lines[i];
          }
          result = lines.join('\n');
        }
        return result;
      } else {
        throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
      }
    };

    // Just add water
    var container = {
      lookup: function(depths, name) {
        var len = depths.length;
        for (var i = 0; i < len; i++) {
          if (depths[i] && depths[i][name] != null) {
            return depths[i][name];
          }
        }
      },
      lambda: function(current, context) {
        return typeof current === 'function' ? current.call(context) : current;
      },

      escapeExpression: Utils.escapeExpression,
      invokePartial: invokePartialWrapper,

      fn: function(i) {
        return templateSpec[i];
      },

      programs: [],
      program: function(i, data, depths) {
        var programWrapper = this.programs[i],
            fn = this.fn(i);
        if (data || depths) {
          programWrapper = program(this, i, fn, data, depths);
        } else if (!programWrapper) {
          programWrapper = this.programs[i] = program(this, i, fn);
        }
        return programWrapper;
      },

      data: function(data, depth) {
        while (data && depth--) {
          data = data._parent;
        }
        return data;
      },
      merge: function(param, common) {
        var ret = param || common;

        if (param && common && (param !== common)) {
          ret = Utils.extend({}, common, param);
        }

        return ret;
      },

      noop: env.VM.noop,
      compilerInfo: templateSpec.compiler
    };

    var ret = function(context, options) {
      options = options || {};
      var data = options.data;

      ret._setup(options);
      if (!options.partial && templateSpec.useData) {
        data = initData(context, data);
      }
      var depths;
      if (templateSpec.useDepths) {
        depths = options.depths ? [context].concat(options.depths) : [context];
      }

      return templateSpec.main.call(container, context, container.helpers, container.partials, data, depths);
    };
    ret.isTop = true;

    ret._setup = function(options) {
      if (!options.partial) {
        container.helpers = container.merge(options.helpers, env.helpers);

        if (templateSpec.usePartial) {
          container.partials = container.merge(options.partials, env.partials);
        }
      } else {
        container.helpers = options.helpers;
        container.partials = options.partials;
      }
    };

    ret._child = function(i, data, depths) {
      if (templateSpec.useDepths && !depths) {
        throw new Exception('must pass parent depths');
      }

      return program(container, i, templateSpec[i], data, depths);
    };
    return ret;
  }

  __exports__.template = template;function program(container, i, fn, data, depths) {
    var prog = function(context, options) {
      options = options || {};

      return fn.call(container, context, container.helpers, container.partials, options.data || data, depths && [context].concat(depths));
    };
    prog.program = i;
    prog.depth = depths ? depths.length : 0;
    return prog;
  }

  __exports__.program = program;function invokePartial(partial, name, context, helpers, partials, data, depths) {
    var options = { partial: true, helpers: helpers, partials: partials, data: data, depths: depths };

    if(partial === undefined) {
      throw new Exception("The partial " + name + " could not be found");
    } else if(partial instanceof Function) {
      return partial(context, options);
    }
  }

  __exports__.invokePartial = invokePartial;function noop() { return ""; }

  __exports__.noop = noop;function initData(context, data) {
    if (!data || !('root' in data)) {
      data = data ? createFrame(data) : {};
      data.root = context;
    }
    return data;
  }
  return __exports__;
})(__module3__, __module5__, __module2__);

// handlebars.runtime.js
var __module1__ = (function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__) {
  "use strict";
  var __exports__;
  /*globals Handlebars: true */
  var base = __dependency1__;

  // Each of these augment the Handlebars object. No need to setup here.
  // (This is done to easily share code between commonjs and browse envs)
  var SafeString = __dependency2__;
  var Exception = __dependency3__;
  var Utils = __dependency4__;
  var runtime = __dependency5__;

  // For compatibility and usage outside of module systems, make the Handlebars object a namespace
  var create = function() {
    var hb = new base.HandlebarsEnvironment();

    Utils.extend(hb, base);
    hb.SafeString = SafeString;
    hb.Exception = Exception;
    hb.Utils = Utils;
    hb.escapeExpression = Utils.escapeExpression;

    hb.VM = runtime;
    hb.template = function(spec) {
      return runtime.template(spec, hb);
    };

    return hb;
  };

  var Handlebars = create();
  Handlebars.create = create;

  Handlebars['default'] = Handlebars;

  __exports__ = Handlebars;
  return __exports__;
})(__module2__, __module4__, __module5__, __module3__, __module6__);

// handlebars/compiler/ast.js
var __module7__ = (function(__dependency1__) {
  "use strict";
  var __exports__;
  var Exception = __dependency1__;

  function LocationInfo(locInfo) {
    locInfo = locInfo || {};
    this.firstLine   = locInfo.first_line;
    this.firstColumn = locInfo.first_column;
    this.lastColumn  = locInfo.last_column;
    this.lastLine    = locInfo.last_line;
  }

  var AST = {
    ProgramNode: function(statements, strip, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "program";
      this.statements = statements;
      this.strip = strip;
    },

    MustacheNode: function(rawParams, hash, open, strip, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "mustache";
      this.strip = strip;

      // Open may be a string parsed from the parser or a passed boolean flag
      if (open != null && open.charAt) {
        // Must use charAt to support IE pre-10
        var escapeFlag = open.charAt(3) || open.charAt(2);
        this.escaped = escapeFlag !== '{' && escapeFlag !== '&';
      } else {
        this.escaped = !!open;
      }

      if (rawParams instanceof AST.SexprNode) {
        this.sexpr = rawParams;
      } else {
        // Support old AST API
        this.sexpr = new AST.SexprNode(rawParams, hash);
      }

      // Support old AST API that stored this info in MustacheNode
      this.id = this.sexpr.id;
      this.params = this.sexpr.params;
      this.hash = this.sexpr.hash;
      this.eligibleHelper = this.sexpr.eligibleHelper;
      this.isHelper = this.sexpr.isHelper;
    },

    SexprNode: function(rawParams, hash, locInfo) {
      LocationInfo.call(this, locInfo);

      this.type = "sexpr";
      this.hash = hash;

      var id = this.id = rawParams[0];
      var params = this.params = rawParams.slice(1);

      // a mustache is definitely a helper if:
      // * it is an eligible helper, and
      // * it has at least one parameter or hash segment
      this.isHelper = !!(params.length || hash);

      // a mustache is an eligible helper if:
      // * its id is simple (a single part, not `this` or `..`)
      this.eligibleHelper = this.isHelper || id.isSimple;

      // if a mustache is an eligible helper but not a definite
      // helper, it is ambiguous, and will be resolved in a later
      // pass or at runtime.
    },

    PartialNode: function(partialName, context, hash, strip, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type         = "partial";
      this.partialName  = partialName;
      this.context      = context;
      this.hash = hash;
      this.strip = strip;

      this.strip.inlineStandalone = true;
    },

    BlockNode: function(mustache, program, inverse, strip, locInfo) {
      LocationInfo.call(this, locInfo);

      this.type = 'block';
      this.mustache = mustache;
      this.program  = program;
      this.inverse  = inverse;
      this.strip = strip;

      if (inverse && !program) {
        this.isInverse = true;
      }
    },

    RawBlockNode: function(mustache, content, close, locInfo) {
      LocationInfo.call(this, locInfo);

      if (mustache.sexpr.id.original !== close) {
        throw new Exception(mustache.sexpr.id.original + " doesn't match " + close, this);
      }

      content = new AST.ContentNode(content, locInfo);

      this.type = 'block';
      this.mustache = mustache;
      this.program = new AST.ProgramNode([content], {}, locInfo);
    },

    ContentNode: function(string, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "content";
      this.original = this.string = string;
    },

    HashNode: function(pairs, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "hash";
      this.pairs = pairs;
    },

    IdNode: function(parts, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "ID";

      var original = "",
          dig = [],
          depth = 0,
          depthString = '';

      for(var i=0,l=parts.length; i<l; i++) {
        var part = parts[i].part;
        original += (parts[i].separator || '') + part;

        if (part === ".." || part === "." || part === "this") {
          if (dig.length > 0) {
            throw new Exception("Invalid path: " + original, this);
          } else if (part === "..") {
            depth++;
            depthString += '../';
          } else {
            this.isScoped = true;
          }
        } else {
          dig.push(part);
        }
      }

      this.original = original;
      this.parts    = dig;
      this.string   = dig.join('.');
      this.depth    = depth;
      this.idName   = depthString + this.string;

      // an ID is simple if it only has one part, and that part is not
      // `..` or `this`.
      this.isSimple = parts.length === 1 && !this.isScoped && depth === 0;

      this.stringModeValue = this.string;
    },

    PartialNameNode: function(name, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "PARTIAL_NAME";
      this.name = name.original;
    },

    DataNode: function(id, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "DATA";
      this.id = id;
      this.stringModeValue = id.stringModeValue;
      this.idName = '@' + id.stringModeValue;
    },

    StringNode: function(string, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "STRING";
      this.original =
        this.string =
        this.stringModeValue = string;
    },

    NumberNode: function(number, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "NUMBER";
      this.original =
        this.number = number;
      this.stringModeValue = Number(number);
    },

    BooleanNode: function(bool, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "BOOLEAN";
      this.bool = bool;
      this.stringModeValue = bool === "true";
    },

    CommentNode: function(comment, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "comment";
      this.comment = comment;

      this.strip = {
        inlineStandalone: true
      };
    }
  };


  // Must be exported as an object rather than the root of the module as the jison lexer
  // most modify the object to operate properly.
  __exports__ = AST;
  return __exports__;
})(__module5__);

// handlebars/compiler/parser.js
var __module9__ = (function() {
  "use strict";
  var __exports__;
  /* jshint ignore:start */
  /* istanbul ignore next */
  /* Jison generated parser */
  var handlebars = (function(){
  var parser = {trace: function trace() { },
  yy: {},
  symbols_: {"error":2,"root":3,"program":4,"EOF":5,"program_repetition0":6,"statement":7,"mustache":8,"block":9,"rawBlock":10,"partial":11,"CONTENT":12,"COMMENT":13,"openRawBlock":14,"END_RAW_BLOCK":15,"OPEN_RAW_BLOCK":16,"sexpr":17,"CLOSE_RAW_BLOCK":18,"openBlock":19,"block_option0":20,"closeBlock":21,"openInverse":22,"block_option1":23,"OPEN_BLOCK":24,"CLOSE":25,"OPEN_INVERSE":26,"inverseAndProgram":27,"INVERSE":28,"OPEN_ENDBLOCK":29,"path":30,"OPEN":31,"OPEN_UNESCAPED":32,"CLOSE_UNESCAPED":33,"OPEN_PARTIAL":34,"partialName":35,"param":36,"partial_option0":37,"partial_option1":38,"sexpr_repetition0":39,"sexpr_option0":40,"dataName":41,"STRING":42,"NUMBER":43,"BOOLEAN":44,"OPEN_SEXPR":45,"CLOSE_SEXPR":46,"hash":47,"hash_repetition_plus0":48,"hashSegment":49,"ID":50,"EQUALS":51,"DATA":52,"pathSegments":53,"SEP":54,"$accept":0,"$end":1},
  terminals_: {2:"error",5:"EOF",12:"CONTENT",13:"COMMENT",15:"END_RAW_BLOCK",16:"OPEN_RAW_BLOCK",18:"CLOSE_RAW_BLOCK",24:"OPEN_BLOCK",25:"CLOSE",26:"OPEN_INVERSE",28:"INVERSE",29:"OPEN_ENDBLOCK",31:"OPEN",32:"OPEN_UNESCAPED",33:"CLOSE_UNESCAPED",34:"OPEN_PARTIAL",42:"STRING",43:"NUMBER",44:"BOOLEAN",45:"OPEN_SEXPR",46:"CLOSE_SEXPR",50:"ID",51:"EQUALS",52:"DATA",54:"SEP"},
  productions_: [0,[3,2],[4,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[10,3],[14,3],[9,4],[9,4],[19,3],[22,3],[27,2],[21,3],[8,3],[8,3],[11,5],[11,4],[17,3],[17,1],[36,1],[36,1],[36,1],[36,1],[36,1],[36,3],[47,1],[49,3],[35,1],[35,1],[35,1],[41,2],[30,1],[53,3],[53,1],[6,0],[6,2],[20,0],[20,1],[23,0],[23,1],[37,0],[37,1],[38,0],[38,1],[39,0],[39,2],[40,0],[40,1],[48,1],[48,2]],
  performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {

  var $0 = $$.length - 1;
  switch (yystate) {
  case 1: yy.prepareProgram($$[$0-1].statements, true); return $$[$0-1]; 
  break;
  case 2:this.$ = new yy.ProgramNode(yy.prepareProgram($$[$0]), {}, this._$);
  break;
  case 3:this.$ = $$[$0];
  break;
  case 4:this.$ = $$[$0];
  break;
  case 5:this.$ = $$[$0];
  break;
  case 6:this.$ = $$[$0];
  break;
  case 7:this.$ = new yy.ContentNode($$[$0], this._$);
  break;
  case 8:this.$ = new yy.CommentNode($$[$0], this._$);
  break;
  case 9:this.$ = new yy.RawBlockNode($$[$0-2], $$[$0-1], $$[$0], this._$);
  break;
  case 10:this.$ = new yy.MustacheNode($$[$0-1], null, '', '', this._$);
  break;
  case 11:this.$ = yy.prepareBlock($$[$0-3], $$[$0-2], $$[$0-1], $$[$0], false, this._$);
  break;
  case 12:this.$ = yy.prepareBlock($$[$0-3], $$[$0-2], $$[$0-1], $$[$0], true, this._$);
  break;
  case 13:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], yy.stripFlags($$[$0-2], $$[$0]), this._$);
  break;
  case 14:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], yy.stripFlags($$[$0-2], $$[$0]), this._$);
  break;
  case 15:this.$ = { strip: yy.stripFlags($$[$0-1], $$[$0-1]), program: $$[$0] };
  break;
  case 16:this.$ = {path: $$[$0-1], strip: yy.stripFlags($$[$0-2], $$[$0])};
  break;
  case 17:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], yy.stripFlags($$[$0-2], $$[$0]), this._$);
  break;
  case 18:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], yy.stripFlags($$[$0-2], $$[$0]), this._$);
  break;
  case 19:this.$ = new yy.PartialNode($$[$0-3], $$[$0-2], $$[$0-1], yy.stripFlags($$[$0-4], $$[$0]), this._$);
  break;
  case 20:this.$ = new yy.PartialNode($$[$0-2], undefined, $$[$0-1], yy.stripFlags($$[$0-3], $$[$0]), this._$);
  break;
  case 21:this.$ = new yy.SexprNode([$$[$0-2]].concat($$[$0-1]), $$[$0], this._$);
  break;
  case 22:this.$ = new yy.SexprNode([$$[$0]], null, this._$);
  break;
  case 23:this.$ = $$[$0];
  break;
  case 24:this.$ = new yy.StringNode($$[$0], this._$);
  break;
  case 25:this.$ = new yy.NumberNode($$[$0], this._$);
  break;
  case 26:this.$ = new yy.BooleanNode($$[$0], this._$);
  break;
  case 27:this.$ = $$[$0];
  break;
  case 28:$$[$0-1].isHelper = true; this.$ = $$[$0-1];
  break;
  case 29:this.$ = new yy.HashNode($$[$0], this._$);
  break;
  case 30:this.$ = [$$[$0-2], $$[$0]];
  break;
  case 31:this.$ = new yy.PartialNameNode($$[$0], this._$);
  break;
  case 32:this.$ = new yy.PartialNameNode(new yy.StringNode($$[$0], this._$), this._$);
  break;
  case 33:this.$ = new yy.PartialNameNode(new yy.NumberNode($$[$0], this._$));
  break;
  case 34:this.$ = new yy.DataNode($$[$0], this._$);
  break;
  case 35:this.$ = new yy.IdNode($$[$0], this._$);
  break;
  case 36: $$[$0-2].push({part: $$[$0], separator: $$[$0-1]}); this.$ = $$[$0-2]; 
  break;
  case 37:this.$ = [{part: $$[$0]}];
  break;
  case 38:this.$ = [];
  break;
  case 39:$$[$0-1].push($$[$0]);
  break;
  case 48:this.$ = [];
  break;
  case 49:$$[$0-1].push($$[$0]);
  break;
  case 52:this.$ = [$$[$0]];
  break;
  case 53:$$[$0-1].push($$[$0]);
  break;
  }
  },
  table: [{3:1,4:2,5:[2,38],6:3,12:[2,38],13:[2,38],16:[2,38],24:[2,38],26:[2,38],31:[2,38],32:[2,38],34:[2,38]},{1:[3]},{5:[1,4]},{5:[2,2],7:5,8:6,9:7,10:8,11:9,12:[1,10],13:[1,11],14:16,16:[1,20],19:14,22:15,24:[1,18],26:[1,19],28:[2,2],29:[2,2],31:[1,12],32:[1,13],34:[1,17]},{1:[2,1]},{5:[2,39],12:[2,39],13:[2,39],16:[2,39],24:[2,39],26:[2,39],28:[2,39],29:[2,39],31:[2,39],32:[2,39],34:[2,39]},{5:[2,3],12:[2,3],13:[2,3],16:[2,3],24:[2,3],26:[2,3],28:[2,3],29:[2,3],31:[2,3],32:[2,3],34:[2,3]},{5:[2,4],12:[2,4],13:[2,4],16:[2,4],24:[2,4],26:[2,4],28:[2,4],29:[2,4],31:[2,4],32:[2,4],34:[2,4]},{5:[2,5],12:[2,5],13:[2,5],16:[2,5],24:[2,5],26:[2,5],28:[2,5],29:[2,5],31:[2,5],32:[2,5],34:[2,5]},{5:[2,6],12:[2,6],13:[2,6],16:[2,6],24:[2,6],26:[2,6],28:[2,6],29:[2,6],31:[2,6],32:[2,6],34:[2,6]},{5:[2,7],12:[2,7],13:[2,7],16:[2,7],24:[2,7],26:[2,7],28:[2,7],29:[2,7],31:[2,7],32:[2,7],34:[2,7]},{5:[2,8],12:[2,8],13:[2,8],16:[2,8],24:[2,8],26:[2,8],28:[2,8],29:[2,8],31:[2,8],32:[2,8],34:[2,8]},{17:21,30:22,41:23,50:[1,26],52:[1,25],53:24},{17:27,30:22,41:23,50:[1,26],52:[1,25],53:24},{4:28,6:3,12:[2,38],13:[2,38],16:[2,38],24:[2,38],26:[2,38],28:[2,38],29:[2,38],31:[2,38],32:[2,38],34:[2,38]},{4:29,6:3,12:[2,38],13:[2,38],16:[2,38],24:[2,38],26:[2,38],28:[2,38],29:[2,38],31:[2,38],32:[2,38],34:[2,38]},{12:[1,30]},{30:32,35:31,42:[1,33],43:[1,34],50:[1,26],53:24},{17:35,30:22,41:23,50:[1,26],52:[1,25],53:24},{17:36,30:22,41:23,50:[1,26],52:[1,25],53:24},{17:37,30:22,41:23,50:[1,26],52:[1,25],53:24},{25:[1,38]},{18:[2,48],25:[2,48],33:[2,48],39:39,42:[2,48],43:[2,48],44:[2,48],45:[2,48],46:[2,48],50:[2,48],52:[2,48]},{18:[2,22],25:[2,22],33:[2,22],46:[2,22]},{18:[2,35],25:[2,35],33:[2,35],42:[2,35],43:[2,35],44:[2,35],45:[2,35],46:[2,35],50:[2,35],52:[2,35],54:[1,40]},{30:41,50:[1,26],53:24},{18:[2,37],25:[2,37],33:[2,37],42:[2,37],43:[2,37],44:[2,37],45:[2,37],46:[2,37],50:[2,37],52:[2,37],54:[2,37]},{33:[1,42]},{20:43,27:44,28:[1,45],29:[2,40]},{23:46,27:47,28:[1,45],29:[2,42]},{15:[1,48]},{25:[2,46],30:51,36:49,38:50,41:55,42:[1,52],43:[1,53],44:[1,54],45:[1,56],47:57,48:58,49:60,50:[1,59],52:[1,25],53:24},{25:[2,31],42:[2,31],43:[2,31],44:[2,31],45:[2,31],50:[2,31],52:[2,31]},{25:[2,32],42:[2,32],43:[2,32],44:[2,32],45:[2,32],50:[2,32],52:[2,32]},{25:[2,33],42:[2,33],43:[2,33],44:[2,33],45:[2,33],50:[2,33],52:[2,33]},{25:[1,61]},{25:[1,62]},{18:[1,63]},{5:[2,17],12:[2,17],13:[2,17],16:[2,17],24:[2,17],26:[2,17],28:[2,17],29:[2,17],31:[2,17],32:[2,17],34:[2,17]},{18:[2,50],25:[2,50],30:51,33:[2,50],36:65,40:64,41:55,42:[1,52],43:[1,53],44:[1,54],45:[1,56],46:[2,50],47:66,48:58,49:60,50:[1,59],52:[1,25],53:24},{50:[1,67]},{18:[2,34],25:[2,34],33:[2,34],42:[2,34],43:[2,34],44:[2,34],45:[2,34],46:[2,34],50:[2,34],52:[2,34]},{5:[2,18],12:[2,18],13:[2,18],16:[2,18],24:[2,18],26:[2,18],28:[2,18],29:[2,18],31:[2,18],32:[2,18],34:[2,18]},{21:68,29:[1,69]},{29:[2,41]},{4:70,6:3,12:[2,38],13:[2,38],16:[2,38],24:[2,38],26:[2,38],29:[2,38],31:[2,38],32:[2,38],34:[2,38]},{21:71,29:[1,69]},{29:[2,43]},{5:[2,9],12:[2,9],13:[2,9],16:[2,9],24:[2,9],26:[2,9],28:[2,9],29:[2,9],31:[2,9],32:[2,9],34:[2,9]},{25:[2,44],37:72,47:73,48:58,49:60,50:[1,74]},{25:[1,75]},{18:[2,23],25:[2,23],33:[2,23],42:[2,23],43:[2,23],44:[2,23],45:[2,23],46:[2,23],50:[2,23],52:[2,23]},{18:[2,24],25:[2,24],33:[2,24],42:[2,24],43:[2,24],44:[2,24],45:[2,24],46:[2,24],50:[2,24],52:[2,24]},{18:[2,25],25:[2,25],33:[2,25],42:[2,25],43:[2,25],44:[2,25],45:[2,25],46:[2,25],50:[2,25],52:[2,25]},{18:[2,26],25:[2,26],33:[2,26],42:[2,26],43:[2,26],44:[2,26],45:[2,26],46:[2,26],50:[2,26],52:[2,26]},{18:[2,27],25:[2,27],33:[2,27],42:[2,27],43:[2,27],44:[2,27],45:[2,27],46:[2,27],50:[2,27],52:[2,27]},{17:76,30:22,41:23,50:[1,26],52:[1,25],53:24},{25:[2,47]},{18:[2,29],25:[2,29],33:[2,29],46:[2,29],49:77,50:[1,74]},{18:[2,37],25:[2,37],33:[2,37],42:[2,37],43:[2,37],44:[2,37],45:[2,37],46:[2,37],50:[2,37],51:[1,78],52:[2,37],54:[2,37]},{18:[2,52],25:[2,52],33:[2,52],46:[2,52],50:[2,52]},{12:[2,13],13:[2,13],16:[2,13],24:[2,13],26:[2,13],28:[2,13],29:[2,13],31:[2,13],32:[2,13],34:[2,13]},{12:[2,14],13:[2,14],16:[2,14],24:[2,14],26:[2,14],28:[2,14],29:[2,14],31:[2,14],32:[2,14],34:[2,14]},{12:[2,10]},{18:[2,21],25:[2,21],33:[2,21],46:[2,21]},{18:[2,49],25:[2,49],33:[2,49],42:[2,49],43:[2,49],44:[2,49],45:[2,49],46:[2,49],50:[2,49],52:[2,49]},{18:[2,51],25:[2,51],33:[2,51],46:[2,51]},{18:[2,36],25:[2,36],33:[2,36],42:[2,36],43:[2,36],44:[2,36],45:[2,36],46:[2,36],50:[2,36],52:[2,36],54:[2,36]},{5:[2,11],12:[2,11],13:[2,11],16:[2,11],24:[2,11],26:[2,11],28:[2,11],29:[2,11],31:[2,11],32:[2,11],34:[2,11]},{30:79,50:[1,26],53:24},{29:[2,15]},{5:[2,12],12:[2,12],13:[2,12],16:[2,12],24:[2,12],26:[2,12],28:[2,12],29:[2,12],31:[2,12],32:[2,12],34:[2,12]},{25:[1,80]},{25:[2,45]},{51:[1,78]},{5:[2,20],12:[2,20],13:[2,20],16:[2,20],24:[2,20],26:[2,20],28:[2,20],29:[2,20],31:[2,20],32:[2,20],34:[2,20]},{46:[1,81]},{18:[2,53],25:[2,53],33:[2,53],46:[2,53],50:[2,53]},{30:51,36:82,41:55,42:[1,52],43:[1,53],44:[1,54],45:[1,56],50:[1,26],52:[1,25],53:24},{25:[1,83]},{5:[2,19],12:[2,19],13:[2,19],16:[2,19],24:[2,19],26:[2,19],28:[2,19],29:[2,19],31:[2,19],32:[2,19],34:[2,19]},{18:[2,28],25:[2,28],33:[2,28],42:[2,28],43:[2,28],44:[2,28],45:[2,28],46:[2,28],50:[2,28],52:[2,28]},{18:[2,30],25:[2,30],33:[2,30],46:[2,30],50:[2,30]},{5:[2,16],12:[2,16],13:[2,16],16:[2,16],24:[2,16],26:[2,16],28:[2,16],29:[2,16],31:[2,16],32:[2,16],34:[2,16]}],
  defaultActions: {4:[2,1],44:[2,41],47:[2,43],57:[2,47],63:[2,10],70:[2,15],73:[2,45]},
  parseError: function parseError(str, hash) {
      throw new Error(str);
  },
  parse: function parse(input) {
      var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
      this.lexer.setInput(input);
      this.lexer.yy = this.yy;
      this.yy.lexer = this.lexer;
      this.yy.parser = this;
      if (typeof this.lexer.yylloc == "undefined")
          this.lexer.yylloc = {};
      var yyloc = this.lexer.yylloc;
      lstack.push(yyloc);
      var ranges = this.lexer.options && this.lexer.options.ranges;
      if (typeof this.yy.parseError === "function")
          this.parseError = this.yy.parseError;
      function popStack(n) {
          stack.length = stack.length - 2 * n;
          vstack.length = vstack.length - n;
          lstack.length = lstack.length - n;
      }
      function lex() {
          var token;
          token = self.lexer.lex() || 1;
          if (typeof token !== "number") {
              token = self.symbols_[token] || token;
          }
          return token;
      }
      var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
      while (true) {
          state = stack[stack.length - 1];
          if (this.defaultActions[state]) {
              action = this.defaultActions[state];
          } else {
              if (symbol === null || typeof symbol == "undefined") {
                  symbol = lex();
              }
              action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
              var errStr = "";
              if (!recovering) {
                  expected = [];
                  for (p in table[state])
                      if (this.terminals_[p] && p > 2) {
                          expected.push("'" + this.terminals_[p] + "'");
                      }
                  if (this.lexer.showPosition) {
                      errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                  } else {
                      errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1?"end of input":"'" + (this.terminals_[symbol] || symbol) + "'");
                  }
                  this.parseError(errStr, {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});
              }
          }
          if (action[0] instanceof Array && action.length > 1) {
              throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
          case 1:
              stack.push(symbol);
              vstack.push(this.lexer.yytext);
              lstack.push(this.lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              if (!preErrorSymbol) {
                  yyleng = this.lexer.yyleng;
                  yytext = this.lexer.yytext;
                  yylineno = this.lexer.yylineno;
                  yyloc = this.lexer.yylloc;
                  if (recovering > 0)
                      recovering--;
              } else {
                  symbol = preErrorSymbol;
                  preErrorSymbol = null;
              }
              break;
          case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column};
              if (ranges) {
                  yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
              }
              r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
              if (typeof r !== "undefined") {
                  return r;
              }
              if (len) {
                  stack = stack.slice(0, -1 * len * 2);
                  vstack = vstack.slice(0, -1 * len);
                  lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;
          case 3:
              return true;
          }
      }
      return true;
  }
  };
  /* Jison generated lexer */
  var lexer = (function(){
  var lexer = ({EOF:1,
  parseError:function parseError(str, hash) {
          if (this.yy.parser) {
              this.yy.parser.parseError(str, hash);
          } else {
              throw new Error(str);
          }
      },
  setInput:function (input) {
          this._input = input;
          this._more = this._less = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};
          if (this.options.ranges) this.yylloc.range = [0,0];
          this.offset = 0;
          return this;
      },
  input:function () {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
              this.yylineno++;
              this.yylloc.last_line++;
          } else {
              this.yylloc.last_column++;
          }
          if (this.options.ranges) this.yylloc.range[1]++;

          this._input = this._input.slice(1);
          return ch;
      },
  unput:function (ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);

          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length-len-1);
          //this.yyleng -= len;
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length-1);
          this.matched = this.matched.substr(0, this.matched.length-1);

          if (lines.length-1) this.yylineno -= lines.length-1;
          var r = this.yylloc.range;

          this.yylloc = {first_line: this.yylloc.first_line,
            last_line: this.yylineno+1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length:
                this.yylloc.first_column - len
            };

          if (this.options.ranges) {
              this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          return this;
      },
  more:function () {
          this._more = true;
          return this;
      },
  less:function (n) {
          this.unput(this.match.slice(n));
      },
  pastInput:function () {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
      },
  upcomingInput:function () {
          var next = this.match;
          if (next.length < 20) {
              next += this._input.substr(0, 20-next.length);
          }
          return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\n/g, "");
      },
  showPosition:function () {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c+"^";
      },
  next:function () {
          if (this.done) {
              return this.EOF;
          }
          if (!this._input) this.done = true;

          var token,
              match,
              tempMatch,
              index,
              col,
              lines;
          if (!this._more) {
              this.yytext = '';
              this.match = '';
          }
          var rules = this._currentRules();
          for (var i=0;i < rules.length; i++) {
              tempMatch = this._input.match(this.rules[rules[i]]);
              if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                  match = tempMatch;
                  index = i;
                  if (!this.options.flex) break;
              }
          }
          if (match) {
              lines = match[0].match(/(?:\r\n?|\n).*/g);
              if (lines) this.yylineno += lines.length;
              this.yylloc = {first_line: this.yylloc.last_line,
                             last_line: this.yylineno+1,
                             first_column: this.yylloc.last_column,
                             last_column: lines ? lines[lines.length-1].length-lines[lines.length-1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length};
              this.yytext += match[0];
              this.match += match[0];
              this.matches = match;
              this.yyleng = this.yytext.length;
              if (this.options.ranges) {
                  this.yylloc.range = [this.offset, this.offset += this.yyleng];
              }
              this._more = false;
              this._input = this._input.slice(match[0].length);
              this.matched += match[0];
              token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);
              if (this.done && this._input) this.done = false;
              if (token) return token;
              else return;
          }
          if (this._input === "") {
              return this.EOF;
          } else {
              return this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\n'+this.showPosition(),
                      {text: "", token: null, line: this.yylineno});
          }
      },
  lex:function lex() {
          var r = this.next();
          if (typeof r !== 'undefined') {
              return r;
          } else {
              return this.lex();
          }
      },
  begin:function begin(condition) {
          this.conditionStack.push(condition);
      },
  popState:function popState() {
          return this.conditionStack.pop();
      },
  _currentRules:function _currentRules() {
          return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;
      },
  topState:function () {
          return this.conditionStack[this.conditionStack.length-2];
      },
  pushState:function begin(condition) {
          this.begin(condition);
      }});
  lexer.options = {};
  lexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {


  function strip(start, end) {
    return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng-end);
  }


  var YYSTATE=YY_START
  switch($avoiding_name_collisions) {
  case 0:
                                     if(yy_.yytext.slice(-2) === "\\\\") {
                                       strip(0,1);
                                       this.begin("mu");
                                     } else if(yy_.yytext.slice(-1) === "\\") {
                                       strip(0,1);
                                       this.begin("emu");
                                     } else {
                                       this.begin("mu");
                                     }
                                     if(yy_.yytext) return 12;
                                   
  break;
  case 1:return 12;
  break;
  case 2:
                                     this.popState();
                                     return 12;
                                   
  break;
  case 3:
                                    yy_.yytext = yy_.yytext.substr(5, yy_.yyleng-9);
                                    this.popState();
                                    return 15;
                                   
  break;
  case 4: return 12; 
  break;
  case 5:strip(0,4); this.popState(); return 13;
  break;
  case 6:return 45;
  break;
  case 7:return 46;
  break;
  case 8: return 16; 
  break;
  case 9:
                                    this.popState();
                                    this.begin('raw');
                                    return 18;
                                   
  break;
  case 10:return 34;
  break;
  case 11:return 24;
  break;
  case 12:return 29;
  break;
  case 13:this.popState(); return 28;
  break;
  case 14:this.popState(); return 28;
  break;
  case 15:return 26;
  break;
  case 16:return 26;
  break;
  case 17:return 32;
  break;
  case 18:return 31;
  break;
  case 19:this.popState(); this.begin('com');
  break;
  case 20:strip(3,5); this.popState(); return 13;
  break;
  case 21:return 31;
  break;
  case 22:return 51;
  break;
  case 23:return 50;
  break;
  case 24:return 50;
  break;
  case 25:return 54;
  break;
  case 26:// ignore whitespace
  break;
  case 27:this.popState(); return 33;
  break;
  case 28:this.popState(); return 25;
  break;
  case 29:yy_.yytext = strip(1,2).replace(/\\"/g,'"'); return 42;
  break;
  case 30:yy_.yytext = strip(1,2).replace(/\\'/g,"'"); return 42;
  break;
  case 31:return 52;
  break;
  case 32:return 44;
  break;
  case 33:return 44;
  break;
  case 34:return 43;
  break;
  case 35:return 50;
  break;
  case 36:yy_.yytext = strip(1,2); return 50;
  break;
  case 37:return 'INVALID';
  break;
  case 38:return 5;
  break;
  }
  };
  lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/,/^(?:[^\x00]+)/,/^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/,/^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/,/^(?:[^\x00]*?(?=(\{\{\{\{\/)))/,/^(?:[\s\S]*?--\}\})/,/^(?:\()/,/^(?:\))/,/^(?:\{\{\{\{)/,/^(?:\}\}\}\})/,/^(?:\{\{(~)?>)/,/^(?:\{\{(~)?#)/,/^(?:\{\{(~)?\/)/,/^(?:\{\{(~)?\^\s*(~)?\}\})/,/^(?:\{\{(~)?\s*else\s*(~)?\}\})/,/^(?:\{\{(~)?\^)/,/^(?:\{\{(~)?\s*else\b)/,/^(?:\{\{(~)?\{)/,/^(?:\{\{(~)?&)/,/^(?:\{\{!--)/,/^(?:\{\{![\s\S]*?\}\})/,/^(?:\{\{(~)?)/,/^(?:=)/,/^(?:\.\.)/,/^(?:\.(?=([=~}\s\/.)])))/,/^(?:[\/.])/,/^(?:\s+)/,/^(?:\}(~)?\}\})/,/^(?:(~)?\}\})/,/^(?:"(\\["]|[^"])*")/,/^(?:'(\\[']|[^'])*')/,/^(?:@)/,/^(?:true(?=([~}\s)])))/,/^(?:false(?=([~}\s)])))/,/^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/,/^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)]))))/,/^(?:\[[^\]]*\])/,/^(?:.)/,/^(?:$)/];
  lexer.conditions = {"mu":{"rules":[6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38],"inclusive":false},"emu":{"rules":[2],"inclusive":false},"com":{"rules":[5],"inclusive":false},"raw":{"rules":[3,4],"inclusive":false},"INITIAL":{"rules":[0,1,38],"inclusive":true}};
  return lexer;})()
  parser.lexer = lexer;
  function Parser () { this.yy = {}; }Parser.prototype = parser;parser.Parser = Parser;
  return new Parser;
  })();__exports__ = handlebars;
  /* jshint ignore:end */
  return __exports__;
})();

// handlebars/compiler/helpers.js
var __module10__ = (function(__dependency1__) {
  "use strict";
  var __exports__ = {};
  var Exception = __dependency1__;

  function stripFlags(open, close) {
    return {
      left: open.charAt(2) === '~',
      right: close.charAt(close.length-3) === '~'
    };
  }

  __exports__.stripFlags = stripFlags;
  function prepareBlock(mustache, program, inverseAndProgram, close, inverted, locInfo) {
    /*jshint -W040 */
    if (mustache.sexpr.id.original !== close.path.original) {
      throw new Exception(mustache.sexpr.id.original + ' doesn\'t match ' + close.path.original, mustache);
    }

    var inverse = inverseAndProgram && inverseAndProgram.program;

    var strip = {
      left: mustache.strip.left,
      right: close.strip.right,

      // Determine the standalone candiacy. Basically flag our content as being possibly standalone
      // so our parent can determine if we actually are standalone
      openStandalone: isNextWhitespace(program.statements),
      closeStandalone: isPrevWhitespace((inverse || program).statements)
    };

    if (mustache.strip.right) {
      omitRight(program.statements, null, true);
    }

    if (inverse) {
      var inverseStrip = inverseAndProgram.strip;

      if (inverseStrip.left) {
        omitLeft(program.statements, null, true);
      }
      if (inverseStrip.right) {
        omitRight(inverse.statements, null, true);
      }
      if (close.strip.left) {
        omitLeft(inverse.statements, null, true);
      }

      // Find standalone else statments
      if (isPrevWhitespace(program.statements)
          && isNextWhitespace(inverse.statements)) {

        omitLeft(program.statements);
        omitRight(inverse.statements);
      }
    } else {
      if (close.strip.left) {
        omitLeft(program.statements, null, true);
      }
    }

    if (inverted) {
      return new this.BlockNode(mustache, inverse, program, strip, locInfo);
    } else {
      return new this.BlockNode(mustache, program, inverse, strip, locInfo);
    }
  }

  __exports__.prepareBlock = prepareBlock;
  function prepareProgram(statements, isRoot) {
    for (var i = 0, l = statements.length; i < l; i++) {
      var current = statements[i],
          strip = current.strip;

      if (!strip) {
        continue;
      }

      var _isPrevWhitespace = isPrevWhitespace(statements, i, isRoot, current.type === 'partial'),
          _isNextWhitespace = isNextWhitespace(statements, i, isRoot),

          openStandalone = strip.openStandalone && _isPrevWhitespace,
          closeStandalone = strip.closeStandalone && _isNextWhitespace,
          inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

      if (strip.right) {
        omitRight(statements, i, true);
      }
      if (strip.left) {
        omitLeft(statements, i, true);
      }

      if (inlineStandalone) {
        omitRight(statements, i);

        if (omitLeft(statements, i)) {
          // If we are on a standalone node, save the indent info for partials
          if (current.type === 'partial') {
            current.indent = (/([ \t]+$)/).exec(statements[i-1].original) ? RegExp.$1 : '';
          }
        }
      }
      if (openStandalone) {
        omitRight((current.program || current.inverse).statements);

        // Strip out the previous content node if it's whitespace only
        omitLeft(statements, i);
      }
      if (closeStandalone) {
        // Always strip the next node
        omitRight(statements, i);

        omitLeft((current.inverse || current.program).statements);
      }
    }

    return statements;
  }

  __exports__.prepareProgram = prepareProgram;function isPrevWhitespace(statements, i, isRoot) {
    if (i === undefined) {
      i = statements.length;
    }

    // Nodes that end with newlines are considered whitespace (but are special
    // cased for strip operations)
    var prev = statements[i-1],
        sibling = statements[i-2];
    if (!prev) {
      return isRoot;
    }

    if (prev.type === 'content') {
      return (sibling || !isRoot ? (/\r?\n\s*?$/) : (/(^|\r?\n)\s*?$/)).test(prev.original);
    }
  }
  function isNextWhitespace(statements, i, isRoot) {
    if (i === undefined) {
      i = -1;
    }

    var next = statements[i+1],
        sibling = statements[i+2];
    if (!next) {
      return isRoot;
    }

    if (next.type === 'content') {
      return (sibling || !isRoot ? (/^\s*?\r?\n/) : (/^\s*?(\r?\n|$)/)).test(next.original);
    }
  }

  // Marks the node to the right of the position as omitted.
  // I.e. {{foo}}' ' will mark the ' ' node as omitted.
  //
  // If i is undefined, then the first child will be marked as such.
  //
  // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
  // content is met.
  function omitRight(statements, i, multiple) {
    var current = statements[i == null ? 0 : i + 1];
    if (!current || current.type !== 'content' || (!multiple && current.rightStripped)) {
      return;
    }

    var original = current.string;
    current.string = current.string.replace(multiple ? (/^\s+/) : (/^[ \t]*\r?\n?/), '');
    current.rightStripped = current.string !== original;
  }

  // Marks the node to the left of the position as omitted.
  // I.e. ' '{{foo}} will mark the ' ' node as omitted.
  //
  // If i is undefined then the last child will be marked as such.
  //
  // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
  // content is met.
  function omitLeft(statements, i, multiple) {
    var current = statements[i == null ? statements.length - 1 : i - 1];
    if (!current || current.type !== 'content' || (!multiple && current.leftStripped)) {
      return;
    }

    // We omit the last node if it's whitespace only and not preceeded by a non-content node.
    var original = current.string;
    current.string = current.string.replace(multiple ? (/\s+$/) : (/[ \t]+$/), '');
    current.leftStripped = current.string !== original;
    return current.leftStripped;
  }
  return __exports__;
})(__module5__);

// handlebars/compiler/base.js
var __module8__ = (function(__dependency1__, __dependency2__, __dependency3__, __dependency4__) {
  "use strict";
  var __exports__ = {};
  var parser = __dependency1__;
  var AST = __dependency2__;
  var Helpers = __dependency3__;
  var extend = __dependency4__.extend;

  __exports__.parser = parser;

  var yy = {};
  extend(yy, Helpers, AST);

  function parse(input) {
    // Just return if an already-compile AST was passed in.
    if (input.constructor === AST.ProgramNode) { return input; }

    parser.yy = yy;

    return parser.parse(input);
  }

  __exports__.parse = parse;
  return __exports__;
})(__module9__, __module7__, __module10__, __module3__);

// handlebars/compiler/compiler.js
var __module11__ = (function(__dependency1__, __dependency2__) {
  "use strict";
  var __exports__ = {};
  var Exception = __dependency1__;
  var isArray = __dependency2__.isArray;

  var slice = [].slice;

  function Compiler() {}

  __exports__.Compiler = Compiler;// the foundHelper register will disambiguate helper lookup from finding a
  // function in a context. This is necessary for mustache compatibility, which
  // requires that context functions in blocks are evaluated by blockHelperMissing,
  // and then proceed as if the resulting value was provided to blockHelperMissing.

  Compiler.prototype = {
    compiler: Compiler,

    equals: function(other) {
      var len = this.opcodes.length;
      if (other.opcodes.length !== len) {
        return false;
      }

      for (var i = 0; i < len; i++) {
        var opcode = this.opcodes[i],
            otherOpcode = other.opcodes[i];
        if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
          return false;
        }
      }

      // We know that length is the same between the two arrays because they are directly tied
      // to the opcode behavior above.
      len = this.children.length;
      for (i = 0; i < len; i++) {
        if (!this.children[i].equals(other.children[i])) {
          return false;
        }
      }

      return true;
    },

    guid: 0,

    compile: function(program, options) {
      this.opcodes = [];
      this.children = [];
      this.depths = {list: []};
      this.options = options;
      this.stringParams = options.stringParams;
      this.trackIds = options.trackIds;

      // These changes will propagate to the other compiler components
      var knownHelpers = this.options.knownHelpers;
      this.options.knownHelpers = {
        'helperMissing': true,
        'blockHelperMissing': true,
        'each': true,
        'if': true,
        'unless': true,
        'with': true,
        'log': true,
        'lookup': true
      };
      if (knownHelpers) {
        for (var name in knownHelpers) {
          this.options.knownHelpers[name] = knownHelpers[name];
        }
      }

      return this.accept(program);
    },

    accept: function(node) {
      return this[node.type](node);
    },

    program: function(program) {
      var statements = program.statements;

      for(var i=0, l=statements.length; i<l; i++) {
        this.accept(statements[i]);
      }
      this.isSimple = l === 1;

      this.depths.list = this.depths.list.sort(function(a, b) {
        return a - b;
      });

      return this;
    },

    compileProgram: function(program) {
      var result = new this.compiler().compile(program, this.options);
      var guid = this.guid++, depth;

      this.usePartial = this.usePartial || result.usePartial;

      this.children[guid] = result;

      for(var i=0, l=result.depths.list.length; i<l; i++) {
        depth = result.depths.list[i];

        if(depth < 2) { continue; }
        else { this.addDepth(depth - 1); }
      }

      return guid;
    },

    block: function(block) {
      var mustache = block.mustache,
          program = block.program,
          inverse = block.inverse;

      if (program) {
        program = this.compileProgram(program);
      }

      if (inverse) {
        inverse = this.compileProgram(inverse);
      }

      var sexpr = mustache.sexpr;
      var type = this.classifySexpr(sexpr);

      if (type === "helper") {
        this.helperSexpr(sexpr, program, inverse);
      } else if (type === "simple") {
        this.simpleSexpr(sexpr);

        // now that the simple mustache is resolved, we need to
        // evaluate it by executing `blockHelperMissing`
        this.opcode('pushProgram', program);
        this.opcode('pushProgram', inverse);
        this.opcode('emptyHash');
        this.opcode('blockValue', sexpr.id.original);
      } else {
        this.ambiguousSexpr(sexpr, program, inverse);

        // now that the simple mustache is resolved, we need to
        // evaluate it by executing `blockHelperMissing`
        this.opcode('pushProgram', program);
        this.opcode('pushProgram', inverse);
        this.opcode('emptyHash');
        this.opcode('ambiguousBlockValue');
      }

      this.opcode('append');
    },

    hash: function(hash) {
      var pairs = hash.pairs, i, l;

      this.opcode('pushHash');

      for(i=0, l=pairs.length; i<l; i++) {
        this.pushParam(pairs[i][1]);
      }
      while(i--) {
        this.opcode('assignToHash', pairs[i][0]);
      }
      this.opcode('popHash');
    },

    partial: function(partial) {
      var partialName = partial.partialName;
      this.usePartial = true;

      if (partial.hash) {
        this.accept(partial.hash);
      } else {
        this.opcode('push', 'undefined');
      }

      if (partial.context) {
        this.accept(partial.context);
      } else {
        this.opcode('getContext', 0);
        this.opcode('pushContext');
      }

      this.opcode('invokePartial', partialName.name, partial.indent || '');
      this.opcode('append');
    },

    content: function(content) {
      if (content.string) {
        this.opcode('appendContent', content.string);
      }
    },

    mustache: function(mustache) {
      this.sexpr(mustache.sexpr);

      if(mustache.escaped && !this.options.noEscape) {
        this.opcode('appendEscaped');
      } else {
        this.opcode('append');
      }
    },

    ambiguousSexpr: function(sexpr, program, inverse) {
      var id = sexpr.id,
          name = id.parts[0],
          isBlock = program != null || inverse != null;

      this.opcode('getContext', id.depth);

      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);

      this.ID(id);

      this.opcode('invokeAmbiguous', name, isBlock);
    },

    simpleSexpr: function(sexpr) {
      var id = sexpr.id;

      if (id.type === 'DATA') {
        this.DATA(id);
      } else if (id.parts.length) {
        this.ID(id);
      } else {
        // Simplified ID for `this`
        this.addDepth(id.depth);
        this.opcode('getContext', id.depth);
        this.opcode('pushContext');
      }

      this.opcode('resolvePossibleLambda');
    },

    helperSexpr: function(sexpr, program, inverse) {
      var params = this.setupFullMustacheParams(sexpr, program, inverse),
          id = sexpr.id,
          name = id.parts[0];

      if (this.options.knownHelpers[name]) {
        this.opcode('invokeKnownHelper', params.length, name);
      } else if (this.options.knownHelpersOnly) {
        throw new Exception("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
      } else {
        id.falsy = true;

        this.ID(id);
        this.opcode('invokeHelper', params.length, id.original, id.isSimple);
      }
    },

    sexpr: function(sexpr) {
      var type = this.classifySexpr(sexpr);

      if (type === "simple") {
        this.simpleSexpr(sexpr);
      } else if (type === "helper") {
        this.helperSexpr(sexpr);
      } else {
        this.ambiguousSexpr(sexpr);
      }
    },

    ID: function(id) {
      this.addDepth(id.depth);
      this.opcode('getContext', id.depth);

      var name = id.parts[0];
      if (!name) {
        // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
        this.opcode('pushContext');
      } else {
        this.opcode('lookupOnContext', id.parts, id.falsy, id.isScoped);
      }
    },

    DATA: function(data) {
      this.options.data = true;
      this.opcode('lookupData', data.id.depth, data.id.parts);
    },

    STRING: function(string) {
      this.opcode('pushString', string.string);
    },

    NUMBER: function(number) {
      this.opcode('pushLiteral', number.number);
    },

    BOOLEAN: function(bool) {
      this.opcode('pushLiteral', bool.bool);
    },

    comment: function() {},

    // HELPERS
    opcode: function(name) {
      this.opcodes.push({ opcode: name, args: slice.call(arguments, 1) });
    },

    addDepth: function(depth) {
      if(depth === 0) { return; }

      if(!this.depths[depth]) {
        this.depths[depth] = true;
        this.depths.list.push(depth);
      }
    },

    classifySexpr: function(sexpr) {
      var isHelper   = sexpr.isHelper;
      var isEligible = sexpr.eligibleHelper;
      var options    = this.options;

      // if ambiguous, we can possibly resolve the ambiguity now
      // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
      if (isEligible && !isHelper) {
        var name = sexpr.id.parts[0];

        if (options.knownHelpers[name]) {
          isHelper = true;
        } else if (options.knownHelpersOnly) {
          isEligible = false;
        }
      }

      if (isHelper) { return "helper"; }
      else if (isEligible) { return "ambiguous"; }
      else { return "simple"; }
    },

    pushParams: function(params) {
      for(var i=0, l=params.length; i<l; i++) {
        this.pushParam(params[i]);
      }
    },

    pushParam: function(val) {
      if (this.stringParams) {
        if(val.depth) {
          this.addDepth(val.depth);
        }
        this.opcode('getContext', val.depth || 0);
        this.opcode('pushStringParam', val.stringModeValue, val.type);

        if (val.type === 'sexpr') {
          // Subexpressions get evaluated and passed in
          // in string params mode.
          this.sexpr(val);
        }
      } else {
        if (this.trackIds) {
          this.opcode('pushId', val.type, val.idName || val.stringModeValue);
        }
        this.accept(val);
      }
    },

    setupFullMustacheParams: function(sexpr, program, inverse) {
      var params = sexpr.params;
      this.pushParams(params);

      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);

      if (sexpr.hash) {
        this.hash(sexpr.hash);
      } else {
        this.opcode('emptyHash');
      }

      return params;
    }
  };

  function precompile(input, options, env) {
    if (input == null || (typeof input !== 'string' && input.constructor !== env.AST.ProgramNode)) {
      throw new Exception("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
    }

    options = options || {};
    if (!('data' in options)) {
      options.data = true;
    }
    if (options.compat) {
      options.useDepths = true;
    }

    var ast = env.parse(input);
    var environment = new env.Compiler().compile(ast, options);
    return new env.JavaScriptCompiler().compile(environment, options);
  }

  __exports__.precompile = precompile;function compile(input, options, env) {
    if (input == null || (typeof input !== 'string' && input.constructor !== env.AST.ProgramNode)) {
      throw new Exception("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
    }

    options = options || {};

    if (!('data' in options)) {
      options.data = true;
    }
    if (options.compat) {
      options.useDepths = true;
    }

    var compiled;

    function compileInput() {
      var ast = env.parse(input);
      var environment = new env.Compiler().compile(ast, options);
      var templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
      return env.template(templateSpec);
    }

    // Template is only compiled on first use and cached after that point.
    var ret = function(context, options) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled.call(this, context, options);
    };
    ret._setup = function(options) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled._setup(options);
    };
    ret._child = function(i, data, depths) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled._child(i, data, depths);
    };
    return ret;
  }

  __exports__.compile = compile;function argEquals(a, b) {
    if (a === b) {
      return true;
    }

    if (isArray(a) && isArray(b) && a.length === b.length) {
      for (var i = 0; i < a.length; i++) {
        if (!argEquals(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
  }
  return __exports__;
})(__module5__, __module3__);

// handlebars/compiler/javascript-compiler.js
var __module12__ = (function(__dependency1__, __dependency2__) {
  "use strict";
  var __exports__;
  var COMPILER_REVISION = __dependency1__.COMPILER_REVISION;
  var REVISION_CHANGES = __dependency1__.REVISION_CHANGES;
  var Exception = __dependency2__;

  function Literal(value) {
    this.value = value;
  }

  function JavaScriptCompiler() {}

  JavaScriptCompiler.prototype = {
    // PUBLIC API: You can override these methods in a subclass to provide
    // alternative compiled forms for name lookup and buffering semantics
    nameLookup: function(parent, name /* , type*/) {
      if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
        return parent + "." + name;
      } else {
        return parent + "['" + name + "']";
      }
    },
    depthedLookup: function(name) {
      this.aliases.lookup = 'this.lookup';

      return 'lookup(depths, "' + name + '")';
    },

    compilerInfo: function() {
      var revision = COMPILER_REVISION,
          versions = REVISION_CHANGES[revision];
      return [revision, versions];
    },

    appendToBuffer: function(string) {
      if (this.environment.isSimple) {
        return "return " + string + ";";
      } else {
        return {
          appendToBuffer: true,
          content: string,
          toString: function() { return "buffer += " + string + ";"; }
        };
      }
    },

    initializeBuffer: function() {
      return this.quotedString("");
    },

    namespace: "Handlebars",
    // END PUBLIC API

    compile: function(environment, options, context, asObject) {
      this.environment = environment;
      this.options = options;
      this.stringParams = this.options.stringParams;
      this.trackIds = this.options.trackIds;
      this.precompile = !asObject;

      this.name = this.environment.name;
      this.isChild = !!context;
      this.context = context || {
        programs: [],
        environments: []
      };

      this.preamble();

      this.stackSlot = 0;
      this.stackVars = [];
      this.aliases = {};
      this.registers = { list: [] };
      this.hashes = [];
      this.compileStack = [];
      this.inlineStack = [];

      this.compileChildren(environment, options);

      this.useDepths = this.useDepths || environment.depths.list.length || this.options.compat;

      var opcodes = environment.opcodes,
          opcode,
          i,
          l;

      for (i = 0, l = opcodes.length; i < l; i++) {
        opcode = opcodes[i];

        this[opcode.opcode].apply(this, opcode.args);
      }

      // Flush any trailing content that might be pending.
      this.pushSource('');

      /* istanbul ignore next */
      if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
        throw new Exception('Compile completed with content left on stack');
      }

      var fn = this.createFunctionContext(asObject);
      if (!this.isChild) {
        var ret = {
          compiler: this.compilerInfo(),
          main: fn
        };
        var programs = this.context.programs;
        for (i = 0, l = programs.length; i < l; i++) {
          if (programs[i]) {
            ret[i] = programs[i];
          }
        }

        if (this.environment.usePartial) {
          ret.usePartial = true;
        }
        if (this.options.data) {
          ret.useData = true;
        }
        if (this.useDepths) {
          ret.useDepths = true;
        }
        if (this.options.compat) {
          ret.compat = true;
        }

        if (!asObject) {
          ret.compiler = JSON.stringify(ret.compiler);
          ret = this.objectLiteral(ret);
        }

        return ret;
      } else {
        return fn;
      }
    },

    preamble: function() {
      // track the last context pushed into place to allow skipping the
      // getContext opcode when it would be a noop
      this.lastContext = 0;
      this.source = [];
    },

    createFunctionContext: function(asObject) {
      var varDeclarations = '';

      var locals = this.stackVars.concat(this.registers.list);
      if(locals.length > 0) {
        varDeclarations += ", " + locals.join(", ");
      }

      // Generate minimizer alias mappings
      for (var alias in this.aliases) {
        if (this.aliases.hasOwnProperty(alias)) {
          varDeclarations += ', ' + alias + '=' + this.aliases[alias];
        }
      }

      var params = ["depth0", "helpers", "partials", "data"];

      if (this.useDepths) {
        params.push('depths');
      }

      // Perform a second pass over the output to merge content when possible
      var source = this.mergeSource(varDeclarations);

      if (asObject) {
        params.push(source);

        return Function.apply(this, params);
      } else {
        return 'function(' + params.join(',') + ') {\n  ' + source + '}';
      }
    },
    mergeSource: function(varDeclarations) {
      var source = '',
          buffer,
          appendOnly = !this.forceBuffer,
          appendFirst;

      for (var i = 0, len = this.source.length; i < len; i++) {
        var line = this.source[i];
        if (line.appendToBuffer) {
          if (buffer) {
            buffer = buffer + '\n    + ' + line.content;
          } else {
            buffer = line.content;
          }
        } else {
          if (buffer) {
            if (!source) {
              appendFirst = true;
              source = buffer + ';\n  ';
            } else {
              source += 'buffer += ' + buffer + ';\n  ';
            }
            buffer = undefined;
          }
          source += line + '\n  ';

          if (!this.environment.isSimple) {
            appendOnly = false;
          }
        }
      }

      if (appendOnly) {
        if (buffer || !source) {
          source += 'return ' + (buffer || '""') + ';\n';
        }
      } else {
        varDeclarations += ", buffer = " + (appendFirst ? '' : this.initializeBuffer());
        if (buffer) {
          source += 'return buffer + ' + buffer + ';\n';
        } else {
          source += 'return buffer;\n';
        }
      }

      if (varDeclarations) {
        source = 'var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n  ') + source;
      }

      return source;
    },

    // [blockValue]
    //
    // On stack, before: hash, inverse, program, value
    // On stack, after: return value of blockHelperMissing
    //
    // The purpose of this opcode is to take a block of the form
    // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
    // replace it on the stack with the result of properly
    // invoking blockHelperMissing.
    blockValue: function(name) {
      this.aliases.blockHelperMissing = 'helpers.blockHelperMissing';

      var params = [this.contextName(0)];
      this.setupParams(name, 0, params);

      var blockName = this.popStack();
      params.splice(1, 0, blockName);

      this.push('blockHelperMissing.call(' + params.join(', ') + ')');
    },

    // [ambiguousBlockValue]
    //
    // On stack, before: hash, inverse, program, value
    // Compiler value, before: lastHelper=value of last found helper, if any
    // On stack, after, if no lastHelper: same as [blockValue]
    // On stack, after, if lastHelper: value
    ambiguousBlockValue: function() {
      this.aliases.blockHelperMissing = 'helpers.blockHelperMissing';

      // We're being a bit cheeky and reusing the options value from the prior exec
      var params = [this.contextName(0)];
      this.setupParams('', 0, params, true);

      this.flushInline();

      var current = this.topStack();
      params.splice(1, 0, current);

      this.pushSource("if (!" + this.lastHelper + ") { " + current + " = blockHelperMissing.call(" + params.join(", ") + "); }");
    },

    // [appendContent]
    //
    // On stack, before: ...
    // On stack, after: ...
    //
    // Appends the string value of `content` to the current buffer
    appendContent: function(content) {
      if (this.pendingContent) {
        content = this.pendingContent + content;
      }

      this.pendingContent = content;
    },

    // [append]
    //
    // On stack, before: value, ...
    // On stack, after: ...
    //
    // Coerces `value` to a String and appends it to the current buffer.
    //
    // If `value` is truthy, or 0, it is coerced into a string and appended
    // Otherwise, the empty string is appended
    append: function() {
      // Force anything that is inlined onto the stack so we don't have duplication
      // when we examine local
      this.flushInline();
      var local = this.popStack();
      this.pushSource('if (' + local + ' != null) { ' + this.appendToBuffer(local) + ' }');
      if (this.environment.isSimple) {
        this.pushSource("else { " + this.appendToBuffer("''") + " }");
      }
    },

    // [appendEscaped]
    //
    // On stack, before: value, ...
    // On stack, after: ...
    //
    // Escape `value` and append it to the buffer
    appendEscaped: function() {
      this.aliases.escapeExpression = 'this.escapeExpression';

      this.pushSource(this.appendToBuffer("escapeExpression(" + this.popStack() + ")"));
    },

    // [getContext]
    //
    // On stack, before: ...
    // On stack, after: ...
    // Compiler value, after: lastContext=depth
    //
    // Set the value of the `lastContext` compiler value to the depth
    getContext: function(depth) {
      this.lastContext = depth;
    },

    // [pushContext]
    //
    // On stack, before: ...
    // On stack, after: currentContext, ...
    //
    // Pushes the value of the current context onto the stack.
    pushContext: function() {
      this.pushStackLiteral(this.contextName(this.lastContext));
    },

    // [lookupOnContext]
    //
    // On stack, before: ...
    // On stack, after: currentContext[name], ...
    //
    // Looks up the value of `name` on the current context and pushes
    // it onto the stack.
    lookupOnContext: function(parts, falsy, scoped) {
      /*jshint -W083 */
      var i = 0,
          len = parts.length;

      if (!scoped && this.options.compat && !this.lastContext) {
        // The depthed query is expected to handle the undefined logic for the root level that
        // is implemented below, so we evaluate that directly in compat mode
        this.push(this.depthedLookup(parts[i++]));
      } else {
        this.pushContext();
      }

      for (; i < len; i++) {
        this.replaceStack(function(current) {
          var lookup = this.nameLookup(current, parts[i], 'context');
          // We want to ensure that zero and false are handled properly if the context (falsy flag)
          // needs to have the special handling for these values.
          if (!falsy) {
            return ' != null ? ' + lookup + ' : ' + current;
          } else {
            // Otherwise we can use generic falsy handling
            return ' && ' + lookup;
          }
        });
      }
    },

    // [lookupData]
    //
    // On stack, before: ...
    // On stack, after: data, ...
    //
    // Push the data lookup operator
    lookupData: function(depth, parts) {
      /*jshint -W083 */
      if (!depth) {
        this.pushStackLiteral('data');
      } else {
        this.pushStackLiteral('this.data(data, ' + depth + ')');
      }

      var len = parts.length;
      for (var i = 0; i < len; i++) {
        this.replaceStack(function(current) {
          return ' && ' + this.nameLookup(current, parts[i], 'data');
        });
      }
    },

    // [resolvePossibleLambda]
    //
    // On stack, before: value, ...
    // On stack, after: resolved value, ...
    //
    // If the `value` is a lambda, replace it on the stack by
    // the return value of the lambda
    resolvePossibleLambda: function() {
      this.aliases.lambda = 'this.lambda';

      this.push('lambda(' + this.popStack() + ', ' + this.contextName(0) + ')');
    },

    // [pushStringParam]
    //
    // On stack, before: ...
    // On stack, after: string, currentContext, ...
    //
    // This opcode is designed for use in string mode, which
    // provides the string value of a parameter along with its
    // depth rather than resolving it immediately.
    pushStringParam: function(string, type) {
      this.pushContext();
      this.pushString(type);

      // If it's a subexpression, the string result
      // will be pushed after this opcode.
      if (type !== 'sexpr') {
        if (typeof string === 'string') {
          this.pushString(string);
        } else {
          this.pushStackLiteral(string);
        }
      }
    },

    emptyHash: function() {
      this.pushStackLiteral('{}');

      if (this.trackIds) {
        this.push('{}'); // hashIds
      }
      if (this.stringParams) {
        this.push('{}'); // hashContexts
        this.push('{}'); // hashTypes
      }
    },
    pushHash: function() {
      if (this.hash) {
        this.hashes.push(this.hash);
      }
      this.hash = {values: [], types: [], contexts: [], ids: []};
    },
    popHash: function() {
      var hash = this.hash;
      this.hash = this.hashes.pop();

      if (this.trackIds) {
        this.push('{' + hash.ids.join(',') + '}');
      }
      if (this.stringParams) {
        this.push('{' + hash.contexts.join(',') + '}');
        this.push('{' + hash.types.join(',') + '}');
      }

      this.push('{\n    ' + hash.values.join(',\n    ') + '\n  }');
    },

    // [pushString]
    //
    // On stack, before: ...
    // On stack, after: quotedString(string), ...
    //
    // Push a quoted version of `string` onto the stack
    pushString: function(string) {
      this.pushStackLiteral(this.quotedString(string));
    },

    // [push]
    //
    // On stack, before: ...
    // On stack, after: expr, ...
    //
    // Push an expression onto the stack
    push: function(expr) {
      this.inlineStack.push(expr);
      return expr;
    },

    // [pushLiteral]
    //
    // On stack, before: ...
    // On stack, after: value, ...
    //
    // Pushes a value onto the stack. This operation prevents
    // the compiler from creating a temporary variable to hold
    // it.
    pushLiteral: function(value) {
      this.pushStackLiteral(value);
    },

    // [pushProgram]
    //
    // On stack, before: ...
    // On stack, after: program(guid), ...
    //
    // Push a program expression onto the stack. This takes
    // a compile-time guid and converts it into a runtime-accessible
    // expression.
    pushProgram: function(guid) {
      if (guid != null) {
        this.pushStackLiteral(this.programExpression(guid));
      } else {
        this.pushStackLiteral(null);
      }
    },

    // [invokeHelper]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of helper invocation
    //
    // Pops off the helper's parameters, invokes the helper,
    // and pushes the helper's return value onto the stack.
    //
    // If the helper is not found, `helperMissing` is called.
    invokeHelper: function(paramSize, name, isSimple) {
      this.aliases.helperMissing = 'helpers.helperMissing';

      var nonHelper = this.popStack();
      var helper = this.setupHelper(paramSize, name);

      var lookup = (isSimple ? helper.name + ' || ' : '') + nonHelper + ' || helperMissing';
      this.push('((' + lookup + ').call(' + helper.callParams + '))');
    },

    // [invokeKnownHelper]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of helper invocation
    //
    // This operation is used when the helper is known to exist,
    // so a `helperMissing` fallback is not required.
    invokeKnownHelper: function(paramSize, name) {
      var helper = this.setupHelper(paramSize, name);
      this.push(helper.name + ".call(" + helper.callParams + ")");
    },

    // [invokeAmbiguous]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of disambiguation
    //
    // This operation is used when an expression like `{{foo}}`
    // is provided, but we don't know at compile-time whether it
    // is a helper or a path.
    //
    // This operation emits more code than the other options,
    // and can be avoided by passing the `knownHelpers` and
    // `knownHelpersOnly` flags at compile-time.
    invokeAmbiguous: function(name, helperCall) {
      this.aliases.functionType = '"function"';
      this.aliases.helperMissing = 'helpers.helperMissing';
      this.useRegister('helper');

      var nonHelper = this.popStack();

      this.emptyHash();
      var helper = this.setupHelper(0, name, helperCall);

      var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

      this.push(
        '((helper = (helper = ' + helperName + ' || ' + nonHelper + ') != null ? helper : helperMissing'
          + (helper.paramsInit ? '),(' + helper.paramsInit : '') + '),'
        + '(typeof helper === functionType ? helper.call(' + helper.callParams + ') : helper))');
    },

    // [invokePartial]
    //
    // On stack, before: context, ...
    // On stack after: result of partial invocation
    //
    // This operation pops off a context, invokes a partial with that context,
    // and pushes the result of the invocation back.
    invokePartial: function(name, indent) {
      var params = [this.nameLookup('partials', name, 'partial'), "'" + indent + "'", "'" + name + "'", this.popStack(), this.popStack(), "helpers", "partials"];

      if (this.options.data) {
        params.push("data");
      } else if (this.options.compat) {
        params.push('undefined');
      }
      if (this.options.compat) {
        params.push('depths');
      }

      this.push("this.invokePartial(" + params.join(", ") + ")");
    },

    // [assignToHash]
    //
    // On stack, before: value, ..., hash, ...
    // On stack, after: ..., hash, ...
    //
    // Pops a value off the stack and assigns it to the current hash
    assignToHash: function(key) {
      var value = this.popStack(),
          context,
          type,
          id;

      if (this.trackIds) {
        id = this.popStack();
      }
      if (this.stringParams) {
        type = this.popStack();
        context = this.popStack();
      }

      var hash = this.hash;
      if (context) {
        hash.contexts.push("'" + key + "': " + context);
      }
      if (type) {
        hash.types.push("'" + key + "': " + type);
      }
      if (id) {
        hash.ids.push("'" + key + "': " + id);
      }
      hash.values.push("'" + key + "': (" + value + ")");
    },

    pushId: function(type, name) {
      if (type === 'ID' || type === 'DATA') {
        this.pushString(name);
      } else if (type === 'sexpr') {
        this.pushStackLiteral('true');
      } else {
        this.pushStackLiteral('null');
      }
    },

    // HELPERS

    compiler: JavaScriptCompiler,

    compileChildren: function(environment, options) {
      var children = environment.children, child, compiler;

      for(var i=0, l=children.length; i<l; i++) {
        child = children[i];
        compiler = new this.compiler();

        var index = this.matchExistingProgram(child);

        if (index == null) {
          this.context.programs.push('');     // Placeholder to prevent name conflicts for nested children
          index = this.context.programs.length;
          child.index = index;
          child.name = 'program' + index;
          this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
          this.context.environments[index] = child;

          this.useDepths = this.useDepths || compiler.useDepths;
        } else {
          child.index = index;
          child.name = 'program' + index;
        }
      }
    },
    matchExistingProgram: function(child) {
      for (var i = 0, len = this.context.environments.length; i < len; i++) {
        var environment = this.context.environments[i];
        if (environment && environment.equals(child)) {
          return i;
        }
      }
    },

    programExpression: function(guid) {
      var child = this.environment.children[guid],
          depths = child.depths.list,
          useDepths = this.useDepths,
          depth;

      var programParams = [child.index, 'data'];

      if (useDepths) {
        programParams.push('depths');
      }

      return 'this.program(' + programParams.join(', ') + ')';
    },

    useRegister: function(name) {
      if(!this.registers[name]) {
        this.registers[name] = true;
        this.registers.list.push(name);
      }
    },

    pushStackLiteral: function(item) {
      return this.push(new Literal(item));
    },

    pushSource: function(source) {
      if (this.pendingContent) {
        this.source.push(this.appendToBuffer(this.quotedString(this.pendingContent)));
        this.pendingContent = undefined;
      }

      if (source) {
        this.source.push(source);
      }
    },

    pushStack: function(item) {
      this.flushInline();

      var stack = this.incrStack();
      this.pushSource(stack + " = " + item + ";");
      this.compileStack.push(stack);
      return stack;
    },

    replaceStack: function(callback) {
      var prefix = '',
          inline = this.isInline(),
          stack,
          createdStack,
          usedLiteral;

      /* istanbul ignore next */
      if (!this.isInline()) {
        throw new Exception('replaceStack on non-inline');
      }

      // We want to merge the inline statement into the replacement statement via ','
      var top = this.popStack(true);

      if (top instanceof Literal) {
        // Literals do not need to be inlined
        prefix = stack = top.value;
        usedLiteral = true;
      } else {
        // Get or create the current stack name for use by the inline
        createdStack = !this.stackSlot;
        var name = !createdStack ? this.topStackName() : this.incrStack();

        prefix = '(' + this.push(name) + ' = ' + top + ')';
        stack = this.topStack();
      }

      var item = callback.call(this, stack);

      if (!usedLiteral) {
        this.popStack();
      }
      if (createdStack) {
        this.stackSlot--;
      }
      this.push('(' + prefix + item + ')');
    },

    incrStack: function() {
      this.stackSlot++;
      if(this.stackSlot > this.stackVars.length) { this.stackVars.push("stack" + this.stackSlot); }
      return this.topStackName();
    },
    topStackName: function() {
      return "stack" + this.stackSlot;
    },
    flushInline: function() {
      var inlineStack = this.inlineStack;
      if (inlineStack.length) {
        this.inlineStack = [];
        for (var i = 0, len = inlineStack.length; i < len; i++) {
          var entry = inlineStack[i];
          if (entry instanceof Literal) {
            this.compileStack.push(entry);
          } else {
            this.pushStack(entry);
          }
        }
      }
    },
    isInline: function() {
      return this.inlineStack.length;
    },

    popStack: function(wrapped) {
      var inline = this.isInline(),
          item = (inline ? this.inlineStack : this.compileStack).pop();

      if (!wrapped && (item instanceof Literal)) {
        return item.value;
      } else {
        if (!inline) {
          /* istanbul ignore next */
          if (!this.stackSlot) {
            throw new Exception('Invalid stack pop');
          }
          this.stackSlot--;
        }
        return item;
      }
    },

    topStack: function() {
      var stack = (this.isInline() ? this.inlineStack : this.compileStack),
          item = stack[stack.length - 1];

      if (item instanceof Literal) {
        return item.value;
      } else {
        return item;
      }
    },

    contextName: function(context) {
      if (this.useDepths && context) {
        return 'depths[' + context + ']';
      } else {
        return 'depth' + context;
      }
    },

    quotedString: function(str) {
      return '"' + str
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/\u2028/g, '\\u2028')   // Per Ecma-262 7.3 + 7.8.4
        .replace(/\u2029/g, '\\u2029') + '"';
    },

    objectLiteral: function(obj) {
      var pairs = [];

      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          pairs.push(this.quotedString(key) + ':' + obj[key]);
        }
      }

      return '{' + pairs.join(',') + '}';
    },

    setupHelper: function(paramSize, name, blockHelper) {
      var params = [],
          paramsInit = this.setupParams(name, paramSize, params, blockHelper);
      var foundHelper = this.nameLookup('helpers', name, 'helper');

      return {
        params: params,
        paramsInit: paramsInit,
        name: foundHelper,
        callParams: [this.contextName(0)].concat(params).join(", ")
      };
    },

    setupOptions: function(helper, paramSize, params) {
      var options = {}, contexts = [], types = [], ids = [], param, inverse, program;

      options.name = this.quotedString(helper);
      options.hash = this.popStack();

      if (this.trackIds) {
        options.hashIds = this.popStack();
      }
      if (this.stringParams) {
        options.hashTypes = this.popStack();
        options.hashContexts = this.popStack();
      }

      inverse = this.popStack();
      program = this.popStack();

      // Avoid setting fn and inverse if neither are set. This allows
      // helpers to do a check for `if (options.fn)`
      if (program || inverse) {
        if (!program) {
          program = 'this.noop';
        }

        if (!inverse) {
          inverse = 'this.noop';
        }

        options.fn = program;
        options.inverse = inverse;
      }

      // The parameters go on to the stack in order (making sure that they are evaluated in order)
      // so we need to pop them off the stack in reverse order
      var i = paramSize;
      while (i--) {
        param = this.popStack();
        params[i] = param;

        if (this.trackIds) {
          ids[i] = this.popStack();
        }
        if (this.stringParams) {
          types[i] = this.popStack();
          contexts[i] = this.popStack();
        }
      }

      if (this.trackIds) {
        options.ids = "[" + ids.join(",") + "]";
      }
      if (this.stringParams) {
        options.types = "[" + types.join(",") + "]";
        options.contexts = "[" + contexts.join(",") + "]";
      }

      if (this.options.data) {
        options.data = "data";
      }

      return options;
    },

    // the params and contexts arguments are passed in arrays
    // to fill in
    setupParams: function(helperName, paramSize, params, useRegister) {
      var options = this.objectLiteral(this.setupOptions(helperName, paramSize, params));

      if (useRegister) {
        this.useRegister('options');
        params.push('options');
        return 'options=' + options;
      } else {
        params.push(options);
        return '';
      }
    }
  };

  var reservedWords = (
    "break else new var" +
    " case finally return void" +
    " catch for switch while" +
    " continue function this with" +
    " default if throw" +
    " delete in try" +
    " do instanceof typeof" +
    " abstract enum int short" +
    " boolean export interface static" +
    " byte extends long super" +
    " char final native synchronized" +
    " class float package throws" +
    " const goto private transient" +
    " debugger implements protected volatile" +
    " double import public let yield"
  ).split(" ");

  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

  for(var i=0, l=reservedWords.length; i<l; i++) {
    compilerWords[reservedWords[i]] = true;
  }

  JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
    return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
  };

  __exports__ = JavaScriptCompiler;
  return __exports__;
})(__module2__, __module5__);

// handlebars.js
var __module0__ = (function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__) {
  "use strict";
  var __exports__;
  /*globals Handlebars: true */
  var Handlebars = __dependency1__;

  // Compiler imports
  var AST = __dependency2__;
  var Parser = __dependency3__.parser;
  var parse = __dependency3__.parse;
  var Compiler = __dependency4__.Compiler;
  var compile = __dependency4__.compile;
  var precompile = __dependency4__.precompile;
  var JavaScriptCompiler = __dependency5__;

  var _create = Handlebars.create;
  var create = function() {
    var hb = _create();

    hb.compile = function(input, options) {
      return compile(input, options, hb);
    };
    hb.precompile = function (input, options) {
      return precompile(input, options, hb);
    };

    hb.AST = AST;
    hb.Compiler = Compiler;
    hb.JavaScriptCompiler = JavaScriptCompiler;
    hb.Parser = Parser;
    hb.parse = parse;

    return hb;
  };

  Handlebars = create();
  Handlebars.create = create;

  Handlebars['default'] = Handlebars;

  __exports__ = Handlebars;
  return __exports__;
})(__module1__, __module7__, __module8__, __module11__, __module12__);

  return __module0__;
}));

define('syracuse-tablet/html/js/helpers/handlebarsHelpers',['require','exports','module'],function (require, exports, module) {"use strict";

exports.registerHelpers = function(Handlebars) {

	/**
	 * USAGE
	 * 		{{#smCompare name "Code"}}
	 *      {{#smCompare name ">" 5}}
	 */
	Handlebars.registerHelper('smCompare', function(lvalue, operator, rvalue, options) {
		var operators, result;

		if (arguments.length < 3) {
			throw new Error("Handlerbars Helper 'compare' needs 2 parameters");
		}

		if (options === undefined) {
			options = rvalue;
			rvalue = operator;
			operator = "===";
		}

		operators = {
			'==': function(l, r) {
				return l == r;
			},
			'===': function(l, r) {
				return l === r;
			},
			'!=': function(l, r) {
				return l != r;
			},
			'!==': function(l, r) {
				return l !== r;
			},
			'<': function(l, r) {
				return l < r;
			},
			'>': function(l, r) {
				return l > r;
			},
			'<=': function(l, r) {
				return l <= r;
			},
			'>=': function(l, r) {
				return l >= r;
			},
			'typeof': function(l, r) {
				return typeof l == r;
			}
		};

		if (!operators[operator]) {
			throw new Error("Handlerbars Helper 'compare' doesn't know the operator " + operator);
		}

		result = operators[operator](lvalue, rvalue);

		if (result) {
			return options.fn(this);
		} else {
			return options.inverse(this);
		}

	});
};
});



/*
* jQuery Mobile v1.4.5
* http://jquerymobile.com
*
* Copyright 2010, 2014 jQuery Foundation, Inc. and other contributors
* Released under the MIT license.
* http://jquery.org/license
*
*/

(function ( root, doc, factory ) {
// FDB No need - Fix build release bug
//	if ( typeof define === "function" && define.amd ) {
//		// AMD. Register as an anonymous module.
//		define( [ "jquery" ], function ( $ ) {
//			factory( $, root, doc );
//			return $.mobile;
//		});
//	} else {
		// Browser globals
		factory( root.jQuery, root, doc );
//	}
}( this, document, function ( jQuery, window, document, undefined ) {	(function( $, undefined ) {
		$.extend( $.support, {
			orientation: "orientation" in window && "onorientationchange" in window
		});
	}( jQuery ));


	// throttled resize event
	(function( $ ) {
		$.event.special.throttledresize = {
			setup: function() {
				$( this ).bind( "resize", handler );
			},
			teardown: function() {
				$( this ).unbind( "resize", handler );
			}
		};

		var throttle = 250,
			handler = function() {
				curr = ( new Date() ).getTime();
				diff = curr - lastCall;

				if ( diff >= throttle ) {

					lastCall = curr;
					$( this ).trigger( "throttledresize" );

				} else {

					if ( heldCall ) {
						clearTimeout( heldCall );
					}

					// Promise a held call will still execute
					heldCall = setTimeout( handler, throttle - diff );
				}
			},
			lastCall = 0,
			heldCall,
			curr,
			diff;
	})( jQuery );


(function( $, window ) {
	var win = $( window ),
		event_name = "orientationchange",
		get_orientation,
		last_orientation,
		initial_orientation_is_landscape,
		initial_orientation_is_default,
		portrait_map = { "0": true, "180": true },
		ww, wh, landscape_threshold;

	// It seems that some device/browser vendors use window.orientation values 0 and 180 to
	// denote the "default" orientation. For iOS devices, and most other smart-phones tested,
	// the default orientation is always "portrait", but in some Android and RIM based tablets,
	// the default orientation is "landscape". The following code attempts to use the window
	// dimensions to figure out what the current orientation is, and then makes adjustments
	// to the to the portrait_map if necessary, so that we can properly decode the
	// window.orientation value whenever get_orientation() is called.
	//
	// Note that we used to use a media query to figure out what the orientation the browser
	// thinks it is in:
	//
	//     initial_orientation_is_landscape = $.mobile.media("all and (orientation: landscape)");
	//
	// but there was an iPhone/iPod Touch bug beginning with iOS 4.2, up through iOS 5.1,
	// where the browser *ALWAYS* applied the landscape media query. This bug does not
	// happen on iPad.

	if ( $.support.orientation ) {

		// Check the window width and height to figure out what the current orientation
		// of the device is at this moment. Note that we've initialized the portrait map
		// values to 0 and 180, *AND* we purposely check for landscape so that if we guess
		// wrong, , we default to the assumption that portrait is the default orientation.
		// We use a threshold check below because on some platforms like iOS, the iPhone
		// form-factor can report a larger width than height if the user turns on the
		// developer console. The actual threshold value is somewhat arbitrary, we just
		// need to make sure it is large enough to exclude the developer console case.

		ww = window.innerWidth || win.width();
		wh = window.innerHeight || win.height();
		landscape_threshold = 50;

		initial_orientation_is_landscape = ww > wh && ( ww - wh ) > landscape_threshold;

		// Now check to see if the current window.orientation is 0 or 180.
		initial_orientation_is_default = portrait_map[ window.orientation ];

		// If the initial orientation is landscape, but window.orientation reports 0 or 180, *OR*
		// if the initial orientation is portrait, but window.orientation reports 90 or -90, we
		// need to flip our portrait_map values because landscape is the default orientation for
		// this device/browser.
		if ( ( initial_orientation_is_landscape && initial_orientation_is_default ) || ( !initial_orientation_is_landscape && !initial_orientation_is_default ) ) {
			portrait_map = { "-90": true, "90": true };
		}
	}

	$.event.special.orientationchange = $.extend( {}, $.event.special.orientationchange, {
		setup: function() {
			// If the event is supported natively, return false so that jQuery
			// will bind to the event using DOM methods.
			if ( $.support.orientation && !$.event.special.orientationchange.disabled ) {
				return false;
			}

			// Get the current orientation to avoid initial double-triggering.
			last_orientation = get_orientation();

			// Because the orientationchange event doesn't exist, simulate the
			// event by testing window dimensions on resize.
			win.bind( "throttledresize", handler );
		},
		teardown: function() {
			// If the event is not supported natively, return false so that
			// jQuery will unbind the event using DOM methods.
			if ( $.support.orientation && !$.event.special.orientationchange.disabled ) {
				return false;
			}

			// Because the orientationchange event doesn't exist, unbind the
			// resize event handler.
			win.unbind( "throttledresize", handler );
		},
		add: function( handleObj ) {
			// Save a reference to the bound event handler.
			var old_handler = handleObj.handler;

			handleObj.handler = function( event ) {
				// Modify event object, adding the .orientation property.
				event.orientation = get_orientation();

				// Call the originally-bound event handler and return its result.
				return old_handler.apply( this, arguments );
			};
		}
	});

	// If the event is not supported natively, this handler will be bound to
	// the window resize event to simulate the orientationchange event.
	function handler() {
		// Get the current orientation.
		var orientation = get_orientation();

		if ( orientation !== last_orientation ) {
			// The orientation has changed, so trigger the orientationchange event.
			last_orientation = orientation;
			win.trigger( event_name );
		}
	}

	// Get the current page orientation. This method is exposed publicly, should it
	// be needed, as jQuery.event.special.orientationchange.orientation()
	$.event.special.orientationchange.orientation = get_orientation = function() {
		var isPortrait = true, elem = document.documentElement;

		// prefer window orientation to the calculation based on screensize as
		// the actual screen resize takes place before or after the orientation change event
		// has been fired depending on implementation (eg android 2.3 is before, iphone after).
		// More testing is required to determine if a more reliable method of determining the new screensize
		// is possible when orientationchange is fired. (eg, use media queries + element + opacity)
		if ( $.support.orientation ) {
			// if the window orientation registers as 0 or 180 degrees report
			// portrait, otherwise landscape
			isPortrait = portrait_map[ window.orientation ];
		} else {
			isPortrait = elem && elem.clientWidth / elem.clientHeight < 1.1;
		}

		return isPortrait ? "portrait" : "landscape";
	};

	$.fn[ event_name ] = function( fn ) {
		return fn ? this.bind( event_name, fn ) : this.trigger( event_name );
	};

	// jQuery < 1.8
	if ( $.attrFn ) {
		$.attrFn[ event_name ] = true;
	}

// FDB No need - Force window
}( jQuery, window ));



}));

define("syracuse-tablet/html/deps/jqm-orientation", function(){});


/*!
 * jQuery Cookie Plugin v1.4.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2006, 2014 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
// FDB
// 	if (typeof define === 'function' && define.amd) {
// AMD (Register as an anonymous module)
// 		define(['jquery'], factory);
// 	} else if (typeof exports === 'object') {
// Node/CommonJS
// 	module.exports = factory(require('jquery'));
// 	} else {
// Browser globals
		factory(jQuery);
// 	}
}(function ($) {

	var pluses = /\+/g;

	function encode(s) {
		return config.raw ? s : encodeURIComponent(s);
	}

	function decode(s) {
		return config.raw ? s : decodeURIComponent(s);
	}

	function stringifyCookieValue(value) {
		return encode(config.json ? JSON.stringify(value) : String(value));
	}

	function parseCookieValue(s) {
		if (s.indexOf('"') === 0) {
			// This is a quoted cookie as according to RFC2068, unescape...
			s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
		}

		try {
			// Replace server-side written pluses with spaces.
			// If we can't decode the cookie, ignore it, it's unusable.
			// If we can't parse the cookie, ignore it, it's unusable.
			s = decodeURIComponent(s.replace(pluses, ' '));
			return config.json ? JSON.parse(s) : s;
		} catch(e) {}
	}

	function read(s, converter) {
		var value = config.raw ? s : parseCookieValue(s);
		return $.isFunction(converter) ? converter(value) : value;
	}

	var config = $.cookie = function (key, value, options) {

		// Write

		if (arguments.length > 1 && !$.isFunction(value)) {
			options = $.extend({}, config.defaults, options);

			if (typeof options.expires === 'number') {
				var days = options.expires, t = options.expires = new Date();
				t.setMilliseconds(t.getMilliseconds() + days * 864e+5);
			}

			return (document.cookie = [
				encode(key), '=', stringifyCookieValue(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
				options.path    ? '; path=' + options.path : '',
				options.domain  ? '; domain=' + options.domain : '',
				options.secure  ? '; secure' : ''
			].join(''));
		}

		// Read

		var result = key ? undefined : {},
			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all. Also prevents odd result when
			// calling $.cookie().
			cookies = document.cookie ? document.cookie.split('; ') : [],
			i = 0,
			l = cookies.length;

		for (; i < l; i++) {
			var parts = cookies[i].split('='),
				name = decode(parts.shift()),
				cookie = parts.join('=');

			if (key === name) {
				// If second argument (value) is a function it's a converter...
				result = read(cookie, value);
				break;
			}

			// Prevent storing a cookie that we couldn't decode.
			if (!key && (cookie = read(cookie)) !== undefined) {
				result[name] = cookie;
			}
		}

		return result;
	};

	config.defaults = {};

	$.removeCookie = function (key, options) {
		// Must not alter options, thus extending a fresh object...
		$.cookie(key, '', $.extend({}, options, { expires: -1 }));
		return !$.cookie(key);
	};

}));
define("syracuse-tablet/html/deps/jquery.cookie", function(){});

define('syracuse-tablet/html/js/main',['require','exports','module','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/init/initStyles','syracuse-tablet/html/js/init/initLocale','syracuse-tablet/html/js/init/initModules','syracuse-tablet/html/js/init/initLogin','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/helpers/scroller/scrollerHelpers','syracuse-tablet/html/js/helpers/native/nativeJSCall','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/deps/handlebars-latest','syracuse-tablet/html/js/helpers/handlebarsHelpers','syracuse-tablet/html/deps/jqm-orientation','syracuse-tablet/html/deps/jquery.cookie','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/storage/storage'],function (require, exports, module) {"use strict";

var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var initStyles = require('syracuse-tablet/html/js/init/initStyles');
var initLocale = require('syracuse-tablet/html/js/init/initLocale');
var initModules = require('syracuse-tablet/html/js/init/initModules');
var initLogin = require('syracuse-tablet/html/js/init/initLogin');
var nativeApp = require('syracuse-tablet/html/js/helpers/native/native').getModule("nativeApp");
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');
var nativeJSCall = require('syracuse-tablet/html/js/helpers/native/nativeJSCall');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("main", false);
/**
 * Display the fatal error - !! take into account the modal-backdrop class which can't be removed
 */
var _fatalError = '\
	<article style="overflow-y:auto;padding:0 20px;font-family:Segoe UI Light,Segoe UI,Segoe WP,Helvetica Neue,sans-serif;font-size: 14px;height:100%;position:fixed;width:100%;z-index:100000;background-color:white;">\
		<H2 style="margin-top:10px;margin-bottom: 20px;font-size:20px;font-weight:bold">A fatal error occurred during initialization process</H2>\
		{{#each $diagnoses}}\
			<section style="border:red solid 1px;margin: 10px;padding: 10px;color: black;background-color: #FBE3E3;">\
				{{#if $message}}<b>{{{$message}}}</b>{{/if}}\
				{{#if $stackTrace}}<br><br>{{{$stackTrace}}}{{/if}}\
			</section>\
		{{/each}}\
		{{#if clearLocalDb}}<button onClick="window._sm_clearLocalDb();" >Clear Local DataBase</button>{{/if}}\
	</article>';
// Add Handlebars to root
window.Handlebars = require('syracuse-tablet/html/deps/handlebars-latest');
// Add our own helpers
require('syracuse-tablet/html/js/helpers/handlebarsHelpers').registerHelpers(window.Handlebars);
//Add jqm orientation
require('syracuse-tablet/html/deps/jqm-orientation');
// Add jquery.cookie
require('syracuse-tablet/html/deps/jquery.cookie');


log && log("main loaded");

window.onerror = function(errorMsg, url, lineNumber, error) {
	if (globals.application) {
		globals.application.waitWheelStop();
	} else {
		uiutils.waitWheelStop();
	}
	try {
		modal.error("Javascript error", {
			where: "window.onerror",
			exception: error,
			message: errorMsg + "\n" + (url ? "Url : " + jsutils.cleanStack(url) + "\nLineNumber : " + lineNumber : "")
		});
	} catch (e) {
		var msg = errorMsg + "\n" + (error ? +JSON.stringify(error, null, 2) : (url ? "Url : " + url + "\nLineNumber : " + lineNumber : ""));
		alert(msg);
	}
};

var _forceLogin = function(message, isError, offlineHint) {
	var deferred = $.Deferred();
	globals.getApplication().logout(message, isError, offlineHint).then(function() {
		deferred.resolve();
	}).fail(function(e) {
		globals.getModal().error("Int process - logout error", e, function() {
			deferred.resolve();
		});
	});
	return deferred.promise();
};
var _locale = null;
var _text = function(id) {
	if (!_locale) {
		_locale = require('syracuse-tablet/html/js/helpers/locale');
	}
	return _locale ? _locale.text(id) : id;
};

function _startup() {
	log && log("main startup");
	// Register global callback methods that can be access by eventual wrapper
	nativeJSCall.init();
	scroller.init();
	return initStyles.init()
		.then(function() {
			uiutils.waitWheelStart();
			return initLocale.init();
		})
		.then(function() {
			return initModules.init();
		})
		.then(function() {
			return initLogin.init();
		})
		.then(function(userLogedIn) {
			uiutils.waitWheelStop();
			log && log("Main native app: " + (nativeApp != null));
			if (nativeApp) {
				// Send notification to wrapping application to signal all is loaded
				nativeApp.notifLoaded();
			}
			if (!userLogedIn) {
				_forceLogin(_text("login.authentication"), false);
			}
		}).fail(function(e) {
			var diags = jsutils.getPropByPath(jsutils.convertToDiagnoses(e, false), "$diagnoses");
			var message = diags && diags.length > 0 ? diags[0].$message : null;
			log && log("Main startup failed: " + (message || (e && JSON.stringify(e))));
			uiutils.waitWheelStop();

			if (nativeApp && e != null && e.$redirectPage === "login") {
				// If process failed but it's just because authentication, we assume all is ok
				nativeApp.notifLoaded();
			} else if (nativeApp) {
				// Send notification to wrapping application to signal something is wrong
				nativeApp.notifStartFail("" + message || "Startup error");
			}

			// Ensure to switch to offline mode so the navigation to the login page on a failed
			// initialization will directly show the offline mode login page
			var offlineHint;
			if (e && e.$noConnectionError === true) {
				globals.setOfflineQuiet(true);
				offlineHint = true;
			}

			// Application is not necessary available
			if (globals.getApplication()) {
				_forceLogin(message, true, offlineHint).then(function() {
					// $redirectPage means that the user clicked on logout in the selectContext dialog
					if (e != null && e.$redirectPage !== "login") {
						globals.getModal().error(_text("startup.error"), e);
						log && log(JSON.stringify(e));
					}
				});
			} else {
				$(document.body).empty();
				var diags = jsutils.convertToDiagnoses(e, true);
				// #7942 To allow user to clear the local DB
				var st = globals.getStorage();
				if (!st) {
					st = require('syracuse-tablet/html/js/storage/storage');
					st = st ? st.getStorage(true) : null;
				}
				// Check if it's versionError error
				diags.clearLocalDb = JSON.stringify(diags).indexOf(_text("db.err.version")) > 0 && st && st.clearDatabaseSupported();
				if (diags.clearLocalDb) {
					window._sm_clearLocalDb = function() {
						st.clearDatabase().always(function(ok) {
							alert(ok ? "Local database has been deleted\nPlease reload the page" : "Database can't be deleted.\nPlease contact the administrator");
						});
					};
				}
				$(window.document.body).empty().html(Handlebars.compile(_fatalError)(diags));
			}
		});
}

$(document).ready(function() {
	log && log("main document ready");

	if (document.location.href.indexOf("?circular") > -1) {
		xrayquire.showCycles(undefined, true);
	} else {
		_startup();
	}
});
});

