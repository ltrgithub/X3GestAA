define('syracuse-tablet/html/js/common/modules',['require','exports','module'],function (require, exports, module) {

var _modules = {};

exports.addModule = function(name, module) {
	_modules[name] = module;
}

exports.get = function(name) {
	var module = _modules[name];
	if (!module) {
		console.log("Modules:" + Object.keys(_modules));
		throw new Error("No such module: " + name);
	}
	return module;
}

window.smModules = exports;
});

define('syracuse-tablet/html/js/helpers/jsutils',['require','exports','module'],function (require, exports, module) {

var _APP_RELEASE_REP = "/dist/";
var _APP_DVLP_REP = "/html/";
var _APP_RELEASE_INDEX = "index.html";
var _APP_DVLP_INDEX = "index_debug.html";

var _stringToHtml = function(str) {
	return (str || "").replace(/\n/g, "<br>");
};
var _strStartsWith = function(str, s) {
	if (!str || str.length == 0 || s == null || s.length === 0 || str.length < s.length) {
		return false;
	}
	return s.length === 1 ? str.charAt(0) === s.toString() : str.indexOf(s.toString()) === 0;
};
var _strEndsWith = function(str, s) {
	if (!str || str.length == 0 || s == null || str.length < s.length) {
		return false;
	}
	s = s.toString();
	return s.length === 1 ? str.charAt(str.length - 1) === s : str.lastIndexOf(s) === str.length - s.length;
};
var _strCapitalize = function(str) {
	if (!str || str.length === 0) {
		return str;
	}
	return str.charAt(0).toUpperCase() + str.slice(1);
};
/*
 * This module must only contain low level helper functions that do not have any dependencies!
 */
if (!window.exports) {
	// Trick - This file can be used in html pages outsite required loader - See open_link
	window.exports = window;
}
/** Parse an url 
 * !!! no @ character should be present in query params (keep them encoded)
 * There are @ query params in date where clauses
 **/
var _purlOptions = {
	strictMode: false,
	key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "querystring", "anchor"],
	q: {
		name: "query",
		parser: /(?:^|&)([^&=]*)=?([^&]*)/g
	},
	parser: {
		strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
		loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
	}
};
/*
 * {
  "anchor": "", "file": "", "password": "", "user": "", "userInfo": "",
  "querystring": "representation=AQTCRUDM.$edit",
  "directory": "/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies",
  "path": "/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies",
  "relative": "/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies?representation=AQTCRUDM.$edit",
  "port": "8124",
  "host": "pc101329.sagefr.adinternal.com",
  "authority": "pc101329.sagefr.adinternal.com:8124",
  "protocol": "http",
  "source": "http://pc101329.sagefr.adinternal.com:8124/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies?representation=AQTCRUDM.$edit",
  "query": {
    "representation": "AQTCRUDM.$edit"
  }
 */
var _parseURL = function(str) {

	// Regex based parser fails on @ in the url also it's valid according specs
	// this is why we encode it (only query params) as %40
	// The query params will be decoded at the end so there should be no harm cause by this
	// https://github.com/Sage-ERP-X3/Syracuse/issues/8660
	str = str && str.replace(/\?.*(\@)/g, function(m) {
		return m.replace(/\@/g, "%40");
	});

	var o = _purlOptions;
	var m = o.parser[o.strictMode ? "strict" : "loose"].exec(str);
	var uri = {};
	var i = 14;

	while (i--) uri[o.key[i]] = m[i] || "";

	uri[o.q.name] = {};
	uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) {
		if ($1) uri[o.q.name][$1] = decodeURIComponent($2);
	});
	return uri;
};
/**
 * Return a string url from u object which has been parsed with _parseURL
 */
var _urlToString = function(u) {
	if (!u) return "";
	var url = "";
	if (u.protocol && u.host) {
		url += u.protocol + "://" + u.host;
		if (u.port.length != 0) url += ":" + u.port;
	}
	url += u.directory ? u.directory.trim() : "";
	if (u.file) {
		if (!_strEndsWith(u.directory, "/")) {
			url += "/";
		}
		url += u.file;
	}
	var query = "";
	for (var p in u.query) {
		if (query.length != 0) query += "&";
		query += p + "=" + encodeURIComponent(u.query[p]);
	}
	if (query.length != 0) url += "?" + query;
	if (u.anchor) url += "#" + u.anchor;
	return url;
};
/**
 * Return the current url
 */
var _curUrl;
var _getCurrentUrl = function() {
	if (_curUrl) return _curUrl;
	_curUrl = _parseURL(window.location.href);
	return _curUrl;
};

/**
 * Returns the context to restore if any (used by external links or live tiles to open a page)
 * Context has been stored by open_link.html page and removed from url (see getOpenLinkUrl, sessStorage)
 * return {endpoint:, applicationName:, history[state]}
 */
var _getUrlContextId = function() {
	// Read context in session storage if any (see open_link.html)
	var contextId;
	var sessStorage = typeof(window.sessionStorage) !== "undefined" ? window.sessionStorage : null;
	if (sessStorage) {
		contextId = sessStorage.getItem("__urlContext__");
		sessStorage.removeItem("__urlContext__");
	}
	if (!contextId) {
		// If no context check url context
		var url = exports.getCurrentUrl();
		contextId = url.quey ? url.query.context : null;
	}
	return contextId;
};
/**
 * Read url context and stores it in session storage if any
 * Remove the context param from url
 * Call idenx.htlk page
 */
var _setUrlContextId = function() {
	var sessStorage = typeof(window.sessionStorage) !== "undefined" ? window.sessionStorage : null;
	if (sessStorage) {
		sessStorage.removeItem("__urlContext__");
	}
	var url = _parseURL(window.location.href);
	try {
		var contextId = url.query && url.query.context;
		console.log("_setUrlContextId", contextId);
		if (sessStorage && contextId && contextId.trim().length > 0) {
			// Stores the context
			sessStorage.setItem("__urlContext__", contextId);
			// Remove it from url
			delete url.query.context;
		}
	} catch (e) {}
	// location.replace to prevent back button
	var file = url.file;
	url.file = url.path.indexOf(_APP_RELEASE_REP) > 0 ? _APP_RELEASE_INDEX : _APP_DVLP_INDEX;
	url.path = url.path.replace(file, url.file);
	window.location.replace(_urlToString(url));
};


var _isInstanceOf = function(o, name) {
	if (o == null) return false;
	var ctor = o.constructor;
	if (ctor && ctor.$smClasses) {
		return ctor.$smClasses.indexOf(name) > -1;
	}
	return false;
};

var _addInheritanceInfo = function(ctor, parent) {
	var classes = [];
	/**
	 * ctor.name comes from the constructor
	 *	var _Page = utils.defineClass(
	 *	function RegularPage($parent,
	 *	In that case name = "RegularPage"
	 */

	/*
	 * https://github.com/Sage-ERP-X3/Syracuse/issues/8758
	 * ctor.name does not exist on IE 11
	 * This is why we try ctor.toString() and parse the function for it's name
	 */
	var name = ctor.name;
	if (!name) {
		var ctorName = ctor && ctor.toString();
		ctorName = ctorName.match(/^function\s*([^\s(]+)/);
		name = ctorName && (ctorName.length > 1 ? ctorName[1] : null);
	}
	if (name) {
		classes.push(name);
	}
	/**
	 * FDB #7822 - we need to propagate $smClasses even if ctor.name == ""
	 * Otherwise we have to define a name for each constructor even if we just want to check the parent class name
	 * Eg: "SidePanel" - We don't want to add a constructor name for all child classes to test instanceOf ("SidePanel")
	 */
	if (parent && parent.$smClasses) {
		var i;
		for (i = 0; i < parent.$smClasses.length; i++) {
			classes.push(parent.$smClasses[i]);
		}
	}
	ctor.$smClasses = classes;
};

var _isError = function(o) {
	if (o && o instanceof Error) {
		return true;
	}
	// Old one
	return o && Error.prototype.toString === o.toString;
};

var _isDOMException = function(o) {
	return o && o.constructor && o.constructor.name === "DOMException";
};

/** 
 * Clean error stack from current base url and limit the size due to the use of deferred
 * html: true -> Display in Html
 **/
var _stackRegexp;
var _cleanStack = function(stack, max, html) {
	if (Array.isArray(stack)) return stack;
	if (!_stackRegexp) {
		var host = window.location.protocol + "//" + window.location.host;
		var path = window.location.pathname.split('/').splice(0, 2).join('/');
		var withPath = host + path;
		var requirePath = host + "/requireJS" + path;
		_stackRegexp = {
			r1: new RegExp(withPath, "g"),
			r2: new RegExp(requirePath, "g")
		};
	}

	max = max == null ? 5 : max;
	if (stack) {
		var array = (stack.split && stack.split("\n")) || stack;;
		var res;
		if (array.length > 0) {
			array.forEach(function(l) {
				var pos1 = l.lastIndexOf(".js");
				if (pos1 > 0) {
					var pos2 = l.lastIndexOf("/", pos1);
					if (pos1 > 0) {
						if (!res) res = [];
						res.push(l.substring(pos2));
					}
				} else {
					// Unknown line format (to include details at end of stack, just add line here)
					if (!res) res = [];
					res.push(l);
				}
			});
		}
		if (!res && _stackRegexp) {
			stack = _stackRegexp ? stack.replace(_stackRegexp.r1, "").replace(_stackRegexp.r2, "") : stack;
		} else {
			stack = res.join('\n');
		}
	} else {
		stack = "";
	}
	stack = stack.split("\n");
	if (max) { // Allow max level of source stack files, stack elements not pointing to a file are always added since the may include important information
		res = [];
		stack.forEach(function(l) {
			if (l.indexOf(".js") > -1) {
				if (max > 0) {
					res.push(l);
					max--;
				}
			} else {
				res.push(l);
			}
		});
		stack = res.join(html ? "<br>&nbsp&nbsp&nbsp&nbsp&nbsp" : "\n");
	}
	return stack;
};

/*
 * Takes what ever is passed as parameter and creates an object containing and $diagnoses array
 * title: Always a string
 * e: String or Error or any kind of object*
 *
 * object*:
 * {
 *   message: "text",
 *   detail: Error or Object
 * }
 *
 */
var _convertToDiagnoses = function(e, html) {
	if (e == null) {
		e = "No error message";
	}
	if (typeof e === "string") {
		// String message
		return {
			$diagnoses: [{
				$severity: "error",
				$message: html ? _stringToHtml(e) : e
			}]
		};
	} else if (_isError(e) || _isDOMException(e)) {
		// Exception to diagnoses
		return {
			$diagnoses: [{
				$message: html ? _stringToHtml(e.message) : e.message,
				$stackTrace: _cleanStack(e.stack, null, html),
				$severity: "error"
			}]
		};
	} else {
		// If parameter is already an object with diagnoses, do not do anything special
		if (e.$diagnoses && Array.isArray(e.$diagnoses)) {
			return e;
		}
		// Arbitrary object
		var res = {
			$diagnoses: []
		};
		var diag = {
			$severity: "error",
			$message: e.message || e.$message || e.$title || "No error message"

		};
		if (html) {
			diag.$message = _stringToHtml(diag.$message);
		}
		res.$diagnoses.push(diag);
		var detail = e.detail;
		if (detail) {
			if (_isError(detail)) {
				if (detail.message) {
					diag.$stackTrace = (diag.$stackTrace ? diag.$stackTrace + "\n" : "") + detail.message;
				}
				if (detail.stack) {
					diag.$stackTrace = (diag.$stackTrace ? diag.$stackTrace + "\n" : "") + _cleanStack(detail.stack, null, html);
				}
			} else {
				diag.$stackTrace = (diag.$stackTrace ? diag.$stackTrace + "\n" : "") + JSON.stringify(detail);
			}
		}
		var xe = e;
		while (xe.$exception != null) {
			_$exceptionAdd(res, xe.$exception, html);
			xe = xe.$exception;
		}
		return res;
	}
};
// $exception returned by storage in addition to $message
var _$exceptionAdd = function(res, $exception, html) {
	if (!$exception) return;
	var msg = typeof $exception === "string" ? $exception : $exception.message || $exception.$message;
	var stk = $exception.stack;
	if (msg || stk) {
		res.$diagnoses.push({
			$message: html ? _stringToHtml(msg) : msg,
			$stackTrace: stk ? _cleanStack(stk, null, html) : "",
			$severity: "error"
		});
	}
};
/**
 * return the value of a given path
 * 	path:	String with/without '.' as separator or array of strings
 *  cache: 	null	-> No cache
 * 		    !null	-> object that stores the cache
 */
var _getPropByPath = function(object, path, cache) {
	if (path == null || object == null) return null;
	var pathStr, pathArray;
	if (Array.isArray(path)) {
		if (path.length === 0) return null;
		pathArray = path;
		pathStr = pathArray.join(".");
	} else {
		pathArray = path.split('.');
		pathStr = path;
	}
	if (cache && cache[pathStr] != null) {
		return cache[pathStr];
	}
	// Check parent if needed
	var data = object[pathArray[0]];
	for (var i = 1; i < pathArray.length; i++) {
		if (data == null) return null;
		if (!$.isPlainObject(data) == null) {
			throw new Error('_getPropByPath - Unexpected non-plainobject');
		}
		data = data[pathArray[i]];
	}
	if (cache) {
		cache[pathStr] = data;
	}
	return data;
};


/**
 * simple function bind
 * arguments that follow context are passed to fn call back after the regular parameters
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
	var args = arguments.length > 2 ? Array.prototype.splice.call(arguments, 2) : null;
	return function boundFn() {
		var callBackArgs = arguments;
		if (args && args.length > 0) {
			args.forEach(function(a) {
				Array.prototype.push.call(callBackArgs, a);
			});
		}
		return fn.apply(context ? context : this, callBackArgs);
	};
}
//http://jsperf.com/multi-array-concat/7
// concatArrays(array1, array2, array3...) - accept undefined arguments
exports.concatArrays = function() {
	var args = [];
	for (var i = 0; i < arguments.length; i++) {
		if (arguments[i] != null) args.push(arguments[i]);
	}
	return [].concat.apply([], args);
};
exports.getPropByPath = _getPropByPath;
exports.addInheritanceInfo = _addInheritanceInfo;

/**
 * return true if o is an instance of class 'name'
 * Like this process could slow down the application it's better to register only classes for which we want to check instance
 */
exports.isInstanceOf = _isInstanceOf;

exports.isError = _isError;
exports.isDOMException = _isDOMException;

exports.cleanStack = _cleanStack;

exports.convertToDiagnoses = _convertToDiagnoses;

exports.bindFn = bindFn;

exports.getCurrentUrl = _getCurrentUrl;

/**
 * return http://host:port
 * acespted url: 	null 	takes current url
 * 					string
 * 					parsed Url
 */
exports.getUrlHost = function(url) {
	if (!url) {
		url = _getCurrentUrl();
	} else if (!$.isPlainObject(url)) {
		if (!url.smStartsWith("http")) {
			url = _getCurrentUrl();
		} else {
			url = exports.parseURL(url);
		}
	} else if (!url.protocol) {
		url = _getCurrentUrl();
	}
	var res = url.protocol + "://" + url.host;
	if (url.port != null) {
		res += ":" + url.port
	}
	return res;
}
exports.getCurrentHostUrl = function() {
	return exports.getUrlHost(null);
}
exports.getUrlContextId = _getUrlContextId;
exports.setUrlContextId = _setUrlContextId;
exports.parseURL = _parseURL;
exports.urlToString = _urlToString;
exports.strStartsWith = _strStartsWith;
exports.strEndsWith = _strEndsWith;
exports.strCapitalize = _strCapitalize;
exports.isReleaseVersion = function() {
	return document.location.href.indexOf("/index_debug.html") < 0 && document.location.href.indexOf("/index_release.html") < 0;
};
exports.isDvlpVersion = function() {
	return window.location.href.indexOf("/index_debug.html") > -1 || window.location.href.indexOf("/index_joined.html") > -1;
};
exports.isTestEnvironment = function() {
	return window.location.href.indexOf("/syracuse-tablet/test/index.html") > -1;
};
exports.getResourcesBasePath = function() {
	if (exports.isReleaseVersion()) {
		return "/syracuse-tablet" + _APP_RELEASE_REP;
	} else {
		return "/syracuse-tablet" + _APP_DVLP_REP;
	}
};
});

define('syracuse-tablet/html/js/helpers/serverLog',['require','exports','module'],function (require, exports, module) {

var sdataHost = (window.location.protocol.toLowerCase() === "file:") ? "" : (window.location.protocol + "//" + window.location.host);

// Url that allow logging even if user is not authenticated
var _logWriteUrl = "/requireJS/log/write?text=";

var lastlog = new Date();
var num = 0;
var lastlog;
var _maxLevel = 0;

function line(text) {
	if (!text) return null;
	var now = new Date(),
		trace = null;
	if (lastlog == null || ((now.getTime() - lastlog.getTime()) > 1000)) {
		text = "********Mobile********\n" + (++num) + ": " + text;
		lastlog = now;
	}
	return text;
}
var _stdTypeToString = function(a, type) {
	if (a == null) return null;
	type = type || typeof a;
	switch (type) {
		case "number":
		case "string":
		case "boolean":
			return new String(a);
			break;
	}
	return null;
};
var _objectToString = function(a, level, flat) {
	level = level == null ? 0 : level;
	if (a == null) return null;
	if (typeof a != "object") return null;
	var res, v;
	if (Array.isArray(a)) {
		res = [];
		a.forEach(function(b) {
			v = _stdTypeToString(b);
			if (v) {
				res.push(v);
			} else if (flat !== true && level <= _maxLevel) {
				v = _objectToString(b, level + 1);
				if (v) {
					res.push(v);
				}
			}
		});
		if (res.length == 0) return null;;
	} else {
		res = {};
		for (var p in a) {
			var v = _stdTypeToString(a[p]);
			if (v) {
				res[p] = v;
			} else if (flat !== true && level <= _maxLevel) {
				v = _objectToString(a[p], level + 1);
				if (v) {
					res[p] = v;
				}
			}
		}
		if ($.isEmptyObject(res)) res = null;
	}
	return level == 0 ? JSON.stringify(res, null, 2) : res;
};
var _argsToString = function(args, flat) {
	var msg = [];
	for (var i = 0; i < args.length; i++) {
		var a = args[i];
		if (a == null) continue;
		var text = _stdTypeToString(a);
		if (text) {
			msg.push(text);
		} else {
			text = _objectToString(a, 0, flat);
			if (text) {
				msg.push(text);
			}
		}
	}
	if (msg.length == 0) return null;
	return msg.join(' ');
};
var _log = function(msg) {
	msg = line(msg);
	if (msg == null) return null;
	$.ajax({
		type: "GET",
		async: false,
		url: sdataHost + _logWriteUrl + encodeURIComponent(msg),
		success: function(xhr) { /* fire and forget */ }
	});
};
exports.log = function() {
	_log(_argsToString(arguments, false));
};
exports.logFlat = function() {
	_log(_argsToString(arguments, true));
};
});

define('syracuse-tablet/html/js/helpers/logger',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/serverLog'],function (require, exports, module) {

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var serverLog = require('syracuse-tablet/html/js/helpers/serverLog');

// true to log on Syracuse server console
var _logOnServer = false;

var _log;

if (window.smNativeLogger && window.smNativeLogger.log) {
	_log = function() {
		var args = [];
		for (var i = 0; i < arguments.length; i++) {
			args.push(arguments[i]);
		}
		window.smNativeLogger.log(args.join(""));
	};
} else {
	var _console = _logOnServer === true ? serverLog : window.console;
	_log = function() {
		if (!_console) return;
		var text = [];
		for (var i = 0; i < arguments.length; i++) {
			var a = arguments[i];
			if (a != null) {
				if (jsutils.isError(a))
					_console && _console.log && _console.log(a.message, "\n", jsutils.cleanStack(a.stack));
				else
					text.push(a);
			}
		}
		_console && _console.log && _console.log(text.join(text, " "));
	};
}
if (window) {
	window.logger = _log;
}

function _getLogger(module, force) {
	// if (module && module.indexOf("native") > -1) force = true;
	if (!(force === true)) {
		return null;
	}
	var logger = function() {
		var text, errs;
		for (var i = 0; i < arguments.length; i++) {
			if (jsutils.isError(arguments[i])) {
				if (!errs) errs = [];
				errs.push(arguments[i]);
			} else {
				if (!text) text = ["[" + module + "]: "];
				text.push(arguments[i]);
			}
		}
		if (text && text.length > 1) _log(text.join(" "));
		if (errs) {
			errs.forEach(function(e) {
				_log("[" + module + "]: " + e.message);
				if (e.stack) _log(jsutils.cleanStack(e.stack));
			});
		}
	};
	return logger;
}

exports.log = _log;
exports.getLogger = _getLogger;
});

/*!
  * Bowser - a browser detector
  * https://github.com/ded/bowser
  * MIT License | (c) Dustin Diaz 2015
  */

!function (name, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define('syracuse-tablet/html/deps/bowser/bowser',definition)
  else this[name] = definition()
}('bowser', function () {
  /**
    * See useragents.js for examples of navigator.userAgent
    */

  var t = true

  function detect(ua) {

    function getFirstMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[1]) || '';
    }

    function getSecondMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[2]) || '';
    }

    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
      , likeAndroid = /like android/i.test(ua)
      , android = !likeAndroid && /android/i.test(ua)
      , chromeBook = /CrOS/.test(ua)
      , edgeVersion = getFirstMatch(/edge\/(\d+(\.\d+)?)/i)
      , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
      , tablet = /tablet/i.test(ua)
      , mobile = !tablet && /[^-]mobi/i.test(ua)
      , result

    if (/opera|opr/i.test(ua)) {
      result = {
        name: 'Opera'
      , opera: t
      , version: versionIdentifier || getFirstMatch(/(?:opera|opr)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/yabrowser/i.test(ua)) {
      result = {
        name: 'Yandex Browser'
      , yandexbrowser: t
      , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/windows phone/i.test(ua)) {
      result = {
        name: 'Windows Phone'
      , windowsphone: t
      }
      if (edgeVersion) {
        result.msedge = t
        result.version = edgeVersion
      }
      else {
        result.msie = t
        result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/msie|trident/i.test(ua)) {
      result = {
        name: 'Internet Explorer'
      , msie: t
      , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
      }
    } else if (chromeBook) {
      result = {
        name: 'Chrome'
      , chromeBook: t
      , chrome: t
      , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    } else if (/chrome.+? edge/i.test(ua)) {
      result = {
        name: 'Microsoft Edge'
      , msedge: t
      , version: edgeVersion
      }
    }
    else if (/chrome|crios|crmo/i.test(ua)) {
      result = {
        name: 'Chrome'
      , chrome: t
      , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    }
    else if (iosdevice) {
      result = {
        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
      }
      // WTF: version is not part of user agent in web apps
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if (/sailfish/i.test(ua)) {
      result = {
        name: 'Sailfish'
      , sailfish: t
      , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/seamonkey\//i.test(ua)) {
      result = {
        name: 'SeaMonkey'
      , seamonkey: t
      , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/firefox|iceweasel/i.test(ua)) {
      result = {
        name: 'Firefox'
      , firefox: t
      , version: getFirstMatch(/(?:firefox|iceweasel)[ \/](\d+(\.\d+)?)/i)
      }
      if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
        result.firefoxos = t
      }
    }
    else if (/silk/i.test(ua)) {
      result =  {
        name: 'Amazon Silk'
      , silk: t
      , version : getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
      }
    }
    else if (android) {
      result = {
        name: 'Android'
      , version: versionIdentifier
      }
    }
    else if (/phantom/i.test(ua)) {
      result = {
        name: 'PhantomJS'
      , phantom: t
      , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
      result = {
        name: 'BlackBerry'
      , blackberry: t
      , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/(web|hpw)os/i.test(ua)) {
      result = {
        name: 'WebOS'
      , webos: t
      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
      };
      /touchpad\//i.test(ua) && (result.touchpad = t)
    }
    else if (/bada/i.test(ua)) {
      result = {
        name: 'Bada'
      , bada: t
      , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
      };
    }
    else if (/tizen/i.test(ua)) {
      result = {
        name: 'Tizen'
      , tizen: t
      , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
      };
    }
    else if (/safari/i.test(ua)) {
      result = {
        name: 'Safari'
      , safari: t
      , version: versionIdentifier
      }
    }
    else {
      result = {
        name: getFirstMatch(/^(.*)\/(.*) /),
        version: getSecondMatch(/^(.*)\/(.*) /)
     };
   }

    // set webkit or gecko flag for browsers based on these engines
    if (!result.msedge && /(apple)?webkit/i.test(ua)) {
      result.name = result.name || "Webkit"
      result.webkit = t
      if (!result.version && versionIdentifier) {
        result.version = versionIdentifier
      }
    } else if (!result.opera && /gecko\//i.test(ua)) {
      result.name = result.name || "Gecko"
      result.gecko = t
      result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i)
    }

    // set OS flags for platforms that have multiple browsers
    if (!result.msedge && (android || result.silk)) {
      result.android = t
    } else if (iosdevice) {
      result[iosdevice] = t
      result.ios = t
    }

    // OS version extraction
    var osVersion = '';
    if (result.windowsphone) {
      osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
    } else if (iosdevice) {
      osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (android) {
      osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
    } else if (result.webos) {
      osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
    } else if (result.blackberry) {
      osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
    } else if (result.bada) {
      osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
    } else if (result.tizen) {
      osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
    }
    if (osVersion) {
      result.osversion = osVersion;
    }

    // device type extraction
    var osMajorVersion = osVersion.split('.')[0];
    if (tablet || iosdevice == 'ipad' || (android && (osMajorVersion == 3 || (osMajorVersion == 4 && !mobile))) || result.silk) {
      result.tablet = t
    } else if (mobile || iosdevice == 'iphone' || iosdevice == 'ipod' || android || result.blackberry || result.webos || result.bada) {
      result.mobile = t
    }

    // Graded Browser Support
    // http://developer.yahoo.com/yui/articles/gbs
    if (result.msedge ||
        (result.msie && result.version >= 10) ||
        (result.yandexbrowser && result.version >= 15) ||
        (result.chrome && result.version >= 20) ||
        (result.firefox && result.version >= 20.0) ||
        (result.safari && result.version >= 6) ||
        (result.opera && result.version >= 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
        (result.blackberry && result.version >= 10.1)
        ) {
      result.a = t;
    }
    else if ((result.msie && result.version < 10) ||
        (result.chrome && result.version < 20) ||
        (result.firefox && result.version < 20.0) ||
        (result.safari && result.version < 6) ||
        (result.opera && result.version < 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
        ) {
      result.c = t
    } else result.x = t

    return result
  }

  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent : '')

  bowser.test = function (browserList) {
    for (var i = 0; i < browserList.length; ++i) {
      var browserItem = browserList[i];
      if (typeof browserItem=== 'string') {
        if (browserItem in bowser) {
          return true;
        }
      }
    }
    return false;
  }

  /*
   * Set our detect method to the main bowser object so we can
   * reuse it to test other user agents.
   * This is needed to implement future tests.
   */
  bowser._detect = detect;

  return bowser
});

/*!
 * Platform.js v1.3.1 <http://mths.be/platform>
 * Copyright 2014-2016 Benjamin Tan <https://d10.github.io/>
 * Copyright 2011-2013 John-David Dalton <http://allyoucanleet.com/>
 * Available under MIT license <http://mths.be/mit>
 */
;(function() {
  

  /** Used to determine if values are of the language type `Object` */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Backup possible global object */
  var oldRoot = root;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  /**
   * Used as the maximum length of an array-like object.
   * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
   * for more details.
   */
  var maxSafeInteger = Math.pow(2, 53) - 1;

  /** Opera regexp */
  var reOpera = /\bOpera/;

  /** Possible global object */
  var thisBinding = this;

  /** Used for native method references */
  var objectProto = Object.prototype;

  /** Used to check for own properties of an object */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to resolve the internal `[[Class]]` of values */
  var toString = objectProto.toString;

  /*--------------------------------------------------------------------------*/

  /**
   * Capitalizes a string value.
   *
   * @private
   * @param {string} string The string to capitalize.
   * @returns {string} The capitalized string.
   */
  function capitalize(string) {
    string = String(string);
    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  /**
   * A utility function to clean up the OS name.
   *
   * @private
   * @param {string} os The OS name to clean up.
   * @param {string} [pattern] A `RegExp` pattern matching the OS name.
   * @param {string} [label] A label for the OS.
   */
  function cleanupOS(os, pattern, label) {
    // platform tokens defined at
    // http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    // http://web.archive.org/web/20081122053950/http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    var data = {
      '6.4':  '10',
      '6.3':  '8.1',
      '6.2':  '8',
      '6.1':  'Server 2008 R2 / 7',
      '6.0':  'Server 2008 / Vista',
      '5.2':  'Server 2003 / XP 64-bit',
      '5.1':  'XP',
      '5.01': '2000 SP1',
      '5.0':  '2000',
      '4.0':  'NT',
      '4.90': 'ME'
    };
    // detect Windows version from platform tokens
    if (pattern && label && /^Win/i.test(os) &&
        (data = data[0/*Opera 9.25 fix*/, /[\d.]+$/.exec(os)])) {
      os = 'Windows ' + data;
    }
    // correct character case and cleanup
    os = String(os);

    if (pattern && label) {
      os = os.replace(RegExp(pattern, 'i'), label);
    }

    os = format(
      os.replace(/ ce$/i, ' CE')
        .replace(/\bhpw/i, 'web')
        .replace(/\bMacintosh\b/, 'Mac OS')
        .replace(/_PowerPC\b/i, ' OS')
        .replace(/\b(OS X) [^ \d]+/i, '$1')
        .replace(/\bMac (OS X)\b/, '$1')
        .replace(/\/(\d)/, ' $1')
        .replace(/_/g, '.')
        .replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, '')
        .replace(/\bx86\.64\b/gi, 'x86_64')
        .replace(/\b(Windows Phone) OS\b/, '$1')
        .split(' on ')[0]
    );

    return os;
  }

  /**
   * An iteration utility for arrays and objects.
   *
   * @private
   * @param {Array|Object} object The object to iterate over.
   * @param {Function} callback The function called per iteration.
   */
  function each(object, callback) {
    var index = -1,
        length = object ? object.length : 0;

    if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {
      while (++index < length) {
        callback(object[index], index, object);
      }
    } else {
      forOwn(object, callback);
    }
  }

  /**
   * Trim and conditionally capitalize string values.
   *
   * @private
   * @param {string} string The string to format.
   * @returns {string} The formatted string.
   */
  function format(string) {
    string = trim(string);
    return /^(?:webOS|i(?:OS|P))/.test(string)
      ? string
      : capitalize(string);
  }

  /**
   * Iterates over an object's own properties, executing the `callback` for each.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} callback The function executed per own property.
   */
  function forOwn(object, callback) {
    for (var key in object) {
      if (hasOwnProperty.call(object, key)) {
        callback(object[key], key, object);
      }
    }
  }

  /**
   * Gets the internal `[[Class]]` of a value.
   *
   * @private
   * @param {*} value The value.
   * @returns {string} The `[[Class]]`.
   */
  function getClassOf(value) {
    return value == null
      ? capitalize(value)
      : toString.call(value).slice(8, -1);
  }

  /**
   * Host objects can return type values that are different from their actual
   * data type. The objects we are concerned with usually return non-primitive
   * types of "object", "function", or "unknown".
   *
   * @private
   * @param {*} object The owner of the property.
   * @param {string} property The property to check.
   * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.
   */
  function isHostType(object, property) {
    var type = object != null ? typeof object[property] : 'number';
    return !/^(?:boolean|number|string|undefined)$/.test(type) &&
      (type == 'object' ? !!object[property] : true);
  }

  /**
   * Prepares a string for use in a `RegExp` by making hyphens and spaces optional.
   *
   * @private
   * @param {string} string The string to qualify.
   * @returns {string} The qualified string.
   */
  function qualify(string) {
    return String(string).replace(/([ -])(?!$)/g, '$1?');
  }

  /**
   * A bare-bones `Array#reduce` like utility function.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function called per iteration.
   * @returns {*} The accumulated result.
   */
  function reduce(array, callback) {
    var accumulator = null;
    each(array, function(value, index) {
      accumulator = callback(accumulator, value, index, array);
    });
    return accumulator;
  }

  /**
   * Removes leading and trailing whitespace from a string.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} The trimmed string.
   */
  function trim(string) {
    return String(string).replace(/^ +| +$/g, '');
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a new platform object.
   *
   * @memberOf platform
   * @param {Object|string} [ua=navigator.userAgent] The user agent string or
   *  context object.
   * @returns {Object} A platform object.
   */
  function parse(ua) {

    /** The environment context object */
    var context = root;

    /** Used to flag when a custom context is provided */
    var isCustomContext = ua && typeof ua == 'object' && getClassOf(ua) != 'String';

    // juggle arguments
    if (isCustomContext) {
      context = ua;
      ua = null;
    }

    /** Browser navigator object */
    var nav = context.navigator || {};

    /** Browser user agent string */
    var userAgent = nav.userAgent || '';

    ua || (ua = userAgent);

    /** Used to flag when `thisBinding` is the [ModuleScope] */
    var isModuleScope = isCustomContext || thisBinding == oldRoot;

    /** Used to detect if browser is like Chrome */
    var likeChrome = isCustomContext
      ? !!nav.likeChrome
      : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());

    /** Internal `[[Class]]` value shortcuts */
    var objectClass = 'Object',
        airRuntimeClass = isCustomContext ? objectClass : 'ScriptBridgingProxyObject',
        enviroClass = isCustomContext ? objectClass : 'Environment',
        javaClass = (isCustomContext && context.java) ? 'JavaPackage' : getClassOf(context.java),
        phantomClass = isCustomContext ? objectClass : 'RuntimeObject';

    /** Detect Java environment */
    var java = /\bJava/.test(javaClass) && context.java;

    /** Detect Rhino */
    var rhino = java && getClassOf(context.environment) == enviroClass;

    /** A character to represent alpha */
    var alpha = java ? 'a' : '\u03b1';

    /** A character to represent beta */
    var beta = java ? 'b' : '\u03b2';

    /** Browser document object */
    var doc = context.document || {};

    /**
     * Detect Opera browser (Presto-based)
     * http://www.howtocreate.co.uk/operaStuff/operaObject.html
     * http://dev.opera.com/articles/view/opera-mini-web-content-authoring-guidelines/#operamini
     */
    var opera = context.operamini || context.opera;

    /** Opera `[[Class]]` */
    var operaClass = reOpera.test(operaClass = (isCustomContext && opera) ? opera['[[Class]]'] : getClassOf(opera))
      ? operaClass
      : (opera = null);

    /*------------------------------------------------------------------------*/

    /** Temporary variable used over the script's lifetime */
    var data;

    /** The CPU architecture */
    var arch = ua;

    /** Platform description array */
    var description = [];

    /** Platform alpha/beta indicator */
    var prerelease = null;

    /** A flag to indicate that environment features should be used to resolve the platform */
    var useFeatures = ua == userAgent;

    /** The browser/environment version */
    var version = useFeatures && opera && typeof opera.version == 'function' && opera.version();

    /** A flag to indicate if the OS ends with "/ Version" */
    var isSpecialCasedOS;

    /* Detectable layout engines (order is important) */
    var layout = getLayout([
      'Trident',
      { 'label': 'WebKit', 'pattern': 'AppleWebKit' },
      'iCab',
      'Presto',
      'NetFront',
      'Tasman',
      'KHTML',
      'Gecko'
    ]);

    /* Detectable browser names (order is important) */
    var name = getName([
      'Adobe AIR',
      'Arora',
      'Avant Browser',
      'Breach',
      'Camino',
      'Epiphany',
      'Fennec',
      'Flock',
      'Galeon',
      'GreenBrowser',
      'iCab',
      'Iceweasel',
      { 'label': 'SRWare Iron', 'pattern': 'Iron' },
      'K-Meleon',
      'Konqueror',
      'Lunascape',
      'Maxthon',
      'Midori',
      'Nook Browser',
      'PhantomJS',
      'Raven',
      'Rekonq',
      'RockMelt',
      'SeaMonkey',
      { 'label': 'Silk', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
      'Sleipnir',
      'SlimBrowser',
      'Sunrise',
      'Swiftfox',
      'WebPositive',
      'Opera Mini',
      { 'label': 'Opera Mini', 'pattern': 'OPiOS' },
      'Opera',
      { 'label': 'Opera', 'pattern': 'OPR' },
      'Chrome',
      { 'label': 'Chrome Mobile', 'pattern': '(?:CriOS|CrMo)' },
      { 'label': 'Firefox', 'pattern': '(?:Firefox|Minefield)' },
      { 'label': 'IE', 'pattern': 'IEMobile' },
      { 'label': 'IE', 'pattern': 'MSIE' },
      'Safari'
    ]);

    /* Detectable products (order is important) */
    var product = getProduct([
      { 'label': 'BlackBerry', 'pattern': 'BB10' },
      'BlackBerry',
      { 'label': 'Galaxy S', 'pattern': 'GT-I9000' },
      { 'label': 'Galaxy S2', 'pattern': 'GT-I9100' },
      { 'label': 'Galaxy S3', 'pattern': 'GT-I9300' },
      { 'label': 'Galaxy S4', 'pattern': 'GT-I9500' },
      'Google TV',
      'Lumia',
      'iPad',
      'iPod',
      'iPhone',
      'Kindle',
      { 'label': 'Kindle Fire', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
      'Nook',
      'PlayBook',
      'PlayStation 4',
      'PlayStation 3',
      'PlayStation Vita',
      'TouchPad',
      'Transformer',
      { 'label': 'Wii U', 'pattern': 'WiiU' },
      'Wii',
      'Xbox One',
      { 'label': 'Xbox 360', 'pattern': 'Xbox' },
      'Xoom'
    ]);

    /* Detectable manufacturers */
    var manufacturer = getManufacturer({
      'Apple': { 'iPad': 1, 'iPhone': 1, 'iPod': 1 },
      'Amazon': { 'Kindle': 1, 'Kindle Fire': 1 },
      'Asus': { 'Transformer': 1 },
      'Barnes & Noble': { 'Nook': 1 },
      'BlackBerry': { 'PlayBook': 1 },
      'Google': { 'Google TV': 1 },
      'HP': { 'TouchPad': 1 },
      'HTC': {},
      'LG': {},
      'Microsoft': { 'Xbox': 1, 'Xbox One': 1 },
      'Motorola': { 'Xoom': 1 },
      'Nintendo': { 'Wii U': 1,  'Wii': 1 },
      'Nokia': { 'Lumia': 1 },
      'Samsung': { 'Galaxy S': 1, 'Galaxy S2': 1, 'Galaxy S3': 1, 'Galaxy S4': 1 },
      'Sony': { 'PlayStation 4': 1, 'PlayStation 3': 1, 'PlayStation Vita': 1 }
    });

    /* Detectable OSes (order is important) */
    var os = getOS([
      'Windows Phone ',
      'Android',
      'CentOS',
      'Debian',
      'Fedora',
      'FreeBSD',
      'Gentoo',
      'Haiku',
      'Kubuntu',
      'Linux Mint',
      'Red Hat',
      'SuSE',
      'Ubuntu',
      'Xubuntu',
      'Cygwin',
      'Symbian OS',
      'hpwOS',
      'webOS ',
      'webOS',
      'Tablet OS',
      'Linux',
      'Mac OS X',
      'Macintosh',
      'Mac',
      'Windows 98;',
      'Windows '
    ]);

    /*------------------------------------------------------------------------*/

    /**
     * Picks the layout engine from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected layout engine.
     */
    function getLayout(guesses) {
      return reduce(guesses, function(result, guess) {
        return result || RegExp('\\b' + (
          guess.pattern || qualify(guess)
        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the manufacturer from an array of guesses.
     *
     * @private
     * @param {Array} guesses An object of guesses.
     * @returns {null|string} The detected manufacturer.
     */
    function getManufacturer(guesses) {
      return reduce(guesses, function(result, value, key) {
        // lookup the manufacturer by product or scan the UA for the manufacturer
        return result || (
          value[product] ||
          value[0/*Opera 9.25 fix*/, /^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] ||
          RegExp('\\b' + qualify(key) + '(?:\\b|\\w*\\d)', 'i').exec(ua)
        ) && key;
      });
    }

    /**
     * Picks the browser name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected browser name.
     */
    function getName(guesses) {
      return reduce(guesses, function(result, guess) {
        return result || RegExp('\\b' + (
          guess.pattern || qualify(guess)
        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the OS name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected OS name.
     */
    function getOS(guesses) {
      return reduce(guesses, function(result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result =
              RegExp('\\b' + pattern + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua)
            )) {
          result = cleanupOS(result, pattern, guess.label || guess);
        }
        return result;
      });
    }

    /**
     * Picks the product name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected product name.
     */
    function getProduct(guesses) {
      return reduce(guesses, function(result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result =
              RegExp('\\b' + pattern + ' *\\d+[.\\w_]*', 'i').exec(ua) ||
              RegExp('\\b' + pattern + '(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)', 'i').exec(ua)
            )) {
          // split by forward slash and append product version if needed
          if ((result = String((guess.label && !RegExp(pattern, 'i').test(guess.label)) ? guess.label : result).split('/'))[1] && !/[\d.]+/.test(result[0])) {
            result[0] += ' ' + result[1];
          }
          // correct character case and cleanup
          guess = guess.label || guess;
          result = format(result[0]
            .replace(RegExp(pattern, 'i'), guess)
            .replace(RegExp('; *(?:' + guess + '[_-])?', 'i'), ' ')
            .replace(RegExp('(' + guess + ')[-_.]?(\\w)', 'i'), '$1 $2'));
        }
        return result;
      });
    }

    /**
     * Resolves the version using an array of UA patterns.
     *
     * @private
     * @param {Array} patterns An array of UA patterns.
     * @returns {null|string} The detected version.
     */
    function getVersion(patterns) {
      return reduce(patterns, function(result, pattern) {
        return result || (RegExp(pattern +
          '(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)', 'i').exec(ua) || 0)[1] || null;
      });
    }

    /**
     * Returns `platform.description` when the platform object is coerced to a string.
     *
     * @name toString
     * @memberOf platform
     * @returns {string} Returns `platform.description` if available, else an empty string.
     */
    function toStringPlatform() {
      return this.description || '';
    }

    /*------------------------------------------------------------------------*/

    // convert layout to an array so we can add extra details
    layout && (layout = [layout]);

    // detect product names that contain their manufacturer's name
    if (manufacturer && !product) {
      product = getProduct([manufacturer]);
    }
    // clean up Google TV
    if ((data = /\bGoogle TV\b/.exec(product))) {
      product = data[0];
    }
    // detect simulators
    if (/\bSimulator\b/i.test(ua)) {
      product = (product ? product + ' ' : '') + 'Simulator';
    }
    // detect Opera Mini 8+ running in Turbo/Uncompressed mode on iOS
    if (name == 'Opera Mini' && /\bOPiOS\b/.test(ua)) {
      description.push('running in Turbo/Uncompressed mode');
    }
    // detect iOS
    if (/^iP/.test(product)) {
      name || (name = 'Safari');
      os = 'iOS' + ((data = / OS ([\d_]+)/i.exec(ua))
        ? ' ' + data[1].replace(/_/g, '.')
        : '');
    }
    // detect Kubuntu
    else if (name == 'Konqueror' && !/buntu/i.test(os)) {
      os = 'Kubuntu';
    }
    // detect Android browsers
    else if (manufacturer && manufacturer != 'Google' &&
        ((/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua)) || /\bVita\b/.test(product))) {
      name = 'Android Browser';
      os = /\bAndroid\b/.test(os) ? os : 'Android';
    }
    // detect false positives for Firefox/Safari
    else if (!name || (data = !/\bMinefield\b|\(Android;/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
      // escape the `/` for Firefox 1
      if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + '/') + 8))) {
        // clear name of false positives
        name = null;
      }
      // reassign a generic name
      if ((data = product || manufacturer || os) &&
          (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
        name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + ' Browser';
      }
    }
    // detect Firefox OS
    if ((data = /\((Mobile|Tablet).*?Firefox\b/i.exec(ua)) && data[1]) {
      os = 'Firefox OS';
      if (!product) {
        product = data[1];
      }
    }
    // detect non-Opera versions (order is important)
    if (!version) {
      version = getVersion([
        '(?:Cloud9|CriOS|CrMo|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|Silk(?!/[\\d.]+$))',
        'Version',
        qualify(name),
        '(?:Firefox|Minefield|NetFront)'
      ]);
    }
    // detect stubborn layout engines
    if (layout == 'iCab' && parseFloat(version) > 3) {
      layout = ['WebKit'];
    } else if (
        layout != 'Trident' &&
        (data =
          /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? 'Blink' : 'Presto') ||
          /\b(?:Midori|Nook|Safari)\b/i.test(ua) && 'WebKit' ||
          !layout && /\bMSIE\b/i.test(ua) && (os == 'Mac OS' ? 'Tasman' : 'Trident')
        )
    ) {
      layout = [data];
    }
    // detect NetFront on PlayStation
    else if (/\bPlayStation\b(?! Vita\b)/i.test(name) && layout == 'WebKit') {
      layout = ['NetFront'];
    }
    // detect Windows Phone 7 desktop mode
    if (name == 'IE' && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
      name += ' Mobile';
      os = 'Windows Phone ' + (/\+$/.test(data) ? data : data + '.x');
      description.unshift('desktop mode');
    }
    // detect Windows Phone 8+ desktop mode
    else if (/\bWPDesktop\b/i.test(ua)) {
      name = 'IE Mobile';
      os = 'Windows Phone 8+';
      description.unshift('desktop mode');
      version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
    }
    // detect IE 11 and above
    else if (name != 'IE' && layout == 'Trident' && (data = /\brv:([\d.]+)/.exec(ua))) {
      if (!/\bWPDesktop\b/i.test(ua)) {
        if (name) {
          description.push('identifying as ' + name + (version ? ' ' + version : ''));
        }
        name = 'IE';
      }
      version = data[1];
    }
    // detect Microsoft Edge
    else if ((name == 'Chrome' || name != 'IE') && (data = /\bEdge\/([\d.]+)/.exec(ua))) {
      name = 'Microsoft Edge';
      version = data[1];
      layout = ['Trident'];
    }
    // leverage environment features
    if (useFeatures) {
      // detect server-side environments
      // Rhino has a global function while others have a global object
      if (isHostType(context, 'global')) {
        if (java) {
          data = java.lang.System;
          arch = data.getProperty('os.arch');
          os = os || data.getProperty('os.name') + ' ' + data.getProperty('os.version');
        }
        if (isModuleScope && isHostType(context, 'system') && (data = [context.system])[0]) {
          os || (os = data[0].os || null);
          try {
            data[1] = context.require('ringo/engine').version;
            version = data[1].join('.');
            name = 'RingoJS';
          } catch(e) {
            if (data[0].global.system == context.system) {
              name = 'Narwhal';
            }
          }
        }
        else if (typeof context.process == 'object' && (data = context.process)) {
          name = 'Node.js';
          arch = data.arch;
          os = data.platform;
          version = /[\d.]+/.exec(data.version)[0];
        }
        else if (rhino) {
          name = 'Rhino';
        }
      }
      // detect Adobe AIR
      else if (getClassOf((data = context.runtime)) == airRuntimeClass) {
        name = 'Adobe AIR';
        os = data.flash.system.Capabilities.os;
      }
      // detect PhantomJS
      else if (getClassOf((data = context.phantom)) == phantomClass) {
        name = 'PhantomJS';
        version = (data = data.version || null) && (data.major + '.' + data.minor + '.' + data.patch);
      }
      // detect IE compatibility modes
      else if (typeof doc.documentMode == 'number' && (data = /\bTrident\/(\d+)/i.exec(ua))) {
        // we're in compatibility mode when the Trident version + 4 doesn't
        // equal the document mode
        version = [version, doc.documentMode];
        if ((data = +data[1] + 4) != version[1]) {
          description.push('IE ' + version[1] + ' mode');
          layout && (layout[1] = '');
          version[1] = data;
        }
        version = name == 'IE' ? String(version[1].toFixed(1)) : version[0];
      }
      os = os && format(os);
    }
    // detect prerelease phases
    if (version && (data =
          /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) ||
          /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ';' + (useFeatures && nav.appMinorVersion)) ||
          /\bMinefield\b/i.test(ua) && 'a'
        )) {
      prerelease = /b/i.test(data) ? 'beta' : 'alpha';
      version = version.replace(RegExp(data + '\\+?$'), '') +
        (prerelease == 'beta' ? beta : alpha) + (/\d+\+?/.exec(data) || '');
    }
    // detect Firefox Mobile
    if (name == 'Fennec' || name == 'Firefox' && /\b(?:Android|Firefox OS)\b/.test(os)) {
      name = 'Firefox Mobile';
    }
    // obscure Maxthon's unreliable version
    else if (name == 'Maxthon' && version) {
      version = version.replace(/\.[\d.]+/, '.x');
    }
    // detect Silk desktop/accelerated modes
    else if (name == 'Silk') {
      if (!/\bMobi/i.test(ua)) {
        os = 'Android';
        description.unshift('desktop mode');
      }
      if (/Accelerated *= *true/i.test(ua)) {
        description.unshift('accelerated');
      }
    }
    // detect Xbox 360 and Xbox One
    else if (/\bXbox\b/i.test(product)) {
      os = null;
      if (product == 'Xbox 360' && /\bIEMobile\b/.test(ua)) {
        description.unshift('mobile mode');
      }
    }
    // add mobile postfix
    else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) &&
        (os == 'Windows CE' || /Mobi/i.test(ua))) {
      name += ' Mobile';
    }
    // detect IE platform preview
    else if (name == 'IE' && useFeatures && context.external === null) {
      description.unshift('platform preview');
    }
    // detect BlackBerry OS version
    // http://docs.blackberry.com/en/developers/deliverables/18169/HTTP_headers_sent_by_BB_Browser_1234911_11.jsp
    else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data =
          (RegExp(product.replace(/ +/g, ' *') + '/([.\\d]+)', 'i').exec(ua) || 0)[1] ||
          version
        )) {
      data = [data, /BB10/.test(ua)];
      os = (data[1] ? (product = null, manufacturer = 'BlackBerry') : 'Device Software') + ' ' + data[0];
      version = null;
    }
    // detect Opera identifying/masking itself as another browser
    // http://www.opera.com/support/kb/view/843/
    else if (this != forOwn && (
          product != 'Wii' && (
            (useFeatures && opera) ||
            (/Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua)) ||
            (name == 'Firefox' && /\bOS X (?:\d+\.){2,}/.test(os)) ||
            (name == 'IE' && (
              (os && !/^Win/.test(os) && version > 5.5) ||
              /\bWindows XP\b/.test(os) && version > 8 ||
              version == 8 && !/\bTrident\b/.test(ua)
            ))
          )
        ) && !reOpera.test((data = parse.call(forOwn, ua.replace(reOpera, '') + ';'))) && data.name) {

      // when "indentifying", the UA contains both Opera and the other browser's name
      data = 'ing as ' + data.name + ((data = data.version) ? ' ' + data : '');
      if (reOpera.test(name)) {
        if (/\bIE\b/.test(data) && os == 'Mac OS') {
          os = null;
        }
        data = 'identify' + data;
      }
      // when "masking", the UA contains only the other browser's name
      else {
        data = 'mask' + data;
        if (operaClass) {
          name = format(operaClass.replace(/([a-z])([A-Z])/g, '$1 $2'));
        } else {
          name = 'Opera';
        }
        if (/\bIE\b/.test(data)) {
          os = null;
        }
        if (!useFeatures) {
          version = null;
        }
      }
      layout = ['Presto'];
      description.push(data);
    }
    // detect WebKit Nightly and approximate Chrome/Safari versions
    if ((data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
      // correct build for numeric comparison
      // (e.g. "532.5" becomes "532.05")
      data = [parseFloat(data.replace(/\.(\d)$/, '.0$1')), data];
      // nightly builds are postfixed with a `+`
      if (name == 'Safari' && data[1].slice(-1) == '+') {
        name = 'WebKit Nightly';
        prerelease = 'alpha';
        version = data[1].slice(0, -1);
      }
      // clear incorrect browser versions
      else if (version == data[1] ||
          version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
        version = null;
      }
      // use the full Chrome version when available
      data[1] = (/\bChrome\/([\d.]+)/i.exec(ua) || 0)[1];
      // detect Blink layout engine
      if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && name != 'IE' && name != 'Microsoft Edge') {
        layout = ['Blink'];
      }
      // detect JavaScriptCore
      // http://stackoverflow.com/questions/6768474/how-can-i-detect-which-javascript-engine-v8-or-jsc-is-used-at-runtime-in-androi
      if (!useFeatures || (!likeChrome && !data[1])) {
        layout && (layout[1] = 'like Safari');
        data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? '4+' : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : '8');
      } else {
        layout && (layout[1] = 'like Chrome');
        data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.10 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.30 ? 11 : data < 535.01 ? 12 : data < 535.02 ? '13+' : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.10 ? 19 : data < 537.01 ? 20 : data < 537.11 ? '21+' : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != 'Blink' ? '27' : '28');
      }
      // add the postfix of ".x" or "+" for approximate versions
      layout && (layout[1] += ' ' + (data += typeof data == 'number' ? '.x' : /[.+]/.test(data) ? '' : '+'));
      // obscure version for some Safari 1-2 releases
      if (name == 'Safari' && (!version || parseInt(version) > 45)) {
        version = data;
      }
    }
    // detect Opera desktop modes
    if (name == 'Opera' &&  (data = /\bzbov|zvav$/.exec(os))) {
      name += ' ';
      description.unshift('desktop mode');
      if (data == 'zvav') {
        name += 'Mini';
        version = null;
      } else {
        name += 'Mobile';
      }
      os = os.replace(RegExp(' *' + data + '$'), '');
    }
    // detect Chrome desktop mode
    else if (name == 'Safari' && /\bChrome\b/.exec(layout && layout[1])) {
      description.unshift('desktop mode');
      name = 'Chrome Mobile';
      version = null;

      if (/\bOS X\b/.test(os)) {
        manufacturer = 'Apple';
        os = 'iOS 4.3+';
      } else {
        os = null;
      }
    }
    // strip incorrect OS versions
    if (version && version.indexOf((data = /[\d.]+$/.exec(os))) == 0 &&
        ua.indexOf('/' + data + '-') > -1) {
      os = trim(os.replace(data, ''));
    }
    // add layout engine
    if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (
        /Browser|Lunascape|Maxthon/.test(name) ||
        /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Sleipnir|Web)/.test(name) && layout[1])) {
      // don't add layout details to description if they are falsey
      (data = layout[layout.length - 1]) && description.push(data);
    }
    // combine contextual information
    if (description.length) {
      description = ['(' + description.join('; ') + ')'];
    }
    // append manufacturer
    if (manufacturer && product && product.indexOf(manufacturer) < 0) {
      description.push('on ' + manufacturer);
    }
    // append product
    if (product) {
      description.push((/^on /.test(description[description.length -1]) ? '' : 'on ') + product);
    }
    // parse OS into an object
    if (os) {
      data = / ([\d.+]+)$/.exec(os);
      isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == '/';
      os = {
        'architecture': 32,
        'family': (data && !isSpecialCasedOS) ? os.replace(data[0], '') : os,
        'version': data ? data[1] : null,
        'toString': function() {
          var version = this.version;
          return this.family + ((version && !isSpecialCasedOS) ? ' ' + version : '') + (this.architecture == 64 ? ' 64-bit' : '');
        }
      };
    }
    // add browser/OS architecture
    if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
      if (os) {
        os.architecture = 64;
        os.family = os.family.replace(RegExp(' *' + data), '');
      }
      if (
          name && (/\bWOW64\b/i.test(ua) ||
          (useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua)))
      ) {
        description.unshift('32-bit');
      }
    }

    ua || (ua = null);

    /*------------------------------------------------------------------------*/

    /**
     * The platform object.
     *
     * @name platform
     * @type Object
     */
    var platform = {};

    /**
     * The platform description.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.description = ua;

    /**
     * The name of the browser's layout engine.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.layout = layout && layout[0];

    /**
     * The name of the product's manufacturer.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.manufacturer = manufacturer;

    /**
     * The name of the browser/environment.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.name = name;

    /**
     * The alpha/beta release indicator.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.prerelease = prerelease;

    /**
     * The name of the product hosting the browser.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.product = product;

    /**
     * The browser's user agent string.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.ua = ua;

    /**
     * The browser/environment version.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.version = name && version;

    /**
     * The name of the operating system.
     *
     * @memberOf platform
     * @type Object
     */
    platform.os = os || {

      /**
       * The CPU architecture the OS is built for.
       *
       * @memberOf platform.os
       * @type number|null
       */
      'architecture': null,

      /**
       * The family of the OS.
       *
       * Common values include:
       * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
       * "Windows XP", "OS X", "Ubuntu", "Debian", "Fedora", "Red Hat", "SuSE",
       * "Android", "iOS" and "Windows Phone"
       *
       * @memberOf platform.os
       * @type string|null
       */
      'family': null,

      /**
       * The version of the OS.
       *
       * @memberOf platform.os
       * @type string|null
       */
      'version': null,

      /**
       * Returns the OS string.
       *
       * @memberOf platform.os
       * @returns {string} The OS string.
       */
      'toString': function() { return 'null'; }
    };

    platform.parse = parse;
    platform.toString = toStringPlatform;

    if (platform.version) {
      description.unshift(version);
    }
    if (platform.name) {
      description.unshift(name);
    }
    if (os && name && !(os == String(os).split(' ')[0] && (os == name.split(' ')[0] || product))) {
      description.push(product ? '(' + os + ')' : 'on ' + os);
    }
    if (description.length) {
      platform.description = description.join(' ');
    }
    return platform;
  }

  /*--------------------------------------------------------------------------*/

  // export platform
  // some AMD build optimizers, like r.js, check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // define as an anonymous module so, through path mapping, it can be aliased
    define('syracuse-tablet/html/deps/platform/platform',[],function() {
      return parse();
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Narwhal, Node.js, Rhino -require, or RingoJS
    forOwn(parse(), function(value, key) {
      freeExports[key] = value;
    });
  }
  // in a browser or Rhino
  else {
    root.platform = parse();
  }
}.call(this));

define('syracuse-tablet/html/js/helpers/native/nativeExtCall',['require','exports','module','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {

/*
 * This module is called JS to call methods in an by an external wrapper
 */

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeExtCall", false);

var _isPromise = function(o) {
	return o != null && typeof o === "object" && typeof o.then === "function" && typeof o.fail === "function";
};

var _testMode = false;

/**
 * True is application runs inside a wrapper native or Javascript
 */
exports.isNativeModeEnabled = function() {
	return (window && window.smNativeInterface) || _testMode === true;
};

/**
 * Returns a promise
 * 	Resolves with the DB (indexedDB or webSQL or null)
 *  	null means regular process (we ask the browser)
 *  	indexedDB:webSQL forces the use of the given db
 * 			Safari in IOS wrapper doesn't support webSQL while Safari out side the wrapper does
 */
exports.getSupportedDB = function() {
	if (window && window.smNativeInterface && window.smNativeInterface.getSupportedDB) {
		return window.smNativeInterface.getSupportedDB();
	}
	// TODO - Null means we use the regular process
	return $.smResolve(null);
};

exports.appStartsRunning = function() {
	if (window && window.smNativeInterface && window.smNativeInterface.appStartsRunning) {
		// Notifies wrapper once the main.js starts to run
		window.smNativeInterface.appStartsRunning();
	}
};
/**
 * Call a native method if it is available.
 * Will return true if method is available and method call returns true
 * Otherwise returns false
 */
exports.isSupported = function(domain, method) {
	var sup = false;

	domain = domain || "";
	method = method || "";

	var caller = window && window.smNativeInterface && window.smNativeInterface.isSupported;
	if (caller && !_testMode) {
		// Do not change to caller.isSupported it will not work!!!;
		sup = window.smNativeInterface.isSupported(domain, method);
	} else if (_testMode) {
		// Arguments here should be 100% equal to the ones used for window.smNativeInterface.isSupported
		// to allow exact validation
		sup = _isSupportedTest(domain, method);
	} else {
		log && log("Native: isSupported no such interface - " + domain + ", " + method + ")");
	}
	return _isPromise(sup) ? sup : $.smResolve(sup);
};

/**
 * Parse returned value if it's a JSON
 */
var _checkReturnedValue = function(ret) {
		log && log("--> Result callMethod =" + (ret || "").substr(0, 100));
		if (ret == null || typeof ret != "string") {
			return null;
		}
		var trimed = ret.trim();
		if (trimed.length > 2) {
			var charFirst = trimed.charAt(0);
			var charLast = trimed.charAt(trimed.length - 1);
			if ((charFirst == "{" && charLast == "}") || (charFirst == "[" && charLast == "]")) {
				try {
					ret = JSON.parse(trimed);
				} catch (e) {}
			}
		}
		return ret;
	}
	/**
	 * Call a native method and receive a return value
	 */
exports.callMethod = function(domain, method, data) {
	var ret = null;

	var param = data;
	if (param != null && typeof param !== "string") {
		param = JSON.stringify(param);
	}
	domain = domain || "";
	method = method || "";
	param = param || "";

	log && log("Native: callMethod (" + domain + ", " + method + "): " + param);
	var caller = window && window.smNativeInterface && window.smNativeInterface.callMethod;
	if (caller && !_testMode) {
		// Do not change to caller.callMethod it will not work!!!
		ret = window.smNativeInterface.callMethod(domain, method, param);
	} else if (_testMode) {
		// Arguments here should be 100% equal to the ones used for window.smNativeInterface.callMethod
		// to allow exact validation
		ret = _callMethodTest(domain, method, param);
	} else {
		log && log("Native: callMethod no such interface");
	}
	if (_isPromise(ret)) {
		return ret.then(function(result) {
			return _checkReturnedValue(result);
		});
	} else {
		return $.smResolve(_checkReturnedValue(ret));
	}
};

/**
 * Call a native method (fire and forget with no return value)
 */
exports.fireMethod = function(domain, method, data) {
	var param = data;
	if (param != null && typeof param !== "string") {
		param = JSON.stringify(param);
	}
	domain = domain || "";
	method = method || "";
	param = param || "";

	log && log("Native: fireMethod (" + domain + ", " + method + "): " + param);
	var caller = window && window.smNativeInterface && window.smNativeInterface.fireMethod;
	if (caller && !_testMode) {
		// Do not change to caller.fireMethod it will not work!!!
		window.smNativeInterface.fireMethod(domain, method, param);
	} else if (_testMode) {
		// Arguments here should be 100% equal to the ones used for window.smNativeInterface.fireMethod
		// to allow exact validation
		_fireMethodTest(domain, method, param);
	} else {
		log && log("Native: fireMethod no such interface");
	}
};

function _isSupportedTest(domain, method) {
	var obj = window[domain];
	var caller = obj && obj[method];
	if (!caller) {
		log && log("_isSupportedTest: No such method: window." + domain + "." + method);
		return false;
	}
	var sup = caller.call(obj);
	return sup;
}

/**
 *
 */
function _callMethodTest(domain, method, param) {
	var obj = window[domain];
	var caller = obj && obj[method];
	if (!caller) {
		log && log("_callMethodTest: No such method: window." + domain + "." + method);
		return null;
	}
	var ret = caller.call(obj, param);
	return ret;

}

/**
 *
 */
function _fireMethodTest(domain, method, param) {
	var obj = window[domain];
	var caller = obj && obj[method];
	if (!caller) {
		log && log("_fireMethodTest: No such method: window." + domain + "." + method);
		return null;
	}
	caller.call(obj, param);
}

exports.init = function(testMode) {
	_testMode = testMode === true;
};
});

define('syracuse-tablet/html/js/helpers/native/nativeJSCall',['require','exports','module','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {

/*
 * This module is called by an external wrapper and maps the calls to javascript methods
 */

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeJSCall", false);

exports.init = function() {

	if (!(window.smJSCall)) {
		/*
		 * This method is the only one that will ever be invoked by wrapper code
		 * It dispatches all incomming calls to dedicated objects per domain
		 */
		window.smJSCall = function(objectName, methodName, jsonParam) {
			try {
				log && log("smJSCall (objectName): " + objectName);
				log && log("smJSCall (methodName): " + methodName);
				var traceParam
				if (jsonParam == null || $.isPlainObject(jsonParam)) {
					// Nothing - JSON or null accepted as parameter
					traceParam = JSON.stringify(jsonParam, null, 2)
				} else if (typeof jsonParam === "string") {
					try { // try to parse json, if it fails, data is assumed to be a plain string
						jsonParam = JSON.parse(jsonParam);
						traceParam = JSON.stringify(jsonParam, null, 2)
					} catch (e) {
						// plain string
						traceParam = jsonParam
					}
				} else {
					// We assume it's a string
					traceParam = jsonParam = new String(jsonParam)
				}
				log && log("smJSCall (jsonParam): " + (traceParam || "").substr(0, 100));
				var obj = window[objectName];
				if (obj == null) {
					log && log("JS Object not found[" + objectName + "] - Can't call method " + methodName);
					return
				}
				var method = obj && obj[methodName];
				var ret = method && method.call(obj, jsonParam);

				// Only strings supported right now!
				if (typeof ret !== "string") {
					ret = "" + ret;
				}
				log && log("smJSCall (return): " + ret);
				return ret;
			} catch (ex) {
				log && log(JSON.stringify(ex));
				throw ex;
			}
		};
	}
};
});

define('syracuse-tablet/html/js/helpers/notifications',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("notifs");
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
/**
 * publish/subscribe - Observer/Observable pattern with jQuery
 * TODO - !!! Attach a _subscriptions to application and one per page
 * --> Switch the page _subscriptions with the page in order to not notify inactive pages (parent page)
 * Temporarily we check inactive in page notif methods
 *
 **/

var _nameSpace = "sm";
var _subscriptions = {};

/**
 * _callHandler outside _publish function to preserve args if call to multiple objects in the loop
 */
var _callCheck = function(object) {
	// Don't notify object that are not active (ex: cached pages)
	if (jsutils.isInstanceOf(object, "Page") && !object.isActive()) return false;
	if (jsutils.isInstanceOf(object, "StructElmt") && (object.controller == null || !object.controller.isActive())) return false;
	return true;
};
var _callHandler = function(callBack, object, args) {
	if (!_callCheck(object)) return;
	return setTimeout(function() {
		callBack.apply(object, args);
	}, 0);
};
var _callHandlerSynch = function(callBack, object, args) {
	if (!_callCheck(object)) return;
	callBack.apply(object, args);
};

/**
 *  publish an event ("sm.logged.in") or an array of events ["sm.logged.in"...]
 * 		Functional Object Subscribers
 * 			 notified through method notifEventname - object.notifLogin, object.notifLogout
 * 		Simple callBack Subscriber
 * 			called with event as first parameter
 * 	Argument that follow events parameter are passed to the Subscriber
 *  If event starts with 'synch.' all the callback will be called synchronously otherwise they will be called asynchronously (setTimeout)
 * */
var _publish = function(events) {
	if (!events) {
		throw new Error("No topic to publish");
	}
	var events = typeof events === "string" ? [events] : events;
	log && log("Publish " + events.join(" - "));
	var args, subscription, subscription, res;
	var count = 0,
		array;
	var objArgs, args = arguments,
		synch, callHandler;
	events.forEach(function(evt) {
		synch = evt.smStartsWith("synch.");
		if (synch) {
			evt = evt.split("synch.")[1];
			callHandler = _callHandlerSynch;
		} else {
			callHandler = _callHandler;
		}
		array = _subscriptions[evt];
		if (array) {
			array = array.slice();
			for (var i = 0, l = array.length; i < l; i++) {
				subscription = array[i];
				if (subscription.object) {
					if (!objArgs) objArgs = Array.prototype.slice.call(args, 1);
					// Remove first argument and call the method - setTimeout(0) for asynchronism and release call stack
					res = callHandler(subscription.callBack, subscription.object, objArgs);
				} else {
					// call the function with evt as first parameter - setTimeout(0) for asynchronism and release call stack
					args[0] = evt;
					res = callHandler(subscription.callBack, null, args);
				}
				count++;
				// TO SEE - -stop is res = false if ( res === false ) { break; }
			}
		} else {
			// No subscribers is not an error!
			// throw new Error("Unknown notification event " + evt);
		}
	});
};

/**
 *  Same as _publish with options
 *  TODO -> Merge both
 * */
var _publishEx = function(events, opts) {
	if (!events) {
		throw new Error("No topic to publish");
	}
	var events = typeof events === "string" ? [events] : events;
	log && log("Publish " + events.join(" - "));
	var args, subscription, subscription, res;
	var count = 0,
		array;
	var exclude = opts && opts.exclude || [];
	var objArgs, args = arguments;
	var synch, callHandler;
	events.forEach(function(evt) {
		synch = evt.smStartsWith("synch.");
		if (synch) {
			evt = evt.split("synch.")[1];
			callHandler = _callHandlerSynch;
		} else {
			callHandler = _callHandler;
		}
		array = _subscriptions[evt];
		if (array) {
			array = array.slice();
			for (var i = 0, l = array.length; i < l; i++) {
				subscription = array[i];
				if (subscription.object) {
					if ((!exclude || exclude.indexOf(subscription.object)) < 0) {
						if (!objArgs) objArgs = Array.prototype.slice.call(args, 2);
						// Remove first argument and call the method - setTimeout(0) for asynchronism and release call stack
						res = callHandler(subscription.callBack, subscription.object, objArgs);
					}
				} else {
					// call the function with evt as first parameter - setTimeout(0) for asynchronism and release call stack
					args[0] = evt;
					res = callHandler(subscription.callBack, null, args);
				}
				count++;
				// TO SEE - -stop is res = false if ( res === false ) { break; }
			}
		} else {
			// No subscribers is not an error!
			// throw new Error("Unknown notification event " + evt);
		}
	});
};


/**
 * object subscribes for events (string or array)
 * 		object can be an functional Object or a function
 * 		functional Object must implement a method notifEventName  sm.my.event -> Method notifMyEvent
 * Events starts with "sm"
 * High priority subscriptions are called first
 */
var _subscribe = function(object, events, priority) {
	if (!events) {
		throw new Error("Notification - No topic to publish");
	}
	if (!object) {
		throw new Error("Notification - Null object");
	}
	priority = priority || 10;
	var events = typeof events === "string" ? [events] : events;
	log && log("Subscribe " + events.join(" - ") + " - priority=" + priority);
	var objectArray, removeIdx;
	events.forEach(function(evt) {
		var callBackFct, callBackObj;
		if (typeof object == "function") {
			callBackFct = object;
			callBackObj = null;
		} else {
			callBackObj = object;
			var methodName = evt.split('.');
			if (methodName[0] != _nameSpace) throw new Error("Notification - Bad event domain name");
			methodName = $.camelCase("notif-" + methodName.splice(1).join('-'));
			callBackFct = object[methodName];
			if (!callBackFct) {
				throw new Error("Notification - Object must implement " + methodName);
			}
		}
		var added = false;
		objectArray = _subscriptions[evt];
		if (!objectArray) {
			objectArray = _subscriptions[evt] = [];
		} else {
			// check if object has already subscribed
			var removeIdx = -1;
			objectArray.some(function(o, idx) {
				if (o && (o.object === object || o.callBack === object)) {
					removeIdx = idx;
					return true;
				}
			});
			if (removeIdx >= 0) {
				objectArray.splice(removeIdx, 1);
			}
		}
		var subscriptionInfo = {
			callBack: callBackFct,
			object: callBackObj,
			priority: priority
		};
		for (var i = objectArray.length - 1; i >= 0; i--) {
			if (objectArray[i].priority <= priority) {
				objectArray.splice(i + 1, 0, subscriptionInfo);
				added = true;
				break;
			}
		}
		if (!added) {
			objectArray.unshift(subscriptionInfo);
		}
	});
};

/**
 * object unsubscribes for events
 *  object != null
 * 		Remove all object's subscription for given events
 * 		object can be an Object or a function
 *  object == null
 * 		Remove all subscription for given events
 *  events string or array
 * 		null -> unsubscribe for allevent
 */
var _unsubscribe = function(object, events) {
	if (!events) {
		events = Object.keys(_subscriptions);
	} else if (typeof events == "string") {
		events = [events];
	}

	var propToCheck = typeof object === "function" ? "callBack" : "object";
	events.forEach(function(evt) {
		var array = _subscriptions[evt];
		if (array) {
			var lg = array.length;
			for (var i = 0, l = lg; i < l; i++) {
				if (object == null || array[i][propToCheck] === object) {
					array.splice(i, 1);
					// Adjust counter and length for removed item
					i--;
					l--;
				}
			}
			if (false && lg != array.length) {
				console.log("_unsubscribe ", evt, object == null ? "all" : propToCheck, lg, array.length, _check().total);
			}
		}

	});
};

// Remove all subscription
var _reset = function(object, events) {
	log && log("Reset");
	// For tests
	_unsubscribe(null, null);
	// We could just do _subscriptions = {};
};

// the number of subscriptions per event (for object if != null)
var _check = function(object) {
	var res = {};
	res.total = 0;
	var propToCheck = typeof object === "function" ? "callBack" : "object";
	Object.keys(_subscriptions).forEach(function(key) {
		res.total += _subscriptions[key].length;
		if (object == null) {
			res[key] = _subscriptions[key].length;
		} else {
			res[key] = 0;
			var arr = _subscriptions[key];
			for (var i = 0, l = arr.length; i < l; i++) {
				if (arr[i][propToCheck] === object) res[key] = res[key] + 1;
			}
		}
	});
	return res;
};
exports.check = _check;
exports.reset = _reset;
exports.subscribe = _subscribe;
exports.unsubscribe = _unsubscribe;
exports.publish = _publish;
exports.publishEx = _publishEx;
});

define('syracuse-tablet/html/js/helpers/native/nativeShare',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/native/nativeExtCall','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeShare", false);
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');
var modules = require('syracuse-tablet/html/js/common/modules');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var _pendingUrl;
var _isReady = false;

var _ShareManager = function() {

	this._currentDeferred = null;

	/*
	 *  This method will be invoked from wrapper once the pen input has finished or failed
	 *  data:
	 *  {
	 *  	action: "ok" | "cancelled",
	 *  }
	 */
	this.shareFinished = function(data) {
		if (this._currentDeferred) {
			var def = this._currentDeferred;
			this._currentDeferred = null;
			log && log("Got share: " + JSON.stringify(data || {}));
			def.resolve(data);
		}
	}

	/*
	 * Called by wrapper when the app is activated by a link
	 * data:
	 * {
	 * 	Url: url (url containing all information to go back to a specific page, sent as url option by sharePageLink)
	 *  Title: Title of url (sent as title option by sharePageLink)
	 * }
	 */
	this.handleLink = function(data) {
		log && log("handleLink: " + JSON.stringify(data, null, 2));
		var url = data && data.Url;
		if (url) {
			_pendingUrl = url;
			_gotoUrl();
		}
	};
};
notifications.subscribe({
	notifNavigatedToPage: function(page) {
		var name = page && page.pageName;
		log && log("DeepLink: navigated to: " + name)
		if (name != null && name != "logout" && name != "login") {
			_isReady = true;
			_gotoUrl();
		}
	}
}, "sm.navigated.to.page");

function _gotoUrl() {
	if (!_isReady || !_pendingUrl) {
		return;
	}
	if (_pendingUrl) {
		var url = _pendingUrl;
		_pendingUrl = null;
		modules.get("navHelper").gotoUrl(url);
	}
}

// Global object to be called by native code on pencil events
if (!(window.smShareJS)) {
	window.smShareJS = new _ShareManager();
}
/**
 *
 */
exports.supports = function(capability) {
	if (capability === "share") {
		return nativeExtCall.isSupported("smShare", "sharePageLinkSupported");
	}
	return $.smResolve(false);
};

/**
 * options:
 * {	
      pageData: {
		title: "Customers" // title that will be shown when page is shared
		url: url that is embedded in sent message and will be passed to handleLink method once the user clicks on the message 
		
		--- optional for now:
		
		id:"..."
		sdataParameters:"..."
		endPoint: "x3.erp.SEEDAMBAS"
		htmlRoot: "http://pc101458:8124/syracuse-tablet/html"
		language: "en-US"
		name: "x3.erp.GX3APP.BPCUSTOMERM.$query"
		sDataUrl: "http://pc101458:8124/mobile1/x3/erp/GX3APP/BPCUSTOMER?representation=BPCUSTOMERM.$query",
		
		DeepLink: {
			Title,
			Url,
		}
	  }
 * }
 */
exports.sharePageLink = function(options) {
	// DeepLink.Url must contain all information required to allow the webapp to navigate back to the current page including it's
	// eventual state (like filters)
	// DeepLink data structure will be shared by other similar functions
	// DeepLink: {
	//		Title: 
	//		Url: 
	//	}

	var param = {
		Title: options.pageData.Title,
		Description: options.pageData.Description,
		DeepLink: options.pageData.DeepLink
	};

	var data = JSON.stringify(param);
	_ShareManager._currentDeferred = $.Deferred();
	nativeExtCall.fireMethod("smShare", "sharePageLink", data);
	return _ShareManager._currentDeferred.promise();
};
/**
 */
exports.init = function(testMode) {};
});

define('syracuse-tablet/html/js/app/globals',['require','exports','module'],function (require, exports, module) {

var _authoringActive = false;
exports.fallbackLocaleCode = "en-US";
exports.getGlobalSettings = function() {
	return {
		"device-type": "auto"
	};
};


exports.getBuildTimeStamp = function() {
	return "???";
};
exports.setAuthoringActive = function(status) {
	_authoringActive = status;
};
exports.isAuthoringActive = function() {
	return _authoringActive;
};
var _defMobileClientConfig = {
	// http request default timeout in ms
	httpTimeout: 600000
};
var _mobileClientConfig = $.extend(true, null, _defMobileClientConfig);
/**
 * Path can be null or '.' separator
 */
exports.getMobileClientConfig = function(path) {
	var o = _mobileClientConfig;
	if (path) {
		path.split('.').some(function(p) {
			o = o[p];
			if (o == null) {
				return true;
			}
		})
	}
	return o;
};
exports.setMobileClientConfig = function(config) {
	_mobileClientConfig = $.extend(true, null, _defMobileClientConfig, config);
	if (_mobileClientConfig.httpTimeout == null || isNaN(_mobileClientConfig.httpTimeout)) {
		_mobileClientConfig.httpTimeout = _defMobileClientConfig.httpTimeout;
	}
};
// In milliseconds
exports.getHttpTimeout = function(url) {
	// eventually we could manage regExps to set a timeout per url
	return _mobileClientConfig.httpTimeout;
};
var _offline = false;
exports.isOffline = function() {
	return _offline;
}
exports.setOffline = function(status) {
	_offline = status;
}
});

define('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestHelpers',['require','exports','module','syracuse-tablet/html/js/app/globals','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {
var globals = require('syracuse-tablet/html/js/app/globals');
var modules = require('syracuse-tablet/html/js/common/modules');

var _handlebars = {
	mailTo: ' <a id ="testNativeMailto" href="mailto:?subject={{subject}}&body={{body}}" class="s-m-link">\
		<i class="fa fa-envelope">\
		</i>\
		<span>{{title}}</span>\
		</a>',
	handleLink: ' <a id ="testNativeHandleLink" href="{{href}}" class="s-m-link">\
		<i class="fa fa-hand-pointer-o">\
		</i>\
		<span>{{title}}</span>\
		</a>'
};
var _getHtml = function(tmpl, ctx) {
	return Handlebars.compile(_handlebars[tmpl])(ctx);
};
/**
 * Call mobile application interface
 */
exports.callAppNativeInterface = function(moduleName, actionName) {
	var app = globals.getApplication();
	if (!app) return null;
	return app.nativeWrapperJSInterface.apply(app, arguments);
};

/**
 * Add a clickable email icon
 * options.subject	subject
 * options.url		url
 * options.timeout	timeout
 */
exports.addTestEmail = function($$parent, options) {
	if (!options) return;
	$(_getHtml("mailTo", {
		title: "Send email",
		subject: encodeURIComponent(options.subject || "No subject"),
		body: encodeURIComponent(options.url)
	})).appendTo($$parent);
	setTimeout(function() {
		$("#testNativeMailto").off().remove();
	}, options.timeout || 5000);
};
/**
 * Add a clickable hand icon
 * options.clickHandler	callback on click
 * options.url			link url
 * options.timeout		timeout
 */
exports.addHandleLink = function($$parent, options) {
	if (!options) return null;
	var $$elmt = $(_getHtml("handleLink", {
		title: options.title || "HandleLink",
		href: options.url || "#"
	})).appendTo($$parent);
	if (options.css) {
		$$elmt.css(options.css);
	}
	if (options.clickHandler) {
		$$elmt.click(function() {
			options.clickHandler();
		});
	}
	setTimeout(function() {
		$("#testNativeHandleLink").off().remove();
	}, options.timeout || 5000);
	return $$elmt;
};

exports.notify = function(title, text) {
	modules.get("modal").notify({
		severityClass: "success",
		title: title,
		body: text,
		onlyWebapp: true
	});
};
});

define('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestLiveTile',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestHelpers'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeLiveTile");
var testHelpers = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestHelpers');

var _TestNativeWrapper = function() {
	/**
	 * OPTIONS
		{
		  "Id": "x3.erp.GX3APP.EXPENENTM.$query_http://pc101329.sagefr.adinternal.com:8124/mobile1/x3/erp/GX3APP/EXPENSES?representation=EXPENENTM.$query",
		  "Title": "Frais non visés",
		  "Description": "TEST",
		  "BackgroundColor": "#ff5800",
		  "ForegroundColor": "#41a940",
		  "SdataUrl": "http://pc101329.sagefr.adinternal.com:8124/mobile1/x3/erp/GX3APP/EXPENSES?representation=EXPENENTM.$query",
		  "DeepLink": {
		    "Title": "Frais non visés",
		    "Url": "http://pc101329.sagefr.adinternal.com:8124/syracuse-tablet/html/open_link.html?testNativeWrapper=true&context=1a8be16b-883a-45be-9b2e-1c96c29226fe"
		  },
		  "BindArray": "$resources",
		  "BindDetail": ""
		}
	 */
	this.addLiveTileSupported = function() {
		return true;
	};
	this.addLiveTile = function(options) {
		if (!options) return;
		try {
			options = JSON.parse(options);
		} catch (e) {
			return;
		}
		console.log(JSON.stringify(options, null, 2));
		var id = options.Id;
		var title = [];
		if (options.Title) {
			title.push(options.Title);
		}
		if (options.Description) {
			title.push(options.Description);
		}
		title = title.join(" - ");
		setTimeout(function() {
			log && log("LIVE TILE ADD - Succeeded - " + title);
			testHelpers.addHandleLink($('.s-m-footer-left'), {
				url: options.DeepLink.Url,
				timeout: 10000,
				title: title
			}).find("i").css({
				"color": options.ForegroundColor || "white",
				"background-color": options.BackgroundColor
			});
			window.smLiveTileJS.addLiveTileFinished(null);
		}, 100);
	};
};

exports.create = function() {
	return new _TestNativeWrapper();
};
});

define('syracuse-tablet/html/js/helpers/native/nativeLiveTile',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestLiveTile','syracuse-tablet/html/js/helpers/native/nativeExtCall'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeLiveTile");
var nativeTestLiveTile = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestLiveTile');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');

var _currentDeferred;
//Global object to be called by native code on pencil events
if (!(window.smLiveTileJS)) {
	window.smLiveTileJS = {

		/*
		 *  This method will be invoked from wrapper when there was a live tile action executed.
		 *  data {
		 *  	action :"add" //"remove" "get"
		 *  	content:{ (null in case of get if not tile found)
		 *  			id:"id passed",
		 *  			title:"my customers",
		 *  			...
		 * 		}
		 *  	error:{ (if error occurs)
		 *  		no:"132001"
		 *  		text:"Not found", "unexpected error" ...
		 *  	}
		 *  }
		 * On error return is:
		 * {
		 *   error: {
		 *     text: "<error removing tile, for reason xxx>"
		 *   }
		 * }
		 */
		addLiveTileFinished: function(data) {
			if (_currentDeferred) {
				var def = _currentDeferred;
				_currentDeferred = null;
				log && log("Command live tile add finished: " + JSON.stringify(data || {}));
				def.resolve(data);
			}
		}
	};
}

/**
 *
 */
exports.supports = function(capability) {
	if (capability === "liveTile") {
		return nativeExtCall.isSupported("smLiveTile", "addLiveTileSupported");
	}
	return $.smResolve(false);
};

/**
	options:{
		"id":"x3.erp.GX3APP.BPCUSTOMERM.$query_http://pc101458:8124/mobile1/x3/erp/GX3APP/BPCUSTOMER?representation=BPCUSTOMERM.$query",
		"title":"Clients",
		"sDataUrl":"http://pc101458:8124/mobile1/x3/erp/GX3APP/BPCUSTOMER?representation=BPCUSTOMERM.$query",
		"description"
		"backgroundColor"
		"DeepLink",
		"userLogin"
	}
	data sent to tile
		{
		  "Id": "x3.erp.GX3APP.EXPENENTM.$query_http://pc101329.sagefr.adinternal.com:8124/mobile1/x3/erp/GX3APP/EXPENSES?representation=EXPENENTM.$query",
		  "Title": "Frais non visés",
		  "Description": "TEST",
		  "BackgroundColor": "#ff5800",
		  "ForegroundColor": "#41a940",
		  "SdataUrl": "http://pc101329.sagefr.adinternal.com:8124/mobile1/x3/erp/GX3APP/EXPENSES?representation=EXPENENTM.$query",
		  "DeepLink": {
		    "Title": "Frais non visés",
		    "Url": "http://pc101329.sagefr.adinternal.com:8124/syracuse-tablet/html/open_link.html?testNativeWrapper=true&context=1a8be16b-883a-45be-9b2e-1c96c29226fe"
		  },
		  "BindArray": "$resources",
		  "BindDetail": ""
		}
	Return see addLiveTileFinished
 */
exports.addLiveTile = function(options) {
	_currentDeferred = $.Deferred();
	var data = JSON.stringify(_getTileDataStruct(options));
	nativeExtCall.fireMethod("smLiveTile", "addLiveTile", data);
	return _currentDeferred.promise();
};

/*
 * Pack everything into a structure understood by native code
 */
function _getTileDataStruct(options) {
	var param = {
		Id: options.id,
		Title: options.title,
		Description: options.description,
		BackgroundColor: options.backgroundColor,
		ForegroundColor: options.color,
		SdataUrl: options.sDataUrl,
		DeepLink: options.DeepLink,

		UserLogin: options.userLogin,

		// Data extraction:

		BindArray: options.bind || "$resources", // Name of array property to use for live tile. 
		// E.g. $resources = array so it will be the number of records in the array shown on the live tile.
		BindDetail: "" // Name of property to read value for live tile
			// E.g. BPCNAM = property, so value of property BPCNAM will be used in live tile
			// NOTE:
			// If BindArray and BindDetail are both given, the live tile will 
			// show the value of BindDetail column of the first record of the array 
			// given by BindArray 
	};
	return param;
}
/**
 * Returns the test js wrapper
 */
exports.init = function(testMode) {
	if (window && window.smLiveTile) return;
	if (!testMode) return;
	log && log("Creating native Live Tile test wrapper");
	window.smLiveTile = nativeTestLiveTile.create();
	return window.smLiveTile;
};
});

define('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestMessages',['require','exports','module','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestHelpers','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var testHelpers = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestHelpers');
var modules = require('syracuse-tablet/html/js/common/modules');

var _TestNativeWrapper = function() {

	this.toastMsgSupported = function() {
		return true;
	};
	this.toastMsg = function(options) {
		options = JSON.parse(options)
		var notify = {
			// Avoid infinite loop
			onlyWebapp: true,
			title: options.Text2,
			message: options.Text2,
			severityClass: options.Severity
		};
		modules.get("modal").forceNotifyWebApp(notify);
	};

	this.scheduledMsgSupported = function() {
		return true;
	};
	this.scheduledMsg = function(data) {
		if (data) {
			data = JSON.parse(data);
			testHelpers.notify(data.Text1 && data.Text2 ? data.Text1 + " - " + data.Text2 : data.Text1 || data.Text2, data.ScheduleTime);
		} else {
			testHelpers.notify("Empty toast message");
		}
	};
};

exports.create = function() {
	return new _TestNativeWrapper();
};
});

define('syracuse-tablet/html/js/helpers/native/nativeMessages',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestMessages','syracuse-tablet/html/js/helpers/native/nativeExtCall'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeMsg");
var nativeTestMessages = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestMessages');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');

var _currentDeferred;

if (!(window.smMsgJS)) {
	window.smMsgJS = {};
}

/**
 *
 */
exports.supports = function(capability) {
	if (capability === "toastMessages") {
		return nativeExtCall.isSupported("smMsg", "toastMsgSupported");
	}
	if (capability === "scheduleMessage") {
		return nativeExtCall.isSupported("smMsg", "scheduledMsgSupported");
	}
	return $.smResolve(false);
};

/**
 * Sends a toast message
 * options: {
 *	Text1: options.title,
 *	Text2: options.body, // optional
 *  Severity: "error" | "success",
 *	DeepLink: { // optional
 *		Title,
 *		Url,
 *	}
 * }
 */
exports.showToastMessage = function(options) {
	var data = JSON.stringify(options);
	nativeExtCall.fireMethod("smMsg", "toastMsg", data);
};

/**
 * Sends a toast message
 * options: {
 *	Text1: options.title,
 *	Text2: options.body, // optional
 *  Severity: "error" | "success",
 *  ScheduleTime, // yyyy-MM-dd hh:mm:ss
 *  Tag: Group id to be able to enum tiles of a specific group at a later time
 *	DeepLink: { // optional
 *		Title,
 *		Url,
 *	}
 * }
 */
exports.scheduledMsg = function(options) {
	var data = JSON.stringify(options);
	nativeExtCall.fireMethod("smMsg", "scheduledMsg", data);
};
/**
 * Returns the test js wrapper
 */
exports.init = function(testMode) {
	if (window && window.smMsg) return;
	if (!testMode) return;
	log && log("Creating native msg test wrapper");
	window.smMsg = nativeTestMessages.create();
	return window.smMsg;
};
});

define('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestPenInput',['require','exports','module','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativePenInput");

var _TestNativeWrapper = function() {

	this.getPenTextInputSupported = function() {
		return true;
	};
	this.getAnnotatedImageSupported = function() {
		return true;
	};
	this.getSignatureImageSupported = function(options) {
		return true;
	};
	this.getPenTextInput = function(context) {
		context = context ? JSON.parse(context) : {};
		var text = window.prompt(context.Title || "Enter the text", context.Value || "");
		var data = {
			Action: text == null || text.trim().length === 0 ? "cancelled" : "ok",
			//Returns an array of words
			Matches: text ? text.split(' ') : null
		};
		setTimeout(function() {
			window.smPenInputJS.penInputTextFinished(data);
		}, 50);
	};
	this.getAnnotatedImage = function(options) {
		var img = "";
		setTimeout(function() {
			var data = {
				Action: "ok",
				ImageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsSAAALEgHS3X78AAAAGklEQVR42mOYacxANmIY1TyqeVTzqOaB1QwApdw+0KHEWp0AAAAASUVORK5CYII="
			};
			log && log("Annotated Image GET ");
			window.smPenInputJS.penAnnotateImageFinished(data);
		}, 100);
	};
	this.getSignatureImage = function(options) {
		var img = "";
		setTimeout(function() {
			var data = {
				Action: "ok",
				ImageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsSAAALEgHS3X78AAAAGklEQVR42mOYacxANmIY1TyqeVTzqOaB1QwApdw+0KHEWp0AAAAASUVORK5CYII="
			};
			log && log("Signature Image GET ");
			window.smPenInputJS.penSignatureImageFinished(data);
		}, 100);
	};

};

exports.create = function() {
	return new _TestNativeWrapper();
};
});

define('syracuse-tablet/html/js/ui/uiUtils',['require','exports','module'],function (require, exports, module) {


//empty dom
var _empty = function(domNode) {
	if (domNode) {
		while (domNode.firstChild) {
			domNode.removeChild(domNode.firstChild);
		}
	}
};
//add or remove class to dom element
var _toggleClass = function(item, css, show) {
	if (item) {
		var className = item.className;
		if (show) {
			if (className.indexOf(css) < 0) {
				item.className = className + (" " + css);
			}
		} else {
			item.className = className.replace(css, "");
		}
	}
};

var _waitDefOpts = {
	className: 'waiting-circles',
	elements: 8,
	radius: 30,
	auto: true
};
/**
 * Wait plugin for global application only (no current page or application)
 */
var _waitGlobal = null;
var _wait = function(waitObject, start) {
	if (waitObject == null) {
		// use only if no current application otherwise use page's wait plugin
		if (_waitGlobal == null) _waitGlobal = _waitWheelCreate($(document.body));
		waitObject = _waitGlobal;
	}
	if (start) {
		waitObject.$$bckg.show();
		_waitPluginStatus(waitObject.$$wheel, "enable");
	} else {
		waitObject.$$bckg.hide();
		_waitPluginStatus(waitObject.$$wheel, "disable");
	}
};

var _waitWheelCreate = function($$parent, opts) {
	var waitObject = {
		$$bckg: $('<div class="waiting-background" style="display:none;z-index:2000"></div>'),
		$$wheel: $('<div class="waiting-wheel"  style="display:none;z-index:2000"></div>')
	};
	waitObject.$$bckg.appendTo($$parent);
	waitObject.$$wheel.appendTo($$parent);
	// Initialize plugin
	_waitPluginCreate(waitObject.$$wheel, _waitDefOpts);
	return waitObject;
};
/**
 * Destroy plugin
 */
var _waitPluginDestroy = function($$elmt) {
	/**
	 * We need to check data('waiting') because the plugin is not safe
	 * 	If no data('waiting') it fails
	 * 	That occurs if we remove a parent element of the plugin before destroying the plugin
	 */
	if ($$elmt && $$elmt.data('waiting')) {
		$$elmt.waiting("destroy");
		$$elmt.remove();
	}
};

var _waitPluginStatus = function($$elmt, status) {
	if ($$elmt && $$elmt.data('waiting')) {
		$$elmt.waiting(status);
		$$elmt[status === "disable" ? "hide" : "show"]();
	}
};

var _waitPluginCreate = function($$elmt, opts) {
	if (!opts) throw new Error("opts is mandatory");
	if ($$elmt) $$elmt.waiting(opts);
	return $$elmt;
};
var _waitWheelDestroy = function(waitObject) {
	if (waitObject) {
		_waitPluginDestroy(waitObject.$$wheel);
		if (waitObject.$$bckg) waitObject.$$bckg.remove();
	}
};
/**
 * Returns a dom element
 * - tag : html tag
 * - classList : array of classes
 * - content : dom.textContent
 * - attrList : various attributes list with key,value (JSON format)
 **/

var _createDomElement = function(tag, classList, content, attrList, parent) {
	if (!tag) {
		throw new Error("tag parameter is necessary !");
	}
	// create dom element
	var dom = document.createElement(tag);

	// append classes
	if (classList) {
		if ($.isArray(classList)) {
			$.each(classList, function(index, className) {
				dom.className += className + (index == classList.length - 1 ? "" : " ");
			});
		} else {
			if (typeof classList !== 'string') {
				throw new Error("classList parameter must be an array or a string");
			} else {
				dom.className += classList;
			}
		}
	}

	// set content
	dom.textContent = content ? content : "";

	if (tag === "a" || tag === "img") {
		// Disable drag - true by default for a and img
		attrList = attrList || {};
		attrList.draggable = "false";
	}
	if (attrList) {
		$.each(attrList, function(key, value) {
			dom.setAttribute(key, value);
		});
	}

	if (parent) {
		if (parent.jquery) {
			parent = parent.append(dom);
		} else {
			parent.appendChild(dom);
		}
	}

	return dom;
};

var _appendTextNode = function(e, text) {
	if (!e) return;
	var t = document.createTextNode(text || "");
	if (e.jquery) {
		e = e.append(t);
	} else {
		e.appendChild(t);
	}
	return e;
};
var _buildDom = function(domDesc, parent) {
	$.each(domDesc, function(nodeName, value) {
		var dom = _createDomElement(nodeName, value.classList, value.textContent, value.attr, parent);
		if (value.children) {
			$.each(value.children, function(index, childElement) {
				_buildDom(childElement, dom);
			});
		}
	});
};

exports.empty = _empty;
exports.toggleClass = _toggleClass;

exports.waitWheelStart = function(waitObject) {
	_wait(waitObject, true);
};
exports.waitWheelStop = function(waitObject) {
	_wait(waitObject, false);
};

exports.waitWheelCreate = _waitWheelCreate;
exports.waitWheelDestroy = _waitWheelDestroy;

/** Wait plugin SAFE call - SAFE if plugin has been remove from DOM*/
exports.waitPluginDestroy = _waitPluginDestroy;
exports.waitPluginCreate = _waitPluginCreate;
exports.waitPluginDisable = function($$elmt) {
	_waitPluginStatus($$elmt, "disable");
};
exports.waitPluginEnable = function($$elmt) {
	_waitPluginStatus($$elmt, "enable");
};

exports.createDomElement = _createDomElement;
exports.buildDom = _buildDom;

exports.appendTextNode = _appendTextNode;

/**
 * Trigger a global resize event for application
 * All layouts will be updated
 */
exports.triggerResizeInternal = function(opts) {
	$(window).triggerHandler("resizeInternal", [opts]);
};
exports.imgHeight2px = function(val) {
	val = val || "small";
	switch (val) {
		case "xsmall":
			return 25;
		case "small":
			return 50;
		case "medium":
			return 100;
		case "large":
			return 200;
		case "xlarge":
			return 300;
		default:
			return 100;
	}
};
});

define('syracuse-tablet/html/js/helpers/native/nativePenInput',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestPenInput','syracuse-tablet/html/js/helpers/native/nativeExtCall','syracuse-tablet/html/js/ui/uiUtils'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativePenInput", false);
var nativeTestPenInput = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestPenInput');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');

var _currentInputDeferred;

// Global object to be called by native code on pencil events
if (!(window.smPenInputJS)) {
	window.smPenInputJS = {

		/*
		 *  This method will be invoked from wrapper once the pen input has finished or failed
		 *  data:
		 *  {
		 *  	Action: "ok" | "cancelled",
		 *  	Matches: ["match 1", "match 2"]
		 *  }
		 */
		penInputTextFinished: function(data) {
			if (_currentInputDeferred) {
				var def = _currentInputDeferred;
				_currentInputDeferred = null;
				log && log("Got pen input: " + JSON.stringify(data || {}));
				def.resolve({
					action: data.Action,
					matches: data.Matches
				});
			}
		},
		/*
		 *  This method will be invoked from wrapper once the user
		 *  finished drawing lines on the image he wants to draw annotations on
		 *  data:
		 *  {
		 *  	Action: "ok" | "cancelled",
		 *  	ImageData: "base64string with new image data" (data:image/jpeg;base64,AFHXSJKAHSFKLJH)
		 *  }
		 */
		penAnnotateImageFinished: function(data) {
			// FD - waitWheel useful when we display for big images
			uiutils.waitWheelStop();
			if (_currentInputDeferred) {
				var def = _currentInputDeferred;
				_currentInputDeferred = null;
				def.resolve({
					action: data.Action,
					imageData: data.ImageData
				});
			}
		},
		/*
		 *  This method will be invoked from wrapper once the user
		 *  finished to draw his signature
		 *  data:
		 *  {
		 *  	Action: "ok" | "cancelled",
		 *  	ImageData: "base64string with new image data" (data:image/jpeg;base64,AFHXSJKAHSFKLJH)
		 *  }
		 */
		penSignatureImageFinished: function(data) {
			if (_currentInputDeferred) {
				var def = _currentInputDeferred;
				_currentInputDeferred = null;
				def.resolve({
					action: data.Action,
					imageData: data.ImageData
				});
			}
		}
	};
}

/**
 *
 */
exports.supports = function(capability) {
	log && log("Pen check support: " + capability);
	if (capability === "penTextInput") {
		return nativeExtCall.isSupported("smPenInput", "getPenTextInputSupported");
	}
	if (capability === "penAnnotatedImage") {
		return nativeExtCall.isSupported("smPenInput", "getAnnotatedImageSupported");
	}
	if (capability === "penSignatureImage") {
		return nativeExtCall.isSupported("smPenInput", "getSignatureImageSupported");
	}
	return $.smResolve(false);
};

/**
 * Trigger pen input modal in native shell
 * options:
 * {
 *      title: Title to display above input area,
 *      value: Current field value // Must be of type string!
 * }
 */
exports.getPenTextInput = function(options) {
	if (options && options.value != null) {
		options.value = "" + options.value;
	}
	var data = JSON.stringify({
		Title: options.title,
		Value: options.value
	});
	_currentInputDeferred = $.Deferred();
	nativeExtCall.fireMethod("smPenInput", "getPenTextInput", data);
	return _currentInputDeferred.promise();
};

/**
 * Trigger pen input on an image to allow highlighting with pencil
 * options:
 * {
 *      title: Title of image property
 *      imageData: base64 string containing image data (data:image/jpeg;base64,AFHXSJKAHSFKLJH)
 * }
 */
exports.getAnnotatedImage = function(options) {
	var data = JSON.stringify({
		Title: options.title,
		ImageData: options.imageData
	});
	_currentInputDeferred = $.Deferred();
	// FD - waitWheel useful when we display for big images - js -> native can take more than 3 seconds
	uiutils.waitWheelStart();
	nativeExtCall.fireMethod("smPenInput", "getAnnotatedImage", data);
	return _currentInputDeferred.promise();

};

/**
 * Trigger pen input to allow user to input his signature
 * options:
 * {
 *      title: Title of page
 *      watermark: Text that will be embedded in the image (e.g. a timestamp)
 *		maxWidth: 640 - Max width of signature image in pixels
 *		maxHeight: 480 - Max height of signature image in pixels
 *      watermarkSize: 16 - Height of watermark text. If text is too long or to high to fit, this size may be shrinked
 * }
 */
exports.getSignatureImage = function(options) {
	var data = JSON.stringify({
		Title: options.title,
		Watermark: (options.watermark != null ? ("" + options.watermark) : ""),
		MaxWidth: (options.maxWidth != null ? (+options.maxWidth) : 640),
		MaxHeight: (options.maxHeight != null ? (+options.maxHeight) : 480),
		WatermarkSize: (options.watermarkSize != null ? (+options.watermarkSize) : 16)
	});
	_currentInputDeferred = $.Deferred();
	nativeExtCall.fireMethod("smPenInput", "getSignatureImage", data);
	return _currentInputDeferred.promise();

};
/**
 * Returns the test js wrapper
 */
exports.init = function(testMode) {
	if (window && window.smPenInput) return;
	if (!testMode) return;
	log && log("Creating native Pen Input test wrapper");
	window.smPenInput = nativeTestPenInput.create();
	return window.smPenInput;
};
});

define('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestImage',['require','exports','module'],function (require, exports, module) {

var _TestNativeWrapper = function() {

	this.getPictureFromCameraSupported = function() {
		return true;
	};
	this.getScaledImageSupported = function() {
		return true;
	};
	this.getPictureFromCamera = function(options) {
		setTimeout(function() {
			var data = {
				Action: "ok",
				ImageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsSAAALEgHS3X78AAAAGklEQVR42mOYacxANmIY1TyqeVTzqOaB1QwApdw+0KHEWp0AAAAASUVORK5CYII="
			};
			window.smImageJS.getPictureFromCameraFinished(data);
		}, 100);
	};
	this.getScaledImage = function(options) {
		setTimeout(function() {
			var data = {
				Action: "ok",
				ImageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsSAAALEgHS3X78AAAAGklEQVR42mOYacxANmIY1TyqeVTzqOaB1QwApdw+0KHEWp0AAAAASUVORK5CYII="
			};
			window.smImageJS.getScaledImageFinished(data);
		}, 100);
	};
};

exports.create = function() {
	return new _TestNativeWrapper();
};
});

define('syracuse-tablet/html/js/helpers/native/nativeImage',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestImage','syracuse-tablet/html/js/helpers/native/nativeExtCall'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeCamera");
var nativeTestImage = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestImage');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');

var _currentDeferred;

// Global object to be called by native code on pencil events
if (!(window.smImageJS)) {
	window.smImageJS = {

		/*
		 *  data:
		 *  {
		 *  	Action: "ok" || "cancelled" || "error"
		 *  	ImageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhE....",
		 *  	Message: "Error message in case action=error"
		 *  }
		 */
		getPictureFromCameraFinished: function(data) {
			log && log("Got image!");
			if (_currentDeferred) {
				var def = _currentDeferred;
				_currentDeferred = null;
				log && log("Got image: " + JSON.stringify(data || {}));
				def.resolve({
					action: data.Action,
					imageData: data.ImageData
				});
			}
		},
		/*
		 *  	Action: "ok" || "error" || "unchanged"
		 *  	ImageData: "data:image/png;base64,iVBORw0KGgoAAAANSUhE....",
		 *  	Width: width
		 *  	Height: height
		 */
		getScaledImageFinished: function(data) {
			log && log("Got scaled image!");
			if (_currentDeferred) {
				var def = _currentDeferred;
				_currentDeferred = null;
				log && log("Got scaled image: " + JSON.stringify(data || {}));
				def.resolve({
					action: data.Action,
					imageData: data.ImageData,
					width: data.Width,
					height: data.Height
				});
			}
		}
	};
}
/**
 *
 */
exports.supports = function(capability) {
	if (capability === "camera") {
		return nativeExtCall.isSupported("smImage", "getPictureFromCameraSupported");
	}
	if (capability === "imageScale") {
		return nativeExtCall.isSupported("smImage", "getScaledImageSupported");
	}
	return $.smResolve(false);
};

/**
 * Options are available as parameter but it's not used yet!
 * IOS: We returned the image resized instead of doing the resize in another step (faster)
 * resizeOptions: is  null if no resize options
 * options:
 * {
 *  	resizeOptions: Resize options see getScaledImage
 * }
 */
exports.getPictureFromCamera = function(options) {
	var param = {};
	if (options && options.resizeOptions != null) {
		param.resizeOptions = {
			Width: options.resizeOptions.width,
			Height: options.resizeOptions.height,
			Mode: options.resizeOptions.mode
		}
	}
	_currentDeferred = $.Deferred();
	nativeExtCall.fireMethod("smImage", "getPictureFromCamera", param);
	return _currentDeferred.promise();
};

/**
 * options: {
 *   imageData: Data of image to scale: data:image/png;base64,iVBORw0KGgoAAAANSUh
 *   width: Desired width
 *   height: Desired height,
 *
 *   mode: "LIMIT_MAX_WIDTH_AND_HEIGHT"
 * }
 *
 *  Modes:
 *  LIMIT_MAX_WIDTH_AND_HEIGHT:
 *  Ensures that width and height do not exceed the values given in the options
 *  If one of the two is bigger that desired, both are scaled down to preserver the aspect ratio
 */
exports.getScaledImage = function(options) {
	var data = {
		ImageData: options.imageData,
		Width: options.width,
		Height: options.height,
		Mode: options.mode
	};
	_currentDeferred = $.Deferred();
	nativeExtCall.fireMethod("smImage", "getScaledImage", data);
	return _currentDeferred.promise();
};
/**
 * Returns the test js wrapper
 */
exports.init = function(testMode) {
	if (window && window.smImage) return;
	if (!testMode) return;
	log && log("Creating native image test wrapper");
	window.smImage = nativeTestImage.create();
	return window.smImage;
};
});

define('syracuse-tablet/html/js/helpers/locale',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var modules = require('syracuse-tablet/html/js/common/modules');

var _currentLocale = null;
var _resources = {};

var _datetimeInformationKey = "$datetimeInformation";
var _decimalInformationKey = "$decimalInformation";
var _upLocalePreferences;

var _txtRegexp = /\{([\w-]+)\}/g;
var _currentLocaleUser = "*";

var _userProfileSettings = {};

/**
 * Init client side locale dependend resources based on the current user profile
 */
exports.setLocaleByUserProfile = function(userProfile) {
	var locale = userProfile.selectedLocale.code;

	_currentLocaleUser = userProfile.user.login;
	_userProfileSettings = userProfile.selectedLocale; // For overriding shortDate defaults, etc

	return exports.setLocale(userProfile.selectedLocale.code);
}

/**
 * This should only be used during init process to set a default locale
 * Subsequent changes should use setLocaleByUserProfile
 */
exports.setLocale = function(locale) {
	var deferred = new $.Deferred();

	var resources = _resources && _resources[locale];
	if (resources) {
		_currentLocale = locale;
		deferred.resolve();
	} else if (locale === _currentLocale) {
		deferred.resolve();
	} else {
		var rsrcPath = jsutils.getResourcesBasePath();
		_loadFile(rsrcPath + "js/resources", "strings", locale, "en")
			.then(function(data) {
				_currentLocale = locale;
				_resources[locale] = data;
			})
			.then(function() {
				return _loadFile(rsrcPath + "js/resources/locales", "date", locale, "en-GB");
			})
			.then(function(data) {
				// join strings-xx-XX and date-xx-XX
				_resources[locale][_datetimeInformationKey] = data;
			})
			.then(function() {
				return _loadFile(rsrcPath + "js/resources/locales", "decimal", locale, "en-GB");
			})
			.then(function(data) {
				// join strings-xx-XX and decimal-xx-XX
				_resources[locale][_decimalInformationKey] = data;
			})
			.then(function() {
				deferred.resolve();
			}).fail(function(e) {
				deferred.resolve();
			});
	}
	return deferred.promise();
};

/**
 * 
 */
exports.text = function(key, args) {
	var resources = _resources && _resources[_currentLocale];
	if (!resources) {
		return;
	}
	var text = resources[key] || "Resource key not found[" + key + "]";

	if (args) {
		if (!Array.isArray(args)) {
			// We accept multiple arguments following the key
			args = Array.prototype.slice.call(arguments, 1);
		}
		text = text.replace(_txtRegexp, function(match, p1) {
			var idx = +p1;
			if (idx >= 0 && idx < args.length) {
				return args[idx];
			}
			return "?";
		});
	}

	return text;
};

/**
 * 
 */
exports.textNoFail = function(key, args) {
	var resources = _resources && _resources[_currentLocale];
	if (!resources || !resources[key]) {
		return null;
	}
	var text = resources[key];
	if (args) {
		if (!Array.isArray(args)) {
			// We accept multiple arguments following the key
			args = Array.prototype.slice.call(arguments, 1);
		}
		text = text.replace(_txtRegexp, function(match, p1) {
			var idx = +p1;
			if (idx >= 0 && idx < args.length) {
				return args[idx];
			}
			return "?";
		});
	}
	return text;
};

/**
 * 
 */
exports.textOpt = function(key) {
	var resources = _resources && _resources[_currentLocale];
	if (!resources) {
		return;
	}
	return resources[key];
};

/**
 * 
 *
 */
exports.getDatetimeInfo = function() {
	var resources = _resources && _resources[_currentLocale];
	if (!resources) {
		return;
	}
	return resources[_datetimeInformationKey];
};

/**
 * 
 */
exports.isCurrent = function(locale, strict) {
	if (!locale || !_currentLocale) return false;
	if (_currentLocale === locale) return true;
	return strict ? false : (locale.split('-'))[0] === _currentLocale;
};

/**
 * 
 */
exports.getDateFormat = function() {
	var di = exports.getDatetimeInfo();
	return _userProfileSettings.shortDate || (di && di.formatPatterns && di.formatPatterns.shortDate) || "dd/MM/yyyy";
};

/**
 * 
 */
exports.getDateTimeFormat = function() {
	var di = exports.getDatetimeInfo();
	var date = _userProfileSettings.shortDate || (di && di.formatPatterns && di.formatPatterns.shortDate) || "dd/MM/yyyy";
	var time = _userProfileSettings.shortTime || (di && di.formatPatterns && di.formatPatterns.shortTime) || "HH:mm:ss";
	return date + " " + time;
};

/**
 * 
 */
exports.getTimeFormat = function() {
	var di = exports.getDatetimeInfo();
	return _userProfileSettings.longTime || (di && di.formatPatterns && di.formatPatterns.longTime || "HH:mm:ss");
};

/**
 * 
 */
exports.getTimeFormatShort = function() {
	var di = exports.getDatetimeInfo();
	return _userProfileSettings.shortTime || (di && di.formatPatterns && di.formatPatterns.shortTime || "HH:mm");
};

/**
 * 
 */
exports.getNumberFormat = function(type) {
	return (type === "application/x-integer" ? "#,##0" : "#,##0.##");
};

/**
 * 
 */
exports.getNumberGroupSeparator = function() {
	var di = _getDecimalInfo();
	var gs = _userProfileSettings.numberGroupSeparator || (di && di.numberGroupSeparator) || ",";
	return gs;
};

/**
 * 
 */
exports.getNumberDecimalSeparator = function() {
	var di = _getDecimalInfo();
	var ds = _userProfileSettings.numberDecimalSeparator || (di && di.numberDecimalSeparator) || ".";
	return ds;
};

/**
 * 
 */
exports.getCurrentLocale = function() {
	return _currentLocale;
};

/**
 * 
 */
exports.getCurrentLocaleHash = function() {
	return _currentLocale + "#" + _currentLocaleUser;
};

/**
 * 
 */
exports.getProductLabels = function() {
	var data = {};
	data.brand = exports.text("global.label.brand");
	data.product = exports.text("global.label.product");
	return data;
};

/**
 * 
 * @returns
 */
function _getDecimalInfo() {
	var resources = _resources && _resources[_currentLocale];
	if (!resources) {
		return;
	}
	return resources[_decimalInformationKey];
};

function _loadFile(path, file, locale, defLocale) {
	var deferred = new $.Deferred();
	var segs = locale.split("-");
	var loadedLocale;
	var ajax = modules.get("ajax");

	function _load() {
		if (segs.length === 0) {
			// Fallback to default
			var url = path + "/" + file + "-" + defLocale + ".json";
			ajax.request(url)
				.then(function(result) {
					var data = result.data;
					if (data) {
						deferred.resolve(data);
					}
					deferred.resolve({});
				}).fail(function(e) {
					deferred.reject(e);
				});
		} else {
			var code = segs.join("-");
			var url = path + "/" + file + "-" + code + ".json";
			ajax.request(url)
				.then(function(result) {
					var data = result.data;
					if (data) {
						if (code !== defLocale) {
							url = path + "/" + file + "-" + defLocale + ".json";
							ajax.request(url)
								.then(function(result) {
									var dataEn = result.data;
									if (dataEn) {
										var mergedStrings = $.extend(true, {}, dataEn, data);
										deferred.resolve(mergedStrings);
									} else {
										deferred.resolve(data);
									}
								})
								.fail(function(e) {
									// Fail silently since it's only about fallback language
									deferred.resolve(data);
								});
							return;
						}
						deferred.resolve(data);
					} else {
						segs.pop();
						_load();
					}
				}).fail(function(e) {
					segs.pop();
					_load();
				});
		}
	}
	_load();
	return deferred.promise();
};
});

define('syracuse-tablet/html/js/helpers/native/nativeVoiceCommands',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/native/nativeExtCall','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeVoice", false);
var locale = require('syracuse-tablet/html/js/helpers/locale');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var modules = require('syracuse-tablet/html/js/common/modules');

var _currentVoiceCommands = null;
var _readyForCommands = false;
var _lastCommand = null;

if (!(window.smVoiceJS)) {
	window.smVoiceJS = {

		/*
		 *  This method will be invoked from wrapper when there was a voice command
		 *
		 *  return true - Command has been handled by webapp
		 *  return false - Command has not been handled, will raise an error message
		 *
		 *  For Hey cortana, show my customers
		 *  data {
		 *  	Command: "openBookmark",
		 *  	Text: "my customers"
		 *  }
		 */
		executeVoiceCommand: function(data) {
			if (!data) return;
			_tryExecuteVoiceCommand(data.Text);
		}
	};
}

notifications.subscribe({
	notifNavigatedToPage: function(page) {
		var name = page && page.pageName;
		log && log("Voice: navigated to: " + name)
		if (!_readyForCommands && name != null && name != "logout" && name != "login") {
			_setReadyForCommands();
		}
	}
}, "sm.navigated.to.page");

function _setReadyForCommands() {
	if (!_readyForCommands && _lastCommand != null) {
		log && log("Ready for voice commands, execute queue");
		_readyForCommands = true;
		_tryExecuteVoiceCommand(_lastCommand);
	} else {
		log && log("Ready for voice commands, no pendig commands in queue");
		_readyForCommands = true;
	}
}

/**
 *
 */
exports.supports = function(capability) {
	if (capability === "voiceCommands") {
		return nativeExtCall.isSupported("smVoice", "setPhraseListSupported");
	}
	return $.smResolve(false);
};

/**
 *
 */
function _setPhraseList(titlesArray) {
	var data = JSON.stringify({
		Phrase: "bookmark",
		PhraseList: titlesArray,
		Language: locale.getCurrentLocale().toLowerCase()
	});
	log && log("Update voiceCommands: " + JSON.stringify(data, null, 2));
	nativeExtCall.fireMethod("smVoice", "setPhraseList", data);
}

/**
 * Sets available voice commands for native API,
 * also stores native voice commands so they can be executed later
 * 
[
	{
		title: "My Customers",
		page: {
            "$url": "{$hostPort}/mobile2/$client/$local/$dataset/mobileDashboard('MY_CUSTOMERS')",
            "$method": "GET"
			
		}
	},
	{
		title: "My Expenses",
		page: {
            "$url": "{$hostPort}/mobile2/$client/$local/$dataset/mobileDashboard('MY_EXPENSES')",
            "$method": "GET"
		}
	}
]
 */
exports.updateVoiceCommands = function(commands) {
	_currentVoiceCommands = commands;
	_setPhraseList(_currentVoiceCommands.map(function(item) {
		return item.title;
	}));
}

function _tryExecuteVoiceCommand(text) {
	_lastCommand = text;
	if (_readyForCommands && _currentVoiceCommands != null) {
		_executeVoiceCommand(_lastCommand);
		_lastCommand = null;
	}
}

function _executeVoiceCommand(text) {
	var command;
	log && log("Execute command: " + text);
	if (_currentVoiceCommands.some(function(c) {
			command = c;
			return c.title === text;
		})) {
		log && log("Execute command data: " + JSON.stringify(command));
		_launchVoiceCommand(command);
	} else {
		log && log("Execute command, no match: " + text);
	}

}

function _launchVoiceCommand(command) {
	var page = command && command.page;
	page && modules.get("navHelper").gotoUrl(page.$url, page.$method);
}

/**
 * Returns the test js wrapper
 */
exports.init = function(testMode) {
	if (window && window.smVoice) return;
	return window.smVoice;
};
});

define('syracuse-tablet/html/js/storage/localStorage',['require','exports','module','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {

/**
 * Local storage
 * Uses only window local storage
 */

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("sessstorage");

var _available = null;

var _isAvailable = function() {
	if (_available !== null) {
		return _available;
	}
	_available = false;
	try {
		window.localStorage.setItem("__test_availability__", "__test_availability__");
		_available = true;
	} catch (e) {}
	return _available;
};

var _getItem = function(key, removeAfter) {
	if (!_isAvailable()) {
		log && log("local.unsupported.getItem(" + key + "):" + val);
		return;
	}
	var val = window.localStorage.getItem(key);
	log && log("local.getItem(" + key + "):" + val);
	if (true === removeAfter) {
		_removeItem(key);
	}
	return val;
};

var _setItem = function(key, value) {
	if (!_isAvailable()) {
		log && log("local.unsupported.setItem(" + key + "):" + value);
		return;
	}
	log && log("local.setItem(" + key + "):" + value);
	return window.localStorage.setItem(key, value);
};

var _removeItem = function(key) {
	if (!_isAvailable()) {
		log && log("local.unspported.removeItem(" + key + ")");
		return;
	}
	log && log("local.removeItem(" + key + ")");
	return window.localStorage.removeItem(key);
};

exports.removeItem = _removeItem;
exports.setItem = _setItem;
exports.getItem = _getItem;
});

define('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestApp',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/storage/localStorage','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestHelpers'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("X3WUPApp", false);
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var localStorage = require('syracuse-tablet/html/js/storage/localStorage');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var nativeHelpers = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestHelpers');

var _closeAppliBtn = '\
	<div id="x3wupappclosebtn" class="s-m-test-wrapper" title="Close application">\
		<a href="#" draggable="false" style= "color:#41a940";>\
		<i class="fa fa-power-off"></i>\
		</a>\
	</div>';

var _addCloseAppliBtn = function($$root) {
	$$root.find("#x3wupappclosebtn").off().remove();
	return $(Handlebars.compile(_closeAppliBtn)()).appendTo($$root);
	//	.css({
	//		"color": "#41a940",
	//		"float": "right",
	//		"padding-left": "8px",
	//		"font-size": ".7em",
	//		"top": "8px",
	//		"position": "relative"
	//	})
};

var _TestNativeWrapper = function() {

	this.nativeWrapperSupported = function() {
		return true;
	};
	this.openExternalLinkSupported = function() {
		return true;
	};

	// This will hide html back button and only allow the one of the browser toolbar
	this.hardwareBackButtonSupported = function() {
		return true;
	};

	this.notifApplicationReady = function(ok) {
		// To not reaload a bad context
		localStorage.removeItem("$reconnectContext");
	};

	this.onClickCloseAppli = function() {
		this.onWebappUnloaded();
	};

	this.onWebappLoaded = function() {};
	/**
	 * historyContext is s a string
	 */
	this.onWebappUnloaded = function() {
		if (!window.smWrapperJS) return;
		try {
			this.setReconnectContext(nativeHelpers.callAppNativeInterface("nativeApp", "applicationClosing"));
			setTimeout(function() {
				window.location.reload();
			}, 100);
		} catch (e) {
			console.log(e.stack);
			return e.message;
		}
	};
	/**
	 *
	 */
	this.webappConfigServer = function() {};
	this.webappSelectServer = function() {};
	/**
	 * context is s a string
	 */
	this.setReconnectContext = function(context) {
		try {
			log && log("setReconnectContext", context);
			localStorage.setItem("$reconnectContext", context);
		} catch (e) {
			log && log("setReconnectContext", JSON.stringify(e));
		}
	};
	/**
	 * Returns a String
	 */
	this.getReconnectContext = function() {
		try {
			var context = localStorage.getItem("$reconnectContext");
			log && log("getReconnectContext", context);
			return context;
		} catch (e) {
			log && log("getReconnectContext", JSON.stringify(e));
			return null;
		}
	};
	/**
	 * Returns a loginCookie and sessionCookie
	 */
	this.getReconnectToken = function() {
		try {
			var loginCookie = localStorage.getItem("$reconnectToken");
			var sidCookie = localStorage.getItem("$reconnectSid");
			log && log("getReconnectToken", loginCookie, sidCookie);
			return $.smResolve(loginCookie, sidCookie)
		} catch (e) {
			log && log("getReconnectToken", JSON.stringify(e));
			return $.smResolve(null, null)
		}
	};
	/**
	 * token is a string
	 *{
	 *		SyracuseSidLogin: token,
	 *		UserLogin: userLogin,
	 *		SyracuseSid: SyracuseSid
	 *};
	 */
	this.setReconnectToken = function(token) {
		try {
			log && log("setReconnectToken", token);
			token = token ? JSON.parse(token) : null;
			if (!token) return
			localStorage.setItem("$reconnectToken", token.SyracuseSidLogin);
			localStorage.setItem("$reconnectSid", token.SyracuseSid);
			localStorage.setItem("$reconnectLoginName", token.LoginCookieName);
			localStorage.setItem("$reconnectSidName", token.SidCookieName);
		} catch (e) {
			log && log("setReconnectToken", JSON.stringify(e));
		}
	};
	/**
	 * Add a button into the header to simulate a close-application event from native wrapper + reload the application and restore the context
	 */
	this.appendHeaderTestCmds = function($$root) {
		if (!$$root || !this.nativeWrapperSupported()) return;
		_addCloseAppliBtn($$root).click(jsutils.bindFn(this.onClickCloseAppli, this));
	};

	// at the end
	notifications.subscribe(this, ["sm.application.ready"]);

};
exports.create = function() {
	return new _TestNativeWrapper();
};
});

define('syracuse-tablet/html/js/helpers/native/nativeApp',['require','exports','module','syracuse-tablet/html/js/app/globals','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestApp','syracuse-tablet/html/js/helpers/native/nativeExtCall','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var globals = require('syracuse-tablet/html/js/app/globals');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeWUPApp", false);
var nativeTestApp = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestApp');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');
var modules = require('syracuse-tablet/html/js/common/modules');


//Global object to be called by native code on low level events
if (!(window.smWrapperJS)) {
	window.smWrapperJS = {

		/*
		 *  This method will be invoked from wrapper when the user clicks the
		 *  hardware back button
		 *
		 *  return "true" - Back action is handled by JS code
		 *  return "false" - Back action is handled by native code (usually to close app).
		 */
		backButtonPressed: function() {
			var app = modules.get("appController").App;
			var canGoBack = app.canGoBack();
			if (canGoBack) {
				modules.get("appController").App.goBack();
				return true;
			}
			return false;
		},

		/*
		 * Called by native wrapper when the application is going to terminate
		 */
		applicationClosing: function() {
			var currentAppState = modules.get("appController").App.nativeApplicationClosing();
			return currentAppState;
		},

		/*
		 * Called only on the following scenaria
		 * Application is loaded but the user navigates back on a page that is driven by native code
		 * so the web app becomes invisible
		 * As soon as the user decides to start the same web app again (make it visible again) this method is called.
		 *
		 * The intention of this method is to check for online/offline mode and other things that may have changed
		 * since the web app was visible for the last time
		 */
		applicationActivated: function() {
			modules.get("appController").App.nativeApplicationActivated();
		},

		/*
		 * connected:
		 * true: The index.html used to start this app can be accessed by the wrapper which usually means network is ok
		 * false: Network is down, index.html is not accessible
		 */
		connectivityChanged: function(connected) {
			log && log("connectivityChanged: " + connected);
			globals.setOffline(connected != true, false, true);
		}
	};
}


/**
 * Running inside a native container?
 * !!! Return a boolean
 */
exports.supports = function(capability) {
	if (capability === "nativeApp") {
		return nativeExtCall.isSupported("smApp", "nativeWrapperSupported");
	}
	if (capability === "hardwareBackButton") {
		return nativeExtCall.isSupported("smApp", "hardwareBackButtonSupported");
	}
	if (capability === "dispatcherListener") {
		return nativeExtCall.isSupported("smApp", "dispatcherListenerSupported");
	}
	if (capability === "extLink") {
		return nativeExtCall.isSupported("smApp", "openExternalLinkSupported");
	}
	if (capability === "nativeScrolling") {
		return nativeExtCall.isSupported("smApp", "nativeScrollingSupported");
	}

	return $.smResolve(false);
};

/**
 * Opens a link in a new browser window
 */
exports.openExternalLink = function(url) {
	nativeExtCall.fireMethod("smApp", "openExternalLink", url);
};

/**
 * Management of reconnection
 * Returns the login and session cookies (reconnectToken) as string
 * To be compliant with win10 version getReconnectToken can return 
 * 	a string (login cookie)
 * 	an object with login and session cookies {loginCookie: loginCookie, sidCookie: sidCookie}
 */
exports.getReconnectToken = function() {
	var deferred = $.Deferred()
	nativeExtCall.callMethod("smApp", "getReconnectToken").then(function(result) {
		var loginCookie = null,
			sidCookie = null;
		if (result == null || typeof result == "string") {
			loginCookie = result;
		} else {
			loginCookie = result.loginCookie;
			sidCookie = result.sidCookie;
		}
		deferred.resolve(loginCookie, sidCookie);
	})
	return deferred.promise();
};
/**
 * Management of reconnection
 * Stores the login token (reconnectToken)
 * Native method is called with a stringified context
 * token: login cookie provided by syracuse server
 * userLogin: user name (login) stored in login cookie
 * sid: session id to preserve the same session for all requests sent to server
 * loginCookieName, sidCookieName: cookies name used if there's a reverse proxy that hide the port
 */
exports.setReconnectToken = function(token, userLogin, sid, loginCookieName, sidCookieName) {
	var data = {}
	if (typeof token === "string") {
		data.SyracuseSidLogin = token;
		data.UserLogin = userLogin;
	}
	if (typeof sid === "string") {
		data.SyracuseSid = sid
	}
	if (typeof loginCookieName === "string") {
		data.LoginCookieName = loginCookieName
	}
	if (typeof sidCookieName === "string") {
		data.SidCookieName = sidCookieName
	}
	nativeExtCall.fireMethod("smApp", "setReconnectToken", data);
};
/**
 * Management of reconnection
 * Returns the user context to restore (context) as string
 * {
 * 		userCtx:
 * 		userProfile:
 *  	context:
 *  }
 */
exports.getReconnectContext = function() {
	return nativeExtCall.callMethod("smApp", "getReconnectContext");
};
exports.configServer = function() {
	nativeExtCall.fireMethod("smApp", "configServer");
};
exports.selectServer = function() {
	nativeExtCall.fireMethod("smApp", "selectServer");
};

/*
 * This is ment to allow the wrapper to listen to dispatched sdata events
 * Can be used to trigger actions on the native side transparently
 *
 * E.g. if a native wrapper shows a live feed of data somewhere (live tiles) he can check if the sdata
 * url dispatched here concerns the same class as the data feed and trigger an internal update
 * without forcing the JS code to know about it
 *
 * link:
 * {
 * 	 Method: PUT|GET|POST
 * 	 Url: what ever url
 * }
 */
exports.dispatcherNotifyAfter = function(link) {
	nativeExtCall.fireMethod("smApp", "dispatcherNotifyAfter", link);
};


/*
 * Invokes the native app to tell loading the app has been finished to avoid a timeout
 */
exports.notifLoaded = function() {
	log && log("notifLoaded");
	nativeExtCall.fireMethod("smApp", "webappLoaded");
};

/*
 * Invokes the native app to tell application is unloaded
 * historyContext	Page history stack
 * 					Used by natoveTestWrapper top store history
 * Can return a message to display (error)
 */
exports.notifUnloaded = function(historyContext) {
	// This is only used by test code
	log && log("OnWebappUnloaded");
	if (window && window.smApp && window.smApp.onWebappUnloaded) {
		return window.smApp.onWebappUnloaded(historyContext ? JSON.stringify(historyContext, null, 2) : null);
	}
};

/*
 * Invokes native app to signal there was a critical error loading the app
 */
exports.notifStartFail = function(msg) {
	nativeExtCall.fireMethod("smApp", "webappLoadFail", msg);
};
/**
 * Returns the test js wrapper
 */
exports.init = function(testMode) {
	if (window && window.smApp) return;
	if (!testMode) return;
	log && log("Creating native nativeApp test wrapper");
	window.smApp = nativeTestApp.create();
	return window.smApp;
};
});

define('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestSensors',['require','exports','module'],function (require, exports, module) {

var _TestNativeWrapper = function() {

	this.getGPSCoordinatesSupported = function() {
		return true;
	};
	this.getGPSCoordinates = function(options) {
		setTimeout(function() {
			var data = {
				Latitude: Math.random() * 100,
				Longitude: Math.random() * 100,
				Succeeded: true
			};
			window.smSensorsJS.getGPSCoordinatesFinished(data);
		}, 1000);
	};
};

exports.create = function() {
	return new _TestNativeWrapper();
};
});

define('syracuse-tablet/html/js/helpers/native/nativeSensors',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestSensors','syracuse-tablet/html/js/helpers/native/nativeExtCall'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeSensors", false);
var nativeTestSensors = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestSensors');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');

var _currentDeferred;

// Global object to be called by native code on pencil events
if (!(window.smSensorsJS)) {
	window.smSensorsJS = {

		/*
		 *  data:
		 *  {
		 *  	Latitude: 1.289374,
		 *  	Longitude: 14.1234124,
		 *  	Succeeded: true/false,
		 *  	Error: unknown,timeout,denied
		 *  }
		 */
		getGPSCoordinatesFinished: function(data) {
			log && log("Got GPS");
			if (_currentDeferred) {
				var def = _currentDeferred;
				_currentDeferred = null;
				log && log("Got GPS: " + JSON.stringify(data || {}));

				def.resolve({
					latitude: data.Latitude,
					longitude: data.Longitude,
					succeeded: data.Succeeded,
					error: data.Error
				});
			}
		}
	};
}
/**
 *
 */
exports.supports = function(capability) {
	if (capability === "GPS") {
		return nativeExtCall.isSupported("smSensors", "getGPSCoordinatesSupported");
	}
	return $.smResolve(false);
};

/**
 */
exports.getGPSCoordinates = function() {
	_currentDeferred = $.Deferred();
	nativeExtCall.fireMethod("smSensors", "getGPSCoordinates");
	return _currentDeferred.promise();
};
/**
 * Returns the test js wrapper
 */
exports.init = function(testMode) {
	if (window && window.smSensors) return;
	if (!testMode) return;
	log && log("Creating native gps test wrapper");
	window.smSensors = nativeTestSensors.create();
	return window.smSensors;
};
});

define('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestBarcode',['require','exports','module'],function (require, exports, module) {

var _TestNativeWrapper = function() {
	this.scanBarcodeSupported = function() {
		return true;
	};
	this.scanBarcode = function(options) {
		var bc = window.prompt("Enter the barcode", "");
		var data = {
			Action: bc == null || bc.trim().length === 0 ? "cancelled" : "ok",
			Content: bc,
			Format: "QR_CODE"
		};
		setTimeout(function() {
			window.smBarcodeJS.scanBarcodeFinished(data);
		}, 100);
	};
};

exports.create = function() {
	return new _TestNativeWrapper();
};
});

define('syracuse-tablet/html/js/helpers/native/nativeBarcode',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestBarcode','syracuse-tablet/html/js/helpers/native/nativeExtCall'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeCamera", false);
var nativeTestBarcode = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestBarcode');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');

var _currentDeferred;

// Global object to be called by native code on pencil events
if (!(window.smBarcodeJS)) {
	window.smBarcodeJS = {

		/*
		 *  data:
		 *  {
		 *  	Action: "ok" || "cancelled" || "error"
		 *  	Content: "Content of scanned barcode"
		 *  	Format: "Barcode format",
		 *  }
		 */
		scanBarcodeFinished: function(data) {
			log && log("Got barcode: " + JSON.stringify(data || {}));
			if (_currentDeferred) {
				var def = _currentDeferred;
				_currentDeferred = null;
				def.resolve({
					action: data.Action,
					content: data.Content,
					format: data.Format
				});
			}
		}
	};
}
/**
 *
 */
exports.supports = function(capability) {
	if (capability === "scanBarcode") {
		return nativeExtCall.isSupported("smBarcode", "scanBarcodeSupported");
	}
	return $.smResolve(false);
};

/**
 * Options are available as parameter but it's not used yet!
 * options:
 * {
 * }
 */
exports.scanBarcode = function(options) {
	// No options yet!
	var param = {};
	_currentDeferred = $.Deferred();
	nativeExtCall.fireMethod("smBarcode", "scanBarcode", param);
	return _currentDeferred.promise();
};

exports.init = function(testMode) {
	if (window && window.smBarcode) return;
	if (!testMode) return;
	log && log("Creating native barcode test wrapper");
	window.smBarcode = nativeTestBarcode.create();
};
});

define('syracuse-tablet/html/js/helpers/native/native',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/native/nativeExtCall','syracuse-tablet/html/js/helpers/native/nativeJSCall','syracuse-tablet/html/js/helpers/native/nativeShare','syracuse-tablet/html/js/helpers/native/nativeLiveTile','syracuse-tablet/html/js/helpers/native/nativeMessages','syracuse-tablet/html/js/helpers/native/nativePenInput','syracuse-tablet/html/js/helpers/native/nativeImage','syracuse-tablet/html/js/helpers/native/nativeVoiceCommands','syracuse-tablet/html/js/helpers/native/nativeApp','syracuse-tablet/html/js/helpers/native/nativeSensors','syracuse-tablet/html/js/helpers/native/nativeBarcode'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("native", false);
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');
var nativeJSCall = require('syracuse-tablet/html/js/helpers/native/nativeJSCall');

var _modules = {
	"nativeShare": require('syracuse-tablet/html/js/helpers/native/nativeShare'),
	"nativeLiveTile": require('syracuse-tablet/html/js/helpers/native/nativeLiveTile'),
	"nativeMessages": require('syracuse-tablet/html/js/helpers/native/nativeMessages'),
	"nativePenInput": require('syracuse-tablet/html/js/helpers/native/nativePenInput'),
	"nativeImage": require('syracuse-tablet/html/js/helpers/native/nativeImage'),
	"nativeVoiceCommands": require('syracuse-tablet/html/js/helpers/native/nativeVoiceCommands'),
	"nativeApp": require('syracuse-tablet/html/js/helpers/native/nativeApp'),
	"nativeSensors": require('syracuse-tablet/html/js/helpers/native/nativeSensors'),
	"nativeBarcode": require('syracuse-tablet/html/js/helpers/native/nativeBarcode')
};

var _capabilities = {
	"nativeApp": "nativeApp",
	"dispatcherListener": "nativeApp",
	"hardwareBackButton": "nativeApp",
	"nativeScrolling": "nativeApp",
	"extLink": "nativeApp",

	"share": "nativeShare",

	"liveTile": "nativeLiveTile",

	"scheduleMessage": "nativeMessages",
	"toastMessages": "nativeMessages",

	"penTextInput": "nativePenInput",
	"penAnnotatedImage": "nativePenInput",
	"penSignatureImage": "nativePenInput",

	"camera": "nativeImage",
	"imageScale": "nativeImage",

	"voiceCommands": "nativeVoiceCommands",

	"scanBarcode": "nativeBarcode",
	"GPS": "nativeSensors"
};

var _capabilitiesModules = {};
/**
 * Initialization is required here to be able to call
 * var nativeVoiceCommmands = require('syracuse-tablet/html/js/helpers/native/native').getModule("voiceCommands");
 */
var _testMode = false;
var _testWrappers = {};

exports.isTestMode = function() {
	return _testMode;
};
exports.hasCapability = function(capability) {
	return exports.getModule(capability) != null;
};
exports.getModule = function(capability) {
	return _capabilitiesModules[capability];
};

exports.callModule = function(capability, functionName) {
	var module = exports.getModule(capability);
	if (!module || !module[functionName]) return null;
	var args = Array.prototype.slice.call(arguments, 2);
	return module[functionName].apply(null, args);
};
/**
 * Allows the test wrapper to add commands in header
 * Must implement appendHeaderTestCmds
 */
exports.appendHeaderTestCmds = function($$root) {
	if (!exports.isTestMode()) return;
	Object.keys(_testWrappers).forEach(function(name) {
		// We call the test wrapper to keep the native interface clean
		var testWrapper = _testWrappers[name];
		if (testWrapper == null || !testWrapper.appendHeaderTestCmds) return;
		testWrapper.appendHeaderTestCmds($$root);
	});
};
exports.init = function() {
	// Register global callback methods that can be access by eventual wrapper
	nativeJSCall.init();
	// Tells wrapper that app starts running
	nativeExtCall.appStartsRunning();
	return $.smResolve().then(function() {
		var _url = jsutils.getCurrentUrl();
		_testMode = _url.query && _url.query.testNativeWrapper === "true";
		nativeExtCall.init(_testMode);
		for (var m in _modules) {
			if (_modules[m].init) {
				_testWrappers[m] = _modules[m].init(_testMode);
			}
		}
	}).then(function() {
		return $.smForEachPromise(Object.keys(_capabilities), function(capability) {
			_capabilitiesModules[capability] = null;
			var moduleName = _capabilities[capability];
			if (moduleName == null) {
				log && log("Native initialization", "No module has been found for capability [" + capability + "]");
				return $.smResolve(false);
			}
			var module = _modules[moduleName];
			if (module == null) {
				log && log("Native initialization", "Unknown native module [" + module + "]");
				return $.smResolve(false);
			}
			if (module.supports == null) {
				log && log("Native initialization", "Module [" + moduleName + "] must implement 'supports' method");
				return $.smResolve(false);
			}
			return module.supports(capability);
		}, function(capability, supported) {
			if (supported === true) {
				_capabilitiesModules[capability] = _modules[_capabilities[capability]];
			}
		});
	}, true);
};
exports.getSupportedDB = function() {
	return nativeExtCall.getSupportedDB();
};
});

define('syracuse-tablet/html/js/helpers/unitTestManager',['require','exports','module'],function (require, exports, module) {

var _$$appElemt = null;

var _pageUpdateCycle = 1

exports.notifPageLoaded = function(step, page) {
	if (!_$$appElemt) return;
	if (step == "before") {
		$('[data-s-ut-page-is-current]').removeAttr("data-s-ut-page-is-current");
		return;
	}
	if (step == "after") {
		if (!page) {
			return;
		}
		// Put page name on vignettes too once they are loaded so we can easily find them too
		page.$$elmt.attr("data-s-ut-page-name", page.pageName);
		if (page.isVignette()) {
			return;
		}
		// Put current page flag on top level page only
		page.$$elmt.attr("data-s-ut-page-is-current", page.pageName);
		return;
	}
};
exports.notifUserCtxChanged = function(ctx, endpoint) {
	if (!_$$appElemt) return;
	_$$appElemt.removeAttr("data-s-ut-user-ctx");
	if (ctx && endpoint) {
		var data = [ctx.$user || "", ctx.$role || "", ctx.$lang || "", endpoint || ""];
		_$$appElemt.attr("data-s-ut-user-ctx", data.join(','));
	}
};
exports.notifDeviceChanged = function(device, orientation) {
	if (!_$$appElemt) return;
	_$$appElemt.attr("data-s-ut-device", device + "," + orientation);
};
exports.arrayAddRowIndex = function($$elmt, idx) {
	if (!_$$appElemt) return;
	$$elmt.attr("data-s-ut-row-idx", idx);
};
exports.addStructElmtId = function($$elmt, info) {
	if (!_$$appElemt) return;
	$$elmt.attr("data-s-ut-elmt-id", info);
};
exports.authAddRightPanelId = function($$elmt, id) {
	if (!_$$appElemt) return;
	if (id) {
		$$elmt.attr("data-s-ut-auth-selected-elmt", id);
	} else {
		$$elmt.removeAttr("data-s-ut-auth-selected-elmt");
	}

};

exports.addBindAttribute = function(ctrl) {
	if (!_$$appElemt) return;
	if (ctrl && ctrl.$$elmt && ctrl.$bind) {
		ctrl.$$elmt.attr("data-s-ut-field-x3name", ctrl.$bind);
	}
};

exports.addPageData = function(page) {
	if (!_$$appElemt) return;
	if (page && page.$$elmt && page.pageData) {
		page.$$elmt.attr("data-s-ut-page-url", page.pageData.$url);
		page.$$elmt.attr("data-s-ut-page-method", page.pageData.$method);
	}
};

exports.authAddTreeElmtId = function($$elmt, info) {
	if (!_$$appElemt) return;
	$$elmt.attr("data-s-ut-auth-elmt-id", info);
};

exports.enable = function() {
	_$$appElemt = $("#s-m-app-id");
};

exports.setPageUpdateCycle = function($$page) {
	_pageUpdateCycle = _pageUpdateCycle + 1;
	$$page.attr("data-s-ut-update-cycle", _pageUpdateCycle);
};

// Make available externally so selenium can interact with this module (Especially functions following below) 
window.$unitTestManager = exports;

// Used to trigger blur event on the element that got the focus
exports.blurFocusElmt = function() {
	$(":focus").blur();
};
});

define('syracuse-tablet/html/js/helpers/environment',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/deps/bowser/bowser','syracuse-tablet/html/deps/platform/platform','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/helpers/unitTestManager'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("environment", false);
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
/**
 * Npm module that detects browsers - Used on desktop
 */
var _bowser = require('syracuse-tablet/html/deps/bowser/bowser');
//platform is used for desktop only - seems that's a reliable library
var _platform = require('syracuse-tablet/html/deps/platform/platform');
var native = require('syracuse-tablet/html/js/helpers/native/native');
var unitTestManager = require('syracuse-tablet/html/js/helpers/unitTestManager');


var _environment = {
	mobileDetect: null,
	currentDesktopOS: null,
	isMobile: false,
	// os for style ios/windows/android
	styleOS: "windows",
	// os name: linux, windows, osx, ios, android
	osName: "windows",
	browserName: "",
	isTestNativeWrapper: false,
	isNativeScrolling: true,
	isUnitTestMode: false
};


/**
 * Returns the 
 */
function _initDefaultOsStyle(mobileDetect) {
	var os = mobileDetect != null && mobileDetect.mobile() != null ? mobileDetect.os() : "windows";
	switch (os) {
		case "AndroidOS":
			return "android";
		case "WindowsMobileOS":
		case "WindowsPhoneOS":
			return "windows";
		case "iOS":
			return "ios";
		case "PalmOS":
		case "BlackBerryOS":
		case "MeeGoOS":
		case "MaemoOS":
		case "JavaOS":
		case "webOS":
		case "badaOS":
		case "BREWOS":
		case "SymbianOS":
		default:
			return "windows";
	}
};

function _initDesktopOs(mobileDetect) {
	if (mobileDetect && mobileDetect.mobile() != null) {
		return null;
	}
	if (!_platform || !_platform.os || !_platform.os.family) {
		return null;
	}
	var family = _platform.os.family.toLowerCase()
	switch (family) {
		case family.indexOf("windows"):
			return "windows";
		case "os x":
			return "osx";
		case "ubuntu":
		case "debian":
		case "fedora":
		case "red Hat":
		case "suse":
			return "linux";
		default:
			return null;
	}
}


/**
 * Just for info
 */
function _initBrowserName(mobileDetect) {
	var res = mobileDetect && mobileDetect.mobile() != null ? mobileDetect.userAgent() : _bowser.name;
	return res ? res.toLowerCase() : "Not detected";
};

/** 
 * uses bowser for desktop and mobile-detect for mobile
 *FDB I did a lot of tests and it's the better way
 *- Eg safari on IOS is not detected as Safari by bowser but mobile-detect doesn't detect correctly browser on a desktop...
 **/
function _checkBrowserName(name) {
	var res = false
	if (_environment.mobileDetect && _environment.mobileDetect.mobile() != null) {
		res = _environment.mobileDetect.userAgent();
		if (!res) return false;
		res = res.toLowerCase();
		res = (res === "ie" && name === "msie") || res === name;
		if (res === true) {
			log && log(name, "detect by mobile-detect");
		}
	} else if (_bowser != null) {
		res = _bowser[name] === true;
		if (res === true) {
			log && log(name, "detect by bowser");
		}
	}
	return res;
};

/**
 * init environment each time the user agent changes
 */
function _defaultInit() {
	// First
	if (_bowser && _bowser._detect) {
		_bowser = _bowser._detect(window.navigator.userAgent);
	}
	_environment.mobileDetect = window.MobileDetect ? new window.MobileDetect(window.navigator.userAgent) : null;
	// Second
	var isMobile = _environment.mobileDetect ? _environment.mobileDetect.mobile() != null : false;
	_environment.currentDesktopOS = _initDesktopOs(_environment.mobileDetect);
	_environment.styleOS = _initDefaultOsStyle(_environment.mobileDetect);
	_environment.isMobile = isMobile;
	_environment.browserName = _initBrowserName(_environment.mobileDetect);
	//  - Used by css (ios we add a top padding to display the status bar)
	_environment.osName = (isMobile ? _environment.mobileDetect.os() : _environment.currentDesktopOS)
	if (_environment.osName) {
		_environment.osName = _environment.osName.toLowerCase();
	}
	// true is mode test native wrapper in query string
	try {
		var _url = jsutils.getCurrentUrl();
		if (_url.query != null) {
			_environment.isUnitTestMode = _url.query.unitTestMode === "true";
			if (_environment.isUnitTestMode === true) {
				unitTestManager.enable();
			}
			_environment.isTestNativeWrapper = _url.query.testNativeWrapper === "true";
		}
	} catch (e) {}
	$(document.body).toggleClass("s-m-mobile-device", isMobile === true).attr({
		"data-style": _environment.styleOS,
		"data-browser": _environment.browserName,
		"data-os": _environment.osName
	});

	if (log) {
		log("Is mobile", _environment.isMobile, "is TestNativeWrapper", _environment.isTestNativeWrapper);
		log("User agent Name", window.navigator.userAgent);
		log("Browser Name: ", _environment.browserName);
		log("Browser OS Name: ", _environment.osName);
		log("Browser OS Style: ", _environment.styleOS);
	}
};

/**
 * Default initialization
 */
(function() {
	_defaultInit();
})();



/**
 * Returns the OS name for style ios/windows/android
 */
exports.getStyleOS = function() {
	return _environment.styleOS;
}

/**
 * check ios/windows/android
 * http://hgoebl.github.io/mobile-detect.js/doc/MobileDetect.html#os
 * For desktop, windows/osx/linux
 */
exports.isOs = function(os) {
	return os && (os.toLowerCase() === _environment.styleOS);
};

/** Key (case insensitive):
 * Accepts multiple arguments msie, msedge...
 * Accepts chrome, firefox, msie, msedge, opera, phantom, safari, seamonkey
 * Returns true/false
 */
exports.checkBrowserName = function() {
	var result = false,
		name, bn;
	for (var i = 0; i < arguments.length; i++) {
		result = result || _checkBrowserName(arguments[i].toLowerCase());
	}
	return result;
};


exports.isDesktop = function() {
	return _environment.isMobile !== true;
}

exports.isMobile = function() {
	return _environment.isMobile === true;
}

exports.isNativeScrolling = function() {
	return _environment.isNativeScrolling === true;
}

exports.isTestNativeWrapper = function() {
	return exports.isDesktop() && _environment.isTestNativeWrapper === true;
}

exports.isAutoUITestMode = function() {
	return _environment.isUnitTestMode === true;
}
exports.getUnitTestMgr = function() {
	return unitTestManager;
};
// Called after having initialized native or when user agent has changed
exports.init = function() {
	_defaultInit();
	// Native scrolling
	if (native.hasCapability("nativeApp")) {
		// Wrapper - We ask the wrapper - Eg: IOS forces non-native for a better UX
		_environment.isNativeScrolling = native.hasCapability("nativeScrolling");
	} else {
		// Not a wrapper - We force native scrolling on mobile devices 
		// Eg: When we test with Chrome simulator we force native
		_environment.isNativeScrolling = exports.isMobile();
	}
}

var _isNativeWrapper;
exports.isNativeWrapper = function() {
	if (_isNativeWrapper == null) {
		_isNativeWrapper = native.hasCapability("nativeApp");
	}
	return _isNativeWrapper;
}
});

define('syracuse-tablet/html/js/utils/waiting',['require','exports','module'],function (require, exports, module) {

var _HTML = '<div style="display:none;z-index:10000" class="s-m-wc-waiting"><div>Loading...</div></div>'

var _count = 0;

var _$$container;

function _waitLocal(promise, $$parent) {
	var deferred = $.Deferred();
	var $$container = $(_HTML);
	$$parent.append($$container.show())
	promise.then(function() {
		$$container.detach();
		deferred.resolve.apply(deferred, arguments);
	}).fail(function() {
		$$container.detach();
		deferred.reject.apply(deferred, arguments);
	})
	return deferred.promise();
}



/** 
 * Show global waiting animation until the passed promise is resolved or rejected
 * If there are parallel requests, the are correctly stacked
 */
function _waitGlobal(promise) {
	var deferred = $.Deferred();
	_pushWait();
	promise.then(function() {
		_popWait();
		deferred.resolve.apply(deferred, arguments);
	}).fail(function() {
		_popWait();
		deferred.reject.apply(deferred, arguments);
	})
	return deferred.promise();
}

exports.waitModal = function(promise, $$parent) {
	if ($$parent) {
		return _waitLocal(promise, $$parent);
	} else {
		return _waitGlobal(promise);
	}
}

exports.reset = function() {
	if (_$$container) {
		_$$container.detach();
		_$$container = null;
	}
	_count = 0;
}

function _pushWait() {
	_count++;
	if (_count === 1) {
		_showWait();
	}
}

function _popWait() {
	_count--;
	if (_count <= 0) {
		_count = 0;
		_hideWait();
	}
}

function _showWait() {
	_ensureInitialized();
	if (!_$$container.is(":visible")) {
		_$$container.css("display", "table");
	}
}

function _hideWait() {
	_ensureInitialized();
	if (_$$container.is(":visible")) {
		_$$container.css("display", "none");
	}
}

function _ensureInitialized() {
	if (_$$container) {
		return;
	}
	var $$app = $("#s-m-app-id");
	// TODO: Move styles to css/less, add animation
	_$$container = $(_HTML);
	$$app.append(_$$container);
}
});

define('syracuse-tablet/html/js/ui/siteLayout',['require','exports','module','syracuse-tablet/html/js/app/globals','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/environment','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

// var serverLog = require('syracuse-tablet/html/js/helpers/serverLog');
var globals = require('syracuse-tablet/html/js/app/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var environment = require('syracuse-tablet/html/js/helpers/environment');
var modules = require('syracuse-tablet/html/js/common/modules');

var _getTransformScale = function() {
	var res = _internalParameters && _internalParameters.pageParameters ? _internalParameters.pageParameters.scale : null;
	return res == null || res <= 0 ? 1 : res;
};

/*
 *
 * This module is responsibe to layout main layout components in the browser window:
 *
 * HEADER    | AUTHORING
 * CONTENT   | PANEL
 * FOOTER    |
 *
 */


/*
 * Bootstrap min sizes per level
 * =============================
 *
 * xs:                  480px;
 * sm:                  768px;
 * md:                  992px;
 * lg:                  1200px;
 *
 */

/*
 * Some devices
 * ============
 *
 * iPad: 1024×768
 * Nexus 7: 1920 × 1200
 * Nexus 10: 2560x1600
 *
 */

/*
 * Needs to be aligned with bootstrap responsiveness!
 * Not, pixel sized defined here match values of media queries or top / left / width /height css attributes.
 * But these are not physical pixels because some devices have a pixel ration physical > logical
 *
 * See: http://bjango.com/articles/min-device-pixel-ratio/
 * We need to work with logical pixel units
 *
 * E.g. Nexus 10 has a 2560x1600 display but reports 1280x800 because ratio is 2.0
 * E.g. Nexus 5 has a 1080x1920 display but reports 360x1080 because ratio is 3.0
 *
 */
//Parameters that are actually used (calculated and maybe changed based on _layoutParameters)
var _layoutInfo;
var _internalParameters;
var _lastWindowWidth;
var _lastWindowHeight;
$(function() {
	_lastWindowWidth = $(window).width() / _getTransformScale();
	_lastWindowHeight = $(window).height() / _getTransformScale();
});

/*
 * To detect orientation change in browser window compared to last call of this function
 */
function _getWindowOrientation() {
	var width = $(window).width() / _getTransformScale();
	var height = $(window).height() / _getTransformScale();
	var ratio = width / height;
	if (ratio < 1) {
		return "portrait";
	} else {
		return "landscape";
	}
}

var _getCurrentDeviceType = function() {
	var currentDeviceType;
	var a = navigator.userAgent.toLowerCase();

	if (a.indexOf("iphone") >= 0) {
		currentDeviceType = "smartphone";
	} else if (a.indexOf("ipad") >= 0) {
		currentDeviceType = "tablet";
	} else {
		if (a.indexOf("mobile") >= 0) { // android smartphones report "mobile" while tablets do not
			currentDeviceType = "smartphone";
		} else {
			currentDeviceType = "tablet";
		}
	}
	return currentDeviceType;
};

/*
 *
 * NOTE: IF you change s-m-auth-col-simulate* classes assigned to a device here, you need to also check
 * the CSS media selectors in thirdparty_custom.less
 *
 */
var _deviceSizes = {
	nexus5: {
		width: 640, // Nexus 5
		height: 360,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-xs",
			landscape: "s-m-auth-col-simulate-sm"
		},
		deviceType: "smartphone",
		orientations: ["portrait", "landscape"]
	},
	nexus7: { // Nexus 7
		width: 960,
		height: 600,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-sm",
			landscape: "s-m-auth-col-simulate-md"
		},
		deviceType: "tablet",
		orientations: ["portrait", "landscape"]
	},
	nexus10: { // Nexus 10
		width: 1280,
		height: 800,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-sm",
			landscape: "s-m-auth-col-simulate-lg"
		},
		deviceType: "tablet",
		orientations: ["portrait", "landscape"]
	},
	ipad: {
		width: 1024,
		height: 768,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-sm",
			landscape: "s-m-auth-col-simulate-lg"
		},
		deviceType: "tablet",
		orientations: ["portrait", "landscape"]
	},
	iphone4: {
		width: 480,
		height: 320,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-xs",
			landscape: "s-m-auth-col-simulate-xs"
		},
		deviceType: "smartphone",
		orientations: ["portrait", "landscape"]
	},
	iphone5: {
		width: 568,
		height: 320,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-xs",
			landscape: "s-m-auth-col-simulate-xs"
		},
		deviceType: "smartphone",
		orientations: ["portrait", "landscape"]
	},
	iphone6: {
		width: 667,
		height: 375,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-xs",
			landscape: "s-m-auth-col-simulate-sm"
		},
		deviceType: "smartphone",
		orientations: ["portrait", "landscape"]
	},
	iphone6plus: {
		width: 960,
		height: 540,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-xs",
			landscape: "s-m-auth-col-simulate-md"
		},
		deviceType: "smartphone",
		orientations: ["portrait", "landscape"]
	}
};

/*
 * Classes that can be put on a container to override the css media selector that use device screen sizes
 */
var _bootstrapTweakClasses = ["s-m-auth-col-simulate-xs", "s-m-auth-col-simulate-sm", "s-m-auth-col-simulate-md", "s-m-auth-col-simulate-lg"];


var _currentOrientation = _getWindowOrientation();
var _splitterWidth = 15;
// Parameters that are currently applied
var _layoutParameters = {
	authPanelRight: {
		width: 230,
		splitterWidth: _splitterWidth,
		visible: false
	},
	authPanelLeft: {
		width: 300,
		splitterWidth: _splitterWidth,
		visible: false
	},
	authPanelHeader: {
		height: 34,
	},
	authPanelFooter: {
		height: 34,
	},
	pageParameters: {
		forcePreview: false,
		forceAutoScale: true,
		scale: 1
	},
};
// Better initilization for pageParameters
_layoutParameters.pageParameters.orientation = _currentOrientation;
_layoutParameters.pageParameters.deviceType = _getCurrentDeviceType();


/** Header/Footer height */
var _heights = {
	"tablet": {
		header: 50,
		footer: {
			opened: 50,
			closed: 20
		}
	},
	"smartphone": {
		header: 50,
		footer: {
			opened: 0,
			closed: 0
		}
	}
};
/*
 * Triggered by JqueryMobile helpers - Only on mobile device
 */
exports.onWindowOrientation = function(evt, opts) {
	if (!evt || evt.orientation == null) return;
	opts = opts || {};
	// serverLog.log("onWindowOrientation")
	opts.orientationChanged = evt.orientation !== _currentOrientation;
	opts.deviceChanged = false;
	_currentOrientation = evt.orientation;
	// 200 is important to avoid some refresh issues
	setTimeout(function() {
		_layoutMainContainers(evt, opts);
	});
};

/*
 * Triggered by browser window resize on the desktop
 *
 * This event is triggered also on mobile devices even if we can't change the size of the browser
 * (e.g. on orientation change or keyboard popup, fullscreen browser, non fullscreen browser)
 */
var _lastUserAgent = null;
exports.onWindowResize = function(evt, opts) {
	if (!evt) return;
	opts = opts || {};
	opts.orientationChanged = false;
	opts.deviceChanged = false;
	var userAgentChanged = _lastUserAgent == null || _lastUserAgent !== navigator.userAgent.toLowerCase();
	// serverLog.log("onWindowResize");
	if (_internalParameters && _internalParameters.pageParameters.forcePreview !== true) {
		// In preview mode orientation is given by the device
		// In !isDesktop mode orientation is handled by onWindowOrientation
		// We have to set orientation in desktop without preview mode
		if (environment.isDesktop()) {
			var prev = _currentOrientation;
			_currentOrientation = _getWindowOrientation();
			opts.orientationChanged = prev !== _currentOrientation;
		}
		// _lastUserAgent checked for mobile and desktop devices to allow CHrome Mobile Devices Simulator on desktop
		if (userAgentChanged) {
			_lastUserAgent = navigator.userAgent.toLowerCase();
			// In simulation assume that device changes with user agent
			opts.deviceChanged = true;
		}
	}
	if (userAgentChanged) {
		// In any cases
		environment.init();
		document.location.reload();
		return;
	}
	// If we are on a desktop, just resize all the time, no need to make it more complicated than that.
	if (environment.isDesktop()) {
		_layoutMainContainers(evt, opts);
	}

	// We endup here, if we are on a mobile device

	// On a mobile device there are only a few options when a resize is actually triggered:
	// 1) Orientation has changed: Size change event because width and height have been swapped. 
	//    => We need to revalidate the layout (!)
	//
	// 2) Go to browser fullscreen: Revalidate layout (realign footer/header, scrollers)
	//    => We need to revalidate the layout (!)
	//
	// 3) Keyboard shows up: 
	//    => WE DO NOT WANT DO REVALIDATE THE LAYOUT SINCE WE WILL LOOSE FOCUS

	var width = $(window).width() / _getTransformScale();
	var height = $(window).height() / _getTransformScale();

	// Keyboard show up detection is done by ensuring the width of the screen has not changed during the resize

	// Special case height changes but width does not change:
	// If the width did not change during a resize BUT the height got bigger,
	// this is an indicator that the keyboard has disappeared.
	// If the keyboard disappeared its safe to to a re-validation of the layout
	// in fact, ITS NECESSARRY. Since a switch between portrait and landscape mode while
	// the keyboard is active triggers a re-validation of the layout using the smaller layout (minus the keyboard)
	// So once the keyboard disappears the revalidation ensures the footer is not in the middle of the screen

	if (width === _lastWindowWidth && height <= _lastWindowHeight) {
		var navStack = modules.get("navStack").getMainStack();
		var currentPage = navStack && navStack.getTopPage();
		if (currentPage) {
			currentPage.notifyScrollerUpdate(true);
		}
		return;
	}

	// One more special case
	// On android, the software keyboards height depends on the
	// type of input field.
	// So on focus change, there is a resize since the keyboard may shrink or grow
	// This is why we take into account the new height only if:
	// Width changed also (orientation change)
	// Height gets bigger (keyboard disappears)
	if (width !== _lastWindowWidth || height > _lastWindowHeight) {
		// Wrapped by "if" to ensure we remember only the maximum height of the current orientation
		_lastWindowHeight = height;
	}

	_lastWindowWidth = width;
	_layoutMainContainers(evt, opts);
};

/*
 * Triggered by application JS code - triggerResizeInternal handler
 */
exports.onWindowResizeInteral = function(evt, opts) {
	if (!evt) return;
	opts = opts || {};
	var params = opts.layout ? opts.layout.pageParameters : null;
	if (params && params.orientation && params.forcePreview) {
		opts.orientationChanged = _currentOrientation !== params.orientation;
		_currentOrientation = params.orientation;
	}
	if (params && params.device && params.forcePreview) {
		var typ = _deviceSizes[params.device];
		typ = typ ? typ.deviceType : "";
		opts.deviceChanged = typ !== _getDeviceType();
	}
	_layoutMainContainers(evt, opts);
};
/*
 * Layout main containers like header, content, footer, authoring panel
 */
function _layoutMainContainers(resizeEvt, opts) {
	var firstCall = _lastUserAgent == null;
	if (_lastUserAgent == null) {
		// Optimization for device simulator - prevent a deviceChanged at the first orientation changed
		_lastUserAgent = navigator.userAgent.toLowerCase();
	}
	opts = opts || {};
	opts.resizeEvent = resizeEvt;
	if (opts.layout) {
		_layoutParameters = $.extend(true, {}, _layoutParameters, opts.layout);
	}

	var appClass = null;

	var authPanelRightWidth = 0;
	var authPanelLeftWidth = 0;
	var authPanelHeaderHeight = 0;
	var authPanelFooterHeight = 0;
	var authPanelRightSplitterWidth = 0;
	var authPanelLeftSplitterWidth = 0;

	var $$authRight = $("#s-m-auth-panel-right-id");
	var $$authLeft = $("#s-m-auth-panel-left-id");
	var $$app = $("#s-m-app-id");
	var $$appContainer = $("#s-m-app-container-id");

	_internalParameters = $.extend(true, {}, _layoutParameters);
	var pageParams = _internalParameters.pageParameters;
	if (_internalParameters.authPanelRight.visible) {
		authPanelRightWidth = _internalParameters.authPanelRight.width;
		authPanelRightSplitterWidth = _internalParameters.authPanelRight.splitterWidth;

		_layoutAuthPanelRight();
		pageParams.forcePreview = true;
	}
	if (_internalParameters.authPanelLeft.visible) {
		authPanelLeftWidth = _internalParameters.authPanelLeft.width;
		authPanelLeftSplitterWidth = _internalParameters.authPanelLeft.splitterWidth;

		_layoutAuthPanelLeft();
		pageParams.forcePreview = true;
	}
	if (_internalParameters.authPanelHeader.visible) {
		authPanelHeaderHeight = _internalParameters.authPanelHeader.height;
		_layoutAuthPanelHeader();
	}
	if (_internalParameters.authPanelFooter.visible) {
		authPanelFooterHeight = _internalParameters.authPanelFooter.height;
		_layoutAuthPanelFooter();
	}
	// We apply scale factor if any
	var applicationWidth = $(window).width() / _getTransformScale();
	var applicationWidth = applicationWidth - authPanelRightWidth - authPanelRightSplitterWidth - authPanelLeftWidth - authPanelLeftSplitterWidth;
	var applicationHeight = $(window).height() / _getTransformScale();
	var applicationHeight = applicationHeight - authPanelHeaderHeight - authPanelFooterHeight;

	var appView;
	var forcePreview = pageParams.forcePreview === true;
	// Remove wrapper if exists
	if ($$app.parent().is(".s-m-device-wrapper")) {
		$$app.unwrap();
	}
	// if forcePreview adds a wrapper to simulate the tablet/iphone body
	if (forcePreview && environment.isDesktop()) {
		var template = pageParams.device ? _deviceSizes[pageParams.device] : null;
		if (!template) {
			template = _deviceSizes["nexus10"];
		}
		// Border for application wrapper
		var wrapBorder = 15;
		// Unscaled application view rectangle
		appView = {
			left: 0,
			top: 0,
			width: pageParams.orientation === "landscape" ? template.width : template.height,
			height: pageParams.orientation === "landscape" ? template.height : template.width,
		};
		// Wrapper W/H
		var wrapH = appView.height + 2 * wrapBorder,
			wrapW = appView.width + 2 * wrapBorder;
		// Auto scale
		if (pageParams.forceAutoScale) {
			pageParams.scale = Math.min(Math.min(applicationWidth / wrapW, applicationHeight / wrapH), 1);
		}
		//Center
		appView.left = Math.max((applicationWidth - wrapW * pageParams.scale) / 2, 0);
		appView.top = Math.max((applicationHeight - wrapH * pageParams.scale) / 2, 0);
		// Class that indicates device simulation status
		appClass = template.bootstrapTweakClass[pageParams.orientation];
		// Wrapp the application into device container to better display the devise structure with round corners...
		var $$wrapper = $('<section class="s-m-device-wrapper"></section>"');
		var wrapCss = {
			top: appView.top + "px",
			left: appView.left + "px",
			width: wrapW + "px",
			height: wrapH + "px"
		};
		if (pageParams.scale !== 1) {
			wrapCss["transform"] = "scale(" + pageParams.scale + ", " + pageParams.scale + ")",
				wrapCss["transform-origin"] = "left top";
		}
		$$wrapper.css(wrapCss);
		$$app.wrap($$wrapper);
		// Container including header, content, footer
		$$app.css({
			top: wrapBorder + "px",
			left: wrapBorder + "px",
			width: appView.width + "px",
			height: appView.height + "px",
			position: "absolute"
		});
	} else {
		// No preview - application is displayed full page
		appView = {
			left: 0,
			top: 0,
			width: applicationWidth,
			height: applicationHeight
		};
		pageParams.orientation = _currentOrientation;
		// Container including header, content, footer
		$$app.css({
			top: appView.top,
			left: appView.left,
			width: appView.width,
			height: appView.height
		});
	}
	// keeps only the right class
	$$app.removeClass(_bootstrapTweakClasses.join(' '));
	if (appClass) {
		$$app.addClass(appClass);
	}
	// Container including header, content, footer
	$$appContainer.css({
		top: authPanelHeaderHeight,
		left: authPanelLeftWidth + authPanelLeftSplitterWidth,
		width: applicationWidth,
		height: applicationHeight
	});
	// Status to manage css
	$$appContainer.toggleClass("s-m-preview", forcePreview);
	// Allow other components like authoring panel or page content to be resized
	var info = {
		// updateLayout = true - no deend to relaod data - needed for arrays or other controls that are build computeLayout (calculate width/height)
		updateLayout: true,
		application: appView,
		// True if resize triggered by authoring
		authoringUpdate: opts.authoringUpdate === true,
		// Action want to preserve the scrolling of the page
		preserveScroll: opts.preserveScroll === true || opts.authoringUpdate === true,
		afterMainPageLoaded: opts.afterMainPageLoaded === true
	};
	if (opts.resizeEvent) {
		/**
		 * Propagated to computeLayout method to be able to identify resizeEvent.type - 'resize' or 'resizeInternal'
		 **/
		info.resizeEvent = opts.resizeEvent;
	}
	info.orientationChanged = opts.orientationChanged;
	info.deviceChanged = opts.deviceChanged;
	if (environment.isAutoUITestMode() && (firstCall || info.orientationChanged || info.deviceChanged)) {
		environment.getUnitTestMgr().notifDeviceChanged(_getDeviceType(), pageParams.orientation);
	}

	_layoutInfo = {
		application: appView,
		orientation: pageParams.orientation,
		deviceType: _getDeviceType()
	};
	notifications.publish("sm.main.layout.changed", info, pageParams.orientation, _getDeviceType());
}

function _layoutAuthPanelRight() {
	// No scale transform
	var width = $(window).width();
	var height = $(window).height();
	var $$auth = $("#s-m-auth-panel-right-id");
	var $$splitter = $("#s-m-auth-splitter-right-id");

	var authPanelHeaderHeight = 0;
	var authPanelFooterHeight = 0;
	if (_internalParameters.authPanelHeader.visible) {
		authPanelHeaderHeight = _internalParameters.authPanelHeader.height;
	}
	if (_internalParameters.authPanelFooter.visible) {
		authPanelFooterHeight = _internalParameters.authPanelFooter.height;
	}

	$$auth.css({
		left: width - _internalParameters.authPanelRight.width,
		top: authPanelHeaderHeight,
		width: _internalParameters.authPanelRight.width,
		height: height - authPanelHeaderHeight - authPanelFooterHeight
	});
	$$splitter.css({
		left: width - _internalParameters.authPanelRight.width - _internalParameters.authPanelRight.splitterWidth,
		top: authPanelHeaderHeight,
		width: _internalParameters.authPanelRight.splitterWidth,
		height: height - authPanelHeaderHeight - authPanelFooterHeight
	});
}

function _layoutAuthPanelLeft() {
	// No scale transform
	var width = $(window).width();
	var height = $(window).height();
	var $$auth = $("#s-m-auth-panel-left-id");
	var $$splitter = $("#s-m-auth-splitter-left-id");

	var authPanelHeaderHeight = 0;
	var authPanelFooterHeight = 0;
	if (_internalParameters.authPanelHeader.visible) {
		authPanelHeaderHeight = _internalParameters.authPanelHeader.height;
	}
	if (_internalParameters.authPanelFooter.visible) {
		authPanelFooterHeight = _internalParameters.authPanelFooter.height;
	}

	$$auth.css({
		left: 0,
		top: authPanelHeaderHeight,
		width: _internalParameters.authPanelLeft.width,
		height: height - authPanelHeaderHeight - authPanelFooterHeight
	});
	$$splitter.css({
		left: _internalParameters.authPanelLeft.width,
		top: authPanelHeaderHeight,
		width: _internalParameters.authPanelLeft.splitterWidth,
		height: height - authPanelHeaderHeight - authPanelFooterHeight
	});
}

function _layoutAuthPanelHeader() {
	// No scale transform
	var width = $(window).width();
	var height = $(window).height();
	var $$auth = $("#s-m-auth-panel-header-id");
	$$auth.css({
		left: 0,
		top: 0,
		width: width,
		height: _internalParameters.authPanelHeader.height,
		overflow: "hidden"
	});
}

function _layoutAuthPanelFooter() {
	// No scale transform
	var width = $(window).width();
	var height = $(window).height();
	var $$auth = $("#s-m-auth-panel-footer-id");
	$$auth.css({
		left: 0,
		top: height - _internalParameters.authPanelFooter.height,
		width: width,
		height: _internalParameters.authPanelFooter.height
	});
}

exports.getDeviceTemplates = function() {
	return _deviceSizes;
};
/**
 * return smartphone/tablet
 */
var _getDeviceType = function() {
	// Preview mode?
	if (_internalParameters && _internalParameters.pageParameters && _internalParameters.pageParameters.forcePreview === true) {
		var device = _internalParameters.pageParameters.device;
		return device && _deviceSizes[device] ? _deviceSizes[device].deviceType : "tablet";
	}
	// Check if auto device recognition is overridden by user settings
	var settings = globals.getGlobalSettings();
	if (settings == null || settings["device-type"] === "auto") {
		return _getCurrentDeviceType();
	}
	return settings["device-type"];
};
/* 
 * only tablet or smartphone
 * Use this to detect if it's a "smartphone" or a "tablet"
 * This function will return the physical device or the simulated one of dev mode or authoring is active.
 */
exports.getDeviceType = _getDeviceType;

exports.getPageOrientation = function() {
	return _internalParameters.pageParameters.orientation;
};

exports.getCurrentLayoutSettings = function() {
	var o = $.extend(true, {}, _layoutParameters);
	return o;
};
exports.getTransformScale = _getTransformScale;

exports.splitterWidth = _splitterWidth;
exports.onWindoReisze = _splitterWidth;

/**
 * {
 *   application: {
 *     width: ...
 *     height: ...
 *   }
 */
exports.getLayoutInfo = function() {
	return _layoutInfo;
}
});

define('syracuse-tablet/html/js/helpers/developmentPage',['require','exports','module','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/siteLayout','syracuse-tablet/html/js/storage/localStorage','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var siteLayout = require('syracuse-tablet/html/js/ui/siteLayout');
var localStorage = require('syracuse-tablet/html/js/storage/localStorage');

var modules = require('syracuse-tablet/html/js/common/modules');


var _deltaExample = '\
{\n \
  "WMENU": 3,\n\
  "$properties": {\n\
    "WMENU": {\n\
      "$isReadOnly": true\n\
    }\n\
  }\n\
}';

var _gotoExample = {
	url: "http://localhost:8124/mobile2/x3/erp/GX3APP/AQMDEVICE?representation=AQMCRUDM.$query&count=50",
	//url: "html:///login",
	//url: "http://localhost:8124/mobile2/x3/erp/GX3APP/AQMDEVICE('10')?representation=AQMCRUDM.$edit",
	//url: "http://localhost:8124/mobile2/syracuse/collaboration/syracuse/mobileDashboards(dashboardName%20eq%20'STD_X3_ERP_EXPENSES_DASHBOARD')?representation=mobileDashboard.$details",
	method: "GET"
};

var _template = '\
	<div id="page_dev_mode" style="margin: 0; width: auto; position: absolute; z-index: 9999"> \
    <div class="modal-dialog" style="margin: 0; width: auto;"> \
		<div class="modal-content" style="width: auto;"> \
		    <div class="modal-header"> \
				<h4 class="modal-title">{{title}}</h4> \
		    </div> \
		    <div class="modal-body"> \
				<div class="form-group"> \
					<label>{{label_device}}</label>\
					<select class="form-control" id="dev-select-device"> \
					{{#each devices}}\
						<option value="{{this.device}}.{{this.orientation}}" {{#if this.selected}}selected{{/if}}>\
						{{this.description}}\
						</option>\
					{{/each}}\
					</select>\
					<span class="input-group"> \
						<input id="dev-device-scale" type="checkbox" {{#if scaleChecked}}checked{{/if}}>{{label_scale}} \
					</span> \
				</div> \
				<div class="form-group"> \
					<span class="input-group"> \
						<input id="dev-cache" type="checkbox" {{#if cacheChecked}}checked{{/if}}>{{label_cache}} \
	  				</span> \
					<span class="input-group"> \
						<input id="dev-app-force-update" type="checkbox" {{#if alwaysUpdateChecked}}checked{{/if}}>Always update apps \
					</span> \
				</div> \
				<div class="form-group"> \
					<label>Goto URL</label><br>\
					<input id="s-m-goto-url-id" value="{{gotoUrl}}"></input><br>\
					<input id="s-m-goto-method-id" value="{{gotoMethod}}"></input><br>\
					<button type="button" class="btn" id="btn-goto-id">Go</button> \
					<button type="button" class="btn" id="btn-curl-id">Current url</button> \
				</div> \
				<div class="form-group"> \
					<label>SData-Delta</label><br>\
					<textarea rows="8" cols="35" id="s-m-delta-json-id" style="white-space: nowrap;">{{deltaExample}}</textarea><br>\
					<button type="button" class="btn" id="btn-apply-delta-id">Apply</button> \
				</div> \
			</div> \
		    <div class="modal-footer"> \
				<button type="button" class="btn" id="btn_dev_close">{{label_close}}</button> \
				<button type="button" class="btn btn-default" disabled="true" id="btn_dev_apply">{{label_apply}}</button> \
    			<button type="button" class="btn" id="btn_dev_ok">{{label_ok}}</button> \
			</div> \
		</div> \
	</div> \
	</div>';

var _show = function() {
	_setActive(true);

	if ($("#page_dev_mode").is(":visible")) {
		return;
	}
	var modalHtml = Handlebars.compile(_template);
	var devs = siteLayout.getDeviceTemplates();

	var ctx = {
		title: "Development settings",

		label_device: "Device",
		devices: [],

		label_scale: "Scale if needed",

		label_cache: "Disable caching",

		label_close: "Cancel",
		label_ok: "Ok",
		label_apply: "Apply",

		scaleChecked: localStorage.getItem("devPanelScale") === "true",
		cacheChecked: localStorage.getItem("devPanelCache") === "true",
		alwaysUpdateChecked: localStorage.getItem("alwaysUpdateChecked") === "true",
		deltaExample: _deltaExample,
		gotoUrl: _gotoExample.url,
		gotoMethod: _gotoExample.method
	};

	ctx.devices.push({
		device: "<No emulation>",
		orientation: "landscape",
		description: "<No emulation>"
	});

	for (var dev in devs) {
		devs[dev].orientations.forEach(function(o) {
			var devName = dev;
			var orientName = o;

			var opt = {
				device: dev,
				orientation: o,
				description: devName + " (" + o + ")"
			};
			ctx.devices.push(opt);
		});
	}
	var lastDev = localStorage.getItem("devPanelDevice") || "<No emulation>.landscape";
	ctx.devices.forEach(function(d) {
		d.selected = (lastDev === d.device + "." + d.orientation);
	});
	modalHtml = modalHtml(ctx);
	$("body").append($(modalHtml));
	var $$page = $("#page_dev_mode");
	$$page.draggable();

	$("#btn-apply-delta-id", $$page).on("click", function() {
		_applyDelta();
	});
	$("#btn-goto-id", $$page).on("click", function() {
		var url = $("#s-m-goto-url-id").val();
		var method = $("#s-m-goto-method-id").val();
		modules.get("navHelper").gotoUrl(url, method).fail(function(e) {
			console.log(e);
		});
	});

	$("#btn-curl-id", $$page).on("click", function() {
		_updateUrl();
	});

	$("#btn_dev_ok", $$page).on("click", function() {
		apply();
		$$page.remove();
	});
	$("#btn_dev_apply", $$page).on("click", function() {
		apply();
		// If we click a second time on the button the rendering is not good (panels)
		$("#btn_dev_apply", $$page).attr("disabled", "true");
	});

	$("#btn_dev_close", $$page).on("click", function() {
		_setActive(false);
		$$page.remove();
	});
	$("#dev-select-device", $$page).on("change", function() {
		$("#btn_dev_apply", $$page).removeAttr("disabled");
	});
	$('input[type="checkbox"]', $$page).on("click", function() {
		$("#btn_dev_apply", $$page).removeAttr("disabled");
	});
	var apply = function() {
		var device = $$page.find("#dev-select-device").val();
		var dev = device.split(".");
		var params = {
			layout: {
				pageParameters: {}
			}
		};
		localStorage.setItem("devPanelDevice", device);
		if (device === "<No emulation>.landscape") {
			params.layout.pageParameters.forcePreview = false;
			params.layout.pageParameters.forceAutoScale = false;
			params.layout.pageParameters.device = "tablet";
			params.layout.pageParameters.orientation = "landscape";
		} else {
			params.layout.pageParameters.device = dev[0];
			params.layout.pageParameters.orientation = dev[1];
			params.layout.pageParameters.forcePreview = true;

			if ($("#dev-device-scale", $$page).is(":checked") === true) {
				params.layout.pageParameters.forceAutoScale = true;
				localStorage.setItem("devPanelScale", "true");
			} else {
				params.layout.pageParameters.forceAutoScale = false;
				localStorage.setItem("devPanelScale", "false");
			}
		}

		if ($("#dev-cache", $$page).is(":checked") === true) {
			localStorage.setItem("devPanelCache", "true");
			//cache.disableCache(true);
		} else {
			localStorage.setItem("devPanelCache", "false");
			//cache.disableCache(false);
		}

		if ($("#dev-app-force-update", $$page).is(":checked") === true) {
			localStorage.setItem("alwaysUpdateChecked", "true");
			//cache.disableCache(true);
		} else {
			localStorage.setItem("alwaysUpdateChecked", "false");
			//cache.disableCache(false);
		}


		uiutils.triggerResizeInternal(params);
	};

	apply();
};

function _setActive(flag) {
	localStorage.setItem("devPanelOpen", flag ? "true" : "false");
}

exports.restoreOnStartup = function() {
	if (localStorage.getItem("devPanelOpen") === "true") {
		exports.show();
	}
}

exports.show = _show;

function _applyDelta() {
	try {
		var json = $("#s-m-delta-json-id").val();
		var obj = JSON.parse(json);

		console.log("Data: ");
		console.log(obj);

		var $$page = $(".s-m-page.s-m-full[data-controller-id]").first();
		var controllerId = $$page.attr("data-controller-id");
		var controller = modules.get("controller").findController(controllerId);

		console.log("Controller: ");
		console.log(controller);
		controller && controller._mergeDelta(obj);

		console.log("Delta applied");
	} catch (e) {
		alert(e.message);
	}
}

function _updateUrl() {
	var navStack = modules.get("navStack").getMainStack();
	var currentPage = navStack && navStack.getTopPage();
	var url = currentPage.pageData && currentPage.pageData.$url;
	var method = currentPage.pageData && currentPage.pageData.$method || "GET";

	var href = window.location.href;
	var i = href.indexOf("?");
	if (i > -1) {
		href = href.substr(0, i);
	}
	href = href + "?url=" + encodeURIComponent(url);
	href = href + "&method=" + encodeURIComponent(method);

	window.location.href = href;
}
});

define('syracuse-tablet/html/js/helpers/handlebarsHelpers',['require','exports','module'],function (require, exports, module) {

exports.registerHelpers = function(Handlebars) {

	/**
	 * USAGE
	 * 		{{#smCompare name "Code"}}
	 *      {{#smCompare name ">" 5}}
	 */
	Handlebars.registerHelper('smCompare', function(lvalue, operator, rvalue, options) {
		var operators, result;

		if (arguments.length < 3) {
			throw new Error("Handlerbars Helper 'compare' needs 2 parameters");
		}

		if (options === undefined) {
			options = rvalue;
			rvalue = operator;
			operator = "===";
		}

		operators = {
			'==': function(l, r) {
				return l == r;
			},
			'===': function(l, r) {
				return l === r;
			},
			'!=': function(l, r) {
				return l != r;
			},
			'!==': function(l, r) {
				return l !== r;
			},
			'<': function(l, r) {
				return l < r;
			},
			'>': function(l, r) {
				return l > r;
			},
			'<=': function(l, r) {
				return l <= r;
			},
			'>=': function(l, r) {
				return l >= r;
			},
			'typeof': function(l, r) {
				return typeof l == r;
			}
		};

		if (!operators[operator]) {
			throw new Error("Handlerbars Helper 'compare' doesn't know the operator " + operator);
		}

		result = operators[operator](lvalue, rvalue);

		if (result) {
			return options.fn(this);
		} else {
			return options.inverse(this);
		}

	});
};
});

/*!

 handlebars v4.0.5

Copyright (C) 2011-2015 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license
*/
!function(a,b){"object"==typeof exports&&"object"==typeof module?module.exports=b():"function"==typeof define&&define.amd?define('syracuse-tablet/html/deps/handlebars.min',[],b):"object"==typeof exports?exports.Handlebars=b():a.Handlebars=b()}(this,function(){return function(a){function b(d){if(c[d])return c[d].exports;var e=c[d]={exports:{},id:d,loaded:!1};return a[d].call(e.exports,e,e.exports,b),e.loaded=!0,e.exports}var c={};return b.m=a,b.c=c,b.p="",b(0)}([function(a,b,c){function d(){var a=r();return a.compile=function(b,c){return k.compile(b,c,a)},a.precompile=function(b,c){return k.precompile(b,c,a)},a.AST=i["default"],a.Compiler=k.Compiler,a.JavaScriptCompiler=m["default"],a.Parser=j.parser,a.parse=j.parse,a}var e=c(1)["default"];b.__esModule=!0;var f=c(2),g=e(f),h=c(21),i=e(h),j=c(22),k=c(27),l=c(28),m=e(l),n=c(25),o=e(n),p=c(20),q=e(p),r=g["default"].create,s=d();s.create=d,q["default"](s),s.Visitor=o["default"],s["default"]=s,b["default"]=s,a.exports=b["default"]},function(a,b){b["default"]=function(a){return a&&a.__esModule?a:{"default":a}},b.__esModule=!0},function(a,b,c){function d(){var a=new h.HandlebarsEnvironment;return n.extend(a,h),a.SafeString=j["default"],a.Exception=l["default"],a.Utils=n,a.escapeExpression=n.escapeExpression,a.VM=p,a.template=function(b){return p.template(b,a)},a}var e=c(3)["default"],f=c(1)["default"];b.__esModule=!0;var g=c(4),h=e(g),i=c(18),j=f(i),k=c(6),l=f(k),m=c(5),n=e(m),o=c(19),p=e(o),q=c(20),r=f(q),s=d();s.create=d,r["default"](s),s["default"]=s,b["default"]=s,a.exports=b["default"]},function(a,b){b["default"]=function(a){if(a&&a.__esModule)return a;var b={};if(null!=a)for(var c in a)Object.prototype.hasOwnProperty.call(a,c)&&(b[c]=a[c]);return b["default"]=a,b},b.__esModule=!0},function(a,b,c){function d(a,b,c){this.helpers=a||{},this.partials=b||{},this.decorators=c||{},i.registerDefaultHelpers(this),j.registerDefaultDecorators(this)}var e=c(1)["default"];b.__esModule=!0,b.HandlebarsEnvironment=d;var f=c(5),g=c(6),h=e(g),i=c(7),j=c(15),k=c(17),l=e(k),m="4.0.5";b.VERSION=m;var n=7;b.COMPILER_REVISION=n;var o={1:"<= 1.0.rc.2",2:"== 1.0.0-rc.3",3:"== 1.0.0-rc.4",4:"== 1.x.x",5:"== 2.0.0-alpha.x",6:">= 2.0.0-beta.1",7:">= 4.0.0"};b.REVISION_CHANGES=o;var p="[object Object]";d.prototype={constructor:d,logger:l["default"],log:l["default"].log,registerHelper:function(a,b){if(f.toString.call(a)===p){if(b)throw new h["default"]("Arg not supported with multiple helpers");f.extend(this.helpers,a)}else this.helpers[a]=b},unregisterHelper:function(a){delete this.helpers[a]},registerPartial:function(a,b){if(f.toString.call(a)===p)f.extend(this.partials,a);else{if("undefined"==typeof b)throw new h["default"]('Attempting to register a partial called "'+a+'" as undefined');this.partials[a]=b}},unregisterPartial:function(a){delete this.partials[a]},registerDecorator:function(a,b){if(f.toString.call(a)===p){if(b)throw new h["default"]("Arg not supported with multiple decorators");f.extend(this.decorators,a)}else this.decorators[a]=b},unregisterDecorator:function(a){delete this.decorators[a]}};var q=l["default"].log;b.log=q,b.createFrame=f.createFrame,b.logger=l["default"]},function(a,b){function c(a){return k[a]}function d(a){for(var b=1;b<arguments.length;b++)for(var c in arguments[b])Object.prototype.hasOwnProperty.call(arguments[b],c)&&(a[c]=arguments[b][c]);return a}function e(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1}function f(a){if("string"!=typeof a){if(a&&a.toHTML)return a.toHTML();if(null==a)return"";if(!a)return a+"";a=""+a}return m.test(a)?a.replace(l,c):a}function g(a){return a||0===a?p(a)&&0===a.length?!0:!1:!0}function h(a){var b=d({},a);return b._parent=a,b}function i(a,b){return a.path=b,a}function j(a,b){return(a?a+".":"")+b}b.__esModule=!0,b.extend=d,b.indexOf=e,b.escapeExpression=f,b.isEmpty=g,b.createFrame=h,b.blockParams=i,b.appendContextPath=j;var k={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;","=":"&#x3D;"},l=/[&<>"'`=]/g,m=/[&<>"'`=]/,n=Object.prototype.toString;b.toString=n;var o=function(a){return"function"==typeof a};o(/x/)&&(b.isFunction=o=function(a){return"function"==typeof a&&"[object Function]"===n.call(a)}),b.isFunction=o;var p=Array.isArray||function(a){return a&&"object"==typeof a?"[object Array]"===n.call(a):!1};b.isArray=p},function(a,b){function c(a,b){var e=b&&b.loc,f=void 0,g=void 0;e&&(f=e.start.line,g=e.start.column,a+=" - "+f+":"+g);for(var h=Error.prototype.constructor.call(this,a),i=0;i<d.length;i++)this[d[i]]=h[d[i]];Error.captureStackTrace&&Error.captureStackTrace(this,c),e&&(this.lineNumber=f,this.column=g)}b.__esModule=!0;var d=["description","fileName","lineNumber","message","name","number","stack"];c.prototype=new Error,b["default"]=c,a.exports=b["default"]},function(a,b,c){function d(a){g["default"](a),i["default"](a),k["default"](a),m["default"](a),o["default"](a),q["default"](a),s["default"](a)}var e=c(1)["default"];b.__esModule=!0,b.registerDefaultHelpers=d;var f=c(8),g=e(f),h=c(9),i=e(h),j=c(10),k=e(j),l=c(11),m=e(l),n=c(12),o=e(n),p=c(13),q=e(p),r=c(14),s=e(r)},function(a,b,c){b.__esModule=!0;var d=c(5);b["default"]=function(a){a.registerHelper("blockHelperMissing",function(b,c){var e=c.inverse,f=c.fn;if(b===!0)return f(this);if(b===!1||null==b)return e(this);if(d.isArray(b))return b.length>0?(c.ids&&(c.ids=[c.name]),a.helpers.each(b,c)):e(this);if(c.data&&c.ids){var g=d.createFrame(c.data);g.contextPath=d.appendContextPath(c.data.contextPath,c.name),c={data:g}}return f(b,c)})},a.exports=b["default"]},function(a,b,c){var d=c(1)["default"];b.__esModule=!0;var e=c(5),f=c(6),g=d(f);b["default"]=function(a){a.registerHelper("each",function(a,b){function c(b,c,f){j&&(j.key=b,j.index=c,j.first=0===c,j.last=!!f,k&&(j.contextPath=k+b)),i+=d(a[b],{data:j,blockParams:e.blockParams([a[b],b],[k+b,null])})}if(!b)throw new g["default"]("Must pass iterator to #each");var d=b.fn,f=b.inverse,h=0,i="",j=void 0,k=void 0;if(b.data&&b.ids&&(k=e.appendContextPath(b.data.contextPath,b.ids[0])+"."),e.isFunction(a)&&(a=a.call(this)),b.data&&(j=e.createFrame(b.data)),a&&"object"==typeof a)if(e.isArray(a))for(var l=a.length;l>h;h++)h in a&&c(h,h,h===a.length-1);else{var m=void 0;for(var n in a)a.hasOwnProperty(n)&&(void 0!==m&&c(m,h-1),m=n,h++);void 0!==m&&c(m,h-1,!0)}return 0===h&&(i=f(this)),i})},a.exports=b["default"]},function(a,b,c){var d=c(1)["default"];b.__esModule=!0;var e=c(6),f=d(e);b["default"]=function(a){a.registerHelper("helperMissing",function(){if(1!==arguments.length)throw new f["default"]('Missing helper: "'+arguments[arguments.length-1].name+'"')})},a.exports=b["default"]},function(a,b,c){b.__esModule=!0;var d=c(5);b["default"]=function(a){a.registerHelper("if",function(a,b){return d.isFunction(a)&&(a=a.call(this)),!b.hash.includeZero&&!a||d.isEmpty(a)?b.inverse(this):b.fn(this)}),a.registerHelper("unless",function(b,c){return a.helpers["if"].call(this,b,{fn:c.inverse,inverse:c.fn,hash:c.hash})})},a.exports=b["default"]},function(a,b){b.__esModule=!0,b["default"]=function(a){a.registerHelper("log",function(){for(var b=[void 0],c=arguments[arguments.length-1],d=0;d<arguments.length-1;d++)b.push(arguments[d]);var e=1;null!=c.hash.level?e=c.hash.level:c.data&&null!=c.data.level&&(e=c.data.level),b[0]=e,a.log.apply(a,b)})},a.exports=b["default"]},function(a,b){b.__esModule=!0,b["default"]=function(a){a.registerHelper("lookup",function(a,b){return a&&a[b]})},a.exports=b["default"]},function(a,b,c){b.__esModule=!0;var d=c(5);b["default"]=function(a){a.registerHelper("with",function(a,b){d.isFunction(a)&&(a=a.call(this));var c=b.fn;if(d.isEmpty(a))return b.inverse(this);var e=b.data;return b.data&&b.ids&&(e=d.createFrame(b.data),e.contextPath=d.appendContextPath(b.data.contextPath,b.ids[0])),c(a,{data:e,blockParams:d.blockParams([a],[e&&e.contextPath])})})},a.exports=b["default"]},function(a,b,c){function d(a){g["default"](a)}var e=c(1)["default"];b.__esModule=!0,b.registerDefaultDecorators=d;var f=c(16),g=e(f)},function(a,b,c){b.__esModule=!0;var d=c(5);b["default"]=function(a){a.registerDecorator("inline",function(a,b,c,e){var f=a;return b.partials||(b.partials={},f=function(e,f){var g=c.partials;c.partials=d.extend({},g,b.partials);var h=a(e,f);return c.partials=g,h}),b.partials[e.args[0]]=e.fn,f})},a.exports=b["default"]},function(a,b,c){b.__esModule=!0;var d=c(5),e={methodMap:["debug","info","warn","error"],level:"info",lookupLevel:function(a){if("string"==typeof a){var b=d.indexOf(e.methodMap,a.toLowerCase());a=b>=0?b:parseInt(a,10)}return a},log:function(a){if(a=e.lookupLevel(a),"undefined"!=typeof console&&e.lookupLevel(e.level)<=a){var b=e.methodMap[a];console[b]||(b="log");for(var c=arguments.length,d=Array(c>1?c-1:0),f=1;c>f;f++)d[f-1]=arguments[f];console[b].apply(console,d)}}};b["default"]=e,a.exports=b["default"]},function(a,b){function c(a){this.string=a}b.__esModule=!0,c.prototype.toString=c.prototype.toHTML=function(){return""+this.string},b["default"]=c,a.exports=b["default"]},function(a,b,c){function d(a){var b=a&&a[0]||1,c=r.COMPILER_REVISION;if(b!==c){if(c>b){var d=r.REVISION_CHANGES[c],e=r.REVISION_CHANGES[b];throw new q["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version ("+d+") or downgrade your runtime to an older version ("+e+").")}throw new q["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version ("+a[1]+").")}}function e(a,b){function c(c,d,e){e.hash&&(d=o.extend({},d,e.hash),e.ids&&(e.ids[0]=!0)),c=b.VM.resolvePartial.call(this,c,d,e);var f=b.VM.invokePartial.call(this,c,d,e);if(null==f&&b.compile&&(e.partials[e.name]=b.compile(c,a.compilerOptions,b),f=e.partials[e.name](d,e)),null!=f){if(e.indent){for(var g=f.split("\n"),h=0,i=g.length;i>h&&(g[h]||h+1!==i);h++)g[h]=e.indent+g[h];f=g.join("\n")}return f}throw new q["default"]("The partial "+e.name+" could not be compiled when running in runtime-only mode")}function d(b){function c(b){return""+a.main(e,b,e.helpers,e.partials,g,i,h)}var f=arguments.length<=1||void 0===arguments[1]?{}:arguments[1],g=f.data;d._setup(f),!f.partial&&a.useData&&(g=j(b,g));var h=void 0,i=a.useBlockParams?[]:void 0;return a.useDepths&&(h=f.depths?b!==f.depths[0]?[b].concat(f.depths):f.depths:[b]),(c=k(a.main,c,e,f.depths||[],g,i))(b,f)}if(!b)throw new q["default"]("No environment passed to template");if(!a||!a.main)throw new q["default"]("Unknown template object: "+typeof a);a.main.decorator=a.main_d,b.VM.checkRevision(a.compiler);var e={strict:function(a,b){if(!(b in a))throw new q["default"]('"'+b+'" not defined in '+a);return a[b]},lookup:function(a,b){for(var c=a.length,d=0;c>d;d++)if(a[d]&&null!=a[d][b])return a[d][b]},lambda:function(a,b){return"function"==typeof a?a.call(b):a},escapeExpression:o.escapeExpression,invokePartial:c,fn:function(b){var c=a[b];return c.decorator=a[b+"_d"],c},programs:[],program:function(a,b,c,d,e){var g=this.programs[a],h=this.fn(a);return b||e||d||c?g=f(this,a,h,b,c,d,e):g||(g=this.programs[a]=f(this,a,h)),g},data:function(a,b){for(;a&&b--;)a=a._parent;return a},merge:function(a,b){var c=a||b;return a&&b&&a!==b&&(c=o.extend({},b,a)),c},noop:b.VM.noop,compilerInfo:a.compiler};return d.isTop=!0,d._setup=function(c){c.partial?(e.helpers=c.helpers,e.partials=c.partials,e.decorators=c.decorators):(e.helpers=e.merge(c.helpers,b.helpers),a.usePartial&&(e.partials=e.merge(c.partials,b.partials)),(a.usePartial||a.useDecorators)&&(e.decorators=e.merge(c.decorators,b.decorators)))},d._child=function(b,c,d,g){if(a.useBlockParams&&!d)throw new q["default"]("must pass block params");if(a.useDepths&&!g)throw new q["default"]("must pass parent depths");return f(e,b,a[b],c,0,d,g)},d}function f(a,b,c,d,e,f,g){function h(b){var e=arguments.length<=1||void 0===arguments[1]?{}:arguments[1],h=g;return g&&b!==g[0]&&(h=[b].concat(g)),c(a,b,a.helpers,a.partials,e.data||d,f&&[e.blockParams].concat(f),h)}return h=k(c,h,a,g,d,f),h.program=b,h.depth=g?g.length:0,h.blockParams=e||0,h}function g(a,b,c){return a?a.call||c.name||(c.name=a,a=c.partials[a]):a="@partial-block"===c.name?c.data["partial-block"]:c.partials[c.name],a}function h(a,b,c){c.partial=!0,c.ids&&(c.data.contextPath=c.ids[0]||c.data.contextPath);var d=void 0;if(c.fn&&c.fn!==i&&(c.data=r.createFrame(c.data),d=c.data["partial-block"]=c.fn,d.partials&&(c.partials=o.extend({},c.partials,d.partials))),void 0===a&&d&&(a=d),void 0===a)throw new q["default"]("The partial "+c.name+" could not be found");return a instanceof Function?a(b,c):void 0}function i(){return""}function j(a,b){return b&&"root"in b||(b=b?r.createFrame(b):{},b.root=a),b}function k(a,b,c,d,e,f){if(a.decorator){var g={};b=a.decorator(b,g,c,d&&d[0],e,f,d),o.extend(b,g)}return b}var l=c(3)["default"],m=c(1)["default"];b.__esModule=!0,b.checkRevision=d,b.template=e,b.wrapProgram=f,b.resolvePartial=g,b.invokePartial=h,b.noop=i;var n=c(5),o=l(n),p=c(6),q=m(p),r=c(4)},function(a,b){(function(c){b.__esModule=!0,b["default"]=function(a){var b="undefined"!=typeof c?c:window,d=b.Handlebars;a.noConflict=function(){return b.Handlebars===a&&(b.Handlebars=d),a}},a.exports=b["default"]}).call(b,function(){return this}())},function(a,b){b.__esModule=!0;var c={helpers:{helperExpression:function(a){return"SubExpression"===a.type||("MustacheStatement"===a.type||"BlockStatement"===a.type)&&!!(a.params&&a.params.length||a.hash)},scopedId:function(a){return/^\.|this\b/.test(a.original)},simpleId:function(a){return 1===a.parts.length&&!c.helpers.scopedId(a)&&!a.depth}}};b["default"]=c,a.exports=b["default"]},function(a,b,c){function d(a,b){if("Program"===a.type)return a;h["default"].yy=n,n.locInfo=function(a){return new n.SourceLocation(b&&b.srcName,a)};var c=new j["default"](b);return c.accept(h["default"].parse(a))}var e=c(1)["default"],f=c(3)["default"];b.__esModule=!0,b.parse=d;var g=c(23),h=e(g),i=c(24),j=e(i),k=c(26),l=f(k),m=c(5);b.parser=h["default"];var n={};m.extend(n,l)},function(a,b){var c=function(){function a(){this.yy={}}var b={trace:function(){},yy:{},symbols_:{error:2,root:3,program:4,EOF:5,program_repetition0:6,statement:7,mustache:8,block:9,rawBlock:10,partial:11,partialBlock:12,content:13,COMMENT:14,CONTENT:15,openRawBlock:16,rawBlock_repetition_plus0:17,END_RAW_BLOCK:18,OPEN_RAW_BLOCK:19,helperName:20,openRawBlock_repetition0:21,openRawBlock_option0:22,CLOSE_RAW_BLOCK:23,openBlock:24,block_option0:25,closeBlock:26,openInverse:27,block_option1:28,OPEN_BLOCK:29,openBlock_repetition0:30,openBlock_option0:31,openBlock_option1:32,CLOSE:33,OPEN_INVERSE:34,openInverse_repetition0:35,openInverse_option0:36,openInverse_option1:37,openInverseChain:38,OPEN_INVERSE_CHAIN:39,openInverseChain_repetition0:40,openInverseChain_option0:41,openInverseChain_option1:42,inverseAndProgram:43,INVERSE:44,inverseChain:45,inverseChain_option0:46,OPEN_ENDBLOCK:47,OPEN:48,mustache_repetition0:49,mustache_option0:50,OPEN_UNESCAPED:51,mustache_repetition1:52,mustache_option1:53,CLOSE_UNESCAPED:54,OPEN_PARTIAL:55,partialName:56,partial_repetition0:57,partial_option0:58,openPartialBlock:59,OPEN_PARTIAL_BLOCK:60,openPartialBlock_repetition0:61,openPartialBlock_option0:62,param:63,sexpr:64,OPEN_SEXPR:65,sexpr_repetition0:66,sexpr_option0:67,CLOSE_SEXPR:68,hash:69,hash_repetition_plus0:70,hashSegment:71,ID:72,EQUALS:73,blockParams:74,OPEN_BLOCK_PARAMS:75,blockParams_repetition_plus0:76,CLOSE_BLOCK_PARAMS:77,path:78,dataName:79,STRING:80,NUMBER:81,BOOLEAN:82,UNDEFINED:83,NULL:84,DATA:85,pathSegments:86,SEP:87,$accept:0,$end:1},terminals_:{2:"error",5:"EOF",14:"COMMENT",15:"CONTENT",18:"END_RAW_BLOCK",19:"OPEN_RAW_BLOCK",23:"CLOSE_RAW_BLOCK",29:"OPEN_BLOCK",33:"CLOSE",34:"OPEN_INVERSE",39:"OPEN_INVERSE_CHAIN",44:"INVERSE",47:"OPEN_ENDBLOCK",48:"OPEN",51:"OPEN_UNESCAPED",54:"CLOSE_UNESCAPED",55:"OPEN_PARTIAL",60:"OPEN_PARTIAL_BLOCK",65:"OPEN_SEXPR",68:"CLOSE_SEXPR",72:"ID",73:"EQUALS",75:"OPEN_BLOCK_PARAMS",77:"CLOSE_BLOCK_PARAMS",80:"STRING",81:"NUMBER",82:"BOOLEAN",83:"UNDEFINED",84:"NULL",85:"DATA",87:"SEP"},productions_:[0,[3,2],[4,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[13,1],[10,3],[16,5],[9,4],[9,4],[24,6],[27,6],[38,6],[43,2],[45,3],[45,1],[26,3],[8,5],[8,5],[11,5],[12,3],[59,5],[63,1],[63,1],[64,5],[69,1],[71,3],[74,3],[20,1],[20,1],[20,1],[20,1],[20,1],[20,1],[20,1],[56,1],[56,1],[79,2],[78,1],[86,3],[86,1],[6,0],[6,2],[17,1],[17,2],[21,0],[21,2],[22,0],[22,1],[25,0],[25,1],[28,0],[28,1],[30,0],[30,2],[31,0],[31,1],[32,0],[32,1],[35,0],[35,2],[36,0],[36,1],[37,0],[37,1],[40,0],[40,2],[41,0],[41,1],[42,0],[42,1],[46,0],[46,1],[49,0],[49,2],[50,0],[50,1],[52,0],[52,2],[53,0],[53,1],[57,0],[57,2],[58,0],[58,1],[61,0],[61,2],[62,0],[62,1],[66,0],[66,2],[67,0],[67,1],[70,1],[70,2],[76,1],[76,2]],performAction:function(a,b,c,d,e,f,g){var h=f.length-1;switch(e){case 1:return f[h-1];case 2:this.$=d.prepareProgram(f[h]);break;case 3:this.$=f[h];break;case 4:this.$=f[h];break;case 5:this.$=f[h];break;case 6:this.$=f[h];break;case 7:this.$=f[h];break;case 8:this.$=f[h];break;case 9:this.$={type:"CommentStatement",value:d.stripComment(f[h]),strip:d.stripFlags(f[h],f[h]),loc:d.locInfo(this._$)};break;case 10:this.$={type:"ContentStatement",original:f[h],value:f[h],loc:d.locInfo(this._$)};break;case 11:this.$=d.prepareRawBlock(f[h-2],f[h-1],f[h],this._$);break;case 12:this.$={path:f[h-3],params:f[h-2],hash:f[h-1]};break;case 13:this.$=d.prepareBlock(f[h-3],f[h-2],f[h-1],f[h],!1,this._$);break;case 14:this.$=d.prepareBlock(f[h-3],f[h-2],f[h-1],f[h],!0,this._$);break;case 15:this.$={open:f[h-5],path:f[h-4],params:f[h-3],hash:f[h-2],blockParams:f[h-1],strip:d.stripFlags(f[h-5],f[h])};break;case 16:this.$={path:f[h-4],params:f[h-3],hash:f[h-2],blockParams:f[h-1],strip:d.stripFlags(f[h-5],f[h])};break;case 17:this.$={path:f[h-4],params:f[h-3],hash:f[h-2],blockParams:f[h-1],strip:d.stripFlags(f[h-5],f[h])};break;case 18:this.$={strip:d.stripFlags(f[h-1],f[h-1]),program:f[h]};break;case 19:var i=d.prepareBlock(f[h-2],f[h-1],f[h],f[h],!1,this._$),j=d.prepareProgram([i],f[h-1].loc);j.chained=!0,this.$={strip:f[h-2].strip,program:j,chain:!0};break;case 20:this.$=f[h];break;case 21:this.$={path:f[h-1],strip:d.stripFlags(f[h-2],f[h])};break;case 22:this.$=d.prepareMustache(f[h-3],f[h-2],f[h-1],f[h-4],d.stripFlags(f[h-4],f[h]),this._$);break;case 23:this.$=d.prepareMustache(f[h-3],f[h-2],f[h-1],f[h-4],d.stripFlags(f[h-4],f[h]),this._$);break;case 24:this.$={type:"PartialStatement",name:f[h-3],params:f[h-2],hash:f[h-1],indent:"",strip:d.stripFlags(f[h-4],f[h]),loc:d.locInfo(this._$)};break;case 25:this.$=d.preparePartialBlock(f[h-2],f[h-1],f[h],this._$);break;case 26:this.$={path:f[h-3],params:f[h-2],hash:f[h-1],strip:d.stripFlags(f[h-4],f[h])};break;case 27:this.$=f[h];break;case 28:this.$=f[h];break;case 29:this.$={type:"SubExpression",path:f[h-3],params:f[h-2],hash:f[h-1],loc:d.locInfo(this._$)};break;case 30:this.$={type:"Hash",pairs:f[h],loc:d.locInfo(this._$)};break;case 31:this.$={type:"HashPair",key:d.id(f[h-2]),value:f[h],loc:d.locInfo(this._$)};break;case 32:this.$=d.id(f[h-1]);break;case 33:this.$=f[h];break;case 34:this.$=f[h];break;case 35:this.$={type:"StringLiteral",value:f[h],original:f[h],loc:d.locInfo(this._$)};break;case 36:this.$={type:"NumberLiteral",value:Number(f[h]),original:Number(f[h]),loc:d.locInfo(this._$)};break;case 37:this.$={type:"BooleanLiteral",value:"true"===f[h],original:"true"===f[h],loc:d.locInfo(this._$)};break;case 38:this.$={type:"UndefinedLiteral",original:void 0,value:void 0,loc:d.locInfo(this._$)};break;case 39:this.$={type:"NullLiteral",original:null,value:null,loc:d.locInfo(this._$)};break;case 40:this.$=f[h];break;case 41:this.$=f[h];break;case 42:this.$=d.preparePath(!0,f[h],this._$);break;case 43:this.$=d.preparePath(!1,f[h],this._$);break;case 44:f[h-2].push({part:d.id(f[h]),original:f[h],separator:f[h-1]}),this.$=f[h-2];break;case 45:this.$=[{part:d.id(f[h]),original:f[h]}];break;case 46:this.$=[];break;case 47:f[h-1].push(f[h]);break;case 48:this.$=[f[h]];break;case 49:f[h-1].push(f[h]);break;case 50:this.$=[];break;case 51:f[h-1].push(f[h]);break;case 58:this.$=[];break;case 59:f[h-1].push(f[h]);break;case 64:this.$=[];break;case 65:f[h-1].push(f[h]);break;case 70:this.$=[];break;case 71:f[h-1].push(f[h]);break;case 78:this.$=[];break;case 79:f[h-1].push(f[h]);break;case 82:this.$=[];break;case 83:f[h-1].push(f[h]);break;case 86:this.$=[];break;case 87:f[h-1].push(f[h]);break;case 90:this.$=[];break;case 91:f[h-1].push(f[h]);break;case 94:this.$=[];break;case 95:f[h-1].push(f[h]);break;case 98:this.$=[f[h]];break;case 99:f[h-1].push(f[h]);break;case 100:this.$=[f[h]];break;case 101:f[h-1].push(f[h])}},table:[{3:1,4:2,5:[2,46],6:3,14:[2,46],15:[2,46],19:[2,46],29:[2,46],34:[2,46],48:[2,46],51:[2,46],55:[2,46],60:[2,46]},{1:[3]},{5:[1,4]},{5:[2,2],7:5,8:6,9:7,10:8,11:9,12:10,13:11,14:[1,12],15:[1,20],16:17,19:[1,23],24:15,27:16,29:[1,21],34:[1,22],39:[2,2],44:[2,2],47:[2,2],48:[1,13],51:[1,14],55:[1,18],59:19,60:[1,24]},{1:[2,1]},{5:[2,47],14:[2,47],15:[2,47],19:[2,47],29:[2,47],34:[2,47],39:[2,47],44:[2,47],47:[2,47],48:[2,47],51:[2,47],55:[2,47],60:[2,47]},{5:[2,3],14:[2,3],15:[2,3],19:[2,3],29:[2,3],34:[2,3],39:[2,3],44:[2,3],47:[2,3],48:[2,3],51:[2,3],55:[2,3],60:[2,3]},{5:[2,4],14:[2,4],15:[2,4],19:[2,4],29:[2,4],34:[2,4],39:[2,4],44:[2,4],47:[2,4],48:[2,4],51:[2,4],55:[2,4],60:[2,4]},{5:[2,5],14:[2,5],15:[2,5],19:[2,5],29:[2,5],34:[2,5],39:[2,5],44:[2,5],47:[2,5],48:[2,5],51:[2,5],55:[2,5],60:[2,5]},{5:[2,6],14:[2,6],15:[2,6],19:[2,6],29:[2,6],34:[2,6],39:[2,6],44:[2,6],47:[2,6],48:[2,6],51:[2,6],55:[2,6],60:[2,6]},{5:[2,7],14:[2,7],15:[2,7],19:[2,7],29:[2,7],34:[2,7],39:[2,7],44:[2,7],47:[2,7],48:[2,7],51:[2,7],55:[2,7],60:[2,7]},{5:[2,8],14:[2,8],15:[2,8],19:[2,8],29:[2,8],34:[2,8],39:[2,8],44:[2,8],47:[2,8],48:[2,8],51:[2,8],55:[2,8],60:[2,8]},{5:[2,9],14:[2,9],15:[2,9],19:[2,9],29:[2,9],34:[2,9],39:[2,9],44:[2,9],47:[2,9],48:[2,9],51:[2,9],55:[2,9],60:[2,9]},{20:25,72:[1,35],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{20:36,72:[1,35],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{4:37,6:3,14:[2,46],15:[2,46],19:[2,46],29:[2,46],34:[2,46],39:[2,46],44:[2,46],47:[2,46],48:[2,46],51:[2,46],55:[2,46],60:[2,46]},{4:38,6:3,14:[2,46],15:[2,46],19:[2,46],29:[2,46],34:[2,46],44:[2,46],47:[2,46],48:[2,46],51:[2,46],55:[2,46],60:[2,46]},{13:40,15:[1,20],17:39},{20:42,56:41,64:43,65:[1,44],72:[1,35],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{4:45,6:3,14:[2,46],15:[2,46],19:[2,46],29:[2,46],34:[2,46],47:[2,46],48:[2,46],51:[2,46],55:[2,46],60:[2,46]},{5:[2,10],14:[2,10],15:[2,10],18:[2,10],19:[2,10],29:[2,10],34:[2,10],39:[2,10],44:[2,10],47:[2,10],48:[2,10],51:[2,10],55:[2,10],60:[2,10]},{20:46,72:[1,35],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{20:47,72:[1,35],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{20:48,72:[1,35],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{20:42,56:49,64:43,65:[1,44],72:[1,35],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{33:[2,78],49:50,65:[2,78],72:[2,78],80:[2,78],81:[2,78],82:[2,78],83:[2,78],84:[2,78],85:[2,78]},{23:[2,33],33:[2,33],54:[2,33],65:[2,33],68:[2,33],72:[2,33],75:[2,33],80:[2,33],81:[2,33],82:[2,33],83:[2,33],84:[2,33],85:[2,33]},{23:[2,34],33:[2,34],54:[2,34],65:[2,34],68:[2,34],72:[2,34],75:[2,34],80:[2,34],81:[2,34],82:[2,34],83:[2,34],84:[2,34],85:[2,34]},{23:[2,35],33:[2,35],54:[2,35],65:[2,35],68:[2,35],72:[2,35],75:[2,35],80:[2,35],81:[2,35],82:[2,35],83:[2,35],84:[2,35],85:[2,35]},{23:[2,36],33:[2,36],54:[2,36],65:[2,36],68:[2,36],72:[2,36],75:[2,36],80:[2,36],81:[2,36],82:[2,36],83:[2,36],84:[2,36],85:[2,36]},{23:[2,37],33:[2,37],54:[2,37],65:[2,37],68:[2,37],72:[2,37],75:[2,37],80:[2,37],81:[2,37],82:[2,37],83:[2,37],84:[2,37],85:[2,37]},{23:[2,38],33:[2,38],54:[2,38],65:[2,38],68:[2,38],72:[2,38],75:[2,38],80:[2,38],81:[2,38],82:[2,38],83:[2,38],84:[2,38],85:[2,38]},{23:[2,39],33:[2,39],54:[2,39],65:[2,39],68:[2,39],72:[2,39],75:[2,39],80:[2,39],81:[2,39],82:[2,39],83:[2,39],84:[2,39],85:[2,39]},{23:[2,43],33:[2,43],54:[2,43],65:[2,43],68:[2,43],72:[2,43],75:[2,43],80:[2,43],81:[2,43],82:[2,43],83:[2,43],84:[2,43],85:[2,43],87:[1,51]},{72:[1,35],86:52},{23:[2,45],33:[2,45],54:[2,45],65:[2,45],68:[2,45],72:[2,45],75:[2,45],80:[2,45],81:[2,45],82:[2,45],83:[2,45],84:[2,45],85:[2,45],87:[2,45]},{52:53,54:[2,82],65:[2,82],72:[2,82],80:[2,82],81:[2,82],82:[2,82],83:[2,82],84:[2,82],85:[2,82]},{25:54,38:56,39:[1,58],43:57,44:[1,59],45:55,47:[2,54]},{28:60,43:61,44:[1,59],47:[2,56]},{13:63,15:[1,20],18:[1,62]},{15:[2,48],18:[2,48]},{33:[2,86],57:64,65:[2,86],72:[2,86],80:[2,86],81:[2,86],82:[2,86],83:[2,86],84:[2,86],85:[2,86]},{33:[2,40],65:[2,40],72:[2,40],80:[2,40],81:[2,40],82:[2,40],83:[2,40],84:[2,40],85:[2,40]},{33:[2,41],65:[2,41],72:[2,41],80:[2,41],81:[2,41],82:[2,41],83:[2,41],84:[2,41],85:[2,41]},{20:65,72:[1,35],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{26:66,47:[1,67]},{30:68,33:[2,58],65:[2,58],72:[2,58],75:[2,58],80:[2,58],81:[2,58],82:[2,58],83:[2,58],84:[2,58],85:[2,58]},{33:[2,64],35:69,65:[2,64],72:[2,64],75:[2,64],80:[2,64],81:[2,64],82:[2,64],83:[2,64],84:[2,64],85:[2,64]},{21:70,23:[2,50],65:[2,50],72:[2,50],80:[2,50],81:[2,50],82:[2,50],83:[2,50],84:[2,50],85:[2,50]},{33:[2,90],61:71,65:[2,90],72:[2,90],80:[2,90],81:[2,90],82:[2,90],83:[2,90],84:[2,90],85:[2,90]},{20:75,33:[2,80],50:72,63:73,64:76,65:[1,44],69:74,70:77,71:78,72:[1,79],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{72:[1,80]},{23:[2,42],33:[2,42],54:[2,42],65:[2,42],68:[2,42],72:[2,42],75:[2,42],80:[2,42],81:[2,42],82:[2,42],83:[2,42],84:[2,42],85:[2,42],87:[1,51]},{20:75,53:81,54:[2,84],63:82,64:76,65:[1,44],69:83,70:77,71:78,72:[1,79],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{26:84,47:[1,67]},{47:[2,55]},{4:85,6:3,14:[2,46],15:[2,46],19:[2,46],29:[2,46],34:[2,46],39:[2,46],44:[2,46],47:[2,46],48:[2,46],51:[2,46],55:[2,46],60:[2,46]},{47:[2,20]},{20:86,72:[1,35],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{4:87,6:3,14:[2,46],15:[2,46],19:[2,46],29:[2,46],34:[2,46],47:[2,46],48:[2,46],51:[2,46],55:[2,46],60:[2,46]},{26:88,47:[1,67]},{47:[2,57]},{5:[2,11],14:[2,11],15:[2,11],19:[2,11],29:[2,11],34:[2,11],39:[2,11],44:[2,11],47:[2,11],48:[2,11],51:[2,11],55:[2,11],60:[2,11]},{15:[2,49],18:[2,49]},{20:75,33:[2,88],58:89,63:90,64:76,65:[1,44],69:91,70:77,71:78,72:[1,79],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{65:[2,94],66:92,68:[2,94],72:[2,94],80:[2,94],81:[2,94],82:[2,94],83:[2,94],84:[2,94],85:[2,94]},{5:[2,25],14:[2,25],15:[2,25],19:[2,25],29:[2,25],34:[2,25],39:[2,25],44:[2,25],47:[2,25],48:[2,25],51:[2,25],55:[2,25],60:[2,25]},{20:93,72:[1,35],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{20:75,31:94,33:[2,60],63:95,64:76,65:[1,44],69:96,70:77,71:78,72:[1,79],75:[2,60],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{20:75,33:[2,66],36:97,63:98,64:76,65:[1,44],69:99,70:77,71:78,72:[1,79],75:[2,66],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{20:75,22:100,23:[2,52],63:101,64:76,65:[1,44],69:102,70:77,71:78,72:[1,79],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{20:75,33:[2,92],62:103,63:104,64:76,65:[1,44],69:105,70:77,71:78,72:[1,79],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{33:[1,106]},{33:[2,79],65:[2,79],72:[2,79],80:[2,79],81:[2,79],82:[2,79],83:[2,79],84:[2,79],85:[2,79]},{33:[2,81]},{23:[2,27],33:[2,27],54:[2,27],65:[2,27],68:[2,27],72:[2,27],75:[2,27],80:[2,27],81:[2,27],82:[2,27],83:[2,27],84:[2,27],85:[2,27]},{23:[2,28],33:[2,28],54:[2,28],65:[2,28],68:[2,28],72:[2,28],75:[2,28],80:[2,28],81:[2,28],82:[2,28],83:[2,28],84:[2,28],85:[2,28]},{23:[2,30],33:[2,30],54:[2,30],68:[2,30],71:107,72:[1,108],75:[2,30]},{23:[2,98],33:[2,98],54:[2,98],68:[2,98],72:[2,98],75:[2,98]},{23:[2,45],33:[2,45],54:[2,45],65:[2,45],68:[2,45],72:[2,45],73:[1,109],75:[2,45],80:[2,45],81:[2,45],82:[2,45],83:[2,45],84:[2,45],85:[2,45],87:[2,45]},{23:[2,44],33:[2,44],54:[2,44],65:[2,44],68:[2,44],72:[2,44],75:[2,44],80:[2,44],81:[2,44],82:[2,44],83:[2,44],84:[2,44],85:[2,44],87:[2,44]},{54:[1,110]},{54:[2,83],65:[2,83],72:[2,83],80:[2,83],81:[2,83],82:[2,83],83:[2,83],84:[2,83],85:[2,83]},{54:[2,85]},{5:[2,13],14:[2,13],15:[2,13],19:[2,13],29:[2,13],34:[2,13],39:[2,13],44:[2,13],47:[2,13],48:[2,13],51:[2,13],55:[2,13],60:[2,13]},{38:56,39:[1,58],43:57,44:[1,59],45:112,46:111,47:[2,76]},{33:[2,70],40:113,65:[2,70],72:[2,70],75:[2,70],80:[2,70],81:[2,70],82:[2,70],83:[2,70],84:[2,70],85:[2,70]},{47:[2,18]},{5:[2,14],14:[2,14],15:[2,14],19:[2,14],29:[2,14],34:[2,14],39:[2,14],44:[2,14],47:[2,14],48:[2,14],51:[2,14],55:[2,14],60:[2,14]},{33:[1,114]},{33:[2,87],65:[2,87],72:[2,87],80:[2,87],81:[2,87],82:[2,87],83:[2,87],84:[2,87],85:[2,87]},{33:[2,89]},{20:75,63:116,64:76,65:[1,44],67:115,68:[2,96],69:117,70:77,71:78,72:[1,79],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{33:[1,118]},{32:119,33:[2,62],74:120,75:[1,121]},{33:[2,59],65:[2,59],72:[2,59],75:[2,59],80:[2,59],81:[2,59],82:[2,59],83:[2,59],84:[2,59],85:[2,59]},{33:[2,61],75:[2,61]},{33:[2,68],37:122,74:123,75:[1,121]},{33:[2,65],65:[2,65],72:[2,65],75:[2,65],80:[2,65],81:[2,65],82:[2,65],83:[2,65],84:[2,65],85:[2,65]},{33:[2,67],75:[2,67]},{23:[1,124]},{23:[2,51],65:[2,51],72:[2,51],80:[2,51],81:[2,51],82:[2,51],83:[2,51],84:[2,51],85:[2,51]},{23:[2,53]},{33:[1,125]},{33:[2,91],65:[2,91],72:[2,91],80:[2,91],81:[2,91],82:[2,91],83:[2,91],84:[2,91],85:[2,91]},{33:[2,93]},{5:[2,22],14:[2,22],15:[2,22],19:[2,22],29:[2,22],34:[2,22],39:[2,22],44:[2,22],47:[2,22],48:[2,22],51:[2,22],55:[2,22],60:[2,22]},{23:[2,99],33:[2,99],54:[2,99],68:[2,99],72:[2,99],75:[2,99]},{73:[1,109]},{20:75,63:126,64:76,65:[1,44],72:[1,35],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{5:[2,23],14:[2,23],15:[2,23],19:[2,23],29:[2,23],34:[2,23],39:[2,23],44:[2,23],47:[2,23],48:[2,23],51:[2,23],55:[2,23],60:[2,23]},{47:[2,19]},{47:[2,77]},{20:75,33:[2,72],41:127,63:128,64:76,65:[1,44],69:129,70:77,71:78,72:[1,79],75:[2,72],78:26,79:27,80:[1,28],81:[1,29],82:[1,30],83:[1,31],84:[1,32],85:[1,34],86:33},{5:[2,24],14:[2,24],15:[2,24],19:[2,24],29:[2,24],34:[2,24],39:[2,24],44:[2,24],47:[2,24],48:[2,24],51:[2,24],55:[2,24],60:[2,24]},{68:[1,130]},{65:[2,95],68:[2,95],72:[2,95],80:[2,95],81:[2,95],82:[2,95],83:[2,95],84:[2,95],85:[2,95]},{68:[2,97]},{5:[2,21],14:[2,21],15:[2,21],19:[2,21],29:[2,21],34:[2,21],39:[2,21],44:[2,21],47:[2,21],48:[2,21],51:[2,21],55:[2,21],60:[2,21]},{33:[1,131]},{33:[2,63]},{72:[1,133],76:132},{33:[1,134]},{33:[2,69]},{15:[2,12]},{14:[2,26],15:[2,26],19:[2,26],29:[2,26],34:[2,26],47:[2,26],48:[2,26],51:[2,26],55:[2,26],60:[2,26]},{23:[2,31],33:[2,31],54:[2,31],68:[2,31],72:[2,31],75:[2,31]},{33:[2,74],42:135,74:136,75:[1,121]},{33:[2,71],65:[2,71],72:[2,71],75:[2,71],80:[2,71],81:[2,71],82:[2,71],83:[2,71],84:[2,71],85:[2,71]},{33:[2,73],75:[2,73]},{23:[2,29],33:[2,29],54:[2,29],65:[2,29],68:[2,29],72:[2,29],75:[2,29],80:[2,29],81:[2,29],82:[2,29],83:[2,29],84:[2,29],85:[2,29]},{14:[2,15],15:[2,15],19:[2,15],29:[2,15],34:[2,15],39:[2,15],44:[2,15],47:[2,15],48:[2,15],51:[2,15],55:[2,15],60:[2,15]},{72:[1,138],77:[1,137]},{72:[2,100],77:[2,100]},{14:[2,16],15:[2,16],19:[2,16],29:[2,16],34:[2,16],44:[2,16],47:[2,16],
48:[2,16],51:[2,16],55:[2,16],60:[2,16]},{33:[1,139]},{33:[2,75]},{33:[2,32]},{72:[2,101],77:[2,101]},{14:[2,17],15:[2,17],19:[2,17],29:[2,17],34:[2,17],39:[2,17],44:[2,17],47:[2,17],48:[2,17],51:[2,17],55:[2,17],60:[2,17]}],defaultActions:{4:[2,1],55:[2,55],57:[2,20],61:[2,57],74:[2,81],83:[2,85],87:[2,18],91:[2,89],102:[2,53],105:[2,93],111:[2,19],112:[2,77],117:[2,97],120:[2,63],123:[2,69],124:[2,12],136:[2,75],137:[2,32]},parseError:function(a,b){throw new Error(a)},parse:function(a){function b(){var a;return a=c.lexer.lex()||1,"number"!=typeof a&&(a=c.symbols_[a]||a),a}var c=this,d=[0],e=[null],f=[],g=this.table,h="",i=0,j=0,k=0;this.lexer.setInput(a),this.lexer.yy=this.yy,this.yy.lexer=this.lexer,this.yy.parser=this,"undefined"==typeof this.lexer.yylloc&&(this.lexer.yylloc={});var l=this.lexer.yylloc;f.push(l);var m=this.lexer.options&&this.lexer.options.ranges;"function"==typeof this.yy.parseError&&(this.parseError=this.yy.parseError);for(var n,o,p,q,r,s,t,u,v,w={};;){if(p=d[d.length-1],this.defaultActions[p]?q=this.defaultActions[p]:((null===n||"undefined"==typeof n)&&(n=b()),q=g[p]&&g[p][n]),"undefined"==typeof q||!q.length||!q[0]){var x="";if(!k){v=[];for(s in g[p])this.terminals_[s]&&s>2&&v.push("'"+this.terminals_[s]+"'");x=this.lexer.showPosition?"Parse error on line "+(i+1)+":\n"+this.lexer.showPosition()+"\nExpecting "+v.join(", ")+", got '"+(this.terminals_[n]||n)+"'":"Parse error on line "+(i+1)+": Unexpected "+(1==n?"end of input":"'"+(this.terminals_[n]||n)+"'"),this.parseError(x,{text:this.lexer.match,token:this.terminals_[n]||n,line:this.lexer.yylineno,loc:l,expected:v})}}if(q[0]instanceof Array&&q.length>1)throw new Error("Parse Error: multiple actions possible at state: "+p+", token: "+n);switch(q[0]){case 1:d.push(n),e.push(this.lexer.yytext),f.push(this.lexer.yylloc),d.push(q[1]),n=null,o?(n=o,o=null):(j=this.lexer.yyleng,h=this.lexer.yytext,i=this.lexer.yylineno,l=this.lexer.yylloc,k>0&&k--);break;case 2:if(t=this.productions_[q[1]][1],w.$=e[e.length-t],w._$={first_line:f[f.length-(t||1)].first_line,last_line:f[f.length-1].last_line,first_column:f[f.length-(t||1)].first_column,last_column:f[f.length-1].last_column},m&&(w._$.range=[f[f.length-(t||1)].range[0],f[f.length-1].range[1]]),r=this.performAction.call(w,h,j,i,this.yy,q[1],e,f),"undefined"!=typeof r)return r;t&&(d=d.slice(0,-1*t*2),e=e.slice(0,-1*t),f=f.slice(0,-1*t)),d.push(this.productions_[q[1]][0]),e.push(w.$),f.push(w._$),u=g[d[d.length-2]][d[d.length-1]],d.push(u);break;case 3:return!0}}return!0}},c=function(){var a={EOF:1,parseError:function(a,b){if(!this.yy.parser)throw new Error(a);this.yy.parser.parseError(a,b)},setInput:function(a){return this._input=a,this._more=this._less=this.done=!1,this.yylineno=this.yyleng=0,this.yytext=this.matched=this.match="",this.conditionStack=["INITIAL"],this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0},this.options.ranges&&(this.yylloc.range=[0,0]),this.offset=0,this},input:function(){var a=this._input[0];this.yytext+=a,this.yyleng++,this.offset++,this.match+=a,this.matched+=a;var b=a.match(/(?:\r\n?|\n).*/g);return b?(this.yylineno++,this.yylloc.last_line++):this.yylloc.last_column++,this.options.ranges&&this.yylloc.range[1]++,this._input=this._input.slice(1),a},unput:function(a){var b=a.length,c=a.split(/(?:\r\n?|\n)/g);this._input=a+this._input,this.yytext=this.yytext.substr(0,this.yytext.length-b-1),this.offset-=b;var d=this.match.split(/(?:\r\n?|\n)/g);this.match=this.match.substr(0,this.match.length-1),this.matched=this.matched.substr(0,this.matched.length-1),c.length-1&&(this.yylineno-=c.length-1);var e=this.yylloc.range;return this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:c?(c.length===d.length?this.yylloc.first_column:0)+d[d.length-c.length].length-c[0].length:this.yylloc.first_column-b},this.options.ranges&&(this.yylloc.range=[e[0],e[0]+this.yyleng-b]),this},more:function(){return this._more=!0,this},less:function(a){this.unput(this.match.slice(a))},pastInput:function(){var a=this.matched.substr(0,this.matched.length-this.match.length);return(a.length>20?"...":"")+a.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var a=this.match;return a.length<20&&(a+=this._input.substr(0,20-a.length)),(a.substr(0,20)+(a.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var a=this.pastInput(),b=new Array(a.length+1).join("-");return a+this.upcomingInput()+"\n"+b+"^"},next:function(){if(this.done)return this.EOF;this._input||(this.done=!0);var a,b,c,d,e;this._more||(this.yytext="",this.match="");for(var f=this._currentRules(),g=0;g<f.length&&(c=this._input.match(this.rules[f[g]]),!c||b&&!(c[0].length>b[0].length)||(b=c,d=g,this.options.flex));g++);return b?(e=b[0].match(/(?:\r\n?|\n).*/g),e&&(this.yylineno+=e.length),this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:e?e[e.length-1].length-e[e.length-1].match(/\r?\n?/)[0].length:this.yylloc.last_column+b[0].length},this.yytext+=b[0],this.match+=b[0],this.matches=b,this.yyleng=this.yytext.length,this.options.ranges&&(this.yylloc.range=[this.offset,this.offset+=this.yyleng]),this._more=!1,this._input=this._input.slice(b[0].length),this.matched+=b[0],a=this.performAction.call(this,this.yy,this,f[d],this.conditionStack[this.conditionStack.length-1]),this.done&&this._input&&(this.done=!1),a?a:void 0):""===this._input?this.EOF:this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},lex:function(){var a=this.next();return"undefined"!=typeof a?a:this.lex()},begin:function(a){this.conditionStack.push(a)},popState:function(){return this.conditionStack.pop()},_currentRules:function(){return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules},topState:function(){return this.conditionStack[this.conditionStack.length-2]},pushState:function(a){this.begin(a)}};return a.options={},a.performAction=function(a,b,c,d){function e(a,c){return b.yytext=b.yytext.substr(a,b.yyleng-c)}switch(c){case 0:if("\\\\"===b.yytext.slice(-2)?(e(0,1),this.begin("mu")):"\\"===b.yytext.slice(-1)?(e(0,1),this.begin("emu")):this.begin("mu"),b.yytext)return 15;break;case 1:return 15;case 2:return this.popState(),15;case 3:return this.begin("raw"),15;case 4:return this.popState(),"raw"===this.conditionStack[this.conditionStack.length-1]?15:(b.yytext=b.yytext.substr(5,b.yyleng-9),"END_RAW_BLOCK");case 5:return 15;case 6:return this.popState(),14;case 7:return 65;case 8:return 68;case 9:return 19;case 10:return this.popState(),this.begin("raw"),23;case 11:return 55;case 12:return 60;case 13:return 29;case 14:return 47;case 15:return this.popState(),44;case 16:return this.popState(),44;case 17:return 34;case 18:return 39;case 19:return 51;case 20:return 48;case 21:this.unput(b.yytext),this.popState(),this.begin("com");break;case 22:return this.popState(),14;case 23:return 48;case 24:return 73;case 25:return 72;case 26:return 72;case 27:return 87;case 28:break;case 29:return this.popState(),54;case 30:return this.popState(),33;case 31:return b.yytext=e(1,2).replace(/\\"/g,'"'),80;case 32:return b.yytext=e(1,2).replace(/\\'/g,"'"),80;case 33:return 85;case 34:return 82;case 35:return 82;case 36:return 83;case 37:return 84;case 38:return 81;case 39:return 75;case 40:return 77;case 41:return 72;case 42:return b.yytext=b.yytext.replace(/\\([\\\]])/g,"$1"),72;case 43:return"INVALID";case 44:return 5}},a.rules=[/^(?:[^\x00]*?(?=(\{\{)))/,/^(?:[^\x00]+)/,/^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/,/^(?:\{\{\{\{(?=[^\/]))/,/^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/,/^(?:[^\x00]*?(?=(\{\{\{\{)))/,/^(?:[\s\S]*?--(~)?\}\})/,/^(?:\()/,/^(?:\))/,/^(?:\{\{\{\{)/,/^(?:\}\}\}\})/,/^(?:\{\{(~)?>)/,/^(?:\{\{(~)?#>)/,/^(?:\{\{(~)?#\*?)/,/^(?:\{\{(~)?\/)/,/^(?:\{\{(~)?\^\s*(~)?\}\})/,/^(?:\{\{(~)?\s*else\s*(~)?\}\})/,/^(?:\{\{(~)?\^)/,/^(?:\{\{(~)?\s*else\b)/,/^(?:\{\{(~)?\{)/,/^(?:\{\{(~)?&)/,/^(?:\{\{(~)?!--)/,/^(?:\{\{(~)?![\s\S]*?\}\})/,/^(?:\{\{(~)?\*?)/,/^(?:=)/,/^(?:\.\.)/,/^(?:\.(?=([=~}\s\/.)|])))/,/^(?:[\/.])/,/^(?:\s+)/,/^(?:\}(~)?\}\})/,/^(?:(~)?\}\})/,/^(?:"(\\["]|[^"])*")/,/^(?:'(\\[']|[^'])*')/,/^(?:@)/,/^(?:true(?=([~}\s)])))/,/^(?:false(?=([~}\s)])))/,/^(?:undefined(?=([~}\s)])))/,/^(?:null(?=([~}\s)])))/,/^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/,/^(?:as\s+\|)/,/^(?:\|)/,/^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/,/^(?:\[(\\\]|[^\]])*\])/,/^(?:.)/,/^(?:$)/],a.conditions={mu:{rules:[7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44],inclusive:!1},emu:{rules:[2],inclusive:!1},com:{rules:[6],inclusive:!1},raw:{rules:[3,4,5],inclusive:!1},INITIAL:{rules:[0,1,44],inclusive:!0}},a}();return b.lexer=c,a.prototype=b,b.Parser=a,new a}();b.__esModule=!0,b["default"]=c},function(a,b,c){function d(){var a=arguments.length<=0||void 0===arguments[0]?{}:arguments[0];this.options=a}function e(a,b,c){void 0===b&&(b=a.length);var d=a[b-1],e=a[b-2];return d?"ContentStatement"===d.type?(e||!c?/\r?\n\s*?$/:/(^|\r?\n)\s*?$/).test(d.original):void 0:c}function f(a,b,c){void 0===b&&(b=-1);var d=a[b+1],e=a[b+2];return d?"ContentStatement"===d.type?(e||!c?/^\s*?\r?\n/:/^\s*?(\r?\n|$)/).test(d.original):void 0:c}function g(a,b,c){var d=a[null==b?0:b+1];if(d&&"ContentStatement"===d.type&&(c||!d.rightStripped)){var e=d.value;d.value=d.value.replace(c?/^\s+/:/^[ \t]*\r?\n?/,""),d.rightStripped=d.value!==e}}function h(a,b,c){var d=a[null==b?a.length-1:b-1];if(d&&"ContentStatement"===d.type&&(c||!d.leftStripped)){var e=d.value;return d.value=d.value.replace(c?/\s+$/:/[ \t]+$/,""),d.leftStripped=d.value!==e,d.leftStripped}}var i=c(1)["default"];b.__esModule=!0;var j=c(25),k=i(j);d.prototype=new k["default"],d.prototype.Program=function(a){var b=!this.options.ignoreStandalone,c=!this.isRootSeen;this.isRootSeen=!0;for(var d=a.body,i=0,j=d.length;j>i;i++){var k=d[i],l=this.accept(k);if(l){var m=e(d,i,c),n=f(d,i,c),o=l.openStandalone&&m,p=l.closeStandalone&&n,q=l.inlineStandalone&&m&&n;l.close&&g(d,i,!0),l.open&&h(d,i,!0),b&&q&&(g(d,i),h(d,i)&&"PartialStatement"===k.type&&(k.indent=/([ \t]+$)/.exec(d[i-1].original)[1])),b&&o&&(g((k.program||k.inverse).body),h(d,i)),b&&p&&(g(d,i),h((k.inverse||k.program).body))}}return a},d.prototype.BlockStatement=d.prototype.DecoratorBlock=d.prototype.PartialBlockStatement=function(a){this.accept(a.program),this.accept(a.inverse);var b=a.program||a.inverse,c=a.program&&a.inverse,d=c,i=c;if(c&&c.chained)for(d=c.body[0].program;i.chained;)i=i.body[i.body.length-1].program;var j={open:a.openStrip.open,close:a.closeStrip.close,openStandalone:f(b.body),closeStandalone:e((d||b).body)};if(a.openStrip.close&&g(b.body,null,!0),c){var k=a.inverseStrip;k.open&&h(b.body,null,!0),k.close&&g(d.body,null,!0),a.closeStrip.open&&h(i.body,null,!0),!this.options.ignoreStandalone&&e(b.body)&&f(d.body)&&(h(b.body),g(d.body))}else a.closeStrip.open&&h(b.body,null,!0);return j},d.prototype.Decorator=d.prototype.MustacheStatement=function(a){return a.strip},d.prototype.PartialStatement=d.prototype.CommentStatement=function(a){var b=a.strip||{};return{inlineStandalone:!0,open:b.open,close:b.close}},b["default"]=d,a.exports=b["default"]},function(a,b,c){function d(){this.parents=[]}function e(a){this.acceptRequired(a,"path"),this.acceptArray(a.params),this.acceptKey(a,"hash")}function f(a){e.call(this,a),this.acceptKey(a,"program"),this.acceptKey(a,"inverse")}function g(a){this.acceptRequired(a,"name"),this.acceptArray(a.params),this.acceptKey(a,"hash")}var h=c(1)["default"];b.__esModule=!0;var i=c(6),j=h(i);d.prototype={constructor:d,mutating:!1,acceptKey:function(a,b){var c=this.accept(a[b]);if(this.mutating){if(c&&!d.prototype[c.type])throw new j["default"]('Unexpected node type "'+c.type+'" found when accepting '+b+" on "+a.type);a[b]=c}},acceptRequired:function(a,b){if(this.acceptKey(a,b),!a[b])throw new j["default"](a.type+" requires "+b)},acceptArray:function(a){for(var b=0,c=a.length;c>b;b++)this.acceptKey(a,b),a[b]||(a.splice(b,1),b--,c--)},accept:function(a){if(a){if(!this[a.type])throw new j["default"]("Unknown type: "+a.type,a);this.current&&this.parents.unshift(this.current),this.current=a;var b=this[a.type](a);return this.current=this.parents.shift(),!this.mutating||b?b:b!==!1?a:void 0}},Program:function(a){this.acceptArray(a.body)},MustacheStatement:e,Decorator:e,BlockStatement:f,DecoratorBlock:f,PartialStatement:g,PartialBlockStatement:function(a){g.call(this,a),this.acceptKey(a,"program")},ContentStatement:function(){},CommentStatement:function(){},SubExpression:e,PathExpression:function(){},StringLiteral:function(){},NumberLiteral:function(){},BooleanLiteral:function(){},UndefinedLiteral:function(){},NullLiteral:function(){},Hash:function(a){this.acceptArray(a.pairs)},HashPair:function(a){this.acceptRequired(a,"value")}},b["default"]=d,a.exports=b["default"]},function(a,b,c){function d(a,b){if(b=b.path?b.path.original:b,a.path.original!==b){var c={loc:a.path.loc};throw new q["default"](a.path.original+" doesn't match "+b,c)}}function e(a,b){this.source=a,this.start={line:b.first_line,column:b.first_column},this.end={line:b.last_line,column:b.last_column}}function f(a){return/^\[.*\]$/.test(a)?a.substr(1,a.length-2):a}function g(a,b){return{open:"~"===a.charAt(2),close:"~"===b.charAt(b.length-3)}}function h(a){return a.replace(/^\{\{~?\!-?-?/,"").replace(/-?-?~?\}\}$/,"")}function i(a,b,c){c=this.locInfo(c);for(var d=a?"@":"",e=[],f=0,g="",h=0,i=b.length;i>h;h++){var j=b[h].part,k=b[h].original!==j;if(d+=(b[h].separator||"")+j,k||".."!==j&&"."!==j&&"this"!==j)e.push(j);else{if(e.length>0)throw new q["default"]("Invalid path: "+d,{loc:c});".."===j&&(f++,g+="../")}}return{type:"PathExpression",data:a,depth:f,parts:e,original:d,loc:c}}function j(a,b,c,d,e,f){var g=d.charAt(3)||d.charAt(2),h="{"!==g&&"&"!==g,i=/\*/.test(d);return{type:i?"Decorator":"MustacheStatement",path:a,params:b,hash:c,escaped:h,strip:e,loc:this.locInfo(f)}}function k(a,b,c,e){d(a,c),e=this.locInfo(e);var f={type:"Program",body:b,strip:{},loc:e};return{type:"BlockStatement",path:a.path,params:a.params,hash:a.hash,program:f,openStrip:{},inverseStrip:{},closeStrip:{},loc:e}}function l(a,b,c,e,f,g){e&&e.path&&d(a,e);var h=/\*/.test(a.open);b.blockParams=a.blockParams;var i=void 0,j=void 0;if(c){if(h)throw new q["default"]("Unexpected inverse block on decorator",c);c.chain&&(c.program.body[0].closeStrip=e.strip),j=c.strip,i=c.program}return f&&(f=i,i=b,b=f),{type:h?"DecoratorBlock":"BlockStatement",path:a.path,params:a.params,hash:a.hash,program:b,inverse:i,openStrip:a.strip,inverseStrip:j,closeStrip:e&&e.strip,loc:this.locInfo(g)}}function m(a,b){if(!b&&a.length){var c=a[0].loc,d=a[a.length-1].loc;c&&d&&(b={source:c.source,start:{line:c.start.line,column:c.start.column},end:{line:d.end.line,column:d.end.column}})}return{type:"Program",body:a,strip:{},loc:b}}function n(a,b,c,e){return d(a,c),{type:"PartialBlockStatement",name:a.path,params:a.params,hash:a.hash,program:b,openStrip:a.strip,closeStrip:c&&c.strip,loc:this.locInfo(e)}}var o=c(1)["default"];b.__esModule=!0,b.SourceLocation=e,b.id=f,b.stripFlags=g,b.stripComment=h,b.preparePath=i,b.prepareMustache=j,b.prepareRawBlock=k,b.prepareBlock=l,b.prepareProgram=m,b.preparePartialBlock=n;var p=c(6),q=o(p)},function(a,b,c){function d(){}function e(a,b,c){if(null==a||"string"!=typeof a&&"Program"!==a.type)throw new k["default"]("You must pass a string or Handlebars AST to Handlebars.precompile. You passed "+a);b=b||{},"data"in b||(b.data=!0),b.compat&&(b.useDepths=!0);var d=c.parse(a,b),e=(new c.Compiler).compile(d,b);return(new c.JavaScriptCompiler).compile(e,b)}function f(a,b,c){function d(){var d=c.parse(a,b),e=(new c.Compiler).compile(d,b),f=(new c.JavaScriptCompiler).compile(e,b,void 0,!0);return c.template(f)}function e(a,b){return f||(f=d()),f.call(this,a,b)}if(void 0===b&&(b={}),null==a||"string"!=typeof a&&"Program"!==a.type)throw new k["default"]("You must pass a string or Handlebars AST to Handlebars.compile. You passed "+a);"data"in b||(b.data=!0),b.compat&&(b.useDepths=!0);var f=void 0;return e._setup=function(a){return f||(f=d()),f._setup(a)},e._child=function(a,b,c,e){return f||(f=d()),f._child(a,b,c,e)},e}function g(a,b){if(a===b)return!0;if(l.isArray(a)&&l.isArray(b)&&a.length===b.length){for(var c=0;c<a.length;c++)if(!g(a[c],b[c]))return!1;return!0}}function h(a){if(!a.path.parts){var b=a.path;a.path={type:"PathExpression",data:!1,depth:0,parts:[b.original+""],original:b.original+"",loc:b.loc}}}var i=c(1)["default"];b.__esModule=!0,b.Compiler=d,b.precompile=e,b.compile=f;var j=c(6),k=i(j),l=c(5),m=c(21),n=i(m),o=[].slice;d.prototype={compiler:d,equals:function(a){var b=this.opcodes.length;if(a.opcodes.length!==b)return!1;for(var c=0;b>c;c++){var d=this.opcodes[c],e=a.opcodes[c];if(d.opcode!==e.opcode||!g(d.args,e.args))return!1}b=this.children.length;for(var c=0;b>c;c++)if(!this.children[c].equals(a.children[c]))return!1;return!0},guid:0,compile:function(a,b){this.sourceNode=[],this.opcodes=[],this.children=[],this.options=b,this.stringParams=b.stringParams,this.trackIds=b.trackIds,b.blockParams=b.blockParams||[];var c=b.knownHelpers;if(b.knownHelpers={helperMissing:!0,blockHelperMissing:!0,each:!0,"if":!0,unless:!0,"with":!0,log:!0,lookup:!0},c)for(var d in c)d in c&&(b.knownHelpers[d]=c[d]);return this.accept(a)},compileProgram:function(a){var b=new this.compiler,c=b.compile(a,this.options),d=this.guid++;return this.usePartial=this.usePartial||c.usePartial,this.children[d]=c,this.useDepths=this.useDepths||c.useDepths,d},accept:function(a){if(!this[a.type])throw new k["default"]("Unknown type: "+a.type,a);this.sourceNode.unshift(a);var b=this[a.type](a);return this.sourceNode.shift(),b},Program:function(a){this.options.blockParams.unshift(a.blockParams);for(var b=a.body,c=b.length,d=0;c>d;d++)this.accept(b[d]);return this.options.blockParams.shift(),this.isSimple=1===c,this.blockParams=a.blockParams?a.blockParams.length:0,this},BlockStatement:function(a){h(a);var b=a.program,c=a.inverse;b=b&&this.compileProgram(b),c=c&&this.compileProgram(c);var d=this.classifySexpr(a);"helper"===d?this.helperSexpr(a,b,c):"simple"===d?(this.simpleSexpr(a),this.opcode("pushProgram",b),this.opcode("pushProgram",c),this.opcode("emptyHash"),this.opcode("blockValue",a.path.original)):(this.ambiguousSexpr(a,b,c),this.opcode("pushProgram",b),this.opcode("pushProgram",c),this.opcode("emptyHash"),this.opcode("ambiguousBlockValue")),this.opcode("append")},DecoratorBlock:function(a){var b=a.program&&this.compileProgram(a.program),c=this.setupFullMustacheParams(a,b,void 0),d=a.path;this.useDecorators=!0,this.opcode("registerDecorator",c.length,d.original)},PartialStatement:function(a){this.usePartial=!0;var b=a.program;b&&(b=this.compileProgram(a.program));var c=a.params;if(c.length>1)throw new k["default"]("Unsupported number of partial arguments: "+c.length,a);c.length||(this.options.explicitPartialContext?this.opcode("pushLiteral","undefined"):c.push({type:"PathExpression",parts:[],depth:0}));var d=a.name.original,e="SubExpression"===a.name.type;e&&this.accept(a.name),this.setupFullMustacheParams(a,b,void 0,!0);var f=a.indent||"";this.options.preventIndent&&f&&(this.opcode("appendContent",f),f=""),this.opcode("invokePartial",e,d,f),this.opcode("append")},PartialBlockStatement:function(a){this.PartialStatement(a)},MustacheStatement:function(a){this.SubExpression(a),a.escaped&&!this.options.noEscape?this.opcode("appendEscaped"):this.opcode("append")},Decorator:function(a){this.DecoratorBlock(a)},ContentStatement:function(a){a.value&&this.opcode("appendContent",a.value)},CommentStatement:function(){},SubExpression:function(a){h(a);var b=this.classifySexpr(a);"simple"===b?this.simpleSexpr(a):"helper"===b?this.helperSexpr(a):this.ambiguousSexpr(a)},ambiguousSexpr:function(a,b,c){var d=a.path,e=d.parts[0],f=null!=b||null!=c;this.opcode("getContext",d.depth),this.opcode("pushProgram",b),this.opcode("pushProgram",c),d.strict=!0,this.accept(d),this.opcode("invokeAmbiguous",e,f)},simpleSexpr:function(a){var b=a.path;b.strict=!0,this.accept(b),this.opcode("resolvePossibleLambda")},helperSexpr:function(a,b,c){var d=this.setupFullMustacheParams(a,b,c),e=a.path,f=e.parts[0];if(this.options.knownHelpers[f])this.opcode("invokeKnownHelper",d.length,f);else{if(this.options.knownHelpersOnly)throw new k["default"]("You specified knownHelpersOnly, but used the unknown helper "+f,a);e.strict=!0,e.falsy=!0,this.accept(e),this.opcode("invokeHelper",d.length,e.original,n["default"].helpers.simpleId(e))}},PathExpression:function(a){this.addDepth(a.depth),this.opcode("getContext",a.depth);var b=a.parts[0],c=n["default"].helpers.scopedId(a),d=!a.depth&&!c&&this.blockParamIndex(b);d?this.opcode("lookupBlockParam",d,a.parts):b?a.data?(this.options.data=!0,this.opcode("lookupData",a.depth,a.parts,a.strict)):this.opcode("lookupOnContext",a.parts,a.falsy,a.strict,c):this.opcode("pushContext")},StringLiteral:function(a){this.opcode("pushString",a.value)},NumberLiteral:function(a){this.opcode("pushLiteral",a.value)},BooleanLiteral:function(a){this.opcode("pushLiteral",a.value)},UndefinedLiteral:function(){this.opcode("pushLiteral","undefined")},NullLiteral:function(){this.opcode("pushLiteral","null")},Hash:function(a){var b=a.pairs,c=0,d=b.length;for(this.opcode("pushHash");d>c;c++)this.pushParam(b[c].value);for(;c--;)this.opcode("assignToHash",b[c].key);this.opcode("popHash")},opcode:function(a){this.opcodes.push({opcode:a,args:o.call(arguments,1),loc:this.sourceNode[0].loc})},addDepth:function(a){a&&(this.useDepths=!0)},classifySexpr:function(a){var b=n["default"].helpers.simpleId(a.path),c=b&&!!this.blockParamIndex(a.path.parts[0]),d=!c&&n["default"].helpers.helperExpression(a),e=!c&&(d||b);if(e&&!d){var f=a.path.parts[0],g=this.options;g.knownHelpers[f]?d=!0:g.knownHelpersOnly&&(e=!1)}return d?"helper":e?"ambiguous":"simple"},pushParams:function(a){for(var b=0,c=a.length;c>b;b++)this.pushParam(a[b])},pushParam:function(a){var b=null!=a.value?a.value:a.original||"";if(this.stringParams)b.replace&&(b=b.replace(/^(\.?\.\/)*/g,"").replace(/\//g,".")),a.depth&&this.addDepth(a.depth),this.opcode("getContext",a.depth||0),this.opcode("pushStringParam",b,a.type),"SubExpression"===a.type&&this.accept(a);else{if(this.trackIds){var c=void 0;if(!a.parts||n["default"].helpers.scopedId(a)||a.depth||(c=this.blockParamIndex(a.parts[0])),c){var d=a.parts.slice(1).join(".");this.opcode("pushId","BlockParam",c,d)}else b=a.original||b,b.replace&&(b=b.replace(/^this(?:\.|$)/,"").replace(/^\.\//,"").replace(/^\.$/,"")),this.opcode("pushId",a.type,b)}this.accept(a)}},setupFullMustacheParams:function(a,b,c,d){var e=a.params;return this.pushParams(e),this.opcode("pushProgram",b),this.opcode("pushProgram",c),a.hash?this.accept(a.hash):this.opcode("emptyHash",d),e},blockParamIndex:function(a){for(var b=0,c=this.options.blockParams.length;c>b;b++){var d=this.options.blockParams[b],e=d&&l.indexOf(d,a);if(d&&e>=0)return[b,e]}}}},function(a,b,c){function d(a){this.value=a}function e(){}function f(a,b,c,d){var e=b.popStack(),f=0,g=c.length;for(a&&g--;g>f;f++)e=b.nameLookup(e,c[f],d);return a?[b.aliasable("container.strict"),"(",e,", ",b.quotedString(c[f]),")"]:e}var g=c(1)["default"];b.__esModule=!0;var h=c(4),i=c(6),j=g(i),k=c(5),l=c(29),m=g(l);e.prototype={nameLookup:function(a,b){return e.isValidJavaScriptVariableName(b)?[a,".",b]:[a,"[",JSON.stringify(b),"]"]},depthedLookup:function(a){return[this.aliasable("container.lookup"),'(depths, "',a,'")']},compilerInfo:function(){var a=h.COMPILER_REVISION,b=h.REVISION_CHANGES[a];return[a,b]},appendToBuffer:function(a,b,c){return k.isArray(a)||(a=[a]),a=this.source.wrap(a,b),this.environment.isSimple?["return ",a,";"]:c?["buffer += ",a,";"]:(a.appendToBuffer=!0,a)},initializeBuffer:function(){return this.quotedString("")},compile:function(a,b,c,d){this.environment=a,this.options=b,this.stringParams=this.options.stringParams,this.trackIds=this.options.trackIds,this.precompile=!d,this.name=this.environment.name,this.isChild=!!c,this.context=c||{decorators:[],programs:[],environments:[]},this.preamble(),this.stackSlot=0,this.stackVars=[],this.aliases={},this.registers={list:[]},this.hashes=[],this.compileStack=[],this.inlineStack=[],this.blockParams=[],this.compileChildren(a,b),this.useDepths=this.useDepths||a.useDepths||a.useDecorators||this.options.compat,this.useBlockParams=this.useBlockParams||a.useBlockParams;var e=a.opcodes,f=void 0,g=void 0,h=void 0,i=void 0;for(h=0,i=e.length;i>h;h++)f=e[h],this.source.currentLocation=f.loc,g=g||f.loc,this[f.opcode].apply(this,f.args);if(this.source.currentLocation=g,this.pushSource(""),this.stackSlot||this.inlineStack.length||this.compileStack.length)throw new j["default"]("Compile completed with content left on stack");this.decorators.isEmpty()?this.decorators=void 0:(this.useDecorators=!0,this.decorators.prepend("var decorators = container.decorators;\n"),this.decorators.push("return fn;"),d?this.decorators=Function.apply(this,["fn","props","container","depth0","data","blockParams","depths",this.decorators.merge()]):(this.decorators.prepend("function(fn, props, container, depth0, data, blockParams, depths) {\n"),this.decorators.push("}\n"),this.decorators=this.decorators.merge()));var k=this.createFunctionContext(d);if(this.isChild)return k;var l={compiler:this.compilerInfo(),main:k};this.decorators&&(l.main_d=this.decorators,l.useDecorators=!0);var m=this.context,n=m.programs,o=m.decorators;for(h=0,i=n.length;i>h;h++)n[h]&&(l[h]=n[h],o[h]&&(l[h+"_d"]=o[h],l.useDecorators=!0));return this.environment.usePartial&&(l.usePartial=!0),this.options.data&&(l.useData=!0),this.useDepths&&(l.useDepths=!0),this.useBlockParams&&(l.useBlockParams=!0),this.options.compat&&(l.compat=!0),d?l.compilerOptions=this.options:(l.compiler=JSON.stringify(l.compiler),this.source.currentLocation={start:{line:1,column:0}},l=this.objectLiteral(l),b.srcName?(l=l.toStringWithSourceMap({file:b.destName}),l.map=l.map&&l.map.toString()):l=l.toString()),l},preamble:function(){this.lastContext=0,this.source=new m["default"](this.options.srcName),this.decorators=new m["default"](this.options.srcName)},createFunctionContext:function(a){var b="",c=this.stackVars.concat(this.registers.list);c.length>0&&(b+=", "+c.join(", "));var d=0;for(var e in this.aliases){var f=this.aliases[e];this.aliases.hasOwnProperty(e)&&f.children&&f.referenceCount>1&&(b+=", alias"+ ++d+"="+e,f.children[0]="alias"+d)}var g=["container","depth0","helpers","partials","data"];(this.useBlockParams||this.useDepths)&&g.push("blockParams"),this.useDepths&&g.push("depths");var h=this.mergeSource(b);return a?(g.push(h),Function.apply(this,g)):this.source.wrap(["function(",g.join(","),") {\n  ",h,"}"])},mergeSource:function(a){var b=this.environment.isSimple,c=!this.forceBuffer,d=void 0,e=void 0,f=void 0,g=void 0;return this.source.each(function(a){a.appendToBuffer?(f?a.prepend("  + "):f=a,g=a):(f&&(e?f.prepend("buffer += "):d=!0,g.add(";"),f=g=void 0),e=!0,b||(c=!1))}),c?f?(f.prepend("return "),g.add(";")):e||this.source.push('return "";'):(a+=", buffer = "+(d?"":this.initializeBuffer()),f?(f.prepend("return buffer + "),g.add(";")):this.source.push("return buffer;")),a&&this.source.prepend("var "+a.substring(2)+(d?"":";\n")),this.source.merge()},blockValue:function(a){var b=this.aliasable("helpers.blockHelperMissing"),c=[this.contextName(0)];this.setupHelperArgs(a,0,c);var d=this.popStack();c.splice(1,0,d),this.push(this.source.functionCall(b,"call",c))},ambiguousBlockValue:function(){var a=this.aliasable("helpers.blockHelperMissing"),b=[this.contextName(0)];this.setupHelperArgs("",0,b,!0),this.flushInline();var c=this.topStack();b.splice(1,0,c),this.pushSource(["if (!",this.lastHelper,") { ",c," = ",this.source.functionCall(a,"call",b),"}"])},appendContent:function(a){this.pendingContent?a=this.pendingContent+a:this.pendingLocation=this.source.currentLocation,this.pendingContent=a},append:function(){if(this.isInline())this.replaceStack(function(a){return[" != null ? ",a,' : ""']}),this.pushSource(this.appendToBuffer(this.popStack()));else{var a=this.popStack();this.pushSource(["if (",a," != null) { ",this.appendToBuffer(a,void 0,!0)," }"]),this.environment.isSimple&&this.pushSource(["else { ",this.appendToBuffer("''",void 0,!0)," }"])}},appendEscaped:function(){this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"),"(",this.popStack(),")"]))},getContext:function(a){this.lastContext=a},pushContext:function(){this.pushStackLiteral(this.contextName(this.lastContext))},lookupOnContext:function(a,b,c,d){var e=0;d||!this.options.compat||this.lastContext?this.pushContext():this.push(this.depthedLookup(a[e++])),this.resolvePath("context",a,e,b,c)},lookupBlockParam:function(a,b){this.useBlockParams=!0,this.push(["blockParams[",a[0],"][",a[1],"]"]),this.resolvePath("context",b,1)},lookupData:function(a,b,c){a?this.pushStackLiteral("container.data(data, "+a+")"):this.pushStackLiteral("data"),this.resolvePath("data",b,0,!0,c)},resolvePath:function(a,b,c,d,e){var g=this;if(this.options.strict||this.options.assumeObjects)return void this.push(f(this.options.strict&&e,this,b,a));for(var h=b.length;h>c;c++)this.replaceStack(function(e){var f=g.nameLookup(e,b[c],a);return d?[" && ",f]:[" != null ? ",f," : ",e]})},resolvePossibleLambda:function(){this.push([this.aliasable("container.lambda"),"(",this.popStack(),", ",this.contextName(0),")"])},pushStringParam:function(a,b){this.pushContext(),this.pushString(b),"SubExpression"!==b&&("string"==typeof a?this.pushString(a):this.pushStackLiteral(a))},emptyHash:function(a){this.trackIds&&this.push("{}"),this.stringParams&&(this.push("{}"),this.push("{}")),this.pushStackLiteral(a?"undefined":"{}")},pushHash:function(){this.hash&&this.hashes.push(this.hash),this.hash={values:[],types:[],contexts:[],ids:[]}},popHash:function(){var a=this.hash;this.hash=this.hashes.pop(),this.trackIds&&this.push(this.objectLiteral(a.ids)),this.stringParams&&(this.push(this.objectLiteral(a.contexts)),this.push(this.objectLiteral(a.types))),this.push(this.objectLiteral(a.values))},pushString:function(a){this.pushStackLiteral(this.quotedString(a))},pushLiteral:function(a){this.pushStackLiteral(a)},pushProgram:function(a){null!=a?this.pushStackLiteral(this.programExpression(a)):this.pushStackLiteral(null)},registerDecorator:function(a,b){var c=this.nameLookup("decorators",b,"decorator"),d=this.setupHelperArgs(b,a);this.decorators.push(["fn = ",this.decorators.functionCall(c,"",["fn","props","container",d])," || fn;"])},invokeHelper:function(a,b,c){var d=this.popStack(),e=this.setupHelper(a,b),f=c?[e.name," || "]:"",g=["("].concat(f,d);this.options.strict||g.push(" || ",this.aliasable("helpers.helperMissing")),g.push(")"),this.push(this.source.functionCall(g,"call",e.callParams))},invokeKnownHelper:function(a,b){var c=this.setupHelper(a,b);this.push(this.source.functionCall(c.name,"call",c.callParams))},invokeAmbiguous:function(a,b){this.useRegister("helper");var c=this.popStack();this.emptyHash();var d=this.setupHelper(0,a,b),e=this.lastHelper=this.nameLookup("helpers",a,"helper"),f=["(","(helper = ",e," || ",c,")"];this.options.strict||(f[0]="(helper = ",f.push(" != null ? helper : ",this.aliasable("helpers.helperMissing"))),this.push(["(",f,d.paramsInit?["),(",d.paramsInit]:[],"),","(typeof helper === ",this.aliasable('"function"')," ? ",this.source.functionCall("helper","call",d.callParams)," : helper))"])},invokePartial:function(a,b,c){var d=[],e=this.setupParams(b,1,d);a&&(b=this.popStack(),delete e.name),c&&(e.indent=JSON.stringify(c)),e.helpers="helpers",e.partials="partials",e.decorators="container.decorators",a?d.unshift(b):d.unshift(this.nameLookup("partials",b,"partial")),this.options.compat&&(e.depths="depths"),e=this.objectLiteral(e),
d.push(e),this.push(this.source.functionCall("container.invokePartial","",d))},assignToHash:function(a){var b=this.popStack(),c=void 0,d=void 0,e=void 0;this.trackIds&&(e=this.popStack()),this.stringParams&&(d=this.popStack(),c=this.popStack());var f=this.hash;c&&(f.contexts[a]=c),d&&(f.types[a]=d),e&&(f.ids[a]=e),f.values[a]=b},pushId:function(a,b,c){"BlockParam"===a?this.pushStackLiteral("blockParams["+b[0]+"].path["+b[1]+"]"+(c?" + "+JSON.stringify("."+c):"")):"PathExpression"===a?this.pushString(b):"SubExpression"===a?this.pushStackLiteral("true"):this.pushStackLiteral("null")},compiler:e,compileChildren:function(a,b){for(var c=a.children,d=void 0,e=void 0,f=0,g=c.length;g>f;f++){d=c[f],e=new this.compiler;var h=this.matchExistingProgram(d);null==h?(this.context.programs.push(""),h=this.context.programs.length,d.index=h,d.name="program"+h,this.context.programs[h]=e.compile(d,b,this.context,!this.precompile),this.context.decorators[h]=e.decorators,this.context.environments[h]=d,this.useDepths=this.useDepths||e.useDepths,this.useBlockParams=this.useBlockParams||e.useBlockParams):(d.index=h,d.name="program"+h,this.useDepths=this.useDepths||d.useDepths,this.useBlockParams=this.useBlockParams||d.useBlockParams)}},matchExistingProgram:function(a){for(var b=0,c=this.context.environments.length;c>b;b++){var d=this.context.environments[b];if(d&&d.equals(a))return b}},programExpression:function(a){var b=this.environment.children[a],c=[b.index,"data",b.blockParams];return(this.useBlockParams||this.useDepths)&&c.push("blockParams"),this.useDepths&&c.push("depths"),"container.program("+c.join(", ")+")"},useRegister:function(a){this.registers[a]||(this.registers[a]=!0,this.registers.list.push(a))},push:function(a){return a instanceof d||(a=this.source.wrap(a)),this.inlineStack.push(a),a},pushStackLiteral:function(a){this.push(new d(a))},pushSource:function(a){this.pendingContent&&(this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent),this.pendingLocation)),this.pendingContent=void 0),a&&this.source.push(a)},replaceStack:function(a){var b=["("],c=void 0,e=void 0,f=void 0;if(!this.isInline())throw new j["default"]("replaceStack on non-inline");var g=this.popStack(!0);if(g instanceof d)c=[g.value],b=["(",c],f=!0;else{e=!0;var h=this.incrStack();b=["((",this.push(h)," = ",g,")"],c=this.topStack()}var i=a.call(this,c);f||this.popStack(),e&&this.stackSlot--,this.push(b.concat(i,")"))},incrStack:function(){return this.stackSlot++,this.stackSlot>this.stackVars.length&&this.stackVars.push("stack"+this.stackSlot),this.topStackName()},topStackName:function(){return"stack"+this.stackSlot},flushInline:function(){var a=this.inlineStack;this.inlineStack=[];for(var b=0,c=a.length;c>b;b++){var e=a[b];if(e instanceof d)this.compileStack.push(e);else{var f=this.incrStack();this.pushSource([f," = ",e,";"]),this.compileStack.push(f)}}},isInline:function(){return this.inlineStack.length},popStack:function(a){var b=this.isInline(),c=(b?this.inlineStack:this.compileStack).pop();if(!a&&c instanceof d)return c.value;if(!b){if(!this.stackSlot)throw new j["default"]("Invalid stack pop");this.stackSlot--}return c},topStack:function(){var a=this.isInline()?this.inlineStack:this.compileStack,b=a[a.length-1];return b instanceof d?b.value:b},contextName:function(a){return this.useDepths&&a?"depths["+a+"]":"depth"+a},quotedString:function(a){return this.source.quotedString(a)},objectLiteral:function(a){return this.source.objectLiteral(a)},aliasable:function(a){var b=this.aliases[a];return b?(b.referenceCount++,b):(b=this.aliases[a]=this.source.wrap(a),b.aliasable=!0,b.referenceCount=1,b)},setupHelper:function(a,b,c){var d=[],e=this.setupHelperArgs(b,a,d,c),f=this.nameLookup("helpers",b,"helper"),g=this.aliasable(this.contextName(0)+" != null ? "+this.contextName(0)+" : {}");return{params:d,paramsInit:e,name:f,callParams:[g].concat(d)}},setupParams:function(a,b,c){var d={},e=[],f=[],g=[],h=!c,i=void 0;h&&(c=[]),d.name=this.quotedString(a),d.hash=this.popStack(),this.trackIds&&(d.hashIds=this.popStack()),this.stringParams&&(d.hashTypes=this.popStack(),d.hashContexts=this.popStack());var j=this.popStack(),k=this.popStack();(k||j)&&(d.fn=k||"container.noop",d.inverse=j||"container.noop");for(var l=b;l--;)i=this.popStack(),c[l]=i,this.trackIds&&(g[l]=this.popStack()),this.stringParams&&(f[l]=this.popStack(),e[l]=this.popStack());return h&&(d.args=this.source.generateArray(c)),this.trackIds&&(d.ids=this.source.generateArray(g)),this.stringParams&&(d.types=this.source.generateArray(f),d.contexts=this.source.generateArray(e)),this.options.data&&(d.data="data"),this.useBlockParams&&(d.blockParams="blockParams"),d},setupHelperArgs:function(a,b,c,d){var e=this.setupParams(a,b,c);return e=this.objectLiteral(e),d?(this.useRegister("options"),c.push("options"),["options=",e]):c?(c.push(e),""):e}},function(){for(var a="break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" "),b=e.RESERVED_WORDS={},c=0,d=a.length;d>c;c++)b[a[c]]=!0}(),e.isValidJavaScriptVariableName=function(a){return!e.RESERVED_WORDS[a]&&/^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(a)},b["default"]=e,a.exports=b["default"]},function(a,b,c){function d(a,b,c){if(f.isArray(a)){for(var d=[],e=0,g=a.length;g>e;e++)d.push(b.wrap(a[e],c));return d}return"boolean"==typeof a||"number"==typeof a?a+"":a}function e(a){this.srcFile=a,this.source=[]}b.__esModule=!0;var f=c(5),g=void 0;try{}catch(h){}g||(g=function(a,b,c,d){this.src="",d&&this.add(d)},g.prototype={add:function(a){f.isArray(a)&&(a=a.join("")),this.src+=a},prepend:function(a){f.isArray(a)&&(a=a.join("")),this.src=a+this.src},toStringWithSourceMap:function(){return{code:this.toString()}},toString:function(){return this.src}}),e.prototype={isEmpty:function(){return!this.source.length},prepend:function(a,b){this.source.unshift(this.wrap(a,b))},push:function(a,b){this.source.push(this.wrap(a,b))},merge:function(){var a=this.empty();return this.each(function(b){a.add(["  ",b,"\n"])}),a},each:function(a){for(var b=0,c=this.source.length;c>b;b++)a(this.source[b])},empty:function(){var a=this.currentLocation||{start:{}};return new g(a.start.line,a.start.column,this.srcFile)},wrap:function(a){var b=arguments.length<=1||void 0===arguments[1]?this.currentLocation||{start:{}}:arguments[1];return a instanceof g?a:(a=d(a,this,b),new g(b.start.line,b.start.column,this.srcFile,a))},functionCall:function(a,b,c){return c=this.generateList(c),this.wrap([a,b?"."+b+"(":"(",c,")"])},quotedString:function(a){return'"'+(a+"").replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")+'"'},objectLiteral:function(a){var b=[];for(var c in a)if(a.hasOwnProperty(c)){var e=d(a[c],this);"undefined"!==e&&b.push([this.quotedString(c),":",e])}var f=this.generateList(b);return f.prepend("{"),f.add("}"),f},generateList:function(a){for(var b=this.empty(),c=0,e=a.length;e>c;c++)c&&b.add(","),b.add(d(a[c],this));return b},generateArray:function(a){var b=this.generateList(a);return b.prepend("["),b.add("]"),b}},b["default"]=e,a.exports=b["default"]}])});


/*
* jQuery Mobile v1.4.5
* http://jquerymobile.com
*
* Copyright 2010, 2014 jQuery Foundation, Inc. and other contributors
* Released under the MIT license.
* http://jquery.org/license
*
*/

(function ( root, doc, factory ) {
// FDB No need - Fix build release bug
//	if ( typeof define === "function" && define.amd ) {
//		// AMD. Register as an anonymous module.
//		define( [ "jquery" ], function ( $ ) {
//			factory( $, root, doc );
//			return $.mobile;
//		});
//	} else {
		// Browser globals
		factory( root.jQuery, root, doc );
//	}
}( this, document, function ( jQuery, window, document, undefined ) {	(function( $, undefined ) {
		$.extend( $.support, {
			orientation: "orientation" in window && "onorientationchange" in window
		});
	}( jQuery ));


	// throttled resize event
	(function( $ ) {
		$.event.special.throttledresize = {
			setup: function() {
				$( this ).bind( "resize", handler );
			},
			teardown: function() {
				$( this ).unbind( "resize", handler );
			}
		};

		var throttle = 250,
			handler = function() {
				curr = ( new Date() ).getTime();
				diff = curr - lastCall;

				if ( diff >= throttle ) {

					lastCall = curr;
					$( this ).trigger( "throttledresize" );

				} else {

					if ( heldCall ) {
						clearTimeout( heldCall );
					}

					// Promise a held call will still execute
					heldCall = setTimeout( handler, throttle - diff );
				}
			},
			lastCall = 0,
			heldCall,
			curr,
			diff;
	})( jQuery );


(function( $, window ) {
	var win = $( window ),
		event_name = "orientationchange",
		get_orientation,
		last_orientation,
		initial_orientation_is_landscape,
		initial_orientation_is_default,
		portrait_map = { "0": true, "180": true },
		ww, wh, landscape_threshold;

	// It seems that some device/browser vendors use window.orientation values 0 and 180 to
	// denote the "default" orientation. For iOS devices, and most other smart-phones tested,
	// the default orientation is always "portrait", but in some Android and RIM based tablets,
	// the default orientation is "landscape". The following code attempts to use the window
	// dimensions to figure out what the current orientation is, and then makes adjustments
	// to the to the portrait_map if necessary, so that we can properly decode the
	// window.orientation value whenever get_orientation() is called.
	//
	// Note that we used to use a media query to figure out what the orientation the browser
	// thinks it is in:
	//
	//     initial_orientation_is_landscape = $.mobile.media("all and (orientation: landscape)");
	//
	// but there was an iPhone/iPod Touch bug beginning with iOS 4.2, up through iOS 5.1,
	// where the browser *ALWAYS* applied the landscape media query. This bug does not
	// happen on iPad.

	if ( $.support.orientation ) {

		// Check the window width and height to figure out what the current orientation
		// of the device is at this moment. Note that we've initialized the portrait map
		// values to 0 and 180, *AND* we purposely check for landscape so that if we guess
		// wrong, , we default to the assumption that portrait is the default orientation.
		// We use a threshold check below because on some platforms like iOS, the iPhone
		// form-factor can report a larger width than height if the user turns on the
		// developer console. The actual threshold value is somewhat arbitrary, we just
		// need to make sure it is large enough to exclude the developer console case.

		ww = window.innerWidth || win.width();
		wh = window.innerHeight || win.height();
		landscape_threshold = 50;

		initial_orientation_is_landscape = ww > wh && ( ww - wh ) > landscape_threshold;

		// Now check to see if the current window.orientation is 0 or 180.
		initial_orientation_is_default = portrait_map[ window.orientation ];

		// If the initial orientation is landscape, but window.orientation reports 0 or 180, *OR*
		// if the initial orientation is portrait, but window.orientation reports 90 or -90, we
		// need to flip our portrait_map values because landscape is the default orientation for
		// this device/browser.
		if ( ( initial_orientation_is_landscape && initial_orientation_is_default ) || ( !initial_orientation_is_landscape && !initial_orientation_is_default ) ) {
			portrait_map = { "-90": true, "90": true };
		}
	}

	$.event.special.orientationchange = $.extend( {}, $.event.special.orientationchange, {
		setup: function() {
			// If the event is supported natively, return false so that jQuery
			// will bind to the event using DOM methods.
			if ( $.support.orientation && !$.event.special.orientationchange.disabled ) {
				return false;
			}

			// Get the current orientation to avoid initial double-triggering.
			last_orientation = get_orientation();

			// Because the orientationchange event doesn't exist, simulate the
			// event by testing window dimensions on resize.
			win.bind( "throttledresize", handler );
		},
		teardown: function() {
			// If the event is not supported natively, return false so that
			// jQuery will unbind the event using DOM methods.
			if ( $.support.orientation && !$.event.special.orientationchange.disabled ) {
				return false;
			}

			// Because the orientationchange event doesn't exist, unbind the
			// resize event handler.
			win.unbind( "throttledresize", handler );
		},
		add: function( handleObj ) {
			// Save a reference to the bound event handler.
			var old_handler = handleObj.handler;

			handleObj.handler = function( event ) {
				// Modify event object, adding the .orientation property.
				event.orientation = get_orientation();

				// Call the originally-bound event handler and return its result.
				return old_handler.apply( this, arguments );
			};
		}
	});

	// If the event is not supported natively, this handler will be bound to
	// the window resize event to simulate the orientationchange event.
	function handler() {
		// Get the current orientation.
		var orientation = get_orientation();

		if ( orientation !== last_orientation ) {
			// The orientation has changed, so trigger the orientationchange event.
			last_orientation = orientation;
			win.trigger( event_name );
		}
	}

	// Get the current page orientation. This method is exposed publicly, should it
	// be needed, as jQuery.event.special.orientationchange.orientation()
	$.event.special.orientationchange.orientation = get_orientation = function() {
		var isPortrait = true, elem = document.documentElement;

		// prefer window orientation to the calculation based on screensize as
		// the actual screen resize takes place before or after the orientation change event
		// has been fired depending on implementation (eg android 2.3 is before, iphone after).
		// More testing is required to determine if a more reliable method of determining the new screensize
		// is possible when orientationchange is fired. (eg, use media queries + element + opacity)
		if ( $.support.orientation ) {
			// if the window orientation registers as 0 or 180 degrees report
			// portrait, otherwise landscape
			isPortrait = portrait_map[ window.orientation ];
		} else {
			isPortrait = elem && elem.clientWidth / elem.clientHeight < 1.1;
		}

		return isPortrait ? "portrait" : "landscape";
	};

	$.fn[ event_name ] = function( fn ) {
		return fn ? this.bind( event_name, fn ) : this.trigger( event_name );
	};

	// jQuery < 1.8
	if ( $.attrFn ) {
		$.attrFn[ event_name ] = true;
	}

// FDB No need - Force window
}( jQuery, window ));



}));

define("syracuse-tablet/html/deps/jqm-orientation", function(){});


/*!
 * jQuery Cookie Plugin v1.4.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2006, 2014 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
// FDB
// 	if (typeof define === 'function' && define.amd) {
// AMD (Register as an anonymous module)
// 		define(['jquery'], factory);
// 	} else if (typeof exports === 'object') {
// Node/CommonJS
// 	module.exports = factory(require('jquery'));
// 	} else {
// Browser globals
		factory(jQuery);
// 	}
}(function ($) {

	var pluses = /\+/g;

	function encode(s) {
		return config.raw ? s : encodeURIComponent(s);
	}

	function decode(s) {
		return config.raw ? s : decodeURIComponent(s);
	}

	function stringifyCookieValue(value) {
		return encode(config.json ? JSON.stringify(value) : String(value));
	}

	function parseCookieValue(s) {
		if (s.indexOf('"') === 0) {
			// This is a quoted cookie as according to RFC2068, unescape...
			s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
		}

		try {
			// Replace server-side written pluses with spaces.
			// If we can't decode the cookie, ignore it, it's unusable.
			// If we can't parse the cookie, ignore it, it's unusable.
			s = decodeURIComponent(s.replace(pluses, ' '));
			return config.json ? JSON.parse(s) : s;
		} catch(e) {}
	}

	function read(s, converter) {
		var value = config.raw ? s : parseCookieValue(s);
		return $.isFunction(converter) ? converter(value) : value;
	}

	var config = $.cookie = function (key, value, options) {

		// Write

		if (arguments.length > 1 && !$.isFunction(value)) {
			options = $.extend({}, config.defaults, options);

			if (typeof options.expires === 'number') {
				var days = options.expires, t = options.expires = new Date();
				t.setMilliseconds(t.getMilliseconds() + days * 864e+5);
			}

			return (document.cookie = [
				encode(key), '=', stringifyCookieValue(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
				options.path    ? '; path=' + options.path : '',
				options.domain  ? '; domain=' + options.domain : '',
				options.secure  ? '; secure' : ''
			].join(''));
		}

		// Read

		var result = key ? undefined : {},
			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all. Also prevents odd result when
			// calling $.cookie().
			cookies = document.cookie ? document.cookie.split('; ') : [],
			i = 0,
			l = cookies.length;

		for (; i < l; i++) {
			var parts = cookies[i].split('='),
				name = decode(parts.shift()),
				cookie = parts.join('=');

			if (key === name) {
				// If second argument (value) is a function it's a converter...
				result = read(cookie, value);
				break;
			}

			// Prevent storing a cookie that we couldn't decode.
			if (!key && (cookie = read(cookie)) !== undefined) {
				result[name] = cookie;
			}
		}

		return result;
	};

	config.defaults = {};

	$.removeCookie = function (key, options) {
		// Must not alter options, thus extending a fresh object...
		$.cookie(key, '', $.extend({}, options, { expires: -1 }));
		return !$.cookie(key);
	};

}));
define("syracuse-tablet/html/deps/jquery.cookie", function(){});

define('syracuse-tablet/html/js/init/initThirdParty',['require','exports','module','syracuse-tablet/html/js/helpers/handlebarsHelpers','syracuse-tablet/html/deps/handlebars.min','syracuse-tablet/html/deps/jqm-orientation','syracuse-tablet/html/deps/jquery.cookie'],function (require, exports, module) {


var handlebarsHelpers = require('syracuse-tablet/html/js/helpers/handlebarsHelpers');

var handlebars = require('syracuse-tablet/html/deps/handlebars.min');
require('syracuse-tablet/html/deps/jqm-orientation');
require('syracuse-tablet/html/deps/jquery.cookie');

exports.init = function() {
	window.Handlebars = handlebars;
	return $.smResolve()
		.then(function() {
			handlebarsHelpers.registerHelpers(window.Handlebars);
		});
}
});

define('syracuse-tablet/html/js/init/initStyles',['require','exports','module','syracuse-tablet/html/js/helpers/environment'],function (require, exports, module) {

/*
 * Module to initialize CSS for used OS/Platform
 *
 */
var environment = require('syracuse-tablet/html/js/helpers/environment');

/**
 * Load css according to detected platform
 * Returns name of the selected platform
 */
exports.init = function() {

	return $.smResolve()
		.then(function() {
			var os = environment.getStyleOS();
			var styles;
			styles = os;

			var cssPlatform = "./css/gen/" + styles + (_isReleaseVersion() ? ".min" : "") + ".css";
			_loadCss(cssPlatform);
			var cssGeneral = "./css/default" + (_isReleaseVersion() ? ".min" : "") + ".css";
			_loadCss(cssGeneral);

			return styles;
		});
};

function _isReleaseVersion() {
	return document.location.href.indexOf("/index_debug.html") < 0 && document.location.href.indexOf("/index_release.html") < 0;
};

function _loadCss(file) {
	var ref = document.createElement("link");

	ref.setAttribute("rel", "stylesheet");
	ref.setAttribute("type", "text/css");
	ref.setAttribute("href", file);

	document.getElementsByTagName("head")[0].appendChild(ref);
}

function _isSurfaceTablet() {
	navigator.userAgent.toLowerCase().indexOf("tablet pc") > -1 && navigator.userAgent.toLowerCase().indexOf("windows") > -1;
}
});

define('syracuse-tablet/html/js/ui/uiSettings',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

var _cache = {};
var _lookAndFeel;

/**
 * typeObject 	hubLayout/footer/header/..
 * path			height/groupSpacing...
 * device		tablet/smartphone
 * orientation	portrait/landscape
 */
exports.init = function(os) {
	_cache = {};
	_lookAndFeel = os;

	_settings.gen = $.extend(true, {}, _settings.def, _settings[os]);
};

/**
 * 
 */
exports.getLookAndFeel = function() {
	return _lookAndFeel;
};

/**
 * 
 */
exports.getProp = function(path, device, orientation) {
	if (path == null || arguments.length === 0) return null;
	var res = jsutils.getPropByPath(_settings.gen, path, _cache);
	if (res == null) return null;
	if (device && res[device]) {
		res = res[device];
	}
	if (orientation && res[orientation]) {
		res = res[orientation];
	}
	if (typeof res === "function") {
		res = res.call(null, device, orientation);
		_cache[Array.isArray(path) ? path.join('.') : path] = res;
	}
	return res;
};

/**
 * SETTINGS
 */
var _settings = {
	ios: null,
	android: null,
	windows: null,
	def: {
		hubLayout: {
			groupSpacing: 55,
			landscapeMinHeigth: function() {
				return exports.getProp("hubGroup.landscapeBaseSize") * 4 + exports.getProp("hubGroup.landscapePadY") * 5 + 40;
			}
		},
		hubGroup: {
			// Default Base size
			// Allows 8 cells from left to right on Nexus 7 portrait mode, 
			// all other devices use a bigger, recalculated base sizes
			landscapeBaseSize: 66,
			landscapePadX: 8,
			landscapePadY: 8,
			portraitPadX: 8,
			portraitPadY: 8,
			portraitWideMinWidth: 570
		},
		footer: {
			height: {
				tablet: 50,
				smartphone: 62
			}
		},
		header: {
			height: 50,
		},
		breadcrumbs: {
			height: 25
		},
		chartDetailToolbar: {
			height: 40
		},
		colors: {
			CELLDEFCOLOR: "darkgrey",
			TILEDEFCOLOR: "darkgrey"
		}
	}
};
});

define('syracuse-tablet/html/js/init/initLocale',['require','exports','module','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var locale = require('syracuse-tablet/html/js/helpers/locale');

/**
 * No user logged in, so use default locale to english at startup
 */
exports.init = function() {
	var lang = "en-GB";
	return locale.setLocale(lang);
};
});

define('syracuse-tablet/html/js/common/helpers',['require','exports','module'],function (require, exports, module) {

/**
 * 
 */
exports.createDiag = function(payload, $severity, $message, $stackTrace) {
	if (!payload || !$.isPlainObject(payload)) {
		payload = {};
	}
	payload.$diagnoses = payload.$diagnoses || [];
	payload.$diagnoses.push({
		"$severity": ($severity || "error").toLowerCase(),
		"$message": $message,
		"$stackTrace": $stackTrace
	});
	return payload;
}

/**
 * jsonData: {
 *   $properties: {
 *     abc: {
 *       $url: "..."
 *     }
 *   }
 * }
 * path: $properties.abc.$url
 */
exports.getValueByPath = function(jsonData, path) {
	var segs = path.split(".");
	var data = jsonData;
	for (var i = 0; i < segs.length; i++) {
		data = data == null ? null : data[segs[i]];
	}
	return data;
}

var _office$Types = [
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document",
	"application/vnd.openxmlformats-officedocument.presentationml.presentation",
	"application/msword",
	"application/vnd.ms-excel",
	"application/syracuse-excel-worksheet",
	"application/syracuse-word-report",
	"application/syracuse-word-mailmerge",
	"application/syracuse-ppt-slide"
];

exports.isOfficeLink = function(info) {
	if (info && info.$type && _office$Types.indexOf(info.$type) >= 0) {
		return true;
	}
	return false;
};

exports.isPaginLink = function(name) {
	return name === "$first" || name === "$previous" || name === "$next" || name === "$last";
}
});

define('syracuse-tablet/html/js/sdata/protocolHelpers',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');

/**
 * 
 */
exports.getPageUrl = function(dataUrl, sdataResponse) {
	var repr = exports.getReprFromUrl(dataUrl);
	var baseUrl = exports.getHostPortFromUrl(dataUrl);
	var endpoint = exports.getEndpointFromUrl(dataUrl);

	if (repr === "mobileDashboard.$details" && sdataResponse) {
		repr = sdataResponse.dashboardName + ".$mobileDashboard";
		endpoint = "syracuse.collaboration.syracuse";
	}

	var url = baseUrl + "/sdata/syracuse/collaboration/syracuse/pages('" + endpoint + "." + repr + ",$page,,mobile')";
	return $.smResolve(url);
}

/**
 * Extract compute prototype url from url
 * http://localhost:8124/mobile2/x3/erp/GX3APP/$prototypes('TABCURM.$lookup')
 * return http://localhost:8124/mobile2/x3/erp/GX3APP$/prototypes('TABCURM.$lookup')
 */

exports.getPrototypeUrl = function(dataUrl) {
	var repr = exports.getReprFromUrl(dataUrl);
	var baseUrl = exports.getBaseUrlFromUrl(dataUrl);
	var url = baseUrl + "/$prototypes('" + repr + "')";
	return url;
}

/**
 * Returns rep and facet if any
 */
exports.getReprInfoFromUrl = function(url) {
	url = decodeURIComponent(url);
	var repr = /representation=(\S+?)\.(\$[a-zA-Z]+)/.exec(url);
	if (repr && repr.length > 2) {
		return {
			representation: repr[1],
			facet: repr[2]
		}
	}
	return null;
}

/**
 * Extract representation query parameter's value
 * {$baseUrl}/$workingCopies('2e3a0b34-994a-4909-8a50-e001a2deb0ad')?representation=AQMCRUDM.$edit"
 * return AQMCRUDM.$edit
 */
exports.getReprFromUrl = function(url) {
	var info = exports.getReprInfoFromUrl(url);
	if (info) {
		return info.representation + "." + info.facet;
	}
	return null;
}

/**
 * Extract endpoint from url
 * http://localhost:8124/mobile2/x3/erp/GX3APP/$prototypes('TABCURM.$lookup')
 * return x3.erp.GX3APP
 */
exports.getEndpointFromUrl = function(url) {
	if (!url.smStartsWith("http")) {
		var fullurl = "http://host";
		if (!url.smStartsWith("/")) {
			fullurl += "/";
		}
		url = fullurl + url;
	}
	var segs = url.split("/");
	var endpoint = segs.slice(4, 7).join(".");
	return endpoint;
}

/**
 * Extract baseurl from url
 * http://localhost:8124/mobile2/x3/erp/GX3APP/$prototypes('TABCURM.$lookup')
 * return http://localhost:8124/mobile2/x3/erp/GX3APP
 */
exports.getBaseUrlFromUrl = function(url) {
	var segs = url.split("/");
	var host = segs.slice(0, 7).join("/");
	return host;
}

/**
 * Extract key from url
 * http://localhost:8124/mobile2/x3/erp/GX3APP/$prototypes('TABCURM.$lookup')
 * "http://localhost:8124/mobile2/syracuse/collaboration/syracuse/mobileDashboards(dashboardName%20eq%20'STD_X3_ERP_EXPENSES_DASHBOARD')?representation=mobileDashboard.$details"
 * return TABCURM.$lookup or STD_X3_ERP_EXPENSES_DASHBOARD
 */
exports.getKeyFromUrl = function(url) {
	var keyOnly = /\('(.*?)'\)/.exec(url);
	if (keyOnly && keyOnly[1] != null) {
		return keyOnly[1];
	}

	var keyWithEq = /\((.*eq.*?)'(.*?)'\)/.exec(url);
	if (keyWithEq && keyWithEq[2] != null) {
		return keyWithEq[2];
	}
}

/**
 * Returns protocol, host and port the app is running on
 * return http://localhost:8124
 */
exports.getHostPort = function() {
	return exports.getHostPortFromUrl(window.location.href);
};

/**
 * Extract host, port and protocol from url
 * http://localhost:8124/mobile2/x3/erp/GX3APP/$prototypes('TABCURM.$lookup')
 * return http://localhost:8124
 */
exports.getHostPortFromUrl = function(url) {
	var segs = url.split("/");
	var host = segs.slice(0, 3).join("/");
	return host;
};

/**
 * Construct url on where to fetch a mobile application from
 */
exports.getMobileAppUrl = function(appName) {
	var php = exports.getHostPort();
	var appUrl = php + "/sdata/syracuse/collaboration/syracuse/mobileApplications(applicationName%20eq%20'" + appName + "')";
	return appUrl;
};

/**
 * For a given dashboard name, constructs the url from where to fetch the data
 */
exports.getLocalDashboardUrl = function(dashboardName) {
	return exports.getHostPort() + "/mobile2/$client/$local/$dataset/mobileDashboard('" + dashboardName + "')"
};
/**
 * 
 * Create the action url and payload to be send to the server
 * 
 */
exports.createActionData = function(dataset, $actionName, $action, workingCopy) {
	var actionData = {};
	if (workingCopy) {
		actionData.data = {};
		actionData.data.$actions = {};
		actionData.data.$actions[$actionName] = {
			$isRequested: true
		};
		actionData.$url = dataset.getUrl();
		// Same as desktop client
		actionData.data.$url = actionData.$url;
		actionData.data.$etag = dataset.getValue("$etag");
		actionData.data.$uuid = dataset.getValue("$uuid");
		actionData.$method = "PUT";
		if ($action.$parameters) {
			var act = actionData.data.$actions[$actionName];
			act.$parameters = {};
			Object.keys($action.$parameters).forEach(function(param) {
				act.$parameters[param] = dataset.resolveExpression($action.$parameters[param]);
			});
		}
	} else {
		var data = dataset.getData(workingCopy);
		actionData.data = data;
		var facet = dataset.getFacet();
		var $url = dataset.getUrl(true);

		// Save is a special case in stateless mode since it's managed by CRUD
		if ($actionName === "$save") {

			if (facet === "$create") {
				$url = _removeKeyFromUrl($url);
				actionData.$method = "POST"; // create
			} else {
				actionData.$method = "PUT"; // update
			}
			actionData.$url = $url;
		} else if ($actionName === "$abort") {
			return null;
		} else {

			$url = $url.replace("?", "/$services/" + $actionName + "?");
			$url = $url.replace("/sdata/", "/mobile2/");

			if (facet === "$create") {
				// Remove key if triggering action on $create facet since there is no record yet
				$url = _removeKeyFromUrl($url);
				actionData.$method = "PUT";
			} else {
				actionData.$method = "POST";
			}
			actionData.$url = $url;
		}
	}
	return actionData;
};

/**
 * Uses the server response to compute if an action was successful or not
 * 
 * Return:
 * {
 * 	   succeeded: true | false // Is the payload received a success or error response?
 *     $diagnose: { // Top level result message to show, can be null
 *         $severity: "error" | "success"
 *         $message: "..."
 *     }
 *     
 * }
 */
exports.computeActionResult = function($actionName, response) {
	var data = response.data;
	var result = {
		success: false
	};

	var actionDiags = (data && data.$actions && data.$actions[$actionName] && data.$actions[$actionName].$diagnoses) || [];
	if (actionDiags.some(
			function(diag) {
				if (diag.$severity === "success") {
					result.$diagnose = diag;
					return true;
				}
			})) { // If there is a single success diagnose on the action, we asume all is ok
		result.success = true;
		return result;
	}

	// If we end here, there is a top level message with an error
	if (actionDiags.length > 0) {
		result.$diagnose = actionDiags[0];
		result.success = false;
		return result;
	}

	// No information on header level, so scan fields for $diagnoses
	if (exports.hasFieldLevelErrors(data)) {
		result.$diagnose = {
			$severity: "error",
			$message: locale.text("action.error.field")
		};
		result.success = false;
		return result;
	}

	result.$diagnose = {
		$severity: "success",
		$message: locale.text("action.success")
	};
	result.success = true;
	return result;
}

/**
 * Scan the given data for any nodes with $diagnoses array containing an error
 * Will stop on the first match to be efficient
 * 
 */
exports.hasFieldLevelErrors = function(data) {
	function scanNode(node) {
		if (!node) {
			return false;
		}
		var errors;
		if (node.$diagnoses && Object.prototype.toString.call(node.$diagnoses) === "[object Array]") {
			errors = node.$diagnoses.some(function(diag) {
				return diag.$severity === "error";
			});
			if (errors) {
				return true;
			}
		}

		switch (Object.prototype.toString.call(node)) {
			case "[object Object]":
				errors = Object.keys(node).some(function(key) {
					return scanNode(node[key]);
				});
				if (errors) {
					return true;
				}
				break;

			case "[object Array]":
				errors = node.some(function(item) {
					return scanNode(item);
				});
				if (errors) {
					return true;
				}
				break;
		}

		return false;
	}
	return scanNode(data);
}

/*
 * 
 */
function _removeKeyFromUrl(url) {
	return url.replace(/(\/\w+)(\(\S+\))(\/\$services|\?)/, "$1$3");
}

exports.checkTransform = function($url, prototypeJson, datasetJson, pageJson) {
	var parsed = jsutils.parseURL($url);

	var articleJson = pageJson.$article;
	var viewsJson = pageJson.$views;
	var rolesJson = [];
	if (pageJson.$roles) {
		pageJson.$roles.forEach(function(role) {
			rolesJson.push({
				"$uuid": role.$uuid
			})
		});
	}
	var $mobileProtocol = (parsed.query && parsed.query.$mobileProtocol) === "workingcopy" ? "workingcopy" : "stateless";
	var $mobileEndpoint = parsed.query && parsed.query.$mobileEndpoint;
	var $mobileApplication = parsed.query && parsed.query.$mobileApplication;
	if (!datasetJson.$clientContext) {
		datasetJson.$clientContext = {
			$mobileProtocol: $mobileProtocol,
			$mobileEndpoint: $mobileEndpoint,
			$mobileApplication: $mobileApplication
		};
	}

	if (prototypeJson.$representation === "mobileApplication") {
		var $applicationName = datasetJson.applicationName;
		var $savedCtx = datasetJson.$clientContext;
		$savedCtx.$mobileProtocol = (datasetJson.onlineOnly === true ? "workingcopy" : "stateless");
		$savedCtx.$mobileApplication = datasetJson.applicationName;

		// A mobile applications json embeds all data required to render it's home dashboard or home gadget
		// so we just need to extract it here
		if (datasetJson.useHomeGadget !== true) {
			prototypeJson = prototypeJson.$mobileDashboardProto;
			datasetJson = datasetJson.$homeDashboard;
		} else if (datasetJson.$homeGadget) {
			prototypeJson = datasetJson.$homeGadgetFetched.prototype
			datasetJson = datasetJson.$homeGadgetFetched.dataset;
		}
		articleJson = datasetJson.$page.$article;
		viewsJson = datasetJson.$page.$views;
		if (datasetJson.$page.$roles) {
			datasetJson.$page.$roles.forEach(function(role) {
				rolesJson.push({
					"$uuid": role.$uuid
				})
			});
		}
		datasetJson.$clientContext = $savedCtx;
	}

	if (prototypeJson.$representation === "mobileDashboard") {

		var transformed = _transformDashboard(datasetJson, prototypeJson, articleJson);
		datasetJson = transformed.datasetJson;
		prototypeJson = transformed.prototypeJson;
		prototypeJson.$applicationName = $applicationName || null;
		articleJson = transformed.articleJson;
	}

	var result = {
		prototypeJson: prototypeJson,
		datasetJson: datasetJson,
		page: {
			$article: articleJson,
			$views: viewsJson,
			$roles: rolesJson
		}
	};

	return result;
}

/**
 * Transform the prototype and data of an mobile dashboard entity instance to something that 
 * passes through the standard widget creation process:
 * - The list of vignettes is transformed to a property per vignette because
 *   the article binds to the id (persistenId) of the vignette 
 */
function _transformDashboard(datasetJson, prototypeJson, articleJson) {
	var proto = $.extend(true, {}, prototypeJson);
	var data = $.extend(true, {}, datasetJson);
	// Dashboard entity properties potentially used (title/descr)
	proto.$properties = {};
	["dashboardName", "title", "description"].forEach(function(p) {
		proto.$properties[p] = prototypeJson.$properties[p]
	})

	proto.$title = datasetJson.title;

	data.$vignettes = data.vignettes; // make list meta information
	delete data.vignettes; // List will be replaced by concrete properties also contained in prototype
	delete data.$properties;

	var defaultArticle = {
		"$layoutType": "stack",
		"$items": []
	}
	for (var i = 0, j = datasetJson.vignettes.length; i < j; i++) {
		var vignette = datasetJson.vignettes[i];
		var vid = vignette.persistentId;

		var gadget = datasetJson.$mobileGadgets[vignette.gadget.$uuid];
		if (!gadget) {
			throw new Error("Gadget not found " + vignette.gadget.$uuid)
		}
		gadget.$clientContext = datasetJson.$clientContext;

		var prop = proto.$properties[vid] = {
			$item: gadget
		};
		prop.$item.$uuid = vignette.gadget.$uuid;
		if (vignette.displayStyle === "$full") {
			prop.$type = "application/x-vignette";
		} else {
			prop.$type = "application/x-vignette-link";
		}

		prop.$title = prop.$item.$title;

		data[vid] = vignette.gadget.$uuid;
		defaultArticle.$items.push({
			$bind: vid
		});
	}
	return {
		datasetJson: data,
		prototypeJson: proto,
		articleJson: articleJson || defaultArticle
	}
}

/**
 * Convert a working copy url to a stateless one
 * 
 * Urls containing $forceProtocol=true will not be changed
 * Like this it's possible to have a client side stateless app opening a working copy mode representation
 */
exports.adjustLinkProtocol = function($link, $mobileProtocol) {
	if ($mobileProtocol !== "workingcopy" && $link.$url && $link.$url.indexOf("$forceProtocol=true") < 0) {
		$link = $.extend(true, {}, $link);
		if ($link.$method !== "DELETE" && $link.$url.indexOf("$services") < 0) {
			$link.$method = "GET";
		}
		if ($link.$url.indexOf("/$workingCopies?") > -1) {
			// switch to stateless
			$link.$url = $link.$url.replace("/$workingCopies?", "?");
		}
	}

	return $link;
}

exports.addClientContext = function($url, $clientContext) {
	var result = $url;
	for (var prop in $clientContext) {
		if (result.indexOf(prop + "=") < 0) {
			if ($clientContext[prop]) {
				var delim = result.indexOf("?") > -1 ? "&" : "?";
				result = result + delim + prop + "=" + encodeURIComponent($clientContext[prop]);
			}
		}
	}
	return result;
};

exports.getPageName = function(url) {
	var urlLC = url.toLowerCase();
	if (urlLC.indexOf("/mobiledashboard") >= 0) {
		return exports.getKeyFromUrl(url);
	} else if (urlLC.indexOf("html://") === 0 || urlLC.indexOf("child://") === 0) {
		return url.split('/')[2];
	} else {
		var rep = exports.getReprFromUrl(url);
		return rep || "unknown";
	}
};

/**
 *  Check if the links is a link to a dashboard with parameters in V11 syntax and convert it to a valid one
 */
exports.transformOldDashboardUrl = function($link, dataset) {
	var url = $link.$url;
	if (!(url.indexOf("/$mobileDashboards?dashboard=") > -1)) {
		return $link;
	}
	try {
		var parsed = jsutils.parseURL(url);
		var dashboard = parsed.query.dashboard;
		var parameters = parsed.query.parameters;

		var params = parameters && parameters.split("&").map(function(param) {
			var tmp = param.split("=");
			var key = tmp[0];
			var val = tmp[1];
			val = dataset.resolveExpression(val);
			return key + "=" + val;
		}).join("&");
		var baseUrl = exports.getHostPortFromUrl(url);
		var url = baseUrl + "/sdata/syracuse/collaboration/syracuse/mobileDashboards(dashboardName eq '" + encodeURIComponent(dashboard) + "')?representation=mobileDashboard.$details";
		if (params) {
			url = url + "&parameters=" + encodeURIComponent(params);
		}
		$link.$url = url;
	} catch (e) {}
	return $link;
}

exports.getDashboardParams = function(url) {
	var obj = {};
	try {
		var parsed = jsutils.parseURL(url);
		var parameters = parsed.query.parameters;
		parameters && parameters.split("&").map(function(param) {
			var tmp = param.split("=");
			obj[tmp[0]] = {
				value: tmp[1]
			}
		});
		return obj;
	} catch (e) {}
	return null;
}
});

define('syracuse-tablet/html/js/common/ajax',['require','exports','module','syracuse-tablet/html/js/common/helpers','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/app/globals','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {
var helpers = require('syracuse-tablet/html/js/common/helpers');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/app/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');

/**
 * 
 * Resolves only if http code is something ok
 * Rejects in all other situations
 * options:{
 * 		timeout:			request timeout
 * 		contentType:		request content type (default is application/json;charset=utf-8)
 * 		acceptStatusCode	[] list of status codes considered as success (eg 404)
 * }
 * Returned object for reject and resolve:
 * {
 *   success: true or false (true if resolve, false if reject)
 *   offline: true: If rejected because of offline
 *   unauthenticated: true: If rejected because of not authorized
 *   $diagnoses: [] // Top level diagnoses (may be created on client side)
 *   data: { // Data coming from the server if any, may include additional diagnoses
 *     CODE: 10,
 *     TEXT: "abc",
 *     $diagnoses: []
 *   }
 * }
 */
exports.request = function(url, method, data, headers, options) {
	options = options || {};
	method = (method && method.toUpperCase()) || "GET";
	var timeout = options.timeout == null ? globals.getHttpTimeout(url) : options.timeout;
	var acceptStatusCode = options.acceptStatusCode || [];
	//  Quickly fake offline if needed	
	//	if (url.indexOf("representation")>-1&&true) {
	//		return $.smReject({
	//			offline: true
	//		});
	//	} 

	var lang = locale.getCurrentLocale() || "en-US";
	var allHeaders = {
		"Accept": "application/json;vnd.sage=syracuse",
	};
	if (lang) {
		allHeaders["Accept-Language"] = lang;
	}
	if (headers) {
		$.extend(allHeaders, headers);
	}
	var ajaxData = {
		headers: allHeaders,
		type: method,
		url: url,
		timeout: timeout
			//processData : false
	};
	// We need this option to deal with non-json data
	var parseJson = allHeaders.Accept.indexOf("application/json") >= 0;
	if (parseJson) {
		ajaxData.dataType = "json";
	}
	if (["PUT", "POST"].indexOf(method) >= 0 && data != null) {
		ajaxData.contentType = options.contentType || "application/json;charset=utf-8";
		ajaxData.data = data;

		if (ajaxData.contentType.indexOf("application/json") >= 0 && typeof data === "object") {
			try {
				ajaxData.data = JSON.stringify(data);
			} catch (e) {
				return $.smReject(helpers.createDiag(null, "error", e.Message));
			}
		};
	}

	var deferred = $.Deferred();
	$.ajax(ajaxData).always(function(jqXHR, textStatus, jqXHRSuccess) {
		var result;
		try {
			if (jqXHRSuccess && jqXHRSuccess.getAllResponseHeaders) {
				jqXHR = jqXHRSuccess;
			}
			var status = jqXHR.status != null ? jqXHR.status : textStatus == "success" ? 200 : 500;
			var regularSuccess = (status >= 200 && status < 300) || status === 304;
			result = {
				headers: {},
				status: status,
				success: regularSuccess || acceptStatusCode.indexOf(status) >= 0
			};

			if (result.success && parseJson) {
				result.data = jqXHR.responseJSON;
				if (result.data == null && regularSuccess) {
					// No parsing if acceptStatusCode
					var txt = (jqXHR.responseText || "").trim()
					if (txt.length > 0) {
						// Error parsing JSON - ajax doesn't return error status is parsig fails
						try {
							result.data = JSON.parse(txt);
						} catch (e) {
							deferred.reject(helpers.createDiag(null, "error", "Error parsing HTTP response", e.message + "\nUrl: " + url + "\n" + jsutils.cleanStack(e.stack)));
							return;
						}
					}
				} else if (result.data && result.data.mobileClientConfig) {
					// Set the config given by nodelocal.js
					globals.setMobileClientConfig(result.data.mobileClientConfig);
				}
			} else {
				// responseText if non-json data
				result.data = parseJson && jqXHR.responseJSON ? jqXHR.responseJSON : jqXHR.responseText;
			}
			var headerStr = jqXHR.getAllResponseHeaders();
			if (headerStr) {
				var _rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg;
				var match;
				while ((match = _rheaders.exec(headerStr))) {
					result.headers[match[1].toLowerCase()] = match[2];
				}
			}
			var diags = null;

			// Success (status OK or acceptStatusCode)
			if (result.success === true) {
				deferred.resolve(result);
			}
			// offline
			else if (status === 0) {
				result.offline = true;
				deferred.reject(helpers.createDiag(result, "error", locale.text("client.offline")));
			}
			// Not found
			else if (status === 404) {
				var message;
				if (result.data && result.data.$diagnoses && result.data.$diagnoses.length > 0) {
					message = result.data.$diagnoses[0].$message + " (Status 404)";
				}
				deferred.reject(helpers.createDiag(result, "error", message || locale.text("http404"), "url:" + url));
			}
			// not authorized
			else if (status === 401) {
				result.unauthenticated = true;
				deferred.reject(helpers.createDiag(result, "error", locale.text("user.not.authenticated")));
			}
			// Unknown error, check if diag is in payload, create one if no one is there
			else {
				if (result.data && result.data.$diagnoses) {
					diags = result;
					diags.$diagnoses = result.data.$diagnoses;
				} else {
					diags = helpers.createDiag(result, "error", "Error http " + status + " reading resource", "url:" + url + "\n" + jqXHR.responseText);
				}
				deferred.reject(diags);
			}
		} catch (e) {
			deferred.reject(helpers.createDiag(null, "error", e.message));
		}
	});

	return deferred.promise();
}
});

define('syracuse-tablet/html/js/helpers/utils',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');


// Used to force the use of the cache to speed up response time for tests
var _forceUseCache = function() {
	var url = jsutils.getCurrentUrl();
	return url.query && url.query.forceUseCache === "true";
};
// Used to force the dvlp mode with minimized version - For tests
var _forceDvlpMode = function() {
	var url = jsutils.getCurrentUrl();
	return url.query && url.query.forceDvlpMode === "true";
};

var _addClassMembers = function(klass, members) {
	if (!klass || !members || !klass.prototype) return;
	var proto = klass.prototype;
	for (var name in members || {}) {
		var member = members[name];
		if (typeof member.get === "function" || typeof member.set === "function") {
			Object.defineProperty(proto, name, member);
		} else {
			proto[name] = member;
		}
	}
};

var _defineClass = function(constructor, parent, members) {
	if (parent) constructor.prototype = Object.create(parent.prototype);
	constructor.prototype.constructor = constructor;
	_addClassMembers(constructor, members);
	// !!! The name of the class is the name of the constructor (function)
	// NOTE: THIS DOES NOT SLOW DOWN THE APPLICATION
	// Classes are defined one time at startup, there classes and baseclasses are then stored in an array only once
	// So isInstanceOf will be fast in the rare cases it is used! No need to add a specific flag on which classes to register
	jsutils.addInheritanceInfo(constructor, parent);
	return constructor;
};

/* Universal UUID - Not readable */
var _UUID = function() {
	return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,
		function(c) {
			var r = Math.random() * 16 | 0,
				v = c == 'x' ? r : (r & 0x3 | 0x8);
			return v.toString(16);
		});
};

var _getCurISODateTime = function(date) {
	var currentdate = date || new Date();
	var values = [
		currentdate.getFullYear(), 4, (currentdate.getMonth() + 1), 2,
		currentdate.getDate(), 2,
		currentdate.getHours(), 2,
		currentdate.getMinutes(), 2,
		currentdate.getSeconds(), 2
	];
	var datetime;
	for (var i = 0; i < values.length; i += 2) {
		var val = "" + values[i];
		while (val.length < values[i + 1]) {
			val = "0" + val;
		}
		if (!datetime) {
			datetime = val;
		} else {
			datetime += "-" + val;
		}
	}
	return datetime;
};
var _isoDateTimeToDate = function(stringDate) { // stringDate "2015-10-13-12-04-50"
	if (stringDate == null || typeof stringDate !== "string") {
		return new Date();
	}
	var val = stringDate.split("-");
	if (val.length !== 6) {
		return new Date();
	}
	return new Date(val[0], parseInt(val[1], 10) - 1, val[2], val[3], val[4], val[5]);
};

var _getTimeFromString = function(stringDate) { // stringDate "2015-10-13-12-04-50"
	if (stringDate) {
		var val = stringDate.split("-");
		return new Date(val[0], parseInt(val[1], 10) - 1, val[2], val[3], val[4], val[5]).getTime();
	} else {
		return new Date().getTime();
	}
};


/* Return a DOM compliant id */
var _domIdCpt = 0;
var _domId = function(id) {
	return id.replace(/([^\w-_])/g, '_');
};

/* Readable ui for html dom ids */
var _uidCpt = 0;
var _readableuid = function() {
	return _domId($.camelCase((arguments.length > 0 ? Array.prototype.join.call(arguments, '-') + '-' : "") + _uidCpt++));
};
var _unitTestId = function() {
	if (arguments.length === 0) return null;
	return Array.prototype.join.call(arguments, '-');
};
/* Parse url QS */
var _qsParser = /([^&=;]*)=?([^&;]*)/g;
var _parseQueryString = function(qs) {
	qs = qs || window.location.search;
	var res = {};
	var qs = decodeURIComponent(qs);
	var ii = qs.indexOf('?');
	if (ii >= 0) {
		qs = qs.substring(ii + 1);
	}
	qs.replace(_qsParser, function($0, $1, $2) {
		if ($1 && $1.length > 0) {
			res[$1] = decodeURIComponent($2);
		}
	});
	return res;
};
/**
 *  Resolves expression according to current dataset and prototype
 *  	expression: Syrause SData expression
 *  	dataset: optionnal - DaoSdata object (with value method to chain with a parent) or a simple JSON object
 *  			 if dataset=null prototype must be != null
 *  	prototype: optionnal - PrototypeObject
 * 		searchInParent: true to find variable in parent if not found in dataset #5793
 **/
var _exprRegExp = /\{(.*?)\}/g;
var _execExpression = function(expression, dataset, prototype, searchInParent, level, keepPlaceholder) {
	level = level || 0;
	expression = (expression || "") + "";
	//	TODO  - to remove - FDB - Expresion without brackets must return itself and must not be resolved
	//	if (level === 0 && expression.indexOf("{") < 0 && dataset) {
	//		console.log("NO BRACKET EXPRESSION " + expression);
	//		var value = dataset.getValue ? dataset.getValue(expression) : dataset[expression];
	//		return value == null ? "" : value;
	//	}
	var prevProp = null;
	var res = expression.replace(_exprRegExp,
		function(match, prop) {
			var empty = keepPlaceholder ? match : "";
			// Search in data first - "{VACBPR}~{LEG}"
			var val = dataset == null ? null : dataset.getValue ? dataset.getValue(prop, undefined, searchInParent) : dataset[prop];
			if (val != null) return val;
			if (!prototype) return empty;
			if (prop.smStartsWith('@')) {
				//Case @1234
				return prototype.localization(prop) || "";
			}
			val = prototype.data(prop, dataset, null, true);
			if (val != null && val.indexOf("{") >= 0 && level < 4) {
				// Search in prototype - ex "{@7898}", "{$baseUrl}/$prototype('{$representation}.$thumb')"
				return _execExpression(val, dataset, prototype, searchInParent, level + 1, keepPlaceholder);
			}
			return val == null ? empty : val;
		});
	return res || "";
};
/*
	Extract code from ref field prototype expression {x}
*/
var _extractCode = function($expression) {
	$expression = $expression + "";
	if ($expression.indexOf("{") >= 0) {
		return $expression.slice(1, $expression.length - 1);
	}
	return $expression;
};
var _isExpression = function(value) {
	if ($.type(value) !== "string") return false;
	return /^{@.*}$/.test(value);

};
var _sanitizeArticle = function(article) {
	if (!article) return article;
	var value = $.extend(true, {}, article);

	function _walk(value) {
		if (value == null || typeof value !== "object") return;
		// Object.keys(value).some works for both arrays and objects
		Object.keys(value).forEach(function(key) {
			var v = value[key];
			if ((key === "$title" || key === "$titleOrig") && v != "" && !_isExpression(v)) {
				// Remove titles of old version of authoring that are not localized (if any) - The title of the proto will be displayed instead
				delete value[key];
			} else {
				_walk(v);
			}
		});
	};
	_walk(value);
	return value;
};
/**
 * For authoring - Don't stop shiftKey/altKey used by scrolling
 */
var _stopClickEvent = function(e) {
	return e.shiftKey !== true && e.altKey !== true;
};
var refTime = new Date().getTime();
var _timeLineCfg = {
	"ajax": false,
	"page": false,
	"pageLoader": false,
	"cacheUpdate": false
};

var _TimeLine = _defineClass(function(type, id) {
	this.type = type;
	this.id = id;
}, null, {
	log: function(step) {
		var time = new Date().getTime();
		var delta = this._prevTime == null ? 0 : time - this._prevTime;
		this._prevTime = time;
		console.log(time - refTime, this.type, this.id, step, "elasped=" + (time - this._start), "delta=" + delta);
	},
	start: function(step) {
		this._start = new Date().getTime();
		this.log(step ? "start " + step : "start");
	},
	step: function(step) {
		this.log(step);
	},
	stop: function(step) {
		this.log(step ? "stop " + step : "stop");
	},
	reset: function() {
		this._prevTime = null;
		this._start = null;
		return this;
	}
});
/**
 * type			page, sendHttp
 * id			url, name...
 * forceEnable	true 		Force enable
 * 				false 		Force disabled
 * 				undefined 	check _timeLineCfg[type]
 */
var _getTimeLine = function(type, id, forceEnable) {
	try {
		if (forceEnable === false) return;
		if (forceEnable !== true && _timeLineCfg[type] !== true) return null;
		if (type.indexOf("page") === -1 && id != null) {
			id = id + "";
			var p = id.indexOf("representation=");
			if (p >= 0) {
				id = id.substr(p + 15);
			} else {
				var p = id.indexOf("x3/erp/");
				if (p >= 0) {
					id = id.substr(p + 7);
				} else {
					var p = id.indexOf("collaboration/syracuse/");
					id = id.substr(p + 23);
				}
			}
			id = decodeURIComponent(id);
		}
		return new _TimeLine(type, id);
	} catch (e) {
		console.log(e);
	}
};

var _hasProp = function(obj, key) {
	return Object.prototype.hasOwnProperty.call(obj, key);
};

var _areEqual = function(obj1, obj2, strict) {
	if (strict ? obj1 === obj2 : obj1 == obj2)
		return true;
	if (obj1 == null || obj2 == null)
		return false;
	if (Array.isArray(obj1) && Array.isArray(obj2)) {
		if (obj1.length != obj2.length)
			return false;
		for (var i = 0; i < obj1.length; i++)
			if (!_areEqual(obj1[i], obj2[i]))
				return false;
		return true;
	}

	if (typeof obj1 != "object" || typeof obj2 != "object") return false;
	var combined = $.extend({}, obj1);
	$.extend(combined, obj2);
	for (var i in combined) {
		if (_hasProp(combined, i)) {
			var val1 = obj1[i];
			var val2 = obj2[i];
			if (!_areEqual(val1, val2))
				return false;
		}
	}
	return true;
};

var _typeNamesByMime = {};
var _regExpMimeToType = /-|\//g;
exports.getTypeName = function(mime) {
	var type = _typeNamesByMime[mime];
	if (!type) {
		// used to generate readable ids - type expected "application/x-name" or "text/plain"
		var a = mime.split(_regExpMimeToType);
		type = _typeNamesByMime[mime] = a[a.length - 1];
	}
	return type;
};

exports._checksum = function(text) {
	var a = 1,
		b = 0;
	for (var index = 0; index < text.length; ++index) {
		a = (a + text.charCodeAt(index)) % 65521;
		b = (b + a) % 65521;
	}
	return (b << 16) | a;
};

exports.arrayInt = function(min, max) {
	return Array(max - min + 2).join().split(',').map(function(e, i) {
		return min + i;
	});
};
exports.isPromise = function(o) {
	if (o == null) return false;
	return typeof o === "object" && typeof o.then === "function" && typeof o.fail === "function";
};
exports.toPromise = function(o) {
	if (exports.isPromise(o)) return o;
	return $.smResolve(o);
};
exports.areEqual = _areEqual;
exports.stopClickEvent = _stopClickEvent;
exports.extractCode = _extractCode;
exports.isExpression = _isExpression;
exports.sanitizeArticle = _sanitizeArticle;
exports.UUID = _UUID;
exports.defineClass = _defineClass;
exports.addClassMembers = _addClassMembers;

exports.readableuid = _readableuid;
exports.domId = _domId;
exports.unitTestId = _unitTestId;
exports.parseQueryString = _parseQueryString;
exports.getCurISODateTime = _getCurISODateTime;
exports.isoDateTimeToDate = _isoDateTimeToDate;
exports.getTimeFromString = _getTimeFromString;
exports.parseExpression = function(expression, dataset, prototype, searchInParent, keepPlaceholder) {
	return _execExpression(expression, dataset, prototype, searchInParent, 0, keepPlaceholder);
};

exports.isLocalizationExits = function($localization, uiId) {
	if (!$localization || !uiId) return false;
	var uuid = uiId.match(/\{\@(\S+)\}/),
		count = 0;
	uuid = (uuid && uuid[1]) || uiId;
	Object.keys($localization).forEach(function(key) {
		if ($localization[key][uuid] && $localization[key][uuid] !== "") {
			count++;
		}
	});
	return count > 1;
};
exports.removeLocalization = function($localization, uuid) {
	if (!$localization || !uuid) return false;
	Object.keys($localization).forEach(function(key) {
		if ($localization[key][uuid]) delete $localization[key][uuid]
	})
	return $localization;
};
exports.setLocalization = function($localization, uuid, text) {
		$localization[locale.getCurrentLocale()] = $localization[locale.getCurrentLocale()] || {}
		$localization[locale.getCurrentLocale()][uuid] = text;
		return $localization;
	}
	// Retunr fr, en .. not en-US, fr-FR
exports.getNavigatorLanguage = function(def) {
	return navigator.language || navigator.userLanguage || def;
};
exports.sameLanguage = function(l1, l2) {
	if (!l1 || !l2) return false;
	l1 = l1.toLowerCase();
	l2 = l2.toLowerCase();
	if (l2 === l1) { // en-us === en-us
		return true;
	} else { // en-us === en
		l1 = l1.split('-');
		l2 = l2.split('-');
		return l1[0] === l2[0];
	}
};
exports.splitSdataKey = function(key) {
	return key && key.split("~");
};
var _splitExp = /({)|(})/g;
exports.sdataExtractKeyFields = function(key) {
	if (key == null || key.length === 0 || !key.replace) return;
	return exports.splitSdataKey(key.replace(_splitExp, ""));
};
exports.getPropByPath = jsutils.getPropByPath;

// Used to analyse performances
exports.getTimeLine = _getTimeLine;
exports.forceUseCache = _forceUseCache;
exports.forceDvlpMode = _forceDvlpMode;
// Check if url has a protocol/host
// if none adds the current url protocol/host 
exports.checkUrlHostAndPort = function(url) {
	if (!url) return url;
	var URL = jsutils.parseURL(url);
	if (!URL.protocol || !URL.host) {
		URL.protocol = jsutils.getCurrentUrl().protocol;
		URL.host = jsutils.getCurrentUrl().host;
		URL.port = jsutils.getCurrentUrl().port;
		return jsutils.urlToString(URL)
	} else {
		return url;
	}
}
});

define('syracuse-tablet/html/js/storage/storageInterface',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {

/*
 * Default interface for mobile application metadata, favorites, drafts and templates, ...
 */


var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

var _statusCodes = {
	OK: 1,
	NOT_FOUND: 2,
	ERROR: 3
};

/*
 * All storage interfaces must inherit the "Not implemented" methods of this super class
 */
exports.Klass = utils.defineClass(
	function(infoString, databaseVersion) {
		this.infoString = infoString;
		this.databaseName = exports.databaseName;
		this.databaseVersion = databaseVersion;
		this.useTestDatabase = false;
		this.db = null;
	},
	null, {
		getInfo: function() {
			return this.infoString;
		},

		/**
		 * Init storage
		 *
		 * Return:
		 * Resolve:
		 * {
		 *   $status: StatusCodes.OK,
		 *   $data: { }
		 * }
		 *
		 * Reject:
		 * {
		 *   $status: StatusCodes.ERROR,
		 *   $message: "Error message",
		 *   $exception: { ... }
		 * }
		 *
		 */
		init: function() {
			throw new Error("Not implemented!");
		},

		/**
		 * Query a list of items
		 *
		 * Parameters:
		 * opts: {
		 *   $context: {
		 *     $user,
		 *     $role,
		 *     $lang
		 *   },
		 *   $endpoint,
		 *   $collection: "users.$query",
		 *   $orderBy: "name, email" // optional
		 * }
		 *
		 * Return:
		 * Resolve:
		 * {
		 *   $status: StatusCodes.OK,
		 *   $data: [record1, record2, ...]
		 * }
		 *
		 * Reject:
		 * {
		 *   $status: StatusCodes.ERROR,
		 *   $message: "Error message",
		 *   $exception: { ... }
		 * }
		 *
		 */
		query: function(opts) {
			throw new Error("Not implemented!");
		},

		/**
		 * Does a create or update if record is there already
		 *
		 * Parameters:
		 * opts: {
		 *   $context: {
		 *     $user,
		 *     $role,
		 *     $lang
		 *   },
		     $endpoint,
		 *   $collection: "users.$query",
		 *   $data: {},
		 *   $key: "abc~def"
		 * }
		 *
		 * Return:
		 * Resolve:
		 * {
		 *   $status: StatusCodes.OK,
		 *   $data: { }
		 * }
		 *
		 * Reject:
		 * {
		 *   $status: StatusCodes.ERROR,
		 *   $message: "Error message",
		 *   $exception: { ... }
		 * }
		 *
		 */
		put: function(opts) {
			throw new Error("Not implemented!");
		},

		/**
		 * Reads exactly one record by it's key
		 *
		 * Parameters:
		 * opts: {
		 *   $context: {
		 *     $user,
		 *     $role,
		 *     $lang
		 *   },
		     $endpoint,
		 *   $collection: "users.$query",
		 *   $key: "abc~def"
		 * }
		 *
		 * Return:
		 * Resolve:
		 * {
		 *   $status: StatusCodes.OK or StatusCodes.NOT_FOUND
		 *   $data: { }
		 * }
		 *
		 * Reject:
		 * {
		 *   $status: StatusCodes.ERROR,
		 *   $message: "Error message",
		 *   $exception: { ... }
		 * }
		 *
		 */
		read: function(opts) {
			throw new Error("Not implemented!");
		},

		/**
		 * Delete exactly one record by it's key
		 *
		 * Parameters:
		 * opts: {
		 *   $context: {
		 *     $user,
		 *     $role,
		 *     $lang
		 *   },
		     $endpoint,
		 *   $collection: "users.$query",
		 *   $key: "abc~def"
		 * }
		 *
		 * Return:
		 * Resolve:
		 * {
		 *   $status: StatusCodes.OK or StatusCodes.NOT_FOUND
		 * }
		 *
		 * Reject:
		 * {
		 *   $status: StatusCodes.ERROR,
		 *   $message: "Error message",
		 *   $exception: { ... }
		 * }
		 *
		 */
		remove: function(opts) {
			throw new Error("Not implemented!");
		},

		/**
		 * Delete exactly one record by it's key
		 *
		 * Parameters:
		 * opts: {
		 *   $context: {
		 *     $user,
		 *     $role,
		 *     $lang
		 *   },
		     $endpoint,
		 *   $collection: "users.$query", // string or regex
		 * }
		 *
		 * Return:
		 * Resolve:
		 * {
		 *   $status: StatusCodes.OK
		 * }
		 *
		 * Reject:
		 * {
		 *   $status: StatusCodes.ERROR,
		 *   $message: "Error message",
		 *   $exception: { ... }
		 * }
		 *
		 */
		clearCollection: function() {
			throw new Error("Not implemented!");
		},
		computeCollectionSize: function() {
			throw new Error("Not implemented!");
		},
		clearDatabaseSupported: function() {
			return false;
		},
		/**
		 * Drafts and working copies
		 * op: Operation CRUD and Query
		 */
		draftOperation: function(op) {},
		/**
		 * Templates
		 * op: Operation CRUD and Query
		 */
		templateOperation: function(op) {}
	}
);

exports.resultToString = function(result) {
	if (!result) return "";
	if (jsutils.isError(result)) {
		return JSON.stringify(jsutils.convertToDiagnoses(result), null, 2);
	}
	var res = [];
	if (result.$status) res.push("status: " + result.$status);
	if (result.$message) res.push("Message: " + result.$message);
	if (result.$exception && result.$exception.message) res.push("Exception: " + result.$exception.message);
	if (result.$exception && result.$exception.stack) res.push("Stack: " + result.$exception.stack);
	return res.join('\n');
}

exports.buildResult = function(status, data, message, exception, metaData) {
	var res = {
		$status: status
	};
	if (data) res.$data = data;
	if (metaData) res.$metaData = metaData;
	if (message) res.$message = message;
	if (exception) res.$exception = exception;
	if (status === _statusCodes.ERROR) {
		res.$diagnoses = res.$diagnoses || [];
		res.$diagnoses.push({
			$severity: "error",
			$message: message
		});
	}
	return res;
}

exports.buildErrResult = function(message, exception) {
	return exports.buildResult(_statusCodes.ERROR, null, message, exception);
}
exports.StatusCodes = _statusCodes;

// Same db name for all kind of database - !!must be different from mobile application name
exports.databaseName = "sage-tablet-db";
});

define('syracuse-tablet/html/js/storage/storageWebSQLBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {

/*
 * WebSQL storage interface (Chrome, Safari)
 */
var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var Base = storageInterface.Klass;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("webSQL", false);

//Increase this number to upgrade database to schema described in _objectStores
var _databaseVersion = 21;
var _databaseSize = 2 * 1024 * 1024;

exports.Klass = utils.defineClass(
	function() {
		Base.call(this, "WebSQL storage interface", _databaseVersion);
		this.databaseSize = _databaseSize;
	},
	Base, {
		init: function() {
			var deferred = $.Deferred();
			var self = this;
			$.smResolve().then(function() {
				self.useTestDatabase = jsutils.isTestEnvironment();
				self.databaseName = storageInterface.databaseName + (self.useTestDatabase ? "-test" : "");
				if (self.useTestDatabase === false && self.db) {
					return $.smResolve(storageInterface.StatusCodes.OK);
				} else {
					return self._openDB();
				}
			}).then(function(status) {
				deferred.resolve(status);
			}).fail(function(e) {
				log && log("Open database exception", JSON.stringify(storageInterface.buildErrResult(e), null, 2));
				var msg = locale.text("db.err.init");
				var diags;
				if (jsutils.isError(e) || jsutils.isDOMException(e)) {
					var diags = jsutils.convertToDiagnoses(e);
					diags.$diagnoses[0].$message = msg;
				} else {
					diags = storageInterface.buildErrResult(msg, e);
				}
				deferred.reject(diags);
			});
			return deferred.promise();
		},
		_openDB: function() {
			var self = this;
			return $.smResolve().then(function() {
				var request;
				log && log("Open database, request version: " + self.databaseVersion);
				self.db = openDatabase(self.databaseName, 7, 'Database', self.databaseSize);
				return self._readCurrentVersion().then(function(version) {
					log && log("Current version: " + version);
					// In test framework create DB every time
					if (version === self.databaseVersion && self.useTestDatabase !== true) {
						return storageInterface.StatusCodes.OK;
					} else {
						return self._createTables().then(function(status) {
							return self._writeCurrentVersion();
						});
					}
				});
			});
		},
		_writeCurrentVersion: function() {
			var self = this;
			var deferred = $.Deferred();
			self._executeSql('DELETE FROM version', null).then(function(result) {
				return self._executeSql('INSERT INTO version (version) values (?)', [_databaseVersion]).then(function(status) {
					deferred.resolve(status);
				});
			}).fail(function(e) {
				log && log("_writeCurrentVersion exception", JSON.stringify(storageInterface.buildErrResult(e), null, 2));
				deferred.reject(storageInterface.buildErrResult("writeCurrentVersion", e));
			});
			return deferred.promise();
		},
		/**
		 * Returns the tables to create
		 */
		getTables: function() {
			return {};
		},
		_executeSql: function(sql, params) {
			var deferred = $.Deferred();
			var self = this;
			try {
				self.db.transaction(function(tx) {
					try {
						log && log("SQL: " + sql);
						log && log(params);
						tx.executeSql(sql, params, function(tx, result) {
							deferred.resolve(result);
						}, function(tx, error) {
							deferred.reject(storageInterface.buildErrResult("DB error initializing database: " + self.sqlErrorToMessage(error, sql, params)));
						});
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error running SQL statement", e));
					}
				}, function(error) {
					deferred.reject(storageInterface.buildErrResult("DB transaction error: " + self.sqlErrorToMessage(error, sql, params) + ". Try to reload the page"));
				});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error running SQL statement", e));
			}
			return deferred.promise();
		},
		_readCurrentVersion: function() {
			var deferred = $.Deferred();
			var self = this;
			self._executeSql('SELECT version FROM version', null).then(function(result) {
				try {
					var len = result.rows.length;
					if (len === 1) {
						var version = result.rows.item(0).version;
						log && log("Read version: " + version);
						deferred.resolve(+version);
					}
					deferred.resolve(-1);
				} catch (e) {
					deferred.reject(storageInterface.buildErrResult("error reading database version", e));
				}
			}).fail(function(e1) {
				// Assume table does not exist, create it
				log && log("Creating version table");
				self._executeSql('CREATE TABLE version (version TEXT)').then(function(status) {
					deferred.resolve(-1);
				}).fail(function(e2) {
					log && log("Error creating version table", JSON.stringify(storageInterface.buildErrResult(e2), null, 2));
					deferred.reject(storageInterface.buildErrResult("error reading database version", e1));
				});
			});
			return deferred.promise();
		},
		_createTables: function() {
			var deferred = $.Deferred();
			var self = this;
			var p = [];
			var errors = [];
			var nbExec = 0;
			var tables = this.getTables();
			// FDB - Redid this way because the old implementation with $.when() didn't bubble up errors rejected to the main process
			for (var name in tables) {
				nbExec += tables[name].length;
			}
			for (var name in tables) {
				tables[name].forEach(function(descr) {
					self._executeSql(descr).then(function() {
						nbExec--;
						if (nbExec === 0) {
							if (errors.length > 0) {
								deferred.reject(storageInterface.buildErrResult("Error creating database tables", errors.join('\n')));
							} else {
								deferred.resolve(storageInterface.StatusCodes.OK);
							}
						}
					}, function(status) {
						nbExec--;
						errors.push(status.$message);
						if (nbExec === 0) {
							deferred.reject(storageInterface.buildErrResult("Error creating database tables", errors.join('\n')));
						}
					});
				});
			};
			return deferred.promise();
		},
		sqlErrorToMessage: function(error, sql, params) {
			if (log) {
				var e = {};
				for (var p in error) {
					if (typeof error[p] === "function") continue;
					if (error[p] == "object" && (!Array.isArray(error[p]) || !$.isPlainObject(error[p]))) continue;
					e[p] = error[p];
				}
				log && log("ERROR REQUEST:", sql);
				log && log("ERROR PARAMS:", params);
				log && log(JSON.stringify(e, null, 2));
			}
			return "CODE: " + error.code + " MESSAGE: " + error.message;
		},
		// No need because we can clear the cache manually - #7942
		clearDatabaseSupported: function() {
			return false;
		}
	}
);
});

define('syracuse-tablet/html/js/storage/storageWebSQLSData',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/storage/storageWebSQLBase','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {

/**
 * WebSQL storage interface - SDATA (META + DATA) MANAGEMENT
 * Members added to of _storageInterfaceWebSQLClass
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var Base = require('syracuse-tablet/html/js/storage/storageWebSQLBase').Klass;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("webSQL", false);

var _tables = {
	"sdata_meta": [
		// meta data table for handling etags, ttl, size, ..
		"DROP TABLE IF EXISTS sdata_meta",
		"CREATE TABLE sdata_meta ( " +
		"key text, " +
		"collection text, " +
		"endpoint text, " +
		"context text, " +
		"id text, " +
		"etag text, " +
		"last_read text, " +
		"last_updated text" +
		")",
		"DROP INDEX IF EXISTS sdata_meta_pk",
		"CREATE UNIQUE INDEX sdata_meta_pk ON sdata_meta (key, collection, endpoint, context)",
		"DROP INDEX IF EXISTS sdata_meta_id",
		"CREATE UNIQUE INDEX sdata_meta_id ON sdata_meta (id)"
	],
	"sdata_objects": [
		// data table
		"DROP TABLE IF EXISTS sdata_objects",
		"CREATE TABLE sdata_objects ( " +
		"id text, " +
		"data text " +
		")",
		"DROP INDEX IF EXISTS sdata_objects_pk",
		"CREATE UNIQUE INDEX sdata_objects_pk ON sdata_objects (id)"
	]
};
exports.Klass = utils.defineClass(
	function() {
		Base.call(this);
	}, Base, {
		getTables: function() {
			var res = Base.prototype.getTables.call(this);
			$.extend(res, _tables);
			return res;
		},
		put: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("PUT: ", JSON.stringify(opts));

				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [opts.$key, opts.$collection, opts.$endpoint, context];

				var insertData = function(metaData) {
					self._executeSql("INSERT INTO sdata_objects (data, id) values (?, ?)", [JSON.stringify(opts.$data), metaData.$id])
						.then(function() {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
						}).fail(function(status) {
							deferred.reject(status);
						});
				};

				var updateData = function(metaData) {
					self._executeSql("UPDATE sdata_objects set data = ? where id = ?", [JSON.stringify(opts.$data), metaData.$id])
						.then(function(result) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
						}).fail(function(status) {
							deferred.reject(status);
						});
				};

				// handle meta data
				self._readMetaData(context, params)
					.then(function(metaData) {
						if (opts.$data && opts.$data.$etag && metaData && metaData.$etag === opts.$data && opts.$data.$etag) {
							// record has not changed
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
						} else if (metaData) {
							// update
							metaData.$etag = opts.$data.$etag;
							metaData.$lastUpdated = utils.getCurISODateTime();
							self._writeMetaData(metaData)
								.then(function() {
									updateData(metaData);
								}).fail(function(status) {
									deferred.reject(status);
								});
						} else {
							// insert
							metaData = {
								$key: opts.$key,
								$collection: opts.$collection,
								$endpoint: opts.$endpoint,
								$context: opts.$context,
								$etag: opts.$data.$etag,
								$lastUpdated: utils.getCurISODateTime()
							};
							self._writeMetaData(metaData)
								.then(function(metaData) {
									insertData(metaData);
								}).fail(function(status) {
									deferred.reject(status);
								});
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error writing to database", e));
			} finally {
				return deferred.promise();
			}
		},

		read: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("READ: ", JSON.stringify(opts));

				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [opts.$key, opts.$collection, opts.$endpoint, context];

				self._readMetaData(context, params)
					.then(function(metaData) {
						if (!metaData) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						} else {
							self._executeSql("SELECT * FROM sdata_objects where id = ?", [metaData.$id])
								.then(function(result) {
									try {
										if (result.rows.length <= 0) {
											deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
										} else {
											deferred.resolve(storageInterface.buildResult(
												storageInterface.StatusCodes.OK,
												JSON.parse(result.rows.item(0).data),
												null,
												null, {
													$lastRead: metaData.$lastRead,
													$lastUpdated: metaData.$lastUpdated
												}));
										}
									} catch (e) {
										deferred.reject(storageInterface.buildErrResult("error reading from database", e));
									}
								}).fail(function(status) {
									deferred.reject(status);
								});
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		query: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("QUERY: ", JSON.stringify(opts));

				if (!opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [opts.$collection, opts.$endpoint, context];

				self._executeSql("SELECT o.*, m.last_read, m.last_updated FROM sdata_objects o INNER JOIN sdata_meta m ON (o.id = m.id and m.collection = ? and m.endpoint = ? and m.context = ?)", params)
					.then(function(result) {
						var ret = [];
						var meta = [];
						try {
							for (var i = 0; i < result.rows.length; i++) {
								var item = result.rows.item(i);
								ret.push(JSON.parse(item.data));
								meta.push({
									$lastRead: item.last_read,
									$lastUpdated: item.last_updated
								});
							}
						} catch (e) {
							deferred.reject(storageInterface.buildErrResult("error reading from database", e));
							return;
						}
						// Exception are handled by our jq deferred hack
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, ret, null, null, meta));
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		remove: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("REMOVE: ", JSON.stringify(opts));

				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [opts.$key, opts.$collection, opts.$endpoint, context];
				self._removeMetaData(context, params)
					.then(function(metaData) {
						if (!metaData) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						} else {
							self._executeSql("DELETE FROM sdata_objects where id = ?", [metaData.$id])
								.then(function() {
									deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
								}).fail(function(status) {
									deferred.reject(status);
								});
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error writing to database", e));
			} finally {
				return deferred.promise();
			}
		},
		clearCollection: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("CLEAR: ", JSON.stringify(opts));

				if (!opts.$collection || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [context];

				//self._executeSql("SELECT * FROM sdata_meta where context = ?", params)
				self._executeSql("SELECT * FROM sdata_meta")
					.then(function(result) {
						var ret = [];
						try {
							for (var i = 0; i < result.rows.length; i++) {
								var item = result.rows.item(i);
								if (opts.$collection.test(item.collection)) {
									if (!opts.$not_read_since || item.last_read < opts.$not_read_since) {
										ret.push({
											$context: opts.$context,
											$collection: item.collection,
											$endpoint: item.endpoint,
											$key: item.key
										});
									}
								}
							}
							$.smForEachPromise(ret, function(item) {
								return self.remove(item);
							}).then(function() {
								deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
							}).fail(function(e) {
								deferred.reject(e);
							});
						} catch (e) {
							deferred.reject(storageInterface.buildErrResult("error reading from database", e));
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		computeCollectionSize: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("CHECK SIZE: ", JSON.stringify(opts));

				if (!opts.$collection || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [context];
				//self._executeSql("SELECT * FROM sdata_meta where context = ?", params)
				self._executeSql("SELECT m.collection, m.endpoint, m.key, m.last_read, d.data FROM sdata_meta m INNER JOIN sdata_objects d ON (d.id = m.id) where m.context = ? ", params)
					.then(function(result) {
						var returnData = {
							numRecords: 0,
							sizeRecords: 0
						};
						var ret = [];
						try {
							for (var i = 0; i < result.rows.length; i++) {
								var item = result.rows.item(i);
								if (opts.$collection.test(item.collection)) {
									if (!opts.$not_read_since || item.last_read < opts.$not_read_since) {
										returnData.numRecords++;
										returnData.sizeRecords += item.data.length;
									}
								}
							}
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, returnData));
						} catch (e) {
							deferred.reject(storageInterface.buildErrResult("error reading from database", e));
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		_readMetaData: function(context, params, noUpdate) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				self._executeSql("SELECT * FROM sdata_meta where key = ? and collection = ? and endpoint = ? and context = ?", params)
					.then(function(result) {
						try {
							if (result.rows.length <= 0) {
								deferred.resolve(null);
							} else {
								var item = result.rows.item(0);
								var metaData = {
									$key: item.key,
									$collection: item.collection,
									$endpoint: item.endpoint,
									$context: item.context,
									$id: item.id,
									$etag: item.etag,
									$lastRead: item.last_read,
									$lastUpdated: item.last_updated
								};
								log && log("Read meta data: " + JSON.stringify(metaData));
								if (noUpdate === true) {
									deferred.resolve(metaData);
								} else {
									self._writeMetaData(metaData)
										.then(function() {
											// allways resolve and ignore errors
											deferred.resolve(metaData);
										}).fail(function(e) {
											deferred.reject(storageInterface.buildErrResult("error reading from database", e));
										});
								}
							}
						} catch (e) {
							deferred.reject(storageInterface.buildErrResult("error reading from database", e));
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},
		// #8093 Locks the key and returns true if key wasn't locked
		_conflictMetaLock: function(metaId) {
			var locked = false;
			if (!this._lockedMeta) {
				this._lockedMeta = [];
			} else {
				locked = this._lockedMeta.indexOf(metaId) >= 0;
			}
			if (locked === false) {
				this._lockedMeta.push(metaId);
			}
			return locked === false;
		},
		// #8093 Put deferred and meta in waiting queue
		_conflictMetaWait: function(metaId, deferred, metaData) {
			log && log("!!CONFLICT WAIT", metaId);
			if (!this._pendingMeta) {
				this._pendingMeta = {};
			}
			var stack = this._pendingMeta[metaId];
			if (!stack) {
				stack = this._pendingMeta[metaId] = [];
			}
			stack.push({
				deferred: deferred,
				metaData: metaData
			});
		},
		// #8093 Unlock the key and process pending metaData (UPDATE) for this key if any
		_conflictMetaUnlock: function(metaId) {
			var idx = this._lockedMeta.indexOf(metaId);
			if (idx >= 0) {
				this._lockedMeta.splice(idx, 1);
			}
			var stack = this._pendingMeta ? this._pendingMeta[metaId] : null;
			if (!stack) {
				return;
			}
			var data = stack.pop();
			if (stack.length === 0) {
				delete this._pendingMeta[metaId];
			}
			if (!data) {
				return;
			}
			log && log("!!CONFLICT RETRY", metaId);
			this._writeMetaData(data.metaData).then(function(metaData) {
				data.deferred.resolve(metaData);
			}).fail(function(status) {
				data.deferred.reject(status);
			});
		},
		_writeMetaData: function(metaData) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				metaData.$lastRead = utils.getCurISODateTime();
				if (!metaData.$id) {
					// #8093 - Set metaData.$id first to force UPDATE if a retry is needed in case of conflict (It will update existing record)
					metaData.$id = utils.UUID();
					// Unique key that could create conflict (Index)
					var metaId = [
						metaData.$key,
						metaData.$collection,
						metaData.$endpoint,
						JSON.stringify(metaData.$context)
					].join('-');
					// Chek if key is locked
					if (self._conflictMetaLock(metaId)) {
						self._executeSql("INSERT INTO sdata_meta (key, collection, endpoint, context, id, etag, last_read, last_updated) values (?, ?, ?, ?, ?, ?, ?, ?)", [
								metaData.$key,
								metaData.$collection,
								metaData.$endpoint,
								JSON.stringify(metaData.$context),
								metaData.$id,
								metaData.$etag,
								metaData.$lastRead,
								metaData.$lastUpdated
							])
							.then(function() {
								// Unnlock key
								self._conflictMetaUnlock(metaId);
								deferred.resolve(metaData);
							}).fail(function(status) {
								// Unnlock key
								self._conflictMetaUnlock(metaId);
								deferred.reject(status);
							});
					} else {
						// Save deferred and data - Lets retry when key is unlocked
						self._conflictMetaWait(metaId, deferred, metaData);
					}
				} else {
					self._executeSql("UPDATE sdata_meta set etag = ?, last_read = ?, last_updated = ? where id = ?", [metaData.$etag, metaData.$lastRead, metaData.$lastUpdated, metaData.$id])
						.then(function(result) {
							deferred.resolve(metaData);
						}).fail(function(status) {
							deferred.reject(status);
						});
				}
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error writing meta data", e));
			} finally {
				return deferred.promise();
			}
		},

		_removeMetaData: function(context, params) {
			var deferred = $.Deferred();
			var self = this;
			try {
				self._readMetaData(context, params, true)
					.then(function(metaData) {
						if (!metaData) {
							deferred.resolve(null);
						} else {
							self._executeSql("DELETE FROM sdata_meta where id = ?", [metaData.$id])
								.then(function() {
									deferred.resolve(metaData);
								}).fail(function(status) {
									deferred.reject(status);
								});
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		}
	});
});

define('syracuse-tablet/html/js/storage/storageWebSQLDrafts',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/storage/storageWebSQLSData','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var Base = require('syracuse-tablet/html/js/storage/storageWebSQLSData').Klass;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("drafts", false);
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
/**
 * WebSQL storage interface - DRAFTS MANAGEMENT
 * Inherits from storageWebSQLSData only to split the code
 */

var _DRAFT_INSERT = "INSERT INTO sdata_drafts (id, endpoint, representation, comment, status, errorMsg, dataSet, restoredContext, saveLink, title, creation_date) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
var _DRAFT_DELETE_ALL = "DELETE FROM sdata_drafts";
var _DRAFT_DELETE = "DELETE FROM sdata_drafts where id = ?";
var _DRAFT_READ = "SELECT * FROM sdata_drafts where id = ?";
var _DRAFT_READ_LIST = "SELECT id, endpoint, representation, comment, status, errorMsg, title, creation_date FROM sdata_drafts";
var _DRAFT_COUNT = "SELECT COUNT(*) AS counter FROM sdata_drafts";
var _tables = {
	"sdata_drafts": [
		"DROP TABLE IF EXISTS sdata_drafts",
		"CREATE TABLE sdata_drafts ( " +
		"id text, " +
		"endpoint text, " +
		"representation text, " +
		"comment text, " +
		"status text, " +
		"errorMsg, " +
		"dataSet text, " +
		"restoredContext text, " +
		"saveLink text, " +
		"title text, " +
		"creation_date text" +
		")",
		"DROP INDEX IF EXISTS sdata_drafts_id",
		"CREATE UNIQUE INDEX sdata_drafts_id ON sdata_drafts (id)"
	],
	"sdata_wrkcpy": [
		// Workingcopy
		"DROP TABLE IF EXISTS sdata_wrkcpy",
		"CREATE TABLE sdata_wrkcpy ( " +
		"id text, " +
		"dataSet text, " +
		"creation_date text" +
		")",
		"DROP INDEX IF EXISTS sdata_wrkcpy_id",
		"CREATE UNIQUE INDEX sdata_wrkcpy_id ON sdata_wrkcpy (id)"
	]
};

var _logError = function(title, status) {
	log && log(title + " ERROR");
	log && log(storageInterface.resultToString(status));
};
/**
 * Manages drafts and working copies storage
 */
exports.Klass = utils.defineClass(
	function() {
		Base.call(this);
		this._wrkcpyAllDeleted = false;
	}, Base, {
		getTables: function() {
			var res = Base.prototype.getTables.call(this);
			$.extend(res, _tables);
			return res;
		},
		/**
		 * Resolve with true/false
		 */
		_wrkcpyExists: function(id) {
			var self = this;
			return self._executeSql("SELECT * FROM sdata_wrkcpy where id = ?", [id])
				.then(function(result) {
					if (result && result.rows && result.rows.length > 0) {
						return true;
					}
					return false;
				}).fail(function(status) {
					_logError("_wrkcpyExists", status);
					return false;
				});
		},
		/**
		 * Resolve with data/null
		 */
		_wrkcpyRead: function(id) {
			var self = this;
			return self._executeSql("SELECT * FROM sdata_wrkcpy where id = ?", [id])
				.then(function(result) {
					if (!result || !result.rows || result.rows.length == 0) return null;
					try {
						result = JSON.parse(result.rows.item(0).dataSet);
						log && log("_wrkcpyRead", id, "OK");
						return result;
					} catch (e) {
						log && log("_wrkcpyRead", "KO", id);
						return null;
					}
				}).fail(function(status) {
					_logError("_wrkcpyRead", status);
					return null;
				});
		},
		/**
		 * Resolve with  true/false
		 * Delete all the working copies that belong to transaction_id
		 */
		_wrkcpyDelete: function(id) {
			var self = this;
			return self._executeSql("DELETE FROM sdata_wrkcpy where id = ?", [id]).then(function(result) {
				log && log("_wrkcpyDelete", id, result ? "OK" : "KO");
				return true;
			}).fail(function(status) {
				_logError("_wrkcpyDelete", status);
				return false;
			});
		},
		/**
		 * Resolve with true/false
		 */
		_wrkcpyDeleteAll: function() {
			var self = this;
			if (self._wrkcpyAllDeleted === true) {
				// Optimization
				return $.smResolve(null);
			}
			return self._executeSql("DELETE FROM sdata_wrkcpy").then(function(result) {
				log && log("_wrkcpyDeleteAll OK");
				self._wrkcpyAllDeleted = true;
				return true;
			}).fail(function(status) {
				_logError("_wrkcpyDeleteAll", status);
				return false;
			});
		},
		/**
		 * Resolve with dataSet/null
		 */
		_wrkcpyCreate: function(dataSet) {
			var self = this;
			if (!dataSet || !dataSet.$uuid) {
				log && log("_wrkcpyCreate error", "Invalid parameters");
				return $.smResolve(null);
			}
			return self._wrkcpyDelete(dataSet.$uuid).then(function() {
				return self._wrkcpyDoInsert(dataSet);
			});
		},
		_wrkcpyDoInsert: function(dataSet) {
			var self = this;
			return self._executeSql("INSERT INTO sdata_wrkcpy (dataSet, id) values (?, ?)", [JSON.stringify(dataSet), dataSet.$uuid])
				.then(function() {
					log && log("_wrkcpyDoInsert", dataSet.$uuid, "OK");
					self._wrkcpyAllDeleted = false;
					return dataSet;
				}).fail(function(status) {
					_logError("_wrkcpyDoInsert", status);
					return null;
				});
		},
		_wrkcpyDoUpdate: function(dataSet) {
			var self = this;
			return self._executeSql("UPDATE sdata_wrkcpy set dataSet = ? where id = ?", [JSON.stringify(dataSet), dataSet.$uuid]).then(function(result) {
				log && log("_wrkcpyDoUpdate", "OK");
				return dataSet;
			}).fail(function(status) {
				_logError("_wrkcpyDoUpdate", status);
				return null;
			});
		},
		_wrkcpyUpdate: function(dataSet) {
			var self = this;
			if (!dataSet || !dataSet.$uuid) {
				log && log("_wrkcpyUpdate error", "Invalid parameters");
				return $.smResolve(null);
			}
			return self._wrkcpyExists(dataSet.$uuid).then(function(exists) {
				if (exists === true) {
					log && log("_wrkcpyUpdate UPDATE", dataSet.$uuid);
					return self._wrkcpyDoUpdate(dataSet);
				} else {
					log && log("_wrkcpyUpdate CREATE", dataSet.$uuid);
					return self._wrkcpyDoInsert(dataSet);
				}
			});
		},
		_draftReadInfo: function(item) {
			if (!item) return null;
			try {
				return {
					id: item.id,
					endpoint: item.endpoint || "",
					representation: item.representation || "",
					comment: item.comment || "",
					status: item.status || "none",
					errorMsg: item.errorMsg || "",
					dataSet: item.dataSet ? JSON.parse(item.dataSet) : null,
					restoredContext: item.restoredContext ? JSON.parse(item.restoredContext) : null,
					saveLink: item.saveLink ? JSON.parse(item.saveLink) : null,
					title: item.title || "",
					creation_date: item.creation_date
				};
			} catch (e) {
				log && log("_draftReadInfo", "KO", item.id);
				return null;
			}
		},
		/**
		 * Resolve with [resources]/[]
		 */
		_draftReadList: function() {
			var self = this;
			return self._executeSql(_DRAFT_READ_LIST)
				.then(function(result) {
					if (!result || !result.rows || result.rows.length == 0) return [];
					var resources = [],
						rec;
					for (var i = 0; i < result.rows.length; i++) {
						rec = self._draftReadInfo(result.rows.item(i));
						if (rec) {
							resources.push(rec);
						}
					}
					log && log("_draftReadList", "OK");
					return resources;
				}).fail(function(status) {
					_logError("_draftReadList", status);
					return [];
				});
		},
		/**
		 * Resolve with data/null
		 */
		_draftRead: function(id) {
			var self = this;
			return self._executeSql(_DRAFT_READ, [id])
				.then(function(result) {
					if (!result || !result.rows || result.rows.length == 0) return null;
					log && log("_draftRead", id, "OK");
					return self._draftReadInfo(result.rows.item(0));
				}).fail(function(status) {
					_logError("_draftRead", status);
					return null;
				});
		},
		/**
		 * Resolve with  true/false
		 */
		_draftDelete: function(id) {
			var self = this;
			return self._executeSql(_DRAFT_DELETE, [id]).then(function(result) {
				log && log("_draftDelete", id, result ? "OK" : "KO");
				self._draftNotifyChanged();
				return true;
			}).fail(function(status) {
				_logError("_draftDelete", status);
				return false;
			});
		},
		/**
		 * Resolve with true/false
		 */
		_draftDeleteAll: function() {
			var self = this;
			return self._executeSql(_DRAFT_DELETE_ALL).then(function(result) {
				log && log("_draftDeleteAll OK");
				self._draftNotifyChanged();
				return true;
			}).fail(function(status) {
				_logError("_draftDeleteAll", status);
				return false;
			});
		},
		/**
		 * Resolve with draft context or reject with an exception
		 */
		_draftSave: function(ctx) {
			var self = this;
			var deferred = $.Deferred();
			if (!ctx || !ctx.id) {
				log && log("_draftSave error", "Invalid parameters");
				deferred.reject(new Error("Invalid parameters"));
			} else {
				self._draftDelete(ctx.id).then(function() {
					return self._executeSql(_DRAFT_INSERT, [ctx.id, ctx.endpoint, ctx.representation, ctx.comment, ctx.status, ctx.errorMsg, JSON.stringify(ctx.dataSet), JSON.stringify(ctx.restoredContext), JSON.stringify(ctx.saveLink), ctx.title, ctx.creation_date]);
				}).then(function() {
					log && log("_draftSave", ctx.id, "OK");
					self._draftNotifyChanged();
					deferred.resolve(ctx);
				}).fail(function(status) {
					_logError("_draftSave", status);
					deferred.reject(status.$exception || new Error(status.message));
				});
			}
			return deferred.promise();
		},
		_draftCount: function(notify) {
			return this._executeSql(_DRAFT_COUNT).then(function(result) {
				var count = result && result.rows.length > 0 ? result.rows.item(0).counter : 0;
				if (notify) {
					notifications.publish("sm.drafts.changed", count);
				}
				return count;
			}).fail(function(status) {
				_logError("_draftCount", status);
				return 0;
			});
		},
		/**
		 * Notifies to update the number of draft in menu
		 */
		_draftNotifyChanged: function() {
			return this._draftCount(true);
		},
		/**
		 * Drafts
		 * op: Operation
		 * 		save
		 * 			args(1) create true/false
		 * 		read
		 * 		query
		 * 		delete
		 * 		switchStatus
		 */
		draftOperation: function(op) {
			switch (op) {
				case "wrkcpyUpdate":
					return this._wrkcpyUpdate(arguments[1]);
				case "wrkcpyRead":
					return this._wrkcpyRead(arguments[1]);
				case "wrkcpyDelete":
					return this._wrkcpyDelete(arguments[1]);
				case "wrkcpyCreate":
					return this._wrkcpyCreate(arguments[1], arguments[2]);
				case "wrkcpyDeleteAll":
					return this._wrkcpyDeleteAll(arguments[1]);
				case "draftSave":
					return this._draftSave(arguments[1]);
				case "draftDelete":
					return this._draftDelete(arguments[1]);
				case "draftDeleteAll":
					return this._draftDeleteAll();
				case "draftRead":
					return this._draftRead(arguments[1]);
				case "draftReadList":
					return this._draftReadList();
				case "draftCount":
					return this._draftCount(false);
				case "draftNotifyChanged":
					var self = this;
					setTimeout(function() {
						self._draftNotifyChanged();
					});
					return;
				default:
					return $.smReject(storageInterface.buildErrResult("Unknown Draft operation[" + op + "]"));
			}
		}
	});
});

define('syracuse-tablet/html/js/storage/storageWebSQLTemplates',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/storage/storageWebSQLDrafts','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var Base = require('syracuse-tablet/html/js/storage/storageWebSQLDrafts').Klass;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("templates", false);
/**
 * WebSQL storage interface - TEMPLATES MANAGEMENT
 * Inherits from storageWebSQLSData only to split the code
 */

var _TMPL_INSERT = "INSERT INTO sdata_templates (id, endpoint, representation, title, dataSet, creation_date) values (?, ?, ?, ?, ?, ?)";
var _TMPL_DELETE_ALL = "DELETE FROM sdata_templates";
var _TMPL_DELETE = "DELETE FROM sdata_templates where id = ?";
var _TMPL_READ = "SELECT * FROM sdata_templates where id = ?";
var _TMPL_QUERY = "SELECT id, endpoint, representation, title, creation_date FROM sdata_templates";
var _TMPL_COUNT = "SELECT COUNT(*) AS counter FROM sdata_templates";
var _tables = {
	"sdata_templates": [
		"DROP TABLE IF EXISTS sdata_templates",
		"CREATE TABLE sdata_templates ( " +
		"id text, " +
		"endpoint text, " +
		"representation text, " +
		"title text, " +
		"dataSet text, " +
		"creation_date text" +
		")",
		"DROP INDEX IF EXISTS sdata_templates",
		"CREATE UNIQUE INDEX sdata_templates_id ON sdata_templates (id)"
	]
};

var _logError = function(title, status) {
	log && log(title + " ERROR");
	log && log(storageInterface.resultToString(status));
};
/**
 * Manages templates (edit/create facets) storage
 */
exports.Klass = utils.defineClass(
	function() {
		Base.call(this);
	}, Base, {
		getTables: function() {
			var res = Base.prototype.getTables.call(this);
			$.extend(res, _tables);
			return res;
		},
		_tmplReadInfo: function(item) {
			if (!item) return null;
			try {
				return {
					"id": item.id,
					"endpoint": item.endpoint || "",
					"representation": item.representation || "",
					"title": item.title || "",
					"dataSet": item.dataSet ? JSON.parse(item.dataSet) : null,
					"creation_date": item["creation_date"]
				};
			} catch (e) {
				log && log("_tmplReadInfo", "KO", item.id);
				return null;
			}
		},
		/**
		 * Resolve with [resources]/[] or reject with a exception
		 */
		_tmplQuery: function(representation, endpoint) {
			var self = this;
			var deferred = $.Deferred();
			var req = _TMPL_QUERY;
			var params = [];
			if (representation || endpoint) {
				req += " where ";
				if (representation) {
					req += "representation = ?";
					params.push(representation);
					if (endpoint) {
						req += " and ";
					}
				}
				if (endpoint) {
					req += "endpoint = ?";
					params.push(endpoint);
				}
			}
			self._executeSql(req, params)
				.then(function(result) {
					log && log("_tmplQuery", "OK");
					if (!result || !result.rows || result.rows.length == 0) {
						return deferred.resolve([]);
					}
					var resources = [],
						rec;
					for (var i = 0; i < result.rows.length; i++) {
						rec = self._tmplReadInfo(result.rows.item(i));
						if (rec) {
							resources.push(rec);
						}
					}
					deferred.resolve(resources);
				}).fail(function(status) {
					_logError("_tmplQuery", status);
					deferred.reject(status.$exception || new Error(status.message));
				});
			return deferred.promise();
		},
		/**
		 * Resolve with data/null or reject with a exception
		 */
		_tmplRead: function(id) {
			var self = this;
			var deferred = $.Deferred();
			self._executeSql(_TMPL_READ, [id]).then(function(result) {
				log && log("_tmplRead", id, "OK");
				if (!result || !result.rows || result.rows.length == 0) {
					return deferred.resolve(null);
				}
				deferred.resolve(self._tmplReadInfo(result.rows.item(0)));
			}).fail(function(status) {
				_logError("_tmplRead", status);
				deferred.reject(status.$exception || new Error(status.message));
			});
			return deferred.promise();
		},
		/**
		 * Resolve or reject with a exception
		 */
		_tmplUpdate: function(id, ctx) {
			var self = this;
			return self._tmplRead(id).then(function(result) {
				if (!result || !ctx) return;
				return self._tmplSave($.extend(result, ctx), false);
			});
		},
		/**
		 * Resolve or reject with a exception
		 */
		_tmplDelete: function(id) {
			var self = this;
			var deferred = $.Deferred();
			self._executeSql(_TMPL_DELETE, [id]).then(function(result) {
				log && log("_tmplDelete", id, result ? "OK" : "KO");
				deferred.resolve();
			}).fail(function(status) {
				_logError("_tmplDelete", status);
				deferred.reject(status.$exception || new Error(status.message));
			});
			return deferred.promise();
		},
		/**
		 * Resolve or reject with a exception
		 */
		_tmplDeleteAll: function() {
			var self = this;
			var deferred = $.Deferred();
			self._executeSql(_TMPL_DELETE_ALL).then(function(result) {
				log && log("_tmplDeleteAll OK");
				deferred.resolve();
			}).fail(function(status) {
				_logError("_tmplDeleteAll", status);
				deferred.reject(status.$exception || new Error(status.message));
			});
			return deferred.promise();
		},
		/**
		 * Resolve with template context or reject with an exception
		 */
		_tmplSave: function(ctx, updateDate) {
			var self = this;
			var deferred = $.Deferred();
			if (!ctx || !ctx.id) {
				log && log("_tmplSave error", "Invalid parameters");
				deferred.reject(new Error("Invalid parameters"));
			} else {
				self._tmplDelete(ctx.id).then(function() {
					if (ctx["creation_date"] == null || updateDate) {
						ctx["creation_date"] = utils.getCurISODateTime(new Date());
					}
					return self._executeSql(_TMPL_INSERT, [ctx.id, ctx.endpoint, ctx.representation, ctx.title, JSON.stringify(ctx.dataSet), ctx.creation_date]);
				}).then(function() {
					log && log("_tmplSave", ctx.id, "OK");
					deferred.resolve(ctx);
				}).fail(function(status) {
					_logError("_tmplSave", status);
					deferred.reject(status.$exception || new Error(status.message));
				});
			}
			return deferred.promise();
		},
		_tmplCount: function() {
			return this._executeSql(_TMPL_COUNT, []).then(function(result) {
				return result && result.rows.length > 0 ? result.rows.item(0).counter : 0;
			}).fail(function(status) {
				_logError("_tmplCount", status);
				return 0;
			});
		},
		/**
		 * Templates
		 * op: Operation
		 */
		templateOperation: function(op) {
			switch (op) {
				case "save":
					return this._tmplSave(arguments[1], true);
				case "delete":
					return this._tmplDelete(arguments[1]);
				case "deleteAll":
					return this._tmplDeleteAll();
				case "read":
					return this._tmplRead(arguments[1]);
				case "update":
					return this._tmplUpdate(arguments[1], arguments[2]);
				case "query":
					return this._tmplQuery(arguments[1], arguments[2], arguments[3]);
				case "readall":
					return this._tmplQuery(arguments[1]);
				case "count":
					return this._tmplCount();
				default:
					return $.smReject(storageInterface.buildErrResult("Unknown template operation[" + op + "]"));
			}
		}
	});
});

define('syracuse-tablet/html/js/storage/storageWebSQL',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/environment','syracuse-tablet/html/js/storage/storageWebSQLTemplates'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("webSQL", false);
var environment = require('syracuse-tablet/html/js/helpers/environment');

/*
 * WebSQL storage interface (Chrome, Safari)
 */

/**
 * The top class is storageWebSQLTemplates
 * It's just a trick to split the code that manages Templates/Drafts from the one that manages SDtata in 3 sub classes of storageWebSQLBase
 */
var _storageInterface = require('syracuse-tablet/html/js/storage/storageWebSQLTemplates').Klass;


exports.getStorageInterface = function() {
	return _storageInterface;
};
exports.isAvailable = function() {
	if ((environment.checkBrowserName("chrome") && environment.isOs("ios")) || (environment.checkBrowserName("safari") && environment.isOs("osx"))) {
		// IndexedDB works fine also on Chrome/Desktop - We should use it instead of WebSQL
		log && log("chrome on ios - force indexedDB");
		return null;
	}
	return window.openDatabase != null;
};
});

define('syracuse-tablet/html/js/storage/storageIndexedDBBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {

/*
 * IndexDB storage interface (Internet Explorer, Firefox)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var Base = storageInterface.Klass;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("indexedDB", false);

// Increase this number to upgrade database to schema described in objectStores
var _databaseVersion = 22;
var _indexedDB = window.indexedDB || window.webkitIndexedDB;

var _logError = function(title, status) {
	log && log(title + " ERROR");
	if (!status) return;
	var request = status.target || status.currentTarget || status.originalTarget;
	if (request && request.error && request.error.message) {
		log && log((request.error.name ? "[" + request.error.name + "]" : "") + request.error.message);
		return;
	}
	log && log(storageInterface.resultToString(status));
};

exports.Klass = utils.defineClass(
	function() {
		Base.call(this, "IndexedDB storage interface", _databaseVersion);
	},
	Base, {

		init: function(requester) {
			var self = this;
			requester = requester || "";
			log && log("_INIT " + requester);
			var deferred = $.Deferred();
			var step = jsutils.isTestEnvironment() ? self._initTestDB() : $.smResolve();
			step.then(function() {
				if (self.db) {
					log && log("DATABASE ALREADY INITIALIZED!");
					return (storageInterface.buildResult(storageInterface.StatusCodes.OK));
				}
				log && log("DATABASE INIT!");
				return self._openDB();
			}).then(function(status) {
				log && log("_openDB OK " + requester);
				deferred.resolve(status);
			}).fail(function(e) {
				_logError("_openDB KO " + requester);
				var msg = locale.text("db.err.init");
				var err = self._eventToMessage(e);
				if (err && err.toLowerCase().indexOf("versionerrror") >= 0) {
					msg += "\n" + locale.text("db.err.version");
				}
				deferred.reject(self._eventToDiagnose(msg, e));
			});
			return deferred.promise();
		},

		_initTestDB: function(requester) {
			var self = this;
			var deferred = $.Deferred();
			$.smResolve().then(function() {
				if (self.db) {
					self.db.close();
					self.db = null;
				}
				self.useTestDatabase = true;
				self.databaseName = storageInterface.databaseName + "-test";
				log && log("DATABASE IN TEST MODE! " + requester);
				var req = _indexedDB.deleteDatabase(self.databaseName);
				req.onsuccess = function() {
					deferred.resolve();
				};
				req.onerror = function(e) {
					_logError("REQUEST ERROR! " + requester);
					deferred.reject(e);
				};
				req.onblocked = function(e) {
					_logError("REQUEST BLOCKED! " + requester);
					deferred.reject(e);
				};
			}).fail(function(e) {
				_logError("_initTestDB KO " + requester);
				deferred.reject(e);
			});
			return deferred.promise();
		},

		_openDB: function() {
			var deferred = $.Deferred();
			var self = this;
			if (self.useTestDatabase === false && self.db) {
				deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
			} else {
				var request;
				try {
					log && log("Open database, request version: " + self.databaseVersion);
					request = _indexedDB.open(self.databaseName, self.databaseVersion);
					request.onupgradeneeded = function(e) {
						log && log("Open database, need upgrade");
						self.db = (e.target.result || e.target.source);
						self._createObjectStore();
					};
					request.onsuccess = function(e) {
						log && log("Open database, success");
						var db = (e.target.result || e.target.source);
						if (!db.setVersion && (self.databaseVersion != db.version)) {
							log && log("Open database, versions missmatch: " + self.DatabaseVersion + " != " + db.version);
							var sdv = db.setVersion(self.databaseVersion);
							sdv.onsuccess = function(e) {
								log && log("Open database, setting version, success");
								self.db = db;
								self._createObjectStore();
								log && log("Open database, opened");
								deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
							};
							sdv.onerror = function(e) {
								log && log("Open database, setting version, error", e);
								self.db = null;
								deferred.reject(e);
							};
						} else {
							log && log("Open database, opened");
							self.db = db;
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
						}
					};
					request.onerror = function(e) {
						_logError("Open database, error", e);
						self.db = null;
						deferred.reject(e);
					};
				} catch (ex) {
					_logError("Open database, exception", ex);
					self.db = null;
					deferred.reject(ex);
				}
			}
			return deferred.promise();
		},
		/**
		 * Returns the objectStore to create
		 */
		getObjectStores: function() {
			return {};
		},
		// Create schema of database on version change
		_createObjectStore: function() {
			var self = this;
			var db = self.db;
			log && log("Updating database");
			try {
				var objectStores = this.getObjectStores();
				Object.keys(objectStores).forEach(function(name) {
					var os = objectStores[name];
					if (db.objectStoreNames.contains(name)) {
						log && log("Deleting objectStore: " + name);
						db.deleteObjectStore(name);
					}
					log && log("Creating objectStore: " + name);
					var obj = db.createObjectStore(name, os.options);
					Object.keys(os.indexes).forEach(function(iname) {
						var idx = os.indexes[iname];
						log && log("Creating index: " + iname);
						obj.createIndex(iname, idx.key, idx.options);
					});
				});
			} catch (e) {
				// Log because error doesn't bubble to the mail caller (caught by onupgradeneeded)
				_logError("_createObjectStore, error", e);
				throw e;
			}
		},
		// Used by children classes
		_eventToMessage: function(event) {
			var request = event.target || event.currentTarget || event.originalTarget;
			if (request && request.error && request.error.message) {
				return (request.error.name ? "[" + request.error.name + "]" : "") + request.error.message;
			}
			return JSON.stringify(event);
		},
		_eventToDiagnose: function(msg, e) {
			if (jsutils.isError(e) || jsutils.isDOMException(e)) {
				var diags = jsutils.convertToDiagnoses(e);
				diags.$diagnoses[0].$message = msg + "\n" + diags.$diagnoses[0].$message;
				return diags;
			}
			var request = e.target || e.currentTarget || e.originalTarget;
			var stack;
			if (request && request.error && request.error.message) {
				stack = (request.error.name ? "[" + request.error.name + "]" : "") + request.error.message;
			} else {
				stack = JSON.stringify(e, null, 2);
			}
			return {
				"$diagnoses": [{
					"$severity": "error",
					"$message": msg,
					"$stackTrace": stack
				}]
			};
		},
		// Needed because we can't clear the cache manually on FF and IE - #7942
		clearDatabaseSupported: function() {
			return true;
		},
		clearDatabase: function() {
			var self = this;
			var deferred = $.Deferred();
			$.smResolve().then(function() {
				var req = window.indexedDB.deleteDatabase(self.databaseName);
				req.onsuccess = function() {
					deferred.resolve(true);
				};
				req.onerror = function(e) {
					deferred.resolve(false);
					console.log("Database deletion failed");
					console.log(e);
				};
			}).fail(function() {
				deferred.resolve(false);
			});
			return deferred.promise();
		}

	}
);
});

define('syracuse-tablet/html/js/storage/storageIndexedDBSData',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/storage/storageIndexedDBBase','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {

/*
 * IndexDB storage interface (Internet Explorer, Firefox)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/storage/storageIndexedDBBase').Klass;
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("sData", false);

var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
var IDBDatabaseException = window.IDBDatabaseException || window.webkitIDBDatabaseException;

var READ_ONLY = (IDBTransaction && IDBTransaction.READ_ONLY) || "readonly";
var READ_WRITE = (IDBTransaction && IDBTransaction.READ_WRITE) || "readwrite";

var _objectStores = {
	"sdata": {
		"options": {
			"autoIncrement": true
		},
		"indexes": {
			"read_write_one": {
				"key": "key_collection_endpoint_context",
				"options": {
					"unique": true
				}
			},
			"read_write_all": {
				"key": "collection_endpoint_context",
				"options": {
					"unique": false
				}
			},
			"read_write_ctx": {
				"key": "context",
				"options": {
					"unique": false
				}
			}
		}
	}
};

exports.Klass = utils.defineClass(
	function() {
		Base.call(this);
	},
	Base, {

		getObjectStores: function() {
			var res = Base.prototype.getObjectStores.call(this);
			$.extend(res, _objectStores);
			return res;
		},

		put: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("PUT: ", JSON.stringify(opts));
				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$key, opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_one");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);
				var mustInsert = true;
				var datetime = utils.getCurISODateTime();
				var doInsert = function() {
					var obj = {
						"context": context,
						"collection": opts.$collection,
						"endpoint": opts.$endpoint,
						"key": opts.$key,
						"last_updated": datetime,
						"last_read": datetime,
						"key_collection_endpoint_context": key,
						"collection_endpoint_context": [opts.$collection, opts.$endpoint, context].join("_"),
						"data": opts.$data,
					};
					var reqt = objectStore.add(obj);
					reqt.onerror = function(event) {
						deferred.reject(storageInterface.buildErrResult("error writing to database: " + self._eventToMessage(event)));
					};
					reqt.onsuccess = function(event) {
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
					};
				};
				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						// In case we saved an empty data we force insert
						if (cr && cr.value && cr.value.data) {
							if (opts.$data.$etag) {
								var etag = cr.value && cr.value.data.$etag;
								if (etag === opts.$data.$etag) {
									deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
									return;
								}
							}
							cr["delete"]();
							cr["continue"]();
						} else {
							doInsert();
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error writing to database", e));
					}
				};
				request.onerror = function(event) {
					if (IDBDatabaseException && event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						doInsert();
					} else {
						deferred.reject(storageInterface.buildErrResult("error writing to database: " + self._eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error writing to database", e));
			} finally {
				return deferred.promise();
			}
		},

		read: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("READ: ", JSON.stringify(opts));
				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");
				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);
				var key = [opts.$key, opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_one");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);

				request.onsuccess = function(event) {
					try {
						var cr = event.target && event.target.result && event.target.result.value;
						if (!cr) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						} else {
							deferred.resolve(storageInterface.buildResult(
								storageInterface.StatusCodes.OK,
								cr.data,
								null,
								null, {
									$lastRead: cr.last_read,
									$lastUpdated: cr.last_updated
								}));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (IDBDatabaseException && event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						// Resolve since it's a logical issue and not neccessarily an error
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + self._eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		query: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("QUERY: ", JSON.stringify(opts));
				if (!opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_all");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);
				var results = [];
				var meta = [];

				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							var data = cr.value.data;
							results.push(data);
							meta.push({
								$lastRead: cr.value.last_read,
								$lastUpdated: cr.value.last_updated
							});
							cr["continue"]();
						} else {
							deferred.resolve(storageInterface.buildResult(
								storageInterface.StatusCodes.OK,
								results,
								null,
								null,
								meta));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (IDBDatabaseException && event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						// Resolve since it's a logical issue and not neccessarily an error
						deferred.resolve(storageInterface.buildResult(
							storageInterface.StatusCodes.OK,
							results,
							null,
							null,
							meta));
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + self._eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		remove: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("REMOVE: ", JSON.stringify(opts));
				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$key, opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_one");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);

				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							cr["delete"]();
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
						} else {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error deleting from database", e));
					}
				};
				request.onerror = function(event) {
					if (IDBDatabaseException && event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						// Resolve since it's a logical issue and not neccessarily an error
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + self._eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error deleting from database", e));
			} finally {
				return deferred.promise();
			}
		},

		clearCollection: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("CLEAR: ", JSON.stringify(opts));
				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = context;

				//				var index = objectStore.index("read_write_ctx");
				//				var keyRange = IDBKeyRange.only(key);
				//				var request = index.openCursor(keyRange);
				var request = objectStore.openCursor();

				var records = [];

				var deleteMatches = function() {
					$.smForEachPromise(records, function(rec) {
						return self.remove({
							$context: opts.$context,
							$collection: rec.collection,
							$endpoint: rec.endpoint,
							$key: rec.key
						});
					}).then(function() {
						deferred.resolve();
					}).fail(function(e) {
						deferred.reject(e);
					});
				};
				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							if (opts.$collection.test(cr.value.collection)) {
								if (!opts.$not_read_since || cr.value.last_read < opts.$not_read_since) {
									records.push(cr.value);
								}
							}
							cr["continue"]();
						} else {
							deleteMatches();
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (IDBDatabaseException && event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						deleteMatches();
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + self._eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		computeCollectionSize: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("SIZE: ", JSON.stringify(opts));
				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = context;

				//				var index = objectStore.index("read_write_ctx");
				//				var keyRange = IDBKeyRange.only(key);
				//				var request = index.openCursor(keyRange);
				var request = objectStore.openCursor();
				var returnData = {
					numRecords: 0,
					sizeRecords: 0
				};

				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							if (opts.$collection.test(cr.value.collection)) {
								if (!opts.$not_read_since || cr.value.last_read < opts.$not_read_since && cr.value.context === key) {
									returnData.numRecords++;
									returnData.sizeRecords += JSON.stringify(cr.value).length;
								}
							}
							cr["continue"]();
						} else {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, returnData));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (IDBDatabaseException && event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						deferred.resolve();
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + self._eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		}
	}
);
});

define('syracuse-tablet/html/js/storage/storageIndexedDBDrafts',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/storage/storageIndexedDBSData','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {

/*
 * IndexDB storage interface (Internet Explorer, Firefox)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var Base = require('syracuse-tablet/html/js/storage/storageIndexedDBSData').Klass;
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("drafts", false);
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
var IDBDatabaseException = window.IDBDatabaseException || window.webkitIDBDatabaseException;

var READ_ONLY = (IDBTransaction && IDBTransaction.READ_ONLY) || "readonly";
var READ_WRITE = (IDBTransaction && IDBTransaction.READ_WRITE) || "readwrite";


var _objectStores = {
	"drafts": {
		"options": {
			"keyPath": "id",
			"autoIncrement": true
		},
		"indexes": {}
	},
	"workingcopies": {
		"options": {
			"keyPath": "id",
			"autoIncrement": true
		},
		"indexes": {}
	}
};

var _logError = function(who, e) {
	if (!log) return;
	log("INDEXED DB - ERROR");
	for (var i = 0; i < arguments.length; i++) {
		var e = arguments[i];
		if (typeof e === "string") {
			log(e);
			continue;
		}
		if (e && e.target && IDBDatabaseException) {
			if (e.target.errorCode != IDBDatabaseException.NOT_FOUND_ERR) {
				log(JSON.stringify(e, null, 2));
				continue;
			}
		}
		log(JSON.stringify(jsutils.convertToDiagnoses(e), null, 2));
	}
};

var _objName = function(type) {
	return type === "d" ? "drafts" : "workingcopies";
};
/**
 * Manages drafts and working copies storage
 */
exports.Klass = utils.defineClass(
	function() {
		Base.call(this);
	},
	Base, {
		/** Overridden method */
		getObjectStores: function() {
			var res = Base.prototype.getObjectStores.call(this);
			$.extend(res, _objectStores);
			return res;
		},

		/** OMethods below are private - Use a dedicated name specific to the class */

		/**
		 * type: d for drafts -  w for workingcopies
		 * Resolves with object store or rejects
		 */
		_draftsObjectStore: function(type, readOpt) {
			var self = this;
			var deferred = $.Deferred();
			try {
				var tx = self.db.transaction([_objName(type)], readOpt || READ_WRITE);
				tx.oncomplete = function(event) {
					log && log("tx.oncomplete", JSON.stringify(event, null, 2));
				};
				tx.onerror = function(event) {
					log && log("tx.onerror", JSON.stringify(event, null, 2));
					//_logError({$diagnoses: [{$message : _objName(type) + " - - IndexedDB.Transaction error", $stackTrace: self._eventToMessage(event)}]});
				};
				deferred.resolve(tx.objectStore(_objName(type)));
			} catch (e) {
				_logError('_draftsObjectStore - ' + _objName(type), e);
				deferred.reject(e);
			}
			return deferred.promise();
		},
		/**
		 * type: d for drafts -  w for workingcopies
		 * Resolves with data if record identified by id or null
		 * fail = true to reject if error
		 */
		_draftGetObject: function(type, id, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._draftsObjectStore(type, READ_ONLY).then(function(objectStore) {
				var request = objectStore.get(id);
				request.onsuccess = function(event) {
					try {
						var result = request.result && request.result.data ? JSON.parse(request.result.data) : null;
						deferred.resolve(result);
						log && log("_draftGetObject - " + _objName(type), "OK");
					} catch (e) {
						log && log("_draftGetObject - " + _objName(type), "Error parsing data");
						if (fail) {
							deferred.reject({
								$diagnoses: [{
									$message: "_draftGetObject - " + _objName(type) + " - Error parsing data"
								}]
							});
						} else {
							deferred.resolve(null);
						}
					}
				};
				request.onerror = function(event) {
					_logError("_draftGetObject - " + _objName(type), event);
					if (fail) {
						deferred.reject({
							$diagnoses: [{
								$message: _objName(type) + " - IndexedDB.OpenCursor error",
								$stackTrace: self._eventToMessage(event)
							}]
						});
					} else {
						deferred.resolve(null);
					}
				};
			}).fail(function(e) {
				if (fail) {
					deferred.reject(e);
				} else {
					deferred.resolve(null);
				}
			});
			return deferred.promise();
		},
		/**
		 * type: d for drafts -  w for workingcopies
		 * Resolves with and array of all records or []
		 * fail = true to reject if error
		 */
		_draftGetAllObjects: function(type, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._draftsObjectStore(type, READ_ONLY).then(function(objectStore) {
				// objectStore.getAll not implemented in FF
				var request = objectStore.openCursor();
				var result = [],
					data;
				request.onsuccess = function(event) {
					var cursor = event.target.result;
					if (cursor) {
						try {
							data = cursor.value && cursor.value.data ? JSON.parse(cursor.value.data) : null;
							if (data) {
								result.push(data);
							}
						} catch (e) {
							log && log("_draftGetAllObjects - " + _objName(type), "Error parsing data");
						}
						cursor.continue();
					} else {
						log && log("_draftGetAllObjects - " + _objName(type), "OK");
						deferred.resolve(result);
					}
				};
				request.onerror = function(event) {
					_logError("_draftGetAllObjects - " + _objName(type), event);
					if (fail) {
						deferred.reject({
							$diagnoses: [{
								$message: _objName(type) + " - IndexedDB.openCursor error",
								$stackTrace: self._eventToMessage(event)
							}]
						});
					} else {
						deferred.resolve([]);
					}
				};
			}).fail(function(e) {
				if (fail) {
					deferred.reject(e);
				} else {
					deferred.resolve([]);
				}
			});
			return deferred.promise();
		},
		/**
		 * type: d for drafts - w for workingcopies
		 * Create a record of update the existing one if any
		 * Resolves with data  and true if record has been created
		 * fail = true to reject if error
		 */
		_draftPutObject: function(type, id, data, fail) {
			var self = this;
			var deferred = $.Deferred();
			if (!data || !id) {
				_logError("_draftPutObject - " + _objName(type), "Invalid parameters");
				if (fail) {
					deferred.reject({
						$diagnoses: [{
							$message: "_draftPutObject - " + _objName(type) + " - Invalid parameters"
						}]
					});
				} else {
					deferred.resolve(null);
				}
			} else {
				self._draftsObjectStore(type, READ_WRITE).then(function(objectStore) {
					var _put = function(created) {
						var request = objectStore.put({
							"id": id,
							"data": JSON.stringify(data),
							"creation_date": utils.getCurISODateTime(new Date())
						});
						request.onsuccess = function(event) {
							log && log("_draftPutObject - " + _objName(type), "OK");
							deferred.resolve(data, created);
						};
						request.onerror = function(event) {
							_logError("_draftPutObject - " + _objName(type), event);
							if (fail) {
								deferred.reject({
									$diagnoses: [{
										$message: _objName(type) + " - IndexedDB.put error",
										$stackTrace: self._eventToMessage(event)
									}]
								});
							} else {
								deferred.resolve(null);
							}
						};
					};
					// Just to return created or updated
					var request = objectStore.get(id);
					request.onsuccess = function(event) {
						_put(true);
					};
					request.onerror = function(event) {
						_put(false);
					};
				}).fail(function(e) {
					if (fail) {
						deferred.reject(e);
					} else {
						deferred.resolve(null);
					}
				});
			}
			return deferred.promise();
		},
		/**
		 * type: d for drafts - w for workingcopies
		 * Delete a record if any
		 * Resolves with true (deleted) or false (no record deleted)
		 * fail = true to reject if error
		 */
		_draftDeleteObject: function(type, id, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._draftsObjectStore(type, READ_WRITE).then(function(objectStore) {
				var request = objectStore["delete"](id);
				request.onsuccess = function(event) {
					log && log("_draftDeleteObject - " + _objName(type), "OK");
					deferred.resolve(true);
				};
				request.onerror = function(event) {
					_logError("_draftDeleteObject - " + _objName(type), event);
					if (fail) {
						deferred.reject({
							$diagnoses: [{
								$message: _objName(type) + " -  IndexedDB.delete error",
								$stackTrace: self._eventToMessage(event)
							}]
						});
					} else {
						deferred.resolve(false);
					}
				};
			}).fail(function(e) {
				if (fail) {
					deferred.reject(e);
				} else {
					deferred.resolve(false);
				}
			});
			return deferred.promise();
		},
		/**
		 * type: d for drafts - w for workingcopies
		 * Delete all records
		 * Resolves with true (deleted) or false (no record deleted)
		 * fail = true to reject if error
		 */
		_draftDeleteAllObjects: function(type, id, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._draftsObjectStore(type, READ_WRITE).then(function(objectStore) {
				var request = objectStore.clear();
				request.onsuccess = function(event) {
					log && log("_draftDeleteAllObjects" + _objName(type), "OK");
					deferred.resolve(true);
				};
				request.onerror = function(event) {
					_logError("_draftDeleteAllObjects" + _objName(type), event);
					if (fail) {
						deferred.reject({
							$diagnoses: [{
								$message: _objName(type) + " -  IndexedDB.clear error",
								$stackTrace: self._eventToMessage(event)
							}]
						});
					} else {
						deferred.resolve(false);
					}
				};
			}).fail(function(e) {
				if (fail) {
					deferred.reject(e);
				} else {
					deferred.resolve(false);
				}
			});
			return deferred.promise();
		},
		/**
		 * type: d for drafts - w for workingcopies
		 * Count all records
		 * Resolves with count
		 * fail = true to reject if error
		 */
		_draftCountAllObjects: function(type, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._draftsObjectStore(type, READ_ONLY).then(function(objectStore) {
				var request = objectStore.count();
				request.onsuccess = function(event) {
					log && log("_draftCountAllObjects" + _objName(type), "OK", request.result);
					deferred.resolve(request.result);
				};
				request.onerror = function(event) {
					_logError("_draftCountAllObjects" + _objName(type), event);
					if (fail) {
						deferred.reject({
							$diagnoses: [{
								$message: _objName(type) + " -  IndexedDB.count error",
								$stackTrace: self._eventToMessage(event)
							}]
						});
					} else {
						deferred.resolve(0);
					}
				};
			}).fail(function(e) {
				if (fail) {
					deferred.reject(e);
				} else {
					deferred.resolve(0);
				}
			});
			return deferred.promise();
		},
		/**
		 * Resolve with data/null
		 */
		_wrkcpyRead: function(id) {
			return this._draftGetObject("w", id, false);
		},
		/**
		 * Resolve with  true/false
		 * Delete all the working copies that belong to transaction_id
		 */
		_wrkcpyDelete: function(id) {
			return this._draftDeleteObject("w", id, false);
		},
		/**
		 * Resolve with true/false
		 */
		_wrkcpyDeleteAll: function() {
			return this._draftDeleteAllObjects("w", false);
		},
		/**
		 * Resolve with dataSet/null
		 */
		_wrkcpyUpdate: function(dataSet) {
			if (!dataSet) {
				return $.smResolve(null);
			}
			return this._draftPutObject("w", dataSet.$uuid, dataSet, false);
		},
		_wrkcpyCreate: function(dataSet) {
			return this._wrkcpyUpdate(dataSet);
		},
		/**
		 * Resolve with [resources]/[]
		 */
		_draftReadList: function() {
			return this._draftGetAllObjects("d", false);
		},
		/**
		 * Resolve with data/null
		 */
		_draftRead: function(id) {
			return this._draftGetObject("d", id, false);
		},
		/**
		 * Resolve with  true/false
		 */
		_draftDelete: function(id) {
			var self = this;
			return self._draftDeleteObject("d", id, false).then(function(result) {
				self._draftNotifyChanged();
				return result;
			});
		},
		/**
		 * Resolve with true/false
		 */
		_draftDeleteAll: function() {
			var self = this;
			return self._deleteAllObject("d", false).then(function(result) {
				self._draftNotifyChanged();
				return result;
			});
		},
		/**
		 * Resolve with draft context or reject with an exception
		 */
		_draftSave: function(ctx) {
			if (!ctx) {
				return $.smResolve(null);
			}
			var self = this;
			return self._draftPutObject("d", ctx.id, ctx, false).then(function(data, created) {
				if (created) {
					self._draftNotifyChanged();
				}
				return data;
			});
		},
		_draftCount: function(notify) {
			return this._draftCountAllObjects("d", false).then(function(count) {
				if (notify) {
					notifications.publish("sm.drafts.changed", count);
				}
				return count;
			});
		},
		/**
		 * Notifies to update the number of draft in 'List of draft' menu item
		 */
		_draftNotifyChanged: function() {
			return this._draftCount(true);
		},
		/**
		 * Drafts
		 * op: Operation
		 * 		save
		 * 			args(1) create true/false
		 * 		read
		 * 		query
		 * 		delete
		 * 		switchStatus
		 */
		draftOperation: function(op) {
			switch (op) {
				case "wrkcpyUpdate":
					return this._wrkcpyUpdate(arguments[1]);
				case "wrkcpyRead":
					return this._wrkcpyRead(arguments[1]);
				case "wrkcpyDelete":
					return this._wrkcpyDelete(arguments[1]);
				case "wrkcpyCreate":
					return this._wrkcpyCreate(arguments[1], arguments[2]);
				case "wrkcpyDeleteAll":
					return this._wrkcpyDeleteAll(arguments[1]);
				case "draftSave":
					return this._draftSave(arguments[1]);
				case "draftDelete":
					return this._draftDelete(arguments[1]);
				case "draftDeleteAll":
					return this._draftDeleteAll();
				case "draftRead":
					return this._draftRead(arguments[1]);
				case "draftReadList":
					return this._draftReadList();
				case "draftCount":
					return this._draftCount(false);
				case "draftNotifyChanged":
					var self = this;
					setTimeout(function() {
						self._draftNotifyChanged();
					});
					return;
				default:
					return $.smReject(storageInterface.buildErrResult("Unknown Draft operation[" + op + "]"));
			}
		}
	}
);
});

define('syracuse-tablet/html/js/storage/storageIndexedDBTemplates',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/storage/storageIndexedDBDrafts','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var Base = require('syracuse-tablet/html/js/storage/storageIndexedDBDrafts').Klass;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("templates", false);

var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
var IDBDatabaseException = window.IDBDatabaseException || window.webkitIDBDatabaseException;

var READ_ONLY = (IDBTransaction && IDBTransaction.READ_ONLY) || "readonly";
var READ_WRITE = (IDBTransaction && IDBTransaction.READ_WRITE) || "readwrite";


var _objectStores = {
	"edittemplates": {
		"options": {
			"keyPath": "id",
			"autoIncrement": true
		},
		"indexes": {
			"repandep": {
				"key": ["representation", "endpoint"],
				"options": {
					"unique": false
				}
			}
		}
	}
};

var _logError = function(who, e) {
	if (!log) return;
	log("INDEXED DB - ERROR");
	for (var i = 0; i < arguments.length; i++) {
		var e = arguments[i];
		if (typeof e === "string") {
			log(e);
			continue;
		}
		if (e && e.target) {
			if (IDBDatabaseException && e.target.errorCode != IDBDatabaseException.NOT_FOUND_ERR) {
				log(JSON.stringify(e, null, 2));
				continue;
			}
		}
		log(JSON.stringify(jsutils.convertToDiagnoses(e), null, 2));
	}
};

exports.Klass = utils.defineClass(
	function() {
		Base.call(this);
	},
	Base, {
		/** Overridden method */
		getObjectStores: function() {
			return $.extend(Base.prototype.getObjectStores.call(this), _objectStores);
		},

		/** !! Methods below are private - Use a dedicated name specific to the class - Not shared with drafts or sdata*/
		_tmplOnError: function(deferred, event, fail, value, caller) {
			_logError(caller, event);
			if (fail) {
				deferred.reject({
					$diagnoses: [{
						$message: "IndexedDB Error - " + caller,
						$stackTrace: this._eventToMessage(event)
					}]
				});
			} else {
				deferred.resolve(value);
			}
		},
		_tmplOnExcep: function(deferred, fail, e, value) {
			if (fail) {
				deferred.reject(e);
			} else {
				deferred.resolve(value);
			}
		},
		/**
		 * Resolves with object store or rejects
		 */
		_tmplObjectStore: function(readOpt) {
			var self = this;
			var deferred = $.Deferred();
			try {
				var tx = self.db.transaction("edittemplates", readOpt || READ_WRITE);
				tx.oncomplete = function(event) {
					log && log("tx.oncomplete", JSON.stringify(event, null, 2));
				};
				tx.onerror = function(event) {
					log && log("tx.onerror", JSON.stringify(event, null, 2));
				};
				deferred.resolve(tx.objectStore("edittemplates"));
			} catch (e) {
				_logError('_tmplObjectStore', e);
				deferred.reject(e);
			}
			return deferred.promise();
		},
		/**
		 * Resolves with data if record identified by id or null
		 * fail = true to reject if error
		 */
		_tmplGetObject: function(id, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._tmplObjectStore(READ_ONLY).then(function(objectStore) {
				var request = objectStore.get(id);
				request.onsuccess = function(event) {
					deferred.resolve(request.result);
				};
				request.onerror = function(event) {
					self._tmplOnError(deferred, event, fail, null, "_tmplGetObject");
				};
			}).fail(function(e) {
				self._tmplOnExcep(deferred, fail, e, null);
			});
			return deferred.promise();
		},
		/**
		 * Resolves with and array of all records or []
		 * fail = true to reject if error
		 */
		_tmplGetAllObjects: function(fail, filter) {
			var self = this;
			var deferred = $.Deferred();
			self._tmplObjectStore(READ_ONLY).then(function(objectStore) {
				var request = objectStore.openCursor();
				var result = [],
					data;
				request.onsuccess = function(event) {
					var cursor = event.target.result;
					if (cursor) {
						if (cursor.value && (filter == null || filter(cursor.value) === true)) {
							result.push(cursor.value);
						}
						cursor.continue();
					} else {
						deferred.resolve(result);
					}
				};
				request.onerror = function(event) {
					self._tmplOnError(deferred, event, fail, [], "_tmplGetAllObjects");
				};
			}).fail(function(e) {
				self._tmplOnExcep(deferred, fail, e, []);
			});
			return deferred.promise();
		},
		/**
		 * Create a record of update the existing one if any
		 * Resolves with data  and true if record has been created
		 * fail = true to reject if error
		 */
		_tmplPutObject: function(data, updateDate, fail) {
			var self = this;
			var deferred = $.Deferred();
			if (!data || !data.id) {
				if (fail) {
					deferred.reject({
						$diagnoses: [{
							$message: "_tmplPutObject - Invalid parameters"
						}]
					});
				} else {
					deferred.resolve(null);
				}
			} else {
				var id = data.id;
				self._tmplObjectStore(READ_WRITE).then(function(objectStore) {
					var _put = function(created) {
						data = $.extend(true, {}, data);
						if (data["creation_date"] == null || updateDate) {
							data["creation_date"] = utils.getCurISODateTime(new Date());
						}
						var request = objectStore.put(data);
						request.onsuccess = function(event) {
							deferred.resolve(data, created);
						};
						request.onerror = function(event) {
							self._tmplOnError(deferred, event, fail, null, "_tmplPutObject");
						};
					};
					// Just to return created or updated
					var request = objectStore.get(id);
					request.onsuccess = function(event) {
						_put(true);
					};
					request.onerror = function(event) {
						_put(false);
					};
				}).fail(function(e) {
					self._tmplOnExcep(deferred, fail, e, null);
				});
			}
			return deferred.promise();
		},
		/**
		 * Delete a record if any
		 * Resolves with true (deleted) or false (no record deleted)
		 * fail = true to reject if error
		 */
		_tmplDeleteObject: function(id, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._tmplObjectStore(READ_WRITE).then(function(objectStore) {
				var request = objectStore["delete"](id);
				request.onsuccess = function(event) {
					deferred.resolve(true);
				};
				request.onerror = function(event) {
					self._tmplOnError(deferred, event, fail, false, "_tmplDeleteObject");
				};
			}).fail(function(e) {
				self._tmplOnExcep(deferred, fail, e, false);
			});
			return deferred.promise();
		},
		/**
		 * Delete all records
		 * Resolves with true (deleted) or false (no record deleted)
		 * fail = true to reject if error
		 */
		_tmplDeleteAllObjects: function(id, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._tmplObjectStore(READ_WRITE).then(function(objectStore) {
				var request = objectStore.clear();
				request.onsuccess = function(event) {
					deferred.resolve(true);
				};
				request.onerror = function(event) {
					self._tmplOnError(deferred, event, fail, false, "_tmplDeleteAllObjects");
				};
			}).fail(function(e) {
				self._tmplOnExcep(deferred, fail, e, false);
			});
			return deferred.promise();
		},
		/**
		 * Count all records
		 * Resolves with count
		 * fail = true to reject if error
		 */
		_tmplCountAllObjects: function(fail) {
			var self = this;
			var deferred = $.Deferred();
			self._tmplObjectStore(READ_ONLY).then(function(objectStore) {
				var request = objectStore.count();
				request.onsuccess = function(event) {
					deferred.resolve(request.result);
				};
				request.onerror = function(event) {
					self._tmplOnError(deferred, event, fail, 0, "_tmplCountAllObjects");
				};
			}).fail(function(e) {
				self._tmplOnExcep(deferred, fail, e, 0);
			});
			return deferred.promise();
		},
		_tmplReadInfo: function(data) {
			if (!data) return null;
			try {
				return {
					"id": data.id,
					"endpoint": data.endpoint || "",
					"representation": data.representation || "",
					"title": data.title || "",
					"dataSet": data.dataSet,
					"creation_date": data["creation_date"]
				};
			} catch (e) {
				log && log("_tmplReadInfo", "KO", data.id);
				return null;
			}
		},
		/**
		 * Resolve with [resources]/[] or reject with a exception
		 * Not supported by IE
		 */
		_tmplQueryWidthCompoundIndex: function(representation, endpoint, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._tmplObjectStore(READ_ONLY).then(function(objectStore) {
				var request;
				if (representation || endpoint) {
					var index = objectStore.index('repandep');
					request = index.openCursor(IDBKeyRange.only([representation, endpoint]));
				} else {
					request = objectStore.openCursor();
				}
				var result = [],
					data;
				request.onsuccess = function(event) {
					var cursor = event.target.result;
					if (cursor && cursor.value) {
						result.push(cursor.value);
						cursor.continue();
					} else {
						log && log("_tmplQuery - OK");
						deferred.resolve(result);
					}
				};
				request.onerror = function(event) {
					self._tmplOnError(deferred, event, fail, [], "_tmplGetAllObjects");
				};
			}).fail(function(e) {
				self._tmplOnExcep(deferred, fail, e, []);
			});
			return deferred.promise();
		},
		/**
		 * Resolve with [resources]/[] or reject with a exception
		 */
		_tmplQuery: function(representation, endpoint, fail) {
			return this._tmplGetAllObjects(fail, function(value) {
				if (representation != null && representation != value.representation) return false;
				if (endpoint != null && endpoint != value.endpoint) return false;
				return true;
			});
		},
		/**
		 * Resolve with data/null or reject with a exception
		 */
		_tmplRead: function(id) {
			return this._tmplGetObject(id, false);
		},
		/**
		 * Resolve or reject with a exception
		 */
		_tmplUpdate: function(id, ctx) {
			var self = this;
			return self._tmplRead(id).then(function(result) {
				if (!result || !ctx) return;
				return self._tmplSave($.extend(result, ctx), false);
			});
		},
		/**
		 * Resolve or reject with a exception
		 */
		_tmplDelete: function(id) {
			return this._tmplDeleteObject(id, false);
		},
		/**
		 * Resolve or reject with a exception
		 */
		_tmplDeleteAll: function() {
			return this._tmplDeleteAllObjects(false);
		},
		/**
		 * Resolve with template context or reject with an exception
		 */
		_tmplSave: function(ctx, updateDate) {
			var self = this;
			var deferred = $.Deferred();
			if (!ctx || !ctx.id) {
				log && log("_tmplSave error", "Invalid parameters");
				deferred.reject(new Error("Invalid parameters"));
			} else {
				self._tmplDelete(ctx.id).then(function() {
					return self._tmplPutObject(ctx, updateDate, false);
				}).then(function() {
					log && log("_tmplSave", ctx.id, "OK");
					deferred.resolve(ctx);
				}).fail(function(status) {
					_logError("_tmplSave", status);
					deferred.reject(status.$exception || new Error(status.message));
				});
			}
			return deferred.promise();
		},
		_tmplCount: function() {
			return this._tmplCountAllObjects();
		},
		templateOperation: function(op) {
			switch (op) {
				case "save":
					return this._tmplSave(arguments[1], true);
				case "delete":
					return this._tmplDelete(arguments[1]);
				case "deleteAll":
					return this._tmplDeleteAll(arguments[1], arguments[2]);
				case "read":
					return this._tmplRead(arguments[1]);
				case "update":
					return this._tmplUpdate(arguments[1], arguments[2]);
				case "query":
					return this._tmplQuery(arguments[1], arguments[2], arguments[3]);
				case "readall":
					return this._tmplQuery(arguments[1]);
				case "count":
					return this._tmplCount();
				default:
					return $.smReject(storageInterface.buildErrResult("Unknown template operation[" + op + "]"));
			}
		}
	});
});

define('syracuse-tablet/html/js/storage/storageIndexedDB',['require','exports','module','syracuse-tablet/html/js/storage/storageIndexedDBTemplates'],function (require, exports, module) {

/*
 * IndexDB storage interface (Internet Explorer, Firefox)
 */

/**
 * The top class is storageIndexedDBTemplates
 * It's just a trick to split the code that manages Templates/Drafts from the one that manages SDtata in 3 sub classes of storageIndexedDBBase
 */
var _storageInterface = require('syracuse-tablet/html/js/storage/storageIndexedDBTemplates').Klass;


exports.getStorageInterface = function() {
	return _storageInterface;
};
exports.isAvailable = function() {
	var indexedDB = window.indexedDB || window.webkitIndexedDB;
	return indexedDB != null;
};
});

define('syracuse-tablet/html/js/storage/storage',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/storage/storageWebSQL','syracuse-tablet/html/js/storage/storageIndexedDB'],function (require, exports, module) {


var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("storage", false);

/*
 * Storage module (Selects implementation depending on what's available in the current browser
 */

var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var _modules = {
	"webSQL": require('syracuse-tablet/html/js/storage/storageWebSQL'),
	"indexedDB": require('syracuse-tablet/html/js/storage/storageIndexedDB')
};
var _impls = [
	"webSQL",
	"indexedDB"
];

var _storageImpl;

// Choose the first supported storage engine
// #8136 noFail used in main error handler 
function _getStorageImpl(noFail) {
	if (_storageImpl) {
		return _storageImpl;
	}

	_impls.some(function(impl) {
		impl = _modules[impl];
		if (impl.isAvailable()) {
			var ctor = impl.getStorageInterface();
			_storageImpl = new ctor();
			return true;
		}
		return false;
	});

	if (_storageImpl == null && noFail !== true) {
		throw new Error("No storage interface (indexedDB or WebSQL) has been found");
	}

	return _storageImpl;
}

exports.getStorage = _getStorageImpl;
exports.StatusCodes = storageInterface.StatusCodes;
exports.init = function(supportedDB) {
	if (supportedDB == null) {
		// Regular process
		_getStorageImpl();
	} else {
		log && log("Force supported DB=" + supportedDB);
		// Force supportedDB
		var impl = _modules[supportedDB];
		if (impl && impl.isAvailable()) {
			var ctor = impl.getStorageInterface();
			_storageImpl = new ctor();
		} else {
			throw new Error("Storage interface (" + supportedDB + ") is not supported");
		}
	}

	log && log("DATABASE=" + _storageImpl.infoString);
	return _storageImpl.init();
};
});

define('syracuse-tablet/html/js/sdata/cache/metaDataCache',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/common/ajax','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/sdata/protocolHelpers','syracuse-tablet/html/js/storage/storage','syracuse-tablet/html/js/utils/waiting','syracuse-tablet/html/js/storage/localStorage'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("metaData", false);

var ajax = require('syracuse-tablet/html/js/common/ajax');
var modules = require('syracuse-tablet/html/js/common/modules');
var protocolHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');
var storageModule = require('syracuse-tablet/html/js/storage/storage');
var waiting = require('syracuse-tablet/html/js/utils/waiting');

var localStorage = require('syracuse-tablet/html/js/storage/localStorage');

var _storage;

// Stores apps we read from the cache so we do not need to ask the database all time
// Also, all what is in this array is assumed to be up to date with remote version
// Whenever this is emptied there will be a new version comparison with the server this happens usually
// on user profile change or when browser reloads the full app
var _cachedAppVersions = {};

function _alwaysUpdateApps() {
	return localStorage.getItem("alwaysUpdateChecked") === "true";
}

function _getStorage() {
	if (!_storage) {
		_storage = modules.get("storage").getStorage();
	}
	return _storage;
}

function _getMetaDataContext() {
	return modules.get("appController").App.getCacheContext();
}

function _getMetaData(metaType, endpoint, key) {
	return _getStorage().read({
		$context: _getMetaDataContext(),
		$collection: "$meta_" + metaType,
		$endpoint: endpoint,
		$key: key
	}).then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			return result.$data;
		} else {
			return null;
		}
	});
}

function _putMetaData(metaType, endpoint, key, data) {
	return _getStorage().put({
		$context: _getMetaDataContext(),
		$collection: "$meta_" + metaType,
		$endpoint: endpoint,
		$key: key,
		$data: data
	});
}

exports.clearCachedApps = function() {
	log && log("clearCachedApps");
	_cachedAppVersions = {};
}


/**
 * Return application header informations or null
 */
exports.tryGetApp = function(appName, endpoint) {
	log && log("Try get app: " + appName + " on " + endpoint);

	var name = endpoint + "." + appName;
	var appInMemory = _cachedAppVersions[name];
	if (appInMemory) {
		log && log("In memory app: " + appName + " on " + endpoint);
		return $.smResolve(appInMemory);
	}
	return $.smResolve()
		.then(function() {
			return _getMetaData("appHeader", "$local", name);
		})
		.then(function(appData) {
			log && log("App in cache: " + (appData !== null));
			if (appData) {
				delete appData.$isUpToDate; // Ensure to check with remote next time
				_cachedAppVersions[name] = appData;
			} else {
				delete _cachedAppVersions[name];
			}
			return appData;
		});
};

/**
 * Check if app is up to date with server version -> true or false if not up to date
 * When offline, the app is assumed to be up to date -> true
 */
exports.isAppUpToDate = function(appData, endpoint) {
	log && log("isAppUpToDate: " + appData.versionNumber);
	var url = protocolHelpers.getMobileAppUrl(appData.applicationName);
	var appDataRemote;

	var name = endpoint + "." + appData.applicationName;
	// Usually app header is in memory already, this is just for safety
	var appInMemory = _cachedAppVersions[name] = _cachedAppVersions[name] || appData;
	if (appInMemory.$isUpToDate) {
		return $.smResolve(true);
	}

	var d = $.Deferred();
	log && log("Check app up to date: " + appData.applicationName);
	ajax.request(url)
		.fail(function(result) {
			if (result.offline) {
				log && log("Offline, assume up to date");
				d.resolve(true); // If we are offline, we assume the app is up to date
			} else {
				d.reject(result); // Critical error
			}
		})
		.then(function(result) {
			appDataRemote = result.data;
		})
		.then(function() {
			log && log("Local version: " + appData.versionNumber);
			log && log("Remote version: " + appDataRemote.versionNumber);
			if (appDataRemote.versionNumber === appData.versionNumber) {
				// We push the remote version to memory since also it's up to date, there may be a newer article included 
				appInMemory = _cachedAppVersions[name] = appDataRemote;
				appInMemory.$isUpToDate = true;
				if (_alwaysUpdateApps()) {
					log && log("Update forced by development flag");
					d.resolve(false);
				} else {
					d.resolve(true);
				}
			} else {
				appInMemory.$isUpToDate = false;
				d.resolve(false);
			}
		});

	return d.promise();
};

/**
 * Fetches meta data for given app from the server and put's it into the local storage
 */
exports.installApp = function(appName, endpoint) {
	var url = protocolHelpers.getMobileAppUrl(appName);

	// Note: If an app is declared as onle only, this service operation will return the header only and all
	// prototype information is fetched on demand
	var appMetaDataUrl = url + "/$service/applicationMetaData?endpoint=" + endpoint;
	var appData;

	log && log("Installing app: " + appName);
	var install = $.smResolve()
		.then(function() {
			log && log("Fetching meta data: " + appName);
			return ajax.request(appMetaDataUrl);
		})
		.then(function(result) {
			appData = result.data;

			// Save header information
			log && log("Saving header: " + appName + " on " + endpoint + " Mode: " + (appData.$application.onlineOnly ? "workingcopy" : "stateless"));
			return _putMetaData("appHeader", "$local", endpoint + "." + appName, appData.$application);
		})
		.then(function() {
			// save pages
			var $pages = appData.$pages || {};
			return $.smForEachPromise(Object.keys($pages), function(page) {
				var $page = $pages[page].$page;

				var article = $page.$article;
				var views = $page.$views;
				var prototype = $page.$prototype;

				return $.smResolve()
					.then(function() {
						if (article) {
							log && log("Saving page: " + page);
							return _putMetaData("page", "$local", page, {
								$article: article,
								$views: views
							});
						}
					})
					.then(function() {
						if (prototype) {
							delete prototype.$article; // We do not need this, so delete before storing to save some space
							log && log("Saving prototype: " + page);
							return _putMetaData("prototype", "$local", page, prototype);
						}
					});
			});
		})
		.then(function() {
			var $dashboards = appData.$dashboards || {};
			return $.smForEachPromise(Object.keys($dashboards), function(dashboard) {
				var $dashboard = $dashboards[dashboard];
				return $.smResolve()
					.then(function() {
						log && log("Saving dashboard: " + dashboard);
						return _putMetaData("dashboard", "$local", dashboard, $dashboard);
					});
			});
		})
		.then(function() {
			var appHeader = appData.$application;
			var name = endpoint + "." + appHeader.applicationName;
			log && log("Saving header: " + name + " Version: " + appHeader.versionNumber);

			appHeader.$isUpToDate = true;
			_cachedAppVersions[name] = appHeader;

			return _putMetaData("appHeader", "$local", name, appHeader);
		});

	return waiting.waitModal(install);
}

exports.getPage = function(pageName) {
	log && log("Read meta data (page): " + pageName);
	return _getMetaData("page", "$local", pageName)
		.then(function(page) {
			if (page) {
				log && log("Cache hit");
				return page;
			}
			log && log("Cache miss");
		});
}

exports.getPrototype = function(prototypeName) {
	log && log("Read meta data (prototype): " + prototypeName);
	return _getMetaData("prototype", "$local", prototypeName)
		.then(function(proto) {
			if (proto) {
				log && log("Cache hit");
				return proto;
			}
			log && log("Cache miss");
		});
}
exports.initApplicationsList = function() {
	var self = this;
	return ajax.request("/sdata/syracuse/collaboration/syracuse/mobileApplications/$service/availableApplications")
		.then(function(result) {
			if (result.data) {
				return _putMetaData("applications", "$local", "$applications", result.data.$resources);
			} else {
				throw new Error("Empty applications list");
			}
		})
}
exports.getApplicationsList = function() {
	log && log("Read meta data (applications list): ");
	return _getMetaData("applications", "$local", "$applications")
		.then(function(appList) {
			if (appList) {
				log && log("Cache hit");
				return appList;
			}
			log && log("Cache miss");
		});
}
exports.getDashboard = function(dashboardName) {
	log && log("Read meta data (dashboard): " + dashboardName);
}

exports.putArticle = function(page, article, views) {
	return _putMetaData("page", "$local", page, {
		$article: article,
		$views: views
	});
}
});

define('syracuse-tablet/html/js/helpers/sharedContext',['require','exports','module','syracuse-tablet/html/js/common/ajax','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {

var ajax = require('syracuse-tablet/html/js/common/ajax');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

var defaultLifeSpan = 10 * 24; // hrs to keep context in database

exports.storeSharedContext = function(context) {
	return ajax.request(
			"/sdata/syracuse/collaboration/syracuse/mobileSharedContexts?representation=mobileSharedContext.$edit",
			"POST", {
				linkCtx: JSON.stringify(context),
				lifespan: defaultLifeSpan
			}
		)
		.then(function(result) {
			return result.data.$uuid;
		});
}

exports.readSharedContext = function(uuid) {
	var deferred = $.Deferred();
	ajax.request("/sdata/syracuse/collaboration/syracuse/mobileSharedContexts('" + uuid + "')?representation=mobileSharedContext.$details")
		.then(function(result) {
			var data = result.data && result.data.linkCtx;
			var obj = null;
			try {
				obj = data && JSON.parse(data);
			} catch (e) {}

			deferred.resolve(obj);
		})
		.fail(function() {
			deferred.resolve(null);
		});

	return deferred.promise();
}

exports.createContextFromPage = function(page) {
	return {
		$url: page.pageData.$url,
		$method: page.pageData.$method,
		$savedCtx: page.savedCtxCreate()
	};
}

exports.createPageLoadDataFromContext = function(context) {
	return {
		$url: context.$url,
		$method: context.$method,
		pageOptions: {
			savedCtx: context.$savedCtx
		}
	};
}

/*
 *  Returns navigation url for deeplinks with client running in native environment like
 *  contextId://d85034ee-ff85-4ada-8ed6-ee36e72bacc6"
 */
exports.getNavContextUrlByPage = function(page) {
	return $.smResolve()
		.then(function() {
			return exports.createContextFromPage(page)
		})
		.then(function(context) {
			return exports.storeSharedContext(context)
		})
		.then(function(uuid) {
			return "contextId://" + uuid
		});
}

/*
 *  Returns full url for loading the client in the browser like
 *  "http://192.168.66.1:8123/syracuse-tablet/html/index_debug.html?url=contextId%3A%2F%2Fd85034ee-ff85-4ada-8ed6-ee36e72bacc6"
 */
exports.getFullContextUrlByPage = function(page) {
	return $.smResolve()
		.then(function() {
			return exports.createContextFromPage(page)
		})
		.then(function(context) {
			return exports.storeSharedContext(context)
		})
		.then(function(uuid) {
			return _getOpenContextUrl(uuid);
		});
}

/**
 * Returns the url that will contain the current page context to restore (ctx) (links, live tiles...)
 */
function _getOpenContextUrl(ctxUuid) {
	var url = $.extend({}, jsutils.getCurrentUrl());
	if (ctxUuid) {
		if (!url.query) {
			url.query = {};
		}
		url.query.url = "contextId://" + ctxUuid;
	}
	return jsutils.urlToString(url);
};
});

define('syracuse-tablet/html/js/app/navigationHelper',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/utils/waiting','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/helpers/environment','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/common/helpers','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/sdata/protocolHelpers','syracuse-tablet/html/js/sdata/cache/metaDataCache','syracuse-tablet/html/js/helpers/sharedContext'],function (require, exports, module) {

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var waiting = require('syracuse-tablet/html/js/utils/waiting');
var modules = require('syracuse-tablet/html/js/common/modules');
var environment = require('syracuse-tablet/html/js/helpers/environment');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var helpers = require('syracuse-tablet/html/js/common/helpers');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');
var metaDataCache = require('syracuse-tablet/html/js/sdata/cache/metaDataCache');
var sharedContext = require('syracuse-tablet/html/js/helpers/sharedContext');

/**
 * url (sdata): http://localhost:8124/mobile2/x3/erp/GX3APP/TABCUR?representation=TABCURM.$lookup
 * method: GET | SET
 * 
 * pageOptions: {
 *   isChild: ... // Open the page as a child of the current page (this means parent page is not destroyed but hidden in the DOM)
 *   
 *	 lookup: { // When url is a lookup, the control asking for the lookup adds this information so the lookup page can inject the selected value
 *	   controllerId: ...
 *	   controlId: ...
 *	   $bind: Name of property receiving the value picked in the lookup
 *     $lookupKeyName: Name of the property in a lookup item that will used as result
 *	},
 *
 *  childContext: { // For client or "detail" pages like row details or chart detail to give context of the parent
 *  	controllerId
 *  }
 * }
 * 
 * 
 * loadOptions:{
 * 		navStack: Instance of NavigationPageStack to push the page on.
 *           If null, the application's main stack is used
 *			 Setting a non standard stack is used to navigate in vignettes
 * 
 * 		noError: Do not show error modal on page loading issues, should be used by vignettes  
 * 		firstPage: true if the application is trying to open a dedicated page when  at start (url param in query string) 
 * 		noRedirectOnError: avoid infinite loop in case of error
 * }
 * RESOLVES WITH PAGE OR NULL
 * 
 * 
 * Urls supported:
 * http://.../mobile2/... sdata pages
 * child://pageName sdata based page that fulls depends on the controller of a parent (e.g. row detail)
 * 
 * html://pageName Full client side page
 *
 * contextId://<uuid> Server side stored context identified by uuid
 * context://<contextString> String describing the context of the app (contextString is what is returned by server when using contextId)
 *
 */
exports.gotoUrl = function(url, method, pageOptions, loadOptions) {
	// Only allow one navigation at a time
	loadOptions = loadOptions || {};
	var navStack = loadOptions.navStack || modules.get("navStack").getMainStack();

	var changedToBusy = navStack.setBusy(true);
	if (!changedToBusy) {
		// There is already a navigation going on
		return $.smResolve(null);
	}

	if (method == null) {
		try {
			var parsedUrl = jsutils.parseURL(url);
			var $method = parsedUrl && parsedUrl.query && parsedUrl.query.$method;
			if ($method) {
				method = $method;
			}
		} catch (e) {
			// ignore
		}
	}

	var deferred = $.Deferred();
	var pageCreateData = {};

	var checkRestoreContext;

	if (url.indexOf("contextId://") === 0) { // server side stored context (for emails, sending links)
		checkRestoreContext = _fetchContext(url.substr(12))
			.then(function(contextPageData) {
				if (!contextPageData) {
					return $.smReject(helpers.createDiag(null, "error", locale.text("invalid.link")));
				}
				url = contextPageData.$url;
				method = contextPageData.$method;
				pageOptions = contextPageData.pageOptions;
				loadOptions = {};
			})
	} else if (url.indexOf("context://") === 0) { // client side stored context for mobile app resume in native environment
		checkRestoreContext = $.smResolve()
			.then(function() {
				var contextPageData;
				try {
					contextPageData = JSON.parse(decodeURIComponent(url.substr(10)));
				} catch (e) {}
				if (!contextPageData) {
					return $.smReject(helpers.createDiag(null, "error", locale.text("invalid.link")));
				}
				url = contextPageData.$url;
				method = contextPageData.$method;
				pageOptions = contextPageData.pageOptions;
				loadOptions = {};
			});
	} else {
		checkRestoreContext = $.smResolve();
	}

	checkRestoreContext.then(function() {
			// Temp: Redirect home to local home dashboard
			if (url.toLowerCase().indexOf("html://home") >= 0) {
				pageCreateData.name = "HOME";
			} else if (url.toLowerCase().indexOf("html://mock") >= 0) {
				url = protoHelpers.getLocalDashboardUrl('MOCK');
				pageCreateData.name = "MOCK";
			} else if (url.indexOf("{$hostPort}") === 0) {
				// Used by unit tests (local)
				url = url.replace("{$hostPort}", protoHelpers.getHostPort());
			}
			// pageCreateData is a simple object that should contain all information
			// that is needed to restore a page on history back or context restore
			pageCreateData.options = $.extend(true, {}, pageOptions);
			pageCreateData.url = url;
			pageCreateData.method = method;

			// Pre check step is there to check if we really want to navigate
			// this can be anything like checking if a mobile app is valid or has to be installed first
			// if precheck returns false, navigation is stopped silently
			return _checkNavigation(url, method);
		})
		.then(function(okToNavigate) {
			if (okToNavigate === true) {
				if (environment.isAutoUITestMode()) {
					environment.getUnitTestMgr().notifPageLoaded("before");
				}
				var loadingPromise = modules.get("pageFactory").createPage(pageCreateData);
				return waiting.waitModal(loadingPromise, loadOptions.$$waitParent)
			} else {
				return null;
			}
		})
		.then(function(newPage) {
			if (!newPage || newPage.destroyed === true) {
				//Page can be destroyed before beeing dislayed (multiple back in dashboards)
				return null;
			}
			return navStack.pushPage(newPage, pageCreateData)
		})
		.then(function(page) {
			if (environment.isAutoUITestMode()) {
				environment.getUnitTestMgr().notifPageLoaded("after", page);
			}
			notifications.publish("sm.navigated.to.page", page);
			deferred.resolve(page)
		})
		.always(function() {
			if (changedToBusy) { // Only set to idle if we set no busy by or self
				navStack.setBusy(false);
			}
		})
		.fail(function(error) {
			if (loadOptions.noError !== true) {
				modules.get("modal")
					.asynchError(null, error)
					.always(function() {
						deferred.resolve(null);
						if (loadOptions.noRedirectOnError == true) {
							return;
						}
						var target = "html://home";
						var pageOptions = {};
						var method = "GET";
						if (error && error.unauthenticated) {
							target = "html://login";
						} else if (loadOptions.firstPage === true) {
							// The url provided can be wrong so we try to go to home dashboard
							// -> Before checking offline
							target = "html://home";
						} else if (error && error.offline) {
							// Avoid blank page
							target = "html://login";
							pageOptions.offline = true;
						} else {
							target = "html://home";
						}
						if (target) {
							// noRedirectOnError to avoid infinite loop if an other error occurs in gotoUrl
							exports.gotoUrl(target, method, pageOptions, {
								noRedirectOnError: true
							});
						}
					})
			} else {
				deferred.reject(error);
			}
		});
	return deferred.promise();

};

/**
 * 
 * @param url
 * @param method
 * @returns
 */
function _checkNavigation(url, method) {
	return $.smResolve()
		.then(function() {
			try {
				var parsed = jsutils.parseURL(url);
				if (parsed && parsed.query) {
					var appName;
					if (parsed.query.representation === "mobileApplication.$details") {
						appName = protoHelpers.getKeyFromUrl(url);
					} else if (parsed.query.$mobileApplication) {
						appName = parsed.query.$mobileApplication;
					}
					var endpoint = parsed.query.$mobileEndpoint;
					if (appName && endpoint) {
						return _checkMobileApplication(appName, endpoint);
					}
				}
			} catch (Exception) {
				return true;
			}
		})
		.then(function(okToNavigate) {

			// Safety bag, when no check occured above, we assume navigation is ok
			if (okToNavigate == null) {
				okToNavigate = true;
			}

			return okToNavigate;
		});
}


function _checkMobileApplication(appName, endpoint) {
	return $.smResolve()
		.then(function() {
			return metaDataCache.tryGetApp(appName, endpoint);
		})
		.then(function(appData) {
			if (appData === null) { // Not installed
				return _installMobileApplication(appName, endpoint);
			} else {
				return _updateMobileApplication(appName, endpoint, appData);
			}
		});
}

function _installMobileApplication(appName, endpoint) {
	var installConfirmed = true;
	return $.smResolve()
		.then(function() {
			if (installConfirmed) {
				return metaDataCache.installApp(appName, endpoint).then(function() {
					return true;
				});
			} else {
				// No install, no navigation
				return false;
			}
		});
}


function _updateMobileApplication(appName, endpoint, appData) {
	var updateConfirmed = true;
	return $.smResolve()
		.then(function() {
			return metaDataCache.isAppUpToDate(appData, endpoint);
		})
		.then(function(isUpToDate) {
			if (isUpToDate) {
				return true;
			}
			if (updateConfirmed) {
				return metaDataCache.installApp(appName, endpoint).then(function() {
					return true;
				});
			} else {
				// No update, still we can navigate to old version
				return true;
			}
		});
}

function _fetchContext(uuid) {
	return sharedContext.readSharedContext(uuid)
		.then(function(context) {
			return context && sharedContext.createPageLoadDataFromContext(context);
		});
}
});

define('syracuse-tablet/html/js/app/navigationPageStack',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/environment','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var environment = require('syracuse-tablet/html/js/helpers/environment');
var modules = require('syracuse-tablet/html/js/common/modules');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _id = 1;
var _stacks = {};
var _mainStack;

/**
 * This class manages a stack of pages and does all what is needed to go back and do cleanups etc
 * There is one stack for the application (the global one) and also one stack per vignette
 *  
 */
var NavigationPageStack = utils.defineClass(function NavigationPageStack($$elmt) {
	this.id = _id++;
	this.$$elmt = $$elmt;
	this.$$elmt.attr("data-nav-stack-id", this.id);

	_stacks[this.id] = this;
	// Unique id of stack items to be able to go back easily
	this._itemId = 1;

	this._pageStack = [];
	this._topPage = null; // Page currently visible
	this._isBusy = false;
}, null, {
	destroy: function() {
		this.$$elmt = null;
		delete _stacks[this.id];
		if (this._pageStack) {
			this._pageStack.forEach(function(page) {
				if (page.page) {
					page.page.destroy();
				}
			})
		}
		this._pageStack = null;
	},

	/**
	 * 
	 */
	getTopPage: function() {
		return this._topPage;
	},
	isEmpty: function() {
		return this.count() == 0;
	},
	count: function() {
		return this._pageStack == null ? 0 : this._pageStack.length;
	},
	/**
	 * Used to aqquire current top level page == page visible to the user
	 */
	_getTopStackItem: function() {
		if (this._pageStack.length > 0) {
			var stackItem = this._pageStack[this._pageStack.length - 1];
			return stackItem;
		}
	},
	/**
	 * Get all items in the stack
	 * Used to show the stack in form of the breadcrumbs for example
	 */
	getStackItems: function() {
		return this._pageStack;
	},

	/**
	 * Go back exactly one page
	 */
	goBack: function() {
		var prevPage = this._getPrevPageInHistory();
		if (prevPage) {
			return this.goBackToId(prevPage.id);
		}
		return $.smResolve();
	},
	/**
	 * Check if going back is possible at the moment
	 */
	canGoBack: function() {
		return this._getPrevPageInHistory() != null;
	},
	_getPrevPageInHistory: function() {
		var prevPage = null;
		var list = this._pageStack.slice();
		list.pop();
		while (!prevPage && list.length > 0) {
			prevPage = list.pop();
			if (prevPage.noHistory) {
				prevPage = null;
			}
		}
		return prevPage;
	},
	_popTopStackItem: function() {
		if (this._pageStack.length > 0) {
			var stackItem = this._pageStack[this._pageStack.length - 1];
			this._pageStack = this._pageStack.slice(0, -1);
			return stackItem;
		}
	},

	/**
	 * Go back to the stack item with the given id
	 */
	goBackToId: function(id) {
		var self = this;
		id = +id;

		function _closeTopPage(stackItem) {
			var close = $.Deferred()

			var page = stackItem.page;

			var deferred = $.Deferred()

			if (page) {
				page.onBackAction(deferred);
			} else {
				deferred.resolve(true);
			}
			var closeAllowed;
			deferred.then(function(_closeAllowed) {
					closeAllowed = _closeAllowed;
					if (!closeAllowed) {
						close.resolve(false);
						return;
					}
					// Remove page from stack
					self._popTopStackItem();
					return $.smResolve()
						.then(function() {
							if (page) {
								return page.hide();
							}
						})
						.then(function() {
							if (page) {
								return page.destroy();
							}
						})
						.then(function() {
							return _checkCurrent();
						});
				})
				.fail(function(e) {
					close.reject(e);
				})
				.then(function() {
					if (closeAllowed) {
						close.resolve(true);
					}
				});

			return close.promise();
		}

		function _checkCurrent() {
			return $.smResolve()
				.then(function() {
					var top = self._getTopStackItem();
					if (top != null && top.id !== id) {
						return _closeTopPage(top);
					} else if (top != null) {
						return self._activateTopPage();
					}
				});
		}

		return _checkCurrent();
	},
	_activateTopPage: function() {
		var self = this;
		var top = self._getTopStackItem();
		var getPage;
		if (top != null) {
			var cached = top.page != null;
			if (cached !== true) {
				getPage = modules.get("pageFactory").createPage(top.pageCreateData)
					.then(function(page) {
						top.page = page;
						return self._renderPage(page);
					});
			} else {
				getPage = $.smResolve(top.page);
			}
			return getPage
				.then(function(page) {
					self._topPage = top.page;
					return top.page.show(cached);
				})
				.then(function() {
					environment.getUnitTestMgr().notifPageLoaded("after", self._topPage);
				});
		} else {
			return $.smReject(locale.text("no.top.page"));
		}
	},
	_renderPage: function(page) {
		var self = this;
		return $.smResolve()
			.then(function() {
				self._topPage = page;

				// Tell the page where it has to render in
				page.set$$container(self.$$elmt);
				return page.build();
			})
			.then(function() {
				if (environment.isAutoUITestMode()) {
					environment.getUnitTestMgr().addPageData(page);
				}
			});
	},

	/**
	 * Push page will push a page to the navigation stack and render the page
	 * The previous page will be hidden (if going to a child page) or destroyed 
	 * 
	 * page: Page to push on the stack
	 * pageCreateData: Date that can be used by page factory to fully restore a previously opened page
	 * RESOLVE WITH the page
	 * 
	 */
	pushPage: function(page, pageCreateData) {
		var self = this;
		var first;
		if (!page) {
			return $.smResolve(null);
		}

		if (page.isRootPage()) {
			this._pageStack.forEach(function(stackItem) {
				if (stackItem.page) {
					stackItem.page.destroy();
				}
			});
			this._pageStack = [];
		}

		var prevStackItem = self._getTopStackItem();
		var prevPage = prevStackItem && prevStackItem.page;

		if (prevPage) {
			if (page.options.isChild) {
				first = $.smResolve()
					.then(function() {
						return prevPage.hide();
					});
			} else {
				first = $.smResolve()
					.then(function() {
						return prevPage.hide();
					})
					.then(function() {
						// Set saved context
						prevStackItem.pageCreateData.options.savedCtx = prevPage.savedCtxCreate();
						prevPage.destroy();
						prevStackItem.page = null; // this ensures page recreation when going back
					});
			}
		} else {
			first = $.smResolve();
		}

		return first
			.then(function() {
				self._itemId = self._itemId + 1;
				var item = {
					id: self._itemId,
					page: page,
					title: page.getPageTitle(),
					pageCreateData: pageCreateData,
					noHistory: page.isNoHistory()
				};
				self._pageStack.push(item);
				if (self.manageBrowserHistory) {
					window.history.pushState(item.id, null, null);
				}
			})
			.then(function() {
				return self._renderPage(page);
			})
			.then(function() {
				return page.show();
			})
			.then(function() {
				return page;
			});
	},

	/**
	 * 
	 */
	replaceCurrentPageData: function(page, callback) {
		var self = this;
		var topItem = self._getTopStackItem();
		topItem.page = page;

		var pageCreateData = topItem.pageCreateData;
		pageCreateData = callback(pageCreateData);
		topItem.pageCreateData = pageCreateData;

		topItem.title = page.getPageTitle();
	},

	setBusy: function(busy) {
		var old = this._isBusy;
		this._isBusy = busy;
		return old !== busy;
	},
	isBusy: function(busy) {
		return this._isBusy;
	},
	filterTopPage: function(filterCb) {
		for (var i = this._pageStack.length - 1; i >= 0; i--) {
			var page = this._pageStack[i] && this._pageStack[i].page;
			if (page && filterCb(page) === true) {
				return page;
			}
		}
	}
});

/**
 * Returns main page stack (full page pages)
 * 
 */
exports.getMainStack = function() {
	if (!_mainStack) {
		_mainStack = exports.getStackForElmt($("#s-m-app-id"));
		_mainStack.manageBrowserHistory = true;
	}
	return _mainStack;
};

/**
 * Returns a page stack by the DOM element the stack is used for
 * 
 */
exports.getStackForElmt = function($$elmt) {
	var id = $$elmt.attr("data-nav-stack-id");
	var stack;
	if (id) {
		stack = _stacks[id];
	}
	if (!stack) {
		stack = new NavigationPageStack($$elmt);
	}

	return stack;
}

/**
 * Go up the DOM and find next matching navigation stack
 */
exports.findClosest = function($$elmt) {
	var $$stack = $$elmt.closest("[data-nav-stack-id]");
	var id = $$stack.attr("data-nav-stack-id");
	if (id) {
		return _stacks[id];
	}
}
});

define('syracuse-tablet/html/js/sdata/prototype',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/common/helpers'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var helpers = require('syracuse-tablet/html/js/common/helpers');

var Prototype = utils.defineClass(
	function Prototype(json, parent) {
		this.json = json;
		this.parent = parent;
		this.root = (parent && parent.root) || this;
		this._initRefFields();
	},
	null, {
		destroy: function() {
			this.root = null;
			this.parent = null;
			this.json = null;
		},
		propExists: function($bind) {
			return (this.json.$properties && this.json.$properties[$bind]) != null;
		},
		propGetType: function($bind) {
			if (!this.propExists($bind)) {
				return null;
			}
			return this.json.$properties[$bind].$type;
		},
		propGetFormat: function($bind) {
			if (!this.propExists($bind)) {
				return null;
			}
			return this.json.$properties[$bind].$format;
		},
		propGetProto: function($bind) {
			if (!this.propExists($bind)) {
				return null;
			}
			return new Prototype(this.json.$properties[$bind], this);
		},
		propGetProtoItem: function($bind) {
			var $item;
			if (!this.propExists($bind)) {
				// If this is a proto array
				$item = this.json.$item;
			} else {
				$item = this.json.$properties[$bind].$item
			}
			if (!$item) return null;
			return new Prototype($item, this);
		},
		getProto$Item: function($bind) {
			return new Prototype(this.json.$item, this);
		},
		propIsSimple: function($bind) {
			if (!this.propExists($bind)) {
				return null;
			}
			return !this.propIsArray($bind) && !this.propIsReference($bind) && !this.propIsImage($bind) && !this.propIsText($bind) && !this.propIsDocument($bind) && !this.propIsBinary($bind);
		},
		propIsText: function($bind) {
			var t = this.propGetType($bind);
			return t && t.split("/")[0] == "text"
		},
		propIsImage: function($bind) {
			return this.propGetType($bind) === "image";
		},
		propIsArray: function($bind) {
			return this.propGetType($bind) === "application/x-array";
		},
		propIsDocument: function($bind) {
			return this.propGetType($bind) === "application/x-document";
		},
		propIsBinary: function($bind) {
			return this.propGetType($bind) === "application/x-binary";
		},
		propIsSingleArray: function($bind) {
			if (!this.propExists($bind) || !this.propIsArray($bind)) {
				return false;
			}
			/* 
			 * Simple array is identified by either the dedicated type application/x-reference or
			 * any other type that does not supply a $properties list (like integer, decimal, ...)
			 * 
			 * Complex (mulit column arrays) are of type application/json
			 */

			var isSimple = (!this.json.$properties[$bind].$item.$properties || this.json.$properties[$bind].$item.$type === "application/x-reference") ? true : false;
			return isSimple;
		},
		isSingleArray: function() {
			var isSingle = (!this.json.$item.$properties || this.json.$item.$type === "application/x-reference") ? true : false;
			return isSingle;
		},
		/**
		 * Is $bind an x-reference field?
		 */
		propIsReference: function($bind) {
			return this.propGetType($bind) === "application/x-reference";
		},
		isReference: function() {
			return this.json.$type === "application/x-reference";
		},
		/**
		 * true if the given property is used to back up a reference field, 
		 * E.g. CUR_REF is backed up by CUR so will return true for CUR
		 */
		propIsRefValue: function($bind) {
			if (!this.propExists($bind)) {
				return false;
			}
			return (this.json.$properties[$bind].$item && this.json.$properties[$bind].$item.$refPropertyName) != null ? true : false;
		},
		/**
		 * get name of x-reference type property linked to this simple $bind property
		 * Will return "CUR_REF" of type application/x-reference for $bind="CUR" which is type of x-string 
		 */
		propGetRefProperty: function($bind) {
			if (!this.propExists($bind)) {
				return null;
			}
			return this.json.$properties[$bind].$item.$refPropertyName;
		},
		/**
		 * Returns the name of the field that contains the value ($refValue)
		 */
		propGetRefValueName: function($bind) {
			if (!this.propExists($bind)) {
				return null;
			}
			return this.json.$properties[$bind].$item.$refValueName;
		},
		/**
		 * isUrl: Is the repression an url? If yes, expressions like abc={xxx} will be abc=<uri encode xxx>
		 * extraData: Key + value to check for matches first (E.g. $parameters when resolving link urls) 
		 */
		resolveExpression: function(exp, isUrl, extraData) {
			var self = this;
			var rescan = true;
			var max = 20;
			if (exp == null) {
				return exp;
			}
			while (rescan && ((max--) > 0) && exp.replace) {
				rescan = false;
				exp = exp.replace(/\{(\S+?)\}/g, function(m, g1, idx) {
					var value;
					// Encode if we resolve an url that contains something like EXTRA_CODE={EXTRA_CODE} ?
					var encode = isUrl && idx > 0 && exp.charAt(idx - 1) === "=";
					if (extraData && g1 in extraData) {
						value = extraData[g1];
						if (value && value.indexOf && value.indexOf("{") === 0) {
							rescan = true;
						} else if (encode) {
							value = encodeURIComponent(value);
						}
					} else if (g1 in self.json) {
						value = self.json[g1];
						if (value && value.indexOf && value.indexOf("{") === 0) {
							rescan = true;
						} else if (encode) {
							value = encodeURIComponent(value);
						}
					} else if (self.root != self && g1 in self.root.json) {
						value = self.root.json[g1];
						if (value && value.indexOf && value.indexOf("{") === 0) {
							rescan = true;
						} else if (encode) {
							value = encodeURIComponent(value);
						}
					} else if (g1.charAt(0) === "@") {
						// Check on root level for localized texts
						value = (self.root.json.$localization && self.root.json.$localization[g1]);
						if (value === null || value === undefined) {
							value = m;
						}
					} else {
						value = m;
					}
					return value;
				});
			}

			return exp;
		},
		/*
		 * Precompute some additional lookup data for reference fields to be faster during setting/getting values
		 */
		_initRefFields: function() {
			var props = this.json.$properties;
			if (!props) return;
			for (var p in props) {
				if (this.propIsReference(p)) {
					this._initRefField(p);
				}
			}
		},

		/*
		 * Pre-compute the name of the property containing the value of the reference field
		 * Will add some props to $item of reference field prototypes:
		 * 
		 * $refValueName: Name of sibling property containing the reference field key value
		 * $lookupKeyName: Name of the key field in lookup representation
		 * 
		 * Will also add $refPropertyName to the simple property used to back up the reference field
		 */
		_initRefField: function($bind) {
			var proto = this.json.$properties[$bind];
			var $item = proto.$item;
			if (!$item) return;

			$item.$refValueName = $item.$lookupKeyName = $bind;
			if ($item.$value && typeof $item.$value == "string") {
				// $item.$value is s.th. like {CUR}
				var vals = /{([^}]+)}/g.exec($item.$value);
				if (vals && vals.length == 2) {
					var $lookupKeyName = vals[1]; // Key of referenced item (e.g. CODE or CUR, ...)

					$item.$lookupKeyName = $lookupKeyName;

					if ($item[$lookupKeyName]) {
						var $refValueName = $item[$lookupKeyName].replace(/[{}]/g, "").trim();
						if (this.propExists($refValueName) || $item.$properties && $item.$properties[$refValueName]) {
							$item.$refValueName = $refValueName;
						}
					}
					if (!$item.$refValueName) {
						$item.$refValueName = $lookupKeyName;
					}
				} else {
					// Composed key in ref field!
					// TODO: Error?
				}
			}
			if ($item.$refValueName && this.propExists($item.$refValueName)) {
				$item.$refValueType = this.propGetType($item.$refValueName);

				this.json.$properties[$item.$refValueName].$item = this.json.$properties[$item.$refValueName].$item || {};
				// Also link simple type property to $bind reference type property
				this.json.$properties[$item.$refValueName].$item.$refPropertyName = $bind;
			}
			// TODO: precompute auto lookup?
		},
		getFacet: function() {
			var facet = /\.(\$\w+)/.exec(this.json.$type);
			facet = facet && facet.length > 1 && facet[1];
			return facet;
		},
		getType: function() {
			return this.json.$type;
		},
		getValueByPath: function(path, resolve, isUrl, extraData) {
			var val = helpers.getValueByPath(this.json, path);
			if (val != null && resolve) {
				val = this.resolveExpression(val, isUrl, extraData);
			}
			return val;
		},

		/**
		 * Check $type of the value of field $bind
		 * Will use parent prototype if called on the fields sub-prototype
		 */
		getFieldValueType: function($bind) {
			var $properties = this.json.$properties || (this.parent && this.parent.json.$properties);
			if (!$properties) {
				return;
			}
			var prop = $properties[$bind];

			var $type = prop && prop.$type ? prop.$type : "application/x-string";
			if ($type === "application/x-quantity") {
				if (prop.$value) {
					$type = prop.$value.$type;
				}
				$type = $type || "application/x-integer";
			} else if ($type === "application/x-reference") {
				if (prop.$item) {
					$type = prop.$item.$refValueType;
				}
				$type = $type || "application/x-string";
			}
			return $type;
		},
		/**
		 * Get name of simple type field backing up the reference field named by $bind
		 */
		getFieldValueName: function($bind) {
			if (this.propIsReference($bind)) {
				return this.propGetRefValueName($bind);
			}
			return $bind;
		},
		/*for exemple : url to save text*/
		getFieldUpdateUrl: function($bind) {
			var $properties = this.json.$properties || (this.parent && this.parent.json.$properties);
			if (!$properties) {
				return;
			}
			var prop = $properties[$bind];
			return prop.$url;
		},
		createNew: function(json) {
			return new Prototype(json, this);
		},
		/**
		 * Calculates the prototype and other info for unit field
		 */
		getUnitFieldInfo: function() {
			var self = this;
			var res = {};
			res.$unit = self.json["$unit"];
			if (typeof res.$unit == "object") {
				res.unitBindName = "$unit";
				res.unitFieldProto = self.createNew($.extend({}, self.$unit));
			} else if (typeof res.$unit == "string") {
				res.unitBindName = res.$unit;
				var parent = self.parent;
				while (parent) {
					var unitProto = parent.json.$properties[res.$unit];
					if (unitProto) {
						res.unitFieldProto = self.createNew($.extend({}, unitProto));
						break;
					}
					parent = parent.parent;
				}
			}
			return res;
		},
		clone: function() {
			var json = $.extend(true, {}, this.json);
			return new Prototype(json, this.parent);
		},
		/**
		 * return true if arguments contain the facet
		 * Ex: 	isFacet("edit, "detail") return true if edit OR detail
		 * 		isFacet("detail") return true if detail
		 */
		isFacet: function() {
			return Array.prototype.indexOf.call(arguments, this.getFacet()) >= 0;
		},
		/**
		 * Stats prototype
		 */
		isCube: function() {
			if (this._isCube == null) {
				// reads facet in $url like stateless version not in $type
				var p = this;
				while (p != null && this._isCube == null) {
					if (p.json.$url != null && p.json.$url.trim().length != 0) {
						var res = /representation=.*\.\$(\w+)[&]*/.exec(p.json.$url);
						if (res != null && res.length == 2) {
							this._isCube = res[1] == "cube";
						}
					}
					p = p.parent;
				}
				this._isCube = this._isCube == null ? false : this._isCube;
			}
			return this._isCube
		},
		/**
		 * Query prototype
		 */
		isQuery: function() {
			return this.isFacet("$query");
		},
		isWorkingCopyFacet: function() {
			return this.isFacet("$edit") || this.isFacet("$create");
		},
		/**
		 * Lookup prototype
		 */
		isLookup: function() {
			return this.isFacet("$lookup");
		},
		isRequest: function() {
			return this.json.codeRequest != null && this.json.codeRequest.length > 0;
		},
		isStatistics: function() {
			return this.json.codeStat != null && this.json.codeStat.length > 0;
		},
		isQueryLikeFacet: function() {
			return this.isQuery() || this.isLookup() || this.isCube() || this.isRequest();
		},
		isApplication: function() {
			return (this.json.$applicationName && this.json.$applicationName != "");
		},
		/**
		 * returns json[prop]
		 * 	ignoreParent: true -> Don't read property in parent
		 */
		data: function(prop, dataContext, ignoreParent, noResolve) {
			if (!prop || prop.length == 0) return null;
			var val = this.json[prop];
			if (val == null) {
				if (ignoreParent == null) {
					if (["$title", "$description"].indexOf(prop) > -1) {
						ignoreParent = true;
					}
				}
				var pVal = ignoreParent !== true && this.parent ? this.parent.data(prop, dataContext, null, true) : val;
				if (pVal != null) {
					this.json[prop] = pVal;
				}
				return pVal;
			}
			if (noResolve) {
				return val;
			}
			// #5793 we resolve with searchInParents = true -> expression variable will be searched in dataContext and parent
			return this.resolveExpression(val, false, dataContext);
		},
		hasCapability: function(cap) {
			return (this.json.$capabilities && this.json.$capabilities.indexOf(cap) > -1) || false;
		},

		getPropertyNames: function() {
			return this.json.$properties ? Object.keys(this.json.$properties) : [];
		},
		getPropertyData: function(name, prop) {
			if (!name || name.length === 0) return null;
			var o = this.json.$properties && this.json.$properties[name];
			if (!o || !prop) return o;
			return this.resolveExpression(o[prop]);
		},
		chartGetNbMeasures: function() {
			var res = 0;
			var measures = this.getValueByPath("$cube.$measures");
			if (measures) {
				Object.keys(measures).forEach(function(key) {
					res++;
				});
			}
			return res;
		},
		chartGetMeasureInfo: function() {
			var res = {};
			var prop;
			var props = this.getValueByPath("$item.$properties");
			var measures = this.getValueByPath("$cube.$measures");
			if (measures) {
				Object.keys(measures).forEach(function(key) {
					prop = props[key];
					prop.$bind = key;
					res[key] = prop;
				});
			}
			return res;
		},
		getProperties: function(select) {
			var props = this.json.$properties;
			var $properties = [];
			Object.keys(props).forEach(function(v) {
				if (select(props[v], v)) {
					$properties[v] = $.extend(true, {}, props[v], {});
				}
			});
			return $properties;
		}
	}
);

exports.Prototype = Prototype;
});

define('syracuse-tablet/html/js/controllers/controller',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/helpers/native/native'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var modules = require('syracuse-tablet/html/js/common/modules');
var native = require('syracuse-tablet/html/js/helpers/native/native');

var _controllerId = 1;
var _controllers = {};

/**
 * Base class for all controllers
 * Main purpose is to allow all controlls to register with a controller
 * 
 * Specific things like sdata management is in derived classes
 */
exports.Controller = utils.defineClass(
	function Controller(parent) {
		this.id = _controllerId++;
		_controllers[this.id] = this;
		this.uiAdapter = parent ? parent.uiAdapter : null;
		this._controlsById = {};
		this._controlsWithContext = [];
		// This will contain controls that render menu items ($links, $actions or actions (data-param)
		// it's used to apply dynamic meta data on them
		// Will be automatically managed for controls that have a "onMenuItemChanged" method
		this._menuItemContainersById = {};
		this._childrenControllers = {};
		this.parent = parent;
		this.root = (parent && parent.root) || this;
		if (parent) {
			// If parent is destroyed -> Children is destroyed
			parent.registerController(this);
		}
	},
	null, {

		destroy: function() {
			if (this.destroyed === true) {
				return;
			}
			this.destroyed = true;
			delete _controllers[this.id];
			this.root = null;
			if (this._childrenControllers) {
				this.destroyChildren();
				this._childrenControllers = null;
			}
			if (this.parent) {
				this.parent.unregisterController(this);
				this.parent = null;
			}
			/**
			 * Destroy all controls
			 * Controls are also destroyed and unregistered from controller when we destroy the parent in tree structure
			 * So it's mandatory to destroy the control here in case :
			 * -> there are remaining controls
			 * -> the controller is destroyed without having destroyed the tree structure
			 */
			if (this._controlsById) {
				this.forEachControl(function(c) {
					c.destroy();
				});
			}
			this._controlsById = null;
			this._menuItemContainersById = null;
			this._controlsWithContext = null;
			this.uiAdapter = null;
		},
		/**
		 * Destroy children controllers
		 * Called also by other modules
		 */
		destroyChildren: function() {
			if (this._childrenControllers) {
				/**
				 * Destroy all children controllers
				 */
				for (var key in this._childrenControllers) {
					if (this._childrenControllers[key]) {
						this._childrenControllers[key].destroy();
					}
				}
				this._childrenControllers = {};
			}
		},

		registerController: function(controller) {
			if (!controller) {
				return;
			}
			this._childrenControllers[controller.id] = controller;
		},

		unregisterController: function(controller) {
			if (!controller || !this._childrenControllers) {
				return;
			}
			delete this._controlsById[controller.id];
		},

		//
		// CONTROLS START
		//
		getControl: function(ctrlId) {
			return this._controlById(ctrlId);
		},

		/**
		 * Returns the control that will process the event
		 * Eg: arrayRow/array controllers the control attached to the controller is the row/array itself
		 * Like there's no possibility to get the row/array we ask the parent
		 */
		getControlForEvent: function(ctrlId, eventName) {
			var ctrl = this.getControl(ctrlId);
			if (!ctrl && this.parent) {
				ctrl = this.parent.getControlForEvent(ctrlId);
			}
			return ctrl;
		},


		getControlsByType: function($types) {
			if (!Array.isArray($types)) {
				$types = [$types]
			}
			var res = []
			this.forEachControl(function(c) {
				if ($types.indexOf(c.$type) >= 0) {
					res.push(c)
				}
			});
			return res;
		},
		registerControl: function(ctrl) {
			this._controlsById[ctrl.id] = ctrl;
			if (ctrl.onMenuItemChanged) {
				this._menuItemContainersById[ctrl.id] = ctrl;
			}
			if (ctrl.savedCtxCreate) {
				this._controlsWithContext.push(ctrl);
			}
		},
		unregisterControl: function(ctrl) {
			delete this._controlsById[ctrl.id];
			delete this._menuItemContainersById[ctrl.id];
			var idx = this._controlsWithContext.indexOf(ctrl);
			if (idx >= 0) {
				this._controlsWithContext.splice(idx, 1);
			}
		},
		_controlById: function(ctrlId) {
			return this._controlsById[ctrlId];
		},
		//
		// CONTROLS END
		//				

		//
		// START UI ADAPTER
		// UI adapter is used to allow the controller to trigger events that occur in the
		// user interface. This is to remove dependencies in the controller
		//
		setUIAdapter: function(uiAdapter) {
			this.uiAdapter = uiAdapter;
		},
		_showNotification: function(title, message, severity) {
			if (this.uiAdapter && this.uiAdapter._showNotification) {
				return this.uiAdapter._showNotification(title, message, severity);
			}
		},
		_askConfirmation: function($confirm) {
			if (this.uiAdapter && this.uiAdapter._askConfirmation) {
				return this.uiAdapter._askConfirmation($confirm);
			}
			return $.smResolve("yes");
		},
		_updateRequestCount: function(count) {
			if (this.uiAdapter && this.uiAdapter._updateRequestCount) {
				return this.uiAdapter._updateRequestCount(count);
			}
		},
		//
		// END UI ADAPTER
		//

		/**
		 * Used by event listener if a data-naction data-params element was clicked
		 * 
		 */
		onDataActionClicked: function(dataAction, dataParams, event) {
			var method = "_act" + $.camelCase("-" + dataAction);

			// Controller implements actions?
			func = this[method];
			if (func) {
				return func.call(this, dataParams, event);
			}

			// Page implements actions?
			var page = modules.get("navStack").getMainStack().getTopPage();
			if (page && page[method]) {
				return page[method].call(page, dataParams, event);
			}

			// App implements actions?
			var app = modules.get("appController").App;
			var func = app[method];
			if (func) {
				return func.call(app, dataParams, event);
			}
		},

		/**
		 * Called whenever a menu item changes
		 * $itemName can be the name of an action or link or something else that the containing widgets must know
		 */
		onMenuItemChanged: function($itemName, $bind, metaData) {
			var ids = Object.keys(this._menuItemContainersById);
			for (var i = 0, j = ids.length; i < j; i++) {
				var id = ids[i];
				var ctrl = this._menuItemContainersById[id];
				ctrl && ctrl.onMenuItemChanged($itemName, $bind, metaData);
			}
		},

		/** 
		 * Is this a root dataset (e.g. page level)
		 */
		isRoot: function() {
			return this != null && this == this.root;
		},

		/**
		 * All controls that do navigation (like ctrlReference for lookups) should ask the controller
		 * to navigate instead of doing the below in their own code.
		 * Doing it centralized in the controller allows sanity checks
		 */
		gotoUrl: function($url, $method, pageOptions, loadOptions) {
			return modules.get("navHelper").gotoUrl($url, $method, pageOptions, loadOptions);
		},
		/**
		 * Navigate to an external url
		 * Used by some controls like CtrlUrl, CtrlPhone, ...
		 */
		_actOpenExternalLink: function(url) {
			var nativeExtLink = native.getModule("extLink");
			if (nativeExtLink) {
				nativeExtLink.openExternalLink(url);
			} else {
				window.open(url);
			}
		},
		/* We expose the module function here so that every component that knows a 
		 * controller can find other controllers without the need of including a 
		 * require to the controller module
		 */
		findController: function(controllerId) {
			return exports.findController(controllerId);
		},

		/**
		 * Stops if cb returns true 
		 */
		forEachControl: function(cb) {
			if (!this._controlsById) {
				return;
			}
			var self = this;
			Object.keys(this._controlsById).some(function(key, idx) {
				var c = self._controlsById[key];
				if (c) {
					return cb(c, idx) == true;
				}
				return false;
			})
		},
		savedCtxCreate: function(opts) {
			var self = this;
			var ctxCtrls = [];
			self._controlsWithContext.forEach(function(ctrl, idx) {
				var ctrlCtx = ctrl.savedCtxCreate(opts);
				if (ctrlCtx) {
					ctxCtrls.push(ctrlCtx);
				}
			})
			return ctxCtrls;
		},
		savedCtxRestore: function(ctrlsCtx) {
			if (!ctrlsCtx) {
				return;
			}
			var self = this;
			ctrlsCtx.forEach(function(ctrlCtx, idx) {
				var ctrl = self._controlsWithContext[idx];
				if (ctrl && ctrl.savedCtxRestore) {
					ctrl.savedCtxRestore(ctrlCtx)
				}
			})
		},
		savedCtxIndexOf: function(ctrl) {
			return this._controlsWithContext == null ? -1 : this._controlsWithContext.indexOf(ctrl);
		}
	}
);

exports.findController = function(id) {
	return _controllers[id];
}

exports.findControllerByDom = function($$elmt) {
	var $$controller = $$elmt.closest("[data-controller-id]");
	var controllerId = $$controller.attr("data-controller-id");
	return exports.findController(controllerId);
}

exports.findControlByDom = function($$elmt) {
	var controller = exports.findControllerByDom($$elmt);
	if (controller) {
		var $$ctrl = $$elmt.closest(".s-m-ctrl");
		var ctrlId = $$ctrl.attr("id");
		if (ctrlId) {
			return controller.getControl(ctrlId);
		}
	}
}
});

define('syracuse-tablet/html/js/app/eventListener',['require','exports','module','syracuse-tablet/html/js/helpers/environment','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/controllers/controller','syracuse-tablet/html/js/ui/siteLayout'],function (require, exports, module) {


var environment = require('syracuse-tablet/html/js/helpers/environment');
var modules = require('syracuse-tablet/html/js/common/modules');
var controllerModule = require("syracuse-tablet/html/js/controllers/controller");
var siteLayout = require('syracuse-tablet/html/js/ui/siteLayout');

var _CLICKDELAY = 300;
var _lastClick = 0;

/**
 * Event model
 * 
 * DOM elements that want to make use of the event listener need to put data-nevent attribute
 * Whenever an event is raised, the closest element with data-nevent attribute is checked for
 * additional information (name of sdata-link or action) on how to handle the event.
 * 
 * The event is always dispatched to a control, the control is discovered by finding the closest DOM
 * element of the data-nevent element having a s-m-ctrl class
 * 
 * To be able to get the control object, the controller is discovered by finding the closest DOM
 * element of the s-m-ctrl element having a data-controller-id attribute
 * 
 * Like this, a control can have many different events/actions defined in the DOM (see below)
 * but handle them all in one control
 * 
 * <section data-controller-id="59"> 	
 *   <div class="s-m-ctrl" id="page438">
 *     <a href="#" data-nevent="" data-naction="home">
 *     <a href="#" data-nevent="" data-naction="pinPage">
 *     
 *     <a href="#" data-nevent="" data-sdata-action-name="$save">
 *     <a href="#" data-nevent="" data-sdata-link-name="$details">
 *     
 *     <a href="#" data-nevent="" data-sdata-link-name="$lookup" data-sdata-link-bind="CUR_REF">

 *     <a href="#" data-nevent="" data-nevent-ctrl-change="">
 *   </div>
 * </section> 
 * 
 */


/**
 * New event listener will catch everything 
 */
exports.registerEvents = function($$container) {

	$(window).on("resize", siteLayout.onWindowResize);
	if (environment.isMobile()) {
		// JQuery mobile helpers that provides Orientationchanged better than we can do
		$.event.special.orientationchange.setup();
		$(window).on("orientationchange", siteLayout.onWindowOrientation);
	}
	// Resize triggered internally
	$(window).on("resizeInternal", siteLayout.onWindowResizeInteral);

	// History management
	$(window).bind("popstate", function(event) {
		var state = event.originalEvent.state;
		// We've to check state to not call historyPop on click on href="#"
		// FIREFOX
		//		Previous fix #8072 - old code was  if (state || /Firefox/.test(navigator.userAgent)) {app.historyPop}
		//			FF was trigering only one event with null state on back
		//	    After fix #8072
		//			Now FF seems to trigger only one event with state != null except when we open the mobile client from another tab with window.open (like does the desktop)
		//			If the client is opened with window.open, the first click in the breadcrum or first back generates popstate with null state  (??)
		//			So the code below fixes this bug and works for all browsers FF
		// CHROME
		// 		When we click back 2 events are triggered (one with state == null that we skip)
		// IE
		// 		When we click back one event is triggered with state != null like FF
		if (state) {
			modules.get("appController").App.onBrowserBackButton(event);
		} else {
			event.preventDefault();
		}
	});

	// General click handler
	$$container.on("click", "[data-nevent]:not(.disabled):not([disabled])", function(e) {
		_eventHandler(e, "click");
	});

	// Whenever a control registers to catch low level events for UX (e.g. blur)
	//!! no data-nevent on data-nevent-ctrl because there's a conflict with click (we do'nt want click to be handled)
	//!! Put data-nevent-ctrl-click to call onClick Method
	["blur", "focus", "change", "click"].forEach(function(eventName) {
		$$container.on(eventName, "[data-nevent-ctrl-" + eventName + "]:not(.disabled):not([disabled])", function(e) {
			_eventHandler(e, eventName);
		});
	});
}


/**
 * 
 * eventName is the jQuery name ("blur", "focus", "change", "click") different from event.type. Eg: blur -> focusout
 * We need it 
 */
function _eventHandler(event, eventName) {
	var $$target = $(event.target);
	var controlRequest = false;

	var $$nevent;
	if ($$target.attr("data-nevent") != null) {
		$$nevent = $$target;
	} else {
		// search data-nevent-ctrl including $target
		$$nevent = $$target.closest("[data-nevent-ctrl-" + eventName + "]");
		if ($$nevent.length > 0) {
			controlRequest = true;
		} else {
			$$nevent = $$target.closest("[data-nevent]");
		}
	}
	if ($$nevent == null || $$nevent.length == 0) {
		return;
	}
	if (eventName === "click") {
		var time = new Date().getTime();
		if (_lastClick > 0 && (time - _lastClick) < _CLICKDELAY) {
			// Avoid double-click for click that don't trigger the display of a new page (panels)
			return;
		}
		_lastClick = time;
		// Blocks event during _CLICKDELAY ms
		$$nevent.attr("disabled", "true");
		setTimeout(function() {
			try {
				$$nevent.removeAttr("disabled")
			} catch (e) {}
		}, _CLICKDELAY)
	}

	var $$ctrl;
	if ($$nevent.hasClass("s-m-ctrl")) {
		$$ctrl = $$nevent;
	} else {
		$$ctrl = $$nevent.closest(".s-m-ctrl");
	}
	// $$nevent controller overrides the one of $$ctrl
	// E.g: Inside a panel control we can add multiple controllers to control sub-panels (footer/Header multi-selection)
	var $$controller = $$nevent.is("[data-controller-id]") ? $$nevent : $$ctrl.is("[data-controller-id]") ? $$ctrl : $$ctrl.closest("[data-controller-id]");
	var controllerId = $$controller.attr("data-controller-id");

	var controller = controllerId && controllerModule.findController(controllerId)
	var ctrlId = $$ctrl.attr("id");

	var ctrl = ctrlId && controller && controller.getControlForEvent(ctrlId, eventName);

	// This is true whenever a control requests to handle a low level event like "blur" itself and not
	// want to interact with the controller
	var handled = false;
	if (controlRequest && ctrl) {
		// Usually, the control handles the raw-event like onClick, onChange, ...
		// if there is a data-naction attribute, the control does not receive a raw event
		// but pre-parsed information in an _act... function
		var dataAction = $$nevent.attr("data-naction")

		var method = "on" + eventName.smCapitalize();
		var func = ctrl[method];
		var args = [];
		var params;
		if (dataAction && $$nevent.is("select")) { // data-naction on select will send selected value to _act function
			method = "_act" + dataAction.smCapitalize();
			func = ctrl[method];
			params = $$nevent.val();
			if (params && typeof params === "string") {
				params = params.split(',');
				params.forEach(function(p, idx) {
					args.push(p.trim());
				});
			}
		} else {
			// Send raw event to control since there is no data-naction attribute
			args.push(event);
		}
		if (func) {
			handled = func.apply(ctrl, args);
		}
		if (handled) {
			// If low level events are handled by a control, the handler function can return true to stop processing or return
			// false to continue processing the event in the event handler further on.
			// In the first case, the control is responsible for stopping propagation etc. by doing:		
			// event.preventDefault();
			// event.stopPropagation();
			// Usage can be: Panel can have onClick to catch the click to close itself but the execution of the link is done in here
			return;
		}
	}

	// If not handled by a control explicitly, we check if it can be handled in a generic way

	if (eventName !== "click") { // We only handle click events further on
		return;
	}

	if (ctrl && controller) { // data related actions are only triggered if there was a control and controller found attached to the event
		// Did we click an sdata link?
		var $linkName = $$nevent.attr("data-sdata-link-name");
		var $linkBind = $$nevent.attr("data-sdata-link-bind");
		if ($linkName) {
			if (ctrl.onSdataLinkClicked) {
				ctrl.onSdataLinkClicked($linkName, $linkBind);
			} else if (controller.onSdataLinkClicked) {
				controller.onSdataLinkClicked($linkName, $linkBind);
			}
			/**
			 * No event.preventDefault/event.stopPropagation in order to let event bubbles to other components
			 * -> A bootstrap dropDownList is closed when we click outside the panel. if we trap the event here and event.stopPropagation dropDown stays open
			 * -> E.g: dropDownList in multi-selection header/footer
			 * event.preventDefault();
			 * event.stopPropagation();
			 */
			return;
		}

		// Did we click an sdata action?
		var $actionName = $$nevent.attr("data-sdata-action-name");
		if ($actionName) {
			if (ctrl.onSdataActionClicked) { // It's very unlikely a control will ever handle this because actions are page level events
				ctrl.onSdataActionClicked($actionName);
			} else if (controller.onSdataActionClicked) {
				controller.onSdataActionClicked($actionName);
			}
			/**
			 * No event.preventDefault/event.stopPropagation in order to let event bubbles to other components
			 * -> A bootstrap dropDownList is closed when we click outside the panel. if we trap the event here and event.stopPropagation dropDown stays open
			 * -> E.g: dropDownList in multi-selection header/footer
			 * event.preventDefault();
			 * event.stopPropagation();
			 */
			return;
		}
	}
	var dataAction = $$nevent.attr("data-naction");
	if (dataAction) {
		var args = [];
		var tmp = $.camelCase("-" + dataAction);
		if (tmp.indexOf("-") === 0) {
			tmp = tmp.substr(1);
		}
		var method = "_act" + tmp;
		var objectToCall;
		if (ctrl && ctrl[method]) {
			objectToCall = ctrl;
		} else if (ctrl && ctrl.onDataActionClicked) {
			args.push(dataAction);
			method = "onDataActionClicked";
			objectToCall = ctrl;
		} else if (controller && controller[method]) {
			objectToCall = controller;
		} else if (controller && controller.onDataActionClicked) {
			args.push(dataAction);
			method = "onDataActionClicked";
			objectToCall = controller;
		} else {
			var navStack = modules.get("navStack").findClosest($$nevent);
			var page = navStack && navStack.getTopPage();
			if (page && page[method]) {
				objectToCall = page;
			} else {
				var app = modules.get("appController").App;
				if (app && app[method]) {
					objectToCall = app;
				}
			}
		}
		if (objectToCall && method) {
			var dataParams = $$nevent.attr("data-params") || "";
			// Create a array of parameters with ','  as separator
			// Used to pass multiple parameters  data-params="filterSelected,{{id}}"
			dataParams = dataParams.split(',');
			dataParams.forEach(function(p, idx) {
				// Remove leading/trailing spaces
				args.push(p.trim());
			});
			// adds event as last parameter because it can be useful
			args.push(event);
			objectToCall[method].apply(objectToCall, args);
		}
		/**
		 * No event.preventDefault/event.stopPropagation in order to let event bubbles to other components
		 * -> A bootstrap dropDownList is closed when we click outside the panel. if we trap the event here and event.stopPropagation dropDown stays open
		 * -> E.g: dropDownList in multi-selection header/footer
		 * event.preventDefault();
		 * event.stopPropagation();
		 */
		return;
	}
}

/**
 * DOM attributes to set for identifying a data action (usually something handled by the client only)
 */
exports.getDataActionAttrs = function(controllerId, action, params, asHtml) {
	var attrs = {
		"href": "#",
		"data-nevent": "",
		"data-controller-id": controllerId,
		"data-naction": action,
		"data-params": params
	};
	return asHtml ? _objectToHtmlAttrs(attrs) : attrs;
};

/**
 * DOM attributes to set for identifying an sdata link
 */
exports.getSdataLinkAttrs = function(controllerId, $linkName, $bind, asHtml) {
	var attrs = {
		"href": "#",
		"data-nevent": "",
		//		Not used yet, controller is also found going up the DOM
		//	    Can be used later if DOM parent is not the controller of this control		
		//		"data-controller-id": controllerId,
		"data-sdata-link-name": $linkName,
		"data-sdata-link-bind": $bind // Optional for field level links
	};
	return asHtml ? _objectToHtmlAttrs(attrs) : attrs;
};

/**
 * DOM attributes to set for identifying an sdata action
 */
exports.getSdataActionAttrs = function(controllerId, $actionName, asHtml) {
	var attrs = {
		"href": "#",
		"data-nevent": "",
		//		Not used yet, controller is also found going up the DOM
		//	    Can be used later if DOM parent is not the controller of this control		
		//		"data-controller-id": controllerId,
		"data-sdata-action-name": $actionName
	};
	return asHtml ? _objectToHtmlAttrs(attrs) : attrs;
};

function _objectToHtmlAttrs(obj) {
	var html;
	for (var attr in obj) {
		var val = obj[attr];
		if (val === null) {
			continue;
		}
		if (val !== "") {
			//TODO: Escape val?
			val = '="' + val + '"';
		}

		if (!html) {
			html = attr + val;
		} else {
			html += ' ' + attr + val;
		}
	}
	return html;
}
});

define('syracuse-tablet/html/js/controls/ctrlBase',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/app/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/environment','syracuse-tablet/html/js/app/eventListener'],function (require, exports, module) {

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/app/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var localeModule = require('syracuse-tablet/html/js/helpers/locale');
var environment = require('syracuse-tablet/html/js/helpers/environment');
var eventListener = require('syracuse-tablet/html/js/app/eventListener');

/**
 * Root base class for controls and layouts (was structElmt before).
 * 
 *
 */
exports.CtrlBase = utils.defineClass(
	function CtrlBase(controller, $type, article, options) {
		this.options = options || {};
		this.controller = controller;
		this.$type = $type;
		this.typeName = utils.getTypeName($type);
		this.article = article || {};
		this.children = null;
		this.parent = null;
		this.destroyed = false;
		this.id = this.createId(this.typeName);
		// Set after creation by ctrlFactory - Property not mandatory
		this.page = null;

		controller.registerControl(this);
	}, null, {
		destroy: function() {
			this.destroyed = true;
			this.page = null;
			if (this.controller) {
				this.controller.unregisterControl(this);
			}
			this.controller = null;
			// First destroy the children before removing $$elmt
			this.destroyChildren();
			notifications.unsubscribe(this);
			if (this.$$elmt) {
				this.$$elmt.unbind();
				this.$$elmt.remove();
				this.$$elmt = null;
			}
			if (this.parent) {
				this.parent.removeChild(this);
				this.parent = null;
			}
		},
		removeChild: function(ctrl) {
			if (!this.children) {
				return;
			}
			var idx = this.children.indexOf(ctrl);
			if (idx > -1) {
				this.children.splice(idx, 1);
			}
		},
		destroyChildren: function() {
			if (!this.children) {
				return;
			}
			for (var i = this.children.length - 1; i >= 0; i--) {
				if (this.children[i]) {
					// destroy removes the child in the parent
					this.children[i].destroy();
				}
			}
			// this.children should be equal to 0
			// We set [] per security because this method can be called by authoring if a control or layout is removed by the user
			this.children = [];
		},
		createId: function(typeName) {
			return utils.readableuid(typeName);
		},

		//
		// START: Rendering
		//
		/**
		 * Set container where html of this control will be placed
		 * Must be called by parent before invoking buildHtml
		 */
		set$$container: function($$container) {
			this.$$container = $$container;
		},
		/**
		 * Each subclass must implement this method to work properly
		 */
		buildHtml: function(classes) {
			throw new Error("Controll does not implement buildHtml");
		},
		/**
		 * Create the root element of the control/layout/vignette
		 * This element is identified by this.id
		 */
		createRootElement: function(classList) {
			if (!this.$$container) {
				throw new Error("No container set for rendering");
			}
			var domElement = uiUtils.createDomElement(this.getRootElementTag(), classList, null, {
				"id": this.id
			});
			var $$elmt = $(domElement);
			this.setRootElement($$elmt, this.$$container);
			if (environment.isAutoUITestMode()) {
				environment.getUnitTestMgr().addBindAttribute(this);
			}
			return $$elmt;
		},
		getRootElementTag: function() {
			return "div";
		},
		/**
		 * 
		 */
		setRootElement: function($$elmt, $$parent) {
			if (!$$parent.jquery) {
				throw new Error("Invalid parent");
			}
			if (!$$elmt.jquery) {
				throw new Error("Invalid root");
			}
			this.$$elmt = $$elmt;
			this.$$elmt.appendTo($$parent);

			if (environment.isAutoUITestMode()) {
				var i = this.getUnitTestId();
				if (i) {
					environment.getUnitTestMgr().addStructElmtId(this.$$elmt, i);
				}
			}
			return this.$$elmt;
		},
		afterRender: function() {
			this.children && this.children.forEach(function(child) {
				child.afterRender();
			});
		},
		//
		// END: Rendering
		//


		//
		// START: Authoring
		//
		/**
		 * Returns field/layout authoring
		 * path: string with or without '.' separator or array of string
		 */
		getAuthoring: function(path, defValue) {
			var val = utils.getPropByPath(this.article, path);
			return val != null ? val : defValue;
		},

		/*
		 * Must return the article of this control/layout node
		 * The article must only contain static authoring.
		 * Dynamic settings that are added by payload must not be part of the returned data structure
		 * since this structure will be used to create the article tree for the page and will
		 * be stored on the server!
		 */
		getArticle: function() {
			return this.article;
		},
		/*
		 * Returns the article used for authoring of this element
		 * Note that sub level informations usually nested in $items MUST NOT be returned here
		 */
		getAuthArticle: function() {
			var authArticle = {};
			var nodeArticle = this.getArticle();
			Object.keys(nodeArticle).forEach(function(key) {
				if (key !== "$items") {
					authArticle[key] = nodeArticle[key];
				}
			});
			return authArticle;
		},

		getAuthState: function(dirtyKeys) {
			return null;
		},
		setAuthState: function(state) {

		},
		//
		// END: Authoring
		//

		isRoot: function() {
			return this.parent == null || this.parent === this.controller;
		},
		isVisible: function() {
			return this.$$elmt && this.$$elmt.is(":visible");
		},
		isHidden: function() {
			return !this.isVisible();
		},
		/**
		 * Set the focus on this field and scroll
		 */
		setFocus: function() {},
		show: function() {
			if (this.$$elmt) {
				this.$$elmt.show();
			}
		},
		hide: function() {
			if (this.$$elmt) {
				this.$$elmt.hide();
			}
		},
		//
		// START: Tree / child management
		//

		/**
		 * Append structElmt c as a child of this
		 */
		appendStructElmt: function(c) {
			if (!c) return;
			if (!this.children) this.children = [];
			c.parent = this;
			this.children.push(c);
		},

		getNbChilds: function() {
			return this.children && this.children.length > 0;
		},

		getIndexOfChild: function(child) {
			var idx = -1;
			this.children && this.children.some(function(c) {
				idx = idx + 1;
				if (c === child) {
					return true;
				}
				return false;
			});
			return idx;
		},
		getChildByIndex: function(idx) {
			return this.children && this.children[idx];
		},

		/*
		 * Add new child before nextChild
		 * If nextChild is null, it's added at the end of the container
		 */
		addChildBefore: function(ctrl, nextChild) {
			var added = false;
			var _children = [];
			this.children && this.children.forEach(function(c) {
				if (nextChild && (c.id === nextChild.id)) {
					_children.push(ctrl);
					added = true;
				}
				if (c.id !== ctrl.id) {
					_children.push(c);
				}
			});

			if (!added) {
				_children.push(ctrl);
			}
			this.children = _children;
		},

		/*
		 * Removes reference to child without destroying the child!
		 */
		removeChildRef: function(c) {
			var _children = [];
			this.children && this.children.forEach(function(child) {
				if (child.id !== c.id) {
					_children.push(child);
				}
			});
			this.children = _children;
		},

		/*
		 * Start by this node and go up the layout tree storing all the indexes of the current not in the parent container
		 */
		getPathInTree: function() {
			var ctrl = this;
			var path = [];
			var parent = this.parent;

			// Special case: this is the root layout of a vignette
			if (parent == null && this.page && this.page.parentVignette) {
				parent = this.page.parentVignette.parent;
				path.push(0);
			}
			// The intention of this function is to stop at root level, not at the first controller found
			// The first controller might be the vignette containing the control, but we want to get the page/dashboard
			// containing the full screen not only a single vignette
			//while (parent && parent != this.controller) {
			while (parent) {
				var idx = parent.getIndexOfChild(ctrl);
				path.push(idx);

				ctrl = parent;
				parent = ctrl.parent;
				if (parent == null && ctrl.page && ctrl.page.parentVignette) {
					path.push(0);
					ctrl = ctrl.page.parentVignette;
					parent = ctrl.parent;
				}
			}
			path.reverse();
			return path;
		},

		/*
		 * Resolve the path generated by getPathInTree to find the children again
		 */
		findChildByPath: function(path) {
			if (!path) {
				return;
			}

			var node = this;
			path.some(function(idx) {
				if (jsutils.isInstanceOf(node, "CtrlVignette")) {
					var page = node.getTopPage();
					node = page && page.rootLayout;
					return false;
				}
				node = node && node.getChildByIndex(+idx);
				if (!node) {
					return true;
				}
			});
			return node;
		},
		//
		// END: Tree / child management
		//

		getArticleText: function(property) {
			if (!this.article[property]) {
				return "";
			}

			var self = this;
			var $articleLocalizationDashboard;
			if (self.page.parentVignette) {
				$articleLocalizationDashboard = self.page.parentVignette.$articleLocalization;
			}

			var locale = localeModule.getCurrentLocale();
			var prop = self.article[property];
			var text = prop && prop.replace(/\{\@(\S+)\}/g, function(m, g) {
				var localization = self.$articleLocalization[locale];
				var fallback = self.$articleLocalization[globals.fallbackLocaleCode];

				var match = (localization && localization[g]) ||
					(fallback && fallback[g]) ||
					($articleLocalizationDashboard && $articleLocalizationDashboard[locale] && $articleLocalizationDashboard[locale][g]) ||
					($articleLocalizationDashboard && $articleLocalizationDashboard[globals.fallbackLocaleCode] && $articleLocalizationDashboard[globals.fallbackLocaleCode][g]);

				if (match === null || match === undefined) {
					return m;
				}
				return match;
			});
			if (text && prop === text) {
				text = this.controller.dataset.prototype.resolveExpression(text);
			};

			return text || "";
		},
		getArticleTextUUID: function(property) {
			if (!this.article[property] || this.article[property].indexOf("{@") < 0) {
				return "";
			};
			var uuid = this.article[property].match(/\{\@(\S+)\}/);
			return (uuid && uuid[1]);
		},
		//
		// START: Testing
		//
		getUnitTestId: function() {
			return null;
		},

		/**
		 * Used by unit test entities to display info
		 */
		getUnitTestMsg: function() {
			return this.article && this.article.$unitTest ? this.article.$unitTest.message : null;
		},
		//
		// END: Testing
		//

		getDataActionAttrs: function(dataAction, dataParams) {
			return eventListener.getDataActionAttrs(this.controller.id, dataAction, dataParams);
		},
		isControl: function() {
			return true;
		},
		isLayout: function() {
			return false;
		},
		isArrayChart: function() {
			return false;
		},
		isAuthoringPropAllowed: function(property, value) {
			return true;
		},
		isVignette: function() {
			return false;
		},
		/**
		 * Set true for controls that contain children but do not allow authoring on these children
		 * because authoring is managed by parent.
		 * Currently, only arrays set this to true
		 * 
		 */
		excludeChildrenFromAuthoring: function() {
			return false;
		},

		setBuildOption: function(optionName, optionValue) {
			if (optionValue != null) {
				this.options[optionName] = optionValue;
			} else {
				delete this.options[optionName];
			}
		},
		setBuildOptionPerClass: function(className, optionName, optionValue) {
			if (jsutils.isInstanceOf(this, className)) {
				this.setBuildOption(optionName, optionValue);
			}
			this.children && this.children.forEach(function(c) {
				c.setBuildOptionPerClass(className, optionName, optionValue);
			});
		}
	}
);
});

define('syracuse-tablet/html/js/controls/ctrlSdataBase',['require','exports','module','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/app/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/app/eventListener','syracuse-tablet/html/js/helpers/environment'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/ctrlBase').CtrlBase;

var globals = require('syracuse-tablet/html/js/app/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var native = require('syracuse-tablet/html/js/helpers/native/native');
var eventListener = require('syracuse-tablet/html/js/app/eventListener');
var environment = require('syracuse-tablet/html/js/helpers/environment');

/**
 * Base class for all controls
 * Main purpose is to register with the controller
 */
exports.CtrlSdataBase = utils.defineClass(
	function CtrlSdataBase(controller, article, prototype, options) {
		// Set $bind before calling super ctor because super ctor will register $bind with controller!
		this.$bind = article.$bind;

		Base.call(this, controller, prototype.getType(), article, options);
		this.prototype = prototype;
		this.$isEditMode = controller.isEditMode();
		this._nativeCapabilities = this._initNativeCapabilities(options);
	}, Base, {
		destroy: function() {
			var self = this;
			Base.prototype.destroy.call(self);

			// Do not call prototype.destroy here
			// the control uses the prototype but destruction is done on higher level
			// is is possible a prototype is reused (e.g. same proto for several array items)
			self.prototype = null;
		},
		createId: function(typeName) {
			// Add $bind in id for readability - Id can be minimized in non debug version
			return utils.readableuid(this.$bind, typeName.substr(0, 3));
		},

		//
		// END: Start 
		//
		/**
		 * controllerDao is the page dao or the row data for a grid
		 * 	We need to store it to keep acces
		 */
		buildHtml: function(classes) {
			classes = classes || [];
			classes.push("s-m-control");
			classes.push("s-m-ctrl");

			var $theme = this.getAuthoring("$theme");
			if ($theme && $theme !== "none") {
				classes.push("s-m-theme-" + $theme);
			}

			this.createRootElement(classes);

			if (environment.isAutoUITestMode()) {
				environment.getUnitTestMgr().addBindAttribute(this);
			}
		},
		afterRender: function() {},
		/**
		 * Applies meta-data
		 */
		applyMetaData: function(metaData) {
			// Must be managed optionally in subclasses
		},
		//
		// END: Rendering 
		//

		//
		// START: Sdata 
		//
		/**
		 * dao.getMetaData does the merge between prototype and data
		 * metaProp		optional - name of the meta $readonly...
		 * 				if null returns all the meta
		 */
		getMetaData: function(metaProp) {
			var meta = this.controller.getMetaData(this.$bind);
			return meta && (metaProp ? meta[metaProp] : meta);
		},
		getTitle: function() {
			var ttl = (this.article && this.article.$title) || this.prototype.getValueByPath("$title", true) || "";
			if (ttl.length === 0 && globals.isAuthoringActive() && this.prototype.isFacet("details", "edit")) {
				// #7148- It's better to display title if no title and force the user to hide them in authoring mode
				ttl = this.$bind;
			}
			return ttl;
		},
		getSdataLinkAttrs: function($linkName) {
			return eventListener.getSdataLinkAttrs(this.controller.id, $linkName, this.$bind);
		},
		getDataActionAttrs: function(action, params) {
			return eventListener.getDataActionAttrs(this.controller.id, action, params);
		},
		//
		// END: Sdata
		//

		//
		// START: Testing
		//
		getUnitTestId: function() {
			if (this.$bind) {
				return utils.unitTestId(this.$bind);
			} else {
				return utils.unitTestId(this.typeName);
			}
		},
		//
		// END: Testing
		//
		//
		// START: Native capabilities
		//
		_initNativeCapabilities: function(options) {
			if (!options || !options.nativeCapabilities) return null;
			var res = {};
			for (var capability in options.nativeCapabilities) {
				res[capability] = options.nativeCapabilities[capability] === true && native.hasCapability(capability) === true;
			}
			return res;
		},
		getNativeCapabilities: function() {
			return this._nativeCapabilities;
		}
	}
);

/**
 * Used to generate the html of control Icon/Button
 * generate a link and call cb to get the content of the control (icon/button...)
 * cb	Add html text to html param
 */
function _genHtmlCtrlLink(proto, dao, options, cb) {
	var self = this;
	options = options || {};
	var html = [];
	var url = proto.data("$url");
	var tag = options.tag || 'a';
	var css = options.css || 'a';
	if (url && url.length) {
		html.push('<');
		html.push(tag);
		html.push(' href="' + url + '"');
		if (css) {
			html.push(' class="' + css + '"');
		}
		html.push('>');
	} else {
		// attributes for data-nav or data-action
		var action = proto.data("$action") || self.prototype.data("$navigation");
		if (action) {
			html.push('<');
			html.push(tag);
			html.push(' href="#"');
			for (var p in action) {
				html.push(' ' + p + '="' + encodeURIComponent(dao ? dao.parseExpression(action[p]) : action[p]) + '"');
			}
			if (css) {
				html.push(' class="' + css + '"');
			}
			html.push('>');
		}
	}
	if (cb) cb(html);
	if (html.length > 1) {
		html.push('</');
		html.push(tag);
		html.push('>');
	}
	return html.join('');
};

exports.genHtmlCtrlLink = _genHtmlCtrlLink;
});

define('syracuse-tablet/html/js/helpers/types/date',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require("syracuse-tablet/html/js/helpers/locale");

var _dateInfo = locale.getDatetimeInfo;

function _padLeft(str, len, ch) {
	str = str ? str.toString() : '';
	if (!ch || ch.length == 0)
		ch = " ";
	while (str.length < len)
		str = ch + str;
	return str;
};

exports.validate = function(value, constraints, errors) {
	if (value == null) {
		if (constraints.$isMandatory)
			return errors.push(locale.text("date.valMan"));
		if (!constraints.$isNullable)
			return errors.push(locale.text("date.valNull"));
		return;
	}
	if (!(value instanceof DateObj)) {
		errors.push(locale.text("date.valDate"));
		return;
	}

	// month value check
	if (!(value.month >= 1 && value.month <= 12)) {
		errors.push(locale.text("date.invMonth"));
		return;
	}

	// day value check
	if (!(value.day >= 1 && value.day <= _daysInMonth(value.year, value.month))) {
		errors.push(locale.text("date.invDay"));
		return;
	}

};

var _monthOffsets = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var _monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

// internal value is integer yyyymmdd
// this is a very simple and compact representation that leads to
// very efficient component extraction and formatting. 
// Also nice for debugging

function DateObj(value) {
	this._value = value;
	//Object.freeze(this); -- confuses JSON, reenable later
}

function _dayName(weekDay, abbrev) {
	return abbrev ? _dateInfo().abbreviatedDayNames[weekDay] : _dateInfo().dayNames[weekDay];
}

function _monthName(month, abbrev) {
	return abbrev ? _dateInfo().abbreviatedMonthNames[month - 1] : _dateInfo().monthNames[month - 1];
}

function _pad2(val) {
	var s = val.toString();
	return (s.length == 1) ? "0" + s : s;
}

function _toOffset(date) {
	var year = date.year;
	var month = date.month;
	var day = date.day;
	// Compute the number of leap days since Jan 1st, 1970.
	// The trick is to use the previous year if month is January or February,
	// the current year otherwise.
	// Then, we compute the number of multiples of 4, 100 and 400 since 1970.
	var y = month <= 2 ? year - 1 : year;

	var n4 = Math.floor(y / 4) - Math.floor(1970 / 4);
	var n100 = Math.floor(y / 100) - Math.floor(1970 / 100);
	var n400 = Math.floor(y / 400) - Math.floor(1970 / 400);

	// Years that are multiple of 400 (like 2000) contribute by 1 (1 -1 +1 in expression below)
	// Years that are multiple of 100 but not of 400 contribute by 0 (1 -1 +0 in expression below)
	// Years that are multiple of 4 but not 100 nor 400 contribute by 1 (1 -0 +0 in expression below).
	var nLeap = n4 - n100 + n400;

	// The offset is straightforward at this point.
	// The February/March transition on leap days will be handled by the fact that the
	// 'y' value above will change, and hence the 'nLeap' value.
	return (year - 1970) * 365 + nLeap + _monthOffsets[month - 1] + day - 1;
}

function _fromOffset(offset) {
	var julian = 2440588 + offset;
	var l = julian + 68569;
	var n = Math.floor((4 * l) / 146097);
	l = l - Math.floor((146097 * n + 3) / 4);
	var i = Math.floor((4000 * (l + 1)) / 1461001);
	l = l - Math.floor((1461 * i) / 4) + 31;
	var j = Math.floor((80 * l) / 2447);
	var day = l - Math.floor((2447 * j) / 80);
	l = Math.floor(j / 11);
	var month = j + 2 - (12 * l);
	var year = 100 * (n - 49) + i + l;
	return new DateObj(year * 10000 + month * 100 + day);
}

function _make(year, month, day) {
	return new DateObj(year * 10000 + month * 100 + day);
}

function _isLeap(year) {
	return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}

function _daysInMonth(year, month) {
	return month == 2 ? (_isLeap(year) ? 29 : 28) : _monthLengths[month - 1];
}

function _isWorkDay(weekDay) {
	return weekDay != 0 && weekDay != 6;
}

function _amDesignator() {
	return _dateInfo().amDesignator || "AM";
}

function _pmDesignator() {
	return _dateInfo().pmDesignator || "PM";
}

exports.amDesignator = _amDesignator;
exports.pmDesignator = _pmDesignator;

// do not export the class
utils.defineClass(DateObj, null, {
	year: {
		get: function() {
			return Math.floor(this._value / 10000);
		}
	},
	month: {
		get: function() {
			return Math.floor(this._value / 100) % 100;

		}
	},
	day: {
		get: function() {
			return this._value % 100;
		}
	},
	weekDay: {
		get: function() {
			// Add Julian offset (+1 because Julian origin is Monday) 
			// so that modulo is on positive value even if date is before 1970
			return ((2440588 + 1 + _toOffset(this)) % 7);
		}
	},
	yearDay: {
		get: function() {
			var month = this.month;
			var leap = month > 2 && _isLeap(this.year) ? 1 : 0;
			return _monthOffsets[month - 1] + leap + this.day;
		}
	},
	week: {
		// ISO 8601 with week 0
		get: function() {
			// week 1 is the beg of week that contains Jan 4th.
			var begOfWeek1 = _make(this.year, 1, 4).begOfWeek(1);
			return Math.floor((7 + _toOffset(this) - _toOffset(begOfWeek1)) / 7);
		}
	},

	valueOf: function() {
		return this.toString();
	},
	compare: function(date) {
		return this._value - date._value;
	},
	equals: function(date) {
		return this._value === date._value;
	},
	between: function(begin, end) {
		return begin._value <= this._value && this._value <= end._value;
	},

	isLeapYear: function() {
		return _isLeap(this.year);
	},
	isWorkDay: function() {
		return _isWorkDay(this.weekDay);
	},
	daysInMonth: function() {
		return _daysInMonth(this.year, this.month);
	},

	begOfYear: function() {
		return _make(this.year, 1, 1);
	},
	endOfYear: function() {
		return _make(this.year, 12, 31);
	},
	begOfQuarter: function() {
		return _make(this.year, Math.floor((this.month - 1) / 3) * 3 + 1, 1);
	},
	endOfQuarter: function() {
		return this.begOfQuarter().addMonths(2).endOfMonth();
	},
	begOfMonth: function() {
		return _make(this.year, this.month, 1);
	},
	endOfMonth: function() {
		return _make(this.year, this.month, this.daysInMonth());
	},
	sameMonth: function(day) {
		day = Math.min(day, this.daysInMonth());
		return _make(this.year, this.month, day);
	},
	pastDay: function(day, includeThis) {
		var delta = day - this.day;
		return (delta > 0 || delta == 0 && !includeThis) ? this.addMonths(-1).sameMonth(day) : this.sameMonth(day);
	},
	futureDay: function(day, includeThis) {
		var delta = day - this.day;
		return (delta < 0 || delta == 0 && !includeThis) ? this.addMonths(1).sameMonth(day) : this.sameMonth(day);
	},
	pastMonth: function(month, includeThis) {
		var delta = this.month - month;
		delta = delta == 0 ? (includeThis ? 0 : 12) : delta > 0 ? delta : delta + 12;
		return this.addMonths(-delta);
	},
	futureMonth: function(month, includeThis) {
		var delta = month - this.month;
		delta = delta == 0 ? (includeThis ? 0 : 12) : delta > 0 ? delta : delta + 12;
		return this.addMonths(delta);
	},
	begOfWeek: function(startDay) { // 0: Sunday (default), 1: Monday
		var delta = this.weekDay - (startDay || 0);
		return delta == 0 ? this : delta > 0 ? this.addDays(-delta) : this.addDays(-delta - 7);
	},
	endOfWeek: function(startDay) {
		return this.begOfWeek(startDay).addDays(6);
	},
	sameWeek: function(weekDay, startDay) {
		return this.begOfWeek(startDay).futureWeekDay(weekDay, true);
	},
	pastWeekDay: function(weekDay, includeThis) {
		var result = this.begOfWeek(weekDay);
		return !includeThis && result.equals(this) ? this.addWeeks(-1) : result;
	},
	futureWeekDay: function(weekDay, includeThis) {
		return this.pastWeekDay(weekDay, !includeThis).addWeeks(1);
	},
	addYears: function(years) {
		if (years == 0)
			return this;
		var year = this.year + years;
		var month = this.month;
		var day = Math.min(this.day, _daysInMonth(year, month));
		return _make(year, month, day);
	},
	addMonths: function(months) {
		if (months == 0)
			return this;
		var self = this;
		var day = self.day;
		var month0 = self.month - 1;
		var year = self.year;
		month0 += months;
		year += Math.floor(month0 / 12);
		var month = (month0 + 120000) % 12 + 1;
		var monthLen = _daysInMonth(year, month);
		day = day < monthLen ? day : monthLen;
		return _make(year, month, day);
	},
	addWeeks: function(weeks) {
		return this.addDays(7 * weeks);
	},
	addDays: function(days) {
		if (days == 0)
			return this;
		return _fromOffset(_toOffset(this) + days);
	},

	daysDiff: function(date) {
		return _toOffset(this) - _toOffset(date);
	},

	/**
     * Adds (or subtracts) to the value of the year, month, day, hour, minute, second, millisecond of the date instance using given configuration object. Positive and Negative values allowed.
     * Example
     <pre><code>
     Date.today().add( { day: 1, month: 1 } )
     </code></pre>
     * @param {Object}   Configuration object containing attributes (month, day, etc.)
     * @return {Date}    this
     */
	add: function(delta) {
		return this.addYears(delta.years || 0).addMonths(delta.months || 0).addWeeks(delta.weeks || 0).addDays(delta.days || 0);
	},

	// format as 
	toString: function(format) {
		var self = this;
		if (format == null) {
			// RFC 3339 by default -- very fast
			var str = self._value.toString();
			str = _padLeft(str, 8, "0");
			return str.substring(0, 4) + "-" + str.substring(4, 6) + "-" + str.substring(6, 8);
		} else {
			var result = '';
			_walkFormat(format, {
				literal: function(lit) {
					result += lit;
				},
				d: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.day.toString();
							break;
						case 2:
							result += _pad2(self.day);
							break;
						case 3:
							result += _dayName(self.weekDay, true);
							break;
						case 4:
							result += _dayName(self.weekDay);
							break;
						default:
							throw new Error(locale.text("date.formatd", repeat));
					}
				},
				M: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.month.toString();
							break;
						case 2:
							result += _pad2(self.month);
							break;
						case 3:
							result += _monthName(self.month, true);
							break;
						case 4:
							result += _monthName(self.month);
							break;
						default:
							throw new Error(locale.text("date.formatM", repeat));
					}
				},
				y: function(repeat) {
					switch (repeat) {
						case 2:
							result += self.year.toString().substring(2, 4);
							break;
						case 4:
							result += self.year.toString();
							break;
						default:
							throw new Error(locale.text("date.formatM", repeat));
					}
				}
			});
			return result;
		}
	},

	at: function(time, millisecond) {
		throw new Error(locale.text("date.notInstalled"));
	},

	toJsDate: function(utc) {
		return utc ? new Date(Date.UTC(this.year, this.month - 1, this.day)) : new Date(this.year, this.month - 1, this.day);
	},

	isNull: function() {
		return this._value == 0;
	}
});

exports.monthName = _monthName;

/**
 * Gets the month number (1-12) if given a Culture Info specific string which is a valid monthName or abbreviatedMonthName.
 * @param {String}   The name of the month (eg. "February, "Feb", "october", "oct").
 * @return {Number}  The day number
 */
exports.monthFromName = function(name) {
	var n = _dateInfo().monthNames,
		m = _dateInfo().abbreviatedMonthNames,
		s = name.toLowerCase();
	for (var i = 0; i < n.length; i++) {
		if (n[i].toLowerCase() == s || m[i].toLowerCase() == s) {
			return i + 1;
		}
	}
	return -1;
};

exports.dayName = _dayName;

/**
 * Gets the day number (0-6) if given a CultureInfo specific string which is a valid dayName, abbreviatedDayName or shortestDayName (two char).
 * @param {String}   The name of the day (eg. "Monday, "Mon", "tuesday", "tue", "We", "we").
 * @return {Number}  The day number
 */
exports.weekDayFromName = function(name) {
	var n = _dateInfo().dayNames,
		m = _dateInfo().abbreviatedDayNames,
		o = _dateInfo().shortestDayNames,
		s = name.toLowerCase();
	for (var i = 0; i < n.length; i++) {
		if (n[i].toLowerCase() == s || m[i].toLowerCase() == s) {
			return i;
		}
	}
	return -1;
};

exports.isLeap = _isLeap;

exports.daysInMonth = _daysInMonth;

exports.today = function(utc) {
	return exports.fromJsDate(new Date(), utc);
};

function _walkFormat(format, map) {
	var i = 0,
		len = format.length;

	function count(i) {
		var ch = format[i],
			k = 1;
		while (format[i + k] === ch)
			k++;
		return k;
	}

	while (i < len) {
		var c = format[i];
		switch (c) {
			case "'":
				i++;
				var literal = '';
				// going to the end of the following litteral or to the format end
				for (; i < len; i++) {
					if (format[i] === "'") {
						i++;
						// check wether the "'" is not doubled
						if (format[i] === "'") {
							literal += "'";
						} else
							break;
					} else {
						literal += format[i];
					}
				}
				map.literal(literal);
				break;
			case "d":
			case "M":
			case "y":
				var repeat = count(i);
				map[c](repeat);
				i += repeat;
				break;
			default:
				map.literal(c);
				i++;

		}
	}
}

function _parse(str, format) {
	var day, weekday, month, year;
	// position in str
	var j = 0;

	function parseInteger(max) {
		if (!/\d/.test(str[j])) {
			throw new Error(locale.text("date.notNumber", str.substring[j]));
		}
		var beg = j++;
		while (j < beg + max && /\d/.test(str[j]))
			j++;
		return parseInt(str.substring(beg, j), 10);
	}

	function parseName(names) {
		for (var k = 0; k < names.length; k++) {
			var name = names[k],
				len = name.length;
			if (str.substring(j, j + len).toUpperCase() == name.toUpperCase()) {
				j += len;
				return k;
			}
		}
		throw new Error(locale.text("date.unknown", str.substring(j)));
	}

	_walkFormat(format, {
		literal: function(literal) {
			if (str.substring(j, j + literal.length) !== literal)
				throw new Error(locale.text("date.wrongFormat", literal, str.substring(j)));
			j += literal.length;
		},
		d: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					day = parseInteger(2);
					break;
				case 3:
					weekday = parseName(_dateInfo().abbreviatedDayNames);
					break;
				case 4:
					weekday = parseName(_dateInfo().dayNames);
					break;
				default:
					throw new Error(locale.text("date.badDay", format.substring(j))); // replaced i with j
			}
		},
		M: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					month = parseInteger(2);
					break;
				case 3:
					month = parseName(_dateInfo().abbreviatedMonthNames) + 1;
					break;
				case 4:
					month = parseName(_dateInfo().monthNames) + 1;
					break;
				default:
					throw new Error(locale.text("date.badDay", format.substring(j))); // replaced i with j
			}
		},
		y: function(arg) {
			switch (arg) {
				case 2:
					year = parseInteger(2);
					year = year < 40 ? 2000 + year : 1900 + year;
					break;
				case 4:
					year = parseInteger(4);
					year = year > 99 ? year : year < 40 ? 2000 + year : 1900 + year;
					break;
				default:
					throw new Error(locale.text("date.badYear", format.substring(j))); // replaced i with j
			}
		}
	});

	// ignore weekday
	return _make(year, month, day);
}

exports.parse = function(str, format) {
	if (str == null)
		throw new Error(locale.text("date.dateNull"));

	if (format == null) {
		// RFC 3339 by default -- very fast
		if (str.length != 10)
			throw new Error(locale.text("date.badFormat", str));
		var value = parseInt(str.replace(/-/g, ''), 10);
		return new DateObj(value);
	} else {
		return _parse(str, format);
	}
};

// used for format conversions
exports.walkFormat = _walkFormat;

exports.fromJsDate = function(jsDate, utc) {
	return utc ? _make(jsDate.getUTCFullYear(), jsDate.getUTCMonth() + 1, jsDate.getUTCDate()) : _make(jsDate.getFullYear(), jsDate.getMonth() + 1, jsDate.getDate());
};

exports.fromInternalValue = function(value) {
	return new DateObj(value);
};

exports.makeInWeek = function(year, week, wday) {
	var dday = wday ? wday - 1 : 6;
	return _make(year, 1, 4).begOfWeek(1).addDays(7 * (week - 1) + dday);
};
exports.isDate = function(obj) {
	return obj instanceof DateObj;
};


exports.sunday = 0;
exports.Sunday = 0;
exports.monday = 1;
exports.Monday = 1;
exports.tuesday = 2;
exports.Tuesday = 2;
exports.wednesday = 3;
exports.Wednesday = 3;
exports.thursday = 4;
exports.Thursday = 4;
exports.friday = 5;
exports.Friday = 5;
exports.saturday = 6;
exports.Saturday = 6;

exports.make = _make;

exports.getLocalShortDate = function(dateISOString) {
	if (!dateISOString || dateISOString.length < 6)
		return "";

	var tmp = dateISOString.split("-");
	var d = _make(+tmp[0], +tmp[1], +tmp[2]);

	return d.toString(locale.getDateFormat());
};
});

define('syracuse-tablet/html/js/helpers/types/time',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require("syracuse-tablet/html/js/helpers/locale");
var _dateInfo = locale.getDatetimeInfo;

exports.validate = function(value, constraints, errors) {
	if (value == null) {
		if (constraints.$isMandatory) return errors.push(locale.text("time.valMan"));
		if (!constraints.$isNullable) return errors.push(locale.text("time.valNull"));
		return;
	}
	if (!(value instanceof Time)) {
		errors.push(locale.text("time.valTime"));
		return;
	}
};

function Time(value) {
	// force modulo on value to bring it back in range
	value = (value + 86400 * 365 * 10000) % 86400;
	this._value = value;
}

function _pad2(val) {
	var s = val.toString();
	return (s.length == 1) ? "0" + s : s;
}

function _parse2(str, beg, end) {
	return parseInt(str.substring(beg, end), 10);
}

function _make(hour, minute, second) {
	return new Time(hour * 3600 + (minute || 0) * 60 + (second || 0));
}

function _amDesignator() {
	return _dateInfo().amDesignator || "AM";
}

function _pmDesignator() {
	return _dateInfo().pmDesignator || "AM";
}

utils.defineClass(Time, null, {
	hour: {
		get: function() {
			return Math.floor(this._value / 3600);
		}
	},
	minute: {
		get: function() {
			return Math.floor(this._value / 60) % 60;
		}
	},
	second: {
		get: function() {
			return this._value % 60;
		}
	},
	value: {
		get: function() {
			return this._value;
		}
	},
	valueOf: function() {
		return this.toString();
	},
	compare: function(time) {
		return this._value - time._value;
	},
	equals: function(time) {
		return this._value === time._value;
	},
	between: function(begin, end) {
		return begin._value <= this._value && this._value <= end._value;
	},

	begOfDay: function() {
		return _make(0, 0, 0);
	},
	endOfDay: function() {
		return _make(23, 59, 59);
	},
	begOfHour: function() {
		return _make(this.hour, 0, 0);
	},
	endOfHour: function() {
		return _make(this.hour, 59, 59);
	},
	begOfMinute: function() {
		return _make(this.hour, this.minute, 0);
	},
	endOfMinute: function() {
		return _make(this.hour, this.minute, 59);
	},

	// format as
	toString: function(format) {
		var self = this;
		if (format == null) {
			return _pad2(self.hour) + ":" + _pad2(self.minute) + ":" + _pad2(self.second);
		} else {
			var result = '';
			_walkFormat(format, {
				literal: function(lit) {
					result += lit;
				},
				H: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.hour;
							break;
						case 2:
							result += _pad2(self.hour);
							break;
						default:
							throw new Error(locale.text("time.formatH", repeat));
					}
				},
				h: function(repeat) {
					switch (repeat) {
						case 1:
							var hour = self.hour;
							if (hour === 0) {
								result += 12;
							} else {
								result += hour > 12 ? hour - 12 : hour;
							}
							break;
						case 2:
							var hour = self.hour;
							if (hour === 0) {
								result += 12;
							} else {
								result += hour > 12 ? _pad2(hour - 12) : _pad2(hour);
							}
							break;
						default:
							throw new Error(locale.text("time.formath", repeat));
					}
				},
				m: function(repeat) {
					switch (repeat) {
						case 2:
							result += _pad2(self.minute);
							break;
						default:
							throw new Error(locale.text("time.formatm", repeat));
					}
				},
				s: function(repeat) {
					switch (repeat) {
						case 2:
							result += _pad2(self.second);
							break;
						default:
							throw new Error(locale.text("time.formats", repeat));
					}
				},
				t: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.hour < 12 ? _amDesignator().substring(0, 1) : _pmDesignator().substring(0, 1);
							break;
						case 2:
							result += self.hour < 12 ? _amDesignator() : _pmDesignator();
							break;
						default:
							throw new Error(locale.text("time.formata", repeat));
					}
				}
			});
			return result;
		}

	},

	secondsDiff: function(t) {
		return this._value - t._value;
	},

	// add functions circle from 23:59:59 to 00:00:00 without warning
	addHours: function(hours) {
		return hours == 0 ? this : new Time(this._value + hours * 3600);
	},
	addMinutes: function(minutes) {
		return minutes == 0 ? this : new Time(this._value + minutes * 60);
	},
	addSeconds: function(seconds) {
		return seconds == 0 ? this : new Time(this._value + seconds);
	},
	add: function(delta) {
		return this.addHours(delta.hours || 0).addMinutes(delta.minutes || 0).addSeconds(delta.seconds || 0);
	},
	isNull: function() {
		return this._value == 0;
	}
});

exports.make = _make;

exports.fromSeconds = function(seconds) {
	return new Time(seconds);
};

exports.fromJsDate = function(js, utc) {
	return utc ? _make(js.getUTCHours(), js.getUTCMinutes(), js.getUTCSeconds()) : _make(js.getHours(), js.getMinutes(), js.getSeconds());
};

exports.now = function(utc) {
	return exports.fromJsDate(new Date(), utc);
};

exports.parse = function(str, format) {
	if (str == null) throw new Error(locale.text("time.isNull"));

	if (format == null) {
		// RFC 3339 full time without fraction -- very fast
		// hh:mm
		if (str.length != 5 && str.length != 8) throw new Error(locale.text("time.badFormat", str));

		var value = str.length == 8 ? _parse2(str, 0, 2) * 3600 + _parse2(str, 3, 5) * 60 + _parse2(str, 6, 8) : _parse2(str, 0, 2) * 3600 + _parse2(str, 3, 5) * 60;
		return new Time(value);
	} else {
		return _parse(str, format);
	}
};

function _walkFormat(format, map) {
	var i = 0,
		len = format.length;

	function count(i) {
		var ch = format[i],
			k = 1;
		while (format[i + k] === ch)
			k++;
		return k;
	}

	while (i < len) {
		var c = format[i];
		switch (c) {
			case "'":
				i++;
				var literal = '';
				// going to the end of the following literal or to the format end
				for (; i < len; i++) {
					if (format[i] === "'") {
						i++;
						// check whether the "'" is not doubled
						if (format[i] === "'") {
							literal += "'";
						} else break;
					} else {
						literal += format[i];
					}
				}
				map.literal(literal);
				break;
			case "H":
			case "h":
			case "m":
			case "s":
			case "t":
				var repeat = count(i);
				map[c](repeat);
				i += repeat;
				break;
			default:
				map.literal(c);
				i++;
		}
	}
}

function _parse(str, format) {
	var hour, minute, second, timeMode, abbrTimeMode;
	var timeModes = [_amDesignator(), _pmDesignator()];
	var abbrTimeModes = [timeModes[0].substring(0, 1), timeModes[1].substring(0, 1)];
	// position in str
	var j = 0;

	function parseInteger(max) {
		if (!/\d/.test(str[j])) {
			throw new Error(locale.text("time.noNumber", str.substring[j]));
		}
		var beg = j++;
		while (j < beg + max && /\d/.test(str[j]))
			j++;
		return parseInt(str.substring(beg, j), 10);
	}

	function parseName(names) {
		for (var k = 0; k < names.length; k++) {
			var name = names[k],
				len = name.length;
			if (str.substring(j, j + len).toUpperCase() == name.toUpperCase()) {
				j += len;
				return k;
			}
		}
		throw new Error(locale.text("time.unknown", str.substring(j)));
	}

	_walkFormat(format, {
		literal: function(literal) {
			if (str.substring(j, j + literal.length) !== literal) throw new Error(locale.text("time.wrongFormat", literal, str.substring(j)));
			j += literal.length;
		},
		H: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					hour = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("time.badHour", format.substring(j))); // replaced i with j
			}
		},
		h: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					hour = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("time.badHour", format.substring(j)));
			}
		},
		m: function(arg) {
			switch (arg) {
				case 2:
					minute = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("time.badMin", format.substring(j)));
			}
		},
		s: function(arg) {
			switch (arg) {
				case 2:
					second = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("time.badSec", format.substring(j)));
			}
		},
		t: function(arg) {
			switch (arg) {
				case 1:
					abbrTimeMode = parseName(abbrTimeModes);
					break;
				case 2:
					timeMode = parseName(timeModes);
					break;
				default:
					throw new Error(locale.text("time.badMarker", format.substring(j)));
			}
		}
	});

	// from 12 format to 24 format, used when necessary

	function from12to24(mode, index) {
		switch (mode[index]) {
			case mode[0]:
				// AM
				hour = hour === 12 ? 0 : hour;
				break;
			case mode[1]:
				// PM
				if (hour >= 1 && hour <= 11) {
					hour += 12;
				}
				break;
		}
	}

	if (timeMode != null || abbrTimeMode != null) {
		if (hour > 12) throw new Error(locale.text("time.badHourVal", hour, timeMode));
		var mode = timeMode != null ? timeModes : abbrTimeModes;
		var index = timeMode != null ? timeMode : abbrTimeMode;
		from12to24(mode, index);
	}

	return _make(hour, minute, second);
}

exports.amDesignator = _amDesignator;
exports.pmDesignator = _pmDesignator;
});

define('syracuse-tablet/html/js/helpers/types/datetime',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/types/date','syracuse-tablet/html/js/helpers/types/time','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var date = require('syracuse-tablet/html/js/helpers/types/date');
var time = require('syracuse-tablet/html/js/helpers/types/time');
var locale = require("syracuse-tablet/html/js/helpers/locale");

var _dateInfo = locale.getDatetimeInfo;

exports.validate = function(value, constraints, errors) {
	if (value == null) {
		if (constraints.$isMandatory) return errors.push(locale.text("datetime.valMand"));
		if (!constraints.$isNullable) return errors.push(locale.text("datetime.valNull"));
		return;
	}
	if (!(value instanceof Datetime)) {
		errors.push(locale.text("datetime.valDT"));
		return;
	}

	// month value check
	if (!(value.month >= 1 && value.month <= 12)) {
		errors.push(locale.text("datetime.valMon"));
		return;
	}

	// day value check
	if (!(value.day >= 1 && value.day <= date.daysInMonth(value.year, value.month))) {
		errors.push(locale.text("datetime.valDay"));
		return;
	}
};

function _pad2(val) {
	var s = val.toString();
	return (s.length == 1) ? "0" + s : s;
}

function _pad3(val) {
	var s = val.toString();
	switch (s.length) {
		case 1:
			return "00" + s;
		case 2:
			return "0" + s;
		default:
			return s;
	}
}

// internal value is GMT millis since origin (Jan 1st, 1970).
// We also cache the local and utc values separately as _local and _utc, when
// they are requested.

function Datetime(value, tzOffset) {
	this._value = value;
	if (tzOffset != null) this._tzOffset = tzOffset;
}

// returns millis value for seconds and milliseconds part

function _ms(dt) {
	// add millis for approx 2000 years to ensure positive before applying modulo
	return (dt._value + 2000 * 365 * 24 * 3600 * 1000) % 1000;
}

// get UTC components packed into an int
// millis are not included as they are independent from UTC/local

function _utc(dt) {
	var utc = dt._utc;
	if (!utc) {
		var d = new Date(dt._value);
		utc = d.getUTCFullYear() * 10000 * 100000 + (d.getUTCMonth() + 1) * 100 * 100000 + d.getUTCDate() * 100000 + d.getUTCHours() * 3600 + d.getUTCMinutes() * 60 + d.getUTCSeconds();
		d._utc = utc;
	}
	return utc;
}

// get local components packed into an int
// millis are not included as they are independent from UTC/local

function _local(dt) {
	var local = dt._local;
	if (!local) {
		var d = new Date(dt._value);
		local = d.getFullYear() * 10000 * 100000 + (d.getMonth() + 1) * 100 * 100000 + d.getDate() * 100000 + d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds();
		d._local = local;
	}
	return local;
}

exports.Datetime = utils.defineClass(Datetime, null, {
	date: {
		get: function() {
			return date.fromInternalValue(Math.floor(_local(this) / 100000));
		}
	},
	time: {
		get: function() {
			return time.fromSeconds(_local(this) % 100000);
		}
	},
	year: {
		get: function() {
			return this.date.year;
		}
	},
	month: {
		get: function() {
			return this.date.month;
		}
	},
	day: {
		get: function() {
			return this.date.day;
		}
	},
	weekDay: {
		get: function() {
			return this.date.weekDay;
		}
	},
	yearDay: {
		get: function() {
			return this.date.yearDay;
		}
	},
	hour: {
		get: function() {
			return this.time.hour;
		}
	},
	minute: {
		get: function() {
			return this.time.minute;
		}
	},
	second: {
		get: function() {
			return this.time.second;
		}
	},
	millisecond: {
		get: function() {
			return _ms(this);
		}
	},

	utcDate: {
		get: function() {
			return date.fromInternalValue(Math.floor(_utc(this) / 100000));
		}
	},
	utcTime: {
		get: function() {
			return time.fromSeconds(_utc(this) % 100000);
		}
	},
	utcYear: {
		get: function() {
			return this.utcDate.year;
		}
	},
	utcMonth: {
		get: function() {
			return this.utcDate.month;
		}
	},
	utcDay: {
		get: function() {
			return this.utcDate.day;
		}
	},
	utcWeekDay: {
		get: function() {
			return this.utcDate.weekDay;
		}
	},
	utcYearDay: {
		get: function() {
			return this.utcDate.yearDay;
		}
	},
	utcHour: {
		get: function() {
			return this.utcTime.hour;
		}
	},
	utcMinute: {
		get: function() {
			return this.utcTime.minute;
		}
	},
	utcSecond: {
		get: function() {
			return this.utcTime.second;
		}
	},
	utcMillisecond: {
		get: function() {
			return _ms(this);
		}
	},
	value: {
		get: function() {
			return this._value;
		}
	},
	timezoneOffset: {
		get: function() {
			if (this._tzOffset == null) this._tzOffset = this.toJsDate().getTimezoneOffset();
			return this._tzOffset;
		}
	},

	compare: function(dt) {
		return this._value - dt._value;
	},
	equals: function(dt) {
		return this._value === dt._value;
	},
	between: function(begin, end) {
		return begin._value <= this._value && this._value <= end._value;
	},

	addYears: function(years) {
		return this.date.addYears(years).at(this.time, this.millisecond);
	},
	addMonths: function(months) {
		return this.date.addMonths(months).at(this.time, this.millisecond);
	},
	addWeeks: function(weeks) {
		return this.date.addWeeks(weeks).at(this.time, this.millisecond);
	},
	addDays: function(days) {
		return this.date.addDays(days).at(this.time, this.millisecond);
	},
	addHours: function(hours) {
		return new Datetime(this._value + hours * 3600 * 1000);
	},
	addMinutes: function(minutes) {
		return new Datetime(this._value + minutes * 60 * 1000);
	},
	addSeconds: function(seconds) {
		return new Datetime(this._value + seconds * 1000);
	},
	addMilliseconds: function(millis) {
		return new Datetime(this._value + millis);
	},
	addDayFractions: function(fraction) {
		return new Datetime(this._value + fraction * 86400 * 1000);
	},

	millisDiff: function(dt) {
		return this._value - dt._value;
	},
	begOfMonth: function() {
		return _make(this.year, this.month, 1);
	},
	begOfWeek: function(startDay) { // 0: Sunday (default), 1: Monday
		var delta = this.weekDay - (startDay || 0);
		return delta == 0 ? this : delta > 0 ? this.addDays(-delta) : this.addDays(-delta - 7);
	},

	/**
     * Adds (or subtracts) to the value of the year, month, day, hour, minute, second, millisecond of the date instance using given configuration object. Positive and Negative values allowed.
     * Example
     <pre><code>
     Date.today().add( { day: 1, month: 1 } )
     </code></pre>
     * @param {Object}   Configuration object containing attributes (month, day, etc.)
     * @return {Date}    this
     */
	add: function(delta) {
		return this.addYears(delta.years || 0).addMonths(delta.months || 0).addWeeks(delta.weeks || 0).addDays(delta.days || 0).addHours(delta.hours || 0).addMinutes(delta.minutes || 0).addSeconds(delta.seconds || 0).addMillis(delta.millis || 0);
	},

	// format as
	toString: function(format) {
		var self = this;
		if (format == null) {
			return new Date(this._value).toISOString();
		} else {
			var utc = _getIndexOfZ(format);
			var _date = utc ? self.utcDate : self.date;
			var _time = utc ? self.utcTime : self.time;

			var result = '';
			_walkFormat(format, {
				literal: function(lit) {
					result += lit;
				},
				H: function(repeat) {
					switch (repeat) {
						case 1:
							result += _time.hour.toString();
							break;
						case 2:
							result += _pad2(_time.hour);
							break;
						default:
							throw new Error(locale.text("datetime.formatH", repeat));
					}
				},
				h: function(repeat) {
					switch (repeat) {
						case 1:
							result += _time.hour < 13 ? _time.hour : (_time.hour - 12);
							break;
						case 2:
							result += _pad2(_time.hour < 13 ? _time.hour : (_time.hour - 12));
							break;
						default:
							throw new Error(locale.text("datetime.formath", repeat));
					}
				},
				m: function(repeat) {
					switch (repeat) {
						case 2:
							result += _pad2(_time.minute);
							break;
						default:
							throw new Error(locale.text("datetime.formatm", repeat));
					}
				},
				s: function(repeat) {
					switch (repeat) {
						case 2:
							result += _pad2(self.second);
							break;
						default:
							throw new Error(locale.text("datetime.formats", repeat));
					}
				},
				t: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.hour < 12 ? _dateInfo().amDesignator.substring(0, 1) : _dateInfo().pmDesignator.substring(0, 1);
							break;
						case 2:
							result += self.hour < 12 ? _dateInfo().amDesignator : _dateInfo().pmDesignator;
							break;
						default:
							throw new Error(locale.text("datetime.formata", repeat));
					}
				},
				d: function(repeat) {
					switch (repeat) {
						case 1:
							result += _date.day.toString();
							break;
						case 2:
							result += _pad2(_date.day);
							break;
						case 3:
							result += date.dayName(_date.weekDay, true);
							break;
						case 4:
							result += date.dayName(_date.weekDay);
							break;
						default:
							throw new Error(locale.text("datetime.formatd", repeat));
					}
				},
				M: function(repeat) {
					switch (repeat) {
						case 1:
							result += _date.month.toString();
							break;
						case 2:
							result += _pad2(_date.month);
							break;
						case 3:
							result += date.monthName(_date.month, true);
							break;
						case 4:
							result += date.monthName(_date.month);
							break;
						default:
							throw new Error(locale.text("datetime.formatM", repeat));
					}
				},
				y: function(repeat) {
					switch (repeat) {
						case 2:
							result += _date.year.toString().substring(2, 4);
							break;
						case 4:
							result += _date.year.toString();
							break;
						default:
							throw new Error(locale.text("datetime.formaty", repeat));
					}
				},
				S: function(repeat) {
					if (repeat === 3) result += _pad3(self.millisecond);
					else new Error(locale.text("datetime.formatS", repeat));
				}
			});
			return result;
		}
	},
	toJsDate: function() {
		return new Date(this._value);
	},
	withoutTimezoneOffset: function() {
		return new Datetime(this._value);
	},
	isNull: function() {
		return this._value == 0;
	}
});

function _formatTzOffset(offset, len) {
	var s = "-";
	if (offset < 0) {
		s = "+";
		offset = -offset;
	}
	var hr = Math.round(offset / 60);
	var min = offset - hr * 60;
	s += len > 1 ? _pad2(hr) : hr;
	s += len > 2 || min ? (":" + (len > 1 ? _pad2(min) : min)) : "";
	return s;
}

function _parseIso(str) {
	var year = 0,
		month = 0,
		day = 0,
		hours = 0,
		minutes = 0,
		seconds = 0,
		ms = 0,
		offset = 0,
		convertError = true;
	var d = /(\d{4})-(\d{2})-(\d{2})([T\s]?)(\d{2})?(:)?(\d{2})?(:)?(\d{2})?(\.(\d{3}))?(Z)?(([+-])(\d{2}))?(.*$)/.exec(str);
	if (d) {
		convertError = false;
		year = +d[1];
		month = d[2] - 1;
		day = +d[3];
		hours = +(d[5] || 0);
		minutes = +(d[7] || 0);
		seconds = +(d[9] || 0);
		ms = +(d[11] || 0);
		if (d[12] === "Z") {
			if (d[14] === '-') offset = (d[15] || 0) * 60;
			else if (d[14] === '+') offset = -(d[15] || 0) * 60;
			var utc = Date.UTC(year, month, day, hours, minutes + offset, seconds, ms);
			return new Datetime(utc);
		} else {
			var jsDate = new Date(year, month, day, hours, minutes + offset, seconds, ms);
			return new Datetime(jsDate.getTime(), jsDate.getTimezoneOffset());
		}
	}
	if (convertError) throw new Error(locale.text("datetime.noParse", str));
}

exports.now = function(withMillis) {
	var jsDate = new Date();
	var millis = jsDate.getTime();
	if (!withMillis) millis = Math.floor(millis / 1000) * 1000;
	return new Datetime(millis, jsDate.getTimezoneOffset());
};

exports.parse = function(str, format) {
	if (str == null) throw new Error(locale.text("datetime.isNull"));

	if (format == null) {
		return _parseIso(str);
	} else {
		return _parse(str, format);
	}
};

exports.fromJsDate = function(jsDate) {
	return new Datetime(jsDate.getTime(), jsDate.getTimezoneOffset());
};

exports.isDatetime = function(obj) {
	return obj instanceof Datetime;
};

exports.fromInternalValue = function(value) {
	return new Datetime(value);
};

exports.dayName = function(weekDay, abbrev) {
	return abbrev ? _dateInfo().abbreviatedDayNames[weekDay] : _dateInfo().dayNames[weekDay];
};

exports.monthName = function(month, abbrev) {
	return abbrev ? _dateInfo().abbreviatedMonthNames[month - 1] : _dateInfo().monthNames[month - 1];
};

function _make(year, month, day, hour, minute, second, millis) {
	var jsDate = new Date(year, month - 1, day, hour || 0, minute || 0, second || 0, millis || 0);
	return new Datetime(jsDate.getTime(), jsDate.getTimezoneOffset());
}

exports.make = _make;
exports.makeUtc = _makeUtc;

function _makeUtc(year, month, day, hour, minute, second, millis) {
	var jsDate = new Date(Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millis || 0));
	return new Datetime(jsDate.getTime(), jsDate.getTimezoneOffset());
}

// hack to install "at" method in date, without require cycles
date.make(1, 1, 1).constructor.prototype.at = function(time, millisecond) {
	return exports.make(this.year, this.month, this.day, time.hour, time.minute, time.second, millisecond);
};

exports.sunday = 0;
exports.Sunday = 0;
exports.monday = 1;
exports.Monday = 1;
exports.tuesday = 2;
exports.Tuesday = 2;
exports.wednesday = 3;
exports.Wednesday = 3;
exports.thursday = 4;
exports.Thursday = 4;
exports.friday = 5;
exports.Friday = 5;
exports.saturday = 6;
exports.Saturday = 6;

function _walkFormat(format, map) {
	var i = 0,
		len = format.length;

	function count(i) {
		var ch = format[i],
			k = 1;
		while (format[i + k] === ch)
			k++;
		return k;
	}

	while (i < len) {
		var c = format[i];
		switch (c) {
			case "'":
				i++;
				var literal = '';
				// going to the end of the following litteral or to the format end
				for (; i < len; i++) {
					if (format[i] === "'") {
						i++;
						// check wether the "'" is not doubled
						if (format[i] === "'") {
							literal += "'";
						} else break;
					} else {
						literal += format[i];
					}
				}
				map.literal(literal);
				break;
			case "H":
			case "h":
			case "m":
			case "s":
			case "S":
			case "t":
			case "d":
			case "M":
			case "y":
				var repeat = count(i);
				map[c](repeat);
				i += repeat;
				break;
			default:
				map.literal(c);
				i++;
		}
	}
}

exports.walkFormat = _walkFormat;

function _parse(str, format) {
	var day, weekday, month, year, hour, minute, second, millis, timeMode, abbrTimeMode;
	var timeModes = [date.amDesignator(), date.pmDesignator()];
	//var timeModes = _dateInfo().amDesignator ? [_dateInfo().amDesignator, _dateInfo().pmDesignator] : ["AM", "PM"];
	var abbrTimeModes = [timeModes[0].substring(0, 1), timeModes[1].substring(0, 1)];
	//var abbrTimeModes = _dateInfo().amDesignator ? [_dateInfo().amDesignator.substring(0, 1), _dateInfo().pmDesignator.substring(0, 1)] : ["A", "P"];

	// position in str
	var j = 0;

	function parseInteger(max) {
		if (!/\d/.test(str[j])) {
			throw new Error(locale.text("datetime.noNumber", str.substring[j]));
		}
		var beg = j++;
		while (j < beg + max && /\d/.test(str[j]))
			j++;
		return parseInt(str.substring(beg, j), 10);
	}

	function parseName(names) {
		for (var k = 0; k < names.length; k++) {
			var name = names[k],
				len = name.length;
			if (str.substring(j, j + len).toUpperCase() == name.toUpperCase()) {
				j += len;
				return k;
			}
		}
		throw new Error(locale.text("datetime.unknown", str.substring(j)));
	}

	_walkFormat(format, {
		literal: function(literal) {
			if (str.substring(j, j + literal.length) !== literal) throw new Error(locale.text("datetime.formatMis", literal, str.substring(j)));
			j += literal.length;
		},
		d: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					day = parseInteger(2);
					break;
				case 3:
					weekday = parseName(_dateInfo().abbreviatedDayNames);
					break;
				case 4:
					weekday = parseName(_dateInfo().dayNames);
					break;
				default:
					throw new Error(locale.text("datetime.badDay", format.substring(j))); // replaced i with j
			}
		},
		M: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					month = parseInteger(2);
					break;
				case 3:
					month = parseName(_dateInfo().abbreviatedMonthNames) + 1;
					break;
				case 4:
					month = parseName(_dateInfo().monthNames) + 1;
					break;
				default:
					throw new Error(locale.text("datetime.badDay", format.substring(j))); // replaced i with j
			}
		},
		y: function(arg) {
			switch (arg) {
				case 2:
					year = parseInteger(2);
					year = year < 40 ? 2000 + year : 1900 + year;
					break;
				case 4:
					year = parseInteger(4);
					year = year > 99 ? year : year < 40 ? 2000 + year : 1900 + year;
					break;
				default:
					throw new Error(locale.text("datetime.badYear", format.substring(j))); // replaced i with j
			}
		},
		H: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					hour = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("datetime.badHour", format.substring(j)));
			}
		},
		h: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					hour = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("datetime.badHour", format.substring(j)));
			}
		},
		m: function(arg) {
			switch (arg) {
				case 2:
					minute = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("datetime.badMin", format.substring(j)));
			}
		},
		s: function(arg) {
			switch (arg) {
				case 2:
					second = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("datetime.badSec", format.substring(j)));
			}
		},
		t: function(arg) {
			switch (arg) {
				case 1:
					abbrTimeMode = parseName(abbrTimeModes);
					break;
				case 2:
					timeMode = parseName(timeModes);
					break;
				default:
					throw new Error(locale.text("datetime.badMarker", format.substring(j)));
			}
		}
	});

	// from 12 format to 24 format, used when necessary

	function from12to24(mode, index) {
		switch (mode[index]) {
			case mode[0]:
				// AM
				hour = hour === 12 ? 0 : hour;
				break;
			case mode[1]:
				// PM
				if (hour >= 1 && hour <= 11) {
					hour += 12;
				}
				break;
		}
	}

	if (timeMode != null || abbrTimeMode != null) {
		if (hour > 12) throw new Error(locale.text("datetime.badHourVal", hour, timeMode));
		var mode = timeMode != null ? timeModes : abbrTimeModes;
		var index = timeMode != null ? timeMode : abbrTimeMode;
		from12to24(mode, index);
	}

	// ignore weekday
	return _make(year, month, day, hour, minute, second, millis);
}

function _getIndexOfZ(format) {
	var i = 0,
		len = format.length;

	function count(i) {
		var ch = format[i],
			k = 1;
		while (format[i + k] === ch)
			k++;
		return k;
	}

	while (i < len) {
		var c = format[i];
		if (c === "'") {
			i++;
			var literal = '';
			// going to the end of the following litteral or to the format end
			for (; i < len; i++) {
				if (format[i] === "'") {
					i++;
					// check wether the "'" is not doubled
					if (format[i] === "'") {
						literal += "'";
					} else break;
				} else {
					literal += format[i];
				}
			}
		} else if (c === 'Z') {
			return i;
		} else {
			i++;
		}
	}
}
});

define('syracuse-tablet/html/js/helpers/types/numberFormat',['require','exports','module','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var locale = require("syracuse-tablet/html/js/helpers/locale");

//======================
//	Useful elements
//======================

/**
 * Format object used to handle format. Useful for the formatting and parsing methods
 * @param {Object} prefix	Any text before directives
 * @param {Object} postfix	Any text after directives
 * @param {Object} properties	Properties are : hasDecimalSeparator, hasGroupSeparator, mandatoryAfter, maxAfter, groupSize, mandatoryBefore, directive, hasPercent, hasPermil, hasSignFormat
 */
function FormatObj(prefix, postfix, properties) {
	this.prefix = prefix;
	this.postfix = postfix;
	this.properties = properties;
}

/**
 * Set number format properties from directive parameter.
 * @param {String}	directive
 * @param {Object}	fObj
 * @return {Object}	Returns a formatObj with properties set
 */
function _processDirective(directive, fObj) {
	// properties to set:   

	// result
	var f = new FormatObj(fObj.prefix, fObj.postfix, fObj.properties);

	var hasDecimalSeparator, hasGroupSeparator;

	var dsIndex = directive.indexOf('.');
	var gsIndex = directive.indexOf(',');

	// decimal and group separator properties
	f.properties.hasDecimalSeparator = hasDecimalSeparator = dsIndex > -1;
	f.properties.hasGroupSeparator = hasGroupSeparator = gsIndex > -1;

	// after properties	
	if (hasDecimalSeparator) {
		var decimal = directive.substring(dsIndex + 1);
		f.properties.mandatoryAfter = decimal.indexOf("0") > -1 ? decimal.match(/0/g).length : 0;
		f.properties.maxAfter = decimal.length;
	}

	// group size property
	if (hasGroupSeparator) {
		f.properties.groupSize = hasDecimalSeparator ? dsIndex - gsIndex - 1 : directive.substring(gsIndex + 1).length;
	}

	// before property
	var integer = hasDecimalSeparator ? directive.substring(0, dsIndex) : directive;
	f.properties.mandatoryBefore = integer.indexOf("0") > -1 ? integer.match(/0/g).length : 0;

	// directive
	f.properties.directive = directive;

	// percent/permil property
	f.properties.hasPercent = directive.indexOf("%") > -1;
	f.properties.hasPermil = directive.indexOf("‰") > -1;

	// sign format
	f.properties.hasSignFormat = directive.indexOf('+') > -1 && directive.indexOf('+') === 0;

	return f;
}

/**
 * Walk through the given format and run functions in map
 * @param {Object} format
 * @param {Object} map
 */
function _walkFormat(format, map) {
	var i = 0,
		len = format.length;

	// valid directive characters in format (except ';')
	var validDir = "0#.,%‰+"; //	'E' or 'e' are not supported yet
	function count(i) {
		var ch = format[i],
			k = 1;
		while (validDir.indexOf(format[i + k]) > -1)
			k++;
		return k;
	}

	while (i < len) {
		var c = format[i];
		switch (c) {
			case "'":
				i++;
				var literal = '';
				// going to the end of the following litteral or to the format end
				for (; i < len; i++) {
					if (format[i] === "'") {
						i++;
						// check wether the "'" is not doubled
						if (format[i] === "'") {
							literal += "'";
						} else break;
					} else {
						literal += format[i];
					}
				}
				map.literal(literal);
				break;
			case "0":
			case "#":
			case ".":
			case "%":
			case "‰":
			case "+":
				var directiveLength = count(i);
				map.directive(i, i + directiveLength);
				i += directiveLength;
				break;
			case ";":
				map.listSeparator();
				i++;
				break;
			default:
				map.literal(c);
				i++;
		}
		// at the end of the loop
		if (i === len) {
			map.listSeparator();
		}
	}
}

/**
 * Add separator parameter after every digits group of size value to the number paramater.
 * @param {Object} num
 * @param {Object} gs
 * @param {Object} size
 */
function _addSeparator(num, gs, size) {
	var result = "";
	var len = num.length;
	var c = "";
	var count = 0;
	for (var i = len - 1; i >= 0; i--) {
		c = num[i];
		result += c;
		++count;
		if ((count % size === 0) && i > 0) {
			result += gs;
		}
	}
	return result.split("").reverse().join("");
}

//======================
//	Format functions
//======================

/**
 * Forat a number
 * @param {Object} val	Raw number
 * @param {Object} format	Format to apply
 * @return {String} Returns a string value containing formatted number
 */
exports.format = function(val, format) {

	//	if (!val)
	//		throw new Error("empty number value");

	if (isNaN(val)) throw new Error(locale.text("numberFormat.notNumber", val));

	if (format == null) {
		val = val.toString();
		var dsIndex = val.indexOf('.');
		var hasDecimal = dsIndex > -1;
		var intPart = hasDecimal ? val.substring(0, dsIndex) : val;
		var decimalPart = hasDecimal ? val.substring(dsIndex + 1) : '';
		var gs = locale.getNumberGroupSeparator() || "";
		var ds = hasDecimal ? (locale.getNumberDecimalSeparator() || ".") : '';
		return _addSeparator(intPart, gs, 3) + ds + decimalPart;
	} else {
		return _format(val, format);
	}

};

function _format(val, format) {
	var prefix, postfix;
	// position in val
	var j = 0;
	// format list (used in case of list of formats separated with ';', empty otherwise)
	var formatsList = [];

	var directiveProcessed = false;

	var f = new FormatObj('', '', {});

	_walkFormat(format, {
		literal: function(literal) {
			// set prefix or postfix value
			directiveProcessed ? f.postfix += literal : f.prefix += literal;
		},
		directive: function(beg, end) {
			// get directive part of the format
			var directive = format.substring(beg, end);

			// process directive
			f = _processDirective(directive, f);

			directiveProcessed = true;
		},
		listSeparator: function() {
			directiveProcessed = false;
			formatsList.push(f);
			f = new FormatObj('', '', {});
			prefix = '';
			postfix = '';
		}
	});

	var flen = formatsList.length;
	switch (flen) {
		case 1:
			return _formatNumber(val, formatsList[0]);
			break;
		case 2:
		case 3:
			if (val === 0) return _formatZero(formatsList[2]);
			else return val < 0 ? _formatNumber(val.toString().substring(1), formatsList[1]) : _formatNumber(val, formatsList[0]);
			break;
		default:
			throw new Error(flen === 0 ? locale.text("numberFormat.noFormat") : locale.text("numberFormat.manyFormat"));
	}
}

function _formatZero(fObj) {
	return fObj.prefix;
}

function _formatNumber(num, fObj) {
	var res = '';

	// locale separators
	var gs = locale.getNumberGroupSeparator();
	var ds = locale.getNumberDecimalSeparator();

	var directive = fObj.properties.directive;

	// special case for percentages
	num = fObj.properties.hasPercent ? num * 100 : num;
	num = fObj.properties.hasPermil ? num * 1000 : num;

	// #6292 - Format can be wrong - TODO add a isValid method to format object
	if (directive == null) return num;

	// == decimal ==
	if (fObj.properties.hasDecimalSeparator) {
		var decimalPart = '';
		var maxAfter = fObj.properties.maxAfter;
		var decimalFormat = directive.substr(directive.indexOf('.') + 1, maxAfter);
		var decimalValue = num % 1;
		var decimalString = '' + decimalValue.toFixed(maxAfter);
		decimalString = decimalString.substring(decimalString.indexOf('.') + 1);
		for (var i = 0; i < maxAfter; i++) {
			var f = decimalFormat.charAt(i);
			var n = decimalString.charAt(i);
			if (f === '0') {
				decimalPart += n;
			} else if (f === '#' && n !== '0') {
				decimalPart += n;
			} else if (f === '#' && n === '0') { // end loop if only '0' left in decimalString
				var notParsed = decimalString.substring(i);
				if (notParsed.match('[1-9]')) decimalPart += n;
				else break;
			}
		}
		res = decimalPart ? ds + decimalPart : res; // in case of integer value, decimalPart --> ''
	} else {
		// it is possible to have decimal number and format not containing decimal separator
		num = Math.round(num);
	}

	// == integer ==
	var intPart = num < 0 ? '' + Math.ceil(num) : '' + Math.floor(num);
	intPart = intPart.replace(/[^\d]+/g, '');
	var intFormat = directive.indexOf('.') === -1 ? directive : directive.substring(0, directive.indexOf('.'));
	// padding if necessary
	if (intPart.length < fObj.properties.mandatoryBefore) {
		var missing = fObj.properties.mandatoryBefore - intPart.length;
		var toAdd = '';
		for (var i = 0; i < missing; i++) {
			toAdd += '0';
		}
		intPart = toAdd + intPart;
	}
	// adding group separator if needed
	if (fObj.properties.hasGroupSeparator) {
		if (fObj.properties.groupSize < intPart.length) {
			intPart = _addSeparator(intPart, gs, fObj.properties.groupSize);
		}
	}

	// in case of no mandatory digit before decimal separator, no character for int part
	intPart = (parseInt(intPart, 10) === 0 && fObj.properties.mandatoryBefore === 0) ? '' : intPart;

	intPart = intPart && num < 0 ? '-' + intPart : intPart;
	res = intPart + res;

	// == specific cases ==
	// sign format
	res = fObj.properties.hasSignFormat && num > 0 ? '+' + res : res;

	// percent and/or permil
	res += fObj.properties.hasPercent ? "%" : '';
	res += fObj.properties.hasPermil ? "‰" : '';

	return fObj.prefix + res + fObj.postfix;
}

//======================
//	Parsing functions
//======================

// * @param {Object} fn	Function called if number returned doesn't match with the integer type (only use)
// exports.parse = function(str, format, fn){
/**
 * Get a number from a formatted number string value
 * @param {Object} str	Formatted number
 * @param {Object} format	Format supposedly used
 * @return {Object}	Returns a number (integer : floor(number), decimal : BigDecimal, real : number)
 */
exports.parse = function(str, format) {
	if (!str) return 0;
	//throw new Error("number string is null");

	if (format == null) {
		return parseFloat(str);
	} else {
		return _parse(str, format);
	}
};

function _parse(str, format) {
	//format = /[0-9-+,.#eE%‰;()\s]/g.exec();
	var prefix, postfix;

	// position in str
	var j = 0;

	// format list (used in case of list of formats separated with ';', empty otherwise)
	var formatsList = [];

	var directiveProcessed = false;

	var f = new FormatObj('', '', {});

	_walkFormat(format, {
		literal: function(literal) {
			// set prefix or postfix value
			directiveProcessed ? f.postfix += literal : f.prefix += literal;
		},
		directive: function(beg, end) {
			// get directive part of the format
			var directive = format.substring(beg, end);

			// process directive
			f = _processDirective(directive, f);

			directiveProcessed = true;
		},
		listSeparator: function() {
			directiveProcessed = false;
			formatsList.push(f);
			f = new FormatObj('', '', {});
			prefix = '';
			postfix = '';
		}
	});

	return _parseFormats(str, formatsList);
}

function _parseFormats(str, formatsList, negative) {
	var flen = formatsList.length;
	var num;
	// locale separators
	var gs = locale.getNumberGroupSeparator();
	var ds = locale.getNumberDecimalSeparator();

	switch (flen) {
		case 1:
			var fObj = formatsList[0];
			var formatNumber = str;
			var integerPart, decimalPart;
			// extract prefix and postfix
			var prefix = fObj.prefix;
			var postfix = fObj.postfix;
			formatNumber = prefix ? formatNumber.substring(prefix.length) : formatNumber;
			formatNumber = postfix ? formatNumber.substring(0, formatNumber.length - postfix.length) : formatNumber;

			// splitting into integer and decimal parts
			var splitted = formatNumber.split(ds);
			// error : too many periods
			if (splitted.length > 2) throw new Error(locale.text("numberFormat.oneSep", formatNumber));
			// setting integer and decimal parts values
			integerPart = splitted[0] ? splitted[0].match(/[0-9]/g).join('') : '0';
			decimalPart = splitted.length > 1 ? splitted[1].match(/[0-9]/g).join('') : '';
			num = parseFloat(decimalPart ? integerPart + "." + decimalPart : integerPart);

			// == specific cases ==
			// negative value
			num = formatNumber.charAt(0) === '-' ? parseFloat('-' + num) : num;
			// percent or permil
			num = fObj.properties.hasPercent ? num / 100 : num;
			num = fObj.properties.hasPermil ? num / 1000 : num;
			// negative value set for list separator cases
			num = negative ? parseFloat('-' + num) : num;
			break;
		case 2:
		case 3:
			// valid characters in formatted number
			var validFormat = "1234567890" + ds + gs + "%‰-+"; // 'E' or 'e' are not supported yet
			var len = formatsList.length;
			var slen = str.length;

			for (var i = 0; i < len; i++) {
				var f = formatsList[i];
				var prefix = f.prefix;
				var postfix = f.postfix;

				var prefixDefined = prefix ? true : false;
				var postfixDefined = postfix ? true : false;

				var pre, post;

				pre = prefixDefined ? str.substring(0, prefix.length) : '';
				post = postfixDefined ? str.substring(slen - postfix.length) : '';

				if (((prefixDefined && !postfixDefined) && pre.indexOf(prefix) > -1) || ((prefixDefined && postfixDefined) && (pre.indexOf(prefix) > -1 && post.indexOf(postfix) > -1)) || ((!prefixDefined && postfixDefined) && post.indexOf(postfix) > -1) || ((!prefixDefined && !postfixDefined) && (validFormat.indexOf(str.charAt(0)) > -1 && validFormat.indexOf(str.charAt(slen - 1)) > -1))) {
					break;
				}
			}
			var flist = [];
			flist.push(formatsList[i]);
			switch (i) {
				case 0:
					num = _parseFormats(str, flist);
					break;
				case 1:
					num = _parseFormats(str, flist, true);
					break;
				case 2:
					num = 0;
					break;
				default:
					throw new Error(locale.text("numberFormat.cannotParse"));
			}
			break;
		default:
			throw new Error(flen === 0 ? locale.text("numberFormat.noFormat") : locale.text("numberFormat.manyFormats"));
	}
	return num;
}
});

define('syracuse-tablet/html/js/helpers/formatApi',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/types/date','syracuse-tablet/html/js/helpers/types/datetime','syracuse-tablet/html/js/helpers/types/time','syracuse-tablet/html/js/helpers/types/numberFormat'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var date = require('syracuse-tablet/html/js/helpers/types/date');
var datetime = require('syracuse-tablet/html/js/helpers/types/datetime');
var time = require('syracuse-tablet/html/js/helpers/types/time');
var numberFormat = require('syracuse-tablet/html/js/helpers/types/numberFormat');

var _cache = {};
var _cacheLocaleHash;

exports.getFormatter = function($type, $format) {
	if ($format == "$url") {
		// #6292 Some numeric field have $format = $url - AQMFIELDM
		// Formatter is skipped - TODO we should add a isValid method to format object
		return null;
	}
	var ctor = _formatters[$type];
	if (!ctor) {
		return null;
	}
	var curLocaleHash = locale.getCurrentLocaleHash();
	if (curLocaleHash !== _cacheLocaleHash) {
		_cacheLocaleHash = curLocaleHash;
		_cache = {};
	}
	var cache = _cache[$type];
	if (!cache) cache = _cache[$type] = {};
	var key = $format || "noformat";
	var fmt = cache[key];
	if (fmt) return fmt;
	fmt = new ctor($type, $format);
	cache[key] = fmt;
	return fmt;
};

var Formatter = utils.defineClass(function($type, $format) {
	this.$format = $format;
	this.$type = $type;
}, null, {

	_isEmpty: function(value) {
		if (value == null)
			return true;
		value = "" + value;
		value = value.trim();
		if (value === "")
			return true;
		return false;
	},

	/*
	 * Format a value for displaying
	 * This will be used on read only fields to format the internal value to a human readable localized pattern.
	 * Also, this will be used to format values in editable fields BEFORE putting the focus into the field for editing
	 * editMode: true if edit mode
	 */
	formatValue: function(value, editMode) {
		return value;
	},

	/*
	 * Format a value for editing it
	 *
	 * This will be used to format values in editable fields AFTER putting the focus into the field for editing.
	 *
	 * Example, in case of dates:
	 * A field displays "April, 1. 2014"
	 * Once the focus is put into the field, it will render the value as "01.04.2014" since it's easier to edit
	 */
	formatValueEdit: function(value) {
		return this.formatValue(value, true);
	},

	/* 
	 * Parse any kind of input string to the internal representation
	 */
	parseValue: function(value, errors) {
		errors.push("No parser for this type, return this dummy error to not override value by null");
	},

	getFormat: function() {
		return this.format;
	}
});

var DateFormatter = utils.defineClass(function($type, $format) {
	Formatter.call(this, $type, $format);
	this.format = locale.getDateFormat();
	this.twoDigitYearSwitch = 40;
}, Formatter, {
	_isEmpty: function(value) {
		if (value == null)
			return true;
		value = "" + value;
		value = value.trim();
		if (value === "")
			return true;

		if (value === "0000-00-00")
			return true;

		return false;
	},

	_checkShortYear: function(year) {
		if (year.year) {
			// Date object
			var y = year.year;
			if (y < 100) {
				year.add({
					years: y < this.twoDigitYearSwitch ? 2000 : 1900
				});
			}
		} else {
			// Number
			year = year > 99 ? year : (year < this.twoDigitYearSwitch ? 2000 + year : 1900 + year);
		}
		return year;
	},

	/**
	 * value expected to be a date string like "2014-08-19"
	 */
	formatValue: function(value, editMode) {
		if (this._isEmpty(value)) {
			return "";
		}
		var p = value.split(/[^\d]+/);
		var format;
		if (p.length >= 3) {
			p[0] = this._checkShortYear(+p[0]);
			var d = date.make(+p[0], +p[1], +p[2]);
			format = d.toString(this.format);
		} else {
			format = value;
		}
		return format;
	},
	parseValue: function(value, errors) {
		var fmt;
		if (this._isEmpty(value)) {
			return "";
		}
		try {
			fmt = date.parse(value, this.format);
			fmt = this._checkShortYear(fmt);
		} catch (e) {
			errors.push(locale.text("field.invalidInput", [this.format]));
			return value;
		}
		return fmt.toString("yyyy-MM-dd");
	},
	validateValue: function(value, errors) {
		var fmt;
		if (this._isEmpty(value)) {
			return "";
		}
		try {
			fmt = date.parse(value, this.format);
			date.validate(fmt, {}, errors)
		} catch (e) {
			errors.push(locale.text("field.invalidInput", [this.format]));
		};
		return (errors.length === 0)
	}
});

var DateTimeFormatter = utils.defineClass(function($type, $format) {
	DateFormatter.call(this, $type, $format);
	this.format = locale.getDateTimeFormat();
}, DateFormatter, {
	_isEmpty: function(value) {
		if (value == null)
			return true;
		value = "" + value;
		value = value.trim();
		if (value === "")
			return true;

		if (value === "0000-00-00T00:00:00Z")
			return true;

		return false;
	},
	/**
	 * value expected to be a date string like "2010-10-13T13:25:03.424Z"
	 * Accept "2010-10-13-14-25-03"
	 */
	formatValue: function(value, editMode) {
		if (this._isEmpty(value)) {
			// We return "" in display mode for compatibility with other fields
			// In edit mode we choose th current date time - L.Seyssel
			return editMode === true ? datetime.now().toString(this.format) : "";
		}
		var p = value.split(/[^\d]+/);
		var format;
		if (p.length >= 6) {
			p[0] = this._checkShortYear(+p[0]);
			var d = datetime.make(+p[0], +p[1], +p[2], +p[3], +p[4], +p[5]);
			format = d.toString(this.format);
		} else {
			format = value;
		}
		return format;
	},
	parseValue: function(value, errors) {
		var fmt;
		if (this._isEmpty(value)) {
			return "";
		}

		try {
			fmt = datetime.parse(value, this.format);
			fmt = this._checkShortYear(fmt);
		} catch (e) {
			errors.push(locale.text("field.invalidInput", [this.format]));
			return value;
		}
		return fmt.toString("yyyy-MM-ddTHH:mm:ss.SSS") + "Z";
	}
});

var TimeFormatter = utils.defineClass(function($type, $format) {
	Formatter.call(this, $type, $format);
	if (this.$format === "TT") {
		this.format = locale.getTimeFormat();
	} else {
		this.format = locale.getTimeFormatShort();
	}
}, Formatter, {
	/**
	 * value expected to be a date string like "13:25:03"
	 */
	formatValue: function(value, editMode) {
		if (this._isEmpty(value)) {
			return "";
		}

		var p = value.split(/[^\d]+/);
		var format;
		if (p.length >= 2) {
			var t = time.make(+p[0], +p[1], +p[2]);
			format = t.toString(this.format);
		} else {
			format = value;
		}
		return format;
	},
	parseValue: function(value, errors) {
		if (this._isEmpty(value)) {
			return "";
		}
		var p = value.split(/[^\d]+/);
		if (p.length >= 1) {
			var t = time.make(+p[0], +p[1], +p[2]);
			return t.toString("HH:mm:ss");
		}
	}
});

var NumberFormatter = utils.defineClass(function($type, $format) {
	Formatter.call(this, $type, $format);
	this.format = this.$format || locale.getNumberFormat(this.$type);
}, Formatter, {
	/*
	 * value to be expected to be a number
	 */
	formatValue: function(value, editMode) {
		if (this._isEmpty(value)) {
			return "";
		}
		var format = numberFormat.format(value, this.format);
		return format;
	},
	parseValue: function(value, errors) {
		if (this._isEmpty(value)) {
			return "";
		}
		try {
			var fmt = numberFormat.parse(value, this.format);
		} catch (e) {
			errors.push(locale.text("field.invalidInput", [this.format]));
			return value;

		}
		return fmt;
	}
});

var _formatters = {
	"application/x-integer": NumberFormatter,
	"application/x-decimal": NumberFormatter,
	"application/x-real": NumberFormatter,

	"application/x-date": DateFormatter,
	"application/x-time": TimeFormatter,
	"application/x-datetime": DateTimeFormatter
};
});

define('syracuse-tablet/html/js/controls/validator',['require','exports','module','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var locale = require('syracuse-tablet/html/js/helpers/locale');

/*
 *
 * Collection of all SData contraints and a validation function per constraint
 *
 */

var _validator = {
	validate: function(ctrl, value, errors, constraints) {
		var proto = ctrl.prototype;
		var ok = true;
		for (var i = 0; i < constraints.length; i++) {
			var c = constraints[i];
			var prop = null;
			if (ctrl && ctrl.getMetaData) {
				prop = ctrl.getMetaData(c);
			}
			if (prop != null) { // constraint set in prototype
				var fn = _validator[c];
				if (fn) {
					ok = fn(value, errors, prop) && ok;
				} else {
					errors.push({
						$severity: "error",
						$message: locale.text("field.unknownConstraint", [c])
					});
					ok = false;
				}
			}
		}
		return ok;
	},

	// General
	$isMandatory: function(value, errors, constraint) {
		if (constraint && (value == null || value === "")) {
			errors.push({
				$severity: "error",
				$message: locale.text("field.valMand")
			});
			return false;
		}
		return true;
	},

	// Strings
	$pattern: function(value, errors, constraint) {
		var self = this;
		if (value && constraint) {
			var re = new RegExp(constraint);
			if (!re.test(value)) {
				errors.push({
					$severity: "error",
					$message: locale.text("field.patternError", [constraint])
				});
				return false;
			}
		}
		return true;
	},

	// Numeric
	$minimum: function(value, errors, constraint) {
		var self = this;
		if (value != null && value < constraint) {
			errors.push({
				$severity: "error",
				$message: locale.text("field.minimum", [constraint])
			});
			return false;
		}
		return true;
	},
	$maximum: function(value, errors, constraint) {
		var self = this;
		if (value != null && value > constraint) {
			errors.push({
				$severity: "error",
				$message: locale.text("field.maximum", [constraint])
			});
			return false;
		}
		return true;
	},
	$exclusiveMinimum: function(value, errors, constraint) {
		var self = this;
		if (value != null && value <= constraint) {
			errors.push({
				$severity: "error",
				$message: locale.text("field.exclusiveMinimum", [constraint])
			});
			return false;
		}
		return true;
	},
	$exclusiveMaximum: function(value, errors, constraint) {
		var self = this;
		if (value != null && value >= constraint) {
			errors.push({
				$severity: "error",
				$message: locale.text("field.exclusiveMaximum", [constraint])
			});
			return false;
		}
		return true;
	},
	$minLength: function(value, errors, constraint) {
		var self = this;
		if (!value || value.length < constraint) {
			errors.push({
				$severity: "error",
				$message: locale.text("field.minLength", [constraint])
			});
			return false;
		}
		return true;
	},
	$maxLength: function(value, errors, constraint) {
		var self = this;
		if (value && value.length > constraint) {
			errors.push({
				$severity: "error",
				$message: locale.text("field.maxLength", [constraint])
			});
			return false;
		}
		return true;
	},
	$precision: function(value, errors, constraint) {
		var self = this;
		if (value) {
			var txt = ("" + value).split(".").join("");
			if (txt.length > constraint) {
				errors.push({
					$severity: "error",
					$message: locale.text("field.precision", [constraint])
				});
				return false;
			}
		}
		return true;
	},
	$scale: function(value, errors, constraint) {
		var self = this;
		if (value) {
			var txt = ("" + value).split(".");
			txt = txt && txt[1] || "";
			if (txt.length > constraint) {
				errors.push({
					$severity: "error",
					$message: locale.text("field.scale", [constraint])
				});
				return false;
			}
		}
		return true;
	}

};

exports.Validator = _validator;
});

define('syracuse-tablet/html/js/ui/fontUtils',['require','exports','module'],function (require, exports, module) {
var _paginBtns = {
	"$first": "glyphicon glyphicon-step-backward",
	"$previous": "glyphicon glyphicon-chevron-left",
	"$next": "glyphicon glyphicon-chevron-right",
	"$last": "glyphicon glyphicon-step-forward"
};

var _tileIcons = [
	'adjust',
	'adn',
	'ambulance',
	'anchor',
	'android',
	'angellist',
	'apple',
	'archive',
	'asterisk',
	'automobile',
	'ban',
	'bank',
	'barcode',
	'bell',
	'bicycle',
	'binoculars',
	'bitbucket',
	'bolt',
	'book',
	'bookmark',
	'briefcase',
	'building',
	'bullhorn',
	'bullseye',
	'calculator',
	'calendar',
	'camera',
	'certificate',
	'chain',
	'child',
	'circle',
	'clipboard',
	'codepen',
	'cog',
	'cogs',
	'columns',
	'compass',
	'dashboard',
	'database',
	'envelope',
	'exclamation',
	'eye',
	'fax',
	'file',
	'flag',
	'flash',
	'folder',
	'globe',
	'heart',
	'home',
	'image',
	'inbox',
	'info',
	'institution',
	'key',
	'laptop',
	'leaf',
	'legal',
	'lock',
	'magic',
	'money',
	'paperclip',
	'phone',
	'plane',
	'rocket',
	'search',
	'shield',
	'sitemap',
	'sliders',
	'star',
	'steam',
	'stethoscope',
	'stop',
	'suitcase',
	'th',
	'tumblr',
	'twitch',
	'twitter',
	'umbrella',
	'warning',
	'wrench'
];

var _getIconByName = function(name) {
	switch (name) {
		case "$multiSelection":
			return "glyphicon glyphicon-list-alt";
		case "$cancelMultiSel":
		case "$cancelEdit":
			return "fa fa-undo";
		case "$edit":
			return "fa fa-edit";
		case "$query":
			return "fa fa-list";
		case "$save":
			return "fa fa-save";
		case "$details":
			return "fa fa-level-down";
		case "$delete":
			return "fa fa-trash-o";
		case "$create":
			return "fa fa-plus-square";
		case "$image-sign":
			return "fa fa-pencil";
		case "$image-camera":
			return "fa fa-camera";
		case "$image-ink":
			return "fa fa-paint-brush";
		case "appUpdate":
			return "fa fa-history";
		case "appSetup":
			return "fa fa-download";
		case "gear":
			return "fa fa-gear";
		case "expand":
			return "fa fa-expand";
		case "compress":
			return "fa fa-compress";
		case "GPSPicker":
			return "fa fa-dot-circle-o";
		case "scanBarcodePicker":
			return "fa fa-barcode";
		case "penTextInputPicker":
			return "fa fa-pencil-square-o";
		case "$showtemplates":
			return "fa fa-file-text-o";
		case "$showtemplatesEmpty":
			return "fa fa-file-o";
		case "$apply":
			return "fa fa-check";
		case "$refresh":
			return "fa fa-save";
		case "lookupPicker":
			return "glyphicon glyphicon-eye-open";
		case "datePicker":
			return "glyphicon glyphicon-calendar";
		case "timePicker":
			return "glyphicon glyphicon-time";
		case "clientTestApplication":
			return "fa fa-th"
	}
	// Icon names used for tiles or tile headers
	if (_tileIcons.indexOf(name) > -1) {
		return "fa fa-" + name;
	}

	return "";
};

exports.getIconByName = _getIconByName;
exports.checkBoxIcon = function(val) {
	return ["glyphicon", val ? "glyphicon-ok" : "glyphicon-remove"];
};
exports.phoneFieldIcon = function() {
	return "fa fa-phone";
};
exports.emailFieldIcon = function() {
	return "fa fa-envelope-o";
};
exports.documentFieldIcon = function() {
	return "fa fa-file-text";
};
exports.binaryFieldIcon = function() {
	return "fa fa-file-0";
};
exports.paginationIcon = function(linkName) {
	return _paginBtns[linkName];
};
exports.layoutExpandCollapseIcon = function(collapse, advancedTheme) {
	if (collapse) {
		return advancedTheme ? "fa fa-ellipsis-h" : "fa fa-chevron-down";
	} else {
		return advancedTheme ? "fa fa-times" : "fa fa-chevron-up";
	}
};
exports.pageIcon = function(name) {
	if (name === "settings") return "fa fa-gear";
	if (name === "clearCache") return "fa fa-history";
	if (name === "switchContext") return "fa fa-user";
	if (name === "search") return "fa fa-search";
	if (name === "sidePanelL") return "fa fa-caret-square-o-left";
	if (name === "sidePanelR") return "fa fa-angle-double-right";
	//if (name === "sidePanelR") return "fa fa-caret-square-o-right";
	if (name === "home") return "fa fa-home";
	if (name === "designPage") return "fa fa-paint-brush";
	if (name === "back") return "fa fa-arrow-circle-o-left";
	if (name === "developmentPage") return "fa fa-wrench";
	if (name === "bars") return "fa fa-bars";
	if (name === "backIphone") return "fa fa-angle-left";
	if (name === "about") return "fa fa-info-circle";
	if (name === "logout") return "fa fa-sign-out";
	if (name === "pinPage_1") return "fa fa-thumb-tack";
	if (name === "pinPage_2") return "fa fa-times";
	if (name === "pageConfig") return "fa fa-paint-brush";
	if (name === "nativeShare") return "fa fa-share-alt";
	if (name === "mailto") return "fa fa-envelope";
	if (name === "freshness") return "fa fa-bookmark";
	if (name === "drafts") return "fa fa-building-o";
	if (name === "dashboardList") return "fa fa-list-ul";
	if (name === "mydashboard") return "fa fa-chevron-left";
};
exports.dashboardIcon = function(name) {
	if (name === "removeTile") return "fa fa-trash-o";
	if (name === "editTile") return "fa fa-pencil";
	if (name === "moveTile") return "fa fa-sitemap";
	if (name === "dashboardList") return "fa fa-list-ul";
	if (name === "templateList") return "fa fa-list-ul";
	if (name === "addGroup") return "fa fa-sitemap";
	if (name === "addHiddenTile") return "fa fa-th-large";
	if (name === "moveGroupAfter") return "fa fa-arrow-left";
	if (name === "moveGroupBefore") return "fa fa-arrow-right";
	if (name === "removeGroup") return "fa fa-trash-o";
	if (name === "emptyTile") return "fa fa-exclamation-triangle";
}
exports.tableActionIcon = function(name) {
	if (name === "rowEdit") return "fa fa-pencil-square-o";
	if (name === "rowDetail") return "fa fa-hand-o-right";
	if (name === "rowDelete") return "fa fa-remove";
	if (name === "rowAdd") return "fa fa-plus";
	return "fa fa-question";
};
exports.vignetteIcons = function(name) {
	if (name === "home") return "fa fa-home";
	if (name === "back") return "fa fa fa-arrow-circle-o-left";
	if (name === "refresh") return "fa fa-history";
};

exports.sortIcon = function(name) {
	if (name === "asc") return "fa fa-long-arrow-up";
	if (name === "none") return "fa fa-times";
	if (name === "desc") return "fa fa-long-arrow-down";
};

exports.filterIcon = function(name) {
	if (name === "panel") return "fa fa-bars";
	if (name === "filtered") return "fa fa-filter";
	if (name === "edit") return "fa fa-pencil";
	if (name === "delete") return "fa fa-times";
	if (name === "separator") return "fa fa-plus";
};
exports.sortFilterTab = function(name) {
	if (name === "sort") return "fa fa-arrows-v";
	if (name === "filter") return "fa fa-filter";
	if (name === "memo") return "fa fa-star";
	if (name === "apply") return "fa fa-check";
};
/* 
 * List of icon names that can be selected by tile customisation
 * These are only the FA icons that look appropriate
 */
exports.getTileIconList = function() {
	return _tileIcons;
};
var _arrayStatusIconNames = ["thumbs-down", "thumbs-o-down", "thumbs-up", "thumbs-o-up", "hand-o-down", "hand-o-up", "lock", "unlock", "unlock-alt", "smile-o", "meh-o", "check", "check-circle", "check-circle-o", "check-square", "check-square-o", "square", "square-o", "circle", "circle-thin", "circle-o", "close", "comment", "comment-o", "comments", "comments-o", "photo", "film", "barcode", "bars", "plus", "plus-circle", "plus-square", "plus-square-o", "minus", "minus-circle", "minus-square", "minus-square-o", "question", "question-circle", "trash", "trash-o", "info", "info-circle", "flag", "flag-checkered", "flag-o", "female", "male", "mars", "venus", "user", "users", "user-plus", "user-times", "user-secret", "facebook-official", "file", "file-o", "dollar", "eur", "gbp", "yen", "rub", "rupee", "shekel", "cny", "ils", "inr", "krw", "money", "turkish-lira", "won", "envelope-square", "envelope-o", "envelope", "exclamation", "exclamation-circle", "exclamation-triangle"];
var _arrayStatusIcons = null;
var _getArrayStatusIconList = function() {
	if (_arrayStatusIcons == null) {
		_arrayStatusIcons = [];
		_arrayStatusIconNames.forEach(function(name) {
			_arrayStatusIcons.push({
				css: "fa fa-" + name,
				name: name
			});
		});
	}
	return _arrayStatusIcons;
};
exports.getArrayStatusIconList = _getArrayStatusIconList;

exports.getArrayStatusDefIcon = function() {
	return {
		name: "circle",
		css: "fa fa-circle"
	};
};

/* Actions control - authoring */
var _arrayActionsIconNames = _arrayStatusIconNames.slice(0);
var _arrayActionsIcons = null;
var _getPageActionIcon = function() {
	if (_arrayActionsIcons == null) {
		_arrayActionsIconNames = _arrayActionsIconNames.concat(["download", "save", "undo", "edit", "history", "eraser", "reply", "refresh"]);
		_arrayActionsIcons = [];
		_arrayActionsIconNames.forEach(function(name) {
			_arrayActionsIcons.push({
				css: "fa fa-" + name,
				name: name
			});
		});
	}
	return _arrayActionsIcons;
};
exports.getPageActionIcon = _getPageActionIcon;

var _emptyImageIconNames = ["image", "user", "users", "warning", "file-movie-o", "file-image-o", "paperclip", "film"];
var _emptyImageIcons = null;
exports.getEmptyImageIconList = function() {
	if (_emptyImageIcons == null) {
		_emptyImageIcons = [];
		_emptyImageIconNames.forEach(function(name) {
			_emptyImageIcons.push({
				css: "fa fa-" + name,
				name: name
			});
		});
	}
	return _emptyImageIcons;
};
exports.getEmptyImageDefIcon = function() {
	return {
		name: "image",
		css: "fa fa-image"
	};
};
exports.getEmptyFileDefIcon = function() {
	return {
		name: "file",
		css: "fa fa-file"
	};
};

var _urlIconNames = ["globe", "map-marker", "street-view", "road", "link", "cloud", "database", "bed", "cutlery", "glass", "train", "subway", "taxi", "ship", "plane"];
var _urlIcons = null;
exports.getUrlIconList = function() {
	if (_urlIcons == null) {
		_urlIcons = [];
		_urlIconNames.forEach(function(name) {
			_urlIcons.push({
				css: "fa fa-" + name,
				name: name
			});
		});
	}
	return _urlIcons;
};
exports.getUrlDefIcon = function() {
	return {
		name: "Url",
		css: "fa fa-globe"
	};
};
var _colImageIconNames = ["image", "user", "users", "warning", "file-movie-o", "file-image-o", "paperclip", "film"];
var _colImageIcons = null;
exports.getColImageIconList = function() {
	if (_colImageIcons == null) {
		_colImageIcons = [];
		_colImageIconNames.forEach(function(name) {
			_colImageIcons.push({
				css: "fa fa-" + name,
				name: name
			});
		});
	}
	return _colImageIcons;
};
exports.getColImageDefIcon = function(emptyImage) {
	return {
		name: "image",
		css: emptyImage === true ? "fa fa-times" : "fa fa-image"
	};
};
exports.getPinVignetteIcon = function(what) {
	return what == "all" ? "fa fa-toggle-on fa-toggle-off" : what == "on" ? "fa fa-toggle-on" : "fa fa-toggle-off";
};
exports.getCarouselIcon = function(what) {
	return what == "left" ? "glyphicon glyphicon-chevron-left" : what == "right" ? "glyphicon glyphicon-chevron-right" : "";
};
exports.getDraftIcons = function(name) {
	switch (name) {
		case "synch":
			return "fa fa-upload";
		case "remove":
			return "fa fa-trash";
		case "stop":
			return "fa fa-stop";
	}
};
});

define('syracuse-tablet/html/js/controls/fields/ctrlFieldBase',['require','exports','module','syracuse-tablet/html/js/controls/ctrlSdataBase','syracuse-tablet/html/js/app/globals','syracuse-tablet/html/js/helpers/environment','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/controls/validator','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/ctrlSdataBase').CtrlSdataBase;

var globals = require('syracuse-tablet/html/js/app/globals');
var environment = require('syracuse-tablet/html/js/helpers/environment');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var validator = require('syracuse-tablet/html/js/controls/validator').Validator;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var modules = require("syracuse-tablet/html/js/common/modules");
var native = require("syracuse-tablet/html/js/helpers/native/native");
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("ctrlFieldBase", false);

var _label_pos = ["top", "left"];
var _texr_align = ["right", "left", "center"];
/**
 * Give the authoring property that enables the capability if any
 */
var _nativeCapabilityAutoring = {
	"scanBarcode": "$scanBarcode",
	"GPS": "$scanGPS"
};

/**
 * 
 * Base class for controls that display exactly one value/property (Use article: { $bind: .. } )
 * 
 * options: {
 *   noEdit: Display field read only
 *   displayCtx: "table" render table specific (Mostly not show diagnosis)
 *   noTitle: Do not render title
 * }
 */
exports.CtrlFieldBase = utils.defineClass(
	function CtrlFieldBase(controller, article, prototype, options) {
		Base.call(this, controller, article, prototype, options);
		if (options.noEdit === true) {
			this.$isEditMode = false;
		}
		this.formatter = formatApi.getFormatter(this.$type, this.prototype.getValueByPath('$format'));
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.formatter = null;
		},

		//
		// START: Callbacks called by sdataController
		//
		/**
		 * Invoked by controller if value changed
		 */
		onValueChanged: function() {
			this.refreshValue();

			// Value updated by server, still we check client side contraints to show
			// invalid values reported by the server or to remove old client side diagnoses
			// e.g. If an empty mandatory field has been set with a value by the server
			var errors = [];
			this.validateValue(this.getValue(), errors);
			this.controller.setClientDiagnoses(this.$bind, errors);
			this.renderDiagnoses();
		},
		refreshValue: function() {
			if (!this.$$elmt) return;
			if (!this.$$value) return;

			this.buildFieldValue();
			this.checkEmptyValue();
		},
		/**
		 * Invoked by controller if meta data changed
		 */
		onMetaChanged: function() {
			this.refreshMetaData();

		},
		refreshMetaData: function() {
			if (!this.$$elmt) return;
			var meta = this.getMetaData();
			this.applyMetaData(meta);
		},
		//
		// END: Callbacks called by sdataController
		//

		//
		// START: Value set/get functions called from "UI"
		//

		/**
		 * Ask controller to return the value of the control
		 */
		getValue: function() {
			var value = this.controller.getValue(this.$bind);
			return value;
		},
		/**
		 * Ask controller to store a new value for the control
		 * 
		 * The controller will never call this method to set the value of the control
		 * It wil always use "onValueChanged" to let the control re-render
		 * 
		 * This method is likely to be called in blur events or similar
		 * 
		 * value parameter must be a correct data type value without UI specific formatting
		 */
		setValue: function(value) {
			this.controller.setValue(this.$bind, value);
		},

		//
		// END: Value set/get functions called from "UI"
		//

		//
		// START: Set, parse, format values from UI related interactions
		//
		/**
		 * Set internal value (controller) and visible formatted value (UI) by applying formatting if needed
		 * value parameter must be a correct data type value without UI specific formatting
		 */
		setFieldValue: function(value) {
			this.setDisplayValue(this.getFormattedValue(value));
			this.setValue(value);
		},
		/**
		 * Field value (input) is set by an external widget (date picker, lookup...)
		 * We force the focus in the field - Use to switch the status of an editable vignette
		 */
		//TODO: DO we really need this?
		setFieldValueFromSelector: function(value) {
			this.setFieldValue(value);
			// Enable to put focus into field after a value has been selected by lookup
			// On last discussion, we decided to not put the focus is the better choice
			// this.setFocus();
		},

		/**
		 * Get value as string to be displayed in control (e.g. formatted specific to locale)
		 * Used by rendering to get string to be displayed
		 */
		getFormattedValue: function(value) {
			if (!this.formatter) {
				return value == null ? "" : new String(value);
			}
			try {
				return this.$isEditMode === true ? this.formatter.formatValueEdit(value) : this.formatter.formatValue(value);
			} catch (e) {
				this.controller.setClientDiagnoses(this.$bind, [{
					$severity: "error",
					$message: e.message
				}]);
				this.renderDiagnoses();
				return "";
			}
		},

		/**
		 * value: value inputed into the field as string
		 * errors: array where to add parsing errors as strings
		 *
		 * return: Parsed value as represented in sdata data
		 * E.g. "2014-12-31" for dates or 123 for numbers
		 */
		parseValue: function(value, errors) {
			if (!this.formatter) {
				return value;
			}
			return this.formatter.parseValue(value, errors);
		},
		//
		// END: Set, parse, format values from UI related interactions
		//

		//
		// START: Rendering
		//
		/**
		 */
		buildHtml: function(classes) {
			classes = classes || [];
			classes.push("s-m-field");

			// add the type of field if needed for css selector
			if (this.cssType) {
				classes.push(this.cssType);
			}
			if (this.getAuthoring("$value.$valueFirst", false)) {
				classes.push("s-m-valueFirst");
			}

			Base.prototype.buildHtml.call(this, classes);
			this._oldValue = this.getValue();

			this.buildFieldTitle();
			this.buildFieldValue();

			// authoring
			this._applyLabelAuthoring();
			this.applyMetaData(this.getMetaData());
			this.renderDiagnoses();
			this.checkEmptyValue();
			this._checkNumVisiblePickers();
		},

		/**
		 * Create the main input field that is bind to blur event and other event
		 * s-m-meta indicates the element to which meta will be applied in edit mode
		 */
		createMainInput: function(value, type, attrs, $$parent) {
			type = type || "text";
			this._addNativePickers();

			var checkBox = "checkbox" === type;

			var css = ["s-m-meta"];
			attrs = attrs || {};
			attrs.type = type;
			var element = "input";
			if ("text" === type) {
				css.push("form-control");
				attrs["data-nevent-ctrl-blur"] = "";
				attrs.value = value;
			} else if ("textplain" === type) {
				element = "textarea";
				css.push("form-control");
				attrs["data-nevent-ctrl-blur"] = "";
			} else if (checkBox) {
				attrs["data-nevent-ctrl-click"] = "";
			}
			if (this.options.notifyFocus === true) {
				attrs["data-nevent-ctrl-focus"] = "";
			}
			this.$$input = $(uiUtils.createDomElement(element, css, null, attrs)).prependTo(this._$$inputGroup || $$parent || this.$$value);
			if (checkBox) {
				this.$$input.prop("checked", value);
			}
			return this.$$input;
		},

		/**
		 * Displays title under fieldSlot ($$elmt)
		 */
		buildFieldTitle: function() {
			this.$$elmt.removeClass("s-m-title-hidden");
			if (this.getAuthoring("$isTitleHidden")) {
				this.$$elmt.addClass("s-m-title-hidden");
				return;
			}
			// don't build field title if grid cell
			if (this.options.displayCtx === "table" ||
				this.options.noTitle === true) {
				return;
			}

			var ttl = (this.getTitle() || "").trim();
			if (ttl.length > 0) {
				if (this.getMetaData("$isMandatory") === true) {
					ttl += "*";
				}
				this.$$title = $(uiUtils.createDomElement("div", ["s-m-title"], ttl, null, this.$$elmt));
			}
			if (!ttl.length) {
				this.$$elmt.addClass("s-m-title-hidden");
			}
		},

		/**
		 * Just create the value slot under $$elmt
		 * Child class has to add the value
		 */
		_ensure$$value: function() {
			if (!this.$$value) {
				this._create$$value();
			}
		},
		_create$$value: function() {
			var classes = ["s-m-value"];
			if (this.$isEditMode) {
				classes.push("edit");
			}
			this.$$value = $(uiUtils.createDomElement("div", classes, null, null, this.$$elmt));
			return this.$$value;
		},
		_clear$$value: function() {
			if (this.$$value) {
				this.$$value.empty();
			}
			this.$$input = null;
			this._$$inputGroup = null;
			this._$$inputGroupBtn = null;
		},
		/**
		 * Add a text value to the valueSlot
		 * Used by default to display value with $details facet
		 */
		appendTextValue: function(value) {
			if (value == null) return;
			if (typeof value !== "string") {
				value = value.toString ? value.toString() : "??Can't display??";
			}
			value = value.trim();
			if (value.length > 0) {
				uiUtils.appendTextNode(this.$$value, value);
			}
		},

		/**
		 * Can be overridden - gauge
		 * forceEmpty used by asynchronous processes (ctrlText)
		 */
		checkEmptyValue: function(forceEmpty) {
			if (this.$isEditMode) return;
			/**
			 * We add a blank value if top aligned in order to align fields in a cell
			 */
			this.$$elmt.css("display", "");
			this.isEmpty = forceEmpty === true || this.$$value == null || this.$$value.is(":empty");
			this.$$elmt.toggleClass("s-m-empty", this.isEmpty);
			if (!this.isEmpty) return;
			// Capability to hide the field if no value
			if (this.getAuthoring("$hideIfEmpty") === true) {
				// No title and No value -> No display
				this.$$elmt.css("display", "none");
				return;
			}
			if (this.getAuthoring("$labelPosition") === "top") {
				// For alignment 
				this._ensure$$value();
				this.$$value.html("&nbsp;");
			}
		},
		/*
		 * Apply authoring properties related to the label:
		 * - labelPosition which can have values top,right,bottom,left
		 * - textAlignment which can have values left, right
		 */
		_applyLabelAuthoring: function() {
			// Code below could be optimized by using classList
			var val = this.getAuthoring("$labelPosition");
			this.$$elmt.removeClass("s-m-top");
			if (val == "top") {
				this.$$elmt.addClass("s-m-top");
			}
			this.$$elmt.removeClass("s-m-left s-m-right s-m-center");
			if (val === "top") {
				val = this.getAuthoring("$labelAlign");
				if (val != null && _texr_align.indexOf(val) >= 0) {
					this.$$elmt.addClass("s-m-" + val);
				}
			}
		},
		_ensureInputGroup: function() {
			var $$input;
			if (!this._$$inputGroup) {
				$$input = this.$$input ? this.$$input.detach() : null;
				this._$$inputGroup = $('<div class="input-group"/>').appendTo(this.$$value);
			}
			if (!this._$$inputGroupBtn) {
				this._$$inputGroupBtn = $('<span class="input-group-btn"/>').appendTo(this._$$inputGroup);
			}
			if ($$input) {
				$$input.prependTo(this._$$inputGroup);
			}
		},
		addPickerSdataLink: function($linkName, icon) {
			this._ensureInputGroup();
			var attrs = this.getSdataLinkAttrs($linkName);

			var $$picker = $('<button class="btn btn-default s-m-meta"><span class="' + icon + '"></span></button>');
			$.each(attrs, function(key, value) {
				$$picker.attr(key, value);
			});

			return $$picker.appendTo(this._$$inputGroupBtn);
		},
		/**
		 * Add a picker on the left hand side of the control
		 * Must be called before calling createMainInput
		 */
		addPicker: function(type, icon) {
			this._ensureInputGroup();
			var $$picker = $('<button data-control-id="' + this.id + '" data-nevent="" data-naction="' + type + 'Picker" class="btn btn-default s-m-meta"><span class="' + icon + '"></span></button>');
			return $$picker.appendTo(this._$$inputGroupBtn);
		},

		/**
		 * 
		 */
		applyMetaData: function(metaData) {
			Base.prototype.applyMetaData.call(this, metaData);
			if (metaData == null) return;

			if (this.$isEditMode) {
				// default
				var $$e = this.$$elmt.find(".s-m-meta");
				if ($$e.length > 0) {
					// Apply $isDisabled and $isReadOnly
					// is("input") returns true for button tags -> we check the BS class .btn
					if ($$e.is("input") && !$$e.is(".btn")) {
						// only for input tags
						$$e[metaData.$isReadOnly === true ? "attr" : "removeAttr"]("readonly", "");
						$$e[metaData.$isDisabled === true ? "attr" : "removeAttr"]("disabled", "");
					} else {
						// other tags
						$$e[metaData.$isReadOnly === true || metaData.$isDisabled === true ? "attr" : "removeAttr"]("disabled", "");
					}
				}
			}

			if (this.article.$isHidden != null || metaData.$isHidden != null) {
				this.$$elmt.toggleClass('s-m-hidden', this.article.$isHidden === true || metaData.$isHidden === true);
			}

			if (this.options.displayCtx === "table") {
				return;
			}
			this.renderDiagnoses();
		},

		renderDiagnoses: function() {
			var self = this;
			if (!this.$$elmt) {
				return;
			}
			if (this.$$message) {
				this.$$message.empty();
			}

			var diags = this.controller.getDiagnoses(this.$bind);
			if (diags.length === 0) {
				this.$$elmt.removeClass("error");
				return;
			}
			if (!this.$$message) {
				this.$$message = $('<span class="s-m-error"/>').appendTo(this.$$elmt);
			}

			var count = 0;
			diags.forEach(function(diag) {
				if (diag.$severity === "error") {
					self.$$message.append($("<p>").text(diag.$message));
					count = count + 1;
				}
			});
			if (count > 0) {
				this.$$elmt.addClass("error");
			} else {
				this.$$elmt.removeClass("error");
			}
		},
		clearClientDiagnoses: function() {
			this.controller.setClientDiagnoses(this.$bind, []);
			this.renderDiagnoses();
		},

		_checkNumVisiblePickers: function() {
			if (!this._$$inputGroupBtn) return;
			var $$pickers = $("button", this._$$inputGroupBtn);
			var count = 0;
			$.each($$pickers, function(idx, picker) {
				// We do not is $.is..or :visible because elements may not be attached to the dom yet
				if ($(picker).css("display") !== "none") {
					count = count + 1;
				}
			});
			this._$$inputGroupBtn.toggle(count > 0);
		},
		//
		// END: Rendering
		//

		/**
		 * Change visible value (UI only)
		 * value parameter must be formatted already!
		 */
		setDisplayValue: function(value) {
			if (this.$$input) {
				this.$$input.val(value);
			}
		},

		//
		// START: Authoring
		//
		/**
		 * Pickers are displayed in authoring mode even if capability is not enabled to make user aware
		 * We toggle them when we clode authoring
		 */
		notifAuthClose: function() {
			if (!this.$$elmt) return;
			for (var p in _nativeCapabilityAutoring) {
				// Restore according to native capabilities - false to say that it's not authoring mode
				this.$$elmt.find('button[data-action="' + p + 'Picker"]').toggle(this.isNativeCapabilityEnabled(p, false));
			}
			this._checkNumVisiblePickers();
		},
		/**
		 * Pickers are displayed in authoring mode even if capability is not enabled to make user aware
		 * We toggle them when we open authoring
		 */
		notifAuthSetPage: function() {
			if (!this.$$elmt) return;
			for (var p in _nativeCapabilityAutoring) {
				this.$$elmt.find('button[data-action="' + p + 'Picker"]').toggle(this.isNativeCapabilityEnabled(p, true));
			}
			this._checkNumVisiblePickers();
		},
		//
		// End: Authoring
		//


		//
		// START: UI Stuff
		//
		onFocus: function(justCheck) {
			notifications.publish("sm.field.focus", this);
		},

		/**
		 * Return true if value OK
		 * justCheck	true to not set the value
		 */
		onBlur: function() {
			this.validateInput();
		},

		/**
		 * Parse and validate after user input
		 */
		validateInput: function() {
			this.clearClientDiagnoses();
			if (!this.$$input) {
				this.renderDiagnoses();
				return true;
			}

			var value = this.$$input.val();
			var errors = [];
			value = this.parseValue(value, errors);
			if (errors.length === 0) {
				this.validateValue(value, errors);
				// Set displayed value, also it may violate constraints later
				// This is because a parseable value is reformatted here to eliminate wrong characters
				// Internal value remains unchanged until all constraints are met
				this.setDisplayValue(this.getFormattedValue(value));
				if (errors.length === 0) {
					this.setValue(value);
				}
			}
			this.controller.setClientDiagnoses(this.$bind, errors);
			this.renderDiagnoses();
			return errors.length == 0;
		},

		/**
		 * value: value inputed into the field as string
		 * errors: array where to add validation errors as strings
		 * return true if ok
		 */
		validateValue: function(value, errors) {
			return validator.validate(this, value, errors, ["$isMandatory"]);
		},

		/**
		 * Set the focus on this field and scroll
		 */
		setFocus: function() {
			// !! First make visible
			Base.prototype.setFocus.call(this);
			if (this.acceptFocus()) {
				// !! Second setFocus
				// !! setFocus scrolls the page and we don't want that because we don't use native scrolling 
				// We need to make th control visible before focus in order to not scroll the page
				// If it doesn't work fine we can save/srestore the page scrolling
				if (this.getFocusElmt().is("input, select")) {
					// focus evt is triggered by dom focus
					this.getFocusElmt().focus();
				} else {
					// focus evt is triggered by application because the elmt doesn't actually take the focus
					// In next brother versions all kind of elements should accept focus
					notifications.publish("sm.field.focus", this);
				}
			}
		},
		/**
		 * Can be overridden (ctrlBinary...)
		 * Regular fields have an input
		 */
		getFocusElmt: function() {
			return this.$$input;
		},
		acceptFocus: function() {
			return this.getFocusElmt() != null;
		},
		//
		// END: UI Stuff
		//
		/**
		 * authoringOnly: force to skip native interface capability
		 * -> Used to display the pickers in authoring mode
		 */
		isNativeCapabilityEnabled: function(capability, authoringOnly) {
			var res;
			authoringOnly = authoringOnly === true;
			if (authoringOnly === true && globals.isAuthoringActive()) {
				// Forces to display pickers in authoring mode to make user aware
				var authoring = this.getNativeCapabilityAuthoring(capability);
				res = authoring != null && this.article[authoring] === true;
			} else if (this._nativeCapabilities == null || this._nativeCapabilities[capability] !== true) {
				res = false;
			} else {
				var authoring = this.getNativeCapabilityAuthoring(capability);
				res = authoring == null || this.article[authoring] === true;
			}
			res = res === true;
			log && log("isNativeCapabilityEnabled: " + capability + " (" + authoringOnly + "): " + res);
			//return true;
			return res;
		},
		addNativePicker: function(nativeCapability) {
			return this.addPicker(nativeCapability, fontUtils.getIconByName(nativeCapability + "Picker"));
		},
		_getNativePicker: function() {
			if (!this._nativeCapabilities) return null;
			if (this.isNativeCapabilityEnabled("scanBarcode")) {
				return "scanBarcode";
			} else if (this.isNativeCapabilityEnabled("GPS")) {
				return "GPS";
			} else if (this.isNativeCapabilityEnabled("penTextInput")) {
				return "penTextInput";
			}
			return null;
		},
		_addNativePickers: function() {
			if (!this._nativeCapabilities) return;
			if (environment.isMobile()) {
				var nativeCapability = this._getNativePicker();
				if (nativeCapability) {
					// First
					this.addNativePicker(nativeCapability);
				}
				return;
			}
			// In desktop mode, for authoring, we add all the pickers and show hide them according to the $ property on sm.auth.close/sm.auth.set.page events
			var self = this;
			["penTextInput", "GPS", "scanBarcode"].forEach(function(nativeCapability) {
				self.addNativePicker(nativeCapability).toggle(self.isNativeCapabilityEnabled(nativeCapability, true));
			});
			// USed to toggle the pickers
			notifications.subscribe(this, ["sm.auth.close", "sm.auth.set.page"]);
		},
		getNativeCapabilityAuthoring: function(capability) {
			// use this.options.nativeCapabilities because it's not filtered by native.hasCapability
			// Authoring doesn't require the native wrapper
			if (!this.options || this.options.nativeCapabilities == null || this.options.nativeCapabilities[capability] !== true) {
				return null;
			}
			return _nativeCapabilityAutoring[capability];
		},
		_actPenTextInputPicker: function() {
			var self = this;
			native.getModule("penTextInput").getPenTextInput({
				title: self.getTitle(),
				value: self.getValue()
			}).then(
				function(data) {
					if (data.action === "ok") {
						if (data.matches && data.matches.length) {
							var values = [];
							data.matches.forEach(function(val) {
								val = self.parseValue(val);
								if (val != null || val != "") {
									values.push(val);
								}
							});
							if (values.length === 0) return;
							// Only the first one if it's a number
							values = self.typeName === "string" ? values.join(' ') : values[0];
							self.setFieldValue(values);
						}
					}
				}
			);
		},
		_actGPSPicker: function() {
			var self = this;
			native.getModule("GPS").getGPSCoordinates().then(
				function(data) {
					if (data.succeeded === true) {
						self.setFieldValue(data.latitude + ", " + data.longitude);
					} else {
						modules.get("modal").notify({
							severityClass: "error",
							title: locale.text("gps.error")
						});
					}
				}
			).fail(function() {});
		},
		_actScanBarcodePicker: function() {
			var self = this;
			native.getModule("scanBarcode").scanBarcode()
				.then(function(data) {
					if (data.action === "ok") {
						self.setFieldValue(data.content);
					} else if (data.action === "cancelled") {
						modules.get("modal").notify({
							severityClass: "info",
							title: locale.text("barcode.cancelled")
						});
					} else {
						modules.get("modal").notify({
							severityClass: "error",
							title: locale.text("barcode.error")
						});
					}
				}).fail(function() {})
		},
		//
		// END: Native capabilities
		//
	});
});

define('syracuse-tablet/html/js/controls/fields/ctrlAlphanum',['require','exports','module','syracuse-tablet/html/js/controls/fields/ctrlFieldBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/controls/validator','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/fields/ctrlFieldBase').CtrlFieldBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var validator = require('syracuse-tablet/html/js/controls/validator').Validator;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

/**
 * 
 * 
 * Rendering:
 * Inputfield: ok
 * 
 * MetaData:
 * $isReadOnly: ok 
 * $isDisabled: ok
 * $isHidden: ok
 * 
 */
exports.CtrlAlphaNum = utils.defineClass(
	function CtrlAlphaNum(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = {
			"penTextInput": true,
			"GPS": true,
			"scanBarcode": true
		};
		Base.call(this, controller, article, prototype, options);
	}, Base, {

		validateValue: function(value, errors) {
			var ok = Base.prototype.validateValue.call(this, value, errors);
			return ok && validator.validate(this, value, errors, ["$pattern", "$minLength", "$maxLength"]);
		},

		buildFieldValue: function() {
			this._ensure$$value();
			this._clear$$value();
			var value = this.getFormattedValue(this.getValue());
			if (this.$isEditMode) {
				this.createMainInput(value);
			} else {
				this.appendTextValue(value);
			};
		},
	});
var CtrlAlphaNum = exports.CtrlAlphaNum;

/**
 * 
 * 
 * Rendering:
 * Inputfield: ok
 * 
 * MetaData:
 * $isReadOnly: ok 
 * $isDisabled: ok
 * $isHidden: ok
 * 
 */
exports.CtrlPhone = utils.defineClass(
	function CtrlPhone(controller, article, prototype, options) {
		CtrlAlphaNum.call(this, controller, article, prototype, options);
		this.cssType = "s-m-phone";
	}, CtrlAlphaNum, {

		buildFieldValue: function() {
			if (this.$isEditMode) {
				CtrlAlphaNum.prototype.buildFieldValue.call(this);
			} else {
				var value = this.getFormattedValue(this.getValue());
				var link = uiUtils.createDomElement("span",
					null,
					"",
					this.getDataActionAttrs("openExternalLink", "tel:" + value)
				);
				if (value) {
					link.appendChild(uiUtils.createDomElement("span", fontUtils.phoneFieldIcon()));
					$(link).append(value);
				}
				this.$$elmt.append(link);
			}
		}
	});

/**
 * 
 * 
 * Rendering:
 * Inputfield: ok
 * 
 * MetaData:
 * $isReadOnly: ok 
 * $isDisabled: ok
 * $isHidden: ok
 * 
 */
exports.CtrlEmail = utils.defineClass(

	function CtrlEmail(controller, article, prototype, options) {
		CtrlAlphaNum.call(this, controller, article, prototype, options);
		this.cssType = "s-m-email";
	}, CtrlAlphaNum, {

		buildFieldValue: function() {
			if (this.$isEditMode) {
				CtrlAlphaNum.prototype.buildFieldValue.call(this);
			} else {
				var value = this.getFormattedValue(this.getValue());
				var link = uiUtils.createDomElement("span",
					null,
					"",
					this.getDataActionAttrs("openExternalLink", "mailto:" + value)
				);
				if (value) {
					link.appendChild(uiUtils.createDomElement("span", fontUtils.emailFieldIcon()));
					$(link).append(value);
				}
				this.$$elmt.append(link);
			}
		}
	});

/**
 * 
 * 
 * Rendering:
 * Inputfield: ok
 * 
 * MetaData:
 * $isReadOnly: ok 
 * $isDisabled: ok
 * $isHidden: ok
 * 
 */
exports.CtrlUrl = utils.defineClass(

	function CtrlUrl(controller, article, prototype, options) {
		CtrlAlphaNum.call(this, controller, article, prototype, options);
		this.cssType = "s-m-url";
	}, CtrlAlphaNum, {

		buildFieldValue: function() {
			this._ensure$$value();
			if (this.$isEditMode) {
				CtrlAlphaNum.prototype.buildFieldValue.call(this);
			} else {
				var value = this.getFormattedValue(this.getValue());
				if (value) {
					this.$$value.append(uiUtils.createDomElement("span", null, value));

					var icon = uiUtils.createDomElement("span", ["s-m-icon-link", this._getDefaultIcon()],
						null,
						this.getDataActionAttrs("openExternalLink", value)
					);
					this.$$value.append(icon);
				}
			}
		},
		_getDefaultIcon: function() {
			var css = "s-m-icon-" + (this.article.$urlIconSize || "small") + " ";
			return css + (this.article.$urlIcon || fontUtils.getUrlDefIcon()).css;
		}
	});
});

define('syracuse-tablet/html/js/controls/fields/ctrlCheckbox',['require','exports','module','syracuse-tablet/html/js/controls/fields/ctrlFieldBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/fields/ctrlFieldBase').CtrlFieldBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');

var locale = require('syracuse-tablet/html/js/helpers/locale');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

/**
 * 
 * 
 * Rendering:
 * Checkbox: ok
 * Text: ok
 * 
 * MetaData:
 * $isReadOnly: ok 
 * $isDisabled: ok
 * $isHidden: ok
 * 
 */
exports.CtrlCheckbox = utils.defineClass(

	function CtrlCheckbox(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		Base.call(this, controller, article, prototype, options);
	}, Base, {
		/**
		 * 
		 */
		buildFieldValue: function() {
			this._ensure$$value();
			this._clear$$value();
			var val = this.getValue();
			if (val == null && !this.$isEditMode) {
				return;
			}
			val = val === true;
			if (this.$isEditMode) {
				this.createMainInput(val, "checkbox");
			} else if (this.getAuthoring("$displayAs") === "text") {
				this.$$value.text(locale.text(val === true ? "yes" : "no"));
			} else {
				this.$$value.append(uiUtils.createDomElement("span", fontUtils.checkBoxIcon(val)));
			}
		},

		/**
		 * 
		 */
		onClick: function(evt) {
			var self = this;
			evt.preventDefault();
			evt.stopPropagation();

			setTimeout(function() {
				var checked = !self.$$input.prop("checked");
				self.$$input.prop("checked", checked);
				self.setValue(checked);
			}, 50);

			return true;
		},

		/**
		 * 
		 */
		applyMetaData: function(metaData) {
			Base.prototype.applyMetaData.call(this, metaData);
			var $$input = this.$$value && this.$$value.find("input");
			if (_isDisabled(metaData)) {
				$$input.attr("disabled", "");
			} else {
				$$input.removeAttr("disabled");
			}
		}
	});

function _isDisabled(metaData) {
	// Apply metaData.$isReadOnly and/or metaData.$isDisabled on select
	// select can only be set as readonly with the 'disabled' attribute
	return metaData && (metaData.$isReadOnly || metaData.$isDisabled);
}
});

define('syracuse-tablet/html/js/controls/fields/ctrlSwitch',['require','exports','module','syracuse-tablet/html/js/controls/fields/ctrlFieldBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/fields/ctrlFieldBase').CtrlFieldBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');

var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');

/**
 * 
 * 
 * Rendering:
 * Inputfield: ok
 * 
 * MetaData:
 * $isReadOnly: TODO: TEST 
 * $isDisabled: TODO: TEST
 * $isHidden: ok
 * 
 */
exports.CtrlSwitch = utils.defineClass(

	function CtrlSwitch(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		Base.call(this, controller, article, prototype, options);
	}, Base, {
		destroy: function() {
			if (this.$$panel) {
				this.$$panel.bootstrapSwitch('destroy');
				this.$$panel = null;
			};
			Base.prototype.destroy.call(this);
		},
		buildFieldValue: function() {
			this._ensure$$value();
			var val = this.getValue();
			if (val == null) {
				return;
			}
			val = val === true;
			if (this.$isEditMode) {
				var attrs = {
					"type": "checkbox"
				};
				this.$$panel = $(uiUtils.createDomElement("input", "", null, attrs, this.$$value));
				this.$$panel.bootstrapSwitch('state', val === true, true);
				this.$$panel.bootstrapSwitch('onText', locale.text("auth.switcher.onText"));
				this.$$panel.bootstrapSwitch('offText', locale.text("auth.switcher.offText"));
				this.$$panel.bootstrapSwitch('size', "small");
				this.$$panel.bootstrapSwitch('onColor', "default");
				this.$$panel.bootstrapSwitch('offColor', "default");
				this.$$panel.bootstrapSwitch('onSwitchChange', jsutils.bindFn(this.onSwitchChange, this));
			} else {
				this.$$value.append(uiUtils.createDomElement("span", fontUtils.checkBoxIcon(val)));
			}
		},
		onSwitchChange: function() {
			this.setValue(this.$$panel.bootstrapSwitch('state'));
		}
	});
});

define('syracuse-tablet/html/js/controls/fields/ctrlCombo',['require','exports','module','syracuse-tablet/html/js/controls/fields/ctrlFieldBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/uiUtils'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/fields/ctrlFieldBase').CtrlFieldBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');

/**
 * 
 * 
 * Rendering:
 * Radio buttons: ok
 * Combobox: ok
 * 
 * MetaData:
 * $isReadOnly: ok
 * $isDisabled: ok
 * $isHidden: ok
 * 
 */
exports.CtrlCombo = utils.defineClass(

	function CtrlCombo(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		Base.call(this, controller, article, prototype, options);
	}, Base, {

		/**
		 * 
		 */
		buildFieldValue: function(fieldSlot, buildOptions) {
			this._ensure$$value();
			this._updateList(false);
		},

		/**
		 * 
		 */
		refreshValue: function(buildOptions) {
			this._updateList(true);
		},

		/**
		 * 
		 */
		applyMetaData: function(metaData) {
			Base.prototype.applyMetaData.call(this, metaData);
			this._updateList(metaData, true);
		},

		/**
		 * 
		 */
		_updateList: function(valueChanged, metaDataChanged) {
			var self = this;
			if (!self.$$value) {
				return;
			}
			var metaData = this.getMetaData();
			this._isDisabled = _isDisabled(metaData);

			var newList = metaData && metaData.$value ? metaData.$value.$enum : null;
			if (valueChanged !== true && _compareEnum(newList, self._choiceList) && metaDataChanged !== true) {
				return;
			}
			self.$$value.empty();

			self._choiceList = $.extend(true, [], newList);
			if (self.$isEditMode) {
				self.$format = (metaData && metaData.$format) || "$combo";
				if (self.$format == '$radios') {
					self._renderRadios(metaData);
				} else {
					self._renderCombo(metaData);
				}
			} else if (self._choiceList.length > 0) {
				self._renderReadOnly(metaData);
			}
		},

		/**
		 * 
		 */
		_renderRadios: function(metaData) {
			var self = this;
			if (self._choiceList.length < 0) {
				return;
			}
			var value = self.currentValue = self.getValue();
			$.each(self._choiceList, function(index, choiceItem) {
				var choiceItemDom = uiUtils.createDomElement("div", ["s-m-field-radio-item"]);
				var inputDom = uiUtils.createDomElement("input", ["s-m-field-choice-radio", "s-m-meta"], null, {
					"type": "radio",
					"value": index,
					"data-sdata-value": choiceItem.$value,
					"name": "s-m-radio-" + self.id,
					"data-nevent-ctrl-click": ""
				});
				if (value && choiceItem.$value == value) {
					inputDom.setAttribute("checked", true);
				} else if (self._isDisabled) {
					inputDom.setAttribute("disabled", true);
				}
				var parsedTitle = self.prototype.resolveExpression(choiceItem.$title);
				var titleDom = uiUtils.createDomElement("div", ["s-m-field-choice-radio-title"], parsedTitle);
				self.$$value[0].appendChild(inputDom);
				self.$$value[0].appendChild(titleDom);
			});
		},

		/**
		 * 
		 */
		_renderCombo: function(metaData) {
			var self = this;
			if (self._choiceList.length < 0) {
				return;
			}
			var value = self.currentValue = self.getValue();
			var selectDom = uiUtils.createDomElement("select", ["form-control", "s-m-meta"], null, {
				"data-nevent-ctrl-change": ""
			});

			var selected = false;
			var opts = [];
			var optDom;

			$.each(self._choiceList, function(index, choiceItem) {
				var parsedTitle = self.prototype.resolveExpression(choiceItem.$title);
				optDom = uiUtils.createDomElement("option", null, parsedTitle, {
					"value": choiceItem.$value
				}, null);
				if (choiceItem.$value == value) {
					optDom.setAttribute("selected", true);
					selected = true;
				}
				opts.push(optDom);
			});

			self.$$value[0].appendChild(selectDom);
			if (_isDisabled(metaData)) {
				selectDom.setAttribute("disabled", true);
			} else {
				selectDom.removeAttribute("disabled");
			}
			if (!selected) {
				if (opts.length > 0) {
					//#7129 - If no value provided by the server we display a blank line and select it
					// This case is not usual if functional developer takes care of providing a value
					// No text like 'Choose a value...' because we don't know the size of the select 
					// TODO: Improve
					// The best way would be to manage our own select without select tag
					opts.push(uiUtils.createDomElement("option", ["empty"], "", {
						"value": "",
						"selected": true
					}, null));
					if (metaData && metaData.$isMandatory) {
						//#7129 - If it's a mandatory field we remove the blank line after having selected a value
						$(selectDom).addClass("removeEmptyOption");
					}
				}
				if (value != null) {
					// #7129 - If value is defined but not found in list we display an error message
					// For quality to detect inconsistencies
					this.controller.setClientDiagnoses(this.$bind, [{
						$severity: "error",
						$message: locale.text("unexpected.value", [" (" + value + ")"])
					}]);

					this.renderDiagnoses();
				}
			}
			//#7129 - IE doesn't work fine if we insert an empty option in the dom $(select).prepend($opt)- So we attach options at the end 
			opts.forEach(function(opt) {
				selectDom.appendChild(opt);
			});
		},

		/**
		 * 
		 */
		_renderReadOnly: function(metaData) {
			var self = this;
			var value = self.currentValue = self.getValue();
			value = self._getChoiceTitle(value);
			value = self.prototype.resolveExpression(value);
			self.appendTextValue(value);
		},

		/**
		 * 
		 */
		_getChoiceTitle: function(value) {
			var res;
			$.each(this._choiceList, function(index, choice) {
				res = choice.$value == value ? choice.$title : res;
				if (res) {
					return false;
				}
			});
			return res;
		},

		/**
		 * 
		 */
		getChoiceTitles: function() {
			var res = [],
				self = this;
			$.each(this._choiceList, function(index, choice) {
				res.push({
					$value: choice.$value,
					title: self.prototype.resolveExpression(choice.$title)
				});
			});
			return res;
		},

		/**
		 * 
		 */
		setDisplayValue: function(value) {
			var self = this;
			if (value == self.currentValue) {
				return
			}
			if (!self.$isEditMode) {
				return;
			}
			if (self.$format !== '$radios') {
				return;
			}
			$.each(self.$$elmt.find("input"), function(idx, input) {
				if ($(input).attr("data-sdata-value") === value) {
					input.checked = true;
				} else {
					input.checked = false;
					if (self._isDisabled) {
						input.disabled = true;
					}
				}
			});
		},

		/**
		 * 
		 */
		setFieldValue: function(value) {
			this.setDisplayValue(value);
			this.currentValue = value;
			this.setValue(value);
		},

		/**
		 * 
		 */
		onClick: function(evt) {
			var $$t = $(evt.target);
			if (this.$format === '$radios') {
				this.setFieldValue(this._getChoiceValue($(evt.target)));
			}
			return true;
		},

		/**
		 * 
		 */
		_getChoiceValue: function($$elmt) {
			return $$elmt.attr("data-sdata-value");
		},

		/**
		 * 
		 */
		onChange: function(evt) {
			var $$t = $(evt.target);
			if ($$t.is("select") && $$t.is(".removeEmptyOption")) {
				// //#7129 - remove the empty option
				$$t.removeClass("removeEmptyOption").find("option.empty").remove();
			}
			this.setFieldValue(evt.target.value);
		},
	});

/**
 * 
 * @param enum1
 * @param enum2
 * @returns {Boolean}
 */
function _compareEnum(enum1, enum2) {
	if (!enum1 || !enum2) return false;
	if (enum1.length != enum2.length) return false;
	for (var i = 0, l = enum1.length; i < l; i++) {
		if (enum1.$value != enum2.$value) return false;
		if (enum1.$title != enum2.$title) return false;
	}
	return true;
}

function _isDisabled(metaData) {
	// Apply metaData.$isReadOnly and/or metaData.$isDisabled on select
	// select can only be set as readonly with the 'disabled' attribute
	return metaData && (metaData.$isReadOnly || metaData.$isDisabled);
}
});

define('syracuse-tablet/html/js/controls/fields/ctrlNumeric',['require','exports','module','syracuse-tablet/html/js/controls/fields/ctrlFieldBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/validator','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {
var Base = require('syracuse-tablet/html/js/controls/fields/ctrlFieldBase').CtrlFieldBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var validator = require('syracuse-tablet/html/js/controls/validator').Validator;
var locale = require('syracuse-tablet/html/js/helpers/locale');

/**
 * 
 * 
 * Rendering:
 * Inputfield: ok
 * 
 * MetaData:
 * $isReadOnly: ok 
 * $isDisabled: ok
 * $isHidden: ok
 * 
 */
exports.CtrlNumeric = utils.defineClass(

	function CtrlNumeric(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = {
			"penTextInput": true
		};
		Base.call(this, controller, article, prototype, options);
	}, Base, {

		buildFieldValue: function() {
			var self = this;
			this._ensure$$value();
			this._clear$$value();
			this.$$value.addClass("s-m-numeric");
			var value = self.getFormattedValue(self.getValue());

			if (self.$isEditMode) {
				self.createMainInput(value);
			} else {
				self.appendTextValue(value);
			}
		},

		parseValue: function(value, errors) {
			var self = this;
			if (self.formatter) {
				var format = self.formatter.getFormat();
				if (format) {
					var gs = locale.getNumberGroupSeparator();
					var ds = locale.getNumberDecimalSeparator();

					if (format.indexOf(",") < 0 && gs && gs.length > 0) {
						// Format with no GS, consider eventual GS as DS
						value = value.replace(new RegExp("\\" + gs, "g"), ds);
					}
					if (format.indexOf(",") > 0 && format.indexOf(".") > 0 && gs && gs.length > 0) {
						// Format with GS and DS, consider GS as DS if no DS entered
						if (value.indexOf(gs) > -1 && value.indexOf(ds) < 0) {
							value = value.replace(new RegExp(gs, "g"), ds);
						}
					}
				}
			}
			return Base.prototype.parseValue.call(self, value, errors);
		},

		validateValue: function(value, errors) {
			var self = this;
			var ok = Base.prototype.validateValue.call(self, value, errors);
			ok = validator.validate(self, value, errors, ["$minimum", "$maximum", "$exclusiveMinimum", "$exclusiveMaximum", "$precision"]) && ok;
			if (self.$type !== "application/x-integer") {
				ok = validator.validate(self, value, errors, ["$scale"]) && ok;
			}
			return ok;
		}
	});
});

define('syracuse-tablet/html/js/controls/fields/ctrlQuantity',['require','exports','module','syracuse-tablet/html/js/controls/fields/ctrlFieldBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/fields/ctrlFieldBase').CtrlFieldBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var modules = require('syracuse-tablet/html/js/common/modules');


exports.CtrlQuantity = utils.defineClass(

	function CtrlQuantity(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = {
			"penTextInput": true
		};
		Base.call(this, controller, article, prototype, options);
		this.unitFieldInfo = prototype.getUnitFieldInfo();
		// Create extra control for UNIT in read only mode
		// !! if grid Cell we ca't create the control with createControl
		this.displayUnit = false;
		if (this.unitFieldInfo && this.unitFieldInfo.unitFieldProto && !this.unitFieldInfo.unitFieldProto.json["$isExcluded"]) {
			this.displayUnit = options && options.displayCtx !== "table";
		}
		this.unitCtrl = null;
	}, Base, {

		initFormatter: function() {
			var valueProto = this.prototype.data('$value');
			if (!valueProto || !valueProto.$type) return null;
			return Base.prototype.initFormatter.call(this, valueProto.$type, valueProto.$format);
		},

		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this.unitCtrl) {
				this.unitCtrl.destroy();
				this.unitCtrl = null;
			}
		},
		buildHtml: function(classes) {
			classes = classes || [];
			classes.push("s-m-qty");
			Base.prototype.buildHtml.call(this, classes);
			if (this.displayUnit) {
				this.unitCtrl = modules.get("ctrlFactory").createControl(
					this.controller, {
						"$bind": this.unitFieldInfo.unitBindName,
						"$noAuthoring": true,
					},
					this.parent,
					this.unitFieldInfo.unitFieldProto, {
						isUnit: true
					});
				this.unitCtrl.set$$container(this.$$value);
				this.unitCtrl.buildHtml();
			}
		},

		buildFieldValue: function() {
			this._ensure$$value();
			this._clear$$value();
			var value = this.getFormattedValue(this.getValue());
			if (this.$isEditMode) {
				this.createMainInput(value);
			} else {
				this.appendTextValue(value);
			}
		}
	});
});

define('syracuse-tablet/html/js/controls/fields/ctrlReference',['require','exports','module','syracuse-tablet/html/js/controls/fields/ctrlFieldBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/fields/ctrlFieldBase').CtrlFieldBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

/**
 * 
 * 
 * Rendering:
 * Inputfield: ok
 * 
 * MetaData:
 * $isReadOnly: ok 
 * $isDisabled: ok
 * $isHidden: ok
 * 
 */
exports.CtrlReference = utils.defineClass(
	function CtrlReference(controller, article, prototype, options) {
		// See ctrlQuantity - Control that displays the unit
		this.isUnit = options.isUnit === true;

		options.nativeCapabilities = {
			"scanBarcode": !this.isUnit
		};

		Base.call(this, controller, article, prototype, options);
		if (this.isUnit) {
			this.$isEditMode = false;
			this.cssType = "s-m-unit";
		} else {
			this.cssType = "s-m-ref";
		}

		this._isNumeric = false;
	}, Base, {
		initFormatter: function() {
			var type = this.prototype.getFieldValueType(this.$bind);
			if (type == null || type.length === 0) return null;
			return Base.prototype.initFormatter.call(this, type, null);
		},
		getValue: function(prop) {
			var val = this.getObjectValue()[prop || "$value"];
			return val == null ? "" : val;
		},

		/**
		 * return {$value, $title, $descr}
		 */
		getObjectValue: function() {
			var val = Base.prototype.getValue.call(this);
			if (val === null || typeof val !== "object") {
				// Unexpected
				val = {
					$value: val
				};
			}
			if (!val.$description) {
				val.$description = "";
			}
			if (!val.$title) {
				val.$title = "";
			}
			return val;
		},

		/**
		 * 
		 */
		buildFieldTitle: function() {
			if (this.isUnit) {
				return;
			}
			Base.prototype.buildFieldTitle.call(this);
		},

		/**
		 * 
		 */
		buildFieldValue: function() {
			var self = this;
			this._ensure$$value();
			this._clear$$value();
			if (self.formatter && self.formatter.$type === "application/x-integer") {
				self.$$value.addClass("s-m-numeric");
			}
			if (self.$isEditMode) {
				self.buildEditValue(self.getValue());
			} else {
				var val = self.getObjectValue();
				if (self.isUnit) {
					self.buildUnitValue(self.$$value, val.$value, val.$description, val.$title);
				} else {
					self.buildDetailValue(self.getFormattedValue(val.$value), val.$description, val.$title);
				}
			}
		},

		/**
		 * 
		 */
		buildEditValue: function(value) {
			var $lookuplink = this.getMetaData("$isReadOnly") !== true && this.getMetaData("$isDisabled") !== true ? this.prototype.getValueByPath("$item.$links.$lookup") : null;
			if ($lookuplink) {
				this.addPickerSdataLink("$lookup", fontUtils.getIconByName("lookupPicker"));
			}
			this.createMainInput(this.getFormattedValue(value));
		},

		/**
		 * 
		 */
		buildDetailValue: function(value, descr, title) {
			var self = this;

			var $$container = this.options.displayCtx !== "table" ? self.addDetailLink(self.$$value) : self.$$value;
			if (value.length > 0) {
				// set description content according to authoring value of $refDescFormat
				// Available values are desc, title, desctitle, and titledesc. Default is "desc"
				var descContent;
				var $refDescFormat = self.getAuthoring("$refDescFormat");
				switch ($refDescFormat) {
					case "title":
						descContent = title;
						break;
					case "desctitle":
						descContent = self._combineTexts(descr, title);
						break;
					case "titledesc":
						descContent = self._combineTexts(title, descr);
						break;
						// "desc" will be considered as default
					default:
						descContent = descr;
						break;
				}

				// build content and set position according to description content authoring position $refDescPosition
				// available values are bottom, right, left, top, none. Default is "right"
				var $refDescPosition = self.getAuthoring("$refDescPosition");
				if ($refDescPosition == null || $refDescPosition.length === 0) {
					$refDescPosition = self.options.displayCtx === "table" ? "bottom" : "right";
				}
				var $$value = $("<div>").addClass("s-m-ref-val").text(value);
				var $$desc = $("<div>").addClass("s-m-descr").text(descContent);
				var arr;
				switch ($refDescPosition) {
					case "bottom":
						$$container.append($$value).append($$desc);
						break;
					case "left":
						$$container.append($$desc).append($$value);
						arr = [$$value, $$desc];
						$.each(arr, function(index, $$ee) {
							$$ee.css("display", "inline-block");
						});
						$$desc.css("padding-right", "5px");
						break;
					case "top":
						$$container.append($$desc).append($$value);
						break;
					case "none":
						$$container.append($$value);
						break;
					case "right": // "right" will be considered as default
					default:
						arr = [$$value, $$desc];
						$$container.append($$value).append($$desc);
						$.each(arr, function(index, $$ee) {
							$$ee.css("display", "inline-block");
						});
						$$desc.css("padding-left", "5px");
				}
			}
		},

		/**
		 * 
		 */
		buildUnitValue: function($$parentElmt, value, descr, title) {
			var self = this;
			var label = descr.length > 0 ? descr : title.length > 0 ? title : value;

			label = value || "";
			if (label && label.toLowerCase) label = label.toLowerCase().smCapitalize();
			uiUtils.createDomElement("span", ["s-m-descr"], label, null, self.addDetailLink($$parentElmt) || $$parentElmt);
		},

		/**
		 * Returns $$parentElmt or detailLink $$elmt
		 */
		addDetailLink: function($$parentElmt) {
			var self = this;
			if (self.options.displayCtx === "card") {
				return
			}
			if (self.prototype.getValueByPath("$item.$links.$details")) {
				// get dom link parameters/attributes (we consider only $details)
				return $(uiUtils.createDomElement("span", null, null,
					self.getSdataLinkAttrs("$details"), $$parentElmt));
			}
			return $$parentElmt;
		},
		/**
		 * data: 		string with value
		 * 				object with {$value:,$description:,$title:}
		 */
		setDisplayValue: function(value) {
			var strData;
			if ($.isPlainObject(value)) {
				strData = value.$value || "";
			} else {
				strData = value || "";
			}
			Base.prototype.setDisplayValue.call(this, strData);
		},

		/**
		 * On reference fields, $linkName can be $details and $lookup
		 */
		onSdataLinkClicked: function($linkName) {
			var self = this;
			var $link = (this.prototype.getValueByPath("$item.$links." + $linkName) || {});
			if (!$link) {
				return;
			}
			var $url = $link.$url;
			var $method = $link.$method;
			if (!$url) {
				return;
			}
			if ($linkName === "$lookup") {
				// Auto generated dynamic filter bases on compound key of item to lookup
				var $lookupWhere = this.prototype.getValueByPath("$item.$autoLookWhere");
				var whereElements;
				$lookupWhere && $.each($lookupWhere, function(property, valueProperty) {
					var fieldValue = self.controller.getValue(valueProperty);
					if (fieldValue != null) {
						whereElements = whereElements || [];
						whereElements.push("(" + property + " eq '{" + valueProperty + "}')");
					}
				});

				var autoLookupWhere = whereElements && whereElements.join(" and ");
				if (autoLookupWhere && $url.indexOf("where=") < 0) {
					if ($url.indexOf("?") < 0) {
						$url = $url + "?where=" + autoLookupWhere;
					} else {
						$url = $url + "&where=" + autoLookupWhere;
					}
				}

				/*
				 *  For lookup link, we add the details on where to put the value in on selection
				 */
				$url = this.controller.dataset.resolveExpression($url, true);
				this.controller.gotoUrl($url, $method, {
					isChild: true,
					lookup: {
						"controllerId": this.controller.id,
						"$bind": this.$bind,
						"$lookupKeyName": this.prototype.getValueByPath("$item.$lookupKeyName")
					}
				});
			} else {
				$url = this.controller.dataset.resolveExpression($url, true);
				this.controller.gotoUrl($url, $method);
			}
		},
		_combineTexts: function(el1, el2) {
			var res;
			// el1-el2 || el1 || el2
			res = (el1 && el2) ? (el1 === el2 ? el1 : el1 + "-" + el2) : (el1 || el2 || "");
			return res;
		}
	});
});

define('syracuse-tablet/html/js/ui/rect',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var modules = require('syracuse-tablet/html/js/common/modules');

var _Klass = utils.defineClass(function rect(top, left, height, width) {
	this.top = top;
	this.left = left;
	this.setHeight(height);
	this.setWidth(width);
}, null, {
	// Accept null for x or y 
	isPointInside: function(x, y) {
		return (x == null || (x >= this.left && x <= this.right)) && (y == null || (y >= this.top && y <= this.bottom));
	},
	/**
	 * rectOffset!=null means that the main has scrolled and we need to to correct the coordinates because pageX/pageY are relative document
	 */
	isEvtInside: function(evt, rectOffset) {
		if (evt.type.smStartsWith("touch")) {
			// Touch events are managed completely differently from mouse events - depends on the number of fingers in contact...
			if (evt.changedTouches && evt.changedTouches.length === 1) {
				evt = evt.changedTouches[0];
			} else if (evt.touches && evt.touches.length === 1) {
				evt = evt.touches[0];
			} else {
				// No control -> OK
				return true;
			}
		}
		var y = rectOffset != null && rectOffset.top != null ? evt.pageY - rectOffset.top : evt.pageY;
		var x = rectOffset != null && rectOffset.left != null ? evt.pageX - rectOffset.left : evt.pageX;
		return this.isPointInside(x, y);
	},
	intersectsWith: function(rect) {
		return this.left <= rect.right && rect.left < this.right && this.top < rect.bottom && rect.top < this.bottom;
	},
	contains: function(rect) {
		if (rect == null) return true;
		return this.isPointInside(rect.left, rect.top) && this.isPointInside(rect.right, rect.bottom);
	},
	equals: function(rect, justSize) {
		if (rect.width === this.width && rect.height === this.height) {
			return justSize === true || (rect.top === this.top && rect.left === this.left);
		}
		return false;
	},
	/**
	 * relative	true/false
	 */
	intersectRect: function(rect, relative) {
		if (!this.intersectsWith(rect)) return null;
		var top = Math.max(this.top, rect.top);
		var left = Math.max(this.left, rect.left);
		var right = Math.min(this.right, rect.right);
		var bottom = Math.min(this.bottom, rect.bottom);
		return new _Klass(relative ? 0 : top, relative ? 0 : left, bottom - top, right - left);
	},
	// Compare this.height with rect.height
	// Returns 0 if equals +1 if greater -1 if less
	checkHeight: function(rect) {
		if (!rect) {
			return false;
		}
		return this.height === rect.height ? 0 : this.height > rect.height ? +1 : -1;
	},
	checkWidth: function(what, rect) {
		if (!rect) {
			return false;
		}
		return this.width === rect.width ? 0 : this.width > rect.width ? +1 : -1;

	},
	setHeight: function(h) {
		this.height = Math.max(h, 0);
		this.bottom = this.top + this.height;
	},
	setWidth: function(w) {
		this.width = Math.max(w, 0);
		this.right = this.left + this.width;
	},
	moveLeft: function(l) {
		this.left = this.left + l;
		this.right = this.width + this.left;
	},
	moveTop: function(l) {
		this.top = this.top + l;
		this.bottom = this.height + this.top;
	},
	toString: function() {
		return "t:" + this.top + " l:" + this.left + " r:" + this.right + " b:" + this.bottom + " h:" + this.height + " w:" + this.width;
	},
	toRelative: function(offet) {
		if (offet == null) offet = {};
		if (offet.top == null) offet.top = 0;
		if (offet.left == null) offet.left = 0;
		return new _Klass(offet.top, offet.left, this.height, this.width);
	},
	/**
	 * timeoutOrColor	optional
	 * 						timeout in ms to delete the div
	 * 						name/code of border color
	 */
	showInDocument: function(options) {
		var scale = modules.get("siteLayout").getTransformScale();
		options = options || {};
		// To pass has param if needed
		var pos = "fixed";
		var $$parent = $(document.body);
		var $$elmt = $('<div class = "s-m-rect">').appendTo($$parent).css({
			position: pos,
			top: this.top + "px",
			left: this.left + "px",
			height: (this.height * scale) + "px",
			width: (this.width * scale) + "px",
			backgroundColor: options.color,
			zIndex: options.zIndex != null ? options.zIndex : undefined
		});
		if (options.timeout != null) {
			setTimeout(function() {
				$$elmt.remove();
			}, options.timeout);
		}
		return $$elmt;
	},
	clone: function() {
		return new _Klass(this.top, this.left, this.height, this.width);
	},
	applyTransformScale: function(scale, clone) {
		if (scale == null || scale <= 0 || typeof scale != "number") return;
		var res = clone === true ? this.clone() : this;
		res.width = res.width * scale;
		res.height = res.height * scale;
		// TODO - left / right - ok if they are equal to 0
		return res;
	}
});
var _meths = {
	outer: ["outerWidth", "outerHeight"],
	inner: ["innerWidth", "innerHeight"],
	computed: ["width", "height"],
	fixed: "position",
	relative: "offset"
};
/**
 * Returns the rectangle of $$elmt
 * 	type:		outer / inner / computed
 * 	position	!!! fixed (RELATIVE TO PARENT), relative (RELATIVE  TO DOCUMENT) - Mistake
 */
exports.elmtRect = function($$elmt, typeRect, position) {
	var scale = modules.get("siteLayout").getTransformScale();
	position = position || "relative";
	typeRect = typeRect || "outer";
	var o = $$elmt[_meths[position]]();
	var m = _meths[typeRect];
	var height = $$elmt[m[1]]();
	var width = $$elmt[m[0]]();
	var rect = new _Klass(o.top, o.left, height / scale, width / scale);
	if (typeRect === "computed" && position === "relative") {
		// We assume that padding L/R and T/B are identical
		var outW = $$elmt.outerWidth();
		var outH = $$elmt.outerHeight();
		if (outW > width) {
			rect.moveLeft((outW - width) * scale / 2);
		}
		if (outH > height) {
			rect.moveTop((outH - height) * scale / 2);
		}
	}
	return rect;
};
exports.newRect = function(top, left, height, width) {
	return new _Klass(top, left, height, width);
};
});

/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  

var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge]
 * @returns {Object} dest
 */
function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
function merge(dest, src) {
    return extend(dest, src, true);
}

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        extend(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument;
    return (doc.defaultView || doc.parentWindow);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = last.deltaX - input.deltaX;
        var deltaY = last.deltaY - input.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.allow = true; // used by Input.TouchMouse to disable mouse events
    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down, and mouse events are allowed (see the TouchMouse input)
        if (!this.pressed || !this.allow) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */
function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        // when we're in a touch event, so  block all upcoming mouse events
        // most mobile browser also emit mouseevents, right after touchstart
        if (isTouch) {
            this.mouse.allow = false;
        } else if (isMouse && !this.mouse.allow) {
            return;
        }

        // reset the allowMouse when we're done
        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
            this.mouse.allow = true;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        // not needed with native support for the touchAction property
        if (NATIVE_TOUCH_ACTION) {
            return;
        }

        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // pan-x and pan-y can be combined
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.id = uniqueId();

    this.manager = null;
    this.options = merge(options || {}, this.defaults);

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        extend(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(withState) {
            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(true);
        }

        emit(); // simple 'eventName' events

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(true);
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = extend({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {
        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        this._super.emit.call(this, input);
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            this.manager.emit(this.options.event + inOut, input);
        }
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 500, // minimal time of the pointer to be pressed
        threshold: 5 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.65,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.velocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.velocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.velocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.direction &&
            input.distance > this.options.threshold &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 2, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED ) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create an manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.4';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, { enable: false }],
        [PinchRecognizer, { enable: false }, ['rotate']],
        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],
        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    options = options || {};

    this.options = merge(options, Hammer.defaults);
    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        extend(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        var recognizers = this.recognizers;
        recognizer = this.get(recognizer);
        recognizers.splice(inArray(recognizers, recognizer), 1);

        this.touchAction.update();
        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    each(manager.options.cssProps, function(value, name) {
        element.style[prefixed(element.style, name)] = add ? value : '';
    });
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

extend(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

if (typeof define == TYPE_FUNCTION && define.amd) {
    define('syracuse-tablet/html/deps/hammerjs-2.0.4/hammer',[],function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');
define('syracuse-tablet/html/js/helpers/scroller/scrollerBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/rect'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var _scrolId = 0;
var _Klass = utils.defineClass(function scroller($$elmt, options) {
	this.options = options = $.extend(true, {}, options);
	this.name = options.name || ("scroller-" + _scrolId++);
	this.$$elmt = $$elmt;
	this.isPageScroller = options.isPageScroller === true;
	this._initDir(options.direction);
	// Max top always 0 because we scroll in relative / parent - If needed pass it in parameter
	// options.valMax kept for compatibility with previous version
	this.scrollMax = options.valMax != null ? options.valMax : options.scrollMax != null ? options.scrollMax : 0;
	this.restoredScroll = null;
}, null, {
	destroy: function() {
		this.reset();
		this.$$elmt = null;
	},
	isNative: function() {
		return false;
	},
	_initDir: function(dir) {
		if (dir == null) {
			if (this.dir != null) return;
			this.dir = "v";
			return;
		}
		this.dir = dir;
	},
	init: function(viewRect, dir, scrollMax, preserveScroll) {
		if (viewRect == null) {
			throw new Error("Unexpected null viewRect");
		}
		var scroll = this.getScroll();
		if (preserveScroll === true && this.restoredScroll == null && scroll != null && scroll !== this.scrollMax) {
			// preserve the current scrolling - Just set restoredScroll
			// ! in charge to the parent class to refresh with restoredScroll 
			this.restoredScroll = scroll;
		}
		this.reset(true);
		this._initDir(dir);
		if (scrollMax != null) {
			this.scrollMax = scrollMax;
		}
		this.viewRect = viewRect;
		this._doInit(viewRect, dir, scrollMax, preserveScroll);
		var refreshed = false;
		if (preserveScroll === true && this.restoredScroll != null) {
			// If preserveScroll we have to adjust in case the newValMin < previousVal < newscrollMax
			refreshed = this.adjust(this.restoredScroll);
		}
		if (!refreshed) {
			this._refresh(this.restoredScroll, true);
		}
		this.restoredScroll = null;
		this.$$elmt.removeClass('scrollDisabled').addClass('scrollEnabled');
	},
	/**
	 * Child classes initialization
	 */
	_doInit: function(viewRect, dir, scrollMax, preserveScroll) {
		throw new Error("Not implemented");
	},
	isInitialized: function() {
		return this.$$elmt != null && this.viewRect != null;
	},
	/**
	 * Disable scroll but keep the capability to re-initialize it
	 */
	reset: function(dontResetValue) {
		if (dontResetValue !== true) {
			// Put initial value
			this._refresh(this.scrollMax);
		}
		this.viewRect = null;
		if (this.$$elmt) {
			this.$$elmt.removeClass('scrollEnabled').addClass('scrollDisabled');
		}
	},
	/**
	 * Applies the scrolling
	 */
	_refresh: function(scroll, force) {
		throw new Error("Not implemented");
	},
	/**
	 * Restore the scrolling
	 */
	savedCtxCreate: function(opts) {
		return {
			scroll: opts == null || opts.noScroll !== true ? this.getScroll() : null
		};
	},
	savedCtxRestore: function(ctx, refresh) {
		// TOD0 _ Woco - Remove refresh if not needed
		refresh = true
		if (ctx == null || ctx.scroll == null) return;
		if (refresh && this.isInitialized()) {
			this._refresh(ctx.scroll);
		} else {
			this.restoredScroll = ctx.scroll;
		}
	},
	getOffset: function() {
		return {
			top: this.dir == "v" ? this.getScroll() : 0,
			left: this.dir == "h" ? this.getScroll() : 0
		};
	},
	/**
	 * Make $$e visible
	 */
	makeVisible: function($$e) {
		throw new Error("Not implemented");
	},
	/**
	 * Auto-scroll to  value
	 */
	autoScroll: function(value) {
		throw new Error("Not implemented");
	},
	/**
	 * Returns the current scrolling
	 */
	getScroll: function(value) {
		throw new Error("Not implemented");
	},
	/**
	 * Returns the min scrolling (rather the max)
	 */
	getScrollMin: function() {
		throw new Error("Not implemented");
	},
	/**
	 * Check if the current scroll element is contained by  viewRect
	 * If true -> reset scrolling Else re-init scrolling
	 */
	checkViewRect: function(viewRect, preserveScroll) {
		var reset = true;
		if (viewRect && this.$$elmt) {
			// For multi-selection in card mode we can hide cards. We need to scroll to beginning in order to calculate the right rect
			var val = this.getScroll();
			this._scrollToBeginning();
			var myRect = uiRect.elmtRect(this.$$elmt, "computed");
			var intersectRect = viewRect.intersectRect(myRect, false);
			if (intersectRect != null) {
				if (preserveScroll) {
					this.resoredVal = val;
				}
				this.init(intersectRect, null, null);
				reset = false;
				if (preserveScroll) {
					// If preserveScroll we have to adjust in case the newValMin < previousVal < newscrollMax
					this.adjust();
				}
			}
		}
		if (reset) {
			this.reset();
		}
	},
	/**
	 * Move to beginning
	 */
	_scrollToBeginning: function() {
		this._refresh(this.scrollMax);
	},
	/**
	 *  Adjust the scroller after modification of DOM to make this.$$elmt visible
	 *  By example after an action which have hidden lines we need to call this method to adjust scrolling because the visible area can be outside the viewRect
	 */
	adjust: function(restoredScroll) {
		throw new Error("Not implemented");
	}
});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/helpers/scroller/hammerScroller',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/deps/hammerjs-2.0.4/hammer','syracuse-tablet/html/js/helpers/scroller/scrollerBase','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("scroll", false);
var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var Hammer = require('syracuse-tablet/html/deps/hammerjs-2.0.4/hammer');
var Base = require('syracuse-tablet/html/js/helpers/scroller/scrollerBase').Klass;
var modules = require('syracuse-tablet/html/js/common/modules');

var _getMainScrollOffset = function() {
		var $$elmt = $("#s-m-app-id");
		return {
			top: $$elmt.length > 0 ? $$elmt.scrollTop() : 0,
			left: $$elmt.length > 0 ? $$elmt.scrollLeft() : 0
		};
	}
	/**
	 * True if hammer event has the dir direction
	 * dir	h or v
	 * 		   -90			+180<-- -->0
	 * 			^			       |
	 * 			|                 +90
	 * -180 <-- -->   0
	 */
var _isEvtDirection = function(evt, dir, forceTrueIfNull) {
	// If hammer as no event it's - we can have the case with panup pandown without velocity
	// by default if work with if (ui.isEvtDirection(evt, "v")) return; - null evt means we continue
	if (evt == null) return forceTrueIfNull === true;
	if (evt.angle == null) throw new Error("this is not a hammer.js event");
	if ((evt.angle > 45 && evt.angle < 135) || (evt.angle < -45 && evt.angle > -135)) return dir == "v";
	return dir == "h";
};



var _stopClickEvent = function(mgr, evt, reason) {
	log && log("Clicked canceled", reason, mgr.id);
	evt.stopPropagation();
	evt.preventDefault();
	evt.$stop = true;
};
// Time to wait before allowing click events a scrolling
var _lastClickTO = 400;
// Enable the slowdown process - scroll continue after panend (mouse up ) like on native devices
var _slowDown = true;
// Move the $$elmt after _slowDownTO in slowdown process
var _slowDownTO = 10;
/**
 * returns the distance to _move according to velocity v
 */
var _velocityToDist = function(velocity) {
	// Velocity of the _move - 0 if we _move the finger slowly and ~ 2 for fast - TO IMPROVE REGARDING THE CONTEXT - TOUCH/DESKTOP 
	var v = Math.abs(Math.round(velocity * 4));
	// Distance to _move - square function of velocity (non linear) 
	// Allow to _move slow and fast if we increase the speed of the finger
	return Math.max(1, v * v / 2);
};
/**
 * Creates a vertical/horizontal scroller which emulates the tablet native behavior
 * 		$$elmt		element to scroll
 * 		options		scrollMax			maximum top - 0 by default - 50 for pages with header...
 * 					direction		h/v
 * 					isPageScroller	true/false
 * 		parentMgr	parent scroll manager (the page's one for an array scroller)
 * 					used to deal with click event
 * 		$$nativeScroll 	div that will take the native scroll when we disable the scrolling (for test and authoring)
 * 						optional - $elmt if null
 */
var _consts = {
	pan: {
		v: "panup pandown panstart panend",
		h: "panleft panright panstart panend"
	},
	dir: {
		v: Hammer.DIRECTION_VERTICAL,
		h: Hammer.DIRECTION_HORIZONTAL
	},
	upEvt: {
		v: "panup",
		h: "panleft"
	}
};
var _Klass = utils.defineClass(function HammerScroller($$elmt, options, parentMgr) {
	options = options || {};
	Base.call(this, $$elmt, options);
	this.id = $$elmt.closest("[id]").attr("id");
	this.parentMgr = parentMgr;
	// Init hammer manager
	this.hammer = new Hammer(this.$$elmt.get(0));
	// evts enabled - false by default
	this._evtsEnabled = false;
}, Base, {
	/**
	 * We need to initialize the scroll after creation
	 * Scrollable object arrays/pages have an empty scroll which is initialized if needed
	 * Initialization needs to be called when the object has been displayed (after show) to make sure that viewRect is ok
	 * To manage savedCtxRestore it's also the better way
	 * 		- save ctx (top)is stored and took into account at initialization
	 * Params
	 * 		viewRect		rectangle (uiUtils/rect class) of the view within we will _move the content of $$elmt (kind of window)
	 * 						!!!top/left must be in fixed coordinates (relative to document)
	 * 						in order to be able to check if mouse pointer belongs to this rect on mousemove/pandown
	 * 		dir				To change dir if needed (orientation changed)
	 * 		scrollMax			To change scrollMax if needed (orientation changed)
	 * 		preserveScroll	true to init scrollRect and preserve the scrolling
	 * 						used to for child pages
	 */
	init: function(viewRect, dir, scrollMax, preserveScroll) {
		Base.prototype.init.call(this, viewRect, dir, scrollMax, preserveScroll);
	},
	_initDir: function(dir) {
		Base.prototype._initDir.call(this, dir);
		// event than means up or right
		this.upEvtType = _consts.upEvt[this.dir];
	},
	_doInit: function(viewRect, dir, scrollMax, preserveScroll) {
		// We need pan and not swipe
		this.hammer.get("pan").set({
			threshold: 0, // Small threshold to bloc the click (mouseup) as son as pan start- To test on mobile devices
			direction: _consts.dir[this.dir]
		});
		// We need press to stop the scolling
		this.hammer.get("press").set({
			time: 1 //Small timeout needed to stop immediately when press
		});
		// Create handlers
		this._panHandler = Hammer.bindFn(this._onPan, this);
		this._pressHandler = Hammer.bindFn(this._onPress, this);
		this._clickHandler = Hammer.bindFn(this._onClick, this);
		// - altClick enable/disable the scrolling
		this.$$elmt.on('click', this._clickHandler);
		// Bind events
		// Original rectangle - used to enable/disable scrolling
		// !!! Images and components loaded by URL need to have a fix height !!! otherwise we can't calculate the height
		this._originalRect = uiRect.elmtRect(this.$$elmt);
		// Store the original offset because it's the reference (only for embedded object like page into vignette and arrays)
		this._originalScrollOffset = this.isPageScroller ? null : _getMainScrollOffset();
		this._enableEvents(true);
	},
	/**
	 * Enable / Disable events
	 * Used by reset and Alt Click
	 * toggleStatus: true means that we toggle 'native scroll' <-> 'hammer scroll'
	 */
	_enableEvents: function(yes) {
		if (!this.hammer) return;
		var wasDisabled = this._evtsEnabled === false;
		// ENABLED
		if (yes === true && this._evtsEnabled !== true) {
			this._evtsEnabled = true;
			this.hammer.on(_consts.pan[this.dir], this._panHandler);
			this.hammer.on("press", this._pressHandler);
			// Just to find elmt with debugger
			this.$$elmt.addClass("s-m-scroll" + this.dir);
		}
		// DISABLED
		if (yes === false && this._evtsEnabled !== false) {
			this._evtsEnabled = false;
			if (this.hammer) {
				this.hammer.off(_consts.pan[this.dir], this._panHandler);
				this.hammer.off("press", this._pressHandler);
			}
			this.$$elmt.removeClass("s-m-scroll" + this.dir);
		}
		// IN ANY CASES
		if (wasDisabled) {
			// Nothing
		} else {
			this.panStart = false;
			this._stopSlowingDown();
			this.cancelClick = false;
			this.lastClickAllowed = null;
		}
	},
	/**
	 * Disable scroll but keep the capability to re-initialize it
	 */
	reset: function(dontResetValue) {
		Base.prototype.reset.call(this, dontResetValue);
		// !! FIRST - Disable events
		this._enableEvents(false);
		// Disable click - No mo more scrolling compared to disable/enable
		if (this.$$elmt) {
			this.$$elmt.off('click', this._clickHandler);
		}
		// True if panstart - mouse start to _move
		this.panStart = false;
		// True if the scroll is slowing down after panend (mouse up)
		this._stopSlowingDown();
		// Cancel click on a link
		this.cancelClick = false;
		//Prevent click after _lastClickTO ms after a panend
		this.lastClickAllowed = null;
		// Null to force to set value on init ( context restored)
		this.val = null;
		this.isLocked = false;
		// !! DO NOT RESET - dir, scrollMax, parentMgr, restoredScroll
	},
	/**
	 * Destroy scroller
	 */
	destroy: function() {
		Base.prototype.destroy.call(this);
		// After
		if (this.hammer) {
			this.hammer.destroy();
			this.hammer = null;
		}
		this._panHandler = null;
		this._pressHandler = null;
		this._toggleRect(false);
		this._clickHandler = null;
		notifications.unsubscribe(this);
	},
	/**
	 * Refresh scrolling
	 * 	internal call or called to refresh scrolling when we activate cached pages
	 *  scroll: optional
	 */
	_refresh: function(scroll, force) {
		if (!this.$$elmt) return;
		this._setScroll(scroll);
		if (this.dir == "v") {
			this.$$elmt.css({
				top: this.getScroll() + "px"
			});
		} else {
			this.$$elmt.css({
				left: this.getScroll() + "px"
			});
		}
	},
	_getScrollOffset: function() {
		if (this.isPageScroller || this._originalScrollOffset == null) return null;
		var o = _getMainScrollOffset();
		return {
			top: o.top - this._originalScrollOffset.top,
			left: o.left - this._originalScrollOffset.left
		};
	},
	_toggleRect: function(remove) {
		// Debug show the rectangle - fixed position 
		if (this._$$viewRect) {
			this._$$viewRect.remove();
			this._$$viewRect.off('click', this._clickHandler);
			this._$$viewRect = null;
		} else if (remove !== false) {
			this._$$viewRect = this.viewRect.showInDocument();
			var o = this._getScrollOffset();
			if (o) {
				this._$$viewRect.css({
					marginTop: "+=" + o.top,
					marginLeft: "+=" + o.left
				});
			}
			this._$$viewRect.on('click', this._clickHandler);
		}
	},
	/**
	 * Intercept click/mouseup events for filtering
	 * We need to filter click events to control the triggering of links
	 * altClick 	-> Enables/Disables scrolling
	 * shiftClick	-> Displays/Hides the viewRect
	 */
	_onClick: function(evt) {
		log && log("onClick Status", "slowingDown:", this.slowingDown, "panStart:", this.panStart, "cancelClick:", this.cancelClick, "lastClickAllowed:", this.lastClickAllowed ? new Date().getTime() - this.lastClickAllowed : null);
		evt.$stop = false;
		if (evt.shiftKey) {
			this._toggleRect();
			return _stopClickEvent(this, evt, "Show rectangle");
		}
		// If disable we skip
		if (this._evtsEnabled === false) return;
		if (this.slowingDown) {
			return _stopClickEvent(this, evt, "slowing down");
		}
		if (this.cancelClick) {
			this.cancelClick = false;
			return _stopClickEvent(this, evt, "Click canceled");
		}
		if (this.lastClickAllowed != null && ((new Date().getTime() - this.lastClickAllowed) < 0)) {
			// Click is authorized if not slowingDown or if not cancelClick
			// We wait _lastClickTO after panend (mouseup) to allow click
			this.lastClickAllowed = null;
			return _stopClickEvent(this, evt, "Last click timeout");
		}
		if (this.parentMgr && this.parentMgr.dir != this.dir) {
			// For double scroll direction one by parent and one by a grid we need to sak the parent to cancel the click 
			this.parentMgr._onClick(evt);
			if (evt.$stop === true) {
				return _stopClickEvent(this, evt, "Parent stopped click");
			}
		}
		log && log("onClick not stopped");
	},
	/**
	 * Used to stop the slowdown process
	 */
	_onPress: function(evt) {
		this.lastPress = new Date().getTime();
		if (this.slowingDown) {
			this._stopSlowingDown();
			// Last click is avoided - The click evt that is always triggered after press a event
			this.cancelClick = true;
		}
		if (this.parentMgr) this.parentMgr.isLocked = false;
		log && log(this.id, "onPress", "slowingDown=" + this.slowingDown, "panStart=" + this.panStart, "cancelClick =" + this.cancelClick, "lastClickAllowed =" + this.lastClickAllowed);
	},
	/**
	 * pan event - mousedown/mousemove/mouseup
	 */
	_onPan: function(evt) {
		log && log(this.id, evt.type, this.dir, _isEvtDirection(evt, this.dir), "isLocked", this.isLocked);
		if (!_isEvtDirection(evt, this.dir)) return;
		if (this.isLocked === true) return;
		try {
			if (evt.type === "panstart") {
				// Mouse mousedown + mousemove event - start the process
				log && log(evt.type);
				this.panStart = true;
				this.cancelClick = true;
				this._stopSlowingDown();
				if (this.parentMgr && (this.parentMgr.dir === this.dir)) this.parentMgr.isLocked = true;
			} else if (evt.type === "panend") {
				// mouseup  - we continue to scroll (_slowDown) until the user do a press event to stop scrolling
				log && log(evt.type);
				this.panStart = false;
				if (_slowDown && this.lastVelocity != null) {
					// We keep the last velocity for slowdown process
					this.lastVelocity = Math.abs(this.lastVelocity);
					if (this.lastVelocity > 0.3 && this.lastVelocity < 1) {
						// If velocity is too small we keep 1
						this.lastVelocity = 1;
					} else {
						// under.3 we consider that we need to stop scrolling
						this.lastVelocity = Math.min(this.lastVelocity, 2);
					}
					if (this.lastVelocity >= 1) {
						// _slowDown option continue the process by decreasing the speed slowly and moving $$elmt
						this.slowingDown = true;
						this._slowDown(this.lastVelocity, this.lastUp);
						this.lastVelocity = this.lastUp = null;
					} else {
						if (this.parentMgr) this.parentMgr.isLocked = false;
					}
				} else {
					// avoid click on mouse up
					this.lastClickAllowed = new Date().getTime() + _lastClickTO;
					if (this.parentMgr) this.parentMgr.isLocked = false;
				}
				return;
			}
			// Direction of the scroll
			// Up means up or right 
			var up = evt.type === this.upEvtType || evt.type === "panstart" && evt.deltaY < 0;
			if (this._move(_velocityToDist(evt.velocity), up)) {
				this.lastVelocity = Math.abs(evt.velocity);
				this.lastUp = up;
			} else {
				this.lastVelocity = this.lastUp = null;
			}
		} catch (e) {
			console.log(JSON.stringify(jsutils.convertToDiagnoses(e), null, 2));
			return false;
		}
	},
	_stopSlowingDown: function() {
		this.slowingDown = false;
		if (this.parentMgr) this.parentMgr.isLocked = false;
	},
	/**
	 * Keep the last speed to continue scrolling process until the user do a press evt
	 */
	_slowDown: function(v, up) {
		var self = this;
		if (self.panStart || !self.slowingDown) {
			this._stopSlowingDown();
			return;
		}
		// keep the same velocity - to improve - we can decrease...
		if (v < 1) {
			this._stopSlowingDown();
			return;
		}
		if (self._move(_velocityToDist(v), up)) {
			// Move until stop with _slowDownTO timeout
			setTimeout(function() {
				self._slowDown(v, up);
			}, _slowDownTO);
		} else {
			this._stopSlowingDown();
		}
	},
	/**
	 * Move $$elmt vertically
	 */
	_move: function(dist, up) {
		if (!this.isInitialized() || dist == 0) {
			return;
		}
		try {
			var scroll = this.getScroll();
			// Check boundaries
			var val = up ? scroll - dist : scroll + dist;
			var valMin = this.getScrollMin();
			val = Math.max(Math.min(this.scrollMax, val), valMin);
			if (val === this.scrollMax || val === valMin) {
				log && log(this.id, "end scrolling");
				// avoid click during xx ms on mouse up at the end of scrolling
				this.lastClickAllowed = new Date().getTime() + _lastClickTO;
				this.cancelClick = false;
				if (scroll === val) {
					// Overflow -> Stop
					// log && log("_move overflow")
					return false;
				}
			}
			// Move elmt
			this._refresh(val);
			return true;
		} catch (e) {
			console.log(JSON.stringify(jsutils.convertToDiagnoses(e), null, 2));
			return false;
		}
	},
	/**
	 * Show element in the viewport - scroll if needed
	 * smoothOffset = null
	 * 		Regular behavior -> scroll $$e almost to the middle of the viewport 
	 * smoothOffset != null
	 * 		scroll $$e to make it just visible (stops scrolling when $e is visible)
	 * 		smoothOffset is used to adjust the position (empirical)
	 */
	makeVisible: function($$e, smoothOffset) {
		var scale = modules.get("siteLayout").getTransformScale();
		var prop = this.dir === "v" ? "top" : "left";
		var size = this.dir === "v" ? "height" : "width";
		if (!$$e || !this.isInitialized() || !this._evtsEnabled || $$e.closest(this.$$elmt).length === 0) {
			return;
		}
		if (this.slowingDown) {
			this._stopSlowingDown();
			// Last click is avoided - The click evt that is always triggered after press a event
			this.cancelClick = true;
		}
		/*
		WOCO - TODO expand the stack to show the element
		var curPage =  _getCurrentPage();
		if (!$$e.is(":visible") && curPage) {
			$$e.parents(".s-m-stack").map(function(stack) {
				var stackLayout = curPage.getLayout($(this).attr("id"));
				stackLayout && stackLayout.setAuthState({
					"collapsed": false
				});
			});
		}
		*/
		// smoothOffset used to tune the scrolling by the caller
		var smooth = smoothOffset != null;
		smoothOffset = smooth ? smoothOffset : 0;
		if (scale != 0 && scale != 1) {
			smoothOffset = smoothOffset * (1 / scale);
		}
		var o = $$e.offset();
		o[prop] = o[prop] + smoothOffset;
		var viewRectProp = this.viewRect[prop] * scale;
		var viewRectSize = this.viewRect[size] * scale;
		this.$$elmt.css("visibility", "hidden");
		var f = o[prop] > viewRectProp ? -1 : +1;
		var stopPos = Math.max(viewRectProp + viewRectSize - $$e[size](), viewRectProp + viewRectSize / 2);
		var step = f * (smooth ? 20 : 50);
		var stop = false;
		while (!stop) {
			var pos = $$e.offset()[prop] + smoothOffset;
			stop = f > 0 ? pos > stopPos : pos < stopPos;
			if (!stop) {
				this._refresh(this.getScroll() + step);
			}
		}
		var valMin = this.getScrollMin();
		if (this.getScroll() < valMin) {
			this._refresh(valMin);
		}
		if (this.getScroll() > this.scrollMax) {
			this._refresh(this.scrollMax);
		}
		this.$$elmt.css("visibility", "visible");
	},
	autoScroll: function(value) {
		this._move(Math.abs(value), value < 0);
	},
	/**
	 * Calculated dynamically because the content of the page can be modified after initisalization of scroller
	 */
	getScrollMin: function() {
		var prop = this.dir == "v" ? "height" : "width";
		var x = this.$$elmt[prop]();
		var scale = modules.get("siteLayout").getTransformScale();
		if (scale > 0 && scale != 1) {
			// !! With jQuery 3.1 the width/height are calculated according to the scale transform (it's wasn't the case for the previous version)
			// !! To not change the code we just divide x by the transform scale instead of multiplying
			x = x * (1 / scale);
		}
		// 30 pixel more
		return Math.min(this.scrollMax - x + this.viewRect[prop] - 30, this.scrollMax);
	},
	_setScroll: function(v) {
		if (v == null || isNaN(v)) {
			v = this.scrollMax;
		}
		this.val = v;
	},
	getScroll: function() {
		return this.val;
	},
	/**
	 *  Adjust the scroller after modification of DOM to make this.$$elmt visible
	 *  By example after an action which have hidden lines we need to call this method to adjust scrolling because the visible area can be outside the viewRect
	 */
	adjust: function(restoredScroll) {
		if (!this.isInitialized()) return false;
		var elmtRect = uiRect.elmtRect(this.$$elmt);
		if (this.viewRect.contains(elmtRect)) {
			// No scroll we set scrollMax
			this._refresh(this.scrollMax);
		} else {
			restoredScroll = restoredScroll == null ? this.getScroll() : restoredScroll;
			if (restoredScroll > this.scrollMax) {
				// outside the scop we set scrollMax
				restoredScroll = this.scrollMax;
			}
			var prop = this.dir == "v" ? "height" : "width";
			var valmin = this.scrollMax - elmtRect[prop] + this.viewRect[prop];
			if (restoredScroll < valmin) {
				// outside the scop we set scrollMin
				restoredScroll = this.getScrollMin();
			}
			this._refresh(restoredScroll);
		}
		return true;
	}
});

exports.Klass = _Klass;
exports.Hammer = Hammer;
exports.isEvtDirection = _isEvtDirection;
});

define('syracuse-tablet/html/js/helpers/scroller/nativeScroller',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/scroller/scrollerBase','syracuse-tablet/html/js/ui/rect'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/helpers/scroller/scrollerBase').Klass;
var uiRect = require('syracuse-tablet/html/js/ui/rect');

var _consts = {
	dirToAxis: {
		v: "y",
		h: "x"
	},
	dirToOtherAxis: {
		v: "x",
		h: "y"
	}
};

var _Klass = utils.defineClass(function NativeScroller($$elmt, options) {
	Base.call(this, $$elmt, options);
}, Base, {
	isNative: function() {
		return true;
	},
	_doInit: function(viewRect, dir, scrollMax, preserveScroll) {
		var css = {};
		css["overflow-" + _consts.dirToAxis[this.dir]] = "auto"; // scrolling axis
		css["overflow-" + _consts.dirToOtherAxis[this.dir]] = "hidden"; // "unused" or fixed axis
		this.$$elmt.addClass("isScrollElmt").parent().css(css).addClass("isScrollWrapper");
		// remove default touch action on all elements
		// would be better if doing this by loading a css file with the appropriate * {} selector instead of setting it on each element
		var css = {};
		if (this.scrollMax === 0 && this.options.nopadding !== true) {
			var prop = this.dir === "h" ? "right" : "bottom";
			// blank line of 10 pixels at the end of scrolling
			css["padding-" + prop] = "10px";
		}
		var prop = this.dir === "h" ? "width" : "height";
		var valProp = this.viewRect[prop];
		if (false) {
			css["border"] = "red solid 1px";
			// To actually see the rectangle
			valProp -= 2;
		}
		this.$$elmt.parent()[prop](valProp).css(css);
	},
	reset: function(dontResetValue) {
		var wasInitialized = this.isInitialized();
		Base.prototype.reset.call(this, dontResetValue);
		if (!this.$$elmt || !wasInitialized) return;
		var prop = this.dir === "h" ? "width" : "height";
		// We restore 100% rather than auto (auto doesn't work i panels when we switch orientation) - 100% is better for the wrapper
		this.$$elmt.parent().css(prop, "100%");
	},
	getScroll: function() {
		return this.$$elmt ? this.$$elmt.parent()[this.dir === "h" ? "scrollLeft" : "scrollTop"]() : this.scrollMax;
	},
	_refresh: function(scroll, force) {
		if (!this.$$elmt) return;
		if (scroll == null && force !== true) return;
		scroll = Math.max(scroll == null ? this.scrollMax : scroll, this.scrollMax);
		var cur = this.getScroll();
		if (cur === scroll && force !== true) return;
		this.$$elmt.parent()[this.dir === "h" ? "scrollLeft" : "scrollTop"](scroll);
	},
	makeVisible: function($$e) {
		if (!$$e || $$e.length === 0 || $$e.is(":visible") || !$$e.get(0).scrollIntoView) {
			return;
		}
		$$e.get(0).scrollIntoView(false);
	},
	autoScroll: function(value) {
		if (!this.isInitialized()) {
			// Set at initialization
			this.restoredScroll = value;
		} else {
			this._refresh(value, true);
		}
	},
	getScrollMin: function() {
		return this.$$elmt ? this.$$elmt.height() : 0;
	},
	/**
	 *  Adjust the scroller after modification of DOM to make this.$$elmt visible
	 *  By example after an action which have hidden lines we need to call this method to adjust scrolling because the visible area can be outside the viewRect
	 */
	adjust: function(restoredScroll) {
		if (!this.isInitialized()) return false;
		if (this.viewRect.contains(uiRect.elmtRect(this.$$elmt))) {
			// No scroll we set scrollMax
			this._refresh(this.scrollMax);
		} else {
			this._refresh(restoredScroll == null ? this.getScroll() : restoredScroll);
		}
		return true;
	}
});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers',['require','exports','module','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/environment','syracuse-tablet/html/js/helpers/scroller/hammerScroller','syracuse-tablet/html/js/helpers/scroller/nativeScroller'],function (require, exports, module) {

var uiRect = require('syracuse-tablet/html/js/ui/rect');
var environment = require('syracuse-tablet/html/js/helpers/environment');

var _scrollerId = 1;
var _ctor = {
	desktop: require('syracuse-tablet/html/js/helpers/scroller/hammerScroller').Klass,
	native: require('syracuse-tablet/html/js/helpers/scroller/nativeScroller').Klass
};

var _createSimpleScroller = function($$elmt) {
	var $$scrolls = $$elmt.find(".s-m-scroll-element");
	var i;
	var scrollers = {};

	for (i = 0; i < $$scrolls.length; i++) {
		_scrollerId++;

		var $$se = $($$scrolls[i]);
		var $$wrapper = $$se.parent();
		var dir = $$wrapper.hasClass("s-m-scroll-wrapper-h") ? "h" : "v";

		$$wrapper.attr("data-scroller-id", _scrollerId);

		var parentScroller = null;
		var $$parentScroller = $$wrapper.parent().closest(".s-m-scroll-wrapper");
		if ($$parentScroller.length > 0) {
			parentScroller = scrollers[$$parentScroller.attr("data-scroller-id")];
		}

		var css = {};
		css["overflow-" + dir] = "auto";
		$$wrapper.css(css);

		var gestureMgr = _newScroller($$se, {
			direction: dir,
			valMax: 0,
			name: "_scroller_" + _scrollerId,
			isPageScroller: false
		}, parentScroller);
		scrollers[_scrollerId] = gestureMgr;
		// reset old scrolling to calculate width/height (mandatory in native mode)
		gestureMgr.reset();
		var scrollRect = uiRect.elmtRect($$se, "outer");
		var wrapperRect = uiRect.elmtRect($$wrapper, "outer");
		var viewRect = wrapperRect.intersectRect(scrollRect);
		if (viewRect && !viewRect.contains(scrollRect)) {
			gestureMgr.init(viewRect);
		}
	}

	return scrollers;
};

var _newScroller = function($$elmt, options, parentMgr, forceNative) {
	var name;
	if (environment.isNativeScrolling() || forceNative) {
		name = "native";
	} else {
		name = "desktop";
	}
	var Klass = _ctor[name];
	if (!Klass) throw new Error("Scroller not initialized");
	$$elmt.addClass(name + "Scroll");
	return new Klass($$elmt, options, parentMgr);
};
exports.newScroller = _newScroller;
exports.createSimpleScroller = _createSimpleScroller;
});

define('syracuse-tablet/html/js/ui/modals/modalDialog',['require','exports','module','syracuse-tablet/html/js/app/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/scroller/scrollerHelpers','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var globals = require('syracuse-tablet/html/js/app/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var modules = require('syracuse-tablet/html/js/common/modules');

var _dialogTpl = '\
	<div class="modal {{displayFlags.modalClass}}" tabindex="-1" role="dialog">\
	<div class="modal-dialog">\
	<div class="modal-content"> \
		{{{header}}} \
		<div class="modal-body">{{{content}}}</div> \
		{{{footer}}} \
	</div> \
	</div>\
	</div>';

var _openModalsPromises = [];

/**
 *
 */
var _Klass = utils.defineClass(

	function BaseModal() {
		var self = this;
		var site = modules.get("siteLayout");
		self.deviceType = site.getDeviceType(); // tablet or smartphone
		self.displayFlags = {
			modalClass: ""
		};
	}, null, {
		destroy: function() {
			if (this.$$elmt) {
				this.$$elmt.unbind();
				this.$$elmt.remove();
			}
			this._checkShowNextModal();
			notifications.unsubscribe(this);
		},

		_checkShowNextModal: function() {
			_openModalsPromises.shift();
			if (_openModalsPromises.length > 0) {
				_openModalsPromises[0].resolve();
			}
		},
		/*
		 * =======================================
		 * Functions that must be overiden
		 * =======================================
		 */

		/*
		 * Needs to be overiden by dialog implementations
		 * Returns html template per device (or only std if no special ones)
		 */
		_getTemplates: function() {
			return {
				std: {},
				tablet: {},
				smartphone: {}
			};
		},

		/*
		 * Needs to be overiden by dialog implementations
		 * Returns data to merge into template
		 */
		_getDataContext: function() {
			return {};
		},


		/*
		 * Can be overidden to handle clicks on data-action=$validate.
		 * Should set value returned by _getResult()
		 * Return false to NOT close dialog
		 */
		_onValidate: function() {

		},

		/*
		 * Can be overidden to handle clicks on data-action=$cancel.
		 * Should set value returned by _getResult()
		 * Return false to NOT close dialog
		 */
		_onCancel: function() {

		},

		/*
		 * Can be overidden to set result of dialog when it is closed
		 *
		 */
		_getResult: function() {

		},

		/*
		 * =======================================
		 * Functions that may be overiden
		 * =======================================
		 */

		/*
		 * Can be overidden to handle clicks on data-action dom elements.
		 * param=data-param
		 * Return false to NOT close dialog
		 */
		_onAction: function(action, param) {

		},

		_compileTpl: function() {
			var self = this;
			var htmlTpls = self._getTemplates();
			var htmlTpl = htmlTpls[self.deviceType] || htmlTpls["std"];

			var tpl = {
				header: Handlebars.compile(htmlTpl.header),
				content: Handlebars.compile(htmlTpl.content),
				footer: Handlebars.compile(htmlTpl.footer),
			};
			return tpl;
		},

		_getWrapperTemplate: function() {
			return Handlebars.compile(_dialogTpl);
		},

		_ensureParent: function() {
			var self = this;
			var parentName = globals.isAuthoringActive() ? "s-m-modal-parent-auth" : "s-m-modal-parent";
			var $$parent = $("#" + parentName);
			if ($$parent.length < 1) {
				$$parent = $("<div>");
				$$parent.attr("id", parentName);
				if (globals.isAuthoringActive()) {
					$("body").append($$parent);
				} else {
					// If application not initialized we must display the message (error in init process)
					$("#s-m-app-container-id").css({
						width: "100%",
						height: "100%"
					});
					$("#s-m-app-id").show().addClass("s-m-modal-parent").append($$parent);
				}
			}
			self.$$parent = $$parent;
		},

		_createDOM: function() {
			var self = this;
			self.$$elmt = $(self.html);
		},

		getDisplayFlags: function() {
			var self = this;
			return self.displayFlags;
		},

		_hookEvents: function() {
			var self = this;
			self.$$elmt.on("shown.bs.modal", self._onShow.bind(self));
			self.$$elmt.on("hide.bs.modal", self._onHide.bind(self));

			self.$$elmt.delegate("[data-action]", "click", self._onButton.bind(self));
		},

		_attachDOM: function() {
			var self = this;
			self.$$parent.toggle(true);
			self.$$parent.append(self.$$elmt);
			self.$$elmt.modal({
				keyboard: false,
				backdrop: "static"
			});
		},

		_onShow: function(evt) {
			var self = this;
			self.$$elmt.css("padding-left", "");
			self._calcSize();
			var app = modules.get("appController").App;
			if (app) {
				app.onModalOpened();
				self._initScrollers();
				notifications.subscribe(self, "sm.main.layout.changed");
			}
		},

		notifMainLayoutChanged: function(info, orientation, deviceType) {
			// Used by some dialogs
		},

		_onHide: function(evt) {
			var self = this;
			self.$$parent.toggle(false);
			var app = modules.get("appController").App;
			if (app) {
				app.onModalClosed();
			}
			self.deferred.resolve(self._getResult());
			self.destroy();
		},

		_onButton: function(evt) {
			var self = this;
			var $$t = $(evt.currentTarget);

			var param = $$t.attr("data-params");
			var act = $$t.attr("data-action");
			if (act) {
				evt.preventDefault();
				evt.stopPropagation();

				var res;
				if (act === "$validate") {
					res = self._onValidate();
				} else if (act === "$cancel") {
					res = self._onCancel();
				} else {
					res = self._onAction(act, param);
				}
				//_onCancel/_onCancel/_onAction can return either a promise or a data
				// So we can call asynchronous processes in theses methods
				utils.toPromise(res).then(function(res) {
					if (res !== false) {
						self.$$elmt.modal('hide');
					}
				});
			} else {
				// Close modal
				self.$$elmt.modal('hide');
			}
		},

		/**
		 * This is the only function to be called from a dialog user
		 * It shows the dialog and resolves the returned promise as soon as the dialog is closed
		 * forceDisplay: error forces the display of the modal
		 */
		show: function(forceDisplay) {
			var self = this;
			var startShow = new $.Deferred();
			if (forceDisplay === true) {
				_openModalsPromises = [];
			}
			_openModalsPromises.push(startShow);
			// First modal to open, so execute immediately
			if (_openModalsPromises.length === 1 || forceDisplay === true) {
				startShow.resolve();
			}

			self.deferred = new $.Deferred();
			startShow.then(function() {
					return self._getDataContext();
				}).then(function(data) {
					self.data = data;
				})
				.then(function() {
					self.template = self._compileTpl();
					var outerTpl = self._getWrapperTemplate();

					var header = self.template.header(self.data);
					var footer = self.template.footer(self.data);

					if (header.length > 0) {
						header = '<div class="modal-header">' + header + '</div>';
					}
					if (footer.length > 0) {
						footer = '<div class="modal-footer">' + footer + '</div>';
					}

					self.html = outerTpl({
						header: header,
						content: self.template.content(self.data),
						footer: footer,
						displayFlags: self.getDisplayFlags()
					});
					self._ensureParent();
					self._createDOM();
					self._hookEvents();
					self._attachDOM();
				}).fail(function(e) {
					// Cancel pending dialogs
					_openModalsPromises = [];
					self.deferred.reject(e);
				});

			return self.deferred.promise();
		},

		/*
		 *
		 */
		_initScrollers: function() {
			scroller.createSimpleScroller(this.$$elmt);
		},

		_calcSize: function() {
			var self = this;

			var df = self.getDisplayFlags();
			if (df.modalClass.indexOf("half_center") > -1 ||
				df.modalClass.indexOf("half_right") > -1 ||
				df.modalClass.indexOf("full") > -1) {
				var $$content = self.$$elmt.find(".modal-content");
				var $$header = self.$$elmt.find(".modal-header");
				var $$body = self.$$elmt.find(".modal-body");
				var $$footer = self.$$elmt.find(".modal-footer");

				var header = $$header.length > 0 ? uiRect.elmtRect($$header, "outer").height : 0;
				var footer = $$footer.length > 0 ? uiRect.elmtRect($$footer, "outer").height : 0;

				$$body.css({
					"top": header,
					"height": $$content.height() - header - footer
				});
			}
		}
	}
);

var _checkMsg = function(msg) {
	return msg ? msg.replace(/\n/g, "<br>") : "";
};

exports.checkMsg = _checkMsg;
exports.ModalBase = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalDiagnoses',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/helpers/scroller/scrollerHelpers','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/scroller/hammerScroller'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var hammerScroller = require('syracuse-tablet/html/js/helpers/scroller/hammerScroller');

var _templateAll = {
	header: '\
		<div class="modal-title {{severity}}">{{title}}</div>',
	content: '\
		<div class="s-m-modal-diag-content">\
			{{#each diags}} \
				<message id="s-m-msg-block-{{id}}" role="alert" style="display:{{this.display}}"> \
					<div style="white-space: pre-line; user-select: initial;">{{this.message}}</div> \
					{{#if stack}} \
						<a id="s-m-msg-stack-{{id}}" draggable="false" name="more" href="#" data-action="more">{{../stackShow}}</a> \
						<section>\
							<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
								<stack name="s-m-scroll-element stack" class="s-m-msg-stack-content"> \
									{{{this.stack}}} \
								</stack> \
							</div> \
						</section>\
					{{/if}} \
				</message> \
			{{/each}}\
		</div>\
		<div class="s-m-modal-diag-goto">\
			{{#each diags}}\
				<a id="s-m-msg-goto-{{id}}" data-action="goto" data-params="{{id}}">\
					<i class="fa fa-circle-o" data-action="goto" data-params="{{id}}"></i>\
				</a>\
			{{/each}}\
		</div>',
	footer: '<div style="width:100%; display: inline-block;"></div><button type="button" class="btn btn-default" data-action="$cancel">{{close}}</button>'
};


var _Klass = utils.defineClass(
	function ModalDiagnoses(title, diag) {
		var self = this;
		modalDialog.ModalBase.call(self);
		// Init params
		self.title = title;
		self.diag = diag;
		self.diagId = 0;
		self.curMsg = 0;
	}, modalDialog.ModalBase, {
		destroy: function() {
			var self = this;
			// destroy hammer component
			this._destroySwiper();
			// destroy gestureMgr (used for vertical swipe within the stack)
			if (this._gestureMgrMap && !$.isEmptyObject(this._gestureMgrMap)) {
				$.each(this._gestureMgrMap, function(key, gestureMgr) {
					gestureMgr.destroy();
				});
				this._gestureMgrMap = null;
			}
			modalDialog.ModalBase.prototype.destroy.call(self);
		},
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},
		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "diagnoses tablet";
			} else {
				displayFlags.modalClass = "diagnoses mobile";
			}
			return displayFlags;
		},
		_getDataContext: function() {
			var self = this;
			var ctx = {
				close: locale.text("modal.btn.close") || "Close",
				stackShow: locale.text("modal.diagnoses.btnstack_show"),
				severity: "info",
				diags: []
			};
			self.diag.$diagnoses.forEach(function(d) {
				var sev;
				if (d.$severity === "success" || d.$severity === "info" || d.$severity === "warning") {
					sev = d.$severity;
				} else {
					sev = "danger";
					ctx.severity = "error";
				}
				var ctxDiag = {
					id: self.diagId,
					display: self.diagId === 0 ? "block" : "none",
					message: d.$message,
					severity: sev,
					severityLabel: locale.text("severity." + sev)
				}
				if (d.$stackTrace) {
					var a = d.$stackTrace.split("\n");
					if (a.length > 20) {
						a.length = 20;
						a.push("...");
					}
					ctxDiag.stack = a.join("<br>");
				}
				ctx.diags.push(ctxDiag);
				self.diagId++;
			});

			self.title = self.title || (ctx.severity === "error" ? locale.text("modal.error.ttl") : locale.text("modal.info.ttl"));
			ctx.title = self.title;

			return ctx;
		},
		_onAction: function(action, param) {
			var self = this;
			switch (action) {
				case "next":
					self._next();
					break;
				case "prev":
					self._prev();
					break;
				case "more":
					self._more();
					break;
				case "goto":
					self._goTo(param);
					break;
			}

			// dont close on actions
			return false;
		},
		_goTo: function(id) {
			var self = this;
			for (var ii = 0, jj = self.diagId; ii < jj; ii++) {
				$("#s-m-msg-block-" + ii, self.$$elmt).css("display", ii == id ? "block" : "none");
			}
			self.curMsg = parseInt(id, 10);
			self._updateButtons();
		},
		_next: function() {
			var self = this;
			if (self.curMsg < (self.diagId - 1)) {
				$("#s-m-msg-block-" + self.curMsg, self.$$elmt).css("display", "none");
				self.curMsg++;
				$("#s-m-msg-block-" + self.curMsg, self.$$elmt).css("display", "block");
				self._updateButtons();
			}
		},
		_prev: function() {
			var self = this;
			if (self.curMsg > 0) {
				$("#s-m-msg-block-" + self.curMsg, self.$$elmt).css("display", "none");
				self.curMsg--;
				$("#s-m-msg-block-" + self.curMsg, self.$$elmt).css("display", "block");
				self._updateButtons();
			}
		},
		_more: function() {
			var self = this;
			var $$btn = $("#s-m-msg-stack-" + self.curMsg, self.$$elmt);
			var $$stackSection = $("section", $$btn.parent());
			if ($$stackSection.css("display") === "none") {
				$$stackSection.css("display", "block");
				$$btn.text(locale.text("modal.diagnoses.btnstack_hide"));
				self._handleGesture();
			} else {
				$$stackSection.css("display", "none");
				$$btn.text(locale.text("modal.diagnoses.btnstack_show"));
			}
		},
		_updateButtons: function() {
			var self = this;

			for (var ii = 0, jj = self.diagId; ii < jj; ii++) {
				var $$navDot = $("a#s-m-msg-goto-" + ii + " i", self.$$elmt);
				$$navDot.toggleClass("fa-circle", ii == self.curMsg);
				$$navDot.toggleClass("fa-circle-o", ii !== self.curMsg);
			}

			// Only show x of y in case there are more than 1 diagnoses
			if (self.diagId > 1) {
				$(".modal-title", self.$$elmt).text(self.title + " (" + (self.curMsg + 1) + "/" + self.diagId + ")");
			} else {
				// hide nav circles if one diag only
				$(".s-m-modal-diag-goto", self.$$elmt).css("display", "none");
			}
		},
		_onShow: function(evt) {
			var self = this;
			modalDialog.ModalBase.prototype._onShow.call(self, evt);
			self._updateButtons();

			self._checkSize();
			// init swype handler if more than one diagnose
			if (self.diagId > 1) {
				self._initSwiper();
			}
		},
		_handleGesture: function() {
			var self = this;
			self._gestureMgrMap = self._gestureMgrMap || {};

			if (!self._gestureMgrMap["gestureMgr" + self.curMsg]) {
				var $$scrollElmt = $(".s-m-msg-stack-content", $("#s-m-msg-block-" + self.curMsg, self.$$elmt));
				var $$wrapper = $(".s-m-scroll-wrapper", $("#s-m-msg-block-" + self.curMsg, self.$$elmt));

				self._gestureMgrMap["gestureMgr" + self.curMsg] = scroller.newScroller($$scrollElmt, {
					direction: "v"
				});
				var scrollRect = uiRect.elmtRect($$wrapper, "outer");
				self._gestureMgrMap["gestureMgr" + self.curMsg].init(scrollRect);
			}
		},
		/*
		 * User can navigate from one diagnose to another with a swipe gesture.
		 * This method will display appropriate diagnose message depending on the swipe gesture
		 */
		_onSwipe: function(evt) {
			if (hammerScroller.isEvtDirection(evt, "v")) return;

			var self = this;
			setTimeout(function() {
				var next = evt ? evt.type === "swipeleft" : null;
				if (next) {
					self._next();
				} else {
					self._prev();
				}
			});
		},
		_destroySwiper: function() {
			var self = this;
			if (self.hammer) {
				self.hammer.destroy();
				self.hammer = null;
			}
		},
		_initSwiper: function() {
			var self = this;
			self._destroySwiper();
			self.hammer = new hammerScroller.Hammer($(".s-m-modal-diag-content", self.$$elmt).get(0));
			self.hammer.get("swipe").set({
				direction: hammerScroller.Hammer.DIRECTION_HORIZONTAL
			});
			// listen to events...
			this.hammer.on("swipeleft swiperight", hammerScroller.Hammer.bindFn(self._onSwipe, self));
		},
		_checkSize: function() {
			var self = this;
			var $$app = $("#s-m-app-id");
			var $$stacks = $("message > section", self.$$elmt);
			$$stacks.css({
				"max-height": ($$app.height() - 200) + "px"
			});
		}
	}
);
exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalConfirm',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _templateAll = {
	header: '\
		<div class="modal-title">{{title}}</div>',
	content: '\
			<div class="s-m-modal-content">\
				{{message}}\
			</div>',
	footer: '\
		<button type="button" class="btn btn-default" data-action="yes">{{yes}}</button> \
		<button type="button" class="btn btn-default" data-action="no">{{no}}</button>'
};

var _Klass = utils.defineClass(
	function ModalConfirm(message, action, isSimpleConfirm) {
		var self = this;
		modalDialog.ModalBase.call(self);
		// Init params
		self.message = message;
		self.action = action;
		self.isSimpleConfirm = isSimpleConfirm;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},
		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "confirm tablet";
			} else {
				displayFlags.modalClass = "confirm mobile";
			}
			return displayFlags;
		},
		_getDataContext: function() {
			var self = this;
			var ctx = {};
			ctx.title = self.isSimpleConfirm ? null : locale.text("modal.confirm.ttl");
			// different message depending on whether the calling modal.js method is confirm() or simpleConfirm()
			ctx.message = self.action ? modalDialog.checkMsg(locale.text("modal.confirm.msg", [self.action])) : modalDialog.checkMsg(self.message);
			ctx.yes = locale.text("yes");
			ctx.no = locale.text("no");
			return ctx;
		},
		_onAction: function(action, param) {
			var self = this;
			self.selectedAction = action;
			// close on actions
			return true;
		},
		_getResult: function() {
			var self = this;
			return self.selectedAction;
		}
	}
);
exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalField',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _templateAll = {
	header: '\
		<buttons class="pull-right"> \
			<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
		</buttons> \
		<div class="modal-title">{{title}}</div>',
	content: '{{{domBody}}}',
	footer: ''
};


var _Klass = utils.defineClass(
	function ModalField(title, domBody, cb) {
		var self = this;
		modalDialog.ModalBase.call(self);
		// Init params
		self.title = title || "Warning";
		self.domBody = domBody;
		self.cb = cb;
	}, modalDialog.ModalBase, {
		destroy: function() {
			modalDialog.ModalBase.prototype.destroy.call(this);
			this.domBody = null;
			this.cb = null;
		},
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},
		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "field tablet";
			} else {
				displayFlags.modalClass = "field mobile";
			}
			return displayFlags;
		},
		_getDataContext: function() {
			var self = this;
			return {
				title: self.title,
				domBody: self.domBody,
				close: locale.text("modal.btn.close")
			};
		},
		_onShow: function(evt) {
			var self = this;
			modalDialog.ModalBase.prototype._onShow.call(self, evt);
			self._execCb(self.cb, "shown.bs.modal", self.$$elmt);
		},
		_onCancel: function() {
			return true;
		},
		_onHide: function(evt) {
			var self = this;
			modalDialog.ModalBase.prototype._onHide.call(self, evt);
			self._execCb(self.cb, "hide.bs.modal", self.$$elmt);
		},
		_execCb: function(cb, msg, data) {
			if (!cb || arguments.length == 0) return;
			var cb = arguments[0];
			var args = Array.prototype.slice.call(arguments, 1);
			cb.apply(null, args);
		}
	}
);
exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modal',['require','exports','module','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/ui/modals/modalDiagnoses','syracuse-tablet/html/js/ui/modals/modalConfirm','syracuse-tablet/html/js/ui/modals/modalField','syracuse-tablet/html/js/helpers/environment'],function (require, exports, module) {

var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var native = require('syracuse-tablet/html/js/helpers/native/native');
var modules = require('syracuse-tablet/html/js/common/modules');

// Separated module for showing diagnoses since it may be replaced depending on device/OS
var ModalDiagnoses = require('syracuse-tablet/html/js/ui/modals/modalDiagnoses').Modal;
var ModalConfirm = require('syracuse-tablet/html/js/ui/modals/modalConfirm').Modal;
var ModalField = require('syracuse-tablet/html/js/ui/modals/modalField').Modal;
var environment = require('syracuse-tablet/html/js/helpers/environment');

var _templates = {
	actionMessage: '\
		<div class="s-m-act-msg {{severityClass}}">\
			<a draggable="false" href="#"><span class="glyphicon glyphicon-remove"></span></a>\
			<header>\
				<div>{{title}}</div>\
			</header>\
			<section>\
				<article>{{message}}</article>\
			</section>\
			<footer></footer>\
		</div>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

/* First param : cb - Second msg - Third data ...*/
var _execCb = function(cb, msg, data) {
	if (!cb || arguments.length == 0) return;
	var cb = arguments[0];
	var args = Array.prototype.slice.call(arguments, 1);
	cb.apply(null, args);
};


/************************************************************************
 ** IMPORTANT
 * The code of the callback parameter in the exported methods :
 * error(), info(), diagnoses(), field(), confirm(), simpleconfirm(), modal()
 * has to indicate whether the callback is called :
 * - when the modal opens
 * - when the modal closes
 * - at both events
 *
 * Here is an example :
 * function (modalEvent, $$modalElmt) {
 *        // build content on open
 *       if (modalEvent == 'shown.bs.modal') {
 *           // code which is run on modal opening
 *       }
 *
 *       // run actions on close 'hidden.bs.modal'
 *       else {
 *       	// code which is run on modal closing
 *       }
 * });
 *************************************************************************/

var _asynchDiagnoses = function(title, diag, forceDisplay) {
	var modal = new ModalDiagnoses(title, diag);
	return modal.show(forceDisplay === true)
};

var _asynchError = function(title, e) {
	// in the code we can have error(e)
	var error = e;
	if (title != null && typeof title !== "string") {
		error = title;
		title = null;
	}
	var diag;
	diag = jsutils.convertToDiagnoses(error);
	if (title == null && error && error.$title) {
		title = error.$title;
	}
	return _asynchDiagnoses(title, diag, true);
};

exports.asynchError = _asynchError;

/*
 * Examples
 * 
 * error("There was an error");
 * 
 * error("There was an error", "I am the detail text");
 *
 * error("There was an error", new Error("I am an exception"));
 * 
 * error("There was an error", {
 *   $diagnoses: [{
 *	   $message: "Message 1",
 *     $severity: "error",
 *     $stackTrace: "bla"
 *	 }, {
 * 	   $message: "Message 2",
 *	   $severity: "info",
 * 	   $stackTrace: "bla"
 *   }]
 * });
 * 
 * error("There was an error", {
 *   message: "I am the message", 
 *   detail: "I am the detail message"
 * });

 * error("There was an error", {
 *   message: "I am the message", 
 *   detail: new Error("I am an exception")
 * });
 * 
 */
var _error = function(title, e, cb) {
	// in the code we can have error(e)
	var error = e;
	var callBack = cb;
	if (title != null && typeof title !== "string") {
		error = title;
		title = null;
	}
	if (typeof e === "function") {
		callBack = e;
	}
	var diag;
	diag = jsutils.convertToDiagnoses(error);
	if (title == null && error && error.$title) {
		title = error.$title;
	}
	return _diagnoses(title, diag, callBack, true);
};

/*
 * title. Title of dialog
 * diag: Object containing diagnoses
 *       {
 *           $diagnoses: [{
 *               $message: "bla...",
 *               $severity: "error", // success, info, warning, error
 *               $stackTrace: "Stacktrace as string, formatted"
 *           }, {
 *               ...
 *           }]
 *       }
 * cb: Callback
 */
var _diagnoses = function(title, diag, cb, forceDisplay) {
	var modal = new ModalDiagnoses(title, diag);
	modal.show(forceDisplay === true).then(function(result) {
		if (cb) {
			cb(result);
		}
	});
	//return modalDiag.show(title, diag, cb);
};

/* 
 * Wrap info text into diagnoses and display it in the generic diagnoses dialog
 */
var _info = function(title, text, cb) {
	var infoDiag = {
		"$diagnoses": [{
			"$severity": "info",
			"$message": text
		}]
	};
	_diagnoses(title, infoDiag, cb);
};
var _warning = function(title, text, cb) {
	_diagnoses(title, {
		"$diagnoses": [{
			"$severity": "warning",
			"$message": text
		}]
	}, cb);
};
var _confirm = function(action, cb) {

	var modal = new ModalConfirm(null, action);

	modal.show().then(function(result) {
		if (cb && (result === "yes" || result === "no")) {
			cb(result, "yes" === result);
		}
	});
};

var _simpleConfirm = function(message, cb) {
	var modal = new ModalConfirm(message, null, true);

	modal.show().then(function(result) {
		if (cb && (result === "yes" || result === "no")) {
			cb(result, "yes" === result);
		}
	});
};

/*
 * simpleConfirmPromise({
 *   message: "Are you sure?"
 *   }).then(function(result) {
 *      if (result.action === "yes") {
 *      } else if (result.action === "no") {
 *      }
 *   });
 */
exports.simpleConfirmPromise = function(options) {
	var deferred = $.Deferred();
	var modal = new ModalConfirm(options.message, null, true);

	modal.show().then(function(result) {
		if (result === "yes" || result === "no") {
			deferred.resolve({
				action: result
			});
		}
	});

	return deferred.promise();
};
/*
 * Open a modal window linked to a field
 */
var _field = function(title, domBody, cb) {
	var modal = new ModalField(title, domBody, cb);
	modal.show();
};

/* options properties are :
- severityClass : css class depending on severity
- title : title text value used in the template
- text : body text value used in the template
- $$parentSlot : parent to which modal is appended, depends on device type
*/
var _notificationHandler = function(options) {
	// #8583 - Check if there's already the same message displayed
	var stop = false;
	$(document.body).find(".s-m-act-msg." + options.severityClass).each(function(index) {
		var $e = $(this)
		if ($e.find("div:contains('" + options.title + "')").length > 0 && $e.find("div:contains('" + options.body + "')").length > 0) {
			stop = true;
			return false;
		}
	})
	if (stop) {
		return;
	}
	// create html
	var h = _getHtml("actionMessage", {
		title: options.title,
		message: options.body,
		severityClass: options.severityClass
	});

	var isClosing;
	// append to app according to device type
	var $$actionModal = $(h);
	options.$$parentSlot.prepend($$actionModal);

	// show parentSlot
	options.$$parentSlot.show();

	// close anchor
	var $$closer = $$actionModal.find("a");

	function toggle() {
		$$actionModal.toggleClass("show");
	}
	var delay = options.delay || "medium";
	delay = delay === "short" ? 1500 : delay === "long" ? 7000 : 5000;

	function clear() {
		toggle();
		// set timeout in order to have css animation visible before removing DOM
		setTimeout(function() {
			$$actionModal.remove();

			// hide parent slot if last item removed
			if (options.$$parentSlot.children().length == 0) {
				options.$$parentSlot.hide();
			}
		}, 500);
	};

	// bind click action on closer button. triggers close action
	$$closer.bind("click", function() {
		clear();
		isClosing = true;
	});

	// display
	// setTimeout is necessary to have the display css animation working
	setTimeout(function() {
		toggle();
	}, 50);

	// toggle after 5 seconds
	var toggleTimeout = setTimeout(function() {
		if (!isClosing) {
			clear();
		}
	}, delay);
};

/**
 * options.onlyWebapp = true if set, notification is not send to operation system but only showen inside application
 */
exports.notify = function(options) {
	var nativeToastMsg = native.hasCapability("toastMessages") === true
	if (environment.isOs("ios") && nativeToastMsg) {
		// nativeToastMsg always
	} else if (options != null && options.onlyWebapp === true) {
		/// Force display by web app
		nativeToastMsg = false
	}
	if (nativeToastMsg === true) {
		// Displayed by native wrapper
		native.getModule("toastMessages").showToastMessage({
			Text1: options.title,
			Text2: options.body,
			Severity: options.severityClass
		});
	} else {
		exports.forceNotifyWebApp(options);
	}
};
// For tests
exports.forceNotifyWebApp = function(options) {
	if (!options) {
		return;
	}
	options.$$parentSlot = options.$$parentSlot || modules.get("appController").App.getMessageSlot();
	_notificationHandler(options);
};

exports.noConnectionModal = function() {
	return _error(
		locale.text("action.title.offline"),
		locale.text("action.needs.net"));
};


/*
 * Creates a diagnoses that contains a general message reporting there was a technical isse
 * This must be used whenever there is an error that the user cannot understand anyway to hide technical
 * defauls from the user
 */
exports.createGeneralErrorDiag = function(source) {
	return {
		$diagnoses: [{
			$message: locale.text("technical.error.message"),
			$severity: "error",
			$stackTrace: JSON.stringify(source)
		}]
	};
};

exports.error = _error;
exports.info = _info;
exports.warning = _warning;
exports.diagnoses = _diagnoses;
exports.field = _field;
exports.confirm = _confirm;
exports.simpleConfirm = _simpleConfirm;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/monthChoice',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/types/date'],function (require, exports, module) {
var utils = require('syracuse-tablet/html/js/helpers/utils');
var _dateApi = require('syracuse-tablet/html/js/helpers/types/date');

var _Klass = utils.defineClass(

	function() {

	}, null, {
		create: function(parentSlot, dateValue, handler) {
			this.parent = parentSlot;
			this.handler = handler;
			this.domItem = document.createElement("nav");
			this.domItem.className = "s-calendar-quick-list";
			this._dateValue = dateValue;
			var table = document.createElement("table");
			table.className = "s-calendar-month-choice";
			var tbody = document.createElement("tbody");
			for (var ii = 0; ii < 6; ii++) {
				var row = document.createElement("tr");
				row.appendChild(this.drawCell(ii + 1, _dateApi.monthName(ii + 1, true), this._dateValue.month));
				row.appendChild(this.drawCell(ii + 7, _dateApi.monthName(ii + 7, true), this._dateValue.month));
				tbody.appendChild(row);
			}
			table.appendChild(tbody);
			this.domItem.appendChild(table);
			this.parent.appendChild(this.domItem);
			this.bindEvents(true);
		},
		drawCell: function(value, text, selValue) {
			var td = document.createElement("td");
			td.className = "s-calendar-my-item";
			td.syraOnClick = "onMonthClick";
			td.syraValue = value;
			td.textContent = text;
			if (value == selValue) {
				td.className += " s-calendar-select";
				this.selectedCell = td;
			}
			return td;
		},
		toggle: function(show) {
			if (show) {
				this.domItem.style.display = "";
			} else {
				this.domItem.style.display = "none";
			}
		},
		onMonthClick: function(picker) {
			if (this.selectedCell) {
				this.selectedCell.className = "s-calendar-my-item";
			}
			(this.selectedCell = picker).className = "s-calendar-my-item s-calendar-select";
			this._selectedMonth = picker.syraValue;
			var month = this._selectedMonth ? this._selectedMonth : this._dateValue.month;
			this._currentDate = this._dateValue = _dateApi.fromJsDate(new Date(this._dateValue.year, month - 1, this._dateValue.day));
			this.handler.onEvent("onCalendarUpdate", this);
		},
		bindEvents: function(bind) {
			var self = this;
			if (bind) {
				$(self.domItem).delegate("td", "click", function(evt) {
					self.onClick(evt);
					evt.preventDefault();
					evt.stopPropagation();
				});
			} else {
				$(self.domItem).undelegate();
			}
		},
		onClick: function(evt) {
			var self = this;
			while (evt.target) {
				if (evt.target.syraOnClick) {
					this[evt.target.syraOnClick](evt.target, evt);
					return;
				} else {
					evt.target = evt.target.parentNode;
				}
			}
		},
		destroy: function() {
			this.bindEvents(false);
			this.domItem = this._dateValue = this.selectedCell = null;
		}
	});

exports.MonthChoice = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/yearChoice',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/types/date'],function (require, exports, module) {
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var _dateApi = require('syracuse-tablet/html/js/helpers/types/date');


var _Klass = utils.defineClass(

	function() {

	}, null, {
		create: function(parentSlot, dateValue, handler) {
			this.parent = parentSlot;
			this.domItem = document.createElement("nav");
			this.domItem.className = "s-calendar-quick-list";
			this.handler = handler;
			this._dateValue = dateValue;
			this._selectedYear = this._dateValue.year;
			var table = document.createElement("table");
			table.className = "s-calendar-year-choice";
			var tbody = document.createElement("tbody");
			this.rows = [];
			for (var ii = 0; ii < 6; ii++) {
				var row = document.createElement("tr");
				if (ii == 0) {
					this.addPrevNextCell(row, true);
					this.addPrevNextCell(row, false);
				} else {
					var cuYear = this._dateValue.year + ii - 4;
					row.appendChild(this.drawCell(cuYear, cuYear));
					row.appendChild(this.drawCell(cuYear + 5, cuYear + 5));
				}
				tbody.appendChild(row);
				this.rows.push(row);
			}
			table.appendChild(tbody);
			this.domItem.appendChild(table);
			this.parent.appendChild(this.domItem);
			this.bindEvents(true);
		},
		addPrevNextCell: function(row, isPrev) {
			var td = document.createElement("td");
			td.className = "s-calendar-my-link-cell";
			var link = document.createElement("a");
			link.className = (link.syraIsPrev = isPrev) ? "s-calendar-prev-year" : "s-calendar-next-year";
			link.textContent = (link.syraIsPrev = isPrev) ? locale.text("date.month.label.prev") : locale.text("date.month.label.next");
			link.syraOnClick = "onChangeYear";
			td.appendChild(link);
			row.appendChild(td);
		},
		drawCell: function(value, text) {
			var td = document.createElement("td");
			td.className = "s-calendar-my-item";
			td.syraOnClick = "onSelectYear";
			td.syraValue = value;
			td.textContent = text;
			if (value == this._selectedYear) {
				td.className += " s-calendar-select";
				this.selectedCell = td;
			}
			return td;
		},
		toggle: function(show) {
			if (show) {
				this.domItem.style.display = "";
			} else {
				this.domItem.style.display = "none";
			}
		},
		_refreshYearCell: function(td, step) {
			td.syraValue += step;
			td.textContent = td.syraValue;
			if (td.syraValue == this._selectedYear) {
				td.className += " s-calendar-select";
				this.selectedCell = td;
			}
		},
		onChangeYear: function(picker) {
			var step = picker.syraIsPrev ? (-10) : 10;
			for (var ii = 1, jj = this.rows.length; ii < jj; ii++) {
				var nodes = this.rows[ii].childNodes;
				this._refreshYearCell(nodes[0], step);
				this._refreshYearCell(nodes[1], step);
			}
		},
		onSelectYear: function(picker) {
			if (this.selectedCell) {
				this.selectedCell.className = "s-calendar-my-item";
			}(this.selectedCell = picker).className = "s-calendar-my-item s-calendar-select";
			this._selectedYear = picker.syraValue;
			var year = this._selectedYear ? this._selectedYear : this._dateValue.year;
			this._currentDate = this._dateValue = _dateApi.fromJsDate(new Date(year, this._dateValue.month, this._dateValue.day));
			this.handler.onEvent("onCalendarUpdate", this);
		},
		bindEvents: function(bind) {
			var self = this;
			if (bind) {
				$(self.domItem).delegate("td", "click", function(evt) {
					self.onClick(evt);
					evt.preventDefault();
					evt.stopPropagation();
				});
			} else {
				$(self.domItem).undelegate();
			}
		},
		onClick: function(evt) {
			var self = this;
			while (evt.target) {
				if (evt.target.syraOnClick) {
					this[evt.target.syraOnClick](evt.target, evt);
					return;
				} else {
					evt.target = evt.target.parentNode;
				}
			}
		},
		destroy: function() {
			this.bindEvents(false);
			//this.parent.removeChild(this.domItem);
			this.rows = this.domItem = this._dateValue = this.selectedCell = null;
		}
	});

exports.YearChoice = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/types/date','syracuse-tablet/html/js/ui/datetimeSelectors/monthChoice','syracuse-tablet/html/js/ui/datetimeSelectors/yearChoice'],function (require, exports, module) {
var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var _dateApi = require('syracuse-tablet/html/js/helpers/types/date');
var MonthChoice = require('syracuse-tablet/html/js/ui/datetimeSelectors/monthChoice').MonthChoice;
var YearChoice = require('syracuse-tablet/html/js/ui/datetimeSelectors/yearChoice').YearChoice;

var _Klass = utils.defineClass(

	function() {

	}, null, {
		onClick: function(evt) {
			var self = this,
				close;
			while (evt.target && evt.target != self.handler.parentSlot) {
				if (evt.target.getAttribute("data-s-syraOnClick")) {
					close = this[evt.target.getAttribute("data-s-syraOnClick")](evt.target, evt);
					if (close) {
						this.handler.closeContainer();
					}
					return;
				} else {
					evt.target = evt.target.parentNode;
				}
			}
		},
		onTodayClick: function() {
			this._currentDate = _dateApi.today();
			this.field.setFieldValueFromSelector(_dateApi.fromInternalValue(this._currentDate._value).toString());
			return true;
		},
		onDayClick: function(picker) {
			this.field.setFieldValueFromSelector(_dateApi.fromInternalValue(picker.getAttribute("data-s-syraValue")).toString());
			return true;
		},
		onChangePeriode: function(picker) {
			if (picker.getAttribute("data-s-syraPeriod") == "month") {
				this._currentDate = this._currentDate.addMonths(picker.getAttribute("data-s-syraIsPrev") ? -1 : 1);
			} else if (picker.getAttribute("data-s-syraPeriod") == "year") {
				this._currentDate = this._currentDate.addYears(picker.getAttribute("data-s-syraIsPrev") ? -1 : 1);
			} else {
				this._currentDate = this._currentDate.addDays(picker.getAttribute("data-s-syraIsPrev") ? -7 : 7);
			}
			this.handler.onEvent("onCalendarUpdate", this);
		},
		onMonthClick: function() {
			this.handler.onEvent("onMonthClick", this);
		},
		onYearClick: function() {
			this.handler.onEvent("onYearClick", this);
		},
		getValueForSelector: function(field) {
			return field.getValue() && field.getValue().slice(0, 10);
		},
		create: function(field, handler) {
			this.domItem = document.createElement("div");
			this.domItem.className = "s-calendar";

			var value = this.getValueForSelector(field) || "";

			this._selectedDate = value ? _dateApi.parse(value) : _dateApi.today();
			this._selectedDate = this._selectedDate._value == 0 ? _dateApi.today() : this._selectedDate;
			this._currentDate = handler._currentDate || _dateApi.fromInternalValue(this._selectedDate._value);

			this.field = field;
			this.handler = handler;

			this._table = document.createElement("table");
			this._table.setAttribute("cellspacing", 0);
			this._table.className = "s-calendar-content";
			this._table.appendChild(this._appendHead());
			this._table.appendChild(this.body = document.createElement("tbody"));
			this._table.appendChild(this._appendFoot());
			this.domItem.appendChild(this._table);

			this._drawBody();

			return this.domItem;
		},
		_appendHead: function() {
			var head = document.createElement("thead");
			var row = document.createElement("tr");
			var cell = document.createElement("th");
			cell.setAttribute("colspan", 8);
			cell.className = "s-calendar-month-year";

			var slot = document.createElement("div");
			slot.className = "s-calendar-month-year-slot";
			cell.appendChild(slot);

			// prev year link
			var link = document.createElement("a");
			link.setAttribute("data-s-syraOnClick", "onChangePeriode");
			link.setAttribute("data-s-syraIsPrev", true);
			link.setAttribute("data-s-syraPeriod", "year");
			link.className = "s-calendar-prev s-calendar-prev-year glyphicon glyphicon-fast-backward";
			slot.appendChild(link);

			// prev month link
			link = document.createElement("a");
			link.setAttribute("data-s-syraOnClick", "onChangePeriode");
			link.setAttribute("data-s-syraIsPrev", true);
			link.setAttribute("data-s-syraPeriod", "month");
			link.className = "s-calendar-prev s-calendar-prev-month glyphicon glyphicon-step-backward";
			slot.appendChild(link);

			this._monthLink = document.createElement("a");
			this._monthLink.className = "s-month s-calendar-month-year-link";
			slot.appendChild(this._monthLink).setAttribute("data-s-syraOnClick", "onMonthClick");

			this._yearLink = document.createElement("a");
			this._yearLink.className = "s-year s-calendar-month-year-link";
			slot.appendChild(this._yearLink).setAttribute("data-s-syraOnClick", "onYearClick");

			// next month link
			link = document.createElement("a");
			link.setAttribute("data-s-syraOnClick", "onChangePeriode");
			link.setAttribute("data-s-syraPeriod", "month");
			link.className = "s-calendar-next s-calendar-next-month glyphicon glyphicon-step-forward";
			slot.appendChild(link);

			// next year link
			link = document.createElement("a");
			link.setAttribute("data-s-syraOnClick", "onChangePeriode");
			link.setAttribute("data-s-syraPeriod", "year");
			link.className = "s-calendar-next s-calendar-next-year glyphicon glyphicon-fast-forward";
			slot.appendChild(link);

			row.appendChild(cell);
			head.appendChild(row);

			row = document.createElement("tr");
			var cell = document.createElement("th");
			cell.className = "s-calendar-week-day";
			row.appendChild(cell);

			var days = [1, 2, 3, 4, 5, 6, 0];
			for (var ii = 0, jj = days.length; ii < jj; ii++) {
				var cell = document.createElement("th");
				cell.className = "s-calendar-week-day";
				cell.title = _dateApi.dayName(days[ii]);
				cell.textContent = _dateApi.dayName(days[ii], true);
				row.appendChild(cell);
			}
			head.appendChild(row);
			return head;
		},
		_appendFoot: function() {
			var row = document.createElement("tr");
			var cell = document.createElement("td");
			cell.setAttribute("colspan", 3);
			cell.className = "s-calendar-foot-week";

			var link = document.createElement("a");
			link.setAttribute("data-s-syraOnClick", "onChangePeriode");
			link.setAttribute("data-s-syraPeriod", "week");
			link.className = "s-calendar-prev s-calendar-prev-week glyphicon glyphicon-chevron-left";
			link.setAttribute("data-s-syraIsPrev", true);
			cell.appendChild(link);

			var label = document.createElement("label");
			label.className = "s-calendar-foot-week-title";
			label.textContent = locale.text("date.label.week");
			cell.appendChild(label);

			this._weekNumber = document.createElement("label");
			this._weekNumber.className = "s-calendar-foot-week-title-num";
			cell.appendChild(this._weekNumber);

			link = document.createElement("a");
			link.setAttribute("data-s-syraOnClick", "onChangePeriode");
			link.setAttribute("data-s-syraPeriod", "week");
			link.className = "s-calendar-next s-calendar-next-week glyphicon glyphicon-chevron-right";
			cell.appendChild(link);
			row.appendChild(cell);

			cell = document.createElement("td");
			cell.setAttribute("colspan", 3);
			cell.className = "s-calendar-foot-today";
			link = document.createElement("a");
			link.className = "s-calendar-today-link";
			link.setAttribute("data-s-syraOnClick", "onTodayClick");

			link.textContent = locale.text("date.label.today");
			cell.appendChild(link);
			row.appendChild(cell);

			cell = document.createElement("td");
			cell.setAttribute("colspan", 2);

			row.appendChild(cell);

			var foot = document.createElement("tfoot");
			foot.appendChild(row);
			return foot;
		},
		_drawBody: function() {

			var curMonth = this._currentDate.month || 9;
			var month = _dateApi.monthName(curMonth);

			this._monthLink.textContent = month;
			this._yearLink.textContent = this._currentDate.year || 2014;

			uiUtils.empty(this.body);

			var curDate = _dateApi.fromInternalValue(this._currentDate._value);
			var begOfMonth = curDate = curDate.begOfMonth();
			curDate = curDate.begOfWeek(1);

			for (var weekRow = 0; weekRow < 6; weekRow++) {
				var row = document.createElement("tr");
				var weekDay = (weekRow == 0) ? begOfMonth : curDate;
				var cell = document.createElement("td");
				cell.className = "s-calendar-week-num";
				row.appendChild(cell);
				cell.textContent = weekDay.week;
				for (var day = 0; day < 7; day++) {
					var cell = document.createElement("td");
					cell.className = "s-calendar-day-link";
					cell.setAttribute("data-s-syraOnClick", "onDayClick");
					cell.setAttribute("data-s-syraValue", curDate._value);
					var link = document.createElement("a");
					link.textContent = curDate.day;
					if (curMonth != curDate.month) {
						cell.className += " s-calendar-other-month";
					}
					if (this._currentDate.equals(curDate)) {
						cell.className += " s-calendar-select";
						link.className = "s-calendar-select";
					}
					cell.appendChild(link);
					row.appendChild(cell);
					curDate = curDate.addDays(1);
				}
				this.body.appendChild(row);
			}
			this._weekNumber.textContent = this._currentDate.week;
		},
		bindEvents: function(bind) {
			var self = this;
			var parentSlot = self.handler.getParentSlot();
			if (bind) {
				$(parentSlot).delegate("td, a", "click", function(evt) {
					self.onClick(evt);
					evt.preventDefault();
					evt.stopPropagation();
				});
			} else {
				$(parentSlot).undelegate();

				// unbind monthchoice and yearchoice components if necessary
				if (self._month) {
					self._month.bindEvents(false);
				}
				if (self._year) {
					self._year.bindEvents(false);
				}
			}
		},
		destroy: function() {
			this.bindEvents(false);
			this._currentDate = this.field = this._currentDate = this.quickList = this._month = this._year = this._selectedDate = this._monthLink = this._yearLink = this._weekNumber = this._quick = this.body = this.domItem = null;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/timeSelector',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/types/time','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {
var utils = require('syracuse-tablet/html/js/helpers/utils');
var _timeApi = require('syracuse-tablet/html/js/helpers/types/time');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _Klass = utils.defineClass(

	function() {

	}, null, {
		onClick: function(evt) {
			var self = this,
				close;
			while (evt.target) {
				if (evt.target.getAttribute("data-s-syraOnClick")) {
					close = this[evt.target.getAttribute("data-s-syraOnClick")](evt.target, evt);
					if (close) {
						this.handler.closeContainer();
					}
					return;
				} else {
					evt.target = evt.target.parentNode;
				}
			}
		},
		setContainer: function($$modalElmt) {
			this.$$modalElmt = $$modalElmt;
		},
		create: function(field, handler, cb) {

			this.domItem = document.createElement("div");
			this.domItem.className = "s-time-choice";

			var options = options || {};
			this.columns = options.columns || 2;
			this.interval = options.interval || 60;

			this.field = field;
			this.handler = handler;
			this.cb = cb;

			this.curTime = _timeApi.now();

			var cellCount = (24 * 60) / this.interval;
			var rowCount = cellCount / this.columns;

			var table = document.createElement("table");
			table.className = "s-time-choice-table";
			table.setAttribute("cellspacing", "0");
			table.setAttribute("cellpadding", "0");

			var row, cell;
			var cellIndex = 0;
			var timeHour = _timeApi.parse("00:00:00");
			for (var rr = 0; rr < rowCount; rr++) {
				row = document.createElement("tr");
				for (var col = 0; col < this.columns; col++) {
					cell = document.createElement("td");
					cell.className = "s-time-choice-td";
					if (cellIndex < cellCount) {
						var link = document.createElement("a");
						link.className = "s-time-choice-a";
						link.setAttribute("data-s-syraOnClick", "onTimeClick");
						if (timeHour.hour == this.curTime.hour) {
							link.className += " s-time-select";
						}
						link.textContent = timeHour.toString(locale.getTimeFormat());
						cell.appendChild(link);
					}
					row.appendChild(cell);
					timeHour = timeHour.addMinutes(this.interval);
					cellIndex++;
				}
				table.appendChild(row);
			}
			this.domItem.appendChild(table);
			return this.domItem;
		},
		onTimeClick: function(picker) {
			var self = this;
			var fieldVal = _timeApi.parse(picker.textContent, locale.getTimeFormat()).toString();
			if (!this.cb) {
				self.field.setFieldValueFromSelector(fieldVal);
				return true;
			} else {
				self.cb(fieldVal, self.handler);
			}
		},
		bindEvents: function(bind) {
			var self = this;
			var parentSlot = self.handler.getParentSlot();
			if (bind) {
				$(parentSlot).delegate("a", "click", function(evt) {
					self.onClick(evt);
					evt.preventDefault();
					evt.stopPropagation();
				});
			} else {
				$(parentSlot).undelegate();
			}
		},
		destroy: function() {
			this.bindEvents(false);
			this.domItem = this.field = this.selectedLink = null;
		}
	});
exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/selectorSwitchHandler',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/datetimeSelectors/monthChoice','syracuse-tablet/html/js/ui/datetimeSelectors/yearChoice','syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector','syracuse-tablet/html/js/ui/datetimeSelectors/timeSelector'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require("syracuse-tablet/html/js/ui/uiUtils");
var MonthChoice = require('syracuse-tablet/html/js/ui/datetimeSelectors/monthChoice').MonthChoice;
var YearChoice = require('syracuse-tablet/html/js/ui/datetimeSelectors/yearChoice').YearChoice;
var DateSelector = require('syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector').Klass;
var TimeSelector = require('syracuse-tablet/html/js/ui/datetimeSelectors/timeSelector').Klass;

var _Klass = utils.defineClass(

	function(field) {
		this.field = field;
	}, null, {
		/**
		Triggers an action when the following events occurs :
		- onMonthClick : When user clicks on month selection link
		- onYearClick : When user clicks on year selection link
		- onOpenTime : In case of datetime field, when user has selected the date, time selector must be displayed afterwards
		- onCalendarUpdate : When user clicks on links that will reshape the calendar (change month, change year, change week, select month, select year)
		- onSelectTime : In case of datetime field, when user has selected the time, field must be set with appropriate date + time value

		@param	evt 		Triggered event in set as string
		@param	selector 	The selector object. Use to get value and for destroy action
		*/
		onEvent: function(evt, selector) {
			this[evt](selector);
		},

		/*
			Set the $$container of the date / time selectors which is likely to be the modal.
			It will make it easier to close it from within the library
			@param	$$container 	Jquery container object (the modal)
		*/
		setContainer: function($$container) {
			this.$$container = $$container;
		},

		/*
			Set parentSlot dom parameter. Useful to make some dom actions like emptying or appending.
			It is the modal body
			@param parentSlot Modal body.

		*/
		setParentSlot: function(parentSlot) {
			this.parentSlot = parentSlot;
		},


		/*
			Returns parentSlot dom parameter
		*/
		getParentSlot: function() {
			return this.parentSlot;
		},

		/*
			Triggered when user clicks on month selection link. It builds the month selector
			@param 	selector 	The selector object. Use to get value and for destroy action
		*/
		onMonthClick: function(selector) {
			var self = this;
			// save date
			var date = selector._currentDate;

			// clear previous selector
			uiUtils.empty(self.parentSlot);
			selector.destroy();

			// create month selector
			var monthChoice = new MonthChoice();
			monthChoice.create(this.parentSlot, date, self);
		},

		/*
			Triggered when user clicks on year selection link. It builds the year selector
			@param 	selector 	The selector object. Use to get value and for destroy action
		*/
		onYearClick: function(selector) {
			var self = this;
			// save date
			var date = selector._currentDate;

			// clear previous selector
			uiUtils.empty(self.parentSlot);
			selector.destroy();

			// create month selector
			var yearChoice = new YearChoice();
			yearChoice.create(self.parentSlot, date, self);
		},


		/*
			Triggered in case of datetime field. It builds time selector after user clicked on date
			@param 	selector 	The selector object. Use to get value and for destroy action
		*/
		onOpenTime: function(selector) {
			var self = this;

			// save date
			self.dateValue = selector.dateValue;

			// clear previous selector
			uiUtils.empty(self.parentSlot);
			selector.destroy();

			// create time selector
			var timeSelector = new TimeSelector();
			var sDom = timeSelector.create(self.field, self, self.onSelectTime);
			self.parentSlot.appendChild(sDom);
			timeSelector.bindEvents(true);
		},

		/*
			Triggered when user clicks on link that will update the calendar. It builds the calendar with updated value
			@param 	selector 	The selector object. Use to get value and for destroy action
		*/
		onCalendarUpdate: function(selector) {
			var self = this;

			// save date
			self._currentDate = selector._currentDate;

			// clear previous selector
			uiUtils.empty(self.parentSlot);
			selector.destroy();

			// create back date selector
			var dateSelector = new DateSelector();
			var sDom = dateSelector.create(self.field, self);
			self.parentSlot.appendChild(sDom);
			dateSelector.bindEvents(true);
		},

		/*
			Triggered in case of datetime field. It sets the final field value and closes the container (the modal)
			@param 	selector 	The selector object. Use to get value and for destroy action
		*/
		onSelectTime: function(timeVal, handler) {
			var self = handler;
			self.field.setFieldValueFromSelector(self.dateValue + " " + timeVal);
			self.closeContainer();
		},

		/*
			Closes the container (the modal here)
		*/
		closeContainer: function() {
			this.$$container.modal("hide");
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/datetimeSelector',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/types/date','syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector'],function (require, exports, module) {
var utils = require('syracuse-tablet/html/js/helpers/utils');
var _dateApi = require('syracuse-tablet/html/js/helpers/types/date');
var Base = require('syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector').Klass;

var _Klass = utils.defineClass(

	function() {

	}, Base, {
		onTodayClick: function() {
			this._currentDate = _dateApi.today();
			this.dateValue = _dateApi.fromInternalValue(this._currentDate._value).toString();
			this.handler.onEvent("onOpenTime", this);
		},
		onDayClick: function(picker) {
			this.dateValue = _dateApi.fromInternalValue(picker.getAttribute("data-s-syraValue")).toString();
			this.handler.onEvent("onOpenTime", this);
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/selectorFactory',['require','exports','module','syracuse-tablet/html/js/ui/uiSettings','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector','syracuse-tablet/html/js/ui/datetimeSelectors/selectorSwitchHandler','syracuse-tablet/html/js/ui/datetimeSelectors/datetimeSelector','syracuse-tablet/html/js/ui/datetimeSelectors/selectorSwitchHandler','syracuse-tablet/html/js/ui/datetimeSelectors/timeSelector','syracuse-tablet/html/js/ui/datetimeSelectors/selectorSwitchHandler'],function (require, exports, module) {

var uiSettings = require('syracuse-tablet/html/js/ui/uiSettings');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');

var _selectors = {
	date: {
		"windows": null,
		"android": null,
		"ios": null,
		"default": require('syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector').Klass,
		"handler": require('syracuse-tablet/html/js/ui/datetimeSelectors/selectorSwitchHandler').Klass
	},
	datetime: {
		"windows": null,
		"android": null,
		"ios": null,
		"default": require('syracuse-tablet/html/js/ui/datetimeSelectors/datetimeSelector').Klass,
		"handler": require('syracuse-tablet/html/js/ui/datetimeSelectors/selectorSwitchHandler').Klass
	},
	time: {
		"windows": null,
		"android": null,
		"ios": null,
		"default": require('syracuse-tablet/html/js/ui/datetimeSelectors/timeSelector').Klass,
		"handler": require('syracuse-tablet/html/js/ui/datetimeSelectors/selectorSwitchHandler').Klass
	}
};
var getType = function(propertyType) {
	var type;
	switch (propertyType) {
		case "application/x-date":
			type = "date";
			break;
		case "application/x-datetime":
			type = "datetime";
			break;
		case "application/x-time":
			type = "time";
			break;
		default:
			type = null;
	}
	return type;
};
/*
	Returns appropriate selector controller according to field type
	@param	propertyType 	Field property type application/x-{date,time,datetime}
*/
var getSelector = function(propertyType) {
	var type = getType(propertyType);
	if (type === null)
		throw new Error("Expected date/time/datetime type. Got " + propertyType);
	var laf = uiSettings.getLookAndFeel();
	var selector = _selectors[type]; // select for type
	if (selector) {
		selector = selector[laf] || selector["default"]; // select per OS or use default
	}

	if (!selector) {
		throw new Error("Expected type. Got " + propertyType);
	}
	return new selector();
};

var getHandler = function(field) {
	var type = getType(field.$type);
	if (type === null)
		throw new Error("Expected date/time/datetime type. Got " + field.$type);
	var selector = _selectors[type]; // handler for type
	if (selector) {
		var handler = selector["handler"];
	}

	if (!handler) {
		return null;
	}
	return new handler(field);
};

/*
	Creates selector widget
	@param	field 	Field controller
*/
var _createSelector = function(field) {
	if (!field || !field.setFieldValueFromSelector) {
		throw new Error("_createSelector - Field must implement setFieldValueFromSelector");
	}
	// selector handler

	var sHandler = getHandler(field);

	// selector controller (date/time/datetime according to type)
	var ctrlSelector = getSelector(field.$type);

	// selector dom
	var selectorDom = ctrlSelector.create(field, sHandler);

	var $$selectorModal = modal.field(field.getTitle(), selectorDom.outerHTML, function(modalEvent, $$modalElmt) {
		// build content on open
		if (modalEvent == 'shown.bs.modal') {
			if (sHandler) {
				sHandler.setContainer($$modalElmt);
				sHandler.setParentSlot($$modalElmt.find(".modal-body")[0]);
			}
			ctrlSelector.bindEvents(true);

		}
		// run actions on close 'hidden.bs.modal'
		else {
			ctrlSelector.destroy();
		}
	});

};

exports.createSelector = _createSelector;
});

define('syracuse-tablet/html/js/controls/fields/ctrlDate',['require','exports','module','syracuse-tablet/html/js/controls/fields/ctrlFieldBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/ui/datetimeSelectors/selectorFactory'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/fields/ctrlFieldBase').CtrlFieldBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var selectorFactory = require('syracuse-tablet/html/js/ui/datetimeSelectors/selectorFactory');

exports.CtrlDate = utils.defineClass(
	function CtrlDate(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		Base.call(this, controller, article, prototype, options);
	}, Base, {

		buildFieldValue: function() {
			this._ensure$$value();
			this._clear$$value();
			//this.$$value.addClass("s-m-date");
			var value = this.getFormattedValue(this.getValue());
			if (this.$isEditMode) {
				this.addPicker("date", fontUtils.getIconByName(this.$type === "application/x-date" ? "datePicker" : "timePicker"));
				this.createMainInput(value);
			} else {
				this.appendTextValue(value);
			}
		},
		_actDatePicker: function() {
			selectorFactory.createSelector(this);
		},
	});
});

define('syracuse-tablet/html/js/sdata/dataset',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/common/helpers'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var helpers = require('syracuse-tablet/html/js/common/helpers');

// Keys on meta data of links and actions that will be checked for changes to notify the controller
var _linksAndActionsMetaKeys = ["$isHidden", "$isDisabled"];

var _checkQueryFullPage = function(prototype, $linkName) {
	if ($linkName !== "$queryfullpage") {
		return null;
	}
	// Query facet in full page
	if (!prototype.root || !prototype.root.isFacet("$query")) {
		throw new Error("$query facte expected for $queryfullpage link");
	}
	return {
		"$title": "$queryfullpage",
		"$target": "",
		"$type": "application/json;vnd.sage=syracuse",
		"$method": "GET",
		"$url": prototype.root.data("$url")
	}
}

/**
 * General dataset class, used for root level of objects right now
 */
var Dataset = utils.defineClass(
	function Dataset(json, prototype, parent, $bind) {
		this.json = json;
		this.prototype = prototype;
		this.parent = parent;
		this.$bind = $bind; // Name of property in parent if this dataset is a child dataset (e.g. array)
		this.root = (parent && parent.root) || this;

		this.dirtyProperties = [];
		this.childDatasets = {};
		this.deltaChangeListeners = [];
	},
	null, {
		destroy: function() {
			if (this.parent && this.parent.childDatasets) {
				delete this.parent.childDatasets[this.$bind];
			}
			this.root = null;
			this.parent = null;
			this.prototype = null;
			this.json = null;
			this.dirtyProperties = null;
			this.deltaChangeListeners = null;

			if (this.childDatasets) {
				var $binds = Object.keys(this.childDatasets);
				for (var i = 0; i < $binds.length; i++) {
					var $bind = $binds[i];
					if (this.childDatasets[$bind]) {
						this.childDatasets[$bind].destroy();
					}
				}
				this.childDatasets = null;
			}
			this.destroyed = true;
		},
		/**
		 * Get value of property $bind
		 * 
		 * useWorkingCopy: Set to true if working copy mode is used or false if stateless is used
		 *                 This will only affect the kind of urls returned for imags and texts
		 * 
		 * Note: 
		 * For reference fields, the returned value is
		 * null or 
		 * {
		 *   $value: ... // value of "key" property of referenced entity e.g. EUR for x-ref on currency
		 *   $title: ... // optional if set by server
		 *   $description: ... // optional if set by server
		 * }
		 */
		getValue: function($bind, useWorkingCopy) {
			if ($bind.charAt(0) === "$" && !this.prototype.propExists($bind)) {
				// $-properties like $url etc
				return this.json[$bind];
			} else if (this.prototype.propIsSimple($bind)) {
				return this.json[$bind];
			} else if (this.prototype.propIsReference($bind)) {
				return this._getValueReference($bind);
			} else if (this.prototype.propIsImage($bind)) {
				return this._getValueImage($bind, useWorkingCopy);
			} else if (this.prototype.propIsText($bind)) {
				return this._getValueText($bind, useWorkingCopy);
			} else if (this.prototype.propIsDocument($bind) || this.prototype.propIsBinary($bind)) {
				return this._getValueDocument($bind, useWorkingCopy);
			} else if (this.prototype.propIsArray($bind)) {
				throw new Error("Use getChild to access arrays");
			}
		},
		/**
		 * Set value of property $bind
		 * 
		 */
		setValue: function($bind, value) {
			if (this.prototype.propIsSimple($bind)) {
				var oldValue = this.json[$bind];
				if (oldValue !== value) {
					this.json[$bind] = value;
					this.setDirty($bind);
				}
			} else if (this.prototype.propIsImage($bind)) {
				var oldValue = this.json[$bind];
				this.json[$bind] = value;
				this.setDirty($bind);
			} else if (this.prototype.propIsText($bind)) {
				var oldValue = (typeof this.json[$bind] !== "string") ? value : this.json[$bind];
				this.json[$bind] = value;
				if (oldValue !== value) {
					this.json[$bind] = value;
					this.setDirty($bind);
				}
			} else if (this.prototype.propIsReference($bind)) {
				this._setValueReference($bind, value);
			} else if (this.prototype.propIsArray($bind)) {
				throw new Error("Use getChild to access arrays");
			}
		},
		/*
		 * Get value of reference field, used by getValue
		 * Can be either
		 * null if value of referenced field is null
		 * or
		 * {
		 *   $value: xxx value of reference field
		 *   $title: ...
		 *   $description: ...
		 * }
		 */
		_getValueReference: function($bind) {
			var value = this.json[$bind];
			var $refValueName = this.prototype.propGetRefValueName($bind);
			var $value = this.json[$refValueName];
			if ($value == null) {
				return null;
			}
			value = value || {};
			value.$value = $value;
			return value;
		},
		_getValueImage: function($bind, useWorkingCopy) {
			if (this.json[$bind]) {
				var prop = "$url";
				// Currently, useWorkingCopy is always != true for images
				// this is wrong since we should use the WC url
				if (useWorkingCopy !== true && this.prototype.root.isWorkingCopyFacet()) {
					prop = "$urlStateless"
				}
				var fieldProto = this.prototype.propGetProto($bind);
				var imageUrl = (fieldProto.getValueByPath(prop) || "");
				return this.resolveExpression(imageUrl, true) + '?salt=' + ((new Date()).getTime());
			} else {
				return null
			}
		},
		_getValueText: function($bind, useWorkingCopy) {
			var prop = "$url";
			if (useWorkingCopy !== true && this.prototype.root.isWorkingCopyFacet()) {
				prop = "$urlStateless"
			}
			var fieldProto = this.prototype.propGetProto($bind);
			var textUrl = (fieldProto.getValueByPath(prop) || "");
			return this.resolveExpression(textUrl, true);
		},
		_getValueDocument: function($bind, useWorkingCopy) {
			if (this.json[$bind] == null) { // no value means no data
				return null;
			}
			var prop = "$url";
			if (useWorkingCopy !== true && this.prototype.root.isWorkingCopyFacet()) {
				prop = "$urlStateless"
			}
			var fieldProto = this.prototype.propGetProto($bind);
			var textUrl = (fieldProto.getValueByPath(prop) || "");
			return this.resolveExpression(textUrl, true);
		},
		/*
		 * Set value of reference field
		 * Currently, value must be a simple type containing the key of the referenced entity
		 */
		_setValueReference: function($bind, value) {
			var $refValueName = this.prototype.propGetRefValueName($bind);
			var oldValue = this.json[$refValueName];
			if (oldValue !== value) {
				this.json[$bind] = {}; // WCUR_REF: x-reference
				this.json[$refValueName] = value; // WCUR: x-string

				this.setDirty($bind);
				this.setDirty($refValueName);
			}
		},
		/**
		 * 
		 * Return child dataset for property $bind
		 * $bind must be an array property
		 */
		getChild: function($bind) {
			var child = this.childDatasets[$bind];
			if (!child) {
				if (this.prototype.propIsArray($bind)) {
					var data = this.json[$bind];
					if (!data) {
						data = this.json[$bind] = [];
					}
					if (!this.prototype.propIsSingleArray($bind)) {
						// Normal multi column array
						var proto = this.prototype.propGetProto($bind);
						child = new MultiArrayDataset(data, proto, this, $bind);
					} else {
						// Single column array
						var proto = this.prototype.propGetProto($bind);
						child = new SingleArrayDataset(data, proto, this, $bind);
					}
					this.childDatasets[$bind] = child;
				}
			}
			return child;
		},
		/**
		 * Set a named property ($bind) to dirty
		 * $bind can be the $uuid of a row of an array too
		 * 
		 * setDirty will report the dirty flag to the parent, so if a child is dirty asking root.isDirty will return true
		 */
		setDirty: function($bind) {
			if (this.dirtyProperties && this.dirtyProperties.indexOf($bind) < 0) {
				this.dirtyProperties.push($bind);
			}
			if (this.parent) {
				this.parent.setDirty(this.$bind);
			}
		},
		/**
		 * Check if dataset is dirty
		 * $bind (optional): If $bind is given, only check if property $bind is dirty
		 */
		isDirty: function($bind) {
			if ($bind != null) {
				return (this.dirtyProperties && this.dirtyProperties.length > 0 && this.dirtyProperties.indexOf($bind) > -1) || false;
			}
			return (this.dirtyProperties && this.dirtyProperties.length > 0) || false;
		},
		/**
		 * Mark dataset as clean (remove all dirty flags)
		 * $bind (optional): If $bind is given, only clean this property
		 * 
		 * includeChildren (optional): If false, to not include children, should only be used internally to avoid infinite child<->parent calls
		 */
		setClean: function($bind, includeChildren) {
			includeChildren = includeChildren == null ? true : false;
			if ($bind != null) {
				var idx = this.dirtyProperties.indexOf($bind);
				if (idx >= 0) {
					this.dirtyProperties.splice(idx, 1);
					if (includeChildren && this.childDatasets[$bind]) {
						this.childDatasets[$bind].setClean();
					}
				}
				// For reference fields, clean related field dirty flag too
				// We check if prop exists first since it's not always the case
				// E.g. a row dataset has a $bind uuid which is not contained in it's prototype
				if (this.prototype.propExists($bind) && this.prototype.propIsReference($bind)) {
					this.setClean(this.prototype.propGetRefValueName($bind));
				}
			} else {
				this.dirtyProperties = [];
				if (includeChildren) {
					for (var childName in this.childDatasets) {
						var child = this.childDatasets[childName];
						child.setClean();
					}
				}
			}
			// Check if all is clean, report to parent if yes
			if (this.parent && this.dirtyProperties.length < 1) {
				this.parent.setClean(this.$bind, false);
			}
		},
		/**
		 * 
		 * @param $bind
		 * @returns
		 */
		getDiagnoses: function($bind) {
			var diags = this.getValueByPath("$properties." + $bind + ".$diagnoses");

			if (this.prototype.propExists($bind) && this.prototype.propIsReference($bind)) {
				var $bindValue = this.prototype.propGetRefValueName($bind);
				var valueFieldDiags = this.getValueByPath("$properties." + $bindValue + ".$diagnoses");
				diags = diags || [];
				Array.prototype.push.apply(diags, valueFieldDiags);
			}
			return diags || [];
		},
		/**
		 * Gets the current JSON data represented by this dataset
		 * Used for stateless mode
		 */
		getData: function() {
			/*
			 * return this.json;
			 * will not work because the internal data structures change for simple property arrays (wrapped with object on read)
			 */
			var data = {};
			var props = Object.keys(this.json);
			for (var i = 0; i < props.length; i++) {
				var $bind = props[i];
				var childDataset = this.childDatasets[$bind];
				if (childDataset) {
					// If there is a child dataset for the property, let it handle to create the data
					data[$bind] = childDataset.getData();
				} else if (this.prototype.propIsSingleArray($bind)) {
					childDataset = this.getChild($bind);
					data[$bind] = childDataset.getData();
				} else {
					data[$bind] = this.json[$bind];
				}
			}
			return data;
		},
		/**
		 * Gets all the JSON data including only properties that are dirty, including children
		 * Used for working copy mode
		 */
		getDataDelta: function() {
			var delta = {
				$uuid: this.json.$uuid,
			};

			if (this.isRoot()) {
				delta.$url = this.getUrl();
				delta.$etag = this.json.$etag;
			}

			var i;
			for (i = 0; i < this.dirtyProperties.length; i++) {
				var $bind = this.dirtyProperties[i];
				if (this.childDatasets[$bind]) { //  Array or something complex?
					delta[$bind] = this.childDatasets[$bind].getDataDelta();
				} else {
					delta[$bind] = this.json[$bind];
				}
			}

			return delta;
		},
		/*Get data for text content upload :  protocol is not like other datas
		 */
		getDataText: function($bind) {
			var delta;
			var i;
			for (i = 0; i < this.dirtyProperties.length; i++) {
				var $bindDirty = this.dirtyProperties[i];
				if ($bindDirty === $bind) {
					delta = this.json[$bind]
				}
			}

			return delta;
		},
		/**
		 * Resolve expressionen on dataset and datasets prototype
		 * isUrl: Is the repression an url? If yes, expressions like abc={xxx} will be abc=<uri encode xxx>
		 * extraData: Key + value to check for matches first (E.g. $parameters when resolving link urls) 
		 */
		resolveExpression: function(exp, isUrl, extraData) {
			var self = this;
			var rescan = true;
			var max = 20;
			if (exp == null) {
				return exp;
			}
			while (rescan && ((max--) > 0) && exp.replace) {
				rescan = false;
				exp = exp.replace(/\{(\S+?)\}/g, function(m, g1, idx) {
					var value;
					// Encode if we resolve an url that contains something like EXTRA_CODE={EXTRA_CODE} ?
					var encode = isUrl && idx > 0 && exp.charAt(idx - 1) === "=";
					if (extraData && g1 in extraData) {
						value = extraData[g1];
						if (value && value.indexOf && value.indexOf("{") === 0) {
							rescan = true;
						} else if (encode) {
							value = encodeURIComponent(value);
						}
					} else if (g1 in self.json) {
						value = self.json[g1];
						if (value && value.indexOf && value.indexOf("{") === 0) {
							rescan = true;
						} else if (encode) {
							value = encodeURIComponent(value);
						}
					} else if (self.root != self && g1 in self.root.json) {
						value = self.root.json[g1];
						if (value && value.indexOf && value.indexOf("{") === 0) {
							rescan = true;
						} else if (encode) {
							value = encodeURIComponent(value);
						}
					} else {
						value = self.prototype.resolveExpression(m);
						rescan = rescan || (value != m && value && value.indexOf && value.indexOf("{") >= 0);
					}
					return value;
				});
			}
			return exp;
		},
		/**
		 * Computes Url of current resource by using $url of payload
		 * 
		 * useProtoype$Url: When NOT true, use $url of dataset or prototype for fallback if not contained in dataset
		 * 					When true: Use $url of prototype (this is the stateless URL for the resource)
		 *
		 * return:
		 * dataset based url
		 * http://localhost:8124/sdata/x3/erp/GX3APP/$workingCopies('6958bd2f-6bb4-46e0-bed7-0c4cc2692e30')?representation=AQMCRUDM.$edit
		 * prototype based url
		 * http://localhost:8124/sdata/x3/erp/GX3APP/AQMDEVICE('8')?representation=AQMCRUDM.$edit
		 * param $bind need only for text content upload, put url come from $url or the property $bind
		 */
		getUrl: function(useProtoype$Url, $bind) {
			var url;
			if ($bind) {
				url = this.prototype.getFieldUpdateUrl($bind);
			}
			if (useProtoype$Url !== true) {
				return this.resolveExpression(url || this.json.$url || this.prototype.json.$url);
			} else {
				return this.resolveExpression(url || this.prototype.json.$url);
			}
		},
		getFacet: function() {
			if (this.isRoot()) {
				return this.prototype.getFacet();
			}
		},

		getAction: function($actionName) {
			var actionP = this.prototype.getValueByPath("$actions." + $actionName); // Must not be null in proto
			var actionD = this.getValueByPath("$actions." + $actionName) || {}; // Could be null in payload
			if (!actionP) {
				return;
			}
			var action = $.extend(true, {}, actionP, actionD);
			if (action.$isExcluded === true || helpers.isOfficeLink(action)) {
				return;
			}
			return action;
		},
		/**
		 * Removes excluded and office links
		 */
		getActions: function() {
			var actionsP = this.prototype.getValueByPath("$actions");
			if (!actionsP) {
				return;
			}
			var actions = {};
			var action;
			for (var actionName in actionsP) {
				action = this.getAction(actionName);
				if (action) {
					actions[actionName] = action;
				}
			}
			return actions;
		},
		getLink: function($linkName, $bind) {
			var link = _checkQueryFullPage(this.prototype, $linkName);
			if (link) {
				return link;
			}
			var path = $bind ? "$properties." + $bind + ".$item.$links." + $linkName : "$links." + $linkName;
			var linkP = this.prototype.getValueByPath(path);
			var linkD = this.getValueByPath(path);

			if (!linkP && !linkD) {
				return;
			}
			link = $.extend(true, {}, linkP, linkD);
			if (link.$url && /\{(\S+?)\}/.test(link.$url)) {
				link.$url = this.resolveExpression(link.$url)
			}
			if (link.$isExcluded === true || helpers.isOfficeLink(link)) {
				return;
			}
			return link;
		},
		/**
		 * Removes excluded and office links
		 */
		getLinks: function($bind) {
			var self = this;
			var path = $bind ? "$properties." + $bind + ".$item.$links" : "$links";
			var linksP = this.prototype.getValueByPath(path);
			var linksNames = [];
			if (linksP) {
				for (var linkName in linksP) {
					linksNames.push(linkName);
				}
			}
			var linksD = this.getValueByPath(path);
			if (linksD) {
				for (var linkName in linksD) {
					linksNames.push(linkName);
				}
			}
			var links = {};
			var link;
			linksNames.forEach(function(linkName) {
				link = self.getLink(linkName, $bind);
				if (link) {
					links[linkName] = link;
				}
			});
			return links;
		},
		/** 
		 * Is this a root dataset (e.g. page level)
		 */
		isRoot: function() {
			return this != null && this == this.root;
		},
		getRoot: function() {
			return this.root;
		},
		getMetaData: function($bind) {
			var protoMeta = this.prototype.getValueByPath("$properties." + $bind);
			var dataMeta = this.getValueByPath("$properties." + $bind);
			var meta = $.extend(true, {}, protoMeta, dataMeta);
			return meta;
		},
		/**
		 * Apply delta comming from server if we are in working copy mode
		 * 
		 */
		applyDelta: function(delta) {
			var i;
			/*
			 *  We collect all modified fields and fire events at the very end
			 *  since there are properties like CUR_REF and CUR that are linked to each other
			 *  so we need to update all of the first before firing the event
			 */

			var deltaNotifications = {};

			var properties = Object.keys(delta);
			for (var ii = 0, jj = properties.length; ii < jj; ii++) {
				var property = properties[ii];
				var value = delta[property];
				this._deltaSetValue(property, value, deltaNotifications);
			}

			for (var $bind in deltaNotifications) {
				var notify = deltaNotifications[$bind];
				if (notify.$value) {
					this._deltaManValueChanged($bind);
				}
				if (notify.$meta) {
					this._deltaManMetaChanged($bind);
				}
				if (notify.$action) {
					this._deltaManActionChanged($bind, notify.$action);
				}
				if (notify.$link) {
					this._deltaManLinkChanged($bind, notify.$link);
				}
			}
		},
		/*
		 * Invoked by applyDelta to apply delta of a single property
		 * 
		 */
		_deltaSetValue: function($bind, value, deltaNotifications) {
			var i = this.dirtyProperties.indexOf($bind);
			if (i >= 0) {
				this.dirtyProperties.splice(i, 1);
			}
			if ($bind === "$properties") {
				this._deltaSetProperties(value, deltaNotifications);
			} else if ($bind === "$actions") {
				this._deltaSetActions(value, deltaNotifications);
			} else if ($bind === "$links") {
				this._deltaSetLinks(value, deltaNotifications);
			} else if ($bind.charAt(0) === "$") {
				// TODO: Make this correct and recursive including notifications
				this.json[$bind] = value;
			} else {
				if (!this.prototype.propExists($bind)) {
					// Non $ properties that are sent by the server but are not present in the prototype
					// Example is ETag on X3 representations
					// We just add them to the json without taking too much care for now
					this.json[$bind] = value;
				} else if (this.prototype.propIsSimple($bind)) {
					var oldValue = this.json[$bind];
					this.json[$bind] = value;
					if (oldValue !== value) {
						if (this.prototype.propIsRefValue($bind)) {
							// Property used to backup a reference field
							var refField = this.prototype.propGetRefProperty($bind);
							var notify = deltaNotifications[refField] = deltaNotifications[refField] || {};
							notify.$value = true;
						} else {
							// Normal property
							deltaNotifications[$bind] = deltaNotifications[$bind] || {};
							deltaNotifications[$bind].$value = true;
						}
					}
				} else if (this.prototype.propIsReference($bind)) {
					var oldValue = this.json[$bind];
					this.json[$bind] = value;
					var notify = deltaNotifications[$bind] = deltaNotifications[$bind] || {};
					notify.$value = true;
				} else if (this.prototype.propIsArray($bind)) {
					var array = this.getChild($bind);
					array.applyDelta(value);
				}
			}
		},
		/*
		 * Traverse $properties
		 */
		_deltaSetProperties: function(value, deltaNotifications) {
			// For meta data changes, we just notify the keys beneath $properties to allow widgets to repaint
			var properties = Object.keys(value);
			for (var ii = 0, jj = properties.length; ii < jj; ii++) {
				var property = properties[ii];
				this.json.$properties = this.json.$properties || {};
				this.json.$properties[property] = value[property];


				if (this.prototype.propIsRefValue(property)) {
					// Property used to backup a reference field
					var refField = this.prototype.propGetRefProperty(property);
					var notify = deltaNotifications[refField] = deltaNotifications[refField] || {};
					notify.$meta = true;
				} else {
					deltaNotifications[property] = deltaNotifications[property] || {};
					deltaNotifications[property].$meta = true;
				}
			}
		},
		/*
		 * Check for changes in $actions block
		 */
		_deltaSetActions: function(value, deltaNotifications) {
			var self = this;
			var actions = Object.keys(value);
			for (var ii = 0, jj = actions.length; ii < jj; ii++) {
				var action = actions[ii];
				this.json.$actions = this.json.$actions || {};
				this.json.$actions[action] = this.json.$actions[action] || {};
				var keys = Object.keys(value[action]);

				var changed = false;
				if (keys.some(function(key) {
						if (_linksAndActionsMetaKeys.indexOf(key) > -1 && value[action][key] !== self.json.$actions[action][key]) {
							return true;
						}
					})) {
					changed = true;
				}
				this.json.$actions[action] = $.extend(true, this.json.$actions[action], value[action]);

				if (changed === true) {
					var status = {};
					var $isHidden = this.json.$actions[action].$isHidden;
					if ($isHidden == null) {
						$isHidden = this.prototype.getValueByPath("$actions." + action + ".$isHidden");
					}
					if ($isHidden != null) {
						status.$isHidden = $isHidden;
					}
					var $isDisabled = this.json.$actions[action].$isDisabled;
					if ($isDisabled == null) {
						$isDisabled = this.prototype.getValueByPath("$actions." + action + ".$isDisabled");
					}
					if ($isDisabled != null) {
						status.$isDisabled = $isDisabled;
					}

					deltaNotifications[action] = deltaNotifications[action] || {};
					deltaNotifications[action].$action = status;
				}
			}
		},
		/*
		 * Check for changes in $links block
		 * Currently, only $links on root level are checked
		 * Links on properties (e.g. $lookup) are handled by the property specific meta data change notification
		 */
		_deltaSetLinks: function(value, deltaNotifications) {
			var self = this;
			var links = Object.keys(value);
			for (var ii = 0, jj = links.length; ii < jj; ii++) {
				var link = links[ii];
				this.json.$links = this.json.$links || {};
				this.json.$links[link] = this.json.$links[link] || {};
				var keys = Object.keys(value[link]);

				var changed = false;
				if (keys.some(function(key) {
						if (_linksAndActionsMetaKeys.indexOf(key) > -1 && value[link][key] !== self.json.$links[link][key]) {
							return true;
						}
					})) {
					changed = true;
				}
				this.json.$links[link] = value[link];

				if (changed === true) {
					var status = {};
					var $isHidden = this.json.$links[link].$isHidden;
					if ($isHidden == null) {
						$isHidden = this.prototype.getValueByPath("$links." + link + ".$isHidden");
					}
					if ($isHidden != null) {
						status.$isHidden = $isHidden;
					}
					var $isDisabled = this.json.$links[link].$isDisabled;
					if ($isDisabled == null) {
						$isDisabled = this.prototype.getValueByPath("$links." + link + ".$isDisabled");
					}
					if ($isDisabled != null) {
						status.$isDisabled = $isDisabled;
					}

					deltaNotifications[link] = deltaNotifications[link] || {};
					deltaNotifications[link].$link = status;
				}
			}
		},
		/* 
		 * Invoked by _deltaSetValue when the server sent a modified value for a given property
		 */
		_deltaManValueChanged: function($bind) {
			for (var i = 0; i < this.deltaChangeListeners.length; i++) {
				this.deltaChangeListeners[i].onDeltaValueChanged(this, $bind);
			}
		},
		_deltaManMetaChanged: function($bind) {
			for (var i = 0; i < this.deltaChangeListeners.length; i++) {
				this.deltaChangeListeners[i].onDeltaMetaChanged(this, $bind);
			}
		},
		_deltaManLinkChanged: function($bind, metaData) {
			for (var i = 0; i < this.deltaChangeListeners.length; i++) {
				this.deltaChangeListeners[i].onDeltaLinkChanged(this, $bind, null, metaData);
			}
		},
		_deltaManActionChanged: function($bind, metaData) {
			for (var i = 0; i < this.deltaChangeListeners.length; i++) {
				this.deltaChangeListeners[i].onDeltaActionChanged(this, $bind, metaData);
			}
		},
		getValueByPath: function(path) {
			return helpers.getValueByPath(this.json, path);
		},
		addDeltaChangeListener: function(listener) {
			if (this.deltaChangeListeners.indexOf(listener) < 0) {
				this.deltaChangeListeners.push(listener);
			}
		},
		removeDeltaChangeListener: function(listener) {
			if (!this.deltaChangeListeners) {
				return;
			}
			var idx = this.deltaChangeListeners.indexOf(listener);
			if (idx >= 0) {
				this.deltaChangeListeners.splice(idx, 1);
			}
		},

		/**
		 * Compute last update time of this dataset
		 * 
		 * Return: 
		 * {
		 *   dateTime: milliseconds
		 *   level: "verytainted" | "tainted" | "fresh"
		 * }
		 * 
		 */
		getDataFreshness: function() {
			var freshness = {
				dateTime: new Date().getTime(),
				level: "verytainted"
			};

			function _check$ResourcesTime($resources) {
				if (!$resources) {
					return;
				}
				var utcTime = new Date().getTime();
				$resources.forEach(function(item) {
					if (item.$cache) {
						utcTime = Math.min(utils.getTimeFromString(item.$cache.$lastUpdated), utcTime);
					}
				});
				freshness.dateTime = utcTime;
			};

			if (this.isRoot()) {
				if (this.json.$cache) {
					freshness.dateTime = Math.min(freshness.dateTime, utils.getTimeFromString(this.json.$cache.$lastUpdated));
				} else {
					_check$ResourcesTime(this.json.$resources);
				}

				var diffDays = Math.round((new Date().getTime() - freshness.dateTime) / (24 * 60 * 60 * 1000));

				if (diffDays <= 7) freshness.level = "tainted";
				if (diffDays <= 1) freshness.level = "fresh";

				return freshness;
			} else {
				return this.root.getDataFreshness();
			}
		}
	}
);
exports.Dataset = Dataset;

/**
 * Base class for array dataset 
 * Never use directly. Use one of it's subclasses. 
 */
var ArrayDataset = utils.defineClass(
	function ArrayDataset(json, prototype, parent, $bind) {
		Dataset.call(this, json, prototype, parent, $bind);
		this.rowDatasetsByUuid = {};
	},
	Dataset, {

		destroy: function() {
			Dataset.prototype.destroy.call(this);
			if (this.rowDatasetsByUuid) {
				var $uuids = Object.keys(this.rowDatasetsByUuid);
				for (var i = 0; i < $uuids.length; i++) {
					this.removeDatasetByUuid($uuids[i]);
				}
			}
		},

		getChild: function($bind) {
			throw new Error("getChild not supported on ArrayDataset");
		},
		isValidIndex: function($index) {
			return ($index >= 0 && $index < this.getNumRows());
		},
		getNumRows: function() {
			return this.json ? this.json.length : 0;
		},
		/**
		 * Move row with $uuid to $index (0 to numRows-1)
		 * 
		 */
		moveRow: function($uuid, targetIndex) {
			var sourceIndex = this.getRowIndex($uuid);
			if (sourceIndex == null ||
				sourceIndex === targetIndex) {
				return;
			}
			if (!this.isValidIndex(sourceIndex) ||
				!this.isValidIndex(targetIndex)) {
				return;
			}
			var rowToMove = this.json[sourceIndex];
			if (Math.abs(targetIndex - sourceIndex) === 1) {
				this.json[sourceIndex] = this.json[targetIndex];
				this.json[targetIndex] = rowToMove;
			} else {
				this.json.splice(sourceIndex, 1);
				this.json.splice(targetIndex, 0, rowToMove);
			}
			this._setAllRowsDirty();
		},
		/**
		 * Return RowDataset representing the row identified by $index or null of $index is not valid
		 */
		getRowByIndex: function($index) {
			if (!this.isValidIndex($index)) {
				return null;
			}
			var $uuid = this.json[$index].$uuid;
			var row = this.rowDatasetsByUuid[$uuid];
			if (!row) {
				// Note that a row's $bind is the rows $uuid which allows to perfectly identify it later
				row = this.createRowDataset(this.json[$index], this.rowPrototype, $uuid, $index);
			}
			return row;
		},
		/**
		 * Return RowDataset representing the row identified by $uuid or null of $uuid is not valid
		 */
		getRowByUuid: function($uuid) {
			var row = this.rowDatasetsByUuid[$uuid];
			if (!row) {
				var index = this.getRowIndex($uuid);
				if (index != null) {
					row = this.createRowDataset(this.json[index], this.rowPrototype, $uuid, index);
				}
			}
			return row;
		},
		getRowIndex: function($uuid) {
			var self = this;
			var $index = null;
			self.json.some(function(rowData, index) {
				if (rowData.$uuid === $uuid) {
					$index = index;
					return true;
				}
				return false;
			});
			return $index;
		},
		createRowDataset: function(json, prototype, $uuid) {
			// Note that a row's $bind is the rows $uuid which allows to perfectly identify it later
			var row = new RowDataset(json, prototype, this, $uuid);
			this.rowDatasetsByUuid[$uuid] = row;
			return row;
		},
		removeRowDataset: function(dataset) {
			if (dataset && dataset.$bind) {
				this.removeDatasetByUuid(dataset.$bind);
			}
		},
		removeDatasetByUuid: function($uuid) {
			var dataset = this.rowDatasetsByUuid[$uuid];
			if (dataset) {
				dataset.destroy();
			}
			delete this.rowDatasetsByUuid[$uuid];
		},
		/**
		 * Called when a row has been added to an array
		 */
		_deltaManRowAdded: function($uuid, idx) {
			for (var i = 0; i < this.deltaChangeListeners.length; i++) {
				this.deltaChangeListeners[i].onDeltaRowAdded(this, this.$bind, $uuid, idx);
			}
		},
		/**
		 * Called when a row has been removed from an array
		 */
		_deltaManRowRemoved: function($uuid, idx) {
			for (var i = 0; i < this.deltaChangeListeners.length; i++) {
				this.deltaChangeListeners[i].onDeltaRowRemoved(this, this.$bind, $uuid, idx);
			}
		},
		/**
		 * Called when a row has moved to a new index
		 */
		_deltaManRowMoved: function($uuid, newIdx) {
			for (var i = 0; i < this.deltaChangeListeners.length; i++) {
				this.deltaChangeListeners[i].onDeltaRowMoved(this, this.$bind, $uuid, newIdx);
			}
		}
	}
);
exports.ArrayDataset = ArrayDataset;

/**
 * Array dataset wrapping complex arrays having multiple columns
 */
var MultiArrayDataset = utils.defineClass(
	function MultiArrayDataset(json, prototype, parent, $bind) {
		ArrayDataset.call(this, json, prototype, parent, $bind);
		this.rowPrototype = prototype.getProto$Item();
		// Set explicit type for ctrl row
		this.rowPrototype.json.$type = "tablet/x-array-row";
		this.rowsDeleted = {};
	},
	ArrayDataset, {
		destroy: function() {
			ArrayDataset.prototype.destroy.call(this);
			if (this.rowPrototype) {
				this.rowPrototype.destroy();
				this.rowPrototype = null;
			}
			this._destroyDeletedRow();
			this.rowsDeleted = null;
		},
		_destroyDeletedRow: function() {
			if (this.rowsDeleted) {
				for (var i = 0; i < this.rowsDeleted.length; i++) {
					this.rowsDeleted[i].destroy();
				}
				this.rowsDeleted = {};
			}
		},
		/**
		 * Add a new row to the array, returns newly created dataset
		 */
		addRow: function() {
			var $uuid = utils.UUID();
			var rowData = {
				$uuid: $uuid
			};
			this.json.push(rowData);
			this.setDirty($uuid);
			return this.getRowByUuid($uuid);
		},
		removeRow: function($uuid) {
			var idx = this.getRowIndex($uuid);
			if (idx != null) {
				this.json.splice(idx, 1);
			}
			var row = this.getRowByUuid($uuid);
			if (row) {
				this.setDirty($uuid);
				this.rowsDeleted[$uuid] = row;
			}
			this.removeDatasetByUuid($uuid);
			this._setAllRowsDirty();
		},
		get$ItemProto: function() {
			return this.rowPrototype;
		},
		getDataDelta: function() {
			var deltaRows = [];
			var i;
			var dirtyRows = this._getOrderedDirtyRows();

			// Could better follow https://github.com/Sage-ERP-X3/platform/wiki/JSON-Delta-Format#deltas-on-lists
			// Currently, delta only (using $index all time) is used no matter on the number of changes
			for (i = 0; i < dirtyRows.length; i++) {
				var $uuid = dirtyRows[i].$uuid;
				var row = this.getRowByUuid($uuid);
				var deltaRow;

				if (row) { // modified row
					deltaRow = row.getDataDelta();
					deltaRow.$index = dirtyRows[i].$index;
					deltaRows.push(deltaRow);
					continue;
				}

				// deleted row
				row = this.rowsDeleted[$uuid];
				if (row) {
					deltaRow = {
						"$uuid": $uuid,
						"$index": dirtyRows[i].$index,
						"$isDeleted": true
					};
					deltaRows.push(deltaRow);
					continue;
				}
			}
			return deltaRows;
		},
		getData: function() {
			return this.json;
		},
		applyDelta: function(delta) {
			this._destroyDeletedRow();
			if (!delta) {
				return;
			}
			// If there is a $index, only changed lines are included
			var changedLinesOnly = delta.length > 0 && delta[0].$index !== undefined;
			if (changedLinesOnly) {
				// All items contain a $index element giving their new position
				this._applyDeltaIndexed(delta);
			} else {
				this._applyDeltaFull(delta);
			}
		},
		_applyDeltaIndexed: function(delta) {
			var self = this;
			var oldUuids = this.json.map(function(row) {
				return row.$uuid;
			});

			// Manage delete, insert and change
			for (var ii = 0, jj = delta.length; ii < jj; ii++) {
				var deltaRow = delta[ii];
				var $uuid = deltaRow.$uuid;
				var $index = deltaRow.$index;
				if (deltaRow.$isDeleted === true) {
					this._deltaManRowRemoved(deltaRow.$uuid, deltaRow.$index);
					this.removeDatasetByUuid(deltaRow.$uuid);

					// Do not use $index since it may not be valid after some operations
					var idx = this.getRowIndex(deltaRow.$uuid);
					if (idx !== null) {
						this.json.splice(idx, 1);
					}
					continue;
				}
				var row = this.getRowByUuid($uuid);
				if (!row) { // new row
					this.json.splice($index, 0, deltaRow);
					this._deltaManRowAdded($uuid, $index);
				} else {
					row.applyDelta(deltaRow);
				}
			}

			// Check for moved rows
			for (var ii = 0, jj = this.json.length; ii < jj; ii++) {
				var maybeMoved = this.json[ii];
				var oldIdx = oldUuids.indexOf(maybeMoved.$uuid);
				if (oldIdx > -1 && oldIdx !== ii) {
					this._deltaManRowMoved(maybeMoved.$uuid, ii);
				}
			}
			this.dirtyProperties = [];
		},
		_applyDeltaFull: function(delta) {
			var self = this;
			var oldUuids = this.json.map(function(row) {
				return row.$uuid;
			});
			for (var ii = 0; ii < this.json.length; ii++) {
				var maybeDeletedRow = this.json[ii];
				if (!delta.some(function(row) {
						return row.$uuid === maybeDeletedRow.$uuid;
					})) {
					this._deltaManRowRemoved(maybeDeletedRow.$uuid, ii);
					this.removeDatasetByUuid(maybeDeletedRow.$uuid);
					this.json.splice(ii, 1);
					ii--;
				}
			}
			for (var ii = 0, jj = delta.length; ii < jj; ii++) {
				var deltaRow = delta[ii];
				var $uuid = deltaRow.$uuid;
				var row = this.getRowByUuid($uuid);
				if (!row) { // new row
					this.json.splice(ii, 0, deltaRow);
					this._deltaManRowAdded($uuid, ii);
				} else {
					var oldIdx = oldUuids.indexOf($uuid);
					if (oldIdx !== ii) {
						this._deltaManRowMoved($uuid, ii);
					}
					row.applyDelta(deltaRow);
				}
			}
		},
		_deltaSetValue: function($bind, value) {
			throw new Error("_deltaSetValue not supported on ArrayDataset");
		},
		/*
		 *  Order row $uuids according to their position in the data model instead of the order of change.
		 *  This important when sending the delta
		 */
		_getOrderedDirtyRows: function() {
			var rows = [];

			for (var $uuid in this.rowsDeleted) {
				rows.push({
					$uuid: $uuid,
					$index: 0
				});
			}

			for (var ii = 0, jj = this.json.length; ii < jj; ii++) {
				var $uuid = this.json[ii].$uuid;
				if (this.dirtyProperties.indexOf($uuid) > -1 ||
					$uuid in this.rowsDeleted) {
					rows.push({
						$uuid: $uuid,
						$index: ii
					});
				}
			}
			return rows;
		},
		_setAllRowsDirty: function() {
			for (var ii = 0, jj = this.json.length; ii < jj; ii++) {
				var $uuid = this.json[ii].$uuid;
				this.setDirty($uuid);
			}
		}
	}
);

/**
 * Array dataset wrapping arrays having exactly one column
 */
var SingleArrayDataset = utils.defineClass(
	function SingleArrayDataset(json, prototype, parent, $bind) {
		var self = this;
		ArrayDataset.call(this, json, prototype, parent, $bind);
		this.isReferenceArray = false;
		if (this.prototype.json.$item.$type === "application/x-reference") {
			this.isReferenceArray = true;
			this.valueProperty = Object.keys(this.prototype.json.$item.$item.$properties)[0];
			var json = {
				$properties: {
					$value_ref: $.extend(true, {}, this.prototype.json.$item),
				}
			}
			json.$properties.$value_ref.$item[this.valueProperty] = "{" + this.valueProperty + "}";
			json.$properties[this.valueProperty] = $.extend(true, {}, this.prototype.json.$item.$item.$properties[this.valueProperty]);
			json.$properties[this.valueProperty].$isExcluded = true;
			json.$type = "$simplePropertyArray";
			//this.rowPrototype = prototype.createNew(this.prototype.json.$item.$item);
			//this.valueProperty = Object.keys(this.rowPrototype.json.$properties)[0];
			//this.rowPrototype.json.$type = "$simplePropertyArray";
			this.rowPrototype = prototype.createNew(json)
			for (var i = 0; i < this.json.length; i++) {
				this.json[i].$uuid = utils.UUID();
			}
		} else {
			this.valueProperty = "$value";
			this.rowPrototype = prototype.createNew({
				$type: "$simplePropertyArray",
				$properties: {
					$value: prototype.json.$item
				}
			});
			var wrappedItems = this.json.map(function(row) {
				return self._wrapRow(row);
			});
			// Clean original json and add wrapped items
			this.json.splice(0, this.json.length);
			for (var i = 0; i < wrappedItems.length; i++) {
				this.json.push(wrappedItems[i]);
			}
		}
	},
	ArrayDataset, {

		get$ItemProto: function() {
			return this.rowPrototype;
		},

		/**
		 * Add a new row to the array, returns newly created dataset
		 */
		addRow: function() {
			var $uuid = utils.UUID();
			var rowData = {
				$uuid: $uuid
			};
			this.json.push(rowData);
			this.setDirty(this.$bind); // full array is dirty all time
			return this.getRowByUuid($uuid);
		},
		removeRow: function($uuid) {
			var idx = this.getRowIndex($uuid);
			if (idx != null) {
				this.json.splice(idx, 1);
			}
			this.setDirty(this.$bind); // full array is dirty all time
			this.removeDatasetByUuid($uuid);
		},
		getDataDelta: function() {
			// For single prop arrays, there is no delta
			// it's always all rows
			return this.getData();
		},
		getData: function() {
			var deltaRows = [];
			var i;
			//
			// we cannot do return this.json;
			// because original json is modified to allow tracking of values
			//
			for (i = 0; i < this.json.length; i++) {
				if (this.isReferenceArray) {
					var d = {};
					// X3 doesn't accept undefined (adding reference field in singleArray)
					d[this.valueProperty] = this.json[i][this.valueProperty] || "";
					deltaRows.push(d);
				} else {
					deltaRows.push(this.json[i][this.valueProperty]);
				}
			}
			return deltaRows;
		},
		applyDelta: function(delta) {
			var rowsAdded = 0;
			for (var ii = 0, jj = delta.length; ii < jj; ii++) {
				var deltaRow = delta[ii];
				if (ii < this.json.length) {
					var row = this.json[ii];
					var rowChanged = false;
					var $bind;
					if (this.isReferenceArray) {
						if (row[this.valueProperty] !== deltaRow[this.valueProperty]) {
							row[this.valueProperty] = deltaRow[this.valueProperty];
							$bind = "$value_ref";
							rowChanged = true;
						}
					} else {
						if (row[this.valueProperty] !== deltaRow) {
							row[this.valueProperty] = deltaRow;
							$bind = this.valueProperty;
							rowChanged = true;
						}
					}
					if (rowChanged && $bind) {
						// If the value changed, let the dataset representing the row know of it
						var rowDataset = this.rowDatasetsByUuid[row.$uuid];
						if (rowDataset) { // there may be no row dataset if the row was not read by the UI, so no need to notify
							rowDataset._deltaManValueChanged($bind);
						}
					}
				} else {
					if (this.isReferenceArray) {
						// We do not care about uuid set by the server. It's not used in the protocol
						// Better create our own one to persistently identify the row on client side 
						deltaRow.$uuid = utils.UUID();
						this.json.push(deltaRow);
					} else {
						this.json.push(this._wrapRow(deltaRow));
					}
					rowsAdded++;
				}
			}
			if (delta.length < this.json.length) {
				// Cleanup dataset of removed rows
				for (var ii = delta.length, jj = this.json.length; ii < jj; ii++) {
					this._deltaManRowRemoved(this.json[ii].$uuid, ii);
					this.removeDatasetByUuid(this.json[ii].$uuid);
				}
				var rowsRemoved = this.json.length - delta.length;
				this.json.splice(delta.length, rowsRemoved);
			} else if (rowsAdded > 0) {
				for (var ii = this.json.length - rowsAdded, jj = this.json.length; ii < jj; ii++) {
					// If there are new rows, let the listeners know 
					this._deltaManRowAdded(this.json[ii].$uuid, ii);
				}
			}
			this.dirtyProperties = [];
		},
		setClean: function($bind, includeChildren) {
			// This override is only for documentation
			// once a single property array is dirty, it will never become clean again
			// console.log("Cleaning a row's dirty flag will never cleanup array for simple type arrays");
			ArrayDataset.prototype.setClean.call(this, $bind, includeChildren);
		},
		_setAllRowsDirty: function() {
			this.setDirty(this.$bind);
		},
		_wrapRow: function(row) {
			if (row && row.$value != null) {
				// Already wrapped
				return row;
			}
			return {
				$uuid: utils.UUID(),
				$value: row
			};
		}
	}
);

exports.SingleArrayDataset = SingleArrayDataset;

/**
 * Row dataset
 * Used to represent data of an array row in MultiArrayDatasets
 * No special implementation yet but used to represent a row dataset for future extensions
 */
var RowDataset = utils.defineClass(
	function RowDataset(json, prototype, parent, $bind) {
		Dataset.call(this, json, prototype, parent, $bind);
	},
	Dataset, {
		destroy: function() {
			Dataset.prototype.destroy.call(this);
		},
		getLink: function($linkName, $bind) {
			var link = _checkQueryFullPage(this.prototype, $linkName);
			if (link) {
				return link;
			}
			var linkD;
			// This is for links that are on property ($resources.$item) level with dynamic meta
			// data only available in the root dataset (the page)
			var parentProp = this.parent && this.parent.$bind;
			if (!$bind && parentProp && this.parent.parent && this.parent.parent.$bind == null) {
				linkD = this.parent.parent.getValueByPath("$properties." + parentProp + ".$item.$links." + $linkName);
			}

			var path = $bind ? "$properties." + $bind + ".$item.$links." + $linkName : "$links." + $linkName;
			var linkP = this.prototype.getValueByPath(path);
			if (!linkD) linkD = this.getValueByPath(path);
			if (!linkP && !linkD) {
				return;
			}
			link = $.extend(true, {}, linkP, linkD);
			if (link.$isHidden) return
			if (link.$url && /\{(\S+?)\}/.test(link.$url)) {
				link.$url = this.resolveExpression(link.$url)
			}
			return link;
		},
		getUuid: function() {
			// !! getUuid can be call on destroyed dataset due to the removeRow process
			return this.json ? this.json["$uuid"] : null;
		}
	}
);

exports.RowDataset = RowDataset;
});

define('syracuse-tablet/html/js/controls/articleParser',['require','exports','module','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var modules = require('syracuse-tablet/html/js/common/modules');

/**
 * page: not mandatory (eg: for cards, formController)
 */
exports.parseArticle = function(controller, article, page) {
	var ctrlFactory;

	function parseNode(controller, article, parent, opts) {
		if (article.$layoutType) {
			// Used by unitTestManager to identify layouts
			if (opts.index == null) {
				opts.index = 0;
			} else {
				opts.index++;
			};
			opts.makeFullHeight = page && page.options.makeFullHeight === true;
		}
		var ctrl = ctrlFactory.createControl(controller, article, parent, page, opts);
		if (ctrl && article.$layoutType && article.$items) {
			article.$items.forEach(function($itm) {
				parseNode(controller, $itm, ctrl, opts);
			});
		}
		return ctrl;
	}
	ctrlFactory = modules.get("ctrlFactory");
	if (!article) {
		throw new Error("Unexpected empty article");
	}
	if (!article.$layoutType) {
		//Mandatory - Better than an exception	
		article.$layoutType = "stack";
	}
	var root = parseNode(controller, article, null, {});
	return root;
};

exports.createDefaultArticle = function(prototype, options) {
	if (options && options.isChartDetail) return exports.createDefaultChartDetailArticle(prototype)
	var article = {
		"$layoutType": "stack",
		"$items": []
	};

	var $properties = prototype.getValueByPath("$properties");
	for (var $bind in $properties) {
		if (prototype.getValueByPath("$properties." + $bind + ".$isExcluded") == true) {
			continue;
		}
		article.$items.push({
			$bind: $bind
		});
	}
	return article;
};
exports.createDefaultChartDetailArticle = function(prototype) {
	var article = {
		"$layoutType": "stack",
		"$display": "bothSideToSide",
		"$items": []
	};

	var $properties = prototype.getValueByPath("$properties");
	for (var $bind in $properties) {
		if (prototype.getValueByPath("$properties." + $bind + ".$isExcluded") == true) {
			continue;
		}
		if (prototype.getValueByPath("$properties." + $bind + ".$cube")) {
			var graph = {
				"$layoutType": "row",
				"$items": []
			};
			var cell = {
				"$layoutType": "cell",
				"$bgColor": "transparent",
				"$widthAll": "6",
				"$sameSize": true,
				"$items": [{
					"$bind": $bind,
					"$display": "chart",
					"$arrayOptions": {
						"showPagination": false,
						"showSortFilter": false,
						"showSearch": false,
						"rowIndex": false
					}
				}]
			}
			graph.$items.push(cell)
			cell = {
				"$layoutType": "cell",
				"$bgColor": "transparent",
				"$widthAll": "6",
				"$sameSize": true,
				"$items": [{
					"$bind": $bind,
					"$forceArray": true,
					"$display": "table"
				}]
			}
			graph.$items.push(cell)
			article.$items.push(graph)
		} else {
			article.$items.push({
				$bind: $bind
			});
		}
	}
	return article;
};
});

define('syracuse-tablet/html/js/sdata/sdataRequesterLocal',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/common/ajax','syracuse-tablet/html/js/sdata/protocolHelpers','syracuse-tablet/html/js/controls/articleParser','syracuse-tablet/html/js/sdata/dataset','syracuse-tablet/html/js/sdata/prototype'],function (require, exports, module) {

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var ajax = require('syracuse-tablet/html/js/common/ajax');
var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');
var articleParser = require("syracuse-tablet/html/js/controls/articleParser");

var Dataset = require('syracuse-tablet/html/js/sdata/dataset').Dataset;
var Prototype = require('syracuse-tablet/html/js/sdata/prototype').Prototype;

var _cachedUrls = {};

exports.localEndpoint = "$client.$local.$dataset";

/**
 * "http://localhost:8124/syracuse-tablet/html/index_debug.html?
 * url=http://localhost:8124/mobile2/$client/$local('STD_EX_ERP_EXPENSES_DASHBOARD')?representation=mobileDashboard.$details
 * &dataset=/$dataset/mobileDashboard/syracuse-tablet/html/js/mocks/mobileDashboard_STD_EX_ERP_EXPENSES_DASHBOARD_data.json
 * &prototype=/syracuse-tablet/html/js/mocks/mobileDashboard_details_proto.json
 * &article=/syracuse-tablet/html/js/mocks/mobileDashboard_STD_EX_ERP_EXPENSES_DASHBOARD_article.json"
 */

var _getEntityFromPath = function(path) {
	return /\w*/.exec(path.split("/")[5]);
}

var _suffix_facets = {
	"$details": "detail",
	"$edit": "edit",
	"$create": "edit",
	"$query": "query",
	"$lookup": "lookup",
	"$queryItem": "query"
}

exports.fetchPageData = function($link, options) {
	options = options || {};
	var url = jsutils.parseURL($link.$url);
	var entity = _getEntityFromPath(url.path);
	var facetInfo = protoHelpers.getReprInfoFromUrl($link.$url);
	var prototypeUrl;
	var datasetUrl;
	var articleUrl;
	if (url.path.indexOf("/mobileDashboard") >= 0) {
		// Put all mobileDashboard in a dedicated folder
		var key = protoHelpers.getKeyFromUrl(url.path);
		// Default proto - Same for all dashboards
		prototypeUrl = "/syracuse-tablet/html/js/mocks/mobileDashboard/" + (url.query.prototype || "$details") + "_proto.json";
		// Data key_data.json by default
		datasetUrl = "/syracuse-tablet/html/js/mocks/mobileDashboard/" + (url.query.dataset || key) + "_data.json";
		// Article key_article.json by default
		articleUrl = "/syracuse-tablet/html/js/mocks/mobileDashboard/" + (url.query.articleUrl || key) + "_article.json";
	} else {
		var suffixFacet = facetInfo && _suffix_facets[facetInfo.facet];
		var defBaseUrl = null;
		if (suffixFacet && entity) {
			defBaseUrl = jsutils.getUrlHost(url) + "/syracuse-tablet/html/js/mocks/" + entity + "/" + entity + "_" + suffixFacet + "_";
		}
		datasetUrl = url.query.dataset;
		if (defBaseUrl && datasetUrl == null) {
			datasetUrl = defBaseUrl + "data.json"
		}
		prototypeUrl = url.query.prototype;
		if (defBaseUrl && prototypeUrl == null) {
			// Used to manage multiple pprotod for an entity entity_query_proto_card, entity_query_proto_table
			var protoName = url.query.protoName;
			prototypeUrl = defBaseUrl + "proto" + (protoName ? "_" + protoName : "") + ".json";
		}
		articleUrl = url.query.article;
		if (defBaseUrl && articleUrl == null) {
			// Used to manage multiple articles for an entity entity_query_article_card, entity_query_article_table
			var articleName = url.query.articleName;
			articleUrl = defBaseUrl + "article" + (articleName ? "_" + articleName : "") + ".json";
		}
	}
	var prototypeJson;
	var datasetJson;
	var articleJson;
	var headers = {

	}

	return $.smResolve()
		.then(function() {
			return _ajax(prototypeUrl);
		})
		.then(function(result) {
			prototypeJson = result.data;
			if (facetInfo) {
				prototypeJson.$type = "{$baseType}." + entity + "." + facetInfo.facet;
			}
			return _ajax(datasetUrl);
		})
		.then(function(result) {
			datasetJson = result.data;
			if (options.page && options.page.$article) {
				return {
					data: options.page.$article
				}
			} else {
				return _ajax(articleUrl, {
					acceptStatusCode: [404]
				});
			}
		})
		.then(function(result) {
			articleJson = result.data;
			if (!articleJson) {
				articleJson = articleParser.createDefaultArticle(new Prototype(prototypeJson));
			}
			return protoHelpers.checkTransform($link.$url, prototypeJson, datasetJson, {
				$article: articleJson
			});
		})
		.then(function(pageDataTransformed) {
			var pageData = {
				isWorkingCopy: false
			};

			pageData.prototype = new Prototype(pageDataTransformed.prototypeJson);
			pageData.dataset = new Dataset(pageDataTransformed.datasetJson, pageData.prototype);
			pageData.page = pageDataTransformed.page;

			return pageData;
		});
}
exports.fetchDataset = function(key) {
	var datasetUrl = "/syracuse-tablet/html/js/mocks/mobileDashboard/" + key + "_data.json";
	return _ajax(datasetUrl);
}

function _ajax(url, opts) {
	var def = $.Deferred();

	var forceNoCache = "?" + (new Date()).getTime();

	ajax.request(url + forceNoCache, null, null, null, opts)
		.then(function(result) {
			_cachedUrls[url] = result;
			def.resolve(result);
		})
		.fail(function(cause) {
			if (_cachedUrls[url]) {
				def.resolve(_cachedUrls[url]);
			} else {
				def.reject(cause);
			}
		})
	return def.promise();
}
});

define('syracuse-tablet/html/js/sdata/sdataUtils',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var _rID = /^(.*)\(\'(.*)\'\)$/i;
/**
 * nofail= true	return null if error
 */
exports.parseSDataURL = function(url, noFail) {
	var res = jsutils.parseURL(url);
	if (res.query && res.query.representation) {
		res.representation = res.query.representation;
		res.facet = null;
		var p = res.representation.indexOf('.');
		if (p != -1) {
			res.facet = res.representation.substr(p + 1);
			if (res.facet.charAt(0) == '$') res.facet = res.facet.substr(1);
			res.representation = res.representation.substr(0, p);
		}
	}
	var a;
	if (res.directory) {
		var idx = res.directory.indexOf("/$services/");
		if (idx > -1) {
			res.$services = res.directory.substring(idx + 11);
		}
		a = res.directory.split('/');
	}
	if (a == null || a.length <= 4) {
		if (noFail === true) return null;
		throw new Error("Bad sdata url:" + url);
	}
	res.dispatch = a[1];
	if (res.dispatch !== "mobile1" && res.dispatch !== "mobile2" && res.dispatch !== "sdata") {
		if (noFail === true) return null;
		throw new Error("Bad sdata url:" + url);
	}
	res.application = a[2];
	res.contract = a[3];
	res.dataset = a[4];
	if (a.length === 4) return res;
	var match = _rID.exec(a[5]);
	if (match && (match.length == 3)) {
		res.entity = match[1];
		res.id = match[2];
		if (res.id && res.id.trim().Length === 0) res.id = null;
	} else {
		res.entity = a[5];
		res.id = null;
	}
	if (a.length === 5) return res;
	return res;
};

/**
 * SCan diagnoses in a sdata response
 * TODO TEST
 */
exports.clearSyracuseStack = function(d) {
	if (d.$stackTrace && d.$stackTrace.indexOf("node_modules\syracuse-x3") >= 0) {
		if (d.$message && d.$stackTrace.indexOf(d.$message) >= 0) {
			// No need of stack
			delete d.$stackTrace;
		} else {
			// Remove stack because too long
			d.$stackTrace = d.$stackTrace.split("\n")[0];
		}
	}
	return d;
};
exports.scanDiagnoses = function(data) {
	var result = [];
	var done = [];
	var _scan = function(o, prop, path) {
		if (!path) path = [];
		if (done.indexOf(o) >= 0) return;
		if (Array.isArray(o)) {
			done.push(o);
			if (prop) path.push(prop);
			o.forEach(function(e, idx) {
				_scan(e, idx + "", path);
			});
			if (prop) path.pop(prop);
		} else if ($.isPlainObject(o)) {
			done.push(o);
			for (var p in o) {
				if (p === "$diagnoses") {
					o[p].forEach(function(d) {
						var $path = [].concat(path);
						if (prop) $path.push(prop);
						if (p) $path.push(p);
						d = exports.clearSyracuseStack($.extend({}, d));
						d.$path = $path.join('.');
						result.push(d);
					});
				} else {
					if (prop) path.push(prop);
					_scan(o[p], p, path);
					if (prop) path.pop(prop);
				}
			}
		}
	};
	if (data != null) _scan(data);
	return result;

};

exports.addWhereClause = function(url, where, params) {
	params = params || {};
	var allParamsSet = true;
	where = where.value;
	var res = where.replace(/\{(\w*?)\}/g, function(m, p1) {
		var value = params[p1];
		if (value == null) {
			allParamsSet = false;
		}
		return value != null ? value : "";
	});
	if (allParamsSet) {
		url = url + "&where=" + res;
	}
	return url;
};
});

define('syracuse-tablet/html/js/sdata/sdataRequesterOffline',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/common/helpers','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/sdata/protocolHelpers','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/sdata/cache/metaDataCache','syracuse-tablet/html/js/sdata/sdataUtils','syracuse-tablet/html/js/sdata/dataset','syracuse-tablet/html/js/sdata/prototype'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("SDataRequesterOffline", false);
var locale = require('syracuse-tablet/html/js/helpers/locale');
var helpers = require("syracuse-tablet/html/js/common/helpers");
var jsutils = require("syracuse-tablet/html/js/helpers/jsutils");
var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');
var modules = require('syracuse-tablet/html/js/common/modules');

var metaDataCache = require('syracuse-tablet/html/js/sdata/cache/metaDataCache');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');

var Dataset = require('syracuse-tablet/html/js/sdata/dataset').Dataset;
var Prototype = require('syracuse-tablet/html/js/sdata/prototype').Prototype;

var OFFLINEQUERYCOUNT = 20;
var _repExp = /\$prototypes\('(.*?)'\)/;
var _keyExp = /\('(.*?)'\)/;
var _keyExpEq = /\(.+'(.*?)'\)/;

var _newTemplateKey = "$$new$$";

function _getCache() {
	return modules.get("cache").getCache();
}

/**
 * Try to fetch the data specified by url from the cache
 */
exports.fetchData = function($url, $method, prototypeJson) {
	var operation;
	return $.smResolve()
		.then(function() {
			operation = _getOperation($url, $method);
		})
		.then(function() {
			console.log(operation);
			switch (operation.$operation) {
				case "new":
					return _readCacheNew(operation, prototypeJson);
				case "read":
					return _readCacheDetail(operation, prototypeJson);
				case "query":
					return _readCacheQuery(operation, prototypeJson);
			}
		});
}

/**
 * Reads an article from the cache
 */
exports.getPage = function($url, sdataResponse) {
	var base = jsutils.getUrlHost($url);
	var endpoint = protoHelpers.getEndpointFromUrl($url);
	var repr = protoHelpers.getReprFromUrl($url);

	if (repr === "mobileDashboard.$details") {
		repr = protoHelpers.getKeyFromUrl($url);
	}
	var pageName = endpoint + "." + repr;
	return $.smResolve()
		.then(function() {
			return metaDataCache.getPage(pageName);
		});
}

/**
 * Read prototype from cache
 */
exports.getPrototype = function($prototypeUrl) {
	var endpoint = protoHelpers.getEndpointFromUrl($prototypeUrl);
	var repr = protoHelpers.getKeyFromUrl($prototypeUrl);
	var protoName = endpoint + "." + repr;

	return $.smResolve()
		.then(function() {
			return metaDataCache.getPrototype(protoName);
		})
		.then(function(proto) {
			if (proto == null) {
				return $.smReject(helpers.createDiag(null, "error", locale.text("error.network.offline.cache"), "Url:" + $prototypeUrl));
			}
			return proto;
		});
}

exports.writeToCache = function($url, $method, cacheData, prototypeJson) {
	var operation;
	return $.smResolve()
		.then(function() {
			operation = _getOperation($url, $method);
		})
		.then(function() {
			switch (operation.$operation) {
				case "new":
					return _writeCacheNew(operation, cacheData, prototypeJson);
				case "read":
					return _writeCacheDetail(operation, cacheData, prototypeJson);
				case "query":
					return _writeCacheArray(operation, cacheData, prototypeJson);
			}
		});
}

function _readCacheDetail(op, prototypeJson) {
	log && log("Read cache: " + op.$endpoint + "." + op.$representation + ": " + op.$key);
	return _getCache().read({
			$representation: op.$representation,
			$key: op.$key,
			$endpoint: op.$endpoint
		})
		.then(function(result) {
			if (result) {
				log && log("Cache hit");
				return result;
			}
			log && log("Cache miss");
			return $.smReject(helpers.createDiag(null, "error", locale.text("error.network.offline.cache")));
		});
}


function _writeCacheDetail(op, data, prototypeJson) {
	log && log("Put cache: " + op.$endpoint + "." + op.$representation + ": " + op.$key);
	return _getCache().put({
		$representation: op.$representation,
		$key: op.$key,
		$endpoint: op.$endpoint,
		$data: data
	});
}

function _readCacheNew(op, prototypeJson) {
	log && log("Read cache: " + op.$endpoint + "." + op.$representation + ": " + _newTemplateKey);
	return _getCache().read({
			$representation: op.$representation,
			$key: _newTemplateKey,
			$endpoint: op.$endpoint
		})
		.then(function(result) {
			if (result) {
				log && log("Cache hit");
				return result;
			}
			log && log("Cache miss");
			return $.smReject(helpers.createDiag(null, "error", locale.text("error.network.offline.cache")));
		});
}


function _writeCacheNew(op, data, prototypeJson) {
	log && log("Put cache: " + op.$endpoint + "." + op.$representation + ": " + _newTemplateKey);
	return _getCache().put({
		$representation: op.$representation,
		$key: _newTemplateKey,
		$endpoint: op.$endpoint,
		$data: data
	});
}

function _writeCacheArray(op, data, prototypeJson) {
	if (!data || !data.$resources) {
		return $.smResolve();
	}
	if (op.$isRequest === true || op.$isStats === true) {
		return _writeCacheRequestAndStats(op, data, prototypeJson);
	} else {
		return _writeCacheQuery(op, data, prototypeJson);
	}
}

function _writeCacheQuery(op, data, prototypeJson) {
	var proto = prototypeJson.$properties && prototypeJson.$properties.$resources && prototypeJson.$properties.$resources.$item || prototypeJson;
	return $.smForEachPromise(data.$resources, function(item) {
		var key = _calculateKey(proto, item);
		if (!key) {
			key = item.$uuid;
		}
		return _getCache().put({
			$representation: op.$representation,
			$key: key,
			$endpoint: op.$endpoint,
			$data: item
		});
	});
}

function _writeCacheRequestAndStats(op, data, prototypeJson) {

}

function _readCacheArray(op, data, prototypeJson) {
	if (op.$isRequest === true || op.$isStats === true) {
		return _readCacheRequestAndStats(op, prototypeJson);
	} else {
		return _readCacheQuery(op, prototypeJson);
	}
}

function _readCacheQuery(op, prototypeJson) {
	var proto = prototypeJson.$properties && prototypeJson.$properties.$resources && prototypeJson.$properties.$resources.$item || prototypeJson;
	var filters = proto.$filters;
	var where;
	var orderBy;
	var keyField;

	// Supervisor currently sends "application/json;vnd.sage=syracuse" on $type of $item so we use the root level type
	// which should contain a representation name
	proto.$type = prototypeJson.$type;

	return $.smResolve()
		.then(function() {
			return _extendWhereWithFilter(op, filters);
		})
		.then(function(_where) {
			where = _where;
		})
		.then(function() {
			if (proto.$key) {
				keyField = proto.$key.replace(/{/g, "").replace(/}/g, "");
			} else {
				keyField = "$uuid";
			}
		})
		.then(function() {
			return _parseOrderBy(op.$orderBy, keyField);
		})
		.then(function(_orderBy) {
			orderBy = _orderBy;
		})
		.then(function() {
			return _getCache().query({
				$proto: proto,
				$endpoint: op.$endpoint,
				$where: where,
				$orderBy: orderBy
			});
		})
		.then(function(result) {
			if (result == null) {
				return $.smReject(helpers.createDiag(null, "error", locale.text("error.network.offline.cache")));
			}
			return _queryCutAndAddLinks(op, result, prototypeJson);
		})
		.then(function(result) {
			return result;
		});
}

function _readCacheRequestAndStats(op, prototypeJson) {

}

function _getOperation($url, $method) {
	$method = $method || "GET"
	var url = $url;
	var result = {
		$url: $url,
		$method: $method,
		$parsedUrl: sdataUtils.parseSDataURL($url)
	};
	result.$endpoint = result.$parsedUrl.application + "." + result.$parsedUrl.contract + "." + result.$parsedUrl.dataset;
	var dir = result.$parsedUrl.directory; // All except query parameters
	var idx;
	if ($method === "GET") {
		if (url.indexOf("$prototypes") > -1) {
			result.$operation = "prototype";
			result.$representation = _repExp.exec(url)[1];
		} else if (dir.indexOf("$template") > -1) {
			result.$operation = "new";
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
		} else if (result.$parsedUrl.$services) {
			result.$operation = "service";
			result.$service = result.$parsedUrl.$services;
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
		} else {
			var key = _keyExp.exec(dir);
			if (key != null) {
				key = key[1];
			} else {
				key = _keyExpEq.exec(dir);
				if (key != null) {
					key = key[1];
				}
			}
			result.$isStats = dir.indexOf("/STATS(") > -1;
			result.$isRequest = dir.indexOf("/QUERY(") > -1;
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
			if (key && !(result.$isStats || result.$isRequest)) {
				result.$operation = "read";
				result.$key = key;
			} else {
				result.$operation = "query";
			}
		}
		if (result.$parsedUrl.query && result.$parsedUrl.query.where) {
			result.$where = result.$parsedUrl.query.where;
		}
		if (result.$parsedUrl.query && result.$parsedUrl.query.orderBy) {
			result.$orderBy = result.$parsedUrl.query.orderBy;
		}
	} else if (result.$parsedUrl.$services) {
		result.$operation = "service";
		result.$service = result.$parsedUrl.$services;
		result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
	} else if ($method === "DELETE") {
		var key = _keyExp.exec(dir);
		result.$operation = "delete";
		result.$key = key[1];
		result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
	} else {
		// PUT/POST and no service
		var key = _keyExp.exec(dir);
		if (key) {
			result.$operation = "save";
			result.$key = key[1];
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
		} else {
			result.$operation = "save";
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
		}
	}

	return result;
};

function _calculateKey(proto, item) {
	var key;
	if (proto.$key) {
		key = proto.$key.replace(/\{(.*?)\}/g, function(match, prop) {
			return item[prop];
		});
	} else {
		key = item.$uuid;
	}
	return key;
}

function _checkQueryPrototype(op, proto) {
	// https://github.com/Sage-ERP-X3/Syracuse/issues/6003
	// Type of $item in queries is application/json but the cache needs a concrete type to be able to store the data
	// For requester requests, type is empty and will also be generated here
	if (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) {
		proto.$properties.$resources.$item.$type = "{$baseType}." + op.$representation;
	}
}

function _queryCutAndAddLinks(op, result, prototypeJson) {
	var response = {};
	result = result || [];
	var baseUrl = op.$parsedUrl.source.split("?")[0];
	var query = "";
	var key;
	var max = OFFLINEQUERYCOUNT;
	var orderBy = "";

	if (op.$parsedUrl.query && op.$parsedUrl.query.where) {
		query += "&where=" + op.$parsedUrl.query.where;
	}

	key = op.$parsedUrl.query && op.$parsedUrl.query.key;
	var firstKeyRead;
	var lastKeyRead;

	var resources = response.$resources = [];
	var hasNextPage = false;
	var hasPreviousPage = false;
	var i;
	var orderBy = "";
	var val;
	var kv;
	var proto = (prototypeJson.$properties && prototypeJson.$properties.$resources && prototypeJson.$properties.$resources.$item) || prototypeJson;
	var keyField;

	return $.smResolve()
		.then(function() {
			if (proto.$key) {
				keyField = proto.$key.replace(/{/g, "").replace(/}/g, "");
			} else {
				keyField = "$uuid";
			}
		})
		.then(function() {
			if (op.$parsedUrl.query && op.$parsedUrl.query.orderBy) {
				return _buildOrderBy(op, keyField, op.$parsedUrl.query.orderBy);
			}
		})
		.then(function(_orderBy) {
			if (_orderBy) {
				orderBy = _orderBy;
				query += "&orderBy=" + orderBy;
			}

			var keyType = proto.$properties[keyField];
			var isNumericKey = keyType && keyType.$type && keyType.$type !== "application/x-string";
			var gotMatch = false;
			if (key && key.smStartsWith("gt")) {
				val = key.substr(3);
				val = isNumericKey ? +val : val;

				for (i = 0; i < result.length; i++) {
					if (!gotMatch) {
						kv = _calculateKey(proto, result[i]);
						kv = isNumericKey ? +kv : "" + kv;
					}
					if (kv == val && !gotMatch) {
						gotMatch = true;
					} else if (gotMatch) {
						resources.push(result[i]);
						if (resources.length > max) {
							break;
						}
					} else {
						hasPreviousPage = true;
					}
				}
				if (resources.length > 0) {
					if (resources.length > max) {
						resources.pop();
						hasNextPage = true;
					}
					firstKeyRead = _calculateKey(proto, resources[0]);
					lastKeyRead = _calculateKey(proto, resources[resources.length - 1]);
				}
			} else if (key && key.smStartsWith("lt")) {

				if (key.length > 3) {
					val = isNumericKey ? +key.substr(3) : "" + key.substr(3);

					for (i = result.length - 1; i >= 0; i--) {
						if (!gotMatch) {
							kv = _calculateKey(proto, result[i]);
							kv = isNumericKey ? 0 + kv : "" + kv;
						}

						if (kv == val && !gotMatch) {
							gotMatch = true;
						} else if (gotMatch) {
							resources.push(result[i]);
							if (resources.length > max) {
								break;
							}
						} else {
							hasNextPage = true;
						}
					}
					if (resources.length > max) {
						hasPreviousPage = true;
						resources.pop();
					}
				} else {
					for (i = result.length - 1; i >= 0; i--) {
						resources.push(result[i]);
						if (resources.length > max) {
							break;
						}
					}
				}
				if (resources.length > 0) {
					if (resources.length > max) {
						hasPreviousPage = true;
						resources.pop();
					}
					response.$resources = resources = resources.reverse();

					firstKeyRead = _calculateKey(proto, resources[0]);
					lastKeyRead = _calculateKey(proto, resources[resources.length - 1]);
				}
			} else {
				for (i = 0; i < result.length; i++) {
					resources.push(result[i]);
					if (resources.length > max) {
						break;
					}
				}
				if (resources.length > 0) {
					if (resources.length > max) {
						hasNextPage = true;
						resources.pop();
					}

					firstKeyRead = _calculateKey(proto, resources[0]);
					lastKeyRead = _calculateKey(proto, resources[resources.length - 1]);
				}
			}

			var links = response.$links = {};
			if (key) {
				links.$first = {
					$url: baseUrl + "?representation=" + op.$representation + query
				};
			}

			if (key && firstKeyRead && hasPreviousPage) {
				if (key !== "gt") { // not on first page?
					links.$previous = {
						$url: baseUrl + "?representation=" + op.$representation + query + "&key=lt." + firstKeyRead
					};
				}
			}

			if (key !== "lt" && lastKeyRead && hasNextPage) { // not on last page and more records
				links.$next = {
					$url: baseUrl + "?representation=" + op.$representation + query + "&key=gt." + lastKeyRead
				};
			}
			if (key !== "lt" && hasNextPage) {
				links.$last = {
					$url: baseUrl + "?representation=" + op.$representation + query + "&key=lt"
				};
			}

			return response;
		});
}

function _parseOrderBy(orderBy, keyField) {
	return $.smResolve().
	then(function() {
		if (!orderBy) {
			return [{
				property: keyField,
				sort: "ASC"
			}];
		}
		var o = [];
		orderBy.split(",").map(function(field) {
			field = field.trim();
			var d = field.split(" ");
			var f = d[0].trim();
			if (f.length > 0) {
				var dir = "ASC";
				if (d.length > 1) {
					dir = d[1].toUpperCase();
					dir = dir !== "DESC" ? "ASC" : "DESC";
				}
				o.push({
					property: f,
					sort: dir
				});
			}
		});
		return o;
	});
}

function _buildOrderBy(op, keyField, orderBy) {
	return $.smResolve().
	then(function() {
		if (!orderBy) {
			return keyField;
		}

		if (!(orderBy === keyField || orderBy.indexOf(keyField + " ") > -1 || orderBy.indexOf(keyField + ",") > -1)) {
			// Key field not yet in order by
			if (orderBy.indexOf(" DESC") > -1) {
				orderBy += ", " + keyField + " DESC";
			} else {
				orderBy += ", " + keyField + " ASC";
			}
		}
		return orderBy;
	});
}

function _extendWhereWithFilter(op, filters) {
	return $.smResolve()
		.then(function() {
			var where = op.$where;
			if (!filters) {
				return where;
			}
			var filterName = op.$parsedUrl && op.$parsedUrl.query && op.$parsedUrl.query.filter;
			if (!filterName) {
				return where;
			}
			var filter = filters && filters[filterName];
			if (!filter) {
				return where;
			}

			return _checkFilterWhere(filterName, filter.$where)
				.then(function(fw) {
					if (!fw) {
						return where;
					}

					if (where) {
						where = "(" + where + ") and (" + fw + ")";
					} else {
						where = "(" + fw + ")";
					}

					return where;
				});
		});
}

/*
 * Check if X3 filter contains invalid references of screen elements which are not valid on client side
 * In case it's true, the filter will be ignored and an error message will be displayer
 */
function _checkFilterWhere(filterName, where) {
	var invalid = where.match(/(\[F\:\w+\]?)/g);
	if (invalid) {
		return $.smReject(helpers.createDiag({}, "error", locale.text("sdata.error.filter.screenFieldDetails", [filterName, invalid.join(","), where])));
	}
	return $.smResolve(where);
}
});

define('syracuse-tablet/html/js/sdata/sdataStatic',['require','exports','module'],function (require, exports, module) {

exports.getMobileDashboardProto = function() {
	return {
		"$type": "application/json",
		"$prototype": "{$baseUrl}/$prototypes('{$representation}.$details')",
		"$url": "{$baseUrl}/{$pluralType}('{$key}')",
		"$title": "Mobile dashboard",
		"$key": "{$uuid}",
		"$description": "Mobile dashboard definition",
		"$pluralType": "mobileDashboards",
		"$representation": "mobileDashboard",
		"$properties": {
			"dashboardName": {
				"$title": "Dashboard name",
				"$isUnique": true,
				"$isMandatory": true,
				"$capabilities": "sort,filter,alphaTab",
				"$links": {
					"$details": {
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/{$pluralType}('{$key}')?representation={$representation}.$details&role={$role}"
					}
				},
				"$type": "application/x-string"
			},
			"title": {
				"$title": "Title",
				"$isMandatory": true,
				"$capabilities": "sort,filter,localize,alphaTab",
				"$links": {
					"$details": {
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/{$pluralType}('{$key}')?representation={$representation}.$details&role={$role}"
					},
					"$localize": {
						"$title": "Translations",
						"$url": "{$shortUrl}/title/$localize",
						"$method": "GET"
					}
				},
				"$type": "application/x-string"
			},
			"description": {
				"$title": "Description",
				"$isMandatory": true,
				"$capabilities": "sort,filter,localize,alphaTab",
				"$links": {
					"$localize": {
						"$title": "Translations",
						"$url": "{$shortUrl}/description/$localize",
						"$method": "GET"
					}
				},
				"$type": "application/x-string"
			},
			"vignettes": {
				"$title": "Gadgets",
				"$capabilities": "sort,filter",
				"$type": "application/x-array"
			}
		},
		"$baseType": "application/json;vnd.sage=syracuse",
		"$baseUrl": "http://localhost:8124/mobile2/syracuse/collaboration/syracuse",
	};
}

exports.getMobileApplicationProto = function() {
	return {
		"$mobileDashboardProto": exports.getMobileDashboardProto(),

		"$type": "application/json",
		"$prototype": "{$baseUrl}/$prototypes('{$representation}.$details')",
		"$url": "{$baseUrl}/{$pluralType}('{$key}')",
		"$title": "Mobile application",
		"$key": "{$uuid}",
		"$pluralType": "mobileApplications",
		"$representation": "mobileApplication",
		"$properties": {
			"title": {
				"$title": "Title",
				"$isMandatory": true,
				"$capabilities": "sort,filter,localize,alphaTab",
				"$type": "application/x-string"
			},
			"description": {
				"$title": "Description",
				"$isMandatory": true,
				"$capabilities": "sort,filter,localize,alphaTab",
				"$type": "application/x-string"
			},
			"applicationName": {
				"$title": "Mobile application name",
				"$isUnique": true,
				"$isMandatory": true,
				"$capabilities": "sort,filter,alphaTab",
				"$type": "application/x-string"
			},
			"iconName": {
				"$title": "Icon",
				"$capabilities": "sort,filter,alphaTab",
				"$type": "application/x-string",
				"$isMandatory": false
			},
			"onlineOnly": {
				"$title": "Online only",
				"$capabilities": "sort,filter",
				"$type": "application/x-boolean",
				"$isNullable": true,
				"$isMandatory": false
			},
			"versionNumber": {
				"$title": "Version",
				"$isReadOnly": true,
				"$isHidden": true,
				"$capabilities": "sort,filter,alphaTab",
				"$type": "application/x-string",
				"$isMandatory": false
			},
			"roles": {
				"$title": "Roles",
				"$capabilities": "sort,filter",
				"$type": "application/x-array",
				"$item": {
					"$type": "application/x-reference",
					"$item": {
						"$url": "{$baseUrl}/roles('{$key}')?representation={$representation}.$thumb",
						"$shortUrl": "{$baseUrl}/roles('{$key}')",
						"$value": "{description}",
						"$description": "Roles allows personalized configurations for users",
						"$key": "{$uuid}",
						"$properties": {
							"description": {
								"$type": "application/x-string"
							}
						},
						"$prototype": "{$baseUrl}/$prototypes('{$representation}.$thumb')",
						"$representation": "role",
						"$links": {
							"$details": {
								"$type": "application/json;vnd.sage=syracuse",
								"$url": "{$baseUrl}/roles('{$key}')?representation=role.$details&role={$role}"
							}
						}
					}
				}
			},
			"endPoints": {
				"$title": "Endpoints",
				"$capabilities": "sort,filter",
				"$type": "application/x-array",
				"$item": {
					"$type": "application/x-reference",
					"$item": {
						"$url": "{$baseUrl}/endPoints('{$key}')?representation={$representation}.$thumb",
						"$shortUrl": "{$baseUrl}/endPoints('{$key}')",
						"$value": "{description}",
						"$description": "Endpoints describe services locations",
						"$key": "{$uuid}",
						"$properties": {
							"description": {
								"$type": "application/x-string"
							}
						},
						"$prototype": "{$baseUrl}/$prototypes('{$representation}.$thumb')",
						"$representation": "endPoint",
						"$links": {
							"$details": {
								"$type": "application/json;vnd.sage=syracuse",
								"$url": "{$baseUrl}/endPoints('{$key}')?representation=endPoint.$details&role={$role}"
							}
						}
					}
				}
			},
			"homeDashboard": {
				"$title": "Home dashboard",
				"$isMandatory": true,
				"$capabilities": "sort,filter",
				"$type": "application/x-reference",
				"$item": {
					"$url": "{$baseUrl}/mobileDashboards('{$key}')?representation={$representation}.$thumb",
					"$shortUrl": "{$baseUrl}/mobileDashboards('{$key}')",
					"$value": "{title}",
					"$description": "Mobile dashboard definition",
					"$key": "{$uuid}",
					"$properties": {
						"title": {
							"$type": "application/x-string"
						}
					},
					"$prototype": "{$baseUrl}/$prototypes('{$representation}.$thumb')",
					"$representation": "mobileDashboard",
					"$links": {
						"$details": {
							"$type": "application/json;vnd.sage=syracuse",
							"$url": "{$baseUrl}/mobileDashboards('{$key}')?representation=mobileDashboard.$details&role={$role}"
						}
					}
				}
			},
		},
		"$baseType": "application/json;vnd.sage=syracuse",
		"$baseUrl": "http://localhost:8124/mobile2/syracuse/collaboration/syracuse",
	}
}
});

define('syracuse-tablet/html/js/controls/vignette/gadget',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/sdata/protocolHelpers'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');

/**
 * Helper to wrap gadget data
 * 
 * Parent page calls dashboard with these url's right now:
 * We need to preserver this old url schema, the new one should be better aligned to sdata
 * {$baseUrl}/$mobileDashboards?dashboard=testContextDashboardChild&parameters=group%3D%7Bgroup%7D
 * 
 * Better (new form) will be:
 * .../mobile2/syracuse/collaboration/syracuse/mobileDashboards(dashboardName%20eq%20'STD_X3_ERP_EXPENSES_DASHBOARD')?representation=mobileDashboard.$details&parameters=group%3D%7Bgroup%7D
 *
 * 
 */
exports.Gadget = utils.defineClass(
	function Gadget(gadgetJson, parameters) {
		this.json = gadgetJson;
		/* use for test only
		 * this is set by mobileGadget entity
		this.json.parameters = {
			where: {
				value: "CODE eq '{CODE}'"
			}
		};
		*/
		// Values for this.json.parameters passed in by dashboard
		this._dashboardParams = {};
	}, null, {
		destroy: function() {},

		data: function(prop) {
			return this.json ? this.json[prop] : null;
		},

		getType: function() {
			return this.json.$type;
		},

		getExternalUrl: function() {
			return this.json.externalUrl;
		},

		/**
		 * Compute the link that is used to fetch information represented by this gadget
		 * return: 
		 * {
		 *   $url: ...
		 *   $method: ...
		 * }
		 */
		getLink: function() {
			var $link;
			// For client side test gadgets, we directly enter $url and $method in gadget data
			// like that, a client side gadget can point to another client side dashboard etc or also
			// to a real X3 entity
			if (this.json.$url && this.json.$method) {
				$link = {
					$url: this._buildUrl(this.json.$url, false),
					$method: this.json.$method
				};
			} else {
				var method = "_computeLink_" + (this.json.$type === "$representation" ? (this.json.$type + "_" + this.json.facet) : this.json.$type);
				$link = this[method].call(this);
			}
			return $link;
		},
		_computeLink_$representation_$query: function() {
			var url;
			var url = "{$baseUrl}/" + this.json.entity +
				"?representation=" + this.json.representation + "." + this.json.facet;
			url = this._buildUrl(url, true, true);

			return {
				$url: url,
				$method: "GET"
			};
		},
		_computeLink_$representation_$details: function() {
			var url;
			url = "{$baseUrl}/" + this.json.entity +
				"('{$key}')" +
				"?representation=" + this.json.representation + "." + this.json.facet;
			url = this._buildUrl(url, true, true);
			return {
				$url: url,
				$method: "GET"
			};
		},
		_computeLink_$representation_$edit: function() {
			var url;
			url = "{$baseUrl}/" + this.json.entity +
				"('{$key}')" +
				(this._useWorkingCopyUrl() ? "/$workingCopies" : "") +
				"?representation=" + this.json.representation + "." + this.json.facet;
			url = this._buildUrl(url, true, true);
			return {
				$url: url,
				$method: this._useWorkingCopyUrl() ? "PUT" : "GET"
			};
		},
		_computeLink_$representation_$create: function() {
			var url;
			url = "{$baseUrl}/" + this.json.entity +
				"/$template" +
				(this._useWorkingCopyUrl() ? "/$workingCopies" : "") +
				"?representation=" + this.json.representation + "." + this.json.facet;
			url = this._buildUrl(url, true, true);
			return {
				$url: url,
				$method: this._useWorkingCopyUrl() ? "POST" : "GET"
			};
		},
		_computeLink_$dashboard: function() {
			var url;
			url = "{$collaborationBaseUrl}/" +
				"mobileDashboards(dashboardName%20eq%20'" +
				this.json.dashboardName +
				"')?representation=mobileDashboard.$details";
			url = this._buildUrl(url, false, true);
			return {
				$url: url,
				$method: "GET"
			};
		},
		_computeLink_$application: function() {
			var url;
			url = "{$collaborationBaseUrl}/" +
				"mobileApplications(applicationName%20eq%20'" +
				this.json.applicationName +
				"')?representation=mobileApplication.$details";
			url = this._buildUrl(url, false, true);
			return {
				$url: url,
				$method: "GET"
			};
		},
		_computeLink_$external: function() {
			var url = this.json.externalUrl;
			url = this._buildUrl(url, false);
			return {
				$url: url,
				$method: "GET"
			};
		},
		_computeLink_$request: function() {
			var url = "{$baseUrl}/QUERY('" + this.json.requestName + "')?representation=QUERY~" +
				this.json.requestName + (this.json.requestLevel ? "~" + this.json.requestLevel : "") + "." +
				this.json.facet;
			url = this._buildUrl(url, true, true);
			return {
				$url: url,
				$method: "GET"
			};
		},
		_computeLink_$stats: function() {
			var url = "{$baseUrl}/STATS('" + this.json.statName + "')?representation=STATS~" +
				this.json.statName + "." +
				this.json.facet;
			url = this._buildUrl(url, true, true);
			return {
				$url: url,
				$method: "GET"
			};
		},
		_buildUrl: function(url, addParameters, addContext) {
			var self = this;
			url = url.replace(/\{(\S+?)\}/g, function(m, p) {
				return self._getGadgetValue(p);
			});

			if (addParameters) { // Add parameters defined in the gadget definition, resolve place holders by parameter values passed to gadget via dashboard
				var params = [];
				this.json.parameters && Object.keys(this.json.parameters).forEach(function(paramName) {
					var paramValue = self._getParamValue(self.json.parameters[paramName].value);
					if (paramValue != null) {
						params.push(paramName + "=" + paramValue);
					}
				});
				if (params.length > 0) {
					var sep = url.indexOf("?") < 0 ? "?" : "&";
					url = url + sep + params.join("&");
				}
			}
			if (addContext) {
				url = protoHelpers.addClientContext(url, this.json.$clientContext);
			}
			return url;
		},
		_getParamValue: function(paramValue) {
			var self = this;
			if (paramValue.indexOf("{") < 0) { // static value?
				return paramValue;
			}
			var allParamsSet = true;
			var res = paramValue.replace(/\{(\S+?)\}/g, function(m, p) {
				var param = self._dashboardParams && self._dashboardParams[p];
				var value = param && param.value;
				if (value == null) {
					allParamsSet = false;
				}
				return value != null ? value : "";
			});
			return allParamsSet == true ? res : null;
		},
		/**
		 * key: $baseUrl, $key, ...
		 */
		_getGadgetValue: function(key) {
			var method = "_get_" + key;
			return this[method].call(this);
		},
		_get_$baseUrl: function() {
			var baseUrl = protoHelpers.getHostPort();
			var endpoint = this._getEndpoint();
			var url = baseUrl + "/mobile2/" + endpoint.split(".").join("/");
			return url;
		},
		_get_$hostPort: function() {
			return protoHelpers.getHostPort();
		},
		_get_$key: function() {
			return this.json.keyParameter;
		},
		_get_$collaborationBaseUrl: function() {
			var baseUrl = protoHelpers.getHostPort();
			return baseUrl + "/mobile2/syracuse/collaboration/syracuse";
		},

		_useWorkingCopyUrl: function() {
			return (this.json.$clientContext && this.json.$clientContext.$mobileProtocol) === "workingcopy";
		},

		_getEndpoint: function() {
			// Does gadget definition use a fixed endpoint?
			var endpoint = this.json.endpoint;
			if (!endpoint) {
				// No endpoint specified in gadget so use the one specified while loading the dashboard
				endpoint = this.json.$clientContext.$mobileEndpoint;
			}
			return endpoint;
		},

		/** 
		 * params = {
		 *	 "CODE": {
		 *		value: "10"
		 *	 }
		 * };
		 */
		setDashboardParams: function(params) {
			this._dashboardParams = params;
		}
	});

exports.createGadget = function(proto) {
	if (proto) {
		var $item = proto.getValueByPath("$item");
		if ($item) {
			return new exports.Gadget(proto.getValueByPath("$item"));
		}
	}
}
});

define('syracuse-tablet/html/js/sdata/sdataRequester',['require','exports','module','syracuse-tablet/html/js/common/ajax','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/common/helpers','syracuse-tablet/html/js/sdata/protocolHelpers','syracuse-tablet/html/js/sdata/dataset','syracuse-tablet/html/js/sdata/prototype','syracuse-tablet/html/js/controls/articleParser','syracuse-tablet/html/js/sdata/sdataRequesterLocal','syracuse-tablet/html/js/sdata/sdataRequesterOffline','syracuse-tablet/html/js/sdata/sdataStatic','syracuse-tablet/html/js/sdata/cache/metaDataCache','syracuse-tablet/html/js/controls/vignette/gadget','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {

var ajax = require('syracuse-tablet/html/js/common/ajax');
var __ajax = ajax;

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var helpers = require('syracuse-tablet/html/js/common/helpers');

var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');
var Dataset = require('syracuse-tablet/html/js/sdata/dataset').Dataset;
var Prototype = require('syracuse-tablet/html/js/sdata/prototype').Prototype;
var articleParser = require("syracuse-tablet/html/js/controls/articleParser");

var sdataRequesterLocal = require("syracuse-tablet/html/js/sdata/sdataRequesterLocal");
var sdataRequesterOffline = require("syracuse-tablet/html/js/sdata/sdataRequesterOffline");
var sdataStatic = require('syracuse-tablet/html/js/sdata/sdataStatic');
var metaDataCache = require('syracuse-tablet/html/js/sdata/cache/metaDataCache');
var gadget = require('syracuse-tablet/html/js/controls/vignette/gadget');

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("SDataRequester", false);

/**
 * Used by test cases to use ajax stub during some tests
 */
exports.__testInjectAjax = function(ajaxStub) {
	ajax = ajaxStub;
}
exports.__testRestoreAjax = function(ajaxStub) {
	ajax = __ajax;
}

/**
 * 
 * Get data from the server according to link information
 * 
 * $link: {
 *   $url: ...
 *   $method: ...
 * }
 * 
 * 
 * options: {
 * 
 * 	   Can be used to pass in predefined data structures if a page is reloaded and not fully loaded
 *     e.g. a protoype will not change when fetching the next page of a query

 *     prototype:
 *     page:
 *     data:
 *     useMetaFromCache: true -> do not try to load proto and article from server
 * }
 * 
 * 
 * return:
 * {
 *   prototype: prototype of navigation target
 *   dataset: data of navigation target,
 *   page: article json and views 
 *   isWorkingCopy: true / false
 * }
 * 
 * Injected to dataset
 * dataset in the return is comming from the server but the client add the following data to it:
 * dataset: {
 *     $clientContext: {
 *         endpoint: x3.erp.GX3APP
 *         application: STD_X3_EXPENSES
 *         protocol: workingcopy|stateless
 *     }
 * }
 * Whenever a navigation occurs, the controller will add the context to the new page so we 
 * know the "context" without the need of managing a global state for this
 * 
 * 
 * Special sdata urls:
 * 
 * Load mobile application:
 * .../syracuse/collaboration/syracuse/mobileApplications(applicationName%20eq%20'STD_X3_ERP_EXPENSES_ONLINE')?representation=mobileApplication.$details&$mobileEndpoint=x3.erp.GX3APP
 * Note $mobileEndpoint must be present to define the endpoint to load the app from
 * 
 * Load Dashboard
 * 
 */
exports.fetchPageData = function($link, options) {
	options = options || {};
	var $url = $link.$url;
	var $method = $link.$method;
	var self = this;
	// Flag if the current page will be managed by a working copy
	var isWorkingCopy = $url.indexOf("$workingCopies") > -1;

	var $mobileProtocol = $url.indexOf("$mobileProtocol=workingcopy") > -1 ? "workingcopy" : "stateless";

	if ($link.$method === "POST" && isWorkingCopy) {
		$url = $url + "&trackingId=" + utils.UUID();
	}

	// Handle client side hard coded entities
	var endpoint = protoHelpers.getEndpointFromUrl($url);
	if (endpoint === sdataRequesterLocal.localEndpoint) {
		return sdataRequesterLocal.fetchPageData($link, options);
	}

	// If the page to be opened is opened in the context of a stateless app
	// we can assume all meta data (proto+article) is available in the local
	// caches, so no need to fetch them below
	if ($mobileProtocol === "stateless") {
		options.useMetaFromCache = true;
	}

	var prototypeJson;
	var datasetJson;
	var articleJson;
	var viewsJson;
	log && log("Fetching: " + $url + " (" + $method + ")");

	// Fix facet recognition for some escaped urls
	$url = $url.replace(/\.\%24/g, ".$");

	return _getPrototype(protoHelpers.getPrototypeUrl($url), options)
		.then(function(proto) {
			prototypeJson = proto;
			return _getData($url, $method, prototypeJson, null, options);
		})
		.then(function(data) {
			datasetJson = data;
			return _getPage($url, $method, prototypeJson, datasetJson, options);
		})
		.then(function(page) {
			return protoHelpers.checkTransform($url, prototypeJson, datasetJson, page);
		})
		.then(function(pageDataTransformed) {
			var pageData = {};
			pageData.prototype = new Prototype(pageDataTransformed.prototypeJson);
			pageData.dataset = new Dataset(pageDataTransformed.datasetJson, pageData.prototype);
			pageData.isWorkingCopy = isWorkingCopy;
			pageData.$url = $url;
			pageData.$originalUrl = $url; // Will be overriden by pageFactory to contain original url before applying filter/sort
			pageData.page = pageDataTransformed.page;
			return pageData;
		});
};
/**
 * 
 */
function _getPrototype($prototypeUrl, options) {
	if (options && options.prototype) {
		log && log("Skip reading prototype");
		return $.smResolve(options.prototype);
	}

	// Some prototypes do never change (like mobile dashboard or app)
	// so we hard code them to save some requests in working copy mode
	var fetchProto = $.Deferred();


	var fetchStatic = $.Deferred();
	_getStaticPrototype($prototypeUrl)
		.then(function(staticProto) {
			fetchStatic.resolve(staticProto);
		})
		.fail(function(e) {
			fetchStatic.resolve(null);
		});

	fetchStatic.then(function(staticProto) {
		if (staticProto) {
			fetchProto.resolve(staticProto);
		} else {
			if (options.useMetaFromCache === true) { // true for stateless apps
				// Fetch from cache
				sdataRequesterOffline.getPrototype($prototypeUrl)
					.then(function(result) {
						fetchProto.resolve(result);
					})
					.fail(function(resultOffline) {
						// If offline fails, we use a client side test application that links to a
						// prototype that may not be in the cache
						// So this is a fallback for tesing only and will never be used in real life because in real life
						// the prototype will always be in the cache
						ajax.request($prototypeUrl)
							.then(function(result) {
								fetchProto.resolve(result.data);
							})
							.fail(function(result) {
								result.offline = true;
								fetchProto.reject(result);
							});
					});
			} else {
				ajax.request($prototypeUrl)
					.fail(function(result) {

						if (result.offline) {
							// Fetch offline if possible
							sdataRequesterOffline.getPrototype($prototypeUrl)
								.then(function(result) {
									fetchProto.resolve(result);
								})
								.fail(function(result) {
									result.offline = true;
									fetchProto.reject(result);
								});
						} else {
							// Non offline error, just bubble up
							fetchProto.reject(result);
						}
					})
					.then(function(result) {
						fetchProto.resolve(result.data);
					});
			}
		}
	});

	return fetchProto;
}

function _getStaticPrototype($prototypeUrl) {
	var endpoint = protoHelpers.getEndpointFromUrl($prototypeUrl);
	var repr = protoHelpers.getKeyFromUrl($prototypeUrl);
	var protoName = endpoint + "." + repr;

	if (protoName === "syracuse.collaboration.syracuse.mobileDashboard.$details") {
		return $.smResolve(sdataStatic.getMobileDashboardProto());
	} else if (protoName === "syracuse.collaboration.syracuse.mobileApplication.$details") {
		return $.smResolve(sdataStatic.getMobileApplicationProto());
	}
	return $.smResolve();
}

function _getData($url, $method, prototypeJson, headers, options) {
	if (options && options.data) {
		log && log("Skip reading data");
		return $.smResolve(options.data);
	}
	var writeCache = true;
	var fetchData = $.Deferred();
	var fetchStatic = $.Deferred();

	if (options && options.noCacheWrite === true) {
		writeCache = false;
	}

	_getStaticData($url, $method, prototypeJson)
		.then(function(staticData) {
			if (staticData) {
				writeCache = false;
			}
			fetchStatic.resolve(staticData);
		})
		.fail(function(e) {
			fetchStatic.resolve(null);
		});

	fetchStatic.then(function(staticData) {
		// Check if data is available locally (e.g. mobile apps are in the DB all the time)
		if (staticData) {
			fetchData.resolve(staticData);
		} else {
			ajax.request($url, $method, null, headers, options && options.ajaxOptions)
				.fail(function(result) {

					if (result.offline) {

						// Fetch offline if possible
						sdataRequesterOffline.fetchData($url, $method, prototypeJson)
							.then(function(result) {
								fetchData.resolve(result);
							})
							.fail(function(result) {
								result.offline = true;
								fetchData.reject(result);
							})
					} else {

						// Non offline error, just bubble up
						fetchData.reject(result);
					}
				})
				.then(function(result) {
					if (writeCache && result.data) {
						sdataRequesterOffline.writeToCache($url, $method, result.data, prototypeJson);
					}
					fetchData.resolve(result.data);
				});
		}
	});
	return fetchData;
}

function _getStaticData($url, $method, prototypeJson) {
	if (prototypeJson.$representation === "mobileApplication") {
		// A mobile application is never loaded by the requester
		// It's installed by the navigation helper BEFORE the actual navigation
		// is started. So it's data is always available in the cache
		var appName = protoHelpers.getKeyFromUrl($url);
		var parsed = jsutils.parseURL($url);
		var endpoint = parsed.query.$mobileEndpoint;
		if (endpoint) {
			return metaDataCache.tryGetApp(appName, endpoint).then(function(mobileApp) {
				return _checkFetchGadgetData(mobileApp, endpoint);
			});
		}
	}
	return $.smResolve();
}

function _getPage($url, $method, prototypeJson, datasetJson, options) {
	if (options && options.page && options.page.$article) {
		log && log("Skip reading article");
		return $.smResolve({
			$article: options.page.$article,
			$views: options.page.$views
		});
	}

	var pageUrl;
	var fetchPage = $.Deferred();
	var fetchStatic = $.Deferred();

	_getStaticArticle($url, $method, prototypeJson, datasetJson)
		.then(function(staticArticle) {
			fetchStatic.resolve(staticArticle);
		})
		.fail(function(e) {
			fetchStatic.resolve(null);
		});

	fetchStatic.then(function(staticArticle) {
		if (staticArticle) {
			fetchPage.resolve(staticArticle);
		} else {
			if (options.useMetaFromCache === true) {
				sdataRequesterOffline.getPage($url, datasetJson)
					.then(function(result) {
						fetchPage.resolve(result);
					})
					.fail(function(resultOffline) {
						// If offline fails, we use a client side test application that links to an
						// article that may not be in the cache
						// So this is a fallback for tesing only and will never be used in real life because in real life
						// the article will always be in the cache
						protoHelpers.getPageUrl($url, datasetJson)
							.then(function(_pageUrl) {
								pageUrl = _pageUrl;
							})
							.then(function(_pageUrl) {
								return ajax.request(pageUrl);
							})
							.fail(function(result) {
								fetchPage.reject(result);
							})
							.then(function(result) {
								fetchPage.resolve(result.data);
							});
					});
			} else {
				protoHelpers.getPageUrl($url, datasetJson)
					.then(function(_pageUrl) {
						pageUrl = _pageUrl;
					})
					.then(function(_pageUrl) {
						return ajax.request(pageUrl);
					})
					.fail(function(result) {
						if (result.offline) {

							// Fetch offline if possible
							sdataRequesterOffline.getArticle($url, datasetJson)
								.then(function(result) {
									fetchPage.resolve(result);
								})
								.fail(function(result) {
									result.offline = true;
									fetchPage.reject(result);
								});
						} else {
							// Non offline error, just bubble up
							fetchPage.reject(result);
						}
					})
					.then(function(result) {
						fetchPage.resolve(result.data);
					});
			}
		}
	});

	return fetchPage.then(function(page) {
		var $article = page && page.$article;
		if (!$article) {
			if (prototypeJson && prototypeJson.$representation === "mobileDashboard") {
				// Do not generate default article for mobile dashboard, it will be generated later in transform step if needed
			} else {
				$article = articleParser.createDefaultArticle(new Prototype(prototypeJson), {
					isChartDetail: options.isChartDetail
				});
			}
		}
		return {
			$article: $article,
			$views: page && page.$views
		}
	});
}

function _getStaticArticle($url, $method, prototypeJson, datasetJson) {
	if (prototypeJson.$representation === "mobileApplication") {
		// A mobile application representation is never rendered.
		// Instead, the home dashboard or home gadget of the mobile application is rendered
		// This is why we create a fake article for the mobile application (which will not be used) 
		// The acutal article is here:
		// datasetJson.$homeDashboard.$page.$article or datasetJson.$gadgetDashboard.$page.$article;
		// Later on page load, the dashboards article will be used (protocolHelpers.checkTransform)
		return $.smResolve({
			$layoutType: "stack"
		});
	}
	return $.smResolve(null);
}

/**
 * Create page information from cached offline data.
 * 
 * Used to mock test cases or offline stateless mode
 * 
 */
exports.createPageDataJson = function(datasetJson, prototypeJson, article) {

	if (prototypeJson.$representation === "mobileDashboard") { // this is set for syracuse entities which is what matters here
		var transformed = protoHelpers.transformDashboard(datasetJson, prototypeJson);

		prototypeJson = transformed.prototypeJson;
		datasetJson = transformed.datasetJson;
	}

	var proto = new Prototype(prototypeJson);
	return {
		prototype: proto,
		dataset: new Dataset(datasetJson, proto),
		article: article || prototypeJson.$article
	};
}

/**
 * Trigger named action
 * $actionName: Name of action (e.g. Save)
 * dataset: Dataset used to build request
 * workingCopy: true or false: Use working copy or not
 * 
 * return:
 * server response
 */
exports.triggerAction = function($actionName, dataset, workingCopy) {
	var def = $.Deferred();
	$.smResolve()
		.then(function() {
			var $action = dataset.getAction($actionName);
			if (!$action) {
				return $.smReject(helpers.createDiag(null, "error", "Action does not exist: " + $actionName));
			}
			return $action;
		})
		.then(function($action) {
			var actionData = protoHelpers.createActionData(dataset, $actionName, $action, workingCopy);
			if (actionData) {
				return ajax.request(actionData.$url, actionData.$method, actionData.data);
			}
		})
		.then(function(result) {
			def.resolve(result);
		})
		.fail(function(result) {
			// If we got a diag here, just merge it into dataset later to show the error
			if (result && result.data && result.data.$diagnoses) {
				// We end up here on X3 responding with http 400 on invalid field values in stateless mode
				// In working copy mode, we get http 200 and diagnoses, so we can treat both as ok
				def.resolve(result);
			} else {
				// Not sure what happened here, better reject
				def.reject(result);
			}
		})

	return def.promise();
};

/**
 * 
 */
exports.executeLink = function($url, $method, dataset) {
	var data;
	if (["PUT", "POST"].indexOf($method) > -1) {
		data = dataset.getData();
	}
	return ajax.request($url, $method, data);
}

/**
 * Export delete working copy
 */
exports.deleteWC = function(dataset) {
	return ajax.request(dataset.getUrl(), "DELETE");
};

/**
 * Extract delta in client side working copy and send it to the server
 * parameter $bind is used to update text because url and content uploaded are not like other data
 */
exports.updateServer = function(dataset, $bind) {
	if (!dataset.isRoot()) {
		return $.smReject(helpers.createDiag(null, "error", "Server update only possible on root dataset"));
	}
	return $.smResolve()
		.then(function() {
			var isText = $bind && dataset.prototype.propIsText($bind);
			var delta = isText ? dataset.getDataText($bind) : dataset.getDataDelta();
			var options = {};
			if (isText) {
				options.contentType = dataset.prototype.propGetType($bind);
			}
			var $url = dataset.getUrl(false, isText ? $bind : null);
			return ajax.request($url, "PUT", delta, null, options);
		})
		.then(function(response) {
			return response;
		});
};
/*Used in ctrlText to get text content*/
exports.getLazyPropData = function($url, prototypeJson, $type) {
	var headers = {
		Accept: $type
	};
	var ajaxOptions = {
		contentType: $type
	};

	return ajax.request($url, "GET", null, headers, ajaxOptions).then(function(result) {
		return result.data;
	})
};

function _checkFetchGadgetData(appData, endpoint) {
	if (appData.useHomeGadget !== true) {
		return $.smResolve(appData);
	}

	var $mobileProtocol = appData.onlineOnly ? "workingcopy" : "stateless";
	var gproto = {
		"$item": appData.$homeGadget,
	};
	gproto.$item.$clientContext = {
		$mobileProtocol: $mobileProtocol,
		$mobileEndpoint: endpoint,
		$mobileApplication: appData.applicationName
	};
	var g = gadget.createGadget(new Prototype(gproto));
	var $link = g.getLink();
	return exports.fetchPageData($link)
		.then(function(gadgetData) {
			appData.$homeGadgetFetched = {
				prototype: gadgetData.prototype.json,
				dataset: gadgetData.dataset.json
			}
			appData.$homeGadgetFetched.dataset.$page = gadgetData.page;

			// The url used to navigate is a different one than is actually rendered so we save
			// the one which is responsible for loading the actual data in $mobileEmbeddedUrl to be able
			// to determin the "real" page name later for authoring
			appData.$homeGadgetFetched.dataset.$mobileEmbeddedUrl = $link.$url;
			return appData;
		})
}
});

define('syracuse-tablet/html/js/helpers/html-escape/lib/escape',['require','exports','module'],function (require, exports, module) {

function fixOptions(options) {
	options = options || {};
	options.allowedTags = (options.allowedTags || []).concat( //
		['h1', 'h2', 'h3', 'h4', 'h5', 'h6', //
			'blockquote', 'p', 'a', 'ul', 'ol', 'nl', 'li', //
			'b', 'i', 'strong', 'em', 'strike', 'code', //
			'hr', 'br', 'div', 'pre', //
			'table', 'thead', 'caption', 'tbody', 'tr', 'th', 'td', 'pre'
		]);
	options.allowedAttributes = (options.allowedAttributes || []).concat( //
		['class', 'href', 'src', 'name', 'target']);
	options.allowedSchemes = (options.allowedSchemes || []).concat( //
		['http', 'https', 'mailto']);
	return options;
}

function map(array) {
	return array.reduce(function(map, key) {
		map[key] = true;
		return map;
	}, {});
}

function escapeText(str) {
	return str.replace(/>/g, '&gt;');
}

function escapeComment(str) {
	return str.replace(/-->/g, '__>');
}

function escapeStyle(str) {
	// brutal: will cripple all occurrences of javascript, expression and url
	return str.replace(/\/\*.*?\*\//g, '').replace(/(\\|\b)(j\\?a\\?v\\?a\\?s\\?c\\?r\\?i\\?p\\?t|e\\?x\\?p\\?r\\?e\\?s\\?s\\?i\\?o\\?n|u\\?r\\?l)\b/ig, 'disabled-$1$2');
}

function escapeType(str) {
	// cripple type="text/javascript"
	return str.replace(/javascript/i, "disabled-javascript");
}

exports.escaper = function(options) {
	options = fixOptions(options);
	var allowedTags = map(options.allowedTags);
	var allowedAttributes = map(options.allowedAttributes);
	var allowedSchemes = map(options.allowedSchemes);
	var urlAttributes = /^(href|src|dynsrc|lowsrc|background)$/i;
	var preserve = options.preserve;
	var warn = options.warn;

	function checkChange(oldVal, newVal, prefix) {
		if (warn && newVal !== oldVal) warn(prefix + ": " + oldVal + " -> " + newVal);
		return newVal;
	}

	function escapeValue(key, val) {
		if (key === 'style') return checkChange(val, escapeStyle(val), "sanitized style");
		if (key === 'type') return checkChange(val, escapeType(val), "sanitized type attribute");
		return val;
	}

	function create() {
		var result = "";
		var inside = "text";

		function skipTillMarker(frag, marker, repl) {
			var i = frag.indexOf(marker);
			if (i >= 0) {
				if (preserve) result += escapeComment(frag.substring(0, i)) + repl + '-->';
				result += escapeText(frag.substring(i + marker.length));
				inside = "text";
			} else {
				if (preserve) result += escapeComment(frag);
			}
			return result;
		}

		function skipTillClosing(frag, tag, allowed) {
			var re = new RegExp('^/' + tag + '>', 'i');
			var m = re.exec(frag);
			if (m) {
				if (allowed) result += '</' + tag + '>';
				else if (preserve) result += '</' + tag + '>-->';
				result += escapeText(frag.substring(m[0].length));
				inside = "text";
			} else {
				if (allowed) result += escapeValue(tag, '<' + frag);
				else if (preserve) result += escapeComment('<' + frag);
			}
			return result;
		}

		function reject(frag, warn) {
			if (warn) warn("malformed element: " + frag);
			if (preserve) result += '<!--<' + escapeComment(frag) + '-->';
			return result;
		}

		function allowedValue(atb, val) {
			if (urlAttributes.test(atb)) {
				var colon = val.indexOf(':');
				if (colon < 0 || !allowedSchemes[val.substring(0, colon)]) return false;
			}
			return true;
		}

		function escapeTag(tag, closing, atbs, autoClosed) {
			if (closing) {
				result += '</' + tag + '>';
				atbs = atbs.trim();
				if (preserve && atbs) result += '<!--@' + escapeComment(atbs) + '-->';
				return;
			}
			result += '<' + tag;
			var end = 0;
			var re = /^\s*(\w+)(?:\s*=\s*(?:(["'])(.*?)\2|()([\w_-]+)))?/,
				m;
			while (m = re.exec(atbs)) {
				atbs = atbs.substring(m[0].length);
				var atb = m[1].toLowerCase();
				var quote = m[2] || '"';
				var val = m[3] || m[5];
				if (!allowedAttributes[atb] || !allowedValue(atb, val)) {
					if (warn) warn("forbidden attribute: " + atb);
					if (preserve) atb = "disabled-" + atb;
					else continue;
				}
				result += ' ' + atb + (val === undefined ? '' : '=' + quote + escapeValue(atb, val) + quote);
			}
			if (autoClosed) result += '/>';
			else result += '>';
			atbs = atbs.trim();
			if (warn && atbs) warn("malformed attribute: " + atbs);
			if (preserve && atbs) {
				result += '<!--@' + escapeComment(atbs) + '-->';
			}
		}

		return function(frag) {
			result = "";
			if (inside === "comment") return skipTillMarker('<' + frag, '-->', '');
			if (inside === "cdata") return skipTillMarker('<' + frag, ']]>', ']]');
			if (inside === "script") return skipTillClosing(frag, 'script');
			if (inside === "style") return skipTillClosing(frag, 'style', allowedTags.style);

			if (/^!--/.test(frag)) {
				inside = "comment";
				if (preserve) result += '<!-- '; // extra space marks as original comment for roundtripping
				return skipTillMarker(frag.substring(3), '-->', '');
			}
			if (/^!\[CDATA\[/.test(frag)) {
				inside = "cdata";
				if (warn) warn("forbidden CDATA");
				if (preserve) result += '<!--';
				return skipTillMarker(frag.substring(1), ']]>', ']]');
			}
			if (/^script\b/i.test(frag)) {
				inside = "script";
				if (warn) warn("forbidden *** SCRIPT *** element");
				if (preserve) result += '<!--';
				return skipTillClosing(frag, 'script');
			}
			if (/^style\b/i.test(frag)) {
				inside = "style";
				if (!allowedTags.style && warn) warn("forbidden STYLE element");
				if (preserve && !allowedTags.style) result += '<!--';
				return skipTillClosing(frag, 'style', allowedTags.style);
			}
			// Special contents have been intercepted.
			// Reject malformed tags
			var end = frag.indexOf('>');
			if (end < 0) return reject(frag, warn); // not closed
			var m = /^(\/?)(\w+)/.exec(frag);
			if (!m) return reject(frag, warn); // invalid syntax: tag name not found
			var tag = m[2].toLowerCase();
			if (!allowedTags[tag]) {
				if (warn && !m[1]) warn("forbidden " + tag.toUpperCase() + " element");
				if (preserve) reject(frag.substring(0, end + 1));
				escapeText(frag.substring(0, end + 1));
			} else {
				// tag is allowed
				var autoClosed = frag[end - 1] === '/';;
				escapeTag(tag, m[1], frag.substring(m[1].length + tag.length, autoClosed ? end - 1 : end), autoClosed);
			}
			result += escapeText(frag.substring(end + 1));
			return result;
		};
	};

	if (options.streaming) {
		return (function() {
			var process;
			return function(text) {
				if (text.indexOf('<') >= 0) throw new Error('internal error: bad HTML fragment');
				if (!process) {
					process = create();
					return escapeText(text);
				} else {
					return process(text);
				}
			};
		})();
	} else {
		return function(text) {
			var process = create();
			var frags = text.split('<');
			var result = escapeText(frags[0]);
			return frags.slice(1).reduce(function(r, frag) {
				return r + process(frag);
			}, result);
		};
	}
};
});

define('syracuse-tablet/html/js/helpers/html-escape/lib/unescape',['require','exports','module'],function (require, exports, module) {

exports.unescaper = function(options) {
	options = options || {};

	function uncomment(str) {
		return str.replace(/__>/g, '-->');
	}

	function process(str) {
		return str.replace(/disabled-(\w+=?)/g, '$1').replace(/(.?)<!--(.*?)-->/g, function(all, ch, commented) {
			if (commented[0] === ' ') return ch + '<!--' + commented.substring(1) + '-->';
			if (commented[0] === '[') return ch + '<!' + uncomment(commented) + '>';
			if (commented[0] === '<') return ch + uncomment(commented);
			if (commented[0] === '@') return uncomment(commented.substring(1)) + ch;
			throw new Error("cannot unescape: " + commented);
		});
	}
	if (options.streaming) {
		var buf = "";
		return function(str) {
			if (str === undefined) return process(buf);
			var start = Math.max(0, buf.length - 2);
			buf += str;
			var end = buf.indexOf('-->', start);
			if (end < 0) return '';
			var r = process(buf.substring(0, end + 3));
			buf = buf.substring(end + 3);
			return r;
		};
	} else {
		return process;
	}
};
});

define('syracuse-tablet/html/js/helpers/html-escape/index',['require','exports','module','./lib/escape','./lib/unescape'],function (require, exports, module) {
exports.escaper = require('./lib/escape').escaper;
exports.unescaper = require('./lib/unescape').unescaper;
});

define('syracuse-tablet/html/js/helpers/syracuse-rtf/lib/rtfparse',['require','exports','module'],function (require, exports, module) {

var lowerLetter = {},
	digit = {},
	LF = '\n'.charCodeAt(0),
	SP = ' '.charCodeAt(0),
	BSLASH = '\\'.charCodeAt(0),
	OPEN = '{'.charCodeAt(0),
	CLOSE = '}'.charCodeAt(0),
	DASH = '-'.charCodeAt(0),
	QUOTE = "\'".charCodeAt(0),
	STAR = "*".charCodeAt(0);

(function() {
	function add(clas, chs, i) {
		chs.split('').forEach(function(ch) {
			clas[ch.charCodeAt(0) + (i || 0)] = true;
		});
	}
	for (var i = 0; i <= 9; i++) add(digit, '0', i);
	for (var i = 0; i < 26; i++) add(lowerLetter, 'a', i);
})();

function builder(error) {
	var group = [],
		stack = [group];
	return {
		open: function() {
			var g = [];
			group.push(g);
			stack.push(g);
			group = g;
		},
		close: function() {
			if (stack.length <= 1) error("too many }");
			group = stack.pop();
			group = stack[stack.length - 1];
		},

		text: function(str) {
			group.push(str);
		},

		control: function(word, arg) {
			var obj = {
				word: word
			};
			if (arg != null) obj.arg = arg;
			group.push(obj);
		},

		/*star: function() {
			group.push({word: "*"});
		},*/

		getResult: function() {
			if (stack.length !== 1) error("missing }");
			return stack[0][0];
		}
	};
}

// returns tree. 
// intermediate nodes are arrays and correspond to rtf groups ({ ...})
// leaf nodes are either
// * strings (text elements)
// * control directives { word: w, arg: a }
exports.parse = function(str) {
	str = str.replace(/\r\n/g, '\n');
	var pos = 0,
		begText = 0,
		len = str.length,
		line = 1,
		bld = builder(error);

	function error(msg) {
		var end = str.indexOf(/[\n>]/, pos);
		if (end < 0) end = str.length;
		return new Error("Invalid RTF: " + msg + " at line " + line + " near " + str.substring(pos, end));
	}

	function flush() {
		if (pos > begText) bld.text(str.substring(begText, pos));
	}
	while (pos < len) {
		var ch = str.charCodeAt(pos);
		switch (ch) {
			case BSLASH:
				flush();
				var beg = ++pos;
				while (lowerLetter[ch = str.charCodeAt(pos)]) pos++;
				if (pos > beg) {
					var word = str.substring(beg, pos),
						arg = undefined;
					if (ch === DASH || digit[ch]) {
						beg = pos;
						pos++;
						while (digit[ch = str.charCodeAt(pos)]) pos++;
						arg = parseInt(str.substring(beg, pos), 10);
					}
					if (ch === SP || ch === LF || (word === "u" && ch !== BSLASH && ch !== OPEN && ch !== CLOSE)) {
						pos++;
					}
					bld.control(word, arg);
				} else if (ch === QUOTE) {

					var symb = String.fromCharCode(parseInt(str.substring(pos + 1, pos + 3), 16));
					bld.text(symb);
					pos = pos + 3;
				} else if (ch === STAR) {
					bld.control("*");
					pos++;
				}

				begText = pos;
				break;
			case OPEN:
				flush();
				bld.open();
				begText = ++pos;
				break;
			case CLOSE:
				flush();
				bld.close();
				begText = ++pos;
				break;
			case LF:
				flush(); // to discard newline from output
				line++;
				begText = ++pos;
				break;
			default:
				pos++;
		}
	}
	flush();
	return bld.getResult();
};
});

define('syracuse-tablet/html/js/helpers/syracuse-rtf/lib/rtfinterpret',['require','exports','module'],function (require, exports, module) {

//var rtfparser = require('./rtfparse');

exports.interpret = function(root) {

	var group;
	var documentModel = {
		deffont: "",
		fonts: {},
		colors: [],
		styles: {},
	};
	var fontfamgroups = {
		fnil: "Sans-serif",
		froman: "Sans-serif",
		fswiss: "Serif",
		fmodern: "Monospace",
		fscript: "Cursive",
		fdecor: "Cursive"
	};

	var supported = ["rtf", "ansi", "ansicpg", "deff", "fonttbl", "colortbl", "stylesheet", //
		"fs", "f", "cf", "highlight", "i", //
		"b", "ul", "strike", "plain", //
		"qc", "ql", "qr", "qj", "par", "pard", "pn"
	];

	function interpretFont(features, index, fonts) {
		var fname = features[0].word + features[0].arg;
		var font = (documentModel.fonts[fname] = {});
		for (var i = 1; i < features.length; i++) {
			interpretFontFeature(features[i], font);
		}
	}

	function interpretFontFeature(feature, font) {
		var sep;
		if (typeof feature == "string" && (sep = feature.indexOf(';')) > 0) {
			font.name = feature.substring(0, sep);
		}
	}

	function interpretStylesheet(features, index, styles) {
		var fname, style;
		if (features[0].word) {
			fname = features[0].word + features[0].arg;
			style = (documentModel.styles[fname] = {});
			for (var i = 1; i < features.length; i++) {
				interpretStyleFeature(features[i], style);
			}
		}
	}

	function interpretStyleFeature(feature, style) {
		var sep;
		if (typeof feature == "string" && (sep = feature.indexOf(';')) > 0) {
			style.name = feature.substring(0, sep);
		}
	}

	function interpretControl(node, parent, index) {
		switch (node.word) {
			case "rtf":
			case "ansi":
			case "ansicpg":
				break;
			case "stylesheet":
				parent.slice(1).filter(function(item) {
					// keep only arrays, remove newlines
					return Array.isArray(item);
				}).forEach(interpretStylesheet);
				//documentModel.stylesheet ="";
				break;
			case "deff":
				documentModel.deffont = "f" + node.arg;
				break;
			case "fonttbl":
				parent.slice(1).filter(function(item) {
					// keep only arrays, remove newlines
					return Array.isArray(item);
				}).forEach(interpretFont);
				break;
			case "colortbl":
				// semicolon counts for one item => skip 2 items first
				var i = 1;
				if (parent[i] === ';') {
					documentModel.colors.push([0, 0, 0]);
					i++;
				}
				while (i < parent.length) {
					documentModel.colors.push([parent[i].arg, parent[i + 1].arg, parent[i + 2].arg]);
					i += 4; // skip semicolon too
				} // while
				break;

			case "*":
				/*console.log(parent[index+1].word) ;*/
				if (supported.indexOf(parent[index + 1].word) == -1) parent.splice(index, parent.length - index);
				break;
		} //switch

	}

	function interpretNode(node, index, array) {
		if (Array.isArray(node)) {
			// child nodes will receive node as array argument.
			node.forEach(interpretNode);
		} else if (typeof node === "object") {
			interpretControl(node, array, index);
		}
	}

	/* on copie fonts et colors dans styles */
	interpretNode(root);
	return documentModel;
};
});

define('syracuse-tablet/html/js/helpers/syracuse-rtf/lib/buildhtml',['require','exports','module'],function (require, exports, module) {

// ===================================================================================================================================================
// ===================================================================================================================================================
// ===================================================================================================================================================
// ===================================================================================================================================================
//	<div class="s-rtf-root">
//	<div class="s-rtf-section">
//		<p></p>
//		<p></p>
//	</div>
//	<div class="s-rtf-section">
//		<ul>
//			<li></li>
//			<li></li>
//			<li></li>
//		</ul>
//	</div>
//</div>
var styleName = {
	cf: "color",
	highlight: "background-color"
};

function rgbToHex(rgb) {
	if (rgb) {
		return toHex(rgb[0]) + toHex(rgb[1]) + toHex(rgb[2]);
	} else {
		return "000000"; //default color
	}
}

function toHex(n) {
	return ("00" + n.toString(16)).slice(-2);
}

function twipsToPoint(t) {
	return t / 20;
}

function indentCount(t) {
	return t / 600;
}

function indentBulletCount(t) {
	return t / 420;
}

function twipsToPixel(t) {
	return t / 15;
}

function builder(documentModel) {
	var rtffonts = documentModel.fonts,
		deffont = documentModel.deffont,
		colors = documentModel.colors,
		styles = documentModel.styles,
		htmltext = "",
		$rootdiv = $("<div>").addClass('s-rtf-root'),
		$current = null,
		$section = null,
		$worker = null,
		context;

	newSection();

	function newWorker() {
		$current = $worker = $("<div>").addClass('s-rtf-worker').addClass('s-rtf-clean');
		return $worker.appendTo($section);
	}

	function newSection() {
		$section = $("<div>").addClass('s-rtf-section').addClass('s-rtf-clean');
		newWorker();
		return $section.appendTo($rootdiv);
	}

	function characterFormatting(node) {
		switch (node.word) {

			case "f":
				/*case "pnf":*/
				var fontface = rtffonts[node.word + node.arg].name;
				return $("<font face='" + fontface + "'>");

			case "fs":
				//case "pnfs":
				return $("<span style='font-size: " + node.arg / 2 + "pt;'>");
			case "tab":
				//case "pnfs":
				//return $("<span style='margin-left: 10pt'>");//be  carrefull depending on navigator
				return $("<blockquote>"); //be  carrefull depending on navigator
			case "cf":
				//if(!node.arg) return null;
			case "highlight":
				// do not use css() because it converts hex value into rgb style
				// return $("<span>").css(styleName[node.word], "#" + rgbToHex(colors[node.arg]));
				return $("<span style='" + styleName[node.word] + ": #" + rgbToHex(colors[node.arg]) + ";'>");

			case "b":
				return $("<b>");
			case "i":
				return $("<i>");
			case "ul":
				return $("<u>");
			case "strike":
				return $("<s>");
				/*
		case "plain":
			return ["<pre>", "</pre>"];
		case "list":
			return ["<ul>", "</ul>"];
		case "pntext":*/
				/*case "bullet":
			return $("<li>");
		case "line":
			return $("<br>");*/
			default:
				// ; //$("");
		}
	}

	function paragraphFormatting(elt, node) {
		elt.addClass('s-rtf-format');

		dirty();

		switch (node.word) {
			case "ql":
				return elt.attr("align", "left");
			case "qc":
				return elt.attr("align", "center");
			case "qr":
				return elt.attr("align", "right");
			case "qj":
				return elt.attr("align", "justify");
			case "li":
				// return elt.css("margin-left", twipsToPixel(node.arg) + "px");
				if (node.arg > 0)
					return elt.css("margin-left", twipsToPoint(node.arg) + "pt");
				else
					return elt;
			case "ri":
				// return elt.css("margin-right", twipsToPixel(node.arg) + "px");
				if (node.arg > 0)
					return elt.css("margin-right", twipsToPoint(node.arg) + "pt");
				else
					return elt;
			default:
				return elt;
		}

	}

	function dirty() {
		$worker && $worker.removeClass("s-rtf-clean");
		// if we want to always have a paragraph, uncomment this line
		// $worker && $worker.addClass("s-rtf-paragraph");
		$section && $section.removeClass("s-rtf-clean");
	}

	function append(elt) {
		dirty();
		$current.append(elt);
	}

	function wrapIn(elt) {
		dirty();
		$current = elt.appendTo($current);
	}

	context = (function() {
		var stack = [{
				format: {}
			}],
			current = stack[0];

		function flattenFormat() {
			var f, fmt = {};
			stack.forEach(function(ctx) {
				f = ctx.format;
				Object.keys(f).forEach(function(key) {
					if (typeof(fmt[key]) === "undefined") {
						fmt[key] = f[key];
					}
				});
			});
			return fmt;
		}

		return {
			open: function() {
				stack.push(current = {
					format: {}
				});
			},

			close: function(idx, parent) {
				stack.pop();
				current = stack[stack.length - 1];
				if (idx < parent.length - 1) {
					this.pending = true;
				}
			},

			update: function(prop, el) {
				if (el === null) {
					delete current.format[prop];
				} else {
					current.format[prop] = el;
				}
			},

			startOver: function() {
				if (!this.pending) return;
				var fmt = flattenFormat();
				Object.keys(fmt).forEach(function(key) {
					$current = fmt[key].clone().appendTo($current);
				});
				this.pending = false;
			}
		};
	})();

	return {
		text: function(str) {
			dirty();
			context && context.startOver();
			var content = $current.html();
			$current.html(content + str);
		},

		open: function() {
			context.open();
		},

		close: function(idx, parent) {
			$current = $worker;
			if ($current.length === 0) $current = $rootdiv;
			context.close(idx, parent);
		},

		control: function(node) {
			switch (node.word) {

				case "par":
					dirty();
					$worker.removeClass("s-rtf-worker").addClass("s-rtf-paragraph");
					$current = $worker = newWorker();
					context && (context.pending = true);
					break;

				case "pard":
					if (!$section.hasClass("s-rtf-clean")) {
						$section = newSection();
						context && (context.pending = true);
					}
					break;

				case "pn":
					$section.addClass("s-rtf-list");
					break;

				case "u":
					this.unicodechar(node.arg);
					break;

				case "qc":
				case "ql":
				case "qr":
				case "qj":
				case "ri":
					paragraphFormatting($section, node);
					break;
				case "li":
					if ($section.hasClass("s-rtf-list")) {
						$section.attr("indent", indentBulletCount(node.arg));
					} else {
						if (!$section.hasClass("s-rtf-clean") && !$section.hasClass("s-rtf-format")) {
							$section = newSection();
							context && (context.pending = true);
						}
						$section.addClass("s-rtf-left-indent");
						$section.attr("indent", indentCount(node.arg));
					}
					break;
				case "lquote":
				case "rquote":
					this.text("'");
					break;

				case "line":
					append("<br>");
					break;
				case "bullet":
					// var el = $("<li>");
					// var dd = 1;
					// if ($current.is("li")) {
					//	$current.parent().append(el);
					// } else {
					//	$current.append(el);
					// }
					// $current = el;
					break;

				case "i":
				case "b":
				case "strike":
				case "ulnone":
				case "ul":
					if (node.arg === 0 || node.word === "ulnone") {
						var tagname;
						if (node.word === "strike") {
							tagname = "s";
						} else if (node.word === "ulnone") {
							tagname = "u";
						} else {
							tagname = node.word;
						}
						if ($current.is(tagname)) {
							$current = $current.parent();
						} else {
							if ($current.html() !== "") {
								var tag = $current.closest(tagname);
								$current = tag.parent();
							}
						}

						context.update(node.word, null);
						break;
					}
				default:
					var el = characterFormatting(node);

					if (el) {
						context.update(node.word, el.clone());
						!context.pending && wrapIn(el);
					}
			}
			//console.log(node.word + "\n"+$rootdiv.html())
		},
		unicodechar: function(code) {
			dirty();
			var content = $current.html();
			$current.html(content + String.fromCharCode(code));
		},

		getHtml: function() {
			//console.log($rootdiv.html())
			// cleanup
			$rootdiv.find(".s-rtf-clean").remove();
			// replace <div> by <ul>
			var sections = $rootdiv.find(".s-rtf-section.s-rtf-list") //.removeAttr("class");
			sections.map(function(i, e) {
				var $e = $(e);
				var i = parseInt($e.attr("indent"), 10);
				var w = [];
				while (w.length < i) {
					w.push("<ul>");
				}
				$e.wrap(w.join("")).contents();
				//$e.removeAttr("indent");
			});
			var workers = sections.find(".s-rtf-paragraph");
			workers.wrap("<li>").contents().unwrap();
			//sections.unwrap();
			var indent = $rootdiv.find(".s-rtf-section.s-rtf-left-indent").removeClass("s-rtf-left-indent");
			indent.map(function(i, e) {
				var $e = $(e);
				var i = parseInt($e.attr("indent"), 10);
				var w = [];
				while (w.length < i) {
					w.push("<blockquote>");
				}
				$e.wrap(w.join("")).contents();
				$e.removeAttr("indent");
			});



			sections = $rootdiv.find(".s-rtf-section");

			// replace <div> by <p>
			sections.find(".s-rtf-paragraph").removeAttr("class").wrap("<p>").contents().unwrap();
			sections.find("div:empty").remove();



			// cleanup
			sections.find(".s-rtf-worker:empty").remove();
			sections.filter(":not(.s-rtf-format)").contents().unwrap();
			while ($rootdiv.find("span:empty").length) {
				$rootdiv.find("span:empty").remove();
			};
			$rootdiv.find(".s-rtf-worker").removeAttr("class").contents().unwrap();
			$rootdiv.find(".s-rtf-format").removeAttr("class");

			return $rootdiv.html();
		}
	};
}

// HTML builder
exports.buildHtml = function(root, documentModel) {
	var bld = builder(documentModel);

	function interpretNode(node, index, array) {
		if (typeof node == "string") {
			bld.text(node);
			return;
		}
		if (Array.isArray(node) && node.length > 0) {
			if (node[0]) {
				switch (node[0].word) {
					case 'fonttbl':
					case 'colortbl':
					case 'stylesheet':
					case 'pntxtb':
					case 'pntext':
					case 'pict':
						return;
				}
			}
			bld.open();
			node.forEach(interpretNode);
			bld.close(index, array);

			return;
		}

		if (typeof(node) === "object") {
			bld.control(node);

		}
	}

	interpretNode(root, 0, []);
	if (!root) return "<div></div>";
	return bld.getHtml();
};
});

define('syracuse-tablet/html/js/helpers/syracuse-rtf/lib/buildrtf',['require','exports','module'],function (require, exports, module) {
var colors = {
	"aliceblue": "#f0f8ff",
	"antiquewhite": "#faebd7",
	"aqua": "#00ffff",
	"aquamarine": "#7fffd4",
	"azure": "#f0ffff",
	"beige": "#f5f5dc",
	"bisque": "#ffe4c4",
	"black": "#000000",
	"blanchedalmond": "#ffebcd",
	"blue": "#0000ff",
	"blueviolet": "#8a2be2",
	"brown": "#a52a2a",
	"burlywood": "#deb887",
	"cadetblue": "#5f9ea0",
	"chartreuse": "#7fff00",
	"chocolate": "#d2691e",
	"coral": "#ff7f50",
	"cornflowerblue": "#6495ed",
	"cornsilk": "#fff8dc",
	"crimson": "#dc143c",
	"cyan": "#00ffff",
	"darkblue": "#00008b",
	"darkcyan": "#008b8b",
	"darkgoldenrod": "#b8860b",
	"darkgray": "#a9a9a9",
	"darkgreen": "#006400",
	"darkkhaki": "#bdb76b",
	"darkmagenta": "#8b008b",
	"darkolivegreen": "#556b2f",
	"darkorange": "#ff8c00",
	"darkorchid": "#9932cc",
	"darkred": "#8b0000",
	"darksalmon": "#e9967a",
	"darkseagreen": "#8fbc8f",
	"darkslateblue": "#483d8b",
	"darkslategray": "#2f4f4f",
	"darkturquoise": "#00ced1",
	"darkviolet": "#9400d3",
	"deeppink": "#ff1493",
	"deepskyblue": "#00bfff",
	"dimgray": "#696969",
	"dodgerblue": "#1e90ff",
	"firebrick": "#b22222",
	"floralwhite": "#fffaf0",
	"forestgreen": "#228b22",
	"fuchsia": "#ff00ff",
	"gainsboro": "#dcdcdc",
	"ghostwhite": "#f8f8ff",
	"gold": "#ffd700",
	"goldenrod": "#daa520",
	"gray": "#808080",
	"green": "#008000",
	"greenyellow": "#adff2f",
	"honeydew": "#f0fff0",
	"hotpink": "#ff69b4",
	"indianred ": "#cd5c5c",
	"indigo ": "#4b0082",
	"ivory": "#fffff0",
	"khaki": "#f0e68c",
	"lavender": "#e6e6fa",
	"lavenderblush": "#fff0f5",
	"lawngreen": "#7cfc00",
	"lemonchiffon": "#fffacd",
	"lightblue": "#add8e6",
	"lightcoral": "#f08080",
	"lightcyan": "#e0ffff",
	"lightgoldenrodyellow": "#fafad2",
	"lightgrey": "#d3d3d3",
	"lightgreen": "#90ee90",
	"lightpink": "#ffb6c1",
	"lightsalmon": "#ffa07a",
	"lightseagreen": "#20b2aa",
	"lightskyblue": "#87cefa",
	"lightslategray": "#778899",
	"lightsteelblue": "#b0c4de",
	"lightyellow": "#ffffe0",
	"lime": "#00ff00",
	"limegreen": "#32cd32",
	"linen": "#faf0e6",
	"magenta": "#ff00ff",
	"maroon": "#800000",
	"mediumaquamarine": "#66cdaa",
	"mediumblue": "#0000cd",
	"mediumorchid": "#ba55d3",
	"mediumpurple": "#9370d8",
	"mediumseagreen": "#3cb371",
	"mediumslateblue": "#7b68ee",
	"mediumspringgreen": "#00fa9a",
	"mediumturquoise": "#48d1cc",
	"mediumvioletred": "#c71585",
	"midnightblue": "#191970",
	"mintcream": "#f5fffa",
	"mistyrose": "#ffe4e1",
	"moccasin": "#ffe4b5",
	"navajowhite": "#ffdead",
	"navy": "#000080",
	"oldlace": "#fdf5e6",
	"olive": "#808000",
	"olivedrab": "#6b8e23",
	"orange": "#ffa500",
	"orangered": "#ff4500",
	"orchid": "#da70d6",
	"palegoldenrod": "#eee8aa",
	"palegreen": "#98fb98",
	"paleturquoise": "#afeeee",
	"palevioletred": "#d87093",
	"papayawhip": "#ffefd5",
	"peachpuff": "#ffdab9",
	"peru": "#cd853f",
	"pink": "#ffc0cb",
	"plum": "#dda0dd",
	"powderblue": "#b0e0e6",
	"purple": "#800080",
	"red": "#ff0000",
	"rosybrown": "#bc8f8f",
	"royalblue": "#4169e1",
	"saddlebrown": "#8b4513",
	"salmon": "#fa8072",
	"sandybrown": "#f4a460",
	"seagreen": "#2e8b57",
	"seashell": "#fff5ee",
	"sienna": "#a0522d",
	"silver": "#c0c0c0",
	"skyblue": "#87ceeb",
	"slateblue": "#6a5acd",
	"slategray": "#708090",
	"snow": "#fffafa",
	"springgreen": "#00ff7f",
	"steelblue": "#4682b4",
	"tan": "#d2b48c",
	"teal": "#008080",
	"thistle": "#d8bfd8",
	"tomato": "#ff6347",
	"turquoise": "#40e0d0",
	"violet": "#ee82ee",
	"wheat": "#f5deb3",
	"white": "#ffffff",
	"whitesmoke": "#f5f5f5",
	"yellow": "#ffff00",
	"yellowgreen": "#9acd32",
	// system colors
	"window": "#ffffff",
	"windowframe": "#000000",
	"windowtext": "#000000"
};

function colourNameToHex(color) {
	return colors[color.toLowerCase()];
}

function rtfContext() {
	return {
		open: function(key) {
			if (!this[key]) {
				this[key] = {};
				this[key].current = 0;
			}
			this[key].current++;
			this[key].pending = true;
			if (this[key].value && this[key].value[this[key].current - 1]) {
				this[key].value.pop();
			}
		},
		close: function(key) {
			this[key].current--;
			if (!this[key].current) this[key].pending = false;
			else this[key].pending = true;
		},
		current: function(key) {
			return (this[key] ? this[key].current : 0);
		},
		pending: function(key, val) {
			if (val !== undefined) {
				if (!this[key]) this[key] = {};
				this[key].pending = val;
			};
			return (this[key] ? this[key].pending : false);

		},
		value: function(key, val) {
			if (!this[key]) return 0;
			if (val !== undefined) {
				val = parseInt(val, 10);
				if (this[key].value === undefined) this[key].value = [];
				this[key].value.push(((this[key].current - 1) ? (this[key].value[this[key].current - 2] + val) : val));
				//this[key].value[this[key].current-1]=((this[key].current-2)? (this[key].value[this[key].current-2]+val):val);
			};
			// console.log("Value:" + this[key].value[this[key].current-1] + " val:"+val);
			return ((this[key] && this[key].value) ? this[key].value[this[key].current - 1] : 0);

		},
		nl: false,
		par: false,
		ulindent: 0
	};
};

function builder(documentModel) {
	var rtffonts = documentModel.fonts,
		colors = documentModel.colors,
		// deffont = null,
		rtftext = "",
		needSpace = false,
		ctx = rtfContext();

	function has(obj, key) {
		return Object.prototype.hasOwnProperty.call(obj, key);
	}

	function isEmpty(obj) {
		if (obj == null) return true;
		for (var key in obj)
			if (has(obj, key)) return false;
		return true;
	}

	if (!isEmpty(rtffonts)) {
		rtftext += "{\\fonttbl";
		Object.keys(rtffonts).forEach(function(key) {
			rtftext += "{\\" + key + " " + rtffonts[key].name + ";}";
		});
		rtftext += "}";
	}

	if (colors.length > 1) {
		rtftext += "{\\colortbl";
		colors.forEach(function(e) {
			if (e[0] === 0 && e[1] === 0 && e[2] === 0) {
				rtftext += ';';
			} else {
				rtftext += "\\red" + e[0] + "\\green" + e[1] + "\\blue" + e[2] + ";";
			}
		});
		rtftext += "}";
	}

	rtftext += "\\uc0\\pard";

	function fromHtmlTag(tag) {
		tag = tag.toLowerCase();
		switch (tag) {
			case "p":
				return "\\par";
			case "b":
				return "\\b";
			case "i":
				return "\\i";
			case "u":
				return "\\ul";
			case "s":
				return "\\strike";
			case "br":
				return "\\par";
			case "blockquote":
				return "";
				//	case "li":
				//		return "\\bullet";
			default:
				return ""; //<!-- " + tag + " -->"; "\\"+tag ;
		}
	}

	return {
		//header: function(){
		//	rtftext=header+rtftext ;
		//},
		open: function() {
			rtftext += "{";
			needSpace = false;
		},
		text: function(str) {
			var pos = 0,
				beg = pos,
				c;

			while (pos < str.length) {
				while (str.charCodeAt(pos) <= 128 && str.charCodeAt(pos) != 10) {
					pos++;
				}
				if (pos > beg) {
					rtftext += (needSpace ? " " : "") + str.substring(beg, pos);
				} else if (str.charCodeAt(pos) == 10) {
					rtftext += (needSpace ? " " : "");
				}
				needSpace = false;
				if (pos < str.length) {
					c = str.charCodeAt(pos);
					// replace nbsp and \n by space
					if (c === 160 || c === 10) {
						rtftext += " ";
					} else {
						this.controlarg("u", str.charCodeAt(pos));
					}
					pos++;
				}
				beg = pos;
			}
		},
		fragment: function(str) {
			rtftext += str;
			needSpace = false;
		},
		font: function(fid) {
			if (fid !== "") {
				rtftext += "\\" + fid;
				needSpace = true;
			}
		},
		controlarg: function(word, arg) {
			rtftext += "\\" + word + arg;
			needSpace = true;
		},
		control: function(word) {
			ctx.par = (word == "par");
			rtftext += "\\" + word;
			needSpace = true;
		},
		htmltag: function(word) {
			var rtf = fromHtmlTag(word);
			if (rtf) {
				ctx.par = (rtf == "\\par");
			}
			rtftext += rtf;
			needSpace = true;
		},
		star: function() {
			rtftext += "\\*";
			needSpace = false;
		},
		close: function() {
			if (!ctx.par) rtftext += "\\par";
			rtftext = "{\\rtf1\\ansi" + rtftext + "}";
			needSpace = false;
		},
		getRtf: function() {
			return rtftext;
		},
		context: ctx
	};
}

var tagMap = {
		"margin-left": "li",
		"margin-right": "ri",
		"margin-top": "sb",
		"margin-bottom": "sa"
	},
	toTwips = (function(unit, v) {
		// see http://publib.boulder.ibm.com/infocenter/domhelp/v8r0/index.jsp?topic=%2Fcom.ibm.productivity.tools.help%2Ftext%2Fcommon%2F00%2F00000003.html
		var ratio = {
			"pt": 20,
			"px": 15,
			"mm": 56.7,
			"cm": 567,
			"in": 1440.18
		};

		return function(unit, v) {
			return v * (ratio[unit] || ratio["px"]);
		};
	})();

exports.buildRtf = function(html) {
	var documentModel = {};
	documentModel.deffont = "";
	documentModel.fonts = {};
	documentModel.colors = [];
	documentModel.styles = {};
	var fontfamgroups = {
		fnil: "Sans-serif",
		froman: "Sans-serif",
		fswiss: "Serif",
		fmodern: "Monospace",
		fscript: "Cursive",
		fdecor: "Cursive"
	};
	var align = {
		left: "ql",
		center: "qc",
		right: "qr",
		justify: "qj"
	};
	var pointPxTable = [{
		pt: 6,
		px: 7
	}, {
		pt: 7,
		px: 9
	}, {
		pt: 40,
		px: 50
	}];
	var bld;
	var $root = $('<div>').append(html);
	//var $root = $(html);
	var rtffonts = [];
	//var first = false ;
	function findColor(arr, obj) {
		if (!obj) return -1;
		for (var i = 0; i < arr.length; i++) {
			if (arr[i][0] == obj[0] && arr[i][1] == obj[1] && arr[i][2] == obj[2]) {
				return i;
			}
		}
		return -1;
	}

	function isLeftIndent(n) {
		return ($(n).is("div[style]") ? ($(n).attr('style').search("margin-left") > -1) : false);
	}

	function addFont(face) {
		rtffonts.indexOf(face) < 0 && rtffonts.push(face);
	}

	function findFont(fontname) {
		var fonts = documentModel.fonts,
			keys = Object.keys(fonts);
		for (var i = 0; i < keys.length; i++) {
			if (fonts[keys[i]].name === fontname) return keys[i];
		}
		return "";
	}

	function isList(n) {
		return (($(n).is("ul") || $(n).is("li")) || (n.childElementCount > 0 && n.firstChild.nodeName === "UL"));
	}

	function processNode(n, i) {
		var clr, idx, colorid;
		//console.log(((n.nodeType!==3)?n.nodeName:n.nodeValue) + " " + (n.id?n.id:""))
		if (bld.context.pending("blockquote") && !bld.context.current("list") && !$(n).is("blockquote") && !$(n).is("div") && !bld.context.current("list") && !isList(n)) {
			bld.control("li" + (bld.context.current("blockquote") * 600));
			bld.context.pending("blockquote", false);
		}
		if (n.nodeType === 3) { // TEXT node
			bld.text(n.nodeValue);
			bld.context.par = false;
			if (n.nextSibling && $(n.nextSibling).is("blockquote")) {
				bld.control("par");
			}
		} else if ($(n).is("*[style]") && !$(n).is("blockquote")) {
			var rules = $(n).attr('style').split(';');
			var drill = !(($(n).attr('style').search("text-align") > -1) && ($(n).attr('style').search("margin-left") > -1)),
				tal = null;
			if (n.nodeName == "B") {
				bld.htmltag(n.nodeName);
			}
			rules.forEach(function(e) {
				var stylerule = e.split(':');
				if (stylerule[0] != null) stylerule[0] = stylerule[0].replace(/^\s*/, '').replace(/\s*$/, '');
				if (stylerule[1] != null) stylerule[1] = stylerule[1].replace(/^\s*/, '').replace(/\s*$/, '');
				switch (stylerule[0]) {
					case 'color':
						if (stylerule[1].substring(0, 3) === 'rgb') {
							clr = rgbColor(stylerule[1]);
							idx = findColor(documentModel.colors, clr);
						} else {
							idx = findColorInColortbl(stylerule[1]);
						}

						colorid = "cf";
						bld.controlarg(colorid, idx);
						break;

					case 'background-color':
						if (stylerule[1].substring(0, 3) === 'rgb') {
							clr = rgbColor(stylerule[1]);
							idx = findColor(documentModel.colors, clr);
						} else {
							idx = findColorInColortbl(stylerule[1]);
						}

						colorid = "highlight";
						bld.controlarg(colorid, idx);
						break;

					case 'text-decoration':
						if (stylerule[1] === 'underline') bld.control('ul');
						else if (stylerule[1] === 'line-through') bld.control('strike');
						break;
					case 'font-style':
						if (stylerule[1] === 'italic') bld.control('i');
						break;
					case 'font-weight':
						if (stylerule[1] === 'bold') bld.control('b');
						break;

					case 'font-size':
						var tmp = $(n).attr("style");
						var m = /([0-9\.\-]+)([A-Za-z]*)/g.exec(stylerule[1]),
							unit = m[2] && m[2].toLowerCase();
						//console.log(unit)
						if (unit != "em") {
							var points = parseFloat(stylerule[1]);
							var halfpoints = Math.round(points * 2);
							bld.controlarg("fs", halfpoints);
							bld.context.fs = true;
						}
						break;
					case 'margin-left':
						var m = /([0-9\.\-]+)([A-Za-z]*)/g.exec(stylerule[1]),
							unit = m[2] && m[2].toLowerCase() || "px",
							val = parseInt(m[1], 10);
						if ($(n).is("ul")) {
							bld.context.ulindent = val / 40;
							bld.context.open("list");
						} else if ($(n).is("div") || $(n).is("p")) {
							bld.context.open("lindent");
							bld.context.value("lindent", val);
							bld.controlarg(tagMap[stylerule[0]], toTwips(unit, bld.context.value("lindent")));
							//bld.context.pending("lindent",false)
							if (tal) {
								bld.control(align[tal]);
							}
						};
						if (drill) {
							$(n).contents().each(visit);
							if (n.nodeName === "P") {
								bld.context.close("lindent");
								bld.control("par");
							} else if (n.nodeName === "DIV") {
								bld.context.close("lindent");
							};
							if (bld.context.current("lindent")) {
								bld.controlarg(tagMap[stylerule[0]], toTwips(unit, bld.context.value("lindent")));
							} else {
								bld.control("pard");
							}
							//bld.context.pending("lindent",false)
						};
						drill = true;
						break;
					case 'margin-right':
					case 'margin-top':
					case 'margin-bottom':
						var m = /([0-9\.\-]+)([A-Za-z]*)/g.exec(stylerule[1]),
							unit = m[2] && m[2].toLowerCase() || "px",
							val = parseInt(m[1], 10);
						bld.controlarg(tagMap[stylerule[0]], toTwips(unit, val));
						$(n).contents().each(visit);
						if (n.nodeName === "P") {
							bld.control("par");
						}
						bld.control("pard");
						break;
					case 'margin':
						$(n).contents().each(visit);
						if (n.nodeName === "P") {
							bld.control("par");
						}
						break;
					case 'text-align':
						if (drill) {
							bld.control("pard");
							var alignment = stylerule[1];
							bld.control(align[alignment]);
							$(n).contents().each(visit);
							bld.control("par");
							bld.control("pard");
						} else {
							tal = stylerule[1];
						}
						drill = true;
						break;
				}
			});
		} else if ($(n).is("font")) {
			if ($(n).is("font[face]")) {
				var face = $(n).attr("face");
				bld.font(findFont(face));
			}
			if ($(n).is("font[color]")) {
				idx = findColorInColortbl($(n).attr("color"));
				colorid = "cf"; //+ idx;
				bld.controlarg(colorid, idx);
			}
			if ($(n).is("font[bgcolor]")) {
				idx = findColorInColortbl($(n).attr("bgcolor"));
				colorid = "highlight"; //+ idx; //"cb"+(idx);
				bld.controlarg(colorid, idx);
			}
			//Even if "SIZE" attribute of "FONT" html tag is obsolete, when copy/paste from Word document, attribute could be present.
			if ($(n).is("font[size]")) {
				idx = findFontSize($(n).attr("size"));
				bld.controlarg("fs", idx);
			}
		} else if ($(n).is("div[align]")) {
			var alignment = $(n).attr("align");
			bld.control("pard");
			bld.control(align[alignment]);

			$(n).contents().each(visit);
			if (!(n.childElementCount > 0 && n.firstChild.nodeName === "P")) {
				bld.control("par");
			}
			bld.control("pard");
		} else if (n.nodeName === "UL") {
			bld.control("pard");
			bld.context.open("list");
		} else if (n.nodeName === "LI") {
			bld.fragment("{\\pntext");
			bld.font(findFont("Symbol"));
			bld.fragment("\\'B7\\tab}");
			if (bld.context.pending("list")) {
				var uls = bld.context.current("list") + bld.context.current("blockquote") + bld.context.ulindent;
				uls = uls + bld.context.current("lindent");
				bld.fragment("{\\*\\pn\\pnlvlblt\\pnf1\\pnindent0{\\pntxtb\\'B7}}\\f0\\li" + (uls * 420));
				bld.context.ulindent = 0;
				bld.context.pending("list", false);
			}
		} else if (n.nodeName === "P") {
			bld.control("par");
		} else {
			bld.htmltag(n.nodeName);
		}
	}

	function parseColor(color) {
		var match = /#(..)(..)(..)/.exec(color) || /#(..)(..)(..)/.exec(colourNameToHex(color));
		return match && match.slice(1).map(function(v) {
			return parseInt(v, 16);
		});
	}

	function findColorInColortbl(colorstr) {
		var parsedclr = parseColor(colorstr);
		/*if (parsedclr[0]==0 && parsedclr[1]==0 && parsedclr[2]==0)
			return 0 ;*/
		var idx = findColor(documentModel.colors, parsedclr);
		if (idx == -1) return -1;
		else return idx;
	}

	function findFontSize(size) {
		size = parseInt(size, 10);
		if (size < 0 || size > 7) return 0;
		return [0, 18, 20, 24, 28, 36, 48, 72][size];
	}

	function scan(n) {
		if (!n) return;
		n.each(visit);
	}

	function processColor(coln, atb) {
		coln.each(function(i, e) {
			var tmp = $(e).attr(atb);
			var rgb = parseColor(tmp);
			if (rgb && findColor(documentModel.colors, rgb) == -1) {
				documentModel.colors.push(rgb); /*(rgb[0]!=0 || rgb[1]!=0 || rgb[2]!=0) &&*/
			}
		});
	}

	function processColorStyle(coln) {
		var clr, idx;
		coln.each(function(i, e) {
			var s = $(e).attr("style"),
				styles = s && s.replace(/[\n\r]*\s*/g, '').split(';'),
				colorstyles = styles && styles.filter(function(e) {
					var rule = e.split(':');
					rule[0] = rule[0].replace(/^\s*/, '').replace(/\s*$/, '');
					return ['color', 'background-color', 'background'].indexOf(rule[0]) != -1;
				});

			var stylerule = colorstyles && colorstyles[0] && colorstyles[0].split(':');
			if (stylerule && stylerule[1]) {
				stylerule[1] = stylerule[1].replace(/^\s*/, '').replace(/\s*$/, '');
				if (stylerule[1].substring(0, 3) === 'rgb') {
					clr = rgbColor(stylerule[1]);
					idx = findColor(documentModel.colors, clr);
				} else {
					idx = findColorInColortbl(stylerule[1]);
					clr = parseColor(stylerule[1]);
				}
				if (idx == -1) {
					clr && documentModel.colors.push(clr);
				}
			}
		});
	}

	function extractFontsAndColors() {
		var fnts = $root.find('font[face]');
		var clrs = $root.find('font[color]');
		var bgclrs = $root.find('font[bgcolor]');
		var stylebgclrs = $root.find('*[style*="background-color"]');
		var styleclrs = $root.find('*[style*="color"]');
		addFont("MS Sans Serif"); //default
		fnts.each(function(i, e) {
			addFont($(e).attr("face"));
		});
		// For bullets
		if ($root.find("ul").length > 0) {
			addFont("Symbol");
		}

		// {\\f1\\fnil\\fcharset2 Symbol;		}
		/*if (documentModel.colors.length==0)
			documentModel.colors.push([0,0,0]) ;*/
		processColor(clrs, "color");
		processColor(bgclrs, "bgcolor");
		processColorStyle(stylebgclrs);
		processColorStyle(styleclrs);
	}

	function rgbColor(colorString) {
		var match = /\s*rgb\(\s*(\d+),\s*(\d+),\s*(\d+)\s*\);*/.exec(colorString);
		if (!match) return [];
		return match.slice(1).map(function(elt) {
			return parseInt(elt, 10);
		});
	}

	function visit(i, e) {
		var $e = $(e),
			$contents;
		//	    console.log("visit >>>>>>>>" + ((e.nodeType!==3)?e.nodeName:e.nodeValue) + " " + (e.id?e.id:""))
		if ($e.is("blockquote")) {
			bld.context.open("blockquote");
		} else if ($e.is("div[align]") || ($e.is('*[style*=text-align]') || $e.is('*[style*=margin]'))) {
			//console.log("div align || text-align || margin")
			processNode(e, i);
			if (e.nodeName === "UL" /*|| $e.is('div[style*=margin]')*/ ) {
				bld.control("pard");
			}
			return;
		}

		var grp, nl, sibling = e.nextSibling,
			crlf = (e.nodeName === "P" && e.childElementCount === 1 && e.firstChild.nodeName === "BR") //in somme case,on enter,  Chrome  can  build br in p;
		$contents = $e.contents();
		if (!$e.is("blockquote") && sibling && sibling.nodeName === "DIV" && !isLeftIndent(e) && !isLeftIndent(sibling)) {
			if (!(sibling.childElementCount > 0 && (sibling.firstChild.nodeName === "BR" || sibling.firstChild.nodeName === "P")) && !crlf) {
				nl = true;
			}
		} else if ($contents.length > 0 && sibling && !$e.is("ul") && !$e.is("li") && !$e.is("blockquote") && !$e.is("p")) {
			grp = true;
			bld.fragment("{");
		}
		if ($e.is("p[align]")) {
			var alignment = $e.attr("align");
			bld.control("pard");
			bld.control(align[alignment]);
		}
		if (!$e.is("p")) {
			processNode(e, i);
		}
		/*if (e.nodeName === "UL") {
			bld.control("pard");
		}*/
		$contents.each(visit);
		if (e.nodeName === "P" && !nl && !crlf) {
			processNode(e, i);
		}
		if (e.nodeName === "B" || $e.is('*[style*=font-weight]')) {
			bld.control("b0");
		}
		if (e.nodeName === "U" || $e.is('*[style*=text-decoration]')) {
			bld.control("ul0");
		}
		if ($e.is('*[style*=font-size]') && bld.context.fs) {
			bld.context.fs = false;
			if (!grp) {
				bld.control("fs16");
			}
		}
		if (e.nodeName === "I" || $e.is('*[style*=font-style]')) {
			bld.control("i0");
		}
		if ($e.is('*[style*=color]') && !$e.is('*[style*=background-color]') && !grp) {
			bld.control("cf0");
		}
		if (e.nodeName === "UL") {
			bld.context.close("list");
			bld.control("pard");
			bld.context.par = true;
			if (bld.context.current("blockquote")) {
				bld.context.pending("blockquote", true);
			}
			if (bld.context.current("lindent") && e.nextSibling && e.nextSibling.nodeType === 3) {
				bld.control("li" + toTwips("px", bld.context.value("lindent")));
			}
		} else if ($e.is("li")) {
			bld.control("par");
		}

		if (grp) {
			bld.fragment("}");
		}
		if ($e.is("blockquote") && bld.context.current("blockquote")) {
			if (bld.context.pending("blockquote")) {
				bld.context.close("blockquote");
				if (!bld.context.current("blockquote") && sibling && !$(sibling).html()) {
					bld.context.nl = true;
				}
			} else {
				if (!bld.context.par) {
					bld.control("par");
				}
				bld.control("pard");
				bld.context.close("blockquote");
			}
		}
		if (nl || bld.context.nl) {
			bld.context.nl = false;
			bld.control("par");
		}
	}

	function createFontTable() {
		var fname;
		for (var i = 0; i < rtffonts.length; i++) {
			fname = "f" + i;
			documentModel.fonts[fname] = {
				name: rtffonts[i]
			};
		}
	}

	documentModel.colors.push([0, 0, 0]);
	extractFontsAndColors();
	createFontTable();
	bld = builder(documentModel);
	//bld.header() ;
	//console.log("buildRtf --->"+$root.html());
	scan($root);

	bld.close();
	var rtftxt = bld.getRtf();
	//console.log("buildRtf --->"+rtftxt);
	return rtftxt;
};
});

define('syracuse-tablet/html/js/helpers/syracuse-rtf/lib/index',['require','exports','module','./rtfparse','./rtfinterpret','./buildhtml','./buildrtf'],function (require, exports, module) {
var rtfParser = require("./rtfparse"),
	rtfInterpreter = require("./rtfinterpret"),
	htmlBuilder = require("./buildhtml"),
	rtfBuilder = require("./buildrtf");

/// !doc
/// # RTF converter
/// Helper functions to convert RTF text from and to HTML.
/// 
/// `var convert = require('@sage/rtf-converter');`  
/// `var html = convert.toHtml(rtf, options);`  
/// `var rtf = convert.fromHtml(html, options);`  
// will see about options later
module.exports = {
	toHtml: function(rtf, options) {
		rtf = rtf || "";
		var root = rtfParser.parse(rtf);
		var model = rtfInterpreter.interpret(root);
		return htmlBuilder.buildHtml(root, model);
	},
	fromHtml: function(html, options) {
		return rtfBuilder.buildRtf(html);
	}
};
});

define('syracuse-tablet/html/js/helpers/syracuse-rtf/index',['require','exports','module','./lib/index'],function (require, exports, module) {
module.exports = require('./lib/index');
});

define('syracuse-tablet/html/js/controls/fields/ctrlText',['require','exports','module','syracuse-tablet/html/js/controls/fields/ctrlFieldBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/sdata/sdataRequester','syracuse-tablet/html/js/helpers/html-escape/index','syracuse-tablet/html/js/helpers/syracuse-rtf/index'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/fields/ctrlFieldBase').CtrlFieldBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var sdataRequester = require('syracuse-tablet/html/js/sdata/sdataRequester');
var escaper = require('syracuse-tablet/html/js/helpers/html-escape/index').escaper({
	warn: console.warn.bind(console),
	allowedAttributes: ["style"],
	allowedTags: ["span"]
});
var rtf = require('syracuse-tablet/html/js/helpers/syracuse-rtf/index');

var _baseHeight = 34; // based on input height within the app

exports.CtrlText = utils.defineClass(
	function CtrlText(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		Base.call(this, controller, article, prototype, options);
		this.cssType = "s-m-clob s-m-" + this.$type.replace("/", "-");
	}, Base, {
		destroy: function() {
			$(this.$$input).off('keyup input');
			Base.prototype.destroy.call(this);
		},
		_getHeightPixelValue: function(authH) {
			switch (authH) {
				case "medium":
					return 2 * _baseHeight;
				case "large":
					return 4 * _baseHeight;
				case "xlarge":
					return 8 * _baseHeight;
				default:
					return _baseHeight;
			}
		},
		buildFieldValue: function() {
			var self = this;
			self._ensure$$value();
			self._clear$$value();
			// dom element which will contain the text
			// enriched text container div
			var $$container = $('<section><div class="s-m-enriched-text"></div></section>').appendTo(self.$$value).children(":first-child");

			// dom element which will contain the text
			var $$textContent = $(uiUtils.createDomElement("div", ["s-m-enriched-text-content"], null, null, $$container));

			/**
			 * !!! It's mandatory to have a fixed height for $$container because we need it to calculate the height of the page
			 * If no height is specified it will be set after the data has been loaded (too late)
			 */
			self.authH = self.getAuthoring("$textHeight", "medium");
			self.authH = self._getHeightPixelValue(self.authH);

			var $url = self.controller.getLazyUrl(self.$bind);
			sdataRequester.getLazyPropData($url, self.prototype.json, self.$type).
			then(function(data) {
				var content = data;
				self.setValue(content);
				var empty = (content == null || content.length === 0) && !self.$isEditMode;
				self.$$elmt.toggleClass("s-m-empty", empty);
				// put text content
				var $$dataArr = [];
				switch (self.$type) {
					case "text/plain":
						self._buildFieldFromPlain(content, $$textContent);
						break;
					case "text/html":
						self._buildFieldFromHtml(content, $$textContent);
						break;
					case "text/rtf":
						self._buildFieldFromRtf(content, $$textContent);
						break;
				}
				/*
				 *	Set text-content height so that line of text is not half cut.
				 *	We use text line-height css property value
				 */
				var lineheight = parseInt($$textContent.css("line-height").replace("px", ""), 10);
				var multiplier = Math.floor(self.authH / lineheight);
				self.computedHeight = lineheight * multiplier;

				$$textContent.css({
					height: self.computedHeight + "px"
				});
				self._appendExpander($$textContent);
			}).fail(function(e) {
				self._insertError(e.message);
			});;
		},

		_buildFieldFromPlain: function(data, $$parent) {
			var self = this;
			if (this.$isEditMode) {
				self.createMainInput(data, "textplain", {
						"wrap": "soft",
						"spellcheck": false,
						"autocorrect": "off",
						"autocomplete": "off",
						"style": "overflow-y:hidden;box-size:border-box;resize:none;width:100%;height:100%",
						"row": "2"
					},
					$$parent);
				this.$$input.val(data);
				this.$$input.on('keyup input', function() {
					self._triggerResizeInput();
				});
			} else {
				$$parent.append($.parseHTML(escaper(data.replace(/\n/g, "<BR/>"))));
			}
		},
		_buildFieldFromHtml: function(data, $$parent) {
			$$parent.append($.parseHTML(escaper(data)));
		},
		_buildFieldFromRtf: function(data, $$parent) {
			this._buildFieldFromHtml(rtf.toHtml(data), $$parent);
		},
		_triggerResizeInput: function() {
			var triggerResize = false;
			if (this.$$expander && this.$$expander.attr("data-params") === "more") {
				this._expandText(this.$$input.parent());
				triggerResize = true;
			};
			this._resizeInput();
			if (triggerResize) {
				uiUtils.triggerResizeInternal({
					preserveScroll: true
				});
			}
		},
		_resizeInput: function(options) {
			if (!this.$$input) return false;
			this.$$input.parent().css('height', 'auto');
			this.$$input.css('height', 'auto');
			var domElmt = this.$$input.get(0);
			var height = (options && options.height != null) ? options.height : (domElmt.scrollHeight + (domElmt.offsetHeight - domElmt.clientHeight));
			this.$$input.css('height', height);
			return false;
		},
		_expandText: function($textContent) {
			$textContent.css({
				height: "auto"
			});
			this.$$expander.toggleClass(fontUtils.getIconByName("expand"), false);
			this.$$expander.toggleClass(fontUtils.getIconByName("compress"), true);
			this.$$expander.attr("data-params", "less");
		},
		_compressText: function($textContent) {
			$textContent.css({
				height: this.computedHeight + "px"
			});
			this.$$expander.toggleClass(fontUtils.getIconByName("compress"), false);
			this.$$expander.toggleClass(fontUtils.getIconByName("expand"), true);
			this.$$expander.attr("data-params", "more");
		},
		/*
		 * Toggle enriched text. It will either show more or hide
		 */
		_actToggleText: function(param) {
			// show whole text field
			// change button label
			var $textContent = this.$$input ? this.$$input.parent() : this.$$elmt.find(".s-m-enriched-text-content");
			if (param === "more") {
				this.currentHeight = null;
				this._expandText($textContent);
				this._resizeInput();
			}
			// decrease text field height
			else {
				this._compressText($textContent);
				this._resizeInput({
					"height": "100%"
				});
			}
			uiUtils.triggerResizeInternal({
				preserveScroll: true
			});
		},


		/**
		 * Display an error
		 */
		_insertError: function(msg) {
			var err = ['<span class="s-m-error"><p>'];
			err.push(msg);
			err.push("<p></span>");
			$(err.join('')).appendTo(this.$$elmt);
		},
		/*
		 *	Append an expander button for the text field.
		 *	Button is appended only if full text height (scrollheight) is higher than self.authH by at least 5px
		 */
		_appendExpander: function($$container) {
			var self = this;
			var scrollHeight = self.$$input ? self.$$input.scrollHeight : $$container.get(0).scrollHeight;
			if (scrollHeight > self.computedHeight && ((scrollHeight - self.computedHeight) > 5)) {

				// build expander button
				var buttonTmpl = '<a href="#" class="' + fontUtils.getIconByName("expand") + '" data-nevent data-naction="toggleText"\
				data-control-id="' + self.id + '" data-params="more"></a>';
				var $$expander = self.$$expander = $(buttonTmpl);

				// append the button
				$$expander.insertBefore($$container);

				$$expander.css("float", "right");

				$$expander.wrap("<div class='s-m-enriched-text-expander'></div>");

				$$expander.parent().height($$expander.outerHeight());
			}
		}
	});
});

define('syracuse-tablet/html/js/controls/fields/ctrlDocument',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/fields/ctrlFieldBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/fields/ctrlFieldBase').CtrlFieldBase;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

/**
 * Binary and document field. For moment quite same later ???
 * authoring:
 * 		$imgHeight	set the height of the image - xsmall, small...
 */
exports.CtrlDocument = utils.defineClass(

	function CtrlDocument(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		Base.call(this, controller, article, prototype, options);
		// Add cssType in root element
		this.cssType = "s-m-document";
	}, Base, {

		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			this.$$layout = null;
		},

		applyMetaData: function(metaData, buildOptions) {
			Base.prototype.applyMetaData.call(this, metaData, buildOptions);
			if (this.$isEditMode && this.$$layout) {
				var disabled = metaData ? metaData.$isReadOnly || metaData.$isDisabled : false;
			}
		},

		buildFieldValue: function() {
			this._ensure$$value();
			this._clear$$value();
			var docUrl = this.controller.getValue(this.$bind) || "";
			docUrl = docUrl && (docUrl + '?salt=' + ((new Date()).getTime()));

			var empty = docUrl.length === 0;
			if (empty) {
				this.$$value.addClass("s-m-empty");
			} else {
				var classcss = ["img-responsive", this._getIcon()];
				var e = uiUtils.createDomElement("span", classcss, null, {
					"href": "#",
					"data-nevent-ctrl-click": ""
				}, this.$$value);
			}
		},
		onClick: function(evt) {
			var dom = evt.target.parentNode;
			var parentDom;
			this._openDocument();
		},
		_openDocument: function() {
			var docUrl = this.controller.getValue(this.$bind) || "";
			var empty = docUrl.length === 0;
			if (!empty) {
				window.open(docUrl, "_blank");
			}
		},
		_getIcon: function() {
			return fontUtils.documentFieldIcon();
		}
	});

exports.CtrlBinary = utils.defineClass(
	function CtrlBinary(controller, article, prototype, options) {
		var self = this;
		exports.CtrlDocument.call(self, controller, article, prototype, options);
		self.cssType = "s-m-binary";
	}, exports.Document, {
		_getIcon: function() {
			return fontUtils.binaryFieldIcon();
		},
	});
});

define('syracuse-tablet/html/js/controls/ctrlTypeUnknown',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').CtrlBase;
var utils = require('syracuse-tablet/html/js/helpers/utils');

exports.CtrlTypeUnknown = utils.defineClass(
	function CtrlTypeUnknown(controller, article, prototype, options) {
		Base.call(this, controller, "application/x-unknown", article, options);
		this.prototype = prototype;
	}, Base, {
		buildHtml: function() {
			var classes = ["s-m-control", "s-m-unknown", "s-m-ctrl"];
			this.createRootElement(classes);
			var $type = this.prototype.data("$type");
			var bind = (this.article.$bind ? this.article.$bind : "unknown");
			this.$$elmt.html('<div class="s-m-value">Field ' + bind + ' - ' + ($type ? "Unknown type[" + $type + "]" : "Empty $type") + '</div>');
		}
	});
});

define('syracuse-tablet/html/js/app/settings',['require','exports','module','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/storage/storage'],function (require, exports, module) {

var modules = require('syracuse-tablet/html/js/common/modules');
var storageModule = require('syracuse-tablet/html/js/storage/storage');

var _storage;

function _getStorage() {
	if (!_storage) {
		_storage = modules.get("storage").getStorage();
	}
	return _storage;
};

var _globalCtx = {
	"$user": "none",
	"$role": "none",
	"$lang": "none"
};

/**
 * Get the user profile that was used to login lately
 */
exports.getLastUsedUserProfile = function() {
	return _getStorage().read({
		$context: _globalCtx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: "$last_user_profile"
	}).then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			return result.$data;
		} else {
			return null;
		}
	});
}

/**
 * Get the user profile that was used to login lately
 */
exports.setLastUsedUserProfile = function(userProfile) {
	return _getStorage().put({
		$context: _globalCtx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: "$last_user_profile",
		$data: userProfile
	}).then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			return result.$data;
		} else {
			return null;
		}
	});
}
exports.removeLastUsedUserProfile = function() {
	if (!_globalCtx) return $.smResolve();
	return _getStorage().remove({
		$context: _globalCtx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: "$last_user_profile"
	});
};

exports.setLoginRememberMe = function(rememberMe) {
	return $.smResolve()
		.then(function() {
			return _getGlobalSettings();
		})
		.then(function(settings) {
			settings.rememberMe = rememberMe
			return _setGlobalSettings(settings);
		});
}

exports.getLoginRememberMe = function() {
	return $.smResolve()
		.then(function() {
			return _getGlobalSettings();
		})
		.then(function(settings) {
			return settings.rememberMe === true;
		});
}
exports.setDeviceType = function(deviceType) {
	return $.smResolve()
		.then(function() {
			return _getGlobalSettings();
		})
		.then(function(settings) {
			settings["device-type"] = deviceType
			return _setGlobalSettings(settings);
		});
}
exports.getDeviceType = function() {
	return $.smResolve()
		.then(function() {
			return _getGlobalSettings();
		})
		.then(function(settings) {
			return settings["device-type"] || "auto"
		});
}

function _getGlobalSettings() {
	return _getStorage().read({
		$context: _globalCtx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: "$global_settings"
	}).then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			return result.$data;
		} else {
			return {};
		}
	});
}

function _setGlobalSettings(settings) {
	return _getStorage().put({
		$context: _globalCtx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: "$global_settings",
		$data: settings
	}).then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			return result.$data;
		} else {
			return {};
		}
	});
}
/**********************************************
 * User page preferences
 */
exports.readUserPagePrefs = function(pageId) {
	var defRes = {
		favorites: []
	}
	if (pageId == null) {
		return $.smResolve(defRes)
	}
	var cc = modules.get("appController").App.getCacheContext();
	var storage = _getStorage();
	var ctx = {
		"$user": cc.$user,
		"$role": "none",
		"$lang": "none"
	};
	return storage.read({
		$context: ctx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: pageId
	}).then(function(result) {
		var res;
		if (result.$status === storageModule.StatusCodes.OK) {
			res = result.$data;
		}
		res = res || defRes;

		// Filter and sort favorites default
		res.favorites = res.favorites || [];
		// Also in these object with null as default are: 
		// res.filter - current filter
		// res.sort - current sort opts
		// res.chartDetail - [0...n] chart detail levels
		return res;
	});
}
exports.writeUserPagePrefs = function(pageId, prefs) {
	if (pageId == null) {
		return $.smResolve()
	}
	var storage = _getStorage();
	var cc = modules.get("appController").App.getCacheContext();
	var ctx = {
		"$user": cc.$user,
		"$role": "none",
		"$lang": "none"
	};
	return exports.readUserPagePrefs(pageId)
		.then(function(oldPrefs) {
			// No extend because of null values must be taken into account and like this it's more clear what's in the settings
			if ('favorites' in prefs) {
				oldPrefs.favorites = prefs.favorites;
			}
			if ('filter' in prefs) {
				oldPrefs.filter = prefs.filter;
			}
			if ('sort' in prefs) {
				oldPrefs.sort = prefs.sort;
			}
			if ('chartDetail' in prefs) {
				oldPrefs.chartDetail = prefs.chartDetail;
			}
			if ('search' in prefs) {
				oldPrefs.search = prefs.search;
			}
			return oldPrefs;
		})
		.then(function(newPrefs) {
			return storage.put({
				$context: ctx,
				$collection: "$settings",
				$endpoint: "$local",
				$key: pageId,
				$data: newPrefs
			});
		});
}
exports.getPagePrefsId = function(pageName, vignette) {
	var id = [pageName];
	if (vignette != null && vignette.page) {
		id.push(vignette.page.pageName);
		id.push(vignette.$bind)
	} else {
		id.push("fullpage");
	}
	return id.join("-");
}
});

define('syracuse-tablet/html/js/controllers/sdataController',['require','exports','module','syracuse-tablet/html/js/controllers/controller','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/sdata/sdataRequester','syracuse-tablet/html/js/sdata/protocolHelpers','syracuse-tablet/html/js/helpers/environment','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/sdata/protocolHelpers','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var Base = require("syracuse-tablet/html/js/controllers/controller").Controller;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var sdataReq = require("syracuse-tablet/html/js/sdata/sdataRequester");
var protocolHelpers = require("syracuse-tablet/html/js/sdata/protocolHelpers");
var environment = require('syracuse-tablet/html/js/helpers/environment');
var modules = require('syracuse-tablet/html/js/common/modules');
var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');
var locale = require('syracuse-tablet/html/js/helpers/locale');


var _isServiceLink = function($link) {
		if (!$link) {
			return false;
		}
		return $link.$url.indexOf("$services") >= 0 || $link.$method === "DELETE";
	}
	/**
	 * parent can be null (formController)
	 */
exports.SdataController = utils.defineClass(
	function SdataController(dataset, parent, isWorkingCopy) {
		Base.call(this, parent);

		this.controlsByBind = {};

		// This is to hold client side only diagnoses per field that are generated by the widgets
		// E.g. checks on $minValue or $maxLength
		// It's better to hold these information in the controller and not the widgets because
		// widgets should not have non UI state
		this.clientDiagnosesByBind = {};

		this.dataset = dataset;

		this.isWorkingCopy = true; // Default
		if (isWorkingCopy !== undefined) { // Given by parameter?
			this.isWorkingCopy = isWorkingCopy;
		} else if (parent != null) { // Try to set from parent if available
			this.isWorkingCopy = parent.isWorkingCopy;
		}

		this.dataset.addDeltaChangeListener(this);
		this.pendingRequests = 0;
	},
	Base, {

		destroy: function() {
			if (this.destroyed === true) {
				return;
			}
			if (this.dataset) {
				this.dataset.removeDeltaChangeListener(this);
			}

			// Ask server to delete working copy?
			if (this.isWorkingCopy && this.isRoot()) {
				if (this.dataset) {
					// This is async but we do not care about the result, since if it does not work,
					// there is nothing more we can do
					sdataReq.deleteWC(this.dataset);
				}
			}

			if (this.isRoot()) {
				this.dataset.destroy();
			}
			this.dataset = null;
			this.prototype = null;
			this.clientDiagnosesByBind = null;
			Base.prototype.destroy.call(this);
		},

		//
		// CONTROLS START
		//
		registerControl: function(ctrl) {
			Base.prototype.registerControl.call(this, ctrl);
			var $bind = ctrl.$bind;
			if ($bind) {
				var perBind = this.controlsByBind[$bind] = this.controlsByBind[$bind] || [];
				perBind.push(ctrl);
			}
		},
		unregisterControl: function(ctrl) {
			Base.prototype.unregisterControl.call(this, ctrl);
			var $bind = ctrl.$bind;
			if ($bind) {
				var perBind = this.controlsByBind[$bind];
				if (perBind) {
					var idx = perBind.indexOf(ctrl);
					if (idx > -1) {
						perBind.splice(idx, 1);
					}
					if (perBind.length == 0) {
						delete this.controlsByBind[$bind];
					}
				}
			}
		},
		_controlsByBind: function($bind) {
			var c = this.controlsByBind[$bind];
			return c;
		},
		getControlsByBind: function($bind) {
			return this._controlsByBind($bind);
		},
		/**
		 * Used to store client side generated diagnoses for a field inside the controller
		 */
		setClientDiagnoses: function($bind, diags) {
			diags = diags || [];
			// Sometimes we receive string instead of diagnoses (internally) - It's ok to consider strings as errors
			for (var i = 0; i < diags.length; i++) {
				if (typeof diags[i] == "string") {
					diags[i] = {
						"$severity": "error",
						"$message": diags[i]
					}
				}
			}
			this.clientDiagnosesByBind[$bind] = diags;
		},
		/**
		 * Return all diagnoses set for a specific field
		 * Array will be empty or client side diagnoses first, server side diagnoses second
		 */
		getDiagnoses: function($bind) {
			var client = this.clientDiagnosesByBind[$bind] || [];
			var server = this.dataset.getDiagnoses($bind);
			var diags = [];
			Array.prototype.push.apply(diags, client);
			Array.prototype.push.apply(diags, server);
			return diags;
		},
		/**
		 * The purpose if this method is to scan all controls which have client side diagnoses set
		 * If there is a diagnoses, this means the widget may render a different value than the dataset
		 * because the user typed something invalid that violates constraints like "$minValue"
		 */
		findErrornousControls: function() {
			var self = this;
			var errors = [];
			Object.keys(self.clientDiagnosesByBind).forEach(function($bind) {
				var diags = self.clientDiagnosesByBind[$bind];
				if (diags && diags.length > 0) {
					var controls = self.controlsByBind[$bind];
					controls && controls.forEach(function(control) {
						if (!control.validateInput()) {
							errors.push(control);
						}
					});
				}
			});
			return errors;
		},
		//
		// CONTROLS END
		//				

		//
		// SDATA START
		//				

		/**
		 * Called by UI to get a value
		 */
		getValue: function($bind) {
			return this.dataset.getValue($bind);
		},
		/**
		 * Called by UI to set a value
		 * 
		 * $bind: Property for which to set the value
		 * value: value
		 * updateUI: Set to true if UI needs to be update, this can happen if one control sets the value of another one
		 * 
		 */
		setValue: function($bind, value, updateUI, noServerUpdate) {
			this.dataset.setValue($bind, value);

			if (updateUI === true) {
				this.onDeltaValueChanged(this.dataset, $bind);
			}

			if (noServerUpdate !== true) {
				this.root._updateServer($bind)
					.fail(function(result) {
						modules.get("modal").error(result);
					});
			}
		},
		/**
		 * 
		 */
		addRow: function() {
			var row = this.dataset.addRow();
			return this.root._updateServer()
				.then(function() {
					return row;
				});
		},
		/**
		 * 
		 */
		removeRow: function($uuid) {
			this.dataset.removeRow($uuid);
			return this.root._updateServer();
		},
		getLazyUrl: function($bind) {
			return this.dataset.getValue($bind, this.isWorkingCopy);
		},
		/**
		 * Called by UI to get meta data
		 */
		getMetaData: function($bind) {
			return this.dataset.getMetaData($bind);
		},
		/**
		 * Called by UI when an sdata action is clicked
		 */
		triggerAction: function($actionName) {
			var self = this;
			return $.smResolve()
				.then(function() {
					if (!self.dataset.isRoot()) {
						// Actions are only allowed on root level of the representation
						return false;

					}
					var $action = self.dataset.getAction($actionName);
					var $title = $action && $action.$title;
					$title = $title || $actionName;
					$title = self.dataset.resolveExpression($title);

					// Check if there are client side data changes that are not in the dataset yet
					// because of invalid input like too big, mandatory not filled, ...
					// If we fail here, no need to ask the server
					var errorControls = self.findErrornousControls();
					if (errorControls.length > 0) {
						self._showNotification($title, locale.text("action.check.input"), "error");
						return false;
					}

					var resultPromise = $.Deferred();
					self._countRequest(sdataReq.triggerAction($actionName, self.dataset, self.isWorkingCopy))
						.fail(function(response) {
							// We end here if http code is <> 2xx
							var diag = (response.data && response.data.$diagnoses ? response.data : (response.$diagnoses ? response : response));
							if (diag) {
								modules.get("modal").error(diag);
							}
							resultPromise.resolve(false);
						})
						.then(function(response) {
							var delta = response.data;
							if (delta) {
								// If there is a delta sent by the server, we merge it
								// This will add field level diagnoses
								// error checking will be done later independently
								return self._mergeDelta(delta).then(function() {
									return response;
								});
							}
							return response;
						})
						.then(function(response) {
							return protocolHelpers.computeActionResult($actionName, response);
						})
						.then(function(result) {
							// 
							if (result.$diagnose) {
								self._showNotification($title, result.$diagnose.$message, result.$diagnose.$severity);
							}
							if (result.success) {
								// There may be a $redirect link in the actions meta data we could use to navigate to the next page
								// from here
								resultPromise.resolve(true);
							} else {
								// Failed, so do nothing and let user modify data
								resultPromise.resolve(false);
							}
						});
					return resultPromise.promise();
				})
				.always(function() {
					if (environment.isAutoUITestMode()) {
						self._updatePageUpdateCycle();
					}
				});


		},

		/**
		 * Called by UI when a sdata link is clicked
		 */
		triggerLink: function($linkName) {
			var self = this;
			return $.smResolve()
				.then(function() {
					var $link = self.dataset.getLink($linkName);
					if (!$link) {
						return;
					}

					// Check if the links is a link to a dashboard with parameters in V11 syntax and convert it to a valid one
					// return input if it's any other url
					$link = protoHelpers.transformOldDashboardUrl($link, self.dataset);

					return self.openLink($link, null, null, $linkName);
				})
		},

		/**
		 * Trigger navigation to the given link
		 * May switch $url and $method of link depending on protocol to be used (working copy / stateless)
		 */
		openLink: function($link, pageOptions, loadOptions, $linkName) {
			var self = this;
			$link = protocolHelpers.adjustLinkProtocol($link, this._getUsedProtocol());

			function _openLink() {
				var $url = self.dataset.resolveExpression($link.$url, true);
				if (!$url) {
					return $.smResolve();
				}
				if (_isServiceLink($link)) {
					return self._executeLink($linkName, $url, $link.$method);
				} else {
					$url = protoHelpers.addClientContext($url, self.dataset.root.json.$clientContext);
					return self.gotoUrl($url, $link.$method, pageOptions, loadOptions);
				}
			}
			if ($link.$confirm) {
				return self._askConfirmation($link.$confirm)
					.then(function(confirmed) {
						if (confirmed === "yes") {
							return _openLink();
						}
					});
			} else {
				return _openLink();
			}
		},
		/**
		 * Used to managed DELETE links which are more like actions
		 */
		_executeLink: function($linkName, $url, $method) {
			var self = this;

			var $link = self.dataset.getLink($linkName);
			var $title = $link && $link.$title;
			$title = self.dataset.resolveExpression($title);
			$title = $title || $linkName;

			var resultPromise = $.Deferred();

			self._countRequest(sdataReq.executeLink($url, $method, self.dataset))
				.fail(function(response) {
					// We end here if http code is <> 2xx
					if (response && response.$diagnoses) {
						var diag = response.$diagnoses[0];
						self._showNotification($title, diag.$message, "error");
					}
					resultPromise.resolve(false);
				})
				.then(function(response) {
					if (response.data && response.data.$diagnoses) {
						var diag = response.data.$diagnoses[0];
						self._showNotification($title, diag.$message, diag.$severity);
					}
					resultPromise.resolve(true);
				});

			return resultPromise.promise();
		},
		triggerDrillLevel: function(level, rowDataset) {
			if (rowDataset.getLink("$drillDown")) {
				this.drillDownLink(level, rowDataset)
			} else if (rowDataset.getLink("levelUp")) {
				this.levelUpLink(level, rowDataset)
			}
		},
		drillDownLink: function(level, dataset) {
			// when drill is called from array, the dataset of the row is this.dataset
			// else the dataset is the parameter ( see getChartClickHandler in builderChart)
			var rowDataset = dataset || this.dataset
			var $link = rowDataset.getLink("$drillDown");
			if (!$link || !$link.$url) return null
			var $url = rowDataset.resolveExpression($link.$url);

			this.gotoUrl($url, null, {
				isChild: false,
				context: {
					controllerId: this.id
				},
				isChartDetail: true,
				level: level + 1
			});
		},
		levelUpLink: function(level, dataset) {
			var rowDataset = dataset || this.dataset
			var $link = rowDataset.getLink("levelUp");
			if (!$link || !$link.$url) return null
			var $url = protoHelpers.getHostPort() + rowDataset.resolveExpression($link.$url);

			this.gotoUrl($url, null, {
				isChild: false,
				context: {
					controllerId: this.id
				},
				isChartDetail: true,
				level: level + 1
			});
		},
		/**
		 * 
		 */
		_updateServer: function($bind) {
			var self = this;
			return $.smResolve()
				.then(function() {
					if (!self.isWorkingCopy) {
						return $.smResolve();
					}
					if (!self.isRoot()) {
						return $.smResolve();
					}
					if (!self.dataset.isDirty()) {
						return $.smResolve();
					}
					return self._countRequest(sdataReq.updateServer(self.dataset, $bind))
						.then(function(response) {
							return self._mergeDelta(response.data);
						})
				})
				.always(function() {
					if (environment.isAutoUITestMode()) {
						self._updatePageUpdateCycle();
					}
				});
		},

		_updatePageUpdateCycle: function() {
			var $$page = $('.s-m-page[data-controller-id="' + this.id + '"]');
			environment.getUnitTestMgr().setPageUpdateCycle($$page);
		},

		/**
		 * 
		 * Merge delta into local dataset and notify affected widgets on changes
		 * Returns delta given to this function so chaining is possible
		 */
		_mergeDelta: function(delta) {
			this.dataset.applyDelta(delta);
			if (this.isRoot() && this.uiAdapter) {
				this.uiAdapter.notifyScrollerUpdate();
			}
			return $.smResolve(delta);
		},

		//
		// SDATA END
		//		
		/**
		 * 
		 * @param promise
		 */
		_countRequest: function(promise) {
			var self = this;
			self.pendingRequests = self.pendingRequests + 1;
			self._updateRequestCount(self.pendingRequests);
			return promise.always(function(result) {
				self.pendingRequests = self.pendingRequests - 1;
				self._updateRequestCount(self.pendingRequests);
				return result;
			});
		},

		//
		// DELTA MANAGEMENT START		
		//				

		/**
		 * Used by dataset delta listeners to signal value changes
		 * dataset must be this.dataset, only passed to function for flexibility reasons 
		 */
		onDeltaValueChanged: function(dataset, $bind) {
			var ctrls = this._controlsByBind($bind);
			if (ctrls) {
				for (var ii = 0, jj = ctrls.length; ii < jj; ii++) {
					var ctrl = ctrls[ii];
					ctrl.onValueChanged && ctrl.onValueChanged();
				}
			}
		},
		/**
		 * Used by dataset delta listeners to signal meta data changes
		 * dataset must be this.dataset, only passed to function for flexibility reasons
		 */
		onDeltaMetaChanged: function(dataset, $bind) {
			var ctrls = this._controlsByBind($bind);
			if (ctrls) {
				for (var ii = 0, jj = ctrls.length; ii < jj; ii++) {
					var ctrl = ctrls[ii];
					ctrl.onMetaChanged && ctrl.onMetaChanged();
				}
			}
		},
		/**
		 * Used by dataset delta listeners to signal rows have been added to array
		 * dataset must be this.dataset, only passed to function for flexibility reasons 
		 */
		onDeltaRowAdded: function(dataset, $bind, $uuid, idx) {
			if (this.uiAdapter && jsutils.isInstanceOf(this.uiAdapter, "CtrlArray")) {
				this.uiAdapter.onDeltaRow("added", dataset, $uuid, idx);
			}
		},
		/**
		 * Used by dataset delta listeners to signal rows have been removed on array
		 * dataset must be this.dataset, only passed to function for flexibility reasons
		 */
		onDeltaRowRemoved: function(dataset, $bind, $uuid, idx) {
			if (this.uiAdapter && jsutils.isInstanceOf(this.uiAdapter, "CtrlArray")) {
				this.uiAdapter.onDeltaRow("removed", dataset, $uuid, idx);
			}
		},
		/**
		 * Called when a row has moved
		 * Note that this will be called in the order of the smallest target row first
		 * So the UI can always remove the row from it's current position and move it to the new one
		 * All later notifications will have an impact on rows with higher new indices only
		 */
		onDeltaRowMoved: function(dataset, $bind, $uuid, newIdx) {
			if (this.uiAdapter && jsutils.isInstanceOf(this.uiAdapter, "CtrlArray")) {
				this.uiAdapter.onDeltaRow("moved", dataset, $uuid, newIdx);
			}
		},
		/**
		 * Used by dataset delta listeners to signal meta data changes for an action
		 */
		onDeltaActionChanged: function(dataset, $action, metaData) {
			this.onMenuItemChanged($action, null, metaData); // Implemented by standard controller to find affected widgets and trigger rendering
		},
		/**
		 * Used by dataset delta listeners to signal meta data changes for a link
		 */
		onDeltaLinkChanged: function(dataset, $link, $bind, metaData) {
			this.onMenuItemChanged($link, $bind, metaData); // Implemented by standard controller to find affected widgets and trigger rendering
		},

		//
		// DELTA MANAGEMENT END		
		//

		//		
		// UI EVENT LISTENER START 
		//

		/**
		 * uiAdapter can implement beforeOnSdataActionClicked/afterOnSdataActionClicked if needed
		 * -> beforeOnSdataActionClicked resolves with goAhead true/false
		 * Eg: Multi-selection action is handled at page level and returns false
		 * -> afterOnSdataActionClicked 
		 * Allows the page to do some job after the action has been executed
		 * Eg: go to detail facet after save...
		 */
		_checkUIAdapterAction: function(actionName, method) {
			var first;
			if (this.uiAdapter && this.uiAdapter.beforeOnSdataActionClicked) {
				first = this.uiAdapter.beforeOnSdataActionClicked(actionName, this);
			} else {
				first = $.smResolve(true, null);
			}
			var self = this;
			return first.then(function(goAhead, beforeContext) {
				//beforeContext is passed from beforeOnSdataActionClicked to afterOnSdataActionClicked
				if (goAhead !== true) {
					return true;
				}
				return method.call(self, actionName).then(function(success) {
					if (self.uiAdapter && self.uiAdapter.afterOnSdataActionClicked) {
						self.uiAdapter.afterOnSdataActionClicked(actionName, success, self, beforeContext);
					}
					return success;
				});
			}).fail(function(result) {
				modules.get("modal").error(result);
			});
		},

		onSdataLinkClicked: function($linkName) {
			if ($linkName === "$edit" || _isServiceLink(this.dataset.getLink($linkName))) {
				// These links are handled like actions
				return this._checkUIAdapterAction($linkName, this.triggerLink);
			}
			// navigation link (details...)
			return this.triggerLink($linkName).fail(function(result) {
				modules.get("modal").error(result);
			});
		},

		onSdataActionClicked: function(actionName) {
			return this._checkUIAdapterAction(actionName, this.triggerAction);
		},

		//		
		// UI EVENT LISTENER END 
		//				

		isEditMode: function() {
			var facet = this.getFacet();
			if (["$edit", "$create"].indexOf(facet) > -1) {
				return true;
			}
			return false;
		},
		getFacet: function() {
			return this.dataset.getRoot().prototype.getFacet();
		},

		/**
		 * Hook a new dataset to current controller
		 * This is used when page data has changed from outside (e.g. pagination or filtering)
		 */
		setDataset: function(dataset) {
			this.dataset.removeDeltaChangeListener(this);
			this.dataset = dataset;
			this.dataset.addDeltaChangeListener(this);
		},

		_getUsedProtocol: function() {
			var rootDataset = this.root.dataset;
			var $mobileProtocol = rootDataset && rootDataset.json.$clientContext && rootDataset.json.$clientContext.$mobileProtocol;
			return $mobileProtocol;
		},

		// Not finalized yet, just a draft that will be used by cancel on row
		// detail pages to revert a working copy
		applyDatasetBackup: function(datasetJson) {
			var self = this;
			var dataset = self.dataset;
			var prototype = self.dataset.prototype;

			var $binds = Object.keys(this.controlsByBind);
			$binds.forEach(function($bind) {
				//if (dataset.isDirty($bind)) {
				if (prototype.isReference($bind)) {
					var val = prototype.propGetRefValueName($bind);
					self.setValue(val, datasetJson[val], true, true);
				} else if (prototype.propIsSimple($bind)) {
					self.setValue($bind, datasetJson[$bind], true, true);
				}
				//}
			});

			return this.root._updateServer();
		},
		actChartToolbarSetDisplay: function(opts) {
			var articles = this.getArticlesByBind("$resources");
			if (this.uiAdapter && this.uiAdapter.actToolbarSetDisplay) {
				return this.uiAdapter.actToolbarSetDisplay(opts);
			}
		},
		getArticlesByBind: function($bind) {
			var chartArticle, arrayChartArticle;
			var controls = this.getControlsByBind($bind);
			controls.forEach(function(ctrl) {
				if (ctrl.isArrayChart()) {
					if (ctrl.isHighChart()) {
						chartArticle = $.extend(true, {}, ctrl.article);
					} else {
						arrayChartArticle = $.extend(true, {}, ctrl.article);
					}
				}
			})
			return {
				"chartArticle": chartArticle,
				"arrayChartArticle": arrayChartArticle
			}
		},
		getChart: function() {
			var controls = this.getControlsByBind("$resources");
			var chart
			controls.forEach(function(ctrl) {
				if (ctrl.isArrayChart()) {
					if (ctrl.isHighChart()) {
						chart = ctrl
					}
				}
			})
			return chart;
		},
		canBePinned: function() {
			return (!this.uiAdapter.pageData.prototype.isApplication());
			// a page can be pinned/unpind if it's not an application dashboard;
		}
	}
);
});

define('syracuse-tablet/html/js/helpers/fieldOperators',['require','exports','module','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var locale = require('syracuse-tablet/html/js/helpers/locale');

var _excludedTypes = ["application/x-array", "image", "application/x-document", "application/x-binary", "application/x-object", "text/rtf", "text/html", "application/x-password"];

var _numberOperators = ["gt", "ge", "lt", "le", "eq", "ne"];
var _stringOperators = ["like", "gt", "ge", "lt", "le", "eq", "ne", "like_s"];
var _defOperators = ["eq", "ne"];

var _DATE = {
	type: "application/x-date",
	checkFieldValue: function(fieldValue) {
		return String(fieldValue);
	},
	checkValue: function(value) {
		return String(value);

	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _TIME = {
	type: "application/x-time",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return value;

	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _DATETIME = {
	type: "application/x-datetime",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return value;

	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _DEC = {
	type: "application/x-decimal",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return parseFloat(value);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _REAL = {
	type: "application/x-real",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return parseFloat(value);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _INT = {
	type: "application/x-integer",
	checkFieldValue: function(fieldValue) {
		return parseInt(fieldValue, 10);
	},
	checkValue: function(value) {
		return parseInt(value, 10);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _QTY = {
	type: "application/x-quantity",
	checkFieldValue: function(fieldValue) {
		return parseFloat(fieldValue);
	},
	checkValue: function(value) {
		return parseFloat(value);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _STR = {
	type: "application/x-string",
	checkFieldValue: function(fieldValue) {
		return String(fieldValue);
	},
	checkValue: function(value) {
		return String(value);
	},
	operators: _stringOperators,
	defOperator: "like"
};
var _TEXT = {
	type: "text/plain",
	checkFieldValue: function(fieldValue) {
		return String(fieldValue);
	},
	checkValue: function(value) {
		return String(value);
	},
	operators: _stringOperators,
	defOperator: "like"
};
var _REF = {
	type: "application/x-reference",
	checkFieldValue: function(fieldValue) {
		return fieldValue && fieldValue.$value ? String(fieldValue.$value).toUpperCase() : null;
	},
	checkValue: function(value) {
		return value ? String(value).toUpperCase() : null;

	},
	operators: _stringOperators,
	defOperator: "like"
};
var _CHOICE = {
	type: "application/x-choice",
	checkFieldValue: function(fieldValue) {
		return parseInt(fieldValue, 10);
	},
	checkValue: function(value) {
		return parseInt(value, 10);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
/**
 * Boolean
 */
var _BOOL = {
	type: "application/x-boolean",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return value;
	},
	operators: _defOperators,
	defOperator: "eq"
};


var _types = {};
[_DATE, _TIME, _DATETIME, _DEC, _REAL, _INT, _QTY, _STR, _TEXT, _REF, _BOOL, _CHOICE].forEach(function(t) {
	_types[t.type] = t;
});


var _operatorsWithTitle = {};
/**
 * Return array of operators according to field type
 */
var _operatorsByType = function($type) {
	var t = _types[$type];
	return t ? t.operators : _defOperators;
};

var _getOperators = function($type, withTitle, exclude) {
	var operators;
	if (withTitle === true) {
		if (_operatorsWithTitle[$type] == null) {
			var ops = _operatorsByType($type);
			var res = [];
			ops.forEach(function(op) {
				res.push({
					title: locale.text("field.operator." + op),
					value: op
				});
			});
			_operatorsWithTitle[$type] = res;
		}
		operators = _operatorsWithTitle[$type];
	} else {
		operators = _operatorsByType($type);
	}
	if (exclude && exclude.length > 0) {
		var tmp = operators;
		operators = [];
		tmp.forEach(function(o) {
			if (exclude.indexOf(o) < 0) {
				operators.push(o);
			}
		});
	}
	return operators;
};

var _getDefaultOperator = function($type) {
	var t = _types[$type];
	return t ? t.defOperator : "eq";
};
var _evaluateOperator = function($type, fieldValue, operator, value) {
	var fieldType = _types[$type];
	if (fieldType == null) {
		console.log("_evaluateOperator - Type [" + $type + "] not evaluated");
		return false;
	}
	if (fieldType.operators.indexOf(operator) < 0) return false;
	fieldValue = fieldType.checkFieldValue(fieldValue);
	value = fieldType.checkValue(value);
	if (fieldValue == null || value == null) return false;
	if (operator === "eq") {
		return fieldValue == value;
	}
	if (operator === "ne") {
		return fieldValue != value;
	}
	if (operator === "like") {
		return fieldValue.indexOf ? fieldValue.indexOf(value) >= 0 : false;
	}
	if (operator === "like_s") {
		return fieldValue.smStartsWith ? fieldValue.smStartsWith(value) : false;
	}
	if (operator === "gt") {
		return fieldValue > value;
	}
	if (operator === "ge") {
		return fieldValue >= value;
	}
	if (operator === "lt") {
		return fieldValue < value;
	}
	if (operator === "le") {
		return fieldValue <= value;
	}
	return false;
};

exports.getDefaultOperator = _getDefaultOperator;
exports.getOperators = _getOperators;
exports.evaluateOperator = _evaluateOperator;
exports.acceptOperator = function($type) {
	return _excludedTypes.indexOf($type) < 0;
};
exports.checkValue = function($type, value) {
	var fieldType = _types[$type];
	return fieldType ? fieldType.checkValue(value) : null;
};
});

define('syracuse-tablet/html/js/controls/array/builderBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/scroller/scrollerHelpers','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/fieldOperators'],function (require, exports, module) {
var utils = require('syracuse-tablet/html/js/helpers/utils');
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');
var modules = require('syracuse-tablet/html/js/common/modules');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');

exports.getHtmlStatus = function(statusInfo, rowDataset) {
	if (!statusInfo || !rowDataset) return;
	var html = ['<div class="s-m-control s-m-row-status">'];
	var h, defIcon = fontUtils.getArrayStatusDefIcon(),
		icon;
	statusInfo.list.some(function(s) {
		if (s.color && fieldOperators.evaluateOperator(s.$type, rowDataset.getValue(s.field), s.operator, s.value)) {
			icon = s.icon || defIcon;
			// We use background color for color icon
			html.push('<div class="' + icon.css + '" style="color:' + s.color.bgColor + '"/>');
			return true;
		}
	});
	html.push('</div>');
	return html.join('');
}

var _isExcluded = ["application/x-password"];

exports.BuilderBase = utils.defineClass(
	function builderBase(control) {
		this.control = control;
		this.$itemProto = this.control.get$ItemProto();
		this.article = this.control.article;
		this.prototype = this.control.prototype;
		this.controller = this.control.controller;
	}, null, {

		destroy: function() {
			this.destroyed = true;
			this.control = null;
			this.$itemProto = null;
			this.article = null;
			this.controller = null;
			this.prototype = null;
		},

		isDestroyed: function() {
			return this.control == null || this.control.destroyed;
		},

		/**
		 * Initialize building and builds the fixed elements of the array that doesn't depend on the parent's size
		 * data is an array of row's dataSet
		 */
		buildHtml: function(data, $$parent, refresh) {},

		/**
		 * Method called on resize (computeLayout)
		 * Builds the elements that need the parent's size
		 * -> scroller, chart, card...
		 */
		buildOnResize: function(data, $$parent, context) {},

		appendRow: function(recordDataset) {
			throw new Error("Not implemented");
		},

		insertError: function(html) {
			$(['<span class="s-m-error">', html, "</span>"].join('')).prependTo(this.control.$$elmt);
		},

		/**
		 * Returns false to break build process
		 */
		checkEmptyArray: function(forceEmpty) {
			if (this.control.isEmpty() || forceEmpty === true) {
				this.updateGestureMgr();
				this.control.setEmptyArrayMsg();
				return false;
			}
			return true;
		},

		doAfterBuild: function() {
			this.updateGestureMgr();
			if (this.control.page.isFacet("details", "edit", "create")) {
				// We notify the controller because arrays are built asynchronously - #6541
				// Only detail/edit because for queries the scroller is managed by the array (refreshHeaderAndGesture);
				this.control.page.notifyScrollerUpdate();
			}
		},

		updateGestureMgr: function(resizeContext) {
			resizeContext = resizeContext || {};
			var scrollOnly = resizeContext.scrollOnly;
			var preserveScroll = resizeContext.preserveScroll;
			if (this._gestureMgr) {
				if (this.isScrollable()) {
					// ScrollViewRect has changed so we check to re-init or reset _gestureMgr 
					this._gestureMgr.checkViewRect(this.control.getScrollViewRect(), preserveScroll);
				} else {
					this._gestureMgr.reset();
				}
			}
		},
		makeVisible: function($$elmt, smoothOffset) {
			if (this._gestureMgr) {
				this._gestureMgr.makeVisible($$elmt, smoothOffset);
			}
		},
		isScrollable: function() {
			return true;
		},

		/**
		 * True if field is excluded
		 */
		isExcluded: function(proto) {
			return proto == null || proto.json.$isExcluded === true || _isExcluded.indexOf(proto.json.$type) >= 0;
		},

		newScroller: function(type, $$elmt, options) {
			this.destroyScroller();
			options = $.extend(true, {
				direction: type,
				name: this.control.$bind,
				isPageScroller: false
			}, options);
			if (options.valMax == null) {
				options.valMax = 0;
			};
			this._gestureMgr = scroller.newScroller($$elmt, options, modules.get("navStack").getMainStack().getTopPage().getGestureMgr());
			return this._gestureMgr;
		},

		destroyScroller: function() {
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},
		hasScroller: function() {
			return this._gestureMgr != null;
		},
		savedCtxCreate: function(opts) {
			if (this._gestureMgr == null || (opts && opts.noScroll === true)) {
				return {};
			}
			var res = {
				$display: this.control.$display,
				selectedRowUuid: this.getLastSelectedRowId()
			};
			res.gestureMgr = this._gestureMgr ? this._gestureMgr.savedCtxCreate(opts) : null;
			return res;
		},
		savedCtxRestore: function(ctx) {
			this.control.$$content.find(".s-m-last-selected").removeClass("s-m-last-selected");
			if (ctx.selectedRowUuid) {
				this.setLastSelectedRowId(ctx.selectedRowUuid);
			}
			if (ctx.gestureMgr != null && this.control.$display === ctx.$display) {
				if (this._gestureMgr) {
					// Restore context and refresh only if $display didn't change
					this._gestureMgr.savedCtxRestore(ctx.gestureMgr, true);
				} else {
					this._restoreGestureMgr = ctx.gestureMgr;
				}
			}
		},
		getLastSelectedRowId: function() {
			throw new Error("Not implemented")
		},
		setLastSelectedRowId: function(selectedRowUuid) {
			throw new Error("Not implemented")
		},
		/**
		 * Update row's index in html
		 */
		updateRowIndex: function($$parent, index) {
			// nothing
		}

	});
});

define('syracuse-tablet/html/js/common/consts',['require','exports','module'],function (require, exports, module) {

exports.ROWID_PREFIX = "rowid-";
});

define('syracuse-tablet/html/js/controls/array/ctrlArrayTableRow',['require','exports','module','syracuse-tablet/html/js/controls/ctrlSdataBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/controls/array/builderBase','syracuse-tablet/html/js/controllers/sdataController','syracuse-tablet/html/js/common/consts'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/ctrlSdataBase').CtrlSdataBase;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var modules = require('syracuse-tablet/html/js/common/modules');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var builderBase = require('syracuse-tablet/html/js/controls/array/builderBase');
var SdataController = require("syracuse-tablet/html/js/controllers/sdataController").SdataController;
var consts = require('syracuse-tablet/html/js/common/consts');


/**
 * Control representing a single row of an array
 */
exports.CtrlArrayTableRow = utils.defineClass(
	function CtrlArrayTableRow(rowDataset, arrayController, article, prototype, options) {
		// first
		this._rowController = new SdataController(rowDataset, arrayController);
		// Second
		Base.call(this, arrayController, article, prototype, options);
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._rowController) {
				this._rowController.destroy();
				this._rowController = null;
			}
			this._columnsInfo = null;
		},

		createId: function(typeName) {
			return consts.ROWID_PREFIX + this.getUuid();
		},

		buildHtml: function(columnsInfo) {
			this._columnsInfo = columnsInfo;
			var classes = ["s-m-record"];
			if (this.options.rowIndex != null && this.options.rowIndex % 2 === 0) {
				classes.push("s-m-even");
			}
			Base.prototype.buildHtml.call(this, classes);
			this._buildContents();
		},

		_buildContents: function(columnsInfo) {
			if (this.options.rowLinkDomAttrs) {
				this.$$elmt.attr(this.options.rowLinkDomAttrs);
			} else if (this.options.drillDownDomAttrs) {
				this.$$elmt.attr(this.options.drillDownDomAttrs);
			}
			this.$$elmt.attr({
				"data-controller-id": this._rowController.id
			});
			var self = this;
			var ctrlFactory = modules.get("ctrlFactory");
			this._columnsInfo.forEach(function(col, idx) {
				if (col.isProtoItem) {
					var ctrlCell = ctrlFactory.createControl(self._rowController, col.article,
						self,
						self.page, {
							displayCtx: "table",
							noEdit: self.options.noEdit
						});
					if (ctrlCell) {
						var $$td = $(uiUtils.createDomElement("td", null, null, null, self.$$elmt));
						ctrlCell.set$$container($$td);
						ctrlCell.buildHtml();
					}
				} else {
					var text;
					switch (col.$bind) {
						case "rowStatus":
							text = builderBase.getHtmlStatus(col.statusInfo, self._rowController.dataset);
							break;
						case "rowIndex":
							text = '<div class="s-m-control s-m-row-index"><span class="badge">' + (self.options.rowIndex + 1) + '</span></div>';
							break;
						case "rowDetail":
						case "rowDelete":
						case "rowEdit":
							text = '<div class="s-m-control s-m-icon"><a href="#" data-nevent data-naction="rowAction" data-params="' + col.$bind + '" class="a"><span class="' + fontUtils.tableActionIcon(col.$bind) + '"></span></a></div>';
							break;
					}
					$("<td>" + (text || col.$bind) + "</td>").appendTo(self.$$elmt);
				}
			});
		},

		getRootElementTag: function() {
			return "tr";
		},
		_refreshContent: function() {
			// Destroy and recreate the controller (new controls are created)
			var rowDataset = this._rowController.dataset;
			var arrayController = this._rowController.parent;
			this._rowController.destroy();
			this._rowController = new SdataController(rowDataset, arrayController);
			//Build new cells under the same parent 
			this.$$elmt.empty();
			this._buildContents();
		},
		_actLookupAccept: function() {
			this.setRowSelected(true);
			var lookup = this.controller.root.lookupData; // Injected by lookup page so we can use it here
			var parentController = this._rowController.findController(lookup.controllerId);
			var value = this._rowController.getValue(lookup.$lookupKeyName);
			parentController.setValue(lookup.$bind, value, true);
			return modules.get("appController").App.goBack();
		},
		/**
		 * Update row index
		 */
		updateRowIndex: function(index) {
			if (this.options.rowIndex == null || index === this.options.rowIndex) {
				return;
			}
			if (this.options.rowIndex != null) {
				this.options.rowIndex = index;
			}
			// Update background
			this.$$elmt.toggleClass("s-m-even", this.options.rowIndex % 2 === 0);
			// Update index
			this.parent.builderContent.updateRowIndex(this.$$elmt, index);
		},
		onSdataLinkClicked: function($linkName, $linkBind) {
			if (this.page.multiSelectionIsEnabed()) {
				this.page.multiSelectionController.multiSelToggleRecord(this.$$elmt);
			} else {
				this.setRowSelected();
				this._rowController.onSdataLinkClicked($linkName, $linkBind);
			}
		},
		notifyRowSaved: function() {
			this._refreshContent();
			return modules.get("appController").App.goBack();

		},
		/**
		 * activity: detail | edit | create
		 */
		openRowDetail: function(activity) {
			this._rowController.gotoUrl("child://SdataRowDetail", null, {
				isChild: true,
				childContext: {
					controllerId: this._rowController.id,
					rowControl: this,
					activity: activity
				}
			});
		},

		/**
		 * Called from rowDetail if cancel on create facet
		 */
		removeRowDetail: function() {
			this.parent.removeRow(this);
		},

		_actRowAction: function(params) {
			switch (params) {
				case "rowDetail":
					this.setRowSelected();
					this.openRowDetail("detail");
					break;
				case "rowEdit":
					this.setRowSelected();
					this.openRowDetail("edit");
					break;
				case "rowDelete":
					this.setRowSelected(false);
					// Ask the parent (=> array to remove the row)
					this.parent.removeRow(this);
					break;
				default:
					break;
			}
		},
		_actDrillDown: function() {
			this._rowController.drillDownLink(this.page.controller.level);
		},
		_actLevelUp: function() {
			this._rowController.levelUpLink(this.page.controller.level);
		},
		getUuid: function() {
			return this._rowController.dataset.getUuid();
		},
		setRowSelected: function(select) {
			select = select == null ? true : false;
			this.parent.$$content.find('.s-m-last-selected').removeClass("s-m-last-selected");
			if (select) {
				return this.$$elmt.addClass("s-m-last-selected");
			}
		},
		doAfterClickAddRow: function(isSingleArray) {
			if (isSingleArray) {
				if (this.children && this.children.length > 0) {
					// Set the focus on the field
					var self = this;
					setTimeout(function() {
						self.children[0].setFocus();
					})
				}
			} else {
				this.openRowDetail("create");
			}
		}
	});
});

define('syracuse-tablet/html/js/controls/array/ctrlArrayCardCell',['require','exports','module','syracuse-tablet/html/js/controls/ctrlSdataBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controllers/sdataController','syracuse-tablet/html/js/controls/articleParser','syracuse-tablet/html/js/common/consts'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/ctrlSdataBase').CtrlSdataBase;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var SdataController = require("syracuse-tablet/html/js/controllers/sdataController").SdataController;
var articleParser = require("syracuse-tablet/html/js/controls/articleParser");
var consts = require('syracuse-tablet/html/js/common/consts');

/**
 * Control representing a single cell of a card array
 */
exports.CtrlArrayCardCell = utils.defineClass(
	function CtrlArrayCardCell(rowDataset, arrayController, article, prototype, options) {
		// first
		this._rootLayout = null;
		this._cellController = new SdataController(rowDataset, arrayController);
		// Second
		Base.call(this, arrayController, article, prototype, options);
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._cellController) {
				this._cellController.destroy();
			}
			this._cellController = null;
			if (this._rootLayout) {
				this._rootLayout.destroy();
			}
			this._rootLayout = null;
		},

		createId: function(typeName) {
			return consts.ROWID_PREFIX + this.getUuid();
		},

		buildHtml: function(columnsInfo) {
			Base.prototype.buildHtml.call(this);
			if (this.options.rowLinkDomAttrs) {
				this.$$elmt.attr(this.options.rowLinkDomAttrs);
			}
			this.$$elmt.attr({
				"data-controller-id": this._cellController.id
			});
			if (!this._rootLayout) {
				this._rootLayout = articleParser.parseArticle(this._cellController, this.options.cardArticle);
				if (this._rootLayout == null) {
					throw new Error("Bad card article")
				}
				this._rootLayout.set$$container(this.$$elmt);
			}
			this._rootLayout.buildHtml();
		},

		getRootElementTag: function() {
			return "div";
		},

		onSdataLinkClicked: function($linkName, $linkBind) {
			if (this.page.multiSelectionIsEnabed()) {
				this.page.multiSelectionController.multiSelToggleRecord(this.$$elmt.closest("td"));
			} else {
				this.setCellSelected();
				this._cellController.onSdataLinkClicked($linkName, $linkBind);
			}
		},

		getUuid: function() {
			return this._cellController.dataset.json.$uuid;
		},

		setCellSelected: function(select) {
			select = select == null ? true : false;
			this.parent.$$content.find('.s-m-last-selected').removeClass("s-m-last-selected");
			if (select) {
				return this.$$elmt.closest("td").addClass("s-m-last-selected");
			}
		}
	});
});

define('syracuse-tablet/html/js/controls/array/paginators',['require','exports','module','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');

var ArrayPaginatorBase = utils.defineClass(
	function ArrayPaginatorBase(arrayCtrl) {
		this.arrayCtrl = arrayCtrl;
		this.pagingLinks = ["$first", "$previous", "$next", "$last"];
	}, null, {
		/**
		 *  Will return -1 if we do not know the number of pages
		 */
		getNumPages: function() {
			throw new Error("Not implemented");
		},
		/**
		 * Returns number of rows for the current page
		 */
		getNumRowsPage: function() {
			throw new Error("Not implemented");
		},
		/**
		 * Returns the row identified by the index
		 */
		getRowByIndex: function(idx) {
			throw new Error("Not implemented");
		},
		/**
		 * Paginate in the direction given
		 * $first, $prev, $next, $last
		 */
		paginate: function(direction) {
			throw new Error("Not implemented");
		},
		destroy: function() {

		},
		/**
		 * Check if pagination on the given direction is enabled
		 */
		isEnabled: function(direction) {
			return false;
		},
		_getDatasetNumRows: function() {
			return this.arrayCtrl.arrayController.dataset.getNumRows();
		}
	});

/**
 * 
 */
exports.ArrayPaginatorServer = utils.defineClass(
	function ArrayPaginatorServer(arrayCtrl) {
		ArrayPaginatorBase.call(this, arrayCtrl);
	}, ArrayPaginatorBase, {
		getNumPages: function() {
			return -1; // For server side pagination, we do not know how many page there are
		},
		/**
		 * Returns number of rows for the current page
		 */
		getNumRowsPage: function() {
			return this._getDatasetNumRows();
		},
		/**
		 * Returns the row identified by the index
		 */
		getRowByIndex: function(index) {
			return this.arrayCtrl.arrayController.dataset.getRowByIndex(index);
		},
		/**
		 * $first, $previous, $next, $last
		 */
		paginate: function(direction) {
			if (!this.isEnabled(direction)) {
				return;
			}
			var $links = this._getLinks();
			var $link = $links[direction];
			if (!$link) {
				return;
			}
			this.arrayCtrl.notifyPaginationServer($link);
		},

		isEnabled: function(direction) {
			var $links = this._getLinks();
			return ($links && $links[direction]) != null;
		},

		_getLinks: function() {
			var pageDataset = this.arrayCtrl.arrayController.dataset.root;
			var $links = pageDataset.getLinks();
			return $links;
		}
	});

/**
 * 
 */
exports.ArrayPaginatorClient = utils.defineClass(
	function ArrayPaginatorServer(arrayCtrl, pageSize) {
		ArrayPaginatorBase.call(this, arrayCtrl);
		this.pageSize = pageSize;
		this.indexShift = 0;
	}, ArrayPaginatorBase, {

		getNumPages: function() {
			// calculated
			return Math.ceil(this._getDatasetNumRows() / this.pageSize);
		},
		/**
		 * Returns number of rows for the CURRENT page
		 */
		getNumRowsPage: function() {
			var countTotal = this._getDatasetNumRows();
			return Math.min(countTotal - this.indexShift, this.pageSize);
		},
		/**
		 * Returns the row identified by the index
		 */
		getRowByIndex: function(index) {
			return this.arrayCtrl.arrayController.dataset.getRowByIndex(index + this.indexShift);
		},
		/**
		 * $first, $previous, $next, $last
		 */
		paginate: function(direction) {
			if (!this.isEnabled(direction)) {
				return;
			}
			switch (direction) {
				case "$first":
					this.indexShift = 0;
					break;
				case "$previous":
					this.indexShift = this.indexShift - this.pageSize
					break;
				case "$next":
					this.indexShift = this.indexShift + this.pageSize
					break;
				case "$last":
					this.indexShift = this._getDatasetNumRows() - this.pageSize;
					break;
			}

			this.indexShift = Math.max(0, Math.min(this.indexShift, this._getDatasetNumRows() - 1));
			this.arrayCtrl.notifyPaginationLocal();
		},

		isEnabled: function(direction) {
			switch (direction) {
				case "$first":
				case "$previous":
					return this.indexShift > 0;
				case "$next":
				case "$last":
					return this.indexShift + this.pageSize < this._getDatasetNumRows();
			}
		}
	});
});

define('syracuse-tablet/html/js/controls/array/builderHeader',['require','exports','module','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');

var _html = {
	header: '<header> \
			<nav class="s-m-stdheader"> \
				{{#if showPagination}} \
				<nav class="s-m-pagin"> \
					<ul class="pagination"> \
						<li> \
							<a class="s-m-link glyphicon glyphicon-step-backward disabled" href="#" \
								data-nevent \
								data-naction="pagination" \
								data-params="$first" \
								draggable="false"> \
							</a> \
						</li> \
						<li> \
							<a class="s-m-link glyphicon glyphicon-chevron-left disabled" href="#" \
								data-nevent \
								data-naction="pagination" \
								data-params="$previous" \
								draggable="false"> \
							</a> \
						</li> \
						<li> \
							<a class="s-m-link glyphicon glyphicon-chevron-right disabled" href="#" \
								data-nevent \
								data-naction="pagination" \
								data-params="$next" \
								draggable="false "> \
							</a> \
						</li> \
						<li> \
							<a class="s-m-link glyphicon glyphicon-step-forward disabled" href="#" \
								data-nevent \
								data-naction="pagination" \
								data-params="$last" \
								draggable="false"> \
							</a> \
						</li> \
					</ul> \
				</nav> \
				{{/if}} \
				{{#if showSearch}} \
				<nav class="s-m-search"/>\
				{{/if}} \
				{{#if showSortFilter}} \
				<div class="s-m-filterSort" data-nevent data-naction="actionArray" data-params="panelfiltersort">\
					<i class="s-m-sorted" style="display:none"></i>\
					<i class="s-m-filtered fa fa-filter" style="display:none"></i>\
					<i class="fa fa-bars"></i>\
				</div>\
				{{/if}}\
				{{#if showFiltersList}}\
				<nav class="s-m-filterslist"/>\
				{{/if}}\
			</nav> \
			{{#if showFiltersTabs}}\
				<nav class="s-m-filtertabs"/>\
			{{/if}}\
		</header>'
};

var _templates = {};
var _getHtml = function(name, ctx) {
	var tmpl = _templates[name];
	if (!tmpl) {
		tmpl = _templates[name] = Handlebars.compile(_html[name]);
	}
	return tmpl(ctx || {});
};

/**
 * Render array header
 */
exports.BuilderHeader = utils.defineClass(
	function builderHeader(control, headerOpts) {
		this.control = control;
		this.options = headerOpts;
		this.options.showFiltersList = this.options.$filtersAuthoring === "list";
		this.options.showFiltersTabs = this.options.showFiltersList !== true && this.options.$filtersAuthoring === "tabs";
		if (this.options.showFiltersTabs == true && this.control.page.isVignette()) {
			this.options.showFiltersList = true;
			this.options.showFiltersTabs = false;
		}
	}, null, {

		destroy: function() {
			this.control = null;
			if (this.$$elmt) {
				this.$$elmt.remove()
			}
			this.$$elmt = null;
		},

		buildHtml: function(arrayData, refresh) {
			// Hide search if no data and no search criteria
			var showSearch = this.options.showSearch && (arrayData.length > 0 || this.control.filterSearch.hasSearchCriteria());
			if (refresh == true && this.$$elmt) {
				this.update(showSearch);
				return;
			}
			if (this.$$elmt) {
				this.$$elmt.remove();
			}
			if (this.options.showFiltersList || this.options.showFiltersTabs || showSearch || this.options.showSortFilter || this.options.showPagination) {
				this.$$elmt = $(_getHtml("header", this.options));
				if (showSearch) {
					$("nav.s-m-search", this.$$elmt).append(this.control.filterSearch.getHtml())
				}
				if (this.options.showFiltersList) {
					$("nav.s-m-filterslist", this.$$elmt).append(this.control.filterX3.getHtml("list"));
				} else if (this.options.showFiltersTabs) {
					$("nav.s-m-filtertabs", this.$$elmt).append(this.control.filterX3.getHtml("tabs"));
				}
			} else {
				// Empty
				this.$$elmt = $("<header/>");
			}
			this.control.$$content.before(this.$$elmt);
			this.update(showSearch);
			// Check if header empty
		},

		update: function(showSearch) {
			$("nav.s-m-search", this.$$elmt).toggle(showSearch);
			if (this.control.filterSort) {
				this.control.filterSort.arrayHeaderUpdate(this.$$elmt);
			}
			if (this.control.paginator) {
				var self = this;
				var nbEnabled = 0;
				this.control.paginator.pagingLinks.forEach(function(link) {
					var $$link = $('[data-naction="pagination"][data-params="' + link + '"]', self.$$elmt);
					var ena = self.control.paginator.isEnabled(link);
					if (ena) {
						nbEnabled++;
					}
					$($$link.parent()).add($$link).toggleClass("disabled", !ena);
				});
				// All disabled hide pagination
				this.$$elmt.find(".s-m-pagin").toggle(nbEnabled > 0);
			}
		},
		/**
		 * disable/enable clicks on the panel
		 */
		disable: function(yes) {
			yes = yes === true;
			this.$$elmt.css("opacity", yes ? 0.5 : "inherit");
			if (yes) {
				this.$$elmt.click(function(evt) {
					evt.preventDefault();
					evt.stopPropagation();
				})
			} else {
				this.$$elmt.off();
			}
		}
	});
});

define('syracuse-tablet/html/js/sdata/sdatawhere/operator',['require','exports','module','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {
var helpers = require('syracuse-tablet/html/js/helpers/utils');

exports.Operator = function(code, text, precedence, isPrefix, isInfix, isAssociative, isPredicate) {
	var self = this;
	self.code = code;
	self.text = text;
	self.precedence = precedence;
	self.isPrefix = isPrefix;
	self.isInfix = isInfix;
	self.isAssociative = isAssociative;
	self.isPredicate = isPredicate;
};
helpers.defineClass(exports.Operator, null, {
	toString: function() {
		return this.text;
	}
});

exports.operators = new function() {
	var self = this;
	self.operators = { //length : 0
	};

	init();

	function createOp(code, text, precedence, isPrefix, isInfix, isAssociative, isPredicate) {
		var op = new exports.Operator(code || text, text, precedence, isPrefix, isInfix, isAssociative, isPredicate);
		self.operators[op.text] = op;
		//self.operators.length++;
	}

	function init() {
		// codes are SQL operators - makes SQL conversion easy
		createOp(null, ".", 1, false, true, true, false);
		createOp(null, "not", 2, true, false, false, false);
		createOp("*", "mul", 3, false, true, true, false);
		createOp("/", "div", 3, false, true, true, false);
		createOp("%", "mod", 3, false, true, true, false);
		createOp(null, "+", 4, false, true, true, false);
		createOp(null, "-", 4, true, true, true, false);
		createOp("=", "eq", 5, false, true, false, true);
		createOp("<>", "ne", 5, false, true, false, true);
		createOp("<", "lt", 5, false, true, false, true);
		createOp("<=", "le", 5, false, true, false, true);
		createOp(">", "gt", 5, false, true, false, true);
		createOp(">=", "ge", 5, false, true, false, true);
		createOp(null, "between", 5, false, true, false, true);
		createOp(null, "in", 5, false, true, false, true);
		createOp(null, "like", 5, false, true, false, true);
		createOp(null, "and", 6, false, true, true, true);
		createOp(null, "or", 7, false, true, true, true);
		createOp(null, "(", 8, true, false, false, false);
		createOp(null, ")", 8, false, false, false, false);
		createOp(null, ",", 8, false, false, false, false);
	}

	return self;

};
});

define('syracuse-tablet/html/js/sdata/sdatawhere/token',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/sdata/sdatawhere/operator'],function (require, exports, module) {
var helpers = require('syracuse-tablet/html/js/helpers/utils');
var operators = require('syracuse-tablet/html/js/sdata/sdatawhere/operator');

exports.tokenType = {
	identifier: 'identifier',
	operator: 'operator',
	literal: 'literal'
};

exports.Token = function(type, line, offset, length, val) {
	var self = this;
	self.type = type;
	self.value = val;

	var _line = line;
	var _offset = offset;
	var _length = length;
	self.getRemainingText = function() {
		return _line.substring(_offset, _line.length);
	};
};

helpers.defineClass(exports.Token, null, {
	matches: function(code) {
		return this.value instanceof operators.Operator && this.value.code == code;
	}
});
});

define('syracuse-tablet/html/js/sdata/sdatawhere/tokenizer',['require','exports','module','syracuse-tablet/html/js/sdata/sdatawhere/token','syracuse-tablet/html/js/sdata/sdatawhere/operator'],function (require, exports, module) {

var token = require('syracuse-tablet/html/js/sdata/sdatawhere/token');
var operators = require('syracuse-tablet/html/js/sdata/sdatawhere/operator');

exports.Tokenizer = new function() {
	var self = this;

	function _skipSpaces(chars, i) {
		while (i < chars.length && chars[i] === " ") {
			i++;
		}
		return i;
	}

	function _isDigit(str) {
		return new RegExp('[0-9]').test(str);
	}

	function _isLetter(str) {
		return new RegExp('[\$a-zA-Z%\']').test(str);
	}

	function _isWordChar(str) {
		return new RegExp('[\$a-zA-Z0-9_%\']').test(str);
	}

	function _parseNumber(line, chars, i, tokens) {
		var end = i + 1;
		while (end < chars.length && _isDigit(chars[end])) {
			end++;
		}
		var val;
		if (end < chars.length && chars[end] === '.') {
			end++;
			while (end < chars.length && _isDigit(chars[end])) {
				end++;
			}
			val = parseFloat(line.substring(i, end));

		} else {
			val = parseInt(line.substring(i, end), 10);
		}
		tokens.push(new token.Token(token.tokenType.literal, line, i, end - i,
			val));
		return end;
	}

	var _literals = {
		"true": true,
		"false": false,
		"null": null,
	};

	function _parseWord(line, chars, i, tokens) {
		var end = i + 1;
		while (end < chars.length && _isWordChar(chars[end])) {
			end++;
		}
		var word = chars.substr(i, end - i);
		var op = operators.operators.operators[word.toLowerCase()];
		if (op != null) {
			tokens.push(new token.Token(token.tokenType.operator, line, i, end - i, op));
		} else {
			var lit;
			if ((lit = _literals[word]) !== undefined) {
				tokens.push(new token.Token(token.tokenType.literal, line, i,
					end - i, lit));
			} else {
				tokens.push(new token.Token(token.tokenType.identifier, line,
					i, end - i, word));
			}
		}
		return end;
	}

	function _parseQuotedString(line, chars, i, tokens) {
		var quote = chars[i];
		var end = i + 1;
		var dest = 0;
		var res = "";
		while (end < chars.length) {
			if (chars[end] === quote) {
				end++;
				if (end === chars.length || chars[end] !== quote) {
					tokens.push(new token.Token(token.tokenType.literal, line,
						i, end - i, res));
					return end;
				}
			}
			res += chars[end++];
		}
		throw new Error('quoted string not terminated: ' + line.substring(i));
	}

	function _parseOperator(line, ch, i, tokens) {
		var op = operators.operators.operators[ch];
		tokens.push(new token.Token(token.tokenType.operator, line, i, 1, op));
		return i + 1;
	}

	function _parseDateTime(line, chars, i, tokens) {
		var end = i + 1,
			len = chars.length;
		while (end < len) {
			if (chars[end] == '@')
				break;
			end++;
		}
		if (end === chars.length) {
			throw new Error('Where parser: date constant not terminated:' + line.substring(i, line.length));
		}
		var str = chars.substr(i + 1, end - i - 1);
		var dt = new Date(str);
		if (dt != null) {
			var nt = new token.Token(token.tokenType.literal, line, i, end + 1 - i, dt);
			nt.dataType = "datetime";
			nt.svalue = str;
			tokens.push(nt);
		}
		return end + 1;
	}

	self.tokenize = function(line) {
		var tokens = [];
		var i = 0;
		while (i < line.length) {
			i = _skipSpaces(line, i);
			var ch = line[i];
			switch (ch) {
				case '@':
					i = _parseDateTime(line, line, i, tokens);
					break;
				case '"':
				case '\'':
					i = _parseQuotedString(line, line, i, tokens);
					break;
				case '.':
				case '-':
				case '+':
				case '(':
				case ')':
				case ',':
					i = _parseOperator(line, ch, i, tokens);
					break;
				default:
					if (_isLetter(ch)) {
						i = _parseWord(line, line, i, tokens);
					} else if (_isDigit(ch)) {
						i = _parseNumber(line, line, i, tokens);
					} else {
						throw new Error('invalid character: ' + line.substring(i));
					}
					break;
			}
		}

		return tokens;
	};

	return self;
};
});

define('syracuse-tablet/html/js/sdata/sdatawhere/expression',['require','exports','module','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {
var helpers = require('syracuse-tablet/html/js/helpers/utils');

exports.Expression = function(config) {
	var self = this;

	self.children = null;
	if (config.operator) {
		self.type = "operator";
		self.value = config.operator;
		self.children = [];
		if (config.expression1) {
			self.children.push(config.expression1);
		}
		if (config.expression2) {
			self.children.push(config.expression2);
		}
	} else if (config.expressionType) {
		self.type = config.expressionType;
		self.value = config.value;
		self.svalue = config.svalue;
		self.dataType = config.dataType;
		if (self.type === "function") {
			self.children = [];
		}
	}
};
helpers.defineClass(exports.Expression, null, {
	isPredicate: function() {
		switch (this.type) {
			case "operator":
				return this.value.isPredicate;
			case "identifier":
				return true; // don't know
			case "function":
				return true; // don't know -- will improve later
			case "literal":
				return false;
			default:
				throw new Error("invalid expression type: " + this.type);
		}
	},
	toString: function() {
		if (this.children == null) {
			return this.value.toString();
		}
		var sb = [];
		sb.push("[" + this.value.toString());
		for (var i = 0; i < this.children.length; i++) {
			sb.push(" " + this.children[i].toString());
		}
		sb.push("]");
		return sb.join('');
	}

});
});

define('syracuse-tablet/html/js/sdata/sdatawhere/parser',['require','exports','module','syracuse-tablet/html/js/sdata/sdatawhere/token','syracuse-tablet/html/js/sdata/sdatawhere/operator','syracuse-tablet/html/js/sdata/sdatawhere/tokenizer','syracuse-tablet/html/js/sdata/sdatawhere/expression'],function (require, exports, module) {
var token = require('syracuse-tablet/html/js/sdata/sdatawhere/token');
var operators = require('syracuse-tablet/html/js/sdata/sdatawhere/operator');
var tokenizer = require('syracuse-tablet/html/js/sdata/sdatawhere/tokenizer');
var expression = require('syracuse-tablet/html/js/sdata/sdatawhere/expression');

exports.Parser = new function() {
	var self = this;
	var _maxPrecedence = 8;

	function _finishBetween(tokens, tokenIndex, exp, precedence) {
		if (tokenIndex[0] == tokens.length || !tokens[tokenIndex[0]].matches("and")) {
			throw new Error("invalid expression: expected 'and' after " + tokens[tokenIndex[0] - 1].getRemainingText());
		}
		tokenIndex[0]++;
		var arg = _parseExpression(tokens, tokenIndex, precedence);
		exp.children.push(arg);
	}

	function _parseExpression(tokens, tokenIndex, precedence) {
		var exp = _parseTerm(tokens, tokenIndex);
		while (tokenIndex[0] < tokens.length) {
			var tk = tokens[tokenIndex[0]];
			var op = tk.value instanceof operators.Operator ? tk.value : null;
			if (op == null || !op.isInfix || op.precedence > precedence) {
				break;
			}
			tokenIndex[0]++;
			if (op.code == "in") {
				if (tokenIndex[0] === tokens.length || !tokens[tokenIndex[0]].matches("(")) {
					throw new Error("invalid expression: '(' expected after " + tk.getRemainingText());
				}
				tokenIndex[0]++;
				exp = new expression.Expression({
					operator: op,
					expression1: exp
				});
				_parseArguments(tokens, tk, tokenIndex, exp.children);
			} else {
				var arg = _parseExpression(tokens, tokenIndex, op.precedence - 1);
				exp = new expression.Expression({
					operator: op,
					expression1: exp,
					expression2: arg
				});
				if (op.code == "between") {
					_finishBetween(tokens, tokenIndex, exp, op.precedence);
				}
			}
			if (!op.isAssociative && op.precedence == precedence) {
				return exp;
			}
		}
		return exp;
	}

	function _parseTerm(tokens, tokenIndex) {
		if (tokenIndex[0] == tokens.length) {
			throw new Error("premature end of expression");
		}
		var tk = tokens[tokenIndex[0]];
		switch (tk.type) {
			case token.tokenType.identifier:
				tokenIndex[0]++;
				if (tokenIndex[0] < tokens.length && tokens[tokenIndex[0]].matches("(")) {
					return _parseFunctionCall(tokens, tk, tokenIndex);
				} else {
					return new expression.Expression({
						expressionType: "identifier",
						value: tk.value
					});
				}
			case token.tokenType.literal:
				tokenIndex[0]++;
				return new expression.Expression({
					expressionType: "literal",
					value: tk.value,
					svalue: tk.svalue,
					dataType: tk.dataType
				});
			case token.tokenType.operator:
				var op = tk.value;
				if (!op.isPrefix) {
					throw new Error("invalid expression: expected beginning of term at " + tk.getRemainingText());
				}
				tokenIndex[0]++;
				return _parsePrefixOperator(tokens, op, tokenIndex);
			default:
				throw new Error("internal error: bad token type " + tk.type);
		}
	}

	function _parseArguments(tokens, tk, tokenIndex, arguments0) {
		if (tokenIndex[0] < tokens.length && tokens[tokenIndex[0]].matches(")")) {
			tokenIndex[0]++;
			return;
		}
		while (tokenIndex[0] < tokens.length) {
			var arg = _parseExpression(tokens, tokenIndex, _maxPrecedence);
			arguments0.push(arg);
			if (tokenIndex[0] < tokens.length && tokens[tokenIndex[0]].matches(")")) {
				tokenIndex[0]++;
				return;
			}
			if (tokenIndex[0] == tokens.length || !tokens[tokenIndex[0]].matches(",")) {
				throw new Error("invalid expression: expected ',' or ')' at " + tokens[tokenIndex[0]].getRemainingText());
			}
			tokenIndex[0]++;
		}
		throw new Error("invalid function call syntax: argument missing after " + tk.getRemainingText());
	}

	function _parsePrefixOperator(tokens, op, tokenIndex) {
		var arg1;
		switch (op.code) {
			case "-":
			case "not":
				arg1 = _parseExpression(tokens, tokenIndex, 1);
				return new expression.Expression({
					operator: op,
					expression1: arg1
				});
			case "(":
				arg1 = _parseExpression(tokens, tokenIndex, op.precedence);
				//require('term').stream.print('???' + tokens[tokenIndex[0]].value);
				if (tokenIndex[0] == tokens.length || !tokens[tokenIndex[0]].matches(")")) {
					throw new Error("invalid expression: expected ')' after " + tokens[tokenIndex[0] - 1].getRemainingText());
				}
				tokenIndex[0]++;
				return arg1;
			default:
				throw new Error("internal error: bad prefix operator " + op.code);
		}
	}

	function _parseFunctionCall(tokens, tk, tokenIndex) {
		tokenIndex[0]++;
		var exp = new expression.Expression({
			expressionType: "function",
			value: tk.value
		});
		_parseArguments(tokens, tk, tokenIndex, exp.children);
		return exp;
	}

	self.parse = function(str) {
		if (str == null || str.length == 0) {
			return null;
		}
		var tokens = tokenizer.Tokenizer.tokenize(str);
		var tokenIndex = [];
		tokenIndex[0] = 0;
		var exp = _parseExpression(tokens, tokenIndex, _maxPrecedence);
		if (tokenIndex[0] != tokens.length) {
			throw new Error("invalid expression: unexpected token at " + tokens[tokenIndex[0]].getRemainingText());
		}
		return exp;
	};

	return self;
};
});

define('syracuse-tablet/html/js/controls/array/filterHelper',['require','exports','module','syracuse-tablet/html/js/sdata/sdatawhere/parser','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {

var parser = require('syracuse-tablet/html/js/sdata/sdatawhere/parser').Parser;
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

exports.getFilterWhereClause = function(filterInfo) {
	var filterClause = "";
	if (filterInfo != null && filterInfo.length != 0) {
		$.each(filterInfo, function(idx, filter) {
			var cf = '(' + filter.id + ' ' + (filter.operator === "like_s" ? "like" : filter.operator) + ' ' + _setFilterRightValue(filter) + ')';
			filterClause = filterClause.length == 0 ? cf : filterClause + ' and ' + cf;
		});
	}
	return filterClause;
}

exports.getSearchClause = function(searchInfo) {
	if (!searchInfo) {
		return null;
	}
	var searchClause = '';
	Object.keys(searchInfo).forEach(function(key) {
		var search = searchInfo[key];
		var cf = '(' + search.id + ' ' + search.operator + ' ' + _setFilterRightValue(search) + ')';
		searchClause = searchClause.length == 0 ? cf : searchClause + ' or ' + cf;
	});
	if (searchClause) {
		searchClause = '(' + searchClause + ')';
	}
	return searchClause;
}
exports.filterSortUpdateUrl = function(opt) {
	var options = opt || {};
	var sdataUrl = jsutils.parseURL(options.$url);
	if (options.$filters) {
		if (!sdataUrl.query) {
			sdataUrl.query = {};
		}
		sdataUrl.query.filter = options.$filters.id;
	}
	// Add filter/sort clause for Lookup and Query if any
	// build sort clause
	var sortClause = null;
	if (options.sortInfo != null && options.sortInfo.length != 0) {
		options.sortInfo.some(function(i) {
			if (i.sort != "none") {
				sortClause = {
					order: i.sort,
					field: i.id
				};
				return true;
			}
		});
	}
	var filterMsg = false;
	// build filter clause
	var filterClause = exports.getFilterWhereClause(options.filterInfos);
	var searchClause = exports.getSearchClause(options.searchInfo);
	if (searchClause && !exports.isValidWhere(searchClause)) {
		searchClause = null;
		filterMsg = true;
	}
	// apply sort clause
	if (!sortClause && !filterClause && !searchClause) return jsutils.urlToString(sdataUrl);;
	// sdataUrl.query.key != null means it's a pagination request
	// -> The pagination request contains already the sort criteria so we don't add them
	// -> Otherwise we add sort criteria to the request
	if (sortClause && sdataUrl.query.key == null) {
		var old = sdataUrl.query.orderBy;
		sdataUrl.query.orderBy = sortClause.field + ' ' + sortClause.order;
		if (old) sdataUrl.query.orderBy = ", " + old;
	}
	// apply filter clause
	if (filterClause && sdataUrl.query.key == null) {
		var old = sdataUrl.query.where;
		sdataUrl.query.where = filterClause;
		if (old) sdataUrl.query.where = old + ' and ' + sdataUrl.query.where;
	}

	// apply search clause
	if (searchClause && sdataUrl.query.key == null) {
		var old = sdataUrl.query.where;
		sdataUrl.query.where = searchClause;
		if (old) sdataUrl.query.where = old + ' and ' + sdataUrl.query.where;
	}

	return jsutils.urlToString(sdataUrl);
}
exports.isValidWhere = function(where) {
	try {
		parser.parse(where);
		return true;
	} catch (e) {
		return false;
	}
}

/**
 * 
 * Returns appropriate right value for where request
 * For example, for the filter 'CODE contains aa', the where clause should look like
 * CODE like '%aa%'. This function will return '%aa%'
 */
function _setFilterRightValue(filter) {
	var cp = filter.prop;
	var cv, value = (filter.originalValue || filter.value) == null ? "" : (filter.originalValue || filter.value);
	switch (cp.$type) {
		case "application/x-password":
		case "application/x-string":
			cv = value.replace(/'/g, "\\'");
			if (filter.operator === "like") cv = '%' + cv + '%';
			else if (filter.operator === "like_s") cv = cv + '%';
			cv = "'" + cv + "'";
			return cv;
		case "application/x-integer":
		case "application/x-real":
		case "application/x-decimal":
		case "application/x-quantity":
			return value;
		case "application/x-date":
			if (!value) return null;
			return '@' + value + '@';
		case "application/x-datetime":
			return '@' + value + '@';
		case "application/x-time":
			return null;
		case "application/x-boolean":
			return value ? "true" : "false";
		case "application/x-choice":
			if (cp.$value && cp.$value.$type === "application/x-string") {
				return "'" + value.replace(/'/g, "\\'") + "'";
			} else return value + "";
			break;
		case "application/x-reference":
			if (typeof value != "string") {
				value = filter.value;
			}
			cv = (value || '').replace(/'/g, "\\'");
			cv = "'" + cv + "'";
			return cv;
		default:
			break;

	}
	return null;
};
});

define('syracuse-tablet/html/js/controls/array/searchArray',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/fieldOperators','syracuse-tablet/html/js/controls/array/filterHelper'],function (require, exports, module) {
var utils = require('syracuse-tablet/html/js/helpers/utils');
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');
var filterHelper = require('syracuse-tablet/html/js/controls/array/filterHelper');

var _templates = {
	basicSearch: '\
		<nav class="s-m-search">\
            <div class="input-group stylish-input-group">\
                <input type="text" class="form-control"  placeholder="Search"  value="{{searchValue}}" >\
                <span class="input-group-addon">\
                    <span style="visibility:{{visibleRemove}}" class="glyphicon glyphicon-remove" data-nevent data-naction="actionArray" data-params="removeSearch"></span>\
					<span class="glyphicon glyphicon-search" data-nevent data-naction="actionArray" data-params="search"></span>\
                </span>\
            </div>\
		</nav>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

var _exclude = ["application/x-boolean"];


exports.SearchArray = utils.defineClass(
	/**
	 * savedContext is the context stored when we go to a child/detail page (see this.savedCtxCreate)
	 * It allows the page (query) to add the clause in sdataUrl at loading
	 */
	function searchArray(control) {
		this.control = control;
		this.maxCrit = 7;
		// searchInfo read in page's prefs - We need the page via controller.uiAdapter (this.page not available in contructor)
		// searchInfo is stored in page settings
		this.searchInfos = this.control.controller.uiAdapter.getPageSearch();
		if (this.hasSearchCriteria()) {
			this.searchValue = this.searchInfos["0"].value;
		} else {
			this.searchValue = "";
			this.searchInfos = null;
		}
	}, null, {
		destroy: function() {
			this.control = null;
			this.searchValue = null;
			this.searchInfos = null;
			if (this.$$search) {
				this.$$search.off("input");
				this.$$search = null;
			}
		},
		getHtml: function() {
			this.$$search = $(_getHtml("basicSearch", {
				searchValue: this.searchValue,
				visibleRemove: this.searchValue !== "" ? "visible" : "hidden"
			}));
			var self = this;
			this.$$search.on("input", "input", function() {
				self._toggleRemoveSearch($(this).val());
			})
			return this.$$search;
		},
		_toggleRemoveSearch: function(value) {
			$("[data-params='removeSearch']", this.$$search).css('visibility', !value ? "hidden" : "visible")
		},
		removeSearch: function() {
			if (this.searchValue !== "") {
				this.searchValue = "";
				this.searchInfos = [];
				this._updateSdataUrl(this.control);
			}
			$(":input", this.$$search).val("");
			this._toggleRemoveSearch();
			return false;
		},
		hasSearchCriteria: function() {
			return !$.isEmptyObject(this.searchInfos) && this.searchInfos["0"] != null;
		},
		search: function() {
			var $$value = $(":input", this.$$search);
			if (this.searchValue !== $$value.val()) {
				this.searchValue = $$value.val();
				this.searchInfos = this.searchValue.length > 0 ? this._filterInfosGet(this.control) : [];
				this._updateSdataUrl(this.control);
			}
		},
		_updateSdataUrl: function() {
			var $url = filterHelper.filterSortUpdateUrl(this.control.getFilterSortOptions());
			this.control.page.setPageSearch(this.searchInfos);
			this.control.notifyApplyFilter($url);
		},
		_filterInfosGet: function() {
			var columnInfo = this.control.getColumnsInfo(true);
			var proto = this.control.prototype.getProto$Item();
			var props = proto.data("$properties");
			var control, $bind, $type, $capabilities, self = this,
				formatter,
				criteria = [],
				errors, val, $isReference;

			columnInfo.forEach(function(column) {
				$bind = column.$bindValue;
				$type = column.$type; // ??(column.$type != "application/x-choice") ? column.$bindType : column.$type;
				$isReference = (column.$type.indexOf("x-reference") >= 0);
				$capabilities = column.$capabilities || "";
				if ($capabilities.indexOf("filter") >= 0 && criteria.length < self.maxCrit) {
					if (_exclude.indexOf($type) < 0 && self._hackFormat(props[$bind])) {
						if ($type !== "application/x-choice") {
							errors = [];
							val = null;
							formatter = formatApi.getFormatter($type, props[$bind].$format);
							if (!formatter) {
								val = self.searchValue;
							} else {
								val = formatter.parseValue(self.searchValue, errors);
								formatter.validateValue && formatter.validateValue(self.searchValue, errors);
							}
							if ($isReference && val) val = val.toUpperCase();
							if (errors.length === 0 && val !== undefined) {
								criteria.push({
									operator: fieldOperators.getDefaultOperator($type),
									id: $bind,
									value: val,
									prop: props[$bind],
									isReference: $isReference
								});
							}
						} else {
							var valueList = self._getChoiceTitles(column.$value, proto);
							valueList.forEach(function(val) {
								if (val.title.indexOf(self.searchValue) > -1 && criteria.length < self.maxCrit) {
									criteria.push({
										operator: fieldOperators.getDefaultOperator($type),
										id: $bind,
										value: val.$value,
										prop: props[$bind],
										isReference: $isReference
									});
								}
							});
						}
					}
				}
			});
			return criteria;
		},
		_getChoiceTitles: function($value, proto) {
			var res = [],
				self = this;
			$.each($value.$enum, function(index, choice) {
				res.push({
					$value: choice.$value,
					title: proto.resolveExpression(choice.$title)
				});
			});
			return res;
		},
		//Waitting for X3 format manager with strict mode
		_hackFormat: function(proto) {
			var searchable = true;
			switch (proto.$type) {
				case "application/x-integer":
					var gs = locale.getNumberGroupSeparator();
					var ds = locale.getNumberDecimalSeparator();
					searchable = !isNaN((gs && gs.length > 0) ? this.searchValue.replace(new RegExp("\\" + gs + "|\\s", "g"), "") : this.searchValue);
					searchable = searchable && ((ds && ds.length > 0) ? this.searchValue.indexOf(ds) < 0 : true);
					break;
				case "application/x-decimal":
				case "application/x-real":
				case "application/x-integer":
				case "application/x-quantity":
					searchable = !isNaN(this.searchValue.replace(new RegExp("\\.|,|\\s", "g"), ""));
					break;
				default:
					searchable = (proto.$maxLength) ? (this.searchValue.length <= proto.$maxLength) : true;
			};
			return searchable;
		},
		tableHeadUpdate: function($$tabHead) {
			$$tabHead.find(".s-m-search").removeClass("s-m-search");
			if (!this.hasSearchCriteria()) {
				return;
			}
			var self = this;
			Object.keys(this.searchInfos).forEach(function(key) {
				$$tabHead.find("." + self.searchInfos[key].id).addClass("s-m-search ");
			});
		}
	});
});

define('syracuse-tablet/html/js/controls/array/filtersSort',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/controls/array/filterHelper','syracuse-tablet/html/js/helpers/fieldOperators'],function (require, exports, module) {
var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var filterHelper = require('syracuse-tablet/html/js/controls/array/filterHelper');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');


var _sortFilterExclude = ["application/x-array", "image", "application/x-document", "application/x-binary", "application/x-object", "text/rtf", "text/html", "text/plain"];

var _templates = {
	filtersList: '\
			<select	class="form-control" data-nevent-ctrl-change data-naction="actionArray">\
			{{#each filters}}\
				<option value="filterSelected,{{id}}" {{#if $isDefault}}selected=""{{/if}}>{{$title}}</option>\
			{{/each}}\
		   </select>',
	filtersTabs: '\
				<ul class="nav nav-pills nav-justified">\
					{{#each filters}}\
						<li role="presentation" role="tab" data-toggle="tab" data-nevent data-naction="actionArray" data-params="filterSelected,{{id}}" class="{{#if $isDefault}}active{{/if}}"><a href="#">{{$title}}</a></li>\
					{{/each}}\
				</ul>',
	sortedHeader: '<div><span>{{title}}</span><i class="{{css}}"></i></div>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

/**
 *  X3 predefined filters
 */
exports.Filters = utils.defineClass(
	function filters(arrayCtrl) {
		this.control = arrayCtrl;
		this.currentFilterId = null;
		this._$filters = [];
		this._protoFilters = null;
		this._initFilters();
	}, null, {
		destroy: function() {
			this.control = null;
			this._$filters = null;
		},
		getHtml: function($auth) {
			if (($auth == "list" || $auth == "tabs") && this._$filters && this._$filters.length > 0) {
				return $(_getHtml($auth == "list" ? "filtersList" : "filtersTabs", {
					filters: this._$filters
				}));
			}
			return null;
		},
		_getUrlFilterId: function() {
			// uiAdapter page is not set in control's contructor
			var $url = this.control.controller.uiAdapter.pageData.$url;
			if ($url) {
				$url = jsutils.parseURL($url);
				return $url.query ? $url.query.filter : null;
			}
			return null;
		},
		_initFilters: function() {
			this._protoFilters = $.extend(true, {}, this.control.prototype.data("$filters", null, false, true));
			if ($.isEmptyObject(this._protoFilters)) {
				this._protoFilters = null;
			}
			if (this._protoFilters == null) {
				return;
			}
			var defFilter = null;
			var currentFilterId = this._getUrlFilterId();
			for (var p in this._protoFilters) {
				var f = $.extend(true, {}, this._protoFilters[p]);
				var ttl = this.control.prototype.resolveExpression(f.$title);
				if (ttl == null ||  ttl.trim().length == 0) {
					continue
				}
				f.$title = ttl;
				f.id = p;
				f.$isDefault = false;
				if (currentFilterId && f.id === currentFilterId) {
					defFilter = f;
				} else if (!defFilter && f.$isDefault === true) {
					defFilter = f;
				}
				this._$filters.push(f);
			}
			if (this._$filters.length == 0) {
				return;
			}
			this._$filters.unshift({
				id: "nofilter",
				$title: locale.text("nofilter"),
				$isDefault: defFilter == null
			});
			if (defFilter) {
				defFilter.$isDefault = true;
			}
		},
		// Returns the filter to add to the query url
		get$filterToApply: function() {
			if (this._$filters.length === 0 || this.control.$filtersGetAuthoring() == "none") {
				return null;
			}
			var f = null;
			this._$filters.some(function(x) {
				if (x.$isDefault === true) {
					f = x;
					return true;
				}
			});
			return f == null || f.id == "nofilter" ? null : f;
		},
		filtersSelect: function(param) {
			if (this._$filtersSelect(param)) {
				var $url = filterHelper.filterSortUpdateUrl(this.control.getFilterSortOptions());
				this.control.notifyApplyFilter($url)
			}
		},
		/**
		 * Select a filter
		 */
		_$filtersSelect: function(filterId) {
			if (this._$filters.length == 0) {
				return false;
			}
			this._$filters.forEach(function(f) {
				f.$isDefault = false;
				if (filterId === f.id) {
					f.$isDefault = true;
				}
			});
			return true
		},
		hasFilters: function() {
			return this._protoFilters != null;
		}
	});

exports.FilterSort = utils.defineClass(
	function filterSort(arrayCtrl) {
		this.control = arrayCtrl
	}, null, {
		destroy: function() {
			this.control = null;
		},
		getHtml: function(id) {

		},
		arrayHeaderUpdate: function($$container) {
			if (!$$container) return;
			var info = this._headerGetInfo();
			var $$icon = $$container.find(".s-m-sorted").toggle(info.sortOrder != null).removeClass();
			$$icon.toggle(info.sortOrder !== null)
			if (info.sortOrder != null) {
				$$icon.addClass("s-m-sorted " + fontUtils.sortIcon(info.sortOrder));
			}
			$$container.find(".s-m-filtered").toggle(info.hasFilter === true);
		},
		/**
		 *  returns an array of filterInfo
		 */
		filterInfoGet: function() {
			var info = this.control.page.getPageFilter();
			return info;
		},
		filterMapGet: function() {
			var self = this;
			var map = [];
			var props = this.control.getColumnsInfo();
			if (props) {
				props.forEach(function(prop) {
					if (_sortFilterExclude.indexOf(prop.$type) === -1 && prop.$capabilities && prop.$capabilities.indexOf("filter") >= 0 && !prop.$isExcluded) {
						var field = {
							fieldName: prop.$title,
							operators: fieldOperators.getOperators(prop.$type),
							// $bindValue is $bind for non reference field
							id: prop.$bindValue,
							prop: prop,
							isReference: prop.$type.indexOf("x-reference") >= 0
						};
						map.push(field);
					}
				});
			}
			return map;
		},
		/**
		 *  return array of sortInfo (not null)
		 */
		sortInfoGet: function() {
			var self = this;
			var info = this.control.page.getPageSort();
			if (info == null || info.length === 0) {
				var cols = this.control.getColumnsInfo();
				if (cols) {
					info = [];
					cols.forEach(function(c) {
						if (_sortFilterExclude.indexOf(c.$type) === -1 && c.$capabilities && c.$capabilities.indexOf("sort") >= 0) {
							info.push({
								name: c.$title,
								// $bindValue is $bind for non reference field
								id: c.$bindValue,
								sort: "none"
							});
						}
					});
				}
				this.sortInfoSet(info, false);
			}
			return info;
		},
		sortInfoSet: function(info, refresh) {
			// set settings
			this.control.page.setPageSort(info);
			if (refresh) {
				var $url = filterHelper.filterSortUpdateUrl(this.control.getFilterSortOptions());
				this.control.notifyApplyFilter($url)
			}
		},
		filterInfoSet: function(info, refresh) {
			this.control.page.setPageFilter(info);
			if (refresh) {
				var $url = filterHelper.filterSortUpdateUrl(this.control.getFilterSortOptions());
				this.control.notifyApplyFilter($url);
			}
		},
		/**
		 * Update table header icons when sort/filter change
		 */
		tableHeadUpdate: function($$tabHead) {
			if (!$$tabHead) {
				return;
			}
			var info = this._headerGetInfo();
			if (!info.sortOrder || !info.sortField) {
				return;
			}
			var $$th = $$tabHead.find(".s-m-sorted");
			if ($$th.length > 1) {
				var text = $$th.find("div > span")[0].text();
				$$th.removeClass();
			}
			$$th = $$tabHead.find("." + info.sortField);
			if ($$th.length > 0) {
				var title = $$th.text();
				$$th.html(_getHtml("sortedHeader", {
					title: title,
					css: fontUtils.sortIcon(info.sortOrder)
				}));
				$$th.addClass("s-m-sorted " + info.sortOrder);
			}
		},
		_headerGetInfo: function() {
			var res = {
				sortOrder: null,
				sortField: null,
				hasFilter: false
			}
			var info = this.sortInfoGet();
			if (info) {
				/** select the first sorted column
				 * Currently we support sorting on only one column
				 * -> We can display a asc/desc icon in the header
				 * Sort panel can manage sorting on multiple columns but it's disabled
				 */
				info.some(function(i) {
					if (i.sort != "none") {
						res.sortOrder = i.sort;
						res.sortField = i.id;
						return true;
					}
				});
			}
			var info = this.filterInfoGet();
			res.hasFilter = info && info.length > 0;
			return res;
		}
	});
});

define('syracuse-tablet/html/js/controls/array/builderTable',['require','exports','module','syracuse-tablet/html/js/controls/array/builderBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/environment','syracuse-tablet/html/js/app/settings','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/array/builderBase').BuilderBase;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var environment = require('syracuse-tablet/html/js/helpers/environment');
var settings = require('syracuse-tablet/html/js/app/settings');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');


var _isExcluded = ["application/json", "application/x-array", "application/x-document", "application/x-binary"];

var _fixedSzInfo = {};
/**
 * Calculates the sizes for characters, iconCells
 */
var _getFixedSizeInfo = function($$table) {
	var dev = settings.getDeviceType();
	var r = _fixedSzInfo[dev];
	if (r) return r;
	var $$body = $('<tbody></body>').appendTo($$table);
	var $$tr = $('<tr class="s-m-record"><td><div class="s-m-control s-m-field" style="width:100%"><div class="s-m-value" style="width:100%" ><span style="width:100%" id="text">MMMMMMMMMM</span></div></div></td><td class="s-m-icon"><div class="s-m-control s-m-icon"><a href="#" class="a"><span class="fa fa-hand-o-right"></span></a></div></td></tr>');
	$$tr.appendTo($$body);
	var tdWidth = $$tr.find("td").outerWidth();
	var valWidth = $$tr.find(".s-m-value").outerWidth();
	var textWidth = $$tr.find("#toto").width();
	r = {
		cellPadding: tdWidth - valWidth,
		charWidth: Math.ceil($$tr.find("#text").width() / 10),
		iconWidth: $$tr.find("td.s-m-icon").outerWidth()
	};
	$$body.remove();
	_fixedSzInfo[dev] = r;
	return r;
};

var _additionalCols = [{
	isProtoItem: false,
	$activity: "edit",
	$bind: "rowEdit",
	$widthType: "auto",
	css: ["s-m-icon"]
}, {
	isProtoItem: false,
	$activity: "edit",
	$bind: "rowDelete",
	$capabilities: "delete",
	$widthType: "auto",
	css: ["s-m-icon"]
}, {
	isProtoItem: false,
	$activity: "read",
	$bind: "rowDetail",
	$widthType: "auto",
	css: ["s-m-icon"]
}];

exports.BuilderTable = utils.defineClass(
	function builderTable(control) {
		Base.call(this, control);
		this._nbAdditionalCols = 0;
		this._tableColumnInfo = null;
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			this._$$body = null;
		},

		buildHtml: function(data, $$parent, refresh) {
			Base.prototype.buildHtml.call(this, data, $$parent, refresh);
			this._createTableColumnInfo();
			if (this._tableColumnInfo && this._tableColumnInfo.length === 0) {
				$$parent.addClass("empty");
			}
			if (refresh === true) {
				// Build the real content only in that case because parent's size is ok
				// Otherwise buildOnResize is called on computeLayout
				this.buildOnResize(data, $$parent, {
					refresh: true
				});
			}
		},

		buildOnResize: function(data, $$parent, context) {
			if (this.destroyed) {
				return;
			}
			var forceEmpty = this._tableColumnInfo == null || this._tableColumnInfo.length === 0;
			if (!this.checkEmptyArray(forceEmpty) && !this.control.controller.isEditMode()) {
				return;
			}
			this._buildTable(data, $$parent, context);
		},

		_buildTable: function(data, $$parent, context) {
			$$parent.empty();
			var scrollMax = 0;
			var $$table = $(uiUtils.createDomElement("table", ["table", "table-condensed"], null, {
				"data-controller-id": this.control.arrayController.id
			}, $$parent));
			this._calulateWidths($$parent, $$table, data);
			var $$headerScroll = this._buildTableHead($$table);
			if (data.length === 0 && !this.control.controller.isEditMode()) {
				this.doAfterBuild();
				return;
			}
			if ($$headerScroll != null && this.isScrollable()) {
				// We create an other table without header to scroll the body
				$$table = $('<table class="table table-condensed"/>').appendTo($$parent);
				// We can't hide the header of the row that scrolls - We put visibility hidden and minimize the height
				// We put an offset of -1 * $$headerScroll.height() to the scrollwrapper to better hide $headerScroll
				$$headerScroll.css({
					fontSize: "0px",
					visibility: "hidden"
				}).appendTo($$table);
				if (this.$$tabHead && this.$$tabHead.length > 0 && $$headerScroll != this.$$tabHead) {
					var top = -1 * $$headerScroll.height() / this.control.getTransformScale();
					$$table.css("top", top + "px");
					this.$$tabHead.css("z-index", 500000);
					if (!environment.isNativeScrolling()) {
						// We need to shift up the scroll in hammerScroll
						scrollMax = top;
					}
				}
			}
			this._$$body = $(uiUtils.createDomElement('tbody', null, null, null, $$table));

			for (var i = 0; i < data.length; i++) {
				this._buildTableRow(data[i], i);
			}

			this._buildTableFooter($$table);

			if (this.isScrollable()) {
				this.newScroller("v", $$table.addClass("s-m-scroll-elmt").wrap('<div class="s-m-scroll-wrapper"/>'), {
					nopadding: true,
					valMax: scrollMax
				});
			}
			this.doAfterBuild();
		},

		_buildTableFooter: function($$table) {
			var nbCols = this._tableColumnInfo.length;
			if (nbCols > 0 && this.control.controller.isEditMode() && this.control.prototype.hasCapability("append")) {
				var $$footer = $('<tfoot><tr><td colspan="' + nbCols + '"><div style= "text-align:center;" class="s-m-control s-m-icon"><a href="#" data-nevent data-naction="addRow" data-params="" class="a"><span class="' + fontUtils.tableActionIcon("rowAdd") + '"></span></a></div></td></tr></tfoot>');
				$$footer.appendTo($$table);
			}
		},

		/** _buildTableHead build the regular header and return a clone of it
		 * To scroll the body we need two tables
		 * -> one that displays only the header
		 * -> another one that display the body with same header (to preserve columns widths) but this header is hidden
		 * $$headerScroll is a clone of the regular header 
		 */
		_buildTableHead: function($$table) {
			this.$$tabHead = $(uiUtils.createDomElement('thead', null, null, null));
			var tr = uiUtils.createDomElement('tr', null, null, null, this.$$tabHead);
			this._tableColumnInfo.forEach(function(col) {
				var th = uiUtils.createDomElement('th', col.cssHeader || col.css, col.title || "", null, tr);
				if (col.fixedWidth != null && col.fixedWidth > 0) {
					$(th).width(col.fixedWidth);
				}
			});
			var showHeader = this.control.getAuthoring("$tableHeaderShow") || true;
			if (showHeader != true || this.control.isSingleArray()) {
				// Displayed header to get the right column with in edit mode
				this.$$tabHead.appendTo($$table)
					// Don't show it but (thead is applied)
				this.$$tabHead.css("visibility", "hidden");
				return null;
			}
			// Cloned before appending to $$table
			var $$headerScroll = this.$$tabHead.clone();
			// Displayed header
			this.$$tabHead.appendTo($$table);
			if (this.control.filterSort) {
				this.control.filterSort.tableHeadUpdate(this.$$tabHead);
			}
			if (this.control.filterSearch) {
				this.control.filterSearch.tableHeadUpdate(this.$$tabHead);
			}
			// header use to scroll the array (needs to be the same as this.$$tabHead to have columns aligned)
			return $$headerScroll;
		},

		_buildTableRow: function(recordDataset, index) {
			var rowCtrl = this.control.createRecordCtrl(this._$$body, recordDataset, index);
			if (rowCtrl) {
				rowCtrl.buildHtml(this._tableColumnInfo);
				if (environment.isAutoUITestMode()) {
					environment.getUnitTestMgr().arrayAddRowIndex(rowCtrl.$$elmt, index);
				}
			}
			return rowCtrl;
		},

		appendRow: function(rowDataset) {
			var index = this.control.arrayController.dataset.getRowIndex(rowDataset.json.$uuid);
			return this._buildTableRow(rowDataset, index);
		},

		_calulateWidths: function($$parent, $$table, data) {
			var size = _getFixedSizeInfo($$table);
			// We substract the icon (edit/delete/detailRow)
			var maxWidth = $$parent.width() - (this._nbAdditionalCols * size.iconWidth);
			var fixedWidth = 0;
			var width;
			// Calculate fixed width
			this._tableColumnInfo.forEach(function(i) {
				var art = i.article;
				i.fixedWidth = 0;
				if (art && art.$widthType === "fixed" && art.$widthVal > 0) {
					width = (size.charWidth * art.$widthVal) + size.cellPadding;
					if (width > 0 && ((fixedWidth + width) < maxWidth)) {
						i.fixedWidth = width;
						fixedWidth += width;
					}
				}
			});
			var remainingWidth = maxWidth - fixedWidth;
			var percentWidth = 0;
			// Caluclate % widths
			this._tableColumnInfo.forEach(function(i) {
				var art = i.article;
				if (art && art.$widthType === "percent" && art.$widthVal > 0) {
					width = ((art.$widthVal * remainingWidth) / 100) + size.cellPadding;
					if (width > 0 && ((percentWidth + width) < remainingWidth)) {
						i.fixedWidth = width;
						percentWidth += width;
					}
				}
			});
		},

		isExcluded: function(item, proto) {
			if (Base.prototype.isExcluded.call(this, proto)) return true;
			return _isExcluded.indexOf(proto.json.$type) >= 0 || item.$isAdvanced === true;
		},

		// get columns that should be displayed
		_createTableColumnInfo: function() {
			if (this._tableColumnInfo) {
				return this._tableColumnInfo;
			}
			this._nbAdditionalCols = 0;
			this._tableColumnInfo = [];
			var nonDataCol = 0;
			if (this.article.$arrayOptions.rowIndex === true) {
				this._tableColumnInfo.push({
					"isProtoItem": false,
					"$bind": "rowIndex",
					"cssHeader": "s-m-rowidx"
				});
				nonDataCol++;
			}
			var statusInfo = this.control.getRowStatusInfo();
			if (statusInfo != null) {
				this._tableColumnInfo.push({
					"isProtoItem": false,
					"$bind": "rowStatus",
					"statusInfo": statusInfo,
					"cssHeader": "s-m-row-status"
				});
				nonDataCol++;
			}
			var unfound = [];
			var items = this.article.$table;
			var protoColumns = this.control.getColumnsInfo(true);
			if (!items) {
				items = protoColumns;
			}
			var self = this;
			var dataProps = this.controller.dataset.getValueByPath("$properties");
			items.forEach(function(item, idx) {
				if (item.$isHidden || (dataProps && dataProps[item.$bind] && dataProps[item.$bind].$isHidden == true)) {
					return;
				}
				item.$widthType = item.$widthType ? item.$widthType : "auto";
				item.$widthVal = parseInt(item.$widthType === "auto" ? 0 : item.$widthVal, 10);
				item.$imgHeight = item.$imgHeight || "small";
				if (isNaN(item.$widthVal)) {
					item.$widthVal = 0;
				}
				var proto = self.$itemProto.propGetProto(item.$bind);
				if (!proto) {
					unfound.push(item);
				} else if (!self.isExcluded(item, proto)) {
					var col = {
						"$bind": item.$bind,
						"proto": proto,
						"article": item
					};
					// Added as class to identify the column by field name - see sortInfoUpdate
					col.css = [self.$itemProto.getFieldValueName(item.$bind)];
					if (col.article.$isTitleHidden === true) {
						col.title = "";
					} else if (col.article.$title != null && col.article.$title != item.$bind && (col.article.$titleOrig == null || col.article.$titleOrig.indexOf('{@') >= 0)) {
						// some translated titles are wrongly in article
						// Authoring save $title with sometimes $bind - we don't display it in the page
						// Title can be overridden by article - TODO translation
						col.title = self.$itemProto.resolveExpression(col.article.$titleOrig || col.article.$title) || "";
					} else {
						col.title = col.proto.data('$title') || "";
					}
					col.isProtoItem = true;
					self._tableColumnInfo.push(col);
				}
			});
			// if we don't display all the columns of the prototype we add the link to the detail of the row
			var overflow = (this._tableColumnInfo.length - nonDataCol) != protoColumns.length;
			if (this.article.$arrayOptions.showRowDetailLink === false) {
				// To not display the icon to display row'w detail
				overflow = false;
			}
			var editMode = this.controller.isEditMode();
			_additionalCols.forEach(function(col) {
				if (editMode && self.control.isSingleArray() && col.$bind === "rowEdit") {
					// Single arrays accept edit mode in the grid
					return
				}
				if ((editMode && col.$activity === "edit") || (!editMode && overflow && col.$activity === "read")) {
					if (col.$capabilities == null || self.prototype.hasCapability(col.$capabilities)) {
						var c = $.extend(true, {}, col);
						c.$widthType = "auto";
						self._tableColumnInfo.push(c);
						self._nbAdditionalCols++;
					}
				}
			});
			if (unfound.length > 0 && jsutils.isDvlpVersion("showUnfoundFields")) {
				var html = ['Field(s) not found<ul>'];
				unfound.forEach(function(x) {
					html.push("<li><b>" + x.$bind + "</b></li>");
				});
				html.push("</ul>");
				this.insertError(html.join(''));
			}
			return this._tableColumnInfo;
		},

		isScrollable: function() {
			return this.control.isArrayChart() || (!this.control.isArrayField() && !this.control.page.isNestedInDashboard("stack"));
		},
		getLastSelectedRowId: function() {
			return this.control.$$content.find(".s-m-last-selected").attr("id");
		},
		setLastSelectedRowId: function(selectedRowUuid) {
			this.control.$$content.find('#' + selectedRowUuid).addClass("s-m-last-selected");
		},
		updateRowIndex: function($$parent, index) {
			$$parent.find(".s-m-control.s-m-row-index > .badge").text(index);
		}
	});
});

define('syracuse-tablet/html/js/ui/modals/modalSettings',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/helpers/native/native'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var modules = require('syracuse-tablet/html/js/common/modules');
var native = require('syracuse-tablet/html/js/helpers/native/native');

var _cacheOptions = {
	"1week": {
		days: 7
	},
	"2week": {
		days: 14
	},
	"month": {
		days: 30
	},
	"all": {
		days: null
	},
};
var _templateAll = {
	header: '\
		<buttons class="pull-right"> \
			<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
		</buttons> \
		<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="form-group s-m-scroll-element"> \
					<header>{{label_device}}</header> \
					<div class="btn-group btn-group-justified" data-toggle="buttons" id="s-m-radio-type-id"> \
						<div class="btn-group"> \
							<label class="btn btn-primary" data-action="clickType" data-params="auto"> \
								<input type="radio" name="s-m-radio-type">{{label_auto}} \
							</label> \
						</div> \
						<div class="btn-group"> \
							<label class="btn btn-primary" data-action="clickType" data-params="smartphone"> \
								<input type="radio" name="s-m-radio-type">{{label_smartphone}} \
							</label> \
						</div> \
						<div class="btn-group"> \
							<label class="btn btn-primary" data-action="clickType" data-params="tablet"> \
								<input type="radio" name="s-m-radio-type">{{label_tablet}} \
							</label> \
						</div> \
					</div> \
					{{#if showConfigServers}} \
						<header>{{label_servers}}</header> \
						<div class="btn-group btn-group-justified"> \
							<div class="btn-group"> \
								<label class="btn btn-primary" data-action="selectServer" data-params="">{{label_switch_server}}</label> \
							</div> \
						</div> \
					{{/if}} \
					<header id="s-m-cache-id">{{label_cache}}</header> \
					<span id="s-m-cache-explain">{{label_cache_clear}} \
					<div id="s-m-cache-btns-id" class="btn-group btn-group-justified"> \
						<label id="s-m-cache-clear-all-id" class="btn btn-primary s-m-cache-btn" data-action="clearCache" data-params="clear,all">{{label_cache_all}}<div></div></label> \
						<label id="s-m-cache-clear-1week-id" class="btn btn-primary s-m-cache-btn" data-action="clearCache" data-params="clear,1week">{{label_cache_week1}}<div></div></label> \
						<label id="s-m-cache-clear-2week-id" class="btn btn-primary s-m-cache-btn" data-action="clearCache" data-params="clear,2week">{{label_cache_week2}}<div></div></label> \
						<label id="s-m-cache-clear-month-id" class="btn btn-primary s-m-cache-btn" data-action="clearCache" data-params="clear,month">{{label_cache_month}}<div></div></label> \
					</div> \
					<div style="display:table-row;"> \
					<label id="s-m-cache-confirm-id" class="btn btn-primary s-m-confirm" data-action="clearCache" data-params="confirm,all" style="display: none;">{{label_cache_confirm}}</label> \
					<label id="s-m-cache-cancel-id" class="btn btn-warning s-m-cancel" data-action="clearCache" data-params="cancel" style="display: none;">{{label_cancel}}</label> \
					</div> \
					<div id="s-m-cache-progress-id" class="progress" style="display: none;"> \
						<div class="progress-bar progress-bar-striped active" role="progressbar" aria-valuenow="45" aria-valuemin="0" aria-valuemax="100" style="width: 100%">{{label_clearing}}</div> \
					</div> \
					\
					<div id="s-m-cache-ok-id" class="alert alert-success" role="alert" style="display: none">{{label_clearing_ok}}</div> \
					<div style="width:100%; display: inline-block;"></div> \
				</div> \
			</div>',

	footer: '',
};

function _getCache() {
	return modules.get("cache").getCache();
};
var _Klass = utils.defineClass(
	function ModalSettings(settings) {
		var self = this;
		modalDialog.ModalBase.call(self);

		self.settings = settings && $.extend(true, {}, settings) || {};
		self.settings["device-type"] = self.settings["device-type"] || "auto";

		// Result
		self.result = null;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll,
				smartphone: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "settings half_right";
			} else {
				displayFlags.modalClass = "settings full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			var data = {
				title: locale.text("settings.title"),

				label_device: locale.text("settings.device.label"),
				label_auto: locale.text("settings.device.auto"),
				label_smartphone: locale.text("settings.device.smartphone"),
				label_tablet: locale.text("settings.device.tablet"),

				label_cache: locale.text("settings.cache.label"),
				label_cache_clear: locale.text("settings.cache.clear"),
				label_cache_week1: locale.text("settings.cache.week1"),
				label_cache_week2: locale.text("settings.cache.week2"),
				label_cache_month: locale.text("settings.cache.month"),
				label_cache_all: locale.text("settings.cache.all"),
				label_cache_confirm: locale.text("settings.cache.confirm"),

				label_clearing: locale.text("settings.cache.clearing"),
				label_clearing_ok: locale.text("settings.cache.clearing_ok"),

				label_apps: locale.text("settings.apps.label"),
				label_apps_update: locale.text("settings.apps.update"),
				label_apps_confirm: locale.text("settings.apps.confirm"),

				label_apps_wait: locale.text("settings.apps.wait"),
				label_apps_ok: locale.text("settings.apps.ok"),

				label_cancel: "", //locale.text("settings.cache.cancel"),
			};
			if (native.hasCapability("nativeApp")) {
				data.showConfigServers = true;
				data.label_servers = locale.text("settings.servers.servers");
				data.label_switch_server = locale.text("settings.servers.switch");
			}
			return data;
		},
		_onShow: function() {
			var self = this;
			modalDialog.ModalBase.prototype._onShow.call(self);

			// Apply UI states
			$("label[data-params='" + self.settings["device-type"] + "']", self.$$elmt).eq(0).button("toggle");

			self._computeCacheSize();
		},
		// could be removed, result is set in _onAction
		_onValidate: function() {
			var self = this;
			var $$active = $("#s-m-radio-type-id .active ", this.$$elmt);
			var deviceType = $$active.length < 1 ? "auto" : $$active.attr("data-params") || "auto";
			self.settings["device-type"] = deviceType;
			self.result = self.settings;
		},
		_onCancel: function() {
			var self = this;
			self.result = null;
		},

		_onAction: function(action, param) {
			var self = this;
			switch (action) {
				case "clickType":
					$("label[data-params='" + param + "']", self.$$elmt).eq(0).button("toggle");
					break;
				case "clearCache":
					self._clearCache(param);
					break;
				case "selectServer":
					if (native.hasCapability("nativeApp")) {
						native.getModule("nativeApp").selectServer();
					}
					return true; // Close settings if we go to server config
					break;
			}
			// dont close on actions
			return false;
		},


		_clearCache: function(param) {
			var self = this;
			var p = param.split(",");
			var action = p[0];
			var data = p[1];
			self._setButtons("clearCache", "cache", action, data);
			if (action === "confirm") {
				// data: 1week, 2week, month, all
				var dt = self._getDateBefore(_cacheOptions[data].days);
				return _getCache().clearCache({
						$not_read_since: dt
					})
					.always(function() {
						self._setButtons("clearCache", "cache", "ok", "");
						self._computeCacheSize();
					});
			}
		},

		_setButtons: function(action, prefix, state, data) {
			var self = this;
			switch (state) {
				case "confirm":
					$("#s-m-" + prefix + "-progress-id", self.$$elmt).show();
					$("#s-m-" + prefix + "-confirm-id", self.$$elmt).hide();
					$("#s-m-" + prefix + "-cancel-id", self.$$elmt).hide();
					break;
				case "cancel":
					$("#s-m-" + prefix + "-btns-id", self.$$elmt).show();
					$("#s-m-" + prefix + "-confirm-id", self.$$elmt).hide();
					$("#s-m-" + prefix + "-cancel-id", self.$$elmt).hide();
					break;
				case "clear":
					$("#s-m-" + prefix + "-confirm-id", self.$$elmt).show();
					$("#s-m-" + prefix + "-cancel-id", self.$$elmt).show();
					$("#s-m-" + prefix + "-btns-id", self.$$elmt).hide();
					$("#s-m-" + prefix + "-confirm-id", self.$$elmt).attr("data-params", "confirm," + (data || ""));
					break;
				case "ok":
					$("#s-m-" + prefix + "-progress-id", self.$$elmt).hide();
					$("#s-m-" + prefix + "-ok-id", self.$$elmt).show();
					setTimeout(function() {
						$("#s-m-" + prefix + "-ok-id", self.$$elmt).hide();
						$("#s-m-" + prefix + "-btns-id", self.$$elmt).show();
					}, 3000);
					break;
			}
		},

		_getDateBefore: function(days) {
			if (!days) {
				return "9999-99-99-00-00-00";
			}
			var today = new Date();
			var dt = new Date(today);
			dt.setDate(today.getDate() - days);
			dt = dt.toJSON().slice(0, 10) + "-00-00-00";
			return dt;
		},

		_computeCacheSize: function() {
			var self = this;
			Object.keys(_cacheOptions).forEach(function(co) {
				var dt = self._getDateBefore(_cacheOptions[co].days);
				return _getCache().computeCacheSize({
						$not_read_since: dt
					})
					.always(function(result) {
						self._updateCacheSize(co, result);
					});
			});
		},

		_updateCacheSize: function(key, result) {
			var self = this;
			var $$div = $("#s-m-cache-clear-" + key + "-id > div", self.$$elmt);

			var units = [locale.text("global.units.kilobytes"),
				locale.text("global.units.megabytes")
			];

			$$div.empty();
			if (result && result.$data) {
				var size = result.$data.sizeRecords;
				var sizeUnit = locale.text("global.units.bytes");
				while (size >= 1024 && units.length > 0) {
					size = (size + 1023) / 1024;
					sizeUnit = units.shift();
				}
				var sizeText = Math.round(size) + " " + sizeUnit;
				$$div.append($("<span>" + result.$data.numRecords + " " + locale.text("global.units.files") + "</span><span>" + sizeText + "</span>"));
			}
		},

		_getResult: function() {
			var self = this;
			return self.result;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalSelectContext',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				{{#unless label_offline}} \
				<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
				{{/unless}} \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
			<div class="s-m-scroll-element"> \
				{{#if label_warning}}\
					<div class="alert alert-warning" role="alert">\
						{{label_warning}}\
					</div>\
				{{/if}}\
				{{#if label_offline}}\
					<div class="alert alert-warning" role="alert">\
						{{label_offline}}\
					</div>\
				{{/if}}\
				{{#if showRoles}} \
				<div class="form-group"> \
					<label>{{label_roles}}</label>\
					<select class="form-control" id="login-select-role"> \
					{{#each roles}}\
						<option value="{{this.code}}" {{#if this.selected}}selected{{/if}}>\
						{{this.description}}\
						</option>\
					{{/each}}\
					</select>\
				</div> \
				{{/if}} \
				<div class="form-group" id="login-select-endpoint-group"> \
					<label>{{label_endpoints}}</label>\
					<select class="form-control" id="login-select-endpoint"> \
					{{#each endpoints}}\
						<option value="{{this.code}}" {{#if this.selected}}selected{{/if}}>\
						{{this.description}}\
						</option>\
					{{/each}}\
					</select>\
				</div> \
				{{#if showLanguages}} \
				<div class="form-group"> \
					<label>{{label_languages}}</label>\
					<select class="form-control" id="login-select-language"> \
					{{#each languages}}\
						<option value="{{this.code}}" {{#if this.selected}}selected{{/if}}>\
						{{this.description}}\
						</option>\
					{{/each}}\
					</select>\
				</div> \
				{{/if}} \
			</div> \
			</div>',
	footer: ''
};
var _myTemplates = {
	endpoints: '\
		{{#each endpoints}}\
				<option value="{{code}}" {{#if selected}}selected{{/if}}>{{description}}{{#unless description}}{{code}}{{/unless}}</option>\
		{{/each}}'
};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _myTemplates[key];
	if (!tmpl) {
		tmpl = _myTemplates[name];
		tmpl = _myTemplates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};
var _Klass = utils.defineClass(
	function ModalSelectContext(currentContext, settings) {
		modalDialog.ModalBase.call(this);
		this._currentContext = currentContext;
		this._settings = settings;
	}, modalDialog.ModalBase, {
		destroy: function() {
			if (this._$$roles) {
				this._$$roles.off();
				this._$$roles = null;
			}
			if (this._$$endpoints) {
				this._$$endpoints = null;
			}
			modalDialog.ModalBase.prototype.destroy.call(this);
		},

		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "select-context half_right";
			} else {
				displayFlags.modalClass = "select-context full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			var roles = self._getRoles();
			var languages = self._getLanguages();
			var endpoints = self._getEndpoints(roles);

			var showRoles = self._settings.offline !== true && roles.length > 1;
			var showLanguages = self._settings.offline !== true && languages.length > 1;

			var label_warning = locale.text("modal.context.warning");
			var label_offline = locale.text("modal.context.offline2");

			if (self._settings.offline === true) {
				label_warning = null;
			} else {
				label_offline = null;
			}

			var data = {
				title: locale.text("modal.context.title"),
				label_endpoints: locale.text("modal.context.endpoints"),

				endpoints: endpoints,

				label_roles: locale.text("modal.context.roles"),
				showRoles: showRoles,
				roles: roles,

				label_languages: locale.text("modal.context.languages"),
				showLanguages: showLanguages,
				languages: languages,

				label_ok: locale.text("modal.context.ok"),
				label_cancel: locale.text("modal.context.cancel"),

				label_warning: label_warning,
				label_offline: label_offline,
			};
			return data;
		},

		/*
		 * 
		 */
		_getRoles: function() {
			var self = this;
			var roles = self._settings && self._settings.profile.roles || [];
			roles.forEach(function(r) {
				r.selected = r.code === self._currentContext.role;
			});
			return roles;
		},
		_getLanguages: function() {
			var self = this;
			var languages = self._settings && self._settings.profile.locales || [];
			languages.forEach(function(lang) {
				lang.selected = lang.code === self._currentContext.lang;
			});
			return languages;
		},
		_getEndpoints: function(role) {
			var self = this;
			var endpoints;
			self._getRoles().some(function(r) {
				if (role && r.code === role || role == null && r.selected === true) {
					endpoints = r.endPoints;
					return true;
				}
			});
			endpoints = endpoints || [];
			endpoints.forEach(function(ep) {
				ep.selected = ep.code === self._currentContext.endpoint;
			});
			return endpoints;
		},

		_attachDOM: function() {
			modalDialog.ModalBase.prototype._attachDOM.call(this);
			this._$$roles = this.$$elmt.find("#login-select-role");
			if (this._$$roles.length > 0) {
				this._$$roles.on('change', jsutils.bindFn(this.onRoleChanged, this));
			}
			this._$$endpoints = this.$$elmt.find("#login-select-endpoint");
			this._$$endpointsGroup = $("#login-select-endpoint-group");

			this.onRoleChanged();
		},
		onRoleChanged: function() {
			var self = this;
			var role = self._$$roles.val();
			var endpoints = self._getEndpoints(role);
			this._$$endpoints.html(_getHtml("endpoints", {
				endpoints: endpoints
			}));

			if (endpoints.length > 1) {
				this._$$endpointsGroup.show();
			} else {
				this._$$endpointsGroup.hide();
			}
		},
		/**
		 * Overridden
		 */
		_onValidate: function() {
			var self = this;
			var endpoint = self._$$endpoints.val();
			var role = self._$$roles.val();
			var language = self.$$elmt.find("#login-select-language").val();

			self.result = {
				"action": "ok",
				"endpoint": endpoint,
				"role": role,
				"language": language
			};
		},

		/**
		 * Overridden
		 */
		_onCancel: function() {
			var self = this;
			self.result = {
				"action": "cancel"
			};
		},
		/**
		 * Overridden
		 */
		_getResult: function() {
			return this.result;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalShowLegal',['require','exports','module','syracuse-tablet/html/js/app/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/helpers/types/date','syracuse-tablet/html/js/common/ajax'],function (require, exports, module) {

var globals = require('syracuse-tablet/html/js/app/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var date = require('syracuse-tablet/html/js/helpers/types/date');
var ajax = require('syracuse-tablet/html/js/common/ajax');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
			<div class="s-m-scroll-element"> \
				<div class="form-group"> \
					<div class="s-m-header-brand"> \
						<span class="s-m-brand">{{label_brand}}</span> \
						<span class="s-m-product">{{label_product}}</span> \
					</div> \
					<span class="s-m-product-update-label">{{label_update}}</span><span class="s-m-product-update-value">{{update}}</span> \
				</div> \
				<div class="form-group"> \
					<h3>{{label_legal}}</h3> \
					<label>{{text1}}</label> \
					<label>{{text2}}</label> \
					<label>{{text3}}</label> \
					<label>{{text4}}</label> \
					<label>{{text5}}</label> \
					<label>{{text6}}</label> \
				</div> \
				{{#if licenses}} \
				<div class="form-group"> \
					<h3>{{label_license}}</h3> \
					{{#each licenses}} \
						<div class="s-m-field"><div class="s-m-title">{{../label_registrationNumber}}</div><div class="s-m-value">{{toRegNum}}</div></div> \
						<div class="s-m-field"><div class="s-m-title">{{../label_licensedTo}}</div><div class="s-m-value">{{toName}}</div></div> \
						<div class="s-m-field"><div class="s-m-title">{{../label_reference}}</div><div class="s-m-value">{{toRefNum}}</div></div> \
						<div class="s-m-field"><div class="s-m-title">{{../label_installedBy}}</div><div class="s-m-value">{{installedBy}}</div></div> \
						<div class="s-m-field"><div class="s-m-title">{{../label_expiryDate}}</div><div class="s-m-value">{{expiryDate}}</div></div> \
					{{/each}} \
				</div> \
				{{/if}} \
				{{#if userAgent}} \
					<h3>{{label_user_agent}}</h3> \
					<div class="form-group"> \
						<label>{{userAgent}}</label> \
					</div> \
				{{/if}} \
				{{#if builddate}} \
					<div class="form-group"> \
						<label>{{builddate}}</label> \
					</div> \
				{{/if}} \
			</div> \
			</div>',
	footer: ''
};

var _Klass = utils.defineClass(
	function ModalShowLegal() {
		var self = this;
		modalDialog.ModalBase.call(self);
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "show-legal half_right";
			} else {
				displayFlags.modalClass = "show-legal full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			return ajax.request("/sdata/syracuse/collaboration/syracuse/licenses/$service/current")
				.then(function(result) {
					var data = result.data;
					var version = null;
					var licenses = [];
					if (data && data.length > 0) {
						data.forEach(function(lic) {
							var l = {};
							l.expiryDate = locale.text("modal.legal.license.expiryDateValue", [date.getLocalShortDate(lic.validFrom), date.getLocalShortDate(lic.expiryDate)]);
							l.toName = lic.licensedTo.name;
							l.toRegNum = lic.licensedTo.registrationNumber;
							l.toRefNum = lic.licensedTo.reference;
							l.installedBy = lic.reseller.name;

							licenses.push(l);
							if (!version) {
								version = lic.productVersion;
							}
						});
						return {
							version: version,
							licenses: licenses
						};
					}
				})
				.then(function(licData) {
					var labels = locale.getProductLabels();
					var showBuildDate = window.location.href.indexOf("SHOW_VERSION_NUMBER") > -1;
					var pageInfo;

					var data = {
						title: locale.text("modal.legal.title"),
						label_brand: labels.brand,
						label_product: labels.product,
						label_update: locale.text("modal.legal.update"),
						label_license: locale.text("modal.legal.about.license"),
						label_legal: locale.text("modal.legal.about.legal"),
						label_user_agent: locale.text("modal.legal.about.user_agent"),
						update: (licData && licData.version) || "?",
						licenses: licData && licData.licenses,
						builddate: showBuildDate && locale.text("modal.legal.builddate", [globals.getBuildTimeStamp()]),
						text1: locale.text("modal.legal.text1"),
						text2: locale.text("modal.legal.text2"),
						text3: locale.text("modal.legal.text3"),
						text4: locale.text("modal.legal.text4"),
						text5: locale.text("modal.legal.text5"),
						text6: locale.text("modal.legal.text6"),
						label_registrationNumber: locale.text("modal.legal.license.registrationNumber"),
						label_licensedTo: locale.text("modal.legal.license.licensedTo"),
						label_reference: locale.text("modal.legal.license.reference"),
						label_userLicense: locale.text("modal.legal.license.userLicense"),
						label_installedBy: locale.text("modal.legal.license.installedBy"),
						label_server: locale.text("modal.legal.license.server"),
						label_expiryDate: locale.text("modal.legal.license.expiryDate"),
						userAgent: jsutils.isDvlpVersion() ? navigator.userAgent : ""
					};

					return data;
				});
		},

		_onValidate: function() {},

		_onCancel: function() {},

		_getResult: function() {}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/pages/attachedControlsMgr',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var modules = require('syracuse-tablet/html/js/common/modules');

/**
 * 
 */
exports.AttachedControlsMgr = utils.defineClass(
	function AttachedControlsMgr(page) {
		this.page = page;
		this.controls = [];
	},
	null, {
		destroyControls: function() {
			this.controls.forEach(function(control) {
				control.control.destroy();
			});
			this.controls = [];
		},
		destroy: function() {
			this.destroyControls();
			this.page = null;
		},
		/**
		 * hidden: the control is not displayed in the page (use toggleControls to show it)
		 */
		createControl: function(info, options, hidden) {
			var self = this;

			if (self.findByName(info.name) != null) {
				throw new Error("There can only be one control for a unique name");
			}

			var ctrlFactory = modules.get("ctrlFactory");
			var ctrl = ctrlFactory.createControl(self.page.controller, {
				$type: info.$type
			}, null, null, options);
			if (ctrl) {
				ctrl.attachedControlsMgr = self;
				ctrl.attachedControlInfo = info;

				ctrl.setActionAdapter && ctrl.setActionAdapter(self.page.actionAdapter);
				var c = $.extend(true, {}, info, {
					control: ctrl,
					isVisible: hidden !== true
				});
				self.controls.push(c);
			}
			return ctrl;
		},
		/**
		 * Create a control outside initialization process
		 * This control is hidden by default
		 * 
		 */
		createAddtionalControl: function(panelInfo, options) {
			var ctrl = this.createControl(panelInfo, {}, true);
			this.ensureControl$$container(ctrl, panelInfo);
			ctrl.buildHtml();
			return ctrl;
		},
		/**
		 * Search the container dedicated to enclose the control and set it for the control
		 */
		ensureControl$$container: function(control, attachedControlInfo) {
			var page;
			if (this.page.isVignette() && attachedControlInfo.vignetteSelectorUseParent) {
				page = this.page.parentPage;
			} else {
				page = this.page;
			}
			var $$container = page.$$elmt.find(attachedControlInfo.selector).first();
			if (!$$container || $$container.length < 1) {
				console.log("Container for control not found: " + attachedControlInfo.selector);
			}
			control.set$$container($$container);
			control.page = page;
		},
		/**
		 * Returns a CtrlBase object
		 */
		findByName: function(name) {
			var entry = this._findEntryByName(name);
			return entry && entry.control;
		},
		/**
		 * Returns a controls entry object
		 */
		_findEntryByName: function(name) {
			var entry = null;
			this.controls.some(function(control) {
				if (name === control.name) {
					entry = control;
					return true;
				}
			});
			return entry;
		},
		_findEntryByControl: function(ctrl) {
			var entry = null;
			this.controls.some(function(control) {
				if (ctrl === control.control) {
					entry = control;
					return true;
				}
			});
			return entry;
		},
		buildHtml: function() {
			var self = this;
			self.controls.forEach(function(control) {
				self.ensureControl$$container(control.control, control.control.attachedControlInfo);
				control.control.buildHtml();
			});
		},
		computeLayout: function(context) {
			this.controls.forEach(function(control) {
				if (control.control.computeLayout) {
					control.control.computeLayout(context);
				}
			});
		},
		/**
		 * 
		 */
		computeMainLayout: function(layoutInfo) {
			var self = this;
			var mainLayout = {
				contentTop: 0,
				contentLeft: 0,
				contentHeight: layoutInfo.application.height,
				contentWidth: layoutInfo.application.width
			};
			var tops = [];
			var bottoms = [];
			var bottomsHeight = 0;
			self.controls.forEach(function(control) {
				if (control.isVisible !== true) {
					return;
				}
				if (control.topIndex != null) {
					tops[control.topIndex] = control;
				}
				if (control.bottomIndex != null) {
					bottoms[control.bottomIndex] = control;
					bottomsHeight += control.control.getDesiredHeight();
				}
			});
			var top = 0;
			var heightSubstract = 0;
			tops.forEach(function(control) {
				if (control == null) {
					return;
				}
				var height = control.control.getDesiredHeight();
				control.control.setTop(top);
				heightSubstract = heightSubstract + height;
				top = top + height;
			});
			mainLayout.contentTop = top;
			top = mainLayout.contentHeight - bottomsHeight;
			bottoms.forEach(function(control) {
				if (control == null) {
					return;
				}
				var height = control.control.getDesiredHeight();
				control.control.setTop(top);
				heightSubstract = heightSubstract + height;
				top = top + height;
			});
			mainLayout.contentHeight -= heightSubstract;
			return mainLayout;
		},
		/**
		 * Toggle the control name1 (force show/hide if show == true/false)
		 * Toggle the control name2 to the reverse status of name1
		 * Returns true if new status is visible
		 */
		toggleControls: function(name1, name2, show) {
			var wasVisible = this.isVisible(name1);
			show = show == null ? !wasVisible : show;
			if ((wasVisible && show) || (!wasVisible && !show)) {
				return;
			}
			var self = this
			var ctrls = [{
				name: name1,
				show: show
			}, {
				name: name2,
				show: !show
			}];
			ctrls.forEach(function(i) {
				var entry = self._findEntryByName(i.name);
				if (!entry) {
					return;
				}
				entry.control.$$elmt.toggle(i.show);
				entry.isVisible = i.show;
				if (i.show) {
					entry.control.computeLayout();
				}
			})
			return show;
		},
		/**
		 * nameOrCtrl is string or CtrlBase
		 */
		isVisible: function(nameOrCtrl) {
			if (!nameOrCtrl) {
				return false;
			}
			var entry;
			if (typeof nameOrCtrl === "string") {
				entry = this._findEntryByName(nameOrCtrl);
			} else {
				entry = this._findEntryByControl(nameOrCtrl);
			}
			return entry && entry.isVisible === true;
		}
	});
});

define('syracuse-tablet/html/js/pages/pageBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controllers/controller','syracuse-tablet/html/js/pages/attachedControlsMgr','syracuse-tablet/html/js/app/settings','syracuse-tablet/html/js/ui/siteLayout','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/scroller/scrollerHelpers','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Controller = require("syracuse-tablet/html/js/controllers/controller").Controller;
var AttachedControlsMgr = require('syracuse-tablet/html/js/pages/attachedControlsMgr').AttachedControlsMgr;
var settings = require('syracuse-tablet/html/js/app/settings');
var siteLayout = require('syracuse-tablet/html/js/ui/siteLayout');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var _id = 1;
var _templates = {};
var _html = {
	fullpage: '\
		<section class="s-m-page s-m-full {{device}}" id="{{pageId}}" style="display: none" data-page-name="{{pageName}}"> \
			<header></header> \
			<section class="s-m-breadcrumbs" style="display:none"></section> \
			<section class="s-m-topToolbar"  style="display:none"></section> \
			<section class="s-m-main-content" data-s-m-content=""></section> \
			<footer style="display:none"></footer> \
		</section> \
	',
	vignette: '<section class= "s-m-page s-m-nested" id="{{pageId}}" style="display: none;" data-page-name="{{pageName}}"></section>',
	panelContainers: '\
		<div class="s-m-side-panel-dismiss" data-nevent data-naction="closePanel"></div> \
		<aside class="s-m-panel s-m-left"></aside> \
		<aside class="s-m-panel s-m-right"></aside>'

}
var _getHtml = function(name, ctx) {
	var tmpl = _templates[name];
	if (!tmpl) {
		tmpl = _templates[name] = Handlebars.compile(_html[name]);
	}
	return tmpl(ctx || {});
};

var _pages = {};

/**
 * options:
 * {
 *   isChild: true|false
 *   isVignette: true|false
 * }
 */
exports.Page = utils.defineClass(
	function PageBase(pageName, options) {
		options = options || {};
		options.nativeCapabilities = options.nativeCapabilities || {}
		this.pageName = pageName || "noname";
		this.id = _id++;
		_pages[this.id] = this;
		this.options = options || {};
		// set from outside, in here we want to load the page
		this.$$container = null;
		// root element of the page
		this.$$elmt = null;
		// element where the main page content is rendered to
		this.$$contentElmt = null;
		this.controller = null;
		// When a page is loaded inside a vignette, parentPage will point to the dashboard containing the vignette
		this.parentPage = null;
		// Vignette that embeds the page if any
		this.parentVignette = null;
		this.parentPage = null;
		if (options.isVignette) {
			this.parentVignette = options.parentVignette;
			this.parentPage = options.parentPage;
		}
		this.attachedControlsMgr = new AttachedControlsMgr(this);
		// Let page subclasses define their own controller if needed
		this._ensureController();
	},
	null, {
		/** 
		 * Override to create a specialized controller
		 */
		_ensureController: function() {
			this.controller = new Controller(null);
		},
		destroy: function() {
			this.destroyed = true;
			this.unbuild();
			delete _pages[this.id];
			this.parentVignette = null;
			this.parentPage = null;
			if (this.controller) {
				this.controller.destroy();
				this.controller = null;
			}
			if (this.attachedControlsMgr) {
				this.attachedControlsMgr.destroy();
				this.attachedControlsMgr = null;
			}
		},
		/**
		 * Release resources that will be re-allocated on build
		 */
		unbuild: function() {
			if (this.attachedControlsMgr) {
				this.attachedControlsMgr.destroyControls();
			}

			if (this.$$elmt) {
				this.$$elmt.unbind();
				this.$$elmt.remove();
			}

			this.$$elmt = null;
			this.$$contentElmt = null; // Element in DOM which contains all content and eventually a scroller
			this.$$contentRoot = null; // Put content in here: Element in DOM that is eventually scrollable, could be the same as $$contentElmt if no scrolling is desired
			this.$$scrollWrapper = null; // Don't forget this otherwise scrolling is frozen
		},
		// Return true whenever pushing this page onto the page stack
		// should clear the history and make this page the only one 
		// existing the the history (e.g. login, logout, home)
		isRootPage: function() {
			return false;
		},
		// For pages that must not be added to the history.
		// e.g. Login, logout
		isNoHistory: function() {
			return false;
		},
		set$$container: function($$container) {
			this.$$container = $$container;
		},

		/**
		 * Should be called by all subclasses
		 */
		createRootElement: function() {
			var tplName = "fullpage";
			if (this.isVignette()) {
				tplName = "vignette";
			}

			var ctx = {
				pageId: this.id,
				pageName: this.pageName,
				device: siteLayout.getDeviceType(),
			};
			this.$$elmt = $(_getHtml(tplName, ctx));
			this.$$contentElmt = this.$$elmt.find('[data-s-m-content]'); // Is there a children flagged to be the content holding element
			if (this.$$contentElmt.length === 0) {
				this.$$contentElmt = this.$$elmt; // Use root element for page content if no other element is flagged to be used
			}
			this.$$contentRoot = this.$$contentElmt;

			if (!this.isVignette()) {
				this.$$elmt.append($(_getHtml("panelContainers")));
			}
			this.$$container.append(this.$$elmt);
		},

		hide: function() {
			if (!this.$$elmt) {
				return;
			}
			this.$$elmt.hide();
		},
		/**
		 * noCompute: 	true 	to not compute the layout
		 * 						Eg: 	when we show a 'cached' page we just display it with recomputing
		 * 								if it's a vignette page we also do'nt compute the page (done once all the pages have been loaded)
		 * 				false 	(default) we compute the layout
		 * 						We need to compute the layout once the control are visible because we need height/width (scrolling, cards, layouts stack/ub...)
		 * 						
		 */
		show: function(noCompute) {
			if (!this.$$elmt) {
				return $.smResolve();
			}
			this.$$elmt.show();
			var self = this;
			return $.smResolve().then(function() {
				/**
				 * Compute the layout once that page is visible
				 * It's mandatory to calculate fixed width 
				 * For a vignette computeLayout is called by the dashboard once all the vignettes have been loaded
				 */
				if (noCompute !== true && !self.isVignette()) {
					self.computeLayout();
				}
				/**
				 * Else nothing has to be restored
				 * Perhaps if we change the size of the child page we should recalculate the layout of the parent on back (not usual)
				 */
			})
		},

		/**
		 * computeLayout is called when the page is shown (show method)
		 */
		build: function() {
			var self = this;

			return $.smResolve()
				.then(function() {
					return self.createRootElement();
				})
				.then(function() {
					return self.initStructure && self.initStructure();
				})
				.then(function() {
					self._initScrolling();
					return self.render && self.render();
				})
				.then(function() {
					return self.afterRender && self.afterRender();
				})
				.then(function() {
					self.onPageDataChanged();
				})
				.then(function() {
					notifications.publish(["sm.page.loaded"], self);
				});
		},

		initStructure: function() {
			this.createAttachedControls();
		},
		/**
		 * context: 
		 */
		computeLayout: function(context) {
			this.$$elmt.removeClass("landscape portrait");
			this.$$elmt.addClass(siteLayout.getPageOrientation());
			var layoutInfo = siteLayout.getLayoutInfo();
			if (!this.isVignette()) {
				var mainLayout = this.attachedControlsMgr.computeMainLayout(layoutInfo);
				this.$$contentElmt.css({
					top: mainLayout.contentTop + "px",
					left: mainLayout.contentLeft + "px",
					width: mainLayout.contentWidth + "px",
					height: mainLayout.contentHeight + "px"
				});
			} else {
				/**
				 * For vignette we don't calculate the H/W in pixels.
				 * To do the calculatation we need to propagate the calculation from dashboard tile -> Control (not done and needed)
				 * H/W calculation is based on css style height auto for the wrapper et 100% for $$contentElmt
				 */
			}
			this.mainContentRect = uiRect.elmtRect(this.$$contentElmt, "outer");
			this.mainContentNoPaddingRect = uiRect.elmtRect(this.$$contentElmt, "computed");
			layoutInfo.pageContentRect = this.mainContentRect;
			layoutInfo.pageContentNoPaddingRect = this.mainContentNoPaddingRect;
			// Compute controls layout
			this.computeControlsLayouts($.extend(true, context, layoutInfo));
			// Update scrolling at the end
			this._updateScrolling();
			// Restore context on first compute
			if (this.options.savedCtx) {
				this.savedCtxRestore(this.options.savedCtx);
				delete this.options.savedCtx;
			}
		},

		/**
		 * Can be overridden - sDataPage compute from rootLayout
		 */
		computeControlsLayouts: function(context) {
			// Compute layouts for attached controls
			if (this.attachedControlsMgr) {
				this.attachedControlsMgr.computeLayout(context);
			}
		},

		//
		// START: Scrolling stuff
		//


		/**
		 * True if scroll enabled in page
		 * By default we can scroll a page in full display
		 * In vignettes only details/edit facet are allowed to scroll - See regular page
		 * In Dashboard hub this is the layout that scrolls - Page doesn't scroll
		 */
		scrollAllowed: function() {
			return !this.isVignette() && !this.isDashboard("hub");
		},

		/**
		 * Override for pages that do not want scrolling
		 */
		_initScrolling: function(preserveScroll) {
			if (!this.scrollAllowed() || this.$$scrollWrapper) {
				return;
			}
			this.$$scrollWrapper = $('<div class="s-m-scroll-wrapper"/>').appendTo(this.$$contentRoot);
			this.$$scrollWrapper.css({
				height: "auto"
			});
			this.$$contentRoot = this.$$scrollWrapper;
			this._gestureMgr = scroller.newScroller(this.$$scrollWrapper, {
				isPageScroller: true // !self.isVignette
			});
		},
		_updateScrolling: function(preserveScroll) {
			if (!this._gestureMgr || !this.$$elmt.is(":visible")) {
				return;
			}
			if (!this.scrollAllowed()) {
				this._gestureMgr.reset();
				return;
			}
			var viewRect = this.isVignette() ? this.parentVignette.getScrollViewRect() : this.mainContentRect;
			if (!viewRect || viewRect.height >= this.$$scrollWrapper.height()) {
				this._gestureMgr.reset();
				return;
			}
			var valMax = 0;
			// If not new -> back on a cached page - We keep scrolling
			preserveScroll = preserveScroll === true;
			// viewRect has fixed coordinate to check if the 'finger' is inside on mousemouve event
			// A page always scolls vertically - In dashboard this is the layout that scrolls horizontally
			this._gestureMgr.init(viewRect, "v", valMax, preserveScroll);
			var autoScroll = this.options["auto-scroll"];
			if (autoScroll != null) {
				// When we go to $edit form $details we keep the scrolling in order to stay at the same location (see actionManager)
				this.autoScroll(autoScroll);
				// Only when we loadd the page
				this.options["auto-scroll"] = undefined;
			}
			var viewRect = this.isVignette() ? this.parentVignette.getScrollViewRect() : this.mainContentRect;
			if (!viewRect || viewRect.height >= this.$$scrollWrapper.height()) {
				this._gestureMgr.reset();
			}
		},

		/**
		 * Called by controls that have an impact on the page size after loading
		 * Currently, this are only vignettes
		 */
		onContentChanged: function() {
			this._updateScrolling();
		},

		//
		// END: Scrolling stuff
		//

		getPageTitle: function() {
			return "";
		},

		createAttachedControls: function() {
			var self = this;
			var names = self._getDefaultAttachedControls();
			names.forEach(function(name) {
				var info = self._getAttachedControlInfo(name);
				if (info) {
					self.attachedControlsMgr.createControl(info);
				}
			});
		},

		/**
		 * Get logical name of controls that are usually attached to a page
		 * 
		 * Can be overriden per page if necessarry
		 * @returns
		 */
		_getDefaultAttachedControls: function() {
			if (this.isVignette()) {
				return [];
			}
			var device = siteLayout.getDeviceType();
			if (device === "smartphone") {
				return ["header"];
			} else {
				var res = ["header", "footer"];
				/* it has been decided to not show Breadcrumbs any more (UX team!)
				if (!this.isHome() && modules.get("navStack").getMainStack().count() > 1) {
					res.push("breadcrumbs");
				}
				*/
				return res;
			}
		},

		/**
		 * Get detail information on how to create a logical control
		 * E.g. device dependent header
		 * 
		 * Can be overriden per page if necessarry
		 * 
		 * @param name
		 * @returns
		 */
		_getAttachedControlInfo: function(name) {
			var device = siteLayout.getDeviceType();
			var defaults = {
				smartphone: {
					header: {
						topIndex: 0,
						selector: "header",
						$type: "application/x-panel-header-sdata-page-smartphone"
					},
					actionsPanel: {
						selector: "aside.s-m-panel.s-m-right",
						$type: "application/x-panel-actions"
					},
					globalPanel: {
						selector: "aside.s-m-panel.s-m-left",
						$type: "application/x-panel-global-smartphone"
					},
					filterSortPanel: {
						selector: "aside.s-m-panel.s-m-right",
						vignetteSelectorUseParent: true,
						$type: "application/x-panel-filtersort"
					},
					sharePanel: {
						selector: "aside.s-m-panel.s-m-left",
						vignetteSelectorUseParent: true,
						$type: "application/x-panel-share"
					}
				},
				tablet: {
					header: {
						topIndex: 0,
						selector: "header",
						$type: "application/x-panel-header-sdata-page-tablet"
					},
					breadcrumbs: {
						topIndex: 1,
						selector: ".s-m-breadcrumbs",
						$type: "application/x-panel-breadcrumbs-tablet"
					},
					footer: {
						bottomIndex: 0,
						selector: "footer",
						$type: "application/x-panel-footer-sdata-page"
					},
					actionsPanel: {
						selector: "aside.s-m-panel.s-m-right",
						$type: "application/x-panel-actions"
					},
					globalPanel: {
						selector: "aside.s-m-panel.s-m-right",
						$type: "application/x-panel-global-tablet"
					},
					filterSortPanel: {
						selector: "aside.s-m-panel.s-m-right",
						vignetteSelectorUseParent: true,
						$type: "application/x-panel-filtersort"
					},
					chartDetailToolBar: {
						topIndex: 2,
						selector: ".s-m-topToolbar",
						$type: "application/x-chartdetail-toolbar"
					},
					sharePanel: {
						selector: "aside.s-m-panel.s-m-right",
						$type: "application/x-panel-share"
					}
				}
			};

			var info = defaults[device][name];
			info.name = name;
			return info;
		},
		openPanel: function(name, options) {
			var panel = this.attachedControlsMgr.findByName(name);
			if (!panel) {
				var info = this._getAttachedControlInfo(name);
				if (info) {
					panel = this.attachedControlsMgr.createControl(info, options);
				}
			}
			if (!panel) {
				return;
			}
			return panel
		},
		_actOpenGlobalPanel: function() {
			var panel = this.openPanel("globalPanel");
			if (panel) panel.show();
		},
		_actPageShare: function() {
			var panel = this.openPanel("sharePanel");
			panel.show();
		},
		/**
		 * Should do:
		 * - Destroy and re-create page specific controls like header/footer depending on the page size/device
		 *   (also this is mostly a development use case)
		 * - Close opened panels and popups 
		 */
		onMainPageResize: function(info, orientation, deviceType) {
			if (info.deviceChanged == true && this.attachedControlsMgr) {
				// Rebuild header/footer.. according to deviceType
				this.attachedControlsMgr.destroyControls();
				this.createAttachedControls();
				this.attachedControlsMgr.buildHtml();

			}
			this.computeLayout();
		},
		/**
		 * Called by navigator whenever the page will be closed because of a back action
		 * The back action will be done as soon as the given deferred is resolved with "true"
		 * Resolving with "false" will cancel the back action
		 * Rejecting will show the error given to reject
		 */
		onBackAction: function(def) {
			// Default is to accept back
			def.resolve(true);
		},
		/**
		 * Called when the data on a page has changed.
		 * First time called after page has rendered and the e.g. on paging
		 */
		onPageDataChanged: function() {},

		//
		// START: Authoring
		//
		allowAuthoring: function() {
			return false;
		},
		getAuthoringName: function() {

		},
		getAuthoringFullName: function() {

		},
		getPageName: function() {
			return this.pageName;
		},
		isVignette: function() {
			return this.options.isVignette === true;
		},
		authUpdateLayout: function() {
			var self = this;
			self.unbuild();
			return self.build()
				.then(function() {
					return self.show();
				});
		},
		//
		// END: Authoring
		//

		/**
		 * typeDashboard = hub / stack / undefined
		 */
		isDashboard: function(typeDashboard) {
			return false;
		},
		isChartDetail: function(typeDashboard) {
			return false;
		},
		isCardDetail: function() {
			return false;
		},
		isNestedInDashboard: function(typeDashboard) {
			return this.isVignette() && this.parentPage && this.parentPage.isDashboard(typeDashboard);
		},

		/**
		 * pageName: null, SdataRowDetail, SdataChartDetail
		 * 
		 */
		isChild: function(pageName) {
			if (pageName == null) {
				return this.options.isChild === true;
			}
			return this.options.isChild === true && this.options.childPageName === pageName;
		},
		/**
		 * Overridden by dashboard
		 */
		getGestureMgr: function() {
			return this._gestureMgr;
		},
		/**
		 * Update the scroller - needed for staked layouts
		 * In stacked/row layout the height of the page is given by the height of the content of the vignette
		 * Used by charts and vignettes
		 * force= true to force recalculation if caller nows that scolling area changed
		 */
		notifyScrollerUpdate: function(force) {
			// _gestureMgr != null for stack (not hub structure)
			if (!this._gestureMgr || !this.$$elmt.is(":visible")) {
				return;
			}
			// Init scroll because hight has changed - True to preserve scroll for authoring
			this._updateScrolling(true);
			this._gestureMgr.adjust();
		},
		isFacet: function() {
			return false;
		},
		/**
		 * opts : 	noScroll	True to not restore the scolling and last Selectedrow
		 */
		savedCtxCreate: function(opts) {
			if (this.destroyed) {
				return;
			}
			var ctx = {
				pageName: this.pageName,
				ctxCtrls: this.controller.savedCtxCreate(opts)
			};
			if (this._gestureMgr) {
				// Save page scrolling if is not a link (by email, pinned page...)
				ctx.scroll = this._gestureMgr.savedCtxCreate(opts);
			}
			return ctx;
		},
		/**
		 * If we want to get the savedCtx of a control before savedCtxRestore
		 */
		savedCtxCtrlRead: function(ctrl) {
			if (this.destroyed) {
				return;
			}
			var ctx;
			if (this.options.savedCtx && this.options.savedCtx.ctxCtrls) {
				var idx = this.controller.savedCtxIndexOf(ctrl);
				ctx = idx >= 0 ? this.options.savedCtx.ctxCtrls[idx] : null;
			}
			return ctx;
		},
		savedCtxRestore: function(ctx) {
			if (this.destroyed) {
				return;
			}
			ctx = ctx || this.options.savedCtx;
			if (!ctx) return;
			if (this.pageName != ctx.pageName) {
				return;
			}
			if (this._gestureMgr && ctx.scroll != null) {
				// Restore page scrolling
				this._gestureMgr.savedCtxRestore(ctx.scroll, true);
			}
			if (ctx.ctxCtrls) {
				this.controller.savedCtxRestore(ctx.ctxCtrls);
			}
		},
		/**
		 * Used to store settings (filters/search...)
		 */
		getPagePrefsId: function() {
			return settings.getPagePrefsId(this.pageName, this.parentVignette)
		},
		getPinActionState: function() {

		}
	});

exports.findPage = function(id) {
	return _pages[id];
}
});

define('syracuse-tablet/html/js/authoring/authoringSData',['require','exports','module','syracuse-tablet/html/js/common/ajax'],function (require, exports, module) {

var ajax = require('syracuse-tablet/html/js/common/ajax');
var _DEVICE_NAME = "mobile";

/*
 * pageName
 * x3.erp.AQMCRUDM.$details
 */
exports.getPageVariants = function(pageName) {
	var deferred = $.Deferred();
	var code = pageName + "." + _DEVICE_NAME;
	var key = encodeURIComponent(code).replace(/'/g, "''");
	ajax.request("/sdata/syracuse/collaboration/syracuse/pageDefs(code%20eq%20'" + key + "')?representation=pageDef.$details")
		.then(function(response) {
			deferred.resolve(response.data.variants || []);
		})
		.fail(function(e) {
			if (e.status === 404) {
				deferred.resolve([]);
			}
			deferred.reject(e);
		});
	return deferred.promise();
};

/*
 * pageName
 * x3.erp.AQMCRUDM.$details
 */
exports.getPageViews = function(pageName) {
	var deferred = $.Deferred();
	var key = encodeURIComponent(pageName).replace(/'/g, "''") + ",$page,," + _DEVICE_NAME;
	ajax.request("/sdata/syracuse/collaboration/syracuse/pages('" + key + "')")
		.then(function(response) {
			deferred.resolve(response.data.$views || []);
		})
		.fail(function(e) {
			if (e.status === 404) {
				deferred.resolve([]);
			}
			deferred.reject(e);
		});
	return deferred.promise();
};

var _createPageDefinitionWC = function(opts) {
	var params = {
		"pageContext": [opts.application, opts.contract, opts.representation, opts.facet].join("."),
		"device": _DEVICE_NAME,
		"representation": "pageAuth.$edit"
	};

	var url = "/sdata/syracuse/collaboration/syracuse/pageAuths" +
		(opts.variant != null ? ("('" + opts.variant + "')") : "/$template") +
		"/$workingCopies?" +
		Object.keys(params).map(function(key) {
			return key + "=" + params[key];
		}).join("&");

	return ajax.request(url, "POST")
		.then(function(response) {
			return response.data;
		});
};
var _savePageDefinitionWC = function(opts, wc) {
	var parameters = {
		"roles": opts.roles,
		"users": opts.users,
		"endpoints": opts.endpoints,
		"saveAsOption": opts.saveAsOption,
		"isFactory": false,
		"isModelRepresentation": false,
		"personalCopy": false,
		"variantCode": opts.variantCode,
		"variantTitle": opts.variantTitle,
		"variantDescription": opts.variantDescription
	};
	switch (opts.saveAsOption) {
		case "factory_variant":
			parameters.isFactory = true;
			break;
		case "personal_copy":
			parameters.personalCopy = true;
			break;
		case "shared_copy":
			break;
		case "global_variant":
			break;
	}

	wc.$actions = {};
	var save;
	if (opts.variant) {
		save = wc.$actions["$save"] = {};
		delete parameters.saveAsOption;
	} else {
		save = wc.$actions["saveAs"] = {};
	}
	save.$isRequested = true;
	save.$parameters = parameters;

	return ajax.request(wc.$url, "PUT", wc)
		.then(function(response) {
			return response.data;
		});
};

exports.savePageDefinition = function(opts) {
	var workingCopy;
	return _createPageDefinitionWC(opts)
		.then(function(wc) {
			workingCopy = wc;
			var send = $.extend(true, {}, workingCopy);
			send.content = send.content || {};
			send.content.$article = opts.article;
			return _savePageDefinitionWC(opts, send);
		}).then(function(wcSaved) {
			var data = $.extend(true, {}, workingCopy, wcSaved);
			var result = _extractErrors(data);
			if (result.errors) {
				return $.smReject(result.diags);
			}
			return data;
		});
};

function _extractErrors(data, result) {
	if (result == null) {
		result = {
			errors: false,
			diags: {
				$diagnoses: []
			}
		};
	}
	Object.keys(data).forEach(function(key) {
		var value = data[key];
		if (key === "$diagnoses") {
			value.forEach(function(d) {
				result.diags.$diagnoses.push(d);
				if (d.$severity == "error") {
					result.errors = true;
				}
			});
		} else if (value && typeof value === "object") {
			_extractErrors(value, result);
		}
	});
	return result;
}
});

define('syracuse-tablet/html/js/authoring/authoringHtml',['require','exports','module'],function (require, exports, module) {

/*
 * Authoring panel main layout
 */
var _templates = {
	authPanelHeader: '\
		<div style="display:table;table-layout:fixed;;width:100%;">\
			<div style="display:table-row;width:100%; ">\
				<div style="display:table-cell;width:300px;">\
					<div style="display:table;">\
						<div style="display:table-row;position:absolute;top:0;">\
							<div style="display:table-cell;">\
								<button class="btn btn-auth-header" id="s-m-auth-settings-id" type="button"><label class="glyphicon glyphicon-cog"></label>{{label_settings}}</button> \
							</div>\
							<div style="display:table-cell;" >\
								<div class="btn-group" id="s-m-auth-orientation-id" data-toggle="buttons">\
									<button class="btn btn-auth-header active" id="s-m-auth-vertical-id" data-auth-orientation="portrait" title="{{label_preview_portrait}}"> \
										<input type="radio" name="orientation" checked> \
										<label class="glyphicon glyphicon-resize-vertical"></label> \
									</button> \
									<button class="btn btn-auth-header" id="s-m-auth-horizontal-id" data-auth-orientation="landscape" title="{{label_preview_landscape}}"> \
										<input type="radio" name="orientation"> \
										<label class="glyphicon glyphicon-resize-horizontal"></label> \
									</button> \
								</div>\
							</div>\
							<div style="display:table-cell;">\
								<button class="btn btn-auth-header" id="s-m-auth-scale-id" type="button" title="{{label_scale_to_fit}}"><label class="glyphicon glyphicon-fullscreen"></button> \
							</div>\
						</div>\
					</div>\
				</div>\
				<div style="display:table-cell;" id="s-m-auth-header-actions-id">\
					<div style="display:table;">\
						<div style="display:table-row;position:absolute;top:0;">\
							<button style="display:table-cell;" class="btn btn-auth-header" id="s-m-auth-new-layout-id" type="button"><label class="glyphicon glyphicon-blackboard"></label><span>{{label_new_layout}}</span></button> \
							<button style="display:table-cell;" class="btn btn-auth-header" id="s-m-auth-remove-all-id" type="button"><label class="glyphicon glyphicon-erase"></label><span>{{label_remove_all}}</span></button> \
							<button style="display:table-cell;" class="btn btn-auth-header disabled" id="s-m-auth-remove-id" type="button"><label class="glyphicon glyphicon-trash"></label><span>{{label_remove}}</span></button> \
							<button style="display:table-cell;" class="btn btn-auth-header disabled" id="s-m-auth-remove-cnt-id" type="button"><label class="glyphicon glyphicon-erase"></label><span>{{label_remove_container}}</span></button> \
						</div>\
					</div>\
				</div>\
				<div style="display:table-cell;">\
					<button id="auth-btn-close-id" style="float:right;" class="btn btn-danger" type="button"><div class="glyphicon glyphicon-remove"></label></button> \
					<button id="auth-btn-save-id" style="float:right;" class="btn btn-default" type="button"><div class="glyphicon glyphicon-ok"></label></button> \
					<button id="auth-btn-undo-all-id" style="float:right;" class="btn btn-auth-header" type="button"><div class="icon-undoall"></label>{{label_undo_all}}</button> \
					<button id="auth-btn-undo-id"  style="float:right;" class="btn btn-auth-header" type="button"><div class="icon-undo"></label>{{label_undo}}</button> \
				</div>\
			</div>\
		</div>',

	authPanelFooter: '\
		<div class="btn-group"> \
		</div>',

	authPanelRightStructure: '\
		<div class="s-m-site-auth-panel-content"> \
			<header id="authPanelControlType">{{label_design}}</header> \
			<p class="form-control-static" id="authPanelControlTitle"> </p> \
			<div style="padding: 0 15px;">\
				<a class="btn btn-primary" id="s-m-auth-child-design-open-id" style="display:none; width: 100%;">{{label_openCardDesign}}</a> \
			</div>\
			<div id="authPanelControl" class="tab-pane panel-body active"> \
				<div id="authPanelControlSimple"> \
				</div> \
			</div> \
		</div>',

	authPanelLeftStructure: '\
		<div class="s-m-site-auth-panel-content"> \
			<ul class="nav nav-pills" role="tablist"> \
				<li class="active"><a aria-expanded="true" href="#s-m-auth-tree-box" role="tab" data-toggle="tab">{{label_content}}</a></li> \
				<li><a href="#s-m-auth-insert-box" role="tab" data-toggle="tab">{{label_insert}}</a></li> \
			</ul> \
			<div class="tab-content"> \
				<div id="s-m-auth-tree-box" class="tab-pane active"> \
					<ul class="s-m-auth-tree" id="auth-structure-root-id"></ul> \
				</div> \
				<div id="s-m-auth-insert-box" class="tab-pane"> \
					<div class="panel panel-primary s-m-panel-auth-prop"> \
						<div class="panel-heading" role="tab" id="auth-lp-cnt-containers-header"> \
							<a data-toggle="collapse" data-parent="#accordion" href="#auth-lp-cnt-containers-clpse" \
								aria-expanded="true" aria-controls="auth-lp-cnt-containers-clpse" \
								<h4 class="panel-title"> \
									{{label_containers}}\
								</h4> \
							</a> \
						</div> \
						<div id="auth-lp-cnt-containers-clpse" class="panel-collapse collapse in" \
							role="tabpanel" aria-labelledby="auth-lp-cnt-containers-header"> \
							<label>{{lab_drag_to_add}}</label><br> \
							<div class="s-m-auth-btn-container s-m-draggable fa fa-th" data-auth-bind="group" title="{{lab_group}}" data-auth-drag-action="add_layout"></div> \
							<div class="s-m-auth-btn-container s-m-draggable fa fa-square-o" data-auth-bind="tile" title="{{lab_tile}}" data-auth-drag-action="add_layout"></div> \
							<div class="s-m-auth-btn-container s-m-draggable fa fa-bars" data-auth-bind="stack" title="{{lab_stack}}" data-auth-drag-action="add_layout"></div> \
						</div> \
					</div> \
					<div class="panel panel-primary s-m-panel-auth-prop"> \
						<div class="panel-heading" role="tab" id="auth-lp-cnt-props-header"> \
							<a data-toggle="collapse" data-parent="#accordion" href="#auth-lp-cnt-props-clpse" \
								aria-expanded="true" aria-controls="auth-lp-cnt-props-clpse">\
								<h4 class="panel-title"> \
									{{label_fields}}\
								</h4> \
							</a> \
						</div> \
						<div id="auth-lp-cnt-props-clpse" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="auth-lp-cnt-props-header"> \
						</div> \
					</div> \
				</div> \
			</div> \
		</div>',

	authPanelPropertyGroup: ' \
		<div class="panel panel-primary s-m-panel-auth-prop s-m-auth-prop-type-{{type}}"> \
			<div class="panel-heading" role="tab" id="heading_{{id}}"> \
				<a data-toggle="collapse" data-parent="#{{#if parentId}}{{parentId}}{{/if}}{{#unless parentId}}accordion{{/unless}}" href="#collapse_{{id}}" {{#if expanded}} aria-expanded="true"{{/if}} aria-controls="collapse_{{id}}" {{#unless expanded}}class="collapsed"{{/unless}}>\
					<h4 class="panel-title"> \
						{{label}}\
					</h4> \
				</a> \
			</div> \
			<div id="collapse_{{id}}" class="panel-collapse collapse {{#if expanded}}in{{/if}}" role="tabpanel" aria-labelledby="heading_{{id}}"> \
			</div> \
		</div>',
	authPanelPropertySeperator: ' \
		<div class="auth-group-seperator"></div> \
		',

	authPanelPropertyRadio: ' \
		<div class="btn-group" data-toggle="buttons" style="width: 100%;"> \
			{{#each options}} \
				<div class="btn-group" style="width: 100%; display: {{this.display}};" id="{{this.id}}"> \
					<label class="s-m-auth-btn-radio-icon s-m-auth-btn-block" id="{{this.id}}_lab" data-s-m-auth-value="{{this.value}}"> \
						<input type="radio" name="{{group}}" id="{{this.id}}">{{this.label}} \
					</label> \
				</div> \
			{{/each}} \
		</div>',
	authPanelPropertyRadioIcon: ' \
		<div class="btn-group" data-toggle="buttons" style="width: 100%;"> \
			{{#each options}} \
				<div class="btn-group"> \
					<label class="auth-btn-icon {{icon}}" id="{{this.id}}_lab" data-s-m-auth-value="{{this.value}}"> \
						<input type="radio" name="{{group}}" id="{{this.id}}"> \
					</label> \
				</div> \
			{{/each}} \
		</div>',

	authPanelPropertyCheckbox: ' \
		<div class="btn-group" style="width: 100%;"> \
			{{#each options}} \
				<div class="btn-group" style="width: 100%; display: {{this.display}};" id="{{this.id}}"> \
					<label class="s-m-auth-btn-checkbox-icon s-m-auth-btn-block" id="{{this.id}}_lab" data-s-m-auth-value="{{this.value}}"> \
							<i class="fa fa-square {{#if checked}}fa-check-square{{/if}}" style="margin-right:5px"></i>{{this.label}} \
					</label> \
				</div> \
			{{/each}} \
		</div>',

	authPanelPropertyInput: ' \
			<div class="form-group"> \
				<input class="form-control" id="{{id}}" value="{{value}}" /> \
			</div>',
	authPanelPropertyInputLocale: ' \
		<div class="form-group"> \
			<input class="form-control" id="{{id}}" value="{{value}}" data-old-value="{{oldValue}}" data-old-uuid="{{oldUUID}}"/> \
		</div>',

	authPanelSliderStep: ' \
		<div class="form-group"> \
			<section style="padding-left:10px;padding-right:10px;">\
				<input id="{{id}}" type="text" data-slider-min="{{min}}" data-slider-max="{{max}}" data-slider-step="{{step}}"  data-slider-value="{{value}}" data-slider-orientation="horizontal" data-slider-tooltip="hide">\
				{{#if displayValue}}<span class="s-m-slider-value">{{#if valText}}{{valText}}{{/if}}{{#unless valText}}{{value}}{{/unless}}</span>{{/if}}\
			</section>\
		</div>',

	authPanelGaugeSlider: '\
		<div class="form-group s-m-auth-g-slider"> \
			<section>\
				<input id="{{id}}" type="text" data-slider-min="{{min}}" data-slider-max="{{max}}" data-slider-step="{{step}}"  data-slider-value="{{value}}" data-slider-orientation="horizontal" data-slider-tooltip="hide" class="s-m-auth-g-range">\
				<span id="{{id}}SliderVal">{{value}}</span>\
			</section>\
		</div>\
	',
	authPanelPropertyCellSize: ' \
		<section>\
			<label class="s-m-auth-btn-checkbox-icon s-m-auth-btn-block">\
				<input type="checkbox">\
				{{sameSize}}\
			</label>\
			{{#each sizes}} \
				<section class = "{{prop}}">\
					<label class="{{class}} auth-size-device-header" style="width: 100%">{{this.label}}</label> \
					<div class="btn-group" data-toggle="buttons" style="width: 100%;"> \
						{{#each ../values}} \
							<div class="btn-group"> \
								<label class="auth-btn-size-sel" id="{{this.id}}_lab" data-s-m-auth-prop="{{../this.prop}}" data-s-m-auth-value="{{this}}"> \
									<input type="radio" name="{{group}}" id="{{../this.prop}}={{this}}">{{this}} \
								</label> \
							</div> \
						{{/each}} \
					</div> \
				</section>\
			{{/each}}\
		</section>',

	authPanelPropertyJSON: ' \
			<div class="form-group"> \
				<textarea class="form-control" id="{{id}}" rows="10">{{value}}</textarea> \
				<div class="btn-group btn-group-justified" role="group">\
					<a class="btn btn-default" data-action="jsonApply">{{label_apply}}</a> \
					<a class="btn btn-default" data-action="openInNewTab">{{label_display}}</a> \
				</div>\
			</div><div style="clear: both;"></div>',

	authPanelPropertyPROTOTYPE: ' \
			<div class="form-group"> \
				<textarea readonly class="form-control" id="{{id}}" rows="10">{{value}}</textarea> \
				<div class="btn-group btn-group-justified" role="group">\
					<a class="btn btn-default" data-action="openInNewTab">{{label_display}}</a> \
				</div>\
			</div>',

	authPanelPropertyGBorderValues: '\
		<div class="form-group">\
			<p class="s-m-auth-g-borders-tip">{{label_tip}}</p>\
			<label>{{label_min}}</label>\
			{{{markupMin}}}\
			<label>{{label_max}}</label>\
			{{{markupMax}}}\
			<button class="btn btn-default btn-block" style="margin-top:5%;">{{label_apply}}</button> \
		</div>\
	',
	authPanelPropertyGSegmentsNumber: '\
		<div class="form-group">\
			{{{value}}} \
			<button class="btn btn-default btn-block" style="margin-top:5%;">{{label_apply}}</button> \
		</div>\
	',
	gaugeBorderInput: '\
		<textarea class="form-control" id={{id}} rows="1">{{value}}</textarea>\
	',
	gaugeSelect: '\
		<select id={{id}} style="color:black;" class="form-control">\
			{{#each options}}\
				<option value="{{option_value}}" {{#if selected}}selected=true{{/if}}>{{option_value}}</option>\
			{{/each}}\
		</select>\
	',
	gaugeSegment: '\
		<div id="{{id}}" class="s-m-auth-seg-slot">\
			<div class="s-m-g-seg-info-block">\
				<div class="s-m-g-seg-label">\
					<label>{{label_valstart}}</label>\
				</div>\
				<div class="s-m-g-seg-value">\
					<input type="text" class="form-control" value="{{value_valstart}}" id="{{id}}-valstart">\
				</div>\
			</div>\
			<div class="s-m-g-seg-info-block">\
				<div class="s-m-g-seg-label">\
					<label>{{label_valend}}</label>\
				</div>\
				<div class="s-m-g-seg-value">\
					<input type="text" class="form-control" value="{{value_valend}}" id="{{id}}-valend">\
				</div>\
			</div>\
			<div class="s-m-g-seg-info-block">\
				<div class="s-m-g-seg-label">\
					<label>{{label_propstart}}</label>\
				</div>\
				<div class="s-m-g-seg-value">\
					{{{value_propstart}}}\
				</div>\
			</div>\
			<div class="s-m-g-seg-info-block">\
				<div class="s-m-g-seg-label">\
					<label>{{label_propend}}</label>\
				</div>\
				<div class="s-m-g-seg-value">\
					{{{value_propend}}}\
				</div>\
			</div>\
			<div class="s-m-g-seg-info-block">\
				<div class="s-m-g-seg-label">\
					<label>{{label_color}}</label>\
				</div>\
				<div class="s-m-g-seg-value">\
					<input type="text" class="form-control" value="{{value_color}}" id="{{id}}-color">\
				</div>\
			</div>\
		</div>\
	',
	authPanelButton: '\
		<div class="s-m-auth-g-apply-slot">\
			<button class="btn btn-default btn-block {{css}}" style="margin-top:5%;">{{label}}</button> \
		</div>\
	'
};

var _compiled = {};

function _getCompiled(name) {
	var c = _compiled[name];
	if (c) {
		return c;
	}

	var t = _templates[name];
	c = Handlebars.compile(t);
	_compiled[name] = c;
	return c;
}

exports.execute = function(name, ctx) {
	var c = _getCompiled(name);
	return c(ctx);
};
});

define('syracuse-tablet/html/js/authoring/authoringVal',['require','exports','module','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/modals/modal'],function (require, exports, module) {

var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');

var _authProperties;

exports.setProperties = function(properties) {
	_authProperties = properties;
};

function getAuthoringPropertiesLayouts() {
	return _authProperties && _authProperties.getPropertiesLayouts();
}
/*
 *
 * Simple article validation module
 *
 */


exports.validateJSON = function(fullPage, jsonText, properties) {
	var obj;
	try {
		if ($.isPlainObject(jsonText)) {
			obj = jsonText;
		} else if (jsonText != null && jsonText.length > 0) {
			obj = JSON.parse(jsonText);
		} else {
			throw new Error("Unexpected bad JSONtext");
		}

		var errors = _validate(fullPage, obj, properties);
		if (errors.length > 0) {
			var text = "\n" + errors.join("\n");
			modal.error(locale.text("auth.panel.save_error_title"), {
				message: locale.text("auth.panel.save_error_json"),
				detail: text
			});
		} else {
			return obj;
		}
	} catch (e) {
		modal.error(locale.text("auth.panel.save_error_title"), {
			message: locale.text("auth.panel.save_error_json"),
			detail: e
		});
	}
};

/*
 * display $items and $article nodes at the end of JSON
 */
exports.toSortedJSON = function(obj) {
	var toJSON = function() {
		var self = this;
		var that = {};
		var $items;
		var $article;
		Object.keys(self).forEach(function(key) {
			if (self.hasOwnProperty(key)) {
				if (key === "$items") {
					$items = self[key];
				} else if (key === "$article") {
					$article = self[key];
				} else if (key === "toJSON") {
					// Do nothing
				} else {
					that[key] = self[key];
				}
			}
		});
		if ($article) {
			that.$article = $article;
		}
		if ($items) {
			that.$items = $items;
		}
		if (self.toJSON) {
			delete self.toJSON;
		}
		if (that.toJSON) {
			delete that.toJSON;
		}
		return that;
	};
	// Step one: Hook property ordering
	JSON.stringify(obj,
		function replacer(key, value) {
			if ($.isPlainObject(value)) {
				value.toJSON = toJSON;
			}
			return value;
		});
	// Build json
	var str = JSON.stringify(obj, null, " ");
	return str;
};

/*
 * fullPage: true = article is an object describing a full page so also nesting constraints can be checked
 * fullPage: false = article is an object describing a control or container so nesting constraints cannot be fully checked
 * article: Article object
 */
function _validate(fullPage, article, properties) {

	var errors = [];
	try {
		_checkNode(fullPage, null, article, properties, errors);
	} catch (e) {
		errors.push("javascriptException - validate\n" + jsutils.cleanStack(e.stack));
	}
	return errors;
};

var _propertiesToCheck = {
	$layoutType: _checkLayoutType,
	$size: _checkTileSize,
	$widthXs: _checkCellSize,
	$widthSm: _checkCellSize,
	$widthMd: _checkCellSize,
	$widthLg: _checkCellSize
};

function _checkNode(fullPage, parent, node, properties, errors) {

	Object.keys(_propertiesToCheck).some(function(key) {
		if (node[key] !== undefined) {
			_propertiesToCheck[key](fullPage, parent, node, key, properties, errors);
		}
	});

	var children;
	if (node.$items) {
		children = node.$items;
	} else if (node.$article) {
		children = [node.$article];
	}
	if (children) {
		children.forEach(function(child) {
			_checkNode(fullPage, node, child, properties, errors);
		});
	}
}

function _checkLayoutType(fullPage, parent, node, key, properties, errors) {
	var type = node.$layoutType;
	var ptype = parent && parent.$layoutType;
	var known = ["stack", "row", "cell", "hub", "hubGroup", "tile"];
	if (known.indexOf(type) < 0) {
		errors.push(locale.text("auth.err.unknown.layout", [type]));
		return;
	}
	if (!fullPage) {
		return;
	}
	switch (type) {
		case "hub":
			if (parent != null) {
				errors.push(locale.text("auth.err.hub.notroot"));
			}
			break;
		case "hubGroup":
			if (ptype != "hub") {
				errors.push(locale.text("auth.err.hubgroup.nohub"));
			}
			break;
		case "tile":
			if (ptype != "hubGroup") {
				errors.push(locale.text("auth.err.tile.nohubgroup"));
			}
			break;
	}
}

function _checkCellSize(fullPage, parent, node, key, properties, errors) {
	var value = +node[key];
	if (!(value >= 1 && value <= 12)) {
		errors.push(locale.text("auth.err.cellSize", [key, value]));
	}
}

function _checkTileSize(fullPage, parent, node, key, properties, errors) {
	var value = node[key];
	var valid = getAuthoringPropertiesLayouts().properties.tileSize.values.map(function(e) {
		return e.value;
	});

	if (valid.indexOf(value) < 0) {
		errors.push(locale.text("auth.err.tileSize", [valid.join(", "), value]));
	}
}
});

define('syracuse-tablet/html/js/authoring/authoringComponents',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');


var _templates = {
	genericSlider: '\
		<div class="form-group" {{#if margin}}style="margin-bottom:{{margin}}px;"{{/if}}> \
			<section style="padding-left:10px;padding-right:10px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis">\
				<input id="{{id}}" type="text" data-slider-min="{{min}}" data-slider-max="{{max}}" data-slider-step="{{step}}"  data-slider-value="{{value}}" data-slider-orientation="horizontal" data-slider-tooltip="hide">\
				{{#if displayValue}}<p class="s-m-slider-value">{{#if valText}}{{valText}}{{/if}}{{#unless valText}}{{value}}{{/unless}}</p>{{/if}}\
			</section>\
		</div>',
	flatRadio: '\
		<div class="btn-group" style="margin-bottom:10px;" data-toggle="buttons">\
			{{#each btns}}\
				<label class="btn btn-primary">\
					<input type="radio" autocomplete="off" value="{{value}}">\
					{{title}}\
				</label>\
			{{/each}}\
		</div>',
	select: '\
		<div style="position:relative;{{#if margin}}margin-bottom:{{margin}}px;{{/if}}">\
		  <select class="selectpicker {{css}}"  data-width="100%" {{#if dataSize}}data-size="{{dataSize}}"{{/if}}>\
		  	{{#each options}}\
		     	<option value="{{value}}">{{title}}</option>\
			{{/each}}\
		  </select>\
		</div>',
	actionBtns: '\
		<div style="text-align:center;">\
			<div class="btn-group" role="group" style="margin-bottom:10px;">\
				{{#each btns}}\
					<button type="button" class="btn btn-default" value="{{value}}">{{title}}</button>\
				{{/each}}\
			</div>\
		</div>',
	colorPicker: '\
		<input type="text" {{#if id}}id="{{id}}"{{/if}} class="form-control {{css}}""></input>',
	editableList: '\
		<section class = "auth-editableList  {{css}}" {{#if id}}id="{{id}}"{{/if}} >\
			<ul class="list-group auth-editableList"></ul>\
			<div class="authMsg"></div>\
			<div class="btn-group btn-group-justified" role="group">\
				<a type="button" class="btn btn-default authLstAct" data-action="append">\
					<i class="fa fa-plus"></i>\
					<span>{{addTitle}}</span>\
				</a>\
				<a style="display:none" type="button" class="btn btn-default authLstAct" data-action="validate">\
					<i class="fa fa-check"></i>\
					<span>{{validateTitle}}</span>\
				</a>\
				<a style="display:none" type="button" class="btn btn-default authLstAct" data-action="cancel">\
					<i class="fa fa-times"></i>\
					<span>{{cancelTitle}}</span>\
				</a>\
			</div>\
		</section>',
	editableListItem: '\
		<li class="list-group-item {{css}}" data-params="{{id}}">\
			<span>\
				<span>{{#if title}}{{title}}{{/if}}{{#if titleHtml}}{{{titleHtml}}}{{/if}}</span>\
				<span class="fa fa-pencil" data-action="editItem"></span>\
				<span class="fa fa-times" data-action="deleteItem"></span>\
			</span>\
		</li>',
	colorPalettePicker: '\
		<section class="auth-colorPalettePicker {{dropDirection}}">\
			<div class="input-group" data-toggle="dropdown" aria-expanded="false">\
				<span class="form-control auth-paletteColor"></span>\
				<span class="input-group-addon"><div class="fa fa-times"></div></span>\
			</div>\
			<div class="dropdown-menu" style="width: 100%;width: 100%;padding-left: 5px;padding-right: 5px;">\
				<div class="auth-paletteRoot" data-toggle="buttons" style="width: 100%;white-space: normal;" >\
				</div>\
		  	</div>\
		</section>',
	colorPaletteItem: '\
		<div class="auth-paletteItem {{css}}" data-id="{{id}}" data-name="{{name}}" data-css="{{css}}">\
		</div>',
	iconPalettePicker: '\
		<section class="auth-iconPalettePicker {{dropDirection}}">\
			<div class="input-group" data-toggle="dropdown" aria-expanded="false">\
				<span class="form-control auth-paletteIcon"></span>\
				<span class="input-group-addon"><div class="fa fa-times"></div></span>\
			</div>\
			<div class="dropdown-menu">\
				<div class="auth-paletteRoot" data-toggle="buttons" style="width: 100%;white-space: normal;" >\
				</div>\
		  	</div>\
		</section>',
	iconPaletteItem: '\
		<div class="auth-paletteItem {{css}}" data-params="{{name}}" data-css="{{css}}">\
		</div>',
	switcher: '\
		 <input {{#if id}}id="{{id}}"{{/if}} type="checkbox">',
	checkboxList: ' \
		<section class="auth-checkboxList {{css}}" {{#if id}}id="{{id}}"{{/if}}/>',
	checkboxListContent: ' \
		<div class="btn-group s-m-list">\
			{{#each list}} \
				<div class="s-m-item btn-group" data-id = "{{id}}"> \
					<label> \
						<input type="checkbox" {{#if checked}}checked{{/if}}>{{label}} \
					</label> \
				</div> \
			{{/each}}\
		</div>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};

var _components = {
	"editableList": function(options, name) {
		options = options || {};
		this.options = options;
		this.name = name || "editableList";
		this.createMarkup = function($$parent) {
			this.$$panel = $(_getHtml("editableList", {
				id: options.id,
				css: options.css || "",
				addTitle: options.appendTitle || locale.text("append"),
				validateTitle: options.validateTitle || locale.text("validate"),
				cancelTitle: options.cancelTitle || locale.text("cancel")
			})).appendTo($$parent);
			if (options.isHidden === true) {
				this.hide();
			}
			if (this.options.doAction) {
				this.$$panel.on('click', "[data-action]", jsutils.bindFn(this.onClick, this));
			}
			this.$$list = this.$$panel.find("ul");
			return this.$$panel;
		};
		this.onClick = function(event) {
			var $$target = $(event.target).closest("[data-action]");
			var action = $$target.attr("data-action");
			var id;
			if (action === "append" || action === "cancel") {
				id = "";
			} else if (action === "editItem" || action === "deleteItem") {
				id = $$target.closest("[data-params]").attr("data-params") || "";
			} else if (action === "validate") {
				id = $$target.attr("data-params") || "";
			}
			var done = this.options.doAction(action, id, this);
			if (done == true) {
				if (action === "deleteItem") {
					$$target.closest("li").off().remove();
				} else if (action === "editItem" || action === "append") {
					this.toggleEditStatus(true, id);
				} else if (action === "validate" || action === "cancel") {
					this.toggleEditStatus(false);
				}
			}
		};
		this.insertRecords = function(records) {
			if (!records || !this.$$list) return;
			if ($.isPlainObject(records)) records = [records];
			if (!Array.isArray(records)) return;
			var self = this;
			records.forEach(function(record) {
				if (!record || !record.id) return;
				var $$newRec = $(_getHtml("editableListItem", {
					id: record.id,
					css: record.css || "",
					titleHtml: record.titleHtml,
					title: record.title
				}));
				var $$oldRec = self.$$list.find('[data-params="' + record.id + '"]');
				if ($$oldRec.length > 0) {
					$$oldRec.before($$newRec);
					$$oldRec.remove();
				} else {
					$$newRec.appendTo(self.$$list);
				}
			});
		};
		this.destroyMarkup = function() {
			this.options = null;
			if (this.$$list) {
				this.$$list.off();
				this.$$list = null;
			}
			this.$$panel = null;
		};
		this.clear = function() {
			if (!this.$$list) return;
			this.$$list.find("li").remove();
		};
		this.toggleEditStatus = function(editMode, recordId) {
			if (!this.$$panel) return;
			this.$$panel.find('[data-action="append"]').toggle(editMode !== true);
			this.$$panel.find('[data-action="validate"]').toggle(editMode === true).attr("data-params", editMode === true ? recordId : "");
			this.$$panel.find('[data-action="cancel"]').toggle(editMode === true);
		};
		this.disableAppendBtn = function(disabled) {
			this.$$panel.find('[data-action="append"]').attr("disabled", disabled === true);
		};
		/**
		 * type info/warning/error
		 */
		this.toggleMessage = function(msgText, type) {
			if (!this.$$panel) return;
			var $$msg = this.$$panel.find('.authMsg');
			$$msg.empty().removeClass();
			if (msgText && msgText.trim().length > 0) {
				$$msg.text(msgText);
				if (type) {
					$$msg.addClass("s-m-" + type);
				}
			}
			$$msg.addClass("authMsg");
		};
	},
	"colorPicker": function(options, name) {
		options = options || {};
		this.options = options;
		this.name = name || "colorPicker";
		this.createMarkup = function($$parent) {
			this.$$picker = $(_getHtml("colorPicker", {
				id: options.id,
				css: options.css || "",
			})).appendTo($$parent);
			if (options.isHidden === true) {
				this.$$picker.hide();
			}
			this.$$picker.minicolors({
				control: options.control || "hue",
				defaultValue: options.value || '',
				inline: options.inline === true,
				letterCase: options.letterCase || 'lowercase',
				opacity: options.opacity === true,
				position: options.position || 'top left',
				theme: 'bootstrap',
				change: options.onChange ? jsutils.bindFn(this.onChange, this) : null
			});
			this.$$panel = this.$$picker;
			return this.$$panel;
		};
		this.onChange = function(event) {
			this.options.onChange(event, this);
		};
		this.destroyMarkup = function() {
			this.options.onChange = null;
			this.options = null;
			if (this.$$picker) {
				this.$$picker.minicolors('destroy');
				this.$$picker = null;
			}
		};
		this.getValue = function(type) {
			if (!this.$$picker) return;
			var meth;
			if (type === "rgbObject" || type === "rgbString" || type === "rgbaString") {
				meth = type;
			} else {
				meth = "value";
			}
			return this.$$picker.minicolors(meth);
		};
		this.setValue = function(valueHexa) {
			if (!this.$$picker) return;
			return this.$$picker.minicolors("value", valueHexa);
		};
	},
	"colorPalettePicker": function(options, name) {
		options = options || {};
		this.options = options;
		this.name = name || "colorPalettePicker";
		this.createMarkup = function($$parent) {
			var css = options.css || "";
			this.$$panel = $(_getHtml("colorPalettePicker", {
				id: options.id,
				css: css,
				dropDirection: options.dropUp === true ? "dropup" : "dropdown"
			})).appendTo($$parent);
			this.$$rootPalette = this.$$panel.find(".auth-paletteRoot");
			this.$$input = this.$$panel.find(".auth-paletteColor");
			this.$$clearBtn = this.$$panel.find(".input-group-addon").on('click', jsutils.bindFn(this.onClear, this));
			this.$$rootPalette.on('click', '[data-id]', jsutils.bindFn(this.onSelectColor, this));
			if (options.isHidden === true) {
				this.$$panel.hide();
			}
			if (options.palette) {
				this.updatePalette(options.palette);
			}
			this.setValue(options.color);
			return this.$$panel;
		};
		this.updatePalette = function(palette) {
			if (!palette) return;
			var html = [];
			palette.forEach(function(item) {
				if (item.items) {
					if (item.title) {
						html.push('<div class ="authPaletteSection">' + item.title + '</div>');
					}
					item.items.forEach(function(subItem) {
						subItem.name = subItem.name || subItem.id;
						html.push(_getHtml("colorPaletteItem", subItem));
					});
				} else {
					html.push(_getHtml("colorPaletteItem", item));
				}
			});
			this.$$rootPalette.html(html.join(''));
		};
		this.onClear = function(event) {
			if (!this.$$panel.is(".open")) {
				event.stopPropagation();
				this.setValue(null);
				if (this.options.onSelectColor) {
					this.options.onSelectColor(null);
				}
			}
		};
		this.onSelectColor = function(event) {
			var $$t = $(event.target);
			var value = {
				id: $$t.attr("data-id") || "",
				name: $$t.attr("data-name") || "",
				css: $$t.attr("data-css"),
				bgColor: $$t.css("background-color"),
				color: $$t.css("color"),
				hex: this.getHexColor($$t.css("background-color"))
			};
			this.setValue(value);
			if (this.options.onSelectColor) {
				this.options.onSelectColor(value);
			}
		};
		this.destroyMarkup = function() {
			if (this.$$rootPalette) {
				this.$$rootPalette.off();
				this.$$rootPalette = null;
			}
			this.options = null;
			this.$$clearBtn.off();
			this.$$clearBtn = this.$$input = this.$$panel = null;
		};
		this.getValue = function() {
			var $$selected = this.$$panel.find(".auth-paletteItem.current");
			if ($$selected.length == 0) return null;
			// Returns color and background-color in case the caller can't use css
			return {
				css: $$selected.attr("data-css") || "",
				name: $$selected.attr("data-name") || "",
				id: $$selected.attr("data-id") || "",
				bgColor: $$selected.css("background-color"),
				color: $$selected.css("color"),
				hex: this.getHexColor($$selected.css("background-color"))
			};
		};
		this.setValue = function(color) {
			this.$$panel.find(".auth-paletteItem.current").removeClass("current");
			if (color) {
				this.$$panel.find('[data-id="' + color.id + '"]').addClass("current");
			}
			this.$$input.removeClass().addClass("form-control").text(color ? color.name : locale.text("auth.components.palette.nocolor"));
			if (color) {
				this.$$input.addClass(color.css);
			}
		};
		this.getHexColor = function(color) {
			var value = "#";
			var toHex = function(n) {
				n = parseInt(n, 10);
				return ("00" + n.toString(16)).slice(-2);
			};
			if (/^rgb\(.*\)$/.test(color)) {
				color.match(/([0-9]+)/g).forEach(function(val) {
					value += toHex(val);
				});
				return value;
			};
			return null;
		};
	},
	"iconPalettePicker": function(options, name) {
		options = options || {};
		this.options = options;
		this.name = name || "iconPalettePicker";
		this.createMarkup = function($$parent) {
			var css = options.css || "";
			this.$$panel = $(_getHtml("iconPalettePicker", {
				id: options.id,
				css: css,
				dropDirection: options.dropUp === true ? "dropup" : "dropdown"
			})).appendTo($$parent);
			this.$$rootPalette = this.$$panel.find(".auth-paletteRoot");
			this.$$input = this.$$panel.find(".auth-paletteIcon");
			this.$$clearBtn = this.$$panel.find(".input-group-addon").on('click', jsutils.bindFn(this.onClear, this));
			this.$$rootPalette.on('click', '[data-params]', jsutils.bindFn(this.onSelectIcon, this));
			if (options.isHidden === true) {
				this.$$panel.hide();
			}
			if (options.palette) {
				this.updatePalette(options.palette);
			}
			this.setValue(options.icon);
			return this.$$panel;
		};
		this.updatePalette = function(palette) {
			if (!palette) return;
			var html = [];
			palette.forEach(function(item) {
				html.push(_getHtml("iconPaletteItem", item));
			});
			this.$$rootPalette.html(html.join(''));
		};
		this.onClear = function(event) {
			if (!this.$$panel.is(".open")) {
				event.stopPropagation();
				this.setValue(null);
			}
		};
		this.onSelectIcon = function(event) {
			var $$t = $(event.target);
			var old = this.getValue();
			var value = {
				name: $$t.attr("data-params"),
				css: $$t.attr("data-css")
			};
			if (old && old.name == value.name && old.css == value.css) return;
			this.setValue(value);
			if (this.options.onSelectIcon) {
				this.options.onSelectIcon(value);
			}
		};
		this.destroyMarkup = function() {
			if (this.$$rootPalette) {
				this.$$rootPalette.off();
				this.$$rootPalette = null;
			}
			this.options = null;
			this.$$clearBtn.off();
			this.$$clearBtn = this.$$input = this.$$panel = null;
		};
		this.getValue = function() {
			var $$selected = this.$$panel.find(".auth-paletteItem.current");
			if ($$selected.length == 0) return null;
			return {
				css: $$selected.attr("data-css") || "",
				name: $$selected.attr("data-params") || ""
			};
		};
		this.setValue = function(icon) {
			this.$$panel.find(".auth-paletteItem.current").removeClass("current");
			if (icon) {
				this.$$panel.find('[data-params="' + icon.name + '"]').addClass("current");
			}
			this.$$input.removeClass().addClass("form-control").empty();
			if (icon) {
				this.$$input.html('<div class="iconIcon ' + icon.css + '"></div><div class="iconName">' + icon.name + '</div>');
			} else {
				this.$$input.text(locale.text("auth.components.palette.noicon"));
			}
		};
	},
	"select": function(options, name) {
		options = options || {};
		if (!options.onChange) throw new Error("select component - onChange is mandatory");
		// Allows empty option because we can use update method
		options.options = options.options || [];
		if (options.value == null) {
			options.value = Object.keys(options.options)[0];
		}
		this.name = name || "select";
		this.options = options;
		var optselect = {
			options: options.options || [],
			css: options.css || ""
		};
		if (options.dataSize) {
			optselect.dataSize = options.dataSize;
		};
		this.createMarkup = function($$parent) {
			this.$$panel = $(_getHtml("select", optselect)).appendTo($$parent);
			this.$$select = this.$$panel.find("select");
			this.$$select.selectpicker();
			this.$$select.selectpicker('val', options.value);
			this.$$select.on('change', jsutils.bindFn(this.onChange, this));
			if (options.isHidden === true) {
				this.$$select.selectpicker('hide');
			}
			return this.$$panel;
		};
		this.onChange = function(event) {
			this.options.onChange(event, this);
		};
		this.destroyMarkup = function() {
			this.options.onChange = null;
			this.options = null;
			if (this.$$select) {
				this.$$select.off();
				this.$$select.selectpicker('destroy');
				this.$$select = null;
			}
		};
		this.getValue = function() {
			if (!this.$$select) return;
			return this.$$select.selectpicker('val');
		};
		this.setValue = function(value) {
			if (!this.$$select) return;
			return this.$$select.selectpicker('val', value);
		};
		this.update = function(selectOpts, defValue) {
			if (!this.$$select) return;
			selectOpts = selectOpts || [];
			this.$$select.find("option").remove();
			var self = this;
			selectOpts.forEach(function(v, idx) {
				self.$$select.append('<option value="' + v.value + '">' + v.title + '</option>');
			});
			if (defValue == null && selectOpts.length > 0) {
				defValue = selectOpts[0].value;
			}
			if (defValue != null) {
				this.$$select.selectpicker('val', defValue);
			}
			this.$$select.selectpicker('refresh');
		};
		this.clear = function() {
			this.update(null);
		};
	},
	"flatRadio": function(options, name) {
		this.name = name || "flatRadio";
		this.options = options;
		this.createMarkup = function($$parent) {
			this.$$panel = $(_getHtml("flatRadio", {
				btns: this.options.btns
			})).appendTo($$parent).on('change', "input", this.options.onClick);
			this.$$panel.find('input[value="' + this.options.value + '"]').parent().button('toggle');
			return this.$$panel;
		};
		this.destroyMarkup = function() {
			this.options.onClick = null;
			this.options = null;
			if (this.$$panel) {
				this.$$panel.off();
				this.$$panel = null;
			}
		};
	},
	"switcher": function(options, name) {
		this.name = name || "switcher";
		this.options = options;
		this.createMarkup = function($$parent) {
			this.$$panel = $(_getHtml("switcher", {
				id: this.options.id
			})).appendTo($$parent);
			this.setValue(this.options.checked);
			this.$$panel.bootstrapSwitch('onText', this.options.onText || locale.text("auth.switcher.onText"));
			this.$$panel.bootstrapSwitch('offText', this.options.offText || locale.text("auth.switcher.offText"));
			this.$$panel.bootstrapSwitch('size', this.options.size || "small");
			this.$$panel.bootstrapSwitch('onColor', this.options.onColor || "default");
			this.$$panel.bootstrapSwitch('offColor', this.options.offColor || "default");
			if (this.options.onSwitchChange) {
				this.$$panel.bootstrapSwitch('onSwitchChange', jsutils.bindFn(this.onSwitchChange, this));
			}
			return this.$$panel;
		};
		this.onSwitchChange = function(event, state) {
			this.options.onSwitchChange(event, state);
		};
		this.destroyMarkup = function() {
			this.options = null;
			if (this.$$panel) {
				this.$$panel.bootstrapSwitch('destroy');
				this.$$panel = null;
			}
		};
		this.getValue = function(value) {
			if (!this.$$panel) return;
			return this.$$panel.bootstrapSwitch('state');
		};
		this.setValue = function(value) {
			if (!this.$$panel) return;
			this.$$panel.bootstrapSwitch('state', value === true, true);
		};
	},
	"actionBtns": function(options, name) {
		this.name = name || "actionBtns";
		this.options = options;
		this.createMarkup = function($$parent) {
			this.$$panel = $(_getHtml("actionBtns", {
				btns: this.options.btns
			})).on('click', this.options.onClick).appendTo($$parent);
			return this.$$panel;
		};
		this.destroyMarkup = function() {
			this.options.onClick = null;
			this.options = null;
			if (this.$$panel) {
				this.$$panel.off();
				this.$$panel = null;
			}
		};
	},
	/**
	 * options.slideHandler(value, this) 	optional - returns the text to display
	 * options.stopHandler(value, this) 	optional
	 * options.startHandler(value, this)	optional
	 *
	 */
	"genericSlider": function(options, name) {
		this.name = name || "genericSlider";
		this.options = options;
		this.label = options.label;
		this.createMarkup = function($$parent) {
			var displayValue = this.options.displayValue || this.options.slideHandler != null;
			this.$$panel = $(_getHtml("genericSlider", {
				value: this.options.value,
				min: this.options.min,
				max: this.options.max,
				step: this.options.step || 1,
				valText: this.options.value != null ? this.options.slideHandler ? this.options.slideHandler(this.options.value, this) : this.options.value : "",
				displayValue: displayValue,
				margin: this.options.margin + ""
			}));
			$$parent.append(this.$$panel);
			this.$$textValue = $(".s-m-slider-value", this.$$panel);
			this.$$slider = $("input", this.$$panel).slider({});
			if (displayValue) {
				this.$$slider.on("slide", jsutils.bindFn(this.onSlider, this, "slide"));
			}
			if (this.options.stopHandler) {
				this.$$slider.on("slideStop", jsutils.bindFn(this.onSlider, this, "stop"));
			}
			if (this.options.startHandler) {
				this.$$slider.on("slideStart", jsutils.bindFn(this.onSlider, this, "start"));
			}
			if (displayValue === "above") {
				this.$$panel.find(".s-m-slider-value").detach().prependTo(this.$$panel.find("section"));
			}

		};

		this.destroyMarkup = function() {
			this.options.startHandler = null;
			this.options.stopHandler = null;
			this.options.slideHandler = null;
			this.options = null;
			if (this.$$slider) {
				this.$$slider.off();
				this.$$slider.slider('destroy');
				this.$$slider = null;
			}
			if (this.$$panel) {
				this.$$panel.remove();
			}
		};

		this.onSlider = function(slideEvt, action) {
			if (action === "start") {
				this.options.startHandler(slideEvt.value, this);
				return;
			}
			if (action === "slide") {
				this.$$textValue.text(this.options.slideHandler ? this.options.slideHandler(slideEvt.value, this) : slideEvt.value);
				return;
			}
			if (action === "stop") {
				if (this.options.value != slideEvt.value) {
					this.options.value = slideEvt.value;
					this.options.stopHandler(slideEvt.value, this);
				}
				return;
			}
		};

		this.update = function(opts) {
			if (!opts) return;
			if (opts.min != null) this.$$slider.slider('setAttribute', 'min', opts.min);
			if (opts.max != null) this.$$slider.slider('setAttribute', 'max', opts.max);
			if (opts.step != null) this.$$slider.slider('setAttribute', 'step', opts.step);
			if (opts.value != null) {
				this.$$slider.slider('setValue', opts.value);
				this.$$textValue.text(this.options.slideHandler ? this.options.slideHandler(opts.value) : opts.value);
			}
		};
	},
	/**
	 * lis:[{label, checked}]
	 */
	"checkboxList": function(options, name) {
		options = options || {};
		this.options = options;
		this.name = name || "checkboxList";
		this.createMarkup = function($$parent) {
			this.$$panel = $(_getHtml("checkboxList", {
				id: options.id,
				css: options.css || ""
			})).appendTo($$parent);
			if (options.isHidden === true) {
				this.hide();
			}
			if (this.options.onClick) {
				this.$$panel.on('click', 'input[type="checkbox"]', jsutils.bindFn(this.onClick, this));
			}
			this._createList(options.list);
			return this.$$panel;
		};
		this.destroyMarkup = function() {
			if (this.$$panel) {
				this.$$panel.find('input[type="checkbox"]').off();
				this.$$panel.off();
				this.$$panel = null;
			}
			this.options = null;
		};
		this.onClick = function(evt) {
			var $$input = $(evt.target);
			this.options.onClick($$input.closest(".s-m-item").attr("data-id"), $$input.is(":checked"));
		};
		/**
		 * Format	array 	-> [{id:id1, checked: true},{id2, checked: false}]
		 * Format	object 	-> {id1: true, id2:false}
		 * Default is object
		 */
		this.getValue = function(format) {
			if (!this._$$list) return null;
			var obj = format !== "array";
			var res = obj ? {} : [];
			this._$$list.find(".s-m-item").each(function() {
				var $$this = $(this);
				if (!$$this.is(":visible")) return;
				var checked = $$this.find("input:checkbox").prop("checked") === true;
				var id = $$this.attr("data-id");
				if (obj) {
					res[id] = checked;
				} else {
					res.push({
						checked: checked,
						id: id
					});
				}
			});
			return res;
		};
		this.setValue = function(list) {
			this.updateValue(list);
		};
		this.reset = function() {
			this.updateValue(null);
		};
		/**
		 * accept list
		 * 	{id1: true, id2:false}
		 * 	[{id:id1, checked: true},{id2, checked: false}]
		 */
		this.updateValue = function(list) {
			if (!this.$$panel) return;
			var self = this;
			self._$$list.find("[data-id]").each(function() {
				$(this).val(false);
			});
			list = this._checkInputList(list);
			if (list.length === 0) return;
			list.forEach(function(itm) {
				if (!itm || !itm.id) return;
				var $$item = self._$$list.find('[data-id="' + itm.id + '"]');
				if ($$item.length === 0) return;
				if (itm.isHidden === true) $$item.hide();
				if (itm.checked !== true) return;
				$$item.attr("data-id", itm.id);
				$$item.find("input:checkbox").prop("checked", itm.checked === true);
				$$item.find("label").text(itm.label);
			});
		};
		/**
		 * accept list
		 * 	{id1: true, id2:false}
		 * 	[{id:id1, checked: true},{id2, checked: false}]
		 */
		this._createList = function(list) {
			if (!this.$$panel) return;
			if (this._$$list) this._$$list.remove();
			list = this._checkInputList(list);
			var newList = [];
			list.forEach(function(itm) {
				if (itm.id) {
					itm.id = itm.id;
					itm.checked = itm.checked === true;
					itm.label = itm.label || itm.id;
					newList.push(itm);
				}
			});
			this._$$list = $(_getHtml("checkboxListContent", {
				list: newList
			})).appendTo(this.$$panel);
		};
		this._arrayToPlainobject = function() {

		};
		// accept {id1: true, id2:false} and return [{id:id1, checked: true},{id2, checked: false}]
		this._checkInputList = function(list) {
			if (!list) return [];
			if (Array.isArray(list)) return list;
			if (!$.isPlainObject(list)) return [];
			var res = [];
			for (var p in list) {
				res.push({
					id: p,
					checked: list[p] === true
				});
			}
			return res;
		};
	}
};
/**
 * type:	genericSlider, flatRadio, select, actionBtns
 * opts:	depends on component
 * name:	name of property / optional
 */
exports.newComponent = function(type, opts, name) {
	var f = _components[type];
	if (!f) throw new Error("Unknown authoring component [" + type + "]");
	return new f(opts, name);
};
});

define('syracuse-tablet/html/js/authoring/authoringCommons',['require','exports','module','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var modules = require('syracuse-tablet/html/js/common/modules');

exports.getCurrentUserLang = function() {
	var up = modules.get("appController").App.getCurrentUserProfile();
	return up.selectedLocale.code;
}

exports.getCurrentPage = function() {
	var navStack = modules.get("navStack").getMainStack();
	var currentPage = navStack && navStack.getTopPage();
	return currentPage;
}

exports.getCurrentUserUuid = function() {
	var up = modules.get("appController").App.getCurrentUserProfile();
	return up.user.$uuid;
}

exports.queryLocalePreferences = function() {
	return modules.get("ajax").request("/sdata/syracuse/collaboration/syracuse/localePreferences?representation=localePreference.$bulk")
		.then(function(result) {
			return result.data && result.data.$resources || [];
		});
}

exports.getSecurityProfile = function() {
	var up = modules.get("appController").App.getCurrentUserProfile();
	return up && up.securityProfile;
}

exports.isNonSaveablePage = function() {
	var page = exports.getCurrentPage();
	var $url = page && page.pageData && page.pageData.$url;
	if ($url && $url.indexOf("/$client/") > -1) {
		return true;
	}
	return false;
}
});

define('syracuse-tablet/html/js/ui/modals/modalTranslationPage',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
		<buttons class="pull-right"> \
			<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
			<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
		</buttons> \
		<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="form-group"> \
					<table class="s-m-translation" >\
					<tr>\
					<th>{{currentLang.title}}</th><th>{{translateLang.title}}</th>\
					</tr>\
					{{#each localizations}}\
					<tr>\
					<td>{{this.value}}</td><td><input type="text" id="{{this.key}}" value="{{this.valueTranslate}}"></td>\
					</tr>\
					{{/each}}\
					</table>\
				</div> \
			</div>',

	footer: '',
};

var _Klass = utils.defineClass(
	function ModalTranslationPage(ctx) {
		this.context = $.extend(true, {}, ctx);
		modalDialog.ModalBase.call(this);
		this.result = null;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			return {
				std: _templateAll
			};
		},
		_getDataContext: function() {
			var localizations = [],
				$localization = this.context.$localization,
				currentLang = this.context.currentLang,
				translateLang = this.context.translateLang;
			if (!$localization[currentLang.value]) return [];
			Object.keys($localization[currentLang.value]).forEach(function(key) {
				if ($localization[currentLang.value][key]) {
					localizations.push({
						'key': key,
						'value': $localization[currentLang.value][key],
						'valueTranslate': ($localization[translateLang.value] && $localization[translateLang.value][key]) ? $localization[translateLang.value][key] : "",
					});
				}
			});
			var data = {};
			data.localizations = localizations;
			data.currentLang = currentLang;
			data.translateLang = translateLang;
			data.title = this.context.pageTitle;
			return data;
		},
		_onShow: function() {
			modalDialog.ModalBase.prototype._onShow.call(this);
		},
		_onValidate: function() {
			var currentLang = this.context.currentLang.value,
				translateLang = this.context.translateLang.value,
				localization = this.context.$localization,
				value, res;

			Object.keys(localization[currentLang]).forEach(function(key) {
				value = $("input[id='" + key + "'").val();
				if (localization[translateLang] && localization[translateLang][key] !== "") { //keep existing value
					if (!res) res = {};
					res[key] = localization[translateLang][key];
				}
				if ((!localization[translateLang] && value !== "") || //no localization and at less a value filled
					(localization[translateLang] &&
						((localization[translateLang][key] && value != localization[translateLang][key]) || //key but value dif
							(!localization[translateLang][key] && value)))) { //no key new value
					if (!res) res = {};
					res[key] = value;
				}
			});
			if (res) {
				localization[translateLang] = res;
				this.result = localization;
			}
		},
		_onCancel: function() {
			this.result = null;
		},
		_getResult: function() {
			return this.result;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral',['require','exports','module','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/authoring/authoringVal','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/authoring/authoringCommons','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/ui/modals/modalTranslationPage'],function (require, exports, module) {
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var authVal = require('syracuse-tablet/html/js/authoring/authoringVal');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var authCommons = require('syracuse-tablet/html/js/authoring/authoringCommons');
var modules = require('syracuse-tablet/html/js/common/modules');

var modalTranslationPage = require('syracuse-tablet/html/js/ui/modals/modalTranslationPage');

var _colorPalette = [{
	title: "primecolor",
	items: ["sagegreen", "green", "blue", "darkgrey", "white", "black"]
}, {
	title: "secondcolor",
	items: ["lightgreen", "grey", "medium-grey", "orange", "purple", "medium-purple", "skyblue"]
}, {
	title: "notifcolors",
	items: ["alert", "warning"]
}];
var _cachePalette = {};
var _getColorPalette = function() {
	if (_cachePalette.colorPalette) {
		return _cachePalette.colorPalette;
	}
	_cachePalette.colorPalette = [];
	var _scan = function(items, array) {
		array = array || [];
		items.forEach(function(item) {
			if (item.items) {
				var items = _scan(item.items);
				array.push({
					title: item.title ? locale.text("colorsPalette." + item.title) : null,
					items: items
				});
			} else if (typeof item === "string") {
				var id = item.toLowerCase();
				array.push({
					id: id,
					name: locale.textNoFail("colorsPalette.colors." + id) || item.smCapitalize(),
					css: "s-m-color-" + id
				});
			}
		});
		return array;
	};
	return _scan(_colorPalette, _cachePalette.colorPalette);
};
/**
 * Returns a standard value/label list
 */
var _getColorValues = function() {
	if (_cachePalette.colorValues) {
		return _cachePalette.colorValues;
	}
	_cachePalette.colorValues = [];
	var _scan = function(items) {
		items.forEach(function(item) {
			if (item.items) {
				_scan(item.items);
			} else if (typeof item === "string") {
				_cachePalette.colorValues.push({
					value: item.toLowerCase(),
					label: locale.textNoFail("colorsPalette.colors." + item) || item.smCapitalize()
				});
			}
		});
	};
	_scan(_colorPalette);
	return _cachePalette.colorValues;
};
/**
 * Returns info  for color id
 */
var _getColorInfo = function(id) {
	if (_cachePalette.colorInfos) {
		return _cachePalette.colorInfos[id];
	}
	_cachePalette.colorInfos = {};
	_getColorValues().forEach(function(color) {
		_cachePalette.colorInfos[color.value] = {
			id: color.value,
			name: color.label,
			css: "s-m-color-" + color.value
		};
	});
	return _cachePalette.colorInfos[id];
};
var _openInNewTab = function(tabid, jsonString, title) {
	if (!jsonString || jsonString.trim().length === 0) return;
	var myWindow = window.open("about:blank", tabid, undefined, true);
	setTimeout(function() {
		myWindow.document.write("<html><body><pre>" + (title ? title + "\n" : "") + locale.text("auth.panel.label_date") + ": " + (new Date()).toLocaleString() + "</pre><pre>" + jsonString + "</pre></body></html>");
	});
};

var _properties = {
	/*
	 * Dummy to add a separator
	 */
	"SEPARATOR": {
		isSeparatror: true
	},

	/*
	 * Full JSON article of selection for experts
	 */
	"JSON": {
		"key": "$JSON",
		createMarkup: _createMarkupJSON,
		type: "expert"
	},
	/*
	 * Read only display of prototype
	 */
	"PROTOTYPE": {
		"key": "$PROTOYPE",
		createMarkup: _createMarkupPrototype,
		type: "expert"
	},
	"translation": function(controller, sel, data) {
		if (!data.articleSelection.$localization ||
			$.isEmptyObject(data.articleSelection.$localization[authCommons.getCurrentUserLang()])) {
			return null;
		}

		this.name = "translation";
		this.type = "expert";
		this.createMarkup = function($$parent, prop, sel, data) {
			var self = this;
			authCommons.queryLocalePreferences()
				.then(function(ls) {
					var selectOpts = [];
					ls.forEach(function(v) {
						selectOpts.push({
							'title': v.description,
							'value': v.code
						});
					});
					var opts = {
						options: selectOpts,
						//onChange: self.onChange.bind(self, $$parent)
						onChange: self.onChange.bind(self, $$parent, data)

					};
					self.langList = authComponents.newComponent("select", opts, "selectLang");
					self.langList.createMarkup($$parent);
				});

		};
		this.onChange = function($$parent, data, event, componentSelect) {
			var context = {};
			context.$localization = data.articleSelection.$localization;
			context.currentLang = {
				'value': authCommons.getCurrentUserLang(),
				'title': getLangDescription(authCommons.getCurrentUserLang(), componentSelect.options.options)
			};
			context.translateLang = {
				'value': componentSelect.getValue(),
				'title': getLangDescription(componentSelect.getValue(), componentSelect.options.options)
			};
			this.buildPanel($$parent, data, context);
		};
		this.buildPanel = function($$parent, data, context) {
			if (this.$$panel == undefined) {
				var html = authHtml.execute("authPanelButton", {
					label: locale.text("auth.translation.openPage"),
					css: "s-m-auth-translation-open"
				});
				this.$$panel = $(html);
				this.$$panel.attr("data-action", "openTranslation");
				$$parent.append(this.$$panel);
			} else {
				this.$$panel.off("click");
			}
			var eventData = {};
			eventData.$$parent = $$parent;
			eventData.data = data;
			eventData.context = context;
			eventData.context.pageTitle = locale.text("auth.translation.page"),
				this.$$panel.click(eventData, function() {
					var modal = new modalTranslationPage.Modal(eventData.context);
					modal.show().then(function(result) {
						if (result) {
							eventData.data.articleSelection.$localization = result;
							_notifyChangePropUI(eventData.$$parent, null, eventData.data);
						}
					}).fail(function(e) {
						modules.get("modal").error(e);
					});
				});
		};
	}
};

function _createMarkupJSON($$parent, prop, sel, data) {
	// This is only displayed if the full page is selected, so we always show the article of the page and not the article
	// of the selected UI compontent (UI component is always the page)
	var value = authVal.toSortedJSON(data.articlePage);
	var html = authHtml.execute("authPanelPropertyJSON", {
		id: "auth_opt_" + prop.name,
		value: value,
		label_apply: locale.text("auth.panel.label_apply"),
		label_display: locale.text("auth.panel.label_display")
	});
	var $$panel = $(html);
	var title = sel.$$elmt.text();
	var _getJson = function(validate) {
		var val = $("textarea", $$panel).val();
		var articleParsed;
		if (validate) {
			articleParsed = authVal.validateJSON(true, $("textarea", $$panel).val(), _properties);
		} else {
			try {
				articleParsed = JSON.parse(val);
			} catch (e) {
				return jsutils.convertToDiagnoses(e);
			}
		}
		return articleParsed ? authVal.toSortedJSON(articleParsed) : null;
	};
	$("a[data-action]", $$panel).click(function() {
		var act = $(this).attr("data-action");
		try {
			if (act === "jsonApply") {
				// Full page article exchange
				var articleString = _getJson(true);
				if (articleString) {
					notifications.publish(["sm.auth.change.prop.ui"], articleString);
				}
			} else if (act === "openInNewTab") {
				var title = authCommons.getCurrentPage().getPrototype().getValueByPath("$title", true);
				title = title && title.length > 0 ? locale.text("auth.panel.label_page") + ": " + title : "";
				_openInNewTab("sageMobileJsonAuthoring", _getJson(false), title);
			}
		} catch (e) {
			console.log(e.stack);
			throw (e);
		}
	});
	$$parent.append($$panel);
}

function _createMarkupPrototype($$parent, prop, sel, data) {
	var json;
	var title;
	if (data.control) {
		json = data.control.prototype && data.control.prototype.json;
		title = data.control.$bind || data.control.id;
	} else if (data.page) {
		var proto = data.page.getPrototype();
		title = proto.data("$title");
		json = proto && proto.json;
	}
	var value;
	if (json) {
		value = JSON.stringify(json, null, " ");
	} else {
		value = locale.text("auth.PROTOTYPE_NONE");
	}
	var html = authHtml.execute("authPanelPropertyPROTOTYPE", {
		id: "auth_opt_" + prop.name,
		value: value,
		label_display: locale.text("auth.panel.label_display")
	});
	var $$panel = $(html);
	$$parent.append($$panel);
	if (json && !$.isEmptyObject(json)) {
		$("a[data-action]", $$panel).click(function() {
			var act = $(this).attr("data-action");
			if (act === "openInNewTab") {
				title = locale.text("auth.panel.label_" + (data.control ? "control" : "page")) + ": " + title;
				_openInNewTab("sageMobilePrototype", authVal.toSortedJSON(json), title);
			}
		});
	}
}
var _initProperty = function(p) {
	var pre = "auth";
	var lk = pre + "." + p.name;
	if (p.label == null) {
		p.label = locale.text(lk);
	}
	if (p.values) {
		p.values.forEach(function(v, idx) {
			if ($.isPlainObject(v)) {
				var vk = lk + "." + ("" + ((v.value != null ? v.value : v.key)));
				if (v.label == null) {
					v.label = locale.text(vk);
				}
			} else {
				p.values[idx] = {
					label: v + "",
					valu: v
				};
			}
		});
	}
};
var _initProperties = function(properties, dest) {
	var pre = "auth";
	Object.keys(properties).forEach(function(prop) {
		var p = properties[prop];
		if (dest) {
			dest[prop] = p;
		}
		if (typeof p === "function") {
			return;
		}
		p.name = prop;
		_initProperty(p);
	});
};

var _err = function(title, ee) {
	modal.error(title, ee);
	return true;
};

function getLangDescription(lang, langList) {
	var desc;
	langList.forEach(function(v) {
		if (v.value === lang) {
			desc = v.title;
		}
	});
	return desc;
}

function _getValueOrDefault(prop, sel, data) {
	var value = data.articleSelection && data.articleSelection[prop.key];
	value = (value != null) ? value : prop["default"];
	return value;
}

function _setValue(prop, sel, data, value) {
	data.articleSelection[prop.key] = value;

	// To flag control that has been changed
	data.articleSelection["$isDirty"] = data.articleSelection["$isDirty"] || {};
	data.articleSelection["$isDirty"][prop.key] = true;
}

function _notifyChangePropUI($$parent, sel, data) {
	var $$json = $("textarea#auth_opt_JSON");
	$$json.val(authVal.toSortedJSON(data.articleSelection));
	notifications.publish(["sm.auth.change.item.prop.ui"], data);
}

function _notifyAuthVariantChange(article) {
	var articleString = authVal.toSortedJSON(article);
	$("textarea#auth_opt_JSON").val(articleString);
	notifications.publish(["sm.auth.change.prop.ui"], articleString);
}

function _createMarkupRadio($$parent, prop, sel, data) {

	var ctx = {
		group: "auth_opt_" + prop.name,
		options: []
	};

	var value = _getValueOrDefault(prop, sel, data);
	var allHidden = true;

	prop.values.forEach(function(v) {
		ctx.options.push({
			id: ctx.group + "_" + v.value,
			value: "" + v.value,
			label: v.label,
			display: (v.isHidden ? "none" : "block")
		});
		allHidden = allHidden && v.isHidden;
	});

	var html = authHtml.execute("authPanelPropertyRadio", ctx);
	var $$panel = $(html);
	$("label[data-s-m-auth-value='" + ("" + value) + "']", $$panel).eq(0).button("toggle");
	$("label", $$panel).on("click", function(e) {
		var $$ct = $(e.currentTarget).closest('[data-s-m-auth-value]');
		var value = $$ct.attr("data-s-m-auth-value");
		$$ct.eq(0).button("toggle");

		/*
		 * Important! Use boolean datatype for boolean properties!
		 */
		if (value === "true") {
			value = true;
		} else if (value === "false") {
			value = false;
		}
		_setValue(prop, sel, data, value);
		_notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);

	if (allHidden) {
		$$parent.parent(".s-m-panel-auth-prop").hide();
	} else {
		$$parent.parent(".s-m-panel-auth-prop").show();
	}
}

function _refreshMarkupRadio($$parent, prop, sel, data) {
	var allHidden = true;
	prop.values.forEach(function(v) {
		var id = "auth_opt_" + prop.name + "_" + v.value;
		var $$btn = $("#" + id, $$parent);
		var display = v.isHidden ? "none" : "block";
		$$btn.css("display", display);
		allHidden = allHidden && v.isHidden;
	});
	if (allHidden) {
		$$parent.parent(".s-m-panel-auth-prop").hide();
	} else {
		$$parent.parent(".s-m-panel-auth-prop").show();
	}
}

function _createMarkupCheckboxes($$parent, prop, sel, data) {

	var ctx = {
		group: "auth_opt_" + prop.name,
		options: []
	};

	var allHidden = true;

	var value = data.articleSelection && data.articleSelection[prop.key] || {};
	prop.values.forEach(function(v) {
		var cb = value[v.key] != null ? value[v.key] : v["default"];
		ctx.options.push({
			id: ctx.group + "_" + v.key,
			value: v.key,
			label: v.label,
			checked: cb,
			display: (v.isHidden ? "none" : "block")
		});
		allHidden = allHidden && v.isHidden;
	});

	var html = authHtml.execute("authPanelPropertyCheckbox", ctx);
	var $$panel = $(html);

	$("label", $$panel).on("click", function(e) {
		// #7840 We use an icon instead of a check box because click with input tag doesn't work fin with the label
		var $$ct = $(e.target).closest('[data-s-m-auth-value]');
		var key = $$ct.attr("data-s-m-auth-value");
		var $$cb = $("i", $$ct);
		var value = $("i", $$ct).toggleClass("fa-check-square").is(".fa-check-square");
		var v = data.articleSelection[prop.key] = data.articleSelection[prop.key] || {};
		v[key] = value;
		_notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);

	if (allHidden) {
		$$parent.parent(".s-m-panel-auth-prop").hide();
	} else {
		$$parent.parent(".s-m-panel-auth-prop").show();
	}
}

function _refreshMarkupCheckboxes($$parent, prop, sel, data) {
	var allHidden = true;
	prop.values.forEach(function(v) {
		var id = "auth_opt_" + prop.name + "_" + v.key;
		var $$btn = $("#" + id, $$parent);
		var display = v.isHidden ? "none" : "block";
		$$btn.css("display", display);
		allHidden = allHidden && v.isHidden;
	});
	if (allHidden) {
		$$parent.parent(".s-m-panel-auth-prop").hide();
	} else {
		$$parent.parent(".s-m-panel-auth-prop").show();
	}
}

function _createMarkupIconPicker($$parent, prop, sel, data) {
	var value = data.articleSelection && data.articleSelection[prop.key] || null;
	var opts = {
		palette: prop["values"] || [],
		dropUp: prop["dropUp"] || true,
		onSelectIcon: function(value) {
			_setValue(prop, sel, data, value);
			_notifyChangePropUI($$parent, sel, data);
		}
	};
	prop._paletteIcon = authComponents.newComponent("iconPalettePicker", opts);
	prop._paletteIcon.createMarkup($$parent);
	prop._paletteIcon.setValue(data.articleSelection[prop.key] || prop["default"]);
}

function _destroyMarkupIconPicker($$parent, prop, sel, data) {
	if (prop._paletteIcon) {
		prop._paletteIcon.destroyMarkup();
		prop._paletteIcon = null;
	}
}

exports.getColorValues = _getColorValues;
exports.getColorPalette = _getColorPalette;
exports.getColorInfo = _getColorInfo;

exports.properties = _properties;
exports.err = _err;
exports.createMarkupIconPicker = _createMarkupIconPicker;
exports.destroyMarkupIconPicker = _destroyMarkupIconPicker;
exports.createMarkupRadio = _createMarkupRadio;
exports.refreshMarkupRadio = _refreshMarkupRadio;
exports.createMarkupCheckboxes = _createMarkupCheckboxes;
exports.refreshMarkupCheckboxes = _refreshMarkupCheckboxes;
exports.getValueOrDefault = _getValueOrDefault;
exports.setValue = _setValue;
exports.notifyAuthVariantChange = _notifyAuthVariantChange;
exports.notifyChangePropUI = _notifyChangePropUI;
exports.initProperties = _initProperties;
exports.initProperty = _initProperty;

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	// Always add JSON editting and proto display
	props.push(_properties.SEPARATOR);
	if ($$elmt.is(".s-m-page")) {
		props.push(_properties.JSON);
		props.push(_properties.SEPARATOR);
		props.push(_properties.PROTOTYPE);
		props.push(_properties.SEPARATOR);
		props.push(_properties.translation);
	} else if (data && data.control && data.control.prototype) {
		props.push(_properties.PROTOTYPE);
	}
};

exports.initModuleProperties = function(dest) {
	exports.initProperties(_properties, dest);
};
});

define('syracuse-tablet/html/js/authoring/arrays/authArrayGeneral',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

var _templates = {
	subtitle: '\
		<section class="s-m-prop-subtitle" {{#if id}}id="{{id}}"{{/if}} style="{{#if notHidden}}overflow:hidden;{{/if}}white-space:nowrap;text-overflow:ellipsis;{{#if margin}}margin-bottom:{{margin}}px;{{/if}}">\
			{{#if title}}<p>{{title}}</p>{{/if}}\
			<div></div>\
		</section>',
	subPropTitle: ' \
		<div class="panel panel-primary s-m-panel-auth-prop s-m-auth-prop-type-{{type}}"> \
			<div style="overflow:hidden;" class="panel-heading" role="tab" id="heading_{{id}}"> \
				<a style="width:100%;display:table;" data-toggle="collapse" data-parent="#{{#if parentId}}{{parentId}}{{/if}}{{#unless parentId}}accordion{{/unless}}" href="#collapse_{{id}}" {{#if expanded}} aria-expanded="true"{{/if}} aria-controls="collapse_{{id}}" {{#unless expanded}}class="collapsed"{{/unless}}>\
					<div style="display:table-row;white-space: nowrap;">\
						<h4 class="panel-title" style="display:table-cell;"> \
							{{label}}\
						</h4> \
						{{#if info}}<span style="padding-left: 10px;font-size:x-small;display:table-cell;text-align: right;"><i>{{info}}</i></span>{{/if}}\
					</div>\
				</a> \
			</div> \
			<div id="collapse_{{id}}" class="panel-collapse collapse {{#if expanded}}in{{/if}}" role="tabpanel" aria-labelledby="heading_{{id}}"> \
			</div> \
		</div>',
	statusLine: '\
		<span style="display:table;table-layout:fixed;width:100%">\
			<span style="display:table-row;">\
				<span style="display:table-cell;overflow:hidden;text-overflow:ellipsis;white-space: nowrap;">{{field}} {{operator}} {{value}}</span>\
				<span class="{{css}}" style="{{style}}display:table-cell;width:{{sizeColor}}px;height:{{sizeColor}}px;margin-right:5px;"></span>\
			</span>\
		</span>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};

var _properties = {
	/**
	 * Optional sel, data
	 * 	 not null when button property is created like a regular panel propety
	 *	 null when property is created from rightPanel (back from cardDesign to array)
	 */
	"chartDetailButton": function(controller, sel, data) {
		this.name = null;
		this.label = null;
		this.key = null;
		this.controller = controller;
		this.control = data.control;
		this.createButtonMarkup = function() {
			var level = this.control.level;
			var label = "auth." + ((level > 0 && this.control.hasSublevel()) ? "subLevel" : "chartDetail") + ".openDesign";
			this.$$OpenButton = $('<button id="auth_opt_chart_design" type="button" class="btn btn-default">' + locale.text(label) + '</button>');
			this.$$OpenButton.on("click", jsutils.bindFn(this.onClickButton, this));
			return this.$$OpenButton;
		};

		this.destroyButtonMarkup = function(context) {
			this.control = null;
			this.controller = null;
			if (this.$$OpenButton) {
				// $$slider.find(".$$slider") to make sur the plugin has been initialized
				this.$$OpenButton.off("click");
				this.$$OpenButton.remove();
				this.$$OpenButton = null;
			}
		};
		//TODO : remove this, think no used
		this.onClickButton = function(evt) {
			var opt = null,
				level = 0;
			if (this.control.hasSublevel()) {
				level = this.control.level + 1;
				var rowId = this.control.rowIdx2Id(0);
				opt = this.control.drillDownOpt(rowId);
				opt.level = level;
				if (level > 1) {
					opt.action = "$drillDown";
				}
			};
			this.control.triggerOpenChartDetail(opt);
			this.destroyButtonMarkup();
		};
	},
	"arrayDisplay": function(controller, sel, data) {
		this.name = "arrayDisplay";
		this.label = null;
		this.key = "$display";
		this["default"] = "table";
		this.values = [];
		var self = this;
		["table", "separator", "card", "carousel", "chart"].forEach(function(val) {
			if (data.control.isAuthoringPropAllowed("arrayDisplay", val)) {
				self.values.push({
					value: val
				});
			}
		});
		this.createMarkup = authPropsGeneral.createMarkupRadio;
		this.refreshMarkup = authPropsGeneral.refreshMarkupRadio;
	},
	// only card
	"arraySeparator": {
		"key": "$separator",
		"default": "blank",
		values: [{
			value: "blank"
		}, {
			value: "dash"
		}, {
			value: "colon"
		}, {
			value: "semicolon"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio
	},
	// only query array
	"arrayProtoFilters": function(controller, sel, data) {
		this.name = "arrayProtoFilters";
		this.label = null;
		this.key = "$filters";
		// No filters displayed by default for vignette
		this["default"] = data.control.page.isVignette() ? "none" : "list";
		this.values = [{
			value: "list"
		}, {
			value: "tabs"
		}, {
			value: "none"
		}];
		this.createMarkup = authPropsGeneral.createMarkupRadio;
		this.refreshMarkup = authPropsGeneral.refreshMarkupRadio;
	},

	// only query array - link to details values are created dynamically
	"arrayQueryLink": function(controller, sel, data) {
		this.name = "arrayQueryLink";
		this.label = null;
		this.isHidden = true;
		this.values = [];
		this.key = "$detailsLink";
		this["default"] = "$details";
		this.createMarkup = authPropsGeneral.createMarkupRadio;
		this.refreshMarkup = authPropsGeneral.refreshMarkupRadio;

		this.initMarkup = function(controller, sel, data) {
			var links = data.control.prototype.getValueByPath("$item.$links");
			if (!links || links.length === 0) return;
			if (data.control.page.isVignette()) {
				// Add the capability to open query full page - Default option
				this["default"] = "$queryfullpage";
				this.values.push({
					value: "$queryfullpage",
					label: locale.text("auth.arrayQueryLink.queryfullpage")
				});
			}
			var self = this;
			// Add $links
			$.each(links, function(key, link) {
				var method = (link && link.$method) || "GET";
				if (link && method === "GET") {
					// For system level links (starting with $, we only allow the ones we know they are supported right now)
					if (key.indexOf("$") !== 0 || ["$edit", "$details"].indexOf(key) > -1) {
						self.values.push({
							value: key,
							label: link.$title ? controller.dataset.resolveExpression(link.$title) + " - " + key : key
						});
					}
				}
			});
			this.isHidden = (this.values.length === 1 && this.values[0].value === "$details");
		};
	},

	// Options of array
	"arrayOptions": function(controller, sel, data) {
		this.name = "arrayOptions";
		this.label = null;
		this.key = "$arrayOptions";
		var ctrl = data.control;
		var isVignette = data.control.page.isVignette();
		this.values = [];
		if (ctrl.isArrayChart() && ctrl.isHighChart()) {
			// Only pagination for array in chart display
			this.values.push({
				"key": "showPagination",
				"default": false
			});
		} else {
			// Other than chart display
			if (!ctrl.isArrayField()) {
				// Arrays outside a details page
				this.values.push({
					"key": "showPagination",
					"default": isVignette ? false : true
				});
				if (!ctrl.isArrayChart()) {
					// Filter and search disabled for request and stats
					this.values.push({
						"key": "showSortFilter",
						"default": isVignette ? false : true
					});
					this.values.push({
						"key": "showSearch",
						"default": isVignette ? false : true
					});
				}
			}
			if (ctrl.$display === "table" && !ctrl.isSingleArray() && !ctrl.isArrayChart() && !controller.dataset.prototype.isQueryLikeFacet()) {
				this.values.push({
					"key": "showRowDetailLink",
					// No row detail link by default
					"default": false
				});
			}
			this.values.push({
				"key": "rowIndex",
				"default": ctrl.$display === "card"
			});
			if (ctrl.$display === "card") {
				this.values.push({
					"key": "hideEmptyRows",
					"default": false
				});
			}
		}
		this.createMarkup = authPropsGeneral.createMarkupCheckboxes;
		this.refreshMarkup = authPropsGeneral.refreshMarkupCheckboxes;
	}
};

exports.getHtml = _getHtml;

exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	// TODO: Detail pages could be authored as stand alone pages and just inject their article in the parent
	/*
	if (data.control.isArrayChart() && (controller.state.type !== "chartdetail" || data.control.hasSublevel())) {
		// button to open the detail of the chart (to design it)
		// Also button to open sub level design
		props.push(_properties.chartDetailButton);
	}
	*/
	props.push(_properties.arrayDisplay);

	if (data.control.isSingleArray()) {
		if (data.control.$display === "separator") {
			props.push(_properties.arraySeparator);
		}
	} else {
		// For chart and other arrays
		if (data.control.displayAsCarousel !== true) {
			props.push(_properties.arrayOptions);
		}

		if (!sel.$$elmt.is(".s-m-control.s-m-chart") && data.control.displayAsCarousel !== true) {
			// For non-chart arrays
			if (data.control.$filtersAllowed()) {
				props.push(_properties.arrayProtoFilters);
			}
			if (controller.dataset.prototype.isQuery()) {
				props.push(_properties.arrayQueryLink);
			}
		}
	}
};
});

define('syracuse-tablet/html/js/authoring/arrays/authArrayTable',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/arrays/authArrayGeneral','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authArrayGeneral = require('syracuse-tablet/html/js/authoring/arrays/authArrayGeneral');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _maxCharWidth = 50;
var _defCharWidth = 20;
var _defPercentWidth = 20;
var _tableConfigKeys = ["$bind", "$type", "$titleOrig", "$widthType", "$widthVal", "$refDescFormat", "$refDescPosition", "$imgIcon", "$imgDisplayIcon", "$imgHeight"];

/**
 * Panel which displays the settings of a columns
 * 	FIELD - WIDTH - X-REFERENCE params
 */
var _TableColumnPanel = function(parent, colInfo) {
	this.name = "arrayTableColumn";
	this.label = colInfo.$title || colInfo.$bind;
	this.parent = parent;
	this.colInfo = colInfo;
	if (parent.isSingleArray || !this.colInfo.$widthType) {
		this.colInfo.$widthType = "auto";
	}
	this._myProperties = [];

	this.createMarkup = function($$parent) {
		this.$$parent = $$parent;
		if (!parent.isSingleArray) {
			this.colNameChoiceAdd();
			this.colWidthTypeAdd();
			this.colWidthValAdd();
		}
		this.colXrefAdd();
		this.colImageAdd();
		this.colImgHeightAdd();
	};

	this._add2PropHeading = function(title, prop, $$forceParent) {
		var $$root = $(authArrayGeneral.getHtml('subtitle', {
			title: title,
			margin: 10,
			id: prop.name
		})).appendTo($$forceParent || this.$$parent).find("div");
		if (prop.name === "selectName") {
			$$root.css({
				textOverflow: "inherit"
			});
		}
		if (prop.createMarkup) {
			prop.createMarkup($$root);
			this._myProperties.push(prop);
		} else if (prop.jquery) {
			$$root.append(prop);
		}
		return prop;
	};
	// COL NAME CHOICE
	this.colNameChoiceAdd = function() {
		var idx = this.parent.getFieldProto(this.colInfo.$bind).idx;
		var selectOpts = [];
		this.parent._protoValue.forEach(function(v) {
			selectOpts.push({
				title: v.$title,
				value: v.$bind
			});
		});
		var opts = {
			value: this.colInfo.$bind,
			options: selectOpts,
			onChange: jsutils.bindFn(this.colNameSelect, this),
		};
		this._add2PropHeading(locale.text('auth.tableDesign.selColName'), authComponents.newComponent("select", opts, "selectName"));
	};
	this.colNameSelect = function(event, prop) {
		this.colInfo = this.parent.getFieldProto($(event.target).val()).value;
		var $$title = prop.$$panel.closest(".panel-primary").find(".panel-title");
		$$title.text(this.colInfo.$title);
		$$title.next("span").find("i").text(this.colInfo ? this.colInfo.$bind : "");
		this.$$xrefroot.toggle(this.colInfo.$type === "application/x-reference");
		this.$$imageroot.toggle(this.colInfo.$type === "image");
	};
	// COL TYPE WIDTH	
	this.colWidthTypeAdd = function() {
		this._add2PropHeading(locale.text("auth.tableDesign.width"), authComponents.newComponent("flatRadio", {
			btns: [{
				value: "auto",
				title: locale.text("auth.tableDesign.auto")
			}, {
				value: "fixed",
				title: locale.text("auth.tableDesign.fixed")
			}, {
				value: "percent",
				title: "%"
			}],
			onClick: jsutils.bindFn(this.colWidthTypeChanged, this),
			value: this.colInfo.$widthType || "auto"
		}));
	};
	this.colWidthTypeChanged = function(evt) {
		if ($(evt.target).val() !== this.colInfo.$widthType) {
			this.colInfo.$widthType = $(evt.target).val();
			this.colWidthValUpdt();
		}
	};
	// COL VALUE	
	this.colWidthValAdd = function() {
		var opts = {
			slideHandler: jsutils.bindFn(this.colWidthValSlide, this),
			stopHandler: jsutils.bindFn(this.colWidthValChange, this),
			value: this.colInfo.$widthVal || 0,
			min: 0,
			max: this.colInfo.$widthType === "percent" ? 100 : _maxCharWidth,
			margin: 0
		};
		this.propWidthVal = this._add2PropHeading(locale.text("auth.tableDesign.selWidth"), authComponents.newComponent("genericSlider", opts));
		this.colWidthValUpdt(opts.value);
	};
	this.colWidthValSlide = function(val, prop) {
		return this.colInfo.$widthType === "percent" ? val + "%" : val + " " + locale.text("auth.tableDesign.characters");
	};
	this.colWidthValChange = function(val, prop) {
		this.colInfo.$widthVal = val;
	};
	this.colWidthValUpdt = function(forceValue) {
		var show = this.colInfo.$widthType !== "auto";
		this._toggleProp(this.propWidthVal, show);
		if (!show) {
			return;
		}
		this.propWidthVal.update({
			value: forceValue || (this.colInfo.$widthType === "percent" ? _defPercentWidth : _defCharWidth),
			max: this.colInfo.$widthType === "percent" ? 100 : _maxCharWidth,
		});
	};
	// COL X-REFERENCE
	this.colXrefAdd = function() {
		var style = this.colInfo.$type !== "application/x-reference" ? "display:none" : "";
		this.$$xrefroot = $('<section class="xrefColumn" style="' + style + '" ></section>').appendTo(this.$$parent);
		// Description format - $refDescPosition, $refDescFormat are x-reference properties
		// First
		var pos = this.colInfo["$refDescPosition"] || "bottom";
		this._xrefDescrPos = this._createXRefSelect("pos", ["bottom", "right", "left", "top", "none"], pos);
		// Second
		this._xrefDescrFmt = this._createXRefSelect("fmt", ["desc", "title", "desctitle", "titledesc"], this.colInfo["$refDescFormat"] || "desc");
		// hide fmt if pos == none
		this.$$xrefroot.find("#selectDescrfmt").toggle(pos !== "none");
	};
	this._createXRefSelect = function(type, codes, def) {
			var selectOpts = [];
			var defIdx = codes.indexOf(def);
			if (defIdx == -1) defIdx = 0;
			var textRoot = "auth." + (type == "fmt" ? "refDescFormat" : "refDescPosition");
			codes.forEach(function(code, idx) {
				selectOpts.push({
					// Used by colXrefChange
					code: code,
					title: locale.text(textRoot + "." + code),
					value: idx
				});
			});
			var opts = {
				value: defIdx,
				options: selectOpts,
				onChange: jsutils.bindFn(this.colXrefChange, this, type)
			};
			this._add2PropHeading(locale.text(textRoot), authComponents.newComponent("select", opts, "selectDescr" + type), this.$$xrefroot);
			return selectOpts;
		},
		this.colXrefChange = function(event, prop, type) {
			var idx = parseInt($(event.target).val(), 10);
			var ref = type === "fmt" ? this._xrefDescrFmt : this._xrefDescrPos;
			ref = ref[idx].code;
			if (type == "pos") {
				// hide fmt if pos == none
				this.$$xrefroot.find("#selectDescrfmt").toggle(ref !== "none");
			}
			this.colInfo["$refDesc" + (type === "fmt" ? "Format" : "Position")] = ref;
		};
	// COL IMAGE
	this.colImageAdd = function() {
		var style = this.colInfo.$type !== "image" ? "display:none" : "";
		this.$$imageroot = $('<section class="ximageColumn" style="' + style + '" ></section>').appendTo(this.$$parent);
		// Switch
		var displayIcon = this.colInfo["$imgDisplayIcon"] === true;
		var opts = {
			checked: displayIcon,
			size: "small",
			onSwitchChange: this.onImgDisplayIconChanged.bind(this)
		};
		this._add2PropHeading(locale.text("auth.imgcol.displayIcon"), authComponents.newComponent("switcher", opts), this.$$imageroot);
		// Icon
		opts = {
			palette: fontUtils.getColImageIconList(),
			dropUp: true,
			icon: this.colInfo["$imgIcon"] || fontUtils.getColImageDefIcon(),
			onSelectIcon: this.onImgIconChanged.bind(this)
		};
		this.propImageIcon = this._add2PropHeading(locale.text("auth.imgcol.iconPicker"), authComponents.newComponent("iconPalettePicker", opts), this.$$imageroot);
		this._toggleProp(this.propImageIcon, displayIcon);
	};
	this.onImgIconChanged = function(icon) {
		this.colInfo["$imgIcon"] = icon;
	};
	this.onImgDisplayIconChanged = function(event, status) {
		this.colInfo["$imgDisplayIcon"] = status;
		this._toggleProp(this.propImageIcon, status);
	};
	this.colImgHeightAdd = function() {
		var opts = {
			value: this.colInfo["$imgHeight"] || "medium",
			options: [],
			onChange: jsutils.bindFn(this.imgHeightSelect, this),
		};
		["xsmall", "small", "medium", "large", "xlarge"].forEach(function(s) {
			opts.options.push({
				title: locale.text("auth.imgHeight." + s),
				value: s
			});
		});
		var prop = this._add2PropHeading(locale.text("auth.imgHeight"), authComponents.newComponent("select", opts));
		this._toggleProp(prop, this.colInfo.$type === "image");
	};
	this.imgHeightSelect = function(event, prop, type) {
		this.colInfo["$imgHeight"] = $(event.target).val();
	};
	this._toggleProp = function(prop, show) {
		return prop.$$panel.closest("section.s-m-prop-subtitle").toggle(show);
	};
	this.destroyMarkup = function() {
		this.parent = null;
		this.colInfo = null;
		// Before
		if (this._myProperties) {
			this._myProperties.forEach(function(p) {
				if (p.destroyMarkup) p.destroyMarkup();
			});
			this._myProperties = null;
		}
		// After
		if (this.$$parent) {
			this.$$parent.closest(".s-m-panel-auth-prop").remove();
			this.$$parent = null;
		}
	};
};
/**
 * General properties for 'table' array
 */
var _properties = {
	// Header of the table
	"arrayTableHeader": {
		"key": "$tableHeaderShow",
		"default": true,
		values: [{
			value: true
		}, {
			value: false
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio
	},

	// Design of columns
	// 		Number of columns
	//		Parameters of each column
	"arrayTableDesign": function(controller, sel, data) {
		this.isHidden = false;
		this.name = "arrayTableDesign";
		this.label = null;
		this.key = "$table";
		this.controller = controller;
		this.ctrlArray = data.control;
		this._generalProperties = [];
		this._columnProperties = [];
		this._protoValue = [];

		this.initMarkup = function(controller, sel, data) {
			//reduce protoValue to columns not hidden by X3
			this._protoValue = this.ctrlArray.getColumnsInfo(true);
			this.isSingleArray = this.ctrlArray.isSingleArray() || this._protoValue.length <= 1;
			this._orginalValue = data.articleSelection.$table;
			var hasValue = this._orginalValue != null && this._orginalValue.length > 0;
			if (!hasValue) {
				this._orginalValue = null;
			}
			this._initProps(hasValue ? this._orginalValue : this._protoValue);
			if (!this.isSingleArray) {
				this.addPropNbColumns();
			} else {
				this.isHidden = this._protoValue.length === 0 || this._protoValue[0].$type !== "application/x-reference";
			}
			if (!this.isHidden) {
				this.addPropActionButtons(sel, data);
			}
		};

		this._initProps = function(props, createEntry) {
			var self = this;
			self._columnProperties = [];
			props.forEach(function(prop) {
				self._createColumnProperty(prop, createEntry);
			});
		};

		this.addPropNbColumns = function() {
			var opts = {
				slideHandler: function(val) {
					return val + " columns";
				},
				stopHandler: jsutils.bindFn(this.updateColumns, this),
				value: this._columnProperties.length,
				min: 1,
				max: this._protoValue.length,
				displayValue: "above"
			};
			this._generalProperties.push(authComponents.newComponent("genericSlider", opts, "nbcolumns"));
		};

		this._updateNbCols = function() {
			var prop;
			this._generalProperties.some(function(p) {
				if (p.name === "nbcolumns") {
					prop = p;
					return true;
				}
			});
			prop.update({
				value: this._columnProperties.length
			});
		};

		this.addPropActionButtons = function(sel, data) {
			var btns = [{
				value: "save",
				title: locale.text("auth.tableDesign.save")
			}];
			this._generalProperties.push(authComponents.newComponent("actionBtns", {
				btns: btns,
				onClick: jsutils.bindFn(this.onClickAction, this, sel, data)
			}));
		};

		this.onClickAction = function(evt, sel, data) {
			var action = $(evt.target).val();
			if (action === "save") {
				var value = [],
					entry;
				var self = this,
					conf;
				this._columnProperties.forEach(function(prop) {
					if (!prop.colInfo) return;
					entry = {};
					_tableConfigKeys.forEach(function(p) {
						if (p !== "$titleOrig" || utils.isExpression(prop.colInfo[p])) {
							conf = prop.colInfo[p];
							if (conf != null) {
								entry[p] = $.isPlainObject(conf) ? $.extend(true, {}, conf) : conf;
							}
						}
					});
					value.push(entry);
				});
				//console.log(JSON.stringify(value, null, 2));
				authPropsGeneral.setValue(this, sel, data, value);
				authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
				return;
			}
			// restore/all - Not used - Wait for the global undo button implementation to remove them
			if (action === "restore") {
				if (this._orginalValue) {
					this._clearColumns();
					this._initProps($.extend(true, [], this._orginalValue), true);
					this._updateNbCols();
					return;
				}
				action = "all";
			}
			if (action === "all") {
				this.updateColumns(null);
				this._updateNbCols();
				return;
			}
		};

		this.createMarkup = function($$parent, prop, sel, data) {
			this.$$parent = $$parent;
			this._accordionId = utils.UUID();
			this.$$myAccordion = $('<div id="' + this._accordionId + '" ></div>');
			$$parent.append(this.$$myAccordion);
			var self = this,
				$$entry;
			self._generalProperties.forEach(function(prop) {
				$$entry = $(authArrayGeneral.getHtml('subtitle', {
					title: prop.label ? prop.label || prop.name : null,
				}));
				// create sub-property
				prop.createMarkup($$entry.find("div"));
				self.$$myAccordion.append($$entry);
			});
			self._columnProperties.forEach(function(prop) {
				self._createColEntry(prop);
			});
		};

		this._createColEntry = function(prop) {
			var id = utils.UUID();
			var $$parent;
			if (!this.isSingleArray) {
				var $$propGroup = $(authArrayGeneral.getHtml("subPropTitle", {
					id: id,
					type: "child columns",
					label: prop.label,
					info: prop.colInfo ? prop.colInfo.$bind : null,
					expanded: false,
					parentId: this._accordionId
				}));
				$$parent = $$propGroup.find("#collapse_" + id);
				this.$$myAccordion.append($$propGroup);
			} else {
				this.$$myAccordion.append($$propGroup);
				$$parent = $('<div style="padding-left:10px;padding-right:10px;"></div>').appendTo(this.$$myAccordion);
			}
			// create sub-property
			prop.createMarkup($$parent);
		};

		this.destroyMarkup = function() {
			this.$$parent = null;
			this.ctrlArray = null;
			this.controller = null;
			this._getAllProps().forEach(function(p) {
				p.destroyMarkup();
			});
			this._generalProperties = null;
			this._columnProperties = null;
		};

		this._getAllProps = function() {
			return (this._generalProperties || []).concat(this._columnProperties || []);
		};

		this.updateColumns = function(nbCols) {
			if (this.$$myAccordion) {
				this.$$myAccordion.find(".collapse").collapse('hide');
			}
			var init = nbCols == null;
			nbCols = init ? this._protoValue.length : nbCols;
			var startFrom = 0;
			if (init) {
				this._clearColumns();
			} else if (this._columnProperties.length > 0) {
				for (var i = this._columnProperties.length - 1; i >= nbCols; i--) {
					this._columnProperties[i].destroyMarkup();
					this._columnProperties.splice(i, 1);
				}
				startFrom = this._columnProperties.length;
			};
			for (var i = startFrom; i < nbCols; i++) {
				this._createColumnProperty(this._protoValue[i], true);
			}
		};

		this._createColumnProperty = function(config, createEntry) {
			var proto = this.getFieldProto(config.$bind, true);
			if (!proto) return null;
			// Update properties from prototype
			config.$title = this.controller.dataset.prototype.resolveExpression(proto.value.$title) || config.$bind;
			config.$type = proto.value.$type;
			config.$titleOrig = proto.value.$titleOrig;
			var prop = new _TableColumnPanel(this, config);
			this._columnProperties.push(prop);
			if (createEntry) {
				this._createColEntry(prop);
			}
			return prop;
		};

		this._clearColumns = function() {
			if (this._columnProperties) {
				this._columnProperties.forEach(function(p) {
					p.destroyMarkup();
				});
			}
			this._columnProperties = [];
		};

		this.getProtoValByIdx = function(idx) {
			if (idx < 0 || idx >= this._protoValue.length) throw new Error("unexpected bad index[" + idx + "]");
			return this._protoValue[idx];

		};

		this.getFieldProto = function(bind, noFail) {
			var res = null;
			this._protoValue.some(function(v, idx) {
				if (v.$bind === bind) {
					res = {
						idx: idx,
						value: v
					};
					return true;
				}
			});
			if (res == null && noFail !== true) throw new Error("unexpected null value - bind=[" + bind + "]");
			return res;
		};
	}
};
exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	if (!data.control.isSingleArray()) {
		props.push(_properties.arrayTableHeader);
	}
	props.push(_properties.arrayTableDesign);
};
});

define('syracuse-tablet/html/js/authoring/arrays/authArrayCard',['require','exports','module','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

var _properties = {

	// only card
	"arrayCardsPerRow": {
		"key": "$cardsPerRow",
		"default": "2",
		values: [{
			value: "1"
		}, {
			value: "2"
		}, {
			value: "3"
		}, {
			value: "4"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio
	},

	/*
	 * Color of tile and layout cell
	 */
	"arrayBgColor": {
		"key": "$arrayBgColor",
		"default": "",
		"colorChange": function(value, sel, data, prop) {
			authPropsGeneral.setValue(this, sel, data, (value ? value.id : ""));
			authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
		},
		"createMarkup": function($$parent, prop, sel, data) {
			var opts = {
				color: "",
				palette: authPropsGeneral.getColorPalette(),
				dropUp: false,
				onSelectColor: jsutils.bindFn(this.colorChange, this, sel, data, prop)
			};
			this.paletteColor = authComponents.newComponent("colorPalettePicker", opts);
			this.paletteColor.createMarkup($$parent);
			this.paletteColor.setValue(authPropsGeneral.getColorInfo(data.control.article.$arrayBgColor));
		}
	},
	// only card
	"arrayCardsMinWidth": function(controller, sel, data) {
		this.name = "arrayCardsMinWidth";
		this.label = null;
		this.key = "$minWidth";
		this["default"] = 1;
		this.min = 0;
		this.max = 20;
		this.step = 1;

		this.createMarkup = function($$parent, prop, sel, data) {
			this.ctrl = data.control;
			this.$$parent = $$parent;
			this.originValue = authPropsGeneral.getValueOrDefault(this, sel, data);
			var opts = {
				id: "auth_opt_" + this.name,
				value: this.originValue,
				min: this.min,
				max: this.max,
				step: this.step || 1,
				slideHandler: jsutils.bindFn(this.onSlide, this, "slide"),
				startHandler: jsutils.bindFn(this.onSlide, this, "start"),
				stopHandler: jsutils.bindFn(this.onSlide, this, "stop", sel, data)
			};
			this._slider = authComponents.newComponent("genericSlider", opts);
			this._slider.createMarkup($$parent);
		};

		this.onSlide = function(value, prop, action, sel, data) {
			var res = this.ctrl.authOnSlideMinSize(value, action);
			if (action === "slide") return res;
			if (action === "stop" && this.originValue != value) {
				authPropsGeneral.setValue(this, sel, data, value);
				authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
			}
		};

		this.destroyMarkup = function() {
			this.ctrl = null;
			this.$$parent = null;
			if (this.$$slider) {
				this.$$slider.slider('destroy');
				this.$$slider = null;
			}
		};

		this._sliderSetValue = function(slideEvt, $$parent, sel, data, originValue) {
			this.ctrl.authOnSlideMinSize(slideEvt, "stop");
			if (originValue != slideEvt.value) {
				authPropsGeneral.setValue(this, sel, data, slideEvt.value);
				authPropsGeneral.notifyChangePropUI($$parent, sel, data);
			}
		};


	},

	// only card
	"arrayCardsEmptyCells": {
		"key": "$emptycell",
		"default": "nodisplay",
		values: [{
			value: "filled"
		}, {
			value: "withtitle"
		}, {
			value: "nodisplay"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio
	}
};

exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	if (!data.control.isSingleArray()) {
		props.push(_properties.arrayCardsPerRow, _properties.arrayCardsMinWidth, _properties.arrayCardsEmptyCells, _properties.arrayBgColor);
	}
};
});

define('syracuse-tablet/html/js/authoring/arrays/authArrayStatus',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/arrays/authArrayGeneral','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/fieldOperators','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authArrayGeneral = require('syracuse-tablet/html/js/authoring/arrays/authArrayGeneral');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _noValue = "$$novalue$$";

var _properties = {

	"arrayStatusEnabled": function(controller, sel, data) {
		this.key = "$statusEnabled";
		this.name = "arrayStatusEnabled";
		this["default"] = "none";
		this.values = [{
			"value": "none",
		}, {
			"value": "mono"
		}];
		if (data.control.$display === "card") {
			this.values.push({
				"value": "multi"
			});
		}
		this.createMarkup = authPropsGeneral.createMarkupRadio;
		this.refreshMarkup = authPropsGeneral.refreshMarkupRadio;
	},

	"arrayStatus": function(controller, sel, data) {
		this.name = "arrayStatus";
		this.label = null;
		this["default"] = null;
		this.key = "$status";
		this.ctrlArray = data.control;
		this.isTable = (this.ctrlArray.article.$display || "table") === "table";
		this._myProperties = [];
		/** 
		 	data structure data.articleSelection.$status
		 		[{
					field: "BPCNUM",
					$type: "application/x-string",
					operator: "eq",
					value: 10,
					color:{
						name: "red",
						css: "s-m-color-ok",
						bgcolor: "#FF0000",
						color: "#FFFFFF"
					}
				}]
		*/
		this.initMarkup = function(controller, sel, data) {
			this._protoValue = this.ctrlArray.getColumnsInfo();
			var authStatus = data.articleSelection[this.key] || [];
			this.statusList = [];
			var self = this,
				proto;
			authStatus.forEach(function(c) {
				proto = self.getFieldProto(c.field);
				if (proto != null) {
					c = $.extend(true, {}, c);
					c.id = utils.UUID();
					self.statusList.push(c);
				}
			});
		};
		this.getFieldProto = function(bind) {
			var res = null;
			this._protoValue.some(function(v, idx) {
				if (v.$bind === bind) {
					res = v;
					return true;
				}
			});
			return res;
		};
		this.getRecordInfo = function(id) {
			if (!id) return null;
			var idx = -1;
			var rec = null;
			this.statusList.some(function(c, i) {
				if (c.id === id) {
					rec = c;
					idx = i;
					return true;
				}
			});
			return idx === -1 ? null : {
				record: rec,
				idx: idx
			};
		};
		this.destroyMarkup = function() {
			this.ctrl = null;
			this.$$parent = null;
			this._protoValue = null;
			this.ctrlArray = null;
			if (this._myProperties) {
				this._myProperties.forEach(function(p) {
					if (p.destroyMarkup) p.destroyMarkup();
				});
				this._myProperties = null;
			}
		};

		this.createMarkup = function($$parent, prop, sel, data) {
			this.ctrl = data.control;
			this.$$parent = $$parent;
			this.statusListAdd(sel, data);
			this.editSectionAdd();
		};
		this.statusListAdd = function(sel, data) {
			var opts = {
				css: "statuslist",
				doAction: jsutils.bindFn(this.listCallBackAction, this, sel, data),
				appendTitle: locale.text("auth.arrayStatus.append")
			};
			this.listStatusDisplayer = authComponents.newComponent("editableList", opts);
			this._addParam("statuslist", this.listStatusDisplayer, true);
			this.updateStatusList();
		};
		this.editSectionAdd = function() {
			this.editStatusSection = this._addSubSection("editstatus");
			this.editStatusSection.$$panel.hide();
			this.editStatusSection.$$content.css("padding-left", "7px");
			this.editStatusSection.$$title.css("font-weight", "bold");
			var $$rootComponents = this.editStatusSection.$$content;
			this.paramFieldAdd($$rootComponents);
			this.paramOperatorAdd($$rootComponents);
			this.paramValueAdd($$rootComponents);
			this.paramColorAdd($$rootComponents);
			this.paramIconAdd($$rootComponents);
		};
		this.listCallBackAction = function(action, recordId, listStatusDisplayer, sel, data) {
			if (action === "append") {
				this._updateParams(null);
				return true;
			}
			if (action === "cancel") {
				this._resetParams();
				this.editStatusSection.$$panel.hide();
				return true;
			}
			var recInfo = this.getRecordInfo(recordId);
			if (action === "validate") {
				var newRecord = this.validateRecord(true);
				if (newRecord) {
					if (recInfo == null) {
						// Validate Append
						this.statusList.push(newRecord);
					} else {
						// Validate Edit
						this.statusList.splice(recInfo.idx, 1);
						this.statusList.splice(recInfo.idx, 0, newRecord);
					}
					this.updateStatusList(true, sel, data);
					// Clears params
					this._resetParams();
					// Removes validate/cancel - Switchs to e'Append status'
					return true;
				} else {
					return false;
				}
			}
			if (action === "deleteItem") {
				if (!recInfo) return false;
				this.statusList.splice(recInfo.idx, 1);
				this.updateStatusList(true, sel, data);
				return true;
			}
			if (action === "editItem") {
				if (!recInfo) return false;
				this._updateParams(recInfo.record);
				return true;
			}
		};
		this.validateRecord = function(errorMsg) {
			var self = this;
			var _fail = function(msg) {
				if (errorMsg === true) {
					var text = msg || locale.text("auth.arrayStatus.invalid");
					self.listStatusDisplayer.toggleMessage(text, "error");
					setTimeout(function() {
						self.listStatusDisplayer.toggleMessage(null);
					}, 2500);
				}
				return null;
			};
			var rec = {};
			rec.field = this.fieldSelector.getValue();
			rec.operator = this.operatorSelector.getValue();
			var proto = this.getFieldProto(rec.field);
			if (!proto) {
				return _fail();
			}
			rec.$type = proto.$type;
			rec.$format = proto.$format;
			if (rec.$type === "application/x-boolean") {
				rec.value = this.componentBoolVal.getValue();
			} else {
				rec.value = this.$$valueElmt.val() || "";
			}
			var formatter = formatApi.getFormatter(rec.$type, proto.$format);
			if (formatter) {
				var errors = [];
				rec.value = formatter.parseValue(rec.value, errors);
				if (errors.length > 0) {
					return _fail(errors.join(''));
				}
				if (rec.value != null && rec.value != this.$$valueElmt.val()) {
					this.$$valueElmt.val(formatter.formatValueEdit(rec.value));
				}
			}
			if (rec.$type == "application/x-reference") {
				rec.value = (rec.value || "").toUpperCase();
			}
			if (this.paletteColor) {
				rec.color = this.paletteColor.getValue();
			}
			if (this.paletteIcon) {
				rec.icon = this.paletteIcon.getValue();
			}
			rec.id = utils.UUID();
			if (rec.field == _noValue || rec.operator == _noValue || rec.color == null) {
				return _fail();
			}
			return rec;
		};
		this._updateParams = function(record) {
			var edit = record != null;
			record = record || {};
			this.editStatusSection.$$panel.show();
			this.fieldSelector.setValue(record.field || _noValue);
			this.updateOperators(record.$type, record.operator || _noValue);
			if (this.paletteColor) {
				this.paletteColor.setValue(record.color);
			}
			if (this.paletteIcon) {
				this.paletteIcon.setValue(record.icon);
			}
			var val = record.value;
			if (val != null) {
				var formatter = formatApi.getFormatter(record.$type, record.$format);
				val = formatter ? formatter.formatValueEdit(val) : val;
			}
			// We create a section for booleans
			var isBool = record.$type === "application/x-boolean";
			this.$$valSection.toggle(!isBool);
			this.$$boolValSection.toggle(isBool);
			this.componentBoolVal.setValue(isBool && val === true);
			this.$$valueElmt.val(isBool || val == null ? "" : val);
		};
		this._resetParams = function() {
			this.editStatusSection.$$panel.hide();
			this.fieldSelector.setValue(_noValue);
			this.operatorSelector.clear();
			this.paletteColor.setValue("");
			this.$$valueElmt.val("");
		};
		this.updateStatusList = function(updateAuthoring, sel, data) {
			var clearBefore = true;
			if (clearBefore) {
				this.listStatusDisplayer.clear();
			}
			var records = [],
				style, css;
			this.statusList.forEach(function(c) {
				if (c.icon) {
					css = c.icon.css;
					style = "color:" + c.color.bgColor + ";font-size:1.4em;";
				} else {
					css = c.color ? c.color.css : "";
					style = "";
				}
				records.push({
					titleHtml: authArrayGeneral.getHtml("statusLine", {
						field: c.field,
						operator: c.operator,
						value: c.value,
						css: css,
						style: style,
						sizeColor: 15
					}),
					id: c.id
				});
			});
			this.listStatusDisplayer.insertRecords(records);
			if (updateAuthoring == true) {
				var value = [];
				this.statusList.forEach(function(c) {
					c = $.extend(true, {}, c);
					delete c.id;
					value.push(c);
				});
				authPropsGeneral.setValue(this, sel, data, value);
				authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
				return;
			}
		};
		this.paramFieldAdd = function($$root) {
			var selectOpts = [{
				"title": locale.text('auth.arrayStatus.novalue'),
				"value": _noValue
			}];
			this._protoValue.forEach(function(v, idx) {
				if (fieldOperators.acceptOperator(v.$type)) {
					selectOpts.push({
						title: v.$title,
						value: v.$bind
					});
				}
			});
			var opts = {
				value: _noValue,
				options: selectOpts,
				css: "statusField",
				onChange: jsutils.bindFn(this.onParamFieldSelect, this),
				isHidden: false
			};
			this.fieldSelector = authComponents.newComponent("select", opts);
			this._addParam("field", this.fieldSelector, true, $$root, true);
		};

		this.paramOperatorAdd = function($$root) {
			var opts = {
				value: _noValue,
				options: [{
					"title": locale.text('auth.arrayStatus.novalue'),
					"value": _noValue
				}],
				css: "statusOperator",
				onChange: jsutils.bindFn(this.onParamOperatorSelect, this),
				isHidden: false
			};
			this.operatorSelector = authComponents.newComponent("select", opts);
			this._addParam("operator", this.operatorSelector, true, $$root, true);
			this.updateOperators();
		};
		this.paramValueAdd = function($$root) {
			this.$$valueElmt = $('<input class="form-control statusValue"></input>');
			var opts = {
				size: "small",
				onText: "True",
				offText: "False",

			};
			this.$$valSection = this._addParam("value", this.$$valueElmt, true, $$root).hide();
			this.componentBoolVal = authComponents.newComponent("switcher", opts);
			this.$$boolValSection = this._addParam("value", this.componentBoolVal, true, $$root).hide();
		};
		this.paramColorAdd = function($$root) {
			var opts = {
				palette: authPropsGeneral.getColorPalette(),
				dropUp: true
			};
			this.paletteColor = authComponents.newComponent("colorPalettePicker", opts);
			this._addParam("color", this.paletteColor, true, $$root, true);
		};
		this.paramIconAdd = function($$root) {
			var opts = {
				palette: fontUtils.getArrayStatusIconList(),
				dropUp: true
			};
			this.paletteIcon = authComponents.newComponent("iconPalettePicker", opts);
			this._addParam("icon", this.paletteIcon, true, $$root, false);
		};
		this.onParamFieldSelect = function(event, prop) {
			var field = this.getFieldProto($(event.target).val());
			this.updateOperators(field.$type, "eq");
			this.$$valSection.toggle(!this.$$boolValSection.toggle(field.$type === "application/x-boolean").is(":visible"));
		};
		this.updateOperators = function(typeField, defValue) {
			defValue = defValue == null ? _noValue : defValue;
			var selectOpts = [{
				"title": locale.text('auth.arrayStatus.novalue'),
				"value": _noValue
			}];
			var ops = fieldOperators.getOperators(typeField, true);
			if (ops) {
				ops.forEach(function(v, idx) {
					selectOpts.push({
						title: v.title,
						value: v.value
					});
				});
			}
			this.operatorSelector.update(selectOpts, defValue);
		};
		this.onParamOperatorSelect = function(event, prop) {};
		this._addParam = function(prop, component, title, $$parent, mandatory) {
			var $$parent = $$parent || this.$$parent;
			var $$title;
			var $$root;
			if (title) {
				var res = this._addSubSection(prop, $$parent, mandatory);
				$$root = res.$$content;
				$$title = res.$$panel;
			} else {
				$$root = $$parent;
			}
			if (component == null) throw new Error("unexpected null component");
			var $$panel;
			if (component.createMarkup) {
				component.createMarkup($$root);
				this._myProperties.push(component);
				$$panel = component.$$panel;
			} else if (component.jquery) {
				$$root.append(component);
				$$panel = component;
			}
			return $$title ? $$title : $$panel;
		};
		this._addSubSection = function(textId, $$parent, mandatory) {
			var $$panel = $(authArrayGeneral.getHtml('subtitle', {
				title: locale.text('auth.arrayStatus.' + textId) + (mandatory === true ? "*" : ""),
				margin: 10,
				id: "arrayStatus" + textId.smCapitalize()
			})).appendTo($$parent || this.$$parent);
			return {
				$$panel: $$panel,
				$$content: $$panel.children("div"),
				$$title: $$panel.children("p")
			};
		};
	}
};

exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	if (!controller.dataset.prototype.isLookup()) {
		props.push(_properties.arrayStatusEnabled);
		var status = data.control.getAuthoring("$statusEnabled");
		if (status === "mono" || status === "multi") {
			props.push(_properties.arrayStatus);
		}
	}
};
});

define('syracuse-tablet/html/js/authoring/arrays/authArrayCarousel',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral'],function (require, exports, module) {
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');


var _properties = {

	"arrayCarouselPeriod": {
		"key": "$carouselPeriod",
		"default": "none",
		values: [{
			value: "none"
		}, {
			value: "slow"
		}, {
			value: "normal"
		}, {
			value: "fast"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio
	}
};

exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	props.push(_properties.arrayCarouselPeriod);
};
});

define('syracuse-tablet/html/js/authoring/arrays/authoringPropertiesChart',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {

var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var _err = authPropsGeneral.err;
var _noValue = "$$novalue$$";
var _templates = {
	subtitle: '\
		<section {{#if id}}id="{{id}}"{{/if}} style="{{#if notHidden}}overflow:hidden;{{/if}}white-space:nowrap;text-overflow:ellipsis;{{#if margin}}margin-bottom:{{margin}}px;{{/if}}">\
			{{#if title}}<p>{{title}}</p>{{/if}}\
			<div></div>\
		</section>',
	serieTitle: ' \
		<div class="panel panel-primary s-m-panel-auth-prop s-m-auth-prop-type-{{type}}"> \
			<div style="overflow:hidden;" class="panel-heading" role="tab" id="heading_{{id}}"> \
				<a id="serie_{{id}}" style="width:100%;display:table;" data-toggle="collapse" data-parent="#{{#if parentId}}{{parentId}}{{/if}}{{#unless parentId}}accordion{{/unless}}" href="#collapse_{{id}}" {{#if expanded}} aria-expanded="true"{{/if}} aria-controls="collapse_{{id}}" {{#unless expanded}}class="collapsed"{{/unless}}>\
					<div style="display:table-row;white-space: nowrap;">\
						<h4 class="panel-title" style="display:table-cell;"> \
							{{label}}\
						</h4> \
					</div>\
				</a> \
			</div> \
			<div id="collapse_{{id}}" class="panel-collapse collapse {{#if expanded}}in{{/if}}" role="seriepanel" aria-labelledby="heading_{{id}}"> \
			</div> \
		</div>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};
var _SeriePanel = function(parent, serieInfo) {
	this.name = serieInfo.name;
	this.label = serieInfo.$title;
	this.parent = parent;
	this.bind = serieInfo.$bind;
	this.color = serieInfo.color;
	this.isHidden = serieInfo.isHidden;
};
var _properties = {
	"chartHeight": {
		"key": "$chartHeight",
		"default": "medium",
		"values": [{
			"value": "xsmall"
		}, {
			"value": "small"
		}, {
			"value": "medium"
		}, {
			"value": "large"
		}, {
			"value": "xlarge"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio
	},
	/*
	 *	$Chart type (pie, line bar)
	 */
	"chartStyle": function(controller, sel, data) {
		this.name = "chartStyle";
		this.key = "$style";
		this["default"] = "line";
		this._chartGetMeasureCountVisible = function() {
			var count = data.control.prototype.chartGetNbMeasures();
			if (data.articleSelection.$seriesOptions) {
				Object.keys(data.articleSelection.$seriesOptions).forEach(function(key) {
					if (data.articleSelection.$seriesOptions[key].isHidden) {
						count--;
					}
				});
			};
			return count;
		};
		this.values = [{
			value: "line"
		}, {
			value: "bar"
		}, {
			value: "column"
		}];
		if (this._chartGetMeasureCountVisible() === 1) {
			this.values.push({
				value: "pie"
			});
		};
		this.createMarkup = authPropsGeneral.createMarkupRadio;
	},
	"chartOptions": function(controller, sel, data) {
		var values = [{
			"key": "isTitleHidden",
			"default": false
		}];
		var valuesPie = [{
			"key": "isLabelsHidden",
			"default": false
		}];
		var valueslineBarColumn = [{
			"key": "isLegendHidden",
			"default": false
		}, {
			"key": "isGridLineHidden",
			"default": false
		}, {
			"key": "isXLabelHidden",
			"default": false
		}, {
			"key": "isXLabelsHidden",
			"default": false
		}, {
			"key": "isYLabelHidden",
			"default": false
		}, {
			"key": "isYLabelsHidden",
			"default": false
		}];
		this.name = "chartOptions";
		this.key = "$chartOptions";
		this.values = values.concat((data.articleSelection.$style === "pie") ? valuesPie : valueslineBarColumn);
		this.createMarkup = authPropsGeneral.createMarkupCheckboxes;
	},
	/*Not implemented for moment*/
	"chartInverted": {
		"key": "$inverted",
		"default": false,
		"values": [{
			"value": false
		}, {
			"value": true
		}],
		createMarkup: authPropsGeneral.createMarkupRadio
	},
	"seriesOptions": function(controller, sel, data) {
		this.name = "seriesOptions";
		this.key = "$seriesOptions";
		this._serieProperties = [];

		this.initMarkup = function(controller, sel, data) {
			this._protoValue = data.control.prototype.chartGetMeasureInfo();
			this._orginalValue = data.articleSelection[this.key];
			var hasValue = this._orginalValue != null;
			this._initProps(hasValue ? this._mergeValue() : this._protoValue);
		};
		this.createMarkup = function($$parent, prop, sel, data) {
			this.$$parent = $$parent;
			this._accordionId = utils.UUID();
			this.$$myAccordion = $('<div id="' + this._accordionId + '" ></div>');
			$$parent.append(this.$$myAccordion);
			var self = this;
			self._serieProperties.forEach(function(prop) {
				self._createSerieEntry(prop, sel, data);
			});
		};
		this.destroyMarkup = function() {
			if (this._serieProperties) {
				this._serieProperties.forEach(function(prop) {
					if (prop.destroyMarkup) {
						prop.destroyMarkup();
					}
				});
			}
			this._serieProperties = null;
			if (this.$$parent) {
				this.$$parent.closest(".s-m-panel-auth-prop").remove();
				this.$$parent = null;
			}
			if (this.$$parent) {
				this.$$myAccordion = null;
			}
		};
		this._mergeValue = function() {
			var res = {},
				self = this;
			Object.keys(self._protoValue).forEach(function(key) {
				res[key] = $.extend(true, {}, self._protoValue[key]);
				Object.keys((self._orginalValue && self._orginalValue[key]) || {}).forEach(function(prop) {
					res[key][prop] = self._orginalValue[key][prop];
				});
			});
			return res;
		};
		this._initProps = function(props, createEntry) {
			var self = this;
			self._serieProperties = [];
			Object.keys(props).forEach(function(key) {
				self._createSerieProperty(props[key], createEntry);
			});
		};

		this._createSerieProperty = function(prop, createEntry) {
			var prop = new _SeriePanel(this, prop);
			this._serieProperties.push(prop);
			if (createEntry) {
				this._createSerieEntry(prop);
			}
		};
		this._createSerieEntry = function(prop, sel, data) {
			var id = prop.bind;
			var $$parent;
			var $$propGroup = $(_getHtml("serieTitle", {
				id: id,
				type: "child",
				label: prop.label,
				expanded: false,
				parentId: this._accordionId
			}));
			$$parent = $$propGroup.find("#collapse_" + id);
			this.$$myAccordion.append($$propGroup);
			this.paramHiddenAdd($$parent, sel, data, prop);
			if (data.articleSelection.$style !== "pie") {
				this.paramColorAdd($$parent, sel, data, prop);
			}
		};
		this.paramHiddenAdd = function($$root, sel, data, prop) {
			var opts = {
				size: "small",
				onText: "True",
				offText: "False",
				onSwitchChange: this.onSwitchChange.bind(this, sel, data, prop)

			};
			this.componentBoolVal = authComponents.newComponent("switcher", opts);
			this._addParam(prop, "isHidden", this.componentBoolVal, true, $$root, false);
			var value = this._getPropValue(prop.bind, 'isHidden') || false;
			this.componentBoolVal.setValue(!value);
		};
		this.onSwitchChange = function(sel, data, prop, event, value) {
			var seriesOptions = $.extend(true, {}, data.articleSelection[this.key]);
			seriesOptions[prop.bind] = seriesOptions[prop.bind] || {};
			seriesOptions[prop.bind].isHidden = !value;
			authPropsGeneral.setValue(this, sel, data, seriesOptions);
			authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
		};
		this.paramColorAdd = function($$root, sel, data, prop) {
			var opts = {
				color: "",
				palette: authPropsGeneral.getColorPalette(),
				dropUp: true,
				onSelectColor: jsutils.bindFn(this.colorChange, this, sel, data, prop)
			};
			this.paletteColor = authComponents.newComponent("colorPalettePicker", opts);
			var param = this._addParam(prop, "color", this.paletteColor, true, $$root, false);
			if (this._getPropValue(prop.bind, 'isHidden')) {
				param.hide();
			}
			this.paletteColor.setValue(this._getPropValue(prop.bind, 'color'));
		};
		this._getPropValue = function(bind, property) {
			var res = null;
			this._serieProperties.forEach(function(prop) {
				if (prop.bind === bind) {
					res = prop[property];
				}
			});
			return res;
		};
		this.colorChange = function(value, sel, data, prop) {
			var seriesOptions = $.extend(true, {}, data.articleSelection[this.key]);
			seriesOptions[prop.bind] = seriesOptions[prop.bind] || {};
			seriesOptions[prop.bind].color = value;
			authPropsGeneral.setValue(this, sel, data, seriesOptions);
			authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
		};
		this._addParam = function(prop, textId, component, title, $$parent, mandatory) {
			var $$parent = $$parent || this.$$parent;
			var $$title;
			var $$root;
			if (title) {
				var res = this._addSubSection(prop, textId, $$parent, mandatory);
				$$root = res.$$content;
				$$title = res.$$panel;
			} else {
				$$root = $$parent;
			}
			if (component == null) throw new Error("unexpected null component");
			var $$panel;
			if (component.createMarkup) {
				component.createMarkup($$root);
				this._serieProperties.push(component);
				$$panel = component.$$panel;
			} else if (component.jquery) {
				$$root.append(component);
				$$panel = component;
			}
			return $$title ? $$title : $$panel;
		};
		this._addSubSection = function(prop, textId, $$parent, mandatory) {
			var $$panel = $(_getHtml('subtitle', {
				title: locale.text('auth.seriesOptions.' + textId) + (mandatory === true ? "*" : ""),
				margin: 10,
				id: "seriesColor" + prop.bind.smCapitalize()
			})).appendTo($$parent || this.$$parent);
			return {
				$$panel: $$panel,
				$$content: $$panel.children("div"),
				$$title: $$panel.children("p")
			};
		};
	},
	"axisLabels": function(controller, sel, data) {
		this.name = "axisLabels";
		this.key = "$axisLabels";
		//Authoring is yet stored by level but to keep existing authoring, we keep the key "this.labels" but always 1
		this.labels = 1;
		this.selectOpts = _getSelectOptions(data.control);
		if (this.selectOpts.length <= 1) return null;
		this.createMarkup = function($$parent, prop, sel, data) {
			var opts = {
				value: _noValue,
				options: [{
					"title": "",
					"value": _noValue
				}].concat(this.selectOpts),
				onChange: this.onChange.bind(this, $$parent, data)
			};
			this.fieldLabelList = authComponents.newComponent("select", opts, "selectLabel");
			this.fieldLabelList.createMarkup($$parent);
			if (data.articleSelection && data.articleSelection[this.key] && data.articleSelection[this.key][this.labels]) {
				this.fieldLabelList.setValue(data.articleSelection[this.key][this.labels]);
			};
		};
		this.onChange = function($$parent, data, event, componentSelect) {
			var axisOptions = $.extend(true, {}, data.articleSelection[this.key]);
			if (componentSelect.getValue() === _noValue && axisOptions[this.labels]) {
				delete(axisOptions[this.labels]);
			} else {
				axisOptions[this.labels] = componentSelect.getValue();
			}
			authPropsGeneral.setValue(this, sel, data, axisOptions);
			authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
		};
	}
};

var _getSelectOptions = function(control) {
	var selectOpts = [];
	var measures = control.prototype.chartGetMeasureInfo();
	var dataset = control.builderContent.getChartDataSet();
	var $properties = control.prototype.getProperties(function(prop, $bind) {
		if (dataset && dataset.length > 0) {
			//Must be in dataset but not a measure
			return (dataset[0][$bind] !== undefined && measures[$bind] === undefined);
		} else {
			return false;
		}
	});
	Object.keys($properties).forEach(function(v) {
		if (!$properties[v].$title) {
			var ids = v.split("_");
			if (ids.lenght >= 2 && ids[0] === "C") {
				$properties[v].$title = ($properties[v.substr(2)] ? $properties[v.substr(2)].$title : "") + " (" + v + ")";
			}
		}
		if ($properties[v].$title) {
			selectOpts.push({
				'title': $properties[v].$title,
				'value': v
			});
		}
	});
	return selectOpts;
};
exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};
exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	if (data.control.chartNeedsHeight && data.control.chartNeedsHeight()) {
		props.push(_properties.chartHeight);
	}
	props.push(_properties.chartStyle, _properties.chartOptions, _properties.seriesOptions, _properties.axisLabels);
};
});

define('syracuse-tablet/html/js/authoring/arrays/authoringPropertiesArrays',['require','exports','module','syracuse-tablet/html/js/authoring/arrays/authArrayGeneral','syracuse-tablet/html/js/authoring/arrays/authArrayTable','syracuse-tablet/html/js/authoring/arrays/authArrayCard','syracuse-tablet/html/js/authoring/arrays/authArrayStatus','syracuse-tablet/html/js/authoring/arrays/authArrayCarousel','syracuse-tablet/html/js/authoring/arrays/authoringPropertiesChart'],function (require, exports, module) {
var authArrayGeneral = require('syracuse-tablet/html/js/authoring/arrays/authArrayGeneral');
var authArrayTable = require('syracuse-tablet/html/js/authoring/arrays/authArrayTable');
var authArrayCard = require('syracuse-tablet/html/js/authoring/arrays/authArrayCard');
var authArrayStatus = require('syracuse-tablet/html/js/authoring/arrays/authArrayStatus');
var authArrayCarousel = require('syracuse-tablet/html/js/authoring/arrays/authArrayCarousel');
var authoringPropertiesChart = require('syracuse-tablet/html/js/authoring/arrays/authoringPropertiesChart');

exports.initModuleProperties = function(dest) {
	authArrayGeneral.initModuleProperties(dest);
	authArrayCard.initModuleProperties(dest);
	authArrayTable.initModuleProperties(dest);
	authArrayStatus.initModuleProperties(dest);
	authArrayCarousel.initModuleProperties(dest);
	authoringPropertiesChart.initModuleProperties(dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	if (sel.$$elmt.is(".s-m-control.s-m-chart")) {
		// Type display and pagination only
		authArrayGeneral.getModuleProperties($$elmt, controller, props, sel, data);
		// Properties for charts authoring
		authoringPropertiesChart.getModuleProperties($$elmt, controller, props, sel, data);
	} else {
		// Commons settings
		authArrayGeneral.getModuleProperties($$elmt, controller, props, sel, data);
		// Design cards/Columns
		if (data.control.isSingleArray()) {
			// Nothing
		} else {
			if (data.control.$display === "card") {
				if (data.control.displayAsCarousel) {
					authArrayCarousel.getModuleProperties($$elmt, controller, props, sel, data);
				} else {
					authArrayCard.getModuleProperties($$elmt, controller, props, sel, data);
				}
			} else if (data.control.$display === "table") {
				authArrayTable.getModuleProperties($$elmt, controller, props, sel, data);
			}
			// Status management on cards and tables
			authArrayStatus.getModuleProperties($$elmt, controller, props, sel, data);
		}
	}
};
});

define('syracuse-tablet/html/js/authoring/authoringPropertiesGauge',['require','exports','module','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral'],function (require, exports, module) {

var locale = require('syracuse-tablet/html/js/helpers/locale');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');

var _err = authPropsGeneral.err;
var maxSegments = 5;

var _properties = {
	/*
	 *	Display numeric data either as normal number field or as gauge
	 */
	"numDisplay": {
		"key": "$numDisplay",
		"default": "normal",
		values: [{
			value: "normal"
		}, {
			value: "gauge"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Sets gauge range (min/max) values origin. Either "default", "bind", or "value"
	 *	- default : gauge component default range values
	 *	- bind : use one field value as range value
	 *	- value : user specified directly range values in input field
	 */
	"gSetBorderValues": {
		"key": "$gSetBorderValues",
		"default": "default",
		values: [{
			value: "default"
		}, {
			value: "value"
		}, {
			value: "bind"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio,
		type: "child"
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Set border values (min/max). It will be either a textarea or a selector
	 */
	"gBorderValues": {
		"default": "",
		createMarkup: _createMarkupGBorderValues,
		type: "child"
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Number of gauge segmets
	 */
	"gSegmentsNumber": {
		"default": "",
		createMarkup: _createMarkupGSegmentsNumbers,
		type: "child"
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Configure gauge segments
	 */
	"gSegmentsConfig": {
		"default": "",
		createMarkup: _createMarkupGSegmentsConfig,
		type: "child",
		destroyMarkup: _destroySlider
	},
	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Apply button for segments configuration
	 */
	"gSegmentsConfigApply": {
		applyMarkup: _createMarkupApply
	}
};



function _createMarkupGBorderValues($$parent, prop, sel, data) {
	var ctx = {};
	ctx.label_apply = locale.text("auth.g.label_apply");
	var idMin = "s-m-auth-g-borders-min";
	var idMax = "s-m-auth-g-borders-max";

	// markup depends if border is value or bind
	var isProperty = data.articleSelection.$gSetBorderValues === "bind" ? true : false;

	// if property, build a selection markup, filled with numeric types within the prototype
	if (isProperty) {
		var valMin = data.articleSelection.$gauge.$bindMin;
		var valMax = data.articleSelection.$gauge.$bindMax;

		ctx.label_tip = locale.text("auth.gBorderValues.label_tip.property");
		ctx.label_min = locale.text("auth.gBorderValues.label_min.property");
		ctx.label_max = locale.text("auth.gBorderValues.label_max.property");

		// get number properties from prototype
		var optionsMin = [];
		var optionsMax = [];
		optionsMin.push({
			option_value: "0",
			selected: valMin === "0"
		});

		var proto = data.control.controller.dataset.prototype;
		if (proto && proto.json && proto.json.$properties) {
			$.each(proto.json.$properties, function(bind, value) {
				if (_isGaugeValuePropertyType(value.$type) && bind !== data.control.$bind && bind !== data.articleSelection.$bind) {
					optionsMin.push({
						option_value: bind,
						selected: valMin === bind
					});
					optionsMax.push({
						option_value: bind,
						selected: valMax === bind
					});
				}
			});

			ctx.markupMin = authHtml.execute("gaugeSelect", {
				id: idMin,
				options: optionsMin
			});

			ctx.markupMax = authHtml.execute("gaugeSelect", {
				id: idMax,
				options: optionsMax
			});
		} else {
			_err(locale.text("auth.gBorderValues.err.prototype.title"), locale.text("auth.gBorderValues.err.prototype.msg"));
			return;
		}

	}

	// if input, build input markup
	else {
		var valMin, valMax;
		// set valMin considering that user switched from "property" to "input"
		if (data.articleSelection.$gauge.$bindMin && typeof data.articleSelection.$gauge.$bindMin == "string") {
			valMin = data.control.controller.dataset.getValue(data.articleSelection.$gauge.$bindMin);
		} else {
			valMin = data.articleSelection.$gauge.$bindMin;
		}

		// set valMax considering that user switched from "property" to "input"
		if (data.articleSelection.$gauge.$bindMax && typeof data.articleSelection.$gauge.$bindMax == "string") {
			valMax = data.control.controller.dataset.getValue(data.articleSelection.$gauge.$bindMax);
		} else {
			valMax = data.articleSelection.$gauge.$bindMax;
		}

		ctx.label_tip = locale.text("auth.gBorderValues.label_tip.input");
		ctx.label_min = locale.text("auth.gBorderValues.label_min.input");
		ctx.label_max = locale.text("auth.gBorderValues.label_max.input");
		ctx.markupMin = authHtml.execute("gaugeBorderInput", {
			id: idMin,
			value: valMin
		});
		ctx.markupMax = authHtml.execute("gaugeBorderInput", {
			id: idMax,
			value: valMax
		});
	}

	var html = authHtml.execute("authPanelPropertyGBorderValues", ctx);
	var $$panel = $(html);

	// /!\ In bind, allow use of 0
	// onclick, update data and refresh
	$("button", $$panel).on("click", function(e) {
		var err = false;
		var vvMin = $(e.target).parent().find("#" + idMin).val();
		var vvMax = $(e.target).parent().find("#" + idMax).val();
		var errTitle = locale.text("auth.gBorderValues.err.title");

		// min and max are both numbers
		if (!isNaN(parseInt(vvMin), 10) && !isNaN(parseInt(vvMax), 10)) {

			if (vvMax < vvMin) {
				err = _err(errTitle, locale.text("auth.gBorderValues.err.msg.lowerMax", [vvMax, vvMin]));
			}
		} else {

			// min and max should both be string values
			if (!(typeof vvMin == "string" && typeof vvMax == "string")) {
				err = _err(errTitle, locale.text("auth.gBorderValues.err.msg.bothString", [vvMin, vvMax]));
			}

			if (vvMin === vvMax) {
				err = _err(errTitle, locale.text("auth.gBorderValues.err.msg.samebind"));
			}
		}

		if (!err) {
			data.articleSelection.$gauge.$bindMin = vvMin;
			data.articleSelection.$gauge.$bindMax = vvMax;
			authPropsGeneral.notifyChangePropUI($$parent, sel, data);
		}
	});

	// append html
	$$parent.append($$panel);
}


function _createMarkupGSegmentsNumbers($$parent, prop, sel, data) {
	// build html
	var defaultValueLabel = locale.text("auth.gSegmentsNumber.default");
	var value = data.articleSelection.$gauge.segments ? data.articleSelection.$gauge.segments.length : "";
	var options = [];
	for (var ii = 0, jj = (maxSegments + 1); ii < jj; ii++) {
		var opt = {};
		if (ii == 0) {
			opt.option_value = defaultValueLabel;
			opt.selected = value ? true : false;
		} else {
			opt.option_value = ii;
			opt.selected = value == ii;
		}
		options.push(opt);
	}
	var ctx = {
		value: authHtml.execute("gaugeSelect", {
			id: "s-m-auth-g-segnumbers-txt",
			options: options
		}),
		label_apply: locale.text("auth.g.label_apply")

	};

	var html = authHtml.execute("authPanelPropertyGSegmentsNumber", ctx);
	var $$panel = $(html);


	// bind click on apply button
	// onclick, update data and refresh
	$("button", $$panel).on("click", function(e) {

		var vv = $(e.target).prev().val();

		if (value != vv) {
			if (vv && vv !== defaultValueLabel) {
				data.articleSelection.$gauge.segments = data.articleSelection.$gauge.segments || [];
				if (data.articleSelection.$gauge.segments.length > vv) {
					data.articleSelection.$gauge.segments.splice(vv);
				}
				for (var ii = 0, jj = vv; ii < jj; ii++) {
					data.articleSelection.$gauge.segments[ii] = data.articleSelection.$gauge.segments[ii] || {};
				}
			} else {
				data.articleSelection.$gauge.segments = null;
			}
			authPropsGeneral.notifyChangePropUI($$parent, sel, data);
		}
	});

	// append html
	$$parent.append($$panel);
}

function _createMarkupGSegmentsConfig($$parent, prop, sel, data) {

	// build html

	var seg = data.articleSelection.$gauge.segments[prop.segIdx];
	var idRoot = "s-m-auth-seg-";
	var idx = prop.segIdx;

	var segInfo = {};
	segInfo.id = idRoot + idx;

	segInfo.label_valstart = locale.text("auth.gSegmentsConfig.label_valstart");
	segInfo.value_valstart = seg.valStart;

	segInfo.label_valend = locale.text("auth.gSegmentsConfig.label_valend");
	segInfo.value_valend = seg.valEnd;

	segInfo.label_propstart = locale.text("auth.gSegmentsConfig.label_propstart");
	segInfo.value_propstart = authHtml.execute("authPanelGaugeSlider", {
		id: segInfo.id + "-propstart",
		min: 0,
		max: 1,
		step: 0.1,
		value: seg.propStart
	});

	segInfo.label_propend = locale.text("auth.gSegmentsConfig.label_propend");
	segInfo.value_propend = authHtml.execute("authPanelGaugeSlider", {
		id: segInfo.id + "-propend",
		min: 0,
		max: 1,
		step: 0.1,
		value: seg.propEnd
	});

	segInfo.label_color = locale.text("auth.gSegmentsConfig.label_color");
	segInfo.value_color = seg.color;
	segInfo.label_apply = locale.text("auth.g.label_apply");

	var html = authHtml.execute("gaugeSegment", segInfo);
	var $$panel = $(html);

	/*
	 *	Bind events
	 */
	// generate slider
	var $$rangeInputArr = $("input.s-m-auth-g-range", $$panel);
	$$rangeInputArr.slider();
	// update range output value
	$$rangeInputArr.on("slide", function(slideEvt) {
		var $$input = $(slideEvt.target);
		var $$output = $$input.next();
		$$output.text(slideEvt.value);
	});

	$$parent.append($$panel);
}

function _createMarkupApply($$parent, prop, sel, data) {
	var html = authHtml.execute("authPanelButton", {
		label: locale.text("auth.gSegmentsConfigApply.label"),
		css: "s-m-auth-g-apply"
	});
	var $$panel = $(html);

	/* bind click on button. apply segments configuration */
	$("button", $$panel).on("click", function(e) {
		var segs = [];
		var $$segments = $(e.target).parent().parent().find(".s-m-auth-seg-slot");
		for (var ii = 0, jj = $$segments.length; ii < jj; ii++) {
			var $$seg = $($$segments[ii]);
			var id = $$seg.attr("id");
			var segInfo = {};
			segInfo.valStart = $("#" + id + "-valstart", $$seg).val();
			segInfo.valEnd = $("#" + id + "-valend", $$seg).val();
			segInfo.propStart = $("#" + id + "-propstart", $$seg).val();
			segInfo.propEnd = $("#" + id + "-propend", $$seg).val();
			segInfo.color = $("#" + id + "-color", $$seg).val();

			// if valStart, valEnd, propStart, propEnd, color value == "", set it to null 
			// this is necessary to comply with the gauge ctrl behavior
			segInfo.valStart = segInfo.valStart === "" ? null : segInfo.valStart;
			segInfo.valEnd = segInfo.valEnd === "" ? null : segInfo.valEnd;
			segInfo.propStart = segInfo.propStart === "" ? null : segInfo.propStart;
			segInfo.propEnd = segInfo.propEnd === "" ? null : segInfo.propEnd;
			segInfo.color = segInfo.color === "" ? null : segInfo.color;

			// check if valStart and valEnd are numeric values
			var vStart = segInfo.valStart;
			var vEnd = segInfo.valEnd;
			if (vStart && isNaN(parseInt(vStart.replace(".", "").replace(",", ""), 10))) {
				_err(locale.text("auth.gSegmentsConfig.err.title"), locale.text("auth.gSegmentsConfig.err.msg.expectedNumber", [locale.text("auth.gSegmentsConfig.label_valstart"), vStart]));
				return;
			}
			if (vEnd && isNaN(parseInt(vEnd.replace(".", "").replace(",", ""), 10))) {
				_err(locale.text("auth.gSegmentsConfig.err.title"), locale.text("auth.gSegmentsConfig.err.msg.expectedNumber", [locale.text("auth.gSegmentsConfig.label_valend"), vEnd]));
				return;
			}
			segs.push(segInfo);
		}
		data.articleSelection.$gauge.segments = segs;
		authPropsGeneral.notifyChangePropUI($$parent, sel, data);
	});

	$$parent.append($$panel);
}

function _destroySlider($$parent, prop) {
	var $$slider = $$parent.find('input.s-m-auth-g-range');
	if ($$slider.length > 0 && $$slider.slider) {
		$$slider.slider('destroy');
	}
}



function _getModuleProperties($$elmt, controller, props, sel, data) {

	if (_isGaugeValuePropertyType(data.type)) {

		var isGauge;

		if (data.articleSelection.$numDisplay) {
			isGauge = data.articleSelection.$numDisplay === "gauge";
		} else {
			// set $numDisplay article value if not set
			isGauge = data.articleSelection.$gauge ? true : false;
			data.articleSelection.$numDisplay = isGauge ? "gauge" : "normal";
		}

		props.push(_properties.numDisplay);

		// push gauge authoring properties according to article values
		if (isGauge) {

			if (!data.articleSelection.$gSetBorderValues) {
				// set the value of "gSetBorderValues" property
				if (data.articleSelection.$gauge.$bindMax) {
					data.articleSelection.$gSetBorderValues = typeof data.articleSelection.$gauge.$bindMax == "string" ? "bind" : "value";
				} else {
					data.articleSelection.$gSetBorderValues = "default";
				}
			}

			// add "gSetBorderValues" property
			props.push(_properties.gSetBorderValues);

			// if "gSetBorderValues" is not "default"
			// add "gBorderValues" properties
			if (data.articleSelection.$gSetBorderValues !== "default") {
				props.push(_properties.gBorderValues);
			}

			// add "gSegmentsNumber" property
			props.push(_properties.gSegmentsNumber);

			// add segments if necessary
			if (data.articleSelection.$gauge.segments && data.articleSelection.$gauge.segments.length > 0) {
				for (var ii = 0, jj = data.articleSelection.$gauge.segments.length; ii < jj; ii++) {
					var name = "gSegmentsConfig" + ii;
					_properties[name] = {
						"default": "",
						createMarkup: _createMarkupGSegmentsConfig,
						type: "child-child",
						destroyMarkup: _destroySlider,
						label: locale.text("auth.gSegmentsConfig", [(ii + 1)]),
						segIdx: ii,
						name: name
					};
					props.push(_properties[name]);
				}
				props.push(_properties.gSegmentsConfigApply);
			}
		}
	}
}

function _isGaugeValuePropertyType(type) {
	if (type.indexOf("integer") >= 0 || type.indexOf("real") >= 0 || type.indexOf("decimal") >= 0 || type.indexOf("quantity") >= 0) {
		return true;
	}
	return false;
}
exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};
exports.getModuleProperties = _getModuleProperties;
});

define('syracuse-tablet/html/js/authoring/authoringPropertiesCtrls',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/arrays/authoringPropertiesArrays','syracuse-tablet/html/js/authoring/authoringPropertiesGauge','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var authUtils = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authoringPropertiesArrays = require('syracuse-tablet/html/js/authoring/arrays/authoringPropertiesArrays');
var authoringPropertiesGauge = require('syracuse-tablet/html/js/authoring/authoringPropertiesGauge');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _modules = [authoringPropertiesArrays, authoringPropertiesGauge];

var _canBeEmpty = function(typ) {
	switch (typ) {
		case "integer":
		case "real":
		case "decimal":
		case "quantity":
		case "boolean":
			return false;
		default:
			return true;
	}
};
var _ctrlFieldsProperties = {
	"checkBoxDisplayAs": {
		"key": "$displayAs",
		"default": "icon",
		"values": [{
			"value": "icon"
		}, {
			"value": "text"
		}],
		createMarkup: authUtils.createMarkupRadio
	},
	/*
	 * Title hidden
	 */
	"isTitleHidden": {
		"key": "$isTitleHidden",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: authUtils.createMarkupRadio,
		type: "default" // Default, just for header color selection
	},
	/*
	 * Hide if empty value
	 */
	"hideIfEmpty": {
		"key": "$hideIfEmpty",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: authUtils.createMarkupRadio
	},
	/*
	 * Is signature
	 */
	"isSignature": {
		"key": "$isSignature",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: authUtils.createMarkupRadio
	},
	/*
	 * scale
	 */
	"imgScale": {
		"key": "$imgScale",
		"default": "original",
		"values": [{
			"value": "original"
		}, {
			"value": "small"
		}, {
			"value": "medium"
		}, {
			"value": "large"
		}],
		createMarkup: authUtils.createMarkupRadio
	},
	/*
	 * Is GPS
	 */
	"scanGPS": {
		"key": "$scanGPS",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: authUtils.createMarkupRadio
	},

	/*
	 * Barcode scanning
	 */
	"scanBarcode": {
		"key": "$scanBarcode",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: authUtils.createMarkupRadio
	},

	/* 
	 * Position of label
	 * left:   <label> <value>
	 *
	 * top:    <label>
	 * 		   <value>
	 */
	"labelPosition": {
		"key": "$labelPosition",
		"default": "left",
		"values": [{
			"value": "left"
		}, {
			"value": "top"
		}],
		createMarkup: authUtils.createMarkupRadio
	},

	/* 
	 * Text alignment of label and values
	 * Wee keep $labelAlign for compatibility
	 */
	"labelAlign": {
		"key": "$labelAlign",
		"default": "left",
		"values": [{
			"value": "left"
		}, {
			"value": "center"
		}, {
			"value": "right"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	},

	/* 
	 * Theme for control
	 */
	"theme": {
		"key": "$theme",
		"default": "none",
		"values": [{
			"value": "none"
		}, {
			"value": "largetitle"
		}],
		createMarkup: authUtils.createMarkupRadio,
		toggleTheme: function($$elmt, theme) {
			this.removeTheme($$elmt, theme);
			this.addTheme($$elmt, theme);
		},
		removeTheme: function($$elmt, theme) {
			var e = $$elmt.get(0);
			if (!e.className || e.className.indexOf("s-m-theme") === -1) return;
			var newClassName = [];
			e.className.split(" ").forEach(function(c) {
				if (c && !c.smStartsWith("s-m-theme")) {
					newClassName.push(c);
				}
			});
			if (e.className.length === 0) return;
			e.className = newClassName.join(' ');
		},
		addTheme: function($$elmt, theme) {
			if (!theme || theme === "none") return;
			$$elmt.addClass("s-m-theme-" + theme);
		}
	},

	/*
	 * Reference field description position
	 * bottom: <value>
	 *         <desc>
	 *
	 * right:  <value> <desc>
	 * left:   <desc> <value>
	 *
	 * top:    <desc>
	 *         <value>
	 */
	"refDescPosition": {
		"key": "$refDescPosition",
		"default": "right",
		"values": [{
			"value": "bottom"
		}, {
			"value": "right"
		}, {
			"value": "left"
		}, {
			"value": "top"
		}, {
			"value": "none"
		}],
		createMarkup: authUtils.createMarkupRadio
	},

	/*
	 * Reference field description format
	 * desc:      <desc>
	 *         
	 * title:     <title>

	 * desctitle: <desc> - <title>
	 * -> If both values are equal, skip display of second value
	 * 
	 * titledesc: <title> - <desc>
	 * -> If both values are equal, skip display of second value
	 */
	"refDescFormat": {
		"key": "$refDescFormat",
		"default": "desc",
		"values": [{
			"value": "desc"
		}, {
			"value": "title"
		}, {
			"value": "desctitle"
		}, {
			"value": "titledesc"
		}],
		createMarkup: authUtils.createMarkupRadio
	},
	// only CLOB field (text plain, text html, text rtf)
	"textHeight": {
		"key": "$textHeight",
		"default": "medium",
		values: [{
			value: "small"
		}, {
			value: "medium"
		}, {
			value: "large"
		}, {
			value: "xlarge"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	},
	"emptyImageIcon": {
		"key": "$emptyImageIcon",
		"default": fontUtils.getEmptyImageDefIcon(),
		"values": fontUtils.getEmptyImageIconList(),
		createMarkup: authUtils.createMarkupIconPicker,
		destroyMarkup: authUtils.destroyMarkupIconPicker
	},
	"emptyIconSize": {
		"key": "$emptyIconSize",
		"default": "small",
		values: [{
			value: "small"
		}, {
			value: "medium"
		}, {
			value: "large"
		}, {
			value: "xlarge"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	},
	"urlIcon": {
		"key": "$urlIcon",
		"default": fontUtils.getUrlDefIcon(),
		"values": fontUtils.getUrlIconList(),
		createMarkup: authUtils.createMarkupIconPicker,
		destroyMarkup: authUtils.destroyMarkupIconPicker
	},
	"urlIconSize": {
		"key": "$urlIconSize",
		"default": "small",
		values: [{
			value: "small"
		}, {
			value: "medium"
		}, {
			value: "large"
		}, {
			value: "xlarge"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	},
	"imgHeight": {
		"key": "$imgHeight",
		"default": "small",
		values: [{
			value: "xsmall"
		}, {
			value: "small"
		}, {
			value: "medium"
		}, {
			value: "large"
		}, {
			value: "xlarge"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	}
};

exports.initModuleProperties = function(dest) {
	// Init fields properties
	authUtils.initProperties(_ctrlFieldsProperties, dest);
	// Init other type of fields properties
	_modules.forEach(function(module) {
		module.initModuleProperties(dest);
	});
};
exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	var isField = sel.$$elmt.is(".s-m-control.s-m-field");
	var isArray = sel.$$elmt.is(".s-m-control.s-m-array");
	if (isField || (isArray && !controller.dataset.root.prototype.isQueryLikeFacet())) {
		props.push(_ctrlFieldsProperties.isTitleHidden);
		var labelPosition = true,
			alignment = true;
		if (authUtils.getValueOrDefault(_ctrlFieldsProperties.isTitleHidden, sel, data)) {
			labelPosition = false;
		} else if (authUtils.getValueOrDefault(_ctrlFieldsProperties.labelPosition, sel, data) !== "top") {
			alignment = false;
		}
		if (labelPosition) {
			props.push(_ctrlFieldsProperties.labelPosition);
		}
		if (alignment) {
			props.push(_ctrlFieldsProperties.labelAlign);
		}
	} else if (sel.$$elmt.is(".s-m-control.s-m-chart-array")) {
		// To deal with title
		props.push(_ctrlFieldsProperties.isTitleHidden);
	}
	// ctrlFieldBase
	if (isField) {
		if (_canBeEmpty(data.type)) {
			props.push(_ctrlFieldsProperties.hideIfEmpty);
		}
		props.push(_ctrlFieldsProperties.theme);
		if (data.type === "boolean") {
			props.push(_ctrlFieldsProperties.checkBoxDisplayAs);
		}
		// Properties for reference fields only 
		if (data.type === "reference") {
			props.push(_ctrlFieldsProperties.refDescFormat);
			props.push(_ctrlFieldsProperties.refDescPosition);
		}
		// Properties for enriched text fields only (html, plain, rtf)
		if (data.type === "rtf" || data.type === "html" || data.type === "plain") {
			props.push(_ctrlFieldsProperties.textHeight);
		}
		if (data.type === "image") {
			props.push(_ctrlFieldsProperties.emptyImageIcon, _ctrlFieldsProperties.emptyIconSize, _ctrlFieldsProperties.imgHeight);
			if (controller.isEditMode()) {
				props.push(_ctrlFieldsProperties.imgScale, _ctrlFieldsProperties.isSignature);
			}
		}
		if (data.type === "string" && data.control && data.control.cssType === "s-m-url") {
			props.push(_ctrlFieldsProperties.urlIcon, _ctrlFieldsProperties.urlIconSize);
		}
		if (controller.isEditMode()) {
			if (data.control.getNativeCapabilityAuthoring("GPS") != null) {
				props.push(_ctrlFieldsProperties.scanGPS);
			}
			if (data.control.getNativeCapabilityAuthoring("scanBarcode") != null) {
				props.push(_ctrlFieldsProperties.scanBarcode);
			}
		}
		// Properties for numeric field
		authoringPropertiesGauge.getModuleProperties($$elmt, controller, props, sel, data);
	} else if (isArray) {
		if (data.control.$display === "separator") {
			props.push(_ctrlFieldsProperties.theme);
		}
		// ctrlFieldArray
		authoringPropertiesArrays.getModuleProperties($$elmt, controller, props, sel, data);
	}
};

exports.toggleTheme = function($$elmt, theme) {
	if (!$$elmt) return;
	return _ctrlFieldsProperties.theme.toggleTheme($$elmt, theme);
};
});

define('syracuse-tablet/html/js/authoring/authoringPropertiesLayouts',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var modules = require('syracuse-tablet/html/js/common/modules');

var _properties = {
	/*
	 * Color of tile and layout cell
	 */
	"tileColor": {
		"key": "$bgColor",
		"default": "",
		//For compatibility with previous version - used by modalConfigTiles
		"values": authPropsGeneral.getColorValues(),
		"colorChange": function(value, sel, data, prop) {
			authPropsGeneral.setValue(this, sel, data, (value ? value.id : ""));
			authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
		},
		"createMarkup": function($$parent, prop, sel, data) {
			var opts = {
				color: "",
				palette: authPropsGeneral.getColorPalette(),
				dropUp: false,
				onSelectColor: jsutils.bindFn(this.colorChange, this, sel, data, prop)
			};
			this.paletteColor = authComponents.newComponent("colorPalettePicker", opts);
			this.paletteColor.createMarkup($$parent);
			this.paletteColor.setValue(authPropsGeneral.getColorInfo(data.articleSelection.$bgColor));
		}
	},
	/*
	 * Size of tile
	 */
	"tileSize": {
		"key": "$size",
		"default": "medium",
		"values": [{
			"value": "small"
		}, {
			"value": "medium"
		}, {
			"value": "wide"
		}, {
			"value": "large"
		}, {
			"value": "full"
		}, {
			"value": "all"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio
	},

	/*
	 * Title of layout node
	 */
	"layoutTitle": function(controller, sel, data) {
		this.name = "layoutTitle";
		this.key = "$title";
		var titleList = _getAllX3Title(controller.dataset.prototype);
		if (!titleList || !titleList.length) {
			this["default"] = "";
			this.createMarkup = _createMarkupInputLocale;
			return;
		};
		this.values = titleList;
		this.createMarkup = function($$parent, prop, sel, data) {
			var opts = {
				value: "",
				options: titleList,
				onChange: jsutils.bindFn(this.valueChange, this, sel, data, prop),
				dataSize: 20
			};
			this.titleSelect = authComponents.newComponent("select", opts);
			this.titleSelect.createMarkup($$parent);
			if (data.articleSelection && data.articleSelection.$title) {
				this.titleSelect.setValue(data.articleSelection.$title);
			};
		};
		this.valueChange = function(event, titleSelect, sel, data, prop) {
			authPropsGeneral.setValue(this, sel, data, titleSelect.getValue());
			authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
		};
	},

	/*
	 * Title of layout node
	 */
	"layoutCollapsible": {
		"key": "$collapsible",
		"default": "notcollapsible",
		"values": [{
			"value": "notcollapsible"
		}, {
			"value": "expanded"
		}, {
			"value": "collapsed"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio
	},

	/*
	 * Icon of a tile
	 */
	"tileIcon": {
		"key": "$icon",
		"default": "",
		createMarkup: _createMarkupIcon
	},

	/*
	 * Size of tile
	 *
	 * Handles the following elements: $widthXs, $widthSm, $widthMd, $widthLg
	 */
	"cellSize": function(controller, sel, data) {
		this["default"] = 4;
		this["name"] = "cellSize";

		this.destroyMarkup = function() {
			this.$$parent = null;
			if (this._$$panel) {
				this._$$panel.off();
				this._$$panel = null;
			}
		};

		this.createMarkup = function($$parent, prop, sel, data) {
				var self = this;
				self.$$parent = $$parent;
				var values = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
				self._sizes = [{
					"prop": "widthAll",
					"label": locale.text("auth.cellSize.widthAll"),
					"class": "s-m-auth-highlight-all"
				}, {
					"prop": "widthXs",
					"label": locale.text("auth.cellSize.$widthXs"),
					"class": "s-m-auth-highlight-xs"
				}, {
					"prop": "widthSm",
					"label": locale.text("auth.cellSize.$widthSm"),
					"class": "s-m-auth-highlight-sm"
				}, {
					"prop": "widthMd",
					"label": locale.text("auth.cellSize.$widthMd"),
					"class": "s-m-auth-highlight-md"
				}, {
					"prop": "widthLg",
					"label": locale.text("auth.cellSize.$widthLg"),
					"class": "s-m-auth-highlight-lg"
				}];
				self._$$panel = $(authHtml.execute("authPanelPropertyCellSize", {
					id: "auth_opt_" + prop.name,
					sizes: self._sizes,
					values: values,
					sameSize: locale.text("auth.cellSize.sameSize"),
				}));
				var last = "12";
				self._sizes.forEach(function(size) {
					var value = data.articleSelection && data.articleSelection["$" + size.prop];
					value = value || last;
					last = value;
					$("label[data-s-m-auth-prop='" + size.prop + "'][data-s-m-auth-value='" + value + "']", self._$$panel).button("toggle");
				});
				self._$$panel.on("click", "label.auth-btn-size-sel", jsutils.bindFn(self.onClickSize, this, sel, data));
				self._$$panel.on("click", 'input[type="checkbox"]', jsutils.bindFn(self.onClickSameSize, this, sel, data));
				self._$$panel.appendTo($$parent);
				self.toggleSameSize($$parent, data.articleSelection["$sameSize"]);
			},
			this.onClickSize = function(e, sel, data) {
				var self = this;
				var $$ct = $(e.currentTarget);
				$$ct.eq(0).button("toggle");
				self._sizes.forEach(function(size) {
					$$ct = self._$$panel.find("label.active[data-s-m-auth-prop='" + size.prop + "']");
					if ($$ct.length > 0) {
						var value = $$ct.attr("data-s-m-auth-value");
						data.articleSelection["$" + size.prop] = value;
					}
				});
				authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
			},
			this.onClickSameSize = function(e, sel, data) {
				data.articleSelection["$sameSize"] = $(e.currentTarget).prop("checked");
				authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
			},
			this.toggleSameSize = function($$parent, yes) {
				yes = yes === true;
				this._$$panel.find('section.widthAll').toggle(yes);
				this._$$panel.find('section:not(.widthAll)').toggle(!yes);
				this._$$panel.find('input[type="checkbox"]').prop("checked", yes);
			};
	},
	"layoutTheme": function(controller, sel, data) {
		if (data.articleSelection.$collapsible === undefined || data.articleSelection.$collapsible === "notcollapsible") return null;
		var level = data.control.$$elmt.parents(".s-m-stack").length;
		//if (level < 2) return null;
		this.name = "layoutTheme";
		this.key = "$theme";
		this["default"] = String.fromCharCode(96 + level);
		this.values = [];
		this.values.push({
			"value": String.fromCharCode(96 + level)
		});
		this.values.push({
			"value": "advanced"
		});
		this.createMarkup = authPropsGeneral.createMarkupRadio;
	}
};


/*
 * Which layout node supports which properties to edit in authoring
 */
var _layoutProps = {
	"stack": [_properties.tileColor, _properties.layoutTitle, _properties.layoutCollapsible, _properties.layoutTheme],
	"row": [_properties.tileColor],
	"hub-group": [_properties.layoutTitle],
	"tile": [_properties.layoutTitle, _properties.tileColor, _properties.tileSize, , _properties.tileIcon],
	"cell": [_properties.tileColor, _properties.cellSize]
};

function _createMarkupInput($$parent, prop, sel, data) {
	var value = authPropsGeneral.getValueOrDefault(prop, sel, data);
	var html = authHtml.execute("authPanelPropertyInput", {
		id: "auth_opt_" + prop.name,
		value: value
	});
	var $$panel = $(html);
	$("input", $$panel).blur(function() {
		var value = $(this).val();
		authPropsGeneral.setValue(prop, sel, data, value);
		authPropsGeneral.notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);
}

function _createMarkupInputLocale($$parent, prop, sel, data) {
	var oldUUID = authPropsGeneral.getValueOrDefault(prop, sel, data);
	var value;
	oldUUID = oldUUID || "";
	if (oldUUID.indexOf("{@") < 0) {
		value = oldUUID; // Plain text in article
		oldUUID = "";
	} else {
		var loc = data.articlePage.$localization && data.articlePage.$localization[locale.getCurrentLocale()];
		value = oldUUID.replace(/\{\@(\S+)\}/g, function(m, g) {
			return loc && loc[g] || m;
		});
		if (value === oldUUID) {
			value = data.control.controller.prototype.resolveExpression(oldUUID, null, true);
		};
	}
	var html = authHtml.execute("authPanelPropertyInputLocale", {
		id: "auth_opt_" + prop.name,
		value: value,
		oldValue: value,
		oldUUID: oldUUID
	});
	var $$panel = $(html);
	$("input", $$panel).blur(function() {
		var value = $(this).val();
		var oldValue = $(this).attr("data-old-value");
		var oldUUID = $(this).attr("data-old-uuid");

		// If plain text value did not change and there is an uuid already, we just re assign the uuid
		// otherwise, plain text is set, which will result in recreation of a new uuid later during article generation 
		if (value === oldValue) {
			if (oldUUID.length > 0) {
				value = oldUUID;
			}
			_setValue($$parent, prop, sel, data, value);
		} else {
			if (oldValue && value && utils.isLocalizationExits(data.articlePage.$localization, oldUUID)) {
				modules.get("modal").simpleConfirmPromise({
					message: locale.text("auth.msg.keepTranslation")
				}).then(function(result) {
					if (result.action === "yes") {
						data.articleSelection.keepKey = oldUUID;
					}
					_setValue($$parent, prop, sel, data, value);
				});
			} else {
				_setValue($$parent, prop, sel, data, value);
			}
		}

	});
	$$parent.append($$panel);
}

function _setValue($$parent, prop, sel, data, value) {
	authPropsGeneral.setValue(prop, sel, data, value);
	authPropsGeneral.notifyChangePropUI($$parent, sel, data);
}

function _createMarkupIcon($$parent, prop, sel, data) {

	var ctx = {
		group: "auth_opt_" + prop.name,
		options: []
	};

	var value = authPropsGeneral.getValueOrDefault(prop, sel, data);
	ctx.options.push({
		id: ctx.group + "_none",
		value: "",
		icon: "fa fa-remove"
	});

	fontUtils.getTileIconList().forEach(function(v) {
		var css = fontUtils.getIconByName(v);
		ctx.options.push({
			id: ctx.group + "_" + v,
			value: v,
			icon: css
		});
	});

	var html = authHtml.execute("authPanelPropertyRadioIcon", ctx);
	var $$panel = $(html);
	$("label[data-s-m-auth-value='" + ("" + value) + "']", $$panel).eq(0).button("toggle");
	$("label", $$panel).on("click", function(e) {
		var $$ct = $(e.currentTarget);
		var value = $$ct.attr("data-s-m-auth-value");
		$$ct.eq(0).button("toggle");
		authPropsGeneral.setValue(prop, sel, data, value);
		authPropsGeneral.notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);
}

exports.properties = _properties;

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	Object.keys(_layoutProps).some(function(key) {
		var cls = "s-m-" + key;
		if ($$elmt.hasClass(cls)) {
			_layoutProps[key].forEach(function(p) {
				props.push(p);
			});
		}
	});
};
exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};

function _getAllX3Title(prototype) {
	var title = [],
		localization = prototype.json.$localization || {};
	Object.keys(localization).forEach(function(key) {
		var tit = {};
		tit.value = "{" + key + "}";
		tit.title = localization[key];
		title.push(tit);
	});
	return title.sort(function(a, b) {
		var aTit = a.title.toLowerCase();
		var bTit = b.title.toLowerCase();
		return ((aTit < bTit) ? -1 : ((aTit > bTit) ? 1 : 0));
	});
}
});

define('syracuse-tablet/html/js/authoring/page/authoringActions',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/common/helpers'],function (require, exports, module) {
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var helpers = require('syracuse-tablet/html/js/common/helpers');

var _templates = {
	subtitle: '\
		<section class="s-m-prop-subtitle" {{#if id}}id="{{id}}"{{/if}} style="{{#if notHidden}}overflow:hidden;{{/if}}white-space:nowrap;text-overflow:ellipsis;{{#if margin}}margin-bottom:{{margin}}px;{{/if}}">\
			{{#if title}}<p>{{title}}</p>{{/if}}\
			<div></div>\
		</section>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};

var _addSubSection = function(title, id, $$parent) {
	var $$panel = $(_getHtml('subtitle', {
		title: title,
		margin: 10,
		id: id
	})).appendTo($$parent || this.$$parent);
	return {
		$$panel: $$panel,
		$$content: $$panel.children("div"),
		$$title: $$panel.children("p")
	};
};

var _optionsProperties = ["footerHeader", "refreshPage", "multiselection", "backIfSuccess"];

/**
 * Property that contains actions authoring
 * 		$pageActionSettings
 * 		[{name: actionName, $title:"", icon:"", options: {footerHeader: true/false, refreshPage:true/false, multiselection: true/false}]
 * Sub properties names
 * 		"footerHeader", "refreshPage", "multiselection"
 */

var _noValue = "$$novalue$$";
var _properties = {

	"actionSettings": function(controller, sel, data) {
		this.name = "actionSettings";
		this.label = null;
		this["default"] = null;
		this.key = "$pageActionSettings";
		this._myProperties = [];
		this._page = data.page;
		this.controller = controller;

		this.initMarkup = function(controller, sel, data) {
			if (!this._page) return;
			var $links = _getLinksAndActions(this._page);
			this._$links = [];
			if ($links) {
				for (var l in $links) {
					var entry = $.extend(true, {}, $links[l]);
					entry.name = l;
					entry.$title = this._page.getPrototype().resolveExpression(entry.$title) || entry.name;
					this._$links.push(entry);
				}
			}
			var baseArticle = data.articleSelection || {};
			baseArticle = baseArticle[this.key] || [];
			this._actionList = [];
			var self = this;
			baseArticle.forEach(function(act) {
				// Check if action is still in the proto
				if (self.getActionProto(act.name)) {
					act.$title = self._page.getPrototype().resolveExpression(act.$title) || entry.name;
					act.options = act.options || {};
					self._actionList.push($.extend(true, {}, act));
				}
			});
		};
		this.getActionProto = function(name) {
			var res = null;
			this._$links.some(function(v, idx) {
				if (v.name === name) {
					res = v;
					return true;
				}
			});
			return res;
		};
		this.getActionInfo = function(actName) {
			if (!actName) return null;
			var idx = -1;
			var rec = null;
			this._actionList.some(function(c, i) {
				if (c.name === actName) {
					rec = c;
					idx = i;
					return true;
				}
			});
			return idx === -1 ? null : {
				record: rec,
				idx: idx
			};
		};
		this.destroyMarkup = function() {
			this._page = null;
			this.$$parent = null;
			this.controller = null;
			this._$links = null;
			if (this._myProperties) {
				this._myProperties.forEach(function(p) {
					if (p.destroyMarkup) p.destroyMarkup();
				});
				this._myProperties = null;
			}
		};

		this.createMarkup = function($$parent, prop, sel, data) {
			if (!this._page) return;
			this.$$parent = $$parent;
			if (this._page.getPrototype().isQuery()) {
				this.downloadOptAdd(sel, data);
			}
			this.actionListAdd(sel, data);
			this.editSectionAdd();
			this.checkAppendButton();
		};
		this.downloadOptAdd = function(sel, data) {
			var value = authPropsGeneral.getValueOrDefault({
				"key": "$allowDownload",
				"default": false
			}, sel, data);
			var opts = {
				size: "small",
				onText: "True",
				offText: "False",
				onSwitchChange: this.onAllowDownloadChanged.bind(this, sel, data)
			};
			this.allowDownload = authComponents.newComponent("switcher", opts);
			this.$$allowDownload = this._addParam("allowDownload", this.allowDownload, true);
			this.allowDownload.setValue(value);
		};
		this.onAllowDownloadChanged = function(sel, data, event, value) {
			authPropsGeneral.setValue({
				key: "$allowDownload"
			}, sel, data, value);
			authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
		};

		this.actionListAdd = function(sel, data) {
			var opts = {
				css: "actionlist",
				doAction: jsutils.bindFn(this.listCallBackAction, this, sel, data),
				appendTitle: locale.text("auth.actionSettings.append")
			};
			this.listActionDisplayer = authComponents.newComponent("editableList", opts);
			this._addParam("actionlist", this.listActionDisplayer, true);
			this.updateActionList();
		};
		this.editSectionAdd = function() {
			this.editActionSection = this._addSubSection("editaction");
			this.editActionSection.$$panel.hide();
			this.editActionSection.$$content.css("padding-left", "7px");
			this.editActionSection.$$title.css("font-weight", "bold");
			var $$rootComponents = this.editActionSection.$$content;
			this.paramActionAdd($$rootComponents);
			this.paramOptionsAdd($$rootComponents);
			this.paramIconAdd($$rootComponents);
		};
		// No append if no actions to add
		this.checkAppendButton = function() {
			if (!this.listActionDisplayer) return;
			this.listActionDisplayer.disableAppendBtn(this._actionList.length >= this._$links.length);
		};
		this.listCallBackAction = function(action, recordId, listActionDisplayer, sel, data) {
			if (action === "append") {
				this._updateParams(null);
				return true;
			}
			if (action === "cancel") {
				this._resetEditParams();
				this.editActionSection.$$panel.hide();
				this.checkAppendButton();
				return true;
			}
			var recInfo = this.getActionInfo(recordId);
			if (action === "validate") {
				var newRecord = this.validateRecord(true);
				if (newRecord) {
					if (recInfo == null) {
						// Validate Append
						this._actionList.push(newRecord);
					} else {
						// Validate Edit
						this._actionList.splice(recInfo.idx, 1);
						this._actionList.splice(recInfo.idx, 0, newRecord);
					}
					this.updateActionList(true, sel, data);
					// Clears params
					this._resetEditParams();
					// Removes validate/cancel - Switchs to e'Append status'
					this.checkAppendButton();
					return true;
				} else {
					return false;
				}
			}
			if (action === "deleteItem") {
				if (!recInfo) return false;
				this._actionList.splice(recInfo.idx, 1);
				this.checkAppendButton();
				this.updateActionList(true, sel, data);
				return true;
			}
			if (action === "editItem") {
				if (!recInfo) return false;
				this._updateParams(recInfo.record);
				return true;
			}
		};
		this.validateRecord = function(errorMsg) {
			var self = this;
			var rec = {};
			var _fail = function(msg, params) {
				if (errorMsg === true) {
					var text = locale.text("auth.actionSettings.invalid" + (msg || ""), params);
					self.listActionDisplayer.toggleMessage(text, "error");
					setTimeout(function() {
						self.listActionDisplayer.toggleMessage(null);
					}, 2500);
				}
				return null;
			};
			rec.name = this.actionSelector.getValue();
			if (!rec.name || rec.name == _noValue) {
				return _fail();
			}
			rec.icon = this.paletteIcon.getValue();
			var info = this.getActionProto(rec.name);
			if (!info) return _fail(".action", [rec.name]);
			rec.$title = info.$title;
			rec.options = this.optionsList.getValue();
			var nbChecked = 0;
			for (var p in rec.options) {
				if (rec.options[p] === true) {
					nbChecked++;
				}
			}
			// No check is not allowed
			if (nbChecked === 0 && !rec.icon) {
				return _fail(".empty");
			}
			if (rec.options.footerHeader && !rec.icon) {
				return _fail(".icon");
			}
			return rec;
		};
		this._updateParams = function(record) {
			var edit = record != null;
			record = record || {};
			this.editActionSection.$$panel.show();
			this.paramActionUpdate(record.name || _noValue, true, record.options);
			this.optionsList.updateValue(record.options);
			this.paletteIcon.setValue(record.icon);
		};
		this._resetEditParams = function() {
			this.editActionSection.$$panel.hide();
			this.actionSelector.setValue(_noValue);
		};
		this.updateActionList = function(updateAuthoring, sel, data) {
			var clearBefore = true;
			if (clearBefore) {
				this.listActionDisplayer.clear();
			}
			var records = [];
			this._actionList.forEach(function(c) {
				records.push({
					titleHtml: "<span>" + (c.$title || c.name) + "</span>",
					id: c.name
				});
			});
			this.listActionDisplayer.insertRecords(records);
			if (updateAuthoring == true) {
				var value = [];
				this._actionList.forEach(function(c) {
					c = $.extend(true, {}, c);
					value.push(c);
				});
				authPropsGeneral.setValue(this, sel, data, value);
				authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
				return;
			}
		};
		/**
		 * Edit empty record
		 */
		this.paramActionAdd = function($$root) {
			var opts = {
				css: "actionName",
				onChange: jsutils.bindFn(this.onParamActionSelect, this),
				isHidden: false
			};
			this.actionSelector = authComponents.newComponent("select", opts);
			this._addParam("action", this.actionSelector, true, $$root, true);
			this.paramActionUpdate(_noValue);
		};

		this.onParamActionSelect = function(event, prop) {};
		/**
		 * value: 			value to select
		 * forceAddValue:	true to add value to select
		 * options:			check action to add according to options
		 */
		this.paramActionUpdate = function(value, forceAddValue, options) {
			var selectOpts = [{
				"title": locale.text('auth.actionSettings.novalue'),
				"value": _noValue
			}];
			var self = this;
			this._$links.forEach(function(v, idx) {
				if (options && options.multiselection === true && v.name.smStartsWith("$")) {
					return;
				}
				// Filters actions that are not already in the list
				if ((forceAddValue === true && value === v.name) || !self.getActionInfo(v.name)) {
					selectOpts.push({
						title: v.$title,
						value: v.name
					});
				}
			});
			this.actionSelector.update(selectOpts, value || _noValue);
		};

		this.paramOptionsAdd = function($$root) {
			var opts = {
				list: [],
				onClick: jsutils.bindFn(this.onClickOptions, this)
			};
			var self = this;
			_optionsProperties.forEach(function(x) {
				if (x === "multiselection" && !self._page.getPrototype().isQuery()) return;
				opts.list.push({
					id: x,
					label: locale.text('auth.actionSettings.' + x)
				});
			});
			this.optionsList = authComponents.newComponent("checkboxList", opts);
			this._addParam("options", this.optionsList, true, $$root, false);
		};
		this.onClickOptions = function(id, checked) {
			this.paramActionUpdate(this.actionSelector.getValue(), true, this.optionsList.getValue());
		};
		this.paramIconAdd = function($$root) {
			var opts = {
				palette: fontUtils.getPageActionIcon(),
				dropUp: true
			};
			this.paletteIcon = authComponents.newComponent("iconPalettePicker", opts);
			this._addParam("icon", this.paletteIcon, true, $$root, false);
		};

		this._addParam = function(prop, component, title, $$parent, mandatory) {
			var $$parent = $$parent || this.$$parent;
			var $$title;
			var $$root;
			if (title) {
				var res = this._addSubSection(prop, $$parent, mandatory);
				$$root = res.$$content;
				$$title = res.$$panel;
			} else {
				$$root = $$parent;
			}
			if (component == null) throw new Error("unexpected null component [" + prop + "]");
			var $$panel;
			if (component.createMarkup) {
				component.createMarkup($$root);
				this._myProperties.push(component);
				$$panel = component.$$panel;
			} else if (component.jquery) {
				$$root.append(component);
				$$panel = component;
			}
			return $$title ? $$title : $$panel;
		};

		this._addSubSection = function(textId, $$parent, mandatory) {
			var title = locale.text('auth.actionSettings.' + textId) + (mandatory === true ? "*" : "");
			var id = "actionSettings" + textId.smCapitalize();
			return _addSubSection(title, id, $$parent || this.$$parent);
		};
	}
};

exports.addSubSection = _addSubSection;

exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	props.push(_properties.actionSettings);
};

function _getLinksAndActions(page) {
	var prototype = page.getPrototype()
	var res = {};
	var $links = $.extend(true, {}, page.controller.dataset.getLinks());
	$.each($links, function(name, info) {
		if (name.smStartsWith('$') || helpers.isPaginLink(name)) {
			return;
		}
		info.name = name;
		info.title = info.$title ? prototype.resolveExpression(info.$title) : "";
		info.icon = fontUtils.getIconByName(name);
		if (info.$type == null || info.$type.length !== 0 || info.$type === "application/json;vnd.sage=syracuse") {
			if (info.$url) {
				var urlParsed = prototype.resolveExpression(info.$url);
				if (urlParsed.indexOf("/mobile2/") > -1) { // mobile2 means it's an sdata request
					res[name] = info;
				}
			}
		}
	});

	var $actions = $.extend(true, {}, page.controller.dataset.getActions());
	$.each($actions, function(name, info) {
		if (name.indexOf("$") === 0) {
			return;
		}
		info.name = name;
		info.title = info.$title ? prototype.resolveExpression(info.$title) : "";
		info.icon = fontUtils.getIconByName(name);
		res[name] = info;
	});
	return $.isEmptyObject(res) ? null : res;
}
});

define('syracuse-tablet/html/js/authoring/page/authoringChartDetail',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral'],function (require, exports, module) {

var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');


var _properties = {
	"chartDetailDisplay": {
		"key": "$display",
		"default": "bothSideToSide",
		"values": [{
			"value": "chartOnly"
		}, {
			"value": "arrayOnly"
		}, {
			"value": "bothSideToSide"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio
	}
};
exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};
exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	props.push(_properties.chartDetailDisplay);
};
});

define('syracuse-tablet/html/js/authoring/authoringPropertiesPages',['require','exports','module','syracuse-tablet/html/js/authoring/page/authoringActions','syracuse-tablet/html/js/authoring/page/authoringChartDetail','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var authoringActions = require('syracuse-tablet/html/js/authoring/page/authoringActions');
var authoringChartDetail = require('syracuse-tablet/html/js/authoring/page/authoringChartDetail');
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _properties = {
	"variants": function(controller, sel, data) {
		this.key = "$variant";
		this.views = data.page.pageData.page.$views;
		if (!this.views || this.views.length <= 1) {
			return;
		};
		var titles = [];
		var currentSelection;
		this.views.forEach(function(view, idx) {
			titles.push({
				"title": view.$title,
				"value": view.uuid || view.$url,
				"selected": view.$selected
			});
			if (view.$selected) currentSelection = view.uuid || view.$url;
		});
		this.applyMarkup = function($$parent, prop, sel, data) {
			var subsection = this._addSubSection($$parent);
			var opts = {
				css: "variants-list",
				value: currentSelection,
				options: titles,
				onChange: jsutils.bindFn(this.valueChange, this, sel, data, prop),
				dataSize: 20
			};
			this.viewSelect = authComponents.newComponent("select", opts);
			this.viewSelect.createMarkup(subsection.$$content);
			if (data.articleSelection && data.articleSelection.$variant) {
				this.viewSelect.setValue(data.articleSelection.$variant);
			};
		};

		this._addSubSection = function($$parent) {
			var title = locale.text("auth.page.views");
			var id = "pageViewsList";
			return authoringActions.addSubSection(title, id, $$parent);
		};

		this.valueChange = function(event, viewSelect, sel, data, prop) {
			var uuid = viewSelect.getValue();
			var self = this;
			var variants = data && data.page && data.page.variants;
			if (!variants) return;

			var variantSelected = $.smFind(variants, function(variant) {
				if (uuid.indexOf(variant.$uuid) > -1) {
					return true;
				};
				return false;
			});
			if (variantSelected) {
				this.views.forEach(function(view) {
					view.$selected = false;
					if (view.$url === uuid || view.uuid == uuid) {
						view.$selected = true;
					}
				});
				authPropsGeneral.notifyAuthVariantChange(JSON.parse(variantSelected.pageData.content).$article);
			}
		};
	}
};

var _modules = [authoringActions, authoringChartDetail];

exports.initModuleProperties = function(dest) {
	_modules.forEach(function(module) {
		module.initModuleProperties(dest);
	});
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	var page = data.page ? data.page : data.control && data.control.isVignette() ? data.control.getTopPage() : null;
	if (page == null) return;
	if (data.control == null) {
		props.push(_properties.variants);
	} else {
		data.page = page;
	}
	if (!page.isCardDetail() && !page.isVignette() && !page.isDashboard()) {
		authoringActions.getModuleProperties($$elmt, controller, props, sel, data);
	}
};
});

define('syracuse-tablet/html/js/authoring/authoringProperties',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/authoringPropertiesCtrls','syracuse-tablet/html/js/authoring/authoringPropertiesLayouts','syracuse-tablet/html/js/authoring/authoringPropertiesPages'],function (require, exports, module) {

var authoringPropertiesGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authoringPropertiesCtrls = require('syracuse-tablet/html/js/authoring/authoringPropertiesCtrls');
var authoringPropertiesLayouts = require('syracuse-tablet/html/js/authoring/authoringPropertiesLayouts');
var authoringPropertiesPages = require('syracuse-tablet/html/js/authoring/authoringPropertiesPages');

var _propsModules = [authoringPropertiesPages, authoringPropertiesLayouts, authoringPropertiesCtrls, authoringPropertiesGeneral];

var _properties;

exports.initProperties = function(force) {
	if (_properties != null && force != true) {
		return;
	}
	_properties = {};
	_propsModules.forEach(function(module) {
		module.initModuleProperties(_properties);
	});
};

exports.getAllProperties = function() {
	return _properties;
};

exports.getProperties = function(sel, data) {

	var $$elmt = sel.$$elmt;
	var props = [];

	var controller = data.control && data.control.controller;

	_propsModules.forEach(function(module) {
		module.getModuleProperties($$elmt, controller, props, sel, data);
	});
	props.forEach(function(p, idx) {
		if (typeof p === "function") {
			var prop = props[idx] = new p(controller, sel, data);
			// to simplify the code writing in function object
			if (prop.initMarkup) {
				prop.initMarkup(controller, sel, data);
			}
			authoringPropertiesGeneral.initProperty(prop);
		}
	});
	return props;
};

/* The following getters are used to avoid some cyclic deps in authoring modules
 */
exports.getPropertiesLayouts = function() {
	return authoringPropertiesLayouts;
};
});

define('syracuse-tablet/html/js/authoring/authoringHelpers',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/pages/pageBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/authoring/authoringSData','syracuse-tablet/html/js/authoring/authoringProperties','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/authoring/authoringVal','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/authoring/authoringCommons','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/sdata/cache/metaDataCache'],function (require, exports, module) {

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var pageBase = require('syracuse-tablet/html/js/pages/pageBase');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var authoringSData = require('syracuse-tablet/html/js/authoring/authoringSData');
var authProps = require('syracuse-tablet/html/js/authoring/authoringProperties');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var authVal = require('syracuse-tablet/html/js/authoring/authoringVal');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var authCommons = require('syracuse-tablet/html/js/authoring/authoringCommons');
var modules = require('syracuse-tablet/html/js/common/modules');
var metaDataCache = require('syracuse-tablet/html/js/sdata/cache/metaDataCache');

var _openPanels = [];

exports.triggerResizeInternal = function(opts) {
	uiutils.triggerResizeInternal(opts);
};

exports.selectElement = function(sel) {
	$(".s-m-auth-selected").removeClass("s-m-auth-selected");
	var $$elmt = $("#" + sel.id, $("#s-m-app-id"));
	var domItem = $$elmt[0];
};

/*
 * Find control instance from DOM element
 */
exports.findControl = function($$ctrl) {
	return modules.get("controller").findControlByDom($$ctrl);
};

exports.getSelectionById = function(id) {
	var $$item = $("#s-m-app-id #" + id);
	if ($$item.length <= 0) {
		return null;
	}
	return {
		$$elmt: $$item,
		id: id
	};
};

exports.getSelectionData = function(sel) {
	if (!sel || !sel.id) {
		return null;
	}
	var article = $.extend(true, {}, authCommons.getCurrentPage().getArticle());

	var title;
	var type;
	var page;

	var control = exports.findControl(sel.$$elmt);
	if (control && !control.isLayout()) {
		title = control.prototype && control.prototype.data("$title");
		if (title) {
			title += " (" + control.$bind + ")";
		} else {
			title = control.$bind;
		}
		type = control.typeName;
	} else if (control) {
		title = locale.text("auth.label_layout");
		type = control.typeName;
	} else if (sel.$$elmt.hasClass("s-m-page")) {
		page = pageBase.findPage(sel.id);
	}
	// If no control it means that it's a page authring
	// -> we pass the authoring of the page not cloned like for controls to be able to manage authoring properties for the page
	var articleSelection = (control && control.getArticle()) || authCommons.getCurrentPage().getArticle();
	return {
		articlePage: article,
		articleSelection: articleSelection,
		title: title,
		type: type,
		control: control,
		page: page
	};
};

var _PropertyPanel = function($$parent) {
	this.$$parent = $$parent;
	// For properties that are not objects
	this.destroyHandlers = [];
	this.propInstances = [];
	this.destroy = function() {
		// First
		this.destroyHandlers.forEach(function(h) {
			if (h) h();
		});
		this.propInstances.forEach(function(p) {
			if (p.destroyMarkup) p.destroyMarkup();
		});
		this.destroyHandlers = this.propInstances = null;
		// Second
		if (this.$$parent) {
			this.$$parent.empty();
		}
	};
	this.addDestroyHandler = function($$content, prop) {
		this.destroyHandlers.push(jsutils.bindFn(prop.destroyMarkup, null, $$content, prop));
	};
	this.addPropInstance = function(prop) {
		this.propInstances.push(prop);
	};
};
// sm.auth.articlechange.ui
exports.createPropertyPanel = function($$parent, sel, data) {
	var props = authProps.getProperties(sel, data);
	if (!props) {
		return;
	}
	var propertyPanel = new _PropertyPanel($$parent);
	var $$accord = $('<div class="panel-group" id="accordion" role="tablist" aria-multiselectable="true">');
	var id;
	var num = 0;
	var toDestroy = [];
	var article = sel.articleSelection;
	var topButtons = [];
	props.forEach(function(prop) {
		id = "auth_prop_" + prop.name;
		var expanded = false;
		if (prop.createMarkup) {
			var $$block = $(
				authHtml.execute("authPanelPropertyGroup", {
					id: id,
					expanded: expanded,
					label: prop.label,
					type: prop.type || "default"
				}));
			var $$content = $('#collapse_' + id, $$block);
			prop.createMarkup($$content, prop, sel, data);
			if ($.isPlainObject(prop) && prop.destroyMarkup) {
				propertyPanel.addDestroyHandler($$content, prop);
			} else if (prop.constructor) {
				propertyPanel.addPropInstance(prop);
			}
			if (prop.isHidden === true) {
				$$block.hide();
			}
		} else if (prop.createButtonMarkup) {
			// Add button at the top of property panel
			topButtons.unshift(prop);
		} else {
			if (prop.applyMarkup) {
				prop.applyMarkup($$accord, prop, sel, data);
			} else if (prop.isSeparatror) {
				var $$block = $(
					authHtml.execute("authPanelPropertySeperator", {
						id: id,
						expanded: expanded,
						label: prop.label,
						type: prop.type || "default"
					}));
			}
		}
		$$accord.append($$block);
		num++;
	});
	topButtons.forEach(function(prop) {
		notifications.publish("sm.auth.top.button", "add", prop);
	});
	$$parent.append($$accord);
	// Expand all collapsible saved into _openPanels (all levels - see cahrts authoring)
	_openPanels.forEach(function(id) {
		$$parent.find("#" + id).collapse({
			toggle: true
		});
	});
	return propertyPanel;
};

exports.refreshPropertyPanels = function(sel, data) {
	var props = authProps.getProperties(sel, data);
	if (!props) {
		return;
	}
	props.forEach(function(prop) {
		if (prop.refreshMarkup) {
			var id = "#collapse_auth_prop_" + prop.name;
			var $$panel = $(id);
			prop.refreshMarkup($$panel, prop, sel, data);
		}
	});
};

exports.savePanelStates = function() {
	// Saved all expanded collapsibles (all levels - see cahrts authoring)
	_openPanels = [];
	$(".collapse.in", "#authPanelControlSimple").each(function() {
		_openPanels.push($(this).attr("id"));
	});
};
exports.getPageVariants = function(page) {
	return authoringSData.getPageVariants(page.getAuthoringName());
};
exports.getPageViews = function(page) {
	return authoringSData.getPageViews(page.getAuthoringFullName());
};
exports.saveAuthoring = function(page, opts) {
	var isCreation;
	var _views;
	var _variants;
	var _variant;
	var segs = page.getAuthoringName().split(".");

	return $.smResolve()
		.then(function() {
			var pageData = {
				application: segs[0],
				contract: segs[1],
				representation: segs[2],
				facet: segs[3],

				roles: [],
				users: [],
				endpoints: [],

				saveAsOption: opts.variantType,

				variantCode: opts.code,
				variantTitle: opts.title,
				variantDescription: opts.description,

				article: opts.article,
				variant: opts.uuid
			};
			if (pageData.saveAsOption === "personal_copy") {
				pageData.users.push({
					$uuid: authCommons.getCurrentUserUuid()
				});
			};
			return authoringSData.savePageDefinition(pageData);
		})
		.then(function(variant) {
			_variant = variant;
			return exports.getPageVariants(page);
		})
		.then(function(variants) {
			_variants = variants;
			return exports.getPageViews(page);
		})
		.then(function(views) {
			_views = views;
			return _updatePageMetaData(page, _variant, _variants, _views, opts.article);
		});
};
exports.getPropertiesVariants = function(page) {
	var propertiesVariants = [],
		properties = {},
		viewSelected, isPersonal, self = this;
	var views = page.pageData.page.$views || [];
	if (!views || !views.length || !page.variants || page.variants.length === 0) {
		return propertiesVariants;
	}
	viewSelected = $.smFind(views, function(view) {
		return view.$selected;
	});
	page.variants.forEach(function(variant) {
		isPersonal = (!variant.$factory &&
			(!variant.roles || !variant.roles.length) &&
			(!variant.endpoints || !variant.endpoints.length) &&
			(variant.users && variant.users.length === 1));
		properties = {
			description: variant.description,
			isFactory: variant.$factory,
			isPersonal: isPersonal,
			isGlobal: (!variant.$factory && !isPersonal),
			title: variant.title,
			code: variant.code,
			comment: variant.comment,
			factoryOwner: variant.$factoryOwner,
			uuid: variant.$uuid,
			isSelected: viewSelected != null && viewSelected.$url && viewSelected.$url.indexOf(variant.$uuid) > -1
		};
		propertiesVariants.push(properties);
	});
	return propertiesVariants;
};

exports.getPropertiesCurrentVariant = function(page) {
	var properties = {};
	var views = page.pageData.page.$views || [];
	if (!views || !views.length || !page.variants || !page.variants.length) {
		return properties;
	}
	var viewSelected = $.smFind(views, function(view) {
		return view.$selected;
	});
	if (!viewSelected) {
		return properties;
	}
	var variantSelected = $.smFind(page.variants, function(variant) {
		if (viewSelected.$url.indexOf(variant.$uuid) > -1) {
			return true;
		};
		return false;
	});
	if (!variantSelected) return properties;
	var isPersonal = (!viewSelected.$isFactory && !variantSelected.roles.length && !variantSelected.endpoints.length && variantSelected.users.length === 1);
	/* Be carefull : shared are not managed !!!
	 * shared is when !viewSelected.isFactory && (viewSelected.roles.length!=0 || viewSelected.roles.length!=0 || viewSelected.endpoints.users.length> 1
	 */
	properties = {
		description: viewSelected.$description,
		isFactory: viewSelected.$isFactory,
		isPersonal: isPersonal,
		isGlobal: (!viewSelected.$isFactory && !isPersonal),
		title: viewSelected.$title,
		url: viewSelected.$url,
		code: variantSelected.code,
		comment: variantSelected.comment,
		factoryOwner: variantSelected.$factoryOwner,
		uuid: variantSelected.$uuid
	};
	return properties;
};

exports.rebuildArticleByPageStruct = function(page, states) {

	function _copyLocNode(uuid) {
		Object.keys($localization).forEach(function(lang) {
			var texts = $localizationNew[lang] = $localizationNew[lang] || {};
			texts[uuid] = $localization[lang][uuid];
		});
	}

	function _findLocMatch(text) {
		var oldTexts = $localization[curLang] || {};
		var match;
		Object.keys(oldTexts).some(function(uuid) {
			if (oldTexts[uuid] === text) {
				match = uuid;
				return true;
			}
			return false;
		});
		return match;
	}

	function _checkLocalization(nodeArticle) {
		var propsPerNode = ["$title"];
		propsPerNode.forEach(function(key) {
			var text = nodeArticle[key];
			if (nodeArticle.$theme === "advanced") {
				/*
				the title of "advanced" stack is wrongly stored as translated text (because of previous authoring).
				The goal of this hack is to clean the article.
				Can be removed for avengers version (after Laurent will do the authoring with his hack).
				*/
				text = "";
				nodeArticle[key] = "";
			}
			if (text) {
				var uuid = text.match(/\{\@(\S+)\}/);
				if (uuid && uuid[1]) { // text is already a placeholder, just copy to new structure
					_copyLocNode(uuid[1]);
				} else {
					uuid = _findLocMatch(text);
					if (!uuid) { // Create new ID or keep existing key (modify value only)
						var keepKey = nodeArticle.keepKey ? nodeArticle.keepKey.match(/\{\@(\S+)\}/) : null;
						uuid = keepKey ? keepKey[1] : utils.UUID();
						if (keepKey) {
							_copyLocNode(uuid);
							delete(nodeArticle.keepKey);
						}
						var texts = $localizationNew[curLang] = $localizationNew[curLang] || {};
						texts[uuid] = text;
					} else {
						_copyLocNode(uuid);
					}
					nodeArticle[key] = "{@" + uuid + "}";
				}
			}
		});
	}

	function _walkNode(article, node) {
		var nodeArticle = node.getAuthArticle();
		_checkLocalization(nodeArticle);
		if (states) {
			var state = node.getAuthState(nodeArticle.$isDirty || {});
			if (state) {
				var path = node.getPathInTree();
				path = path.join(".");
				states[path] = state;
			}
		}
		// Remove dirty flags
		delete nodeArticle.$isDirty;
		Object.keys(nodeArticle).forEach(function(key) {
			article[key] = nodeArticle[key];
		});

		if (node.isVignette()) {
			var page = node.getTopPage();
			if (page) { // Page is set if content of vignette is not a link
				var rootLayout = page.rootLayout;
				article.$article = {};
				_walkNode(article.$article, rootLayout);
			}
		} else {
			if (!node.excludeChildrenFromAuthoring() &&
				node.children && node.children.length > 0) {
				article.$items = [];
				node.children.forEach(function(child) {
					var childArticle = {};
					article.$items.push(childArticle);
					_walkNode(childArticle, child);
				});
			}
		}
	}
	var curLang = locale.getCurrentLocale();
	var rootLayout = page.rootLayout;
	var $localization = page.pageData.page.$article && page.pageData.page.$article.$localization || {};
	var $localizationNew = {};
	var jsonArticlePage = {};

	_authCopyPageProperties(page.article, jsonArticlePage);

	_walkNode(jsonArticlePage, rootLayout);

	jsonArticlePage.$localization = $localizationNew;

	var articleJSON = authVal.toSortedJSON(jsonArticlePage);
	return articleJSON;
};

/**
 * Authoring properties of a page
 */
function _authCopyPageProperties(src, dst) {
	var _authPageProps = ["$pageActionSettings", "$allowDownload"];
	if (!src || !dst) return;
	_authPageProps.forEach(function(p) {
		if (src[p] != null || (dst[p] != null && src[p] == null)) {
			dst[p] = src[p];
		}
	});
};

//Add views fetched from server to views from meta data
//ensure the selected flag of view from meta data is set to new list of views
function _updatePageMetaData(page, variant, variants, views, article) {
	//Update live page object
	// Make the view we just saved also the selected one in meta data
	variant && variant.variantId && views.forEach(function(view) {
		view.$selected = !!(view.$url && view.$url.indexOf(variant.variantId) > -1);
	});
	page.pageData.page.$views = views;
	page.variants = variants;
	var pageName = page.getAuthoringFullName();
	return metaDataCache.putArticle(pageName, article, views);
}
});

define('syracuse-tablet/html/js/authoring/authoringPanelRight',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/helpers/environment','syracuse-tablet/html/js/ui/siteLayout','syracuse-tablet/html/js/authoring/authoringCommons'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var environment = require('syracuse-tablet/html/js/helpers/environment');
var siteLayout = require('syracuse-tablet/html/js/ui/siteLayout');
var authCommons = require('syracuse-tablet/html/js/authoring/authoringCommons');

exports.Panel = utils.defineClass(function AuthoringPanelRight() {
	var self = this;
	self.$$panel = null;
	self.topButtons = [];
}, null, {
	show: function() {
		var self = this;

		self._ensurePanel();
		self._subscribe();

		self.$$panel.show();
		self.$$splitter.show();
		/* Min width for drag - self.$$splitter.width is 0 - We should improve that*/
		self._minWidth = 4 * siteLayout.splitterWidth;;
		self._initDefaults();

		$('#authPanelControl .btn', self.$$panelSave).eq(0).button("toggle");
		$('.nav-pills a[href="#authPanelControl"]').tab('show');
	},

	hide: function() {
		var self = this;
		self._ensurePanel();
		self.$$panel.hide();
		self.$$splitter.hide();
		self._unscribe();
	},
	_subscribe: function() {
		var self = this;
		notifications.subscribe(self, ["sm.main.layout.changed"]);
		notifications.subscribe(self, ["sm.auth.set.page"]);
		notifications.subscribe(self, ["sm.auth.set.selection"]);
		notifications.subscribe(self, ["sm.auth.top.button"]);
	},

	_unscribe: function() {
		var self = this;
		notifications.unsubscribe(self, ["sm.main.layout.changed"]);
		notifications.unsubscribe(self, ["sm.auth.set.page"]);
		notifications.unsubscribe(self, ["sm.auth.set.selection"]);
		notifications.unsubscribe(self, ["sm.auth.top.button"]);
	},

	notifMainLayoutChanged: function() {
		var self = this;
		self.$$panel.find(".tab-content").css({
			"height": self.$$panel.height() - 100
		});
	},

	_ensurePanel: function() {
		var self = this;
		if (this.$$panel) {
			return;
		}

		var ctx = {
			label_design: locale.text("auth.panel.label_design"),
			label_openCardDesign: locale.text("auth.openCardDesign")
		};

		self.$$panel = $("#s-m-auth-panel-right-id");
		$(authHtml.execute("authPanelRightStructure", ctx)).appendTo(self.$$panel);

		self._getDomObjects();
		self._initSplitter();
		self._initDomEvents();
	},

	_getDomObjects: function() {
		var self = this;
		self.$$panelRightStruct = self.$$panel.find("#authPanelControlTitle");
		self.$$panelControlSimple = $("#authPanelControlSimple");
		self.$$panelControlExpert = $("#authPanelControlExpert");
		self.$$panelControlTitle = $("#authPanelControlTitle");
		self.$$panelControlType = $("#authPanelControlType");

		self.$$panelControlChild = $("#s-m-auth-child-design-open-id");

		self.$$panelEdit = $("#authPanelEdit");
	},

	_initDomEvents: function() {
		var self = this;
		self.$$panelControlChild.on("click", self._onChildClick.bind(self));
	},

	_initDefaults: function() {
		var self = this;
		self.$$panelControlTitle.text("");
		self.$$panelControlType.text(locale.text("auth.panel.label_design"));
		self.destroyPropertyPanel();
	},
	/**
	 * context	indicates the context of destroy: selection...
	 * 		origin	"selection" -> destroy called by a selection of ctrl.layout
	 * context is used by topButtons destroyButtonMarkup
	 * 		destroyButtonMarkup returns false if button has not been destroyed
	 * -> destroyButtonMarkup/createButtonMarkup facilitate the search for buttons properties
	 */
	destroyPropertyPanel: function(context) {
		if (this.topButtons) {
			var preserveButtons = [];
			this.topButtons.forEach(function(prop) {
				if (prop.destroyButtonMarkup) {
					if (prop.destroyButtonMarkup(context) === false) {
						preserveButtons.push(prop);
					};
				}
			});
			this.topButtons = preserveButtons;
		}
		if (this._propertyPanel) {
			this._propertyPanel.destroy();
			this._propertyPanel = null;
		}
	},

	notifAuthSetPage: function(page) {
		var self = this;
		self.currentPageName = page.getAuthoringName();
		self._initDefaults();
		self._checkDetailNavigation(null, null);
	},

	/**
	 * path = null to remove current selection
	 */
	notifAuthSetSelection: function(id) {
		var self = this;
		self.$$panelControlTitle.text("");
		self.$$panelControlType.text(locale.text("auth.panel.label_design"));

		var sel = id ? authHelpers.getSelectionById(id) : null;

		authHelpers.savePanelStates();
		self.destroyPropertyPanel({
			origin: "selection"
		});
		var data;
		if (sel) {
			data = authHelpers.getSelectionData(sel);
			if (data) {
				self.$$panelControlTitle.text(data.title || "");
				self.$$panelControlType.text(locale.text("auth.panel.label_design") + " " + (data.type || ""));
				var article = data.articleSelection;
				if (article) {
					this._propertyPanel = authHelpers.createPropertyPanel(self.$$panelControlSimple, sel, data);
				}

				if (environment.isAutoUITestMode()) {
					var id = data.control ? data.control.getUnitTestId() : data.page ? data.page.getPageName() : null;
					environment.getUnitTestMgr().authAddRightPanelId(self.$$panelControlTitle.parent(), id);
				}
			}
		}

		self._checkDetailNavigation(sel, data);
	},

	_initSplitter: function() {
		var self = this;
		self.$$splitter = $("#s-m-auth-splitter-right-id");
		self.$$splitter.draggable({
			axis: "x",
			stop: function(e, ui) {
				var $$splitter = $(this);
				var pos = $$splitter.position();
				var width = $$splitter.width();
				var panelRightSize = Math.max(self._minWidth, $(window).width() - pos.left - width);
				// Normally we should block on drag event
				$$splitter.css({
					left: ($(window).width() - panelRightSize - width) + "px"
				});
				authHelpers.triggerResizeInternal({
					layout: {
						authPanelRight: {
							width: panelRightSize
						}
					}
				});
			}
		});
	},
	/**
	 * Ad a button at the top of property panel
	 */
	notifAuthTopButton: function(action, prop) {
		if (!this.$$panelRightStruct || !prop.createButtonMarkup) return;
		this.topButtons.push(prop);
		this.$$panelRightStruct.after(prop.createButtonMarkup(this.getPage()));
	},

	_checkDetailNavigation: function(sel, data) {
		var self = this;
		var page = authCommons.getCurrentPage();
		if (page && !page.isCardDetail() && data && data.control && data.control.$display === "card") {
			self.$$panelControlChild.show();
		} else {
			self.$$panelControlChild.hide();
		}
	},
	_onChildClick: function() {
		notifications.publish("sm.auth.open.card.design");
	}
});
});

define('syracuse-tablet/html/js/authoring/authoringDrag',['require','exports','module','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/authoring/authoringCommons','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var authCommons = require('syracuse-tablet/html/js/authoring/authoringCommons');
var modules = require('syracuse-tablet/html/js/common/modules');

var _$$lastElements = [];


/*
	Drag and drop helpers
*/

/*
 * Gets the control/drag element a dragged DOM element belongs to
 * (The DOM element on drag start can be a child of the actual draggable, this is why we need to go up the tree)
 */
exports.getClosestDragElement = function($$source) {
	var $$draggable = $$source.closest(".ui-draggable");
	return $$draggable;
};

exports.dropDrop = function($$drop, $$helper, $$draggable) {
	// We always drop to the highest element in the stack which belongs to the drop description
	// visible in the UI
	$$drop = _$$lastElements.length > 0 && _$$lastElements[_$$lastElements.length - 1];
	_$$lastElements = []; // There may be more drop events, we ignore all subsequent ones
	if (!$$drop) {
		return;
	}

	var data = _getDropData($$drop, $$draggable);
	if (!_isDropAllowed(data)) {
		return;
	}

	if (data.action === "add_layout") {
		_addLayout(data);
	} else if (data.action == "add_bind") {
		_addBind(data);
	} else if (data.action == "move_ctrl") {
		_moveControl(data);
	} else if (data.action == "move_layout") {
		_moveLayout(data);
	}

};

exports.dropAccept = function($$drop, $$draggable) {
	var data = _getDropData($$drop, $$draggable);
	return true;
};

exports.dropOut = function($$drop, $$helper, $$draggable) {
	$$drop.removeClass("s-m-top-stack");
	var $$top = _updateHoverStack();
	if ($$top) {
		_updateDragHelper($$top, $$helper, $$draggable);
	}
};

exports.dropOver = function($$drop, $$helper, $$draggable) {
	_$$lastElements.push($$drop);
	_updateHoverStack();
	_updateDragHelper($$drop, $$helper, $$draggable);
};

function _updateHoverStack() {
	var newList = [];
	$.each(_$$lastElements, function(idx, $$last) {
		$$last.removeClass("s-m-top-stack");
		if ($$last.hasClass("s-m-auth-hover-droptarget")) {
			newList.push($$last);
		}
	});
	var $$last = newList[newList.length - 1];
	if ($$last) {
		$$last.addClass("s-m-top-stack");
	}
	_$$lastElements = newList;
	return $$last;
}

function _updateDragHelper($$drop, $$helper, $$draggable) {
	var data = _getDropData($$drop, $$draggable);
	var allowed = _isDropAllowed(data);

	$$helper.removeClass("drop_move");
	$$helper.removeClass("drop_add");
	$$helper.removeClass("drop_disabled");
	if (!allowed) {
		$$helper.addClass("drop_disabled");
		$('#s-m-auth-drag-helper-desc-id', $$helper).text("");
		return;
	}

	var desc = "";
	var title;

	if (data.moveBeforeCtrl) {
		title = _controlTitle(data.moveBeforeCtrl);
	} else {
		title = _controlTitle(data.toContainer);
	}

	switch (data.action) {
		case "add_layout":
			if (data.moveBeforeCtrl) {
				desc = locale.text("auth.drag.add.before", [title]);
			} else {
				desc = locale.text("auth.drag.add.intoend", [title]);
			}
			$$helper.addClass("drop_add");
			break;
		case "add_bind":
			if (data.moveBeforeCtrl) {
				desc = locale.text("auth.drag.add.before", [title]);
			} else {
				desc = locale.text("auth.drag.add.intoend", [title]);
			}
			$$helper.addClass("drop_add");
			break;
		case "move_ctrl":
			if (data.moveBeforeCtrl) {
				desc = locale.text("auth.drag.move.before", [title]);
			} else {
				desc = locale.text("auth.drag.move.intoend", [title]);
			}
			$$helper.addClass("drop_move");
			break;
		case "move_layout":
			if (data.moveBeforeCtrl) {
				desc = locale.text("auth.drag.move.before", [title]);
			} else {
				desc = locale.text("auth.drag.move.intoend", [title]);
			}
			$$helper.addClass("drop_move");
			break;
	}

	$('#s-m-auth-drag-helper-desc-id', $$helper).text(desc);
}

function _isDropAllowed(data) {
	if (!data.toType) {
		return false;
	}

	var targetLayout;
	var container;

	if (data.ctrl) {
		data.container = data.ctrl.parent;
	}

	if (data.toCtrl && data.toCtrl.isLayout()) {
		container = data.toCtrl;
		targetLayout = data.toType;
	} else if (data.toCtrl) {
		container = data.toCtrl.parent;
		targetLayout = container.$type;
		data.moveBeforeCtrl = data.toCtrl;
	}
	data.toContainer = container;

	// Check layout constraints
	if (data.action === "add_layout") {
		if (data.bind == "stack") {
			if (targetLayout !== "stack" && targetLayout !== "cell" && targetLayout !== "tile") {
				return false;
			}
		} else if (data.bind == "group") {
			if (targetLayout !== "stack" && targetLayout !== "hub") {
				return false;
			}
		} else if (data.bind == "tile") {
			if (targetLayout !== "row" && targetLayout !== "hubGroup" && targetLayout !== "stack" && targetLayout !== "hub") {
				return false;
			}
		}
		return true;
	}

	// Check adding of controls
	if (data.action === "add_bind") {
		// Controlls in a vignette may only be added to the vignette the control belongs too but not to another one
		if (data.parent != data.toParent) {
			return false;
		}
		// Controls may only be added in a stack
		if (targetLayout === "stack" || targetLayout === "tile" || targetLayout === "cell" || targetLayout === "hubGroup") {
			return true;
		}
	}

	if (data.action === "move") {
		/* 
		 * Move of control
		 */
		if (data.ctrl && !data.ctrl.isLayout()) {
			data.action = "move_ctrl";
			if (data.parent != data.toParent) {
				return false;
			}

			// Controls may only be added in a stack
			if (targetLayout === "stack" || targetLayout === "tile" || targetLayout === "cell" || targetLayout === "hubGroup") {
				return true;
			}
		} else if (data.ctrl && data.ctrl.isLayout()) {
			data.action = "move_layout";
			if (data.type == "stack") {
				if (targetLayout !== "stack" && targetLayout !== "cell" && targetLayout !== "tile") {
					return false;
				}
			} else if (data.type == "tile") {
				if (targetLayout !== "hubGroup") {
					return false;
				}
			} else if (data.type == "cell") {
				if (targetLayout !== "row") {
					return false;
				}
			} else if (data.type == "row") {
				if (targetLayout !== "stack" && targetLayout !== "cell" && targetLayout !== "tile") {
					return false;
				}
			} else if (data.type == "hubGroup") {
				if (targetLayout !== "hub") {
					return false;
				}
			}

			// Check drop into self
			var $$dropToChildren = data.toCtrl.$$elmt.closest("#" + data.ctrl.id);
			if ($$dropToChildren.length > 0) { // Drop layout into a children of itself
				return false;
			}

			// Check vignette scope
			var vignetteScopeOk = true;
			var $$fromVignette = data.ctrl.$$elmt.closest(".s-m-control.s-m-vignette");
			var $$toVignette = data.toCtrl.$$elmt.closest(".s-m-control.s-m-vignette");
			if ($$fromVignette.length !== $$toVignette.length) { // From/to vignette to non vignette scope or other way around
				vignetteScopeOk = false;
			} else if ($$toVignette.length === 0) { // No vignettes involved, always ok
				vignetteScopeOk = true;
			} else if ($$fromVignette.length === 1 && $$toVignette.length === 1) { // From vignette to vignette scope
				if ($$fromVignette.attr("id") === $$toVignette.attr("id")) {
					vignetteScopeOk = true; // Same vignette	
				} else {
					vignetteScopeOk = false; // Vignette a -> vignette b = not allowed
				}
			}
			return vignetteScopeOk;
		}
	}
	return false;
}

function _getDropData($$drop, $$draggable) {
	var action;
	var fromId;
	var toId;
	var bind;
	var parent;

	action = $$draggable.attr("data-auth-drag-action");
	switch (action) {
		case "move":
			fromId = $$draggable.attr("data-ctrl-id");
			break;
		case "add_bind":
			bind = $$draggable.attr("data-auth-bind");
			parent = $$draggable.attr("data-auth-bind-parent");
			parent = parent === "" ? null : parent;
			break;
		case "add_layout":
			bind = $$draggable.attr("data-auth-bind");
			break;
		default:
			// drop from page (events currently disabled)
			action = "move";
			fromId = $$draggable.attr("id");
			break;
	}

	var ctrl;
	var $$ctrl;
	if (fromId && fromId.length > 0) {
		$$ctrl = $("#" + fromId);
		ctrl = authHelpers.findControl($$ctrl);
		var v = ctrl && ctrl.page.vignette;
		if (v) {
			parent = v.$bind; // Name of the vignette that is bound to the controller of the current element
		}
	}

	// drop control or layout
	toId = $$drop.attr("data-ctrl-id"); // drop inside tree
	if (toId && toId.length > 0) {
		$$ctrl = $("#" + toId);
	} else {
		toId = $$drop.attr("id"); // Drop inside page
		$$ctrl = $$drop;
	}

	var toParent;
	var toCtrl = authHelpers.findControl($$ctrl);
	if (toCtrl && !toCtrl.page) {
		toCtrl = null;
	}
	if (toCtrl) {
		var v = toCtrl.page.vignette;
		if (v) {
			toParent = v.$bind; // Name of the vignette that is bound to the controller of the current element
		}
	}

	if (!toCtrl && $$ctrl.is(".s-m-page,.s-m-full")) { // Dropping on the page is dropping into the page's root layout container
		toCtrl = authCommons.getCurrentPage().getRootLayout();
	}

	return {
		//		$$draggable: $$draggable,	// Debugging
		//		$$drop: $$drop,				// Debugging

		action: action, // move, add_bind, add_layout
		bind: bind, // $bind or name of layout in case of add*
		ctrl: ctrl,
		type: ctrl && ctrl.$type, // Type of drag target
		parent: parent, // parent $bind (e.g. vignette name)
		fromId: fromId, // ctrlId (when dragging existing ctrl)
		toId: toId, // ctrlId of drop target
		toType: toCtrl && toCtrl.$type, // Type of drop target
		toCtrl: toCtrl,
		toParent: toParent
	};
}

function _addLayout(data) {
	var layoutType = "stack";
	var toContainer = data.toContainer;
	var parent;

	switch (data.bind) {
		case "group":
			if (data.toType == "hub") {
				layoutType = "hubGroup";
			} else {
				layoutType = "row";
			}
			break;
		case "tile":
			if (data.toType == "hubGroup") {
				layoutType = "tile";
			} else if (data.toType == "row") {
				layoutType = "cell";
			} else if (data.toType == "stack") {
				parent = _createLayout(data.toCtrl.controller, toContainer, {
					$layoutType: "row"
				}, {});
				layoutType = "cell";
				toContainer = parent;
			} else if (data.toType == "hub") {
				parent = _createLayout(data.toCtrl.controller, toContainer, {
					$layoutType: "hubGroup"
				}, {});
				layoutType = "tile";
				toContainer = parent;
			}

			break;
		case "stack":
			layoutType = "stack";
			break;
	}

	var article = {
		$layoutType: layoutType
	};

	// Create new layout node
	var ctrl = _createLayout(data.toCtrl.controller, toContainer, article, {});

	// Move before desired sibling
	if (data.moveBeforeCtrl) {
		if (parent) { // Handle autoboxing
			data.toContainer.removeChildRef(parent);
			data.toContainer.addChildBefore(parent, data.moveBeforeCtrl);
		} else {
			toContainer.removeChildRef(ctrl);
			toContainer.addChildBefore(ctrl, data.moveBeforeCtrl);
		}
	}

	notifications.publish(["sm.auth.change.item.prop.ui"]);
}

function _addBind(data) {
	var article = {
		$bind: data.bind
	};
	var toContainer = data.toContainer;
	if (data.toType == "hubGroup") {
		var parent = _createLayout(data.toCtrl.controller, toContainer, {
			$layoutType: "tile"
		}, {});
		toContainer = parent;
	}

	var ctrl = _createBindControl(data.toCtrl.controller, toContainer, article, {});

	// Move before desired sibling
	if (data.moveBeforeCtrl) {
		data.toContainer.removeChildRef(ctrl);
		data.toContainer.addChildBefore(ctrl, data.moveBeforeCtrl);
	}

	notifications.publish(["sm.auth.change.item.prop.ui"]);
}

function _moveControl(data) {
	data.container.removeChildRef(data.ctrl);
	var toContainer = data.toContainer;
	if (data.toType == "hubGroup") {
		var parent = _createLayout(data.toCtrl.controller, toContainer, {
			$layoutType: "tile"
		}, {});
		toContainer.removeChildRef(parent);
		toContainer.addChildBefore(parent, data.moveBeforeCtrl);
		parent.addChildBefore(data.ctrl, null);
	} else {
		toContainer.addChildBefore(data.ctrl, data.moveBeforeCtrl);
	}
	notifications.publish(["sm.auth.change.item.prop.ui"]);
}

function _moveLayout(data) {
	data.container.removeChildRef(data.ctrl);
	data.toContainer.addChildBefore(data.ctrl, data.moveBeforeCtrl);
	notifications.publish(["sm.auth.change.item.prop.ui"]);
}

function _controlTitle(ctrl) {
	var title = ctrl.prototype && ctrl.prototype.data("$title");

	if (!title) {
		title = ctrl.$bind;
	} else if (ctrl.$bind) {
		title = title + " (" + ctrl.$bind + ")";
	}

	if (!title) {
		title = ctrl.$type;
	}
	return title;
}

function _createLayout(controller, parent, article, opts) {
	return modules.get("ctrlFactory").createControl(controller, article, parent, null, opts);
}

function _createBindControl(controller, parent, article, opts) {
	return modules.get("ctrlFactory").createControl(controller, article, parent, null, opts);
}
});

define('syracuse-tablet/html/js/authoring/authoringPanelLeft',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/authoring/authoringDrag','syracuse-tablet/html/js/authoring/authoringCommons','syracuse-tablet/html/js/helpers/environment','syracuse-tablet/html/js/ui/siteLayout'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var authDrag = require('syracuse-tablet/html/js/authoring/authoringDrag');
var authCommons = require('syracuse-tablet/html/js/authoring/authoringCommons');
var environment = require('syracuse-tablet/html/js/helpers/environment');
var siteLayout = require('syracuse-tablet/html/js/ui/siteLayout');

var $$lastHoverList;

exports.Panel = utils.defineClass(function AuthoringPanelLeft() {
	var self = this;
	self.$$panel = null;
	self.$$page = $("#s-m-app-id");
	self._bindsOnPage = [];
}, null, {
	show: function() {
		var self = this;

		self._ensurePanel();
		self._subscribe();

		self.$$panel.show();
		self.$$splitter.show();
		/* Min width for drag - width of tabs - self.$$splitter.width is 0 - We should improve that*/
		self._minWidth = 2 * siteLayout.splitterWidth;
		self.$$panel.find(".s-m-site-auth-panel-content > ul.nav.nav-pills > li").each(function() {
			self._minWidth += $(this).outerWidth();
		});
	},

	hide: function() {
		var self = this;
		self._ensurePanel();
		self.$$panel.hide();
		self.$$splitter.hide();
		self._unscribe();
	},

	_subscribe: function() {
		var self = this;
		notifications.subscribe(self, ["sm.main.layout.changed"]);
		notifications.subscribe(self, ["sm.auth.set.page"]);

		notifications.subscribe(self, ["sm.auth.set.selection"]);
		notifications.subscribe(self, ["sm.auth.remove.selection"]);

		notifications.subscribe(self, ["sm.auth.hover.in"]);
		notifications.subscribe(self, ["sm.auth.hover.out"]);
	},

	_unscribe: function() {
		var self = this;
		notifications.unsubscribe(self, ["sm.main.layout.changed"]);
		notifications.unsubscribe(self, ["sm.auth.set.page"]);

		notifications.unsubscribe(self, ["sm.auth.set.selection"]);
		notifications.unsubscribe(self, ["sm.auth.remove.selection"]);

		notifications.unsubscribe(self, ["sm.auth.hover.in"]);
		notifications.unsubscribe(self, ["sm.auth.hover.out"]);
	},

	notifMainLayoutChanged: function() {
		var self = this;

		$("#s-m-auth-tree-box", self.$$panel).css({
			"height": self.$$panel.height() - 45
		});
		$("#s-m-auth-insert-box", self.$$panel).css({
			"height": self.$$panel.height() - 40
		});
	},

	_ensurePanel: function() {
		var self = this;
		if (this.$$panel) {
			return;
		}
		var ctx = {
			label_content: locale.text("auth.panel.label_content"),
			label_insert: locale.text("auth.panel.label_insert"),
			label_containers: locale.text("auth.panel.label_containers"),
			label_fields: locale.text("auth.panel.label_fields"),
			lab_drag_to_add: locale.text("auth.label_layout.drag"),
			lab_group: locale.text("auth.label_layout.group"),
			lab_tile: locale.text("auth.label_layout.tile"),
			lab_stack: locale.text("auth.label_layout.stack"),
		};

		self.$$panel = $("#s-m-auth-panel-left-id");
		self.$$panel.append($(authHtml.execute("authPanelLeftStructure", ctx)));

		self._getDomObjects();
		self._initSplitter();
	},

	_getDomObjects: function() {
		var self = this;
		self.$$structureRoot = $("#auth-structure-root-id", self.$$panel);
		self.$$prototypeRoot = $("#auth-lp-cnt-props-clpse", self.$$panel);
	},

	_initSplitter: function() {
		var self = this;
		self.$$splitter = $("#s-m-auth-splitter-left-id");
		self.$$splitter.draggable({
			axis: "x",
			stop: function(e, ui) {
				var $$splitter = $(this);
				var pos = $$splitter.position();
				var width = $$splitter.width();
				var panelLeftSize = Math.max(self._minWidth, pos.left);
				// Normally we should block on drag event
				$$splitter.css({
					left: panelLeftSize + "px"
				});
				authHelpers.triggerResizeInternal({
					layout: {
						authPanelLeft: {
							width: panelLeftSize
						}
					}
				});
			}
		});
	},

	notifAuthSetPage: function(page) {
		var self = this;
		self._resetContent(page.article);
	},

	notifAuthSetSelection: function(id) {
		var self = this;
		var $$item = self._getItemById(id);
		if ($$item.length > 0) {
			$$item.addClass("s-m-auth-selected");
			var $$tb = $("#s-m-auth-tree-box", self.$$panel);
			var o1 = $$tb.offset();
			var o2 = $$item.offset();
			if (o2.top < o1.top || o2.top > (o1.top + $$tb.height())) {
				var scroll = o2.top - (o1.top + $$tb.height() / 2);
				$("#s-m-auth-tree-box", self.$$panel).animate({
					scrollTop: scroll
				}, 500);
			}
		}
	},

	notifAuthRemoveSelection: function(id) {
		var self = this;
		var $$item = self._getItemById(id);
		$$item.removeClass("s-m-auth-selected");
	},

	notifAuthHoverIn: function(id) {
		var self = this;
		var $$item = self._getItemById(id);
		$$item.addClass("s-m-auth-hover");
	},

	notifAuthHoverOut: function(id) {
		var self = this;
		var $$item = self._getItemById(id);
		$$item.removeClass("s-m-auth-hover");
	},

	_getItemById: function(id) {
		var self = this;
		return $('[data-ctrl-id="' + id + '"]', self.$$panel);
	},

	_resetContent: function(article) {
		var self = this;
		self._buildPageStructTree();
		self._buildProtoStructTree();
		self._initDomEvents();
		self._initDrag();
	},


	_buildPageStructTree: function() {
		var self = this;
		self._bindsOnPage = [];

		function _walkNode(node, $$parent, bindParent, level) {
			var nodeArticle = node.getArticle();
			var id = node.id;
			var typeClass;
			var label;

			// Never show root level layout node since it cannot be changed at all
			if (level === 1) {
				if (node.children && node.children.length > 0) {
					node.children.forEach(function(child) {
						if (child.article.$noAuthoring) {
							return;
						}
						var $$ul = $('<ul class="s-m-auth-tree">').appendTo($$parent);
						_walkNode(child, $$ul, bindParent, level + 1);
					});
				}
				return;
			}

			if (!node.isLayout()) {
				var title = node.prototype && node.prototype.data("$title");
				typeClass = node.typeName;
				label = title ? title : nodeArticle.$bind;
				var bind = bindParent != null ? bindParent + "." + node.$bind : node.$bind;
				self._bindsOnPage.push(bind);
			} else {
				typeClass = nodeArticle.$layoutType || node.typeName;
				label = nodeArticle.$title ? node.getArticleText("$title") + " (" + typeClass + ")" : typeClass;
			}
			var $$item = $('<li class="s-m-auth-tree s-m-auth-tree-' + typeClass + '">').appendTo($$parent);
			if (environment.isAutoUITestMode() && node.getUnitTestId) {
				var i = node.getUnitTestId();
				if (i) {
					environment.getUnitTestMgr().authAddTreeElmtId($$item, i);
				}
			}
			var $$p = $('<p title="' + nodeArticle.$bind + '" data-ctrl-id="' + id + '" class="s-m-draggable s-m-droppable" data-auth-drag-action="move">' + label + '</p>');
			$$item.append($$p);
			if (node.isVignette()) {
				self._bindsOnPage.push(node.$bind);
				var page = node.getTopPage();
				if (page) { // Page is set if content of vignette is not a link
					var rootLayout = page.rootLayout;
					var $$ul = $('<ul class="s-m-auth-tree">').appendTo($$item);
					var $$li = _walkNode(rootLayout, $$ul, node.$bind, level + 1);
					$(">p", $$li).removeClass("s-m-draggable");
				}
			} else {
				if (!node.excludeChildrenFromAuthoring() && // Some controls do authoring for their children (e.g. arrays)
					node.children && node.children.length > 0) {
					node.children.forEach(function(child) {
						if (child.article.$noAuthoring) {
							return;
						}
						var $$ul = $('<ul class="s-m-auth-tree">').appendTo($$item);
						_walkNode(child, $$ul, bindParent, level + 1);
					});
				}
			}
			return $$item;
		}

		var page = authCommons.getCurrentPage();
		var rootLayout = page.rootLayout;
		var label = page.getPrototype().data("$title") || locale.text("page");

		self.$$structureRoot.empty();
		var $$item = $('<li class="s-m-auth-tree s-m-auth-tree-page">').appendTo(self.$$structureRoot);
		$$item.append('<p data-ctrl-id="' + page.id + '">' + label + '</p>');
		var $$ul = $('<ul class="s-m-auth-tree">').appendTo($$item);

		var $$li = _walkNode(rootLayout, $$ul, null, 1);
		$(">p", $$li).removeClass("s-m-draggable");
	},

	/*
	 * Show page prototype tree, only show items that are not yet bound (referenced with $bind) on the page
	 * To only allow to add each field exactly one time.
	 */
	_buildProtoStructTree: function() {
		var self = this;
		var page = authCommons.getCurrentPage();
		var label = page.getPrototype().data("$title");
		self.$$prototypeRoot.empty();
		var $$item = $('<li class="s-m-auth-tree s-m-auth-tree-page">').appendTo(self.$$prototypeRoot);
		$$item.append('<p data-ctrl-id="' + page.id + '">' + label + '</p>');
		var $$ul = $('<ul class="s-m-auth-tree">').appendTo($$item);

		if (jsutils.isInstanceOf(page, "PageSdataDashboard")) {
			var pageProto = page.getPrototype();
			var props = pageProto.getPropertyNames();
			props.forEach(function(key) {
				var prop = pageProto.getValueByPath("$properties." + key);
				if (prop && (prop.$type === "application/x-vignette" || prop.$type === "application/x-vignette-link")) {
					self._addVignette(page, prop.$type, key, $$ul);
				}
			});
		} else {
			self._addPage(page, $$ul);
		}
	},

	_addVignette: function(page, $type, vignette, $$parent) {
		var self = this;
		var proto = page.getPrototype();
		var title = proto.getValueByPath("$properties." + vignette + ".$title");
		var label = title ? title + " (" + vignette + ")" : vignette;
		var $$item = $('<li class="s-m-auth-tree s-m-auth-tree-vignette">').appendTo($$parent);
		$$item.append('<p class="s-m-draggable" data-auth-bind="' + vignette + '"  data-auth-drag-action="add_bind">' + label + '</p>');

		var ctrlVignette = page.controller.getControlsByBind(vignette);
		ctrlVignette = ctrlVignette && ctrlVignette[0]; // Potentially could be more than one but the authoring permits this, so it's safe to use the first one
		if (ctrlVignette) {
			$$item.removeClass("s-m-draggable");
			$$item.addClass("disabled");
			// May be null if vignette is not displaying the content but only a link
			if ($type === "application/x-vignette") {
				page = ctrlVignette.getTopPage();
				if (page) {
					var $$ul = $('<ul class="s-m-auth-tree">').appendTo($$item);
					self._addPage(page, $$ul, vignette);

					var $$children = $("li", $$ul);
					// vignette used on page already and also all it's children, so no need to show
					if (self._bindsOnPage.indexOf(vignette) > -1) {
						if ($$children.length <= 0) {
							$$item.remove();
						}
					}
					if ($$children.length <= 0) {
						$$ul.remove();
					}
				}
			} else {
				// Vignette is only a link and already used on page
				if (self._bindsOnPage.indexOf(vignette) > -1) {
					$$item.remove();
				}
			}
		}
	},

	_addPage: function(page, $$parent, bindParent) {
		var self = this;
		var label = "?";
		var proto = page.getPrototype();
		var props = proto.getPropertyNames();
		props.forEach(function(key) {
			if (proto.getPropertyData(key, "$isExcluded") !== true) {;
				var bind = bindParent != null ? bindParent + "." + key : key;
				if (self._bindsOnPage.indexOf(bind) < 0) {
					var title = proto.getPropertyData(key, "$title");
					var type = proto.getPropertyData(key, "$type");
					var typeClass = utils.getTypeName(type);
					var label = title ? title + " (" + key + ")" : key;
					var $$item = $('<li class="s-m-auth-tree s-m-auth-tree-' + typeClass + '">').appendTo($$parent);
					$$item.append('<p class="s-m-draggable" data-auth-bind="' + key + '" data-auth-bind-parent="' + (bindParent || '') + '" data-auth-drag-action="add_bind">' + label + '</p>');
				}
			}
		});
	},

	_initDomEvents: function() {
		var self = this;
		$("li.s-m-auth-tree > p", $("#auth-structure-root-id")).not('li.s-m-auth-hidden > p').mouseover(function(e) {
			var $$o = $(e.currentTarget);
			if ($$lastHoverList) {
				$$lastHoverList.removeClass("s-m-auth-hover");
				var id = $$lastHoverList.attr("id");
				notifications.publishEx(["sm.auth.hover.out"], {
					exclude: [self]
				}, id);
			}
			$$o.addClass("s-m-auth-hover");
			$$lastHoverList = $$o;

			var id = $$o.attr("data-ctrl-id");
			notifications.publishEx(["sm.auth.hover.in"], {
				exclude: [self]
			}, id);
			return false;
		});

		$("li.s-m-auth-tree > p", $("#auth-structure-root-id")).not('li.s-m-auth-hidden > p').mouseout(function(e) {
			var $$o = $(e.currentTarget);
			$$o.removeClass("s-m-auth-hover");
			var id = $$o.attr("data-ctrl-id");
			notifications.publishEx(["sm.auth.hover.out"], {
				exclude: [self]
			}, id);
		});

		$("li.s-m-auth-tree > p", $("#auth-structure-root-id")).not('li.s-m-auth-hidden > p').click(function(e) {
			self.setSelection($(e.currentTarget), false);
			return false;
		});
		$("li.s-m-auth-tree > p", $("#auth-structure-root-id")).not('li.s-m-auth-hidden > p').dblclick(function(e) {
			self.makeVisibleInPage($(e.currentTarget));
			return false;
		});
	},

	/**
	 * Set current selection
	 * if $$newSel = null just remove the current selection
	 */
	setSelection: function($$newSel, noScroll) {
		var self = this;
		var $$old = $(".s-m-auth-selected", self.$$panel);
		$$old.removeClass("s-m-auth-selected");
		var id = $$old.attr("data-ctrl-id");
		notifications.publishEx(["sm.auth.remove.selection"], {
			exclude: [self]
		}, id);
		if ($$newSel) {
			// new sitem to select
			$$newSel.addClass("s-m-auth-selected");
			id = $$newSel.attr("data-ctrl-id");
		} else {
			// just remove selection
			id = null;
		}
		notifications.publishEx(["sm.auth.set.selection"], {
			exclude: [self]
		}, id, noScroll == null ? true : noScroll);
	},

	makeVisibleInPage: function($$sel) {
		var self = this;
		self.setSelection($$sel, false);
	},

	_initDrag: function() {
		var self = this;
		var dragParam = {
			scroll: false,
			containment: $("body"),
			helper: function(event) {
				var $$source = $(event.target);
				return self._createDragHelper($$source);
			},
			appendTo: "body",
		};
		$(".s-m-draggable", self.$$panel).draggable(dragParam);
		$(".s-m-droppable", self.$$structureRoot).droppable({
			greedy: true,
			hoverClass: "s-m-auth-hover-droptarget",
			tolerance: "pointer",
			drop: function(event, ui) {
				var $$helper = ui.helper;
				var $$draggable = ui.draggable;
				return authDrag.dropDrop($(this), $$helper, $$draggable);
			},
			accept: function($$draggable) {
				return authDrag.dropAccept($(this), $$draggable);
			},
			over: function(event, ui) {
				var $$helper = ui.helper;
				var $$draggable = ui.draggable;
				return authDrag.dropOver($(this), $$helper, $$draggable);
			}
		});
	},

	_createDragHelper: function($$source) {
		var $$dragSource = authDrag.getClosestDragElement($$source);
		var text;

		// Layout icon
		if ($$dragSource.attr("data-auth-drag-action") === "add_layout") {
			var name = $$dragSource.attr("data-auth-bind");
			text = locale.text("auth.drag." + name);
		} else {
			text = $$dragSource.text();
		}
		var $$helper = $('<div class="s-m-auth-drag-helper"><p id="s-m-auth-drag-helper-label-id">&nbsp;</p><p id="s-m-auth-drag-helper-desc-id">&nbsp;</p><div style="clear:both;"></div></div>');
		$('#s-m-auth-drag-helper-label-id', $$helper).text(text);
		return $$helper[0];
	},
});
});

define('syracuse-tablet/html/js/authoring/authoringPage',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/authoring/authoringDrag','syracuse-tablet/html/js/authoring/authoringCommons'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var authDrag = require('syracuse-tablet/html/js/authoring/authoringDrag');
var authCommons = require('syracuse-tablet/html/js/authoring/authoringCommons');

var _selectedRecord = "s-m-auth-rec-selected";
var $$lastHoverElement;

//Controls and layout classes that cannot be selected during authoring
var _elementsNoAuthoring = [
	".s-m-array .s-m-control",
	".s-m-array .s-m-layout",
	".s-m-control.header",
	".s-m-control.footer",
	".s-m-control.navigationpanel",
	".s-m-control.pageactionpanelregular",
	".s-m-control.breadcrumbs",
	".s-m-control.toolbar",
	".s-m-control.s-m-field > .s-m-value.edit > .s-m-control.s-m-unit", // Disable to select unit control of a quantity field
	".s-m-layout.s-m-hub", // do not allow to select root level hub (hub is always at root level, that's why there is no qualification like for the stack)
	".s-m-main-content > .s-m-scroll-elmt > .s-m-stack", // do not allow to select root level stack
	".s-m-main-content > .s-m-stack" // do not allow to select root level stack
];

exports.AuthPage = utils.defineClass(
	function AuthPage() {
		var self = this;

		self.__onElementClick = self._onElementClick.bind(self);
		self.__onElementMouseOver = self._onElementMouseOver.bind(self);
		self.__onElementMouseOut = self._onElementMouseOut.bind(self);

		self.$$page = $("#s-m-app-id");
	}, null, {

		enable: function() {
			var self = this;
			self._subscribe();
		},

		disable: function() {
			var self = this;
			self._unscribe();
		},

		/*
		 * Enable hover and click events in page
		 */
		enableAuthCss: function() {
			var self = this;
			// !! disableAuthCss is not well managed and if we call enableAuthCss without having called disableAuthCss we add multiple handlers
			// TODO - Review the destroy/disable process
			self.disableAuthCss();
			$(".s-m-control").addClass("s-m-auth");
			$(".s-m-layout").addClass("s-m-auth");
			$(".s-m-page").addClass("s-m-auth");
			$("section.s-m-card").addClass("s-m-auth");

			_elementsNoAuthoring.forEach(function(e) {
				$(e).removeClass("s-m-auth");
			});

			$(".s-m-auth", self.$$page).on("click", self.__onElementClick);
			$(".s-m-auth", self.$$page).on("mouseover", self.__onElementMouseOver);
			$(".s-m-auth", self.$$page).on("mouseout", self.__onElementMouseOut);

			self._enableDrop();
		},

		/*
		 * Disable all events in page that were used for authoring interaction
		 */
		disableAuthCss: function() {
			var self = this;
			self._disableDrop();
			var $$smAuth = $(".s-m-auth", self.$$page);
			$$smAuth.off("click", self.__onElementClick);
			$$smAuth.off("mouseover", self.__onElementMouseOver);
			$$smAuth.off("mouseout", self.__onElementMouseOut);
			$$smAuth.removeClass("s-m-auth");
			$(".s-m-record." + _selectedRecord, self.$$page).removeClass(_selectedRecord);
		},

		_subscribe: function() {
			var self = this;
			notifications.subscribe(self, ["sm.auth.hover.in"]);
			notifications.subscribe(self, ["sm.auth.hover.out"]);
			notifications.subscribe(self, ["sm.auth.set.selection"]);
			notifications.subscribe(self, ["sm.auth.remove.selection"]);
		},

		_unscribe: function() {
			var self = this;
			notifications.unsubscribe(self, ["sm.auth.hover.in"]);
			notifications.unsubscribe(self, ["sm.auth.hover.out"]);
			notifications.unsubscribe(self, ["sm.auth.set.selection"]);
			notifications.unsubscribe(self, ["sm.auth.remove.selection"]);
		},

		_enableDrop: function() {
			var self = this;
			var dragParam = {
				scroll: false,
				containment: $("body"),
				tolerance: "pointer",
				helper: function(event) {
					var $$source = $(event.target);
					return self._createDragHelper($$source);
				},
				appendTo: "body",
				revert: function($$drop) {
					return "invalid";
				},
				start: function() {},
				stop: function() {}
			};

			$(".s-m-auth").droppable({
				greedy: false,
				hoverClass: "s-m-auth-hover-droptarget",
				tolerance: "pointer",
				drop: function(event, ui) {
					var $$helper = ui.helper;
					var $$draggable = ui.draggable;
					return authDrag.dropDrop($(this), $$helper, $$draggable);
				},
				accept: function($$draggable) {
					return authDrag.dropAccept($(this), $$draggable);
				},
				over: function(event, ui) {
					var $$helper = ui.helper;
					var $$draggable = ui.draggable;
					return authDrag.dropOver($(this), $$helper, $$draggable);
				},
				out: function(event, ui) {
					var $$helper = ui.helper;
					var $$draggable = ui.draggable;
					return authDrag.dropOut($(this), $$helper, $$draggable);
				}
			});
		},

		_disableDrop: function() {
			$(".s-m-auth.ui-droppable").droppable("destroy");
		},

		_createDragHelper: function($$source) {
			var $$dragSource = authDrag.getClosestDragElement($$source);
			var control = authHelpers.findControl($$dragSource);
			if (!control) {
				return;
			}

			var $$helper = $('<p class="s-m-auth-drag-helper">');
			var text;
			if (control.prototype) {
				// it's a control
				text = control.prototype.data("$title");
				if (text) {
					text = text + "(" + control.$bind + ")";
				} else {
					text = control.$bind;
				}
			} else {
				// it's a layout
				text = control.title;
				if (text) {
					text = text + " (" + control.typeName + ")";
				} else {
					text = control.typeName;
				}
			}
			$$helper.text(text);
			return $$helper[0];
		},

		_onElementClick: function(e) {
			var self = this;
			var $$o = $(e.currentTarget);

			if ($$o.is("section.s-m-card")) {
				$$o.closest("table").find(".s-m-record." + _selectedRecord).removeClass(_selectedRecord);
				$$o.closest(".s-m-record").addClass(_selectedRecord);
				// Select the card - Event bubbles
				return;
			}
			var id = this.getCurrentSelected().removeClass("s-m-auth-selected").attr("id");
			if (id) {
				// synchronous is better
				notifications.publishEx(["synch.sm.auth.remove.selection"], {
					exclude: [self]
				}, id);
			}
			id = $$o.addClass("s-m-auth-selected").attr("id");
			// synchronous is better
			notifications.publishEx(["synch.sm.auth.set.selection"], {
				exclude: [self]
			}, id);
			// Scrolling needs shiftClick and altClick
			if (utils.stopClickEvent(e)) return false;
		},

		_onElementMouseOver: function(e) {
			var self = this;
			var $$o = $(e.currentTarget);
			if ($$lastHoverElement) {
				$$lastHoverElement.removeClass("s-m-auth-hover");
				notifications.publishEx(["sm.auth.hover.out"], {
					exclude: [self]
				}, $$lastHoverElement.attr("id"));
			}
			notifications.publishEx(["sm.auth.hover.in"], {
				exclude: [self]
			}, $$o.attr("id"));
			$$o.addClass("s-m-auth-hover");
			$$lastHoverElement = $$o;
			return false;
		},

		_onElementMouseOut: function(e) {
			var self = this;
			var $$o = $(e.currentTarget);
			$$o.removeClass("s-m-auth-hover");
			notifications.publishEx(["sm.auth.hover.out"], {
				exclude: [self]
			}, $$o.attr("id"));
		},

		notifAuthHoverIn: function(id) {
			var self = this;
			var $$pageItem = self._getItemById(id);
			$$pageItem.addClass("s-m-auth-hover");
		},

		notifAuthHoverOut: function(id) {
			var self = this;
			var $$pageItem = self._getItemById(id);
			$$pageItem.removeClass("s-m-auth-hover");
		},

		notifAuthSetSelection: function(id, noScroll) {
			var self = this;
			var $$item = self._getItemById(id);
			if ($$item && $$item.length > 0) {
				$$item.addClass("s-m-auth-selected");
				if (noScroll !== true) {
					self._scrollToVisibleArea($$item);
				}
			}
		},

		notifAuthRemoveSelection: function(id) {
			var self = this;
			var $$item = self._getItemById(id);
			$$item.removeClass("s-m-auth-selected");
		},

		_getItemById: function(id) {
			return $("#" + id, this.$$page);
		},

		getCurrentSelectionId: function() {
			return this.getCurrentSelected().attr("id");
		},

		getCurrentSelected: function() {
			// :visible because in the case of chartDetail page (child page) we have the parent page hidden
			return $(".s-m-auth-selected:visible", this.$$page);
		},

		_scrollToVisibleArea: function($$item) {
			var self = this;
			var page = authCommons.getCurrentPage();
			var scroller = page && page.getGestureMgr();
			if (scroller) {
				scroller.makeVisible($$item);
			}
		}
	});
});

define('syracuse-tablet/html/js/ui/modals/modalChooseDevice',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var modules = require('syracuse-tablet/html/js/common/modules');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="form-group s-m-scroll-element"> \
					<div class="list-group" id="modal-device-select-list-id"> \
						{{#each devices}} \
							<a draggable="false" href="#" class="list-group-item" data-action="clickDevice" data-params="{{name}}">{{label}}</a> \
						{{/each}} \
					</div> \
				</div> \
		    </div>',
	footer: ''
};

var _Klass = utils.defineClass(
	function ModalChooseDevice(device) {
		var self = this;
		modalDialog.ModalBase.call(self);
		// Init params
		self.selectedDevice = device;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "config-tile half_right";
			} else {
				displayFlags.modalClass = "config-tile full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			var devices = [];

			var site = modules.get("siteLayout");
			var devs = site.getDeviceTemplates();
			for (var dev in devs) {
				devices.push({
					name: dev,
					label: locale.textOpt("auth.device." + dev + ".title") || dev
				});
			}

			var data = {
				title: locale.text("auth.device.title"),
				devices: devices,
			};

			return data;
		},

		_onShow: function() {
			var self = this;
			modalDialog.ModalBase.prototype._onShow.call(self);
			$('a[data-params="' + self.selectedDevice + '"]').addClass("active");
		},

		// could be removed, result is set in _onAction
		_onValidate: function() {

		},
		_onCancel: function() {
			var self = this;
			self.selectedApps = {};
		},

		_onAction: function(action, param) {
			var self = this;
			if (action === "clickDevice") {
				self.selectedDevice = param;
				return true;
			}
			// dont close on actions
			return false;
		},

		_getResult: function() {
			var self = this;
			return self.selectedDevice;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalNewLayout',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
		<buttons class="pull-right"> \
			<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
			<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
		</buttons> \
		<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="alert alert-warning" role="alert"> \
					{{warning}} \
				</div> \
				<div class="form-group" id="dir"> \
					<label>{{lab_dir}}</label> \
        			<div class="btn-group btn-group-vertical btn-group-justified" data-toggle="buttons"> \
						<label class="btn btn-default {{#if horizontal}}active{{/if}}"> \
							<input type="radio" id="horizontal" name="scroll" value="horizontal" {{#if horizontal}}checked{{/if}}/>{{lab_horizontal}}\
						</label> \
						<label class="btn btn-default {{#unless horizontal}}active{{/unless}}"> \
							<input type="radio" id="vertical" name="scroll" value="vertical" {{#unless horizontal}}checked{{/unless}}/>{{lab_vertical}}\
						</label> \
					</div> \
				</div> \
				<div class="form-group" id="tpl"> \
					<label>{{lab_tpl}}</label> \
					<div class="btn-group btn-group-vertical btn-group-justified" data-toggle="buttons"> \
						<label class="btn btn-default {{#if template}}active{{/if}}"> \
							<input type="radio" id="template" name="empty" value="true" {{#if template}}checked{{/if}}/>{{lab_template}}\
						</label> \
						<label class="btn btn-default {{#unless template}}active{{/unless}}"> \
							<input type="radio" id="empty" name="empty" value="false" {{#unless template}}checked{{/unless}}/>{{lab_empty}}\
						</label> \
					</div> \
				</div> \
			</div>',
	footer: '',
};

var _Klass = utils.defineClass(
	function ModalNewLayout(_defaults) {
		var self = this;
		modalDialog.ModalBase.call(self);

		// Init params
		self._defaults = _defaults;
		// Result
		self.result = null;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "half_right";
			} else {
				displayFlags.modalClass = "full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			var data = {
				label_validate: locale.text("modal.ok"),
				label_cancel: locale.text("modal.cancel"),
				title: locale.text("modal.newlayout.title"),

				warning: locale.text("modal.newLayout.warning"),
				lab_horizontal: locale.text("modal.newLayout.horizontal"),
				lab_vertical: locale.text("modal.newLayout.vertical"),
				lab_template: locale.text("modal.newLayout.template"),
				lab_empty: locale.text("modal.newLayout.empty"),
				lab_dir: locale.text("modal.newLayout.dir"),
				lab_tpl: locale.text("modal.newLayout.tpl"),

				horizontal: self._defaults.scroll === "horizontal",
				template: self._defaults.template
			};

			return data;
		},

		_onValidate: function() {
			var self = this;
			var dir = self.$$elmt.find('#dir label.active input').val();
			var tpl = self.$$elmt.find('#tpl label.active input').val();

			self.result = {
				scroll: dir,
				template: tpl === "true"
			};
		},
		_onCancel: function() {
			var self = this;
			self.result = null;
		},

		_getResult: function() {
			var self = this;
			return self.result;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/authoring/authoringHeader',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/ui/modals/modalChooseDevice','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/ui/modals/modalNewLayout','syracuse-tablet/html/js/authoring/authoringCommons','syracuse-tablet/html/js/ui/siteLayout'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var modalChooseDevice = require('syracuse-tablet/html/js/ui/modals/modalChooseDevice');
var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var modalNewLayout = require('syracuse-tablet/html/js/ui/modals/modalNewLayout');
var authCommons = require('syracuse-tablet/html/js/authoring/authoringCommons');
var siteLayout = require('syracuse-tablet/html/js/ui/siteLayout');

exports.Panel = utils.defineClass(function AuthoringPanelHeader() {
	var self = this;
	self.$$panel = null;
}, null, {

	show: function() {
		var self = this;
		self._ensurePanel();
		self._subscribe();
		self.$$panel.show();
		self._initDefaults();
	},
	hide: function() {
		var self = this;
		self._ensurePanel();
		self.$$panel.hide();
		self._unscribe();
	},

	_ensurePanel: function() {
		var self = this;
		if (this.$$panel) {
			return;
		}
		var ctx = {
			label_settings: locale.text("auth.device.settings"),
			label_save: locale.text("auth.panel.label_save"),
			label_remove: locale.text("auth.panel.label_remove"),
			label_remove_container: locale.text("auth.panel.label_remove_container"),
			label_remove_all: locale.text("auth.panel.label_remove_all"),
			label_new_layout: locale.text("auth.panel.label_new_layout"),
			label_preview_portrait: locale.text("auth.panel.label_preview_portrait"),
			label_preview_landscape: locale.text("auth.panel.label_preview_landscape"),
			label_scale_to_fit: locale.text("auth.panel.label_scale_to_fit"),
			label_undo: locale.text("auth.label_undo"),
			label_undo_all: locale.text("auth.label_undo_all"),
		};

		self.$$panel = $("#s-m-auth-panel-header-id");
		self.$$panel.append($(authHtml.execute("authPanelHeader", ctx)));
		self._getDomObjects();
		self._initDomEvents();
	},

	_getDomObjects: function() {
		var self = this;
		self.$$orientation = $("#s-m-auth-orientation-id", self.$$panel);
		self.$$removeItem = $("#s-m-auth-remove-id", self.$$panel);
		self.$$removeCnt = $("#s-m-auth-remove-cnt-id", self.$$panel);
		self.$$removeAllItems = $("#s-m-auth-remove-all-id", self.$$panel);
		self.$$newLayout = $("#s-m-auth-new-layout-id", self.$$panel);
		self.$$undo = $("#auth-btn-undo-id", self.$$panel);
		self.$$undoAll = $("#auth-btn-undo-all-id", self.$$panel);
	},

	_initDomEvents: function() {
		var self = this;

		// preview options
		$("#s-m-auth-settings-id").on("click", self._onChooseDevice.bind(self));
		$("#s-m-auth-scale-id").on("click", self._onScaleDevice.bind(self));
		$("#s-m-auth-vertical-id").on("click", self._onOrientation.bind(self));
		$("#s-m-auth-horizontal-id").on("click", self._onOrientation.bind(self));
		// Delete
		self.$$removeItem.on("click", self._onRemoveItem.bind(self));
		self.$$removeCnt.on("click", self._onRemoveCnt.bind(self));
		self.$$removeAllItems.on("click", self._onRemoveAllItems.bind(self));
		self.$$newLayout.on("click", self._onNewLayout.bind(self));
		self.$$undo.on("click", self._onUndo.bind(self));
		self.$$undoAll.on("click", self._onUndoAll.bind(self));
		// save/close
		$("#auth-btn-save-id").on("click", self._onSave.bind(self));
		$("#auth-btn-close-id").on("click", self._onClose.bind(self));
	},

	_initDefaults: function() {
		var self = this;
	},

	_subscribe: function() {
		var self = this;
		notifications.subscribe(self, ["sm.auth.set.page"]);
		notifications.subscribe(self, ["sm.main.layout.changed"]);
		notifications.subscribe(self, ["sm.auth.set.selection"]);
		notifications.subscribe(self, ["sm.auth.history.change"]);
	},

	_unscribe: function() {
		var self = this;
		notifications.unsubscribe(self, ["sm.auth.set.page"]);
		notifications.unsubscribe(self, ["sm.main.layout.changed"]);
		notifications.unsubscribe(self, ["sm.auth.set.selection"]);
		notifications.unsubscribe(self, ["sm.auth.history.change"]);
	},

	notifMainLayoutChanged: function() {
		var self = this;
		var cur = siteLayout.getCurrentLayoutSettings();

		if (cur.pageParameters.forceAutoScale === true) {
			$("#s-m-auth-scale-id").addClass('active');
		} else {
			$("#s-m-auth-scale-id").removeClass('active');
		}
		if (cur.pageParameters.orientation === "landscape") {
			$("#s-m-auth-horizontal-id").addClass('active');
			$("#s-m-auth-vertical-id").removeClass('active');
		} else {
			$("#s-m-auth-horizontal-id").removeClass('active');
			$("#s-m-auth-vertical-id").addClass('active');
		}

	},

	notifAuthSetSelection: function(id) {
		var self = this;
		self._currentSelectionId = id;
		self._enableRemoveBtn();
	},

	notifAuthHistoryChange: function(pageHistory) {
		var self = this;
		if (pageHistory.length > 0) {
			self.$$undo.removeClass("disabled");
			self.$$undoAll.removeClass("disabled");
		} else {
			self.$$undo.addClass("disabled");
			self.$$undoAll.addClass("disabled");
		}
	},

	notifAuthSetPage: function(page) {
		this._checkSave();
	},
	_checkSave: function() {
		if (authCommons.isNonSaveablePage()) {
			$("#auth-btn-save-id").hide();
		} else {
			$("#auth-btn-save-id").show();
		}
	},
	_enableRemoveBtn: function() {
		var self = this;
		var stateRemove = false;
		var stateRemoveCnt = false;
		var sel, data, parent;

		if (self._currentSelectionId) {
			sel = authHelpers.getSelectionById(self._currentSelectionId);
			data = sel && authHelpers.getSelectionData(sel);
			if (!data || !data.control) {
				stateRemove = false;
			} else {
				stateRemove = true;
			}
		}

		if (data && data.control && data.control) {
			if (data.control.isRoot()) { // Never allow to remove root layout node, in page and/or in vignette
				stateRemove = false;
			}

			if (data.control.isLayout()) {
				stateRemoveCnt = true;
			}
		}

		if (stateRemove !== false) {
			self.$$removeItem.removeClass("disabled");
		} else {
			self.$$removeItem.addClass("disabled");
		}
		if (stateRemoveCnt !== false) {
			self.$$removeCnt.removeClass("disabled");
		} else {
			self.$$removeCnt.addClass("disabled");
		}
	},
	_setDeviceSize: function(size, orientation) {
		var params = {
			layout: {
				pageParameters: {}
			}
		};

		if (size) {
			params.layout.pageParameters.device = size;
		}
		if (orientation) {
			params.layout.pageParameters.orientation = orientation;
		}
		// To manage the deviceChanged	and set the device type in page root element that drives css
		params.layout.pageParameters.forcePreview = true;
		authHelpers.triggerResizeInternal(params);
	},

	_onRemoveItem: function() {
		if (!this._currentSelectionId) {
			return;
		}
		var sel = authHelpers.getSelectionById(this._currentSelectionId);
		var data = sel && authHelpers.getSelectionData(sel);
		if (!data || !data.control || data.control.isRoot()) {
			return;
		}
		this._enableRemoveBtn(false);
		// Change widget tree
		data.control.destroy();
		notifications.publish(["sm.auth.change.item.prop.ui"]);
	},

	_onRemoveCnt: function() {
		if (!this._currentSelectionId) {
			return;
		}
		var sel = authHelpers.getSelectionById(this._currentSelectionId);
		var data = sel && authHelpers.getSelectionData(sel);
		if (!data || !data.control) {
			return;
		}

		data.control.destroyChildren();
		notifications.publish(["sm.auth.change.item.prop.ui"]);
	},

	_onRemoveAllItems: function() {
		// Rebuild and apply new article
		var page = authCommons.getCurrentPage();
		page.rootLayout.destroyChildren();
		notifications.publish(["sm.auth.change.item.prop.ui"]);
	},

	_onClose: function() {
		notifications.publish(["sm.auth.close"]);
	},

	_onSave: function(evt) {
		notifications.publish(["sm.auth.save"]);
	},

	_onChooseDevice: function(elmt) {
		var self = this;
		var cur = siteLayout.getCurrentLayoutSettings();

		var modal = new modalChooseDevice.Modal(cur.pageParameters.device);
		modal.show().then(function(result) {
			if (result != null) {
				self._setDeviceSize(result);
				notifications.publish(["sm.auth.display.changed"], "device");
			}
		});
	},

	_onScaleDevice: function(elmt) {
		var cur = siteLayout.getCurrentLayoutSettings();

		var params = {
			layout: {
				pageParameters: {
					forceAutoScale: cur.pageParameters.forceAutoScale === false
				}
			}
		};
		authHelpers.triggerResizeInternal(params);
		notifications.publish(["sm.auth.display.changed"], "scale");
	},

	_onOrientation: function(elmt) {
		var self = this;
		var orient = $(elmt.currentTarget).attr("data-auth-orientation");
		if (orient) {
			self._setDeviceSize(null, orient);
			notifications.publish(["sm.auth.display.changed"], "orientation");
		}
	},

	_onNewLayout: function() {
		var self = this;

		var page = authCommons.getCurrentPage();
		var data = {
			scroll: jsutils.isInstanceOf(page, "PageSdataDashboard") ? "horizontal" : "vertical",
			template: true
		};
		var modal = new modalNewLayout.Modal(data);
		modal.show().then(function(result) {
			if (result != null) {
				notifications.publish(["sm.auth.new.layout"], result.scroll, result.template);
			}
		});
	},

	_onUndo: function() {
		notifications.publish(["sm.auth.undo"], false);
	},

	_onUndoAll: function() {
		notifications.publish(["sm.auth.undo"], true);
	}
});
});

define('syracuse-tablet/html/js/authoring/authoringFooter',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/authoring/authoringHtml'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');

exports.Panel = utils.defineClass(function AuthoringPanelFooter() {
	var self = this;
	self.$$panel = null;
}, null, {
	show: function() {
		var self = this;

		self._ensurePanel();
		self._subscribe();

		self.$$panel.show();

		self._initDefaults();
	},
	hide: function() {
		var self = this;
		self._ensurePanel();
		self.$$panel.hide();

		self._unscribe();
	},

	_ensurePanel: function() {
		var self = this;
		if (this.$$panel) {
			return;
		}

		var ctx = {};

		self.$$panel = $("#s-m-auth-panel-footer-id");
		self.$$panel.append($(authHtml.execute("authPanelFooter", ctx)));

		self._getDomObjects();
		self._initDomEvents();
	},

	_getDomObjects: function() {},

	_initDomEvents: function() {},

	_initDefaults: function() {},

	_subscribe: function() {},

	_unscribe: function() {},
});
});

define('syracuse-tablet/html/js/authoring/authoringArticleGen',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

/**
 * opts: {
 *   page,
 *   orientation,
 *   template
 * }
 */
exports.genNewArticle = function(opts) {
	var proto;
	proto = opts.page.getPrototype();

	if (jsutils.isInstanceOf(opts.page, "PageSdataDashboard")) {
		return _generateDashboardArticle(proto, opts.orientation, opts.template);
	} else {
		return _generateRegularArticle(proto, opts.orientation, opts.template);
	}
};
/**
 * Return the article synchronously
 */
exports.genCardArticle = function(prototype) {
	return _generateRegularArticle(prototype, null, true, true);
};

function _generateDashboardArticle(proto, orientation, tpl) {

	var article;
	proto = proto.json;
	var props = proto.$properties;

	if (orientation === "horizontal") {
		article = {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "",
				"$items": []
			}]
		};

		// Just create root and return if requested
		if (tpl === false) {
			return $.smResolve(article);
		}

		Object.keys(props).forEach(function(key) {
			var prop = props[key];
			if (prop.$type === "application/x-vignette") {
				article.$items[0].$items.push({
					"$layoutType": "tile",
					"$size": "medium",
					"$items": [{
						"$bind": key,
					}]
				});
			}
		});
	} else {
		article = {
			"$layoutType": "stack",
			"$items": []
		};

		// Just create root and return if requested
		if (tpl === false) {
			return $.smResolve(article);
		}

		var cellCount = 4;
		var row;
		Object.keys(props).forEach(function(key) {
			var prop = props[key];
			if (prop.$type === "application/x-vignette") {
				if (cellCount === 4) {
					cellCount = 0;
					row = {
						"$layoutType": "row",
						"$items": []
					};
					article.$items.push(row);
				}
				row.$items.push({
					"$layoutType": "cell",
					"$widthXs": 12,
					"$widthSm": 6,
					"$widthMd": 4,
					"$widthLg": 3,
					"$items": [{
						"$bind": key,
					}]
				});
			}
		});
	}
	return $.smResolve(article);
};

function _generateRegularArticle(proto, orientation, tpl, synch) {
	proto = proto.json;
	if (proto.$type === "application/x-array") {
		proto = proto.$item;
	}
	var props = proto.$properties;
	var $items, prop;
	var forceNoTitle = _getFacet(proto.$url) === "query";
	if (orientation === "horizontal") {
		article = {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "",
				"$items": []
			}]
		};

		// Just create root and return if requested
		if (tpl === false) {
			return $.smResolve(article);
		}

		var groupItems = article.$items[0].$items;
		var maxItemsPerGroup = 4;
		var itemsPerGroup = maxItemsPerGroup;
		var tileItems;
		var singlePropTypes = ["application/x-array", "application/x-document", "image"];
		for (var p in props) {
			prop = props[p];
			if (prop.$isExcluded !== true) {
				if (singlePropTypes.indexOf(prop.$type) > -1) {
					var tile = {
						"$layoutType": "tile",
						"$size": "large",
						"$items": []
					};
					groupItems.push(tile);
					tileItems = tile.$items;
					itemsPerGroup = maxItemsPerGroup;
				} else if (itemsPerGroup >= maxItemsPerGroup) {
					itemsPerGroup = 0;
					var tile = {
						"$layoutType": "tile",
						"$size": "large",
						"$items": []
					};
					groupItems.push(tile);
					tileItems = tile.$items;
				}

				itemsPerGroup = itemsPerGroup + 1;
				var a = {
					$bind: p
				};
				if (forceNoTitle) {
					a.$isTitleHidden = forceNoTitle;
				} else {
					a.$labelPosition = "top";
				}
				tileItems.push(a);
			}
		}
	} else {
		var article = {
			$layoutType: "stack",
			$items: []
		};

		// Just create root and return if requested
		if (tpl === false) {
			return $.smResolve(article);
		}
		if (!proto || !proto.$article || !proto.$article.$layout) {
			$items = article.$items;
			for (var p in props) {
				prop = props[p];
				if (prop.$isExcluded !== true) {
					var a = {
						$bind: p
					};
					if (forceNoTitle) {
						a.$isTitleHidden = forceNoTitle;
					}
					$items.push(a);
				}
			}
		} else {
			_x3Layout2DefaultArticle(proto, article, props);
		}
	}
	return synch === true ? article : $.smResolve(article);
};

var _testFacet = /representation=.*\.\$(\w+)[&]*/;

function _getFacet($url) {
	var t = _testFacet.exec($url || "");
	return t != null && t.length == 2 ? t[1] : null;
};

function _x3Layout2DefaultArticle(proto, article, props) {
	function _parse(coreLayout, article, props) {
		if (!coreLayout) return;
		var idx, idx1;
		coreLayout.$items.forEach(function($itm) {
			switch ($itm.$category) {
				case "section":
					idx = article.$items.push({
						"$title": $itm.$title,
						"$layoutType": "stack",
						"$items": []
					});
					_parse($itm.$layout, article.$items[idx - 1], props);
					break;
				case "block":
					idx = article.$items.push({
						"$title": $itm.$title,
						"$layoutType": "stack",
						"$items": []
					});
					idx1 = article.$items[idx - 1].$items.push({
						"$layoutType": "row",
						"$items": []
					});
					_parse($itm.$layout, article.$items[idx - 1].$items[idx1 - 1], props);
					break;
				default:
					if (props[$itm.$bind] && !props[$itm.$bind].$isExcluded) {
						idx = article.$items.push({
							"$layoutType": "cell",
							"$bgColor": "",
							/*to avoid default cell color*/
							"$items": []
						});

						article.$items[idx - 1].$items.push({
							"$bind": $itm.$bind,
						});
					}
					break;
			}
		});
	}
	_parse(proto.$article.$layout, article, props);
}
});

define('syracuse-tablet/html/js/ui/modals/modalSaveAuth',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
			<div class="s-m-scroll-element"> \
		 		{{#each fields}}\
				<div class="form-group"> \
					<label>{{label}}</label> \
					<input class="{{css}} form-control" id="{{id}}" type="text" value="{{value}}" {{readonly}}/> \
				</div> \
				{{/each}}\
				<label id="saveType" params="{{saveType}}" >{{label_save_type}}</label> \
				<div class="btn-group btn-group-justified" data-toggle="buttons"> \
			   {{#each buttons}}\
					<div class="btn-group"> \
					<label class="{{css}} btn btn-primary {{active}}" data-action="clickType" data-params="{{id}}"  >\
					<input type="radio"  name="options" id="{{id}}" {{checked}}>{{label}} \
					</label>\
					</div>\
				{{/each}}\
				</div> \
			</div> \
			</div>',
	footer: ''
};

var _Klass = utils.defineClass(
	function ModalSaveAuth(saveContext) {
		var self = this;
		modalDialog.ModalBase.call(self);

		self.saveContext = saveContext;

		// Result
		self.result = null;
	}, modalDialog.ModalBase, {
		destroy: function() {
			$("input.evt-input", this.$$elmt).off();
			modalDialog.ModalBase.prototype.destroy.call(this);
		},
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},
		/**
		 * Always Half-right because only on desktop
		 */
		getDisplayFlags: function() {
			var displayFlags = this.displayFlags || {};
			displayFlags.modalClass = "config-tile half_right";
			return displayFlags;
		},
		_getDataContext: function() {
			var self = this;
			self.currentVariant = $.smFind(self.saveContext.variants, function(variant) {
				return variant.isSelected;
			}) || {};
			self.currentVariant.comment = self.currentVariant.comment || self.saveContext.comment;
			var readonly = "readonly";
			var data = {
				title: locale.text("auth.save.title"),
				page: self.saveContext.pageName,
				fields: [{
					id: "authCode",
					label: locale.text("auth.panel.label_code"),
					value: self.currentVariant.code,
					readonly: readonly,
					css: "evt-input"
				}, {
					id: "authTitle",
					label: locale.text("auth.panel.label_title"),
					value: self.currentVariant.title,
					readonly: readonly,
					css: "evt-input"
				}, {
					id: "authDescription",
					label: locale.text("auth.panel.label_description"),
					value: self.currentVariant.description,
					readonly: readonly,
					css: "evt-input"
				}, {
					id: "authComment",
					label: locale.text("auth.panel.label_comment"),
					value: self.currentVariant.comment || self.saveContext.comment,
				}],
				saveType: "save",
				label_save_type: locale.text("auth.panel.label_save"),

				buttons: [{
					id: "personal_copy",
					label: locale.text("auth.panel.label_personal"),
					active: (self.currentVariant.isPersonal && self._isPersonelVariantAutorized()) ? "active" : "",
					css: (!self._isPersonelVariantAutorized()) ? "disabled" : ""
				}, {
					id: "global_variant",
					label: locale.text("auth.panel.label_global"),
					active: (self.currentVariant.isGlobal && self._isGlobalVariantAutorized()) ? "active" : "",
					css: (!self._isGlobalVariantAutorized()) ? "disabled" : ""
				}, {
					id: "factory_variant",
					label: locale.text("auth.panel.label_factory"),
					active: (self.currentVariant.isFactory && self._canUpdateFactory(self.currentVariant)) ? "active" : "",
					css: (!self._canManageFactory()) ? "disabled" : ""
				}, ]
			};
			return data;
		},
		_canUpdateFactory: function(variant) {
			return (this._canManageFactory() && (this.saveContext.securityProfile.factoryId === variant.factoryOwner));
		},
		_canManageFactory: function() {
			return (this.saveContext.securityProfile.factoryId != "" && this._isGlobalVariantAutorized());
		},
		_isGlobalVariantAutorized: function() {
			return this.saveContext.securityProfile.personalizationLevel === "admin";
		},
		_isPersonelVariantAutorized: function() {
			return this.saveContext.securityProfile.personalizationLevel === "admin" || this.saveContext.securityProfile.personalizationLevel === "user";
		},
		_onShow: function(evt) {
			var self = this;
			modalDialog.ModalBase.prototype._onShow.call(this, evt);
			//this.$$element.on('click', 'input[type="checkbox"]', jsutils.bindFn(this._onInput, this));
			$("input.evt-input", self.$$elmt).on("input", self._onInput.bind(self));
			self._refreshBtnValidate();
		},
		_onAction: function(action, param) {
			if (action !== "clickType") return false;
			var self = this;
			var ctxUI = {};
			var create = false;
			switch (param) {
				case "factory_variant":
					if (self._canManageFactory()) {
						self.currentVariant = $.smFind(self.saveContext.variants, function(variant) {
							return variant.isFactory && variant.factoryOwner === self.saveContext.securityProfile.factoryId;
						});
						if (!self.currentVariant) {
							create = true;
							self.currentVariant = {
								isFactory: true,
								code: this.saveContext.securityProfile.factoryId,
								title: this.saveContext.securityProfile.factoryId,
								description: this.saveContext.securityProfile.factoryId,
								factoryOwner: this.saveContext.securityProfile.factoryId,
								comment: "",
							};
						}
					};
					break;
				case "global_variant":
					self.currentVariant = $.smFind(self.saveContext.variants, function(variant) {
						return variant.isGlobal;
					});
					if (!self.currentVariant) {
						create = true;
						this.currentVariant = {
							isGlobal: true,
							code: "GLOBAL",
							title: "GLOBAL",
							description: "GLOBAL",
							comment: "",
						};
					}
					break;
				case "personal_copy":
					self.currentVariant = $.smFind(self.saveContext.variants, function(variant) {
						return variant.isPersonal;
					});
					if (!self.currentVariant) {
						create = true;
						this.currentVariant = {
							isPersonal: true,
							code: "PERSONAL",
							title: "PERSONAL",
							description: "PERSONAL",
							comment: "",
						};
					}
					break;
			};
			$("label[data-params='" + param + "']", self.$$elmt).eq(0).button("toggle");
			if (create) {
				var UI = {
					saveType: "saveAs",
					label_save_type: locale.text("auth.panel.label_saveas_option"),
				};
			} else {
				var UI = {
					saveType: "save",
					label_save_type: locale.text("auth.panel.label_save"),
				};
			}
			UI.fields = [{
				id: "authCode",
				value: self.currentVariant.code,
				readonly: !create
			}, {
				id: "authTitle",
				value: self.currentVariant.title,
				readonly: !create
			}, {
				id: "authDescription",
				value: self.currentVariant.description,
				readonly: !create
			}, {
				id: "authComment",
				value: self.currentVariant.comment,
				readonly: false
			}];
			self._changeUI(UI);
			return false;
		},
		_changeUI: function(ctx) {
			var self = this;
			var $$saveType = self.$$elmt.find("#saveType");
			$$saveType.attr("params", ctx.saveType);
			$$saveType.text(ctx.label_save_type);
			var field;
			ctx.fields.forEach(function(item) {
				field = self.$$elmt.find("#" + item.id);
				field.val(item.value);
				if (item.readonly) {
					field.attr("readonly", "readonly");
				} else {
					field.removeAttr("readonly");
				}
			});
			this._refreshBtnValidate(true);
		},
		_onValidate: function() {
			var self = this;
			self.result = {
				code: self.$$elmt.find("#authCode").val(),
				title: self.$$elmt.find("#authTitle").val(),
				description: self.$$elmt.find("#authDescription").val(),
				comment: self.$$elmt.find("#authComment").val(),
				variantType: $("label[data-action='clickType'].active", self.$$elmt).attr("data-params"),
				uuid: self.currentVariant.uuid
			};
		},
		_onCancel: function() {
			var self = this;
			self.result = null;
		},
		/**
		 * Manages create button status
		 */
		_onInput: function(evt) {
			this._refreshBtnValidate();
		},
		_refreshBtnValidate: function(focus) {
			var disabled = false,
				$$field;
			disabled = (!$("label[data-action='clickType'].active", this.$$elmt).attr("data-params"));
			if (!disabled) {
				$$field = this.$$elmt.find("#authCode");
				if (!(disabled = ($$field.val().trim().length <= 0))) {
					$$field = this.$$elmt.find("#authTitle");
					if (!(disabled = ($$field.val().trim().length <= 0))) {
						$$field = this.$$elmt.find("#authDescription");
						disabled = ($$field.val().trim().length <= 0);
					}
				}
			}
			if (focus && disabled && $$field) $$field.focus();
			$("button[data-action='$validate']").toggleClass("disabled", disabled);
		},
		_getResult: function() {
			var self = this;
			return self.result;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/authoring/authoring',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/app/globals','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/authoring/authoringPanelRight','syracuse-tablet/html/js/authoring/authoringPanelLeft','syracuse-tablet/html/js/authoring/authoringPage','syracuse-tablet/html/js/authoring/authoringHeader','syracuse-tablet/html/js/authoring/authoringFooter','syracuse-tablet/html/js/authoring/authoringArticleGen','syracuse-tablet/html/js/authoring/authoringVal','syracuse-tablet/html/js/authoring/authoringCommons','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/ui/modals/modalSaveAuth','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/authoring/authoringProperties','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/app/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var authoringPanelRight = require('syracuse-tablet/html/js/authoring/authoringPanelRight');
var authoringPanelLeft = require('syracuse-tablet/html/js/authoring/authoringPanelLeft');
var authoringPage = require('syracuse-tablet/html/js/authoring/authoringPage');
var authoringHeader = require('syracuse-tablet/html/js/authoring/authoringHeader');
var authoringFooter = require('syracuse-tablet/html/js/authoring/authoringFooter');
var authoringArticleGen = require('syracuse-tablet/html/js/authoring/authoringArticleGen');
var authVal = require('syracuse-tablet/html/js/authoring/authoringVal');
var authCommons = require('syracuse-tablet/html/js/authoring/authoringCommons');
var modules = require('syracuse-tablet/html/js/common/modules');

var modalSaveAuth = require('syracuse-tablet/html/js/ui/modals/modalSaveAuth');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var authProps = require('syracuse-tablet/html/js/authoring/authoringProperties');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _authInterface;

var _authEvents = ["sm.page.loaded",
	"sm.all.vignettes.loaded",
	"sm.auth.change.item.prop.ui",
	"sm.auth.change.prop.ui",
	"sm.auth.close",
	"sm.auth.save",
	"sm.auth.new.layout",
	"sm.auth.set.page",
	"sm.auth.display.changed",
	"sm.auth.undo",
	"sm.auth.open.card.design"
];
/*
 * This module glues together the action done in the page and the two panels
 */

exports.toggleDesignPage = function() {
	if (!_authInterface) {
		_authInterface = new AuthInterface();
	}

	_authInterface.toggleDesignPage();
};
exports.isEnabled = function() {
	return _authInterface && _authInterface.isActive;
};
/**
 * Returns true if back process can continue
 */
// Called on unload event - application.onUnload
exports.destroy = function() {
	if (!_authInterface) return;
	_authInterface.destroy();
	_authInterface = null;
};
var AuthInterface = utils.defineClass(function AuthoringInterface() {
	var self = this;
	self.$$authPanel = null;
	self.isActive = false;

	self.undoPageHistory = {};
	self.isDirty = false // True if not all changes are saved yet, used by close button;

	/*
	 * Right panel interaction
	 */
	self.rightPanel = new authoringPanelRight.Panel();

	/*
	 * Left panel interaction
	 */
	self.leftPanel = new authoringPanelLeft.Panel();

	/*
	 * Header
	 */
	self.headerPanel = new authoringHeader.Panel();

	/*
	 * Footer
	 */
	self.footerPanel = new authoringFooter.Panel();

	/*
	 * Page interaction
	 */
	self.authPage = new authoringPage.AuthPage();

	authProps.initProperties(authHelpers);
	authVal.setProperties(authProps);
}, null, {

	destroy: function() {
		var self = this;
		// TODO - improve destroy
		["rightPanel", "leftPanel", "headerPanel", "authPage"].forEach(function(p) {
			if (self[p] && self[p].destroy) {
				self[p].destroy();
			}
			self[p] = null;
		});
	},

	toggleDesignPage: function(forceStatus) {
		if (this.isActive || forceStatus === false) {
			this.disable();
		} else {
			this.enable();
		}
	},

	enable: function() {
		var self = this;

		self._subscribe();

		self.authPage.enable();
		self.rightPanel.show();
		self.leftPanel.show();
		self.headerPanel.show();
		self.footerPanel.show();

		var page = authCommons.getCurrentPage();
		authHelpers.getPageVariants(page)
			.then(function(variants) {
				page.variants = variants;
				return authHelpers.getPageViews(page)
			})
			.then(function(views) {
				_mergeViews(page, views);
			})
			.then(function() {
				notifications.publish(["sm.auth.set.page"], page);
				authHelpers.triggerResizeInternal({
					preserveScroll: true,
					layout: {
						authPanelLeft: {
							visible: true
						},
						authPanelRight: {
							visible: true
						},
						authPanelHeader: {
							visible: true
						},
						authPanelFooter: {
							visible: true
						},
						pageParameters: {
							forcePreview: true
						}
					}
				});

				self.authPage.enableAuthCss();

				self.isActive = true;
				self.isDirty = false;
				globals.setAuthoringActive(true);
			})
			.fail(function(e) {
				modules.get("modal").error(e);
			});
	},

	disable: function() {
		var self = this;

		self.authPage.disable();
		self.rightPanel.hide();
		self.leftPanel.hide();
		self.headerPanel.hide();
		self.footerPanel.hide();
		self.isActive = false;

		self.authPage.disableAuthCss();

		authHelpers.triggerResizeInternal({
			preserveScroll: true,
			layout: {
				authPanelLeft: {
					visible: false
				},
				authPanelRight: {
					visible: false
				},
				authPanelHeader: {
					visible: false
				},
				authPanelFooter: {
					visible: false
				},
				pageParameters: {
					forcePreview: false
				}
			}
		});
		self.isActive = false;
		self._unscribe();
		globals.setAuthoringActive(false);
	},

	_subscribe: function() {
		notifications.subscribe(this, _authEvents);
	},

	_unscribe: function() {
		notifications.unsubscribe(this, _authEvents);
	},

	notifAllVignettesLoaded: function(dashboardPage) {
		var self = this;
		if (!self.isActive) {
			return;
		}
		self.authPage.enableAuthCss();
		if (dashboardPage) {
			notifications.publish(["sm.auth.set.page"], dashboardPage);
			// computeLayout after having enableAuthCss
			// Card size in vignette depends on enableAuthCss so we have to recompute
			dashboardPage.computeLayout();
		}

	},

	notifPageLoaded: function(page) {
		var self = this;
		if (!self.isActive) {
			return;
		}

		if (page && !page.allowAuthoring()) {
			self.authPage.disableAuthCss();
			self.toggleDesignPage();
			return;
		}

		if (page.isVignette() || page.isDashboard()) {
			// Vignettes do not have to trigger a refresh on load
			// for dashboard, we handle update of the page by notifAllVignettesLoaded
			return;
		}

		notifications.publish(["sm.auth.set.page"], page);
		self.authPage.enableAuthCss();
	},

	notifAuthSetPage: function(page) {
		var self = this;
		var parentAuthoringName = self.currentPageName;
		self.currentPageName = page.getAuthoringName();
		self.currentPageFullName = page.getAuthoringName();

		// Copy of article before we start changing it
		self.displayedArticle = JSON.stringify(page.getArticle());
		// init history on page change
		if (!self.undoPageHistory[self.currentPageName]) {
			self.undoPageHistory[self.currentPageName] = {
				parentPageName: parentAuthoringName,
				articles: []
			};
		}
		notifications.publish(["sm.auth.history.change"], self.undoPageHistory[self.currentPageName].articles);
	},

	// Called if a new article is to be applied on the page by a user interaction
	// Here, we need to put the previous article in the undo buffer
	notifAuthChangePropUi: function(articlePage, states, vignetteToUpdt) {
		var self = this;

		if (self.displayedArticle != null) {
			self.isDirty = true; // As soon as we put something into the undo history, we got dirty changes we need to save
			self.undoPageHistory[self.currentPageName].articles.push(self.displayedArticle);
			notifications.publish(["sm.auth.history.change"], self.undoPageHistory[self.currentPageName].articles);
			self.displayedArticle = null;
		}
		self._updateLayoutPage(articlePage, states, vignetteToUpdt);
	},

	// Called by panels if something has changed to trigger a repaint of the page content and also reinitialize the panels
	notifAuthChangeItemPropUi: function() {
		var self = this;
		var page = authCommons.getCurrentPage();
		var states = {};
		var articleJSON = authHelpers.rebuildArticleByPageStruct(page, states);
		notifications.publish(["sm.auth.change.prop.ui"], articleJSON, states);
	},

	notifAuthClose: function(articlePage) {
		var self = this;
		var page = authCommons.getCurrentPage();
		if (page && page.isCardDetail()) {
			self._closeCardDesign();
		} else {
			self._authCloseAuthoring(articlePage);
		}
	},

	_authCloseAuthoring: function(articlePage) {
		var self = this;
		var _end = function() {
			self.undoPageHistory = {};
			notifications.publish(["sm.auth.history.change"], []);
			self.disable();
			authHelpers.triggerResizeInternal();
		};
		if (self.isDirty === true) {
			modal.simpleConfirmPromise({
					message: locale.text("auth.msg.close")
				})
				.then(function(result) {
					if (result.action === "yes") {
						_end();
					}
				});
		} else {
			_end();
		}
	},

	/**
	 * When we change orientation, device, scale
	 * type = orientation, device, scale
	 */
	notifAuthDisplayChanged: function(type) {
		// We need to remove current selection
		// Indeed, sometimes authoring depends on the type of device or orientation
		// We remove the current selection in order to recreate it on click with new context
		// Ex: query filters are forced to tabs' for smartphone so we must not display property 'Filters' for $resources if device= smartphone
		this.leftPanel.setSelection(null);
	},

	notifAuthSave: function() {
		var self = this;
		var page = authCommons.getCurrentPage();
		if (page && page.isCardDetail()) {
			self._saveCardDesign();
			return;
		}

		var article = authCommons.getCurrentPage().getArticle();
		var articleParsed = authVal.validateJSON(true, article, authProps.getAllProperties());
		if (!articleParsed) {
			return;
		}
		var propertiesVariantSelected = authHelpers.getPropertiesCurrentVariant(page);
		var comment = articleParsed && articleParsed.$comment;
		var context = {
			code: propertiesVariantSelected.code || locale.text("auth.panel.authCodeDefault"),
			title: propertiesVariantSelected.title || locale.text("auth.panel.authTitleDefault"),
			description: propertiesVariantSelected.description || locale.text("auth.panel.authDescriptionDefault"),
			isFactory: propertiesVariantSelected.isFactory,
			isGlobal: propertiesVariantSelected.isGlobal,
			isPersonal: propertiesVariantSelected.isPersonal,
			factoryOwner: propertiesVariantSelected.factoryOwner,
			securityProfile: authCommons.getSecurityProfile(),
			uuid: propertiesVariantSelected.uuid,
			comment: propertiesVariantSelected.comment || comment,
			variants: authHelpers.getPropertiesVariants(page),
		};
		context.pageName = self.currentPageName;
		var modal = new modalSaveAuth.Modal(context);
		var canceled = false;
		var modalCtx;
		modal.show()
			.then(function(ctx) {
				modalCtx = ctx;
				canceled = modalCtx == null;
				if (canceled) return;
				articleParsed.$comment = ctx.comment;
				var params = {
					code: ctx.code,
					title: ctx.title,
					description: ctx.description,
					variantType: ctx.variantType,
					uuid: ctx.uuid,
					article: articleParsed
				};
				params.article = utils.sanitizeArticle(params.article);
				return authHelpers.saveAuthoring(page, params);
			}).then(function() {
				if (canceled) return;
				if (!modalCtx.uuid) { //refresh right panel because of new view
					self.rightPanel.notifAuthSetSelection();
				}
				self.isDirty = false;
			}).then(function() {
				if (canceled) return;
				modules.get("modal").info(locale.text("auth.panel.save_ok_title"), locale.text("auth.panel.save_ok_text"));
			}).fail(function(e) {
				modules.get("modal").error(locale.text("auth.panel.save_error_title"), e);
			});
	},
	notifAuthNewLayout: function(type, template) {
		var page = authCommons.getCurrentPage();
		authoringArticleGen.genNewArticle({
				page: page,
				orientation: type,
				template: template
			})
			.then(function(article) {
				var articleJSON = authVal.toSortedJSON(article);
				notifications.publish(["sm.auth.change.prop.ui"], articleJSON);
			})
			.fail(function(e) {
				modal.error(e);
			});
	},
	notifAuthUndo: function(all) {
		var self = this;
		var article;
		if (all) {
			article = self.undoPageHistory[self.currentPageName].articles.shift();
			self.undoPageHistory[self.currentPageName].articles = [];
		} else {
			article = self.undoPageHistory[self.currentPageName].articles.pop();
		}

		notifications.publish(["sm.auth.history.change"], self.undoPageHistory[self.currentPageName].articles);
		notifications.publishEx(["sm.auth.change.prop.ui"], {
			exclude: [self]
		}, article);

		self._updateLayoutPage(article);
	},
	notifAuthOpenCardDesign: function() {
		this._openCardDesign();
	},
	/**
	 * vignetteToUpdt!=null means just reload this vignette  - see pageDashboard.authUpdateLayout
	 */
	_updateLayoutPage: function(articlePage, states, vignetteToUpdt) {
		var self = this;
		var page = authCommons.getCurrentPage();
		try {
			var articleParsed = JSON.parse(articlePage);
		} catch (e) {
			// Never end up here because validated before
		}
		if (!articleParsed) {
			return;
		}

		var path = self._findSelectionPath();

		authHelpers.savePanelStates();

		// Copy of article before we start changing it once again
		self.displayedArticle = articlePage;
		self.authPage.disableAuthCss();
		page.authUpdateLayout(articleParsed, vignetteToUpdt)
			.then(function() {
				self.authPage.enableAuthCss();
				if (states) {
					self._applyPreviousStates(states);
				}
				self._selectByPath(path);
			}).fail(function(e) {
				modules.get("modal").error(e);
			});

	},
	_applyPreviousStates: function(states) {
		var self = this;
		var page = authCommons.getCurrentPage();
		for (var statePath in states) {
			statePath = statePath.length > 0 ? statePath.split(".") : [];
			var node = page.rootLayout.findChildByPath(statePath);
			if (node) {
				node.setAuthState(states[statePath]);
			}
		}
	},
	/**
	 * returns $$currentpage$$ if root page elmt is selected
	 */
	_findSelectionPath: function() {
		var id = this.authPage.getCurrentSelectionId();
		if (id === authCommons.getCurrentPage().id) {
			return "$$currentpage$$";
		}
		var sel = id && authHelpers.getSelectionById(id);
		var data = sel && authHelpers.getSelectionData(sel);
		if (!data || !data.control) {
			return null;
		}
		var path = data.control.getPathInTree();
		return path;
	},

	_selectByPath: function(path) {
		var page = authCommons.getCurrentPage();
		if (!path || !page) {
			return;
		}
		if (path === "$$currentpage$$") {
			path = page.id;
		} else {
			var node = page.rootLayout.findChildByPath(path);
			path = node ? node.id : null;
		}
		if (path) {
			notifications.publishEx(["sm.auth.set.selection"], {
				exclude: [this]
			}, path);
		}
	},
	_isArticleChange: function(articleBefore) {
		//Be careful : article is a string of json 
		//			   Only for carddesign and chartdetail
		var article = JSON.stringify(authCommons.getCurrentPage().getArticle());
		return (articleBefore !== article);
	},

	_openCardDesign: function() {
		var id = this.authPage.getCurrentSelectionId();
		var sel = id && authHelpers.getSelectionById(id);
		var data = sel && authHelpers.getSelectionData(sel);
		if (!data || !data.control || !data.control.getCardDetailPageData) {
			return null;
		}

		var page = data.control.page || authCommons.getCurrentPage();
		modules.get("navHelper").gotoUrl("child://SdataCardDetail", null, {
			isChild: true,
			childContext: {
				controllerId: page.controller.id,
				arrayControlId: data.control.id,
				cardDetailPageData: data.control.getCardDetailPageData()
			}
		});
	},

	_closeCardDesign: function() {
		this._goBack();
	},
	_saveCardDesign: function() {
		var self = this;
		var page = authCommons.getCurrentPage();

		var cardArticle = page.getCardArticle();
		var arrayControl = page.getCardArrayControl();

		self._goBack()
			.then(function() {
				page = authCommons.getCurrentPage();

				// Inject article of card detail page into array control
				if (arrayControl) {
					arrayControl.setCardDetailArticle(cardArticle);
				}
				notifications.publish(["sm.auth.change.item.prop.ui"]);
			});
	},
	_goBack: function() {
		var navStack = modules.get("navStack").getMainStack();
		if (navStack) {
			return navStack.goBack();
		}
		return $.smResolve();
	}
});

function _mergeViews(page, views) {
	var pviews = page.pageData.page.$views = page.pageData.page.$views || [];
	views.forEach(function(view) {
		// View not yet know by client so add it but it also cannot be selected
		view.$selected = false;

		pviews.some(function(pview) {
			var match = pview.$url === view.$url;
			if (match) {
				view.$selected = pview.$selected;
			}
			return match;
		});
	})
	page.pageData.page.$views = views;
}
});

define('syracuse-tablet/html/js/app/appController',['require','exports','module','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/common/ajax','syracuse-tablet/html/js/ui/siteLayout','syracuse-tablet/html/js/utils/waiting','syracuse-tablet/html/js/app/globals','syracuse-tablet/html/js/app/eventListener','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/sharedContext','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/ui/modals/modalSettings','syracuse-tablet/html/js/ui/modals/modalSelectContext','syracuse-tablet/html/js/ui/modals/modalShowLegal','syracuse-tablet/html/js/helpers/developmentPage','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/environment','syracuse-tablet/html/js/app/settings','syracuse-tablet/html/js/sdata/cache/metaDataCache','syracuse-tablet/html/js/authoring/authoring'],function (require, exports, module) {

var locale = require('syracuse-tablet/html/js/helpers/locale');
var ajax = require('syracuse-tablet/html/js/common/ajax');
var siteLayout = require('syracuse-tablet/html/js/ui/siteLayout');
var waiting = require('syracuse-tablet/html/js/utils/waiting');
var globals = require('syracuse-tablet/html/js/app/globals');
var eventListener = require('syracuse-tablet/html/js/app/eventListener');
var modules = require('syracuse-tablet/html/js/common/modules');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var sharedContext = require('syracuse-tablet/html/js/helpers/sharedContext');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("appController", false);

var modalSettings = require('syracuse-tablet/html/js/ui/modals/modalSettings');
var modalSelectContext = require('syracuse-tablet/html/js/ui/modals/modalSelectContext');
var modalShowLegal = require('syracuse-tablet/html/js/ui/modals/modalShowLegal');

var developmentPage = require('syracuse-tablet/html/js/helpers/developmentPage');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var environment = require('syracuse-tablet/html/js/helpers/environment');
var settings = require('syracuse-tablet/html/js/app/settings');
var metaDataCache = require('syracuse-tablet/html/js/sdata/cache/metaDataCache');

var authoring = require('syracuse-tablet/html/js/authoring/authoring');

var _appClass = utils.defineClass(
	function App() {
		this.$$elmt = $("#s-m-app-id");

		// Set some defaults, note these will be overridden as soon as login is done
		// no matter if login is online or offline
		this._cacheContext = {
			"$user": "none",
			"$role": "none",
			"$lang": "none"
		};
		this._defaultEndpoint = "x3.erp.GX3APP";
		this._currentUserProfile = null;
		notifications.subscribe(this, ["sm.main.layout.changed"]);
	},
	null, {
		init: function() {
			eventListener.registerEvents(this.$$elmt);
			// Must be called after event listener is set up
			$(window).triggerHandler("resizeInternal");
		},
		notifMainLayoutChanged: function(info, orientation, deviceType) {
			this.$$elmt.width(info.application.width);
			this.$$elmt.height(info.application.height);
			var navStack = modules.get("navStack").getMainStack();
			var currentPage = navStack && navStack.getTopPage();
			if (currentPage) {
				currentPage.onMainPageResize(info, orientation, deviceType);
				if (info.afterMainPageLoaded === true && environment.isAutoUITestMode()) {
					environment.getUnitTestMgr().notifPageLoaded("after", currentPage);
				}
			}
			/**
			 * TODO DRAFTS
			 * if (info.deviceChanged) {
			 * // Like we change the device we rebuilt the header and must refresh darft count
			 * self.triggerUpdtDraftsCount();
			 * }
			 */
		},

		/**
		 * Called whenever the current user profile changes
		 * This can be:
		 * Login of a new user
		 * Role, endpoint, locale changes 
		 */
		setUserProfile: function(userProfile) {
			var self = this;
			var initialProfile = false;
			if (!this._currentUserProfile) { // First call after login
				this._currentUserProfile = $.extend(true, {}, userProfile);
				initialProfile = true;
			}
			return $.smResolve()
				.then(function() {

					// If locale changes or the user profile is set for the first time, ensure the language texts are reloaded
					if (self._currentUserProfile.selectedLocale.code !== userProfile.selectedLocale.code || initialProfile === true) {
						// Update locale prefs
						return locale.setLocaleByUserProfile(userProfile);
					}
				})
				.then(function() {
					self._cacheContext = {
						"$user": userProfile.user.login,
						"$role": userProfile.selectedRole.code,
						"$lang": userProfile.selectedLocale.code
					};
					self._defaultEndpoint = userProfile.selectedEndpoint.application + "." + userProfile.selectedEndpoint.contract + "." + userProfile.selectedEndpoint.dataset;
					if (environment.isAutoUITestMode()) {
						environment.getUnitTestMgr().notifUserCtxChanged(self._cacheContext, self._defaultEndpoint);
					}
				})
				.then(function() {
					if (!initialProfile) { // Clone if we did not do this at the very beginning
						self._currentUserProfile = $.extend(true, {}, userProfile);
					}
				})
				.then(function() {
					return metaDataCache.clearCachedApps();
				});
		},
		getCurrentUserProfile: function() {
			return this._currentUserProfile;
		},
		getCurrentEndpoint: function() {
			return this._currentUserProfile.selectedEndpoint ? this._currentUserProfile.selectedEndpoint.code : ""
		},
		/**
		 * Return the context used to read and write sdata specific cache items
		 * 
		 * {
		 * 	 "$user": "mawal",
		 *	 "$role": "ADMIN",
		 *	 "$lang": "en-US"
		 * }
		 */
		getCacheContext: function() {
			return this._cacheContext;
		},
		/**
		 * The default endpoint is used to load applications on the welcome page
		 *
		 * returns: x3.erp.GX3APP
		 */
		getDefaultEndpoint: function() {
			return this._defaultEndpoint;
		},

		goBack: function() {
			var navStack = modules.get("navStack").getMainStack();
			if (navStack) {
				var changedToBusy = navStack.setBusy(true);
				if (!changedToBusy) {
					return;
				}
				navStack.goBack()
					.always(function() {
						if (changedToBusy) { // Only set to idle if we set no busy by or self
							navStack.setBusy(false);
						}
					})
					.fail(function(error) {
						modules.get("modal").error(error);
					});
			}
		},
		canGoBack: function() {
			var navStack = modules.get("navStack").getMainStack();
			if (navStack) {
				return navStack.canGoBack();
			}
			return false;
		},

		/**
		 * Called by back button in header
		 */
		_actHistoryBack: function() {
			if (globals.isAuthoringActive()) {
				return;
			}
			this.goBack();
		},
		/**
		 * Called by event listener whenever the back button if the browser is used
		 */
		onBrowserBackButton: function(event) {
			if (event) {
				event.preventDefault();
			}
			if (globals.isAuthoringActive()) {
				return;
			}
			this.goBack();
		},
		_actSwitchContext: function() {
			var self = this;
			_selectNewContext()
				.fail(function(result) {
					modules.get("modal").error(result);
				})
				.then(function(userProfile) {
					if (userProfile) { // User profile has changed
						return self.setUserProfile(userProfile)
							.then(function() {
								modules.get("modal").notify({
									body: locale.text("switchContext.success"),
									severityClass: "success"
								});
							})
							.then(function() {
								return self.initApplicationsList();
							})
							.then(function() {
								self.gotoHomePage();
							});
					} else {
						// We did not do a change
						// Nothing to do here!
					}
				});
		},
		_actLogout: function() {
			var self = this;
			_logout()
				.then(function(result) {
					var msg;
					if (result == "loggedout") {
						// User has logged out
						msg = {
							body: locale.text("logout.msg"),
							severityClass: "success"
						};
					} else if (result === "offline") {
						msg = {
							body: locale.text("logout.offline.msg"),
							severityClass: "warning"
						};
					}
					modules.get("modal").notify(msg);
					self.gotoLogoutPage();
				})
				.fail(function(result) {
					modules.get("modal").error(result);
				});
		},
		_actSettings: function() {
			var self = this;
			//Don't understand how device-type settings is needed
			return settings.getDeviceType()
				.then(function(deviceType) {
					var modal = new modalSettings.Modal({
						"device-type": deviceType
					});
					return modal.show();
				})
				.then(function(result) {
					if (result && result["device-type"]) {
						return settings.setDeviceType(result["device-type"]);
					}
				});
		},
		_actAbout: function() {
			var modal = new modalShowLegal.Modal();
			modal.show();
		},
		_actDevelopmentPage: function() {
			developmentPage.show();
		},
		_actHome: function() {
			this.gotoHomePage();
		},
		gotoHomePage: function() {
			return modules.get("navHelper").gotoUrl("html://home");
		},
		gotoLoginPage: function() {
			return modules.get("navHelper").gotoUrl("html://login");
		},
		gotoLogoutPage: function() {
			return modules.get("navHelper").gotoUrl("html://logout");
		},

		/** 
		 * Called whenever an modal is opened
		 */
		onModalOpened: function() {},
		/**
		 * Called whenever a modal is closed
		 */
		onModalClosed: function() {},

		getMessageSlot: function() {
			if (!this._$$actMsgSlot) {
				this._$$actMsgSlot = {};
			}
			var deviceType = siteLayout.getDeviceType();
			var orientation = siteLayout.getPageOrientation();
			var key = deviceType + orientation;
			if (this._$$actMsgSlot[key]) {
				return this._$$actMsgSlot[key];
			}
			var $$slot = this._$$actMsgSlot[key] = $("<div>").addClass("s-m-act-msg-slot").addClass(deviceType).addClass(orientation);
			this.$$elmt.prepend($$slot);
			return $$slot;
		},

		// Authoring
		_actDesignPage: function() {
			authoring.toggleDesignPage();
		},

		nativeApplicationActivated: function() {
			log && log("nativeApplicationActivated");
			var navStack = modules.get("navStack").getMainStack();
			var currentPage = navStack && navStack.getTopPage();
			var isLoginPage = jsutils.isInstanceOf(currentPage, "PageLogin");
			if (isLoginPage) {
				log && log("is login page -> reload");
				window.location.reload();
			}
		},
		// Return string that describs current app status for restoration later
		nativeApplicationClosing: function() {
			log && log("nativeApplicationClosing");
			var page = this.findTopmostNonChild();
			if (page) {
				var context = sharedContext.createContextFromPage(page);
				return JSON.stringify(context);
			}
			return "";
		},
		findTopmostNonChild: function() {
			var navStack = modules.get("navStack").getMainStack();
			if (navStack) {
				return navStack.filterTopPage(function(page) {
					return !(page.options && page.options.isChild);
				});
			}
		},
		initApplicationsList: function() {
			return metaDataCache.initApplicationsList()
		},

		_actPageMailto: function() {
			var navStack = modules.get("navStack").getMainStack();
			var currentPage = navStack && navStack.getTopPage();
			if (currentPage) {
				sharedContext.sendPageByEmail(currentPage)
					.fail(function(error) {
						modules.get("modal").error(error);
					});
			}
		}
	}
);
exports.App = new _appClass();

/**
 * Select user, role, endpoint
 * Returns:
 * User profile on successful context change
 * null if there was no change done (no change selected by user or cancelled)
 * null if logout was choosen
 * @returns
 */
function _selectNewContext() {
	var up = exports.App.getCurrentUserProfile();
	var currentContext = {
		endpoint: up.selectedEndpoint.code,
		role: up.selectedRole.code,
		lang: up.selectedLocale.code
	};

	var settings = {};
	var fetchSettings = $.Deferred();

	ajax.request("/sdata/syracuse/collaboration/syracuse/userProfiles/$service/settings")
		.then(function(result) {
			settings.profile = result.data;
			settings.offline = false;
			fetchSettings.resolve();
		})
		.fail(function(result) {
			if (result.offline) {
				settings.profile = {};
				settings.offline = true;
				fetchSettings.resolve();
			} else {
				fetchSettings.reject(result);
			}
		});

	return waiting.waitModal(fetchSettings)
		.then(function() {
			var modal = new modalSelectContext.Modal(currentContext, settings);
			return modal.show();
		})
		.then(function(result) {
			if (result.action === "cancel") {
				// do nothing
			} else if (result.action === "ok") {
				var session = modules.get("session");
				return waiting.waitModal(session.applyNewContext(settings.profile, up, result.endpoint, result.role, result.language));
			}
		});
}

function _logout() {
	var d = $.Deferred();

	var session = modules.get("session");
	waiting.waitModal(session.logout())
		.then(function() {
			d.resolve("loggedout");
		})
		.fail(function(result) {
			if (result.offline) { // Logging out when offline does not work and also makes no sence
				d.resolve("offline");
			}
			d.reject(result);
		});
	return d;
}
});

define('syracuse-tablet/html/js/controls/array/builderCard',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/array/builderBase','syracuse-tablet/html/js/app/appController','syracuse-tablet/html/js/helpers/fieldOperators','syracuse-tablet/html/js/helpers/environment','syracuse-tablet/html/js/authoring/authoringArticleGen'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/array/builderBase').BuilderBase;
var App = require('syracuse-tablet/html/js/app/appController').App;
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');
var environment = require('syracuse-tablet/html/js/helpers/environment');
var authoringArticleGen = require('syracuse-tablet/html/js/authoring/authoringArticleGen');

exports.BuilderCard = utils.defineClass(
	function builderCard(control) {
		Base.call(this, control);
		this.direction = this.control.isArrayField() ? "h" : "v";
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			this._tds = null;
			if (this._$$body) {
				this._$$body.remove();
				this.destroyScroller();
			}
			this._$$body = null;
		},

		buildHtml: function(data, $$container, refresh) {
			this.article.$minWidth = this.article.$minWidth || 6;
			Base.prototype.buildHtml.call(this, data, $$container, refresh);
			this._cardArticle = this._createCardArticle();
			this._statusInfo = this.control.getRowStatusInfo();
			if (refresh === true) {
				// Build the real content only in that case because parent's size is ok
				// Otherwise buildOnResize is called on computeLayout
				this.buildOnResize(data, $$container, {
					refresh: true
				});
			}
		},

		buildOnResize: function(data, $$container, context) {
			if (this.destroyed) {
				return;
			}
			if (!this.checkEmptyArray()) {
				return;
			}
			this.buildCards(data, $$container, context);
		},

		buildCards: function(data, $$container, context) {
			var context = context || {};
			var refresh = context.refresh == true;
			if (!this._$$body) {
				this.destroyScroller();
				this._$$table = $('<table/>').appendTo($$container)
				this._$$body = $('<tbody>').appendTo(this._$$table);
				this._tds = [];
				var self = this;
				data.forEach(function(rowData, idx) {
					self._tds.push({
						"$$td": $('<td class="s-m-record"/>'),
						rowData: rowData
					});
				});
			}
			var sz = this.control.getAvailableSizeForCards();
			var parentH = sz.height;
			var parentW = sz.width;
			// Border spacing used for calculation
			var bs = this._$$body.parent().css("border-spacing");
			if (bs) {
				bs = bs.split("px");
				bs = bs && bs.length > 0 ? parseInt(bs[0], 10) : 0;
			}
			var $$hiddenRow;
			var visibleTds = [];
			// We keep the $$td's to not recreate them and arrange according the new configuration
			// We first detach them and select the visible ones (used by multiselection)
			// We put non-visible ones in $$hiddenRow to let them available in the dom (used by multiselection)
			this._tds.forEach(function(o, idx) {
				if (o.$$card) {
					// Clear the height/width because they are calculated according to the device/parent size
					o.$$card.css({
						height: "",
						width: ""
					});
				}
				o.$$td.detach();
				if (o.$$td.css('display') != "none") {
					visibleTds.push(o);
				} else {
					if (!$$hiddenRow) {
						$$hiddenRow = $("<tr>").hide();
					}
					o.$$td.appendTo($$hiddenRow);
				}
			});
			// !! Call $$body after having detached $$td because empty() removes the data attached to the node ($.smData) used by multi-selection (diagnoses)
			this._$$body.empty();
			if ($$hiddenRow) {
				$$hiddenRow.appendTo(this._$$body);
			}
			if (visibleTds.length === 0) return;
			if (this.direction === "h") {
				this.buildCardH(visibleTds, bs, parentH, parentW);
			} else {
				this.buildCardV(visibleTds, bs, parentW);
			}
			// Center the table in the parent - only if fixed height
			this._centerCardInParent(parentH);
			this.initScroller($$container);
			this.doAfterBuild();
		},
		_centerCardInParent: function(parentH) {
			// Center the table in the parent - only if fixed height
			if (!this.control.isArrayField() && !this.control.page.isNestedInDashboard("stack")) {
				var top = Math.max(0, (parentH - this._$$body.parent().outerHeight()) / 2);
				this._$$body.parent().css({
					top: top + "px"
				});
			}
		},
		initScroller: function($$container) {
			if (this.direction === "h" || (this.direction === "v" && !this.control.page.isNestedInDashboard("stack"))) {
				this.newScroller(this.direction, this._$$body.parent());
			}
		},
		buildCardV: function(visibleTds, bs, parentW) {
			var scale = this.control.getTransformScale();
			var cardW;
			var remaining = 0;
			var nbCardPerRow = isNaN(this.article.$cardsPerRow) ? 2 : (parseInt(this.article.$cardsPerRow, 10) || 2);
			var $$row = null;
			var self = this;
			visibleTds.some(function(o, idx) {
				if ($$row == null || nbCardPerRow == 1 || (nbCardPerRow > 1 && idx % nbCardPerRow === 0)) {
					$$row = $("<tr>").appendTo(self._$$body);
					remaining = nbCardPerRow;
				}
				remaining--;
				o.$$td.appendTo($$row);
				if (!o.$$card) {
					// !! We create the card here because we need to have the $$card attached to the dom to calculate children width/row... eg: cards inside card
					// If we crate the card at the same time as $$td the generation of html is wrong
					o.$$card = self.createCardContent(o.$$td, idx, o.rowData);
				}
				if (idx === 0) {
					// We have to substract the padding of the card to set the right width
					var padding = (o.$$card.outerWidth() - o.$$card.width());
					// Width of the row minus the borderSpacings
					var availWidth = o.$$td.width() / scale;
					var minWidth = Math.min(availWidth - padding, self.authMinSize2Pixels(self.article.$minWidth));
					while (nbCardPerRow > 0) {
						cardW = Math.round(((availWidth - ((nbCardPerRow - 1) * bs)) / nbCardPerRow)) - padding;
						if (cardW >= minWidth) {
							// nbCardPerRow is ok 
							availWidth = cardW
							break;
						}
						// Width is to small -> We decrease nbCardPerRow
						nbCardPerRow--;
					}
					nbCardPerRow = Math.max(nbCardPerRow, 1);
				}
				o.$$card.width(cardW);
			});
			var $emptycell = this.article.$emptycell || "nodisplay";
			if (remaining && this._cardArticle.$emptyCell !== "nodisplay") {
				this.addEmptyCells(this._layoutRoot, $$row, remaining, visibleTds.length);
			}
			if (this.article.$arrayOptions.hideEmptyRows === true) {
				this.checkEmptyRows();
			}
		},
		buildCardH: function(visibleTds, bs, parentH, parentW) {
			var scale = this.control.getTransformScale();
			var cardW;
			var nbCardPerRow = isNaN(this.article.$cardsPerRow) ? 2 : (parseInt(this.article.$cardsPerRow, 10) || 2)
			var remaining = 0;
			var maxHeight = 0;
			var heightChanged;
			var $$row = null;
			var self = this;
			visibleTds.some(function(o, idx) {
				if (!$$row || nbCardPerRow == 1 || (nbCardPerRow > 1 && idx % nbCardPerRow === 0)) {
					$$row = $("<tr>").appendTo(self._$$body);
					remaining = nbCardPerRow;
				}
				o.$$td.appendTo($$row);
				if (!o.$$card) {
					o.$$card = self.createCardContent(o.$$td, idx, o.rowData);
				}
				if (idx === 0) {
					var realH = (o.$$td.height() / scale) + bs;
					parentW = parentW - ((nbVisiblecardsPerRow + 1) * bs);
					var padding = o.$$card.outerWidth() - o.$$card.width();
					// Width of the row minus the borderSpacings
					var availWidth = o.$$td.width() / scale;
					var minWidth = Math.min(availWidth - padding, self.authMinSize2Pixels(self.article.$minWidth));
					var nbVisiblecardsPerRow = nbCardPerRow;
					while (nbVisiblecardsPerRow > 0) {
						cardW = Math.round(((availWidth - ((nbVisiblecardsPerRow - 1) * bs)) / nbVisiblecardsPerRow)) - padding;
						if (cardW >= minWidth) {
							// nbCardPerRow is ok 
							availWidth = cardW
							break;
						}
						// Width is to small -> We decrease nbCardPerRow
						nbVisiblecardsPerRow--;
					}
					nbVisiblecardsPerRow = Math.max(nbVisiblecardsPerRow, 1);
					if (true || self.control.isArrayField() || (visibleTds.length * cardW < parentW)) {
						// Force to display all the cells on one line because there's enough room
						nbCardPerRow = visibleTds.length;
					} else {
						// Calculate the number of rows to fit the parent height
						var numberOfRows = Math.max(1, Math.floor((parentH - bs) / realH));
						nbCardPerRow = Math.ceil(visibleTds.length / numberOfRows);
						if (visibleTds.length <= numberOfRows * nbVisiblecardsPerRow) {
							// Dispatch the cards by filling the lines from the top to bottom
							nbCardPerRow = nbVisiblecardsPerRow;
						}
					}
					remaining = nbCardPerRow;
				}
				o.$$card.width(cardW);
				var cardH = o.$$card.height() / scale;
				if (maxHeight === 0) {
					maxHeight = cardH;
				} else if (maxHeight != cardH) {
					heightChanged = true;
					maxHeight = Math.max(maxHeight, cardH);
				}
				remaining--;
			});
			if (heightChanged === true) {
				// Set the same height for cards (could occurs if there are arrays in cards)
				visibleTds.forEach(function(o) {
					o.$$card.height(maxHeight);
				});
			}
			var $emptycell = this.article.$emptycell || "nodisplay";
			if (remaining > 0 && $emptycell !== "nodisplay") {
				var $$emptyCells = this.addEmptyCells(this._layoutRoot, $$row, remaining);
				if ($$emptyCells && heightChanged) {
					$$emptyCells.height(maxHeight);
				}
			}
			if (this.article.$arrayOptions.hideEmptyRows === true) {
				this.checkEmptyRows();
			}
		},
		createCardContent: function($$container, index, rowData) {
			var $$card = $('<section class="s-m-card"/>').appendTo($$container).attr("data-idx", index);
			$('<span class="badge checked fa fa-check">&nbsp;</span>').appendTo($$card);
			if (this.article.$arrayOptions.rowIndex === true && index != null) {
				$('<span class="badge index">' + (index + 1) + '</span>').appendTo($$card);
			}
			if (this._statusInfo) {
				this.checkStatusManagement($$card, this._statusInfo, $$card, rowData);
			}
			var cardCtrl = this.control.createRecordCtrl($$card, rowData, index, {
				cardArticle: this._cardArticle
			});
			if (cardCtrl) {
				cardCtrl.buildHtml(this._tableColumnInfo);
				if (environment.isAutoUITestMode()) {
					environment.getUnitTestMgr().arrayAddRowIndex(cardCtrl.$$elmt, index);
				}
			}
			return $$card;
		},
		checkStatusManagement: function($$parent, statusInfo, $$cell, rowData) {
			if (!statusInfo) return;
			var $$rootIcon = $$cell.find(".s-m-status");
			if ($$rootIcon.length === 0) {
				$$rootIcon = $('<div class="s-m-status"/>').appendTo($$cell);
			}
			var nbBckg = 0;
			statusInfo.list.some(function(s) {
				if (s.color && fieldOperators.evaluateOperator(s.$type, rowData.getValue(s.field), s.operator, s.value)) {
					/**
					 * We need to set color and bg-color because using css property doesn't work due to css inheritance
					 * Using css forces to declare all css selectors (td:not(.s-m-multi-selected)...) for each color of the palette
					 */
					if (s.icon) {
						$('<div class="s-m-status-icon ' + s.icon.css + '" style="color:' + s.color.bgColor + '"/>').appendTo($$rootIcon);
						return statusInfo.type === "mono";
					} else if (s.color.css && nbBckg === 0) {
						$$parent.addClass('s-m-status-color ' + s.color.css);
						nbBckg++;
					}
					return statusInfo.type === "mono";
				}
			});
		},
		authMinSize2Pixels: function(val) {
			var max = 700,
				min = 100;
			val = parseInt(val, 10);
			if (val == null || isNaN(val)) return 200;
			if (val > 20) return max;
			if (val < 1) return min;
			return min + (val * (max - min) / 20);
		},
		_createCardArticle: function() {
			var cardArticle = this.article.$card;
			if (!cardArticle) {
				cardArticle = authoringArticleGen.genCardArticle(this.control.prototype);
			};
			return cardArticle;
		},
		getLastSelectedRowId: function() {
			return this.control.$$content.find(".s-m-last-selected > .s-m-card > .s-m-ctrl").attr("id");
		},
		setLastSelectedRowId: function(selectedRowUuid) {
			this.control.$$content.find('#' + selectedRowUuid).closest("td").addClass("s-m-last-selected");
		},
		/**
		 * Add nb empty cells
		 * this.article.$emptycell:
		 * -> "empty" no card is added
		 * -> "withtitle" add empty cards with fields titles displayed
		 * -> "filled" add an empty card
		 */
		addEmptyCells: function(rootLayout, $$parent, nb, startIdx) {
			if (nb < 1) return null;
			// dispEmpty: withtitle, filled, empty
			var dispEmpty = this.article.$emptycell;
			if (dispEmpty === "withtitle" || dispEmpty === "filled") {
				for (var i = 0; i < nb; i++) {
					this.createCardContent($('<td class="s-m-record s-m-empty s-m-' + dispEmpty + ' nohover">').appendTo($$parent), startIdx + i);
				}
				return $$parent.find("td.s-m-empty");
			} else {
				return null;
			}
		},
		/**
		 * Like the rows are not stored as controls (html generated) we get the $$row and apply the rocess to detect empty row
		 * Same process for the row layout
		 */
		checkEmptyRows: function() {
			if (!this._$$body) return;
			if (!this._$$rows) {
				this._$$rows = this._$$body.find(".s-m-row");
			}
			this._$$rows.each(function() {
				_checkEmptyRow($(this));
			});
		},
		updateRowIndex: function($$parent, index) {
			$$parent.find(".badge.index").text(index);
		}

	});


/**
 * Detects empty rows and hide them with the class .s-m-empty.s-m-fullwidth
 * An empty cell (s-m-empty) is hidden if the cell is full width
 * 		takes the full width of the row - depends on bootstrap grid classes)
 * If all non full width cells (emptyNotfw) are empty
 * 		eg; 2 empty cells with width=50% (6/12  of the row) + another one with width=100% (12/12  of the row)
 * A row is hidden if
 * 		All the cells are empty (s-m-empty)
 *
 */
function _checkEmptyRow($$row) {
	if (!$$row) return;
	var fullCellMinWidth = $$row.width();
	fullCellMinWidth = fullCellMinWidth - fullCellMinWidth / 12;
	var emptyNotfw = [];
	$$row.children().each(function() {
		var $$cell = $(this);
		if ($$cell.width() > fullCellMinWidth) {
			$$cell.addClass("s-m-fullwidth");
		} else {
			$$cell.removeClass("s-m-fullwidth");
			if (emptyNotfw && $$cell.is(".s-m-empty")) {
				emptyNotfw.push($$cell);
			} else {
				// Breaks the process on first non empty cell
				emptyNotfw = null;
			}
		}
	});
	if (emptyNotfw) {
		// Hide all these cells
		emptyNotfw.forEach(function($$cell) {
			$$cell.addClass("s-m-fullwidth");
		});
	}
}
});

define('syracuse-tablet/html/js/controls/array/builderCarousel',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/controls/array/builderCard','syracuse-tablet/html/js/helpers/scroller/hammerScroller','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsUtils = require('syracuse-tablet/html/js/helpers/jsutils');
var Base = require('syracuse-tablet/html/js/controls/array/builderCard').BuilderCard;
var hammerScroller = require('syracuse-tablet/html/js/helpers/scroller/hammerScroller');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _templates = {
	footer: '<footer>\
				<ul class="s-m-carousel-indicators">\
					<span class="first active"></span>\
					{{#if middle}}\
						<span class="middle"></span>\
					{{/if}}\
					{{#if last}}\
						<span class="last"></span>\
					{{/if}}\
				</ul>\
				<span class="left carousel-control {{leftIcon}}"></span>\
				<span class="right carousel-control {{rightIcon}}"></span>\
			</footer>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

exports.BuilderCarousel = utils.defineClass(
	function builderCarousel(control) {
		Base.call(this, control);
		this.direction = "h";
		this._curIdx = 0;
		this._hammer = null;
		this._nbCards = 0;
		this._interval = null;
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			this._destroySwiper();
			this.$$container = null;
			if (this._$$footer) {
				this._$$footer.off()
				this._$$footer.remove();
			}
		},

		buildHtml: function(data, $$container, refresh) {
			this._nbCards = data.length;
			this.$$container = $$container;
			Base.prototype.buildHtml.call(this, data, $$container, refresh);

		},
		buildCardH: function(visibleTds, bs, parentH, parentW) {
			Base.prototype.buildCardH.call(this, visibleTds, bs, parentH, parentW);
			if (this._nbCards == 0) {
				return;
			}
			this._shiftInPx = (this._$$table.find("tbody > tr > td").width() / this.control.getTransformScale()) + bs;

			if (!this._$$footer) {
				this._$$footer = this.$$container.append(_getHtml("footer", {
					middle: true,
					last: true,
					leftIcon: fontUtils.getCarouselIcon("left"),
					rightIcon: fontUtils.getCarouselIcon("right")
				}));
				this._$$footer.on("click", jsUtils.bindFn(this._onClickFooter, this))
			}
			this._$$footer.toggle(this._nbCards > 0)
			if (this._nbCards > 0) {
				this._updateIndicators();
			}
			// When width changes we need to right position the card
			this._swipe("justUpdate");
		},
		_centerCardInParent: function(parentH) {
			// nothing
		},
		_updateIndicators: function() {
			this._$$footer.find(".s-m-carousel-indicators > .first").toggleClass("active", this._curIdx === 0);
			this._$$footer.find(".s-m-carousel-indicators > .middle").toggleClass("active", this._curIdx > 0 && this._curIdx < (this._nbCards - 1));
			this._$$footer.find(".s-m-carousel-indicators > .last").toggleClass("active", this._curIdx >= (this._nbCards - 1));
		},
		initScroller: function($$container) {
			this._destroySwiper();
			if (this._nbCards == 0) {
				return;
			}
			this._hammer = new hammerScroller.Hammer($$container.get(0));
			this._hammer.get("swipe").set({
				direction: hammerScroller.Hammer.DIRECTION_HORIZONTAL
			});
			this._hammer.on("swipeleft swiperight", jsUtils.bindFn(this._onSwipe, this));
			if (this._getInterval() > 0) {
				this._interval = setInterval(jsUtils.bindFn(this._onTimeout, this), this._getInterval());
			}
		},

		_onClickFooter: function(evt) {
			var $$targ = $(evt.target);
			if (!$$targ.is(".carousel-control")) {
				return;
			}
			this._swipe($$targ.is(".left") ? "swiperight" : "swipeleft");
		},

		_onTimeout: function(evt) {
			if (this.destroyed) {
				return;
			}
			this._swipe("swipeleft");
		},

		_onSwipe: function(evt) {
			if (hammerScroller.isEvtDirection(evt, "v") || !evt) {
				return;
			}
			this._swipe(evt.type);
		},

		_swipe: function(type) {
			if (this.destroyed) {
				return;
			}
			var $$current = this.control.$$elmt.find('.s-m-card[data-idx="' + this._curIdx + '"]');
			if ($$current.length == 0) {
				return;
			}

			if (type === "justUpdate") {
				// Nothing
			} else if (type === "swipeleft") {
				this._curIdx++;
				if (this._curIdx >= this._nbCards) {
					this._curIdx = 0;
				}
			} else if (type === "swiperight") {
				this._curIdx--;
				if (this._curIdx < 0) {
					this._curIdx = this._nbCards - 1;
				}
			} else {
				return;
			}
			var $$next = this.control.$$elmt.find('.s-m-card[data-idx="' + this._curIdx + '"]');
			if ($$next.length == 0) {
				return;
			}
			this._$$table.css("opacity", 0, 25);
			var self = this;
			this._$$table.animate({
				left: (-1 * this._curIdx * this._shiftInPx) + "px",
				opacity: 1
			}, 300, "swing", function() {
				self._updateIndicators();
			});
		},

		_destroySwiper: function() {
			if (this._interval) {
				clearInterval(this._interval);
				this._interval = null;
			}
			if (this._hammer) {
				this._hammer.destroy();
				this._hammer = null;
			}
		},
		_getInterval: function() {
			var period = this.article.$carouselPeriod;
			if (period === "slow") {
				return 6000;
			} else if (period === "normal") {
				return 3000;
			} else if (period === "fast") {
				return 1000;
			}
			return -1;
		}
	});
});

define('syracuse-tablet/html/js/controls/array/builderSeparator',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/array/builderBase','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/controllers/sdataController'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/array/builderBase').BuilderBase;
var modules = require('syracuse-tablet/html/js/common/modules');
var SdataController = require("syracuse-tablet/html/js/controllers/sdataController").SdataController;

var _seps = {
	semicolon: ",",
	colon: ":",
	blank: " ",
	dash: "-"
};

exports.BuilderSeparator = utils.defineClass(
	function builderSeparator(control) {
		Base.call(this, control);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
		},

		buildHtml: function(data, $$parent, refresh) {
			Base.prototype.buildHtml.call(this, data, $$parent, refresh);
			$$parent.empty();
			//this.control.arrayController.destroyChildren();
			var $$section = $('<section/>').appendTo($$parent);
			var sep = _seps[this.control.article.$separator || "blank"] || " ";
			var ctrlFactory = modules.get("ctrlFactory");
			var self = this;
			data.forEach(function(dataSet, idx) {
				if (idx > 0) {
					var $$sep = $('<span class="s-m-separator"/>').appendTo($$section).text(sep);
					if (sep === ",") {
						$$sep.css("text-align", "left");
					}
				}
				// We need to have one controller per field because the dataset is unic per field (same $bind)
				var controller = new SdataController(dataSet, self.control.arrayController);
				//self._fieldsControllers.push(controller);
				var ctrlFld = ctrlFactory.createControl(controller, {
						$bind: dataSet.parent.valueProperty
					},
					null,
					self.control.page, {
						displayCtx: "separator",
						noEdit: true
					});
				if (ctrlFld) {
					ctrlFld.set$$container($$section);
					ctrlFld.buildHtml();
				}
			});
		}

	});
});

define('syracuse-tablet/html/js/controls/chart/cubeChartsTheme',['require','exports','module'],function (require, exports, module) {

var theme = {
	//colors: ['#007f64', '#34b233', '#4d4f53', '#9a9b9c', '#ff5800', '#009fda', '#6639b7' /*green brightgreen darkgrey midgray orange blue purple*/ , '#409f8b', '#67c566', '#7a7b7e', '#b3b4b5', '#ff8240', '#40b7e3', '#8c6bc9', /*75%*/ /*'#7fbfb1','#99d899','#a6a7a9','#cccdcd','#ffab7f','#7fcfec','#b29cdb',50%*/ ],
	colors: ['#BF7070', '#BFB730', '#7ABF30', '#7373FF', '#BF7730', '#BF3080', '#30BF9F', '#FF7373', '#FFF773', '#85FF00', '#3030BF', '#FF9F40', '#FF40BC', '#1699A6', '#FF0000', '#FFF100', '#00FF00', '#0000FF', '#FF7F00', '#FF00A6', '#00FFC6', '#A60000', '#A69C00', '#56A600', '#90B2FF', '#A65200', '#A6006C', '#00A681', '#FF4040', '#FFF440', '#A3FF40', '#3673FF', '#FFB873', '#FF76CE', '#73FFED'],
	chart: {
		borderRadius: '0',
		spacingTop: 10,
		backgroundColor: '#fff',
		borderColor: '#ccc',
		borderWidth: 1,
		className: 'dark-container',
		// backgroundColor: {
		//	linearGradient: [250, 250, 250, 400],
		// 	stops: [
		// 		[0, 'rgb(250, 250, 250)'],
		// 		[1, 'rgb(240, 240, 240)']
		// 	]
		// },
		resetZoomButton: {
			theme: {
				fill: 'white',
				stroke: '#dddddd',
				r: 0,
				states: {
					hover: {
						fill: '#00a1de',
						style: {
							color: 'white'
						}
					}
				}
			},
			position: {
				// align: 'right', // by default
				// verticalAlign: 'top', // by default
				x: -50,
				y: 5
			},
			relativeTo: 'chart'
		}
	},
	title: {
		style: {
			color: '#464646',
			font: 'bold 16px "Trebuchet MS", Verdana, sans-serif'
		}
	},
	subtitle: {
		style: {
			color: '#464646',
			font: 'bold 12px "Trebuchet MS", Verdana, sans-serif'
		}
	},
	xAxis: {
		gridLineColor: 'rgba(0, 0, 0, 0.05)',
		gridLineDashStyle: 'longdash',
		gridLineWidth: 1,
		labels: {
			style: {
				color: '#A0A0A0'
			}
		},
		lineColor: 'rgba(0, 0, 0, 0.2)',
		tickColor: 'rgba(0, 0, 0, 0.2)',
		title: {
			style: {
				color: '#464646',
				fontWeight: 'bold',
				fontSize: '15px',
				fontFamily: 'arial',
			}
		}
	},
	yAxis: {
		minorGridLineColor: 'rgba(0, 0, 0, 0.05)',
		minorTickInterval: 'auto',
		/*alternateGridColor: 'rgba(0, 0, 0, 0.02)',*/
		gridLineWidth: 2,
		gridLineColor: 'rgba(0, 0, 0, 0.07)',
		labels: {
			align: 'left',
			x: 0,
			y: 12,
			style: {
				color: '#A0A0A0'
			}
		},
		lineColor: 'rgba(0, 0, 0, 0.07)',
		/*minorTickInterval: null,*/

		title: {
			style: {
				color: '#CCC',
				fontSize: '16px',
				fontFamily: 'Georgia, Verdana, sans-serif',
				fontStyle: 'italic',
			}
		}
	},
	tooltip: { /*backgroundColor: 'rgba(250,250, 250, 0.75)',*/
		backgroundColor: '#464646',
		borderRadius: '0',
		style: {
			color: '#fff',
			/*fontFamily: '"georgia"',
			fontStyle: 'italic',*/
			fontSize: '12px',
			padding: '5px',
			whiteSpace: 'nowrap',

		}
	},
	toolbar: {
		itemStyle: {
			color: 'silver'
		}
	},
	plotOptions: {
		series: {
			marker: { /*	fillColor: '#FFFFFF',*/
				lineWidth: 2,
				lineColor: null,
				// inherit from series,
				radius: 4,
				states: {
					hover: {
						radius: 8,
						lineColor: null,
					}
				}
			}
		},
		area: {
			fillOpacity: 0.15

		},
		areaspline: {
			fillOpacity: 0.15
		},
		line: {
			dataLabels: {
				color: '#CCC'
			},
			marker: {
				lineColor: '#FFFFFF',
			}
		},
		spline: {
			marker: {
				lineColor: '#FFFFFF',
			}
		},
		scatter: {
			marker: {
				lineColor: '#FFFFFF'
			}
		},
		candlestick: {
			lineColor: '#FFFFFF',
			animation: {
				duration: 2000,
				easing: 'easeOutBounce'
			}
		},
		pie: {
			allowPointSelect: true,
			cursor: 'pointer',
			borderColor: 'rgba(250,250,250,0.3)',
			borderWidth: 0.5,
			dataLabels: {
				enabled: true,
				connectorWidth: 2,
				color: '#464646',
				style: {
					fontWeight: 'bold'
				}
			},
		},

	},
	legend: {
		borderRadius: 0,
		borderWidth: 1,
		// borderColor: '#dddddd',
		backgroundColor: 'white',
		//shadow: true,
		itemMarginTop: 8,
		itemStyle: {
			color: '#464646',
			fontFamily: '"arial"',
			fontWeight: 'bold',
			/*fontStyle: 'italic',*/
			fontSize: '8pt ',
		},
		itemHoverStyle: {
			color: '#00a1de'
		},
		itemHiddenStyle: {
			color: '#555'
		},
		title: {
			style: {
				color: '#464646',
				fontWeight: 'bold',
				fontSize: '8pt',
				fontFamily: 'arial',
			}
		}
	},
	credits: {
		enabled: false,
		style: {
			color: '#666'
		}
	},
	labels: {
		style: {
			color: '#CCC'
		}
	},

	exporting: {
		buttons: {
			drillUp: {
				symbolStroke: '#fff',
				symbolFill: 'rgba(250,250,250,0.5)',
				hoverSymbolStroke: '#fff',
				hoverSymbolFill: 'rgba(250,250,250,0.5)',

			},
			exportButton: {
				symbolStroke: '#fff',
				symbolFill: 'rgba(250,250,250,0.5)',
				hoverSymbolStroke: '#fff',
				hoverSymbolFill: 'rgba(250,250,250,0.5)',

			},
			printButton: {
				symbolStroke: '#fff',
				symbolFill: 'rgba(250,250,250,0.5)',
				hoverSymbolStroke: '#fff',
				hoverSymbolFill: 'rgba(250,250,250,0.5)',
			}
		}
	},

	// scroll charts
	rangeSelector: {
		buttonTheme: {
			fill: {
				linearGradient: [0, 0, 0, 20],
				stops: [
					[0.4, '#888'],
					[0.6, '#555']
				]
			},
			stroke: '#000000',
			style: {
				color: '#CCC',
				fontWeight: 'bold'
			},
			states: {
				hover: {
					fill: {
						linearGradient: [0, 0, 0, 20],
						stops: [
							[0.4, '#BBB'],
							[0.6, '#888']
						]
					},
					stroke: '#000000',
					style: {
						color: 'white'
					}
				},
				select: {
					fill: {
						linearGradient: [0, 0, 0, 20],
						stops: [
							[0.1, '#000'],
							[0.3, '#333']
						]
					},
					stroke: '#000000',
					style: {
						color: 'yellow'
					}
				}
			}
		},
		inputStyle: {
			backgroundColor: '#333',
			color: 'silver'
		},
		labelStyle: {
			color: 'silver'
		}
	},

	navigator: {
		handles: {
			backgroundColor: '#666',
			borderColor: '#AAA'
		},
		outlineColor: '#CCC',
		maskFill: 'rgba(16, 16, 16, 0.5)',
		series: {
			color: '#7798BF',
			lineColor: '#A6C7ED'
		}
	},

	scrollbar: {
		barBackgroundColor: {
			linearGradient: [0, 0, 0, 20],
			stops: [
				[0.4, '#888'],
				[0.6, '#555']
			]
		},
		barBorderColor: '#CCC',
		buttonArrowColor: '#CCC',
		buttonBackgroundColor: {
			linearGradient: [0, 0, 0, 20],
			stops: [
				[0.4, '#888'],
				[0.6, '#555']
			]
		},
		buttonBorderColor: '#CCC',
		rifleColor: '#FFF',
		trackBackgroundColor: {
			linearGradient: [0, 0, 0, 10],
			stops: [
				[0, '#000'],
				[1, '#333']
			]
		},
		trackBorderColor: '#666'
	},

	// special colors for some of the
	legendBackgroundColor: 'rgba(0, 0, 0, 0.5)',
	legendBackgroundColorSolid: 'rgb(35, 35, 70)',
	dataLabelsColor: '#444',
	textColor: '#C0C0C0',
	maskColor: 'rgba(255,255,255,0.3)'
};

var colors = theme.colors;

// Options for Org chart view
theme.orgChart = {
	node: {
		textColor: 'black ',
		borderColor: colors[1],
		borderWidth: 2,
		backgroundColor: 'white ',
		fontWeight: 'normal ',
		hover: {
			backgroundColor: colors[3],
			textColor: 'white '
		}
	},
	junction: {
		lineColor: colors[3],
		lineWidth: 2
	},
	dropMarker: {
		borderColor: colors[1],
		borderWidth: 0,
		backgroundColor: colors[4],
		backgroundOpacity: 1
	},
	tooltip: {
		backgroundColor: colors[1],
		backgroundOpacity: 1,
		borderWidth: 2,
		borderRadius: 0,
		borderColor: colors[2],
		style: {
			color: '#fff',
			/*fontFamily: '"georgia"',
			fontStyle: 'italic',*/
			fontSize: '12px',
			padding: '5px',
			whiteSpace: 'nowrap',
		}
	}
};

theme.version = Highcharts.version.split(".").map(function(e) {
	return parseInt(e, 10);
});

if (theme.version[0] === 2) {
	// theme.navigation = {
	// 	buttonOptions: {
	// 		borderRadius: 50,
	// 		height: 24,
	// 		width: 24,
	// 		backgroundColor: '#00acec',
	// 		borderColor: '#00a1de',
	// 		symbolX: 12,
	// 		symbolY: 12,
	// 	}
	// },
} else if (theme.version[0] === 3) {
	theme.navigation = {
		buttonOptions: {
			symbolStroke: '#DDDDDD',
			hoverSymbolStroke: '#FFFFFF',
			theme: {
				fill: {
					linearGradient: {
						x1: 0,
						y1: 0,
						x2: 0,
						y2: 1
					},
					stops: [
						[0.4, '#606060'],
						[0.6, '#333333']
					]
				},
				stroke: '#000000'
			}
		}
	};

	delete theme.exporting;
}

exports.theme = theme;
});

define('syracuse-tablet/html/js/controls/array/builderChartBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/array/builderBase','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/controls/chart/cubeChartsTheme','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/array/builderBase').BuilderBase;
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var theme = require('syracuse-tablet/html/js/controls/chart/cubeChartsTheme').theme;
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _merge = Highcharts.merge;
var objectClone = function(o) {
	return $.extend({}, o);
};

Highcharts.theme = theme;
Highcharts.setOptions(Highcharts.theme);

var colors = Highcharts.theme.colors;

var _style = function($style) {
	var map = {
		xy: "line",
		point: "scatter",
		stick: "column",
		radar: "spiderweb"
	};

	return $style && (map[$style] || $style);
};

function _isCubeValid(cube, proto) {
	return !!(cube && cube.$hierarchies && proto.$axes && proto.$axes.length > 0 && //
		proto.$axes[0].$hierarchies && proto.$axes[0].$hierarchies.length > 0);
}
/**
 * cube chart control class
 *
 * article:
 * $isLegendHidden: true/false
 * $isXLabelHidden: true/false
 * $isYLabelHidden: true/false
 * $isXLabelsHidden: true/false
 * $isYLabelsHidden: true/false
 * $style: line, spline, area, areaspline, bar, stick, pie
 */
exports.BuilderChartBase = utils.defineClass(
	function builderChartBase(control) {
		Base.call(this, control);
		// #6974 Add this stuff there for compatibility with desktop code
		// This block assigns some variables so that the implementations
		// in ctrlCubeChartBase which have been migrated from the desktop client
		// do not need to be modified too much!
		this.$prototype = control.prototype.json;
		this.$prototype.$properties = this.$prototype.$item.$properties;
		this._localize = {
			highCharts_showHideLegend: locale.text("highCharts_showHideLegend"),
			highCharts_seriesTitle: locale.text("highCharts_seriesTitle")
		};
		this._initializeMeta();
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.clearChart();
			this._localize = this._meta = this._dataset = this.$prototype = this.currentMetaData = null;
		},
		//#6974 clear existing chart
		clearChart: function() {
			if (this.highchartObject) {
				this.highchartObject.destroy();
			}
			this.highchartObject = null;
		},
		_mergeMetaData: function(metadata) {
			var m = {};
			if (metadata && metadata.$chartOptions) {
				metadata.$isXLabelsHidden = metadata.$chartOptions.isXLabelsHidden || false;
				metadata.$isYLabelsHidden = metadata.$chartOptions.isYLabelsHidden || false;
				metadata.$isXLabelHidden = metadata.$chartOptions.isXLabelHidden || false;
				metadata.$isYLabelHidden = metadata.$chartOptions.isYLabelHidden || false;
				metadata.$isLegendHidden = metadata.$chartOptions.isLegendHidden || false;
				metadata.$isGridLineHidden = metadata.$chartOptions.isGridLineHidden || false;
				metadata.$isTitleHidden = metadata.$chartOptions.isTitleHidden || false;
				metadata.$isLabelsHidden = metadata.$chartOptions.isLabelsHidden || false; // Only for pie
			}
			if (metadata && metadata.$axisLabels) m.$axisLabels = metadata.$axisLabels;
			if (metadata && metadata.$cube) m.$cube = metadata.$cube;
			if (metadata && metadata.$axes) m.$axes = metadata.$axes;
			if (metadata && metadata.$style) m.$style = metadata.$style;
			if (metadata && metadata.$color) m.$color = metadata.$color;
			if (metadata && metadata.$isLegendHidden) m.$isLegendHidden = metadata.$isLegendHidden;
			if (metadata && metadata.$isXLabelHidden) m.$isXLabelHidden = metadata.$isXLabelHidden;
			if (metadata && metadata.$isYLabelHidden) m.$isYLabelHidden = metadata.$isYLabelHidden;
			if (metadata && metadata.$isXLabelsHidden) m.$isXLabelsHidden = metadata.$isXLabelsHidden;
			if (metadata && metadata.$isYLabelsHidden) m.$isYLabelsHidden = metadata.$isYLabelsHidden;
			if (metadata && metadata.$isGridLineHidden) m.$isGridLineHidden = metadata.$isGridLineHidden;
			if (metadata && metadata.$isTitleHidden) m.$isTitleHidden = metadata.$isTitleHidden;
			if (metadata && metadata.$isLabelsHidden) m.$isLabelsHidden = metadata.$isLabelsHidden;
			if (metadata && metadata.$inverted) m.$inverted = metadata.$inverted;
			if (metadata && metadata.$seriesOptions) {
				m.$cube = m.$cube || {};
				m.$cube.$measures = m.$cube.$measures || {};
				Object.keys(metadata.$seriesOptions).forEach(function(key) {
					if (metadata.$seriesOptions[key]) {
						m.$cube.$measures[key] = m.$cube.$measures[key] || {};
						if (metadata.$seriesOptions[key].color) {
							m.$cube.$measures[key].$color = metadata.$seriesOptions[key].color.bgColor;
						}
						m.$cube.$measures[key].$isHidden = metadata.$seriesOptions[key].isHidden;
					}
				});
			}
			this.currentMetaData = _merge(this.currentMetaData || {}, m);

			if (metadata && metadata.$item && metadata.$item.$properties && this.currentMetaData && this.currentMetaData.$cube && this.currentMetaData.$cube.$measures) {
				$.smForEachKey(this.currentMetaData.$cube.$measures, function(key, m) {
					if (metadata.$item.$properties[key] && metadata.$item.$properties[key].$title) {
						m.$title = metadata.$item.$properties[key].$title;
					} else {
						m.$title = key;
					}
				});
			}

			return this.currentMetaData;
		},
		_ensureFormatter: function(measure) {
			measure.formatter = {
				format: function(val, localFormat) {
					return val;
				}
			};
		},
		_localizedText: function(key) {
			return key;
		},
		_getFieldEvalTitle: function() {
			return [];
		},
		// Each time the dataset of array changes
		notifyArrayDataChanged: function(refresh, arrayData, isEmpty) {
			var self = this;
			var chartDataset = [];
			if (arrayData && arrayData.$resources) {
				arrayData.$resources.forEach(function(dao) {
					chartDataset.push(dao.data);
				});
			}
			self._dataset = chartDataset;
			self._links = null;
			if (arrayData && arrayData.$links) {
				self._links = {};
				Object.keys(arrayData.$links).forEach(function(key) {
					if (!arrayData.$links[key].$isHidden) self._links[key] = arrayData.$links[key];
				});
			}
		},
		_settingsFromValue: function() {
			var self = this,
				$cube = this.currentMetaData.$cube,
				icolor = 0,
				settings;

			var dataset = self.getChartDataSet();
			if ($cube && $cube.$style === "spiderweb") {
				settings = {};
				settings.categories = Object.keys(self._meta.series).map(function(key) {
					return self._meta.series[key].options.name;
				});

				settings.series = {};
				dataset && dataset.reduce(function(res, current) {
					var serie = {
						name: self._getMeasureLabel(current, self._meta.xAxis[0].code),
						color: colors[icolor++],
						data: [],
						pointPlacement: 'on'
					};
					if (serie.name) {
						serie.id = "#s-" + serie.name;
						$.smForEachKey(self._meta.series, function(key, s) {
							if (!s.isHidden) self._pushData(serie, key, key, current);
						});
						res.series[serie.name] = serie;
					}
					return res;
				}, settings);
			} else {
				settings = {
					categories: [],
					series: {}
				};
				dataset && dataset.reduce(function(res, current) {
					var categoryName = self._getMeasureLabel(current, self._meta.xAxis[0].code);
					if (categoryName != null) {
						res.categories.push(categoryName);
						$.smForEachKey(self._meta.series, function(key, s) {
							var serie = res.series[key];
							if (!serie) {
								serie = objectClone(s.options);
								serie.data = [];
								res.series[key] = serie;
							}
							self._pushData(serie, categoryName, key, current);
						});
					}
					return res;
				}, settings);
			}
			return settings;
		},

		_pushData: function(serie, categoryName, key, data) {
			var val = parseFloat(data.$rawV && data.$rawV[key] && data.$rawV[key].v || data[key]) || 0;
			if (this.useLogarithmicAxis) {
				this.maxValue = Math.max(this.maxValue || -Infinity, val);
				this.minValue = Math.min(this.maxValue || Infinity, val);
			}
			serie.data.push({
				name: categoryName,
				y: val,
				"rowId": data.$uuid
			});
		},
		//#6974 add options height/width.onComplete/zoomType
		createChart: function(settings, $$parent, options) {
			var self = this,
				options = _merge(self._getPref(), self._getOptions(self.$prototype, $$parent, options));
			if (self.highchartObject) {
				//#6974 clear existing chart
				self.clearChart();
			}
			if (settings) {
				options.xAxis[0].categories = settings.categories;
				$.smForEachKey(settings.series, function(key, s) {
					var serie = objectClone(s),
						serieMeta = self._meta.series[key];
					if (options.chart.polar && serie && serie.type) {
						delete serie.type;
					}
					if (!(serieMeta && serieMeta.isHidden) && !(serieMeta && serieMeta.options && serieMeta.options.isHidden)) {
						options.series.push(serie);
					}
				});
			} else {
				$.smForEachKey(self._meta.series, function(key, s) {
					var serie = objectClone(s.options);
					if (options.chart.polar && serie && serie.type) {
						delete serie.type;
					}
					serie.data = [0];
					if (!s.isHidden) {
						options.series.push(serie);
					}
				});
			}
			if (!(self.$prototype.$cube && self.$prototype.$cube.$style == "spiderweb")) {
				options.series.reverse();
			}
			if (this.useLogarithmicAxis) {
				if ((this.maxValue || 0) / (this.minValue || 1) > 10) {
					options.yAxis.type = 'logarithmic';
				}
			}
			self.highchartObject = new Highcharts.Chart(options);

			var legend = this.highchartObject.legend;
			self.displayLegend = legend && legend.display;

			var chartSeries = self.highchartObject.series,
				serie, serieMeta;
			for (var j = chartSeries.length - 1; j >= 0; j--) {
				serie = chartSeries[j];
				serieMeta = serie && serie.options.id && self._meta.series[serie.options.id.slice(3)];
				if (serieMeta && serieMeta.measure) {
					serieMeta.measure.$color = serieMeta.options.color = serie.color;
				}
			}
		},
		//#6974 add options height/width.onComplete/zoomType
		_getOptions: function(proto, $$parent, options) {
			options = options || {};
			var self = this;
			var $cube = this.currentMetaData.$cube;
			var defOptions = Highcharts.getOptions();
			var buttons = defOptions.exporting.buttons;
			var enuml;
			var $style = this.currentMetaData.$style || ($cube && $cube.$style) || (proto.$cube && proto.$cube.$style);
			var axe = proto.$axes && proto.$axes[0] || {};
			var titleCode = this._getMeasureCode(axe.$hierarchies[0][0]);
			var hierarchy = $cube.$hierarchies && $cube.$hierarchies[titleCode];
			var axeTitle = hierarchy ? hierarchy.$title : null;
			if (axeTitle === null && proto.$properties && proto.$properties[titleCode]) {
				axeTitle = proto.$properties[titleCode].$title || "";
			};
			var margin = {
				top: (this.currentMetaData.$isTitleHidden && $style !== "bar" ? 0 : null),
				bottom: (this.currentMetaData.$isXLabelsHidden && $style !== "bar" ? 0 : null),
				left: (this.currentMetaData.$isYLabelsHidden && $style !== "bar" ? 2 : null)
			};
			var legend = {};
			/*TODO :if (globals.getSiteLayout().getDeviceType() === "smartphone") {
				legend.layout = 'horizontal';
				legend.align = 'center';
				legend.verticalAlign = 'bottom';
				legend.floating = 'bottom';
				legend.notitle = true;
			};*/
			var options = {
				chart: {
					renderTo: $$parent.get(0),
					reflow: false,
					zoomType: options.zoomType || 'x',
					ignoreHiddenSeries: false,
					width: options.width,
					height: options.height,
					inverted: this.currentMetaData.$inverted,
					marginTop: margin.top,
					marginBottom: (!this.currentMetaData.$inverted ? margin.bottom : margin.left),
					marginLeft: (!this.currentMetaData.$inverted ? margin.left : margin.bottom),
					marginRight: (!this.currentMetaData.$inverted ? margin.left : margin.bottom),
					events: {
						load: options.onComplete,
					}
				},
				lang: {
					showHideLegend: self._localize.highCharts_showHideLegend
				},

				legend: {
					layout: legend.layout ? legend.layout : 'vertical',
					align: legend.align ? legend.align : 'right',
					verticalAlign: legend.verticalAlign ? legend.verticalAlign : 'top',
					y: legend.notitle ? 0 : 60,
					x: legend.notitle ? 0 : -10,
					title: {
						text: (legend.notitle ? '' : ':::: ' + self._localize.highCharts_seriesTitle)
					},
					borderWidth: legend.notitle ? 0 : 1,
					floating: legend.notitle ? false : true,
					draggable: legend.notitle ? false : true,
					zIndex: 20,
					enabled: !(this.currentMetaData.$isLegendHidden === true) && ($style !== "pie")
				},
				title: {
					text: (!this.currentMetaData.$isTitleHidden && $cube && self._localizedText($cube.$title)) || null
				},
				subtitle: {
					text: null
				},
				xAxis: [{
					categories: [],
					title: {
						text: (!this.currentMetaData.$isXLabelHidden && self._localizedText(axeTitle)) || null
					},
					labels: {
						rotation: -45,
						align: 'right',
						enabled: !(this.currentMetaData.$isXLabelsHidden === true)
					},
					gridLineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
					minorGridLineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
					lineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
					tickWidth: (this.currentMetaData.$isXLabelsHidden ? 0 : 1)
				}],

				yAxis: [{
					title: {
						text: null
					},
					labels: {
						align: 'right',
						enabled: !(this.currentMetaData.$isYLabelsHidden === true)
					},
					gridLineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
					minorGridLineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
					lineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
					tickWidth: (this.currentMetaData.$isYLabelsHidden ? 0 : 1)
				}],

				plotOptions: {
					series: {
						pointPadding: 0,
						groupPadding: 0.1,
						cursor: 'pointer',
						events: {},
						point: {
							events: {
								click: self.getChartClickHandler()
							}
						},
						stacking: self._meta.stacking,
						animation: false
					}
				},

				tooltip: {
					formatter: function() {
						var seriesMeta = self._meta.series,
							serie = this.key && seriesMeta[this.key] || seriesMeta[this.series.options.id.slice(3)],
							measure = serie && serie.measure,
							data = this.series.processedYData,
							y = this.y;

						if (measure) {
							self._ensureFormatter(measure);
						}
						var label = this.series.name || measure && measure.$title,
							mformat = measure && measure.formatter;
						label = (label ? label + "<br>" : "") + (this.x || this.key) + ': <b> ' + (mformat ? mformat.format(y) : y) + '</b>';
						if (measure && (measure.$isNormalized) && data.length > 0) {
							var sum = data.reduce(function(a, b) {
								return a + b;
							});
							label += ' (' + (mformat ? mformat.formatValue(y / sum * 100) : y / sum * 100) + '%)';
						}

						return label;
					}
				},

				series: [],
			};
			if ($style === "pie") {
				options.plotOptions.pie = options.plotOptions.pie || {};
				options.plotOptions.pie.dataLabels = options.plotOptions.pie.datalabels || {};
				options.plotOptions.pie.dataLabels.enabled = (this.currentMetaData.$isLabelsHidden ? false : true);
			}
			if (Highcharts.theme.version[0] === 3) {
				// For Highcarts 3.0.0
				options.exporting = {
					type: 'image/png',
					url: 'http://export.highcharts.com/',
					buttons: {
						contextButton: { // docs
							//x: -10, // docs: x is different now
							symbol: 'menu',
							enabled: false,
							_titleKey: 'contextButtonTitle',
							menuItems: [{
								textKey: 'showHideLegend',
								onclick: function() {
									setTimeout(function() {
										self._toggleLegendDisplay();
									}, 100);
								}
							}]
						},
						legendButton: {
							enabled: false,
							textKey: 'showHideLegend',
							symbol: 'menu',
							onclick: function() {
								setTimeout(function() {
									self._toggleLegendDisplay();
								}, 100);
							}
						}
					}
				};
				var menuItems = options.exporting.buttons.contextButton.menuItems || [];
				if (this._printSupported()) {
					menuItems.push({
						text: 'Print chart',
						onclick: function() {
							this.print(self);
						}
					});
				}
				if (this._exportSupported()) {
					menuItems.push({
						separator: true
					});
					menuItems.push({
						textKey: 'downloadPNG',
						onclick: function() {
							this.exportChart();
						}
					});
					menuItems.push({
						textKey: 'downloadJPEG',
						onclick: function() {
							this.exportChart({
								type: 'image/jpeg'
							});
						}
					});
					menuItems.push({
						textKey: 'downloadPDF',
						onclick: function() {
							this.exportChart({
								type: 'application/pdf'
							});
						}
					});
					menuItems.push({
						textKey: 'downloadSVG',
						onclick: function() {
							this.exportChart({
								type: 'image/svg+xml'
							});
						}
					});
				}
			}

			if (options.xAxis[0].title.text !== options.title.text) {
				options.xAxis[0].title.text = (options.xAxis[0].title.text ? options.xAxis[0].title.text : options.title.text);
			}
			options.chart.type = self._meta.defaultStyle;

			return options;
		},

		_initializeMeta: function() {
			this._mergeMetaData(this.$prototype);
			this._mergeMetaData(this.article);

			var proto = this.$prototype;
			var cube = this.currentMetaData;

			this._meta = {
				xAxis: [{}],
				series: {},
				displaysOneMeasure: cube && cube.$displaysOneMeasure,
				hasMeasureSelector: cube && cube.$hasMeasureSelector,
				hasStyleSelector: cube && cube.$hasStyleSelector,
				defaultStyle: _style(cube.$style) || 'column',
				drill: {
					minLevel: 1,
					maxLevel: 0,
					currLevel: 1,
					currAxisHier: 0,
					levelsProperties: [],
					members: [],
					stack: [{
						$axes: proto.$axes,
						$item: proto.$item,
						$slicer: proto.$slicer
					}]
				}
			};
			this.__processMeta(proto, true);
		},

		_exportSupported: function() {
			return true;
		},

		_printSupported: function() {
			return true;
		},

		__processMeta: function(metaData, init) {
			this._processMeasures(metaData, init);
			this._processAxes(metaData, init);
		},

		_processMeasures: function(metaData, init) {
			this._mergeMetaData(metaData);

			var self = this,
				items = this.$prototype.$properties;

			// Get measures definition. If measures are not defined in the second axis members (Cf. specs),
			// we used all the measures defined in the cube
			var measures = this._getRestraintMeasures(),
				icolor = 0;
			if (measures) {
				$.smForEachKey(measures, function(key, m) {
					// Because duplicate properties is possible for cube definition... we keep the last defined
					var code = (m.$property || key);
					var measure = _merge(items[code], m);
					if (metaData && metaData.$item && metaData.$item.$properties) {
						measure = _merge(measure, metaData.$item.$properties[code]);
					}
					if (!measure.$title || measure.$title === "") {
						measure.$title = key;
					}
					// measures[key] = measure;
					var serie = self._meta.series[code];

					if (init) {
						self._ensureFormatter(measure);

						serie = self._meta.series[code] = {
							options: {
								id: '#s-' + code,
								// legendIndex: "",
								name: self._localizedText(measure.$title) || String.fromCharCode(160),
								// visible: measure.$title !== "" && !!(!self._meta.displaysOneMeasure || measure.$isDefault)
							},
							measure: measure
						};
					}
					if (serie) {
						serie.isHidden = measure.$title === "";
						serie.options.type = _style(measure.$style);
						serie.options.color = measure.$color || colors[icolor++];
						serie.options.name = self._localizedText(measure.$title) || String.fromCharCode(160);
						serie.options.visible = measure.$title !== "" && !!(!self._meta.displaysOneMeasure || measure.$isDefault);
						serie.options.isHidden = measure.$isHidden;
					}

					if (measure.$isStacked || measure.$stackingGroup) {
						serie.options.stack = measure.$stackingGroup || 0; // a stack ID
						self._meta.stacking = measure.$isNormalized ? 'percent' : self._meta.stacking || 'normal';
					}
				});
			}
		},

		_getRestraintMeasures: function() {
			var proto = this.currentMetaData,
				$cube = proto.$cube,
				measures = $cube && $cube.$measures,
				restraintMeasures = measures;
			if (measures) {
				if (proto.$axes && proto.$axes.length > 1 && proto.$axes[1].$members && proto.$axes[1].$members[0][0].length > 0) {
					restraintMeasures = {};
					$.smForEach(proto.$axes[1].$members[0][0], function(measureCode) {
						restraintMeasures[measureCode] = measures[measureCode];
					});
				}
			}
			return restraintMeasures;
		},

		_processAxes: function(proto, init) {
			var cube = this.$prototype.$cube;
			if (!_isCubeValid(cube, proto)) return false;

			var self = this,
				currAxisHier = 0,
				axis0 = proto.$axes && proto.$axes[0];

			// TODO: review this
			// Get axis analysis
			var mainHLevelsTab = null;
			if (axis0) {
				$.smForEachKey(axis0.$hierarchies, function(idx, hierarchy) {
					if (!mainHLevelsTab && hierarchy.length > 1 && hierarchy[1] == 1) {
						mainHLevelsTab = cube.$hierarchies[hierarchy[0]].$properties;
						if (mainHLevelsTab) {
							self._meta.xAxis[0].code = mainHLevelsTab[hierarchy.length > 2 ? hierarchy[2] : 0];
							currAxisHier = idx;
						}
					}
				});
				if (!mainHLevelsTab && axis0.$hierarchies[0].length > 0) {
					mainHLevelsTab = cube.$hierarchies[axis0.$hierarchies[0][0]].$properties;
					if (mainHLevelsTab && mainHLevelsTab.length > 0) self._meta.xAxis[0].code = mainHLevelsTab[0];
				}
				// Get drill definition
				var properties;
				$.smForEach(axis0.$hierarchies, function(hierarchie) {
					properties = cube.$hierarchies[hierarchie[0]].$properties;
					$.smForEach(properties, function(property) {
						this.levelsProperties[this.maxLevel++] = property;
					}, self._meta.drill);
				});
				if (axis0.$members) {
					$.smForEach(axis0.$members, function(tuple) {
						$.smForEach(tuple, function(value) {
							if (value.length > 0) {
								this.members[(this.currLevel++) - 1] = value[0];
							}
						}, this);
					}, self._meta.drill);
				}
			}
			self._meta.drill.code = proto.$codeStat || "UNKNOWN";
			self._meta.drill.axis0FieldCode = self._meta.xAxis[0].code || "";
			self._meta.drill.maxLevel = Math.max(self._meta.drill.maxLevel, self._meta.drill.minLevel);
		},

		_getPref: function() {
			return Highcharts.getOptions();
		},
		//get the measure code depending on level. May be not the best way to do that (see desktop release).
		_getMeasureCode: function(code) {
			var level = (this.controller.level != undefined) ? this.controller.level + 1 : 0;
			var measureCode = ((level > 1) && this.$prototype.$axes[0].$hierarchies.length >= level) ? this.$prototype.$axes[0].$hierarchies[level - 1][0] : null;
			//Authoring is yet stored by level but to keep existing authoring, we keep the key but always 1
			measureCode = (this.currentMetaData.$axisLabels) ? this.currentMetaData.$axisLabels[1] : measureCode;
			return measureCode || code;
		},
		_getMeasureLabel: function(measure, code) {
			var self = this;
			var label = this._localizedText(measure.$title);
			if (label) return label;
			code = this._getMeasureCode(code);
			if (!measure[code]) return "";
			var item = self.$prototype.$properties[code];
			if (!item) return null;
			switch (item.$type) {
				case "application/x-choice":
					label = measure[code];
					item.$value.$enum.some(function(element, i, array) {
						if (element.$value === label) {
							label = self._localizedText(element.$title);
							return true;
						}
						return false;
					});
					break;
				case "application/x-date":
					item.formatter = formatApi.getFormatter(item.$type, locale.getDateFormat(item.$type));
					label = item.formatter.formatValue(measure[code]);
					break;
				case "application/x-integer":
				case "application/x-decimal":
					item.formatter = formatApi.getFormatter(item.$type, locale.getNumberFormat(item.$type));
					label = item.formatter.formatValue(measure[code]);
					break;
				default:
					label = "" + measure[code];
					break;
			}
			return label;
		},
		_toggleLegendDisplay: function() {
			var legend = this.highchartObject.legend;
			legend && this._displayLegend(!legend.display);
		},
		_displayLegend: function(display) {
			var legend = this.highchartObject.legend;
			if (!legend) return;
			if (display) {
				legend.group.show();
				legend.box.show();
			} else {
				legend.group.hide();
				legend.box.hide();
			}
			this.displayLegend = legend.display = display;
		}
	});
});

define('syracuse-tablet/html/js/controls/array/builderChart',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/app/globals','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/controls/array/builderChartBase','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/app/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var Base = require('syracuse-tablet/html/js/controls/array/builderChartBase').BuilderChartBase;
var notifications = require('syracuse-tablet/html/js/helpers/notifications');


var _getHeight = function(h) {
	if (h === "xsmall") return 50;
	if (h === "small") return 100;
	if (h === "medium") return 200;
	if (h === "large") return 400;
	if (h === "xlarge") return 700;
	return 200;
};

/**
 * HIGHCHART BUILDER
 */
exports.BuilderChart = utils.defineClass(
	function builderChart(control) {
		Base.call(this, control);
	}, Base, {
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			this.resetProps(false);
		},
		destroy: function() {
			Base.prototype.destroy.call(this);
			this._$$chartSlot = this._$$catchEvt = null;
		},
		buildHtml: function(arrayData, $$content, refresh) {
			var self = this
			Base.prototype.buildHtml.call(this, arrayData, $$content, refresh);
			var article = this.article;
			// sometimes we need the height - see chartNeedsHeight
			this._height = _getHeight(this.control.article.$chartHeight);
			this._$$chartSlot = $('<div class="s-m-slot"/>').appendTo($$content);
			this._setChartDataSet(arrayData)
			if (this.getChartDataSet().length > 0) {
				// Catch chart events
				this._$$catchEvt = $('<div class="s-m-catchevt"/>').appendTo($$content);
				this._$$catchEvt.hide();
				if (this.control.isOpenDetailEnabled()) {
					this.control.addChartDetailLink(this._$$catchEvt);
				}
			} else {
				var title = this.control.prototype.getValueByPath("$cube.$title");
				if (title) {
					$('<div class="s-m-no-data-title"/>').appendTo(this._$$chartSlot).text(title);
				}
				$('<div class="s-m-no-data-label"/>').appendTo(this._$$chartSlot).text(locale.text("label.chart.nodata"));
				this._$$chartSlot.css("position", "relative");
			}
			// Display chart only if parent's size is ok
			// Otherwise chart is build on buildOnResize (computeLayout)
			if (refresh == true) {
				this._displayChart(refresh);
			}
		},
		buildOnResize: function(arrayData, $$content, context) {
			if (!this.checkEmptyArray()) {
				return;
			}
			if (this._$$catchEvt) {
				if (this.control.isOpenDetailEnabled()) {
					this._$$catchEvt.show();
				} else {
					this._$$catchEvt.toggle(globals.isAuthoringActive())
				}
			}
			if (!$$content || !$$content.is(':visible')) {
				if (!this._subscribedExpand) {
					this._subscribedExpand = true;
					notifications.subscribe(this, ["sm.layout.expanded"]);
				}
			}
			if (this._layouytType == null) {
				// Needed here to access to all elements (getParentVignette)
				// We do that just once
				if (this.control.isDisplayedInDetailPage()) {
					// in that case the chart is displayed in a 'detail's page
					this._layouytType = "stack";
				} else if (this.control.page.isVignette() && this.control.page.parentVignette) {
					this._layouytType = jsutils.isInstanceOf(this.control.page.parentVignette.parent, "LayoutTile") ? "hub" : "stack";
				}
			}
			this._displayChart(false, true);
		},
		notifLayoutExpanded: function() {
			this._displayChart(false, false);
		},
		_checkHeaderHeight: function(height) {
			if (this.control.builderHeader == null) {
				return height;
			}
			var $$header = this.control.builderHeader.$$elmt;
			if (!$$header.is(":visible")) {
				return height;
			}
			var hh = $$header.height() / this.control.getTransformScale();
			var phh = $$header ? 2 : 0; //+2 to display bottom border (???)
			if (height == null) {
				var css = {
					top: hh + "px",
					height: ((this.control.$$content.height() / this.control.getTransformScale()) - hh - phh) + "px"
				};
				this._$$chartSlot.css(css);
				if (this._$$catchEvt) {
					this._$$catchEvt.css(css);
				}
			} else {
				height = height - hh - phh;
			}
			return height;
		},
		_displayChart: function(refresh, updtScroller) {
			var self = this;
			if (self.isDestroyed() || !self._$$chartSlot) {
				return;
			}
			// SetTimeout to improve UX when there are multiple charts to display (dashboard)
			setTimeout(function() {
				if (self.isDestroyed()) {
					return;
				}
				var stackPage, height;
				if (self._layouytType === "stack") {
					// relative is needed - set each time because aof refresh
					self._$$chartSlot.css("position", "relative");
					// in stack mode we need a height
					stackPage = self.control.page;
					if (self.control.isDisplayedInDetailPage()) {
						// Height set to device height
						height = stackPage.mainContentRect.height - 10;
					} else if (stackPage.isVignette() && stackPage.parentVignette) {
						stackPage = stackPage.parentVignette.page;
						// Height always less or equal than the device height
						height = Math.min(self._height, stackPage.mainContentRect.height - 10);
					} else {
						throw new Error("Unexpected chart page context");
					}
				} else {
					// Parent's height
					height = self._$$chartSlot.height() / self.control.getTransformScale();
				}
				height = self._checkHeaderHeight(height);
				self.createChart(self._settingsFromValue(), self._$$chartSlot, {
					height: height,
					// Parent's width
					width: self._$$chartSlot.width() / self.control.getTransformScale(),
					onComplete: function() {}
				});
				if (updtScroller && stackPage) {
					// Needed to update the scroller
					stackPage.notifyScrollerUpdate()
				}
			}, 10);
		},
		getChartDataSet: function() {
			return this._dataset || [];
		},
		_setChartDataSet: function(arrayData) {
			var chartDataset = [];
			if (arrayData && arrayData.length > 0) {
				arrayData.forEach(function(rowData) {
					chartDataset.push(rowData.getData());
				});
			} //TODO Manage link (drilldown ...)
			this._dataset = chartDataset;
		},
		/**
		 * Returns the handler attached to the click event in the chart
		 */
		getChartClickHandler: function() {
			var self = this;
			return function() {
				var rowId = this.rowId;
				var level = self.level;
				var rowDataset = self.controller.dataset.childDatasets.$resources.getRowByUuid(rowId)
				self.controller.triggerDrillLevel(level, rowDataset)
				return true;
			};
		},
	});
});

define('syracuse-tablet/html/js/controls/array/ctrlArray',['require','exports','module','syracuse-tablet/html/js/controls/ctrlSdataBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/sdata/dataset','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/app/settings','syracuse-tablet/html/js/app/eventListener','syracuse-tablet/html/js/controllers/sdataController','syracuse-tablet/html/js/controls/array/ctrlArrayTableRow','syracuse-tablet/html/js/controls/array/ctrlArrayCardCell','syracuse-tablet/html/js/controls/array/paginators','syracuse-tablet/html/js/controls/array/builderHeader','syracuse-tablet/html/js/controls/array/searchArray','syracuse-tablet/html/js/controls/array/filtersSort','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/controls/array/builderTable','syracuse-tablet/html/js/controls/array/builderCard','syracuse-tablet/html/js/controls/array/builderCarousel','syracuse-tablet/html/js/controls/array/builderSeparator','syracuse-tablet/html/js/controls/array/builderChart','syracuse-tablet/html/js/common/consts'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/ctrlSdataBase').CtrlSdataBase;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var RowDataset = require('syracuse-tablet/html/js/sdata/dataset').RowDataset;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var settings = require('syracuse-tablet/html/js/app/settings');
var eventListener = require('syracuse-tablet/html/js/app/eventListener');
var SdataController = require("syracuse-tablet/html/js/controllers/sdataController").SdataController;
var CtrlArrayTableRow = require('syracuse-tablet/html/js/controls/array/ctrlArrayTableRow').CtrlArrayTableRow;
var CtrlArrayCardCell = require('syracuse-tablet/html/js/controls/array/ctrlArrayCardCell').CtrlArrayCardCell;
var paginators = require("syracuse-tablet/html/js/controls/array/paginators");
var BuilderHeader = require('syracuse-tablet/html/js/controls/array/builderHeader').BuilderHeader;
var SearchArray = require('syracuse-tablet/html/js/controls/array/searchArray').SearchArray;
var FiltersSort = require('syracuse-tablet/html/js/controls/array/filtersSort');
var modules = require('syracuse-tablet/html/js/common/modules');
var BuilderTable = require('syracuse-tablet/html/js/controls/array/builderTable').BuilderTable;
var BuilderCard = require('syracuse-tablet/html/js/controls/array/builderCard').BuilderCard;
var BuilderCarousel = require('syracuse-tablet/html/js/controls/array/builderCarousel').BuilderCarousel;
var BuilderSeparator = require('syracuse-tablet/html/js/controls/array/builderSeparator').BuilderSeparator;
var BuilderChart = require('syracuse-tablet/html/js/controls/array/builderChart').BuilderChart;
var consts = require('syracuse-tablet/html/js/common/consts');

var _builders = {
	table: BuilderTable,
	card: BuilderCard,
	carousel: BuilderCarousel,
	separator: BuilderSeparator,
	chart: BuilderChart
};
/**
 * Used to create empty rowDataset
 */
var _typeDefValue = function(prop) {
	switch (prop.$type) {
		case "application/x-password":
		case "application/x-string":
			return "";
		case "application/x-quantity":
			return 0.0;
		case "application/x-decimal":
		case "application/x-real":
			return 0.0;
		case "application/x-integer":
			return 0;
		case "application/x-boolean":
			return false;
		case "application/x-date":
			return '';
		case "application/x-datetime":
			return '';
		case "application/x-time":
			return '';
		case "application/x-choice":
			return prop.$value.$enum[0].$value;
		case "application/x-reference":
			return {
				$value: "",
				$description: "",
				$title: ""
			};
		case "application/x-array":
			return [];
		default:
			return null;
	}
};
var _dataProps = ["$isMandatory", "$isReadOnly", "$isHidden", "$isExcluded", "$isDisabled", "$actions", "$format"];
var _proto2Instance = function(protoArray) {
	var res = {
		$properties: {}
	};
	var props = protoArray.getValueByPath("$properties");
	for (var propName in props) {
		if (!propName.smStartsWith("$")) {
			var prop = props[propName];
			res[propName] = _typeDefValue(prop);
			var $properties = res.$properties[propName] = {};
			_dataProps.forEach(function(p) {
				if (prop[p] != null) {
					$properties[p] = prop[p];
				}
			});
		}
	}
	return res;
};

/**
 * 
 * Array control
 * 
 * Will create it's own controller to manage array only
 * Per row, it will create a row controller and row control to represent the row
 * Doing it like this, there is always a flat structure per control
 * 
 * For value rendering, "normal" field controls are used
 * 
 */
exports.CtrlArray = utils.defineClass(
	function CtrlArray(controller, article, prototype, options) {
		Base.call(this, controller, article, prototype, options);
		this.$display = "table";
		this.displayAsCarousel = false;
		// An array has it's own controller scoped to the array property only
		this.arrayController = new SdataController(controller.dataset.getChild(this.$bind), controller);
		// UiAdapter is the arrayControl for server feedback
		this.arrayController.uiAdapter = this;
		this._ensurePaginator();
		this.filterSearch = this.filterSortAllowed() ? new SearchArray(this) : null;
		// Predefined x3 filters
		this.filterX3 = this.filterSortAllowed() ? new FiltersSort.Filters(this) : null;
		// in relation with panel filterSort
		this.filterSort = this.filterSortAllowed() ? new FiltersSort.FilterSort(this) : null;
		this.builderContent = null;
		this.builderHeader = null;
		this._checkAuthoring();
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.$$title = this.$$content = null;
			// Since the array creates it's own controller, it must also be destroyed here
			if (this.arrayController) {
				this.arrayController.destroy();
				this.arrayController = null;
			}
			if (this.paginator) {
				this.paginator.destroy();
				this.paginator = null;
			}
			if (this.filterSearch) {
				this.filterSearch.destroy();
				this.filterSearch = null;
			}
			if (this.builderHeader) {
				this.builderHeader.destroy();
				this.builderHeader = null;
			}
			if (this.filterX3) {
				this.filterX3.destroy();
				this.filterX3 = null;
			}
			if (this.filterSort) {
				this.filterSort.destroy();
				this.filterSort = null;
			}
			if (this.builderContent) {
				this.builderContent.destroy();
				this.builderContent = null;
			}
		},
		filterSortAllowed: function() {
			// page is not set during initialization :-(
			var page = this.controller.uiAdapter;
			return page && !page.isVignette() && !page.isChild("SdataRowDetail") && (this.prototype.root.isLookup() || this.prototype.root.isQuery());
		},
		_checkAuthoring: function() {
			this.$display = this.controller.isEditMode() || !this.article.$display ? "table" : this.article.$display;
			if (this.$display === "carousel") {
				this.$display = "card";
				this.displayAsCarousel = true;
			}
			// By default			
			// page is not set during initialization :-(
			var page = this.controller.uiAdapter;
			var isChartDetail = page && page.isChild("SdataRowDetail");
			var isRowDetail = page && page.isChild("SdataChartDetail");
			var defAuthoring = {
				showPagination: !isChartDetail && !page.isVignette(),
				showSortFilter: this.filterSort != null,
				showSearch: this.filterSearch != null,
				rowIndex: this.$display === "card"
			};
			// Force with parents $arrayOptions if any
			this.article.$arrayOptions = $.extend(true, defAuthoring, this.article.$arrayOptions || {});
			// Force value depending on context
			if (this.displayAsCarousel === true) {
				this.article.$cardsPerRow = 1;
				this.article.$minWidth = 1;
				this.article.$filters = "none";
				this.article.$detailsLink = "$none";
				this.article.$arrayOptions = $.extend(true, this.article.$arrayOptions, {
					showPagination: false,
					showSortFilter: false,
					showSearch: false,
					rowIndex: true,
					showRowDetailLink: false
				})
			} else if (isChartDetail) {
				// No row detail in chart detail
				this.article.$arrayOptions.showRowDetailLink = false;
			} else if (isRowDetail) {
				// Force in row detail because no authoring
				this.article.$arrayOptions.showRowDetailLink = true;
			} else if (this.article.$arrayOptions.showRowDetailLink == null) {
				// False by default in other pages
				this.article.$arrayOptions.showRowDetailLink = false;
			}
		},

		get$ItemProto: function() {
			// this proto contains the right prototype for single arrays
			return this.arrayController.dataset.get$ItemProto();
		},

		_newBuilderContent: function() {
			var BuilderClass = _builders[this.$display == "card" ? this.displayAsCarousel ? "carousel" : "card" : this.$display];
			if (!BuilderClass) {
				this.$display = "table";
				this.displayAsCarousel = false;
				BuilderClass = _builders.table;
			}
			return new BuilderClass(this);
		},

		_newBuilderHeader: function() {
			if (this.isSingleArray()) {
				return null;
			}
			var headerOpts = $.extend(true, null, this.article.$arrayOptions);
			// $filters
			headerOpts.$filtersAuthoring = this.$filtersGetAuthoring();
			headerOpts.showSortFilter = this.filterSort != null;
			headerOpts.showSearch = this.filterSearch != null;
			if (this.isArrayField()) {
				// No pagination/search/filters for arrays nested inside pages
				headerOpts.showPagination = false;
			}
			if (headerOpts.showPagination || headerOpts.showSortFilter || headerOpts.showSearch || headerOpts.$filtersAuthoring === "list") {
				return new BuilderHeader(this, headerOpts);
			}
			return null;
		},

		_iniBeforeBuild: function(refresh) {
			if (!this.$$elmt) {
				var css = ["s-m-array", "s-m-" + this.$display];
				if (this.displayAsCarousel) {
					css.push("s-m-carousel");
				}
				Base.prototype.buildHtml.call(this, css);
			}
			if (!this.$$title) {
				this.$$title = $(uiUtils.createDomElement('div', ["s-m-title"])).appendTo(this.$$elmt).hide();
			}
			// After title
			if (!this.$$content) {
				this.$$content = $(uiUtils.createDomElement('div', ["s-m-value"])).appendTo(this.$$elmt);
				if (this.$display === "card") {
					var bgColor = this.article.$arrayBgColor || "darkgrey";
					this.$$content.addClass("s-m-bg s-m-color-" + bgColor.toLowerCase());
				}
			}
			this.clearContent(refresh);
			this.$$elmt.toggleClass("empty", this.isEmpty());
			// Title
			var title = (this.getTitle() || "").trim();
			if (this._displayArray() && title.length > 0 && this.getAuthoring("$isTitleHidden") !== true) {
				this.$$title.show();
				this.$$title.text(title);
			}
		},
		/**
		 * Nb rows displayed (not the one in dataset if local paginator)
		 */
		getNbRows: function() {
			return this.paginator.getNumRowsPage();
		},
		isEmpty: function() {
			return this.getNbRows() == 0;
		},
		/**
		 * Returns the control attached to rowDataset.$uuid == rowId 
		 */
		getRowCtrlById: function(rowId) {
			return this.arrayController.getControl(consts.ROWID_PREFIX + rowId)
		},
		/**
		 * return an array of rowDataset
		 * Calculated because rows can be removed by server on server feedback
		 */
		_getArrayData: function() {
			var arrayData = [];
			var jj = this.paginator.getNumRowsPage();
			for (var ii = 0; ii < jj; ii++) {
				arrayData.push(this.paginator.getRowByIndex(ii))
			}
			return arrayData;
		},
		clearContent: function(refresh) {
			if (refresh !== true) {
				if (this.builderContent) {
					this.builderContent.destroy();
				}
				if (this.builderHeader) {
					this.builderHeader.destroy();
				}
				this.$$title.empty().hide();
				this.builderContent = this._newBuilderContent(this);
				this.builderHeader = this._newBuilderHeader(this);
			}
			this.$$content.empty();
		},
		buildHtml: function(refresh) {
			this._iniBeforeBuild(refresh);
			var arrayData = this._getArrayData();
			if (this.builderHeader) {
				this.builderHeader.buildHtml(arrayData, refresh);
			}
			if (this.builderContent) {
				// Build elements that don't depend on parent's size
				this.builderContent.buildHtml(arrayData, this.$$content, refresh);
			}
		},

		// Build elements that depend on parent's size
		buildOnResize: function(context) {
			if (!this.builderContent) {
				return;
			}
			var arrayData = this._getArrayData();
			this.builderContent.buildOnResize(arrayData, this.$$content, context);
			//Notifies cell/Tile parent - Display optimization
			this.notifyVignetteArrayHosted();
		},

		computeLayout: function(context) {
			this.buildOnResize(context);
		},

		/** 
		 * Create a CardCellCtrl or CardCellCtrl
		 */
		createRecordCtrl: function($$container, recordDataset, index, opts) {
			if (recordDataset == null) {
				recordDataset = this.createEmptyRowDataset();
			}
			var $bind = this.$bind + "-" + recordDataset.$bind + "-" + index;
			var klass;
			var noEdit = true;
			if (this.$display === "card") {
				klass = CtrlArrayCardCell;
			} else if (this.$display === "table") {
				klass = CtrlArrayTableRow;
				// Edit allowed for single arrays
				noEdit = this.isSingleArray() !== true
			} else {
				throw new Error("Unknown record array control")
			}
			opts = $.extend(true, {
				rowIndex: index,
				noEdit: noEdit,
				// This is the link on rows for "real" navigation (e.g. go to $details)
				rowLinkDomAttrs: this._createRecordLinkAttr(),
				drillDownDomAttrs: this._createDrillDownLinkAttr(),
				// Links for child arrays to remove/edit rows
				showRowDetail: this.article.showRowDetailLink,
				showRowDelete: this.prototype.hasCapability("delete")
			}, opts);

			var rowCtrl = new klass(recordDataset, this.arrayController, {
				$bind: this.$bind + "-" + recordDataset.$bind + "-" + index
			}, recordDataset.prototype, opts);
			this.appendStructElmt(rowCtrl);
			rowCtrl.set$$container($$container);
			rowCtrl.page = this.page;
			return rowCtrl;
		},
		_createRecordLinkAttr: function() {
			if (this.isArrayField()) return null
			var linkDomAttrs;
			if (this.controller.root.isLookupController) {
				linkDomAttrs = this.getDataActionAttrs("lookupAccept");
			} else {
				var $linkName = this.getAuthoring("$detailsLink");
				if ($linkName == null) {
					$linkName = this.page.isVignette() ? "$queryfullpage" : "$details";
				}
				var $links = this.get$ItemProto().data("$links");
				if ($linkName == "$queryfullpage" || ($links && $links[$linkName])) {
					linkDomAttrs = this.getSdataLinkAttrs($linkName);
				} else {
					linkDomAttrs = null;
				}
			}
			return linkDomAttrs;
		},
		_createDrillDownLinkAttr: function() {
			if (!this.isChartDetailPage()) return null
			var $linkName = "",
				linkDomAttrs = null;
			var $links = this.get$ItemProto().data("$links");
			if (!$links) return null;
			if ($links.$drillDown) $linkName = "drillDown";
			if ($links.levelUp) $linkName = "levelUp";
			if ($linkName !== "") linkDomAttrs = this.getDataActionAttrs($linkName);
			return linkDomAttrs;
		},
		/**
		 * Force to update the scroller
		 */
		notifyScrollerUpdate: function() {
			if (this.builderContent) {
				this.builderContent.updateGestureMgr();
			}
		},
		/**
		 * Called by paginator on server side pagination
		 * The paginator tells the array the new url which has to be loaded
		 * and the array just asks it's containing page to reload
		 */
		notifyPaginationServer: function($link) {
			this._updateSdataUrl($link)
		},

		/** 
		 * Called by paginator on client side pagination to just redraw the array
		 * Must cleanup DOM and other stuff created before and then trigger a rebuild of the array only
		 */
		notifyPaginationLocal: function() {
			// Destroy row controls
			this.destroyChildren();
			this.buildHtml(true);
		},
		/**
		 * Filter/Search
		 */
		notifyApplyFilter: function($url) {
			this._updateSdataUrl({
				"$url": $url
			})
		},
		_updateSdataUrl: function($link) {
			this.page.fetchNewPageData($link)
		},

		_ensurePaginator: function() {
			this.paginator = new paginators.ArrayPaginatorServer(this);
		},

		_actPagination: function(direction) {
			if (!this.paginator.isEnabled(direction)) {
				return;
			}
			this.paginator.paginate(direction);
		},
		_actActionArray: function(id) {
			switch (id) {
				case "panelfiltersort":
					this._openFilterSortPanel();
					break;
				case "filterSelected":
					var filterId = arguments[1]
					if (filterId) {
						this.filterX3.filtersSelect(filterId);
					}
					break;
				case "search":
					this.filterSearch.search();
					break;
				case "removeSearch":
					this.filterSearch.removeSearch();
					break;
			}
		},
		_openFilterSortPanel: function() {
			var panel = this.page.openPanel("filterSortPanel", {
				filter: true,
				sort: true
			})
			panel.ensureParentArray(this.id)
			panel.show();
		},
		isArrayField: function() {
			if (!this.controller) return false;
			return !this.prototype.root.isQueryLikeFacet();
		},

		isSingleArray: function() {
			return this.prototype.isSingleArray();
		},

		isArrayChart: function() {
			return false;
		},
		/*Used by filterSort filters and searchArray*/
		getFilterSortOptions: function() {
			var opt = {
				"$url": this.page.pageData.prototype.getValueByPath("$url", true, true),
				"$filters": this.filterX3 ? this.filterX3.get$filterToApply() : null,
				"sortInfo": this.page.getPageSort(),
				"filterInfos": this.page.getPageFilter(),
				"searchInfo": this.filterSearch ? this.filterSearch.searchInfos : null
			};
			return opt;
		},
		excludeChildrenFromAuthoring: function() {
			return true;
		},

		getRowStatusInfo: function() {
			var type = this.getAuthoring("$statusEnabled");
			if (type === "mono" || type === "multi") {
				var status = this.getAuthoring("$status");
				if (status == null || $.isEmptyObject(status)) return null;
				return {
					type: type,
					list: status
				};
			}
			return null;
		},

		/**
		 * Returns the columns to display with all info needed by builder
		 */
		getColumnsInfo: function(onlyVisible) {
			if (!this._columnsInfo) {
				var base = {
					$title: "",
					$titleOrig: "", // title not resolved
					$type: "",
					$bind: "",
					$widthType: "auto",
					$imgHeight: "small",
					$widthVal: 0,
					$capabilities: ""
				};
				this._columnsInfo = [];
				var itemProto = this.get$ItemProto();
				var props = itemProto.data("$properties");
				if (props) {
					var self = this;
					Object.keys(props).forEach(function($bind) {
						var prop = props[$bind];
						if (prop.$isHidden !== true && prop.$isExcluded !== true && ["CREUSR", "CREUSR_REF", "UPDUSR", "UPDUSR_REF"].indexOf($bind) < 0) {
							var p = $.extend(true, {}, base, prop);
							p.$title = itemProto.resolveExpression(prop.$title);
							p.$titleOrig = prop.$title;
							// Bind field - Ex SITE_REF
							p.$bind = $bind;
							// Name of the field that contains the value - !=$bind for non reference fields - Ex For SITE_REF -> SITE
							p.$bindValue = itemProto.getFieldValueName($bind);
							// Type of the field that contains the value - !=$type for non reference fields - Ex For SITE -> "application/x-string"
							p.$bindType = itemProto.getFieldValueType($bind);
							self._columnsInfo.push(p);
						}
					});
				}
			}
			// META
			var dataProps = this.controller.dataset.getValueByPath("$properties");
			if (onlyVisible !== true || dataProps == null) {
				return this._columnsInfo;
			}
			var res = [];
			this._columnsInfo.forEach(function(prop) {
				if (dataProps[prop.$bind] == null || dataProps[prop.$bind].$isHidden !== true) {
					res.push(prop);
				}
			});
			return res;
		},

		_actAddRow: function() {
			var self = this;
			// Let the controller create a new row and eventually sync with the server
			// Then, render the new row afterwards since the server may set some values
			this.arrayController.addRow()
				.then(function(rowDataset) {
					if (rowDataset) {
						self.builderContent.appendRow(rowDataset).doAfterClickAddRow(self.isSingleArray());
					}
				})
				.fail(function(result) {
					modules.get("modal").error(result);
				});

		},
		/**
		 * Called by a click action
		 */
		removeRow: function(rowCtrl) {
			var self = this;
			this.arrayController.removeRow(rowCtrl.getUuid()).then(function() {
					self._deleteCtrlRow(rowCtrl);
				})
				.fail(function(result) {
					modules.get("modal").error(result);
				});
		},
		/**
		 * 
		 */
		_deleteCtrlRow: function(rowCtrl) {
			if (!rowCtrl) {
				return;
			}
			rowCtrl.destroy();
			this._updateRowsIndex();
		},
		/**
		 * After a deletion/insertion refresh index and background (add/even)
		 */
		_updateRowsIndex: function(skipRowCtrl) {
			var self = this;
			var realIdx = 1;
			this._getArrayData().forEach(function(rowDataset, idx) {
				var rowCtrl = self.getRowCtrlById(rowDataset.getUuid());
				if (rowCtrl != null && (skipRowCtrl == null || skipRowCtrl != rowCtrl)) {
					// rowCtrl can be null if it's the row that has just been removed (_deleteCtrlRow)
					// The rowDataset is actually removed after ui process 
					rowCtrl.updateRowIndex(realIdx++);
				}
			})
		},

		_displayArray: function() {
			return this.controller.isEditMode() === true || !this.isEmpty() || this.getAuthoring("$displayIfEmpty") === true;
		},
		getScrollViewRect: function() {
			if (this.page.parentVignette) {
				return this.page.parentVignette.getScrollViewRect();
			} else {
				return this.page.mainContentRect;
			}
		},
		/**
		 * none/tabs/list
		 * Stored in $resources array
		 */
		$filtersGetAuthoring: function() {
			if (!this.filterX3) {
				return "none";
			}
			var auth = this.getAuthoring("$filters", this.page.isVignette() ? "none" : "list");
			if (auth !== "none" && settings.getDeviceType() === "smartphone") {
				auth = "tabs";
			}
			return auth;
		},
		$filtersAllowed: function() {
			return this.filterX3 != null && this.filterX3.hasFilters();
		},
		/**
		 * text can be overridden (chart)
		 */
		setEmptyArrayMsg: function(text) {
			this.$$content.empty();
			if (!this.isArrayField()) {
				var title = this.getTitle();
				if (title) {
					$('<div class="s-m-no-data-title"/>').appendTo(this.$$content).text(title);
				}
				$('<div class="s-m-no-data-label"/>').appendTo(this.$$content).text(text || locale.text("array.empty"));
			} else {
				// No label
			}
		},
		/**
		 * Call cell/tile parent (if any) to inform the that a array is nested in a vignette (query/stats/request only)
		 * Used to improve display - call notifSpecialArrayHosted method directly
		 * typeArray: chart/carousel
		 */
		notifyVignetteArrayHosted: function() {
			if (this.isArrayField() || this.prototype.isLookup() || !this.page.isVignette() || !this.page.parentVignette) {
				return;
			}
			// Query/stats/requests....only
			var parent = this.page.parentVignette.parent;
			// Notifies cell/tile to improve display when a chart/carousel is nested
			// hack to remove the background color since we manage it by js (not css)
			if (parent && parent.notifSpecialArrayHosted) {
				var typeArray = this.displayAsCarousel ? "carousel" : this.$display;
				parent.notifSpecialArrayHosted(typeArray);
			}
		},
		savedCtxCreate: function(opts) {
			if (!this.builderContent) return;
			var res = {};
			var builderCtx = this.builderContent.savedCtxCreate(opts);
			if (builderCtx) {
				res.$builder = builderCtx
			}
			return $.isEmptyObject(res) ? null : res;
		},
		savedCtxRestore: function(ctx) {
			if (!ctx) {
				return;
			}
			if (this.builderContent && ctx.$builder) {
				this.builderContent.savedCtxRestore(ctx.$builder);
			}
		},
		/**
		 * Returns the size available to display cards
		 */
		getAvailableSizeForCards: function() {
			var scale = this.getTransformScale();
			return {
				height: (this.$$elmt.height() - (this.builderHeader ? this.builderHeader.$$elmt.height() : 0)) / scale,
				width: this.$$content.width() / scale
			};
		},
		/**
		 * Returns an empty row dataset
		 */
		createEmptyRowDataset: function() {
			var proto = this.arrayController.dataset.rowPrototype;
			var json = _proto2Instance(proto);
			json.$uuid = utils.UUID();
			// We path pathBind as $bind in empty dao to be able to retrieve the full path of prototype in nested arrays
			return this.arrayController.dataset.createRowDataset(json, proto, json.$uuid);
		},
		/**
		 * Called when we set the minimum size of a card
		 */
		authOnSlideMinSize: function(size, action) {
			if (!this.builderContent || !this.builderContent.authMinSize2Pixels) {
				return;
			}
			var arrayData = this._getArrayData();
			if (this.$display != "card" || arrayData.length == 0) {
				return;
			}
			var scale = this.getTransformScale();
			var value = this.builderContent.authMinSize2Pixels(size);
			var contentW = this.$$content.width() / scale;
			var contentH = this.$$content.height() / scale;

			var left = ((contentW - value) / 2) + "px";
			value += "px";
			if (action == "start") {
				var height = this.$$content.find(this.$$content.find("#" + consts.ROWID_PREFIX + arrayData[0].getValue("$uuid"))).closest(".s-m-record").height();
				height = height
				this.$$content.css({
					opacity: "0.3"
				});
				this._$$cardSize = $('<div class="s-m-auth-minsize"><span>Min size' + value + '</span></div>').appendTo(this.$$elmt);
				this._$$cardSize.css({
					height: height + "px",
					width: value,
					top: this.$$content.position().top + (height / 2) + "px",
					left: left
				});
				return;
			}
			if (action == "stop") {
				this.$$content.css({
					opacity: "inherit"
				});
				this._$$cardSize.remove();
				this._$$cardSize = null;
				return;
			}
			if (action == "slide") {
				if (this._$$cardSize) {
					// slide action is called to get the text to display before starting the slider
					this._$$cardSize.css({
						width: value,
						left: left
					});
					if (!this._minCardText) {
						this._minCardText = locale.text("array.minCardWidth") + " ";
						this._minCardSpan = this._$$cardSize.children("span");
					}
					this._minCardSpan.text(this._minCardText + value);
				}
				return value;
			}
		},
		isChartDetailPage: function() {
			return false;
		},
		isAuthoringPropAllowed: function(property, value) {
			if (property !== "arrayDisplay") {
				return Base.prototype.isAuthoringPropAllowed.call(this, property, value);
			}
			switch (value) {
				case "table":
					return true;
				case "separator":
					return this.isSingleArray();
				case "card":
				case "carousel":
					return !this.isSingleArray();
				default:
					return false;
			}
		},
		getCardDetailPageData: function() {
			var dataset = this.getAuthoringDataset();
			return {
				prototype: dataset.prototype,
				dataset: dataset,
				page: {
					$article: this.article.$card
				}
			};
		},
		getAuthoringDataset: function() {
			var datasetJson;
			var arrayDataSet = this.arrayController.dataset;
			var num = arrayDataSet.getNumRows();
			if (num > 0) {
				datasetJson = arrayDataSet.getRowByIndex(0).json;
			} else {
				datasetJson = {};
			}
			var prototype = arrayDataSet.rowPrototype.clone();
			var dataset = new RowDataset(datasetJson, prototype, arrayDataSet, "$cardDetailDummy");

			// In authoring, there are only operations on the prototype, so we inject placeholders here to make
			// the text available later with no need to reference the data
			prototype.json.$title = dataset.resolveExpression(prototype.json.$title);
			return dataset;
		},
		setCardDetailArticle: function(article) {
			this.article.$card = article;
		},
		/**
		 * Used to convert .height()/.width() to the real px
		 */
		getTransformScale: function() {
			return modules.get("siteLayout").getTransformScale();
		},
		/**
		 * Disable/Enable array's header
		 */
		multiSelToggleStatus: function(enabled) {
			if (this.builderHeader) {
				this.builderHeader.disable(enabled === true);
			}
		},
		/**
		 * Returns the selected rows
		 */
		multiSelGetSelectedData: function() {
			var self = this;
			var data = [];
			this.$$content.find(".s-m-record.s-m-multi-selected").each(function(idx, record) {
				record = $(record);
				// avoid click
				record.attr("data-disabled", "true");
				var selector = '.s-m-control.s-m-ctrl[data-sdata-link-bind="$resources"]';
				var rowId = record.is(selector) ? record : record.find(selector);
				rowId = rowId.attr("id").split(consts.ROWID_PREFIX);
				if (rowId.length > 0) {
					rowId = rowId[1];
					var rowdata = self.arrayController.dataset.getRowByUuid(rowId);
					if (rowdata) {
						data.push({
							rowData: rowdata,
							rowId: rowId,
							$$record: record,
							idx: idx,
							status: "init"
						});
					}
				}
			});
			return data;
		},
		/**
		 * Add a diagnose and check the row/card as error
		 * data.$$record record that failed
		 * data.$diagnoses diagnoses to display
		 */
		multiSelAddDiagnoses: function(data) {
			// error/success
			data.$$record.addClass(data.status);
			if (data.success !== true && data.$diagnoses && data.$diagnoses.length > 0) {
				var diag = data.$diagnoses[0];
				var $$diag = $('<div " class="alert alert-' + (diag.$severity === "error" ? "danger" : "success") + '" role="alert">' + diag.$message + '</div>');
				var $$root;
				var smoothOffset;
				if (this.$display == "table") {
					var colSpan = data.$$record.children('td').length;
					$$root = $('<tr class="s-m-multisel-diag" data-nevent data-naction="multiSelTriggerAction" data-params="showdiagnoses"><td colspan="' + colSpan + '"/></tr>');
					data.$$record.after($$root);
					$$diag.appendTo($$root.find("td"));
					smoothOffset = 30;
				} else {
					$$root = $('<section style="padding:2px;width:100%;left: 0px;bottom:0px;" class="s-m-multisel-diag" data-nevent data-naction="multiSelTriggerAction" data-params="showdiagnoses"/>').prependTo(data.$$record.find(".s-m-card"));
					$$diag.appendTo($$root);
					smoothOffset = 5;
				}
				$$root.smData('diagnoses', data.$diagnoses);
				this.notifyScrollerUpdate();
			}
			// smoothOffset != null -> smooth scrolling (value is empirical)
			this.builderContent.makeVisible(data.$$record, smoothOffset)
		},
		/**
		 * Show the diagnose attached to  diagnose and check the row/card as error
		 */
		multiSelShowDiagnoses: function(event) {
			if (!event) {
				return;
			}
			var $$elmt = $(event.target).closest(".s-m-multisel-diag");
			var diags = $$elmt.smData('diagnoses');
			if (diags == null || diags.length == 0) return;
			modules.get("modal").error({
				$diagnoses: diags
			});
		},
		multiSelRemoveDiagnoses: function() {
			// error/success
			this.$$content.find(".s-m-record").removeClass("error success");
			var $$diags = this.$$content.find(".s-m-multisel-diag");
			$$diags.smRemoveData('diagnoses').remove();
			$$diags.remove();
			this.notifyScrollerUpdate();
		},
		/**
		 * Called when the data set is modified
		 * action: added, removed, moved
		 * $uuid: row's uuid
		 * idx: rows idx
		 */
		onDeltaRow: function(action, arrayDataset, $uuid, idx) {
			// Removes the existing row
			var rowCtrl;
			this.arrayController.forEachControl(function(row) {
				if (row && row.getUuid() == $uuid) {
					rowCtrl = row;
					return true;
				}
			})
			if (rowCtrl) {
				this._deleteCtrlRow(rowCtrl);
			}
			if (action == "removed") {
				return;
			}
			// Create row
			var rowDataset = arrayDataset.getRowByUuid($uuid);
			if (!rowDataset) {
				return;
			}
			// Always append
			rowCtrl = this.builderContent.appendRow(rowDataset);
			this._updateRowsIndex();
		}
	});
});

define('syracuse-tablet/html/js/controls/array/ctrlArrayChart',['require','exports','module','syracuse-tablet/html/js/controls/array/ctrlArray','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/controls/array/paginators'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/array/ctrlArray').CtrlArray;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var paginators = require("syracuse-tablet/html/js/controls/array/paginators");


/**
 * 
 * Chart Array control
 * 
 * Array tied to a chart
 * Can be displayed as a grid/card/chart (article.$display = "chart" or "card" or "table")
 * 
 */
exports.CtrlArrayChart = utils.defineClass(
	function CtrlArrayChart(controller, article, prototype, options) {
		options = options || {};
		options.localPagination = prototype.isCube();
		article.$arrayOptions = article.$arrayOptions || {};
		// Disabled for statistics and requests
		article.$arrayOptions.showSortFilter = false;
		article.$arrayOptions.showSearch = false;
		if (!article.$display) {
			article.$display = "chart";
		}
		//TODO : this.level = controller.state.level == null ? 0 : controller.state.level;
		Base.call(this, controller, article, prototype, options);
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
		},

		buildHtml: function(refresh) {
			Base.prototype.buildHtml.call(this, refresh);
			if (this.isHighChart()) {
				this.$$elmt.addClass("s-m-chart");
			} else {
				if (this.isOpenDetailEnabled()) {
					// action on $$value not on $$elmt ( pagination)
					this.addChartDetailLink(this.$$value);
				}
				this.$$elmt.addClass("s-m-chart-array");
			}
			if (this.article.$isHidden === true) {
				this.$$elmt.addClass("s-m-hidden");
			}

		},
		/**
		 * Called also by builderChart
		 */
		addChartDetailLink: function($$elmt) {
			this.$$elmt.attr("data-control-id", this.id).attr("data-naction", "chartDetail");
			this.$$elmt.attr("data-nevent", "")
		},
		_actChartDetail: function() {
			if (this.isEmpty()) return;
			this.controller.gotoUrl(this.page.pageData.$url, null, {
				childContext: {
					controllerId: this.controller.id
				},
				isChartDetail: true,
				level: 0,
			})
		},
		isArrayChart: function() {
			return true;
		},
		setEmptyArrayMsg: function() {
			Base.prototype.setEmptyArrayMsg.call(this, locale.text("label.chart.nodata"));
		},
		_ensurePaginator: function() {
			if (this.prototype.isCube()) {
				this.paginator = new paginators.ArrayPaginatorClient(this, 10);
			} else {
				Base.prototype._ensurePaginator.call(this);
			}
		},
		isDisplayedInDetailPage: function() {
			return this.isChartDetailPage() || !this.page.isVignette();
		},
		/**
		 * Called by chart authoring to know if we should display height property
		 * Mandatory for charts in a row/cell layout because we need to fix the height of the chart
		 * For hub the height is given by the tile
		 */
		chartNeedsHeight: function() {
			return this.$display === "chart" && this._layouytType === "stack" && !this.isDisplayedInDetailPage();
		},
		isHighChart: function() {
			return this.$display === "chart";
		},
		/**
		 * Called also by builderChart
		 */
		isOpenDetailEnabled: function() {
			if (this.isChartDetailPage() || this.displayAsCarousel) {
				return false;
			}
			if (this.page.isVignette()) {
				return this.article.$openDetail !== false;
			}
			return true;
		},
		isChartDetailPage: function() {
			return this.page.isChartDetail();
		},
		isAuthoringPropAllowed: function(property, value) {
			if (property !== "arrayDisplay") {
				return Base.prototype.isAuthoringPropAllowed.call(this, property, value);
			}
			if (value === "separator") {
				return false;
			}
			if (!this.isChartDetailPage()) {
				// All properties included chart
				return true;
			}
			// Chart only for chart (left control) - Table/Card for array (right control)
			return this.article.$forceArray === true ? value !== "chart" : value === "chart";
		}
	});
});

define('syracuse-tablet/html/js/controls/vignette/ctrlVignette',['require','exports','module','syracuse-tablet/html/js/controls/ctrlSdataBase','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/environment','syracuse-tablet/html/js/controls/vignette/gadget','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/app/settings','syracuse-tablet/html/js/app/navigationPageStack','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/sdata/protocolHelpers'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/ctrlSdataBase').CtrlSdataBase;

var uiRect = require('syracuse-tablet/html/js/ui/rect');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var justils = require('syracuse-tablet/html/js/helpers/jsutils');
var environment = require('syracuse-tablet/html/js/helpers/environment');
var gadget = require('syracuse-tablet/html/js/controls/vignette/gadget');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var settings = require('syracuse-tablet/html/js/app/settings');
var navigationPageStack = require('syracuse-tablet/html/js/app/navigationPageStack');
var modules = require('syracuse-tablet/html/js/common/modules');
var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');

var _templates = {
	main: '\
			<section/>\
			<footer style="display:none"/> \
			<div class="s-m-waiting bckg" style="display:none"/> \
			<div class="s-m-waiting wheel" style="display:none"/> \
		',
	vignetteError: '\
			<a draggable="false" href="#" data-nevent="" data-naction="vignetteError">{{text}}</a><span class="s-m-diagnose" style="display:none">{{detail}}</span>\
		',
	iframe: '\
			<br><iframe src="{{url}}" style="position: absolute; top: 0px; left: 0px; height: 100vh; width: 100vh;"/>\
		'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

/**
 * 
 * The prototype of vignettes contains an $item node which includes all the gadgets information
 */
exports.CtrlVignette = utils.defineClass(
	function CtrlVignette(controller, article, prototype, options) {
		this.navigationPageStack = null;
		this.gadget = null;
		options = options || {};
		options.nativeCapabilities = {
			"liveTile": true
		};
		Base.call(this, controller, article, prototype, options);
		this.gadget = gadget.createGadget(this.prototype, options.dashboardParameters);
		if (!this.gadget) {
			// TODO: Throw breaks widget tree creation, would be better to render an "error vignette" here
			throw new Error("Cant' create vignette's gadget[" + this.id + "] - Check prototype")
		}
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this.navigationPageStack) {
				this.navigationPageStack.destroy(true);
			}
			this.navigationPageStack = null;
			if (this.gadget) {
				this.gadget.destroy();
			}
			this.gadget = null;
		},
		/**
		 */
		buildHtml: function() {
			Base.prototype.buildHtml.call(this, ["s-m-vignette"]);
			this._addDashboardParams();
			this.$$elmt.html(_getHtml("main", {}));
			this._$$content = this.$$elmt.children("section");
			this._$$footer = this.$$elmt.children("footer");
			this._$$waitBckg = this.$$elmt.children(".s-m-waiting.bckg");
		},

		afterRender: function() {
			var link = this.gadget.getLink();
			if (link) {
				switch (this.gadget.getType()) {
					case "$external":
						var iFrame = _getHtml("iframe", {
							url: link.$url
						});
						$(iFrame).appendTo(this._$$content);
						break;
					case "$representation":
					case "$stats":
					case "$request":
						this.loadSDataPage(link);
						break;
				}
			} else {
				this._displayError("No Gadget link");
			}
		},
		_addDashboardParams: function() {
			var params = this.page.getGadgetParams();
			if (params) {
				this.gadget.setDashboardParams(params);
			}
		},
		loadSDataPage: function(link) {
			var self = this;
			var pageOptions = {
				// Tell the page it's loaded in a vignette
				isVignette: true,
				// page id depends on vignette context
				pagePrefsId: settings.getPagePrefsId(protoHelpers.getPageName(link.$url), this),
				makeFullHeight: true,
				// Force page's article if any
				$vignetteArticle: this.article && this.article.$article && !$.isEmptyObject(this.article.$article) ? this.article.$article : null,
				parentVignette: self,
				parentPage: self.page,
				// Set saved context stored in parent's dashboard context
				savedCtx: this.page.getSavedCtxVignette(this)
			};
			self.navigationPageStack = navigationPageStack.getStackForElmt(self._$$content);
			var loadOptions = {
				navStack: self.navigationPageStack,
				noError: true,
				$$waitParent: self.$$elmt
			}
			self.controller.openLink(link, pageOptions, loadOptions)
				.then(function(nestedPage) {
					if (self.destroyed) {
						return;
					}
					// Not stored because available in navigationPageStack
					nestedPage.notifyScrollerUpdate();
					self.page.onVignetteLoaded(self, true);
					if (environment.isAutoUITestMode()) {
						environment.getUnitTestMgr().notifPageLoaded("after", nestedPage);
					}

				})
				.fail(function(e) {
					if (self.destroyed) {
						return;
					}
					self._displayError(e);
					self.page.onVignetteLoaded(self, false);
				});
		},

		/**
		 * Call once all vignettes have been loaded
		 * Parent's size is OK -> Can computeLayout
		 */
		afterAllVignettesLoaded: function() {
			try {
				if (this.destroyed) {
					return;
				}
				this.computeLayout();
			} catch (e) {
				this._displayError(e);
			}
		},

		computeLayout: function() {
			if (this.getTopPage()) {
				// computLayout layout is called by parent dashboard once the all the vignettes has been loaded
				// In particular charts need the calculated size of the parent to render
				this.getTopPage().computeLayout();
			}
		},

		_displayError: function(e) {
			if (!this.$$elmt) {
				return;
			}
			var diag = justils.convertToDiagnoses(e);
			if (!this.$$elmt.is(".s-m-error")) {
				this.$$elmt.addClass("s-m-error");
				this.$$elmt.prepend(_getHtml("vignetteError", {
					text: locale.text("vignette.load.failed"),
					detail: JSON.stringify(diag)
				}));
			} else {
				// Append to existing diagnose
				try {
					var currentDiag = JSON.parse(this.$$elmt.find("span").text());
					currentDiag.$diagnoses = currentDiag.$diagnoses.concat(diag.$diagnoses);
					this.$$elmt.find("span").text(JSON.stringify(currentDiag))
				} catch (e) {
					return;
				}
			}
		},

		_actVignetteError: function() {
			var diag = this.$$elmt.find("span.s-m-diagnose").text();
			try {
				diag = JSON.parse(diag);
			} catch (e) {
				return;
			}
			modules.get("modal").asynchError(null, diag);
		},
		getTopPage: function() {
			return this.navigationPageStack && this.navigationPageStack.getTopPage();
		},
		getScrollViewRect: function() {
			return uiRect.elmtRect(this._$$content);
		},
		isVignette: function() {
			return true;
		}
	});
});

define('syracuse-tablet/html/js/controls/vignette/ctrlVignetteLink',['require','exports','module','syracuse-tablet/html/js/controls/ctrlSdataBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/vignette/gadget','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/app/navigationPageStack'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/ctrlSdataBase').CtrlSdataBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var gadget = require('syracuse-tablet/html/js/controls/vignette/gadget');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var navigationPageStack = require('syracuse-tablet/html/js/app/navigationPageStack');

var _templates = {
	linkPage: '\
			<section>\
				<div draggable="false" href="{{href}}"\
				class="s-m-link-page" data-nevent="" data-naction="touch">\
					{{#if icon}}\
						<section class="s-m-icon">\
							<div>\
								<div class="{{icon}}"></div>\
							</div>\
						</section>\
					{{/if}}\
					<section class="s-m-title">\
						<div>{{title}}</div>\
					</section>\
				</div>\
			</section>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

/**
 * 
 * The prototype of vignettes contains an $item node which includes all the gadgets information
 */
exports.CtrlVignetteLink = utils.defineClass(
	function CtrlVignetteLink(controller, article, prototype, options) {
		Base.call(this, controller, article, prototype, options);
		this.gadget = gadget.createGadget(this.prototype);
		if (!this.gadget) {
			// TODO: Throw breaks widget tree creation, would be better to render an "error link" here 
			throw new Error("Cant' create vignette's gadget[" + this.id + "] - Check prototype")
		}
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this.navigationPageStack) {
				this.navigationPageStack.destroy();
			}
			this.navigationPageStack = null;
			if (this.gadget) {
				this.gadget.destroy();
			}
			this.gadget = null;

		},
		/**
		 */
		buildHtml: function() {
			// s-m-vignette for css compatibility
			Base.prototype.buildHtml.call(this, ["s-m-vignette"]);
			this._addDashboardParams();
			switch (this.gadget.getType()) {
				case "$representation":
					this._loadRepresentation();
					break;
				case "$dashboard":
					this._loadDashboard();
					break;
				case "$application":
					this._loadApplication();
					break;
				case "$external":
					this._loadExternal();
					break;
				default:
					break;
			}
		},

		afterRender: function() {},

		_addDashboardParams: function() {
			var params = this.page.getGadgetParams();
			if (params) {
				this.gadget.setDashboardParams(params);
			}
		},
		_getTitle: function() {
			return this.article && (this.article.$title ? this.getArticleText("$title") : this.gadget.data("$title"));
		},

		_loadRepresentation: function() {
			this._addPicker({
				"title": this._getTitle(),
				"icon": this._getCssIcon("s-m-sage-gadget-icon")
			});
		},

		_loadDashboard: function() {
			this._addPicker({
				"title": this._getTitle(),
				"icon": this._getCssIcon("s-m-sage-gadget-icon")
			});
		},

		_loadApplication: function() {
			this._addPicker({
				"title": this._getTitle(),
				"icon": this._getCssIcon("s-m-sage-app-icon"),
			});
		},

		_loadExternal: function() {
			var url = this.gadget.getExternalUrl();
			this._addPicker({
				"title": this._getTitle()
			});
		},

		_addPicker: function(context) {
			var vignetteCtx = {};
			for (var p in context) {
				vignetteCtx[p] = context[p];
			}
			$(_getHtml("linkPage", vignetteCtx)).appendTo(this.$$elmt);
		},

		_getCssIcon: function(sageBaseCss) {
			var icon = this.article && this.article.$icon || this.gadget.data("icon")
			if (icon) {
				if (icon.smStartsWith("s-m-")) {
					// our own gadget icons
					icon = sageBaseCss + " " + icon;
				} else {
					icon = fontUtils.getIconByName(icon);
				}
			}
			return icon || "";
		},

		_actTouch: function() {
			var link = this.gadget && this.gadget.getLink();
			if (link) {
				if (this.gadget.getType() == "$external") {
					window.open(link.$url, "s-m-external-window");
				} else {
					// Navigate by asking the controller because controller will be
					// able to switch between working copy and stateless urls
					// Allow the article to pass an article to the target page (mockup)
					var opts = {
						$mockArticle: this.article.$mockArticle
					}
					this.controller.openLink(link, opts);
				}
			}
		}
	});
});

define('syracuse-tablet/html/js/controls/fields/ctrlImage',['require','exports','module','syracuse-tablet/html/js/controls/fields/ctrlFieldBase','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/native/native'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/fields/ctrlFieldBase').CtrlFieldBase;
var locale = require('syracuse-tablet/html/js/helpers/locale');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var native = require('syracuse-tablet/html/js/helpers/native/native');

/**
 * 
 * 
 * Rendering:
 * 	display mode : ok
 *  edit mode : ok
 * 
 * action :
 * 	change : ok
 *  remove : ok
 *  camera
 *  sign
 *  edit
 *  
 * MetaData:
 * $isReadOnly:  ok
 * $isDisabled:  ok
 * $isHidden: ok
 * 
 */
var _scaleMap = {
	small: {
		width: 640,
		height: 480
	},
	medium: {
		width: 1024,
		height: 768
	},
	large: {
		width: 1920,
		height: 1440
	}
};
var _templates = {
	layout: ' \
		<div class="s-m-img-layout">\
			<section>\
				<a class="img-responsive s-m-field-img" data-nevent-ctrl-click="" href="#" draggable="false">\
				</a>\
			</section>\
			{{#if actions}}\
			<footer> \
				{{#each actions}}\
					{{#if active}}\
						<a class="s-m-meta" \
							href = "#"\
							draggable="false"\
								data-nevent=""\
								data-naction="{{id}}"\
								{{#if display}}\
									style="display:{{display}}">\
								{{/if}}\
							<span \
							{{#if css}}\
								class="{{css}}"\
							{{/if}}\
							>\
							{{#if text}}\
								{{text}}\
							{{/if}}\
							</span>\
						</a>\
					{{/if}}\
				{{/each}}\
			</footer>\
			{{/if}}\
		</div>',
	layoutDispay: '\
			<a class="img-responsive s-m-field-img" href="#" draggable="false">\
			</a>',
	image: '\
		{{#if empty}}\
			<span class="{{css}}"></span>\
		{{else}}\
			<img class="img-responsive" src="{{url}}" draggable=false>\
		{{/if}}\
		',
	inputFile: ' \
		<input\
			type="file"\
			accept="image/*"\
			class="ctrl-evt-change"\
			data-nevent-ctrl-change=""\
		>'
};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	if (!tmpl) alert("template " + name + " not found");
	return tmpl(ctx);
};

exports.CtrlImage = utils.defineClass(

	function CtrlImage(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = {
			"penAnnotatedImage": true,
			"penSignatureImage": true,
			"camera": true
		};
		Base.call(this, controller, article, prototype, options);
	}, Base, {
		/**
		 * 
		 */
		buildHtml: function(classes) {
			classes = classes || [];
			classes.push("s-m-img");
			Base.prototype.buildHtml.call(this, classes);
		},
		buildFieldValue: function() {
			this._ensure$$value();
			this._clear$$value();
			var $imgUrl = this.getValue();
			var empty = ($imgUrl === null)
			if (this.$isEditMode) {
				this.buildEditValue($imgUrl, empty);
			} else {
				this.buildDisplayValue($imgUrl, empty);
			}
		},
		/**
		 * 
		 */
		buildDisplayValue: function(url) {
			var layout = $(_getHtml("layoutDispay", {})).appendTo(this.$$value);

			this._newImg(layout, url);
		},

		buildEditValue: function(url) {
			var layout = $(_getHtml("layout", {
				actions: this._imageActions(url === null)
			})).appendTo(this.$$value);

			this.img = this._newImg($("a.img-responsive", layout), url);

			$(_getHtml("inputFile", {})).appendTo(this.$$value);
		},
		_imageActions: function(empty) {
			var actions = [{
				id: "$select",
				active: this._isBtnActive("$select"),
				css: "s-m-select",
				text: locale.text("image.label.selectimage")
			}, {
				id: "$edit",
				active: this._isBtnActive("$edit"),
				css: "s-m-edit " + fontUtils.getIconByName("$image-ink")
			}, {
				id: "$sign",
				active: this._isBtnActive("$sign"),
				css: "s-m-sign " + fontUtils.getIconByName("$image-sign")
			}, {
				id: "$camera",
				active: this._isBtnActive("$camera"),
				css: "s-m-camera " + fontUtils.getIconByName("$image-camera")
			}, {
				id: "$delete",
				active: this._isBtnActive("$delete"),
				css: "s-m-delete " + fontUtils.getIconByName("$delete"),
				display: empty ? "none" : null
			}];
			return actions;
		},
		_isBtnActive: function(btnId) {
			var isSignature = this.article.$isSignature ? true : false;
			var isActive = false;
			switch (btnId) {
				case "$select":
					isActive = (!isSignature);
					break;
				case "$edit":
					isActive = (!isSignature && this.isNativeCapabilityEnabled("penAnnotatedImage"));
					break;
				case "$camera":
					isActive = (!isSignature && this.isNativeCapabilityEnabled("camera"));
					break;
				case "$sign":
					isActive = (isSignature && this.isNativeCapabilityEnabled("penSignatureImage"));
					break;
				case "$delete":
					isActive = true;
					break;
				default:
					isActive = false;
			}
			return isActive;
		},
		applyMetaData: function(metaData) {
			Base.prototype.applyMetaData.call(this, metaData);
		},
		onDataActionClicked: function(dataAction, dataParams, event) {
			switch (dataAction) {
				case "$select":
					this._onUploadClick();
					break;
				case "$delete":
					this._onClearClick();
					break;
				case "$edit":
					this._onEditClick();
					break;
				case "$camera":
					this._onCameraClick();
					break;
				case "$sign":
					this._onSignClick();
					break;
				default:
					return false
			}
		},
		onClick: function(event) {
			// Not used - click on image
			// console.log("click on " + $(event.target).prop("nodeName"))
		},
		/*
		 When upload button is clicked (or empty image), run upload and update dao
		 */
		_onUploadClick: function() {
			var $$inputDom = this.$$elmt.find(".s-m-value > input");
			try {
				$$inputDom.trigger("click");
			} catch (e) {
				//In case of wrapper and close the dialog box without any file selected, jquery catch 
				//on statement "Prevent re-triggering of the same event" (jQuery 2.1.1 line 4357) 
				//and does not reinit the property "triggered".
				// So we do it in place of jquery !
				jQuery.event.triggered = undefined;
			}
		},
		/*
		 When clear button is clicked
		 - Removes  content
		 - Hide clear button
		 - Update upload button text if image
		 */
		_onClearClick: function() {
			this._setImage(null);
			this.setValue("");
			var element = this.$$elmt.find(".s-m-value > input");
			element.replaceWith(element = element.clone(true)); // element.val('') does not work with IE
			var clearBtn = this.$$elmt.find(".s-m-img-layout > footer > a[data-naction='$delete']")[0];
			$(clearBtn).toggle();
			if (this._isBtnActive('$edit')) {
				var editBtn = this.$$elmt.find(".s-m-img-layout > footer > a[data-naction='$edit']")[0];
				$(editBtn).toggle();
			}
		},
		/*
		 fire when user select a local image
		 */
		onChange: function(evt) {
			var self = this;
			if (evt.target.nodeName.toLowerCase() === 'input') {
				var files = evt.target.files; // FileList object
				var res = {};
				if (files && files.length) {
					var f = files[0]; // only one file
					if (!f.type.match('image.*')) return;
					res.$contentType = f.type;
					res.$fileName = f.name;
					res.$type = "image";

					var reader = new FileReader();
					/*
					 *  theFile : {
					    	lastModified:1465574128588,
							name:"Tiles.png",
							size:35374,
							type:"image/png"
						}
						content : {
							$contentType:"image/png",
							$fileName:"Tiles.png",
							$type:"image",
							$value:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAP.." // result from _getImageDataValue
						}
						src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAP.."
						*/
					reader.onload = (function(theFile, content) {
						return function(e) {
							self._checkScale(e.target.result).then(function(src) {
								content.$value = self._getImageDataValue(src); // clean "data:image/jpeg;base64,"
								delete content.$url; // don't understand, not sure it's necessay
								self.setValue(content.$value); // set the dataset, maybe can avoid it, change is manage by the input type file
								self.setFocus();
								self._setImage(src); // draw the new image
							});
						};
					})(f, res);
					reader.readAsDataURL(f); // read the file and trigger onload at the end
				}
			}
		},
		/*
		 *  src: data:image/png;base64,iVBORw0KGgoAAAAN
		 */
		_checkScale: function(src) {
			if (!src) return $.smResolve(src);
			var self = this;

			var scaler = native.getModule("imageScale");
			if (!scaler) return $.smResolve(src);

			var opts = self._getResizeOptions();
			if (!opts) return $.smResolve(src);
			opts.imageData = src;
			return scaler.getScaledImage(opts)
				.then(function(result) {
					// Change so return  new image
					if (result.action === "ok") {
						return result.imageData;
					}
					// No change, maybe because size was ok already
					if (result.action === "nochange") {
						return src;
					}
					// Here we got an error but we still can return the original image
					return src;
				});
		},
		_getResizeOptions: function() {
			// FD - default is medium otherwise iphone6 picture is too big
			var scale = _scaleMap[this.getAuthoring("$imgScale") || "medium"]
			if (scale == null) {
				return null;
			}
			return {
				width: scale.width,
				height: scale.height,
				mode: "LIMIT_MAX_WIDTH_AND_HEIGHT" // Only supported mode right now
			}
		},
		_getImageDataValue: function(content) {
			var i = content.indexOf("base64,");
			if (i > 0) {
				return content.substring(i + 7);
			} else {
				// don't know when we are in this case ????
				return content.result;
			}
		},
		/*
		 Set image based on client image src
		 */
		_setImage: function(src) {
			var core = this.$$elmt.find(".s-m-img-layout > section > a")[0];
			// remove image
			uiUtils.empty(core);
			// update image
			this.img = this._newImg(core, src);
			// toggle clearBtn
			this.$$elmt.find(".s-m-img-layout > footer > a[data-naction='$delete']").toggle(true);
			if (this._isBtnActive('$edit')) {
				this.$$elmt.find(".s-m-img-layout > footer > a[data-naction='$edit']").toggle(true);
			}
		},
		_newImg: function(parent, src) {
			var empty = (src === null);
			var css = empty ? this._getDefaultIcon() + " s-m-empty img-responsive" : "s-m-image";
			var img = $(_getHtml("image", {
				empty: empty,
				css: css,
				url: src,
			})).appendTo(parent);
			return this._setImgHeight(img);
		},
		_defaultImg: function(parent, css) {
			return this._setImgHeight(uiUtils.createDomElement("span", this._getDefaultIcon() + (" " + (css || "")), null, null, parent));
		},
		_setImgHeight: function($i) {
			return $i.height(uiUtils.imgHeight2px(this.getAuthoring("$imgHeight") || "small")).get(0);
		},
		_getDefaultIcon: function() {
			var css = "s-m-icon-" + (this.article.$emptyIconSize || "small") + " ";
			return css + (this.article.$emptyImageIcon || fontUtils.getEmptyImageDefIcon()).css;
		},
		_getBinaryContent: function() {
			var binary;
			if (this.img) {
				var canvas = document.createElement('canvas');
				var ctx = canvas.getContext("2d");
				ctx.canvas.width = this.img.naturalWidth;
				ctx.canvas.height = this.img.naturalHeight;
				ctx.drawImage(this.img, 0, 0, this.img.naturalWidth, this.img.naturalHeight);
				binary = canvas.toDataURL();
			}
			return binary;
		},
		_onEditClick: function() {
			var self = this;
			var editBtn = this.$$elmt.find(".s-m-img-layout > footer > a[data-naction='$edit']")[0];
			var data;

			// Avoid error on invalid image data
			try {
				data = self._getBinaryContent();
			} catch (e) {
				$(editBtn).hide();
				return;
			}
			$(editBtn).toggle();
			native.getModule("penAnnotatedImage").getAnnotatedImage({
				title: self.getTitle(),
				imageData: data
			}).then(
				function(data) {
					if (data && data.action === "ok") {
						if (data.imageData && data.imageData.length) {
							// No need to scale here
							// The image is scaled before adding it and making inking available
							self.setValue(self._getImageDataValue(data.imageData));
							self._setImage(data.imageData);
						}
					} else {
						$(editBtn).toggle();
					};
				}
			);
		},
		_onSignClick: function() {
			var self = this;
			var signBtn = this.$$elmt.find(".s-m-img-layout > footer > a[data-naction='$sign']")[0];
			$(signBtn).toggle();
			native.getModule("penAnnotatedImage").getSignatureImage({
				title: self.getTitle(),
				watermark: ""
			}).then(
				function(data) {
					if (data && data.action === "ok") {
						if (data.imageData && data.imageData.length) {
							// We do not scale images that are input as a signature since
							// signature images created by the wrapper have a defined size already 
							self.setValue(self._getImageDataValue(data.imageData));
							self._setImage(data.imageData);
						}
					}
					$(signBtn).toggle();
				}
			);
		},
		_onCameraClick: function() {
			var self = this;
			var signBtn = this.$$elmt.find(".s-m-img-layout > footer > a[data-naction='$camera']")[0];
			$(signBtn).toggle();
			native.getModule("camera").getPictureFromCamera({
					resizeOptions: self._getResizeOptions()
				}).then(function(data) {
					if (data && data.action === "ok") {
						if (data.imageData && data.imageData.length > 0) {
							return self._checkScale(data.imageData);
						}
					}
					return null;
				})
				.then(function(imageData) {
					if (imageData) {
						self.setValue(self._getImageDataValue(imageData));
						self._setImage(imageData);
					}
				})
				.always(function() {
					$(signBtn).toggle();
				});
		}
	});

function _isDisabled(metaData) {
	// Apply metaData.$isReadOnly and/or metaData.$isDisabled on select
	// select can only be set as readonly with the 'disabled' attribute
	return metaData && (metaData.$isReadOnly || metaData.$isDisabled);
}
});

define('syracuse-tablet/html/js/controls/chart/gaugeChartstheme',['require','exports','module'],function (require, exports, module) {

exports.ChartsTheme = {
	"colors": ["#2f7ed8", "#0d233a", "#8bbc21", "#910000", "#1aadce", "#492970", "#f28f43", "#77a1e5", "#c42525", "#a6c96a"],
	"symbols": ["circle", "diamond", "square", "triangle", "triangle-down"],
	"lang": {
		"loading": "Loading...",
		"months": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
		"shortMonths": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
		"weekdays": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
		"decimalPoint": ".",
		"numericSymbols": ["k", "M", "G", "T", "P", "E"],
		"resetZoom": "Reset zoom",
		"resetZoomTitle": "Reset zoom level 1:1",
		"thousandsSep": ","
	},
	"global": {
		"useUTC": true,
		"canvasToolsURL": "http://code.highcharts.com/3.0.2/modules/canvas-tools.js",
		"VMLRadialGradientURL": "http://code.highcharts.com/3.0.2/gfx/vml-radial-gradient.png"
	},
	"chart": {
		"borderColor": "#4572A7",
		"borderRadius": 5,
		"defaultSeriesType": "line",
		"ignoreHiddenSeries": true,
		"spacingTop": 10,
		"spacingRight": 10,
		"spacingBottom": 15,
		"spacingLeft": 10,
		"style": {
			"fontFamily": "\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif",
			"fontSize": "12px"
		},
		"backgroundColor": "#FFFFFF",
		"plotBorderColor": "#C0C0C0",
		"resetZoomButton": {
			"theme": {
				"zIndex": 20
			},
			"position": {
				"align": "right",
				"x": -10,
				"y": 10
			}
		}
	},
	"title": {
		"text": "Chart title",
		"align": "center",
		"y": 15,
		"style": {
			"color": "#666",
			"fontSize": "16px"
		}
	},
	"subtitle": {
		"text": "",
		"align": "center",
		"y": 30,
		"style": {
			"color": "#4d759e"
		}
	},
	"plotOptions": {
		"line": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": {
				"enabled": true,
				"lineWidth": 0,
				"radius": 4,
				"lineColor": "#FFFFFF",
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": "bottom"
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true
		},
		"area": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": {
				"enabled": true,
				"lineWidth": 0,
				"radius": 4,
				"lineColor": "#FFFFFF",
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": "bottom"
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true,
			"threshold": 0
		},
		"spline": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": {
				"enabled": true,
				"lineWidth": 0,
				"radius": 4,
				"lineColor": "#FFFFFF",
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": "bottom"
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true
		},
		"areaspline": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": {
				"enabled": true,
				"lineWidth": 0,
				"radius": 4,
				"lineColor": "#FFFFFF",
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": "bottom"
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true,
			"threshold": 0
		},
		"column": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": null,
				"x": 0,
				"y": null,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null
			},
			"cropThreshold": 50,
			"pointRange": null,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": 0.1,
					"shadow": false
				},
				"select": {
					"marker": {

					},
					"color": "#C0C0C0",
					"borderColor": "#000000",
					"shadow": false
				}
			},
			"stickyTracking": false,
			"borderColor": "#FFFFFF",
			"borderWidth": 1,
			"borderRadius": 0,
			"groupPadding": 0.2,
			"pointPadding": 0.1,
			"minPointLength": 0,
			"threshold": 0
		},
		"bar": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": null,
				"x": 0,
				"y": null,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null
			},
			"cropThreshold": 50,
			"pointRange": null,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": 0.1,
					"shadow": false
				},
				"select": {
					"marker": {

					},
					"color": "#C0C0C0",
					"borderColor": "#000000",
					"shadow": false
				}
			},
			"stickyTracking": false,
			"borderColor": "#FFFFFF",
			"borderWidth": 1,
			"borderRadius": 0,
			"groupPadding": 0.2,
			"pointPadding": 0.1,
			"minPointLength": 0,
			"threshold": 0
		},
		"scatter": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 0,
			"marker": {
				"enabled": true,
				"lineWidth": 0,
				"radius": 4,
				"lineColor": "#FFFFFF",
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": "bottom"
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": false,
			"tooltip": {
				"headerFormat": "<span style=\"font-size: 10px; color:{series.color}\">{series.name}</span><br/>",
				"pointFormat": "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>",
				"followPointer": true
			}
		},
		"pie": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": true,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": "bottom",
				"distance": 30
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": false,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": 0.1,
					"shadow": false
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": false,
			"borderColor": "#FFFFFF",
			"borderWidth": 1,
			"center": [
				null, null
			],
			"clip": false,
			"colorByPoint": true,
			"ignoreHiddenPoint": true,
			"legendType": "point",
			"size": null,
			"slicedOffset": 10,
			"tooltip": {
				"followPointer": true
			}
		},
		"arearange": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 1,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null,
				"xLow": 0,
				"xHigh": 0,
				"yLow": 0,
				"yHigh": 0
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true,
			"threshold": null,
			"tooltip": {
				"pointFormat": "<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.low}</b> - <b>{point.high}</b><br/>"
			},
			"trackByArea": true
		},
		"areasplinerange": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 1,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null,
				"xLow": 0,
				"xHigh": 0,
				"yLow": 0,
				"yHigh": 0
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true,
			"threshold": null,
			"tooltip": {
				"pointFormat": "<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.low}</b> - <b>{point.high}</b><br/>"
			},
			"trackByArea": true
		},
		"columnrange": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 1,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null,
				"xLow": 0,
				"xHigh": 0,
				"yLow": 0,
				"yHigh": 0
			},
			"cropThreshold": 300,
			"pointRange": null,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": 0.1,
					"shadow": false
				},
				"select": {
					"marker": {

					},
					"color": "#C0C0C0",
					"borderColor": "#000000",
					"shadow": false
				}
			},
			"stickyTracking": true,
			"borderColor": "#FFFFFF",
			"borderWidth": 1,
			"borderRadius": 0,
			"groupPadding": 0.2,
			"pointPadding": 0.1,
			"minPointLength": 0,
			"threshold": null,
			"tooltip": {
				"pointFormat": "<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.low}</b> - <b>{point.high}</b><br/>"
			},
			"trackByArea": true
		},
		"gauge": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": {
				"enabled": true,
				"lineWidth": 0,
				"radius": 4,
				"lineColor": "#FFFFFF",
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": true,
				"align": "center",
				"x": 0,
				"y": 5,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "16px",
					"lineHeight": "24px",
					"fontWeight": "normal"
				},
				"verticalAlign": "top",
				"borderWidth": 0,
				"borderColor": null,
				"borderRadius": 3,
				"zIndex": 2
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": false,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true,
			"dial": {

			},
			"pivot": {

			},
			"tooltip": {
				"style": {
					"color": "#666"
				},
				"headerFormat": ""
			}
		},
		"boxplot": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 1,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": null,
				"x": 0,
				"y": null,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null
			},
			"cropThreshold": 50,
			"pointRange": null,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": -0.3,
					"shadow": false
				},
				"select": {
					"marker": {

					},
					"color": "#C0C0C0",
					"borderColor": "#000000",
					"shadow": false
				}
			},
			"stickyTracking": false,
			"borderColor": "#FFFFFF",
			"borderWidth": 1,
			"borderRadius": 0,
			"groupPadding": 0.2,
			"pointPadding": 0.1,
			"minPointLength": 0,
			"threshold": null,
			"fillColor": "#FFFFFF",
			"medianWidth": 2,
			"tooltip": {
				"pointFormat": "<span style=\"color:{series.color};font-weight:bold\">{series.name}</span><br/>Minimum: {point.low}<br/>Lower quartile: {point.q1}<br/>Median: {point.median}<br/>Higher quartile: {point.q3}<br/>Maximum: {point.high}<br/>"
			},
			"whiskerLength": "50%",
			"whiskerWidth": 2
		},
		"errorbar": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 1,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": null,
				"x": 0,
				"y": null,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null
			},
			"cropThreshold": 50,
			"pointRange": null,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": -0.3,
					"shadow": false
				},
				"select": {
					"marker": {

					},
					"color": "#C0C0C0",
					"borderColor": "#000000",
					"shadow": false
				}
			},
			"stickyTracking": false,
			"borderColor": "#FFFFFF",
			"borderWidth": 1,
			"borderRadius": 0,
			"groupPadding": 0.2,
			"pointPadding": 0.1,
			"minPointLength": 0,
			"threshold": null,
			"fillColor": "#FFFFFF",
			"medianWidth": 2,
			"tooltip": {
				"pointFormat": "<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.low}</b> - <b>{point.high}</b><br/>"
			},
			"whiskerLength": "50%",
			"whiskerWidth": null,
			"color": "#000000",
			"grouping": false,
			"linkedTo": ":previous"
		},
		"waterfall": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 1,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": null,
				"x": 0,
				"y": null,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null
			},
			"cropThreshold": 50,
			"pointRange": null,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": 0.1,
					"shadow": false
				},
				"select": {
					"marker": {

					},
					"color": "#C0C0C0",
					"borderColor": "#000000",
					"shadow": false
				}
			},
			"stickyTracking": false,
			"borderColor": "#333",
			"borderWidth": 1,
			"borderRadius": 0,
			"groupPadding": 0.2,
			"pointPadding": 0.1,
			"minPointLength": 0,
			"threshold": 0,
			"lineColor": "#333",
			"dashStyle": "dot"
		},
		"bubble": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 0,
			"marker": {
				"enabled": true,
				"lineWidth": 1,
				"radius": 4,
				"lineColor": null,
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "white",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px",
					"textShadow": "0px 0px 3px black"
				},
				"verticalAlign": "middle",
				"inside": true
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": false,
			"tooltip": {
				"headerFormat": "<span style=\"font-size: 10px; color:{series.color}\">{series.name}</span><br/>",
				"pointFormat": "({point.x}, {point.y}), Size: {point.z}",
				"followPointer": true
			},
			"minSize": 8,
			"maxSize": "20%",
			"zThreshold": 0
		}
	},
	"labels": {
		"style": {
			"position": "absolute",
			"color": "#3E576F"
		}
	},
	"legend": {
		"enabled": true,
		"align": "center",
		"layout": "horizontal",
		"borderWidth": 1,
		"borderColor": "#909090",
		"borderRadius": 5,
		"navigation": {
			"activeColor": "#274b6d",
			"inactiveColor": "#CCC"
		},
		"shadow": false,
		"itemStyle": {
			"cursor": "pointer",
			"color": "#274b6d",
			"fontSize": "12px"
		},
		"itemHoverStyle": {
			"color": "#000"
		},
		"itemHiddenStyle": {
			"color": "#CCC"
		},
		"itemCheckboxStyle": {
			"position": "absolute",
			"width": "13px",
			"height": "13px"
		},
		"symbolWidth": 16,
		"symbolPadding": 5,
		"verticalAlign": "bottom",
		"x": 0,
		"y": 0,
		"title": {
			"style": {
				"fontWeight": "bold"
			}
		}
	},
	"loading": {
		"labelStyle": {
			"fontWeight": "bold",
			"position": "relative",
			"top": "1em"
		},
		"style": {
			"position": "absolute",
			"backgroundColor": "white",
			"opacity": 0.5,
			"textAlign": "center"
		}
	},
	"tooltip": {
		"enabled": true,
		"animation": true,
		"backgroundColor": "rgba(255, 255, 255, .85)",
		"borderWidth": 1,
		"borderRadius": 3,
		"dateTimeLabelFormats": {
			"millisecond": "%A, %b %e, %H:%M:%S.%L",
			"second": "%A, %b %e, %H:%M:%S",
			"minute": "%A, %b %e, %H:%M",
			"hour": "%A, %b %e, %H:%M",
			"day": "%A, %b %e, %Y",
			"week": "Week from %A, %b %e, %Y",
			"month": "%B %Y",
			"year": "%Y"
		},
		"headerFormat": "<span style=\"font-size: 10px\">{point.key}</span><br/>",
		"pointFormat": "<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.y}</b><br/>",
		"shadow": true,
		"snap": 10,
		"style": {
			"color": "#333333",
			"cursor": "default",
			"fontSize": "12px",
			"padding": "8px",
			"whiteSpace": "nowrap"
		}
	},
	"credits": {
		"enabled": false,
		"text": "Highcharts.com",
		"href": "http://www.highcharts.com",
		"position": {
			"align": "right",
			"x": -10,
			"verticalAlign": "bottom",
			"y": -5
		},
		"style": {
			"cursor": "pointer",
			"color": "#909090",
			"fontSize": "9px"
		}
	}
};
});

define('syracuse-tablet/html/js/controls/fields/ctrlGaugeChart',['require','exports','module','syracuse-tablet/html/js/controls/fields/ctrlFieldBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/chart/gaugeChartstheme','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/fields/ctrlFieldBase').CtrlFieldBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var chartsTheme = require('syracuse-tablet/html/js/controls/chart/gaugeChartstheme').ChartsTheme;
var locale = require('syracuse-tablet/html/js/helpers/locale');

exports.CtrlGaugeChart = utils.defineClass(
	function CtrlGaugeChart(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		Base.call(this, controller, article, prototype, options);

	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			var $$chartSlot = $(".s-m-gauge-container", this.$$elmt);
			if ($$chartSlot && $$chartSlot.length > 0) {
				$$chartSlot.remove();
			}
		},

		buildFieldTitle: function(fieldSlot, buildOptions) {
			// overridden because nothing to do
		},

		_defaultGaugeSegments: [{
			propStart: 0,
			propEnd: 0.25,
			valStart: null,
			valEnd: null,
			color: '#41A940'
		}, {
			propStart: 0.25,
			propEnd: 0.75,
			valStart: null,
			valEnd: null,
			color: '#FF5800'
		}, {
			propStart: 0.75,
			propEnd: 1,
			valStart: null,
			valEnd: null,
			color: '#CB3500'
		}],
		buildHtml: function(classes) {
			classes = classes || [];
			classes.push("s-m-gauge");
			Base.prototype.buildHtml.call(this, classes);
		},
		buildFieldValue: function() {
			var localeDecimalSep = locale.getNumberDecimalSeparator();
			var localeThousandSep = locale.getNumberGroupSeparator();

			this._ensure$$value();
			this._clear$$value();

			if (!this.chartsTheme) {
				this.chartsTheme = chartsTheme;
			}
			if (!this.chartsTheme.themeWasSet || this.chartsTheme.decimalPoint !== localeDecimalSep || this.chartsTheme.thousandsSep !== localeThousandSep) {
				this.chartsTheme.decimalPoint = localeDecimalSep;
				this.chartsTheme.thousandsSep = localeThousandSep;

				Highcharts.setOptions(this.chartsTheme);
				this.chartsTheme.themeWasSet = true;
			}
		},
		computeLayout: function(context) {
			this._renderGauge();
		},
		_renderGauge: function() {
			var $$chartSlot = $(".s-m-gauge-container", this.$$value);
			if ($$chartSlot && $$chartSlot.length > 0) {
				$$chartSlot.remove();
			}

			$$chartSlot = $("<div>").addClass("s-m-gauge-container");
			this.$$value.append($$chartSlot);

			var gauge = this.article.$gauge;
			var labelColor = !this.$isEditMode ? "#34B233" : "#666";

			var val = this.getValue();
			var valMin = 0;
			var valMax = 100;

			if (gauge.$bindMin != null && gauge.$bindMax != null) {
				if (isNaN(gauge.$bindMin)) {
					valMin = this.controller.getValue(gauge.$bindMin);
				} else {
					valMin = gauge.$bindMin;
				}
				if (isNaN(gauge.$bindMax)) {
					valMax = this.controller.getValue(gauge.$bindMax);
				} else {
					valMax = gauge.$bindMax;
				}
			}

			try {
				if (typeof val === "string") val = parseFloat(val);
			} catch (e) {}
			try {
				if (typeof valMin === "string") valMin = parseFloat(valMin);
			} catch (e) {}
			try {
				if (typeof valMax === "string") valMax = parseFloat(valMax);
			} catch (e) {}

			var cp = this.prototype.json;

			var uom = "";
			if (cp.$unit && cp.$properties && cp.$properties[cp.$unit] && val && val[cp.$unit] && val[cp.$unit].$symbol) {
				uom = val[cp.$unit].$symbol;
			}

			var label = this.getTitle();
			var decimals = this._getScale();
			var plotBands = this._createBands(cp, valMin, valMax);

			this._calcDesiredHeight();
			var spacingBottom = 35;
			var height = this.desiredHeight;
			var centerA = "50%";
			var centerB = (height - 20) / height * 100 + "%";
			var size = height - 30;

			$$chartSlot.highcharts({
				chart: {
					type: 'gauge',
					plotBackgroundColor: null,
					plotBackgroundImage: null,
					plotBorderWidth: 0,
					plotShadow: false,
					backgroundColor: null,
					height: height,
					borderWidth: 0,
					spacingBottom: spacingBottom
				},
				title: {
					text: label,
					style: {
						color: labelColor,
						fontWeight: "normal",
						textTransform: "uppercase"
					},
					verticalAlign: "bottom",
					y: 27
				},
				pane: {
					startAngle: -90,
					endAngle: 90,
					center: [centerA, centerB],
					size: size,
					background: [{
						backgroundColor: '#FFF',
						borderWidth: 0
					}]
				},
				yAxis: {
					min: valMin,
					max: valMax,

					minorTickWidth: 1,
					minorTickInterval: 'auto',
					minorTickLength: 20,
					minorTickPosition: 'inside',
					minorTickColor: '#fff',

					tickPixelInterval: 30,
					tickWidth: 0,
					tickPosition: 'inside',
					tickLength: 15,
					tickColor: '#FFF',
					labels: {
						step: 1,
						rotation: 'auto',
						style: {
							color: "#666",
							cursor: "default",
							fontSize: "0.9em",
							fontFamily: "Arial",
							lineHeight: "14px"
						},
						distance: 10,
						y: 0,
						verticalAlign: 'center',
						align: 'center'
					},
					title: {
						text: uom,
						style: {
							color: "#666"
						}
					},
					plotBands: plotBands
				},
				plotOptions: {
					gauge: {
						dataLabels: {
							enabled: true,
							format: "{point.y:,." + decimals + "f}",
							style: {
								fontFamily: "Arial"
							}
						}
					}
				},
				exporting: {
					buttons: null
				},
				series: [{
					name: label,
					data: [val],
					tooltip: {
						valueSuffix: ' ' + uom
					}
				}]

			}, function() {});
		},
		_getScale: function() {
			function getScaleFromFormat($format) {
				var match = $format.match(/\.(.*)/g);
				return match.length >= 1 ? match.length : 0;
			}

			if (this.article.$scale) {
				return this.article.$scale;
			} else {
				if (this.article.$format) {
					return getScaleFromFormat(this.article.$format);
				} else {
					return 0;
				}
			}
		},
		// Create segment definitions for gauge
		_createBands: function(cp, valMin, valMax) {
			var bands = [];

			// Grey background is always present
			bands.push({
				from: valMin,
				to: valMax,
				color: '#ccc',
				innerRadius: '79%',
				outerRadius: '101%'
			});

			var data = this.getValue();
			var bandsDef = this._mergeAuthoringAndDefaults();
			var seg;
			var s;
			var band;
			var range = valMax - valMin;
			for (s = 0; s < bandsDef.length; s++) {
				seg = bandsDef[s];
				band = {
					innerRadius: '79%',
					outerRadius: '101%',
					color: seg.color
				};
				if (seg.valStart != null && seg.valEnd != null) {
					band.from = this._resolveExpr(seg.valStart, data, cp);
					band.to = this._resolveExpr(seg.valEnd, data, cp);
				} else if (seg.propStart != null && seg.propEnd != null) {
					band.from = valMin + range * this._resolveExpr(seg.propStart, data, cp);
					band.to = valMin + range * this._resolveExpr(seg.propEnd, data, cp);
				}
				bands.push(band);
			}
			return bands;
		},
		// Merge default values for gauge segments with data comming from the authoring
		_mergeAuthoringAndDefaults: function() {
			var $gauge = this.article.$gauge;
			if (!$gauge.segments) // Not authoring on segments
				return this._defaultGaugeSegments;
			if ($gauge.segments.length === 0) // Not authoring on segments
				return this._defaultGaugeSegments;

			var s, def, auth, res = [];
			for (s = 0; s < $gauge.segments.length; s++) {
				def = this._defaultGaugeSegments[Math.min(s, this._defaultGaugeSegments.length - 1)];
				auth = $gauge.segments[s];
				if (!auth) {
					// no authoring for this segment, use default
					res.push(def);
				} else {
					if ((auth.propStart == null || auth.propEnd == null) && (auth.valStart == null || auth.valEnd == null)) {
						// not range defined, use default, not authoring
						auth.propStart = def.propStart;
						auth.propEnd = def.propEnd;
						auth.valStart = def.valStart;
						auth.valEnd = def.valEnd;
					}
					if (auth.color == null) {
						auth.color = def.color;
					}
					res.push(auth);
				}
			}
			return res;
		},
		_resolveExpr: function(expr, data, cp) {
			if (typeof expr !== "string") return expr;
			return expr.replace(/\{(\w+)\}/g, function(d0, d1) {
				if (data[d1] != null) return data[d1];
				if (cp[d1] != null) return cp[d1];
				return d0;
			});
		},
		_calcDesiredHeight: function() {
			var $$pscroll = this.$$elmt.closest(".s-m-scroll-wrapper");
			var isSingleChild = $(".s-m-control", $$pscroll).length < 2;
			var isInTile = $$pscroll.closest(".s-m-tile").length > 0;

			if (isInTile && isSingleChild) {
				// if we are the only control in a tile, we use up the full space
				var $$tile = $$pscroll.parent();
				this.desiredHeight = $$tile.height() - 20; // 20 for eventual header
			} else {
				// use a default size if there are other items or we are not in a tile
				this.desiredHeight = 200;
			}
		}
	});
});

define('syracuse-tablet/html/js/controls/fields/ctrlFilter',['require','exports','module','syracuse-tablet/html/js/controls/fields/ctrlFieldBase','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/fields/ctrlFieldBase').CtrlFieldBase;
var utils = require('syracuse-tablet/html/js/helpers/utils');

/**
 * application/x-filter type - found in requests prototypes
 * Added just to not have a Unknown field -TODO see what we should do with this field
 */
exports.CtrlFilter = utils.defineClass(
	function CtrlFilter(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		Base.call(this, controller, article, prototype, options);
	}, Base, {

		buildFieldValue: function() {
			this._ensure$$value();
			this._clear$$value();
			this.appendTextValue(this.getValue() || "");
		}
	});
});

define('syracuse-tablet/html/js/controls/layouts/layoutBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').CtrlBase;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

/**
 * 
 */
exports.LayoutBase = utils.defineClass(function LayoutBase(controller, type, article, opts) {
	Base.call(this, controller, type, article, opts);
	this.title = article.$title;
}, Base, {
	destroy: function() {
		Base.prototype.destroy.call(this);
	},
	//
	// START: Rendering
	// 
	buildHtml: function() {
		this.createRootElement(["s-m-layout", "s-m-ctrl"]);

		if (this.article.$title && this.options.noTitle !== true) {
			this.buildTitle();
		}
		if (this.article.$icon && this.options.noIcon !== true) {
			this.buildIcon();
		}
	},
	_ensureHeader: function($$root) {
		if (!this.$$header) {
			this.$$header = $('<header>').prependTo($$root || this.$$elmt);
		}
		return this.$$header;
	},
	buildIcon: function($$rootLyt, $$parent, controllerDao, destroyAfter) {
		this._ensureHeader();
		var icon = fontUtils.getIconByName(this.article.$icon);
		if (icon) {
			this.$$header.addClass("s-m-has-ttl-icon").prepend('<i class="s-m-ttl-icon ' + icon + '">');
		}
	},
	buildTitle: function() {
		this._ensureHeader();
		this.$$header.find("span.title").remove();
		this.$$header.prepend('<span class="title">' + this.getArticleText("$title") + '</span>');
	},
	/**
	 * Subclasses need to give the container they want the children to be rendered in
	 * Used by this.buildChildrenHtml
	 */
	getChild$$Container: function() {
		throw new Error("Subclass must give container for children");
	},
	/**
	 * 
	 */
	buildChildrenHtml: function() {
		var self = this;
		this.isEmpty = true;

		if (this.children) {
			var $$childContainer = self.getChild$$Container();
			$.each(self.children, function(index, child) {
				child.set$$container($$childContainer);
				child.buildHtml();
				self.isEmpty = self.isEmpty && child.isEmpty;
			});
		}
		if (this.options.hideEmptyRows === true) {
			// This option allows to hide empty rows and optimize display
			this.$$elmt.toggleClass("s-m-empty", this.isEmpty);
		}
	},
	//
	// END: Rendering
	//

	createId: function(typeName) {
		return utils.readableuid(typeName);
	},
	/**
	 * Built with the rank of the layout in generation process to be reliable
	 */
	getUnitTestId: function() {
		if (this.options.index == null) return;
		return utils.unitTestId(this.typeName.toLowerCase(), this.options.index);
	},
	computeLayout: function(context) {
		if (!this.children) return;
		this.children.forEach(function(child) {
			if (child.computeLayout) {
				child.computeLayout(context);
			}
		});
	},
	// Only hub layout is able to scroll
	getGestureMgr: function() {
		return null;
	},

	isLayout: function() {
		return true;
	}
});
});

define('syracuse-tablet/html/js/controls/layouts/layoutStack',['require','exports','module','syracuse-tablet/html/js/controls/layouts/layoutBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/app/globals','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/layouts/layoutBase').LayoutBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/app/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

/**
 * cssOptions
 * 		cssLayout, cssCell: class added to default ones
 * default classes can  be overridden
 */
exports.LayoutStack = utils.defineClass(
	function LayoutStack(controller, type, article, opts) {
		var self = this;
		Base.call(self, controller, type, article, opts);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this.$$btnCollapse) {
				this.$$btnCollapse.off();
				this.$$btnCollapse = null;
			}
		},

		///
		/// START: Rendering
		///

		buildHtml: function() {
			var self = this;
			Base.prototype.buildHtml.call(self);

			self.$$elmt.addClass("s-m-stack");
			if (this.options.makeFullHeight === true) {
				self.$$elmt.height("100%");
			}
			var css = [];
			var level = this.$$container.parents(".s-m-stack").length;
			if (level) {
				var $theme = (self.article && self.article.$theme) || String.fromCharCode(96 + Math.min(level, 3));
				css.push("s-m-theme-" + $theme);
			}
			this.isAdvanced = ($theme === "advanced");

			var $collapsible = (self.article && self.article.$collapsible) || "notcollapsible";
			var $title = (this.getArticleText("$title") || "").trim();
			if ($collapsible !== "notcollapsible") {
				css.push("s-m-collapsible");
			}
			if ($title.length) {
				css.push("s-m-title");
			}
			if (css.length) {
				self.$$elmt.addClass(css.join(" "));
			}
			if ($collapsible !== "notcollapsible" || $title.length > 0) {
				self._addHeader($collapsible, $title);
			}
			self.$$content = $("<content>");
			self._setStackColorClass();
			self.$$elmt.append(self.$$content);

			self.buildChildrenHtml();
			self._updateCollapseState();
		},
		_setStackColorClass: function() {
			var self = this;
			var color = self.article.$bgColor;
			if (color) {
				self.$$content.addClass("s-m-bg s-m-color-" + color);
			}
		},
		buildTitle: function() {
			// When there is a $title attribute in the article,
			// layoutBase will create the title for all child classes
			// Since a stack layout generates a "special" title which allows collapsing, we override
			// the function here to not get two titles
		},

		_addHeader: function(state, title) {
			var self = this;
			self.$$header = $('<header>') //.text(title);
			if (state !== "notcollapsible") {
				/* We don't use data-action because collapse button must work in authoring mode - data-action click handler is overridden by select authoring handler */
				self.$$btnCollapse = $('<btn class="' + state + ' ' + fontUtils.layoutExpandCollapseIcon(state === "collapsed", this.isAdvanced) + '">').appendTo(self.$$header);
				self.$$header.on("click", jsutils.bindFn(this._actCollapse, this));
			}
			var $$title = $('<div class="s-m-title">');
			$$title.append(title);
			self.$$elmt.append(self.$$header);
			self.$$header.append($$title);
		},
		getChild$$Container: function() {
			return this.$$content;
		},

		///
		/// END: Rendering
		///

		_actCollapse: function(events, setCollapse) {
			// Propagate to authoring for selection
			if (events && !globals.isAuthoringActive()) {
				events.stopPropagation();
			}
			if (!this.$$btnCollapse) return;
			if (setCollapse === true) {
				this.$$btnCollapse.removeClass("expanded " + fontUtils.layoutExpandCollapseIcon(setCollapse, this.isAdvanced)).addClass("collapsed " + fontUtils.layoutExpandCollapseIcon(!setCollapse, this.isAdvanced));
			} else if (setCollapse === false) {
				this.$$btnCollapse.removeClass("collapsed " + fontUtils.layoutExpandCollapseIcon(!setCollapse, this.isAdvanced)).addClass("expanded " + fontUtils.layoutExpandCollapseIcon(setCollapse, this.isAdvanced));
			} else {
				this.$$btnCollapse.toggleClass("collapsed " + fontUtils.layoutExpandCollapseIcon(setCollapse, this.isAdvanced)).toggleClass("expanded " + fontUtils.layoutExpandCollapseIcon(!setCollapse, this.isAdvanced));
			}
			this._updateCollapseState();
			if (!this.$$btnCollapse.hasClass("collapsed")) {
				/**
				 * We need to notify elements like array to refresh them - They are not displayed if !.is(":visible")
				 */
				notifications.publish("sm.layout.expanded");
			}
			/**
			 * We need to update the scroller because height has changed
			 */
			this.page.notifyScrollerUpdate();
		},

		_updateCollapseState: function() {
			var self = this;
			if (!self.$$btnCollapse || !self.$$content) {
				return;
			}
			var collapse = self.$$btnCollapse.hasClass("expanded");
			self.$$content.toggle(collapse);
		},

		getAuthState: function(dirtyKeys) {
			var self = this;
			// If collapsed state has been changed, we do not store that state
			if (dirtyKeys.$collapsible) {
				return null;
			}
			return {
				collapsed: self.$$btnCollapse ? self.$$btnCollapse.hasClass("collapsed") : false
			};
		},

		setAuthState: function(state) {
			if (state && state.collapsed != null) {
				this._actCollapse(null, state.collapsed);
			}
		}
	});
});

define('syracuse-tablet/html/js/controls/layouts/layoutRow',['require','exports','module','syracuse-tablet/html/js/controls/layouts/layoutBase','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/layouts/layoutBase').LayoutBase;
var utils = require('syracuse-tablet/html/js/helpers/utils');

/**
 * 
 */
exports.LayoutRow = utils.defineClass(

	function LayoutRow(controller, type, article, opts) {
		var self = this;
		Base.call(self, controller, type, article, opts);
	}, Base, {

		buildHtml: function() {
			Base.prototype.buildHtml.call(this);

			this.$$elmt.addClass("s-m-row row");
			this._setRowColorClass();

			this.buildChildrenHtml();

			if (this.$$elmt.is(":empty")) {
				this.$$elmt.hide();
			}
		},
		_setRowColorClass: function() {
			var self = this;
			var color = self.article.$bgColor;
			if (color) {
				self.$$elmt.addClass("s-m-bg s-m-color-" + color);
			}
		},
		getChild$$Container: function() {
			return this.$$elmt;
		},
	}
);
});

define('syracuse-tablet/html/js/controls/layouts/layoutCell',['require','exports','module','syracuse-tablet/html/js/controls/layouts/layoutBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/uiSettings'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/layouts/layoutBase').LayoutBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var uiSettings = require('syracuse-tablet/html/js/ui/uiSettings');

var _sizes = [{
	$prop: "$widthXs",
	$prefix: "col-xs-",
	$def: 12
}, {
	$prop: "$widthSm",
	$prefix: "col-sm-",
	$def: 6
}, {
	$prop: "$widthMd",
	$prefix: "col-md-",
	$def: 4
}, {
	$prop: "$widthLg",
	$prefix: "col-lg-",
	$def: 3
}];

exports.LayoutCell = utils.defineClass(function LayoutCell(controller, type, article, opts) {
	Base.call(this, controller, type, article, opts);
	// Set the default color - Forced to be modified by authoring
	if (article.$bgColor == null) {
		article.$bgColor = uiSettings.getProp("colors.CELLDEFCOLOR");
	}
	article.$bgColor = article.$bgColor.toLowerCase();
}, Base, {
	buildHtml: function() {
		Base.prototype.buildHtml.call(this);

		this.$$elmt.addClass("s-m-cell");
		this.$$cell = $(uiUtils.createDomElement("div", ["cell"], null, null, this.$$elmt));

		this._setCellColorClass();
		this._setCellSizeClasses();

		this.buildChildrenHtml();
	},
	getChild$$Container: function() {
		return this.$$cell;
	},
	_setCellColorClass: function() {
		var bg = this.article.$bgColor;
		if (bg === "transparent" || bg.length === 0) {
			// No color if bg == "" or transparent color for compatibility
			return;
		}
		this.$$cell.addClass("s-m-bg s-m-color-" + bg);
	},
	_setCellSizeClasses: function() {
		var self = this;
		if (self.article.$sameSize !== true) {
			var widthFound = false;
			var sizes = [],
				sz;
			_sizes.forEach(function(size) {
				sz = self.article[size.$prop];
				if (sz != null && sz >= 1 && sz <= 12) {
					sizes.push(size.$prefix + sz);
				};
			});
			if (sizes.length == 0) {
				self.article.$sameSize = true;
				self.article.$widthAll = 12;
			}
		}
		if (self.article.$sameSize === true) {
			if (self.article.$widthAll == null) self.article.$widthAll = 12;
			sizes = ["col-xs-" + Math.min(12, Math.max(1, self.article.$widthAll), self.article.$widthAll)];
		}
		self.$$elmt.addClass(sizes.join(" "));
	},
	_ensureHeader: function() {
		// header is created under $$cell - used by vignette to display icon on/off like in tiles
		return Base.prototype._ensureHeader.call(this, this.$$cell);
	},
	/**
	 * Used to adapt the behavior according to the kind of hhosted array
	 * typeArray: chart/carousel
	 * Chart:
	 * 	remove the default color for charts
	 * 	Hack: Done by programming since we don't manage default color by css
	 * 	Add s-m-chart to tune display fo these tiles by css
	 * Carousel:
	 * 	Remove fixed height
	 */
	notifSpecialArrayHosted: function(typeArray) {
		if (!this.$$cell) return;
		if (typeArray === "chart") {
			this.$$cell.removeClass("s-m-bg s-m-color-" + this.article.$bgColor);
			this.$$elmt.addClass("s-m-chart");
		} else if (typeArray === "carousel") {
			this.$$elmt.addClass("s-m-carousel");
		}
	}
});
});

define('syracuse-tablet/html/js/controls/layouts/layoutHub',['require','exports','module','syracuse-tablet/html/js/controls/layouts/layoutBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiSettings','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/scroller/scrollerHelpers'],function (require, exports, module) {


var Base = require('syracuse-tablet/html/js/controls/layouts/layoutBase').LayoutBase;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiSettings = require('syracuse-tablet/html/js/ui/uiSettings');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');

/**
 * Top level layout node that must only contain layoutHubGroups as children
 * This "hub" expands horizontally and only uses the available vertical space
 * Use this to define pages which only scroll horizontally
 */
exports.LayoutHub = utils.defineClass(
	function LayoutHub(controller, type, article, opts) {
		var self = this;
		Base.call(self, controller, type, article, opts);
		this._gestureMgr = null;
		this._tilesGroupSpacing = uiSettings.getProp("hubLayout.groupSpacing");
		this._minLandscapeHeigth = uiSettings.getProp("hubLayout.landscapeMinHeigth");
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},

		buildHtml: function() {
			var self = this;
			Base.prototype.buildHtml.call(self);
			self.$$elmt.addClass("s-m-hub");
			self.$$scrollElmt = $('<div class="s-m-scroll-elmt">').appendTo(self.$$elmt);
			self.buildChildrenHtml();
			if (self._gestureMgr) {
				self._gestureMgr.destroy();
			}
			/**
			 * New $$scrollElmt -> New scroller
			 */
			self._gestureMgr = scroller.newScroller(self.$$scrollElmt, {
				isPageScroller: true
			});
		},

		getChild$$Container: function() {
			return this.$$scrollElmt;
		},

		computeLayout: function(context) {
			var self = this;
			/**
			 * Returns the visible rectangle of main page content
			 *
			 */
			var parentRect = context.pageContentNoPaddingRect;
			var pos = self.$$elmt.position();

			var w = parentRect.width;
			var h = parentRect.height - pos.top; // - 10;

			var rel = w / h;
			var posX = 0;
			var posY = 0;
			var opts;
			/* Layout orientation */
			self.scrollDirection = (rel > 1.2 && h >= this._minLandscapeHeigth) ? "h" : "v";
			if (self.scrollDirection === "h") {
				self.$$elmt.css({
					width: "100%",
					height: h + "px"
				});
			} else {
				self.$$elmt.css({
					width: w + "px",
					height: "100%"
				});
			}
			if (self.children) {
				var last = self.children.length - 1;
				self.children.forEach(function(child, idx) {
					opts = {
						posX: posX,
						posY: posY,
						maxHeight: h,
						maxWidth: w,
						scrollDirection: self.scrollDirection,
						allowSmallTiles: rel > 1.2
					};
					child.computeLayout(context, opts);
					if (self.scrollDirection === "h") {
						posX += child.getWidth() + (idx < last ? self._tilesGroupSpacing : 0);
					} else {
						posY += child.getHeight() + (idx < last ? self._tilesGroupSpacing : 0);
					}
				});
			}
			var width, height;
			if (self.scrollDirection === "h") {
				width = posX;
				height = h;
			} else {
				width = w;
				height = posY;
			}
			var oldScroll = null;
			if (context && context.preserveScroll === true) {
				oldScroll = self._gestureMgr.getScroll();
			}
			// reset old scrolling to calculate width/height (mandatory in native mode)
			self._gestureMgr.reset();
			self.$$scrollElmt.width(width);
			self.$$scrollElmt.height(height);
			var scrollRect = uiRect.elmtRect(self.$$scrollElmt, "outer");
			var viewRect = parentRect.intersectRect(scrollRect);
			viewRect != null && !viewRect.contains(scrollRect) ? viewRect : null;
			if (!viewRect) return;
			self._gestureMgr.init(viewRect, self.scrollDirection, 0);
			if (oldScroll != null) {
				self._gestureMgr.autoScroll(oldScroll);
			}
		},
		/**
		 * layout hub gesture manager is the gesture manager of the dashboard
		 * in dashborad we don't scroll the whole page but just the content ofthe layout hub
		 * This method returns the _gestureMgr attached to the dashboard
		 */
		getGestureMgr: function() {
			return this._gestureMgr;
		},
		/**
		 * Context to store when dashboard is destroyed
		 * We save gesture manager context (scroll)
		 */
		savedCtxCreate: function(opts) {
			return this._gestureMgr ? {
				hubScroll: this._gestureMgr.savedCtxCreate(opts)
			} : null;
		},
		/**
		 * Restore the context for the hublayout
		 */
		savedCtxRestore: function(ctx) {
			if (ctx != null && this._gestureMgr) {
				// Restore the scroll of hub layout
				this._gestureMgr.savedCtxRestore(ctx.hubScroll);
			}
		},
	});
});

define('syracuse-tablet/html/js/controls/layouts/layoutHubGroup',['require','exports','module','syracuse-tablet/html/js/controls/layouts/layoutBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/app/globals','syracuse-tablet/html/js/ui/uiSettings','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/layouts/layoutBase').LayoutBase;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/app/globals');
var uiSettings = require('syracuse-tablet/html/js/ui/uiSettings');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var modules = require('syracuse-tablet/html/js/common/modules');

var _validSizes = ["small", "medium", "wide", "large", "full", "all"];

/**
 * Layout node that can only be used inside layoutHub parent nodes
 * Renders a group of tiles using the available space from top to bottom and then wraps to the right
 * Child elements bound to this layout may set "$size" attribute to define their size:
 * - small		- four tiles will fit into one group from left to right
 * - medium		- two tiles fit into one group from left to right, also double height of "small"
 * - wide		- one tile fits into one group from left to right, same height as "medium"
 * - large		- same width as "wide" and double height of "wide"/"medium"
 * - full		- same width as "wide", uses one full column (rounded to tile size medium)
 */
exports.LayoutHubGroup = utils.defineClass(
	function LayoutHubGroup(controller, type, article, opts) {
		var self = this;
		Base.call(self, controller, type, article, opts);
		self._settings = uiSettings.getProp("hubGroup");
		self.isEditable = self._getCapability("edit");
		self.isDeletable = self._getCapability("delete");
		self.isDraggable = self._getCapability("draggable");
	}, Base, {
		/**
		 * Build full html structed but do not yet apply position and size attributes (Will be done in a later step or on resize)
		 */
		buildHtml: function() {
			var self = this;
			Base.prototype.buildHtml.call(self);
			self.$$elmt.addClass("s-m-hub-group");
			self.$$separator = $(uiUtils.createDomElement("div", null, null, null, self.$$elmt));
			self.$$separator.addClass("s-m-hub-group-separator");
			self._buildCellStructure();
		},

		buildTitle: function() {
			var self = this;
			if (self.options.groupActions == null) {
				Base.prototype.buildTitle.call(self);
			} else {
				self.buildTitleActions();
			}
		},

		buildTitleActions: function() {
			var self = this;

			this._ensureHeader();
			this.$$input = $("<input data-nevent-ctrl-change>");
			this.$$input.val(this.getArticleText("$title"));
			this.$$header.append(this.$$input);
			this.$$header.addClass("edit");
			var $$actions = $('<div class="s-m-group-actions">');
			this.$$header.append($$actions);
			self.options.groupActions.forEach(function(action) {
				var actionAttrs = action.disabled === true ? "" : ('" data-nevent data-naction="' + action.action + '" data-params="' + self.id + '"');
				var className = action.className + (action.disabled === true ? " disabled" : "");
				var $$btn = $('<btn class="cfg ' + action.icon + ' ' + className + '" ' + actionAttrs + '></btn>');
				$$actions.append($$btn);
			});
		},
		onChange: function() {
			var title = this.$$input.val();
			if (this.getArticleText("$title") !== title) {
				var uuid = this.getArticleTextUUID("$title") || utils.UUID();
				this.article.$title = '{@' + uuid + '}';
				this.page && this.page.onGroupTitleChanged && this.page.onGroupTitleChanged(this, uuid, title);
			}
		},
		_buildCellStructure: function() {
			var self = this;
			self.cells = [];
			var cell = null;
			var notLinksCpt = 0;
			var index = 0
			if (self.children) {
				self.children.forEach(function(layout) {
					if (layout.isLinkVignette == null || layout.isLinkVignette() !== true) {
						notLinksCpt++;
					}
					var size = (layout.article && layout.article.$size) || "medium";
					if (_validSizes.indexOf(size) < 0) {
						size = _validSizes[1];
						layout.article = layout.article || {};
						layout.article.$size = size;
					}
					if (!cell) {
						cell = self._createCell(size);
						cell.domItem = uiUtils.createDomElement("div", null, null, null, self.$$elmt);
						self.cells.push(cell);
					}
					if (size === "small") {
						layout.set$$container($(cell.domItem));
						layout.buildHtml();
						cell.children.push(layout);
						if (cell.children.length === 4) {
							cell = null;
						}
					} else {
						if (cell.children.length > 0) {
							cell = self._createCell(size);
							cell.domItem = uiUtils.createDomElement("div", null, null, null, self.$$elmt);
							self.cells.push(cell);
						}
						layout.set$$container($(cell.domItem));
						layout.buildHtml();
						cell.children.push(layout);
						cell = null;
					}
					index++;
				});
			} else {
				self.$$elmt.addClass("empty"); //empty group
			}
			if (self.options.showAddTiles) {
				var cell = self._createCell("medium");
				var opts = {
					icon: fontUtils.dashboardIcon("addHiddenTile"),
					title: locale.text("welcome.dashboard.add.hiddenTile"),
					action: 'addHiddenTile',
					css: 's-m-tile-action s-m-color-tile-action medium',
					params: self.id,
				};
				self._addActionTile(cell, opts);
				self.cells.push(cell);
			}
			// True if the group contains only links
			self._linksOnly = notLinksCpt === 0;
		},
		_addActionTile: function(cell, opts) {
			var self = this;
			var optsAction = {
				"data-nevent": "",
				"data-naction": opts.action,
				"data-params": opts.params,
			};
			cell.domItem = uiUtils.createDomElement("div", null, null, optsAction, self.$$elmt);
			var addTile = uiUtils.createDomElement("div", opts.css, null, null, cell.domItem);
			$(addTile).append('<section class="s-m-icon"><div><div class="s-m-sage-app-icon ' + opts.icon + '"></div></div></section>');
			$(addTile).append('<section class="s-m-title"><div>' + opts.title + '</div></section>')
		},
		_createCell: function(size) {
			var self = this;
			size = (size === "small" ? "medium" : size);
			var cell = {
				size: size,
				children: []
			};
			return cell;
		},

		/*
		 * Options set by layoutHub with sizes
		 */
		computeLayout: function(context, options) {
			this.calculateLayout(options);
			Base.prototype.computeLayout.call(this, context);
		},

		calculateLayout: function(options) {
			var self = this;
			var size, index = 0;
			var scale = modules.get("siteLayout").getTransformScale();
			self._headerSpace = self.$$header ? self.$$header.height() / scale : 0;
			self._width = 0;
			self._height = 0;

			self.hubGroupOptions = options || self.hubGroupOptions;
			self.$$elmt.removeClass("s-m-hub-group-v s-m-hub-group-h")
			self.$$elmt.addClass("s-m-hub-group-" + self.hubGroupOptions.scrollDirection)
			if (self.hubGroupOptions.scrollDirection === "h") {
				self._calculateLayoutHorizontal();
			} else {
				self._calculateLayoutVertical();
			}
			// in case of empty group
			self._width = (4 * self.hubGroupOptions.baseSize + 6)
			self._height = 2 * self.hubGroupOptions.baseSize

			self.cells.forEach(function(cell) {
				size = cell.size;
				cell.domItem.style.left = cell.x + "px";
				cell.domItem.style.top = (cell.y + self._headerSpace) + "px";
				cell.domItem.style.width = (self._sizes[size].width + 2) + "px";
				cell.domItem.style.height = (self._sizes[size].height + 2) + "px";
				cell.domItem.style.position = "absolute";

				$(cell.domItem).attr("data-cellIndex", index);
				$(cell.domItem).attr("coord", cell.abs + "," + cell.ord);
				$(cell.domItem).attr("silo", cell.silo);
				$(cell.domItem).attr("size", cell.size);
				if (cell.x + self._sizes[size].width > self._width) {
					self._width = cell.x + self._sizes[size].width;
				}
				if (cell.y + self._sizes[size].height > self._height) {
					self._height = cell.y + self._sizes[size].height;
				}

				/* Keep this to debug
				cell.domItem.style.border = "1px dotted red";
				var contentInfo=cell.size.substr(0,3) + " i:"+index + " x:" +cell.abs + " y:" + cell.ord + " s:"+cell.silo
				var info = uiUtils.createDomElement("div", null, contentInfo, null, cell.domItem);
				info.style.position = "absolute";
				info.style.border = "1px dotted red";
				info.style.left = "2px";
				info.style.top ="2px";
				info.style.width ="97%"
				info.style.backgroundColor ="white";
				info.style.zIndex ="1000";
				info.style.overFlow ="hidden";
				*/
				var x = 0;
				var y = 0;
				cell.children.forEach(function(tileLayout) {
					size = tileLayout.getAuthoringSize();
					tileLayout.calculateLayout(x, y, size, self._sizes[size]);
					if (x !== 0) {
						x = 0;
						y += self._sizes[size].height + self.hubGroupOptions.padY;
					} else {
						x += self._sizes[size].width + self.hubGroupOptions.padX;
					}
				});
				index++;
			});

			var style = self.$$elmt.get(0).style;

			if (self.hubGroupOptions.scrollDirection === "h") {
				if (self.cells.length < 1 && globals.isAuthoringActive()) {
					self._width = self.hubGroupOptions.maxGroupWidth;
				}
				style.top = "0px";
				style.left = self.hubGroupOptions.posX + "px";
				style.width = 6 + self._width + "px";
				style.height = (self.hubGroupOptions.maxHeight - 6) + "px";
			} else {
				if (self.cells.length < 1 && globals.isAuthoringActive()) {
					self._height = self.hubGroupOptions.baseSize;
				}
				style.top = self.hubGroupOptions.posY + "px";
				style.left = "0px";
				self._width = self.hubGroupOptions.maxGroupWidth //self._width;
				style.width = self.hubGroupOptions.maxGroupWidth + "px" //self._width + "px";
				self._height += self._headerSpace + self._settings.portraitPadY;
				style.height = self._height + "px";
				if (self.cells.length < 1 && globals.isAuthoringActive()) {

				}
			}
		},

		/**
		 * Calc tile positions in horizontal scrolling model
		 */
		_calculateLayoutHorizontal: function() {
			var self = this;
			var padSilo = 0;
			// Asume default base size
			self.hubGroupOptions.baseSize = self._settings.landscapeBaseSize;
			self.hubGroupOptions.padX = self._settings.landscapePadX;
			self.hubGroupOptions.padY = self._settings.landscapePadY;
			self.hubGroupOptions.maxGroupHeight = self.hubGroupOptions.maxHeight - self._headerSpace; //- 6;

			// How many tiles fit vertically?
			var maxTiles = self.hubGroupOptions.maxGroupHeight / (self.hubGroupOptions.baseSize + self.hubGroupOptions.padY);
			var remainPixels = self.hubGroupOptions.maxGroupHeight - Math.floor(maxTiles) * (self.hubGroupOptions.baseSize + self.hubGroupOptions.padY);
			var remainPerTile = Math.floor(remainPixels / maxTiles);
			var paddingPerTile = Math.floor(remainPixels / maxTiles / 2);
			self.hubGroupOptions.baseSize += remainPerTile;
			self.hubGroupOptions.paddingPerTile = paddingPerTile;

			self.hubGroupOptions.maxGroupWidth = 4 * self.hubGroupOptions.baseSize + 3 * self.hubGroupOptions.padX;

			self.hubGroupOptions.maxFullTileHeight = self.hubGroupOptions.maxGroupHeight - self.hubGroupOptions.padY; //Math.floor((self.hubGroupOptions.maxGroupHeight + self.hubGroupOptions.padY) / (self.hubGroupOptions.baseSize + self.hubGroupOptions.padY) / 2) * (self.hubGroupOptions.baseSize + self.hubGroupOptions.padY) * 2 - self.hubGroupOptions.padY;
			self.hubGroupOptions.maxAllTileHeight = self.hubGroupOptions.maxFullTileHeight;
			self.hubGroupOptions.maxAllTileWidth = self.hubGroupOptions.maxWidth; //Math.floor((self.hubGroupOptions.maxWidth + self.hubGroupOptions.padX) / (self.hubGroupOptions.baseSize + self.hubGroupOptions.padX) / 2) * (self.hubGroupOptions.baseSize + self.hubGroupOptions.padX) * 2 - self.hubGroupOptions.padX;

			self._sizes = {
				small: {
					width: self.hubGroupOptions.baseSize,
					height: self.hubGroupOptions.baseSize,
					paddingX: self.hubGroupOptions.paddingPerTile,
					paddingY: self.hubGroupOptions.paddingPerTile
				},
				medium: {
					width: self.hubGroupOptions.baseSize * 2 + self.hubGroupOptions.padX,
					height: self.hubGroupOptions.baseSize * 2 + self.hubGroupOptions.padY,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 2,
					paddingY: self.hubGroupOptions.paddingPerTile, // * 2,
				},
				wide: {
					width: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padX * 3,
					height: self.hubGroupOptions.baseSize * 2 + self.hubGroupOptions.padY,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 4,
					paddingY: self.hubGroupOptions.paddingPerTile, // * 2,
				},
				large: {
					width: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padX * 3,
					height: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padY * 3,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 4,
					paddingY: self.hubGroupOptions.paddingPerTile, // * 4,
				},
				full: {
					width: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padX * 3,
					height: self.hubGroupOptions.maxFullTileHeight,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 4,
					paddingY: self.hubGroupOptions.paddingPerTile,
				},
				all: {
					height: self.hubGroupOptions.maxAllTileHeight,
					width: self.hubGroupOptions.maxAllTileWidth,
					paddingX: self.hubGroupOptions.paddingPerTile,
					paddingY: self.hubGroupOptions.paddingPerTile,
				}
			};

			var relX = 0;
			var relY = 0;
			var x = 0;
			var y = 0;
			var prevOrd = 0;
			var silo = 0;
			self.cells.forEach(function(cell) {
				cell.w = self._sizes[cell.size].width;
				cell.h = self._sizes[cell.size].height;
				if ((y + cell.h > self.hubGroupOptions.maxGroupHeight) ||
					(y !== 0 && (cell.size === "full" || cell.size === "all"))) // full/all size cell always use one full column 
				{
					y = 0;
					relX += self.hubGroupOptions.maxGroupWidth + self.hubGroupOptions.padX + padSilo;
					x = relX;
				}
				if (cell.size === "medium") {
					if ((x - relX) + cell.w > self.hubGroupOptions.maxGroupWidth) {
						x = relX;
						y += cell.h + self.hubGroupOptions.padY;
					}
					if (y + cell.h > self.hubGroupOptions.maxGroupHeight) {
						y = 0;
						relX += self.hubGroupOptions.maxGroupWidth + self.hubGroupOptions.padX + padSilo;
						x = relX;
					}
					cell.x = x;
					cell.y = y;
					x += cell.w + self.hubGroupOptions.padX;
				} else {
					if (x !== relX) {
						x = relX;
						y += self._sizes.medium.height + self.hubGroupOptions.padY;
					}
					if (y + cell.h > self.hubGroupOptions.maxGroupHeight) {
						y = 0;
						relX += self.hubGroupOptions.maxGroupWidth + self.hubGroupOptions.padX + padSilo;
						x = relX;
					}
					cell.x = x;
					cell.y = y;
					y += cell.h + self.hubGroupOptions.padY;

					if (cell.size === "all") {
						y = 0;
						relX += cell.w + self.hubGroupOptions.padX;
						x = relX;
					}
				}

				cell.abs = Math.round(cell.x / ((self.hubGroupOptions.baseSize * 2) + self.hubGroupOptions.padX))
				cell.ord = Math.round(cell.y / ((self.hubGroupOptions.baseSize * 2) + self.hubGroupOptions.padY))
				if (cell.ord === 0 && cell.ord !== prevOrd) {
					silo++
				}
				cell.silo = silo;
				prevOrd = cell.ord;

			});
		},

		/**
		 * Calc tile positions in vertical scrolling model
		 */
		_calculateLayoutVertical: function() {
			var self = this;
			var centerPadX;
			self.hubGroupOptions.paddingPerTile = 0;
			self.hubGroupOptions.maxGroupHeight = self.hubGroupOptions.maxHeight - self._headerSpace;
			self.hubGroupOptions.padX = self._settings.portraitPadX;
			self.hubGroupOptions.padY = self._settings.portraitPadY;
			self.hubGroupOptions.maxFullTileHeight = self.hubGroupOptions.maxGroupHeight - self.hubGroupOptions.padY;
			var small = false;
			if (self.hubGroupOptions.maxWidth >= self._settings.portraitWideMinWidth ||
				(self.hubGroupOptions.allowSmallTiles === true && self._linksOnly === true)) {
				// #7898 allowSmallTiles & _linksOnly -> A group with only links - display smaller tiles - We have more freedom to show more tiles
				// Tablet default, display maximum of 8 tiles in a row in portrait mode
				self.hubGroupOptions.baseSize = Math.floor((self.hubGroupOptions.maxWidth - 7 * self.hubGroupOptions.padX) / 8);
				self.hubGroupOptions.maxGroupWidth = 8 * self.hubGroupOptions.baseSize + 7 * self.hubGroupOptions.padX;
			} else {
				// For smaller devices: display maximum of 4 tiles in a row in portrait mode
				self.hubGroupOptions.baseSize = Math.floor((self.hubGroupOptions.maxWidth - 3 * self.hubGroupOptions.padX) / 4);
				self.hubGroupOptions.maxGroupWidth = 4 * self.hubGroupOptions.baseSize + 3 * self.hubGroupOptions.padX;
			}
			self.hubGroupOptions.maxAllTileHeight = self.hubGroupOptions.maxFullTileHeight;
			self.hubGroupOptions.maxAllTileWidth = self.hubGroupOptions.maxWidth; //Math.floor((self.hubGroupOptions.maxWidth + self.hubGroupOptions.padX) / (self.hubGroupOptions.baseSize + self.hubGroupOptions.padX) / 2) * (self.hubGroupOptions.baseSize + self.hubGroupOptions.padX) * 2 - self.hubGroupOptions.padX;
			centerPadX = (self.hubGroupOptions.maxWidth - self.hubGroupOptions.maxGroupWidth) / 2;
			self.hubGroupOptions.maxGroupWidth += centerPadX;

			self._sizes = {
				small: {
					width: self.hubGroupOptions.baseSize,
					height: self.hubGroupOptions.baseSize,
					paddingX: self.hubGroupOptions.paddingPerTile,
					paddingY: self.hubGroupOptions.paddingPerTile,
				},
				medium: {
					width: self.hubGroupOptions.baseSize * 2 + self.hubGroupOptions.padX,
					height: self.hubGroupOptions.baseSize * 2 + self.hubGroupOptions.padY,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 2,
					paddingY: self.hubGroupOptions.paddingPerTile, // * 2
				},
				wide: {
					width: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padX * 3,
					height: self.hubGroupOptions.baseSize * 2 + self.hubGroupOptions.padY,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 4,
					paddingY: self.hubGroupOptions.paddingPerTile, // * 2
				},
				large: {
					width: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padX * 3,
					height: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padY * 3,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 4,
					paddingY: self.hubGroupOptions.paddingPerTile, // * 4
				},
				full: {
					width: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padX * 3,
					height: self.hubGroupOptions.maxFullTileHeight,
					paddingX: self.hubGroupOptions.paddingPerTile,
					paddingY: self.hubGroupOptions.paddingPerTile
				},
				all: {
					width: self.hubGroupOptions.maxAllTileWidth,
					height: self.hubGroupOptions.maxAllTileHeight,
					paddingX: self.hubGroupOptions.paddingPerTile,
					paddingY: self.hubGroupOptions.paddingPerTile
				}
			};

			var x = centerPadX;
			var y = 0;
			var yInc = 0;
			self.cells.forEach(function(cell) {
				cell.w = self._sizes[cell.size].width;
				cell.h = self._sizes[cell.size].height;

				cell.x = x;
				cell.y = y;

				if (x + cell.w > self.hubGroupOptions.maxGroupWidth) {
					x = centerPadX;
					y += yInc + self.hubGroupOptions.padY;
					cell.x = x;
					cell.y = y;
					yInc = cell.h;
					x += cell.w + self.hubGroupOptions.padX;
				} else {
					x += cell.w + self.hubGroupOptions.padX;
					yInc = cell.h > yInc ? cell.h : yInc;
				}
				cell.abs = Math.round(cell.x / ((self.hubGroupOptions.baseSize * 2) + self.hubGroupOptions.padX))
				cell.ord = Math.round(cell.y / ((self.hubGroupOptions.baseSize * 2) + self.hubGroupOptions.padY))
				cell.silo = 0
			});
		},
		getTitle: function() {
			return this.getArticleText("$title");
		},
		_getCapability: function(capability) {
			return (this.article.$capabilities && (this.article.$capabilities.indexOf(capability) > -1));
		},
		getWidth: function() {
			return this._width;
		},
		getHeight: function() {
			return this._height;
		}
	});
});

define('syracuse-tablet/html/js/controls/layouts/layoutTile',['require','exports','module','syracuse-tablet/html/js/controls/layouts/layoutBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/ui/uiSettings'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/layouts/layoutBase').LayoutBase;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var uiSettings = require('syracuse-tablet/html/js/ui/uiSettings');

exports.LayoutTile = utils.defineClass(function LayoutTile(controller, type, article, opts) {
	Base.call(this, controller, type, article, opts);
	// Set the default color - Forced to be modified by authoring	
	if (article.$bgColor == null) {
		article.$bgColor = uiSettings.getProp("colors.TILEDEFCOLOR");
	}
	article.$bgColor = article.$bgColor.toLowerCase();
}, Base, {

	initReuseProperties: function() {
		Base.prototype.initReuseProperties.call(this);
	},
	buildHtml: function() {
		var self = this;
		Base.prototype.buildHtml.call(self);
		self.$$elmt.addClass("s-m-tile");
		self._setCellColorClass();
		self.buildChildrenHtml();
		if (self.isEmpty /*Don't know why so remove it : && this.article.$items && this.article.$items.length > 1*/ ) {
			self._buildEmptyTile();
		}
		self._checkAddActionButtons();
	},

	getChild$$Container: function() {
		return this.$$elmt;
	},

	_buildEmptyTile: function() {
		var $$container = this.getChild$$Container();
		$$container.css({
			"display": "table",
			"table-layout": "fixed",
			"text-align": "center"
		});
		var $bind = null;
		if (this.article.$items && this.article.$items.length > 0) {
			$bind = this.article.$items[0].$bind;
		}
		var html = [];
		html.push('<section class="s-m-icon" style="display:table-row;height:100%;">');
		html.push('<div style="display:table-cell;vertical-align: middle;">');
		html.push('<div class="s-m-sage-app-icon ');
		html.push(fontUtils.dashboardIcon("emptyTile"));
		html.push('"></div>');
		html.push('</div></section>');
		html.push('<section class="s-m-title">');
		if ($bind != null && jsutils.isDvlpVersion()) {
			html.push('<span style="font-size:smaller;white-space:nowrap;">' + $bind + '</span><br>')
		}
		var textName = "gadget.not.found";
		if (jsutils.isInstanceOf(this.page, "PageHome")) {
			textName = "welcome.dashboard.emptyTile";
		}
		html.push('<div>' + locale.text(textName) + '</div></section>')
		$$container.append(html.join(''));
	},
	_setCellColorClass: function() {
		var bg = (this.article.$bgColor || "").toLowerCase();
		if (bg === "transparent" || bg.length === 0) {
			// No color if bg == "" or transparent color for compatibility
			return;
		}
		bg = "s-m-color-" + bg;
		this.$$elmt.addClass("s-m-bg " + bg);
	},
	/**
	 * Set attribute according to sizeInfo given by layoutHub
	 * Shit (padding top) if there's a title
	 */
	calculateLayout: function(x, y, authSize, sizeInfo) {
		var css = {
			left: x + "px",
			top: y + "px",
			width: sizeInfo.width + "px",
			height: sizeInfo.height + "px",
			position: "absolute",
			"padding-left": sizeInfo.paddingX + "px",
			"padding-right": sizeInfo.paddingX + "px",
			"padding-bottom": sizeInfo.paddingY + "px",
			"padding-top": ((this.$$header ? this.$$header.height() : 0) + sizeInfo.paddingY) + "px"
		};
		this.$$elmt.css(css);
		this.$$elmt.addClass(authSize);
	},
	getAuthoringSize: function() {
		return (this.article && this.article.$size) || "medium";
	},
	/**
	 * Called only for arrays nested in query/stats/requests
	 * Used to adapt the behavior according to the kind of hosted array
	 * typeArray: chart/carousel
	 * Chart:
	 * 	remove the default color for charts
	 * 	Hack: Done by programming since we don't manage default color by css
	 * 	Add s-m-chart to tune display fo these tiles by css
	 * Carousel:
	 * 	Remove fixed height - To improve
	 */
	notifSpecialArrayHosted: function(typeArray) {
		if (!this.$$elmt) return;
		// For authoring we can switch from carousel to chart to table...
		this.$$elmt.removeClass("s-m-carousel s-m-chart");
		if (typeArray === "carousel") {
			// set a class to remove padding by css to better fit
			this.$$elmt.addClass("s-m-carousel");
		} else if (typeArray === "chart") {
			// Remove Bg color and set a class to add border by css
			this.$$elmt.removeClass("s-m-bg s-m-color-" + this.article.$bgColor).addClass("s-m-chart");
		}
	},
	isLinkVignette: function() {
		var child = this.children ? this.children[0] : null;
		if (!child || child.$type !== "tablet/x-vignette") return false;
		return child.isLinkVignette();
	},
	_checkAddActionButtons: function() {
		var self = this;
		if (!this.options.tileActions || this.options.tileActions.length <= 0) {
			return;
		}
		this.options.tileActions.forEach(function(action) {
			if (!self.isEmpty || action.action === "removeTile") {
				var $$btn = $('<btn class="cfg ' + action.icon + ' ' + action.className + '" data-nevent data-naction="' + action.action + '" data-params="' + self.id + '"></btn>');
				self.$$elmt.append($$btn);
			}
		});
	}
});
});

define('syracuse-tablet/html/js/controls/panels/panelBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/ctrlBase'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').CtrlBase;

/**
 * 
 */
exports.PanelBase = utils.defineClass(function PanelBase(controller, type, article, opts) {
	Base.call(this, controller, type, article, opts);
}, Base, {
	destroy: function() {
		Base.prototype.destroy.call(this);

		// Do not call destroy since we did not create the adapter but just reference to it
		this.actionAdapter = null;
	},

	/**
	 * This must be called by the creator if this component (usually it's the page)
	 * The component will use the adapter instance to get a list of items to be rendered
	 */
	setActionAdapter: function(actionAdapter) {
		this.actionAdapter = actionAdapter;
	},

	//
	// START: Rendering
	// 
	buildHtml: function() {
		this.createRootElement(["s-m-panel", "s-m-control", "s-m-ctrl"]);
	},
	//
	// END: Rendering
	//

	createId: function(typeName) {
		return utils.readableuid(typeName);
	},
	/**
	 * Built with the rank of the layout in generation process to be reliable
	 */
	getUnitTestId: function() {
		if (this.options.index == null) return;
		return utils.unitTestId(this.typeName.toLowerCase(), this.options.index);
	},
	getGestureMgr: function() {
		return null;
	},
	/**
	 * disable/enable clicks on the panel
	 */
	disable: function(yes) {
		yes = yes === true;
		this.$$elmt.css("opacity", yes ? 0.5 : "inherit");
		if (yes) {
			this.$$elmt.click(function(evt) {
				evt.preventDefault();
				evt.stopPropagation();
			})
		} else {
			this.$$elmt.off();
		}
	}
});
});

define('syracuse-tablet/html/js/controls/panels/panelSdataPage',['require','exports','module','syracuse-tablet/html/js/controls/panels/panelBase','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/panels/panelBase').PanelBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');

/**
 * Base class for all panels that interact with an sdata page and 
 * may trigger actions and links that rely on the page controller
 * 
 * This class is ment to manage interactions and should not do rendering since it's very
 * unspecific
 * 
 */
exports.PanelSdataPage = utils.defineClass(
	function PanelSdataPage(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
		},
		///
		/// START: Rendering
		///
		buildHtml: function() {
			Base.prototype.buildHtml.call(this);
		},
		///
		/// END: Rendering
		///

		/**
		 * metaData will contain:
		 * {
		 * 	$isDisabled: tue|false
		 *  $isHidden: true|false
		 * }
		 * These properties will be the result of merging prototype and data so there is not need
		 * to do anything more here except applying them
		 */
		onMenuItemChanged: function($itemName, $bind, metaData) {
			var $$item = this.$$elmt.find('[data-menuitem-id="' + $itemName + '"]');
			if ($$item.length < 1) {
				return;
			}
			if (metaData.$isDisabled === true) {
				$$item.addClass("disabled");
			} else if (metaData.$isDisabled === false) {
				$$item.removeClass("disabled");
			}
			if (metaData.$isHidden === true) {
				$$item.addClass("hidden");
			} else if (metaData.$isHidden === false) {
				$$item.removeClass("hidden");
			}
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/footer/panelFooterSdataPageBase',['require','exports','module','syracuse-tablet/html/js/controls/panels/panelSdataPage','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiSettings','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/panels/panelSdataPage').PanelSdataPage;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiSettings = require('syracuse-tablet/html/js/ui/uiSettings');
var modules = require('syracuse-tablet/html/js/common/modules');

var _html = {
	mainContainer: '\
		<div class="s-m-footer s-m-opened container-fluid {{deviceClass}}">\
			<div class="s-m-footer-left">\
			</div>\
			<div class="s-m-footer-right">\
			</div>\
		</div>'
};

var _templates = {};

function _getHtml(name, ctx) {
	var tmpl = _templates[name];
	if (!tmpl) {
		tmpl = _templates[name] = Handlebars.compile(_html[name]);
	}
	return tmpl(ctx);
};

/**
 * 
 */
exports.PanelFooterSdataPageBase = utils.defineClass(
	function PanelFooterSdataPageBase(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
		},

		///
		/// START: Rendering
		///

		/**
		 * 
		 */
		buildHtml: function(deviceClass) {
			this.$$container.css({
				left: 0 + "px",
				height: this.getDesiredHeight() + "px"
			});

			Base.prototype.buildHtml.call(this);
			this.$$elmt.addClass("footer");

			this.$$elmt.html(_getHtml("mainContainer", {
				deviceClass: deviceClass
			}));
			this.$$left = this.$$elmt.find(".s-m-footer-left");
			this.$$right = this.$$elmt.find(".s-m-footer-right");
		},

		/**
		 * 
		 */
		computeLayout: function() {
			if (!this.$$container) {
				return;
			}
			var layoutInfo = modules.get("siteLayout").getLayoutInfo();
			this.$$container.css({
				top: this.top + "px",
				width: layoutInfo.application.width + "px",
			});
			if (!this.$$container.is(":visible")) {
				// Showed here to avoid flickering - by default the header is covered by the footer
				this.$$container.show();
			}

		},
		///
		/// END: Rendering
		///
		getDesiredHeight: function() {
			var layoutInfo = modules.get("siteLayout").getLayoutInfo();
			var deviceType = layoutInfo.deviceType;
			return uiSettings.getProp("footer.height", deviceType);
		},
		setTop: function(top) {
			this.top = top;
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/panelsHtml',['require','exports','module','syracuse-tablet/html/js/app/eventListener','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

/* 
 * 
 * Html templates used by more that one panel
 * 
 */

var eventListener = require('syracuse-tablet/html/js/app/eventListener');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _multiSelActionsList = [{
	action: "multiSelTriggerDownload",
	id: "download"
}, {
	action: "multiSelActions",
	id: "unselectall"
}, {
	action: "multiSelActions",
	id: "selectall"
}, {
	action: "multiSelActions",
	id: "invert"
}, {
	action: "multiSelActions",
	id: "hideunselected"
}, {
	action: "multiSelActions",
	id: "showunselected"
}];


var _iconClassMap = {
	"home": "fa fa-home",
	"pin": "fa fa-star-o",
	"unpin": "fa fa-star",
	"openactionspanel": "fa fa-ellipsis-h",
	"switchContext": "fa fa-user",
	"mail": "fa fa-envelope",
	"share": "fa fa-share-alt",
	"settings": "fa fa-gear",
	"about": "fa fa-info-circle",
	"development": "fa fa-wrench",
	"logout": "fa fa-sign-out",
	"drafts": "fa fa-building-o",
	"designPage": "fa fa-thumb-tack",

	"accept": "fa fa-check",
	"cancel": "fa fa-reply",

	"$save": "fa fa-save",
	"$edit": "fa fa-edit",
	"$delete": "fa fa-trash-o",
	"$create": "fa fa-plus-square",
	"$query": "fa fa-list",

	"multiSelection": "fa fa-th-list",
	"multiSelectionRunExit": "fa fa-times",
	"multiSelectionRunStop": "fa fa-stop",

	"pageConfig": "fa fa-pencil",
	"addGroup": "fa fa-sitemap",
	"myTemplates": "fa fa-list-ul",
	"myDashboard": "fa fa-chevron-left"
};

var _html = {
	footer: {
		defaultItem: '<a href="#"\
			draggable="false" \
			data-menuitem-id="{{uniqueId}}" \
			class="s-m-link"\
			{{{attrs}}}>\
			<i class="{{iconClass}}"></i>\
			<span>{{title}}</span>\
		</a>'
	},
	// same as footer except no title is rendered
	header: {
		defaultItem: '<a href="#"\
			draggable="false" \
			data-menuitem-id="{{uniqueId}}" \
			class="s-m-link"\
			{{{attrs}}}>\
			<i class="{{iconClass}}"></i>\
		</a>'
	},
	actionPanel: {
		defaultItem: '<li data-menuitem-id="{{uniqueId}}"\
			class="s-m-link">\
			<a href="#"\
				draggable="false" \
				{{{attrs}}}>\
				<i class="{{iconClass}}"></i>\
				<span>{{title}}</span>\
			</a>\
		</li>'
	},
	globalPanel: {
		defaultItem: '<li data-menuitem-id="{{uniqueId}}">\
			<a href="#"\
				draggable="false" \
				class="s-m-link"\
				{{{attrs}}}>\
				<i class="{{iconClass}}"></i>\
				<span class="isLabel">{{title}}</span>\
			</a>\
		</li>',
		draftsItem: '<li data-menuitem-id="{{uniqueId}}">\
			<a href="#" \
				draggable="false" \
				class="s-m-link {{#if disabled}} disabled"{{/if}}" {{#if disabled}} data-disabled{{/if}}>\
				<i class="{{iconClass}}"></i>\
				<span class="isLabel">{{title}}<span class="badge" style="float: right;">{{count}}</span></span>\
			</a>\
		</li>'
	},
	multiSel: {
		menuActions: '\
			<div id="{{id}}" class="btn-group s-m-link">\
				<div class="{{dropDirection}}">\
					<button type="button" class="btn btn-primary dropdown-toggle" data-toggle="dropdown" aria-expanded="false">\
						<span class="badge"></span><span class="title">{{title}}</span><span class="caret"></span>\
					</button>\
					<ul class="dropdown-menu dropdown-menu-{{dropPosition}}" role="menu">\
						{{#each links}}\
							<li><a  style="display:none" draggable="false" {{{attrs}}}>{{title}}</a></li>\
						{{/each}}\
					</ul>\
				</div>\
			</div>'
	}
};

var _templates = {};

function _getHtml(panel, name, ctx) {
	var tmpl = _templates[panel];
	if (!tmpl) {
		tmpl = _templates[panel] = {};
	}
	tmpl = tmpl[name];
	if (!tmpl) {
		tmpl = _templates[panel][name] = Handlebars.compile(_html[panel][name]);
	}
	return tmpl(ctx);
};

var _getMultiSelMenuActions = function(panelName, controllerId) {
	var dropDirection = panelName === "footer" ? "dropup" : "dropdown";
	var dropPosition = panelName === "footer" ? "right" : "left";
	var links = [];
	_multiSelActionsList.forEach(function(info) {
		var attrs = eventListener.getDataActionAttrs(controllerId, info.action, "$" + info.id, true);
		links.push({
			title: locale.text("multiselect.action." + info.id),
			attrs: attrs
		});
	});
	return _getHtml("multiSel", "menuActions", {
		id: "multiSelMenuActions",
		links: links,
		title: locale.text("multiselect.selected"),
		dropDirection: dropDirection,
		dropPosition: dropPosition
	});
};
/**
 * 
 */
exports.getItemHtml = function(panelName, item) {
	var html;
	var tpl;
	var attrs;
	var controllerId = item["controller-id"];

	if (item.action) {
		// Non sData actions
		if (item.action === "multiSelActions") {
			return _getMultiSelMenuActions(panelName, controllerId);
		} else if (item.action === "pageDrafts") {
			tpl = "draftsItem";
			attrs = eventListener.getDataActionAttrs(controllerId, item.action, item.params, true);
			item.count = item.params;
			item.disabled = item.count < 1;
		} else {
			tpl = "defaultItem";
			attrs = eventListener.getDataActionAttrs(controllerId, item.action, item.params, true);
		}
		item.uniqueId = item.action; // Will be used to find item in the DOM later to apply dynamic meta data
	} else if (item.$link) {
		tpl = "defaultItem";
		attrs = eventListener.getSdataLinkAttrs(controllerId, item.$link, null, true);
		item.uniqueId = item.$link; // Will be used to find item in the DOM later to apply dynamic meta data
	} else if (item.$sdataAction) {
		tpl = "defaultItem";
		attrs = eventListener.getSdataActionAttrs(controllerId, item.$sdataAction, true);
		item.uniqueId = item.$sdataAction; // Will be used to find item in the DOM later to apply dynamic meta data
	}

	if (tpl) {
		if (item.icon && typeof item.icon === "string") {
			// Regular icons
			item.iconClass = _iconClassMap[item.icon];
		} else if (item.icon && item.icon.css) {
			// Icon given by authoring
			item.iconClass = item.icon.css;
		}
		item.attrs = attrs;
		html = _getHtml(panelName, tpl, item);
	}

	return html;
}
});

define('syracuse-tablet/html/js/controls/panels/footer/panelFooterSdataPageTablet',['require','exports','module','syracuse-tablet/html/js/controls/panels/footer/panelFooterSdataPageBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/panels/panelsHtml'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/panels/footer/panelFooterSdataPageBase').PanelFooterSdataPageBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var panelsHtml = require('syracuse-tablet/html/js/controls/panels/panelsHtml');

/**
 * 
 */
exports.PanelFooterSdataPageTablet = utils.defineClass(
	function PanelFooterSdataPageTablet(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
		},
		buildHtml: function() {
			var self = this;

			// Base class creates footer and a left and right container that
			// are available after by this.$$left and this.$$right
			Base.prototype.buildHtml.call(self, "tablet");

			this.leftItems = [];
			this.rightItems = [];

			var items = this._getItems();

			for (var ii = 0, jj = items.length; ii < jj; ii++) {
				var item = items[ii];
				if (this.controller.isActionHidden && this.controller.isActionHidden(item.action)) {
					continue;
				}
				var html = panelsHtml.getItemHtml("footer", item);
				if (html) {
					// Only store items here to be able to change order before adding to the dom
					var list = item.slot === "left" ? this.leftItems : this.rightItems;
					list.push(html);
				}
			}
			this.rightItems.reverse();
			this.$$left.append($(this.leftItems.join("")));
			this.$$right.append($(this.rightItems.join("")));
		},
		/**
		 * Can be overridden
		 */
		_getItems: function() {
			return this.actionAdapter.getFooterItems();
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/header/panelHeaderSdataPageBase',['require','exports','module','syracuse-tablet/html/js/controls/panels/panelSdataPage','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiSettings','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/panels/panelSdataPage').PanelSdataPage;

var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiSettings = require('syracuse-tablet/html/js/ui/uiSettings');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var modules = require('syracuse-tablet/html/js/common/modules');
var locale = require('syracuse-tablet/html/js/helpers/locale');
/**
 * 
 */
exports.PanelHeaderSdataPageBase = utils.defineClass(
	function PanelHeaderSdataPageBase(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
		notifications.subscribe(this, ["sm.data.freshness.change"]);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			notifications.unsubscribe(this, ["sm.data.freshness.change"]);
		},

		///
		/// START: Rendering
		///

		/**
		 * 
		 */
		buildHtml: function() {
			this.$$container.css({
				left: 0 + "px",
				height: this.getDesiredHeight() + "px"
			});

			Base.prototype.buildHtml.call(this);
			this.$$elmt.addClass("header");
			this.$$elmt.css({
				left: 0 + "px",
				height: this._height + "px"
			});
			this.$$container.show();
		},

		/**
		 * 
		 */
		computeLayout: function(context) {
			if (!this.$$container) {
				return;
			}
			var layoutInfo = modules.get("siteLayout").getLayoutInfo();
			this.$$container.css({
				top: this.top + "px",
				width: layoutInfo.application.width + "px",
			});
		},
		///
		/// END: Rendering
		///

		/*
		 * Use by smartphone and tablet to get default information shown in the header
		 */
		getHeaderCtx: function() {
			return {
				title: this.actionAdapter.getPageTitle()
			};
		},
		_updateWidth: function() {
			return;
			var $$header = this.$$elmt.find(".s-m-header");
			if (!$$header) {
				return;
			}
			var $$label = this.$$elmt.find(".s-m-header-labels");
			var $$freshness = this.$$elmt.find(".s-m-freshness");
			var freshVisible = $$freshness && $$freshness.is(":visible");
			if (freshVisible) {
				// We need to hide $$freshness to calculate the width
				// $$freshness is positioned in absolute and is dispayed over the header
				$$freshness.hide();
			}

			var width;
			var maxWidth = this.$$elmt.width();
			var fullWidth = 0;
			var $$nav;
			$$header.children().each(function() {
				$$nav = $(this);
				if (!$$nav.is(".s-m-header-labels")) {
					width = 0;
					$$nav.children().each(function(idx) {
						var c = $(this).outerWidth() + 1;
						width += c;
					});
					// Width=with or remaining with or zero
					width = Math.min(Math.max(maxWidth - fullWidth, 0), width);
					fullWidth += width;
					$$nav.width(width);
				}
			});
			$$label.width("auto");
			if (freshVisible) {
				$$freshness.show();
			}
		},
		getDesiredHeight: function() {
			return uiSettings.getProp("header.height");
		},
		setTop: function(top) {
			this.top = top;
		},
		notifDataFreshnessChange: function(dataFreshness) {
			this._dataFreshness = dataFreshness;
			this._$$freshness = $(".s-m-freshness", this.$elmt);
			this._$$freshness.removeClass("s-m-fresh s-m-tainted s-m-verytainted");
			this._$$freshness.addClass("s-m-" + this._dataFreshness.level);
			this._$$freshness.show();
		},

		/**
		 * Displays freshness info
		 */
		_actShowFreshness: function() {
			if (!this._dataFreshness) return;
			var formatter = formatApi.getFormatter("application/x-datetime");
			var dateTime = formatter.formatValue(utils.getCurISODateTime(new Date(this._dataFreshness.dateTime)), false);

			var notify = {
				severityClass: this._dataFreshness.level,
				title: locale.text("page.data.freshness.last") + " : " + dateTime,
				body: locale.text("page.data.freshness." + this._dataFreshness.level),
				onlyWebapp: true
			};
			modules.get("modal").notify(notify);
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/header/panelHeaderSdataPageTablet',['require','exports','module','syracuse-tablet/html/js/controls/panels/header/panelHeaderSdataPageBase','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/panels/header/panelHeaderSdataPageBase').PanelHeaderSdataPageBase;
var native = require("syracuse-tablet/html/js/helpers/native/native");

var utils = require('syracuse-tablet/html/js/helpers/utils');

var _html = {
	mainContainer: '\
		<div class="s-m-header tablet">\
			<div class="s-m-header-nav">\
				<a href="#" draggable="false"\
					id="s-m-header-back-id"\
					data-nevent\
					data-naction="historyBack">\
					<i class="fa fa-arrow-circle-o-left"></i>\
				</a>\
			</div>\
			<div class="s-m-header-labels">\
				<span class="s-m-header-label">{{title}}</span>\
			</div>\
			<div class="s-m-header-links">\
				<a class="s-m-header-link" href="#" draggable="false" \
					data-nevent\
					data-naction="openGlobalPanel">\
					<span class="fa fa-bars"></span>\
				</a>\
			</div>\
		</div>\
		<div class="s-m-freshness s-m-fresh"\
			data-nevent data-naction="showFreshness"\
			style="display: none;">\
			<i class="fa fa-bookmark"></i>\
		</div>',
	popupContainer: '<ul class="dropdown-menu dropdown-menu-right" role="menu">{{{items}}}</ul>'

}
var _templates = {};

function _getHtml(name, ctx) {
	var tmpl = _templates[name];
	if (!tmpl) {
		tmpl = _templates[name] = Handlebars.compile(_html[name]);
	}
	return tmpl(ctx);
};

/**
 * 
 */
exports.PanelHeaderSdataPageTablet = utils.defineClass(
	function PanelHeaderSdataPageTablet(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
		},

		///
		/// START: Rendering
		///

		buildHtml: function() {
			var self = this;
			Base.prototype.buildHtml.call(self);

			this.$$elmt.html(_getHtml("mainContainer", this.getHeaderCtx()));
			this._updateWidth();
			this._checkBack();
		},

		_checkBack: function() {
				var $$back = $("#s-m-header-back-id", this.$$elmt);
				if (native.hasCapability("hardwareBackButton")) {
					$$back.hide();
				}
			}
			///
			/// END: Rendering
			///
	});
});

define('syracuse-tablet/html/js/controls/panels/header/panelHeaderSdataPageSmartphone',['require','exports','module','syracuse-tablet/html/js/controls/panels/header/panelHeaderSdataPageBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/panels/panelsHtml'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/panels/header/panelHeaderSdataPageBase').PanelHeaderSdataPageBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var panelsHtml = require('syracuse-tablet/html/js/controls/panels/panelsHtml');

var _html = {
	mainContainer: '\
		<div class="s-m-header smartphone">\
			{{#if showNav}}\
				<div class="s-m-header-nav">\
					<a href="#" draggable="false" \
						data-nevent\
						data-naction="openGlobalPanel">\
					<span class="fa fa-bars"></span>\
					</a>\
				</div>\
			{{/if}}\
			{{#if showLabel}}\
				<div class="s-m-header-labels">\
					<span class="s-m-header-label">{{title}}</span>\
					<!--\
					<div class="s-m-header-brand">\
						<span class="s-m-brand">Sage</span>\
						<span class="s-m-product">X3</span>\
					</div>\
					-->\
				</div>\
			{{/if}}\
			<div class="s-m-header-links">\
			</div>\
		</div>\
		{{#if showFreshness}}\
			<div class="s-m-freshness s-m-fresh"\
				data-nevent data-naction="showFreshness"\
				style="display: none;">\
				<i class="fa fa-bookmark"></i>\
			</div>\
		{{/if}}'
}
var _templates = {};

function _getHtml(name, ctx) {
	var tmpl = _templates[name];
	if (!tmpl) {
		tmpl = _templates[name] = Handlebars.compile(_html[name]);
	}
	return tmpl(ctx);
};

/**
 * 
 */
exports.PanelHeaderSdataPageSmartphone = utils.defineClass(
	function PanelHeaderSdataPageSmartphone(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
		},
		buildHtml: function() {
			Base.prototype.buildHtml.call(this);
			this.$$elmt.html(_getHtml("mainContainer", this.getHeaderCtx()));
			this.$$links = this.$$elmt.find(".s-m-header-links");
			var items = this._getItems();
			var list = [];
			for (var ii = 0, jj = items.length; ii < jj; ii++) {
				var item = items[ii];
				var html = panelsHtml.getItemHtml("header", item);
				if (html) {
					list.push(html);
				}
			}
			list.reverse();
			this.$$links.append($(list.join("")));
			this._updateWidth();
		},
		/**
		 * Can be overridden
		 */
		_getItems: function() {
			return this.actionAdapter.getHeaderItems();
		},
		getHeaderCtx: function() {
			var ctx = Base.prototype.getHeaderCtx.call(this);
			ctx.showNav = true;
			ctx.showLabel = true;
			ctx.showFreshness = true;
			return ctx;
		}
	});
});

define('syracuse-tablet/html/js/multiselection/multiSelectionPanelController',['require','exports','module','syracuse-tablet/html/js/controllers/controller','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var Base = require("syracuse-tablet/html/js/controllers/controller").Controller;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');

/**
 * Attached to multi-selection header/footer
 * Handles actions of drop-down list (selectAll...)
 */
exports.MultiSelectionPanelController = utils.defineClass(
	function MultiSelectionPanelController(panel) {
		Base.call(this);
		this._panel = panel;
	},
	Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			this._panel = null;
		},
		/**
		 * Invoked when user click on multiSelection action
		 */
		multiSelToggleStatus: function(enabled) {
			this._nbSelected = 0;
			if (enabled !== true) {
				this._actMultiSelActions("$showunselected")
				this._actMultiSelActions("$unselectall")
			}
			this._multiSelUpdateStatus();
		},
		/**
		 * Invoked when user select a card/row
		 */
		multiSelToggleRecord: function(enabled) {
			if (this._multiSelAction("$showunselected").css("display") !== "none") {
				// Disables hideUnselected
				this._actMultiSelActions("$showunselected");
			}
			this._nbSelected = Math.max(0, this._nbSelected + (enabled === true ? 1 : -1));
			this._multiSelUpdateStatus();
			return true;
		},
		/**
		 * Start actions processing
		 */
		multiSelStartProcessing: function() {
			this._multiSelToggleUnselected(false);
			this._multiSelRunToggleStop(true);
			this._panel.multiSelUpdateCounter(0, 0);
		},

		_multiSelRunToggleStop: function(show) {
			this._panel.$$elmt.find('[data-naction="multiSelTriggerAction"][data-params="stop"]').toggle(show);
			this._panel.$$elmt.find('[data-naction="multiSelTriggerAction"][data-params="exit"]').toggle(!show);
		},
		/**
		 * Stop actions processing
		 */
		multiSelRunStop: function() {
			this._multiSelRunToggleStop(false);
		},
		/**
		 * Exit actions processing
		 */
		multiSelRunExit: function() {
			// Remove success/error status
			this._multiSelSelected().removeClass("error success");
			this._panel.multiSelUpdateCounter(0, 0);
		},
		/**
		 * Update the status of the actions
		 */
		_multiSelUpdateStatus: function() {
			this._panel.$$elmt.find('a.s-m-link:not([data-menuitem-id="multiSelToggle"])').toggleClass("disabled", this._nbSelected == 0);
			var $$menuActions = this._panel.$$elmt.find("#multiSelMenuActions");
			$$menuActions.find(".badge").text(this._nbSelected);
			$$menuActions.find(".title").text(locale.text(this._nbSelected > 1 ? "multiselect.selected.plural" : "multiselect.selected"));
			var nbRecords = this._panel.page.getQueryArray().getNbRows();
			this._multiSelAction("$hideunselected").toggle(this._nbSelected != 0 && this._nbSelected != nbRecords);
			this._multiSelAction("$selectall").toggle(this._nbSelected != nbRecords);
			this._multiSelAction("$unselectall", "$invert").toggle(this._nbSelected > 0);
			this._multiSelAction("$download").toggle(this._panel.page.isDownloadEnabled() && this._nbSelected > 0);
		},
		/**
		 * Returns unselected records
		 */
		_multiSelUnselected: function() {
			return this._panel.page.$$contentElmt.find(".s-m-array.s-m-control > .s-m-value .s-m-record:not(.s-m-multi-selected)");
		},
		/**
		 * Returns selected records
		 */
		_multiSelSelected: function() {
			return this._panel.page.$$contentElmt.find(".s-m-array.s-m-control > .s-m-value .s-m-record.s-m-multi-selected");
		},
		/**
		 * Returns all the records
		 */
		_multiSelAll: function() {
			return this._panel.page.$$contentElmt.find(".s-m-array.s-m-control > .s-m-value .s-m-record");
		},
		/**
		 * argument is the list of actions id
		 * Returns the array of $elements
		 */
		_multiSelAction: function() {
			var res = $();
			var args = arguments;
			this._panel.$$elmt.find('#multiSelMenuActions a[data-params]').each(function(id) {
				var param = $(this).attr("data-params")
				if (Array.prototype.indexOf.apply(args, [param]) >= 0) {
					res.push(this)
				}
			})
			return res;
		},
		/**
		 * Toggle the status of all unselected elements
		 */
		_multiSelToggleUnselected: function(show) {
			this._multiSelUnselected().toggle(show);
			var array = this._panel.page.getQueryArray();
			if (array.$display === "card") {
				// Hide empty rows to remove the height of empty tr elements
				this._panel.page.$$contentElmt.find(".s-m-array.s-m-card tr").each(function() {
					var e = $(this);
					e.toggle(show ? show : e.find("td").length != e.find("td.s-m-record:not(:visible)").length);
				});
				// To improve - Update scroller after having hidden the empty rows/cards
				array.notifyScrollerUpdate();
			}
		},
		/**
		 * Toggle the status 'select' of the elements given by elmtList
		 */
		_multiSelToggleListStatus: function(elmtList, select) {
			var selected = elmtList.toggleClass("s-m-multi-selected", select);
			if (!selected.is(".s-m-multi-selected")) {
				selected = []
			}
			this._nbSelected = this._multiSelSelected().length;
			this._multiSelUpdateStatus();
		},
		/**
		 * Process multi-selection action (drop down list menu)
		 */
		_actMultiSelActions: function(params) {
			if (params == "$unselectall") {
				this._multiSelToggleUnselected(true);
				this._multiSelToggleListStatus(this._multiSelSelected(), false);
				return;
			}
			if (params == "$selectall") {
				this._multiSelToggleUnselected(true);
				this._multiSelToggleListStatus(this._multiSelUnselected(), true);
				return;
			}
			if (params == "$invert") {
				var unselected = this._multiSelUnselected();
				var selected = this._multiSelSelected();
				this._multiSelToggleListStatus(unselected, true);
				this._multiSelToggleListStatus(selected, false);
				return;
			}
			if (params === "$hideunselected" || params === "$showunselected") {
				var hideUnselected = params === "$hideunselected";
				this._multiSelToggleUnselected(!hideUnselected);
				this._multiSelAction("$hideunselected", "$selectall", "$unselectall", "$invert").toggle(!hideUnselected);
				this._multiSelAction("$showunselected").toggle(hideUnselected);
				return;
			}
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/header/panelHeaderMultiselSmartphone',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/panels/header/panelHeaderSdataPageSmartphone','syracuse-tablet/html/js/multiselection/multiSelectionPanelController'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/panels/header/panelHeaderSdataPageSmartphone').PanelHeaderSdataPageSmartphone;
var MultiSelectionPanelController = require("syracuse-tablet/html/js/multiselection/multiSelectionPanelController").MultiSelectionPanelController;


/**
 * Dedicated header for multi-selection on smartphones
 */
exports.PanelHeaderMultiselSmartphone = utils.defineClass(
	function PanelHeaderMultiselSmartphone(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
		this.multiSelectionController = new MultiSelectionPanelController(this);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this.multiSelectionController) {
				this.multiSelectionController.destroy();
				this.multiSelectionController = null;
			}
		},
		buildHtml: function() {
			Base.prototype.buildHtml.call(this);
			this.$$elmt.addClass("multiSelection");
		},
		/**
		 * Override _getItems
		 */
		_getItems: function() {
			return this.actionAdapter.getMultiSelectionItems(this.multiSelectionController.id);
		},
		getHeaderCtx: function() {
			var ctx = Base.prototype.getHeaderCtx.call(this);
			ctx.showNav = false;
			ctx.showLabel = false;
			ctx.showFreshness = false;
			return ctx;
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/header/panelHeaderMultiselSmartphoneRun',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/panels/header/panelHeaderMultiselSmartphone'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/panels/header/panelHeaderMultiselSmartphone').PanelHeaderMultiselSmartphone;

/**
 * Dedicated header for multi-selection on smartphones
 */
exports.PanelHeaderMultiselSmartphoneRun = utils.defineClass(
	function PanelHeaderMultiselSmartphoneRun(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
	}, Base, {
		buildHtml: function() {
			Base.prototype.buildHtml.call(this);
			this._$$counter = $('<span class="s-m-multiselmsg"/>').prependTo(this.$$elmt.find(".s-m-header"));
		},
		multiSelUpdateCounter: function(nbOk, nbKo) {
			if (nbOk == null) {
				nbOk = 0;
			}
			if (nbKo == null) {
				nbKo = 0;
			}
			this._$$counter.text(nbOk + ' successes - ' + nbKo + ' failures');
		},
		/**
		 * Override _getItems
		 */
		_getItems: function() {
			return this.actionAdapter.getMultiSelectionRunItems(this.multiSelectionController.id);
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/footer/panelFooterMultiselTablet',['require','exports','module','syracuse-tablet/html/js/controls/panels/footer/panelFooterSdataPageTablet','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/multiselection/multiSelectionPanelController'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/panels/footer/panelFooterSdataPageTablet').PanelFooterSdataPageTablet;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var MultiSelectionPanelController = require("syracuse-tablet/html/js/multiselection/multiSelectionPanelController").MultiSelectionPanelController;

/**
 * Dedicated header for multi-selection on Tablet
 */
exports.PanelFooterMultiselTablet = utils.defineClass(
	function PanelFooterMultiselTablet(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
		this.multiSelectionController = new MultiSelectionPanelController(this);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this.multiSelectionController) {
				this.multiSelectionController.destroy();
				this.multiSelectionController = null;
			}
		},
		buildHtml: function() {
			Base.prototype.buildHtml.call(this);
			this.$$elmt.addClass("multiSelection");
		},
		/**
		 * Override _getItems
		 */
		_getItems: function() {
			return this.actionAdapter.getMultiSelectionItems(this.multiSelectionController.id);
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/footer/panelFooterMultiselTabletRun',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/panels/footer/panelFooterMultiselTablet'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require("syracuse-tablet/html/js/controls/panels/footer/panelFooterMultiselTablet").PanelFooterMultiselTablet;

/**
 * Dedicated header for multi-selection on Tablet
 * This panel is displayed when actions are executed
 */
exports.PanelFooterMultiselTabletRun = utils.defineClass(
	function PanelFooterMultiselTabletRun(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this._$$counter = null;
		},
		buildHtml: function() {
			Base.prototype.buildHtml.call(this);
			this._$$counter = $('<span class="s-m-multiselmsg"/>').appendTo(this.$$elmt.find(".s-m-footer-left"));
		},
		multiSelUpdateCounter: function(nbOk, nbKo) {
			if (nbOk == null) {
				nbOk = 0;
			}
			if (nbKo == null) {
				nbKo = 0;
			}
			this._$$counter.text(nbOk + ' successes - ' + nbKo + ' failures');
		},
		/**
		 * Override _getItems
		 */
		_getItems: function() {
			return this.actionAdapter.getMultiSelectionRunItems(this.multiSelectionController.id);
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/header/panelHeaderEditHome',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/panels/header/panelHeaderSdataPageBase','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/panels/header/panelHeaderSdataPageBase').PanelHeaderSdataPageBase;
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var modules = require('syracuse-tablet/html/js/common/modules');
/**
 * Dedicated header for edit homepage on tablet
 */
var _html = {
	mainContainer: '\
			<div class="s-m-header {{device}} s-m-dasboard-config">\
			<div class="s-m-header-title">\
				<input class="s-m-header-label" value="{{description}}">\
				{{#if template}}\
					<div class="s-m-dashboard-header-role-number">{{roleCount}}</div>\
				    <btn class="s-m-dashboard-header-btn-role fa fa-users" data-nevent data-naction="roleList"   data-controller-id="{{controllerId}}">\
				{{/if}} \
			</div>\
			<buttons class="pull-right dashboard-header-btn" style="width:{{rightBtnWidth}}px">\
				<button type="button" class="btn btn-default" style="display:{{displaySaveButton}}" data-nevent data-naction="{{buttonSaveAction}}" data-controller-id="{{controllerId}}">\
					<i class="fa fa-check"></i>\
				</button>\
				<button type="button" style="float:right" class="btn btn-danger" data-nevent data-naction="closeDashboardConfig"  data-controller-id="{{controllerId}}">\
					<i class="fa fa-close"></i>\
				</button>\
			</buttons>\
		</div>'
}
var _templates = {};

function _getHtml(name, ctx) {
	var tmpl = _templates[name];
	if (!tmpl) {
		tmpl = _templates[name] = Handlebars.compile(_html[name]);
	}
	return tmpl(ctx);
};
exports.PanelHeaderEditHome = utils.defineClass(
	function PanelHeaderEditHome(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
		notifications.subscribe(this, ["sm.dashboard.state.change"]);
		notifications.subscribe(this, ["sm.dashboard.roles.change"]);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
		},
		buildHtml: function() {
			Base.prototype.buildHtml.call(this);
			this.$$elmt.append(_getHtml("mainContainer", this.getHeaderCtx()));
			$("input.s-m-header-label", this.$$elmt).on('change', jsutils.bindFn(this._descriptionChange, this))
		},
		_descriptionChange: function() {
			notifications.publish(["sm.dashboard.description.change"], $("input.s-m-header-label", this.$$elmt).val());
		},
		notifDashboardStateChange: function(dirty) {
			if (dirty) {
				$("[data-naction='savePersonal'],[data-naction='saveTemplate']", this.$$elmt).show();
			} else {
				$("[data-naction='savePersonal'],[data-naction='saveTemplate']", this.$$elmt).hide();
			}
		},
		notifDashboardRolesChange: function() {
			$(".s-m-dashboard-header-role-number", this.$$elmt).text(this.page.roles().length);
		},
		/**
		 * Override _getItems
		 */
		getHeaderCtx: function() {
			return {
				description: this.page.getPageDescription(),
				device: modules.get("siteLayout").getDeviceType(),
				displaySaveButton: "none",
				rightBtnWidth: 100,
				buttonSaveAction: this.page.isPersonal() ? "savePersonal" : "saveTemplate",
				controllerId: this.page.controller.id,
				template: !this.page.isPersonal(),
				roleCount: this.page.roles().length
			};
		},
	});
});

define('syracuse-tablet/html/js/pages/actionAdapter',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/siteLayout'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var siteLayout = require('syracuse-tablet/html/js/ui/siteLayout');

/**
 * Manage actions that will appear in the different panels of the page like header, footer, right panel, user profile
 * This is the base class that MUST be implemented by a child class to return action items
 * The intention of this is mostly to document and give an interface to the panel UI components
 * 
 * Most methods return a list of action items to be rendered.
 * An action item can be one of the following.
 * 
 * {
 *   "name":		  // Unique name
 * 	 "controller-id":
 *   "$action":		  // Sdata action ($save)
 *   "icon":		  // Optional, rendering control should use prototype and a default if possible
 *   "title":		  // Optional, rendering control should use prototype
 * }
 *
 * {
 *   "name":		  // Unique name
 * 	 "controller-id":
 *   "$link":   	  // Sdata link ($edit)
 *   "$bind":		  // If link is on a specific conrol and not on page level
 *   "icon":		  // Optional, rendering control should use prototype and a default if possible
 *   "title":		  // Optional, rendering control should use prototype
 * }
 * 
 * {
 *   "name":	    	// Unique name
 * 	 "controller-id":    
 * 	 "action": 			// Non sdata actions (like pin-page, represented by data-action and data-params
 *   "params":
 *   "icon":
 *   "title":
 * }
 * 
 */
exports.ActionAdapter = utils.defineClass(
	function ActionAdapter(page) {
		this.page = page;
	},
	null, {
		destroy: function() {
			this.page = null;
		},
		//
		// START: Methods to be implemented by subclasses
		//
		/**
		 * Returns items to be shown in the action panel
		 */
		getActionsPanelItems: function() {
			return [];
		},
		/**
		 * Returns items to be shown in the footer panel
		 */
		getFooterItems: function() {
			return [];
		},

		/**
		 * Returns items to be shown in the header
		 */
		getHeaderItems: function() {
			return [];
		},
		/**
		 * Returns items to be shown in the global panel
		 */
		getGlobalPanelItems: function() {
			return [];
		},
		getPageTitle: function() {
			return this.page.getPageTitle();
		},
		//
		// END: Methods to be implemented by subclasses
		//

		//
		// START: Helpers
		//
		_addDataAction: function(items, name, action, params, title, icon, controller, overrides) {
			var item = exports.createDataAction(name, action, params, title, icon, controller, overrides);
			items.push(item);
		},

		// Standard buttons
		_addOpenActionsPanel: function(items, controller, overrides) {
			var label;
			if (siteLayout.getDeviceType() !== "smartphone") {
				label = "actions";
			}
			this._addDataAction(items, "openActionsPanel", "openActionsPanel", null, label, "openactionspanel", controller, overrides);
		},
		_addHomeButton: function(items, controller, overrides) {
			this._addDataAction(items, "home", "home", null, "global.action.title.home", "home", controller, overrides);
		},
		_addPinButton: function(items, status, controller, overrides) {
			status = status === "pin" ? "pin" : "unpin";
			this._addDataAction(items, "pinPage", status + "Page", null, "global.action.title." + status, status, controller, overrides);
		},
		_addDesignPageButton: function(items, controller, overrides) {
			this._addDataAction(items, "designPage", "designPage", null, "global.action.title.designPage", "designPage", controller, overrides);
		},
		_addShareButton: function(items, controller, overrides) {
			this._addDataAction(items, "pageShare", "pageShare", null, "global.action.title.pageShare", "share", controller, overrides);
		},
		_addSwitchContextButton: function(items, controller, overrides) {
			this._addDataAction(items, "switchContext", "switchContext", null, "global.action.title.changeProfile", "switchContext", controller, overrides);
		},
		_addSettingsButton: function(items, controller, overrides) {
			this._addDataAction(items, "settings", "settings", null, "global.action.title.settings", "settings", controller, overrides);
		},
		_addAboutButton: function(items, controller, overrides) {
			this._addDataAction(items, "about", "about", null, "global.action.title.about", "about", controller, overrides);
		},
		_addDevButton: function(items, controller, overrides) {
			this._addDataAction(items, "developmentPage", "developmentPage", null, "global.action.title.developmentPage", "development", controller, overrides);
		},
		_addLogoutButton: function(items, controller, overrides) {
			this._addDataAction(items, "logout", "logout", null, "global.action.title.logout", "logout", controller, overrides);
		},
		_addDraftsButton: function(items, numDrafts, controller, overrides) {
			// Not sure if drafts will be done
			// this._addDataAction(items, "pageDrafts", "pageDrafts", numDrafts, "global.action.title.drafts", "drafts", controller, overrides);
		},
		_addAcceptButton: function(items, controller, overrides) {
			this._addDataAction(items, "accept", "accept", null, "global.action.title.accept", "accept", controller, overrides);
		},
		_addCancelButton: function(items, controller, overrides) {
			this._addDataAction(items, "cancel", "cancel", null, "global.action.title.cancel", "cancel", controller, overrides);
		},
		_addPageConfigButton: function(items, controller, overrides) {
			this._addDataAction(items, "pageConfig", "pageConfig", null, "action.pageConfig", "pageConfig", controller, overrides);
		},
		_addMyTemplatesButton: function(items, controller, overrides) {
			this._addDataAction(items, "myTemplates", "myTemplates", null, "action.myTemplates", "myTemplates", controller, overrides);
		},
		_addMyDashboardButton: function(items, controller, overrides) {
			this._addDataAction(items, "myDashboard", "myDashboard", null, "action.myDashboard", "myDashboard", controller, overrides);
		},
		//
		// END: Helpers
		//
	});

exports.createDataAction = function(name, action, params, title, icon, controller, overrides) {
	var item = $.extend(true, {
		"name": name,
		"controller-id": controller.id,
		"action": action,
		"params": params,
		"title": locale.textOpt(title) || title,
		"icon": icon
	}, overrides);
	return item;
}
});

define('syracuse-tablet/html/js/controls/panels/footer/panelFooterEditHomeTablet',['require','exports','module','syracuse-tablet/html/js/controls/panels/footer/panelFooterSdataPageBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/pages/actionAdapter','syracuse-tablet/html/js/controls/panels/panelsHtml'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/panels/footer/panelFooterSdataPageBase').PanelFooterSdataPageBase;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var actionAdapter = require('syracuse-tablet/html/js/pages/actionAdapter');
var panelsHtml = require('syracuse-tablet/html/js/controls/panels/panelsHtml');

/**
 * Dedicated header for edit homePage on Tablet
 */
exports.PanelFooterEditHomeTablet = utils.defineClass(
	function PanelFooterEditHomeTablet(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
		},
		buildHtml: function() {
			var self = this;

			// Base class creates footer and a left and right container that
			// are available after by this.$$left and this.$$right
			Base.prototype.buildHtml.call(self, "tablet");

			this.leftItems = [];
			this.rightItems = [];

			var items = this._getItems();
			for (var ii = 0, jj = items.length; ii < jj; ii++) {
				var item = items[ii];
				var html = panelsHtml.getItemHtml("footer", item);
				if (html) {
					// Only store items here to be able to change order before adding to the dom
					var list = item.slot === "left" ? this.leftItems : this.rightItems;
					list.push(html);
				}
			}
			this.rightItems.reverse();
			this.$$left.append($(this.leftItems.join("")));
			this.$$right.append($(this.rightItems.join("")));
		},
		_getItems: function() {
			var items = [];
			items.push(
				actionAdapter.createDataAction("addGroup", "addGroup", null, "welcome.dashboard.add.group", "addGroup", this.controller, {
					slot: "left"
				})
			);
			return items;
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/footer/panelFooterEditHomeSmartphone',['require','exports','module','syracuse-tablet/html/js/controls/panels/footer/panelFooterSdataPageBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/pages/actionAdapter','syracuse-tablet/html/js/controls/panels/panelsHtml'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/panels/footer/panelFooterSdataPageBase').PanelFooterSdataPageBase;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var actionAdapter = require('syracuse-tablet/html/js/pages/actionAdapter');
var panelsHtml = require('syracuse-tablet/html/js/controls/panels/panelsHtml');

/**
 * Dedicated header for edit homePage on Tablet
 */
exports.PanelFooterEditHomeSmartphone = utils.defineClass(
	function PanelFooterEditHomeSmartphone(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
		},
		buildHtml: function() {
			var self = this;

			// Base class creates footer and a left and right container that
			// are available after by this.$$left and this.$$right
			Base.prototype.buildHtml.call(self, "smartphone");

			this.leftItems = [];
			this.rightItems = [];

			var items = this._getItems();
			for (var ii = 0, jj = items.length; ii < jj; ii++) {
				var item = items[ii];
				var html = panelsHtml.getItemHtml("footer", item);
				if (html) {
					// Only store items here to be able to change order before adding to the dom
					var list = item.slot === "left" ? this.leftItems : this.rightItems;
					list.push(html);
				}
			}
			this.rightItems.reverse();
			this.$$left.append($(this.leftItems.join("")));
			this.$$right.append($(this.rightItems.join("")));
		},
		_getItems: function() {
			var items = [];
			items.push(
				actionAdapter.createDataAction("addGroup", "addGroup", null, "welcome.dashboard.add.group", "addGroup", this.controller, {
					slot: "left"
				})
			);
			return items;
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/aside/panelAsideBase',['require','exports','module','syracuse-tablet/html/js/controls/panels/panelSdataPage','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/scroller/scrollerHelpers','syracuse-tablet/html/js/ui/rect'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/panels/panelSdataPage').PanelSdataPage;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');
var uiRect = require('syracuse-tablet/html/js/ui/rect');

var _html = {
	mainContainer: '\
		<nav class="navbar s-m-side-panel {{side}} navbar-inverse" role="navigation">\
			<div class="s-m-panel-content s-m-scroll-elmt">\
			</div>\
		</nav>'
}

var _templates = {};

function _getHtml(name, ctx) {
	var tmpl = _templates[name];
	if (!tmpl) {
		tmpl = _templates[name] = Handlebars.compile(_html[name]);
	}
	return tmpl(ctx);
};

/**
 * 
 */
exports.PanelAsideBase = utils.defineClass(
	function PanelAsideBase(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
	}, Base, {

		destroy: function() {
			if (this.$$container) {
				this.$$container.off();
			}
			Base.prototype.destroy.call(this);
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},

		///
		/// START: Rendering
		///

		/**
		 * 
		 */
		buildHtml: function() {
			this.attachedSide = this.attachedControlInfo.selector.indexOf("-left") >= 0 ? "left" : "right";
			this._ensure$$container();
			Base.prototype.buildHtml.call(this);
			this.$$elmt.html(_getHtml("mainContainer", {
				side: this.attachedSide
			}));
			this.$$panelContent = this.$$elmt.find(".s-m-panel-content");
			if (this.options.noCloseOnClick !== true) {
				this.$$container.click(jsutils.bindFn(this.onClickPanel, this));
			}
		},

		/**
		 * Can be overridden if we want to cathc event and not close the panel (panel with input fields like share)
		 */
		onClickPanel: function(event) {
			if (!this.$$elmt.is(":visible")) {
				return
			}
			this.hide();
		},

		_ensure$$container: function() {
			// Ensure the manager of this control points us to the correct container to be used
			this.attachedControlsMgr.ensureControl$$container(this, this.attachedControlInfo);
		},
		/**
		 * 
		 */
		computeLayout: function(layoutInfo) {
			if (!this.$$container) {
				return;
			}
		},
		_updateGesture: function() {
			if (!this.$$elmt || !this.$$elmt.is(':visible')) {
				if (this._gestureMgr) {
					this._gestureMgr.reset();
				}
				return;
			}
			if (!this._gestureMgr) {
				this.$$scrollElmt = this.$$elmt.find(".s-m-scroll-elmt");
				if (this.$$scrollElmt.length === 0) {
					return;
				}
				// $$scrollWrapper is generally this.$$elmt
				this.$$scrollWrapper = this.$$elmt.find(".s-m-scroll-wrapper");
				if (this.$$scrollWrapper.length === 0) {
					this.$$scrollWrapper = this.$$elmt;
				}
				this._gestureMgr = scroller.newScroller(this.$$scrollElmt, {
					direction: "v",
					valMax: 0,
					name: this.$type,
					isPageScroller: false
				});
			}
			// reset old scrolling to calculate width/height (mandatory in native mode)
			this._gestureMgr.reset();
			// top=0px needed to calculate the right viewrect
			var scrollRect = uiRect.elmtRect(this.$$scrollElmt.css({
				top: "0px"
			}), "outer");
			var wrapperRect = uiRect.elmtRect(this.$$scrollWrapper, "outer");
			var viewRect = wrapperRect.intersectRect(scrollRect);
			if (viewRect && !viewRect.contains(scrollRect)) {
				// Keep scrolling
				this._gestureMgr.init(viewRect, null, null, true);
			}
		},
		///
		/// END: Rendering
		///

		onMenuItemChanged: function($itemName, $bind, metaData) {
			// Hide/unhide elements
			Base.prototype.onMenuItemChanged.call(this, $itemName, $bind, metaData);

			// Ensure scrolling is reset
			this._updateGesture();
		},
		_actClosePanel: function() {
			this.hide();
		},
		_makeVisible: function() {
			this._ensure$$dismiss();
			this.$$container.fadeIn(200);
			this.$$elmt.show(); // Do not only show/hide the container but also the panel since one container can be used by several panels!

			var panelWidth = this.$$elmt.width();
			this.$$dismiss.addClass(this.attachedSide).css(this.attachedSide, panelWidth);

			// TODO:
			// We fake the dismiss as being a piece of markup of the panel control so the event handler knows where to route the close event
			// Better would be to create a panel specific dismiss element to avoid this hack
			this.$$dismiss.addClass("s-m-ctrl");
			this.$$dismiss.attr("data-controller-id", this.controller.id)
			this.$$dismiss.attr("id", this.id);

			this._updateGesture();
		},
		_makeInvisible: function() {
			this._ensure$$dismiss();

			this.$$dismiss.removeClass(this.attachedSide).css(this.attachedSide, 0);
			this.$$dismiss.removeClass("s-m-ctrl");
			this.$$dismiss.attr("id", null);

			this.$$container.hide();
			this.$$elmt.hide(); // Do not only show/hide the container but also the panel since one container can be used by several panels!
		},
		_ensure$$dismiss: function() {
			this._ensure$$container();
			this.$$dismiss = this.$$container.parent().find(".s-m-side-panel-dismiss");
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/aside/panelActions',['require','exports','module','syracuse-tablet/html/js/controls/panels/aside/panelAsideBase','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/panels/panelsHtml'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/panels/aside/panelAsideBase').PanelAsideBase;
var locale = require('syracuse-tablet/html/js/helpers/locale');
var utils = require('syracuse-tablet/html/js/helpers/utils');

var panelsHtml = require('syracuse-tablet/html/js/controls/panels/panelsHtml');

var _html = {
	content: '\
		<div class="container-fluid">\
			<div class="navbar-header">\
				<span class="navbar-brand" href="#"><span>{{title}}</span></a>\
			</div>\
		</div>\
		{{{itemsBlockHtml}}}',
	itemsBlock: '\
		<ul class="nav navbar-nav">\
			{{{itemsHtml}}}\
		</ul>',
}

var _templates = {};

function _getHtml(name, ctx) {
	var tmpl = _templates[name];
	if (!tmpl) {
		tmpl = _templates[name] = Handlebars.compile(_html[name]);
	}
	return tmpl(ctx);
};

/**
 * 
 */
exports.PanelActions = utils.defineClass(
	function PanelActions(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
		},

		///
		/// START: Rendering
		///

		/**
		 * 
		 */
		buildHtml: function() {
			var self = this;
			Base.prototype.buildHtml.call(this, "right");

			var items = this.actionAdapter.getActionsPanelItems();
			var links = [];
			var actions = [];
			items.forEach(function(item) {
				if (item.slot === "links") {
					links.push(panelsHtml.getItemHtml("actionPanel", item));
				} else {
					actions.push(panelsHtml.getItemHtml("actionPanel", item));
				}
			});

			if (links.length != 0 && actions.length != 0) {
				links.push('<li class="s-m-separator"></li>');
			}
			var itemsHtml = links.join("") + actions.join("");
			var itemsBlockHtml = "";
			if (itemsHtml.length > 0) {
				itemsBlockHtml = _getHtml("itemsBlock", {
					itemsHtml: itemsHtml
				});
			}
			self.$$panelContent.html(_getHtml("content", {
				title: locale.text("actions"),
				itemsBlockHtml: itemsBlockHtml
			}));
		},

		///
		/// END: Rendering
		///
		show: function() {
			if (!this.$$elmt) {
				this.buildHtml();
			}
			this._makeVisible();
		},
		hide: function() {
			this._makeInvisible();
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/aside/panelGlobalBase',['require','exports','module','syracuse-tablet/html/js/controls/panels/aside/panelAsideBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/controls/panels/panelsHtml'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/panels/aside/panelAsideBase').PanelAsideBase;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var modules = require('syracuse-tablet/html/js/common/modules');

var panelsHtml = require('syracuse-tablet/html/js/controls/panels/panelsHtml');

var _html = {
	content: '\
		<div class="container-fluid">\
			<div class="navbar-header">\
				<span class="navbar-brand" href="#"><span>{{username}}</span>\
			</div>\
		</div>\
		{{{itemsBlockHtml}}}',
	itemsBlock: '\
		<ul class="nav navbar-nav">\
			{{{itemsHtml}}}\
		</ul>',
}

var _templates = {};

function _getHtml(name, ctx) {
	var tmpl = _templates[name];
	if (!tmpl) {
		tmpl = _templates[name] = Handlebars.compile(_html[name]);
	}
	return tmpl(ctx);
};

/**
 * 
 * Global panel showing stuff like design page, settings, ...
 */
exports.PanelGlobalBase = utils.defineClass(
	function PanelGlobalBase(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
		},

		///
		/// START: Rendering
		///

		/**
		 * 
		 */
		buildHtml: function() {
			var self = this;
			Base.prototype.buildHtml.call(this);

			var items = this.actionAdapter.getGlobalPanelItems();
			var links = [];
			var actions = [];
			items.forEach(function(item) {
				if (item.slot === "links") {
					links.push(panelsHtml.getItemHtml("globalPanel", item));
				} else {
					actions.push(panelsHtml.getItemHtml("globalPanel", item));
				}
			});

			if (links.length != 0 && actions.length != 0) {
				links.push('<li class="s-m-separator"></li>');
			}
			var itemsHtml = links.join("") + actions.join("");
			var itemsBlockHtml = "";
			if (itemsHtml.length > 0) {
				itemsBlockHtml = _getHtml("itemsBlock", {
					itemsHtml: itemsHtml
				});
			}
			self.$$panelContent.html(_getHtml("content", {
				username: _getUserName(),
				userrole: _getUserRole(),
				itemsBlockHtml: itemsBlockHtml
			}));
		},

		///
		/// END: Rendering
		///
		show: function() {
			if (!this.$$elmt) {
				this.buildHtml();
			}
			this._makeVisible();
		},
		hide: function() {
			this._makeInvisible();
		}
	});


function _getUserName() {
	var up = modules.get("appController").App.getCurrentUserProfile();
	if (!up) {
		return "";
	}
	var name = up.user.firstName || "";
	name = (name != "" ? name + " " : "") + up.user.lastName;
	return name;
}

function _getUserRole() {
	var up = modules.get("appController").App.getCurrentUserProfile();
	if (!up) {
		return "";
	}
	return up.selectedRole.code;
}
});

define('syracuse-tablet/html/js/controls/panels/aside/panelGlobalSmartphone',['require','exports','module','syracuse-tablet/html/js/controls/panels/aside/panelGlobalBase','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/panels/aside/panelGlobalBase').PanelGlobalBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');

/**
 * 
 */
exports.PanelGlobalSmartphone = utils.defineClass(
	function PanelGlobalSmartphone(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
	}, Base, {
		buildHtml: function() {
			Base.prototype.buildHtml.call(this);
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/aside/panelGlobalTablet',['require','exports','module','syracuse-tablet/html/js/controls/panels/aside/panelGlobalBase','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/controls/panels/aside/panelGlobalBase').PanelGlobalBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');

/**
 * 
 */
exports.PanelGlobalTablet = utils.defineClass(
	function PanelGlobalTablet(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
	}, Base, {
		buildHtml: function() {
			Base.prototype.buildHtml.call(this);
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/sortfilter/tabBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/scroller/scrollerHelpers'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');

/**
 * Base tab
 */
exports.TabBase = utils.defineClass(
	function TabBase(panel, id, options) {
		this.id = id;
		this.options = options || {};
		this.panel = panel;
		this.$$tab = this.panel.$$panel.find('[href="#' + id + '"]');
		this.$$tab.on('shown.bs.tab', jsutils.bindFn(this._onTabShown, this));
		this.$$content = this.panel.$$panel.find('#' + this.id);
		this.$$content.on("click", '[data-params]', jsutils.bindFn(this.onTabContentClick, this));
		if (this._gestureMgr) {
			this._gestureMgr.destroy();
			this._gestureMgr = null;
		}
		this.buildHtml();
		// Create gesture mgr
		this.$$scrollWrapper = this.$$content.find(".s-m-scroll-wrapper");
		this.$$scrollElmt = this.$$content.find(".s-m-scroll-elmt");
		if (this.$$scrollElmt.length > 0 && this.$$scrollWrapper.length > 0) {
			this._gestureMgr = scroller.newScroller(this.$$scrollElmt, {
				direction: "v",
				valMax: 0,
				isPageScroller: false
			});
		}
	}, null, {
		destroy: function() {
			this.panel = null;
			if (this.$$tab) {
				this.$$tab.unbind();
				this.$$tab.remove();
				this.$$tab = null;
			}
			if (this.$$content) {
				this.$$content.unbind();
				this.$$content.remove();
				this.$$content = null;
			}
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
			this.$$scrollElmt = null;
			this.$$scrollWrapper = null;
		},
		/**
		 * Hide the tab
		 */
		hide: function() {
			this.$$tab.parent().hide();
			this.$$content.hide();
		},
		setWidth: function(w) {
			this.$$tab.parent().width(w);
		},
		triggerActivate: function() {
			var self = this;
			if (self.$$tab.parent().hasClass("active")) {
				self._onTabShown();
			} else {
				window.setTimeout(function() {
					self.$$tab.tab('show');
				});
			}
		},
		/**
		 * Tab becomes visible - No override - Override doTabShow
		 */
		_onTabShown: function(event) {
			//Calls panel to set active tab
			this.panel.notifyActiveTab(this);
			this.doTabShow();
			this.updateGesture();
		},
		/**
		 * Overridden by child class
		 */
		doTabShow: function() {

		},
		/**
		 * Build HTML
		 */
		buildHtml: function() {

		},
		/**
		 * Click on content
		 */
		onTabContentClick: function(evt) {
			evt.preventDefault();
			evt.stopPropagation();
			this.doContentAction(evt, $(evt.target), $(evt.target).attr("data-params"));
		},
		/**
		 * Called when user clicks on an action in tab content
		 * Action is identified by data-param attribute
		 */
		doContentAction: function(evt, $$target, params) {},
		/**
		 * Called when user clicks on Apply button
		 */
		doActionApply: function() {
			return $.smResolve(true);

		},
		/**
		 * Panel is resized
		 */
		onResize: function(context) {
			if (this._gestureMgr && this.$$content.is(':visible')) {
				this.updateGesture(context);
			}
		},
		/**
		 * Panel is opened
		 */
		notifyOpenPanel: function() {},
		/**
		 * Panel is closed
		 */
		notifyClosePanel: function() {},
		updateGesture: function(context) {
			if (!this._gestureMgr) return;
			// reset old scrolling to calculate width/height (mandatory in native mode)
			this._gestureMgr.reset();
			var viewRect = uiRect.elmtRect(this.$$scrollWrapper).intersectRect(uiRect.elmtRect(this.panel.$$elmt));
			if (viewRect && viewRect.height < this.$$scrollElmt.height()) {
				this._gestureMgr.init(viewRect);
			}
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/sortfilter/tabSort',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/panels/sortfilter/tabBase','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/panels/sortfilter/tabBase').TabBase;
var modules = require('syracuse-tablet/html/js/common/modules');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _templates = {
	main: '\
		<div id="sorttabroot" class="s-m-scroll-wrapper">\
			<ul class="list-group s-m-scroll-elmt"/>\
		</div>',
	items: '\
		{{#each items}}\
			<li class="list-group-item" data-params="{{id}}">\
				<span>{{name}}</span>\
				<span class="s-m-order ' + fontUtils.sortIcon("desc") + '  {{#smCompare sort "desc"}}enabled{{/smCompare}}" data-params="desc"></span>\
				<span class="s-m-order ' + fontUtils.sortIcon("asc") + '  {{#smCompare sort "asc"}}enabled{{/smCompare}}" data-params="asc"></span>\
			</li>\
		{{/each}}',
	/** Add this line to add the remove icon
	 * <span class="s-m-order ' + fontUtils.sortIcon("none") + ' " data-params="none"></span>
	 */
};


var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};
/**
 * Sort tab
 */
exports.TabSort = utils.defineClass(
	function TabSort(panel, id, options) {
		options = options || {};
		options.hidden = options.hidden === true || panel.sortInfoGet(false).length === 0;
		Base.call(this, panel, id, options);
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.$$list = null;
		},
		buildHtml: function() {
			this.$$content.append($(_getHtml("main", {})));
			this.$$list = this.$$content.find("ul.list-group");
		},
		/**
		 * Save sort info
		 */
		doActionApply: function() {
			this.panel.sortInfoSet($.extend(true, [], this.sortInfo), true);
			return this.panel.savePagePrefs().then(function() {
				return true;
			}).fail(function(error) {
				modules.get("modal").error(error);
			})
		},
		_buildSortInfo: function() {
			var status = {};
			this.$$content.find(".s-m-order.enabled").each(function(idx, $$e) {
				$$e = $($$e);
				status[$$e.parent().attr("data-params")] = $$e.attr("data-params");
			});
			this.sortInfo = this.sortInfo || [];
			this.sortInfo.forEach(function(i) {
				i.sort = status[i.id] || "none";
			});
		},
		getFavoritesData: function() {
			this._buildSortInfo();
			return $.extend(true, [], this.sortInfo);
		},
		doContentAction: function(evt, $$target, dataParams) {
			if ($$target.hasClass("enabled")) {
				$$target.removeClass('enabled');
			} else {
				(this.options.singleCriteria === true ? this.$$content : $$target.parent()).find(".s-m-order.enabled").removeClass('enabled');
				$$target.addClass("enabled");
			};
			this._buildSortInfo();
		},
		/**
		 * We remove the content on close to cancel modifications
		 */
		notifyClosePanel: function() {
			Base.prototype.notifyClosePanel.call(this);
			if (this.$$items) {
				this.$$items.remove();
				this.$$items = null;
			}
			this.sortInfo = null;
		},
		/**
		 * Tab becomes Active - we create content
		 */
		doTabShow: function() {
			Base.prototype.doTabShow.call(this);
			if (this.$$items) this.$$items.remove();
			// We clone to keep a different copy from array one		
			this.sortInfo = this.sortInfo || $.extend(true, [], this.panel.sortInfoGet());
			this.$$items = $(_getHtml("items", {
				items: this.sortInfo
			}));
			this.$$list.append(this.$$items);
		}
	});
});

define('syracuse-tablet/html/js/controllers/formController',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/sdata/prototype','syracuse-tablet/html/js/controllers/sdataController','syracuse-tablet/html/js/controls/articleParser'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var proto = require('syracuse-tablet/html/js/sdata/prototype').Prototype;
var Base = require("syracuse-tablet/html/js/controllers/sdataController").SdataController;
var articleParser = require("syracuse-tablet/html/js/controls/articleParser");

var _createProto = function(protoJson, protoParent, baseUrl) {
	if (!protoParent && baseUrl) {
		protoJson.$baseUrl = baseUrl;
	}
	return new proto(protoJson);
};

var _createArticle = function(proto) {
	var article = {
		"$layoutType": "stack",
		"$items": []
	};
	var protoJson = proto.data("$properties", null, true, true);
	Object.keys(protoJson).forEach(function(key) {
		if (!protoJson[key].$isExcluded) {
			article.$items.push({
				"$bind": key
			});
		}
	});
	return article;
};
/**
 * options
 * 		$activity	read by default
 */
var _Klass = utils.defineClass(
	function(id, proto, article, dataset, options) {
		if (article == null) {
			article = _createArticle(proto);
		}
		this.article = article;
		Base.call(this, dataset, null, false);
	}, Base, {
		destroy: function() {
			if (this.destroyed === true) {
				return;
			}
			Base.prototype.destroy.call(this);
			if (this.rootLayout == null) {
				this.rootLayout.destroy();
			}
			this.rootLayout = null;
			this.$$formParent = null;
			this.article = null;
		},
		render: function($$parent, opts) {
			if (this.rootLayout == null) {
				this.buildControlsTree();
			};
			this.$$formParent.attr("data-controller-id", this.id);
			this.rootLayout.set$$container($$parent);
			this.rootLayout.buildHtml();
			// USed to retrieve the controller on events
			this.rootLayout.$$elmt.attr("data-controller-id", this.id);
		},
		/**
		 * Show element in page - scroll if needed
		 * c is a JQuery elmt or an object with $$elmt property
		 */
		makeVisible: function(c) {
			// TODO - Implement a gestureManager in base controller to allow makeVisible
		},
		buildControlsTree: function() {
			if (this.rootLayout) {
				this.rootLayout.destroy();
			}
			this.rootLayout = articleParser.parseArticle(this, this.article);
			return this.rootLayout;

		},
		isEditMode: function() {
			return true;
		},
		applyChange: function(delta) {
			this.dataset.applyDelta(delta);
		}
	});


exports.createProto = _createProto;
exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/panels/sortfilter/tabFilterEdit',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controllers/formController','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/fieldOperators','syracuse-tablet/html/js/sdata/dataset','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var formController = require('syracuse-tablet/html/js/controllers/formController');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');
var Dataset = require('syracuse-tablet/html/js/sdata/dataset').Dataset;
var modules = require('syracuse-tablet/html/js/common/modules');


var _templates = {
	main: '\
		<section id="formtabroot">\
			<div class="s-m-scroll-wrapper">\
				<div id="formtabform"/>\
			</div>\
			<div class="btn-group btn-group-justified" role="group">\
				<a type="button" class="btn btn-default" data-params="cancelFilterEdit">\
					<i class="fa fa-times" data-params="cancelFilterEdit"></i>\
				</a>\
				<a type="button" class="btn btn-default disabled" data-params="submitFilterEdit">\
					<i class="fa fa-check" data-params="submitFilterEdit"></i>\
				</a>\
			</div>\
		</section>'
};


var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

var _buildOperatorsEnum = function(operators) {
	var res = [];
	$.each(operators, function(idx, op) {
		res.push({
			$value: op,
			$title: locale.text("field.operator." + op)
		});
	});
	return res;
};

var FormKlass = utils.defineClass(
	function(proto, dao, filtersMap, $$formParent) {
		formController.Klass.call(this, utils.readableuid("FILTERFORM"), proto, null, dao, {
			$activity: "edit"
		});
		this.$$formParent = $$formParent;
		this.filtersMap = filtersMap;
	}, formController.Klass, {
		destroy: function() {
			formController.Klass.prototype.destroy.call(this);
		},
		// user changes Input value 
		setValue: function($bind, value) {
			var self = this;
			switch ($bind) {
				case "FIELDS":

					// nothing to do. user selected "select field" option
					if (value == 0) {
						// set button validate disabled
						this._toggleSave(false);
						return;
					} else {
						// set button validate enabled
						this._toggleSave(true);
						var fm = self.filtersMap[value - 1];
						// UPDATE OPERATORS CHOICE CTRL & VALUE FIELD TYPE

						// build new enum
						var operators = fm.operators;
						var $newEnum = _buildOperatorsEnum(operators);

						var newData = {
							"$properties": {
								"OPERATORS": {
									"$value": {
										$enum: $newEnum
									},
									$isReadOnly: false
								}
							},
							"OPERATORS": $newEnum[0].$value
						};
						// hide previously displayed value field
						if (self.keyToHide) {
							newData.$properties[self.keyToHide] = {
								$isHidden: true
							};
						}
						// For reference fields, meta-data ($properties) is given by the field that contains the data
						//var keyToShow = fm.isReference ? fm.id : "VALUE-" + fm.id;
						var keyToShow = "VALUE-" + fm.id;
						newData.$properties[keyToShow] = {
							$isHidden: false
						};
						self.keyToHide = keyToShow;

						// apply change
						window.setTimeout(function() {
							self.applyChange($.extend(true, {}, newData));
						});
					}
					break;
				case "OPERATORS":
					// TODO handle specific operators such as "between", "empty", "not empty"
					formController.Klass.prototype.setValue.call(this, $bind, value, true)
					break;
				default:
					formController.Klass.prototype.setValue.call(this, $bind, value, true)
			}
		},
		// check that data is set
		validateForm: function() {
			var self = this;
			var res = true;
			this.forEachControl(function(ctrl, idx) {
				var bind = ctrl.$bind;
				res = (bind && (bind !== "OPERATORS" || bind !== "FIELDS" || bind !== self.keyToHide)) ? (res ? ctrl.validateInput() : res) : res
			});
			return res;
		},
		applyChange: function(newData) {
			formController.Klass.prototype.applyChange.call(this, newData);
			this._toggleSave(newData != null && !$.isEmptyObject(newData));
		},
		render: function($$parent, buildOpts) {
			formController.Klass.prototype.render.call(this, $$parent, buildOpts);
			this._toggleSave(false);
		},
		_toggleSave: function(enable) {
			$("a[data-params='submitFilterEdit']", this.$$formParent).toggleClass("disabled", !enable);
		}
	});
/**
 * Filter edit tab
 */
exports.TabFilterEdit = utils.defineClass(
	function(parentTab) {
		this.controller = null;
		this.$$content = $(_getHtml("main", {}));
		this.$$formtabform = this.$$content.find("#formtabform");
		this.parentTab = parentTab;
		this.panel = parentTab.panel;
	}, null, {
		destroy: function() {
			if (this.controller) {
				this.controller.destroy();
				this.controller = null;
			}
			this.$$content = null;
			this.$$formtabform = null;
			this.parentTab = null;
			this.panel = null;
			this.panel = null;
		},
		/**
		 * Create content
		 */
		create: function($$container) {
			var self = this;

			if (self.$$content.parent().length == 0) {
				$$container.append(self.$$content);
			}

			self.$$formtabform.empty();

			var protoJson;
			var dataJson;

			var res = self._buildProtoJson();
			protoJson = res.protoJson;
			dataJson = res.dataJson;


			var proto = formController.createProto(protoJson, null, self.panel.parentArray.prototype.data("$baseUrl"));
			var dataset = new Dataset(dataJson, proto);

			self.controller = new FormKlass(proto, dataset, self.filtersMap, self.$$content);
			self.controller.render(self.$$formtabform, {});
			self.updateGesture();
			if (self.initData) {
				window.setTimeout(function() {
					// Enable save if a filter exists
					self.controller.applyChange($.extend(true, {}, self.initData), true);
					self.controller.keyToHide = self.initKeyToHide;
				});
			}

		},
		updateGesture: function() {
			this.parentTab.updateGesture();
		},
		_getFiltersMap: function() {
			var self = this;
			self.filtersMap = self.filtersMap || self.panel.filterMapGet();
			return self.filtersMap;
		},
		_buildProtoJson: function() {
			var self = this;

			var choiceData = {};

			self.filtersMap = self._getFiltersMap();

			// init json
			var protoJson = {
				"$properties": {
					"FIELDS": {
						"$title": locale.text("panels.array.filterForm.field"),
						"$type": "application/x-choice",
						"$value": {
							"$type": "application/x-integer",
							"$enum": []
						},
						"$isMandatory": true
					},
					"OPERATORS": {
						"$title": locale.text("panels.array.filterForm.operator"),
						"$type": "application/x-choice",
						"$value": {
							"$type": "application/x-string",
							"$enum": []
						},
						"$isReadOnly": true
					}
				},
				$localization: self.panel.parentArray.prototype.root.getValueByPath("$localization")
			};

			for (var ii = 0, jj = self.filtersMap.length; ii < jj; ii++) {

				var ff = self.filtersMap[ii];
				var key = "VALUE-" + ff.id;
				protoJson.$properties[key] = {
					$title: locale.text("panels.array.filterForm.value"),
					$type: ff.prop.$type,
					$isHidden: true,
					$item: ff.prop.$item,
					$value: ff.prop.$value
				};
				if (ff.isReference) {
					protoJson.$properties[ff.prop.$bindValue] = {
						$type: protoJson.$properties[ff.prop.$bindType],
						$isHidden: true,
						$isExcluded: true
					};
				}
				// in case of application/x-choice field, first value must be added to init dao
				if (ff.prop.$type.indexOf("choice") >= 0) {
					choiceData[key] = ff.prop.$value.$enum[0].$value;
				} else if (ff.prop.$type.indexOf("boolean") >= 0) {
					choiceData[key] = true;
					protoJson.$properties[key].$format = "$switch";
				}
			}


			// set fields choice ctrl values
			// protoJson.$properties.FIELDS.$value.$enum
			var $fieldEnum = [];
			$fieldEnum.push({
				$value: 0,
				$title: locale.text("panels.array.filterForm.fieldDefault")
			});
			$.each(self.filtersMap, function(idx, ff) {
				$fieldEnum.push({
					$value: idx + 1,
					$title: ff.fieldName
				});
			});
			protoJson.$properties.FIELDS.$value.$enum = $fieldEnum;

			// set operators choice ctrl default value
			// protoJson.$properties.OPERATORS.$value.$enum
			var $operatorDefEnum = [];
			var operators = fieldOperators.getOperators();
			protoJson.$properties.OPERATORS.$value.$enum = _buildOperatorsEnum(operators);

			var result = {
				protoJson: protoJson,
				dataJson: choiceData
			};

			return result;
		},
		/**
		 * Save sort info
		 */
		doActionApply: function() {
			if (!this.controller) {
				return $.smResolve(true);
			}
			if (!this.controller.checkControlsData()) {
				modules.get("modal").error("Data are invalid");
				return $.smResolve(false);
			} else {
				modules.get("modal").info("Data are valid");
				return this.panel.savePagePrefs().then(function() {
					return true;
				});
			}
		},
		doContentAction: function(evt, $$target, params) {
			var self = this;
			switch (params) {
				case "submitFilterEdit":
					self.onFilterEditSubmit();
					break;
				case "cancelFilterEdit":
					self.onCancelEdit();
					break;
			}
		},
		/*
		 * If user submits filter edit, update filter tab info,
		 */
		onFilterEditSubmit: function() {
			var self = this;
			if (self.controller.validateForm()) {
				// build filterInfo object with the following format
				/* {
					filterMapIdx: 'index in filterMap array',
					fieldName: "fieldName",
					operatorLabel: "operator label",
					value: "value to filter by",
					operator: "filter operator"
					id: "field code",
					prop: "field $value object"
				}
				*/
				self.filtersMap = self._getFiltersMap();
				var data = self.controller.dataset.getData();
				var fieldId, value, prop
				Object.keys(data.$properties).forEach(function(propertie) {
					if (propertie != "OPERATORS") { //only one
						fieldId = propertie;
						value = data[propertie];
					}

				});
				var filterMapIdx = -1,
					idx = 0
				self.filtersMap.forEach(function(filter) {
					if (fieldId === "VALUE-" + filter.id) {
						filterMapIdx = idx;
					}
					idx++
				})
				var operator = self.controller.dataset.getValue('OPERATORS');
				var prop = self.filtersMap[filterMapIdx].prop;

				var info = {
					filterMapIdx: filterMapIdx,
					fieldName: self.filtersMap[filterMapIdx].fieldName,
					operatorLabel: locale.text("field.operator." + operator),
					value: self._getValue(prop, value),
					operator: operator,
					id: self.filtersMap[filterMapIdx].id,
					prop: prop,
					originalValue: value,
					isReference: self.filtersMap[filterMapIdx].isReference
				};
				self.filterTab = self.filterTab || self.panel.getTabs().filter;
				self.filterTab.onFilterUpdate(info, !isNaN(parseInt(self.initIdx, 10)) && self.initIdx >= 0 ? self.initIdx : null);
				self._onTabClose();
			}
		},
		/* 	get value to be displayed in filter list (text value)
		 * 	this is particularly useful in case of application/x-choice fields
		 */
		_getValue: function(prop, value) {
			var self = this;
			var vv;
			if (typeof value === 'object') {
				vv = value.$value || value.$description || value.$title;
			} else {
				// in case of application/x-choice item, 
				// value to display should be $title of $enum if $value.$type -> 'application/x-integer'
				// else, value parameter is already ok
				if (prop.$type.indexOf("choice") >= 0) {
					vv = prop.$value.$type.indexOf("integer") >= 0 ? self.panel.parentArray.prototype.resolveExpression(prop.$value.$enum[parseInt(value - 1, 10)].$title) : value;
				} else {
					vv = value;
				}
			}
			return vv;
		},
		/*
		 * If user cancels filter edit, hide form and show filters list
		 */
		onCancelEdit: function() {
			var self = this;
			self._onTabClose();
			self.parentTab.toggleList(true);
		},
		/*
		* Create init data for that will be used to create the filter edit
		* init data JSON structure is {
			"FIELDS": "index among enum, as a string",
			"OPERATORS": "operator value",
			"VALUE": "filter value"
		}

		info parameter JSON structure is {
			filterMapIdx: 'index in filterMap array',
			fieldName: "fieldName",
			operatorLabel: "operator label",
			value: "value to filter by",
			operator: "filter operator"
			id: "field code",
			prop: "field $value object"
		}
		*/
		setInitData: function(info, initIdx) {
			var self = this;

			self.filtersMap = self._getFiltersMap();

			// get idx
			var filterMapIdx = info.filterMapIdx;
			var ff = self.filtersMap[filterMapIdx];

			// build init data
			self.initData = {
				$properties: {
					OPERATORS: {
						$value: {
							$enum: _buildOperatorsEnum(ff.operators)
						},
						$isReadOnly: false
					}
				},
				FIELDS: filterMapIdx + 1,
				OPERATORS: info.operator
			};

			if (ff.isReference) {
				self.initData[ff.id] = info.originalValue.$value;
			}
			self.initData["VALUE-" + ff.id] = info.originalValue;
			// For reference fields, meta-data ($properties) is given by the field that contains the data
			var bind = "VALUE-" + ff.id;
			self.initData.$properties[bind] = {
				$isHidden: false
			};

			self.initIdx = initIdx;

			// bind key will be used by the formController
			self.initKeyToHide = bind;
		},
		/*
		 * Cleaning actions
		 */
		_onTabClose: function() {
			var self = this;
			self.controller.destroy();
			self.controller = null;
			self.initData = null;
			self.initIdx = null;
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/sortfilter/tabFilter',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/panels/sortfilter/tabBase','syracuse-tablet/html/js/controls/panels/sortfilter/tabFilterEdit','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/panels/sortfilter/tabBase').TabBase;
var FilterEdit = require('syracuse-tablet/html/js/controls/panels/sortfilter/tabFilterEdit').TabFilterEdit;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modules = require('syracuse-tablet/html/js/common/modules');

var _templates = {
	main: '\
		<div class="s-m-scroll-wrapper" style="height:100%">\
			<div  class="s-m-scroll-elmt">\
				<section id="filterlist">\
				</section>\
				<section id="filteredit">\
				</section>\
			</div>\
		</div>',
	filterList: '\
		<div id="filterListEmpty" style="display:none">\
			{{emptyList}}\
		</div>\
		<ul class="list-group"/>\
		<div class="btn-group btn-group-justified" role="group">\
			<a type="button" class="btn btn-default" data-params="addFilter">\
				<i class="fa fa-plus" data-params="addFilter"></i>\
			</a>\
		</div>',
	items: '\
		{{#each items}}\
			{{#unless  @first }}\
			<span class="s-m-filter-separator ' + fontUtils.filterIcon("separator") + '" ></span>\
			{{/unless}}\
			<li class="list-group-item" data-params="{{id}}">\
				<span class="s-m-filter-info"> \
					<span class="s-m-filter-field">{{fieldName}}</span>\
					<span class="s-m-filter-operator">{{operatorLabel}}</span>\
					<span class="s-m-filter-value">{{value}}</span>\
				</span>\
				<span class="s-m-filter ' + fontUtils.filterIcon("edit") + '" data-params="edit,{{@index}}"></span>\
				<span class="s-m-filter ' + fontUtils.filterIcon("delete") + '" data-params="delete,{{@index}}"></span>\
			</li>\
		{{/each}}'
};


var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

/**
 * Filter tab
 */
exports.TabFilter = utils.defineClass(
	function TabFilter(panel, id, options) {
		Base.call(this, panel, id, options);
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this.filterEdit) {
				this.filterEdit.destroy();
				this.filterEdit = null;
			}
			this.filterInfo = null;
			this.$$listSectio = null;
			this.$$list = null;
			this.$$editSection = null;
		},
		buildHtml: function() {
			this.$$content.append($(_getHtml("main", {})));
			this.$$editSection = this.$$content.find("#filteredit");
			this.$$listSection = this.$$content.find("#filterlist");
			$(_getHtml("filterList", {
				addFilter: locale.text("panels.array.addFilter"),
				emptyList: locale.text("panels.array.emptyList")
			})).appendTo(this.$$listSection);
			this.$$list = this.$$listSection.find(".list-group");
			this.$$emptyList = this.$$content.find("#filterListEmpty");
		},
		/**
		 * Tab becomes Active - we create content
		 */
		doTabShow: function() {
			if (this.initOpened) return;
			this.updateFilterList();
			this.initOpened = true;
		},
		/**
		 * Update filter list . If no filter set, display no filter information
		 **/
		updateFilterList: function(list) {
			// We clone to keep a different copy from array one
			this.filterInfo = list || (this.filterInfo && this.filterInfo.length > 0) ? this.filterInfo : $.extend(true, [], this.panel.filterInfoGet());
			this.$$emptyList.toggle(false);
			// clean current list
			this.$$list.empty();
			if (this.filterInfo && this.filterInfo.length > 0) {
				// append list
				var $$items = $(_getHtml("items", {
					items: this.filterInfo
				}));
				this.$$list.append($$items);
			} else {
				// no filter set
				this.$$emptyList.toggle(true);
			}
			this.updateGesture();
		},
		/**
		 * Save sort info
		 */
		doActionApply: function() {
			this.panel.filterInfoSet($.extend(true, [], this.filterInfo), true);
			return this.panel.savePagePrefs().then(function() {
				return true;
			}).fail(function(error) {
				modules.get("modal").error(error);
			});
		},
		getFavoritesData: function() {
			return $.extend(true, [], this.filterInfo);
		},
		/**
		 * Click on an element with data-param - edit delete...
		 */
		doContentAction: function(evt, $$target, dataParams) {
			if (!dataParams) return;
			var params = dataParams.split(",");
			switch (params[0]) {
				case "addFilter":
					this._openFilterEdit();
					break;
				case "cancelFilterEdit":
					this.filterEdit.onCancelEdit();
					break;
				case "submitFilterEdit":
					this.filterEdit.onFilterEditSubmit();
					break;
				case "delete":
					var idx = params[1];
					this._onFilterDelete(idx);
					break;
				case "edit":
					var idx = params[1];
					this._openFilterEdit(idx);
					break;
				default:
					return;
			}
		},
		/*
		 *	When user deletes one filter in filter list
		 */
		_onFilterDelete: function(idx) {
			if (this._isIndexValid(idx)) {
				this._removeFilter(idx);
				// argument this.fileterInfo when call updateFilterList to avoid get list from cache.
				this.updateFilterList(this.filterInfo);
			}
		},
		/*
		* Adds new filter info
		* {
			fieldName: "field name",
			operator: "selected operator label",
			value: "filtering value"
		}
		*/
		_addFilter: function(newFilterInfo) {
			this.filterInfo.push(newFilterInfo);
		},
		/*
		 * Remove filter
		 */
		_removeFilter: function(idx) {
			if (this._isIndexValid(idx)) {
				this.filterInfo.splice(idx, 1);
			}
		},
		/*
		 * Update filter
		 */
		_updateFilter: function(idx, updateFilterInfo) {
			if (this._isIndexValid(idx)) {
				this.filterInfo.splice(idx, 1, updateFilterInfo);
			}
		},
		/*
		 * If user cancels filter edit, hide form and show filters list
		 */
		_onCancelEdit: function() {
			this.$$editSection.empty();
			this.$$listSection.toggle(true);
		},
		/*Build filter set/add form */
		_openFilterEdit: function(filterIdx) {
			// get filter edit object
			this.filterEdit = this.filterEdit || new FilterEdit(this);

			// set init data
			if (this._isIndexValid(filterIdx)) {
				this.filterEdit.setInitData(this.filterInfo[filterIdx], filterIdx);
			}

			// create filter edit content
			this.filterEdit.create(this.$$editSection);

			// hide filter list
			this.toggleList(false);

		},
		_isIndexValid: function(idx) {
			return !isNaN(parseInt(idx, 10)) && idx >= 0;
		},
		onFilterUpdate: function(filterInfo, filterIdx) {
			if (this._isIndexValid(filterIdx)) {
				this._updateFilter(filterIdx, filterInfo);
			} else {
				this._addFilter(filterInfo);
			}

			// update list
			this.updateFilterList();

			// show list
			this.toggleList(true);
		},
		toggleList: function(show) {
			this.$$listSection.toggle(show);
			if (this.filterEdit) {
				this.filterEdit.$$content.toggle(!show);
			}
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/sortfilter/tabMemo',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/controls/panels/sortfilter/tabBase','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var Base = require('syracuse-tablet/html/js/controls/panels/sortfilter/tabBase').TabBase;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modules = require('syracuse-tablet/html/js/common/modules');

var _templates = {
	main: '\
		<div id="memotabroot" class="s-m-scroll-wrapper" style="height:100%">\
			<div  class="s-m-scroll-elmt">\
				<ul class="list-group"/>\
			</div>\
		</div>',
	items: '\
		{{#each items}}\
			<li class="list-group-item" data-params="{{@index}}">\
				<span class="s-m-memo-info"><a draggable="false" href="#" data-params="click">{{title}}</a>\
				<div style="display:none" class="s-m-value edit"><input class="s-m-meta form-control" type="text" value="{{title}}"></div>\
				</span>\
				<span class="s-m-memo ' + fontUtils.filterIcon("edit") + '" data-params="edit"></span>\
				<span class="s-m-memo ' + fontUtils.filterIcon("delete") + '" data-params="delete"></span>\
			</li>\
		{{/each}}',
	/** Add this line to add the remove icon
	 * <span class="s-m-order ' + fontUtils.sortIcon("none") + ' " data-params="none"></span>
	 */
};


var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};
/**
 * Sort tab
 */
exports.TabMemo = utils.defineClass(
	function TabMemo(panel, id, options) {
		options = options || {};
		options.hidden = false;
		Base.call(this, panel, id, options);
		this.currentSelection = null;

		var prefs = this.panel.getPagePrefs();
		this.favorites = prefs.favorites || [];
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.$$edit = null;
			this.$$display = null;
			this.currentSelection = null;
		},
		buildHtml: function() {
			this.$$content.append($(_getHtml("main", {})));
			this.$$list = this.$$content.find("ul.list-group");
			this.$$list.css({
				height: "auto",
				position: "relative"
			});
			this.$$list.on('blur', "input", jsutils.bindFn(this.onBlur, this));
		},
		/**
		 * We remove the content on close to cancel modifications
		 */
		notifyClosePanel: function() {
			Base.prototype.notifyClosePanel.call(this);
			if (this.$$items) {
				this.$$items.remove();
				this.$$items = null;
			}
		},
		/**
		 * Tab becomes Active - we create content
		 */
		doTabShow: function() {
			Base.prototype.doTabShow.call(this);
			this._render();
			this._setButtonsState();
		},
		_setButtonsState: function() {
			this.panel.setButtonsState(false, this.currentSelection != null); //currentSelection could be undefined
		},
		_render: function() {
			if (this.$$items) this.$$items.remove();
			// We clone to keep a different copy from array one		
			this.$$items = $(_getHtml("items", {
				items: this.favorites,
			}));
			this.$$list.append(this.$$items);
			if (this.currentSelection != null) this._selectCurrent(this.currentSelection);
			this.updateGesture();
		},
		doContentAction: function(evt, $$target, dataParams) {
			if (!dataParams) return;
			switch (dataParams) {
				case "delete":
					var idx = $$target.closest("li").index();
					this._onMemoDelete(idx);
					break;
				case "edit":
					this._openMemoEdit($$target.closest("li"));
					break;
				case "click":
					var idx = $$target.closest("li").index();
					this._onMemoClick(idx);
					break;
				default:
					return;
			}
		},
		_onMemoDelete: function(idx) {
			var self = this;
			self._unSelectCurrent();
			self.favorites.splice(idx, 1);
			self.saveFavorites().then(function() {
				self._render();
			});

		},
		_openMemoEdit: function(li) {
			this.$$edit = $(li).find(".s-m-value.edit");
			this.$$display = $(li).find("a");
			this._setEditMode();

		},
		_onMemoClick: function(idx) {
			if (idx != this.currentSelection) {
				this._unSelectCurrent();
			};
			this._selectCurrent(idx);
		},
		_unSelectCurrent: function() {
			this.$$list.find(".selected").toggleClass("selected");
			this.currentSelection = null;
			this._setButtonsState();
		},
		_selectCurrent: function(idx) {
			this.currentSelection = idx;
			this.$$list.find("[data-params='" + this.currentSelection + "']").toggleClass("selected");
			this._setButtonsState();
		},
		onBlur: function() {
			var self = this;
			self._updateValue().then(function() {
				self._setDisplayMode();
			});
		},
		_setDisplayMode: function() {
			this.$$edit.toggle(false);
			this.$$display.toggle(true);
			this.$$edit = null;
			this.$$display = null;
		},
		_setEditMode: function() {
			this._unSelectCurrent();
			this.$$edit.toggle(true);
			this.$$display.toggle(false);
			this.$$edit.children().focus();
			this.$$edit.children().select();
		},
		_updateValue: function() {
			var idx = this.$$display.closest("li").index();
			var value = this.$$edit.children().val();
			this.$$display.text(value);
			this.favorites[idx].title = value;
			return this.saveFavorites().then(function() {
				return true
			});
		},
		doActionApply: function() {
			if (this.currentSelection !== null) {
				var fav = this.favorites[this.currentSelection];
				if (fav) {
					this.panel.sortInfoSet($.extend(true, [], fav.sort), false);
					this.panel.filterInfoSet($.extend(true, [], fav.filter), true);
				}
			}
			return $.smResolve(true);
		},
		addFavorite: function(favData) {
			if (!favData) {
				return $.smResolve();
			}
			this.favorites.push(favData);

			return this.saveFavorites()
				.then(function() {
					var notify = {
						severityClass: "success",
						title: favData.title,
						body: locale.text("panels.array.memo.created"),
						onlyWebapp: true
					};
					modules.get("modal").notify(notify);
				});

		},
		saveFavorites: function() {
			var prefs = this.panel.getPagePrefs();
			prefs.favorites = this.favorites;
			prefs.isDirty = true;
			return this.panel.savePagePrefs().then(function() {
				return true
			});
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/sortfilter/panelFilterSort',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/controls/panels/aside/panelAsideBase','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/controls/panels/sortfilter/tabSort','syracuse-tablet/html/js/controls/panels/sortfilter/tabFilter','syracuse-tablet/html/js/controls/panels/sortfilter/tabMemo'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var Base = require('syracuse-tablet/html/js/controls/panels/aside/panelAsideBase').PanelAsideBase;
var locale = require('syracuse-tablet/html/js/helpers/locale');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _Sort = require('syracuse-tablet/html/js/controls/panels/sortfilter/tabSort').TabSort;
var _Filter = require('syracuse-tablet/html/js/controls/panels/sortfilter/tabFilter').TabFilter;
var _Memo = require('syracuse-tablet/html/js/controls/panels/sortfilter/tabMemo').TabMemo;

var _templates = {
	main: '\
			<nav class="nav-header">\
				<nav class="title">\
					<div >{{title}}</div>\
				</nav>\
				<div class="btn-group header-btn" role="group">\
					<a type="button" class="btn btn-default ' + fontUtils.sortFilterTab("memo") + '" data-params="memo"></a>\
					<a type="button" class="btn btn-default ' + fontUtils.sortFilterTab("apply") + '" data-params="apply"></a>\
				</div>\
			</nav>\
			<ul class="nav nav-pills" role="tablist"> \
				{{#each tabs}}\
					<li><a href="#{{id}}" class="" role="tab" data-toggle="tab">{{title}}</a></li> \
				{{/each}}\
			</ul> \
			<div class="tab-content">\
				{{#each tabs}}\
					<div id="{{id}}" role="tabpanel" class="tab-pane {{type}}">\
					</div>\
				{{/each}}\
			</div>',
};


var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

var _tabDescr = [{
	klass: _Sort,
	options: {
		name: "sort",
		isActive: true,
		singleCriteria: true,
	}
}, {
	klass: _Filter,
	options: {
		name: "filter",
		isActive: false,
	}
}, {
	klass: _Memo,
	options: {
		name: "memo",
		isActive: false
	}
}];

/**
 * Arrays Sort/Filter panel
 * Options
		filter: 		false to hide filter tab
		sort: 			false to hide sort tab
 */
exports.PanelFilterSort = utils.defineClass(
	function PanelFilterSort(controller, $type, article, options) {
		options = options || {};
		options.noCloseOnClick = true;
		// Scroller is managed by tabs
		options.enableGesture = false;
		this._tabs = {};
		Base.call(this, controller, $type, article, options);
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this._activeTab = null;
			var self = this;
			notifications.unsubscribe(self, ["sm.click.icon.filterSort"]);
			if (this._tabs) {
				$.each(this._tabs, function(key, value) {
					value.destroy();
				});
				this._tabs = null;
			}
			if (this.$$btnBar) {
				this.$$btnBar.unbind();
				this.$$btnBar.remove();
				this.$$btnBar = null;
			};
			this.parentArray = null
		},
		/**
		 * Build panel and tabs html
		 */
		buildHtml: function(side) {
			var self = this;
			notifications.subscribe(self, ["sm.click.icon.filterSort"]);
			Base.prototype.buildHtml.call(this, side);
			self.$$elmt.addClass(self.typeName);
			if (self.$$panel) {
				self.$$panel.remove();
			}
			var ctx = {
				title: locale.text("panels.array.title"),
				ctrlId: self.id,
				side: side,
				apply: locale.text("panels.array.apply"),
				close: locale.text("panels.array.close"),
				/* There's no titles for queries*/
				tabs: [],
			};
			var descriptions = [];
			/**
			 * We can disable filter or sort with self.options.filter = false or  self.options.sort
			 */
			_tabDescr.forEach(function(descr) {
				descr = $.extend({}, descr);
				descr.options.hidden = self.options[descr.options.name] === false;
				descriptions.push(descr);
			});
			var ids = {};
			descriptions.forEach(function(descr) {
				ids[descr.options.name] = utils.readableuid("array" + descr.options.name);
				ctx.tabs.push({
					id: ids[descr.options.name],
					//title: descr.title || locale.text("panels.array." + descr.options.name),
					icon: fontUtils.sortFilterTab(descr.options.name),
					type: descr.options.name,
					buttons: descr.options.buttons,
					title: locale.text("panels.array." + descr.options.name),
				});
			});
			self.$$panel = $(_getHtml("main", ctx));
			if (self.$$panel && self.$$panel.length) {
				self.$$panelContent.append(self.$$panel);
				var visibleTabs = [];
				var activeIdx = -1;
				// Create tabs
				descriptions.forEach(function(descr, idx) {
					var t = new descr.klass(self, ids[descr.options.name], descr.options);
					if (descr.options.hidden) {
						t.hide();
					} else {
						visibleTabs.push(t);
						if (descr.options.isActive) {
							activeIdx = idx;
						}
					}
					self._tabs[descr.options.name] = t;
				});
				if (visibleTabs.length > 0) {
					this._activeTab = visibleTabs[activeIdx === -1 ? 0 : activeIdx];
					// Adjust width
					var width = visibleTabs.length === 1 ? "100%" : Math.round(1000 * 100 / visibleTabs.length) / 1000 + "%";
					visibleTabs.forEach(function(t) {
						t.setWidth(width);
					});
					self.$$btnBar = self.$$panelContent.find('.nav-header>.btn-group.header-btn');
					self.$$btnBar.on('click', '[data-params]', jsutils.bindFn(self.onBtnBarClick, this));
				} else {
					this.close();
				}
			}
		},
		/**
		 * Notification when panel is opened/closed
		 * Pass event to tabs
		 */
		notifyToggled: function(visible) {
			$.each(this._tabs, function(id, tab) {
				tab[visible ? "notifyOpenPanel" : "notifyClosePanel"]();
			});
			if (visible && this._activeTab) {
				this._activeTab.triggerActivate();
			}
		},
		onResize: function(context) {
			Base.prototype.onResize.call(this, context);
			if (this.destoyed || !this._tabs) return;
			$.each(this._tabs, function(id, tab) {
				tab.onResize(context);
			});
		},
		onBtnBarClick: function(evt) {
			evt.preventDefault();
			evt.stopPropagation();
			var $$target = $(evt.target);
			var params = $$target.attr("data-params");
			switch (params) {
				case "apply":
					this.applyTabSettings();
					break;
				case "memo":
					this.addFavorite();
					break;
			}
		},
		// Redirect apply button event to active tab
		applyTabSettings: function() {
			var self = this;
			if (!this._activeTab) {
				return;
			}
			this._activeTab.doActionApply()
				.then(function(close) {
					if (close) {
						self.hide();
					}
				});
		},
		// Collect data of every tab and send it to memo management tab
		addFavorite: function() {
			if (!this._activeTab) {
				return;
			}
			var favData = null;
			$.each(this._tabs, function(key, tab) {
				// Does panel contribute to favorites item?
				if (tab.getFavoritesData) {
					favData = favData || {};
					favData[key] = tab.getFavoritesData();
				}
			});
			if (favData) {
				favData.title = locale.text("panels.array.memo") + " " + utils.getCurISODateTime();
				var memoTab = this._tabs["memo"];
				memoTab.addFavorite(favData);
			}
		},
		notifyActiveTab: function(tab) {
			this._activeTab = tab;
			this.setButtonsState(true, true);
		},
		/*
		 *	Returns panel tabs
		 */
		getTabs: function() {
			return this._tabs;
		},
		notifClickIconFilterSort: function(context) {
			if (context && context.className) {
				if (context.className.indexOf("sorted") >= 0) {
					this.getTabs()["sort"].triggerActivate();
				} else if (context.className.indexOf("filtered") >= 0) {
					this.getTabs()["filter"].triggerActivate();
				}
			}
		},
		setButtonsState: function(memo, apply) {
			this.$$btnBar.find("[data-params='memo']").toggleClass("disabled", !memo);
			this.$$btnBar.find("[data-params='apply']").toggleClass("disabled", !apply);
		},
		getPagePrefs: function() {
			return this.parentArray.page.getPageSettings();

		},
		savePagePrefs: function() {
			// async write settings
			return this.parentArray.page.writePageSettings().then(function() {
				return true
			});
		},
		///
		/// END: Rendering
		///
		show: function() {
			if (!this.$$elmt) {
				this.buildHtml("right");
			}
			this._makeVisible();
			this.notifyToggled(true)
		},
		hide: function() {
			this._makeInvisible();
		},
		ensureParentArray: function(parentArrayId) {
			this.parentArray = this.controller.getControl(parentArrayId)
		},
		filterInfoGet: function() {
			return this.parentArray.filterSort.filterInfoGet()
		},
		filterInfoSet: function(info, refresh) {
			this.parentArray.filterSort.filterInfoSet(info, refresh)
		},
		filterMapGet: function() {
			return this.parentArray.filterSort.filterMapGet()
		},
		sortInfoGet: function() {
			return this.parentArray.filterSort.sortInfoGet()
		},
		sortInfoSet: function(info, refresh) {
			this.parentArray.filterSort.sortInfoSet(info, refresh)
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/crumbs/breadcrumbsTablet',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/ui/uiSettings','syracuse-tablet/html/js/app/navigationPageStack','syracuse-tablet/html/js/app/eventListener','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').CtrlBase;
var uiSettings = require('syracuse-tablet/html/js/ui/uiSettings');

var navigationPageStack = require('syracuse-tablet/html/js/app/navigationPageStack');
var eventListener = require('syracuse-tablet/html/js/app/eventListener');
var modules = require('syracuse-tablet/html/js/common/modules');

var _html = {
	items: '\
		<div class="s-m-items">\
		{{{itemsHtml}}}\
		</div>\
		',
	item: '<a draggable="false" \
		href="#" \
		{{{attrs}}}><div class="s-m-item">\
		<div class="s-m-text">{{text}}</div>\
		{{#if notLast}}<div class="fa fa-caret-right s-m-icon-small"></div>{{/if}}\
		</div></a>'
};
var _templates = {};

function _getHtml(name, ctx) {
	var tmpl = _templates[name];
	if (!tmpl) {
		tmpl = _templates[name] = Handlebars.compile(_html[name]);
	}
	return tmpl(ctx);
};
/**
 * 
 */
exports.BreadcrumbsTablet = utils.defineClass(function BreadcrumbsTablet(controller, type, article, opts) {
	Base.call(this, controller, type, article, opts);
}, Base, {
	destroy: function() {
		Base.prototype.destroy.call(this);

		// Do not call destroy since we did not create the adapter but just reference to it
		this.actionAdapter = null;
		this._stack = null;
	},

	//
	// START: Rendering
	// 
	buildHtml: function() {
		this.createRootElement(["s-m-panel", "s-m-control", "s-m-ctrl", "breadcrumbs"]);

		this.$$elmt.css("height", this.getDesiredHeight());
		this._stack = navigationPageStack.findClosest(this.$$elmt);

		this._buildItems();

		this.$$container.show();
	},

	_buildItems: function() {
		this.$$elmt.empty();
		if (!this._stack) {
			return;
		}
		var stackItems = this._stack.getStackItems();
		var items = [];
		var idx = 0;
		for (var i = 0; i < stackItems.length; i++) {
			var si = stackItems[i];
			if (si.noHistory !== true) {
				var attrs = eventListener.getDataActionAttrs(this.controller.id, "itemClicked", si.id, true);
				items.push(_getHtml("item", {
					attrs: attrs,
					text: si.title,
					notLast: idx !== 0
				}));
				idx++;
			}
		}
		items.reverse();
		this.$$elmt.append($(_getHtml("items", {
			itemsHtml: items.join("")
		})));

	},

	//
	// END: Rendering
	//
	setTop: function(top) {
		this.top = top;
	},
	/**
	 * 
	 */
	computeLayout: function(layoutInfo) {
		if (!this.$$container) {
			return;
		}
		this.$$container.css({
			top: this.top + "px",
			width: layoutInfo.application.width + "px",
		});
	},
	getDesiredHeight: function() {
		return uiSettings.getProp("breadcrumbs.height");
	},
	_actItemClicked: function(id) {
		this._stack.goBackToId(id)
			.fail(function(e) {
				modules.get("modal").error(e);
			});
	},
	createId: function(typeName) {
		return utils.readableuid(typeName);
	},
	/**
	 * Built with the rank of the layout in generation process to be reliable
	 */
	getUnitTestId: function() {
		if (this.options.index == null) return;
		return utils.unitTestId(this.typeName.toLowerCase(), this.options.index);
	},
	getGestureMgr: function() {
		return null;
	}
});
});

define('syracuse-tablet/html/js/controls/panels/toolBars/chartDetailToolBar',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/sdata/prototype','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/ui/uiSettings'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');

var prototype = require('syracuse-tablet/html/js/sdata/prototype');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').CtrlBase;
var uiSettings = require('syracuse-tablet/html/js/ui/uiSettings');

var _actions = [{
	params: "arrayOnly",
	icon: "fa fa-table",
	enabled: true,
	selected: "",
}, {
	params: "chartOnly",
	icon: "fa fa-bar-chart",
	enabled: true,
	selected: "",
}, {
	params: "bothSideToSide",
	icon: "fa fa-columns",
	enabled: true,
	selected: "",
}];
var _chartStyle = [{
	params: "column",
	icon: "fa fa-bar-chart",
	enabled: true,
	selected: "",
}, {
	params: "bar",
	icon: "fa fa-bar-chart fa-rotate-90",
	enabled: true,
	selected: "",
}, {
	params: "area",
	icon: "fa fa-area-chart",
	enabled: true,
	selected: "",
}, {
	params: "line",
	icon: "fa fa-line-chart",
	enabled: true,
	selected: "",
}, {
	params: "pie",
	icon: "fa fa-pie-chart",
	enabled: true,
	selected: "",
}];
var _templates = {
	toolbar: '\
		<div class="btn-toolbar" role="toolbar">\
			<div class="btn-group">\
				{{#each actions}}\
					{{#if enabled}}\
					<button type="button" class="btn btn-default {{selected}}" data-nevent data-naction="toolbar" data-params="{{params}}"><span class="{{icon}}"></span></button>\
					{{/if}}\
				{{/each}}\
		    </div>\
			<div class="btn-group chartstyles">\
				{{#each chartStyle}}\
					{{#if enabled}}\
					<button type="button" class="btn btn-default {{selected}}" data-nevent data-naction="chartstyle" data-params="{{params}}"><span class="{{icon}}"></span></button>\
					{{/if}}\
				{{/each}}\
		    </div>\
	    </div>'

};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	if (!tmpl) alert("template " + name + " not found");
	return tmpl(ctx);
};


/**
 * chartDetail Tool bar
 */

exports.ChartDetailToolBar = utils.defineClass(
	function(controller, $type, article, options) {
		Base.call(this, controller, $type, article, options);
	}, Base, {
		buildHtml: function() {
			this._height = this.getDesiredHeight();
			var measureCount = this._getChartMeasureCount();
			var chartSettings = this.controller.uiAdapter.getChartDetailSetting() || {};
			var articles = this.controller.uiAdapter.getArticles(this.controller.uiAdapter.pageData.page.$article);
			var showActionBar = articles.arrayChartArticle && articles.arrayArticle;
			var showStyleBar = articles.arrayChartArticle != undefined;
			_chartStyle.forEach(function(itm) {
				itm.enabled = showStyleBar;
				itm.selected = "";
				if (itm.params == "pie") {
					itm.enabled = (measureCount == 1);
				}
				if (chartSettings.display === "arrayOnly") {
					itm.enabled = false
				}
				if (itm.params === chartSettings.style) {
					itm.selected = "s-m-selected"
				}
			});
			_actions.forEach(function(itm) {
				itm.enabled = showActionBar;
				itm.selected = ""
				if (itm.params === chartSettings.display) {
					itm.selected = "s-m-selected"
				}
			})
			this.createRootElement(["s-m-panel", "s-m-control", "s-m-ctrl", "toolbar"]);
			this.$$elmt.append($(_getHtml('toolbar', {
				ctrlId: this.id,
				actions: _actions,
				chartStyle: _chartStyle
			})));
			this.$$container.show();
		},
		computeLayout: function(layoutInfo) {
			if (!this.$$container) {
				return;
			}
			this.$$container.css({
				top: this.top + "px",
				width: layoutInfo.application.width + "px",
				height: this._height
			});
		},
		_getChartMeasureCount: function() {
			var chart = this.controller.getChart();
			if (!chart) return 0;
			var count = chart.prototype.chartGetNbMeasures();
			var $seriesOptions = chart.article.$seriesOptions;
			if (!$seriesOptions) return count;
			Object.keys($seriesOptions).forEach(function(key) {
				if ($seriesOptions[key].isHidden) {
					count--;
				}
			});
			return count;
		},
		getDesiredHeight: function() {
			return uiSettings.getProp("chartDetailToolbar.height");
		},
		getHeight: function() {
			return this.$$elmt.is(":visible") ? this._height : 0;
		},
		//
		// END: Rendering
		//
		setTop: function(top) {
			this.top = top;
		},
		_actToolbar: function(display) {
			if ($(".btn[data-params='" + display + "']", this.$$elmt).is(".s-m-selected")) return;
			this.controller.actChartToolbarSetDisplay({
				"display": display
			});
		},
		_actChartstyle: function(chartType) {
			if ($(".btn[data-params='" + chartType + "']", this.$$elmt).is(".s-m-selected")) return;
			this.controller.actChartToolbarSetDisplay({
				"style": chartType
			});
		}
	});
});

define('syracuse-tablet/html/js/controls/panels/aside/panelShare',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/ui/datetimeSelectors/selectorFactory','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/helpers/sharedContext','syracuse-tablet/html/js/controls/panels/aside/panelAsideBase'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var selectorFactory = require('syracuse-tablet/html/js/ui/datetimeSelectors/selectorFactory');
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var modules = require('syracuse-tablet/html/js/common/modules');
var native = require('syracuse-tablet/html/js/helpers/native/native');
var sharedContext = require('syracuse-tablet/html/js/helpers/sharedContext');

var Base = require('syracuse-tablet/html/js/controls/panels/aside/panelAsideBase').PanelAsideBase;

var _templates = {
	share: '\
	<div class="modal-subtitle" >{{share.title}}</div> \
	<div class="btn-group btn-group-justified" role="group">\
		<a type="button" href="#" class="btn btn-default" data-control-id="{{ctrlId}}" data-nevent data-naction="sharePageLink">\
			<i class="{{share.icon}}"/>\
		<span>{{{share.label}}}</span>\
		</a>\
	</div>',

	scheduleMessage: '\
	<div class="modal-subtitle">{{scheduleMessage.title}}</div> \
	<div class=""> \
		<div class="form-group"> \
			<table class="s-m-schedulemsg">\
			{{#each scheduleMessage.items}}\
			<tr>\
			<td>{{this.label}}</td>\
			<td>\
			{{#if this.picker }}\
				<div  class="input-group">\
					<input type="text" readonly="true" class="form-control" size="{{this.size}}" id="{{this.id}}" value="">\
					<span class="input-group-btn">\
						<button data-control-id="{{../../ctrlId}}" data-nevent data-naction="{{this.dataAction}}" data-params="{{this.id}} "class="btn btn-default">\
						<span class="{{this.icon}}"></span>\
					<\span>\
				<\div>\
			{{else}}\
				<input type="text"  \
				{{#if this.mandatory}}\
					mandatory="mandatory"\
				{{/if}}\
				class="form-control" size="{{this.size}}" id="{{this.id}}" value="">\
			{{/if}}\
			</td>\
			</tr>\
			{{/each}}\
			</table> \
			<div class="btn-group btn-group-justified" role="group">\
				<a type="button" class="btn btn-default"  data-nevent data-naction="scheduleMessage" data-control-id="{{ctrlId}}">{{scheduleMessage.btnApply}}</a>\
			</div>\
		</div> \
	</div>',

	liveTile: '\
		<div class="modal-subtitle">{{liveTile.title}}</div> \
		<div class=""> \
			<div class="form-group"> \
				<table class="s-m-livetile">\
				{{#each liveTile.items}}\
				{{#unless this.disabled}}\
				<tr>\
				{{#if this.picker }}\
					<td>{{this.label}}</td>\
					<td>\
					<div  class="input-group" id="{{this.id}}" style="width:100%">\
					<\div>\
					</td>\
				{{else}}\
					{{#if this.select}}\
						<td>{{this.label}}</td>\
						<td>\
						<select class="form-control" id="{{this.id}}" data-nevent data-naction="{{this.dataAction}}" data-control-id="{{../ctrlId}}">\
							{{#each pages}}\
								<option value="{{this.id}}">{{this.title}}</option>\
							{{/each}}\
						</select>\
						</td>\
					{{else}}\
						<td>{{this.label}}</td>\
						<td>\
						<input type="text"  \
							{{#if this.mandatory}}\
							mandatory="mandatory"\
							{{/if}}\
							class="form-control" size="{{this.size}}" id="{{this.id}}" value="">\
						</td>\
					{{/if}}\
				{{/if}}\
				</tr> \
				{{/unless}}\
				{{/each}}\
				</table> \
				<div class="btn-group btn-group-justified" role="group">\
					<a type="button" class="btn btn-default"  data-nevent data-naction="liveTileCreate" data-control-id="{{ctrlId}}">{{liveTile.btnApply}}</a>\
				</div>\
			</div> \
		</div>'
};
var _blocks = ["liveTile", "scheduleMessage", "share"];
var _liveTile = [{
	disabled: false,
	id: "vignette",
	select: true,
	dataAction: "choice",
	mandatory: true,
	size: 30
}, {
	disabled: false,
	id: "backgroundColor",
	size: 10,
	picker: true,
	component: "colorPalettePicker"
}, {
	disabled: false,
	id: "description",
	type: "application/x-string",
	defaultValue: "",
	size: 50,
	mandatory: true
}];
var _scheduleMsgItems = [{
	id: "date",
	size: 10,
	type: "application/x-date",
	icon: fontUtils.getIconByName("datePicker"),
	picker: true,
	dataAction: "datePicker",
	mandatory: true
}, {
	id: "time",
	size: 10,
	type: "application/x-time",
	icon: fontUtils.getIconByName("timePicker"),
	picker: true,
	dataAction: "timePicker",
	mandatory: true
}, {
	id: "description",
	size: 50,
	type: "application/x-string",
	mandatory: true
}];
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	if (!tmpl) alert("template " + name + " not found");
	return tmpl(ctx);
};

exports.PanelShare = utils.defineClass(
	function PanelShare(controller, $type, article, options) {
		Base.call(this, controller, $type, article, options);

		this.initPublishOptions();
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
		},

		initPublishOptions: function() {
			var self = this;
			var navStack = modules.get("navStack").getMainStack();
			var currentPage = navStack && navStack.getTopPage();
			this._htmlContext = {
				ctrlId: this.id
			};
			this._publishOptions = currentPage.getPublishOptions();

			_blocks.forEach(function(block) {
				if (self._publishOptions[block]) {
					self["_" + block]();
				}
			});
		},
		_liveTile: function() {
			var ctx;
			_liveTile.forEach(function(item) {
				item.label = locale.text("liveTile." + item.id + ".label");
			});
			ctx = {
				title: locale.text("liveTile.page.subtitle"),
				btnApply: locale.text("liveTile.apply.label"),
				items: _liveTile
			};
			_liveTile[0].pages = [];
			this._publishOptions.liveTile.pages.forEach(function(page) {
				_liveTile[0].pages.push({
					id: page.id,
					title: page.getPageTitle()
				});
			});
			this._htmlContext.liveTile = ctx;
		},
		_scheduleMessage: function() {
			var ctx;
			_scheduleMsgItems.forEach(function(item) {
				item.label = locale.text("schedule.message." + item.id + ".label");
			});
			ctx = {
				title: locale.text("schedule.message.page.subtitle"),
				btnApply: locale.text("schedule.message.apply.label"),
				items: _scheduleMsgItems
			};
			this._htmlContext.scheduleMessage = ctx;
		},
		_share: function() {
			var ctx = {
				title: locale.text("share.page.subtitle"),
				icon: fontUtils.pageIcon("nativeShare"),
				label: locale.text("action.nativeShare")
			};
			this._htmlContext.share = ctx;
		},
		buildHtml: function() {
			var self = this;
			Base.prototype.buildHtml.call(this);
			this.$$elmt.addClass(this.typeName);

			_blocks.forEach(function(block) {
				if (self._htmlContext[block]) {
					var html = _getHtml(block, self._htmlContext);
					self.$$panelContent.append($(html));
				}
			})

			_liveTile.forEach(function(item) {
				if (item.component) {
					self.components = self.components || {};
					var $$item = self.$$panelContent.find(".s-m-livetile #" + item.id);
					var opts = {};
					switch (item.component) {
						case "colorPalettePicker":
							opts = {
								id: item.id,
								palette: authPropsGeneral.getColorPalette(),
								dropUp: false,
								onSelectColor: jsutils.bindFn(self._colorChange, self)
							};
							break;
					}
					self.components[item.id] = authComponents.newComponent(item.component, opts);
					self.components[item.id].createMarkup($$item);

				};
			});
			if (this._publishOptions.liveTile) {
				this._actChoice(this._publishOptions.liveTile.pages[0].id)
				if (this._publishOptions.liveTile.pages.length < 2) {
					this.$$panelContent.find(".s-m-livetile #vignette").parent().parent().hide();
				}
			}

			this.$$panelContent.on('input', "[mandatory]", jsutils.bindFn(this._setButtonsStat, this));
			this._setButtonsStat();
			return;
		},

		onClickPanel: function(event) {
			return;
		},

		show: function() {
			if (!this.$$elmt) {
				this.buildHtml();
			}
			this._makeVisible();
		},
		hide: function() {
			this._makeInvisible();
		},
		_colorChange: function(value) {
			this._backgroundColor = value ? value.hex : null;
		},
		_setButtonsStat: function() {
			var self = this;
			var btnCreate = self.$$elmt.find("a[data-naction='liveTileCreate']"),
				disable = false,
				val = "";
			_liveTile.forEach(function(item) {
				if (!item.disabled && item.mandatory) {
					disable = disable || (self.$$panelContent.find(".s-m-livetile #" + item.id).val() == "");
				}
			});
			if (disable) {
				btnCreate.attr("disabled", "disabled");
			} else {
				btnCreate.removeAttr("disabled");
			};
			btnCreate = self.$$elmt.find("a[data-naction='scheduleMessage']"), disable = false, val = "";
			_scheduleMsgItems.forEach(function(item) {
				if (!item.disabled && item.mandatory) {
					disable = disable || (self.$$panelContent.find(".s-m-schedulemsg #" + item.id).val() == "");
				}
			});
			if (disable) {
				btnCreate.attr("disabled", "disabled");
			} else {
				btnCreate.removeAttr("disabled");
			};
		},
		onValueChange: function() {
			this._setButtonsStat();
		},
		_getItemLiveTile: function(id) {
			var found;
			_liveTile.some(function(item) {
				if (item.id === id) {
					found = item;
					return true;
				}
			});
			return found;
		},
		_actChoice: function(id) {
			var btnCreate = this.$$elmt.find("a[data-naction='liveTileCreate']");
			var value = this.$$elmt.find(".s-m-livetile #vignette").val();
			var itemDescription = this._getItemLiveTile("description");
			if (itemDescription && !itemDescription.disabled && itemDescription.defaultValue !== undefined) {
				this.$$elmt.find(".s-m-livetile #description").val(value ? this.$$elmt.find(".s-m-livetile #vignette option:selected").text() : "");
			}
			this._setButtonsStat();
		},
		_actDatePicker: function(id) {
			selectorFactory.createSelector(new _Field("application/x-date", this.$$panelContent.find(".s-m-schedulemsg #" + id), locale.text("schedule.message." + id + ".label"), this));
		},
		_actTimePicker: function(id) {
			selectorFactory.createSelector(new _Field("application/x-time", this.$$panelContent.find(".s-m-schedulemsg #" + id), locale.text("schedule.message." + id + ".label"), this));
		},
		_actSharePageLink: function() {
			var self = this;
			_getShareDeepLink(self._publishOptions.share.page)
				.then(function(deepLink) {
					var opts = {
						pageData: {
							Title: deepLink.Title,
							DeepLink: deepLink
						}
					};
					var cap = native.getModule("share");
					if (cap) {
						return cap.sharePageLink(opts);
					}
				})
				.then(function() {
					this._makeInvisible();
				})
		},
		_actScheduleMessage: function() {
			var self = this;
			var schedule = {};
			var msg;

			// Find date values
			_scheduleMsgItems.forEach(function(item) {
				var val = self.$$panelContent.find(".s-m-schedulemsg #" + item.id).attr("isoValue");
				if (val) {
					schedule[item.id] = schedule[item.id] || {};
					schedule[item.id].$type = item.$type;
					schedule[item.id].value = val;
				}
			});
			var desc = self.$$panelContent.find(".s-m-schedulemsg #description").val();
			_getShareDeepLink(self._publishOptions.share.page)
				.then(function(deepLink) {
					if (schedule.date && schedule.time) {
						msg = {
							Severity: "reminder",
							Text1: deepLink.Title,
							Text2: desc,
							ScheduleTime: schedule["date"].value + " " + schedule["time"].value,
							ScheduleTimeJSON: _getDateTimeInfo(schedule["date"].value, schedule["time"].value),
							DeepLink: deepLink
						};
					}

					var cap = native.getModule("scheduleMessage");
					if (cap && msg) {
						return cap.scheduledMsg(msg);
					}
				})
				.fail(function() {
					modules.get("modal").notify({
						body: locale.text("liveTile.page.add.notok"),
						severityClass: "error"
					});
				})
				.then(function() {
					modules.get("modal").notify({
						body: locale.text("liveTile.page.add.ok"),
						severityClass: "success"
					});
				})
				.then(function() {
					self._makeInvisible();
				});
		},
		_actLiveTileCreate: function() {
			var self = this;
			var tile = {
				title: self.$$panelContent.find(".s-m-livetile #description").val(),
				userLogin: _getUser()
			}
			if (self._backgroundColor) {
				tile.backgroundColor = self._backgroundColor;
			}
			var pageId = self.$$panelContent.find(".s-m-livetile #vignette").val();
			_getTileDeepLink(self._publishOptions.share.page)
				.then(function(deepLink) {
					self._publishOptions.liveTile.pages.forEach(function(page) {
						if ("" + page.id === "" + pageId) {
							tile.sDataUrl = page.pageData.$url;
							tile.id = tile.sDataUrl;
							tile.DeepLink = deepLink;
						}
					});

					var cap = native.getModule("liveTile");
					if (cap) {
						return cap.addLiveTile(tile);
					}
				})
				.fail(function() {
					modules.get("modal").notify({
						body: locale.text("liveTile.page.add.notok"),
						severityClass: "error"
					});
				})
				.then(function() {
					modules.get("modal").notify({
						body: locale.text("liveTile.page.add.ok"),
						severityClass: "success"
					});
				})
				.then(function() {
					self._makeInvisible();
				})
		}
	});

var _Field = utils.defineClass(
	function(type, item, title, panel) {
		this.$type = type;
		this.$title = title;
		this.$$item = item;
		this.panel = panel;
	}, null, {
		setFieldValueFromSelector: function(value) {
			this.$$item.attr("isoValue", value);
			this.$$item.val(this._getFormattedValue(value));
			if (this.panel.onValueChange) {
				this.panel.onValueChange();
			};
			this.destroy();
		},
		_getFormattedValue: function(value) {
			var formatter = formatApi.getFormatter(this.$type);
			return formatter.formatValue(value, false);
		},
		getValue: function() {
			return this.$$item.attr("isoValue");
		},
		getTitle: function() {
			return this.$title;
		},
		destroy: function() {;
			this.$$item = this.panel = null;
		}
	});

function _getShareDeepLink(page) {
	return sharedContext.getNavContextUrlByPage(page)
		.then(function(url) {
			var link = {
				Title: page.getPageTitle(),
				Url: url
			}
			return link;
		})
}

function _getTileDeepLink(page) {
	var link = {
		Title: page.getPageTitle(),
		Url: page.pageData.$url
	}
	return $.smResolve(link);
}

//date YYYY-MM-DD" Time: "HH:MM-:SS"
function _getDateTimeInfo(date, time) {
	if (!date) return null;
	date = date.split("-");
	if (date.length !== 3) return null;
	var res = {};
	res.year = date[0];
	res.month = date[1];
	res.day = date[2];
	time = time ? time.split(":") : [];
	if (time.length == 3) {
		res.hours = time[0];
		res.minutes = time[1];
		res.seconds = time[2];
	}
	return res;
};

function _getUser() {
	var up = modules.get("appController").App.getCurrentUserProfile();
	return up.user.login;
}
});

define('syracuse-tablet/html/js/controls/ctrlFactory',['require','exports','module','syracuse-tablet/html/js/sdata/prototype','syracuse-tablet/html/js/controls/fields/ctrlAlphanum','syracuse-tablet/html/js/controls/fields/ctrlCheckbox','syracuse-tablet/html/js/controls/fields/ctrlSwitch','syracuse-tablet/html/js/controls/fields/ctrlCombo','syracuse-tablet/html/js/controls/fields/ctrlNumeric','syracuse-tablet/html/js/controls/fields/ctrlQuantity','syracuse-tablet/html/js/controls/fields/ctrlReference','syracuse-tablet/html/js/controls/fields/ctrlDate','syracuse-tablet/html/js/controls/fields/ctrlText','syracuse-tablet/html/js/controls/fields/ctrlDocument','syracuse-tablet/html/js/controls/fields/ctrlDocument','syracuse-tablet/html/js/controls/ctrlTypeUnknown','syracuse-tablet/html/js/controls/array/ctrlArray','syracuse-tablet/html/js/controls/array/ctrlArrayChart','syracuse-tablet/html/js/controls/vignette/ctrlVignette','syracuse-tablet/html/js/controls/vignette/ctrlVignetteLink','syracuse-tablet/html/js/controls/fields/ctrlImage','syracuse-tablet/html/js/controls/fields/ctrlGaugeChart','syracuse-tablet/html/js/controls/fields/ctrlFilter','syracuse-tablet/html/js/controls/layouts/layoutStack','syracuse-tablet/html/js/controls/layouts/layoutRow','syracuse-tablet/html/js/controls/layouts/layoutCell','syracuse-tablet/html/js/controls/layouts/layoutHub','syracuse-tablet/html/js/controls/layouts/layoutHubGroup','syracuse-tablet/html/js/controls/layouts/layoutTile','syracuse-tablet/html/js/controls/panels/footer/panelFooterSdataPageTablet','syracuse-tablet/html/js/controls/panels/header/panelHeaderSdataPageTablet','syracuse-tablet/html/js/controls/panels/header/panelHeaderSdataPageSmartphone','syracuse-tablet/html/js/controls/panels/header/panelHeaderMultiselSmartphone','syracuse-tablet/html/js/controls/panels/header/panelHeaderMultiselSmartphoneRun','syracuse-tablet/html/js/controls/panels/footer/panelFooterMultiselTablet','syracuse-tablet/html/js/controls/panels/footer/panelFooterMultiselTabletRun','syracuse-tablet/html/js/controls/panels/header/panelHeaderEditHome','syracuse-tablet/html/js/controls/panels/footer/panelFooterEditHomeTablet','syracuse-tablet/html/js/controls/panels/footer/panelFooterEditHomeSmartphone','syracuse-tablet/html/js/controls/panels/aside/panelActions','syracuse-tablet/html/js/controls/panels/aside/panelGlobalSmartphone','syracuse-tablet/html/js/controls/panels/aside/panelGlobalTablet','syracuse-tablet/html/js/controls/panels/sortfilter/panelFilterSort','syracuse-tablet/html/js/controls/panels/crumbs/breadcrumbsTablet','syracuse-tablet/html/js/controls/panels/toolBars/chartDetailToolBar','syracuse-tablet/html/js/controls/panels/aside/panelShare'],function (require, exports, module) {

var Prototype = require('syracuse-tablet/html/js/sdata/prototype').Prototype;

var CtrlAlphaNumModule = require('syracuse-tablet/html/js/controls/fields/ctrlAlphanum');

var CtrlAlphaNum = CtrlAlphaNumModule.CtrlAlphaNum;
var CtrlPhone = CtrlAlphaNumModule.CtrlPhone;
var CtrlEmail = CtrlAlphaNumModule.CtrlEmail;
var CtrlUrl = CtrlAlphaNumModule.CtrlUrl;

var CtrlCheckbox = require('syracuse-tablet/html/js/controls/fields/ctrlCheckbox').CtrlCheckbox;
var CtrlSwitch = require('syracuse-tablet/html/js/controls/fields/ctrlSwitch').CtrlSwitch;
var CtrlCombo = require('syracuse-tablet/html/js/controls/fields/ctrlCombo').CtrlCombo;

var CtrlNumeric = require('syracuse-tablet/html/js/controls/fields/ctrlNumeric').CtrlNumeric;
var CtrlQuantity = require('syracuse-tablet/html/js/controls/fields/ctrlQuantity').CtrlQuantity;
var CtrlReference = require('syracuse-tablet/html/js/controls/fields/ctrlReference').CtrlReference;

var CtrlDate = require('syracuse-tablet/html/js/controls/fields/ctrlDate').CtrlDate;
var CtrlText = require('syracuse-tablet/html/js/controls/fields/ctrlText').CtrlText;

var CtrlDocument = require('syracuse-tablet/html/js/controls/fields/ctrlDocument').CtrlDocument;
var CtrlBinary = require('syracuse-tablet/html/js/controls/fields/ctrlDocument').CtrlBinary;

var CtrlTypeUnknown = require('syracuse-tablet/html/js/controls/ctrlTypeUnknown').CtrlTypeUnknown;

var CtrlArray = require('syracuse-tablet/html/js/controls/array/ctrlArray').CtrlArray;
var CtrlArrayChart = require('syracuse-tablet/html/js/controls/array/ctrlArrayChart').CtrlArrayChart;

var CtrlVignette = require('syracuse-tablet/html/js/controls/vignette/ctrlVignette').CtrlVignette;
var CtrlVignetteLink = require('syracuse-tablet/html/js/controls/vignette/ctrlVignetteLink').CtrlVignetteLink;

var CtrlImage = require('syracuse-tablet/html/js/controls/fields/ctrlImage').CtrlImage;
var CtrlGaugeChart = require('syracuse-tablet/html/js/controls/fields/ctrlGaugeChart').CtrlGaugeChart;
var CtrlFilter = require('syracuse-tablet/html/js/controls/fields/ctrlFilter').CtrlFilter;

var LayoutStack = require('syracuse-tablet/html/js/controls/layouts/layoutStack').LayoutStack;
var LayoutRow = require('syracuse-tablet/html/js/controls/layouts/layoutRow').LayoutRow;
var LayoutCell = require('syracuse-tablet/html/js/controls/layouts/layoutCell').LayoutCell;
var LayoutHub = require('syracuse-tablet/html/js/controls/layouts/layoutHub').LayoutHub;
var LayoutHubGroup = require('syracuse-tablet/html/js/controls/layouts/layoutHubGroup').LayoutHubGroup;
var LayoutTile = require('syracuse-tablet/html/js/controls/layouts/layoutTile').LayoutTile;

var PanelFooterSdataPageTablet = require('syracuse-tablet/html/js/controls/panels/footer/panelFooterSdataPageTablet').PanelFooterSdataPageTablet;

var PanelHeaderSdataPageTablet = require('syracuse-tablet/html/js/controls/panels/header/panelHeaderSdataPageTablet').PanelHeaderSdataPageTablet;
var PanelHeaderSdataPageSmartphone = require('syracuse-tablet/html/js/controls/panels/header/panelHeaderSdataPageSmartphone').PanelHeaderSdataPageSmartphone;

var PanelHeaderMultiselSmartphone = require('syracuse-tablet/html/js/controls/panels/header/panelHeaderMultiselSmartphone').PanelHeaderMultiselSmartphone;
var PanelHeaderMultiselSmartphoneRun = require('syracuse-tablet/html/js/controls/panels/header/panelHeaderMultiselSmartphoneRun').PanelHeaderMultiselSmartphoneRun;
var PanelFooterMultiselTablet = require('syracuse-tablet/html/js/controls/panels/footer/panelFooterMultiselTablet').PanelFooterMultiselTablet;
var PanelFooterMultiselTabletRun = require('syracuse-tablet/html/js/controls/panels/footer/panelFooterMultiselTabletRun').PanelFooterMultiselTabletRun;
var PanelHeaderEditHome = require('syracuse-tablet/html/js/controls/panels/header/panelHeaderEditHome').PanelHeaderEditHome;
var PanelFooterEditHomeTablet = require('syracuse-tablet/html/js/controls/panels/footer/panelFooterEditHomeTablet').PanelFooterEditHomeTablet;
var PanelFooterEditHomeSmartphone = require('syracuse-tablet/html/js/controls/panels/footer/panelFooterEditHomeSmartphone').PanelFooterEditHomeSmartphone;

var PanelActions = require('syracuse-tablet/html/js/controls/panels/aside/panelActions').PanelActions;
var PanelGlobalSmartphone = require('syracuse-tablet/html/js/controls/panels/aside/panelGlobalSmartphone').PanelGlobalSmartphone;
var PanelGlobalTablet = require('syracuse-tablet/html/js/controls/panels/aside/panelGlobalTablet').PanelGlobalTablet;
var PanelSortFilter = require('syracuse-tablet/html/js/controls/panels/sortfilter/panelFilterSort').PanelFilterSort;
var BreadcrumbsTablet = require('syracuse-tablet/html/js/controls/panels/crumbs/breadcrumbsTablet').BreadcrumbsTablet;
var ChartDetailToolBar = require('syracuse-tablet/html/js/controls/panels/toolBars/chartDetailToolBar').ChartDetailToolBar;
var PanelShare = require('syracuse-tablet/html/js/controls/panels/aside/panelShare').PanelShare;
/**
 * Single function to create controls and bind them to the given controller
 * Control selection is based on article, there are several ways
 * 
 * article can be:
 * {
 *   $bind: "CODE" // Bind to a property of controller
 * }
 * article can be:
 * {
 *   $layoutType: "stack" // Create a layout (not really a control)
 * }
 * article can be:
 * {
 *   $link: "$details" //Create a link control triggering an sdata link
 * }
 * article can be:
 * {
 *   $action: "$save" //Create a action control triggering an sdata action
 * }
 * article can be:
 * {
 *   $type: "footer" //Create a control by a type not backed up by sdata (e.g. panels or footer)
 * }
 */
exports.createControl = function(controller, article, parent, page, opts) {
	var ctrl;
	// Mandatory
	opts = $.extend(true, {}, opts);
	if (article.$bind) {
		ctrl = _createControl(controller, article, parent, opts);
	} else if (article.$layoutType) {
		ctrl = _createLayout(controller, article, parent, opts);
	} else if (article.$link) {
		ctrl = _createLink(controller, article, parent, opts);
	} else if (article.$action) {
		ctrl = _createAction(controller, article, parent, opts);
	} else if (article.$type) {
		ctrl = _createControlType(controller, article, parent, opts);
	}

	if (ctrl) {
		// Keep a reference to the page for every control so a control knows where it sits in
		ctrl.page = page || parent && parent.page;

		var $articleLocalization = article.$localization; // This will be only set if we are on the articles root level
		if (!$articleLocalization && parent) {
			$articleLocalization = parent.$articleLocalization;
		}
		if (!$articleLocalization) {
			$articleLocalization = {};
		}

		ctrl.$articleLocalization = $articleLocalization;
	}

	return ctrl;
};

/**
 * 
 * @param controller
 * @param article
 * @param parent
 * @param opts
 * @returns 
 */
function _createControl(controller, article, parent, opts) {
	var $bind = article.$bind;
	if (!controller.dataset.prototype.propExists($bind)) {
		return;
	}

	var $type = controller.dataset.prototype.propGetType($bind);
	var $format = controller.dataset.prototype.propGetFormat($bind);
	var ctor;
	var proto;
	//	console.log(controller.dataset.prototype.propGetProto($bind).getValueByPath("$title", true), controller.dataset.prototype.propGetProto($bind).json)
	switch ($type) {
		case "application/x-boolean":
			switch ($format) {
				case "$switch":
					ctor = CtrlSwitch;
					break;
				default:
					ctor = CtrlCheckbox;
					break;
			}
			break;

		case "application/x-choice":
			ctor = CtrlCombo;
			break;
		case "application/x-string":
		case "application/x-password":
			switch ($format) {
				case "$phone":
					ctor = CtrlPhone;
					break;
				case "$email":
					ctor = CtrlEmail;
					break;
				case "$url":
					ctor = CtrlUrl;
					break;
				default:
					ctor = CtrlAlphaNum;
			}
			break;
		case "application/x-reference":
			ctor = CtrlReference;
			break;

		case "application/x-integer":
		case "application/x-real":
		case "application/x-decimal":
		case "application/x-quantity":
			// "$numDisplay" is an authoring property used to select how to display numeric value (either "gauge" or "normal")
			// important in case we switch from "normal" to "gauge"
			if (!article.$gauge && article.$numDisplay === "gauge") {
				article.$gauge = {};
			}
			if (article.$gauge) {
				ctor = CtrlGaugeChart;
			} else {
				ctor = ($type === "application/x-quantity" ? CtrlQuantity : CtrlNumeric);
			}
			break;
		case "application/x-date":
		case "application/x-time":
		case "application/x-datetime":
			ctor = CtrlDate;
			break;
		case "application/x-array":
			proto = controller.dataset.prototype.propGetProto($bind);
			if (proto.getValueByPath("$cube")) {
				// We always instantiate an ArrayChart because whatever $display chart/table/card...
				// ArrayChart manages the links to detail chart and is needed if we display a "$cube" as a table/card...
				ctor = CtrlArrayChart;
			} else {
				ctor = CtrlArray;
			}
			break;
		case "application/x-vignette":
			ctor = CtrlVignette;
			break;
		case "application/x-vignette-link":
			ctor = CtrlVignetteLink;
			break;
		case "image":
			ctor = CtrlImage;
			break;
		case "text/plain":
		case "text/rtf":
		case "text/html":
			ctor = CtrlText;
			break;
		case "application/x-filter":
			ctor = CtrlFilter;
		case "application/x-document":
			ctor = CtrlDocument;
			break;
		case "application/x-binary":
			ctor = CtrlBinary;
			break;
		default:
			ctor = CtrlTypeUnknown;
			break;
	}
	if (ctor) {
		proto = proto || controller.dataset.prototype.propGetProto($bind);
	}

	var ctrl;
	if (ctor && proto) {
		ctrl = new ctor(controller, article, proto, opts || {});
	}

	if (ctrl && parent) {
		parent.appendStructElmt(ctrl);
	}
	return ctrl;
}

/**
 * 
 * @param controller
 * @param article
 * @param parent
 * @param opts
 * @returns
 */
function _createLayout(controller, article, parent, opts) {
	var $type = article.$layoutType;
	var ctrl;
	var ctor;
	// compatibility stateless version hubGroup
	switch ($type.toLowerCase()) {
		case "stack":
			ctor = LayoutStack;
			break;
		case "row":
			ctor = LayoutRow;
			break;
		case "cell":
			ctor = LayoutCell;
			break;
		case "hub":
			ctor = LayoutHub;
			break;
		case "hubgroup":
			ctor = LayoutHubGroup;
			break;
		case "tile":
			ctor = LayoutTile;
			break;
		default:
			throw new Error("Unknown layout type [" + $type + "]")
			ctor = null;
			break;
	}

	if (ctor) {
		ctrl = new ctor(controller, $type, article, opts || {});
	}

	if (ctrl && parent) {
		parent.appendStructElmt(ctrl);
	}

	return ctrl;
}

/**
 * 
 * @param controller
 * @param article
 * @param parent
 * @param opts
 */
function _createLink(controller, article, parent, opts) {}

/**
 * 
 * @param controller
 * @param article
 * @param parent
 * @param opts
 */
function _createAction(controller, article, parent, opts) {}

/**
 * 
 * @param controller
 * @param article
 * @param parent
 * @param opts
 */
function _createControlType(controller, article, parent, opts) {
	var $type = article.$type;
	var ctor;
	var ctrl;
	switch ($type) {
		case "application/x-panel-footer-sdata-page":
			ctor = PanelFooterSdataPageTablet;
			break;

		case "application/x-panel-header-sdata-page-tablet":
			ctor = PanelHeaderSdataPageTablet;
			break;
		case "application/x-panel-header-sdata-page-smartphone":
			ctor = PanelHeaderSdataPageSmartphone;
			break;
		case "application/x-panel-header-multisel-smartphone":
			ctor = PanelHeaderMultiselSmartphone;
			break;
		case "application/x-panel-header-multisel-run-smartphone":
			ctor = PanelHeaderMultiselSmartphoneRun;
			break;
		case "application/x-panel-footer-multisel-tablet":
			ctor = PanelFooterMultiselTablet;
			break;
		case "application/x-panel-footer-multisel-run-tablet":
			ctor = PanelFooterMultiselTabletRun;
			break;
		case "application/x-panel-actions":
			ctor = PanelActions;
			break;
		case "application/x-panel-global-smartphone":
			ctor = PanelGlobalSmartphone;
			break;
		case "application/x-panel-global-tablet":
			ctor = PanelGlobalTablet;
			break;
		case "application/x-panel-breadcrumbs-tablet":
			ctor = BreadcrumbsTablet;
			break;
		case "application/x-panel-filtersort":
			ctor = PanelSortFilter;
			break;
		case "application/x-chartdetail-toolbar":
			ctor = ChartDetailToolBar;
			break;
		case "application/x-panel-share":
			ctor = PanelShare;
			break;
		case "application/x-panel-footer-edithome-tablet":
			ctor = PanelFooterEditHomeTablet;
			break;
		case "application/x-panel-footer-edithome-smartphone":
			ctor = PanelFooterEditHomeSmartphone;
			break;
		case "application/x-panel-header-edithome":
			ctor = PanelHeaderEditHome;
			break;
	}

	if (ctor) {
		ctrl = new ctor(controller, $type, article, opts);
	}
	return ctrl;
}
});

define('syracuse-tablet/html/js/sdata/wpHelpers',['require','exports','module','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/sdata/protocolHelpers','syracuse-tablet/html/js/sdata/sdataStatic','syracuse-tablet/html/js/common/ajax','syracuse-tablet/html/js/sdata/cache/metaDataCache','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/controls/vignette/gadget','syracuse-tablet/html/js/sdata/dataset','syracuse-tablet/html/js/sdata/prototype','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var modules = require('syracuse-tablet/html/js/common/modules');
var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');
var sdataStatic = require('syracuse-tablet/html/js/sdata/sdataStatic');
var ajax = require('syracuse-tablet/html/js/common/ajax');
var metaDataCache = require('syracuse-tablet/html/js/sdata/cache/metaDataCache');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var gadget = require('syracuse-tablet/html/js/controls/vignette/gadget');

var Dataset = require('syracuse-tablet/html/js/sdata/dataset').Dataset;
var Prototype = require('syracuse-tablet/html/js/sdata/prototype').Prototype;

var locale = require('syracuse-tablet/html/js/helpers/locale');
/**
 * Gets current user and role and reads/constructs welcome page pageData
 */
exports.fetchWelcomePageData = function(uuid) {
		var up = modules.get("appController").App.getCurrentUserProfile();
		var opts = {
			user: up.user.$uuid,
			userRole: up.selectedRole.$uuid,
			uuid: uuid,
			isPersonal: (!uuid)
		}
		return _fetchWelcomePageData(opts);
	}
	/**
	 * 
	 */
function _fetchWelcomePageData(opts) {
	var prototypeJson;
	var datasetJson;
	var $resources;
	var $url = _getHomeDashboardUrl(opts);
	var noAutoSave = false;
	var meta;
	prototypeJson = sdataStatic.getMobileDashboardProto();
	var fetchDashboard = $.Deferred();
	ajax.request($url, "GET")
		//  Fake offline for tests
		//	.then(function(result) {
		//		return $.smReject({
		//			offline: true
		//		});
		//	})
		.then(function(result) {
			fetchDashboard.resolve(result.data.dashboard);
		})
		.fail(function(result) {
			// When we are not up to date with the server, we do not auto save a personal dashboard later in the process
			noAutoSave = true;

			if (opts.isPersonal && result.offline) {
				_readWelcomeDashboardClient(opts.user, opts.userRole)
					.then(function(result) {
						fetchDashboard.resolve(result);
					})
					.fail(function() {
						fetchDashboard.resolve(null);
					});
			} else {
				fetchDashboard.reject(result);
			}
		});

	return fetchDashboard.then(function(dashboard) {
			$resources = dashboard || {};
			return _getDefaultDataHome($resources.content, opts.isPersonal)
		})
		.then(function(datasetJson) {
			return _appendTestHomeDataset(datasetJson)
		})
		.then(function(dataset) {
			datasetJson = dataset
			return _getHomePage($resources, datasetJson);
		})
		.then(function(page) {
			meta = page.meta || {};
			meta.uuid = opts.uuid;
			// Special for welcome page since here not all information is yet availabe and also not needed
			datasetJson.$clientContext = {
				// $mobileProtocol: $mobileProtocol, Does not matter, protocol is selected by welcome page
				$mobileEndpoint: _getEndpoint(),
				// $mobileApplication: $mobileApplication, Does not matter, application is not yet selected 
			};
			return protoHelpers.checkTransform($url, prototypeJson, datasetJson, page);
		})
		.then(function(pageDataTransformed) {
			var pageData = {};
			pageData.prototype = new Prototype(pageDataTransformed.prototypeJson);
			pageData.dataset = new Dataset(pageDataTransformed.datasetJson, pageData.prototype);
			pageData.isWorkingCopy = false;
			pageData.$url = $url;
			pageData.$originalUrl = $url; // Will be overriden by pageFactory to contain original url before applying filter/sort
			pageData.page = pageDataTransformed.page;
			pageData.meta = meta;
			pageData.isPersonal = opts.isPersonal;

			if (!$resources.content || !_havePersonalDashboard($resources.$views)) { // Did we create a new default one
				if (noAutoSave !== true && opts.isPersonal) {
					var data = exports.createWelcomeDashboardFromPageData(pageData, true);
					exports.saveWelcomeDashboard(data);
				}
			}
			return pageData;
		})
}

function _havePersonalDashboard(availableViews) {
	var views = availableViews || []
	return views.some(function(view) {
		return view.$isPersonal;
	})
}

function _appendTestHomeDataset(dataset) {
	//Only in dev mode
	if (!jsutils.isDvlpVersion()) {
		return $.smResolve(dataset)
	}
	var gadget = {
		$uuid: "$MOCK_mobileDashboard_Gadget",
		$title: "Test applications",
		$url: "{$hostPort}/mobile2/$client/$local/$dataset/mobileDashboard('MOCK')",
		$method: "GET",
		$type: "$application"
	};
	dataset.$mobileGadgets[gadget.$uuid] = gadget;
	dataset.vignettes.push({
		local: true,
		gadget: {
			$uuid: gadget.$uuid
		},
		$uuid: "$MOCK_mobileDashboard_Vignette",
		persistentId: "$MOCK_mobileDashboard_Vignette"
	});
	return $.smResolve(dataset);
}

function _getDefaultDataHome(content, isPersonal) {
	return metaDataCache.getApplicationsList()
		.then(function(appList) {
			if (isPersonal) { // On personal welcome page, only show valid apps, for templates, we do not filter
				appList = exports.filterApps(appList);
			}
			//Get a compatible datasetjson or build a dataset json from applist
			return _checkHomeDataset(appList, content);
		});
}
exports.filterApps = function(appList) {
	var up = modules.get("appController").App.getCurrentUserProfile();
	var validApps = [];
	var curEp = up.selectedEndpoint.code;
	var curRole = up.selectedRole.code;

	appList.forEach(function(app) {
		var valid = app.endpoints.length === 0 || app.endpoints.some(function(ep) {
			return [ep.application, ep.contract, ep.dataset].join(".") === curEp;
		});
		valid = valid && (app.roles.length === 0 || app.roles.some(function(role) {
			return role.code === curRole;
		}));
		if (valid) {
			validApps.push(app);
		}
	});

	return validApps;
}

function _getHomePage($resources, datasetJson) {
	var article = $resources.content ? $resources.content.$article : null;
	// home article from dashboard content (extended with local test) or build a default
	return {
		$article: _homeArticle(article, datasetJson),
		$views: $resources.$views,
		$roles: $resources.roles || [],
		meta: {
			"description": $resources.description || locale.text("welcome.mydashboard")
		}
	}
}

function _homeArticle($article, datasetJson) {
	if (!$article) {
		return _defaultHomeArticle(datasetJson);
	}

	// Append test vignettes
	var $items = [];
	datasetJson.vignettes.forEach(function(v) {
		if (v.local) {
			$items.push({
				"$layoutType": "tile",
				"$title": "",
				"$size": "medium",
				"$items": [{
					"$bind": v.persistentId
				}]
			})
		}
	});
	if ($items.length > 0) {
		$article.$items.unshift({
			"local": true,
			"$layoutType": "hubgroup",
			"$title": "Test applications",
			"$items": $items
		})
	}
	return $article;
}

function _defaultHomeArticle(datasetJson) {
	var article = {
		"$layoutType": "hub",
		"$items": [{
			"local": true,
			"$layoutType": "hubgroup",
			"$title": "Test applications",
			"$items": []
		}, {
			"$layoutType": "hubgroup",
			"$title": "All available applications",
			"$items": []
		}]
	};

	// Add client side test gadgets if there are some in the dataset
	var i;
	datasetJson.vignettes.forEach(function(v) {
		i = v.local ? 0 : 1
		article.$items[i].$items.push({
			"$layoutType": "tile",
			"$size": "medium",
			"$items": [{
				"$bind": v.persistentId
			}]
		})
	})
	if (article.$items[0].$items.length === 0) {
		article.$items.shift();
	}
	return article;
}

function _checkHomeDataset(appList, dashboardContent) {
	var dataset = _ensureHomeDatasetCompatibility(dashboardContent, appList);
	if (dataset) {
		return dataset;
	}
	var datasetJson = {
		vignettes: [],
		$mobileGadgets: {}
	};
	var endpoint = modules.get("appController").App.getCurrentEndpoint();
	appList.forEach(function(app) {
		var vignette = {
			"persistentId": app.$uuid,
			"gadget": {
				"$uuid": app.$uuid,
			}
		};
		datasetJson.vignettes.push(vignette);
		datasetJson.$mobileGadgets[app.$uuid] = {
			"$type": "$application",
			"$title": app.title,
			"icon": app.iconName,
			"applicationName": app.applicationName,
		};
	});
	return datasetJson;
}

function _ensureHomeDatasetCompatibility(datasetJson, appList) { // datasetJson could be null, content V11 or content V12(woco)
	var appName;
	var compatibleDatasetJson = {
		$mobileGadgets: {},
		vignettes: []
	};
	if (!datasetJson) return null;
	var appTitleList = _getAppListTitle(appList);
	if (datasetJson.$mobileGadgets) {
		datasetJson.vignettes.forEach(function(vi) {
			if (_isVignetteAvailable(datasetJson.$mobileGadgets[vi.gadget.$uuid], appList)) {
				compatibleDatasetJson.vignettes.push(vi);
				compatibleDatasetJson.$mobileGadgets[vi.gadget.$uuid] = datasetJson.$mobileGadgets[vi.gadget.$uuid];
				appName = compatibleDatasetJson.$mobileGadgets[vi.gadget.$uuid].applicationName;
				compatibleDatasetJson.$mobileGadgets[vi.gadget.$uuid].$title = appTitleList[appName] ? appTitleList[appName].$title : compatibleDatasetJson.$mobileGadgets[vi.gadget.$uuid].$title
			}
		})
		return compatibleDatasetJson;
	}
	var endpoint = modules.get("appController").App.getCurrentEndpoint();
	Object.keys(datasetJson.$vignettes).forEach(function(key) {
		if (_isVignetteAvailable(datasetJson.$gadgets[key], appList)) {
			compatibleDatasetJson.vignettes.push({
				"persistentId": key,
				"gadget": {
					"$uuid": key
				}
			});
			compatibleDatasetJson.$mobileGadgets[key] = datasetJson.$gadgets[key];
			appName = compatibleDatasetJson.$mobileGadgets[key].applicationName;
			compatibleDatasetJson.$mobileGadgets[key].$title = appTitleList[appName] ? appTitleList[appName].$title : compatibleDatasetJson.$mobileGadgets[key].$title
		}
	})
	return compatibleDatasetJson;
}

function _getAppListTitle(appList) {
	var appListTitle = {};
	appList.forEach(function(app) {
		appListTitle[app.applicationName] = {
			"$title": app.title,
			"$description": app.description
		}
	})
	return appListTitle;
}

function _isVignetteAvailable(gadget, appList) {
	//check if application exist
	var appMap = {};
	appList.forEach(function(app) {
		appMap[app.applicationName] = app
	})
	return (gadget.$type !== "$application" || (gadget.$type === "$application" && appMap[gadget.applicationName]))
}

/**
 * Compute full payload for saving a welcome dashboard
 * Json will differ depending on if it's a template or a personal dashboard
 */
function _computeWelcomePageData(content, isPersonal, roles, meta) {
	var data = {
		"description": meta.description || locale.text("welcome.mydashboard"),
		"clientId": "",
		"content": content,
		"isPersonal": isPersonal,
		"uuid": meta.uuid
	};

	if (isPersonal) {
		var up = modules.get("appController").App.getCurrentUserProfile();
		data.user = {
			"$uuid": up.user.$uuid
		};
		data.role = {
			"$uuid": up.selectedRole.$uuid
		};
	} else if (roles) {
		data.roles = roles;
	} else {
		// Should not happen
	}
	return data;
}

/**
 * Compute content json of welcome page defined by page data.
 * returned json has same structure, no matter if template or personal dashboard
 */
function _computeWelcomePageContent(pageData) {
	var $gadgets = {},
		$article = {},
		vignettes = [];
	pageData.dataset.json.$vignettes.forEach(function(vi) {
		if (!vi.local) {
			vignettes.push(vi);
			$gadgets[vi.gadget.$uuid] = pageData.dataset.json.$mobileGadgets[vi.gadget.$uuid];
		}
	});
	$article.$layoutType = pageData.page.$article.$layoutType,
		$article.$items = [];
	pageData.page.$article.$items.forEach(function(item) {
		if (!item.local) {
			$article.$items.push(item)
		}
	});
	$article.$localization = pageData.page.$article.$localization;
	var content = {
		"$dashboardName": "$welcomeDashboard",
		"$title": "Home",
		"$article": $article,
		"vignettes": vignettes,
		"$mobileGadgets": $gadgets,
	}
	return content;
}

exports.welcomePageToCommands = function(data) {
	var vignettes = [];

	// Find all gadgets shown on page
	function _walk(article) {
		if (article.$bind) {
			var vignette = data.prototype.json.$properties[article.$bind];
			if (vignette && vignette.$type === "application/x-vignette-link") {
				vignettes.push(vignette);
			}
		}
		if (article.$items) {
			article.$items.forEach(_walk);
		}
	}
	_walk(data.page.$article);

	var commands = [];
	vignettes.forEach(function(vignette) {
		var g = gadget.createGadget(new Prototype(vignette));
		if (g) {
			var title = g.data("$title");
			var link = g.getLink();
			if (link && title) {
				commands.push({
					title: title,
					page: link
				});
			}
		}
	});
	return commands;
	/* commands is like:
	[{
		title: "Kunden",
		page: {
			"$url": "{$hostPort}/mobile2/$client/$local/$dataset/mobileDashboard('MY_CUSTOMERS')",
			"$method": "GET"

		}
	}, ...];
	*/
}

function _getEndpoint() {
	return modules.get("appController").App.getDefaultEndpoint();
}

function _getHomeDashboardUrl(opts) {
	var url = "/mobile2/syracuse/collaboration/syracuse/welcomeDashboards/$service/availableDashboard?representation=mobileDashboard.$details";
	url += opts.user ? "&user=" + opts.user : "";
	url += opts.userRole ? "&role=" + opts.userRole : "";
	url += (opts.uuid ? "&uuid=" + opts.uuid : "");
	return protoHelpers.getHostPort() + url;
}

/**
 * Uses pageData of the client side rendered Welcome dashboard to construct the json data
 * that will be saved on the server
 * 
 * Usually used before saveWelcomeDashboard
 */
exports.createWelcomeDashboardFromPageData = function(pageData, isPersonal) {
	var content = _computeWelcomePageContent(pageData);
	var data = _computeWelcomePageData(content, isPersonal, pageData.page.$roles, pageData.meta);
	return data;
}

/**
 * 
 * Save a welcome dashboard on server and client (if it's isPersonal = true)
 * 
 * "data" can be constructed using createWelcomeDashboardFromPageData
 * 
 * data: {
 *   content: {
 *     $article: ...
 *     $mobileGadgets: ...
 *     $dashboardName: ...
 *     $vignettes: ...
 *   },
 *   $dashboardName: ...
 *   description: ...
 *   isPersonal: ...
 *   role: {
 *     $uuid: ...
 *   },
 *   user: {
 *     $uuid: ...
 *   }   
 * }
 */
exports.saveWelcomeDashboard = function(data) {
	return _saveWelcomeDashboardClient(data)
		.then(function() {
			return _saveWelcomeDashboardServer(data).then(function(data) {
				return data;
			});
		});
}

function _saveWelcomeDashboardClient(data) {
	if (!data.isPersonal) {
		return $.smResolve();
	}

	var ctx = {
		"$user": data.user.$uuid,
		"$role": data.role.$uuid,
		"$lang": "none"
	};
	return modules.get("storage").getStorage().put({
		$context: ctx,
		$collection: "$welcomeDashboard",
		$endpoint: "$local",
		$key: ctx.$user + "_" + ctx.$role,
		$data: data
	});
}
exports.isPagePinned = function(pageId) {
	var self = this;
	return _getWelcomeDashboarClient()
		.then(function(data) {
			return data.content.$mobileGadget && data.content.$mobileGadget[pageId]
		})
}

function _getWelcomeDashboarClient() {
	var up = modules.get("appController").App.getCurrentUserProfile();
	return _readWelcomeDashboardClient(up.user.$uuid, up.selectedRole.$uuid).then(function(data) {
		return data
	});
}

function _readWelcomeDashboardClient($userUuid, $roleUuid) {
	var ctx = {
		"$user": $userUuid,
		"$role": $roleUuid,
		"$lang": "none"
	};
	return modules.get("storage").getStorage().read({
			$context: ctx,
			$collection: "$welcomeDashboard",
			$endpoint: "$local",
			$key: ctx.$user + "_" + ctx.$role
		})
		.then(function(result) {
			if (result.$status === 1) { // OK
				return result.$data;
			} else {
				return null;
			}
		});
}
exports.getListOfRoles = function() {
	return ajax.request("/sdata/syracuse/collaboration/syracuse/welcomeDashboards/$service/listOfRoles")
		.then(function(result) {
			return (result.data && result.data.$resources) ? result.data && result.data.$resources : []
		})
}

function _saveWelcomeDashboardServer(data) {
	return ajax.request("/sdata/syracuse/collaboration/syracuse/welcomeDashboards/$service/updateDashboard", "POST", data)
		.then(function(result) {
			return result.data
		})
}
});

define('syracuse-tablet/html/js/pages/sdata/actionAdapterPageSdata',['require','exports','module','syracuse-tablet/html/js/pages/actionAdapter','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/siteLayout','syracuse-tablet/html/js/helpers/environment'],function (require, exports, module) {

var ActionAdapter = require('syracuse-tablet/html/js/pages/actionAdapter').ActionAdapter;
var locale = require('syracuse-tablet/html/js/helpers/locale');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var siteLayout = require('syracuse-tablet/html/js/ui/siteLayout');
var environment = require('syracuse-tablet/html/js/helpers/environment');

/**
 * Action that can be added multiple time (panel, footer...)
 */
var _skipExlude = ["multiSelToggle", "multiSelTriggerAction"];
/**
 * 
 */
exports.ActionAdapterPageSdata = utils.defineClass(
	function ActionAdapterPageSdata(sdataPage) {
		ActionAdapter.call(this, sdataPage);
		this.sdataPage = sdataPage;

		// Used to cache items
		this._items = {
			header: null,
			footer: null,
			globalPanel: null,
			actionsPanel: null,
			multiSelection: null,
			multiSelectionRun: null,
			multiSelectionReserved: null
		};

		// Some pages (like row detail will set these to true)
		this.showAccept = false;
		this.showCancel = false;
		this.showDesignPage = false;
		this.showPageShare = false;
		this.showPinPage = false;
		this.showHome = false;
		this.showPageConfig = false;
		this.showMyTemplates = false;
		this.showMyDashboard = false;

		this._initMultiSelItems();
	},
	ActionAdapter, {
		destroy: function() {
			this.sdataPage = null;
		},

		/**
		 * Multi-selection is enabled by authoring
		 * These actions are hidden (excluded) in header/footer/actionPAnel
		 * They are displayed only when Multi-selection mode is enabled
		 */
		_initMultiSelItems: function() {
			this._items.multiSelection = [];
			var actions = this.sdataPage.getAuthoring("$pageActionSettings");
			if (!actions) {
				return;
			}
			var self = this;
			var items = this._items.multiSelection;
			var dataset = this.sdataPage.controller.dataset;
			actions.forEach(function(act) {
				if (act.options && act.options.multiselection !== true) {
					return;
				}
				var link = dataset.getLink(act.name);
				if (!link) {
					return;
				}
				// Action called at page level - multiSelectionController is not available at this stage
				self._addNonSdataActionItem(items, "multiSelTriggerAction", act.name, dataset.resolveExpression(link.$title), null, act)
			})
			if ((items && items.length > 0) || this.sdataPage.isDownloadEnabled()) {
				// Multi-selection action
				this._addMultiSelectionToggle(items, "right");
				// Actions Drop-down-list item - Specific html
				items.unshift({
					"action": "multiSelActions"
				});
				// For the panel displayed when actions are being executed
				this._items.multiSelectionRun = [];
				this._addNonSdataActionItem(this._items.multiSelectionRun, "multiSelTriggerAction", "stop", null, null, {
					icon: "multiSelectionRunStop"
				});
				this._addNonSdataActionItem(this._items.multiSelectionRun, "multiSelTriggerAction", "exit", null, null, {
					icon: "multiSelectionRunExit"
				});
			}
		},

		/* To force re-evaluation of items to be rendered.
		 * Used when refreshing page during authoring
		 */
		clearCachedItems: function() {
			this._items.header = null;
			this._items.footer = null;
			this._items.globalPanel = null;
			this._items.actionsPanel = null;
			this._items.multiSelectionReserved = null;
		},
		/**
		 * Returns items to be shown in the header
		 */
		getHeaderItems: function() {
			return this.getItems("header");
		},

		/**
		 * Returns items to be shown in the footer panel
		 */
		getFooterItems: function() {
			return this.getItems("footer");
		},
		/**
		 * Returns items to be shown in the footer panel
		 * panelControllerId is the id of MultiSelectionPanelController that handles drop-down list multiSelActions
		 * - except Download action which is handled by the sdataQueryPage
		 */
		getMultiSelectionItems: function(panelControllerId) {
			var items = this.getItems("multiSelection");
			if (panelControllerId) {
				items.forEach(function(item) {
					if (item.action === "multiSelActions") {
						// MultiSelectionPanelController
						item["controller-id"] = panelControllerId;
					} // Else action processed by the sdata query page
				})
			}
			return items;
		},
		getMultiSelectionRunItems: function() {
			return this.getItems("multiSelectionRun");
		},
		/**
		 * 
		 */
		getGlobalPanelItems: function() {
			return this.getItems("globalPanel");
		},

		/**
		 * Returns items to be shown in the header
		 */
		getActionsPanelItems: function() {
			return this.getItems("actionsPanel");
		},

		_hasItems: function(panelName) {
			var items = this.getItems(panelName);
			return (items && items.length > 0) || false;
		},
		getItems: function(panelName) {
			var items = this._items[panelName];
			if (!items) {
				var func = "_compute" + panelName.smCapitalize() + "Items";
				items = this[func].call(this);
				this._items[panelName] = items;
			}
			return items;
		},

		/**
		 * Add other action in header/footer (enabled by authoring)
		 * slot: position of icon in header/footer
		 */
		_addFooterHeaderActions: function(items, slot) {
			var actions = this.sdataPage.pageData.page.$article.$pageActionSettings;
			if (!actions) {
				return;
			}
			var controller = this.sdataPage.controller;
			var knownActions = controller.dataset.getActions() || {};
			var knownLinks = controller.dataset.getLinks() || {};

			var self = this;
			actions.forEach(function(act) {
				if (act.options && act.options.footerHeader === true && act.options.multiselection !== true) {
					if (knownLinks[act.name]) {
						self._addSdataLinkItem(items, act.name, controller, $.extend(true, {
							slot: slot
						}, act));
					} else if (knownActions[act.name]) {
						self._addSdataActionItem(items, act.name, controller, $.extend(true, {
							slot: slot
						}, act));
					}
				}
			})
			if (this._items.multiSelection.length > 0) {
				this._addMultiSelectionToggle(items, slot);
			}
		},

		_computeHeaderItems: function() {
			var items = [];
			if (siteLayout.getDeviceType() !== "smartphone") {
				return;
			}
			var controller = this.sdataPage.controller;
			var facet = controller.getFacet();
			switch (facet) {
				case "$query":
					this._addSdataLinkItem(items, "$create", controller, {});
					this._addFooterHeaderActions(items);
					break;

				case "$details":
					this._addSdataLinkItem(items, "$edit", controller, {});
					this._addSdataLinkItem(items, "$delete", controller, {});
					this._addFooterHeaderActions(items);
					break;

				case "$edit":
				case "$create":
					this._addSdataActionItem(items, "$save", controller, {
						slot: "right"
					});
					this._addFooterHeaderActions(items);
					break;
			}
			if (this.showAccept) {
				this._addAcceptButton(items, controller, {
					slot: "right"
				});
			}
			if (this.showCancel) {
				this._addCancelButton(items, controller, {
					slot: "right"
				});
			}
			if (this._hasItems("actionsPanel")) {
				this._addOpenActionsPanel(items, controller, {
					slot: "right"
				});
			}
			return items;
		},
		_computeFooterItems: function() {
			var items = [];
			if (siteLayout.getDeviceType() === "smartphone") {
				// Usually, there is no footer on the smartphone so it's not a good idea to return items
				items = [];
			} else {
				var controller = this.sdataPage.controller;
				if (this.showPageConfig) {
					this._addPageConfigButton(items, controller, {
						slot: "left"
					});
				}
				if (this.showMyTemplates) {
					this._addMyTemplatesButton(items, controller, {
						slot: "left"
					});
				}
				if (this.showMyDashboard) {
					this._addMyDashboardButton(items, controller, {
						slot: "left"
					});
				}
				if (this.showHome) {
					this._addHomeButton(items, controller, {
						slot: "left"
					});
				}
				if (this.showPinPage) {
					this._addPinButton(items, this.page.getPinActionState(), controller, {
						slot: "left"
					});
				}

				var facet = controller.getFacet();
				switch (facet) {
					case "$query":
						this._addSdataLinkItem(items, "$create", controller, {
							slot: "right"
						});
						this._addFooterHeaderActions(items, "right");
						break;

					case "$details":
						this._addSdataLinkItem(items, "$edit", controller, {
							slot: "right"
						});
						this._addSdataLinkItem(items, "$delete", controller, {
							slot: "right"
						});
						this._addSdataLinkItem(items, "$query", controller, {
							slot: "right"
						});
						this._addFooterHeaderActions(items, "right");
						break;

					case "$edit":
					case "$create":
						this._addSdataActionItem(items, "$save", controller, {
							slot: "right"
						});
						this._addFooterHeaderActions(items, "right");
						break;
				}

				if (this.showAccept) {
					this._addAcceptButton(items, controller, {
						slot: "right"
					});
				}
				if (this.showCancel) {
					this._addCancelButton(items, controller, {
						slot: "right"
					});
				}

				if (this._hasItems("actionsPanel")) {
					this._addOpenActionsPanel(items, controller, {
						slot: "right"
					});
				}
			}
			return items;
		},
		_computeGlobalPanelItems: function() {
			var items = [];
			var controller = this.sdataPage.controller;
			if (siteLayout.getDeviceType() === "smartphone") {
				if (this.showPageConfig) {
					this._addPageConfigButton(items, controller, {
						slot: "left"
					});
				}
				if (this.showMyTemplates) {
					this._addMyTemplatesButton(items, controller, {
						slot: "left"
					});
				}
				if (this.showMyDashboard) {
					this._addMyDashboardButton(items, controller, {
						slot: "left"
					});
				}
				if (this.showHome) {
					this._addHomeButton(items, controller, {
						slot: "left"
					});
				}
				if (this.showPinPage) {
					this._addPinButton(items, "pin", controller, {
						slot: "left"
					});
				}
				this._addSwitchContextButton(items, controller);
				this._addSettingsButton(items, controller);
				this._addAboutButton(items, controller);
				this._addLogoutButton(items, controller);
				this._addDevButton(items, controller);
				if (this.showDesignPage === true && environment.isDesktop() && !environment.isNativeWrapper()) {
					this._addDesignPageButton(items, controller);
				}
				this._addDraftsButton(items, 123, controller);
				if (this.showPageShare) {
					this._addShareButton(items, controller);
				}
			} else {
				if (this.showDesignPage === true && environment.isDesktop() && !environment.isNativeWrapper()) {
					this._addDesignPageButton(items, controller);
				}
				if (this.showPageShare) {
					this._addShareButton(items, controller);
				}
				this._addSwitchContextButton(items, controller);
				this._addSettingsButton(items, controller);
				this._addAboutButton(items, controller);
				this._addDevButton(items, controller);
				this._addDraftsButton(items, 0, controller);
				this._addLogoutButton(items, controller);
			}

			return items;
		},
		_computeActionsPanelItems: function() {
			var items = [];
			var controller = this.sdataPage.controller;

			var $links = controller.dataset.getLinks();
			for (var $linkName in $links) {
				if (!$linkName.smStartsWith("$")) {
					this._addSdataLinkItem(items, $linkName, controller, {
						slot: "links"
					});
				}
			}
			var $actions = controller.dataset.getActions();
			for (var $actionName in $actions) {
				if (!$actionName.smStartsWith("$")) {
					this._addSdataActionItem(items, $actionName, controller, {
						slot: "actions"
					});
				}
			}
			return items;
		},

		/**
		 * Add sdata link item if link is known in prototype
		 * 
		 * {
		 *   "name":		  // Unique name
		 * 	 "controller-id":
		 *   "sdata-$link":   // Sdata link ($edit)
		 *   "icon":		  // Optional, rendering control should use prototype and a default if possible
		 *   "title":		  // Optional, rendering control should use prototype
		 *   "$bind":		  // Optional: Property the link belongs too (for field level links)
		 * }
		 */
		_addSdataLinkItem: function(items, $linkName, controller, overrides) {
			if (this._isMultiSelectionReserved($linkName)) {
				return;
			}
			var dataset = controller.dataset;
			var link = dataset.getLink($linkName);
			if (!link) {
				return;
			}
			var item = {
				"name": $linkName,
				"controller-id": controller.id,
				"$link": $linkName,
				"icon": $linkName,
				"title": dataset.resolveExpression(link.$title)
			}
			this._pushItem(items, item, overrides);
		},
		/**
		 * Button that toggles the multi-selection mode
		 */
		_addMultiSelectionToggle: function(items, slot) {
			this._addNonSdataActionItem(items, "multiSelToggle", null, locale.text("action.multiselect"), null, {
				icon: "multiSelection",
				slot: slot || "right"
			})
		},
		/**
		 * Non sData action (handled by _act or onDataActionClicked at ctrl/controller/page level)
		 */
		_addNonSdataActionItem: function(items, $actionName, params, title, controller, overrides) {
			if (_skipExlude.indexOf($actionName) < 0 && this._isMultiSelectionReserved($actionName)) {
				return;
			}
			title = title || "";
			var item = {
				"name": $actionName,
				"controller-id": controller && controller.id,
				"action": $actionName,
				"icon": $actionName,
				"title": title,
				"params": params
			}
			this._pushItem(items, item, overrides);
		},

		/**
		 * Add sdata action item if action is known in prototype
		 * 
		 * {
		 *   "name":		  // Unique name
		 * 	 "controller-id":
		 *   "sdata-$link":   // Sdata link ($edit)
		 *   "icon":		  // Optional, rendering control should use prototype and a default if possible
		 *   "title":		  // Optional, rendering control should use prototype
		 * }
		 */
		_addSdataActionItem: function(items, $actionName, controller, overrides) {
			if (_skipExlude.indexOf($actionName) < 0 && this._isMultiSelectionReserved($actionName)) {
				return;
			}
			var dataset = controller.dataset;
			var action = dataset.getAction($actionName);
			if (!action) {
				return;
			}
			var item = {
				"name": $actionName,
				"controller-id": controller.id,
				"$sdataAction": $actionName,
				"icon": $actionName,
				"title": dataset.resolveExpression(action.$title || "")
			}
			this._pushItem(items, item, overrides);
		},
		_pushItem: function(items, item, overrides) {
			if (overrides) {
				item = $.extend(true, {}, item, overrides);
			}
			items.push(item);
			if (!this._items.multiSelectionReserved) {
				this._items.multiSelectionReserved = [];
			}
			this._items.multiSelectionReserved.push(item.name);
		},
		_isMultiSelectionReserved: function(name) {
			return this._items.multiSelectionReserved != null && this._items.multiSelectionReserved.indexOf(name) >= 0;
		}
	});
});

define('syracuse-tablet/html/js/pages/sdata/pageSdata',['require','exports','module','syracuse-tablet/html/js/pages/pageBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/common/helpers','syracuse-tablet/html/js/controllers/sdataController','syracuse-tablet/html/js/controls/articleParser','syracuse-tablet/html/js/pages/sdata/actionAdapterPageSdata','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/sdata/sdataRequester','syracuse-tablet/html/js/utils/waiting','syracuse-tablet/html/js/app/settings','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/sdata/protocolHelpers','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/native/native'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/pages/pageBase').Page;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var helpers = require('syracuse-tablet/html/js/common/helpers');

var SdataController = require("syracuse-tablet/html/js/controllers/sdataController").SdataController;
var articleParser = require("syracuse-tablet/html/js/controls/articleParser");
var ActionAdapterPageSdata = require('syracuse-tablet/html/js/pages/sdata/actionAdapterPageSdata').ActionAdapterPageSdata;

var modules = require('syracuse-tablet/html/js/common/modules');
var sdataReq = require("syracuse-tablet/html/js/sdata/sdataRequester");
var waiting = require('syracuse-tablet/html/js/utils/waiting');
var settings = require('syracuse-tablet/html/js/app/settings');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var native = require('syracuse-tablet/html/js/helpers/native/native');

/**
 * Page handling something backed-up by sdata
 * 
 * A page should
 * - Create UI controls needed for rendering, can be device specific like header/footer
 * - Create it's controller 
 */
exports.Page = utils.defineClass(
	function PageSdata(pageData, options) {
		this.pageData = pageData;
		var isDetails = this.pageData.prototype.getFacet() === "$details"
		options = options || {};
		Base.call(this, pageData.name, options);

		this.actionAdapter = new ActionAdapterPageSdata(this);
		this.actionAdapter.showDesignPage = this.allowAuthoring();
		this.actionAdapter.showPageShare = this._checkSharePanelActive();
		if (options.isChild !== true) {
			this.actionAdapter.showPinPage = true;
		}
		this.actionAdapter.showHome = true;
		this._publishOptions = null;
	},
	Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.pageData = null;

			if (this.controller) {
				this.controller.destroy();
				this.controller = null;
			}
			if (this.actionAdapter) {
				this.actionAdapter.destroy();
				this.actionAdapter = null;
			}
		},
		unbuild: function() {
			if (this.rootLayout) {
				this.rootLayout.destroy();
				this.rootLayout = null;
			}
			Base.prototype.unbuild.call(this);
		},
		_ensureController: function() {
			this.controller = new SdataController(this.pageData.dataset, null, this.pageData.isWorkingCopy);
			// Will raise notifications or do confirmations
			this.controller.setUIAdapter(this);
		},
		createRootElement: function() {
			Base.prototype.createRootElement.call(this);
			this.$$elmt.attr("data-controller-id", this.controller.id);
			// Needed by css - previous version
			var css = ["regular"];
			var facet = this.controller.dataset.prototype.getFacet();
			if (facet) {
				css.push(facet.smStartsWith("$") ? facet.substring(1) : facet);
			}
			this.$$elmt.addClass(css.join(" "));
		},
		initStructure: function() {
			Base.prototype.initStructure.call(this);
			this.rootLayout = articleParser.parseArticle(this.controller, this.pageData.page.$article, this);
			if (!this.rootLayout) {
				return $.smReject(helpers.createDiag(null, "error", locale.text("page.invalid.article")));
			}
		},
		render: function() {
			var self = this;
			return $.smResolve()
				.then(function() {
					self.attachedControlsMgr.buildHtml();
					return self.renderRootLayout();
				});
		},
		renderRootLayout: function() {
			var self = this;
			return $.smResolve().then(function() {
				self.rootLayout.set$$container(self.$$contentRoot);
				self.rootLayout.buildHtml();
			})
		},
		afterRender: function() {
			this.rootLayout.afterRender();
		},

		/**
		 * Called when the data on a page has changed after pagination/filter..
		 * Normally we shoudl'nt rebuild but just refresh the page
		 */
		rebuildHtml: function() {
			this.rootLayout.destroy();
			this.rootLayout = articleParser.parseArticle(this.controller, this.pageData.page.$article, this);
			this.rootLayout.set$$container(this.$$contentRoot);
			this.rootLayout.buildHtml();
			// Like the controls are destroyed we have to computeLayout to recalculate the widths
			this.computeLayout({
				refresh: true
			});
		},

		/**
		 * Compute layout starting from rootLayouts
		 */
		computeControlsLayouts: function(context) {
			Base.prototype.computeControlsLayouts.call(this, context);
			if (this.rootLayout) {
				this.rootLayout.computeLayout(context);
			}
		},
		/**
		 * True if scroll enabled in page
		 * edit/detail allows scroll in vignette
		 * query/lookup doesn't allow because scroll is done by the array
		 */
		scrollAllowed: function() {
			if (this.controller.dataset.prototype.isQueryLikeFacet()) {
				// This is the array which scrolls
				return false;
			}
			return true;
		},

		//
		// START UI ADAPTER
		//

		/**
		 * Called before processing an action
		 * Returns a promise
		 * Resolve with (true/false, beforeContext)
		 * 	-> false to stop the action - true to continue
		 * 	-> beforeContext (optional) is a context passed to afterOnSdataActionClicked 
		 */
		beforeOnSdataActionClicked: function(actionName, controller) {
			var context = null;
			var goAhead = true;
			if (actionName === "$edit") {
				// Used to stay at the same position when we edit the page
				var selector = '.s-m-control.s-m-field';
				this.$$contentElmt.find(selector).each(function() {
					var $$e = $(this);
					if ($$e.is(":visible") && $$e.offset().top > 50) {
						// Pass the first 'visible' element
						context = {
							selector: selector,
							id: $$e.attr("id").split('-')[0],
							offset: $$e.offset().top
						}
						return false;
					}
				})
			}
			return $.smResolve(goAhead, context)
		},

		/**
		 * Called after an action/link has been processed
		 * actionName: name of clicked action/link
		 * successOrPage: if actionName is a service (_executeLink/$save) successOrPage is true if success
		 * 				  if actionName is a link (gotoUrl/$edit) successOrPage is the new page
		 * No return expected
		 */
		afterOnSdataActionClicked: function(actionName, successOrPage, controller, beforeContext) {
			if ((actionName === "$save" || actionName === "$delete") && successOrPage === true) {
				setTimeout(function() {
					// TODO - Add an authoring property to manage the behavior 
					modules.get("appController").App.goBack();
				})
			} else if (actionName === "$edit" && beforeContext != null) {
				var newPage = successOrPage;
				if (newPage && newPage.getGestureMgr()) {
					// Scroll in order to restore the same offset
					var id = beforeContext.id + "-";
					var self = this;
					newPage.$$contentElmt.find(beforeContext.selector).each(function() {
						var $$e = $(this);
						if ($$e.attr("id").smStartsWith(id)) {
							newPage.getGestureMgr().adjust(beforeContext.offset - $$e.offset().top);
							return false;
						}
					})
				}
			}
		},
		_showNotification: function(title, message, severity) {
			modules.get("modal").notify({
				title: title,
				body: message,
				severityClass: severity
			});
		},
		_askConfirmation: function($confirm) {
			var resultPromise = $.Deferred();
			modules.get("modal").simpleConfirm($confirm, function(confirmed) {
				resultPromise.resolve(confirmed);
			});
			return resultPromise.promise();
		},
		// This is mostly for debugging pending requests easily
		_updateRequestCount: function(count) {
			if (!this.$$counter) {
				this.$$counter = $('<span style="position: absolute; right: 0; bottom: 0; padding: 10px; background: white; z-index: 99999; opacity: 0.5;"><span>');
				this.$$elmt.append(this.$$counter);
			}
			if (count > 0) {
				this.$$counter.show();
				this.$$counter.text(count);
			} else {
				this.$$counter.hide();
			}
		},
		//
		// END UI ADAPTER
		//

		getPageTitle: function() {
			return this.controller.dataset.prototype.getValueByPath("$title", true);
		},

		_actOpenActionsPanel: function() {
			var actionsPanel = this.attachedControlsMgr.findByName("actionsPanel");
			if (!actionsPanel) {
				var info = this._getAttachedControlInfo("actionsPanel");
				if (info) {
					actionsPanel = this.attachedControlsMgr.createControl(info);
				}
			}
			if (!actionsPanel) {
				return;
			}
			actionsPanel.show();
		},

		/**
		 * Used by paging to allow the page to reload itself and update the history also
		 */
		fetchNewPageData: function($link) {
			var self = this;
			var $url = $link.$url;
			var fetchData = sdataReq.fetchPageData({
					$url: $url
				}, {
					prototype: self.pageData.prototype.json,
					page: self.pageData.page
				})
				.then(function(pageData) {
					var navStack = modules.get("navStack").findClosest(self.$$elmt);
					if (navStack) {
						navStack.replaceCurrentPageData(self, function(currentData) {
							currentData.url = $url;
							return currentData;
						});
					}
					// Saved context
					self.options.savedCtx = self.savedCtxCreate({
						noScroll: true
					});
					//keep the settings
					var settings = $.extend(true, {}, self.pageData.settings);
					self.pageData = pageData;
					self.pageData.settings = settings;
					self.controller.dataset.destroy();
					self.controller.setDataset(self.pageData.dataset);
					self.rebuildHtml();
				});
			// !! Returns the promise
			return waiting.waitModal(fetchData)
				.fail(function(error) {
					modules.get("modal").error(error);
				})
				.then(function() {
					self.onPageDataChanged();
				});
		},
		getPageSort: function() {
			return this.getPageSettings().sort;
		},
		getPageFilter: function() {
			return this.getPageSettings().filter;
		},
		getPageSearch: function() {
			return this.getPageSettings().search;
		},
		setPageSort: function(sort) {
			var old = this.getPageSort();
			if (sort == null && old == null) {
				return;
			}
			var changed = (old == null || sort == null) || (old.length != sort.length);
			changed = changed || sort.some(function(val, idx) {
				return sort[idx].sort !== old[idx].sort || sort[idx].field !== old[idx].field;
			});
			if (changed) {
				this.getPageSettings().sort = sort;
				this.getPageSettings().isDirty = true;
			}
		},
		setPageFilter: function(filter) {
			var old = this.getPageSort();
			if (old == null && filter == null) {
				return;
			}
			this.getPageSettings().filter = filter;
			this.getPageSettings().isDirty = true;
		},
		setPageSearch: function(searchchInfo) {
			this.getPageSettings().search = $.extend(true, null, searchchInfo);
			this.getPageSettings().isDirty = true;
			this.writePageSettings();
		},
		/* 
		 * Write user specific settings of this page
		 * Uses getPagePrefsId to compute key of the page
		 * When the key is empty, the page is assumed to have not settings and nothing is written
		 */
		writePageSettings: function() {
			var self = this;
			var pageSettings = self.getPageSettings();
			if (!pageSettings.isDirty) {
				return $.smResolve();
			}
			return $.smResolve()
				.then(function() {
					var pagePrefsId = self.getPagePrefsId();
					if (pagePrefsId) {
						delete pageSettings["isDirty"];
						return settings.writeUserPagePrefs(pagePrefsId, pageSettings);
					}
				});
		},
		getPageSettings: function() {
			if (!this.pageData.settings) {
				this.pageData.settings = {};
			}
			return this.pageData.settings;
		},
		/**
		 * Called when the data on a page has changed.
		 * First time called after page has rendered and the e.g. on paging
		 */
		onPageDataChanged: function() {
			Base.prototype.onPageDataChanged.call(this);
			if (!this.isVignette()) {
				// Vignettes will report to their dashboard and not directly notify here
				notifications.publish("sm.data.freshness.change", this.controller.dataset.getDataFreshness());
			}
		},
		// Arguments:  $details, $edit, $create, $query
		isFacet: function() {
			return this.controller.dataset.prototype.isFacet.apply(this.controller.dataset.prototype, arguments);
		},
		//
		// START: Authoring
		//
		allowAuthoring: function() {
			return true;
		},
		/**
		 * Returns name to use for saving authoring
		 * 
		 * Note: If the current page is the first page of a mobile application and is defined by a single homeGadget,
		 * the url to navigate to the page is the mobile application url. BUT the url used to determine the page
		 * name is the representations name and is stored in $mobileEmbeddedUrl
		 * 
		 * x3.erp.AQTCRUDM.$query
		 * syracuse.collaboration.testHomeDashboard.$mobileDashboard
		 */
		getAuthoringName: function() {
			var $url = this.pageData.dataset.json.$mobileEmbeddedUrl || this.pageData.$url;
			var repr = protoHelpers.getReprFromUrl($url);
			var ep = protoHelpers.getEndpointFromUrl($url);
			ep = ep.split(".").slice(0, 2).join(".");
			return ep + "." + repr;
		},
		/**
		 * Returns FULL name to use for reading articles
		 * The difference to getAuthoringName is, it also includes the dataset name (e.g. GX3APP)
		 * 
		 * Note: If the current page is the first page of a mobile application and is defined by a single homeGadget,
		 * the url to navigate to the page is the mobile application url. BUT the url used to determine the page
		 * name is the representations name and is stored in $mobileEmbeddedUrl
		 * 
		 * x3.erp.GX3APP.AQTCRUDM.$query
		 * syracuse.collaboration.testHomeDashboard.$mobileDashboard
		 */
		getAuthoringFullName: function() {
			var $url = this.pageData.dataset.json.$mobileEmbeddedUrl || this.pageData.$url;
			var repr = protoHelpers.getReprFromUrl($url);
			var ep = protoHelpers.getEndpointFromUrl($url);
			ep = ep.split(".").slice(0, 3).join(".");
			return ep + "." + repr;
		},
		getPrototype: function() {
			return this.pageData.prototype;
		},
		getRootLayout: function() {
			return this.rootLayout;
		},
		getArticle: function() {
			return this.pageData.page.$article;
		},
		authUpdateLayout: function(article) {
			this.pageData.page.$article = article;
			if (this.actionAdapter) {
				this.actionAdapter.clearCachedItems();
			}
			return Base.prototype.authUpdateLayout.call(this, article);
		},
		//
		// END: Authoring
		//
		isDownloadEnabled: function() {
			return false;
		},
		getAuthoring: function(path, defValue) {
			var val = utils.getPropByPath(utils.getPropByPath(this, "pageData.page.$article"), path);
			return val != null ? val : defValue;
		},
		multiSelectionIsEnabed: function() {
			return false;
		},

		/** 
		 * TODO: https://jira-sage.valiantyscloud.net/browse/X3-17940
		 */
		getPinActionState: function() {
			return this.options.isPinned ? "unpin" : "pin"
		},
		_actPinPage: function() {
			alert("PIN");
		},
		_actUnpinPage: function() {
			alert("UNPIN");
		},
		// What does the page basically support
		getPagePublishOptions: function() {
			if (this._publishOptions) {
				return this._publishOptions;
			}
			if (this.options.isChild) {
				this._publishOptions = {};
				return this._publishOptions;
			}
			var opts = {
				"scheduleMessage": {
					page: this
				},
				"share": {
					page: this
				}
			}
			if (this.pageData.prototype.isQuery()) {
				opts.liveTile = {
					page: this, // page to open on tile click
					pages: [this] // page to use for tile content (same as page or a vignette)
				}
			}
			this._publishOptions = opts;
			return this._publishOptions;
		},
		getPublishOptions: function() {
			var supportedByPage = this.getPagePublishOptions();
			var opts = {};
			Object.keys(supportedByPage).forEach(function(fn) {
				if (native.hasCapability(fn)) {
					opts[fn] = supportedByPage[fn];
				}
			});
			return opts;
		},
		_checkSharePanelActive: function() {
			if (this.options.isVignette) { // Will be handled by dashboard
				return false;
			}
			var opts = this.getPublishOptions();
			return Object.keys(opts).length > 0;
		}
	}
);
});

define('syracuse-tablet/html/js/multiselection/multiSelectionMainController',['require','exports','module','syracuse-tablet/html/js/controllers/sdataController','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/sdata/sdataRequester','syracuse-tablet/html/js/sdata/sdataUtils','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/sdata/protocolHelpers','syracuse-tablet/html/js/sdata/sdataRequester'],function (require, exports, module) {

var Base = require("syracuse-tablet/html/js/controllers/sdataController").SdataController;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var sdataReq = require("syracuse-tablet/html/js/sdata/sdataRequester");
var sdataUtils = require("syracuse-tablet/html/js/sdata/sdataUtils");
var modules = require('syracuse-tablet/html/js/common/modules');
var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');
var sdataReq = require("syracuse-tablet/html/js/sdata/sdataRequester");


/**
 * Main multi-selection controller
 * Declared at queryPageLevel
 */
exports.MultiSelectionMainController = utils.defineClass(
	function MultiSelectionMainController(queryPage) {
		if (queryPage == null || queryPage.isFacet == null || !queryPage.isFacet("$query")) {
			throw new Error("Sdata query page expected");
		}
		Base.call(this, queryPage.pageData.dataset, null, queryPage.pageData.isWorkingCopy);
		this._page = queryPage;
		// Header/Footer with multSelection button
		this._panel = null
			// $resources array
		this._array = null;
		// header/footer displayed when action are processed on selected data
		this._panelRun = null;
	},
	Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			this._page == null;
			this._panel = null;
			this._array = null;
			this._panelRun = null;
		},
		/**
		 * Caller queryPage
		 * Toggles the status
		 * Returns true is status enabled
		 */
		multiSelToggleStatus: function() {
			var isSmartphone = modules.get("siteLayout").getDeviceType() === "smartphone";
			if (this._panel == null) {
				var panelInfo;
				if (isSmartphone) {
					panelInfo = {
						name: "headerMultisel",
						topIndex: 0,
						selector: "header",
						$type: "application/x-panel-header-multisel-smartphone"
					}
				} else {
					panelInfo = {
						name: "footerMultisel",
						topIndex: 0,
						selector: "footer",
						$type: "application/x-panel-footer-multisel-tablet"
					}
				}
				this._panel = this._page.attachedControlsMgr.createAddtionalControl(panelInfo, {});
				this._array = this._page.getQueryArray();
			}
			this.isEnabled = this._page.attachedControlsMgr.toggleControls(isSmartphone ? "headerMultisel" : "footerMultisel", isSmartphone ? "header" : "footer");
			// Notifies header/footer
			this._panel.multiSelectionController.multiSelToggleStatus(this.isEnabled);
			this._array.multiSelToggleStatus(this.isEnabled);
			if (!isSmartphone) {
				//Disable header
				this._page.attachedControlsMgr.findByName("header").disable(this.isEnabled);
			}
			return this.isEnabled;
		},
		/**
		 * Caller arrayRow/Cell on click on record
		 * Toggles the status of card/row
		 */
		multiSelToggleRecord: function($$recordElmt) {
			if (this._isProcessingData()) {
				return;
			}
			$$recordElmt.toggleClass("s-m-multi-selected");
			// Notifies header/footer
			this._panel.multiSelectionController.multiSelToggleRecord($$recordElmt.is(".s-m-multi-selected"));
		},
		multiSelExit: function() {
			// Exit run mode
			this._array.multiSelRemoveDiagnoses();
			this._panelRun.multiSelectionController.multiSelRunExit();
			this._processTogglePanel(false);
			this.multiSelToggleStatus();
		},
		/**
		 * Caller queryPage
		 * Applies $actionName to selected rows/cards
		 */
		multiSelTriggerAction: function($actionName, event) {
			if ($actionName === "showdiagnoses") {
				this._array.multiSelShowDiagnoses(event);
			} else if ($actionName === "stop") {
				this._processRunning = false
			} else if ($actionName === "exit") {
				this.multiSelExit();
			} else {
				//waiting.waitModal()
				$('<div id="multiSelSpinner"><div><div class="spinner-loader"></div></div></div>').appendTo(this._page.$$contentElmt);
				this._processRunning = true;
				var self = this;
				var _end = function(status) {
					$("#multiSelSpinner").remove();
					self._processRunning = false;
					self._panelRun.multiSelectionController.multiSelRunStop();
				}
				this._processRun($actionName).then(function(status) {
					_end(status);
				}).fail(function(error) {
					modules.get("modal").asynchError(locale.text("multiselect.processAll.fail"), error).then(function() {
						_end("stop");
					});
				});
			}
		},
		_isProcessingData: function() {
			return this._processRunning === true;
		},
		/**
		 * Processes all cards/rows
		 */
		_processRun: function($actionName) {
			var self = this;
			var nbOk = 0;
			var nbKo = 0;
			return $.smResolve().then(function() {
				// Displays dedicated footer/header and hides unselected rows
				self._processTogglePanel(true);
				self._panelRun.multiSelectionController.multiSelStartProcessing();
				return {
					$actionName: $actionName,
					data: self._array.multiSelGetSelectedData(),
					link: protoHelpers.adjustLinkProtocol(self._page.controller.dataset.getLink($actionName), self._getUsedProtocol())
				}
			}).then(function(info) {
				if (!info.link || !info.data) {
					return null;
				}
				var deferred = $.Deferred();
				var _exec = function(idx) {
					if (idx >= info.data.length) {
						// End
						deferred.resolve("end", info);
					} else {
						self._processOne(info, idx).then(function(status) {
							if (status === "stop") {
								deferred.resolve("stop", info);
								return;
							}
							if (status === "success") {
								nbOk++
							} else {
								nbKo++;
							}
							self._panelRun.multiSelUpdateCounter(nbOk, nbKo);
							// Next
							_exec(idx + 1);
						}).fail(function(e) {
							deferred.reject(e);
						})
					}
				};
				// First
				_exec(0);
				return deferred.promise();
			})
		},
		/**
		 * Process one selected row/card
		 */
		_processOne: function(info, idx) {
			var step;
			if (info.link.$url === "$UnitTesturl") {
				step = this._procesUnitTestUrl(info, idx);
			} else {
				step = this._processUrl(info, idx)
			}
			var self = this;
			return step.then(function(success, result) {
				if (!self._isProcessingData()) {
					// Process stopped
					return "stop";
				}
				var diagsMsg = [];
				var diagsErr = [];
				if ($.isPlainObject(result)) {
					(sdataUtils.scanDiagnoses(result) || []).forEach(function(d) {
						if (d.$severity === "error") {
							diagsErr.push(d);
						} else {
							diagsMsg.push(d);
						}
					});
				}
				var diags = info.data[idx];
				success = success && diagsErr.length == 0;
				if (!success) {
					if (jsutils.isError(result)) {
						diags.$diagnoses = [{
							$message: result.message,
							$stackTrace: result.stack
						}];
					} else {
						diags.$diagnoses = diagsErr;
					}
				} else {
					diags.$diagnoses = diagsMsg;
				}
				diags.status = success ? "success" : "error";
				self._array.multiSelAddDiagnoses(diags);
				return diags.status;
			})
		},
		/**
		 * Execute action info.$actionName on rowData dtaSet
		 */
		_processUrl: function(info, idx) {
			var rowDataSet = info.data[idx].rowData;
			var self = this;
			var deferred = $.Deferred();
			var $url = rowDataSet.resolveExpression(info.link.$url, true);
			if (info.link.$parameters) {
				$.each(info.link.$parameters, function(paramName, paramValue) {
					// PARAMETER_ESCAPING
					// If there are placeholders in a parameters value, we try to resolve them here
					// In any case, the result is encoded to ensure sdataUtils.getLinkInfo will not fail if there
					// are non valid characters in the url
					// As a result, in multiselection, eventually left over encoded placeholders need to be
					// unescaped and replaced later in the process (see multiSelectionMgr.js -> PARAMETER_ESCAPING)
					if (paramValue.indexOf("{") > -1) {
						var pv2 = rowDataSet.resolveExpression(paramValue);
						if (pv2 && pv2.length > 0) {
							paramValue = encodeURIComponent(pv2);
						} else {
							paramValue = encodeURIComponent(paramValue);
						}
					}
					$url = $url.replace("{" + paramName + "}", paramValue);
				});
			}
			// We force GET for multi-selection
			sdataReq.executeLink($url, "GET", rowDataSet).then(function(response) {
				var delta = response.data;
				if (delta) {
					// If there is a delta sent by the server, we merge it
					// This will add field level diagnoses
					// error checking will be done later independently
					return self._mergeDelta(delta).then(function() {
						return response;
					});
				}
				return response;
			}).then(function(result) {
				deferred.resolve(result.success === true, result);
			}).fail(function(e) {
				deferred.resolve(false, jsutils.convertToDiagnoses(e));
			});
			return deferred.promise();
		},
		/**
		 * Used to test ui process.
		 * Don't send an url
		 */
		_procesUnitTestUrl: function(info, idx) {
			var deferred = $.Deferred();
			setTimeout(function() {
				if (idx % 2 == 0) {
					deferred.resolve(true, {
						$diagnoses: [{
							$message: "test succeeded idx=" + idx,
							$severity: "success"
						}]
					});
				} else {
					deferred.resolve(false, {
						$diagnoses: [{
							$message: "test failed idx=" + idx,
							$severity: "error"
						}]
					})
				}
			}, 1000)
			return deferred.promise();
		},
		/**
		 * Create if needed and toggle the process header/footer with the stop action and 'xx successes - yy failures' message
		 */
		_processTogglePanel: function(show) {
			var isSmartphone = modules.get("siteLayout").getDeviceType() === "smartphone";
			if (this._panelRun == null) {
				var panelInfo;
				if (isSmartphone) {
					panelInfo = {
						name: "headerMultiselRun",
						topIndex: 0,
						selector: "header",
						$type: "application/x-panel-header-multisel-run-smartphone"
					}
				} else {
					panelInfo = {
						name: "footerMultiselRun",
						topIndex: 0,
						selector: "footer",
						$type: "application/x-panel-footer-multisel-run-tablet"
					}
				}
				this._panelRun = this._page.attachedControlsMgr.createAddtionalControl(panelInfo, {});
			}
			this._page.attachedControlsMgr.toggleControls(isSmartphone ? "headerMultiselRun" : "footerMultiselRun", isSmartphone ? "headerMultisel" : "footerMultisel", show);
			return this._panelRun;
		},
		/**
		 * Returns the selected dataSets
		 */
		getSelectedData: function() {
			return this._array.multiSelGetSelectedData();
		}
	});
});

define('syracuse-tablet/html/js/sdata/sdataSyncUtils',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/sdata/prototype','syracuse-tablet/html/js/sdata/cache/metaDataCache'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var prototypeModule = require('syracuse-tablet/html/js/sdata/prototype');
var metaDataCache = require('syracuse-tablet/html/js/sdata/cache/metaDataCache');

var _syncMaxLevels = 6;

exports.getSyncStructure = function(prototype) {
	var node = {
		$title: prototype.data("$title")
	};
	var urlList = [];
	return _resolvePrototype({
		prototype: prototype,
		level: 1,
		maxLevels: _syncMaxLevels
	}, node, urlList);
};

function _resolvePrototype(opts, node, urlList) {
	node.uuid = utils.UUID();
	node.$children = [];
	if (opts.level >= opts.maxLevels) {
		return $.smResolve(node);
	}

	var $links;

	// For query facet, only take $details link into account
	if (opts.prototype.getFacet() === "$query") {
		var $resources = opts.prototype.getPropertyData("$resources");
		if ($resources && $resources.$item && $resources.$item.$links && $resources.$item.$links.$details) {
			$links = {
				$details: $resources.$item.$links.$details
			};
		}
	} else if (opts.prototype.getFacet() === "$details") {
		$links = opts.prototype.data("$links");
		if ($links && $links.$edit) {
			node.$canEdit = true;
		}
	} else {
		// Only $details and $query facets allowed, we should never end up here, just for safety
		return $.smResolve(node);
	}
	if (!$links) {
		return $.smResolve(node);
	}

	return $.smForEachPromise(Object.keys($links), function(name) {
			var link = $links[name];
			if (_isCacheableLink(link, name, urlList)) {
				//var url = sdataUtils.parseSDataURL(link.$url);
				var repr = _getRepresentation(link);
				if (repr) {
					urlList.push(link.$url);

					var child = {
						$name: name,
						$title: opts.prototype.resolveExpression(link.$title),
						$link: link,
						$representation: repr
					};
					node.$children.push(child);
					return _processNode(child, opts, urlList);
				}
			}
			return $.smResolve(node);
		})
		.then(function() {
			if (node.$canEdit) {
				node.$editLink = $links["$edit"];
				var repr = _getRepresentation(node.$editLink);
				var protoName = _getProtoName({
					$representation: repr
				}, {
					prototype: opts.prototype // Only $baseUrl is extracted
				});

				return metaDataCache.getPrototype(protoName)
					.then(function(proto) {
						node.$editPrototype = prototypeModule.create(proto);
					});
			}
		})
		.then(function() {
			return node;
		});
}

function _isCacheableLink(link, name, urlList) {
	if (urlList.indexOf(link.$url) > -1) {
		return false;
	}
	if (name.indexOf("$") === 0 && name !== "$details") {
		return false;
	}
	if (link.$method !== "GET" && link.$method != null) {
		return false;
	}
	if (link.$url.indexOf("/$services/") > -1) {
		return false;
	}
	if (link.$url.indexOf("representation=") < 0) {
		return false;
	}
	var repr = _getRepresentation(link);
	if (!repr || repr.indexOf(".$details") < 0 && repr.indexOf(".$query") < 0) {
		return false;
	}
	return true;
}

function _getRepresentation(link) {
	var repr = /[\?\&]representation=(\S+?)(&|$)/.exec(link.$url);
	return repr && repr[1];
}

function _processNode(node, opts, urlList) {

	var protoName = _getProtoName(node, opts);
	return metaDataCache.getPrototype(protoName)
		.then(function(proto) {
			if (proto) {
				proto = new prototypeModule.Prototype(proto);
				node.$prototype = proto;
				if (node.$name === "$details") {
					node.$title = proto.data("$title");
					node.$isDetails = true;
				}

				return _resolvePrototype({
					prototype: proto,
					level: opts.level + 1,
					maxLevels: opts.maxLevels
				}, node, urlList);
			}
		});
}

function _getProtoName(node, opts) {
	var endpoint = opts.prototype.data("$baseUrl");
	endpoint = endpoint.split("/");
	endpoint = endpoint.slice(endpoint.length - 3, endpoint.length).join(".");
	return endpoint + "." + node.$representation;
}
});

define('syracuse-tablet/html/js/ui/modals/modalSyncOffline',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/sdata/sdataSyncUtils','syracuse-tablet/html/js/sdata/sdataRequesterOffline','syracuse-tablet/html/js/common/ajax'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var sdataSyncUtils = require('syracuse-tablet/html/js/sdata/sdataSyncUtils');
var sdataRequesterOffline = require("syracuse-tablet/html/js/sdata/sdataRequesterOffline");
var ajax = require('syracuse-tablet/html/js/common/ajax');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
			<div class="s-m-scroll-element"> \
				<div class="form-group" id="s-m-sync-no-data-id"> \
					<div class="panel s-m-panel-diag-error"><div class="panel-heading">{{label_errors}}</div><ul></ul></div> \
					<center>{{label_no_data}}</center>\
				</div> \
				<div class="form-group" id="s-m-sync-actions-id" style="display: none"> \
					<center> \
						<button type="button" class="btn btn-default s-m-modal-btn-sync" data-action="modal-sync">{{label_sync}}</button> \
						<button type="button" class="btn btn-default s-m-modal-btn-sync-stop hidden" data-action="modal-sync-stop">{{label_sync_stop}}<div class="s-m-sync-total"><span class="label label-success ok"></span><span class="label label-danger error"></span></div></button> \
					</center> \
				</div> \
				<div class="form-group" id="s-m-sync-tree-id"> \
					<label>{{label_tree}}</label> \
					<div id="s-m-sync-tree-id"></div> \
				</div> \
			</div> \
			</div>',
	footer: ''
};

var _Klass = utils.defineClass(
	function ModalSyncOffline(syncRootData) {
		var self = this;
		modalDialog.ModalBase.call(self);
		self.syncRootData = syncRootData;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "sync-offline half_right";
			} else {
				displayFlags.modalClass = "sync-offline full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			var data = {
				title: locale.text("modal.sync.title"),
				label_tree: locale.text("modal.sync.header.tree"),
				label_sync: locale.text("modal.sync.label_sync"),
				label_sync_stop: locale.text("modal.sync.label_sync_stop"),
				label_no_data: locale.text("modal.sync.nodata"),
				label_errors: locale.text("modal.sync.errors")
			};
			return data;
		},

		_onShow: function() {
			var self = this;
			modalDialog.ModalBase.prototype._onShow.call(self);
			sdataSyncUtils.getSyncStructure(self.syncRootData.pageProto)
				.then(function(tree) {
					self.syncTreeRoot = tree;
					if (self.syncTreeRoot) {
						self._buildStructHtml(tree);
					} else {
						self._noData();
					}
				})
				.fail(function(e) {
					self._noData(e);
				});
		},

		_noData: function(e) {
			var self = this;
			$("#s-m-sync-no-data-id").show();
			$("#s-m-sync-actions-id").hide();
			$("#s-m-sync-tree-id").hide();

			var $$ul = $("#s-m-sync-no-data-id ul");
			$$ul.empty();
			e = e && e.$diagnoses;
			if (e && e.length) {
				$("#s-m-sync-no-data-id .panel").show();
				var i;
				for (i = 0; i < e.length; i++) {
					var msg = e[i] && e[i].$message;
					if (msg) {
						var $$li = $("<li>");
						$$li.text(msg);
						$$ul.append($$li);
					}
				}
			} else {
				$("#s-m-sync-no-data-id .panel").hide();
			}
		},
		_buildStructHtml: function(node) {
			var self = this;
			$("#s-m-sync-no-data-id").hide();
			$("#s-m-sync-actions-id").show();
			$("#s-m-sync-tree-id").show();
			var $$sync = $("#s-m-sync-tree-id");
			var $$ul = $("<ul>");
			self._addNode($$ul, node, 0);
			$$sync.append($$ul);
		},

		_addNode: function($$parent, node, level) {
			var self = this;
			var cls = level > 0 ? "collapsed" : "expanded";
			cls = cls + (level < 1 ? " selected" : "");
			var $$li = $('\
				<li class="s-m-sync-tree-item ' + cls + '" data-params="' + node.uuid + '"> \
					<div class="s-m-tree-icon-expand" data-action="tree-click-expand" data-params="' + node.uuid + '"></div> \
					<div class="s-m-tree-label" data-action="tree-click-select" data-params="' + node.uuid + '"></div> \
					<div class="s-m-sync-count hidden"><div>"\
				</li>');
			$("div.s-m-tree-label", $$li).text(node.$title);
			$$parent.append($$li);
			if (node.$children.length > 0) {
				var $$ul = $("<ul>");
				if (node.$isDetails !== true) {
					// For $query parent, the single $details link is not added to the tree it will be handled implicitly
					var child = node.$children[0];
					if (child && child.$children && child.$children.length > 0) {
						$$li.append($$ul);
						child.$children.forEach(function(child) {
							self._addNode($$ul, child);
						});
					}
				} else {
					if (node.$children && node.$children.length > 0) {
						$$li.append($$ul);
						// For a $details parent, all child links are added as new tree level
						node.$children.forEach(function(child) {
							self._addNode($$ul, child);
						});
					}
				}
			}
			// No children added
			if ($("ul", $$li).length < 1) {
				var $$expand = $(">.s-m-tree-icon-expand", $$li);
				$$expand.removeClass("s-m-tree-icon-expand");
				$$expand.addClass("s-m-tree-icon-leaf");
				$$expand.attr("data-action", null);
			}
		},
		_onAction: function(action, param) {
			var self = this;
			if (action === "tree-click-expand") {
				self._onTreeClickExpand(param);
			} else if (action === "tree-click-select") {
				self._onTreeClickSelect(param);
			} else if (action === "modal-sync") {
				self._syncData();
			} else if (action === "modal-sync-stop") {
				self.stopSync = true;
			}

			return false;
		},
		_onValidate: function() {},

		_onCancel: function() {},

		_getResult: function() {
			return "done";
		},
		_onTreeClickExpand: function(param) {
			var self = this;
			var $$li = $('li[data-params="' + param + '"]');
			if ($$li.hasClass("expanded")) {
				$$li.removeClass("expanded");
				$$li.addClass("collapsed");
			} else {
				$$li.addClass("expanded");
				$$li.removeClass("collapsed");
			}
		},
		_onTreeClickSelect: function(param) {
			var self = this;
			var $$li = $('li[data-params="' + param + '"]');
			if ($$li.hasClass("selected")) {
				$$li = $$li.add("li", $$li);
				$$li.removeClass("selected");
			} else {
				$$li = $$li.add("li", $$li);
				$$li.addClass("selected");
			}
		},

		_syncData: function() {
			var self = this;
			self.stopSync = false;

			var $$li = $('li[data-params="' + self.syncTreeRoot.uuid + '"]');

			$('button[data-action="modal-sync"]', self.$$elmt).addClass("hidden");
			$('button[data-action="modal-sync-stop"]', self.$$elmt).removeClass("hidden");

			self.syncCount = 0;
			self.errorCount = 0;
			self._updateErrorCount();
			$.smForEachPromise(self.syncRootData.rowsData, function(row, idx, cnt) {
					if (self.stopSync) {
						return $.smResolve();
					}
					self._updateSyncCount($$li, idx, cnt);
					return self._syncNodeData(self.syncTreeRoot, row);
				})
				.always(function(e) {
					$('button[data-action="modal-sync"]', self.$$elmt).removeClass("hidden");
					$('button[data-action="modal-sync-stop"]', self.$$elmt).addClass("hidden");
				});
		},

		_updateSyncCount: function($$li, idx, cnt) {
			var self = this;
			var $$state = $(">div.s-m-sync-count", $$li);
			$$state.removeClass("hidden");
			$$state.text((idx + 1) + " / " + cnt);
			var $$states = $("li>div.s-m-sync-count", $$li);
			$$states.addClass("hidden");
		},

		_updateErrorCount: function() {
			var self = this;

			var $$total = $('button[data-action="modal-sync-stop"]>.s-m-sync-total', self.$$elmt);
			var $$ok = $(">.ok", $$total);
			var $$error = $(">.error", $$total);
			$$ok.text(self.syncCount);
			$$error.text(self.errorCount);
		},

		_syncNodeData: function(node, parentData) {
			var self = this;
			var $$li;

			if (self.stopSync) {
				return $.smResolve();
			}

			if (node.$isDetails !== true) {
				$$li = $('li[data-params="' + node.uuid + '"]');
				if ($$li.length < 1) {
					return $.smResolve();
				}
				if (!$$li.hasClass("selected")) {
					return $.smResolve();
				}
				node.$$listItem = $$li;
			}

			node.$$listItem.addClass("sync-progress");

			var nodeData;
			if (node.$link) {
				nodeData = self._readNodeData(node, parentData);
			} else {
				nodeData = $.smResolve(parentData);
			}
			return nodeData
				.then(function(nodeData) {
					var dataItems = nodeData && nodeData.$resources;
					if (!dataItems && nodeData) {
						dataItems = [nodeData];
					}
					if (!dataItems) {
						return $.smResolve(null);
					}
					return $.smForEachPromise(dataItems, function(dataItem, idx, cnt) {
						if (self.stopSync) {
							return $.smResolve();
						}

						if (nodeData.$resources) {
							self._updateSyncCount($$li, idx, cnt);
						}
						return $.smForEachPromise(node.$children, function(child) {
							if (self.stopSync) {
								return $.smResolve();
							}

							child.$$listItem = $$li;
							return self._syncNodeData(child, dataItem);
						}).
						then(function() {
							// Children may set the same node to finished which may be wrong
							node.$$listItem.addClass("sync-progress");
						});
					});
				})
				.then(function() {
					node.$$listItem.removeClass("sync-progress");
				});
		},
		_readNodeData: function(node, parentData) {
			var self = this;
			var deferred = $.Deferred();
			var linkUrl = utils.parseExpression(node.$link.$url, parentData, node.$prototype);

			ajax.request(linkUrl, "GET")
				.then(function(result) {
					sdataRequesterOffline.writeToCache(linkUrl, "GET", result.data, node.$prototype.json);
					// No edit link, so we are done for detail record
					if (!node.$editLink) {
						self.syncCount++;
						self._updateErrorCount();
						deferred.resolve(result.data);

						return result.data;
					}

					// We also have to fetch $edit
					return self._readEditNodeData(node, result.data)
						.then(function() {
							self.syncCount++;
							self._updateErrorCount();
							deferred.resolve(result.data);

							return result.data;
						});
				})
				.fail(function() {
					self.errorCount++;
					self._updateErrorCount();
					deferred.resolve(null);
				});

			return deferred.promise();
		},
		_readEditNodeData: function(node, parentData) {
			var self = this;
			var deferred = $.Deferred();

			var linkUrl = utils.parseExpression(node.$editLink.$url, parentData, node.$editPrototype);

			ajax.request(linkUrl, "GET")
				.then(function(result) {
					sdataRequesterOffline.writeToCache(linkUrl, "GET", result.data, node.$editPrototype.json);
					deferred.resolve(result);
					return result.data;
				})
				.fail(function() {
					deferred.resolve(null);
				});
			return deferred.promise();
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/multiselection/downloadController',['require','exports','module','syracuse-tablet/html/js/controllers/sdataController','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/modals/modalSyncOffline'],function (require, exports, module) {

var Base = require("syracuse-tablet/html/js/controllers/sdataController").SdataController;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var modalSyncOffline = require('syracuse-tablet/html/js/ui/modals/modalSyncOffline');

/**
 * parent can be null (formController)
 */
exports.DownloadController = utils.defineClass(
	function DownloadController(queryPage) {
		if (queryPage == null || queryPage.isFacet == null || !queryPage.isFacet("$query")) {
			throw new Error("Sdata query page expected");
		}
		Base.call(this, queryPage.pageData.dataset, null, queryPage.pageData.isWorkingCopy);
		this.page = queryPage;
	},
	Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			this.page == null;
		},
		/**
		 * Caller queryPage
		 * Launch download process
		 */
		multiSelTriggerDownload: function() {

			var syncRootData = {
				pageProto: this.page.getPrototype(),
				rowsData: []
			};
			var selectedData = this.page.multiSelectionController.getSelectedData();
			selectedData.forEach(function(selectedItem) {
				var rowDataSet = selectedItem.rowData;
				syncRootData.rowsData.push(rowDataSet.json);
			});

			var modal = new modalSyncOffline.Modal(syncRootData);
			modal.show().then(function(result) {});
		}
	});
});

define('syracuse-tablet/html/js/pages/sdata/pageSdataQuery',['require','exports','module','syracuse-tablet/html/js/pages/sdata/pageSdata','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/multiselection/multiSelectionMainController','syracuse-tablet/html/js/multiselection/downloadController'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/pages/sdata/pageSdata').Page;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var MultiSelectionController = require("syracuse-tablet/html/js/multiselection/multiSelectionMainController").MultiSelectionMainController;
var DownloadController = require("syracuse-tablet/html/js/multiselection/downloadController").DownloadController;

/**
 * Page handling a query
 * We should add filters and paging
 * 
 */
exports.Page = utils.defineClass(
	function PageSdataQuery(pageData, options) {
		options = options || {};
		options.nativeCapabilities = {
			"liveTile": true,
			"scheduleMessage": true,
			"share": true
		};
		Base.call(this, pageData, options);
		this.multiSelectionController = null;
		this.downloadController = null;
	},
	Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this.multiSelectionController) {
				this.multiSelectionController.destroy();
				this.multiSelectionController = null;
			}
			if (this.downloadController) {
				this.downloadController.destroy();
				this.downloadController = null;
			}
		},
		_actMultiSelToggle: function() {
			if (!this.attachedControlsMgr) {
				return;
			}
			if (!this.multiSelectionController) {
				this.multiSelectionController = new MultiSelectionController(this);
			}
			if (this.multiSelectionController.multiSelToggleStatus() !== true) {
				this.$$contentElmt.find(".s-m-multi-selected").removeClass("s-m-multi-selected");
			}
		},
		multiSelectionIsEnabed: function() {
			return this.multiSelectionController != null && this.multiSelectionController.isEnabled;
		},
		getQueryArray: function() {
			var array = this.controller.getControlsByType("application/x-array");
			if (array.length !== 1) {
				throw new Error("One and only one array is expected in a query facet")
			}
			return array[0];
		},
		isDownloadEnabled: function() {
			return this.getAuthoring("$allowDownload") === true;
		},
		_actMultiSelTriggerDownload: function() {
			if (!this.downloadController) {
				this.downloadController = new DownloadController(this);
			}
			this.downloadController.multiSelTriggerDownload()
		},
		_actMultiSelTriggerAction: function(params, event) {
			if (!this.multiSelectionIsEnabed()) {
				return;
			}
			this.multiSelectionController.multiSelTriggerAction(params, event)
		},
		/**
		 * Used by paging to allow the page to reload itself and update the history also
		 */
		fetchNewPageData: function($link) {
			this._oldX3FilterAuth = this.getQueryArray().$filtersGetAuthoring();
			return Base.prototype.fetchNewPageData.call(this, $link);
		},
		authUpdateLayout: function(article) {
			var step = $.smResolve();
			if (this.getQueryArray().$filtersGetAuthoring() == "none" && this._oldX3FilterAuth != "none") {
				// In case $filters authoring as changed from list/tabs to none we've to remove the filter params from the page's url
				var url = jsutils.parseURL(this.pageData.$url);
				if (url.query && url.query.filter) {
					url.query.filter = "";
					step = this.fetchNewPageData({
						$url: jsutils.urlToString(url)
					})
				}
			}
			var self = this;
			return step.then(function() {
				return Base.prototype.authUpdateLayout.call(self, article);
			})
		}
	});
});

define('syracuse-tablet/html/js/pages/sdata/pageSdataLookup',['require','exports','module','syracuse-tablet/html/js/pages/sdata/pageSdataQuery','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/pages/sdata/pageSdataQuery').Page;

var utils = require('syracuse-tablet/html/js/helpers/utils');

/**
 * Page handling a lookup
 * Based on query
 * Goes back on row selection
 * 
 */
exports.Page = utils.defineClass(
	function PageSdataLookup(pageData, options) {
		Base.call(this, pageData, options);
		// Flag the controller so the array can check if it has to put the lookup accept link
		this.controller.isLookupController = true;
		this.controller.lookupData = options.lookup;
	},
	Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
		}
	}
);
});

define('syracuse-tablet/html/js/pages/sdata/pageSdataDashboard',['require','exports','module','syracuse-tablet/html/js/pages/sdata/pageSdata','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/sdata/protocolHelpers'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/pages/sdata/pageSdata').Page;
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var utils = require('syracuse-tablet/html/js/helpers/utils');
var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');

/**
 * Page handling a dashboard
 * 
 * options: { // Additional options for dashboard page. These add up to what is possible for pageBase
 *   dashboardParameters: {
 *     CODE: {
 *       value: "10"
 *     }
 *   }
 * }
 */
exports.Page = utils.defineClass(
	function PageSdataDashboard(pageData, options) {
		options = options || {};
		Base.call(this, pageData, options);
		this._nbVignettesLoaded = 0;
		// Default, will be updaten on every loaded vignette
		this._dataFreshness = {
			dateTime: new Date().getTime(),
			level: "fresh"
		};
		this.actionAdapter.showPinPage = this.controller.canBePinned();
		this._savedVignetteContext = null;
		this._parseParameters();
	},
	Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this._savedVignetteContext = null;
			this._vignettes = null;
		},

		build: function() {
			this._publishOptions = null; // depends on vignettes which will be loaded after
			this._vignettes = null;
			this._vignettesLoaded = $.Deferred();
			return Base.prototype.build.call(this);
		},

		afterRender: function() {
			Base.prototype.afterRender.call(this);
			this._nbVignettesLoaded = 0;
		},

		getPageTitle: function() {
			// Give by dashboard value
			var ttl = this.controller.dataset.getValue("title");
			if (!ttl) {
				// Compliant with stateless dashboard (client test app)
				ttl = ttl = this.controller.dataset.getValue("$title");
			}
			if (!ttl) {
				// Given by prototype
				ttl = Base.prototype.getPageTitle.call(this);
			}
			return ttl
		},

		onVignetteLoaded: function(vignette, success) {
			if (success) {
				this._updateDataFreshness(vignette);
			}
			this._nbVignettesLoaded++;
			var vignettes = this._getVignettes();
			if (vignettes.length == 0) {
				this.afterAllVignettesLoaded();
			} else if (this._nbVignettesLoaded >= vignettes.length) {
				var self = this;
				setTimeout(function() {
					// Once all vignettes have been loaded (eg: stack hub scroller height depends on vignette content)
					vignettes.forEach(function(v) {
						v.afterAllVignettesLoaded();
					})
					self.afterAllVignettesLoaded();
				})
			}
		},
		afterAllVignettesLoaded: function() {
			this.onContentChanged();
			this.actionAdapter.showPageShare = this._checkSharePanelActive();
			notifications.publish(["sm.all.vignettes.loaded"], this);
			this._vignettesLoaded.resolve();
		},
		/*
		 * Called whenever a vignette is loaded to update the overall freshness of the dashboard
		 */
		_updateDataFreshness: function(vignette) {
			var childPage = vignette && vignette.getTopPage();
			var dataset = childPage && childPage.controller && childPage.controller.dataset;
			if (dataset) {
				var freshness = dataset.getDataFreshness();
				if (this._dataFreshness.dateTime > freshness.dateTime) {
					this._dataFreshness.dateTime = freshness.dateTime;
					this._dataFreshness.level = freshness.level;
					notifications.publish("sm.data.freshness.change", this._dataFreshness);
				}
			}
		},
		/**
		 * Returns name to use for saving authoring
		 * syracuse.collaboration.testHomeDashboard.$mobileDashboard
		 */
		getAuthoringName: function() {
			var $url = this.pageData.$url;
			var key = this.pageData.dataset.json.dashboardName;
			var ep = protoHelpers.getEndpointFromUrl($url);
			ep = ep.split(".").slice(0, 2).join(".");
			return ep + "." + key + ".$mobileDashboard";
		},
		getAuthoringFullName: function() {
			var $url = this.pageData.$url;
			var key = this.pageData.dataset.json.dashboardName;
			var ep = protoHelpers.getEndpointFromUrl($url);
			ep = ep.split(".").slice(0, 3).join(".");
			return ep + "." + key + ".$mobileDashboard";
		},
		authUpdateLayout: function(article) {
			var self = this;
			return Base.prototype.authUpdateLayout.call(self, article)
				.then(function() {
					return self._vignettesLoaded;
				});
		},
		/**
		 * typeDashboard = hub / stack / undefined
		 */
		isDashboard: function(typeDashboard) {
			return typeDashboard == null ? true : (this.rootLayout ? this.rootLayout.$type === typeDashboard : true);
		},
		/**
		 * Scroll handled by hub layout
		 */
		scrollAllowed: function() {
			return !this.isDashboard("hub");
		},
		getGestureMgr: function() {
			return this.isDashboard("hub") && this.rootLayout ? this.rootLayout.getGestureMgr() : Base.prototype.getGestureMgr.call(this);
		},
		savedCtxCreate: function(opts) {
			if (this.destroyed) {
				return;
			}
			var ctx = Base.prototype.savedCtxCreate.call(this, opts);
			ctx.vignettes = [];
			var p;
			this._getVignettes().forEach(function(v) {
				ctx.vignettes.push(v.getTopPage() ? v.getTopPage().savedCtxCreate(opts) : null);
			});
			if (this.isDashboard("hub") && this.rootLayout) {
				ctx.hubCtx = this.rootLayout.savedCtxCreate(opts);
			}
			return ctx;
		},
		savedCtxRestore: function(ctx) {
			if (this.destroyed) {
				return;
			}
			Base.prototype.savedCtxRestore.call(this, ctx);
			// store vignettes context because it is removed after calling savedCtxRestore
			// Vignettes are loaded asynch so they will need the context later
			this._savedVignetteContext = ctx.vignettes;
			if (ctx.hubCtx && this.isDashboard("hub")) {
				// Restore dashboard context
				this.rootLayout.savedCtxRestore(ctx.hubCtx);
			}
		},
		getSavedCtxVignette: function(v) {
			if (v == null) {
				return null;
			}
			if (this._savedVignetteContext == null) {
				// Check page context
				// Sometimes we want to read the context before savedCtxRestore (see searchArray)
				this._savedVignetteContext = (this.options.savedCtx && this.options.savedCtx.vignettes) || [];
			}
			var idx = this._getVignettes().indexOf(v);
			if (idx == -1 || idx > this._savedVignetteContext.length - 1) {
				return null;
			}
			return this._savedVignetteContext[idx];
		},

		_getVignettes: function() {
			if (this._vignettes == null) {
				this._vignettes = this.controller.getControlsByType("application/x-vignette") || [];
			}
			return this._vignettes;
		},

		getPagePublishOptions: function() {
			if (this._publishOptions) {
				return this._publishOptions;
			}
			if (this.options.isChild) {
				this._publishOptions = {};
				return this._publishOptions;
			}
			var opts = {
				"scheduleMessage": {
					page: this
				},
				"share": {
					page: this
				}
			}
			var queryVignettes = [];
			this._getVignettes().forEach(function(v) {
				var page = v.getTopPage();
				if (page && page.pageData && page.pageData.prototype.isQueryLikeFacet()) {
					queryVignettes.push(page);
				}
			})
			if (queryVignettes.length > 0) {
				opts.liveTile = {
					page: this, // page to open on tile click
					pages: queryVignettes // page to use for tile content (same as page or a vignette)
				}
			}
			this._publishOptions = opts;
			return this._publishOptions;
		},
		_parseParameters: function() {
			this._dashboardParams = protoHelpers.getDashboardParams(this.pageData.$url);
		},
		getGadgetParams: function() {
			return this._dashboardParams || {};
		}
	}
);
});

define('syracuse-tablet/html/js/controllers/homeController',['require','exports','module','syracuse-tablet/html/js/controllers/sdataController','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {

var Base = require("syracuse-tablet/html/js/controllers/sdataController").SdataController;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var modules = require('syracuse-tablet/html/js/common/modules');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');


exports.HomeController = utils.defineClass(
	function HomeController(dataset, page) {
		this.page = page;
		Base.call(this, dataset);
	},
	Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
		},
		headerFooterToggle: function() {
			var isSmartphone = modules.get("siteLayout").getDeviceType() === "smartphone";
			if (this._header == null || this._header.actionAdapter == null) {
				var panelInfo;
				panelInfo = {
					name: "headerEditHome",
					topIndex: 0,
					selector: "header",
					$type: "application/x-panel-header-edithome"
				}
				this._header = this.page.attachedControlsMgr.createAddtionalControl(panelInfo, {});
			}
			if (this._footer == null || this._footer.actionAdapter == null) {
				if (isSmartphone) {
					panelInfo = {
						name: "footerEditHome",
						bottomIndex: 0,
						selector: "footer",
						$type: "application/x-panel-footer-edithome-smartphone"
					};
				} else {
					panelInfo = {
						name: "footerEditHome",
						bottomIndex: 0,
						selector: "footer",
						$type: "application/x-panel-footer-edithome-tablet"
					};
				}
				this._footer = this.page.attachedControlsMgr.createAddtionalControl(panelInfo, {});
			}

			this.page.attachedControlsMgr.toggleControls("headerEditHome", "header");
			this.page.attachedControlsMgr.toggleControls("footerEditHome", "footer");
			this.page.computeLayout();
		},
		isActionHidden: function(action) {
			return (action === "myDashboard" && this.page.isPersonal());
		},
		factoryId: function() {
			var app = modules.get("appController").App;
			return app._currentUserProfile.securityProfile.factoryId
		},
		showMyTemplates: function() {
			var factoryId = this.factoryId();
			return factoryId != null && factoryId != "";
		},
		toggleConfig: function(saveContext) {
			if (saveContext) {
				this.saveContext();
			} else {
				this.restoreContext();
			}
			if (this.configActive) { // config already enabled
				this.page._disabledConfig()
			} else {
				this.page._enabledConfig()
			}
		},
		disabledConfig: function() {
			this.headerFooterToggle();
			this.configActive = false;
		},
		enabledConfig: function(forceShow) {
			this.headerFooterToggle(forceShow);
			this.configActive = true;
		},
		isConfigActive: function() {
			return this.configActive;
		},
		rolesChange: function() {
			notifications.publish(["sm.dashboard.roles.change"]);
			this.setDirty(true)
		},
		dashboardDescriptionChange: function(newDescription) {
			this.saveContext();
			this.page.pageData.meta.description = newDescription;
			this.setDirty(true);
		},
		setDirty: function(dirty) {
			this._dirty = dirty;
			notifications.publish(["sm.dashboard.state.change"], dirty)
		},
		isDirty: function() {
			return this._dirty;
		},
		saveContext: function() {
			this._article = this._article || $.extend(true, {}, this.page.pageData.page.$article);
			this._meta = this._meta || $.extend(true, {}, this.page.pageData.meta);
		},
		restoreContext: function() {
			this.page.pageData.page.$article = $.extend(true, {}, this._article || this.page.pageData.page.$article)
			this.page.pageData.meta = $.extend(true, {}, this._meta || this.page.pageData.meta)
			this.cleanContext();
		},
		cleanContext: function() {
			this._article = null;
			this._meta = null;
		}
	}
);
});

define('syracuse-tablet/html/js/ui/modals/modalChooseApps',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="form-group s-m-scroll-element"> \
					<div class="list-group">\
						{{#each appList}} \
							<a draggable="false" href="#" class="list-group-item" data-action="clickApp" data-params="{{applicationName}}">\
								<h4 class="list-group-item-heading">{{title}}</h4>\
								<p class="list-group-item-text">{{description}}</p>\
							</a>\
						{{/each}} \
					</div> \
				</div> \
			</div>',
	footer: ''
};

var _Klass = utils.defineClass(
	function ModalChooseApps(appList) {
		var self = this;
		modalDialog.ModalBase.call(self);
		// Init params
		self.appList = [];
		appList.forEach(function(a) {
			self.appList.push(a);
		});

		// Result
		self.selectedApps = {};
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "half_right";
			} else {
				displayFlags.modalClass = "full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			return {
				label_validate: locale.text("welcome.select.app.add"),
				label_cancel: locale.text("welcome.select.app.cancel"),
				title: locale.text("welcome.select.app.title"),
				appList: self.appList
			};
		},

		// could be removed, result is set in _onAction
		_onValidate: function() {

		},
		_onCancel: function() {
			var self = this;
			self.selectedApps = {};
		},

		_onAction: function(action, param) {
			var self = this;
			if (action === "clickApp") {
				var $$app = self.$$elmt.find('[data-params="' + param + '"]');
				if (self.selectedApps[param]) {
					$$app.removeClass("active");
					delete self.selectedApps[param];
				} else {
					$$app.addClass("active");
					self.selectedApps[param] = self._appForName(param);
				}
			}
			// dont close on actions
			return false;
		},
		_appForName: function(appName) {
			var self = this;
			var match;
			self.appList.some(function(app) {
				if (app.applicationName === appName) {
					match = app;
					return true;
				}
			});

			return match;
		},
		_getResult: function() {
			var self = this;
			return Object.keys(self.selectedApps).map(function(key) {
				return self.selectedApps[key];
			});
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalChooseDashboardGroup',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="form-group s-m-scroll-element"> \
					<div class="list-group">\
						{{#each groups}} \
							<a draggable="false" href="#" class="list-group-item" data-action="clickGroup" data-params="{{id}}">\
								<h4 class="list-group-item-heading">{{title}}</h4>\
							</a>\
						{{/each}} \
					</div> \
				</div> \
			</div>',
	footer: ''
};

var _Klass = utils.defineClass(
	function ModalChooseDashboardGroup(groups) {
		var self = this;
		modalDialog.ModalBase.call(self);
		groups = groups || []
			// Init params
		self.groups = [];
		groups.forEach(function(group) {
			self.groups.push({
				"title": group.title,
				"id": group.id,
			});
		});

		// Result
		self.selectedGroup = {};
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "half_right";
			} else {
				displayFlags.modalClass = "full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			return {
				title: locale.text("welcome.move.tile.title"),
				groups: self.groups
			};
		},
		_onCancel: function() {
			var self = this;
			self.selectedgroup = null;
		},

		_onAction: function(action, param) {
			var self = this;
			if (action === "clickGroup") {
				self.selectedgroup = param;
			}
			// close on actions
			return true;
		},

		_getResult: function() {
			var self = this;
			return self.selectedgroup;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalConfigTile',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/authoring/authoringProperties'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var authoringProperties = require('syracuse-tablet/html/js/authoring/authoringProperties');

var _templateAll = {
	header: '\
		<buttons class="pull-right"> \
			<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
			<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
		</buttons> \
		<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="form-group s-m-scroll-element"> \
					<label>{{lab_title}}</label> \
					<div>{{tileTitle}}</div>\
					<label>{{lab_color}}</label> \
					<div class="s-m-list-colors">\
						{{#each colors}} \
							<a draggable="false" href="#" {{#if active}}class="active"{{/if}} data-action="clickColor" data-params="{{value}}">\
								<div class="s-m-bg s-m-color-{{value}}"> \
								</div> \
							</a>\
						{{/each}} \
					</div> \
					<label>{{lab_size}}</label> \
					<div class="s-m-list-sizes">\
						{{#each sizes}} \
							<a draggable="false" href="#" {{#if active}}class="active"{{/if}} data-action="clickSize" data-params="{{value}}">{{label}}</a>\
						{{/each}} \
					</div> \
					<label>{{lab_icon}}</label> \
					<div class="s-m-list-icons">\
						{{#each icons}} \
							<a draggable="false" href="#" {{#if active}}class="active"{{/if}} data-action="clickIcon" data-params="{{value}}"> \
								<i class="{{label}}"/> \
							</a>\
						{{/each}} \
					</div> \
					<div style="width:100%; display: inline-block;"></div> \
				</div> \
			</div>',

	footer: '',
};

/*
 * 
 * {
 * 	color:"darkgrey",
 * 	icon:"s-m-sales-documents",
 * 	size:"medium",
 * 	title:"My Sales documents", -> read only
 *  ctrlTile -> pass through
 *  gadgetId -> pass through
 * }
 */
var _Klass = utils.defineClass(
	function ModalConfigTile(tile) {
		var self = this;
		modalDialog.ModalBase.call(self);

		// Init params
		self.tile = tile;
		// Result
		self.result = null;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "config-tile half_right";
			} else {
				displayFlags.modalClass = "config-tile full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			authoringProperties.initProperties();

			var properties = authoringProperties.getAllProperties();
			var data = {
				label_validate: locale.text("welcome.tile.cfg.ok"),
				label_cancel: locale.text("welcome.tile.cfg.cancel"),
				title: locale.text("welcome.tile.cfg.title"),

				lab_title: locale.text("welcome.tile.cfg.lab_title"),
				lab_color: locale.text("welcome.tile.cfg.lab_color"),
				lab_size: locale.text("welcome.tile.cfg.lab_size"),
				lab_icon: locale.text("welcome.tile.cfg.lab_icon")
			};

			data.colors = properties.tileColor.values.map(function(e) {
				return {
					active: self.tile.color === e.value,
					value: e.value,
					label: e.label
				};
			});

			data.sizes = properties.tileSize.values.map(function(e) {
				return {
					active: self.tile.size === e.value,
					value: e.value,
					label: e.label
				};
			});

			data.icons = fontUtils.getTileIconList().map(function(e) {
				var cls = fontUtils.getIconByName(e);
				return {
					active: self.tile.icon === e,
					value: e,
					label: cls
				};
			});

			data.tileTitle = self.tile.title;
			return data;
		},

		_onValidate: function() {
			var self = this;
			var $$selected = self.$$elmt.find('a.active');
			var i;

			var tile = $.extend(true, {}, self.tile);
			for (i = 0; i < $$selected.length; i++) {
				var action = $($$selected[i]).attr("data-action");
				var param = $($$selected[i]).attr("data-params");
				switch (action) {
					case "clickColor":
						tile.color = param;
						break;
					case "clickSize":
						tile.size = param;
						break;
					case "clickIcon":
						tile.icon = param;
						break;
				}
			}
			self.result = tile;
		},
		_onCancel: function() {
			var self = this;
			self.result = null;
		},

		_onAction: function(action, param) {
			var self = this;
			switch (action) {
				case "clickColor":
				case "clickSize":
				case "clickIcon":
					var $$old = self.$$elmt.find('a.active[data-action="' + action + '"]');
					var $$new = self.$$elmt.find('a[data-action="' + action + '"][data-params="' + param + '"]');
					$$old.removeClass("active");
					$$new.addClass("active");
					break;
			}
			// dont close on actions
			return false;
		},

		_getResult: function() {
			var self = this;
			return self.result;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalChooseWelcomeDashboard',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="form-group s-m-scroll-element"> \
					<div class="list-group">\
						{{#each views}} \
							<a draggable="false" href="#" class="list-group-item  {{selected}}" data-action="clickView" data-params="{{uuid}}">\
								<h4 class="list-group-item-heading">{{description}}</h4>\
								<p class="list-group-item-text">{{factoryOwner}}</p>\
							</a>\
						{{/each}} \
					</div> \
				</div> \
			</div>',
	footer: '{{#if createLabel}}\
			<button type="button" class="btn btn-default" data-action="createTemplate"> {{createLabel}}</button>\
			{{/if}}'
};

var _Klass = utils.defineClass(
	function ModalChooseWelcomeDashboard(opts) {
		var self = this;
		modalDialog.ModalBase.call(self);
		// Init params
		self.views = [];
		self.title = opts.title;
		self.result = null;
		if (opts.showCreateTemplate) {
			self.createLabel = locale.text("dashboard.welcome.create.template")
		}
		opts.views.forEach(function(view) {
			self.views.push({
				"description": view.$description,
				"personal": view.$isPersonal,
				"selected": (view.$selected ? "active" : ""),
				"uuid": view.$uuid,
				"factoryOwner": view.$factoryOwner,
			});
		});
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "half_right";
			} else {
				displayFlags.modalClass = "full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			return {
				title: self.title,
				views: self.views,
				createLabel: self.createLabel
			};
		},
		_onCancel: function() {
			var self = this;
			self.result = null
		},

		_onAction: function(action, param) {
			var self = this;
			if (action === "clickView") {
				self.result = {
					selectedView: param,
				}
			}
			if (action === "createTemplate") {
				self.result = {
					selectedView: null
				}
			}
			return true;
		},

		_getResult: function() {
			var self = this;
			return self.result;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalChooseRoles',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="form-group s-m-scroll-element"> \
					<div class="list-group">\
						{{#each roleList}} \
							<a draggable="false" href="#" class="list-group-item {{selected}}" data-action="clickRole" data-params="{{uuid}}">\
								<h4 class="list-group-item-heading">{{code}}</h4>\
								<p class="list-group-item-text">{{description}}</p>\
							</a>\
						{{/each}} \
					</div> \
				</div> \
			</div>',
	footer: ''
};

var _Klass = utils.defineClass(
	function ModalChoosRoles(roleList) {
		var self = this;
		modalDialog.ModalBase.call(self);
		// Init params
		self.roleList = [];
		self.rolesSelected = {}; //initial roles selected
		roleList.forEach(function(role) {
			self.roleList.push({
				"code": role.$code,
				"description": role.$description,
				"uuid": role.$uuid,
				"selected": role.$selected
			});
			if (role.$selected) {
				self.rolesSelected[role.$uuid] = true
			}
		});
		// Result
		self.selectedRoles = $.extend(true, {}, self.rolesSelected);
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "half_right";
			} else {
				displayFlags.modalClass = "full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			return {
				title: locale.text("welcome.select.roles.title"),
				roleList: self.roleList
			};
		},

		// could be removed, result is set in _onAction
		_onValidate: function() {

		},
		_onCancel: function() {
			var self = this;
			self.selectedRoles = $.extend(true, {}, self.rolesSelected);
		},

		_onAction: function(action, param) {
			var self = this;
			if (action === "clickRole") {
				var $$app = self.$$elmt.find('[data-params="' + param + '"]');
				if (self.selectedRoles[param]) {
					$$app.removeClass("active");
					delete self.selectedRoles[param];
				} else {
					$$app.addClass("active");
					self.selectedRoles[param] = true;
				}
			}
			// dont close on actions
			return false;
		},

		_getResult: function() {
			var self = this;
			var change = self._compare(self.selectedRoles, self.rolesSelected);
			return {
				"change": change,
				"selectedRoles": Object.keys(self.selectedRoles)
			};
		},
		_compare: function(roles1, roles2) {
			roles1 = roles1 || {};
			roles2 = roles2 || {};
			for (var prop in roles1) {
				if (!roles2[prop]) return true;
			};
			for (var prop in roles2) {
				if (!roles1[prop]) return true;
			}
			return false;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/pages/sdata/pageHome',['require','exports','module','syracuse-tablet/html/js/pages/sdata/pageSdataDashboard','syracuse-tablet/html/js/pages/sdata/pageSdata','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/controllers/homeController','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/sdata/wpHelpers','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/sdata/cache/metaDataCache','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/ui/modals/modalChooseApps','syracuse-tablet/html/js/ui/modals/modalChooseDashboardGroup','syracuse-tablet/html/js/ui/modals/modalConfigTile','syracuse-tablet/html/js/ui/modals/modalConfirm','syracuse-tablet/html/js/ui/modals/modalChooseWelcomeDashboard','syracuse-tablet/html/js/ui/modals/modalChooseRoles','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/pages/sdata/pageSdataDashboard').Page;
var BaseSdata = require('syracuse-tablet/html/js/pages/sdata/pageSdata').Page;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var HomeController = require("syracuse-tablet/html/js/controllers/homeController").HomeController;
var native = require('syracuse-tablet/html/js/helpers/native/native');
var wpHelpers = require('syracuse-tablet/html/js/sdata/wpHelpers');
var modules = require('syracuse-tablet/html/js/common/modules');
var metaDataCache = require('syracuse-tablet/html/js/sdata/cache/metaDataCache');
var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');

var ModalChooseApps = require('syracuse-tablet/html/js/ui/modals/modalChooseApps').Modal;
var ModalChooseDashboardGroup = require('syracuse-tablet/html/js/ui/modals/modalChooseDashboardGroup').Modal;
var ModalConfigTile = require('syracuse-tablet/html/js/ui/modals/modalConfigTile').Modal;
var ModalConfirm = require('syracuse-tablet/html/js/ui/modals/modalConfirm').Modal;
var ModalChooseWelcomeDashboard = require('syracuse-tablet/html/js/ui/modals/modalChooseWelcomeDashboard').Modal;
var ModalChooseRoles = require('syracuse-tablet/html/js/ui/modals/modalChooseRoles').Modal;
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

/**
 *
 */
exports.Page = utils.defineClass(
	function PageHome(pageData, options) {
		Base.call(this, pageData, options);
		this.actionAdapter.showDesignPage = false;
		this.actionAdapter.showPageShare = false;
		this.actionAdapter.showPinPage = false;
		this.actionAdapter.showHome = false;
		this.actionAdapter.showPageConfig = true;
		this.actionAdapter.showMyTemplates = this.controller.showMyTemplates();
		this.actionAdapter.showMyDashboard = true;;
		this.nativeVoiceCommands = native.getModule("voiceCommands");
		notifications.subscribe(this, ["sm.dashboard.description.change"]);

	},
	Base, {
		destroy: function() {
			notifications.unsubscribe(this, ["sm.dashboard.description.change"]);
			Base.prototype.destroy.call(this);
		},
		getPageTitle: function() {
			return this.isPersonal() ? locale.text("global.pageTitle.home") : this.pageData.meta.description;
		},
		isRootPage: function() {
			return true;
		},
		isPersonal: function() {
			return this.pageData.isPersonal;
		},
		roles: function() {
			return this.pageData.page.$roles;
		},
		_ensureController: function() {
			this.controller = new HomeController(this.pageData.dataset, this);
			// Will raise notifications or do confirmations
			this.controller.setUIAdapter(this);
		},

		afterRender: function() {
			Base.prototype.afterRender.call(this);
			this.updateVoiceCommands();

		},

		updateVoiceCommands: function() {
			var self = this;
			if (self.nativeVoiceCommands) {
				self.getVoiceCommands().then(function(commands) {
					self.nativeVoiceCommands.updateVoiceCommands(commands);
				});
			}
		},
		_actPageConfig: function() {
			this.controller.toggleConfig(true);
			this._refresh();
		},
		_actMyTemplates: function() {
			var self = this;
			var views = [];
			var currentViews = self.pageData.page.$views || [];
			currentViews.forEach(function(view) {
				if (view.$factoryOwner && view.$factoryOwner === self.controller.factoryId()) {
					views.push(view)
				}
			});
			var opts = {
				showCreateTemplate: true,
				views: views
			}
			var modal = new ModalChooseWelcomeDashboard(opts);
			modal.show()
				.then(function(result) {
					if (result) {
						if (result.selectedView) { // uuid template
							var opts = {
								uuid: result.selectedView
							};
							modules.get("navHelper").gotoUrl("html://home", null, opts);
						} else {
							var article = {
								"$layoutType": "hub",
								"$items": [{
									$layoutType: "hubgroup",
									$title: locale.text("welcome.newgroup")
								}]
							};
							self.pageData.page.$article = article;
							self.pageData.meta.uuid = null;
							self.pageData.meta.description = locale.text("dashboard.welcome.create.template");
							_cleanupUnreferenced(self.pageData);
							self.pageData.isPersonal = false
							self._enabledConfig(true)
							self._refresh(true);
						}
					}
				})
		},
		_actMyDashboard: function() {
			modules.get("navHelper").gotoUrl("html://home");
		},
		_enabledConfig: function(forceShow) {
			this.controller.enabledConfig(forceShow)
			var $$tiles = $(".s-m-tile", this.$$elmt);
			$$tiles.addClass("s-m-tile-edit")
		},
		_disabledConfig: function() {
			this.controller.disabledConfig();
			$(".s-m-tile-edit", this.$$elmt).removeClass("s-m-tile-edit");
		},
		/**
		 * List of voice commands that can be called by user
		 * will be stored in native api and open the called page if the title matches
		 * 
		 * Promise resolving with:
		 * [
		 * {
		 *   title: "My Customers",
		 *   page: {
		 *     $url: ...
		 *     $method: ...
		 *   }
		 * ]
		 */
		getVoiceCommands: function() {
			return $.smResolve(wpHelpers.welcomePageToCommands(this.pageData));
		},
		getPageDescription: function() {
			return this.pageData.meta.description
		},
		_actCloseDashboardConfig: function() {
			if (this.controller.isDirty()) { // restaure
				var opts = {
					uuid: this.pageData.meta.uuid
				};
				modules.get("navHelper").gotoUrl("html://home", null, opts);
			} else {
				this.controller.toggleConfig();
				this._refresh(false)
			}
		},
		_actSavePersonal: function() {
			var self = this;
			var data = wpHelpers.createWelcomeDashboardFromPageData(this.pageData, true);
			wpHelpers.saveWelcomeDashboard(data).then(function(res) {
				self.controller.cleanContext();
				self.controller.setDirty(false);
				modules.get("modal").notify({
					body: locale.text("dashboard.welcome.saved"),
					severityClass: "success"
				});
			})
		},
		_actSaveTemplate: function() {
			var self = this;
			var data = wpHelpers.createWelcomeDashboardFromPageData(this.pageData, false);
			wpHelpers.saveWelcomeDashboard(data)
				.then(function(res) {
					self.pageData.page.$views = res.$views;
					self.pageData.meta.uuid = res.$uuid;
					self.controller.cleanContext();
					self.controller.setDirty(false);
					modules.get("modal").notify({
						body: locale.text("dashboard.welcome.saved"),
						severityClass: "success"
					});
				})
		},
		_actRoleList: function() {
			var self = this;
			_getAvailableRoles(self.roles())
				.then(function(roles) {
					var modal = new ModalChooseRoles(roles);
					return modal.show();
				})
				.then(function(result) {
					if (result && result.change) {
						self.pageData.page.$roles = []
						result.selectedRoles.forEach(function(role) {
							self.pageData.page.$roles.push({
								$uuid: role
							})
						})
						self.controller.rolesChange()
					}
				})
		},
		_actAddGroup: function() {
			// Called when add group in the footer is clicked
			this.pageData.page.$article.$items.push({
				$items: [],
				$layoutType: "hubgroup",
				$title: locale.text("welcome.newgroup")
			})
			this._refresh(true)
		},
		_refresh: function(dirty) {
			var self = this;
			self.authUpdateLayout(self.pageData.page.$article)
				.then(function() {
					if (self.controller.configActive) { // config already enabled restore it
						self._enabledConfig(true)
					}
					self.controller.setDirty(dirty)
				})
				.fail(function(e) {
					modules.get("modal").error(e);
				});
		},
		renderRootLayout: function() {
			var self = this;
			return self._canAddTile().then(function(canAddTile) {
				self._updateRenderOptions(canAddTile);
				self.rootLayout.set$$container(self.$$contentRoot);
				self.rootLayout.buildHtml();
			})
		},
		_updateRenderOptions: function(canAddTiles) {
			var self = this;
			if (this.controller.isConfigActive()) {
				self.rootLayout.setBuildOptionPerClass("LayoutHubGroup", "showAddTiles", canAddTiles);
				self.rootLayout.setBuildOptionPerClass("LayoutTile", "tileActions", self._defineTileActions());

				var groups = self.rootLayout.children;
				groups.forEach(function(group, idx) {
					var groupActions = [{
						action: "removeGroup",
						className: "remove",
						icon: "fa fa-trash"
					}, {
						action: "moveGroupLeft",
						disabled: idx === 0,
						className: "s-m-move-group" + (idx === 0 ? " disabled" : ""),
						icon: "fa fa-arrow-left"
					}, {
						action: "moveGroupRight",
						disabled: idx === groups.length - 1,
						className: "s-m-move-group",
						icon: "fa fa-arrow-right"
					}];
					group.setBuildOption("groupActions", groupActions);
				});
			} else {
				self.rootLayout.setBuildOptionPerClass("LayoutHubGroup", "showAddTiles", null);
				self.rootLayout.setBuildOptionPerClass("LayoutHubGroup", "groupActions", null);
				self.rootLayout.setBuildOptionPerClass("LayoutTile", "tileActions", null);
			}
		},
		_defineTileActions: function() {
			var tileActions = [];
			if (this._hasMoreThanOneGroup()) {
				tileActions.push({
					action: "changeGroup",
					className: "changegroup",
					icon: "fa fa-sitemap"
				});
			}
			tileActions.push({
				action: "configTile",
				className: "config",
				icon: "fa fa-pencil"
			});
			tileActions.push({
				action: "removeTile",
				className: "remove",
				icon: "fa fa-trash-o"
			});
			return tileActions;
		},
		_hasMoreThanOneGroup: function() {
			return this.pageData.page.$article.$items.length > 1;
		},
		authUpdateLayout: function(article) {
			var self = this;
			return BaseSdata.prototype.authUpdateLayout.call(self, article)
		},

		/*
		 * TILE BTN ACTIONS
		 */
		_actChangeGroup: function(tileId) {
			var self = this;
			var grpIdxDest, grpIdx, tileIdx
			var ctrlTile = this.controller.getControl(tileId);
			var groupId = ctrlTile.parent.id;
			var groups = _getOtherGroups(this.rootLayout, groupId);
			var modal = new ModalChooseDashboardGroup(groups);
			modal.show().then(function(groupIdDest) {
				if (groupIdDest) {
					if (self.rootLayout.children.some(function(group, idx) {
							if (group.id === groupIdDest) {
								grpIdxDest = idx;
								return true;
							}
						})) {
						if (self.rootLayout.children.some(function(group, idx) {
								if (group.id === groupId) {
									grpIdx = idx;
									return true;
								}
							})) {
							if (self.rootLayout.children[grpIdx].children.some(function(tile, idx) {
									if (tile.id === tileId) {
										tileIdx = idx;
										return true;
									}
								})) {
								var article = self.pageData.page.$article;
								article.$items[grpIdxDest].$items = article.$items[grpIdxDest].$items || []
								article.$items[grpIdxDest].$items.push(article.$items[grpIdx].$items.slice(tileIdx, tileIdx + 1)[0]);
								article.$items[grpIdx].$items.splice(tileIdx, 1)
								self._refresh(true);
							};
						};

					}
				}
			});
		},
		_actConfigTile: function(tileId) {
			var self = this;
			var ti = this._getTileInfo(tileId);
			if (ti) {
				var modal = new ModalConfigTile(ti);
				modal.show().then(function(result) {
					if (result) {
						self._setTileInfo(result);
						self._rebuildPageByControls(true);
					}
				})
			}
		},

		_actRemoveTile: function(tileId) {
			this._removeTile(tileId);
		},

		/*
		 * GROUP BTN ACTIONS
		 */

		_actMoveGroupLeft: function(hubGroupId) {
			this._moveGroup(hubGroupId, -1);
		},
		_actMoveGroupRight: function(hubGroupId) {
			this._moveGroup(hubGroupId, 1);
		},
		_actRemoveGroup: function(hubGroupId) {
			var self = this;
			var modal = new ModalConfirm(locale.text("welcome.dashboard.remove.group"), null, true);
			modal.show().then(function(result) {
				if (result === "yes") {
					self._deleteGroup(hubGroupId);
				}
			});
		},

		_actAddHiddenTile: function(hubGroupId) {
			var self = this;
			_getAvailabeNotUsedApps(this.pageData.page.$article, this.pageData.dataset.json)
				.then(function(notUsedApps) {
					var modal = new ModalChooseApps(notUsedApps);
					return modal.show();
				})
				.then(function(result) {
					// result is a list if selected application objects
					if (result && result.length > 0) {
						return self._addAppsToGroup(result, hubGroupId);
					}
				})
				.then(function(tileAdded) {
					self._rebuildPageByControls(tileAdded);
				});
		},
		_addAppsToGroup: function(apps, hubGroupId) {
			var self = this;
			var hubGroupCtrl = self.controller.getControl(hubGroupId);
			if (!hubGroupCtrl) {
				return false;
			}
			var tileAdded = apps.reduce(function(a, b, index, appList) {
				var vignetteUuid = _addVignetteAndGadget(self.pageData.dataset.json, self.pageData.prototype.json, appList[index])
				b = false;
				if (vignetteUuid) {
					b = _bindVignetteToHubGroupCtrl(hubGroupCtrl, vignetteUuid);
				}
				return a || b

			}, false)
			return tileAdded;
		},
		_moveGroup: function(hubGroupId, dir) {
			var self = this;
			var myIdx;
			if (self.rootLayout.children.some(function(group, idx) {
					if (group.id === hubGroupId) {
						myIdx = idx;
						return true;
					}
				})) {
				var newIdx = myIdx + dir;
				if (newIdx >= 0 && newIdx < self.rootLayout.children.length) {
					var article = self.pageData.page.$article;
					var destGrp = article.$items[newIdx];
					article.$items[newIdx] = article.$items[myIdx];
					article.$items[myIdx] = destGrp;
					self._refresh(true);
				}
			}
		},
		// Called by hub group if title canges
		// use to inject title into page main article
		onGroupTitleChanged: function(ctrlHubGroup, uuid, title) {
			this.pageData.page.$article.$localization = this.pageData.page.$article.$localization || {};
			utils.setLocalization(this.pageData.page.$article.$localization, uuid, title);
			this.controller.setDirty(true);
		},
		_removeTile: function(tileId) {
			var self = this;
			var tile = this.controller.getControl(tileId);
			var group = tile.parent;
			var tileIndex = group.getIndexOfChild(tile);
			var hub = group.parent;
			var groupIndex = hub.getIndexOfChild(group);

			var article = self.pageData.page.$article;
			article.$items[groupIndex].$items.splice(tileIndex, 1);
			_cleanupUnreferenced(self.pageData);
			self._refresh(true);
		},
		_deleteGroup: function(hubGroupId) {
			var self = this;
			var myIdx;
			if (self.rootLayout.children.some(function(group, idx) {
					if (group.id === hubGroupId) {
						myIdx = idx;
						return true;
					}
				})) {
				var article = self.pageData.page.$article;
				article.$items.splice(myIdx, 1);
				_cleanupUnreferenced(self.pageData);
				self._refresh(true);
			}
		},
		_getTileInfo: function(tileId) {
			var tileInfo;
			var ctrlTile = this.controller.getControl(tileId);
			var ctrlVignette = ctrlTile && ctrlTile.getChildByIndex(0);
			if (ctrlVignette && ctrlVignette.$bind) {
				var article = ctrlTile.getArticle();
				var gadgetId = this.pageData.dataset.json[ctrlVignette.$bind];
				var gadget = gadgetId && this.pageData.dataset.json.$mobileGadgets[gadgetId];
				tileInfo = {
					icon: gadget && gadget.icon,
					title: gadget && gadget.$title,
					size: article.$size,
					color: article.$bgColor,
					gadgetId: gadgetId,
					ctrlTile: ctrlTile,
					vignetteId: ctrlVignette.$bind
				};
			}
			return tileInfo;
		},
		_setTileInfo: function(tileInfo) {
			var article = tileInfo.ctrlTile.article = tileInfo.ctrlTile.article || {};
			article.$size = tileInfo.size;
			article.$bgColor = tileInfo.color;
			var gadget = this.pageData.dataset.json.$mobileGadgets[tileInfo.gadgetId];
			if (gadget) {
				gadget.icon = tileInfo.icon;
				gadget.title = tileInfo.title;
			}
			var gadget = this.pageData.prototype.json.$properties[tileInfo.vignetteId].$item;
			if (gadget) {
				gadget.icon = tileInfo.icon;
				gadget.title = tileInfo.title;
			}
		},
		_rebuildPageByControls: function(dirty) {
			var self = this;
			var states = [];
			var newArticle = JSON.parse(authHelpers.rebuildArticleByPageStruct(self, states));
			self.pageData.page.$article = newArticle;
			self._refresh(dirty);
		},
		_canAddTile: function() {
			return _getAvailabeNotUsedApps(this.pageData.page.$article, this.pageData.dataset.json).then(function(appsToAdd) {
				return appsToAdd.length > 0
			})
		},
		getPagePublishOptions: function() {
			return {};
		},
		notifDashboardDescriptionChange: function(newDescription) {
			this.controller.dashboardDescriptionChange(newDescription);
		},
	}
);

/**
 * Return list of application objects that are in the global list of available apps but not yet
 * refered to by the given article
 * 
 */
function _getAvailabeNotUsedApps(article, dataset) {
	var boundApps = _getBoundApps(article, dataset);
	return metaDataCache.getApplicationsList()
		.then(function(appList) {
			var notUsedApps = [];
			appList.forEach(function(app) {
				if (boundApps.indexOf(app.applicationName) < 0) {
					notUsedApps.push(app);
				}
			});
			return wpHelpers.filterApps(notUsedApps);
		});
}

function _getAvailableRoles(currentRoles) {
	var activeRoles = {};
	if (currentRoles) {
		activeRoles = currentRoles.reduce(function(roles, current) {
			roles[current.$uuid] = "active";
			return roles;
		}, {});
	};
	return wpHelpers.getListOfRoles()
		.then(function(roles) {
			roles.forEach(function(role) {
				if (activeRoles[role.$uuid]) {
					role.$selected = activeRoles[role.$uuid]
				}
			});
			return roles;
		})
}
/**
 * Return the list of applicationNames that are bound in the current $article of the page
 * 
 */
function _getBoundApps(article, dataset) {
	var boundApps = [];

	function _checkBind($bind) {
		var gadgetId = dataset[$bind];
		var gadget = gadgetId && dataset.$mobileGadgets[gadgetId];
		if (gadget && gadget.$type === "$application") {
			boundApps.push(gadget.applicationName);
		}
	}
	_getAllBinds(article).forEach(function($bind) {
		_checkBind($bind);
	});
	return boundApps;
}

function _getAllBinds(article) {
	var binds = [];

	function _walk(node) {
		if (node.$bind) {
			binds.push(node.$bind);
		}
		if (node.$items) {
			node.$items.forEach(function($item) {
				_walk($item);
			});
		}
	}
	_walk(article);
	return binds;
}
/**
 * Create new tile article and append it to hubgroupcontrol
 */
function _bindVignetteToHubGroupCtrl(hubGroupCtrl, vignetteUuid) {
	var article = hubGroupCtrl.getArticle();

	var tileArticle = {
		$bgColor: "darkgrey",
		$layoutType: "tile",
		$size: "medium"
	};
	var tile = modules.get("ctrlFactory").createControl(hubGroupCtrl.controller, tileArticle, hubGroupCtrl, hubGroupCtrl.page);
	var vignetteArticle = {
		$bind: vignetteUuid
	};
	var vignette = modules.get("ctrlFactory").createControl(tile.controller, vignetteArticle, tile, tile.page);
	return true;
}

function _addVignetteAndGadget(datasetJson, prototypeJson, app) {
	var gadget = {
		$type: "$application",
		$title: app.title,
		applicationName: app.applicationName,
		icon: app.iconName
	};
	var gadgetId = "$welcome_" + app.applicationName + "_GADGET";
	var vignetteId = "$welcome_" + app.applicationName + "_VIGNETTE";

	datasetJson.$mobileGadgets[gadgetId] = gadget;
	datasetJson[vignetteId] = gadgetId;
	if (prototypeJson) {
		prototypeJson.$properties[vignetteId] = {
			$item: gadget,
			$title: app.title,
			$type: "application/x-vignette-link"
		}
	}
	if (datasetJson.$vignettes) {
		datasetJson.$vignettes.push({
			persistentId: vignetteId,
			gadget: {
				$uuid: gadgetId
			}
		});
	}
	return vignetteId;
}

function _getOtherGroups(rootLayout, groupId) {
	var groups = [];
	rootLayout.children.forEach(function(group) {
		if (group.id !== groupId) {
			groups.push({
				title: group.getArticleText("$title"),
				id: group.id
			});
		}
	});
	return groups;
}

/**
 * Remove vignettes and gadgets not referenced by article any more
 * 
 */
function _cleanupUnreferenced(pageData) {
	var binds = _getAllBinds(pageData.page.$article);
	var boundVignettes = [];
	pageData.dataset.json.$vignettes.forEach(function(vignette) {
		if (binds.indexOf(vignette.persistentId) > -1) {
			boundVignettes.push(vignette);
		} else {
			var vid = vignette.persistentId;
			var gid = vignette.gadget.$uuid;
			delete pageData.dataset.json[vid];
			delete pageData.dataset.json.$mobileGadgets[gid];
		}
	})
	pageData.dataset.json.$vignettes = boundVignettes;
}
});

define('syracuse-tablet/html/js/pages/html/pageHtmlBase',['require','exports','module','syracuse-tablet/html/js/pages/pageBase','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/pages/pageBase').Page;

var utils = require('syracuse-tablet/html/js/helpers/utils');


/**
 *
 */
exports.Page = utils.defineClass(
	function PageHtmlBase(pageName, options) {
		Base.call(this, pageName, options);
	},
	Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
		},
		render: function() {},
		afterRender: function() {},

		/**
		 * Return internal page name as title, should be overridden by concrete subclass to return localized title
		 */
		getPageTitle: function() {
			return this.pageName;
		},

		/**
		 * Default html pages do not have attached control (panels, headers or footers)
		 */
		_getDefaultAttachedControls: function() {
			return [];
		},
		scrollAllowed: function() {
			return true;
		}
	}
);
});

define('syracuse-tablet/html/js/pages/html/pageLogin',['require','exports','module','syracuse-tablet/html/js/pages/html/pageHtmlBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/app/settings','syracuse-tablet/html/js/utils/waiting','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/pages/html/pageHtmlBase').Page;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var nativeApp = require('syracuse-tablet/html/js/helpers/native/native').getModule("nativeApp");
var settings = require('syracuse-tablet/html/js/app/settings');

var waiting = require('syracuse-tablet/html/js/utils/waiting');
var modules = require('syracuse-tablet/html/js/common/modules');

var _templates = {
	main: '\
			<div class="s-m-loginform" style="position: relative;">\
				<div class="row s-m-login-info">\
					<div class="col-xs-offset-1 col-xs-10 col-sm-offset-3 col-sm-6 col-md-offset-4 col-md-4 col-lg-offset-4 col-lg-4">\
						<div id="login-reason-id" style="display: none;" class="alert alert-info" role="alert"></div>\
					</div>\
				</div>\
				<div id="s-m-login-online-id" class="row">\
					<div class="col-xs-offset-1 col-xs-10 col-sm-offset-3 col-sm-6 col-md-offset-4 col-md-4 col-lg-offset-4 col-lg-4">\
						<div class="panel panel-default">\
							<div  id="s-m-login-withoutcookie">\
								<div class="s-m-login-header main">\
									<span class="s-m-signin">{{label_signin}}</span>\
									<span class="s-m-brand">{{label_brand}}</span>\
									<span class="s-m-product">{{label_product}}</span>\
								</div>\
								\
								<div class="panel-body s-m-login-body" id="s-m-basic-fields-id">\
									<br>\
									<div class="form-group">\
										<input type="text" autocorrect="off" autocapitalize="off" value="" class="form-control s-m-login-form-input" placeholder="{{label_user}}"	id="login-user">\
									</div>\
									<br>\
									<div class="form-group">\
										<input type="password" autocorrect="off" autocapitalize="off" class="form-control s-m-login-form-input" placeholder="{{label_password}}" id="login-password">\
									</div>\
									<div class="form-group">\
										<center>\
											<label style="font-weight:normal"><input type="checkbox" id="s-m-remember-me-id">{{label_rememberme}}</input></label>\
										</center>\
									</div>\
									<button id="login-login" data-nevent data-naction="loginBasic" type="button" class="btn btn-primary s-m-signin-btn">{{act_login}}</button>\
								</div>\
								<div id="s-m-sageid-fields-id">\
									<div class="s-m-login-header" id="s-m-sageid-header">\
										<span class="s-m-signin">{{sageid_label_header}}</span>\
									</div>\
									<div class="panel-body s-m-login-body" id="s-m-sageid-body">\
										<button id="s-m-sageid-signin" data-nevent data-naction="loginSageId" type="button" class="btn btn-primary s-m-signin-btn">{{sageid_label_signin}}</button>\
									</div>\
								</div>\
								<div id="s-m-external-fields-id">\
									<div class="s-m-login-header" id="s-m-external-header">\
										<span class="s-m-signin">{{label_external}}</span>\
									</div>\
									<div class="panel-body s-m-login-body" id="s-m-external-body">\
										{{#each externals}} \
											<button style="margin-bottom:10px;" data-nevent data-naction="externalSignin" data-params="{{this.href}}" type="button" class="btn btn-primary s-m-signin-btn">{{this.title}}</button>\
										{{/each}} \
									</div>\
								</div> \
								<div id="s-m-login-noauth-id">\
									<div class="form-group">\
										<center>\
											{{no_auth_method}} \
											<br> \
											{{contact_admin}} \
										</center>\
									</div>\
								</div>\
							</div>\
						</div>\
					</div>\
				</div>\
				<div id="s-m-login-offline-id" class="row" style="display: none;">\
					<div class="col-xs-offset-1 col-xs-10 col-sm-offset-3 col-sm-6 col-md-offset-4 col-md-4 col-lg-offset-4 col-lg-4">\
						<div class="panel panel-default">\
							<div class="s-m-login-header"><span class="s-m-signin">{{label_signin}} </span> <span class="s-m-brand">{{label_brand}}</span> <span class="s-m-product">{{label_product}}</span></div>\
							<div class="s-m-login-header" id="s-m-offline-header">\
								<span class="s-m-signin">{{offline_label_header}}</span>\
							</div>\
							<div class="panel-body s-m-login-body" id="s-m-sageid-body">\
								<button id="s-m-offline-signin" data-nevent data-naction="offlinesignin" type="button" class="btn btn-primary s-m-signin-btn"> \
									<div id="s-m-offline-label">{{offline_label_signin_as}}</div> \
									<div id="s-m-offline-user-id"></div> \
								</button>\
							</div>\
						</div>\
					</div>\
				</div>\
				<div id="s-m-login-nooffline-id" class="row" style="display: none;">\
					<div class="col-xs-offset-1 col-xs-10 col-sm-offset-3 col-sm-6 col-md-offset-4 col-md-4 col-lg-offset-4 col-lg-4">\
						<div class="panel panel-default">\
							<div class="s-m-login-header" id="s-m-offline-header">\
									{{offline_notavail}}\
							</div>\
							<div class="panel-body s-m-login-body" id="s-m-sageid-body">\
								<div>{{offline_emptydb}}</div> \
							</div>\
						</div>\
					</div>\
				</div>\
			</div>\
		',
	message: '{{title}}<p>{{message}}</p>{{stack}}'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};


/**
 *
 * Login page takes the following options
 * 
 * options: {
 *   offline: true|false|null // optionally given by caller if known
 *   loginPreset: Name to preset
 *   onLogin: {
 *   
 *     // If a login was ok, the login page will redirect to this page
 *     gotoUrl: {
 *       url:
 *       method:
 *       options:
 *     }
 *   }
 * }
 */
exports.Page = utils.defineClass(
	function PageLogin(pageName, options) {
		options = options || {};
		Base.call(this, pageName, options);
		this._offline = (options.offline === true);
	},
	Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
		},
		getPageTitle: function() {
			return locale.text("global.pageTitle.login");
		},
		isRootPage: function() {
			return true;
		},
		isNoHistory: function() {
			return true;
		},
		render: function() {
			var self = this;
			// This adds login background image to the page
			this.$$elmt.addClass("login");
			return this._readLabels()
				.then(function() {
					var ctx = $.extend(true, {}, self._labels);
					self.$$contentRoot.append($(_getHtml("main", ctx)));
				});
		},
		afterRender: function() {
			var self = this;

			$('#s-m-basic-fields-id input', self.$$elmt).on('keyup', jsutils.bindFn(self._onEnterPressed, self));

			if (this.options.loginPreset) {
				$('#s-m-basic-fields-id input', self.$$elmt).val(this.options.loginPreset);
			}

			return $.smResolve()
				.then(function() {
					return self._showSupportedMethods();
				});
		},

		_onEnterPressed: function(e) {
			var self = this;
			if (e.which == 13 || e.keyCode == 13) {
				e.preventDefault();
				// This will check mandatory fields and set focus accordingly
				self._actLoginBasic();
			}
		},

		/**
		 * Do basic authentication login - input validation
		 */
		_actLoginBasic: function() {
			var self = this;
			var usr = self.$$elmt.find("#login-user").val();
			var pwd = self.$$elmt.find("#login-password").val();

			// User mandatory, so focus there
			if (usr == null || usr.length < 1) {
				self.$$elmt.find("#login-usr").focus();
				return;
			}
			// Password mandatory, so focus there
			if (pwd == null || pwd.length < 1) {
				self.$$elmt.find("#login-password").focus();
				return;
			}

			var rememberMe = $("#s-m-remember-me-id").is(':checked');
			if (nativeApp) {
				rememberMe = true;
			}

			this._loginBasic(usr, pwd, rememberMe);
		},

		/**
		 * Do basic authentication login - do login process
		 */
		_loginBasic: function(usr, pwd, rememberMe) {
			var self = this;
			var session = modules.get("session");

			var loginTask =
				$.smResolve()
				.then(function() {
					return settings.setLoginRememberMe(rememberMe)
				})
				.then(function() {
					return session.loginBasic(usr, pwd, rememberMe);
				})
				.fail(function(result) {
					var data = result && result.data;
					var $diag = data && data.$diagnoses && data.$diagnoses[0];
					$diag = $diag || (result && result.$diagnoses && result.$diagnoses[0]);
					var $message = $diag && $diag.$message;
					$message = $message || locale.text("login.failed");
					self._showMessage($message);

					if (result && result.offline) {
						self._offline = true;
					}

					return self._showSupportedMethods();
				});

			waiting.waitModal(loginTask)
				.then(function() {
					return self._onBasicLoginOk()
						.fail(function(error) {
							modules.get("modal").error(error).always(function() {
								modules.get("navHelper").gotoUrl("html://home");
							})
						});
				});
		},

		/**
		 * Start sage id login
		 * Here just the redirect starts.
		 * When authenticated, sage id will redirect back causing a reload of the app
		 * So the login page will not be shown again since there will be a session
		 */
		_actLoginSageId: function() {
			var session = modules.get("session");
			session.loginSageId();
		},
		_actExternalSignin: function(param) {
			window.location.href = param;
		},
		_actOfflinesignin: function() {
			var self = this;
			return $.smResolve()
				.then(function() {
					return self._onOfflineLoginOk();
				})
				.fail(function(error) {
					modules.get("modal").error(error);
				});
		},

		_readLabels: function() {
			var self = this;
			var product = locale.getProductLabels();
			return self._ensureExternalProviders()
				.then(function() {
					self._labels = {
						"label_user": locale.text("login.label.user"),
						"label_password": locale.text("login.label.password"),
						"act_login": locale.text("login.label.signinaction"),
						"label_signin": locale.text("login.label.signin"),
						"label_brand": product.brand,
						"label_product": product.product,
						"sageid_label_header": locale.text("sageid.label.header"),
						"sageid_label_signin": locale.text("sageid.label.signin"),
						"offline_label_header": locale.text("login.label.offline"),
						"offline_label_signin_as": locale.text("login.label.login_as"),
						"offline_notavail": locale.text("login.offline.notavail"),
						"offline_emptydb": locale.text("login.offline.emptydb"),
						"label_forgetme": locale.text("login.forgetme"),
						"label_changeuser": locale.text("login.changeuser"),
						"label_rememberme": locale.text("login.rememberme"),
						"no_auth_method": locale.text("login.label.noauth"),
						"contact_admin": locale.text("contact.admin"),
						"label_external": locale.text("authentication.external.accs"),
						"externals": self._externalProviders
					};
				});
		},

		/**
		 * Adapt UI to online/offline and auth methods supported
		 */
		_showSupportedMethods: function() {
			var self = this;
			var session = modules.get("session");

			self._ensureAuthMethods()
				.then(function() {
					return self._showRememberMe();
				})
				.then(function() {
					if (self._offline) {
						return self._showOfflineMethods();
					} else {
						return self._showOnlineMethods();
					}
				});
		},

		_showOnlineMethods: function() {
			var self = this;
			var methods = {
				"sage-id": "s-m-sageid-fields-id",
				"basic": "s-m-basic-fields-id",
				"$$externals": "s-m-external-fields-id",
			};
			var count = 0;

			$("#s-m-login-online-id").show();
			$("#s-m-login-offline-id").hide();
			return $.smResolve()
				.then(function() {
					return self._ensureAuthMethods();
				})
				.then(function() {
					return self._ensureExternalProviders();
				})
				.then(function() {
					Object.keys(methods).forEach(function(method) {
						var id = methods[method];
						var $$block = $("#" + id);
						if (self._authMethods.$supported.indexOf(method) > -1) {
							count = count + 1;
							$$block.show();
						} else {
							$$block.hide();
						}
					})
				})
				.then(function() {
					if (count < 1) {
						$("#s-m-login-noauth-id").show();
					} else {
						$("#s-m-login-noauth-id").hide();
					}
				});
		},
		_ensureAuthMethods: function() {
			var self = this;
			if (self._authMethods) {
				return $.smResolve();
			}
			var session = modules.get("session");

			var def = $.Deferred();
			session.getAuthMethods()
				.then(function(list) {
					self._authMethods = list;
					def.resolve();
				})
				.fail(function(result) {
					self._authMethods = {
						$supported: []
					}
					if (result && result.offline) {
						self._offline = true;
						def.resolve();
					} else {
						def.reject(result);
					}
				})

			return def.promise();
		},
		_ensureExternalProviders: function() {
			var self = this;
			if (self._externalProviders) {
				return $.smResolve();
			}
			return self._ensureAuthMethods()
				.then(function() {
					self._externalProviders = [];
					if (self._authMethods.$supported.indexOf("saml2") > -1) {
						Array.prototype.push.apply(self._externalProviders, self._authMethods.$saml2 || []);
					}
					if (self._authMethods.$supported.indexOf("oauth2") > -1) {
						Array.prototype.push.apply(self._externalProviders, self._authMethods.$oauth2 || []);
					}
					if (self._externalProviders.length > 0) {
						self._authMethods.$supported.push("$$externals");
					}
				});
		},
		_showOfflineMethods: function() {
			var self = this;
			$("#s-m-login-online-id").hide();
			return $.smResolve()
				.then(function() {
					return settings.getLastUsedUserProfile();
				})
				.then(function(profile) {
					self._offlineProfile = profile;
					if (!profile) {
						$("#s-m-login-offline-id").hide();
						$("#s-m-login-nooffline-id").show();

					} else {
						$("#s-m-login-offline-id").show();
						$("#s-m-login-nooffline-id").hide();
						$("#s-m-offline-user-id").text((self._offlineProfile.user.firstName || "") + " " + (self._offlineProfile.user.lastName || ""));
					}
				});
		},

		_showRememberMe: function() {
			return $.smResolve()
				.then(function() {
					return settings.getLoginRememberMe();
				})
				.then(function(rememberMe) {
					var $$check = $("#s-m-remember-me-id");
					if (nativeApp) {
						rememberMe = true;
						$$check.closest(".form-group").hide();
					} else {
						$$check.closest(".form-group").show();
					}
					$$check.attr('checked', rememberMe);
				});
		},

		/**
		 * Basic authentication succeeded, preserve profile for next time and go to target page
		 */
		_onBasicLoginOk: function() {
			var self = this;
			var session = modules.get("session");
			return $.smResolve()
				.then(function() {
					return session.getCurrentUserProfile();
				})
				.then(function(profile) {
					return modules.get("appController").App.setUserProfile(profile)
						.then(function() {
							return profile;
						});
				})
				.then(function(profile) {
					return session.storeUserProfile(profile);
				})
				.then(function() {
					return modules.get("appController").App.initApplicationsList();
				})
				.then(function() {
					return self._openTargetPage();
				});
		},

		/**
		 * Offline authentication succeeded, go to target page
		 */
		_onOfflineLoginOk: function() {
			var self = this;
			return $.smResolve()
				.then(function() {
					return modules.get("appController").App.setUserProfile(self._offlineProfile)
				})
				.then(function() {
					return self._openTargetPage();
				});
		},

		/**
		 * After login, go to home page or to page given by the caller of the login page
		 */
		_openTargetPage: function() {
			var target = this.options && this.options.onLogin && this.options.onLogin.gotoUrl;
			if (!target) {
				target = {
					url: "html://home"
				};
			}

			return modules.get("navHelper").gotoUrl(target.url, target.method, target.options, target.loadOptions);
		},

		/**
		 * Show top diagnoses
		 */
		_showMessage: function(message) {
			var html = Handlebars.compile("{{message}}")({
				message: message
			});
			$("#login-reason-id").empty();
			$("#login-reason-id").html(html)
			$("#login-reason-id").show();

		},

		/**
		 * Hide top diagnoses
		 */
		_hideMessage: function() {
			$("#login-reason-id").hide();
		}
	}
);
});

define('syracuse-tablet/html/js/pages/html/pageLogout',['require','exports','module','syracuse-tablet/html/js/pages/html/pageHtmlBase','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/pages/html/pageHtmlBase').Page;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var nativeApp = require('syracuse-tablet/html/js/helpers/native/native').getModule("nativeApp");
var modules = require('syracuse-tablet/html/js/common/modules');

var _templates = {
	main: '\
			<div class="s-m-loginform" style="position: relative;">\
				<div class="row s-m-login-info">\
				</div>\
				<div id="s-m-login-online-id" class="row">\
					<div class="col-xs-offset-1 col-xs-10 col-sm-offset-3 col-sm-6 col-md-offset-4 col-md-4 col-lg-offset-4 col-lg-4">\
						<div class="panel panel-default">\
							<div>\
								<div class="s-m-login-header main">\
									<span class="s-m-signin">{{label_signin}}</span>\
									<span class="s-m-brand">{{label_brand}}</span>\
									<span class="s-m-product">{{label_product}}</span>\
								</div>\
								<div class="panel-body s-m-login-body">\
									<center>\
										<div>{{label_logged_out}}</div>\
									</center>\
								</div>\
								<div class="panel-body s-m-login-body" id="s-m-relogin-id" style="display: none;">\
									<button id="s-m-offline-signin" data-nevent data-naction="relogin" \
										type="button" class="btn btn-primary s-m-signin-btn"> \
										<div>{{label_login_as}}</div> \
										<div>{{label_last_user}}</div> \
									</button>\
								</div>\
								<div class="panel-body s-m-login-body" id="s-m-login-changeuser">\
									<button data-nevent data-naction="changeuser" type="button" class="btn btn-primary s-m-signin-btn">{{label_changeuser}}</button>\
								</div>\
								<div class="panel-body s-m-login-body" id="s-m-login-forgetme-id">\
									<button data-nevent data-naction="forgetme" type="button" class="btn btn-primary s-m-signin-btn">{{label_forgetme}}</button>\
								</div>\
							</div>\
						</div>\
					</div>\
				</div>\
			</div>\
		',
	message: '{{title}}<p>{{message}}</p>{{stack}}'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};


/**
 *
 */
exports.Page = utils.defineClass(
	function PageLogout(pageName, options) {
		options = options || {};
		Base.call(this, pageName, options);
	},
	Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
		},
		getPageTitle: function() {
			return locale.text("global.pageTitle.logout");
		},
		isRootPage: function() {
			return true;
		},
		isNoHistory: function() {
			return true;
		},
		render: function() {
			// This adds login background image to the page
			this.$$elmt.addClass("login");
			this._readLabels();
			var ctx = $.extend(true, {}, this._labels);

			this._userProfile = modules.get("appController").App.getCurrentUserProfile();
			if (this._userProfile) {
				this._authMethod = this._userProfile.user.authentication;
				this._lastUsername = (this._userProfile.user.firstName || "") + " " + (this._userProfile.user.lastName || "");
				this._lastLogin = this._userProfile.user.login;
				ctx.label_last_user = this._lastUsername;
			}
			this.$$contentRoot.append($(_getHtml("main", ctx)));
		},

		_readLabels: function() {
			var product = locale.getProductLabels();
			this._labels = {
				"label_brand": product.brand,
				"label_product": product.product,
				"label_forgetme": locale.text("login.forgetme"),
				"label_changeuser": locale.text("login.changeuser"),
				"label_logged_out": locale.text("logout.logged.out"),
				"label_login_as": locale.text("login.label.login_as")
			};
		},

		afterRender: function() {
			var self = this;
			if (this._userProfile) {
				$("#s-m-relogin-id").show();
			}
			return $.smResolve()
				.then(function() {
					var session = modules.get("session");
					return session.getReconnectToken();
				})
				.then(function(token, login, sid, loginCookieName, sidCookieName) {
					$("#s-m-login-forgetme-id").toggle(token != null);
				});
		},

		_actRelogin: function() {
			var self = this;
			if (this._authMethod === "sage-id") {
				var session = modules.get("session");
				session.loginSageId();
			} else if (["basic", "db", "ldap"].indexOf(this._authMethod) > -1) {
				// Method that is handled by syracuse/http basic authentication with no redirects
				self._gotoLogin({
					"loginPreset": this._lastLogin
				});
			} else {
				this._actChangeuser();
			}
		},
		_actChangeuser: function() {
			this._gotoLogin();
		},
		_actForgetme: function() {
			var self = this;
			var session = modules.get("session");
			session.forgetMe()
				.always(function() {
					self._gotoLogin();
				});
		},
		_gotoLogin: function(options) {
			return modules.get("navHelper").gotoUrl("html://login", null, options);
		},
	}
);
});

define('syracuse-tablet/html/js/pages/sdata/pageSdataChildPage',['require','exports','module','syracuse-tablet/html/js/pages/sdata/pageSdata','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/controls/articleParser','syracuse-tablet/html/js/controllers/sdataController','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/pages/sdata/pageSdata').Page;
var modules = require('syracuse-tablet/html/js/common/modules');
var articleParser = require("syracuse-tablet/html/js/controls/articleParser");
var SdataController = require("syracuse-tablet/html/js/controllers/sdataController").SdataController;
var utils = require('syracuse-tablet/html/js/helpers/utils');

/**
 * 
 */
exports.Page = utils.defineClass(
	function PageSdataChildPage(pageData, options) {
		this.options = options || {};
		this.parentController = modules.get("controller").findController(options.childContext.controllerId);
		pageData = this._createPageData(pageData);
		Base.call(this, pageData, options);
		this.actionAdapter.showPinPage = false;
		this.actionAdapter.showHome = false;
	},
	Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
		},
		_createPageData: function(pageData) {
			var dataset = this.parentController.dataset;
			var childPageData = $.extend(true, {}, pageData);
			childPageData.dataset = dataset;
			childPageData.prototype = dataset.prototype;
			childPageData.page.$article = this._getArticle(dataset.prototype);
			return childPageData;
		},
		_getArticle: function(prototype) {
			return articleParser.createDefaultArticle(prototype);
		},
		_ensureController: function() {
			this.controller = new SdataController(this.pageData.dataset, this.parentController, this.pageData.isWorkingCopy);
			// Will raise notifications or do confirmations
			this.controller.setUIAdapter(this);
		},
		// Child pages have no name, they get and save their article with the parent
		getAuthoringName: function() {
			return "$$child";
		},
		/**
		 * Returns the root page
		 */
		getRootPage: function() {
			return this.controller.root.uiAdapter;
		}
	}
);
});

define('syracuse-tablet/html/js/pages/sdata/pageSdataRowDetail',['require','exports','module','syracuse-tablet/html/js/pages/sdata/pageSdataChildPage','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/pages/sdata/pageSdataChildPage').Page;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var modules = require('syracuse-tablet/html/js/common/modules');

/**
 * Page handling a query
 * We should add filters and paging
 * 
 */
exports.Page = utils.defineClass(
	function PageSdataRowDetail(pageData, options) {
		Base.call(this, pageData, options);
		if (!this.options.childContext.rowControl) {
			throw new Error("Unexpected null rowControl");
		}
		// create/edit/details
		this._activity = this.options.childContext.activity;
		this.actionAdapter.showAccept = ["create", "edit"].indexOf(this._activity) >= 0;
		// Cancel deactivated for $edit since backup and revert is not fully implemented yet
		this.actionAdapter.showCancel = ["create"].indexOf(this._activity) >= 0;

		// No row detail authoring at the moment
		this.actionAdapter.showDesignPage = false;

		// Controller was create in the ctor of one of the super classes
		// so we can access it here.
		this.datasetBackupJson = $.extend(true, {}, this.controller.dataset.json);
	},
	Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.options.childContext.rowControl = null;
		},
		getPageTitle: function() {
			return this.controller.dataset.parent.prototype.getValueByPath("$title", true);
		},
		_actAccept: function() {
			if (!this.options.childContext.rowControl) {
				return;
			}
			var self = this;
			setTimeout(function() {
				self.options.childContext.rowControl.notifyRowSaved();
			})
		},
		_actHistoryBack: function() {
			this._cancel();
		},
		// Not finalized yet, just a draft that will be used by cancel on row
		// detail pages to revert a working copy
		_actCancel: function() {
			this._cancel();
		},
		_cancel: function() {
			if (this._activity === "create") {
				this.options.childContext.rowControl.removeRowDetail()
			} else {
				// TODO: How to cancel an edit in WC mode?

				this.controller.applyDatasetBackup(this.datasetBackupJson)
					.fail(function(result) {
						modules.get("modal").error(result);
					});
			}
			return modules.get("appController").App.goBack();
		}
	}
);
});

define('syracuse-tablet/html/js/pages/sdata/pageSdataChartDetail',['require','exports','module','syracuse-tablet/html/js/pages/sdata/pageSdata','syracuse-tablet/html/js/ui/siteLayout','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/pages/sdata/pageSdata').Page;
var siteLayout = require('syracuse-tablet/html/js/ui/siteLayout');

var utils = require('syracuse-tablet/html/js/helpers/utils');

/**
 * Page handling a query
 * We should add filters and paging
 * 
 */
/*TODO
 * page settings
 */
exports.Page = utils.defineClass(
	function PageSdataChartDetail(pageData, options) {
		options = options || {};
		options.nativeCapabilities = {
			"liveTile": true,
			"scheduleMessage": true,
			"share": true
		};
		var settings = pageData.settings ? pageData.settings.chartDetail : {}
		this.applySettings(pageData.page.$article, settings)
		Base.call(this, pageData, options);
		this.controller.level = this.options.level || 0;
		this.actionAdapter.showPinPage = false;
		this.actionAdapter.showHome = false;
	},
	Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
		},
		scrollAllowed: function() {
			return true;
		},
		_getDefaultAttachedControls: function() {
			var device = siteLayout.getDeviceType();
			if (device === "smartphone") {
				return ["header", "chartDetailToolBar"];
			} else {
				return ["header", /*"breadcrumbs"*/ , "chartDetailToolBar", "footer"];
			}
		},
		getChartDetailSetting: function() {
			var settings = this.getPageSettings() || {};
			return settings.chartDetail
		},
		_setDisplay: function() {
			var chartSettings = this.getChartDetailSetting() || {};
			this.authUpdateLayout(this.getArticle(chartSettings))
		},
		actToolbarSetDisplay: function(opts) {
			this._setChartDetailPrefs(opts);
			this._setDisplay();
			this.writePageSettings()
				.then(function() {
					// just to document it's a promise
				});
		},
		_setChartDetailPrefs: function(opts) {
			var settings = this.getPageSettings();
			settings.chartDetail = opts;
			settings.isDirty = true;
		},
		isChartDetail: function() {
			return true
		},
		getArticle: function(chartSettings) {
			var $article = Base.prototype.getArticle.call(this);
			if (chartSettings) {
				this.applySettings($article, chartSettings)
			}
			return $article
		},
		applySettings: function($article, chartSettings) {
			if (!chartSettings) return
			$article.$display = chartSettings.display || $article.$display;
			this._setArticlesSettings($article, chartSettings, {});
		},
		_setArticlesSettings: function($article, chartSettings) {
			// Be careful chart or array (or both) can be removed by authoring)
			var articles = this.getArticles($article);
			articles.arrayChartArticle && (articles.arrayChartArticle.$items[0].$isHidden = chartSettings.display === "arrayOnly");
			articles.arrayArticle && (articles.arrayArticle.$items[0].$isHidden = chartSettings.display === "chartOnly");
			var sameSize = articles.arrayChartArticle && !articles.arrayChartArticle.$items[0].$isHidden &&
				articles.arrayArticle && !articles.arrayArticle.$items[0].$isHidden &&
				(chartSettings.display === "bothSideToSide")

			if (articles.arrayChartArticle && articles.arrayArticle) {
				articles.arrayChartArticle.$sameSize = articles.arrayArticle.$sameSize = sameSize
				if (sameSize) {
					articles.arrayArticle.$widthAll = articles.arrayChartArticle.$widthAll = 6
				}
				articles.arrayChartArticle.$items[0].$arrayOptions.showPagination = (chartSettings.display === "chartOnly" && articles.arrayArticle.$items[0].$arrayOptions && articles.arrayArticle.$items[0].$arrayOptions.showPagination);
			}
			if (chartSettings.style && articles.arrayChartArticle) {
				articles.arrayChartArticle.$items[0].$style = chartSettings.style
			}
		},
		getArticles: function(node, articles) {
			if (!node.$items) return
			articles = articles || {}
			for (var i = 0; i < node.$items.length; i++) {
				if (node.$items[i].$display === "chart") {
					articles.arrayChartArticle = node
				} else if (["card", "carousel", "table"].indexOf(node.$items[i].$display) > -1) {
					articles.arrayArticle = node;
				}
				this.getArticles(node.$items[i], articles)
			};
			return articles
		},
		_isStatistics: function() {
			return this.pageData.prototype.getValueByPath("codeStat") != undefined;
		},
		allowAuthoring: function() {
			return Base.prototype.allowAuthoring.call(this) && (this.options.level === 0 || !this._isStatistics());
		}
	}

);
});

define('syracuse-tablet/html/js/pages/sdata/pageSdataCardDetail',['require','exports','module','syracuse-tablet/html/js/pages/sdata/pageSdataChildPage','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/controls/articleParser'],function (require, exports, module) {

var Base = require('syracuse-tablet/html/js/pages/sdata/pageSdataChildPage').Page;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var articleParser = require("syracuse-tablet/html/js/controls/articleParser");

/**
 * Page handling a query
 * We should add filters and paging
 * 
 */
exports.Page = utils.defineClass(
	function PageSdataCardDetail(pageData, options) {
		Base.call(this, pageData, options);

		this.actionAdapter.showAccept = false;
		// Cancel deactivated since backup and revert is not fully implemented yet
		this.actionAdapter.showCancel = false; // true;

		// No row detail authoring at the moment
		this.actionAdapter.showDesignPage = false;
		this.actionAdapter.showPinPage = false;
		this.actionAdapter.showHome = false;

	},
	Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
		},
		_createPageData: function(pageData) {
			var childPageData = this.options.childContext.cardDetailPageData;
			if (!childPageData.page.$article) {
				childPageData.page.$article = this._getArticle(childPageData.prototype);
			}
			return childPageData;
		},
		_getArticle: function(prototype) {
			return articleParser.createDefaultArticle(prototype);
		},
		getCardArrayControl: function() {
			var parentPageController = this.controller.findController(this.options.childContext.controllerId);
			if (parentPageController) {
				var arrayControl = parentPageController.getControl(this.options.childContext.arrayControlId);
				if (arrayControl) {
					return arrayControl;
				}
			}
		},
		getCardArticle: function() {
			var cardArticle = this.pageData.page.$article;
			return cardArticle;
		},
		getPageTitle: function() {
			return locale.text("auth.designCardLayout");
		},
		isCardDetail: function() {
			return true;
		}
	}
);
});

define('syracuse-tablet/html/js/pages/pageFactory',['require','exports','module','syracuse-tablet/html/js/sdata/sdataRequester','syracuse-tablet/html/js/sdata/wpHelpers','syracuse-tablet/html/js/app/settings','syracuse-tablet/html/js/controls/array/filterHelper','syracuse-tablet/html/js/sdata/protocolHelpers','syracuse-tablet/html/js/pages/sdata/pageSdata','syracuse-tablet/html/js/pages/sdata/pageSdataQuery','syracuse-tablet/html/js/pages/sdata/pageSdataLookup','syracuse-tablet/html/js/pages/sdata/pageSdataDashboard','syracuse-tablet/html/js/pages/sdata/pageHome','syracuse-tablet/html/js/pages/html/pageLogin','syracuse-tablet/html/js/pages/html/pageLogout','syracuse-tablet/html/js/pages/sdata/pageSdataRowDetail','syracuse-tablet/html/js/pages/sdata/pageSdataChartDetail','syracuse-tablet/html/js/pages/sdata/pageSdataCardDetail'],function (require, exports, module) {

var sdataReq = require("syracuse-tablet/html/js/sdata/sdataRequester");
var wpHelpers = require("syracuse-tablet/html/js/sdata/wpHelpers");
var settings = require('syracuse-tablet/html/js/app/settings');
var filterHelper = require('syracuse-tablet/html/js/controls/array/filterHelper');
var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');

var _classes = {
	PageSdata: require("syracuse-tablet/html/js/pages/sdata/pageSdata").Page,
	PageSdataQuery: require("syracuse-tablet/html/js/pages/sdata/pageSdataQuery").Page,
	PageSdataLookup: require("syracuse-tablet/html/js/pages/sdata/pageSdataLookup").Page,

	PageSdataDashboard: require("syracuse-tablet/html/js/pages/sdata/pageSdataDashboard").Page,
	PageHome: require("syracuse-tablet/html/js/pages/sdata/pageHome").Page,

	PageLogin: require("syracuse-tablet/html/js/pages/html/pageLogin").Page,
	PageLogout: require("syracuse-tablet/html/js/pages/html/pageLogout").Page,

	PageSdataRowDetail: require("syracuse-tablet/html/js/pages/sdata/pageSdataRowDetail").Page,
	PageSdataChartDetail: require("syracuse-tablet/html/js/pages/sdata/pageSdataChartDetail").Page,
	PageSdataCardDetail: require("syracuse-tablet/html/js/pages/sdata/pageSdataCardDetail").Page,
}

var _htmlPages = {
	login: _classes.PageLogin,
	logout: _classes.PageLogout,
	home: _classes.PageHome
};

var _childPages = {
	SdataRowDetail: _classes.PageSdataRowDetail,
	SdataChartDetail: _classes.PageSdataChartDetail,
	SdataCardDetail: _classes.PageSdataCardDetail
}

/**
 * pageCreateData: 
 * 
 * Data that describes on how to create the page
 * Should be simple data only, no class instances so that the navigation stack
 * can re-create pages autonomously without knowing internals
 */
exports.createPage = function(pageCreateData) {
	var url = pageCreateData.url;
	var method = pageCreateData.method;
	var options = pageCreateData.options || {};
	var fetchOptions = {
		data: null,
		isChartDetail: pageCreateData.options.isChartDetail === true,
	};
	// for chartdetail level is in pageCreateData.options.level (0 for first ...)
	// First guess of a page name, could be changed later by transforms
	pageCreateData.name = pageCreateData.name || protoHelpers.getPageName(url);

	// pagePrefsId != null if isVignette
	pageCreateData.pagePrefsId = options.isVignette ? options.pagePrefsId : settings.getPagePrefsId(pageCreateData.name);
	if (options.isVignette && options.$vignetteArticle) {
		// Force vignette's article
		fetchOptions.page = {
			$article: $.extend(true, null, options.$vignetteArticle)
		};
	} else if (options.$mockArticle) {
		// used by mockup
		fetchOptions.page = {
			$article: $.extend(true, null, options.$mockArticle)
		};
	}
	return $.smResolve()
		.then(function() {
			if (url.indexOf("html://home") === 0) {
				return _fetchSDataPageHomeData(options.uuid)
					.then(function(pageData) {
						pageData.$url = url;
						pageData.$method = method;
						pageData.name = pageCreateData.name;
						var page = new _classes.PageHome(pageData, options);
						return page;
					});
			} else if (url.indexOf("html://") === 0) {
				return _createHtmlPage(pageCreateData.name, options);
			} else if (url.indexOf("child://") === 0) {
				return _createChildPage(pageCreateData.name, options);
			}
			return _fetchSDataPageData(url, fetchOptions, method, pageCreateData.pagePrefsId)
				.then(function(pageData) {
					pageData.$url = url;
					pageData.$method = method;
					return wpHelpers.isPagePinned(pageData.dataset.getValueByPath("$uuid"))
						.then(function(state) {
							options.isPinned = state;
							var page = _createSdataPage(pageData, pageCreateData, options);
							return page;
						})
				});
		});
}

function _fetchSDataPageHomeData(uuid) {
	return $.smResolve()
		.then(function() {
			return wpHelpers.fetchWelcomePageData(uuid);
		})
		.then(function(pageData) {
			pageData.$originalUrl = pageData.$url; // Url used to introduce page loading
			return pageData;
		})
}
/*
 * 
 */
function _fetchSDataPageData(url, options, method, pagePrefsId) {
	var pageSettings;
	return $.smResolve()
		.then(function() {
			return settings.readUserPagePrefs(pagePrefsId)
		})
		.then(function(settings) {
			settings.isDirty = false;
			return settings;
		})
		.then(function(settings) {
			pageSettings = settings;
			var opts = {
				"$url": url,
				"sortInfo": settings.sort,
				"filterInfos": settings.filter,
				"searchInfo": settings.search,
			}
			var $url;
			if (url.indexOf(".$query") > -1) {
				$url = filterHelper.filterSortUpdateUrl(opts);
			}
			$url = $url || url;

			var _page = {
				"$url": $url,
				"$method": method || "GET"
			};
			return sdataReq.fetchPageData(_page, options);
		})
		.then(function(pageData) {
			pageData.settings = pageSettings;
			pageData.$originalUrl = url; // Url used to introduce page loading
			return pageData;
		})
}
/**
 * 
 */
function _createSdataPage(pageData, pageCreateData, options) {
	var proto = pageData.prototype;
	var facet = proto.getFacet();
	if (options.isChartDetail) facet = "$chartDetail"
	var $url = proto.getValueByPath("$url", true);
	var syrRepr = proto.getValueByPath("$representation");

	// A dashboard is also an sdata entity but with a very special rendering
	if (syrRepr === "mobileDashboard") {
		pageData.name = pageData.dataset.json.dashboardName + ".$mobileDashboard";
		// http://localhost:8124/sdata/syracuse/collaboration/syracuse/mobileDashboards(dashboardName%20eq%20'STD_X3_ERP_EXPENSES_DASHBOARD')?representation=mobileDashboard.$details
		return new _classes.PageSdataDashboard(pageData, options);
	}
	pageData.name = pageCreateData.name;
	switch (facet) {
		case "$query":
			return new _classes.PageSdataQuery(pageData, options);

		case "$lookup":
			return new _classes.PageSdataLookup(pageData, options);
		case "$chartDetail":
			return new _classes.PageSdataChartDetail(pageData, options);
		default:
			return new _classes.PageSdata(pageData, options);

	}
}

/**
 * 
 * 
 */
function _createHtmlPage(pageName, options) {
	return $.smResolve()
		.then(function() {
			var pageClass = _htmlPages[pageName];
			if (!pageClass) {
				throw new Error("Html page " + pageName + " not found")
				return;
			}
			var page = new pageClass(pageName, options);
			return page;
		});
}

function _createChildPage(pageName, options) {
	return $.smResolve()
		.then(function() {
			var pageClass = _childPages[pageName];
			if (!pageClass) {
				throw new Error("Child page " + pageName + " not found")
				return;
			}
			// Page data will be created by child page since it's usually just pointing to the parent page
			// See pageSdataChildPage
			var pageData = {};
			pageData.page = {};
			options = options || {};
			options.childPageName = pageName;
			return new pageClass(pageData, options);
		});

}
});

define('syracuse-tablet/html/js/helpers/base64',['require','exports','module'],function (require, exports, module) {

/**
 *
 *  Base64 encode / decode
 *  http://www.webtoolkit.info/
 *
 **/

var Base64 = exports.Base64 = {

	// private property
	_keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

	// public method for encoding
	encode: function(input) {
		var output = "";
		var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
		var i = 0;

		input = Base64._utf8_encode(input);

		while (i < input.length) {

			chr1 = input.charCodeAt(i++);
			chr2 = input.charCodeAt(i++);
			chr3 = input.charCodeAt(i++);

			enc1 = chr1 >> 2;
			enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
			enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
			enc4 = chr3 & 63;

			if (isNaN(chr2)) {
				enc3 = enc4 = 64;
			} else if (isNaN(chr3)) {
				enc4 = 64;
			}

			output = output + this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) + this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);

		}

		return output;
	},

	// public method for decoding
	decode: function(input) {
		var output = "";
		var chr1, chr2, chr3;
		var enc1, enc2, enc3, enc4;
		var i = 0;

		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

		while (i < input.length) {

			enc1 = this._keyStr.indexOf(input.charAt(i++));
			enc2 = this._keyStr.indexOf(input.charAt(i++));
			enc3 = this._keyStr.indexOf(input.charAt(i++));
			enc4 = this._keyStr.indexOf(input.charAt(i++));

			chr1 = (enc1 << 2) | (enc2 >> 4);
			chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
			chr3 = ((enc3 & 3) << 6) | enc4;

			output = output + String.fromCharCode(chr1);

			if (enc3 != 64) {
				output = output + String.fromCharCode(chr2);
			}
			if (enc4 != 64) {
				output = output + String.fromCharCode(chr3);
			}

		}

		output = Base64._utf8_decode(output);

		return output;

	},

	// private method for UTF-8 encoding
	_utf8_encode: function(string) {
		string = string.replace(/\r\n/g, "\n");
		var utftext = "";

		for (var n = 0; n < string.length; n++) {

			var c = string.charCodeAt(n);

			if (c < 128) {
				utftext += String.fromCharCode(c);
			} else if ((c > 127) && (c < 2048)) {
				utftext += String.fromCharCode((c >> 6) | 192);
				utftext += String.fromCharCode((c & 63) | 128);
			} else {
				utftext += String.fromCharCode((c >> 12) | 224);
				utftext += String.fromCharCode(((c >> 6) & 63) | 128);
				utftext += String.fromCharCode((c & 63) | 128);
			}

		}

		return utftext;
	},

	// private method for UTF-8 decoding
	_utf8_decode: function(utftext) {
		var string = "";
		var i = 0;
		var c1, c2, c3;
		var c = c1 = c2 = 0;

		while (i < utftext.length) {

			c = utftext.charCodeAt(i);

			if (c < 128) {
				string += String.fromCharCode(c);
				i++;
			} else if ((c > 191) && (c < 224)) {
				c2 = utftext.charCodeAt(i + 1);
				string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
				i += 2;
			} else {
				c2 = utftext.charCodeAt(i + 1);
				c3 = utftext.charCodeAt(i + 2);
				string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
				i += 3;
			}

		}

		return string;
	},

	// public method for decoding
	raw_decode: function(input) {
		var output = "";
		var chr1, chr2, chr3;
		var enc1, enc2, enc3, enc4;
		var i = 0;

		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

		while (i < input.length) {

			enc1 = this._keyStr.indexOf(input.charAt(i++));
			enc2 = this._keyStr.indexOf(input.charAt(i++));
			enc3 = this._keyStr.indexOf(input.charAt(i++));
			enc4 = this._keyStr.indexOf(input.charAt(i++));

			chr1 = (enc1 << 2) | (enc2 >> 4);
			chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
			chr3 = ((enc3 & 3) << 6) | enc4;

			output = output + String.fromCharCode(chr1);

			if (enc3 != 64) {
				output = output + String.fromCharCode(chr2);
			}
			if (enc4 != 64) {
				output = output + String.fromCharCode(chr3);
			}

		}

		//		output = Base64._utf8_decode(output);

		return output;

	}
};

exports.encode = function(text) {
	return Base64.encode(text);
};
});

define('syracuse-tablet/html/js/app/session',['require','exports','module','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/helpers/base64','syracuse-tablet/html/js/app/settings','syracuse-tablet/html/js/common/helpers','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/native/native'],function (require, exports, module) {

var modules = require('syracuse-tablet/html/js/common/modules');
var base64 = require('syracuse-tablet/html/js/helpers/base64');
var settings = require('syracuse-tablet/html/js/app/settings');
var helpers = require('syracuse-tablet/html/js/common/helpers');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("session", false);
var native = require('syracuse-tablet/html/js/helpers/native/native');

/**
 * 
 */
exports.getAuthMethods = function() {
	var ajax = modules.get("ajax");
	return ajax.request("/requireJS/misc/availableAuth")
		.then(function(result) {
			var list = [];
			if (result && result.data) {
				Object.keys(result.data).forEach(function(key) {
					var supported = result.data[key];
					if (supported) {
						list.push(key);
					}
				})
			}
			return {
				"$supported": list, // List of what is supported
				"$oauth2": result.data && result.data.$oauth2, // oauth2 providers
				"$saml2": result.data && result.data.$saml2 // saml2 providers
			}
		});
}

/**
 * Returns current user profile
 * Resolves with JSON or reject
 */
exports.getCurrentUserProfile = function() {
	return modules.get("ajax").request("/sdata/syracuse/collaboration/syracuse/userProfiles/$service/current")
		.then(function(result) {
			if (result.data) {
				return result.data;
			} else {
				throw new Error("Empty user profile");
			}
		})
};

/**
 * 
 */
exports.loginBasic = function(user, password, rememberMe) {
	var deferred = $.Deferred();

	var headers = {
		"Authorization": 'Basic ' + base64.encode(user + ":" + password),
		"accept": "application/json"
	};

	var data = {
		// To force the server to take into account a new credentials - see SAM 112730
		forgetme: true
	};
	if (rememberMe === true) {
		// Enable remember me one credentials s have been validated
		data["keepConnected"] = true;
	}

	var ajax = modules.get("ajax");
	ajax.request("/auth/login/submit", "POST", data, headers)
		.then(function(result) {

			// Once logged in, remember reconnect token for next time 
			// NOTE: For other redirect based authentications, the token is stored
			// during startup in main.js
			exports.nativeStoreReconnectToken();

			deferred.resolve(result.data);
		})
		.fail(function(result) {
			deferred.reject(result);
		});

	return deferred.promise();

}

/**
 * Trigger Sage-ID authentication
 * Note: This is just a redirect to the sage is authentication service
 * Once authentication is done, it will automatically redirect to the location the client has been looking at before.
 * The mobile client will reload, see the created session and automatically open the desired page
 */
exports.loginSageId = function() {
	window.location.href = "/auth/sage-id/signOnStart";
}

/**
 * 
 */
exports.logout = function() {
	var ajax = modules.get("ajax");
	return ajax.request("/logout", "POST");

}

/**
 * 
 */
exports.forgetMe = function() {
	var ajax = modules.get("ajax");
	return ajax.request("/auth/forgetMe/submit", "POST", {
		forgetme: true
	}).always(function() {
		// Remove the last used context - fixed FDB
		settings.removeLastUsedUserProfile();
	})

}

/**
 * Store current user profile in local database to allow offline login next time
 * Returns currently active user profile
 */
exports.storeUserProfile = function(profile) {
	return settings.setLastUsedUserProfile(profile);
}

/**
 * Apply endpoint, role and language to the current user profile
 * Saves user profile for next offline login if setting the above succeeded
 *   
 * settings: Available endpoints, roles, languages
 * userProfile: currently active user profile
 * endpoint,role,language: Settings to be applied
 * 
 * Return: Current user profile
 * 
 */
exports.applyNewContext = function(settings, userProfile, endpoint, role, language) {
	//	console.log(settings);
	//	console.log(userProfile);

	var roleMatch;
	var localeMatch;
	var endpointMatch;

	settings.roles.some(function(r) {
		if (r.code === role) {
			roleMatch = r;
			return true;
		}
	});
	if (!roleMatch) {
		return $.smReject(helpers.createDiag({}, "error", locale.text("switchContext.error.role", [role])));

	}

	settings.locales.some(function(l) {
		if (l.code === language) {
			localeMatch = l;
			return true;
		}
	});
	if (!roleMatch) {
		return $.smReject(helpers.createDiag({}, "error", locale.text("switchContext.error.language", [language])));

	}

	roleMatch.endPoints.some(function(e) {
		if (e.code === endpoint) {
			endpointMatch = e;
			return true;
		}
	});
	if (!endpointMatch) {
		return $.smReject(helpers.createDiag({}, "error", locale.text("switchContext.error.endpoint", [endpoint])));

	}

	var changeDelta = {};
	if (userProfile.selectedEndpoint.$uuid !== endpointMatch.$uuid) {
		changeDelta.selectedEndpoint = {
			$uuid: endpointMatch.$uuid
		};
	}
	if (userProfile.selectedRole.$uuid !== roleMatch.$uuid) {
		changeDelta.selectedRole = {
			$uuid: roleMatch.$uuid
		};
	}
	if (userProfile.selectedLocale.$uuid !== localeMatch.$uuid) {
		changeDelta.selectedLocale = {
			$uuid: localeMatch.$uuid
		};
	}

	if (Object.keys(changeDelta).length <= 0) {
		// Nothing to change
		return $.smResolve();
	}

	var ajax = modules.get("ajax");
	return ajax.request("/sdata/syracuse/collaboration/syracuse/userProfiles/$service/updateProfile", "POST", changeDelta)
		.then(function(result) {
			return exports.storeUserProfile(result.data)
				.then(function() {
					return result.data;
				});
		});
}
exports.getReconnectToken = function() {
	var deferred = new $.Deferred();

	var ajax = modules.get("ajax");
	ajax.request("/requireJS/reconnect/getToken", "GET", null, {
		"accept": "application/json"
	}).always(function(result) {
		if (result.status === 200 && result.headers) {
			var token = result.headers["x-reconnect-token"];
			var sid = result.headers["x-reconnect-sid"];

			// We return the cookies names because the client doesn't know 
			// the port number used to build the name in case of reverse proxy 
			// like on server http://sage-x3-mobile.sage-demo.fr
			var loginCookieName = result.headers["x-reconnect-login-cookiename"];
			var sidCookieName = result.headers["x-reconnect-sid-cookiename"];

			var login = _parseReconnectCookie(token);
			deferred.resolve(login ? token : null, login, sid, loginCookieName, sidCookieName);
		} else {
			deferred.resolve();
		}
	});
	return deferred.promise();
};

exports.setReconnectToken = function(loginCookie, sidCookie) {
	var deferred = new $.Deferred();
	loginCookie = loginCookie || "";
	sidCookie = sidCookie || "";
	log && log("setReconnectToken - Login: ", loginCookie, " - sid: ", sidCookie)

	var ajax = modules.get("ajax");
	ajax.request("/requireJS/reconnect/setToken", "GET", null, {
			"accept": "application/json",
			"x-reconnect-token": loginCookie,
			"x-reconnect-sid": sidCookie
		}).then(function(result) {
			log && log("setReconnectToken succeeded", loginCookie, sidCookie);
		}).fail(function(result) {
			log && log("setReconnectToken failed");
		})
		.always(function() {
			deferred.resolve();
		});
	return deferred.promise();
}

exports.nativeStoreReconnectToken = function() {
	var deferred = new $.Deferred();
	var nativeApp = native.getModule("nativeApp");
	if (!nativeApp) {
		return $.smResolve();
	}

	exports.getReconnectToken()
		.then(function(token, userLogin, sid, loginCookieName, sidCookieName) {
			log && log("nativeStoreReconnectToken", token, userLogin, sid, loginCookieName, sidCookieName);
			nativeApp.setReconnectToken(token, userLogin, sid, loginCookieName, sidCookieName);
		})
		.always(function() {
			deferred.resolve();
		});
	return deferred.promise();
}

function _parseReconnectCookie(cookie) {
	if (!cookie) {
		return null;
	}
	cookie = cookie.split("/");
	if (cookie.length < 3) return null;
	var token = cookie.pop();
	var series = cookie.pop();
	var login = cookie.join("/");
	return login;
};
});

define('syracuse-tablet/html/js/sdata/sdatawhere/whereUtils',['require','exports','module'],function (require, exports, module) {

function _exec(data, exp, proto) {
	if (exp.type == "identifier") {
		exp.property = data[exp.value];
		// issue #3744 in X3 boolean properties has numeric values
		// and in the x3 filters (where clauses use numeric values 1(false) and
		// 2(true) for boolean properties)
		var item = proto && proto.$properties && proto.$properties.$resources ? proto.$properties.$resources.$item : null;
		if (item && item.$properties && item.$properties[exp.value] && item.$properties[exp.value].$type === "application/x-boolean") {
			exp.property = exp.property === true ? 2 : 1;
		}
	} else if (exp.type == "literal") {
		exp.property = (exp.dataType == "datetime") ? exp.svalue : exp.value;
	} else {
		if (exp.children) {
			var property = null;

			// propagate property from child to parent if operator if low level
			// operator
			if (exp.type == "operator") {
				switch (exp.value.code) {

					case "and":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property && exp.children[1].property);
						break;
					case "or":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property || exp.children[1].property);
						break;
					case "between":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property >= exp.children[1].property) && (exp.children[0].property <= exp.children[2].property);
						break;
					case ">=":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property >= exp.children[1].property);
						break;
					case ">":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property > exp.children[1].property);
						break;
					case "<=":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property <= exp.children[1].property);
						break;
					case "<":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property < exp.children[1].property);
						break;
					case "like_s":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property.toUpperCase()
							.indexOf(exp.children[1].property.toUpperCase()) === 0);
						break;
					case "like":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						var val = exp.children[1].property.toUpperCase().replace(
							/%/g, '');
						exp.property = (exp.children[0].property.toUpperCase()
							.indexOf(val) >= 0);
						break;
					case "=":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						if (exp.children[0].property == "0000-00-00" && exp.children[1].dataType === "datetime") {
							exp.children[0].property = "";
						}
						if (exp.children[1].property == "0000-00-00" && exp.children[0].dataType === "datetime") {
							exp.children[1].property = "";
						}
						exp.property = (exp.children[0].property == exp.children[1].property);
						break;
					case "<>":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						if (exp.children[0].property == "0000-00-00" && exp.children[1].dataType === "datetime") {
							exp.children[0].property = "";
						}
						if (exp.children[1].property == "0000-00-00" && exp.children[0].dataType === "datetime") {
							exp.children[1].property = "";
						}
						exp.property = (exp.children[0].property != exp.children[1].property);
						break;
					case ".":
						_exec(data, exp.children[0], proto);
						_exec(exp.children[0].property, exp.children[1], proto);
						exp.property = exp.children[1].property;
						break;
					default:
						exp.property = property;
						// propagate to literals
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
							if (child.type == "literal")
								child.property = property;
						});
				}
			} else if (exp.type == "function") {
				throw new Error("exp.type == 'function' not implemented");
			}
		}
	}
};

exports.execWhere = function(dataContext, exp, proto) {

	if (exp == null) {
		return true;
	}

	_exec(dataContext, exp, proto);

	return exp.property;

};
});

define('syracuse-tablet/html/js/sdata/sdataSort',['require','exports','module'],function (require, exports, module) {

/*
 *
 */

function _sdataSortArray(data, proto, orderBy) {

	var comparators = [];
	var properties = (proto.$properties.$resources && proto.$properties.$resources.$item && proto.$properties.$resources.$item.$properties) || proto.$properties;

	orderBy.forEach(function(exp) {
		var prop = exp.property;
		var sort = ((exp.sort === "DESC" || exp.sort === "desc") ? "DESC" : "ASC");
		var type = (properties[prop] && properties[prop].$type) || "application/x-string";

		if (type === "application/x-decimal") {
			if (sort === "ASC") {
				try {
					comparators.push(function(a, b) {
						var vala = a[prop];
						var valb = b[prop];
						return (+vala) - (+valb);
					});
				} catch (e) {}
				return 0;
			} else {
				try {
					comparators.push(function(a, b) {
						var vala = a[prop];
						var valb = b[prop];
						return (+valb) - (+vala);
					});
				} catch (e) {}
				return 0;
			}
		} else {
			if (sort === "ASC") {
				comparators.push(function(a, b) {
					try {
						var vala = a[prop];
						var valb = b[prop];
						if (vala > valb) {
							return 1;
						} else if (vala < valb) {
							return -1;
						}
					} catch (e) {}
					return 0;
				});
			} else {
				comparators.push(function(a, b) {
					try {
						var vala = a[prop];
						var valb = b[prop];
						if (vala > valb) {
							return -1;
						} else if (vala < valb) {
							return 1;
						}
					} catch (e) {}
					return 0;
				});
			}
		}
	});

	data.sort(function(a, b) {
		var c = 0;
		for (var i = 0; i < comparators.length; i++) {
			c = comparators[i](a, b);
			if (c !== 0) {
				break;
			}
		}
		return c;
	});
}
exports.sdataSortArray = _sdataSortArray;
});

define('syracuse-tablet/html/js/sdata/cache/sdataCache',['require','exports','module','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/storage/storage','syracuse-tablet/html/js/sdata/sdatawhere/parser','syracuse-tablet/html/js/sdata/sdatawhere/whereUtils','syracuse-tablet/html/js/sdata/sdataSort'],function (require, exports, module) {

/*
 *
 */
var modules = require('syracuse-tablet/html/js/common/modules');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("SDataCache", false);
var utils = require('syracuse-tablet/html/js/helpers/utils');
var storageModule = require('syracuse-tablet/html/js/storage/storage');
var parser = require('syracuse-tablet/html/js/sdata/sdatawhere/parser').Parser;
var whereUtils = require('syracuse-tablet/html/js/sdata/sdatawhere/whereUtils');
var sdataSort = require('syracuse-tablet/html/js/sdata/sdataSort');

// all storage entries created by the cache will be prefixed with this to be able to empty the cache w/o removing settings
var _cachePrefix = "$cache_";
var _keyRegExp = /\{(.*?)\}/g;

var _cache;

function _SDataCache() {};

/*
 *
 */
var _SDataCacheClass = utils.defineClass(
	_SDataCache,
	null, {
		cachePrefix: _cachePrefix,

		/**
		 * Put an instance of an sdata object into the cache
		 *
		 * Parameters:
		 * data
		 * {
		 *   $data: {} - Data to store in cache (mandatory)
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 *   $key: "mawal" - Key of data
		 * }
		 * Note that $proto OR $representation AND $key must be set
		 *
		 * Return:
		 * Resolve:
		 * null
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		put: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				if (!data.$data) {
					throw new Error("PUT: No data specified");
				}
				var repr;
				var key;
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
					key = self._getKeyValue(data.$data, $proto);
				} else if (data.$representation && data.$key) {
					repr = data.$representation;
					key = data.$key;
				} else {
					throw new Error("PUT: Neither proto nor representation and key specified");
				}
				self.getStorage().put({
					$context: self.getCacheContext(),
					$collection: _cachePrefix + repr,
					$endpoint: data.$endpoint,
					$key: key,
					$data: {
						$item: data.$data
					}
				}).then(function(result) {
					deferred.resolve();
				}).fail(function(error) {
					deferred.reject(error);
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 * Query an array of instances from cache
		 *
		 * Parameters:
		 * data
		 * {
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 *   $where: "user eq 'admin' - Optional where clause
		 *   $orderBy: [{ "property": "user", "sort" : "ASC"}, { "property": "login", "sort" : "desc"}] - Optional array of sort conditions
		 * }
		 * Note that $proto OR $representation must be set
		 *
		 * Return:
		 * Resolve:
		 * Matched instances of queried representation
		 * [
		 *   {},
		 *   {}
		 * ]
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		query: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var repr;
				log && log("Query by: " + JSON.stringify(data));
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					//repr = self._getRepresentation($proto);
					repr = self._getRepresentation(data.$proto);

				} else if (data.$representation) {
					if (data.$where) {
						throw new Error("QUERY: Where clause parsing requires prototype");
					}
					if (data.$orderBy) {
						throw new Error("QUERY: Order by requires prototype");
					}
					repr = data.$representation;
				} else {
					throw new Error("QUERY: Neither proto nor representation specified");
				}
				self.getStorage().query({
					$context: self.getCacheContext(),
					$endpoint: data.$endpoint,
					$collection: _cachePrefix + repr
				}).then(function(result) {
					var res = [];
					if (data.$where) {
						var exp = parser.parse(data.$where);
						result.$data.forEach(function(item, i) {
							if (whereUtils.execWhere(item.$item, exp, $proto)) {
								var d = item.$item;
								var m = result.$metaData[i];
								d.$cache = {
									$lastRead: m.$lastRead,
									$lastUpdated: m.$lastUpdated
								};
								res.push(d);
							}
						});
					} else {
						result.$data.forEach(function(item, i) {
							var d = item.$item;
							var m = result.$metaData[i];
							d.$cache = {
								$lastRead: m.$lastRead,
								$lastUpdated: m.$lastUpdated
							};
							res.push(d);
						});
					}
					if (data.$orderBy) {
						sdataSort.sdataSortArray(res, $proto, data.$orderBy);
					}
					// Exception are handled by ou jq deferred hack
					deferred.resolve(res);
				}).fail(function(error) {
					deferred.reject(error);
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 * Read one instance from cache using given key
		 *
		 * Parameters:
		 * data
		 * {
		 *   $key: "abc~def" - Key of object to read
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 * }
		 * Note that $proto OR $representation must be set
		 *
		 * Return:
		 * Resolve:
		 * Instance for given key or null if no match
		 * { ... }
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		read: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var repr;
				if (!data.$key) {
					throw new Error("READ: No key specified");
				}
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
				} else if (data.$representation) {
					repr = data.$representation;
				} else {
					throw new Error("READ: Neither proto nor representation specified");
				}
				self.getStorage().read({
					$context: self.getCacheContext(),
					$collection: _cachePrefix + repr,
					$endpoint: data.$endpoint,
					$key: data.$key
				}).then(function(result) {
					if (result.$status === storageModule.StatusCodes.OK) {
						var res = result.$data.$item;
						res.$cache = {
							$lastRead: result.$metaData.$lastRead,
							$lastUpdated: result.$metaData.$lastUpdated
						};
						deferred.resolve(res);
					} else {
						deferred.resolve(null);
					}
				}).fail(function(error) {
					deferred.reject(error);
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 * Delete instance from cache by given key
		 *
		 * Parameters:
		 * data
		 * {
		 *   $key: "abc~def" - Key of object to read
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 * }
		 * Note that $proto OR $representation must be set
		 *
		 * Return:
		 * Resolve:
		 * null
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		remove: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var repr;
				if (!data.$key) {
					throw new Error("REMOVE: No key specified");
				}
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
				} else if (data.$representation) {
					repr = data.$representation;
				} else {
					throw new Error("READ: Neither proto nor representation specified");
				}
				self.getStorage().remove({
					$context: self.getCacheContext(),
					$collection: _cachePrefix + repr,
					$endpoint: data.$endpoint,
					$key: data.$key
				}).then(function() {
					deferred.resolve();
				}).fail(function(error) {
					deferred.reject(error);
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 *
		 * options: {
		 * $not_read_since: "2015-01-20 11-22-33"
		 * }
		 */
		clearCache: function(options) {
			var deferred = $.Deferred();
			var self = this;
			var re = new RegExp(self.cachePrefix.replace(/([\$\_]+)/g, "\\$1"));
			var opts = {
				$context: self.getCacheContext(),
				$collection: re
			};
			if (options && options.$not_read_since) {
				opts.$not_read_since = options.$not_read_since;
			}
			try {
				self.getStorage().clearCollection(opts)
					.then(function() {
						deferred.resolve();
					}).fail(function(error) {
						deferred.reject(error);
					});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 *
		 * options: {
		 * $not_read_since: "2015-01-20 11-22-33"
		 * }
		 */
		computeCacheSize: function(options) {
			var deferred = $.Deferred();
			var self = this;
			var re = new RegExp(self.cachePrefix.replace(/([\$\_]+)/g, "\\$1"));
			var opts = {
				$context: self.getCacheContext(),
				$collection: re
			};
			if (options && options.$not_read_since) {
				opts.$not_read_since = options.$not_read_since;
			}
			try {
				self.getStorage().computeCollectionSize(opts)
					.then(function(result) {
						deferred.resolve(result);
					}).fail(function(error) {
						deferred.reject(error);
					});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		_getProto: function(proto) {
			var itemProto = (proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
			// item type of query and lookup is e.g. $queryItem
			// We want to use the base $type here ($query or $lookup)
			itemProto.$type = proto.$type;
			return itemProto;
		},
		_getRepresentation: function(proto) {
			return proto.$type.split(".").slice(1, 3).join(".").replace("$queryItem", "$query");
		},
		_getKeyValue: function(data, proto) {
			return proto.$key.replace(_keyRegExp, function(m, p) {
				return data[p];
			});
		},
		getStorage: function() {
			if (!this._storage) {
				this._storage = modules.get("storage").getStorage();
			}
			return this._storage;
		},
		getCacheContext: function() {
			return modules.get("appController").App.getCacheContext();
		}
	}
);

exports.getCache = function() {
	if (!_cache) {
		_cache = new _SDataCache();
	}
	return _cache;
}
});

define('syracuse-tablet/html/js/init/initModules',['require','exports','module','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/app/navigationHelper','syracuse-tablet/html/js/app/navigationPageStack','syracuse-tablet/html/js/controls/ctrlFactory','syracuse-tablet/html/js/pages/pageFactory','syracuse-tablet/html/js/controllers/controller','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/ui/siteLayout','syracuse-tablet/html/js/app/appController','syracuse-tablet/html/js/common/ajax','syracuse-tablet/html/js/app/session','syracuse-tablet/html/js/storage/storage','syracuse-tablet/html/js/sdata/cache/sdataCache'],function (require, exports, module) {

var modules = require('syracuse-tablet/html/js/common/modules');

//globally used modules
var navigationHelper = require('syracuse-tablet/html/js/app/navigationHelper');
var navigationPageStack = require('syracuse-tablet/html/js/app/navigationPageStack');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');
var pageFactory = require('syracuse-tablet/html/js/pages/pageFactory');
var controller = require('syracuse-tablet/html/js/controllers/controller');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var siteLayout = require('syracuse-tablet/html/js/ui/siteLayout');
var appController = require('syracuse-tablet/html/js/app/appController');
var ajax = require('syracuse-tablet/html/js/common/ajax');
var session = require('syracuse-tablet/html/js/app/session');
var storage = require('syracuse-tablet/html/js/storage/storage');
var cache = require('syracuse-tablet/html/js/sdata/cache/sdataCache');

/**
 * 
 */
exports.init = function() {
	return $.smResolve()
		.then(function() {
			return _initComponentModules();
		});
};

/**
 * 
 * @returns
 */
function _initComponentModules() {
	return $.smResolve()
		.then(function() {
			modules.addModule("navHelper", navigationHelper);
			modules.addModule("navStack", navigationPageStack);
			modules.addModule("ctrlFactory", ctrlFactory);
			modules.addModule("pageFactory", pageFactory);
			modules.addModule("controller", controller);
			modules.addModule("modal", modal);
			modules.addModule("siteLayout", siteLayout);
			modules.addModule("appController", appController);
			modules.addModule("ajax", ajax);
			modules.addModule("session", session);
			modules.addModule("storage", storage);
			modules.addModule("cache", cache);
		});
}
});

define('syracuse-tablet/html/js/init/initStorage',['require','exports','module','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/common/modules'],function (require, exports, module) {

var native = require('syracuse-tablet/html/js/helpers/native/native');
var modules = require('syracuse-tablet/html/js/common/modules');

exports.init = function() {
	return $.smResolve()
		.then(function() {
			return native.getSupportedDB();
		})
		.then(function(supportedDB) {
			return modules.get("storage").init(supportedDB)
		});
}
});

define('syracuse-tablet/html/js/main',['require','exports','module','syracuse-tablet/html/js/common/modules','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/environment','syracuse-tablet/html/js/utils/waiting','syracuse-tablet/html/js/helpers/native/native','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/developmentPage','syracuse-tablet/html/js/init/initThirdParty','syracuse-tablet/html/js/init/initStyles','syracuse-tablet/html/js/ui/uiSettings','syracuse-tablet/html/js/init/initLocale','syracuse-tablet/html/js/init/initModules','syracuse-tablet/html/js/init/initStorage','syracuse-tablet/html/js/app/appController'],function (require, exports, module) {

var modules = require('syracuse-tablet/html/js/common/modules');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("main", false);
var environment = require('syracuse-tablet/html/js/helpers/environment');

var waiting = require('syracuse-tablet/html/js/utils/waiting');
var native = require('syracuse-tablet/html/js/helpers/native/native');

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

var developmentPage = require('syracuse-tablet/html/js/helpers/developmentPage');

var initThirdParty = require('syracuse-tablet/html/js/init/initThirdParty');
var initStyles = require('syracuse-tablet/html/js/init/initStyles');
var uiSettings = require('syracuse-tablet/html/js/ui/uiSettings');
var initLocale = require('syracuse-tablet/html/js/init/initLocale');
var initModules = require('syracuse-tablet/html/js/init/initModules');
var initStorage = require('syracuse-tablet/html/js/init/initStorage');

var App = require('syracuse-tablet/html/js/app/appController').App;

var _nativeApp;

var _onError = function(error) {
	waiting.reset();
	try {
		modules.get("modal").asynchError(error);
	} catch (e) {
		alert(JSON.stringify(jsutils.convertToDiagnoses(error), null, 2));
	}
}

window.onerror = function(errorMsg, url, lineNumber, error) {
	var diag = {
		$diagnoses: [{
			$message: errorMsg,
			$stackTrace: "url:" + url + "\nLineNUmber:" + lineNumber + "\nError:" + error,
			$severity: "error"
		}]
	}
	_onError(diag);
};

$(document).ready(function() {
	if (document.location.href.indexOf("?circular") > -1) {
		_checkModuleDependencies();
	} else {
		_startApp()
	}
});

function _checkModuleDependencies() {
	xrayquire.showCycles(undefined, true);
}

function _startApp() {
	var sessionAvailable;
	var firstPage;
	var initTask = $.smResolve()
		.then(function() {
			return _initPlatform();
		})
		.then(function() {
			// When technical stuff is ready, we tell it to the wrapper if there is one
			_nativeApp && _nativeApp.notifLoaded();
		})
		.then(function() {
			return developmentPage.restoreOnStartup();
		})
		.then(function() {
			return App.init();
		})
		.then(function() {
			// returns true -> already logged in
			// "offline" when offline
			// "nosession" if we need to login first
			return _checkSession();
		})
		.then(function(_sessionAvailable) {
			sessionAvailable = _sessionAvailable;
		})
		.then(function() {
			firstPage = _defineFirstPage();
			log && log("First page to open: " + JSON.stringify(firstPage));
		});
	return waiting.waitModal(initTask)
		.then(function() {
			if (sessionAvailable === true) {
				return modules.get("appController").App.initApplicationsList()
					.then(function() {
						// firstPage to force home in case of error (bad url...)
						return modules.get("navHelper").gotoUrl(firstPage.url, firstPage.method, firstPage.options, {
							"firstPage": true
						});
					})
			} else {
				var offline = sessionAvailable === "offline";
				return modules.get("navHelper").gotoUrl("html://login", null, {
					"offline": offline,
					"onLogin": {
						"gotoUrl": firstPage
					}
				});
			}
		})
		.fail(function(e) {
			// needed there
			_onError(e)
		});

}

/**
 * Init low level stuff like locale, native wrapper, modules, ...
 * When this fails, it's a fatal error that cannot be resolved by the user
 */
function _initPlatform() {
	return $.smResolve()
		.then(function() {
			return initThirdParty.init();
		})
		.then(function() {
			return initModules.init();
		})
		.then(function() {
			return native.init();
		})
		.then(function() {
			// After native
			environment.init();
			_nativeApp = native.getModule("nativeApp");
		})
		.then(function() {
			return initStyles.init();
		})
		.then(function(detectedOS) {
			return uiSettings.init(detectedOS);
		})
		.then(function() {
			return initLocale.init();
		})
		.then(function() {
			return initStorage.init();
		});
}

/**
 * Check login session status and connectivity
 * 
 * Resolves with true, "nosession" to force login or "offline"
 * 
 */
function _checkSession() {
	var deferred = $.Deferred();
	var session = modules.get("session");
	var profile;
	var step;

	var nativeApp = native.getModule("nativeApp");
	if (nativeApp) {
		step = nativeApp.getReconnectToken()
			.then(function(loginCookie, sidCookie) {
				if (loginCookie || sidCookie) {
					return session.setReconnectToken(loginCookie, sidCookie);
				}
			});
	} else {
		step = $.smResolve();
	}

	step.then(function() {
			return session.getCurrentUserProfile()
		})
		.then(function(_profile) {
			profile = _profile;
			return App.setUserProfile(profile);
		})
		.then(function() {
			return session.storeUserProfile(profile);
		})
		.then(function() {
			// Fire and forget since we need the token on next login only
			session.nativeStoreReconnectToken();

			deferred.resolve(true);
		})
		.fail(function(result) {
			// Getting user profile failed because we are not authenticated, so it's ok
			if (result.unauthenticated === true) {
				deferred.resolve("nosession");
			} else if (result.offline === true) {
				deferred.resolve("offline");
			} else {
				// Any other error is a "real" failure
				deferred.reject(result);
			}
		});
	return deferred.promise();
}

/**
 * Check if the page to go to after login is given by the url or if we want to go to the home page
 */
function _defineFirstPage() {
	var url;
	var page;

	page = _checkNativeContext();
	if (page) {
		return page;
	}

	try {
		url = jsutils.parseURL(window.location.href);
	} catch (e) {}

	var query = url && url.query;
	var url = query.url;
	var method = query.method || "GET";

	if (url) {
		page = {
			url: url,
			method: method,
			options: null,
			loadOptions: {
				firstPage: true
			}
		}
	} else {
		page = {
			url: "html://home"
		}
	}

	return page;
}

function _checkNativeContext() {
	if (_nativeApp) {
		log && log("Native app, check for context")
		var contextToRestore = _nativeApp.getReconnectContext();
		if (contextToRestore) {
			var obj;
			if (typeof contextToRestore === "string") {
				try {
					obj = JSON.parse(contextToRestore);
				} catch (e) {}
			} else {
				obj = contextToRestore;
			}
		}
		if (obj && obj.url) { // Sanity check
			var ctxString = JSON.stringify(obj);
			log && log("Native app, context: " + ctxString);
			return {
				url: "context://" + encodeURIComponent(contextToRestore),
				options: null,
				loadOptions: {
					firstPage: true
				}
			};
		}
	}
}
});

