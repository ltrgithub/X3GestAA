define('syracuse-tablet/html/js/ui/uiUtils',['require','exports','module'],function (require, exports, module) {
//empty dom
var _empty = function(domNode) {
	if (domNode) {
		while (domNode.firstChild) {
			domNode.removeChild(domNode.firstChild);
		}
	}
};
//add or remove class to dom element
var _toggleClass = function(item, css, show) {
	if (item) {
		var className = item.className;
		if (show) {
			if (className.indexOf(css) < 0) {
				item.className = className + (" " + css);
			}
		} else {
			item.className = className.replace(css, "");
		}
	}
};

var _waitDefOpts = {
	className: 'waiting-circles',
	elements: 8,
	radius: 30,
	auto: true
};
/**
 * Wait plugin for global application only (no current page or application)
 */
var _waitGlobal = null;
var _wait = function(waitObject, start) {
	if (waitObject == null) {
		// use only if no current application otherwise use page's wait plugin
		if (_waitGlobal == null) _waitGlobal = _waitWheelCreate($(document.body));
		waitObject = _waitGlobal;
	}
	if (start) {
		waitObject.$$bckg.show();
		_waitPluginStatus(waitObject.$$wheel, "enable");
	} else {
		waitObject.$$bckg.hide();
		_waitPluginStatus(waitObject.$$wheel, "disable");
	}
};

var _waitWheelCreate = function($$parent, opts) {
	var waitObject = {
		$$bckg: $('<div class="waiting-background" style="display:none;z-index:2000"></div>'),
		$$wheel: $('<div class="waiting-wheel"  style="display:none;z-index:2000"></div>')
	};
	waitObject.$$bckg.appendTo($$parent);
	waitObject.$$wheel.appendTo($$parent);
	// Initialize plugin
	_waitPluginCreate(waitObject.$$wheel, _waitDefOpts);
	return waitObject;
};
/**
 * Destroy plugin
 */
var _waitPluginDestroy = function($$elmt) {
	/**
	 * We need to check data('waiting') because the plugin is not safe
	 * 	If no data('waiting') it fails
	 * 	That occurs if we remove a parent element of the plugin before destroying the plugin
	 */
	if ($$elmt && $$elmt.data('waiting')) {
		$$elmt.waiting("destroy");
		$$elmt.remove();
	}
};

var _waitPluginStatus = function($$elmt, status) {
	if ($$elmt && $$elmt.data('waiting')) {
		$$elmt.waiting(status);
		$$elmt[status === "disable" ? "hide" : "show"]();
	}
};

var _waitPluginCreate = function($$elmt, opts) {
	if (!opts) throw new Error("opts is mandatory");
	if ($$elmt) $$elmt.waiting(opts);
	return $$elmt;
};
var _waitWheelDestroy = function(waitObject) {
	if (waitObject) {
		_waitPluginDestroy(waitObject.$$wheel);
		if (waitObject.$$bckg) waitObject.$$bckg.remove();
	}
};
/**
 * Returns a dom element
 * - tag : html tag
 * - classList : array of classes
 * - content : dom.textContent
 * - attrList : various attributes list with key,value (JSON format)
 **/

var _createDomElement = function(tag, classList, content, attrList, parent) {
	if (!tag) {
		throw new Error("tag parameter is necessary !");
	}
	// create dom element
	var dom = document.createElement(tag);

	// append classes
	if (classList) {
		if ($.isArray(classList)) {
			$.each(classList, function(index, className) {
				dom.className += className + (index == classList.length - 1 ? "" : " ");
			});
		} else {
			if (typeof classList !== 'string') {
				throw new Error("classList parameter must be an array or a string");
			} else {
				dom.className += classList;
			}
		}
	}

	// set content
	dom.textContent = content ? content : "";

	if (tag === "a" || tag === "img") {
		// Disable drag - true by default for a and img
		attrList = attrList || {};
		attrList.draggable = "false";
	}
	if (attrList) {
		$.each(attrList, function(key, value) {
			dom.setAttribute(key, value);
		});
	}

	if (parent) {
		if (parent.jquery) {
			parent = parent.append(dom);
		} else {
			parent.appendChild(dom);
		}
	}

	return dom;
};

var _appendTextNode = function(e, text) {
	if (!e) return;
	var t = document.createTextNode(text || "");
	if (e.jquery) {
		e = e.append(t);
	} else {
		e.appendChild(t);
	}
	return e;
};
var _buildDom = function(domDesc, parent) {
	$.each(domDesc, function(nodeName, value) {
		var dom = _createDomElement(nodeName, value.classList, value.textContent, value.attr, parent);
		if (value.children) {
			$.each(value.children, function(index, childElement) {
				_buildDom(childElement, dom);
			});
		}
	});
};

exports.empty = _empty;
exports.toggleClass = _toggleClass;

exports.waitWheelStart = function(waitObject) {
	_wait(waitObject, true);
};
exports.waitWheelStop = function(waitObject) {
	_wait(waitObject, false);
};

exports.waitWheelCreate = _waitWheelCreate;
exports.waitWheelDestroy = _waitWheelDestroy;

/** Wait plugin SAFE call - SAFE if plugin has been remove from DOM*/
exports.waitPluginDestroy = _waitPluginDestroy;
exports.waitPluginCreate = _waitPluginCreate;
exports.waitPluginDisable = function($$elmt) {
	_waitPluginStatus($$elmt, "disable");
};
exports.waitPluginEnable = function($$elmt) {
	_waitPluginStatus($$elmt, "enable");
};

exports.createDomElement = _createDomElement;
exports.buildDom = _buildDom;

exports.appendTextNode = _appendTextNode;
/**
 * Trigger a global resize event for application
 * All layouts will be updated
 */
exports.triggerResizeInternal = function(opts) {
	$(window).triggerHandler("resizeInternal", [opts]);
};
});

define('syracuse-tablet/html/js/helpers/winjs',['require','exports','module'],function (require, exports, module) {

var _activeNotifications = {};
var _requestCounter = 0;

/* 
    this function is the global callback hook for WinJS to trigger callbacks started by callWinJS function
*/
var _winjsCallbackHook = function(param) {
	if (!param) {
		// todo error
		return;
	}

	var data;
	try {
		data = JSON.parse(param);
	} catch (e) {
		// todo error
		return;
	}
	if (!data.$uuid) {
		// todo error
		return;
	}

	// recover stored callback information to route callback
	var $active = _activeNotifications[data.$uuid];
	if (!$active) {
		// todo error
		return;
	}
	delete _activeNotifications[data.$uuid];
	if (!$active.$deferred) {
		// no error
		return;
	}
	if (data.$error) {
		$active.$deferred.reject(data.$error);
	} else {
		$active.$deferred.resolve(data.$data);
	}
};

var _callWinJS = function(domain, funcName, parameterObject, fireAndForget) {
	var deferred = $.Deferred();
	if (_isAvailable()) { // do we have an winJs container?
		_requestCounter = _requestCounter + 1;

		var $invoke = {
			$domain: domain,
			$funcName: funcName,
			$uuid: "" + _requestCounter,
			$data: parameterObject,
			$execCallback: !fireAndForget
		};

		var param = JSON.stringify($invoke);
		var $active;
		if (fireAndForget !== true) {
			$active = {
				$uuid: $invoke.$uuid,
				$deferred: deferred
			};
			_activeNotifications[$active.$uuid] = $active;
		}

		window.external.notify(param);

		if (fireAndForget === true) {
			deferred.resolve();
		}
	} else {
		deferred.reject({
			$message: "No WinJS container"
		});
	}
	return deferred.promise();
};

var _isAvailable = function() {
	try {
		return ("notify" in window.external);
	} catch (e) {
		// Safari
		return false;
	}
};

// Register callback hook on window object to be available "globally" from outside the web view control
if (window) {
	window.winjsCallbackHook = _winjsCallbackHook;
}

exports.callWinJS = _callWinJS;
exports.isAvailable = _isAvailable;
});

define('syracuse-tablet/html/js/helpers/jsutils',['require','exports','module'],function (require, exports, module) {
/*
 * This module must only contain low level helper functions that do not have any dependencies!
 */

var _isInstanceOf = function(o, name) {
	var ctor = o.constructor;
	if (ctor && ctor.$smClasses) {
		return ctor.$smClasses.indexOf(name) > -1;
	}
	return false;
};

var _addInheritanceInfo = function(ctor, parent) {
	var classes = [];
	/*
	Does not work in IE 10
	function walk(obj) {
		var name = obj && obj.constructor && obj.constructor.name;
		if (name && name !== "Object") {
			classes.push(name);
			var proto = obj.constructor.prototype && obj.constructor.prototype.__proto__;
			if (proto) {
				walk(proto);
			}
		}
	}
	if (ctor.name) {
		classes.push(ctor.name);
		walk(ctor.prototype.__proto__);
		ctor.$smClasses = classes;
	}
	*/
	if (ctor.name) {
		classes.push(ctor.name);
		if (parent && parent.$smClasses) {
			var i;
			for (i = 0; i < parent.$smClasses.length; i++) {
				classes.push(parent.$smClasses[i]);
			}
		}
	}
	ctor.$smClasses = classes;
};

var _isError = function(o) {
	return o && Error.prototype.toString === o.toString;
};

var _isException = function(o) {
	return o && o.constructor && o.constructor.name === "DOMException";
};

/** 
 * Clean error stack from current base url and limit the size due to the use of deferred
 * html: true -> Display in Html
 **/
var _stackRegexp;
var _cleanStack = function(stack, max, html) {
	if (Array.isArray(stack)) return stack;
	var globals = window.$sm;
	if (!globals) return stack;
	if (!_stackRegexp && globals && globals.baseLocation()) {
		_stackRegexp = {
			r1: new RegExp(globals.baseLocation().withPath, "g"),
			r2: new RegExp(globals.baseLocation().requirePath, "g")
		};
	}

	max = max == null ? 5 : max;
	if (stack) {
		var array = (stack.split && stack.split("\n")) || stack;;
		var res;
		if (array.length > 0) {
			array.forEach(function(l) {
				var pos1 = l.lastIndexOf(".js");
				if (pos1 > 0) {
					var pos2 = l.lastIndexOf("/", pos1);
					if (pos1 > 0) {
						if (!res) res = [];
						res.push(l.substring(pos2));
					}
				} else {
					// Unknown line format (to include details at end of stack, just add line here)
					if (!res) res = [];
					res.push(l);
				}
			});
		}
		if (!res && _stackRegexp) {
			stack = _stackRegexp ? stack.replace(_stackRegexp.r1, "").replace(_stackRegexp.r2, "") : stack;
		} else {
			stack = res.join('\n');
		}
	} else {
		stack = "";
	}
	stack = stack.split("\n");
	if (max) { // Allow max level of source stack files, stack elements not pointing to a file are always added since the may include important information
		res = [];
		stack.forEach(function(l) {
			if (l.indexOf(".js") > -1) {
				if (max > 0) {
					res.push(l);
					max--;
				}
			} else {
				res.push(l);
			}
		});
		stack = res.join(html ? "<br>&nbsp&nbsp&nbsp&nbsp&nbsp" : "\n");
	}
	return stack;
};

/*
 * Takes what ever is passed as parameter and creates an object containing and $diagnoses array
 * title: Always a string
 * e: String or Error or any kind of object*
 *
 * object*:
 * {
 *   message: "text",
 *   detail: Error or Object
 * }
 *
 */
var _convertToDiagnoses = function(title, e) {

	// Handle case where first parameter is an Error
	if (_isError(title) && e == null) {
		e = title;
	}

	if (e == null) {
		// Nothing, only title
		return {
			$diagnoses: [{
				$severity: "error",
				$message: title
			}]
		};
	} else if (typeof e === "string") {
		// String message
		return {
			$diagnoses: [{
				$severity: "error",
				$message: e
			}]
		};
	} else if (_isError(e) || _isException(e)) {
		// Exception to diagnoses
		return {
			$diagnoses: [{
				$message: e.message,
				$stackTrace: _cleanStack(e.stack),
				$severity: "error"
			}]
		};
	} else {
		// If parameter is already an object with diagnoses, do not do anything special
		if (e.$diagnoses && Array.isArray(e.$diagnoses)) {
			return e;
		}

		// Arbitrary object
		var res = {
			$diagnoses: [{}]
		};
		var diag = res.$diagnoses[0];
		diag.$message = e.message || title;
		diag.$severity = "error";
		var detail = e.detail;
		if (detail) {
			if (_isError(detail)) {
				if (detail.message) {
					diag.$stackTrace = (diag.$stackTrace ? diag.$stackTrace + "\n" : "") + detail.message;
				}
				if (detail.stack) {
					diag.$stackTrace = (diag.$stackTrace ? diag.$stackTrace + "\n" : "") + _cleanStack(detail.stack);
				}
			} else {
				diag.$stackTrace = (diag.$stackTrace ? diag.$stackTrace + "\n" : "") + JSON.stringify(detail);
			}
		}

		return res;
	}
};

/**
 * return the value of a given path
 * 	path:	String with/without '.' as separator or array of strings
 *  cache: 	null	-> No cache
 * 		    !null	-> object that stores the cache
 */
var _getPropByPath = function(object, path, cache) {
	if (path == null || object == null) return null;
	var pathStr, pathArray;
	if (Array.isArray(path)) {
		if (path.length === 0) return null;
		pathArray = path;
		pathStr = pathArray.join(".");
	} else {
		pathArray = path.split('.');
		pathStr = path;
	}
	if (cache && cache[pathStr] != null) {
		return cache[pathStr];
	}
	// Check parent if needed
	var data = object[pathArray[0]];
	for (var i = 1; i < pathArray.length; i++) {
		if (data == null) return null;
		if (!$.isPlainObject(data) == null) {
			throw new Error('_getPropByPath - Unexpected non-plainobject');
		}
		data = data[pathArray[i]];
	}
	if (cache) {
		cache[pathStr] = data;
	}
	return data;
};


/**
 * simple function bind
 * arguments that follow context are passed to fn call back after the regular parameters
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
	var args = arguments.length > 2 ? Array.prototype.splice.call(arguments, 2) : null;
	return function boundFn() {
		var callBackArgs = arguments;
		if (args && args.length > 0) {
			args.forEach(function(a) {
				Array.prototype.push.call(callBackArgs, a);
			});
		}
		return fn.apply(context ? context : this, callBackArgs);
	};
}
//http://jsperf.com/multi-array-concat/7
// concatArrays(array1, array2, array3...) - accept undefined arguments
exports.concatArrays = function() {
	var args = [];
	for (var i = 0; i < arguments.length; i++) {
		if (arguments[i] != null) args.push(arguments[i]);
	}
	return [].concat.apply([], args);
};
exports.getPropByPath = _getPropByPath;
exports.addInheritanceInfo = _addInheritanceInfo;

/**
 * return true if o is an instance of class 'name'
 * Like this process could slow down the application it's better to register only classes for which we want to check instance
 */
exports.isInstanceOf = _isInstanceOf;

exports.isError = _isError;

exports.cleanStack = _cleanStack;

exports.convertToDiagnoses = _convertToDiagnoses;

exports.bindFn = bindFn;
});

define('syracuse-tablet/html/js/helpers/logger',['require','exports','module','syracuse-tablet/html/js/helpers/winjs','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {

var winjs = require('syracuse-tablet/html/js/helpers/winjs');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

var _log;

if (winjs.isAvailable()) {
	_log = function() {
		var args = [];
		for (var i = 0; i < arguments.length; i++) {
			args.push(arguments[i]);
		}
		winjs.callWinJS("logger", "log", {
			"args": args
		}, true);
	};
} else {
	_log = function() {
		var text = [];
		for (var i = 0; i < arguments.length; i++) {
			var a = arguments[i];
			if (a != null) {
				if (jsutils.isError(a))
					console && console.log && console.log(a.message, "\n", jsutils.cleanStack(a.stack));
				else
					text.push(a);
			}
		}
		console && console.log && console.log(text.join(text, " "));
	};
}
if (window) {
	window.logger = _log;
}

function _getLogger(module, force) {
	if (!(force === true)) {
		return null;
	}
	var logger = function() {
		var text, errs;
		for (var i = 0; i < arguments.length; i++) {
			if (jsutils.isError(arguments[i])) {
				if (!errs) errs = [];
				errs.push(arguments[i]);
			} else {
				if (!text) text = ["[" + module + "]: "];
				text.push(arguments[i]);
			}
		}
		if (text && text.length > 1) _log(text.join(" "));
		if (errs) {
			errs.forEach(function(e) {
				_log("[" + module + "]: " + e.message);
				if (e.stack) _log(jsutils.cleanStack(e.stack));
			});
		}
	};
	return logger;
}

exports.log = _log;
exports.getLogger = _getLogger;
});

define('syracuse-tablet/html/js/helpers/uiSettings',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
// No required here
var _cache = {};
var _getProp = function(path, device, orientation) {
	if (path == null || arguments.length === 0) return null;
	var res = jsutils.getPropByPath(_settings.gen, path, _cache);
	if (res == null) return null;
	if (device && res[device]) {
		res = res[device];
	}
	if (orientation && res[orientation]) {
		res = res[orientation];
	}
	if (typeof res === "function") {
		res = res.call(null, device, orientation);
		_cache[Array.isArray(path) ? path.join('.') : path] = res;
	}
	// console.log(path, res);
	return res;
};
/**
 * SETTINGS
 */
var _settings = {
	ios: null,
	android: null,
	windows: null,
	/*
	surface: {
		footer: {
			height: {
				opened: 100,
				closed: 40
			}
		},
		header: {
			height: 100
		}
	},
	*/
	def: {
		hubLayout: {
			groupSpacing: 55,
			landscapeMinHeigth: function() {
				return _getProp("hubGroup.landscapeBaseSize") * 4 + _getProp("hubGroup.landscapePadY") * 5 + 40;
			}
		},
		hubGroup: {
			// Default Base size
			// Allows 8 cells from left to right on Nexus 7 portrait mode, 
			// all other devices use a bigger, recalculated base sizes
			landscapeBaseSize: 66,
			landscapePadX: 8,
			landscapePadY: 8,
			portraitPadX: 8,
			portraitPadY: 8,
			portraitWideMinWidth: 570
		},
		footer: {
			height: 50
		},
		header: {
			height: 50
		},
		breadcrumbs: {
			height: 25
		}
	}
};
/**
 * typeObject 	hubLayout/footer/header/..
 * path			height/groupSpacing...
 * device		tablet/smartphone
 * orientation	portrait/landscape
 */
exports.getProp = _getProp;
exports.init = function(os) {
	_cache = {};
	_settings.gen = $.extend(true, {}, _settings.def, _settings[os]);
};
});

define('syracuse-tablet/html/js/helpers/globals',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/uiSettings'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("globals");
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');

var _metaData;
var _authoringActive;
var _emptyCacheCtx = {
	"$user": "none",
	"$role": "none",
	"$lang": "none"
};

var _devOpts = {
	showUnfoundFields: false
};
var _controllersMap = {};

var _globals = {
	tabletApplication: null,
	userCtx: null,
	isTestEnvironment: false,
	baseLocation: null,
	isDvlpMode: false,
	storage: null,
	cache: null,
	modal: null,
	cacheCtx: $.extend({}, _emptyCacheCtx),
	lookAndFeel: "windows",
	userProfile: {},
};

var _setUserCtx = function(userCtx) {
	log && log("Set user context");
	var ctx = userCtx == null ? $.extend({}, _emptyCacheCtx) : userCtx;

	_globals.cache.setContext(ctx);
	_globals.cacheCtx = ctx;
	return _globals.userCtx = ctx;
};

var _setTabletApplication = function(appObj) {
	if (!appObj) {
		throw new Error("Null tabletApplication object");
	}
	log && log("Set tablet Application object");
	_globals.tabletApplication = appObj;
	return appObj;
};

/**
 * Called by main.js
 */
var _init = function(dvlpMode, storage, cache, utilsModule) {
	_globals.isDvlpMode = dvlpMode;
	var bl = _globals.baseLocation = {};
	bl.host = window.location.protocol + "//" + window.location.host;
	var path = window.location.pathname.split('/').splice(0, 2).join('/');
	bl.withPath = bl.host + path;
	bl.requirePath = bl.host + "/requireJS" + path;
	bl.htmlRoot = bl.withPath + "/html";
	if (utilsModule) bl.query = utilsModule.parseQueryString();
	_globals.isTestEnvironment = window.location.href.indexOf("/syracuse-tablet/test/index.html") > -1;
	_globals.storage = storage;
	_globals.cache = cache;
};
/*************************************************************
 * APPLICATIONS DATA
 ************************************************************/
exports.isLoggedIn = function() {
	return _globals.userCtx != null && _globals.userCtx.$user !== "none";
};
exports.getUserCtx = function() {
	return _globals.userCtx;
};
exports.getGlobalCtx = function() {
	return _globals;
};
exports.getStorage = function() {
	return _globals.storage;
};
exports.getCache = function() {
	return _globals.cache;
};
exports.getCacheCtx = function() {
	return _globals.cacheCtx;
};
exports.getEmptyCacheCtx = function() {
	return _emptyCacheCtx;
};
exports.getEndpoint = function() {
	var ep = _globals.endpoint;
	return ep;
};
exports.setEndpoint = function(ep) {
	_globals.endpoint = ep;
};
exports.$config = function(prop) {
	return _globals.tabletApplication.$config(prop);
};
exports.setUserProfile = function(up) {
	_globals.userProfile = up;
};

exports.getUserProfile = function() {
	return _globals.userProfile;
};
exports.getUserName = function() {
	var up = _globals.userProfile;
	return up && up.user && ((up.user.firstName ? up.user.firstName + " " : "") + up.user.lastName) || "unknown";
};

exports.getUserRole = function() {
	var up = _globals.userProfile;
	return (up && up.selectedRole && up.selectedRole.description) || "";
};

exports.getUserPhotoUrl = function() {
	var up = _globals.userProfile;
	var upPhoto = up && up.user && up.user.photo;
	return upPhoto && up.user.$shortUrl ? up.user.$shortUrl + "/photo" : false;
};

/** 
 * Return the current page of tablet application (not current page in a vignette)
 */
exports.getCurrentPage = function() {
	return _globals.tabletApplication.currentPage;
};
exports.getScrollingDirection = function() {
	var p = exports.getCurrentPage();
	return p.rootLayout && p.rootLayout.$type === "hub" ? p.rootLayout.scrollDirection : "v";
};
exports.getMainPageGestureMgr = function() {
	var p = exports.getCurrentPage();
	if (!p) return null;
	return p.getGestureMgr();
};
/**
 * Set the global that points to the tablet application
 */
exports.setTabletApplication = _setTabletApplication;
/**
 * Returns global tablet application
 * TODO Change the name of getApplication
 */
exports.getApplication = function() {
	return _globals.tabletApplication;
};

/*************************************************************
 * UTILS
 ************************************************************/
exports.setUserCtx = _setUserCtx;

/**
 * Allows access to modal through globals
 */
exports.setModal = function(m) {
	_globals.modal = m;
};
exports.getModal = function() {
	return _globals.modal;
};
/**
 * base url utilities
 * 	baseLocation.host - protocol://host:port
 * 	baseLocation.withPath
 * 	baseLocation.requirePath
 * 	baseLocation.htmlRoot
 * 	baseLocation.query
 */
exports.baseLocation = function() {
	return _globals.baseLocation;
};
/**
 * True is dvlp mode - set the caller of _init function
 */
exports.isDvlpMode = function() {
	return _globals.isDvlpMode;
};

exports.getDvlpOpt = function(name) {
	return _globals.isDvlpMode && _devOpts[name];
};

/**
 * True if modules is loaded by unit test page
 */
exports.isTestEnvironment = function() {
	return _globals.isTestEnvironment;
};
/**
 * set/returns look and feel id : windows | android | ios
 */
exports.setLookAndFeel = function(lookAndFeel) {
	uiSettings.init(lookAndFeel);
	_globals.lookAndFeel = lookAndFeel;
};
exports.getLookAndFeel = function() {
	return _globals.lookAndFeel;
};
exports.getSiteLayout = function() {
	return _globals.siteLayout;
};
exports.setSiteLayout = function(sl) {
	_globals.siteLayout = sl;
};
exports.isSmartphone = function() {
	return _globals.siteLayout.getDeviceType() === "smartphone";
};
exports.isTablet = function() {
	return _globals.siteLayout.getDeviceType() === "tablet";
};
exports.setMetaData = function(metaData) {
	_metaData = metaData;
};
exports.getMetaData = function() {
	return _metaData;
};
exports.addController = function(c) {
	if (!c) return;
	if (!_controllersMap) _controllersMap = {};
	if (_controllersMap[c.id]) throw new Error("Controller already exists [" + c.id + "]");
	_controllersMap[c.id] = c;
	return c;
};
exports.removeController = function(c) {
	if (!c || !_controllersMap) return;
	delete _controllersMap[c.id];
	return c;
};
exports.getController = function(id) {
	if (!id || !_controllersMap) return null;
	return _controllersMap[id];
};

/*
 * Set/Check if authoring mode is active or not to change behaviour of modals
 */
exports.setAuthoringActive = function(status) {
	_authoringActive = status;
};

exports.isAuthoringActive = function() {
	return _authoringActive;
};


/*************************************************************
 * STATIQUES
 ************************************************************/
exports.ROWIDXPROP = "~ROWIDX~";
exports.SINGLEARRAYPROP = "~data~";
exports.ACTROWDETAIL = "rowDetail";
exports.ACTCARDDESIGN = "cardDesign";
exports.ACTROWDEL = "rowDelete";
exports.ACTROWSEL = "rowSelect";
exports.RECORDCLASS = "s-m-record";
exports.ACTMULTISEL = "multiSelection";

exports.PANELACTIONSREGULAR = "panelactionregular";
exports.PANELUSERSMARTPHONE = "panelusersmartphone";
exports.PANELFILTERSORT = "panelfiltersort";
exports.EXCLUDEFIELDS = ["CREUSR", "CREUSR_REF", "UPDUSR", "UPDUSR_REF"];

/*************************************************************
 * INIT
 ************************************************************/
/* Initialization by main.js */
exports.init = _init;
if (window) {
	window.$sm = exports;
}

exports.X3_SEVERITY_TO_BS = {
	"info": "success",
	"warning": "warning",
	"error": "error"
};

exports.isOnline = function() {
	return navigator.onLine;
};

exports.getBuildTimeStamp = function() {
	// Global function injected by build process in case we use non debug client
	if (window.__sageBuildTimestamp) {
		return window.__sageBuildTimestamp();
	}
	return "dev mode";
};

/*
 * Global settings are settings stored for the current device and are not user or role dependent.
 * The goal of this method is only to store the settings in a global var to make them accessible for sync calls since
 * the are read in an async process
 */
var _globalSettings = {};
exports.setGlobalSettings = function(settings) {
	_globalSettings = settings;
};
exports.getGlobalSettings = function() {
	return _globalSettings;
};
});

define('syracuse-tablet/html/js/helpers/notifications',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("notifs");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
/**
 * publish/subscribe - Observer/Observable pattern with jQuery
 * TODO - !!! Attach a _subscriptions to application and one per page
 * --> Switch the page _subscriptions with the page in order to not notify inactive pages (parent page)
 * Temporarily we check inactive in page notif methods
 *
 **/

var _nameSpace = "sm";
var _subscriptions = {};

var _err = function(e) {
	log && log("Error", e);
	if (typeof e == "string") {
		throw new Error("Notification - " + e);
	} else {
		throw e;
	}
};

/**
 * _callHandler outside _publish function to preserve args if call to multiple objects in the loop
 */
var _callCheck = function(object) {
	// Don't notify object that are not active (ex: cached pages)
	if (jsutils.isInstanceOf(object, "Page") && !object.isActive()) return false;
	if (jsutils.isInstanceOf(object, "StructElmt") && (object.controller == null || !object.controller.isActive())) return false;
	return true;
};
var _callHandler = function(callBack, object, args) {
	if (!_callCheck(object)) return;
	return setTimeout(function() {
		callBack.apply(object, args);
	}, 0);
};
var _callHandlerSynch = function(callBack, object, args) {
	if (!_callCheck(object)) return;
	callBack.apply(object, args);
};

/**
 *  publish an event ("sm.login") or an array of events ["sm.login"...]
 * 		Functional Object Subscribers
 * 			 notified through method notifEventname - object.notifLogin, object.notifLogout
 * 		Simple callBack Subscriber
 * 			called with event as first parameter
 * 	Argument that follow events parameter are passed to the Subscriber
 *  If event starts with 'synch.' all the callback will be called synchronously otherwise they will be called asynchronously (setTimeout)
 * */
var _publish = function(events) {
	try {
		if (!events) {
			throw new Error("No topic to publish");
		}
		var events = typeof events === "string" ? [events] : events;
		log && log("Publish " + events.join(" - "));
		var args, subscription, subscription, res;
		var count = 0,
			array;
		var objArgs, args = arguments,
			synch, callHandler;
		events.forEach(function(evt) {
			synch = evt.smStartsWith("synch.");
			if (synch) {
				evt = evt.split("synch.")[1];
				callHandler = _callHandlerSynch;
			} else {
				callHandler = _callHandler;
			}
			array = _subscriptions[evt];
			if (array) {
				array = array.slice();
				for (var i = 0, l = array.length; i < l; i++) {
					subscription = array[i];
					if (subscription.object) {
						if (!objArgs) objArgs = Array.prototype.slice.call(args, 1);
						// Remove first argument and call the method - setTimeout(0) for asynchronism and release call stack
						res = callHandler(subscription.callBack, subscription.object, objArgs);
					} else {
						// call the function with evt as first parameter - setTimeout(0) for asynchronism and release call stack
						args[0] = evt;
						res = callHandler(subscription.callBack, null, args);
					}
					count++;
					// TO SEE - -stop is res = false if ( res === false ) { break; }
				}
			} else {
				// No subscribers is not an error!
				// throw new Error("Unknown notification event " + evt);
			}
		});
	} catch (e) {
		_err(e);
	}
};

/**
 *  publish an event ("sm.login") or an array of events ["sm.login"...]
 * 		Functional Object Subscribers
 * 			 notified through method notifEventname - object.notifLogin, object.notifLogout
 * 		Simple callBack Subscriber
 * 			called with event as first parameter
 * 	Argument that follow events parameter are passed to the Subscriber
 *
 * opts: {
 *   exclude: [objects to not notify]
 * }
 * */
var _publishEx = function(events, opts) {
	try {
		if (!events) {
			throw new Error("No topic to publish");
		}
		var events = typeof events === "string" ? [events] : events;
		log && log("Publish " + events.join(" - "));
		var args, subscription, subscription, res;
		var count = 0,
			array;
		var exclude = opts && opts.exclude || [];
		var objArgs, args = arguments;
		events.forEach(function(evt) {
			array = _subscriptions[evt];
			if (array) {
				array = array.slice();
				for (var i = 0, l = array.length; i < l; i++) {
					subscription = array[i];
					if (subscription.object) {
						if ((!exclude || exclude.indexOf(subscription.object)) < 0) {
							if (!objArgs) objArgs = Array.prototype.slice.call(args, 2);
							// Remove first argument and call the method - setTimeout(0) for asynchronism and release call stack
							res = _callHandler(subscription.callBack, subscription.object, objArgs);
						}
					} else {
						// call the function with evt as first parameter - setTimeout(0) for asynchronism and release call stack
						args[0] = evt;
						res = _callHandler(subscription.callBack, null, args);
					}
					count++;
					// TO SEE - -stop is res = false if ( res === false ) { break; }
				}
			} else {
				// No subscribers is not an error!
				// throw new Error("Unknown notification event " + evt);
			}
		});
	} catch (e) {
		_err(e);
	}
};


/**
 * object subscribes for events (string or array)
 * 		object can be an functional Object or a function
 * 		functional Object must implement a method notifEventName  sm.Login.user -> Method notifLoginUser
 * Events starts with "sm" (sm.login)
 * High priority subscriptions are called first
 */
var _subscribe = function(object, events, priority) {
	if (!events) {
		_err("No topic to publish");
	}
	if (!object) {
		_err("Null object");
	}
	priority = priority || 10;
	var events = typeof events === "string" ? [events] : events;
	log && log("Subscribe " + events.join(" - ") + " - priority=" + priority);
	events.forEach(function(evt) {
		var callBackFct, callBackObj;
		if (typeof object == "function") {
			callBackFct = object;
			callBackObj = null;
		} else {
			callBackObj = object;
			var methodName = evt.split('.');
			if (methodName[0] != _nameSpace) _err("Bad event domain name");
			methodName = $.camelCase("notif-" + methodName.splice(1).join('-'));
			callBackFct = object[methodName];
			if (!callBackFct) {
				_err("Object must implement " + methodName);
			}
		}
		var added = false;
		if (!_subscriptions[evt]) {
			_subscriptions[evt] = [];
		}
		var subscriptionInfo = {
			callBack: callBackFct,
			object: callBackObj,
			priority: priority
		};
		for (var i = _subscriptions[evt].length - 1; i >= 0; i--) {
			if (_subscriptions[evt][i].priority <= priority) {
				_subscriptions[evt].splice(i + 1, 0, subscriptionInfo);
				added = true;
				break;
			}
		}
		if (!added) {
			_subscriptions[evt].unshift(subscriptionInfo);
		}
	});
};

/**
 * object unsubscribes for events
 *  object != null
 * 		Remove all object's subscription for given events
 * 		object can be an Object or a function
 *  object == null
 * 		Remove all subscription for given events
 *  events string or array
 * 		null -> unsubscribe for allevent
 */
var _unsubscribe = function(object, events) {
	if (!events) {
		events = Object.keys(_subscriptions);
	} else if (typeof events == "string") {
		events = [events];
	}

	var propToCheck = typeof object === "function" ? "callBack" : "object";
	events.forEach(function(evt) {
		var array = _subscriptions[evt];
		if (array) {
			var lg = array.length;
			for (var i = 0, l = lg; i < l; i++) {
				if (object == null || array[i][propToCheck] === object) {
					array.splice(i, 1);
					// Adjust counter and length for removed item
					i--;
					l--;
				}
			}
			if (false && lg != array.length) {
				console.log("_unsubscribe ", evt, object == null ? "all" : propToCheck, lg, array.length, _check().total);
			}
		}

	});
};

// Remove all subscription
var _reset = function(object, events) {
	log && log("Reset");
	// For tests
	_unsubscribe(null, null);
	// We could just do _subscriptions = {};
};

// the number of subscriptions per event (for object if != null)
var _check = function(object) {
	var res = {};
	res.total = 0;
	var propToCheck = typeof object === "function" ? "callBack" : "object";
	Object.keys(_subscriptions).forEach(function(key) {
		res.total += _subscriptions[key].length;
		if (object == null) {
			res[key] = _subscriptions[key].length;
		} else {
			res[key] = 0;
			var arr = _subscriptions[key];
			for (var i = 0, l = arr.length; i < l; i++) {
				if (arr[i][propToCheck] === object) res[key] = res[key] + 1;
			}
		}
	});
	return res;
};
/**
 * Notify a specified page or the current one
 * We can't used the standard notification process for pages because we need to notify only one page
 * We can have potentially multiple pages objects (vignettes, disabled pages..)
 * We keep the subscription/publication method to to call asynchronously the method to release the stack
 * TODO - Review/improve later the project according to global needs
 * event: 	only one event
 * page:	second parameter - no parameter for current page
 * arguments:	callback arguments
 */
var _notifyController = function(event, page) {
	try {
		if (!event) throw new Error("_notifyController - Unexpected empty event");
		if (typeof event !== "string") throw new Error("_notifyController - string event expected");
		log && log("notifyController " + event);
		var args;
		if (page !== null) {
			args = Array.prototype.slice.call(arguments, 2);
		} else {
			page = globals.getCurrentPage();
			args = Array.prototype.slice.call(arguments, 1);
		}
		if (!page) throw new Error("_notifyController - Unexpected null page");
		var array = _subscriptions[event];
		if (array) {
			for (var i = 0, l = array.length; i < l; i++) {
				if (array[i].object === page) {
					return _callHandler(array[i].callBack, page, args);
				}
			}
		} else {
			console.log("_notifyController - No sunsciption for event " + event);
		}
	} catch (e) {
		_err(e);
	}
};
exports.check = _check;
exports.reset = _reset;
exports.subscribe = _subscribe;
exports.unsubscribe = _unsubscribe;
exports.publish = _publish;
exports.publishEx = _publishEx;
exports.notifyController = _notifyController;
});

define('syracuse-tablet/html/js/helpers/utils',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {
var globals = require('syracuse-tablet/html/js/helpers/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

var _defineClass = function(constructor, parent, members) {
	function _addMembers(proto, members) {
		for (var name in members || {}) {
			var member = members[name];
			if (typeof member.get === "function" || typeof member.set === "function") {
				Object.defineProperty(proto, name, member);
			} else {
				proto[name] = member;
			}
		}
	}

	if (parent) constructor.prototype = Object.create(parent.prototype);
	constructor.prototype.constructor = constructor;
	_addMembers(constructor.prototype, members);

	// !!! The name of the class is the name of the constructor (function)
	// NOTE: THIS DOES NOT SLOW DOWN THE APPLICATION
	// Classes are defined one time at startup, there classes and baseclasses are then stored in an array only once
	// So isInstanceOf will be fast in the rare cases it is used! No need to add a specific flag on which classes to register
	jsutils.addInheritanceInfo(constructor, parent);
	return constructor;
};

/* Universal UUID - Not readable */
var _UUID = function() {
	return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,
		function(c) {
			var r = Math.random() * 16 | 0,
				v = c == 'x' ? r : (r & 0x3 | 0x8);
			return v.toString(16);
		});
};

var _getCurISODateTime = function() {
	var currentdate = new Date();
	var values = [
		currentdate.getFullYear(), 4, (currentdate.getMonth() + 1), 2,
		currentdate.getDate(), 2,
		currentdate.getHours(), 2,
		currentdate.getMinutes(), 2,
		currentdate.getSeconds(), 2
	];
	var datetime;
	for (var i = 0; i < values.length; i += 2) {
		var val = "" + values[i];
		while (val.length < values[i + 1]) {
			val = "0" + val;
		}
		if (!datetime) {
			datetime = val;
		} else {
			datetime += "-" + val;
		}
	}
	return datetime;
};

/* Return a DOM compliant id */
var _domIdCpt = 0;
var _domId = function(id) {
	return id.replace(/([^\w-_])/g, '_');
};

/* Readable ui for html dom ids */
var _uidCpt = 0;
var _readableuid = function() {
	return _domId($.camelCase((arguments.length > 0 ? Array.prototype.join.call(arguments, '-') + '-' : "") + _uidCpt++));
};


/** Parse an url 
 * !!! no @ character should be present in query params (keep them encoded)
 * There are @ query params in date where clauses
 **/
var _purlOptions = {
	strictMode: false,
	key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "querystring", "anchor"],
	q: {
		name: "query",
		parser: /(?:^|&)([^&=]*)=?([^&]*)/g
	},
	parser: {
		strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
		loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
	}
};
/*
 * {
  "anchor": "", "file": "", "password": "", "user": "", "userInfo": "",
  "querystring": "representation=AQTCRUDM.$edit",
  "directory": "/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies",
  "path": "/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies",
  "relative": "/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies?representation=AQTCRUDM.$edit",
  "port": "8124",
  "host": "pc101329.sagefr.adinternal.com",
  "authority": "pc101329.sagefr.adinternal.com:8124",
  "protocol": "http",
  "source": "http://pc101329.sagefr.adinternal.com:8124/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies?representation=AQTCRUDM.$edit",
  "query": {
    "representation": "AQTCRUDM.$edit"
  }
 */
var _parseURL = function(str) {
	var o = _purlOptions;
	var m = o.parser[o.strictMode ? "strict" : "loose"].exec(str);
	var uri = {};
	var i = 14;

	while (i--) uri[o.key[i]] = m[i] || "";

	uri[o.q.name] = {};
	uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) {
		if ($1) uri[o.q.name][$1] = decodeURIComponent($2);
	});
	return uri;
};

var _urlToString = function(u) {
	if (!u) return "";
	var url = "";
	if (u.protocol && u.host) {
		url += u.protocol + "://" + u.host;
		if (u.port.length != 0) url += ":" + u.port;
	}
	url += u.path;
	var query = "";
	for (var p in u.query) {
		if (query.length != 0) query += "&";
		query += p + "=" + encodeURIComponent(u.query[p]);
	}
	if (query.length != 0) url += "?" + query;
	if (u.anchor) url += "#" + u.anchor;
	return url;
};

/* Parse url QS */
var _qsParser = /([^&=;]*)=?([^&;]*)/g;
var _parseQueryString = function(qs) {
	qs = qs || window.location.search;
	var res = {};
	var qs = decodeURIComponent(qs);
	var ii = qs.indexOf('?');
	if (ii >= 0) {
		qs = qs.substring(ii + 1);
	}
	qs.replace(_qsParser, function($0, $1, $2) {
		if ($1 && $1.length > 0) {
			res[$1] = decodeURIComponent($2);
		}
	});
	return res;
};

/* Encoding/Decoding stuff*/
// TODO - can be improved
var _htmlEncode = function(value) {
	return $('<div/>').text(value).html();
};
var _htmlDecode = function(value) {
	return $('<div/>').html(value).text();
};

/* cleanup all references */
var _unbindObj = function(obj) {
	if (obj == null) return;
	if (obj.jquery) {
		obj.unbind();
		obj.undelegate();
		obj.off();
		obj.remove();
		if (obj.smPageRemoveController) obj.smPageRemoveController();
	}
	notifications.unsubscribe(obj);
};
/**
 *  Resolves expression according to current dataset and prototype
 *  	expression: Syrause SData expression
 *  	dataset: optionnal - DaoSdata object (with value method to chain with a parent) or a simple JSON object
 *  			 if dataset=null prototype must be != null
 *  	prototype: optionnal - PrototypeObject
 * 		searchInParent: true to find variable in parent if not found in dataset #5793
 **/
var _exprRegExp = /\{(.*?)\}/g;
var _execExpression = function(expression, dataset, prototype, searchInParent, level) {
	level = level || 0;
	expression = (expression || "") + "";
	//	TODO  - to remove - FDB - Expresion without brackets must return itself and must not be resolved
	//	if (level === 0 && expression.indexOf("{") < 0 && dataset) {
	//		console.log("NO BRACKET EXPRESSION " + expression);
	//		var value = dataset.getValue ? dataset.getValue(expression) : dataset[expression];
	//		return value == null ? "" : value;
	//	}
	var prevProp = null;
	var res = expression.replace(_exprRegExp,
		function(match, prop) {
			// Search in data first - "{VACBPR}~{LEG}"
			var val = dataset == null ? null : dataset.getValue ? dataset.getValue(prop, undefined, searchInParent) : dataset[prop];
			if (val != null) return val;
			if (!prototype) return "";
			if (prop.smStartsWith('@')) {
				//Case @1234
				return prototype.localization(prop);
			}
			val = prototype.data(prop, dataset, null, true);
			if (val != null && val.indexOf("{") >= 0 && level < 4) {
				// Search in prototype - ex "{@7898}", "{$baseUrl}/$prototype('{$representation}.$thumb')"
				return _execExpression(val, dataset, prototype, searchInParent, level + 1);
			}
			return val == null ? "" : val;
		});
	return res || "";
};

/*
 * Returns of the application is physically running on a desktop PC
 * This function MUST ignore eventually emulation properties set by authoring
 */
exports.isDesktop = function() {
	var agt = navigator.userAgent;
	var mobile = (agt.match(/(iphone|ipod|ipad)/) || agt.match(/(android)/i) || agt.match(/(iemobile)/) || agt.match(/iphone/i) || agt.match(/ipad/i) || agt.match(/ipod/i) || agt.match(/blackberry/i) || agt.match(/bada/i));
	return !mobile;
};

/*
	Extract code from ref field prototype expression {x}
*/
var _extractCode = function($expression) {
	$expression = $expression + "";
	if ($expression.indexOf("{") >= 0) {
		return $expression.slice(1, $expression.length - 1);
	}
	return $expression;
};
/**
 * Only if current pages  is a dashboard
 * return the parent vignette or null
 * we assume that there are no dashboard in vignettes
 */
var _findParentVignette = function($$target, fail) {
	var app = globals.getApplication();
	if (app.currentPage && app.currentPage.isDashboard()) {
		// Find vignette controlId + get vignette control
		var $$v = $$target.closest(".s-m-control.s-m-vignette");
		var vignetteId = $$v.attr("id");
		if (fail && (vignetteId == null || vignetteId.length === 0)) throw new Error("Vignette DOM elmt not found");
		var vignette = app.currentPage.getControl(vignetteId);
		if (fail && !vignette) throw new Error("Vignette not found - id[" + vignetteId + "]");
		return vignette;
	} else if (fail) {
		throw new Error("Current page is not a dashboard");
	}
	return null;
};

/**
 * Given a dom elmt find the parent controller
 * data-controller-id is generated by controller base class to allow to retreive a control
 * Controller is not only a page and we must be able to retrieve it
 */
var _findController = function($$elmt) {
	var $$parent = $$elmt.closest("[data-controller-id]");
	if ($$parent && $$parent.length > 0) {
		var id = $$parent.attr("data-controller-id");
		return globals.getController(id);
	}
	return null;
};
/*
 * Find control instance from DOM element control or layout
 */
var _findControl = function($$ctrl) {
	var controller = _findController($$ctrl);
	if (!controller) {
		return null;
	}
	return controller.getStructElmt($$ctrl.attr("id"));
};
/**
 * True if hammer event has the dir direction
 * dir	h or v
 * 		   -90			+180<-- -->0
 * 			^			       |
 * 			|                 +90
 * -180 <-- -->   0
 */
var _isEvtDirection = function(evt, dir, forceTrueIfNull) {
	// If hammer as no event it's - we can have the case with panup pandown without velocity
	// by default if work with if (ui.isEvtDirection(evt, "v")) return; - null evt means we continue
	if (evt == null) return forceTrueIfNull === true;
	if (evt.angle == null) throw new Error("this is not a hammer.js event");
	if ((evt.angle > 45 && evt.angle < 135) || (evt.angle < -45 && evt.angle > -135)) return dir == "v";
	return dir == "h";
};
/**
 * For authoring - Don't stop shiftKey/altKey used by scrolling
 */
var _stopClickEvent = function(e) {
	return e.shiftKey !== true && e.altKey !== true;
};
var refTime = new Date().getTime();
var _timeLineCfg = {
	"ajax": false,
	"page": false,
	"pageLoader": false
};
var _TimeLine = _defineClass(function(type, id) {
	this.type = type;
	this.id = id;
}, null, {
	log: function(step) {
		var time = new Date().getTime();
		var delta = this._prevTime == null ? 0 : time - this._prevTime;
		this._prevTime = time;
		//console.log(time - refTime, this.type, this.id, step, "elasped=" + (time - this._start), "delta=" + delta);
	},
	start: function(step) {
		this._start = new Date().getTime();
		this.log(step ? "start " + step : "start");
	},
	step: function(step) {
		this.log(step);
	},
	stop: function(step) {
		this.log(step ? "stop " + step : "stop");
	},
	reset: function() {
		this._prevTime = null;
		this._start = null;
		return this;
	}
});
/**
 * type			page, sendHttp
 * id			url, name...
 * forceEnable	true 		Force enable
 * 				false 		Force disabled
 * 				undefined 	check _timeLineCfg[type]
 */
var _getTimeLine = function(type, id, forceEnable) {
	try {
		if (forceEnable === false) return;
		if (forceEnable !== true && _timeLineCfg[type] !== true) return null;
		if (type.indexOf("page") === -1 && id != null) {
			id = id + "";
			var p = id.indexOf("representation=");
			if (p >= 0) {
				id = id.substr(p + 15);
			} else {
				var p = id.indexOf("x3/erp/");
				if (p >= 0) {
					id = id.substr(p + 7);
				} else {
					var p = id.indexOf("collaboration/syracuse/");
					id = id.substr(p + 23);
				}
			}
			id = decodeURIComponent(id);
		}
		return new _TimeLine(type, id);
	} catch (e) {
		console.log(e);
	}
};

var _hasProp = function(obj, key) {
	return Object.prototype.hasOwnProperty.call(obj, key);
};

var _areEqual = function(obj1, obj2, strict) {
	if (strict ? obj1 === obj2 : obj1 == obj2)
		return true;
	if (obj1 == null || obj2 == null)
		return false;
	if (Array.isArray(obj1) && Array.isArray(obj2)) {
		if (obj1.length != obj2.length)
			return false;
		for (var i = 0; i < obj1.length; i++)
			if (!_areEqual(obj1[i], obj2[i]))
				return false;
		return true;
	}

	if (typeof obj1 != "object" || typeof obj2 != "object") return false;
	var combined = $.extend({}, obj1);
	$.extend(combined, obj2);
	for (var i in combined) {
		if (_hasProp(combined, i)) {
			var val1 = obj1[i];
			var val2 = obj2[i];
			if (!_areEqual(val1, val2))
				return false;
		}
	}
	return true;
};

var _typeNamesByMime = {};
var _regExpMimeToType = /-|\//g;
exports.getTypeName = function(mime) {
	var type = _typeNamesByMime[mime];
	if (!type) {
		// used to generate readable ids - type expected "application/x-name" or "text/plain"
		var a = mime.split(_regExpMimeToType);
		type = _typeNamesByMime[mime] = a[a.length - 1];
	}
	return type;
};

exports.areEqual = _areEqual;
exports.stopClickEvent = _stopClickEvent;
exports.isEvtDirection = _isEvtDirection;
exports.extractCode = _extractCode;
exports.UUID = _UUID;
exports.defineClass = _defineClass;
exports.readableuid = _readableuid;
exports.domId = _domId;
exports.parseQueryString = _parseQueryString;
exports.parseURL = _parseURL;
exports.urlToString = _urlToString;
exports.htmlEncode = _htmlEncode;
exports.htmlDecode = _htmlDecode;
exports.getCurISODateTime = _getCurISODateTime;
exports.unbindObj = _unbindObj;
exports.parseExpression = function(expression, dataset, prototype, searchInParent) {
	return _execExpression(expression, dataset, prototype, searchInParent, 0);
};
exports.getPropByPath = jsutils.getPropByPath;
exports.findParentVignette = _findParentVignette;
exports.findController = _findController;
exports.findControl = _findControl;
// Used to analyse performances
exports.getTimeLine = _getTimeLine;
});

define('syracuse-tablet/html/js/ajax/ajaxInterface',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {
/*
 * Ajax module (Default browser implementation)
 */


var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("ajax");
var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');

// Locale module passed in init because if dependency cycle
var _locale;

function _AjaxInterface() {};

var _httpStatus = {
	"200": 'Ok',
	"201": 'Created',
	"400": 'Bad Request',
	"401": 'Unauthenticated',
	"403": 'Forbidden',
	"404": 'Not Found',
	"405": 'Method Not Allowed',
	"406": 'Not Acceptable',
	"409": 'Conflict',
	"410": 'Gone',
	"411": 'Length Required',
	"412": 'Precondition Failed',
	"413": 'Request Entity Too Large',
	"414": 'Request URI Too Long',
	"415": 'Unsupported Media Type',
	"422": 'Unprocessable Entity',
	"429": 'Too Many Requests',
	"500": 'Internal Server Error',
	"501": 'Not Implemented',
	"502": 'Bad Gateway',
	"503": 'Service Unavailable',
	"504": 'Gateway Timeout'
};
var _rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg;
var _ajaxInterfaceClass = utils.defineClass(
	_AjaxInterface,
	null, {
		/**
		 *
		 * Parameters:
		 *
		 * method: GET, PUT, POST, DELETE, HEAD
		 * url: http URL
		 * send: Data to send (Objects will be stringified to json on POST and PUT)
		 * headers: headers to add to the request
		 * options: {
		 *   noJsonParsing: true, : Returns response body as string without trying to parse and return an object. (Default: Parse and return object)
		 *   timeout: 1000 : Request timeout (Default: 0)
		 *   dontCatchHttp401: true (Default: false): true = Return 401 to caller instead of redirecting to login page
		 * }
		 *
		 * When promise is resolved, callback gets the following object as parameter:
		 * {
		 *     textStatus: e.g. "success", "errror"
		 *     status: http status code (200, 404, 500, ...)
		 *     descrHttpStatus: description of http status code (e.g. "Internal Server Error")
		 *     isSuccess: true for: status >= 200 && status < 300 || status === 304
		 *     responseJSON: Contains parsed object returned by server (Unless response did not contain JSON or option noJsonParsing was set)
		 *     responseText: Contains response as returned by server (as string)
		 *     headers: { ... } : Contains returned http headers
		 * }
		 *
		 */
		ajax: function(method, url, send, headers, options) {
			var deferred = $.Deferred();
			try {
				method = method ? method.toUpperCase() : "GET";
				if (method === "GET" && send) {
					if (url.indexOf('?') === -1) url += "?";
					var params = [];
					for (var p in send) {
						if (send[p] != null) {
							params.push(encodeURIComponent(p) + "=" + encodeURIComponent(send[p].toString()));
						}
					}
					url += params.join('&');
				}
				options = options || {};
				var doAjax = function() {
					try {
						var lang = _locale && _locale.getCurrentLocale();
						var allHeaders = {
							"Accept": "application/json;vnd.sage=syracuse",
						};
						if (lang) {
							allHeaders["Accept-Language"] = lang;
						}
						if (headers) {
							$.extend(allHeaders, headers);
						}
						// TODO: Authentication
						var ajaxData = {
							headers: allHeaders,
							type: method,
							url: url,
							timeout: options.timeout == null ? 0 : options.timeout
							//processData : false
						};
						if (["PUT", "POST"].indexOf(method) >= 0 && send != null) {
							ajaxData.contentType = options.contentType || "application/json;charset=utf-8";
							if (ajaxData.contentType.indexOf("application/json") >= 0 && typeof send === "object") {
								try {
									send = JSON.stringify(send);
								} catch (e) {
									throw new Error("Error parsing send data\nurl: " + url);
								}
							};
							ajaxData.data = send;
						}
						var timeLine = utils.getTimeLine("ajax", url);
						timeLine && timeLine.start("send");
						// We need this option to deal with non-json data
						var parseJson = allHeaders.Accept.indexOf("application/json") >= 0 && options.noJsonParsing !== true;
						if (parseJson) {
							ajaxData.dataType = "json";
						}
						log && log("'" + method + "':" + url);
						// $.ajax is replaced after startup to ensure the module  ajax/ajax.is used since $.ajax will not work
						// in winJS container because of blocked CORS.
						// Here, it's ok to use $.ajax since if we are in a winJS container, this function will be replaced by a
						// function that redirects the call to a winJS function.
						// If we end up here, we are sure we are in standalone browser mode and $.ajax will work as usually

						var ajax = $.ajax_original || $.ajax;
						var promise = ajax(ajaxData);
						promise.complete(function(jqXHR, textStatus) {
							try {
								timeLine && timeLine.step("completed");
								var status = jqXHR.status != null ? jqXHR.status : textStatus == "success" ? 200 : 500;
								var result = {
									textStatus: textStatus,
									status: status,
									descrHttpStatus: _httpStatus[status] || ("unknown: " + status),
									isSuccess: status >= 200 && status < 300 || status === 304,
									headers: {}
								};
								if (parseJson) {
									result.responseJSON = jqXHR.responseJSON;
								} else {
									result.responseText = jqXHR.responseText;
								}
								var match, headerStr = jqXHR.getAllResponseHeaders();
								if (headerStr) {
									while ((match = _rheaders.exec(headerStr))) {
										result.headers[match[1].toLowerCase()] = match[2];
									}
								}
								if (status === 401 && !(options.dontCatchHttp401 === true)) {
									_handleHttp401(deferred, result);
								} else {
									deferred.resolve(result);
								}
							} catch (e) {
								deferred.reject(e);
								return;
							}
						});
					} catch (e) {
						globals.getModal().error("ajax.doAjax error", e, function() {
							deferred.resolve(e);
						});
					} finally {
						return promise;
					}
				};

				doAjax();
			} catch (e) {
				globals.getModal().error("ajax error", e, function() {
					deferred.reject(e);
				});
			} finally {
				return deferred.promise();
			}
		}
	}
);

exports.AjaxInterfaceClass = _ajaxInterfaceClass;

/*
 * config
 * locale moduel syracuse-tablet/html/js/helpers/locale passed as parameter because of dependencies
 *
 */
exports.init = function(config, locale) {
	_locale = locale;
	config = config || {};
	$.ajaxSetup({
		timeout: config.timeout == null ? 20000 : config.timeout,
		async: true
	});
};

/*
 *
 */
function _handleHttp401(deferred, result) {
	if (globals.isTestEnvironment()) {
		deferred.reject("Please login before running this testcase");
		return;
	}
	var responseJSON = result.responseJSON;
	if (!responseJSON) {
		try {
			responseJSON = JSON.parse(result.responseText);
		} catch (e) {} // if we cannot parse, we will not get a diag below and let the error bubble up
	}
	var diag = responseJSON && responseJSON.$diagnoses && responseJSON.$diagnoses[0];
	var link = diag && diag.$links && diag.$links.$redirect;
	if (!link) { // Response unexpected, resume original chain any maybe report error
		deferred.resolve(result);
		return;
	}

	var diag = {
		$message: _locale.text("error.session.timeout"),
		$severity: "error",
		$links: {
			$redirect: link
		}
	};
	responseJSON = responseJSON || {};
	/* We only set our own diag on 401 and do not add it to the one comming from the server
	responseJSON.$diagnoses = responseJSON.$diagnoses || [];
	responseJSON.$diagnoses.unshift(diag);
	*/
	responseJSON.$diagnoses = [diag];
	responseJSON.$redirectPage = "login";

	result.responseJSON = responseJSON;
	deferred.resolve(result);
}
});

define('syracuse-tablet/html/js/ajax/ajaxWinJS',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/winjs'],function (require, exports, module) {
/*
 * Ajax module for winJS
 */


var utils = require('syracuse-tablet/html/js/helpers/utils');
var winjs = require('syracuse-tablet/html/js/helpers/winjs');

var _ajax;

function _AjaxWinJSInterface() {};

var _ajaxWinJSInterfaceClass = utils.defineClass(
	_AjaxWinJSInterface,
	null, {
		ajax: function(method, url, send, headers, options) {

			// TODO: Temporarily to distinguish local and remote http resources 
			if (url.indexOf("/syracuse-tablet") !== 0) {
				url = "http://localhost:8124" + url;
			}
			var deferred = $.Deferred();
			method = method || "GET";

			var allHeaders = {
				"Accept": "application/json;vnd.sage=syracuse"
			};
			if (headers) {
				$.extend(allHeaders, headers);
			}

			var data = {
				"$method": method || "GET",
				"$url": url,
				"$send": send,
				"$headers": allHeaders,
				"$options": options
			};
			winjs.callWinJS("winjsAjax", "ajax", data).then(function(data) {
				// WinJS call succeeded, this does not mean ajax call succeeded!

				var respHeaders = {
					"status": data.$status,
					"location": (data.$headers && data.$headers["location"]) || ""
				};

				if (data.$succeeded) {
					deferred.resolve(data.$data, respHeaders);
				} else {
					deferred.reject(data.$status, respHeaders);
				}
			}).fail(function(error) {
				// WInJS call failed!
				deferred.reject(500, {});
			});

			return deferred.promise();
		}
	}
);

exports.AjaxInterfaceClass = _ajaxWinJSInterfaceClass;
exports.init = function(config, locale) {

};
});

define('syracuse-tablet/html/js/ajax/ajax',['require','exports','module','syracuse-tablet/html/js/helpers/winjs','syracuse-tablet/html/js/ajax/ajaxInterface','syracuse-tablet/html/js/ajax/ajaxWinJS'],function (require, exports, module) {
/*
 * Ajax module
 */


var winJS = require('syracuse-tablet/html/js/helpers/winjs');
var ajaxInterface = require('syracuse-tablet/html/js/ajax/ajaxInterface');
var ajaxWinJS = require('syracuse-tablet/html/js/ajax/ajaxWinJS');

var _ajax;

exports.getAjax = function() {
	if (!_ajax) {
		if (winJS.isAvailable()) {
			_ajax = new ajaxWinJS.AjaxInterfaceClass();
		} else {
			_ajax = new ajaxInterface.AjaxInterfaceClass();
		}
	}
	return _ajax;
};

exports.init = function(config, locale) {
	if (winJS.isAvailable()) {
		ajaxWinJS.init(config, locale);
	} else {
		ajaxInterface.init(config, locale);
	}
};
});

define('syracuse-tablet/html/js/helpers/locale',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ajax/ajax'],function (require, exports, module) {

var globals = require('syracuse-tablet/html/js/helpers/globals');
var ajax = require('syracuse-tablet/html/js/ajax/ajax').getAjax().ajax;

var _currentLocale = null;
var _resources = {};

var _datetimeInformationKey = "$datetimeInformation";
var _decimalInformationKey = "$decimalInformation";
var _upLocalePreferences;

var _txtRegexp = /\{([\w-]+)\}/g;
var _localeHashUser = "*";

var _userProfileSettings = {};
var _userLocales = {};


function _getResourcesBasePath() {
	if (document.location.href.indexOf("index_debug.html") < 0) {
		return "/syracuse-tablet/dist/";
	} else {
		return "/syracuse-tablet/html/";
	}
}

var _text = function(key, args) {
	var resources = _resources && _resources[_currentLocale];
	if (!resources) {
		return;
	}
	//	if (!resources[key]) {
	//		console.log(key);
	//	}
	var text = resources[key] || "Resource key not found[" + key + "]";

	if (args) {
		text = text.replace(_txtRegexp, function(match, p1) {
			var idx = +p1;
			if (idx >= 0 && idx < args.length) {
				return args[idx];
			}
			return "?";
		});
	}

	return text;
};

var _textNoFail = function(key, args) {
	var resources = _resources && _resources[_currentLocale];
	if (!resources || !resources[key]) {
		return null;
	}
	var text = resources[key];
	if (args) {
		text = text.replace(_txtRegexp, function(match, p1) {
			var idx = +p1;
			if (idx >= 0 && idx < args.length) {
				return args[idx];
			}
			return "?";
		});
	}
	return text;
};

var _textOpt = function(key) {
	var resources = _resources && _resources[_currentLocale];
	if (!resources) {
		return;
	}
	return resources[key];
};

var _getDatetimeInfo = function() {
	var resources = _resources && _resources[_currentLocale];
	if (!resources) {
		return;
	}
	return resources[_datetimeInformationKey];
};

var _getDecimalInfo = function() {
	var resources = _resources && _resources[_currentLocale];
	if (!resources) {
		return;
	}
	return resources[_decimalInformationKey];
};

var _setLocale = function(locale, upLocalePreferences) {
	var deferred = new $.Deferred();
	_upLocalePreferences = upLocalePreferences;

	// Everytime a locale is set, the user is remembered
	// this is because formatters created afterwards are cached
	// and need to be linked to locale + user (because of user defined locale settings)
	// See getCurrentLocaleHash()
	var ctx = globals.getUserCtx();
	_localeHashUser = ctx && ctx.$user || "*";
	_userProfileSettings = _userLocales[locale] || {};

	var resources = _resources && _resources[locale];
	if (resources) {
		_currentLocale = locale;
		deferred.resolve();
	} else if (locale === _currentLocale) {
		deferred.resolve();
	} else {
		_loadFile(_getResourcesBasePath() + "js/resources", "strings", locale, "en")
			.then(function(data) {
				_currentLocale = locale;
				_resources[locale] = data;
			})
			.then(function() {
				return _loadFile(_getResourcesBasePath() + "js/resources/locales", "date", locale, "en-GB");
			})
			.then(function(data) {
				// join strings-xx-XX and date-xx-XX
				_resources[locale][_datetimeInformationKey] = data;
			})
			.then(function() {
				return _loadFile(_getResourcesBasePath() + "js/resources/locales", "decimal", locale, "en-GB");
			})
			.then(function(data) {
				// join strings-xx-XX and decimal-xx-XX
				_resources[locale][_decimalInformationKey] = data;
			})
			.then(function() {
				deferred.resolve();
			}).fail(function(e) {
				deferred.resolve();
			});
	}
	return deferred.promise();
};

var _loadFile = function(path, file, locale, defLocale) {
	var deferred = new $.Deferred();
	var segs = locale.split("-");

	function _load() {
		if (segs.length === 0) {
			// Fallback to default
			var url = path + "/" + file + "-" + defLocale + ".json";
			ajax("GET", url, null, null)
				.then(function(data) {
					if (data && data.responseJSON) {
						deferred.resolve(data.responseJSON);
					}
					deferred.resolve({});
				}).fail(function(e) {
					deferred.reject(e);
				});
		} else {
			var code = segs.join("-");
			var url = path + "/" + file + "-" + code + ".json";
			ajax("GET", url, null, null)
				.then(function(data) {
					if (data && data.responseJSON) {
						deferred.resolve(data.responseJSON);
					} else {
						segs.pop();
						_load();
					}
				}).fail(function(e) {
					segs.pop();
					_load();
				});
		}
	}
	_load();
	return deferred.promise();
};

var _isCurrent = function(locale, strict) {
	if (!locale || !_currentLocale) return false;
	if (_currentLocale === locale) return true;
	return strict ? false : (locale.split('-'))[0] === _currentLocale;
};

/*
 * TODO: Use prefered format from _upLocalePreferences if set
 */
exports.getDateFormat = function() {
	var di = _getDatetimeInfo();
	return _userProfileSettings.shortDate || (di && di.formatPatterns && di.formatPatterns.shortDate) || "dd/MM/yyyy";
};

exports.getDateTimeFormat = function() {
	var di = _getDatetimeInfo();
	var date = _userProfileSettings.shortDate || (di && di.formatPatterns && di.formatPatterns.shortDate) || "dd/MM/yyyy";
	var time = _userProfileSettings.shortTime || (di && di.formatPatterns && di.formatPatterns.shortTime) || "HH:mm:ss";
	return date + " " + time;
};
exports.getTimeFormat = function() {
	var di = _getDatetimeInfo();
	return _userProfileSettings.longTime || (di && di.formatPatterns && di.formatPatterns.longTime || "HH:mm:ss");
};
exports.getTimeFormatShort = function() {
	var di = _getDatetimeInfo();
	return _userProfileSettings.shortTime || (di && di.formatPatterns && di.formatPatterns.shortTime || "HH:mm");
};

exports.getNumberFormat = function(type) {
	return (type === "application/x-integer" ? "#,##0" : "#,##0.##");
};

exports.getNumberGroupSeparator = function() {
	var di = _getDecimalInfo();
	var gs = _userProfileSettings.numberGroupSeparator || (di && di.numberGroupSeparator) || ",";
	return gs;
};

exports.getNumberDecimalSeparator = function() {
	var di = _getDecimalInfo();
	var ds = _userProfileSettings.numberDecimalSeparator || (di && di.numberDecimalSeparator) || ".";
	return ds;
};

exports.setLocale = _setLocale;
exports.text = _text;;
exports.textNoFail = _textNoFail;
exports.textOpt = _textOpt;
exports.isCurrent = _isCurrent;

// Get Month names, etc for parsers
exports.getDatetimeInfo = _getDatetimeInfo;
exports.getCurrentLocale = function() {
	return _currentLocale;
};
exports.getCurrentLocaleHash = function() {
	return _currentLocale + "#" + _localeHashUser;
};

exports.setUserLocales = function(locales) {
	_userLocales = {};
	if (locales) {
		locales.forEach(function(locale) {
			_userLocales[locale.code] = {
				shortDate: locale.shortDate,
				shortTime: locale.shortTime,
				longTime: locale.longTime,
				numberDecimalSeparator: locale.numberDecimalSeparator,
				numberGroupSeparator: locale.numberGroupSeparator
			};
		});
	}
};
});

define('syracuse-tablet/html/js/ui/rect',['require','exports','module','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');

var _Klass = utils.defineClass(function rect(top, left, height, width) {
	this.top = top;
	this.left = left;
	this.setHeight(height);
	this.setWidth(width);
}, null, {
	// Accept null for x or y 
	isPointInside: function(x, y) {
		return (x == null || (x >= this.left && x <= this.right)) && (y == null || (y >= this.top && y <= this.bottom));
	},
	/**
	 * rectOffset!=null means that the main has scrolled and we need to to correct the coordinates because pageX/pageY are relative document
	 */
	isEvtInside: function(evt, rectOffset) {
		if (evt.type.smStartsWith("touch")) {
			// Touch events are managed completely differently from mouse events - depends on the number of fingers in contact...
			if (evt.changedTouches && evt.changedTouches.length === 1) {
				evt = evt.changedTouches[0];
			} else if (evt.touches && evt.touches.length === 1) {
				evt = evt.touches[0];
			} else {
				// No control -> OK
				return true;
			}
		}
		var y = rectOffset != null && rectOffset.top != null ? evt.pageY - rectOffset.top : evt.pageY;
		var x = rectOffset != null && rectOffset.left != null ? evt.pageX - rectOffset.left : evt.pageX;
		return this.isPointInside(x, y);
	},
	intersectsWith: function(rect) {
		return this.left <= rect.right && rect.left < this.right && this.top < rect.bottom && rect.top < this.bottom;
	},
	contains: function(rect) {
		if (rect == null) return true;
		return this.isPointInside(rect.left, rect.top) && this.isPointInside(rect.right, rect.bottom);
	},
	equals: function(rect, justSize) {
		if (rect.width === this.width && rect.height === this.height) {
			return justSize === true || (rect.top === this.top && rect.left === this.left);
		}
		return false;
	},
	/**
	 * relative	true/false
	 */
	intersectRect: function(rect, relative) {
		if (!this.intersectsWith(rect)) return null;
		var top = Math.max(this.top, rect.top);
		var left = Math.max(this.left, rect.left);
		var right = Math.min(this.right, rect.right);
		var bottom = Math.min(this.bottom, rect.bottom);
		return new _Klass(relative ? 0 : top, relative ? 0 : left, bottom - top, right - left);
	},
	setHeight: function(h) {
		this.height = Math.max(h, 0);
		this.bottom = this.top + this.height;
	},
	setWidth: function(w) {
		this.width = Math.max(w, 0);
		this.right = this.left + this.width;
	},
	moveLeft: function(l) {
		this.left = this.left + l;
		this.right = this.width + this.left;
	},
	toString: function() {
		return "t:" + this.top + " l:" + this.left + " r:" + this.right + " b:" + this.bottom + " h:" + this.height + " w:" + this.width;
	},
	toRelative: function(offet) {
		if (offet == null) offet = {};
		if (offet.top == null) offet.top = 0;
		if (offet.left == null) offet.left = 0;
		return new _Klass(offet.top, offet.left, this.height, this.width);
	},
	/**
	 * timeoutOrColor	optional
	 * 						timeout in ms to delete the div
	 * 						name/code of border color
	 */
	showInDocument: function(options) {
		options = options || {};
		// To pass has param if needed
		var pos = "fixed";
		var $$parent = $(document.body);
		var $$elmt = $('<div class = "s-m-rect">').appendTo($$parent).css({
			position: pos,
			top: this.top + "px",
			left: this.left + "px",
			height: this.height + "px",
			width: this.width + "px",
			backgroundColor: options.color,
			zIndex: options.zIndex != null ? options.zIndex : undefined
		});
		if (options.timeout != null) {
			setTimeout(function() {
				$$elmt.remove();
			}, options.timeout);
		}
		return $$elmt;
	},
	clone: function() {
		return new _Klass(this.top, this.left, this.height, this.width);
	},
	applyTransformScale: function(scale, clone) {
		if (scale == null || scale <= 0 || typeof scale != "number") return;
		var res = clone === true ? this.clone() : this;
		res.width = res.width * scale;
		res.height = res.height * scale;
		// TODO - left / right - ok if they are equal to 0
		return res;
	}
});
var _meths = {
	outer: ["outerWidth", "outerHeight"],
	inner: ["innerWidth", "innerHeight"],
	computed: ["width", "height"],
	fixed: "position",
	relative: "offset"
};
/**
 * Returns the rectangle of $$elmt
 * 	type:		outer / inner / computed
 * 	position	fixed, relative
 * 	myOffset	my offset to shift the rect if any
 */
exports.elmtRect = function($$elmt, typeRect, position) {
	var o = $$elmt[_meths[position || "relative"]]();
	var m = _meths[typeRect || "outer"];
	return new _Klass(o.top, o.left, $$elmt[m[1]](), $$elmt[m[0]]());
};
exports.newRect = function(top, left, height, width) {
	return new _Klass(top, left, height, width);
};
});

/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  

var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge]
 * @returns {Object} dest
 */
function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
function merge(dest, src) {
    return extend(dest, src, true);
}

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        extend(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument;
    return (doc.defaultView || doc.parentWindow);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = last.deltaX - input.deltaX;
        var deltaY = last.deltaY - input.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.allow = true; // used by Input.TouchMouse to disable mouse events
    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down, and mouse events are allowed (see the TouchMouse input)
        if (!this.pressed || !this.allow) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */
function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        // when we're in a touch event, so  block all upcoming mouse events
        // most mobile browser also emit mouseevents, right after touchstart
        if (isTouch) {
            this.mouse.allow = false;
        } else if (isMouse && !this.mouse.allow) {
            return;
        }

        // reset the allowMouse when we're done
        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
            this.mouse.allow = true;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        // not needed with native support for the touchAction property
        if (NATIVE_TOUCH_ACTION) {
            return;
        }

        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // pan-x and pan-y can be combined
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.id = uniqueId();

    this.manager = null;
    this.options = merge(options || {}, this.defaults);

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        extend(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(withState) {
            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(true);
        }

        emit(); // simple 'eventName' events

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(true);
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = extend({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {
        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        this._super.emit.call(this, input);
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            this.manager.emit(this.options.event + inOut, input);
        }
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 500, // minimal time of the pointer to be pressed
        threshold: 5 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.65,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.velocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.velocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.velocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.direction &&
            input.distance > this.options.threshold &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 2, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED ) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create an manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.4';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, { enable: false }],
        [PinchRecognizer, { enable: false }, ['rotate']],
        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],
        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    options = options || {};

    this.options = merge(options, Hammer.defaults);
    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        extend(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        var recognizers = this.recognizers;
        recognizer = this.get(recognizer);
        recognizers.splice(inArray(recognizers, recognizer), 1);

        this.touchAction.update();
        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    each(manager.options.cssProps, function(value, name) {
        element.style[prefixed(element.style, name)] = add ? value : '';
    });
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

extend(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

if (typeof define == TYPE_FUNCTION && define.amd) {
    define('syracuse-tablet/html/deps/hammerjs-2.0.4/hammer',[],function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');
define('syracuse-tablet/html/js/helpers/hammerScroller',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/deps/hammerjs-2.0.4/hammer'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("scroll", false);
var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var Hammer = require('syracuse-tablet/html/deps/hammerjs-2.0.4/hammer');
var _scrollerId = 1;

var _stopClickEvent = function(mgr, evt, reason) {
	log && log("Clicked canceled", reason, mgr.id);
	evt.stopPropagation();
	evt.preventDefault();
	evt.$stop = true;
};
// Time to wait before allowing click events a scrolling
var _lastClickTO = 400;
// Enable the slowdown process - scroll continue after panend (mouse up ) like on native devices
var _slowDown = true;
// Move the $$elmt after _slowDownTO in slowdown process
var _slowDownTO = 10;
/**
 * returns the distance to move according to velocity v
 */
var _velocityToDist = function(velocity) {
	// Velocity of the move - 0 if we move the finger slowly and ~ 2 for fast - TO IMPROVE REGARDING THE CONTEXT - TOUCH/DESKTOP 
	var v = Math.abs(Math.round(velocity * 4));
	// Distance to move - square function of velocity (non linear) 
	// Allow to move slow and fast if we increase the speed of the finger
	return Math.max(1, v * v / 2);
};
/**
 * Creates a vertical/horizontal scroller which emulates the tablet native behavior
 * 		$$elmt		element to scroll
 * 		options		callBack		Optional Called on event and skip default process
 * 					valMax			maximum top - 0 by default - 50 for pages with header...
 * 					direction		h/v
 * 					isPageScroller	true/false
 * 		parentMgr	parent scroll manager (the page's one for an array scroller)
 * 					used to deal with click event
 * 		$$nativeScroll 	div that will take the native scroll when we disable the scrolling (for test and authoring)
 * 						optional - $elmt if null
 */
var _consts = {
	pan: {
		v: "panup pandown panstart panend",
		h: "panleft panright panstart panend"
	},
	dir: {
		v: Hammer.DIRECTION_VERTICAL,
		h: Hammer.DIRECTION_HORIZONTAL
	},
	upEvt: {
		v: "panup",
		h: "panleft"
	}
};
var _Klass = utils.defineClass(function hammerScroller($$elmt, options, parentMgr, $$nativeScroll) {
	options = options || {};
	this.hammer = null;
	this.$$elmt = $$elmt;
	this.$$nativeScroll = $$nativeScroll || $$elmt;
	if ($$elmt == "null") throw new Error("hammerScroller - null $$elmt");
	this.id = $$elmt.closest("[id]").attr("id");
	// Max top always 0 because we scroll in relative / parent - If needed pass it in parameter
	this.valMax = options.valMax != null ? options.valMax : 0;
	this.name = options.name || "scroller";
	this.parentMgr = parentMgr;
	this.callBack = options.callBack;
	this.isPageScroller = options.isPageScroller === true;
	// Init hammer manager
	this.hammer = new Hammer(this.$$elmt.get(0));
	// Direction of scroller
	if (options.direction) {
		this._initDir(options.direction);
	}
	// evts enabled - false by default
	this._evtsEnabled = false;
	// To allow disable/Enable - General HammerScroller objects - all object will be toggled
	notifications.subscribe(this, ["sm.scroller.toggle"], 1);
}, null, {
	/**
	 * Init direction and associated pan events
	 */
	_initDir: function(direction) {
		this.dir = direction;
		if (this.dir !== "v" && this.dir !== "h") throw new Error("hammerScroller - Unexpected direction [" + this.dir + "]");
		// event than means up or right
		this.upEvtType = _consts.upEvt[this.dir];
	},
	/**
	 * Called before init
	 * I reset the old scrolling on $$elmt before calculating the new viewRect
	 * Init is called in callBack function
	 */
	resetScrolling: function(callBack) {
		if (this.val != null) {
			this.setVal(this.valMax);
			this.refresh();
			this.reset();
		}
		if (callBack) callBack();
	},
	/**
	 * We need to initialize the scroll after creation
	 * Scrollable object arrays/pages have an empty scroll which is initialized if needed
	 * Initialization needs to be called when the object has been displayed (after show) to make sure that viewRect is ok
	 * To manage savedCtxRestore it's also the better way
	 * 		- save ctx (top)is stored and took into account at initialization
	 * Params
	 * 		viewRect		rectangle (uiUtils/rect class) of the view within we will move the content of $$elmt (kind of window)
	 * 						!!!top/left must be in fixed coordinates (relative to document)
	 * 						in order to be able to check if mouse pointer belongs to this rect on mousemove/pandown
	 * 		dir				To change dir if needed (orientation changed)
	 * 		valMax			To change valMax if needed (orientation changed)
	 * 		keepScrolling	true to init scrollRect and keep the scrolling
	 * 						used to for child pages
	 */
	init: function(viewRect, dir, valMax, keepScrolling) {
		if (viewRect == null) throw new Error("hammerScroller - Unexpected null viewRect");
		if (keepScrolling === true && this.val != null) {
			this.restoredVal = this.val;
		}
		// Reset the scroller - not all values - keep valMax, dir, restoredVal...
		this.reset(true);
		// Init can override direction
		if (dir != null && this.dir != dir) {
			this._initDir(dir);
		}
		if (this.dir == null) throw new Error("hammerScroller - Unexpected null direction");
		if (globals.getSiteLayout().getTransformScale() != 1) {
			viewRect = viewRect.applyTransformScale(globals.getSiteLayout().getTransformScale(), true);
		}
		// viewRect defines the boundaries
		this.viewRect = viewRect;
		// We need pan and not swipe
		this.hammer.get("pan").set({
			threshold: 0, // Small threshold to bloc the click (mouseup) as son as pan start- To test on mobile devices
			direction: _consts.dir[this.dir]
		});
		// We need press to stop the scolling
		this.hammer.get("press").set({
			time: 1 //Small timeout needed to stop immediately when press
		});
		// Create handlers
		this._panHandler = Hammer.bindFn(this.onPan, this);
		this._pressHandler = Hammer.bindFn(this.onPress, this);
		this._clickHandler = Hammer.bindFn(this.onClick, this);
		// - altClick enable/disable the scrolling
		this.$$elmt.on('click', this._clickHandler);
		// Bind events
		// Original rectangle - used to enable/disable scrolling
		// !!! Images and components loaded by URL need to have a fix height !!! otherwise we can't calculate the height
		this._originalRect = uiRect.elmtRect(this.$$elmt);
		// Store the original offset because it's the reference (only for embedded object like page into vignette and arrays)
		// globals.getCurrentPage() can be nul since we use scroller in modal (globals.getCurrentPage() is null if an error occure on page loading)
		this._originalScrollOffset = this.isPageScroller || !globals.getCurrentPage() ? null : globals.getCurrentPage().getScrollOffset();
		this._enableEvents(true);
		// Init can override valMax
		if (valMax != null) this.valMax = valMax;
		// Values set by restoreSaveContext - back 
		this.setVal(this.restoredVal == null ? this.valMax : this.restoredVal);
		if (keepScrolling === true && this.restoredVal != null) {
			// If keepScrolling we have to adjust in case the newValMin < previousVal < newValMax
			this.adjust();
		}
		this.restoredVal = null;
		// Reset the new scrolling
		this.refresh();
	},
	/**
	 * Enable / Disable events
	 * Used by reset and Alt Click
	 * toggleStatus: true means that we toggle 'native scroll' <-> 'hammer scroll'
	 */
	_enableEvents: function(yes) {
		//this.viewRect == null -> scroller has not been initialized
		// Can occurs because we create a non-initialized scroller for pages/array so they can be notified even if they've not been initialized
		if (!this.viewRect) return;
		var wasDisabled = this._evtsEnabled === false;
		// ENABLED
		if (yes === true && this._evtsEnabled !== true) {
			this._evtsEnabled = true;
			this.hammer.on(_consts.pan[this.dir], this._panHandler);
			this.hammer.on("press", this._pressHandler);
			// Just to find elmt with debugger
			this.$$elmt.addClass("s-m-scroll" + this.dir);
		}
		// DISABLED
		if (yes === false && this._evtsEnabled !== false) {
			if (this._evtsEnabled === false) return;
			this._evtsEnabled = false;
			if (this.hammer) {
				this.hammer.off(_consts.pan[this.dir], this._panHandler);
				this.hammer.off("press", this._pressHandler);
			}
			this.$$elmt.removeClass("s-m-scroll" + this.dir);
		}
		// IN ANY CASES
		if (wasDisabled) {
			// Nothing
		} else {
			this.panStart = false;
			this.stopSlowingDown();
			this.cancelClick = false;
			this.lastClickAllowed = null;
		}
	},
	/**
	 * Disable scroll but keep the capability to re-initialize it
	 */
	reset: function(dontResetValue) {
		if (dontResetValue !== true && this.viewRect != null) {
			this.setVal(this.valMax);
			// Put initial value
			this.refresh();
		}
		// !! FIRST - Disable events
		this._enableEvents(false);
		// Disable click - No mo more scrolling compared to disable/enable
		if (this.$$elmt) {
			// TODO - There a double destroy ??
			this.$$elmt.off('click', this._clickHandler);
		}
		// After
		this.viewRect = null;
		// True if panstart - mouse start to move
		this.panStart = false;
		// True if the scroll is slowing down after panend (mouse up)
		this.stopSlowingDown();
		// Cancel click on a link
		this.cancelClick = false;
		//Prevent click after _lastClickTO ms after a panend
		this.lastClickAllowed = null;
		// Null to force to set value on init ( context restored)
		this.val = null;
		this.isLocked = false;
		// !! DO NOT RESET - dir, valMax, parentMgr, restoredVal
	},
	/**
	 * Destroy scroller
	 */
	destroy: function() {
		// First
		this.reset();
		// After
		if (this.hammer) {
			this.hammer.destroy();
			this.hammer = null;
		}
		this.$$elmt = null;
		this.$$nativeScroll = null;
		this.callBack = null;
		this._panHandler = null;
		this._pressHandler = null;
		this._toggleRect(false);
		this._clickHandler = null;
		utils.unbindObj(this);
	},
	/**
	 * Refresh scrolling
	 * 	internal call or called to refresh scrolling when we activate cached pages
	 */
	refresh: function() {
		if (!this.$$elmt || !this.dir) return;
		if (this.dir == "v") {
			this.$$elmt.css({
				top: this.val + "px"
			});
		} else {
			this.$$elmt.css({
				left: this.val + "px"
			});
		}
	},
	_getScrollOffset: function() {
		if (this.isPageScroller || this._originalScrollOffset == null) return null;
		var o = globals.getCurrentPage().getScrollOffset();
		if (o == null) return null;
		return {
			top: o.top - this._originalScrollOffset.top,
			left: o.left - this._originalScrollOffset.left
		};
	},
	_toggleRect: function(remove) {
		// Debug show the rectangle - fixed position 
		if (this._$$viewRect) {
			this._$$viewRect.remove();
			this._$$viewRect.off('click', this._clickHandler);
			this._$$viewRect = null;
		} else if (remove !== false) {
			this._$$viewRect = this.viewRect.showInDocument();
			var o = this._getScrollOffset();
			if (o) {
				this._$$viewRect.css({
					marginTop: "+=" + o.top,
					marginLeft: "+=" + o.left
				});
			}
			this._$$viewRect.on('click', this._clickHandler);
		}
	},
	/**
	 * Intercept click/mouseup events for filtering
	 * We need to filter click events to control the triggering of links
	 * altClick 	-> Enables/Disables scrolling
	 * shiftClick	-> Displays/Hides the viewRect
	 */
	onClick: function(evt) {
		log && log("onClick Status", "slowingDown:", this.slowingDown, "panStart:", this.panStart, "cancelClick:", this.cancelClick, "lastClickAllowed:", this.lastClickAllowed ? new Date().getTime() - this.lastClickAllowed : null);
		evt.$stop = false;
		if (evt.shiftKey) {
			this._toggleRect();
			return _stopClickEvent(this, evt, "Show rectangle");
		}
		// If disable we skip
		if (this._evtsEnabled === false) return;
		if (this.slowingDown) {
			return _stopClickEvent(this, evt, "slowing down");
		}
		if (this.cancelClick) {
			this.cancelClick = false;
			return _stopClickEvent(this, evt, "Click canceled");
		}
		if (this.lastClickAllowed != null && ((new Date().getTime() - this.lastClickAllowed) < 0)) {
			// Click is authorized if not slowingDown or if not cancelClick
			// We wait _lastClickTO after panend (mouseup) to allow click
			this.lastClickAllowed = null;
			return _stopClickEvent(this, evt, "Last click timeout");
		}
		if (this.parentMgr && this.parentMgr.dir != this.dir) {
			// For double scroll direction one by parent and one by a grid we need to sak the parent to cancel the click 
			this.parentMgr.onClick(evt);
			if (evt.$stop === true) {
				return _stopClickEvent(this, evt, "Parent stopped click");
			}
		}
		log && log("onClick not stopped");
	},
	/**
	 * Used to stop the slowdown process
	 */
	onPress: function(evt) {
		this.lastPress = new Date().getTime();
		if (this.slowingDown) {
			this.stopSlowingDown();
			// Last click is avoided - The click evt that is always triggered after press a event
			this.cancelClick = true;
		}
		if (this.parentMgr) this.parentMgr.isLocked = false;
		log && log(this.id, "onPress", "slowingDown=" + this.slowingDown, "panStart=" + this.panStart, "cancelClick =" + this.cancelClick, "lastClickAllowed =" + this.lastClickAllowed);
	},
	/**
	 * pan event - mousedown/mousemove/mouseup
	 */
	onPan: function(evt) {
		log && log(this.id, evt.type, this.dir, utils.isEvtDirection(evt, this.dir), "isLocked", this.isLocked);
		if (!utils.isEvtDirection(evt, this.dir)) return;
		if (this.isLocked === true) return;
		try {
			if (false && !this.viewRect.isEvtInside(evt.srcEvent, this._getScrollOffset())) {
				// outside the viewRect -> Stop process
				log && log("outside");
				return;
			}
			if (evt.type === "panstart") {
				// Mouse mousedown + mousemove event - start the process
				log && log(evt.type);
				this.panStart = true;
				this.cancelClick = true;
				this.stopSlowingDown();
				if (this.parentMgr && (this.parentMgr.dir === this.dir)) this.parentMgr.isLocked = true;
			} else if (evt.type === "panend") {
				// mouseup  - we continue to scroll (_slowDown) until the user do a press event to stop scrolling
				log && log(evt.type);
				this.panStart = false;
				if (_slowDown && this.lastVelocity != null) {
					// We keep the last velocity for slowdown process
					this.lastVelocity = Math.abs(this.lastVelocity);
					if (this.lastVelocity > 0.3 && this.lastVelocity < 1) {
						// If velocity is too small we keep 1
						this.lastVelocity = 1;
					} else {
						// under.3 we consider that we need to stop scrolling
						this.lastVelocity = Math.min(this.lastVelocity, 2);
					}
					if (this.lastVelocity >= 1) {
						// _slowDown option continue the process by decreasing the speed slowly and moving $$elmt
						this.slowingDown = true;
						this.slowDown(this.lastVelocity, this.lastUp);
						this.lastVelocity = this.lastUp = null;
					} else {
						if (this.parentMgr) this.parentMgr.isLocked = false;
					}
				} else {
					// avoid click on mouse up
					this.lastClickAllowed = new Date().getTime() + _lastClickTO;
					if (this.parentMgr) this.parentMgr.isLocked = false;
				}
				return;
			}
			// Direction of the scroll
			// Up means up or right 
			var up = evt.type === this.upEvtType || evt.type === "panstart" && evt.deltaY < 0;
			if (this.move(_velocityToDist(evt.velocity), up)) {
				this.lastVelocity = Math.abs(evt.velocity);
				this.lastUp = up;
			} else {
				this.lastVelocity = this.lastUp = null;
			}
		} catch (e) {
			console.log(JSON.stringify(jsutils.convertToDiagnoses("hammerScroller exception - onPan", e), null, 2));
			return false;
		}
	},
	stopSlowingDown: function() {
		this.slowingDown = false;
		if (this.parentMgr) this.parentMgr.isLocked = false;
	},
	/**
	 * Keep the last speed to continue scrolling process until the user do a press evt
	 */
	slowDown: function(v, up) {
		var self = this;
		if (self.panStart || !self.slowingDown) {
			this.stopSlowingDown();
			return;
		}
		// keep the same velocity - to improve - we can decrease...
		if (v < 1) {
			this.stopSlowingDown();
			return;
		}
		if (self.move(_velocityToDist(v), up)) {
			// Move until stop with _slowDownTO timeout
			setTimeout(function() {
				self.slowDown(v, up);
			}, _slowDownTO);
		} else {
			this.stopSlowingDown();
		}
	},
	/**
	 * Move $$elmt vertically
	 */
	move: function(dist, up) {
		try {
			if (dist == 0) return;
			// Check boundaries
			var val = up ? this.val - dist : this.val + dist;
			var valMin = this.getValMin();
			val = Math.max(Math.min(this.valMax, val), valMin);
			if (val === this.valMax || val === valMin) {
				log && log(this.id, "end scrolling");
				// avoid click during xx ms on mouse up at the end of scrolling
				this.lastClickAllowed = new Date().getTime() + _lastClickTO;
				this.cancelClick = false;
				if (this.val === val) {
					// Overflow -> Stop
					// log && log("move overflow")
					return false;
				}
			}
			this.setVal(val);
			if (this.callBack) {
				return this.callBack(this.val);
			} else {
				// Move elmt
				this.refresh();
				return true;
			}
		} catch (e) {
			console.log(JSON.stringify(jsutils.convertToDiagnoses("hammerScroller exception - move", e), null, 2));
			return false;
		}
	},
	// Save context if enabled
	savedCtxCreate: function() {
		return this.hammer ? {
			val: this.val
		} : null;
	},
	// Restored context
	savedCtxRestore: function(ctx, refresh) {
		if (ctx == null || ctx.val == null) return;
		// Set val - if refresh == false that means that we need to call init method 
		this.restoredVal = ctx.val;
		if (refresh) {
			// By example called by a cached pages which has been activated
			this.refresh();
		}
	},
	getOffset: function() {
		return {
			top: this.dir == "v" ? this.val : 0,
			left: this.dir == "h" ? this.val : 0
		};
	},
	/**
	 * status	null	 	toggles this._evtsEnabled otherwise
	 * 			true 		forces enable
	 * 			false		forces disable
	 */
	notifScrollerToggle: function(status) {
		this._enableEvents(status == null ? !this._evtsEnabled : status === true, true);
		/**
		 * Set $$elmt and $$nativeScroll to enable/disable native scrolling (browser's scroll bar)
		 */
		// Set $$nativeScroll properties - overflow and width/height
		var css = {
			overflow: "hidden"
		};
		// Set the width/height with right values
		var prop = this.dir === "h" ? "width" : "height";
		//!! _originalRect is not changed only if toggleStatus == true
		css[prop] = this._originalRect[prop] + "px";
		this.$$nativeScroll.css(css);
		// Set $$elmts properties - top and overflow
		var css = {
			overflow: "hidden"
		};
		// Position to default offset
		css[this.dir === "h" ? "left" : "top"] = this.valMax + "px";
		this.$$elmt.css(css);
		this.setVal(this.valMax);
	},
	/**
	 * Show element in page - scroll if needed
	 * c is a JQuery elmt or an object with $$elmt property
	 */
	makeVisible: function($$e) {
		if (this.slowingDown) {
			this.stopSlowingDown();
			// Last click is avoided - The click evt that is always triggered after press a event
			this.cancelClick = true;
		}
		if (!$$e || !$$e.jquery || $$e.length == 0 || this.viewRect == null) return;
		if ($$e.closest(this.$$elmt).length === 0) return;
		if (!this._evtsEnabled) return;
		var prop = this.dir === "v" ? "top" : "left";
		var size = this.dir === "v" ? "height" : "width";
		var o = $$e.offset();
		if (o[prop] > this.viewRect[prop] && o[prop] < (this.viewRect[prop] + this.viewRect[size] - 10)) {
			return;
		}
		this.$$elmt.css("visibility", "hidden");
		var f = o[prop] > this.viewRect[prop] ? -1 : +1;
		//$$e.css("background-color", "red");
		// FDB - Best way I found to right position $$e - Perhaps we can do that in one shot
		// Comparing this.$elmt.offset et $e.offset doesn't work
		var stop = this.viewRect[prop] + this.viewRect[size] / 2;
		var valMin = this.getValMin();
		while ($$e.offset()[prop] > stop) {
			this.setVal(this.val + 50 * f);
			this.refresh();
		}
		if (this.val < valMin) {
			this.setVal(valMin);
			this.refresh();
		}
		if (this.val > this.valMax) {
			this.setVal(this.valMax);
			this.refresh();
		}
		this.$$elmt.css("visibility", "visible");
	},
	autoScroll: function(value) {
		this.move(Math.abs(value), value < 0);
	},
	getScrollValue: function(value) {
		return this.val;
	},
	/**
	 * Calculated dynamically because the content of the page can be modified after initisalization of scroller
	 */
	getValMin: function() {
		var prop = this.dir == "v" ? "height" : "width";
		var x = this.$$elmt[prop]();
		if (false && globals.getSiteLayout().getTransformScale != 1) {
			// disabled because doesn't work fine - Like we scaled viewRect we should scale x 
			x = x * globals.getSiteLayout().getTransformScale();
		}
		// 30 pixel more
		return Math.min(this.valMax - x + this.viewRect[prop] - 30, this.valMax);
	},
	// Adjust the scroller after modification of DOM to make this.$elmt visible
	// By example after an action which hides lines we need to call this method to adjust scrolling because the visible area can be outside the viewRect
	adjust: function() {
		// Panel has not been initialized
		if (this.viewRect == null) return;
		var newVal = null;
		var elmtRect = uiRect.elmtRect(this.$$elmt);
		if (this.viewRect.contains(elmtRect)) {
			newVal = this.valMax;
		} else {
			if (this.val > this.valMax) {
				newVal = this.valMax;
			}
			var prop = this.dir == "v" ? "height" : "width";
			var valmin = this.valMax - elmtRect[prop] + this.viewRect[prop];
			if (this.val < valmin) {
				newVal = this.getValMin();
			}
		}
		if (newVal != null) {
			this.setVal(newVal);
			this.refresh();
		}
	},
	// Move to beginning 
	scrollToBeginning: function() {
		this.setVal(this.valMax);
		this.refresh();
	},
	/**
	 * Check if the current scroll element is contained by  viewRect
	 * If true -> reset scrollin - no need
	 * Else re-init scrolling
	 */
	checkViewRect: function(viewRect, preserveScroll) {
		var reset = true;
		if (viewRect && this.$$elmt) {
			// For multiselection in card mode we can hide cards. We need to scroll to beginning in order to calculate the right rect
			var val = this.val;
			this.scrollToBeginning();
			if (preserveScroll) {
				this.setVal(val);
			}
			var myRect = uiRect.elmtRect(this.$$elmt, "computed");
			var intersectRect = viewRect.intersectRect(myRect, false);
			if (intersectRect != null) {
				this.init(intersectRect, null, null, preserveScroll);
				reset = false;
				if (preserveScroll) {
					// If preserveScroll we have to adjust in case the newValMin < previousVal < newValMax
					this.adjust();
				}
			}
		}
		if (reset) {
			this.reset();
		}
		return !reset;
	},
	setVal: function(v) {
		if (isNaN(v)) v = 0;
		this.val = v;
	}
});

var _createSimpleScroller = function($$elmt) {
	var $$scrolls = $$elmt.find(".s-m-scroll-element");
	var i;
	var scrollers = {};

	for (i = 0; i < $$scrolls.length; i++) {
		_scrollerId++;

		var $$se = $($$scrolls[i]);
		var $$wrapper = $$se.parent();
		var dir = $$wrapper.hasClass("s-m-scroll-wrapper-h") ? "h" : "v";

		$$wrapper.attr("data-scroller-id", _scrollerId);

		var parentScroller = null;
		var $$parentScroller = $$wrapper.parent().closest(".s-m-scroll-wrapper");
		if ($$parentScroller.length > 0) {
			parentScroller = scrollers[$$parentScroller.attr("data-scroller-id")];
		}

		var css = {};
		css["overflow-" + dir] = "auto";
		$$wrapper.css(css);

		var gestureMgr = new _Klass($$se, {
			direction: dir,
			valMax: 0,
			name: "_scroller_" + _scrollerId,
			isPageScroller: false
		}, parentScroller);
		scrollers[_scrollerId] = gestureMgr;

		var scrollRect = uiRect.elmtRect($$se, "outer");
		var wrapperRect = uiRect.elmtRect($$wrapper, "outer");
		var viewRect = wrapperRect.intersectRect(scrollRect);
		if (viewRect && !viewRect.contains(scrollRect)) {
			gestureMgr.init(viewRect);
		} else {
			gestureMgr.reset();
		}
	}

	return scrollers;
};

exports.Klass = _Klass;
exports.createSimpleScroller = _createSimpleScroller;
});

define('syracuse-tablet/html/js/ui/modals/modalDialog',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/hammerScroller','syracuse-tablet/html/js/ui/rect'],function (require, exports, module) {

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var HammerScroller = require('syracuse-tablet/html/js/helpers/hammerScroller');
var uiRect = require('syracuse-tablet/html/js/ui/rect');

var _dialogTpl = '\
	<div class="modal {{displayFlags.modalClass}}" id="modal-endpoint" tabindex="-1" role="dialog">\
	<div class="modal-dialog">\
	<div class="modal-content"> \
		{{{header}}} \
		<div class="modal-body">{{{content}}}</div> \
		{{{footer}}} \
	</div> \
	</div>\
	</div>';

/**
 *
 */
var _Klass = utils.defineClass(

	function BaseModal() {
		var self = this;
		var site = globals.getSiteLayout();

		self.deviceType = site.getDeviceType(); // tablet or smartphone
		self.displayFlags = {
			modalClass: ""
		};
	}, null, {
		destroy: function() {
			if (this.$$elmt) {
				this.$$elmt.unbind();
				this.$$elmt.remove();
			}
		},
		/*
		 * =======================================
		 * Functions that must be overiden
		 * =======================================
		 */

		/*
		 * Needs to be overiden by dialog implementations
		 * Returns html template per device (or only std if no special ones)
		 */
		_getTemplates: function() {
			return {
				std: {},
				tablet: {},
				smartphone: {}
			};
		},

		/*
		 * Needs to be overiden by dialog implementations
		 * Returns data to merge into template
		 */
		_getDataContext: function() {
			return {};
		},


		/*
		 * Can be overidden to handle clicks on data-action=$validate.
		 * Should set value returned by _getResult()
		 * Return false to NOT close dialog
		 */
		_onValidate: function() {

		},

		/*
		 * Can be overidden to handle clicks on data-action=$cancel.
		 * Should set value returned by _getResult()
		 * Return false to NOT close dialog
		 */
		_onCancel: function() {

		},

		/*
		 * Can be overidden to set result of dialog when it is closed
		 *
		 */
		_getResult: function() {

		},

		/*
		 * =======================================
		 * Functions that may be overiden
		 * =======================================
		 */

		/*
		 * Can be overidden to handle clicks on data-action dom elements.
		 * param=data-param
		 * Return false to NOT close dialog
		 */
		_onAction: function(action, param) {

		},

		_compileTpl: function() {
			var self = this;
			var htmlTpls = self._getTemplates();
			var htmlTpl = htmlTpls[self.deviceType] || htmlTpls["std"];

			var tpl = {
				header: Handlebars.compile(htmlTpl.header),
				content: Handlebars.compile(htmlTpl.content),
				footer: Handlebars.compile(htmlTpl.footer),
			};
			return tpl;
		},

		_getWrapperTemplate: function() {
			return Handlebars.compile(_dialogTpl);
		},

		_ensureParent: function() {
			var self = this;
			var parentName = globals.isAuthoringActive() ? "s-m-modal-parent-auth" : "s-m-modal-parent";
			var $$parent = $("#" + parentName);
			if ($$parent.length < 1) {
				$$parent = $("<div>");
				$$parent.attr("id", parentName);
				if (globals.isAuthoringActive()) {
					$("body").append($$parent);
				} else {
					$("#s-m-app-id").append($$parent);
				}
			}
			self.$$parent = $$parent;
		},

		_createDOM: function() {
			var self = this;
			self.$$elmt = $(self.html);
		},

		getDisplayFlags: function() {
			var self = this;
			return self.displayFlags;
		},

		_hookEvents: function() {
			var self = this;
			self.$$elmt.on("shown.bs.modal", self._onShow.bind(self));
			self.$$elmt.on("hide.bs.modal", self._onHide.bind(self));

			self.$$elmt.delegate("[data-action]", "click", self._onButton.bind(self));
		},

		_attachDOM: function() {
			var self = this;
			self.$$parent.toggle(true);
			self.$$parent.append(self.$$elmt);
			self.$$elmt.modal({
				keyboard: false,
				backdrop: "static"
			});
		},

		_onShow: function(evt) {
			var self = this;
			self.$$elmt.css("padding-left", "");
			self._calcSize();
			var app = globals.getApplication();
			app.notifModalOpen();

			self._initScrollers();
		},

		_onHide: function(evt) {
			var self = this;
			var app = globals.getApplication();

			self.$$parent.toggle(false);
			app.notifModalClose();

			self.deferred.resolve(self._getResult());
			self.destroy();
		},

		_onButton: function(evt) {
			var self = this;
			var $$t = $(evt.currentTarget);

			var param = $$t.attr("data-params");
			var act = $$t.attr("data-action");
			if (act) {
				evt.preventDefault();
				evt.stopPropagation();

				var res;
				if (act === "$validate") {
					res = self._onValidate();
				} else if (act === "$cancel") {
					res = self._onCancel();
				} else {
					res = self._onAction(act, param);
				}
				if (res !== false) {
					self.$$elmt.modal('hide');
				}
			} else {
				// Close modal
				self.$$elmt.modal('hide');
			}
		},

		/**
		 * This is the only function to be called from a dialog user
		 * It shows the dialog and resolves the returned promise as soon as the dialog is closed
		 *
		 */
		show: function() {
			var self = this;
			self.deferred = new $.Deferred();

			$.smResolve().then(function() {
				return self._getDataContext();
			})
				.then(function(data) {
					self.data = data;
				})
				.then(function() {
					self.template = self._compileTpl();
					var outerTpl = self._getWrapperTemplate();

					var header = self.template.header(self.data);
					var footer = self.template.footer(self.data);

					if (header.length > 0) {
						header = '<div class="modal-header">' + header + '</div>';
					}
					if (footer.length > 0) {
						footer = '<div class="modal-footer">' + footer + '</div>';
					}

					self.html = outerTpl({
						header: header,
						content: self.template.content(self.data),
						footer: footer,
						displayFlags: self.getDisplayFlags()
					});
					self._ensureParent();
					self._createDOM();
					self._hookEvents();
					self._attachDOM();
				});

			return self.deferred.promise();
		},

		/*
		 *
		 */
		_initScrollers: function() {
			var self = this;
			HammerScroller.createSimpleScroller(self.$$elmt);
		},

		_calcSize: function() {
			var self = this;

			var df = self.getDisplayFlags();
			if (df.modalClass.indexOf("half_center") > -1 ||
				df.modalClass.indexOf("half_right") > -1 ||
				df.modalClass.indexOf("full") > -1) {
				var $$content = self.$$elmt.find(".modal-content");
				var $$header = self.$$elmt.find(".modal-header");
				var $$body = self.$$elmt.find(".modal-body");
				var $$footer = self.$$elmt.find(".modal-footer");

				var header = $$header.length > 0 ? uiRect.elmtRect($$header, "outer").height : 0;
				var footer = $$footer.length > 0 ? uiRect.elmtRect($$footer, "outer").height : 0;

				$$body.css({
					"top": header,
					"height": $$content.height() - header - footer
				});
			}
		}
	}
);

exports.ModalBase = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalDiagnoses',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/deps/hammerjs-2.0.4/hammer','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/hammerScroller'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var Hammer = require('syracuse-tablet/html/deps/hammerjs-2.0.4/hammer');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var HammerScroller = require('syracuse-tablet/html/js/helpers/hammerScroller').Klass;

var _templateAll = {
	header: '\
		<div class="modal-title {{severity}}">{{title}}</div>',
	content: '\
		<div class="s-m-modal-diag-content">\
			{{#each diags}} \
				<message id="s-m-msg-block-{{id}}" role="alert" style="display:{{this.display}}"> \
					<div style="white-space: pre-line;">{{this.message}}</div> \
					{{#if stack}} \
						<a id="s-m-msg-stack-{{id}}" draggable="false" name="more" href="#" data-action="more">{{../../stackShow}}</a> \
						<section>\
							<div class="s-m-scroll-wrapper">\
								<stack name="stack" class="s-m-msg-stack-content"> \
									{{{this.stack}}} \
								</stack> \
							</div> \
						</section>\
					{{/if}} \
				</message> \
			{{/each}}\
		</div>\
		<div class="s-m-modal-diag-goto">\
			{{#each diags}}\
				<a id="s-m-msg-goto-{{id}}" data-action="goto" data-params="{{id}}">\
					<i class="fa fa-circle-o" data-action="goto" data-params="{{id}}"></i>\
				</a>\
			{{/each}}\
		</div>',
	footer: '<button type="button" class="btn btn-default" data-action="$cancel">{{close}}</button>'
};


var _Klass = utils.defineClass(
	function ModalDiagnoses(title, diag) {
		var self = this;
		modalDialog.ModalBase.call(self);
		// Init params
		self.title = title;
		self.diag = diag;
		self.diagId = 0;
		self.curMsg = 0;
	}, modalDialog.ModalBase, {
		destroy: function() {
			var self = this;
			// destroy hammer component
			this._destroySwiper();
			// destroy gestureMgr (used for vertical swipe within the stack)
			if (this._gestureMgrMap && !$.isEmptyObject(this._gestureMgrMap)) {
				$.each(this._gestureMgrMap, function(key, gestureMgr) {
					gestureMgr.destroy();
				});
				this._gestureMgrMap = null;
			}
			modalDialog.ModalBase.prototype.destroy.call(self);
		},
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},
		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "diagnoses tablet";
			} else {
				displayFlags.modalClass = "diagnoses mobile";
			}
			return displayFlags;
		},
		_getDataContext: function() {
			var self = this;
			var ctx = {
				close: locale.text("modal.btn.close"),
				stackShow: locale.text("modal.diagnoses.btnstack_show"),
				severity: "info",
				diags: []
			};
			self.diag.$diagnoses.forEach(function(d) {
				var sev;
				if (d.$severity === "success" || d.$severity === "info" || d.$severity === "warning") {
					sev = d.$severity;
				} else {
					sev = "danger";
					ctx.severity = "error";
				}
				ctx.diags.push({
					id: self.diagId,
					display: self.diagId === 0 ? "block" : "none",
					message: d.$message,
					severity: sev,
					severityLabel: locale.text("severity." + sev),
					stack: d.$stackTrace && d.$stackTrace.replace(/\n/g, "<BR/>")
				});

				self.diagId++;
			});

			self.title = self.title || (ctx.severity === "error" ? locale.text("modal.error.ttl") : locale.text("modal.info.ttl"));
			ctx.title = self.title;

			return ctx;
		},
		_onAction: function(action, param) {
			var self = this;
			switch (action) {
				case "next":
					self._next();
					break;
				case "prev":
					self._prev();
					break;
				case "more":
					self._more();
					break;
				case "goto":
					self._goTo(param);
					break;
			}

			// dont close on actions
			return false;
		},
		_goTo: function(id) {
			var self = this;
			for (var ii = 0, jj = self.diagId; ii < jj; ii++) {
				$("#s-m-msg-block-" + ii, self.$$elmt).css("display", ii == id ? "block" : "none");
			}
			self.curMsg = parseInt(id, 10);
			self._updateButtons();
		},
		_next: function() {
			var self = this;
			if (self.curMsg < (self.diagId - 1)) {
				$("#s-m-msg-block-" + self.curMsg, self.$$elmt).css("display", "none");
				self.curMsg++;
				$("#s-m-msg-block-" + self.curMsg, self.$$elmt).css("display", "block");
				self._updateButtons();
			}
		},
		_prev: function() {
			var self = this;
			if (self.curMsg > 0) {
				$("#s-m-msg-block-" + self.curMsg, self.$$elmt).css("display", "none");
				self.curMsg--;
				$("#s-m-msg-block-" + self.curMsg, self.$$elmt).css("display", "block");
				self._updateButtons();
			}
		},
		_more: function() {
			var self = this;
			var $$btn = $("#s-m-msg-stack-" + self.curMsg, self.$$elmt);
			var $$stackSection = $("section", $$btn.parent());
			if ($$stackSection.css("display") === "none") {
				$$stackSection.css("display", "block");
				$$btn.text(locale.text("modal.diagnoses.btnstack_hide"));
				self._handleGesture();
			} else {
				$$stackSection.css("display", "none");
				$$btn.text(locale.text("modal.diagnoses.btnstack_show"));
			}
		},
		_updateButtons: function() {
			var self = this;

			for (var ii = 0, jj = self.diagId; ii < jj; ii++) {
				var $$navDot = $("a#s-m-msg-goto-" + ii + " i", self.$$elmt);
				$$navDot.toggleClass("fa-circle", ii == self.curMsg);
				$$navDot.toggleClass("fa-circle-o", ii !== self.curMsg);
			}

			// Only show x of y in case there are more than 1 diagnoses
			if (self.diagId > 1) {
				$(".modal-title", self.$$elmt).text(self.title + " (" + (self.curMsg + 1) + "/" + self.diagId + ")");
			} else {
				// hide nav circles if one diag only
				$(".s-m-modal-diag-goto", self.$$elmt).css("display", "none");
			}
		},
		_onShow: function(evt) {
			var self = this;
			modalDialog.ModalBase.prototype._onShow.call(self, evt);
			self._updateButtons();

			// init swype handler if more than one diagnose
			if (self.diagId > 1) {
				self._initSwiper();
			}
		},
		_handleGesture: function() {
			var self = this;
			self._gestureMgrMap = self._gestureMgrMap || {};

			if (!self._gestureMgrMap["gestureMgr" + self.curMsg]) {
				var $$scrollElmt = $(".s-m-msg-stack-content", $("#s-m-msg-block-" + self.curMsg, self.$$elmt));
				var $$wrapper = $(".s-m-scroll-wrapper", $("#s-m-msg-block-" + self.curMsg, self.$$elmt));

				self._gestureMgrMap["gestureMgr" + self.curMsg] = new HammerScroller($$scrollElmt, {
					direction: "v"
				});
				var scrollRect = uiRect.elmtRect($$wrapper, "outer");
				self._gestureMgrMap["gestureMgr" + self.curMsg].init(scrollRect);
			}
		},
		/*
		 * User can navigate from one diagnose to another with a swipe gesture.
		 * This method will display appropriate diagnose message depending on the swipe gesture
		 */
		_onSwipe: function(evt) {
			if (utils.isEvtDirection(evt, "v")) return;

			var self = this;
			setTimeout(function() {
				var next = evt ? evt.type === "swipeleft" : null;
				if (next) {
					self._next();
				} else {
					self._prev();
				}
			});
		},
		_destroySwiper: function() {
			var self = this;
			if (self.hammer) {
				self.hammer.destroy();
				self.hammer = null;
			}
		},
		_initSwiper: function() {
			var self = this;
			self._destroySwiper();
			self.hammer = new Hammer($(".s-m-modal-diag-content", self.$$elmt).get(0));
			self.hammer.get("swipe").set({
				direction: Hammer.DIRECTION_HORIZONTAL
			});
			// listen to events...
			this.hammer.on("swipeleft swiperight", Hammer.bindFn(self._onSwipe, self));
		}
	}
);
exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalConfirm',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _templateAll = {
	header: '\
		<div class="modal-title">{{title}}</div>',
	content: '\
			<div class="s-m-modal-content">\
				{{message}}\
			</div>',
	footer: '\
		<button type="button" class="btn btn-default" data-action="yes">{{yes}}</button> \
		<button type="button" class="btn btn-default" data-action="no">{{no}}</button>'
};

var _checkMsg = function(msg) {
	return msg ? msg.replace(/\n/g, "<br>") : "";
};


var _Klass = utils.defineClass(
	function ModalConfirm(message, action, isSimpleConfirm) {
		var self = this;
		modalDialog.ModalBase.call(self);
		// Init params
		self.message = message;
		self.action = action;
		self.isSimpleConfirm = isSimpleConfirm;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},
		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "confirm tablet";
			} else {
				displayFlags.modalClass = "confirm mobile";
			}
			return displayFlags;
		},
		_getDataContext: function() {
			var self = this;
			var ctx = {};
			ctx.title = self.isSimpleConfirm ? null : locale.text("modal.confirm.ttl");
			// different message depending on whether the calling modal.js method is confirm() or simpleConfirm()
			ctx.message = self.action ? _checkMsg(locale.text("modal.confirm.msg", [self.action])) : _checkMsg(self.message);
			ctx.yes = locale.text("yes");
			ctx.no = locale.text("no");
			return ctx;
		},
		_onAction: function(action, param) {
			var self = this;
			self.selectedAction = action;
			// close on actions
			return true;
		},
		_getResult: function() {
			var self = this;
			return self.selectedAction;
		}
	}
);
exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalField',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _templateAll = {
	header: '\
		<buttons class="pull-right"> \
			<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
		</buttons> \
		<div class="modal-title">{{title}}</div>',
	content: '{{{domBody}}}',
	footer: ''
};


var _Klass = utils.defineClass(
	function ModalField(title, domBody, cb) {
		var self = this;
		modalDialog.ModalBase.call(self);
		// Init params
		self.title = title || "Warning";
		self.domBody = domBody;
		self.cb = cb;
	}, modalDialog.ModalBase, {
		destroy: function() {
			modalDialog.ModalBase.prototype.destroy.call(this);
			this.domBody = null;
			this.cb = null;
		},
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},
		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "field tablet";
			} else {
				displayFlags.modalClass = "field mobile";
			}
			return displayFlags;
		},
		_getDataContext: function() {
			var self = this;
			return {
				title: self.title,
				domBody: self.domBody,
				close: locale.text("modal.btn.close")
			};
		},
		_onShow: function(evt) {
			var self = this;
			modalDialog.ModalBase.prototype._onShow.call(self, evt);
			self._execCb(self.cb, "shown.bs.modal", self.$$elmt);
		},
		_onCancel: function() {
			return true;
		},
		_onHide: function(evt) {
			var self = this;
			modalDialog.ModalBase.prototype._onHide.call(self, evt);
			self._execCb(self.cb, "hide.bs.modal", self.$$elmt);
		},
		_execCb: function(cb, msg, data) {
			if (!cb || arguments.length == 0) return;
			var cb = arguments[0];
			var args = Array.prototype.slice.call(arguments, 1);
			cb.apply(null, args);
		}
	}
);
exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modal',['require','exports','module','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/modals/modalDiagnoses','syracuse-tablet/html/js/ui/modals/modalConfirm','syracuse-tablet/html/js/ui/modals/modalField'],function (require, exports, module) {

var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

// Separated module for showing diagnoses since it may be replaced depending on device/OS
var ModalDiagnoses = require('syracuse-tablet/html/js/ui/modals/modalDiagnoses').Modal;
var ModalConfirm = require('syracuse-tablet/html/js/ui/modals/modalConfirm').Modal;
var ModalField = require('syracuse-tablet/html/js/ui/modals/modalField').Modal;

var _checkMsg = function(msg) {
	return msg ? msg.replace(/\n/g, "<br>") : "";
};
var _templates = {
	confirm: ' \
		<div class="modal fade" id="modal-confirm" tabindex="-1" role="dialog"> \
			<div class="modal-dialog s-m-modal-layout">\
				<header>\
					<button type="button" class="close" data-dismiss="modal" aria-hidden="true">&#215;</button> \
				</header>\
				<section>\
					<div class="s-m-modal-content row">\
						<div class="col-md-4"></div>\
						<div class="col-md-4">\
							<header>{{title}}</header>\
							<section>{{message}}</section>\
							<footer>\
								<button type="button" class="btn btn-default" data-action="yes">{{yes}}</button> \
				                <button type="button" class="btn btn-default" data-action="no">{{no}}</button> \
							</footer>\
						</div>\
					<div class="col-md-4"></div>\
				</div>\
				</section>\
			</div> \
		</div>',
	error: ' \
		<div class="modal fade" id="modal-error" tabindex="-1" role="dialog"> \
			<div class="modal-dialog s-m-modal-layout">\
				<header>\
					<button type="button" class="close" data-dismiss="modal" aria-hidden="true">&#215;</button> \
				</header>\
				<section>\
					<div class="s-m-modal-content row">\
						<div class="col-md-4"></div>\
						<div class="col-md-4">\
							<header class="error">{{title}}</header>\
							<section>{{body}}</section>\
							<footer><button type="button" class="btn btn-default" data-dismiss="modal">{{close}}</button></footer>\
						</div>\
						<div class="col-md-4"></div>\
					</div>\
				</section>\
			</div> \
		</div>',
	info: '\
		<div class="modal fade" id="modal-info" tabindex="-1" role="dialog"> \
		    <div class="modal-dialog s-m-modal-layout">\
		    	<header>\
		    		<button type="button" class="close" data-dismiss="modal" aria-hidden="true">&#215;</button> \
		    	</header>\
		    	<section>\
		    		<div class="s-m-modal-content row">\
			    		<div class="col-md-4"></div>\
			    		<div class="col-md-4">\
			    			<header class="info">{{title}}</header>\
			    			<section>{{body}}</section>\
			    			<footer><button type="button" class="btn btn-default" data-dismiss="modal">{{close}}</button></footer>\
			    		</div>\
			    		<div class="col-md-4"></div>\
		    		</div>\
		    	</section>\
			</div> \
		</div>',
	field: '\
		<div class="modal fade" id="modal-field" tabindex="-1" role="dialog"> \
		    <div class="modal-dialog"> \
				<div class="modal-content"> \
				    <div class="modal-header"> \
						<button type="button" class="close" data-dismiss="modal" aria-hidden="true">&#215;</button> \
						<h4 class="modal-title" id="myModalLabel">{{title}}</h4> \
				    </div> \
				    <div class="modal-body"> \
				       {{{body}}} \
				    </div> \
				    <div class="modal-footer"> \
				        <button type="button" class="btn btn-default" data-dismiss="modal">{{close}}</button> \
					</div> \
				</div> \
			</div> \
		</div>',
	actionMessage: '\
		<div class="s-m-act-msg {{severityClass}}">\
			<a draggable="false" href="#"><span class="glyphicon glyphicon-remove"></span></a>\
			<header>\
				<div>{{title}}</div>\
			</header>\
			<section>\
				<article>{{message}}</article>\
			</section>\
			<footer></footer>\
		</div>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

/* First param : cb - Second msg - Third data ...*/
var _execCb = function(cb, msg, data) {
	if (!cb || arguments.length == 0) return;
	var cb = arguments[0];
	var args = Array.prototype.slice.call(arguments, 1);
	cb.apply(null, args);
};


/************************************************************************
 ** IMPORTANT
 * The code of the callback parameter in the exported methods :
 * error(), info(), diagnoses(), field(), confirm(), simpleconfirm(), modal()
 * has to indicate whether the callback is called :
 * - when the modal opens
 * - when the modal closes
 * - at both events
 *
 * Here is an example :
 * function (modalEvent, $$modalElmt) {
 *        // build content on open
 *       if (modalEvent == 'shown.bs.modal') {
 *           // code which is run on modal opening
 *       }
 *
 *       // run actions on close 'hidden.bs.modal'
 *       else {
 *       	// code which is run on modal closing
 *       }
 * });
 *************************************************************************/



/*
 * Examples
 * 
 * error("There was an error");
 * 
 * error("There was an error", "I am the detail text");
 *
 * error("There was an error", new Error("I am an exception"));
 * 
 * error("There was an error", {
 *   $diagnoses: [{
 *	   $message: "Message 1",
 *     $severity: "error",
 *     $stackTrace: "bla"
 *	 }, {
 * 	   $message: "Message 2",
 *	   $severity: "info",
 * 	   $stackTrace: "bla"
 *   }]
 * });
 * 
 * error("There was an error", {
 *   message: "I am the message", 
 *   detail: "I am the detail message"
 * });

 * error("There was an error", {
 *   message: "I am the message", 
 *   detail: new Error("I am an exception")
 * });
 * 
 */
var _error = function(title, e, cb) {
	var diag;
	diag = jsutils.convertToDiagnoses(title, e);
	if (title == null && e && e.$title) {
		title = e.$title;
	}
	return _diagnoses(title, diag, cb);
};

/*
 * title. Title of dialog
 * diag: Object containing diagnoses
 *       {
 *           $diagnoses: [{
 *               $message: "bla...",
 *               $severity: "error", // success, info, warning, error
 *               $stackTrace: "Stacktrace as string, formatted"
 *           }, {
 *               ...
 *           }]
 *       }
 * cb: Callback
 */
var _diagnoses = function(title, diag, cb) {
	var modal = new ModalDiagnoses(title, diag);
	modal.show().then(function(result) {
		if (cb) {
			cb(result);
		}
	});
	//return modalDiag.show(title, diag, cb);
};

/* 
 * Wrap info text into diagnoses and display it in the generic diagnoses dialog
 */
var _info = function(title, text, cb) {
	var infoDiag = {
		"$diagnoses": [{
			"$severity": "info",
			"$message": text
		}]
	};
	_diagnoses(title, infoDiag, cb);
};

var _confirm = function(action, cb) {

	var modal = new ModalConfirm(null, action);

	modal.show().then(function(result) {
		if (cb && (result === "yes" || result === "no")) {
			cb(result, "yes" === result);
		}
	});
};

var _simpleConfirm = function(message, cb) {
	var modal = new ModalConfirm(message, null, true);

	modal.show().then(function(result) {
		if (cb && (result === "yes" || result === "no")) {
			cb(result, "yes" === result);
		}
	});
};

/*
 * simpleConfirmPromise({
 *   message: "Are you sure?"
 *   }).then(function(result) {
 *      if (result.action === "yes") {
 *      } else if (result.action === "no") {
 *      }
 *   });
 */
exports.simpleConfirmPromise = function(options) {
	var deferred = $.Deferred();
	var modal = new ModalConfirm(options.message, null, true);

	modal.show().then(function(result) {
		if (result === "yes" || result === "no") {
			deferred.resolve({
				action: result
			});
		}
	});

	return deferred.promise();
};

/*
 * Open a modal window linked to a field
 */
var _field = function(title, domBody, cb) {
	var modal = new ModalField(title, domBody, cb);
	modal.show();
};

var _actionResult = function(title, obj) {
	if (!obj || !obj.$diagnoses || obj.$diagnoses.length == 0) return;
	var hasStack = false,
		hasError = false;
	var text = [];
	obj.$diagnoses.forEach(function(diag) {
		text.push(diag.$message);
		if (diag.$severity == "error") {
			hasError = true;
			hasStack = hasStack || diag.$stackTrace != null;
		}
	});
	if (!hasStack) {
		var options = {
			title: title,
			body: text.join('\n'),
			severityClass: hasError ? "error" : "success",
			$$parentSlot: globals.getApplication().getMessageSlot()
		};
		_notificationHandler(options);
	} else {
		_diagnoses(title, obj);
	}
};

/* options properties are :
- severityClass : css class depending on severity
- title : title text value used in the template
- text : body text value used in the template
- $$parentSlot : parent to which modal is appended, depends on device type
*/
var _notificationHandler = function(options) {

	// create html
	var h = _getHtml("actionMessage", {
		title: options.title,
		message: options.body,
		severityClass: options.severityClass
	});

	var isClosing;
	// append to app according to device type
	var $$actionModal = $(h);
	options.$$parentSlot.prepend($$actionModal);

	// show parentSlot
	options.$$parentSlot.show();

	// close anchor
	var $$closer = $$actionModal.find("a");

	function toggle() {
		$$actionModal.toggleClass("show");
	}

	function clear() {
		toggle();
		// set timeout in order to have css animation visible before removing DOM
		setTimeout(function() {
			$$actionModal.remove();

			// hide parent slot if last item removed
			if (options.$$parentSlot.children().length == 0) {
				options.$$parentSlot.hide();
			}
		}, 500);
	};

	// bind click action on closer button. triggers close action
	$$closer.bind("click", function() {
		clear();
		isClosing = true;
	});

	// display
	// setTimeout is necessary to have the display css animation working
	setTimeout(function() {
		toggle();
	}, 50);

	// toggle after 5 seconds
	var toggleTimeout = setTimeout(function() {
		if (!isClosing) {
			clear();
		}
	}, 5000);
};


var _modal = function(html, cb) {
	// Disable wait wheel if any
	uiutils.waitWheelStop();
	var app = globals.getApplication();
	if (app && app.currentPage) {
		app.currentPage.waitWheelStop();
	}
	/* Always to retry read template and display alert if not found */
	var h = $(html).modal({
		keyboard: false,
		backdrop: "static"
	});
	var viewportHeight = $(window).height();
	$('.modal-body', h).css('max-height', viewportHeight * 0.7);

	// move modal within the app dom element
	var $$md = $(h);
	var $$parent = $("#s-m-modal-parent") && $("#s-m-modal-parent").length > 0 ? $("#s-m-modal-parent") : $("<div>").attr("id", "s-m-modal-parent");
	$$parent.append($$md);
	$("#s-m-app-id").append($$parent);
	$$parent.toggle(true);

	var done = false;


	// Use <button data-dismiss"modal" for close action
	// Use <button data-action"myaction" for action other than
	// close
	h.on("shown.bs.modal", function(evt) {
		try {
			_execCb(cb, "shown.bs.modal", h);
		} catch (e) {
			alert("Modal open - call back error" + e.stack);
		}
		// !!We need a synchronous call
		app.notifModalOpen();
	});
	// hide.bs.modal is better than hidden.bs.modal be cause it comes sooner
	// Like open modals are accounted in aplication it's better to notifModalClose ASAP otherwise changePage doesn't work fine (no changePage if a modal is opened)
	app.notifModalClose();
	h.on("hide.bs.modal", function() {
		$("#s-m-modal-parent").toggle(false);

		// !!We need a synchronous call
		app.notifModalClose();
		// Call cb only if no click action
		if (!done && cb) {
			try {
				_execCb(cb, "hide.bs.modal", h);
			} catch (e) {
				alert("Modal close - call back error" + e.stack);
			}
		}
		// Called when dialog is close - data-dismiss = "modal"
		// or m.modal('hide')
		h.unbind();
		h.remove();
	});
	// For dialogs with option
	h.delegate("button[data-action]", "click", function(evt) {
		var t = $(evt.target);
		var act = t.attr("data-action");
		if (act) {
			done = true;
			evt.preventDefault();
			evt.stopPropagation();
			_execCb(cb, act, h, t.attr("data-params"));
		}
		// Close modal
		h.modal('hide');
	});
	return h;
};

exports.notify = function(options) {
	options.$$parentSlot = options.$$parentSlot || (globals.getApplication() && globals.getApplication().getMessageSlot());
	_notificationHandler(options);
};

var _displayActionMsg = function(success, name, proto, data) {
	var obj;
	if (data && data.$diagnoses && data.$diagnoses.length > 0) {
		obj = data;
	} else {
		obj = {
			$diagnoses: [{
				$message: "Action: " + name + " " + (success ? "succeeded" : "failed"),
				$severity: success ? "success" : "error",
				$stackTrace: JSON.stringify(data)
			}]
		};
	}
	var title = name;
	if (proto) {
		var links = proto.data("$links");
		var link = links && links[name];
		if (link && link.$title) {
			title = proto.resolveExpression(link.$title);
		}
	}
	_actionResult(title, obj);
};

exports.error = _error;
exports.info = _info;
exports.diagnoses = _diagnoses;
exports.field = _field;
exports.confirm = _confirm;
exports.simpleConfirm = _simpleConfirm;
exports.modal = _modal;
exports.actionResult = _actionResult;
exports.displayActionMsg = _displayActionMsg;
});

define('syracuse-tablet/html/js/init/initStyles',['require','exports','module','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {

/*
 * Module to initialize CSS for used OS/Platform
 *
 */
var globals = require('syracuse-tablet/html/js/helpers/globals');

function _loadCss(file) {
	var ref = document.createElement("link");

	ref.setAttribute("rel", "stylesheet");
	ref.setAttribute("type", "text/css");
	ref.setAttribute("href", file);

	document.getElementsByTagName("head")[0].appendChild(ref);
}

function _getOS() {
	var mobile = (/iphone|ipad|ipod|android|blackberry|mini|windows|palm/i.exec());
	var map = {
		iphone: "ios",
		ipad: "ios",
		ipod: "ios",
		android: "android",
		windows: "windows"
	};

	return $.smUrlParam("forceLookAndFeel") || map[mobile || "windows"] || "windows";
}

function _isSurfaceTablet() {
	navigator.userAgent.toLowerCase().indexOf("tablet pc") > -1 && navigator.userAgent.toLowerCase().indexOf("windows") > -1;
}

function _isReleaseVersion() {
	return (document.location.href.indexOf("index_debug.html") < 0);
}

exports.init = function() {
	var deferred = new $.Deferred();
	var os = _getOS();
	var styles;
	//	if (_isSurfaceTablet()) {
	//		styles = "surface";
	//	} else {
	styles = os;
	//	}
	var cssPlatform = "./css/gen/" + styles + (_isReleaseVersion() ? ".min" : "") + ".css";
	_loadCss(cssPlatform);
	var cssGeneral = "./css/default" + (_isReleaseVersion() ? ".min" : "") + ".css";
	_loadCss(cssGeneral);
	deferred.resolve();
	globals.setLookAndFeel(styles);

	return deferred.promise();
};
});

define('syracuse-tablet/html/js/init/initLocale',['require','exports','module','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var locale = require('syracuse-tablet/html/js/helpers/locale');

exports.init = function() {
	var lang = "en-GB";
	return locale.setLocale(lang);
};
});

define('syracuse-tablet/html/js/application/gadget',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');

var _Gadget = utils.defineClass(function(jsonData) {
	var self = this;
	self._data = jsonData;
}, null, {

	destroy: function() {
		var self = this;
		self._data = null;
	},

	isRequest: function() {
		return this._data.$type === "$request";
	},

	data: function(prop) {
		return this._data ? this._data[prop] : null;
	},

	getEndPoint: function() {
		// Default endpoint if not specified
		return this._data.endpoint || globals.getEndpoint();
	},

	isDefaultEndpoint: function() {
		return !this._data.endpoint;
	},

	getPageName: function() {
		var self = this;
		if (!self.isValid()) return null;
		var rep = self.isRequest() ? self.getRequestRepresentation() : self._data.representation;
		return self.getEndPoint() + "." + rep + "." + self._data.facet;
	},

	getSDataUrl: function(proto) {
		var self = this;
		var url;
		switch (self._data.$type) {
			case "$representation":
				if (["$details", "$edit"].indexOf(self._data.action) > -1) {
					url = proto.data("$url", {
						$key: self._data.keyParameter
					});
				} else if (["$create"].indexOf(self._data.action) > -1) {
					url = proto.data("$url");
					url = url.replace(/\((.*?)\)/, "/$template");
				} else {
					url = proto.data("$url");
				}
				break;
			case "$request":
				url = proto.data("$baseUrl");
				url = url + "/QUERY('" + self._data.requestName + "')?representation=" + self.getRequestRepresentation() + ".$query";
				break;
		}
		return url;
	},
	getRequestRepresentation: function() {
		return "QUERY~" + this._data.requestName + "~" + this._data.requestLevel;
	},
	getJSON: function() {
		return $.extend(true, {}, this._data);
	},
	isValid: function() {
		// to complete
		return this.getInvalidReason() == null;
	},
	getInvalidReason: function() {
		var t = this._data.$type;
		if (t === "$representation" || t === "$stats" || t === "$request") {
			// When we import mobile apps we could have such error
			// tablet client displays a user friendly message
			// to complete
			if (this._data.$uuid.smStartsWith("test")) return null;
			return (this.getEndPoint() || "").trim().length == 0 ? "No endpoint" : null;
		}
		// TODO
		return null;
	},
	getParameters: function() {
		return this._data.parameters || {};
	}
});

exports.Klass = _Gadget;
});

define('syracuse-tablet/html/js/controls/ctrlFactory',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("factory");
var globals = require('syracuse-tablet/html/js/helpers/globals');

var _ctor = {};

var _types = {
	// official types
	string: "application/x-string",
	password: "application/x-password",
	text: "text/plain",
	integer: "application/x-integer",
	real: "application/x-real",
	decimal: "application/x-decimal",
	quantity: "application/x-quantity",
	choice: "application/x-choice",
	boolean: "application/x-boolean",
	date: "application/x-date",
	time: "application/x-time",
	datetime: "application/x-datetime",
	reference: "application/x-reference",
	array: "application/x-array",
	image: "image",
	doc: "application/x-document",
	binary: "application/x-binary",
	soapObject: "application/x-object",
	textRtf: "text/rtf",
	textHtml: "text/html",
	textPlain: "text/plain",
	// our own types
	vignette: "tablet/x-vignette",
	layout: "tablet/x-layout",
	// !! tablet/x-page- prefix means page control
	breadcrumbs: "tablet/x-page-breadcrumbs",
	pageheader: "tablet/x-page-header",
	pagefooter: "tablet/x-page-footer",
	vignettefooter: "tablet/x-vignette-footer",
	vignetteheader: "tablet/x-vignette-header",
	panelactionregular: "tablet/x-page-panel-actionregular",
	panelusersmartphone: "tablet/x-page-panel-usersmartphone",
	panelfiltersort: "tablet/x-page-panel-filtersort",
	icon: "tablet/x-icon",
	button: "tablet/x-button",
	unfound: "tablet/x-unfound",
	rowStatus: "tablet/x-row-status"
};
/**
 * Create a control and insert DOM element in a grid cell
 * 	TODO - Use an HTML builder instead of a control
 */
var _createCellFieldCtrl = function($$parentCell, controller, ctrlArticle, ctrlProto, options) {
	options = options || {};
	// True if the field id added to a cell of a table - Array with table display
	options.displayCtx = "table";
	return _createControl(controller, null, ctrlArticle, ctrlProto, options);
};
/**
 * Create a control
 * 	Add control to controller
 * 	Append control as a child of parentStructElmt
 *  options: arrayCtx : context of array filed display
 */
var _createControl = function(controller, parentStructElmt, article, prototype, options) {
	if (!controller) throw new Error("createControl - null parent or controller");
	options = options || {};
	var c;
	var type = prototype.data("$type");
	switch (type) {
		case _types.string:
		case _types.password:
			switch (prototype.data("$format")) {
				case "$phone":
					c = new _ctor.PhoneField(controller, article, prototype, options);
					break;
				case "$email":
					c = new _ctor.EmailField(controller, article, prototype, options);
					break;
				case "$url":
					c = new _ctor.UrlField(controller, article, prototype, options);
					break;
				default:
					c = new _ctor.Alphanum(controller, article, prototype, options);
			}
			break;
		case _types.integer:
		case _types.real:
		case _types.decimal:
			// "$numDisplay" is an authoring property used to select how to display numeric value (either "gauge" or "normal")
			if (article.$numDisplay) {
				// important in case we switch from "normal" to "gauge"
				if (!article.$gauge && article.$numDisplay === "gauge") {
					article.$gauge = {};
				}
				c = article.$numDisplay === "normal" ? new _ctor.Numeric(controller, article, prototype, options) : new _ctor.Gauge(controller, article, prototype, options);
			} else {
				if (article.$gauge) {
					c = new _ctor.Gauge(controller, article, prototype, options);
				} else {
					c = new _ctor.Numeric(controller, article, prototype, options);
				}
			}
			break;
		case _types.quantity:
			c = new _ctor.Quantity(controller, article, prototype, options);
			break;
		case _types.choice:
			c = new _ctor.Combo(controller, article, prototype, options);
			break;
		case _types.boolean:
			c = new _ctor.CheckBox(controller, article, prototype, options);
			break;
		case _types.date:
		case _types.time:
		case _types.datetime:
			c = new _ctor.Date(controller, article, prototype, options);
			break;
		case _types.reference:
			c = new _ctor.Reference(controller, article, prototype, options);
			break;
		case _types.array:
			if (prototype.data("$cube")) {
				c = new _ctor.CubeChart(controller, article, prototype, options);
			} else {
				c = new _ctor.Array(controller, article, prototype, options);
			}
			break;
		case _types.vignette:
			c = new _ctor.Vignette(controller, article, prototype, options);
			break;
		case _types.image:
		case _types.doc:
		case _types.binary:
			c = new _ctor.Binary(controller, article, prototype, options);
			break;
		case _types.icon:
			c = new _ctor.Icon(controller, article, prototype, options);
			break;
		case _types.button:
			c = new _ctor.Button(controller, article, prototype, options);
			break;
		case _types.textRtf:
		case _types.textHtml:
		case _types.textPlain:
			c = new _ctor.Text(controller, article, prototype, options);
			break;
		case _types.soapObject:
			throw new Error("not implemented");
			break;
		case _types.unfound:
			c = new _ctor.FieldUnfound(controller, article, prototype, options);
			break;
		case _types.rowStatus:
			c = new _ctor.FieldRowStatus(controller, article, prototype, options);
			break;
		default:
			c = new _ctor.TypeUnknown(controller, article, prototype, options);
			break;
	}
	//Field inside a table cell - Nothing - Control is used only to build html - TODO use html Builders instead of control
	if (options.displayCtx === "table") return c;
	if (!parentStructElmt) throw new Error("createControl - Parent's control is mandatory");
	// Add control elmt in a tree
	parentStructElmt.appendStructElmt(c);
	// Add control to controller
	if (options.displayCtx !== "card") {
		controller.addControl(c);
	} // Else array card context we don't add control but build tree - tree is used as a html generator
	return c;
};
var _createLayout = function(controller, parentStructElmt, article, opts) {
	var type = article.$layoutType || "stack";
	var klass;
	if (type == "stack") {
		klass = _ctor.LayoutStack;
	} else if (type == "row") {
		klass = _ctor.LayoutRow;
	} else if (type == "tab") {
		klass = _ctor.LayoutTab;
	} else if (type == "hub") {
		klass = _ctor.LayoutHub;
	} else if (type == "hubGroup") {
		klass = _ctor.LayoutHubGroup;
	} else if (type == "tile") {
		klass = _ctor.LayoutTile;
	} else if (type == "cell") {
		klass = _ctor.LayoutCell;
	} else {
		log && log("layout type=" + type + " is not implemented");
		return null;
	}
	var l = new klass(controller, type, article, opts);
	if (parentStructElmt) {
		parentStructElmt.appendStructElmt(l);
	} else {
		// Root layout
		l.parent = controller;
	}
	controller.addLayout(l);
	return l;
};
/**
 * Creates page static controls - header/footer
 */
var _createPageControl = function(type, controller, options) {
	options = options || {};
	var c;
	switch (type) {
		case "breadcrumbs":
			c = new _ctor.BreadCrumbs(_types.breadcrumbs, controller, options);
			break;
		case "header":
			c = new _ctor.PageHeader(_types.pageheader, controller, options);
			break;
		case "footer":
			c = new _ctor.PageFooter(_types.pagefooter, controller, options);
			break;
		default:
			throw new Error("Unknown page control[" + type + "]");
			break;
	}
	controller.addControl(c);
	return c;
};
var _createActionControl = function(type, vignette, options) {
	if (type === "footer") return new _ctor.VignetteFooter(_types.vignettefooter, vignette, options);
	if (type === "header") return new _ctor.VignetteHeader(_types.vignetteheader, vignette, options);
	throw new Error("Unknown vignette action control[" + type + "]");
};
/**
 * Creates panels
 * id	globals.PANELACTIONSREGULAR, globals.PANELUSERSMARTPHONE, globals.PANELFILTERSORT
 */
var _createPanel = function(controller, panelId, options) {
	var deviceType = globals.getSiteLayout().getDeviceType();
	// We need to store device type to detect changes and recreate panels if needed
	options = options || {
		deviceType: deviceType
	};
	switch (panelId) {
		case globals.PANELACTIONSREGULAR:
			return new _ctor.PageActionPanelRegular(controller, _types.panelactionregular, panelId, options);
		case globals.PANELUSERSMARTPHONE:
			return new _ctor.UserPanelSmartphone(controller, _types.panelusersmartphone, panelId, options);
			break;
		case globals.PANELFILTERSORT:
			return new _ctor.FilterSortPanel(controller, _types.panelfiltersort, panelId, options);
		default:
			throw new Error("Unknown page control[" + panelId + "]");
	}
	// Control is not added here but by panel manager
};

/*
 * This is a trick used by authoring
 * We create a dummy control that only returns an article with a $bind node
 * This allows authoring to only add this kind of untyped controls and after a refresh,
 * the base system creates the "real" control.
 */
var _createBindControl = function(controller, parentStructElmt, article) {
	if (!controller) throw new Error("Control - null parent or controller");
	var c = new _ctor.StructElmt(controller, "$dummyBind", article, {}, {});
	if (parentStructElmt) {
		// Add control elmt in a tree
		parentStructElmt.appendStructElmt(c);
	} else {
		throw new Error("Parent's control is mandatory");
	}
	return c;
};


exports.createPanel = _createPanel;
exports.createControl = _createControl;
exports.createLayout = _createLayout;
exports.createPageControl = _createPageControl;
exports.createActionControl = _createActionControl;
exports.createCellFieldCtrl = _createCellFieldCtrl;
exports.createBindControl = _createBindControl;

exports.type = function(name) {
	return _types[name];
};
exports.setImpl = function(name, ctor) {
	_ctor[name] = ctor;
};
});

define('syracuse-tablet/html/js/helpers/articleParser',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/controls/ctrlFactory','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("articleParser");
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

/**
 * Return true if jsonArrayProto is a single array
 * For one cell array prototype doesn't contain $properties
 * For one x-reference cell array $properties of prototype isn't $properties of the array but $properties of the reference field
 * This code is shared with prototype class
 */
var _isSingleArray = function(jsonArrayProto) {
	return jsonArrayProto.$item.$properties == null || jsonArrayProto.$type == "application/x-reference";
};
/**
 * Parses an article and generate the control tree structure
 */
var _Parser = utils.defineClass(
	function(page) {
		// Controller
		var self = this;
		self.page = page;
	}, null, {
		_doParse: function(article, prototype, parent, opts, unfounds) {
			var self = this;
			if (article.$layoutType) {
				var lyt = ctrlFactory.createLayout(self.page, parent, article, opts);
				if (lyt && article.$items) {
					if (prototype.isQuery()) {
						prototype = prototype.getPrototype("$resources");
					}
					article.$items.forEach(function($itm) {
						// Important: Do not clone article here since full tree has to be preserved	
						self._doParse($itm, prototype, lyt, opts, unfounds);
					});
				}
				return lyt;
			} else if (article.$bind) {
				var fieldProto = prototype.getPrototype(article.$bind);
				if (fieldProto == null && article.$isUnfound !== true) {
					unfounds.push(article);
				} else {
					if (article.$isUnfound) {
						fieldProto = prototype.create({
							$type: "tablet/x-unfound"
						});
					}
					if (!fieldProto.$isExcluded) {
						// Important: Do not clone article here since full tree has to be preserved
						ctrlFactory.createControl(self.page, parent, article, fieldProto, opts);
					}
				}
			} else {
				log && log("$layoutType or $bind exspected");
				//throw new Error ("$layoutType or $bind expected");
			}
		},
		parse: function(article, prototype, opts) {
			var self = this;
			try {
				if (!article || !prototype) throw new Error("Not empty article and prototype are expected");
				if (!article.$layoutType) {
					//Mandatory - Better than an exception	
					article.$layoutType = "stack";
				}
				var unfounds = [];
				var loc = article.$localization && article.$localization[locale.getCurrentLocale()];
				opts.$localization = loc;
				var root = self._doParse(article, prototype, null, opts, unfounds);
				if (unfounds.length > 0 && globals.getDvlpOpt("showUnfoundFields")) {
					var article = {
						$layoutType: "stack",
						$items: []
					};
					unfounds.forEach(function(f) {
						article.$items.push($.extend(true, f, {
							$isUnfound: true
						}));
					});
					self._doParse(article, prototype, root, opts, null);
				}
				return root;
			} catch (e) {
				log && log('article parser error', e);
				throw new Error("Error parsing article [" + e.message + "]\n" + jsutils.cleanStack(e.stack));
			}
		}
	}
);

/**
 * Parses article and calls the controls factory
 * 		article: json description
 *  	prototype: prototype object (Prototype class)
 *  Return root element (layout)
 */
var _article2Controls = function(page, article, prototype, opts) {
	var p = new _Parser(page);
	return p.parse(article, prototype, opts);
};

/**
 * Convert a desktop article to tablet one
 * 		article:  desktop json description
 *  	prototype: prototype object (Prototype class)
 */
var _defOption = {
	skipblock: true,
	skipsection: true,
	include: ["$category", "$layoutType", "$title", "$bind"],
	exclude: ["$items", "$widths"],
	protoExclude: ["application/x-array", "application/json"]
};

var _convertWidth = function(widths) {
	var r = [];
	widths = widths.split(",");
	// temporarily - We can also embed cells into 
	if (widths.length === 0) throw new Error("Number of cells/rows must be > 0");
	if (widths.length > 12) throw new Error("Number of cells/rows must be <= 12");
	var sum = 0;
	widths.forEach(function(w) {
		w = parseInt(w, 10);
		w = Math.ceil(w / 12);
		sum += w;
		r.push(w);
	});
	if (sum > 12) {
		var d = sum - 12;
		r.sort();
		while (d > 0) {
			// Remove excess starting from large cells
			for (var i = r.length - 1; i >= 0; i--) {
				if (d > 0 && r[i] > 1) {
					r[i] = r[i] - 1;
					d--;
				}
			}
		}
	} else if (sum < 12) {
		var d = 12 - sum;
		r.sort();
		while (d > 0) {
			// Add shortage starting from small cells
			for (var i = 0; i < r.length; i++) {
				if (d > 0) {
					r[i] = r[i] + 1;
					d--;
				}
			}
		}
	}
	return r.join(",");
};
var _scanDesktop = function(json, options) {

	if (!json) return null;
	// we skip $layout
	var res;
	if (json.$layout) {
		res = _scanDesktop(json.$layout, options);
	} else {
		res = {};
	}
	if (json.$layoutType) {
		if (!json.$items) throw new Error("$items is missing");
		res.$items = [];
		json.$items.forEach(function(itm) {
			res.$items.push(_scanDesktop(itm, options));
		});
	}
	for (var p in json) {
		if (p === "$widths") {
			res[p] = _convertWidth(json[p]);
		} else if (options.exclude.indexOf(p) === -1 && options.include.indexOf(p) >= 0) {
			res[p] = json[p];
		}
	}
	return res;
};

var _convertDesktop = function(article, prototype, options) {
	options = $.extend({}, _defOption, options);
	return _scanDesktop(article, options);
};

exports.article2Controls = _article2Controls;
exports.convertDesktop = _convertDesktop;
exports.isSingleArray = _isSingleArray;
});

define('syracuse-tablet/html/js/helpers/prototype',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/application/gadget','syracuse-tablet/html/js/helpers/articleParser'],function (require, exports, module) {
var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Gadget = require('syracuse-tablet/html/js/application/gadget').Klass;
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');

/**
 * Return json prototype of an array or null if proto is not an array
 * proto is a prototype object or a JSON object
 * This code is shared with prototype class
 */
var _getArrayJsonProto = function(proto) {
	if (!proto) return null;
	var json;
	if (!$.isPlainObject(proto)) {
		if (proto.isArray()) {
			json = proto.json;
		} else if (proto.parent) {
			json = proto.parent.json;
		}
	} else {
		json = proto;
	}
	if (json == null || json.$type !== "application/x-array") return null;
	return json;
};

var _testFacet = /representation=.*\.\$(\w+)[&]*/;

/**
 * getFieldNameForValue
 */
var _reg1 = /{[^}]+}/g,
	_reg2 = /[{}]/g;
/**
 * Prototype class
 * 	Provides all the method to deal with prototype
 * 	manage prototype chaining parent -> child
 * !!use Prototype methods instead of dealing directly with JSON
 */
var _Prototype = utils.defineClass(function(json, parent) {
	var self = this;
	this.json = json || {};
	if (typeof this.json == "string") {
		this.json = JSON.parse(self.json);
	}
	if (parent) {
		this.parent = parent;
	}
	this.init();
}, null, {
	init: function() {
		var props = this.json.$properties;
		if (!props) return;
		for (var p in props) {
			if (props[p].$type === "application/x-reference") {
				this.initRefField(props[p], p);
			}
		}
	},
	destroy: function() {
		// Just set to null
		this.parent = null;
		// Just set to null
		this.json = null;
	},
	/**
	 * returns json[prop]
	 * 	ignoreParent: true -> Don't read property in parent
	 */
	data: function(prop, dataContext, ignoreParent, noResolve) {
		if (!prop || prop.length == 0) return null;
		var val = this.json[prop];
		if (val == null) {
			if (ignoreParent == null) {
				if (["$title", "$description"].indexOf(prop) > -1) {
					ignoreParent = true;
				}
			}
			var pVal = ignoreParent !== true && this.parent ? this.parent.data(prop, dataContext, null, true) : val;
			if (pVal != null) {
				this.json[prop] = pVal;
			}
			return pVal;
		}
		if (noResolve) {
			return val;
		}
		// #5793 we resolve with searchInParents = true -> expression variable will be searched in dataContext and parent
		return this.resolveExpression(val, dataContext, true);
	},
	/**
	 * returns JSON for json.$properties[name]
	 * If prop!=null returns json.$properties[name][prop]
	 * dataContext: optional
	 */
	property: function(name, prop, dataContext) {
		if (!name || name.length === 0) return null;
		var o = this.json.$properties ? this.json.$properties[name] : this.parent ? this.parent.property(name) : null;
		if (!o || !prop) return o;
		return this.resolveExpression(o[prop], dataContext);
	},
	/**
	 * True if the property prop is a x-reference
	 */
	isReference: function(propname) {
		var res;
		if (this._cacheRef != null) {
			res = this._cacheRef[propname];
			if (res != null) return res;
		}
		var p = this.property(propname);
		res = p != null && p.$type === "application/x-reference";
		if (!this._cacheRef) this._cacheRef = {};
		this._cacheRef[propname] = res;
		return res;
	},
	/**
	 * True proto is a x-array
	 */
	isArray: function() {
		return this.json.$type === "application/x-array";
	},
	/**
	 * True proto is a x-array
	 */
	isBlob: function() {
		var t = this.json.$type;
		return t === "image" || t === "application/x-document" || t === "application/x-array";
	},
	/**
	 * Check value and resolve if it's an expression or title otherwise return val
	 * 	dataContext optional (used for expressions other than localization)
	 */
	resolveExpression: function(val, dataContext, searchInParent) {
		if (val && val.indexOf && val.indexOf('{') >= 0) {
			val = utils.parseExpression(val, dataContext, this, searchInParent);
		}
		return val;
	},
	localization: function(val) {
		var self = this;
		var loc = self.json.$localization || {};
		return loc[val] ? loc[val] : self.parent ? self.parent.localization(val) : null;
	},
	/**
	 * returns a prototype object for json.$properties[prop] or $item proto for grids
	 * prop			$items for arrays
	 * 				propertyName for fields
	 * 				path with . as separator of data in other cases (rowDetail)
	 *  override: 	optional - override JSON properties
	 *  			used by row detail to get page prototype from array field proto
	 *  facet		force facet
	 */
	getPrototype: function(prop, override, facet) {
		var json;
		if (prop.indexOf(".") > 0) {
			json = this.getDataByPath(prop);
		} else if (prop === "$item") {
			json = this.data(prop);
			if (this.isSingleArray(true)) { /** we create a standard proto compliant with multiple columns arrays **/
				var newJson = {
					$properties: {},
					$type: "application/json"
				};
				newJson.$properties[globals.SINGLEARRAYPROP] = json;
				json = newJson;
			}
		} else {
			json = this.property(prop);
		}
		if (!json) return null;
		override = $.extend(true, {}, json, override);
		var proto = exports.create(override, this);
		if (proto.json.$links && proto.json.$links[prop] && proto.json.$links[prop].$url !== undefined) {
			proto.json.$format = proto.json.$format || "$url";
		}
		if (facet) {
			proto._facet = facet;
		}
		return proto;
	},
	/**
	 * Query prototype
	 */
	isQuery: function() {
		return this.isFacet("query");
	},
	/**
	 * Lookup prototype
	 */
	isLookup: function() {
		return this.isFacet("lookup");
	},
	isDetails: function() {
		return this.isFacet("details");
	},
	/**
	 * return true if aguments contain the facet
	 * Ex: 	isFacet("edit, "detail") return true if edit OR detail
	 * 		isFacet("detail") return true if detail
	 */
	isFacet: function() {
		return Array.prototype.indexOf.call(arguments, this.getFacet()) >= 0;
	},
	/**
	 * Format for display a value according to proto description
	 * Temporarily
	 */
	formatDisplay: function(prop, dataContext) {
		var self = this;
		var info = self.property(prop);

	},
	/**
	 * Temporarily - Add our own property - TODO Find another way
	 * 		Add row index in prototype for grids
	 */
	addProperty: function(name, descr) {
		var self = this;
		if (descr && self.json.$properties && !self.json.$properties[name]) {
			self.json.$properties[name] = descr;
		}
	},
	getPropTitle: function(propName) {
		var self = this;
		var prop = self.property(propName);
		return prop && prop.$title ? self.resolveExpression(prop.$title) : "";

	},
	getUrlLink: function(propName) {
		var self = this;
		var prop = self.property(propName, "$links");
		return prop ? prop[propName] : null;
	},
	getFacet: function() {
		if (this._facet == null) {
			// We read the facet from this -> parent and keep the first one
			// !! do not take the one of root parent 
			var p = this,
				t;
			while (p != null && t == null) {
				if (p.json.$url != null && p.json.$url.trim().length != 0) {
					t = _testFacet.exec(p.json.$url);
					t = t != null && t.length == 2 ? t[1] : null;
				}
				p = p.parent;
			}
			this._facet = t || "";
		}
		return this._facet;
	},
	/**
	 * Returns the name of the field that contains the value ($refValue)
	 * 	For std type it returns name
	 * 	For reference type
	 * 		Set $refValue in prototype
	 * 		Set $lookupdescr - I don't remember if it will be used in tablet but I suppose - TODO remove if not used
	 * 		In mobile client this method was called after having loaded the prototype to calculated additionnal information needed by the client
	 */

	getFieldNameForValue: function(name) {
		var protoField = this.property(name);
		var item = protoField && protoField.$item;
		// reference fiels have been initialized at creation of proto object - initRefField
		return item && item.$refValue ? item.$refValue : name;
	},
	getFieldTypeForValue: function(name) {
		var protoField = this.property(name);
		var item = protoField && protoField.$item;
		// Type of bind field - Same as $type for non reference type and non quantity field
		var type = item && item.$refValueType ? item.$refValueType : null;
		var value = protoField && protoField.$value;
		type = value && value.$type ? value.$type : null;
		return type ? type : protoField.$type;
	},
	/**
	 * TODO - Test with Syracuse entities and X3 test screens
	 */
	initRefField: function(protoField, name) {
		var self = this;
		if (!protoField) throw new Error("Field proto expected[" + name + "]");
		var item = protoField.$item;
		if (!item || item.$refValue) return;
		item.$refValue = item.$lookupValue = name;
		if (item.$value && typeof item.$value == "string") {
			var vals = item.$value.match(_reg1);
			if (vals && vals.length == 1) {
				// In X3 we expect only one param in $values -> "{CUR}"
				// v : must point to key of cd object - { $value:"{F1}", F1:"{F2}"} - F2 must be a field of cd parent
				var f1 = vals[0].replace(_reg2, "").trim();
				// See AQTCRUDM Tabel Diverse -> $value = {CODE} means that value of xref field value is given by the field CODE
				item.$lookupValue = f1;
				if (item[f1]) {
					var f2 = item[f1].replace(_reg2, "").trim();
					if (self.property(f2)) {
						// Field that contains the value in the prototype - Same field in collaboration - Dedicated field in X3 :-(
						item.$refValue = f2;
					} // else field not found in parent keep $$refValue = property
				} else {
					item.$refValue = f1; // else item  key not found keep $refValue = property
				}
			} else {
				throw new Error("Prototype.initRefField - Only one value is expected");
			}
		}
		if (item.$refValue) {
			var p = self.property(item.$refValue);
			if (p && p.$type) {
				item.$refValueType = p.$type;
			}
		}
		return item.$refValue;
	},
	/**
	 * return the value of a given path
	 * 	path:	String with/without '.' as separator or array of strings
	 */
	getDataByPath: function(path) {
		if (!this._cahePath) this._cahePath = {};
		return utils.getPropByPath(this.json, path, this._cahePath);
	},
	getVignetteGadget: function() {
		var json = this.data("$gadget");
		return json ? new Gadget(json) : null;
	},
	/**
	 * Calculates the prototype and other info for unit field
	 */
	getUnitFieldInfo: function() {
		var self = this;
		var res = {};
		res.$unit = self.data("$unit");
		if (typeof res.$unit == "object") {
			res.unitBindName = "$unit";
			res.unitFieldProto = exports.create($.extend({}, self.$unit));
		} else if (typeof res.$unit == "string") {
			res.unitBindName = res.$unit;
			var parent = self.parent;
			while (parent) {
				var unitProto = parent.property(res.$unit);
				if (unitProto) {
					res.unitFieldProto = exports.create($.extend({}, unitProto));
					break;
				}
				parent = parent.parent;
			}
		}
		return res;
	},

	/**
	 * True if array has one column - Single array
	 * Protocole isn't consistent because there a confusion with x-reference fields
	 * current object is array proto or array.$item proto
	 * field!=null -> Check field's proto
	 **/
	isSingleArray: function(noFail, field) {
		var jsonArray;
		if (field != null) {
			jsonArray = this.property(field);
		} else {
			if (this.$singleArray) return this.$singleArray;
			jsonArray = _getArrayJsonProto(this);
		}
		if (jsonArray == null && noFail) return false;
		if (jsonArray == null) throw new Error("Unexpected parent array");
		var res = articleParser.isSingleArray(jsonArray);
		if (field != null) {
			// Cache
			this.$singleArray = res;
		}
		return res;
	},
	getPropertyNames: function() {
		var props = this.json.$properties;
		if (props) {
			return Object.keys(props);
		}
		return [];
	},
	/**
	 * Create a child proto from JSON
	 * Used by example for unknown fields
	 */
	create: function(json) {
		return exports.create($.extend(true, {}, json), this);
	},
	/**
	 * this is the prototype of an array field
	 * return information on columns to display
	 * $bindValue is the field that contains the value - For non-refrence bindValue = $bind
	 */
	arrayTableGetColInfo: function() {
		var base = {
			$title: "",
			$titleOrig: "", // title not resolved
			$type: "",
			$bind: "",
			$widthType: "auto",
			$widthVal: 0,
			$capabilities: ""
		};
		var res = [];
		if (this.isSingleArray()) {
			var prop = this.getDataByPath("$item");
			var p = $.extend({}, base, prop);
			p.$title = this.resolveExpression(this.$title);
			p.$titleOrig = this.$title;
			p.$bind = globals.SINGLEARRAYPROP;
			res.push(p);
		} else {
			var props = this.getDataByPath("$item.$properties");
			if (!props) return null;
			var prop;
			var self = this;
			var itemProto = this.getPrototype("$item");
			Object.keys(props).forEach(function(key) {
				prop = props[key];
				if (prop.$isExcluded !== true && (globals.EXCLUDEFIELDS.indexOf(key) < 0)) {
					var p = $.extend({}, base, prop);
					p.$title = self.resolveExpression(prop.$title);
					p.$titleOrig = prop.$title;
					// Bind field - Ex SITE_REF
					p.$bind = key;
					// Name of the field that contains the value - !=$bind for non reference fields - Ex For SITE_REF -> SITE
					p.$bindValue = itemProto.getFieldNameForValue(key);
					// Type of the field that contains the value - !=$type for non reference fields - Ex For SITE -> "application/x-string"
					p.$bindType = itemProto.getFieldTypeForValue(key);
					res.push(p);
				}
			});
		}
		return res;
	},
	getRepDotFacet: function() {
		var self = this;
		return self.data("$type").split(".").slice(-2).join(".");
	},
	isValid: function() {
		return this.json != null;
	}
});
/**
 * To manage a row index in arrays
 */
exports.getRowIdxProto = function() {
	return exports.create({
		$type: "application/x-integer"
	});
};
/**
 * Constructor
 */
exports.create = function(json, parent) {
	return new _Prototype(json, parent);
};
});

define('syracuse-tablet/html/js/authoring/authoringArticleGen',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

/*
 * Generator for articles of different page types and scrolling models
 *
 */

var _testFacet = /representation=.*\.\$(\w+)[&]*/;
var _getFacet = function($url) {
	var t = _testFacet.exec($url || "");
	return t != null && t.length == 2 ? t[1] : null;
};
exports.genNewArticle = function(opts, synch) {
	var proto;
	proto = opts.page.prototype;

	if (jsutils.isInstanceOf(opts.page, "DashboardPage")) {
		return exports.generateDashboardArticle(proto, opts.orientation, opts.template, synch);
	} else {
		return _generateRegularArticle(proto, opts.orientation, opts.template, synch);
	}
};

exports.generateDashboardArticle = function(proto, orientation, tpl, synch) {

	var article;
	proto = $.isPlainObject(proto) ? proto : proto.json;
	var props = proto.$properties;

	if (orientation === "horizontal") {
		article = {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "",
				"$items": []
			}]
		};

		// Just create root and return if requested
		if (tpl === false) {
			return $.smResolve(article);
		}

		Object.keys(props).forEach(function(key) {
			var prop = props[key];
			article.$items[0].$items.push({
				"$layoutType": "tile",
				"$size": "medium",
				"$items": [{
					"$bind": key,
				}]
			});

		});
	} else {
		article = {
			"$layoutType": "stack",
			"$items": []
		};

		// Just create root and return if requested
		if (tpl === false) {
			return $.smResolve(article);
		}

		var cellCount = 4;
		var row;
		Object.keys(props).forEach(function(key) {
			if (cellCount === 4) {
				cellCount = 0;
				row = {
					"$layoutType": "row",
					"$items": []
				};
				article.$items.push(row);
			}
			var prop = props[key];
			row.$items.push({
				"$layoutType": "cell",
				"$widthXs": 12,
				"$widthSm": 6,
				"$widthMd": 4,
				"$widthLg": 3,
				"$items": [{
					"$bind": key,
				}]
			});
		});
	}
	return synch === true ? article : $.smResolve(article);
};

function _generateRegularArticle(proto, orientation, tpl, synch) {
	proto = $.isPlainObject(proto) ? proto : proto.json;
	if (proto.$type === "application/x-array") {
		proto = proto.$item;
	}
	var props = proto.$properties;
	var $items, prop;
	var forceNoTitle = _getFacet(proto.$url) === "query";
	if (orientation === "horizontal") {
		article = {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "",
				"$items": []
			}]
		};

		// Just create root and return if requested
		if (tpl === false) {
			return $.smResolve(article);
		}

		var groupItems = article.$items[0].$items;
		var maxItemsPerGroup = 4;
		var itemsPerGroup = maxItemsPerGroup;
		var tileItems;
		var singlePropTypes = ["application/x-array", "application/x-document", "image"];
		for (var p in props) {
			prop = props[p];
			if (prop.$isExcluded !== true) {
				if (singlePropTypes.indexOf(prop.$type) > -1) {
					var tile = {
						"$layoutType": "tile",
						"$size": "large",
						"$items": []
					};
					groupItems.push(tile);
					tileItems = tile.$items;
					itemsPerGroup = maxItemsPerGroup;
				} else if (itemsPerGroup >= maxItemsPerGroup) {
					itemsPerGroup = 0;
					var tile = {
						"$layoutType": "tile",
						"$size": "large",
						"$items": []
					};
					groupItems.push(tile);
					tileItems = tile.$items;
				}
				itemsPerGroup = itemsPerGroup + 1;
				var a = {
					$bind: p
				};
				if (forceNoTitle) {
					a.$isTitleHidden = forceNoTitle;
				} else {
					a.$labelPosition = "top";
				}
				tileItems.push(a);
			}
		}

	} else {
		var article = {
			$layoutType: "stack",
			$items: []
		};

		// Just create root and return if requested
		if (tpl === false) {
			return $.smResolve(article);
		}

		$items = article.$items;
		for (var p in props) {
			prop = props[p];
			if (prop.$isExcluded !== true) {
				var a = {
					$bind: p
				};
				if (forceNoTitle) {
					a.$isTitleHidden = forceNoTitle;
				}
				$items.push(a);
			}
		}
	}

	return synch === true ? article : $.smResolve(article);
}
});

define('syracuse-tablet/html/js/helpers/dashboardUtils',['require','exports','module','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/authoring/authoringArticleGen'],function (require, exports, module) {

var prototype = require('syracuse-tablet/html/js/helpers/prototype');
var authArticleGen = require('syracuse-tablet/html/js/authoring/authoringArticleGen');

/**
 *  Generates proto form dashBoard description
 **/
var _getDashboardProto = function(dash) {
	var proto = {
		$title: dash.$title,
		$description: dash.$description,
		$properties: {},
		$dashboardName: dash.$dashboardName
	};
	var vignetteIds = Object.keys(dash.$vignettes || []);
	for (var i = 0; i < vignetteIds.length; i++) {
		var vignetteId = vignetteIds[i];
		var property = $.extend({}, dash.$vignettes[vignetteId]);
		var gadgetId = property.$uuid;

		property.$gadget = dash.$gadgets[gadgetId];
		if (property.$gadget) {
			property.$gadget = $.extend({}, property.$gadget);
			// Set gadget uuid
			property.$gadget.$uuid = gadgetId;
			// Set vignette uuid
			property.$uuid = vignetteId;
			// Set type - "application/x-string"
			property.$type = "tablet/x-vignette";
			property.$title = property.$gadget.$title;
		} else {
			property.$gadget = {
				$uuid: gadgetId,
				$type: "$gadgetMissing"
			};
			property.$uuid = vignetteId;
			property.$type = "tablet/x-vignette";

		}
		proto.$properties[vignetteId] = property;
	}
	return prototype.create(proto);
};

/**
 * Returns $article from dashBoard info
 * 		Calculates and Sets $article if no $article was found
 */
var _getDashboardArticle = function(proto) {
	return authArticleGen.generateDashboardArticle(proto, "orientation");
};

var _getDashboardInfo = function(dashboardMetaData) {
	return $.smResolve()
		.then(function() {
			var article = dashboardMetaData.$article;
			var proto = _getDashboardProto(dashboardMetaData);
			if (!article) {
				return _getDashboardArticle(proto)
					.then(function(article) {
						dashboardMetaData.$article = article;
						return {
							article: $.extend({}, article),
							prototype: proto
						};
					});
			} else {
				return {
					article: $.extend({}, article),
					prototype: proto
				};
			}
		});

};

exports.getDashboardInfo = _getDashboardInfo;
exports.getDashboardArticle = _getDashboardArticle;
exports.getDashboardProto = _getDashboardProto;
});

define('syracuse-tablet/html/js/application/appFactory',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/dashboardUtils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("factory");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var dashboardUtils = require('syracuse-tablet/html/js/helpers/dashboardUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _ctor = {
	Application: function() {
		throw new Error("Not implemented");
	},
	DashoardPage: function() {
		throw new Error("Not implemented");
	},
	RegularPage: function() {
		throw new Error("Not implemented");
	},
	RowDetailPage: function() {
		throw new Error("Not implemented");
	},
	LookupPage: function() {
		throw new Error("Not implemented");
	},
	LoginPage: function() {
		throw new Error("Not implemented");
	},
	DaoApp: function() {
		throw new Error("Not implemented");
	},
	DaoSdata: function() {
		throw new Error("Not implemented");
	}
};

var _createApplication = function($$elmt) {
	var res = new _ctor.Application($$elmt, exports);
	res.init();
	log && log("Application", "Create ok");
	return res;
};

// $forceLinkArticle is used in test entities to attach a $article to a $link vignette
// -> convenient for unit test
var _createPage = function($parent, state, parentPage, $forceLinkArticle) {
	var res = null;
	var type = state.type;
	var deferred = $.Deferred();
	var options = {};
	try {
		switch (type) {
			case "static":
				if (state.subtype === "html") {
					switch (state.name) {
						case "login":
							res = new _ctor.LoginPage($parent, state, options);
							break;
						default:
							throw new Error("_createPage - unknown html page [" + state.name + "]");
					}
				} else {
					throw new Error("_createPage - unknown static subtype [" + state.subtype + "]");
				}
				break;
			case "dashboard":
				globals.getMetaData().getDashboard(state.dashboardName)
					.then(function(dashboardMetaData) {
						return dashboardUtils.getDashboardInfo(dashboardMetaData);
					})
					.then(function(dashboardInfo) {
						if (state.isWelcomePage === true) {
							res = new _ctor.WelcomeDashoardPage($parent, state, dashboardInfo.prototype, dashboardInfo.article, options);
						} else {
							res = new _ctor.DashoardPage($parent, state, dashboardInfo.prototype, dashboardInfo.article, options);
						}
						deferred.resolve(res);
					})
					.fail(function(e) {
						deferred.reject(e);
					});
				break;
			case "regular":
			case "rowdetail":
			case "carddesign":
				globals.getMetaData().getPageDetails(state)
					.then(function(info) {
						if (!info) {
							return $.smReject({
								message: locale.text("error.page.not.found", [state.name])
							});
						}
						if (info.prototype.isLookup()) {
							res = new _ctor.LookupPage($parent, state, info.prototype, info.article, options);
						} else if (type === "rowdetail") {
							res = new _ctor.RowDetailPage($parent, state, info.prototype, info.article, parentPage, options);
						} else if (type === "regular") {
							if ($forceLinkArticle) {
								// ONLY FOR TEST ENTITIES - Store article attached to a link in order to magae the back
								state.forceLinkArticle = $forceLinkArticle;
							}
							res = new _ctor.RegularPage($parent, state, info.prototype, $forceLinkArticle ? $forceLinkArticle : info.article, options);
						} else if (type === "carddesign") {
							res = new _ctor.CardDesignPage($parent, state, info.prototype, info.article, parentPage, options);
						}
						deferred.resolve(res);
					}).fail(function(e) {
						deferred.reject(e);
					});
				break;
			default:
				throw new Error("Unknown page type[" + type + "]");
				break;
		}
		if (res) {
			// Synchronous result
			deferred.resolve(res);
		}
		log && log("New Page", "Create ok");
	} catch (e) {
		deferred.reject(e);
	} finally {
		return deferred.promise();
	}
};

var _createDaoApp = function(appli) {
	var dao = new _ctor.DaoApp(appli);
	log && log("New DAO Application", "Create ok");
	return dao;
};

var _createDaoSdata = function(type, data, prototype, parent) {
	var dao;
	switch (type) {
		case "representation":
		case "process":
		case "request":
		case "statistics":
		case "dashboardpage":
		case "externallink":
			dao = new _ctor.DaoSdata(data, prototype, parent);
			break;
		default:
			throw new Error("Unknown DaoSdata type[" + type + "]");
			break;
	}
	log && log("New DAO View", "Create ok");
	return dao;
};

exports.setImpl = function(name, ctor) {
	_ctor[name] = ctor;
};

exports.createApplication = _createApplication;
exports.createPage = _createPage;
exports.createDaoApp = _createDaoApp;
exports.createDaoSdata = _createDaoSdata;
});

define('syracuse-tablet/html/js/sdata/sdataUtils',['require','exports','module','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');

var _fieldsMeta = ["$isMandatory", "$isReadOnly", "$isHidden", "$isExcluded", "$isDisabled", "$actions", "$format"];

var _rID = /^(.*)\(\'(.*)\'\)$/i;
/**
 * nofail= true	return null if error
 */
var _parseSDataURL = function(url, noFail) {
	var res = utils.parseURL(url);
	if (res.query && res.query.representation) {
		res.representation = res.query.representation;
		res.facet = null;
		var p = res.representation.indexOf('.');
		if (p != -1) {
			res.facet = res.representation.substr(p + 1);
			if (res.facet.charAt(0) == '$') res.facet = res.facet.substr(1);
			res.representation = res.representation.substr(0, p);
		}
	}
	var a;
	if (res.directory) {
		var idx = res.directory.indexOf("/$services/");
		if (idx > -1) {
			res.$services = res.directory.substring(idx + 11);
		}
		a = res.directory.split('/');
	}
	if (a == null || a.length <= 4) {
		if (noFail === true) return null;
		throw new Error("Bad sdata url:" + url);
	}
	res.dispatch = a[1];
	if (res.dispatch !== "mobile1" && res.dispatch !== "sdata") {
		if (noFail === true) return null;
		throw new Error("Bad sdata url:" + url);
	}
	res.application = a[2];
	res.contract = a[3];
	res.dataset = a[4];
	if (a.length === 4) return res;
	var match = _rID.exec(a[5]);
	if (match && (match.length == 3)) {
		res.entity = match[1];
		res.id = match[2];
		if (res.id && res.id.trim().Length === 0) res.id = null;
	} else {
		res.entity = a[5];
		res.id = null;
	}
	if (a.length === 5) return res;
	return res;
};

/**
 * Resolve sdataurl and return navigation info to generate the <a>/<button> link
 * nofail= true	return null if error
 */
var _getLinkInfo = function(sDataUrl, dao, nofail) {
	// dao is optional since a link can be a link without dataset (e.g. prev/next)
	sDataUrl = dao ? dao.parseExpression(sDataUrl) : sDataUrl;
	var url = _parseSDataURL(sDataUrl, nofail);
	if (url == null) return null;
	if (url.entity === "$mobileDashboards") {
		var res = {
			page: url.query.dashboard + ".$mobileDashboard"
		};
		if (url.query.parameters) {
			res.parameters = utils.parseExpression(url.query.parameters, dao);
		}
		return res;
	}
	if (url.query.representation) {
		var ep = url.application + "." + url.contract + "." + url.dataset;
		var res = {
			page: ep + (url.query.representation ? "." + url.query.representation : ""),
			sDataUrl: sDataUrl
		};
		if (url.$services) {
			// Mandatory to make the difference between a page link and action link
			res.$services = url.$services;
		}
		return res;
	}
	if (nofail === true) return null;
	throw new Error("getLinkInfo - Unexpected empty representaion in ul " + sDataUrl);
};
/**
 * Returns attributes for link tag
 * 	linkInfo: 	object returned by _getLinkInfo
 * 				or sdataUrl
 * dao:			mandatory if linkInfo is a sdataUrl
 */
var _getLinkAttrs = function(linkInfo, dao) {
	if (typeof linkInfo === "string") {
		// We assume that linkInfo is the url - we need dao
		linkInfo = _getLinkInfo(linkInfo, dao);
	}
	if (linkInfo.type === "navig") {
		return 'data-nav="' + linkInfo.page + '" data-sdata-url="' + encodeURIComponent(linkInfo.sDataUrl) + '"';
	} else if (linkInfo.type === "act") {
		return 'data-action="' + linkInfo.action + '" data-params="' + encodeURIComponent((linkInfo.params || "")) + '"';
	} else {
		throw new Error("_getLinkAttrs - unknonwn type\n" + linkInfo.type);
	}
};
/**
 * SCan diagnoses in a sdata response
 * TODO TEST
 */
var _clearSyracuseStack = function(d) {
	if (d.$stackTrace && d.$stackTrace.indexOf("node_modules\syracuse-x3") >= 0) {
		if (d.$message && d.$stackTrace.indexOf(d.$message) >= 0) {
			// No need of stack
			delete d.$stackTrace;
		} else {
			// Remove stack because too long
			d.$stackTrace = d.$stackTrace.split("\n")[0];
		}
	}
	return d;
};
var _scanDiagnoses = function(data) {
	var result = [];
	var done = [];
	var _scan = function(o, prop, path) {
		if (!path) path = [];
		if (done.indexOf(o) >= 0) return;
		if (Array.isArray(o)) {
			done.push(o);
			if (prop) path.push(prop);
			o.forEach(function(e, idx) {
				_scan(e, idx + "", path);
			});
			if (prop) path.pop(prop);
		} else if ($.isPlainObject(o)) {
			done.push(o);
			for (var p in o) {
				if (p === "$diagnoses") {
					o[p].forEach(function(d) {
						var $path = [].concat(path);
						if (prop) $path.push(prop);
						if (p) $path.push(p);
						d = _clearSyracuseStack($.extend({}, d));
						d.$path = $path.join('.');
						result.push(d);
					});
				} else {
					if (prop) path.push(prop);
					_scan(o[p], p, path);
					if (prop) path.pop(prop);
				}
			}
		}
	};
	if (data != null) _scan(data);
	return result;

};

var _addWhereClause = function(url, where, params) {
	params = params || {};
	var allParamsSet = true;
	where = where.value;
	var res = where.replace(/\{(\w*?)\}/g, function(m, p1) {
		var value = params[p1];
		if (value == null) {
			allParamsSet = false;
		}
		return value != null ? value : "";
	});
	if (allParamsSet) {
		url = url + "&where=" + res;
	}
	return url;
};

exports.parseSDataURL = _parseSDataURL;
exports.getLinkInfo = _getLinkInfo;
exports.getLinkAttrs = _getLinkAttrs;
exports.scanDiagnoses = _scanDiagnoses;
exports.addWhereClause = _addWhereClause;
});

define('syracuse-tablet/html/js/sdata/sdataHttp',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/ajax/ajax','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("sDataHttp");
var ajax = require('syracuse-tablet/html/js/ajax/ajax').getAjax().ajax;
var locale = require('syracuse-tablet/html/js/helpers/locale');

// We force no parsing
var _forceOptions = {
	noJsonParsing: true
};
/* 
 * params : {method, url, send, headers, options, login}
 * optional : send, headers, options, login = {user,password}
 * Return a promise
 * Resolve with result {status, isSuccess, responseText, jsonData, textStatus, descrHttpStatus, headers}
 * Never rejects
 * status = 600 if Java Script exception
 */

var _send = function(params) {
	var deferred = $.Deferred();
	var params = params || {};

	params.options = $.extend(params.options || {}, _forceOptions);
	params.headers = params.headers || {};
	params.headers["Accept-Language"] = locale.getCurrentLocale();

	try {
		log && log("_httpSend - Begin - Method:" + params.method + "\n\t" + params.url);

		ajax(params.method, params.url, params.send, params.headers, params.options)
			.then(function(result) {
				log && log("_httpSend - End - status=" + result.status + " - " + result.textStatus);
				// Try to parse data even if fail status - we can have a $diagnose in response
				if (!result.responseJSON) {
					var responseText = result.responseText ? result.responseText.trim() : "";
					if (responseText.length > 0 && ['{', '['].indexOf(responseText.charAt(0)) >= 0) {
						result.responseJSON = JSON.parse(responseText);
					} else {
						result.responseJSON = null;
					}
				}
				deferred.resolve(result);
			}).fail(function(e) {
				deferred.reject(e);
			});
	} catch (e) {
		deferred.reject(e);
	}
	return deferred.promise();
};

exports.send = _send;
});

define('syracuse-tablet/html/js/sdata/sdataCommonResources',['require','exports','module','syracuse-tablet/html/js/sdata/sdataUtils','syracuse-tablet/html/js/sdata/sdataHttp','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {

var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var sdataHttp = require('syracuse-tablet/html/js/sdata/sdataHttp');
var utils = require('syracuse-tablet/html/js/helpers/utils');

/*
 * This file should be the only file containing direct, non generic access to server side supporting entities/services
 */
var _appListUrl = "/sdata/syracuse/collaboration/syracuse/mobileApplications/$service/availableApplications";
var _localePreferencesUrl = "/sdata/syracuse/collaboration/syracuse/localePreferences?representation=localePreference.$bulk";
var _userProfileUrl = "/sdata/syracuse/collaboration/syracuse/userProfiles/$service/current";
var _endpointListUrl = "/sdata/syracuse/collaboration/syracuse/endPoints?representation=endPoint.$bulk";
var _roleListUrl = "/sdata/syracuse/collaboration/syracuse/roles?representation=role.$bulk";

function _generateReject(title, result, url) {
	if (result && result.responseJSON && result.responseJSON.$diagnoses) {
		return $.smReject({
			$title: title,
			$diagnoses: result.responseJSON.$diagnoses
		});
	}
	return $.smReject({
		$title: title
	});
}

exports.queryAllApplications = function() {
	var params = {
		method: "GET",
		url: _appListUrl
	};
	params.parsedUrl = sdataUtils.parseSDataURL(params.url);
	return sdataHttp.send(params)
		.then(function(result) {
			if (result.isSuccess && result.responseJSON) {
				var apps = result.responseJSON.$resources;
				return apps;
			}
			return _generateReject("Loading application list error", result, params.url);
		});
};

exports.queryApplicationDetail = function(appHeader) {
	var params = {
		method: "GET",
		url: appHeader.$metaDataUrl
	};
	params.parsedUrl = sdataUtils.parseSDataURL(params.url);
	return sdataHttp.send(params)
		.then(function(result) {
			if (result.isSuccess && result.responseJSON) {
				var app = result.responseJSON;
				return app;
			}
			return _generateReject("Error loading application details for '" + appHeader.applicationName + "'", result, params.url);
		});
};

exports.getUserProfile = function() {
	var params = {
		method: "GET",
		url: _userProfileUrl
	};
	params.parsedUrl = sdataUtils.parseSDataURL(params.url);
	return sdataHttp.send(params)
		.then(function(result) {
			if (result.isSuccess && result.responseJSON) {
				var profile = result.responseJSON;
				return profile;
			}
			return _generateReject("Loading user profile error", result, params.url);
		});
};

exports.queryLocalePreferences = function() {
	return _fetchAll(_localePreferencesUrl)
		.then(function(result) {
			var locales = [];
			result.forEach(function(locale) {
				locales.push({
					"$uuid": locale.$uuid,
					"code": locale.code,
					"description": locale.description
				});
			});
			return locales;
		});
};

exports.queryEndpoints = function() {
	return _fetchAll(_endpointListUrl);
};

exports.queryRoles = function() {
	return _fetchAll(_roleListUrl);
};

exports.updateUserProfile = function(changes) {

	function createWC() {
		return $.smResolve().then(function() {
			var trackingId = utils.UUID();
			var params = {
				method: "POST",
				url: "/sdata/syracuse/collaboration/syracuse/userProfiles/$template/$workingCopies?representation=userProfile.$edit&role=&trackingId=" + trackingId
			};
			params.parsedUrl = sdataUtils.parseSDataURL(params.url);
			return sdataHttp.send(params)
				.then(function(result) {
					if (result.isSuccess && result.responseJSON) {
						return $.smResolve(result.responseJSON);
					} else {
						return $.smReject();
					}
				});
		});
	}

	function updateWC(up) {
		return $.smResolve().then(function() {
			var upData = $.extend({}, up, changes);
			var params = {
				method: "PUT",
				url: up.$url,
				send: upData
			};
			params.parsedUrl = sdataUtils.parseSDataURL(params.url);
			return sdataHttp.send(params)
				.then(function(result) {
					if (result.isSuccess && result.responseJSON) {
						return $.smResolve(result.responseJSON);
					} else {
						return $.smReject();
					}
				});
		});
	}

	function deleteWC(up) {
		return $.smResolve().then(function() {
			var params = {
				method: "DELETE",
				url: up.$url
			};
			params.parsedUrl = sdataUtils.parseSDataURL(params.url);
			return sdataHttp.send(params)
				.then(function(result) {
					return $.smResolve();
				});
		});
	}

	return createWC()
		.then(function(up) {
			return updateWC(up);
		})
		.then(function(up) {
			return deleteWC(up).always(function() {
				return $.smResolve();
			});
		});
};

function _fetchAll(urlQuery) {
	var deferred = $.Deferred();
	var list = [];

	function _fetchPage(url) {
		var params = {
			method: "GET",
			url: url
		};

		params.parsedUrl = sdataUtils.parseSDataURL(params.url);
		sdataHttp.send(params)
			.then(function(result) {
				var data = result && result.responseJSON;
				data && data.$resources && data.$resources.forEach(function(i) {
					list.push(i);
				});
				if (data && data.$links && data.$links.$next && data.$links.$next.$url) {
					_fetchPage(data.$links.$next.$url);
				} else {
					deferred.resolve(list);
				}
			});
	}

	_fetchPage(urlQuery);
	return deferred.promise();
}
});

define('syracuse-tablet/html/js/helpers/base64',['require','exports','module'],function (require, exports, module) {

/**
 *
 *  Base64 encode / decode
 *  http://www.webtoolkit.info/
 *
 **/

var Base64 = exports.Base64 = {

	// private property
	_keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

	// public method for encoding
	encode: function(input) {
		var output = "";
		var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
		var i = 0;

		input = Base64._utf8_encode(input);

		while (i < input.length) {

			chr1 = input.charCodeAt(i++);
			chr2 = input.charCodeAt(i++);
			chr3 = input.charCodeAt(i++);

			enc1 = chr1 >> 2;
			enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
			enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
			enc4 = chr3 & 63;

			if (isNaN(chr2)) {
				enc3 = enc4 = 64;
			} else if (isNaN(chr3)) {
				enc4 = 64;
			}

			output = output + this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) + this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);

		}

		return output;
	},

	// public method for decoding
	decode: function(input) {
		var output = "";
		var chr1, chr2, chr3;
		var enc1, enc2, enc3, enc4;
		var i = 0;

		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

		while (i < input.length) {

			enc1 = this._keyStr.indexOf(input.charAt(i++));
			enc2 = this._keyStr.indexOf(input.charAt(i++));
			enc3 = this._keyStr.indexOf(input.charAt(i++));
			enc4 = this._keyStr.indexOf(input.charAt(i++));

			chr1 = (enc1 << 2) | (enc2 >> 4);
			chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
			chr3 = ((enc3 & 3) << 6) | enc4;

			output = output + String.fromCharCode(chr1);

			if (enc3 != 64) {
				output = output + String.fromCharCode(chr2);
			}
			if (enc4 != 64) {
				output = output + String.fromCharCode(chr3);
			}

		}

		output = Base64._utf8_decode(output);

		return output;

	},

	// private method for UTF-8 encoding
	_utf8_encode: function(string) {
		string = string.replace(/\r\n/g, "\n");
		var utftext = "";

		for (var n = 0; n < string.length; n++) {

			var c = string.charCodeAt(n);

			if (c < 128) {
				utftext += String.fromCharCode(c);
			} else if ((c > 127) && (c < 2048)) {
				utftext += String.fromCharCode((c >> 6) | 192);
				utftext += String.fromCharCode((c & 63) | 128);
			} else {
				utftext += String.fromCharCode((c >> 12) | 224);
				utftext += String.fromCharCode(((c >> 6) & 63) | 128);
				utftext += String.fromCharCode((c & 63) | 128);
			}

		}

		return utftext;
	},

	// private method for UTF-8 decoding
	_utf8_decode: function(utftext) {
		var string = "";
		var i = 0;
		var c1, c2, c3;
		var c = c1 = c2 = 0;

		while (i < utftext.length) {

			c = utftext.charCodeAt(i);

			if (c < 128) {
				string += String.fromCharCode(c);
				i++;
			} else if ((c > 191) && (c < 224)) {
				c2 = utftext.charCodeAt(i + 1);
				string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
				i += 2;
			} else {
				c2 = utftext.charCodeAt(i + 1);
				c3 = utftext.charCodeAt(i + 2);
				string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
				i += 3;
			}

		}

		return string;
	},

	// public method for decoding
	raw_decode: function(input) {
		var output = "";
		var chr1, chr2, chr3;
		var enc1, enc2, enc3, enc4;
		var i = 0;

		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

		while (i < input.length) {

			enc1 = this._keyStr.indexOf(input.charAt(i++));
			enc2 = this._keyStr.indexOf(input.charAt(i++));
			enc3 = this._keyStr.indexOf(input.charAt(i++));
			enc4 = this._keyStr.indexOf(input.charAt(i++));

			chr1 = (enc1 << 2) | (enc2 >> 4);
			chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
			chr3 = ((enc3 & 3) << 6) | enc4;

			output = output + String.fromCharCode(chr1);

			if (enc3 != 64) {
				output = output + String.fromCharCode(chr2);
			}
			if (enc4 != 64) {
				output = output + String.fromCharCode(chr3);
			}

		}

		//		output = Base64._utf8_decode(output);

		return output;

	}
};

exports.encode = function(text) {
	return Base64.encode(text);
};
});

define('syracuse-tablet/html/js/application/authentication',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ajax/ajax','syracuse-tablet/html/js/sdata/sdataCommonResources','syracuse-tablet/html/js/helpers/base64'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("app");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var ajax = require('syracuse-tablet/html/js/ajax/ajax').getAjax().ajax;
var sdataCommonRes = require('syracuse-tablet/html/js/sdata/sdataCommonResources');
var base64 = require('syracuse-tablet/html/js/helpers/base64');

/**
 * Login services are temporarily implemented in requireJSDispatcher._js
 * - tabletCheckLogin
 * 		Return 403 if login failed because 401 forces the browser to display the authentication dialog
 * - tabletDoLogin
 *      Return user's profile if OK
 */
var _config = {
	svcLogin: "/auth/login/submit",
	svcLogout: "/logout",
	userProfile: "/sdata/syracuse/collaboration/syracuse/userProfiles/$service/current"
};

/**
 * True if user is logged in
 */
var _check = function() {
	var deferred = new $.Deferred();
	var _rejectError = function(e, t) {
		log && log(t || "Check login request rejected", e);
		deferred.reject(e);
	};
	try {
		return ajax("GET", _config.userProfile, null, null, {
			dontCatchHttp401: true
		}).then(function(result) {
			if (result.status === 200) {
				deferred.resolve({
					authenticated: true
				});
			} else {
				deferred.resolve(false);
			}
		}).fail(function(e) {
			_rejectError(e);
		});
	} catch (e) {
		_rejectError(e, "Check login request exception");
	} finally {
		return deferred.promise();
	}
};
/**
 * Resolve with success and user's profile
 */
var _login = function(user, password, lang) {
	var deferred = new $.Deferred();
	var _rejectError = function(e, t) {
		log && log(t || "Login request rejected", e);
		deferred.reject(e);
	};
	try {
		var token = 'Basic ' + base64.encode(user + ":" + password);
		return ajax("POST", _config.svcLogin, null, {
			"Authorization": token,
			"accept": "application/json"
		}).then(function(result) {
			if (result.status !== 200 && result.status !== 401 && result.status !== 0) {
				deferred.resolve(false, null, "Httpstatus: " + result.status + (result.descrHttpStatus ? "[" + result.descrHttpStatus + "]" : ""));
			} else if (result.status === 0) {
				deferred.resolve(false, null, "Offline", true);
			} else {
				try {
					var url = result.responseJSON.$diagnoses[0].$links.$redirect.$url;
					if (url === "/auth/login/page") {
						deferred.resolve(false, null, "Httpstatus: " + result.status + (result.descrHttpStatus ? "[" + result.descrHttpStatus + "]" : ""));
					} else {
						sdataCommonRes.getUserProfile().then(function(profile) {
							deferred.resolve(true, profile, "Httpstatus: " + result.status + (result.descrHttpStatus ? "[" + result.descrHttpStatus + "]" : ""));
						}).fail(function(e) {
							_rejectError(e);
						});
					}
				} catch (e) {
					_rejectError(e);
				}
			}
		}).fail(function(e) {
			_rejectError(e);
		});
	} catch (e) {
		_rejectError(e, "Do login request exception");
	} finally {
		return deferred.promise();
	}
};

/**
 * Logout
 */
var _logout = function() {
	var deferred = new $.Deferred();
	var _rejectError = function(e, t) {
		log && log(t || "Logout request rejected", e);
		deferred.reject(e);
	};
	try {
		var url = globals.baseLocation().host + _config.svcLogout;
		// temporarily - To improve
		return ajax("GET", url, {
			device: "phone"
		}).then(function(result) {
			var data;
			var msg = "";
			if (!result.isSuccess) {
				msg = "Httpstatus: " + result.status + (result.descrHttpStatus ? "[" + result.descrHttpStatus + "]" : "");
			}
			var diag = result.responseJSON ? result.responseJSON.$diagnoses : null;
			if (diag) {
				diag.forEach(function(d) {
					msg += (msg.lengthj > 0 ? "\n" : "") + d.$message;
				});
			}
			var isSuccess = result.isSuccess;
			if (!isSuccess && result.status === 0) {
				isSuccess = true; // We are offline, so we consider logout is ok and do not display a message
			}
			deferred.resolve(isSuccess, msg);
		}).fail(function(e) {
			_rejectError(e);
		});
	} catch (e) {
		_rejectError(e, "Do logout request exception");
	} finally {
		return deferred.promise();
	}
};

/*
 * Sage ID signin
 */
var _sageidsigin = function() {
	window.location.href = "/auth/sage-id/signOnStart";
};

exports.check = _check;
exports.login = _login;
exports.logout = _logout;
exports.sageidsignin = _sageidsigin;
});

define('syracuse-tablet/html/js/application/eventListener',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("evts");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

/**
 * Returns id of parent array
 */
var _findParentCtrlId = function($$target, selector) {
	// Find a control array with an ID
	var p = $$target.closest(".s-m-control" + (selector || "") + "[id]");
	return p.length > 0 ? _attr(p, "id") : null;
};
/**
 * Returns attribute, decode and parse if it's a json
 */
var _attr = function($$e, name, nullIfEmpty, decode) {
	var a = ($$e.attr(name) || "").trim();
	if (decode === true) {
		a = decodeURIComponent(a);
		if (a.smStartsWith('{') && a.smEndsWith('}')) {
			// We allow serialized JSON objects in attributes
			try {
				var json = JSON.parse(a);
				return json;
			} catch (e) {
				log.console("Error reading JSON attribute " + name + "\n\t" + a);
			}
		}
	}
	return nullIfEmpty && a.length === 0 ? null : a;
};
/**
 * Parse code=abc&value=cde to
 * {
 * code: "abc",
 * value: "cde"
 * }
 */
var _parseParameters = function(params) {
	var p = params.split("&");
	var res = {};
	for (var i = 0; i < p.length; i++) {
		var v = p[i].split("=");
		res[v[0]] = v[1];
	}
	return res;
};
var _findControlById = function(app, ctrlId, $$target) {
	if (!app.currentPage) throw new Error("No current page");
	var ctrl = app.currentPage.getControl(ctrlId);
	if (ctrl) return ctrl;
	/**
	 * data-controller-id is generated by controller base class to allow to retreive a control
	 * Controller is not only a page and we must be able to retrieve it
	 */
	var controller = $$target.closest("[data-controller-id]");
	if (controller.length === 0) {
		controller = $("#" + ctrlId).closest("[data-controller-id]");
	}
	if (controller.length > 0) {
		var id = controller.attr("data-controller-id");
		controller = globals.getController(id);
		if (controller) {
			ctrl = controller.getStructElmt(ctrlId);
		}
	}
	if (ctrl) return ctrl;
	throw new Error("Control not found - ctrlid[" + ctrlId + "]");
};
/**
 * Calls an action given by data-action
 * params a string or a JSON object
 * if parans is a string and contains ',' separator params is split the callBack is called with as many parameters as split elements
 * $$target can be NULL
 */
var _doAction = function($$target, act, params, controlId) {
	var app = globals.getApplication();
	var fail = function(e) {
		var title = locale.text("actions.error");
		e = e || {};
		e.stack = e.stack ? e.stack + "\n---\n" : "";
		e.stack = e.stack + "Action: " + act + "\nControl: " + (controlId || "?");
		modal.error(title, e);
	};
	try {
		var method = "_act" + $.camelCase("-" + act);
		var object;
		if ($$target) {
			if (!controlId) {
				// look for the first parent array if any
				// data-action in a row should invoke the method on array control
				controlId = _findParentCtrlId($$target, ".s-m-array");
			}
			if (controlId) {
				// Find control in current page and vignettes if dashboard
				object = _findControlById(app, controlId, $$target);
			} else {
				// Find if it's an action off a vignette (contains a page)
				var vignette = utils.findParentVignette($$target, false);
				if (vignette) {
					if (vignette[method]) {
						object = vignette;
					} else {
						var p = vignette.getPage();
						if (p && p[method]) object = p;
					}
				}
			}
		}
		// Find if it's a current page action
		if (object == null && app.currentPage[method]) object = app.currentPage;
		// Find if it's a global action
		if (object == null) object = app;
		if (!object[method]) throw new Error("Method [" + method + "] not found in object/application/current page)");
		var args = [];
		if (params && typeof params === "string") {
			// Create a array of parameters ( ','  as separator
			// Remove leading/trailing spaces
			params = params.split(',');
			params.forEach(function(p, idx) {
				args.push(p.trim());
			});
		} else {
			args.push(params);
		}
		// Add $target at the end
		args.push($$target);
		$.when(object[method].apply(object, args)).then(function(todo) {
			if (todo) {
				if (todo.page) {
					globals.getApplication().changePage(todo.page);
				}
			}
		}).fail(function(e) {
			fail(e);
		});
	} catch (e) {
		fail(e);
	}
};
/** NAVIGATION 
 * clickedElmt:	jQuery element or JSON object that provides attr() method
 * app			global application
 * $$target		$$target event for click in page
 * 				Element from which we searcg for the vignette if any
 *
 */
var _doNavigation = function(clickedElmt, $$target) {
	var app = globals.getApplication();
	var options = {}, attr;
	// Page to open
	attr = _attr(clickedElmt, "data-sdata-url");
	if (attr.length > 0) {
		// !! do not call decode URI because we must keep query parameters encoded
		options["sdata-url"] = attr;
	}
	attr = _attr(clickedElmt, "data-sdata-method");
	if (attr.length > 0) {
		options["sdata-method"] = attr;
	}
	// Link type : pagination...
	attr = _attr(clickedElmt, "data-nav-type");
	if (attr.length > 0) {
		options["type"] = attr;
	}
	// Id of parent page
	attr = _attr(clickedElmt, "data-parent-id");
	if (attr.length > 0) {
		options["parentId"] = attr;
	}
	// Control that rated the link - used by refresh and action on child pages like lookup
	attr = _attr(clickedElmt, "data-control-id");
	if (attr.length > 0) {
		options["controlId"] = attr;
	}
	// Parameters are passed in page options - data navigation accepts Stringify JSON
	attr = _attr(clickedElmt, "data-params", false, true);
	// If attribute starts with { and ends with } it is parsed
	options["dataParams"] = attr || "";

	// Target - vignette -> Change/Refresh the page in the vignette - null or "application" Change/Refresh  application currentpage
	attr = _attr(clickedElmt, "data-nav-target");
	var navTarget;
	if ($$target) {
		if (attr === "vignette") {
			// data-nav-target allows to specify the target for navigation link - Ex pagination
			navTarget = utils.findParentVignette($$target, true);
		} else if (attr !== "application" && app.$config("openLinkInVignette")) {
			// Navigation in vignette - Just a  try but it works - Vignette display back/home icon in icon bar
			navTarget = utils.findParentVignette($$target, false);
		}

	}
	// default navigation is done at application level
	if (!navTarget) {
		navTarget = app;
	}

	// Page refresh instead of opening a new page
	var refreshPage = _attr(clickedElmt, "data-nav-refresh");
	if (refreshPage === "true") {
		// options.controlId points Control to refresh if any
		navTarget.refreshPage(options);
		return;
	}
	attr = _attr(clickedElmt, "data-application-name");
	var applicatioName;
	if (attr.length > 0) {
		applicatioName = attr;
	}

	var pageName;
	attr = _attr(clickedElmt, "data-nav");
	if (attr.length > 0) {
		pageName = attr;
	}

	// Only application name is given, so switch application, which will navigate to home page of that application
	if (applicatioName && !pageName) {
		notifications.publish("sm.switch.app", applicatioName);
		return;
	}

	if (applicatioName) {
		options["applicationName"] = applicatioName;
	}

	// Gadget - Page opener
	attr = _attr(clickedElmt, "data-gadget-id");
	if (attr.length > 0) {
		options["gadget-id"] = attr;
	}

	// Used to put a $article in a $link vignette - test entities
	attr = _attr(clickedElmt, "data-link-article");
	if (attr.length > 0) {
		options["linkArticle"] = attr;
	}
	// Used to filter gadgets in dashboard pages
	attr = _attr(clickedElmt, "data-sdata-parameters");
	if (attr && attr.length > 0) {
		options["sdataParameters"] = _parseParameters(attr);
	}

	// history.back not allowed - TODO See how to pass options	JSON in params ?	
	attr = _attr(clickedElmt, "data-nav-noback");
	options["noHistoryBack"] = attr === "true";

	navTarget.changePage(pageName, options);
};

/** 
 * Bind actions declared by data-nav or data-action/data-params attributes to an object
 *      for navigation data-nav  contains the name of the targeted page
 * 		for action method name is : _actActionName with ActionName the name of action declared in data-action attribute
 * object	: object that processes the actions
 * 				Check current page and application if method not found in object
 * 				if data-control-id attribute call control's action on current page
 * $$elmt 	: optional if object.$$elmt - element to bind event
 * selector : optional
 * 		Default selector is "[data-nav], [data-action]"
 *
 * !!! FDB - About stopPropagations !!!
 * Like data-action can be used inside a bootstrap componant (ex dropdown) we need to propagate the event (no stopPropagations)
 * For dropdown it allows BS to close the opup window
 * I removed the stopPropagation in _bindActions
 * If we need to add it we will have to add a param in html that tells _bindActions to stop or not event propagation
 *
 */
var _handleActionEvt = function(evt, app) {
	var fail = function(e) {
		var title = "_bindActions error";
		log && log(title, e);
		modal.error(title, e);
	};
	try {
		if (app.hasModalOpen()) {
			// If we have a modal in front of a page with a default button and if we press enter to close the dialog we trigger default action of the page
			// This test block the action - TODO improve
			log && log("!!! Tries to execute an action data-action with a MODAL open.\nAction is skipped");
			return;
		}
		var $$target = $(evt.target);
		var $$actionElmt = $$target.closest("[data-nav], [data-nav-refresh]");
		if ($$actionElmt.length > 0) {
			if ($$actionElmt.attr("data-disabled") != null) return;
			_doNavigation($$actionElmt, $$target);
			// #5359 - We need to stop propagation if other evt as been triggered
			// Ex: click on an item of right panel - There a click listenr on the panel to close it - if no stopPropagation click on panel is triggered 
			evt.stopPropagation();
			return;
		}
		$$actionElmt = $$target.closest("[data-action]");
		if ($$actionElmt.length > 0) {
			// used to disable a link or action in order to allow the propagation of events (multiselection)
			if ($$actionElmt.attr("data-disabled") != null) return;
			/** ACTION **/
			var param;
			var act = _attr($$actionElmt, "data-action");
			if ($$actionElmt.is("select")) {
				param = $(this).val();
			} else {
				// Actions on arrays rows
				if (act === globals.ACTROWDETAIL || act === globals.ACTROWDEL || act === globals.ACTROWSEL || act === globals.ACTCARDDESIGN) {
					// We search the record of a the line that contains the row id indata-params attribute
					// We just have one elmt tha stores the rowId
					$$actionElmt = $$actionElmt.closest("." + globals.RECORDCLASS);
				}
				// data action parameters
				// if attr starts with { and ends with } it is parsed
				// if there's a ',' separator parameters are splited and become action arguments
				param = _attr($$actionElmt, "data-params", false, true);
			}
			var controlId = _attr($$actionElmt, "data-control-id", true);
			_doAction($$target, act, param, controlId);
			return;
		}
	} catch (e) {
		fail(e);
	}
};
var _bindActions = function(app) {
	// Action are bound to application $$elmt and dispatcched to current page or control
	if (!app.$$elmt) throw new Error("_bindActions - null $$elmt");
	var handler = jsutils.bindFn(_handleActionEvt, null, app);
	// No click event on select - only change
	app.$$elmt.on("click", ":not(select)[data-nav], :not(select)[data-nav-refresh], :not(select)[data-action]", handler);
	// For select tag
	app.$$elmt.on("change", "select[data-nav], select[data-nav-refresh], select[data-action]", handler);
};

/**
 * Add event handlers for controls
 * 		put a ctrl-evt- + evtName in the class attribute of the dom element you want to enable
 * 		handler will call ctrl.onEventName (onClick, onBlur...)
 */
var _bindControlEvents = function(app) {
	var fail = function(e) {
		var title = "_bindControlEvents error";
		log && log(title, e);
		modal.error(title, e);
	};
	var events = ["click", "blur", "change"];
	// Use forEach instead of for(var i =...) to preserve evtname closure context otherwise evtname has always the last value
	events.forEach(function(evtname) {
		app.$$elmt.on(evtname, ".ctrl-evt-" + evtname, function(event) {
			//TODO - ee if we could remove stopPropagation like in _bindAtion
			event.preventDefault();
			event.stopPropagation();
			try {
				var $$target = $(event.target);
				var ctrlId;
				if ($$target.hasClass("s-m-control")) {
					ctrlId = _attr($$target, "id");
				} else {
					// We can force control-id if it's not a parent of $$target
					ctrlId = _attr($$target, "data-control-id", true);
					if (!ctrlId) {
						// We search for the first control parent with an ID
						// Controls in arrays don't have an id - So click on a card/row will return the array control
						ctrlId = _findParentCtrlId($$target);
					}
				}
				var ctrl = _findControlById(app, ctrlId, $$target);
				var method = "on" + evtname.smCapitalize();
				var controllerListener = ctrl.controller ? ctrl.controller.getEventListener(evtname) : null;
				if (controllerListener && controllerListener("before", ctrl, $$target, event) === true) {
					// Skip control
					return;
				}
				if (!ctrl[method]) {
					log && log("!!! Method[" + method + "] not found - ctrlid[" + ctrlId + "]");
					return;
				}
				ctrl[method](event);
				controllerListener && controllerListener("after", ctrl, $$target, event);
			} catch (e) {
				fail(e);
			}
			return;
		});
	});
};

/**
 * Application event listener
 */
var _bindEvents = function(app) {

	$(window).bind("popstate", function(event) {
		var state = event.originalEvent.state;
		// We've to check state to not call historyPop on click on href="#"
		// On Firefox we do'nt receive 2 popstate
		if (state || /Firefox/.test(navigator.userAgent)) {
			app.historyPop(event);
		}
	});
	// Bind action/navigation call to click/select/change 
	_bindActions(app);
	// Bind control events
	_bindControlEvents(app);
	// triggered by browser window size or orientation change
	$(window).on("resize", globals.getSiteLayout().onWindowResize);
	// triggered by application JS code
	$(window).on("resizeInternal", globals.getSiteLayout().onWindowResizeInteral);
	// Page reload
	$(window).on("unload", app.onUnload.bind(app));
};
/**
 * Trigger an action
 * 		$$elmt: JQL element - $$elmt of a control or page by example
 * 				if null trigger elemt at current page level (controlId is ignored)
 */
var _triggerAction = function($$elmt, act, params, controlId) {
	window.setTimeout(function() {
		_doAction($$elmt, act, params, controlId);
	});
};
/**
 * Triggers a navigation (open link) according to attributes params
 * $$elmt			JQ element to search for parent vignette  if any
 * attributes		SAme attributes as $$element
 */
var _triggerNavigation = function($$elmt, attributes) {
	// Simulate a Jquery object that provides attr() method
	var attrs = function(jsonAttrs) {
		var _jsonAttrs = jsonAttrs;
		Object.keys(_jsonAttrs).forEach(function(key) {
			if ($.isPlainObject(_jsonAttrs[key])) {
				_jsonAttrs[key] = JSON.stringify(_jsonAttrs[key]);
			}
		});
		this.attr = function(name) {
			return _jsonAttrs[name];
		};
	};
	_doNavigation(new attrs(attributes), $$elmt);
};
/*
 * Trigger refresh - used by filterSort
 */
var _triggerRefreshPage = function($$elmt, attributes) {
	attributes = attributes || {};
	attributes["data-nav-refresh"] = "true";
	_triggerNavigation($$elmt, attributes);
};
exports.bindEvents = _bindEvents;
exports.triggerAction = _triggerAction;
exports.triggerNavigation = _triggerNavigation;
exports.triggerRefreshPage = _triggerRefreshPage;
});

define('syracuse-tablet/html/js/application/pageLoader',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("pageLoader");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var locale = require('syracuse-tablet/html/js/helpers/locale');

/**
 * Load a page in a container
 * 	container must provide the following interface
 * 	Use by application and vignette - code factorization
 * 	callerInterface - see CALLER INTERFACE below
 */
var _PageLoader = utils.defineClass(
	function PageLoader(callerInterface) {
		this.callerInterface = callerInterface;
		this.factory = globals.getApplication().factory;
	}, null, {

		destroy: function() {
			this.callerInterface = null;
			this.factory = null;
		},
		/**
		 * loadOptions
		 * 		dontDisplayLoadErr = true to not display a modal
		 */
		load: function(state, back, loadOptions) {
			var deferred = $.Deferred();
			loadOptions = loadOptions || {};
			var self = this;
			var _fail = function(e) {
				self.loading = false;
				self.waitStop();
				if (self.callerInterface.loadingError) {
					self.callerInterface.loadingError(deferred, state, e);
				} else if (loadOptions.dontDisplayLoadErr !== true) {
					modal.error(locale.text("error.page.loading"), e, function() {
						deferred.reject(e);
					});
				} else {
					deferred.reject(e);
				}
			};
			var timeLine = utils.getTimeLine("pageLoader", state.name);
			timeLine && timeLine.start();
			var _success = function(pageToOpen, pageToClose, parentNotifInfo) {
				self.loading = false;
				self.waitStop();
				if (pageToOpen) {
					if (back !== true && (state.options == null || state.options.noHistoryBack !== true)) {
						// Store page in history - noHistoryBack option is used by example for pagination actions
						if (pageToOpen.prototype) {
							pageToOpen.state.$title = pageToOpen.prototype.data("$title");
						}
						self.historyPush(pageToOpen.state);
					}
					self.succeeded(pageToOpen, pageToClose, parentNotifInfo, back, loadOptions);
					timeLine && timeLine.stop(pageToOpen.isNew ? "newPage" : "existingPage");
				}
				deferred.resolve(pageToOpen);
			};
			try {
				if (self.loading) {
					_success(null);
				}
				self.loading = true;
				if (state === null || typeof state != "object") throw new Error("Bad state object");
				log && log("_gotoPage", "start", "page: " + state.uuid);
				var pageToClose = self.getCurrentPage();
				if (pageToClose && pageToClose.getProp("uuid") === state.uuid) {
					log && log("\tPage is current -> Skip");
					return;
				}
				var parentNotifInfo = null;
				var childNotifInfo = null;
				if (pageToClose && pageToClose.isChild) {
					/**
					 * If the current page is a child and wants to notify the parent (ex lookup...) it should provide at least
					 * a JSONobject that contains a notifyId with the id of notification
					 * We need to store this data before the page it's destroyed
					 * Information is passed to parent in succeeded interface method (at the end of the process)
					 */
					parentNotifInfo = pageToClose.getParentNotif();
				}
				self.waitStart();
				var pageToOpen = $("#" + state.uuid).smPageController();
				// Page found -> Direct access -> Activate and remove childs
				if (pageToOpen != null) {
					log && log("\tPage found in dom -> Activate");
					if (!pageToOpen) throw new Error("Unexpected null page data");
					// Page retrieve from cache
					pageToOpen.isNew = false;
					self._pageActivate(pageToOpen, function() {
						timeLine && timeLine.step("activated");
						// After activation to keep current page for transition
						// No siblings expected
						pageToOpen.destroySiblings();
						_success(pageToOpen, pageToClose, parentNotifInfo);
					}, back);
					return deferred.promise();
				}
				// Page not found -> Create and display
				var savedContext = null;
				var parentPage = null;
				if (state.options && state.options.parentId) {
					// For cild page like state.type === "carddesign" || state.type === "rowdetail"
					parentPage = globals.getController(state.options.parentId);
				}
				var $forceLinkArticle;
				if (pageToClose) {
					// linkArticle contains the id of the vignette that contains the page article
					// Used in test entities to attach a $article to a $link vignette
					// -> convenient for unit test
					$forceLinkArticle = pageToClose.getLinkedPageArticle(back, back || !state.options ? null : state.options["linkArticle"]);
				}
				self.factory.createPage(self.getRootElmt(), state, parentPage, $forceLinkArticle)
					.then(function(p) {
						timeLine && timeLine.step("created");
						pageToOpen = p;
						// Page created
						pageToOpen.isNew = true;
						return pageToOpen.load(loadOptions);
					})
					.then(function() {
						timeLine && timeLine.step("loaded");
						if (pageToOpen.isNew) {
							// We restore the context only if pageToOpen has been destroyed and re-created
							if (!back && pageToOpen.isVignette && pageToClose == null) {
								// Restore the context of a page nested in a vignette after it has been loaded (only - pageToClose == null)
								// Ex: 	when we open a detail form a vignette we need to store the status (scroll, selection...) of the vignette to restore it on back
								savedContext = self.savedCtxVignette();
							} else if (back) {
								// Back in full page or vignette page - we restore context
								savedContext = pageToClose ? pageToClose.savedContext : null;
							}
						}
						self._pageActivate(pageToOpen, function() {
							timeLine && timeLine.step("activated");
							_success(pageToOpen, pageToClose, parentNotifInfo);
						}, back, savedContext);
					}).fail(function(e) {
						_fail(e);
					});
			} catch (e) {
				_fail(e);
			}
			return deferred.promise();
		},

		_pageActivate: function(pageToOpen, cb, back, savedContext) {
			var self = this;
			var pageToClose = self.getCurrentPage();
			// Destroy=true if the pageToClose has to be destroyed
			// We destroy the page if back or if pageToClose is not cached or if pageToOpen is a not child
			var destroy = pageToClose && (back === true || (pageToClose.getProp("cached") !== true && pageToOpen.isChild !== true));
			if (destroy && back !== true) {
				// Save context - Like pages is destroyed we need to save a context in current page to retrieve if on back navigation
				// Context object containt the context f current page and context of parent page for chaining
				pageToOpen.contextSave(pageToClose);
			}
			pageToOpen.activate(pageToClose, savedContext, function() {
				self.setCurrentPage(pageToClose, pageToOpen, destroy);
				if (cb) cb();
			});
		},

		/**
		 * CALLER INTERFACE BEGIN
		 */

		/* Methods MUST be implemented */
		historyPush: function(state) {
			this.callerInterface.historyPush(state);
		},

		waitStop: function() {
			this.callerInterface.waitStop();
		},

		waitStart: function() {
			this.callerInterface.waitStart();
		},

		getRootElmt: function() {
			return this.callerInterface.getRootElmt();
		},

		getCurrentPage: function() {
			return this.callerInterface.getCurrentPage();
		},
		savedCtxVignette: function() {
			var meth = this.callerInterface.savedCtxVignette;
			return meth ? meth() : null;
		},
		setCurrentPage: function(pageToClose, pageToOpen, destroy) {
			var self = this;
			if (pageToClose) {
				if (destroy === true) {
					// To postpone destroy and let asynchronous processes stop (prevent bugs when we work on local data)
					setTimeout(function() {
						pageToClose.destroy();
					});
				} else {
					// Keep cached page only if not back - Ex: List -> Detail
					pageToClose.deactivate();
				}
			}
			self.callerInterface.setCurrentPage(pageToOpen);
		},

		succeeded: function(pageToOpen, pageToClose, parentNotifInfo, back, loadOptions) {
			var self = this;
			notifications.publish("sm.page.loaded", self.getCurrentPage());
			if (this.callerInterface.succeeded) {
				this.callerInterface.succeeded(pageToOpen, pageToClose, parentNotifInfo, back, loadOptions);
			}
		}
		/**
		 * CALLER INTERFACE END
		 */
	});

exports.Klass = _PageLoader;
});

define('syracuse-tablet/html/js/ui/modals/modalSelectContext',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				{{#unless label_offline}} \
				<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
				{{/unless}} \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
			<div class="s-m-scroll-element"> \
				{{#if showEndpoints}} \
				<div class="form-group"> \
					<label>{{label_endpoints}}</label>\
					<select class="form-control" id="login-select-endpoint"> \
					{{#each endpoints}}\
						<option value="{{this.application}}.{{this.contract}}.{{this.dataset}}" {{#if this.selected}}selected{{/if}}>\
						{{this.description}}\
						</option>\
					{{/each}}\
					</select>\
				</div> \
				{{/if}} \
				{{#if showRoles}} \
				<div class="form-group"> \
					<label>{{label_roles}}</label>\
					<select class="form-control" id="login-select-role"> \
					{{#each roles}}\
						<option value="{{this.code}}" {{#if this.selected}}selected{{/if}}>\
						{{this.description}}\
						</option>\
					{{/each}}\
					</select>\
				</div> \
				{{/if}} \
				{{#if showLanguages}} \
				<div class="form-group"> \
					<label>{{label_languages}}</label>\
					<select class="form-control" id="login-select-language"> \
					{{#each languages}}\
						<option value="{{this.code}}" {{#if this.selected}}selected{{/if}}>\
						{{this.description}}\
						</option>\
					{{/each}}\
					</select>\
				</div> \
				{{/if}} \
				{{#if label_warning}}\
				<div class="alert alert-warning" role="alert">\
					{{label_warning}}\
				</div>\
				{{/if}}\
				{{#if label_offline}}\
					<div class="alert alert-warning" role="alert">\
						{{label_offline}}\
					</div>\
				{{/if}}\
			</div> \
			</div>',
	footer: '<button type="button" class="btn btn-default" data-action="logout">{{label_logout}}</button>'
};

var _Klass = utils.defineClass(
	function ModalSelectContext(context, endpoints, roles, languages, warn) {
		var self = this;
		modalDialog.ModalBase.call(self);

		// Init params
		self.initParam = {
			context: context,
			endpoints: endpoints,
			roles: roles,
			languages: languages,
			warn: warn
		};

		// Result
		self.result = null;
	}, modalDialog.ModalBase, {
		destroy: function() {
			modalDialog.ModalBase.prototype.destroy.call(this);
			this.initParam = null;
			this.result = null;
		},

		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "config-tile half_right";
			} else {
				displayFlags.modalClass = "config-tile full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			var showEndpoints = self.initParam.endpoints.length > 0;
			var showRoles = self.initParam.roles.length > 0;
			var showLanguages = self.initParam.languages.length > 0;

			var label_warning = self.initParam.warn && locale.text("modal.context.warning");
			var label_offline = locale.text("modal.context.offline");
			if (showEndpoints + showLanguages + showRoles > 0) {
				label_offline = null;
			} else {
				label_warning = null;
			}
			var data = {
				title: locale.text("modal.context.title"),
				label_endpoints: locale.text("modal.context.endpoints"),
				showEndpoints: showEndpoints,
				endpoints: self.initParam.endpoints,
				label_roles: locale.text("modal.context.roles"),
				showRoles: showRoles,
				roles: self.initParam.roles,
				label_languages: locale.text("modal.context.languages"),
				showLanguages: showLanguages,
				languages: self.initParam.languages,
				label_logout: locale.text("modal.context.logout"),
				label_ok: locale.text("modal.context.ok"),
				label_cancel: locale.text("modal.context.cancel"),
				label_warning: label_warning,
				label_offline: label_offline
			};
			if (self.initParam.context) {
				self.initParam.endpoints.forEach(function(ep) {
					if (ep.application + "." + ep.contract + "." + ep.dataset === self.initParam.context.endpoint) {
						ep.selected = true;
					} else {
						ep.selected = false;
					}
				});
				self.initParam.roles.forEach(function(role) {
					if (role.code === self.initParam.context.role) {
						role.selected = true;
					} else {
						role.selected = false;
					}
				});
				self.initParam.languages.forEach(function(lang) {
					if (lang.code === self.initParam.context.language) {
						lang.selected = true;
					} else {
						lang.selected = false;
					}
				});
			}

			return data;
		},

		_onAction: function(action, param) {
			var self = this;
			if (action === "logout") {
				self.result = {
					"action": "logout"
				};
				return true;
			}
			return false;
		},

		_onValidate: function() {
			var self = this;

			var endpoint = self.$$elmt.find("#login-select-endpoint").val();
			var role = self.$$elmt.find("#login-select-role").val();
			var language = self.$$elmt.find("#login-select-language").val();

			self.result = {
				"action": "ok",
				"endpoint": endpoint,
				"role": role,
				"language": language
			};
		},

		_onCancel: function() {
			var self = this;
			self.result = {
				"action": "cancel"
			};
		},

		_getResult: function() {
			var self = this;
			return self.result;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/storage/localStorage',['require','exports','module','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {

/**
 * Local storage
 * Uses only window local storage
 */

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("sessstorage");

var _available = null;

var _isAvailable = function() {
	if (_available !== null) {
		return _available;
	}
	_available = false;
	try {
		window.localStorage.setItem("__test_availability__", "__test_availability__");
		_available = true;
	} catch (e) {}
	return _available;
};

var _getItem = function(key, removeAfter) {
	if (!_isAvailable()) {
		log && log("local.unsupported.getItem(" + key + "):" + val);
		return;
	}
	var val = window.localStorage.getItem(key);
	log && log("local.getItem(" + key + "):" + val);
	if (true === removeAfter) {
		_removeItem(key);
	}
	return val;
};

var _setItem = function(key, value) {
	if (!_isAvailable()) {
		log && log("local.unsupported.setItem(" + key + "):" + value);
		return;
	}
	log && log("local.setItem(" + key + "):" + value);
	return window.localStorage.setItem(key, value);
};

var _removeItem = function(key) {
	if (!_isAvailable()) {
		log && log("local.unspported.removeItem(" + key + ")");
		return;
	}
	log && log("local.removeItem(" + key + ")");
	return window.localStorage.removeItem(key);
};

exports.removeItem = _removeItem;
exports.setItem = _setItem;
exports.getItem = _getItem;
});

define('syracuse-tablet/html/js/storage/storageInterface',['require','exports','module','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {

/*
 * Default interface for mobile application metadata, favorites, drafts and templates, ...
 */


var utils = require('syracuse-tablet/html/js/helpers/utils');

var _statusCodes = {
	OK: 1,
	NOT_FOUND: 2,
	ERROR: 3
};


function _StorageInterface() {
	this.infoString = "Interface only";
};

/*
 * All storage interfaces must inherit the "Not implemented" methods of this super class
 */
var storageInterfaceClass = utils.defineClass(
	_StorageInterface,
	null, {
		getInfo: function() {
			return this.infoString;
		},

		/**
		 * Init storage
		 *
		 * Return:
		 * Resolve:
		 * {
		 *   $status: StatusCodes.OK,
		 *   $data: { }
		 * }
		 *
		 * Reject:
		 * {
		 *   $status: StatusCodes.ERROR,
		 *   $message: "Error message",
		 *   $exception: { ... }
		 * }
		 *
		 */
		init: function() {
			throw new Error("Not implemented!");
		},

		/**
		 * Query a list of items
		 *
		 * Parameters:
		 * opts: {
		 *   $context: {
		 *     $user,
		 *     $role,
		 *     $lang
		 *   },
		 *   $endpoint,
		 *   $collection: "users.$query",
		 *   $orderBy: "name, email" // optional
		 * }
		 *
		 * Return:
		 * Resolve:
		 * {
		 *   $status: StatusCodes.OK,
		 *   $data: [record1, record2, ...]
		 * }
		 *
		 * Reject:
		 * {
		 *   $status: StatusCodes.ERROR,
		 *   $message: "Error message",
		 *   $exception: { ... }
		 * }
		 *
		 */
		query: function(opts) {
			throw new Error("Not implemented!");
		},

		/**
		 * Does a create or update if record is there already
		 *
		 * Parameters:
		 * opts: {
		 *   $context: {
		 *     $user,
		 *     $role,
		 *     $lang
		 *   },
		     $endpoint,
		 *   $collection: "users.$query",
		 *   $data: {},
		 *   $key: "abc~def"
		 * }
		 *
		 * Return:
		 * Resolve:
		 * {
		 *   $status: StatusCodes.OK,
		 *   $data: { }
		 * }
		 *
		 * Reject:
		 * {
		 *   $status: StatusCodes.ERROR,
		 *   $message: "Error message",
		 *   $exception: { ... }
		 * }
		 *
		 */
		put: function(opts) {
			throw new Error("Not implemented!");
		},

		/**
		 * Reads exactly one record by it's key
		 *
		 * Parameters:
		 * opts: {
		 *   $context: {
		 *     $user,
		 *     $role,
		 *     $lang
		 *   },
		     $endpoint,
		 *   $collection: "users.$query",
		 *   $key: "abc~def"
		 * }
		 *
		 * Return:
		 * Resolve:
		 * {
		 *   $status: StatusCodes.OK or StatusCodes.NOT_FOUND
		 *   $data: { }
		 * }
		 *
		 * Reject:
		 * {
		 *   $status: StatusCodes.ERROR,
		 *   $message: "Error message",
		 *   $exception: { ... }
		 * }
		 *
		 */
		read: function(opts) {
			throw new Error("Not implemented!");
		},

		/**
		 * Delete exactly one record by it's key
		 *
		 * Parameters:
		 * opts: {
		 *   $context: {
		 *     $user,
		 *     $role,
		 *     $lang
		 *   },
		     $endpoint,
		 *   $collection: "users.$query",
		 *   $key: "abc~def"
		 * }
		 *
		 * Return:
		 * Resolve:
		 * {
		 *   $status: StatusCodes.OK or StatusCodes.NOT_FOUND
		 * }
		 *
		 * Reject:
		 * {
		 *   $status: StatusCodes.ERROR,
		 *   $message: "Error message",
		 *   $exception: { ... }
		 * }
		 *
		 */
		remove: function(opts) {
			throw new Error("Not implemented!");
		},

		/**
		 * Delete exactly one record by it's key
		 *
		 * Parameters:
		 * opts: {
		 *   $context: {
		 *     $user,
		 *     $role,
		 *     $lang
		 *   },
		     $endpoint,
		 *   $collection: "users.$query", // string or regex
		 * }
		 *
		 * Return:
		 * Resolve:
		 * {
		 *   $status: StatusCodes.OK
		 * }
		 *
		 * Reject:
		 * {
		 *   $status: StatusCodes.ERROR,
		 *   $message: "Error message",
		 *   $exception: { ... }
		 * }
		 *
		 */
		clearCollection: function() {
			throw new Error("Not implemented!");
		}
	}
);

function buildResult(status, data, message, exception, metaData) {

	var res = {
		$status: status
	};

	if (data) res.$data = data;
	if (metaData) res.$metaData = metaData;
	if (message) res.$message = message;
	if (exception) res.$exception = exception;

	return res;
}

function buildErrResult(message, exception) {
	return buildResult(_statusCodes.ERROR, null, message, exception);
}
exports.StorageInterface = storageInterfaceClass;
exports.StatusCodes = _statusCodes;

exports.buildResult = buildResult;
exports.buildErrResult = buildErrResult;

// Same db name for all kind of database - !!must be different from mobile application name
exports.databaseName = "sage-tablet-db";
});

define('syracuse-tablet/html/js/storage/storageWinJS',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/helpers/winjs'],function (require, exports, module) {

/*
 * WinJS storage interface (Webview control running in Windows Store Application)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var winjs = require('syracuse-tablet/html/js/helpers/winjs');

function _StorageInterfaceWinJS() {
	this.infoString = "WinJS storage interface";
};

/*
 *
 * Proxy class to route all call to winJS container
 *
 */
var _storageInterfaceWinJSClass = utils.defineClass(
	_StorageInterfaceWinJS,
	storageInterface.StorageInterface, {
		init: function() {
			var useTestDatabase = globals.isTestEnvironment();
			return winjs.callWinJS("winjsDB", "init", {
				useTestDatabase: useTestDatabase
			});
		},

		queryAppConfigs: function() {
			return winjs.callWinJS("winjsDB", "queryAppConfigs", {});
		},

		createAppConfig: function(data) {
			return winjs.callWinJS("winjsDB", "createAppConfig", {
				app: data
			});
		},

		readAppConfig: function(appid) {
			return winjs.callWinJS("winjsDB", "readAppConfig", {
				appid: appid
			});
		},

		deleteAppConfig: function(appid) {
			return winjs.callWinJS("winjsDB", "deleteAppConfig", {
				appid: appid
			});
		}
	}
);

exports.StorageInterface = _storageInterfaceWinJSClass;
exports.isAvailable = function() {
	return winjs.isAvailable();

};
});

define('syracuse-tablet/html/js/storage/storageWebSQL',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {

/*
 * WebSQL storage interface (Chrome, Safari)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("webSQL");

//Increase this number to upgrade database to schema described in _objectStores
var _databaseVersion = 16;

var _tables = [
	// meta data table for handling etags, ttl, size, ..
	"DROP TABLE IF EXISTS sdata_meta",
	"CREATE TABLE sdata_meta ( " +
	"key text, " +
	"collection text, " +
	"endpoint text, " +
	"context text, " +
	"id text, " +
	"etag text, " +
	"last_read text, " +
	"last_updated text" +
	")",
	"DROP INDEX IF EXISTS sdata_meta_pk",
	"CREATE UNIQUE INDEX sdata_meta_pk ON sdata_meta (key, collection, endpoint, context)",
	"DROP INDEX IF EXISTS sdata_meta_id",
	"CREATE UNIQUE INDEX sdata_meta_id ON sdata_meta (id)",
	// data table
	"DROP TABLE IF EXISTS sdata_objects",
	"CREATE TABLE sdata_objects ( " +
	"id text, " +
	"data text " +
	")",
	"DROP INDEX IF EXISTS sdata_objects_pk",
	"CREATE UNIQUE INDEX sdata_objects_pk ON sdata_objects (id)"
];

function _StorageInterfaceWebSQL() {
	this.infoString = "WebSQL storage interface";
	this.databaseVersion = _databaseVersion;
	this.databaseName = storageInterface.databaseName;
	this.useTestDatabase = false;
	this.databaseSize = 2 * 1024 * 1024;
	this.db = null;
};

var _storageInterfaceWebSQLClass = utils.defineClass(
	_StorageInterfaceWebSQL,
	storageInterface.StorageInterface, {
		init: function() {
			var deferred = $.Deferred();
			var self = this;
			var useTestDatabase = globals.isTestEnvironment();
			self.databaseName = storageInterface.databaseName + "-test";
			self.useTestDatabase = useTestDatabase;
			try {
				self._openDB().then(function(status) {
					deferred.resolve(status);
				}).fail(function(status) {
					deferred.reject(status);
				});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error initializing database", e));
			} finally {
				return deferred.promise();
			}
		},
		put: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("PUT: ", JSON.stringify(opts));

				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [opts.$key, opts.$collection, opts.$endpoint, context];

				var insertData = function(metaData) {
					self._executeSql("INSERT INTO sdata_objects (data, id) values (?, ?)", [JSON.stringify(opts.$data), metaData.$id])
						.then(function() {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
						}).fail(function(status) {
							deferred.reject(status);
						});
				};

				var updateData = function(metaData) {
					self._executeSql("UPDATE sdata_objects set data = ? where id = ?", [JSON.stringify(opts.$data), metaData.$id])
						.then(function(result) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
						}).fail(function(status) {
							deferred.reject(status);
						});
				};

				// handle meta data
				self._readMetaData(context, params)
					.then(function(metaData) {
						if (metaData && metaData.$etag === opts.$data.$etag) {
							// record has not changed
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
						} else if (metaData) {
							// update
							metaData.$etag = opts.$data.$etag;
							metaData.$lastUpdated = utils.getCurISODateTime();
							self._writeMetaData(metaData)
								.then(function() {
									updateData(metaData);
								}).fail(function(status) {
									deferred.reject(status);
								});
						} else {
							// insert
							metaData = {
								$key: opts.$key,
								$collection: opts.$collection,
								$endpoint: opts.$endpoint,
								$context: opts.$context,
								$etag: opts.$data.$etag,
								$lastUpdated: utils.getCurISODateTime()
							};
							self._writeMetaData(metaData)
								.then(function(metaData) {
									insertData(metaData);
								}).fail(function(status) {
									deferred.reject(status);
								});
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error writing to database", e));
			} finally {
				return deferred.promise();
			}
		},

		read: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("READ: ", JSON.stringify(opts));

				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [opts.$key, opts.$collection, opts.$endpoint, context];

				self._readMetaData(context, params)
					.then(function(metaData) {
						if (!metaData) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						} else {
							self._executeSql("SELECT * FROM sdata_objects where id = ?", [metaData.$id])
								.then(function(result) {
									try {
										if (result.rows.length <= 0) {
											deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
										} else {
											deferred.resolve(storageInterface.buildResult(
												storageInterface.StatusCodes.OK,
												JSON.parse(result.rows.item(0).data),
												null,
												null, {
													$lastRead: metaData.$lastRead,
													$lastUpdated: metaData.$lastUpdated
												}));
										}
									} catch (e) {
										deferred.reject(storageInterface.buildErrResult("error reading from database", e));
									}
								}).fail(function(status) {
									deferred.reject(status);
								});
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		query: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("QUERY: ", JSON.stringify(opts));

				if (!opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [opts.$collection, opts.$endpoint, context];

				self._executeSql("SELECT o.*, m.last_read, m.last_updated FROM sdata_objects o INNER JOIN sdata_meta m ON (o.id = m.id and m.collection = ? and m.endpoint = ? and m.context = ?)", params)
					.then(function(result) {
						var ret = [];
						var meta = [];
						try {
							for (var i = 0; i < result.rows.length; i++) {
								var item = result.rows.item(i);
								ret.push(JSON.parse(item.data));
								meta.push({
									$lastRead: item.last_read,
									$lastUpdated: item.last_updated
								});
							}
						} catch (e) {
							deferred.reject(storageInterface.buildErrResult("error reading from database", e));
							return;
						}
						// Exception are handled by our jq deferred hack
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, ret, null, null, meta));
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		remove: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("REMOVE: ", JSON.stringify(opts));

				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [opts.$key, opts.$collection, opts.$endpoint, context];
				self._removeMetaData(context, params)
					.then(function(metaData) {
						if (!metaData) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						} else {
							self._executeSql("DELETE FROM sdata_objects where id = ?", [metaData.$id])
								.then(function() {
									deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
								}).fail(function(status) {
									deferred.reject(status);
								});
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error writing to database", e));
			} finally {
				return deferred.promise();
			}
		},
		clearCollection: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("CLEAR: ", JSON.stringify(opts));

				if (!opts.$collection || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [context];

				//self._executeSql("SELECT * FROM sdata_meta where context = ?", params)
				self._executeSql("SELECT * FROM sdata_meta")
					.then(function(result) {
						var ret = [];
						try {
							for (var i = 0; i < result.rows.length; i++) {
								var item = result.rows.item(i);
								if (opts.$collection.test(item.collection)) {
									ret.push({
										$context: opts.$context,
										$collection: item.collection,
										$endpoint: item.endpoint,
										$key: item.key
									});
								}
							}
							$.smForEachPromise(ret, function(item) {
								return self.remove(item);
							}).then(function() {
								deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
							}).fail(function(e) {
								deferred.reject(e);
							});
						} catch (e) {
							deferred.reject(storageInterface.buildErrResult("error reading from database", e));
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		_readMetaData: function(context, params, noUpdate) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				self._executeSql("SELECT * FROM sdata_meta where key = ? and collection = ? and endpoint = ? and context = ?", params)
					.then(function(result) {
						try {
							if (result.rows.length <= 0) {
								deferred.resolve(null);
							} else {
								var item = result.rows.item(0);
								var metaData = {
									$key: item.key,
									$collection: item.collection,
									$endpoint: item.endpoint,
									$context: item.context,
									$id: item.id,
									$etag: item.etag,
									$lastRead: item.last_read,
									$lastUpdated: item.last_updated
								};
								log && log("Read meta data: " + JSON.stringify(metaData));
								if (noUpdate === true) {
									deferred.resolve(metaData);
								} else {
									self._writeMetaData(metaData)
										.then(function() {
											// allways resolve and ignore errors
											deferred.resolve(metaData);
										}).fail(function(e) {
											deferred.reject(storageInterface.buildErrResult("error reading from database", e));
										});
								}
							}
						} catch (e) {
							deferred.reject(storageInterface.buildErrResult("error reading from database", e));
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		_writeMetaData: function(metaData) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				metaData.$lastRead = utils.getCurISODateTime();
				if (!metaData.$id) {
					metaData.$id = utils.UUID();

					self._executeSql("INSERT INTO sdata_meta (key, collection, endpoint, context, id, etag, last_read, last_updated) values (?, ?, ?, ?, ?, ?, ?, ?)", [
						metaData.$key,
						metaData.$collection,
						metaData.$endpoint,
						JSON.stringify(metaData.$context),
						metaData.$id,
						metaData.$etag,
						metaData.$lastRead,
						metaData.$lastUpdated
					])
						.then(function() {
							deferred.resolve(metaData);
						}).fail(function(status) {
							deferred.reject(status);
						});
				} else {
					self._executeSql("UPDATE sdata_meta set etag = ?, last_read = ?, last_updated = ? where id = ?", [metaData.$etag, metaData.$lastRead, metaData.$lastUpdated, metaData.$id])
						.then(function(result) {
							deferred.resolve(metaData);
						}).fail(function(status) {
							deferred.reject(status);
						});
				}
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error writing meta data", e));
			} finally {
				return deferred.promise();
			}
		},

		_removeMetaData: function(context, params) {
			var deferred = $.Deferred();
			var self = this;
			try {
				self._readMetaData(context, params, true)
					.then(function(metaData) {
						if (!metaData) {
							deferred.resolve(null);
						} else {
							self._executeSql("DELETE FROM sdata_meta where id = ?", [metaData.$id])
								.then(function() {
									deferred.resolve(metaData);
								}).fail(function(status) {
									deferred.reject(status);
								});
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},
		_executeSql: function(sql, params) {
			var deferred = $.Deferred();
			var self = this;
			try {
				self.db.transaction(function(tx) {
					try {
						log && log("SQL: " + sql);
						log && log(params);
						tx.executeSql(sql, params, function(tx, result) {
							deferred.resolve(result);
						}, function(tx, error) {
							deferred.reject(storageInterface.buildErrResult("error initializing database: " + _errorToMessage(tx, error)));
						});
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error running SQL statement", e));
					}
				});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error running SQL statement", e));
			}
			return deferred.promise();
		},

		/*
		 *
		 * Database migration functions
		 *
		 */
		_openDB: function() {
			var deferred = $.Deferred();
			var self = this;
			if (self.useTestDatabase === false && self.db) {
				deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
			}
			var request;
			try {
				log && log("Open database, request version: " + self.databaseVersion);
				self.db = openDatabase(self.databaseName, 7, 'Database', self.databaseSize);
				self._readCurrentVersion().then(function(version) {
					log && log("Current version: " + version);
					// In test framework create DB every time
					if (version === self.databaseVersion && self.useTestDatabase !== true) {
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
					} else {
						self._createTables().then(function(status) {
							return self._writeCurrentVersion();
						}).then(function(status) {
							deferred.resolve(status);
						}).fail(function(status) {
							deferred.reject(status);
						});
					}
				}).fail(function(status) {
					deferred.reject(status);
				});

			} catch (e) {
				log && log("Open database, exception", e);
				self.db = null;
				deferred.reject(storageInterface.buildErrResult("error initializing database", e));
			}

			return deferred.promise();
		},
		_readCurrentVersion: function() {
			var deferred = $.Deferred();
			var self = this;
			self._executeSql('SELECT version FROM version', null).then(function(result) {
				try {
					var len = result.rows.length;
					if (len === 1) {
						var version = result.rows.item(0).version;
						log && log("Read version: " + version);
						deferred.resolve(+version);
					}
					deferred.resolve(-1);
				} catch (e) {
					deferred.reject(storageInterface.buildErrResult("error reading database version", e));
				}
			}).fail(function(status) {
				// Asume table does not exist, create it
				log && log("Creating version table");
				self._executeSql('CREATE TABLE version (version TEXT)').then(function(status) {
					deferred.resolve(-1);
				}).fail(function(status) {
					globals.getModal().error("Error Creating version table", status, function() {
						deferred.reject(status);
					});
				});
			});
			return deferred.promise();
		},
		_writeCurrentVersion: function() {
			var deferred = $.Deferred();
			var self = this;
			self._executeSql('DELETE FROM version', null)
				.then(function(result) {
					return self._executeSql('INSERT INTO version (version) values (?)', [_databaseVersion]);
				})
				.then(function(status) {
					deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
				}).fail(function(status) {
					deferred.reject(status);
				});
			return deferred.promise();
		},
		_createTables: function() {
			var deferred = $.Deferred();
			var self = this;
			var p = [];
			for (var i = 0; i < _tables.length; i++) {
				p.push(self._executeSql(_tables[i]));
			}
			$.when.apply($, p).then(function() {
				deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
			}).fail(function(status) {
				deferred.reject(status);
			});
			return deferred.promise();
		}
	}
);

function _errorToMessage(tx, error) {
	return "CODE: " + error.code + " MESSAGE: " + error.message;
}
exports.StorageInterface = _storageInterfaceWebSQLClass;
exports.isAvailable = function() {
	return (window.openDatabase != null);
};
});

define('syracuse-tablet/html/js/storage/storageIndexedDB',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {

/*
 * IndexDB storage interface (Internet Explorer, Firefox)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("indexedDB");

var _indexedDB = window.indexedDB || window.webkitIndexedDB;
var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
var IDBDatabaseException = window.IDBDatabaseException || window.webkitIDBDatabaseException;

var READ_ONLY = (IDBTransaction && IDBTransaction.READ_ONLY) || "readonly";
var READ_WRITE = (IDBTransaction && IDBTransaction.READ_WRITE) || "readwrite";


// Increase this number to upgrade database to schema described in _objectStores
var _databaseVersion = 11;

var _objectStores = {
	"sdata": {
		"options": {
			"autoIncrement": true
		},
		"indexes": {
			"read_write_one": {
				"key": "key_collection_endpoint_context",
				"options": {
					"unique": true
				}
			},
			"read_write_all": {
				"key": "collection_endpoint_context",
				"options": {
					"unique": false
				}
			},
			"read_write_ctx": {
				"key": "context",
				"options": {
					"unique": false
				}
			}
		}
	}
};

function _StorageInterfaceIndexedDB() {
	this.infoString = "IndexedDB storage interface";
	this.databaseVersion = _databaseVersion;
	this.databaseName = storageInterface.databaseName;
	this.useTestDatabase = false;
	this.db = null;
};

var _storageInterfaceIndexedDBClass = utils.defineClass(
	_StorageInterfaceIndexedDB,
	storageInterface.StorageInterface, {

		init: function(requester) {
			requester = requester || "";
			log && log("_INIT " + requester);
			var deferred = $.Deferred();
			var self = this;
			var useTestDatabase = globals.isTestEnvironment();
			try {
				var _doInit = function() {
					log && log("DATABASE INIT!");
					self._openDB().then(function(status) {
						log && log("_openDB OK " + requester);
						deferred.resolve(status);
					}).fail(function(status) {
						log && log("_openDB KO " + requester);
						deferred.resolve(status);
					});
				};
				if (useTestDatabase === true) {
					if (self.db) {
						self.db.close();
						self.db = null;
					}
					self.useTestDatabase = true;
					self.databaseName = storageInterface.databaseName + "-test";
					log && log("DATABASE IN TEST MODE! " + requester);
					var req = _indexedDB.deleteDatabase(self.databaseName);
					req.onsuccess = function() {
						_doInit();
					};
					req.onerror = function(e) {
						log && log("REQUEST ERROR! " + requester);
						deferred.reject(storageInterface.buildErrResult("error deleting database"));
					};
					req.onblocked = function(e) {
						log && log("REQUEST BLOCKED! " + requester);
						deferred.reject(storageInterface.buildErrResult("error deleting database (blocked)"));
					};
				} else if (!self.db) {
					_doInit();
				}
			} catch (e) {
				log && log("init ERROR " + requester);
				deferred.reject(storageInterface.buildErrResult("error initializing database", e));
			} finally {
				return deferred.promise();
			}
		},

		put: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("PUT: ", JSON.stringify(opts));
				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$key, opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_one");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);
				var mustInsert = true;
				var datetime = utils.getCurISODateTime();
				var doInsert = function() {
					var obj = {
						"context": context,
						"collection": opts.$collection,
						"endpoint": opts.$endpoint,
						"key": opts.$key,
						"last_updated": datetime,
						"last_read": datetime,
						"key_collection_endpoint_context": key,
						"collection_endpoint_context": [opts.$collection, opts.$endpoint, context].join("_"),
						"data": opts.$data,
					};

					var reqt = objectStore.add(obj);
					reqt.onerror = function(event) {
						deferred.reject(storageInterface.buildErrResult("error writing to database: " + _eventToMessage(event)));
					};
					reqt.onsuccess = function(event) {
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
					};
				};
				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							if (opts.$data.$etag) {
								var etag = cr.value && cr.value.data.$etag;
								if (etag === opts.$data.$etag) {
									deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
									return;
								}
							}
							cr["delete"]();
							cr["continue"]();
						} else {
							doInsert();
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error writing to database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						doInsert();
					} else {
						deferred.reject(storageInterface.buildErrResult("error writing to database: " + _eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error writing to database", e));
			} finally {
				return deferred.promise();
			}
		},

		read: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("READ: ", JSON.stringify(opts));
				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");
				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);
				var key = [opts.$key, opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_one");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);

				request.onsuccess = function(event) {
					try {
						var cr = event.target && event.target.result && event.target.result.value;
						if (!cr) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						} else {
							deferred.resolve(storageInterface.buildResult(
								storageInterface.StatusCodes.OK,
								cr.data,
								null,
								null, {
									$lastRead: cr.last_read,
									$lastUpdated: cr.last_updated
								}));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						// Resolve since it's a logical issue and not neccessarily an error
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + _eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		query: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("QUERY: ", JSON.stringify(opts));
				if (!opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_all");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);
				var results = [];
				var meta = [];

				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							var data = cr.value.data;
							results.push(data);
							meta.push({
								$lastRead: cr.last_read,
								$lastUpdated: cr.last_updated
							});
							cr["continue"]();
						} else {
							deferred.resolve(storageInterface.buildResult(
								storageInterface.StatusCodes.OK,
								results,
								null,
								null,
								meta));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						// Resolve since it's a logical issue and not neccessarily an error
						deferred.resolve(storageInterface.buildResult(
							storageInterface.StatusCodes.OK,
							results,
							null,
							null,
							meta));
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + _eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		remove: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("REMOVE: ", JSON.stringify(opts));
				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$key, opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_one");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);

				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							cr["delete"]();
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
						} else {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error deleting from database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						// Resolve since it's a logical issue and not neccessarily an error
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + _eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error deleting from database", e));
			} finally {
				return deferred.promise();
			}
		},

		clearCollection: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("CLEAR: ", JSON.stringify(opts));
				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = context;

				//				var index = objectStore.index("read_write_ctx");
				//				var keyRange = IDBKeyRange.only(key);
				//				var request = index.openCursor(keyRange);
				var request = objectStore.openCursor();

				var records = [];

				var deleteMatches = function() {
					$.smForEachPromise(records, function(rec) {
						return self.remove({
							$context: opts.$context,
							$collection: rec.collection,
							$endpoint: rec.endpoint,
							$key: rec.key
						});
					}).then(function() {
						deferred.resolve();
					}).fail(function(e) {
						deferred.reject(e);
					});
				};
				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							if (opts.$collection.test(cr.value.collection)) {
								records.push(cr.value);
							}
							cr["continue"]();
						} else {
							deleteMatches();
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						deleteMatches();
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + _eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		_openDB: function() {
			var deferred = $.Deferred();
			var self = this;
			if (self.useTestDatabase === false && self.db) {
				deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
			}

			var request;
			try {
				log && log("Open database, request version: " + self.databaseVersion);
				request = _indexedDB.open(self.databaseName, self.databaseVersion);
				request.onupgradeneeded = function(e) {
					log && log("Open database, need upgrade");
					self.db = (e.target.result || e.target.source);
					self._createObjectStore();
				};
				request.onsuccess = function(e) {
					log && log("Open database, success");
					var db = (e.target.result || e.target.source);
					if (!db.setVersion && (self.databaseVersion != db.version)) {
						log && log("Open database, versions missmatch: " + self.DatabaseVersion + " != " + db.version);
						var sdv = db.setVersion(self.databaseVersion);
						sdv.onsuccess = function(e) {
							log && log("Open database, setting version, success");
							self.db = db;
							self._createObjectStore();
							log && log("Open database, opened");
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
						};
						sdv.onerror = function(e) {
							log && log("Open database, setting version, error", e);
							self.db = null;
							deferred.reject(storageInterface.buildErrResult("error initializing database: " + _eventToMessage(e)));
						};
					} else {
						log && log("Open database, opened");
						self.db = db;
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
					}
				};
				request.onerror = function(e) {
					log && log("Open database, error", e);
					self.db = null;
					deferred.reject(storageInterface.buildErrResult("error initializing database: " + _eventToMessage(e)));
				};
			} catch (ex) {
				log && log("Open database, exception", ex);
				self.db = null;
				deferred.reject(storageInterface.buildErrResult("error initializing database", ex));
			}

			return deferred.promise();
		},

		// Create schema of database on version change
		_createObjectStore: function() {
			var self = this;
			var db = self.db;
			log && log("Updating database");
			Object.keys(_objectStores).forEach(function(name) {
				var os = _objectStores[name];
				if (db.objectStoreNames.contains(name)) {
					log && log("Deleting objectStore: " + name);
					db.deleteObjectStore(name);
				}

				log && log("Creating objectStore: " + name);
				var obj = db.createObjectStore(name, os.options);
				Object.keys(os.indexes).forEach(function(iname) {
					var idx = os.indexes[iname];
					log && log("Creating index: " + iname);
					obj.createIndex(iname, idx.key, idx.options);
				});
			});
		}
	}
);

function _eventToMessage(event) {
	return JSON.stringify(event);
}

exports.StorageInterface = _storageInterfaceIndexedDBClass;
exports.isAvailable = function() {
	return (_indexedDB != null);
};
});

define('syracuse-tablet/html/js/storage/storage',['require','exports','module','syracuse-tablet/html/js/storage/storageInterface','syracuse-tablet/html/js/storage/storageWinJS','syracuse-tablet/html/js/storage/storageWebSQL','syracuse-tablet/html/js/storage/storageIndexedDB'],function (require, exports, module) {

/*
 * Storage module (Selects implementation depending on what's available in the current browser
 */

var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');

var _impls = [
	require('syracuse-tablet/html/js/storage/storageWinJS'),
	require('syracuse-tablet/html/js/storage/storageWebSQL'),
	require('syracuse-tablet/html/js/storage/storageIndexedDB')
];

var _storageImpl;

// Choose the first supported storage engine
function _getStorageImpl() {
	if (_storageImpl) {
		return _storageImpl;
	}

	_impls.some(function(impl) {
		if (impl.isAvailable()) {
			var ctor = impl.StorageInterface;
			_storageImpl = new ctor();
			return true;
		}
		return false;
	});

	return _storageImpl;
}

exports.getStorage = _getStorageImpl;
exports.StatusCodes = storageInterface.StatusCodes;
});

define('syracuse-tablet/html/js/application/settings',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/storage/storage','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {

/*
 * This module should be used to persist user specific settings
 */

var globals = require('syracuse-tablet/html/js/helpers/globals');
var storageModule = require('syracuse-tablet/html/js/storage/storage');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("settings");

var _currentContextUserRole = {};
var _currentContextUser = {};

var _settingsUserRole = null;
var _settingsUser = null;

/*
 *
 */
function _getContext() {
	var ctx = globals.getUserCtx();
	if (!ctx) { // In case not logged in yet!
		return {
			$user: "none",
			$role: "none",
			$lang: "en-US",
		};
	}
	return ctx;
}

/*
 *
 */
function _checkContextUserRole() {
	var ctx = _getContext();
	if (_currentContextUserRole.user != ctx.$user ||
		_currentContextUserRole.role != ctx.$role) {
		_currentContextUserRole.user = ctx.$user;
		_currentContextUserRole.role = ctx.$role;
		_currentContextUserRole.lang = ctx.$lang;
		_settingsUserRole = null;
	}
}

/*
 *
 */
function _readSettingsUserRole() {
	var storage = globals.getStorage();

	var ctx = {
		"$user": _currentContextUserRole.user,
		"$role": _currentContextUserRole.role,
		"$lang": "none"
	};

	return storage.read({
		$context: ctx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: "$user_and_role"
	}).then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			return result.$data;
		} else {
			return {};
		}
	});
}

/*
 *
 */
function _checkContextUser() {
	var ctx = _getContext();
	if (_currentContextUser.user != ctx.$user ||
		_currentContextUser.role != ctx.$role) {
		_currentContextUser.user = ctx.$user;
		_currentContextUser.role = ctx.$role;
		_currentContextUser.lang = ctx.$lang;
		_settingsUser = null;
	}
}

/*
 *
 */
function _readSettingsUser() {
	var storage = globals.getStorage();

	var ctx = {
		"$user": _currentContextUser.user,
		"$role": "none",
		"$lang": "none"
	};

	return storage.read({
		$context: ctx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: "$user"
	}).then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			_settingsUser = result.$data;
		} else {
			_settingsUser = {};
		}
		log && log("Read user settings...");
		log && log(_settingsUser);
	});
}

/*
 *
 */
function _writeSettingsUser() {
	var storage = globals.getStorage();

	var ctx = {
		"$user": _currentContextUser.user,
		"$role": "none",
		"$lang": "none"
	};

	log && log("Writing user settings...");
	log && log(_settingsUser);
	return storage.put({
		$context: ctx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: "$user",
		$data: _settingsUser
	}).then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			return result.$data;
		} else {
			return {};
		}
	});
}

/*
 * ======================================================
 * Pages pinned on welcome page
 * ======================================================
 */

/*
 *
 */
exports.getPinnedPages = function() {
	_checkContextUser();
	var read;
	if (_settingsUser == null) {
		read = _readSettingsUser();
	} else {
		read = $.smResolve();
	}
	return read.then(function() {
		_settingsUser.pinnedPages = _settingsUser.pinnedPages || [];
		return _settingsUser.pinnedPages;
	});
};

/*
 *
 */
exports.addPinnedPage = function(page) {
	return exports.getPinnedPages().then(function(pages) {
		if (!pages.some(function(p, idx) {
			if (p.id === page.id) {
				pages[idx] = page; // Overwrite existing
				return true;
			}
		})) {
			pages.push(page);
		}
		// No return ... then, because can be done async
		_writeSettingsUser();
		return page;
	});
};

/*
 *
 */
exports.isPinnedPage = function(id) {
	return exports.getPinnedPages().then(function(pages) {
		return pages.some(function(p, idx) {
			if (p.id === id) {
				return true;
			}
		});
	});
};

/*
 *
 */
exports.removePinnedPage = function(id) {
	return exports.getPinnedPages().then(function(pages) {
		if (pages.some(function(p, idx) {
			if (p.id === id) {
				pages.splice(idx, 1); // remove and stop
				return true;
			}
		})) {
			// Only write if there was a change
			// No return ... then, because can be done async
			_writeSettingsUser();
		}
	});
};

/*
 * ======================================================
 * Apps hidden on welcome page
 * ======================================================
 */
/*
 *
 */
exports.getHiddenApplications = function() {
	_checkContextUser();
	var read;
	if (_settingsUser == null) {
		read = _readSettingsUser();
	} else {
		read = $.smResolve();
	}
	return read.then(function() {
		_settingsUser.hiddenApplications = _settingsUser.hiddenApplications || [];
		return _settingsUser.hiddenApplications;
	});
};

/*
 *
 */
exports.unhideApplication = function(applicationName) {
	return exports.getHiddenApplications().then(function(apps) {
		if (apps.some(function(app, idx) {
			if (app === applicationName) {
				apps.splice(idx, 1); // remove and stop
				return true;
			}
		})) {
			// Only write if there was a change
			// No return ... then, because can be done async
			_writeSettingsUser();
		}
	});
};

/*
 *
 */
exports.hideApplication = function(applicationName) {
	return exports.getHiddenApplications().then(function(apps) {
		if (!apps.some(function(app, idx) {
			if (app === applicationName) {
				return true;
			}
		})) {
			apps.push(applicationName);
			// No return ... then, because can be done async
			_writeSettingsUser();
		}
	});
};

/*
 * ======================================================
 * Tiles on welcome page
 * ======================================================
 */
exports.getTileConfigs = function() {
	_checkContextUser();
	var read;
	if (_settingsUser == null) {
		read = _readSettingsUser();
	} else {
		read = $.smResolve();
	}
	return read.then(function() {
		_settingsUser.tileConfigs = _settingsUser.tileConfigs || {};
		return _settingsUser.tileConfigs;
	});
};

exports.setTileConfig = function(tile) {
	return exports.getTileConfigs().then(function(configs) {
		configs[tile.tileId] = tile;
		_writeSettingsUser();
	});
};


/*
 *
 */
exports.getLastUserProfile = function(profile) {
	var ctx = {
		"$user": "none",
		"$role": "none",
		"$lang": "none"
	};
	var storage = globals.getStorage();
	return storage.read({
		$context: ctx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: "$last_user_profile"
	}).then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			return result.$data;
		} else {
			return null;
		}
	});
};

/*
 *
 */
exports.setLastUserProfile = function(profile) {
	var ctx = {
		"$user": "none",
		"$role": "none",
		"$lang": "none"
	};
	var storage = globals.getStorage();
	return storage.put({
		$context: ctx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: "$last_user_profile",
		$data: profile
	}).then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			return result.$data;
		} else {
			return {};
		}
	});
};


/*
 * These are settings that are understood to be global for the device
 * This should be things that are common for all users, roles, languages that use the current device
 * E.g. is the device type ("auto", "tablet", "smartphone")
 */
exports.getGlobalSettings = function() {
	var storage = globals.getStorage();

	var ctx = {
		"$user": "none",
		"$role": "none",
		"$lang": "none"
	};

	return storage.read({
		$context: ctx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: "$global_settings"
	}).then(function(result) {
		var settings;
		if (result.$status === storageModule.StatusCodes.OK) {
			settings = result.$data;
		} else {
			settings = {
				"device-type": "auto"
			};
		}
		// Store last read settings in a global variable to make the accessible from elsewhere
		globals.setGlobalSettings(settings);
		return settings;
	});
};

exports.setGlobalSettings = function(settings) {
	var storage = globals.getStorage();

	var ctx = {
		"$user": "none",
		"$role": "none",
		"$lang": "none"
	};
	return storage.put({
		$context: ctx,
		$collection: "$settings",
		$endpoint: "$local",
		$key: "$global_settings",
		$data: settings
	}).then(function() {
		// Store last stored settings in a global variable to make the accessible from elsewhere
		globals.setGlobalSettings(settings);
		return settings;
	}).fail(function(e) {
		return $.smResolve();
	});
};
});

define('syracuse-tablet/html/js/init/initContext',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalSelectContext','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/sdata/sdataCommonResources','syracuse-tablet/html/js/storage/localStorage','syracuse-tablet/html/js/application/settings'],function (require, exports, module) {

var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var modalSelectContext = require('syracuse-tablet/html/js/ui/modals/modalSelectContext');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var sdataCommonResources = require('syracuse-tablet/html/js/sdata/sdataCommonResources');
var localStorage = require('syracuse-tablet/html/js/storage/localStorage');
var settings = require('syracuse-tablet/html/js/application/settings');

exports.getLastUsedContext = function(userName) {
	var context;
	try {
		var settingsKey = userName + "_lastContext";
		var contextString = localStorage.getItem(settingsKey);
		if (contextString && contextString.length > 0) {
			context = JSON.parse(contextString);
		}
	} catch (e) {}
	return context;
};

exports.setLastUsedContext = function(userName, context) {
	try {
		var settingsKey = userName + "_lastContext";
		var contextString = JSON.stringify(context);
		localStorage.setItem(settingsKey, contextString);
	} catch (e) {}
};

exports.init = function(force, warn) {
	var endpoints = [];
	var roles = [];
	var languages = [];

	var userCtx = globals.getUserCtx();
	var userName = userCtx && userCtx.$user;
	var userProfile = globals.getUserProfile();

	var currentContext = exports.getLastUsedContext(userName);

	// Settings are read here just so they are put into the globals to make them available later,
	// they are not needed here at all but it's a good place to read them
	return settings.getGlobalSettings()
		.then(function() {
			return sdataCommonResources.queryEndpoints();
		})
		.then(function(eps) {
			eps.forEach(function(ep) {
				if (userProfile.endpoints && userProfile.endpoints.some(function(e) {
					return e.$uuid === ep.$uuid;
				})) {
					endpoints.push(ep);
				}
			});
			return sdataCommonResources.queryLocalePreferences();
		})
		.then(function(ls) {
			languages = ls;
			return sdataCommonResources.queryRoles();
		})
		.then(function(rs) {
			rs.forEach(function(rl) {
				if (userProfile.roles && userProfile.roles.some(function(r) {
					return r.$uuid === rl.$uuid;
				})) {
					roles.push(rl);
				}
			});
		})
		.then(function() {
			var deferred = $.Deferred();
			var _dialog = function(ctx) {
				var selectNewContext;
				if (force || ctx == null) {
					var modal = new modalSelectContext.Modal(ctx, endpoints, roles, languages, warn);
					selectNewContext = modal.show();
				} else {
					ctx.action = "ok"; // as if dialog was opened and accepted
					selectNewContext = $.smResolve(ctx);
				}

				selectNewContext.then(function(context) {
					if (context && context.action === "ok") {
						deferred.resolve(context);
					} else if (context && context.action === "cancel") {
						if (currentContext == null) {
							force = true;
							_dialog(context);
						} else {
							deferred.resolve(null);
						}
					} else if (context && context.action === "logout") {
						globals.getApplication().logout().always(function() {
							deferred.resolve(null);
						});
					}
				}).fail(function(e) {
					deferred.reject(e);
				});
			};

			_dialog(currentContext);
			return deferred.promise();
		})
		.then(function(context) {
			if (context) {
				// Locale for client UI
				locale.setLocale(context.language);

				// Endpoint for storing records locally and to use for gadgets with default endpoint usage
				globals.setEndpoint(context.endpoint);

				// Context for storing records locally
				globals.setUserCtx({
					$user: userCtx.$user,
					$role: context.role,
					$lang: context.language,
				});
			}
			return context;
		})
		.then(function(context) {
			if (!context) {
				return context;
			}
			exports.setLastUsedContext(userName, context);
			return _contextChanged(context);
		})
		.then(function(context) {
			if (!context) {
				return context;
			}
			return _updateServerUserProfile(context, userName, endpoints, roles, languages);
		}).fail(function(e) {
			globals.getModal().error("context.sdataCommonResources error", e);
		});
};

function _contextChanged(context) {
	return $.smResolve()
		.then(function() {
			var deferred = $.Deferred();
			notifications.publish("sm.context.changed", deferred);
			return deferred.promise();
		}).then(function() {
			// Nothing
		}).fail(function(e) {
			globals.getModal().error("context._contextChanged error", e);
		});
}

function _updateServerUserProfile(context, userName, endpoints, roles, languages) {
	return sdataCommonResources.getUserProfile().then(function(up) {
		var change = false;
		var upChanges = {};
		change = endpoints.some(function(ep) {
			if (ep.application + "." + ep.contract + "." + ep.dataset === context.endpoint && ep.$uuid !== up.selectedEndpoint.$uuid) {
				upChanges.selectedEndpoint = {
					$uuid: ep.$uuid
				};
				return true;
			}
			return false;
		}) || change;
		change = roles.forEach(function(role) {
			if (role.code === context.role && role.$uuid !== up.selectedRole.$uuid) {
				upChanges.selectedRole = {
					$uuid: role.$uuid
				};
				return true;
			}
			return false;
		}) || change;
		languages.forEach(function(lang) {
			if (lang.code === context.languages && lang.$uuid !== up.selectedLocale.$uuid) {
				upChanges.selectedLocale = {
					$uuid: lang.$uuid
				};
				return true;
			}
			return false;
		}) || change;

		if (change) {
			return sdataCommonResources.updateUserProfile(upChanges)
				.then(function() {
					return context;
				});
		} else {
			return $.smResolve(context);
		}
	});
}
});

define('syracuse-tablet/html/js/sdata/entities/clientContract',['require','exports','module','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {

var globals = require('syracuse-tablet/html/js/helpers/globals');

var _entities = {};

var _propertiesToCopy = [
	// ui related
	"$title",
	"$isExcluded",
	"$isHidden",
	"$isMandatory",
	"$isReadOnly",
	"$isDisabled",

	// for formats
	"$format",
	"$x3Format",

	// for quantity and ref fields
	"$unit",
	"$value",
	"$shortTitle",
	"$capabilities",
	"$item",

	// constraints according to https://github.com/Sage-ERP-X3/platform/wiki/Resource-Prototypes
	"$minimum",
	"$maximum",
	"$exclusiveMinimum",
	"$exclusiveMaximum",
	"$minItems",
	"$maxItems",
	"$isNullable",
	"$isUnique",
	"$pattern",
	"$minLength",
	"$maxLength",
	"$precision",
	"$scale",
	"$enum"
];

exports.registerApp = function(app) {
	globals.getMetaData().registerStaticApp(app);
};

exports.registerEntity = function(entity) {
	_entities[entity.$entityName] = entity;
};

exports.getEntity = function(entity) {
	return _entities[entity];
};


exports.getPageInfo = function(name, options) {
	var repr = name.split(".");
	if (repr.length === 5) {
		repr = repr.slice(3, 5);
	}
	if (repr[0].smStartsWith("QUERY~")) {
		var p = repr[0].split("~");
		repr[0] = p[1];
	}
	var ent = _entities[repr[0]];
	if (!ent) {
		return null;
	}
	var state = {
		home: false,
		type: "regular",
		subtype: repr[1] ? repr[1].substring(1) : "unknown",
		cached: false,
		refreshed: false,
		changeHash: false
	};
	state.name = name;
	return state;

};

exports.getRegularPageInfo = function(pageId) {
	var repr = pageId.split(".");
	if (repr.length === 5) {
		repr = repr.slice(3, 5);
	}

	if (repr[0].smStartsWith("QUERY~")) {
		var p = repr[0].split("~");
		repr[0] = p[1];
	}

	var ent = _entities[repr[0]];
	var pageInfo;
	if (ent) {
		pageInfo = _buildPageInfo(repr[0], repr[1], ent);
	}
	return $.smResolve(pageInfo);
};

function _buildPageInfo(repr, facet, entity) {
	var page = {
		$page: {},
		$cache: {}
	};
	_buildPage(repr, facet, entity, page.$page);
	return page;
}

function _buildPage(repr, facet, entity, page) {
	if (facet === "$query" || facet === "$lookup") {
		page.$prototype = {
			$properties: {
				$resources: {
					$type: "application/x-array",
					$item: _buildPrototype(repr, facet),
					$url: "{$baseUrl}/" + repr + "('{$key}')?representation=" + repr + ".$queryItem",
				}
			}
		};
		page.$prototype.$url = "{$baseUrl}/" + repr + "?representation=" + repr + "." + facet;
		page.$prototype.$properties.$resources.$item.$key = "{$uuid}";
		page.$prototype.$properties.$resources.$item.$value = entity.$value;
		page.$prototype.$properties.$resources.$item.$links = {
			$details: {
				$url: "{$baseUrl}/" + repr + "('{$key}')?representation=" + repr + ".$details",
				$title: "Details"
			},
			$edit: {
				$url: "{$baseUrl}/" + repr + "('{$key}')?representation=" + repr + ".$edit",
				$title: "Edit"
			}
		};
		page.$prototype.$links = {
			$create: {
				$url: "{$baseUrl}/" + repr + "('{$key}')?representation=" + repr + ".$create",
				$title: "Create New"
			}
		};
		page.$prototype.$key = "{$uuid}";
	} else {

		page.$prototype = _buildPrototype(repr, facet);
		page.$prototype.$url = "{$baseUrl}/" + repr + "('{$key}')?representation=" + repr + "." + facet;
		page.$prototype.$key = "{$uuid}";
		page.$prototype.$links = {};

		// links to set in a json variable
		var links = {
			$edit: {
				$url: "{$baseUrl}/" + repr + "('{$key}')?representation=" + repr + ".$edit",
				$title: "Edit"
			},
			$query: {
				$url: "{$baseUrl}/" + repr + "?representation=" + repr + ".$query",
				$title: "List"
			},
			$save: {
				$url: "{$baseUrl}/" + repr + "('{$key}')?representation=" + repr + ".$save",
				$title: "Save"
			},
			$details: {
				$url: "{$baseUrl}/" + repr + "('{$key}')?representation=" + repr + ".$details",
				$title: "Detail"
			}
		};

		// add links according to facet (remainting facets are '$details', '$edit', '$create')
		switch (facet) {
			case "$create":
				page.$prototype.$links["$save"] = links["$save"];
				page.$prototype.$links["$query"] = links["$query"];
				break;
			case "$details":
				page.$prototype.$links["$edit"] = links["$edit"];
				page.$prototype.$links["$query"] = links["$query"];
				break;
			case "$edit":
				page.$prototype.$links["$save"] = links["$save"];
				page.$prototype.$links["$details"] = links["$details"];
				page.$prototype.$links["$query"] = links["$query"];
				break;
			default:
				throw new Error(facet ? "facet " + facet + " not handled yet" : "No facet specified");
		}
	}
	var $article = entity.$articles && entity.$articles[facet];
	if ($article) {
		page.$article = $article;
	}
	// not used at all but needs to be set since it's syntactically checked later
	page.$prototype.$baseUrl = "http://localhost:8124/mobile1/x3/erp/local";

	if (entity.$prototype) {
		entity.$prototype(page.$prototype, repr, facet);
	}
}

function _buildPrototype(repr, facet) {
	var entity = _entities[repr];
	if (!entity) {
		return null;
	}
	var proto = {
		$properties: {}
	};
	Object.keys(entity.$properties).forEach(function(key) {
		var prop = entity.$properties[key];
		var $type = prop.$type || "application/x-string";
		var propNew = proto.$properties[key] = {
			$type: $type
		};
		for (var i = 0; i < _propertiesToCopy.length; i++) {
			var pname = _propertiesToCopy[i];
			var p = prop[pname];
			if (p) {
				propNew[pname] = p;
			}
		}
	});
	return proto;
}

exports.getPrototype = function(repr, facet) {
	return _buildPrototype(repr, facet);
};
});

define('syracuse-tablet/html/js/application/pageRegistry',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/application/gadget'],function (require, exports, module) {

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var Gadget = require('syracuse-tablet/html/js/application/gadget').Klass;

var _staticPages = {};

exports.getPageInfo = function(pageName, options, currentPage) {
	return $.smResolve()
		.then(function() {
			// Check if a static page is requested first
			var pageInfo = _staticPages[pageName];
			return pageInfo;
		})
		.then(function(pageInfo) {
			// Check for client side page definition
			if (!pageInfo) {
				pageInfo = clientContract.getPageInfo(pageName, options);
			}
			return pageInfo;
		})
		.then(function(pageInfo) {
			if (pageName === "rowdetail" || pageName === "carddesign") {
				return _getPageInfoArrayChildPage(pageName, options, currentPage);
			}
			// Check for pages defined by "real" mobile applications
			if (!pageInfo) {
				pageInfo = globals.getMetaData().getPageInfo(pageName);
			}
			return pageInfo;
		})
		.then(function(pageInfo) {
			if (!pageInfo) {
				// Workaround for all that is lazy loaded
				pageInfo = _createDummyPageInfo(pageName);
			}
			_addAuthoringInfo(pageInfo);
			return pageInfo;
		})
		.then(function(pageInfo) {
			_addOptions(pageName, pageInfo, options, currentPage);

			pageInfo.uuid = utils.readableuid("page", pageInfo.type, pageInfo.name);
			return $.extend(true, {}, pageInfo);
		});
};

function _getPageInfoArrayChildPage(typePage, options, currentPage) {
	if (!currentPage) {
		throw new Error("_getPageInfoArrayChildPage - Not null currentPage expected");
	}
	if (!currentPage.getControl) {
		throw new Error("_getPageInfoArrayChildPage - Unexpected currentPage object - getControl method not found");
	}
	options = options || {};
	var ctrlArray = currentPage.getControl(options.controlId);
	if (!ctrlArray) {
		throw new Error("_getPageInfoArrayChildPage - Array not found - id:" + options.controlId);
	}
	return ctrlArray.childPageGetPageInfo(typePage, currentPage);
}

function _addOptions(pageName, pageInfo, options, currentPage) {
	options = options || {};
	pageInfo.options = $.extend(true, {}, options);
	_addGadgetData(pageInfo, currentPage);
}

function _addGadgetData(pageInfo, currentPage) {
	var gadgetId = pageInfo.options["gadget-id"];
	if (gadgetId) {
		var $properties = currentPage && currentPage.prototype && currentPage.prototype.json && currentPage.prototype.json.$properties;
		if ($properties) {
			Object.keys($properties).some(function(vignetteId) {
				var vignette = $properties[vignetteId];
				if (vignette && vignette.$gadget && vignette.$gadget.$uuid === gadgetId) {
					var json = vignette.$gadget;
					pageInfo.options.gadget = json ? new Gadget(json) : null;
					return true;
				}
				return false;
			});
		}
	}
}

function _createDummyPageInfo(pageName) {
	var pageInfo = {
		name: pageName,
		home: false,
		type: "regular",
		subtype: "",
		cached: false,
		refreshed: false,
		changeHash: false,
	};
	if (pageName) {
		var x = pageName.split('.');
		if (x.length > 0 && x[x.length - 1].smStartsWith('$')) {
			pageInfo.subtype = x[x.length - 1].substring(1);
		}
	}
	return pageInfo;
}

function _addAuthoringInfo(pageInfo) {
	if (!pageInfo.authoringName) {
		// Compute page name used by authoring
		var segs = pageInfo.name.split(".");
		var authoringName;
		if (segs.length === 5) {
			// remove dataset (e.g. SUPERV, ...)
			authoringName = segs[0] + "." + segs[1] + "." + segs[3] + "." + segs[4];
		} else {
			authoringName = pageInfo.name;
		}
		if (segs.length === 2) {
			authoringName = "syracuse.collaboration." + authoringName;
		}
		pageInfo.authoringName = authoringName;
	}
}

/**
 * Static preloaded pages
 * Pages belongs to all mobile applications
 */
function _registerStaticPages() {
	["login"].forEach(function(name) {

		var info = {
			name: name,
			type: "static",
			subtype: "html",

			cached: false,
			refreshed: false,
			changeHash: false,

			home: false,
			disableAuthoring: true,
			isLogin: name === "login",

			/**
			 * Html have an empty proto and are base on a stacked layout for compatibility with other pages
			 * Html is appended to layout root elmt
			 * We add the proto/article in state for convenience - it can be enhanced according to the needs
			 * Currently we need only static html pages
			 */
			$prototype: {
				$properties: {}
			},
			$article: {
				$layoutType: "stack",
				$items: []
			}
		};
		_staticPages[name] = info;
	});
}

// Called only once to register static html pages
_registerStaticPages();
});

define('syracuse-tablet/html/js/authoring/authoringSData',['require','exports','module','syracuse-tablet/html/js/sdata/sdataHttp'],function (require, exports, module) {

var sdataHttp = require('syracuse-tablet/html/js/sdata/sdataHttp');
var _DEVICE_NAME = "mobile";

/*
 * pageData: {
 *   application: "x3",
 *   contract: "erp",
 *   representation: "BPCUSTOMERM"
 *   facet: "$details"
 * }
 */
exports.getPageVariants = function(pageData) {
	return $.smResolve()
		.then(function() {
			pageData = $.extend(true, {}, {
				device: _DEVICE_NAME
			}, pageData);

			if (!pageData.application || !pageData.contract || !pageData.representation || !pageData.facet || !pageData.device) {
				return $.smReject("Not all mandatory parameters present: " + JSON.stringify(pageData));
			}

			var code = [pageData.application, pageData.contract, pageData.representation, pageData.facet, pageData.device].join(".");
			var req = {
				url: "/sdata/syracuse/collaboration/syracuse/pageDefs(code%20eq%20'" + code + "')?representation=pageDef.$details"
			};

			return sdataHttp.send(req)
				.then(function(response) {
					if (response && response.isSuccess) {
						return response.responseJSON.variants || [];
					}
					if (response.status === 404) {
						return [];
					}
					return $.smReject("Unknown error");
				});
		});
};

exports.deletePageVariants = function(pageData) {
	return $.smResolve()
		.then(function() {
			pageData = $.extend(true, {}, {
				device: _DEVICE_NAME
			}, pageData);

			if (!pageData.application || !pageData.contract || !pageData.representation || !pageData.facet || !pageData.device) {
				return $.smReject("Not all mandatory parameters present: " + JSON.stringify(pageData));
			}

			var code = [pageData.application, pageData.contract, pageData.representation, pageData.facet, pageData.device].join(".");
			var req = {
				url: "/sdata/syracuse/collaboration/syracuse/pageDefs(code%20eq%20'" + code + "')?representation=pageDef.$edit",
				method: "DELETE"
			};

			return sdataHttp.send(req)
				.then(function(response) {
					if (response && response.isSuccess) {
						return;
					}
					return $.smReject("Unknown error");
				});
		});
};

exports.createPageDefinitionWC = function(opts) {
	var params = {
		"pageContext": [opts.application, opts.contract, opts.representation, opts.facet].join("."),
		"device": _DEVICE_NAME,
		"representation": "pageAuth.$edit"
	};

	var url = "/sdata/syracuse/collaboration/syracuse/pageAuths" +
		(opts.variant != null ? ("('" + opts.variant + "')") : "/$template") +
		"/$workingCopies?" +
		Object.keys(params).map(function(key) {
			return key + "=" + params[key];
		}).join("&");

	var req = {
		url: url,
		method: "POST"
	};

	return sdataHttp.send(req)
		.then(function(response) {
			if (response && response.isSuccess) {
				return response.responseJSON;
			}
			return $.smReject("Unknown error");
		});
};
exports.savePageDefinitionWC = function(opts, wc) {
	var parameters = {
		"roles": opts.roles,
		"users": opts.users,
		"endpoints": opts.endpoints,
		"saveAsOption": opts.saveAsOption,
		"isFactory": false,
		"isModelRepresentation": false,
		"personalCopy": false,
		"variantCode": opts.variantCode,
		"variantTitle": opts.variantTitle,
		"variantDescription": opts.variantDescription
	};
	switch (opts.saveAsOption) {
		case "factory_variant":
			parameters.isFactory = true;
			break;
		case "personal_copy":
			parameters.personalCopy = true;
			break;
		case "shared_copy":
			break;
		case "global_variant":
			break;
	}

	wc.$actions = {};
	var save;
	if (opts.variant) {
		save = wc.$actions["$save"] = {};
		delete parameters.saveAsOption;
	} else {
		save = wc.$actions["saveAs"] = {};
	}
	save.$isRequested = true;
	save.$parameters = parameters;

	var req = {
		url: wc.$url,
		method: "PUT",
		send: wc
	};
	return sdataHttp.send(req)
		.then(function(response) {
			if (response && response.isSuccess) {
				return response.responseJSON;
			}
			return $.smReject("Unknown error");
		});
};

exports.savePageDefinition = function(opts) {
	return exports.createPageDefinitionWC(opts)
		.then(function(wc) {
			var send = $.extend(true, {}, wc);
			send.content = send.content || {};
			send.content.$article = opts.article;

			return exports.savePageDefinitionWC(opts, send)
				.then(function(wcSaved) {
					var data = $.extend(true, {}, wc, wcSaved);
					var diags = [];
					_extractDiag(data, diags);
					return {
						data: data,
						diags: diags
					};
				})
				.fail(function(e) {
					return $.smReject({
						data: null,
						diags: [{
							$severity: "error",
							$message: "" + e
						}]
					});
				});
		});
};

function _extractDiag(data, diags) {
	Object.keys(data).forEach(function(key) {
		var value = data[key];
		if (key === "$diagnoses") {
			value.forEach(function(d) {
				diags.push(d);
			});
		} else {
			if (value && typeof value === "object") {
				_extractDiag(value, diags);
			}
		}
	});
}
});

define('syracuse-tablet/html/js/authoring/authoringHtml',['require','exports','module'],function (require, exports, module) {

/*
 * Authoring panel main layout
 */
var _templates = {
	authPanelHeader: '\
		<div style="display:table;table-layout:fixed;;width:100%;">\
			<div style="display:table-row;width:100%; ">\
				<div style="display:table-cell;width:300px;">\
					<div style="display:table;">\
						<div style="display:table-row;">\
							<div style="display:table-cell;">\
								<button class="btn btn-auth-header" id="s-m-auth-settings-id" type="button"><label class="glyphicon glyphicon-cog"></label>{{label_settings}}</button> \
							</div>\
							<div style="display:table-cell;" >\
								<div class="btn-group" id="s-m-auth-orientation-id" data-toggle="buttons">\
									<button class="btn btn-auth-header active" id="s-m-auth-vertical-id" data-auth-orientation="portrait" title="{{label_preview_portrait}}"> \
										<input type="radio" name="orientation" checked> \
										<label class="glyphicon glyphicon-resize-vertical"></label> \
									</button> \
									<button class="btn btn-auth-header" id="s-m-auth-horizontal-id" data-auth-orientation="landscape" title="{{label_preview_landscape}}"> \
										<input type="radio" name="orientation"> \
										<label class="glyphicon glyphicon-resize-horizontal"></label> \
									</button> \
								</div>\
							</div>\
							<div style="display:table-cell;">\
								<button class="btn btn-auth-header" id="s-m-auth-scale-id" type="button" title="{{label_scale_to_fit}}"><label class="glyphicon glyphicon-fullscreen"></button> \
							</div>\
						</div>\
					</div>\
				</div>\
				<div style="display:table-cell;" id="s-m-auth-header-actions-id">\
					<div style="display:table;">\
						<div style="display:table-row;">\
							<button style="display:table-cell;" class="btn btn-auth-header" id="s-m-auth-new-layout-id" type="button"><label class="glyphicon glyphicon-blackboard"></label><span>{{label_new_layout}}</span></button> \
							<button style="display:table-cell;" class="btn btn-auth-header" id="s-m-auth-remove-all-id" type="button"><label class="glyphicon glyphicon-erase"></label><span>{{label_remove_all}}</span></button> \
							<button style="display:table-cell;" class="btn btn-auth-header disabled" id="s-m-auth-remove-id" type="button"><label class="glyphicon glyphicon-trash"></label><span>{{label_remove}}</span></button> \
							<button style="display:table-cell;" class="btn btn-auth-header disabled" id="s-m-auth-remove-cnt-id" type="button"><label class="glyphicon glyphicon-erase"></label><span>{{label_remove_container}}</span></button> \
						</div>\
					</div>\
				</div>\
				<div style="display:table-cell;width:300px;">\
					<button id="auth-btn-undo-id"  class="btn btn-auth-header" type="button"><div class="icon-undo"></label>{{label_undo}}</button> \
					<button id="auth-btn-undo-all-id"  class="btn btn-auth-header" type="button"><div class="icon-undoall"></label>{{label_undo_all}}</button> \
					<button id="auth-btn-close-id" style="float:right;" class="btn btn-danger" type="button"><div class="glyphicon glyphicon-remove"></label></button> \
					<button id="auth-btn-save-id" style="float:right;" class="btn btn-auth-header" type="button"><div class="glyphicon glyphicon-ok"></label></button> \
				</div>\
			</div>\
		</div>',

	authPanelFooter: '\
		<div class="btn-group"> \
		</div>',

	authPanelRightStructure: '\
		<div class="s-m-site-auth-panel-content"> \
			<header id="authPanelControlType">{{label_control}}</header> \
			<p class="form-control-static" id="authPanelControlTitle"> </p> \
			<div id="authPanelControl" class="tab-pane panel-body active"> \
				<div id="authPanelControlSimple"> \
				</div> \
			</div> \
		</div>',

	authPanelLeftStructure: '\
		<div class="s-m-site-auth-panel-content"> \
			<ul class="nav nav-pills" role="tablist"> \
				<li class="active"><a aria-expanded="true" href="#s-m-auth-tree-box" role="tab" data-toggle="tab">{{label_content}}</a></li> \
				<li><a href="#s-m-auth-insert-box" role="tab" data-toggle="tab">{{label_insert}}</a></li> \
			</ul> \
			<div class="tab-content"> \
				<div id="s-m-auth-tree-box" class="tab-pane active"> \
					<ul class="s-m-auth-tree" id="auth-structure-root-id"></ul> \
				</div> \
				<div id="s-m-auth-insert-box" class="tab-pane"> \
					<div class="panel panel-primary s-m-panel-auth-prop"> \
						<div class="panel-heading" role="tab" id="auth-lp-cnt-containers-header"> \
							<a data-toggle="collapse" data-parent="#accordion" href="#auth-lp-cnt-containers-clpse" \
								aria-expanded="true" aria-controls="auth-lp-cnt-containers-clpse" \
								<h4 class="panel-title"> \
									{{label_containers}}\
								</h4> \
							</a> \
						</div> \
						<div id="auth-lp-cnt-containers-clpse" class="panel-collapse collapse in" \
							role="tabpanel" aria-labelledby="auth-lp-cnt-containers-header"> \
							<label>{{lab_drag_to_add}}</label><br> \
							<div class="s-m-auth-btn-container s-m-draggable fa fa-th" data-auth-bind="group" title="{{lab_group}}" data-auth-drag-action="add_layout"></div> \
							<div class="s-m-auth-btn-container s-m-draggable fa fa-square-o" data-auth-bind="tile" title="{{lab_tile}}" data-auth-drag-action="add_layout"></div> \
							<div class="s-m-auth-btn-container s-m-draggable fa fa-bars" data-auth-bind="stack" title="{{lab_stack}}" data-auth-drag-action="add_layout"></div> \
						</div> \
					</div> \
					<div class="panel panel-primary s-m-panel-auth-prop"> \
						<div class="panel-heading" role="tab" id="auth-lp-cnt-props-header"> \
							<a data-toggle="collapse" data-parent="#accordion" href="#auth-lp-cnt-props-clpse" \
								aria-expanded="true" aria-controls="auth-lp-cnt-props-clpse">\
								<h4 class="panel-title"> \
									{{label_fields}}\
								</h4> \
							</a> \
						</div> \
						<div id="auth-lp-cnt-props-clpse" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="auth-lp-cnt-props-header"> \
						</div> \
					</div> \
				</div> \
			</div> \
		</div>',

	authPanelPropertyGroup: ' \
		<div class="panel panel-primary s-m-panel-auth-prop s-m-auth-prop-type-{{type}}"> \
			<div class="panel-heading" role="tab" id="heading_{{id}}"> \
				<a data-toggle="collapse" data-parent="#{{#if parentId}}{{parentId}}{{/if}}{{#unless parentId}}accordion{{/unless}}" href="#collapse_{{id}}" {{#if expanded}} aria-expanded="true"{{/if}} aria-controls="collapse_{{id}}" {{#unless expanded}}class="collapsed"{{/unless}}>\
					<h4 class="panel-title"> \
						{{label}}\
					</h4> \
				</a> \
			</div> \
			<div id="collapse_{{id}}" class="panel-collapse collapse {{#if expanded}}in{{/if}}" role="tabpanel" aria-labelledby="heading_{{id}}"> \
			</div> \
		</div>',
	authPanelPropertySeperator: ' \
		<div class="auth-group-seperator"></div> \
		',

	authPanelPropertyRadio: ' \
		<div class="btn-group" data-toggle="buttons" style="width: 100%;"> \
			{{#each options}} \
				<div class="btn-group" style="width: 100%; display: {{this.display}};" id="{{this.id}}"> \
					<label class="s-m-auth-btn-radio-icon s-m-auth-btn-block" id="{{this.id}}_lab" data-s-m-auth-value="{{this.value}}"> \
						<input type="radio" name="{{group}}" id="{{this.id}}">{{this.label}} \
					</label> \
				</div> \
			{{/each}} \
		</div>',

	authPanelPropertyRadioColor: ' \
		<div class="btn-group" data-toggle="buttons" style="width: 100%;"> \
			{{#each options}} \
				<div class="btn-group"> \
					<label class="auth-btn-color s-m-bg-{{color}}" id="{{this.id}}_lab" data-s-m-auth-value="{{this.value}}"> \
						<input type="radio" name="{{group}}" id="{{this.id}}"> \
					</label> \
				</div> \
			{{/each}} \
		</div>',

	authPanelPropertyRadioIcon: ' \
		<div class="btn-group" data-toggle="buttons" style="width: 100%;"> \
			{{#each options}} \
				<div class="btn-group"> \
					<label class="auth-btn-icon {{icon}}" id="{{this.id}}_lab" data-s-m-auth-value="{{this.value}}"> \
						<input type="radio" name="{{group}}" id="{{this.id}}"> \
					</label> \
				</div> \
			{{/each}} \
		</div>',

	authPanelPropertyCheckbox: ' \
		<div class="btn-group" style="width: 100%;"> \
			{{#each options}} \
				<div class="btn-group" style="width: 100%; display: {{this.display}};" id="{{this.id}}"> \
					<label class="s-m-auth-btn-checkbox-icon s-m-auth-btn-block" id="{{this.id}}_lab" data-s-m-auth-value="{{this.value}}"> \
						<input type="checkbox" id="{{this.id}}" {{#if checked}}checked{{/if}}>{{this.label}} \
					</label> \
				</div> \
			{{/each}} \
		</div>',

	authPanelPropertyInput: ' \
			<div class="form-group"> \
				<input class="form-control" id="{{id}}" value="{{value}}" /> \
			</div>',
	authPanelPropertyInputLocale: ' \
		<div class="form-group"> \
			<input class="form-control" id="{{id}}" value="{{value}}" data-old-value="{{oldValue}}" data-old-uuid="{{oldUUID}}"/> \
		</div>',

	authPanelSliderStep: ' \
		<div class="form-group"> \
			<section style="padding-left:10px;padding-right:10px;">\
				<input id="{{id}}" type="text" data-slider-min="{{min}}" data-slider-max="{{max}}" data-slider-step="{{step}}"  data-slider-value="{{value}}" data-slider-orientation="horizontal" data-slider-tooltip="hide">\
				{{#if displayValue}}<span class="s-m-slider-value">{{#if valText}}{{valText}}{{/if}}{{#unless valText}}{{value}}{{/unless}}</span>{{/if}}\
			</section>\
		</div>',

	authPanelGaugeSlider: '\
		<div class="form-group s-m-auth-g-slider"> \
			<section>\
				<input id="{{id}}" type="text" data-slider-min="{{min}}" data-slider-max="{{max}}" data-slider-step="{{step}}"  data-slider-value="{{value}}" data-slider-orientation="horizontal" data-slider-tooltip="hide" class="s-m-auth-g-range">\
				<span id="{{id}}SliderVal">{{value}}</span>\
			</section>\
		</div>\
	',
	authPanelPropertyCellSize: ' \
		{{#each sizes}} \
			<label class="{{class}} auth-size-device-header" style="width: 100%">{{this.label}}</label> \
			<div class="btn-group" data-toggle="buttons" style="width: 100%;"> \
				{{#each ../values}} \
					<div class="btn-group"> \
						<label class="auth-btn-size-sel" id="{{this.id}}_lab" data-s-m-auth-prop="{{../this.prop}}" data-s-m-auth-value="{{this}}"> \
							<input type="radio" name="{{group}}" id="{{../this.prop}}={{this}}">{{this}} \
						</label> \
					</div> \
				{{/each}} \
			</div> \
		{{/each}}',

	authPanelPropertyJSON: ' \
			<div class="form-group"> \
				<textarea class="form-control" id="{{id}}" rows="10">{{value}}</textarea> \
				<div class="btn-group btn-group-justified" role="group">\
					<a class="btn btn-default" data-action="jsonApply">{{label_apply}}</a> \
					<a class="btn btn-default" data-action="openInNewTab">{{label_display}}</a> \
				</div>\
			</div><div style="clear: both;"></div>',

	authPanelPropertyPROTOTYPE: ' \
			<div class="form-group"> \
				<textarea readonly class="form-control" id="{{id}}" rows="10">{{value}}</textarea> \
			</div>',

	authPanelPropertyGBorderValues: '\
		<div class="form-group">\
			<p class="s-m-auth-g-borders-tip">{{label_tip}}</p>\
			<label>{{label_min}}</label>\
			{{{markupMin}}}\
			<label>{{label_max}}</label>\
			{{{markupMax}}}\
			<button class="btn btn-default btn-block" style="margin-top:5%;">{{label_apply}}</button> \
		</div>\
	',
	authPanelPropertyGSegmentsNumber: '\
		<div class="form-group">\
			{{{value}}} \
			<button class="btn btn-default btn-block" style="margin-top:5%;">{{label_apply}}</button> \
		</div>\
	',
	gaugeBorderInput: '\
		<textarea class="form-control" id={{id}} rows="1">{{value}}</textarea>\
	',
	gaugeSelect: '\
		<select id={{id}} style="color:black;" class="form-control">\
			{{#each options}}\
				<option value="{{option_value}}" {{#if selected}}selected=true{{/if}}>{{option_value}}</option>\
			{{/each}}\
		</select>\
	',
	gaugeSegment: '\
		<div id="{{id}}" class="s-m-auth-seg-slot">\
			<div class="s-m-g-seg-info-block">\
				<div class="s-m-g-seg-label">\
					<label>{{label_valstart}}</label>\
				</div>\
				<div class="s-m-g-seg-value">\
					<input type="text" class="form-control" value="{{value_valstart}}" id="{{id}}-valstart">\
				</div>\
			</div>\
			<div class="s-m-g-seg-info-block">\
				<div class="s-m-g-seg-label">\
					<label>{{label_valend}}</label>\
				</div>\
				<div class="s-m-g-seg-value">\
					<input type="text" class="form-control" value="{{value_valend}}" id="{{id}}-valend">\
				</div>\
			</div>\
			<div class="s-m-g-seg-info-block">\
				<div class="s-m-g-seg-label">\
					<label>{{label_propstart}}</label>\
				</div>\
				<div class="s-m-g-seg-value">\
					{{{value_propstart}}}\
				</div>\
			</div>\
			<div class="s-m-g-seg-info-block">\
				<div class="s-m-g-seg-label">\
					<label>{{label_propend}}</label>\
				</div>\
				<div class="s-m-g-seg-value">\
					{{{value_propend}}}\
				</div>\
			</div>\
			<div class="s-m-g-seg-info-block">\
				<div class="s-m-g-seg-label">\
					<label>{{label_color}}</label>\
				</div>\
				<div class="s-m-g-seg-value">\
					<input type="text" class="form-control" value="{{value_color}}" id="{{id}}-color">\
				</div>\
			</div>\
		</div>\
	',
	authPanelButton: '\
		<div class="s-m-auth-g-apply-slot">\
			<button class="btn btn-default btn-block {{css}}" style="margin-top:5%;">{{label}}</button> \
		</div>\
	'
};

var _compiled = {};

function _getCompiled(name) {
	var c = _compiled[name];
	if (c) {
		return c;
	}

	var t = _templates[name];
	c = Handlebars.compile(t);
	_compiled[name] = c;
	return c;
}

exports.execute = function(name, ctx) {
	var c = _getCompiled(name);
	return c(ctx);
};
});

define('syracuse-tablet/html/js/authoring/authoringVal',['require','exports','module','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/modals/modal'],function (require, exports, module) {

var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');

var _authProperties;

exports.setProperties = function(properties) {
	_authProperties = properties;
};

function getAuthoringPropertiesLayouts() {
	return _authProperties && _authProperties.getPropertiesLayouts();
}
/*
 *
 * Simple article validation module
 *
 */


exports.validateJSON = function(fullPage, jsonText, properties) {
	var obj;
	try {
		if ($.isPlainObject(jsonText)) {
			obj = jsonText;
		} else if (jsonText != null && jsonText.length > 0) {
			obj = JSON.parse(jsonText);
		} else {
			throw new Error("Unexpected bad JSONtext");
		}

		var errors = _validate(fullPage, obj, properties);
		if (errors.length > 0) {
			var text = "\n" + errors.join("\n");
			modal.error(locale.text("auth.panel.save_error_title"), {
				message: locale.text("auth.panel.save_error_json"),
				detail: text
			});
		} else {
			return obj;
		}
	} catch (e) {
		modal.error(locale.text("auth.panel.save_error_title"), {
			message: locale.text("auth.panel.save_error_json"),
			detail: e
		});
	}
};

/*
 * display $items and $article nodes at the end of JSON
 */
exports.toSortedJSON = function(obj) {
	var toJSON = function() {
		var self = this;
		var that = {};
		var $items;
		var $article;
		Object.keys(self).forEach(function(key) {
			if (self.hasOwnProperty(key)) {
				if (key === "$items") {
					$items = self[key];
				} else if (key === "$article") {
					$article = self[key];
				} else if (key === "toJSON") {
					// Do nothing
				} else {
					that[key] = self[key];
				}
			}
		});
		if ($article) {
			that.$article = $article;
		}
		if ($items) {
			that.$items = $items;
		}
		if (self.toJSON) {
			delete self.toJSON;
		}
		if (that.toJSON) {
			delete that.toJSON;
		}
		return that;
	};
	// Step one: Hook property ordering
	JSON.stringify(obj,
		function replacer(key, value) {
			if ($.isPlainObject(value)) {
				value.toJSON = toJSON;
			}
			return value;
		});
	// Build json
	var str = JSON.stringify(obj, null, " ");
	return str;
};

/*
 * fullPage: true = article is an object describing a full page so also nesting constraints can be checked
 * fullPage: false = article is an object describing a control or container so nesting constraints cannot be fully checked
 * article: Article object
 */
function _validate(fullPage, article, properties) {

	var errors = [];
	try {
		_checkNode(fullPage, null, article, properties, errors);
	} catch (e) {
		errors.push("javascriptException - validate\n" + jsutils.cleanStack(e.stack));
	}
	return errors;
};

var _propertiesToCheck = {
	$layoutType: _checkLayoutType,
	$bgColor: _checkBgColor,
	$size: _checkTileSize,
	$widthXs: _checkCellSize,
	$widthSm: _checkCellSize,
	$widthMd: _checkCellSize,
	$widthLg: _checkCellSize
};

function _checkNode(fullPage, parent, node, properties, errors) {

	Object.keys(_propertiesToCheck).some(function(key) {
		if (node[key] !== undefined) {
			_propertiesToCheck[key](fullPage, parent, node, key, properties, errors);
		}
	});

	var children;
	if (node.$items) {
		children = node.$items;
	} else if (node.$article) {
		children = [node.$article];
	}
	if (children) {
		children.forEach(function(child) {
			_checkNode(fullPage, node, child, properties, errors);
		});
	}
}

function _checkLayoutType(fullPage, parent, node, key, properties, errors) {
	var type = node.$layoutType;
	var ptype = parent && parent.$layoutType;
	var known = ["stack", "row", "cell", "hub", "hubGroup", "tile"];
	if (known.indexOf(type) < 0) {
		errors.push(locale.text("auth.err.unknown.layout", [type]));
		return;
	}
	if (!fullPage) {
		return;
	}
	switch (type) {
		case "hub":
			if (parent != null) {
				errors.push(locale.text("auth.err.hub.notroot"));
			}
			break;
		case "hubGroup":
			if (ptype != "hub") {
				errors.push(locale.text("auth.err.hubgroup.nohub"));
			}
			break;
		case "tile":
			if (ptype != "hubGroup") {
				errors.push(locale.text("auth.err.tile.nohubgroup"));
			}
			break;
	}
}

function _checkBgColor(fullPage, parent, node, key, properties, errors) {
	var value = node[key];

	var valid = getAuthoringPropertiesLayouts().properties.tileColor.values.map(function(e) {
		return e.value;
	});
	if (valid.indexOf(value) < 0) {
		errors.push(locale.text("auth.err.bgColor", [key, valid.join(", "), value]));
	}
}

function _checkCellSize(fullPage, parent, node, key, properties, errors) {
	var value = +node[key];
	if (!(value >= 1 && value <= 12)) {
		errors.push(locale.text("auth.err.cellSize", [key, value]));
	}
}

function _checkTileSize(fullPage, parent, node, key, properties, errors) {
	var value = node[key];
	var valid = getAuthoringPropertiesLayouts().properties.tileSize.values.map(function(e) {
		return e.value;
	});

	if (valid.indexOf(value) < 0) {
		errors.push(locale.text("auth.err.tileSize", [valid.join(", "), value]));
	}
}
});

define('syracuse-tablet/html/js/authoring/authoringComponents',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');


var _templates = {
	genericSlider: '\
		<div class="form-group" {{#if margin}}style="margin-bottom:{{margin}}px;"{{/if}}> \
			<section style="padding-left:10px;padding-right:10px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis">\
				<input id="{{id}}" type="text" data-slider-min="{{min}}" data-slider-max="{{max}}" data-slider-step="{{step}}"  data-slider-value="{{value}}" data-slider-orientation="horizontal" data-slider-tooltip="hide">\
				{{#if displayValue}}<p class="s-m-slider-value">{{#if valText}}{{valText}}{{/if}}{{#unless valText}}{{value}}{{/unless}}</p>{{/if}}\
			</section>\
		</div>',
	flatRadio: '\
		<div class="btn-group" style="margin-bottom:10px;" data-toggle="buttons">\
			{{#each btns}}\
				<label class="btn btn-primary">\
					<input type="radio" autocomplete="off" value="{{value}}">\
					{{title}}\
				</label>\
			{{/each}}\
		</div>',
	select: '\
		<div style="position:relative;{{#if margin}}margin-bottom:{{margin}}px;{{/if}}">\
		  <select class="selectpicker {{css}}"  data-width="100%">\
		  	{{#each options}}\
		     	<option value="{{value}}">{{title}}</option>\
			{{/each}}\
		  </select>\
		</div>',
	actionBtns: '\
		<div style="text-align:center;">\
			<div class="btn-group" role="group" style="margin-bottom:10px;">\
				{{#each btns}}\
					<button type="button" class="btn btn-default" value="{{value}}">{{title}}</button>\
				{{/each}}\
			</div>\
		</div>',
	colorPicker: '\
		<input type="text" {{#if id}}id="{{id}}"{{/if}} class="form-control {{css}}""></input>',
	editableList: '\
		<section class = "auth-editableList  {{css}}" {{#if id}}id="{{id}}"{{/if}} >\
			<ul class="list-group auth-editableList"></ul>\
			<div class="authMsg"></div>\
			<div class="btn-group btn-group-justified" role="group">\
				<a type="button" class="btn btn-default authLstAct" data-action="append">\
					<i class="fa fa-plus"></i>\
					<span>{{addTitle}}</span>\
				</a>\
				<a style="display:none" type="button" class="btn btn-default authLstAct" data-action="validate">\
					<i class="fa fa-check"></i>\
					<span>{{validateTitle}}</span>\
				</a>\
				<a style="display:none" type="button" class="btn btn-default authLstAct" data-action="cancel">\
					<i class="fa fa-times"></i>\
					<span>{{cancelTitle}}</span>\
				</a>\
			</div>\
		</section>',
	editableListItem: '\
		<li class="list-group-item {{css}}" data-params="{{id}}">\
			<span>\
				<span>{{#if title}}{{title}}{{/if}}{{#if titleHtml}}{{{titleHtml}}}{{/if}}</span>\
				<span class="fa fa-pencil" data-action="editItem"></span>\
				<span class="fa fa-times" data-action="deleteItem"></span>\
			</span>\
		</li>',
	colorPalettePicker: '\
		<section class="auth-colorPalettePicker {{dropDirection}}">\
			<div class="input-group" data-toggle="dropdown" aria-expanded="false">\
				<span class="form-control auth-paletteColor"></span>\
				<span class="input-group-addon"><div class="fa fa-times"></div></span>\
			</div>\
			<div class="dropdown-menu" style="width: 100%;width: 100%;padding-left: 5px;padding-right: 5px;">\
				<div class="auth-paletteRoot" data-toggle="buttons" style="width: 100%;white-space: normal;" >\
				</div>\
		  	</div>\
		</section>',
	colorPaletteItem: '\
		<div class="auth-paletteItem {{css}}" data-params="{{name}}" data-css="{{css}}">\
		</div>',
	iconPalettePicker: '\
		<section class="auth-iconPalettePicker {{dropDirection}}">\
			<div class="input-group" data-toggle="dropdown" aria-expanded="false">\
				<span class="form-control auth-paletteIcon"></span>\
				<span class="input-group-addon"><div class="fa fa-times"></div></span>\
			</div>\
			<div class="dropdown-menu">\
				<div class="auth-paletteRoot" data-toggle="buttons" style="width: 100%;white-space: normal;" >\
				</div>\
		  	</div>\
		</section>',
	iconPaletteItem: '\
		<div class="auth-paletteItem {{css}}" data-params="{{name}}" data-css="{{css}}">\
		</div>',
	switcher: '\
		 <input {{#if id}}id="{{id}}"{{/if}} type="checkbox">'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};

var _components = {
	"editableList": function(options, name) {
		options = options || {};
		this.options = options;
		this.name = name || "editableList";
		this.createMarkup = function($$parent) {
			this.$$panel = $(_getHtml("editableList", {
				id: options.id,
				css: options.css || "",
				addTitle: options.appendTitle || locale.text("append"),
				validateTitle: options.validateTitle || locale.text("validate"),
				cancelTitle: options.cancelTitle || locale.text("cancel")
			})).appendTo($$parent);
			if (options.isHidden === true) {
				this.hide();
			}
			if (this.options.doAction) {
				this.$$panel.on('click', "[data-action]", jsutils.bindFn(this.onClick, this));
			}
			this.$$list = this.$$panel.find("ul");
			return this.$$panel;
		};
		this.onClick = function(event) {
			var $$target = $(event.target).closest("[data-action]");
			var action = $$target.attr("data-action");
			var id;
			if (action === "append" || action === "cancel") {
				id = "";
			} else if (action === "editItem" || action === "deleteItem") {
				id = $$target.closest("[data-params]").attr("data-params") || "";
			} else if (action === "validate") {
				id = $$target.attr("data-params") || "";
			}
			var done = this.options.doAction(action, id, this);
			if (done == true) {
				if (action === "deleteItem") {
					$$target.closest("li").off().remove();
				} else if (action === "editItem" || action === "append") {
					this.toggleEditStatus(true, id);
				} else if (action === "validate" || action === "cancel") {
					this.toggleEditStatus(false);
				}
			}
		};
		this.insertRecords = function(records) {
			if (!records || !this.$$list) return;
			if ($.isPlainObject(records)) records = [records];
			if (!Array.isArray(records)) return;
			var self = this;
			records.forEach(function(record) {
				if (!record || !record.id) return;
				var $$newRec = $(_getHtml("editableListItem", {
					id: record.id,
					css: record.css || "",
					titleHtml: record.titleHtml,
					title: record.title
				}));
				var $$oldRec = self.$$list.find('[data-params="' + record.id + '"]');
				if ($$oldRec.length > 0) {
					$$oldRec.before($$newRec);
					$$oldRec.remove();
				} else {
					$$newRec.appendTo(self.$$list);
				}
			});
		};
		this.destroyMarkup = function() {
			this.options = null;
			if (this.$$list) {
				this.$$list.off();
				this.$$list = null;
			}
			this.$$panel = null;
		};
		this.clear = function() {
			if (!this.$$list) return;
			this.$$list.find("li").remove();
		};
		this.toggleEditStatus = function(editMode, recordId) {
			if (!this.$$panel) return;
			this.$$panel.find('[data-action="append"]').toggle(editMode !== true);
			this.$$panel.find('[data-action="validate"]').toggle(editMode === true).attr("data-params", editMode === true ? recordId : "");
			this.$$panel.find('[data-action="cancel"]').toggle(editMode === true);
		};
		/**
		 * type info/warning/error
		 */
		this.toggleMessage = function(msgText, type) {
			var $$msg = this.$$panel.find('.authMsg');
			$$msg.empty().removeClass();
			if (msgText && msgText.trim().length > 0) {
				$$msg.text(msgText);
				if (type) {
					$$msg.addClass("s-m-" + type);
				}
			}
			$$msg.addClass("authMsg");
		};
	},
	"colorPicker": function(options, name) {
		options = options || {};
		this.options = options;
		this.name = name || "colorPicker";
		this.createMarkup = function($$parent) {
			this.$$picker = $(_getHtml("colorPicker", {
				id: options.id,
				css: options.css || "",
			})).appendTo($$parent);
			if (options.isHidden === true) {
				this.$$picker.hide();
			}
			this.$$picker.minicolors({
				control: options.control || "hue",
				defaultValue: options.value || '',
				inline: options.inline === true,
				letterCase: options.letterCase || 'lowercase',
				opacity: options.opacity === true,
				position: options.position || 'top left',
				theme: 'bootstrap',
				change: options.onChange ? jsutils.bindFn(this.onChange, this) : null
			});
			this.$$panel = this.$$picker;
			return this.$$panel;
		};
		this.onChange = function(event) {
			this.options.onChange(event, this);
		};
		this.destroyMarkup = function() {
			this.options.onChange = null;
			this.options = null;
			if (this.$$picker) {
				this.$$picker.minicolors('destroy');
				this.$$picker = null;
			}
		};
		this.getValue = function(type) {
			if (!this.$$picker) return;
			var meth;
			if (type === "rgbObject" || type === "rgbString" || type === "rgbaString") {
				meth = type;
			} else {
				meth = "value";
			}
			return this.$$picker.minicolors(meth);
		};
		this.setValue = function(valueHexa) {
			if (!this.$$picker) return;
			return this.$$picker.minicolors("value", valueHexa);
		};
	},
	"colorPalettePicker": function(options, name) {
		options = options || {};
		this.options = options;
		this.name = name || "colorPalettePicker";
		this.createMarkup = function($$parent) {
			var css = options.css || "";
			this.$$panel = $(_getHtml("colorPalettePicker", {
				id: options.id,
				css: css,
				dropDirection: options.dropUp === true ? "dropup" : "dropdown"
			})).appendTo($$parent);
			this.$$rootPalette = this.$$panel.find(".auth-paletteRoot");
			this.$$input = this.$$panel.find(".auth-paletteColor");
			this.$$clearBtn = this.$$panel.find(".input-group-addon").on('click', jsutils.bindFn(this.onClear, this));
			this.$$rootPalette.on('click', '[data-params]', jsutils.bindFn(this.onSelectColor, this));
			if (options.isHidden === true) {
				this.$$panel.hide();
			}
			if (options.palette) {
				this.updatePalette(options.palette);
			}
			this.setValue(options.color);
			return this.$$panel;
		};
		this.updatePalette = function(palette) {
			if (!palette) return;
			var html = [];
			palette.forEach(function(item) {
				if (item.items) {
					if (item.title) {
						html.push('<div class ="authPaletteSection">' + item.title + '</div>');
					}
					item.items.forEach(function(subItem) {
						html.push(_getHtml("colorPaletteItem", subItem));
					});
				} else {
					html.push(_getHtml("colorPaletteItem", item));
				}
			});
			this.$$rootPalette.html(html.join(''));
		};
		this.onClear = function(event) {
			if (!this.$$panel.is(".open")) {
				event.stopPropagation();
				this.setValue(null);
			}
		};
		this.onSelectColor = function(event) {
			var $$t = $(event.target);
			this.setValue({
				name: $$t.attr("data-params"),
				css: $$t.attr("data-css")
			});
		};
		this.destroyMarkup = function() {
			if (this.$$rootPalette) {
				this.$$rootPalette.off();
				this.$$rootPalette = null;
			}
			this.options = null;
			this.$$clearBtn.off();
			this.$$clearBtn = this.$$input = this.$$panel = null;
		};
		this.getValue = function() {
			var $$selected = this.$$panel.find(".auth-paletteItem.current");
			if ($$selected.length == 0) return null;
			// Returns color and background-color in case the caller can't use css
			return {
				css: $$selected.attr("data-css") || "",
				name: $$selected.attr("data-params") || "",
				bgColor: $$selected.css("background-color"),
				color: $$selected.css("color")
			};
		};
		this.setValue = function(color) {
			this.$$panel.find(".auth-paletteItem.current").removeClass("current");
			if (color) {
				this.$$panel.find('[data-params="' + color.name + '"]').addClass("current");
			}
			this.$$input.removeClass().addClass("form-control").text(color ? color.name : locale.text("auth.components.palette.nocolor"));
			if (color) {
				this.$$input.addClass(color.css);
			}
		};
	},
	"iconPalettePicker": function(options, name) {
		options = options || {};
		this.options = options;
		this.name = name || "iconPalettePicker";
		this.createMarkup = function($$parent) {
			var css = options.css || "";
			this.$$panel = $(_getHtml("iconPalettePicker", {
				id: options.id,
				css: css,
				dropDirection: options.dropUp === true ? "dropup" : "dropdown"
			})).appendTo($$parent);
			this.$$rootPalette = this.$$panel.find(".auth-paletteRoot");
			this.$$input = this.$$panel.find(".auth-paletteIcon");
			this.$$clearBtn = this.$$panel.find(".input-group-addon").on('click', jsutils.bindFn(this.onClear, this));
			this.$$rootPalette.on('click', '[data-params]', jsutils.bindFn(this.onSelectIcon, this));
			if (options.isHidden === true) {
				this.$$panel.hide();
			}
			if (options.palette) {
				this.updatePalette(options.palette);
			}
			this.setValue(options.icon);
			return this.$$panel;
		};
		this.updatePalette = function(palette) {
			if (!palette) return;
			var html = [];
			palette.forEach(function(item) {
				html.push(_getHtml("iconPaletteItem", item));
			});
			this.$$rootPalette.html(html.join(''));
		};
		this.onClear = function(event) {
			if (!this.$$panel.is(".open")) {
				event.stopPropagation();
				this.setValue(null);
			}
		};
		this.onSelectIcon = function(event) {
			var $$t = $(event.target);
			var old = this.getValue();
			var value = {
				name: $$t.attr("data-params"),
				css: $$t.attr("data-css")
			};
			if (old && old.name == value.name && old.css == value.css) return;
			this.setValue(value);
			if (this.options.onSelectIcon) {
				this.options.onSelectIcon(value);
			}
		};
		this.destroyMarkup = function() {
			if (this.$$rootPalette) {
				this.$$rootPalette.off();
				this.$$rootPalette = null;
			}
			this.options = null;
			this.$$clearBtn.off();
			this.$$clearBtn = this.$$input = this.$$panel = null;
		};
		this.getValue = function() {
			var $$selected = this.$$panel.find(".auth-paletteItem.current");
			if ($$selected.length == 0) return null;
			return {
				css: $$selected.attr("data-css") || "",
				name: $$selected.attr("data-params") || ""
			};
		};
		this.setValue = function(icon) {
			this.$$panel.find(".auth-paletteItem.current").removeClass("current");
			if (icon) {
				this.$$panel.find('[data-params="' + icon.name + '"]').addClass("current");
			}
			this.$$input.removeClass().addClass("form-control").empty();
			if (icon) {
				this.$$input.html('<div class="iconIcon ' + icon.css + '"></div><div class="iconName">' + icon.name + '</div>');
			} else {
				this.$$input.text(locale.text("auth.components.palette.noicon"));
			}
		};
	},
	"select": function(options, name) {
		if (!options || !options.options || options.options.length === 0 || !options.onChange) return;
		if (options.value == null) {
			options.value = Object.keys(options.options)[0];
		}
		this.name = name || "select";
		this.options = options;
		this.createMarkup = function($$parent) {
			this.$$panel = $(_getHtml("select", {
				options: options.options || [],
				css: options.css || ""
			})).appendTo($$parent);
			this.$$select = this.$$panel.find("select");
			this.$$select.selectpicker();
			this.$$select.selectpicker('val', options.value);
			this.$$select.on('change', jsutils.bindFn(this.onChange, this));
			if (options.isHidden === true) {
				this.$$select.selectpicker('hide');
			}
			return this.$$panel;
		};
		this.onChange = function(event) {
			this.options.onChange(event, this);
		};
		this.destroyMarkup = function() {
			this.options.onChange = null;
			this.options = null;
			if (this.$$select) {
				this.$$select.off();
				this.$$select.selectpicker('destroy');
				this.$$select = null;
			}
		};
		this.getValue = function() {
			if (!this.$$select) return;
			return this.$$select.selectpicker('val');
		};
		this.setValue = function(value) {
			if (!this.$$select) return;
			return this.$$select.selectpicker('val', value);
		};
		this.update = function(selectOpts, defValue) {
			if (!this.$$select) return;
			selectOpts = selectOpts || [];
			this.$$select.find("option").remove();
			var self = this;
			selectOpts.forEach(function(v, idx) {
				self.$$select.append('<option value="' + v.value + '">' + v.title + '</option>');
			});
			if (defValue == null && selectOpts.length > 0) {
				defValue = selectOpts[0].value;
			}
			if (defValue != null) {
				this.$$select.selectpicker('val', defValue);
			}
			this.$$select.selectpicker('refresh');
		};
		this.clear = function() {
			this.update(null);
		};
	},
	"flatRadio": function(options, name) {
		this.name = name || "flatRadio";
		this.options = options;
		this.createMarkup = function($$parent) {
			this.$$panel = $(_getHtml("flatRadio", {
				btns: this.options.btns
			})).appendTo($$parent).on('change', "input", this.options.onClick);
			this.$$panel.find('input[value="' + this.options.value + '"]').parent().button('toggle');
			return this.$$panel;
		};
		this.destroyMarkup = function() {
			this.options.onClick = null;
			this.options = null;
			if (this.$$panel) {
				this.$$panel.off();
				this.$$panel = null;
			}
		};
	},
	"switcher": function(options, name) {
		this.name = name || "switcher";
		this.options = options;
		this.createMarkup = function($$parent) {
			this.$$panel = $(_getHtml("switcher", {
				id: this.options.id
			})).appendTo($$parent);
			this.setValue(this.options.checked);
			this.$$panel.bootstrapSwitch('onText', this.options.onText || locale.text("auth.switcher.onText"));
			this.$$panel.bootstrapSwitch('offText', this.options.offText || locale.text("auth.switcher.offText"));
			this.$$panel.bootstrapSwitch('size', this.options.size || "small");
			this.$$panel.bootstrapSwitch('onColor', this.options.onColor || "default");
			this.$$panel.bootstrapSwitch('offColor', this.options.offColor || "default");
			if (this.options.onSwitchChange) {
				this.$$panel.bootstrapSwitch('onSwitchChange', jsutils.bindFn(this.onSwitchChange, this));
			}
			return this.$$panel;
		};
		this.onSwitchChange = function(event, state) {
			this.options.onSwitchChange(event, state);
		};
		this.destroyMarkup = function() {
			this.options = null;
			if (this.$$panel) {
				this.$$panel.bootstrapSwitch('destroy');
				this.$$panel = null;
			}
		};
		this.getValue = function(value) {
			if (!this.$$panel) return;
			return this.$$panel.bootstrapSwitch('state');
		};
		this.setValue = function(value) {
			if (!this.$$panel) return;
			this.$$panel.bootstrapSwitch('state', value === true, true);
		};
	},
	"actionBtns": function(options, name) {
		this.name = name || "actionBtns";
		this.options = options;
		this.createMarkup = function($$parent) {
			this.$$panel = $(_getHtml("actionBtns", {
				btns: this.options.btns
			})).on('click', this.options.onClick).appendTo($$parent);
			return this.$$panel;
		};
		this.destroyMarkup = function() {
			this.options.onClick = null;
			this.options = null;
			if (this.$$panel) {
				this.$$panel.off();
				this.$$panel = null;
			}
		};
	},
	/**
	 * options.slideHandler(value, this) 	optional - returns the text to display
	 * options.stopHandler(value, this) 	optional
	 * options.startHandler(value, this)	optional
	 *
	 */
	"genericSlider": function(options, name) {
		this.name = name || "genericSlider";
		this.options = options;
		this.label = options.label;
		this.createMarkup = function($$parent) {
			var displayValue = this.options.displayValue || this.options.slideHandler != null;
			this.$$panel = $(_getHtml("genericSlider", {
				value: this.options.value,
				min: this.options.min,
				max: this.options.max,
				step: this.options.step || 1,
				valText: this.options.value != null ? this.options.slideHandler ? this.options.slideHandler(this.options.value, this) : this.options.value : "",
				displayValue: displayValue,
				margin: this.options.margin + ""
			}));
			$$parent.append(this.$$panel);
			this.$$textValue = $(".s-m-slider-value", this.$$panel);
			this.$$slider = $("input", this.$$panel).slider({});
			if (displayValue) {
				this.$$slider.on("slide", jsutils.bindFn(this.onSlider, this, "slide"));
			}
			if (this.options.stopHandler) {
				this.$$slider.on("slideStop", jsutils.bindFn(this.onSlider, this, "stop"));
			}
			if (this.options.startHandler) {
				this.$$slider.on("slideStart", jsutils.bindFn(this.onSlider, this, "start"));
			}
			if (displayValue === "above") {
				this.$$panel.find(".s-m-slider-value").detach().prependTo(this.$$panel.find("section"));
			}

		};

		this.destroyMarkup = function() {
			this.options.startHandler = null;
			this.options.stopHandler = null;
			this.options.slideHandler = null;
			this.options = null;
			if (this.$$slider) {
				this.$$slider.off();
				this.$$slider.slider('destroy');
				this.$$slider = null;
			}
			if (this.$$panel) {
				this.$$panel.remove();
			}
		};

		this.onSlider = function(slideEvt, action) {
			if (action === "start") {
				this.options.startHandler(slideEvt.value, this);
				return;
			}
			if (action === "slide") {
				this.$$textValue.text(this.options.slideHandler ? this.options.slideHandler(slideEvt.value, this) : slideEvt.value);
				return;
			}
			if (action === "stop") {
				if (this.options.value != slideEvt.value) {
					this.options.value = slideEvt.value;
					this.options.stopHandler(slideEvt.value, this);
				}
				return;
			}
		};

		this.update = function(opts) {
			if (!opts) return;
			if (opts.min != null) this.$$slider.slider('setAttribute', 'min', opts.min);
			if (opts.max != null) this.$$slider.slider('setAttribute', 'max', opts.max);
			if (opts.step != null) this.$$slider.slider('setAttribute', 'step', opts.step);
			if (opts.value != null) {
				this.$$slider.slider('setValue', opts.value);
				this.$$textValue.text(this.options.slideHandler ? this.options.slideHandler(opts.value) : opts.value);
			}
		};
	}
};
/**
 * type:	genericSlider, flatRadio, select, actionBtns
 * opts:	depends on component
 * name:	name of property / optional
 */
exports.newComponent = function(type, opts, name) {
	var f = _components[type];
	if (!f) throw new Error("Unknown authoring component [" + type + "]");
	return new f(opts, name);
};
});

define('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral',['require','exports','module','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/authoring/authoringVal','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/authoring/authoringComponents'],function (require, exports, module) {
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var authVal = require('syracuse-tablet/html/js/authoring/authoringVal');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');


var _properties = {
	/*
	 * Dummy to add a separator
	 */
	"SEPARATOR": {
		isSeparatror: true
	},

	/*
	 * Full JSON article of selection for experts
	 */
	"JSON": {
		"key": "$JSON",
		createMarkup: _createMarkupJSON,
		type: "expert"
	},
	/*
	 * Read only display of prototype
	 */
	"PROTOTYPE": {
		"key": "$PROTOYPE",
		createMarkup: _createMarkupPrototype,
		type: "expert"
	},

};


function _createMarkupJSON($$parent, prop, sel, data) {
	// This is only displayed if the full page is selected, so we always show the article of the page and not the article
	// of the selected UI compontent (UI component is always the page)
	var value = authVal.toSortedJSON(data.articlePage);
	var html = authHtml.execute("authPanelPropertyJSON", {
		id: "auth_opt_" + prop.name,
		value: value,
		label_apply: locale.text("auth.panel.label_apply"),
		label_display: locale.text("auth.panel.label_display")
	});
	var $$panel = $(html);
	var title = sel.$$elmt.text();
	var _getJson = function(validate) {
		var val = $("textarea", $$panel).val();
		var articleParsed;
		if (validate) {
			articleParsed = authVal.validateJSON(true, $("textarea", $$panel).val(), _properties);
		} else {
			try {
				articleParsed = JSON.parse(val);
			} catch (e) {
				return jsutils.convertToDiagnoses("Error validating JSON", e);
			}
		}
		return articleParsed ? authVal.toSortedJSON(articleParsed) : null;
	};
	$("a[data-action]", $$panel).click(function() {
		var act = $(this).attr("data-action");
		try {
			if (act === "jsonApply") {
				// Full page article exchange
				var articleString = _getJson(true);
				if (articleString) {
					notifications.publish(["sm.auth.change.prop.ui"], articleString);
				}
			} else if (act === "openInNewTab") {
				var articleString = _getJson(false);
				if (articleString) {
					var myWindow = window.open("about:blank", "sageMobileJsonAuthoring", undefined, true);
					setTimeout(function() {
						var title = globals.getApplication().currentPage.prototype;
						if (title) title = title.data("$title");
						title = title && title.length > 0 ? locale.text("auth.panel.label_page") + ": " + title + "\n" : "";
						myWindow.document.write("<html><body><pre>" + title + locale.text("auth.panel.label_date") + ": " + (new Date()).toLocaleString() + "</pre><pre>" + articleString + "</pre></body></html>");
					});
				}
			}
		} catch (e) {
			console.log(e.stack);
			throw (e);
		}
	});
	$$parent.append($$panel);
}

function _createMarkupPrototype($$parent, prop, sel, data) {
	var value = data.control && data.control.prototype && data.control.prototype.json;
	if (value) {
		value = JSON.stringify(value, null, " ");
	} else {
		value = locale.text("auth.PROTOTYPE_NONE");
	}
	var html = authHtml.execute("authPanelPropertyPROTOTYPE", {
		id: "auth_opt_" + prop.name,
		value: value
	});
	var $$panel = $(html);
	$$parent.append($$panel);
	//	$$parent.append($('<button type="button" class="btn btn-default">title</button>'));
}

var _initProperty = function(p) {
	var pre = "auth";
	var lk = pre + "." + p.name;
	if (p.label == null) {
		p.label = locale.text(lk);
	}
	if (p.values) {
		p.values.forEach(function(v, idx) {
			if ($.isPlainObject(v)) {
				var vk = lk + "." + ("" + ((v.value != null ? v.value : v.key)));
				if (v.label == null) {
					v.label = locale.text(vk);
				}
			} else {
				p.values[idx] = {
					label: v + "",
					valu: v
				};
			}
		});
	}
};
var _initProperties = function(properties, dest) {
	var pre = "auth";
	Object.keys(properties).forEach(function(prop) {
		var p = properties[prop];
		if (dest) {
			dest[prop] = p;
		}
		if (typeof p === "function") {
			return;
		}
		p.name = prop;
		_initProperty(p);
	});
};

var _err = function(title, ee) {
	modal.error(title, ee);
	return true;
};

function _getValueOrDefault(prop, sel, data) {
	var value = data.articleSelection && data.articleSelection[prop.key];
	value = (value != null) ? value : prop["default"];
	return value;
}

function _setValue(prop, sel, data, value) {
	data.articleSelection[prop.key] = value;

	// To flag control that has been changed
	data.articleSelection["$isDirty"] = data.articleSelection["$isDirty"] || {};
	data.articleSelection["$isDirty"][prop.key] = true;
}

function _notifyChangePropUI($$parent, sel, data) {
	var $$json = $("textarea#auth_opt_JSON");
	$$json.val(authVal.toSortedJSON(data.articleSelection));
	notifications.publish(["sm.auth.change.item.prop.ui"], data);
}

function _createMarkupRadio($$parent, prop, sel, data) {

	var ctx = {
		group: "auth_opt_" + prop.name,
		options: []
	};

	var value = _getValueOrDefault(prop, sel, data);
	var allHidden = true;

	prop.values.forEach(function(v) {
		ctx.options.push({
			id: ctx.group + "_" + v.value,
			value: "" + v.value,
			label: v.label,
			display: (v.isHidden ? "none" : "block")
		});
		allHidden = allHidden && v.isHidden;
	});

	var html = authHtml.execute("authPanelPropertyRadio", ctx);
	var $$panel = $(html);
	$("label[data-s-m-auth-value='" + ("" + value) + "']", $$panel).eq(0).button("toggle");
	$("label", $$panel).on("click", function(e) {
		var $$ct = $(e.currentTarget);
		var value = $$ct.attr("data-s-m-auth-value");
		$$ct.eq(0).button("toggle");

		/*
		 * Important! Use boolean datatype for boolean properties!
		 */
		if (value === "true") {
			value = true;
		} else if (value === "false") {
			value = false;
		}
		_setValue(prop, sel, data, value);
		_notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);

	if (allHidden) {
		$$parent.parent(".s-m-panel-auth-prop").hide();
	} else {
		$$parent.parent(".s-m-panel-auth-prop").show();
	}
}

function _refreshMarkupRadio($$parent, prop, sel, data) {
	var allHidden = true;
	prop.values.forEach(function(v) {
		var id = "auth_opt_" + prop.name + "_" + v.value;
		var $$btn = $("#" + id, $$parent);
		var display = v.isHidden ? "none" : "block";
		$$btn.css("display", display);
		allHidden = allHidden && v.isHidden;
	});
	if (allHidden) {
		$$parent.parent(".s-m-panel-auth-prop").hide();
	} else {
		$$parent.parent(".s-m-panel-auth-prop").show();
	}
}

function _createMarkupCheckboxes($$parent, prop, sel, data) {

	var ctx = {
		group: "auth_opt_" + prop.name,
		options: []
	};

	var allHidden = true;

	var value = data.articleSelection && data.articleSelection[prop.key] || {};
	prop.values.forEach(function(v) {
		var cb = value[v.key] != null ? value[v.key] : v["default"];
		ctx.options.push({
			id: ctx.group + "_" + v.key,
			value: v.key,
			label: v.label,
			checked: cb,
			display: (v.isHidden ? "none" : "block")
		});
		allHidden = allHidden && v.isHidden;
	});

	var html = authHtml.execute("authPanelPropertyCheckbox", ctx);
	var $$panel = $(html);

	$("label", $$panel).on("click", function(e) {
		var $$ct = $(e.currentTarget);
		var key = $$ct.attr("data-s-m-auth-value");
		var value = $("input:checked", $$ct).length > 0;

		var v = data.articleSelection[prop.key] = data.articleSelection[prop.key] || {};
		v[key] = value;
		_notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);

	if (allHidden) {
		$$parent.parent(".s-m-panel-auth-prop").hide();
	} else {
		$$parent.parent(".s-m-panel-auth-prop").show();
	}
}

function _refreshMarkupCheckboxes($$parent, prop, sel, data) {
	var allHidden = true;
	prop.values.forEach(function(v) {
		var id = "auth_opt_" + prop.name + "_" + v.key;
		var $$btn = $("#" + id, $$parent);
		var display = v.isHidden ? "none" : "block";
		$$btn.css("display", display);
		allHidden = allHidden && v.isHidden;
	});
	if (allHidden) {
		$$parent.parent(".s-m-panel-auth-prop").hide();
	} else {
		$$parent.parent(".s-m-panel-auth-prop").show();
	}
}

function _createMarkupIconPicker($$parent, prop, sel, data) {
	var value = data.articleSelection && data.articleSelection[prop.key] || null;
	var opts = {
		palette: prop["values"] || [],
		dropUp: prop["dropUp"] || true,
		onSelectIcon: function(value) {
			_setValue(prop, sel, data, value);
			_notifyChangePropUI($$parent, sel, data);
		}
	};
	prop._paletteIcon = authComponents.newComponent("iconPalettePicker", opts);
	prop._paletteIcon.createMarkup($$parent);
	prop._paletteIcon.setValue(data.articleSelection[prop.key] || prop["default"]);
}

function _destroyMarkupIconPicker($$parent, prop, sel, data) {
	if (prop._paletteIcon) {
		prop._paletteIcon.destroyMarkup();
		prop._paletteIcon = null;
	}
}

exports.properties = _properties;
exports.err = _err;
exports.createMarkupIconPicker = _createMarkupIconPicker;
exports.destroyMarkupIconPicker = _destroyMarkupIconPicker;
exports.createMarkupRadio = _createMarkupRadio;
exports.refreshMarkupRadio = _refreshMarkupRadio;
exports.createMarkupCheckboxes = _createMarkupCheckboxes;
exports.refreshMarkupCheckboxes = _refreshMarkupCheckboxes;
exports.getValueOrDefault = _getValueOrDefault;
exports.setValue = _setValue;
exports.notifyChangePropUI = _notifyChangePropUI;
exports.initProperties = _initProperties;
exports.initProperty = _initProperty;
exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	// Always add JSON editting and proto display
	props.push(_properties.SEPARATOR);
	if ($$elmt.hasClass("s-m-page")) {
		props.push(_properties.JSON);
	}
	if (data && data.control && data.control.prototype) {
		props.push(_properties.PROTOTYPE);
	}
};
exports.initModuleProperties = function(dest) {
	exports.initProperties(_properties, dest);
};
});

define('syracuse-tablet/html/js/authoring/arrays/authArrayGeneral',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _templates = {
	subtitle: '\
		<section {{#if id}}id="{{id}}"{{/if}} style="{{#if notHidden}}overflow:hidden;{{/if}}white-space:nowrap;text-overflow:ellipsis;{{#if margin}}margin-bottom:{{margin}}px;{{/if}}">\
			{{#if title}}<p>{{title}}</p>{{/if}}\
			<div></div>\
		</section>',
	subPropTitle: ' \
		<div class="panel panel-primary s-m-panel-auth-prop s-m-auth-prop-type-{{type}}"> \
			<div style="overflow:hidden;" class="panel-heading" role="tab" id="heading_{{id}}"> \
				<a style="width:100%;display:table;" data-toggle="collapse" data-parent="#{{#if parentId}}{{parentId}}{{/if}}{{#unless parentId}}accordion{{/unless}}" href="#collapse_{{id}}" {{#if expanded}} aria-expanded="true"{{/if}} aria-controls="collapse_{{id}}" {{#unless expanded}}class="collapsed"{{/unless}}>\
					<div style="display:table-row;white-space: nowrap;">\
						<h4 class="panel-title" style="display:table-cell;"> \
							{{label}}\
						</h4> \
						{{#if info}}<span style="padding-left: 10px;font-size:x-small;display:table-cell;text-align: right;"><i>{{info}}</i></span>{{/if}}\
					</div>\
				</a> \
			</div> \
			<div id="collapse_{{id}}" class="panel-collapse collapse {{#if expanded}}in{{/if}}" role="tabpanel" aria-labelledby="heading_{{id}}"> \
			</div> \
		</div>',
	statusLine: '\
		<span style="display:table;table-layout:fixed;width:100%">\
			<span style="display:table-row;">\
				<span style="display:table-cell;overflow:hidden;text-overflow:ellipsis;white-space: nowrap;">{{field}} {{operator}} {{value}}</span>\
				<span class="{{css}}" style="{{style}}display:table-cell;width:{{sizeColor}}px;height:{{sizeColor}}px;margin-right:5px;"></span>\
			</span>\
		</span>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};

var _properties = {

	"arrayDisplay": {
		"key": "$display",
		"default": "table",
		values: [{
			value: "table"
		}, {
			value: "card"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio
	},

	// only query array
	"arrayProtoFilters": function(controller, sel, data) {
		this.name = "arrayProtoFilters";
		this.label = null;
		this.key = "$filters";
		// No filters displayed by default for vignette
		this["default"] = controller.isVignette ? "none" : "list";
		this.values = [{
			value: "list"
		}, {
			value: "tabs"
		}, {
			value: "none"
		}];
		this.createMarkup = authPropsGeneral.createMarkupRadio;
		this.refreshMarkup = authPropsGeneral.refreshMarkupRadio;
	},

	// only query array - link to details values are created dynamically
	"arrayQueryLink": function(controller, sel, data) {
		this.name = "arrayQueryLink";
		this.label = null;
		this.isHidden = true;
		this.values = [];
		this.key = "$detailsLink";
		this["default"] = "$details";
		this.createMarkup = authPropsGeneral.createMarkupRadio;
		this.refreshMarkup = authPropsGeneral.refreshMarkupRadio;

		this.initMarkup = function(controller, sel, data) {
			var links = data.control.prototype.getDataByPath("$item.$links");
			if (!links || links.length === 0) return;
			if (controller.isVignette) {
				// Add the capability to open query full page - Default option
				this["default"] = "$queryfullpage";
				this.values.push({
					value: "$queryfullpage",
					label: locale.text("auth.arrayQueryLink.queryfullpage")
				});
			}
			var self = this;
			// Add $links
			$.each(links, function(key, link) {
				if (link && link.$method === "GET") {
					self.values.push({
						value: key,
						label: link.$title ? controller.prototype.resolveExpression(link.$title) + " - " + key : key
					});
				}
			});
			this.isHidden = (this.values.length === 1 && this.values[0].value === "$details");
		};
	},

	// Options of array
	"arrayOptions": function(controller, sel, data) {
		this.name = "arrayOptions";
		this.label = null;
		this.key = "$arrayOptions";
		if (!data.control.isArrayField()) {
			this.values = [{
				"key": "showPagination",
				"default": controller.isVignette ? false : true
			}, {
				"key": "showSortFilter",
				"default": controller.isVignette ? false : true
			}, {
				"key": "showSearch",
				"default": controller.isVignette ? false : true
			}];
		} else {
			this.values = [];
		}
		this.values.push({
			"key": "rowIndex",
			"default": exports.checkDisplay(sel, data, "card")
		});
		this.createMarkup = authPropsGeneral.createMarkupCheckboxes;
		this.refreshMarkup = authPropsGeneral.refreshMarkupCheckboxes;
	}
};

exports.getHtml = _getHtml;

exports.checkDisplay = function(sel, data, display) {
	return display === authPropsGeneral.getValueOrDefault(_properties.arrayDisplay, sel, data);
};

exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	if (!data.control.prototype.isSingleArray()) {
		// Force table for single array
		props.push(_properties.arrayDisplay);
	}
	props.push(_properties.arrayOptions);
	if (!data.control.isArrayField() && controller.$filtersGet() && controller.$filtersGet().length > 1) {
		props.push(_properties.arrayProtoFilters);
	}
	if (controller.prototype.isQuery()) {
		props.push(_properties.arrayQueryLink);
	}
};
});

define('syracuse-tablet/html/js/ui/fontUtils',['require','exports','module'],function (require, exports, module) {
var _paginBtns = {
	"$first": "glyphicon glyphicon-step-backward",
	"$previous": "glyphicon glyphicon-chevron-left",
	"$next": "glyphicon glyphicon-chevron-right",
	"$last": "glyphicon glyphicon-step-forward",
	"$more": "glyphicon glyphicon-refresh"
};

var _tileIcons = [
	'adjust',
	'adn',
	'ambulance',
	'anchor',
	'android',
	'angellist',
	'apple',
	'archive',
	'asterisk',
	'automobile',
	'ban',
	'bank',
	'barcode',
	'bell',
	'bicycle',
	'binoculars',
	'bitbucket',
	'bolt',
	'book',
	'bookmark',
	'briefcase',
	'building',
	'bullhorn',
	'bullseye',
	'calculator',
	'calendar',
	'camera',
	'certificate',
	'chain',
	'child',
	'circle',
	'clipboard',
	'codepen',
	'cog',
	'cogs',
	'columns',
	'compass',
	'dashboard',
	'database',
	'envelope',
	'exclamation',
	'eye',
	'fax',
	'file',
	'flag',
	'flash',
	'folder',
	'globe',
	'heart',
	'home',
	'image',
	'inbox',
	'info',
	'institution',
	'key',
	'laptop',
	'leaf',
	'legal',
	'lock',
	'magic',
	'money',
	'paperclip',
	'phone',
	'plane',
	'rocket',
	'search',
	'shield',
	'sitemap',
	'sliders',
	'star',
	'steam',
	'stethoscope',
	'stop',
	'suitcase',
	'th',
	'tumblr',
	'twitch',
	'twitter',
	'umbrella',
	'warning',
	'wrench'
];

var _getIconByName = function(name) {
	switch (name) {
		case "$multiSelection":
			return "glyphicon glyphicon-list-alt";
		case "$cancelMultiSel":
		case "$cancelEdit":
			return "fa fa-undo";
		case "$edit":
			return "fa fa-pencil-square-o";
		case "$query":
			return "fa fa-list";
		case "$save":
			return "fa fa-floppy-o";
		case "$details":
			return "fa fa-level-down";
		case "$delete":
			return "fa fa-trash-o";
		case "$create":
			return "fa fa-plus-square";
			break;
	}
	// Icon names used for tiles or tile headers
	if (_tileIcons.indexOf(name) > -1) {
		return "fa fa-" + name;
	}

	return "";
};

exports.getIconByName = _getIconByName;
exports.checkBoxIcon = function(val) {
	return ["glyphicon", val ? "glyphicon-ok" : "glyphicon-remove"];
};
exports.dateFieldIcon = function($type) {
	return $type.indexOf("date") != -1 ? ["glyphicon", "glyphicon-calendar"] : ["glyphicon", "glyphicon-time"];
};
exports.refFieldIcon = function() {
	return ["glyphicon", "glyphicon-eye-open"];
};
// s-m-img/s-m-binary - icon: default
exports.binaryIcon = function(type, icon) {
	if (type === "s-m-img") {
		return "glyphicon " + (icon === "default" ? "glyphicon-picture" : "");
	}
	if (type === "s-m-binary") {
		return "glyphicon " + (icon === "default" ? "glyphicon-file" : "");
	}
	return "";
};
exports.paginationIcon = function(linkName) {
	return _paginBtns[linkName];
};
exports.pageIcon = function(name) {
	if (name === "settings") return "fa fa-gear";
	if (name === "clearCache") return "fa fa-history";
	if (name === "switchContext") return "fa fa-user";
	if (name === "search") return "fa fa-search";
	if (name === "sidePanelL") return "fa fa-caret-square-o-left";
	if (name === "sidePanelR") return "fa fa-angle-double-right";
	//if (name === "sidePanelR") return "fa fa-caret-square-o-right";
	if (name === "home") return "fa fa-home";
	if (name === "designPage") return "fa fa-paint-brush";
	if (name === "back") return "fa fa-arrow-circle-o-left";
	if (name === "developmentPage") return "fa fa-wrench";
	if (name === "bars") return "fa fa-bars";
	if (name === "backIphone") return "fa fa-angle-left";
	if (name === "about") return "fa fa-info-circle";
	if (name === "logout") return "fa fa-sign-out";
	if (name === "pinPage_1") return "fa fa-thumb-tack";
	if (name === "pinPage_2") return "fa fa-times";
	if (name === "pageConfig") return "fa fa-gear";
};
exports.ctrlIcon = function(name) {
	if (name === "editrow") return "fa fa-pencil-square-o";
	if (name === "detailrow") return "fa fa-hand-o-right";
	if (name === "delrow") return "fa fa-remove";
	if (name === "addrow") return "fa fa-plus";
};
exports.vignetteIcons = function(name) {
	if (name === "home") return "fa fa-home";
	if (name === "back") return "fa fa fa-arrow-circle-o-left";
	if (name === "refresh") return "fa fa-history";
};

exports.sortIcon = function(name) {
	if (name === "asc") return "fa fa-long-arrow-up";
	if (name === "none") return "fa fa-times";
	if (name === "desc") return "fa fa-long-arrow-down";
};

exports.filterIcon = function(name) {
	if (name === "panel") return "fa fa-bars";
	if (name === "filtered") return "fa fa-filter";
	if (name === "edit") return "fa fa-pencil";
	if (name === "delete") return "fa fa-times";
};

/* 
 * List of icon names that can be selected by tile customisation
 * These are only the FA icons that look appropriate
 */
exports.getTileIconList = function() {
	return _tileIcons;
};
var _arrayStatusIconNames = ["thumbs-down", "thumbs-o-down", "thumbs-up", "thumbs-o-up", "hand-o-down", "hand-o-up", "lock", "unlock", "unlock-alt", "smile-o", "meh-o", "check", "check-circle", "check-circle-o", "check-square", "check-square-o", "circle", "circle-thin", "circle-o", "close", "comment", "comment-o", "comments", "comments-o", "photo", "film", "barcode", "bars", "plus", "plus-circle", "plus-square", "plus-square-o", "minus", "minus-circle", "minus-square", "minus-square-o", "question", "question-circle", "trash", "trash-o", "info", "info-circle", "flag", "flag-checkered", "flag-o", "female", "male", "mars", "venus", "user", "users", "user-plus", "user-times", "user-secret", "facebook-official", "file", "file-o", "dollar", "eur", "gbp", "yen", "rub", "rupee", "shekel", "cny", "ils", "inr", "krw", "money", "turkish-lira", "won"];
var _arrayStatusIcons = null;
exports.getArrayStatusIconList = function() {
	if (_arrayStatusIcons == null) {
		_arrayStatusIcons = [];
		_arrayStatusIconNames.forEach(function(name) {
			_arrayStatusIcons.push({
				css: "fa fa-" + name,
				name: name
			});
		});
	}
	return _arrayStatusIcons;
};
exports.getArrayStatusDefIcon = function() {
	return {
		name: "circle",
		css: "fa fa-circle"
	};
};
var _emptyImageIconNames = ["image", "user", "users", "warning", "file-movie-o", "file-image-o", "paperclip", "film"];
var _emptyImageIcons = null;
exports.getEmptyImageIconList = function() {
	if (_emptyImageIcons == null) {
		_emptyImageIcons = [];
		_emptyImageIconNames.forEach(function(name) {
			_emptyImageIcons.push({
				css: "fa fa-" + name,
				name: name
			});
		});
	}
	return _emptyImageIcons;
};
exports.getEmptyImageDefIcon = function() {
	return {
		name: "image",
		css: "fa fa-image"
	};
};
exports.getEmptyFileDefIcon = function() {
	return {
		name: "file",
		css: "fa fa-file"
	};
};

var _urlIconNames = ["globe", "map-marker", "street-view", "road", "link", "cloud", "database", "bed", "cutlery", "glass", "train", "subway", "taxi", "ship", "plane"];
var _urlIcons = null;
exports.getUrlIconList = function() {
	if (_urlIcons == null) {
		_urlIcons = [];
		_urlIconNames.forEach(function(name) {
			_urlIcons.push({
				css: "fa fa-" + name,
				name: name
			});
		});
	}
	return _urlIcons;
};
exports.getUrlDefIcon = function() {
	return {
		name: "Url",
		css: "fa fa-globe"
	};
};
var _colImageIconNames = ["image", "user", "users", "warning", "file-movie-o", "file-image-o", "paperclip", "film"];
var _colImageIcons = null;
exports.getColImageIconList = function() {
	if (_colImageIcons == null) {
		_colImageIcons = [];
		_colImageIconNames.forEach(function(name) {
			_colImageIcons.push({
				css: "fa fa-" + name,
				name: name
			});
		});
	}
	return _colImageIcons;
};
exports.getColImageDefIcon = function(emptyImage) {
	return {
		name: "image",
		css: emptyImage === true ? "fa fa-times" : "fa fa-image"
	};
};
exports.getPinVignetteIcon = function(what) {
	return what == "all" ? "fa fa-toggle-on fa-toggle-off" : what == "on" ? "fa fa-toggle-on" : "fa fa-toggle-off";
};
});

define('syracuse-tablet/html/js/authoring/arrays/authArrayTable',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/arrays/authArrayGeneral','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authArrayGeneral = require('syracuse-tablet/html/js/authoring/arrays/authArrayGeneral');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _maxCharWidth = 50;
var _defCharWidth = 20;
var _defPercentWidth = 20;
var _tableConfigKeys = ["$bind", "$title", "$type", "$titleOrig", "$widthType", "$widthVal", "$refDescFormat", "$refDescPosition", "$imgIcon", "$imgDisplayIcon"];

/**
 * Panel which displays the settings of a columns
 * 	FIELD - WIDTH - X-REFERENCE params
 */
var _TableColumnPanel = function(parent, colInfo) {
	this.name = "arrayTableColumn";
	this.label = colInfo.$title || colInfo.$bind;
	this.parent = parent;
	this.colInfo = colInfo;
	if (parent.isSingleArray || !this.colInfo.$widthType) {
		this.colInfo.$widthType = "auto";
	}
	this._myProperties = [];

	this.createMarkup = function($$parent) {
		this.$$parent = $$parent;
		if (!parent.isSingleArray) {
			this.colNameChoiceAdd();
			this.colWidthTypeAdd();
			this.colWidthValAdd();
		}
		this.colXrefAdd();
		this.colImageAdd();
	};

	this._add2PropHeading = function(title, prop, $$forceParent) {
		var $$root = $(authArrayGeneral.getHtml('subtitle', {
			title: title,
			margin: 10,
			id: prop.name
		})).appendTo($$forceParent || this.$$parent).find("div");
		if (prop.name === "selectName") {
			$$root.css({
				textOverflow: "inherit"
			});
		}
		if (prop.createMarkup) {
			prop.createMarkup($$root);
			this._myProperties.push(prop);
		} else if (prop.jquery) {
			$$root.append(prop);
		}
		return prop;
	};
	// COL NAME CHOICE
	this.colNameChoiceAdd = function() {
		var idx = this.parent.getFieldProto(this.colInfo.$bind).idx;
		var selectOpts = [];
		this.parent._protoValue.forEach(function(v) {
			selectOpts.push({
				title: v.$title,
				value: v.$bind
			});
		});
		var opts = {
			value: this.colInfo.$bind,
			options: selectOpts,
			onChange: jsutils.bindFn(this.colNameSelect, this),
		};
		this._add2PropHeading(locale.text('auth.tableDesign.selColName'), authComponents.newComponent("select", opts, "selectName"));
	};
	this.colNameSelect = function(event, prop) {
		this.colInfo = this.parent.getFieldProto($(event.target).val()).value;
		var $$title = prop.$$panel.closest(".panel-primary").find(".panel-title");
		$$title.text(this.colInfo.$title);
		$$title.next("span").find("i").text(this.colInfo ? this.colInfo.$bind : "");
		this.$$xrefroot.toggle(this.colInfo.$type === "application/x-reference");
		this.$$imageroot.toggle(this.colInfo.$type === "image");
	};
	// COL TYPE WIDTH	
	this.colWidthTypeAdd = function() {
		this._add2PropHeading(locale.text("auth.tableDesign.width"), authComponents.newComponent("flatRadio", {
			btns: [{
				value: "auto",
				title: locale.text("auth.tableDesign.auto")
			}, {
				value: "fixed",
				title: locale.text("auth.tableDesign.fixed")
			}, {
				value: "percent",
				title: "%"
			}],
			onClick: jsutils.bindFn(this.colWidthTypeChanged, this),
			value: this.colInfo.$widthType || "auto"
		}));
	};
	this.colWidthTypeChanged = function(evt) {
		if ($(evt.target).val() !== this.colInfo.$widthType) {
			this.colInfo.$widthType = $(evt.target).val();
			this.colWidthValUpdt();
		}
	};
	// COL VALUE	
	this.colWidthValAdd = function() {
		var opts = {
			slideHandler: jsutils.bindFn(this.colWidthValSlide, this),
			stopHandler: jsutils.bindFn(this.colWidthValChange, this),
			value: this.colInfo.$widthVal || 0,
			min: 0,
			max: this.colInfo.$widthType === "percent" ? 100 : _maxCharWidth,
			margin: 0
		};
		this.propWidthVal = this._add2PropHeading(locale.text("auth.tableDesign.selWidth"), authComponents.newComponent("genericSlider", opts));
		this.colWidthValUpdt(opts.value);
	};
	this.colWidthValSlide = function(val, prop) {
		return this.colInfo.$widthType === "percent" ? val + "%" : val + " " + locale.text("auth.tableDesign.characters");
	};
	this.colWidthValChange = function(val, prop) {
		this.colInfo.$widthVal = val;
	};
	this.colWidthValUpdt = function(forceValue) {
		var show = this.colInfo.$widthType !== "auto";
		this._toggleProp(this.propWidthVal, show);
		if (!show) {
			return;
		}
		this.propWidthVal.update({
			value: forceValue || (this.colInfo.$widthType === "percent" ? _defPercentWidth : _defCharWidth),
			max: this.colInfo.$widthType === "percent" ? 100 : _maxCharWidth,
		});
	};
	// COL X-REFERENCE
	this.colXrefAdd = function() {
		var style = this.colInfo.$type !== "application/x-reference" ? "display:none" : "";
		this.$$xrefroot = $('<section class="xrefColumn" style="' + style + '" ></section>').appendTo(this.$$parent);
		// Description format - $refDescPosition, $refDescFormat are x-reference properties
		// First
		var pos = this.colInfo["$refDescPosition"] || "none";
		this._xrefDescrPos = this._createXRefSelect("pos", ["bottom", "right", "left", "top", "none"], pos);
		// Second
		this._xrefDescrFmt = this._createXRefSelect("fmt", ["desc", "title", "desctitle", "titledesc"], this.colInfo["$refDescFormat"] || "desc");
		// hide fmt if pos == none
		this.$$xrefroot.find("#selectDescrfmt").toggle(pos !== "none");
	};
	this._createXRefSelect = function(type, codes, def) {
		var selectOpts = [];
		var defIdx = codes.indexOf(def);
		if (defIdx == -1) defIdx = 0;
		var textRoot = "auth." + (type == "fmt" ? "refDescFormat" : "refDescPosition");
		codes.forEach(function(code, idx) {
			selectOpts.push({
				// Used by colXrefChange
				code: code,
				title: locale.text(textRoot + "." + code),
				value: idx
			});
		});
		var opts = {
			value: defIdx,
			options: selectOpts,
			onChange: jsutils.bindFn(this.colXrefChange, this, type)
		};
		this._add2PropHeading(locale.text(textRoot), authComponents.newComponent("select", opts, "selectDescr" + type), this.$$xrefroot);
		return selectOpts;
	},
	this.colXrefChange = function(event, prop, type) {
		var idx = parseInt($(event.target).val(), 10);
		var ref = type === "fmt" ? this._xrefDescrFmt : this._xrefDescrPos;
		ref = ref[idx].code;
		if (type == "pos") {
			// hide fmt if pos == none
			this.$$xrefroot.find("#selectDescrfmt").toggle(ref !== "none");
		}
		this.colInfo["$refDesc" + (type === "fmt" ? "Format" : "Position")] = ref;
	};
	// COL IMAGE
	this.colImageAdd = function() {
		var style = this.colInfo.$type !== "image" ? "display:none" : "";
		this.$$imageroot = $('<section class="ximageColumn" style="' + style + '" ></section>').appendTo(this.$$parent);
		// Switch
		var displayIcon = this.colInfo["$imgDisplayIcon"] === true;
		var opts = {
			checked: displayIcon,
			size: "small",
			onSwitchChange: this.onImgDisplayIconChanged.bind(this)
		};
		this._add2PropHeading(locale.text("auth.imgcol.displayIcon"), authComponents.newComponent("switcher", opts), this.$$imageroot);
		// Icon
		opts = {
			palette: fontUtils.getColImageIconList(),
			dropUp: true,
			icon: this.colInfo["$imgIcon"] || fontUtils.getColImageDefIcon(),
			onSelectIcon: this.onImgIconChanged.bind(this)
		};
		this.propImageIcon = this._add2PropHeading(locale.text("auth.imgcol.iconPicker"), authComponents.newComponent("iconPalettePicker", opts), this.$$imageroot);
		this._toggleProp(this.propImageIcon, displayIcon);
	};
	this.onImgIconChanged = function(icon) {
		this.colInfo["$imgIcon"] = icon;
	};
	this.onImgDisplayIconChanged = function(event, status) {
		this.colInfo["$imgDisplayIcon"] = status;
		this._toggleProp(this.propImageIcon, status);
	};
	this._toggleProp = function(prop, show) {
		return prop.$$panel.closest("section").toggle(show);
	};
	this.destroyMarkup = function() {
		this.parent = null;
		this.colInfo = null;
		// Before
		if (this._myProperties) {
			this._myProperties.forEach(function(p) {
				if (p.destroyMarkup) p.destroyMarkup();
			});
			this._myProperties = null;
		}
		// After
		if (this.$$parent) {
			this.$$parent.closest(".s-m-panel-auth-prop").remove();
			this.$$parent = null;
		}
	};
};
/**
 * General properties for 'table' array
 */
var _properties = {
	// Header of the table
	"arrayTableHeader": {
		"key": "$tableHeaderShow",
		"default": true,
		values: [{
			value: true
		}, {
			value: false
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio
	},

	// Design of columns
	// 		Number of columns
	//		Parameters of each column
	"arrayTableDesign": function(controller, sel, data) {
		this.isHidden = false;
		this.name = "arrayTableDesign";
		this.label = null;
		this.key = "$table";
		this.controller = controller;
		this.ctrlArray = data.control;
		this._generalProperties = [];
		this._columnProperties = [];
		this._protoValue = [];

		this.initMarkup = function(controller, sel, data) {
			this._protoValue = this.ctrlArray.prototype.arrayTableGetColInfo();
			this.isSingleArray = this.ctrlArray.prototype.isSingleArray() || this._protoValue.length <= 1;
			this._orginalValue = data.articleSelection.$table;
			var hasValue = this._orginalValue != null && this._orginalValue.length > 0;
			if (!hasValue) {
				this._orginalValue = null;
			}
			this._initProps(hasValue ? this._orginalValue : this._protoValue);
			if (!this.isSingleArray) {
				this.addPropNbColumns();
			} else {
				this.isHidden = this._protoValue.length === 0 || this._protoValue[0].$type !== "application/x-reference";
			}
			if (!this.isHidden) {
				this.addPropActionButtons(sel, data);
			}
		};

		this._initProps = function(props, createEntry) {
			var self = this;
			self._columnProperties = [];
			props.forEach(function(prop) {
				self._createColumnProperty(prop, createEntry);
			});
		};

		this.addPropNbColumns = function() {
			var opts = {
				slideHandler: function(val) {
					return val + " columns";
				},
				stopHandler: jsutils.bindFn(this.updateColumns, this),
				value: this._columnProperties.length,
				min: 1,
				max: this._protoValue.length,
				displayValue: "above"
			};
			this._generalProperties.push(authComponents.newComponent("genericSlider", opts, "nbcolumns"));
		};

		this._updateNbCols = function() {
			var prop;
			this._generalProperties.some(function(p) {
				if (p.name === "nbcolumns") {
					prop = p;
					return true;
				}
			});
			prop.update({
				value: this._columnProperties.length
			});
		};

		this.addPropActionButtons = function(sel, data) {
			var btns = [{
				value: "save",
				title: locale.text("auth.tableDesign.save")
			}];
			this._generalProperties.push(authComponents.newComponent("actionBtns", {
				btns: btns,
				onClick: jsutils.bindFn(this.onClickAction, this, sel, data)
			}));
		};

		this.onClickAction = function(evt, sel, data) {
			var action = $(evt.target).val();
			if (action === "save") {
				var value = [],
					entry;
				var self = this,
					conf;
				this._columnProperties.forEach(function(prop) {
					if (!prop.colInfo) return;
					entry = {};
					_tableConfigKeys.forEach(function(p) {
						conf = prop.colInfo[p];
						if (conf != null) {
							entry[p] = $.isPlainObject(conf) ? $.extend(true, {}, conf) : conf;
						}
					});
					value.push(entry);
				});
				//console.log(JSON.stringify(value, null, 2));
				authPropsGeneral.setValue(this, sel, data, value);
				authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
				return;
			}
			// restore/all - Not used - Wait for the global undo button implementation to remove them
			if (action === "restore") {
				if (this._orginalValue) {
					this._clearColumns();
					this._initProps($.extend(true, [], this._orginalValue), true);
					this._updateNbCols();
					return;
				}
				action = "all";
			}
			if (action === "all") {
				this.updateColumns(null);
				this._updateNbCols();
				return;
			}
		};

		this.createMarkup = function($$parent, prop, sel, data) {
			this.$$parent = $$parent;
			this._accordionId = utils.UUID();
			this.$$myAccordion = $('<div id="' + this._accordionId + '" ></div>');
			$$parent.append(this.$$myAccordion);
			var self = this,
				$$entry;
			self._generalProperties.forEach(function(prop) {
				$$entry = $(authArrayGeneral.getHtml('subtitle', {
					title: prop.label ? prop.label || prop.name : null,
				}));
				// create sub-property
				prop.createMarkup($$entry.find("div"));
				self.$$myAccordion.append($$entry);
			});
			self._columnProperties.forEach(function(prop) {
				self._createColEntry(prop);
			});
		};

		this._createColEntry = function(prop) {
			var id = utils.UUID();
			var $$parent;
			if (!this.isSingleArray) {
				var $$propGroup = $(authArrayGeneral.getHtml("subPropTitle", {
					id: id,
					type: "child columns",
					label: prop.label,
					info: prop.colInfo ? prop.colInfo.$bind : null,
					expanded: false,
					parentId: this._accordionId
				}));
				$$parent = $$propGroup.find("#collapse_" + id);
				this.$$myAccordion.append($$propGroup);
			} else {
				this.$$myAccordion.append($$propGroup);
				$$parent = $('<div style="padding-left:10px;padding-right:10px;"></div>').appendTo(this.$$myAccordion);
			}
			// create sub-property
			prop.createMarkup($$parent);
		};

		this.destroyMarkup = function() {
			this.$$parent = null;
			this.ctrlArray = null;
			this.controller = null;
			this._getAllProps().forEach(function(p) {
				p.destroyMarkup();
			});
			this._generalProperties = null;
			this._columnProperties = null;
		};

		this._getAllProps = function() {
			return (this._generalProperties || []).concat(this._columnProperties || []);
		};

		this.updateColumns = function(nbCols) {
			if (this.$$myAccordion) {
				this.$$myAccordion.find(".collapse").collapse('hide');
			}
			var init = nbCols == null;
			nbCols = init ? this._protoValue.length : nbCols;
			var startFrom = 0;
			if (init) {
				this._clearColumns();
			} else if (this._columnProperties.length > 0) {
				for (var i = this._columnProperties.length - 1; i >= nbCols; i--) {
					this._columnProperties[i].destroyMarkup();
					this._columnProperties.splice(i, 1);
				}
				startFrom = this._columnProperties.length;
			}
			for (var i = startFrom; i < nbCols; i++) {
				this._createColumnProperty(this._protoValue[i], true);
			}
		};

		this._createColumnProperty = function(config, createEntry) {
			var proto = this.getFieldProto(config.$bind, true);
			if (!proto) return null;
			// Update properties from prototype
			config.$title = this.controller.prototype.resolveExpression(proto.value.$title) || config.$bind;
			config.$type = proto.value.$type;
			config.$titleOrig = proto.value.$titleOrig;
			var prop = new _TableColumnPanel(this, config);
			this._columnProperties.push(prop);
			if (createEntry) {
				this._createColEntry(prop);
			}
			return prop;
		};

		this._clearColumns = function() {
			if (this._columnProperties) {
				this._columnProperties.forEach(function(p) {
					p.destroyMarkup();
				});
			}
			this._columnProperties = [];
		};

		this.getProtoValByIdx = function(idx) {
			if (idx < 0 || idx >= this._protoValue.length) throw new Error("unexpected bad index[" + idx + "]");
			return this._protoValue[idx];

		};

		this.getFieldProto = function(bind, noFail) {
			var res = null;
			this._protoValue.some(function(v, idx) {
				if (v.$bind === bind) {
					res = {
						idx: idx,
						value: v
					};
					return true;
				}
			});
			if (res == null && noFail !== true) throw new Error("unexpected null value - bind=[" + bind + "]");
			return res;
		};
	}
};

exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	if (!data.control.prototype.isSingleArray()) {
		props.push(_properties.arrayTableHeader);
	}
	props.push(_properties.arrayTableDesign);
};
});

define('syracuse-tablet/html/js/authoring/arrays/authArrayCard',['require','exports','module','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/application/eventListener','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

var _properties = {

	// only card
	"arrayCardsPerRow": {
		"key": "$cardsPerRow",
		"default": "2",
		values: [{
			value: "1"
		}, {
			value: "2"
		}, {
			value: "3"
		}, {
			value: "4"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio
	},

	// only card
	"arrayCardsMinWidth": function(controller, sel, data) {
		this.name = "arrayCardsMinWidth";
		this.label = null;
		this.key = "$minWidth";
		this["default"] = 1;
		this.min = 0;
		this.max = 20;
		this.step = 1;

		this.createMarkup = function($$parent, prop, sel, data) {
			this.ctrl = data.control;
			this.$$parent = $$parent;
			this.originValue = authPropsGeneral.getValueOrDefault(this, sel, data);
			var opts = {
				id: "auth_opt_" + this.name,
				value: this.originValue,
				min: this.min,
				max: this.max,
				step: this.step || 1,
				slideHandler: jsutils.bindFn(this.onSlide, this, "slide"),
				startHandler: jsutils.bindFn(this.onSlide, this, "start"),
				stopHandler: jsutils.bindFn(this.onSlide, this, "stop", sel, data)
			};
			this._slider = authComponents.newComponent("genericSlider", opts);
			this._slider.createMarkup($$parent);
		};

		this.onSlide = function(value, prop, action, sel, data) {
			var res = this.ctrl.authOnSlideMinSize(value, action);
			if (action === "slide") return res;
			if (action === "stop" && this.originValue != value) {
				authPropsGeneral.setValue(this, sel, data, value);
				authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
			}
		};

		this.destroyMarkup = function() {
			this.ctrl = null;
			this.$$parent = null;
			if (this.$$slider) {
				this.$$slider.slider('destroy');
				this.$$slider = null;
			}
			if (this.$$Button) {
				this.$$Button.off("click");
				this.$$Button = null;
			}
		};

		this._sliderSetValue = function(slideEvt, $$parent, sel, data, originValue) {
			this.ctrl.authOnSlideMinSize(slideEvt, "stop");
			if (originValue != slideEvt.value) {
				authPropsGeneral.setValue(this, sel, data, slideEvt.value);
				authPropsGeneral.notifyChangePropUI($$parent, sel, data);
			}
		};


	},
	/**
	 * Optional sel, data
	 * 	 not null when button property is created like a regular panel propety
	 *	 null when property is created from rightPanel (back from cardDesign to array)
	 */
	"arrayCardButton": function(controller, sel, data) {
		this.name = null;
		this.label = null;
		this.key = null;
		this.controller = controller;
		if (data) {
			this.control = data.control;
		}
		this.createButtonMarkup = function() {
			var saveDesign = this.isSaveButton();
			var text = locale.text("auth.tableDesign." + (saveDesign ? "saveDesign" : "openDesign"));
			this.$$Button = $('<button id="auth_opt_card_design" type="button" class="btn btn-default">' + text + '</button>');
			this.$$Button.on("click", jsutils.bindFn(this.onClickButton, this, saveDesign));
			return this.$$Button;
		};

		this.destroyButtonMarkup = function(context) {
			if (context && context.origin == "selection" && this.isSaveButton()) {
				// No destroy in that case - button remains displayed when we select a ctrl/layout
				// False to tell controller to remove the button
				return false;
			}
			this.control = null;
			this.controller = null;
			if (this.$$Button) {
				// $$slider.find(".$$slider") to make sur the plugin has been initialized
				this.$$Button.off("click");
				this.$$Button.remove();
				this.$$Button = null;
			}
		};

		this.onClickButton = function(evt, closeDesign) {
			if (closeDesign) {
				eventListener.triggerAction(this.controller.$$elmt, "saveCardDesign");
			} else if (this.control) {
				// Trigger a navigation to carddesign page
				var attrs = {
					"data-control-id": this.control.id,
					"data-parent-id": this.controller.id,
					"data-nav": "carddesign",
					"data-nav-target": "application"
				};
				eventListener.triggerNavigation(this.control.$$elmt, attrs);
			}
		};
		this.isSaveButton = function() {
			return this.controller && this.controller.state.type == "carddesign";
		};
	},

	// only card
	"arrayCardsEmptyCells": {
		"key": "$emptycell",
		"default": "nodisplay",
		values: [{
			value: "filled"
		}, {
			value: "withtitle"
		}, {
			value: "nodisplay"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio
	}
};

exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	if (!data.control.prototype.isSingleArray()) {
		props.push(_properties.arrayCardsPerRow, _properties.arrayCardsMinWidth, _properties.arrayCardsEmptyCells, _properties.arrayCardButton);
	}
};

exports.getCardDesignBackButton = function(controller) {
	return new _properties.arrayCardButton(controller);
};
});

define('syracuse-tablet/html/js/helpers/fieldOperators',['require','exports','module','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var locale = require('syracuse-tablet/html/js/helpers/locale');

var _excludedTypes = ["application/x-array", "image", "application/x-document", "application/x-binary", "application/x-object", "text/rtf", "text/html", "application/x-password"];

var _numberOperators = ["gt", "ge", "lt", "le", "eq", "ne"];
var _stringOperators = ["like", "gt", "ge", "lt", "le", "eq", "ne", "like_s"];
var _defOperators = ["eq", "ne"];

var _DATE = {
	type: "application/x-date",
	checkFieldValue: function(fieldValue) {
		return String(fieldValue);
	},
	checkValue: function(value) {
		return String(value);

	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _TIME = {
	type: "application/x-time",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return value;

	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _DATETIME = {
	type: "application/x-datetime",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return value;

	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _DEC = {
	type: "application/x-decimal",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return parseFloat(value);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _REAL = {
	type: "application/x-real",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return parseFloat(value);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _INT = {
	type: "application/x-integer",
	checkFieldValue: function(fieldValue) {
		return parseInt(fieldValue, 10);
	},
	checkValue: function(value) {
		return parseInt(value, 10);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _QTY = {
	type: "application/x-quantity",
	checkFieldValue: function(fieldValue) {
		return parseFloat(fieldValue);
	},
	checkValue: function(value) {
		return parseFloat(value);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _STR = {
	type: "application/x-string",
	checkFieldValue: function(fieldValue) {
		return String(fieldValue);
	},
	checkValue: function(value) {
		return String(value);
	},
	operators: _stringOperators,
	defOperator: "like"
};
var _TEXT = {
	type: "text/plain",
	checkFieldValue: function(fieldValue) {
		return String(fieldValue);
	},
	checkValue: function(value) {
		return String(value);
	},
	operators: _stringOperators,
	defOperator: "like"
};
var _REF = {
	type: "application/x-reference",
	checkFieldValue: function(fieldValue) {
		return fieldValue && fieldValue.$value ? String(fieldValue.$value).toUpperCase() : null;
	},
	checkValue: function(value) {
		return value ? String(value).toUpperCase() : null;

	},
	operators: _stringOperators,
	defOperator: "like"
};
var _CHOICE = {
	type: "application/x-choice",
	checkFieldValue: function(fieldValue) {
		return parseInt(fieldValue, 10);
	},
	checkValue: function(value) {
		return parseInt(value, 10);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _BOOL = {
	type: "application/x-boolean",
	checkFieldValue: function(fieldValue) {
		return parseInt(fieldValue, 10);
	},
	checkValue: function(value) {
		return parseInt(value, 10);
	},
	operators: _defOperators,
	defOperator: "eq"
};


var _types = {};
[_DATE, _TIME, _DATETIME, _DEC, _REAL, _INT, _QTY, _STR, _TEXT, _REF, _BOOL, _CHOICE].forEach(function(t) {
	_types[t.type] = t;
});


var _operatorsWithTitle = {};
/**
 * Return array of operators according to field type
 */
var _operatorsByType = function($type) {
	var t = _types[$type];
	return t ? t.operators : _defOperators;
};

var _getOperators = function($type, withTitle, exclude) {
	var operators;
	if (withTitle === true) {
		if (_operatorsWithTitle[$type] == null) {
			var ops = _operatorsByType($type);
			var res = [];
			ops.forEach(function(op) {
				res.push({
					title: locale.text("field.operator." + op),
					value: op
				});
			});
			_operatorsWithTitle[$type] = res;
		}
		operators = _operatorsWithTitle[$type];
	} else {
		operators = _operatorsByType($type);
	}
	if (exclude && exclude.length > 0) {
		var tmp = operators;
		operators = [];
		tmp.forEach(function(o) {
			if (exclude.indexOf(o) < 0) {
				operators.push(o);
			}
		});
	}
	return operators;
};

var _getDefaultOperator = function($type) {
	var t = _types[$type];
	return t ? t.defOperator : "eq";
};
var _evaluateOperator = function($type, fieldValue, operator, value) {
	var fieldType = _types[$type];
	if (fieldType == null) {
		console.log("_evaluateOperator - Type [" + $type + "] not evaluated");
		return false;
	}
	if (fieldType.operators.indexOf(operator) < 0) return false;
	fieldValue = fieldType.checkFieldValue(fieldValue);
	value = fieldType.checkValue(value);
	if (fieldValue == null || value == null) return false;
	if (operator === "eq") {
		return fieldValue == value;
	}
	if (operator === "ne") {
		return fieldValue != value;
	}
	if (operator === "like") {
		return fieldValue.indexOf ? fieldValue.indexOf(value) >= 0 : false;
	}
	if (operator === "like_s") {
		return fieldValue.smStartsWith ? fieldValue.smStartsWith(value) : false;
	}
	if (operator === "gt") {
		return fieldValue > value;
	}
	if (operator === "ge") {
		return fieldValue >= value;
	}
	if (operator === "lt") {
		return fieldValue < value;
	}
	if (operator === "le") {
		return fieldValue <= value;
	}
	return false;
};

exports.getDefaultOperator = _getDefaultOperator;
exports.getOperators = _getOperators;
exports.evaluateOperator = _evaluateOperator;
exports.acceptOperator = function($type) {
	return _excludedTypes.indexOf($type) < 0;
};
});

define('syracuse-tablet/html/js/helpers/types/date',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require("syracuse-tablet/html/js/helpers/locale");

var _dateInfo = locale.getDatetimeInfo;

function _padLeft(str, len, ch) {
	str = str ? str.toString() : '';
	if (!ch || ch.length == 0)
		ch = " ";
	while (str.length < len)
		str = ch + str;
	return str;
};

exports.validate = function(value, constraints, errors) {
	if (value == null) {
		if (constraints.$isMandatory)
			return errors.push(locale.text("date.valMan"));
		if (!constraints.$isNullable)
			return errors.push(locale.text("date.valNull"));
		return;
	}
	if (!(value instanceof DateObj)) {
		errors.push(locale.text("date.valDate"));
		return;
	}

	// month value check
	if (!(value.month >= 1 && value.month <= 12)) {
		errors.push(locale.text("date.invMonth"));
		return;
	}

	// day value check
	if (!(value.day >= 1 && value.day <= _daysInMonth(value.year, value.month))) {
		errors.push(locale.text("date.invDay"));
		return;
	}

};

var _monthOffsets = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var _monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

// internal value is integer yyyymmdd
// this is a very simple and compact representation that leads to
// very efficient component extraction and formatting. 
// Also nice for debugging

function DateObj(value) {
	this._value = value;
	//Object.freeze(this); -- confuses JSON, reenable later
}

function _dayName(weekDay, abbrev) {
	return abbrev ? _dateInfo().abbreviatedDayNames[weekDay] : _dateInfo().dayNames[weekDay];
}

function _monthName(month, abbrev) {
	return abbrev ? _dateInfo().abbreviatedMonthNames[month - 1] : _dateInfo().monthNames[month - 1];
}

function _pad2(val) {
	var s = val.toString();
	return (s.length == 1) ? "0" + s : s;
}

function _toOffset(date) {
	var year = date.year;
	var month = date.month;
	var day = date.day;
	// Compute the number of leap days since Jan 1st, 1970.
	// The trick is to use the previous year if month is January or February,
	// the current year otherwise.
	// Then, we compute the number of multiples of 4, 100 and 400 since 1970.
	var y = month <= 2 ? year - 1 : year;

	var n4 = Math.floor(y / 4) - Math.floor(1970 / 4);
	var n100 = Math.floor(y / 100) - Math.floor(1970 / 100);
	var n400 = Math.floor(y / 400) - Math.floor(1970 / 400);

	// Years that are multiple of 400 (like 2000) contribute by 1 (1 -1 +1 in expression below)
	// Years that are multiple of 100 but not of 400 contribute by 0 (1 -1 +0 in expression below)
	// Years that are multiple of 4 but not 100 nor 400 contribute by 1 (1 -0 +0 in expression below).
	var nLeap = n4 - n100 + n400;

	// The offset is straightforward at this point.
	// The February/March transition on leap days will be handled by the fact that the
	// 'y' value above will change, and hence the 'nLeap' value.
	return (year - 1970) * 365 + nLeap + _monthOffsets[month - 1] + day - 1;
}

function _fromOffset(offset) {
	var julian = 2440588 + offset;
	var l = julian + 68569;
	var n = Math.floor((4 * l) / 146097);
	l = l - Math.floor((146097 * n + 3) / 4);
	var i = Math.floor((4000 * (l + 1)) / 1461001);
	l = l - Math.floor((1461 * i) / 4) + 31;
	var j = Math.floor((80 * l) / 2447);
	var day = l - Math.floor((2447 * j) / 80);
	l = Math.floor(j / 11);
	var month = j + 2 - (12 * l);
	var year = 100 * (n - 49) + i + l;
	return new DateObj(year * 10000 + month * 100 + day);
}

function _make(year, month, day) {
	return new DateObj(year * 10000 + month * 100 + day);
}

function _isLeap(year) {
	return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}

function _daysInMonth(year, month) {
	return month == 2 ? (_isLeap(year) ? 29 : 28) : _monthLengths[month - 1];
}

function _isWorkDay(weekDay) {
	return weekDay != 0 && weekDay != 6;
}

function _amDesignator() {
	return _dateInfo().amDesignator || "AM";
}

function _pmDesignator() {
	return _dateInfo().pmDesignator || "PM";
}

exports.amDesignator = _amDesignator;
exports.pmDesignator = _pmDesignator;

// do not export the class
utils.defineClass(DateObj, null, {
	year: {
		get: function() {
			return Math.floor(this._value / 10000);
		}
	},
	month: {
		get: function() {
			return Math.floor(this._value / 100) % 100;

		}
	},
	day: {
		get: function() {
			return this._value % 100;
		}
	},
	weekDay: {
		get: function() {
			// Add Julian offset (+1 because Julian origin is Monday) 
			// so that modulo is on positive value even if date is before 1970
			return ((2440588 + 1 + _toOffset(this)) % 7);
		}
	},
	yearDay: {
		get: function() {
			var month = this.month;
			var leap = month > 2 && _isLeap(this.year) ? 1 : 0;
			return _monthOffsets[month - 1] + leap + this.day;
		}
	},
	week: {
		// ISO 8601 with week 0
		get: function() {
			// week 1 is the beg of week that contains Jan 4th.
			var begOfWeek1 = _make(this.year, 1, 4).begOfWeek(1);
			return Math.floor((7 + _toOffset(this) - _toOffset(begOfWeek1)) / 7);
		}
	},

	valueOf: function() {
		return this.toString();
	},
	compare: function(date) {
		return this._value - date._value;
	},
	equals: function(date) {
		return this._value === date._value;
	},
	between: function(begin, end) {
		return begin._value <= this._value && this._value <= end._value;
	},

	isLeapYear: function() {
		return _isLeap(this.year);
	},
	isWorkDay: function() {
		return _isWorkDay(this.weekDay);
	},
	daysInMonth: function() {
		return _daysInMonth(this.year, this.month);
	},

	begOfYear: function() {
		return _make(this.year, 1, 1);
	},
	endOfYear: function() {
		return _make(this.year, 12, 31);
	},
	begOfQuarter: function() {
		return _make(this.year, Math.floor((this.month - 1) / 3) * 3 + 1, 1);
	},
	endOfQuarter: function() {
		return this.begOfQuarter().addMonths(2).endOfMonth();
	},
	begOfMonth: function() {
		return _make(this.year, this.month, 1);
	},
	endOfMonth: function() {
		return _make(this.year, this.month, this.daysInMonth());
	},
	sameMonth: function(day) {
		day = Math.min(day, this.daysInMonth());
		return _make(this.year, this.month, day);
	},
	pastDay: function(day, includeThis) {
		var delta = day - this.day;
		return (delta > 0 || delta == 0 && !includeThis) ? this.addMonths(-1).sameMonth(day) : this.sameMonth(day);
	},
	futureDay: function(day, includeThis) {
		var delta = day - this.day;
		return (delta < 0 || delta == 0 && !includeThis) ? this.addMonths(1).sameMonth(day) : this.sameMonth(day);
	},
	pastMonth: function(month, includeThis) {
		var delta = this.month - month;
		delta = delta == 0 ? (includeThis ? 0 : 12) : delta > 0 ? delta : delta + 12;
		return this.addMonths(-delta);
	},
	futureMonth: function(month, includeThis) {
		var delta = month - this.month;
		delta = delta == 0 ? (includeThis ? 0 : 12) : delta > 0 ? delta : delta + 12;
		return this.addMonths(delta);
	},
	begOfWeek: function(startDay) { // 0: Sunday (default), 1: Monday
		var delta = this.weekDay - (startDay || 0);
		return delta == 0 ? this : delta > 0 ? this.addDays(-delta) : this.addDays(-delta - 7);
	},
	endOfWeek: function(startDay) {
		return this.begOfWeek(startDay).addDays(6);
	},
	sameWeek: function(weekDay, startDay) {
		return this.begOfWeek(startDay).futureWeekDay(weekDay, true);
	},
	pastWeekDay: function(weekDay, includeThis) {
		var result = this.begOfWeek(weekDay);
		return !includeThis && result.equals(this) ? this.addWeeks(-1) : result;
	},
	futureWeekDay: function(weekDay, includeThis) {
		return this.pastWeekDay(weekDay, !includeThis).addWeeks(1);
	},
	addYears: function(years) {
		if (years == 0)
			return this;
		var year = this.year + years;
		var month = this.month;
		var day = Math.min(this.day, _daysInMonth(year, month));
		return _make(year, month, day);
	},
	addMonths: function(months) {
		if (months == 0)
			return this;
		var self = this;
		var day = self.day;
		var month0 = self.month - 1;
		var year = self.year;
		month0 += months;
		year += Math.floor(month0 / 12);
		var month = (month0 + 120000) % 12 + 1;
		var monthLen = _daysInMonth(year, month);
		day = day < monthLen ? day : monthLen;
		return _make(year, month, day);
	},
	addWeeks: function(weeks) {
		return this.addDays(7 * weeks);
	},
	addDays: function(days) {
		if (days == 0)
			return this;
		return _fromOffset(_toOffset(this) + days);
	},

	daysDiff: function(date) {
		return _toOffset(this) - _toOffset(date);
	},

	/**
     * Adds (or subtracts) to the value of the year, month, day, hour, minute, second, millisecond of the date instance using given configuration object. Positive and Negative values allowed.
     * Example
     <pre><code>
     Date.today().add( { day: 1, month: 1 } )
     </code></pre>
     * @param {Object}   Configuration object containing attributes (month, day, etc.)
     * @return {Date}    this
     */
	add: function(delta) {
		return this.addYears(delta.years || 0).addMonths(delta.months || 0).addWeeks(delta.weeks || 0).addDays(delta.days || 0);
	},

	// format as 
	toString: function(format) {
		var self = this;
		if (format == null) {
			// RFC 3339 by default -- very fast
			var str = self._value.toString();
			str = _padLeft(str, 8, "0");
			return str.substring(0, 4) + "-" + str.substring(4, 6) + "-" + str.substring(6, 8);
		} else {
			var result = '';
			_walkFormat(format, {
				literal: function(lit) {
					result += lit;
				},
				d: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.day.toString();
							break;
						case 2:
							result += _pad2(self.day);
							break;
						case 3:
							result += _dayName(self.weekDay, true);
							break;
						case 4:
							result += _dayName(self.weekDay);
							break;
						default:
							throw new Error(locale.text("date.formatd", repeat));
					}
				},
				M: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.month.toString();
							break;
						case 2:
							result += _pad2(self.month);
							break;
						case 3:
							result += _monthName(self.month, true);
							break;
						case 4:
							result += _monthName(self.month);
							break;
						default:
							throw new Error(locale.text("date.formatM", repeat));
					}
				},
				y: function(repeat) {
					switch (repeat) {
						case 2:
							result += self.year.toString().substring(2, 4);
							break;
						case 4:
							result += self.year.toString();
							break;
						default:
							throw new Error(locale.text("date.formatM", repeat));
					}
				}
			});
			return result;
		}
	},

	at: function(time, millisecond) {
		throw new Error(locale.text("date.notInstalled"));
	},

	toJsDate: function(utc) {
		return utc ? new Date(Date.UTC(this.year, this.month - 1, this.day)) : new Date(this.year, this.month - 1, this.day);
	},

	isNull: function() {
		return this._value == 0;
	}
});

exports.monthName = _monthName;

/**
 * Gets the month number (1-12) if given a Culture Info specific string which is a valid monthName or abbreviatedMonthName.
 * @param {String}   The name of the month (eg. "February, "Feb", "october", "oct").
 * @return {Number}  The day number
 */
exports.monthFromName = function(name) {
	var n = _dateInfo().monthNames,
		m = _dateInfo().abbreviatedMonthNames,
		s = name.toLowerCase();
	for (var i = 0; i < n.length; i++) {
		if (n[i].toLowerCase() == s || m[i].toLowerCase() == s) {
			return i + 1;
		}
	}
	return -1;
};

exports.dayName = _dayName;

/**
 * Gets the day number (0-6) if given a CultureInfo specific string which is a valid dayName, abbreviatedDayName or shortestDayName (two char).
 * @param {String}   The name of the day (eg. "Monday, "Mon", "tuesday", "tue", "We", "we").
 * @return {Number}  The day number
 */
exports.weekDayFromName = function(name) {
	var n = _dateInfo().dayNames,
		m = _dateInfo().abbreviatedDayNames,
		o = _dateInfo().shortestDayNames,
		s = name.toLowerCase();
	for (var i = 0; i < n.length; i++) {
		if (n[i].toLowerCase() == s || m[i].toLowerCase() == s) {
			return i;
		}
	}
	return -1;
};

exports.isLeap = _isLeap;

exports.daysInMonth = _daysInMonth;

exports.today = function(utc) {
	return exports.fromJsDate(new Date(), utc);
};

function _walkFormat(format, map) {
	var i = 0,
		len = format.length;

	function count(i) {
		var ch = format[i],
			k = 1;
		while (format[i + k] === ch)
			k++;
		return k;
	}

	while (i < len) {
		var c = format[i];
		switch (c) {
			case "'":
				i++;
				var literal = '';
				// going to the end of the following litteral or to the format end
				for (; i < len; i++) {
					if (format[i] === "'") {
						i++;
						// check wether the "'" is not doubled
						if (format[i] === "'") {
							literal += "'";
						} else
							break;
					} else {
						literal += format[i];
					}
				}
				map.literal(literal);
				break;
			case "d":
			case "M":
			case "y":
				var repeat = count(i);
				map[c](repeat);
				i += repeat;
				break;
			default:
				map.literal(c);
				i++;

		}
	}
}

function _parse(str, format) {
	var day, weekday, month, year;
	// position in str
	var j = 0;

	function parseInteger(max) {
		if (!/\d/.test(str[j])) {
			throw new Error(locale.text("date.notNumber", str.substring[j]));
		}
		var beg = j++;
		while (j < beg + max && /\d/.test(str[j]))
			j++;
		return parseInt(str.substring(beg, j), 10);
	}

	function parseName(names) {
		for (var k = 0; k < names.length; k++) {
			var name = names[k],
				len = name.length;
			if (str.substring(j, j + len).toUpperCase() == name.toUpperCase()) {
				j += len;
				return k;
			}
		}
		throw new Error(locale.text("date.unknown", str.substring(j)));
	}

	_walkFormat(format, {
		literal: function(literal) {
			if (str.substring(j, j + literal.length) !== literal)
				throw new Error(locale.text("date.wrongFormat", literal, str.substring(j)));
			j += literal.length;
		},
		d: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					day = parseInteger(2);
					break;
				case 3:
					weekday = parseName(_dateInfo().abbreviatedDayNames);
					break;
				case 4:
					weekday = parseName(_dateInfo().dayNames);
					break;
				default:
					throw new Error(locale.text("date.badDay", format.substring(j))); // replaced i with j
			}
		},
		M: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					month = parseInteger(2);
					break;
				case 3:
					month = parseName(_dateInfo().abbreviatedMonthNames) + 1;
					break;
				case 4:
					month = parseName(_dateInfo().monthNames) + 1;
					break;
				default:
					throw new Error(locale.text("date.badDay", format.substring(j))); // replaced i with j
			}
		},
		y: function(arg) {
			switch (arg) {
				case 2:
					year = parseInteger(2);
					year = year < 40 ? 2000 + year : 1900 + year;
					break;
				case 4:
					year = parseInteger(4);
					year = year > 99 ? year : year < 40 ? 2000 + year : 1900 + year;
					break;
				default:
					throw new Error(locale.text("date.badYear", format.substring(j))); // replaced i with j
			}
		}
	});

	// ignore weekday
	return _make(year, month, day);
}

exports.parse = function(str, format) {
	if (str == null)
		throw new Error(locale.text("date.dateNull"));

	if (format == null) {
		// RFC 3339 by default -- very fast
		if (str.length != 10)
			throw new Error(locale.text("date.badFormat", str));
		var value = parseInt(str.replace(/-/g, ''), 10);
		return new DateObj(value);
	} else {
		return _parse(str, format);
	}
};

// used for format conversions
exports.walkFormat = _walkFormat;

exports.fromJsDate = function(jsDate, utc) {
	return utc ? _make(jsDate.getUTCFullYear(), jsDate.getUTCMonth() + 1, jsDate.getUTCDate()) : _make(jsDate.getFullYear(), jsDate.getMonth() + 1, jsDate.getDate());
};

exports.fromInternalValue = function(value) {
	return new DateObj(value);
};

exports.makeInWeek = function(year, week, wday) {
	var dday = wday ? wday - 1 : 6;
	return _make(year, 1, 4).begOfWeek(1).addDays(7 * (week - 1) + dday);
};
exports.isDate = function(obj) {
	return obj instanceof DateObj;
};


exports.sunday = 0;
exports.Sunday = 0;
exports.monday = 1;
exports.Monday = 1;
exports.tuesday = 2;
exports.Tuesday = 2;
exports.wednesday = 3;
exports.Wednesday = 3;
exports.thursday = 4;
exports.Thursday = 4;
exports.friday = 5;
exports.Friday = 5;
exports.saturday = 6;
exports.Saturday = 6;

exports.make = _make;

exports.getLocalShortDate = function(dateISOString) {
	if (!dateISOString || dateISOString.length < 6)
		return "";

	var tmp = dateISOString.split("-");
	var d = _make(+tmp[0], +tmp[1], +tmp[2]);

	return d.toString(locale.getDateFormat());
};
});

define('syracuse-tablet/html/js/helpers/types/time',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require("syracuse-tablet/html/js/helpers/locale");
var _dateInfo = locale.getDatetimeInfo;

exports.validate = function(value, constraints, errors) {
	if (value == null) {
		if (constraints.$isMandatory) return errors.push(locale.text("time.valMan"));
		if (!constraints.$isNullable) return errors.push(locale.text("time.valNull"));
		return;
	}
	if (!(value instanceof Time)) {
		errors.push(locale.text("time.valTime"));
		return;
	}
};

function Time(value) {
	// force modulo on value to bring it back in range
	value = (value + 86400 * 365 * 10000) % 86400;
	this._value = value;
}

function _pad2(val) {
	var s = val.toString();
	return (s.length == 1) ? "0" + s : s;
}

function _parse2(str, beg, end) {
	return parseInt(str.substring(beg, end), 10);
}

function _make(hour, minute, second) {
	return new Time(hour * 3600 + (minute || 0) * 60 + (second || 0));
}

function _amDesignator() {
	return _dateInfo().amDesignator || "AM";
}

function _pmDesignator() {
	return _dateInfo().pmDesignator || "AM";
}

utils.defineClass(Time, null, {
	hour: {
		get: function() {
			return Math.floor(this._value / 3600);
		}
	},
	minute: {
		get: function() {
			return Math.floor(this._value / 60) % 60;
		}
	},
	second: {
		get: function() {
			return this._value % 60;
		}
	},
	value: {
		get: function() {
			return this._value;
		}
	},
	valueOf: function() {
		return this.toString();
	},
	compare: function(time) {
		return this._value - time._value;
	},
	equals: function(time) {
		return this._value === time._value;
	},
	between: function(begin, end) {
		return begin._value <= this._value && this._value <= end._value;
	},

	begOfDay: function() {
		return _make(0, 0, 0);
	},
	endOfDay: function() {
		return _make(23, 59, 59);
	},
	begOfHour: function() {
		return _make(this.hour, 0, 0);
	},
	endOfHour: function() {
		return _make(this.hour, 59, 59);
	},
	begOfMinute: function() {
		return _make(this.hour, this.minute, 0);
	},
	endOfMinute: function() {
		return _make(this.hour, this.minute, 59);
	},

	// format as
	toString: function(format) {
		var self = this;
		if (format == null) {
			return _pad2(self.hour) + ":" + _pad2(self.minute) + ":" + _pad2(self.second);
		} else {
			var result = '';
			_walkFormat(format, {
				literal: function(lit) {
					result += lit;
				},
				H: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.hour;
							break;
						case 2:
							result += _pad2(self.hour);
							break;
						default:
							throw new Error(locale.text("time.formatH", repeat));
					}
				},
				h: function(repeat) {
					switch (repeat) {
						case 1:
							var hour = self.hour;
							if (hour === 0) {
								result += 12;
							} else {
								result += hour > 12 ? hour - 12 : hour;
							}
							break;
						case 2:
							var hour = self.hour;
							if (hour === 0) {
								result += 12;
							} else {
								result += hour > 12 ? _pad2(hour - 12) : _pad2(hour);
							}
							break;
						default:
							throw new Error(locale.text("time.formath", repeat));
					}
				},
				m: function(repeat) {
					switch (repeat) {
						case 2:
							result += _pad2(self.minute);
							break;
						default:
							throw new Error(locale.text("time.formatm", repeat));
					}
				},
				s: function(repeat) {
					switch (repeat) {
						case 2:
							result += _pad2(self.second);
							break;
						default:
							throw new Error(locale.text("time.formats", repeat));
					}
				},
				t: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.hour < 12 ? _amDesignator().substring(0, 1) : _pmDesignator().substring(0, 1);
							break;
						case 2:
							result += self.hour < 12 ? _amDesignator() : _pmDesignator();
							break;
						default:
							throw new Error(locale.text("time.formata", repeat));
					}
				}
			});
			return result;
		}

	},

	secondsDiff: function(t) {
		return this._value - t._value;
	},

	// add functions circle from 23:59:59 to 00:00:00 without warning
	addHours: function(hours) {
		return hours == 0 ? this : new Time(this._value + hours * 3600);
	},
	addMinutes: function(minutes) {
		return minutes == 0 ? this : new Time(this._value + minutes * 60);
	},
	addSeconds: function(seconds) {
		return seconds == 0 ? this : new Time(this._value + seconds);
	},
	add: function(delta) {
		return this.addHours(delta.hours || 0).addMinutes(delta.minutes || 0).addSeconds(delta.seconds || 0);
	},
	isNull: function() {
		return this._value == 0;
	}
});

exports.make = _make;

exports.fromSeconds = function(seconds) {
	return new Time(seconds);
};

exports.fromJsDate = function(js, utc) {
	return utc ? _make(js.getUTCHours(), js.getUTCMinutes(), js.getUTCSeconds()) : _make(js.getHours(), js.getMinutes(), js.getSeconds());
};

exports.now = function(utc) {
	return exports.fromJsDate(new Date(), utc);
};

exports.parse = function(str, format) {
	if (str == null) throw new Error(locale.text("time.isNull"));

	if (format == null) {
		// RFC 3339 full time without fraction -- very fast
		// hh:mm
		if (str.length != 5 && str.length != 8) throw new Error(locale.text("time.badFormat", str));

		var value = str.length == 8 ? _parse2(str, 0, 2) * 3600 + _parse2(str, 3, 5) * 60 + _parse2(str, 6, 8) : _parse2(str, 0, 2) * 3600 + _parse2(str, 3, 5) * 60;
		return new Time(value);
	} else {
		return _parse(str, format);
	}
};

function _walkFormat(format, map) {
	var i = 0,
		len = format.length;

	function count(i) {
		var ch = format[i],
			k = 1;
		while (format[i + k] === ch)
			k++;
		return k;
	}

	while (i < len) {
		var c = format[i];
		switch (c) {
			case "'":
				i++;
				var literal = '';
				// going to the end of the following literal or to the format end
				for (; i < len; i++) {
					if (format[i] === "'") {
						i++;
						// check whether the "'" is not doubled
						if (format[i] === "'") {
							literal += "'";
						} else break;
					} else {
						literal += format[i];
					}
				}
				map.literal(literal);
				break;
			case "H":
			case "h":
			case "m":
			case "s":
			case "t":
				var repeat = count(i);
				map[c](repeat);
				i += repeat;
				break;
			default:
				map.literal(c);
				i++;
		}
	}
}

function _parse(str, format) {
	var hour, minute, second, timeMode, abbrTimeMode;
	var timeModes = [_amDesignator(), _pmDesignator()];
	var abbrTimeModes = [timeModes[0].substring(0, 1), timeModes[1].substring(0, 1)];
	// position in str
	var j = 0;

	function parseInteger(max) {
		if (!/\d/.test(str[j])) {
			throw new Error(locale.text("time.noNumber", str.substring[j]));
		}
		var beg = j++;
		while (j < beg + max && /\d/.test(str[j]))
			j++;
		return parseInt(str.substring(beg, j), 10);
	}

	function parseName(names) {
		for (var k = 0; k < names.length; k++) {
			var name = names[k],
				len = name.length;
			if (str.substring(j, j + len).toUpperCase() == name.toUpperCase()) {
				j += len;
				return k;
			}
		}
		throw new Error(locale.text("time.unknown", str.substring(j)));
	}

	_walkFormat(format, {
		literal: function(literal) {
			if (str.substring(j, j + literal.length) !== literal) throw new Error(locale.text("time.wrongFormat", literal, str.substring(j)));
			j += literal.length;
		},
		H: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					hour = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("time.badHour", format.substring(j))); // replaced i with j
			}
		},
		h: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					hour = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("time.badHour", format.substring(j)));
			}
		},
		m: function(arg) {
			switch (arg) {
				case 2:
					minute = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("time.badMin", format.substring(j)));
			}
		},
		s: function(arg) {
			switch (arg) {
				case 2:
					second = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("time.badSec", format.substring(j)));
			}
		},
		t: function(arg) {
			switch (arg) {
				case 1:
					abbrTimeMode = parseName(abbrTimeModes);
					break;
				case 2:
					timeMode = parseName(timeModes);
					break;
				default:
					throw new Error(locale.text("time.badMarker", format.substring(j)));
			}
		}
	});

	// from 12 format to 24 format, used when necessary

	function from12to24(mode, index) {
		switch (mode[index]) {
			case mode[0]:
				// AM
				hour = hour === 12 ? 0 : hour;
				break;
			case mode[1]:
				// PM
				if (hour >= 1 && hour <= 11) {
					hour += 12;
				}
				break;
		}
	}

	if (timeMode != null || abbrTimeMode != null) {
		if (hour > 12) throw new Error(locale.text("time.badHourVal", hour, timeMode));
		var mode = timeMode != null ? timeModes : abbrTimeModes;
		var index = timeMode != null ? timeMode : abbrTimeMode;
		from12to24(mode, index);
	}

	return _make(hour, minute, second);
}

exports.amDesignator = _amDesignator;
exports.pmDesignator = _pmDesignator;
});

define('syracuse-tablet/html/js/helpers/types/datetime',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/types/date','syracuse-tablet/html/js/helpers/types/time','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var date = require('syracuse-tablet/html/js/helpers/types/date');
var time = require('syracuse-tablet/html/js/helpers/types/time');
var locale = require("syracuse-tablet/html/js/helpers/locale");

var _dateInfo = locale.getDatetimeInfo;

exports.validate = function(value, constraints, errors) {
	if (value == null) {
		if (constraints.$isMandatory) return errors.push(locale.text("datetime.valMand"));
		if (!constraints.$isNullable) return errors.push(locale.text("datetime.valNull"));
		return;
	}
	if (!(value instanceof Datetime)) {
		errors.push(locale.text("datetime.valDT"));
		return;
	}

	// month value check
	if (!(value.month >= 1 && value.month <= 12)) {
		errors.push(locale.text("datetime.valMon"));
		return;
	}

	// day value check
	if (!(value.day >= 1 && value.day <= date.daysInMonth(value.year, value.month))) {
		errors.push(locale.text("datetime.valDay"));
		return;
	}
};

function _pad2(val) {
	var s = val.toString();
	return (s.length == 1) ? "0" + s : s;
}

function _pad3(val) {
	var s = val.toString();
	switch (s.length) {
		case 1:
			return "00" + s;
		case 2:
			return "0" + s;
		default:
			return s;
	}
}

// internal value is GMT millis since origin (Jan 1st, 1970).
// We also cache the local and utc values separately as _local and _utc, when
// they are requested.

function Datetime(value, tzOffset) {
	this._value = value;
	if (tzOffset != null) this._tzOffset = tzOffset;
}

// returns millis value for seconds and milliseconds part

function _ms(dt) {
	// add millis for approx 2000 years to ensure positive before applying modulo
	return (dt._value + 2000 * 365 * 24 * 3600 * 1000) % 1000;
}

// get UTC components packed into an int
// millis are not included as they are independent from UTC/local

function _utc(dt) {
	var utc = dt._utc;
	if (!utc) {
		var d = new Date(dt._value);
		utc = d.getUTCFullYear() * 10000 * 100000 + (d.getUTCMonth() + 1) * 100 * 100000 + d.getUTCDate() * 100000 + d.getUTCHours() * 3600 + d.getUTCMinutes() * 60 + d.getUTCSeconds();
		d._utc = utc;
	}
	return utc;
}

// get local components packed into an int
// millis are not included as they are independent from UTC/local

function _local(dt) {
	var local = dt._local;
	if (!local) {
		var d = new Date(dt._value);
		local = d.getFullYear() * 10000 * 100000 + (d.getMonth() + 1) * 100 * 100000 + d.getDate() * 100000 + d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds();
		d._local = local;
	}
	return local;
}

exports.Datetime = utils.defineClass(Datetime, null, {
	date: {
		get: function() {
			return date.fromInternalValue(Math.floor(_local(this) / 100000));
		}
	},
	time: {
		get: function() {
			return time.fromSeconds(_local(this) % 100000);
		}
	},
	year: {
		get: function() {
			return this.date.year;
		}
	},
	month: {
		get: function() {
			return this.date.month;
		}
	},
	day: {
		get: function() {
			return this.date.day;
		}
	},
	weekDay: {
		get: function() {
			return this.date.weekDay;
		}
	},
	yearDay: {
		get: function() {
			return this.date.yearDay;
		}
	},
	hour: {
		get: function() {
			return this.time.hour;
		}
	},
	minute: {
		get: function() {
			return this.time.minute;
		}
	},
	second: {
		get: function() {
			return this.time.second;
		}
	},
	millisecond: {
		get: function() {
			return _ms(this);
		}
	},

	utcDate: {
		get: function() {
			return date.fromInternalValue(Math.floor(_utc(this) / 100000));
		}
	},
	utcTime: {
		get: function() {
			return time.fromSeconds(_utc(this) % 100000);
		}
	},
	utcYear: {
		get: function() {
			return this.utcDate.year;
		}
	},
	utcMonth: {
		get: function() {
			return this.utcDate.month;
		}
	},
	utcDay: {
		get: function() {
			return this.utcDate.day;
		}
	},
	utcWeekDay: {
		get: function() {
			return this.utcDate.weekDay;
		}
	},
	utcYearDay: {
		get: function() {
			return this.utcDate.yearDay;
		}
	},
	utcHour: {
		get: function() {
			return this.utcTime.hour;
		}
	},
	utcMinute: {
		get: function() {
			return this.utcTime.minute;
		}
	},
	utcSecond: {
		get: function() {
			return this.utcTime.second;
		}
	},
	utcMillisecond: {
		get: function() {
			return _ms(this);
		}
	},
	value: {
		get: function() {
			return this._value;
		}
	},
	timezoneOffset: {
		get: function() {
			if (this._tzOffset == null) this._tzOffset = this.toJsDate().getTimezoneOffset();
			return this._tzOffset;
		}
	},

	compare: function(dt) {
		return this._value - dt._value;
	},
	equals: function(dt) {
		return this._value === dt._value;
	},
	between: function(begin, end) {
		return begin._value <= this._value && this._value <= end._value;
	},

	addYears: function(years) {
		return this.date.addYears(years).at(this.time, this.millisecond);
	},
	addMonths: function(months) {
		return this.date.addMonths(months).at(this.time, this.millisecond);
	},
	addWeeks: function(weeks) {
		return this.date.addWeeks(weeks).at(this.time, this.millisecond);
	},
	addDays: function(days) {
		return this.date.addDays(days).at(this.time, this.millisecond);
	},
	addHours: function(hours) {
		return new Datetime(this._value + hours * 3600 * 1000);
	},
	addMinutes: function(minutes) {
		return new Datetime(this._value + minutes * 60 * 1000);
	},
	addSeconds: function(seconds) {
		return new Datetime(this._value + seconds * 1000);
	},
	addMilliseconds: function(millis) {
		return new Datetime(this._value + millis);
	},
	addDayFractions: function(fraction) {
		return new Datetime(this._value + fraction * 86400 * 1000);
	},

	millisDiff: function(dt) {
		return this._value - dt._value;
	},
	begOfMonth: function() {
		return _make(this.year, this.month, 1);
	},
	begOfWeek: function(startDay) { // 0: Sunday (default), 1: Monday
		var delta = this.weekDay - (startDay || 0);
		return delta == 0 ? this : delta > 0 ? this.addDays(-delta) : this.addDays(-delta - 7);
	},

	/**
     * Adds (or subtracts) to the value of the year, month, day, hour, minute, second, millisecond of the date instance using given configuration object. Positive and Negative values allowed.
     * Example
     <pre><code>
     Date.today().add( { day: 1, month: 1 } )
     </code></pre>
     * @param {Object}   Configuration object containing attributes (month, day, etc.)
     * @return {Date}    this
     */
	add: function(delta) {
		return this.addYears(delta.years || 0).addMonths(delta.months || 0).addWeeks(delta.weeks || 0).addDays(delta.days || 0).addHours(delta.hours || 0).addMinutes(delta.minutes || 0).addSeconds(delta.seconds || 0).addMillis(delta.millis || 0);
	},

	// format as
	toString: function(format) {
		var self = this;
		if (format == null) {
			return new Date(this._value).toISOString();
		} else {
			var utc = _getIndexOfZ(format);
			var _date = utc ? self.utcDate : self.date;
			var _time = utc ? self.utcTime : self.time;

			var result = '';
			_walkFormat(format, {
				literal: function(lit) {
					result += lit;
				},
				H: function(repeat) {
					switch (repeat) {
						case 1:
							result += _time.hour.toString();
							break;
						case 2:
							result += _pad2(_time.hour);
							break;
						default:
							throw new Error(locale.text("datetime.formatH", repeat));
					}
				},
				h: function(repeat) {
					switch (repeat) {
						case 1:
							result += _time.hour < 13 ? _time.hour : (_time.hour - 12);
							break;
						case 2:
							result += _pad2(_time.hour < 13 ? _time.hour : (_time.hour - 12));
							break;
						default:
							throw new Error(locale.text("datetime.formath", repeat));
					}
				},
				m: function(repeat) {
					switch (repeat) {
						case 2:
							result += _pad2(_time.minute);
							break;
						default:
							throw new Error(locale.text("datetime.formatm", repeat));
					}
				},
				s: function(repeat) {
					switch (repeat) {
						case 2:
							result += _pad2(self.second);
							break;
						default:
							throw new Error(locale.text("datetime.formats", repeat));
					}
				},
				t: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.hour < 12 ? _dateInfo().amDesignator.substring(0, 1) : _dateInfo().pmDesignator.substring(0, 1);
							break;
						case 2:
							result += self.hour < 12 ? _dateInfo().amDesignator : _dateInfo().pmDesignator;
							break;
						default:
							throw new Error(locale.text("datetime.formata", repeat));
					}
				},
				d: function(repeat) {
					switch (repeat) {
						case 1:
							result += _date.day.toString();
							break;
						case 2:
							result += _pad2(_date.day);
							break;
						case 3:
							result += date.dayName(_date.weekDay, true);
							break;
						case 4:
							result += date.dayName(_date.weekDay);
							break;
						default:
							throw new Error(locale.text("datetime.formatd", repeat));
					}
				},
				M: function(repeat) {
					switch (repeat) {
						case 1:
							result += _date.month.toString();
							break;
						case 2:
							result += _pad2(_date.month);
							break;
						case 3:
							result += date.monthName(_date.month, true);
							break;
						case 4:
							result += date.monthName(_date.month);
							break;
						default:
							throw new Error(locale.text("datetime.formatM", repeat));
					}
				},
				y: function(repeat) {
					switch (repeat) {
						case 2:
							result += _date.year.toString().substring(2, 4);
							break;
						case 4:
							result += _date.year.toString();
							break;
						default:
							throw new Error(locale.text("datetime.formaty", repeat));
					}
				},
				S: function(repeat) {
					if (repeat === 3) result += _pad3(self.millisecond);
					else new Error(locale.text("datetime.formatS", repeat));
				}
			});
			return result;
		}
	},
	toJsDate: function() {
		return new Date(this._value);
	},
	withoutTimezoneOffset: function() {
		return new Datetime(this._value);
	},
	isNull: function() {
		return this._value == 0;
	}
});

function _formatTzOffset(offset, len) {
	var s = "-";
	if (offset < 0) {
		s = "+";
		offset = -offset;
	}
	var hr = Math.round(offset / 60);
	var min = offset - hr * 60;
	s += len > 1 ? _pad2(hr) : hr;
	s += len > 2 || min ? (":" + (len > 1 ? _pad2(min) : min)) : "";
	return s;
}

function _parseIso(str) {
	var year = 0,
		month = 0,
		day = 0,
		hours = 0,
		minutes = 0,
		seconds = 0,
		ms = 0,
		offset = 0,
		convertError = true;
	var d = /(\d{4})-(\d{2})-(\d{2})([T\s]?)(\d{2})?(:)?(\d{2})?(:)?(\d{2})?(\.(\d{3}))?(Z)?(([+-])(\d{2}))?(.*$)/.exec(str);
	if (d) {
		convertError = false;
		year = +d[1];
		month = d[2] - 1;
		day = +d[3];
		hours = +(d[5] || 0);
		minutes = +(d[7] || 0);
		seconds = +(d[9] || 0);
		ms = +(d[11] || 0);
		if (d[12] === "Z") {
			if (d[14] === '-') offset = (d[15] || 0) * 60;
			else if (d[14] === '+') offset = -(d[15] || 0) * 60;
			var utc = Date.UTC(year, month, day, hours, minutes + offset, seconds, ms);
			return new Datetime(utc);
		} else {
			var jsDate = new Date(year, month, day, hours, minutes + offset, seconds, ms);
			return new Datetime(jsDate.getTime(), jsDate.getTimezoneOffset());
		}
	}
	if (convertError) throw new Error(locale.text("datetime.noParse", str));
}

exports.now = function(withMillis) {
	var jsDate = new Date();
	var millis = jsDate.getTime();
	if (!withMillis) millis = Math.floor(millis / 1000) * 1000;
	return new Datetime(millis, jsDate.getTimezoneOffset());
};

exports.parse = function(str, format) {
	if (str == null) throw new Error(locale.text("datetime.isNull"));

	if (format == null) {
		return _parseIso(str);
	} else {
		return _parse(str, format);
	}
};

exports.fromJsDate = function(jsDate) {
	return new Datetime(jsDate.getTime(), jsDate.getTimezoneOffset());
};

exports.isDatetime = function(obj) {
	return obj instanceof Datetime;
};

exports.fromInternalValue = function(value) {
	return new Datetime(value);
};

exports.dayName = function(weekDay, abbrev) {
	return abbrev ? _dateInfo().abbreviatedDayNames[weekDay] : _dateInfo().dayNames[weekDay];
};

exports.monthName = function(month, abbrev) {
	return abbrev ? _dateInfo().abbreviatedMonthNames[month - 1] : _dateInfo().monthNames[month - 1];
};

function _make(year, month, day, hour, minute, second, millis) {
	var jsDate = new Date(year, month - 1, day, hour || 0, minute || 0, second || 0, millis || 0);
	return new Datetime(jsDate.getTime(), jsDate.getTimezoneOffset());
}

exports.make = _make;
exports.makeUtc = _makeUtc;

function _makeUtc(year, month, day, hour, minute, second, millis) {
	var jsDate = new Date(Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millis || 0));
	return new Datetime(jsDate.getTime(), jsDate.getTimezoneOffset());
}

// hack to install "at" method in date, without require cycles
date.make(1, 1, 1).constructor.prototype.at = function(time, millisecond) {
	return exports.make(this.year, this.month, this.day, time.hour, time.minute, time.second, millisecond);
};

exports.sunday = 0;
exports.Sunday = 0;
exports.monday = 1;
exports.Monday = 1;
exports.tuesday = 2;
exports.Tuesday = 2;
exports.wednesday = 3;
exports.Wednesday = 3;
exports.thursday = 4;
exports.Thursday = 4;
exports.friday = 5;
exports.Friday = 5;
exports.saturday = 6;
exports.Saturday = 6;

function _walkFormat(format, map) {
	var i = 0,
		len = format.length;

	function count(i) {
		var ch = format[i],
			k = 1;
		while (format[i + k] === ch)
			k++;
		return k;
	}

	while (i < len) {
		var c = format[i];
		switch (c) {
			case "'":
				i++;
				var literal = '';
				// going to the end of the following litteral or to the format end
				for (; i < len; i++) {
					if (format[i] === "'") {
						i++;
						// check wether the "'" is not doubled
						if (format[i] === "'") {
							literal += "'";
						} else break;
					} else {
						literal += format[i];
					}
				}
				map.literal(literal);
				break;
			case "H":
			case "h":
			case "m":
			case "s":
			case "S":
			case "t":
			case "d":
			case "M":
			case "y":
				var repeat = count(i);
				map[c](repeat);
				i += repeat;
				break;
			default:
				map.literal(c);
				i++;
		}
	}
}

exports.walkFormat = _walkFormat;

function _parse(str, format) {
	var day, weekday, month, year, hour, minute, second, millis, timeMode, abbrTimeMode;
	var timeModes = [date.amDesignator(), date.pmDesignator()];
	//var timeModes = _dateInfo().amDesignator ? [_dateInfo().amDesignator, _dateInfo().pmDesignator] : ["AM", "PM"];
	var abbrTimeModes = [timeModes[0].substring(0, 1), timeModes[1].substring(0, 1)];
	//var abbrTimeModes = _dateInfo().amDesignator ? [_dateInfo().amDesignator.substring(0, 1), _dateInfo().pmDesignator.substring(0, 1)] : ["A", "P"];

	// position in str
	var j = 0;

	function parseInteger(max) {
		if (!/\d/.test(str[j])) {
			throw new Error(locale.text("datetime.noNumber", str.substring[j]));
		}
		var beg = j++;
		while (j < beg + max && /\d/.test(str[j]))
			j++;
		return parseInt(str.substring(beg, j), 10);
	}

	function parseName(names) {
		for (var k = 0; k < names.length; k++) {
			var name = names[k],
				len = name.length;
			if (str.substring(j, j + len).toUpperCase() == name.toUpperCase()) {
				j += len;
				return k;
			}
		}
		throw new Error(locale.text("datetime.unknown", str.substring(j)));
	}

	_walkFormat(format, {
		literal: function(literal) {
			if (str.substring(j, j + literal.length) !== literal) throw new Error(locale.text("datetime.formatMis", literal, str.substring(j)));
			j += literal.length;
		},
		d: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					day = parseInteger(2);
					break;
				case 3:
					weekday = parseName(_dateInfo().abbreviatedDayNames);
					break;
				case 4:
					weekday = parseName(_dateInfo().dayNames);
					break;
				default:
					throw new Error(locale.text("datetime.badDay", format.substring(j))); // replaced i with j
			}
		},
		M: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					month = parseInteger(2);
					break;
				case 3:
					month = parseName(_dateInfo().abbreviatedMonthNames) + 1;
					break;
				case 4:
					month = parseName(_dateInfo().monthNames) + 1;
					break;
				default:
					throw new Error(locale.text("datetime.badDay", format.substring(j))); // replaced i with j
			}
		},
		y: function(arg) {
			switch (arg) {
				case 2:
					year = parseInteger(2);
					year = year < 40 ? 2000 + year : 1900 + year;
					break;
				case 4:
					year = parseInteger(4);
					year = year > 99 ? year : year < 40 ? 2000 + year : 1900 + year;
					break;
				default:
					throw new Error(locale.text("datetime.badYear", format.substring(j))); // replaced i with j
			}
		},
		H: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					hour = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("datetime.badHour", format.substring(j)));
			}
		},
		h: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					hour = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("datetime.badHour", format.substring(j)));
			}
		},
		m: function(arg) {
			switch (arg) {
				case 2:
					minute = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("datetime.badMin", format.substring(j)));
			}
		},
		s: function(arg) {
			switch (arg) {
				case 2:
					second = parseInteger(2);
					break;
				default:
					throw new Error(locale.text("datetime.badSec", format.substring(j)));
			}
		},
		t: function(arg) {
			switch (arg) {
				case 1:
					abbrTimeMode = parseName(abbrTimeModes);
					break;
				case 2:
					timeMode = parseName(timeModes);
					break;
				default:
					throw new Error(locale.text("datetime.badMarker", format.substring(j)));
			}
		}
	});

	// from 12 format to 24 format, used when necessary

	function from12to24(mode, index) {
		switch (mode[index]) {
			case mode[0]:
				// AM
				hour = hour === 12 ? 0 : hour;
				break;
			case mode[1]:
				// PM
				if (hour >= 1 && hour <= 11) {
					hour += 12;
				}
				break;
		}
	}

	if (timeMode != null || abbrTimeMode != null) {
		if (hour > 12) throw new Error(locale.text("datetime.badHourVal", hour, timeMode));
		var mode = timeMode != null ? timeModes : abbrTimeModes;
		var index = timeMode != null ? timeMode : abbrTimeMode;
		from12to24(mode, index);
	}

	// ignore weekday
	return _make(year, month, day, hour, minute, second, millis);
}

function _getIndexOfZ(format) {
	var i = 0,
		len = format.length;

	function count(i) {
		var ch = format[i],
			k = 1;
		while (format[i + k] === ch)
			k++;
		return k;
	}

	while (i < len) {
		var c = format[i];
		if (c === "'") {
			i++;
			var literal = '';
			// going to the end of the following litteral or to the format end
			for (; i < len; i++) {
				if (format[i] === "'") {
					i++;
					// check wether the "'" is not doubled
					if (format[i] === "'") {
						literal += "'";
					} else break;
				} else {
					literal += format[i];
				}
			}
		} else if (c === 'Z') {
			return i;
		} else {
			i++;
		}
	}
}
});

define('syracuse-tablet/html/js/helpers/types/numberFormat',['require','exports','module','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var locale = require("syracuse-tablet/html/js/helpers/locale");

//======================
//	Useful elements
//======================

/**
 * Format object used to handle format. Useful for the formatting and parsing methods
 * @param {Object} prefix	Any text before directives
 * @param {Object} postfix	Any text after directives
 * @param {Object} properties	Properties are : hasDecimalSeparator, hasGroupSeparator, mandatoryAfter, maxAfter, groupSize, mandatoryBefore, directive, hasPercent, hasPermil, hasSignFormat
 */
function FormatObj(prefix, postfix, properties) {
	this.prefix = prefix;
	this.postfix = postfix;
	this.properties = properties;
}

/**
 * Set number format properties from directive parameter.
 * @param {String}	directive
 * @param {Object}	fObj
 * @return {Object}	Returns a formatObj with properties set
 */
function _processDirective(directive, fObj) {
	// properties to set:   

	// result
	var f = new FormatObj(fObj.prefix, fObj.postfix, fObj.properties);

	var hasDecimalSeparator, hasGroupSeparator;

	var dsIndex = directive.indexOf('.');
	var gsIndex = directive.indexOf(',');

	// decimal and group separator properties
	f.properties.hasDecimalSeparator = hasDecimalSeparator = dsIndex > -1;
	f.properties.hasGroupSeparator = hasGroupSeparator = gsIndex > -1;

	// after properties	
	if (hasDecimalSeparator) {
		var decimal = directive.substring(dsIndex + 1);
		f.properties.mandatoryAfter = decimal.indexOf("0") > -1 ? decimal.match(/0/g).length : 0;
		f.properties.maxAfter = decimal.length;
	}

	// group size property
	if (hasGroupSeparator) {
		f.properties.groupSize = hasDecimalSeparator ? dsIndex - gsIndex - 1 : directive.substring(gsIndex + 1).length;
	}

	// before property
	var integer = hasDecimalSeparator ? directive.substring(0, dsIndex) : directive;
	f.properties.mandatoryBefore = integer.indexOf("0") > -1 ? integer.match(/0/g).length : 0;

	// directive
	f.properties.directive = directive;

	// percent/permil property
	f.properties.hasPercent = directive.indexOf("%") > -1;
	f.properties.hasPermil = directive.indexOf("‰") > -1;

	// sign format
	f.properties.hasSignFormat = directive.indexOf('+') > -1 && directive.indexOf('+') === 0;

	return f;
}

/**
 * Walk through the given format and run functions in map
 * @param {Object} format
 * @param {Object} map
 */
function _walkFormat(format, map) {
	var i = 0,
		len = format.length;

	// valid directive characters in format (except ';')
	var validDir = "0#.,%‰+"; //	'E' or 'e' are not supported yet
	function count(i) {
		var ch = format[i],
			k = 1;
		while (validDir.indexOf(format[i + k]) > -1)
			k++;
		return k;
	}

	while (i < len) {
		var c = format[i];
		switch (c) {
			case "'":
				i++;
				var literal = '';
				// going to the end of the following litteral or to the format end
				for (; i < len; i++) {
					if (format[i] === "'") {
						i++;
						// check wether the "'" is not doubled
						if (format[i] === "'") {
							literal += "'";
						} else break;
					} else {
						literal += format[i];
					}
				}
				map.literal(literal);
				break;
			case "0":
			case "#":
			case ".":
			case "%":
			case "‰":
			case "+":
				var directiveLength = count(i);
				map.directive(i, i + directiveLength);
				i += directiveLength;
				break;
			case ";":
				map.listSeparator();
				i++;
				break;
			default:
				map.literal(c);
				i++;
		}
		// at the end of the loop
		if (i === len) {
			map.listSeparator();
		}
	}
}

/**
 * Add separator parameter after every digits group of size value to the number paramater.
 * @param {Object} num
 * @param {Object} gs
 * @param {Object} size
 */
function _addSeparator(num, gs, size) {
	var result = "";
	var len = num.length;
	var c = "";
	var count = 0;
	for (var i = len - 1; i >= 0; i--) {
		c = num[i];
		result += c;
		++count;
		if ((count % size === 0) && i > 0) {
			result += gs;
		}
	}
	return result.split("").reverse().join("");
}

//======================
//	Format functions
//======================

/**
 * Forat a number
 * @param {Object} val	Raw number
 * @param {Object} format	Format to apply
 * @return {String} Returns a string value containing formatted number
 */
exports.format = function(val, format) {

	//	if (!val)
	//		throw new Error("empty number value");

	if (isNaN(val)) throw new Error(locale.text("numberFormat.notNumber", val));

	if (format == null) {
		val = val.toString();
		var dsIndex = val.indexOf('.');
		var hasDecimal = dsIndex > -1;
		var intPart = hasDecimal ? val.substring(0, dsIndex) : val;
		var decimalPart = hasDecimal ? val.substring(dsIndex + 1) : '';
		var gs = locale.getNumberGroupSeparator() || "";
		var ds = hasDecimal ? (locale.getNumberDecimalSeparator() || ".") : '';
		return _addSeparator(intPart, gs, 3) + ds + decimalPart;
	} else {
		return _format(val, format);
	}

};

function _format(val, format) {
	var prefix, postfix;
	// position in val
	var j = 0;
	// format list (used in case of list of formats separated with ';', empty otherwise)
	var formatsList = [];

	var directiveProcessed = false;

	var f = new FormatObj('', '', {});

	_walkFormat(format, {
		literal: function(literal) {
			// set prefix or postfix value
			directiveProcessed ? f.postfix += literal : f.prefix += literal;
		},
		directive: function(beg, end) {
			// get directive part of the format
			var directive = format.substring(beg, end);

			// process directive
			f = _processDirective(directive, f);

			directiveProcessed = true;
		},
		listSeparator: function() {
			directiveProcessed = false;
			formatsList.push(f);
			f = new FormatObj('', '', {});
			prefix = '';
			postfix = '';
		}
	});

	var flen = formatsList.length;
	switch (flen) {
		case 1:
			return _formatNumber(val, formatsList[0]);
			break;
		case 2:
		case 3:
			if (val === 0) return _formatZero(formatsList[2]);
			else return val < 0 ? _formatNumber(val.toString().substring(1), formatsList[1]) : _formatNumber(val, formatsList[0]);
			break;
		default:
			throw new Error(flen === 0 ? locale.text("numberFormat.noFormat") : locale.text("numberFormat.manyFormat"));
	}
}

function _formatZero(fObj) {
	return fObj.prefix;
}

function _formatNumber(num, fObj) {
	var res = '';

	// locale separators
	var gs = locale.getNumberGroupSeparator();
	var ds = locale.getNumberDecimalSeparator();

	var directive = fObj.properties.directive;

	// special case for percentages
	num = fObj.properties.hasPercent ? num * 100 : num;
	num = fObj.properties.hasPermil ? num * 1000 : num;

	// #6292 - Format can be wrong - TODO add a isValid method to format object
	if (directive == null) return num;

	// == decimal ==
	if (fObj.properties.hasDecimalSeparator) {
		var decimalPart = '';
		var maxAfter = fObj.properties.maxAfter;
		var decimalFormat = directive.substr(directive.indexOf('.') + 1, maxAfter);
		var decimalValue = num % 1;
		var decimalString = '' + decimalValue.toFixed(maxAfter);
		decimalString = decimalString.substring(decimalString.indexOf('.') + 1);
		for (var i = 0; i < maxAfter; i++) {
			var f = decimalFormat.charAt(i);
			var n = decimalString.charAt(i);
			if (f === '0') {
				decimalPart += n;
			} else if (f === '#' && n !== '0') {
				decimalPart += n;
			} else if (f === '#' && n === '0') { // end loop if only '0' left in decimalString
				var notParsed = decimalString.substring(i);
				if (notParsed.match('[1-9]')) decimalPart += n;
				else break;
			}
		}
		res = decimalPart ? ds + decimalPart : res; // in case of integer value, decimalPart --> ''
	} else {
		// it is possible to have decimal number and format not containing decimal separator
		num = Math.round(num);
	}

	// == integer ==
	var intPart = num < 0 ? '' + Math.ceil(num) : '' + Math.floor(num);
	intPart = intPart.replace(/[^\d]+/g, '');
	var intFormat = directive.indexOf('.') === -1 ? directive : directive.substring(0, directive.indexOf('.'));
	// padding if necessary
	if (intPart.length < fObj.properties.mandatoryBefore) {
		var missing = fObj.properties.mandatoryBefore - intPart.length;
		var toAdd = '';
		for (var i = 0; i < missing; i++) {
			toAdd += '0';
		}
		intPart = toAdd + intPart;
	}
	// adding group separator if needed
	if (fObj.properties.hasGroupSeparator) {
		if (fObj.properties.groupSize < intPart.length) {
			intPart = _addSeparator(intPart, gs, fObj.properties.groupSize);
		}
	}

	// in case of no mandatory digit before decimal separator, no character for int part
	intPart = (parseInt(intPart, 10) === 0 && fObj.properties.mandatoryBefore === 0) ? '' : intPart;

	intPart = intPart && num < 0 ? '-' + intPart : intPart;
	res = intPart + res;

	// == specific cases ==
	// sign format
	res = fObj.properties.hasSignFormat && num > 0 ? '+' + res : res;

	// percent and/or permil
	res += fObj.properties.hasPercent ? "%" : '';
	res += fObj.properties.hasPermil ? "‰" : '';

	return fObj.prefix + res + fObj.postfix;
}

//======================
//	Parsing functions
//======================

// * @param {Object} fn	Function called if number returned doesn't match with the integer type (only use)
// exports.parse = function(str, format, fn){
/**
 * Get a number from a formatted number string value
 * @param {Object} str	Formatted number
 * @param {Object} format	Format supposedly used
 * @return {Object}	Returns a number (integer : floor(number), decimal : BigDecimal, real : number)
 */
exports.parse = function(str, format) {
	if (!str) return 0;
	//throw new Error("number string is null");

	if (format == null) {
		return parseFloat(str);
	} else {
		return _parse(str, format);
	}
};

function _parse(str, format) {
	//format = /[0-9-+,.#eE%‰;()\s]/g.exec();
	var prefix, postfix;

	// position in str
	var j = 0;

	// format list (used in case of list of formats separated with ';', empty otherwise)
	var formatsList = [];

	var directiveProcessed = false;

	var f = new FormatObj('', '', {});

	_walkFormat(format, {
		literal: function(literal) {
			// set prefix or postfix value
			directiveProcessed ? f.postfix += literal : f.prefix += literal;
		},
		directive: function(beg, end) {
			// get directive part of the format
			var directive = format.substring(beg, end);

			// process directive
			f = _processDirective(directive, f);

			directiveProcessed = true;
		},
		listSeparator: function() {
			directiveProcessed = false;
			formatsList.push(f);
			f = new FormatObj('', '', {});
			prefix = '';
			postfix = '';
		}
	});

	return _parseFormats(str, formatsList);
}

function _parseFormats(str, formatsList, negative) {
	var flen = formatsList.length;
	var num;
	// locale separators
	var gs = locale.getNumberGroupSeparator();
	var ds = locale.getNumberDecimalSeparator();

	switch (flen) {
		case 1:
			var fObj = formatsList[0];
			var formatNumber = str;
			var integerPart, decimalPart;
			// extract prefix and postfix
			var prefix = fObj.prefix;
			var postfix = fObj.postfix;
			formatNumber = prefix ? formatNumber.substring(prefix.length) : formatNumber;
			formatNumber = postfix ? formatNumber.substring(0, formatNumber.length - postfix.length) : formatNumber;

			// splitting into integer and decimal parts
			var splitted = formatNumber.split(ds);
			// error : too many periods
			if (splitted.length > 2) throw new Error(locale.text("numberFormat.oneSep", formatNumber));
			// setting integer and decimal parts values
			integerPart = splitted[0] ? splitted[0].match(/[0-9]/g).join('') : '0';
			decimalPart = splitted.length > 1 ? splitted[1].match(/[0-9]/g).join('') : '';
			num = parseFloat(decimalPart ? integerPart + "." + decimalPart : integerPart);

			// == specific cases ==
			// negative value
			num = formatNumber.charAt(0) === '-' ? parseFloat('-' + num) : num;
			// percent or permil
			num = fObj.properties.hasPercent ? num / 100 : num;
			num = fObj.properties.hasPermil ? num / 1000 : num;
			// negative value set for list separator cases
			num = negative ? parseFloat('-' + num) : num;
			break;
		case 2:
		case 3:
			// valid characters in formatted number
			var validFormat = "1234567890" + ds + gs + "%‰-+"; // 'E' or 'e' are not supported yet
			var len = formatsList.length;
			var slen = str.length;

			for (var i = 0; i < len; i++) {
				var f = formatsList[i];
				var prefix = f.prefix;
				var postfix = f.postfix;

				var prefixDefined = prefix ? true : false;
				var postfixDefined = postfix ? true : false;

				var pre, post;

				pre = prefixDefined ? str.substring(0, prefix.length) : '';
				post = postfixDefined ? str.substring(slen - postfix.length) : '';

				if (((prefixDefined && !postfixDefined) && pre.indexOf(prefix) > -1) || ((prefixDefined && postfixDefined) && (pre.indexOf(prefix) > -1 && post.indexOf(postfix) > -1)) || ((!prefixDefined && postfixDefined) && post.indexOf(postfix) > -1) || ((!prefixDefined && !postfixDefined) && (validFormat.indexOf(str.charAt(0)) > -1 && validFormat.indexOf(str.charAt(slen - 1)) > -1))) {
					break;
				}
			}
			var flist = [];
			flist.push(formatsList[i]);
			switch (i) {
				case 0:
					num = _parseFormats(str, flist);
					break;
				case 1:
					num = _parseFormats(str, flist, true);
					break;
				case 2:
					num = 0;
					break;
				default:
					throw new Error(locale.text("numberFormat.cannotParse"));
			}
			break;
		default:
			throw new Error(flen === 0 ? locale.text("numberFormat.noFormat") : locale.text("numberFormat.manyFormats"));
	}
	return num;
}
});

define('syracuse-tablet/html/js/helpers/formatApi',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/types/date','syracuse-tablet/html/js/helpers/types/datetime','syracuse-tablet/html/js/helpers/types/time','syracuse-tablet/html/js/helpers/types/numberFormat'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var date = require('syracuse-tablet/html/js/helpers/types/date');
var datetime = require('syracuse-tablet/html/js/helpers/types/datetime');
var time = require('syracuse-tablet/html/js/helpers/types/time');
var numberFormat = require('syracuse-tablet/html/js/helpers/types/numberFormat');

var _cache = {};
var _cacheLocaleHash;

exports.getFormatter = function($type, $format) {
	if ($format == "$url") {
		// #6292 Some numeric field have $format = $url - AQMFIELDM
		// Formatter is skipped - TODO we should add a isValid method to format object
		return null;
	}
	var ctor = _formatters[$type];
	if (!ctor) {
		return null;
	}
	var curLocaleHash = locale.getCurrentLocaleHash();
	if (curLocaleHash !== _cacheLocaleHash) {
		_cacheLocaleHash = curLocaleHash;
		_cache = {};
	}
	var cache = _cache[$type];
	if (!cache) cache = _cache[$type] = {};
	var key = $format || "noformat";
	var fmt = cache[key];
	if (fmt) return fmt;
	fmt = new ctor($type, $format);
	cache[key] = fmt;
	return fmt;
};

var Formatter = utils.defineClass(function($type, $format) {
	this.$format = $format;
	this.$type = $type;
}, null, {

	_isEmpty: function(value) {
		if (value == null)
			return true;
		value = "" + value;
		value = value.trim();
		if (value === "")
			return true;
		return false;
	},

	/*
	 * Format a value for displaying
	 * This will be used on read only fields to format the internal value to a human readable localized pattern.
	 * Also, this will be used to format values in editable fields BEFORE putting the focus into the field for editing
	 *
	 */
	formatValue: function(value) {
		return value;
	},

	/*
	 * Format a value for editing it
	 *
	 * This will be used to format values in editable fields AFTER putting the focus into the field for editing.
	 *
	 * Example, in case of dates:
	 * A field displays "April, 1. 2014"
	 * Once the focus is put into the field, it will render the value as "01.04.2014" since it's easier to edit
	 */
	formatValueEdit: function(value) {
		return this.formatValue(value);
	},

	/* 
	 * Parse any kind of input string to the internal representation
	 */
	parseValue: function(value, errors) {
		errors.push("No parser for this type, return this dummy error to not override value by null");
	},

	getFormat: function() {
		return this.format;
	}
});

var DateFormatter = utils.defineClass(function($type, $format) {
	Formatter.call(this, $type, $format);
	this.format = locale.getDateFormat();
	this.twoDigitYearSwitch = 40;
}, Formatter, {
	_isEmpty: function(value) {
		if (value == null)
			return true;
		value = "" + value;
		value = value.trim();
		if (value === "")
			return true;

		if (value === "0000-00-00")
			return true;

		return false;
	},

	_checkShortYear: function(year) {
		if (year.year) {
			// Date object
			var y = year.year;
			if (y < 100) {
				year.add({
					years: y < this.twoDigitYearSwitch ? 2000 : 1900
				});
			}
		} else {
			// Number
			year = year > 99 ? year : (year < this.twoDigitYearSwitch ? 2000 + year : 1900 + year);
		}
		return year;
	},

	/**
	 * value expected to be a date string like "2014-08-19"
	 */
	formatValue: function(value) {
		if (this._isEmpty(value)) {
			return "";
		}

		var p = value.split(/[^\d]+/);
		var format;
		if (p.length >= 3) {
			p[0] = this._checkShortYear(+p[0]);
			var d = date.make(+p[0], +p[1], +p[2]);
			format = d.toString(this.format);
		} else {
			format = value;
		}
		return format;
	},
	parseValue: function(value, errors) {
		var fmt;
		if (this._isEmpty(value)) {
			return "";
		}
		try {
			fmt = date.parse(value, this.format);
			fmt = this._checkShortYear(fmt);
		} catch (e) {
			errors.push(locale.text("field.invalidInput", [this.format]));
			return value;
		}
		return fmt.toString("yyyy-MM-dd");
	}
});

var DateTimeFormatter = utils.defineClass(function($type, $format) {
	DateFormatter.call(this, $type, $format);
	this.format = locale.getDateTimeFormat();
}, DateFormatter, {
	_isEmpty: function(value) {
		if (value == null)
			return true;
		value = "" + value;
		value = value.trim();
		if (value === "")
			return true;

		if (value === "0000-00-00T00:00:00Z")
			return true;

		return false;
	},
	/**
	 * value expected to be a date string like "2010-10-13T13:25:03.424Z"
	 */
	formatValue: function(value) {
		if (this._isEmpty(value)) {
			return datetime.now().toString(this.format);
			//return "";
		}

		var p = value.split(/[^\d]+/);
		var format;
		if (p.length >= 6) {
			p[0] = this._checkShortYear(+p[0]);
			var d = datetime.make(+p[0], +p[1], +p[2], +p[3], +p[4], +p[5]);
			format = d.toString(this.format);
		} else {
			format = value;
		}
		return format;
	},
	parseValue: function(value, errors) {
		var fmt;
		if (this._isEmpty(value)) {
			return "";
		}

		try {
			fmt = datetime.parse(value, this.format);
			fmt = this._checkShortYear(fmt);
		} catch (e) {
			errors.push(locale.text("field.invalidInput", [this.format]));
			return value;
		}
		return fmt.toString("yyyy-MM-ddTHH:mm:ss.SSS") + "Z";
	}
});

var TimeFormatter = utils.defineClass(function($type, $format) {
	Formatter.call(this, $type, $format);
	if (this.$format === "TT") {
		this.format = locale.getTimeFormat();
	} else {
		this.format = locale.getTimeFormatShort();
	}
}, Formatter, {
	/**
	 * value expected to be a date string like "13:25:03"
	 */
	formatValue: function(value) {
		if (this._isEmpty(value)) {
			return "";
		}

		var p = value.split(/[^\d]+/);
		var format;
		if (p.length >= 2) {
			var t = time.make(+p[0], +p[1], +p[2]);
			format = t.toString(this.format);
		} else {
			format = value;
		}
		return format;
	},
	parseValue: function(value, errors) {
		if (this._isEmpty(value)) {
			return "";
		}
		var p = value.split(/[^\d]+/);
		if (p.length >= 1) {
			var t = time.make(+p[0], +p[1], +p[2]);
			return t.toString("HH:mm:ss");
		}
	}
});

var NumberFormatter = utils.defineClass(function($type, $format) {
	Formatter.call(this, $type, $format);
	this.format = this.$format || locale.getNumberFormat(this.$type);
}, Formatter, {
	/*
	 * value to be expected to be a number
	 */
	formatValue: function(value) {
		if (this._isEmpty(value)) {
			return "";
		}
		var format = numberFormat.format(value, this.format);
		return format;
	},
	parseValue: function(value, errors) {
		if (this._isEmpty(value)) {
			return "";
		}
		try {
			var fmt = numberFormat.parse(value, this.format);
		} catch (e) {
			errors.push(locale.text("field.invalidInput", [this.format]));
			return value;

		}
		return fmt;
	}
});

var _formatters = {
	"application/x-integer": NumberFormatter,
	"application/x-decimal": NumberFormatter,
	"application/x-real": NumberFormatter,

	"application/x-date": DateFormatter,
	"application/x-time": TimeFormatter,
	"application/x-datetime": DateTimeFormatter
};
});

define('syracuse-tablet/html/js/authoring/arrays/authArrayStatus',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/arrays/authArrayGeneral','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/fieldOperators','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authArrayGeneral = require('syracuse-tablet/html/js/authoring/arrays/authArrayGeneral');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _noValue = "$$novalue$$";
var _colorPalette = [{
	title: "primecolor",
	items: ["white", "sagegreen", "green", "darkgrey", "black", "purple", "blue", "orange"]
}, {
	title: "secondcolor",
	items: ["lightgreen", "medium-purple", "medium-grey", "grey", "skyblue"]
}, {
	title: "notifcolors",
	items: ["error", "alert", "warning", "info", "ok", "ko"]
}];

var _getColorPalette = function() {
	var _scan = function(items, array) {
		array = array || [];
		items.forEach(function(item) {
			if (item.items) {
				var items = _scan(item.items);
				array.push({
					title: item.title ? locale.text("status.palette." + item.title) : null,
					items: items
				});
			} else if (typeof item === "string") {
				array.push({
					name: locale.textNoFail("status.color." + item) || item.smCapitalize(),
					css: "s-m-color-" + item
				});
			}
		});
		return array;
	};
	return _scan(_colorPalette);
};

var _properties = {

	"arrayStatusEnabled": {
		"key": "$statusEnabled",
		"default": false,
		"values": [{
			"value": false,
		}, {
			"value": true
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio
	},

	"arrayStatus": function(controller, sel, data) {
		this.name = "arrayStatus";
		this.label = null;
		this["default"] = null;
		this.key = "$status";
		this.ctrlArray = data.control;
		this.isTable = (this.ctrlArray.article.$display || "table") === "table";
		this._myProperties = [];
		/** 
		 	data structure data.articleSelection.$status
		 		[{
					field: "BPCNUM",
					$type: "application/x-string",
					operator: "eq",
					value: 10,
					color:{
						name: "red",
						css: "s-m-color-ok",
						bgcolor: "#FF0000",
						color: "#FFFFFF"
					}
				}]
		*/
		this.initMarkup = function(controller, sel, data) {
			this._protoValue = this.ctrlArray.prototype.arrayTableGetColInfo();
			var authStatus = data.articleSelection[this.key] || [];
			this.statusList = [];
			var self = this,
				proto;
			authStatus.forEach(function(c) {
				proto = self.getFieldProto(c.field);
				if (proto != null) {
					c = $.extend({}, true, c);
					c.id = utils.UUID();
					self.statusList.push(c);
				}
			});
		};
		this.getFieldProto = function(bind) {
			var res = null;
			this._protoValue.some(function(v, idx) {
				if (v.$bind === bind) {
					res = v;
					return true;
				}
			});
			return res;
		};
		this.getRecordInfo = function(id) {
			if (!id) return null;
			var idx = -1;
			var rec = null;
			this.statusList.some(function(c, i) {
				if (c.id === id) {
					rec = c;
					idx = i;
					return true;
				}
			});
			return idx === -1 ? null : {
				record: rec,
				idx: idx
			};
		};
		this.destroyMarkup = function() {
			this.ctrl = null;
			this.$$parent = null;
			this._protoValue = null;
			this.ctrlArray = null;
			if (this._myProperties) {
				this._myProperties.forEach(function(p) {
					if (p.destroyMarkup) p.destroyMarkup();
				});
				this._myProperties = null;
			}
		};

		this.createMarkup = function($$parent, prop, sel, data) {
			this.ctrl = data.control;
			this.$$parent = $$parent;
			this.statusListAdd(sel, data);
			this.editSectionAdd();
		};
		this.statusListAdd = function(sel, data) {
			var opts = {
				css: "statuslist",
				doAction: jsutils.bindFn(this.listCallBackAction, this, sel, data),
				appendTitle: locale.text("auth.arrayStatus.append")
			};
			this.listStatusDisplayer = authComponents.newComponent("editableList", opts);
			this._addParam("statuslist", this.listStatusDisplayer, true);
			this.updateStatusList();
		};
		this.editSectionAdd = function() {
			this.editStatusSection = this._addSubSection("editstatus");
			this.editStatusSection.$$panel.hide();
			this.editStatusSection.$$content.css("padding-left", "7px");
			this.editStatusSection.$$title.css("font-weight", "bold");
			var $$rootComponents = this.editStatusSection.$$content;
			this.paramFieldAdd($$rootComponents);
			this.paramOperatorAdd($$rootComponents);
			this.paramValueAdd($$rootComponents);
			this.paramColorAdd($$rootComponents);
			this.paramIconAdd($$rootComponents);
		};
		this.listCallBackAction = function(action, recordId, listStatusDisplayer, sel, data) {
			if (action === "append") {
				this._updateParams(null);
				return true;
			}
			if (action === "cancel") {
				this._resetParams();
				this.editStatusSection.$$panel.hide();
				return true;
			}
			var recInfo = this.getRecordInfo(recordId);
			if (action === "validate") {
				var newRecord = this.validateRecord(true);
				if (newRecord) {
					if (recInfo == null) {
						// Validate Append
						this.statusList.push(newRecord);
					} else {
						// Validate Edit
						this.statusList.splice(recInfo.idx, 1);
						this.statusList.splice(recInfo.idx, 0, newRecord);
					}
					this.updateStatusList(true, sel, data);
					// Clears params
					this._resetParams();
					// Removes validate/cancel - Switchs to e'Append status'
					return true;
				} else {
					return false;
				}
			}
			if (action === "deleteItem") {
				if (!recInfo) return false;
				this.statusList.splice(recInfo.idx, 1);
				this.updateStatusList(true, sel, data);
				return true;
			}
			if (action === "editItem") {
				if (!recInfo) return false;
				this._updateParams(recInfo.record);
				return true;
			}
		};
		this.validateRecord = function(errorMsg) {
			var self = this;
			var _fail = function(msg) {
				if (errorMsg === true) {
					var text = msg || locale.text("auth.arrayStatus.invalid");
					self.listStatusDisplayer.toggleMessage(text, "error");
					setTimeout(function() {
						self.listStatusDisplayer.toggleMessage(null);
					}, 2500);
				}
				return null;
			};
			var rec = {};
			rec.field = this.fieldSelector.getValue();
			rec.operator = this.operatorSelector.getValue();
			var proto = this.getFieldProto(rec.field);
			if (!proto) {
				return _fail();
			}
			rec.$type = proto.$type;
			rec.$format = proto.$format;
			rec.value = this.$$valueElmt.val() || "";
			var formatter = formatApi.getFormatter(rec.$type, proto.$format);
			if (formatter) {
				var errors = [];
				rec.value = formatter.parseValue(rec.value, errors);
				if (errors.length > 0) {
					return _fail(errors.join(''));
				}
				if (rec.value != null && rec.value != this.$$valueElmt.val()) {
					this.$$valueElmt.val(formatter.formatValueEdit(rec.value));
				}
			}
			if (rec.$type == "application/x-reference") {
				rec.value = (rec.value || "").toUpperCase();
			}
			if (this.paletteColor) {
				rec.color = this.paletteColor.getValue();
			}
			if (this.paletteIcon) {
				rec.icon = this.paletteIcon.getValue();
			}
			rec.id = utils.UUID();
			if (rec.field == _noValue || rec.operator == _noValue || rec.color == null) {
				return _fail();
			}
			return rec;
		};
		this._updateParams = function(record) {
			var edit = record != null;
			record = record || {};
			this.editStatusSection.$$panel.show();
			this.fieldSelector.setValue(record.field || _noValue);
			this.updateOperators(record.$type, record.operator || _noValue);
			if (this.paletteColor) {
				this.paletteColor.setValue(record.color);
			}
			if (this.paletteIcon) {
				this.paletteIcon.setValue(record.icon);
			}
			var val = record.value;
			if (val != null) {
				var formatter = formatApi.getFormatter(record.$type, record.$format);
				val = formatter ? formatter.formatValueEdit(val) : val;
			}
			this.$$valueElmt.val(val == null ? "" : val);
		};
		this._resetParams = function() {
			this.editStatusSection.$$panel.hide();
			this.fieldSelector.setValue(_noValue);
			this.operatorSelector.clear();
			this.paletteColor.setValue("");
			this.$$valueElmt.val("");
		};
		this.updateStatusList = function(updateAuthoring, sel, data) {
			var clearBefore = true;
			if (clearBefore) {
				this.listStatusDisplayer.clear();
			}
			var records = [],
				style, css;
			this.statusList.forEach(function(c) {
				if (c.icon) {
					css = c.icon.css;
					style = "color:" + c.color.bgColor + ";font-size:1.4em;";
				} else {
					css = c.color ? c.color.css : "";
					style = "";
				}
				records.push({
					titleHtml: authArrayGeneral.getHtml("statusLine", {
						field: c.field,
						operator: c.operator,
						value: c.value,
						css: css,
						style: style,
						sizeColor: 15
					}),
					id: c.id
				});
			});
			this.listStatusDisplayer.insertRecords(records);
			if (updateAuthoring == true) {
				var value = [];
				this.statusList.forEach(function(c) {
					c = $.extend({}, true, c);
					delete c.id;
					value.push(c);
				});
				authPropsGeneral.setValue(this, sel, data, value);
				authPropsGeneral.notifyChangePropUI(this.$$parent, sel, data);
				return;
			}
		};
		this.paramFieldAdd = function($$root) {
			var selectOpts = [{
				"title": locale.text('auth.arrayStatus.novalue'),
				"value": _noValue
			}];
			this._protoValue.forEach(function(v, idx) {
				if (fieldOperators.acceptOperator(v.$type)) {
					selectOpts.push({
						title: v.$title,
						value: v.$bind
					});
				}
			});
			var opts = {
				value: _noValue,
				options: selectOpts,
				css: "statusField",
				onChange: jsutils.bindFn(this.onParamFieldSelect, this),
				isHidden: false
			};
			this.fieldSelector = authComponents.newComponent("select", opts);
			this._addParam("field", this.fieldSelector, true, $$root, true);
		};

		this.paramOperatorAdd = function($$root) {
			var opts = {
				value: _noValue,
				options: [{
					"title": locale.text('auth.arrayStatus.novalue'),
					"value": _noValue
				}],
				css: "statusOperator",
				onChange: jsutils.bindFn(this.onParamOperatorSelect, this),
				isHidden: false
			};
			this.operatorSelector = authComponents.newComponent("select", opts);
			this._addParam("operator", this.operatorSelector, true, $$root, true);
			this.updateOperators();
		};
		this.paramValueAdd = function($$root) {
			this.$$valueElmt = $('<input class="form-control statusValue"></input>');
			this._addParam("value", this.$$valueElmt, true, $$root);
		};
		this.paramColorAdd = function($$root) {
			var opts = {
				palette: _getColorPalette(),
				dropUp: true
			};
			this.paletteColor = authComponents.newComponent("colorPalettePicker", opts);
			this._addParam("color", this.paletteColor, true, $$root, true);
		};
		this.paramIconAdd = function($$root) {
			var opts = {
				palette: fontUtils.getArrayStatusIconList(),
				dropUp: true
			};
			this.paletteIcon = authComponents.newComponent("iconPalettePicker", opts);
			this._addParam("icon", this.paletteIcon, true, $$root, false);
		};
		this.onParamFieldSelect = function(event, prop) {
			var field = this.getFieldProto($(event.target).val());
			this.updateOperators(field.$type, "eq");
		};
		this.updateOperators = function(typeField, defValue) {
			defValue = defValue == null ? _noValue : defValue;
			var selectOpts = [{
				"title": locale.text('auth.arrayStatus.novalue'),
				"value": _noValue
			}];
			var ops = fieldOperators.getOperators(typeField, true);
			if (ops) {
				ops.forEach(function(v, idx) {
					selectOpts.push({
						title: v.title,
						value: v.value
					});
				});
			}
			this.operatorSelector.update(selectOpts, defValue);
		};
		this.onParamOperatorSelect = function(event, prop) {};
		this._addParam = function(prop, component, title, $$parent, mandatory) {
			var $$parent = $$parent || this.$$parent;
			var $$title;
			var $$root;
			if (title) {
				var res = this._addSubSection(prop, $$parent, mandatory);
				$$root = res.$$content;
				$$title = res.$$panel;
			} else {
				$$root = $$parent;
			}
			if (component == null) throw new Error("unexpected null component");
			var $$panel;
			if (component.createMarkup) {
				component.createMarkup($$root);
				this._myProperties.push(component);
				$$panel = component.$$panel;
			} else if (component.jquery) {
				$$root.append(component);
				$$panel = component;
			}
			return $$title ? $$title : $$panel;
		};
		this._addSubSection = function(textId, $$parent, mandatory) {
			var $$panel = $(authArrayGeneral.getHtml('subtitle', {
				title: locale.text('auth.arrayStatus.' + textId) + (mandatory === true ? "*" : ""),
				margin: 10,
				id: "arrayStatus" + textId.smCapitalize()
			})).appendTo($$parent || this.$$parent);
			return {
				$$panel: $$panel,
				$$content: $$panel.children("div"),
				$$title: $$panel.children("p")
			};
		};
	}
};

exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	if (!controller.prototype.isLookup()) {
		props.push(_properties.arrayStatusEnabled);
		if (data.control.getAuthoring("$statusEnabled") == true) {
			props.push(_properties.arrayStatus);
		}
	}
};
});

define('syracuse-tablet/html/js/authoring/arrays/authoringPropertiesArrays',['require','exports','module','syracuse-tablet/html/js/authoring/arrays/authArrayGeneral','syracuse-tablet/html/js/authoring/arrays/authArrayTable','syracuse-tablet/html/js/authoring/arrays/authArrayCard','syracuse-tablet/html/js/authoring/arrays/authArrayStatus'],function (require, exports, module) {
var authArrayGeneral = require('syracuse-tablet/html/js/authoring/arrays/authArrayGeneral');
var authArrayTable = require('syracuse-tablet/html/js/authoring/arrays/authArrayTable');
var authArrayCard = require('syracuse-tablet/html/js/authoring/arrays/authArrayCard');
var authArrayStatus = require('syracuse-tablet/html/js/authoring/arrays/authArrayStatus');

exports.initModuleProperties = function(dest) {
	authArrayGeneral.initModuleProperties(dest);
	authArrayCard.initModuleProperties(dest);
	authArrayTable.initModuleProperties(dest);
	authArrayStatus.initModuleProperties(dest);
};

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	// Commons settings
	authArrayGeneral.getModuleProperties($$elmt, controller, props, sel, data);
	// Design cards/Columns
	if (authArrayGeneral.checkDisplay(sel, data, "card")) {
		authArrayCard.getModuleProperties($$elmt, controller, props, sel, data);
	} else if (authArrayGeneral.checkDisplay(sel, data, "table")) {
		if (!data.control.prototype.isSingleArray()) {
			authArrayTable.getModuleProperties($$elmt, controller, props, sel, data);
		}
	}
	// Status management on cards and tables
	authArrayStatus.getModuleProperties($$elmt, controller, props, sel, data);
};
});

define('syracuse-tablet/html/js/authoring/authoringPropertiesGauge',['require','exports','module','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral'],function (require, exports, module) {

var locale = require('syracuse-tablet/html/js/helpers/locale');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');

var _err = authPropsGeneral.err;
var maxSegments = 5;

var _properties = {
	/*
	 *	Display numeric data either as normal number field or as gauge
	 */
	"numDisplay": {
		"key": "$numDisplay",
		"default": "normal",
		values: [{
			value: "normal"
		}, {
			value: "gauge"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Sets gauge range (min/max) values origin. Either "default", "bind", or "value"
	 *	- default : gauge component default range values
	 *	- bind : use one field value as range value
	 *	- value : user specified directly range values in input field
	 */
	"gSetBorderValues": {
		"key": "$gSetBorderValues",
		"default": "default",
		values: [{
			value: "default"
		}, {
			value: "value"
		}, {
			value: "bind"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio,
		type: "child"
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Set border values (min/max). It will be either a textarea or a selector
	 */
	"gBorderValues": {
		"default": "",
		createMarkup: _createMarkupGBorderValues,
		type: "child"
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Number of gauge segmets
	 */
	"gSegmentsNumber": {
		"default": "",
		createMarkup: _createMarkupGSegmentsNumbers,
		type: "child"
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Configure gauge segments
	 */
	"gSegmentsConfig": {
		"default": "",
		createMarkup: _createMarkupGSegmentsConfig,
		type: "child",
		destroyMarkup: _destroySlider
	},
	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Apply button for segments configuration
	 */
	"gSegmentsConfigApply": {
		applyMarkup: _createMarkupApply
	}
};



function _createMarkupGBorderValues($$parent, prop, sel, data) {
	var ctx = {};
	ctx.label_apply = locale.text("auth.g.label_apply");
	var idMin = "s-m-auth-g-borders-min";
	var idMax = "s-m-auth-g-borders-max";

	// markup depends if border is value or bind
	var isProperty = data.articleSelection.$gSetBorderValues === "bind" ? true : false;

	// if property, build a selection markup, filled with numeric types within the prototype
	if (isProperty) {
		var valMin = data.articleSelection.$gauge.$bindMin;
		var valMax = data.articleSelection.$gauge.$bindMax;

		ctx.label_tip = locale.text("auth.gBorderValues.label_tip.property");
		ctx.label_min = locale.text("auth.gBorderValues.label_min.property");
		ctx.label_max = locale.text("auth.gBorderValues.label_max.property");

		// get number properties from prototype
		var optionsMin = [];
		var optionsMax = [];
		if (data.control.controller.prototype && data.control.controller.prototype.json && data.control.controller.prototype.json.$properties) {
			$.each(data.control.controller.prototype.json.$properties, function(bind, value) {
				if ((value.$type.indexOf("integer") >= 0 || value.$type.indexOf("decimal") >= 0 || value.$type.indexOf("real") >= 0) && bind !== data.control.$bind && bind !== data.articleSelection.$bind) {
					optionsMin.push({
						option_value: bind,
						selected: valMin === bind
					});
					optionsMax.push({
						option_value: bind,
						selected: valMax === bind
					});
				}
			});

			ctx.markupMin = authHtml.execute("gaugeSelect", {
				id: idMin,
				options: optionsMin
			});

			ctx.markupMax = authHtml.execute("gaugeSelect", {
				id: idMax,
				options: optionsMax
			});
		} else {
			_err(locale.text("auth.gBorderValues.err.prototype.title"), locale.text("auth.gBorderValues.err.prototype.msg"));
			return;
		}

	}

	// if input, build input markup
	else {
		var valMin, valMax;
		// set valMin considering that user switched from "property" to "input"
		if (data.articleSelection.$gauge.$bindMin && typeof data.articleSelection.$gauge.$bindMin == "string") {
			valMin = data.control.controller.dao.data[data.articleSelection.$gauge.$bindMin];
		} else {
			valMin = data.articleSelection.$gauge.$bindMin;
		}

		// set valMax considering that user switched from "property" to "input"
		if (data.articleSelection.$gauge.$bindMax && typeof data.articleSelection.$gauge.$bindMax == "string") {
			valMax = data.control.controller.dao.data[data.articleSelection.$gauge.$bindMax];
		} else {
			valMax = data.articleSelection.$gauge.$bindMax;
		}

		ctx.label_tip = locale.text("auth.gBorderValues.label_tip.input");
		ctx.label_min = locale.text("auth.gBorderValues.label_min.input");
		ctx.label_max = locale.text("auth.gBorderValues.label_max.input");
		ctx.markupMin = authHtml.execute("gaugeBorderInput", {
			id: idMin,
			value: valMin
		});
		ctx.markupMax = authHtml.execute("gaugeBorderInput", {
			id: idMax,
			value: valMax
		});
	}

	var html = authHtml.execute("authPanelPropertyGBorderValues", ctx);
	var $$panel = $(html);

	// /!\ In bind, allow use of 0
	// onclick, update data and refresh
	$("button", $$panel).on("click", function(e) {
		var err = false;
		var vvMin = $(e.target).parent().find("#" + idMin).val();
		var vvMax = $(e.target).parent().find("#" + idMax).val();
		var errTitle = locale.text("auth.gBorderValues.err.title");

		// min and max are both numbers
		if (!isNaN(parseInt(vvMin), 10) && !isNaN(parseInt(vvMax), 10)) {

			if (vvMax < vvMin) {
				err = _err(errTitle, locale.text("auth.gBorderValues.err.msg.lowerMax", [vvMax, vvMin]));
			}
			// else, all good. update value
		} else {

			// min and max should both be string values
			if (!(typeof vvMin == "string" && typeof vvMax == "string")) {
				err = _err(errTitle, locale.text("auth.gBorderValues.err.msg.bothString", [vvMin, vvMax]));
			}

			// if min and max are supposed to be numbers
			if (!isProperty) {
				err = _err(errTitle, locale.text("auth.gBorderValues.err.msg.expectedNumbers", [vvMin, vvMax]));
			}

			if (vvMin === vvMax) {
				err = _err(errTitle, locale.text("auth.gBorderValues.err.msg.samebind"));
			}

			// TODO maybe another control ?

			// else, all good. update value
		}

		if (!err) {
			data.articleSelection.$gauge.$bindMin = vvMin;
			data.articleSelection.$gauge.$bindMax = vvMax;
			authPropsGeneral.notifyChangePropUI($$parent, sel, data);
		}
	});

	// append html
	$$parent.append($$panel);
}


function _createMarkupGSegmentsNumbers($$parent, prop, sel, data) {
	// build html
	var value = data.articleSelection.$gauge.segments ? data.articleSelection.$gauge.segments.length : "";
	var options = [];
	for (var ii = 0, jj = (maxSegments + 1); ii < jj; ii++) {
		var opt = {};
		if (ii == 0) {
			opt.option_value = locale.text("auth.gSegmentsNumber.default");
			opt.selected = value ? true : false;
		} else {
			opt.option_value = ii;
			opt.selected = value == ii;
		}
		options.push(opt);
	}
	var ctx = {
		value: authHtml.execute("gaugeSelect", {
			id: "s-m-auth-g-segnumbers-txt",
			options: options
		}),
		label_apply: locale.text("auth.g.label_apply")

	};

	var html = authHtml.execute("authPanelPropertyGSegmentsNumber", ctx);
	var $$panel = $(html);


	// bind click on apply button
	// onclick, update data and refresh
	$("button", $$panel).on("click", function(e) {

		var vv = $(e.target).prev().val();

		if (value != vv) {
			if (vv && isNaN(parseInt(vv, 10))) {
				_err(locale.text("auth.gSegmentsNumber.err.title"), locale.text("auth.gSegmentsNumber.err.msg.expectedNumber", [vv]));
			} else {
				if (vv) {
					data.articleSelection.$gauge.segments = data.articleSelection.$gauge.segments || [];
					if (data.articleSelection.$gauge.segments.length > vv) {
						data.articleSelection.$gauge.segments.splice(vv);
					}
					for (var ii = 0, jj = vv; ii < jj; ii++) {
						data.articleSelection.$gauge.segments[ii] = data.articleSelection.$gauge.segments[ii] || {};
					}
				} else {
					data.articleSelection.$gauge.segments = null;
				}
				authPropsGeneral.notifyChangePropUI($$parent, sel, data);
			}
		}
	});

	// append html
	$$parent.append($$panel);
}

function _createMarkupGSegmentsConfig($$parent, prop, sel, data) {

	// build html

	var seg = data.articleSelection.$gauge.segments[prop.segIdx];
	var idRoot = "s-m-auth-seg-";
	var idx = prop.segIdx;

	var segInfo = {};
	segInfo.id = idRoot + idx;

	segInfo.label_valstart = locale.text("auth.gSegmentsConfig.label_valstart");
	segInfo.value_valstart = seg.valStart;

	segInfo.label_valend = locale.text("auth.gSegmentsConfig.label_valend");
	segInfo.value_valend = seg.valEnd;

	segInfo.label_propstart = locale.text("auth.gSegmentsConfig.label_propstart");
	segInfo.value_propstart = authHtml.execute("authPanelGaugeSlider", {
		id: segInfo.id + "-propstart",
		min: 0,
		max: 1,
		step: 0.1,
		value: seg.propStart
	});

	segInfo.label_propend = locale.text("auth.gSegmentsConfig.label_propend");
	segInfo.value_propend = authHtml.execute("authPanelGaugeSlider", {
		id: segInfo.id + "-propend",
		min: 0,
		max: 1,
		step: 0.1,
		value: seg.propEnd
	});

	segInfo.label_color = locale.text("auth.gSegmentsConfig.label_color");
	segInfo.value_color = seg.color;
	segInfo.label_apply = locale.text("auth.g.label_apply");

	var html = authHtml.execute("gaugeSegment", segInfo);
	var $$panel = $(html);

	/*
	 *	Bind events
	 */
	// generate slider
	var $$rangeInputArr = $("input.s-m-auth-g-range", $$panel);
	$$rangeInputArr.slider();
	// update range output value
	$$rangeInputArr.on("slide", function(slideEvt) {
		var $$input = $(slideEvt.target);
		var $$output = $$input.next();
		$$output.text(slideEvt.value);
	});

	$$parent.append($$panel);
}

function _createMarkupApply($$parent, prop, sel, data) {
	var html = authHtml.execute("authPanelButton", {
		label: locale.text("auth.gSegmentsConfigApply.label"),
		css: "s-m-auth-g-apply"
	});
	var $$panel = $(html);

	/* bind click on button. apply segments configuration */
	$("button", $$panel).on("click", function(e) {
		var segs = [];
		var $$segments = $(e.target).parent().parent().find(".s-m-auth-seg-slot");
		for (var ii = 0, jj = $$segments.length; ii < jj; ii++) {
			var $$seg = $($$segments[ii]);
			var id = $$seg.attr("id");
			var segInfo = {};
			segInfo.valStart = $("#" + id + "-valstart", $$seg).val();
			segInfo.valEnd = $("#" + id + "-valend", $$seg).val();
			segInfo.propStart = $("#" + id + "-propstart", $$seg).val();
			segInfo.propEnd = $("#" + id + "-propend", $$seg).val();
			segInfo.color = $("#" + id + "-color", $$seg).val();

			// if valStart, valEnd, propStart, propEnd, color value == "", set it to null 
			// this is necessary to comply with the gauge ctrl behavior
			segInfo.valStart = segInfo.valStart === "" ? null : segInfo.valStart;
			segInfo.valEnd = segInfo.valEnd === "" ? null : segInfo.valEnd;
			segInfo.propStart = segInfo.propStart === "" ? null : segInfo.propStart;
			segInfo.propEnd = segInfo.propEnd === "" ? null : segInfo.propEnd;
			segInfo.color = segInfo.color === "" ? null : segInfo.color;

			// check if valStart and valEnd are numeric values
			var vStart = segInfo.valStart;
			var vEnd = segInfo.valEnd;
			if (vStart && isNaN(parseInt(vStart.replace(".", "").replace(",", ""), 10))) {
				_err(locale.text("auth.gSegmentsConfig.err.title"), locale.text("auth.gSegmentsConfig.err.msg.expectedNumber", [locale.text("auth.gSegmentsConfig.label_valstart"), vStart]));
				return;
			}
			if (vEnd && isNaN(parseInt(vEnd.replace(".", "").replace(",", ""), 10))) {
				_err(locale.text("auth.gSegmentsConfig.err.title"), locale.text("auth.gSegmentsConfig.err.msg.expectedNumber", [locale.text("auth.gSegmentsConfig.label_valend"), vEnd]));
				return;
			}
			segs.push(segInfo);
		}
		data.articleSelection.$gauge.segments = segs;
		authPropsGeneral.notifyChangePropUI($$parent, sel, data);
	});

	$$parent.append($$panel);
}

function _destroySlider($$parent, prop) {
	var $$slider = $$parent.find('input.s-m-auth-g-range');
	if ($$slider.length > 0 && $$slider.slider) {
		$$slider.slider('destroy');
	}
}



function _getModuleProperties($$elmt, controller, props, sel, data) {

	if (data.type === "integer" || data.type === "real" || data.type === "decimal") {

		var isGauge;

		if (data.articleSelection.$numDisplay) {
			isGauge = data.articleSelection.$numDisplay === "gauge";
		} else {
			// set $numDisplay article value if not set
			isGauge = data.articleSelection.$gauge ? true : false;
			data.articleSelection.$numDisplay = isGauge ? "gauge" : "normal";
		}

		props.push(_properties.numDisplay);

		// push gauge authoring properties according to article values
		if (isGauge) {

			if (!data.articleSelection.$gSetBorderValues) {
				// set the value of "gSetBorderValues" property
				if (data.articleSelection.$gauge.$bindMax) {
					data.articleSelection.$gSetBorderValues = typeof data.articleSelection.$gauge.$bindMax == "string" ? "bind" : "value";
				} else {
					data.articleSelection.$gSetBorderValues = "default";
				}
			}

			// add "gSetBorderValues" property
			props.push(_properties.gSetBorderValues);

			// if "gSetBorderValues" is not "default"
			// add "gBorderValues" properties
			if (data.articleSelection.$gSetBorderValues !== "default") {
				props.push(_properties.gBorderValues);
			}

			// add "gSegmentsNumber" property
			props.push(_properties.gSegmentsNumber);

			// add segments if necessary
			if (data.articleSelection.$gauge.segments && data.articleSelection.$gauge.segments.length > 0) {
				for (var ii = 0, jj = data.articleSelection.$gauge.segments.length; ii < jj; ii++) {
					var name = "gSegmentsConfig" + ii;
					_properties[name] = {
						"default": "",
						createMarkup: _createMarkupGSegmentsConfig,
						type: "child-child",
						destroyMarkup: _destroySlider,
						label: locale.text("auth.gSegmentsConfig", [(ii + 1)]),
						segIdx: ii,
						name: name
					};
					props.push(_properties[name]);
				}
				props.push(_properties.gSegmentsConfigApply);
			}
		}
	}
}

exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};
exports.getModuleProperties = _getModuleProperties;
});

define('syracuse-tablet/html/js/authoring/authoringPropertiesChart',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral'],function (require, exports, module) {

var authUtils = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var _err = authUtils.err;


var _properties = {

};

exports.initModuleProperties = function(dest) {
	authUtils.initProperties(_properties, dest);
};
exports.getModuleProperties = function($$elmt, controller, props, sel, data) {

};
});

define('syracuse-tablet/html/js/authoring/authoringPropertiesCtrls',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/arrays/authoringPropertiesArrays','syracuse-tablet/html/js/authoring/authoringPropertiesGauge','syracuse-tablet/html/js/authoring/authoringPropertiesChart','syracuse-tablet/html/js/authoring/authoringComponents','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var authUtils = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authoringPropertiesArrays = require('syracuse-tablet/html/js/authoring/arrays/authoringPropertiesArrays');
var authoringPropertiesGauge = require('syracuse-tablet/html/js/authoring/authoringPropertiesGauge');
var authoringPropertiesChart = require('syracuse-tablet/html/js/authoring/authoringPropertiesChart');
var authComponents = require('syracuse-tablet/html/js/authoring/authoringComponents');
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _modules = [authoringPropertiesArrays, authoringPropertiesGauge];

var _ctrlFieldsProperties = {
	/*
	 * Title hidden
	 */
	"isTitleHidden": {
		"key": "$isTitleHidden",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: authUtils.createMarkupRadio,
		type: "default" // Default, just for header color selection
	},

	/* 
	 * Position of label
	 * left:   <label> <value>
	 *
	 * top:    <label>
	 * 		   <value>
	 */
	"labelPosition": {
		"key": "$labelPosition",
		"default": "left",
		"values": [{
			"value": "left"
		}, {
			"value": "top"
		}],
		createMarkup: authUtils.createMarkupRadio
	},

	/* 
	 * Text alignment of label
	 * left:   |<label>      |
	 * right:  |      <value>|
	 */
	"labelAlign": {
		"key": "$labelAlign",
		"default": "left",
		"values": [{
			"value": "left"
		}, {
			"value": "center",
			"isHidden": true
		}, {
			"value": "right"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	},

	/* 
	 * Theme for control
	 */
	"theme": {
		"key": "$theme",
		"default": "a",
		"values": [{
			"value": "a"
		}, {
			"value": "b"
		}, {
			"value": "c"
		}],
		createMarkup: authUtils.createMarkupRadio
	},

	/*
	 * Reference field description position
	 * bottom: <value>
	 *         <desc>
	 *
	 * right:  <value> <desc>
	 * left:   <desc> <value>
	 *
	 * top:    <desc>
	 *         <value>
	 */
	"refDescPosition": {
		"key": "$refDescPosition",
		"default": "right",
		"values": [{
			"value": "bottom"
		}, {
			"value": "right"
		}, {
			"value": "left"
		}, {
			"value": "top"
		}, {
			"value": "none"
		}],
		createMarkup: authUtils.createMarkupRadio
	},

	/*
	 * Reference field description format
	 * desc:      <desc>
	 *         
	 * title:     <title>

	 * desctitle: <desc> - <title>
	 * -> If both values are equal, skip display of second value
	 * 
	 * titledesc: <title> - <desc>
	 * -> If both values are equal, skip display of second value
	 */
	"refDescFormat": {
		"key": "$refDescFormat",
		"default": "desc",
		"values": [{
			"value": "desc"
		}, {
			"value": "title"
		}, {
			"value": "desctitle"
		}, {
			"value": "titledesc"
		}],
		createMarkup: authUtils.createMarkupRadio
	},
	// only CLOB field (text plain, text html, text rtf)
	"textHeight": {
		"key": "$textHeight",
		"default": "medium",
		values: [{
			value: "small"
		}, {
			value: "medium"
		}, {
			value: "large"
		}, {
			value: "xlarge"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	},
	"emptyImageIcon": {
		"key": "$emptyImageIcon",
		"default": fontUtils.getEmptyImageDefIcon(),
		"values": fontUtils.getEmptyImageIconList(),
		createMarkup: authUtils.createMarkupIconPicker,
		destroyMarkup: authUtils.destroyMarkupIconPicker
	},
	"emptyIconSize": {
		"key": "$emptyIconSize",
		"default": "small",
		values: [{
			value: "small"
		}, {
			value: "medium"
		}, {
			value: "large"
		}, {
			value: "xlarge"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	},
	"urlIcon": {
		"key": "$urlIcon",
		"default": fontUtils.getUrlDefIcon(),
		"values": fontUtils.getUrlIconList(),
		createMarkup: authUtils.createMarkupIconPicker,
		destroyMarkup: authUtils.destroyMarkupIconPicker
	},
	"urlIconSize": {
		"key": "$urlIconSize",
		"default": "small",
		values: [{
			value: "small"
		}, {
			value: "medium"
		}, {
			value: "large"
		}, {
			value: "xlarge"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	}
};


//Centered label is only possible on top or bottom positioned label
function _getLabelAlign(sel, data) {
	var valPos = authUtils.getValueOrDefault(_ctrlFieldsProperties.labelPosition, sel, data);

	var props = $.extend(true, {}, _ctrlFieldsProperties.labelAlign);
	props.values.forEach(function(val) {
		if (valPos === "left" && val.value === "center") {
			val.isHidden = true;
		} else {
			val.isHidden = false;
		}
	});
	return props;
}

exports.initModuleProperties = function(dest) {
	// Init fields properties
	authUtils.initProperties(_ctrlFieldsProperties, dest);
	// Init other type of fields properties
	_modules.forEach(function(module) {
		module.initModuleProperties(dest);
	});
};
exports.getModuleProperties = function($$elmt, controller, props, sel, data) {

	var labelAlign = _getLabelAlign(sel, data);

	// ctrlFieldBase
	if (sel.$$elmt.hasClass("s-m-field")) {
		[_ctrlFieldsProperties.isTitleHidden, _ctrlFieldsProperties.labelPosition, labelAlign, _ctrlFieldsProperties.theme].forEach(function(p) {
			props.push(p);
		});

		// Properties for reference fields only 
		if (data.type === "reference") {
			props.push(_ctrlFieldsProperties.refDescFormat);
			props.push(_ctrlFieldsProperties.refDescPosition);
		}
		// Properties for enriched text fields only (html, plain, rtf)
		if (data.type === "rtf" || data.type === "html" || data.type === "plain") {
			props.push(_ctrlFieldsProperties.textHeight);
		}
		if (data.type === "image" || data.type === "document") {
			props.push(_ctrlFieldsProperties.emptyImageIcon, _ctrlFieldsProperties.emptyIconSize);
		}
		if (data.type === "string" && data.control && data.control.cssType === "s-m-url") {
			props.push(_ctrlFieldsProperties.urlIcon, _ctrlFieldsProperties.urlIconSize);
		}
		// Properties for numeric field
		authoringPropertiesGauge.getModuleProperties($$elmt, controller, props, sel, data);
	} else if (sel.$$elmt.hasClass("s-m-array")) {
		var facet = data && data.control && data.control.prototype && data.control.prototype.getFacet();
		if ("query" !== facet) {
			[_ctrlFieldsProperties.isTitleHidden, _ctrlFieldsProperties.labelPosition, labelAlign, _ctrlFieldsProperties.theme].forEach(function(p) {
				props.push(p);
			});
		} else {
			[_ctrlFieldsProperties.isTitleHidden].forEach(function(p) {
				props.push(p);
			});
		}

		// ctrlFieldArray
		authoringPropertiesArrays.getModuleProperties($$elmt, controller, props, sel, data);
	} else if ($$elmt.hasClass("s-m-chart")) {
		[_ctrlFieldsProperties.isTitleHidden, _ctrlFieldsProperties.labelPosition, labelAlign, _ctrlFieldsProperties.theme].forEach(function(p) {
			props.push(p);
		});

		// Properties for charts authoring
		authoringPropertiesChart.getModuleProperties($$elmt, controller, props, sel, data);

	}


};
});

define('syracuse-tablet/html/js/authoring/authoringPropertiesLayouts',['require','exports','module','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _properties = {
	/*
	 * Color of tile and layout cell
	 */
	"tileColor": {
		"key": "$bgColor",
		"default": "darkgrey",
		"values": [{
			"value": "transparent"
		}, {
			"value": "sagegreen"
		}, {
			"value": "green"
		}, {
			"value": "lightgreen"
		}, {
			"value": "darkgrey"
		}, {
			"value": "mediumgrey"
		}, {
			"value": "skyblue"
		}, {
			"value": "purple"
		}, {
			"value": "orange"
		}, {
			"value": "blue"
		}],
		createMarkup: _createMarkupRadioBgColor
	},

	/*
	 * Size of tile
	 */
	"tileSize": {
		"key": "$size",
		"default": "medium",
		"values": [{
			"value": "small"
		}, {
			"value": "medium"
		}, {
			"value": "wide"
		}, {
			"value": "large"
		}, {
			"value": "full"
		}, {
			"value": "all"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio
	},

	/*
	 * Title of layout node
	 */
	"layoutTitle": {
		"key": "$title",
		"default": "",
		createMarkup: _createMarkupInputLocale
	},

	/*
	 * Title of layout node
	 */
	"layoutCollapsible": {
		"key": "$collapsible",
		"default": "notcollapsible",
		"values": [{
			"value": "notcollapsible"
		}, {
			"value": "expanded"
		}, {
			"value": "collapsed"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio
	},

	/*
	 * Icon of a tile
	 */
	"tileIcon": {
		"key": "$icon",
		"default": "",
		createMarkup: _createMarkupIcon
	},

	/*
	 * Size of tile
	 *
	 * Handles the following elements: $widthXs, $widthSm, $widthMd, $widthLg
	 */
	"cellSize": {
		"default": 4,
		createMarkup: _createMarkupCellSize
	}
};


/*
 * Which layout node supports which properties to edit in authoring
 */
var _layoutProps = {
	"stack": [_properties.layoutTitle, _properties.layoutCollapsible],
	"row": [],
	"hub-group": [_properties.layoutTitle],
	"tile": [_properties.layoutTitle, _properties.tileColor, _properties.tileSize, , _properties.tileIcon],
	"cell": [_properties.tileColor, _properties.cellSize]
};


function _createMarkupRadioBgColor($$parent, prop, sel, data) {

	var ctx = {
		group: "auth_opt_" + prop.name,
		options: []
	};

	var value = authPropsGeneral.getValueOrDefault(prop, sel, data);

	prop.values.forEach(function(v) {
		ctx.options.push({
			id: ctx.group + "_" + v.value,
			value: "" + v.value,
			label: v.label,
			color: v.value
		});
	});

	var html = authHtml.execute("authPanelPropertyRadioColor", ctx);
	var $$panel = $(html);
	$("label[data-s-m-auth-value='" + ("" + value) + "']", $$panel).eq(0).button("toggle");
	$("label", $$panel).on("click", function(e) {
		var $$ct = $(e.currentTarget);
		var value = $$ct.attr("data-s-m-auth-value");
		$$ct.eq(0).button("toggle");

		/*
		 * Important! Use boolean datatype for boolean properties!
		 */
		if (value === "true") {
			value = true;
		} else if (value === "false") {
			value = false;
		}
		authPropsGeneral.setValue(prop, sel, data, value);
		authPropsGeneral.notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);
}


function _createMarkupInput($$parent, prop, sel, data) {
	var value = authPropsGeneral.getValueOrDefault(prop, sel, data);
	var html = authHtml.execute("authPanelPropertyInput", {
		id: "auth_opt_" + prop.name,
		value: value
	});
	var $$panel = $(html);
	$("input", $$panel).blur(function() {
		var value = $(this).val();
		authPropsGeneral.setValue(prop, sel, data, value);
		authPropsGeneral.notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);
}

function _createMarkupInputLocale($$parent, prop, sel, data) {
	var oldUUID = authPropsGeneral.getValueOrDefault(prop, sel, data);
	var value;
	oldUUID = oldUUID || "";
	if (oldUUID.indexOf("{@") < 0) {
		value = oldUUID; // Plain text in article
		oldUUID = "";
	} else {
		var loc = data.articlePage.$localization && data.articlePage.$localization[locale.getCurrentLocale()];
		value = oldUUID.replace(/\{\@(\S+)\}/g, function(m, g) {
			return loc && loc[g] || m;
		});
	}
	var html = authHtml.execute("authPanelPropertyInputLocale", {
		id: "auth_opt_" + prop.name,
		value: value,
		oldValue: value,
		oldUUID: oldUUID
	});
	var $$panel = $(html);
	$("input", $$panel).blur(function() {
		var value = $(this).val();
		var oldValue = $(this).attr("data-old-value");
		var oldUUID = $(this).attr("data-old-uuid");

		// If plain text value did not change and there is an uuid already, we just re assign the uuid
		// otherwise, plain text is set, which will result in recreation of a new uuid later during article generation 
		if (value === oldValue && oldUUID.length > 0) {
			value = oldUUID;
		}
		authPropsGeneral.setValue(prop, sel, data, value);
		authPropsGeneral.notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);
}

function _createMarkupCellSize($$parent, prop, sel, data) {
	var values = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
	var sizes = [{
		"prop": "widthXs",
		"label": locale.text("auth.cellSize.$widthXs"),
		"class": "s-m-auth-highlight-xs"
	}, {
		"prop": "widthSm",
		"label": locale.text("auth.cellSize.$widthSm"),
		"class": "s-m-auth-highlight-sm"
	}, {
		"prop": "widthMd",
		"label": locale.text("auth.cellSize.$widthMd"),
		"class": "s-m-auth-highlight-md"
	}, {
		"prop": "widthLg",
		"label": locale.text("auth.cellSize.$widthLg"),
		"class": "s-m-auth-highlight-lg"
	}];

	var html = authHtml.execute("authPanelPropertyCellSize", {
		id: "auth_opt_" + prop.name,
		sizes: sizes,
		values: values
	});
	var $$panel = $(html);
	var last = "12";
	sizes.forEach(function(size) {
		var value = data.articleSelection && data.articleSelection["$" + size.prop];
		value = value || last;
		last = value;
		$("label[data-s-m-auth-prop='" + size.prop + "'][data-s-m-auth-value='" + value + "']", $$panel).button("toggle");
	});

	$("label", $$panel).on("click", function(e) {
		var $$ct = $(e.currentTarget);
		$$ct.eq(0).button("toggle");
		sizes.forEach(function(size) {
			$$ct = $$panel.find("label.active[data-s-m-auth-prop='" + size.prop + "']");
			if ($$ct.length > 0) {
				var value = $$ct.attr("data-s-m-auth-value");
				data.articleSelection["$" + size.prop] = value;
			}
		});
		authPropsGeneral.notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);
}

function _createMarkupIcon($$parent, prop, sel, data) {

	var ctx = {
		group: "auth_opt_" + prop.name,
		options: []
	};

	var value = authPropsGeneral.getValueOrDefault(prop, sel, data);

	fontUtils.getTileIconList().forEach(function(v) {
		var css = fontUtils.getIconByName(v);
		ctx.options.push({
			id: ctx.group + "_" + v,
			value: v,
			icon: css
		});
	});

	var html = authHtml.execute("authPanelPropertyRadioIcon", ctx);
	var $$panel = $(html);
	$("label[data-s-m-auth-value='" + ("" + value) + "']", $$panel).eq(0).button("toggle");
	$("label", $$panel).on("click", function(e) {
		var $$ct = $(e.currentTarget);
		var value = $$ct.attr("data-s-m-auth-value");
		$$ct.eq(0).button("toggle");
		authPropsGeneral.setValue(prop, sel, data, value);
		authPropsGeneral.notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);
}

exports.properties = _properties;

exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	Object.keys(_layoutProps).some(function(key) {
		var cls = "s-m-" + key;
		if ($$elmt.hasClass(cls)) {
			_layoutProps[key].forEach(function(p) {
				props.push(p);
			});
		}
	});
};
exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};
});

define('syracuse-tablet/html/js/authoring/authoringProperties',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/authoring/authoringPropertiesGeneral','syracuse-tablet/html/js/authoring/authoringPropertiesCtrls','syracuse-tablet/html/js/authoring/authoringPropertiesLayouts'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var authoringPropertiesGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authoringPropertiesCtrls = require('syracuse-tablet/html/js/authoring/authoringPropertiesCtrls');
var authoringPropertiesLayouts = require('syracuse-tablet/html/js/authoring/authoringPropertiesLayouts');

var _propsModules = [authoringPropertiesCtrls, authoringPropertiesLayouts, authoringPropertiesGeneral];

var _properties;

exports.initProperties = function(force) {
	if (_properties != null && force != true) {
		return;
	}
	_properties = {};
	_propsModules.forEach(function(module) {
		module.initModuleProperties(_properties);
	});
};

exports.getAllProperties = function() {
	return _properties;
};

exports.getProperties = function(sel, data) {

	var $$elmt = sel.$$elmt;
	var props = [];

	var controller = utils.findController($$elmt);
	_propsModules.forEach(function(module) {
		module.getModuleProperties($$elmt, controller, props, sel, data);
	});
	props.forEach(function(p, idx) {
		if (typeof p === "function") {
			var prop = props[idx] = new p(controller, sel, data);
			// to simplify the code writing in function object
			if (prop.initMarkup) {
				prop.initMarkup(controller, sel, data);
			}
			authoringPropertiesGeneral.initProperty(prop);
		}
	});
	return props;
};

/* The following getters are used to avoid some cyclic deps in authoring modules
 */
exports.getPropertiesLayouts = function() {
	return authoringPropertiesLayouts;
};
exports.getPropertiesGeneral = function() {
	return authoringPropertiesGeneral;
};
exports.getPropertiesCtrl = function() {
	return authoringPropertiesCtrls;
};
});

define('syracuse-tablet/html/js/authoring/authoringHelpers',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/authoring/authoringSData','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/authoring/authoringProperties','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/authoring/authoringVal','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/ui/uiUtils'],function (require, exports, module) {

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var authoringSData = require('syracuse-tablet/html/js/authoring/authoringSData');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var authProps = require('syracuse-tablet/html/js/authoring/authoringProperties');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var authVal = require('syracuse-tablet/html/js/authoring/authoringVal');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');

var _openPanels = [];

exports.triggerResizeInternal = function(opts) {
	uiutils.triggerResizeInternal(opts);
};

exports.selectElement = function(sel) {
	$(".s-m-auth-selected").removeClass("s-m-auth-selected");
	var $$elmt = $("#" + sel.id, $("#s-m-app-id"));
	var domItem = $$elmt[0];
};

/*
 * Find control instance from DOM element
 */
exports.findControl = function($$ctrl) {
	return utils.findControl($$ctrl);
};

exports.getSelectionById = function(id) {
	var $$item = $("#s-m-app-id #" + id);
	if ($$item.length <= 0) {
		return null;
	}
	return {
		$$elmt: $$item,
		id: id
	};
};

exports.getSelectionData = function(sel) {
	if (!sel || !sel.id) {
		return null;
	}
	var app = globals.getApplication();
	var article = $.extend(true, {}, app.currentPage.article);

	var title;
	var type;
	var control = exports.findControl(sel.$$elmt);
	if (control && control.isControl()) {
		title = control.prototype && control.prototype.data("$title");
		if (title) {
			title += " (" + control.$bind + ")";
		} else {
			title = control.$bind;
		}
		type = control.typeName;
	} else {
		title = locale.text("auth.label_layout");
		type = sel.$$elmt.attr("id");
		type = type.replace(/\d/g, "");
	}
	var articleSelection = (control && control.getArticle()) || article;
	return {
		articlePage: article,
		articleSelection: articleSelection,
		title: title,
		type: type,
		control: control
	};
};

var _PropertyPanel = function($$parent) {
	this.$$parent = $$parent;
	// For properties that are not objects
	this.destroyHandlers = [];
	this.propInstances = [];
	this.destroy = function() {
		// First
		this.destroyHandlers.forEach(function(h) {
			if (h) h();
		});
		this.propInstances.forEach(function(p) {
			if (p.destroyMarkup) p.destroyMarkup();
		});
		this.destroyHandlers = this.propInstances = null;
		// Second
		if (this.$$parent) {
			this.$$parent.empty();
		}
	};
	this.addDestroyHandler = function($$content, prop) {
		this.destroyHandlers.push(jsutils.bindFn(prop.destroyMarkup, null, $$content, prop));
	};
	this.addPropInstance = function(prop) {
		this.propInstances.push(prop);
	};
};
// sm.auth.articlechange.ui
exports.createPropertyPanel = function($$parent, sel, data) {
	var props = authProps.getProperties(sel, data);
	if (!props) {
		return;
	}
	var propertyPanel = new _PropertyPanel($$parent);
	var $$accord = $('<div class="panel-group" id="accordion" role="tablist" aria-multiselectable="true">');
	var id;
	var num = 0;
	var toDestroy = [];
	var article = sel.articleSelection;
	var topButtons = [];
	props.forEach(function(prop) {
		id = "auth_prop_" + prop.name;
		var expanded = _openPanels.indexOf("collapse_" + id) > -1;

		if (prop.createMarkup) {
			var $$block = $(
				authHtml.execute("authPanelPropertyGroup", {
					id: id,
					expanded: expanded,
					label: prop.label,
					type: prop.type || "default"
				}));
			var $$content = $('#collapse_' + id, $$block);
			prop.createMarkup($$content, prop, sel, data);
			if ($.isPlainObject(prop) && prop.destroyMarkup) {
				propertyPanel.addDestroyHandler($$content, prop);
			} else if (prop.constructor) {
				propertyPanel.addPropInstance(prop);
			}
			if (prop.isHidden === true) {
				$$block.hide();
			}
		} else if (prop.createButtonMarkup) {
			// Add button at the top of property panel
			topButtons.unshift(prop);
		} else {
			if (prop.applyMarkup) {
				prop.applyMarkup($$accord, prop, sel, data);
			} else if (prop.isSeparatror) {
				var $$block = $(
					authHtml.execute("authPanelPropertySeperator", {
						id: id,
						expanded: expanded,
						label: prop.label,
						type: prop.type || "default"
					}));
			}
		}
		$$accord.append($$block);
		num++;
	});
	topButtons.forEach(function(prop) {
		notifications.publish("sm.auth.top.button", "add", prop);
	});
	$$parent.append($$accord);
	return propertyPanel;
};

exports.refreshPropertyPanels = function(sel, data) {
	var props = authProps.getProperties(sel, data);
	if (!props) {
		return;
	}
	props.forEach(function(prop) {
		if (prop.refreshMarkup) {
			var id = "#collapse_auth_prop_" + prop.name;
			var $$panel = $(id);
			prop.refreshMarkup($$panel, prop, sel, data);
		}
	});
};

exports.savePanelStates = function() {
	var i;
	var panels = $(".panel-collapse.collapse.in", "#authPanelControlSimple");
	_openPanels = [];
	for (i = 0; i < panels.length; i++) {
		_openPanels.push(panels[i].id);
	}
};

exports.saveAuthoring = function(page, opts) {

	var segs = page.split(".");

	var pageData = {
		application: segs[0], // x3
		contract: segs[1], // erp
		representation: segs[2], // ACTIV
		facet: segs[3], // $query

		roles: [],
		users: [],
		endpoints: [],

		saveAsOption: opts.saveAs,

		variantCode: opts.code,
		variantTitle: opts.title,
		variantDescription: opts.description,

		article: opts.article
	};

	return authoringSData.getPageVariants({
		application: segs[0],
		contract: segs[1],
		representation: segs[2],
		facet: segs[3]
	})
		.then(function(variants) {
			variants && variants.some(function(v) {
				var match = v.title === opts.title && v.code === opts.code && v.description === opts.description;

				// Did type change? Then create new variant
				if (opts.saveAs === "factory_variant" && v.isFactory !== true) {
					match = false;
				} else if (opts.saveAs === "global_variant" && v.isFactory === true) {
					match = false;
				} else if (opts.saveAs === "personal_copy" && v.isFactory === true) {
					match = false;
				}

				// If all matches, it's a save and not a save as
				if (match) {
					pageData.variant = v.$uuid;
				}
			});
		})
		.then(function() {
			return authoringSData.savePageDefinition(pageData);
		})
		.then(function(data) {
			modal.diagnoses(locale.text("auth.panel.save_ok_title"), {
				$diagnoses: data.diags
			});
		})
		.fail(function(e) {
			modal.diagnoses(locale.text("auth.panel.save_error_title"), e);
		});
};


exports.rebuildArticleByPageStruct = function(page, states) {

	function _copyLocNode(uuid) {
		Object.keys($localization).forEach(function(lang) {
			var texts = $localizationNew[lang] = $localizationNew[lang] || {};
			texts[uuid] = $localization[lang][uuid];
		});
	}

	function _findLocMatch(text) {
		var oldTexts = $localization[curLang] || {};
		var match;
		Object.keys(oldTexts).some(function(uuid) {
			if (oldTexts[uuid] === text) {
				match = uuid;
				return true;
			}
			return false;
		});
		return match;
	}

	function _checkLocalization(nodeArticle) {
		var propsPerNode = ["$title"];
		propsPerNode.forEach(function(key) {
			var text = nodeArticle[key];
			if (text) {
				var uuid = text.match(/\{\@(\S+)\}/);
				if (uuid && uuid[1]) { // text is already a placeholder, just copy to new structure
					_copyLocNode(uuid[1]);
				} else {
					uuid = _findLocMatch(text);
					if (!uuid) { // Create new ID
						uuid = utils.UUID();
						var texts = $localizationNew[curLang] = $localizationNew[curLang] || {};
						texts[uuid] = text;
					} else {
						_copyLocNode(uuid);
					}
					nodeArticle[key] = "{@" + uuid + "}";
				}
			}
		});
	}

	function _walkNode(article, node) {
		var nodeArticle = node.getAuthArticle();
		_checkLocalization(nodeArticle);
		if (states) {
			var state = node.getAuthState(nodeArticle.$isDirty || {});
			if (state) {
				var path = node.getPathInTree();
				path = path.join(".");
				states[path] = state;
			}
		}
		// Remove dirty flags
		delete nodeArticle.$isDirty;
		Object.keys(nodeArticle).forEach(function(key) {
			article[key] = nodeArticle[key];
		});

		if (node.isVignette()) {
			var page = node.getPage();
			if (page) { // Page is set if content of vignette is not a link
				var rootLayout = page.rootLayout;
				article.$article = {};
				_walkNode(article.$article, rootLayout);
			}
		} else {
			if (node.children && node.children.length > 0) {
				article.$items = [];
				node.children.forEach(function(child) {
					var childArticle = {};
					article.$items.push(childArticle);
					_walkNode(childArticle, child);
				});
			}
		}
	}
	var curLang = locale.getCurrentLocale();
	var rootLayout = page.rootLayout;
	var $localization = page.article && page.article.$localization || {};
	var $localizationNew = {};
	var jsonArticlePage = {};

	_walkNode(jsonArticlePage, rootLayout);
	jsonArticlePage.$localization = $localizationNew;
	var articleJSON = authVal.toSortedJSON(jsonArticlePage);
	return articleJSON;
};
});

define('syracuse-tablet/html/js/authoring/authoringPanelRight',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/authoring/arrays/authArrayCard'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var authArrayCard = require('syracuse-tablet/html/js/authoring/arrays/authArrayCard');

exports.Panel = utils.defineClass(function AuthoringPanelRight() {
	var self = this;
	self.$$panel = null;
	self.topButtons = [];
}, null, {
	show: function() {
		var self = this;

		self._ensurePanel();
		self._subscribe();

		self.$$panel.show();
		self.$$splitter.show();
		/* Min width for drag - self.$$splitter.width is 0 - We should improve that*/
		self._minWidth = 4 * globals.getSiteLayout().splitterWidth;;
		self._initDefaults();

		$('.btn', self.$$panelSave).eq(0).button("toggle");
		$('.nav-pills a[href="#authPanelControl"]').tab('show');
	},

	hide: function() {
		var self = this;
		self._ensurePanel();
		self.$$panel.hide();
		self.$$splitter.hide();
		self._unscribe();
	},
	_subscribe: function() {
		var self = this;
		notifications.subscribe(self, ["sm.main.layout.changed"]);
		notifications.subscribe(self, ["sm.auth.set.page"]);
		notifications.subscribe(self, ["sm.auth.set.selection"]);
		notifications.subscribe(self, ["sm.auth.change.prop.ui"]);
		notifications.subscribe(self, ["sm.auth.top.button"]);
	},

	_unscribe: function() {
		var self = this;
		notifications.unsubscribe(self, ["sm.main.layout.changed"]);
		notifications.unsubscribe(self, ["sm.auth.set.page"]);
		notifications.unsubscribe(self, ["sm.auth.set.selection"]);
		notifications.unsubscribe(self, ["sm.auth.change.prop.ui"]);
		notifications.unsubscribe(self, ["sm.auth.top.button"]);
	},

	notifMainLayoutChanged: function() {
		var self = this;
		self.$$panel.find(".tab-content").css({
			"height": self.$$panel.height() - 100
		});
	},

	_ensurePanel: function() {
		var self = this;
		if (this.$$panel) {
			return;
		}

		var ctx = {
			label_control: locale.text("auth.panel.label_control"),
			label_edit: locale.text("auth.panel.label_page"),
			label_apply: locale.text("auth.panel.label_apply"),

			label_simple: locale.text("auth.panel.label_simple"),
			label_expert: locale.text("auth.panel.label_expert"),

			label_control_title: locale.text("auth.panel.label_control_title"),
			label_control_type: locale.text("auth.panel.label_control_type"),
		};

		self.$$panel = $("#s-m-auth-panel-right-id");
		$(authHtml.execute("authPanelRightStructure", ctx)).appendTo(self.$$panel);
		self.$$panelRightStruct = self.$$panel.find("#authPanelControlTitle");

		self._getDomObjects();
		self._initSplitter();
		self._initDomEvents();
	},

	_getDomObjects: function() {
		var self = this;
		self.$$panelControlSimple = $("#authPanelControlSimple");
		self.$$panelControlExpert = $("#authPanelControlExpert");
		self.$$authPageName = $("#authPageName");
		self.$$panelControlTitle = $("#authPanelControlTitle");
		self.$$panelControlType = $("#authPanelControlType");

		self.$$panelEdit = $("#authPanelEdit");
	},

	_initDomEvents: function() {
		var self = this;
	},

	_initDefaults: function() {
		var self = this;
		self.$$panelControlTitle.text("");
		self.$$panelControlType.text(locale.text("auth.panel.label_control"));
		self.destroyPropertyPanel();
	},
	/**
	 * context	indicates the context of destroy: selection...
	 * 		origin	"selection" -> destroy called by a selection of ctrl.layout
	 * context is used by topButtons destroyButtonMarkup
	 * 		destroyButtonMarkup returns false if button has not been destroyed
	 * -> destroyButtonMarkup/createButtonMarkup facilitate the search for buttons properties
	 */
	destroyPropertyPanel: function(context) {
		if (this.topButtons) {
			var preserveButtons = [];
			this.topButtons.forEach(function(prop) {
				if (prop.destroyButtonMarkup) {
					if (prop.destroyButtonMarkup(context) === false) {
						preserveButtons.push(prop);
					};
				}
			});
			this.topButtons = preserveButtons;
		}
		if (this._propertyPanel) {
			this._propertyPanel.destroy();
			this._propertyPanel = null;
		}
	},

	notifAuthSetPage: function(page) {
		var self = this;
		self.currentPageName = page.state.authoringName;
		self.currentPageId = page.id;
		self.$$authPageName.text(self.currentPageName);
		self._initDefaults();
		var cardDesign = page.state.type == "carddesign";
		if (cardDesign) {
			// Add back button from card design -> array
			notifications.publish("sm.auth.top.button", "add", authArrayCard.getCardDesignBackButton(page));
		}
		// Disable the validate/save button in card design mode - Card design page is a child page 
		// Close button do a back to the previous page that contains the array
		$("#auth-btn-save-id").toggle(cardDesign !== true);
	},


	// Called by panel if a property like color has been changed using the simple ui
	notifAuthChangePropUi: function(articlePage) {
		var self = this;
	},

	/**
	 * path = null to remove current selection
	 */
	notifAuthSetSelection: function(id) {
		var self = this;
		self.$$panelControlTitle.text("");
		self.$$panelControlType.text(locale.text("auth.panel.label_control"));

		var sel = id ? authHelpers.getSelectionById(id) : null;

		authHelpers.savePanelStates();
		self.destroyPropertyPanel({
			origin: "selection"
		});
		if (!sel) {
			return;
		}
		var data = authHelpers.getSelectionData(sel);
		if (data) {
			self.$$panelControlTitle.text(data.title || "");
			self.$$panelControlType.text(locale.text("auth.panel.label_control") + " " + data.type || "");
			var article = data.articleSelection;
			if (article) {
				this._propertyPanel = authHelpers.createPropertyPanel(self.$$panelControlSimple, sel, data);
			}
		}
	},

	getPageArticle: function() {
		return this.getPage().article;
	},

	getPage: function() {
		var page = $("#s-m-app-id").find("#" + this.currentPageId).smPageController();
		if (!page) throw new Error("Page not found " + this.currentPageId);
		if (!page.isActive()) throw new Error("Page not active " + this.currentPageId);
		return page;
	},

	_initSplitter: function() {
		var self = this;
		self.$$splitter = $("#s-m-auth-splitter-right-id");
		self.$$splitter.draggable({
			axis: "x",
			stop: function(e, ui) {
				var $$splitter = $(this);
				var pos = $$splitter.position();
				var width = $$splitter.width();
				var panelRightSize = Math.max(self._minWidth, $(window).width() - pos.left - width);
				// Normally we should block on drag event
				$$splitter.css({
					left: ($(window).width() - panelRightSize - width) + "px"
				});
				authHelpers.triggerResizeInternal({
					layout: {
						authPanelRight: {
							width: panelRightSize
						}
					}
				});
			}
		});
	},
	/**
	 * Ad a button at the top of property panel
	 */
	notifAuthTopButton: function(action, prop) {
		if (!this.$$panelRightStruct || !prop.createButtonMarkup) return;
		this.topButtons.push(prop);
		this.$$panelRightStruct.after(prop.createButtonMarkup(this.getPage()));
	}
});
});

define('syracuse-tablet/html/js/authoring/authoringDrag',['require','exports','module','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/controls/ctrlFactory','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _$$lastElements = [];


/*
	Drag and drop helpers
*/

/*
 * Gets the control/drag element a dragged DOM element belongs to
 * (The DOM element on drag start can be a child of the actual draggable, this is why we need to go up the tree)
 */
exports.getClosestDragElement = function($$source) {
	var $$draggable = $$source.closest(".ui-draggable");
	return $$draggable;
};

exports.dropDrop = function($$drop, $$helper, $$draggable) {
	// We always drop to the highest element in the stack which belongs to the drop description
	// visible in the UI
	$$drop = _$$lastElements.length > 0 && _$$lastElements[_$$lastElements.length - 1];
	_$$lastElements = []; // There may be more drop events, we ignore all subsequent ones
	if (!$$drop) {
		return;
	}

	var data = _getDropData($$drop, $$draggable);
	if (!_isDropAllowed(data)) {
		return;
	}

	if (data.action === "add_layout") {
		_addLayout(data);
	} else if (data.action == "add_bind") {
		_addBind(data);
	} else if (data.action == "move_ctrl") {
		_moveControl(data);
	} else if (data.action == "move_layout") {
		_moveLayout(data);
	}

};

exports.dropAccept = function($$drop, $$draggable) {
	var data = _getDropData($$drop, $$draggable);
	return true;
};

exports.dropOut = function($$drop, $$helper, $$draggable) {
	$$drop.removeClass("s-m-top-stack");
	var $$top = _updateHoverStack();
	if ($$top) {
		_updateDragHelper($$top, $$helper, $$draggable);
	}
};

exports.dropOver = function($$drop, $$helper, $$draggable) {
	_$$lastElements.push($$drop);
	_updateHoverStack();
	_updateDragHelper($$drop, $$helper, $$draggable);
};

function _updateHoverStack() {
	var newList = [];
	$.each(_$$lastElements, function(idx, $$last) {
		$$last.removeClass("s-m-top-stack");
		if ($$last.hasClass("s-m-auth-hover-droptarget")) {
			newList.push($$last);
		}
	});
	var $$last = newList[newList.length - 1];
	if ($$last) {
		$$last.addClass("s-m-top-stack");
	}
	_$$lastElements = newList;
	return $$last;
}

function _updateDragHelper($$drop, $$helper, $$draggable) {
	var data = _getDropData($$drop, $$draggable);
	var allowed = _isDropAllowed(data);

	$$helper.removeClass("drop_move");
	$$helper.removeClass("drop_add");
	$$helper.removeClass("drop_disabled");
	if (!allowed) {
		$$helper.addClass("drop_disabled");
		$('#s-m-auth-drag-helper-desc-id', $$helper).text("");
		return;
	}

	var desc = "";
	var title;

	if (data.moveBeforeCtrl) {
		title = _controlTitle(data.moveBeforeCtrl);
	} else {
		title = _controlTitle(data.toContainer);
	}

	switch (data.action) {
		case "add_layout":
			if (data.moveBeforeCtrl) {
				desc = locale.text("auth.drag.add.before", [title]);
			} else {
				desc = locale.text("auth.drag.add.intoend", [title]);
			}
			$$helper.addClass("drop_add");
			break;
		case "add_bind":
			if (data.moveBeforeCtrl) {
				desc = locale.text("auth.drag.add.before", [title]);
			} else {
				desc = locale.text("auth.drag.add.intoend", [title]);
			}
			$$helper.addClass("drop_add");
			break;
		case "move_ctrl":
			if (data.moveBeforeCtrl) {
				desc = locale.text("auth.drag.move.before", [title]);
			} else {
				desc = locale.text("auth.drag.move.intoend", [title]);
			}
			$$helper.addClass("drop_move");
			break;
		case "move_layout":
			if (data.moveBeforeCtrl) {
				desc = locale.text("auth.drag.move.before", [title]);
			} else {
				desc = locale.text("auth.drag.move.intoend", [title]);
			}
			$$helper.addClass("drop_move");
			break;
	}

	$('#s-m-auth-drag-helper-desc-id', $$helper).text(desc);
}

function _isDropAllowed(data) {
	if (!data.toType) {
		return false;
	}

	var targetLayout;
	var container;

	if (data.ctrl) {
		data.container = data.ctrl.parent;
	}

	if (data.toCtrl && data.toCtrl.isLayout()) {
		container = data.toCtrl;
		targetLayout = data.toType;
	} else if (data.toCtrl) {
		container = data.toCtrl.parent;
		targetLayout = container.$type;
		data.moveBeforeCtrl = data.toCtrl;
	}
	data.toContainer = container;

	// Check layout constraints
	if (data.action === "add_layout") {
		if (data.bind == "stack") {
			if (targetLayout !== "stack" && targetLayout !== "cell" && targetLayout !== "tile") {
				return false;
			}
		} else if (data.bind == "group") {
			if (targetLayout !== "stack" && targetLayout !== "hub") {
				return false;
			}
		} else if (data.bind == "tile") {
			if (targetLayout !== "row" && targetLayout !== "hubGroup" && targetLayout !== "stack" && targetLayout !== "hub") {
				return false;
			}
		}
		return true;
	}

	// Check adding of controls
	if (data.action === "add_bind") {
		// Controlls in a vignette may only be added to the vignette the control belongs too but not to another one
		if (data.parent != data.toParent) {
			return false;
		}
		// Controls may only be added in a stack
		if (targetLayout === "stack" || targetLayout === "tile" || targetLayout === "cell") {
			return true;
		}
	}

	if (data.action === "move") {
		/* 
		 * Move of control
		 */
		if (data.ctrl && !data.ctrl.isLayout()) {
			data.action = "move_ctrl";
			if (data.parent != data.toParent) {
				return false;
			}

			// Controls may only be added in a stack
			if (targetLayout === "stack" || targetLayout === "tile" || targetLayout === "cell") {
				return true;
			}
		} else if (data.ctrl && data.ctrl.isLayout()) {
			data.action = "move_layout";
			if (data.type == "stack") {
				if (targetLayout !== "stack" && targetLayout !== "cell" && targetLayout !== "tile") {
					return false;
				}
			} else if (data.type == "tile") {
				if (targetLayout !== "hubGroup") {
					return false;
				}
			} else if (data.type == "cell") {
				if (targetLayout !== "row") {
					return false;
				}
			} else if (data.type == "row") {
				if (targetLayout !== "stack" && targetLayout !== "cell" && targetLayout !== "tile") {
					return false;
				}
			} else if (data.type == "hubGroup") {
				if (targetLayout !== "hub") {
					return false;
				}
			}

			// Check drop into self
			var $$dropToChildren = data.toCtrl.$$elmt.closest("#" + data.ctrl.id);
			if ($$dropToChildren.length > 0) { // Drop layout into a children of itself
				return false;
			}

			// Check vignette scope
			var vignetteScopeOk = true;
			var $$fromVignette = data.ctrl.$$elmt.closest(".s-m-control.s-m-vignette");
			var $$toVignette = data.toCtrl.$$elmt.closest(".s-m-control.s-m-vignette");
			if ($$fromVignette.length !== $$toVignette.length) { // From/to vignette to non vignette scope or other way around
				vignetteScopeOk = false;
			} else if ($$toVignette.length === 0) { // No vignettes involved, always ok
				vignetteScopeOk = true;
			} else if ($$fromVignette.length === 1 && $$toVignette.length === 1) { // From vignette to vignette scope
				if ($$fromVignette.attr("id") === $$toVignette.attr("id")) {
					vignetteScopeOk = true; // Same vignette	
				} else {
					vignetteScopeOk = false; // Vignette a -> vignette b = not allowed
				}
			}
			return vignetteScopeOk;
		}
	}
	return false;
}

function _getDropData($$drop, $$draggable) {
	var action;
	var fromId;
	var toId;
	var bind;
	var parent;

	action = $$draggable.attr("data-auth-drag-action");
	switch (action) {
		case "move":
			fromId = $$draggable.attr("data-ctrl-id");
			break;
		case "add_bind":
			bind = $$draggable.attr("data-auth-bind");
			parent = $$draggable.attr("data-auth-bind-parent");
			parent = parent === "" ? null : parent;
			break;
		case "add_layout":
			bind = $$draggable.attr("data-auth-bind");
			break;
		default:
			// drop from page (events currently disabled)
			action = "move";
			fromId = $$draggable.attr("id");
			break;
	}

	var ctrl;
	var $$ctrl;
	if (fromId && fromId.length > 0) {
		$$ctrl = $("#" + fromId);
		ctrl = authHelpers.findControl($$ctrl);
		var v = ctrl && ctrl.controller.getParentVignette();
		if (v) {
			parent = v.$bind; // Name of the vignette that is bound to the controller of the current element
		}
	}

	// drop control or layout
	toId = $$drop.attr("data-ctrl-id"); // drop inside tree
	if (toId && toId.length > 0) {
		$$ctrl = $("#" + toId);
	} else {
		toId = $$drop.attr("id"); // Drop inside page
		$$ctrl = $$drop;
	}

	var toParent;
	var toCtrl = authHelpers.findControl($$ctrl);
	if (toCtrl) {
		if (toCtrl.controller.isVignette) {
			var v = toCtrl.controller.getParentVignette();
			if (v) {
				toParent = v.$bind; // Name of the vignette that is bound to the controller of the current element
			}
		}
	}
	return {
		//		$$draggable: $$draggable,	// Debugging
		//		$$drop: $$drop,				// Debugging

		action: action, // move, add_bind, add_layout
		bind: bind, // $bind or name of layout in case of add*
		ctrl: ctrl,
		type: ctrl && ctrl.$type, // Type of drag target
		parent: parent, // parent $bind (e.g. vignette name)
		fromId: fromId, // ctrlId (when dragging existing ctrl)
		toId: toId, // ctrlId of drop target
		toType: toCtrl && toCtrl.$type, // Type of drop target
		toCtrl: toCtrl,
		toParent: toParent
	};
}

function _addLayout(data) {
	var layoutType = "stack";
	var toContainer = data.toContainer;
	var parent;

	switch (data.bind) {
		case "group":
			if (data.toType == "hub") {
				layoutType = "hubGroup";
			} else {
				layoutType = "row";
			}
			break;
		case "tile":
			if (data.toType == "hubGroup") {
				layoutType = "tile";
			} else if (data.toType == "row") {
				layoutType = "cell";
			} else if (data.toType == "stack") {
				parent = ctrlFactory.createLayout(data.toCtrl.controller, toContainer, {
					$layoutType: "row"
				}, {});
				layoutType = "cell";
				toContainer = parent;
			} else if (data.toType == "hub") {
				parent = ctrlFactory.createLayout(data.toCtrl.controller, toContainer, {
					$layoutType: "hubGroup"
				}, {});
				layoutType = "tile";
				toContainer = parent;
			}

			break;
		case "stack":
			layoutType = "stack";
			break;
	}

	var article = {
		$layoutType: layoutType
	};

	// Create new layout node
	var ctrl = ctrlFactory.createLayout(data.toCtrl.controller, toContainer, article, {});

	// Move before desired sibling
	if (data.moveBeforeCtrl) {
		if (parent) { // Handle autoboxing
			data.toContainer.removeChildRef(parent);
			data.toContainer.addChildBefore(parent, data.moveBeforeCtrl);
		} else {
			toContainer.removeChildRef(ctrl);
			toContainer.addChildBefore(ctrl, data.moveBeforeCtrl);
		}
	}

	notifications.publish(["sm.auth.change.item.prop.ui"]);
}

function _addBind(data) {
	var article = {
		$bind: data.bind
	};
	var ctrl = ctrlFactory.createBindControl(data.toCtrl.controller, data.toContainer, article, {});

	// Move before desired sibling
	if (data.moveBeforeCtrl) {
		data.toContainer.removeChildRef(ctrl);
		data.toContainer.addChildBefore(ctrl, data.moveBeforeCtrl);
	}

	notifications.publish(["sm.auth.change.item.prop.ui"]);
}

function _moveControl(data) {
	data.container.removeChildRef(data.ctrl);
	data.toContainer.addChildBefore(data.ctrl, data.moveBeforeCtrl);
	notifications.publish(["sm.auth.change.item.prop.ui"]);
}

function _moveLayout(data) {
	data.container.removeChildRef(data.ctrl);
	data.toContainer.addChildBefore(data.ctrl, data.moveBeforeCtrl);
	notifications.publish(["sm.auth.change.item.prop.ui"]);
}

function _controlTitle(ctrl) {
	var title = ctrl.prototype && ctrl.prototype.data("$title");

	if (!title) {
		title = ctrl.$bind;
	} else if (ctrl.$bind) {
		title = title + " (" + ctrl.$bind + ")";
	}

	if (!title) {
		title = ctrl.$type;
	}
	return title;
}
});

define('syracuse-tablet/html/js/authoring/authoringPanelLeft',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/authoring/authoringDrag'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var authDrag = require('syracuse-tablet/html/js/authoring/authoringDrag');

var $$lastHoverList;

exports.Panel = utils.defineClass(function AuthoringPanelLeft() {
	var self = this;
	self.$$panel = null;
	self.$$page = $("#s-m-app-id");
	self._bindsOnPage = [];
}, null, {
	show: function() {
		var self = this;

		self._ensurePanel();
		self._subscribe();

		self.$$panel.show();
		self.$$splitter.show();
		/* Min width for drag - width of tabs - self.$$splitter.width is 0 - We should improve that*/
		self._minWidth = 2 * globals.getSiteLayout().splitterWidth;
		self.$$panel.find(".s-m-site-auth-panel-content > ul.nav.nav-pills > li").each(function() {
			self._minWidth += $(this).outerWidth();
		});
	},

	hide: function() {
		var self = this;
		self._ensurePanel();
		self.$$panel.hide();
		self.$$splitter.hide();
		self._unscribe();
	},

	_subscribe: function() {
		var self = this;
		notifications.subscribe(self, ["sm.main.layout.changed"]);
		notifications.subscribe(self, ["sm.auth.set.page"]);
		notifications.subscribe(self, ["sm.auth.change.prop.ui"]);

		notifications.subscribe(self, ["sm.auth.set.selection"]);
		notifications.subscribe(self, ["sm.auth.remove.selection"]);

		notifications.subscribe(self, ["sm.auth.hover.in"]);
		notifications.subscribe(self, ["sm.auth.hover.out"]);
		notifications.subscribe(self, ["sm.page.loaded"]);
	},

	_unscribe: function() {
		var self = this;
		notifications.unsubscribe(self, ["sm.main.layout.changed"]);
		notifications.unsubscribe(self, ["sm.auth.set.page"]);
		notifications.unsubscribe(self, ["sm.auth.change.prop.ui"]);

		notifications.unsubscribe(self, ["sm.auth.set.selection"]);
		notifications.unsubscribe(self, ["sm.auth.remove.selection"]);

		notifications.unsubscribe(self, ["sm.auth.hover.in"]);
		notifications.unsubscribe(self, ["sm.auth.hover.out"]);
		notifications.unsubscribe(self, ["sm.page.loaded"]);
	},

	notifMainLayoutChanged: function() {
		var self = this;

		$("#s-m-auth-tree-box", self.$$panel).css({
			"height": self.$$panel.height() - 40
		});
		$("#s-m-auth-insert-box", self.$$panel).css({
			"height": self.$$panel.height() - 40
		});
	},

	_ensurePanel: function() {
		var self = this;
		if (this.$$panel) {
			return;
		}
		var ctx = {
			label_content: locale.text("auth.panel.label_content"),
			label_insert: locale.text("auth.panel.label_insert"),
			label_containers: locale.text("auth.panel.label_containers"),
			label_fields: locale.text("auth.panel.label_fields"),
			lab_drag_to_add: locale.text("auth.label_layout.drag"),
			lab_group: locale.text("auth.label_layout.group"),
			lab_tile: locale.text("auth.label_layout.tile"),
			lab_stack: locale.text("auth.label_layout.stack"),
		};

		self.$$panel = $("#s-m-auth-panel-left-id");
		self.$$panel.append($(authHtml.execute("authPanelLeftStructure", ctx)));

		self._getDomObjects();
		self._initSplitter();
	},

	_getDomObjects: function() {
		var self = this;
		self.$$structureRoot = $("#auth-structure-root-id", self.$$panel);
		self.$$prototypeRoot = $("#auth-lp-cnt-props-clpse", self.$$panel);
	},

	_initSplitter: function() {
		var self = this;
		self.$$splitter = $("#s-m-auth-splitter-left-id");
		self.$$splitter.draggable({
			axis: "x",
			stop: function(e, ui) {
				var $$splitter = $(this);
				var pos = $$splitter.position();
				var width = $$splitter.width();
				var panelLeftSize = Math.max(self._minWidth, pos.left);
				// Normally we should block on drag event
				$$splitter.css({
					left: panelLeftSize + "px"
				});
				authHelpers.triggerResizeInternal({
					layout: {
						authPanelLeft: {
							width: panelLeftSize
						}
					}
				});
			}
		});
	},

	notifAuthSetPage: function(page) {
		var self = this;
		self._resetContent(page.article);
	},

	notifAuthChangePropUi: function(articlePage) {
		var self = this;
		var article = JSON.parse(articlePage);
		self._resetContent(article);
	},

	notifPageLoaded: function(page) {
		var self = this;
		if (globals.getCurrentPage().isDashboard()) {
			self._resetContent(globals.getCurrentPage().article);
		}
	},

	_resetContent: function(article) {
		var self = this;
		self._buildPageStructTree();
		self._buildProtoStructTree();
		self._initDomEvents();
		self._initDrag();
	},

	notifAuthSetSelection: function(id) {
		var self = this;
		var $$item = self._getItemById(id);
		if ($$item.length > 0) {
			$$item.addClass("s-m-auth-selected");

			$("#s-m-auth-tree-box", self.$$panel).animate({
				scrollTop: $$item.offset().top
			}, 500);
		}
	},

	notifAuthRemoveSelection: function(id) {
		var self = this;
		var $$item = self._getItemById(id);
		$$item.removeClass("s-m-auth-selected");
	},

	notifAuthHoverIn: function(id) {
		var self = this;
		var $$item = self._getItemById(id);
		$$item.addClass("s-m-auth-hover");
	},

	notifAuthHoverOut: function(id) {
		var self = this;
		var $$item = self._getItemById(id);
		$$item.removeClass("s-m-auth-hover");
	},

	_getItemById: function(id) {
		var self = this;
		return $('[data-ctrl-id="' + id + '"]', self.$$panel);
	},

	_buildPageStructTree: function() {
		var self = this;
		self._bindsOnPage = [];

		function _walkNode(node, $$parent, bindParent) {
			var nodeArticle = node.getArticle();
			var id = node.id;
			var typeClass;
			var label;

			if (node.isControl()) {
				var title = node.prototype && node.prototype.data("$title");
				typeClass = node.typeName;
				label = title ? title + " (" + nodeArticle.$bind + ")" : nodeArticle.$bind + " (" + nodeArticle.$bind + ")";
				var bind = bindParent != null ? bindParent + "." + node.$bind : node.$bind;
				self._bindsOnPage.push(bind);
			} else {
				typeClass = nodeArticle.$layoutType || node.typeName;
				label = nodeArticle.$title ? node.getArticleText("$title") + " (" + typeClass + ")" : typeClass;
			}

			var $$item = $('<li class="s-m-auth-tree s-m-auth-tree-' + typeClass + '">').appendTo($$parent);
			var $$p = $('<p data-ctrl-id="' + id + '" class="s-m-draggable s-m-droppable" data-auth-drag-action="move">' + label + '</p>');
			$$item.append($$p);
			if (node.isVignette()) {
				self._bindsOnPage.push(node.$bind);
				var page = node.getPage();
				if (page) { // Page is set if content of vignette is not a link
					var rootLayout = page.rootLayout;
					var $$ul = $('<ul class="s-m-auth-tree">').appendTo($$item);
					var $$li = _walkNode(rootLayout, $$ul, node.$bind);
					$(">p", $$li).removeClass("s-m-draggable");
				}
			} else {
				if (node.children && node.children.length > 0) {
					node.children.forEach(function(child) {
						var $$ul = $('<ul class="s-m-auth-tree">').appendTo($$item);
						_walkNode(child, $$ul, bindParent);
					});
				}
			}
			return $$item;
		}

		var page = globals.getApplication().currentPage;
		var rootLayout = page.rootLayout;
		var label = page.prototype.data("$title");

		self.$$structureRoot.empty();
		var $$item = $('<li class="s-m-auth-tree s-m-auth-tree-page">').appendTo(self.$$structureRoot);
		$$item.append('<p data-ctrl-id="' + page.id + '">' + label + '</p>');
		var $$ul = $('<ul class="s-m-auth-tree">').appendTo($$item);

		var $$li = _walkNode(rootLayout, $$ul);
		$(">p", $$li).removeClass("s-m-draggable");
	},

	/*
	 * Show page prototype tree, only show items that are not yet bound (referenced with $bind) on the page
	 * To only allow to add each field exactly one time.
	 */
	_buildProtoStructTree: function() {
		var self = this;
		var page = globals.getApplication().currentPage;
		var label = page.prototype.data("$title");
		self.$$prototypeRoot.empty();
		var $$item = $('<li class="s-m-auth-tree s-m-auth-tree-page">').appendTo(self.$$prototypeRoot);
		$$item.append('<p data-ctrl-id="' + page.id + '">' + label + '</p>');
		var $$ul = $('<ul class="s-m-auth-tree">').appendTo($$item);

		if (jsutils.isInstanceOf(page, "DashboardPage")) {
			var props = page.prototype.getPropertyNames();
			props.forEach(function(key) {
				self._addVignette(page, key, $$ul);
			});
		} else {
			self._addPage(page, $$ul);
		}
		/* Do not show "nothing to add..." for now
		var $$children = $("li", $$ul);
		if ($$children.length <= 0) {
			$$item = $('<li class="s-m-auth-tree s-m-auth-tree-nothing">' + locale.text("auth.panel.label_nothing") + '</li>').appendTo(self.$$prototypeRoot);
		}
		*/
	},

	_addVignette: function(page, vignette, $$parent) {
		var self = this;
		var proto = page.prototype;
		var prop = proto.property(vignette);
		var title = proto.property(vignette, "$title");
		var label = title ? title + " (" + vignette + ")" : vignette;
		var $$item = $('<li class="s-m-auth-tree s-m-auth-tree-vignette">').appendTo($$parent);
		$$item.append('<p class="s-m-draggable" data-auth-bind="' + vignette + '"  data-auth-drag-action="add_bind">' + label + '</p>');

		var ctrlVignette = page.getControlByBind(vignette);
		if (ctrlVignette) { // may be null, if vignette is not loaded yet
			$$item.removeClass("s-m-draggable");
			$$item.addClass("disabled");

			page = ctrlVignette.getPage();

			// May be null if vignette is not displaying the content but only a link
			if (page) {
				var $$ul = $('<ul class="s-m-auth-tree">').appendTo($$item);
				self._addPage(page, $$ul, vignette);

				var $$children = $("li", $$ul);
				// vignette used on page already and also all it's children, so no need to show
				if (self._bindsOnPage.indexOf(vignette) > -1) {
					if ($$children.length <= 0) {
						$$item.remove();
					}
				}
				if ($$children.length <= 0) {
					$$ul.remove();
				}
			} else {
				// Vignette is only a link and already used on page
				if (self._bindsOnPage.indexOf(vignette) > -1) {
					$$item.remove();
				}
			}
		}
	},

	_addPage: function(page, $$parent, bindParent) {
		var self = this;
		var label = "?";
		var proto = page.prototype;
		var props = proto.getPropertyNames();
		props.forEach(function(key) {
			if (proto.property(key, "$isExcluded") !== true) {;
				var bind = bindParent != null ? bindParent + "." + key : key;
				if (self._bindsOnPage.indexOf(bind) < 0) {
					var title = proto.property(key, "$title");
					var type = proto.property(key, "$type");
					var typeClass = utils.getTypeName(type);
					var label = title ? title + " (" + key + ")" : key;
					var $$item = $('<li class="s-m-auth-tree s-m-auth-tree-' + typeClass + '">').appendTo($$parent);
					$$item.append('<p class="s-m-draggable" data-auth-bind="' + key + '" data-auth-bind-parent="' + (bindParent || '') + '" data-auth-drag-action="add_bind">' + label + '</p>');
				}
			}
		});
	},

	_initDomEvents: function() {
		var self = this;
		$("li.s-m-auth-tree > p", $("#auth-structure-root-id")).mouseover(function(e) {
			var $$o = $(e.currentTarget);
			if ($$lastHoverList) {
				$$lastHoverList.removeClass("s-m-auth-hover");
				var id = $$lastHoverList.attr("id");
				notifications.publishEx(["sm.auth.hover.out"], {
					exclude: [self]
				}, id);
			}
			$$o.addClass("s-m-auth-hover");
			$$lastHoverList = $$o;

			var id = $$o.attr("data-ctrl-id");
			notifications.publishEx(["sm.auth.hover.in"], {
				exclude: [self]
			}, id);
			return false;
		});

		$("li.s-m-auth-tree > p", $("#auth-structure-root-id")).mouseout(function(e) {
			var $$o = $(e.currentTarget);
			$$o.removeClass("s-m-auth-hover");
			var id = $$o.attr("data-ctrl-id");
			notifications.publishEx(["sm.auth.hover.out"], {
				exclude: [self]
			}, id);
		});

		$("li.s-m-auth-tree > p", $("#auth-structure-root-id")).click(function(e) {
			self.setSelection($(e.currentTarget));
			return false;
		});
		$("li.s-m-auth-tree > p", $("#auth-structure-root-id")).dblclick(function(e) {
			self.makeVisibleInPage($(e.currentTarget));
			return false;
		});
	},

	/**
	 * Set current selection
	 * if $$newSel = null just remove the current selection
	 */
	setSelection: function($$newSel, noScroll) {
		var self = this;
		var $$old = $(".s-m-auth-selected", self.$$panel);
		$$old.removeClass("s-m-auth-selected");
		var id = $$old.attr("data-ctrl-id");
		notifications.publishEx(["sm.auth.remove.selection"], {
			exclude: [self]
		}, id);
		if ($$newSel) {
			// new sitem to select
			$$newSel.addClass("s-m-auth-selected");
			id = $$newSel.attr("data-ctrl-id");
		} else {
			// just remove selection
			id = null;
		}
		notifications.publishEx(["sm.auth.set.selection"], {
			exclude: [self]
		}, id, noScroll == null ? true : noScroll);
	},

	makeVisibleInPage: function($$sel) {
		var self = this;
		self.setSelection($$sel, false);
	},

	_initDrag: function() {
		var self = this;
		var dragParam = {
			scroll: false,
			containment: $("body"),
			helper: function(event) {
				var $$source = $(event.target);
				return self._createDragHelper($$source);
			},
			appendTo: "body",
		};
		$(".s-m-draggable", self.$$panel).draggable(dragParam);
		$(".s-m-droppable", self.$$structureRoot).droppable({
			greedy: true,
			hoverClass: "s-m-auth-hover-droptarget",
			tolerance: "pointer",
			drop: function(event, ui) {
				var $$helper = ui.helper;
				var $$draggable = ui.draggable;
				return authDrag.dropDrop($(this), $$helper, $$draggable);
			},
			accept: function($$draggable) {
				return authDrag.dropAccept($(this), $$draggable);
			},
			over: function(event, ui) {
				var $$helper = ui.helper;
				var $$draggable = ui.draggable;
				return authDrag.dropOver($(this), $$helper, $$draggable);
			}
		});
	},

	_createDragHelper: function($$source) {
		var $$dragSource = authDrag.getClosestDragElement($$source);
		var text;

		// Layout icon
		if ($$dragSource.attr("data-auth-drag-action") === "add_layout") {
			var name = $$dragSource.attr("data-auth-bind");
			text = locale.text("auth.drag." + name);
		} else {
			text = $$dragSource.text();
		}
		var $$helper = $('<div class="s-m-auth-drag-helper"><p id="s-m-auth-drag-helper-label-id"><p id="s-m-auth-drag-helper-desc-id"><div>');
		$('#s-m-auth-drag-helper-label-id', $$helper).text(text);
		return $$helper[0];
	},
});
});

define('syracuse-tablet/html/js/authoring/authoringPage',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/authoring/authoringDrag'],function (require, exports, module) {

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var authDrag = require('syracuse-tablet/html/js/authoring/authoringDrag');

var _selectedRecord = "s-m-auth-rec-selected";
var $$lastHoverElement;

//Controls and layout classes that cannot be selected during authoring
var _elementsNoAuthoring = [
	".s-m-array .s-m-control",
	".s-m-array .s-m-layout",
	".s-m-control.header",
	".s-m-control.footer",
	".s-m-control.navigationpanel",
	".s-m-control.pageactionpanelregular",
	".s-m-control.breadcrumbs",
];

exports.AuthPage = utils.defineClass(
	function AuthPage() {
		var self = this;

		self.__onElementClick = self._onElementClick.bind(self);
		self.__onElementMouseOver = self._onElementMouseOver.bind(self);
		self.__onElementMouseOut = self._onElementMouseOut.bind(self);

		self.$$page = $("#s-m-app-id");
	}, null, {

		enable: function() {
			var self = this;
			self._subscribe();
		},

		disable: function() {
			var self = this;
			self._unscribe();
		},

		/*
		 * Enable hover and click events in page
		 */
		enableAuthCss: function() {
			var self = this;
			// !! disableAuthCss is not well managed and if we call enableAuthCss without having called disableAuthCss we add multiple handlers
			// TODO - Review the destroy/disable process
			self.disableAuthCss();
			$(".s-m-control").addClass("s-m-auth");
			$(".s-m-layout").addClass("s-m-auth");
			$(".s-m-layout").addClass("s-m-auth");
			$(".s-m-page").addClass("s-m-auth");
			$("section.s-m-card").addClass("s-m-auth");

			_elementsNoAuthoring.forEach(function(e) {
				$(e).removeClass("s-m-auth");
			});

			$(".s-m-auth", self.$$page).on("click", self.__onElementClick);
			$(".s-m-auth", self.$$page).on("mouseover", self.__onElementMouseOver);
			$(".s-m-auth", self.$$page).on("mouseout", self.__onElementMouseOut);

			self._enableDrop();
		},

		/*
		 * Disable all events in page that were used for authoring interaction
		 */
		disableAuthCss: function() {
			var self = this;
			self._disableDrop();
			var $$smAuth = $(".s-m-auth", self.$$page);
			$$smAuth.off("click", self.__onElementClick);
			$$smAuth.off("mouseover", self.__onElementMouseOver);
			$$smAuth.off("mouseout", self.__onElementMouseOut);
			$$smAuth.removeClass("s-m-auth");
			$(".s-m-record." + _selectedRecord, self.$$page).removeClass(_selectedRecord);
		},

		_subscribe: function() {
			var self = this;
			notifications.subscribe(self, ["sm.auth.hover.in"]);
			notifications.subscribe(self, ["sm.auth.hover.out"]);
			notifications.subscribe(self, ["sm.auth.set.selection"]);
			notifications.subscribe(self, ["sm.auth.remove.selection"]);
		},

		_unscribe: function() {
			var self = this;
			notifications.unsubscribe(self, ["sm.auth.hover.in"]);
			notifications.unsubscribe(self, ["sm.auth.hover.out"]);
			notifications.unsubscribe(self, ["sm.auth.set.selection"]);
			notifications.unsubscribe(self, ["sm.auth.remove.selection"]);
		},

		_enableDrop: function() {
			var self = this;
			var dragParam = {
				scroll: false,
				containment: $("body"),
				tolerance: "pointer",
				helper: function(event) {
					var $$source = $(event.target);
					return self._createDragHelper($$source);
				},
				appendTo: "body",
				revert: function($$drop) {
					return "invalid";
				},
				start: function() {},
				stop: function() {}
			};

			$(".s-m-auth").droppable({
				greedy: false,
				hoverClass: "s-m-auth-hover-droptarget",
				tolerance: "pointer",
				drop: function(event, ui) {
					var $$helper = ui.helper;
					var $$draggable = ui.draggable;
					return authDrag.dropDrop($(this), $$helper, $$draggable);
				},
				accept: function($$draggable) {
					return authDrag.dropAccept($(this), $$draggable);
				},
				over: function(event, ui) {
					var $$helper = ui.helper;
					var $$draggable = ui.draggable;
					return authDrag.dropOver($(this), $$helper, $$draggable);
				},
				out: function(event, ui) {
					var $$helper = ui.helper;
					var $$draggable = ui.draggable;
					return authDrag.dropOut($(this), $$helper, $$draggable);
				}
			});
		},

		_disableDrop: function() {
			$(".s-m-auth.ui-droppable").droppable("destroy");
		},

		_createDragHelper: function($$source) {
			var $$dragSource = authDrag.getClosestDragElement($$source);
			var control = authHelpers.findControl($$dragSource);
			if (!control) {
				return;
			}

			var $$helper = $('<p class="s-m-auth-drag-helper">');
			var text;
			if (control.prototype) {
				// it's a control
				text = control.prototype.data("$title");
				if (text) {
					text = text + "(" + control.$bind + ")";
				} else {
					text = control.$bind;
				}
			} else {
				// it's a layout
				text = control.title;
				if (text) {
					text = text + " (" + control.typeName + ")";
				} else {
					text = control.typeName;
				}
			}
			$$helper.text(text);
			return $$helper[0];
		},

		_onElementClick: function(e) {
			var self = this;
			var $$o = $(e.currentTarget);

			if ($$o.is("section.s-m-card")) {
				$$o.closest("table").find(".s-m-record." + _selectedRecord).removeClass(_selectedRecord);
				$$o.closest(".s-m-record").addClass(_selectedRecord);
				// Select the card - Event bubbles
				return;
			}
			var id = $(".s-m-auth-selected", self.$$page).removeClass("s-m-auth-selected").attr("id");
			if (id) {
				notifications.publishEx(["sm.auth.remove.selection"], {
					exclude: [self]
				}, id);
			}
			id = $$o.addClass("s-m-auth-selected").attr("id");
			notifications.publishEx(["sm.auth.set.selection"], {
				exclude: [self]
			}, id);
			// Scrolling needs shiftClick and altClick
			if (utils.stopClickEvent(e)) return false;
		},

		_onElementMouseOver: function(e) {
			var self = this;
			var $$o = $(e.currentTarget);
			if ($$lastHoverElement) {
				$$lastHoverElement.removeClass("s-m-auth-hover");
				notifications.publishEx(["sm.auth.hover.out"], {
					exclude: [self]
				}, $$lastHoverElement.attr("id"));
			}
			notifications.publishEx(["sm.auth.hover.in"], {
				exclude: [self]
			}, $$o.attr("id"));
			$$o.addClass("s-m-auth-hover");
			$$lastHoverElement = $$o;
			return false;
		},

		_onElementMouseOut: function(e) {
			var self = this;
			var $$o = $(e.currentTarget);
			$$o.removeClass("s-m-auth-hover");
			notifications.publishEx(["sm.auth.hover.out"], {
				exclude: [self]
			}, $$o.attr("id"));
		},

		notifAuthHoverIn: function(id) {
			var self = this;
			var $$pageItem = self._getItemById(id);
			$$pageItem.addClass("s-m-auth-hover");
		},

		notifAuthHoverOut: function(id) {
			var self = this;
			var $$pageItem = self._getItemById(id);
			$$pageItem.removeClass("s-m-auth-hover");
		},

		notifAuthSetSelection: function(id, noScroll) {
			var self = this;
			var $$item = self._getItemById(id);
			if ($$item && $$item.length > 0) {
				$$item.addClass("s-m-auth-selected");
				if (noScroll !== true) {
					self._scrollToVisibleArea($$item);
				}
			}
		},

		notifAuthRemoveSelection: function(id) {
			var self = this;
			var $$item = self._getItemById(id);
			$$item.removeClass("s-m-auth-selected");
		},

		_getItemById: function(id) {
			var self = this;
			return $("#" + id, self.$$page);
		},

		getCurrentSelectionId: function() {
			var self = this;
			var $$item = $(".s-m-auth-selected", self.$$page);
			return $$item.attr("id");
		},

		_scrollToVisibleArea: function($$item) {
			var self = this;
			var page = globals.getApplication().currentPage;
			var scroller =
				page && page._gestureMgr ||
				page && page.rootLayout && page.rootLayout._gestureMgr;
			if (scroller) {
				scroller.makeVisible($$item);
			}
		}
	});
});

define('syracuse-tablet/html/js/ui/modals/modalChooseDevice',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="form-group s-m-scroll-element"> \
					<div class="list-group" id="modal-device-select-list-id"> \
						{{#each devices}} \
							<a draggable="false" href="#" class="list-group-item" data-action="clickDevice" data-params="{{name}}">{{label}}</a> \
						{{/each}} \
					</div> \
				</div> \
		    </div>',
	footer: ''
};

var _Klass = utils.defineClass(
	function ModalChooseDevice(device) {
		var self = this;
		modalDialog.ModalBase.call(self);
		// Init params
		self.selectedDevice = device;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "config-tile half_right";
			} else {
				displayFlags.modalClass = "config-tile full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			var devices = [];

			var site = globals.getSiteLayout();
			var devs = site.getDeviceTemplates();
			for (var dev in devs) {
				devices.push({
					name: dev,
					label: locale.textOpt("auth.device." + dev + ".title") || dev
				});
			}

			var data = {
				title: locale.text("auth.device.title"),
				devices: devices,
			};

			return data;
		},

		_onShow: function() {
			var self = this;
			modalDialog.ModalBase.prototype._onShow.call(self);
			$('a[data-params="' + self.selectedDevice + '"]').addClass("active");
		},

		// could be removed, result is set in _onAction
		_onValidate: function() {

		},
		_onCancel: function() {
			var self = this;
			self.selectedApps = {};
		},

		_onAction: function(action, param) {
			var self = this;
			if (action === "clickDevice") {
				self.selectedDevice = param;
				return true;
			}
			// dont close on actions
			return false;
		},

		_getResult: function() {
			var self = this;
			return self.selectedDevice;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalNewLayout',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
		<buttons class="pull-right"> \
			<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
			<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
		</buttons> \
		<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="alert alert-warning" role="alert"> \
					{{warning}} \
				</div> \
				<div class="form-group" id="dir"> \
					<label>{{lab_dir}}</label> \
        			<div class="btn-group btn-group-vertical btn-group-justified" data-toggle="buttons"> \
						<label class="btn btn-default {{#if horizontal}}active{{/if}}"> \
							<input type="radio" id="horizontal" name="scroll" value="horizontal" {{#if horizontal}}checked{{/if}}/>{{lab_horizontal}}\
						</label> \
						<label class="btn btn-default {{#unless horizontal}}active{{/unless}}"> \
							<input type="radio" id="vertical" name="scroll" value="vertical" {{#unless horizontal}}checked{{/unless}}/>{{lab_vertical}}\
						</label> \
					</div> \
				</div> \
				<div class="form-group" id="tpl"> \
					<label>{{lab_tpl}}</label> \
					<div class="btn-group btn-group-vertical btn-group-justified" data-toggle="buttons"> \
						<label class="btn btn-default {{#if template}}active{{/if}}"> \
							<input type="radio" id="template" name="empty" value="true" {{#if template}}checked{{/if}}/>{{lab_template}}\
						</label> \
						<label class="btn btn-default {{#unless template}}active{{/unless}}"> \
							<input type="radio" id="empty" name="empty" value="false" {{#unless template}}checked{{/unless}}/>{{lab_empty}}\
						</label> \
					</div> \
				</div> \
			</div>',
	footer: '',
};

var _Klass = utils.defineClass(
	function ModalNewLayout(_defaults) {
		var self = this;
		modalDialog.ModalBase.call(self);

		// Init params
		self._defaults = _defaults;
		// Result
		self.result = null;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "half_right";
			} else {
				displayFlags.modalClass = "full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			var data = {
				label_validate: locale.text("modal.ok"),
				label_cancel: locale.text("modal.cancel"),
				title: locale.text("modal.newlayout.title"),

				warning: locale.text("modal.newLayout.warning"),
				lab_horizontal: locale.text("modal.newLayout.horizontal"),
				lab_vertical: locale.text("modal.newLayout.vertical"),
				lab_template: locale.text("modal.newLayout.template"),
				lab_empty: locale.text("modal.newLayout.empty"),
				lab_dir: locale.text("modal.newLayout.dir"),
				lab_tpl: locale.text("modal.newLayout.tpl"),

				horizontal: self._defaults.scroll === "horizontal",
				template: self._defaults.template
			};

			return data;
		},

		_onValidate: function() {
			var self = this;
			var dir = self.$$elmt.find('#dir label.active input').val();
			var tpl = self.$$elmt.find('#tpl label.active input').val();

			self.result = {
				scroll: dir,
				template: tpl === "true"
			};
		},
		_onCancel: function() {
			var self = this;
			self.result = null;
		},

		_getResult: function() {
			var self = this;
			return self.result;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/authoring/authoringHeader',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/authoring/authoringHtml','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/modals/modalChooseDevice','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/ui/modals/modalNewLayout'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var modalChooseDevice = require('syracuse-tablet/html/js/ui/modals/modalChooseDevice');
var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var modalNewLayout = require('syracuse-tablet/html/js/ui/modals/modalNewLayout');

exports.Panel = utils.defineClass(function AuthoringPanelHeader() {
	var self = this;
	self.$$panel = null;
}, null, {

	show: function() {
		var self = this;
		self._ensurePanel();
		self._subscribe();
		self.$$panel.show();
		self._initDefaults();
	},
	hide: function() {
		var self = this;
		self._ensurePanel();
		self.$$panel.hide();
		self._unscribe();
	},

	_ensurePanel: function() {
		var self = this;
		if (this.$$panel) {
			return;
		}
		var ctx = {
			label_settings: locale.text("auth.device.settings"),
			label_save: locale.text("auth.panel.label_save"),
			label_remove: locale.text("auth.panel.label_remove"),
			label_remove_container: locale.text("auth.panel.label_remove_container"),
			label_remove_all: locale.text("auth.panel.label_remove_all"),
			label_new_layout: locale.text("auth.panel.label_new_layout"),
			label_preview_portrait: locale.text("auth.panel.label_preview_portrait"),
			label_preview_landscape: locale.text("auth.panel.label_preview_landscape"),
			label_scale_to_fit: locale.text("auth.panel.label_scale_to_fit"),
			label_undo: locale.text("auth.label_undo"),
			label_undo_all: locale.text("auth.label_undo_all"),
		};

		self.$$panel = $("#s-m-auth-panel-header-id");
		self.$$panel.append($(authHtml.execute("authPanelHeader", ctx)));
		self._getDomObjects();
		self._initDomEvents();
	},

	_getDomObjects: function() {
		var self = this;
		self.$$orientation = $("#s-m-auth-orientation-id", self.$$panel);
		self.$$removeItem = $("#s-m-auth-remove-id", self.$$panel);
		self.$$removeCnt = $("#s-m-auth-remove-cnt-id", self.$$panel);
		self.$$removeAllItems = $("#s-m-auth-remove-all-id", self.$$panel);
		self.$$newLayout = $("#s-m-auth-new-layout-id", self.$$panel);
		self.$$undo = $("#auth-btn-undo-id", self.$$panel);
		self.$$undoAll = $("#auth-btn-undo-all-id", self.$$panel);
	},

	_initDomEvents: function() {
		var self = this;

		// preview options
		$("#s-m-auth-settings-id").on("click", self._onChooseDevice.bind(self));
		$("#s-m-auth-scale-id").on("click", self._onScaleDevice.bind(self));
		$("#s-m-auth-vertical-id").on("click", self._onOrientation.bind(self));
		$("#s-m-auth-horizontal-id").on("click", self._onOrientation.bind(self));
		// Delete
		self.$$removeItem.on("click", self._onRemoveItem.bind(self));
		self.$$removeCnt.on("click", self._onRemoveCnt.bind(self));
		self.$$removeAllItems.on("click", self._onRemoveAllItems.bind(self));
		self.$$newLayout.on("click", self._onNewLayout.bind(self));
		self.$$undo.on("click", self._onUndo.bind(self));
		self.$$undoAll.on("click", self._onUndoAll.bind(self));
		// save/close
		$("#auth-btn-save-id").on("click", self._onSave.bind(self));
		$("#auth-btn-close-id").on("click", self._onClose.bind(self));
	},

	_initDefaults: function() {
		var self = this;
	},

	_subscribe: function() {
		var self = this;
		notifications.subscribe(self, ["sm.main.layout.changed"]);
		notifications.subscribe(self, ["sm.auth.set.selection"]);
		notifications.subscribe(self, ["sm.auth.change.prop.ui"]);
		notifications.subscribe(self, ["sm.auth.history.change"]);
	},

	_unscribe: function() {
		var self = this;
		notifications.unsubscribe(self, ["sm.main.layout.changed"]);
		notifications.unsubscribe(self, ["sm.auth.set.selection"]);
		notifications.unsubscribe(self, ["sm.auth.change.prop.ui"]);
		notifications.unsubscribe(self, ["sm.auth.history.change"]);
	},

	notifMainLayoutChanged: function() {
		var self = this;
		var site = globals.getSiteLayout();
		var cur = site.getCurrentLayoutSettings();

		if (cur.pageParameters.forceAutoScale === true) {
			$("#s-m-auth-scale-id").addClass('active');
		} else {
			$("#s-m-auth-scale-id").removeClass('active');
		}
		if (cur.pageParameters.orientation === "landscape") {
			$("#s-m-auth-horizontal-id").addClass('active');
			$("#s-m-auth-vertical-id").removeClass('active');
		} else {
			$("#s-m-auth-horizontal-id").removeClass('active');
			$("#s-m-auth-vertical-id").addClass('active');
		}

	},

	// Called by panel if a property like color has been changed using the simple ui
	notifAuthChangePropUi: function(articlePage) {
		var self = this;
	},

	notifAuthSetSelection: function(id) {
		var self = this;
		self._currentSelectionId = id;
		self._enableRemoveBtn();
	},

	notifAuthHistoryChange: function(history) {
		var self = this;
		if (history.articles.length > 0) {
			self.$$undo.removeClass("disabled");
			self.$$undoAll.removeClass("disabled");
		} else {
			self.$$undo.addClass("disabled");
			self.$$undoAll.addClass("disabled");
		}
	},

	_enableRemoveBtn: function() {
		var self = this;
		var stateRemove = false;
		var stateRemoveCnt = false;
		var sel, data, parent;

		if (self._currentSelectionId) {
			sel = authHelpers.getSelectionById(self._currentSelectionId);
			data = sel && authHelpers.getSelectionData(sel);
			if (!data || !data.control) {
				stateRemove = false;
			} else {
				stateRemove = true;
			}
		}

		if (data && data.control && data.control) {
			if (data.control.isRoot()) { // Never allow to remove root layout node, in page and/or in vignette
				stateRemove = false;
			}

			if (data.control.isLayout()) {
				stateRemoveCnt = true;
			}
		}

		if (stateRemove !== false) {
			self.$$removeItem.removeClass("disabled");
		} else {
			self.$$removeItem.addClass("disabled");
		}
		if (stateRemoveCnt !== false) {
			self.$$removeCnt.removeClass("disabled");
		} else {
			self.$$removeCnt.addClass("disabled");
		}
	},
	_setDeviceSize: function(size, orientation) {
		var self = this;
		var params = {
			layout: {
				pageParameters: {}
			}
		};

		if (size) {
			params.layout.pageParameters.device = size;
		}
		if (orientation) {
			params.layout.pageParameters.orientation = orientation;
		}
		authHelpers.triggerResizeInternal(params);
	},

	_onRemoveItem: function() {
		var self = this;
		if (!self._currentSelectionId) {
			return;
		}
		var sel = authHelpers.getSelectionById(self._currentSelectionId);
		var data = sel && authHelpers.getSelectionData(sel);
		if (!data || !data.control || data.control.isRoot()) {
			return;
		}
		self._enableRemoveBtn(false);
		// Change widget tree
		data.control.parent.removeChild(data.control);
		notifications.publish(["sm.auth.change.item.prop.ui"]);
	},

	_onRemoveCnt: function() {
		var self = this;
		if (!self._currentSelectionId) {
			return;
		}
		var sel = authHelpers.getSelectionById(self._currentSelectionId);
		var data = sel && authHelpers.getSelectionData(sel);
		if (!data || !data.control) {
			return;
		}

		data.control.removeChildren();
		notifications.publish(["sm.auth.change.item.prop.ui"]);
	},

	_onRemoveAllItems: function() {
		// Rebuild and apply new article
		var page = globals.getApplication().currentPage;
		page.rootLayout.removeChildren();
		notifications.publish(["sm.auth.change.item.prop.ui"]);
	},

	_onClose: function() {
		var self = this;
		notifications.publish(["sm.auth.close"]);
	},

	_onSave: function() {
		var self = this;
		notifications.publish(["sm.auth.save"]);
	},

	_onChooseDevice: function(elmt) {
		var self = this;
		var site = globals.getSiteLayout();
		var cur = site.getCurrentLayoutSettings();

		var modal = new modalChooseDevice.Modal(cur.pageParameters.device);
		modal.show().then(function(result) {
			if (result != null) {
				self._setDeviceSize(result);
				notifications.publish(["sm.auth.display.changed"], "device");
			}
		});
	},

	_onScaleDevice: function(elmt) {
		var site = globals.getSiteLayout();
		var cur = site.getCurrentLayoutSettings();

		var params = {
			layout: {
				pageParameters: {
					forceAutoScale: cur.pageParameters.forceAutoScale === false
				}
			}
		};
		authHelpers.triggerResizeInternal(params);
		notifications.publish(["sm.auth.display.changed"], "scale");
	},

	_onOrientation: function(elmt) {
		var self = this;
		var orient = $(elmt.currentTarget).attr("data-auth-orientation");
		if (orient) {
			self._setDeviceSize(null, orient);
			notifications.publish(["sm.auth.display.changed"], "orientation");
		}
	},

	_onNewLayout: function() {
		var self = this;

		var page = globals.getApplication().currentPage;
		var data = {
			scroll: jsutils.isInstanceOf(page, "DashboardPage") ? "horizontal" : "vertical",
			template: true
		};
		var modal = new modalNewLayout.Modal(data);
		modal.show().then(function(result) {
			if (result != null) {
				notifications.publish(["sm.auth.new.layout"], result.scroll, result.template);
			}
		});
	},

	_onUndo: function() {
		notifications.publish(["sm.auth.undo"], false);
	},

	_onUndoAll: function() {
		notifications.publish(["sm.auth.undo"], true);
	}
});
});

define('syracuse-tablet/html/js/authoring/authoringFooter',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/authoring/authoringHtml'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');

exports.Panel = utils.defineClass(function AuthoringPanelFooter() {
	var self = this;
	self.$$panel = null;
}, null, {
	show: function() {
		var self = this;

		self._ensurePanel();
		self._subscribe();

		self.$$panel.show();

		self._initDefaults();
	},
	hide: function() {
		var self = this;
		self._ensurePanel();
		self.$$panel.hide();

		self._unscribe();
	},

	_ensurePanel: function() {
		var self = this;
		if (this.$$panel) {
			return;
		}

		var ctx = {};

		self.$$panel = $("#s-m-auth-panel-footer-id");
		self.$$panel.append($(authHtml.execute("authPanelFooter", ctx)));

		self._getDomObjects();
		self._initDomEvents();
	},

	_getDomObjects: function() {
		var self = this;
	},

	_initDomEvents: function() {
		var self = this;
	},

	_initDefaults: function() {
		var self = this;
	},

	_subscribe: function() {
		var self = this;
		notifications.subscribe(self, ["sm.main.layout.changed"]);
		notifications.subscribe(self, ["sm.auth.set.selection"]);
		notifications.subscribe(self, ["sm.auth.change.prop.ui"]);
	},

	_unscribe: function() {
		var self = this;
		notifications.unsubscribe(self, ["sm.main.layout.changed"]);
		notifications.unsubscribe(self, ["sm.auth.set.selection"]);
		notifications.unsubscribe(self, ["sm.auth.change.prop.ui"]);
	},

	notifMainLayoutChanged: function() {
		var self = this;
	},

	// Called by panel if a property like color has been changed using the simple ui
	notifAuthChangePropUi: function(articlePage) {
		var self = this;
	},

	notifAuthSetSelection: function(id) {
		var self = this;
	}
});
});

define('syracuse-tablet/html/js/ui/modals/modalSaveAuth',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
			<div class="s-m-scroll-element"> \
				<div class="form-group"> \
					<label>{{label_code}}</label> \
					<input class="form-control" id="authCode" value="{{authCodeDefault}}" /> \
				</div> \
				<div class="form-group"> \
					<label>{{label_title}}</label> \
					<input class="form-control" id="authTitle" value="{{authTitleDefault}}" /> \
				</div> \
				<div class="form-group"> \
					<label>{{label_description}}</label> \
					<input class="form-control" id="authDescription" value="{{authDescriptionDefault}}"  /> \
				</div> \
				<label>{{label_saveas_option}}</label> \
				<div class="btn-group btn-group-justified" data-toggle="buttons"> \
					<div class="btn-group"> \
						<label class="btn btn-primary"> \
							<input type="radio" name="options" id="personal_copy" checked>{{label_personal}} \
						</label> \
					</div> \
					<div class="btn-group"> \
						<label class="btn btn-primary"> \
							<input type="radio" name="options" id="global_variant"> {{label_global}} \
						</label> \
					</div> \
					<div class="btn-group"> \
						<label class="btn btn-primary active"> \
							<input type="radio" name="options" id="factory_variant">{{label_factory}} \
						</label> \
					</div> \
				</div> \
			</div> \
			</div>',
	footer: ''
};

var _Klass = utils.defineClass(
	function ModalSaveAuth(saveContext) {
		var self = this;
		modalDialog.ModalBase.call(self);

		self.saveContext = saveContext;

		// Result
		self.result = null;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "config-tile half_right";
			} else {
				displayFlags.modalClass = "config-tile full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			var data = {
				title: locale.text("auth.save.title"),
				page: self.saveContext.pageName,
				authCodeDefault: self.saveContext.code,
				authTitleDefault: self.saveContext.title,
				authDescriptionDefault: self.saveContext.description,

				label_code: locale.text("auth.panel.label_code"),
				label_title: locale.text("auth.panel.label_title"),
				label_description: locale.text("auth.panel.label_description"),
				label_saveas_option: locale.text("auth.panel.label_saveas_option"),
				label_personal: locale.text("auth.panel.label_personal"),
				label_global: locale.text("auth.panel.label_global"),
				label_factory: locale.text("auth.panel.label_factory"),

				label_save: locale.text("auth.panel.label_save"),
				label_cancel: locale.text("auth.panel.label_cancel"),
			};

			return data;
		},

		_onValidate: function() {
			var self = this;
			var code = self.$$elmt.find("#authCode").val();
			var title = self.$$elmt.find("#authTitle").val();
			var description = self.$$elmt.find("#authDescription").val();
			self.result = {
				code: code,
				title: title,
				description: description,
				saveAs: $("input:radio:checked", self.$$elmt)[0].id
			};
		},

		_onCancel: function() {
			var self = this;
			self.result = null;
		},

		_getResult: function() {
			var self = this;
			return self.result;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/authoring/authoring',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/authoring/authoringHelpers','syracuse-tablet/html/js/authoring/authoringPanelRight','syracuse-tablet/html/js/authoring/authoringPanelLeft','syracuse-tablet/html/js/authoring/authoringPage','syracuse-tablet/html/js/authoring/authoringHeader','syracuse-tablet/html/js/authoring/authoringFooter','syracuse-tablet/html/js/authoring/authoringArticleGen','syracuse-tablet/html/js/authoring/authoringVal','syracuse-tablet/html/js/ui/modals/modalSaveAuth','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/authoring/authoringProperties','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var authoringPanelRight = require('syracuse-tablet/html/js/authoring/authoringPanelRight');
var authoringPanelLeft = require('syracuse-tablet/html/js/authoring/authoringPanelLeft');
var authoringPage = require('syracuse-tablet/html/js/authoring/authoringPage');
var authoringHeader = require('syracuse-tablet/html/js/authoring/authoringHeader');
var authoringFooter = require('syracuse-tablet/html/js/authoring/authoringFooter');
var authoringArticleGen = require('syracuse-tablet/html/js/authoring/authoringArticleGen');
var authVal = require('syracuse-tablet/html/js/authoring/authoringVal');
var modalSaveAuth = require('syracuse-tablet/html/js/ui/modals/modalSaveAuth');

var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var authProps = require('syracuse-tablet/html/js/authoring/authoringProperties');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _authInterface;
var _saveContext;

/*
 * This module glues together the action done in the page and the two panels
 */

exports.toggleDesignPage = function() {
	if (!_authInterface) {
		_authInterface = new AuthInterface();
	}

	_authInterface.toggleDesignPage();
};
// Called on unload event - application.onUnload
exports.destroy = function() {
	if (!_authInterface) return;
	_authInterface.destroy();
	_authInterface = null;
};
var AuthInterface = utils.defineClass(function AuthoringInterface() {
	var self = this;
	self.$$authPanel = null;
	self.isActive = false;

	self.undoHistory = {
		pageName: null, // Page for which this history is valid (to detect page change)
		articles: [] // List of articles, history of changes
	};
	self.isDirty = false // True if not all changes are saved yet, used by close button;

	/*
	 * Right panel interaction
	 */
	self.rightPanel = new authoringPanelRight.Panel();

	/*
	 * Left panel interaction
	 */
	self.leftPanel = new authoringPanelLeft.Panel();

	/*
	 * Header
	 */
	self.headerPanel = new authoringHeader.Panel();

	/*
	 * Footer
	 */
	self.footerPanel = new authoringFooter.Panel();

	/*
	 * Page interaction
	 */
	self.authPage = new authoringPage.AuthPage();

	authProps.initProperties(authHelpers);
	authVal.setProperties(authProps);
}, null, {

	destroy: function() {
		var self = this;
		// TODO - improve destroy
		["rightPanel", "leftPanel", "headerPanel", "authPage"].forEach(function(p) {
			if (self[p] && self[p].destroy) {
				self[p].destroy();
			}
			self[p] = null;
		});
	},

	toggleDesignPage: function(forceStatus) {
		var self = this;

		if (self.isActive || forceStatus === false) {
			self.disable();
		} else {
			self.enable();
		}
		// No need to load data
		authHelpers.triggerResizeInternal();
	},

	enable: function() {
		var self = this;

		self._subscribe();

		self.authPage.enable();
		self.rightPanel.show();
		self.leftPanel.show();
		self.headerPanel.show();
		self.footerPanel.show();

		var page = globals.getApplication().currentPage;
		notifications.publish(["sm.auth.set.page"], page);

		authHelpers.triggerResizeInternal({
			layout: {
				authPanelLeft: {
					visible: true
				},
				authPanelRight: {
					visible: true
				},
				authPanelHeader: {
					visible: true
				},
				authPanelFooter: {
					visible: true
				},
				pageParameters: {
					forcePreview: true
				}
			}
		});

		self.authPage.enableAuthCss();

		self.isActive = true;
		self.isDirty = false;
		globals.setAuthoringActive(true);
	},

	disable: function() {
		var self = this;

		self.authPage.disable();
		self.rightPanel.hide();
		self.leftPanel.hide();
		self.headerPanel.hide();
		self.footerPanel.hide();
		self.isActive = false;

		self.authPage.disableAuthCss();

		authHelpers.triggerResizeInternal({
			layout: {
				authPanelLeft: {
					visible: false
				},
				authPanelRight: {
					visible: false
				},
				authPanelHeader: {
					visible: false
				},
				authPanelFooter: {
					visible: false
				},
				pageParameters: {
					forcePreview: false
				}
			}
		});
		self.isActive = false;
		self._unscribe();
		globals.setAuthoringActive(false);
	},

	_subscribe: function() {
		var self = this;
		notifications.subscribe(self, ["sm.page.loaded"]);
		notifications.subscribe(self, ["sm.auth.change.item.prop.ui"]);
		notifications.subscribe(self, ["sm.auth.change.prop.ui"]);
		notifications.subscribe(self, ["sm.auth.close"]);
		notifications.subscribe(self, ["sm.auth.save"]);
		notifications.subscribe(self, ["sm.auth.new.layout"]);
		notifications.subscribe(self, ["sm.auth.set.page"]);
		notifications.subscribe(self, ["sm.auth.display.changed"]);
		notifications.subscribe(self, ["sm.auth.undo"]);
	},

	_unscribe: function() {
		var self = this;
		notifications.unsubscribe(self, ["sm.page.loaded"]);
		notifications.unsubscribe(self, ["sm.auth.change.item.prop.ui"]);
		notifications.unsubscribe(self, ["sm.auth.change.prop.ui"]);
		notifications.unsubscribe(self, ["sm.auth.close"]);
		notifications.unsubscribe(self, ["sm.auth.save"]);
		notifications.unsubscribe(self, ["sm.auth.new.layout"]);
		notifications.unsubscribe(self, ["sm.auth.set.page"]);
		notifications.unsubscribe(self, ["sm.auth.display.changed"]);
		notifications.unsubscribe(self, ["sm.auth.undo"]);
	},

	notifPageLoaded: function(page) {
		var self = this;
		if (!self.isActive) {
			return;
		}

		if (page && page.state && page.state.disableAuthoring) {
			self.authPage.disableAuthCss();
			self.toggleDesignPage();
			return;
		}

		if (page && !page.isVignette) {
			notifications.publish(["sm.auth.set.page"], page);
		}
		self.authPage.enableAuthCss();
	},

	notifAuthSetPage: function(page) {
		var self = this;
		self.currentPageName = page.state.authoringName;

		// Copy of article before we start changing it
		self.displayedArticle = JSON.stringify(page.article);

		// Clean history on page change
		if (self.currentPageName !== self.undoHistory.pageName) {
			self.undoHistory.pageName = self.currentPageName;
			self.undoHistory.articles = [];
			notifications.publish(["sm.auth.history.change"], self.undoHistory);
		}
	},

	// Called if a new article is to be applied on the page by a user interaction
	// Here, we need to put the previous article in the undo buffer
	notifAuthChangePropUi: function(articlePage, states, autoScroll) {
		var self = this;

		if (self.displayedArticle != null) {
			self.isDirty = true; // As soon as we put something into the undo history, we got dirty changes we need to save

			self.undoHistory.articles.push(self.displayedArticle);
			notifications.publish(["sm.auth.history.change"], self.undoHistory);
			self.displayedArticle = null;
		}
		self._updateLayoutPage(articlePage, states, autoScroll);
	},

	// Called by panels if something has changed to trigger a repaint of the page content and also reinitialize the panels
	notifAuthChangeItemPropUi: function(data) {
		var self = this;
		var page = globals.getApplication().currentPage;
		var states = {}, autoScroll;
		if (data.control && data.control.controller._gestureMgr) {
			autoScroll = data.control.controller._gestureMgr.getScrollValue();
		}
		var articleJSON = authHelpers.rebuildArticleByPageStruct(page, states);
		notifications.publish(["sm.auth.change.prop.ui"], articleJSON, states, autoScroll);
	},

	notifAuthClose: function(articlePage) {
		var self = this;
		if (self.currentPageName && self.currentPageName.indexOf(".carddesign") > 0) {
			// No close authoring - Just back to previous page
			globals.getApplication().goBack();
			return;
		}
		if (self.isDirty === true) {
			modal.simpleConfirmPromise({
				message: locale.text("auth.msg.close")
			})
				.then(function(result) {
					if (result.action === "yes") {
						self.undoHistory.articles = [];
						self.disable();
					}
				});
		} else {
			self.undoHistory.articles = [];
			self.disable();
		}
	},

	/**
	 * When we change orientation, device, scale
	 * type = orientation, device, scale
	 */
	notifAuthDisplayChanged: function(type) {
		// We need to remove current selection
		// Indeed, sometimes authoring depends on the type of device or orientation
		// We remove the current selection in order to recreate it on click with new context
		// Ex: query filters are forced to tabs' for smartphone so we must not display property 'Filters' for $resources if device= smartphone
		this.leftPanel.setSelection(null);
	},


	notifAuthSave: function() {
		var self = this;
		var article = self.rightPanel.getPageArticle();
		var articleParsed = authVal.validateJSON(true, article, authProps.getAllProperties());
		if (!articleParsed) {
			return;
		}

		_saveContext = _saveContext || {
			code: locale.text("auth.panel.authCodeDefault"),
			title: locale.text("auth.panel.authTitleDefault"),
			description: locale.text("auth.panel.authDescriptionDefault"),
			saveAs: "personal_copy"
		};
		_saveContext.pageName = self.currentPageName;
		var modal = new modalSaveAuth.Modal(_saveContext);
		modal.show()
			.then(function(ctx) {
				if (ctx != null) {
					_saveContext = ctx; // Remember for next time

					var params = {
						code: ctx.code,
						title: ctx.title,
						description: ctx.description,

						// "factory_variant", "personal_copy", "global_variant"
						// -> "shared_copy" not yet supported
						saveAs: ctx.saveAs,
						article: articleParsed
					};
					authHelpers.saveAuthoring(self.currentPageName, params);

					self.isDirty = false;
				}
			}).fail(function(e) {
				globals.getModal().error(e);
			});
	},

	notifAuthNewLayout: function(type, template) {
		var page = globals.getApplication().currentPage;
		authoringArticleGen.genNewArticle({
			page: page,
			orientation: type,
			template: template
		})
			.then(function(article) {
				var articleJSON = authVal.toSortedJSON(article);
				notifications.publish(["sm.auth.change.prop.ui"], articleJSON);
			})
			.fail(function(e) {
				modal.error(e);
			});
	},

	notifAuthUndo: function(all) {
		var self = this;
		var article;
		if (all) {
			article = self.undoHistory.articles.shift();
			self.undoHistory.articles = [];
		} else {
			article = self.undoHistory.articles.pop();
		}

		notifications.publish(["sm.auth.history.change"], self.undoHistory);
		notifications.publishEx(["sm.auth.change.prop.ui"], {
			exclude: [self]
		}, article);

		self._updateLayoutPage(article);
	},

	_updateLayoutPage: function(articlePage, states, autoScroll) {
		var self = this;
		var page = globals.getApplication().currentPage;
		try {
			var articleParsed = JSON.parse(articlePage);
		} catch (e) {
			// Never end up here because validated before
		}
		if (!articleParsed) {
			return;
		}

		var path = self._findSelectionPath();

		authHelpers.savePanelStates();

		// Copy of article before we start changing it once again
		self.displayedArticle = articlePage;

		self.authPage.disableAuthCss();
		page.authUpdateLayout(articleParsed)
			.then(function() {
				self.authPage.enableAuthCss();
				if (states) {
					self._applyPreviousStates(states);
				}
				self._selectByPath(path, autoScroll);
			});

	},

	_applyPreviousStates: function(states) {
		var self = this;
		var page = globals.getApplication().currentPage;
		for (var statePath in states) {
			statePath = statePath.length > 0 ? statePath.split(".") : [];
			var node = page.rootLayout.findChildByPath(statePath);
			if (node) {
				node.setAuthState(states[statePath]);
			}
		}
	},

	_findSelectionPath: function() {
		var self = this;
		var id = self.authPage.getCurrentSelectionId();
		var sel = id && authHelpers.getSelectionById(id);
		var data = sel && authHelpers.getSelectionData(sel);
		if (!data || !data.control) {
			return null;
		}
		var path = data.control.getPathInTree();
		return path;
	},

	_selectByPath: function(path, autoScroll) {
		var self = this;
		if (!path) {
			return;
		}
		var page = globals.getApplication().currentPage;
		var node = page.rootLayout.findChildByPath(path);

		if (node) {
			if (autoScroll != null && node.controller && node.controller._gestureMgr) {
				setTimeout(function() {
					//node.controller._gestureMgr.autoScroll(autoScroll)
				}, 100);
			}
			notifications.publishEx(["sm.auth.set.selection"], {
				exclude: [self]
			}, node.id);
		}
	}
});
});

define('syracuse-tablet/html/js/ui/developmentPage',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/storage/localStorage'],function (require, exports, module) {

var globals = require('syracuse-tablet/html/js/helpers/globals');
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var localStorage = require('syracuse-tablet/html/js/storage/localStorage');

var _template = '\
	<div id="page_dev_mode" style="margin: 0; width: auto; position: absolute; z-index: 9999"> \
    <div class="modal-dialog" style="margin: 0; width: auto;"> \
		<div class="modal-content" style="width: 230px;"> \
		    <div class="modal-header"> \
				<h4 class="modal-title">{{title}}</h4> \
		    </div> \
		    <div class="modal-body"> \
				<div class="form-group"> \
					<label>{{label_device}}</label>\
					<select class="form-control" id="dev-select-device"> \
					{{#each devices}}\
						<option value="{{this.device}}.{{this.orientation}}" {{#if this.selected}}selected{{/if}}>\
						{{this.description}}\
						</option>\
					{{/each}}\
					</select>\
					<span class="input-group"> \
						<input id="dev-device-scale" type="checkbox" {{#if scaleChecked}}checked{{/if}}>{{label_scale}} \
					</span> \
				</div> \
				<div class="form-group"> \
					<span class="input-group"> \
						<input id="dev-cache" type="checkbox" {{#if cacheChecked}}checked{{/if}}>{{label_cache}} \
	  				</span> \
				</div> \
			</div> \
		    <div class="modal-footer"> \
				<button type="button" class="btn" id="btn_dev_close">{{label_close}}</button> \
				<button type="button" class="btn btn-default" id="btn_dev_apply">{{label_apply}}</button> \
    			<button type="button" class="btn" id="btn_dev_ok">{{label_ok}}</button> \
			</div> \
		</div> \
	</div> \
	</div>';

var _show = function() {
	_setActive(true);

	if ($("#page_dev_mode").is(":visible")) {
		return;
	}
	var modalHtml = Handlebars.compile(_template);
	var cache = globals.getCache();
	var site = globals.getSiteLayout();
	var devs = site.getDeviceTemplates();
	var cur = site.getCurrentLayoutSettings();

	var lastDev = localStorage.getItem("devPanelDevice");

	var ctx = {
		title: "Development settings",

		label_device: "Device",
		devices: [],

		label_scale: "Scale if needed",

		label_cache: "Disable caching",

		label_close: "Cancel",
		label_ok: "Ok",
		label_apply: "Apply",

		scaleChecked: localStorage.getItem("devPanelScale") === "true",
		cacheChecked: localStorage.getItem("devPanelCache") === "true"
	};

	ctx.devices.push({
		device: "<No emulation>",
		orientation: "landscape",
		description: "<No emulation>",
		selected: lastDev === "<No emulation>.landscape",
	});

	for (var dev in devs) {
		devs[dev].orientations.forEach(function(o) {
			var devName = dev;
			var orientName = o;

			var opt = {
				device: dev,
				orientation: o,
				description: devName + " (" + o + ")"
			};

			opt.selected = (lastDev === opt.device + "." + opt.orientation);
			ctx.devices.push(opt);
		});
	}

	modalHtml = modalHtml(ctx);
	$("body").append($(modalHtml));
	var $$page = $("#page_dev_mode");
	$$page.draggable();

	$("#btn_dev_ok", $$page).on("click", function() {
		apply();
		$$page.remove();
	});
	$("#btn_dev_apply", $$page).on("click", function() {
		apply();
	});

	$("#btn_dev_close", $$page).on("click", function() {
		_setActive(false);
		$$page.remove();
	});

	var apply = function() {
		var device = $$page.find("#dev-select-device").val();
		var dev = device.split(".");
		var params = {
			layout: {
				pageParameters: {}
			}
		};
		localStorage.setItem("devPanelDevice", device);
		if (device === "<No emulation>.landscape") {
			params.layout.pageParameters.forcePreview = false;
			params.layout.pageParameters.forceAutoScale = false;
		} else {
			params.layout.pageParameters.device = dev[0];
			params.layout.pageParameters.orientation = dev[1];
			params.layout.pageParameters.forcePreview = true;

			if ($("#dev-device-scale", $$page).is(":checked") === true) {
				params.layout.pageParameters.forceAutoScale = true;
				localStorage.setItem("devPanelScale", "true");
			} else {
				params.layout.pageParameters.forceAutoScale = false;
				localStorage.setItem("devPanelScale", "false");
			}
		}

		if ($("#dev-cache", $$page).is(":checked") === true) {
			localStorage.setItem("devPanelCache", "true");
			cache.disableCache(true);
		} else {
			localStorage.setItem("devPanelCache", "false");
			cache.disableCache(false);
		}

		uiutils.triggerResizeInternal(params);
	};

	apply();
};

function _setActive(flag) {
	localStorage.setItem("devPanelOpen", flag ? "true" : "false");
}

exports.wasActive = function() {
	return localStorage.getItem("devPanelOpen") === "true";
};

exports.show = _show;
});

define('syracuse-tablet/html/js/ui/modals/modalShowLegal',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/sdata/sdataHttp','syracuse-tablet/html/js/helpers/types/date'],function (require, exports, module) {

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var sdataHttp = require('syracuse-tablet/html/js/sdata/sdataHttp');
var date = require('syracuse-tablet/html/js/helpers/types/date');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
			<div class="s-m-scroll-element"> \
				<div class="form-group"> \
					<div class="s-m-header-brand"> \
						<span class="s-m-brand">{{label_brand}}</span> \
						<span class="s-m-product">{{label_product}}</span> \
					</div> \
					<span class="s-m-product-update-label">{{label_update}}</span><span class="s-m-product-update-value">{{update}}</span> \
				</div> \
				<div class="form-group"> \
					<h3>{{label_legal}}</h3> \
					<label>{{text1}}</label> \
					<label>{{text2}}</label> \
					<label>{{text3}}</label> \
					<label>{{text4}}</label> \
					<label>{{text5}}</label> \
					<label>{{text6}}</label> \
				</div> \
				<div class="form-group"> \
					<h3>{{label_license}}</h3> \
					{{#each licenses}} \
						<div class="s-m-field"><div class="s-m-title">{{../label_registrationNumber}}</div><div class="s-m-value">{{toRegNum}}</div></div> \
						<div class="s-m-field"><div class="s-m-title">{{../label_licensedTo}}</div><div class="s-m-value">{{toName}}</div></div> \
						<div class="s-m-field"><div class="s-m-title">{{../label_reference}}</div><div class="s-m-value">{{toRefNum}}</div></div> \
						<div class="s-m-field"><div class="s-m-title">{{../label_installedBy}}</div><div class="s-m-value">{{installedBy}}</div></div> \
						<div class="s-m-field"><div class="s-m-title">{{../label_expiryDate}}</div><div class="s-m-value">{{expiryDate}}</div></div> \
					{{/each}} \
				</div> \
				{{#if userAgent}} \
					<h3>{{label_user_agent}}</h3> \
					<div class="form-group"> \
						<label>{{userAgent}}</label> \
						<label>{{lookAndFeel}}</label> \
					</div> \
				{{/if}} \
			</div> \
			</div>',
	footer: ''
};

var _Klass = utils.defineClass(
	function ModalShowLegal() {
		var self = this;
		modalDialog.ModalBase.call(self);
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "show-legal half_right";
			} else {
				displayFlags.modalClass = "show-legal full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			return sdataHttp.send({
				method: "GET",
				url: "/sdata/syracuse/collaboration/syracuse/licenses/$service/current"
			}).
			then(function(data) {
				var version = null;
				var licenses = [];
				if (data && data.responseJSON)
					data.responseJSON.forEach(function(lic) {
						var l = {};
						l.expiryDate = locale.text("modal.legal.license.expiryDateValue", [date.getLocalShortDate(lic.validFrom), date.getLocalShortDate(lic.expiryDate)]);
						l.toName = lic.licensedTo.name;
						l.toRegNum = lic.licensedTo.registrationNumber;
						l.toRefNum = lic.licensedTo.reference;
						l.installedBy = lic.reseller.name;

						licenses.push(l);
						if (!version) {
							version = lic.productVersion;
						}
					});

				var data = {
					title: locale.text("modal.legal.title"),
					label_brand: locale.text("modal.legal.title_brand"),
					label_product: locale.text("modal.legal.title_x3"),
					label_update: locale.text("modal.legal.update"),
					label_license: locale.text("modal.legal.about.license"),
					label_legal: locale.text("modal.legal.about.legal"),
					label_user_agent: locale.text("modal.legal.about.user_agent"),
					update: version,
					licenses: licenses,
					builddate: locale.text("modal.legal.builddate", [globals.getBuildTimeStamp()]),
					text1: locale.text("modal.legal.text1"),
					text2: locale.text("modal.legal.text2"),
					text3: locale.text("modal.legal.text3"),
					text4: locale.text("modal.legal.text4"),
					text5: locale.text("modal.legal.text5"),
					text6: locale.text("modal.legal.text6"),
					label_registrationNumber: locale.text("modal.legal.license.registrationNumber"),
					label_licensedTo: locale.text("modal.legal.license.licensedTo"),
					label_reference: locale.text("modal.legal.license.reference"),
					label_userLicense: locale.text("modal.legal.license.userLicense"),
					label_installedBy: locale.text("modal.legal.license.installedBy"),
					label_server: locale.text("modal.legal.license.server"),
					label_expiryDate: locale.text("modal.legal.license.expiryDate"),
					userAgent: globals.isDvlpMode() ? navigator.userAgent : "",
					lookAndFeel: globals.isDvlpMode() ? globals.getLookAndFeel() : ""
				};

				return data;
			});
		},

		_onValidate: function() {},

		_onCancel: function() {},

		_getResult: function() {}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalSettings',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/helpers/globals'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var globals = require('syracuse-tablet/html/js/helpers/globals');

var _templateAll = {
	header: '\
		<buttons class="pull-right"> \
			<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
			<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
		</buttons> \
		<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="form-group s-m-scroll-element"> \
					<header>{{label_device}}</header> \
					<div class="btn-group btn-group-justified" data-toggle="buttons" id="s-m-radio-type-id"> \
						<div class="btn-group"> \
							<label class="btn btn-primary" data-action="clickType" data-params="auto"> \
								<input type="radio" name="s-m-radio-type">{{label_auto}} \
							</label> \
						</div> \
						<div class="btn-group"> \
							<label class="btn btn-primary" data-action="clickType" data-params="smartphone"> \
								<input type="radio" name="s-m-radio-type">{{label_smartphone}} \
							</label> \
						</div> \
						<div class="btn-group"> \
							<label class="btn btn-primary" data-action="clickType" data-params="tablet"> \
								<input type="radio" name="s-m-radio-type">{{label_tablet}} \
							</label> \
						</div> \
					</div> \
					<header id="s-m-cache-id">{{label_cache}}</header> \
					<label id="s-m-cache-clear-id" class="btn btn-primary" data-action="clearCache" data-params="clear">{{label_cache_clear}}</label> \
					<label id="s-m-cache-confirm-id" class="btn btn-primary" data-action="clearCache" data-params="confirm" style="display: none;">{{label_cache_confirm}}</label> \
					<label id="s-m-cache-cancel-id" class="btn btn-warning" data-action="clearCache" data-params="cancel" style="display: none;">{{label_cache_cancel}}</label> \
					<div class="progress" style="display: none;"> \
						<div class="progress-bar progress-bar-striped active" role="progressbar" aria-valuenow="45" aria-valuemin="0" aria-valuemax="100" style="width: 100%">{{label_clearing}}</div> \
					</div> \
					<div class="alert alert-success" role="alert" style="display: none">{{label_clearing_ok}}</div> \
					</label> \
					<div style="width:100%; display: inline-block;"></div> \
				</div> \
			</div>',

	footer: '',
};

var _Klass = utils.defineClass(
	function ModalSettings(settings) {
		var self = this;
		modalDialog.ModalBase.call(self);

		self.settings = settings && $.extend(true, {}, settings) || {};
		self.settings["device-type"] = self.settings["device-type"] || "auto";

		// Result
		self.result = null;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll,
				smartphone: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "settings half_right";
			} else {
				displayFlags.modalClass = "settings full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			var data = {
				title: locale.text("settings.title"),

				label_device: locale.text("settings.device.label"),
				label_auto: locale.text("settings.device.auto"),
				label_smartphone: locale.text("settings.device.smartphone"),
				label_tablet: locale.text("settings.device.tablet"),

				label_cache: locale.text("settings.cache.label"),
				label_cache_clear: locale.text("settings.cache.clear"),
				label_cache_confirm: locale.text("settings.cache.confirm"),
				label_cache_cancel: "", //locale.text("settings.cache.cancel"),

				label_clearing: locale.text("settings.cache.clearing"),
				label_clearing_ok: locale.text("settings.cache.clearing_ok"),
			};

			return data;
		},
		_onShow: function() {
			var self = this;
			modalDialog.ModalBase.prototype._onShow.call(self);

			// Apply UI states
			$("label[data-params='" + self.settings["device-type"] + "']", self.$$elmt).eq(0).button("toggle");
		},
		// could be removed, result is set in _onAction
		_onValidate: function() {
			var self = this;
			var $$active = $("#s-m-radio-type-id .active ", this.$$elmt);
			var deviceType = $$active.length < 1 ? "auto" : $$active.attr("data-params") || "auto";
			self.settings["device-type"] = deviceType;
			self.result = self.settings;
		},
		_onCancel: function() {
			var self = this;
			self.result = null;
		},

		_onAction: function(action, param) {
			var self = this;
			switch (action) {
				case "clickType":
					$("label[data-params='" + param + "']", self.$$elmt).eq(0).button("toggle");
					break;
				case "clearCache":
					self._clearCache(param);
					break;
			}
			// dont close on actions
			return false;
		},

		_clearCache: function(param) {
			var self = this;
			switch (param) {
				case "clear":
					$("label[data-params='clear']", self.$$elmt).hide();
					$("label[data-params='cancel']", self.$$elmt).show();
					$("label[data-params='confirm']", self.$$elmt).show();
					return;
				case "cancel":
					$("label[data-params='clear']", self.$$elmt).show();
					$("label[data-params='cancel']", self.$$elmt).hide();
					$("label[data-params='confirm']", self.$$elmt).hide();
					return;
			}

			$("label[data-params='cancel']", self.$$elmt).hide();
			$("label[data-params='confirm']", self.$$elmt).hide();
			$(".progress", self.$$elmt).show();

			return globals.getCache().clearCache()
				.always(function() {
					$(".progress", self.$$elmt).hide();
					$(".alert", self.$$elmt).show();
					setTimeout(function() {
						$(".alert", self.$$elmt).hide();
						$("label[data-params='clear']", self.$$elmt).show();
					}, 3000);
				});
		},

		_getResult: function() {
			var self = this;
			return self.result;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/application/application',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/application/authentication','syracuse-tablet/html/js/application/eventListener','syracuse-tablet/html/js/application/pageLoader','syracuse-tablet/html/js/init/initContext','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/application/pageRegistry','syracuse-tablet/html/js/authoring/authoring','syracuse-tablet/html/js/ui/developmentPage','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/application/settings','syracuse-tablet/html/js/ui/modals/modalShowLegal','syracuse-tablet/html/js/ui/modals/modalSettings'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("app");
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var auth = require('syracuse-tablet/html/js/application/authentication');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var pageLoader = require('syracuse-tablet/html/js/application/pageLoader');
var initContext = require('syracuse-tablet/html/js/init/initContext');
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var pageRegistry = require('syracuse-tablet/html/js/application/pageRegistry');
var authoring = require('syracuse-tablet/html/js/authoring/authoring');
var developmentPage = require('syracuse-tablet/html/js/ui/developmentPage');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var settings = require('syracuse-tablet/html/js/application/settings');
var modalShowLegal = require('syracuse-tablet/html/js/ui/modals/modalShowLegal');
var modalSettings = require('syracuse-tablet/html/js/ui/modals/modalSettings');

/**
 * Default application config
 */
var _appConfig = {
	transition: null,
	// FDB - openLinkInVignette=true to allow test in vignettes (children page, lookup...)
	// MW - Changed to false as default since this is more what we are going to use.
	openLinkInVignette: false,
	// FK - to allow display of user photo
	loadUserImage: true
};
/**
 * Subscriptions
 */
var _subscribe = function(self) {
	notifications.subscribe(self, ["sm.context.changed", "sm.switch.app", "sm.modal.open", "sm.modal.close", "sm.main.layout.changed"], 1);
};
/**
 * Tablet application class
 */
var _Application = utils.defineClass(
	function($$elmt, factory) {
		var self = this;
		self.$$elmt = $$elmt;
		self.currentPage = null;
		self._$config = $.extend(true, {}, _appConfig);
		self.factory = factory;
		self._pageLoader = null;
		self._nbModals = 0;
		self._wait = uiutils.waitWheelCreate($$elmt);
		// Id of the home dashboard of current application
		// Used to go to home page
		self.homePageId = null;
		// Default appid when login page is loaded without current application
		self.uuid = "root";
		// Application history stack
		self.history = [];
		// Force pushState on first page
		self.pushState = true;
	}, null, {
		/**
		 * Called after object has been created
		 **/
		init: function() {
			var self = this;
			// Can't be called in constructor
			eventListener.bindEvents(self);
			self.dao = self.factory.createDaoApp(self);
			_subscribe(self);
			self.$$elmt.show();
		},

		destroy: function() {
			var self = this;
			authoring.destroy();
			if (self._wait) {
				uiutils.waitWheelDestroy(self._wait);
				self._wait = null;
			}
			notifications.unsubscribe();
			if (self.$$elmt) {
				self.removeAllChildPages(self.$$elmt);
				utils.unbindObj(self.$$elmt);
				self.$$elmt = null;
				self.currentPage = null;
			}
			if (self.dao) {
				self.dao.destroy();
				self.dao = null;
			}
			if (self._pageLoader) {
				self._pageLoader.destroy();
				self._pageLoader = null;
			}
			utils.unbindObj(self);
			$(window).unbind();
		},
		// Called on page reload
		onUnload: function() {
			this.destroy();
		},
		/**
		 * True if current 'mobile application' is welcome application
		 */
		isWelcomeApplication: function() {
			return this.uuid === "$welcomeApplication";
		},
		/**
		 * For page display
		 */
		getTitle: function() {
			return this.dao.getApplicationTitle();
		},
		/**
		 * Goto home page of current 'mobile application'
		 */
		gotoHome: function() {
			var self = this;
			setTimeout(function() {
				self.changePage(self.homePageId);
			});
		},
		/**
		 * Accept path like "array.gridMaxCols"
		 */
		$config: function(id) {
			return utils.getPropByPath(this._$config, id);
		},
		/**
		 * User, role, endpoint or language changed
		 * !! resolve/reject deferred is not null
		 * -> deferred used to catch error in transition phase - before page has been loaded
		 */
		notifContextChanged: function(deferred) {
			this.gotoWelcomeApplication(deferred);
		},

		notifModalOpen: function() {
			this._nbModals++;
			log && log("notifModalOpen nbModals=" + this._nbModals);
		},

		notifModalClose: function() {
			this._nbModals = Math.max(this._nbModals - 1, 0);
			log && log("notifModalClose nbModals=" + this._nbModals);
		},
		/**
		 * info - sizes of application and main page components header/footer/content - see siteLayout
		 * 		application.width	Application width
		 * 		application.weight	Application height
		 * 		content.width		Main page content width
		 * 		content.height		Main page content height
		 * 		...footer and header
		 * orientation	portrait/landscape
		 */
		notifMainLayoutChanged: function(info, orientation, deviceClass) {
			var self = this;
			//	self.orientation = orientation;
			// Container including header, content, footer
			// Set fixed with/height for application
			self.$$elmt.width(info.application.width);
			self.$$elmt.height(info.application.height);
			if (self.currentPage) {
				self.currentPage.onMainPageResize(info, orientation, deviceClass);
			}
		},
		/**
		 * Application can be scrolled (native scroll) in authoring mode
		 */
		getScrollOffset: function() {
			return {
				top: this.$$elmt.scrollTop(),
				left: this.$$elmt.scrollLeft()
			};
		},
		hasModalOpen: function() {
			log && log("_nbModals=" + this._nbModals);
			return this._nbModals > 0;
		},

		_actGotoWelcomeApplication: function() {
			this.gotoWelcomeApplication();
		},
		_actLogout: function(actionName) {
			this.logout();
		},
		/**
		 * Called by link with data-action = historyBack
		 */
		_actHistoryBack: function() {
			window.history.back();
		},
		// Switch role, endpoint, language
		_actSwitchContext: function() {
			var self = this;
			initContext.init(true, true).then(function(context) {}).fail(function(e) {
				modal.error("Switch context error", e);
			});
		},
		_actDevelopmentPage: function() {
			developmentPage.show();
		},
		_actSettings: function() {
			var self = this;
			return settings.getGlobalSettings()
				.then(function(set) {
					var modal = new modalSettings.Modal(set);
					return modal.show();
				})
				.then(function(result) {
					if (result) {
						return settings.setGlobalSettings(result);
					}
				});
		},
		_actDesignPage: function() {
			authoring.toggleDesignPage();
		},
		/**
		 * Open about page
		 */
		_actAbout: function() {
			var modal = new modalShowLegal.Modal();
			modal.show();
		},
		/**
		 * User has selected a new Syracuse mobile application
		 * appInfo json description of application
		 */
		notifSwitchApp: function(appName) {
			var self = this;
			globals.getMetaData().getApplication(appName).then(function(appDetails) {
				self._setCurrentApplication(appDetails);
			}).fail(function(e) {
				globals.getModal().error(null, e);
			});
		},

		/**
		 * Goto tablet applications home page  - Welcome dashboard
		 * deferred to resolve/reject in not null - used by asynchronous calls
		 * Ex: For login page we display the error in login page instead of modal
		 */
		gotoWelcomeApplication: function(deferred) {
			var self = this;
			if (globals.isLoggedIn()) {
				globals.getMetaData().getApplication("$welcomeApplication").then(function(appDetails) {
					self._setCurrentApplication(appDetails, {
						deferred: deferred
					});
				});
			} else {
				if (deferred) {
					deferred.resolve();
				}
				this.gotoLogin();
			}
		},
		/**
		 * Goto login page
		 */
		gotoLogin: function(reason) {
			var self = this;
			setTimeout(function() {
				self.changePage("login", {
					reason: reason || locale.text("login.authentication")
				});
			}, 0);
		},
		/**
		 * Set the current 'mobile application'
		 * Called after a switch context (application selection) or when tablet application is launched
		 * 'Welcome dashboard' page is a real application with only one dashboard
		 * options
		 * {
		 *    deferred: deferred to resolve/reject if not null - used by asynchronous calls to be notified
		 *    noPageChange: Don't change to application home dashboard
		 * }
		 *
		 */
		_setCurrentApplication: function(appInfo, options) {
			var self = this;

			options = options || {};
			var deferred = options.deferred;

			var _fail = function(msg, e) {
				self.waitWheelStop();
				if (deferred) {
					deferred.reject(e);
				} else {
					modal.error(msg, e, function() {
						if (self.currentPage) self.currentPage.activate();
					});
				}
			};
			var _success = function(appDetail) {
				try {
					self.waitWheelStop();
					if (!appDetail.$application.$uuid) throw new Error("No application $uuid - " + appDetail.applicationName);
					if (self.uuid !== appDetail.$application.$uuid) {
						// Application changed
						self.dao.setApplication(appDetail);
						self.homePageId = globals.getMetaData().getDashboardPageName(self.dao.getHomeDashboardName());
						self.uuid = appDetail.$application.$uuid;
					}
					if (options.noPageChange !== true) {
						self.gotoHome();
					}
					if (deferred) {
						deferred.resolve();
					}
				} catch (e) {
					_fail("Error loading new application", e);
				}
			};
			try {
				if (!appInfo) {
					throw new Error("Null appInfo");
				}
				log && log("Switch to Syracuse Mobile Application " + appInfo.applicationName);
				if (self.currentPage) {
					self.currentPage.deactivate();
				}
				self.waitWheelStart();
				_success(appInfo);
			} catch (e) {
				_fail("Error switching application", e);
			}
		},
		/**
		 * Open a page
		 * !! Do not call directly - Use changePage
		 * loadOptions
		 * 		dontDisplayLoadErr = true to not display a modal
		 */
		_gotoPage: function(state, back, loadOptions) {
			var self = this;
			if (!self._pageLoader) {
				self._pageLoader = self._createPageLoader();
			}
			/**
			 * Page loader shared with vignette
			 * Load a page
			 */
			if (state.isLogin === false && !globals.isLoggedIn()) {
				self.gotoLogin("Authentication is required");
				return $.smResolve();
			} else if (self._pageLoader.loading) {
				// Nothing if a page is currently loading
				// #5872 - We could load a login page two time that causes an error (called from http401Error and init login) 
				return $.smResolve();
			} else {
				return self._pageLoader.load(state, back, loadOptions)
					.then(function() {
						notifications.publish(["sm.history.push"], self.history);
					});
			}
		},

		_createPageLoader: function() {
			var self = this;
			var loader = new pageLoader.Klass({
				waitStop: function() {
					self.waitWheelStop();
				},
				getRootElmt: function() {
					return self.$$elmt;
				},
				waitStart: function() {
					self.waitWheelStart();
				},
				getCurrentPage: function() {
					return self.currentPage;
				},
				setCurrentPage: function(page) {
					self.currentPage = page;
					if (page.state.isLogin === true) {
						self.historyReset(page);
					} else if (page.state.name === self.homePageId) {
						// Destroy all cached pages except current home page
						log && log("Home page " + self.homePageId + " - Destroy all pages except current");
						self.removeAllChildPages(self.$$elmt, page);
					}
				},
				historyPush: function(state) {
					self.history.push(state);
					notifications.publish(["sm.history.push"], self.history);
					// Refresh browser history to keep only one page in history for tablet application
					if (self.pushState) {
						window.history.pushState({
							x: new Date()
						}, utils.UUID(), null);
					} else {
						window.history.replaceState({
							x: new Date()
						}, utils.UUID(), null);
					}
					// self.historyLog("historyPush");
				},
				succeeded: function(dstPage, pageToClose, parentNotifInfo, back, loadOptions) {
					log && log("succeeded" + " - win=" + window.history.length + " - app=" + self.history.length);
					// dstPage.isNew - > Page has been created -> trigger resize
					// back && !dstPage.isNew -> dstPage was stored in the cache - back from child page (pageToClose.isChild should be true)
					// -> We resize on only if size has changed - Otherwise we just show the page
					if (dstPage.isNew || (back && pageToClose && pageToClose.isChild && pageToClose.sizeModified)) {
						uiutils.triggerResizeInternal();
					}
					if (parentNotifInfo && parentNotifInfo.notifId) {
						/**
						 * If the child application wants to notify the parent it should return info for notification
						 * parentNotifInfo contain :
						 * 		notifId:  	with the notification id
						 * 		notifData: 	with data  needed for processing this event
						 * 		controlId: 	If action as been trigered by a control
						 * 		parentId: 	id of the controller to notify
						 */
						var controllerToNotify = globals.getController(parentNotifInfo.parentId);
						if (controllerToNotify) {
							notifications.notifyController(parentNotifInfo.notifId, controllerToNotify, parentNotifInfo.notifData, parentNotifInfo.controlId);
						} else {
							modal.error("Controller notification warning", "Controller[" + parentNotifInfo.parentId + "] not found");
						}
					}
				}
			});

			return loader;
		},

		historyReset: function(page) {
			// Destroy all cached pages except page parameter
			this.removeAllChildPages(this.$$elmt, page);
			this.history = [];
		},
		/**
		 * Call cb(state)
		 * Stop if cb returns true
		 */
		historyScan: function(cb) {
			for (var i = this.history.length - 1; i >= 0; i--) {
				if (cb(this.history[i]) === true) break;
			}
		},
		historyLog: function(title) {
			this.historyScan(function(state) {
				console.log("\t", state.name);
			});
		},
		/**
		 * Called by browser history.back
		 * !! never call this method directlty - Call window.back - except if we want to be notified with cb callback
		 * cb is a function if we want to be notified whe the page has been loaded
		 * 	- by example to display a message
		 * pageFilter callback to select the targetPage
		 * 		If pageFilter == null goto previous page
		 * 		pageFilter(pageState)
		 * 		returns true/false
		 * 		If true goto a selected page
		 * 		if false  back is canceled
		 *
		 */
		historyPop: function(event, cb, pageFilter) {
			try {
				var self = this;
				log && log("History pop before" + " - win=" + window.history.length + " - app=" + self.history.length);
				// No back if a modal is open
				if (self._nbModals > 0) {
					if (event) {
						event.preventDefault();
					}
					return;
				}
				if (self.uuid === "root" || self.history.length === 0) {
					// No application has been loaded - Goto previous browser history
					// ?? return without preventDefault doesn't continue back action on browser side
					// -> We repost a back
					window.history.back();
					return;
				}
				if (pageFilter && self.history.length > 0) {
					var selectedIdx = -1;
					for (var i = self.history.length - 1; i >= 0; i--) {
						if (pageFilter(self.history[i])) {
							selectedIdx = i;
							break;
						}
					}
					if (selectedIdx < 0) {
						if (event) {
							event.preventDefault();
						}
						return;
					}
					while (self.history.length > (selectedIdx + 2)) {
						var state = self.history.pop();
						var pageToRemove = $("#" + state.uuid).smPageController();
						if (pageToRemove) {
							pageToRemove.destroy();
						}
					}
				}
				// Remove current state
				var state = self.history.length > 0 ? self.history.pop() : null;
				if (state && (state.isWelcomePage || state.isLogin)) {
					// Homepage if login or welcome
					// ?? return without preventDefault doesn't continue back action on browser side
					// -> We repost a back

					// MW 2015-02-9 commented since it caused a double back action
					//window.history.back();
					return;
				} else {
					// Get previous state
					state = self.history.length > 0 ? self.history[self.history.length - 1] : null;
				}
				if (event) {
					event.preventDefault();
				}
				notifications.publish(["sm.history.pop"], self.history);
				// Force pushState on display page - Last state has been removed
				self.pushState = true;
				// self.historyLog("historyPop");
				// Open page
				if (state) {
					setTimeout(function() {
						var promise;
						if (state.isWelcomePage) {
							var deferred = $.Deferred();
							self.gotoWelcomeApplication(deferred);
							promise = deferred.promise();
						} else {
							promise = self._gotoPage(state, true);
						}
						if (cb) cb(promise);
					}, 0);
				}
			} catch (e) {
				modal.error("historyPop error", e, function() {
					if (cb) cb($.smReject(e));
				});
			}
		},
		/**
		 * Goto to previous page if any
		 * pageFilter == null	-> Goto to previous page
		 * pageFilter != null	-> Goto to selected page  - see historyPop
		 *
		 */
		goBack: function(pageFilter) {
			var deferred = $.Deferred();
			this.historyPop(null, function(promise) {
				if (promise) {
					promise.then(function(newPage) {
						deferred.resolve(newPage);
					}).fail(function(e) {
						deferred.reject(e);
					});
				} else {
					deferred.resolve();
				}
			}, pageFilter);
			return deferred.promise();
		},
		/** 
		 * pageName - name of the page
		 * pageOptions - Option override standard pageInfo and allows to store a context
		 * 		{
		 *   		applicationName: allows to switch application before changing page
		 * 		}
		 * changePageOpts - changePageOpts methods options
		 * 		callerhandlesErrors = true  - caller handle loading errors (message and redirection)
		 **/
		changePage: function(pageName, pageOptions, changePageOpts) {
			var self = this;
			changePageOpts = changePageOpts || {};
			var changeApp;
			if (pageOptions && pageOptions.applicationName) {
				var curApp = self.dao && self.dao.getApplicationName();
				if (curApp !== pageOptions.applicationName) {
					changeApp = $.Deferred();
					globals.getMetaData().getApplication(pageOptions.applicationName).then(function(appDetails) {
						self._setCurrentApplication(appDetails, {
							deferred: changeApp,
							noPageChange: true
						});
					});
				}
			}

			// If there is no application change going on, we just resolve to quickly change the page
			if (!changeApp) {
				changeApp = $.smResolve();
			}
			return changeApp
				.then(function() {
					var curPage;
					if (pageOptions && pageOptions.parentId && pageOptions.parentId.length > 0) {
						// Open a child page in fullpage mode
						curPage = globals.getController(pageOptions.parentId);
						if (!curPage) throw new Error("changePage - Can't find parent page - " + pageOptions.parentId);
					} else {
						curPage = self.currentPage;
					}
					return pageRegistry.getPageInfo(pageName, pageOptions, curPage);
				})
				.then(function(pageInfo) {
					return self._gotoPage(pageInfo, false, {
						dontDisplayLoadErr: changePageOpts.callerhandlesErrors
					});
				})
				.fail(function(e) {
					var next = e && e.$redirectPage || "welcomePage";
					if (next === "login") {
						self.gotoLogin(locale.text("login.timeout.message"));
					} else if (changePageOpts.callerhandlesErrors !== true) {
						// callerhandlesErrors = true means that it's the caller that will hanlde the redirection
						// 	On an error, we will go to the welcome page
						self.gotoWelcomeApplication();
					}
					return (e);
				});
		},

		logout: function() {
			var deferred = $.Deferred();
			var self = this;
			var _loggedOut = function() {
				log && log("User Logged out");
				globals.setUserCtx(null);
				deferred.resolve();
				self.gotoLogin(locale.text("logout.msg"));
			};
			self.waitWheelStart();
			auth.logout().then(function(ok, message) {
				self.waitWheelStop();
				if (ok) {
					_loggedOut();
				} else {
					modal.error(message, function() {
						_loggedOut();
					});
				}
			}).fail(function(e) {
				self.waitWheelStop();
				modal.error("Logout error", e, function() {
					_loggedOut();
				});
			});
			return deferred.promise();
		},

		/**
		 * Refresh current page - called from eventListener
		 */
		refreshPage: function(options) {
			var self = this;
			if (!self.currentPage) {
				throw new Error("No current page");
			}
			self.currentPage.refresh(options).then(function() {
				//	Eventually do something in vignette control	
			}).fail(function(e) {
				self.modalError(locale.text("err.load.main"), e);
			});
		},
		/**
		 * One waiting plugin per page
		 */
		waitWheelStart: function() {
			uiutils.waitWheelStart(this._wait);
		},
		waitWheelStop: function() {
			uiutils.waitWheelStop(this._wait);
		},
		/**
		 * Also exported in globals
		 */
		modalError: function(title, e, cb) {
			modal.error(title, e, cb);
		},
		getMessageSlot: function() {
			// tablet or smartphone
			if (!this._$$actMsgSlot) this._$$actMsgSlot = {};
			var deviceType = globals.getSiteLayout().getDeviceType();
			if (this._$$actMsgSlot[deviceType]) return this._$$actMsgSlot[deviceType];
			var $$slot = this._$$actMsgSlot[deviceType] = $("<div>").addClass("s-m-act-msg-slot").addClass(deviceType);
			(deviceType !== "tablet" && this.currentPage ? this.currentPage.$$contentElmt : this.$$elmt).prepend($$slot);
			return $$slot;
		},
		_actPinPage: function() {
			var self = this;
			var page = self.currentPage;
			var unpin = false;
			settings.isPinnedPage(page.getPinPageId())
				.then(function(isPinned) {
					var message;
					if (isPinned) {
						unpin = true;
						message = locale.text("pin.page.remove.confirm");
					} else {
						message = locale.text("pin.page.add.confirm");
					}
					return globals.getModal().simpleConfirmPromise({
						message: message
					});
				})
				.then(function(confirm) {
					if (confirm.action === "yes") {
						var pageData = page.getPinPageData(pageData); // allow to add information by subclasses
						if (unpin) {
							return settings.removePinnedPage(pageData.id)
								.then(function() {
									var notify = {
										severityClass: "success",
										title: "",
										body: locale.text("pin.page.remove.ok", [pageData.title]),
									};
									globals.getModal().notify(notify);
									notifications.publish("sm.page.pin.state.change", 1);
								});
						} else {
							// Save full context
							pageData.applicationName = self.dao.getApplicationName();
							pageData.endpoint = pageData.endpoint || globals.getEndpoint();
							if (pageData.dashboardName && pageData.applicationName === self.dao.getApplicationName() && pageData.dashboardName === self.dao.getHomeDashboardName()) {
								// We keep the application Icon if we pin the home dashboard
								pageData.icon = self.dao.getApplicationIcon();
							}
							return settings.addPinnedPage(pageData)
								.then(function() {
									var notify = {
										severityClass: "success",
										title: "",
										body: locale.text("pin.page.add.ok", [pageData.title]),
									};
									globals.getModal().notify(notify);
									notifications.publish("sm.page.pin.state.change", 2);
								});
						}
					}
				})
				.fail(function(e) {
					globals.getModal().error(e);
				});
		},

		removeAllChildPages: function($$elmt) {
			if (!$$elmt) return;
			if (!$$elmt.jquery) $$elmt = $($$elmt);
			var exclude = Array.prototype.slice.call(arguments, 1);
			$$elmt.children(".s-m-page").each(function(idx) {
				var page = $(this).smPageController();
				if (page && Array.prototype.indexOf.call(exclude, page) == -1) {
					page.destroy();
				}
			});
		},

		getHistory: function() {
			var self = this;
			return self.history;
		}
	});


exports.Application = _Application;
});

define('syracuse-tablet/html/js/helpers/controller',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/articleParser','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var _Klass = utils.defineClass(
	function(id, prototype, article, options) {
		this.options = options || {};
		this.id = id || utils.UUID();
		this.prototype = prototype;
		this.article = article;
		this.rootLayout = null;
		this.dao = null;
		this._evtListener = null;
		this.isVignette = false;
		this._controlsMap = {};
		this._layoutsMap = {};
		// read/edit/create - read by default
		this.$activity = "read";
		globals.addController(this);
		notifications.subscribe(this, ["sm.lookup.selection"], 1);
	}, null, {
		/**
		 * Used by page updateLayouts
		 */
		resetMaps: function() {
			this._controlsMap = {};
			this._layoutsMap = {};
		},
		destroy: function() {
			globals.removeController(this);
			this._controlsMap = null;
			this._layoutsMap = null;
			if (this.dao) {
				this.dao.destroy();
				this.dao = null;
			}
			if (this.rootLayout) {
				this.rootLayout.destroy();
				this.rootLayout = null;
			}
			if (this.prototype) {
				this.prototype.destroy();
				this.prototype = null;
			}
			this.removeEventListener();
			utils.unbindObj(this);
			this.article = null;
			this.prototype = null;
		},
		addControl: function(c) {
			if (!c) return;
			this._controlsMap[c.id] = c;
		},
		removeControl: function(c) {
			if (!c) return;
			delete this._controlsMap[c.id];
		},
		addLayout: function(c) {
			if (!c) return;
			this._layoutsMap[c.id] = c;
		},
		getControl: function(id) {
			return this._controlsMap && this._controlsMap[id];
		},
		getLayout: function(id) {
			return this._layoutsMap && this._layoutsMap[id];
		},
		getStructElmt: function(id) {
			return this.getControl(id) || this.getLayout(id);
		},
		/**
		 * scans _controlsMap and calls callBack
		 * -> callBack returns true to stop
		 * returns control that stopped the scan
		 */
		forEachControl: function(callBack) {
			if (!callBack) return;
			var c = null;
			for (var id in this._controlsMap) {
				if (callBack(id, this._controlsMap[id])) {
					c = this._controlsMap[id];
					break;
				}
			}
			return c;
		},
		getControlByBind: function($bind) {
			for (var p in this._controlsMap) {
				if (this._controlsMap[p].$bind === $bind) return this._controlsMap[p];
			}
			return null;
		},
		setDao: function(dao) {
			if (this.dao && this.dao.destroy) this.dao.destroy();
			this.dao = dao;
		},
		isEditMode: function() {
			return this.$activity === "edit" || this.$activity === "create";
		},
		setActivity: function(activity) {
			this.$activity = activity || "read";
		},
		buildControlsTree: function() {
			if (this.rootLayout) {
				this.rootLayout.destroy();
			}
			this.rootLayout = articleParser.article2Controls(this, this.article, this.prototype, {});
			return this.rootLayout;
		},
		render: function($$parent, buildOpts) {
			if (!this.rootLayout) return;
			this.rootLayout.buildHtml($$parent, this.dao, buildOpts);
			// USed to retrieve the controller on events
			this.rootLayout.$$elmt.attr("data-controller-id", this.id);
		},
		/**
		 * Refresh the page
		 */
		refresh: function(options, callBackInterface) {
			throw new Error("Not implemeneted");
		},
		/**
		 * Used by refresh method to update controls after having loaded new data
		 * ids == null means all controls
		 * Returns the list controls with an error
		 */
		refreshControls: function(ids, options) {
			var self = this;
			var errors = [];
			var _refresh = function(ctrl) {
				if (!ctrl) return;
				ctrl.refresh(self.dao, options);
				if (ctrl.hasError()) {
					errors.push(ctrl);
				}
			};
			if (ids && ids.length > 0) {
				ids.forEach(function(id) {
					_refresh(self._controlsMap[id]);
				});
			} else {
				Object.keys(self._controlsMap).forEach(function(key) {
					_refresh(self._controlsMap[key]);
				});
			}
			return errors;
		},
		/** Event sm.action.link
		 *  Notified when a action succeeded - sdata link - see action manager
		 *  success:	true/false
		 *  link:		Link info
		 *  result:		Json response
		 */
		notifActionLink: function(success, link, result, options) {
			throw new Error("not implemented");
		},
		/**
		 * When we select a value in a lookup
		 * 		rowData:	Selected row  - {data, proto} - data: selected JSON data - proto - prototype of row data
		 * 		controlId:	Id of control to refresh
		 */
		notifLookupSelection: function(rowData, controlId) {
			try {
				var ctrl = this.getControl(controlId);
				if (!ctrl) throw new Error("Control not found '" + controlId + "'");
				if (!ctrl.setLookupValue) throw new Error("Control must implement setLookupValue '" + controlId + "'");
				ctrl.setLookupValue(rowData);
			} catch (e) {
				globals.getModal().error("notifLookupSelection failed", e);
			}
		},
		/**
		 * Check controls data - Edit mode only
		 * Return true if ok
		 * Display fields errors if any
		 */
		checkControlsData: function() {
			if (!this.isEditMode()) return true;
			var self = this;
			var ok = true;
			var firstError, c;
			Object.keys(self._controlsMap).forEach(function(key) {
				c = self._controlsMap[key];
				if (c && c.checkData) {
					ok = ok && c.checkData();
					if (!ok && firstError == null) firstError = c;
				}
			});
			if (firstError) {
				firstError.setFocus();
			}
			return ok;
		},
		/**
		 * Show element in page - scroll if needed
		 * c is a JQuery elmt or an object with $$elmt property
		 */
		makeVisible: function(c) {
			// TODO - Implement a gestureManager in base controller to allow makeVisible
		},
		/**
		 * USED ONLY BY SIMPLE CONTROLLER FOR TESTS
		 */
		applyChange: function(newData) {
			if (!newData || !this.dao) return;
			this.dao.applyChange(newData);
			this.refreshControls(null, {
				refreshValue: true
			});
		},
		replaceData: function(newData) {
			if (!newData || !this.dao) return;
			this.dao.replaceData(newData);
			this.refreshControls(null, {
				refreshValue: true
			});
		},
		/**
		 * Allows child controllers to listen events
		 * controller event listener is called before coaling control listener
		 * Signature		mylistener(when, ctrl, $$target, event)
		 * 					when		"before" or "after"
		 * 									"before"	call before calling control event
		 * 										return false 	to continue
		 * 										return true 	to stop the process and not call control's listener
		 * 									"after" 	call after calling control event
		 * 					ctrl		control object
		 * 					$$target	target elmt
		 * 					event		event
		 * eventName		click, change, blur...
		 */
		addEventListener: function(eventName, method) {
			if (!method || typeof method !== "function") return;
			if (!this._evtListener) {
				this._evtListener = {};
			}
			this._evtListener[eventName] = jsutils.bindFn(method, this);
		},
		removeEventListener: function(eventName) {
			if (!this._evtListener) return;
			if (eventName) {
				this._evtListener[eventName] = null;
			} else {
				for (var p in this._evtListener) {
					this._evtListener = null;
				}
			}
		},
		getEventListener: function(eventName) {
			return this._evtListener ? this._evtListener[eventName] : null;
		}
	});


exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/pages/page',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/uiSettings','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/controller','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/controls/ctrlFactory','syracuse-tablet/html/js/helpers/hammerScroller','syracuse-tablet/html/js/application/settings','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/helpers/controller').Klass;;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("page");
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');
var HammerScroller = require('syracuse-tablet/html/js/helpers/hammerScroller').Klass;
var settings = require('syracuse-tablet/html/js/application/settings');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

/**
 * s-m-side-panel-dismiss: div that traps the events outside the panel when a panel if open
 */
var _templates = {
	fullpage: '\
		<section class="s-m-page s-m-full {{type}} {{subtype}}" id="{{pageid}}" {{#if parentId}}data-parent-id="{{parentId}}"{{/if}} class="ctrl-event-click" style=""> \
			<header></header> \
			<breadcrumbs></breadcrumbs> \
			<section class="s-m-main-content"></section> \
			<footer style="display:none"></footer> \
		</section> \
	',
	vignette: '<section class= "s-m-page s-m-nested {{type}} {{subtype}}" id="{{pageid}}"></section>',
	panels: '\
		<div class="s-m-side-panel-dismiss" data-action="toggleSidePanel" data-params="close,all"></div> \
		<aside class="s-m-panel s-m-left"></aside> \
		<aside class="s-m-panel s-m-right"></aside>'
};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx || {});
};
/*********** PANELS MANAGER ***********
 * !! Created/Destroyed only on main page (not on vignettes)
 * page		Main/Current page
 *************************************/
var PanelManager = function(page) {
	this.page = page;
	if (!page.isVignette) {
		// init $$elmts for panels
		page.$$elmt.append($(_getHtml("panels")));
		page.$$dismissPanel = page.$$elmt.children(".s-m-side-panel-dismiss");
	}
	this.destroy = function() {
		this.page = null;
	};
	/**
	 * Panels are attached to the main page
	 */
	this.mainPage = function() {
		return this.page.isVignette ? globals.getCurrentPage() : this.page;
	};
	/**
	 * Adds a panel to left or right sections - sidePanel class
	 * 		If not exists create it
	 * where	"left" or "right"
	 * panel	panel object
	 */
	this.panelAttach = function(where, panel, action) {
		var controller = this.mainPage();
		if (!controller.$$dismissPanel || !panel || (where != "right" && where != "left")) return;
		var currentPanel = controller._pageControls.get(where);
		if (currentPanel && currentPanel != panel) {
			this._panelDetach(where);
		}
		if (!panel.isAttached(where)) {
			var $$parent = controller.$$elmt.children("aside.s-m-panel.s-m-" + where);
			if ($$parent.length != 1) return;
			// Add the control to the list
			controller.addControl(panel);
			controller._pageControls.add(where, panel).attach($$parent, where);
		}
		return this.panelToggle(where, panel, action);
	};
	/**
	 * Toggle panel
	 */
	this.panelToggle = function(where, panel, action) {
		var controller = this.mainPage();
		if (!panel) panel = controller._pageControls.get(where);
		if (!panel || !panel.$$elmt) return null;
		// close -> Force hide - resize -> stay visible - toggle -> toggle
		panel.$$elmt.toggle(action === "close" ? false : undefined);
		var visible = panel.$$elmt.is(':visible') === true;
		var newWidth = visible ? panel.$$elmt.width() : 0;
		if (panel.closeBox != true) {
			controller.$$dismissPanel[visible ? "addClass" : "removeClass"](where);
			controller.$$dismissPanel.css(where, newWidth);
		}
		if (panel.overlap != true) {
			var self = this;
			var shiftElmts = [controller.$$contentElmt];
			["header", "footer", "breadcrumbs"].forEach(function(id) {
				var c = controller._pageControls.get(id);
				if (c) {
					shiftElmts.push(c.$$elmt.parent());
				}
			});
			shiftElmts.forEach(function($$elmt) {
				$$elmt.css("left", (visible ? (where === "right" ? -1 : 1) * newWidth : 0) + "px");
			});
		}
		panel.notifyToggled(where, action, visible);
		return panel;
	};
	/**
	 * Removes the panel but not destroy it
	 * where	"left" or "right"
	 */
	this._panelDetach = function(where) {
		var controller = this.mainPage();
		if (!controller.$$dismissPanel) return;
		var p = controller._pageControls.remove(where);
		if (!p) return;
		this.panelToggle(where, p, "close");
		controller.removeControl(p);
		return p.detach();
	};
	/**
	 * Returns a panel - Just to have ctrlFactory declared here
	 * id	globals.PANELACTIONSREGULAR, globals.PANELUSERSMARTPHONE, globals.PANELFILTERSORT
	 */
	this.panelCreate = function(panelId, options) {
		// controller of the control is the current page because we could need to access to this page from the panel (Ex for a panel attached to a vignette)
		return ctrlFactory.createPanel(this.page, panelId, options);
	};
	this.panelResize = function(context) {
		var controller = this.mainPage();
		["right", "left"].forEach(function(w) {
			var p = controller._pageControls.get(w);
			if (p && p.onResize) p.onResize(context);
		});
	};
};
/*********** PAGE CONTROLS MANAGER ***********
 * Page controls are not attached to rootLayout
 * header/footer
 ************************************************/
var PageControls = function(page) {
	this.page = page;
	this.map = {};
	this.statics = {};
	this.add = function(id, ctrl) {
		if (this.map[id]) {
			alert("Control " + id + " already exists");
		}
		this.map[id] = ctrl;
		if (id === "header" || id === "footer" || id === "breadcrumbs") {
			this.statics[id] = ctrl;
		}
		return ctrl;
	};
	this.get = function(id) {
		return this.map[id];
	};
	this.remove = function(id) {
		var ctrl = this.map[id];
		this.map[id] = undefined;
		this.statics[id] = undefined;
		return ctrl;
	};
	this.destroy = function() {
		this.page = null;
		if (!this.map) return;
		for (var id in this.map) {
			this.map[id] && this.map[id].destroy();
		}
		this.map = null;
		this.statics = null;
	};
	/**
	 * Only on static controls header/footer
	 */
	this.buildHtml = function(dao, buildOptions) {
		for (var id in this.statics) {
			this.statics[id].buildHtml(this.page.$$elmt.children(id), dao, buildOptions);
		}
	};
	this.afterRender = function(buildOpts) {
		for (var id in this.statics) {
			if (this.statics[id].afterRender) this.statics[id].afterRender(buildOpts);
		}
	};
	/**
	 * All controls header/footer/leftPanel/rightPanel
	 */
	this.forAllCtrls = function(cb) {
		for (var id in this.map) {
			cb(id, this.map[id]);
		}
	};
	this.addToControlMap = function() {
		for (var id in this.map) {
			this.page.addControl(this.map[id]);
		}
	};
	this.closeSidePanel = function() {
		// TODO
	};
};
/****************** PAGE CLASS *********************
 * Base class for all pages
 *  $$parent: Parent element
 * 	state: Page information - JSON structure stored in history
 *  prototype: Prototype object (class prototype)
 *  article: JSON article
 *  !! Temporarily prototype and article can be null for html pages
 ***************************************************/
var _defOpts = {
	header: true,
	footer: true,
	breadcrumbs: false
};
var _Page = utils.defineClass(
	function Page($$parent, state, prototype, article, options) {
		Base.call(this, state.uuid, prototype, article, $.extend({}, _defOpts, options));
		this._pageControls = null;
		this._panelsManager = null;
		this._$$parent = $$parent;
		this.state = state;
		this.state.options = state.options || {};
		this.ctrlAfterRenderCalls = [];
		this.ctrlSaveCtxCalls = [];
		this.isVignette = state.options.vignette === true;
		this.isChild = state.options.parentId != null;
		if (this.isChild) {
			// Children pages are cached - no destry if we open a child page from this page
			this.state.cached = true;
		}
		this._initRootElmt($$parent);
		// true if page is created - set by page loader when page is activated
		this.isNew = false;
		// Last selected row - Used to save/restore context of last selected row
		this.lastSelectedRow = null;
		notifications.subscribe(this, ["sm.select.row", "sm.updt.card.article", "sm.page.updt.scroll"], 1);
	}, Base, {
		resetMaps: function() {
			Base.prototype.resetMaps.call(this);
			// Contains controls that need to be called after Render - outside pageControls
			this.ctrlAfterRenderCalls = [];
			// Contains controls that have a context to save in order to retrieve it when page will be load (eg: back navigation)
			this.ctrlSaveCtxCalls = [];
		},
		/**
		 * Create and return root DOM element of every page
		 * 		DOM element is hidden and contains only the structure
		 * 		Page object is stored in DOM element under data("smcontroller")
		 */
		_initRootElmt: function($$parent) {
			var self = this;
			var type = self.state.type;
			var root, ctx = {
					pageid: self.id,
					type: type, // regular/html/dashboard
					subtype: self.state.subtype, // regular - > facet - dashboard -> std/welcome/home - html -> login/about...
					parentId: self.getParentId()
				};
			if (self.isVignette) {
				// only content in a vignette
				self.$$contentElmt = self.$$elmt = $(_getHtml("vignette", ctx));
			} else {
				self.$$elmt = $(_getHtml("fullpage", ctx));
				self.$$contentElmt = self.$$elmt.children("section.s-m-main-content");
				self.$$breadcrumbsElmt = self.$$elmt.children("breadcrumbs");
				// Page controls only for main page
				self._pageControls = new PageControls(self);
				if (self.options.header === true) {
					// It's better to fix the top before mainResize even if it can change
					// When we restore context (scroll...) on back we need that because restore context is done before mainREsize
					self.$$contentElmt.css({
						top: uiSettings.getProp("header.height")
					});
				}
			}
			// Panel manager should be attached to the main page - For vignettes we should take toe one of the main page
			//  -> Temporarlilly we create a Panel manager for vignettes because main page (globals.currentPage) is not available when we create the controls of the vignette
			//  -> Ex when we create an array sortFilter panel in a vignette
			//  -> TODO - Review the loading process of vignettes to pass the main page (pageToOpen) as a parameter or option 
			//  -> After that we will be able to set self._panelsManager = mainPage._panelsManager for vignettes
			self._panelsManager = new PanelManager(self);
			if (self.scrollAllowed()) {
				// Scroll in page is allowed for $details and $edit
				// For dashboard this is the layout which scrolls (not the page)
				// For query this si the array  which scrolls (not the page)
				// Only if scroll allowed - Ex: In wignette with charts we musn't have the scroll wrapper becaus eit breaks size calculation 
				self.$$scrollWrapper = $('<div class="s-m-scroll-wrapper"/>').appendTo(self.$$contentElmt);
				self.$$scrollWrapper.css({
					height: "auto"
				});
				self.$$ctrlsRootElmt = self.$$scrollWrapper;
				// Create scroll manager here because it must be created when we restore the context on back
				self._gestureMgr = new HammerScroller(self.$$scrollWrapper, {
					// isPageScroller: true for full page
					// isPageScroller: false for vignette - The view rectangle scolls with the content of the page
					isPageScroller: !self.isVignette
				});
			} else {
				self.$$ctrlsRootElmt = self.$$contentElmt;
			}
			self.$$elmt.hide();
			self.$$elmt.appendTo($$parent);
			// attaches page object to DOM element
			self.$$elmt.smPageController(self);
		},
		isDashboard: function() {
			return this.getType() === "dashboard";
		},
		destroy: function() {
			Base.prototype.destroy.call(this);
			this._$$parent = null;
			if (this.$$elmt) {
				utils.unbindObj(this.$$elmt);
				this.$$elmt = null;
			}
			if (this._pageControls) {
				this._pageControls.destroy();
				this._pageControls = null;
			}
			if (this._panelsManager) {
				this._panelsManager.destroy();
				this._panelsManager = null;
			}
			if (this._waiting) {
				uiutils.waitWheelDestroy(this._waiting);
				this._waiting = null;
			}
			this.ctrlAfterRenderCalls = null;
			this.ctrlSaveCtxCalls = null;
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},
		/**
		 * Called be pageLoader - TODO TEST
		 */
		destroySiblings: function() {
			if (this.$$elmt) {
				log && log("Page destroySiblings", "destroySiblings");
				var next = this.$$elmt.siblings(function(idx) {
					var ctrl = $(this).smPageController();
					if (ctrl) ctrl.destroy();
				});
			}
		},
		/**
		 * dashboard/regular/html
		 */
		getType: function() {
			return this.state.type;
		},
		/**
		 * Allows prop = "options.parentId"
		 */
		getProp: function(prop) {
			return utils.getPropByPath(this.state, prop);
		},
		/**
		 * Set by vignette at page loading
		 */
		openLinkInVignette: function() {
			return this.state.options.openLinkInVignette === true;
		},
		/**
		 * Load the page
		 * 		The result is that the page is created and attached to DOM document and hidden
		 * 		the contoller of the page (applictaion/vignette) has to call activate method to display the page (see pageLoader module)
		 * loadOptions:
		 * 		updateLayout -> true to not load the data and update only main layout
		 */
		load: function(loadOptions) {
			var self = this;
			loadOptions = loadOptions || {};
			var timeLine = utils.getTimeLine("page", self.state.name);
			timeLine && timeLine.start();
			return $.smResolve()
				.then(function() {
					return self.initOnLoad();
				})
				.then(function() {
					return self.buildHtmlOption(loadOptions);
				})
				.then(function(opts) {
					self.buildOpts = opts;
					return self.loadStructure(loadOptions);
				})
				.then(function() {
					timeLine && timeLine.step("loadStructure");
					return self.loadData(loadOptions);
				})
				.then(function() {
					timeLine && timeLine.step("loadData");
					return self.render(loadOptions, self.buildOpts);
				})
				.then(function() {
					timeLine && timeLine.step("render");
					return self.afterRender(loadOptions, self.buildOpts);
				})
				.then(function() {
					timeLine && timeLine.stop();
				});
		},
		/**
		 * Create layout/control tree structure according to article
		 */
		loadStructure: function(loadOptions) {
			var self = this;
			return $.smResolve().then(function() {
				if (!self.article || !self.prototype) throw new Error("loadStructure - NULL article or prototype");
				if (self._pageControls && loadOptions.skipPageControls !== true) {
					if (self.options.breadcrumbs === true) {
						self._pageControls.add("breadcrumbs", ctrlFactory.createPageControl("breadcrumbs", self));
					};
					if (self.options.header === true) {
						// Save orginal header beacuse we can change it
						this._pageHeader = self._pageControls.add("header", ctrlFactory.createPageControl("header", self));
					};
					if (self.options.footer === true) {
						// Save orginal footer beacuse we can change it
						this._pageFooter = self._pageControls.add("footer", ctrlFactory.createPageControl("footer", self));
					}
				}
				// Creates control / fields tree(from article)
				self.buildControlsTree();
			});
		},
		/**
		 * Load page data
		 */
		loadData: function(loadOptions) {
			var self = this;
			return $.smResolve().then(function() {
				self.setDao(null);
			});
		},
		/**
		 * Rendering - Build html and attachs dom elements to document
		 */
		render: function(loadOptions, buildOpts) {
			var self = this;
			return $.smResolve().then(function() {
				if (!self.rootLayout) {
					throw new Error("buildHtml - NULL rootLayout");
				}
				// Renders header/footer
				if (self._pageControls && loadOptions.skipPageControls !== true) {
					self._pageControls.buildHtml(self.dao, buildOpts);
				}
				if (self.$$ctrlsRootElmt) {
					self.beforeAddContent();
					// Renders tree controls (article)
					Base.prototype.render.call(self, self.$$ctrlsRootElmt, buildOpts);
				}
			});
		},

		/*
		 * First action (deferred) called on page loading
		 * Can be used to cache data from async operations that are needed later in
		 * page loading in sync processes
		 */
		initOnLoad: function() {
			return $.smResolve();
		},

		/**
		 * return build options for controls
		 * Set options for all controls
		 * Header -> options for header control
		 * Can be overridden
		 */
		buildHtmlOption: function(loadOptions) {
			var self = this;
			return settings.isPinnedPage(self.getPinPageId())
				.then(function(isPinned) {
					return {
						updateLayout: loadOptions.updateLayout === true,
						makeFullHeight: self.isVignette,
						toolBars: {
							showAuthoring: !self.isChild && self.state.disableAuthoring !== true,
							showLinks: !self.isChild,
							showHome: !self.isChild && !this.state.isWelcomePage,
							statusPinPage: !self.isChild ? (isPinned ? 2 : 1) : 0
						}
					};
				});
		},
		/**
		 * Called from authoring to update the page's article
		 */
		authUpdateLayout: function(article) {
			var self = this;
			self.waitWheelStart();
			// Set new article which comes from authoring panel
			self.article = article;
			// Init controsl maps
			self.resetMaps();
			// destroy all controls and layouts
			self.rootLayout.destroy();
			// Clear dom
			self.$$ctrlsRootElmt.empty();
			// Reload with updateLayout and skipPageControls option
			// 	-> don't load data
			//	-> don't create page controls
			var options = {
				updateLayout: true,
				skipPageControls: true
			};
			return self.load(options).then(function() {
				// Add page controls to maps
				self._pageControls.addToControlMap();
				// Recalculate layouts
				uiutils.triggerResizeInternal(options);
			}).then(function() {
				self.waitWheelStop();
			}).fail(function(e) {
				self.waitWheelStop();
				globals.getModal().error("Error", e);
			});
		},
		/**
		 * Resize of application main page
		 * info give the size in pixels of mainContent/header/footer - see siteLayout
		 * We need it to pass to rootLayout without having to set the size od $$contentElmt
		 * $$contentElmt must have css.height set to auto for scrolling
		 * info.updateLayout = true if page updated by authoring
		 */
		onMainPageResize: function(info, orientation, deviceClass) {
			var self = this;
			if (!this.isVignette) {
				// Set device type for css
				if (this._deviceType) this.$$elmt.removeClass(this._deviceType);
				this._deviceType = globals.getSiteLayout().getDeviceType();
				this.$$elmt.addClass(this._deviceType);
				/**
				 * or main page we calculate the H/W in pixels - BAs of calculation comes from application/SiteLayout
				 */
				var top = 0,
					left = 0,
					topBreadCrumbs = 0;
				var contentHeight = info.application.height;
				var contentWidth = info.application.width;
				if (self._pageControls) {
					info.contentWidth = contentWidth;
					info.contentHeight = contentHeight;
					self._pageControls.forAllCtrls(function(id, ctrl) {
						if (ctrl.onMainPageResize) {
							ctrl.onMainPageResize(info, orientation, deviceClass);
							if (ctrl.isVisible() && (id === "header" || id === "footer" || id === "breadcrumbs")) {
								var ch = ctrl.getHeight();
								contentHeight -= ch;
								if (id === "header") {
									top += ch;
									topBreadCrumbs += ch;
								} else if (id === "breadcrumbs") {
									top += ch;
								}
							}
						}
					});
				}
				self.$$breadcrumbsElmt.css({
					top: topBreadCrumbs
				});
				self.$$contentElmt.css({
					top: top + "px",
					left: left + "px",
					width: contentWidth + "px",
					height: contentHeight + "px"
				});
			} else {
				/**
				 * For vignette we don't calculate the H/W in pixels.
				 * To do the calculatation we need to propagate the calculation from dashboard tile -> Control (not done and needed)
				 * H/W calculation is based on css style height auto for the wrapper et 100% for $$contentElmt
				 */
			}
			/**
			 * We need to create the scroller for main page and page embeded in vignette
			 */
			// Save content rectangle for scrolling and hub layout - "computed" to ignore padding
			self._mainContentRect = uiRect.elmtRect(self.$$contentElmt, "computed");
			// We need to set the right coordinates for intersectRect with scroller
			self._mainContentRect.moveLeft(parseInt(self.$$contentElmt.css("padding-left"), 10));
			self._initScroll(info && info.preserveScroll);
			// info is the context of resize - info.u^dateLayout = true if page updated by authoring
			self.onResize(info);
		},
		/**
		 * returns main content rect for hub layout
		 */
		getMainContentRect: function() {
			return this._mainContentRect;
		},
		/**
		 * Resize handler called by window.resize
		 */
		onResize: function(context) {
			if (this._resizeContext && context) {
				// Optimization for triggerResize on back - We need to know if sized changed (orientation/device type...)
				this.sizeModified = this._resizeContext.contentHeight != context.contentHeight || this._resizeContext.contentWidth != context.contentWidth;
			} else {
				this.sizeModified = false;
			}
			this._resizeContext = $.extend({}, context);
			// Call resize handler in tree hierachy
			if (this.rootLayout && this.rootLayout.onResize) {
				this.rootLayout.onResize(context);
			}
			if (this._panelsManager) {
				this._panelsManager.panelResize(context);
			}
		},
		/**
		 * Specific procces after rendering
		 */
		afterRender: function(loadOptions, buildOpts) {
			// afterRender for controls - outside pageControls
			this.ctrlAfterRenderCalls.forEach(function(c) {
				c.afterRender(buildOpts);
			});
			if (this._pageControls && loadOptions.skipPageControls !== true) {
				// for _pageControls afterRender is called only at the creation of the page
				this._pageControls.afterRender(buildOpts);
			}
		},
		beforeAddContent: function() {},
		addTitle: function(title, description) {
			var html = "";
			if (title) html = '<header class="s-m-page-title">' + title + '</header>';
			if (description) html += '<p>' + description + '<p>';
			if (html.length > 0) $(html).prependTo(this.$$ctrlsRootElmt);
		},
		/**
		 *  called each tile a control/layout is created
		 **/
		addControl: function(c) {
			Base.prototype.addControl.call(this, c);
			// For controls others that page Controls
			if (!c.isPageControl()) {
				// stores controls that need specific processes
				// !!! It's the simplest way to identify controls by testing the presence of the method when we add them
				// Another way woud be that it's the control that asks the page to be notified
				// After render
				if (c.afterRender) this.ctrlAfterRenderCalls.push(c);
				// Save context
				if (c.savedCtxCreate && c.savedCtxRestore) this.ctrlSaveCtxCalls.push(c);
			} // PageControls are managed separately because of updateMayout 
		},
		/**
		 * Display the page and hides currentPage
		 * 		Manage transitions (effect) according  to self.getProp("transition")
		 *		Do not call show directly
		 * 		cb is called after oage hs been displayed (we don't use deferred)
		 * pageToClose is the page ths will be replaced by this
		 * 		For a child page currentPage is the parent page
		 *			Used by rowdetail page to read the DAO
		 * savedContext
		 * 		Context is propvided by pageToClose (or dashboard for vignettes)
		 * 		It contains a status to restore after it has been displayed (scroll...)
		 */
		activate: function(pageToClose, savedContext, cb) {
			var self = this;
			self._show(pageToClose, function() {
				if (savedContext) {
					// Set saved context use for back to 'parent' page
					self.savedContext = savedContext.parent;
					// We restore the current contex (ex scroll)
					self.savedCtxRestore(savedContext.current);
				} else if (self.lastSelectedRow) {
					// We allways restore last selected row because it is stored in page when we clik the link that opens the 'child' page
					self._hilightLastSelectedRow(self.lastSelectedRow);
				}
				if (cb) cb();
			});

		},
		/**
		 * Hide the page
		 * 	Do not call hide or show directly
		 * A "cached" page is deactivated instead of being destroyed on navigation event
		 */
		deactivate: function(cb) {
			this._hide(cb);
		},
		/**
		 * Save previous page context - Called by page loader before deactivating the page
		 * We propagate the context of previous pages into the page to be able to retrieve it on back navigation
		 */
		contextSave: function(pageToClose) {
			var self = this;
			if (!pageToClose) return;
			self.savedContext = {
				// Parent context is saved
				parent: pageToClose.savedContext,
				// Context to restore when this pageToClose will be reopen on back navigation
				current: pageToClose.savedCtxCreate()
			};
		},
		/**
		 * returns the context to save
		 * 		default:	page scroll coordinates
		 * Can be overridden (ex dashboard to manage contexts of vignettes)
		 */
		savedCtxCreate: function() {
			var self = this;
			var ctx = {
				//forceLinkArticle - article given by a link - ONLY FOR TEST ENTITIES - see getLinkedPageArticle
				forceLinkArticle: this.state.forceLinkArticle,
				pageName: this.state.name,
				lastSelectedRow: self.lastSelectedRow
			};
			if (self._gestureMgr) {
				// Save page scrolling
				ctx.scroll = self._gestureMgr.savedCtxCreate();
			}
			if (self.ctrlSaveCtxCalls && self.ctrlSaveCtxCalls.length > 0) {
				ctx.ctxCtrls = {};
				// Save controls contexts - All controls who implement savedCtxCreate are added to ctrlSaveCtxMap
				// We take $bind as control ID because id is changed each time we create a control
				self.ctrlSaveCtxCalls.forEach(function(c) {
					var ctrlCtx = c.savedCtxCreate();
					if (ctrlCtx) ctx.ctxCtrls[c.$bind] = ctrlCtx;
				});
			}
			return ctx;
		},
		/**
		 * Restore page context - Called after activation (show)
		 * 		default:	page scroll coordinates
		 */
		savedCtxRestore: function(ctx) {
			var self = this;
			if (!ctx) return;
			if (ctx.pageName != this.state.name) {
				// The page is not able to restore child pages inside a vignette - TODO if needed
				// If we go to detail page in ful page from a dashboard and go back a vignette that contains a detail page will not restore the context if current page was a child page
				// -> Only main parent page is restored
				return;
			}
			if (self._gestureMgr && ctx.scroll) {
				// Restore page scrolling
				self._gestureMgr.savedCtxRestore(ctx.scroll, true);
			}
			if (ctx.ctxCtrls) {
				// Restore controls context
				// We take $bind as control ID because id is changed each time we create a control
				for (var bind in ctx.ctxCtrls) {
					var c = self.getControlByBind(bind);
					var ctrlCtx = ctx.ctxCtrls[bind];
					if (c && c.savedCtxRestore && ctrlCtx) {
						if (ctx.lastSelectedRow && ctx.lastSelectedRow.array$Bind === bind) {
							// We pass the id to the right arrays - Row selection will be done later after the display of th array
							ctrlCtx.selectedRowId = ctx.lastSelectedRow.rowId;
						}
						c.savedCtxRestore(ctrlCtx);
					}
				}
			}
		},
		_hilightLastSelectedRow: function(lastSelectedRow, old) {
			var self = this;
			var toggle = function(rowInfo, show) {
				// We take array$Bind as control ID because id is changed each time we create a control
				var c = self.getControlByBind(rowInfo.array$Bind);
				if (c && c.selectLastSelectedRow) {
					c.selectLastSelectedRow(rowInfo.rowId, show);
				}
			};
			if (old) toggle(old, false);
			if (lastSelectedRow) {
				toggle(lastSelectedRow, true);
				return true;
			}
			return false;
		},
		_show: function(currentPage, cb) {
			var self = this;
			var transition = self.getProp("transition");
			if (currentPage) {
				currentPage._hide(function() {
					self.$$elmt.show(transition || 0, function() {
						if (cb) cb();
					});
				});
				return;
			}
			self.$$elmt.show(transition == null ? 0 : transition, cb);
		},
		_hide: function(cb) {
			if (!this.$$elmt) {
				if (cb) cb();
				// page has been destroyed
				return;
			}
			// Close panels
			if (this._pageControls) {
				this._pageControls.closeSidePanel("all");
			}
			var transition = this.getProp("transition");
			this.$$elmt.hide(transition == null ? 0 : transition, cb);
		},
		isActive: function() {
			return this.$$elmt && this.$$elmt.is(":visible");
		},
		/**
		 * True is page is a lookup
		 */
		isLookup: function() {
			return this.prototype && this.prototype.isLookup();
		},
		/**
		 * Return the info to notify parent when the child page is closed
		 * It depends on the kind of page
		 * Ex: lookup notifies parent control with selected value
		 */
		getParentNotif: function() {
			throw new Error("not implemented");
		},
		/**
		 * Return the id of parent page if any
		 */
		getParentId: function() {
			return this.isChild ? this.state.options.parentId : null;
		},

		/**
		 * Returns attribute for the link that opens this page (used to open this page from a vignette to full page)
		 * Overriden by regular page to put s-data-url
		 */
		getOpenLinkAttrs: function() {
			return {
				"data-nav": this.state.name
			};
		},

		/***
		 * Test action
		 */
		_actTest: function(params) {
			var e = $('<h5 style="color:red">Action test succeeded</h5>').prependTo(this.$$elmt);
			window.setTimeout(function() {
				e.remove();
			}, 2000);
		},
		/**
		 * Click on home in footer/header
		 * Can be overrridden - rowDetail
		 */
		_actHome: function() {
			globals.getApplication().gotoWelcomeApplication();
		},
		/**
		 * Wait wheel management
		 * We need one plugin per page
		 */
		waitWheelStart: function(controlId) {
			var self = this;
			if (controlId) {
				var c = self.getControl(controlId);
				if (c && c.waitStart) c.waitStart();
				return;
			}
			if (!self._waiting) {
				self._waiting = uiutils.waitWheelCreate(self.$$elmt);
			}
			uiutils.waitWheelStart(self._waiting);
		},
		waitWheelStop: function(controlId) {
			var self = this;
			if (controlId) {
				var c = self.getControl(controlId);
				if (c && c.waitStop) c.waitStop();
				return;
			}
			if (self._waiting) {
				uiutils.waitWheelStop(self._waiting);
			}
		},
		/**
		 * Called synchronously by an array when a row has been selected
		 * 	arrayId		Id of array
		 * 	rowId		Id of row
		 * 	rowdata		data of the row used by loojup page
		 * 	updateUI	True to update UI
		 * 				When the page is not destroyed by the link we clicked we have to remove old selection
		 * 				Otherwise the selction the line will be hightlighted after creation of the page
		 */
		notifSelectRow: function(arrayId, rowId, rowdata, updateUI) {
			var c = this.getControl(arrayId);
			if (!c) return;
			// !! selections works with $uuid - it doesn't work if no $uuid or same $uuid whihc occurs sometime in X3 dvlp folders 
			var old = this.lastSelectedRow;
			this.lastSelectedRow = {
				array$Bind: c.$bind,
				rowId: rowId
			};
			if (updateUI) {
				this._hilightLastSelectedRow(this.lastSelectedRow, old);
			}
		},
		/**
		 * USed by child pages
		 * TODO - Improve by using orr own history stack to avoid forward
		 */
		goBack: function() {
			window.history.back();
		},
		/**
		 * Update the scroll for a vignette
		 *
		 */
		initVignetteScroll: function(back) {
			if (!this._gestureMgr) return;
			var viewRect = this.getParentVignette().getScrollViewRect();
			//if (back === true || (viewRect.height < this.$$scrollWrapper.height())) {
			// If back into a vignette we keep old scrolling - To improve 
			var keepOldScrolling = back === true;
			this._gestureMgr.init(viewRect, "v", 0, keepOldScrolling);
			//}
		},
		/**
		 * Enable/Disable scrolling
		 */
		_initScroll: function(preserveScroll) {
			if (!this._gestureMgr) return;
			if (this.scrollAllowed()) {
				var viewRect = this.isVignette ? this.getParentVignette().getScrollViewRect() : this._mainContentRect;
				// Force $$scrollWrapper to full heigth of childrens
				// We scroll if childen height is greater than childrenRect height
				if (viewRect && viewRect.height < this.$$scrollWrapper.height()) {
					var valMax = 0;
					// If not new -> back on a cahced page - We keep scrolling
					preserveScroll = preserveScroll === true || this.isNew !== true;
					//viewRect has fixed coordinate to check if the 'finger' is inside on mousemouve event
					// A page always scolls verticaly - In dashboard this is the layout that scrolls horizontally
					this._gestureMgr.init(viewRect, "v", valMax, preserveScroll);
					var autoScroll = this.state.options["auto-scroll"];
					if (autoScroll != null) {
						// When we go to $edit form $details we keep the scrolling in order to stay at the same location (see actionManager)
						this.autoScroll(autoScroll);
						// Only when we loadd the page
						this.state.options["auto-scroll"] = undefined;
					}
				} else {
					this._gestureMgr.reset();
				}
			} else {
				// Disable _gestureMgr if any
				this._gestureMgr.reset();
			}
		},
		/**
		 * Scroll the page
		 */
		autoScroll: function(value) {
			// TODO - scroll the rootLayout for the dashboard
			if (this._gestureMgr) this._gestureMgr.autoScroll(value);
		},
		/**
		 * True if scroll enabled in page
		 * By default we can scroll a page in full display
		 * In vignettes only details/edit facet are allowed to scroll - See regular page
		 * In Dashboard hub this is the layout that scrolls - Page doesn't scroll
		 */
		scrollAllowed: function() {
			if (this.isVignette) return false;
			if (this.isDashboard()) return this.article && this.article.$layoutType !== "hub";
			return true;
		},
		/**
		 * Returns the offset of the scrollRect top/left in fixed position (document)
		 * Overridden by dashboard
		 */
		getScrollOffset: function() {
			// Application content can be scrcolled (native in authoring)
			return globals.getApplication().getScrollOffset();
		},
		/**
		 * returns the value of the page's scroller
		 * 0 by default even if no scroller		 *
		 */
		getScrollValue: function() {
			return this._gestureMgr ? this._gestureMgr.getScrollValue() : 0;
		},
		setParentVignette: function(v) {
			this._parentVignette = v;
		},
		getParentVignette: function() {
			return this._parentVignette;
		},
		getGestureMgr: function() {
			return this._gestureMgr;
		},
		/**
		 * Show element in page - scroll if needed
		 * c is a JQuery elmt or an object with $$elmt property
		 */
		makeVisible: function(c) {
			if (!c || !this.getGestureMgr() || !c.$$elmt) return;
			this.getGestureMgr().makeVisible(c.$$elmt);
		},
		/**
		 * Adds a panel to left or right sections - sidePanel class
		 */
		panelAttach: function(where, panel, action) {
			return this._panelsManager ? this._panelsManager.panelAttach(where, panel, action) : null;
		},
		/**
		 * Returns a panel - Just to have ctrlFactory declared here
		 */
		panelCreate: function(panelId, options) {
			return this._panelsManager ? this._panelsManager.panelCreate(panelId, options) : null;
		},
		/**
		 * Toggle left/right panel - data-action="sidePanel"
		 * 	panel : left or right
		 * 	action toggle
		 */
		_actToggleSidePanel: function(action, side) {
			if (!this._panelsManager) return;
			var self = this;
			var side = side == null || side === "all" ? ["left", "right"] : [side];
			side.forEach(function(where) {
				self._panelsManager.panelToggle(where, null, action);
			});
		},

		getPinPageId: function() {
			// Overridden by child classes!
		},
		getPinPageData: function() {
			var self = this;
			var pageData = {
				name: self.state.name,
				title: self.prototype.data("$title"),
				id: self.getPinPageId(),
				icon: "star"
			};
			return pageData;
		},
		/**
		 * Returns page authoring property
		 * path: string with or without '.' separator or array of string
		 */
		getAuthoring: function(path, defValue) {
			var val = utils.getPropByPath(this.article, path);
			return val != null ? val : defValue;
		},
		notifUpdtCardArticle: function(notifData, controlId) {
			var array = this.getControl(controlId);
			if (!array || !notifData) return;
			array.setCardAuthoring(notifData.article);
		},
		notifPageUpdtScroll: function(preserveScroll) {
			this._initScroll(preserveScroll);
		},
		/**
		 * Used by test entities to attach an article to a link
		 * - When we open a detail from a query (array)
		 * 		$detailLinkArticle attribute
		 * 		$queryLinkArticle attribute
		 * - when we open a facet form a $link vignette
		 * 		$linkArticle attribute
		 */
		getLinkedPageArticle: function(back, ctrlId) {
			if (back === true) {
				// From a back we read forceLinkArticle stored in page context  see savedCtxCreate
				// We need to read forceLinkArticle if any when we create the page - before savedCtxRestore 
				return this.savedContext && this.savedContext.current ? this.savedContext.current.forceLinkArticle : null;
			}
			if (ctrlId) {
				var ctrl = utils.findControl($("#" + ctrlId, this.$$elmt));
				if (!ctrl || !ctrl.getLinkedPageArticle) return;
				return ctrl.getLinkedPageArticle();
			}
		},
		getToolbarLinks: function() {
			return null;
		},
		getProtoLinks: function() {
			return null;
		},
		getMultiSelectionLinks: function() {
			return null;
		},
		isMultiSelectionEnabled: function() {
			return this.getMultiSelectionLinks() != null;
		},
		/**
		 * typeControl= "header" or "footer"
		 * newControl= Header or Footer control
		 * Switchs current footer/header by newControl
		 * Returns the current footer/header
		 * newControl =  null -> Restores the original footer/header
		 */
		toggleHeaderFooter: function(typeControl, newControl) {
			if (newControl == null) {
				// Restore original footer
				newControl = this[type.smCapitalize()];
			}
			if (!newControl) return;
			var $$root = this.$$elmt.children(typeControl);
			if (this._pageControls.get(typeControl) === newControl) {
				return;
			}
			var oldControl = this._pageControls.remove(typeControl);
			if (oldControl) {
				if (oldControl.$$elmt) {
					oldControl.$$elmt.detach();
				}
				oldControl.notifToggled(false);
				this.removeControl(oldControl);
			}
			this._pageControls.add(typeControl, newControl);
			if (!newControl.$$elmt) {
				newControl.buildHtml($$root, this.dao);
			} else {
				$$root.append(newControl.$$elmt);
				// JQuery work around for 'a' tags - the JQuery.defaultDisplay function returns 'inline' for a and we need 'inline-block'
				// if we attach a footer and reattach it, call show/hide restores the defaultDisplay instead the orginal one 
				// if we don't detach the footer it works ok so we force inline-block
				newControl.$$elmt.find("a").css("display", "inline-block");
			}
			this.addControl(newControl);
			newControl.notifToggled(true);
			return oldControl;
		}
	}
);

exports.Page = _Page;
});

define('syracuse-tablet/html/js/pages/pageDashboard',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/pages/page','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/modals/modal'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/pages/page').Page;
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');

var _Page = utils.defineClass(

	function DashboardPage($parent, state, prototype, article, options) {
		if (options.breadcrumbs == null) options.breadcrumbs = true;
		Base.call(this, $parent, state, prototype, article, options);
		this.vignettes = [];
		this._vignettesLoaderStates = [];
		this.cacheNotify = true;
		var app = globals.getApplication();
		if (app.dao.isSageApplication() && this.state.dashboardName === app.dao.getHomeDashboardName()) {
			this.$$contentElmt.addClass(app.dao.getAppBackGroundClass());
		}
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			this.vignettes = null;
			this._vignettesLoaderStates = null;
		},

		loadData: function(loadOptions) {
			this.cacheNotify = true;
			return null;
		},

		beforeAddContent: function() {
			// #5583 - disabled rendering of title because redundant with header title
		},

		addControl: function(c) {
			Base.prototype.addControl.call(this, c);
			if (c && c.isVignette && c.isVignette()) {
				this.vignettes.push(c);
			}
		},
		afterRender: function(loadOptions, buildOpts) {
			var self = this;
			Base.prototype.afterRender.call(this, loadOptions, buildOpts);
			// Empty dashboard
			if (!this.vignettes || this.vignettes.length < 1) {
				// Todo, better check in another way
				//this.renderEmptyDashboardMessage();
			} else {
				var vignetteNum = 0;
				var dashName = self.prototype.data("$dashboardName");
				var join = [];

				this.vignettes.forEach(function(v) {
					var pageOptions = {
						sdataParameters: self.state.options && self.state.options.sdataParameters || {},
						vignetteName: dashName + "#" + vignetteNum
					};
					var vLoadOptions = {
						updateLayout: loadOptions.updateLayout === true
					};
					vignetteNum++;
					var loadPromise = v.load(null, pageOptions, vLoadOptions).then(function(page, error) {
						self._checkVignetteLoadError(error);
						return page;
					});
					join.push(loadPromise);
				});

				// In case authoring is active, we wait until all vignettes are loaded
				// If it's non authoring, just let them load async
				if (globals.isAuthoringActive()) {
					return $.smForEachPromise(join, function(loader) {
						return loader;
					});
				}
			}
		},

		/*
		 * Called once a vignette has been loaded
		 * Once all vignettes are loaded, we check if there was an error we need to handle globally
		 */
		_checkVignetteLoadError: function(error) {
			var self = this;
			if (!self.vignettes || !self._vignettesLoaderStates) {
				// dashboard could have been destroyed when afterRender is called
				return;
			}
			self._vignettesLoaderStates.push({
				error: error
			});
			// We got a state from all vignettes that are pending to load
			if (self._vignettesLoaderStates.length === this.vignettes.length) {
				// Check if we went offline
				var goLogin = false;
				var e;
				self._vignettesLoaderStates.some(function(s) {
					if (s.error && s.error.$redirectPage === "login") {
						e = s.error;
						return true;
					}
				});
				self._vignettesLoaderStates = [];
				if (e) {
					modal.error(locale.text("error.page.loading"), e, function() {
						globals.getApplication().gotoLogin(locale.text("login.timeout.message"));
					});
				}
			}
		},
		onMainPageResize: function(info, orientation, deviceClass) {
			Base.prototype.onMainPageResize.call(this, info, orientation, deviceClass);
			/**
			 * We need to load the vignettes after having resized the main page
			 * otherwise we load page which is nested in the vignette two times, onMainPageResize and after the vignette has been loaded (asynch)
			 * If we load vignette here we make sure that onMainPageResize resizes only the vignette (not the nested page)
			 * Nested page will be resized after having been loaded
			 */
			this.vignettes.forEach(function(v) {
				v.onMainPageResize(info, orientation, deviceClass);
			});
		},

		authUpdateLayout: function(article) {
			this.vignettes = [];
			return Base.prototype.authUpdateLayout.call(this, article);
		},
		/**
		 * Context to store when dashboard is destroyed
		 * We save the context for each vignette (scroll, selection....)
		 * Context of the vignette will be retrieved with the index which is the identifier
		 * Vignette id is recalculated at creation and changes each time the vignette is loaded
		 */
		savedCtxCreate: function() {
			var ctx = Base.prototype.savedCtxCreate.call(this);
			ctx.vignettes = [];
			var p;
			this.vignettes && this.vignettes.forEach(function(v) {
				p = v.getPage();
				// We store a context even if p == null - Vignette can be destroyed before the end of load process and we must preserve the index in vignette array
				// Vignette is identified by its index
				ctx.vignettes.push(p ? p.savedCtxCreate() : null);
			});
			if (this.isHubLayout()) {
				// Store the scroll of hub layout
				ctx.hubCtx = this.rootLayout.savedCtxCreate();
			}
			return ctx;
		},
		/**
		 * Restore the context for the dashboard (not for the vignette)
		 */
		savedCtxRestore: function(ctx) {
			// Std restore for all page
			Base.prototype.savedCtxRestore.call(this, ctx);
			// store vignettes context
			this._savedVignetteContext = ctx.vignettes;
			if (ctx.hubCtx && this.isHubLayout()) {
				// Restore the scroll of hub layout
				this.rootLayout.savedCtxRestore(ctx.hubCtx);
			}
		},
		/**
		 * Returns the context of a vignette v
		 * Called by the vignette
		 */
		savedCtxVignette: function(v) {
			if (v == null || this._savedVignetteContext == null) return null;
			var idx = this.vignettes.indexOf(v);
			if (idx == -1 || idx > this._savedVignetteContext.length - 1) return null;
			return {
				current: this._savedVignetteContext[idx]
			};
		},

		renderEmptyDashboardMessage: function() {
			var text;
			if (this.state.isWelcomePage) {
				text = locale.text("dashboard.welcome.empty");
			} else {
				text = locale.text("dashboard.all.empty");
			}

			this.rootLayout.$$elmt.prepend('<div class="s-m-dashboard-msg-empty">' + text + "</div>");
		},
		getPinPageId: function() {
			var self = this;
			return self.state.dashboardName + "_" + JSON.stringify(self.state.options.sdataParameters);
		},
		getPinPageData: function() {
			var self = this;
			var params;
			if (self.state.options.sdataParameters) {
				Object.keys(self.state.options.sdataParameters).forEach(function(key) {
					var opt = key + "=" + self.state.options.sdataParameters[key];
					if (params) {
						params += "&" + opt;
					} else {
						params = opt;
					}
				});
			}
			var pageData = Base.prototype.getPinPageData.call(self);
			pageData.dashboardName = self.state.dashboardName;
			pageData.sdataParameters = params; // In case of a filtered dashboard, may be null
			return pageData;
		},

		cachedDataNotification: function(message) {
			if (this.cacheNotify === true) {
				globals.getModal().notify(message);
				this.cacheNotify = false;
			}
		},
		isHubLayout: function() {
			return this.rootLayout && this.rootLayout.$type === "hub";
		},
		getGestureMgr: function() {
			return this.isHubLayout() ? this.rootLayout.getGestureMgr() : Base.prototype.getGestureMgr.call(this);
		},
		getScrollOffset: function() {
			var offset = globals.getApplication().getScrollOffset();
			if (this.isHubLayout() && this.getGestureMgr()) {
				var o = this.getGestureMgr().getOffset();
				// Application content can be scrolled (native in authoring)
				offset.top += o.top;
				offset.left += o.left;
				return o;
			} else {
				// No offset
				return offset;
			}
		}
	});

exports.Page = _Page;
});

define('syracuse-tablet/html/js/sdata/entities/welcomeApplication',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/application/settings','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var settings = require('syracuse-tablet/html/js/application/settings');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _appList = {
	hidden: [],
	visible: []
};

var _welcomeApplication = {
	"$application": {
		"$uuid": "$welcomeApplication",

		"applicationName": "$welcomeApplication",
		"title": "",
		"description": "",
		"iconName": "gears",

		"$homeDashboard": {
			"$uuid": "$welcomeDashboard",
			"dashboardName": "$welcomeDashboard"
		},
	},
	"$dashboards": {
		"$welcomeDashboard": {
			"$pageInfo": {
				// Don't remove it - used to identify application welcome page
				"isWelcomePage": true,
				"disableAuthoring": true
			},
			"$update": function(dashboard) {
				return _updateWelcomeDashboard(dashboard);
			},
			"$dashboardName": "$welcomeDashboard",
			/* It's the first page, no need to explain that using title or description */
			"$title": "",
			"$description": "",
		}
	}
};

function _buildGadget(page) {
	if (page.dashboardName) {
		return _buildDashboardGadget(page);
	} else {
		return _buildRepresentationGadget(page);
	}
}

function _buildRepresentationGadget(page) {
	return {
		"$type": "$representation",
		"$title": page.title,
		"entity": page.entity,
		"action": page.action,
		"representation": page.representation,
		"facet": page.facet,
		"keyParameter": page.key,
		"endpoint": page.endpoint,
		"applicationName": page.applicationName,
		"icon": page.icon,
	};
}

function _buildDashboardGadget(page) {
	return {
		"$type": "$dashboard",
		"$title": page.title,
		"dashboardName": page.dashboardName,
		"applicationName": page.applicationName,
		"sdataParameters": page.sdataParameters, // Contains url with key value pairs like code=444&group=123&bpcnum=123
		"endpoint": page.endpoint,
		"icon": page.icon,
	};
}

function _addPinnedPages(dashboard, apps) {
	var grp;
	var pageId = 1;
	var tileConfigs;
	var endpoint = globals.getEndpoint();
	var appNames;

	appNames = apps.map(function(a) {
		return a.applicationName;
	});

	return settings.getTileConfigs()
		.then(function(tc) {
			tileConfigs = tc;
		})
		.then(function() {
			return settings.getPinnedPages();
		})
		.then(function(pp) {
			if (pp.length <= 0) {
				return;
			}
			grp = {
				"$layoutType": "hubGroup",
				"$title": locale.text("welcome.myquicklinks"),
				"$items": []
			};
			pp.forEach(function(page) {
				if (appNames.indexOf(page.applicationName) >= 0) {
					var config = tileConfigs["pin-" + page.id];
					config = config || {};

					var gadgetName = "$$$" + pageId;
					pageId++;
					var vignetteName = gadgetName;
					var gadget = _buildGadget(page);
					if (gadget.endpoint === endpoint) {
						gadget.$title = config.title || gadget.$title;
						gadget.icon = config.icon || gadget.icon;

						// Used to find which page was pinned in this gadget in case we remove directly on welcome page
						gadget.pinPageId = page.id;

						dashboard.$gadgets[gadgetName] = gadget;

						dashboard.$vignettes[vignetteName] = {
							"$uuid": gadgetName,
							"$displayStyle": "$link"
						};

						grp.$items.push({
							$layoutType: "tile",
							$bgColor: config.color || "darkgrey",
							$items: [{
								$bind: vignetteName
							}],
							$size: config.size || "medium"
						});
					}
				}
			});
		})
		.then(function() {
			if (grp && grp.$items && grp.$items.length > 0) {
				dashboard.$article.$items.push(grp);
			}
		});

}

function _addApps(dashboard, apps) {

	var apps;
	var hiddenApps;
	var groups = {
		sageAppli: {
			"$layoutType": "hubGroup",
			"$title": locale.text("welcome.sageapp"),
			"$items": []
		},
		byDefault: {
			"$layoutType": "hubGroup",
			"$title": locale.text("welcome.myapps"),
			"$items": []
		}
	};
	var tileConfigs;
	return settings.getTileConfigs()
		.then(function(tc) {
			tileConfigs = tc;
		})
		.then(function() {
			return settings.getHiddenApplications();
		})
		.then(function(hiddenAppsList) {
			hiddenApps = hiddenAppsList;

			// Make list availabe for later use in page
			_appList.hidden = [];
			_appList.visible = [];
			hiddenApps.forEach(function(name) {
				apps.forEach(function(appInfo) {
					if (name === appInfo.applicationName) {
						_appList.hidden.push(appInfo);
					}
				});
			});

			apps.forEach(function(appInfo) {
				var name = appInfo.applicationName;
				if (appInfo.applicationName !== _welcomeApplication.$application.applicationName && hiddenApps.indexOf(name) < 0) {
					_appList.visible.push(name);

					var config = tileConfigs["app-" + name];
					config = config || {};
					var name = "$welcome_" + appInfo.applicationName;
					var gadget = {
						"$type": "$application",
						"$title": config.title || appInfo.title,
						"applicationName": appInfo.applicationName,
						"icon": config.icon || appInfo.iconName
					};
					var vignette = {
						"$uuid": name
					};
					dashboard.$gadgets[name] = gadget;
					dashboard.$vignettes[name] = vignette;
					groups[appInfo.isSageApplication ? "sageAppli" : "byDefault"].$items.push({
						$layoutType: "tile",
						$bgColor: config.color,
						$items: [{
							$bind: name
						}],
						$size: config.size || "medium"
					});
				}
			});
			for (var p in groups) {
				if (globals.isDvlpMode() || p !== "sageAppli") {
					if (groups[p].$items.length > 0) {
						dashboard.$article.$items.push(groups[p]);
					}
				}
			}
		});
}

/* we pass appMetaData as parameter to allow $update to refresh it (original appMetaData has been cloned) - see getAppDetail*/
function _updateWelcomeDashboard(dashboard) {
	var meta = globals.getMetaData();
	var appList;
	dashboard.$gadgets = {};
	dashboard.$vignettes = {};
	dashboard.$article = {
		"$layoutType": "hub",
		"$items": []
	};
	dashboard.$title = locale.text("welcome.title.home");
	return $.smResolve()
		.then(function() {
			return meta.getApplications();
		})
		.then(function(apps) {
			appList = apps;
		})
		.then(function() {
			return _addPinnedPages(dashboard, appList);
		})
		.then(function() {
			return _addApps(dashboard, appList);
		})
		.then(function() {
			return dashboard;
		})
		.fail(function(e) {
			console.log(e);
			return $.smReject(e);
		});
}

exports.register = function() {
	clientContract.registerApp(_welcomeApplication);
};

/* 
 * Returns the list of applications available to the user that were hidden by settings during
 * the last initialisation of the dashboard.
 * This list is the list of applications that the user could add to the welcome page if he want's to
 */
exports.getApplicationLists = function() {
	return _appList;
};
});

define('syracuse-tablet/html/js/ui/modals/modalChooseApps',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="form-group s-m-scroll-element"> \
					<div class="list-group">\
						{{#each appList}} \
							<a draggable="false" href="#" class="list-group-item" data-action="clickApp" data-params="{{applicationName}}">\
								<h4 class="list-group-item-heading">{{title}}</h4>\
								<p class="list-group-item-text">{{description}}</p>\
							</a>\
						{{/each}} \
					</div> \
				</div> \
			</div>',
	footer: ''
};

var _Klass = utils.defineClass(
	function ModalChooseApps(appList) {
		var self = this;
		modalDialog.ModalBase.call(self);
		// Init params
		self.appList = [];
		appList.forEach(function(a) {
			self.appList.push(a);
		});

		// Result
		self.selectedApps = {};
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "half_right";
			} else {
				displayFlags.modalClass = "full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			return {
				label_validate: locale.text("welcome.select.app.add"),
				label_cancel: locale.text("welcome.select.app.cancel"),
				title: locale.text("welcome.select.app.title"),
				appList: self.appList
			};
		},

		// could be removed, result is set in _onAction
		_onValidate: function() {

		},
		_onCancel: function() {
			var self = this;
			self.selectedApps = {};
		},

		_onAction: function(action, param) {
			var self = this;
			if (action === "clickApp") {
				var $$app = self.$$elmt.find('[data-params="' + param + '"]');
				if (self.selectedApps[param]) {
					$$app.removeClass("active");
					delete self.selectedApps[param];
				} else {
					$$app.addClass("active");
					self.selectedApps[param] = true;
				}
			}
			// dont close on actions
			return false;
		},

		_getResult: function() {
			var self = this;
			return Object.keys(self.selectedApps);
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/ui/modals/modalConfigTile',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/authoring/authoringProperties'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var authoringProperties = require('syracuse-tablet/html/js/authoring/authoringProperties');

var _templateAll = {
	header: '\
		<buttons class="pull-right"> \
			<button type="button" class="btn btn-default s-m-modal-btn-validate" data-action="$validate"></button> \
			<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
		</buttons> \
		<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
				<div class="form-group s-m-scroll-element"> \
					<label>{{lab_title}}</label> \
					<input id="tile_title" value="{{tileTitle}}"> \
					<label>{{lab_color}}</label> \
					<div class="s-m-list-colors">\
						{{#each colors}} \
							<a draggable="false" href="#" {{#if this.active}}class="active"{{/if}} data-action="clickColor" data-params="{{value}}">\
								<div class="s-m-bg-{{value}}"> \
								</div> \
							</a>\
						{{/each}} \
					</div> \
					<label>{{lab_size}}</label> \
					<div class="s-m-list-sizes">\
						{{#each sizes}} \
							<a draggable="false" href="#" {{#if this.active}}class="active"{{/if}} data-action="clickSize" data-params="{{value}}">{{label}}</a>\
						{{/each}} \
					</div> \
					<label>{{lab_icon}}</label> \
					<div class="s-m-list-icons">\
						{{#each icons}} \
							<a draggable="false" href="#" {{#if this.active}}class="active"{{/if}} data-action="clickIcon" data-params="{{value}}"> \
								<i class="{{label}}"/> \
							</a>\
						{{/each}} \
					</div> \
					<div style="width:100%; display: inline-block;"></div> \
				</div> \
			</div>',

	footer: '',
};

var _Klass = utils.defineClass(
	function ModalConfigTile(tile) {
		var self = this;
		modalDialog.ModalBase.call(self);

		// Init params
		self.tile = tile;
		// Result
		self.result = null;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "config-tile half_right";
			} else {
				displayFlags.modalClass = "config-tile full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			authoringProperties.initProperties();

			var properties = authoringProperties.getAllProperties();
			var data = {
				label_validate: locale.text("welcome.tile.cfg.ok"),
				label_cancel: locale.text("welcome.tile.cfg.cancel"),
				title: locale.text("welcome.tile.cfg.title"),

				lab_title: locale.text("welcome.tile.cfg.lab_title"),
				lab_color: locale.text("welcome.tile.cfg.lab_color"),
				lab_size: locale.text("welcome.tile.cfg.lab_size"),
				lab_icon: locale.text("welcome.tile.cfg.lab_icon")
			};

			data.colors = properties.tileColor.values.map(function(e) {
				return {
					active: self.tile.color === e.value,
					value: e.value,
					label: e.label
				};
			});
			data.colors.shift(); // First one is transparent which we do not want here

			data.sizes = properties.tileSize.values.map(function(e) {
				return {
					active: self.tile.size === e.value,
					value: e.value,
					label: e.label
				};
			});

			data.icons = fontUtils.getTileIconList().map(function(e) {
				var cls = fontUtils.getIconByName(e);
				return {
					active: self.tile.icon === e,
					value: e,
					label: cls
				};
			});

			data.tileTitle = self.tile.title;
			return data;
		},

		// could be removed, result is set in _onAction
		_onValidate: function() {
			var self = this;
			var $$selected = self.$$elmt.find('a.active');
			var i;

			var tile = $.extend(true, {}, self.tile);

			tile.title = self.$$elmt.find("#tile_title").val();

			for (i = 0; i < $$selected.length; i++) {
				var action = $($$selected[i]).attr("data-action");
				var param = $($$selected[i]).attr("data-params");
				switch (action) {
					case "clickColor":
						tile.color = param;
						break;
					case "clickSize":
						tile.size = param;
						break;
					case "clickIcon":
						tile.icon = param;
						break;
				}
			}
			self.result = tile;
		},
		_onCancel: function() {
			var self = this;
			self.result = null;
		},

		_onAction: function(action, param) {
			var self = this;
			switch (action) {
				case "clickColor":
				case "clickSize":
				case "clickIcon":
					var $$old = self.$$elmt.find('a.active[data-action="' + action + '"]');
					var $$new = self.$$elmt.find('a[data-action="' + action + '"][data-params="' + param + '"]');
					$$old.removeClass("active");
					$$new.addClass("active");
					break;
			}
			// dont close on actions
			return false;
		},

		_getResult: function() {
			var self = this;
			return self.result;
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/pages/pageWelcomeDashboard',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/pages/pageDashboard','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/application/settings','syracuse-tablet/html/js/sdata/entities/welcomeApplication','syracuse-tablet/html/js/ui/modals/modalChooseApps','syracuse-tablet/html/js/ui/modals/modalConfigTile'],function (require, exports, module) {

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/pages/pageDashboard').Page;
var locale = require('syracuse-tablet/html/js/helpers/locale');
var settings = require('syracuse-tablet/html/js/application/settings');
var welcomeApplication = require('syracuse-tablet/html/js/sdata/entities/welcomeApplication');
var modalChooseApps = require('syracuse-tablet/html/js/ui/modals/modalChooseApps');
var modalConfigTile = require('syracuse-tablet/html/js/ui/modals/modalConfigTile');

var _initConfigPage = false;

var _Page = utils.defineClass(

	function WelcomeDashboardPage($parent, state, prototype, article) {
		Base.call(this, $parent, state, prototype, article, {
			breadcrumbs: false
		});
		this.vignettes = [];
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
		},

		beforeAddContent: function() {
			// We do not show a title on the welcome page
			//this.addTitle(this.prototype.data("$title"), this.prototype.data("$description"));
			this.$$elmt.addClass("s-m-page-welcome-background");
		},

		buildHtmlOption: function(loadOptions) {
			var self = this;
			return Base.prototype.buildHtmlOption.call(self, loadOptions)
				.then(function(opts) {
					opts.makeFullHeight = false;
					opts.toolBars = {
						showAuthoring: false,
						showLinks: true,
						showHome: false,
						showPageConfig: true,
						statusPinPage: 0,
					};
					return opts;
				});
		},

		afterRender: function(loadOptions, buildOpts) {
			var self = this;
			Base.prototype.afterRender.call(self, loadOptions, buildOpts);
			if (_initConfigPage) {
				self._initConfigUI();
			}
			_initConfigPage = false;
		},

		_actPageConfig: function() {
			var self = this;
			self._initConfigUI();
		},

		_actCancelPageConfig: function() {
			var self = this;

			self._destroyConfigUI();
		},

		_actRemoveTile: function(vignetteId) {
			var self = this;
			var tile = self._getTileInfo(vignetteId);

			var first;
			if (tile.gadget.pinPageId) {
				first = settings.removePinnedPage(tile.gadget.pinPageId);
			} else {
				first = settings.hideApplication(tile.gadget.applicationName);
			}

			first.then(function() {
				return self._afterChangePage();
			});
		},

		_actAddWelcomeApp: function() {
			var self = this;
			var modal = new modalChooseApps.Modal(self._appList.hidden);
			modal.show().then(function(result) {
				if (result && result.length > 0) {
					$.smForEachPromise(result, function(app) {
						return settings.unhideApplication(app);
					})
						.then(function() {
							return self._afterChangePage();
						});
				}
			});
		},

		_afterChangePage: function() {
			var self = this;
			_initConfigPage = true; // Force auto start of page config on reload
			globals.getApplication().gotoWelcomeApplication(null, true);
		},

		_actConfigTile: function(vignetteId) {
			var self = this;

			var ti = self._getTileInfo(vignetteId);
			var classes = ti.$$tile.attr("class");

			var size = "medium";
			var cls = classes.split(" ");
			var validSizes = ["small", "medium", "wide", "large", "full", "all"];
			cls && cls.some(function(c) {
				if (validSizes.indexOf(c) > -1) {
					size = c;
					return true;
				}
				return false;
			});

			var color = /s-m-bg-(\w+)/.exec(classes);
			color = (color && color.length > 1 && color[1]) || "darkgrey";
			var tile = {
				title: ti.gadget.$title,
				color: color,
				size: size,
				icon: ti.gadget.icon
			};
			var modal = new modalConfigTile.Modal(tile);
			modal.show().then(function(result) {
				if (result != null) {
					self._applyTileChanges(ti, result);
				}
			});
		},

		_applyTileChanges: function(tileInfo, tile) {
			var self = this;
			var tileId;
			if (tileInfo.gadget.pinPageId) {
				tileId = "pin-" + tileInfo.gadget.pinPageId;
			} else {
				tileId = "app-" + tileInfo.gadget.applicationName;
			}
			tile.tileId = tileId;
			settings.setTileConfig(tile)
				.then(function() {
					self._afterChangePage();
				});
		},

		_initConfigUI: function() {
			var self = this;

			self._appList = welcomeApplication.getApplicationLists();

			var $$header = $(".s-m-control.header", self.$elmt);
			self.$$pageConfigHeader = $(
				'<div class="s-m-page-config-header">\
					<div class="pull-left">\
						<btn class="hidden addapp btn fa fa-cubes" data-action="addWelcomeApp">' + locale.text("page.configure.add.app") + '\
						</btn>\
					</div>\
			  	<div class="pull-right">\
					<btn class="cancel btn glyphicon glyphicon-remove" data-action="cancelPageConfig"></btn>\
				</div>\
			</div>');

			$$header.append(self.$$pageConfigHeader);

			if (self._appList.hidden.length > 0) {
				$('[data-action=addWelcomeApp]', $$header).removeClass("hidden");
			}
			var $$tiles = $(".s-m-tile", self.$$elmt);
			$$tiles.addClass("s-m-tile-edit");
			for (var i = 0; i < $$tiles.length; i++) {
				var $$tile = $($$tiles[i]);
				$$tile.attr("data-tile-config-id", i);

				var $$vignette = $(".s-m-vignette", $$tile);
				$$tile.append($('<btn class="cfg config fa fa-gears" data-action="configTile" data-params="' + $$vignette.attr('id') + '">'));
				$$tile.append($('<btn class="cfg remove fa fa-trash-o" data-action="removeTile" data-params="' + $$vignette.attr('id') + '">'));
			}

			$(".s-m-control.footer", self.$elmt).css({
				display: "none"
			});
		},

		_destroyConfigUI: function() {
			var self = this;
			if (self.$$pageConfigHeader) {
				self.$$pageConfigHeader.remove();
				self.$$pageConfigHeader = null;
			}

			$(".s-m-control.footer", self.$elmt).css({
				display: "block"
			});

			$(".s-m-tile-edit").removeClass("s-m-tile-edit");
			$(".s-m-tile btn.remove", self.$elmt).remove();
			$(".s-m-tile btn.config", self.$elmt).remove();
		},

		_getTileInfo: function(vignetteId) {
			var ctrl = this.getControl(vignetteId);
			if (!ctrl) {
				return;
			}
			var $$vignette = $("#" + vignetteId);
			var $$tile = $$vignette.closest(".s-m-tile");
			return {
				$$tile: $$tile,
				$$vignette: $$vignette,
				$$remove: $(".s-m-tile btn.remove", $$tile),
				ctrl: ctrl,
				gadget: ctrl.prototype.data("$gadget"),
			};
		},
	});

exports.Page = _Page;
});

define('syracuse-tablet/html/js/sdata/sdatawhere/operator',['require','exports','module','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {
var helpers = require('syracuse-tablet/html/js/helpers/utils');

exports.Operator = function(code, text, precedence, isPrefix, isInfix, isAssociative, isPredicate) {
	var self = this;
	self.code = code;
	self.text = text;
	self.precedence = precedence;
	self.isPrefix = isPrefix;
	self.isInfix = isInfix;
	self.isAssociative = isAssociative;
	self.isPredicate = isPredicate;
};
helpers.defineClass(exports.Operator, null, {
	toString: function() {
		return this.text;
	}
});

exports.operators = new function() {
	var self = this;
	self.operators = { //length : 0
	};

	init();

	function createOp(code, text, precedence, isPrefix, isInfix, isAssociative, isPredicate) {
		var op = new exports.Operator(code || text, text, precedence, isPrefix, isInfix, isAssociative, isPredicate);
		self.operators[op.text] = op;
		//self.operators.length++;
	}

	function init() {
		// codes are SQL operators - makes SQL conversion easy
		createOp(null, ".", 1, false, true, true, false);
		createOp(null, "not", 2, true, false, false, false);
		createOp("*", "mul", 3, false, true, true, false);
		createOp("/", "div", 3, false, true, true, false);
		createOp("%", "mod", 3, false, true, true, false);
		createOp(null, "+", 4, false, true, true, false);
		createOp(null, "-", 4, true, true, true, false);
		createOp("=", "eq", 5, false, true, false, true);
		createOp("<>", "ne", 5, false, true, false, true);
		createOp("<", "lt", 5, false, true, false, true);
		createOp("<=", "le", 5, false, true, false, true);
		createOp(">", "gt", 5, false, true, false, true);
		createOp(">=", "ge", 5, false, true, false, true);
		createOp(null, "between", 5, false, true, false, true);
		createOp(null, "in", 5, false, true, false, true);
		createOp(null, "like", 5, false, true, false, true);
		createOp(null, "and", 6, false, true, true, true);
		createOp(null, "or", 7, false, true, true, true);
		createOp(null, "(", 8, true, false, false, false);
		createOp(null, ")", 8, false, false, false, false);
		createOp(null, ",", 8, false, false, false, false);
	}

	return self;

};
});

define('syracuse-tablet/html/js/sdata/sdatawhere/token',['require','exports','module','syracuse-tablet/html/js/helpers/utils','./operator'],function (require, exports, module) {
var helpers = require('syracuse-tablet/html/js/helpers/utils');
var operators = require('./operator');

exports.tokenType = {
	identifier: 'identifier',
	operator: 'operator',
	literal: 'literal'
};

exports.Token = function(type, line, offset, length, val) {
	var self = this;
	self.type = type;
	self.value = val;

	var _line = line;
	var _offset = offset;
	var _length = length;
	self.getRemainingText = function() {
		return _line.substring(_offset, _line.length);
	};
};

helpers.defineClass(exports.Token, null, {
	matches: function(code) {
		return this.value instanceof operators.Operator && this.value.code == code;
	}
});
});

define('syracuse-tablet/html/js/sdata/sdatawhere/tokenizer',['require','exports','module','./token','./operator'],function (require, exports, module) {


var token = require('./token');
var operators = require('./operator');

exports.Tokenizer = new function() {
	var self = this;

	function _skipSpaces(chars, i) {
		while (i < chars.length && chars[i] === " ") {
			i++;
		}
		return i;
	}

	function _isDigit(str) {
		return new RegExp('[0-9]').test(str);
	}

	function _isLetter(str) {
		return new RegExp('[\$a-zA-Z%\']').test(str);
	}

	function _isWordChar(str) {
		return new RegExp('[\$a-zA-Z0-9_%\']').test(str);
	}

	function _parseNumber(line, chars, i, tokens) {
		var end = i + 1;
		while (end < chars.length && _isDigit(chars[end])) {
			end++;
		}
		var val;
		if (end < chars.length && chars[end] === '.') {
			end++;
			while (end < chars.length && _isDigit(chars[end])) {
				end++;
			}
			val = parseFloat(line.substring(i, end));

		} else {
			val = parseInt(line.substring(i, end), 10);
		}
		tokens.push(new token.Token(token.tokenType.literal, line, i, end - i,
			val));
		return end;
	}

	var _literals = {
		"true": true,
		"false": false,
		"null": null,
	};

	function _parseWord(line, chars, i, tokens) {
		var end = i + 1;
		while (end < chars.length && _isWordChar(chars[end])) {
			end++;
		}
		var word = chars.substr(i, end - i);
		var op = operators.operators.operators[word.toLowerCase()];
		if (op != null) {
			tokens.push(new token.Token(token.tokenType.operator, line, i, end - i, op));
		} else {
			var lit;
			if ((lit = _literals[word]) !== undefined) {
				tokens.push(new token.Token(token.tokenType.literal, line, i,
					end - i, lit));
			} else {
				tokens.push(new token.Token(token.tokenType.identifier, line,
					i, end - i, word));
			}
		}
		return end;
	}

	function _parseQuotedString(line, chars, i, tokens) {
		var quote = chars[i];
		var end = i + 1;
		var dest = 0;
		var res = "";
		while (end < chars.length) {
			if (chars[end] === quote) {
				end++;
				if (end === chars.length || chars[end] !== quote) {
					tokens.push(new token.Token(token.tokenType.literal, line,
						i, end - i, res));
					return end;
				}
			}
			res += chars[end++];
		}
		throw new Error('quoted string not terminated: ' + line.substring(i));
	}

	function _parseOperator(line, ch, i, tokens) {
		var op = operators.operators.operators[ch];
		tokens.push(new token.Token(token.tokenType.operator, line, i, 1, op));
		return i + 1;
	}

	function _parseDateTime(line, chars, i, tokens) {
		var end = i + 1,
			len = chars.length;
		while (end < len) {
			if (chars[end] == '@')
				break;
			end++;
		}
		if (end === chars.length) {
			throw new Error('Where parser: date constant not terminated:' + line.substring(i, line.length));
		}
		var str = chars.substr(i + 1, end - i - 1);
		var dt = new Date(str);
		if (dt != null) {
			var nt = new token.Token(token.tokenType.literal, line, i, end + 1 - i, dt);
			nt.dataType = "datetime";
			nt.svalue = str;
			tokens.push(nt);
		}
		return end + 1;
	}

	self.tokenize = function(line) {
		var tokens = [];
		var i = 0;
		while (i < line.length) {
			i = _skipSpaces(line, i);
			var ch = line[i];
			switch (ch) {
				case '@':
					i = _parseDateTime(line, line, i, tokens);
					break;
				case '"':
				case '\'':
					i = _parseQuotedString(line, line, i, tokens);
					break;
				case '.':
				case '-':
				case '+':
				case '(':
				case ')':
				case ',':
					i = _parseOperator(line, ch, i, tokens);
					break;
				default:
					if (_isLetter(ch)) {
						i = _parseWord(line, line, i, tokens);
					} else if (_isDigit(ch)) {
						i = _parseNumber(line, line, i, tokens);
					} else {
						throw new Error('invalid character: ' + line.substring(i));
					}
					break;
			}
		}

		return tokens;
	};

	return self;
};
});

define('syracuse-tablet/html/js/sdata/sdatawhere/expression',['require','exports','module','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {
var helpers = require('syracuse-tablet/html/js/helpers/utils');

exports.Expression = function(config) {
	var self = this;

	self.children = null;
	if (config.operator) {
		self.type = "operator";
		self.value = config.operator;
		self.children = [];
		if (config.expression1) {
			self.children.push(config.expression1);
		}
		if (config.expression2) {
			self.children.push(config.expression2);
		}
	} else if (config.expressionType) {
		self.type = config.expressionType;
		self.value = config.value;
		self.svalue = config.svalue;
		self.dataType = config.dataType;
		if (self.type === "function") {
			self.children = [];
		}
	}
};
helpers.defineClass(exports.Expression, null, {
	isPredicate: function() {
		switch (this.type) {
			case "operator":
				return this.value.isPredicate;
			case "identifier":
				return true; // don't know
			case "function":
				return true; // don't know -- will improve later
			case "literal":
				return false;
			default:
				throw new Error("invalid expression type: " + this.type);
		}
	},
	toString: function() {
		if (this.children == null) {
			return this.value.toString();
		}
		var sb = [];
		sb.push("[" + this.value.toString());
		for (var i = 0; i < this.children.length; i++) {
			sb.push(" " + this.children[i].toString());
		}
		sb.push("]");
		return sb.join('');
	}

});
});

define('syracuse-tablet/html/js/sdata/sdatawhere/parser',['require','exports','module','./token','./operator','./tokenizer','./expression'],function (require, exports, module) {
var token = require('./token');
var operators = require('./operator');
var tokenizer = require('./tokenizer');
var expression = require('./expression');

exports.Parser = new function() {
	var self = this;
	var _maxPrecedence = 8;

	function _finishBetween(tokens, tokenIndex, exp, precedence) {
		if (tokenIndex[0] == tokens.length || !tokens[tokenIndex[0]].matches("and")) {
			throw new Error("invalid expression: expected 'and' after " + tokens[tokenIndex[0] - 1].getRemainingText());
		}
		tokenIndex[0]++;
		var arg = _parseExpression(tokens, tokenIndex, precedence);
		exp.children.push(arg);
	}

	function _parseExpression(tokens, tokenIndex, precedence) {
		var exp = _parseTerm(tokens, tokenIndex);
		while (tokenIndex[0] < tokens.length) {
			var tk = tokens[tokenIndex[0]];
			var op = tk.value instanceof operators.Operator ? tk.value : null;
			if (op == null || !op.isInfix || op.precedence > precedence) {
				break;
			}
			tokenIndex[0]++;
			if (op.code == "in") {
				if (tokenIndex[0] === tokens.length || !tokens[tokenIndex[0]].matches("(")) {
					throw new Error("invalid expression: '(' expected after " + tk.getRemainingText());
				}
				tokenIndex[0]++;
				exp = new expression.Expression({
					operator: op,
					expression1: exp
				});
				_parseArguments(tokens, tk, tokenIndex, exp.children);
			} else {
				var arg = _parseExpression(tokens, tokenIndex, op.precedence - 1);
				exp = new expression.Expression({
					operator: op,
					expression1: exp,
					expression2: arg
				});
				if (op.code == "between") {
					_finishBetween(tokens, tokenIndex, exp, op.precedence);
				}
			}
			if (!op.isAssociative && op.precedence == precedence) {
				return exp;
			}
		}
		return exp;
	}

	function _parseTerm(tokens, tokenIndex) {
		if (tokenIndex[0] == tokens.length) {
			throw new Error("premature end of expression");
		}
		var tk = tokens[tokenIndex[0]];
		switch (tk.type) {
			case token.tokenType.identifier:
				tokenIndex[0]++;
				if (tokenIndex[0] < tokens.length && tokens[tokenIndex[0]].matches("(")) {
					return _parseFunctionCall(tokens, tk, tokenIndex);
				} else {
					return new expression.Expression({
						expressionType: "identifier",
						value: tk.value
					});
				}
			case token.tokenType.literal:
				tokenIndex[0]++;
				return new expression.Expression({
					expressionType: "literal",
					value: tk.value,
					svalue: tk.svalue,
					dataType: tk.dataType
				});
			case token.tokenType.operator:
				var op = tk.value;
				if (!op.isPrefix) {
					throw new Error("invalid expression: expected beginning of term at " + tk.getRemainingText());
				}
				tokenIndex[0]++;
				return _parsePrefixOperator(tokens, op, tokenIndex);
			default:
				throw new Error("internal error: bad token type " + tk.type);
		}
	}

	function _parseArguments(tokens, tk, tokenIndex, arguments0) {
		if (tokenIndex[0] < tokens.length && tokens[tokenIndex[0]].matches(")")) {
			tokenIndex[0]++;
			return;
		}
		while (tokenIndex[0] < tokens.length) {
			var arg = _parseExpression(tokens, tokenIndex, _maxPrecedence);
			arguments0.push(arg);
			if (tokenIndex[0] < tokens.length && tokens[tokenIndex[0]].matches(")")) {
				tokenIndex[0]++;
				return;
			}
			if (tokenIndex[0] == tokens.length || !tokens[tokenIndex[0]].matches(",")) {
				throw new Error("invalid expression: expected ',' or ')' at " + tokens[tokenIndex[0]].getRemainingText());
			}
			tokenIndex[0]++;
		}
		throw new Error("invalid function call syntax: argument missing after " + tk.getRemainingText());
	}

	function _parsePrefixOperator(tokens, op, tokenIndex) {
		var arg1;
		switch (op.code) {
			case "-":
			case "not":
				arg1 = _parseExpression(tokens, tokenIndex, 1);
				return new expression.Expression({
					operator: op,
					expression1: arg1
				});
			case "(":
				arg1 = _parseExpression(tokens, tokenIndex, op.precedence);
				//require('term').stream.print('???' + tokens[tokenIndex[0]].value);
				if (tokenIndex[0] == tokens.length || !tokens[tokenIndex[0]].matches(")")) {
					throw new Error("invalid expression: expected ')' after " + tokens[tokenIndex[0] - 1].getRemainingText());
				}
				tokenIndex[0]++;
				return arg1;
			default:
				throw new Error("internal error: bad prefix operator " + op.code);
		}
	}

	function _parseFunctionCall(tokens, tk, tokenIndex) {
		tokenIndex[0]++;
		var exp = new expression.Expression({
			expressionType: "function",
			value: tk.value
		});
		_parseArguments(tokens, tk, tokenIndex, exp.children);
		return exp;
	}

	self.parse = function(str) {
		if (str == null || str.length == 0) {
			return null;
		}
		var tokens = tokenizer.Tokenizer.tokenize(str);
		var tokenIndex = [];
		tokenIndex[0] = 0;
		var exp = _parseExpression(tokens, tokenIndex, _maxPrecedence);
		if (tokenIndex[0] != tokens.length) {
			throw new Error("invalid expression: unexpected token at " + tokens[tokenIndex[0]].getRemainingText());
		}
		return exp;
	};

	return self;
};
});

define('syracuse-tablet/html/js/sdata/sdatawhere/whereUtils',['require','exports','module'],function (require, exports, module) {

function _exec(data, exp, proto) {
	if (exp.type == "identifier") {
		exp.property = data[exp.value];
		// issue #3744 in X3 boolean properties has numeric values
		// and in the x3 filters (where clauses use numeric values 1(false) and
		// 2(true) for boolean properties)
		var item = proto && proto.$properties && proto.$properties.$resources ? proto.$properties.$resources.$item : null;
		if (item && item.$properties && item.$properties[exp.value] && item.$properties[exp.value].$type === "application/x-boolean") {
			exp.property = exp.property === true ? 2 : 1;
		}
	} else if (exp.type == "literal") {
		exp.property = (exp.dataType == "datetime") ? exp.svalue : exp.value;
	} else {
		if (exp.children) {
			var property = null;

			// propagate property from child to parent if operator if low level
			// operator
			if (exp.type == "operator") {
				switch (exp.value.code) {

					case "and":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property && exp.children[1].property);
						break;
					case "or":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property || exp.children[1].property);
						break;
					case "between":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property >= exp.children[1].property) && (exp.children[0].property <= exp.children[2].property);
						break;
					case ">=":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property >= exp.children[1].property);
						break;
					case ">":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property > exp.children[1].property);
						break;
					case "<=":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property <= exp.children[1].property);
						break;
					case "<":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property < exp.children[1].property);
						break;
					case "like_s":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						exp.property = (exp.children[0].property.toUpperCase()
							.indexOf(exp.children[1].property.toUpperCase()) === 0);
						break;
					case "like":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						var val = exp.children[1].property.toUpperCase().replace(
							/%/g, '');
						exp.property = (exp.children[0].property.toUpperCase()
							.indexOf(val) >= 0);
						break;
					case "=":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						if (exp.children[0].property == "0000-00-00" && exp.children[1].dataType === "datetime") {
							exp.children[0].property = "";
						}
						if (exp.children[1].property == "0000-00-00" && exp.children[0].dataType === "datetime") {
							exp.children[1].property = "";
						}
						exp.property = (exp.children[0].property == exp.children[1].property);
						break;
					case "<>":
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
						});
						if (exp.children[0].property == "0000-00-00" && exp.children[1].dataType === "datetime") {
							exp.children[0].property = "";
						}
						if (exp.children[1].property == "0000-00-00" && exp.children[0].dataType === "datetime") {
							exp.children[1].property = "";
						}
						exp.property = (exp.children[0].property != exp.children[1].property);
						break;
					case ".":
						_exec(data, exp.children[0], proto);
						_exec(exp.children[0].property, exp.children[1], proto);
						exp.property = exp.children[1].property;
						break;
					default:
						exp.property = property;
						// propagate to literals
						exp.children.forEach(function(child) {
							_exec(data, child, proto);
							if (child.type == "literal")
								child.property = property;
						});
				}
			} else if (exp.type == "function") {
				throw new Error("exp.type == 'function' not implemented");
			}
		}
	}
};

exports.execWhere = function(dataContext, exp, proto) {

	if (exp == null) {
		return true;
	}

	_exec(dataContext, exp, proto);

	return exp.property;

};
});

define('syracuse-tablet/html/js/sdata/sdataDispatcherLocal',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/sdata/sdatawhere/parser','syracuse-tablet/html/js/sdata/sdatawhere/whereUtils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var parser = require('syracuse-tablet/html/js/sdata/sdatawhere/parser').Parser;
var whereUtils = require('syracuse-tablet/html/js/sdata/sdatawhere/whereUtils');

exports.Dispatcher = utils.defineClass(function() {}, null, {
	"getEntity": function($representation) {
		var repr = $representation && $representation.split(".");
		if (repr && repr[0] && repr[0].smStartsWith("QUERY~")) {
			repr = repr[0].split("~")[1];
		} else {
			repr = repr && repr[0];
		}
		return repr && clientContract.getEntity(repr);
	},
	"accept": function(op, data) {
		var self = this;
		var deferred = $.Deferred();
		deferred.resolve(self.getEntity(op.$representation) != null);
		return deferred.promise();
	},

	"prototype": function(op, data) {
		var deferred = $.Deferred();
		deferred.reject("Dispatcher should never request for prototypes since they are cached in the application model on client side");
		return deferred.promise();
	},

	"new": function(op, data) {
		var self = this;
		var ent = self.getEntity(op.$representation);
		return ent.$services["$new"](op, data);
	},

	"read": function(op, data) {
		var self = this;
		var ent = self.getEntity(op.$representation);
		return ent.$services["$read"](op, data);
	},

	"query": function(op, data) {
		var self = this;
		var ent = self.getEntity(op.$representation);
		var list = ent.$services["$query"](op, data);

		// Apply where condition
		if (op.$where) {
			var deferred = $.Deferred();
			list.then(function(resources) {
				var list = resources.$resources;
				var exp = parser.parse(op.$where);
				var repr = op.$representation && op.$representation.split(".");
				var $proto = clientContract.getPrototype(repr[0], repr[1]);
				var res = [];
				list.forEach(function(item, i) {
					if (whereUtils.execWhere(item, exp, $proto)) {
						res.push(item);
					}
				});
				deferred.resolve({
					$resources: res
				});
			}).fail(function(e) {
				deferred.reject(e);
			});
			return deferred.promise();
		}
		return list;
	},

	"save": function(op, data) {
		var self = this;
		var ent = self.getEntity(op.$representation);
		return ent.$services["$save"](op, data);
	},

	"delete": function(op, data) {
		var self = this;
		var ent = self.getEntity(op.$representation);
		return ent.$services["$delete"](op, data);
	},
	"service": function(op, data) {
		var self = this;
		var ent = self.getEntity(op.$representation);
		return ent.$services[op.$service](op, data);
	}
});
});

define('syracuse-tablet/html/js/sdata/sdataDispatcherHttp',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/sdata/sdataHttp'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("sdataDispatcher");
var sdataHttp = require('syracuse-tablet/html/js/sdata/sdataHttp');

exports.Dispatcher = utils.defineClass(function() {}, null, {
	"accept": function() {
		var deferred = $.Deferred();
		deferred.resolve(true);
		return deferred.promise();
	},

	_isOnline: function() {
		// Just wrapped here to have eventual dedicated tracing posibility
		return globals.isOnline();
	},

	/*
	 * Returns true if the ajax response is considered to be an offline error message
	 */
	_isOfflineError: function(result) {
		if (result && result.status < 100) {
			return true;
		}
		return false;
	},

	_networkError: function(title, result) {
		if (result && result.responseJSON && result.responseJSON.$diagnoses) {
			result.responseJSON.$title = title;
			return $.smReject(result.responseJSON);
		}
		return $.smReject({
			$title: title
		});
	},

	_offlineNoCachedDataMessage: function() {
		return $.smReject({
			$diagnoses: [{
				$message: locale.text("error.network.offline.cache"),
				$severity: "error"
			}]
		});
	},

	/**
	 *  Called for every request handled by the dispatcher
	 *  Can be used to disable caching in general or for specific representations
	 */
	_useCache: function(op, data, action) {
		var cache = globals.getCache();
		if (cache.isDisabled()) { // Disabled by dev features?
			return false;
		}

		var nocache = op.$parsedUrl && op.$parsedUrl.query && op.$parsedUrl.query.nocache;
		if (nocache && action === "read") {
			return false;
		}
		if (op.$representation.indexOf(".$edit") > 0 && action === "read") {
			return false;
		}
		return true;
	},

	// GET: {$baseUrl}/SUPERV//$prototypes('AQTCRUD.$query')
	"prototype": function(op, data) {
		var deferred = $.Deferred();
		deferred.reject("Dispatcher should never request for prototypes since they are cached in the application model on client side");
		return deferred.promise();
	},

	//GET: {$baseUrl}/SUPERV/AQTCRUD/$template?representation=AQTCRUD.$create
	"new": function(op, data) {
		var self = this;

		var cacheRead;
		var usedCache;
		if (self._isOnline()) {
			cacheRead = $.smResolve();
			usedCache = false;
		} else {
			cacheRead = self._newGetCache(op, data);
			usedCache = true;
		}

		return cacheRead.then(function(result) {
			// got new template from cache
			if (result) {
				log && log("Read template from cache: " + op.$representation);
				// Change UUID since we create a new record!
				result.$uuid = utils.UUID();
				return result;
			}
			return self._newDoHttp(op, data)
				.then(function(result) {
					if (result.isSuccess) {
						var data = result.responseJSON;
						return self._newPutCache(op, data)
							.then(function() {
								return data;
							});
					}
					if (!usedCache) {
						return self._newGetCache(op, data)
							.then(function(result) {
								if (result) {
									log && log("Read template from cache fallback: " + op.$representation);
									// Change UUID since we create a new record!
									result.$uuid = utils.UUID();
									return result;
								}
								return self._networkError("Error reading $template", result);
							});
					}
					return self._networkError("Error reading $template", result);
				});
		});
	},

	_newGetCache: function(op) {
		var self = this;
		if (self._useCache(op, null, "read")) {
			var cache = globals.getCache();
			log && log("Reading template from cache: " + op.$representation);
			return cache.read({
				$representation: "$templates",
				$endpoint: op.$endpoint,
				$key: op.$representation
			});
		}
		log && log("Disabled reading template from cache : " + op.$representation);
		return $.smResolve();
	},
	_newDoHttp: function(op, data) {
		var send = {
			method: "GET",
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_newPutCache: function(op, data) {
		var self = this;
		if (self._useCache(op, data, "write")) {
			log && log("Writing template to cache: " + op.$representation);
			var cache = globals.getCache();
			return cache.put({
				$representation: "$templates",
				$key: op.$representation,
				$endpoint: op.$endpoint,
				$data: data
			});
		}
		log && log("Disabled writing template to cache : " + op.$representation);
		return $.smResolve();
	},

	//GET: {$baseUrl}/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$create
	"read": function(op, data, forceUseCache) {
		var self = this;
		var cacheRead;
		var usedCache;
		if (self._isOnline() && forceUseCache !== true) {
			cacheRead = $.smResolve();
			usedCache = false;
		} else {
			cacheRead = self._readGetCache(op, data);
			usedCache = true;
		}

		return cacheRead.then(function(result) {
			if (result) {
				log && log("Read data from cache: " + op.$representation);
				result.$cacheHint = {};
				return result;
			}
			return self._readDoHttp(op, data)
				.then(function(result) {
					if (result.isSuccess) {
						var data = result.responseJSON;
						return self._readPutCache(op, data)
							.then(function() {
								return data;
							});
					}
					if (!self._isOfflineError(result)) {
						return self._networkError("Error reading data", result);
					}
					if (!usedCache) {
						return self._readGetCache(op, data)
							.then(function(data) {
								if (data) {
									data.$cacheHint = {};
									return data;
								}
								return forceUseCache === true ? null : self._offlineNoCachedDataMessage();
							});
					}
					return forceUseCache === true ? null : self._offlineNoCachedDataMessage();
				});
		});
	},

	_readGetCache: function(op) {
		var self = this;
		if (self._useCache(op, null, "read")) {
			var cache = globals.getCache();
			log && log("Reading data from cache: " + op.$representation);
			return cache.read({
				$representation: op.$representation,
				$endpoint: op.$endpoint,
				$key: op.$key
			});
		}
		log && log("Disabled reading data from cache : " + op.$representation);
		return $.smResolve();
	},
	_readDoHttp: function(op, data) {
		var send = {
			method: "GET",
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_readPutCache: function(op, data) {
		var self = this;
		if (self._useCache(op, data, "write")) {
			log && log("Writing data to cache: " + op.$representation);
			var cache = globals.getCache();
			return cache.put({
				$representation: op.$representation,
				$key: op.$key,
				$endpoint: op.$endpoint,
				$data: data
			});
		}
		log && log("Disabled writing data to cache : " + op.$representation);
		return $.smResolve();
	},

	// GET: {$baseUrl}/SUPERV/AQTCRUD?representation=AQTCRUD.$create?where=xxx
	"query": function(op, data, forceUseCache) {
		var self = this;

		var cacheRead;
		var usedCache;
		if (self._isOnline() && forceUseCache !== true) {
			cacheRead = $.smResolve();
			usedCache = false;
		} else {
			cacheRead = self._queryGetCache(op, data);
			usedCache = true;
		}

		return cacheRead.then(function(result) {
			var step;
			if (result && result.length > 0) {
				log && log("Queried data from cache: " + op.$representation);
				var response = {};
				step = self._queryCutAndAddLinks(op, data, result, response).then(function() {
					if (response.$resources.length > 0) {
						response.$cacheHint = {};
						return response;
					}
				});
			} else {
				step = $.smResolve(null);
			}

			return step.then(function(response) {
				if (response && response.$resources && response.$resources.length > 0) {
					return response;
				}
				return self._queryDoHttp(op, data)
					.then(function(result) {
						if (result.isSuccess) {
							var data = result.responseJSON;
							return self._queryPutCache(op, data)
								.then(function() {
									return data;
								});
						}
						if (!self._isOfflineError(result)) {
							return self._networkError("Error reading data", result);
						}

						if (!usedCache) {
							return self._queryGetCache(op, data)
								.then(function(result1) {
									if (result1 && result1.length > 0) {
										log && log("Queried data from cache: " + op.$representation);
										var response = {};
										return self._queryCutAndAddLinks(op, data, result1, response).then(function() {
											if (response.$resources.length > 0) {
												response.$cacheHint = {};
												return response;
											}
										});
									}
									return forceUseCache === true ? null : self._offlineNoCachedDataMessage();
								});
						}
						return forceUseCache === true ? null : self._offlineNoCachedDataMessage();
					});
			});
		});
	},
	_queryCutAndAddLinks: function(op, data, result, response) {
		var self = this;
		var baseUrl = op.$parsedUrl.source.split("?")[0];
		var query = "";
		var key;
		var max = 30;
		var orderBy = "";

		if (op.$parsedUrl.query && op.$parsedUrl.query.where) {
			query += "&where=" + op.$parsedUrl.query.where;
		}

		key = op.$parsedUrl.query && op.$parsedUrl.query.key;
		var firstKeyRead;
		var lastKeyRead;

		var resources = response.$resources = [];
		var hasNextPage = false;
		var hasPreviousPage = false;
		var i;

		var pageName = op.$endpoint + "." + op.$representation;
		return globals.getMetaData().getPrototype(pageName)
			.then(function(proto) {
				var val;
				var kv;
				var orderBy = "";
				proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
				var keyField;
				if (proto.$key) {
					keyField = proto.$key.replace(/{/g, "").replace(/}/g, "");
				} else {
					keyField = "$uuid";
				}
				if (op.$parsedUrl.query && op.$parsedUrl.query.orderBy) {
					orderBy = self._buildOrderBy(op, keyField, op.$parsedUrl.query.orderBy);
					query += "&orderBy=" + orderBy;
				}

				var keyType = proto.$properties[keyField];
				var isNumericKey = keyType && keyType.$type && keyType.$type !== "application/x-string";
				var gotMatch = false;
				if (key && key.smStartsWith("gt")) {
					val = key.substr(3);
					val = isNumericKey ? +val : val;

					for (i = 0; i < result.length; i++) {
						if (!gotMatch) {
							kv = self._calculateKey(proto, result[i]);
							kv = isNumericKey ? +kv : "" + kv;
						}
						if (kv == val && !gotMatch) {
							gotMatch = true;
						} else if (gotMatch) {
							resources.push(result[i]);
							if (resources.length > max) {
								break;
							}
						} else {
							hasPreviousPage = true;
						}
					}
					if (resources.length > 0) {
						if (resources.length > max) {
							resources.pop();
							hasNextPage = true;
						}
						firstKeyRead = self._calculateKey(proto, resources[0]);
						lastKeyRead = self._calculateKey(proto, resources[resources.length - 1]);
					}
				} else if (key && key.smStartsWith("lt")) {

					if (key.length > 3) {
						val = isNumericKey ? +key.substr(3) : "" + key.substr(3);

						for (i = result.length - 1; i >= 0; i--) {
							if (!gotMatch) {
								kv = self._calculateKey(proto, result[i]);
								kv = isNumericKey ? 0 + kv : "" + kv;
							}

							if (kv == val && !gotMatch) {
								gotMatch = true;
							} else if (gotMatch) {
								resources.push(result[i]);
								if (resources.length > max) {
									break;
								}
							} else {
								hasNextPage = true;
							}
						}
						if (resources.length > max) {
							hasPreviousPage = true;
							resources.pop();
						}
					} else {
						for (i = result.length - 1; i >= 0; i--) {
							resources.push(result[i]);
							if (resources.length > max) {
								break;
							}
						}
					}
					if (resources.length > 0) {
						if (resources.length > max) {
							hasPreviousPage = true;
							resources.pop();
						}
						response.$resources = resources = resources.reverse();

						firstKeyRead = self._calculateKey(proto, resources[0]);
						lastKeyRead = self._calculateKey(proto, resources[resources.length - 1]);
					}
				} else {
					for (i = 0; i < result.length; i++) {
						resources.push(result[i]);
						if (resources.length > max) {
							break;
						}
					}
					if (resources.length > 0) {
						if (resources.length > max) {
							hasNextPage = true;
							resources.pop();
						}

						firstKeyRead = self._calculateKey(proto, resources[0]);
						lastKeyRead = self._calculateKey(proto, resources[resources.length - 1]);
					}
				}

				var links = response.$links = {};
				if (key) {
					links.$first = {
						$url: baseUrl + "?representation=" + op.$representation + query
					};
				}

				if (key && firstKeyRead && hasPreviousPage) {
					if (key !== "gt") { // not on first page?
						links.$previous = {
							$url: baseUrl + "?representation=" + op.$representation + query + "&key=lt." + firstKeyRead
						};
					}
				}

				if (key !== "lt" && lastKeyRead && hasNextPage) { // not on last page and more records
					links.$next = {
						$url: baseUrl + "?representation=" + op.$representation + query + "&key=gt." + lastKeyRead
					};
				}
				if (key !== "lt") {
					links.$last = {
						$url: baseUrl + "?representation=" + op.$representation + query + "&key=lt"
					};
				}

				links.$more = {
					$url: op.$parsedUrl.source + "&nocache=true"
				};
			});
	},
	_queryGetCache: function(op) {
		var self = this;
		if (self._useCache(op, null, "read")) {
			var cache = globals.getCache();
			log && log("Querying data from cache: " + op.$representation);
			var p = op.$endpoint + "." + op.$representation;
			// Ususally this should never be called since the sync call above
			// returns the prototype already.
			return globals.getMetaData().getPrototype(p).then(function(proto) {
				self._checkQueryPrototype(op, proto);

				var filters = proto.$filters;
				var where = self._extendWhereWithFilter(op, filters);

				var proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
				var keyField;
				if (proto.$key) {
					keyField = proto.$key.replace(/{/g, "").replace(/}/g, "");
				} else {
					keyField = "$uuid";
				}
				var orderBy = self._parseOrderBy(op.$orderBy, keyField);
				return cache.query({
					$proto: proto,
					$endpoint: op.$endpoint,
					$where: where,
					$orderBy: orderBy
				}).fail(function(e) {
					return $.smReject(e);
				});
			});
		}
		log && log("Disabled querying data from cache : " + op.$representation);
		return $.smResolve();
	},
	_queryDoHttp: function(op, data) {
		var send = {
			method: "GET",
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_queryPutCache: function(op, data) {
		var self = this;
		if (self._useCache(op, data, "write")) {
			log && log("Writing data to cache: " + op.$representation);
			var cache = globals.getCache();

			var pageName = op.$endpoint + "." + op.$representation;
			return globals.getMetaData().getPrototype(pageName).then(function(proto) {
				proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
				return $.smForEachPromise(data.$resources, function(item) {
					var key = self._calculateKey(proto, item);
					return cache.put({
						$representation: op.$representation,
						$key: key,
						$endpoint: op.$endpoint,
						$data: item
					});
				});
			});
		}
		// No cache
		return $.smResolve(data);
		log && log("Disabled writing data to cache : " + op.$representation);
	},


	// PUT: {$baseUrl}/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$edit
	// POST: {$baseUrl}/SUPERV/AQTCRUD?representation=AQTCRUD.$create
	"save": function(op, data) {
		var self = this;
		return self._saveDoHttp(op, data)
			.then(function(result) {
				if (result.isSuccess) {
					var data = result.responseJSON;
					return self._savePutCache(op, data)
						.then(function() {
							return data;
						});
				}
				return $.smReject(result);
			});
	},

	_saveDoHttp: function(op, data) {
		var send = {
			method: op.$link.$method,
			url: op.$link.$url,
			send: data
		};
		return sdataHttp.send(send);
	},

	_savePutCache: function(op, data) {
		var self = this;
		try {
			if (self._useCache(op, data, "write")) {
				log && log("Writing data to cache: " + op.$representation);
				var cache = globals.getCache();
				var key = op.$key;
				var step;
				if (!key) {
					var pageName = op.$endpoint + "." + op.$representation;
					step = globals.getMetaData().getPrototype(pageName).then(function(proto) {
						proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
						key = self._calculateKey(proto, data);
						return key;
					});
				} else {
					step = $.smResolve(key);
				}
				// write to cache is async, this is why there is not "return step.then(...)"
				step.then(function(key) {
					self._removeFromCache({
						$representation: op.$representation,
						$key: key,
						$endpoint: op.$endpoint
					}).then(function() {
						return cache.put({
							$representation: op.$representation,
							$key: key,
							$endpoint: op.$endpoint,
							$data: data
						});
					});
				});
			}
			log && log("Disabled writing data to cache : " + op.$representation);
			return $.smResolve();
		} catch (e) {
			return $.smReject(e);
		}
	},

	// DELETE: {$baseUrl}/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$query
	"delete": function(op, data) {
		var self = this;
		var deferred = $.Deferred();
		try {
			self._deleteDoHttp(op, data)
				.then(function(result) {
					if (result.isSuccess) {
						var data = result.responseJSON;
						return self._deleteRemoveCache(op, data)
							.then(function() {
								return data;
							});
					}
					return $.smReject(result); //new Error("Error saving object: " + JSON.stringify(result)));
				})
				.then(function(result) {
					deferred.resolve(result);
				}).fail(function(e) {
					deferred.reject(e);
				});
		} catch (e) {
			deferred.reject(e);
		}
		return deferred.promise();
	},
	_deleteDoHttp: function(op, data) {
		var send = {
			method: op.$link.$method,
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_deleteRemoveCache: function(op, data) {
		var self = this;
		if (self._useCache(op, data, "write")) {
			log && log("Deleting data from cache: " + op.$representation);
			var cache = globals.getCache();
			self._removeFromCache({
				$representation: op.$representation,
				$key: op.$key,
				$endpoint: op.$endpoint
			}).then(function() {
				return cache.remove({
					$representation: op.$representation,
					$key: op.$key,
					$endpoint: op.$endpoint
				});
			});
		}
		log && log("Disabled deleting data from cache : " + op.$representation);
		return $.smResolve();
	},

	"service": function(op, data) {
		if (this._isOnline()) {
			var send = {
				method: op.$link.$method,
				url: op.$link.$url,
				send: data
			};
			return sdataHttp.send(send);
		} else {
			return $.smResolve({
				"$diagnoses": [{
					"$severity": "error",
					"$message": locale.text("error.service.offline")
				}]
			});
		}
	},
	_calculateKey: function(proto, item) {
		var key;
		if (proto.$key) {
			key = proto.$key.replace(/\{(.*?)\}/g, function(match, prop) {
				return item[prop];
			});
		} else {
			key = item.$uuid;
		}
		return key;
	},
	_getKeyFields: function(proto) {
		var key = proto.$key ||
			proto.$properties &&
			proto.$properties.$resources &&
			proto.$properties.$resources.$item &&
			proto.$properties.$resources.$item.$key;
		if (key) {
			var list = [];
			key.replace(/\{(.*?)\}/g, function(match, prop) {
				list.push(prop);
			});
			if (list.length < 1) {
				return ["$uuid"];
			}
			return list;
		} else {
			return ["$uuid"];
		}
	},
	_checkQueryPrototype: function(op, proto) {
		// https://github.com/Sage-ERP-X3/Syracuse/issues/6003
		// Type of $item in queries is application/json but the cache needs a concrete type to be able to store the data
		// For requester requests, type is empty and will also be generated here
		if (proto.$properties.$resources.$item) {
			proto.$properties.$resources.$item.$type = "{$baseType}." + op.$representation;
		}
	},
	_removeFromCache: function(op) {
		var self = this;

		var cache = globals.getCache();

		var facets = ["$edit", "$create", "$details", "$query", "$lookup"];
		var rep = op.$representation.split(".")[0];

		return $.smForEachPromise(facets, function(facet) {
			if (op.$representation.indexOf("." + facet) > 0) {
				return $.smResolve();
			}
			return cache.remove({
				$representation: rep + "." + facet,
				$key: op.$key,
				$endpoint: op.$endpoint
			});
		});
	},

	_parseOrderBy: function(orderBy, keyField) {
		if (!orderBy) {
			return [{
				property: keyField,
				sort: "ASC"
			}];
		}
		var o = [];
		orderBy.split(",").map(function(field) {
			field = field.trim();
			var d = field.split(" ");
			var f = d[0].trim();
			if (f.length > 0) {
				var dir = "ASC";
				if (d.length > 1) {
					dir = d[1].toUpperCase();
					dir = dir !== "DESC" ? "ASC" : "DESC";
				}
				o.push({
					property: f,
					sort: dir
				});
			}
		});
		return o;
	},

	_buildOrderBy: function(op, keyField, orderBy) {
		if (!orderBy) {
			return keyField;
		}

		if (!(orderBy === keyField || orderBy.indexOf(keyField + " ") > -1 || orderBy.indexOf(keyField + ",") > -1)) {
			// Key field not yet in order by
			if (orderBy.indexOf(" DESC") > -1) {
				orderBy += ", " + keyField + " DESC";
			} else {
				orderBy += ", " + keyField + " ASC";
			}
		}
		return orderBy;
	},

	_extendWhereWithFilter: function(op, filters) {
		var self = this;

		var where = op.$where;
		if (!filters) {
			return where;
		}
		var filterName = op.$parsedUrl && op.$parsedUrl.query && op.$parsedUrl.query.filter;
		if (!filterName) {
			return where;
		}
		var filter = filters && filters[filterName];
		if (!filter) {
			return where;
		}

		var fw = self._checkFilterWhere(filterName, filter.$where);
		if (!fw) {
			return where;
		}

		if (where) {
			where = "(" + where + ") and (" + fw + ")";
		} else {
			where = "(" + fw + ")";
		}

		return where;
	},

	/*
	 * Check if X3 filter contains invalid references of screen elements which are not valid on client side
	 * In case it's true, the filter will be ignored and an error message will be displayer
	 */
	_checkFilterWhere: function(filterName, where) {
		var invalid = where.match(/(\[F\:\w+\]?)/g);
		if (invalid) {
			globals.getModal().error(
				locale.text("sdata.error.filter.screenFieldTitle"),
				locale.text("sdata.error.filter.screenFieldDetails", [filterName, invalid.join(","), where])
			);
			// Do not use filter, it will cause errors
			return null;
		}
		return where;
	}
});
});

define('syracuse-tablet/html/js/sdata/sdataDispatcher',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/sdata/sdataUtils','syracuse-tablet/html/js/sdata/sdataDispatcherLocal','syracuse-tablet/html/js/sdata/sdataDispatcherHttp'],function (require, exports, module) {

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("sdataDispatcher");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');

var dispLocal = require('syracuse-tablet/html/js/sdata/sdataDispatcherLocal').Dispatcher;
var dispHttp = require('syracuse-tablet/html/js/sdata/sdataDispatcherHttp').Dispatcher;

var _dispatchers = [
	new dispLocal(),
	new dispHttp()
];

/**
 * link
 * {
 * 	 $url: ...,
 * 	 $method: "GET", ...
 * }
 * data
 * {
 *   ...
 * }
 */
exports.dispatch = function(link, data, options) {
	var deferred = $.Deferred();
	try {
		log && log("Dispatch: " + link.$method + ": " + link.$url);
		options = options || {};
		var op = exports.parseLink(link);
		// Used by authoring when update layout
		var forceUseCache = options.forceUseCache === true;
		var dispatcher;
		$.smForEachPromise(_dispatchers, function(disp) {
			return disp.accept(op, data);
		}, function(disp, result) {
			if (result === true) {
				dispatcher = disp;
				return true;
			}
			return false;
		});
		var cacheStatus;
		if (forceUseCache) {
			cacheStatus = globals.getCache().isDisabled();
			globals.getCache().disableCache(false);
		}
		var prom = dispatcher[op.$operation](op, data, forceUseCache);
		if (!prom) {
			throw new Error("Could not dispatch: " + link.$method + ": " + link.$url + " (" + op.$operation + ")");
		}
		prom.then(function(result) {
			if (forceUseCache) {
				globals.getCache().disableCache(cacheStatus);
			}
			deferred.resolve(result);
		}).fail(function(e) {
			if (forceUseCache) {
				globals.getCache().disableCache(cacheStatus);
			}
			deferred.reject(e);
		});
	} catch (e) {
		deferred.reject(e);
	}
	return deferred.promise();
};

/**
 * Parse link to identify which kind of operation it's intended to start
 *
 * link:
 * {
 * 	 $url: ...,
 * 	 $method: "GET", ...
 * }
 *
 * Return:
 * {
 *    "$link":{
 *       "$method":"DELETE",
 *       "$url":"http://localhost:8124/sdata/x3/erp/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$query"
 *    },
 *    "$parsedUrl":{
 * ...
 *       "directory":"/sdata/x3/erp/SUPERV/AQTCRUD('10')",
 *       "path":"/sdata/x3/erp/SUPERV/AQTCRUD('10')",
 *       "relative":"/sdata/x3/erp/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$query",
 * ...
 *       "query":{
 *          "representation":"AQTCRUD.$query"
 *       },
 * ...
 *       "representation":"AQTCRUD",
 *    },
 *    "$operation":"delete",
 *    "$key":"10",
 *    "$representation":"AQTCRUD.$query"
 * }
 *
 */
var _repExp = /\$prototypes\('(.*?)'\)/;
var _keyExp = /\('(.*?)'\)/;

exports.parseLink = function(link) {
	var url = link.$url;
	var result = {
		$link: link,
		$parsedUrl: sdataUtils.parseSDataURL(link.$url)
	};
	result.$endpoint = result.$parsedUrl.application + "." + result.$parsedUrl.contract + "." + result.$parsedUrl.dataset;
	var dir = result.$parsedUrl.directory; // All except query parameters
	var idx;
	if (link.$method === "GET") {
		if (url.indexOf("$prototypes") > -1) {
			result.$operation = "prototype";
			result.$representation = _repExp.exec(url)[1];
		} else if (dir.indexOf("$template") > -1) {
			result.$operation = "new";
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
		} else if (result.$parsedUrl.$services) {
			result.$operation = "service";
			result.$service = result.$parsedUrl.$services;
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
		} else {
			var key = _keyExp.exec(dir);
			var isQuery = dir.indexOf("/QUERY(") > -1;
			if (key && !isQuery) {
				result.$operation = "read";
				result.$key = key[1];
				result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
			} else {
				result.$operation = "query";
				result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
			}
		}
		if (result.$parsedUrl.query && result.$parsedUrl.query.where) {
			result.$where = result.$parsedUrl.query.where;
		}
		if (result.$parsedUrl.query && result.$parsedUrl.query.orderBy) {
			result.$orderBy = result.$parsedUrl.query.orderBy;
		}
	} else if (result.$parsedUrl.$services) {
		result.$operation = "service";
		result.$service = result.$parsedUrl.$services;
		result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
	} else if (link.$method === "DELETE") {
		var key = _keyExp.exec(dir);
		result.$operation = "delete";
		result.$key = key[1];
		result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
	} else {
		// PUT/POST and no service
		var key = _keyExp.exec(dir);
		if (key) {
			result.$operation = "save";
			result.$key = key[1];
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
		} else {
			result.$operation = "save";
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
		}
	}

	return result;
};
});

define('syracuse-tablet/html/js/storage/sessionStorage',['require','exports','module','syracuse-tablet/html/js/helpers/logger'],function (require, exports, module) {

/**
 * Session storage
 * 	Uses windows session storage or local hash map if not available
 */

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("sessstorage");

var _available = null;
var _backupMap = {};

var _isAvailable = function() {
	if (_available !== null) {
		return _available;
	}
	_available = false;
	try {
		window.sessionStorage.setItem("__test_availability_session__", "__test_availability_session__");
		_available = true;
	} catch (e) {}
	return _available;
};

var _getItem = function(key) {
	if (!_isAvailable()) {
		log && log("session.fallback.getItem(" + key + "):" + val);
		return _backupMap[key];
	}
	var val = window.sessionStorage.getItem(key);
	log && log("session.getItem(" + key + "):" + val);
	return val;
};

var _setItem = function(key, value) {
	if (!_isAvailable()) {
		log && log("session.fallback.setItem(" + key + "):" + value);
		_backupMap[key] = value;
		return;
	}
	log && log("session.setItem(" + key + "):" + value);
	return window.sessionStorage.setItem(key, value);
};

var _removeItem = function(key) {
	if (!_isAvailable()) {
		log && log("session.fallback.removeItem(" + key + ")");
		delete _backupMap[key];
		return;
	}
	log && log("session.removeItem(" + key + ")");
	return window.sessionStorage.removeItem(key);
};

exports.removeItem = _removeItem;
exports.setItem = _setItem;
exports.getItem = _getItem;
});

define('syracuse-tablet/html/js/pages/pageRegular',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/pages/page','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/sdata/sdataDispatcher','syracuse-tablet/html/js/application/appFactory','syracuse-tablet/html/js/sdata/sdataUtils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/storage/sessionStorage','syracuse-tablet/html/js/application/eventListener','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("page");
var Base = require('syracuse-tablet/html/js/pages/page').Page;
var globals = require('syracuse-tablet/html/js/helpers/globals');
var dispatcher = require('syracuse-tablet/html/js/sdata/sdataDispatcher');
var factory = require('syracuse-tablet/html/js/application/appFactory');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var sessStorage = require('syracuse-tablet/html/js/storage/sessionStorage');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');


//Add display info for facet actions - Simplify by adding name.action.$edit... in resources
var _addFacetLink = function(info, facet) {
	info.icon = fontUtils.getIconByName(facet);
	switch (facet) {
		case "$edit":
		case "$query":
		case "$save":
		case "$details":
		case "$delete":
		case "$create":
			info.title = locale.text("action." + facet);
			break;
		default:
			log && log("Facet " + facet + " not implemented yet");
			info.title = facet || "???";
			break;
	}
};
var _isOfficeLink = function(name) {
	return name.smStartsWith("$word") || name.smStartsWith("$excel");
};
var _isPaginLink = function(name) {
	return name === "$first" || name === "$previous" || name === "$next" || name === "$last" || name === "$more";
};
var _linksMap = {
	header: {
		smartphone: {
			details: {
				$edit: true,
				$delete: true
			},
			edit: {
				$canceledit: true,
				$save: true
			},
			query: {
				$create: true
			},
			create: {
				$save: true,
				$canceledit: true
			}
		},
		tablet: {}
	},
	footer: {
		smartphone: {},
		tablet: {
			details: {
				$edit: true,
				$delete: true,
				$query: true
			},
			edit: {
				$save: true,
				$canceledit: true
			},
			query: {
				$create: true
			},
			create: {
				$save: true,
				$canceledit: true
			}
		}
	},
	actionpanel: {}
};
var _getLinkMap = function(toolbar, deviceType, facet) {
	var lMap = _linksMap[toolbar];
	if (!lMap) {
		throw new Error("Unexpected toolbar parameter [" + toolbar + "]. Expected 'header', 'footer' or 'actionpanel'");
	}
	if (toolbar === "actionpanel") return lMap;
	lMap = lMap[deviceType || "tablet"];
	if (!lMap) {
		throw new Error("Unexpected deviceType parameter [" + deviceType + "]. Expected 'tablet', 'smartphone'");
	}
	if (facet === "lookup") facet = "query";
	if (facet === "summary") facet = "details";
	lMap = lMap[facet];
	if (!lMap) {
		throw new Error("Unexpected facet parameter [" + facet + "]");
	}
	return lMap;
};
/*
 * Returns appropriate right value for where request
 * For example, for the filter 'CODE contains aa', the where clause should look like
 * CODE like '%aa%'. This function will return '%aa%'
 */
var _setFilterRightValue = function(filter) {
	var cp = filter.prop;
	var cv, value = (filter.originalValue || filter.value) == null ? "" : (filter.originalValue || filter.value);
	switch (cp.$type) {
		case "application/x-password":
		case "application/x-string":
			cv = value.replace(/'/g, "\\'");
			if (filter.operator === "like") cv = '%' + cv + '%';
			else if (filter.operator === "like_s") cv = cv + '%';
			cv = "'" + cv + "'";
			return cv;
		case "application/x-integer":
		case "application/x-real":
		case "application/x-decimal":
		case "application/x-quantity":
			return value;
		case "application/x-date":
			if (!value) return null;
			return '@' + value + '@';
		case "application/x-datetime":
			return '@' + value + '@';
		case "application/x-time":
			return null;
		case "application/x-boolean":
			return value ? "true" : "false";
		case "application/x-choice":
			if (cp.$value && cp.$value.$type === "application/x-string") {
				return "'" + value.replace(/'/g, "\\'") + "'";
			} else return value + "";
			break;
		case "application/x-reference":
			if (typeof value != "string") {
				value = filter.value;
			}
			cv = (value || '').replace(/'/g, "\\'");
			cv = "'" + cv + "'";
			return cv;
		default:
			break;

	}
	return null;
};

/**
 * Page with representation and sdata back-end
 */
var _Page = utils.defineClass(
	function RegularPage($parent, state, prototype, article, options) {
		options.breadcrumbs = true;
		Base.call(this, $parent, state, prototype, article, options);
		this.gadget = this.state.options.gadget;
		this._originalSdataUrl = this.state.options["sdata-url"];
		if (!this._originalSdataUrl) {
			if (this.gadget) {
				this._originalSdataUrl = this.gadget.getSDataUrl(this.prototype);
			} else {
				this._originalSdataUrl = this.prototype.data("$url");
			}
		}
		this._init$Filters();
		this._initSdataInfo();
		notifications.subscribe(this, ["sm.rowdetail.update", "sm.rowdetail.delete", "sm.action.link"], 1);
		if (this.prototype.data("$url")) {
			this.$facet = sdataUtils.parseSDataURL(this.prototype.data("$url")).facet;
			// Override the standard "display" activity
			this.setActivity(this.$facet === "edit" ? "edit" : this.$facet === "create" ? "create" : "read");
		}
		notifications.subscribe(this, ["sm.action.link"], 1);
	}, Base, {
		_init$Filters: function() {
			this._$filters = [];
			// Authoring on filters - none/list/tabs
			var auth = this.$filtersGetAuthoring();
			var filters = this.prototype.data("$filters");
			if (auth === "none" || !filters) {
				this._$filtersDisabled = true;
				return;
			}
			var def = false;
			for (var p in filters) {
				var ttl = this.prototype.resolveExpression(filters[p].$title);
				if (ttl) {
					var f = $.extend(true, {}, filters[p]);
					f.$title = ttl;
					f.id = p;
					def = def || f.$isDefault === true;
					this._$filters.push(f);
				}
			}
			if (this._$filters.length == 0) return;
			if (!def) {
				this._$filters[0].$isDefault = true;
			}
		},

		/**
		 *  Init sdata url - Called in constructor and page refresh
		 * 	sdataUrl is optional in case of a gadget (to see with Mathias)
		 *  Can be overridden - rowdetail
		 */
		_initSdataInfo: function(sdataUrl) {
			if (!sdataUrl) sdataUrl = this._originalSdataUrl;
			if (this.gadget) {
				var params = this.gadget.getParameters();
				if (params.where) {
					sdataUrl = sdataUtils.addWhereClause(sdataUrl, params.where, this.state.options.sdataParameters);
				}
			}
			if (!sdataUrl) throw new Error("$url (sDataUrl) is expected");
			this.state.options["sdata-url"] = this.sDataUrl = sdataUrl;
			this.sDataMethod = this.state.options["sdata-method"] || "GET";
		},

		destroy: function() {
			Base.prototype.destroy.call(this);
			this.gadget = null;
		},

		initOnLoad: function() {
			// TODO: Load filter settings
		},

		beforeAddContent: function() {
			if (false && !this.isVignette) {
				// #5583 - disabled because redundant with header title
				var ttl = this.prototype.data("$title");
				this.addTitle(globals.getApplication().getTitle() + (ttl ? " - " + ttl : ""));
			}
		},

		afterRender: function(loadOptions, buildOpts) {
			var self = this;
			Base.prototype.afterRender.call(self, loadOptions, buildOpts);
			if (!self.isVignette) {
				var diags = self.dao && self.dao.data && self.dao.data.$diagnoses;
				if (diags && diags.length > 0) {
					diags.forEach(function(diag) {
						var notify = {
							severityClass: globals.X3_SEVERITY_TO_BS[diag.$severity] || diag.$severity || "error",
							title: diag.$message
						};
						globals.getModal().notify(notify);
					});
				}
			}
		},

		/**
		 * Used by html builder to create a link to full page
		 */
		getOpenLinkAttrs: function() {
			var res = Base.prototype.getOpenLinkAttrs.call(this);
			res["data-sdata-url"] = this.sDataUrl;
			res["data-sdata-method"] = this.sDataMethod;
			res["data-gadget-id"] = this.gadget.data("$uuid");
			return res;
		},

		/**
		 * Refresh the page
		 * 	Called from a vignette or full page (callBackInterface)
		 * 	options.sdata-url -> New url
		 * 	options.controlId!=null -> refresh the control
		 *  options.type Type of refresh (pagination...)
		 *  callBackInterface
		 *  	waitStop(ctrlId) / waitStart(ctrlId)
		 */
		refresh: function(options, callBackInterface) {
			var self = this;
			options = options || {};
			var deferred = $.Deferred();
			var url = options["sdata-url"];
			var controlId = options["controlId"];
			var type = options.type || "";
			var force = type === "filtersort";
			var _wait = function(status) {
				self["waitWheel" + status.smCapitalize()].call(self, controlId);
			};
			try {
				var _succeeded = function() {
					_wait("stop");
					self.refreshControls(controlId ? [controlId] : null, options);
					deferred.resolve();
				};
				if (!url && force !== true) {
					_succeeded();
				} else {
					_wait("start");
					if (url) {
						/* url can change on refresh (paginations)*/
						self._initSdataInfo(url);
					}
					self.loadData(false, controlId)
						.then(function() {
							_succeeded();
						}).fail(function(e) {
							_wait("stop");
							deferred.reject(e);
						});
				}
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		loadData: function(loadOptions, controlId) {
			var deferred = $.Deferred();
			var self = this;
			self.offLine = false;
			var _rejectError = function(e) {
				log && log("loadData failed", e);
				deferred.reject(e);
			};
			// Force to read data in the cache to speed up rendering
			var forceUseCache = loadOptions.updateLayout;
			try {
				var dispatchOptions = {
					forceUseCache: forceUseCache
				};
				dispatcher.dispatch({
					$url: self._filterSortAllowed(false) ? self._filterSortUpdateUrl(controlId) : self.sDataUrl,
					$method: self.sDataMethod
				}, null, dispatchOptions).then(function(data) {
					if (data) {
						self.setDao(factory.createDaoSdata("representation", data, self.prototype, null));
						if (data.$cacheHint && !forceUseCache) {
							var notify = {
								severityClass: "warning",
								title: locale.text("info.network.offline.title"),
								body: locale.text("info.network.offline.outdated")
							};
							self.offLine = true;
							if (!self.isVignette) {
								globals.getModal().notify(notify);
							} else {
								// For vignettes, if they are loaded from cache, the notification is displayed only once
								// per dashboard
								var dashboardPage = globals.getApplication().currentPage;
								if (dashboardPage && dashboardPage.cachedDataNotification) {
									dashboardPage.cachedDataNotification(notify);
								} else {
									// Fallback
									globals.getModal().notify(notify);
								}
							}
						}
					} else {
						globals.getModal().actionResult("updateDao", {
							$diagnoses: [{
								$message: "NO DATA",
								$severity: "info"
							}]
						});
					}
					return deferred.resolve();
				}).fail(function(e) {
					_rejectError(e);
				});
			} catch (e) {
				_rejectError(e);
			} finally {
				return deferred.promise();
			}
		},
		/**
		 * Lookup notification
		 * 		rowData:	Selected row data
		 * 		controlId:	Id of control to refresh
		 */
		notifLookupSelection: function(rowData, controlId) {
			if (!this.isActive()) return;
			Base.prototype.notifLookupSelection.call(this, rowData, controlId);
		},
		/** Event sm.action.link
		 *  Notified when a action succeeded - sdata link - see action manager
		 *  success:	true/false
		 *  link:		Link info
		 *  result:		Json response
		 */
		notifActionLink: function(success, link, result, options) {
			var self = this;
			if (!this.isActive()) return;
			try {
				var responseJSON = result ? result.responseJSON || {} : {};
				// TODO  - scan/display field errors	
				switch (link.name) {
					case "$save":
						this._doActSave(success, link, responseJSON, options);
						break;
					case "$delete":
						globals.getApplication().goBack().always(function() {
							globals.getModal().displayActionMsg(success, link.name, self.prototype, responseJSON);
						});
						break;
					case "$canceledit":
						var autoScroll = this.getScrollValue();
						globals.getApplication().goBack().always(function(newPage) {
							if (newPage) {
								// We stay at the same location - .8 because the height of the page is less in detail than edit
								// in actionManager we also preserve scrolling when we go from edit to detail
								setTimeout(function() {
									newPage.autoScroll(autoScroll * 0.8);
								});
							}
						});
						break;
					default:
						if (link.$isAction === true && responseJSON) {
							this._myApplyChange(responseJSON);
						}
						globals.getModal().displayActionMsg(success, link.name, self.prototype, responseJSON);
						break;
				}
			} catch (e) {
				globals.getModal().error("notifActionLink failed", e);
			}
		},
		/**
		 * For right panel action we call standard applyChange that check DATA + META-DATA and refresh controls
		 * TODO - Use always this process after having removed the old _updateMeta in daoSData
		 */
		_myApplyChange: function(responseJSON) {
			this.dao.applyChange(responseJSON, {
				$isPartialDelta: false,
				$isEditMode: this.isEditMode()
			});
			var errors = this.refreshControls(null, {
				refreshValue: true
			});
			if (errors.length > 0) {
				// Set focus on the first error field
				errors[0].setFocus();
			}
			if (this._gestureMgr) {
				// We need to adjust the scroller because line can be removed -> Make content visible
				this._gestureMgr.adjust();
			}
		},
		/**
		 * Validate data before sending an action
		 */
		validateBeforeActionLink: function(link) {
			if (link && link.name === "$save") {
				return this.checkControlsData();
			}
			return true;
		},
		// Action on child pages
		_doActSave: function(success, link, responseJSON, options) {
			var self = this;
			if (success) {
				globals.getApplication().goBack().always(function() {
					// Displays diagnoses contained in response if any once the back page has been displayed
					globals.getModal().displayActionMsg(success, link.name, self.prototype, responseJSON);
				});
			} else {
				// !! We expect that input fields errors come always with success = false
				// We just update the meta to extract diagnoses
				if (self.dao.updateMeta(responseJSON)) {
					// Update controls - Display diagnoses
					var errors = self.refreshControls(null, {});
					if (errors.length > 0) {
						// Set focus on the firts error field
						errors[0].setFocus();
					}
					if (self._gestureMgr) {
						// We need to adjust the scroller because line can be removed -> Make content visible
						self._gestureMgr.adjust();
					}
				}
				if (!success && (responseJSON == null || (!responseJSON.$diagnoses || responseJSON.$diagnoses.length == 0))) {
					// Unexpected
					responseJSON.$diagnoses = [{
						$message: "Save action failed without any message",
						$severity: "error"
					}];
				}
				// Display global message
				globals.getModal().actionResult("Action: " + link.name, responseJSON);
			}
		},
		/**
		 * True if scroll enabled in page
		 * edit/detail allows scroll in vignette
		 * query/lookup doesn't allow because scroll is done by the array
		 */
		scrollAllowed: function() {
			if (this.prototype.isLookup() || this.prototype.isQuery()) {
				// This is the array which scrolls
				return false;
			}
			return true;
		},
		/**
		 * Save a rowDetail dao (childDao) into the current dao
		 */
		notifRowdetailUpdate: function(info, arrayId) {
			if (!info) return;
			var childDao = info.dao;
			if (!childDao) return;
			// singleArrayRowIdx needed for single arrays
			var array = this.getControl(arrayId);
			if (!array) return;
			var create = info.activity === "create";
			var singleArrayRowIdx;
			if (!create && array.prototype.isSingleArray()) {
				// For single arrays we added a $uuid in arrayData to manage them as other arrays
				// When we update the dao we need to retreive the index from the uuid because there's no uuid in for theses row in parent dao
				singleArrayRowIdx = array.rowId2Idx(childDao.getValue("$uuid"));
			} // If not singleArray the row will be rtreive in parent from th uuid contained in childDao
			if (childDao.updateParentRow(create, singleArrayRowIdx)) {
				var errors = this.refreshControls([arrayId], {});
				if (errors.length > 0) {
					// Set focus on the firts error field
					errors[0].setFocus();
				}
			}
			childDao.destroy();
		},
		/**
		 * Delete a row (data.uuid) in current dao - Row has been deleted by Delete footer action
		 */
		notifRowdetailDelete: function(data, arrayId) {
			if (!data || !data.uuid) return;
			var array = this.getControl(arrayId);
			if (!array) return;
			var rowidOrIdx = data.uuid;
			if (array.prototype.isSingleArray()) {
				rowidOrIdx = array.rowId2Idx(data.uuid);
			}
			// Remove the row in dao by idx or rowid 
			this.dao.deleteRow(array.$bind, rowidOrIdx);
			// Remove html identofied by uuid
			array.removeRow(data.uuid);
		},
		getPinPageId: function() {
			var self = this;
			return self.state.name + "_" + self.sDataUrl;
		},
		getPinPageData: function() {
			var self = this;
			var pageData = Base.prototype.getPinPageData.call(self);

			pageData.sDataUrl = self.sDataUrl;
			pageData.key = self.prototype.data("$key", self.dao);

			var pu = utils.parseURL(pageData.sDataUrl);
			var repr = pu.query.representation.split(".");
			pageData.representation = repr[0];
			pageData.facet = repr[1];
			pageData.action = repr[1];

			var ps = pu.path.split("/");
			pageData.entity = ps[5];
			pageData.endpoint = pu.path.split("/").slice(2, 5).join(".");

			var value = self.prototype.data("$value", self.dao);
			if (value) {
				pageData.title = self.prototype.data("$title") + " - " + value;
			}
			return pageData;
		},
		filterSortRead: function(type, ctrl) {
			if (!this._filterSortAllowed(true)) return;
			var id = this._filterInfoSaveId(type, ctrl);
			if (!this._filterSortInfo) this._filterSortInfo = {};
			var info = this._filterSortInfo[id];
			if (info) return info;
			info = sessStorage.getItem(id);
			if (info) {
				try {
					info = JSON.parse(info);
					return info;
				} catch (e) {}
			}
			return null;
		},
		filterSortWrite: function(type, info, ctrl, refresh) {
			if (!this._filterSortAllowed(true)) return;
			var id = this._filterInfoSaveId(type, ctrl);
			var save = false;
			if (info && info.length > 0) {
				var old = this.filterSortRead(type, ctrl);
				if (old == null || !this._filterSortEquals(type, info, old)) {
					save = true;
				}
			} else {
				save = info != this._filterSortInfo[id];
			}

			if (save) {
				sessStorage.setItem(id, info ? JSON.stringify(info) : null);
				this._filterSortInfo[id] = info;
				if (refresh === true) {
					this._filterSortRefresh(ctrl);
				}
			}
		},
		searchRefresh: function(ctrlArray) {
			this._filterSortRefresh(ctrlArray);
		},
		_filterSortRefresh: function(ctrlArray) {
			var attrs = {
				"data-control-id": ctrlArray.id,
				"data-nav-target": this.isVignette ? "vignette" : "application",
				"data-nav-type": "filtersort"
			};
			// Set original URL - Remove pagination - Ex we change the filter/sort criteria in a pagination 
			this._initSdataInfo(null);
			setTimeout(function() {
				eventListener.triggerRefreshPage(ctrlArray.$$elmt, attrs);
			});
		},
		/**
		 * Only for query and lookup in current version
		 */
		_filterSortAllowed: function(log) {
			return this.prototype.isLookup() || this.prototype.isQuery();
		},
		_filterInfoSaveId: function(type, ctrl) {
			if (!this._filtersortUrlId) {
				this._filtersortUrlId = this._originalSdataUrl;
			}
			var id = this._filtersortUrlId + "#" + type;
			if (this.isVignette) {
				var vid = this.state && this.state.options && this.state.options.vignetteName;
				if (vid) {
					id = vid + "#" + id;
				}
			}
			if (this.prototype.isLookup() || this.prototype.isQuery()) {
				// For isLookup and isQuery no field ID
				return id;
			}
			// Adds id for filter/sort on array fields in details pages - Not implemenred currently
			return id + '_' + ctrl.$bind;
		},

		/*
		 * Check if sort or filter has changed
		 * This is just to detect changes to trigger a page reload
		 * If e.g. sort criterias are not change, the page will not be reloaded
		 */
		_filterSortEquals: function(type, info, old) {
			if (info == null || old == null) return true;
			if (type == "sort") {
				if (old.length != info.length) return false;
				for (var i = 0; i < info.length; i++) {
					if (info[i].sort !== old[i].sort) return false;
					if (info[i].field !== old[i].field) return false;
				}
				return true;
			} else if (type == "filter") {
				// Filters are hard to compare because the can change and still be logically the same
				// So we always asume changed filter conditions here
				return false;
			}
		},
		_filterSortUpdateUrl: function(controlId) {
			var self = this;
			var sdataUrl = utils.parseURL(self.sDataUrl);
			// Add filters describe in proto - the filter is selected by the user ($isDefault === true)
			if (this.$filtersGet().length > 0 && this._$filtersDisabled != true) {
				var f = null;
				this.$filtersGet().some(function(x) {
					if (x.$isDefault === true) {
						f = x;
						return true;
					}
				});
				if (f) {
					if (!sdataUrl.query) sdataUrl.query = {};
					sdataUrl.query.filter = f.id;
				}
			}
			if (!self._filterSortAllowed(true)) return utils.urlToString(sdataUrl);
			// Add filter/sort clause for Lookup and Query if any
			// build sort clause
			var sortClause = null;
			var info = self.filterSortRead("sort");
			if (info != null && info.length != 0) {
				info.some(function(i) {
					if (i.sort != "none") {
						sortClause = {
							order: i.sort,
							field: i.id
						};
						return true;
					}
				});
			}
			// build filter clause
			var filterClause = '';
			info = self.filterSortRead("filter");
			if (info != null && info.length != 0) {
				$.each(info, function(idx, filter) {
					var cf = '(' + filter.id + ' ' + (filter.operator === "like_s" ? "like" : filter.operator) + ' ' + _setFilterRightValue(filter) + ')';
					filterClause = filterClause.length == 0 ? cf : filterClause + ' and ' + cf;
				});
			}
			var searchClause = '';
			info = controlId ? self.getControl(controlId).searchInfoGet() : null;
			if (info != null && info.length != 0) {
				$.each(info, function(idx, search) {
					var cf = '(' + search.id + ' ' + search.operator + ' ' + _setFilterRightValue(search) + ')';
					searchClause = searchClause.length == 0 ? cf : searchClause + ' or ' + cf;
				});
				if (searchClause) {
					searchClause = '(' + searchClause + ')';
				}
			}
			// apply sort clause
			if (!sortClause && !filterClause && !searchClause) return utils.urlToString(sdataUrl);;
			// sdataUrl.query.key != null means it's a pagination request
			// -> The pagination request contains already the sort criteria so we don't add them
			// -> Otherwise we add sort criteria to the request
			if (sortClause && sdataUrl.query.key == null) {
				var old = sdataUrl.query.orderBy;
				sdataUrl.query.orderBy = sortClause.field + ' ' + sortClause.order;
				if (old) sdataUrl.query.orderBy = ", " + old;
			}
			// apply filter clause
			if (filterClause && sdataUrl.query.key == null) {
				var old = sdataUrl.query.where;
				sdataUrl.query.where = filterClause;
				if (old) sdataUrl.query.where = old + ' and ' + sdataUrl.query.where;
			}

			// apply search clause
			if (searchClause && sdataUrl.query.key == null) {
				var old = sdataUrl.query.where;
				sdataUrl.query.where = searchClause;
				if (old) sdataUrl.query.where = old + ' and ' + sdataUrl.query.where;
			}

			return utils.urlToString(sdataUrl);
		},
		/**
		 * List of filters given by the prototype ($filters)
		 */
		$filtersGet: function() {
			return this._$filters;
		},
		/**
		 * Select a filter
		 */
		$filtersSelect: function(filterId, ctrlArray) {
			if (!this._$filters) return;
			this._$filtersDisabled = false;
			this._$filters.forEach(function(f) {
				f.$isDefault = false;
				if (filterId === f.id) {
					f.$isDefault = true;
				}
			});
			this._filterSortRefresh(ctrlArray);
		},
		/**
		 * none/tabs/list
		 * Stored in $resources array
		 */
		$filtersGetAuthoring: function() {
			var c = this.getControlByBind("$resources");
			if (c) {
				return c.$filtersGetAuthoring();
			}
			return null;
		},
		setDao: function(dao) {
			Base.prototype.setDao.call(this, dao);
			this._multiSelectionLinks = this._protoLinks = this._toolbarLinks = null;
		},
		getMultiSelectionLinks: function() {
			var self = this;
			if (!self.prototype.isQuery()) return null;
			if (self._multiSelectionLinks == null) {
				self._multiSelectionLinks = [];
				var $links = self.getProtoLinks(),
					info, link;
				if ($links) {
					$.each($links, function(name, value) {
						if (value == null || value.$isExcluded === true || name.smStartsWith('$')) {
							return;
						}
						if (value.$url == null || value.$url.length == 0) {
							return;
						}
						info = $.extend({}, link, value);
						info.css = (info.css || "") + " s-m-ismultisel";
						self._multiSelectionLinks.push(info);
					});
				}
			}
			return self._multiSelectionLinks.length == 0 ? null : self._multiSelectionLinks;
		},
		/**
		 * Accept getProtoLinks("$query", $details"...)
		 */
		getProtoLinks: function() {
			var self = this;
			if (self._protoLinks == null) {
				var $links = $.extend(true, {}, self.prototype.data("$links", null, true), self.dao ? self.dao.getValue("$links") : null);
				self._protoLinks = {};
				var info, sdataInfo;
				$.each($links, function(name, info) {
					if (info == null || info.$isExcluded === true) {
						return;
					}
					if (_isPaginLink(name)) {
						return;
					}
					if (name.smStartsWith('$') && _isOfficeLink(name)) {
						return;
					}

					info.name = name;
					info.title = info.$title ? self.prototype.resolveExpression(info.$title) : "";
					info.icon = fontUtils.getIconByName(name);
					if (info.$type == null || info.$type.length !== 0 || info.$type === "application/json;vnd.sage=syracuse") {
						if (info.$url) {
							var urlParsed = self.prototype.resolveExpression(info.$url);
							if (urlParsed.indexOf("/mobile1/") > -1) { // mobile1 means it's an sdata request
								sdataInfo = sdataUtils.getLinkInfo(info.$url, self.dao, true);
								if (!sdataInfo) return;
								$.extend(info, sdataInfo);
								if (info.$services) {
									info.$isAction = true;
								}
							} else {
								// Free type link (for maps)
								info.externalUrl = info.$url;
							}
						} else {
							// Force notification
							info.$isAction = true;
						}
						if (info.$uuid == null) {
							info.$uuid = utils.UUID();
						}
						info.css = info.css || [];
						if (info.$isHidden === true) info.css.push("hidden");
						if (info.$isDisabled === true) info.css.push("disabled");
						info.css = info.css.join(' ');
						self._protoLinks[name] = info;
						return;
					}
				});
			}
			if (arguments.length == 0) {
				return $.isEmptyObject(self._protoLinks) ? null : self._protoLinks;
			}
			var res;
			for (var i = 0; i < arguments.length; i++) {
				if (self._protoLinks[arguments[i]]) {
					if (res == null) res = {};
					res[arguments[i]] = self._protoLinks[arguments[i]];
				}
			}
			return res;

		},
		/**
		 * Return an array of link info according to toolbar
		 *		toolbar - can be "header", "footer", "actionpanel"
		 * !!! There's a hack in \lib\sdataStatelessHack._js that transform the original proto to put $actions in $links
		 * 		Set a $isAction = true for actions (false for $links)
		 */
		getToolbarLinks: function(toolbar) {
			var self = this;
			if (!self.dao) {
				// non regular pages
				return [];
			}
			if (self._toolbarLinks == null) self._toolbarLinks = {};
			var device = globals.getSiteLayout().getDeviceType();
			var facet = self.dao.prototype.getFacet();
			var key = toolbar + device + facet;
			if (self._toolbarLinks[key]) return self._toolbarLinks[key];
			var links = self._toolbarLinks[key] = [];
			var $links = self.getProtoLinks();
			if ($links) {
				var lMap = _getLinkMap(toolbar, device, facet);
				$.each($links, function(name, value) {
					if (toolbar !== "actionpanel" && !lMap[name]) {
						return;
					}
					// in case of action panel, do not add facet links. They are added with 'actionpanelparent' if needed
					if (toolbar === "actionpanel" && (name === "$edit" || name === "$create" || name === "$delete" || name === "$details" || name === "$query" || name === "$save" || name === "$canceledit")) {
						return;
					}
					links.push(value);
				});
			}
			return links;
		}
	});

exports.Page = _Page;
});

define('syracuse-tablet/html/js/pages/pageRowDetail',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/pages/pageRegular'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/pages/pageRegular').Page;

/**
 * Child page that displays row detail in edit and details mode
 */
var _Page = utils.defineClass(
	function($parent, state, prototype, article, parentPage, options) {
		this.parentPage = parentPage;
		if (this.parentPage.state.type === "rowdetail") {
			this.mainPageId = this.parentPage.mainPageId;
		} else {
			this.mainPageId = this.parentPage.state.uuid;
		}
		if (!this.parentPage) throw new Error("rowdetail page - Unexpected empty parent page");
		/** Set parentpage before **/
		Base.call(this, $parent, state, prototype, article, options);
		// Activity and facet - This page has no url
		this.setActivity(this.parentPage.$activity);
	}, Base, {

		_initSdataInfo: function(sdataUrl, sdataMethod) {
			// nothing no sdataUrl
		},

		destroy: function() {
			Base.prototype.destroy.call(this);
			this.parentPage = null;
			this._notifData = null;
		},

		isEditMode: function() {
			return this.parentPage && this.parentPage.isEditMode();
		},
		/**
		 *  Modify title for dvlp tests
		 */
		buildHtmlOption: function(loadOptions) {
			return Base.prototype.buildHtmlOption.call(this, loadOptions).
			then(function(opts) {
				opts.toolBars.showHome = true;
				return opts;
			});
		},
		/**
		 * Click on home in footer/header
		 * -> Goto main parent page
		 */
		_actHome: function() {
			var self = this;
			if (!self.parentPage) return;
			globals.getApplication().goBack(function(state) {
				return state.uuid === self.mainPageId;
			});
		},

		/**
		 * this.state.options.dataParams is an object that gives:
		 * 	rowId:	id of the row - empty if creation
		 *  activity:	"create/edit/detail" if it's a creation
		 */
		loadData: function(loadOptions) {
			// We get the row DAO - !!! Do not store parentPage
			var ctrl = this.parentPage.getControl(this.state.options.controlId);
			if (!ctrl) throw new Error("rowdetail page - Array datasource not found");
			// Dao of the row to display - dao is calculated by the array when user click on action 'rosDetail'
			var info = ctrl.rowDetailGetInfo();
			var rowDao = info.dao;
			if (!rowDao) throw new Error("rowdetail page - Row data not found");
			this.setDao(rowDao);
			// create/edit/read
			this.setActivity(info.activity);
			// For single arrays we need idx to update parent on save  because there's no uuid in dao
			this.singleArrayRowIdx = info.singleArrayRowIdx;
			return $.smResolve();
		},
		/**
		 * Process action
		 */
		notifActionLink: function(success, link, result, options) {
			try {
				switch (link.name) {
					case "$save":
						this._doActSave(success, link, options);
						break;
					case "$delete":
						this._doActDelete(success, link, options);
						break;
					case "$canceledit":
						globals.getApplication().goBack();
						break;
					default:
						globals.getModal().displayActionMsg(success, link.name);
						break;
				}
			} catch (e) {
				globals.getModal().error("notifActionLink failed", e);
			}
		},
		_doActSave: function(success, link, responseJSON, options) {
			if (success) {
				// Check if the row is still in error - If we change the value of a field in error it resets the error status
				this.dao.checkArrayUpdateError();
				// Notify parent to update its dao
				this._notifData = {
					notifId: "sm.rowdetail.update",
					notifData: {
						dao: this.dao,
						activity: this.$activity,
						singleArrayRowIdx: this.singleArrayRowIdx
					}
				};
				// To not destroy it - no need to clone
				this.dao = null;
				globals.getApplication().goBack();
			}
		},
		_doActDelete: function(success, link, responseJSON, options) {
			// Stores data for parent which will be notified before closing the child page
			this._notifData = {
				notifId: "sm.rowdetail.delete",
				notifData: {
					uuid: this.dao.getValue("$uuid")
				}
			};
			globals.getApplication().goBack();
		},
		/**
		 * Return data for parent
		 */
		getParentNotif: function() {
			if (this._notifData) {
				//ID of parent page
				this._notifData.parentId = this.state.options.parentId;
				// Notify parent to update its dao
				this._notifData.controlId = this.state.options.controlId;
				return this._notifData;
			}
		},

	});

exports.Page = _Page;
});

define('syracuse-tablet/html/js/helpers/deltaManager',['require','exports','module'],function (require, exports, module) {


function _isVariantArray(list) {
	var first = list && list.length > 0 ? list[0] : null;
	if (first) {
		if (first.$uuid == undefined) {
			if (typeof(first) == 'object' && Object.keys(first).length == 1) {
				return true;
			}
		}
	}
	return false;
}

function _ensureServerIndex(list) {
	if (_isVariantArray(list)) {
		for (var ii = 0, jj = list.length; ii < jj; ii++) {
			var record = list[ii];
			if (typeof(record) == 'object') {
				record[Object.keys(record)[0]].$serverIndex = ii;
			}
		}
	} else {
		if (list.length && typeof(list[0]) == 'object' && list[0].$uuid !== undefined) {
			for (var ii = 0, jj = list.length; ii < jj; ii++) {
				list[ii].$serverIndex = ii;
			}
		}
	}
}

function _applyPageRecordDelta(options, record, subRecord, targetMap, targetList, variantKey) {
	if (subRecord.$uuid !== undefined) {
		if (!subRecord.$isDeleted) {
			if ((subRecord.$uuid !== undefined) && targetMap[subRecord.$uuid]) {
				if (variantKey) {
					var newNecord = _applyObjectDelta(options, targetMap[subRecord.$uuid], subRecord);
					record = {};
					record[variantKey] = newNecord;
					targetList.push(record);
				} else {
					targetList.push(_applyObjectDelta(options, targetMap[subRecord.$uuid], subRecord));
				}
			} else {
				targetList.push(record);
			}
		}
	} else {
		targetList.push(record);
	}
}

function _applyObjectArrayDelta(options, targetList, sourceList) {
	if (sourceList) {
		if (targetList.length == sourceList.length) {
			for (var ii = 0, jj = sourceList.length; ii < jj; ii++) {
				_applyObjectDelta(options, targetList[ii], sourceList[ii]);
			}
		} else {
			targetList.splice(0, targetList.length);
			for (var ii = 0, jj = sourceList.length; ii < jj; ii++) {
				targetList.push(sourceList[ii]);
			}
		}
	}
	return targetList;
}

function _applyObjectDelta(options, target, source, isObjectDelta) {
	options = options || {};
	if (source) {
		var properties = Object.keys(source);
		var isData;
		for (var ii = 0, jj = properties.length; ii < jj; ii++) {
			var property = properties[ii];
			isData = property.charAt(0) != "$";
			var targetValue = target[property];
			var sourceValue = source[property];
			if (typeof(sourceValue) == 'object') {
				if (!(targetValue == null || sourceValue === null)) {
					if (Array.isArray(sourceValue)) {
						// isData: applyPageArrayDelta only for data not for meta-data
						if (isObjectDelta || !isData) {
							sourceValue = _applyObjectArrayDelta(options, targetValue, sourceValue);
						} else {
							if (options.$isEditMode || options.$isPartialDelta) {
								// applyPageArrayDelta update the targetValue by comparison of $uuids
								sourceValue = exports.applyPageArrayDelta(options, targetValue, sourceValue);
							}
						}
					} else {
						sourceValue = _applyObjectDelta(options, targetValue, sourceValue, isObjectDelta);
					}
				}
				if (Array.isArray(sourceValue) && isData) {
					_ensureServerIndex(sourceValue);
				}
			}
			target[property] = sourceValue;
		}
	}
	return target;
}


exports.cleanServerIndex = function(source) {
	if (source && (typeof(source) == 'object')) {
		if (Array.isArray(source)) {
			for (var ii = 0, jj = source.length; ii < jj; ii++) {
				exports.cleanServerIndex(source[ii]);
			}
		} else {
			delete source.$serverIndex;
			var properties = Object.keys(source);
			for (var ii = 0, jj = properties.length; ii < jj; ii++) {
				exports.cleanServerIndex(source[properties[ii]]);
			}
		}
	}
	return source;
};

exports.applyObjectDelta = _applyObjectDelta;

exports.applyPageArrayDelta = function(options, targetList, sourceList) {
	options = options || {};
	if (sourceList) {
		var targetMap = {};
		var isVariant = _isVariantArray(sourceList);
		if (options.$isPartialDelta || (sourceList.length == 1 && sourceList[0].$index !== undefined)) {
			var found, foundIndex;
			for (var ii = 0, jj = sourceList.length; ii < jj; ii++) {
				found = null;
				var sourceRecord = sourceList[ii];
				foundIndex = 0;
				for (var mm = targetList.length; foundIndex < mm; foundIndex++) {
					found = targetList[foundIndex];
					if (found.$uuid == sourceRecord.$uuid) {
						break;
					} else {
						found = null;
					}
				}
				if (found) {
					if (sourceRecord.$isDeleted) {
						targetList.splice(foundIndex, 1);
					} else {
						_applyObjectDelta(options, found, sourceRecord);
						if (sourceRecord.$index !== undefined && sourceRecord.$index != foundIndex) {
							targetList.splice(foundIndex, 1);
							targetList.splice(sourceRecord.$index, 0, found);
							delete found.$index;
						}
					}
				} else {
					if (!sourceRecord.$isDeleted) {
						if (sourceRecord.$index !== undefined) {
							targetList.splice(sourceRecord.$index, 0, sourceRecord);
						} else {
							targetList.push(sourceRecord);
						}
					}
				}
			}
		} else {
			for (var ii = 0, jj = targetList.length; ii < jj; ii++) {
				var record = targetList[ii];
				if (record) {
					if (record.$uuid !== undefined) {
						targetMap[record.$uuid] = record;
					} else {
						if (isVariant) {
							record = record[Object.keys(record)[0]];
							if (record.$uuid !== undefined) {
								targetMap[record.$uuid] = record;
							}
						}
					}

				}
			}
			targetList = [];
			for (var ii = 0, jj = sourceList.length; ii < jj; ii++) {
				var record = sourceList[ii];
				if (isVariant) {
					var variantKey = Object.keys(record)[0];
					_applyPageRecordDelta(options, record, record[variantKey], targetMap, targetList, variantKey);
				} else {
					_applyPageRecordDelta(options, record, record, targetMap, targetList);
				}

			}
		}
	}
	return targetList;
};
});

define('syracuse-tablet/html/js/application/daoSdata',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/articleParser','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/deltaManager'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var deltaManager = require('syracuse-tablet/html/js/helpers/deltaManager');


var _defMetaData = {
	$properties: {
		"$isExcluded": false,
		"$isHidden": false,
		"$isMandatory": false,
		"$isReadOnly": false,
		"$isDisabled": false,
		"$diagnoses": null,
		"$x3Format": null,
		"$value": null,
		"$format": null,
		"$capabilities": null
	},
	$links: {
		"$isDisabled": false,
		"$isHidden": false,
		"$style": false,
		"$isRequested": false
	}
};
/**
 * Recursive update of meta-data
 */
var _updt = function(src, dst) {
	var m = {}, j;
	for (var p in _defMetaData) {
		j = src[p];
		if (j && !$.isEmptyObject(j)) m[p] = j;
	}
	if (!$.isEmptyObject(m)) {
		$.extend(dst, m);
		return m;
	}
	return null;
};
var _updateMeta = function(fromData, toData, properties, isRowData) {
	if (!fromData || !toData) return false;
	var meta = _updt(fromData, toData);
	if (isRowData == true && meta && meta.$properties) {
		// We need to update the parent that there's a child on error 
		// If there's an error in a nested array we need to display the row in error at the first level
		for (var p in meta.$properties) {
			if (meta.$properties[p].$diagnoses != null) {
				toData.$arrayUpdateError = true;
				break;
			}
		}
	}
	var done = meta != null;
	if (properties) {
		for (var name in properties) {
			var proto = properties[name];
			if (proto && proto.$type === "application/x-array" && fromData[name]) {
				if (!articleParser.isSingleArray(proto)) {
					var arrSrc = fromData[name];
					var arrDst = toData[name];
					if (!arrDst) throw new Error("Unexpected empty data array - " + name);
					for (var idx = 0; idx < arrSrc.length && idx < arrDst.length; idx++) {
						// _updateMeta first
						var rowData = arrDst[idx];
						meta = _updateMeta(arrSrc[idx], rowData, proto.$item.$properties, true);
						if (rowData.$arrayUpdateError && isRowData) {
							toData.$arrayUpdateError = true;
						}
						done = meta != null || done;
					}
				} else if (proto.$item.$type === "application/x-reference") {
					// meta of x-reference single arrays are sent in data			
					var arrSrc = fromData[name];
					var arrDst = toData[name];
					var dst, src;
					for (var idx = 0; idx < arrSrc.length && idx < arrDst.length; idx++) {
						dst = arrDst[idx];
						src = arrSrc[idx];
						for (var p in _defMetaData.$properties) {
							if (src && src[p] != null) {
								dst[p] = src[p];
							} else if (proto.$item[p] != null) {
								dst[p] = proto.$item[p];
							} else {
								dst[p] = _defMetaData.$properties[p];
							}
						}
					}
				}
			}
		}
	}
	return done;
};

var _typeDefValue = function(prop) {
	switch (prop.$type) {
		case "application/x-password":
		case "application/x-string":
			return "";
		case "application/x-quantity":
			return 0.0;
		case "application/x-decimal":
		case "application/x-real":
			return 0.0;
		case "application/x-integer":
			return 0;
		case "application/x-boolean":
			return false;
		case "application/x-date":
			return '';
		case "application/x-datetime":
			return '';
		case "application/x-time":
			return '';
		case "application/x-choice":
			return prop.$value.$enum[0].$value;
		case "application/x-reference":
			return {
				$value: "",
				$description: "",
				$title: ""
			};
		case "application/x-array":
			return [];
		default:
			return null;
	}
};
var _dataProps = ["$isMandatory", "$isReadOnly", "$isHidden", "$isExcluded", "$isDisabled", "$actions", "$format"];
var _proto2Instance = function(protoArray) {
	var res;
	if (protoArray.isSingleArray()) {
		res = {
			$properties: {
				"~data~": ""
			}
		};
	} else {
		res = {
			$properties: {}
		};
		var props = protoArray.getDataByPath("$item.$properties");
		for (var propName in props) {
			if (!propName.smStartsWith("$")) {
				var prop = props[propName];
				res[propName] = _typeDefValue(prop);
				var $properties = res.$properties[propName] = {};
				_dataProps.forEach(function(p) {
					if (prop[p] != null) {
						$properties[p] = prop[p];
					}
				});
			}
		}
	}
	return res;
};
var _getArrayEmptyRow = function(array, proto, bind, parentDao) {
	var rsrc;
	if (false && proto.isSingleArray()) {
		rsrc = _proto2Instance(proto);
	} else {
		rsrc = _proto2Instance(proto);
		rsrc.$uuid = utils.UUID();
	}
	// We path pathBind as $bind in empty dao to be able to retrieve the full path of prototype in nested arrays
	return new _Dao(rsrc, _getProtoRowDetail(array, proto), parentDao, bind);
};
var _getProtoRowDetail = function(array, proto) {
	var protoJson = {
		$url: "",
		$typ: "rowdetail",
		$links: {}
	};
	// add $links
	if (array.controller.isEditMode()) {
		protoJson.$links.$save = {
			"$title": locale.text("array.links.save")
		};
		// TODO - delete is always possible in rowDetail - for tests
		if (true || array.controller.prototype.getDataByPath("$links.$delete")) {
			protoJson.$links.$delete = {
				"$title": locale.text("array.links.delete"),
				"$confirm": locale.text("actions.del.confirm")
			};
		}
	}
	protoJson.$title = proto.data("$title");
	if (proto.isSingleArray()) {
		var p = $.extend({}, proto.getDataByPath("$item"));
		p.$isMandatory = true;
		p.$isReadOnly = p.$isHidden = p.$isDisabled = false;
		protoJson.$properties = {
			"~data~": p
		};
		return proto.create(protoJson);
	} else {
		return proto.getPrototype("$item", protoJson, array.prototype.getFacet());
	}
};
var _getProtoCardDesign = function(array) {
	var proto = array.prototype;
	var protoJson = {
		$url: "",
		$typ: "carddesign",
		$links: {}
	};
	if (proto.isSingleArray()) {
		throw new Error("No card design for single array");
	} else {
		proto = proto.getPrototype("$item", protoJson, "details");
		var props = proto.data("$properties");
		Object.keys(props).forEach(function(key) {
			props[key].$isHidden = false;
		});
		return proto;
	}
};
/**
 * Class that manages access to sdata data structure
 *  	data: 		JOSN data
 *  	prototype: 	Prototype
 *  	parent:		Parent DAO (see getPrototype)
 *  	$bind		For a child it's the name of the field from which dao has bee created
 * Manages DAO chaining parent -> child
 * !!use DAO methods instead of dealing directly with JSON
 */
var _Dao = utils.defineClass(function(data, prototype, parent, $bind) {
	var self = this;
	self.$bind = $bind || "";
	self.data = data || {};
	if (!prototype) throw new Error("Prototype is mandatory");
	if (!data) throw new Error("jsonData is mandatory");
	self.prototype = prototype;
	self.resetCache();
	self.parent = parent;
	if (!parent) {
		self._creationDate = new Date();
	}
}, null, {

	destroy: function() {
		var self = this;
		self.parent = null;
		self.data = null;
		self.prototype = null;
	},
	resetCache: function() {
		this._cache = {
			metaData: {},
			queryData: null
		};
	},
	/**
	 * Set field's value
	 * For x-reference fields value can be a string or an object {$value,$description, $title}
	 */
	setValue: function(name, value, notify) {
		var done = false;
		var curVal = this.data[name];
		if (this.prototype.isReference(name)) {
			var valName = this.prototype.getFieldNameForValue(name);
			if (valName !== name) {
				// X3 entities 
				var strVal;
				if (typeof value === "object") {
					strVal = value.$value || "";
				} else {
					strVal = value + "";
				}
				if (strVal != this.data[valName]) {
					// Reset value
					this.data[name] = curVal = {};
					// Set field value
					this.data[valName] = strVal;
					// Set value
					if (strVal === value) {
						// value is a string - TODO remove all other properties??
						curVal.$value = strVal;
					} else {
						// set _REF value/descr/ttl to allow refresh of all fields data
						for (var p in value) {
							curVal[p] = value[p];
						}
					}
					// for ref fields in single arrays we've to set this value {$value:"ASN", FCY:"ASN"}
					curVal[valName] = strVal;
					done = true;
				}
			} else if (curVal == null || curVal.$value != value) {
				throw new Error("Syracuse entities - x-refrence setValue not implemented");
			}
		} else if (curVal == null || curVal !== value) {
			if (false && !this.prototype.isBlob(name) && typeof curVal === "object") {
				throw new Error("daoSdata.setValue - Unexpected Object value for " + name);
			}
			this.data[name] = value;
			done = true;
		}
		if (done && notify === true) {
			notifications.publish('sm.dao.updated', this, name, value);
		}
		return done;
	},
	/**
	 * Get field's value
	 * searchInParents should be equals to true - remove it if not used
	 */
	getValue: function(name, defValue, searchInParents) {
		if (!name || name.length === 0) return defValue;
		var val = this.data[name];
		if (val != null && this.prototype.isReference(name) && typeof val === "object" && val.$value == null) {
			// Add $value in value with the value of the linked field 
			var nameValue = this.prototype.getFieldNameForValue(name);
			if (nameValue != name) {
				val.$value = this.getValue(nameValue, defValue);
			} else {
				val.$value = val;
			}
			return val;
		}
		if (val != null) return val;
		if (searchInParents && val == null && this.parent) {
			var pVal = this.parent.getValue(name, defValue, searchInParents);
			val = pVal;
		}
		return val != null ? val : defValue;
	},
	/**
	 * Return the 'type' meta-data
	 * 	type		$properties for fields
	 * 				$links for actions
	 *  propName 	Name of the field for type = $properties
	 */
	getMetaData: function(type, propName) {
		if (!type) throw new Error("getMetaData - type expected");
		if (propName == null) return;
		/* NOTE: #6097 For Reference fields, meta data like $isHidden is set on e.g. CRY_REF NOT on CRY so there must be NO mapping from CRY_REF->CRY
		 */
		var protoPropName = propName;
		if (type === "$properties" && this.prototype.isReference(propName)) {
			propName = this.prototype.getFieldNameForValue(propName);
		}

		var meta = this._cache.metaData[type];
		if (meta) {
			if (propName == null) return meta;
			if (propName != null && meta[propName] != null) return meta[propName];
			meta = meta[propName] = {};
		} else {
			meta = this._cache.metaData[type] = {};
			if (propName != null) meta = meta[propName] = {};
		}
		var proto = this.prototype.data(type);
		if (proto && propName != null) proto = proto[protoPropName];
		var data = this.data[type];
		if (data && propName != null) data = data[propName];
		var props = _defMetaData[type];
		if (!props) throw new Error("getMetaData - unexpected type[" + type + "]");
		for (var p in props) {
			if (data && data[p] != null) {
				meta[p] = data[p];
				continue;
			} else if (proto && proto[p] != null) {
				meta[p] = proto[p];
			} else {
				meta[p] = props[p];
			}
		}
		return meta;
	},
	/**
	 * Fields $diagnoses are removed after having being displayed
	 */
	removeMetaDiagnoses: function(fieldName) {
		if (this.prototype.isReference(fieldName)) {
			fieldName = this.prototype.getFieldNameForValue(fieldName);
		}
		[this.data, this._cache.metaData].forEach(function(data) {
			var meta = data.$properties;
			if (meta && meta[fieldName]) meta[fieldName]["$diagnoses"] = undefined;
		});
	},
	getFieldInfo: function(name) {
		return {
			meta: this.getMetaData(),
			value: this.getValue()
		};
	},
	/**
	 * current proto is controller's proto
	 * name: array field name
	 * protoArray: prototype of array field
	 * Returns Array field data
	 * 	$resources an array of dao per row
	 *  No server pagination for array field in Syracuse
	 */
	getArrayData: function($bind, protoArray) {
		var self = this;
		var res = {
			$resources: [],
		};
		var rsrcs = self.getValue($bind) || [];
		if (protoArray.isSingleArray()) {
			// $resources contains an array of single type $resource:[2,6,8,9], $resources:[{$description:,$title:,FCY:},{$description:,$title:,FCY:}]
			// We create the same field structure as multiple columns arrays with a hard coded field name SINGLEARRAYPROP {$data:1} {$data:{$description:,$title:,FCY:}}
			rsrcs.forEach(function(rsrc) {
				var data = {};
				data[globals.SINGLEARRAYPROP] = rsrc;
				// We add an uuid for compliance with other array - used for crud
				data.$uuid = utils.UUID();
				var proto = protoArray.getPrototype("$item");
				if (proto.property(globals.SINGLEARRAYPROP).$type === "application/x-reference") {
					// THIS METHOD IS BETTER THAN THE ONE OF  getValue BECAUSE IT'S COMPLIANT WITH LINKS
					// If it's a single array of x-reference we need to add the value ($refValue) calculated by prototype.getFieldNameForValue
					// Example below  for field FCY_REF -> $refValue = FCY
					//{
					//  	$data:{ $description: "Site AA2 long", $title: "Site AA2", FCY: "AA2"},
					//-->	FCY: "AA2"
					//}
					// TODO - test with Syracuse entities
					var valFld = proto.getFieldNameForValue(globals.SINGLEARRAYPROP);
					if (valFld) data[valFld] = rsrc[valFld];
				}
				res.$resources.push(new _Dao(data, proto, self, $bind));
			});
		} else {
			// Fix the display of values in arrays - !! dependencies with builderTable._getOtherColProto
			var protoRow = protoArray.getPrototype("$item");
			rsrcs.forEach(function(rsrc) {
				res.$resources.push(new _Dao(rsrc, protoRow, self, $bind));
			});
		}
		return res;
	},
	/**
	 * Returns query info
	 * 	Pagination info : 	$itemsPerPage $links
	 * 	Data : 				$resources an array of dao per row
	 *
	 */
	getQueryData: function(protoArray) {
		var self = this;
		var res = {
			$itemsPerPage: self.getValue("$itemsPerPage"),
			$resources: [],
			$links: self.getValue("$links")
		};
		if (!protoArray) throw new Error("getQueryData - Prototype Array is mandatory");
		var rowProto = protoArray.getPrototype("$item");
		var $bind = "$resources";
		var rsrcs = self.getValue($bind);
		if (rsrcs) {
			rsrcs.forEach(function(rsrc) {
				res.$resources.push(new _Dao(rsrc, rowProto, self, $bind));
			});
		}
		return res;
	},
	/**
	 * Lookup info
	 */
	getLookupData: function(protoArray) {
		return this.getQueryData(protoArray);
	},
	getQueryResources: function() {
		return this.getValue("$resources") || [];
	},
	/* Resolve expression according to current dataset and prototype*/
	parseExpression: function(expression) {
		return utils.parseExpression(expression, this, this.prototype);
	},
	/**
	 * Set row index for arrays
	 */
	setRowIndex: function(value) {
		this.setValue(globals.ROWIDXPROP, value, false);
	},
	/**
	 * return action's payload
	 * $method: "POST"
	 * $url: "{$baseUrl}/AQMDEVICE?representation=AQMCRUDM.$create"
	 * $uuid: "6cdcb613-323f-495d-8a29-f54efad77f53"
	 * name: "$save"
	 * page: "x3.erp.SUPERV.AQMCRUDM.$create"
	 * sdataurl: "/sdata/x3/erp/SUPERV/AQMDEVICE?representation=AQMCRUDM.$create"
	 */
	getActionPayload: function(link) {
		var self = this;
		var payload;
		switch (link.name) {
			case "$save":
			case "$edit":
				// TODO - Eventually remove unused properties
				payload = $.extend({}, this.data);
				break;
			default:
				payload = null;
				break;
		}
		$.each(link.$parameters || [], function(name, value) {
			payload = payload || {};
			payload.$parameters = payload.$parameters || {};
			payload.$parameters[name] = self.parseExpression(value);
		});
		return payload;
	},
	clone: function() {
		return new _Dao($.extend(true, {}, this.data), this.prototype, this.parent, this.$bind);
	},
	/**
	 * Merge dao with json (json is by example the result of an action)
	 * We take into account the meta $properties and $links
	 * -> It's work only with meta - Should be replaced by applyChange
	 * retuns true if meta to refresh
	 */
	updateMeta: function(src) {
		if (!src) return;
		this.resetCache();
		var res = _updateMeta(src, this.data, this.prototype.data("$properties"));
		return res;
	},
	/**
	 * Update the parent dao - used by child pages
	 * Retrun true if change has been detected
	 * create				add new row
	 * singleArrayRowIdx	index of row for singleArrayRowIdx because no $uuid
	 */
	updateParentRow: function(create, singleArrayRowIdx) {
		if (!this.parent || !this.data || $.isEmptyObject(this.data)) return false;
		var id = this.data.$uuid;
		var grid = this.parent.data[this.$bind];
		if (!grid) {
			if (!create) return false;
			grid = this.parent.data[this.$bind] = [];
		}
		var single = this.prototype.isSingleArray();
		if (create) {
			var newdata = single ? this.data[globals.SINGLEARRAYPROP] : this.data;
			grid.push($.isPlainObject(newdata) ? $.extend({}, newdata) : newdata);
		} else {
			var idx = -1;
			var newdata = this.data;
			if (single) {
				// in single arrays there's no uuid
				if (grid.length > singleArrayRowIdx) idx = singleArrayRowIdx;
				if (idx < 0) return false;
				// In signle arrays we manage data in SINGLEARRAYPROP field for compliance with other arrays
				newdata = this.data[globals.SINGLEARRAYPROP];
			} else {
				grid.some(function(r, i) {
					if (r.$uuid == id) {
						idx = i;
						return true;
					}
				});
				if (idx < 0) return false;
			}
			if (utils.areEqual(newdata, grid[idx])) return false;
			grid[idx] = $.isPlainObject(newdata) ? $.extend({}, newdata) : newdata;
		}
		return true;
	},
	/**
	 * Delete a row
	 * 	isSingleArray		> rowidoridx is the index beacuse there's no uuid in data
	 * 	not isSingleArray	-> rowidoridx is the uuid
	 */
	deleteRow: function(field, rowidoridx) {
		var grid = this.data[field];
		if (!grid) return false;
		var idx = -1;
		if (this.prototype.isSingleArray(false, field)) {
			rowidoridx = parseInt(rowidoridx, 10);
			// in single arrays there's no uuid
			if (grid.length > rowidoridx) idx = rowidoridx;
		} else {
			grid.some(function(r, i) {
				if (r.$uuid == rowidoridx) {
					idx = i;
					return true;
				}
			});
		}
		if (idx < 0) return false;
		grid.splice(idx, 1);
		return true;
	},
	/**
	 * Called when we save a rowDetail page
	 * If the dao has errors it keeps error status ($arrayUpdateError) at true
	 * If no error it sets $arrayUpdateError to false
	 * If we save a representation with nested arrays and have an error in the last level the parent lines are shown with errors (red border)
	 * If we change the value in error we clear the error
	 * If no error remains we have to remove the error status ($arrayUpdateError) in parent lines
	 */
	checkArrayUpdateError: function() {
		var d = this.data,
			errors = false;
		if (d.$properties) {
			// check diagnoes in fields
			for (var p in d.$properties) {
				if (p.$diagnoses && p.$diagnoses.length > 0) {
					errors = true;
					break;
				}
			}
		}
		if (!errors) {
			// check error status ($arrayUpdateError) in array fields lines
			var props = this.prototype.data("$properties") || {};
			for (var p in props) {
				if (props[p].$type === "application/x-array" && this.data[p] && this.data[p].some(function(r) {
					if (r.$arrayUpdateError) return true;
				})) {
					errors = true;
					break;
				}
			}
		}
		if (!errors) {
			// If no error found reser error status to not display the red border for this row
			d.$arrayUpdateError = false;
		}
	},
	/**
	 * This is the method we shoudl call to update data + metat data
	 * It uses Daniels's deltaManager
	 * TODO - Re-implement the management of data/meta-data like in desktop client
	 */
	applyChange: function(newData, opts) {
		if (!newData) newData = {};
		this.resetCache();
		if (!opts) opts = {};
		if (opts.$isPartialDelta == null) opts.$isPartialDelta = true;
		if (opts.$isEditMode == null) opts.$isEditMode = true;
		//console.log("BEFORE", JSON.stringify(this.data, null, 2));
		deltaManager.applyObjectDelta(opts, this.data, newData);
		//console.log("AFTER", JSON.stringify(this.data, null, 2));
	},
	replaceData: function(newData) {
		if (!newData) newData = {};
		this.resetCache();
		this.data = newData;
	},
	isValid: function() {
		return this.prototype != null && this.data != null && this.prototype.isValid();
	},
	expired: function(timeout) {
		var creDate, dao = this;
		while (dao != null && ((creDate = dao._creationDate) != null)) {
			dao = this.parent;
		}
		if (!creDate) return false;
		return (new Date().getTime() - creDate.getTime()) > timeout;
	}
});
// for override only
exports.Dao = _Dao;
exports.emptyDao = function(prototype, parent) {
	return new _Dao({
		$properties: {}
	}, prototype, parent);
};
exports.getArrayEmptyRow = _getArrayEmptyRow;
exports.getProtoRowDetail = _getProtoRowDetail;
exports.getProtoCardDesign = _getProtoCardDesign;
});

define('syracuse-tablet/html/js/pages/pageCardDesign',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/pages/pageRegular','syracuse-tablet/html/js/application/daoSdata'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/pages/pageRegular').Page;
var daoSdata = require('syracuse-tablet/html/js/application/daoSdata');

/**
 * Child page that displays card detail for design
 */
var _Page = utils.defineClass(
	function PageCardDesign($parent, state, prototype, article, parentPage, options) {
		options.header = false;
		options.footer = false;
		if (!parentPage) throw new Error("carddesign page - Unexpected empty parent page");
		this.parentPage = parentPage;
		Base.call(this, $parent, state, prototype, article, options);
	}, Base, {

		_initSdataInfo: function(sdataUrl, sdataMethod) {
			// nothing no sdataUrl
		},

		destroy: function() {
			Base.prototype.destroy.call(this);
			this.parentPage = null;
			this._notifData = null;
		},
		buildHtmlOption: function(loadOptions) {
			return Base.prototype.buildHtmlOption.call(this, loadOptions).
			then(function(opts) {
				opts.toolBars.showHome = true;
				opts.cardDesign = true;
				return opts;
			});
		},
		isEditMode: function() {
			return false;
		},

		loadData: function(loadOptions) {
			// We get the row DAO - !!! Do not store parentPage
			var ctrl = this.parentPage.getControl(this.state.options.controlId);
			if (!ctrl) throw new Error("cardDesign page - Array datasource not found");
			var dao;
			if (ctrl.getArrayData() && ctrl.getArrayData().$resources.length > 0) {
				var row = ctrl.getRowById(ctrl.$$elmt.find(".s-m-record.s-m-auth-rec-selected").attr("data-params"));
				if (row) {
					row = row.row;
				} else {
					row = ctrl.getArrayData().$resources[0];
				}
				row = $.extend(true, {}, row.data);
				dao = new daoSdata.Dao(row, this.prototype, null, "carddesign");
			} else {
				dao = daoSdata.getArrayEmptyRow(this, this.prototype, "carddesign", ctrl.getDao());
			}
			this.setDao(dao);
			return $.smResolve();
		},
		/**
		 * Return data for parent
		 */
		getParentNotif: function() {
			if (this._notifData) {
				return {
					parentId: this.state.options.parentId,
					controlId: this.state.options.controlId,
					notifId: "sm.updt.card.article",
					notifData: this._notifData
				};
			}
			return null;
		},
		_actSaveCardDesign: function() {
			this._notifData = {};
			this._notifData.article = $.extend(true, {}, this.article);
			globals.getApplication().goBack();
		}
	});

exports.Page = _Page;
});

define('syracuse-tablet/html/js/pages/pageLookup',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/pages/pageRegular','syracuse-tablet/html/js/application/eventListener'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/pages/pageRegular').Page;
var eventListener = require('syracuse-tablet/html/js/application/eventListener');

var _noDataHtml = '	<br><br><br>\
					<h3 class="alert alert-info" style= "text-align:center" role="alert">\
					No data\
					</h3>\
					<br>\
					<div  style= "font-size:xx-large;text-align:center">\
					<a draggable="false" href="#" data-action="lookupBack" class="fa fa fa-arrow-circle-o-left" style="display: inline-block;"/>\
					</div>';
/**
 * Lookup page that handles selection
 * TODO - eventually if we have to merge wit regular page later
 */
var _Page = utils.defineClass(
	function($parent, state, prototype, article, options) {
		options.footer = false;
		Base.call(this, $parent, state, prototype, article, options);
		this.selectedRowJson = null;
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			this.selectedRowJson = null;
		},
		/**
		 * sm-select-row notification event - Do not call super (Page) because we just need to store the rowDao and close the page
		 * Data selected will be passed to parent page by pageLoader via standard parent notification process - getParentNotif
		 * {data, proto} - data: selected JSON data - proto - prototype of rrow data
		 */
		notifSelectRow: function(arrayId, rowId, data) {
			if (!data) return;
			// Clone JSON because array dao is destroyed with the page
			this.selectedRowJson = data;
			this._actLookupBack();
		},
		afterRender: function(loadOptions, buildOpts) {
			Base.prototype.afterRender.call(this, loadOptions, buildOpts);
			// Check if array is empty
			var c = this.forEachControl(function(id, c) {
				return c.$type === "application/x-array";
			});
			if (c && c.isEmpty == true) {
				this.$$elmt.html(_noDataHtml);
			}
		},
		/**
		 * getParentNotif method is called by pageLoader to notify parent page
		 */
		getParentNotif: function() {
			if (!this.selectedRowJson) return null;
			return {
				parentId: this.state.options.parentId,
				controlId: this.state.options.controlId,
				notifId: "sm.lookup.selection",
				notifData: this.selectedRowJson
			};
		},
		_actLookupBack: function() {
			if (this.isVignette) {
				eventListener.triggerAction(this.$$elmt, "vignetteBack");
			} else {
				this.goBack();
			}
		}
	});

exports.Page = _Page;
});

define('syracuse-tablet/html/js/pages/pageHtml',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/pages/page'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var prototype = require('syracuse-tablet/html/js/helpers/prototype');
var Base = require('syracuse-tablet/html/js/pages/page').Page;


var _Page = utils.defineClass(

	function($$parent, state, options) {
		Base.call(this, $$parent, state, prototype.create(state.$prototype), state.$article, options);
	}, Base, {


		afterRender: function(loadOptions, buildOpts) {
			Base.prototype.afterRender.call(this, loadOptions, buildOpts);
			this.$$htmlRoot = this.rootLayout.$$elmt;
			this.appendHtml(this.$$htmlRoot, buildOpts);
		},
		/**
		 * Append html to the root layout $$elmt
		 */
		appendHtml: function($$parent, buildOpts) {

		}
	});

exports.Page = _Page;
});

define('syracuse-tablet/html/js/pages/pageLogin',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/pages/pageHtml','syracuse-tablet/html/js/application/authentication','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/application/settings','syracuse-tablet/html/js/helpers/hammerScroller'],function (require, exports, module) {

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/pages/pageHtml').Page;
var auth = require('syracuse-tablet/html/js/application/authentication');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var settings = require('syracuse-tablet/html/js/application/settings');
var HammerScroller = require('syracuse-tablet/html/js/helpers/hammerScroller').Klass;

var _pageTemplate = '\
		<div class="s-m-scroll-wrapper">\
			<div class="s-m-loginform" style="display:none;position: relative;">\
				<div class="row s-m-login-info">\
					<div class="col-xs-offset-1 col-xs-10 col-sm-offset-3 col-sm-6 col-md-offset-4 col-md-4 col-lg-offset-4 col-lg-4">\
						<div id="login-reason" style="display: none" class="alert alert-info" role="alert"></div>\
						<div id="login-success" style="display: none" class="alert alert-success" role="alert"></div>\
						<div id="login-fail" style="display: none" class="alert alert-danger" role="alert"></div>\
					</div>\
				</div>\
				<div id="s-m-login-online" class="row">\
					<div class="col-xs-offset-1 col-xs-10 col-sm-offset-3 col-sm-6 col-md-offset-4 col-md-4 col-lg-offset-4 col-lg-4">\
						<div class="panel panel-default">\
							<div class="s-m-login-header"><span class="s-m-signin">{{label_signin}} </span> <span class="s-m-brand">{{label_brand}}</span> <span class="s-m-product">{{label_product}}</span></div>\
							<div class="panel-body s-m-login-body">\
								<br>\
								<div class="form-group">\
									<input type="text" value="" class="form-control s-m-login-form-input" placeholder="{{label_user}}"	id="login-user">\
								</div>\
								<br>\
								<div class="form-group">\
									<input type="password" class="form-control s-m-login-form-input" placeholder="{{label_password}}" id="login-password">\
								</div>\
								<br>\
								<button id="login-login" data-action="login" type="button" class="btn btn-primary s-m-signin-btn">{{act_login}}</button>\
							</div>\
							<div class="s-m-login-header" id="s-m-sageid-header">\
								<span class="s-m-signin">{{sageid_label_header}}</span>\
							</div>\
							<div class="panel-body s-m-login-body" id="s-m-sageid-body">\
								<button id="s-m-sageid-signin" data-action="sageidsignin" type="button" class="btn btn-primary s-m-signin-btn">{{sageid_label_signin}}</button>\
							</div>\
						</div>\
					</div>\
				</div>\
				<div id="s-m-login-offline" class="row" style="display: none;">\
					<div class="col-xs-offset-1 col-xs-10 col-sm-offset-3 col-sm-6 col-md-offset-4 col-md-4 col-lg-offset-4 col-lg-4">\
						<div class="panel panel-default">\
							<div class="s-m-login-header"><span class="s-m-signin">{{label_signin}} </span> <span class="s-m-brand">{{label_brand}}</span> <span class="s-m-product">{{label_product}}</span></div>\
							<div class="s-m-login-header" id="s-m-offline-header">\
								<span class="s-m-signin">{{offline_label_header}}</span>\
							</div>\
							<div class="panel-body s-m-login-body" id="s-m-sageid-body">\
								<button id="s-m-offline-signin" data-action="offlinesignin" type="button" class="btn btn-primary s-m-signin-btn"> \
									<div id="s-m-offline-label">{{offline_label_signin_as}}</div> \
									<div id="s-m-offline-user"></div> \
								</button>\
							</div>\
						</div>\
					</div>\
				</div>\
			</div>\
		</div>\
	';

var lang;
var _Page = utils.defineClass(

	function($parent, state, options) {
		options.header = false;
		options.footer = false;
		this.offline = false;
		this.message = null;
		this.stack = null;
		Base.call(this, $parent, state, options);
	}, Base, {

		appendHtml: function($$parent, loadOpts) {
			var self = this;

			// Add class login to add background
			self.$$elmt.addClass("login");
			var _pageContext = {
				"label_user": locale.text("login.label.user"),
				"label_password": locale.text("login.label.password"),
				"act_login": locale.text("login.label.signinaction"),
				"label_signin": locale.text("login.label.signin"),
				"label_brand": locale.text("login.label.brand"),
				"label_product": locale.text("login.label.product"),
				"sageid_label_header": locale.text("sageid.label.header"),
				"sageid_label_signin": locale.text("sageid.label.signin"),
				"offline_label_header": locale.text("login.label.offline"),
				"offline_label_signin_as": locale.text("login.label.login_as")
			};
			var template = Handlebars.compile(_pageTemplate);
			$$parent.html(template(_pageContext));

			if (self.state.options.reason) {
				$$parent.find("#login-reason").text(self.state.options.reason).show();
			}

			if (!globals.isOnline()) {
				self.offline = true;
				self._updateStatus();
			}

			self._gestureMgr = new HammerScroller($(".s-m-loginform", self.$$elmt), {
				direction: "v"
			});
		},
		_actLogin: function() {
			var self = this;

			self.$$elmt.find("#login-reason").remove();
			var usr = self.$$elmt.find("#login-user").val();
			var pwd = self.$$elmt.find("#login-password").val();
			var locale = self.$$elmt.find("#login-locale").val();

			var userProfile = null;
			self.waitWheelStart();

			return auth.login(usr, pwd).then(function(ok, syraUsrProfile, message, offline) {
				if (ok) {
					userProfile = syraUsrProfile;
					return $.smResolve();
				} else {
					return $.smReject(message, offline);
				}
			}).then(function() {
				self.waitWheelStop();
				var notifDeferred = $.Deferred();
				// We pass a deferred to be notified with error/success of initLogin process
				// !! only one subscriber of sm.login should resolve/reject the deferred
				notifications.publish("sm.login", userProfile, notifDeferred);
				return notifDeferred.promise();
			}).then(function(context) {
				// Result of notification - Do Nothing - Display of welcomeApplication page is managed by application
			}).fail(function(e, offline) {
				self.waitWheelStop();
				self.offline = offline;
				self._checkMessage(e);
				self._updateStatus();
			});
		},
		_checkMessage: function(e) {
			var self = this;
			self.message = null;
			self.stack = null;
			if (jsutils.isError(e)) {
				self.message = e.message;
				self.stack = jsutils.cleanStack(e.stack, 3, true);
			} else {
				self.message = e;
			}
		},
		_updateStatus: function() {
			var self = this;
			var $$fail = $("#login-fail");
			if (self.message) {
				$$fail.show().html("Login failed<p>" + self.message + "</p>" + (self.stack ? self.stack : ""));
			} else {
				$$fail.hide();
			}

			settings.getLastUserProfile().then(function(profile) {
				self.profile = profile;

				// If there is no user profile stored on the device, only allow online login
				if (!self.profile) {
					self.offline = false;
				} else {
					$("#s-m-offline-user").text((self.profile.user.firstName || "") + " " + (self.profile.user.lastName || ""));
				}

				if (self.offline) {
					$("#s-m-login-online").hide();
					$("#s-m-login-offline").show();
				} else {
					$("#s-m-login-online").show();
					$("#s-m-login-offline").hide();
				}
			});
		},
		_actSageidsignin: function() {
			auth.sageidsignin();
		},
		_actOfflinesignin: function() {
			var self = this;
			var notifDeferred = $.Deferred();

			notifications.publish("sm.login", self.profile, notifDeferred);
			notifDeferred.fail(function(e) {
				self._checkMessage(e);
				self._updateStatus();
			});
		},
		onMainPageResize: function(info, orientation, deviceClass) {
			var self = this;
			Base.prototype.onMainPageResize.call(self, info, orientation, deviceClass);

			var $$form = self.$$htmlRoot.find("div.s-m-loginform");
			$$form.show();

			// handle gesture (necessary for small screen devices)
			setTimeout(function() {

				var $$scrollWrapper = $(".s-m-scroll-wrapper", self.$$elmt);
				var scrollRect = uiRect.elmtRect($$scrollWrapper, "outer");
				var hScroll = self._gestureMgr.$$elmt.height();

				if (scrollRect.height < hScroll) {
					self._gestureMgr.init(scrollRect, null, null, info && info.preserveScroll);
				} else {
					self._gestureMgr.reset();
				}

			});
		},
		scrollAllowed: function() {
			return false;
		},
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		}
	});

exports.Page = _Page;
});

define('syracuse-tablet/html/js/application/daoApp',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');

/**
 * Class that manage access to application DATA
 *  	appli: 		Application object
 * !!use DAO methods instead of dealing directly with JSON
 */
var _Dao = utils.defineClass(
	function(appli) {
		var self = this;
		self._appli = appli;
		self.appMetaData = null;
	}, null, {

		destroy: function() {
			var self = this;
			self._appli = null;
		},
		/**
		 *Returns the JSON description of application
		 */
		isApplicationLoaded: function() {
			var self = this;
			return (self.appMetaData != null);
		},

		/**
		 * Set the JSON description of application
		 */
		setApplication: function(appMetaData) {
			var self = this;
			if (appMetaData) {
				self.appMetaData = $.extend(true, {}, appMetaData);
			}
		},

		getApplicationName: function() {
			var self = this;
			return self.appMetaData && self.appMetaData.$application.applicationName || "";
		},

		getApplicationTitle: function() {
			var self = this;
			return (self.appMetaData && (self.appMetaData.$application.title || self.appMetaData.$application.applicationName)) || "";
		},

		getApplicationIcon: function() {
			return this.appMetaData && this.appMetaData.$application.iconName;
		},
		isSageApplication: function() {
			return this.appMetaData != null && this.appMetaData.$application.isSageApplication === true;
		},
		getAppBackGroundClass: function() {
			// No background class - we removed the background image
			return "";
		},
		/*
		 * Return name of home dashboard of this application or null if not available
		 */
		getHomeDashboardName: function() {
			var self = this;
			var homeDash = (self.appMetaData.$application.$homeDashboard.dashboardName || "").trim();
			if (homeDash.length == 0) {
				new Error(locale.text("error.page.homenotdefined", [self.getApplicationName()]));
			}
			if (self.appMetaData && self.appMetaData.$dashboards) {
				for (var p in self.appMetaData.$dashboards) {
					var data = self.appMetaData.$dashboards[p];
					if (data.$dashboardName === homeDash) {
						return data.$dashboardName;
					}
				}
			}
			throw new Error(locale.text("error.page.homenotfound", [self.getApplicationName(), homeDash]));
		},
	});

exports.Dao = _Dao;
});

define('syracuse-tablet/html/js/application/appFactoryDeps',['require','exports','module','syracuse-tablet/html/js/application/application','syracuse-tablet/html/js/pages/pageDashboard','syracuse-tablet/html/js/pages/pageWelcomeDashboard','syracuse-tablet/html/js/pages/pageRegular','syracuse-tablet/html/js/pages/pageRowDetail','syracuse-tablet/html/js/pages/pageCardDesign','syracuse-tablet/html/js/pages/pageLookup','syracuse-tablet/html/js/pages/pageLogin','syracuse-tablet/html/js/application/daoApp','syracuse-tablet/html/js/application/daoSdata','syracuse-tablet/html/js/application/appFactory'],function (require, exports, module) {

var Application = require('syracuse-tablet/html/js/application/application').Application;
var DashoardPage = require('syracuse-tablet/html/js/pages/pageDashboard').Page;
var WelcomeDashoardPage = require('syracuse-tablet/html/js/pages/pageWelcomeDashboard').Page;
var RegularPage = require('syracuse-tablet/html/js/pages/pageRegular').Page;
var RowDetailPage = require('syracuse-tablet/html/js/pages/pageRowDetail').Page;
var CardDesignPage = require('syracuse-tablet/html/js/pages/pageCardDesign').Page;
var LookupPage = require('syracuse-tablet/html/js/pages/pageLookup').Page;
var LoginPage = require('syracuse-tablet/html/js/pages/pageLogin').Page;
var DaoApp = require('syracuse-tablet/html/js/application/daoApp').Dao;
var DaoSdata = require('syracuse-tablet/html/js/application/daoSdata').Dao;

var factory = require('syracuse-tablet/html/js/application/appFactory');

exports.init = function() {
	factory.setImpl("Application", Application);
	factory.setImpl("DashoardPage", DashoardPage);
	factory.setImpl("WelcomeDashoardPage", WelcomeDashoardPage);
	factory.setImpl("RegularPage", RegularPage);
	factory.setImpl("RowDetailPage", RowDetailPage);
	factory.setImpl("CardDesignPage", CardDesignPage);
	factory.setImpl("LookupPage", LookupPage);
	factory.setImpl("LoginPage", LoginPage);
	factory.setImpl("DaoApp", DaoApp);
	factory.setImpl("DaoSdata", DaoSdata);
};
});

define('syracuse-tablet/html/js/controls/structElmt',['require','exports','module','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils'],function (require, exports, module) {

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');

/**
 * Base class for controls and layouts
 *
 * controller: page (or child controller)
 * 		must implements addControl Method
 *
 */
var _Klass = utils.defineClass(
	function StructElmt(controller, $type, article, options) {
		var self = this;
		self.options = options || {};
		self.controller = controller;
		self.$type = $type;
		self.typeName = utils.getTypeName($type);
		self.article = article || {};
		self.children = null;
		self.parent = null;
		self._dao = null;
		self.initReuseProperties();
	}, null, {
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			this.$$elmt = null;
			this.id = this.createId(this.typeName);
		},
		destroy: function() {
			this.controller = null;
			this._dao = null;
			this.parent = null;
			if (this._gestures) {
				this._gestures.destroy();
				this._gestures = null;
			}
			utils.unbindObj(this.$$elmt);
			utils.unbindObj(this);
			if (this.children) {
				this.children.forEach(function(child) {
					if (child) child.destroy();
				});
				this.children = null;
			}
			if (this.$$elmt) {
				this.$$elmt.remove();
				this.$$elmt = null;
			}
		},
		isRoot: function() {
			return this.parent == null || this.parent === this.controller;
		},
		/**
		 * Generate html
		 * Use the same control buildHtml multiple html with different id's
		 * It's used by cards to build the tree structure for a card and reuse it for all the cards instead of creating a new tree structure for each card
		 * Same as buildHtml but:
		 * 		calls initReuseProperties to reset ID and properties used by previous build (cache, dom elmts...)
		 * !! It's the responsibility of the caller to destroy or not the control after having set $$elmt to null
		 * Returns $$elmt
		 */
		generateHtml: function($$parent, controllerDao, htmlRootCtrl, updateLayout) {
			var opts = this.options;
			if (htmlRootCtrl) {
				opts.htmlRootCtrl = htmlRootCtrl;
			}
			opts.isHtmlGenerator = true;
			opts.updateLayout = updateLayout === true;
			/**
			 * !! When we build html of a rootLayout with isHtmlGenerator = true we call afterRender (recursively) after having called buildHtml to apply meta-data
			 * It's done in LayoutBase buildChildrenHtml
			 */
			this.buildHtml($$parent, controllerDao, opts);
			if (this.afterRender) {
				// Call afterRender on current element - afterRender is called by LayoutBase.buildChildrenHtml for children if any
				this.afterRender(opts);
			}
			return this.$$elmt;
		},
		applyMetaData: function(metaData) {
			// Nothing by default - used by controls
		},
		getDao: function() {
			if (this._dao && !this._dao.isValid()) {
				// Trick - Like we store the dao we don't know if it's still valid - It'd be better to not store the dao but not easy for arrays
				this._dao = null;
			}
			return this._dao ? this._dao : this.controller.dao;
		},
		/**
		 * Build html for a control/layout
		 * !! CHILD CLASSES BUILDHTML METHOD MUST CALL THIS METHOD BEFORE PROCESSING
		 */
		buildHtml: function($$parent, controllerDao, buildOptions) {
			/**
			 * We need to store the dao to build cards - dao is the data row which is different from controller.dao
			 * It's better to store it for asynchronous calls
			 */
			this._dao = controllerDao;
			if (buildOptions && buildOptions.isHtmlGenerator === true) {
				if (this._needReuse) {
					this.initReuseProperties();
				} else {
					// First call don't call _initReuse
					this._needReuse = true;
				}
			}
		},
		/**
		 * Only for controls by method is need for all structElmts
		 */
		getMetaData: function(metaProp) {
			return null;
		},
		/**
		 * Returns field/layout authoring
		 * path: string with or without '.' separator or array of string
		 */
		getAuthoring: function(path, defValue) {
			var val = utils.getPropByPath(this.article, path);
			return val != null ? val : defValue;
		},
		/**
		 * Appends style authoring to classArray
		 * It's a draft just to start dealing with authoring
		 * classArray: 	array of classes used by createDomElement
		 * pathOrData: 	string or array of string that points points to an authoring value
		 * 				JS plain object that is the authoring object
		 */
		appendStyleAuthoring: function(classArray, pathOrData) {
			classArray = classArray || [];
			if (!pathOrData) return classArray;
			if ($.isPlainObject(pathOrData)) {
				// pathOrData is the authoring object
				var data = pathOrData;
			} else {
				// pathOrData points to an authoring value
				var data = this.getAuthoring(pathOrData);
			}
			if (!data) return classArray;
			// Apply style classes - To improve/enhance
			for (var p in data) {
				if (["$theme", "$fontStyle", "$fontSize"].indexOf(p) >= 0) {
					classArray.push(data[p]);
				}
			}
			return classArray;
		},
		/**
		 * Empty current element
		 * 	Called before a refresh
		 *  Keep control objects
		 */
		empty: function() {
			var self = this;
			if (self.children) {
				self.children.forEach(function(child) {
					if (child) child.empty();
				});
			}
			if (self.$$elmt) {
				self.$$elmt.empty();
			}
		},
		isLayout: function() {
			return false;
		},
		isVignette: function() {
			return false;
		},
		isControl: function() {
			return false;
		},
		createId: function(typeName) {
			return utils.readableuid(typeName);
		},
		/**
		 * Append structElmt c as a child of this
		 */
		appendStructElmt: function(c) {
			var self = this;
			if (!c) return;
			if (!self.children) self.children = [];
			c.parent = self;
			self.children.push(c);
		},

		getNbChilds: function() {
			return this.children && this.children.length > 0;
		},
		/**
		 * Create the root element of the control/layout/vignette
		 * 	This element is identified by self.id
		 */
		createRootElement: function(css, $$parent) {
			var self = this;
			// No id for generated html
			var e = self.setRootElement(uiUtils.createDomElement("div", css, null, self.options.isHtmlGenerator === true ? null : {
				"id": self.id
			}), $$parent);
			return e;
		},
		setRootElement: function(e, $$parent) {
			if (!e) {
				return null;
			}
			if (!e.jquery) {
				e = $(e);
			}
			this.$$elmt = e;
			if ($$parent) {
				if (!$$parent.jquery) {
					$$parent = $($$parent);
				}
				e.appendTo($$parent);
			}
			return e;
		},
		isVisible: function() {
			return this.$$elmt && this.$$elmt.is(":visible");
		},
		isHidden: function() {
			return !this.isVisible();
		},
		show: function() {
			if (this.$$elmt) this.$$elmt.show();
		},
		hide: function() {
			if (this.$$elmt) this.$$elmt.hide();
		},
		/**
		 * Set the focus on this field and scroll
		 */
		setFocus: function() {

		},
		/*
		 * Must return the article of this control/layout node
		 * The article must only contain static authoring.
		 * Dynamic settings that are added by payload must not be part of the returned data structure
		 * since this structure will be used to create the article tree for the page and will
		 * be stored on the server!
		 */
		getArticle: function() {
			return this.article;
		},

		/*
		 * Called by authoring if a control or layout is removed by the user
		 */
		removeChild: function(structElmt) {
			var self = this;
			var _children = [];
			self.children.forEach(function(child) {
				if (child && child.id === structElmt.id) {
					child.destroy();
				} else {
					_children.push(child);
				}
			});
			self.children = _children;
		},
		/*
		 * Called by authoring if a control or layout is removed by the user
		 */
		removeChildren: function() {
			var self = this;
			self.children && self.children.forEach(function(child) {
				child.destroy();
			});
			self.children = [];
		},
		getIndexOfChild: function(child) {
			var self = this;
			var idx = -1;
			self.children && self.children.some(function(c) {
				idx = idx + 1;
				if (c === child) {
					return true;
				}
				return false;
			});
			return idx;
		},
		getChildByIndex: function(idx) {
			var self = this;
			return self.children && self.children[idx];
		},

		/*
		 * Add new child before nextChild
		 * If nextChild is null, it's added at the end of the container
		 */
		addChildBefore: function(ctrl, nextChild) {
			var self = this;
			var added = false;
			var _children = [];
			self.children && self.children.forEach(function(c) {
				if (nextChild && (c.id === nextChild.id)) {
					_children.push(ctrl);
					added = true;
				}
				if (c.id !== ctrl.id) {
					_children.push(c);
				}
			});

			if (!added) {
				_children.push(ctrl);
			}
			self.children = _children;
		},

		/*
		 * Removes reference to child without destorying the child!
		 */
		removeChildRef: function(c) {
			var self = this;
			var _children = [];
			self.children && self.children.forEach(function(child) {
				if (child.id !== c.id) {
					_children.push(child);
				}
			});
			self.children = _children;
		},

		/*
		 * Start by this node and go up the layout tree storing all the indexes of the current not in the parent container
		 */
		getPathInTree: function() {
			var ctrl = this;
			var parent;
			var path = [];
			parent = this.parent;

			// The intention of this function is to stop at root level, not at the first controller found
			// The first controller might be the vignette containing the control, but we want to get the page/dashboard
			// containing the full screen not only a single vignette
			//while (parent && parent != this.controller) {
			while (parent) {
				var idx;
				if (jsutils.isInstanceOf(parent, "Page")) {
					if (parent.isVignette) {
						var vgnt = parent.getParentVignette();
						idx = 0;
						parent = vgnt.parent;
					} else { // We reached the root page -> done
						break;
					}
				} else {
					idx = parent.getIndexOfChild(ctrl);
				}
				path.push(idx);
				ctrl = parent;
				parent = parent.parent;
			}
			path.reverse();
			return path;
		},

		/*
		 * Resolve the path generated by getPathInTree to find the children again
		 */
		findChildByPath: function(path) {
			var self = this;
			if (!path) {
				return;
			}

			var node = self;
			path.some(function(idx) {
				if (jsutils.isInstanceOf(node, "VignetteBase")) {
					if (node.getPage()) {
						node = node.getPage().rootLayout;
					} else {
						node = null;
						return true;
					}
				}
				node = node.getChildByIndex(+idx);
			});

			return node;
		},

		/*
		 * Returns the article used for authoring of this element
		 * Not that sub level informations usually nested in $items MUST not be returned here
		 */
		getAuthArticle: function() {
			var self = this;
			var authArticle = {};
			var nodeArticle = self.getArticle();
			Object.keys(nodeArticle).forEach(function(key) {
				if (key !== "$items") {
					authArticle[key] = nodeArticle[key];
				}
			});
			return authArticle;
		},

		getAuthState: function(dirtyKeys) {
			return null;
		},
		setAuthState: function(state) {

		},
		getArticleText: function(property) {
			var self = this;
			if (!self.article[property]) {
				return "";
			}
			var text = self.article[property] && self.article[property].replace(/\{\@(\S+)\}/g, function(m, g) {
				return self.options.$localization && self.options.$localization[g] || m;
			});
			return text || "";
		}
	}
);

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/ctrlBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/structElmt'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/structElmt').Klass;
/**
 * Used to generate the html of control Icon/Button
 * generate a link and call cb to get the content of the control (icon/button...)
 * cb	Add html text to html param
 */
var _genHtmlCtrlLink = function(proto, dao, options, cb) {
	var self = this;
	options = options || {};
	var html = [];
	var url = proto.data("$url");
	var tag = options.tag || 'a';
	var css = options.css || 'a';
	if (url && url.length) {
		html.push('<');
		html.push(tag);
		html.push(' href="' + url + '"');
		if (css) {
			html.push(' class="' + css + '"');
		}
		html.push('>');
	} else {
		// attributes for data-nav or data-action
		var action = proto.data("$action") || self.prototype.data("$navigation");
		if (action) {
			html.push('<');
			html.push(tag);
			html.push(' href="#"');
			for (var p in action) {
				html.push(' ' + p + '="' + encodeURIComponent(dao ? dao.parseExpression(action[p]) : action[p]) + '"');
			}
			if (css) {
				html.push(' class="' + css + '"');
			}
			html.push('>');
		}
	}
	if (cb) cb(html);
	if (html.length > 1) {
		html.push('</');
		html.push(tag);
		html.push('>');
	}
	return html.join('');
};

var _Klass = utils.defineClass(

	function CtrlBase(controller, article, prototype, options) {
		var self = this;
		options = options || {};
		self.prototype = prototype;
		self.$bind = article.$bind;
		Base.call(self, controller, prototype.data('$type'), article, options);
		self.$isEditMode = controller.isEditMode();
		if (options.displayCtx === "table") {
			self.$isEditMode = false;
		}
	}, Base, {
		destroy: function() {
			var self = this;
			Base.prototype.destroy.call(self);
			if (self.prototype) {
				// We destroy the proto
				self.prototype.destroy();
				self.prototype = null;
			}
		},
		createId: function(typeName) {
			// Add $bind in id for readability - Id can be minimized in non debug version
			return utils.readableuid(this.$bind, typeName.substr(0, 3));
		},
		/**
		 * Controls manage by the page (outside the tree structure given by article)
		 * footer/header...
		 */
		isPageControl: function() {
			return this.$type.smStartsWith("tablet/x-page-");
		},
		/**
		 * controllerDao is the page dao or the row data for a grid
		 * 	We need to store it to keep acces
		 */
		buildHtml: function($$parent, controllerDao, buildOptions, classes) {
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions);
			var css = ["s-m-control"];
			if (classes) css.push(classes.join(' '));
			this.createRootElement(css, $$parent);
			this._oldValue = this.getValue();
		},
		afterRender: function(buildOpts) {
			// Apply meta after build html - !! Called aftrt buildHtml if isHtmlGenerator = true
			this.applyMetaData(this.getMetaData());
		},
		/**
		 * Refreshes the control
		 * We have to apply meta-data
		 */
		refresh: function(controllerDao, options) {
			if (options && options.refreshValue) {
				// Used by simple controllers - To improve with meta-data management imrpovement
				var newValue = this.getValue();
				if (!utils.areEqual(newValue, this._oldValue)) {
					// Enabled only wit simple controller
					this.refreshValue(newValue);
					this._oldValue = newValue;
				}
			}
			this.applyMetaData(this.getMetaData());
		},
		refreshValue: function(value) {

		},
		/**
		 * dao.getMetaData does the merge between prototype and data
		 * metaProp		optional - name of the meta $readonly...
		 * 				if null returns all the meta
		 */
		getMetaData: function(metaProp) {
			var dao = this.getDao();
			var meta = dao ? dao.getMetaData("$properties", this.$bind) : null;
			if (metaProp) return meta ? meta[metaProp] : null;
			return meta;
		},
		getTitle: function() {
			return (this.article && this.article.$title) || this.prototype.data("$title") || this.prototype.getPropTitle(this.$bind);
		},
		/**
		 * Applies meta-data
		 * In edit mode the dom element to which meta-data apply is identify by s-m-meta class
		 * In detail mode meta-data apply to fieldSlot
		 */
		applyMetaData: function(metaData) {
			var self = this;
			if (metaData == null) return;
			if (self.$isEditMode) {
				// default
				var e = self.$$elmt.find(".s-m-meta");
				if (e.length > 0) {
					// Apply $isDisabled and $isReadOnly
					// is("input") returns true for button tags -> we check the BS class .btn
					if (e.is("input") && !e.is(".btn")) {
						// only for input tags
						e[metaData.$isReadOnly === true ? "attr" : "removeAttr"]("readonly", "");
						e[metaData.$isDisabled === true ? "attr" : "removeAttr"]("disabled", "");
					} else {
						// other tags
						e[metaData.$isReadOnly === true || metaData.$isDisabled === true ? "attr" : "removeAttr"]("disabled", "");
					}
				}
			}
			if (metaData.$isHidden != undefined) {
				// Do not toggle in any case to not set style="display..." if no meta hidden
				self.$$elmt.toggle(metaData.$isHidden === false);
			}
		},
		getValue: function() {
			var dao = this.getDao();
			return dao ? dao.getValue(this.$bind) : null;
		},
		/**
		 * Change internal value (non UI only)
		 * value parameter must be a correct datatype value without UI specific formatting
		 */
		setValue: function(value) {
			this.getDao().setValue(this.$bind, value);
		},
		/**
		 *  Validate the value and display error if any
		 *  returns true if OK
		 *  Used to validate a form
		 */
		checkData: function() {
			// Only field controls check the value
			return true;
		},
		setErrorStatus: function(yes) {
			if (!this.$$elmt) return;
			this.$$elmt[yes === true ? "addClass" : "removeClass"]("error");
		},
		/**
		 * True if ctrl has an error
		 */
		hasError: function() {
			return this.$$elmt && this.$$elmt.hasClass("error");
		},
		/**
		 * Set the focus on this field and scroll
		 */
		setFocus: function() {
			if (!this.controller) return;
			// Just make ctrl visible
			this.controller.makeVisible(this);
			// Focus is set on CtrlFields with inputs fields for the moment
		},
		isControl: function() {
			return true;
		}
	}
);

exports.genHtmlCtrlLink = _genHtmlCtrlLink;
exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/validator',['require','exports','module','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var locale = require('syracuse-tablet/html/js/helpers/locale');

/*
 *
 * Collection of all SData contraints and a validation function per constraint
 *
 */

var _validator = {
	validate: function(ctrl, value, errors, constraints) {
		var proto = ctrl.prototype;
		var ok = true;
		for (var i = 0; i < constraints.length; i++) {
			var c = constraints[i];
			var prop = null;
			if (ctrl && ctrl.getMetaData) {
				// We check metadata first - check $properties[constraints] in data and proto
				// Ex: $isMandatory
				prop = ctrl.getMetaData(c);
			}
			if (prop == null) {
				// If it's not a meta ($properties) we check the proto value
				prop = proto && proto.data(c);
			}
			if (prop != null) { // constraint set in prototype
				var fn = _validator[c];
				if (fn) {
					ok = fn(value, errors, prop) && ok;
				} else {
					errors.push(locale.text("field.unknownConstraint", [c]));
					ok = false;
				}
			}
		}
		return ok;
	},

	// General
	$isMandatory: function(value, errors, constraint) {
		if (constraint && (value == null || value == "")) {
			errors.push(locale.text("field.valMand"));
			return false;
		}
		return true;
	},

	// Strings
	$pattern: function(value, errors, constraint) {
		var self = this;
		if (value && constraint) {
			var re = new RegExp(constraint);
			if (!re.test(value)) {
				errors.push(locale.text("field.patternError", [constraint]));
				return false;
			}
		}
		return true;
	},

	// Numeric
	$minimum: function(value, errors, constraint) {
		var self = this;
		if (value != null && value < constraint) {
			errors.push(locale.text("field.minimum", [constraint]));
			return false;
		}
		return true;
	},
	$maximum: function(value, errors, constraint) {
		var self = this;
		if (value != null && value > constraint) {
			errors.push(locale.text("field.maximum", [constraint]));
			return false;
		}
		return true;
	},
	$exclusiveMinimum: function(value, errors, constraint) {
		var self = this;
		if (value != null && value <= constraint) {
			errors.push(locale.text("field.exclusiveMinimum", [constraint]));
			return false;
		}
		return true;
	},
	$exclusiveMaximum: function(value, errors, constraint) {
		var self = this;
		if (value != null && value >= constraint) {
			errors.push(locale.text("field.exclusiveMaximum", [constraint]));
			return false;
		}
		return true;
	},
	$minLength: function(value, errors, constraint) {
		var self = this;
		if (!value || value.length < constraint) {
			errors.push(locale.text("field.minLength", [constraint]));
			return false;
		}
		return true;
	},
	$maxLength: function(value, errors, constraint) {
		var self = this;
		if (value && value.length > constraint) {
			errors.push(locale.text("field.maxLength", [constraint]));
			return false;
		}
		return true;
	},
	$precision: function(value, errors, constraint) {
		var self = this;
		if (value) {
			var txt = ("" + value).split(".").join("");
			if (txt.length > constraint) {
				errors.push(locale.text("field.precision", [constraint]));
				return false;
			}
		}
		return true;
	},
	$scale: function(value, errors, constraint) {
		var self = this;
		if (value) {
			var txt = ("" + value).split(".");
			txt = txt && txt[1] || "";
			if (txt.length > constraint) {
				errors.push(locale.text("field.scale", [constraint]));
				return false;
			}
		}
		return true;
	}

};

exports.Validator = _validator;
});

define('syracuse-tablet/html/js/controls/field/ctrlFieldBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/controls/validator','syracuse-tablet/html/js/authoring/authoringProperties'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');

var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var validator = require('syracuse-tablet/html/js/controls/validator').Validator;

var authorProp = require('syracuse-tablet/html/js/authoring/authoringProperties').properties;

/**
 * Base class for controls that display exactly one value/property
 */
var _Klass = utils.defineClass(

	function CtrlFieldBase(controller, article, prototype, options) {
		var self = this;
		Base.call(self, controller, article, prototype, options);
		self.formatter = self.initFormatter();
		// css to add to fieldSlot elmt
		self.cssType = null;
	}, Base, {

		initFormatter: function() {
			return formatApi.getFormatter(this.$type, this.prototype.data('$format'));
		},
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			this.domInput = null;
			this.$$message = null;
			this.$$value = null; // To force to recreate the value
		},
		destroy: function() {
			var self = this;
			Base.prototype.destroy.call(self);
			self.formatter = null;
		},
		/**
		 */
		buildHtml: function($$parent, controllerDao, buildOptions) {
			var classes = ["s-m-field"];
			// add the type of field if needed for css selector
			if (this.cssType) classes.push(this.cssType);
			if (this.getAuthoring("$value.$valueFirst", false)) classes.push("s-m-valueFirst");
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions, classes);
			var fieldSlot = this.$$elmt.get(0);
			this.buildFieldTitle(fieldSlot, buildOptions);
			this.buildFieldValue(fieldSlot, buildOptions);
			// authoring
			this._applyLabelAuthoring();
			this._applyThemeAuthoring();
			this.checkDiagnoses();
		},
		/**
		 * Refresh only the value
		 */
		refreshValue: function(buildOptions) {
			if (!this.$$value) return;
			this.buildFieldValue(this.$$elmt.get(0), buildOptions);
		},
		/*
		 * Apply theme authoring:
		 * - different theme values come from authorProp (a, b, c, ...)
		 */
		_applyThemeAuthoring: function() {
			var self = this;
			var $theme = self.getAuthoring("$theme");
			if ($theme) {
				var themes = authorProp.theme.values.map(function(val, index, obj) {
					return val.value;
				});
				$.each(themes, function(index, $theme) {
					self.$$elmt.toggleClass("s-m-control-" + $theme, false);
				});
				self.$$elmt.toggleClass("s-m-control-" + $theme);
			}
		},
		/*
		 * Apply authoring properties related to the label:
		 * - labelPosition which can have values top,right,bottom,left
		 * - labelAlign which can have values left, right
		 */
		_applyLabelAuthoring: function() {
			var self = this;

			// set label position
			var $labelPosition = self.getAuthoring("$labelPosition");
			if ($labelPosition) {
				self.setLabelPosition($labelPosition);
			}

			// set label alignment
			var $labelAlign = self.getAuthoring("$labelAlign");
			if ($labelAlign) {
				self.setLabelAlign($labelAlign);
			}
		},
		/*
		 *	Set field label position (left, top)
		 */
		setLabelPosition: function($lp) {
			if ($lp) {
				var self = this;
				var $$title = self.$$elmt.find("div.s-m-title");
				var arr;
				switch ($lp) {
					case "top":
						arr = [$$title, self.$$value];
						$.each(arr, function(index, $$ee) {
							$$ee && $$ee.css("float", "none").css("width", "inherit");
						});
						break;
						// default "left"
					default:
						$$title.css("float", "left").css("width", "30%");
						break;
				}
			}
		},
		/*
		 *	Set field label alignment (right,center,left)
		 */
		setLabelAlign: function($la) {
			var self = this;
			var $$title = self.$$elmt.find("div.s-m-title");
			$$title.css("text-align", $la || "inherit");
		},
		/**
		 * Create the main input field that is bind to blur event and other event
		 * s-m-meta indicates the element to which meta will be applied in edit mode
		 * self.domInput contains the dom element used by event hanlders
		 */
		createMainInput: function(parent, value, type) {
			var self = this;
			type = type || "text";
			var css = ["s-m-meta"];
			var attrs = {
				"type": type
			};
			if ("text" === type) {
				css.push("form-control");
				css.push("ctrl-evt-blur");
				attrs.value = value;
			} else if ("checkbox" === type) {
				css.push("ctrl-evt-click");
			}
			self.domInput = uiUtils.createDomElement("input", css, null, attrs, parent);
			if ("checkbox" === type) self.domInput.checked = value;
			return self.domInput;
		},
		/**
		 * Displays title under fieldSlot ($$elmt)
		 */
		buildFieldTitle: function(fieldSlot, buildOptions) {
			if (this.getAuthoring("$isTitleHidden")) return;
			// don't build field title if grid cell
			if (buildOptions && buildOptions.displayCtx === "table") return;
			var ttl = (this.getTitle() || "").trim();
			if (ttl.length > 0) {
				if (this.getMetaData("$isMandatory") === true) ttl += "*";
				return uiUtils.createDomElement("div", ["s-m-title"], ttl, null, fieldSlot);
			}
			return null;
		},

		/**
		 * Just create the value slot under fieldSlot ($$elmt)
		 * Child class has to add the value
		 */
		buildFieldValue: function(fieldSlot, buildOptions) {
			if (this.$$value) {
				this.$$value.empty();
				this.clearInputErrors();
				this.$$message = null;
			} else {
				var e = uiUtils.createDomElement("div", ["s-m-value", (this.$isEditMode ? "edit" : "")], null, null, fieldSlot);
				this.$$value = $(e);
			}
			return this.$$value.get(0);
		},

		/**
		 * Add a text value to the valueSlot
		 * USed by default to display value with $details facet
		 */
		appendTextValue: function(valueSlot, value) {
			if (valueSlot == null || value == null) return;
			if (typeof value !== "string") value = value.toString ? value.toString() : "??Can't display??";
			value = value.trim();
			if (value.length > 0) uiUtils.appendTextNode(valueSlot, value);
		},

		/*
		 * value: value inputed into the field as string
		 * errors: array where to add validation errors as strings
		 * return true if ok
		 */
		validateValue: function(value, errors) {
			return validator.validate(this, value, errors, ["$isMandatory"]);
		},

		/*
		 * value: value inputed into the field as string
		 * errors: array where to add parsing errors as strings
		 *
		 * return: Parsed value as represented in sdata data
		 * E.g. "2014-12-31" for dates or 123 for numbers
		 */
		parseValue: function(value, errors) {
			if (!this.formatter) {
				return value;
			}
			return this.formatter.parseValue(value, errors);
		},

		applyMetaData: function(metaData) {
			Base.prototype.applyMetaData.call(this, metaData);
			if (metaData && metaData.$diagnoses) {
				var errors = [];
				metaData.$diagnoses.forEach(function(d) {
					errors.push(d.$message);
				});
				this.showInputErrors(errors);
			}
		},
		showInputErrors: function(errors) {
			var self = this;
			if (!self.$$message) {
				self.$$message = $('<span class="s-m-error"/>').appendTo(self.$$value);
			} else {
				self.$$message.empty();
			}
			self.$$elmt.removeClass("error");
			if (errors && errors.length > 0) {
				self.$$elmt.addClass("error");
				errors.forEach(function(error) {
					if (error != null && (error + "").trim().length > 0) {
						self.$$message.append($("<p>").text(error));
					}
				});
			}
		},
		clearInputErrors: function() {
			this.showInputErrors(null);
		},

		/*
		 * Get value as string to be displayed in control (ev. formatted specific to locale)
		 */
		getFormattedValue: function(value) {
			if (!this.formatter) {
				return value || "";
			}
			return this.formatter.formatValue(value);
		},
		/**
		 * Set internal value (controller) and visible formatted value (UI) by applying formatting if needed
		 * value parameter must be a correct datatype value without UI specific formatting
		 * data: 		string/int
		 * 				object with {$value:,$description:,$title:} for x-reference
		 */
		setFieldValue: function(value) {
			this.setDisplayValue(this.getFormattedValue(value));
			this.setValue(value);
		},
		/**
		 * Return true if value OK
		 * justCheck	true to not set the value
		 */
		onBlur: function(justCheck) {
			var self = this;
			self.clearInputErrors();
			if (!self.domInput) return true;
			var value = self.domInput.value;
			var errors = [];
			value = self.parseValue(value, errors);
			if (errors.length === 0) {
				self.validateValue(value, errors);
				if (justCheck !== true) {
					// Set displayed value, also it may violate constraints later
					// This is because a parseable value is reformatted here to emiminate wrong characters
					// Internat value remains unchanged until all constraints are met
					self.setDisplayValue(self.getFormattedValue(value));
					if (errors.length === 0) {
						self.setValue(value);
					}
				}
			}
			if (errors.length > 0) {
				self.showInputErrors(errors);
			}
			return errors.length == 0;
		},
		/**
		 * Change visible value (UI only)
		 * value parameter must be formatted already!
		 */
		setDisplayValue: function(value) {
			if (this.domInput) {
				this.domInput.value = value;
			}
			this.clearInputErrors();
			this.removeDiagnoses();
		},
		refresh: function(controllerDao, options) {
			Base.prototype.refresh.call(this, controllerDao, options);
			this.checkDiagnoses();
		},
		checkDiagnoses: function() {
			var errors = [];
			var diags = this.getMetaData("$diagnoses");
			if (diags && diags.length > 0) {
				diags.forEach(function(d) {
					if (d.$severity === "error") {
						errors.push(d.$message);
					}
				});
			}
			if (errors.length > 0) {
				this.showInputErrors(errors);
			}
			return errors.length === 0;
		},
		/**
		 *  Validate the value and display error if any
		 *  returns true if OK
		 *  Use to validate a form
		 */
		checkData: function(checkDiagnoses) {
			this.clearInputErrors();
			var meta = this.getMetaData();
			if (meta && (meta.$isDisabled === true || meta.$isReadOnly === true || meta.$isHidden === true)) return true;
			if (!this.onBlur(true)) {
				return false;
			}
			var errors = [];
			var value = this.getValue();
			this.validateValue(value, errors);
			if (errors.length > 0) {
				this.showInputErrors(errors);
			}
			return errors.length === 0;
		},
		removeDiagnoses: function() {
			if (this.getDao()) {
				this.getDao().removeMetaDiagnoses(this.$bind);
			}
		},
		/**
		 * Set the focus on this field and scroll
		 */
		setFocus: function() {
			// !! First make visible
			Base.prototype.setFocus.call(this);
			if (this.domInput) {
				// !! Second setFocus
				// !! setFocus scrolls the page and we don't want that because we don't use native scrolling 
				// We need to make th control visible before focus in order to not scroll the page
				// If it doesn't work fine we can save/srestore the page scrolling
				this.domInput.focus();
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/field/ctrlAlphanum',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/controls/validator','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var validator = require('syracuse-tablet/html/js/controls/validator').Validator;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _AlphaNum = utils.defineClass(
	function CtrlAlphaNum(controller, article, prototype, options) {
		var self = this;
		Base.call(self, controller, article, prototype, options);
	}, Base, {

		validateValue: function(value, errors) {
			var self = this;
			var ok = Base.prototype.validateValue.call(self, value, errors);
			return ok && validator.validate(self, value, errors, ["$pattern", "$minLength", "$maxLength"]);
		},

		buildFieldValue: function(fieldSlot, buildOptions) {
			var self = this;
			var valueSlot = Base.prototype.buildFieldValue.call(self, fieldSlot, buildOptions);
			var value = self.getFormattedValue(self.getValue());
			if (self.$isEditMode) {
				self.createMainInput(valueSlot, value);
			} else {
				self.appendTextValue(valueSlot, value);
			}
		}

	});

var _PhoneField = utils.defineClass(

	function CtrlPhoneField(controller, article, prototype, options) {
		var self = this;
		_AlphaNum.call(self, controller, article, prototype, options);
		self.cssType = "s-m-phone";
	}, _AlphaNum, {

		buildFieldValue: function(fieldSlot, buildOptions) {
			var self = this;
			if (self.$isEditMode) {
				_AlphaNum.prototype.buildFieldValue.call(self, fieldSlot, buildOptions);
			} else {
				var value = self.getFormattedValue(self.getValue());
				var link = uiUtils.createDomElement("a", [], value, {
					"href": "phoneto:" + value
				});
				link.appendChild(uiUtils.createDomElement("span", ["badge", "pull-left"]));
				fieldSlot.appendChild(link);
			}
		}
	});


var _EmailField = utils.defineClass(

	function CtrlEmailField(controller, article, prototype, options) {
		var self = this;
		_AlphaNum.call(self, controller, article, prototype, options);
		self.cssType = "s-m-email";
	}, _AlphaNum, {

		buildFieldValue: function(fieldSlot, buildOptions) {
			var self = this;
			if (self.$isEditMode) {
				_AlphaNum.prototype.buildFieldValue.call(self, fieldSlot, buildOptions);
			} else {
				var value = self.getFormattedValue(self.getValue());
				var link = uiUtils.createDomElement("a", [], value, {
					"href": "mailto:" + value
				});
				link.appendChild(uiUtils.createDomElement("span", ["badge", "pull-left"]));
				fieldSlot.appendChild(link);
			}
		}
	});
var _UrlField = utils.defineClass(

	function CtrlUrlField(controller, article, prototype, options) {
		var self = this;
		_AlphaNum.call(self, controller, article, prototype, options);
		self.cssType = "s-m-url";
	}, _AlphaNum, {

		buildFieldValue: function(fieldSlot, buildOptions) {
			var self = this;
			if (self.$isEditMode) {
				_AlphaNum.prototype.buildFieldValue.call(self, fieldSlot, buildOptions);
			} else {
				var value, link, asValue, $urlLink = self.prototype.getUrlLink(self.$bind);
				if ($urlLink.$url) {
					asValue = self.getValue() ? true : false;
					if (asValue) {
						_AlphaNum.prototype.buildFieldValue.call(self, fieldSlot, buildOptions);
					}
					if ($urlLink.$url.indexOf('{' + self.$bind + '}') < 0 || asValue) {
						value = self.prototype.resolveExpression($urlLink.$url, self._dao.data, true);
					}
				} else {
					value = self.getFormattedValue(self.getValue());
				}
				link = value ? uiUtils.createDomElement("a", [], "", {
					"href": value,
					"target": "_blank",
					"class": "s-m-icon-link"
				}) : null;
				if (link) {
					link.appendChild(uiUtils.createDomElement("span", []));
					$(link).addClass(self._getDefaultIcon());
					fieldSlot.appendChild(link);
				}
			}
		},
		_getDefaultIcon: function() {
			var css = "s-m-icon-" + (this.article.$urlIconSize || "small") + " ";
			return css + (this.article.$urlIcon || fontUtils.getUrlDefIcon()).css;
		}
	});
exports.Klass = _AlphaNum;
exports.PhoneField = _PhoneField;
exports.EmailField = _EmailField;
exports.UrlField = _UrlField;
});

define('syracuse-tablet/html/js/controls/field/ctrlProgress',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/controls/field/ctrlFieldBase'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;

var defaultValues = {
	$valueMin: 0,
	$valueMax: 100
};

var _Klass = utils.defineClass(

	function CtrlProgress(controller, article, prototype) {
		var self = this;
		Base.call(self, controller, article, prototype);
	}, Base, {
		buildFieldValue: function(fieldSlot, buildOptions) {
			var self = this;
			var valueSlot = Base.prototype.buildFieldValue.call(self, fieldSlot, buildOptions);
			// building progress bar layout based on bootstrap component
			var value = self.getValue();
			var progressContainer = uiUtils.createDomElement("div", ["progress"]);
			var progressBar = uiUtils.createDomElement("div", ["progress-bar"], value, {
				"role": "progressbar",
				"aria-valuenow": value,
				"aria-valuemin": self.article.$valueMin || defaultValues.$valueMin,
				"aria-valuemax": self.article.$valueMax || defaultValues.$valueMax,
				"style": "width:" + value + "%;"
			});
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/field/ctrlNumeric',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/controls/validator','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var validator = require('syracuse-tablet/html/js/controls/validator').Validator;
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _Klass = utils.defineClass(

	function CtrlNumeric(controller, article, prototype, options) {
		var self = this;
		Base.call(self, controller, article, prototype, options);
	}, Base, {

		buildFieldValue: function(fieldSlot, buildOptions) {
			var self = this;
			var valueSlot = Base.prototype.buildFieldValue.call(self, fieldSlot, buildOptions);
			var value = self.getFormattedValue(self.getValue());
			if (self.$isEditMode) {
				self.createMainInput(valueSlot, value);
			} else {
				self.appendTextValue(valueSlot, value);
			}
		},

		parseValue: function(value, errors) {
			var self = this;
			if (self.formatter) {
				var format = self.formatter.getFormat();
				if (format) {
					var gs = locale.getNumberGroupSeparator();
					var ds = locale.getNumberDecimalSeparator();

					if (format.indexOf(",") < 0 && gs && gs.length > 0) {
						// Format with no GS, consider eventual GS as DS
						value = value.replace(new RegExp("\\" + gs, "g"), ds);
					}
					if (format.indexOf(",") > 0 && format.indexOf(".") > 0 && gs && gs.length > 0) {
						// Format with GS and DS, consider GS as DS if no DS entered
						if (value.indexOf(gs) > -1 && value.indexOf(ds) < 0) {
							value = value.replace(new RegExp(gs, "g"), ds);
						}
					}
				}
			}
			return Base.prototype.parseValue.call(self, value, errors);
		},

		validateValue: function(value, errors) {
			var self = this;
			var ok = Base.prototype.validateValue.call(self, value, errors);
			ok = validator.validate(self, value, errors, ["$minimum", "$maximum", "$exclusiveMinimum", "$exclusiveMaximum", "$precision"]) && ok;
			if (self.$type !== "application/x-integer") {
				ok = validator.validate(self, value, errors, ["$scale"]) && ok;
			}
			return ok;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/field/ctrlQuantity',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/controls/ctrlFactory'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');

var _Klass = utils.defineClass(

	function CtrlQuantity(controller, article, prototype, options) {
		Base.call(this, controller, article, prototype, options);
		this.unitFieldInfo = prototype.getUnitFieldInfo();
		// Create extra control for UNIT in read only mode
		// !! if grid Cell we ca't create the control with createControl
		this.displayUnit = false;
		if (this.unitFieldInfo && this.unitFieldInfo.unitFieldProto && !this.unitFieldInfo.unitFieldProto.data("$isExcluded")) {
			this.displayUnit = options && options.displayCtx !== "table";
		}
		this.unitCtrl = null;
	}, Base, {

		initFormatter: function() {
			var valueProto = this.prototype.data('$value');
			return formatApi.getFormatter(valueProto.$type, valueProto.$format);
		},

		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this.unitCtrl) {
				this.unitCtrl.destroy();
				this.unitCtrl = null;
			}
		},

		buildHtml: function($$parent, controllerDao, buildOptions) {
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions);
			(this.$$elmt).addClass("s-m-qty");
			if (this.displayUnit) {
				this.unitCtrl = ctrlFactory.createControl(this.controller, this, {
					"$bind": this.unitFieldInfo.unitBindName,
				}, this.unitFieldInfo.unitFieldProto, {
					isUnit: true
				});
				this.unitCtrl.buildHtml(this.$$elmt, controllerDao, buildOptions);
			}
		},

		buildFieldValue: function(fieldSlot, buildOptions) {
			var valueSlot = Base.prototype.buildFieldValue.call(this, fieldSlot, buildOptions);
			var value = this.getFormattedValue(this.getValue());
			if (this.$isEditMode) {
				this.createMainInput(valueSlot, value);
			} else {
				this.appendTextValue(valueSlot, value);
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/field/ctrlCheckBox',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _Klass = utils.defineClass(

	function CtrlCheckbox(controller, article, prototype, options) {
		var self = this;
		Base.call(self, controller, article, prototype, options);
	}, Base, {
		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions);
			// value before title in edit mode
			/*if (self.$isEditMode) {
				self.$$elmt.addClass("s-m-valuefirst");
			}*/
		},
		buildFieldValue: function(fieldSlot, buildOptions) {
			var self = this;
			var valueSlot = Base.prototype.buildFieldValue.call(self, fieldSlot, buildOptions);
			var val = self.getValue();
			// Nothing displayed if no values otherwise we see only the icon (empty array cards)
			if (val == null) return;
			val = val === true;
			if (self.$isEditMode) {
				self.createMainInput(valueSlot, val, "checkbox");
			} else {
				valueSlot.appendChild(uiUtils.createDomElement("span", fontUtils.checkBoxIcon(val)));
			}
		},
		onClick: function(evt) {
			var self = this;
			setTimeout(function() {
				self.domInput.checked = !self.domInput.checked;
				self.setValue(self.domInput.checked);
			}, 50);
		}

	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/field/ctrlCombo',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/controls/field/ctrlFieldBase'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;

var _compareEnum = function(enum1, enum2) {
	if (!enum1 || !enum2) return false;
	if (enum1.length != enum2.length) return false;
	for (var i = 0, l = enum1.length; i < l; i++) {
		if (enum1.$value != enum2.$value) return false;
		if (enum1.$title != enum2.$title) return false;
	}
	return true;
};
var _Klass = utils.defineClass(

	function CtrlCombo(controller, article, prototype, options) {
		Base.call(this, controller, article, prototype, options);
	}, Base, {
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			this.radioItemList = null;
			this._choiceList = null;
			this.valueSlot = null;
		},
		/**
		 * Not called on refreshValue - only at creation
		 */
		buildFieldValue: function(fieldSlot, buildOptions) {
			// create the $$value slot at creation
			this.valueSlot = Base.prototype.buildFieldValue.call(this, fieldSlot, buildOptions);
			// Else _updateList manages the update of list and value
			this._updateList(this.getMetaData(), false);
		},
		/**
		 * Refresh only the value if it changed
		 */
		refreshValue: function(buildOptions) {
			this._updateList(this.getMetaData(), true);
		},
		_updateList: function(metaData, valueChanged) {
			var self = this;
			if (!self.valueSlot) return;
			var newList = metaData && metaData.$value ? metaData.$value.$enum : null;
			if (valueChanged !== true && _compareEnum(newList, self._choiceList)) return;
			$(self.valueSlot).empty();
			// We need to clone because the deltaManager modifies the content of the list
			self._choiceList = $.extend(true, [], newList);
			if (self.$isEditMode) {
				var $format = metaData ? metaData.$format : null;
				if (!$format) {
					$format = self.prototype.data("$format");
				}
				// if '$format' is set it can only have values '$combo' or '$radio'
				if ($format && ($format != '$radios' && $format != '$combo')) {
					$format = '$combo';
				}
				// ## set display in case of edit mode ##
				var value = self.currentValue = self.getValue();
				var domValue;
				if (self._choiceList.length > 0) {
					// display in case of '$radios' format
					if ($format == '$radios') {
						self.radioItemList = [];
						$.each(self._choiceList, function(index, choiceItem) {
							// building choice item display
							var choiceItemDom = uiUtils.createDomElement("div", ["s-m-field-radio-item"]);
							var inputDom = uiUtils.createDomElement("input", ["s-m-field-choice-radio", "ctrl-evt-click", "s-m-meta"], null, {
								"type": "radio",
								"value": index,
								"name": "s-m-radio-" + self.id
							});
							if (value && choiceItem.$value == value) {
								inputDom.setAttribute("checked", true);
							}
							var titleDom = uiUtils.createDomElement("div", ["s-m-field-choice-radio-title"], choiceItem.$title);

							// build radioItemList array
							self.radioItemList.push({
								"inputDom": inputDom,
								"titleDom": titleDom
							});
							// appending to parent layout
							self.valueSlot.appendChild(inputDom);
							self.valueSlot.appendChild(titleDom);
						});
					}
					// default format is '$combo'
					else {
						var selectDom = uiUtils.createDomElement("select", ["form-control ctrl-evt-change", "s-m-meta"]);
						// build list
						$.each(self._choiceList, function(index, choiceItem) {
							var parsedTitle = self.prototype.resolveExpression(choiceItem.$title);
							var optDom = uiUtils.createDomElement("option", null, parsedTitle, {
								"value": choiceItem.$value
							}, selectDom);
							if ((choiceItem.$value == value) || (!value && index == 0)) {
								optDom.setAttribute("selected", true);
							}
						});

						// Apply metaData.$isReadOnly and/or metaData.$isDisabled on select
						// select can only be set as readonly with the 'disabled' attribute
						if (metaData.$isReadOnly || metaData.$isDisabled) {
							selectDom.setAttribute("disabled", true);
						} else {
							selectDom.removeAttribute("disabled");
						}


						self.valueSlot.appendChild(selectDom);
					}
				}
			} else if (self._choiceList.length > 0) {
				// ## set display in case of edit mode ##
				var value = self.currentValue = self.getValue();
				value = self._getChoiceTitle(value);
				value = self.prototype.resolveExpression(value);
				self.appendTextValue(self.valueSlot, value);
			}
		},
		_getChoiceTitle: function(value) {
			var res;
			$.each(this._choiceList, function(index, choice) {
				res = choice.$value == value ? choice.$title : res;
				if (res) {
					return false;
				}
			});
			return res;
		},
		getChoiceTitles: function() {
			var res = [],
				self = this;
			$.each(this._choiceList, function(index, choice) {
				res.push({
					$value: choice.$value,
					title: self.prototype.resolveExpression(choice.$title)
				});
			});
			return res;
		},
		_getChoiceValue: function(title) {
			var res;
			$.each(this._choiceList, function(index, choice) {
				res = choice.$title == title ? choice.$value : res;
				if (res) {
					return false;
				}
			});
			return res;
		},
		setDisplayValue: function(value, index, pickerText) {
			var self = this;
			if (self.$isEditMode) {
				// in case of radio choice
				if (self.prototype.data("$format") == '$radios') {
					// apply change if new value
					if (value != self.currentValue) {
						// update widget
						$.each(self.radioItemList, function(idx, radioItem) {
							setTimeout(function() {
								// if new choice index is defined
								if (index) {
									radioItem.inputDom.checked = index == idx;
								}
								// if new choice index is not defined
								else {
									radioItem.inputDom.checked = self._choiceList[idx].$value == value;
								}
							}, 5);
						});
					}
				}

			}
		},

		setFieldValue: function(value, index, pickerText) {
			this.setDisplayValue(value, index, pickerText);
			this.currentValue = value;
			this.setValue(value);
		},

		onClick: function(evt) {
			if (this.prototype.data("$format") == '$radios') {
				this.setFieldValue(this._getChoiceValue(evt.target.nextElementSibling.textContent), $(evt.target.parentNode).index());
			}
		},

		onChange: function(evt) {
			this.setFieldValue(evt.target.value, evt.target.selectedIndex, evt.target.options[evt.target.options.selectedIndex].textContent);
			//this.setFieldValue($(evt.target).val(), evt.target.selectedIndex, $(evt.target).text());
		},


		applyMetaData: function(metaData) {
			Base.prototype.applyMetaData.call(this, metaData);
			this._updateList(metaData);
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/monthChoice',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/types/date'],function (require, exports, module) {
var utils = require('syracuse-tablet/html/js/helpers/utils');
var _dateApi = require('syracuse-tablet/html/js/helpers/types/date');

var _Klass = utils.defineClass(

	function() {

	}, null, {
		create: function(parentSlot, dateValue, handler) {
			this.parent = parentSlot;
			this.handler = handler;
			this.domItem = document.createElement("nav");
			this.domItem.className = "s-calendar-quick-list";
			this._dateValue = dateValue;
			var table = document.createElement("table");
			table.className = "s-calendar-month-choice";
			var tbody = document.createElement("tbody");
			for (var ii = 0; ii < 6; ii++) {
				var row = document.createElement("tr");
				row.appendChild(this.drawCell(ii + 1, _dateApi.monthName(ii + 1, true), this._dateValue.month));
				row.appendChild(this.drawCell(ii + 7, _dateApi.monthName(ii + 7, true), this._dateValue.month));
				tbody.appendChild(row);
			}
			table.appendChild(tbody);
			this.domItem.appendChild(table);
			this.parent.appendChild(this.domItem);
			this.bindEvents(true);
		},
		drawCell: function(value, text, selValue) {
			var td = document.createElement("td");
			td.className = "s-calendar-my-item";
			td.syraOnClick = "onMonthClick";
			td.syraValue = value;
			td.textContent = text;
			if (value == selValue) {
				td.className += " s-calendar-select";
				this.selectedCell = td;
			}
			return td;
		},
		toggle: function(show) {
			if (show) {
				this.domItem.style.display = "";
			} else {
				this.domItem.style.display = "none";
			}
		},
		onMonthClick: function(picker) {
			if (this.selectedCell) {
				this.selectedCell.className = "s-calendar-my-item";
			}
			(this.selectedCell = picker).className = "s-calendar-my-item s-calendar-select";
			this._selectedMonth = picker.syraValue;
			var month = this._selectedMonth ? this._selectedMonth : this._dateValue.month;
			this._currentDate = this._dateValue = _dateApi.fromJsDate(new Date(this._dateValue.year, month - 1, this._dateValue.day));
			this.handler.onEvent("onCalendarUpdate", this);
		},
		bindEvents: function(bind) {
			var self = this;
			if (bind) {
				$(self.domItem).delegate("td", "click", function(evt) {
					self.onClick(evt);
					evt.preventDefault();
					evt.stopPropagation();
				});
			} else {
				$(self.domItem).undelegate();
			}
		},
		onClick: function(evt) {
			var self = this;
			while (evt.target) {
				if (evt.target.syraOnClick) {
					this[evt.target.syraOnClick](evt.target, evt);
					return;
				} else {
					evt.target = evt.target.parentNode;
				}
			}
		},
		destroy: function() {
			this.bindEvents(false);
			this.domItem = this._dateValue = this.selectedCell = null;
		}
	});

exports.MonthChoice = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/yearChoice',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/types/date'],function (require, exports, module) {
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var _dateApi = require('syracuse-tablet/html/js/helpers/types/date');


var _Klass = utils.defineClass(

	function() {

	}, null, {
		create: function(parentSlot, dateValue, handler) {
			this.parent = parentSlot;
			this.domItem = document.createElement("nav");
			this.domItem.className = "s-calendar-quick-list";
			this.handler = handler;
			this._dateValue = dateValue;
			this._selectedYear = this._dateValue.year;
			var table = document.createElement("table");
			table.className = "s-calendar-year-choice";
			var tbody = document.createElement("tbody");
			this.rows = [];
			for (var ii = 0; ii < 6; ii++) {
				var row = document.createElement("tr");
				if (ii == 0) {
					this.addPrevNextCell(row, true);
					this.addPrevNextCell(row, false);
				} else {
					var cuYear = this._dateValue.year + ii - 4;
					row.appendChild(this.drawCell(cuYear, cuYear));
					row.appendChild(this.drawCell(cuYear + 5, cuYear + 5));
				}
				tbody.appendChild(row);
				this.rows.push(row);
			}
			table.appendChild(tbody);
			this.domItem.appendChild(table);
			this.parent.appendChild(this.domItem);
			this.bindEvents(true);
		},
		addPrevNextCell: function(row, isPrev) {
			var td = document.createElement("td");
			td.className = "s-calendar-my-link-cell";
			var link = document.createElement("a");
			link.className = (link.syraIsPrev = isPrev) ? "s-calendar-prev-year" : "s-calendar-next-year";
			link.textContent = (link.syraIsPrev = isPrev) ? locale.text("date.month.label.prev") : locale.text("date.month.label.next");
			link.syraOnClick = "onChangeYear";
			td.appendChild(link);
			row.appendChild(td);
		},
		drawCell: function(value, text) {
			var td = document.createElement("td");
			td.className = "s-calendar-my-item";
			td.syraOnClick = "onSelectYear";
			td.syraValue = value;
			td.textContent = text;
			if (value == this._selectedYear) {
				td.className += " s-calendar-select";
				this.selectedCell = td;
			}
			return td;
		},
		toggle: function(show) {
			if (show) {
				this.domItem.style.display = "";
			} else {
				this.domItem.style.display = "none";
			}
		},
		_refreshYearCell: function(td, step) {
			td.syraValue += step;
			td.textContent = td.syraValue;
			if (td.syraValue == this._selectedYear) {
				td.className += " s-calendar-select";
				this.selectedCell = td;
			}
		},
		onChangeYear: function(picker) {
			var step = picker.syraIsPrev ? (-10) : 10;
			for (var ii = 1, jj = this.rows.length; ii < jj; ii++) {
				var nodes = this.rows[ii].childNodes;
				this._refreshYearCell(nodes[0], step);
				this._refreshYearCell(nodes[1], step);
			}
		},
		onSelectYear: function(picker) {
			if (this.selectedCell) {
				this.selectedCell.className = "s-calendar-my-item";
			}(this.selectedCell = picker).className = "s-calendar-my-item s-calendar-select";
			this._selectedYear = picker.syraValue;
			var year = this._selectedYear ? this._selectedYear : this._dateValue.year;
			this._currentDate = this._dateValue = _dateApi.fromJsDate(new Date(year, this._dateValue.month, this._dateValue.day));
			this.handler.onEvent("onCalendarUpdate", this);
		},
		bindEvents: function(bind) {
			var self = this;
			if (bind) {
				$(self.domItem).delegate("td", "click", function(evt) {
					self.onClick(evt);
					evt.preventDefault();
					evt.stopPropagation();
				});
			} else {
				$(self.domItem).undelegate();
			}
		},
		onClick: function(evt) {
			var self = this;
			while (evt.target) {
				if (evt.target.syraOnClick) {
					this[evt.target.syraOnClick](evt.target, evt);
					return;
				} else {
					evt.target = evt.target.parentNode;
				}
			}
		},
		destroy: function() {
			this.bindEvents(false);
			//this.parent.removeChild(this.domItem);
			this.rows = this.domItem = this._dateValue = this.selectedCell = null;
		}
	});

exports.YearChoice = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/types/date','syracuse-tablet/html/js/ui/datetimeSelectors/monthChoice','syracuse-tablet/html/js/ui/datetimeSelectors/yearChoice'],function (require, exports, module) {
var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var _dateApi = require('syracuse-tablet/html/js/helpers/types/date');
var MonthChoice = require('syracuse-tablet/html/js/ui/datetimeSelectors/monthChoice').MonthChoice;
var YearChoice = require('syracuse-tablet/html/js/ui/datetimeSelectors/yearChoice').YearChoice;

var _Klass = utils.defineClass(

	function() {

	}, null, {
		onClick: function(evt) {
			var self = this,
				close;
			while (evt.target && evt.target != self.handler.parentSlot) {
				if (evt.target.getAttribute("data-s-syraOnClick")) {
					close = this[evt.target.getAttribute("data-s-syraOnClick")](evt.target, evt);
					if (close) {
						this.handler.closeContainer();
					}
					return;
				} else {
					evt.target = evt.target.parentNode;
				}
			}
		},
		onTodayClick: function() {
			this._currentDate = _dateApi.today();
			this.field.setFieldValue(_dateApi.fromInternalValue(this._currentDate._value).toString());
			return true;
		},
		onDayClick: function(picker) {
			this.field.setFieldValue(_dateApi.fromInternalValue(picker.getAttribute("data-s-syraValue")).toString());
			return true;
		},
		onChangePeriode: function(picker) {
			if (picker.getAttribute("data-s-syraPeriod") == "month") {
				this._currentDate = this._currentDate.addMonths(picker.getAttribute("data-s-syraIsPrev") ? -1 : 1);
			} else if (picker.getAttribute("data-s-syraPeriod") == "year") {
				this._currentDate = this._currentDate.addYears(picker.getAttribute("data-s-syraIsPrev") ? -1 : 1);
			} else {
				this._currentDate = this._currentDate.addDays(picker.getAttribute("data-s-syraIsPrev") ? -7 : 7);
			}
			this.handler.onEvent("onCalendarUpdate", this);
		},
		onMonthClick: function() {
			this.handler.onEvent("onMonthClick", this);
		},
		onYearClick: function() {
			this.handler.onEvent("onYearClick", this);
		},
		getValueForSelector: function(field) {
			return field.getValue() && field.getValue().slice(0, 10);
		},
		create: function(field, handler) {
			this.domItem = document.createElement("div");
			this.domItem.className = "s-calendar";

			var value = this.getValueForSelector(field) || "";

			this._selectedDate = value ? _dateApi.parse(value) : _dateApi.today();
			this._selectedDate = this._selectedDate._value == 0 ? _dateApi.today() : this._selectedDate;
			this._currentDate = handler._currentDate || _dateApi.fromInternalValue(this._selectedDate._value);

			this.field = field;
			this.handler = handler;

			this._table = document.createElement("table");
			this._table.setAttribute("cellspacing", 0);
			this._table.className = "s-calendar-content";
			this._table.appendChild(this._appendHead());
			this._table.appendChild(this.body = document.createElement("tbody"));
			this._table.appendChild(this._appendFoot());
			this.domItem.appendChild(this._table);

			this._drawBody();

			return this.domItem;
		},
		_appendHead: function() {
			var head = document.createElement("thead");
			var row = document.createElement("tr");
			var cell = document.createElement("th");
			cell.setAttribute("colspan", 8);
			cell.className = "s-calendar-month-year";

			var slot = document.createElement("div");
			slot.className = "s-calendar-month-year-slot";
			cell.appendChild(slot);

			// prev year link
			var link = document.createElement("a");
			link.setAttribute("data-s-syraOnClick", "onChangePeriode");
			link.setAttribute("data-s-syraIsPrev", true);
			link.setAttribute("data-s-syraPeriod", "year");
			link.className = "s-calendar-prev s-calendar-prev-year glyphicon glyphicon-fast-backward";
			slot.appendChild(link);

			// prev month link
			link = document.createElement("a");
			link.setAttribute("data-s-syraOnClick", "onChangePeriode");
			link.setAttribute("data-s-syraIsPrev", true);
			link.setAttribute("data-s-syraPeriod", "month");
			link.className = "s-calendar-prev s-calendar-prev-month glyphicon glyphicon-step-backward";
			slot.appendChild(link);

			this._monthLink = document.createElement("a");
			this._monthLink.className = "s-month s-calendar-month-year-link";
			slot.appendChild(this._monthLink).setAttribute("data-s-syraOnClick", "onMonthClick");

			this._yearLink = document.createElement("a");
			this._yearLink.className = "s-year s-calendar-month-year-link";
			slot.appendChild(this._yearLink).setAttribute("data-s-syraOnClick", "onYearClick");

			// next month link
			link = document.createElement("a");
			link.setAttribute("data-s-syraOnClick", "onChangePeriode");
			link.setAttribute("data-s-syraPeriod", "month");
			link.className = "s-calendar-next s-calendar-next-month glyphicon glyphicon-step-forward";
			slot.appendChild(link);

			// next year link
			link = document.createElement("a");
			link.setAttribute("data-s-syraOnClick", "onChangePeriode");
			link.setAttribute("data-s-syraPeriod", "year");
			link.className = "s-calendar-next s-calendar-next-year glyphicon glyphicon-fast-forward";
			slot.appendChild(link);

			row.appendChild(cell);
			head.appendChild(row);

			row = document.createElement("tr");
			var cell = document.createElement("th");
			cell.className = "s-calendar-week-day";
			row.appendChild(cell);

			var days = [1, 2, 3, 4, 5, 6, 0];
			for (var ii = 0, jj = days.length; ii < jj; ii++) {
				var cell = document.createElement("th");
				cell.className = "s-calendar-week-day";
				cell.title = _dateApi.dayName(days[ii]);
				cell.textContent = _dateApi.dayName(days[ii], true);
				row.appendChild(cell);
			}
			head.appendChild(row);
			return head;
		},
		_appendFoot: function() {
			var row = document.createElement("tr");
			var cell = document.createElement("td");
			cell.setAttribute("colspan", 3);
			cell.className = "s-calendar-foot-week";

			var link = document.createElement("a");
			link.setAttribute("data-s-syraOnClick", "onChangePeriode");
			link.setAttribute("data-s-syraPeriod", "week");
			link.className = "s-calendar-prev s-calendar-prev-week glyphicon glyphicon-chevron-left";
			link.setAttribute("data-s-syraIsPrev", true);
			cell.appendChild(link);

			var label = document.createElement("label");
			label.className = "s-calendar-foot-week-title";
			label.textContent = locale.text("date.label.week");
			cell.appendChild(label);

			this._weekNumber = document.createElement("label");
			this._weekNumber.className = "s-calendar-foot-week-title-num";
			cell.appendChild(this._weekNumber);

			link = document.createElement("a");
			link.setAttribute("data-s-syraOnClick", "onChangePeriode");
			link.setAttribute("data-s-syraPeriod", "week");
			link.className = "s-calendar-next s-calendar-next-week glyphicon glyphicon-chevron-right";
			cell.appendChild(link);
			row.appendChild(cell);

			cell = document.createElement("td");
			cell.setAttribute("colspan", 3);
			cell.className = "s-calendar-foot-today";
			link = document.createElement("a");
			link.className = "s-calendar-today-link";
			link.setAttribute("data-s-syraOnClick", "onTodayClick");

			link.textContent = locale.text("date.label.today");
			cell.appendChild(link);
			row.appendChild(cell);

			cell = document.createElement("td");
			cell.setAttribute("colspan", 2);

			row.appendChild(cell);

			var foot = document.createElement("tfoot");
			foot.appendChild(row);
			return foot;
		},
		_drawBody: function() {

			var curMonth = this._currentDate.month || 9;
			var month = _dateApi.monthName(curMonth);

			this._monthLink.textContent = month;
			this._yearLink.textContent = this._currentDate.year || 2014;

			uiUtils.empty(this.body);

			var curDate = _dateApi.fromInternalValue(this._currentDate._value);
			var begOfMonth = curDate = curDate.begOfMonth();
			curDate = curDate.begOfWeek(1);

			for (var weekRow = 0; weekRow < 6; weekRow++) {
				var row = document.createElement("tr");
				var weekDay = (weekRow == 0) ? begOfMonth : curDate;
				var cell = document.createElement("td");
				cell.className = "s-calendar-week-num";
				row.appendChild(cell);
				cell.textContent = weekDay.week;
				for (var day = 0; day < 7; day++) {
					var cell = document.createElement("td");
					cell.className = "s-calendar-day-link";
					cell.setAttribute("data-s-syraOnClick", "onDayClick");
					cell.setAttribute("data-s-syraValue", curDate._value);
					var link = document.createElement("a");
					link.textContent = curDate.day;
					if (curMonth != curDate.month) {
						cell.className += " s-calendar-other-month";
					}
					if (this._currentDate.equals(curDate)) {
						cell.className += " s-calendar-select";
						link.className = "s-calendar-select";
					}
					cell.appendChild(link);
					row.appendChild(cell);
					curDate = curDate.addDays(1);
				}
				this.body.appendChild(row);
			}
			this._weekNumber.textContent = this._currentDate.week;
		},
		bindEvents: function(bind) {
			var self = this;
			var parentSlot = self.handler.getParentSlot();
			if (bind) {
				$(parentSlot).delegate("td, a", "click", function(evt) {
					self.onClick(evt);
					evt.preventDefault();
					evt.stopPropagation();
				});
			} else {
				$(parentSlot).undelegate();

				// unbind monthchoice and yearchoice components if necessary
				if (self._month) {
					self._month.bindEvents(false);
				}
				if (self._year) {
					self._year.bindEvents(false);
				}
			}
		},
		destroy: function() {
			this.bindEvents(false);
			this._currentDate = this.field = this._currentDate = this.quickList = this._month = this._year = this._selectedDate = this._monthLink = this._yearLink = this._weekNumber = this._quick = this.body = this.domItem = null;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/timeSelector',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/types/time','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {
var utils = require('syracuse-tablet/html/js/helpers/utils');
var _timeApi = require('syracuse-tablet/html/js/helpers/types/time');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _Klass = utils.defineClass(

	function() {

	}, null, {
		onClick: function(evt) {
			var self = this,
				close;
			while (evt.target) {
				if (evt.target.getAttribute("data-s-syraOnClick")) {
					close = this[evt.target.getAttribute("data-s-syraOnClick")](evt.target, evt);
					if (close) {
						this.handler.closeContainer();
					}
					return;
				} else {
					evt.target = evt.target.parentNode;
				}
			}
		},
		setContainer: function($$modalElmt) {
			this.$$modalElmt = $$modalElmt;
		},
		create: function(field, handler, cb) {

			this.domItem = document.createElement("div");
			this.domItem.className = "s-time-choice";

			var options = options || {};
			this.columns = options.columns || 2;
			this.interval = options.interval || 60;

			this.field = field;
			this.handler = handler;
			this.cb = cb;

			this.curTime = _timeApi.now();

			var cellCount = (24 * 60) / this.interval;
			var rowCount = cellCount / this.columns;

			var table = document.createElement("table");
			table.className = "s-time-choice-table";
			table.setAttribute("cellspacing", "0");
			table.setAttribute("cellpadding", "0");

			var row, cell;
			var cellIndex = 0;
			var timeHour = _timeApi.parse("00:00:00");
			for (var rr = 0; rr < rowCount; rr++) {
				row = document.createElement("tr");
				for (var col = 0; col < this.columns; col++) {
					cell = document.createElement("td");
					cell.className = "s-time-choice-td";
					if (cellIndex < cellCount) {
						var link = document.createElement("a");
						link.className = "s-time-choice-a";
						link.setAttribute("data-s-syraOnClick", "onTimeClick");
						if (timeHour.hour == this.curTime.hour) {
							link.className += " s-time-select";
						}
						link.textContent = timeHour.toString(locale.getTimeFormat());
						cell.appendChild(link);
					}
					row.appendChild(cell);
					timeHour = timeHour.addMinutes(this.interval);
					cellIndex++;
				}
				table.appendChild(row);
			}
			this.domItem.appendChild(table);
			return this.domItem;
		},
		onTimeClick: function(picker) {
			var self = this;
			var fieldVal = _timeApi.parse(picker.textContent, locale.getTimeFormat()).toString();
			if (!this.cb) {
				self.field.setFieldValue(fieldVal);
				return true;
			} else {
				self.cb(fieldVal, self.handler);
			}
		},
		bindEvents: function(bind) {
			var self = this;
			var parentSlot = self.handler.getParentSlot();
			if (bind) {
				$(parentSlot).delegate("a", "click", function(evt) {
					self.onClick(evt);
					evt.preventDefault();
					evt.stopPropagation();
				});
			} else {
				$(parentSlot).undelegate();
			}
		},
		destroy: function() {
			this.bindEvents(false);
			this.domItem = this.field = this.selectedLink = null;
		}
	});
exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/selectorSwitchHandler',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/datetimeSelectors/monthChoice','syracuse-tablet/html/js/ui/datetimeSelectors/yearChoice','syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector','syracuse-tablet/html/js/ui/datetimeSelectors/timeSelector'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require("syracuse-tablet/html/js/ui/uiUtils");
var MonthChoice = require('syracuse-tablet/html/js/ui/datetimeSelectors/monthChoice').MonthChoice;
var YearChoice = require('syracuse-tablet/html/js/ui/datetimeSelectors/yearChoice').YearChoice;
var DateSelector = require('syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector').Klass;
var TimeSelector = require('syracuse-tablet/html/js/ui/datetimeSelectors/timeSelector').Klass;

var _Klass = utils.defineClass(

	function(field) {
		this.field = field;
	}, null, {
		/**
		Triggers an action when the following events occurs :
		- onMonthClick : When user clicks on month selection link
		- onYearClick : When user clicks on year selection link
		- onOpenTime : In case of datetime field, when user has selected the date, time selector must be displayed afterwards
		- onCalendarUpdate : When user clicks on links that will reshape the calendar (change month, change year, change week, select month, select year)
		- onSelectTime : In case of datetime field, when user has selected the time, field must be set with appropriate date + time value

		@param	evt 		Triggered event in set as string
		@param	selector 	The selector object. Use to get value and for destroy action
		*/
		onEvent: function(evt, selector) {
			this[evt](selector);
		},

		/*
			Set the $$container of the date / time selectors which is likely to be the modal.
			It will make it easier to close it from within the library
			@param	$$container 	Jquery container object (the modal)
		*/
		setContainer: function($$container) {
			this.$$container = $$container;
		},

		/*
			Set parentSlot dom parameter. Useful to make some dom actions like emptying or appending.
			It is the modal body
			@param parentSlot Modal body.

		*/
		setParentSlot: function(parentSlot) {
			this.parentSlot = parentSlot;
		},


		/*
			Returns parentSlot dom parameter
		*/
		getParentSlot: function() {
			return this.parentSlot;
		},

		/*
			Triggered when user clicks on month selection link. It builds the month selector
			@param 	selector 	The selector object. Use to get value and for destroy action
		*/
		onMonthClick: function(selector) {
			var self = this;
			// save date
			var date = selector._currentDate;

			// clear previous selector
			uiUtils.empty(self.parentSlot);
			selector.destroy();

			// create month selector
			var monthChoice = new MonthChoice();
			monthChoice.create(this.parentSlot, date, self);
		},

		/*
			Triggered when user clicks on year selection link. It builds the year selector
			@param 	selector 	The selector object. Use to get value and for destroy action
		*/
		onYearClick: function(selector) {
			var self = this;
			// save date
			var date = selector._currentDate;

			// clear previous selector
			uiUtils.empty(self.parentSlot);
			selector.destroy();

			// create month selector
			var yearChoice = new YearChoice();
			yearChoice.create(self.parentSlot, date, self);
		},


		/*
			Triggered in case of datetime field. It builds time selector after user clicked on date
			@param 	selector 	The selector object. Use to get value and for destroy action
		*/
		onOpenTime: function(selector) {
			var self = this;

			// save date
			self.dateValue = selector.dateValue;

			// clear previous selector
			uiUtils.empty(self.parentSlot);
			selector.destroy();

			// create time selector
			var timeSelector = new TimeSelector();
			var sDom = timeSelector.create(self.field, self, self.onSelectTime);
			self.parentSlot.appendChild(sDom);
			timeSelector.bindEvents(true);
		},

		/*
			Triggered when user clicks on link that will update the calendar. It builds the calendar with updated value
			@param 	selector 	The selector object. Use to get value and for destroy action
		*/
		onCalendarUpdate: function(selector) {
			var self = this;

			// save date
			self._currentDate = selector._currentDate;

			// clear previous selector
			uiUtils.empty(self.parentSlot);
			selector.destroy();

			// create back date selector
			var dateSelector = new DateSelector();
			var sDom = dateSelector.create(self.field, self);
			self.parentSlot.appendChild(sDom);
			dateSelector.bindEvents(true);
		},

		/*
			Triggered in case of datetime field. It sets the final field value and closes the container (the modal)
			@param 	selector 	The selector object. Use to get value and for destroy action
		*/
		onSelectTime: function(timeVal, handler) {
			var self = handler;
			self.field.setFieldValue(self.dateValue + " " + timeVal);
			self.closeContainer();
		},

		/*
			Closes the container (the modal here)
		*/
		closeContainer: function() {
			this.$$container.modal("hide");
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/datetimeSelector',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/types/date','syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector'],function (require, exports, module) {
var utils = require('syracuse-tablet/html/js/helpers/utils');
var _dateApi = require('syracuse-tablet/html/js/helpers/types/date');
var Base = require('syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector').Klass;

var _Klass = utils.defineClass(

	function() {

	}, Base, {
		onTodayClick: function() {
			this._currentDate = _dateApi.today();
			this.dateValue = _dateApi.fromInternalValue(this._currentDate._value).toString();
			this.handler.onEvent("onOpenTime", this);
		},
		onDayClick: function(picker) {
			this.dateValue = _dateApi.fromInternalValue(picker.getAttribute("data-s-syraValue")).toString();
			this.handler.onEvent("onOpenTime", this);
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/ui/datetimeSelectors/selectorFactory',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/ui/datetimeSelectors/selectorSwitchHandler','syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector','syracuse-tablet/html/js/ui/datetimeSelectors/datetimeSelector','syracuse-tablet/html/js/ui/datetimeSelectors/timeSelector'],function (require, exports, module) {

var globals = require('syracuse-tablet/html/js/helpers/globals');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var SelectorHandler = require('syracuse-tablet/html/js/ui/datetimeSelectors/selectorSwitchHandler').Klass;

var _selectors = {
	date: {
		"windows": null,
		"android": null,
		"ios": null,
		"default": require('syracuse-tablet/html/js/ui/datetimeSelectors/dateSelector').Klass
	},
	datetime: {
		"windows": null,
		"android": null,
		"ios": null,
		"default": require('syracuse-tablet/html/js/ui/datetimeSelectors/datetimeSelector').Klass
	},
	time: {
		"windows": null,
		"android": null,
		"ios": null,
		"default": require('syracuse-tablet/html/js/ui/datetimeSelectors/timeSelector').Klass
	}
};

/*
	Returns appropriate selector controller according to field type
	@param	propertyType 	Field property type application/x-{date,time,datetime}
*/
var getSelector = function(propertyType) {
	var type;
	switch (propertyType) {
		case "application/x-date":
			type = "date";
			break;
		case "application/x-datetime":
			type = "datetime";
			break;
		case "application/x-time":
			type = "time";
			break;
		default:
			throw new Error("Expected date/time/datetime type. Got " + propertyType);
	}

	var laf = globals.getLookAndFeel();
	var selector = _selectors[type]; // select for type
	if (selector) {
		selector = selector[laf] || selector["default"]; // select per OS or use default
	}

	if (!selector) {
		throw new Error("Expected date/time/datetime type. Got " + propertyType);
	}
	return new selector();
};


/*
	Creates selector widget
	@param	field 	Field controller
*/
var _createSelector = function(field) {
	// selector handler
	var sHandler = new SelectorHandler(field);

	// selector controller (date/time/datetime according to type)
	var ctrlSelector = getSelector(field.$type);

	// selector dom
	var selectorDom = ctrlSelector.create(field, sHandler);

	var $$selectorModal = modal.field(field.getTitle(), selectorDom.outerHTML, function(modalEvent, $$modalElmt) {
		// build content on open
		if (modalEvent == 'shown.bs.modal') {
			sHandler.setContainer($$modalElmt);
			sHandler.setParentSlot($$modalElmt.find(".modal-body")[0]);
			ctrlSelector.bindEvents(true);
		}

		// run actions on close 'hidden.bs.modal'
		else {
			ctrlSelector.destroy();
		}
	});

};

exports.createSelector = _createSelector;
});

define('syracuse-tablet/html/js/controls/field/ctrlDate',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/datetimeSelectors/selectorFactory','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var selectorFactory = require('syracuse-tablet/html/js/ui/datetimeSelectors/selectorFactory');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _Klass = utils.defineClass(

	function CtrlBase(controller, article, prototype, options) {
		var self = this;
		Base.call(self, controller, article, prototype, options);
	}, Base, {
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			this.picker = null;
		},
		buildFieldValue: function(fieldSlot, buildOptions) {
			var self = this;
			var valueSlot = Base.prototype.buildFieldValue.call(self, fieldSlot, buildOptions);
			var value = self.getFormattedValue(self.getValue());
			if (self.$isEditMode) {
				var inputGroup = uiUtils.createDomElement("div", ["input-group"], null, null, valueSlot);
				self.createMainInput(inputGroup, value);
				var span = uiUtils.createDomElement("span", ["input-group-btn"], null, null, inputGroup);
				self.picker = uiUtils.createDomElement("button", ["btn", "btn-default", "s-m-meta"], null, null, span);
				uiUtils.createDomElement("span", fontUtils.dateFieldIcon(self.$type), null, null, self.picker);
				$(self.picker).click(function() {
					selectorFactory.createSelector(self);
				});
			} else {
				self.appendTextValue(valueSlot, value);
			}
		},
		setFieldValue: function(value) {
			if (this.$type.indexOf("datetime") > -1 && value.length <= 10) {
				value += "T00:00:00.0Z";
			}
			Base.prototype.setFieldValue.call(this, value);
		},
		getFieldFormat: function() {
			return this.formatter.format;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/array/searchArray',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/fieldOperators'],function (require, exports, module) {
var utils = require('syracuse-tablet/html/js/helpers/utils');
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');

var _templates = {
	basicSearch: '\
		<nav class="s-m-search">\
            <div class="input-group stylish-input-group">\
                <input type="text" class="form-control"  placeholder="Search"  value="{{searchValue}}" >\
                <span class="input-group-addon">\
                    <span style="visibility:{{visibleRemove}}" class="glyphicon glyphicon-remove" data-action="actionArray" data-params="removeSearch"></span>\
					<span class="glyphicon glyphicon-search" data-action="actionArray" data-params="search"></span>\
                </span>\
            </div>\
		</nav>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

var _Klass = utils.defineClass(
	function() {
		this._exclude = {};
		this.searchValue = "";
		this.searchInfos = [];
		this.maxCrit = 13;
	}, null, {
		destroy: function() {
			this.searchValue = null;
			this.$$search = null;
			this.searchInfos = null;
		},
		getHtml: function() {
			var self = this;
			self.$$search = $(_getHtml("basicSearch", {
				searchValue: self.searchValue,
				visibleRemove: self.searchValue !== "" ? "visible" : "hidden"
			}));
			return self.$$search;
		},
		removeSearch: function(ctrl) {
			this.searchValue = "";
			this.searchInfos = [];
		},
		search: function(ctrl) {
			this.searchValue = $(":input", this.$$search).val();
			this.searchInfos = (this.searchValue != "") ? this._filterInofsGet(ctrl) : [];
		},
		_filterInofsGet: function(ctrl) {
			var columnInfo = ctrl.builder.getColumnsInfo(true);
			var proto = ctrl.prototype.create(ctrl.prototype.getDataByPath("$item"));
			var props = proto.data("$properties");
			var control, $bind, $type, $capabilities, self = this,
				formatter,
				criteria = [],
				errors, val, $isReference;

			columnInfo.forEach(function(column) {
				control = column.control;
				$bind = column.$bindValue;
				$type = (column.$type != "application/x-choice") ? column.$bindType : column.$type;
				$isReference = (column.$type.indexOf("x-reference") >= 0);
				$capabilities = column.$capabilities || "";
				if ($capabilities.indexOf("filter") >= 0 && criteria.length < self.maxCrit) {
					if (!self._exclude[$type] && self._hackFormat(props[$bind])) {
						if ($type !== "application/x-choice") {
							errors = [];
							val = null;
							formatter = formatApi.getFormatter($type, props[$bind].$format);
							if (!formatter) {
								val = self.searchValue;
							} else {
								val = formatter.parseValue(self.searchValue, errors);
							}
							if ($isReference && val) val = val.toUpperCase();
							if (errors.length === 0 && val !== undefined) {
								criteria.push({
									operator: fieldOperators.getDefaultOperator($type),
									id: $bind,
									value: val,
									prop: props[$bind],
									isReference: $isReference
								});
							}
						} else {
							var valueList = self._getChoiceTitles(column.$value, proto);
							valueList.forEach(function(val) {
								if (val.title.indexOf(self.searchValue) > -1 && criteria.length < self.maxCrit) {
									criteria.push({
										operator: fieldOperators.getDefaultOperator($type),
										id: $bind,
										value: val.$value,
										prop: props[$bind],
										isReference: $isReference
									});
								}
							});
						}
					}
				}
			});
			return criteria;
		},
		_getChoiceTitles: function($value, proto) {
			var res = [],
				self = this;
			$.each($value.$enum, function(index, choice) {
				res.push({
					$value: choice.$value,
					title: proto.resolveExpression(choice.$title)
				});
			});
			return res;
		},
		//Waitting for X3 format manager with strict mode
		_hackFormat: function(proto) {
			var searchable = true;
			switch (proto.$type) {
				case "application/x-integer":
					var gs = locale.getNumberGroupSeparator();
					var ds = locale.getNumberDecimalSeparator();
					searchable = !isNaN((gs && gs.length > 0) ? this.searchValue.replace(new RegExp("\\" + gs + "|\\s", "g"), "") : this.searchValue);
					searchable = searchable && ((ds && ds.length > 0) ? this.searchValue.indexOf(ds) < 0 : true);
					break;
				case "application/x-decimal":
				case "application/x-real":
				case "application/x-integer":
				case "application/x-quantity":
					searchable = !isNaN(this.searchValue.replace(new RegExp("\\.|,|\\s", "g"), ""));
					break;
				default:
					searchable = (proto.$maxLength) ? (this.searchValue.length <= proto.$maxLength) : true;
			};
			return searchable;
		},
		getSearchInfos: function() {
			return this.searchInfos;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/array/builderBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/hammerScroller'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var HammerScroller = require('syracuse-tablet/html/js/helpers/hammerScroller').Klass;

var _filterSortPanelId = globals.PANELFILTERSORT;

var _templates = {
	pagin: '\
			<nav class="s-m-pagin"> \
				<ul class="pagination"> \
					{{#each links}}\
						<li>\
							<a class="s-m-link {{css}}"\
								href = "#"\
								{{#if url}}\
									data-nav-refresh="true"\
									data-nav-type="{{type}}"\
									data-sdata-url="{{url}}"\
									data-control-id="{{id}}"\
									data-nav-target="{{target}}"\
								{{/if}}\
								draggable="false">\
							</a>\
						</li>\
					{{/each}}\
				</ul> \
			</nav> \
		',
	filterSort: '\
		<div class="s-m-filterSort" data-action="actionArray" data-params="{{panelId}}">\
			<i class="s-m-sorted" style="display:none"></i>\
			<i class="s-m-filtered ' + fontUtils.filterIcon("filtered") + '" style="display:none"></i>\
			<i class="' + fontUtils.filterIcon("panel") + '"></i>\
		</div>',
	$filtersList: '\
		<nav class="s-m-filterslist">\
			<select	class="form-control" data-action="actionArray">\
				{{#each filters}}\
					<option value="filterSelected,{{id}}" {{#if $isDefault}}selected=""{{/if}}>{{$title}}</option>\
				{{/each}}\
			</select>\
		</nav>',
	$filterstabs: '\
		<nav class="s-m-filtertabs">\
			<ul class="nav nav-pills nav-justified">\
				{{#each filters}}\
					<li role="presentation" role="tab" data-toggle="tab" data-action="actionArray" data-params="filterSelected,{{id}}" class="{{#if $isDefault}}active{{/if}}"><a href="#">{{$title}}</a></li>\
				{{/each}}\
			</ul>\
		</nav>'

};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	if (!tmpl) alert("template " + name + " not found");
	return tmpl(ctx);
};

var _isExcluded = ["application/x-password"];
var _paginLinks = ["$first", "$previous", "$next", "$last"]; //We don't display "$more" used to refresh the cache (disabled)
/**
 * Array builder base class
 * Authoring global properties
 * 		$isTitleHidden		Hide the column title
 * 		$rowIdx				Show/Hide row index
 */
var _Klass = utils.defineClass(
	function(control, disp, options) {
		this.$display = disp;
		this.options = options || {};
		if (control == null) throw new Error("Null control");
		this.control = control;
		this.$articleArray = control.article;
		this.$arrayOptions = this.$articleArray.$arrayOptions;
		this.$itemProto = control.prototype.getPrototype("$item");
		this._gestureMgr = null;
		this._lastSelectedRow = null;
	}, null, {
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {},
		destroy: function() {
			this.control = null;
			if (this.$itemProto) {
				// We destroy the proto
				this.$itemProto.destroy();
				this.$itemProto = null;
			}
			this.destroyScroller();
		},
		refresh: function(arrayData, buildOptions) {
			buildOptions = buildOptions || {};
			// Option for buildHtml
			buildOptions.refresh = true;
			this.buildHtml(arrayData, buildOptions);
		},
		/**
		 * $$value parent that contains the table - same strcture for all controls
		 * 	arrayData is an object that contains all data needed by array
		 * 	arrayData.$resources contains rows data - Array of dao
		 */
		buildHtml: function(arrayData, buildOptions, classes) {},
		isRefreshContext: function(buildOpts) {
			// We force display if it's an array in a card because there's no resize in that case
			return (buildOpts && (buildOpts.refresh === true || buildOpts.cardDesign === true)) || (this.options && this.options.displayCtx === "card");
		},
		buildEmptyArray: function() {
			this.refreshHeaderAndGesture();
			if (!this.control.isArrayField()) {
				$('<span>' + locale.text("array.empty") + '</span>').appendTo(this.control.$$value);
			}
		},
		onResize: function(context) {
			this.refreshHeaderAndGesture(context != null && context.scrollOnly, context != null && context.preserveScroll);
		},
		/**
		 * Init gesture manager on onResize because we need to calculate the viewRect
		 */
		refreshHeaderAndGesture: function(scrollOnly, preserveScroll) {
			/**
			 * Workaround to check if the display of filters changed
			 */
			if (scrollOnly !== true) {
				this._refreshHeader();
			}
			this._initGestureMgr(preserveScroll);
			if (this._lastSelectedRow) {
				/**
				 * Workaround to preserve last selected line
				 * onResize broke the regular process and onResize is call when we activate a cached page
				 * lastRowSelection is done before the onResize (page.activate) so we need to preserve the selection
				 * Here because the build of array is asynchronous so we can't call this code in ctrlArray.onResize
				 */
				this.selectLastSelectedRow(this._lastSelectedRow, true);
			}
		},
		_initGestureMgr: function(preserveScroll) {
			if (this._gestureMgr && this.control.getArrayData().$resources.length > 0) {
				// ScrollViewRect has changed so we check to re-init or reset _gestureMgr 
				this._gestureMgr.checkViewRect(this.control.getScrollViewRect(), preserveScroll);
			} else if (this._gestureMgr) {
				this._gestureMgr.reset();
			}
			if (this._restoreSelectedRowId) {
				// Restore the selected row - We do the job here to be able to make the line visible 
				var $$row = this.selectLastSelectedRow(this._restoreSelectedRowId, true);
				if ($$row && this._gestureMgr) {
					// Scroll to make row visible
					this._gestureMgr.makeVisible($$row);
				}
				this._restoreSelectedRowId = null;
			}
		},
		/**
		 * Display an error
		 */
		insertError: function(html) {
			var err = ['<div class="s-m-error">'];
			err.push(html);
			err.push("</div>");
			$(err.join('')).appendTo(this.control.$$elmt);
		},
		/**
		 * Refreshed header and filters
		 * We need to call _refreshHeader in onResize and buildHtml
		 * We display filters/sort and $filter when array is empty -> We need to be able to modify the filter if result returns no data
		 */
		_refreshHeader: function(buildOptions) {
			var $filtersAuth = null;
			var headerOpts = this.control.getHeaderOptions ? this.control.getHeaderOptions() : null;
			if (headerOpts && headerOpts.$filters && headerOpts.$filters.length > 1) {
				$filtersAuth = this.control.controller.$filtersGetAuthoring ? this.control.controller.$filtersGetAuthoring() : null;
			}
			if (this._isHeaderVisible($filtersAuth)) {
				this.control.$$header.children(".s-m-stdheader").remove();
				this._buildArrayHeader(this.control.getArrayData(), buildOptions, $filtersAuth);
			}
			if ($filtersAuth === "tabs") {
				// Displayed below  _$$stdHeader
				this.control.$$header.find(".s-m-filtertabs").remove();
				this._build$Filters(headerOpts.$filters, $filtersAuth);
			}
		},
		_isHeaderVisible: function($filtersAuth) {
			return this.$arrayOptions.showPagination ||
				this.$arrayOptions.showSortFilter ||
				this.$arrayOptions.showSearch ||
				$filtersAuth === "list";

		},
		_buildArrayHeader: function(arrayData, buildOptions, $filtersAuth) {
			var refresh = buildOptions && buildOptions.refresh;
			var headerOpts = this.control.getHeaderOptions ? this.control.getHeaderOptions() : {};

			this._$$stdHeader = $('<nav class="s-m-stdheader"/>').prependTo(this.control.$$header);
			if (headerOpts.paginEnabled === true && this.$arrayOptions.showPagination === true) {
				this._buildPagin(this._$$stdHeader, arrayData);
			}
			if (headerOpts.searchEnabled === true && this.$arrayOptions.showSearch === true) {
				this._$$stdHeader.append(this.control.getSearcher().getHtml());
			}
			if ((headerOpts.filterEnabled === true || headerOpts.sortEnabled === true) &&
				this.$arrayOptions.showSortFilter === true) {
				this._buildSortFilter(this._$$stdHeader);
			}


			if ($filtersAuth === "list") {
				this._build$Filters(headerOpts.$filters, $filtersAuth);
			}
		},
		_build$Filters: function(filters, $filtersAuth) {
			if (!$filtersAuth || $filtersAuth == "none") return;
			if ($filtersAuth == "list") {
				$(_getHtml("$filtersList", {
					filters: filters
				})).appendTo(this._$$stdHeader);
				return;
			}
			if ($filtersAuth == "tabs") {
				$(_getHtml("$filterstabs", {
					filters: filters
				})).appendTo(this.control.$$header);
				return;
			}
		},
		_buildPagin: function($$parent, arrayData) {
			var self = this;
			// Temporarily disabled - during mobile gesture implementation
			var addLink = function(parent, linkName, attrs) {
				$(uiUtils.createDomElement('a', ["s-m-link", fontUtils.paginationIcon(linkName), linkName.substr(1)],
					null, attrs)).appendTo(parent);
			};
			if (arrayData.$links) {
				var ctxLinks = {
					links: []
				}, ctx;
				// We wan to display all the links and disable the ones that are not in $link - except $more id cache.disabled
				_paginLinks.forEach(function(linkName) {
					if (linkName === "$more" && globals.getCache().isDisabled()) {
						return;
					}
					ctx = {
						css: fontUtils.paginationIcon(linkName)
					};
					if (arrayData.$links[linkName]) {
						ctx.type = linkName;
						ctx.url = arrayData.$links[linkName].$url;
						ctx.id = self.control.id;
						ctx.target = self.control.controller.isVignette ? "vignette" : "application";
					} else {
						ctx.css += " disabled";
					}
					ctxLinks.links.push(ctx);
				});
				$$parent.prepend($(_getHtml("pagin", ctxLinks)));
			}
		},
		_buildSortFilter: function($$parent) {
			this._$$sortFilter = $(_getHtml("filterSort", {
				ctrlId: this.control.id,
				panelId: _filterSortPanelId
			}));
			$$parent.append(this._$$sortFilter);
			var sortOrder = null,
				sortField = null,
				hasFilter = false;
			var info = this.control.sortInfoGet();
			if (info) {
				// select the first sorted column
				// Currently we support sorting on only one column
				// -> We can display a asc/desc icon in the header
				// Sort panel can manage sorting on multiple columns but it's disabled
				info.some(function(i) {
					if (i.sort != "none") {
						sortOrder = i.sort;
						sortField = i.id;
						return true;
					}
				});
			}
			var info = this.control.filterInfoGet();
			hasFilter = info && info.length > 0;
			this.filterSortUpdate(sortOrder, sortField, hasFilter);
		},
		/**
		 * Update icons when sort change
		 * Can be overridden
		 */
		filterSortUpdate: function(sortOrder, sortField, hasFilter) {
			if (!this._$$stdHeader) return;
			var $$icon = this._$$stdHeader.find(".s-m-sorted").toggle(sortOrder != null).removeClass();
			if (sortOrder != null) {
				$$icon.addClass("s-m-sorted " + fontUtils.sortIcon(sortOrder));
			}
			this._$$stdHeader.find(".s-m-filtered").toggle(hasFilter === true);
		},
		/**
		 * Can be overridden - lookup
		 * This is the DOM element that contains the record
		 * 	class		s-m-record
		 * 	data-params	rowId
		 * Action (edit/detail/delete) which are children of this element use data-param as parameter see hack in eventistener._bindActions
		 * 	rowId is generated only one time
		 */
		buildRecordMainElmt: function(rowData, options, idx) {
			if (options == null) throw new Error("Null options");
			var self = this;
			var attrs = options.attrs || {};
			if (rowData) {
				// We set data-params on the main dom element of the record (RECORDCLASS)
				attrs["data-params"] = encodeURIComponent(rowData.getValue("$uuid") || "");
			}
			options.css = options.css || [];
			options.css.unshift(globals.RECORDCLASS);
			var hasLink = self.control.prototype.isLookup();
			if (!hasLink) {
				var links = self.$itemProto.data("$links");
				if (links) {
					var forceLink = self.control.getAuthoring("$detailsLink");
					hasLink = (forceLink && links[forceLink] != null) || links.$details != null;;
				}
			}
			if (hasLink) {
				if (options.tag === "a") {
					attrs["href"] = "#";
				}
				// Trigger an action in array control for additional processes before open link
				attrs["data-action"] = globals.ACTROWSEL;
			}
			if (hasLink || options.createIfNoLink) {
				return uiUtils.createDomElement(options.tag, options.css, options.title, attrs, options.parent);
			}
			return null;
		},
		/**
		 * True if field is excluded
		 */
		isExcluded: function(proto) {
			return proto == null || proto.$isExcluded === true || _isExcluded.indexOf(proto.$type) >= 0;
		},
		/**
		 * Returns control id eventually concatenated with arguments
		 * 	Allows to get unic ids for control childs if needed
		 */
		getId: function() {
			var self = this;
			if (arguments.length > 0) {
				return self.control.id + " - " + Array.prototype.join.call(arguments, '-');
			} else {
				return self.control.id;
			}
		},
		_getRowById: function(rowId) {
			return this.control.$$elmt.find('tbody .' + globals.RECORDCLASS + '[data-params="' + rowId + '"]');
		},
		removeRowById: function(rowId) {
			return this._getRowById(rowId).remove();
		},
		/**
		 * lastSelectedRow is restored when after a back action - See page.savedCtxRestore
		 */
		selectLastSelectedRow: function(rowId, show) {
			this._lastSelectedRow = rowId ? rowId : null;
			if (rowId == null) {
				this.control.$$value.find('.s-m-last-selected').removeClass("s-m-last-selected");
			} else {
				return this._getRowById(rowId)[show ? "addClass" : "removeClass"]("s-m-last-selected");
			}
		},
		getSelectedRowId: function() {
			return this.control.$$elmt.find("." + globals.RECORDCLASS + ".s-m-last-selected").attr('data-params');
		},
		callGenerateHtml: function(ctrlToGenerate, $$parent, rowData, destroyAfter, buildOptions, idx) {
			buildOptions = buildOptions || {};
			// htmlRootCtrl is the array control that is stored in memory
			// If we have a card array X with other arrays displayed inside the card (multiple levels) htmlRootCtrl is X
			// -> used to store info if needed (rowDetail links/edit/delete) (see array.rowDetailAdd)
			// -> Like controls are not stord as object in memory (we just generate html) we need to store info for actions in htmlRootCtrl
			var htmlRootCtrl = buildOptions.htmlRootCtrl || this.control;
			// Build HTML
			var $$elmt = ctrlToGenerate.generateHtml($$parent, rowData, htmlRootCtrl, buildOptions.updateLayout);
			if (this.control.prototype.isSingleArray() && idx != null) {
				var meta = ctrlToGenerate.getMetaData();
				// For single array we hide the row if the cell is hidden
				// We hide also the edit/delete buttons if readOnly or disabled
				var d;
				if (ctrlToGenerate.$type === "application/x-reference") {
					//#5344 - $isHidden is stored in data ??
					d = rowData.getValue(globals.SINGLEARRAYPROP);
				} else if (rowData.parent && rowData.parent.data.$properties) {
					// For int collection meta are stores in an array in $properties of array field 
					d = rowData.parent.data.$properties;
					if (d && d[rowData.$bind]) {
						d = d[rowData.$bind].$items[idx];
					}
				}
				if (d) {
					if (!meta) meta = {};
					["$isHidden", "$isReadOnly", "$isDisabled"].forEach(function(p) {
						if (d[p] != null) meta[p] = d[p];
					});
				}
				if (meta.$isHidden === true || meta.$isReadOnly) {
					// Hide row or hide button with readonly
					$$elmt.closest(".s-m-record").addClass(meta.$isHidden ? "hidden" : "readonly");
				}
				ctrlToGenerate.applyMetaData(meta);
			}
			// reste $$elmt to not destroy it when we'll destroy the control
			ctrlToGenerate.$$elmt = null;
			if (destroyAfter === true) {
				// Destroy if needed
				ctrlToGenerate.destroy();
			}
		},
		addEmptyCells: function(rootLayout, $$row, nb, buildOptions, $$wrapper) {
			var self = this;
			if (nb < 1) return;
			// dispEmpty: withtitle, filled, empty
			var dispEmpty = self.$articleArray.$emptycell;
			if (dispEmpty === "withtitle" || dispEmpty === "filled") {
				var $$td = $('<td class="s-m-empty s-m-' + dispEmpty + ' nohover">');
				if ($$wrapper) {
					$$parent = $$wrapper.appendTo($$td);
				}
				var $$parent;
				for (var i = 0; i < nb; i++) {
					$$parent = $$td.clone().appendTo($$row);
					if ($$wrapper) $$parent = $$parent.children().first();
					this.callGenerateHtml(rootLayout, $$parent, null, false, buildOptions);
				}
			}
			return $$row.children("td.s-m-empty");
		},
		/**
		 * Return the context to save.
		 * It will be be restored afer page has been loaded
		 * The context is saved and restored by the page
		 * Stores the scroll index
		 */
		savedCtxCreate: function() {
			return {
				$display: this.$display,
				gestureMgr: this._gestureMgr ? this._gestureMgr.savedCtxCreate() : null
			};
		},
		savedCtxRestore: function(ctx) {
			if (this._gestureMgr && ctx.gestureMgr && this.$display === ctx.$display) {
				// Restore context and refresh only if $display didn't change
				this._gestureMgr.savedCtxRestore(ctx.gestureMgr, true);
			}
			// selectedRowId has been added by page.savedCtxRestore to let the right array select the row once the page has been displayed
			if (ctx.selectedRowId) {
				this._restoreSelectedRowId = ctx.selectedRowId;
			}
		},
		newScroller: function(type, $$elmt, valMax) {
			// Set gesture manager - disabled - Enabled onResize
			this.destroyScroller();
			/**
			 * We wrap a parent that will give the Height/Width for scrolling
			 */
			this._gestureMgr = new HammerScroller($$elmt, {
				direction: type,
				valMax: valMax == null ? 0 : valMax,
				name: this.control.$bind,
				isPageScroller: false
			}, globals.getMainPageGestureMgr()); //, $$elmt.wrap('<div class="s-m-scroll-wrapper"/>').parent());
			return this._gestureMgr;
		},
		destroyScroller: function() {
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},
		hasScroller: function() {
			return this._gestureMgr != null;
		},
		/**
		 * Must be called after buildHtml
		 * True if a singme array is empty - $isHidden on all records
		 */
		isEmptySingleArray: function() {
			if (!this.control || !this.control.getArrayData()) return false;
			if (this.control.getArrayData().length > 0) return false;
			return this.control.prototype.isSingleArray() && this.control.$$value.find(".s-m-record.hidden").length === this.control.getArrayData().$resources.length;
		},
		isColumnDisplayed: function($bind) {
			var cols = this.getColumnsInfo(true);
			if (!cols) return false;
			return cols.some(function(c) {
				return c.$bind === $bind;
			});
		},
		getColumnsInfo: function(onlyVisible) {
			throw new Error("Not implemented");
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/array/builderTable',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/controls/array/builderBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/application/daoSdata','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/controls/ctrlFactory'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var builderBase = require('syracuse-tablet/html/js/controls/array/builderBase');
var Base = builderBase.Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var reqProto = require('syracuse-tablet/html/js/helpers/prototype');;
var daoSdata = require('syracuse-tablet/html/js/application/daoSdata');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');

var _fixedSzInfo = {};
/**
 * Calculates the sizes for characters, iconCells
 */
var _getFixedSizeInfo = function($$table) {
	var dev = globals.getSiteLayout().getDeviceType();
	var r = _fixedSzInfo[dev];
	if (r) return r;
	var $$body = $('<tbody></body>').appendTo($$table);
	var $$tr = $('<tr class="s-m-record"><td><div class="s-m-control s-m-field"><div class="s-m-value "><span id="text">MMMMMMMMMM</span></div></div></td><td class="s-m-icon"><div class="s-m-control s-m-icon"><a href="#" class="a"><span class="fa fa-hand-o-right"></span></a></div></td></tr>');
	$$tr.appendTo($$body);
	var tdWidth = $$tr.find("td").outerWidth();
	var valWidth = $$tr.find(".s-m-value").outerWidth();
	var textWidth = $$tr.find("#toto").width();
	r = {
		cellPadding: tdWidth - valWidth,
		charWidth: Math.ceil($$tr.find("#text").width() / 10),
		iconWidth: $$tr.find("td.s-m-icon").outerWidth()
	};
	$$body.remove();
	_fixedSzInfo[dev] = r;
	return r;
};


/**
 * Return a table cell control
 * Article is calculated from the fieldProto
 */
var _createCellControl = function(arrayCtrl, $$parent, colInfo, fieldProto) {
	var article = {
		"$bind": colInfo.$bind
	};
	return ctrlFactory.createCellFieldCtrl($$parent, arrayCtrl.controller, colInfo.article || colInfo, fieldProto);
};

var _isExcluded = ["application/json", "application/x-array", "application/x-document", "application/x-binary"];
var _ADDROW = "$ADDROW";
// !! $activity same code as page.$activity
var _addRowBtn = {
	$activity: "create",
	$type: "tablet/x-button",
	$icon: "addrow",
	$bind: _ADDROW,
	$text: "Add row",
	$action: "rowCreate",
	$capabilities: ["append"]
};
var _additionalCols = [{
	$type: "tablet/x-icon",
	css: ["s-m-icon"],
	$activity: "edit",
	$icon: "editrow",
	$bind: "$EDITROW",
	$action: globals.ACTROWDETAIL
}, {
	$type: "tablet/x-icon",
	css: ["s-m-icon"],
	$activity: "edit",
	$icon: "delrow",
	$bind: "$DELETEROW",
	$action: globals.ACTROWDEL,
	$capabilities: "delete"
}, {
	$type: "tablet/x-icon",
	css: ["s-m-icon"],
	$activity: "read",
	$icon: "detailrow",
	$bind: "$DETAILROW",
	$action: globals.ACTROWDETAIL
}];

var _templates = {
	sortedHeader: '<div><span>{{title}}</span><i class="{{css}}"></i></div>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};
/**
 * x-array control class
 * Array authoring - $article
 * 		$items 				Columns authoring
 * 				$title			Override the title
 * 				$width			Set the width
 * 				$isAdvanced		Not displayed in grid
 */
var _Klass = utils.defineClass(
	function(control, disp, options) {
		Base.call(this, control, disp, options);
		this._columnInfo = null;
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._columnInfo) {
				this._columnInfo.forEach(function(col) {
					if (col.control) col.control.destroy();
				});
				this._columnInfo = null;
			}
		},
		buildHtml: function(arrayData, buildOpts) {
			buildOpts = buildOpts || {};
			Base.prototype.buildHtml.call(this, arrayData, buildOpts);
			if (this._createColumnInfo(buildOpts).length > 0) {
				if (this.isRefreshContext(buildOpts)) {
					// Force display because there's no resize
					this._build(buildOpts);
				} // Otherwise build is done on resize
			} else {
				this.control.$$value.addClass("empty");
			}
		},
		onResize: function(context) {
			// Used by multi-selection - we just want to refresh the scroll
			var scrollOnly = context != null && context.scrollOnly === true;
			if (scrollOnly != true && this._columnInfo && this._columnInfo.length > 0) {
				var buildOpts = {
					updateLayout: context && context.updateLayout
				};
				this._build(buildOpts, context);
			} else {
				Base.prototype.onResize.call(this, context);
			}
		},
		/**
		 * We need to build the table on resize when the table is visible to calculate widths		 *
		 */
		_build: function(buildOpts, resizeContext) {
			if (!this.control._displayArray()) {
				if (this.control.isEmpty) {
					this.buildEmptyArray();
				}
				return;
			}
			buildOpts = buildOpts || {};
			var self = this;
			var initScroll = buildOpts.refresh === true || resizeContext;
			self.control.$$value.empty();
			var arrayData = self.control.getArrayData();
			if (!arrayData) return;
			var $$table = $('<table class="table table-condensed"/>').appendTo(self.control.$$value);
			self._calulateWidths($$table, arrayData);
			// _buildTableHead build the regular header and return a clone of it
			// To scroll the body we need two tables
			// -> one that displays only the header
			// -> another one that display the body with same header (to preserve columns widths) but this heaedr is hidden
			// $$headerScroll is a clone of the regular header 
			var $$headerScroll = self._buildTableHead($$table, buildOpts);
			if (arrayData.$resources.length > 0 || self.control.controller.isEditMode) {
				var scrollable = !self.control.isArrayField();
				// We create an other table without header to scroll the body
				if (scrollable) {
					$$table = $('<table class="table table-condensed"/>').appendTo(self.control.$$value);
					// We can't hide the header of the row that scrolls - We pu visibility hidden and minimize the height
					// We put an offset of -1 * $$headerScroll.height() to the scrollwrapper to better hide $headerScroll
					$$headerScroll.css({
						fontSize: "0px",
						visibility: "hidden"
					}).appendTo($$table);
				}
				var $$body = $(uiUtils.createDomElement('tbody', null, null, null, $$table));
				var size = _getFixedSizeInfo($$body);
				// Build rows
				for (var i = 0; i < arrayData.$resources.length; i++) {
					self._buildTableRow($$body, arrayData.$resources[i], i, buildOpts);
				}
				self._buildTableFoot($$table, arrayData, buildOpts);
				// Create a scroller -> initialized onResize
				if (scrollable) {
					// WE SCROLL ONLY ARRAYS IN QUERY OR LOOKUP
					// Set gesture manager - disabled - Enabled onResize
					var scroller = self.newScroller("v", $$table.wrap('<div class="s-m-scroll-wrapper"/>'), -1 * $$headerScroll.height());
				}
			}
			self.refreshHeaderAndGesture(resizeContext != null && resizeContext.scrollOnly, resizeContext != null && resizeContext.preserveScroll);
		},
		/**
		 * Caluclate fixed widths according to authoring properties
		 * To improve
		 */
		_calulateWidths: function($$table, arrayData) {
			var self = this;
			var size = _getFixedSizeInfo($$table);
			// We substract the icon (edit/delete/detailRow)
			var maxWidth = self.control.$$value.width() - (self._nbAdditionalCols * size.iconWidth);
			var fixedWidth = 0,
				width;
			// Caluclate fixed width
			self._columnInfo.forEach(function(i) {
				var art = i.article;
				i.fixedWidth = 0;
				if (art && art.$widthType === "fixed" && art.$widthVal > 0) {
					width = (size.charWidth * art.$widthVal) + size.cellPadding;
					if (width > 0 && ((fixedWidth + width) < maxWidth)) {
						i.fixedWidth = width;
						fixedWidth += width;
					}
				}
			});
			var remainingWidth = maxWidth - fixedWidth;
			var percentWidth = 0;
			// Caluclate % widths
			self._columnInfo.forEach(function(i) {
				var art = i.article;
				if (art && art.$widthType === "percent" && art.$widthVal > 0) {
					width = ((art.$widthVal * remainingWidth) / 100) + size.cellPadding;
					if (width > 0 && ((percentWidth + width) < remainingWidth)) {
						i.fixedWidth = width;
						percentWidth += width;
					}
				}
			});
		},
		// get columns that should be displayed
		_createColumnInfo: function(buildOpts) {
			var self = this;
			if (self._columnInfo) return self._columnInfo;
			self._nbAdditionalCols = 0;
			self._columnInfo = [];
			if (self.$arrayOptions.rowIndex) {
				self._columnInfo.push({
					"$bind": globals.ROWIDXPROP,
					"proto": reqProto.getRowIdxProto(),
					css: "s-m-rowidx"
				});
			}
			this._statusList = this.control.getRowStatusInfo();
			if (this._statusList != null) {
				self._columnInfo.push({
					$bind: "$ROWSTATUS",
					css: "s-m-row-status",
					proto: reqProto.create({
						$type: "tablet/x-row-status"
					})
				});
			}
			var proto, nbCols = 0,
				unfound = [],
				col;
			var items = self.$articleArray.$table;
			if (!items) items = self.control.prototype.arrayTableGetColInfo();
			items.forEach(function(item, idx) {
				/* #6148 - skip these columns - No possibility to show/hide columns currently*/
				if (item.$isHidden) return;
				item.$widthType = item.$widthType ? item.$widthType : "auto";
				item.$widthVal = parseInt(item.$widthType === "auto" ? 0 : item.$widthVal, 10);
				if (isNaN(item.$widthVal)) item.$widthVal = 0;
				proto = self.$itemProto.property(item.$bind);
				if (!proto) {
					unfound.push(item);
					// TODO - Display error
				} else {
					nbCols++;
					if (!self.isExcluded(item, proto)) {
						col = {
							"$bind": item.$bind,
							"proto": self.$itemProto.create(proto),
							"article": item,
						};
						// Added as class to identify the column by field name - see sortInfoUpdate
						col.css = [self.$itemProto.getFieldNameForValue(item.$bind)];
						if (col.article.$isTitleHidden === true) {
							col.title = "";
						} else if (col.article.$title != null && col.article.$title != item.$bind) {
							// Authoring save $title with sometimes $bind - we don't display it in the page
							// Title can be overridden bay article - TODO translation
							col.title = self.$itemProto.resolveExpression(col.article.$title) || "";
						} else {
							col.title = col.proto.data('$title') || "";
						}
						self._columnInfo.push(col);
					}
				}
			});
			var edit = self.control.controller.isEditMode();
			var overflow = self._columnInfo.length != nbCols;
			var c;
			_additionalCols.forEach(function(col) {
				if ((edit && col.$activity === "edit") || (!edit && overflow && col.$activity === "read")) {
					if (self.control.checkCapabilities(col.$capabilities)) {
						c = $.extend(true, {}, col);
						c.$widthType = "auto";
						self._columnInfo.push(c);
						self._nbAdditionalCols++;
					}
				}
			});
			if (unfound.length > 0 && globals.getDvlpOpt("showUnfoundFields")) {
				// Add unfound columns
				var html = ['Field(s) not found<ul>'];
				unfound.forEach(function(x) {
					html.push("<li><b>" + x.$bind + "</b></li>");
				});
				html.push("</ul>");
				self.insertError(html.join(''));
			}
			return self._columnInfo;
		},
		getColumnInfo: function() {
			return this._columnInfo;
		},
		isExcluded: function(item, proto) {
			var self = this;
			if (Base.prototype.isExcluded.call(self, proto)) return true;
			return _isExcluded.indexOf(proto.$type) >= 0 || item.$isAdvanced === true;
		},
		_buildTableHead: function($$table, buildOpts) {
			var self = this;
			var $$tabHead = $(uiUtils.createDomElement('thead', null, null, null));
			var tr = uiUtils.createDomElement('tr', null, null, null, $$tabHead);
			var th;
			self._columnInfo.forEach(function(col) {
				th = uiUtils.createDomElement('th', col.css, col.title, null, tr);
				if (col.fixedWidth != null && col.fixedWidth > 0) {
					$(th).width(col.fixedWidth);
				}
			});
			var $$headerScroll;
			if (this.control.getAuthoring("$tableHeaderShow") !== false) {
				$$headerScroll = $$tabHead.clone();
				this.$$tabHead = $$tabHead.appendTo($$table);

			} else {
				$$headerScroll = $$tabHead;
			}
			return $$headerScroll;
		},
		_buildTableFoot: function($$table, arrayData, buildOpts) {
			var self = this;
			if (self.control.controller.isEditMode() && this.control.checkCapabilities(_addRowBtn.$capabilities)) {
				//#5529 - we add addRow in any case
				var $$cell = $('<tfoot><tr><td colspan="' + self._columnInfo.length + '"></td></tr></tfoot>').appendTo($$table).find("td");
				var fieldProto = self._getOtherColProto(_addRowBtn, "");
				/**
				 * Build cell html and append it to parent
				 * Control is used only one time
				 */
				var ctrl = _createCellControl(self.control, $$cell, _addRowBtn, fieldProto);
				self.callGenerateHtml(ctrl, $$cell, daoSdata.emptyDao(fieldProto), true, buildOpts);
			}
		},
		_buildTableRow: function($$body, rowData, idx, buildOpts) {
			var self = this;
			var cssRowIdx;
			if (self.$arrayOptions.rowIndex) {
				rowData.setRowIndex(idx + 1);
			}
			var css = [];
			var rowId = rowData.data.$uuid;
			if (rowId === self.control.controller.lastSelectedRowId) {
				css.push("s-m-selected");
			}
			var error = rowData.data.$arrayUpdateError;
			if (error === true) {
				css.push("error");
			}
			var tr = self.buildRecordMainElmt(rowData, {
				tag: "tr",
				parent: $$body,
				createIfNoLink: true,
				css: css
			}, idx);
			var $$cell, fieldProto;
			self._columnInfo.forEach(function(col, idx) {
				// We display the css stored in _columnInfo
				// Used by rowIndex (to apply a style) and columns with icon (to set width)
				$$cell = $(uiUtils.createDomElement('td', col.css || "", null, null, tr));
				fieldProto = col.$activity != null ? self._getOtherColProto(col, rowId, rowData, buildOpts) : col.proto;
				if (!col.control) {
					// Creates the control used for generating html in cells
					col.control = _createCellControl(self.control, $$cell, col, fieldProto);
				}
				self.callGenerateHtml(col.control, $$cell, rowData, false, buildOpts, idx);
			});
			return tr;
		},
		/**
		 * Returns the proto for button, icons for actions
		 * 		Add new row			array._actRowDetail
		 * 		Detelete row		array._actDelrow
		 * 		Goto row detail		array._actRowDetail
		 * 		Edit row detail		array._actRowDetail
		 * In row detail page we will get a null rowid for creation
		 */
		_getOtherColProto: function(colInfo, rowId, rowData, buildOpts) {
			var self = this;
			// mainArrayCtrl is the array control at the origin of the creation of the table/card
			// When we generate html cards for arrays nested is a parent array the main control is propagated by buildOpts.htmlRootCtrl
			// Otherwise the maincontrol is self.control
			var mainArrayCtrl = buildOpts && buildOpts.htmlRootCtrl ? buildOpts.htmlRootCtrl : self.control;
			var action = colInfo.$action;
			var rowInfo = {
				pathBind: [],
				pathId: [],
				activity: colInfo.$activity
			};
			var create = colInfo.$activity === "create";
			if (create) {
				// CREATE ROW - Build the path to retrieve the row when we click on AddRow
				rowId = utils.UUID();
				rowInfo.pathId.unshift(rowId);
				rowInfo.pathBind.unshift(self.control.$bind);
			} else {
				if (!rowData) throw new Error("unexpected null row data");
				// Build the path of array field and rowsid's and stores it in mainArrayCtrl
				var rd = rowData;
				// EDIT/DETAIL ROW
				rowInfo.pathId.unshift(rowId);
				rowInfo.pathBind.unshift(rd.$bind);
				// Build the path id/bind to access to the resource. We need to store it because the controls/dao/proto are destroyed after creation
				// rd.parent.$bind && rd.parent.$bind.length >0 added to build the bing array working with a protoRow = protoArray.getPrototype("$item"); - sess getArrayData in prototype
				// To test multiple level in display mode pput card display in 'Collection Object' of AQMCRUDM. We see the card with an array inside. If we click on 'rowDetail' icon we've pathBind/pathId.length == 2 
				while (rd.$bind !== mainArrayCtrl.$bind) {
					rowInfo.pathId.unshift(rd.parent.getValue("$uuid"));
					rowInfo.pathBind.unshift(rd.parent.$bind);
					rd = rd.parent;
				}
			}
			// Registers the row info into the main Array control
			// Like html generator destroy the control and dao after generation we need to store the paths (ids and $bind) to retreive row dao and proto
			mainArrayCtrl.rowDetailAdd(rowId, rowInfo);
			var json = {
				$action: {
					"data-action": action
				}
			};
			if (create) {
				// For create we add the parameter in data-params
				json.$action["data-params"] = rowId;
			} else {
				// For other action than create the id of the row is added in the dom elmt of the record - see builderBase.buildRecordMainElmt
				// It allows to not add uuid for each action delete/select/edit...
			}
			// Additional info needed to create the control (button, icon...)
			["$type", "$icon", "$text"].forEach(function(x) {
				if (x != null && x != "$activity") json[x] = colInfo[x];
			});
			return reqProto.create(json);
		},
		/**
		 * Update icons when sort/filter change
		 */
		filterSortUpdate: function(sortOrder, sortField, hasFilters) {
			Base.prototype.filterSortUpdate.call(this, sortOrder, sortField, hasFilters);
			if (sortOrder && sortField && this.$$tabHead) {
				var $$th = this.$$tabHead.find(".s-m-sorted");
				if ($$th.length > 1) {
					// remove the current - To test because necer occurs as the array is rebuilt on refresh
					var text = $$th.find("div > span")[0].text();
					$$th.removeClass();
				}
				// set the content with sort info
				$$th = this.$$tabHead.find("." + sortField);
				if ($$th.length > 0) {
					var title = $$th.text();
					$$th.html(_getHtml("sortedHeader", {
						title: title,
						css: fontUtils.sortIcon(sortOrder)
					}));
					$$th.addClass("s-m-sorted " + sortOrder);
				}
			};
			this.searchUpdate();
		},
		searchUpdate: function() {
			var $$th, searcher = this.control.getSearcher(),
				self = this;
			if (self.$$tabHead) {
				self.$$tabHead.find(".s-m-search").removeClass("s-m-search");
				if (searcher) {
					searcher.searchInfos.forEach(function(column) {
						$$th = self.$$tabHead.find("." + column.id);
						$$th.addClass("s-m-search ");
					});
				}
			}
		},
		getColumnsInfo: function(onlyVisible) {
			var cols;
			if (!this.control.prototype.isSingleArray() && onlyVisible === true) {
				var ci = this._createColumnInfo();
				if (ci && ci.length > 0) {
					var cols = [];
					ci.forEach(function(c) {
						if (c.$action !== true) {
							cols.push(c.$bind);
						}
					});
				}
			}
			var protoCols = this.control.prototype.arrayTableGetColInfo();
			if (cols == null) {
				return protoCols;
			}
			var res = [];
			protoCols.forEach(function(c) {
				if (cols.indexOf(c.$bind) >= 0) {
					res.push(c);
				}
			});
			return res;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/array/builderCard',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/controls/array/builderBase','syracuse-tablet/html/js/helpers/articleParser','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/authoring/authoringArticleGen','syracuse-tablet/html/js/helpers/hammerScroller','syracuse-tablet/html/js/helpers/fieldOperators'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/array/builderBase').Klass;
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var articleGen = require('syracuse-tablet/html/js/authoring/authoringArticleGen');
var HammerScroller = require('syracuse-tablet/html/js/helpers/hammerScroller').Klass;
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');


/**
 * Vertical card builder
 * Authoring
 * 		$numberOfRows 			number of card s per row
 * 		$displayEmptyCells 		Display or not empty cells true by default
 */
var _Klass = utils.defineClass(
	function(control, disp, options) {
		Base.call(this, control, disp, options);
		this._layoutRoot = null;
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._layoutRoot) {
				this._layoutRoot.destroy();
				this._layoutRoot = null;
			}
			if (this._oneCardGestureMgr) {
				this._oneCardGestureMgr.destroy();
				this._oneCardGestureMgr = null;
			}
			this._$$body = null;
			this._$$cellTmpl = null;
			this._tds = null;
		},
		/**
		 * Just build $$td cells
		 * Build of array will be done on resize because we need to have the height of the parent control.$$value to calculate the number of roww
		 */
		buildHtml: function(arrayData, buildOpts) {
			var self = this;
			this.$articleArray.$minWidth = this.$articleArray.$minWidth || 6;
			Base.prototype.buildHtml.call(self, arrayData, buildOpts);
			if (self._layoutRoot == null) {
				var cardArticle = self.$articleArray.$card;
				if (!cardArticle) {
					cardArticle = articleGen.genNewArticle({
						page: {
							prototype: self.control.prototype
						}
					}, true);
				};
				var options = {
					displayCtx: "card"
				};
				self._layoutRoot = articleParser.article2Controls(self.control.controller, cardArticle, self.$itemProto, options);
			}
			// Like we rebuild a new _$$body we have to destroy the scroller
			self.destroyScroller();
			self._$$body = $('<tbody>').appendTo($('<table/>').appendTo(self.control.$$value));
			var $$td;
			self._$$cellTmpl = $('<section class="s-m-card s-m-std"/>');
			var $$cell, $$root;
			self._tds = [];
			var statusList = this.control.getRowStatusInfo();
			arrayData.$resources.forEach(function(rowData, idx) {
				$$td = $(self.buildRecordMainElmt(rowData, {
					tag: "td",
					parent: null,
					createIfNoLink: true
				}, idx));
				$$root = $$cell = self._$$cellTmpl.clone().appendTo($$td);
				if (self.$arrayOptions.rowIndex === true) {
					$('<span class="badge index">' + (idx + 1) + '</span>').appendTo($$cell);
				}
				if (statusList) {
					$$root = self.checkStatusManagement(statusList, $$cell, rowData);
				}
				self.callGenerateHtml(self._layoutRoot, $$root, rowData, false, buildOpts, idx);
				self._tds.push({
					"$$td": $$td,
					"$$card": $$cell
				});
			});
			if (this.isRefreshContext(buildOpts)) {
				// Force display because there's no resize
				self._build(buildOpts);
			} // Otherwise build is done on resize
		},
		checkStatusManagement: function(statusList, $$cell, rowData) {
			if (!statusList) return;
			var $$newCell = $$cell;
			statusList.some(function(s) {
				if (s.color && fieldOperators.evaluateOperator(s.$type, rowData.getValue(s.field), s.operator, s.value)) {
					/**
					 * We need to set color and bg-color because using css property doesn't work due to css inheritance
					 * Using css forces to declare all css selectors (td:not(.s-m-multi-selected)...) for each color of the palette
					 */
					if (s.icon) {
						$('<div class="s-m-status-icon ' + s.icon.css + '" style="color:' + s.color.bgColor + '"/>').appendTo($$cell);
					} else {
						$$cell.css("padding", "0px");
						$$newCell = $('<div class="s-m-status-color ' + s.color.css + '">').appendTo($$cell);
					}
					return true;
				}
			});
			return $$newCell;
		},
		onResize: function(context) {
			// Used by multi-selection - we just want to refresh the scroll
			var scrollOnly = context != null && context.scrollOnly === true;
			if (scrollOnly !== true && this._layoutRoot && this._tds.length > 0) {
				/**
				 * We rebuild in any cases in order to have a good display
				 * To be able to calculate  parentH in nested pages we use table display for s-m-control and table-row for children
				 * --> In that case control.$$value has the right height
				 * For non nested paged table display doens't allow to calculate the height of the array without removing the old one...
				 * Other option was to check if $$value height changed to rebuild array
				 */
				var buildOpts = {
					updateLayout: context && context.updateLayout
				};
				this._build(buildOpts, context);
			} else {
				Base.prototype.onResize.call(this, context);
			}
		},
		/**
		 * !! check the multi-selection if we modify  _build
		 */
		_build: function(buildOpts, resizeContext) {
			buildOpts = buildOpts || {};
			if (!this.control._displayArray()) {
				if (this.control.isEmpty) {
					this.buildEmptyArray();
				}
				return;
			}
			/**
			 * setTimeout to better calculate the height of $$value
			 */
			var dirArray = globals.getScrollingDirection() || "v";
			var initScroll = buildOpts.refresh === true || resizeContext;
			dirArray = this.control.isArrayField() ? "h" : dirArray === "h" ? "v" : "v"; //"h";
			if (!this.hasScroller() || this._dirArray == null || this._dirArray != dirArray) {
				this.newScroller(dirArray, this._$$body.parent());
				this._dirArray = dirArray;
				initScroll = true;
			}
			buildOpts.cardAuthoring = {
				$emptycell: this.$articleArray.$emptycell || "nodisplay",
				$minWidth: this.authMinSize2Pixels(this.$articleArray.$minWidth),
				$cardsPerRow: parseInt(this.$articleArray.$cardsPerRow, 10) || 2
			};
			if (!this._$$body) {
				// Sometimes the body can be empty - Ex when we exit multi-selection mode
				return;
			}
			var sz = this.control.getAvailableSize();
			var parentH = sz.height;
			var parentW = sz.width;
			// Border spacing used for calculation
			var bs = this._$$body.parent().css("border-spacing");
			if (bs) {
				bs = bs.split("px");
				bs = bs && bs.length > 0 ? parseInt(bs[0], 10) : 0;
			}
			//parentH = parentH - bs;
			//parentW = parentW - bs;
			var $$hiddenRow;
			var visibleTds = [];
			// We keep the $$td's to not recreate them and arrange according the new configuration
			// We first detach them and select the visible ones (used by multiselection)
			// We put non-visible ones in $$hiddenRow to let them available in the dom (used by multiselection)
			this._tds.forEach(function(o, idx) {
				o.$$td.detach();
				if (o.$$td.css('display') != "none") {
					visibleTds.push(o);
				} else {
					if (!$$hiddenRow) {
						$$hiddenRow = $("<tr>").hide();
					}
					o.$$td.appendTo($$hiddenRow);
				}
			});
			// !! Call $$body after having detached $$td because empty() removes the data attached to the node ($.smData) used by multi-selection (diagnoses)
			this._$$body.empty();
			if ($$hiddenRow) {
				$$hiddenRow.appendTo(this._$$body);
			}
			if (visibleTds.length === 0) return;
			this["buildCard" + dirArray.toUpperCase()](visibleTds, bs, parentH, parentW, buildOpts);
			this.control.$$elmt.addClass("card" + dirArray.toUpperCase());
			var top = Math.max(0, (parentH - this._$$body.parent().outerHeight()) / 2);
			this._$$body.parent().css({
				top: top + "px"
			});
			if (initScroll) {
				// refreshes the gestureMgr
				this.refreshHeaderAndGesture(resizeContext != null && resizeContext.scrollOnly, resizeContext != null && resizeContext.preserveScroll);
			}
		},
		buildCardV: function(visibleTds, bs, parentH, parentW, buildOpts) {
			this._$$body.parent().width("100%");
			var $$row, realW, nbCardPerRow;
			var minWidth = buildOpts.cardAuthoring.$minWidth;
			var remaining = 0;
			var self = this;
			visibleTds.some(function(o, idx) {
				if (idx === 0 || nbCardPerRow == 1 || (nbCardPerRow > 1 && idx % nbCardPerRow === 0)) {
					$$row = $("<tr>").appendTo(self._$$body);
					remaining = nbCardPerRow;
				}
				remaining--;
				o.$$td.appendTo($$row);
				if (idx === 0) {
					var padding = o.$$card.outerWidth() - o.$$card.width();
					nbCardPerRow = buildOpts.cardAuthoring.$cardsPerRow;
					while (nbCardPerRow > 1) {
						realW = Math.round((parentW - ((nbCardPerRow + 1) * bs)) / nbCardPerRow) - padding;
						if (realW >= minWidth) break;
						nbCardPerRow--;
					}
					if (nbCardPerRow > 1) {
						realW = Math.min(Math.max(minWidth, realW));
					}
				}
				if (nbCardPerRow > 1) {
					o.$$card.width(realW);
				} else {
					o.$$card.css({
						width: "100%"
					});
				}
			});
			if (remaining && buildOpts.cardAuthoring.$emptyCell !== "nodisplay") {
				this.addEmptyCells(this._layoutRoot, $$row, remaining, buildOpts, this._$$cellTmpl);
			}
		},
		buildCardH: function(visibleTds, bs, parentH, parentW, buildOpts) {
			var $$row, realH, realW;
			var nbCardPerRow, numberOfRows;
			var nbVisiblecardsPerRow = buildOpts.cardAuthoring.$cardsPerRow;
			var minWidth = buildOpts.cardAuthoring.$minWidth;
			parentH = parentH - bs;
			var remaining = 0;
			var self = this;
			var maxHeight = 0,
				h, heightChanged;
			visibleTds.some(function(o, idx) {
				if (idx == 0 || nbCardPerRow == 1 || (nbCardPerRow > 1 && idx % nbCardPerRow === 0)) {
					$$row = $("<tr>").appendTo(self._$$body);
					remaining = nbCardPerRow;
				}
				o.$$td.appendTo($$row);
				if (idx === 0) {
					// Calculate the number of rows after having create the first cell
					realH = o.$$td.height() + bs;
					parentW = parentW - ((nbVisiblecardsPerRow + 1) * bs);
					var padding = o.$$card.outerWidth() - o.$$card.width();
					realW = Math.round(parentW / nbVisiblecardsPerRow) - padding;
					if (self.control.isArrayField() || (visibleTds.length * realW < parentW)) {
						// Force to display all the cells on one line because there's enough room
						numberOfRows = 1;
						nbCardPerRow = visibleTds.length;
					} else {
						// Calculate the number of rows to fit the parent height
						numberOfRows = Math.max(1, Math.floor(parentH / realH));
						nbCardPerRow = Math.ceil(visibleTds.length / numberOfRows);
						if (visibleTds.length <= numberOfRows * nbVisiblecardsPerRow) {
							// Dispatch the cards by filling the lines from the top to bottom
							nbCardPerRow = nbVisiblecardsPerRow;
						}
					}
					remaining = nbCardPerRow;
				}
				o.$$card.width(Math.min(parentW, Math.max(minWidth, realW)));
				var h = o.$$card.height();
				if (maxHeight === 0) {
					maxHeight = h;
				} else if (maxHeight != h) {
					heightChanged = true;
					maxHeight = Math.max(maxHeight, h);
				}
				remaining--;
			});
			if (heightChanged) {
				// Set the same height for cards (could occurs if there are arrays in cards)
				visibleTds.forEach(function(o) {
					o.$$card.height(maxHeight);
				});
			}
			if (remaining && buildOpts.cardAuthoring.$emptyCell !== "nodisplay") {
				var $$emptyCells = this.addEmptyCells(this._layoutRoot, $$row, remaining, buildOpts, this._$$cellTmpl);
				if (heightChanged) {
					$$emptyCells.height(maxHeight);
				}
			}
			if (self.control.isArrayField()) {
				if (this._oneCardGestureMgr) {
					this._oneCardGestureMgr.destroy();
					this._oneCardGestureMgr = null;
				}
				this._oneCardGestureMgr = new HammerScroller($(self._$$body.parent()), {
					direction: "h",
					valMax: 0,
					name: this.control.$bind,
					isPageScroller: false
				});
				this._oneCardGestureMgr.init(uiRect.elmtRect(this.control.$$value));
			}
		},
		authMinSize2Pixels: function(val) {
			var max = 700,
				min = 100;
			val = parseInt(val, 10);
			if (val == null || isNaN(val)) return 200;
			if (val > 20) return max;
			if (val < 1) return min;
			return min + (val * (max - min) / 20);
		},
		getColumnsInfo: function(onlyVisible) {
			var cols = null;
			if (!this.control.prototype.isSingleArray() && onlyVisible === true && this._layoutRoot) {
				cols = [];
				var _scan = function(node) {
					if (!node || !node.children) return;
					node.children.forEach(function(c) {
						if (c.isControl() && c.$bind) {
							cols.push(c.$bind);
						} else {
							_scan(c);
						}
					});
				};
				_scan(this._layoutRoot);
			}
			var protoCols = this.control.prototype.arrayTableGetColInfo();
			if (cols == null) {
				return protoCols;
			}
			var res = [];
			protoCols.forEach(function(c) {
				if (cols.indexOf(c.$bind)) {
					res.push(c);
				}
			});
			return res;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/array/ctrlArray',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/application/eventListener','syracuse-tablet/html/js/sdata/sdataUtils','syracuse-tablet/html/js/application/daoSdata','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/fieldOperators','syracuse-tablet/html/js/controls/array/searchArray','syracuse-tablet/html/js/controls/array/builderTable','syracuse-tablet/html/js/controls/array/builderCard'],function (require, exports, module) {


var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var daoSdata = require('syracuse-tablet/html/js/application/daoSdata');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');
var SearchArray = require('syracuse-tablet/html/js/controls/array/searchArray').Klass;


var _sortFilterExclude = ["application/x-array", "image", "application/x-document", "application/x-binary", "application/x-object", "text/rtf", "text/html", "text/plain"];

var _notImplemented = function(text) {
	throw new Error("The following feature in not implemented -> " + text);
};
var Builders = {
	table: require('syracuse-tablet/html/js/controls/array/builderTable').Klass,
	card: require('syracuse-tablet/html/js/controls/array/builderCard').Klass
};
var _destroyArrayData = function(a) {
	if (!a || !a.$resources) return null;
	a.$resources.forEach(function(r) {
		if (r) r.destroy();
	});
	return null;
};
/**
 * x-array control class
 * Authoring
 * 			$isTitleHidden: 		true/false
 * 			$height					height of array - if no height displays full array
 * 									add pan event to scroll(no swipe)
 * 			$width					100% by default - not needed
 * 			$displayIfEmpty:		true/false - Maybe a general property for fields to not display the control if empty
 *                              	If false we display the label and default value
 *      							Useful to optimize display
 *  		$emptycell				Ford cards mode - Value! ’empty’, ‘filled’, ‘withtitle’
 * 				empty:		 			doesn't fill grid with empty cells
 * 				filled:					fills grid with empty cells
 * 				withtitle:				fills grid with cards wit titles and default field values
 * 			$display				display mode table / card
 * 			for card
 * 				$cardMode	 			Display mode
 * 					single 					to display one card at a time with a swipe to walk inside the collection
 * 					multiple 				to display a list of cards
 * 				$cardsPerRow 			number of cards per row
 * 										height is calculated in percentage based on control width (full parent page with by default)
 * 				for field array 		s-m-control.s-m-array parent page has class detail or edit
 * 					$pagination				Displays N cards at a time on other ones on swipe
 *         $onselect 					detail 		Open detail fullpage
 *         								fullpage	Open query fullpage
 */
var _Klass = utils.defineClass(
	function(controller, article, prototype, options) {
		Base.call(this, controller, article, prototype, options);
		this._initArrayAuthOptioring();
		this._newBuilder(options);
		this._arrayData = null;
		this._search = new SearchArray();
		// All the rows with a link to rowDetail are registered in _rowDetailCache - id: {pathId,pathBind}
		// When we display arrays nested in arrays in card mode we need to store the path to access to the data/proto of the selected row
		// -> Cards Html is generated and the control object is not stored so we need to store the path to retrieve it from mainControl (htmlRootCtrl)
		this._rowDetailCache = {};
		// Info of the clicked row
		this._rowDetailInfo = null;
	}, Base, {
		_initArrayAuthOptioring: function() {
			this.$display = this.article.$display = this.article.$display || "table";
			var defaults;
			if (this.controller.isVignette) {
				defaults = {
					showPagination: false,
					showSortFilter: false
				};
			} else {
				defaults = {
					showPagination: true,
					showSortFilter: true,
					showSearch: true
				};
			}
			defaults.rowIndex = this.$display === "card";
			this.article.$arrayOptions = $.extend(defaults, this.article.$arrayOptions || {});
		},
		_newBuilder: function(options) {
			var Builder;
			if (this.builder) {
				options = this.builder.options;
				this.builder.destroy();
			}
			if (this.$$value) this.$$value.empty();
			if (this.$display.indexOf("card") === 0) {
				Builder = Builders["card"];
			} else {
				Builder = Builders.table;
			}
			this.builder = new Builder(this, this.$display, options);
		},
		getMode: function() {
			return this.builder && this.builder.$display;
		},
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			if (this._arrayData) this._arrayData = _destroyArrayData(this._arrayData);
			if (this.builder) this.builder.initReuseProperties();
		},
		destroy: function() {
			this._multiSelExit();
			// Just set to null - destroyed by rowDetail page
			this._rowDetailInfo = null;
			// Just set to null
			this._rowDetailCache = null;
			Base.prototype.destroy.call(this);
			this.prototype = null;
			if (this.builder) {
				this.builder.destroy();
				this.builder = null;
			}
			if (this._arrayData) {
				this._arrayData = _destroyArrayData(this._arrayData);
				this._arrayData = null;
			}
			if (this._waiting) {
				uiUtils.waitWheelDestroy(this._waiting);
				this._waiting = null;
			}
			if (this._waiting) {
				this._filterSortPanel.destroy();
				this._filterSortPanel = null;
			}
			if (this._search) {
				this._search.destroy();
				this._search = null;
			}
		},
		isArrayField: function() {
			return !this.prototype.isLookup() && !this.prototype.isQuery();
		},
		/**
		 *	Build html DOM object + bind event
		 **/
		buildHtml: function($$parent, controllerDao, buildOptions) {
			if (this.builder == null) throw new Error("Null builder");
			// Create standard root elmt
			var disp = this.article.$display;
			if (this.builder.$display !== this.article.$display) {
				// If we change display by authoring without saving and go to detail page the display is reseted when we go back from detail to array
				// We need to change it
				this._newBuilder();
			}
			var css = "s-m-" + disp;
			// Build root elm
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions, ["s-m-array", css]);
			// Set up array data and isEmpty property used to managed authoring - Display title
			this._setArrayData(controllerDao, false);
			var hasFilerSort = !this.isArrayField();
			if (hasFilerSort) {
				this._filterSortPanel = this.controller.panelCreate(globals.PANELFILTERSORT, {
					parentArray: this,
					filter: true,
					sort: true
				});
			}
			this.builder.buildHtml(this._arrayData, buildOptions);
			if (this.prototype.isSingleArray() && this.builder.isEmptySingleArray()) {
				// #5529 Special case -> single array and all records with $isHidden = true -> test AQMCRUDM
				this.isEmpty = true;
			}
			// Hidden if no data and no title - take into account this.isEmpty for singleArrays
			if (!this._displayArray() && (this.$$ttl == null || this.$$ttl.empty())) {
				this.$$elmt.hide();
			}
		},
		/**
		 * Refreshes the control
		 */
		refresh: function(controllerDao, options) {
			this._rowDetailInfo = null;
			this._capabilities = null;
			if (this.builder == null) throw new Error("Null builder");
			this.builder.refresh(this._setArrayData(controllerDao, true), options);
		},
		onResize: function(context) {
			/**
			 * Add with collapsible stack
			 * We don't display array if not visible because not needed and because card needs a visible element to calculate width/height/padding...
			 * :visible takes into account parents (maybe costly in cpu)
			 * subscibes event expand layout to render the array
			 */
			if (context && context.footerSwipe === true) {
				// No need to refresh
				return;
			}
			if (!this.$$elmt.is(':visible')) {
				if (!this._subscribedExpand) {
					this._subscribedExpand = true;
					notifications.subscribe(this, ["sm.layout.expanded"]);
				}
				// No display
				return;
			} else if (this._subscribedExpand) {
				notifications.unsubscribe(this, ["sm.layout.expanded"]);
				this._subscribedExpand = false;
			}
			this.builder.onResize(context);
		},
		_notifSelectedRow: function(rowId, rowData) {
			notifications.notifyController("sm.select.row", this.controller, this.id, rowId, rowData, false);
		},
		/**
		 * handle selection of a row for lookup
		 */
		_actRowSelect: function(rowId, $$target) {
			if (this._multiSelSelect($$target)) {
				return;
			}
			var rowData = this.getRowById(rowId);
			if (!rowData) return;
			rowData = rowData.row;
			if (this.controller.isLookup()) {
				/** SELECTION ON LOOKUP ARRAY**/
				// Proto to allow caller to read/display $description, $title... 
				var proto = $.extend({}, true, this.prototype.getDataByPath("$item"));
				var data = $.extend({}, true, rowData.data);
				// Notify selection to lookup page
				this._notifSelectedRow(rowId, {
					data: data,
					proto: proto
				});
			} else {
				/** SELECTION ON REGULAR ARRAY**/
				var links = this.builder.$itemProto.data("$links");
				// We can force the detail link by authoring (Fixed Assets)
				var forceLink = this.getAuthoring("$detailsLink");
				var link;
				if (forceLink == null) {
					forceLink = this.controller.isVignette ? "$queryfullpage" : "$details";
				}
				if (forceLink === "$queryfullpage") {
					if (!this.controller.isVignette) throw new Error("Vignette context expected");
					link = {
						page: this.controller.state.name
					};
					// No selected row in that case
					// Check if there is an article for query link - ONLY FOR TEST ENTITIES
					this._forceArticle = this.article ? this.article.$queryLinkArticle : null;
				} else {
					var linkProto = links[forceLink] ? links[forceLink] : links.$details;
					link = linkProto ? sdataUtils.getLinkInfo(linkProto.$url, rowData) : null;
					// Notify last selected row to current page - Stores the lastSelectedRowId - see selectLastSelectedRow
					// false to not update UI because link destroy the page
					this._notifSelectedRow(rowId, rowData);
					// Check if there is an article for detail link - ONLY FOR TEST ENTITIES
					this._forceArticle = this.article ? this.article.$detailLinkArticle : null;
				}
				if (link) {
					var attrs = {};
					attrs["data-nav"] = link.page;
					attrs["data-nav-target"] = this.controller.openLinkInVignette() ? "vignette" : "application";
					if (link.sDataUrl) {
						attrs["data-sdata-url"] = link.sDataUrl;
					}
					if (link.parameters) {
						var params = utils.parseExpression(link.parameters, rowData);
						attrs["data-sdata-parameters"] = params;
					}
					if (this._forceArticle) {
						attrs["data-link-article"] = this.id;
					}
					eventListener.triggerNavigation(this.$$elmt, attrs);
				}
			}
		},
		/**
		 * Called when we click on editRow, detailRow, createRow
		 * Calculate information dao/proto/name for rorwDetail page
		 * Each time a rowDetail link is generated, we store link info in _rowDetailCache
		 * 		Path of array from the current array
		 * 		Path of row ids from current array
		 * This method retrieve dao/proto objects from stored info
		 * 		rowDetail page needs _rowDetailInfo.dao in lodaData method
		 *  	pageHelpers._getRowdetailPage needs _rowDetailInfo.proto and _rowDetailInfo.pathBind to build rowDetail page proto
		 *
		 *  rowInfofId is the id of the cached info
		 */
		_openDetailRow: function(rowInfofId) {
			var self = this;
			try {
				// Info that has been set by the builder - Contains path of $binds and ids for each row displayed
				var info = self._rowDetailCache[rowInfofId];
				if (!info) throw new Error("rowDetailGetDao - Unexpected null row info");
				var isRowCreation = info.activity === "create";
				// Path of parent arrays
				var pathBind = info.pathBind;
				if (isRowCreation && pathBind.length > 1) {
					// TODO - Create new row in an array embedded inside a card
					// Currently we force table mode in edit mode
					_notImplemented("Creating row in an array embedded inside a card");
				} else {
					// Ok if not patpathBindhBind.length > 1 in display mode 
					// We allow display of row detail in an arrayy embedded inside a card - Tested
				}
				// Id of parent rows
				var pathId = info.pathId;
				var proto = self.prototype.parent;
				var protoPath = ["$properties"];
				var dao = self.getDao();
				for (var i = 0; i < pathBind.length; i++) {
					protoPath.push(pathBind[i]);
					// Get Proto and dao for the ith array
					proto = proto.getPrototype(protoPath.join("."));
					// Some explanations about he way to retreive the right row dao
					// When we generate cards or grids we don't store controls and associated dao object (see html generator) - We keep only the generated html
					// We need a way to retreive the right row dao when we click on a row Detail link (there are complex use cases with cards arrays inside cards arrays)
					// -> We save the path of row ids and path of $bind in _rowDetailCache
					// To retreive the row dao we scan the current Dao from to pathBinds and pathRowIds
					var arrayData;
					if (self.$bind === pathBind[i]) {
						// We are on the current dao -> we take the current object dao
						// It's important in order to set rowDetail parent with the right dao object
						//  -> pageRegular.notifRowdetailUpdate -> childDao.updateParentRow will update the right parent dao
						arrayData = self._arrayData;
					} else {
						if (!dao) throw new Error("Unexpected null dao");
						// We are on a parent of the current dao -> we create a new dao object
						arrayData = dao.getArrayData(pathBind[i], proto);
					}
					// Search the row by id in dao
					var res = self.getRowById(pathId[i], arrayData);
					if (!res) {
						if (!isRowCreation) throw new Error("Unexpected empty row");
						res = {
							row: daoSdata.getArrayEmptyRow(this, proto, pathBind[i], dao)
						};
					}
					// Current dao	
					dao = res.row;
					// Current path root in protoype
					protoPath = ["$item.$properties"];
				}
				if (!dao || dao === self.getDao()) return;
				// we create the proto for detail row
				proto = daoSdata.getProtoRowDetail(this, proto);
				pathBind = info.pathBind.join('.');
				// Stores row Detail in info - RowDetail info will be requested by rowDetail page in loadData method
				self._rowDetailInfo = {
					// Path of the array from root (page) - use dto calculated the id of the rowDetail page
					pathBind: pathBind,
					// dao of rowDetail page
					dao: dao.clone(),
					// Proto of row detail page
					proto: proto,
					activity: info.activity
				};
				// Trigger a navigation to rowDetail page
				var attrs = {
					"data-control-id": self.id,
					"data-parent-id": self.controller.id,
					"data-nav": "rowdetail",
					"data-params": dao.getValue("$uuid")
				};
				if (self.controller.isVignette) {
					// It's the vignette which will load the page
					// We open row detail in the same vignette
					attrs["data-nav-target"] = "vignette";
				}
				// Notify last selected row - see selectLastSelectedRow - true to update UI because link doesn't destroy the page
				if (!isRowCreation) {
					notifications.notifyController("sm.select.row", self.controller, self.id, dao.getValue("$uuid"), null, true);
				}
				eventListener.triggerNavigation(self.$$elmt, attrs);
			} catch (e) {
				globals.getModal().error("Error loading row detail page", e);
			}
		},
		/**
		 * Click on display or edit row detail
		 * Id is stored in s-m-record parent dom elment
		 */
		_actRowDetail: function(rowInfofId) {
			this._openDetailRow(rowInfofId);
		},
		/**
		 * Click on create a new row
		 * Id is stored data-cation element
		 * This action is not really a row action, it's an array action
		 */
		_actRowCreate: function(rowInfofId) {
			this._openDetailRow(rowInfofId);
		},
		/**
		 * handle delete row
		 */
		_actRowDelete: function(rowId) {
			var self = this;
			// Info that has been set by the builder - Contains path of $binds and ids for each row displayed
			var info = self._rowDetailCache[rowId];
			if (!info) return;
			modal.simpleConfirm(locale.text("actions.del.confirm"), function(confirmed) {
				if (confirmed) {
					// Retreive the current array in path
					var pathBind = info.pathBind;
					var pathId = info.pathId;
					while (pathBind.length != 0 && pathBind[0] != self.$bind) {
						pathBind.shift();
						pathId.shift();
					}
					if (pathBind.length == 0) throw new Error("Unexpected null pathBind");
					var field = pathBind.pop();
					/**
					 * pathBind.length > 1 means that we have to retreive the row in a child according to pathId
					 * We can have this case if we edit an array cards inside a card. The current array is th card's parent and we wantto delete the row in a child array
					 * --> Not implemented for the moment because not tested
					 */
					if (pathBind.length > 1 || field !== self.$bind) {
						_notImplemented("Deleting row in an array embedded inside a card");
					} else {
						// TODO - Retreive the row in newted child arrays (id is unic) and delete it
					}
					// Temporarily - Remove row in current array
					self.removeRow(rowId);
				}
			});
		},
		/**
		 * Remove rowId in datasets and html
		 * Can be called also from regularPage when we click on Delete action in rowDetail footer
		 */
		removeRow: function(rowId) {
			// Remove the row in _arrayData
			var array = this._arrayData;
			if (!array || !array.$resources || array.$resources.length == 0) return;
			var idx = -1;
			array.$resources.some(function(r, i) {
				if (r.getValue("$uuid") === rowId) {
					idx = i;
					return true;
				}
			});
			if (idx < 0 || idx >= array.$resources.length) return;
			array.$resources.splice(idx, 1);
			// Remove the row in html	
			this.builder.removeRowById(rowId);
			// Remove the row in dao - If it's a single array we use idx becaus there's no uuid in backoffice data (uuid is added by tablet client in arrayData to manage singleArrasy like other arrays)
			this.getDao().deleteRow(this.$bind, this.prototype.isSingleArray() ? idx : rowId);
		},
		/**
		 * Register a row in rowDetail cache to be able to reteive infortiaon on ckcik on 'rowDetail' Link (_actRowDetail)
		 */
		rowDetailAdd: function(id, data) {
			this._rowDetailCache[id + ""] = data;
		},
		/**
		 *  Return the dao and other information of the selected row (see _actRowDetail)		 *
		 **/
		rowDetailGetInfo: function(create) {
			// Read/ Edit row detail
			return this._rowDetailInfo;
		},
		/**
		 * Return the page info used buy pageRegistry
		 */
		childPageGetPageInfo: function(typePage, currentPage) {
			var pageInfo = {
				home: false,
				type: typePage,
				cached: false,
				refreshed: false,
				changeHash: false
			};
			if (typePage === "rowdetail") {
				if (!this._rowDetailInfo) throw new Error("childPageGetPageInfo - Null details row data");
				pageInfo.prototype = this._rowDetailInfo.proto;
				pageInfo.subtype = currentPage.isEditMode() ? "edit" : "details";
				pageInfo.article = null;
				// To store the generated page in aplication page we nee the full path of the selected row
				// By exmaple for AQMCRUDM -  if we add a $article to the array level 1 we display i the card array level 2
				// When we click on rowDetail we need to display the row of level 2 ADEVADEVICEL.ADEVADEVICELADEVICELL
				// Page name is 
				//		AQMCRUDM.$details.ADEVADEVICEL if no article in ADEVADEVICEL
				//		AQMCRUDM.$details.ADEVADEVICEL.ADEVADEVICELADEVICELL if there's an article in ADEVADEVICEL
				//		AQMCRUDM.$details.ADEVADEVICEL.ADEVADEVICELADEVICELL.ADEVADEVICELADEVICELLDLLLif there's an article in ADEVADEVICEL.ADEVADEVICELADEVICELL
				pageInfo.name = currentPage.state.name + "." + this._rowDetailInfo.pathBind;
			} else if (typePage === "carddesign") {
				pageInfo.prototype = daoSdata.getProtoCardDesign(this);
				pageInfo.subtype = "details";
				pageInfo.article = this.article.$card ? this.article.$card : null;
				pageInfo.name = currentPage.state.name + "." + this.$bind + "." + typePage;
			}
			return pageInfo;
		},
		/**
		 * Select the last selected row
		 * lastSelectedrow is stored in page context and restores on back
		 * It highlights the last selected row
		 * Done by builder because depends on the way array has been rendered
		 */
		selectLastSelectedRow: function(rowId, show) {
			this.builder.selectLastSelectedRow(rowId, show);
		},
		/**
		 *	returns array rows
		 *		depends on the kind of page query/lookup or detail/edit
		 *		called one time to create the dao - then use getArrayData()
		 **/
		readArrayData: function(controllerDao) {
			var self = this;
			if (self.prototype.isQuery()) {
				return controllerDao.getQueryData(self.prototype);
			} else if (self.prototype.isLookup()) {
				return controllerDao.getLookupData(self.prototype);
			} else {
				return controllerDao.getArrayData(self.$bind, self.prototype);
			}
		},
		/**
		 *	Set array data - depends on array type
		 **/
		_setArrayData: function(controllerDao, refresh) {
			this._multiSelExit();
			this.isEmpty = true;
			// Clear control content
			if (refresh) {
				this.$$value.empty();
			} else {
				this.$$elmt.empty();
			}
			_destroyArrayData(this._arrayData);
			this._arrayData = controllerDao ? this.readArrayData(controllerDao) : {
				$resources: []
			};
			if (this._arrayData == null) throw new Error("Null arrayData");
			this.isEmpty = this._arrayData.$resources.length === 0;
			this.$$elmt.toggleClass("empty", this.isEmpty);
			if (!refresh) {
				// Build the base structure common to all ctrls - Title and value
				var title = this.getTitle();
				if (this._displayTitle(title)) {
					if (!this.$$ttl) this.$$ttl = $(uiUtils.createDomElement('div', ["s-m-title"])).appendTo(this.$$elmt);
					this.$$ttl.text(title);
				} else if (this.$$ttl) {
					this.$$ttl.empty();
				}
				// After title
				this.$$value = $(uiUtils.createDomElement('div', ["s-m-value"], null, null, this.$$elmt));
				this.$$value.before(this.$$header = $('<header/>'));
			}
			return this._arrayData;
		},
		_displayTitle: function(title) {
			if (title == null || title.trim().length === 0) return false;
			if (this.getAuthoring("$isTitleHidden") === true) return false;
			return this._displayArray();
		},
		_displayArray: function() {
			return this.controller.isEditMode() === true || this.isEmpty !== true || this.getAuthoring("$displayIfEmpty") === true;
		},
		/**
		 *	returns array rows
		 *		controllerDao optional
		 **/
		getArrayData: function() {
			return this._arrayData;
		},
		getNbRecords: function() {
			return this._arrayData ? this._arrayData.$resources.length : 0;
		},
		waitStart: function() {
			if (!this._waiting) {
				// TODO - Optimization
				this._waiting = uiUtils.waitWheelCreate(this.$$elmt.parent());
				this._waiting.$$bckg.css({
					position: "absolute"
				});
				this._waiting.$$wheel.css({
					position: "absolute"
				});
			}
			uiUtils.waitWheelStart(this._waiting);
		},
		waitStop: function() {
			if (this._waiting) {
				uiUtils.waitWheelStop(this._waiting);
			}
		},
		// arrayData is used for recursice search in arrays nested in arrays
		getRowById: function(rowId, arrayData) {
			var self = this;
			arrayData = arrayData || self._arrayData;
			if (!arrayData || !arrayData.$resources || arrayData.$resources.length == 0) return null;
			var idx = 0;
			var result = null;
			arrayData.$resources.some(function(r) {
				if (r.getValue("$uuid") === rowId) {
					result = r;
					return true;
				}
				idx++;
			});
			return result ? {
				row: result,
				idx: idx
			} : null;
		},
		// Used for single Arrays
		_getRowByIdx: function(idx, arrayData) {
			arrayData = arrayData || this._arrayData;
			idx = parseInt(idx, 10);
			if (!arrayData || !arrayData.$resources || arrayData.$resources.length <= idx) return null;
			return {
				row: arrayData.$resources[idx],
				idx: idx
			};
		},
		/**
		 * return the context to save. It will be be restored afer page has been loaded
		 */
		savedCtxCreate: function() {
			return this.builder.savedCtxCreate();
		},
		/**
		 * Called by the page to restore the context
		 */
		savedCtxRestore: function(ctx) {
			this.builder.savedCtxRestore(ctx);
		},
		getScrollViewRect: function() {
			if (this.controller.isVignette) {
				var v = this.controller.getParentVignette();
				return v ? v.getScrollViewRect() : null;
			} else {
				return this.controller.getMainContentRect();
			}
		},
		/**
		 * Returns idx from rowId
		 * Used by single arrays
		 */
		rowId2Idx: function(uuid) {
			if (!this._arrayData || !this._arrayData.$resources) return -1;
			var rowIdx = -1;
			this._arrayData.$resources.some(function(r, idx) {
				if (r.getValue("$uuid") === uuid) {
					rowIdx = idx;
					return true;
				}
			});
			return rowIdx;
		},
		_actActionArray: function(id, param) {
			if (id === globals.PANELFILTERSORT) {
				// Manual filters
				this.controller.panelAttach("right", this._filterSortPanel, "toggle");
				return;
			}
			if (id === "filterSelected") {
				// Selection of a filter given by the proto
				this.controller.$filtersSelect(param, this);
				return;
			}
			if (id === "search") {
				this.getSearcher().search(this);
				this.controller.searchRefresh(this);
				return;
			}
			if (id === "removeSearch") {
				this.getSearcher().removeSearch(this);
				this.controller.searchRefresh(this);
				return;
			}
		},
		/**
		 *  return array of sortInfo (not null)
		 */
		sortInfoGet: function() {
			var info = this.controller.filterSortRead("sort", this);
			if (info == null || info.length === 0) {
				var cols = this.builder.getColumnsInfo(true);
				if (cols) {
					info = [];
					cols.forEach(function(c) {
						if (_sortFilterExclude.indexOf(c.$type) === -1 && c.$capabilities && c.$capabilities.indexOf("sort") >= 0) {
							info.push({
								name: c.$title,
								// $bindValue is $bind for non reference field
								id: c.$bindValue,
								sort: "none"
							});
						}
					});
				}
				this.sortInfoSet(info, false);
			}
			return info;
		},
		sortInfoSet: function(info, refresh) {
			this.controller.filterSortWrite("sort", info, this, refresh);
		},
		/**
		 *  returns an array of filterInfo
		 */
		filterInfoGet: function() {
			var info = this.controller.filterSortRead("filter", this);
			return info;
		},
		/**
		* Sets filter info. Array of objects 
		* {
		*	fieldName : "fieldName",
		*	operatorLabel: "operator label",
		*	value: "value",
		*	operator: "operator code"
		}
		*/
		filterInfoSet: function(info, refresh) {
			this.controller.filterSortWrite("filter", info, this, refresh);
		},

		/**
		 * Returns filters map with following structure
		 *  [{
		 *		fieldName: 'field name',
		 *		operators: [], // array of possible operators according to field type,
		 *		id: proto.getFieldNameForValue(key),
		 *		prop: propertyValue, // Object
		 *		isReference: isReference // Boolean. Whether property is a reference or not
		 *	}, ...]
		 */
		searchInfoGet: function() {
			return this.getSearcher().getSearchInfos();
		},
		filterMapGet: function() {
			var self = this;
			var map = [];
			var props = this.builder.getColumnsInfo(false);
			if (props) {
				props.forEach(function(prop) {
					if (_sortFilterExclude.indexOf(prop.$type) === -1 && prop.$capabilities && prop.$capabilities.indexOf("filter") >= 0) {
						map.push({
							fieldName: prop.$title,
							operators: fieldOperators.getOperators(prop.$type),
							// $bindValue is $bind for non reference field
							id: prop.$bindValue,
							prop: prop,
							isReference: prop.$type.indexOf("x-reference") >= 0
						});
					}
				});
			}
			return map;
		},
		/**
		 * Retunrs the option for header - Should work in buildHtml and refresh
		 */
		getHeaderOptions: function() {
			var queryOrLookup = !this.isArrayField();
			var opts = {};
			// This is a query array
			// Manual sort/filters
			opts.filterEnabled = opts.sortEnabled = opts.paginEnabled = opts.searchEnabled = queryOrLookup;
			opts.searchEnabled = (opts.searchEnabled && !this.controller.offLine);
			// Filters given by prototype
			opts.$filters = queryOrLookup && this.controller.$filtersGet ? this.controller.$filtersGet() : null;
			return opts;
		},
		/**
		 * none/tabs/list
		 */
		$filtersGetAuthoring: function() {
			var auth = this.getAuthoring("$filters", this.controller.isVignette ? "none" : "list");
			if (auth !== "none" && globals.getSiteLayout().getDeviceType() === "smartphone") {
				auth = "tabs";
			}
			return auth;
		},
		/**
		 * enable/disable multiselection
		 */
		multiSelSetMgr: function(mgr) {
			if (this._multiselHandler) {
				this._multiselHandler = null;
			}
			if (mgr) {
				this._multiselHandler = jsutils.bindFn(mgr.callbackArray, mgr);
			}
		},
		/**
		 * Array as changed - Exit multisselection if any
		 */
		_multiSelExit: function() {
			if (this._multiselHandler) {
				this._multiselHandler(this, "$exitmultisel", null);
			}
		},
		/**
		 * Row selection
		 */
		_multiSelSelect: function($$target) {
			if (this._multiselHandler) {
				this._multiselHandler(this, "$selectmultisel", $$target);
				return true;
			}
			return false;
		},
		/**
		 * Multiselection action is selectAll, unselectAll
		 * data-action with ctrlmId == array's id
		 */
		_actMultiSelectionAction: function(params, $target) {
			if (!this._multiselHandler) return;
			this._multiselHandler(this, params, $target);
		},
		authOnSlideMinSize: function(size, action) {
			if (this.builder.$display != "card" || !this._arrayData || this._arrayData.length > 0) return;
			var value = this.builder.authMinSize2Pixels(size);
			var left = ((this.$$value.width() - value) / 2) + "px";
			value += "px";
			if (action == "start") {
				var height = this.$$value.find(this.$$value.find('[data-params="' + this._arrayData.$resources[0].getValue("$uuid") + '"]')).height();
				this.$$value.css({
					opacity: "0.3"
				});
				this._$$cardSize = $('<div class="s-m-auth-minsize"><span>Min size' + value + '</span></div>').appendTo(this.$$elmt);
				this._$$cardSize.css({
					height: height + "px",
					width: value,
					top: ((this.$$value.height() - height) / 2) + "px",
					left: left
				});
				return;
			}
			if (action == "stop") {
				this.$$value.css({
					opacity: "inherit"
				});
				this._$$cardSize.remove();
				this._$$cardSize = null;
				return;
			}
			if (action == "slide") {
				if (this._$$cardSize) {
					// slide action is called to get the text to display before starting the slider
					this._$$cardSize.css({
						width: value,
						left: left
					});
					if (!this._minCardText) {
						this._minCardText = locale.text("array.minCardWidth") + " ";
						this._minCardSpan = this._$$cardSize.children("span");
					}
					this._minCardSpan.text(this._minCardText + value);
				}
				return value;
			}
		},
		setCardAuthoring: function(article) {
			this.article.$card = article;
			notifications.publish("sm.auth.change.item.prop.ui");
		},
		// Only for test entities - We can attach an article to a link to detail or query
		getLinkedPageArticle: function() {
			return this._forceArticle;
		},
		notifLayoutExpanded: function() {
			this.onResize();
		},
		getSearcher: function() {
			return this._search;
		},
		checkCapabilities: function(value) {
			if (value == null) return true;
			if (!this._capabilities) {
				this._capabilities = {};
				var self = this;
				(this.getMetaData("$capabilities") || "").split(',').forEach(function(c) {
					c = c.trim();
					if (c.length > 0) {
						self._capabilities[c.trim()] = true;
					}
				});
			}
			return this._capabilities[value] === true;
		},
		getRowStatusInfo: function() {
			if (this.getAuthoring("$statusEnabled") === true) {
				var status = this.getAuthoring("$status");
				return status && status.length > 0 ? status : null;
			}
			return null;
		},
		toggleColorStatus: function(disable) {
			if (this.$display == "table" || this.getRowStatusInfo() == null) return;
			var style = disable ? "inherit" : "";
			this.$$value.find(".s-m-status-color").css({
				"background-color": style,
				"color": style
			});
		},
		/**
		 * Height/Width available to render the array
		 */
		getAvailableSize: function() {
			return {
				height: this.$$elmt.height() - this.$$header.height(),
				width: this.$$value.width()
			};
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/field/ctrlReference',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/sdata/sdataUtils','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

/**
 *
 */

var _Klass = utils.defineClass(

	function CtrlReference(controller, article, prototype, options) {
		var self = this;
		Base.call(self, controller, article, prototype, options);
		// See ctrlQuantity - Control that displays the unit
		self.isUnit = self.options.isUnit === true;
		if (self.isUnit) {
			self.$isEditMode = false;
			self.cssType = "s-m-unit";
		} else {
			self.cssType = "s-m-ref";
		}
	}, Base, {
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			this.picker = null;
		},
		getValue: function(prop) {
			var val = Base.prototype.getValue.call(this);
			return val ? val[prop || "$value"] || "" : "";
		},
		buildFieldTitle: function(fieldSlot, buildOptions) {
			var self = this;
			return self.isUnit ? null : Base.prototype.buildFieldTitle.call(self, fieldSlot, buildOptions);
		},
		buildFieldValue: function(fieldSlot, buildOptions) {
			var self = this;
			var parentElmt = Base.prototype.buildFieldValue.call(self, fieldSlot);
			var value = self.getValue();
			if (self.$isEditMode) {
				self.buildEditValue(parentElmt, self.getValue());
			} else {
				var descr = (self.getValue("$description") || "").trim();
				var title = (self.getValue("$title") || "").trim();
				if (self.isUnit) {
					self.buildUnitValue(parentElmt, value, descr, title);
				} else {
					self.buildDetailValue(parentElmt, value, descr, title, buildOptions);
				}
			}
		},
		buildEditValue: function(parentElmt, value) {
			var self = this;
			var bsInputGroup = uiUtils.createDomElement("div", ["input-group"], null, null, parentElmt);
			self.createMainInput(bsInputGroup, self.getFormattedValue(value));
			var $lookuplink = this.getMetaData("$isReadOnly") !== true && this.getMetaData("$isDisabled") !== true ? self.prototype.getDataByPath("$item.$links.$lookup") : null;
			if (!$lookuplink) {
				$(bsInputGroup).css({
					width: "100%"
				});
				return;
			}
			// get dom $lookup link parameters/attributes
			var span = uiUtils.createDomElement("span", ["input-group-btn"], null, null, bsInputGroup);
			var attrs = self._getLinkAttrs(sdataUtils.getLinkInfo($lookuplink.$url, self.getDao()), {
				"data-param": self.id,
				"data-parent-id": self.controller.id,
				"data-control-id": self.id,
				"title": self.prototype.resolveExpression($lookuplink.$title) || "Lookup"
			});
			self.picker = uiUtils.createDomElement("a", ["btn", "btn-default", "s-m-meta"], null, attrs, span);
			uiUtils.createDomElement("span", fontUtils.refFieldIcon(), null, null, self.picker);
		},
		buildDetailValue: function(parentElmt, value, descr, title, buildOptions) {
			var self = this;
			// build container - Disable link to lookup entity in tables
			var container = buildOptions && buildOptions.displayCtx === "table" ? parentElmt : self.addLink(parentElmt);

			// build container of reference value if any
			if (value.length > 0) {
				// set description content according to authoring value of $refDescFormat
				// Available values are desc, title, desctitle, and titledesc. Default is "desc"
				var descContent;
				var $refDescFormat = self.getAuthoring("$refDescFormat");
				switch ($refDescFormat) {
					case "title":
						descContent = title;
						break;
					case "desctitle":
						descContent = self._combineTexts(descr, title);
						break;
					case "titledesc":
						descContent = self._combineTexts(title, descr);
						break;
						// "desc" will be considered as default
					default:
						descContent = descr;
						break;
				}

				// build content and set position according to description content authoring position $refDescPosition
				// available values are bottom, right, left, top, none. Default is "right"
				var $refDescPosition = self.getAuthoring("$refDescPosition");
				var $$value = $("<div>").addClass("s-m-ref-val").text(value);
				var $$desc = $("<div>").addClass("s-m-descr").text(descContent);
				var arr;
				switch ($refDescPosition) {
					case "bottom":
						$(container).append($$value).append($$desc);
						break;
					case "left":
						$(container).append($$desc).append($$value);
						arr = [$$value, $$desc];
						$.each(arr, function(index, $$ee) {
							$$ee.css("display", "inline-block");
						});
						$$desc.css("padding-right", "5px");
						break;
					case "top":
						$(container).append($$desc).append($$value);
						break;
					case "none":
						$(container).append($$value);
						break;
					case "right": // "right" will be considered as default
					default:
						arr = [$$value, $$desc];
						$(container).append($$value).append($$desc);
						$.each(arr, function(index, $$ee) {
							$$ee.css("display", "inline-block");
						});
						$$desc.css("padding-left", "5px");
				}
			}
		},
		buildUnitValue: function(parentElmt, value, descr, title) {
			var self = this;
			var label = descr.length > 0 ? descr : title.length > 0 ? title : value;
			// TODO See how we display unit
			label = value || "";
			if (label && label.toLowerCase) label = label.toLowerCase().smCapitalize();
			uiUtils.createDomElement("span", ["s-m-descr"], label, null, self.addLink(parentElmt));
		},
		addLink: function(parentElmt) {
			var self = this;
			if (self.options.displayCtx === "card") return parentElmt;
			var $detaillink = self.prototype.getDataByPath("$item.$links.$details");
			// if links && $links.$details, container is an anchor, otherwise it is a simple div
			if ($detaillink) {
				// get dom link parameters/attributes (we consider only $details)
				return uiUtils.createDomElement("a", null, null, self._getLinkAttrs(sdataUtils.getLinkInfo($detaillink.$url, self.getDao()), {
					"title": self.prototype.resolveExpression($detaillink.$title) || "Detail"
				}), parentElmt);
			} else {
				return parentElmt;
			}
		},
		getFormattedValue: function(value) {
			return value;
		},
		// lookupData - {data, proto} - data: selected JSON data - proto - prototype of row data
		setLookupValue: function(lookupData) {
			if (!lookupData) {
				console.log("setLookupValue Error - bind", this.$bind, "No lookupData");
				return;
			}
			if (!lookupData.data) {
				console.log("setLookupValue Error - bind", this.$bind, "No data");
				return;
			}
			var field = (this.prototype.getDataByPath("$item") || {}).$lookupValue;
			if (!field) {
				console.log("setLookupValue Error - bind", this.$bind, "No $lookupValue");
				return;
			}
			var proto = lookupData.proto;
			if (proto) {
				// proto allows to read $title, $description in lookupData.data if we want to diplay them
			}
			var value = lookupData.data[field];
			if (value == null) {
				value = "";
				console.log("setLookupValue Error - bind", this.$bind, "No field value", field);
			}
			this.setFieldValue(value);
		},
		/**
		 * data: 		string with value
		 * 				object with {$value:,$description:,$title:}
		 */
		setDisplayValue: function(value) {
			var strData;
			if ($.isPlainObject(value)) {
				strData = value.$value || "";
			} else {
				strData = value || "";
			}
			Base.prototype.setDisplayValue.call(this, strData);
		},
		_getLinkAttrs: function(link, options) {
			var self = this;
			var attrs = {
				"href": "#",
				"data-nav": link.page,
				"data-sdata-url": link.sDataUrl
			};
			if (self.controller.isVignette) {
				// Its the vignette which will load the page - Do not modify it - FDB
				attrs["data-nav-target"] = self.controller.openLinkInVignette() ? "vignette" : "application";
			}
			if (options) {
				for (var p in options) attrs[p] = options[p];
			}
			return attrs;
		},
		_combineTexts: function(el1, el2) {
			var res;
			// el1-el2 || el1 || el2
			res = (el1 && el2) ? (el1 === el2 ? el1 : el1 + "-" + el2) : (el1 || el2 || "");
			return res;
		}

	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/layout/layoutBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/structElmt','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/structElmt').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _Klass = utils.defineClass(function LayoutBase(controller, type, article, opts) {
	var self = this;
	Base.call(self, controller, type, article, opts);
	self.title = article.$title;
}, Base, {
	/**
	 * Init the properties to allow reuse of this control
	 */
	initReuseProperties: function() {
		Base.prototype.initReuseProperties.call(this);
		this.$$header = null;
	},
	destroy: function() {
		var self = this;
		Base.prototype.destroy.call(self);
	},
	createId: function(typeName) {
		var self = this;
		return utils.readableuid(typeName);
	},
	buildHtml: function($$parent, controllerDao, buildOptions) {
		var self = this;
		Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions);
		self.createRootElement(["s-m-layout"], $$parent);

		if (self.article.$title && (buildOptions == null || buildOptions.noTitle !== true)) {
			self.buildTitle();
		}
		if (self.article.$icon && (buildOptions == null || buildOptions.noIcon !== true)) {
			self.buildIcon();
		}
	},
	/**
	 * Needed to call afterRender in mode generator - isHtmlGenerator
	 * afterRender applies the meta-data - Used to apply meta-data in cards
	 */
	buildChildrenHtml: function($parent, controllerDao, buildOptions) {
		var self = this;
		if (self.children) {
			$.each(self.children, function(index, child) {
				child.buildHtml($parent, controllerDao, buildOptions);
				/**
				 * TODO - call build html inside a render method that call a process before (sets Dao and after removes dao and calls afterRender
				 */
				if (child.afterRender && buildOptions && (buildOptions.isHtmlGenerator === true || buildOptions.afterRender === true)) {
					child.afterRender(buildOptions);
				}
			});
		}
	},
	onResize: function(context) {
		if (!this.children) return;
		this.children.forEach(function(child) {
			if (child.onResize) child.onResize(context);
		});
	},
	_ensureHeader: function() {
		if (!this.$$header) {
			this.$$header = $(uiUtils.createDomElement('header', null, "", null, this.$$elmt));
		}
		return this.$$header;
	},
	buildIcon: function($$rootLyt, $$parent, controllerDao, destroyAfter) {
		this._ensureHeader();
		var icon = fontUtils.getIconByName(this.article.$icon);
		if (icon) {
			this.$$header.prepend('<icon class="s-m-ttl-icon ' + icon + '">');
		}
	},
	buildTitle: function($$rootLyt, $$parent, controllerDao, destroyAfter) {
		this._ensureHeader();
		this.$$header.text(this.getArticleText("$title"));
	},
	// Only hub layout is able to scroll
	getGestureMgr: function() {
		return null;
	},
	isLayout: function() {
		return true;
	},
	isHubLayout: function() {
		return false;
	}
});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/layout/layoutRow',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/layout/layoutBase'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/layout/layoutBase').Klass;

/**
 */
var _Klass = utils.defineClass(

	function LayoutRow(controller, type, article, opts) {
		var self = this;
		Base.call(self, controller, type, article, opts);
	}, Base, {

		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions);
			self.$$elmt.addClass("s-m-row");
			self.$$elmt.addClass("row");
			self.buildChildrenHtml(self.$$elmt, controllerDao, buildOptions);
		}
	}
);

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/layout/layoutStack',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/layout/layoutBase','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/layout/layoutBase').Klass;
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

/**
 * cssOptions
 * 		cssLayout, cssCell: class added to default ones
 * default classes can  be overridden
 */
var _Klass = utils.defineClass(
	function LayoutStack(controller, type, article, opts) {
		var self = this;
		Base.call(self, controller, type, article, opts);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this.$$btnCollapse) {
				this.$$btnCollapse.off();
				this.$$btnCollapse = null;
			}
		},

		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions);

			self.$$elmt.addClass("s-m-stack");
			if (buildOptions && buildOptions.makeFullHeight === true) {
				self.$$elmt.height("100%");
			}

			var $collapsible = (self.article && self.article.$collapsible) || "notcollapsible";
			var $title = (self.article && self.article.$title) || "";
			if ($collapsible !== "notcollapsible" || $title.length > 0) {
				self._addHeader($collapsible, this.getArticleText("$title"));
			}
			self.$$content = $("<content>");
			self.$$elmt.append(self.$$content);
			self.buildChildrenHtml(self.$$content, controllerDao, buildOptions);
			self._updateCollapseState();
		},

		buildTitle: function($$rootLyt, $$parent, controllerDao, destroyAfter) {
			// When there is a $title attribute in the article,
			// layoutBase will create the title for all child classes
			// Since a stack layout generates a "special" title which allows collapsing, we override
			// the function here to not get two titles
		},

		_addHeader: function(state, title) {
			var self = this;
			self.$$header = $('<header>').text(title);
			if (state !== "notcollapsible") {
				/* We don't use data-action because collapse button must work in authoring mode - data-action click handler is overridden by select authoring handler */
				self.$$btnCollapse = $('<btn class="' + state + '">').appendTo(self.$$header).on("click", jsutils.bindFn(this._actCollapse, this));
			}
			self.$$elmt.append(self.$$header);
		},
		_actCollapse: function(events, setCollapse) {
			if (events) {
				events.stopPropagation();
			}
			if (!this.$$btnCollapse) return;
			if (setCollapse === true) {
				this.$$btnCollapse.removeClass("expanded").addClass("collapsed");
			} else if (setCollapse === false) {
				this.$$btnCollapse.removeClass("collapsed").addClass("expanded");
			} else {
				this.$$btnCollapse.toggleClass("collapsed").toggleClass("expanded");
			}
			this._updateCollapseState();
			/**
			 * We need to update the scroller because height has changed
			 */
			notifications.notifyController("sm.page.updt.scroll", this.controller, true);
			if (!this.$$btnCollapse.hasClass("collapsed")) {
				/**
				 * We need to notify elements like array to refresh them - They are not displayed if !.is(":visible")
				 */
				notifications.publish("sm.layout.expanded");
			}
		},

		_updateCollapseState: function() {
			var self = this;
			if (!self.$$btnCollapse || !self.$$content) {
				return;
			}
			var collapse = self.$$btnCollapse.hasClass("expanded");
			self.$$content.toggle(collapse);
		},

		getAuthState: function(dirtyKeys) {
			var self = this;
			// If collapsed state has been changed, we do not store that state
			if (dirtyKeys.$collapsible) {
				return null;
			}
			return {
				collapsed: self.$$btnCollapse ? self.$$btnCollapse.hasClass("collapsed") : false
			};
		},

		setAuthState: function(state) {
			if (state && state.collapsed != null) {
				this._actCollapse(null, state.collapsed);
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/layout/layoutTab',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/layout/layoutBase','syracuse-tablet/html/js/ui/uiUtils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/layout/layoutBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');

var _Klass = utils.defineClass(
	function LayoutTab(controller, type, article, opts) {
		var self = this;
		Base.call(self, controller, type, article, opts);
	}, Base, {
		/**
		 * Build Html recursively
		 */

		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions);
			self.$$elmt.addClass("s-m-tabs");
			var slot = uiUtils.createDomElement("div", [self.article.$layoutType]);
			$.each(self.children, function(index, layout) {
				layout.isTabSection = true;
				var item = uiUtils.createDomElement("div", ["s-m-layout-cell"], null, {
					"style": "display:" + (index != 0 ? "none" : "")
				}, slot);
				layout.buildHtml($(item), controllerDao, buildOptions);
			});
		},
		/**
		 * TODO - FDB - DOESNT WORK - Not attached to DOM
		 */
		buildTitle: function() {
			/*
			var self = this;
			var header = uiUtils.createDomElement('header', ["s-m-layout-header"]);
			var tabSlot = uiUtils.createDomElement("div", ["s-m-tabs-slot"]);
			var tabsContainer = uiUtils.createDomElement("ul", ["nav,nav-tabs"], null, {
				"role": "tablist"
			});
			$.each(self.children, function(index, layout) {
				var tabClass = index == 0 ? ["active"] : null;
				var tab = uiUtils.createDomElement("li", tabClass);
				var tabLink = uiUtils.createDomElement("a", ["s-m-tab"], layout.article.$title, {
					"href": "#"
				});
				tab.appendChild(tabLink);
				tabsContainer.appendChild(tab);
			});
			tabSlot.appendChild(tabsContainer);
			container.appendChild(header);
			*/
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/layout/layoutHub',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/layout/layoutBase','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/hammerScroller','syracuse-tablet/html/js/helpers/uiSettings'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/layout/layoutBase').Klass;
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var HammerScroller = require('syracuse-tablet/html/js/helpers/hammerScroller').Klass;
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');

/**
 * Top level layout node that must only contain layoutHubGroups as children
 * This "hub" expands horizontally and only uses the available vertical space
 * Use this to define pages which only scroll horizontally
 */
var _Klass = utils.defineClass(
	function LayoutHub(controller, type, article, opts) {
		var self = this;
		Base.call(self, controller, type, article, opts);
		this._gestureMgr = null;
		this._tilesGroupSpacing = uiSettings.getProp("hubLayout.groupSpacing");
		this._minLandscapeHeigth = uiSettings.getProp("hubLayout.landscapeMinHeigth");
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},

		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			buildOptions = buildOptions || {};
			Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions);
			self.$$elmt.addClass("s-m-hub");
			self.$$scrollElmt = $('<div class="s-m-scroll-wrapper">').appendTo(self.$$elmt);
			self.buildChildrenHtml(self.$$scrollElmt, controllerDao, buildOptions);
			if (self._gestureMgr) {
				self._gestureMgr.reset();
			} else {
				/**
				 * Direction and valMax will be set on onResize when we know the orientations
				 * _gestureMgr needs to be created here to be able to store the restored value (see dashboard.savedCtxRestore)
				 * On back navigation we should restore the scrolling
				 */
				self._gestureMgr = new HammerScroller(self.$$scrollElmt, {
					isPageScroller: true
				});
			}
		},
		/**
		 * Resize handler called by window.resize
		 */
		onResize: function(context) {
			if (context && context.footerSwipe === true) {
				// To not resize the tiles on footerSwipe - TODO test and improve
				return;
			}
			var self = this;

			/**
			 * Returns the visible rectangle of main page content
			 *
			 */
			var parentRect = self.controller.getMainContentRect();
			var pos = self.$$elmt.position();

			var w = parentRect.width;
			var h = parentRect.height - pos.top; // - 10;

			var rel = w / h;
			var posX = 0;
			var posY = 0;
			var opts;
			/* Layout orientation */
			self.scrollDirection = (rel > 1.2 && h >= this._minLandscapeHeigth) ? "h" : "v";
			if (self.scrollDirection === "h") {
				self.$$elmt.css({
					width: "100%",
					height: h + "px"
				});
			} else {
				self.$$elmt.css({
					width: w + "px",
					height: "100%"
				});
			}
			if (self.children) {
				var last = self.children.length - 1;
				self.children.forEach(function(child, idx) {
					opts = {
						posX: posX,
						posY: posY,
						maxHeight: h,
						maxWidth: w,
						scrollDirection: self.scrollDirection
					};
					child.onResize(context, opts);
					if (self.scrollDirection === "h") {
						posX += child.getWidth() + (idx < last ? self._tilesGroupSpacing : 0);
					} else {
						posY += child.getHeight() + (idx < last ? self._tilesGroupSpacing : 0);
					}
				});
			}
			var width, height;
			if (self.scrollDirection === "h") {
				width = posX;
				height = h;
			} else {
				width = w;
				height = posY;
			}
			// Reset old scrolling
			self._gestureMgr.resetScrolling(function() {
				// Used by scroller
				self.$$scrollElmt.width(width);
				self.$$scrollElmt.height(height);

				var scrollRect = uiRect.elmtRect(self.$$scrollElmt, "outer");
				var viewRect = parentRect.intersectRect(scrollRect);
				viewRect != null && !viewRect.contains(scrollRect) ? viewRect : null;
				if (viewRect) {
					self._gestureMgr.init(viewRect, self.scrollDirection, 0);
				} else {
					self._gestureMgr.reset();
				}
			});
		},
		/**
		 * layout hub gesture manager is the gesture manager of the dashboard
		 * in dashborad we don't scroll the whole page but just the content ofthe layout hub
		 * This method returns the _gestureMgr attached to the dashboard
		 */
		getGestureMgr: function() {
			return this._gestureMgr;
		},
		/**
		 * Context to store when dashboard is destroyed
		 * We save gesture manager context (scroll)
		 */
		savedCtxCreate: function() {
			return this._gestureMgr ? {
				hubScroll: this._gestureMgr.savedCtxCreate()
			} : null;
		},
		/**
		 * Restore the context for the hublayout
		 */
		savedCtxRestore: function(ctx) {
			if (ctx != null && this._gestureMgr) {
				// Restore the scroll of hub layout
				this._gestureMgr.savedCtxRestore(ctx.hubScroll);
			}
		},
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/layout/layoutHubGroup',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/layout/layoutBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/uiSettings'],function (require, exports, module) {

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/layout/layoutBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');

var _validSizes = ["small", "medium", "wide", "large", "full", "all"];

/**
 * Layout node that can only be used inside layoutHub parent nodes
 * Renders a group of tiles using the available space from top to bottom and then wraps to the right
 * Child elements bound to this layout may set "$size" attribute to define their size:
 * - small		- four tiles will fit into one group from left to right
 * - medium		- two tiles fit into one group from left to right, also double height of "small"
 * - wide		- one tile fits into one group from left to right, same height as "medium"
 * - large		- same width as "wide" and double height of "wide"/"medium"
 * - full		- same width as "wide", uses one full column (rounded to tile size medium)
 */
var _Klass = utils.defineClass(
	function LayoutHubGroup(controller, type, article, opts) {
		var self = this;
		Base.call(self, controller, type, article, opts);
		self._settings = uiSettings.getProp("hubGroup");
	}, Base, {
		/**
		 * Build full html structed but do not yet apply position and size attributes (Will be done in a later step or on resize)
		 */
		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions);
			self.$$elmt.addClass("s-m-hub-group");

			self._buildCellStructure(controllerDao, buildOptions);
		},

		_buildCellStructure: function(controllerDao, buildOptions) {
			var self = this;
			self.cells = [];
			var cell = null;

			self.children && self.children.forEach(function(layout) {
				var size = (layout.article && layout.article.$size) || "medium";
				if (_validSizes.indexOf(size) < 0) {
					size = _validSizes[1];
					layout.article = layout.article || {};
					layout.article.$size = size;
				}
				if (!cell) {
					cell = self._createCell(size);
					cell.domItem = uiUtils.createDomElement("div", null, null, null, self.$$elmt);
					self.cells.push(cell);
				}
				if (size === "small") {
					layout.buildHtml($(cell.domItem), controllerDao, buildOptions);
					cell.children.push(layout);
					if (cell.children.length === 4) {
						cell = null;
					}
				} else {
					if (cell.children.length > 0) {
						cell = self._createCell(size);
						cell.domItem = uiUtils.createDomElement("div", null, null, null, self.$$elmt);
						self.cells.push(cell);
					}
					layout.buildHtml($(cell.domItem), controllerDao, buildOptions);
					cell.children.push(layout);
					cell = null;
				}
			});
		},

		_createCell: function(size) {
			var self = this;
			size = (size === "small" ? "medium" : size);
			var cell = {
				size: size,
				children: []
			};
			return cell;
		},

		onResize: function(context, options) {
			this.calculateLayout(options);
			Base.prototype.onResize.call(this, context);
		},


		calculateLayout: function(options) {
			var self = this;
			var size;

			self._headerSpace = self.$$header ? self.$$header.height() : 0;
			self._width = 0;
			self._height = 0;

			self.hubGroupOptions = options;

			if (self.hubGroupOptions.scrollDirection === "h") {
				self._calculateLayoutHorizontal();
			} else {
				self._calculateLayoutVertical();
			}

			self.cells.forEach(function(cell) {
				size = cell.size;
				cell.domItem.style.left = cell.x + "px";
				cell.domItem.style.top = (cell.y + self._headerSpace) + "px";
				cell.domItem.style.width = self._sizes[size].width + "px";
				cell.domItem.style.height = self._sizes[size].height + "px";
				cell.domItem.style.position = "absolute";

				if (cell.x + self._sizes[size].width > self._width) {
					self._width = cell.x + self._sizes[size].width;
				}
				if (cell.y + self._sizes[size].height > self._height) {
					self._height = cell.y + self._sizes[size].height;
				}

				var x = 0;
				var y = 0;
				cell.children.forEach(function(tileLayout) {
					size = tileLayout.getAuthoringSize();
					tileLayout.calculateLayout(x, y, size, self._sizes[size]);
					if (x !== 0) {
						x = 0;
						y += self._sizes[size].height + self.hubGroupOptions.padY;
					} else {
						x += self._sizes[size].width + self.hubGroupOptions.padX;
					}
				});
			});

			var style = self.$$elmt.get(0).style;
			if (self.hubGroupOptions.scrollDirection === "h") {
				if (self.cells.length < 1 && globals.isAuthoringActive()) {
					self._width = self.hubGroupOptions.maxGroupWidth;
				}
				style.top = "0px";
				style.left = self.hubGroupOptions.posX + "px";
				style.width = 6 + self._width + "px";
				style.height = (self.hubGroupOptions.maxHeight - 6) + "px";
			} else {
				if (self.cells.length < 1 && globals.isAuthoringActive()) {
					self._height = self.hubGroupOptions.baseSize;
				}
				style.top = self.hubGroupOptions.posY + "px";
				style.left = "0px";
				self._width = self._width;
				style.width = self._width + "px";
				self._height += self._headerSpace + self._settings.portraitPadY;
				style.height = self._height + "px";
				if (self.cells.length < 1 && globals.isAuthoringActive()) {

				}
			}
		},

		/**
		 * Calc tile positions in horizontal scrolling model
		 */
		_calculateLayoutHorizontal: function() {
			var self = this;

			// Asume default base size
			self.hubGroupOptions.baseSize = self._settings.landscapeBaseSize;
			self.hubGroupOptions.padX = self._settings.landscapePadX;
			self.hubGroupOptions.padY = self._settings.landscapePadY;
			self.hubGroupOptions.maxGroupHeight = self.hubGroupOptions.maxHeight - self._headerSpace; //- 6;

			// How many tiles fit vertically?
			var maxTiles = self.hubGroupOptions.maxGroupHeight / (self.hubGroupOptions.baseSize + self.hubGroupOptions.padY);
			var remainPixels = self.hubGroupOptions.maxGroupHeight - Math.floor(maxTiles) * (self.hubGroupOptions.baseSize + self.hubGroupOptions.padY);
			var remainPerTile = Math.floor(remainPixels / maxTiles);
			var paddingPerTile = Math.floor(remainPixels / maxTiles / 2);
			self.hubGroupOptions.baseSize += remainPerTile;
			self.hubGroupOptions.paddingPerTile = paddingPerTile;

			self.hubGroupOptions.maxGroupWidth = 4 * self.hubGroupOptions.baseSize + 3 * self.hubGroupOptions.padX;

			self.hubGroupOptions.maxFullTileHeight = Math.floor((self.hubGroupOptions.maxGroupHeight + self.hubGroupOptions.padY) / (self.hubGroupOptions.baseSize + self.hubGroupOptions.padY) / 2) * (self.hubGroupOptions.baseSize + self.hubGroupOptions.padY) * 2 - self.hubGroupOptions.padY;
			self.hubGroupOptions.maxAllTileHeight = self.hubGroupOptions.maxFullTileHeight;
			self.hubGroupOptions.maxAllTileWidth = Math.floor((self.hubGroupOptions.maxWidth + self.hubGroupOptions.padX) / (self.hubGroupOptions.baseSize + self.hubGroupOptions.padX) / 2) * (self.hubGroupOptions.baseSize + self.hubGroupOptions.padX) * 2 - self.hubGroupOptions.padX;

			self._sizes = {
				small: {
					width: self.hubGroupOptions.baseSize,
					height: self.hubGroupOptions.baseSize,
					paddingX: self.hubGroupOptions.paddingPerTile,
					paddingY: self.hubGroupOptions.paddingPerTile
				},
				medium: {
					width: self.hubGroupOptions.baseSize * 2 + self.hubGroupOptions.padX,
					height: self.hubGroupOptions.baseSize * 2 + self.hubGroupOptions.padY,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 2,
					paddingY: self.hubGroupOptions.paddingPerTile, // * 2,
				},
				wide: {
					width: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padX * 3,
					height: self.hubGroupOptions.baseSize * 2 + self.hubGroupOptions.padY,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 4,
					paddingY: self.hubGroupOptions.paddingPerTile, // * 2,
				},
				large: {
					width: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padX * 3,
					height: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padY * 3,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 4,
					paddingY: self.hubGroupOptions.paddingPerTile, // * 4,
				},
				full: {
					width: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padX * 3,
					height: self.hubGroupOptions.maxFullTileHeight,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 4,
					paddingY: self.hubGroupOptions.paddingPerTile,
				},
				all: {
					height: self.hubGroupOptions.maxAllTileHeight,
					width: self.hubGroupOptions.maxAllTileWidth,
					paddingX: self.hubGroupOptions.paddingPerTile,
					paddingY: self.hubGroupOptions.paddingPerTile,
				}
			};

			var relX = 0;
			var relY = 0;
			var x = 0;
			var y = 0;

			self.cells.forEach(function(cell) {
				cell.w = self._sizes[cell.size].width;
				cell.h = self._sizes[cell.size].height;
				if ((y + cell.h > self.hubGroupOptions.maxGroupHeight) ||
					(y !== 0 && (cell.size === "full" || cell.size === "all"))) // full/all size cell always use one full column 
				{
					y = 0;
					relX += self.hubGroupOptions.maxGroupWidth + self.hubGroupOptions.padX;
					x = relX;
				}
				if (cell.size === "medium") {
					if ((x - relX) + cell.w > self.hubGroupOptions.maxGroupWidth) {
						x = relX;
						y += cell.h + self.hubGroupOptions.padY;
					}
					if (y + cell.h > self.hubGroupOptions.maxGroupHeight) {
						y = 0;
						relX += self.hubGroupOptions.maxGroupWidth + self.hubGroupOptions.padX;
						x = relX;
					}
					cell.x = x;
					cell.y = y;
					x += cell.w + self.hubGroupOptions.padX;
				} else {
					if (x !== relX) {
						x = relX;
						y += self._sizes.medium.height + self.hubGroupOptions.padY;
					}
					if (y + cell.h > self.hubGroupOptions.maxGroupHeight) {
						y = 0;
						relX += self.hubGroupOptions.maxGroupWidth + self.hubGroupOptions.padX;
						x = relX;
					}
					cell.x = x;
					cell.y = y;
					y += cell.h + self.hubGroupOptions.padY;

					if (cell.size === "all") {
						y = 0;
						relX += cell.w + self.hubGroupOptions.padX;
						x = relX;
					}
				}
			});
		},

		/**
		 * Calc tile positions in vertical scrolling model
		 */
		_calculateLayoutVertical: function() {
			var self = this;
			var centerPadX;
			self.hubGroupOptions.paddingPerTile = 0;
			self.hubGroupOptions.maxGroupHeight = self.hubGroupOptions.maxHeight - self._headerSpace;
			self.hubGroupOptions.padX = self._settings.portraitPadX;
			self.hubGroupOptions.padY = self._settings.portraitPadY;
			self.hubGroupOptions.maxFullTileHeight = self.hubGroupOptions.maxGroupHeight - self.hubGroupOptions.padY;
			if (self.hubGroupOptions.maxWidth >= self._settings.portraitWideMinWidth) {
				// Tablet default, display maximum of 8 tiles in a row in portrait mode
				self.hubGroupOptions.baseSize = Math.floor((self.hubGroupOptions.maxWidth - 7 * self.hubGroupOptions.padX) / 8);
				self.hubGroupOptions.maxGroupWidth = 8 * self.hubGroupOptions.baseSize + 7 * self.hubGroupOptions.padX;
			} else {
				// For smaller devices: display maximum of 4 tiles in a row in portrait mode
				self.hubGroupOptions.baseSize = Math.floor((self.hubGroupOptions.maxWidth - 3 * self.hubGroupOptions.padX) / 4);
				self.hubGroupOptions.maxGroupWidth = 4 * self.hubGroupOptions.baseSize + 3 * self.hubGroupOptions.padX;
			}
			self.hubGroupOptions.maxAllTileHeight = self.hubGroupOptions.maxFullTileHeight;
			self.hubGroupOptions.maxAllTileWidth = Math.floor((self.hubGroupOptions.maxWidth + self.hubGroupOptions.padX) / (self.hubGroupOptions.baseSize + self.hubGroupOptions.padX) / 2) * (self.hubGroupOptions.baseSize + self.hubGroupOptions.padX) * 2 - self.hubGroupOptions.padX;
			centerPadX = (self.hubGroupOptions.maxWidth - self.hubGroupOptions.maxGroupWidth) / 2;
			self.hubGroupOptions.maxGroupWidth += centerPadX;

			self._sizes = {
				small: {
					width: self.hubGroupOptions.baseSize,
					height: self.hubGroupOptions.baseSize,
					paddingX: self.hubGroupOptions.paddingPerTile,
					paddingY: self.hubGroupOptions.paddingPerTile,
				},
				medium: {
					width: self.hubGroupOptions.baseSize * 2 + self.hubGroupOptions.padX,
					height: self.hubGroupOptions.baseSize * 2 + self.hubGroupOptions.padY,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 2,
					paddingY: self.hubGroupOptions.paddingPerTile, // * 2
				},
				wide: {
					width: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padX * 3,
					height: self.hubGroupOptions.baseSize * 2 + self.hubGroupOptions.padY,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 4,
					paddingY: self.hubGroupOptions.paddingPerTile, // * 2
				},
				large: {
					width: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padX * 3,
					height: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padY * 3,
					paddingX: self.hubGroupOptions.paddingPerTile, // * 4,
					paddingY: self.hubGroupOptions.paddingPerTile, // * 4
				},
				full: {
					width: self.hubGroupOptions.baseSize * 4 + self.hubGroupOptions.padX * 3,
					height: self.hubGroupOptions.maxFullTileHeight,
					paddingX: self.hubGroupOptions.paddingPerTile,
					paddingY: self.hubGroupOptions.paddingPerTile
				},
				all: {
					width: self.hubGroupOptions.maxAllTileWidth,
					height: self.hubGroupOptions.maxAllTileHeight,
					paddingX: self.hubGroupOptions.paddingPerTile,
					paddingY: self.hubGroupOptions.paddingPerTile
				}
			};

			var x = centerPadX;
			var y = 0;
			var yInc = 0;
			self.cells.forEach(function(cell) {
				cell.w = self._sizes[cell.size].width;
				cell.h = self._sizes[cell.size].height;

				cell.x = x;
				cell.y = y;

				if (x + cell.w > self.hubGroupOptions.maxGroupWidth) {
					x = centerPadX;
					y += yInc + self.hubGroupOptions.padY;
					cell.x = x;
					cell.y = y;
					yInc = cell.h;
					x += cell.w + self.hubGroupOptions.padX;
				} else {
					x += cell.w + self.hubGroupOptions.padX;
					yInc = cell.h > yInc ? cell.h : yInc;
				}
			});
		},

		getWidth: function() {
			return this._width;
		},
		getHeight: function() {
			return this._height;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/layout/layoutTile',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/layout/layoutBase'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/layout/layoutBase').Klass;

var _Klass = utils.defineClass(function LayoutTile(controller, type, article, opts) {
	var self = this;
	Base.call(self, controller, type, article, opts);
}, Base, {
	buildHtml: function($$parent, controllerDao, buildOptions) {
		var self = this;
		Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions);
		self.$$elmt.addClass("s-m-tile");
		self.$$body = self.$$elmt;
		self._setCellColorClass();
		self.buildChildrenHtml(self.$$body, controllerDao, buildOptions);
	},
	_setCellColorClass: function() {
		var self = this;
		var color = self.article.$bgColor;
		if (!color) {
			color = "darkgrey";
		}
		self.$$elmt.addClass("s-m-bg-" + color);
	},
	/**
	 * Set attribute according to sizeInfo given by layoutHub
	 * Shit (padding top) if there's a title
	 */
	calculateLayout: function(x, y, authSize, sizeInfo) {
		this.$$elmt.css({
			left: x + "px",
			top: y + "px",
			width: sizeInfo.width + "px",
			height: sizeInfo.height + "px",
			position: "absolute",
			"padding-left": sizeInfo.paddingX + "px",
			"padding-right": sizeInfo.paddingX + "px",
			"padding-bottom": sizeInfo.paddingY + "px",
			"padding-top": ((this.$$header ? this.$$header.height() : 0) + sizeInfo.paddingY) + "px"
		});
		this.$$elmt.addClass(authSize);
	},
	getAuthoringSize: function() {
		return (this.article && this.article.$size) || "medium";
	},
	/**
	 * Allows a child to add an action's icon -> Vignette
	 */
	iconActionAdd: function(action, control, icon, enabled) {
		this._ensureHeader();
		this._iconActs = {};
		icon = icon || "";
		var $$icon = $('<icon data-action="' + action + '" data-control-id="' + control.id + '" class="s-m-tile-act ' + icon + '" style="float:right"></span>');
		this._ensureHeader().append($$icon);
		return this.iconActionToggleStatus(action, enabled === true);
	},
	/**
	 * Allows a child to toggle the status of the action's icon
	 */
	iconActionToggleStatus: function(action, enabled) {
		if (!this.$$header) return;
		return this.$$header.find('[data-action="' + action + '"]').toggleClass("s-m-status-enabled", enabled);
	}
});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/layout/layoutCell',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/layout/layoutBase','syracuse-tablet/html/js/ui/uiUtils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/layout/layoutBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');

var _sizes = [{
	$prop: "$widthXs",
	$prefix: "col-xs-"
}, {
	$prop: "$widthSm",
	$prefix: "col-sm-"
}, {
	$prop: "$widthMd",
	$prefix: "col-md-"
}, {
	$prop: "$widthLg",
	$prefix: "col-lg-"
}];

var _Klass = utils.defineClass(function LayoutCell(controller, type, article, opts) {
	var self = this;
	Base.call(self, controller, type, article, opts);
}, Base, {
	/**
	 * Init the properties to allow reuse of this control
	 */
	initReuseProperties: function() {
		Base.prototype.initReuseProperties.call(this);
		this.$$cell = null;
	},
	buildHtml: function($$parent, controllerDao, buildOptions) {
		var self = this;
		Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions);
		self.$$elmt.addClass("s-m-cell");
		self.$$cell = $(uiUtils.createDomElement("div", ["cell"], null, null, self.$$elmt));
		self._setCellColorClass();
		self._setCellSizeClasses();
		self.buildChildrenHtml(self.$$cell, controllerDao, buildOptions);
	},
	_setCellColorClass: function() {
		var self = this;
		var color = self.article.$bgColor;
		if (!color) {
			color = "darkgrey";
		}
		self.$$cell.addClass("s-m-bg-" + color);
	},
	_setCellSizeClasses: function() {
		var self = this;
		var last = 12;
		var match = true;

		_sizes.forEach(function(size) {
			match = match || self.article[size.$prop];
		});

		if (!match) { // no size set, generate default
			self.article = {
				"$widthXs": 12,
				"$widthSm": 6,
				"$widthMd": 4,
				"$widthLg": 3
			};
		}

		_sizes.forEach(function(size) {
			var val = self.article[size.$prop];
			if (val != null && val > 0 && val <= 12) {
				last = val;
			} else {
				val = last;
			}
			var cls = size.$prefix + val;
			self.$$elmt.addClass(cls);
		});
	}

});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/vignetteBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/application/pageLoader','syracuse-tablet/html/js/application/pageRegistry','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/controls/ctrlFactory'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var PageLoader = require('syracuse-tablet/html/js/application/pageLoader').Klass;
var pageRegistry = require('syracuse-tablet/html/js/application/pageRegistry');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("app");
var locale = require('syracuse-tablet/html/js/helpers/locale');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');


var _waitConfig = {
	className: 'waiting-blocks',
	elements: 5,
	auto: true,
	speed: 200
};
var _templates = {
	main: '\
		<section/>\
		<footer style="display:none"/> \
		<div class="s-m-waiting bckg" style="display:none"/> \
		<div class="s-m-waiting wheel" style="display:none"/> \
	',
	iframe: '\
		<br><iframe src="{{url}}" style="position: absolute; top: 0px; left: 0px; height: 100vh; width: 100vh;"/>\
	',
	navbtns: '\
		<a draggable="false" href="#" data-action="vignetteBack" class="' + fontUtils.vignetteIcons("back") + '" style="display:none"></a>\
		<a draggable="false" href="#" data-action="vignetteHome" class="' + fontUtils.vignetteIcons("home") + '" style="display:none"></a>\
	',
	vignetteError: '\
		<a draggable="false" href="#" data-action="vignetteError">{{text}}</a>\
	',
	linkPage: '\
		<a draggable="false" href="{{href}}"\
			data-nav-target="application"\
			data-nav="{{data-nav}}"\
			{{#if data-link-article}} data-link-article="{{data-link-article}}"{{/if}}\
			data-gadget-id="{{data-gadget-id}}"\
			data-application-name="{{data-application-name}}"\
			data-sdata-parameters="{{data-sdata-parameters}}"\
			class="s-m-link-page">\
				{{#if icon}}\
					<section class="s-m-icon">\
						<div>\
							<div class="{{icon}}"></div>\
						</div>\
					</section>\
				{{/if}}\
				<section class="s-m-title">\
					<div>{{title}}</div>\
				</section>\
		</a>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};


var _Klass = utils.defineClass(

	function VignetteBase(controller, article, prototype, opts) {
		var self = this;
		article.$article = article.$article || {};
		Base.call(self, controller, article, prototype, opts);
		self._currentPage = null;
		self._pageLoader = null;
		self._$$wait = null;
		self._stateStack = [];
		self._error = null;
		self.displayStyle = prototype.data("$displayStyle");
		self.openLinkInVignette = globals.$config("openLinkInVignette");
		notifications.subscribe(this, ["sm.vignette.pinned"]);
	}, Base, {
		destroy: function() {
			this._error = null;
			// destroy all pages attached to the vignette
			this.clearContent();
			if (this._$$wait) {
				uiUtils.waitPluginDestroy(this._$$wait);
			}
			if (this._pageLoader) {
				this._pageLoader.destroy();
				this._pageLoader = null;
			}
			if (this._savedPageControl) {
				this._savedPageControl.destroy();
				this._savedPageControl = null;
			}
			if (this._actionControl) {
				this._actionControl.destroy();
				this._actionControl = null;
			}
			this._$$actionIcon = null;
			Base.prototype.destroy.call(this);
		},
		/**
		 * If vignette contains a page return the control object identified by id
		 */
		getPageControl: function(ctrlId) {
			return this._currentPage && this._currentPage.getControl && this._currentPage.getControl(ctrlId);
		},
		getPageLayout: function(id) {
			return this._currentPage && this._currentPage.getLayout && this._currentPage.getLayout(id);
		},
		getPageStructElmt: function(id) {
			return this.getPageControl(id) || this.getPageLayout(id);
		},
		getPage: function() {
			return this._currentPage;
		},
		onMainPageResize: function(info, orientation, deviceClass) {
			if (this._currentPage == null || this._currentPage.state.options.$displayStyle !== "$full") return;
			this._currentPage.onMainPageResize(info, orientation, deviceClass);
		},
		/**
		 * Change current page - called from eventListener
		 * 	data-nav action has been clicked in a vignette's link
		 * 	we could have a parameter that indicates if the link has to be opened full page or inside the vignette
		 */
		changePage: function(state, options) {
			options = options || {};
			// Propagate openLinkInVignette to child page - used to open reflinks...
			options.openLinkInVignette = this._openLinkInsideVignette();
			// Always full page
			options.$displayStyle = "$full";
			this._loadPage(state, options);
		},
		/**
		 * Refresh current page - called from eventListener
		 */
		refreshPage: function(options) {
			var self = this;
			if (!self._currentPage) throw new Error("No current page");
			if (self._error) this._removeError();
			self._currentPage.refresh(options, {
				waitStart: function(controlId) {
					// Wait managed by vignette
					self.waitStart();
				},
				waitStop: function(controlId) {
					self.waitStop();
				}
			}).then(function() {
				//	Eventually do something in vignette control	
			}).fail(function(e) {
				modal.error(locale.text("err.load.main"), e);
			});
		},
		hasBtnsBar: function() {
			return this._openLinkInsideVignette();
		},
		clearContent: function() {
			if (this._$$content) {
				globals.getApplication().removeAllChildPages(this._$$content);
				this._$$content.empty();
			}
			// _currentPage has been destroyed by removeAllPages
			if (this._currentPage) this._currentPage = null;
			this._stateStack = [];
		},
		_openLinkInsideVignette: function(state) {
			if (this.openLinkInVignette === true) return true;
			var name;
			if (state == null) {
				name = this._currentPage ? this._currentPage.state.name : null;
			} else if ($.isPlainObject(state)) {
				name = state.name;
			} else {
				name = state;
			}
			if (typeof name === "string" && (name === "rowdetail" || name === "carddesign" || name.smEndsWith("$lookup"))) this.openLinkInVignette = true;
			if (this._currentPage && this._currentPage.isChild) this.openLinkInVignette = true;;
			return this.openLinkInVignette;
		},
		/**
		 * Load a page
		 * 	state
		 * 				state of the  page - stored in page object
		 * 	pageOptions
		 * 				options of the  page - stored in page object
		 * 	action: 	back for a back in vignette actions
		 * 				home for a home in vignette actions
		 * 	loadOptions
		 * 				updateLayout...
		 */
		_loadPage: function(state, pageOptions, action, loadOptions) {
			var self = this;
			self._error = null;
			if (!self._openLinkInsideVignette(state) && self._stateStack.length > 0) {
				// Clear content only that case. Otherwise we have to store cached paged inside the vignette
				self.clearContent();
			}
			if (!self._pageLoader) {
				self._initPageLoader();
			}
			return $.smResolve().then(function() {
				var pageInfo;
				var articleCopy;
				if (typeof state === "string") {
					pageOptions = pageOptions || {};
					pageOptions.vignette = true;
					articleCopy = pageOptions.vignetteArticle; // Backup of original article, this MUST NOT be cloned
					return pageRegistry.getPageInfo(state, pageOptions, self._currentPage)
						.then(function(pageInfo) {
							if (articleCopy && pageInfo.options) {
								pageInfo.options.vignetteArticle = articleCopy;
							}
							return pageInfo;
						});
				} else if (action === "back" || action === "home") {
					return state;
				} else {
					throw new Error("Unexpected object state");
				}
			}).then(function(pageInfo) {
				if (pageInfo.options && pageInfo.options.$displayStyle === "$full") {
					// action "home" is not a back. It's like an open page because we want to store the state in history
					return self._pageLoader.load(pageInfo, action === "back", loadOptions);
				} else if (pageOptions.gadget) {
					var icon = self._getCssIcon(pageOptions.gadget, "s-m-sage-gadget-icon");
					var attrs = {
						"data-nav": pageInfo.name,
						"data-gadget-id": pageOptions.gadget.data("$uuid"),
						"data-application-name": pageOptions.gadget.data("applicationName"),
						"title": self.article && self.article.$article && self.article.$article.$title ? self.article.$article.$title : pageOptions.gadget.data("$title"),
						"icon": icon
					};
					if (pageInfo.options.$displayStyle === "$link" && self.article && self.article.$linkArticle) {
						// Used by test entities to pass an article to the page
						attrs["data-link-article"] = self.id;
					}
					self._addPicker(attrs);
					return $.smResolve();
				} else {
					throw new Error("Unexpected vignette page");
				}
			})
				.fail(function(e) {
					self._displayError("Loading page error", e);
				});
		},

		_initPageLoader: function() {
			var self = this;
			/**
			 * Page loader shared with application
			 * Load a page
			 */
			self._pageLoader = new PageLoader({
				waitStop: function() {
					self.waitStop();
				},
				waitStart: function() {
					self.waitStart();
				},
				getRootElmt: function() {
					return self._$$content;
				},
				getCurrentPage: function() {
					return self._currentPage;
				},
				setCurrentPage: function(page) {
					self._currentPage = page;
					self._currentPage.setParentVignette(self);
				},
				historyPush: function(state) {
					// Add state in stack in all case - We need it for link to row Detail
					self._stateStack.push(state);
				},
				succeeded: function(dstPage, pageToClose, parentNotifInfo, back, loadOptions) {
					if (!self.controller) return; //Vignette destroyed before end of load process
					if (self.hasBtnsBar()) {
						self.refreshBtnsBar();
					}
					if (parentNotifInfo && parentNotifInfo.notifId) {
						/**
						 * _notifyController  to notify only the page
						 */
						if (dstPage.id === parentNotifInfo.parentId) {
							notifications.notifyController(parentNotifInfo.notifId, self._currentPage, parentNotifInfo.notifData, parentNotifInfo.controlId);
						} else {
							modal.error("Child page notification warning", "Parent page is not the current page");
						}
					}
					// page has been loaded - Used to prevent multiple onresize calls to current page
					log && log("vignette loaded" + self.id);
					// Call resize handler each time a page has been loaded for calculations
					if (dstPage.state.options.$displayStyle === "$full") {
						/* setTimeout to resize dstPage after current process - #5737*/
						self._initActionDashboard(dstPage);
						setTimeout(function() {
							dstPage.onMainPageResize({
								updateLayout: back === true || (loadOptions && loadOptions.updateLayout)
							});
						});
					}
				},
				loadingError: function(deferred, state, e) {
					self._displayError(locale.text("error.page.loading"), e);

					// No reject
					deferred.resolve(null, e);
				},
				/**
				 * Specific interface method for vignettes
				 * Returns the context of a page nested in a vignette and also context of the vignette (selection)
				 * Called by the pageLoader after the vignette has been displayed
				 */
				savedCtxVignette: function() {
					// It's the dashboard that manage the storage
					if (!self.controller) {
						//Page has been destroyed before calling this method
						// If we have multiple vignettes and we click a link before all vignettes has been displayed we get this case
						return;
					}
					return self.controller.savedCtxVignette(self);
				}
			});
		},
		/**
		 * If multiselection is enabled for the page we enable the switch of footer
		 * An icon in tile's title allows the user to swicth the current footer by the one of the nested page (dstPage)
		 */
		_initActionDashboard: function(dstPage) {
			try {
				// TODO Check authoring
				var tile = this.getParentTile();
				if (!tile) return;
				if (!dstPage || !dstPage.isMultiSelectionEnabled()) return;
				if (this._$$actionIcon) {
					this._$$actionIcon = tile.toggleActionIcon("togglePinVignette");
					return;
				}
				var typeControl = globals.getSiteLayout().getDeviceType() == "smartphone" ? "header" : "footer";
				if (!this._actionControl) {
					this._actionControl = ctrlFactory.createActionControl(typeControl, this);
				}
				this._$$actionIcon = tile.iconActionAdd("togglePinVignette", this, fontUtils.getPinVignetteIcon("off"));
				this._isPinned = false;
			} catch (e) {
				this._displayError("Pin vignette init error", e.stack);
			}
		},
		/**
		 * Click on icon in tile's header
		 */
		_actTogglePinVignette: function() {
			//!! notifications is synchrounous - We must disable the current enabled tile (if any) before enabling this.getParentTile
			notifications.publish("synch.sm.vignette.pinned", this.id);
			// Toggles current vignettes status
			this._doTogglePinVignette(this.id);
		},
		/**
		 * Toggle the status of vignettes other than the vignette that has publihed the notification
		 */
		notifVignettePinned: function(id) {
			if (this.id == id) return;
			this._doTogglePinVignette(id);
		},
		/**
		 * Toggle icon status and switchs the footer
		 */
		_doTogglePinVignette: function(id) {
			try {
				if (!this._actionControl || (id != this.id && !this._isPinned)) return;
				var tile = this.getParentTile();
				if (!tile) return;
				this._isPinned = id != this.id ? false : !this._isPinned;
				tile.iconActionToggleStatus("togglePinVignette", this._isPinned);
				tile.$$elmt.toggleClass("s-m-enabled", this._isPinned);
				var typeControl = globals.getSiteLayout().getDeviceType() === "smartphone" ? "header" : "footer";
				this._savedPageControl = this.controller.toggleHeaderFooter(typeControl, this._isPinned ? this._actionControl : this._savedPageControl);
				this._$$actionIcon.removeClass(fontUtils.getPinVignetteIcon("all")).addClass(fontUtils.getPinVignetteIcon(this._isPinned ? "on" : "off"));
			} catch (e) {
				this._displayError("Pin vignette error", e.stack);
			}
		},

		_loadRepresentation: function(gadget, name, pageOptions, loadOptions) {
			var self = this;
			var name = name || gadget.getPageName();
			pageOptions = $.extend({}, pageOptions);
			pageOptions.openLinkInVignette = self._openLinkInsideVignette(name);
			pageOptions.$displayStyle = self.displayStyle;
			pageOptions.gadget = gadget;
			pageOptions.vignetteArticle = self.article.$article; // sub article in case the layout of a vignette is defined in the dashboard layout
			return self._loadPage(name, pageOptions, null, loadOptions);
		},

		_displayError: function(msg, detail) {
			var self = this;
			self._error = {
				message: msg,
				detail: detail
			};
			if (self.$$elmt) {
				self._$$content.hide();
				self.$$elmt.addClass("s-m-error");
				self.$$elmt.prepend(_getHtml("vignetteError", {
					text: "Loading failed"
				}));
				self.refreshBtnsBar();
			} else {
				alert(msg + "\n\n" + detail);
			}
		},

		_removeError: function() {
			this.$$elmt.children('a[data-action="vignetteError"]').remove();
			this.$$elmt.removeClass("s-m-error");
			this._$$content.show();
			this._error = null;
		},

		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			if (self._stateStack.length > 0) {
				// There could be cached pages

			} else {
				Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions, ["s-m-vignette"]);
				self.$$elmt.html(_getHtml("main", {}));
				self._$$content = self.$$elmt.children("section");
				self.$$footer = self.$$elmt.children("footer");
				self._$$waitBckg = self.$$elmt.children(".s-m-waiting.bckg");
			}
		},

		/**
		 * First load of the page
		 */
		load: function(name, pageOptions, loadOptions) {
			var self = this;
			pageOptions = pageOptions || {};

			var deferred = $.Deferred();

			var _finalize = function(page, error) {
				deferred.resolve(page, error);
			};
			var _fail = function(e) {
				self._displayError(e);
				// Deferred is not rejected because error is displayed in the vignette
				_finalize();
			};
			try {
				var gadget = self.prototype.getVignetteGadget();
				if (gadget && gadget.isValid()) {
					if (pageOptions.resize === true) {
						// Always clear content if resize to rebuild a new one
						this.clearContent();
					}
					switch (gadget.data("$type")) {
						case "$representation":
						case "$stats":
						case "$request":
							self._loadRepresentation(gadget, name, pageOptions, loadOptions)
								.then(function(page, error) {
									_finalize(page, error);
								})
								.fail(function(e) {
									_fail(e);
								});
							break;
						case "$dashboard":
							self._loadDashboard(gadget);
							_finalize();
							break;
						case "$application":
							self._loadApplication(gadget);
							_finalize();
							break;
						case "$external":
							self._loadExternal(gadget);
							_finalize();
							break;
						case "$gadgetMissing":
							self._displayError("Referenced gadget does not exist: " + gadget.data("$uuid"));
							_finalize();
							break;
						default:
							self._displayError("Unsupported gadget type: " + gadget.data("$type"));
							_finalize();
							break;
					}
				} else {
					self._displayError("Invalid gadget" + (gadget ? " [" + gadget.getInvalidReason() + "]" : ""), gadget ? gadget.getJSON() : "Null gadget");
					_finalize();
				}
			} catch (e) {
				_fail(e);
			} finally {
				return deferred.promise();
			}
		},

		_getCssIcon: function(gadget, sageBaseCss) {
			var icon = gadget.data("icon") || this.article && this.article.$icon;
			if (icon) {
				if (icon.smStartsWith("sage")) {
					// our own gadget icons
					icon = sageBaseCss + " " + icon;
				} else {
					// FontAwesome
					icon = fontUtils.getIconByName(icon);
				}
			}
			return icon || "";
		},

		_loadDashboard: function(gadget) {
			this._addPicker({
				"data-nav": globals.getMetaData().getDashboardPageName(gadget.data("dashboardName")),
				"data-application-name": gadget.data("applicationName"),
				"data-gadget-id": gadget.data("$uuid"),
				"data-sdata-parameters": gadget.data("sdataParameters"),
				"title": gadget.data("$title"),
				"icon": this._getCssIcon(gadget, "dash")
			});
		},

		_loadApplication: function(gadget) {
			this._addPicker({
				"data-application-name": gadget.data("applicationName"),
				"title": gadget.data("$title"),
				"icon": this._getCssIcon(gadget, "s-m-sage-app-icon"),
			});
		},

		_loadExternal: function(gadget) {
			var self = this,
				url = gadget.data("externalUrl");
			self._addPicker({
				"href": url,
				"title": gadget.data("$title")
			});
			if (self.displayStyle !== "$link") {
				var iFrame = _getHtml("iframe", {
					url: url
				});
				$(iFrame).appendTo(self._$$content);
			}
		},

		_addPicker: function(context) {
			if (!context.href) context.href = "#";
			$(_getHtml("linkPage", context)).appendTo(this._$$content);
		},

		waitStart: function() {
			var self = this;
			if (!self._$$wait) {
				self._$$wait = uiUtils.waitPluginCreate(self.$$elmt.children(".s-m-waiting.wheel"), _waitConfig);
			}
			uiUtils.waitPluginEnable(this._$$wait);
			this._$$waitBckg.show();
		},
		waitStop: function() {
			var self = this;
			if (self._$$wait) {
				uiUtils.waitPluginDisable(this._$$wait);
			}
			this._$$waitBckg.hide();
		},

		refreshBtnsBar: function() {
			var self = this;
			if (self._openLinkInsideVignette()) {
				var show = false;
				if (!self.$$icnBack) {
					self.$$footer.prepend(_getHtml("navbtns"));
					self.$$icnBack = self.$$footer.children("[data-action=vignetteBack]");
					self.$$icnHome = self.$$footer.children("[data-action=vignetteHome]");
				}
				var l = self._stateStack.length;
				self.$$icnBack.toggle(l > 1);
				self.$$icnHome.toggle(l > 2);
				show = self._stateStack.length > 1;
				self.$$footer.toggle(show);
				self.$$elmt.toggleClass("footer", show);
			}
		},

		_actVignetteHome: function() {
			var self = this;
			if (self._stateStack.length == 0) return;
			var state = self._stateStack[0];
			self._stateStack = []; // to force clearContent
			self._loadPage(state, null, "home");
		},

		_actVignetteBack: function() {
			var self = this;
			if (self._stateStack.length <= 1) return;
			self._stateStack.pop();
			// !!! true for BACK in order to unstack the current page
			self._loadPage(self._stateStack[self._stateStack.length - 1], null, "back");
		},
		_actVignetteError: function() {
			var self = this;
			if (self._error.detail) {
				modal.error(self._error.message, self._error.detail);
			} else {
				modal.error("Vignette load error", self._error);
			}
		},
		_actVignetteRefresh: function() {
			this.refreshPage({});
		},
		isOverflow: function() {
			if (!this._currentPage) return;
			return (this._currentPage.$$elmt.height() - this.$$elmt.height()) > 0;

		},
		getScrollViewRect: function() {
			return uiRect.elmtRect(this._$$content, "inner");
		},
		isVignette: function() {
			return true;
		},
		// Only for test entities - We can attache an article to a $link vignette
		getLinkedPageArticle: function() {
			return this.article ? this.article.$linkArticle : null;
		},
		getParentTile: function() {
			var p = this.parent;
			while (p && p != this.controller && !jsutils.isInstanceOf(p, "LayoutTile")) {
				p = p.parent;
			}
			return p && p != this.controller ? p : null;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/ctrlBreadCrumbs',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/helpers/uiSettings','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var globals = require('syracuse-tablet/html/js/helpers/globals');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var prototype = require('syracuse-tablet/html/js/helpers/prototype');
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var _templates = {
	items: '\
		<div class="s-m-breadcrumbs-items">\
		{{#each items}}{{{html}}}{{/each}}\
		</ul>\
		',
	item: '<a href="#" data-action="breadcrumb-click" data-control-id="{{ctrlId}}" data-params="{{data}}"><div class="s-m-breadcrumbs-item"><div class="s-m-breadcrumbs-text">{{text}}</div>{{#if notLast}}<div class="fa fa-caret-right s-m-icon-small"></div>{{/if}}</div></a>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};

var _Klass = utils.defineClass(
	function CtrlBreadCrumbs($type, controller, options) {
		Base.call(this, controller, {
			$bind: "breadcrumbs"
		}, prototype.create({
			$type: $type
		}), options);

		notifications.subscribe(this, ["sm.history.pop", "sm.history.push"]);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			this._pageStates = [];
		},

		buildHtml: function($$parent, controllerDao, buildOptions) {
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions, [this.typeName]);
		},
		onMainPageResize: function(info, orientation) {
			var deviceType = globals.getSiteLayout().getDeviceType();
			if (deviceType === "tablet") {
				this.$$elmt.css({
					height: uiSettings.getProp("breadcrumbs.height")
				});
			} else {
				// In the first step, breadcrumbs are not shown on smartphone
				this.$$elmt.css({
					height: 0
				});
			}
		},
		afterRender: function(updateLayout, buildOpts) {},
		applyMetaData: function(metaData) {
			//  No meta for this control 
			return;
		},

		_actFooterLink: function(uuid) {
			this._actionManager.triggerLink(uuid, this.controller).then(function(success, link, data, options) {
				// Message is displayed 
			}).fail(function(e) {
				if (jsutils.isError(e)) {
					// We shouldn't expect an error except exceptions
					globals.getModal().error("Footer action error", e);
				}
			});
		},
		getHeight: function() {
			return this.$$elmt && this.$$elmt.is(":visible") ? this.$$elmt.height() : 0;
		},
		notifHistoryPush: function(history) {
			this._buildBreadcrumbs(history);
		},
		notifHistoryPop: function(history) {
			this._buildBreadcrumbs(history);
		},
		_buildBreadcrumbs: function(history) {
			var self = this;
			var items = this._getItems(history);
			var crumbs = [];
			self._pageStates = [];
			$.each(items, function(idx, state) {
				var uuid = utils.UUID();
				self._pageStates[uuid] = $.extend(true, {}, state, {
					stackNum: idx
				});
				crumbs.push({
					html: _getHtml("item", {
						text: state.$title,
						notLast: (idx + 1 < items.length),
						ctrlId: self.id,
						data: uuid
					})
				});
			});
			var html = _getHtml("items", {
				items: crumbs
			});
			this.$$elmt.empty();
			this.$$elmt.append(html);
		},
		_getItems: function(history) {
			history = history || [];
			history = history.slice(0);
			history = history.reverse(); // Latest is first
			var stackToHome = [];

			// Filter history to only show stack until we reach welcome page for the first time to keep it as small as possible
			history.some(function(state) {
				stackToHome.push(state);
				if (state.isWelcomePage) {
					return true;
				}
				return false;
			});
			return stackToHome;
		},
		_actBreadcrumbClick: function(uuid) {
			var self = this;
			var state = self._pageStates[uuid];
			if (!state) return;
			var num = state.stackNum;
			if (num <= 0) return; // Click on current page, no need to do an action
			globals.getApplication().goBack(function PageFilter(histState) {
				if (num === 0) {
					return true;
				}
				num--;
			});
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/application/actionManager',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/sdata/sdataDispatcher','syracuse-tablet/html/js/sdata/sdataUtils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var dispatcher = require('syracuse-tablet/html/js/sdata/sdataDispatcher');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

/**
 * Set pageOpts with auto scroll value to preserve scrolling when we go from detail -> edit
 * We do the same for cancelEdit action in pageRegular when we go from edit -> detail
 */
var _preserveScrolling = function(page, link, pageOpts) {
	if (!page || !link || !pageOpts) return;
	var val = page.getScrollValue();
	// Auto-scroll - If we edit a page we keep the scrolling
	if (!isNaN(val) && val !== 0) {
		// 1.2 because the height of the page is higher in edit mode 
		// To improve or disable but to me it's great to keep the scrolling when we edit a page
		pageOpts["auto-scroll"] = page.getScrollValue() * 1.2;
	}
};
/**
 * Default message display
 * TODO - Message + detail
 */
var _displayMessage = function(title, data, cb) {
	if (data === null) data = "";
	if (jsutils.isError(data)) {
		data = data.message;
	} else if (typeof data === "string") {
		// Nothing
	} else {
		var diags = sdataUtils.scanDiagnoses(data);
		if (diags.length > 0) {
			var msg = [];
			diags.forEach(function(d) {
				msg.push(d.$message);
			});
			data = msg.join('\n');
		} else {
			data = JSON.stringify(data, null, 2);
		}
	};
	globals.getModal().info(title, data, cb);
};
/**
 * Manage action on links given by prototype
 * Used by footer/header/navigation panel
 */
var _Klass = utils.defineClass(

	function(controller, toolbar, options) {
		this.options = options || {};
		this.toolbar = toolbar;
		this.controller = controller;
		this._initLinks();
	}, null, {

		destroy: function() {
			this.options = null;
			this.controller = null;
		},
		/**
		 * To update links if by example deviceType changed
		 */
		_initLinks: function() {
			var self = this;
			var deviceType = globals.getSiteLayout().getDeviceType();
			var beginLinks = [];
			if (self.options.addMultiSelection && !self.controller.isEditMode()) {
				beginLinks.push(self.getMultiSelectionLink());
			}
			// multiSelectionOnly = true - Only multi-selection is enabled - Used by vignettes
			// In taht case it's not necessary to set addMultiSelection = true
			if (self.options.multiSelectionOnly != true) {
				var toolBarLinks = self.controller.getToolbarLinks(self.toolbar) || [];
				var endLinks = [];
				if (self.options.addCancelEditAction && self.controller.isEditMode()) {
					endLinks.push(self.getCancelEditAction(self.options.addCancelEditAction));
				}
			}
			self.links = jsutils.concatArrays(beginLinks, toolBarLinks, endLinks);
		},
		/**
		 * Add action to links
		 */
		getCancelEditAction: function(actionName) {
			return {
				name: "$canceledit",
				icon: fontUtils.getIconByName("$cancelEdit"),
				isClientAction: true,
				action: actionName || "cancelEdit",
				title: locale.text("action.cancelEdit"),
				$uuid: utils.UUID()
			};
		},
		getMultiSelectionLink: function() {
			return {
				name: "$multiSelection",
				icon: fontUtils.getIconByName("$multiSelection"),
				isClientAction: true,
				action: globals.ACTMULTISEL,
				css: ["s-m-ismultisel"],
				title: locale.text("action.multiselect"),
				$uuid: utils.UUID()
			};
		},
		getLinks: function() {
			return this.links;
		},
		hasLinks: function() {
			return this.links && this.links.length > 0;
		},
		/**
		 *  Triggers a link action/navigation and resolve/reject
		 *  		displayed eventually a message if diagnoses have been returned by server
		 *  uuid
		 *  		Id of the link which has been stored in the html (data-params)
		 *  page: optional - page that will be notified with data returned by action
		 *  	  mandatory for cancelEdit action
		 * 	options
		 * 		For a navigation link
		 * 			If options.noRedirection == true resolve with the following data
		 * 				{
		 * 					gotoPage:{
		 * 						name:"PageName",
		 * 						options{Pages options}
		 * 					}
		 * 				}
		 * 				It's the caller that calls application.changepage
		 * 			Else it does redirection to the target page
		 */
		triggerLink: function(uuid, page) {
			var deferred = $.Deferred();
			try {
				var self = this;
				// reads link info
				var link = null;
				self.getLinks().some(function(l) {
					if (l.$uuid === uuid) {
						link = l;
						return true;
					}
				});
				if (!link) return;
				// ACTION WITH CONFIRMATION
				if (link.$confirm) {
					// Action with confirmation asked by server
					globals.getModal().simpleConfirm(link.$confirm, function(confirmed) {
						if (confirmed) {
							self._execLink(deferred, page, link);
						}
					});
					return;
				} else {
					self._execLink(deferred, page, link);
				}

			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},
		_execLink: function(deferred, page, link) {
			var self = this;
			// CLIENT ACTION - NON SDATA ACTION
			if (link.isClientAction) {
				if (!page) throw new Error("triggerLink - Page is expected");
				self._notifyAndResolve(page, deferred, true, link);
				return;
			}
			/**
			 * $isAction comes from prototype (true for save, delete...)
			 * If url contains $services $isAction is set to true (see prototype.getLinks)
			 * 		$services urls are considered as actions
			 * !! No url and $isAction means child page action
			 */
			// ACTION - #6195 we consider DELETE to be an action because we stay on the same page
			if (link.$isAction || link.$method === "DELETE") {
				// Action which stays on the same page
				self._doLinkAction(deferred, page, link);
				return;
			}
			// NAVIGATION
			if (link.page) {
				// Navigation to a page
				var pageOpts = {
					"sdata-url": link.sDataUrl,
					"sdata-method": link.$method,
					"sdata-parameter": link.parameters
				};
				if (page) {
					// Auto-scroll - If we edit a page we keep the scrolling
					if (page.state.name.replace(".$details", ".$edit") === link.page) {
						_preserveScrolling(page, link, pageOpts);
					}
				};
				if (self.options.noRedirection === true) {
					// Caller wants to manage redirection
					self._notifyAndResolve(page, deferred, true, link, {
						gotoPage: {
							name: link.page,
							options: pageOpts
						}
					}, self.options);
				} else {
					// callerhandlesErrors: we don't want the caller to redirect to homepage if there's an error
					// -> We stay on the current page
					var opts = {
						callerhandlesErrors: true
					};
					globals.getApplication().changePage(link.page, pageOpts, opts).then(function() {
						// Page is changed so it's not necessary
						deferred.resolve();
					}).fail(function(e) {
						// Display error message and stays on current page
						if (e) {
							if (e.responseJSON && e.responseJSON.$diagnoses) {
								e = {
									$diagnoses: e.responseJSON.$diagnoses
								};
							} else {
								var msg = "";
								if (e.status != null) {
									msg += "httpStatus=" + e.status;
								}
								if (e.message != null) {
									msg += " - " + e.message;
								}
								e = {
									$diagnoses: [{
										$severity: "error",
										$message: msg
									}]
								};
							}
						}
						globals.getModal().actionResult(locale.text("error.page.loading"), e);
						deferred.resolve();
					});
				}
				return;
			} else if (link.externalUrl) {
				var url = utils.parseExpression(link.externalUrl, page.dao, page.prototype);
				window.open(url);
				return;
			}
			// Unexpected case
			_displayMessage("Unexpected link type", link, function() {
				self._notifyAndResolve(page, deferred, false, link, null, self.options);
			});
		},

		/**
		 * Send an action to server and process result
		 * Resolve/reject deferred
		 */
		_doLinkAction: function(deferred, page, link) {
			var self = this;
			var _end = function(success, data) {
				self._notifyAndResolve(page, deferred, success, link, data);
			};
			try {
				// Validate the data before processing - Synchronous call
				if (page && page.validateBeforeActionLink && page.validateBeforeActionLink(link) === false) {
					// Just resolve - No notification because action has not been sent
					deferred.resolve(false);
					return;
				}
				if (link.sDataUrl) {
					if (page) page.waitWheelStart();
					var payload = page ? page.dao.getActionPayload(link) : null;
					dispatcher.dispatch({
						$url: link.sDataUrl,
						$method: link.$method || "GET"
					}, payload).then(function(data) {
						if (page) page.waitWheelStop();
						// True for success
						_end(true, data);
					}).fail(function(e) {
						if (page) page.waitWheelStop();
						if (!jsutils.isError(e) && $.isPlainObject(e)) {
							// false for fail
							_end(false, e);
						} else {
							// Exception - we display the message
							_displayMessage("Action '" + link.title + "' failed", e, function() {
								deferred.reject(e);
							});
						}
					});
				} else {
					// Child page action - True for success - no data
					_end(true);
				}
			} catch (e) {
				_displayMessage("Action '" + link.title + "' javascript exception", e, function() {
					deferred.reject(e);
				});
			}
		},
		/**
		 * Notify (the page controller) to do some stuff after an action succeeded
		 * Save/Delete...
		 */
		_notifyAndResolve: function(page, deferred, success, link, result) {
			if (page) {
				notifications.notifyController("sm.action.link", page, success, link, result, this.options);
			}
			if (deferred) {
				deferred.resolve(success, link, result, this.options);
			}
		}
	});

exports.Klass = _Klass;

/**
 * toolbar	header, footer, actionpanel...
 * opts
 * 			addCancelEditAction
 * 				Name aof action to trigger (headerAction; footerAction...)
 * 				Link is not added if null
 * 			noMessage
 */
exports.create = function(controller, toolbar, opts) {
	return new _Klass(controller, toolbar, opts || {});
};
});

define('syracuse-tablet/html/js/sdata/sdataSyncUtils',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/prototype'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var prototypeModule = require('syracuse-tablet/html/js/helpers/prototype');

var _syncMaxLevels = 6;

exports.getSyncStructure = function(prototype) {
	var node = {
		$title: prototype.data("$title")
	};
	var urlList = [];
	return _resolvePrototype({
		prototype: prototype,
		level: 1,
		maxLevels: _syncMaxLevels
	}, node, urlList);
};

function _resolvePrototype(opts, node, urlList) {
	node.uuid = utils.UUID();
	node.$children = [];
	if (opts.level >= opts.maxLevels) {
		return $.smResolve(node);
	}

	var $links;

	// For query facet, only take $details link into account
	if (opts.prototype.getFacet() === "query") {
		var $resources = opts.prototype.property("$resources");
		if ($resources && $resources.$item && $resources.$item.$links && $resources.$item.$links.$details) {
			$links = {
				$details: $resources.$item.$links.$details
			};
		}
	} else if (opts.prototype.getFacet() === "details") {
		$links = opts.prototype.data("$links");
	} else {
		// Only $details and $query facets allowed, we should never end up here, just for safety
		return $.smResolve(node);
	}

	return $.smForEachPromise(Object.keys($links), function(name) {
		var link = $links[name];
		if (_isCacheableLink(link, name, urlList)) {
			//var url = sdataUtils.parseSDataURL(link.$url);
			var repr = _getRepresentation(link);
			if (repr) {
				urlList.push(link.$url);

				var child = {
					$name: name,
					$title: utils.parseExpression(link.$title, null, opts.prototype, true),
					$link: link,
					$representation: repr
				};
				node.$children.push(child);
				return _processNode(child, opts, urlList);
			}
		}
		return $.smResolve(node);
	})
		.then(function() {
			return node;
		});
}

function _isCacheableLink(link, name, urlList) {
	if (urlList.indexOf(link.$url) > -1) {
		return false;
	}
	if (name.indexOf("$") === 0 && name !== "$details") {
		return false;
	}
	if (link.$method !== "GET") {
		return false;
	}
	if (link.$url.indexOf("/$services/") > -1) {
		return false;
	}
	if (link.$url.indexOf("representation=") < 0) {
		return false;
	}
	var repr = _getRepresentation(link);
	if (!repr || repr.indexOf(".$details") < 0 && repr.indexOf(".$query") < 0) {
		return false;
	}
	return true;
}

function _getRepresentation(link) {
	var repr = /[\?\&]representation=(\S+?)(&|$)/.exec(link.$url);
	return repr && repr[1];
}

function _processNode(node, opts, urlList) {
	var meta = globals.getMetaData();
	var protoName = _getProtoName(node, opts);
	return meta.getPrototype(protoName)
		.then(function(proto) {
			if (proto) {
				proto = prototypeModule.create(proto);
				node.$prototype = proto;
				if (node.$name === "$details") {
					node.$title = proto.data("$title");
					node.$isDetails = true;
				}

				return _resolvePrototype({
					prototype: proto,
					level: opts.level + 1,
					maxLevels: opts.maxLevels
				}, node, urlList);
			}
		});
}

function _getProtoName(node, opts) {
	var endpoint = opts.prototype.data("$baseUrl");
	endpoint = endpoint.split("/");
	endpoint = endpoint.slice(endpoint.length - 3, endpoint.length).join(".");
	return endpoint + "." + node.$representation;
}
});

define('syracuse-tablet/html/js/ui/modals/modalSyncOffline',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalDialog','syracuse-tablet/html/js/sdata/sdataDispatcher','syracuse-tablet/html/js/sdata/sdataSyncUtils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var sdataDispatcher = require('syracuse-tablet/html/js/sdata/sdataDispatcher');
var sdataSyncUtils = require('syracuse-tablet/html/js/sdata/sdataSyncUtils');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
			<div class="s-m-scroll-element"> \
				<div class="form-group"> \
					<center> \
						<button type="button" class="btn btn-default s-m-modal-btn-sync" data-action="modal-sync">{{label_sync}}</button> \
						<button type="button" class="btn btn-default s-m-modal-btn-sync-stop hidden" data-action="modal-sync-stop">{{label_sync_stop}}<div class="s-m-sync-total"><span class="label label-success ok"></span><span class="label label-danger error"></span></div></button> \
					</center> \
				</div> \
				<div class="form-group"> \
					<label>{{label_tree}}</label> \
					<div id="s-m-sync-tree-id"></div> \
				</div> \
			</div> \
			</div>',
	footer: ''
};

var _Klass = utils.defineClass(
	function ModalSyncOffline(syncRootData) {
		var self = this;
		modalDialog.ModalBase.call(self);
		self.syncRootData = syncRootData;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "sync-offline half_right";
			} else {
				displayFlags.modalClass = "sync-offline full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			var data = {
				title: locale.text("modal.sync.title"),
				label_tree: locale.text("modal.sync.header.tree"),
				label_sync: locale.text("modal.sync.label_sync"),
				label_sync_stop: locale.text("modal.sync.label_sync_stop")
			};
			return data;
		},

		_onShow: function() {
			var self = this;
			modalDialog.ModalBase.prototype._onShow.call(self);
			sdataSyncUtils.getSyncStructure(self.syncRootData.pageProto)
				.then(function(tree) {
					self.syncTreeRoot = tree;
					self._buildStructHtml(tree);
				});
		},

		_buildStructHtml: function(node) {
			var self = this;
			var $$sync = $("#s-m-sync-tree-id");
			var $$ul = $("<ul>");
			self._addNode($$ul, node, 0);
			$$sync.append($$ul);
		},

		_addNode: function($$parent, node, level) {
			var self = this;
			var cls = level > 0 ? "collapsed" : "expanded";
			cls = cls + (level < 1 ? " selected" : "");
			var $$li = $('\
				<li class="s-m-sync-tree-item ' + cls + '" data-params="' + node.uuid + '"> \
					<div class="s-m-tree-icon-expand" data-action="tree-click-expand" data-params="' + node.uuid + '"></div> \
					<div class="s-m-tree-label" data-action="tree-click-select" data-params="' + node.uuid + '"></div> \
					<div class="s-m-sync-count hidden"><div>"\
				</li>');
			$("div.s-m-tree-label", $$li).text(node.$title);
			$$parent.append($$li);
			if (node.$children.length > 0) {
				var $$ul = $("<ul>");
				if (node.$isDetails !== true) {
					// For $query parent, the single $details link is not added to the tree it will be handled implicitly
					var child = node.$children[0];
					if (child && child.$children && child.$children.length > 0) {
						$$li.append($$ul);
						child.$children.forEach(function(child) {
							self._addNode($$ul, child);
						});
					}
				} else {
					if (node.$children && node.$children.length > 0) {
						$$li.append($$ul);
						// For a $details parent, all child links are added as new tree level
						node.$children.forEach(function(child) {
							self._addNode($$ul, child);
						});
					}
				}
			}
			// No children added
			if ($("ul", $$li).length < 1) {
				var $$expand = $(">.s-m-tree-icon-expand", $$li);
				$$expand.removeClass("s-m-tree-icon-expand");
				$$expand.addClass("s-m-tree-icon-leaf");
				$$expand.attr("data-action", null);
			}
		},
		_onAction: function(action, param) {
			var self = this;
			if (action === "tree-click-expand") {
				self._onTreeClickExpand(param);
			} else if (action === "tree-click-select") {
				self._onTreeClickSelect(param);
			} else if (action === "modal-sync") {
				self._syncData();
			} else if (action === "modal-sync-stop") {
				self.stopSync = true;
			}

			return false;
		},
		_onValidate: function() {},

		_onCancel: function() {},

		_getResult: function() {
			return "done";
		},
		_onTreeClickExpand: function(param) {
			var self = this;
			var $$li = $('li[data-params="' + param + '"]');
			if ($$li.hasClass("expanded")) {
				$$li.removeClass("expanded");
				$$li.addClass("collapsed");
			} else {
				$$li.addClass("expanded");
				$$li.removeClass("collapsed");
			}
		},
		_onTreeClickSelect: function(param) {
			var self = this;
			var $$li = $('li[data-params="' + param + '"]');
			if ($$li.hasClass("selected")) {
				$$li = $$li.add("li", $$li);
				$$li.removeClass("selected");
			} else {
				$$li = $$li.add("li", $$li);
				$$li.addClass("selected");
			}
		},

		_syncData: function() {
			var self = this;
			self.stopSync = false;

			var $$li = $('li[data-params="' + self.syncTreeRoot.uuid + '"]');

			$('button[data-action="modal-sync"]', self.$$elmt).addClass("hidden");
			$('button[data-action="modal-sync-stop"]', self.$$elmt).removeClass("hidden");

			self.syncCount = 0;
			self.errorCount = 0;
			self._updateErrorCount();
			$.smForEachPromise(self.syncRootData.rowsData, function(row, idx, cnt) {
				if (self.stopSync) {
					return $.smResolve();
				}
				self._updateSyncCount($$li, idx, cnt);
				return self._syncNodeData(self.syncTreeRoot, row.rowData.data);
			})
				.always(function(e) {
					$('button[data-action="modal-sync"]', self.$$elmt).removeClass("hidden");
					$('button[data-action="modal-sync-stop"]', self.$$elmt).addClass("hidden");
				});
		},

		_updateSyncCount: function($$li, idx, cnt) {
			var self = this;
			var $$state = $(">div.s-m-sync-count", $$li);
			$$state.removeClass("hidden");
			$$state.text((idx + 1) + " / " + cnt);
			var $$states = $("li>div.s-m-sync-count", $$li);
			$$states.addClass("hidden");
		},

		_updateErrorCount: function() {
			var self = this;

			var $$total = $('button[data-action="modal-sync-stop"]>.s-m-sync-total', self.$$elmt);
			var $$ok = $(">.ok", $$total);
			var $$error = $(">.error", $$total);
			$$ok.text(self.syncCount);
			$$error.text(self.errorCount);
		},

		_syncNodeData: function(node, parentData) {
			var self = this;
			var $$li;

			if (self.stopSync) {
				return $.smResolve();
			}

			if (node.$isDetails !== true) {
				$$li = $('li[data-params="' + node.uuid + '"]');
				if ($$li.length < 1) {
					return $.smResolve();
				}
				if (!$$li.hasClass("selected")) {
					return $.smResolve();
				}
				node.$$listItem = $$li;
			}

			node.$$listItem.addClass("sync-progress");

			var nodeData;
			if (node.$link) {
				nodeData = self._readNodeData(node, parentData);
			} else {
				nodeData = $.smResolve(parentData);
			}
			return nodeData
				.then(function(nodeData) {
					var dataItems = nodeData && nodeData.$resources;
					if (!dataItems && nodeData) {
						dataItems = [nodeData];
					}
					if (!dataItems) {
						return $.smResolve(null);
					}
					return $.smForEachPromise(dataItems, function(dataItem, idx, cnt) {
						if (self.stopSync) {
							return $.smResolve();
						}

						if (nodeData.$resources) {
							self._updateSyncCount($$li, idx, cnt);
						}
						return $.smForEachPromise(node.$children, function(child) {
							if (self.stopSync) {
								return $.smResolve();
							}

							child.$$listItem = $$li;
							return self._syncNodeData(child, dataItem);
						}).
						then(function() {
							// Children may set the same node to finished which may be wrong
							node.$$listItem.addClass("sync-progress");
						});
					});
				})
				.then(function() {
					node.$$listItem.removeClass("sync-progress");
				});
		},
		_readNodeData: function(node, parentData) {
			var self = this;
			var deferred = $.Deferred();
			var linkUrl = utils.parseExpression(node.$link.$url, parentData, node.$prototype);
			linkUrl = linkUrl + "&nocache=true"; // Always force to not use the cache

			sdataDispatcher.dispatch({
				$url: linkUrl,
				$method: "GET"
			})
				.then(function(data) {
					self.syncCount++;
					self._updateErrorCount();
					deferred.resolve(data);
					return data;
				})
				.fail(function() {
					self.errorCount++;
					self._updateErrorCount();
					deferred.resolve(null);
				});

			return deferred.promise();
		}
	}
);

exports.Modal = _Klass;
});

define('syracuse-tablet/html/js/application/multiSelectionMgr',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/sdata/sdataUtils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/sdata/sdataDispatcher','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modalSyncOffline'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var dispatcher = require('syracuse-tablet/html/js/sdata/sdataDispatcher');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalSyncOffline = require('syracuse-tablet/html/js/ui/modals/modalSyncOffline');

var _linksMenuId = "multiSelMenuLink";
var _actionMenuId = "multiSelMenuActions";
var _selectedClass = "s-m-multi-selected";

var _templates = {
	menuActions: '\
		<div id="{{id}}" class="btn-group s-m-ismultisel">\
			<div class="{{dropDirection}}">\
				<button type="button" class="btn btn-primary dropdown-toggle" data-toggle="dropdown" aria-expanded="false">\
					<span class="badge"></span>{{title}}<span class="caret"></span>\
				</button>\
				<ul class="dropdown-menu dropdown-menu-right" role="menu">\
					{{#each links}}\
						<li><a  {{#if style}}style="{{style}}"{{/if}} draggable="false"  data-action="multiSelectionAction" data-params="{{params}}" data-control-id="{{../ctrlId}}" href="#">{{title}}</a></li>\
					{{/each}}\
				</ul>\
			</div>\
		</div>',
	menuLinks: '\
		<div  id="{{id}}" class="btn-group s-m-ismultisel">\
			<div class="{{dropDirection}}">\
				<button type="button" class="btn btn-primary dropdown-toggle" data-toggle="dropdown" aria-expanded="false">\
				{{title}}<span class="caret"></span>\
				</button>\
				<ul class="dropdown-menu dropdown-menu-right" role="menu">\
					{{#each links}}\
						<li>\
							<a draggable="false"  href="#" class="{{css}}" data-action="multiSelectionAction" data-params="{{$uuid}}" data-control-id="{{../ctrlId}}">\
								{{title}}\
							</a>\
						</li>\
					{{/each}}\
				</ul>\
			</div>\
		</div>',
	processMenu: '\
		<a draggable="false"  href="#" class="s-m-ismultisel" data-action="multiSelectionAction" data-params="$exitrun" data-control-id="{{ctrlId}}">\
			<i class="{{icon}}"/>\
		</a>'
};
var _actionsList = ["download", "unselectall", "selectall", "invert", "hideunselected", "showunselected"];

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	if (!tmpl) alert(locale.text("multiselect.gethtml.alert", name));
	return tmpl(ctx);
};

/**
 * Manages MultiSelection
 */
var _Klass = utils.defineClass(

	function(controller, cssToToggle) {
		this.controller = controller;
		this.cssToToggle = cssToToggle;
	}, null, {

		destroy: function() {
			this.controller = null;
			this._$$ownerParent = null;
		},
		getLinks: function() {
			return this.controller.getMultiSelectionLinks();
		},

		isEnabled: function() {
			return this._$$ownerParent != null;
		},
		disable: function() {
			if (this.isEnabled()) {
				this._stopMultiSel(this._getArray());
			}
		},
		_getArray: function() {
			var array = this.controller.getControlByBind("$resources");
			if (!array) throw new Error(locale.text("multiselect.getArray.error"));
			return array;
		},

		/**
		 * enable/disable multi-selection
		 * Called from footer or header
		 */
		toggle: function(ctrlOwner, $$parent, dropDirection) {
			var array = this._getArray();
			if (this._$$ownerParent) {
				this._stopMultiSel(array);
			} else {
				this._startMultiSel($$parent, array, dropDirection);
			}
			return this._$$ownerParent != null;
		},
		/**
		 * Called from array
		 */
		callbackArray: function(ctrlArray, params, $target) {
			if (params == "$selectmultisel") {
				this._toggleSelectStatus(ctrlArray, $target.closest(".s-m-record"));
				return;
			}
			if (params == "$showdiagnoses") {
				this._showDiagnoses($target);
				return;
			}
			if (params == "$exitrun") {
				this._processExit(ctrlArray);
				return;
			}
			if (params == "$exitmultisel") {
				this._stopMultiSel(ctrlArray);
				return;
			}
			if (params == "$download") {
				this._startDownloadAction(ctrlArray);
				return;
			}
			if (params == "$unselectall") {
				this._toggleUnselected(ctrlArray, true);
				this._toggleSelectStatus(ctrlArray, this._$$Selected(ctrlArray), false);
				return;
			}
			if (params == "$selectall") {
				this._toggleUnselected(ctrlArray, true);
				this._toggleSelectStatus(ctrlArray, this._$$Unselected(ctrlArray), true);
				this._updateUI(ctrlArray, ctrlArray.getNbRecords());
				return;
			}
			if (params == "$invert") {
				var unSelected = this._$$Unselected(ctrlArray);
				var selected = this._$$Selected(ctrlArray);
				this._toggleSelectStatus(ctrlArray, unSelected, true);
				this._toggleSelectStatus(ctrlArray, selected, false);
				return;
			}
			if (params === "$hideunselected" || params === "$showunselected") {
				this._toggleUnselected(ctrlArray, params === "$showunselected");
				this._$$action("$hideunselected").toggle(params === "$showunselected");
				this._$$action("$showunselected").toggle(params === "$hideunselected");
				this._updateUI(ctrlArray, null);
				return;
			}
			/**
			 * EXECUTE ACTIONS - params is the id of the link
			 */
			if (this.nbSelected > 0) {
				var self = this;
				setTimeout(function() {
					self._processAll(ctrlArray, params);
				});
			}
		},
		_toggleSelectStatus: function(ctrlArray, elmtList, select) {
			var selected = elmtList.toggleClass(_selectedClass, select).hasClass(_selectedClass);
			if (ctrlArray.$display === "card") {
				var $$card = elmtList.find(".s-m-card");
				if (selected) {
					$$card.append('<span class="badge checked fa fa-check">&nbsp;</span>');
				} else {
					$$card.find(".badge.checked").remove();
				}
			}
			this._updateUI(ctrlArray, this._$$Selected(ctrlArray).length);
		},
		/**
		 * Show/Hide buttons in parent's owner (foorter/header...)
		 */
		_toggleOwnerActions: function(show) {
			var selector = "a:not(.s-m-ismultisel)";
			if (this.cssToToggle) {
				selector += ", " + this.cssToToggle;
			}
			this._$$ownerParent.closest(".s-m-control").find(selector).toggle(show);
		},
		_startMultiSel: function($$parent, array, dropDirection) {
			notifications.subscribe(this, ["sm.main.layout.changed"]);
			this._$$ownerParent = $$parent;
			this._$$ownerAction().addClass("enabled");
			array.multiSelSetMgr(this);
			$$parent.prepend(this._$$linksMenuHtml(array, dropDirection));
			$$parent.prepend(this._$$actionMenuHtml(array, dropDirection));
			// Hide all action other than multisel ones
			this._toggleOwnerActions(false);
			// Disable last selected line
			array.selectLastSelectedRow(null);
			// Disable status management if any
			array.toggleColorStatus(true);
			var self = this;
			// setTimeout otherwise $selectall is not shown
			setTimeout(function() {
				self._updateUI(array, 0);
			});
		},
		_stopMultiSel: function(array) {
			notifications.unsubscribe(this, ["sm.main.layout.changed"]);
			if (!this._$$ownerParent) return;
			this._processExit(array);
			array.multiSelSetMgr(null);
			this._toggleSelectStatus(array, this._$$Selected(array), false);
			this._$$menu(_linksMenuId).remove();
			this._$$menu(_actionMenuId).remove();
			this._$$ownerAction().removeClass("enabled");
			// Enable status management if any
			array.toggleColorStatus(false);
			// Show all action other than multisel ones
			this._toggleOwnerActions(true);
			this._$$ownerParent = null;
			this._resizeArray(array);
		},

		_$$linksMenuHtml: function(array, dropDirection) {
			return _getHtml("menuLinks", {
				id: _linksMenuId,
				links: this.getLinks(),
				ctrlId: array.id,
				title: locale.text("actions"),
				dropDirection: dropDirection || "dropdown"
			});
		},

		_$$actionMenuHtml: function(array, dropDirection) {
			var links = [];
			_actionsList.forEach(function(id) {
				links.push({
					title: locale.text("multiselect.action." + id),
					params: "$" + id,
					style: "display:none"
				});
			});
			return _getHtml("menuActions", {
				id: _actionMenuId,
				links: links,
				ctrlId: array.id,
				title: locale.text("multiselect.selected"),
				dropDirection: dropDirection || "dropdown"
			});
		},

		_resizeArray: function(array) {
			/**
			 * To recalculate the scroller beacuse we hide/show cells
			 */
			array.onResize({
				scrollOnly: true
			});
		},
		_getSelectedData: function(array) {
			var selected = this._$$Selected(array);
			var data = [];
			selected.each(function(idx, record) {
				var $$record = $(record);
				// avoid click
				$$record.attr("data-disabled", "true");
				var rowId = $$record.attr("data-params");
				var rowdata = array.getRowById(rowId);
				if (rowdata) {
					data.push({
						rowData: rowdata.row,
						rowId: rowId,
						$$record: $$record,
						idx: idx,
						status: "init"
					});
				}
			});
			return data;
		},
		_processStart: function(array, uuid) {
			var deferred = $.Deferred();
			try {
				array.waitStart();
				this._toggleUnselected(array, false);
				this._$$ownerParent.find(".s-m-ismultisel").hide();
				this._resizeArray(array);
				this._$$ownerParent.prepend(_getHtml("processMenu", {
					title: "Exit",
					ctrlId: array.id,
					icon: fontUtils.getIconByName("$cancelMultiSel")
				}));
				var data = this._getSelectedData(array);
				// reads link info
				var link = null;
				var self = this;
				this.getLinks().some(function(l) {
					if (l.$uuid === uuid) {
						link = l;
						return true;
					}
				});
				deferred.resolve(link, data);
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},
		_processAll: function(array, uuid) {
			var self = this;
			var _data;
			self._processStart(array, uuid).then(function(link, data) {
				_data = data;
				var deferred = $.Deferred();
				var _run = function(idx) {
					if (idx >= data.length) {
						deferred.resolve(link, data);
					} else {
						self._processOne(array, link, data[idx], idx).then(function(ok) {
							_run(idx + 1);
						});
					}
				};
				_run(0);
				return deferred.promise();
			}).then(function(link, data) {
				self._processEnd(data, array);
			}).fail(function(e) {
				globals.getModal().error(locale.text("multiselect.processAll.fail"), e, function() {
					self._processEnd(_data, array);
				});
			});
		},
		_toggleUnselected: function(array, show) {
			this._$$Unselected(array).toggle(show);
			if (array.$display == "card") {
				// Hide empty rows to remove the height of empty tr elements
				array.$$elmt.find("tr").each(function() {
					var e = $(this);
					e.toggle(show ? show : e.find("td").length != e.find("td.s-m-record:not(:visible)").length);
				});
			}
		},
		_processEnd: function(data, array) {
			var res = {
				ok: 0,
				ko: 0,
				init: 0
			};
			data.forEach(function(d) {
				res[d.status]++;
			});
			this._$$ownerParent.prepend('<span class="s-m-multiselmsg">' + res.ok + ' successes - ' + res.ko + ' failures</span>');
			this._resizeArray(array);
			array.waitStop();
		},
		_processExit: function(array) {
			// Clear status
			this._toggleUnselected(array, true);
			this._toggleSelectStatus(array, this._$$Selected(array), false);
			// Clear messages
			this._$$All(array).show().removeClass("error success").removeAttr("data-disabled");
			// Remove buttons in footer/header
			this._$$ownerParent.find('[data-params="$exitrun"], .s-m-multiselmsg').remove();
			this._$$ownerParent.find(".s-m-ismultisel").show();
			// Clear disgnoses attached to error records
			array.$$value.find(".s-m-multisel-diag").smRemoveData('diagnoses').remove();
			this._resizeArray(array);
		},
		_processOne: function(array, link, data, idx) {
			var self = this;
			var deferred = $.Deferred();
			var _end = function(success, result) {
				try {
					var diagsMsg = [],
						diagsErr = [];
					if ($.isPlainObject(result)) {
						var diags = sdataUtils.scanDiagnoses(result);
						if (diags) {
							diags.forEach(function(d) {
								if (d.$severity === "error") {
									diagsErr.push(d);
								} else {
									diagsMsg.push(d);
								}
							});
						}
					}
					success = success && diagsErr.length == 0;
					if (!success) {
						if (jsutils.isError(result)) {
							// console.log(JSON.stringify(result.stack, null, 2));
							data.$diagnoses = [{
								$message: result.message,
								$stackTrace: result.stack
							}];
						} else {
							data.$diagnoses = diagsErr;
						}
					} else {
						data.$diagnoses = diagsMsg;
						// console.log(JSON.stringify(result, null, 2));
					}
				} catch (e) {
					success = false;
					data.$diagnoses = [{
						$message: e.message,
						$stackTrace: e.stack
					}];
				} finally {
					data.status = success ? "ok" : "ko";
					data.$$record.addClass(success ? "success" : "error");
					self._addDiagnoses(array, data);
					deferred.resolve(success);
				}
			};
			try {
				if (link.$url) {
					var sdataUrl = data && data.rowData ? data.rowData.parseExpression(link.$url) : link.sDataUrl;
					var payload = data && data.rowData ? data.rowData.getActionPayload(link) : null;
					dispatcher.dispatch({
						$url: sdataUrl,
						$method: link.$method || "GET"
					}, payload).then(function(data) {
						_end(true, data);
					}).fail(function(e) {
						_end(false, e);
					});
				} else {
					_end(true);
				}
			} catch (e) {
				_end(false, e);
			} finally {
				return deferred.promise();
			}
		},
		_addDiagnoses: function(array, data) {
			var $$root = null,
				colSpan, $$diag, isTable = array.getMode() === "table";
			if (isTable) {
				colSpan = data.$$record.children('td').length;
			} else {
				$$root = $('<section data-action="multiSelectionAction" data-params="$showdiagnoses"/>').addClass("s-m-multisel-diag").prependTo(data.$$record);
				$$root.width(data.$$record.width());
				$$root.smData('diagnoses', data.$diagnoses);
			}
			data.$diagnoses.forEach(function(d, idx) {
				$$diag = $('<div data-idx="' + idx + '" class="alert alert-' + (d.$severity === "error" ? "danger" : "success") + '" role="alert">' + d.$message + '</div>');
				if (isTable) {
					$$root = $('<tr  data-action="multiSelectionAction"  data-params="$showdiagnoses"><td colspan="' + colSpan + '"/></tr>').addClass("s-m-multisel-diag");
					$$root.smData('diagnoses', data.$diagnoses);
					data.$$record.after($$root);
					$$root = $$root.children()[0];
				}
				$$diag.appendTo($$root);
			});
		},
		_showDiagnoses: function($$elmt) {
			$$elmt = $$elmt.closest(".s-m-multisel-diag");
			var diags = $$elmt.smData('diagnoses');
			if (diags == null || diags.length == 0) return;
			globals.getModal().error("", {
				$diagnoses: diags
			});
		},
		_$$ownerAction: function() {
			return this._$$ownerParent.find('[data-action="' + globals.ACTMULTISEL + '"]');
		},
		_$$Unselected: function(array) {
			return array.$$value.find(".s-m-record:not(." + _selectedClass + ")");
		},
		_$$Selected: function(array) {
			return array.$$value.find(".s-m-record." + _selectedClass);
		},
		_$$All: function(array) {
			return array.$$value.find(".s-m-record");
		},
		_$$action: function(id) {
			return this._$$ownerParent.find('[data-params="' + id + '"]');
		},
		_$$menu: function(id) {
			return this._$$ownerParent.find("#" + id);
		},
		_updateUI: function(array, nb) {
			if (!this._$$ownerParent) return;
			if (nb != null) {
				this.nbSelected = Math.max(0, nb);
				this._$$menu(_actionMenuId).find(".badge").text(this.nbSelected);
			}
			var noSel = this.nbSelected == 0;
			var allSel = this.nbSelected === array.getNbRecords();
			this._$$menu(_linksMenuId).find("button").toggleClass("disabled", noSel);
			if (noSel || allSel) {
				this._$$action("$hideunselected").hide();
				this._$$action("$showunselected").hide();
			} else if (this.nbSelected > 0 && !this._$$action("$showunselected").is(":visible")) {
				this._$$action("$hideunselected").show();
			}
			this._$$action("$unselectall").toggle(this.nbSelected > 0);
			this._$$action("$selectall").toggle(true);
			this._$$action("$invert").toggle(this.nbSelected > 0);
			this._$$action("$download").toggle(this.nbSelected > 0);
		},
		notifMainLayoutChanged: function() {
			if (this._$$ownerParent) {
				this._stopMultiSel(this._getArray());
			}
		},
		_startDownloadAction: function(ctrlArray) {
			var self = this;

			var data = self._getSelectedData(ctrlArray);
			var pageProto = ctrlArray.prototype;
			while (pageProto.parent) {
				pageProto = pageProto.parent;
			}
			var syncRootData = {
				pageProto: pageProto,
				rowsData: []
			};
			data.forEach(function(rowData) {
				syncRootData.rowsData.push(rowData);
			});

			var modal = new modalSyncOffline.Modal(syncRootData);
			modal.show().then(function(result) {
				if (result === "done") {
					self._stopMultiSel(ctrlArray);
				}
			});
		}
	});


exports.create = function(controller, cssToToggle) {
	if (!controller.isMultiSelectionEnabled()) return null;
	return new _Klass(controller, cssToToggle);
};
});

define('syracuse-tablet/html/js/controls/page/ctrlHeaderBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/uiSettings','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/application/eventListener','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/application/actionManager','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/application/multiSelectionMgr','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var globals = require('syracuse-tablet/html/js/helpers/globals');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var prototype = require('syracuse-tablet/html/js/helpers/prototype');
var actionManager = require('syracuse-tablet/html/js/application/actionManager');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var multiSelectionMgr = require('syracuse-tablet/html/js/application/multiSelectionMgr');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var _userPanelId = globals.PANELUSERSMARTPHONE;
var _actionPanelId = globals.PANELACTIONSREGULAR;

var _templates = {
	main: '\
		<div class="s-m-header container-fluid {{deviceType}}">\
			{{{contentHtml}}}\
		</div> \
	',
	tablet: {
		main: '\
			<div class="s-m-header-nav">\
				{{#if showBack}} \
					<a href="#" draggable="false" data-action="historyBack">\
						<i class="' + fontUtils.pageIcon("back") + '" />\
						</a>\
				{{/if}} \
			</div>\
			<div class="s-m-header-labels">\
				{{#if showBrand}}\
					<div class="s-m-header-brand"><span class="s-m-brand">{{labelBrand}}</span> <span class="s-m-product">{{labelProduct}}</span></div>\
				{{/if}}\
				<div class="s-m-header-label">{{headerLabel}}</div>\
			</div>\
			<div class="s-m-header-links">\
				{{{userContent}}}\
			</div>',
		userInfo: '\
			<div>\
				<span class="s-m-nav-text username">{{username}}</span>\
				<span class="s-m-nav-text userrole">{{userrole}}</span>\
			</div>\
			{{#if userPhotoUrl}}\
				<img src="{{userPhotoUrl}}"/>\
			{{else}}\
				<span style="font-size:32px" class="' + fontUtils.pageIcon("switchContext") + '" />\
			{{/if}}',
		infoOnly: '\
			<div>{{{userInfo}}}</div>}}}',
		dropDown: '\
			<div class="dropdown">\
				<a href="#" draggable="false" data-toggle="dropdown" role="button" id="{{dropdownId}}" aria-haspopup="true" aria-expanded="false">\
					{{{userInfo}}}\
				</a>\
				{{{dropDownMenu}}}\
			</div>',
		dropDownMenu: '\
			<ul class="dropdown-menu" role="menu" aria-labelledby="{{dropdownId}}">\
				{{#each links}}\
					{{#if divider}} \
						<li role="presentation" class="divider"></li>\
					{{/if}} \
					<li>\
						<a href="#" data-action="linkClicked" draggable="false" data-params="{{data-params}}" data-control-id="{{ctrlId}}" class="list-group-item {{css}}">\
							<span class="{{icon}}" />\
							<span>{{label}}</span>\
						</a>\
					</li>\
				{{/each}}\
			</ul>',
		search: '\
			<div class="s-m-header-search" style="display:none">\
				<form style="display:none" class="navbar-form navbar-right" role="search">\
					<div class="form-group input-group-sm"">\
						<input type="text" class="form-control" placeholder="Search">\
					</div>\
					<button type="submit" class="btn btn-success">\
						<span class="' + fontUtils.pageIcon("search") + '"></span>\
					</button>\
				</form>\
			</div>'
	},
	smartphone: {
		main: '\
			<div class="s-m-header-nav">\
				<a href="#" draggable="false" data-action="headerAction" data-params="{{panelId}}" data-control-id="{{ctrlId}}">\
					<span class="' + fontUtils.pageIcon("bars") + '" />\
				</a>\
				{{{backDom}}}\
			</div>\
			<div class="s-m-header-labels">\
				{{{labelContent}}}\
			</div>\
			<div class="s-m-header-links">\
				{{{linksContent}}}\
			</div>',
		backDom: '\
			<a href="#" draggable="false" data-action="historyBack" style="padding-left:0;">\
				<span class="' + fontUtils.pageIcon("backIphone") + '" />\
			</a>',
		brandDom: '\
			<div class="s-m-header-brand">\
				<span class="s-m-brand">{{labelBrand}}</span>\
				<span class="s-m-product">{{labelProduct}}</span>\
			</div>',
		labelDom: '\
			<div class="s-m-header-label">{{label}}</div>',
		actionLink: '\
			<a href="#" draggable="false" class="{{css}}" {{#if $isHidden}}style="display:none"{{/if}} data-action="{{#if action}}{{action}}{{else}}headerLink{{/if}}" data-params="{{$uuid}}" data-control-id="{{ctrlId}}">\
				<i class="{{icon}}"></i>\
			</a>',
		actionPanelToggle: '\
			<a href="#" data-action="headerAction" draggable="false" data-params="{{panelId}}" data-control-id="{{ctrlId}}">\
				<i class="' + fontUtils.pageIcon("sidePanelR") + '" />\
				<span>{{{title}}}</span>\
			</a>'
	}
};

var _linksCtx = {
	showAuthoring: {
		items: [{
			"data-params": "designPage",
			"icon": "designPage",
			"label": "header.links.designPage"
		}]
	},
	showLinks: {
		items: [{
			"data-params": "switchContext",
			"icon": "switchContext",
			"label": "header.links.switchContext"
		}, {
			"data-params": "settings",
			"icon": "settings",
			"label": "header.links.settings"
		}, {
			"data-params": "about",
			"icon": "about",
			"label": "header.sm.links.about"
		}]
	},
	showDevelopment: {
		"divider": true,
		items: [{
			"data-params": "developmentPage",
			"icon": "developmentPage",
			"label": "header.links.development"
		}]
	}
};

var _getHtml = function(type, name, ctx) {
	type = type || "";
	var key = type + name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = type.length == 0 ? _templates[name] : _templates[type][name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	return tmpl(ctx);
};

/**
 * Page header Generate Html
 */
var _Klass = utils.defineClass(

	function CtrlPageHeader($type, controller, options) {
		Base.call(this, controller, {
			$bind: "header"
		}, prototype.create({
			$type: $type
		}), options);
	}, Base, {

		destroy: function() {
			this.resetPanels();
			if (this._actionManager) {
				this._actionManager.destroy();
				this._actionManager = null;
			}
			if (this._multiSelManager) {
				this._multiSelManager.destroy();
				this._multiSelManager = null;
			}
			Base.prototype.destroy.call(this);
		},
		resetPanels: function() {
			if (this._smphUserpanel) {
				this._smphUserpanel.destroy();
			}
			if (this._smphPageactionpanel) {
				this._smphPageactionpanel.destroy();
			}
		},
		buildHtml: function($$parent, controllerDao, buildOptions) {
			buildOptions = buildOptions || {};
			this.buildOptions = this.checkBuildOptions(buildOptions);
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, this.buildOptions, [this.typeName]);
			// Build the header with default deviceClass - To avoid flickering of the page - Improvement is done in onMainPageResize
			if (this.buildOptions.refresh === true) {
				// Avoid double build
				// If it's not a refresh build is called on onResize - there's always a triggerResize when we rendre a page
				this._build();
			}
		},

		// Can be overridden
		checkBuildOptions: function(buildOptions) {
			var opts = $.extend(buildOptions.footer, buildOptions.toolBars) || {};
			opts.showDevelopment = globals.isDvlpMode();
			opts.showAuthoring = (utils.isDesktop() === true) ? opts.showAuthoring : false; // Show full feature authoring only if on PC
			return opts;
		},

		applyMetaData: function(metaData) {
			//  No meta for this control 
			return;
		},
		onMainPageResize: function(info, orientation) {
			// In any case because we need to have the content width	
			this.$$elmt.parent().css({
				width: info.contentWidth + "px"
			});
			this._build();
			// In any case because we need to have the width tho calculate text-overflow elipsis
			this._updateHeaderStyle(this._deviceType);
		},
		getHeight: function() {
			return this.$$elmt && this.$$elmt.is(":visible") ? this.$$elmt.height() : 0;
		},
		/**
		 * Allows to build header in build html (better UX)
		 */
		_build: function() {
			var deviceType = globals.getSiteLayout().getDeviceType();
			if (this._deviceType != null && this._deviceType === deviceType) return;
			if (this._multiSelManager) {
				this._multiSelManager.destroy();
				this._multiSelManager = null;
			}
			if (this._actionManager) {
				this._actionManager.destroy();
				this._actionManager = null;
			}
			this._deviceType = deviceType;
			if (this.$$header) this.$$header.remove();
			var h = uiSettings.getProp("header.height");
			this.$$elmt.css({
				height: h + "px"
			});
			/*this.$$elmt.height(h);*/
			var $$parent = this.$$elmt.parent();
			$$parent.css({
				left: 0 + "px",
				height: h + "px"
			});
			var opts = this.buildOptions;
			// Controller that handle action - different from current page for vignettes
			var actionController = this.getActionController();
			// Controller that displays the footer
			var displayController = this.controller;
			var contentHtml;
			if (deviceType === "smartphone") {
				contentHtml = this._smartPhoneHtml(opts, displayController, actionController);
			} else {
				contentHtml = this._tabletHtml(opts, displayController, actionController);
			}
			this.$$header = $(_getHtml(null, "main", {
				contentHtml: contentHtml,
				deviceType: deviceType
			}));
			this.$$header.appendTo(this.$$elmt);
		},

		/**
		 * Controller that handles actions
		 * For actions in dashboard this controller is the page nested in the vignette
		 * Can be overridden
		 */
		getActionController: function() {
			return this.controller;
		},

		/**
		 *	Update some header css properties.
		 */
		_updateHeaderStyle: function(deviceType) {
			// tablet
			// calculate and set s-m-header-labels div width according
			// to widths of s-m-header-nav and s-m-header-links div elements.
			var self = this;
			var $$header = self.$$elmt.find(".s-m-header");
			var $$links = self.$$elmt.find(".s-m-header-links");
			var $$nav = self.$$elmt.find(".s-m-header-nav");
			var $$label = self.$$elmt.find(".s-m-header-label");
			var offset = 10;
			if (deviceType === "tablet") {

				// for pages other than welcome page, update label width
				if (!self.controller.state.isWelcomePage) {
					var maxWidth = $$header.width() - ($$nav[0].scrollWidth + $$links[0].scrollWidth + offset);
					$$label.css("max-width", maxWidth);
				}
				// on welcome page, if header is too small, label will be hidden for a better display
				else {
					$$label.css("max-width", "inherit");
					var $$brand = self.$$elmt.find(".s-m-header-brand");

					// hide label if brand + label + links > header (in term of width)
					var hideLabel = $$brand.width() + $$label.width() + $$nav.width() + $$links.width() + offset > $$header.width();
					$$label.toggle(hideLabel ? false : true);

					// if label hidden and header still too small, reduce brand fontsize until header has better display
					var sum = $$brand.width() + $$nav.width() + $$links.width();
					var off = 3;
					if (hideLabel == true && (sum > $$header.width())) {
						while (sum > $$header.width()) {
							$$brand.css("font-size", ($$brand.css("font-size").match(/\d+/)[0] - off) + "px");
							off += 3;
							sum = $$brand.width() + $$nav.width() + $$links.width();
						}
					} else {
						$$brand.css("font-size", "2.5em");
					}

				}
			}
			// smartphone
			else {
				// only not on welcome page
				if (!self.controller.state.isWelcomePage) {
					var maxWidth = $$header.width() - ($$nav[0].scrollWidth + $$links[0].scrollWidth + offset);
					$$label.css("max-width", maxWidth);
				}
			}
		},
		/**
		 * Returns HTML for tablet
		 */
		_tabletHtml: function() {
			var self = this;
			var lknCtx = {
				dropdownId: utils.UUID(),
				links: []
			};
			var opts = self.buildOptions;
			var linksCpt = 0;
			for (var p in _linksCtx) {
				if (opts[p] === true) {
					var l = _linksCtx[p];
					l.items.forEach(function(x, idx) {
						x = $.extend({}, x);
						x.label = locale.text(x.label);
						x.ctrlId = self.id;
						x.icon = fontUtils.pageIcon(x.icon);
						if (idx === 0 && lknCtx.links.length > 1) x.divider = l.divider;
						lknCtx.links.push(x);
					});
				}
			}
			var _mainCtx = {
				showBack: opts.showHome,
				showHome: opts.showHome,
				showBrand: self.controller.state.isWelcomePage,
				labelBrand: opts.labelBrand || "Sage",
				labelProduct: opts.labelProduct || "ERP X3",
				headerLabel: self.controller.prototype.data("$title")
			};
			var htmlUserInfo = _getHtml("tablet", "userInfo", {
				username: globals.getUserName(),
				userrole: globals.getUserRole(),
				userPhotoUrl: globals.getUserPhotoUrl
			});
			if (lknCtx.links.length === 0) {
				_mainCtx.userContent = _getHtml("tablet", "infoOnly", {
					userInfo: htmlUserInfo
				});
			} else {
				_mainCtx.userContent = _getHtml("tablet", "dropDown", {
					userInfo: htmlUserInfo,
					dropDownMenu: _getHtml("tablet", "dropDownMenu", lknCtx)
				});
				/** Force overflow visible on s-m-control to display the dropDownMenu**/
				self.$$elmt.css({
					overflow: "visible"
				});
			}
			return _getHtml("tablet", "main", _mainCtx);
		},
		/**
		 * Returns HTML for smartphone
		 */
		_smartPhoneHtml: function(opts, displayController, actionController) {
			var self = this;
			this.resetPanels();
			if (opts.showUserpanel) {
				self._smphUserpanel = displayController.panelCreate(_userPanelId);
			}
			if (opts.showActionpanel) {
				self._smphPageactionpanel = displayController.panelCreate(_actionPanelId);
			}
			var backDom = "";
			var labelContent = "";
			var linksContent = "";
			// build backDom only if iPhone
			if (opts.showHome && globals.getLookAndFeel() === "ios") {
				backDom = _getHtml("smartphone", "backDom", {});
			}
			// build label content. 
			labelContent = self._getLabelContent(opts);
			// build links content.
			var hasPanelLinks = self._smphPageactionpanel && self._smphPageactionpanel.hasLinks();
			linksContent = self._getSmartphoneLinksContent(displayController, actionController, hasPanelLinks);
			var ctx = {
				backDom: backDom,
				labelContent: labelContent,
				linksContent: linksContent,
				panelId: _userPanelId,
				ctrlId: self.id
			};
			return _getHtml("smartphone", "main", ctx);
		},
		/**
		 *	/!\ SMARTPHONE ONLY
		 *	Returns header label content which depends on the current page.
		 *	Label depends whether user is located in home page, app dashboard page, inside an app, or anywhere else
		 */
		_getLabelContent: function(opts) {
			var self = this;
			var labelContent;

			function getContent(isLabelDom, labelVal, opts) {
				if (isLabelDom) {
					return _getHtml("smartphone", "labelDom", {
						label: labelVal
					});
				}
				// brand name
				else {
					return _getHtml("smartphone", "brandDom", {
						labelBrand: opts.labelBrand || "Sage",
						labelProduct: opts.labelProduct || "ERP X3",
					});
				}
			}

			// home page --> brand name
			if (this.controller.state.isWelcomePage) {
				labelContent = getContent(false, null, opts);
			} else {
				// app dashboard page --> app title
				labelContent = getContent(true, self.controller.prototype.data("$title"));
				if (!labelContent) {
					// other cases (for example html static page)
					labelContent = getContent(false, null, opts);
				}
			}
			return labelContent;
		},
		/**
		 *	/!\ SMARTPHONE ONLY
		 *	Returns header links content which depends on the current page.
		 *	- No link on welcome page and application dashboard
		 *	- On query page, links will be "create" and an anchor to open the actions panel (on the right)
		 *	- On detail page, links will be "edit" and an anchor to open the actions panel (on the right)
		 *	- On edit page, links will be "save", "cancel" and an anchor to open the actions panel (on the right)
		 *	Some actions will be displayed in the footer
		 */
		_getSmartphoneLinksContent: function(displayController, actionController, hasPanelLinks) {
			var linksContent = "";
			this._multiSelManager = multiSelectionMgr.create(actionController, ".s-m-header-nav, .s-m-header-labels, a:not(.s-m-ismultisel)");
			notifications.subscribe(this, ["sm.panel.multiselection.toggle"]);
			this._actionManager = actionManager.create(actionController, "header", {
				addCancelEditAction: "headerLink",
				addMultiSelection: !this.buildOptions.multiSelectionOnly && actionController.isMultiSelectionEnabled(),
				multiSelectionOnly: this.buildOptions.multiSelectionOnly
			});
			var linksArr = this._actionManager.getLinks();
			var cc = [];
			if (hasPanelLinks) {
				cc.push(_getHtml("smartphone", "actionPanelToggle", {
					panelId: _actionPanelId,
					ctrlId: this.id,
					title: "&nbsp;"
				}));
			}
			if (linksArr && linksArr.length > 0) {
				var self = this;
				linksArr.forEach(function(ll, idx) {
					cc.push(_getHtml("smartphone", "actionLink", $.extend(ll, {
						ctrlId: self.id,
						$isHidden: ll.action === "multiSelection"
					})));
				});
			}
			linksContent = cc.join("");
			return linksContent;
		},
		_actHeaderLink: function(uuid) {
			this._actionManager.triggerLink(uuid, this.getActionController()).then(function(success, link, data, options) {
				// Message is displayed 
			}).fail(function(e) {
				if (jsutils.isError(e)) {
					// We shouldn't expect an error except exceptions
					globals.getModal().error("Header action error (smartphone)", e);
				}
			});
		},
		_actHeaderAction: function(id) {
			var panel = id === _actionPanelId ? this._smphPageactionpanel : this._smphUserpanel;
			var side = id === _actionPanelId ? "right" : "left";
			this.controller.panelAttach(side, panel, "toggle");
		},
		_actLinkClicked: function(actionName) { /* triggering action */
			eventListener.triggerAction(this.$$elmt, actionName);
		},

		notifPanelMultiselectionToggle: function(uuid, $$target) {
			this.toggleMultiSelection();
		},

		toggleMultiSelection: function() {
			this._actMultiSelection();
			this.$$elmt.find('[data-action="multiSelection"]').show();
		},

		_actMultiSelection: function(uuid, $$target) {
			var enabled = this._multiSelManager.toggle(this, this.$$elmt.find(".s-m-header-links"), "dropdown");
			this.$$elmt.find(".s-m-header-nav, .s-m-header-labels, a:not(.s-m-ismultisel)").toggle(!enabled);
			this.$$elmt.find('[data-action="multiSelection"]').toggle(enabled);
		},

		/**
		 * Page footer can be changed
		 * This method is called each time the header is toggled
		 */
		notifToggled: function(shown) {
			if (shown === false) {
				if (this._multiSelManager) {
					this._multiSelManager.disable();
				}
				return;
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/ctrlPageHeader',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/page/ctrlHeaderBase'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/page/ctrlHeaderBase').Klass;
/**
 * Page main header
 */
var _Klass = utils.defineClass(

	function CtrlPageHeader($type, controller, options) {
		Base.call(this, $type, controller, options);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
		},

		checkBuildOptions: function(buildOptions, device) {
			var stdOpts = Base.prototype.checkBuildOptions.call(this, buildOptions);
			stdOpts.showUserpanel = true;
			stdOpts.showActionpanel = true;
			return stdOpts;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/ctrlFooterBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/uiSettings','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/application/actionManager','syracuse-tablet/html/js/application/multiSelectionMgr','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var globals = require('syracuse-tablet/html/js/helpers/globals');
var actionManager = require('syracuse-tablet/html/js/application/actionManager');
var multiSelectionMgr = require('syracuse-tablet/html/js/application/multiSelectionMgr');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var prototype = require('syracuse-tablet/html/js/helpers/prototype');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _actionPanelId = globals.PANELACTIONSREGULAR;
var _templates = {
	main: '\
		<div class="s-m-footer s-m-opened container-fluid {{deviceType}}">\
			{{{contentHtml}}}\
		</div>',
	tablet: {
		main: '\
			<div class="s-m-footer-left">\
				{{#if homeLink}}{{{homeLink}}}{{/if}}\
				{{#if configLink}}{{{configLink}}}{{/if}}\
				{{#if pinPage}}{{{pinPage}}}{{/if}}\
			</div>\
			<div class="s-m-footer-right">\
				{{#if rightLinks}}{{{rightLinks}}}{{/if}}\
			</div>\
		',
		rightLinks: '\
			{{#each links}}\
				<a draggable="false"  href="#" class="{{css}}" data-action="{{#if action}}{{action}}{{else}}footerLink{{/if}}" data-params="{{$uuid}}" data-control-id="{{../ctrlId}}">\
					<i class="{{icon}}"/>\
					<span>{{{title}}}</>\
				</a>\
			{{/each}}\
		',
		action: '\
			<a href="#" data-action="{{action}}">\
				<i class="{{icon}}"/>\
				<span>{{{title}}}</>\
			</a>'
	},
	smartphone: {
		main: ""
	}
};

var _getHtml = function(type, name, ctx) {
	type = type || "";
	var key = type + name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = type.length == 0 ? _templates[name] : _templates[type][name];
		tmpl = _templates[key] = Handlebars.compile(tmpl);
	}
	if (!tmpl) alert("footer template " + name + " not found");
	return tmpl(ctx);
};
/**
 * Base footer class
 */
var _Klass = utils.defineClass(
	function($type, controller, options) {
		Base.call(this, controller, {
			$bind: "footer"
		}, prototype.create({
			$type: $type
		}), options);
		this._actionManager = null;
		this._multiSelManager = null;
		this._actionPanel = null;
	}, Base, {

		destroy: function() {
			if (this._actionManager) {
				this._actionManager.destroy();
				this._actionManager = null;
			}
			if (this._multiSelManager) {
				this._multiSelManager.destroy();
				this._multiSelManager = null;
			}
			this.resetActionPanel();
			Base.prototype.destroy.call(this);
			notifications.unsubscribe(this);
		},

		/**
		 * Controller that handles actions
		 * For actions in dashboard this controller is the page nested in the vignette
		 * Can be overridden
		 */
		getActionController: function() {
			return this.controller;
		},

		resetActionPanel: function() {
			if (this._actionPanel) {
				this._actionPanel.destroy();
				this._actionPanel = null;
			}

		},
		buildHtml: function($$parent, controllerDao, buildOptions) {
			this.buildOptions = this.checkBuildOptions(buildOptions);
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions, [this.typeName]);
			this._$$parent = this.$$elmt.closest("footer");
			if (this.buildOptions.refresh === true) {
				// Avoid double build
				// If it's not a refresh build is called on onResize - there's always a triggerResize when we rendre a page
				this._build();
			}
		},

		// Can be overridden
		checkBuildOptions: function(buildOptions) {
			return $.extend(buildOptions.footer, buildOptions.toolBars) || {};
		},

		applyMetaData: function(metaData) {
			//  No meta for this control 
			return;
		},

		_actFooterLink: function(uuid) {
			this._actionManager.triggerLink(uuid, this.getActionController()).then(function(success, link, data, options) {
				// Message is displayed 
			}).fail(function(e) {
				if (jsutils.isError(e)) {
					// We shouldn't expect an error except exceptions
					globals.getModal().error("Footer action error", e);
				}
			});
		},
		/**
		 * Click on icon action
		 */
		_actMultiSelection: function(uuid, $$target) {
			this.toggleMultiSelection();
		},
		// Called by vignette footer
		toggleMultiSelection: function() {
			if (this._multiSelManager) {
				this._multiSelManager.toggle(this, this.$$elmt.find(".s-m-footer-right"), "dropup");
			}
		},

		_actFooterAction: function(id) {
			if (id === _actionPanelId) {
				this.controller.panelAttach("right", this._actionPanel, "toggle");
			}
		},

		onMainPageResize: function(info, orientation) {
			var deviceType = globals.getSiteLayout().getDeviceType();
			this._build(deviceType);
			if (this.$$footer) {
				// Set height/top of footer in any cases
				// Cancel bottom:0px of buildHtml
				this._$$parent.css({
					top: (info.contentHeight - this._height) + "px",
					width: info.contentWidth + "px",
				});
				// Sow needed to allow page to get height for scroller
				this._$$parent.show();
			} else {
				this.resetActionPanel();
			}
		},
		getHeight: function() {
			return this.$$elmt && this.$$elmt.is(":visible") ? this.$$elmt.height() : 0;
		},
		/**
		 * onMainPageResize event broke the buildHtml model
		 * We need to buil html onMainPageResize instead of onMainPageResize
		 */
		_build: function(deviceType) {
			deviceType = deviceType || globals.getSiteLayout().getDeviceType();
			if (this._deviceType != null && this._deviceType === deviceType) return;
			this._deviceType = deviceType;
			if (this.$$footer) {
				this.$$footer.remove();
				this.$$footer = null;
			}
			if (deviceType === "smartphone") return;
			this._height = uiSettings.getProp("footer.height");
			this._$$parent.css({
				left: 0 + "px",
				height: this._height + "px"
			});
			var htmlCtx = {};
			// Controller that handle action - different from current page for vignettes
			var actionController = this.getActionController();
			// Controller that displays the footer
			var displayController = this.controller;
			if (!this._multiSelManager) {
				this._multiSelManager = multiSelectionMgr.create(actionController);
			}
			var contentHtml;
			this._actionManager = actionManager.create(actionController, "footer", {
				addCancelEditAction: "footerLink",
				addMultiSelection: !this.buildOptions.multiSelectionOnly && actionController.isMultiSelectionEnabled(),
				multiSelectionOnly: this.buildOptions.multiSelectionOnly
			});
			this._addActionMgrHtmlCtx(htmlCtx, actionController, displayController);
			this.$$footer = $(_getHtml(null, "main", {
				contentHtml: _getHtml("tablet", "main", htmlCtx),
				deviceType: deviceType
			}));
			this.$$footer.appendTo(this.$$elmt);
		},
		/**
		 * Return the html context to display actions/panel - Action comes from $links
		 */
		_addActionMgrHtmlCtx: function(ctx, actionController, displayController) {
			if (!this._actionManager) return;
			var rightLinks;
			if (this._actionManager.hasLinks()) {
				rightLinks = this._actionManager.getLinks();
			}
			if (!this._actionPanel && actionController.state.type === "regular") {
				// Add open/close action panel - We are not on smartPhone -> We display it
				this._actionPanel = displayController.panelCreate(_actionPanelId);
			}
			if (this._actionPanel && this._actionPanel.hasLinks()) {
				if (!rightLinks) rightLinks = [];
				rightLinks.push({
					action: "footerAction",
					icon: fontUtils.pageIcon("sidePanelR"),
					$uuid: _actionPanelId,
					title: "&nbsp;"
				});
			}
			if (rightLinks) {
				// BUILD RIGHT LINKS HTML
				ctx.rightLinks = _getHtml("tablet", "rightLinks", {
					ctrlId: this.id,
					links: rightLinks
				});
			}
			// BUILD HOME LINK IF SHOWHOME OK (goes on the left)
			if (this.buildOptions.showHome) {
				ctx.homeLink = _getHtml("tablet", "action", {
					action: "home",
					icon: fontUtils.pageIcon("home"),
					title: locale.text("action.home")
				});
			}
			// BUILD HOME LINK IF SHOWHOME OK (goes on the left)
			if (this.buildOptions.showPageConfig) {
				ctx.configLink = _getHtml("tablet", "action", {
					action: "pageConfig",
					icon: fontUtils.pageIcon("pageConfig"),
					title: locale.text("action.pageConfig")
				});
			}
			// 0 = don't show
			// 1 = show inactive
			// 2 = show active
			if (this.buildOptions.statusPinPage > 0) {
				ctx.pinPage = _getHtml("tablet", "action", {
					action: "pinPage",
					icon: fontUtils.pageIcon("pinPage_" + this.buildOptions.statusPinPage),
					title: locale.text(this.buildOptions.statusPinPage === 1 ? "action.pin" : "action.unpin")
				});
			}
		},

		/**
		 * Page footer can be changed
		 * This method is called each time the footer is toggled
		 */
		notifToggled: function(shown) {
			if (shown === false) {
				if (this._multiSelManager) {
					this._multiSelManager.disable();
				}
				return;
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/ctrlPageFooter',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/controls/page/ctrlFooterBase','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var Base = require('syracuse-tablet/html/js/controls/page/ctrlFooterBase').Klass;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');


/**
 * Page main footer
 */
var _Klass = utils.defineClass(
	function($type, controller, options) {
		Base.call(this, $type, controller, options);
		notifications.subscribe(this, ["sm.page.pin.state.change"]);
	}, Base, {
		// newState
		// 0 = don't show
		// 1 = show inactive
		// 2 = show active
		notifPagePinStateChange: function(newState) {
			var $$root = this.$$elmt.find("[data-action=pinPage]");
			var $$icon = $$root.find("i");
			if ($$icon.length > 0) {
				$$icon.attr("class", fontUtils.pageIcon("pinPage_" + newState));
				$$root.find("span").text(locale.text(newState === 1 ? "action.pin" : "action.unpin"));
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/ctrlVignetteFooter',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/page/ctrlFooterBase'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/page/ctrlFooterBase').Klass;


/**
 * Vignette footer - USed to call action in dashboards
 * Created only for smartphone devices
 */
var _Klass = utils.defineClass(
	function($type, vignette, options) {
		Base.call(this, $type, vignette.controller, options);
		this._vignette = vignette;
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			this._vignette = null;
		},

		checkBuildOptions: function(buildOptions) {
			return {
				showHome: false,
				showPageConfig: false,
				statusPinPage: false,
				multiSelectionOnly: true,
				// To force build
				refresh: true
			};
		},

		getActionController: function() {
			return this._vignette.getPage();
		},

		/**
		 * Called after the footer has been attached
		 * Enable multiselection
		 */
		notifToggled: function(shown) {
			Base.prototype.notifToggled.call(this, shown);
			if (shown === true && this._multiSelManager) {
				this.toggleMultiSelection();
			}
		}

	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/ctrlVignetteHeader',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/page/ctrlHeaderBase'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/page/ctrlHeaderBase').Klass;

/**
 * Header displayed whe a vignette is pinned (action triggering is enabled)
 */
var _Klass = utils.defineClass(

	function($type, vignette, options) {
		Base.call(this, $type, vignette.controller, options);
		this._vignette = vignette;
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			this._vignette = null;
		},

		checkBuildOptions: function(buildOptions) {
			return {
				showHome: false,
				showAuthoring: false,
				showDevelopment: false,
				showUserpanel: false,
				showActionpanel: false,
				multiSelectionOnly: true,
				// To force build
				refresh: true
			};
		},

		getActionController: function() {
			return this._vignette.getPage();
		},

		/**
		 * Called after the header has been attached
		 * Enable multiselection
		 */
		notifToggled: function(shown) {
			Base.prototype.notifToggled.call(this, shown);
			if (shown === true && this._multiSelManager) {
				this.toggleMultiSelection();
			}
		}

	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/sidePanel',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/application/eventListener'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var prototype = require('syracuse-tablet/html/js/helpers/prototype');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');

/**
 * Base left/right panel control for dashBoards and regular pages
 * 	Adapted from Metro Bootstrap navbar-side
 */
var _Klass = utils.defineClass(

	function(controller, $type, panelId, options) {
		this.panelId = panelId;
		this.actionManager = null;
		// Close on click by default
		this.closeBox = options.closeBox === true;
		// Overlap by default
		this.overlap = options.overlap !== false;
		Base.call(this, controller, {
			$bind: this.panelId + "panel"
		}, prototype.create({
			$type: $type
		}), options);
	}, Base, {
		destroy: function() {
			if (this.actionManager) {
				this.actionManager.destroy();
				this.actionManager = null;
			}
			Base.prototype.destroy.call(this);
		},
		/**
		 * Build doesn't attach $$elmt to a parent - see attach/detach
		 */
		buildHtml: function(side) {
			this.side = side;
			Base.prototype.buildHtml.call(this, null, this.controller.dao, {}, [this.typeName]);
			this.$$elmt.hide();
		},
		attach: function($$parent, side) {
			if (this.$$elmt && (this.side != null && side != this.side)) {
				this.$$elmt.remove();
				this.$$elmt = null;
			}
			if (!this.$$elmt) {
				this.buildHtml(side);
			};
			if (this.isAttached()) {
				console.log("sidePanel.attach - Unexpected attached $$elmt");
				this.detach();
			}
			if (!$$parent) return;
			$$parent.append(this.$$elmt);
		},
		isAttached: function(side) {
			return this.$$elmt != null && this.$$elmt.closest(".s-m-panel").length > 0 && this.side == side;
		},
		detach: function() {
			if (!this.$$elmt) return;
			this.$$elmt.detach();
		},
		isEnabled: function() {
			return true;
		},
		/**
		 * Notified by page when toggled
		 */
		notifyToggled: function(side, action, visible) {},
		applyMetaData: function(metaData) {
			//  No meta for this control 
			return;
		},
		onClick: function(evt) {
			this.close();
		},
		// Trigger evt to let page manage the close and all additional actions
		close: function() {
			eventListener.triggerAction(this.$$elmt, "toggleSidePanel", "close," + this.side);
		},
		setActionManager: function(amgr) {
			if (this.actionManager) {
				this.actionManager.destroy();
			}
			this.actionManager = amgr;
		},
		// Returns a deferred
		// .then(function(success, link, data, options) {}).fail(function() {})
		_actActionLink: function(uuid) {
			if (this.actionManager) {
				return this.actionManager.triggerLink(uuid, this.controller).then(function(success, link, data, options) {}).fail(function() {});
			} else {
				return $.smResolve();
			}
		},
		hasLinks: function() {
			throw new Error("Not implemented");
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/actionPanel',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/page/panels/sidePanel','syracuse-tablet/html/js/helpers/hammerScroller','syracuse-tablet/html/js/ui/rect'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/page/panels/sidePanel').Klass;
var HammerScroller = require('syracuse-tablet/html/js/helpers/hammerScroller').Klass;
var uiRect = require('syracuse-tablet/html/js/ui/rect');

var _templates = {
	main: '\
			<nav class="navbar s-m-side-panel {{side}} navbar-inverse ctrl-evt-click" role="navigation">\
				<div class="s-m-scroll-elmt">\
					{{#each items}}\
						{{#if html}}\
							{{#if title}}\
								<div class="container-fluid">\
									<div class="navbar-header">\
										<span class="navbar-brand" href="#"><span>{{title}}</span></a>\
									</div>\
								</div>\
							{{/if}}\
							<ul class="nav navbar-nav">\
								{{{html}}}\
							</ul>\
						{{/if}}\
					{{/each}}\
				</div>\
			</nav>'
};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	if (!tmpl) alert("template " + name + " not found");
	return tmpl(ctx);
};
/**
 * Base left/right panel control for dashBoards and regular pages
 * 	Adapted from Metro Bootstrap navbar-side
 */
var _Klass = utils.defineClass(

	function(controller, $type, panelId, options) {
		// true by default
		this.enableGesture = options.enableGesture !== false;
		Base.call(this, controller, $type, panelId, options);
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},
		buildHtml: function(side) {
			Base.prototype.buildHtml.call(this, side);
			this.$$elmt.addClass(this.typeName);
			var context = {
				ctrlId: this.id,
				side: side
			};
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
			if (this.$$panel) {
				this.$$panel.remove();
			}
			this.$$panel = this.buildPanel(context, side);
			if (this.$$panel && this.$$panel.length) {
				this.$$elmt.append(this.$$panel);
			}
		},
		/**
		 * Override this method to build child class
		 */
		buildPanel: function(context, side) {
			return $(_getHtml("main", context));
		},

		isEnabled: function() {
			return true;
		},
		notifyToggled: function(side, action, visible) {
			if (this.enableGesture && visible) {
				this.updateGesture();
			}
		},
		updateGesture: function() {
			if (this.$$elmt.is(':visible') && this.$$panel) {
				if (!this._gestureMgr) {
					this.$$scrollElmt = this.$$panel.find(".s-m-scroll-elmt");
					this.$$scrollElmt.css({
						height: "auto",
						position: "relative"
					});
					this.$$scrollWrapper = this.$$panel;
					this._gestureMgr = new HammerScroller(this.$$scrollElmt, {
						direction: "v",
						valMax: 0,
						name: this.$bind,
						isPageScroller: false
					});
				}
				var scrollRect = uiRect.elmtRect(this.$$scrollElmt, "outer");
				var wrapperRect = uiRect.elmtRect(this.$$scrollWrapper, "outer");
				var viewRect = wrapperRect.intersectRect(scrollRect);
				if (viewRect && !viewRect.contains(scrollRect)) {
					this._gestureMgr.init(viewRect);
				} else {
					this._gestureMgr.reset();
				}
			} else if (this._gestureMgr) {
				this._gestureMgr.reset();
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/pageActionPanelRegular',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/controls/page/panels/actionPanel','syracuse-tablet/html/js/application/actionManager','syracuse-tablet/html/js/application/multiSelectionMgr','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/page/panels/actionPanel').Klass;
var actionManager = require('syracuse-tablet/html/js/application/actionManager');
var multiSelectionMgr = require('syracuse-tablet/html/js/application/multiSelectionMgr');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var _templates = {
	actionLink: '\
	{{#each links}}\
		<li>\
			<a draggable="false" href="#" class="{{css}}" data-action="actionLink" data-params="{{$uuid}}" data-control-id="{{../ctrlId}}">\
				<i style="font-size: large" class="{{icon}}"/>\
				<span>{{title}}</span>\
			</a>\
		</li>\
	{{/each}}'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

/**
 * Regular page action panel
 */
var _Klass = utils.defineClass(

	function(controller, $type, panelId, options) {
		Base.call(this, controller, $type, panelId, options);
	}, Base, {

		destroy: function() {
			if (this._multiSelManager) {
				this._multiSelManager.destroy();
				this._multiSelManager = null;
			}
			Base.prototype.destroy.call(this);
		},

		buildPanel: function(context, side) {
			if (!this.actionManager) {
				this._createActionManager();
			}
			context.items = [];
			// Top level links - no title
			if (this._smartPhoneMultiselLink()) {
				this._multiSelManager = multiSelectionMgr.create(this.controller);
				var info = this.actionManager.getMultiSelectionLink();
				info.$isAction = true;
				info.$uuid = "togglemultiselection";
				context.items.push({
					title: null,
					html: _getHtml("actionLink", {
						ctrlId: this.id,
						links: [info]
					})
				});
			}
			// Specific additional links
			if (this._smartPhoneBackToQueryLink()) {
				context.items.push({
					title: locale.text("actionpanel.label.links"),
					html: _getHtml("actionLink", {
						ctrlId: this.id,
						links: [this.controller.getProtoLinks("$query").$query]
					})
				});
			}
			// Prototype action links
			if (this._hasActionLinks()) {
				context.items.push({
					title: locale.text("actions"),
					html: _getHtml("actionLink", {
						ctrlId: this.id,
						links: this.actionManager.getLinks()
					})
				});
			}
			return Base.prototype.buildPanel.call(this, context);
		},
		_smartPhoneMultiselLink: function() {
			return globals.isSmartphone() && this.controller.isMultiSelectionEnabled();
		},

		_smartPhoneBackToQueryLink: function() {
			return globals.isSmartphone() && this.controller.prototype.isDetails() && this.controller.getProtoLinks("$query") != null;
		},

		_hasActionLinks: function() {
			return this._createActionManager().hasLinks();
		},

		_actActionLink: function(uuid) {
			this.close("close");
			if (uuid === "togglemultiselection") {
				notifications.publish("sm.panel.multiselection.toggle");
				return;
			} else {
				return Base.prototype._actActionLink.call(this, uuid);
			}
		},
		_createActionManager: function() {
			if (this.actionManager) return this.actionManager;
			this.setActionManager(actionManager.create(this.controller, "actionpanel"));
			return this.actionManager;
		},
		hasLinks: function() {
			return this._hasActionLinks() || this._smartPhoneBackToQueryLink() || this._smartPhoneMultiselLink();
		},
		_actActionNavigation: function(uuid) {
			if (this.actionManager) {
				return this.actionManager.triggerLink(uuid, this.controller).then(function(success, link, data, options) {}).fail(function() {});
			} else {
				return $.smResolve();
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

/**
 * Base tab
 */
var _Klass = utils.defineClass(
	function(panel, id, options) {
		this.id = id;
		this.options = options || {};
		this.panel = panel;
		this.$$tab = this.panel.$$panel.find('[href="#' + id + '"]');
		this.$$tab.on('shown.bs.tab', jsutils.bindFn(this.onTabShown, this));
		this.$$content = this.panel.$$panel.find('#' + this.id);
		this.$$content.on("click", '[data-params]', jsutils.bindFn(this.onTabContentClick, this));
	}, null, {
		destroy: function() {
			this.panel = null;
			utils.unbindObj(this.$$tab);
			this.$$tab = null;
			utils.unbindObj(this.$$content);
			this.$$content = null;
		},
		/**
		 * Hide the tab
		 */
		hide: function() {
			this.$$tab.parent().hide();
			this.$$content.hide();
		},
		setWidth: function(w) {
			this.$$tab.parent().width(w);
		},
		triggerActivate: function() {
			var self = this;
			if (self.$$tab.parent().hasClass("active")) {
				self.onTabShown();
			} else {
				window.setTimeout(function() {
					self.$$tab.tab('show');
				});
			}
		},
		/**
		 * Tab becomes visible
		 */
		onTabShown: function(event) {
			//Calls panel to set active tab
			this.panel.notifyActiveTab(this);
		},
		/**
		 * Build HTML
		 */
		buildHtml: function() {},
		/**
		 * Click on content
		 */
		onTabContentClick: function(evt) {
			evt.preventDefault();
			evt.stopPropagation();
			this.doContentAction(evt, $(evt.target), $(evt.target).attr("data-params"));
		},
		/**
		 * Called when user clicks on an action in tab content
		 * Action is identified by data-param attribute
		 */
		doContentAction: function(evt, $$target, params) {},
		/**
		 * Called when user clicks on Apply button
		 */
		doActionApply: function(evt, $$target) {},
		/**
		 * Panel is resized
		 */
		onResize: function(context) {},
		/**
		 * Panel is opened
		 */
		notifyOpenPanel: function() {},
		/**
		 * Panel is closed
		 */
		notifyClosePanel: function() {}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabSort',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/page/panels/sortfilter/tabBase','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/hammerScroller'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabBase').Klass;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var HammerScroller = require('syracuse-tablet/html/js/helpers/hammerScroller').Klass;

var _templates = {
	main: '\
		<div id="sorttabroot" class="s-m-scroll-wrapper">\
			<ul class="list-group"/>\
		</div>',
	items: '\
		{{#each items}}\
			<li class="list-group-item" data-params="{{id}}">\
				<span>{{name}}</span>\
				<span class="s-m-order ' + fontUtils.sortIcon("desc") + '  {{#smCompare sort "desc"}}enabled{{/smCompare}}" data-params="desc"></span>\
				<span class="s-m-order ' + fontUtils.sortIcon("asc") + '  {{#smCompare sort "asc"}}enabled{{/smCompare}}" data-params="asc"></span>\
			</li>\
		{{/each}}',
	/** Add this line to add the remove icon
	 * <span class="s-m-order ' + fontUtils.sortIcon("none") + ' " data-params="none"></span>
	 */
};


var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};
/**
 * Sort tab
 */
var _Klass = utils.defineClass(
	function(panel, id, options) {
		Base.call(this, panel, id, options);
		options.hidden = options.hidden === true || this.panel.getParentArray().sortInfoGet(false).length === 0;
		if (this._gestureMgr) {
			this._gestureMgr.destroy();
			this._gestureMgr = null;
		}
		this.$$content.append($(_getHtml("main", {})));
		// Create gesture mgr
		this.$$scrollWrapper = this.$$content.find(".s-m-scroll-wrapper");
		this.$$list = this.$$scrollWrapper.find("ul.list-group");
		this.$$list.css({
			height: "auto",
			position: "relative"
		});
		this._gestureMgr = new HammerScroller(this.$$list, {
			direction: "v",
			valMax: 0,
			name: "SORTTAB",
			isPageScroller: false
		});
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},
		/**
		 * Save sort info
		 */
		doActionApply: function(evt, $$target, dataParams) {
			var status = {};
			this.$$content.find(".s-m-order.enabled").each(function(idx, $$e) {
				$$e = $($$e);
				status[$$e.parent().attr("data-params")] = $$e.attr("data-params");
			});
			this.sortInfo.forEach(function(i) {
				i.sort = status[i.id] || "none";
			});
			// Set and refresh - clone to keep a different copy from array one
			this.panel.getParentArray().sortInfoSet($.extend(true, [], this.sortInfo), true);
			return true;
		},
		doContentAction: function(evt, $$target, dataParams) {
			if (dataParams !== "none") {
				// unused because no dataParams="none" icon
				if ($$target.hasClass("enabled")) {
					$$target.removeClass('enabled');
					return;
				}
			}
			(this.options.singleCriteria === true ? this.$$content : $$target.parent()).find(".s-m-order.enabled").removeClass('enabled');
			if (dataParams !== "none") {
				$$target.addClass("enabled");
			}
		},
		onResize: function(context) {
			Base.prototype.onResize.call(this, context);
			if (this.$$content.is(':visible')) {
				this.updateGesture(context);
			}
		},
		updateGesture: function(context) {
			if (!this._gestureMgr) return;
			var wrapperRect = uiRect.elmtRect(this.$$scrollWrapper, "outer");
			var panelRect = uiRect.elmtRect(this.panel.$$elmt, "outer");
			var viewRect = wrapperRect.intersectRect(panelRect);
			if (viewRect && !viewRect.contains(wrapperRect)) {
				this._gestureMgr.init(viewRect);
			} else {
				this._gestureMgr.reset();
			}
		},
		/**
		 * We remove the content on close to cancel modifications
		 */
		notifyClosePanel: function() {
			Base.prototype.notifyClosePanel.call(this);
			if (this.$$items) {
				this.$$items.remove();
				this.$$items = null;
			}
			this.sortInfo = null;
		},
		/**
		 * Tab becomes Active - we create content
		 */
		onTabShown: function() {
			Base.prototype.onTabShown.call(this);
			if (!this.$$items) {
				// We clone to keep a different copy from array one		
				this.sortInfo = $.extend(true, [], this.panel.getParentArray().sortInfoGet());
				this.$$items = $(_getHtml("items", {
					items: this.sortInfo
				}));
				this.$$list.append(this.$$items);
				this.updateGesture();
			}
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/helpers/formController',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/helpers/controller'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var reqProto = require('syracuse-tablet/html/js/helpers/prototype');
var Base = require('syracuse-tablet/html/js/helpers/controller').Klass;

var _createProto = function(protoJson, protoParent, baseUrl) {
	if (!protoParent && baseUrl) {
		protoJson.$baseUrl = baseUrl;
	}
	return reqProto.create(protoJson, protoParent);
};

var _createArticle = function(proto) {
	var article = {
		"$layoutType": "stack",
		"$items": []
	};
	var protoJson = proto.data("$properties");
	Object.keys(protoJson).forEach(function(key) {
		if (!protoJson[key].$isExcluded) {
			article.$items.push({
				"$bind": key
			});
		}
	});
	return article;
};
/**
 * options
 * 		$activity	read by default
 */
var _Klass = utils.defineClass(
	function(id, proto, article, dao, options) {
		if (article == null) {
			article = _createArticle(proto);
		}
		Base.call(this, id, proto, article, options);
		this.setActivity(this.options.$activity);
		this.setDao(dao);
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
		},
		render: function($$parent, opts) {
			if (this.rootLayout == null) {
				this.buildControlsTree();
			}
			var opts = $.extend(opts, {
				afterRender: true
			});
			Base.prototype.render.call(this, $$parent, opts);
		},
		/**
		 * Show element in page - scroll if needed
		 * c is a JQuery elmt or an object with $$elmt property
		 */
		makeVisible: function(c) {
			// TODO - Implement a gestureManager in base controller to allow makeVisible
		}
	});


exports.createProto = _createProto;
exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabFilterEdit',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/formController','syracuse-tablet/html/js/ui/rect','syracuse-tablet/html/js/helpers/hammerScroller','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/application/daoSdata','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/fieldOperators'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var formController = require('syracuse-tablet/html/js/helpers/formController');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var HammerScroller = require('syracuse-tablet/html/js/helpers/hammerScroller').Klass;
var prototype = require('syracuse-tablet/html/js/helpers/prototype');
var daoSdata = require('syracuse-tablet/html/js/application/daoSdata');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');


var _templates = {
	main: '\
		<section id="formtabroot">\
			<div class="s-m-scroll-wrapper">\
				<div id="formtabform"/>\
			</div>\
			<div class="btn-group btn-group-justified" role="group">\
				<a type="button" class="btn btn-default" data-params="cancelFilterEdit">\
					<i class="fa fa-times" data-params="cancelFilterEdit"></i>\
				</a>\
				<a type="button" class="btn btn-default disabled" data-params="submitFilterEdit">\
					<i class="fa fa-check" data-params="submitFilterEdit"></i>\
				</a>\
			</div>\
		</section>'
};


var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

var _buildOperatorsEnum = function(operators) {
	var res = [];
	$.each(operators, function(idx, op) {
		res.push({
			$value: op,
			$title: locale.text("field.operator." + op)
		});
	});
	return res;
};

var FormKlass = utils.defineClass(
	function(proto, dao, gestureMgr, filtersMap, $$formParent) {
		formController.Klass.call(this, utils.readableuid("FILTERFORM"), proto, null, dao, {
			$activity: "edit"
		});
		this.$$formParent = $$formParent;
		this.filtersMap = filtersMap;
		this.gestureMgr = gestureMgr;
		this.addEventListener("change", this.onEvtChange);
		this.addEventListener("blur", this.onEvtBlur);
	}, formController.Klass, {
		destroy: function() {
			formController.Klass.prototype.destroy.call(this);
			this.gestureMgr = null;
		},
		/**
		 * 	when	"before" or "after"
		 * 				"before"	call before calling control event
		 * 					return false 	to continue
		 * 					return true 	to stop the process and not call control's listener
		 * 				"after" 	call after calling control event
		 *	crl		control object
		 */
		onEvtChange: function(when, ctrl, $$target, event) {
			var self = this;
			if (when === "before") {
				var res = false;

				switch (ctrl.$bind) {
					case "FIELDS":

						// nothing to do. user selected "select field" option
						if ($$target.val() == 0) {
							// set button validate disabled
							this._toggleSave(false);
							return;
						} else {
							// set button validate enabled
							this._toggleSave(true);
							var fm = self.filtersMap[$$target.val() - 1];
							// UPDATE OPERATORS CHOICE CTRL & VALUE FIELD TYPE

							// build new enum
							var operators = fm.operators;
							var $newEnum = _buildOperatorsEnum(operators);

							var newData = {
								"$properties": {
									"OPERATORS": {
										"$value": {
											$enum: $newEnum
										},
										$isReadOnly: false
									}
								},
								"OPERATORS": $newEnum[0].$value
							};
							// hide previously displayed value field
							if (self.keyToHide) {
								newData.$properties[self.keyToHide] = {
									$isHidden: true
								};
							}
							// For reference fields, meta-data ($properties) is given by the field that contains the data
							var keyToShow = fm.isReference ? fm.id : "VALUE-" + fm.id;
							newData.$properties[keyToShow] = {
								$isHidden: false
							};

							self.keyToHide = keyToShow;

							// apply change
							window.setTimeout(function() {
								self.applyChange($.extend(true, {}, newData));
							});
						}
						break;
					case "OPERATORS":
						// TODO handle specific operators such as "between", "empty", "not empty"
						break;
				}
				return res;
			}
		},
		onEvtBlur: function(when, ctrl, $$target, event) {
			//TODO ?
		},
		// check that data is set
		validateForm: function() {
			var self = this;
			var res = true;
			this.forEachControl(function(id, ctrl) {
				var bind = ctrl.$bind;
				if (ctrl.prototype.isReference(bind)) {
					// Field that contains the value
					bind = ctrl.prototype.getFieldNameForValue(bind);
				}
				res = (bind === "OPERATORS" || bind !== "FIELDS" || bind !== self.keyToHide) ? res : (ctrl.checkData() ? res : false);
			});
			return res;
		},
		applyChange: function(newData) {
			formController.Klass.prototype.applyChange.call(this, newData);
			this._toggleSave(newData != null && !$.isEmptyObject(newData));
		},
		render: function($$parent, buildOpts) {
			formController.Klass.prototype.render.call(this, $$parent, buildOpts);
			this._toggleSave(false);
		},
		_toggleSave: function(enable) {
			$("a[data-params='submitFilterEdit']", this.$$formParent).toggleClass("disabled", !enable);
		}
	});
/**
 * Filter edit tab
 */
var _Klass = utils.defineClass(
	function(parentTab) {
		this.controller = null;
		if (this._gestureMgr) {
			this._gestureMgr.destroy();
			this._gestureMgr = null;
		}
		this.$$content = $(_getHtml("main", {}));
		// Create gesture mgr
		this.$$scrollWrapper = this.$$content.find(".s-m-scroll-wrapper");
		this.$$ScrollElmt = this.$$scrollWrapper.children("#formtabform");
		this.$$ScrollElmt.css({
			height: "auto",
			position: "relative"
		});
		this._gestureMgr = new HammerScroller(this.$$ScrollElmt, {
			direction: "v",
			valMax: 0,
			name: "FORMTAB",
			isPageScroller: false
		});
		this.parentTab = parentTab;
		this.panel = parentTab.panel;
	}, null, {
		updateGesture: function() {
			if (!this._gestureMgr) return;
			var wrapperRect = uiRect.elmtRect(this.$$scrollWrapper, "outer");
			var panelRect = uiRect.elmtRect(this.panel.$$elmt, "outer");
			var viewRect = wrapperRect.intersectRect(panelRect);
			if (viewRect && !viewRect.contains(wrapperRect)) {
				this._gestureMgr.init(viewRect);
			} else {
				this._gestureMgr.reset();
			}
		},
		/**
		 * Create content
		 */
		create: function($$container) {
			var self = this;

			if (self.$$content.parent().length == 0) {
				$$container.append(self.$$content);
			}

			self.$$ScrollElmt.empty();

			var array = self.panel.getParentArray();

			var protoJson;
			var dataJson;

			var res = self._buildProtoJson();
			protoJson = res.protoJson;
			dataJson = res.dataJson;


			var proto = formController.createProto(protoJson, null, array.prototype.data("$baseUrl"));
			var dao = new daoSdata.Dao($.extend(true, {}, dataJson), proto);

			self.controller = new FormKlass(proto, dao, self._gestureMgr, self.filtersMap, self.$$content);
			self.controller.render(self.$$ScrollElmt, {});
			self.updateGesture();
			if (self.initData) {
				window.setTimeout(function() {
					// Enable save if a filter exists
					self.controller.applyChange($.extend(true, {}, self.initData), true);
					self.controller.keyToHide = self.initKeyToHide;
				});
			}

		},
		_getFiltersMap: function() {
			var self = this;
			self.filtersMap = self.filtersMap || self.panel.getParentArray().filterMapGet();
			return self.filtersMap;
		},
		_buildProtoJson: function() {
			var self = this;

			var choiceData = {};

			self.filtersMap = self._getFiltersMap();

			// init json
			var protoJson = {
				"$properties": {
					"FIELDS": {
						"$title": locale.text("panels.array.filterForm.field"),
						"$type": "application/x-choice",
						"$capabilities": "sort,filter",
						"$value": {
							"$type": "application/x-integer",
							"$enum": []
						},
						"$isMandatory": true
					},
					"OPERATORS": {
						"$title": locale.text("panels.array.filterForm.operator"),
						"$type": "application/x-choice",
						"$capabilities": "sort,filter",
						"$value": {
							"$type": "application/x-string",
							"$enum": []
						},
						"$isReadOnly": true
					}
				},
				$localization: self.panel.getParentArray().prototype.data("$localization")
			};

			for (var ii = 0, jj = self.filtersMap.length; ii < jj; ii++) {

				var ff = self.filtersMap[ii];
				var key = "VALUE-" + ff.id;
				protoJson.$properties[key] = {
					$title: locale.text("panels.array.filterForm.value"),
					$type: ff.prop.$type,
					$isHidden: true,
					$item: ff.prop.$item,
					$value: ff.prop.$value
				};
				if (ff.isReference) {
					protoJson.$properties[ff.prop.$bindValue] = {
						$type: protoJson.$properties[ff.prop.$bindType],
						$isHidden: true,
						$isExcluded: true
					};
				}
				// in case of application/x-choice field, first value must be added to init dao
				if (ff.prop.$type.indexOf("choice") >= 0) {
					choiceData[key] = ff.prop.$value.$enum[0].$value;
				}
			}


			// set fields choice ctrl values
			// protoJson.$properties.FIELDS.$value.$enum
			var $fieldEnum = [];
			$fieldEnum.push({
				$value: 0,
				$title: locale.text("panels.array.filterForm.fieldDefault")
			});
			$.each(self.filtersMap, function(idx, ff) {
				$fieldEnum.push({
					$value: idx + 1,
					$title: ff.fieldName
				});
			});
			protoJson.$properties.FIELDS.$value.$enum = $fieldEnum;

			// set operators choice ctrl default value
			// protoJson.$properties.OPERATORS.$value.$enum
			var $operatorDefEnum = [];
			var operators = fieldOperators.getOperators();
			protoJson.$properties.OPERATORS.$value.$enum = _buildOperatorsEnum(operators);

			var result = {
				protoJson: protoJson,
				dataJson: choiceData
			};


			return result;
		},
		/**
		 * Save sort info
		 */
		doActionApply: function(evt, $$target, dataParams) {
			if (!this.controller) return;
			if (!this.controller.checkControlsData()) {
				globals.getModal().error("Data are invalid");
			} else {
				globals.getModal().info("Data are valid");
			}
		},
		doContentAction: function(evt, $$target, params) {
			var self = this;
			switch (params) {
				case "submitFilterEdit":
					self.onFilterEditSubmit();
					break;
				case "cancelFilterEdit":
					self.onCancelEdit();
					break;
			}
		},
		/*
		 * If user submits filter edit, update filter tab info,
		 */
		onFilterEditSubmit: function() {
			var self = this;
			if (self.controller.validateForm()) {
				// build filterInfo object with the following format
				/* {
					filterMapIdx: 'index in filterMap array',
					fieldName: "fieldName",
					operatorLabel: "operator label",
					value: "value to filter by",
					operator: "filter operator"
					id: "field code",
					prop: "field $value object"
				}
				*/
				self.filtersMap = self._getFiltersMap();
				var dao = self.controller.dao.data;
				var filterMapIdx = parseInt(dao.FIELDS, 10) - 1;
				var operator = dao.OPERATORS;
				var value = dao["VALUE-" + self.filtersMap[filterMapIdx].id];
				var prop = self.filtersMap[filterMapIdx].prop;

				var info = {
					filterMapIdx: filterMapIdx,
					fieldName: self.filtersMap[filterMapIdx].fieldName,
					operatorLabel: locale.text("field.operator." + operator),
					value: self._getValue(prop, value),
					operator: operator,
					id: self.filtersMap[filterMapIdx].id,
					prop: prop,
					originalValue: value,
					isReference: self.filtersMap[filterMapIdx].isReference
				};


				self.filterTab = self.filterTab || self.panel.getTabs().filter;
				self.filterTab.onFilterUpdate(info, !isNaN(parseInt(self.initIdx, 10)) && self.initIdx >= 0 ? self.initIdx : null);

				self._onTabClose();
			}
		},
		/* 	get value to be displayed in filter list (text value)
		 * 	this is particularly useful in case of application/x-choice fields
		 */
		_getValue: function(prop, value) {
			var self = this;
			var vv;
			if (typeof value === 'object') {
				vv = value.$value || value.$description || value.$title;
			} else {
				// in case of application/x-choice item, 
				// value to display should be $title of $enum if $value.$type -> 'application/x-integer'
				// else, value parameter is already ok
				if (prop.$type.indexOf("choice") >= 0) {
					vv = prop.$value.$type.indexOf("integer") >= 0 ? self.controller.prototype.resolveExpression(prop.$value.$enum[parseInt(value - 1, 10)].$title) : value;
				} else {
					vv = value;
				}
			}
			return vv;
		},
		/*
		 * If user cancels filter edit, hide form and show filters list
		 */
		onCancelEdit: function() {
			var self = this;
			self._onTabClose();
			self.parentTab.toggleList(true);
		},
		/*
		* Create init data for that will be used to create the filter edit
		* init data JSON structure is {
			"FIELDS": "index among enum, as a string",
			"OPERATORS": "operator value",
			"VALUE": "filter value"
		}

		info parameter JSON structure is {
			filterMapIdx: 'index in filterMap array',
			fieldName: "fieldName",
			operatorLabel: "operator label",
			value: "value to filter by",
			operator: "filter operator"
			id: "field code",
			prop: "field $value object"
		}
		*/
		setInitData: function(info, initIdx) {
			var self = this;

			self.filtersMap = self._getFiltersMap();

			// get idx
			var filterMapIdx = info.filterMapIdx;
			var ff = self.filtersMap[filterMapIdx];

			// build init data
			self.initData = {
				$properties: {
					OPERATORS: {
						$value: {
							$enum: _buildOperatorsEnum(ff.operators)
						},
						$isReadOnly: false
					}
				},
				FIELDS: filterMapIdx + 1,
				OPERATORS: info.operator
			};

			self.initData["VALUE-" + ff.id] = info.originalValue;
			// For reference fields, meta-data ($properties) is given by the field that contains the data
			var bind = ff.isReference ? ff.id : "VALUE-" + ff.id;

			self.initData.$properties[bind] = {
				$isHidden: false
			};

			self.initIdx = initIdx;

			// bind key will be used by the formController
			self.initKeyToHide = bind;
		},
		/*
		 * Cleaning actions
		 */
		_onTabClose: function() {
			var self = this;
			self.controller.destroy();
			self.controller = null;
			self.initData = null;
			self.initIdx = null;
		},
		destroy: function() {
			if (this.controller) {
				this.controller.destroy();
				this.controller = null;
			}

			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
			this.$$content = null;
			this.$$scrollWrapper = null;
			this.parentTab = null;
			this.panel = null;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabFilter',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/page/panels/sortfilter/tabBase','syracuse-tablet/html/js/controls/page/panels/sortfilter/tabFilterEdit','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabBase').Klass;
var FilterEdit = require('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabFilterEdit').Klass;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _templates = {
	main: '\
		<div class="s-m-scroll-wrapper">\
			<section id="filterlist">\
				<div id="filterListEmpty" style="display:none">{{emptyList}}</div>\
				<ul class="list-group"/>\
				<div class="btn-group btn-group-justified" role="group">\
					<a type="button" class="btn btn-default" data-params="addFilter">\
						<i class="fa fa-plus" data-params="addFilter"></i>\
						<span data-params="addFilter">{{addFilter}}</span>\
					</a>\
				</div>\
			</section>\
			<section id="filteredit">\
			</section>\
		</div>',
	items: '\
		{{#each items}}\
			<li class="list-group-item" data-params="{{id}}">\
				<span class="s-m-filter-info"> \
					<span class="s-m-filter-field">{{fieldName}}</span>\
					<span class="s-m-filter-operator">{{operatorLabel}}</span>\
					<span class="s-m-filter-value">{{value}}</span>\
				</span>\
				<span class="s-m-filter ' + fontUtils.filterIcon("edit") + '" data-params="edit"></span>\
				<span class="s-m-filter ' + fontUtils.filterIcon("delete") + '" data-params="delete"></span>\
			</li>\
		{{/each}}'
};


var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

/**
 * Filter tab
 */
var _Klass = utils.defineClass(

	function(panel, id, options) {
		Base.call(this, panel, id, options);
		this.$$content.append($(_getHtml("main", {
			addFilter: locale.text("panels.array.addFilter"),
			emptyList: locale.text("panels.array.emptyList")
		})));
		this.$$listSection = this.$$content.find("#filterlist");
		this.$$list = this.$$listSection.find(".list-group");
		this.$$editSection = this.$$content.find("#filteredit");
		this.$$emptyList = this.$$content.find("#filterListEmpty");
	}, Base, {
		/**
		 * Tab becomes Active - we create content
		 */
		onTabShown: function() {
			var self = this;
			Base.prototype.onTabShown.call(this);
			if (!self.initOpened) {
				this.updateFilterList();
				self.initOpened = true;
			}

		},
		/**
		 * Update filter list . If no filter set, display no filter information
		 **/
		updateFilterList: function() {
			var self = this;

			self.$$emptyList.toggle(false);

			// clean current list
			self.$$list.empty();

			// We clone to keep a different copy from array one
			self.filterInfo = self.filterInfo || $.extend(true, [], self.panel.getParentArray().filterInfoGet());

			if (self.filterInfo && self.filterInfo.length > 0) {
				// clean
				self.$$list.empty();

				// append list
				var $$items = $(_getHtml("items", {
					items: self.filterInfo
				}));
				self.$$list.append($$items);
			} else {
				// no filter set
				self.$$emptyList.toggle(true);
			}
		},
		/**
		 * Save sort info
		 */
		doActionApply: function(evt, $$target, dataParams) {
			this.panel.getParentArray().filterInfoSet($.extend(true, [], this.filterInfo), true);
			return true;
		},
		/**
		 * Click on an element with data-param - edit delete...
		 */
		doContentAction: function(evt, $$target, dataParams) {
			var self = this;
			switch (dataParams) {
				case "addFilter":
					self._openFilterEdit();
					break;
				case "cancelFilterEdit":
					self.filterEdit.onCancelEdit();
					break;
				case "submitFilterEdit":
					self.filterEdit.onFilterEditSubmit();
					break;
				case "delete":
					var idx = $$target.closest("li").index();
					self._onFilterDelete(idx);
					break;
				case "edit":
					var idx = $$target.closest("li").index();
					self._openFilterEdit(idx);
					break;
				default:
					alert(dataParams);
			}
		},
		/*
		 *	When user deletes one filter in filter list
		 */
		_onFilterDelete: function(idx) {
			var self = this;
			if (self._isIndexValid(idx)) {
				self._removeFilter(idx);
				self.updateFilterList();
			}
		},
		/*
		* Adds new filter info
		* {
			fieldName: "field name",
			operator: "selected operator label",
			value: "filtering value"
		}
		*/
		_addFilter: function(newFilterInfo) {
			var self = this;
			self.filterInfo.push(newFilterInfo);
		},
		/*
		 * Remove filter
		 */
		_removeFilter: function(idx) {
			var self = this;
			if (self._isIndexValid(idx)) {
				self.filterInfo.splice(idx, 1);
			}
		},
		/*
		 * Update filter
		 */
		_updateFilter: function(idx, updateFilterInfo) {
			var self = this;
			if (self._isIndexValid(idx)) {
				self.filterInfo.splice(idx, 1, updateFilterInfo);
			}
		},
		/*
		 * If user cancels filter edit, hide form and show filters list
		 */
		_onCancelEdit: function() {
			var self = this;
			self.$$editSection.empty();
			self.$$listSection.toggle(true);
		},
		/*Build filter set/add form */
		_openFilterEdit: function(filterIdx) {
			var self = this;

			// get filter edit object
			self.filterEdit = self.filterEdit || new FilterEdit(self);

			// set init data
			if (self._isIndexValid(filterIdx)) {
				self.filterEdit.setInitData(self.filterInfo[filterIdx], filterIdx);
			}

			// create filter edit content
			self.filterEdit.create(self.$$editSection);

			// hide filter list
			self.toggleList(false);

		},
		_isIndexValid: function(idx) {
			return !isNaN(parseInt(idx, 10)) && idx >= 0;
		},
		onFilterUpdate: function(filterInfo, filterIdx) {
			var self = this;

			if (self._isIndexValid(filterIdx)) {
				self._updateFilter(filterIdx, filterInfo);
			} else {
				self._addFilter(filterInfo);
			}

			// update list
			self.updateFilterList();

			// show list
			self.toggleList(true);
		},
		toggleList: function(show) {
			var self = this;
			self.$$listSection.toggle(show);
			if (self.filterEdit) {
				self.filterEdit.$$content.toggle(!show);
			}
		},
		destroy: function() {
			var self = this;
			if (self.filterEdit) {
				self.filterEdit.destroy();
				self.filterEdit = null;
			}
			self.filterInfo = null;
			Base.prototype.destroy.call(self);
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/sortfilter/filterSortPanel',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/controls/page/panels/sidePanel','syracuse-tablet/html/js/controls/page/panels/sortfilter/tabSort','syracuse-tablet/html/js/controls/page/panels/sortfilter/tabFilter','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var Base = require('syracuse-tablet/html/js/controls/page/panels/sidePanel').Klass;
var _Sort = require('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabSort').Klass;
var _Filter = require('syracuse-tablet/html/js/controls/page/panels/sortfilter/tabFilter').Klass;
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _templates = {
	main: '\
		<section class="s-m-side-panel {{side}}">\
			<ul class="nav nav-pills" role="tablist"> \
				{{#each tabs}}\
					<li><a href="#{{id}}" role="tab" data-toggle="tab">{{title}}</a></li> \
				{{/each}}\
			</ul> \
			<div class="tab-content">\
				<header>{{title}}</header>\
				<div class="btn-group btn-group-justified" role="group">\
				  <a type="button" class="btn btn-default" data-params="apply">{{apply}}</a>\
				  <a type="button" class="btn btn-default" data-params="close">{{close}}</a>\
				</div>\
				{{#each tabs}}\
					<div id="{{id}}" role="tabpanel" class="tab-pane {{type}}"/> \
				{{/each}}\
			</div> \
		</section>',
};


var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

var _tabDescr = [{
	klass: _Sort,
	options: {
		name: "sort",
		isActive: true,
		singleCriteria: true
	}
}, {
	klass: _Filter,
	options: {
		name: "filter",
		isActive: false
	}
}];

/**
 * Arrays Sort/Filter panel
 * Options
 * 		parentArray: 	parent array control
		filter: 		false to hide filter tab
		sort: 			false to hide sort tab
 */
var _Klass = utils.defineClass(
	function(controller, $type, panelId, options) {
		this._tabs = {};
		Base.call(this, controller, $type, panelId, options);
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this._activeTab = null;
			this.options.parentArray = null;
			if (this._tabs) {
				$.each(this._tabs, function(key, value) {
					value.destroy();
				});
				this._tabs = null;
			}
			if (this.$$btnBar) {
				utils.unbindObj(this.$$btnBar);
				this.$$btnBar = null;
			}
		},
		getParentArray: function() {
			return this.options.parentArray;
		},
		/**
		 * Build panel and tabs html
		 */
		buildHtml: function(side) {
			var self = this;
			Base.prototype.buildHtml.call(this, side);
			self.$$elmt.addClass(self.typeName);
			if (self.$$panel) {
				self.$$panel.remove();
			}
			var ctx = {
				ctrlId: self.id,
				side: side,
				apply: locale.text("panels.array.apply"),
				close: locale.text("panels.array.close"),
				/* There's no titles for queries*/
				title: this.getParentArray().getTitle(),
				tabs: [],
			};
			var descriptions = [];
			/**
			 * We can disable filter or sort with self.options.filter = false or  self.options.sort
			 */
			_tabDescr.forEach(function(descr) {
				descr = $.extend({}, descr);
				descr.options.hidden = self.options[descr.options.name] === false;
				descriptions.push(descr);
			});
			var ids = {};
			descriptions.forEach(function(descr) {
				ids[descr.options.name] = utils.readableuid("array" + descr.options.name);
				ctx.tabs.push({
					id: ids[descr.options.name],
					title: descr.title || locale.text("panels.array." + descr.options.name),
					type: descr.options.name
				});
			});
			self.$$panel = $(_getHtml("main", ctx));
			if (self.$$panel && self.$$panel.length) {
				self.$$elmt.append(self.$$panel);
				var visibleTabs = [];
				var activeIdx = -1;
				// Create tabs
				descriptions.forEach(function(descr, idx) {
					var t = new descr.klass(self, ids[descr.options.name], descr.options);
					if (descr.options.hidden) {
						t.hide();
					} else {
						visibleTabs.push(t);
						if (descr.options.isActive) {
							activeIdx = idx;
						}
					}
					self._tabs[descr.options.name] = t;
				});
				if (visibleTabs.length > 0) {
					this._activeTab = visibleTabs[activeIdx === -1 ? 0 : activeIdx];
					// Adjust width
					var width = visibleTabs.length === 1 ? "100%" : Math.round(1000 * 100 / visibleTabs.length) / 1000 + "%";
					visibleTabs.forEach(function(t) {
						t.setWidth(width);
					});
					self.$$btnBar = self.$$panel.find('.tab-content > .btn-group');
					self.$$btnBar.on('click', '[data-params]', jsutils.bindFn(self.onBtnBarClick, this));
				} else {
					this.close();
				}
			}
		},
		/**
		 * Notification when panel is opened/closed
		 * Pass event to tabs
		 */
		notifyToggled: function(side, action, visible) {
			Base.prototype.notifyToggled.call(this, side, action, visible);
			$.each(this._tabs, function(id, tab) {
				tab[visible ? "notifyOpenPanel" : "notifyClosePanel"]();
			});
			if (visible && this._activeTab) {
				this._activeTab.triggerActivate();
			}
		},
		onResize: function(context) {
			$.each(this._tabs, function(id, tab) {
				tab.onResize(context);
			});
		},
		onBtnBarClick: function(evt) {
			evt.preventDefault();
			evt.stopPropagation();
			var $$target = $(evt.target);
			var params = $$target.attr("data-params");
			switch (params) {
				case "apply":
					if (this._activeTab && this._activeTab.doActionApply(evt, $$target) === true) {
						this.close();
					}
					break;
				case "close":
					this.close();
					break;
			}
		},
		notifyActiveTab: function(tab) {
			this._activeTab = tab;
		},
		/*
		 *	Returns panel tabs
		 */
		getTabs: function() {
			return this._tabs;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/page/panels/userpanelsmartphone',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/page/panels/actionPanel','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/application/eventListener','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/page/panels/actionPanel').Klass;
var globals = require('syracuse-tablet/html/js/helpers/globals');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var _templates = {
	navigLink: '<li class="">\
		<a draggable="false"  href="#" data-action="{{action}}" data-params="{{params}}" data-control-id="{{ctrlId}}">\
			<i class="{{icon}}"></i>\
			&nbsp;\
			<span>{{title}}</span>\
		</a>\
	</li>'
};

// TODO
var _panelLinks = {
	home: {
		label: "header.sm.links.home",
		icon: "home",
		action: "gotoWelcomeApplication",
		target: "application"
	},
	switchContext: {
		label: "header.sm.links.switchContext",
		icon: "switchContext",
		params: "switchContext",
		action: "linkClicked",
		target: "panel"
	},
	clearCache: {
		label: "header.sm.links.settings",
		icon: "settings",
		action: "linkClicked",
		params: "settings",
		target: "panel"
	},
	about: {
		label: "header.sm.links.about",
		icon: "about",
		action: "linkClicked",
		params: "about",
		target: "panel"
	},
	logout: {
		label: "header.sm.links.logout",
		icon: "logout",
		action: "logout",
		target: "application"
	},
	development: {
		label: "header.links.development",
		icon: "developmentPage",
		action: "developmentPage",
		target: "application"
	},
	pinPage: {
		label: "",
		icon: "",
		action: "pinPage",
		target: "application"
	},
	pageConfig: {
		label: "page.configure.btn",
		icon: "pageConfig",
		action: "pageConfig",
		target: "application"
	}
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

/**
 * Regular page left panel
 */
var _Klass = utils.defineClass(

	function(controller, $type, panelId, options) {
		// Just to test this mode that pushs the content
		options.overlap = false;
		Base.call(this, controller, $type, panelId, options);
		notifications.subscribe(this, ["sm.page.pin.state.change"]);
		this._initPanelItems(controller);
	}, Base, {

		buildPanel: function(context, side) {
			var self = this;
			var actionsHtml = [];
			var keys = Object.keys(self._panelLinks);
			keys.forEach(function(kk, idx) {
				var link = self._panelLinks[kk];
				if (link.hidden !== true) {
					actionsHtml.push(_getHtml("navigLink", {
						title: locale.text(link.label),
						action: link.action || "",
						params: link.params || "",
						icon: fontUtils.pageIcon(link.icon),
						ctrlId: link.target === "panel" ? self.id : null
					}));
				}
			});
			context.items = [{
				title: globals.getUserName(),
				html: actionsHtml.join('')
			}];
			return Base.prototype.buildPanel.call(self, context, side);
		},

		_initPanelItems: function(page) {
			var toolBars = page.buildOpts && page.buildOpts.toolBars || {};
			this._panelLinks = $.extend(true, {}, _panelLinks);
			this._panelLinks["development"].hidden = !toolBars.showDevelopment;
			this._panelLinks["home"].hidden = !toolBars.showHome;
			this._panelLinks["pageConfig"].hidden = !toolBars.showPageConfig;
			var pinPage = this._panelLinks["pinPage"];
			switch (toolBars.statusPinPage) {
				case 1:
					pinPage.label = "pin.page.panel.label.pin";
					pinPage.hidden = false;
					pinPage.icon = "pinPage_1";
					break;
				case 2:
					pinPage.label = "pin.page.panel.label.unpin";
					pinPage.hidden = false;
					pinPage.icon = "pinPage_2";
					break;
				default:
					pinPage.hidden = true;
					break;
			}
		},

		_actLinkClicked: function(actionName) {
			/* triggering action */
			eventListener.triggerAction(this.$$elmt, actionName);
		},

		// newState
		// 0 = don't show
		// 1 = show inactive
		// 2 = show active
		notifPagePinStateChange: function(newState) {
			var $$icon = this.$$elmt.find("[data-action=pinPage] i");
			if ($$icon.length > 0) {
				$$icon.attr("class", fontUtils.pageIcon("pinPage_" + newState));
			}
			var $$text = this.$$elmt.find("[data-action=pinPage] span");
			if ($$text.length > 0) {
				var text;
				if (newState != 2) {
					text = locale.text("pin.page.panel.label.pin");
				} else {
					text = locale.text("pin.page.panel.label.unpin");
				}

				$$text.text(text);
			}
		},
		hasLinks: function() {
			return true;
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/ctrlTypeUnknown',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/ctrlBase'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;

/**
 * Base class for controls that display exactly one value/property
 */
var _Klass = utils.defineClass(

	function CtrlTypeUnknown(controller, article, prototype) {
		Base.call(this, controller, article, prototype);
	}, Base, {
		buildHtml: function($$parent, controllerDao, buildOptions) {
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions, ["s-m-unknown"]);
			this.$$elmt.html('<div class="s-m-value">Field ' + this.$bind + ' - Unknown type: ' + this.$type + '</div>');
		}
	}
);

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/ctrlUnfound',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/ctrlBase'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;

/**
 * Unfound fields in prototype
 */
var _Klass = utils.defineClass(

	function CtrlUnfound(controller, article, prototype) {
		Base.call(this, controller, article, prototype);
	}, Base, {
		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions, ["s-m-unfound"]);
			self.$$elmt.html('<div class="s-m-value">Field <b>' + self.$bind + '</b> unfound</div>');
		}
	}
);

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/chart/ctrlCubeChartTheme',['require','exports','module'],function (require, exports, module) {

var theme = {
	//colors: ['#007f64', '#34b233', '#4d4f53', '#9a9b9c', '#ff5800', '#009fda', '#6639b7' /*green brightgreen darkgrey midgray orange blue purple*/ , '#409f8b', '#67c566', '#7a7b7e', '#b3b4b5', '#ff8240', '#40b7e3', '#8c6bc9', /*75%*/ /*'#7fbfb1','#99d899','#a6a7a9','#cccdcd','#ffab7f','#7fcfec','#b29cdb',50%*/ ],
	colors: ['#BF7070', '#BFB730', '#7ABF30', '#7373FF', '#BF7730', '#BF3080', '#30BF9F', '#FF7373', '#FFF773', '#85FF00', '#3030BF', '#FF9F40', '#FF40BC', '#1699A6', '#FF0000', '#FFF100', '#00FF00', '#0000FF', '#FF7F00', '#FF00A6', '#00FFC6', '#A60000', '#A69C00', '#56A600', '#90B2FF', '#A65200', '#A6006C', '#00A681', '#FF4040', '#FFF440', '#A3FF40', '#3673FF', '#FFB873', '#FF76CE', '#73FFED'],
	chart: {
		borderRadius: '0',
		spacingTop: 10,
		backgroundColor: '#fff',
		borderColor: '#ccc',
		borderWidth: 1,
		className: 'dark-container',
		// backgroundColor: {
		//	linearGradient: [250, 250, 250, 400],
		// 	stops: [
		// 		[0, 'rgb(250, 250, 250)'],
		// 		[1, 'rgb(240, 240, 240)']
		// 	]
		// },
		resetZoomButton: {
			theme: {
				fill: 'white',
				stroke: '#dddddd',
				r: 0,
				states: {
					hover: {
						fill: '#00a1de',
						style: {
							color: 'white'
						}
					}
				}
			},
			position: {
				// align: 'right', // by default
				// verticalAlign: 'top', // by default
				x: -50,
				y: 5
			},
			relativeTo: 'chart'
		}
	},
	title: {
		style: {
			color: '#464646',
			font: 'bold 16px "Trebuchet MS", Verdana, sans-serif'
		}
	},
	subtitle: {
		style: {
			color: '#464646',
			font: 'bold 12px "Trebuchet MS", Verdana, sans-serif'
		}
	},
	xAxis: {
		gridLineColor: 'rgba(0, 0, 0, 0.05)',
		gridLineDashStyle: 'longdash',
		gridLineWidth: 1,
		labels: {
			style: {
				color: '#A0A0A0'
			}
		},
		lineColor: 'rgba(0, 0, 0, 0.2)',
		tickColor: 'rgba(0, 0, 0, 0.2)',
		title: {
			style: {
				color: '#464646',
				fontWeight: 'normal',
				fontSize: '20px',
				fontFamily: 'arial',
			}
		}
	},
	yAxis: {
		minorGridLineColor: 'rgba(0, 0, 0, 0.05)',
		minorTickInterval: 'auto',
		/*alternateGridColor: 'rgba(0, 0, 0, 0.02)',*/
		gridLineWidth: 2,
		gridLineColor: 'rgba(0, 0, 0, 0.07)',
		labels: {
			align: 'left',
			x: 0,
			y: 12,
			style: {
				color: '#A0A0A0'
			}
		},
		lineColor: 'rgba(0, 0, 0, 0.07)',
		/*minorTickInterval: null,*/

		title: {
			style: {
				color: '#CCC',
				fontSize: '16px',
				fontFamily: 'Georgia, Verdana, sans-serif',
				fontStyle: 'italic',
			}
		}
	},
	tooltip: { /*backgroundColor: 'rgba(250,250, 250, 0.75)',*/
		backgroundColor: '#464646',
		borderRadius: '0',
		style: {
			color: '#fff',
			/*fontFamily: '"georgia"',
			fontStyle: 'italic',*/
			fontSize: '12px',
			padding: '5px',
			whiteSpace: 'nowrap',

		}
	},
	toolbar: {
		itemStyle: {
			color: 'silver'
		}
	},
	plotOptions: {
		series: {
			marker: { /*	fillColor: '#FFFFFF',*/
				lineWidth: 2,
				lineColor: null,
				// inherit from series,
				radius: 4,
				states: {
					hover: {
						radius: 8,
						lineColor: null,
					}
				}
			}
		},
		area: {
			fillOpacity: 0.15

		},
		areaspline: {
			fillOpacity: 0.15
		},
		line: {
			dataLabels: {
				color: '#CCC'
			},
			marker: {
				lineColor: '#FFFFFF',
			}
		},
		spline: {
			marker: {
				lineColor: '#FFFFFF',
			}
		},
		scatter: {
			marker: {
				lineColor: '#FFFFFF'
			}
		},
		candlestick: {
			lineColor: '#FFFFFF',
			animation: {
				duration: 2000,
				easing: 'easeOutBounce'
			}
		},
		pie: {
			allowPointSelect: true,
			cursor: 'pointer',
			borderColor: 'rgba(250,250,250,0.3)',
			borderWidth: 0.5,
			dataLabels: {
				enabled: true,
				connectorWidth: 2,
				color: '#464646',
				style: {
					fontWeight: 'bold'
				}
			},
		},

	},
	legend: {
		borderRadius: 0,
		borderWidth: 1,
		// borderColor: '#dddddd',
		backgroundColor: 'white',
		//shadow: true,
		itemMarginTop: 8,
		itemStyle: {
			color: '#464646',
			fontFamily: '"arial"',
			fontWeight: 'bold',
			/*fontStyle: 'italic',*/
			fontSize: '8pt ',
		},
		itemHoverStyle: {
			color: '#00a1de'
		},
		itemHiddenStyle: {
			color: '#555'
		},
		title: {
			style: {
				color: '#464646',
				fontWeight: 'bold',
				fontSize: '8pt',
				fontFamily: 'arial',
			}
		}
	},
	credits: {
		enabled: false,
		style: {
			color: '#666'
		}
	},
	labels: {
		style: {
			color: '#CCC'
		}
	},

	exporting: {
		buttons: {
			drillUp: {
				symbolStroke: '#fff',
				symbolFill: 'rgba(250,250,250,0.5)',
				hoverSymbolStroke: '#fff',
				hoverSymbolFill: 'rgba(250,250,250,0.5)',

			},
			exportButton: {
				symbolStroke: '#fff',
				symbolFill: 'rgba(250,250,250,0.5)',
				hoverSymbolStroke: '#fff',
				hoverSymbolFill: 'rgba(250,250,250,0.5)',

			},
			printButton: {
				symbolStroke: '#fff',
				symbolFill: 'rgba(250,250,250,0.5)',
				hoverSymbolStroke: '#fff',
				hoverSymbolFill: 'rgba(250,250,250,0.5)',
			}
		}
	},

	// scroll charts
	rangeSelector: {
		buttonTheme: {
			fill: {
				linearGradient: [0, 0, 0, 20],
				stops: [
					[0.4, '#888'],
					[0.6, '#555']
				]
			},
			stroke: '#000000',
			style: {
				color: '#CCC',
				fontWeight: 'bold'
			},
			states: {
				hover: {
					fill: {
						linearGradient: [0, 0, 0, 20],
						stops: [
							[0.4, '#BBB'],
							[0.6, '#888']
						]
					},
					stroke: '#000000',
					style: {
						color: 'white'
					}
				},
				select: {
					fill: {
						linearGradient: [0, 0, 0, 20],
						stops: [
							[0.1, '#000'],
							[0.3, '#333']
						]
					},
					stroke: '#000000',
					style: {
						color: 'yellow'
					}
				}
			}
		},
		inputStyle: {
			backgroundColor: '#333',
			color: 'silver'
		},
		labelStyle: {
			color: 'silver'
		}
	},

	navigator: {
		handles: {
			backgroundColor: '#666',
			borderColor: '#AAA'
		},
		outlineColor: '#CCC',
		maskFill: 'rgba(16, 16, 16, 0.5)',
		series: {
			color: '#7798BF',
			lineColor: '#A6C7ED'
		}
	},

	scrollbar: {
		barBackgroundColor: {
			linearGradient: [0, 0, 0, 20],
			stops: [
				[0.4, '#888'],
				[0.6, '#555']
			]
		},
		barBorderColor: '#CCC',
		buttonArrowColor: '#CCC',
		buttonBackgroundColor: {
			linearGradient: [0, 0, 0, 20],
			stops: [
				[0.4, '#888'],
				[0.6, '#555']
			]
		},
		buttonBorderColor: '#CCC',
		rifleColor: '#FFF',
		trackBackgroundColor: {
			linearGradient: [0, 0, 0, 10],
			stops: [
				[0, '#000'],
				[1, '#333']
			]
		},
		trackBorderColor: '#666'
	},

	// special colors for some of the
	legendBackgroundColor: 'rgba(0, 0, 0, 0.5)',
	legendBackgroundColorSolid: 'rgb(35, 35, 70)',
	dataLabelsColor: '#444',
	textColor: '#C0C0C0',
	maskColor: 'rgba(255,255,255,0.3)'
};

var colors = theme.colors;

// Options for Org chart view
theme.orgChart = {
	node: {
		textColor: 'black ',
		borderColor: colors[1],
		borderWidth: 2,
		backgroundColor: 'white ',
		fontWeight: 'normal ',
		hover: {
			backgroundColor: colors[3],
			textColor: 'white '
		}
	},
	junction: {
		lineColor: colors[3],
		lineWidth: 2
	},
	dropMarker: {
		borderColor: colors[1],
		borderWidth: 0,
		backgroundColor: colors[4],
		backgroundOpacity: 1
	},
	tooltip: {
		backgroundColor: colors[1],
		backgroundOpacity: 1,
		borderWidth: 2,
		borderRadius: 0,
		borderColor: colors[2],
		style: {
			color: '#fff',
			/*fontFamily: '"georgia"',
			fontStyle: 'italic',*/
			fontSize: '12px',
			padding: '5px',
			whiteSpace: 'nowrap',
		}
	}
};

theme.version = Highcharts.version.split(".").map(function(e) {
	return parseInt(e, 10);
});

if (theme.version[0] === 2) {
	// theme.navigation = {
	// 	buttonOptions: {
	// 		borderRadius: 50,
	// 		height: 24,
	// 		width: 24,
	// 		backgroundColor: '#00acec',
	// 		borderColor: '#00a1de',
	// 		symbolX: 12,
	// 		symbolY: 12,
	// 	}
	// },
} else if (theme.version[0] === 3) {
	theme.navigation = {
		buttonOptions: {
			symbolStroke: '#DDDDDD',
			hoverSymbolStroke: '#FFFFFF',
			theme: {
				fill: {
					linearGradient: {
						x1: 0,
						y1: 0,
						x2: 0,
						y2: 1
					},
					stops: [
						[0.4, '#606060'],
						[0.6, '#333333']
					]
				},
				stroke: '#000000'
			}
		}
	};

	delete theme.exporting;
}

exports.theme = theme;
});

define('syracuse-tablet/html/js/controls/chart/ctrlCubeChartBase',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/controls/chart/ctrlCubeChartTheme','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var theme = require('syracuse-tablet/html/js/controls/chart/ctrlCubeChartTheme').theme;
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _merge = Highcharts.merge;
var objectClone = function(o) {
	return $.extend({}, o);
};

Highcharts.theme = theme;
Highcharts.setOptions(Highcharts.theme);

var colors = Highcharts.theme.colors;

var _style = function($style) {
	var map = {
		xy: "line",
		point: "scatter",
		stick: "column",
		radar: "spiderweb"
	};

	return $style && (map[$style] || $style);
};

function _isCubeValid(cube, proto) {
	return !!(cube && cube.$hierarchies && proto.$axes && proto.$axes.length > 0 && //
		proto.$axes[0].$hierarchies && proto.$axes[0].$hierarchies.length > 0);
}
/**
 * cube chart control class
 *
 * article:
 * $isLegendHidden: true/false
 * $isXLabelHidden: true/false
 * $isYLabelHidden: true/false
 * $isXLabelsHidden: true/false
 * $isYLabelsHidden: true/false
 * $style: line, spline, area, areaspline, bar, stick, pie
 */
var _Klass = utils.defineClass(function(controller, article, prototype, options) {
	var self = this;
	Base.call(self, controller, article, prototype, options);
	self.itemProto = prototype.getPrototype("$item");
}, Base, {
	_mergeMetaData: function(metadata) {
		var m = {};
		if (metadata && metadata.$cube) m.$cube = metadata.$cube;
		if (metadata && metadata.$axes) m.$axes = metadata.$axes;
		if (metadata && metadata.$style) m.$style = metadata.$style;
		if (metadata && metadata.$color) m.$color = metadata.$color;
		if (metadata && metadata.$isLegendHidden) m.$isLegendHidden = metadata.$isLegendHidden;
		if (metadata && metadata.$isXLabelHidden) m.$isXLabelHidden = metadata.$isXLabelHidden;
		if (metadata && metadata.$isYLabelHidden) m.$isYLabelHidden = metadata.$isYLabelHidden;
		if (metadata && metadata.$isXLabelsHidden) m.$isXLabelsHidden = metadata.$isXLabelsHidden;
		if (metadata && metadata.$isYLabelsHidden) m.$isYLabelsHidden = metadata.$isYLabelsHidden;
		this.currentMetaData = _merge(this.currentMetaData || {}, m);

		if (metadata && metadata.$item && metadata.$item.$properties && this.currentMetaData && this.currentMetaData.$cube && this.currentMetaData.$cube.$measures) {
			$.smForEachKey(this.currentMetaData.$cube.$measures, function(key, m) {
				if (metadata.$item.$properties[key] && metadata.$item.$properties[key].$title) {
					m.$title = metadata.$item.$properties[key].$title;
				} else {
					m.$title = key;
				}
			});
		}

		return this.currentMetaData;
	},

	_settingsFromValue: function() {
		var self = this,
			$cube = this.currentMetaData.$cube,
			icolor = 0,
			settings;

		if ($cube.$style === "spiderweb") {
			settings = {};
			settings.categories = Object.keys(self._meta.series).map(function(key) {
				return self._meta.series[key].options.name;
			});

			settings.series = {};
			self.dataset && self.dataset.reduce(function(res, current) {
				var serie = {
					name: self._getMeasureLabel(current, self._meta.xAxis[0].code),
					color: colors[icolor++],
					data: [],
					pointPlacement: 'on'
				};
				if (serie.name) {
					serie.id = "#s-" + serie.name;
					$.smForEachKey(self._meta.series, function(key, s) {
						if (!s.isHidden) self._pushData(serie, key, key, current);
					});
					res.series[serie.name] = serie;
				}
				return res;
			}, settings);
		} else {
			settings = {
				categories: [],
				series: {}
			};
			self.dataset && self.dataset.reduce(function(res, current) {
				var categoryName = self._getMeasureLabel(current, self._meta.xAxis[0].code);
				if (categoryName != null) {
					res.categories.push(categoryName);
					$.smForEachKey(self._meta.series, function(key, s) {
						var serie = res.series[key];
						if (!serie) {
							serie = objectClone(s.options);
							serie.data = [];
							res.series[key] = serie;
						}
						self._pushData(serie, categoryName, key, current);
					});
				}
				return res;
			}, settings);
		}
		return settings;
	},

	_pushData: function(serie, categoryName, key, data) {
		var val = parseFloat(data.$rawV && data.$rawV[key] && data.$rawV[key].v || data[key]) || 0;
		if (this.useLogarithmicAxis) {
			this.maxValue = Math.max(this.maxValue || -Infinity, val);
			this.minValue = Math.min(this.maxValue || Infinity, val);
		}
		serie.data.push([categoryName, val]);
	},

	_createChart: function(settings) {
		var self = this,
			options = _merge(self._getPref(), self._getOptions(self.$prototype));

		if (settings) {
			options.xAxis[0].categories = settings.categories;
			$.smForEachKey(settings.series, function(key, s) {
				var serie = objectClone(s),
					serieMeta = self._meta.series[key];
				if (options.chart.polar && serie && serie.type) {
					delete serie.type;
				}
				if (!(serieMeta && serieMeta.isHidden)) {
					options.series.push(serie);
				}
			});
		} else {
			$.smForEachKey(self._meta.series, function(key, s) {
				var serie = objectClone(s.options);
				if (options.chart.polar && serie && serie.type) {
					delete serie.type;
				}
				serie.data = [0];
				if (!s.isHidden) {
					options.series.push(serie);
				}
			});
		}
		if (!(self.$prototype.$cube && self.$prototype.$cube.$style == "spiderweb")) {
			options.series.reverse();
		}
		if (this.useLogarithmicAxis) {
			if ((this.maxValue || 0) / (this.minValue || 1) > 10) {
				options.yAxis.type = 'logarithmic';
			}
		}
		self._chart = new Highcharts.Chart(options);

		var legend = this._chart.legend;
		self.displayLegend = legend && legend.display;

		var chartSeries = self._chart.series,
			serie, serieMeta;
		for (var j = chartSeries.length - 1; j >= 0; j--) {
			serie = chartSeries[j];
			serieMeta = serie && serie.options.id && self._meta.series[serie.options.id.slice(3)];
			if (serieMeta && serieMeta.measure) {
				serieMeta.measure.$color = serieMeta.options.color = serie.color;
			}
		}
	},

	_getOptions: function(proto) {
		var self = this,
			$cube = this.currentMetaData.$cube,
			defOptions = Highcharts.getOptions(),
			buttons = defOptions.exporting.buttons,
			measuresTitle = this._getFieldEvalTitle(),
			axe = proto.$axes && proto.$axes[0] || {},
			axeTitle = axe.$hierarchies && measuresTitle[axe.$hierarchies[0][0]] || axe.$title,
			enuml;
		var options = {
			chart: {
				renderTo: this.$$chartSlot.get(0),
				zoomType: 'x',
				ignoreHiddenSeries: false,
				width: 50,
				height: 50
			},
			lang: {
				showHideLegend: self._localize.highCharts_showHideLegend
			},

			legend: {
				layout: 'vertical',
				align: 'right',
				verticalAlign: 'top',
				y: 60,
				x: -10,
				title: {
					text: ':::: ' + self._localize.highCharts_seriesTitle,
				},
				floating: true,
				draggable: true,
				zIndex: 20,
				enabled: !(this.currentMetaData.$isLegendHidden === true)
			},
			title: {
				text: ($cube && self._localizedText($cube.$title)) || '',
				margin: 5
			},
			xAxis: [{
				categories: [],
				title: {
					text: self._localizedText(axeTitle),
					enabled: !(this.currentMetaData.$isXLabelHidden === true)
				},
				labels: {
					rotation: -45,
					align: 'right',
					enabled: !(this.currentMetaData.$isXLabelsHidden === true)
				}
			}],

			yAxis: [{
				title: {
					text: '',
					enabled: !(this.currentMetaData.$isYLabelHidden === true)
				},
				labels: {
					align: 'right',
					enabled: !(this.currentMetaData.$isYLabelsHidden === true)
				}
			}],

			plotOptions: {
				series: {
					cursor: 'pointer',
					events: {},
					point: {
						events: {
							click: function(event) {

							}
						}
					},
					stacking: self._meta.stacking,
					animation: false
				}
			},

			tooltip: {
				formatter: function() {
					var seriesMeta = self._meta.series,
						serie = this.key && seriesMeta[this.key] || seriesMeta[this.series.options.id.slice(3)],
						measure = serie && serie.measure,
						data = this.series.processedYData,
						y = this.y;

					if (measure) {
						self._ensureFormatter(measure);
					}
					var label = this.series.name || measure && measure.$title,
						mformat = measure && measure.formatter;
					label = (label ? label + "<br>" : "") + (this.x || this.key) + ': <b> ' + (mformat ? mformat.format(y) : y) + '</b>';
					if (measure && (measure.$isNormalized) && data.length > 0) {
						var sum = data.reduce(function(a, b) {
							return a + b;
						});
						label += ' (' + (mformat ? mformat.formatValue(y / sum * 100) : y / sum * 100) + '%)';
					}

					return label;
				}
			},

			series: [],
		};
		if (Highcharts.theme.version[0] === 3) {
			// For Highcarts 3.0.0
			options.exporting = {
				type: 'image/png',
				url: 'http://export.highcharts.com/',
				buttons: {
					contextButton: { // docs
						//x: -10, // docs: x is different now
						symbol: 'menu',
						enabled: false,
						_titleKey: 'contextButtonTitle',
						menuItems: [{
							textKey: 'showHideLegend',
							onclick: function() {
								setTimeout(function() {
									self._toggleLegendDisplay();
								}, 100);
							}
						}]
					},
					legendButton: {
						enabled: false,
						textKey: 'showHideLegend',
						symbol: 'menu',
						onclick: function() {
							setTimeout(function() {
								self._toggleLegendDisplay();
							}, 100);
						}
					}
				}
			};
			var menuItems = options.exporting.buttons.contextButton.menuItems || [];
			if (this._printSupported()) {
				menuItems.push({
					text: 'Print chart',
					onclick: function() {
						this.print(self);
					}
				});
			}
			if (this._exportSupported()) {
				menuItems.push({
					separator: true
				});
				menuItems.push({
					textKey: 'downloadPNG',
					onclick: function() {
						this.exportChart();
					}
				});
				menuItems.push({
					textKey: 'downloadJPEG',
					onclick: function() {
						this.exportChart({
							type: 'image/jpeg'
						});
					}
				});
				menuItems.push({
					textKey: 'downloadPDF',
					onclick: function() {
						this.exportChart({
							type: 'application/pdf'
						});
					}
				});
				menuItems.push({
					textKey: 'downloadSVG',
					onclick: function() {
						this.exportChart({
							type: 'image/svg+xml'
						});
					}
				});
			}
		}

		if (options.xAxis[0].title.text !== options.title.text) {
			options.xAxis[0].title.text = (options.xAxis[0].title.text ? options.xAxis[0].title.text : options.title.text);
		}
		options.chart.type = self._meta.defaultStyle;

		return options;
	},

	_initializeMeta: function() {
		this._mergeMetaData(this.$prototype);
		this._mergeMetaData(this.article);

		var proto = this.$prototype;
		var cube = this.currentMetaData;

		this._meta = {
			xAxis: [{}],
			series: {},
			displaysOneMeasure: cube && cube.$displaysOneMeasure,
			hasMeasureSelector: cube && cube.$hasMeasureSelector,
			hasStyleSelector: cube && cube.$hasStyleSelector,
			defaultStyle: _style(cube.$style) || 'column',
			drill: {
				minLevel: 1,
				maxLevel: 0,
				currLevel: 1,
				currAxisHier: 0,
				levelsProperties: [],
				members: [],
				stack: [{
					$axes: proto.$axes,
					$item: proto.$item,
					$slicer: proto.$slicer
				}]
			}
		};
		this.__processMeta(proto, true);
	},

	_exportSupported: function() {
		return true;
	},

	_printSupported: function() {
		return true;
	},

	__processMeta: function(metaData, init) {
		this._processMeasures(metaData, init);
		this._processAxes(metaData, init);
	},

	_processMeasures: function(metaData, init) {
		this._mergeMetaData(metaData);

		var self = this,
			items = this.$prototype.$properties;

		// Get measures definition. If measures are not defined in the second axis members (Cf. specs),
		// we used all the measures defined in the cube
		var measures = this._getRestraintMeasures(),
			icolor = 0;
		if (measures) {
			$.smForEachKey(measures, function(key, m) {
				// Because duplicate properties is possible for cube definition... we keep the last defined
				var code = (m.$property || key);
				var measure = _merge(items[code], m);
				if (metaData && metaData.$item && metaData.$item.$properties) {
					measure = _merge(measure, metaData.$item.$properties[code]);
				}
				if (!measure.$title || measure.$title === "") {
					measure.$title = key;
				}
				// measures[key] = measure;
				var serie = self._meta.series[code];

				if (init) {
					self._ensureFormatter(measure);

					serie = self._meta.series[code] = {
						options: {
							id: '#s-' + code,
							// legendIndex: "",
							name: self._localizedText(measure.$title) || String.fromCharCode(160),
							// visible: measure.$title !== "" && !!(!self._meta.displaysOneMeasure || measure.$isDefault)
						},
						measure: measure
					};
				}
				if (serie) {
					serie.isHidden = measure.$title === "";
					serie.options.type = _style(measure.$style);
					serie.options.color = measure.$color || colors[icolor++];
					serie.options.name = self._localizedText(measure.$title) || String.fromCharCode(160);
					serie.options.visible = measure.$title !== "" && !! (!self._meta.displaysOneMeasure || measure.$isDefault);
				}

				if (measure.$isStacked || measure.$stackingGroup) {
					serie.options.stack = measure.$stackingGroup || 0; // a stack ID
					self._meta.stacking = measure.$isNormalized ? 'percent' : self._meta.stacking || 'normal';
				}
			});
		}
	},

	_getRestraintMeasures: function() {
		var proto = this.currentMetaData,
			$cube = proto.$cube,
			measures = $cube && $cube.$measures,
			restraintMeasures = measures;
		if (measures) {
			if (proto.$axes && proto.$axes.length > 1 && proto.$axes[1].$members && proto.$axes[1].$members[0][0].length > 0) {
				restraintMeasures = {};
				$.smForEach(proto.$axes[1].$members[0][0], function(measureCode) {
					restraintMeasures[measureCode] = measures[measureCode];
				});
			}
		}
		return restraintMeasures;
	},

	_processAxes: function(proto, init) {
		var cube = this.$prototype.$cube;
		if (!_isCubeValid(cube, proto)) return false;

		var self = this,
			currAxisHier = 0,
			axis0 = proto.$axes && proto.$axes[0];

		// TODO: review this
		// Get axis analysis
		var mainHLevelsTab = null;
		if (axis0) {
			$.smForEachKey(axis0.$hierarchies, function(idx, hierarchy) {
				if (!mainHLevelsTab && hierarchy.length > 1 && hierarchy[1] == 1) {
					mainHLevelsTab = cube.$hierarchies[hierarchy[0]].$properties;
					if (mainHLevelsTab) {
						self._meta.xAxis[0].code = mainHLevelsTab[hierarchy.length > 2 ? hierarchy[2] : 0];
						currAxisHier = idx;
					}
				}
			});
			if (!mainHLevelsTab && axis0.$hierarchies[0].length > 0) {
				mainHLevelsTab = cube.$hierarchies[axis0.$hierarchies[0][0]].$properties;
				if (mainHLevelsTab && mainHLevelsTab.length > 0) self._meta.xAxis[0].code = mainHLevelsTab[0];
			}
			// Get drill definition
			var properties;
			$.smForEach(axis0.$hierarchies, function(hierarchie) {
				properties = cube.$hierarchies[hierarchie[0]].$properties;
				$.smForEach(properties, function(property) {
					this.levelsProperties[this.maxLevel++] = property;
				}, self._meta.drill);
			});
			if (axis0.$members) {
				$.smForEach(axis0.$members, function(tuple) {
					$.smForEach(tuple, function(value) {
						if (value.length > 0) {
							this.members[(this.currLevel++) - 1] = value[0];
						}
					}, this);
				}, self._meta.drill);
			}
		}
		self._meta.drill.code = proto.$codeStat || "UNKNOWN";
		self._meta.drill.axis0FieldCode = self._meta.xAxis[0].code || "";
		self._meta.drill.maxLevel = Math.max(self._meta.drill.maxLevel, self._meta.drill.minLevel);
	},

	_getPref: function() {
		return Highcharts.getOptions();
	},

	_getMeasureLabel: function(measure, code) {
		// return cubeHelper.getMeasureLabel(measure, code, this.$prototype && this.$prototype.$properties);
		var label = this._localizedText(measure.$title);
		if (label) return label;
		var self = this;
		var item = self.$prototype.$properties[code];
		if (!item) return null;
		switch (item.$type) {
			case "application/x-choice":
				label = measure[code];
				item.$value.$enum.some(function(element, i, array) {
					if (element.$value === label) {
						label = this._localizedText(element.$title);
						return true;
					}
					return false;
				});
				break;
			case "application/x-date":
				item.formatter = formatApi.getFormatter(item.$type, locale.getDateFormat(item.$type));
				label = item.formatter.formatValue(measure[code]);
				break;
			case "application/x-integer":
			case "application/x-decimal":
				item.formatter = formatApi.getFormatter(item.$type, locale.getNumberFormat(item.$type));
				label = item.formatter.formatValue(measure[code]);
				break;
			default:
				label = "" + measure[code];
				break;
		}
		return label;
	},

	_toggleLegendDisplay: function() {
		var legend = this._chart.legend;
		legend && this._displayLegend(!legend.display);
	},

	_displayLegend: function(display) {
		var legend = this._chart.legend;
		if (!legend) return;
		if (display) {
			legend.group.show();
			legend.box.show();
		} else {
			legend.group.hide();
			legend.box.hide();
		}
		this.displayLegend = legend.display = display;
	},
	destroy: function() {
		var self = this;
		Base.prototype.destroy.call(self);

		this._chart && this._chart.destroy();
		this._chart = this._localize = this._meta = this.currentMetaData = null;
	}
});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/chart/ctrlCubeChart',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/chart/ctrlCubeChartBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/formatApi','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/chart/ctrlCubeChartBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var locale = require("syracuse-tablet/html/js/helpers/locale");

/**
 * cube chart control class
 */
var _Klass = utils.defineClass(function CtrlCubeChart(controller, article, prototype, options) {
	var self = this;
	Base.call(self, controller, article, prototype, options);
	self.itemProto = prototype.getPrototype("$item");
}, Base, {
	/**
	 * Init the properties to allow reuse of this control
	 */
	initReuseProperties: function() {
		Base.prototype.initReuseProperties.call(this);
		this.$$chartSlot = null;
		this.dataset = null;
	},

	buildHtml: function($$parent, controllerDao, buildOptions) {
		var self = this;
		Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions, ["s-m-chart"]);
		self.$$chartSlot = $(uiUtils.createDomElement('div', null, null, null, self.$$elmt));
		self.$$chartSlot.hide();
		self._buildChart();
	},

	_buildChart: function() {
		var self = this;

		// This block assigns some variables so that the implementations
		// in ctrlCubeChartBase which have been migrated from the desktop client
		// do not need to be modified too much!
		self.$prototype = self.prototype.json;
		self.$prototype.$properties = self.$prototype.$item.$properties;
		self._localize = {
			highCharts_showHideLegend: locale.text("highCharts_showHideLegend"),
			highCharts_seriesTitle: locale.text("highCharts_seriesTitle")
		};
		//

		self._initializeMeta();

		self.dataset = self.getDao().getQueryResources();

		var settings = self._settingsFromValue();
		self._createChart(settings);
	},

	_ensureFormatter: function(measure) {
		measure.formatApi = {
			format: function(val, localFormat) {
				return val;
			}
		};
	},

	_localizedText: function(key) {
		return key;
	},

	_getFieldEvalTitle: function() {
		return [];
	},

	destroy: function() {
		var self = this;
		Base.prototype.destroy.call(self);
		self.dataset = null;
	},
	/**
	 * Call by page on resize - TODO generalize the resize process
	 */
	onResize: function(context) {
		var self = this;
		setTimeout(function() {
			var chart = self.$$chartSlot.highcharts();
			if (chart) {
				chart.setSize(self.$$chartSlot.width(), self.$$chartSlot.height(), false);
			}
			self.$$chartSlot.show();
		});
	}
});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/field/ctrlBinary',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/locale'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _defHeight = 100;

var _handlersMap = {
	"header": "_onClearClick",
	"section": "_onDocumentClick",
	"footer": "_onUploadClick",
	"a": "_onDocumentClick"
};

/**
 * Binary field
 * authoring:
 * 		$height	set the height of the image - default is _defHeight
 */
var _Klass = utils.defineClass(

	function CtrlBinary(controller, article, prototype, options) {
		var self = this;
		Base.call(self, controller, article, prototype, options);
		self.isImage = self.$type.indexOf("image") == 0;
		// Add cssType in root element
		self.cssType = self.isImage ? "s-m-img" : "s-m-binary";
	}, Base, {

		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			this.$$layout = null;
		},

		applyMetaData: function(metaData) {
			Base.prototype.applyMetaData.call(this, metaData);
			if (this.$isEditMode && this.$$layout) {
				var disabled = metaData ? metaData.$isReadOnly || metaData.$isDisabled : false;
				this.$$layout.children("header").toggle(disabled !== true);
				this.$$layout.children("footer").toggle(disabled !== true);
			}
		},

		buildFieldValue: function(parentSlot, buildOptions) {
			var self = this;
			var value = self.getFormattedValue(self.getValue());
			// Create the image stuff under the standard s-m-value parent
			var imgParent = Base.prototype.buildFieldValue.call(self, parentSlot, buildOptions);
			var docUrl = self._getLocalUrlValue();
			if (!docUrl) {
				docUrl = self.prototype.data("$url", self.getDao()) || "";
				//TODO use $etag or else - No need to force reload if updateLayout - data are in the browser's cache
				if (buildOptions.updateLayout !== true) {
					docUrl += '?salt=' + ((new Date()).getTime());
				}
			}
			var empty = value == null || value === "" || docUrl.length === 0;
			if (empty) $(imgParent).addClass("s-m-empty");
			// if FileReader not supported by the browser, we display detail view (fix for Safari)
			// we don't display edit mode for "x-document" type since it can't be edited yet
			if (self.$isEditMode && typeof FileReader !== "undefined" && self.typeName.indexOf("document") < 0) {
				self._buildEditBinaryField(imgParent, docUrl, empty);
			} else {
				if (this.article.$imgDisplayIcon === true) {
					// We want to display images as icons - enabled only for arrays in table mode
					var css;
					if (empty) {
						css = fontUtils.getColImageDefIcon(true).css;
					} else {
						css = (this.article.$imgIcon || fontUtils.getColImageDefIcon(false)).css;
					}
					return $(imgParent).addClass(css);
				} else if (empty) {
					// Only icon
					if (buildOptions && buildOptions.displayCtx === "card") {
						// same height for all cards -> We set the height
						self._defaultImg(imgParent, null);
					} else {
						$(imgParent).addClass(this._getDefaultIcon());
					}
				} else {
					// link - Maybe we could manage a modal to display the image 
					var e = uiUtils.createDomElement("a", ["img-responsive ctrl-evt-click"], null, {
						"href": "#"
					}, imgParent);
					if (self.isImage) {
						// Image with link
						e = self._newImg(e, docUrl);
						//e.style.backgroundImage = 'url("' + docUrl + '")';
					} else {
						// Icon with link
						e = uiUtils.createDomElement("span", this._getDefaultIcon(), null, null, e);
					}
				}
			}
		},
		_buildEditBinaryField: function(parentSlot, docUrl, empty) {
			var self = this;

			// layout structure
			self.$$layout = $('<div class="s-m-img-layout">');
			// building 3 components. clear button, core and upload button. All clickable.
			var clearBtn, uploadBtn, core;

			// build clear btn.
			clearBtn = uiUtils.createDomElement("a", ["ctrl-evt-click"], null, {
				"href": "#"
			}, $("<header>").appendTo(self.$$layout));
			clearBtn = uiUtils.createDomElement("span", fontUtils.getIconByName("close"), null, null, clearBtn);
			$(clearBtn).toggle(!empty);

			// build core
			core = uiUtils.createDomElement("a", ["img-responsive", "s-m-field-" + (self.isImage ? "img" : "bin"), "ctrl-evt-click"], null, {
				"href": "#"
			}, $("<section>").appendTo(self.$$layout));


			// *image* core
			if (self.isImage) {

				// build upload button only for image content
				uploadBtn = uiUtils.createDomElement("a", ["ctrl-evt-click"], locale.text("image.label." + (empty ? "addimage" : "changeimage")), {
					"href": "#"
				}, $("<footer>").appendTo(self.$$layout));

				// use default image if empty content
				if (empty) {
					core = uiUtils.createDomElement("span", [self._getDefaultIcon(), "s-m-empty", "img-responsive"], null, null, core);
				} else {
					core = self._newImg(core, docUrl);
				}

			} else {
				// *document* core
				core = uiUtils.createDomElement("span", [self._getDefaultIcon(), empty ? "s-m-empty" : "", "s-m-doc"], null, null, core);
			}

			parentSlot.appendChild(self.$$layout[0]);

			// append <input> dom if image
			if (self.isImage) {
				var inputDom = uiUtils.createDomElement("input", ["ctrl-evt-change"], null, {
					"type": "file",
					"accept": "image/*"
				}, parentSlot);
			}
		},
		onClick: function(evt) {
			var self = this;
			var dom = evt.target.nodeName.toLowerCase() === "span" ? evt.target.parentNode : evt.target;
			var parentDom;

			// detail mode
			if (!self.$isEditMode && dom.nodeName.toLowerCase() === "a") {
				parentDom = dom;
			}
			// edit mode
			else {
				parentDom = dom.parentNode;
			}
			if (!parentDom) return;
			var hdl = _handlersMap[parentDom.nodeName.toLowerCase()];
			if (!hdl) return;
			self[hdl](evt, dom);
		},
		/*
			When clear button is clicked
			- Removes binary content
			- Hide clear button
			- Update upload button text if image
		*/
		_onClearClick: function(evt, dom) {
			var self = this;

			// get the clear btn
			var clearBtn = dom;

			// get core elmt (the anchor containing the image or the file)
			var core = self.$$elmt.find(".s-m-img-layout > section > a")[0];

			// remove image/doc
			uiUtils.empty(core);

			// update image/doc
			core = uiUtils.createDomElement("span", [self._getDefaultIcon(), "s-m-empty"], null, null, core);

			// update dao
			self.setValue(null);

			// toggle clearBtn
			$(clearBtn).toggle();

			// update upload button
			if (self.isImage) {
				self.$$elmt.find(".s-m-img-layout > footer > a").text(locale.text("image.label.addimage"));
			}

			self._setLocalUrlValue(null);
		},
		/*
			When image is clicked
			- If not empty, open image
			- If empty, run upload image process

			When document is clicked
			- If empty, nothing
			- If not empty, open document
		*/
		_onDocumentClick: function(evt, dom) {
			var self = this;
			var value = self.getFormattedValue(self.getValue());
			var docUrl = self.prototype.data("$url", self.getDao()) || "";
			var empty = value == null || value === "" || docUrl.length === 0;

			if (self.isImage) {
				if (empty) {
					// upload image
					self._onUploadClick(evt, dom);
				}
			} else {
				if (!empty) {
					window.open(docUrl, "_blank");
				}
			}
		},
		/* 
		When upload button is clicked (or empty image), run upload and update dao
	*/
		_onUploadClick: function(evt, dom) {
			var self = this;
			var $$inputDom = self.$$elmt.find(".s-m-value > input");
			$$inputDom.trigger("click");
		},
		/*
		Runs image selection within the client device
		Updates dao
	*/
		onChange: function(evt) {
			var self = this;

			if (evt.target.nodeName.toLowerCase() === 'input') {
				var files = evt.target.files; // FileList object
				var res = {};
				if (files && files.length) {
					var f = files[0];
					if (!f.type.match('image.*')) return;
					res.$contentType = f.type;
					res.$fileName = f.name;
					res.$type = "image";

					var reader = new FileReader();
					reader.onload = (function(theFile, cont) {
						return function(e) {
							var i = e.target.result.indexOf("base64,");
							if (i > 0) cont.$value = e.target.result.substring(i + 7);
							else cont.$value = e.target.result;
							delete cont.$url;
							self.setValue(cont.$value);
							self._setImage(e.target.result);
						};
					})(f, res);
					reader.readAsDataURL(f);

				}
			}
		},
		_setLocalUrlValue: function(src) {
			this.getDao().setValue(this.$bind + "-LOCALURL", src);
		},
		_getLocalUrlValue: function() {
			return this.getDao().getValue(this.$bind + "-LOCALURL");
		},
		/*
		Set image based on client image src
		*/
		_setImage: function(src) {
			var self = this;

			self._setLocalUrlValue(src);

			// get core elmt (the anchor containing the image)
			var core = self.$$elmt.find(".s-m-img-layout > section > a")[0];

			// remove image
			uiUtils.empty(core);

			// update image
			core = self._newImg(core, src);

			// update upload button
			self.$$elmt.find(".s-m-img-layout > footer > a").text(locale.text("image.label.changeimage"));

			// toggle clearBtn
			self.$$elmt.find(".s-m-img-layout > header > a").toggle(true);
		},
		_newImg: function(parent, src) {
			return this._setImgHeight(uiUtils.createDomElement("img", ["img-responsive"], null, {
				src: src
			}, parent));
		},
		_defaultImg: function(parent, css) {
			return this._setImgHeight(uiUtils.createDomElement("span", this._getDefaultIcon() + (" " + (css || "")), null, null, parent));
		},
		_setImgHeight: function(i) {
			var h = Math.max(0, parseInt(this.getAuthoring("$height") || _defHeight, 10));
			return $(i).height(h).get(0);
		},
		_getDefaultIcon: function() {
			var css = "s-m-icon-" + (this.article.$emptyIconSize || "small") + " ";
			if (this.cssType === "s-m-binary") {
				return css + fontUtils.getEmptyFileDefIcon().css;
			}
			if (this.cssType === "s-m-img") {
				return css + (this.article.$emptyImageIcon || fontUtils.getEmptyImageDefIcon()).css;
			}
			return "";
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/helpers/html-escape/lib/escape',['require','exports','module'],function (require, exports, module) {

function fixOptions(options) {
	options = options || {};
	options.allowedTags = (options.allowedTags || []).concat( //
		['h1', 'h2', 'h3', 'h4', 'h5', 'h6', //
			'blockquote', 'p', 'a', 'ul', 'ol', 'nl', 'li', //
			'b', 'i', 'strong', 'em', 'strike', 'code', //
			'hr', 'br', 'div', 'pre', //
			'table', 'thead', 'caption', 'tbody', 'tr', 'th', 'td', 'pre'
		]);
	options.allowedAttributes = (options.allowedAttributes || []).concat( //
		['class', 'href', 'src', 'name', 'target']);
	options.allowedSchemes = (options.allowedSchemes || []).concat( //
		['http', 'https', 'mailto']);
	return options;
}

function map(array) {
	return array.reduce(function(map, key) {
		map[key] = true;
		return map;
	}, {});
}

function escapeText(str) {
	return str.replace(/>/g, '&gt;');
}

function escapeComment(str) {
	return str.replace(/-->/g, '__>');
}

function escapeStyle(str) {
	// brutal: will cripple all occurrences of javascript, expression and url
	return str.replace(/\/\*.*?\*\//g, '').replace(/(\\|\b)(j\\?a\\?v\\?a\\?s\\?c\\?r\\?i\\?p\\?t|e\\?x\\?p\\?r\\?e\\?s\\?s\\?i\\?o\\?n|u\\?r\\?l)\b/ig, 'disabled-$1$2');
}

function escapeType(str) {
	// cripple type="text/javascript"
	return str.replace(/javascript/i, "disabled-javascript");
}

exports.escaper = function(options) {
	options = fixOptions(options);
	var allowedTags = map(options.allowedTags);
	var allowedAttributes = map(options.allowedAttributes);
	var allowedSchemes = map(options.allowedSchemes);
	var urlAttributes = /^(href|src|dynsrc|lowsrc|background)$/i;
	var preserve = options.preserve;
	var warn = options.warn;

	function checkChange(oldVal, newVal, prefix) {
		if (warn && newVal !== oldVal) warn(prefix + ": " + oldVal + " -> " + newVal);
		return newVal;
	}

	function escapeValue(key, val) {
		if (key === 'style') return checkChange(val, escapeStyle(val), "sanitized style");
		if (key === 'type') return checkChange(val, escapeType(val), "sanitized type attribute");
		return val;
	}

	function create() {
		var result = "";
		var inside = "text";

		function skipTillMarker(frag, marker, repl) {
			var i = frag.indexOf(marker);
			if (i >= 0) {
				if (preserve) result += escapeComment(frag.substring(0, i)) + repl + '-->';
				result += escapeText(frag.substring(i + marker.length));
				inside = "text";
			} else {
				if (preserve) result += escapeComment(frag);
			}
			return result;
		}

		function skipTillClosing(frag, tag, allowed) {
			var re = new RegExp('^/' + tag + '>', 'i');
			var m = re.exec(frag);
			if (m) {
				if (allowed) result += '</' + tag + '>';
				else if (preserve) result += '</' + tag + '>-->';
				result += escapeText(frag.substring(m[0].length));
				inside = "text";
			} else {
				if (allowed) result += escapeValue(tag, '<' + frag);
				else if (preserve) result += escapeComment('<' + frag);
			}
			return result;
		}

		function reject(frag, warn) {
			if (warn) warn("malformed element: " + frag);
			if (preserve) result += '<!--<' + escapeComment(frag) + '-->';
			return result;
		}

		function allowedValue(atb, val) {
			if (urlAttributes.test(atb)) {
				var colon = val.indexOf(':');
				if (colon < 0 || !allowedSchemes[val.substring(0, colon)]) return false;
			}
			return true;
		}

		function escapeTag(tag, closing, atbs, autoClosed) {
			if (closing) {
				result += '</' + tag + '>';
				atbs = atbs.trim();
				if (preserve && atbs) result += '<!--@' + escapeComment(atbs) + '-->';
				return;
			}
			result += '<' + tag;
			var end = 0;
			var re = /^\s*(\w+)(?:\s*=\s*(?:(["'])(.*?)\2|()([\w_-]+)))?/,
				m;
			while (m = re.exec(atbs)) {
				atbs = atbs.substring(m[0].length);
				var atb = m[1].toLowerCase();
				var quote = m[2] || '"';
				var val = m[3] || m[5];
				if (!allowedAttributes[atb] || !allowedValue(atb, val)) {
					if (warn) warn("forbidden attribute: " + atb);
					if (preserve) atb = "disabled-" + atb;
					else continue;
				}
				result += ' ' + atb + (val === undefined ? '' : '=' + quote + escapeValue(atb, val) + quote);
			}
			if (autoClosed) result += '/>';
			else result += '>';
			atbs = atbs.trim();
			if (warn && atbs) warn("malformed attribute: " + atbs);
			if (preserve && atbs) {
				result += '<!--@' + escapeComment(atbs) + '-->';
			}
		}

		return function(frag) {
			result = "";
			if (inside === "comment") return skipTillMarker('<' + frag, '-->', '');
			if (inside === "cdata") return skipTillMarker('<' + frag, ']]>', ']]');
			if (inside === "script") return skipTillClosing(frag, 'script');
			if (inside === "style") return skipTillClosing(frag, 'style', allowedTags.style);

			if (/^!--/.test(frag)) {
				inside = "comment";
				if (preserve) result += '<!-- '; // extra space marks as original comment for roundtripping
				return skipTillMarker(frag.substring(3), '-->', '');
			}
			if (/^!\[CDATA\[/.test(frag)) {
				inside = "cdata";
				if (warn) warn("forbidden CDATA");
				if (preserve) result += '<!--';
				return skipTillMarker(frag.substring(1), ']]>', ']]');
			}
			if (/^script\b/i.test(frag)) {
				inside = "script";
				if (warn) warn("forbidden *** SCRIPT *** element");
				if (preserve) result += '<!--';
				return skipTillClosing(frag, 'script');
			}
			if (/^style\b/i.test(frag)) {
				inside = "style";
				if (!allowedTags.style && warn) warn("forbidden STYLE element");
				if (preserve && !allowedTags.style) result += '<!--';
				return skipTillClosing(frag, 'style', allowedTags.style);
			}
			// Special contents have been intercepted.
			// Reject malformed tags
			var end = frag.indexOf('>');
			if (end < 0) return reject(frag, warn); // not closed
			var m = /^(\/?)(\w+)/.exec(frag);
			if (!m) return reject(frag, warn); // invalid syntax: tag name not found
			var tag = m[2].toLowerCase();
			if (!allowedTags[tag]) {
				if (warn && !m[1]) warn("forbidden " + tag.toUpperCase() + " element");
				if (preserve) reject(frag.substring(0, end + 1));
				escapeText(frag.substring(0, end + 1));
			} else {
				// tag is allowed
				var autoClosed = frag[end - 1] === '/';;
				escapeTag(tag, m[1], frag.substring(m[1].length + tag.length, autoClosed ? end - 1 : end), autoClosed);
			}
			result += escapeText(frag.substring(end + 1));
			return result;
		};
	};

	if (options.streaming) {
		return (function() {
			var process;
			return function(text) {
				if (text.indexOf('<') >= 0) throw new Error('internal error: bad HTML fragment');
				if (!process) {
					process = create();
					return escapeText(text);
				} else {
					return process(text);
				}
			};
		})();
	} else {
		return function(text) {
			var process = create();
			var frags = text.split('<');
			var result = escapeText(frags[0]);
			return frags.slice(1).reduce(function(r, frag) {
				return r + process(frag);
			}, result);
		};
	}
};
});

define('syracuse-tablet/html/js/helpers/html-escape/lib/unescape',['require','exports','module'],function (require, exports, module) {

exports.unescaper = function(options) {
	options = options || {};

	function uncomment(str) {
		return str.replace(/__>/g, '-->');
	}

	function process(str) {
		return str.replace(/disabled-(\w+=?)/g, '$1').replace(/(.?)<!--(.*?)-->/g, function(all, ch, commented) {
			if (commented[0] === ' ') return ch + '<!--' + commented.substring(1) + '-->';
			if (commented[0] === '[') return ch + '<!' + uncomment(commented) + '>';
			if (commented[0] === '<') return ch + uncomment(commented);
			if (commented[0] === '@') return uncomment(commented.substring(1)) + ch;
			throw new Error("cannot unescape: " + commented);
		});
	}
	if (options.streaming) {
		var buf = "";
		return function(str) {
			if (str === undefined) return process(buf);
			var start = Math.max(0, buf.length - 2);
			buf += str;
			var end = buf.indexOf('-->', start);
			if (end < 0) return '';
			var r = process(buf.substring(0, end + 3));
			buf = buf.substring(end + 3);
			return r;
		};
	} else {
		return process;
	}
};
});

define('syracuse-tablet/html/js/helpers/html-escape/index',['require','exports','module','./lib/escape','./lib/unescape'],function (require, exports, module) {
exports.escaper = require('./lib/escape').escaper;
exports.unescaper = require('./lib/unescape').unescaper;
});

define('syracuse-tablet/html/js/helpers/syracuse-rtf/lib/rtfparse',['require','exports','module'],function (require, exports, module) {

var lowerLetter = {},
	digit = {},
	LF = '\n'.charCodeAt(0),
	SP = ' '.charCodeAt(0),
	BSLASH = '\\'.charCodeAt(0),
	OPEN = '{'.charCodeAt(0),
	CLOSE = '}'.charCodeAt(0),
	DASH = '-'.charCodeAt(0),
	QUOTE = "\'".charCodeAt(0),
	STAR = "*".charCodeAt(0);

(function() {
	function add(clas, chs, i) {
		chs.split('').forEach(function(ch) {
			clas[ch.charCodeAt(0) + (i || 0)] = true;
		});
	}
	for (var i = 0; i <= 9; i++) add(digit, '0', i);
	for (var i = 0; i < 26; i++) add(lowerLetter, 'a', i);
})();

function builder(error) {
	var group = [],
		stack = [group];
	return {
		open: function() {
			var g = [];
			group.push(g);
			stack.push(g);
			group = g;
		},
		close: function() {
			if (stack.length <= 1) error("too many }");
			group = stack.pop();
			group = stack[stack.length - 1];
		},

		text: function(str) {
			group.push(str);
		},

		control: function(word, arg) {
			var obj = {
				word: word
			};
			if (arg != null) obj.arg = arg;
			group.push(obj);
		},

		/*star: function() {
			group.push({word: "*"});
		},*/

		getResult: function() {
			if (stack.length !== 1) error("missing }");
			return stack[0][0];
		}
	};
}

// returns tree. 
// intermediate nodes are arrays and correspond to rtf groups ({ ...})
// leaf nodes are either
// * strings (text elements)
// * control directives { word: w, arg: a }
exports.parse = function(str) {
	str = str.replace(/\r\n/g, '\n');
	var pos = 0,
		begText = 0,
		len = str.length,
		line = 1,
		bld = builder(error);

	function error(msg) {
		var end = str.indexOf(/[\n>]/, pos);
		if (end < 0) end = str.length;
		return new Error("Invalid RTF: " + msg + " at line " + line + " near " + str.substring(pos, end));
	}

	function flush() {
		if (pos > begText) bld.text(str.substring(begText, pos));
	}
	while (pos < len) {
		var ch = str.charCodeAt(pos);
		switch (ch) {
			case BSLASH:
				flush();
				var beg = ++pos;
				while (lowerLetter[ch = str.charCodeAt(pos)]) pos++;
				if (pos > beg) {
					var word = str.substring(beg, pos),
						arg = undefined;
					if (ch === DASH || digit[ch]) {
						beg = pos;
						pos++;
						while (digit[ch = str.charCodeAt(pos)]) pos++;
						arg = parseInt(str.substring(beg, pos), 10);
					}
					if (ch === SP || ch === LF || (word === "u" && ch !== BSLASH && ch !== OPEN && ch !== CLOSE)) {
						pos++;
					}
					bld.control(word, arg);
				} else if (ch === QUOTE) {

					var symb = String.fromCharCode(parseInt(str.substring(pos + 1, pos + 3), 16));
					bld.text(symb);
					pos = pos + 3;
				} else if (ch === STAR) {
					bld.control("*");
					pos++;
				}

				begText = pos;
				break;
			case OPEN:
				flush();
				bld.open();
				begText = ++pos;
				break;
			case CLOSE:
				flush();
				bld.close();
				begText = ++pos;
				break;
			case LF:
				flush(); // to discard newline from output
				line++;
				begText = ++pos;
				break;
			default:
				pos++;
		}
	}
	flush();
	return bld.getResult();
};
});

define('syracuse-tablet/html/js/helpers/syracuse-rtf/lib/rtfinterpret',['require','exports','module'],function (require, exports, module) {

//var rtfparser = require('./rtfparse');

exports.interpret = function(root) {

	var group;
	var documentModel = {
		deffont: "",
		fonts: {},
		colors: [],
		styles: {},
	};
	var fontfamgroups = {
		fnil: "Sans-serif",
		froman: "Sans-serif",
		fswiss: "Serif",
		fmodern: "Monospace",
		fscript: "Cursive",
		fdecor: "Cursive"
	};

	var supported = ["rtf", "ansi", "ansicpg", "deff", "fonttbl", "colortbl", "stylesheet", //
		"fs", "f", "cf", "highlight", "i", //
		"b", "ul", "strike", "plain", //
		"qc", "ql", "qr", "qj", "par", "pard", "pn"
	];

	function interpretFont(features, index, fonts) {
		var fname = features[0].word + features[0].arg;
		var font = (documentModel.fonts[fname] = {});
		for (var i = 1; i < features.length; i++) {
			interpretFontFeature(features[i], font);
		}
	}

	function interpretFontFeature(feature, font) {
		var sep;
		if (typeof feature == "string" && (sep = feature.indexOf(';')) > 0) {
			font.name = feature.substring(0, sep);
		}
	}

	function interpretStylesheet(features, index, styles) {
		var fname, style;
		if (features[0].word) {
			fname = features[0].word + features[0].arg;
			style = (documentModel.styles[fname] = {});
			for (var i = 1; i < features.length; i++) {
				interpretStyleFeature(features[i], style);
			}
		}
	}

	function interpretStyleFeature(feature, style) {
		var sep;
		if (typeof feature == "string" && (sep = feature.indexOf(';')) > 0) {
			style.name = feature.substring(0, sep);
		}
	}

	function interpretControl(node, parent, index) {
		switch (node.word) {
			case "rtf":
			case "ansi":
			case "ansicpg":
				break;
			case "stylesheet":
				parent.slice(1).filter(function(item) {
					// keep only arrays, remove newlines
					return Array.isArray(item);
				}).forEach(interpretStylesheet);
				//documentModel.stylesheet ="";
				break;
			case "deff":
				documentModel.deffont = "f" + node.arg;
				break;
			case "fonttbl":
				parent.slice(1).filter(function(item) {
					// keep only arrays, remove newlines
					return Array.isArray(item);
				}).forEach(interpretFont);
				break;
			case "colortbl":
				// semicolon counts for one item => skip 2 items first
				var i = 1;
				if (parent[i] === ';') {
					documentModel.colors.push([0, 0, 0]);
					i++;
				}
				while (i < parent.length) {
					documentModel.colors.push([parent[i].arg, parent[i + 1].arg, parent[i + 2].arg]);
					i += 4; // skip semicolon too
				} // while
				break;

			case "*":
				/*console.log(parent[index+1].word) ;*/
				if (supported.indexOf(parent[index + 1].word) == -1) parent.splice(index, parent.length - index);
				break;
		} //switch

	}

	function interpretNode(node, index, array) {
		if (Array.isArray(node)) {
			// child nodes will receive node as array argument.
			node.forEach(interpretNode);
		} else if (typeof node === "object") {
			interpretControl(node, array, index);
		}
	}

	/* on copie fonts et colors dans styles */
	interpretNode(root);
	return documentModel;
};
});

define('syracuse-tablet/html/js/helpers/syracuse-rtf/lib/buildhtml',['require','exports','module'],function (require, exports, module) {

// ===================================================================================================================================================
// ===================================================================================================================================================
// ===================================================================================================================================================
// ===================================================================================================================================================
//	<div class="s-rtf-root">
//	<div class="s-rtf-section">
//		<p></p>
//		<p></p>
//	</div>
//	<div class="s-rtf-section">
//		<ul>
//			<li></li>
//			<li></li>
//			<li></li>
//		</ul>
//	</div>
//</div>
var styleName = {
	cf: "color",
	highlight: "background-color"
};

function rgbToHex(rgb) {
	if (rgb) {
		return toHex(rgb[0]) + toHex(rgb[1]) + toHex(rgb[2]);
	} else {
		return "000000"; //default color
	}
}

function toHex(n) {
	return ("00" + n.toString(16)).slice(-2);
}

function twipsToPoint(t) {
	return t / 20;
}

function indentCount(t) {
	return t / 600;
}

function indentBulletCount(t) {
	return t / 420;
}

function twipsToPixel(t) {
	return t / 15;
}

function builder(documentModel) {
	var rtffonts = documentModel.fonts,
		deffont = documentModel.deffont,
		colors = documentModel.colors,
		styles = documentModel.styles,
		htmltext = "",
		$rootdiv = $("<div>").addClass('s-rtf-root'),
		$current = null,
		$section = null,
		$worker = null,
		context;

	newSection();

	function newWorker() {
		$current = $worker = $("<div>").addClass('s-rtf-worker').addClass('s-rtf-clean');
		return $worker.appendTo($section);
	}

	function newSection() {
		$section = $("<div>").addClass('s-rtf-section').addClass('s-rtf-clean');
		newWorker();
		return $section.appendTo($rootdiv);
	}

	function characterFormatting(node) {
		switch (node.word) {

			case "f":
				/*case "pnf":*/
				var fontface = rtffonts[node.word + node.arg].name;
				return $("<font face='" + fontface + "'>");

			case "fs":
				//case "pnfs":
				return $("<span style='font-size: " + node.arg / 2 + "pt;'>");
			case "tab":
				//case "pnfs":
				//return $("<span style='margin-left: 10pt'>");//be  carrefull depending on navigator
				return $("<blockquote>"); //be  carrefull depending on navigator
			case "cf":
				//if(!node.arg) return null;
			case "highlight":
				// do not use css() because it converts hex value into rgb style
				// return $("<span>").css(styleName[node.word], "#" + rgbToHex(colors[node.arg]));
				return $("<span style='" + styleName[node.word] + ": #" + rgbToHex(colors[node.arg]) + ";'>");

			case "b":
				return $("<b>");
			case "i":
				return $("<i>");
			case "ul":
				return $("<u>");
			case "strike":
				return $("<s>");
				/*
		case "plain":
			return ["<pre>", "</pre>"];
		case "list":
			return ["<ul>", "</ul>"];
		case "pntext":*/
				/*case "bullet":
			return $("<li>");
		case "line":
			return $("<br>");*/
			default:
				// ; //$("");
		}
	}

	function paragraphFormatting(elt, node) {
		elt.addClass('s-rtf-format');

		dirty();

		switch (node.word) {
			case "ql":
				return elt.attr("align", "left");
			case "qc":
				return elt.attr("align", "center");
			case "qr":
				return elt.attr("align", "right");
			case "qj":
				return elt.attr("align", "justify");
			case "li":
				// return elt.css("margin-left", twipsToPixel(node.arg) + "px");
				if (node.arg > 0)
					return elt.css("margin-left", twipsToPoint(node.arg) + "pt");
				else
					return elt;
			case "ri":
				// return elt.css("margin-right", twipsToPixel(node.arg) + "px");
				if (node.arg > 0)
					return elt.css("margin-right", twipsToPoint(node.arg) + "pt");
				else
					return elt;
			default:
				return elt;
		}

	}

	function dirty() {
		$worker && $worker.removeClass("s-rtf-clean");
		// if we want to always have a paragraph, uncomment this line
		// $worker && $worker.addClass("s-rtf-paragraph");
		$section && $section.removeClass("s-rtf-clean");
	}

	function append(elt) {
		dirty();
		$current.append(elt);
	}

	function wrapIn(elt) {
		dirty();
		$current = elt.appendTo($current);
	}

	context = (function() {
		var stack = [{
			format: {}
		}],
			current = stack[0];

		function flattenFormat() {
			var f, fmt = {};
			stack.forEach(function(ctx) {
				f = ctx.format;
				Object.keys(f).forEach(function(key) {
					if (typeof(fmt[key]) === "undefined") {
						fmt[key] = f[key];
					}
				});
			});
			return fmt;
		}

		return {
			open: function() {
				stack.push(current = {
					format: {}
				});
			},

			close: function(idx, parent) {
				stack.pop();
				current = stack[stack.length - 1];
				if (idx < parent.length - 1) {
					this.pending = true;
				}
			},

			update: function(prop, el) {
				if (el === null) {
					delete current.format[prop];
				} else {
					current.format[prop] = el;
				}
			},

			startOver: function() {
				if (!this.pending) return;
				var fmt = flattenFormat();
				Object.keys(fmt).forEach(function(key) {
					$current = fmt[key].clone().appendTo($current);
				});
				this.pending = false;
			}
		};
	})();

	return {
		text: function(str) {
			dirty();
			context && context.startOver();
			var content = $current.html();
			$current.html(content + str);
		},

		open: function() {
			context.open();
		},

		close: function(idx, parent) {
			$current = $worker;
			if ($current.length === 0) $current = $rootdiv;
			context.close(idx, parent);
		},

		control: function(node) {
			switch (node.word) {

				case "par":
					dirty();
					$worker.removeClass("s-rtf-worker").addClass("s-rtf-paragraph");
					$current = $worker = newWorker();
					context && (context.pending = true);
					break;

				case "pard":
					if (!$section.hasClass("s-rtf-clean")) {
						$section = newSection();
						context && (context.pending = true);
					}
					break;

				case "pn":
					$section.addClass("s-rtf-list");
					break;

				case "u":
					this.unicodechar(node.arg);
					break;

				case "qc":
				case "ql":
				case "qr":
				case "qj":
				case "ri":
					paragraphFormatting($section, node);
					break;
				case "li":
					if ($section.hasClass("s-rtf-list")) {
						$section.attr("indent", indentBulletCount(node.arg));
					} else {
						if (!$section.hasClass("s-rtf-clean") && !$section.hasClass("s-rtf-format")) {
							$section = newSection();
							context && (context.pending = true);
						}
						$section.addClass("s-rtf-left-indent");
						$section.attr("indent", indentCount(node.arg));
					}
					break;
				case "lquote":
				case "rquote":
					this.text("'");
					break;

				case "line":
					append("<br>");
					break;
				case "bullet":
					// var el = $("<li>");
					// var dd = 1;
					// if ($current.is("li")) {
					//	$current.parent().append(el);
					// } else {
					//	$current.append(el);
					// }
					// $current = el;
					break;

				case "i":
				case "b":
				case "strike":
				case "ulnone":
				case "ul":
					if (node.arg === 0 || node.word === "ulnone") {
						var tagname;
						if (node.word === "strike") {
							tagname = "s";
						} else if (node.word === "ulnone") {
							tagname = "u";
						} else {
							tagname = node.word;
						}
						if ($current.is(tagname)) {
							$current = $current.parent();
						} else {
							if ($current.html() !== "") {
								var tag = $current.closest(tagname);
								$current = tag.parent();
							}
						}

						context.update(node.word, null);
						break;
					}
				default:
					var el = characterFormatting(node);

					if (el) {
						context.update(node.word, el.clone());
						!context.pending && wrapIn(el);
					}
			}
			//console.log(node.word + "\n"+$rootdiv.html())
		},
		unicodechar: function(code) {
			dirty();
			var content = $current.html();
			$current.html(content + String.fromCharCode(code));
		},

		getHtml: function() {
			//console.log($rootdiv.html())
			// cleanup
			$rootdiv.find(".s-rtf-clean").remove();
			// replace <div> by <ul>
			var sections = $rootdiv.find(".s-rtf-section.s-rtf-list") //.removeAttr("class");
			sections.map(function(i, e) {
				var $e = $(e);
				var i = parseInt($e.attr("indent"), 10);
				var w = [];
				while (w.length < i) {
					w.push("<ul>");
				}
				$e.wrap(w.join("")).contents();
				//$e.removeAttr("indent");
			});
			var workers = sections.find(".s-rtf-paragraph");
			workers.wrap("<li>").contents().unwrap();
			//sections.unwrap();
			var indent = $rootdiv.find(".s-rtf-section.s-rtf-left-indent").removeClass("s-rtf-left-indent");
			indent.map(function(i, e) {
				var $e = $(e);
				var i = parseInt($e.attr("indent"), 10);
				var w = [];
				while (w.length < i) {
					w.push("<blockquote>");
				}
				$e.wrap(w.join("")).contents();
				$e.removeAttr("indent");
			});



			sections = $rootdiv.find(".s-rtf-section");

			// replace <div> by <p>
			sections.find(".s-rtf-paragraph").removeAttr("class").wrap("<p>").contents().unwrap();
			sections.find("div:empty").remove();



			// cleanup
			sections.find(".s-rtf-worker:empty").remove();
			sections.filter(":not(.s-rtf-format)").contents().unwrap();
			while ($rootdiv.find("span:empty").length) {
				$rootdiv.find("span:empty").remove();
			};
			$rootdiv.find(".s-rtf-worker").removeAttr("class").contents().unwrap();
			$rootdiv.find(".s-rtf-format").removeAttr("class");

			return $rootdiv.html();
		}
	};
}

// HTML builder
exports.buildHtml = function(root, documentModel) {
	var bld = builder(documentModel);

	function interpretNode(node, index, array) {
		if (typeof node == "string") {
			bld.text(node);
			return;
		}
		if (Array.isArray(node) && node.length > 0) {
			if (node[0]) {
				switch (node[0].word) {
					case 'fonttbl':
					case 'colortbl':
					case 'stylesheet':
					case 'pntxtb':
					case 'pntext':
					case 'pict':
						return;
				}
			}
			bld.open();
			node.forEach(interpretNode);
			bld.close(index, array);

			return;
		}

		if (typeof(node) === "object") {
			bld.control(node);

		}
	}

	interpretNode(root, 0, []);
	if (!root) return "<div></div>";
	return bld.getHtml();
};
});

define('syracuse-tablet/html/js/helpers/syracuse-rtf/lib/buildrtf',['require','exports','module'],function (require, exports, module) {
var colors = {
	"aliceblue": "#f0f8ff",
	"antiquewhite": "#faebd7",
	"aqua": "#00ffff",
	"aquamarine": "#7fffd4",
	"azure": "#f0ffff",
	"beige": "#f5f5dc",
	"bisque": "#ffe4c4",
	"black": "#000000",
	"blanchedalmond": "#ffebcd",
	"blue": "#0000ff",
	"blueviolet": "#8a2be2",
	"brown": "#a52a2a",
	"burlywood": "#deb887",
	"cadetblue": "#5f9ea0",
	"chartreuse": "#7fff00",
	"chocolate": "#d2691e",
	"coral": "#ff7f50",
	"cornflowerblue": "#6495ed",
	"cornsilk": "#fff8dc",
	"crimson": "#dc143c",
	"cyan": "#00ffff",
	"darkblue": "#00008b",
	"darkcyan": "#008b8b",
	"darkgoldenrod": "#b8860b",
	"darkgray": "#a9a9a9",
	"darkgreen": "#006400",
	"darkkhaki": "#bdb76b",
	"darkmagenta": "#8b008b",
	"darkolivegreen": "#556b2f",
	"darkorange": "#ff8c00",
	"darkorchid": "#9932cc",
	"darkred": "#8b0000",
	"darksalmon": "#e9967a",
	"darkseagreen": "#8fbc8f",
	"darkslateblue": "#483d8b",
	"darkslategray": "#2f4f4f",
	"darkturquoise": "#00ced1",
	"darkviolet": "#9400d3",
	"deeppink": "#ff1493",
	"deepskyblue": "#00bfff",
	"dimgray": "#696969",
	"dodgerblue": "#1e90ff",
	"firebrick": "#b22222",
	"floralwhite": "#fffaf0",
	"forestgreen": "#228b22",
	"fuchsia": "#ff00ff",
	"gainsboro": "#dcdcdc",
	"ghostwhite": "#f8f8ff",
	"gold": "#ffd700",
	"goldenrod": "#daa520",
	"gray": "#808080",
	"green": "#008000",
	"greenyellow": "#adff2f",
	"honeydew": "#f0fff0",
	"hotpink": "#ff69b4",
	"indianred ": "#cd5c5c",
	"indigo ": "#4b0082",
	"ivory": "#fffff0",
	"khaki": "#f0e68c",
	"lavender": "#e6e6fa",
	"lavenderblush": "#fff0f5",
	"lawngreen": "#7cfc00",
	"lemonchiffon": "#fffacd",
	"lightblue": "#add8e6",
	"lightcoral": "#f08080",
	"lightcyan": "#e0ffff",
	"lightgoldenrodyellow": "#fafad2",
	"lightgrey": "#d3d3d3",
	"lightgreen": "#90ee90",
	"lightpink": "#ffb6c1",
	"lightsalmon": "#ffa07a",
	"lightseagreen": "#20b2aa",
	"lightskyblue": "#87cefa",
	"lightslategray": "#778899",
	"lightsteelblue": "#b0c4de",
	"lightyellow": "#ffffe0",
	"lime": "#00ff00",
	"limegreen": "#32cd32",
	"linen": "#faf0e6",
	"magenta": "#ff00ff",
	"maroon": "#800000",
	"mediumaquamarine": "#66cdaa",
	"mediumblue": "#0000cd",
	"mediumorchid": "#ba55d3",
	"mediumpurple": "#9370d8",
	"mediumseagreen": "#3cb371",
	"mediumslateblue": "#7b68ee",
	"mediumspringgreen": "#00fa9a",
	"mediumturquoise": "#48d1cc",
	"mediumvioletred": "#c71585",
	"midnightblue": "#191970",
	"mintcream": "#f5fffa",
	"mistyrose": "#ffe4e1",
	"moccasin": "#ffe4b5",
	"navajowhite": "#ffdead",
	"navy": "#000080",
	"oldlace": "#fdf5e6",
	"olive": "#808000",
	"olivedrab": "#6b8e23",
	"orange": "#ffa500",
	"orangered": "#ff4500",
	"orchid": "#da70d6",
	"palegoldenrod": "#eee8aa",
	"palegreen": "#98fb98",
	"paleturquoise": "#afeeee",
	"palevioletred": "#d87093",
	"papayawhip": "#ffefd5",
	"peachpuff": "#ffdab9",
	"peru": "#cd853f",
	"pink": "#ffc0cb",
	"plum": "#dda0dd",
	"powderblue": "#b0e0e6",
	"purple": "#800080",
	"red": "#ff0000",
	"rosybrown": "#bc8f8f",
	"royalblue": "#4169e1",
	"saddlebrown": "#8b4513",
	"salmon": "#fa8072",
	"sandybrown": "#f4a460",
	"seagreen": "#2e8b57",
	"seashell": "#fff5ee",
	"sienna": "#a0522d",
	"silver": "#c0c0c0",
	"skyblue": "#87ceeb",
	"slateblue": "#6a5acd",
	"slategray": "#708090",
	"snow": "#fffafa",
	"springgreen": "#00ff7f",
	"steelblue": "#4682b4",
	"tan": "#d2b48c",
	"teal": "#008080",
	"thistle": "#d8bfd8",
	"tomato": "#ff6347",
	"turquoise": "#40e0d0",
	"violet": "#ee82ee",
	"wheat": "#f5deb3",
	"white": "#ffffff",
	"whitesmoke": "#f5f5f5",
	"yellow": "#ffff00",
	"yellowgreen": "#9acd32",
	// system colors
	"window": "#ffffff",
	"windowframe": "#000000",
	"windowtext": "#000000"
};

function colourNameToHex(color) {
	return colors[color.toLowerCase()];
}

function rtfContext() {
	return {
		open: function(key) {
			if (!this[key]) {
				this[key] = {};
				this[key].current = 0;
			}
			this[key].current++;
			this[key].pending = true;
			if (this[key].value && this[key].value[this[key].current - 1]) {
				this[key].value.pop();
			}
		},
		close: function(key) {
			this[key].current--;
			if (!this[key].current) this[key].pending = false;
			else this[key].pending = true;
		},
		current: function(key) {
			return (this[key] ? this[key].current : 0);
		},
		pending: function(key, val) {
			if (val !== undefined) {
				if (!this[key]) this[key] = {};
				this[key].pending = val;
			};
			return (this[key] ? this[key].pending : false);

		},
		value: function(key, val) {
			if (!this[key]) return 0;
			if (val !== undefined) {
				val = parseInt(val, 10);
				if (this[key].value === undefined) this[key].value = [];
				this[key].value.push(((this[key].current - 1) ? (this[key].value[this[key].current - 2] + val) : val));
				//this[key].value[this[key].current-1]=((this[key].current-2)? (this[key].value[this[key].current-2]+val):val);
			};
			// console.log("Value:" + this[key].value[this[key].current-1] + " val:"+val);
			return ((this[key] && this[key].value) ? this[key].value[this[key].current - 1] : 0);

		},
		nl: false,
		par: false,
		ulindent: 0
	};
};

function builder(documentModel) {
	var rtffonts = documentModel.fonts,
		colors = documentModel.colors,
		// deffont = null,
		rtftext = "",
		needSpace = false,
		ctx = rtfContext();

	function has(obj, key) {
		return Object.prototype.hasOwnProperty.call(obj, key);
	}

	function isEmpty(obj) {
		if (obj == null) return true;
		for (var key in obj)
			if (has(obj, key)) return false;
		return true;
	}

	if (!isEmpty(rtffonts)) {
		rtftext += "{\\fonttbl";
		Object.keys(rtffonts).forEach(function(key) {
			rtftext += "{\\" + key + " " + rtffonts[key].name + ";}";
		});
		rtftext += "}";
	}

	if (colors.length > 1) {
		rtftext += "{\\colortbl";
		colors.forEach(function(e) {
			if (e[0] === 0 && e[1] === 0 && e[2] === 0) {
				rtftext += ';';
			} else {
				rtftext += "\\red" + e[0] + "\\green" + e[1] + "\\blue" + e[2] + ";";
			}
		});
		rtftext += "}";
	}

	rtftext += "\\uc0\\pard";

	function fromHtmlTag(tag) {
		tag = tag.toLowerCase();
		switch (tag) {
			case "p":
				return "\\par";
			case "b":
				return "\\b";
			case "i":
				return "\\i";
			case "u":
				return "\\ul";
			case "s":
				return "\\strike";
			case "br":
				return "\\par";
			case "blockquote":
				return "";
				//	case "li":
				//		return "\\bullet";
			default:
				return ""; //<!-- " + tag + " -->"; "\\"+tag ;
		}
	}

	return {
		//header: function(){
		//	rtftext=header+rtftext ;
		//},
		open: function() {
			rtftext += "{";
			needSpace = false;
		},
		text: function(str) {
			var pos = 0,
				beg = pos,
				c;

			while (pos < str.length) {
				while (str.charCodeAt(pos) <= 128 && str.charCodeAt(pos) != 10) {
					pos++;
				}
				if (pos > beg) {
					rtftext += (needSpace ? " " : "") + str.substring(beg, pos);
				} else if (str.charCodeAt(pos) == 10) {
					rtftext += (needSpace ? " " : "");
				}
				needSpace = false;
				if (pos < str.length) {
					c = str.charCodeAt(pos);
					// replace nbsp and \n by space
					if (c === 160 || c === 10) {
						rtftext += " ";
					} else {
						this.controlarg("u", str.charCodeAt(pos));
					}
					pos++;
				}
				beg = pos;
			}
		},
		fragment: function(str) {
			rtftext += str;
			needSpace = false;
		},
		font: function(fid) {
			if (fid !== "") {
				rtftext += "\\" + fid;
				needSpace = true;
			}
		},
		controlarg: function(word, arg) {
			rtftext += "\\" + word + arg;
			needSpace = true;
		},
		control: function(word) {
			ctx.par = (word == "par");
			rtftext += "\\" + word;
			needSpace = true;
		},
		htmltag: function(word) {
			var rtf = fromHtmlTag(word);
			if (rtf) {
				ctx.par = (rtf == "\\par");
			}
			rtftext += rtf;
			needSpace = true;
		},
		star: function() {
			rtftext += "\\*";
			needSpace = false;
		},
		close: function() {
			if (!ctx.par) rtftext += "\\par";
			rtftext = "{\\rtf1\\ansi" + rtftext + "}";
			needSpace = false;
		},
		getRtf: function() {
			return rtftext;
		},
		context: ctx
	};
}

var tagMap = {
	"margin-left": "li",
	"margin-right": "ri",
	"margin-top": "sb",
	"margin-bottom": "sa"
},
	toTwips = (function(unit, v) {
		// see http://publib.boulder.ibm.com/infocenter/domhelp/v8r0/index.jsp?topic=%2Fcom.ibm.productivity.tools.help%2Ftext%2Fcommon%2F00%2F00000003.html
		var ratio = {
			"pt": 20,
			"px": 15,
			"mm": 56.7,
			"cm": 567,
			"in": 1440.18
		};

		return function(unit, v) {
			return v * (ratio[unit] || ratio["px"]);
		};
	})();

exports.buildRtf = function(html) {
	var documentModel = {};
	documentModel.deffont = "";
	documentModel.fonts = {};
	documentModel.colors = [];
	documentModel.styles = {};
	var fontfamgroups = {
		fnil: "Sans-serif",
		froman: "Sans-serif",
		fswiss: "Serif",
		fmodern: "Monospace",
		fscript: "Cursive",
		fdecor: "Cursive"
	};
	var align = {
		left: "ql",
		center: "qc",
		right: "qr",
		justify: "qj"
	};
	var pointPxTable = [{
		pt: 6,
		px: 7
	}, {
		pt: 7,
		px: 9
	}, {
		pt: 40,
		px: 50
	}];
	var bld;
	var $root = $('<div>').append(html);
	//var $root = $(html);
	var rtffonts = [];
	//var first = false ;
	function findColor(arr, obj) {
		if (!obj) return -1;
		for (var i = 0; i < arr.length; i++) {
			if (arr[i][0] == obj[0] && arr[i][1] == obj[1] && arr[i][2] == obj[2]) {
				return i;
			}
		}
		return -1;
	}

	function isLeftIndent(n) {
		return ($(n).is("div[style]") ? ($(n).attr('style').search("margin-left") > -1) : false);
	}

	function addFont(face) {
		rtffonts.indexOf(face) < 0 && rtffonts.push(face);
	}

	function findFont(fontname) {
		var fonts = documentModel.fonts,
			keys = Object.keys(fonts);
		for (var i = 0; i < keys.length; i++) {
			if (fonts[keys[i]].name === fontname) return keys[i];
		}
		return "";
	}

	function isList(n) {
		return (($(n).is("ul") || $(n).is("li")) || (n.childElementCount > 0 && n.firstChild.nodeName === "UL"));
	}

	function processNode(n, i) {
		var clr, idx, colorid;
		//console.log(((n.nodeType!==3)?n.nodeName:n.nodeValue) + " " + (n.id?n.id:""))
		if (bld.context.pending("blockquote") && !bld.context.current("list") && !$(n).is("blockquote") && !$(n).is("div") && !bld.context.current("list") && !isList(n)) {
			bld.control("li" + (bld.context.current("blockquote") * 600));
			bld.context.pending("blockquote", false);
		}
		if (n.nodeType === 3) { // TEXT node
			bld.text(n.nodeValue);
			bld.context.par = false;
			if (n.nextSibling && $(n.nextSibling).is("blockquote")) {
				bld.control("par");
			}
		} else if ($(n).is("*[style]") && !$(n).is("blockquote")) {
			var rules = $(n).attr('style').split(';');
			var drill = !(($(n).attr('style').search("text-align") > -1) && ($(n).attr('style').search("margin-left") > -1)),
				tal = null;
			if (n.nodeName == "B") {
				bld.htmltag(n.nodeName);
			}
			rules.forEach(function(e) {
				var stylerule = e.split(':');
				if (stylerule[0] != null) stylerule[0] = stylerule[0].replace(/^\s*/, '').replace(/\s*$/, '');
				if (stylerule[1] != null) stylerule[1] = stylerule[1].replace(/^\s*/, '').replace(/\s*$/, '');
				switch (stylerule[0]) {
					case 'color':
						if (stylerule[1].substring(0, 3) === 'rgb') {
							clr = rgbColor(stylerule[1]);
							idx = findColor(documentModel.colors, clr);
						} else {
							idx = findColorInColortbl(stylerule[1]);
						}

						colorid = "cf";
						bld.controlarg(colorid, idx);
						break;

					case 'background-color':
						if (stylerule[1].substring(0, 3) === 'rgb') {
							clr = rgbColor(stylerule[1]);
							idx = findColor(documentModel.colors, clr);
						} else {
							idx = findColorInColortbl(stylerule[1]);
						}

						colorid = "highlight";
						bld.controlarg(colorid, idx);
						break;

					case 'text-decoration':
						if (stylerule[1] === 'underline') bld.control('ul');
						else if (stylerule[1] === 'line-through') bld.control('strike');
						break;
					case 'font-style':
						if (stylerule[1] === 'italic') bld.control('i');
						break;
					case 'font-weight':
						if (stylerule[1] === 'bold') bld.control('b');
						break;

					case 'font-size':
						var tmp = $(n).attr("style");
						var m = /([0-9\.\-]+)([A-Za-z]*)/g.exec(stylerule[1]),
							unit = m[2] && m[2].toLowerCase();
						//console.log(unit)
						if (unit != "em") {
							var points = parseFloat(stylerule[1]);
							var halfpoints = Math.round(points * 2);
							bld.controlarg("fs", halfpoints);
							bld.context.fs = true;
						}
						break;
					case 'margin-left':
						var m = /([0-9\.\-]+)([A-Za-z]*)/g.exec(stylerule[1]),
							unit = m[2] && m[2].toLowerCase() || "px",
							val = parseInt(m[1], 10);
						if ($(n).is("ul")) {
							bld.context.ulindent = val / 40;
							bld.context.open("list");
						} else if ($(n).is("div") || $(n).is("p")) {
							bld.context.open("lindent");
							bld.context.value("lindent", val);
							bld.controlarg(tagMap[stylerule[0]], toTwips(unit, bld.context.value("lindent")));
							//bld.context.pending("lindent",false)
							if (tal) {
								bld.control(align[tal]);
							}
						};
						if (drill) {
							$(n).contents().each(visit);
							if (n.nodeName === "P") {
								bld.context.close("lindent");
								bld.control("par");
							} else if (n.nodeName === "DIV") {
								bld.context.close("lindent");
							};
							if (bld.context.current("lindent")) {
								bld.controlarg(tagMap[stylerule[0]], toTwips(unit, bld.context.value("lindent")));
							} else {
								bld.control("pard");
							}
							//bld.context.pending("lindent",false)
						};
						drill = true;
						break;
					case 'margin-right':
					case 'margin-top':
					case 'margin-bottom':
						var m = /([0-9\.\-]+)([A-Za-z]*)/g.exec(stylerule[1]),
							unit = m[2] && m[2].toLowerCase() || "px",
							val = parseInt(m[1], 10);
						bld.controlarg(tagMap[stylerule[0]], toTwips(unit, val));
						$(n).contents().each(visit);
						if (n.nodeName === "P") {
							bld.control("par");
						}
						bld.control("pard");
						break;
					case 'margin':
						$(n).contents().each(visit);
						if (n.nodeName === "P") {
							bld.control("par");
						}
						break;
					case 'text-align':
						if (drill) {
							bld.control("pard");
							var alignment = stylerule[1];
							bld.control(align[alignment]);
							$(n).contents().each(visit);
							bld.control("par");
							bld.control("pard");
						} else {
							tal = stylerule[1];
						}
						drill = true;
						break;
				}
			});
		} else if ($(n).is("font")) {
			if ($(n).is("font[face]")) {
				var face = $(n).attr("face");
				bld.font(findFont(face));
			}
			if ($(n).is("font[color]")) {
				idx = findColorInColortbl($(n).attr("color"));
				colorid = "cf"; //+ idx;
				bld.controlarg(colorid, idx);
			}
			if ($(n).is("font[bgcolor]")) {
				idx = findColorInColortbl($(n).attr("bgcolor"));
				colorid = "highlight"; //+ idx; //"cb"+(idx);
				bld.controlarg(colorid, idx);
			}
			//Even if "SIZE" attribute of "FONT" html tag is obsolete, when copy/paste from Word document, attribute could be present.
			if ($(n).is("font[size]")) {
				idx = findFontSize($(n).attr("size"));
				bld.controlarg("fs", idx);
			}
		} else if ($(n).is("div[align]")) {
			var alignment = $(n).attr("align");
			bld.control("pard");
			bld.control(align[alignment]);

			$(n).contents().each(visit);
			if (!(n.childElementCount > 0 && n.firstChild.nodeName === "P")) {
				bld.control("par");
			}
			bld.control("pard");
		} else if (n.nodeName === "UL") {
			bld.control("pard");
			bld.context.open("list");
		} else if (n.nodeName === "LI") {
			bld.fragment("{\\pntext");
			bld.font(findFont("Symbol"));
			bld.fragment("\\'B7\\tab}");
			if (bld.context.pending("list")) {
				var uls = bld.context.current("list") + bld.context.current("blockquote") + bld.context.ulindent;
				uls = uls + bld.context.current("lindent");
				bld.fragment("{\\*\\pn\\pnlvlblt\\pnf1\\pnindent0{\\pntxtb\\'B7}}\\f0\\li" + (uls * 420));
				bld.context.ulindent = 0;
				bld.context.pending("list", false);
			}
		} else if (n.nodeName === "P") {
			bld.control("par");
		} else {
			bld.htmltag(n.nodeName);
		}
	}

	function parseColor(color) {
		var match = /#(..)(..)(..)/.exec(color) || /#(..)(..)(..)/.exec(colourNameToHex(color));
		return match && match.slice(1).map(function(v) {
			return parseInt(v, 16);
		});
	}

	function findColorInColortbl(colorstr) {
		var parsedclr = parseColor(colorstr);
		/*if (parsedclr[0]==0 && parsedclr[1]==0 && parsedclr[2]==0)
			return 0 ;*/
		var idx = findColor(documentModel.colors, parsedclr);
		if (idx == -1) return -1;
		else return idx;
	}

	function findFontSize(size) {
		size = parseInt(size, 10);
		if (size < 0 || size > 7) return 0;
		return [0, 18, 20, 24, 28, 36, 48, 72][size];
	}

	function scan(n) {
		if (!n) return;
		n.each(visit);
	}

	function processColor(coln, atb) {
		coln.each(function(i, e) {
			var tmp = $(e).attr(atb);
			var rgb = parseColor(tmp);
			if (rgb && findColor(documentModel.colors, rgb) == -1) {
				documentModel.colors.push(rgb); /*(rgb[0]!=0 || rgb[1]!=0 || rgb[2]!=0) &&*/
			}
		});
	}

	function processColorStyle(coln) {
		var clr, idx;
		coln.each(function(i, e) {
			var s = $(e).attr("style"),
				styles = s && s.replace(/[\n\r]*\s*/g, '').split(';'),
				colorstyles = styles && styles.filter(function(e) {
					var rule = e.split(':');
					rule[0] = rule[0].replace(/^\s*/, '').replace(/\s*$/, '');
					return ['color', 'background-color', 'background'].indexOf(rule[0]) != -1;
				});

			var stylerule = colorstyles && colorstyles[0] && colorstyles[0].split(':');
			if (stylerule && stylerule[1]) {
				stylerule[1] = stylerule[1].replace(/^\s*/, '').replace(/\s*$/, '');
				if (stylerule[1].substring(0, 3) === 'rgb') {
					clr = rgbColor(stylerule[1]);
					idx = findColor(documentModel.colors, clr);
				} else {
					idx = findColorInColortbl(stylerule[1]);
					clr = parseColor(stylerule[1]);
				}
				if (idx == -1) {
					clr && documentModel.colors.push(clr);
				}
			}
		});
	}

	function extractFontsAndColors() {
		var fnts = $root.find('font[face]');
		var clrs = $root.find('font[color]');
		var bgclrs = $root.find('font[bgcolor]');
		var stylebgclrs = $root.find('*[style*="background-color"]');
		var styleclrs = $root.find('*[style*="color"]');
		addFont("MS Sans Serif"); //default
		fnts.each(function(i, e) {
			addFont($(e).attr("face"));
		});
		// For bullets
		if ($root.find("ul").length > 0) {
			addFont("Symbol");
		}

		// {\\f1\\fnil\\fcharset2 Symbol;		}
		/*if (documentModel.colors.length==0)
			documentModel.colors.push([0,0,0]) ;*/
		processColor(clrs, "color");
		processColor(bgclrs, "bgcolor");
		processColorStyle(stylebgclrs);
		processColorStyle(styleclrs);
	}

	function rgbColor(colorString) {
		var match = /\s*rgb\(\s*(\d+),\s*(\d+),\s*(\d+)\s*\);*/.exec(colorString);
		if (!match) return [];
		return match.slice(1).map(function(elt) {
			return parseInt(elt, 10);
		});
	}

	function visit(i, e) {
		var $e = $(e),
			$contents;
		//	    console.log("visit >>>>>>>>" + ((e.nodeType!==3)?e.nodeName:e.nodeValue) + " " + (e.id?e.id:""))
		if ($e.is("blockquote")) {
			bld.context.open("blockquote");
		} else if ($e.is("div[align]") || ($e.is('*[style*=text-align]') || $e.is('*[style*=margin]'))) {
			//console.log("div align || text-align || margin")
			processNode(e, i);
			if (e.nodeName === "UL" /*|| $e.is('div[style*=margin]')*/ ) {
				bld.control("pard");
			}
			return;
		}

		var grp, nl, sibling = e.nextSibling,
			crlf = (e.nodeName === "P" && e.childElementCount === 1 && e.firstChild.nodeName === "BR") //in somme case,on enter,  Chrome  can  build br in p;
			$contents = $e.contents();
		if (!$e.is("blockquote") && sibling && sibling.nodeName === "DIV" && !isLeftIndent(e) && !isLeftIndent(sibling)) {
			if (!(sibling.childElementCount > 0 && (sibling.firstChild.nodeName === "BR" || sibling.firstChild.nodeName === "P")) && !crlf) {
				nl = true;
			}
		} else if ($contents.length > 0 && sibling && !$e.is("ul") && !$e.is("li") && !$e.is("blockquote") && !$e.is("p")) {
			grp = true;
			bld.fragment("{");
		}
		if ($e.is("p[align]")) {
			var alignment = $e.attr("align");
			bld.control("pard");
			bld.control(align[alignment]);
		}
		if (!$e.is("p")) {
			processNode(e, i);
		}
		/*if (e.nodeName === "UL") {
			bld.control("pard");
		}*/
		$contents.each(visit);
		if (e.nodeName === "P" && !nl && !crlf) {
			processNode(e, i);
		}
		if (e.nodeName === "B" || $e.is('*[style*=font-weight]')) {
			bld.control("b0");
		}
		if (e.nodeName === "U" || $e.is('*[style*=text-decoration]')) {
			bld.control("ul0");
		}
		if ($e.is('*[style*=font-size]') && bld.context.fs) {
			bld.context.fs = false;
			if (!grp) {
				bld.control("fs16");
			}
		}
		if (e.nodeName === "I" || $e.is('*[style*=font-style]')) {
			bld.control("i0");
		}
		if ($e.is('*[style*=color]') && !$e.is('*[style*=background-color]') && !grp) {
			bld.control("cf0");
		}
		if (e.nodeName === "UL") {
			bld.context.close("list");
			bld.control("pard");
			bld.context.par = true;
			if (bld.context.current("blockquote")) {
				bld.context.pending("blockquote", true);
			}
			if (bld.context.current("lindent") && e.nextSibling && e.nextSibling.nodeType === 3) {
				bld.control("li" + toTwips("px", bld.context.value("lindent")));
			}
		} else if ($e.is("li")) {
			bld.control("par");
		}

		if (grp) {
			bld.fragment("}");
		}
		if ($e.is("blockquote") && bld.context.current("blockquote")) {
			if (bld.context.pending("blockquote")) {
				bld.context.close("blockquote");
				if (!bld.context.current("blockquote") && sibling && !$(sibling).html()) {
					bld.context.nl = true;
				}
			} else {
				if (!bld.context.par) {
					bld.control("par");
				}
				bld.control("pard");
				bld.context.close("blockquote");
			}
		}
		if (nl || bld.context.nl) {
			bld.context.nl = false;
			bld.control("par");
		}
	}

	function createFontTable() {
		var fname;
		for (var i = 0; i < rtffonts.length; i++) {
			fname = "f" + i;
			documentModel.fonts[fname] = {
				name: rtffonts[i]
			};
		}
	}

	documentModel.colors.push([0, 0, 0]);
	extractFontsAndColors();
	createFontTable();
	bld = builder(documentModel);
	//bld.header() ;
	//console.log("buildRtf --->"+$root.html());
	scan($root);

	bld.close();
	var rtftxt = bld.getRtf();
	//console.log("buildRtf --->"+rtftxt);
	return rtftxt;
};
});

define('syracuse-tablet/html/js/helpers/syracuse-rtf/lib/index',['require','exports','module','./rtfparse','./rtfinterpret','./buildhtml','./buildrtf'],function (require, exports, module) {
var rtfParser = require("./rtfparse"),
	rtfInterpreter = require("./rtfinterpret"),
	htmlBuilder = require("./buildhtml"),
	rtfBuilder = require("./buildrtf");

/// !doc
/// # RTF converter
/// Helper functions to convert RTF text from and to HTML.
/// 
/// `var convert = require('syracuse-rtf');`  
/// `var html = convert.toHtml(rtf, options);`  
/// `var rtf = convert.fromHtml(html, options);`  
// will see about options later
module.exports = {
	toHtml: function(rtf, options) {
		rtf = rtf || "";
		var root = rtfParser.parse(rtf);
		var model = rtfInterpreter.interpret(root);
		return htmlBuilder.buildHtml(root, model);
	},
	fromHtml: function(html, options) {
		return rtfBuilder.buildRtf(html);
	}
};
});

define('syracuse-tablet/html/js/helpers/syracuse-rtf/index',['require','exports','module','./lib/index'],function (require, exports, module) {
module.exports = require('./lib/index');
});

define('syracuse-tablet/html/js/controls/field/ctrlText',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/helpers/html-escape/index','syracuse-tablet/html/js/ajax/ajax','syracuse-tablet/html/js/helpers/syracuse-rtf/index'],function (require, exports, module) {
var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var escaper = require('syracuse-tablet/html/js/helpers/html-escape/index').escaper({
	warn: console.warn.bind(console),
	allowedAttributes: ["style"],
	allowedTags: ["span"]
});
var ajax = require('syracuse-tablet/html/js/ajax/ajax').getAjax().ajax;
var rtf = require('syracuse-tablet/html/js/helpers/syracuse-rtf/index');

var _baseHeight = 34; // based on input height within the app

var _templates = {
	expander: '\
		<button type="button" class="btn" data-action="toggleText" data-control-id="{{ctrlId}}>{{label}}</button>'
};

/**
 * Text field
 * authoring:
 * 		$height	set the height of the image - default is _defHeight
 */
var _Klass = utils.defineClass(

	function CtrlText(controller, article, prototype, options) {
		var self = this;

		// set label position default top
		// TODO build a function to apply default authoring parameters ...
		if (article && !article.$labelPosition) {
			article.$labelPosition = "top";
		}

		Base.call(self, controller, article, prototype, options);
		self.cssType = "s-m-clob";
	}, Base, {
		_getHeightPixelValue: function(authH) {
			switch (authH) {
				case "medium":
					return 2 * _baseHeight;
				case "large":
					return 4 * _baseHeight;
				case "xlarge":
					return 8 * _baseHeight;
				default:
					return _baseHeight;
			}
		},
		buildFieldValue: function(parentSlot, buildOptions) {
			var self = this;
			var value = self.getFormattedValue(self.getValue());

			// Create the enriched text content under the standard s-m-value parent
			var parent = Base.prototype.buildFieldValue.call(self, parentSlot, buildOptions);

			// enriched text container div
			var $$container = $('<section><div class="s-m-enriched-text"></div></section>').appendTo(parent).children(":first-child");

			// dom element which will contain the text
			var $$textContent = $(uiUtils.createDomElement("div", ["s-m-enriched-text-content"], null, null, $$container));

			/**
			 * !!! It's mandatory to have a fixed height for $$container because we need it to calculate the height of the page
			 * If no height is specified it will be set after the data has been loaded (too late)
			 */
			self.authH = self.getAuthoring("$textHeight", "medium");
			self.authH = self._getHeightPixelValue(self.authH);




			var docUrl = self.prototype.data("$url", self.getDao()) || "";
			ajax("GET", docUrl, null, null, {
				noJsonParsing: true
			}).then(function(result) {
				var responseText = result.responseText || "";

				if (!responseText || responseText === "") {
					$$container.remove();
					return;
				}

				// put text content
				var $$dataArr = [];
				switch (self.$type) {
					case "text/plain":
						self.buildFieldFromPlain(responseText, $$textContent);
						break;
					case "text/html":
						self.buildFieldFromHtml(responseText, $$textContent);
						break;
					case "text/rtf":
						self.buildFieldFromRtf(responseText, $$textContent);
						break;
				}

				/*
				 *	Set text-content height so that line of text is not half cut.
				 *	We use text line-height css property value
				 */
				var lineheight = parseInt($$textContent.css("line-height").replace("px", ""), 10);
				var multiplier = Math.floor(self.authH / lineheight);
				self.computedHeight = lineheight * multiplier;

				$$textContent.css({
					height: self.computedHeight + "px"
				});

				self.appendExpander($$textContent);
			}).fail(function(e) {
				self.insertError(e.message);
			});
		},

		/*
		 *	Append an expander button for the text field.
		 *	Button is appended only if full text height (scrollheight) is higher than self.authH by at least 5px
		 */
		appendExpander: function($$container) {
			var self = this;
			if ($$container.get(0).scrollHeight > self.computedHeight && (($$container.get(0).scrollHeight - self.computedHeight) > 5)) {

				// build expander button
				var buttonTmpl = '<button type="button" class="btn" data-action="toggleText"\
				data-control-id="' + self.id + '"\
				data-params="more">' + locale.text("field.text.seemore") + '</button>';

				var $$expander = self.$$expander = $(buttonTmpl);

				// append the button
				$$expander.insertAfter($$container);

				$$expander.css("float", "right");

				$$expander.wrap("<div class='s-m-enriched-text-expander'></div>");

				$$expander.parent().height($$expander.outerHeight());
			}
		},
		/*
		 * Toggle enriched text. It will either show more or hide
		 */
		_actToggleText: function(param) {
			var self = this;
			// show whole text field
			// change button label
			if (param === "more") {
				self.$$elmt.find(".s-m-enriched-text-content").css({
					height: "auto"
				});
				self.$$expander.text(locale.text("field.text.seeless"));
				self.$$expander.attr("data-params", "less");
			}
			// decrease text field height
			else {
				self.$$elmt.find(".s-m-enriched-text-content").css({
					height: self.computedHeight + "px"
				});
				self.$$expander.text(locale.text("field.text.seemore"));
				self.$$expander.attr("data-params", "more");
			}
			uiUtils.triggerResizeInternal({
				preserveScroll: true
			});
		},
		/**
		 * Display an error
		 */
		insertError: function(html) {
			var err = ['<div class="s-m-error">'];
			err.push(html);
			err.push("</div>");
			$(err.join('')).appendTo(this.$$elmt);
		},
		buildFieldFromPlain: function(data, $$parent) {
			$$parent.append($.parseHTML(escaper(data.replace(/\n/g, "<BR/>"))));
		},
		buildFieldFromRtf: function(data, $$parent) {
			this.buildFieldFromHtml(rtf.toHtml(data), $$parent);
		},
		buildFieldFromHtml: function(data, $$parent) {
			$$parent.append($.parseHTML(escaper(data)));
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/ctrlIcon',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/controls/ctrlBase'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var ctrlBase = require('syracuse-tablet/html/js/controls/ctrlBase');
var Base = ctrlBase.Klass;

/**
 * Icon used by arrays
 * Displays an icon according to the value of $icon in prototype
 * prototype properties
 * 		$url to attach a link to the icon
 * 		$action to attach an action/navigation to the icon
 * 			Contains all the parameters for the link (data-action, data-params...)
 */
var _Klass = utils.defineClass(

	function CtrlIcon(controller, article, prototype) {
		Base.call(this, controller, article, prototype);
	}, Base, {

		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions, ["s-m-icon"]);
			self.$$elmt.html(ctrlBase.genHtmlCtrlLink(self.prototype, controllerDao, {
				tag: 'a',
				css: ''
			}, function(html) {
				html.push('<span class="');
				html.push(fontUtils.ctrlIcon(self.prototype.data('$icon')));
				html.push('"></span>');
			}));
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/ctrlButton',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/ui/fontUtils','syracuse-tablet/html/js/controls/ctrlBase'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var ctrlBase = require('syracuse-tablet/html/js/controls/ctrlBase');
var Base = ctrlBase.Klass;

/**
 * Icon used by arrays
 * Displays an icon according to the value of $icon in prototype
 * prototype properties
 * 		$url to attach a link to the icon
 * 		$action to attach an action/navigation to the icon
 * 			Contains all the parameters for the link (data-action, data-params...)
 */
var _Klass = utils.defineClass(

	function CtrlButton(controller, article, prototype) {
		Base.call(this, controller, article, prototype);
	}, Base, {

		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions, ["s-m-btn"]);
			self.$$elmt.html(ctrlBase.genHtmlCtrlLink(self.prototype, controllerDao, {
				tag: 'button',
				css: 'btn btn-info btn-large'
			}, function(html) {
				var param = self.prototype.data('$icon') || "";
				if (param.length > 0) html.push('<i class="' + fontUtils.ctrlIcon(self.prototype.data('$icon')) + '"></i>');
				param = self.prototype.data('$text') || "";
				if (param.length > 0) html.push(param);
			}));
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/chart/chartstheme',['require','exports','module'],function (require, exports, module) {

exports.ChartsTheme = {
	"colors": ["#2f7ed8", "#0d233a", "#8bbc21", "#910000", "#1aadce", "#492970", "#f28f43", "#77a1e5", "#c42525", "#a6c96a"],
	"symbols": ["circle", "diamond", "square", "triangle", "triangle-down"],
	"lang": {
		"loading": "Loading...",
		"months": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
		"shortMonths": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
		"weekdays": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
		"decimalPoint": ".",
		"numericSymbols": ["k", "M", "G", "T", "P", "E"],
		"resetZoom": "Reset zoom",
		"resetZoomTitle": "Reset zoom level 1:1",
		"thousandsSep": ","
	},
	"global": {
		"useUTC": true,
		"canvasToolsURL": "http://code.highcharts.com/3.0.2/modules/canvas-tools.js",
		"VMLRadialGradientURL": "http://code.highcharts.com/3.0.2/gfx/vml-radial-gradient.png"
	},
	"chart": {
		"borderColor": "#4572A7",
		"borderRadius": 5,
		"defaultSeriesType": "line",
		"ignoreHiddenSeries": true,
		"spacingTop": 10,
		"spacingRight": 10,
		"spacingBottom": 15,
		"spacingLeft": 10,
		"style": {
			"fontFamily": "\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif",
			"fontSize": "12px"
		},
		"backgroundColor": "#FFFFFF",
		"plotBorderColor": "#C0C0C0",
		"resetZoomButton": {
			"theme": {
				"zIndex": 20
			},
			"position": {
				"align": "right",
				"x": -10,
				"y": 10
			}
		}
	},
	"title": {
		"text": "Chart title",
		"align": "center",
		"y": 15,
		"style": {
			"color": "#666",
			"fontSize": "16px"
		}
	},
	"subtitle": {
		"text": "",
		"align": "center",
		"y": 30,
		"style": {
			"color": "#4d759e"
		}
	},
	"plotOptions": {
		"line": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": {
				"enabled": true,
				"lineWidth": 0,
				"radius": 4,
				"lineColor": "#FFFFFF",
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": "bottom"
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true
		},
		"area": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": {
				"enabled": true,
				"lineWidth": 0,
				"radius": 4,
				"lineColor": "#FFFFFF",
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": "bottom"
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true,
			"threshold": 0
		},
		"spline": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": {
				"enabled": true,
				"lineWidth": 0,
				"radius": 4,
				"lineColor": "#FFFFFF",
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": "bottom"
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true
		},
		"areaspline": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": {
				"enabled": true,
				"lineWidth": 0,
				"radius": 4,
				"lineColor": "#FFFFFF",
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": "bottom"
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true,
			"threshold": 0
		},
		"column": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": null,
				"x": 0,
				"y": null,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null
			},
			"cropThreshold": 50,
			"pointRange": null,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": 0.1,
					"shadow": false
				},
				"select": {
					"marker": {

					},
					"color": "#C0C0C0",
					"borderColor": "#000000",
					"shadow": false
				}
			},
			"stickyTracking": false,
			"borderColor": "#FFFFFF",
			"borderWidth": 1,
			"borderRadius": 0,
			"groupPadding": 0.2,
			"pointPadding": 0.1,
			"minPointLength": 0,
			"threshold": 0
		},
		"bar": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": null,
				"x": 0,
				"y": null,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null
			},
			"cropThreshold": 50,
			"pointRange": null,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": 0.1,
					"shadow": false
				},
				"select": {
					"marker": {

					},
					"color": "#C0C0C0",
					"borderColor": "#000000",
					"shadow": false
				}
			},
			"stickyTracking": false,
			"borderColor": "#FFFFFF",
			"borderWidth": 1,
			"borderRadius": 0,
			"groupPadding": 0.2,
			"pointPadding": 0.1,
			"minPointLength": 0,
			"threshold": 0
		},
		"scatter": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 0,
			"marker": {
				"enabled": true,
				"lineWidth": 0,
				"radius": 4,
				"lineColor": "#FFFFFF",
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": "bottom"
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": false,
			"tooltip": {
				"headerFormat": "<span style=\"font-size: 10px; color:{series.color}\">{series.name}</span><br/>",
				"pointFormat": "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>",
				"followPointer": true
			}
		},
		"pie": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": true,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": "bottom",
				"distance": 30
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": false,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": 0.1,
					"shadow": false
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": false,
			"borderColor": "#FFFFFF",
			"borderWidth": 1,
			"center": [
				null, null
			],
			"clip": false,
			"colorByPoint": true,
			"ignoreHiddenPoint": true,
			"legendType": "point",
			"size": null,
			"slicedOffset": 10,
			"tooltip": {
				"followPointer": true
			}
		},
		"arearange": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 1,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null,
				"xLow": 0,
				"xHigh": 0,
				"yLow": 0,
				"yHigh": 0
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true,
			"threshold": null,
			"tooltip": {
				"pointFormat": "<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.low}</b> - <b>{point.high}</b><br/>"
			},
			"trackByArea": true
		},
		"areasplinerange": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 1,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null,
				"xLow": 0,
				"xHigh": 0,
				"yLow": 0,
				"yHigh": 0
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true,
			"threshold": null,
			"tooltip": {
				"pointFormat": "<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.low}</b> - <b>{point.high}</b><br/>"
			},
			"trackByArea": true
		},
		"columnrange": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 1,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null,
				"xLow": 0,
				"xHigh": 0,
				"yLow": 0,
				"yHigh": 0
			},
			"cropThreshold": 300,
			"pointRange": null,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": 0.1,
					"shadow": false
				},
				"select": {
					"marker": {

					},
					"color": "#C0C0C0",
					"borderColor": "#000000",
					"shadow": false
				}
			},
			"stickyTracking": true,
			"borderColor": "#FFFFFF",
			"borderWidth": 1,
			"borderRadius": 0,
			"groupPadding": 0.2,
			"pointPadding": 0.1,
			"minPointLength": 0,
			"threshold": null,
			"tooltip": {
				"pointFormat": "<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.low}</b> - <b>{point.high}</b><br/>"
			},
			"trackByArea": true
		},
		"gauge": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 2,
			"marker": {
				"enabled": true,
				"lineWidth": 0,
				"radius": 4,
				"lineColor": "#FFFFFF",
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": true,
				"align": "center",
				"x": 0,
				"y": 5,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "16px",
					"lineHeight": "24px",
					"fontWeight": "normal"
				},
				"verticalAlign": "top",
				"borderWidth": 0,
				"borderColor": null,
				"borderRadius": 3,
				"zIndex": 2
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": false,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": true,
			"dial": {

			},
			"pivot": {

			},
			"tooltip": {
				"style": {
					"color": "#666"
				},
				"headerFormat": ""
			}
		},
		"boxplot": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 1,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": null,
				"x": 0,
				"y": null,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null
			},
			"cropThreshold": 50,
			"pointRange": null,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": -0.3,
					"shadow": false
				},
				"select": {
					"marker": {

					},
					"color": "#C0C0C0",
					"borderColor": "#000000",
					"shadow": false
				}
			},
			"stickyTracking": false,
			"borderColor": "#FFFFFF",
			"borderWidth": 1,
			"borderRadius": 0,
			"groupPadding": 0.2,
			"pointPadding": 0.1,
			"minPointLength": 0,
			"threshold": null,
			"fillColor": "#FFFFFF",
			"medianWidth": 2,
			"tooltip": {
				"pointFormat": "<span style=\"color:{series.color};font-weight:bold\">{series.name}</span><br/>Minimum: {point.low}<br/>Lower quartile: {point.q1}<br/>Median: {point.median}<br/>Higher quartile: {point.q3}<br/>Maximum: {point.high}<br/>"
			},
			"whiskerLength": "50%",
			"whiskerWidth": 2
		},
		"errorbar": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 1,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": null,
				"x": 0,
				"y": null,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null
			},
			"cropThreshold": 50,
			"pointRange": null,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": -0.3,
					"shadow": false
				},
				"select": {
					"marker": {

					},
					"color": "#C0C0C0",
					"borderColor": "#000000",
					"shadow": false
				}
			},
			"stickyTracking": false,
			"borderColor": "#FFFFFF",
			"borderWidth": 1,
			"borderRadius": 0,
			"groupPadding": 0.2,
			"pointPadding": 0.1,
			"minPointLength": 0,
			"threshold": null,
			"fillColor": "#FFFFFF",
			"medianWidth": 2,
			"tooltip": {
				"pointFormat": "<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.low}</b> - <b>{point.high}</b><br/>"
			},
			"whiskerLength": "50%",
			"whiskerWidth": null,
			"color": "#000000",
			"grouping": false,
			"linkedTo": ":previous"
		},
		"waterfall": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 1,
			"marker": null,
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": null,
				"x": 0,
				"y": null,
				"style": {
					"color": "#666",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px"
				},
				"verticalAlign": null
			},
			"cropThreshold": 50,
			"pointRange": null,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					},
					"brightness": 0.1,
					"shadow": false
				},
				"select": {
					"marker": {

					},
					"color": "#C0C0C0",
					"borderColor": "#000000",
					"shadow": false
				}
			},
			"stickyTracking": false,
			"borderColor": "#333",
			"borderWidth": 1,
			"borderRadius": 0,
			"groupPadding": 0.2,
			"pointPadding": 0.1,
			"minPointLength": 0,
			"threshold": 0,
			"lineColor": "#333",
			"dashStyle": "dot"
		},
		"bubble": {
			"allowPointSelect": false,
			"showCheckbox": false,
			"animation": {
				"duration": 1000
			},
			"events": {

			},
			"lineWidth": 0,
			"marker": {
				"enabled": true,
				"lineWidth": 1,
				"radius": 4,
				"lineColor": null,
				"states": {
					"hover": {
						"enabled": true
					},
					"select": {
						"fillColor": "#FFFFFF",
						"lineColor": "#000000",
						"lineWidth": 2
					}
				}
			},
			"point": {
				"events": {

				}
			},
			"dataLabels": {
				"enabled": false,
				"align": "center",
				"x": 0,
				"y": 0,
				"style": {
					"color": "white",
					"cursor": "default",
					"fontSize": "11px",
					"lineHeight": "14px",
					"textShadow": "0px 0px 3px black"
				},
				"verticalAlign": "middle",
				"inside": true
			},
			"cropThreshold": 300,
			"pointRange": 0,
			"showInLegend": true,
			"states": {
				"hover": {
					"marker": {

					}
				},
				"select": {
					"marker": {

					}
				}
			},
			"stickyTracking": false,
			"tooltip": {
				"headerFormat": "<span style=\"font-size: 10px; color:{series.color}\">{series.name}</span><br/>",
				"pointFormat": "({point.x}, {point.y}), Size: {point.z}",
				"followPointer": true
			},
			"minSize": 8,
			"maxSize": "20%",
			"zThreshold": 0
		}
	},
	"labels": {
		"style": {
			"position": "absolute",
			"color": "#3E576F"
		}
	},
	"legend": {
		"enabled": true,
		"align": "center",
		"layout": "horizontal",
		"borderWidth": 1,
		"borderColor": "#909090",
		"borderRadius": 5,
		"navigation": {
			"activeColor": "#274b6d",
			"inactiveColor": "#CCC"
		},
		"shadow": false,
		"itemStyle": {
			"cursor": "pointer",
			"color": "#274b6d",
			"fontSize": "12px"
		},
		"itemHoverStyle": {
			"color": "#000"
		},
		"itemHiddenStyle": {
			"color": "#CCC"
		},
		"itemCheckboxStyle": {
			"position": "absolute",
			"width": "13px",
			"height": "13px"
		},
		"symbolWidth": 16,
		"symbolPadding": 5,
		"verticalAlign": "bottom",
		"x": 0,
		"y": 0,
		"title": {
			"style": {
				"fontWeight": "bold"
			}
		}
	},
	"loading": {
		"labelStyle": {
			"fontWeight": "bold",
			"position": "relative",
			"top": "1em"
		},
		"style": {
			"position": "absolute",
			"backgroundColor": "white",
			"opacity": 0.5,
			"textAlign": "center"
		}
	},
	"tooltip": {
		"enabled": true,
		"animation": true,
		"backgroundColor": "rgba(255, 255, 255, .85)",
		"borderWidth": 1,
		"borderRadius": 3,
		"dateTimeLabelFormats": {
			"millisecond": "%A, %b %e, %H:%M:%S.%L",
			"second": "%A, %b %e, %H:%M:%S",
			"minute": "%A, %b %e, %H:%M",
			"hour": "%A, %b %e, %H:%M",
			"day": "%A, %b %e, %Y",
			"week": "Week from %A, %b %e, %Y",
			"month": "%B %Y",
			"year": "%Y"
		},
		"headerFormat": "<span style=\"font-size: 10px\">{point.key}</span><br/>",
		"pointFormat": "<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.y}</b><br/>",
		"shadow": true,
		"snap": 10,
		"style": {
			"color": "#333333",
			"cursor": "default",
			"fontSize": "12px",
			"padding": "8px",
			"whiteSpace": "nowrap"
		}
	},
	"credits": {
		"enabled": false,
		"text": "Highcharts.com",
		"href": "http://www.highcharts.com",
		"position": {
			"align": "right",
			"x": -10,
			"verticalAlign": "bottom",
			"y": -5
		},
		"style": {
			"cursor": "pointer",
			"color": "#909090",
			"fontSize": "9px"
		}
	}
};
});

define('syracuse-tablet/html/js/controls/field/ctrlGaugeChart',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/controls/field/ctrlFieldBase','syracuse-tablet/html/js/controls/chart/chartstheme'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var chartsTheme = require('syracuse-tablet/html/js/controls/chart/chartstheme').ChartsTheme;

var _Klass = utils.defineClass(function CtrlGaugeChart(controller, article, prototype, opts) {
	var self = this;
	Base.call(self, controller, article, prototype, opts);
	self.formatter = self.initFormatter();
	// css to add to fieldSlot elmt
	self.cssType = null;
}, Base, {

	/**
	 * Init the properties to allow reuse of this control
	 */
	initReuseProperties: function() {
		var self = this;
		Base.prototype.initReuseProperties.call(self);
	},
	_defaultGaugeSegments: [{
		propStart: 0,
		propEnd: 0.25,
		valStart: null,
		valEnd: null,
		color: '#41A940'
	}, {
		propStart: 0.25,
		propEnd: 0.75,
		valStart: null,
		valEnd: null,
		color: '#FF5800'
	}, {
		propStart: 0.75,
		propEnd: 1,
		valStart: null,
		valEnd: null,
		color: '#CB3500'
	}],
	buildFieldValue: function(fieldSlot, buildOptions) {
		var self = this;

		var localeDecimalSep = locale.getNumberDecimalSeparator();
		var localeThousandSep = locale.getNumberGroupSeparator();

		if (!self.chartsTheme) {
			self.chartsTheme = chartsTheme;
		}
		if (!self.chartsTheme.themeWasSet || self.chartsTheme.decimalPoint !== localeDecimalSep || self.chartsTheme.thousandsSep !== localeThousandSep) {
			self.chartsTheme.decimalPoint = localeDecimalSep;
			self.chartsTheme.thousandsSep = localeThousandSep;

			Highcharts.setOptions(self.chartsTheme);
			self.chartsTheme.themeWasSet = true;
		}

		self._renderGauge();
	},
	buildFieldTitle: function(fieldSlot, buildOptions) {
		// override because nothing to do
	},
	_resolveExpr: function(expr, data, cp) {
		if (typeof expr !== "string") return expr;
		return expr.replace(/\{(\w+)\}/g, function(d0, d1) {
			if (data[d1] != null) return data[d1];
			if (cp[d1] != null) return cp[d1];
			return d0;
		});
	},
	// Merge default values for gauge segments with data comming from the authoring
	_mergeAuthoringAndDefaults: function() {
		var self = this;
		var $gauge = self.article.$gauge;
		if (!$gauge.segments) // Not authoring on segments
			return self._defaultGaugeSegments;
		if ($gauge.segments.length === 0) // Not authoring on segments
			return self._defaultGaugeSegments;

		var s, def, auth, res = [];
		for (s = 0; s < $gauge.segments.length; s++) {
			def = self._defaultGaugeSegments[Math.min(s, self._defaultGaugeSegments.length - 1)];
			auth = $gauge.segments[s];
			if (!auth) {
				// no authoring for this segment, use default
				res.push(def);
			} else {
				if ((auth.propStart == null || auth.propEnd == null) && (auth.valStart == null || auth.valEnd == null)) {
					// not range defined, use default, not authoring
					auth.propStart = def.propStart;
					auth.propEnd = def.propEnd;
					auth.valStart = def.valStart;
					auth.valEnd = def.valEnd;
				}
				if (auth.color == null) {
					auth.color = def.color;
				}
				res.push(auth);
			}
		}
		return res;
	},
	// Create segment definitions for gauge
	_createBands: function(cp, valMin, valMax) {
		var self = this;
		var bands = [];

		// Grey background is always present
		bands.push({
			from: valMin,
			to: valMax,
			color: '#ccc',
			innerRadius: '79%',
			outerRadius: '101%'
		});

		var data = self.getValue();
		var bandsDef = self._mergeAuthoringAndDefaults();
		var seg;
		var s;
		var band;
		var range = valMax - valMin;
		for (s = 0; s < bandsDef.length; s++) {
			seg = bandsDef[s];
			band = {
				innerRadius: '79%',
				outerRadius: '101%',
				color: seg.color
			};
			if (seg.valStart != null && seg.valEnd != null) {
				band.from = self._resolveExpr(seg.valStart, data, cp);
				band.to = self._resolveExpr(seg.valEnd, data, cp);
			} else if (seg.propStart != null && seg.propEnd != null) {
				band.from = valMin + range * self._resolveExpr(seg.propStart, data, cp);
				band.to = valMin + range * self._resolveExpr(seg.propEnd, data, cp);
			}
			bands.push(band);
		}
		return bands;
	},
	_getScale: function() {
		var self = this;

		function getScaleFromFormat($format) {
			var match = $format.match(/\.(.*)/g);
			return match.length >= 1 ? match.length : 0;
		}

		if (self.article.$scale) {
			return self.article.$scale;
		} else {
			if (self.article.$format) {
				return getScaleFromFormat(self.article.$format);
			} else {
				return 0;
			}
		}
	},

	_renderGauge: function() {
		var self = this;

		var $$chartSlot = $(".s-m-gauge-container", self.$$elmt);
		if ($$chartSlot && $$chartSlot.length > 0) {
			$$chartSlot.remove();
		}

		$$chartSlot = $("<div>").addClass("s-m-gauge-container");
		self.$$elmt.append($$chartSlot);

		var gauge = self.article.$gauge;
		var labelColor = !self.$isEditMode ? "#34B233" : "#666";

		var val = self.getValue();
		var valMin = 0;
		var valMax = 100;

		if (gauge.$bindMin != null && gauge.$bindMax != null) {
			if (typeof gauge.$bindMin === "string") valMin = self.getDao().getValue(gauge.$bindMin);
			else valMin = gauge.$bindMin;
			if (typeof gauge.$bindMax === "string") valMax = self.getDao().getValue(gauge.$bindMax);
			else valMax = gauge.$bindMax;
		}

		try {
			if (typeof val === "string") val = parseFloat(val);
		} catch (e) {}
		try {
			if (typeof valMin === "string") valMin = parseFloat(valMin);
		} catch (e) {}
		try {
			if (typeof valMax === "string") valMax = parseFloat(valMax);
		} catch (e) {}

		var cp = self.prototype.json;

		var uom = "";
		if (cp.$unit && cp.$properties && cp.$properties[cp.$unit] && val && val[cp.$unit] && val[cp.$unit].$symbol) {
			uom = val[cp.$unit].$symbol;
		}

		var label = self.getTitle();
		var decimals = self._getScale();
		var plotBands = self._createBands(cp, valMin, valMax);

		self._calcDesiredHeight();
		var spacingBottom = 35;
		var height = self.desiredHeight;
		var centerA = "50%";
		var centerB = (height - 20) / height * 100 + "%";
		var size = height - 30;

		$$chartSlot.highcharts({
			chart: {
				type: 'gauge',
				plotBackgroundColor: null,
				plotBackgroundImage: null,
				plotBorderWidth: 0,
				plotShadow: false,
				backgroundColor: null,
				height: height,
				borderWidth: 0,
				spacingBottom: spacingBottom
			},
			title: {
				text: label,
				style: {
					color: labelColor,
					fontWeight: "normal",
					textTransform: "uppercase"
				},
				verticalAlign: "bottom",
				y: 27
			},
			pane: {
				startAngle: -90,
				endAngle: 90,
				center: [centerA, centerB],
				size: size,
				background: [{
					backgroundColor: '#FFF',
					borderWidth: 0
				}]
			},
			yAxis: {
				min: valMin,
				max: valMax,

				minorTickWidth: 1,
				minorTickInterval: 'auto',
				minorTickLength: 20,
				minorTickPosition: 'inside',
				minorTickColor: '#fff',

				tickPixelInterval: 30,
				tickWidth: 0,
				tickPosition: 'inside',
				tickLength: 15,
				tickColor: '#FFF',
				labels: {
					step: 1,
					rotation: 'auto',
					style: {
						color: "#666",
						cursor: "default",
						fontSize: "0.9em",
						fontFamily: "Arial",
						lineHeight: "14px"
					},
					distance: 10,
					y: 0,
					verticalAlign: 'center',
					align: 'center'
				},
				title: {
					text: uom,
					style: {
						color: "#666"
					}
				},
				plotBands: plotBands
			},
			plotOptions: {
				gauge: {
					dataLabels: {
						enabled: true,
						format: "{point.y:,." + decimals + "f}",
						style: {
							fontFamily: "Arial"
						}
					}
				}
			},
			exporting: {
				buttons: null
			},
			series: [{
				name: label,
				data: [val],
				tooltip: {
					valueSuffix: ' ' + uom
				}
			}]

		}, function() {});
	},
	onResize: function() {
		var self = this;
		self._renderGauge();
	},
	_calcDesiredHeight: function() {
		var self = this;
		var $$pscroll = self.$$elmt.closest(".s-m-scroll-wrapper");
		var isSingleChild = $(".s-m-control", $$pscroll).length < 2;
		var isInTile = $$pscroll.closest(".s-m-tile").length > 0;

		if (isInTile && isSingleChild) {
			// if we are the only control in a tile, we use up the full space
			var $$tile = $$pscroll.parent();
			self.desiredHeight = $$tile.height() - 20; // 20 for eventual header
		} else {
			// use a default size if there are other items or we are not in a tile
			self.desiredHeight = 200;
		}
	},
	destroy: function() {
		var self = this;
		Base.prototype.destroy.call(self);
		var $$chartSlot = $(".s-m-gauge-container", self.$$elmt);
		if ($$chartSlot && $$chartSlot.length > 0) {
			$$chartSlot.remove();
		}
	}
});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/array/ctrlRowStatus',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/controls/ctrlBase','syracuse-tablet/html/js/helpers/fieldOperators','syracuse-tablet/html/js/ui/fontUtils'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

/**
 * Display the row status in table array mode
 * Enabled by authoring 'manage a status'
 */
var _Klass = utils.defineClass(

	function CtrlRowStatus(controller, article, prototype) {
		Base.call(this, controller, article, prototype);
	}, Base, {
		buildHtml: function($$parent, rowData, buildOptions) {
			var self = this;
			var ctrlArray = buildOptions.htmlRootCtrl;
			if (!ctrlArray) return;
			var statusList = ctrlArray.getRowStatusInfo();
			if (!statusList) return;
			Base.prototype.buildHtml.call(self, $$parent, rowData, buildOptions, ["s-m-row-status"]);
			var h, defIcon = fontUtils.getArrayStatusDefIcon(),
				icon;
			statusList.some(function(s) {
				if (s.color && fieldOperators.evaluateOperator(s.$type, rowData.getValue(s.field), s.operator, s.value)) {
					icon = s.icon || defIcon;
					// We use background color for color icon
					self.$$elmt.html('<div class="' + icon.css + '" style="color:' + s.color.bgColor + '"/>');
					return true;
				}
			});
		}
	});

exports.Klass = _Klass;
});

define('syracuse-tablet/html/js/controls/ctrlFactoryDeps',['require','exports','module','syracuse-tablet/html/js/controls/field/ctrlAlphanum','syracuse-tablet/html/js/controls/field/ctrlAlphanum','syracuse-tablet/html/js/controls/field/ctrlAlphanum','syracuse-tablet/html/js/controls/field/ctrlAlphanum','syracuse-tablet/html/js/controls/field/ctrlProgress','syracuse-tablet/html/js/controls/field/ctrlNumeric','syracuse-tablet/html/js/controls/field/ctrlQuantity','syracuse-tablet/html/js/controls/field/ctrlCheckBox','syracuse-tablet/html/js/controls/field/ctrlCombo','syracuse-tablet/html/js/controls/field/ctrlDate','syracuse-tablet/html/js/controls/array/ctrlArray','syracuse-tablet/html/js/controls/field/ctrlReference','syracuse-tablet/html/js/controls/layout/layoutRow','syracuse-tablet/html/js/controls/layout/layoutStack','syracuse-tablet/html/js/controls/layout/layoutTab','syracuse-tablet/html/js/controls/layout/layoutHub','syracuse-tablet/html/js/controls/layout/layoutHubGroup','syracuse-tablet/html/js/controls/layout/layoutTile','syracuse-tablet/html/js/controls/layout/layoutCell','syracuse-tablet/html/js/controls/vignetteBase','syracuse-tablet/html/js/controls/page/ctrlBreadCrumbs','syracuse-tablet/html/js/controls/page/ctrlPageHeader','syracuse-tablet/html/js/controls/page/ctrlPageFooter','syracuse-tablet/html/js/controls/page/ctrlVignetteFooter','syracuse-tablet/html/js/controls/page/ctrlVignetteHeader','syracuse-tablet/html/js/controls/page/panels/pageActionPanelRegular','syracuse-tablet/html/js/controls/page/panels/sortfilter/filterSortPanel','syracuse-tablet/html/js/controls/page/panels/userpanelsmartphone','syracuse-tablet/html/js/controls/ctrlTypeUnknown','syracuse-tablet/html/js/controls/ctrlUnfound','syracuse-tablet/html/js/controls/chart/ctrlCubeChart','syracuse-tablet/html/js/controls/field/ctrlBinary','syracuse-tablet/html/js/controls/field/ctrlText','syracuse-tablet/html/js/controls/ctrlIcon','syracuse-tablet/html/js/controls/ctrlButton','syracuse-tablet/html/js/controls/field/ctrlGaugeChart','syracuse-tablet/html/js/controls/structElmt','syracuse-tablet/html/js/controls/array/ctrlRowStatus','syracuse-tablet/html/js/controls/ctrlFactory'],function (require, exports, module) {

var Alphanum = require('syracuse-tablet/html/js/controls/field/ctrlAlphanum').Klass;
var PhoneField = require('syracuse-tablet/html/js/controls/field/ctrlAlphanum').PhoneField;
var EmailField = require('syracuse-tablet/html/js/controls/field/ctrlAlphanum').EmailField;
var UrlField = require('syracuse-tablet/html/js/controls/field/ctrlAlphanum').UrlField;
var ProgressField = require('syracuse-tablet/html/js/controls/field/ctrlProgress').Klass;
var Numeric = require('syracuse-tablet/html/js/controls/field/ctrlNumeric').Klass;
var Quantity = require('syracuse-tablet/html/js/controls/field/ctrlQuantity').Klass;
var CheckBox = require('syracuse-tablet/html/js/controls/field/ctrlCheckBox').Klass;
var Combo = require('syracuse-tablet/html/js/controls/field/ctrlCombo').Klass;
var Date = require('syracuse-tablet/html/js/controls/field/ctrlDate').Klass;
var Array = require('syracuse-tablet/html/js/controls/array/ctrlArray').Klass;
var Reference = require('syracuse-tablet/html/js/controls/field/ctrlReference').Klass;
var LayoutRow = require('syracuse-tablet/html/js/controls/layout/layoutRow').Klass;
var LayoutStack = require('syracuse-tablet/html/js/controls/layout/layoutStack').Klass;
var LayoutTab = require('syracuse-tablet/html/js/controls/layout/layoutTab').Klass;
var LayoutHub = require('syracuse-tablet/html/js/controls/layout/layoutHub').Klass;
var LayoutHubGroup = require('syracuse-tablet/html/js/controls/layout/layoutHubGroup').Klass;
var LayoutTile = require('syracuse-tablet/html/js/controls/layout/layoutTile').Klass;
var LayoutCell = require('syracuse-tablet/html/js/controls/layout/layoutCell').Klass;
var Vignette = require('syracuse-tablet/html/js/controls/vignetteBase').Klass;
var BreadCrumbs = require('syracuse-tablet/html/js/controls/page/ctrlBreadCrumbs').Klass;
var PageHeader = require('syracuse-tablet/html/js/controls/page/ctrlPageHeader').Klass;
var PageFooter = require('syracuse-tablet/html/js/controls/page/ctrlPageFooter').Klass;
var VignetteFooter = require('syracuse-tablet/html/js/controls/page/ctrlVignetteFooter').Klass;
var VignetteHeader = require('syracuse-tablet/html/js/controls/page/ctrlVignetteHeader').Klass;
var PageActionPanelRegular = require('syracuse-tablet/html/js/controls/page/panels/pageActionPanelRegular').Klass;;
var FilterSortPanel = require('syracuse-tablet/html/js/controls/page/panels/sortfilter/filterSortPanel').Klass;
var UserPanelSmartphone = require('syracuse-tablet/html/js/controls/page/panels/userpanelsmartphone').Klass;
var TypeUnknown = require('syracuse-tablet/html/js/controls/ctrlTypeUnknown').Klass;
var FieldUnfound = require('syracuse-tablet/html/js/controls/ctrlUnfound').Klass;
var CubeChart = require('syracuse-tablet/html/js/controls/chart/ctrlCubeChart').Klass;
var Binary = require('syracuse-tablet/html/js/controls/field/ctrlBinary').Klass;
var EnrichedText = require('syracuse-tablet/html/js/controls/field/ctrlText').Klass;
var Icon = require('syracuse-tablet/html/js/controls/ctrlIcon').Klass;
var Button = require('syracuse-tablet/html/js/controls/ctrlButton').Klass;
var Gauge = require('syracuse-tablet/html/js/controls/field/ctrlGaugeChart').Klass;
var StructElmt = require('syracuse-tablet/html/js/controls/structElmt').Klass;
var FieldRowStatus = require('syracuse-tablet/html/js/controls/array/ctrlRowStatus').Klass;

var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');

exports.init = function() {
	ctrlFactory.setImpl("Alphanum", Alphanum);
	ctrlFactory.setImpl("PhoneField", PhoneField);
	ctrlFactory.setImpl("EmailField", EmailField);
	ctrlFactory.setImpl("UrlField", UrlField);
	ctrlFactory.setImpl("ProgressField", EmailField);
	ctrlFactory.setImpl("Numeric", Numeric);
	ctrlFactory.setImpl("Quantity", Quantity);
	ctrlFactory.setImpl("CheckBox", CheckBox);
	ctrlFactory.setImpl("Combo", Combo);
	ctrlFactory.setImpl("Date", Date);
	ctrlFactory.setImpl("Array", Array);
	ctrlFactory.setImpl("Reference", Reference);
	ctrlFactory.setImpl("LayoutRow", LayoutRow);
	ctrlFactory.setImpl("LayoutStack", LayoutStack);
	ctrlFactory.setImpl("LayoutTab", LayoutTab);
	ctrlFactory.setImpl("LayoutHub", LayoutHub);
	ctrlFactory.setImpl("LayoutHubGroup", LayoutHubGroup);
	ctrlFactory.setImpl("LayoutTile", LayoutTile);
	ctrlFactory.setImpl("LayoutCell", LayoutCell);
	ctrlFactory.setImpl("Vignette", Vignette);
	ctrlFactory.setImpl("BreadCrumbs", BreadCrumbs);
	ctrlFactory.setImpl("PageHeader", PageHeader);
	ctrlFactory.setImpl("PageFooter", PageFooter);
	ctrlFactory.setImpl("VignetteFooter", VignetteFooter);
	ctrlFactory.setImpl("VignetteHeader", VignetteHeader);
	ctrlFactory.setImpl("PageActionPanelRegular", PageActionPanelRegular);
	ctrlFactory.setImpl("UserPanelSmartphone", UserPanelSmartphone);
	ctrlFactory.setImpl("FilterSortPanel", FilterSortPanel);
	ctrlFactory.setImpl("TypeUnknown", TypeUnknown);
	ctrlFactory.setImpl("FieldUnfound", FieldUnfound);
	ctrlFactory.setImpl("CubeChart", CubeChart);
	ctrlFactory.setImpl("Binary", Binary);
	ctrlFactory.setImpl("Text", EnrichedText);
	ctrlFactory.setImpl("Icon", Icon);
	ctrlFactory.setImpl("Gauge", Gauge);
	ctrlFactory.setImpl("Button", Button);
	ctrlFactory.setImpl("StructElmt", StructElmt);
	ctrlFactory.setImpl("FieldRowStatus", FieldRowStatus);
};
});

define('syracuse-tablet/html/js/sdata/sdataSort',['require','exports','module'],function (require, exports, module) {

/*
 *
 */

function _sdataSortArray(data, proto, orderBy) {

	var comparators = [];
	var properties = (proto.$properties.$resources && proto.$properties.$resources.$item && proto.$properties.$resources.$item.$properties) || proto.$properties;

	orderBy.forEach(function(exp) {
		var prop = exp.property;
		var sort = ((exp.sort === "DESC" || exp.sort === "desc") ? "DESC" : "ASC");
		var type = (properties[prop] && properties[prop].$type) || "application/x-string";

		if (type === "application/x-decimal") {
			if (sort === "ASC") {
				try {
					comparators.push(function(a, b) {
						var vala = a[prop];
						var valb = b[prop];
						return (+vala) - (+valb);
					});
				} catch (e) {}
				return 0;
			} else {
				try {
					comparators.push(function(a, b) {
						var vala = a[prop];
						var valb = b[prop];
						return (+valb) - (+vala);
					});
				} catch (e) {}
				return 0;
			}
		} else {
			if (sort === "ASC") {
				comparators.push(function(a, b) {
					try {
						var vala = a[prop];
						var valb = b[prop];
						if (vala > valb) {
							return 1;
						} else if (vala < valb) {
							return -1;
						}
					} catch (e) {}
					return 0;
				});
			} else {
				comparators.push(function(a, b) {
					try {
						var vala = a[prop];
						var valb = b[prop];
						if (vala > valb) {
							return -1;
						} else if (vala < valb) {
							return 1;
						}
					} catch (e) {}
					return 0;
				});
			}
		}
	});

	data.sort(function(a, b) {
		var c = 0;
		for (var i = 0; i < comparators.length; i++) {
			c = comparators[i](a, b);
			if (c !== 0) {
				break;
			}
		}
		return c;
	});
}
exports.sdataSortArray = _sdataSortArray;
});

define('syracuse-tablet/html/js/sdata/sdataCache',['require','exports','module','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/storage/storage','syracuse-tablet/html/js/sdata/sdatawhere/parser','syracuse-tablet/html/js/sdata/sdatawhere/whereUtils','syracuse-tablet/html/js/sdata/sdataSort','syracuse-tablet/html/js/storage/localStorage'],function (require, exports, module) {

/*
 *
 */

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("SDataCache");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var storageModule = require('syracuse-tablet/html/js/storage/storage');
var parser = require('syracuse-tablet/html/js/sdata/sdatawhere/parser').Parser;
var whereUtils = require('syracuse-tablet/html/js/sdata/sdatawhere/whereUtils');
var sdataSort = require('syracuse-tablet/html/js/sdata/sdataSort');
var localStorage = require('syracuse-tablet/html/js/storage/localStorage');

// all storage entries created by the case will be prefixed with this to be able to empty the cache w/o removing settings
var _cachePrefix = "$cache_";
var _keyRegExp = /\{(.*?)\}/g;

function _SDataCache(storage) {
	this.storage = storage;
	this.context = null;
};

/*
 *
 */
var _SDataCacheClass = utils.defineClass(
	_SDataCache,
	null, {
		setContext: function(context) {
			log && log("Changing cache context: " + JSON.stringify(context));
			this.context = context;
		},

		cachePrefix: _cachePrefix,

		/**
		 * Put an instance of an sdata object into the cache
		 *
		 * Parameters:
		 * data
		 * {
		 *   $data: {} - Data to store in cache (mandatory)
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 *   $key: "mawal" - Key of data
		 * }
		 * Note that $proto OR $representation AND $key must be set
		 *
		 * Return:
		 * Resolve:
		 * null
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		put: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				if (!data.$data) {
					throw new Error("PUT: No data specified");
				}
				var repr;
				var key;
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
					key = self._getKeyValue(data.$data, $proto);
				} else if (data.$representation && data.$key) {
					repr = data.$representation;
					key = data.$key;
				} else {
					throw new Error("PUT: Neither proto nor representation and key specified");
				}
				self.storage.put({
					$context: self.context,
					$collection: _cachePrefix + repr,
					$endpoint: data.$endpoint,
					$key: key,
					$data: {
						$item: data.$data
					}
				}).then(function(result) {
					deferred.resolve();
				}).fail(function(error) {
					deferred.reject(error);
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 * Query an array of instances from cache
		 *
		 * Parameters:
		 * data
		 * {
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 *   $where: "user eq 'admin' - Optional where clause
		 *   $orderBy: [{ "property": "user", "sort" : "ASC"}, { "property": "login", "sort" : "desc"}] - Optional array of sort conditions
		 * }
		 * Note that $proto OR $representation must be set
		 *
		 * Return:
		 * Resolve:
		 * Matched instances of queried representation
		 * [
		 *   {},
		 *   {}
		 * ]
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		query: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var repr;
				log && log("Query by: " + JSON.stringify(data));
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
				} else if (data.$representation) {
					if (data.$where) {
						throw new Error("QUERY: Where clause parsing requires prototype");
					}
					if (data.$orderBy) {
						throw new Error("QUERY: Order by requires prototype");
					}
					repr = data.$representation;
				} else {
					throw new Error("QUERY: Neither proto nor representation specified");
				}
				self.storage.query({
					$context: self.context,
					$endpoint: data.$endpoint,
					$collection: _cachePrefix + repr
				}).then(function(result) {
					var res = [];
					if (data.$where) {
						var exp = parser.parse(data.$where);
						result.$data.forEach(function(item, i) {
							if (whereUtils.execWhere(item.$item, exp, $proto)) {
								var d = item.$item;
								var m = result.$metaData[i];
								d.$cache = {
									$lastRead: m.$lastRead,
									$lastUpdated: m.$lastUpdated
								};
								res.push(d);
							}
						});
					} else {
						result.$data.forEach(function(item, i) {
							var d = item.$item;
							var m = result.$metaData[i];
							d.$cache = {
								$lastRead: m.$lastRead,
								$lastUpdated: m.$lastUpdated
							};
							res.push(d);
						});
					}
					if (data.$orderBy) {
						sdataSort.sdataSortArray(res, $proto, data.$orderBy);
					}
					// Exception are handled by ou jq deferred hack
					deferred.resolve(res);
				}).fail(function(error) {
					deferred.reject(error);
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 * Read one instance from cache using given key
		 *
		 * Parameters:
		 * data
		 * {
		 *   $key: "abc~def" - Key of object to read
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 * }
		 * Note that $proto OR $representation must be set
		 *
		 * Return:
		 * Resolve:
		 * Instance for given key or null if no match
		 * { ... }
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		read: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var repr;
				if (!data.$key) {
					throw new Error("READ: No key specified");
				}
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
				} else if (data.$representation) {
					repr = data.$representation;
				} else {
					throw new Error("READ: Neither proto nor representation specified");
				}
				self.storage.read({
					$context: self.context,
					$collection: _cachePrefix + repr,
					$endpoint: data.$endpoint,
					$key: data.$key
				}).then(function(result) {
					if (result.$status === storageModule.StatusCodes.OK) {
						var res = result.$data.$item;
						res.$cache = {
							$lastRead: result.$metaData.$lastRead,
							$lastUpdated: result.$metaData.$lastUpdated
						};
						deferred.resolve(res);
					} else {
						deferred.resolve(null);
					}
				}).fail(function(error) {
					deferred.reject(error);
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 * Delete instance from cache by given key
		 *
		 * Parameters:
		 * data
		 * {
		 *   $key: "abc~def" - Key of object to read
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 * }
		 * Note that $proto OR $representation must be set
		 *
		 * Return:
		 * Resolve:
		 * null
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		remove: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var repr;
				if (!data.$key) {
					throw new Error("REMOVE: No key specified");
				}
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
				} else if (data.$representation) {
					repr = data.$representation;
				} else {
					throw new Error("READ: Neither proto nor representation specified");
				}
				self.storage.remove({
					$context: self.context,
					$collection: _cachePrefix + repr,
					$endpoint: data.$endpoint,
					$key: data.$key
				}).then(function() {
					deferred.resolve();
				}).fail(function(error) {
					deferred.reject(error);
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 *
		 */
		clearCache: function() {
			var deferred = $.Deferred();
			var self = this;
			var re = new RegExp(self.cachePrefix.replace(/([\$\_]+)/g, "\\$1"));
			try {
				self.storage.clearCollection({
					$context: self.context,
					$collection: re
				})
					.then(function() {
						deferred.resolve();
					}).fail(function(error) {
						deferred.reject(error);
					});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		_getProto: function(proto) {
			var itemProto = (proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
			// item type of query and lookup is e.g. $queryItem
			// We want to use the base $type here ($query or $lookup)
			itemProto.$type = proto.$type;
			return itemProto;
		},
		_getRepresentation: function(proto) {
			return proto.$type.split(".").slice(1, 3).join(".").replace("$queryItem", "$query");
		},
		_getKeyValue: function(data, proto) {
			return proto.$key.replace(_keyRegExp, function(m, p) {
				return data[p];
			});
		},

		disableCache: function(isDisabled) {
			if (globals.isDvlpMode()) {
				localStorage.setItem("s.m.cache.disabled", isDisabled);
			}
			this._isDisabled = isDisabled;
		},
		isDisabled: function() {
			if (this._isDisabled == null) {
				if (globals.isDvlpMode()) {
					this._isDisabled = localStorage.getItem("s.m.cache.disabled");
					this._isDisabled = this._isDisabled === true || this._isDisabled === "true";
				} else {
					this._isDisabled = false;
				}
			}
			return this._isDisabled;
		}
	}
);

exports.SDataCache = _SDataCacheClass;
});

define('syracuse-tablet/html/js/helpers/siteLayout',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/notifications'],function (require, exports, module) {
var globals = require('syracuse-tablet/html/js/helpers/globals');

/*
 * Bootstrap min sizes per level
 * =============================
 *
 * xs:                  480px;
 * sm:                  768px;
 * md:                  992px;
 * lg:                  1200px;
 *
 */

/*
 * Some devices
 * ============
 *
 * iPad: 1024×768
 * Nexus 7: 1920 × 1200
 * Nexus 10: 2560x1600
 *
 */

/*
 * Needs to be aligned with bootstrap responsiveness!
 * Not, pixel sized defined here match values of media queries or top / left / width /height css attributes.
 * But these are not physical pixels because some devices have a pixel ration physical > logical
 *
 * See: http://bjango.com/articles/min-device-pixel-ratio/
 * We need to work with logical pixel units
 *
 * E.g. Nexus 10 has a 2560x1600 display but reports 1280x800 because ratio is 2.0
 * E.g. Nexus 5 has a 1080x1920 display but reports 360x1080 because ratio is 3.0
 *
 */
var _getCurrentDeviceClass = function() {
	var currentDeviceClass;
	var a = navigator.userAgent.toLowerCase();

	if (a.indexOf("iphone") >= 0) {
		currentDeviceClass = "smartphone";
	} else if (a.indexOf("ipad") >= 0) {
		currentDeviceClass = "tablet";
	} else {
		if (a.indexOf("mobile") >= 0) { // android smartphones report "mobile" while tablets do not
			currentDeviceClass = "smartphone";
		} else {
			currentDeviceClass = "tablet";
		}
	}
	return currentDeviceClass;
};

/*
 *
 * NOTE: IF you change s-m-auth-col-simulate* classes assigned to a device here, you need to also check
 * the CSS media selectors in thirdparty_custom.less
 *
 */
var _deviceSizes = {
	nexus5: {
		width: 640, // Nexus 5
		height: 360,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-xs",
			landscape: "s-m-auth-col-simulate-sm"
		},
		deviceClass: "smartphone",
		orientations: ["portrait", "landscape"]
	},
	nexus7: { // Nexus 7
		width: 960,
		height: 600,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-sm",
			landscape: "s-m-auth-col-simulate-md"
		},
		deviceClass: "minitablet",
		orientations: ["portrait", "landscape"]
	},
	nexus10: { // Nexus 10
		width: 1280,
		height: 800,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-sm",
			landscape: "s-m-auth-col-simulate-lg"
		},
		deviceClass: "tablet",
		orientations: ["portrait", "landscape"]
	},
	ipad: {
		width: 1024,
		height: 768,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-sm",
			landscape: "s-m-auth-col-simulate-lg"
		},
		deviceClass: "tablet",
		orientations: ["portrait", "landscape"]
	},
	iphone4: {
		width: 480,
		height: 320,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-xs",
			landscape: "s-m-auth-col-simulate-xs"
		},
		deviceClass: "smartphone",
		orientations: ["portrait", "landscape"]
	},
	iphone5: {
		width: 568,
		height: 320,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-xs",
			landscape: "s-m-auth-col-simulate-xs"
		},
		deviceClass: "smartphone",
		orientations: ["portrait", "landscape"]
	},
	iphone6: {
		width: 667,
		height: 375,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-xs",
			landscape: "s-m-auth-col-simulate-sm"
		},
		deviceClass: "smartphone",
		orientations: ["portrait", "landscape"]
	},
	iphone6plus: {
		width: 960,
		height: 540,
		bootstrapTweakClass: {
			portrait: "s-m-auth-col-simulate-xs",
			landscape: "s-m-auth-col-simulate-md"
		},
		deviceClass: "smartphone",
		orientations: ["portrait", "landscape"]
	}
};

/*
 * Classes that can be put on a container to override the css media selector that use device screen sizes
 */
var _bootstrapTweakClasses = ["s-m-auth-col-simulate-xs", "s-m-auth-col-simulate-sm", "s-m-auth-col-simulate-md", "s-m-auth-col-simulate-lg"];

/*
 *
 * This module is responsibe to layout main layout components in the browser window:
 *
 * HEADER    | AUTHORING
 * CONTENT   | PANEL
 * FOOTER    |
 *
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var _currentOrientation = null;
var _splitterWidth = 15;
// Parameters that are currently applied
var _layoutParameters = {
	authPanelRight: {
		width: 230,
		splitterWidth: _splitterWidth,
		visible: false
	},
	authPanelLeft: {
		width: 300,
		splitterWidth: _splitterWidth,
		visible: false
	},
	authPanelHeader: {
		height: 34,
	},
	authPanelFooter: {
		height: 34,
	},
	pageParameters: {
		forcePreview: false,
		forceAutoScale: true,
		device: "nexus10",
		orientation: "landscape",
		scale: 1
	},
};

/** Header/Footer height */
var _heights = {
	"tablet": {
		header: 50,
		footer: {
			opened: 50,
			closed: 20
		}
	},
	"smartphone": {
		header: 50,
		footer: {
			opened: 0,
			closed: 0
		}
	}
};
// Parameters that are actually used (calculated and maybe changed based on _layoutParameters)
var _internalParameters;

/*
 * To detect orientation change in browser window compared to last call of this function
 */
function _isOrientationChange() {
	var width = $(window).width();
	var height = $(window).height();

	var ratio = width / height;
	var orientation;

	if (ratio < 1) {
		orientation = "portrait";
	} else {
		orientation = "landscape";
	}
	if (orientation == _currentOrientation || _currentOrientation == null) {
		_currentOrientation = orientation;
		return false;
	}
	_currentOrientation = orientation;
	return true;
}

/*
 * Triggered by browser window change
 */
exports.onWindowResize = function(evt, opts) {
	// If browser window size change but orientation did not change, the the software keyboard has been rendered and
	// there MUST NOT be a resize to not loose focus.
	// On desktop devices, we can do the resize without any harm
	if (_isOrientationChange() || utils.isDesktop()) {
		_layoutMainContainers(opts);
	}
};

/*
 * Triggered by application JS code - triggerResizeInternal handler
 */
exports.onWindowResizeInteral = function(evt, opts) {
	_layoutMainContainers(opts);
};

var _resizeOptions = ["preserveScroll", "footerSwipe"];
/*
 * Layout main containers like header, content, footer, authoring panel
 */
function _layoutMainContainers(opts) {
	opts = opts || {};
	if (opts.layout) {
		_layoutParameters = $.extend(true, {}, _layoutParameters, opts.layout);
	}
	var width = $(window).width();
	var height = $(window).height();
	var appClass = null;

	var authPanelRightWidth = 0;
	var authPanelLeftWidth = 0;
	var authPanelHeaderHeight = 0;
	var authPanelFooterHeight = 0;
	var authPanelRightSplitterWidth = 0;
	var authPanelLeftSplitterWidth = 0;

	var $$authRight = $("#s-m-auth-panel-right-id");
	var $$authLeft = $("#s-m-auth-panel-left-id");
	var $$app = $("#s-m-app-id");
	var $$appContainer = $("#s-m-app-container-id");

	_internalParameters = $.extend(true, {}, _layoutParameters);
	var pageParams = _internalParameters.pageParameters;

	if (_internalParameters.authPanelRight.visible) {
		authPanelRightWidth = _internalParameters.authPanelRight.width;
		authPanelRightSplitterWidth = _internalParameters.authPanelRight.splitterWidth;

		_layoutAuthPanelRight(width, height);
		pageParams.forcePreview = true;
	}
	if (_internalParameters.authPanelLeft.visible) {
		authPanelLeftWidth = _internalParameters.authPanelLeft.width;
		authPanelLeftSplitterWidth = _internalParameters.authPanelLeft.splitterWidth;

		_layoutAuthPanelLeft(width, height);
		pageParams.forcePreview = true;
	}
	if (_internalParameters.authPanelHeader.visible) {
		authPanelHeaderHeight = _internalParameters.authPanelHeader.height;
		_layoutAuthPanelHeader(width, height);
	}
	if (_internalParameters.authPanelFooter.visible) {
		authPanelFooterHeight = _internalParameters.authPanelFooter.height;
		_layoutAuthPanelFooter(width, height);
	}
	var applicationWidth = width - authPanelRightWidth - authPanelRightSplitterWidth - authPanelLeftWidth - authPanelLeftSplitterWidth;
	var applicationHeight = height - authPanelHeaderHeight - authPanelFooterHeight;

	var appView;
	var forcePreview = pageParams.forcePreview === true;
	// Remove wrapper if exists
	if ($$app.parent().is(".s-m-device-wrapper")) {
		$$app.unwrap();
	}
	// if forcePreview adds a wrapper to simulate the tablet/iphone body
	if (forcePreview) {
		var device = pageParams.device || "tablet";
		var template = _deviceSizes[device] || _deviceSizes["tablet"];
		// Border for application wrapper
		var wrapBorder = 15;
		// Unscaled application view rectangle
		appView = {
			left: 0,
			top: 0,
			width: pageParams.orientation === "landscape" ? template.width : template.height,
			height: pageParams.orientation === "landscape" ? template.height : template.width,
		};
		// Wrapper W/H
		var wrapH = appView.height + 2 * wrapBorder,
			wrapW = appView.width + 2 * wrapBorder;
		// Auto scale
		if (pageParams.forceAutoScale) {
			pageParams.scale = Math.min(Math.min(applicationWidth / wrapW, applicationHeight / wrapH), 1);
		}
		//Center
		appView.left = Math.max((applicationWidth - wrapW * pageParams.scale) / 2, 0);
		appView.top = Math.max((applicationHeight - wrapH * pageParams.scale) / 2, 0);
		// Class that indicates device simulation status
		appClass = template.bootstrapTweakClass[pageParams.orientation];
		// Wrapp the application into device container to better display the devise structure with round corners...
		var $$wrapper = $('<section class="s-m-device-wrapper"></section>"');
		var wrapCss = {
			top: appView.top + "px",
			left: appView.left + "px",
			width: wrapW + "px",
			height: wrapH + "px"
		};
		if (pageParams.scale !== 1) {
			wrapCss["transform"] = "scale(" + pageParams.scale + ", " + pageParams.scale + ")",
			wrapCss["transform-origin"] = "left top";
		}
		$$wrapper.css(wrapCss);
		$$app.wrap($$wrapper);
		// Container including header, content, footer
		$$app.css({
			top: wrapBorder + "px",
			left: wrapBorder + "px",
			width: appView.width + "px",
			height: appView.height + "px",
			position: "absolute"
		});
	} else {
		// No preview - application is displayed full page
		appView = {
			left: 0,
			top: 0,
			width: applicationWidth,
			height: applicationHeight
		};
		pageParams.orientation = _currentOrientation;
		// Container including header, content, footer
		$$app.css({
			top: appView.top,
			left: appView.left,
			width: appView.width,
			height: appView.height
		});
	}
	// keeps only the right class
	$$app.removeClass(_bootstrapTweakClasses.join(' '));
	if (appClass) {
		$$app.addClass(appClass);
	}
	// Container including header, content, footer
	$$appContainer.css({
		top: authPanelHeaderHeight,
		left: authPanelLeftWidth + authPanelLeftSplitterWidth,
		width: applicationWidth,
		height: applicationHeight
	});
	// Status to manage css
	$$appContainer.toggleClass("s-m-preview", forcePreview);
	// Allow other components like authoring panel or page content to be resized
	var info = {
		// updateLayout = true - no deend to relaod data - needed for arrays or other controls that are build onResize (calculate width/height)
		updateLayout: true,
		application: appView
	};
	// Add specific options sent by the caller
	if (!$.isEmptyObject(opts)) {
		_resizeOptions.forEach(function(p) {
			info[p] = opts[p];
		});
		if (opts.footerSwipe === true) {
			// Swipe footer preserve the scrolling
			info.preserveScroll = true;
		}
	}
	notifications.publish("sm.main.layout.changed", info, pageParams.orientation, _getDeviceClass());

}

function _layoutAuthPanelRight(width, height) {
	var $$auth = $("#s-m-auth-panel-right-id");
	var $$splitter = $("#s-m-auth-splitter-right-id");

	var authPanelHeaderHeight = 0;
	var authPanelFooterHeight = 0;
	if (_internalParameters.authPanelHeader.visible) {
		authPanelHeaderHeight = _internalParameters.authPanelHeader.height;
	}
	if (_internalParameters.authPanelFooter.visible) {
		authPanelFooterHeight = _internalParameters.authPanelFooter.height;
	}

	$$auth.css({
		left: width - _internalParameters.authPanelRight.width,
		top: authPanelHeaderHeight,
		width: _internalParameters.authPanelRight.width,
		height: height - authPanelHeaderHeight - authPanelFooterHeight
	});
	$$splitter.css({
		left: width - _internalParameters.authPanelRight.width - _internalParameters.authPanelRight.splitterWidth,
		top: authPanelHeaderHeight,
		width: _internalParameters.authPanelRight.splitterWidth,
		height: height - authPanelHeaderHeight - authPanelFooterHeight
	});
}

function _layoutAuthPanelLeft(width, height) {
	var $$auth = $("#s-m-auth-panel-left-id");
	var $$splitter = $("#s-m-auth-splitter-left-id");

	var authPanelHeaderHeight = 0;
	var authPanelFooterHeight = 0;
	if (_internalParameters.authPanelHeader.visible) {
		authPanelHeaderHeight = _internalParameters.authPanelHeader.height;
	}
	if (_internalParameters.authPanelFooter.visible) {
		authPanelFooterHeight = _internalParameters.authPanelFooter.height;
	}

	$$auth.css({
		left: 0,
		top: authPanelHeaderHeight,
		width: _internalParameters.authPanelLeft.width,
		height: height - authPanelHeaderHeight - authPanelFooterHeight
	});
	$$splitter.css({
		left: _internalParameters.authPanelLeft.width,
		top: authPanelHeaderHeight,
		width: _internalParameters.authPanelLeft.splitterWidth,
		height: height - authPanelHeaderHeight - authPanelFooterHeight
	});
}

function _layoutAuthPanelHeader(width, height) {
	var $$auth = $("#s-m-auth-panel-header-id");
	$$auth.css({
		left: 0,
		top: 0,
		width: width,
		height: _internalParameters.authPanelHeader.height,
		overflow: "hidden"
	});
}

function _layoutAuthPanelFooter(width, height) {
	var $$auth = $("#s-m-auth-panel-footer-id");
	$$auth.css({
		left: 0,
		top: height - _internalParameters.authPanelFooter.height,
		width: width,
		height: _internalParameters.authPanelFooter.height
	});
}

exports.getDeviceTemplates = function() {
	return _deviceSizes;
};

var _getDeviceClass = function() {
	// Preview mode?
	if (_internalParameters.pageParameters.forcePreview === true) {
		var device = _internalParameters.pageParameters.device || "tablet";
		var template = _deviceSizes[device] || _deviceSizes["tablet"];
		return template.deviceClass;
	}

	// Check if auto device recognition is overridden by user settings
	var settings = globals.getGlobalSettings();
	if (!settings) return _getCurrentDeviceClass();
	if (settings["device-type"] !== "auto") {
		return settings["device-type"];
	}

	// Autodetect device class, this is the default
	return _getCurrentDeviceClass();
};
var _getDeviceType = function(deviceClass) {
	if (deviceClass == null) deviceClass = _getDeviceClass();
	return (deviceClass != "tablet" && deviceClass != "minitablet") ? "smartphone" : "tablet";
};

/* 
 * only tablet or smartphone
 * Use this to detect if it's a "smartphone" or a "tablet"
 * This function will return the physical device or the simulated one of dev mode or authoring is active.
 */
exports.getDeviceType = _getDeviceType;

exports.getPageOrientation = function() {
	return _internalParameters.pageParameters.orientation;
};

exports.getCurrentLayoutSettings = function() {
	var o = $.extend(true, {}, _layoutParameters);
	return o;
};
exports.getTransformScale = function() {
	var res = _internalParameters && _internalParameters.pageParameters ? _internalParameters.pageParameters.scale : null;
	return res == null || res <= 0 ? 1 : res;
};

exports.splitterWidth = _splitterWidth;
exports.onWindoReisze = _splitterWidth;
});

define('syracuse-tablet/html/js/application/metaDataCache',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/storage/storage','syracuse-tablet/html/js/sdata/sdataCommonResources','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ajax/ajax'],function (require, exports, module) {

/*
 * This module handles level 2 meta data access and persistance of meta data on client side
 * See metaData.js for details
 */

var globals = require('syracuse-tablet/html/js/helpers/globals');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("metaData");
var storageModule = require('syracuse-tablet/html/js/storage/storage');
var sdataCommonRes = require('syracuse-tablet/html/js/sdata/sdataCommonResources');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var ajax = require('syracuse-tablet/html/js/ajax/ajax').getAjax().ajax;

function _startWait() {
	var app = globals.getApplication();
	if (app) {
		app.waitWheelStart();
	}
}

function _stopWait() {
	var app = globals.getApplication();
	if (app) {
		app.waitWheelStop();
	}
}

/*
 * Gets all application stored on the client or
 * asks the server in case there is nothing stored on the client
 *
 * Note: This reads ALL applications known, not only the ones matching the role and endpoint
 */
exports.getKnownApplications = function(context) {
	var storage = globals.getStorage();

	var ctx = {
		"$user": "none",
		"$role": "none",
		"$lang": context.lang
	};

	var readCache;
	var cache = globals.getCache();
	if (cache.isDisabled()) { // Disabled by dev features?
		readCache = $.smResolve({
			$status: storageModule.StatusCodes.NOT_FOUND
		});
	} else {
		readCache = storage.read({
			$context: ctx,
			$collection: "$cache_$meta",
			$endpoint: "$local",
			$key: "$applications"
		});
	}
	return readCache.then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			var apps = result.$data;
			log && log("Application list from cache");
			return apps;
		} else {
			log && log("Fetching remote application list");
			return sdataCommonRes.queryAllApplications()
				.then(function(apps) {
					return _storeKnownApplications(apps, ctx).then(function() {
						return apps;
					});
				});
		}
	});
};

/*
 * Store list of apps locally
 */
function _storeKnownApplications(apps, ctx) {
	var storage = globals.getStorage();
	return storage.put({
		$context: ctx,
		$collection: "$cache_$meta",
		$endpoint: "$local",
		$key: "$applications",
		$data: apps
	}).then(function(result) {
		return apps;
	});
}

/*
 * Cached in the context of user, role and language
 * Return application detail for a given JSON description
 */
exports.getApplication = function(header, context) {
	var storage = globals.getStorage();
	var ctx = {
		"$user": context.user,
		"$role": context.role,
		"$lang": context.lang
	};

	return storage.read({
		$context: ctx,
		$collection: "$cache_$meta",
		$endpoint: "$local",
		$key: "$application_" + header.applicationName
	})
		.then(function(result) {
			if (result.$status === storageModule.StatusCodes.OK) {
				log && log("Application details from cache");
				return result.$data;
			} else {
				log && log("Fetching remote application details");
				_startWait();
				return sdataCommonRes.queryApplicationDetail(header)
					.then(function(app) {
						return _storeApplicationDetail(app, ctx).then(function() {
							return app;
						});
					})
					.then(function(app) {
						_stopWait();
						return app;
					})
					.fail(function(e) {
						_stopWait();
						return $.smReject(e);
					});
			}
		});
};

/*
 * Store details of single app locally
 */
function _storeApplicationDetail(app, ctx) {
	var storage = globals.getStorage();
	return storage.put({
		$context: ctx,
		$collection: "$cache_$meta",
		$endpoint: "$local",
		$key: "$application_" + app.$application.applicationName,
		$data: app
	});
}

/*
 * Gets a prototype
 * Asks the server in case there is nothing stored on the client
 *
 */
exports.getPrototype = function(name, context) {
	var storage = globals.getStorage();

	var ctx = {
		"$user": context.user,
		"$role": context.role,
		"$lang": context.lang
	};

	var readCache;
	readCache = storage.read({
		$context: ctx,
		$collection: "$cache_$meta",
		$endpoint: "$local",
		$key: "$prototype_" + name
	});
	return readCache.then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			var proto = result.$data;
			log && log("Prototype from cache");
			return proto;
		} else {
			log && log("Fetching remote prototype");
			return _fetchRemotePrototype(name)
				.then(function(prototype) {
					return _storePrototype(name, prototype, ctx).then(function() {
						return prototype;
					});
				});
		}
	});
};

/*
 *
 */
function _fetchRemotePrototype(name) {
	var deferred = $.Deferred();
	try {
		var base = globals.baseLocation();
		var segs = name.split(".");
		var ep = segs.slice(0, 3).join("/");
		var repr = segs.slice(3, 5).join(".");
		var url = base.host + "/mobile1/" + ep + "/$prototypes('" + repr + "')";

		var headers = {
			"Accept-Language": locale.getCurrentLocale()
		};

		ajax("GET", url, null, headers)
			.then(function(data) {
				if (data.isSuccess) {
					deferred.resolve(data.responseJSON);
				} else {
					return $.smReject(data.responseJSON);
				}
			}).fail(function(e) {
				deferred.reject(e);
			});
	} catch (e) {
		deferred.reject(e);
	} finally {
		return deferred.promise();
	}
}

function _storePrototype(name, prototype, ctx) {
	var storage = globals.getStorage();
	return storage.put({
		$context: ctx,
		$collection: "$cache_$meta",
		$endpoint: "$local",
		$key: "$prototype_" + name,
		$data: prototype
	});
}
});

define('syracuse-tablet/html/js/application/metaData',['require','exports','module','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/application/metaDataCache','syracuse-tablet/html/js/helpers/logger','syracuse-tablet/html/js/helpers/prototype','syracuse-tablet/html/js/authoring/authoringArticleGen'],function (require, exports, module) {

/*
 * This module should be used to access any kind of meta data
 * It either queries the local database or fetches the information
 * remotely and adds it to the local database
 *
 * Getting meta data is done in three levels for performance and maintainance reasons
 * 1 - In memory JS objects, once a piece of metadata has been read from level 2
 *     This level should be handled in this file
 * 2 - IndexedDB/WebSQL, persistent over restarts but slower than level 1
 *     This level should be handled in metaDataCache.js
 * 3 - Remote access to the server
 *     This level should be handled in metaDataCache.js
 */

var globals = require('syracuse-tablet/html/js/helpers/globals');
var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var metaDataCache = require('syracuse-tablet/html/js/application/metaDataCache');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("metaData");
var prototypeModule = require('syracuse-tablet/html/js/helpers/prototype');
var articleGen = require('syracuse-tablet/html/js/authoring/authoringArticleGen');

var _currentApplicationContext = {};
var _currentPrototypeContext = {};

// Applications depending on context
var _applications = null;
var _applicationDetails = {};
// Applications defined client side (always available)
var _applicationsStatic = [];

// Prototypes
var _prototypes = {};

/*
 *
 */
function _checkApplicationCtx() {
	var ctx = globals.getUserCtx();
	var endpoint = globals.getEndpoint();
	if (_currentApplicationContext.user != ctx.$user ||
		_currentApplicationContext.role != ctx.$role ||
		_currentApplicationContext.lang != ctx.$lang ||
		_currentApplicationContext.endpoint != endpoint) {
		_currentApplicationContext.user = ctx.$user;
		_currentApplicationContext.role = ctx.$role;
		_currentApplicationContext.lang = ctx.$lang;
		_currentApplicationContext.endpoint = endpoint;
		log && log("Application context changed to: " + JSON.stringify(_currentApplicationContext));
		_resetApplicationCache();
	}
}

/*
 *
 */
function _resetApplicationCache() {
	_applications = null;
	_applicationDetails = {};
}

/*
 *
 */
function _initApplications() {
	log && log("Reading applications");
	var apps = metaDataCache.getKnownApplications(_currentApplicationContext)
		.then(function(apps) {
			var matchedApps = [];
			apps.forEach(function(app) {
				var epMatch = true;
				if (app.endpoints && app.endpoints.length > 0) {
					epMatch = epMatch && app.endpoints.some(function(ep) {
						return (ep.application + "." + ep.contract + "." + ep.dataset === _currentApplicationContext.endpoint);
					});
				}
				var roleMatch = true;
				if (globals.isDvlpMode()) {
					roleMatch = true;
				} else {
					if (app.roles && app.roles.length > 0 && epMatch) {
						roleMatch = roleMatch && app.roles.some(function(role) {
							return (role.code === _currentApplicationContext.role);
						});

					}
				}
				if (roleMatch && epMatch) {
					matchedApps.push(app);
				}
			});

			// Always add static resources
			Object.keys(_applicationsStatic).forEach(function(name) {
				matchedApps.push(_applicationsStatic[name].$application);
			});
			_applications = matchedApps;
			log && log("Number of applications: " + _applications.length);
		});
	return apps;
}

/*
 *
 */
function _getApplicationHeaderByName(name) {
	var match = null;
	_applications.some(function(app) {
		if (app.applicationName == name) {
			match = app;
			return true;
		}
	});
	return match;
}

/*
 *
 */
exports.registerStaticApp = function(app) {
	log && log("Register static application: " + app.$application.applicationName);
	_applicationsStatic[app.$application.applicationName] = app;
};

/*
 * Return full details of requested application
 * name:
 * Name of application
 */
exports.getApplication = function(name) {
	// Application details already available?
	var app = _applicationsStatic[name] || _applicationDetails[name];
	if (app) {
		log && log("Application from cache: " + name);
		return $.smResolve(app);
	}
	var header = _getApplicationHeaderByName(name);
	if (header) {
		return metaDataCache.getApplication(header, _currentApplicationContext).then(function(app) {
			_applicationDetails[name] = app;
			return app;
		});
	} else {
		log && log("Unknown application: " + name);
	}
	return $.smResolve(app);
};

/*
 * Return all applications available for current context
 */
exports.getApplications = function() {
	_checkApplicationCtx();
	if (_applications != null) {
		return $.smResolve(_applications);
	}
	return _initApplications().then(function() {
		return _applications;
	});
};

/*
 *
 */
function _checkPrototypeCtx() {
	var ctx = globals.getUserCtx();
	var endpoint = globals.getEndpoint();
	if (_currentPrototypeContext.user != ctx.$user ||
		_currentPrototypeContext.role != ctx.$role ||
		_currentPrototypeContext.lang != ctx.$lang ||
		_currentPrototypeContext.endpoint != endpoint) {
		_currentPrototypeContext.user = ctx.$user;
		_currentPrototypeContext.role = ctx.$role;
		_currentPrototypeContext.lang = ctx.$lang;
		_currentPrototypeContext.endpoint = endpoint;
		log && log("Prototype context changed to: " + JSON.stringify(_currentPrototypeContext));
		_resetPrototypeCache();
	}
}

/*
 *
 */
function _resetPrototypeCache() {
	_prototypes = {};
}

/*
 * name:
 * application.protocol.dataset.representation.facet
 */
exports.getPrototype = function(name) {
	log && log("Getting prototype: " + name);
	var repr = name.split(".");
	if (repr.length < 5) { // Client side representations names are not fully qualified
		proto = clientContract.getPrototype(repr[0], repr[1]);
		log && log("Prototype (client side entitiy): " + name);
		return $.smResolve(proto);
	}

	_checkPrototypeCtx();
	var proto = _prototypes[name];
	if (proto) {
		return $.smResolve(proto);
	}
	var app = globals.getApplication();
	var appMetaData = app && app.dao && app.dao.appMetaData;
	var page = appMetaData && appMetaData.$pages && appMetaData.$pages[name];
	proto = page && page.$page && page.$page.$prototype;
	if (proto) {
		_prototypes[name] = proto;
		return $.smResolve(proto);
	}

	return metaDataCache.getPrototype(name, _currentPrototypeContext).then(function(proto) {
		log && log("Got prototype: " + name);
		_prototypes[name] = proto;
		return proto;
	});
};

function _getDashboardByName(name) {
	var appMetaData = globals.getApplication().dao.appMetaData;
	var $dashboards = appMetaData.$dashboards;

	var dashboard;
	if (!Object.keys($dashboards).some(function(key) {
		dashboard = $dashboards[key];
		if (dashboard.$dashboardName === name) {
			return true;
		}
	})) {
		dashboard = null;
	};

	return dashboard;
}
/*
 * name:
 * Name of dashboard
 *
 * Returns full meta data of dashboard
 * Gadgets will be added in node $gadget of the dashboard data so that
 * there is no need to query the application later
 */
exports.getDashboard = function(name) {
	var appMetaData = globals.getApplication().dao.appMetaData;
	var $dashboards = appMetaData.$dashboards;

	var dashboard = _getDashboardByName(name);
	//console.log(name);
	//console.log(dashboard);
	return $.smResolve()
		.then(function() {
			if (dashboard) {
				if (dashboard && dashboard.$update) {
					return dashboard.$update(dashboard);
				} else {
					return dashboard;
				}
			}
		})
		.then(function(dashboard) {
			if (dashboard) {
				dashboard.$gadgets = dashboard.$gadgets || {};
				// Copy gadgets to dashboard
				if (appMetaData.$gadgets) {
					for (var vignette in dashboard.$vignettes) {
						var v = dashboard.$vignettes[vignette];
						if (appMetaData.$gadgets[v.$uuid]) {
							dashboard.$gadgets[v.$uuid] = appMetaData.$gadgets[v.$uuid];
						}
					}
				}
			}
			return dashboard;
		});
};

/*
 *
 */
exports.getDashboardPageName = function(dashboardName) {
	return dashboardName + ".$mobileDashboard";
};

/*
 * For the name of a page, get it's type (dashboard, regular =proto based, static =html based)
 * Also return some other flags like, cached page, etc...
 */
exports.getPageInfo = function(pageName) {
	return _getDashboardPageInfo(pageName)
		.then(function(pageInfo) {
			if (pageInfo) {
				return pageInfo;
			}
			return _getRegularPageInfo(pageName);
		});
};

function _getDashboardPageInfo(pageName) {
	if (!pageName.smEndsWith(".$mobileDashboard")) {
		return $.smResolve(null);
	}
	var dashboardName = pageName.substring(0, pageName.length - 17);
	var dashboard = _getDashboardByName(dashboardName);
	if (!dashboard) {
		return $.smResolve(null);
	}
	var pageInfo = dashboard.$pageInfo || {};
	pageInfo.name = pageName;
	pageInfo.type = "dashboard";
	pageInfo.subtype = pageInfo.isWelcomePage ? "welcome" : "std";
	pageInfo.dashboardName = dashboard.$dashboardName;
	pageInfo.cached = false;
	pageInfo.refreshed = false;
	pageInfo.changeHash = false;

	return $.smResolve(pageInfo);
}

function _getRegularPageInfo(pageName) {
	var appMetaData = globals.getApplication().dao.appMetaData;
	var $pages = appMetaData && appMetaData.$pages;
	var page = $pages && $pages[pageName];
	if (!page) {
		return $.smResolve(null);
	}

	var pageInfo = {
		name: pageName,
		home: false,
		type: "regular",
		subtype: "unknown",
		cached: false,
		refreshed: false,
		changeHash: false,
	};

	return $.smResolve(page.$page.$prototype)
		.then(function(prototype) {
			if (!prototype) {
				return exports.getPrototype(pageInfo.name);
			}
			return prototype;
		})
		.then(function(prototype) {
			if (prototype) {
				var facet = prototype.$type;
				if (!facet) {
					// if no type we take $url - in test representation  $type is not set
					facet = prototype.$url;
				}
				pageInfo.subtype = facet.substring(facet.lastIndexOf('.$') + 2);
				if (!pageInfo.subtype) {
					throw new Error("Unexpected facet for page " + pageName + "\n$url=" + prototype.$url);
				}
			}
		})
		.then(function() {
			return pageInfo;
		});
}

/*
 * For a prototype based page, return article and prototype
 */
exports.getPageDetails = function(pageInfo) {
	var pageDetails;
	if (pageInfo.type === "regular") {
		return _getRegularPageDetails(pageInfo);
	}
	if (pageInfo.type === "rowdetail" || pageInfo.type === "carddesign") {
		return _getArrayChildPageDetails(pageInfo);
	}
	throw new Error("Unsupported page type: " + pageInfo.type);
};

function _getRegularPageDetails(pageInfo) {
	var pageDetails;
	var appMetaData = globals.getApplication().dao.appMetaData;
	var $pages = appMetaData && appMetaData.$pages;


	return $.smResolve().
	then(function() {
		// Get page from application meta data
		var page = $pages && $pages[pageInfo.name];
		if (page) {
			return {
				prototype: page.$page && page.$page.$prototype,
				article: page.$page && page.$page.$article
			};
		}
	})
		.then(function(pageDetails) {
			if (!pageDetails) {
				// Check if this page is defined by a client side JS entity
				return clientContract.getRegularPageInfo(pageInfo.name)
					.then(function(page) {
						if (page) {
							return {
								prototype: page.$page && page.$page.$prototype,
								article: page.$page && page.$page.$article
							};
						}
					});
			}
			return pageDetails;
		})
		.then(function(pageDetails) {
			// Page not found in app meta data and not in client side contract, must be lazy loaded representation
			if (!pageDetails) {
				return exports.getPrototype(pageInfo.name)
					.then(function(proto) {
						if (proto) {
							return {
								prototype: proto,
							};
						}
					});
			}
			// Maybe there is an article on the client but prototype is comming from server
			if (!pageDetails.prototype) {
				return exports.getPrototype(pageInfo.name)
					.then(function(proto) {
						if (proto) {
							pageDetails.prototype = proto;
							return pageDetails;
						}
					});
			}
			return pageDetails;
		})
		.then(function(pageDetails) {
			if (pageDetails) {
				// Wrap prototype in class
				pageDetails.prototype = prototypeModule.create(pageDetails.prototype); //, parentProto)
			}
			return pageDetails;
		})
		.then(function(pageDetails) {
			if (pageDetails) {
				return _ensureRegularPageDetailsArticle(pageInfo, pageDetails)
					.then(function() {
						return pageDetails;
					});
			}
			// Page not found
			return null;
		});
}

function _getArrayChildPageDetails(pageInfo) {
	return $.smResolve()
		.then(function() {
			var pageDetails = {
				prototype: pageInfo.prototype,
				article: pageInfo.article
			};
			return _ensureRegularPageDetailsArticle(pageInfo, pageDetails)
				.then(function() {
					return pageDetails;
				});
		});
}

function _ensureRegularPageDetailsArticle(pageInfo, pageDetails) {
	// If !vignetteArticle we take the one of the pageDetails if any
	var article;
	var genArticle;
	// For dashboard the article of the vignette can be defined in the article of the dashboard
	var vignetteArticle = pageInfo.options.vignetteArticle;

	if (!vignetteArticle) { // Not a vignette, so we can use article of full page
		article = pageDetails.article;
	} else if (vignetteArticle && $.isEmptyObject(vignetteArticle)) { // Vignette but no article given by dashboard -> create one
		article = null;
	} else if (vignetteArticle && !$.isEmptyObject(vignetteArticle)) { // Vignette andarticle given by dashboard -> use it
		article = vignetteArticle;
	}
	if (article && !$.isEmptyObject(article)) {
		genArticle = $.smResolve(article);
	} else {
		genArticle = $.smResolve().then(function() {
			return articleGen.genNewArticle({
				page: {
					prototype: pageDetails.prototype
				}
			}).then(function(protoArticle) {
				article = protoArticle;
			});
		});
	}
	return genArticle.then(function() {
		pageDetails.article = article;
	});
}
});

define('syracuse-tablet/html/js/sdata/entities/test/example',['require','exports','module'],function (require, exports, module) {

var _data = [];
for (var i = 0; i < 100; i++) {
	_data.push({
		$uuid: "" + i,
		name: "My name is: " + i,
		desc: "My desc is: " + i,
		desc2: "My desc2 is: " + i,
		amount: i * 100,
	});
}

exports.entity = {
	$entityName: "example",
	$value: "{name}",
	$properties: {
		name: {
			$type: "application/x-string",
			$title: "My name"
		},
		desc: {
			$type: "application/x-string",
			$title: "My description"
		},
		desc2: {
			$type: "application/x-string",
			$title: "My description 2"
		},
		amount: {
			$type: "application/x-integer",
			$title: "My amount",
			$isExcluded: false,
			$isHidden: false,
			$isMandatory: false,
			$isReadOnly: false,
			$isDisabled: false
		}
	},
	$relations: {
		values: {
			$type: "exampleChild"
		}
	},
	$articles: {
		$details: {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "name",
						"$isTitleHidden": false
					}]
				}, {
					"$bind": "desc",
					"$isTitleHidden": false
				}],
			}, {
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "desc2",
						"$isTitleHidden": false
					}]
				}, {
					"$bind": "amount",
					"$isTitleHidden": false
				}]
			}]
		},
		$edit: {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "name",
						"$isTitleHidden": true
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "desc",
						"$isTitleHidden": true
					}]
				}],
			}, {
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "desc2",
						"$isTitleHidden": false
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "amount",
						"$isTitleHidden": false
					}]
				}]
			}]
		}
	},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			// only works because op.$key is equal the array index and equal the $uuid
			deferred.resolve(_data[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/exampleHubLayout',['require','exports','module'],function (require, exports, module) {

var _data = [];
for (var i = 0; i < 100; i++) {
	_data.push({
		$uuid: "" + i,
		name: "My name is: " + i,
		desc: "My desc is: " + i,
		desc2: "My desc2 is: " + i,
		amount: i * 100,
	});
}

exports.entity = {
	$entityName: "exampleHubLayout",
	$value: "{name}",
	$properties: {
		name: {
			$type: "application/x-string",
			$title: "My name"
		},
		desc: {
			$type: "application/x-string",
			$title: "My description"
		},
		desc2: {
			$type: "application/x-string",
			$title: "My description 2"
		},
		amount: {
			$type: "application/x-integer",
			$title: "My amount",
			$isExcluded: false,
			$isHidden: false,
			$isMandatory: false,
			$isReadOnly: false,
			$isDisabled: false
		}
	},
	$relations: {
		values: {
			$type: "exampleChild"
		}
	},
	$articles: {
		$details: {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Layout group 1",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$size": "full",
					"$items": [{
						"$layoutType": "stack",
						"$items": [{
							"$layoutType": "row",
							"$items": [{
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "desc",
								"$isTitleHidden": false
							}],
						}]
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$size": "medium",
					"$items": [{
						"$layoutType": "stack",
						"$items": [{
							"$layoutType": "row",
							"$items": [{
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "desc",
								"$isTitleHidden": false
							}],
						}]
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "purple",
					"$size": "medium",
					"$items": [{
						"$layoutType": "stack",
						"$items": [{
							"$layoutType": "row",
							"$items": [{
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "desc",
								"$isTitleHidden": false
							}],
						}]
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$size": "wide",
					"$items": [{
						"$layoutType": "stack",
						"$items": [{
							"$layoutType": "row",
							"$items": [{
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "desc",
								"$isTitleHidden": false
							}],
						}]
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Layout group 2",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "orange",
					"$size": "large",
					"$items": [{
						"$layoutType": "stack",
						"$items": [{
							"$layoutType": "row",
							"$items": [{
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "desc",
								"$isTitleHidden": false
							}],
						}]
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$size": "medium",
					"$items": [{
						"$layoutType": "stack",
						"$items": [{
							"$layoutType": "row",
							"$items": [{
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "desc",
								"$isTitleHidden": false
							}],
						}]
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "purple",
					"$size": "green",
					"$items": [{
						"$layoutType": "stack",
						"$items": [{
							"$layoutType": "row",
							"$items": [{
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "desc",
								"$isTitleHidden": false
							}],
						}]
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$size": "wide",
					"$items": [{
						"$layoutType": "stack",
						"$items": [{
							"$layoutType": "row",
							"$items": [{
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "name",
								"$isTitleHidden": false
							}, {
								"$bind": "desc",
								"$isTitleHidden": false
							}],
						}]
					}]
				}]
			}]
		},
		$edit: {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$widthMd": "6,6",
				"$items": [{
					"$bind": "name",
					"$isTitleHidden": true
				}, {
					"$bind": "desc",
					"$isTitleHidden": true
				}],
			}, {
				"$layoutType": "row",
				"$widthMd": "6,6",
				"$items": [{
					"$bind": "desc2",
					"$isTitleHidden": false
				}, {
					"$bind": "amount",
					"$isTitleHidden": false
				}]
			}]
		}
	},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			// only works because op.$key is equal the array index and equal the
			// $uuid
			deferred.resolve(_data[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testDatatypes',['require','exports','module'],function (require, exports, module) {

var _data = [];
var _switch = false;
for (var i = 0; i < 10; i++) {
	_data.push({
		$uuid: "" + i,
		propString: "Simple String=" + i,
		propDate: "2014-03-" + (i + 20),
		propDateTime: "2014-06-" + (i + 10) + "T12:45:" + (i + 44) + ".123Z",
		propTime: "15:45:" + (i + 34),
		propTimeShort: "15:45:" + (i + 34),
		propInt: (i * 1000 + i * 10),
		propDecimal: Math.sqrt(i * 1000 + i * 10),
		propReal: Math.sqrt(i * 1000 + i * 30),
		propBoolean: (_switch = !_switch),
		propChoice: "mr",
		propQuantity: i * 123,
		propStringUnit: "EUR",
		propStringMandatory: "Mandatory",
		propDecimalMandatory: "",
		propStringMinMax: "",
		propStringMinMaxValue: "",
		propStringPattern: ""
	});
}

var _entity = {
	$entityName: "testDataTypes",
	$properties: {
		propString: {
			$type: "application/x-string",
			$isMandatory: false,
			$title: "My name (max len 25)",
			$maxLength: 25
		},
		propStringMandatory: {
			$type: "application/x-string",
			$isMandatory: true,
			$title: "String Madatory"
		},
		propStringMinMax: {
			$type: "application/x-string",
			$title: "String MinMaxLength(3-5)",
			$minLength: 3,
			$maxLength: 5
		},
		propStringMinMaxValue: {
			$type: "application/x-integer",
			$isMandatory: false,
			$title: "Integer MinMaxValue(3-50)",
			$minimun: "3",
			$maximun: "50"
		},
		propStringPattern: {
			$type: "application/x-string",
			$title: "Pattern",
			$maxLength: 40
		},
		propDate: {
			$type: "application/x-date",
			$isMandatory: false,
			$title: "Date"
		},

		propDateTime: {
			$type: "application/x-datetime",
			$isMandatory: false,
			$title: "Date+Time"
		},
		propTime: {
			$type: "application/x-time",
			$isMandatory: false,
			$title: "Time long",
			$format: "TT"
		},
		propTimeShort: {
			$type: "application/x-time",
			$isMandatory: false,
			$title: "Time",
		},
		propInt: {
			$type: "application/x-integer",
			$isMandatory: false,
			$title: "Integer (1-7000 Max)",
			$minimun: "1",
			$maximun: "7000"
		},

		propDecimalMandatory: {
			$type: "application/x-decimal",
			$isMandatory: true,
			$title: "Decimal mandatory(2.4)",
			$scale: 2,
			$precision: 4,
			$format: "0.00"
		},
		propDecimal: {
			$type: "application/x-decimal",
			$isMandatory: false,
			$title: "Decimal(4.7)",
			$scale: 4,
			$precision: 7,
			$format: "0.0000"
		},
		propReal: {
			$type: "application/x-real",
			$isMandatory: false,
			$title: "Real",
		},

		propBoolean: {
			$type: "application/x-boolean",
			$isMandatory: false,
			$title: "Boolean"
		},
		propChoice: {
			$type: "application/x-choice",
			$isMandatory: false,
			$title: "Choice",
			//$format: "$radios",
			$value: {
				$enum: [{
					$title: "Mr.",
					$value: "mr"
				}, {
					$title: "Mrs.",
					$value: "mrs"
				}],
				$type: "application/x-string"
			}
		},
		propQuantity: {
			$title: "Quantity",
			$type: "application/x-quantity",
			$value: {
				$title: "{$value} {$unit}",
				$type: "application/x-decimal",
				$scale: 9,
				$precision: 2,
				$format: "0.00"
			},
			$unit: "propStringUnit"
		},
		propStringUnit: {
			$type: "application/x-string",
			$isMandatory: false,
			$isExcluded: true,
			$title: "Unit for quantity"
		},
		propStringM: {
			$type: "application/x-string",
			$isMandatory: true,
			$title: "My name"
		},
		propDateM: {
			$type: "application/x-date",
			$isMandatory: true,
			$title: "Date (Mandatory)"
		},
		propDateTimeM: {
			$type: "application/x-datetime",
			$isMandatory: true,
			$title: "Date+Time (Mandatory)"
		},
		propTimeM: {
			$type: "application/x-time",
			$isMandatory: true,
			$title: "Time (Mandatory)",
		},
		propIntM: {
			$type: "application/x-integer",
			$isMandatory: true,
			$title: "Integer (Mandatory)",
		},
		propDecimalM: {
			$type: "application/x-decimal",
			$isMandatory: true,
			$title: "Decimal (Mandatory)",
		},
		propRealM: {
			$type: "application/x-real",
			$isMandatory: true,
			$title: "Real (Mandatory)",
		},
		propBooleanM: {
			$type: "application/x-boolean",
			$isMandatory: true,
			$title: "Boolean (Mandatory)"
		}
	},
	$relations: {},
	$articles: {
		$details: {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "stack",
				"$title": "String types",
				"$collapsible": "expanded",
				"$items": [{
					"$bind": "propString"
				}, {
					"$bind": "propStringMandatory"
				}, {
					"$bind": "propStringMinMax"
				}, {
					"$bind": "propStringPattern"
				}, {
					"$bind": "propStringM"
				}]
			}, {
				"$layoutType": "stack",
				"$title": "Numerical",
				"$collapsible": "collapsed",
				"$items": [{
					"$bind": "propTimeShort"
				}, {
					"$bind": "propDecimal"
				}, {
					"$bind": "propReal"
				}, {
					"$bind": "propIntM"
				}, {
					"$bind": "propDecimalMandatory"
				}, {
					"$bind": "propRealM"
				}, {
					"$bind": "propDecimalM"
				}, {
					"$bind": "propStringMinMaxValue"
				}, {
					"$bind": "propInt"
				}]
			}, {
				"$layoutType": "stack",
				"$title": "Date and Time",
				"$items": [{
					"$bind": "propDateTime"
				}, {
					"$bind": "propDateTimeM"
				}, {
					"$bind": "propDateM"
				}, {
					"$bind": "propTime"
				}, {
					"$bind": "propDate"
				}, {
					"$bind": "propTimeM"
				}]
			}, {
				"$layoutType": "stack",
				"$title": "Complex",
				"$collapsible": "collapsed",
				"$items": [{
					"$bind": "propQuantity"
				}, {
					"$bind": "propBoolean"
				}, {
					"$bind": "propChoice"
				}, {
					"$bind": "propBooleanM"
				}]
			}]
		}
	},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			// template when creating a new record
			var i = 15;
			var tpl = {
				$uuid: "" + i,
				propString: "Simple String=" + i,
				propDate: "2014-03-" + i,
				propDateTime: "2014-06-" + i + "T12:45:" + (i + 44) + ".234Z",
				propTime: "15:45:" + (i + 34),
				propInt: (i * 1000 + i * 10),
				propDecimal: Math.sqrt(i * 1000 + i * 10),
				propReal: Math.sqrt(i * 1000 + i * 30),
				propBoolean: (_switch = !_switch)
			};

			deferred.resolve(tpl);
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			// only works because op.$key is equal the array index and equal the $uuid
			deferred.resolve(_data[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};


exports.entity = _entity;
});

define('syracuse-tablet/html/js/sdata/entities/test/testFormats',['require','exports','module'],function (require, exports, module) {

var _data = [];
var _switch = false;
for (var i = 0; i < 10; i++) {
	_data.push({
		$uuid: "" + i,
		propDate1: "2014-03-" + (i + 20),
		propDateTime1: "2014-06-" + (i + 10) + " 12:45:" + (i + 44),
		propTime1: "15:45:" + (i + 34),
		propInt1: (i * 1000 + i * 10),
		propDecimal1: Math.sqrt(i * 1000 + i * 10),
		propReal1: Math.sqrt(i * 1000 + i * 30),
		propDate2: "2014-03-" + (i + 20),
		propDateTime2: "2014-06-" + (i + 10) + " 12:45:" + (i + 44),
		propTime2: "15:45:" + (i + 34),
		propInt2: (i * 1000 + i * 10),
		propDecimal2: Math.sqrt(i * 1000 + i * 10),
		propReal2: Math.sqrt(i * 1000 + i * 30)

	});
}

exports.entity = {
	$entityName: "testFormats",
	$properties: {
		propDate1: {
			$type: "application/x-date",
			$title: "Date"
		},
		propDateTime1: {
			$type: "application/x-datetime",
			$title: "Date+Time"
		},
		propTime1: {
			$type: "application/x-time",
			$title: "Time",
		},
		propInt1: {
			$type: "application/x-integer",
			$title: "Integer",
		},
		propDecimal1: {
			$type: "application/x-decimal",
			$title: "Decimal",
		},
		propReal1: {
			$type: "application/x-real",
			$title: "Real",
		},
		propDate2: {
			$type: "application/x-date",
			$title: "Date"
		},
		propDateTime2: {
			$type: "application/x-datetime",
			$title: "Date+Time"
		},
		propTime2: {
			$type: "application/x-time",
			$title: "Time",
		},
		propInt2: {
			$type: "application/x-integer",
			$title: "Integer",
		},
		propDecimal2: {
			$type: "application/x-decimal",
			$title: "Decimal",
		},
		propReal2: {
			$type: "application/x-real",
			$title: "Real",
		},
	},
	$relations: {},
	$articles: {},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({});
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve(_data[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testFormatsReference',['require','exports','module'],function (require, exports, module) {


var $descriptionSamples = ["Labe", "Labuan", "La Rochelle", "Las Vegas", "Las Palmas", "Liege", "Libreville", "Lille", "Liverpool", "Leipzig", "Lucknow", "London"];
var $codeSamples = ["LEK", "LBU", "LRH", "LAS", "LPA", "LGG", "LBV", "LIL", "LPL", "LEJ", "LKO", "LON"];

var _data = {
	SITE_REF: {
		$description: "Paris",
		FCY: "PAR"
	},
	SITE_REF_1: {
		$description: "Yaounde",
		FCY: "YDE"
	},
	SITE_REF_2: {
		$description: "London",
		FCY: "LON"
	},
	SITE_REF_3: {
		$description: "Lisbon",
		FCY: "LIS"
	}
};

var _qData = [];
var j = -1;
var m = -1;
for (var i = 0; i < 3; i++) {
	_qData.push({
		$uuid: "" + i,
		SITE_REF: {
			$description: $descriptionSamples[++j],
			FCY: $codeSamples[++m]
		},
		SITE_REF_1: {
			$description: $descriptionSamples[++j],
			FCY: $codeSamples[++m]
		},
		SITE_REF_2: {
			$description: $descriptionSamples[++j],
			FCY: $codeSamples[++m]
		},
		SITE_REF_3: {
			$description: $descriptionSamples[++j],
			FCY: $codeSamples[++m]
		}
	});
}

exports.entity = {
	$entityName: "testFormatsReference",
	$baseUrl: "http://localhost:8124/mobile1/x3/erp/SUPERV",
	$properties: {
		"SITE": {
			"$type": "application/x-string",
			"$maxLength": 5,
			"$isExcluded": true
		},
		"SITE_REF": {
			$type: "application/x-reference",
			$title: "Reference",
			$shortTitle: "Reference",
			$capabilities: "sort,filter",
			$item: {
				$url: "{$baseUrl}/testFormatsReference('{$key}')?representation=testFormatsReference.$lookup",
				$value: "{FCY}",
				"FCY": "{SITE}",
				"$key": "{FCY}",
				"$properties": {
					"FCY": {
						"$type": "application/x-string"
					}
				},
				"$links": {
					"$details": {
						"$title": "details",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference('{SITE}')?representation=testFormatsReference.$details",
						"$method": "GET"
					},
					"$lookup": {
						"$title": "lookup",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference?representation=testFormatsReference.$lookup",
						"$method": "GET"
					},
					"$query": {
						"$title": "query",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference?representation=testFormatsReference.$query",
						"$method": "GET"
					},
					"SIT1": {
						"$title": "SIT1",
						"$target": "main",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "https://maps.google.de/maps?q={SITE}&t=Default",
						"$method": "GET"
					}
				}
			}
		},
		"SITE_REF_1": {
			$type: "application/x-reference",
			$title: "Reference 1",
			$shortTitle: "Reference 1",
			$capabilities: "sort,filter",
			$item: {
				$url: "{$baseUrl}/testFormatsReference('{$key}')?representation=testFormatsReference.$lookup",
				$value: "{FCY}",
				"FCY": "{SITE}",
				"$key": "{FCY}",
				"$properties": {
					"FCY": {
						"$type": "application/x-string"
					}
				},
				"$links": {
					"$details": {
						"$title": "details",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference('{SITE}')?representation=testFormatsReference.$details",
						"$method": "GET"
					},
					"$lookup": {
						"$title": "lookup",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference?representation=testFormatsReference.$lookup",
						"$method": "GET"
					},
					"$query": {
						"$title": "query",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference?representation=testFormatsReference.$query",
						"$method": "GET"
					},
					"SIT1": {
						"$title": "SIT1",
						"$target": "main",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "https://maps.google.de/maps?q={SITE}&t=Default",
						"$method": "GET"
					}
				}
			}
		},
		"SITE_REF_2": {
			$type: "application/x-reference",
			$title: "Reference 2",
			$shortTitle: "Reference 2",
			$capabilities: "sort,filter",
			$item: {
				$url: "{$baseUrl}/testFormatsReference('{$key}')?representation=testFormatsReference.$lookup",
				$value: "{FCY}",
				"FCY": "{SITE}",
				"$key": "{FCY}",
				"$properties": {
					"FCY": {
						"$type": "application/x-string"
					}
				},
				"$links": {
					"$details": {
						"$title": "details",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference('{SITE}')?representation=testFormatsReference.$details",
						"$method": "GET"
					},
					"$lookup": {
						"$title": "lookup",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference?representation=testFormatsReference.$lookup",
						"$method": "GET"
					},
					"$query": {
						"$title": "query",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference?representation=testFormatsReference.$query",
						"$method": "GET"
					},
					"SIT1": {
						"$title": "SIT1",
						"$target": "main",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "https://maps.google.de/maps?q={SITE}&t=Default",
						"$method": "GET"
					}
				}
			}
		},
		"SITE_REF_3": {
			$type: "application/x-reference",
			$title: "Reference 3",
			$shortTitle: "Reference 3",
			$capabilities: "sort,filter",
			$item: {
				$url: "{$baseUrl}/testFormatsReference('{$key}')?representation=testFormatsReference.$lookup",
				$value: "{FCY}",
				"FCY": "{SITE}",
				"$key": "{FCY}",
				"$properties": {
					"FCY": {
						"$type": "application/x-string"
					}
				},
				"$links": {
					"$details": {
						"$title": "details",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference('{SITE}')?representation=testFormatsReference.$details",
						"$method": "GET"
					},
					"$lookup": {
						"$title": "lookup",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference?representation=testFormatsReference.$lookup",
						"$method": "GET"
					},
					"$query": {
						"$title": "query",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/testFormatsReference?representation=testFormatsReference.$query",
						"$method": "GET"
					},
					"SIT1": {
						"$title": "SIT1",
						"$target": "main",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "https://maps.google.de/maps?q={SITE}&t=Default",
						"$method": "GET"
					}
				}
			}
		}
	},
	$relations: {},
	$articles: {
		$details: {
			"$layoutType": "stack",
			$items: [{
				$bind: "SITE_REF",
				$title: "Ref field 1"
			}, {
				$bind: "SITE_REF_1",
				$title: "Ref field 2"
			}, {
				$bind: "SITE_REF_2",
				$title: "Ref field 3"
			}, {
				$bind: "SITE_REF_3",
				$title: "Ref field 4"
			}]
		},
		$edit: {
			"$layoutType": "stack",
			$items: [{
				$bind: "SITE_REF",
				$title: "Ref field 1"
			}, {
				$bind: "SITE_REF_1",
				$title: "Ref field 2"
			}, {
				$bind: "SITE_REF_2",
				$title: "Ref field 3"
			}, {
				$bind: "SITE_REF_3",
				$title: "Ref field 4"
			}]
		}
	},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({});
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve(_data);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _qData
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testCharts',['require','exports','module'],function (require, exports, module) {

var _data = [{
	part: "Gear",
	value: 50,
	revenue: 40,
	margin: 10
}, {
	part: "Motor",
	value: 60,
	revenue: 40,
	margin: 20
}, {
	part: "Head drive",
	value: 60,
	revenue: 80,
	margin: -20
}, {
	part: "Handwheel",
	value: 70,
	revenue: 90,
	margin: 10
}, {
	part: "Crank",
	value: 70,
	revenue: 70,
	margin: 0
}, {
	part: "Saddle",
	value: 80,
	revenue: 30,
	margin: 50
}, {
	part: "Base",
	value: 20,
	revenue: 40,
	margin: -20
}, {
	part: "Spindle",
	value: 10,
	revenue: 0,
	margin: 10
}];


exports.entity = {
	$entityName: "testCharts",
	$properties: {
		part: {
			$type: "application/x-string",
			$title: "Item"
		},
		value: {
			$type: "application/x-decimal",
			$title: "Value",
			$format: "0.0000"
		},
		revenue: {
			$type: "application/x-decimal",
			$title: "Revenue",
			$format: "0.0000"
		},
		margin: {
			$type: "application/x-decimal",
			$title: "Margin",
			$format: "0.0000"
		}
	},

	// invoked after protype generation to do adjustments
	$prototype: function(proto) {

		// Add some chart information in $query prototype
		var res = proto.$properties && proto.$properties.$resources;
		if (res) {
			res.$axes = [{
				$title: "Item",
				$hierarchies: [
					["part"]
				]
			}, {
				$hierarchies: [
					["$measures"]
				]
			}];
			res.$cube = {
				$title: "Sales overview",
				$hierarchies: {
					part: {
						$properties: ["part"]
					}
				},
				$measures: {
					value: {},
					revenue: {},
					margin: {}
				}
			};
		}
	},
	$relations: {},
	$articles: {},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve(_data[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testConstraints',['require','exports','module'],function (require, exports, module) {

var _data = [];
var _switch = false;
for (var i = 0; i < 10; i++) {
	_data.push({
		$uuid: "" + i,
		propString: "Test " + i,
		propString2: "Some text " + i,
		propString3: "Fill me " + i,
		propInt: (i * 1000 + i * 10),
		propInt2: (i * 1000 + i * 100),
		propDecimal: Math.sqrt(i * 1000 + i * 10),
		propDecimal2: Math.sqrt(i * 1000 + i * 100),
		propDecimal3: Math.sqrt(i * 1000 + i * 110),
		propDecimal4: Math.sqrt(i * 1000 + i * 120),
		propQuantity: i * 123,
		propStringUnit: "EUR"
	});
}

exports.entity = {
	$entityName: "testConstraints",
	$properties: {
		propString: {
			$title: "Test: $pattern=Test.*\\d$",
			$type: "application/x-string",
			$isMandatory: true,
			$pattern: "Test.*\\d$"
		},
		propString2: {
			$title: "Test: $minLength=5, $maxLength=15",
			$type: "application/x-string",
			$isMandatory: true,
			$minLength: 5,
			$maxLength: 15
		},
		propString3: {
			$title: "Test: $minLength=5, $maxLength=15, $pattern=Fill me.*\\d$",
			$type: "application/x-string",
			$isMandatory: true,
			$pattern: "Fill me.*\\d$",
			$minLength: 5,
			$maxLength: 15
		},
		propInt: {
			$title: "Test: $minimum=100, $maximum=200",
			$type: "application/x-integer",
			$isMandatory: true,
			$minimum: 100,
			$maximum: 200
		},
		propInt2: {
			$title: "Test: $exclusiveMinimum=100, $exclusiveMaximum=200",
			$type: "application/x-integer",
			$isMandatory: true,
			$exclusiveMinimum: 100,
			$exclusiveMaximum: 200
		},
		propDecimal: {
			$title: "Test: $format=0.0000",
			$type: "application/x-decimal",
			$isMandatory: true,
			$format: "0.0000"
		},
		propDecimal2: {
			$title: "Test: $format=0.00",
			$type: "application/x-decimal",
			$isMandatory: true,
			$format: "0.00"
		},
		propDecimal3: {
			$title: "Test: $precision=10",
			$type: "application/x-decimal",
			$isMandatory: true,
			$precision: 10
		},
		propDecimal4: {
			$title: "Test: $scale=3",
			$type: "application/x-decimal",
			$isMandatory: true,
			$scale: 3,
			$format: "0.00000"
		},
		propQuantity: {
			$title: "Test: $format=0.00",
			$isMandatory: true,
			$type: "application/x-quantity",
			$value: {
				$title: "{$value} {$unit}",
				$type: "application/x-decimal",
				$scale: 9,
				$precision: 2,
				$format: "0.00"
			},
			$unit: "propStringUnit"
		},
		propStringUnit: {
			$title: "Unit for quantity",
			$type: "application/x-string",
			$isMandatory: false,
			$isExcluded: true
		},
	},
	$relations: {},
	$articles: {},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			// template when creating a new record
			var i = 15;
			var tpl = {
				$uuid: "" + i,
				propString: "Simple String=" + i,
				propInt: (i * 1000 + i * 10),
				propDecimal: Math.sqrt(i * 1000 + i * 10),
			};
			deferred.resolve(tpl);
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			// only works because op.$key is equal the array index and equal the $uuid
			deferred.resolve(_data[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testNavigateTo',['require','exports','module','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {
var utils = require('syracuse-tablet/html/js/helpers/utils');

var _data = [];

for (var i = 0; i < 10; i++) {
	_data.push({
		$uuid: "" + i,
		name: "Customer group " + i,
		group: "" + i
	});

}

exports.entity = {
	$entityName: "testNavigateTo",
	$properties: {
		name: {
			$title: "Customer group name",
			$type: "application/x-string",
		},
		group: {
			$title: "Customer group",
			$type: "application/x-string",
		},
	},
	$prototype: function(proto) {
		// Add some chart information in $query prototype
		var res = utils.getPropByPath(proto, "$properties.$resources.$item.$links") || {};
		res["DASHBOARD"] = {
			$title: "Detail dashboard",
			$url: "{$baseUrl}/$mobileDashboards?dashboard=testContextDashboardChild&parameters=group%3D%7Bgroup%7D"
		};
	},
	$relations: {},
	$articles: {
		$query: {
			"$layoutType": "stack",
			"$items": [{
				"$bind": "$resources",
				"$detailsLink": "DASHBOARD",
				"$isTitleHidden": true,
				"$article": {
					"$items": [{
						"$bind": "name"
					}, {
						"$bind": "group"
					}]
				},
				"$display": "table"
			}]
		}
	},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			// template when creating a new record
			var i = 15;
			var tpl = {
				$uuid: "" + i,
				propString: "Simple String=" + i,
				propInt: (i * 1000 + i * 10),
				propDecimal: Math.sqrt(i * 1000 + i * 10),
			};
			deferred.resolve(tpl);
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			// only works because op.$key is equal the array index and equal the $uuid
			deferred.resolve(_data[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testNavigateToChild',['require','exports','module'],function (require, exports, module) {

var _data = [];

for (var i = 0; i < 10; i++) {
	for (var j = 0; j < 10; j++) {
		_data.push({
			$uuid: "" + ((i * 10) + j),
			name: "Customer " + (i * 10) + j,
			desc: "Belongs to group " + i,
			group: "" + i
		});
	}
}

exports.entity = {
	$entityName: "testNavigateToChild",
	$properties: {
		name: {
			$title: "Customer name",
			$type: "application/x-string",
		},
		desc: {
			$title: "Description",
			$type: "application/x-string",
		},
		group: {
			$title: "Customer group",
			$type: "application/x-string",
		},
	},
	$relations: {},
	$articles: {},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			// template when creating a new record
			var i = 15;
			var tpl = {
				$uuid: "" + i,
				propString: "Simple String=" + i,
				propInt: (i * 1000 + i * 10),
				propDecimal: Math.sqrt(i * 1000 + i * 10),
			};
			deferred.resolve(tpl);
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			// only works because op.$key is equal the array index and equal the $uuid
			deferred.resolve(_data[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testPropertyHideShow',['require','exports','module'],function (require, exports, module) {

var _data = [];
var _switch = false;
for (var i = 0; i < 10; i++) {
	_data.push({
		$uuid: "" + i,
		propStringShow: "Simple String=" + i,
		propStringHide: "Simple String=" + i,
		propStringReadOnly: "ReadOnly String=" + i,
		propStringDisabled: "Disabled=true String=" + i,
		propStringDisabledFalse: "Disabled=false String=" + i,

		propDate: "2014-03-" + (i + 20),
		propDateHide: "2014-03-" + (i + 20),
		propDateDisabled: "2014-03-" + (i + 20),
		propDateReadOnly: "2014-03-" + (i + 20),

		propDateTime: "2014-06-" + (i + 10) + "T12:45:" + (i + 44) + ".123Z",
		propDateTimeHide: "2014-06-" + (i + 10) + "T12:45:" + (i + 44) + ".123Z",
		propDateTimeDisabled: "2014-06-" + (i + 10) + "T12:45:" + (i + 44) + ".123Z",

		propTime: "15:45:" + (i + 34),
		propTimeHide: "15:45:" + (i + 34),
		propTimeDisabled: "15:45:" + (i + 34),


		propInt: (i * 1000 + i * 10),
		propIntHide: (i * 1000 + i * 10),
		propIntDisabled: (i * 1000 + i * 10),
		propIntReadOnly: (i * 1000 + i * 10),

		propDecimal: Math.sqrt(i * 1000 + i * 10),
		propDecimalHide: Math.sqrt(i * 1000 + i * 10),
		propDecimalDisabled: Math.sqrt(i * 1000 + i * 10),
		propDecimalReadOnly: Math.sqrt(i * 1000 + i * 10),

		propReal: Math.sqrt(i * 1000 + i * 30),

		propBoolean: (_switch = !_switch),
		propBooleanHidden: (_switch = !_switch),
		propBooleanDisabled: (_switch = !_switch),

		propChoice: "mr",
		propChoiceHidden: "mr",
		propChoiceDisabled: "mr",

		propQuantity: i * 123,
		propStringUnit: "EUR",
		propQuantityExcluded: i * 123,
		propStringUnitExcluded: "USD"

	});
}

exports.entity = {
	$entityName: "testPropertyHideShow",
	$properties: {
		propStringShow: {
			$type: "application/x-string",
			$isMandatory: true,
			$title: "String Mandatory $isHidden: false",
			$isHidden: false
		},
		propStringHide: {
			$type: "application/x-string",
			$isMandatory: false,
			$title: "String $isHidden: true",
			$isHidden: true
		},
		propStringReadOnly: {
			$type: "application/x-string",
			$title: "String $isReadOnly: true",
			$isReadOnly: true
		},
		propStringDisabledFalse: {
			$type: "application/x-string",
			$title: "String $isDisabled: false",
			$isDisabled: false
		},
		propStringDisabled: {
			$type: "application/x-string",
			$title: "String $isDisabled: true",
			$isDisabled: true
		},
		propDate: {
			$type: "application/x-date",
			$isMandatory: false,
			$title: "Date $isHidden: false",
			$isHidden: false
		},
		propDateHide: {
			$type: "application/x-date",
			$isMandatory: false,
			$title: "Date $isHidden: true",
			$isHidden: true
		},
		propDateDisabled: {
			$type: "application/x-date",
			$isMandatory: false,
			$title: "Date $isDisabled: true",
			$isDisabled: true
		},
		propDateReadOnly: {
			$type: "application/x-date",
			$isMandatory: false,
			$title: "Date $isReadOnly: true",
			$isReadOnly: true
		},

		propDateTime: {
			$type: "application/x-datetime",
			$isMandatory: false,
			$title: "Date+Time $isHidden: false",
			$isHidden: false
		},
		propDateTimeHide: {
			$type: "application/x-datetime",
			$isMandatory: false,
			$title: "Date+Time $isHidden: true",
			$isHidden: true
		},
		propDateTimeDisabled: {
			$type: "application/x-datetime",
			$isMandatory: false,
			$title: "Date+Time $isDisabled: true",
			$isDisabled: true
		},

		propTime: {
			$type: "application/x-time",
			$isMandatory: false,
			$title: "Time long",
			$format: "TT"
		},
		propTimeHide: {
			$type: "application/x-time",
			$isMandatory: false,
			$title: "Time $isHidden: true",
			$isHidden: true
		},
		propTimeDisabled: {
			$type: "application/x-time",
			$isMandatory: false,
			$title: "Time $isDisabled: true",
			$isDisabled: true
		},

		propInt: {
			$type: "application/x-integer",
			$isMandatory: false,
			$title: "Integer ($isHidden: false)",
			$isHidden: false
		},
		propIntHide: {
			$type: "application/x-integer",
			$isMandatory: false,
			$title: "Integer ($isHidden: true)",
			$isHidden: true
		},
		propIntDisabled: {
			$type: "application/x-integer",
			$isMandatory: false,
			$title: "Integer ($isDisabled: true)",
			$isDisabled: true
		},
		propIntReadOnly: {
			$type: "application/x-integer",
			$isMandatory: false,
			$title: "Integer ($isReadOnly: true)",
			$isReadOnly: true
		},
		propDecimal: {
			$type: "application/x-decimal",
			$isMandatory: false,
			$title: "Decimal $isHidden: false",
			$isHidden: false
		},
		propDecimalHide: {
			$type: "application/x-decimal",
			$isMandatory: false,
			$title: "Decimal $isHidden: true",
			$isHidden: true
		},
		propDecimalDisabled: {
			$type: "application/x-decimal",
			$isMandatory: false,
			$title: "Decimal $isDisabled: true",
			$isDisabled: true
		},
		propDecimalReadOnly: {
			$type: "application/x-decimal",
			$isMandatory: false,
			$title: "Decimal $isReadOnly: true",
			$isReadOnly: true
		},

		propReal: {
			$type: "application/x-real",
			$isMandatory: false,
			$title: "Real"
		},

		propBoolean: {
			$type: "application/x-boolean",
			$isMandatory: false,
			$title: "Boolean"
		},
		propBooleanHidden: {
			$type: "application/x-boolean",
			$isMandatory: false,
			$title: "Boolean ($isHidden: true)",
			$isHidden: true
		},
		propBooleanDisabled: {
			$type: "application/x-boolean",
			$isMandatory: false,
			$title: "Boolean ($isDisabled: true)",
			$isDisabled: true
		},

		propChoice: {
			$type: "application/x-choice",
			$isMandatory: false,
			$title: "Choice",
			//$format: "$radios",
			$value: {
				$enum: [{
					$title: "Mr.",
					$value: "mr"
				}, {
					$title: "Mrs.",
					$value: "mrs"
				}],
				$type: "application/x-string"
			}
		},
		propChoiceHidden: {
			$type: "application/x-choice",
			$isMandatory: false,
			$title: "Choice($isHidden: true)",
			$isHidden: true,
			//$format: "$radios",
			$value: {
				$enum: [{
					$title: "Mr.",
					$value: "mr"
				}, {
					$title: "Mrs.",
					$value: "mrs"
				}],
				$type: "application/x-string"
			}
		},
		propChoiceDisabled: {
			$type: "application/x-choice",
			$isMandatory: false,
			$title: "Choice ($isDisabled: true)",
			$isDisabled: true,
			//$format: "$radios",
			$value: {
				$enum: [{
					$title: "Mr.",
					$value: "mr"
				}, {
					$title: "Mrs.",
					$value: "mrs"
				}],
				$type: "application/x-string"
			}
		},
		propQuantity: {
			$title: "Quantity ($unit $isExcluded: false)",
			$type: "application/x-quantity",
			$value: {
				$title: "{$value} {$unit}",
				$type: "application/x-decimal",
				$scale: 9,
				$precision: 2,
				$format: "0.00"
			},
			$unit: "propStringUnit"
		},
		propStringUnit: {
			$type: "application/x-string",
			$isMandatory: false,
			$isExcluded: false,
			$title: "Unit for quantity ($isExcluded: false)"
		},
		propQuantityExcluded: {
			$title: "Quantity($unit $isExcluded: true)",
			$type: "application/x-quantity",
			$value: {
				$title: "{$value} {$unit}",
				$type: "application/x-decimal",
				$scale: 9,
				$precision: 2,
				$format: "0.00"
			},
			$unit: "propStringUnitExcluded"
		},
		propStringUnitExcluded: {
			$type: "application/x-string",
			$isMandatory: false,
			$isExcluded: true,
			$title: "Unit for quantity ($isExcluded: true)"
		}

	},
	$relations: {},
	$articles: {},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			// template when creating a new record
			var i = 15;
			var tpl = {
				$uuid: "" + i,
				propString: "Simple String=" + i,
				propDate: "2014-03-" + i,
				propDateTime: "2014-06-" + i + "T12:45:" + (i + 44) + ".234Z",
				propTime: "15:45:" + (i + 34),
				propInt: (i * 1000 + i * 10),
				propDecimal: Math.sqrt(i * 1000 + i * 10),
				propReal: Math.sqrt(i * 1000 + i * 30),
				propBoolean: (_switch = !_switch)
			};

			deferred.resolve(tpl);
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			// only works because op.$key is equal the array index and equal the $uuid
			deferred.resolve(_data[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testGaugeChart',['require','exports','module'],function (require, exports, module) {

var _data = {
	"salesOp": "75.0000000000",
	"salesValue": "133000.0000000000",
	"salesValueMin": "100000.0000000000",
	"salesValueMax": "150000.0000000000"
};

var _entity = {
	$entityName: "testGaugeChart",
	$properties: {
		"salesOp": {
			"$title": "sale opportunity",
			"$type": "application/x-decimal",
			"$capabilities": "sort,filter"
		},
		"salesValue": {
			"$title": "sales value",
			"$type": "application/x-decimal",
			"$capabilities": "sort,filter"
		},
		"salesValueMin": {
			"$title": "sales value min",
			"$type": "application/x-decimal",
			"$capabilities": "sort,filter"
		},
		"salesValueMax": {
			"$title": "sales value max",
			"$type": "application/x-decimal",
			"$capabilities": "sort,filter"
		}
	},
	$relations: {},
	$articles: {},
	$services: {
		$read: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve(_data);
			return deferred.promise();
		}
	}
};

exports.entity = _entity;
});

define('syracuse-tablet/html/js/sdata/entities/test/testHomeDashboard',['require','exports','module'],function (require, exports, module) {
exports.dashboards = {
	"testHomeDashboard": {
		"$dashboardName": "testHomeDashboard",
		"$title": "Main test dashboard",
		"$description": "This dashboard links to different dashboards used for every kind of UI tests",
		"$vignettes": {
			"testLayoutsDashboard": {
				"$uuid": "testLayoutsDashboard",
				"$displayStyle": "$link"
			},
			"testTypesDashboard": {
				"$uuid": "testTypesDashboard",
				"$displayStyle": "$link"
			},
			"testTypesDashboard2": {
				"$uuid": "testTypesDashboard2",
				"$displayStyle": "$link"
			},
			"testFormatsDashboard": {
				"$uuid": "testFormatsDashboard",
				"$displayStyle": "$link"
			},
			"testGX3APPDashboard": {
				"$uuid": "testGX3APPDashboard",
				"$displayStyle": "$link"
			},
			"testSUPERVDashboard": {
				"$uuid": "testSUPERVDashboard",
				"$displayStyle": "$link"
			},
			"testChartsDashboard": {
				"$uuid": "testChartsDashboard",
				"$displayStyle": "$link"
			},
			"testSUPERVDashboard2": {
				"$uuid": "testSUPERVDashboard2",
				"$displayStyle": "$link"
			},
			"testGX3APPDashboard2": {
				"$uuid": "testGX3APPDashboard2",
				"$displayStyle": "$link"
			},
			"testConstraintsDashboard": {
				"$uuid": "testConstraintsDashboard",
				"$displayStyle": "$link"
			},
			"testContextDashboard": {
				"$uuid": "testContextDashboard",
				"$displayStyle": "$link"
			},
			"testPropertyHideShowDashboard": {
				"$uuid": "testPropertyHideShowDashboard",
				"$displayStyle": "$link"
			},
			"testAQTACTNPDashboard": {
				"$uuid": "testAQTACTNPDashboard",
				"$displayStyle": "$link"
			},
			"testSyDevDashboard": {
				"$uuid": "testSyDevDashboard",
				"$displayStyle": "$link"
			},
			"testGaugeChartDashboard": {
				"$uuid": "testGaugeChartDashboard",
				"$displayStyle": "$link"
			},
			"testGridDashboard": {
				"$uuid": "testGridDashboard",
				"$displayStyle": "$link"
			},
			"testDefaultAQTCRUDM": {
				"$uuid": "testDefaultAQTCRUDM",
				"$displayStyle": "$link"
			},
			"testDefaultAQMCRUDM": {
				"$uuid": "testDefaultAQMCRUDM",
				"$displayStyle": "$link"
			},
			"testDefaultAQMFIELDSM": {
				"$uuid": "testDefaultAQMFIELDSM",
				"$displayStyle": "$link"
			},
			"testDefaultAQMSEARCHM": {
				"$uuid": "testDefaultAQMSEARCHM",
				"$displayStyle": "$link"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Client only",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "purple",
					"$items": [{
						"$bind": "testLayoutsDashboard"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "testFormatsDashboard"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "testTypesDashboard"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$bgColor": "mediumgrey",
					"$items": [{
						"$bind": "testConstraintsDashboard",
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$title": "Test title",
					"$icon": "adjust",
					"$items": [{
						"$bind": "testChartsDashboard"
					}],
					"$size": "medium"
				}, {
					"$layoutType": "tile",
					"$bgColor": "blue",
					"$items": [{
						"$bind": "testContextDashboard"
					}],
					"$size": "medium"
				}, {
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$items": [{
						"$bind": "testPropertyHideShowDashboard"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$items": [{
						"$bind": "testGaugeChartDashboard"
					}],
					"$size": "small"
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "SUPERV endpoint",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "green",
					"$items": [{
						"$bind": "testSUPERVDashboard"
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$items": [{
						"$bind": "testGridDashboard"
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "GX3APP endpoint",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "blue",
					"$items": [{
						"$bind": "testGX3APPDashboard"
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$items": [{
						"$bind": "testGX3APPDashboard2"
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "SYDEV endpoint",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "purple",
					"$items": [{
						"$bind": "testSyDevDashboard"
					}],
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Default endpoint",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "mediumgrey",
					"$items": [{
						"$bind": "testAQTACTNPDashboard"
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "testTypesDashboard2",
					}],
					"$size": "medium"
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$items": [{
						"$bind": "testDefaultAQTCRUDM"
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$items": [{
						"$bind": "testDefaultAQMCRUDM"
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$items": [{
						"$bind": "testDefaultAQMFIELDSM"
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$items": [{
						"$bind": "testDefaultAQMSEARCHM"
					}]
				}]

			}]
		}
	}
};

exports.gadgets = {
	"testLayoutsDashboard": {
		"$type": "$dashboard",
		"$title": "Layout tests",
		"$description": "Layout tests",
		"dashboardName": "testLayoutsDashboard"
	},
	"testTypesDashboard": {
		"$type": "$dashboard",
		"$title": "Datatype tests",
		"$description": "Datatype tests",
		"dashboardName": "testTypesDashboard"
	},
	"testTypesDashboard2": {
		"$type": "$dashboard",
		"$title": "Datatype AQTCRUD",
		"$description": "Datatype AQTCRUD",
		"dashboardName": "testTypesDashboard2"
	},
	"testFormatsDashboard": {
		"$type": "$dashboard",
		"$title": "Formats tests",
		"$description": "Formats tests",
		"dashboardName": "testFormatsDashboard"
	},
	"testGX3APPDashboard": {
		"$type": "$dashboard",
		"$title": "GX3APP tests",
		"$description": "GX3APP tests",
		"dashboardName": "testGX3APPDashboard"
	},
	"testSUPERVDashboard": {
		"$type": "$dashboard",
		"$title": "SUPERV tests",
		"$description": "SUPERV tests",
		"dashboardName": "testSUPERVDashboard"
	},
	"testChartsDashboard": {
		"$type": "$dashboard",
		"$title": "Charts tests",
		"$description": "Charts tests",
		"dashboardName": "testChartsDashboard"
	},
	"testSUPERVDashboard2": {
		"$type": "$dashboard",
		"$title": "AQMCRUDM",
		"$description": "AQMCRUDM default endpoint",
		"dashboardName": "testSUPERVDashboard2"
	},
	"testGX3APPDashboard2": {
		"$type": "$dashboard",
		"$title": "GX3APP Cost",
		"$description": "GX3APP Cost",
		"dashboardName": "testGX3APPDashboard2"
	},
	"testConstraintsDashboard": {
		"$type": "$dashboard",
		"$title": "SData constraints",
		"$description": "SData constraints",
		"dashboardName": "testConstraintsDashboard"
	},
	"testContextDashboard": {
		"$type": "$dashboard",
		"$title": "Dashboard with context",
		"$description": "Dashboard with context",
		"dashboardName": "testContextDashboard"
	},
	"testPropertyHideShowDashboard": {
		"$type": "$dashboard",
		"$title": "Property Hide Show",
		"$description": "Dashboard PropertyHideShow",
		"dashboardName": "testPropertyHideShowDashboard"
	},
	"testAQTACTNPDashboard": {
		"$type": "$dashboard",
		"$title": "AQTACTNP Create facet",
		"$description": "AQTACTNP Create facet",
		"dashboardName": "testAQTACTNPDashboard"
	},
	"testSyDevDashboard": {
		"$type": "$dashboard",
		"$title": "Sydev entities",
		"$description": "Sydev entities",
		"dashboardName": "testSyDevDashboard"
	},
	"testGaugeChartDashboard": {
		"$type": "$dashboard",
		"$title": "Test gauge chart",
		"$description": "Test gauge chart",
		"dashboardName": "testGaugeChartDashboard"
	},
	"testGridDashboard": {
		"$type": "$dashboard",
		"$title": "Test grid authoring",
		"$description": "Test grid authoring",
		"dashboardName": "testGridDashboard"
	},
	"testDefaultAQTCRUDM": {
		"$type": "$dashboard",
		"$title": "AQTCRUDM",
		"$description": "Test AQTCRUDM",
		"dashboardName": "testDefaultAQTCRUDM"
	},
	"testDefaultAQMCRUDM": {
		"$type": "$dashboard",
		"$title": "AQMCRUDM",
		"$description": "Test AQMCRUDM",
		"dashboardName": "testDefaultAQMCRUDM"
	},
	"testDefaultAQMFIELDSM": {
		"$type": "$dashboard",
		"$title": "AQMFIELDSM",
		"$description": "Test AQMFIELDSM",
		"dashboardName": "testDefaultAQMFIELDSM"
	},
	"testDefaultAQMSEARCHM": {
		"$type": "$dashboard",
		"$title": "AQMSEARCHM",
		"$description": "Test AQMSEARCHM",
		"dashboardName": "testDefaultAQMSEARCHM"
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testLayoutsDashboard',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testLayoutsDashboard": {
		"$dashboardName": "testLayoutsDashboard",
		"$title": "Layout test dashboard",
		"$description": "Test different kinds of layouts",
		"$vignettes": {
			"testLayoutHubDashboard": {
				"$uuid": "testLayoutHubDashboard",
				"$displayStyle": "$link"
			},
			"testLayoutRowsDashboard": {
				"$uuid": "testLayoutRowsDashboard",
				"$displayStyle": "$link"
			},
			"testLongQuery": {
				"$uuid": "testLongQuery",
				"$displayStyle": "$link"
			},
			"testHubLayoutEntity": {
				"$uuid": "testHubLayoutEntity",
				"$displayStyle": "$link"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLayoutHubDashboard"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLayoutRowsDashboard"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLongQuery"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testHubLayoutEntity"
					}]
				}]
			}]
		}
	},
	"testLayoutHubDashboard": {
		"$dashboardName": "testLayoutHubDashboard",
		"$title": "Hub dashboard (scroll horizontal)",
		"$description": "Horizontal scrolling dashboard",
		"$vignettes": {
			"testDummyTile": {
				"$uuid": "testDummyTile",
				"$displayStyle": "$full"
			},
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Layout group 1",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$items": [{
						"$bind": "testDummyTile",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "name",
							}, {
								"$bind": "name",
								"$labelPosition": "left"
							}, {
								"$bind": "desc",
								"$labelPosition": "top"
							}, {
								"$bind": "desc2",
								"$labelPosition": "right"
							}, {
								"$bind": "desc2",
								"$labelAlign": "right"
							}, {
								"$bind": "amount",
								"$labelPosition": "bottom"
							}, {
								"$bind": "amount",
								"$isTitleHidden": true
							}]
						}
					}],
					"$size": "full" // as wide as a column, as high as the screen (rounded/snapped to the next "medium" size tile coordinates)
				}, {
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "medium" // square, half the width of a column
				}, {
					"$layoutType": "tile",
					"$bgColor": "sagegreen",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "small" // square, quarter size of a column
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bgColor": "darkgrey",
						"$bind": "testDummyTile"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$bgColor": "skyblue",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "wide" // fill width of a column, and half the height of the width
				}, {
					"$layoutType": "tile",
					"$bgColor": "orange",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "large" // square, width and heigth as big as a column
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Layout group 2",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "blue",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "medium",
				}, {
					"$layoutType": "tile",
					"$bgColor": "mediumgrey",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "medium",
				}, {
					"$layoutType": "tile",
					"$bgColor": "green",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "medium",
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Layout group 3",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "wide"
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "medium"
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "medium"
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Layout group 4",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "large"
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "medium"
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "medium"
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Layout group 5",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "wide"
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "full"
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "small",
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "small"
				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testDummyTile"
					}],
					"$size": "small"
				}]
			}]
		}
	},
	"testLayoutRowsDashboard": {
		"$dashboardName": "testLayoutRowsDashboard",
		"$title": "Row layout dashboard (scroll vertical)",
		"$description": "Vertical scrolling dashboard",
		"$vignettes": {
			"testDummyTile": {
				"$uuid": "testDummyTile",
				"$displayStyle": "$full"
			},
			"testDummyTileLink": {
				"$uuid": "testDummyTile",
				"$displayStyle": "$link"
			},
		},
		"$article": {
			"$layoutType": "stack",
			"$localization": {
				"en-US": {
					"67bfa0d4-958f-4929-9bd4-05a248e594c4": "On tablet portrait mode, this shows 4 cells in a line. On Mini-Tablet landscape (Nexus7) it shows three ons one cell per line. On Tablet landscape, it 2 per line. On phone or smaller its one per line"
				}
			},
			"$items": [{
				"$layoutType": "stack",
				"$title": "{@67bfa0d4-958f-4929-9bd4-05a248e594c4}",
				"$items": [{
					"$layoutType": "row",
					"$items": [{
						"$layoutType": "cell",
						"$widthLg": "3",
						"$widthSm": "6",
						"$widthXs": "12",
						"$widthMd": "4",
						"$items": [{
							"$layoutType": "stack",
							"$items": [{
								"$bind": "testDummyTileLink",
								"$article": {}
							}]
						}]
					}, {
						"$layoutType": "cell",
						"$widthLg": "3",
						"$widthSm": "6",
						"$widthXs": "12",
						"$widthMd": "4",
						"$items": [{
							"$layoutType": "stack",
							"$items": [{
								"$bind": "testDummyTileLink",
								"$article": {}
							}]
						}]
					}, {
						"$layoutType": "cell",
						"$widthLg": "3",
						"$widthSm": "6",
						"$widthXs": "12",
						"$widthMd": "4",
						"$items": [{
							"$layoutType": "stack",
							"$items": [{
								"$bind": "testDummyTileLink",
								"$article": {}
							}]
						}]
					}, {
						"$layoutType": "cell",
						"$widthLg": "3",
						"$widthSm": "6",
						"$widthXs": "12",
						"$widthMd": "12",
						"$items": [{
							"$layoutType": "stack",
							"$items": [{
								"$bind": "testDummyTileLink",
								"$article": {}
							}]
						}]
					}]
				}]
			}, {
				"$layoutType": "stack",
				"$items": [{
					"$layoutType": "row",
					"$items": [{
						"$layoutType": "cell",
						"$widthLg": "6",
						"$widthSm": "6",
						"$widthXs": "12",
						"$items": [{
							"$bind": "testDummyTile",
							"$article": {
								"$layoutType": "stack",
								"$items": [{
									"$bind": "name"
								}, {
									"$bind": "desc"
								}, {
									"$bind": "desc2"
								}, {
									"$bind": "amount"
								}]
							}
						}]
					}, {
						"$layoutType": "cell",
						"$widthLg": "6",
						"$widthSm": "6",
						"$widthXs": "12",
						"$items": [{
							"$bind": "testDummyTile",
							"$article": {
								"$layoutType": "stack",
								"$items": [{
									"$bind": "name"
								}, {
									"$bind": "desc"
								}, {
									"$bind": "desc2"
								}, {
									"$bind": "amount"
								}]
							}
						}]
					}, {
						"$layoutType": "cell",
						"$items": [{
							"$widthLg": "3",
							"$widthSm": "4",
							"$widthXs": "12",
							"$bind": "testDummyTile",
							"$article": {
								"$layoutType": "stack",
								"$items": [{
									"$bind": "name"
								}, {
									"$bind": "desc"
								}, {
									"$bind": "desc2"
								}, {
									"$bind": "amount"
								}]
							}
						}]
					}, {
						"$layoutType": "cell",
						"$items": [{
							"$widthLg": "3",
							"$widthSm": "12",
							"$widthXs": "12",
							"$bind": "testDummyTile",
							"$article": {
								"$layoutType": "stack",
								"$items": [{
									"$bind": "name"
								}, {
									"$bind": "desc"
								}, {
									"$bind": "desc2"
								}, {
									"$bind": "amount"
								}]
							}
						}]
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testLayoutHubDashboard": {
		"$type": "$dashboard",
		"$title": "Hub Layout tests",
		"$description": "Hub Layout tests",
		"dashboardName": "testLayoutHubDashboard"
	},
	"testLayoutRowsDashboard": {
		"$type": "$dashboard",
		"$title": "Rows Layout tests",
		"$description": "Rows Layout tests",
		"dashboardName": "testLayoutRowsDashboard"
	},
	"testDummyTile": {
		"$type": "$representation",
		"$title": "Dummy",
		"$description": "Dummy",
		"entity": "example",
		"action": "$details",
		"representation": "example",
		"facet": "$details",
		"keyParameter": "5"
	},
	"testLongQuery": {
		"$type": "$representation",
		"$title": "Long query",
		"$description": "Query",
		"entity": "example",
		"action": "$query",
		"representation": "example",
		"facet": "$query"
	},
	"testHubLayoutEntity": {
		"$type": "$representation",
		"$title": "Hub Layout on Representation",
		"$description": "Hub Layout on Representation",
		"entity": "exampleHubLayout",
		"action": "$details",
		"representation": "exampleHubLayout",
		"facet": "$details",
		"keyParameter": "5"
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testTypesDashboard',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testTypesDashboard": {
		"$dashboardName": "testTypesDashboard",
		"$title": "Datatypes test dashboard",
		"$description": "Test different kinds of datatypes",
		"$vignettes": {
			"testLinkQueryRecord": {
				"$uuid": "testDisplayQueryRecord",
				"$displayStyle": "$link"
			},
			"testLinkDetailsRecord": {
				"$uuid": "testDisplayDetailsRecord",
				"$displayStyle": "$link"
			},
			"testLinkEditRecord": {
				"$uuid": "testDisplayEditRecord",
				"$displayStyle": "$link"
			},
			"testLinkCreateRecord": {
				"$uuid": "testDisplayCreateRecord",
				"$displayStyle": "$link"
			},
			"testDisplayQueryRecord": {
				"$uuid": "testDisplayQueryRecord",
				"$displayStyle": "$full"
			},
			"testDisplayDetailsRecord": {
				"$uuid": "testDisplayDetailsRecord",
				"$displayStyle": "$full"
			},
			"testDisplayEditRecord": {
				"$uuid": "testDisplayEditRecord",
				"$displayStyle": "$full"
			},
			"testDisplayCreateRecord": {
				"$uuid": "testDisplayCreateRecord",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkQueryRecord"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkDetailsRecord"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkEditRecord"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkCreateRecord"
					}]
				}]
			}, {
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayQueryRecord"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayDetailsRecord"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayEditRecord"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayCreateRecord"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testDisplayDetailsRecord": {
		"$type": "$representation",
		"$title": "Details facet",
		"entity": "testDataTypes",
		"action": "$details",
		"representation": "testDataTypes",
		"facet": "$details",
		"keyParameter": "5"
	},
	"testDisplayEditRecord": {
		"$type": "$representation",
		"$title": "Edit facet",
		"entity": "testDataTypes",
		"action": "$edit",
		"representation": "testDataTypes",
		"facet": "$edit",
		"keyParameter": "5"
	},
	"testDisplayCreateRecord": {
		"$type": "$representation",
		"$title": "Create facet",
		"entity": "testDataTypes",
		"action": "$create",
		"representation": "testDataTypes",
		"facet": "$create",
		"keyParameter": "5"
	},
	"testDisplayQueryRecord": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "testDataTypes",
		"action": "$query",
		"representation": "testDataTypes",
		"facet": "$query",
		"keyParameter": "5"
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testTypesDashboard2',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testTypesDashboard2": {
		"$dashboardName": "testTypesDashboard2",
		"$title": "AQTCRUD default endpoint",
		"$description": "AQTCRUD Representation",
		"$vignettes": {
			"testLinkQueryRecord2": {
				"$uuid": "testDisplayQueryRecord2",
				"$displayStyle": "$link"
			},
			"testLinkDetailsRecord2": {
				"$uuid": "testDisplayDetailsRecord2",
				"$displayStyle": "$link"
			},
			"testLinkEditRecord2": {
				"$uuid": "testDisplayEditRecord2",
				"$displayStyle": "$link"
			},
			"testLinkCreateRecord2": {
				"$uuid": "testDisplayCreateRecord2",
				"$displayStyle": "$link"
			},
			"testDisplayQueryRecord2": {
				"$uuid": "testDisplayQueryRecord2",
				"$displayStyle": "$full"
			},
			"testDisplayDetailsRecord2": {
				"$uuid": "testDisplayDetailsRecord2",
				"$displayStyle": "$full"
			},
			"testDisplayEditRecord2": {
				"$uuid": "testDisplayEditRecord2",
				"$displayStyle": "$full"
			},
			"testDisplayCreateRecord2": {
				"$uuid": "testDisplayCreateRecord2",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkQueryRecord2"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkDetailsRecord2"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkEditRecord2"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkCreateRecord2"
					}]
				}]
			}, {
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayQueryRecord2"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayDetailsRecord2"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayEditRecord2"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayCreateRecord2"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testDisplayDetailsRecord2": {
		"$type": "$representation",
		"$title": "Details facet",
		"entity": "AQTCRUD",
		"action": "$details",
		"representation": "AQTCRUD",
		"facet": "$details",
		"keyParameter": "10"
	},
	"testDisplayEditRecord2": {
		"$type": "$representation",
		"$title": "Edit facet",
		"entity": "AQTCRUD",
		"action": "$edit",
		"representation": "AQTCRUD",
		"facet": "$edit",
		"keyParameter": "10"
	},
	"testDisplayCreateRecord2": {
		"$type": "$representation",
		"$title": "Create facet",
		"entity": "AQTCRUD",
		"action": "$create",
		"representation": "AQTCRUD",
		"facet": "$create"
	},
	"testDisplayQueryRecord2": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "AQTCRUD",
		"action": "$query",
		"representation": "AQTCRUD",
		"facet": "$query"
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testFormatsDashboard',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testFormatsDashboard": {
		"$dashboardName": "testFormatsDashboard",
		"$title": "Formatting test dashboard",
		"$description": "Test different kinds of formats",
		"$vignettes": {
			"testFormatEditRecord": {
				"$uuid": "testFormatEditRecord",
				"$displayStyle": "$full"
			},
			"testFormatReferenceDetail": {
				"$uuid": "testFormatReferenceDetail",
				"$displayStyle": "$full"
			},
			"testFormatReferenceEdit": {
				"$uuid": "testFormatReferenceEdit",
				"$displayStyle": "$full"
			},
			"testFormatReferenceQuery": {
				"$uuid": "testFormatReferenceQuery",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testFormatEditRecord"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testFormatReferenceDetail"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testFormatReferenceEdit"
					}]
				}]
			}, {
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testFormatReferenceQuery"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testFormatEditRecord": {
		"$type": "$representation",
		"$title": "Details facet",
		"entity": "testFormats",
		"action": "$edit",
		"representation": "testFormats",
		"facet": "$edit",
		"keyParameter": "5"
	},
	"testFormatReferenceDetail": {
		"$type": "$representation",
		"$title": "Details facet reference fields",
		"entity": "testFormatsReference",
		"action": "$details",
		"representation": "testFormatsReference",
		"facet": "$details",
		"keyParameter": "5"
	},
	"testFormatReferenceEdit": {
		"$type": "$representation",
		"$title": "Edit facet reference fields",
		"entity": "testFormatsReference",
		"action": "$edit",
		"representation": "testFormatsReference",
		"facet": "$edit",
		"keyParameter": "5"
	},
	"testFormatReferenceQuery": {
		"$type": "$representation",
		"$title": "Query facet reference fields",
		"entity": "testFormatsReference",
		"action": "$query",
		"representation": "testFormatsReference",
		"facet": "$query",
		"keyParameter": "5"
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testGX3APPDashboard',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testGX3APPDashboard": {
		"$dashboardName": "testGX3APPDashboard",
		"$title": "Display data from GX3APP",
		"$description": "Test different representations on GX3APP",
		"$vignettes": {
			"testACTIVQuery": {
				"$uuid": "testACTIVQuery",
				"$displayStyle": "$full"
			},
			"testRequestVEN085": {
				"$uuid": "testRequestVEN085",
				"$displayStyle": "$full"
			}
		},

		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Some data...",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testACTIVQuery"
					}],
					"$size": "full"
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Some fancy chart",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestVEN085"
					}],
					"$size": "large"
				}]
			}]
		},
	}
};

exports.gadgets = {
	"testACTIVQuery": {
		"$type": "$representation",
		"$title": "Query ACTIV",
		"entity": "ACTIV",
		"action": "$query",
		"representation": "ACTIV",
		"endpoint": "x3.erp.GX3APP",
		"facet": "$query"
	},
	"testRequestVEN085": {
		"$type": "$request",
		"$title": "Request VEN085",
		"requestName": "VEN085",
		"requestLevel": "1",
		"action": "$query",
		"endpoint": "x3.erp.GX3APP",
		"facet": "$query"
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testSUPERVDashboard',['require','exports','module'],function (require, exports, module) {

var _detailLinkArticle = {
	"$layoutType": "stack",
	"$title": "Test collapsed",
	"$collapsible": "collapsed",
	"$items": [{
		"$layoutType": "row",
		"$items": [{
			"$layoutType": "cell",
			"$widthXs": "6",
			"$widthSm": "6",
			"$widthMd": "6",
			"$widthLg": "6",
			"$bgColor": "sagegreen",
			"$items": [{
				"$bind": "MODULE"
			}, {
				"$bind": "UPDUSR_REF"
			}, {
				"$bind": "CREUSR_REF"
			}, {
				"$bind": "UNIT_REF"
			}, {
				"$bind": "TDCB2"
			}, {
				"$bind": "SITE_REF"
			}, {
				"$bind": "QTY",
				"$numDisplay": "normal"
			}, {
				"$bind": "WCUR_REF"
			}, {
				"$bind": "TEL"
			}, {
				"$bind": "TEXTAXX"
			}, {
				"$bind": "TDCB",
				"$items": [{
					"$bind": "WCUR_REF"
				}]
			}, {
				"$bind": "TEL"
			}, {
				"$bind": "TDATE"
			}]
		}, {
			"$layoutType": "cell",
			"$widthXs": "6",
			"$widthSm": "6",
			"$widthMd": "6",
			"$widthLg": "6",
			"$bgColor": "orange",
			"$items": [{
				"$bind": "CODE"
			}, {
				"$bind": "CODECHR"
			}, {
				"$bind": "TEXTDES0"
			}, {
				"$bind": "TEXTE"
			}, {
				"$bind": "CRY_REF"
			}, {
				"$bind": "CPY_REF"
			}, {
				"$bind": "CUR_REF"
			}, {
				"$bind": "TYPEATT"
			}, {
				"$bind": "HIDEWHOW"
			}, {
				"$bind": "EMAIL"
			}, {
				"$bind": "TEXTAXX"
			}, {
				"$bind": "TDCB3"
			}, {
				"$bind": "DIVERS0"
			}, {
				"$bind": "TPOSIF"
			}]
		}]
	}, {
		"$layoutType": "stack",
		"$title": "Test collapsed",
		"$collapsible": "collapsed",
		"$items": [{
			"$layoutType": "row",
			"$items": [{
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "6",
				"$widthMd": "6",
				"$widthLg": "6",
				"$items": [{
					"$bind": "PBLOB"
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "6",
				"$widthMd": "6",
				"$widthLg": "6",
				"$items": [{
					"$bind": "PBLOB2"
				}]
			}]
		}]
	}, {
		"$layoutType": "stack",
		"$collapsible": "expanded",
		"$title": "Test collapsible",
		"$items": [{
			"$layoutType": "row",
			"$items": [{
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "6",
				"$widthMd": "6",
				"$widthLg": "6",
				"$items": [{
					"$bind": "ADEVCOLREF2",
					"$article": {}
				}, {
					"$bind": "ADEVADEVCOL1",
					"$article": {}
				}, {
					"$bind": "ADEVTABL",
					"$article": {}
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "6",
				"$widthMd": "6",
				"$widthLg": "6",
				"$items": [{
					"$bind": "ADEVCOLREF1",
					"$article": {}
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "6",
				"$widthMd": "6",
				"$widthLg": "6",
				"$items": [{
					"$bind": "ADEVCTINT",
					"$article": {}
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "6",
				"$widthMd": "6",
				"$widthLg": "6",
				"$items": [{
					"$bind": "ADEVTABDATE",
					"$article": {}
				}]
			}]
		}]
	}, {
		"$layoutType": "stack",
		"$title": "Test collapsible",
		"$collapsible": "expanded",
		"$items": [{
			"$layoutType": "row",
			"$items": [{
				"$layoutType": "cell",
				"$items": [{
					"$bind": "ADEVADEVICEL",
					"$display": "card",
					"$article": {}
				}]
			}]
		}]
	}, {
		"$layoutType": "stack",
		"$collapsible": "expanded",
		"$title": "Test collapsible",
		"$items": [{
			"$layoutType": "row",
			"$items": [{
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "6",
				"$widthMd": "6",
				"$widthLg": "6",
				"$items": [{
					"$bind": "PCLOB"
				}, {
					"$bind": "TEXTHTML",
					"$labelPosition": "top"
				}, {
					"$bind": "TYEPACD",
					"$labelPosition": "top"
				}, {
					"$bind": "TYEPACB"
				}, {
					"$bind": "TEXTRTF",
					"$labelPosition": "top"
				}]
			}, {
				"$layoutType": "cell",
				"$widthXs": "6",
				"$widthSm": "6",
				"$widthMd": "6",
				"$widthLg": "6",
				"$items": [{
					"$bind": "TEXTHTML",
					"$labelPosition": "top"
				}, {
					"$bind": "TYEPACD",
					"$labelPosition": "top"
				}, {
					"$bind": "TEXTPLAIN",
					"$labelPosition": "top"
				}]
			}]
		}]
	}]
};
var _queryLinkArticle = {
	"$layoutType": "stack",
	"$items": [{
		"$bind": "$resources",
		"$display": "table",
		"$detailLinkArticle": _detailLinkArticle,
		"$table": [{
			"$bind": "CODE",
			"$title": "Code",
			"$type": "application/x-integer",
			"$titleOrig": "{@5296}",
			"$widthType": "fixed",
			"$widthVal": 4
		}, {
			"$bind": "TEXTDES0",
			"$title": "Description",
			"$type": "application/x-string",
			"$titleOrig": "{@282}",
			"$widthType": "auto",
			"$widthVal": 0
		}, {
			"$bind": "CUR_REF",
			"$title": "Currency",
			"$type": "application/x-reference",
			"$titleOrig": "{@323}",
			"$widthType": "fixed",
			"$widthVal": 6,
			"$refDescPosition": "bottom"
		}, {
			"$bind": "TDATE",
			"$title": "Date",
			"$type": "application/x-date",
			"$titleOrig": "{@212}",
			"$widthType": "fixed",
			"$widthVal": 6
		}, {
			"$bind": "CPY_REF",
			"$title": "Company",
			"$type": "application/x-reference",
			"$titleOrig": "{@1343}",
			"$widthType": "fixed",
			"$widthVal": 6,
			"$refDescPosition": "bottom"
		}, {
			"$bind": "SITE_REF",
			"$title": "Site",
			"$type": "application/x-reference",
			"$titleOrig": "{@1344}",
			"$widthType": "fixed",
			"$widthVal": 6,
			"$refDescPosition": "bottom"
		}, {
			"$bind": "CRY_REF",
			"$title": "Country",
			"$type": "application/x-reference",
			"$titleOrig": "{@263}",
			"$widthType": "fixed",
			"$widthVal": 6,
			"$refDescPosition": "bottom"
		}, {
			"$bind": "TDCB2",
			"$title": "4-décimal",
			"$type": "application/x-decimal",
			"$titleOrig": "{@28715}",
			"$widthType": "fixed",
			"$widthVal": 6
		}, {
			"$bind": "UNIT_REF",
			"$title": "Unit",
			"$type": "application/x-reference",
			"$titleOrig": "{@2685}",
			"$widthType": "fixed",
			"$widthVal": 6,
		}],
		"$article": {}
	}]
};

exports.dashboards = {
	"testSUPERVDashboard": {
		"$dashboardName": "testSUPERVDashboard",
		"$title": "Display Query AQMCRUDM",
		"$description": "",
		"$vignettes": {
			"testAQMDEVICEQuery": {
				"$uuid": "testAQMDEVICEQuery",
				"$displayStyle": "$full"
			},
			"testAQMDEVICEQueryLink": {
				"$uuid": "testAQMDEVICEQuery",
				"$displayStyle": "$link"
			},
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$items": [{
					"$layoutType": "tile",
					"$title": "QUERY display in table mode 1",
					"$size": "full",
					"$items": [{
						"$bind": "testAQMDEVICEQuery",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$arrayOptions": {
									"showSortFilter": true
								},
								"$display": "table",
								"$queryLinkArticle": _queryLinkArticle,
								"$detailLinkArticle": _detailLinkArticle,
								"$table": [{
									"$bind": "CODE",
									"$widthType": "fixed",
									"$widthVal": "3"
								}, {
									"$bind": "TDATE",
									"$widthType": "fixed",
									"$widthVal": "4"
								}, {
									"$bind": "CUR_REF",
									"$widthType": "fixed",
									"$widthVal": "3",
									"$refDescPosition": "bottom"
								}, {
									"$bind": "CPY_REF",
									"$widthType": "fixed",
									"$widthVal": "3",
									"$refDescPosition": "none"
								}]
							}]
						}
					}]
				}, {
					"$layoutType": "tile",
					"$title": "QUERY display in table mode 2",
					"$size": "full",
					"$items": [{
						"$bind": "testAQMDEVICEQuery",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$arrayOptions": {
									"showSortFilter": true
								},
								"$display": "table",
								"$queryLinkArticle": _queryLinkArticle,
								"$detailLinkArticle": _detailLinkArticle,
								"$table": [{
									"$bind": "CODE",
									"$widthType": "fixed",
									"$widthVal": "3"
								}, {
									"$bind": "TDATE",
									"$widthType": "fixed",
									"$widthVal": "4"
								}, {
									"$bind": "CUR_REF",
									"$widthType": "fixed",
									"$widthVal": "3",
									"$refDescPosition": "bottom"
								}, {
									"$bind": "CPY_REF",
									"$widthType": "fixed",
									"$widthVal": "3",
									"$refDescPosition": "none"
								}]
							}]
						}
					}]
				}, {
					"$layoutType": "tile",
					"$title": "Open in card mode",
					"$size": "medium",
					"$items": [{
						"$bind": "testAQMDEVICEQueryLink",
						"$linkArticle": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$display": "card",
								"$detailLinkArticle": _detailLinkArticle,
								"$card": {
									"$layoutType": "stack",
									"$items": [{
										"$layoutType": "row",
										"$items": [{
											"$layoutType": "cell",
											"$widthXs": "6",
											"$widthSm": "6",
											"$widthMd": "6",
											"$widthLg": "6",
											"$bgColor": "sagegreen",
											"$items": [{
												"$bind": "MODULE"
											}, {
												"$bind": "UPDUSR_REF"
											}, {
												"$bind": "CREUSR_REF"
											}, {
												"$bind": "UNIT_REF"
											}, {
												"$bind": "TDCB2"
											}, {
												"$bind": "SITE_REF"
											}, {
												"$bind": "TDATE"
											}]
										}, {
											"$layoutType": "cell",
											"$widthXs": "6",
											"$widthSm": "6",
											"$widthMd": "6",
											"$widthLg": "6",
											"$bgColor": "orange",
											"$items": [{
												"$bind": "CODE"
											}, {
												"$bind": "CODECHR"
											}, {
												"$bind": "TEXTDES0"
											}, {
												"$bind": "TEXTE"
											}, {
												"$bind": "CRY_REF"
											}, {
												"$bind": "CPY_REF"
											}, {
												"$bind": "CUR_REF"
											}]
										}]
									}]
								},
								"$minWidth": 4
							}]
						}
					}]
				}, {
					"$layoutType": "tile",
					"$title": "Open in table mode",
					"$size": "medium",
					"$items": [{
						"$bind": "testAQMDEVICEQueryLink",
						"$linkArticle": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "table",
								"$detailLinkArticle": _detailLinkArticle,
								"$table": [{
									"$bind": "CODE",
									"$widthType": "fixed",
									"$widthVal": "5"
								}, {
									"$bind": "TDATE",
									"$widthType": "fixed",
									"$widthVal": "6"
								}, {
									"$bind": "CUR_REF",
									"$widthType": "fixed",
									"$widthVal": "3",
									"$refDescPosition": "none"
								}, {
									"$bind": "CPY_REF",
									"$widthType": "fixed",
									"$widthVal": "6",
									"$refDescPosition": "top"
								}, {
									"$bind": "SITE_REF",
									"$widthType": "fixed",
									"$widthVal": "10",
									"$refDescFormat": "titledesc",
									"$refDescPosition": "bottom"
								}, {
									"$bind": "TEXTDES0"
								}]
							}]
						}
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testAQMDEVICEQuery": {
		"$type": "$representation",
		"$title": "Query AQMCRUDM",
		"entity": "AQMDEVICE",
		"action": "$query",
		"representation": "AQMCRUDM",
		"facet": "$query"
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testChartsDashboard',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testChartsDashboard": {
		"$dashboardName": "testChartsDashboard",
		"$title": "Display some charts",
		"$description": "Test different kind of charts",
		"$vignettes": {
			"testRequestChart": {
				"$uuid": "testRequestChart",
				"$displayStyle": "$full"
			}
		},

		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Big chart (!)",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "bar" // default = stick = colum = bar chart
							}]
						}
					}],
					"$size": "full",

				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "bar"
							}]
						}
					}],
					"$size": "large",

				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Bar charts",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "stick" // default = stick = colum = bar chart
							}]
						}
					}],
					"$size": "large",

				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "bar"
							}]
						}
					}],
					"$size": "large",

				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Line charts",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "line"
							}]
						}
					}],
					"$size": "large",

				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "area"
							}]
						}
					}],
					"$size": "large",

				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Spline charts",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "spline"
							}]
						}
					}],
					"$size": "large",

				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "areaspline"
							}]
						}
					}],
					"$size": "large",

				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Pie chart",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$style": "pie"
							}]
						}
					}],
					"$size": "large",

				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Test different sizes/legends",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$isLegendHidden": false,
								"$style": "line"
							}]
						}
					}],
					"$size": "large",

				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$isLegendHidden": true,
								"$style": "line"
							}]
						}
					}],
					"$size": "large",

				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$isLegendHidden": true,
								"$isXLabelHidden": true,
								"$isYLabelHidden": true,
								"$isXLabelsHidden": true,
								"$isYLabelsHidden": true,
								"$style": "line"
							}]
						}
					}],
					"$size": "wide",

				}, {
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testRequestChart",
						/* if this node is present, the layout of 
						 * the gadget is comming from this layout embedded in the dashbaord */
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": true,
								"$isLegendHidden": true,
								"$isXLabelHidden": true,
								"$isYLabelHidden": true,
								"$isXLabelsHidden": true,
								"$isYLabelsHidden": true,
								"$style": "bar"
							}]
						}
					}],
					"$size": "medium",
				}]
			}]
		},
	}
};

exports.gadgets = {
	"testRequestChart": {
		"$type": "$request",
		"$title": "Request test",
		"requestName": "testCharts",
		"requestLevel": "1",
		"action": "$query",
		"facet": "$query"
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testSUPERVDashboard2',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testSUPERVDashboard2": {
		"$dashboardName": "testSUPERVDashboard2",
		"$title": "AQMCRUDM default endpoint",
		"$description": "Test representation AQMCRUDM",
		"$vignettes": {
			"testAQTCRUDQuery": {
				"$uuid": "testAQTCRUDQuery",
				"$displayStyle": "$full"
			},
			"testAQTCRUDQueryLink": {
				"$uuid": "testAQTCRUDQuery",
				"$displayStyle": "$link"
			},
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$widthXs": "6,1",
				"$items": [{
					"$bind": "testAQTCRUDQuery"
				}, {
					"$bind": "testAQTCRUDQueryLink"
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testAQTCRUDQuery": {
		"$type": "$representation",
		"$title": "Query AQMCRUDM",
		"entity": "AQMCRUDM",
		"action": "$query",
		"representation": "AQMCRUDM",
		"facet": "$query"
	},
	"testAQTCRUDQueryLink": {
		"$type": "$representation",
		"$title": "Query 10 AQMCRUDM",
		"requestName": "10",
		"requestLevel": "1",
		"action": "$query",
		"facet": "$query"
	}

};
});

define('syracuse-tablet/html/js/sdata/entities/test/testGX3APPDashboard2',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testGX3APPDashboard2": {
		"$dashboardName": "testGX3APPDashboard2",
		"$title": "Display data from GX3APP",
		"$description": "Test PRPCOSTCTR representation on GX3APP",
		"$vignettes": {
			"testPRPCOSTCTRQuery": {
				"$uuid": "testPRPCOSTCTRQuery",
				"$displayStyle": "$full"
			}
		},

		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Some data Spending cost...",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testPRPCOSTCTRQuery"
					}],
					"$size": "full"
				}]

			}]
		},
	}
};
exports.gadgets = {
	"testPRPCOSTCTRQuery": {
		"$type": "$representation",
		"$title": "Query PRPCOSTCTR",
		"entity": "PRPCOSTCTR",
		"action": "$query",
		"representation": "PRPCOSTCTR",
		"endpoint": "x3.erp.GX3APP",
		"facet": "$query"
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testConstraintsDashboard',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testConstraintsDashboard": {
		"$dashboardName": "testConstraintsDashboard",
		"$title": "Constraints test dashboard",
		"$description": "Test SData constraints: https://github.com/Sage-ERP-X3/platform/wiki/Resource-Prototypes#type-constraints",
		"$vignettes": {
			"testConstraintsEditRecord": {
				"$uuid": "testConstraintsEditRecord",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "12",
					"$items": [{
						"$bind": "testConstraintsEditRecord"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testConstraintsEditRecord": {
		"$type": "$representation",
		"$title": "Edit facet",
		"entity": "testConstraints",
		"action": "$edit",
		"representation": "testConstraints",
		"facet": "$edit",
		"keyParameter": "5"
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testNavigateToDashboard',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testContextDashboard": {
		"$dashboardName": "testContextDashboard",
		"$title": "Test dashboard parameters",
		"$description": "Test navigation to a dashboard with parameters",
		"$vignettes": {
			"testRecordLinkToDashboard": {
				"$uuid": "testRecordLinkToDashboard",
				"$displayStyle": "$full"
			},
			"testRecordLinkToDashboardLink": {
				"$uuid": "testRecordLinkToDashboardLink",
				"$displayStyle": "$full"
			},
			"testRecordLinkToDashboardSUPERV": {
				"$uuid": "testRecordLinkToDashboardSUPERV",
				"$displayStyle": "$full"
			},
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testRecordLinkToDashboard"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testRecordLinkToDashboardLink"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testRecordLinkToDashboardSUPERV"
					}]
				}]
			}]
		}
	},
	"testContextDashboardChild": {
		"$dashboardName": "testContextDashboardChild",
		"$title": "Child dashboard",
		"$description": "Child dashboard getting parameters that are applied to the first to vignettes but not to the last one using the same representation to gather data",
		"$vignettes": {
			"testRecordWithContext1": {
				"$uuid": "testRecordWithContext",
				"$displayStyle": "$full"
			},
			"testRecordWithContext2": {
				"$uuid": "testRecordWithContext",
				"$displayStyle": "$full"
			},
			"testRecordWithoutContext": {
				"$uuid": "testRecordWithoutContext",
				"$displayStyle": "$full"
			},
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testRecordWithContext1"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testRecordWithContext2"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "4",
					"$items": [{
						"$bind": "testRecordWithoutContext"
					}]
				}]
			}]
		}
	},
	"testContextDashboardChildSUPERV": {
		"$dashboardName": "testContextDashboardChildSUPERV",
		"$title": "Child dashboard",
		"$description": "Child dashboard getting parameters",
		"$vignettes": {
			"testRecordWithContextSUPERV": {
				"$uuid": "testRecordWithContextSUPERV",
				"$displayStyle": "$full"
			},
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "12",
					"$items": [{
						"$bind": "testRecordWithContextSUPERV"
					}]
				}]
			}]
		}
	}

};

exports.gadgets = {
	"testRecordLinkToDashboard": {
		"$type": "$representation",
		"$title": "Click to navigate",
		"entity": "testNavigateTo",
		"action": "$query",
		"representation": "testNavigateTo",
		"facet": "$query"
	},
	"testRecordWithContext": {
		"$type": "$representation",
		"$title": "Click to navigate",
		"entity": "testNavigateToChild",
		"action": "$query",
		"representation": "testNavigateToChild",
		"facet": "$query",
		"parameters": {
			"where": {
				"value": "group eq '{group}'"
			}
		}
	},
	"testRecordLinkToDashboardLink": {
		"$type": "$dashboard",
		"$title": "Open dashboard w/o params",
		"dashboardName": "testContextDashboardChild"
	},
	"testRecordWithoutContext": {
		"$type": "$representation",
		"$title": "Click to navigate",
		"entity": "testNavigateToChild",
		"action": "$query",
		"representation": "testNavigateToChild",
		"facet": "$query"
	},
	"testRecordLinkToDashboardSUPERV": {
		"$type": "$representation",
		"$title": "Click to navigate",
		"entity": "AQMDEVICEM",
		"action": "$query",
		"representation": "AQMDEVICEM",
		"facet": "$query",
		"endpoint": "x3.erp.SUPERV"
	},
	"testRecordWithContextSUPERV": {
		"$type": "$representation",
		"$title": "Click to navigate",
		"entity": "AQMDEVICEM",
		"action": "$query",
		"representation": "AQMDEVICEM",
		"facet": "$query",
		"endpoint": "x3.erp.SUPERV",
		"parameters": {
			"where": {
				"value": "CODE eq {CODE}"
			}
		}
	},
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testPropertyHideShowDashboard',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testPropertyHideShowDashboard": {
		"$dashboardName": "testPropertyHideShowDashboard",
		"$title": "PropertyHideShow test dashboard",
		"$description": "Test different kinds of PropertyHideShow",
		"$vignettes": {
			"testLinkQueryRecordHS": {
				"$uuid": "testDisplayQueryRecordHS",
				"$displayStyle": "$link"
			},
			"testLinkDetailsRecordHS": {
				"$uuid": "testDisplayDetailsRecordHS",
				"$displayStyle": "$link"
			},
			"testLinkEditRecordHS": {
				"$uuid": "testDisplayEditRecordHS",
				"$displayStyle": "$link"
			},
			"testLinkCreateRecordHS": {
				"$uuid": "testDisplayCreateRecordHS",
				"$displayStyle": "$link"
			},
			"testDisplayQueryRecordHS": {
				"$uuid": "testDisplayQueryRecordHS",
				"$displayStyle": "$full"
			},
			"testDisplayDetailsRecordHS": {
				"$uuid": "testDisplayDetailsRecordHS",
				"$displayStyle": "$full"
			},
			"testDisplayEditRecordHS": {
				"$uuid": "testDisplayEditRecordHS",
				"$displayStyle": "$full"
			},
			"testDisplayCreateRecordHS": {
				"$uuid": "testDisplayCreateRecordHS",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkQueryRecordHS"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkDetailsRecordHS"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkEditRecordHS"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testLinkCreateRecordHS"
					}]
				}]
			}, {
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayQueryRecordHS"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayDetailsRecordHS"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayEditRecordHS"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testDisplayCreateRecordHS"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testDisplayDetailsRecordHS": {
		"$type": "$representation",
		"$title": "Details facet",
		"entity": "testPropertyHideShow",
		"action": "$details",
		"representation": "testPropertyHideShow",
		"facet": "$details",
		"keyParameter": "5"
	},
	"testDisplayEditRecordHS": {
		"$type": "$representation",
		"$title": "Edit facet",
		"entity": "testPropertyHideShow",
		"action": "$edit",
		"representation": "testPropertyHideShow",
		"facet": "$edit",
		"keyParameter": "5"
	},
	"testDisplayCreateRecordHS": {
		"$type": "$representation",
		"$title": "Create facet",
		"entity": "testPropertyHideShow",
		"action": "$create",
		"representation": "testPropertyHideShow",
		"facet": "$create",
		"keyParameter": "5"
	},
	"testDisplayQueryRecordHS": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "testPropertyHideShow",
		"action": "$query",
		"representation": "testPropertyHideShow",
		"facet": "$query",
		"keyParameter": "5"
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testAQTACTNPDashboard',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testAQTACTNPDashboard": {
		"$dashboardName": "testAQTACTNPDashboard",
		"$title": "AQTACTNP Facet Create",
		"$description": "Test Facet Create AQTACTNP",
		"$vignettes": {
			"testAQTACTNPCreate": {
				"$uuid": "testAQTACTNPCreate",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "testAQTACTNPCreate"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testAQTACTNPCreate": {
		"$type": "$representation",
		"$title": "Facet Create AQTACTNP",
		"entity": "AQTACTNP",
		"action": "$create",
		"representation": "AQTACTNP",
		"facet": "$create"
	}

};
});

define('syracuse-tablet/html/js/sdata/entities/test/testSyDevDashboard',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testSyDevDashboard": {
		"$dashboardName": "testSyDevDashboard",
		"$title": "Display Query AQMCRUDM from SyDev",
		"$description": "Test different representations on SyDev",
		"$vignettes": {
			"testSyDev_QAQT02_Request": {
				"$uuid": "testSyDev_QAQT02_Request",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$items": [{
					"$layoutType": "tile",
					"$items": [{
						"$bind": "testSyDev_QAQT02_Request"
					}],
					"$size": "full"
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testSyDev_QAQT02_Request": {
		"$type": "$request",
		"$title": "Request QAQT02",
		"requestName": "QAQT02",
		"requestLevel": "99",
		"action": "$query",
		"endpoint": "x3.erp.SYDEV",
		"facet": "$query"
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testGridDashboard',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testGridDashboard": {
		"$dashboardName": "testGridDashboard",
		"$title": "Arrays - Test dashboard",
		"$description": "Arrays - Test dashboard",
		"$vignettes": {
			"testAQMDEVICEQueryGrid": {
				"$uuid": "testAQMDEVICEQueryGrid",
				"$displayStyle": "$full"
			},
			"testAQMDEVICEDetailGrid": {
				"$uuid": "testAQMDEVICEDetailGrid",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "AQMCRUDM.$Query - Table Mode",
				"$items": [{
					"$layoutType": "tile",
					"$size": "full",
					"$items": [{
						"$bind": "testAQMDEVICEQueryGrid",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$title": "QUERY - $display=table",
								"$display": "table",
								"$table": [{
									"$bind": "CODE"
								}, {
									"$bind": "CODECHR"
								}, {
									"$bind": "TEXTDES0"
								}, {
									"$bind": "CUR_REF"
								}]
							}]
						}
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "AQMCRUDM.$Query - Vertical Cards - Multiple",
				"$items": [{
					"$layoutType": "tile",
					"$size": "full",
					"$items": [{
						"$bind": "testAQMDEVICEQueryGrid",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "card",
								"$cardsPerRow": 1,
								"$emptycell": "filled",
								"$article": {
									"$items": [{
										"$bind": "CODE"
									}, {
										"$bind": "CODECHR"
									}, {
										"$bind": "TEXTDES0"
									}, {
										"$bind": "CUR_REF"
									}]
								}
							}]
						}
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "AQMCRUDM.$Query - Vertical Cards - Single",
				"$items": [{
					"$layoutType": "tile",
					"$size": "full",
					"$items": [{
						"$bind": "testAQMDEVICEQueryGrid",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "card",
								"$cardsPerRow": 3,
								"$emptycell": "filled",
								"$article": {
									"$items": [{
										"$bind": "CODE"
									}, {
										"$bind": "CODECHR"
									}, {
										"$bind": "TEXTDES0"
									}, {
										"$bind": "CUR_REF"
									}]
								}
							}]
						}
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "$Details facet",
				"$items": [{
					"$layoutType": "tile",
					"$size": "full",
					"$items": [{
						"$bind": "testAQMDEVICEDetailGrid"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testAQMDEVICEQueryGrid": {
		"$type": "$representation",
		"$title": "Query AQMCRUDM",
		"entity": "AQMDEVICE",
		"action": "$query",
		"representation": "AQMCRUDM",
		"facet": "$query"
	},
	"testAQMDEVICEDetailGrid": {
		"$type": "$representation",
		"$title": "Detail AQMCRUDM",
		"entity": "AQMDEVICE",
		"action": "$details",
		"representation": "AQMCRUDM",
		"facet": "$details",
		"keyParameter": "1"
	}

};
});

define('syracuse-tablet/html/js/sdata/entities/test/testSUPERVAQTCRUDMDashboard',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testDefaultAQTCRUDM": {
		"$dashboardName": "testDefaultAQTCRUDM",
		"$title": "AQTCRUDM default endpoint",
		"$description": "AQTCRUDM Representation",
		"$vignettes": {
			"testDefaultAQTCRUDM_AQTCRUDM_QUERY": {
				"$uuid": "testDefaultAQTCRUDM_AQTCRUDM_QUERY",
				"$displayStyle": "$full"
			},
			"testDefaultAQTCRUDM_AQTCRUDM_DETAIL": {
				"$uuid": "testDefaultAQTCRUDM_AQTCRUDM_DETAIL",
				"$displayStyle": "$full"
			},
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "testDefaultAQTCRUDM_AQTCRUDM_QUERY"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "testDefaultAQTCRUDM_AQTCRUDM_DETAIL"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testDefaultAQTCRUDM_AQTCRUDM_QUERY": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "AQTCRUDM",
		"action": "$query",
		"representation": "AQTCRUDM",
		"facet": "$query"
	},
	"testDefaultAQTCRUDM_AQTCRUDM_DETAIL": {
		"$type": "$representation",
		"$title": "Details facet",
		"entity": "AQTCRUDM",
		"action": "$details",
		"representation": "AQTCRUDM",
		"facet": "$details",
		"keyParameter": "10"
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testSUPERVAQMCRUDMDashboard',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testDefaultAQMCRUDM": {
		"$dashboardName": "testDefaultAQMCRUDM",
		"$title": "AQMCRUDM default endpoint",
		"$description": "AQMCRUDM Representation",
		"$vignettes": {
			"testDefaultAQMCRUDM_AQMCRUDM_QUERY": {
				"$uuid": "testDefaultAQMCRUDM_AQMCRUDM_QUERY",
				"$displayStyle": "$full"
			},
			"testDefaultAQMCRUDM_AQMCRUDM_DETAIL": {
				"$uuid": "testDefaultAQMCRUDM_AQMCRUDM_DETAIL",
				"$displayStyle": "$full"
			},
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "testDefaultAQMCRUDM_AQMCRUDM_QUERY",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$title": "QUERY - $display=table, bind some unexistant fields",
								"$display": "table",
								"$article": {
									"$items": [{
										"$bind": "CODE"
									}, {
										"$bind": "CPY_REF"
									}, {
										"$bind": "CUR_REF"
									}, {
										/* to test  globals.getDvlpOpt("showUnfoundFields") option */
										"$bind": "I_do_not_exist"
									}]
								}
							}]
						}
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "testDefaultAQMCRUDM_AQMCRUDM_DETAIL"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testDefaultAQMCRUDM_AQMCRUDM_QUERY": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "AQMCRUDM",
		"action": "$query",
		"representation": "AQMCRUDM",
		"facet": "$query"
	},
	"testDefaultAQMCRUDM_AQMCRUDM_DETAIL": {
		"$type": "$representation",
		"$title": "Details facet",
		"entity": "AQMCRUDM",
		"action": "$details",
		"representation": "AQMCRUDM",
		"facet": "$details",
		"keyParameter": "10"
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testSUPERVAQMTABLEMDashboard',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testDefaultAQMFIELDSM": {
		"$dashboardName": "testDefaultAQMFIELDSM",
		"$title": "AQMFIELDSM SUPERV endpoint",
		"$description": "AQMFIELDSM Representation",
		"$vignettes": {
			"testDefaultAQMFIELDSM_AQMFIELDSM_QUERY": {
				"$uuid": "testDefaultAQMFIELDSM_AQMFIELDSM_QUERY",
				"$displayStyle": "$full"
			},
			"testDefaultAQMFIELDSM_AQMFIELDSM_DETAIL": {
				"$uuid": "testDefaultAQMFIELDSM_AQMFIELDSM_DETAIL",
				"$displayStyle": "$full"
			},
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "testDefaultAQMFIELDSM_AQMFIELDSM_QUERY"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "6",
					"$items": [{
						"$bind": "testDefaultAQMFIELDSM_AQMFIELDSM_DETAIL"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testDefaultAQMFIELDSM_AQMFIELDSM_QUERY": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "AQMDEVICE",
		"action": "$query",
		"representation": "AQMFIELDSM",
		"facet": "$query"
	},
	"testDefaultAQMFIELDSM_AQMFIELDSM_DETAIL": {
		"$type": "$representation",
		"$title": "Details facet",
		"entity": "AQMDEVICE",
		"action": "$details",
		"representation": "AQMFIELDSM",
		"facet": "$details",
		"keyParameter": "10"
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testSUPERVAQMSEARCHMDashboard',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testDefaultAQMSEARCHM": {
		"$dashboardName": "testDefaultAQMSEARCHM",
		"$title": "AQMSEARCHM SUPERV",
		"$description": "AQMSEARCHM Representation",
		"$vignettes": {
			"testDefaultAQMSEARCHM_AQMSEARCHM_QUERY": {
				"$uuid": "testDefaultAQMSEARCHM_AQMSEARCHM_QUERY",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "12",
					"$items": [{
						"$bind": "testDefaultAQMSEARCHM_AQMSEARCHM_QUERY"
					}]
				}]
			}]
		}
	}
};
exports.gadgets = {
	"testDefaultAQMSEARCHM_AQMSEARCHM_QUERY": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "AQMSEARCH",
		"action": "$query",
		"representation": "AQMSEARCHM",
		"facet": "$query"
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testGaugeChartDashboard',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"testGaugeChartDashboard": {
		"$dashboardName": "testGaugeChartDashboard",
		"$title": "Gauge chart test dashboard",
		"$description": "Test different gauge charts authoring",
		"$vignettes": {
			"testGauge": {
				"$uuid": "testGauge",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testGauge",
						$article: {
							$layoutType: "stack",
							$items: [{
								$bind: "salesOp",
								/* GAUGE 1 */
								$gauge: {}
							}]
						}
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testGauge",
						$article: {
							$layoutType: "stack",
							$items: [{
								$bind: "salesOp",
								/* GAUGE 2 */
								"$gauge": {
									"segments": [{
										"propStart": 0,
										"propEnd": 0.75
									}, {
										"propStart": 0.75,
										"propEnd": 0.85
									}, {
										"propStart": 0.85,
										"propEnd": 1
									}]
								}
							}]
						}
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testGauge",
						$article: {
							$layoutType: "stack",
							$items: [{
								$bind: "salesValue",
								/* GAUGE 3 */
								"$gauge": {
									"$bindMin": "salesValueMin",
									"$bindMax": "salesValueMax",
									"segments": [{
										"propStart": 0,
										"propEnd": 0.75
									}, {
										"propStart": 0.75,
										"propEnd": 0.85
									}, {
										"propStart": 0.85,
										"propEnd": 1
									}]
								}
							}]
						}
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "3",
					"$items": [{
						"$bind": "testGauge",
						$article: {
							$layoutType: "stack",
							$items: [{
								$bind: "salesValue",
								/* GAUGE 4 */
								"$gauge": {
									"$bindMin": "salesValueMin",
									"$bindMax": "salesValueMax",
									"segments": [{
										"valStart": 100000,
										"valEnd": 130000,
										"color": "#DF5353"
									}, {
										"valStart": 130000,
										"valEnd": 140000
									}, {
										"valStart": 140000,
										"valEnd": 150000,
										"color": "#55BF3B"
									}]
								}
							}]
						}
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"testGauge": {
		"$type": "$representation",
		"$title": "Gauge 1",
		"entity": "testGaugeChart",
		"action": "$details",
		"representation": "testGaugeChart",
		"facet": "$details"
	}
};
});

define('syracuse-tablet/html/js/sdata/entities/test/testApplication',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/sdata/entities/test/example','syracuse-tablet/html/js/sdata/entities/test/exampleHubLayout','syracuse-tablet/html/js/sdata/entities/test/testDatatypes','syracuse-tablet/html/js/sdata/entities/test/testFormats','syracuse-tablet/html/js/sdata/entities/test/testFormatsReference','syracuse-tablet/html/js/sdata/entities/test/testCharts','syracuse-tablet/html/js/sdata/entities/test/testConstraints','syracuse-tablet/html/js/sdata/entities/test/testNavigateTo','syracuse-tablet/html/js/sdata/entities/test/testNavigateToChild','syracuse-tablet/html/js/sdata/entities/test/testPropertyHideShow','syracuse-tablet/html/js/sdata/entities/test/testGaugeChart','syracuse-tablet/html/js/sdata/entities/test/testHomeDashboard','syracuse-tablet/html/js/sdata/entities/test/testLayoutsDashboard','syracuse-tablet/html/js/sdata/entities/test/testTypesDashboard','syracuse-tablet/html/js/sdata/entities/test/testTypesDashboard2','syracuse-tablet/html/js/sdata/entities/test/testFormatsDashboard','syracuse-tablet/html/js/sdata/entities/test/testGX3APPDashboard','syracuse-tablet/html/js/sdata/entities/test/testSUPERVDashboard','syracuse-tablet/html/js/sdata/entities/test/testChartsDashboard','syracuse-tablet/html/js/sdata/entities/test/testSUPERVDashboard2','syracuse-tablet/html/js/sdata/entities/test/testGX3APPDashboard2','syracuse-tablet/html/js/sdata/entities/test/testConstraintsDashboard','syracuse-tablet/html/js/sdata/entities/test/testNavigateToDashboard','syracuse-tablet/html/js/sdata/entities/test/testPropertyHideShowDashboard','syracuse-tablet/html/js/sdata/entities/test/testAQTACTNPDashboard','syracuse-tablet/html/js/sdata/entities/test/testSyDevDashboard','syracuse-tablet/html/js/sdata/entities/test/testGridDashboard','syracuse-tablet/html/js/sdata/entities/test/testSUPERVAQTCRUDMDashboard','syracuse-tablet/html/js/sdata/entities/test/testSUPERVAQMCRUDMDashboard','syracuse-tablet/html/js/sdata/entities/test/testSUPERVAQMTABLEMDashboard','syracuse-tablet/html/js/sdata/entities/test/testSUPERVAQMSEARCHMDashboard','syracuse-tablet/html/js/sdata/entities/test/testGaugeChartDashboard'],function (require, exports, module) {

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');

var _example = require('syracuse-tablet/html/js/sdata/entities/test/example');
var _exampleHubLayout = require('syracuse-tablet/html/js/sdata/entities/test/exampleHubLayout');
var _testDatatypes = require('syracuse-tablet/html/js/sdata/entities/test/testDatatypes');
var _testFormats = require('syracuse-tablet/html/js/sdata/entities/test/testFormats');
var _testFormatsReference = require('syracuse-tablet/html/js/sdata/entities/test/testFormatsReference');
var _testCharts = require('syracuse-tablet/html/js/sdata/entities/test/testCharts');
var _testConstraints = require('syracuse-tablet/html/js/sdata/entities/test/testConstraints');
var _testNavigateTo = require('syracuse-tablet/html/js/sdata/entities/test/testNavigateTo');
var _testNavigateToChild = require('syracuse-tablet/html/js/sdata/entities/test/testNavigateToChild');
var _testPropertyHideShow = require('syracuse-tablet/html/js/sdata/entities/test/testPropertyHideShow');
var _testGaugeChart = require('syracuse-tablet/html/js/sdata/entities/test/testGaugeChart');

var _testHomeDashboard = require('syracuse-tablet/html/js/sdata/entities/test/testHomeDashboard');
var _testLayoutsDashboard = require('syracuse-tablet/html/js/sdata/entities/test/testLayoutsDashboard');
var _testTypesDashboard = require('syracuse-tablet/html/js/sdata/entities/test/testTypesDashboard');
var _testTypesDashboard2 = require('syracuse-tablet/html/js/sdata/entities/test/testTypesDashboard2');
var _testFormatsDashboard = require('syracuse-tablet/html/js/sdata/entities/test/testFormatsDashboard');
var _testGX3APPDashboard = require('syracuse-tablet/html/js/sdata/entities/test/testGX3APPDashboard');
var _testSUPERVDashboard = require('syracuse-tablet/html/js/sdata/entities/test/testSUPERVDashboard');
var _testChartsDashboard = require('syracuse-tablet/html/js/sdata/entities/test/testChartsDashboard');
var _testSUPERVDashboard2 = require('syracuse-tablet/html/js/sdata/entities/test/testSUPERVDashboard2');
var _testGX3APPDashboard2 = require('syracuse-tablet/html/js/sdata/entities/test/testGX3APPDashboard2');
var _testConstraintsDashboard = require('syracuse-tablet/html/js/sdata/entities/test/testConstraintsDashboard');
var _testNavigateToDashboard = require('syracuse-tablet/html/js/sdata/entities/test/testNavigateToDashboard');
var _testPropertyHideShowDashboard = require('syracuse-tablet/html/js/sdata/entities/test/testPropertyHideShowDashboard');
var _testAQTACTNPDashboard = require('syracuse-tablet/html/js/sdata/entities/test/testAQTACTNPDashboard');
var _testSyDevDashboard = require('syracuse-tablet/html/js/sdata/entities/test/testSyDevDashboard');
var _testGridDashboard = require('syracuse-tablet/html/js/sdata/entities/test/testGridDashboard');
var _testDefaultAQTCRUDM = require('syracuse-tablet/html/js/sdata/entities/test/testSUPERVAQTCRUDMDashboard');
var _testDefaultAQMCRUDM = require('syracuse-tablet/html/js/sdata/entities/test/testSUPERVAQMCRUDMDashboard');
var _testDefaultAQMFIELDSM = require('syracuse-tablet/html/js/sdata/entities/test/testSUPERVAQMTABLEMDashboard');
var _testDefaultAQMSEARCHM = require('syracuse-tablet/html/js/sdata/entities/test/testSUPERVAQMSEARCHMDashboard');

var _testGaugeChartDashboard = require('syracuse-tablet/html/js/sdata/entities/test/testGaugeChartDashboard');

var _testApplication = {
	"$application": {
		"$uuid": "clientTestApplication",

		"applicationName": "clientTestApplication",
		"title": "Client test application",
		"description": "Application for testing client features without server dependencies",
		"iconName": "th",

		"$homeDashboard": {
			"$uuid": "testHomeDashboard",
			"dashboardName": "testHomeDashboard"
		},
	},
	"$dashboards": {},
	"$gadgets": {},
	"$pages": {
		/*
		 * Example on how to define a default article for an X3 representation
		 * that is used in a client side defined application
		 */
		"x3.erp.SUPERV.AQMCRUDM.$details": {
			"$page": {
				"$article": {
					"$layoutType": "stack",
					"$items": [{
						"$bind": "CODE"
					}, {
						"$bind": "PBLOB"
					}, {
						"$bind": "CODECHR"
					}, {
						"$bind": "WCUR_REF"
					}, {
						"$bind": "FLGTEST"
					}, {
						"$bind": "WMENU"
					}, {
						"$bind": "SIMUL1"
					}, {
						"$bind": "PCLOB"
					}, {
						"$bind": "TEXTAXX"
					}, {
						"$bind": "TEXTE"
					}, {
						"$bind": "TPOSIF"
					}, {
						"$bind": "CUR_REF"
					}, {
						"$bind": "SITE_REF"
					}, {
						"$bind": "TDCB2"
					}, {
						"$bind": "TDCB3",
						"$gauge": {}
					}, {
						"$bind": "TDCB"
					}, {
						"$bind": "TDATE"
					}, {
						"$bind": "UNIT_REF"
					}, {
						"$bind": "CRY_REF"
					}, {
						"$bind": "TEL"
					}, {
						"$bind": "EMAIL"
					}, {
						"$bind": "TEXTPLAIN"
					}, {
						"$bind": "TEXTHTML"
					}, {
						"$bind": "TEXTRTF"
					}, {
						"$bind": "CREUSR_REF"
					}, {
						"$bind": "UPDUSR_REF"
					}, {
						"$bind": "ADEVCOLREF1"
					}, {
						"$bind": "ADEVCOLREF2"
					}, {
						"$bind": "ADEVCTINT"
					}, {
						"$bind": "ADEVADEVICEL"
					}]
				}
			}
		}
	}
};

function _addToApp(app) {
	if (app.gadgets) {
		Object.keys(app.gadgets).forEach(function(key) {
			if (_testApplication.$gadgets[key]) {
				console.log("Duplicate gadget name: " + key);
			}
			_testApplication.$gadgets[key] = app.gadgets[key];
		});
	}
	if (app.dashboards) {
		Object.keys(app.dashboards).forEach(function(key) {
			if (_testApplication.$dashboards[key]) {
				console.log("Duplicate dashboard name: " + key);
			}
			_testApplication.$dashboards[key] = app.dashboards[key];
		});
	}
}

exports.register = function() {
	clientContract.registerEntity(_example.entity);
	clientContract.registerEntity(_exampleHubLayout.entity);

	clientContract.registerEntity(_testDatatypes.entity);
	clientContract.registerEntity(_testFormats.entity);
	clientContract.registerEntity(_testFormatsReference.entity);
	clientContract.registerEntity(_testCharts.entity);
	clientContract.registerEntity(_testConstraints.entity);
	clientContract.registerEntity(_testNavigateTo.entity);
	clientContract.registerEntity(_testNavigateToChild.entity);
	clientContract.registerEntity(_testPropertyHideShow.entity);
	clientContract.registerEntity(_testGaugeChart.entity);

	_addToApp(_testHomeDashboard);
	_addToApp(_testLayoutsDashboard);
	_addToApp(_testTypesDashboard);
	_addToApp(_testTypesDashboard2);
	_addToApp(_testFormatsDashboard);
	_addToApp(_testGX3APPDashboard);
	_addToApp(_testSUPERVDashboard);
	_addToApp(_testChartsDashboard);
	_addToApp(_testSUPERVDashboard2);
	_addToApp(_testGX3APPDashboard2);
	_addToApp(_testConstraintsDashboard);
	_addToApp(_testNavigateToDashboard);
	_addToApp(_testPropertyHideShowDashboard);
	_addToApp(_testAQTACTNPDashboard);
	_addToApp(_testSyDevDashboard);
	_addToApp(_testGaugeChartDashboard);
	_addToApp(_testGridDashboard);
	_addToApp(_testDefaultAQTCRUDM);
	_addToApp(_testDefaultAQMCRUDM);
	_addToApp(_testDefaultAQMFIELDSM);
	_addToApp(_testDefaultAQMSEARCHM);

	clientContract.registerApp(_testApplication);
};
});

define('syracuse-tablet/html/js/demos/salesMyCustomers/dashCustomers',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"$customersDashboard": {
		"$dashboardName": "$customersDashboard",
		"$title": "Customer Dashboard",
		"$description": "",
		"$vignettes": {
			"$x3CustomersList": {
				"$uuid": "$x3CustomersList",
				"$displayStyle": "$full"
			},
			"$localCustomerTotals": {
				"$uuid": "$localCustomerTotals",
				"$displayStyle": "$full"
			},
			"$localOverviewSales_rev_perc": {
				"$uuid": "$localOverviewSales_rev_perc",
				"$displayStyle": "$full"
			},
			"$localOverviewSalesLeads": {
				"$uuid": "$localOverviewSalesLeads",
				"$displayStyle": "$full"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Dashboard",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Sales leads",
					"$size": "full",
					"$bgColor": "lightgreen",
					"$items": [{
						"$bind": "$localOverviewSalesLeads",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$isTitleHidden": false,
								"$style": "line",
								"$display": "table",
								"$article": {
									"$items": [{
										"$bind": "date"
									}, {
										"$bind": "numLeads"
									}, {
										"$bind": "numDeals"
									}]
								}
							}]
						}
					}]
				}, {
					"$layoutType": "tile",
					"$size": "medium",
					"$bgColor": "skyblue",
					"$title": "Quote values",
					"$items": [{
						"$bind": "$localCustomerTotals",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "quotesValue",
								"$gauge": {
									"$bindMin": "min",
									"$bindMax": "quotesMax",
									"segments": [{
										"propStart": 0,
										"propEnd": 0.75,
										"color": "#DF5353"
									}, {
										"propStart": 0.75,
										"propEnd": 0.85,
									}, {
										"propStart": 0.85,
										"propEnd": 1,
										"color": "#55BF3B"
									}]
								}
							}]
						}
					}]
				}, {
					"$layoutType": "tile",
					"$size": "large",
					"$bgColor": "skyblue",
					"$title": "Monthly revenues",
					"$items": [{
						"$bind": "$localOverviewSales_rev_perc",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "revMonthly",
								"$gauge": {
									"$bindMin": "revMonthlyMin",
									"$bindMax": "revMonthlyMax",
									"segments": [{
										"propStart": 0,
										"propEnd": 0.75,
										"color": "#DF5353"
									}, {
										"propStart": 0.75,
										"propEnd": 0.85,
										"color": "#FF5800"
									}, {
										"propStart": 0.85,
										"propEnd": 1,
										"color": "#55BF3B"
									}]
								}
							}]
						}
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Customer List",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Customers list",
					"$size": "all",
					"$items": [{
						"$bind": "$x3CustomersList",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "card",
								"ss$card": {
									"$layoutType": "stack",
									"$items": [{
										"$bind": "BPCNUM"
									}, {
										"$bind": "BPCNAM"
									}, {
										"$bind": "TEXTDES0"
									}, {
										"$bind": "RPOSCOD"
									}, {
										"$bind": "BPCSTA"
									}, {
										"$bind": "BPCTYP"
									}]
								}
							}]
						}
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"$x3CustomersList": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "BPCUSTOMER",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "BPCUSTOMERM",
		"facet": "$query"
	},
	"$localCustomerTotals": {
		"$type": "$representation",
		"$title": "Totals",
		"entity": "$localCustomer",
		"action": "$details",
		"representation": "$localCustomer",
		"facet": "$details",
		"keyParameter": "10"
	},
	"$localOverviewSalesLeads": {
		"$type": "$representation",
		"$title": "Leads vs Deals",
		"entity": "$localOverviewSalesLeads",
		"action": "$query",
		"representation": "$localOverviewSalesLeads",
		"facet": "$query",
	},
	"$localOverviewSales_rev_perc": {
		"$type": "$representation",
		"$title": "Overview",
		"entity": "$localOverviewSales",
		"action": "$details",
		"representation": "$localOverviewSales",
		"facet": "$details",
		"keyParameter": "10"
	}
};
});

define('syracuse-tablet/html/js/demos/utils',['require','exports','module'],function (require, exports, module) {


exports.addToApp = function(app, toAdd) {
	if (toAdd.gadgets) {
		Object.keys(toAdd.gadgets).forEach(function(key) {
			if (app.$gadgets[key]) {
				console.log("Duplicate gadget name: " + key);
			}
			app.$gadgets[key] = toAdd.gadgets[key];
		});
	}
	if (toAdd.dashboards) {
		Object.keys(toAdd.dashboards).forEach(function(key) {
			if (app.$dashboards[key]) {
				console.log("Duplicate dashboard name: " + key);
			}
			app.$dashboards[key] = toAdd.dashboards[key];
		});
	}
};
});

define('syracuse-tablet/html/js/demos/_entities/entTodos',['require','exports','module'],function (require, exports, module) {

var _todos = [{
	$uuid: "1",
	date: "2015-02-01 09:00:00",
	who: "Mr. Miller",
	desc: "Call"
}, {
	$uuid: "2",
	date: "2015-02-09 10:00:00",
	who: "Mr. Miller",
	desc: "Meeting"
}, {
	$uuid: "3",
	date: "2015-03-04 09:00:00",
	who: "Mr. Heinz",
	desc: "Milestone definition"
}, {
	$uuid: "4",
	date: "2015-03-05 15:00:00",
	who: "Mr. Schmidt",
	desc: "Project review"
}, {
	$uuid: "5",
	date: "2015-03-08 14:00:00",
	who: "Mr. Miller",
	desc: "Call"
}, {
	$uuid: "6",
	date: "2015-03-09 15:40:00",
	who: "Mr. Miller",
	desc: "Call"
}, {
	$uuid: "7",
	date: "2015-03-10 15:50:00",
	who: "Mr. Miller",
	desc: "Call"
}, {
	$uuid: "8",
	date: "2015-03-11 14:00:00",
	who: "Mr. Miller",
	desc: "Call"
}, {
	$uuid: "9",
	date: "2015-03-11 14:00:00",
	who: "Mr. Miller",
	desc: "Call"
}, {
	$uuid: "10",
	date: "2015-03-11 14:00:00",
	who: "Mr. Miller",
	desc: "Call"
}, {
	$uuid: "11",
	date: "2015-03-11 14:00:00",
	who: "Mr. Miller",
	desc: "Call"
}, {
	$uuid: "12",
	date: "2015-03-11 14:00:00",
	who: "Mr. Miller",
	desc: "Call"
}, {
	$uuid: "13",
	date: "2015-03-11 14:00:00",
	who: "Mr. Miller",
	desc: "Call"
}];

exports.entity = {
	$entityName: "$localTodo",
	$value: "{desc}",
	$properties: {
		who: {
			$type: "application/x-string",
			$title: "Who"
		},
		desc: {
			$type: "application/x-string",
			$title: "Description"
		},
		date: {
			$type: "application/x-datetime",
			$title: "Date"
		},
	},
	$articles: {},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve(_todos[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _todos
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/_entities/entOverviewSales',['require','exports','module'],function (require, exports, module) {

var _data = {
	$uuid: "1",
	revMonthlyMin: 100000,
	revMonthly: 180000,
	revMonthlyMax: 200000,
	revMonthlyPerc: 92
};

exports.entity = {
	$entityName: "$localOverviewSales",
	$value: "{revMonthly}",
	$properties: {
		revMonthlyMin: {
			$type: "application/x-decimal",
			$title: "Min"
		},
		revMonthlyMax: {
			$type: "application/x-decimal",
			$title: "Target"
		},
		revMonthly: {
			$type: "application/x-decimal",
			$title: "Revenue"
		},
		revMonthlyPerc: {
			$type: "application/x-decimal",
			$title: "Monthly Target"
		},
	},
	$articles: {},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve(_data);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: [_data]
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/_entities/entOverviewSalesLeads',['require','exports','module'],function (require, exports, module) {

var _data = [{
	$uuid: "1",
	date: "2014-12-05",
	numLeads: 50,
	numDeals: 40,
}, {
	$uuid: "1",
	date: "2014-12-12",
	numLeads: 53,
	numDeals: 45,
}, {
	$uuid: "1",
	date: "2014-12-15",
	numLeads: 54,
	numDeals: 47,
}, {
	$uuid: "1",
	date: "2014-12-22",
	numLeads: 53,
	numDeals: 49,
}, {
	$uuid: "1",
	date: "2014-12-29",
	numLeads: 52,
	numDeals: 52,
}];

exports.entity = {
	$entityName: "$localOverviewSalesLeads",
	$value: "{date}",
	$properties: {
		date: {
			$type: "application/x-date",
			$title: "Date"
		},
		numLeads: {
			$type: "application/x-decimal",
			$title: "Leads"
		},
		numDeals: {
			$type: "application/x-decimal",
			$title: "Deals"
		}
	},
	$articles: {},
	$prototype: function(proto) {

		// Add some chart information in $query prototype
		var res = proto.$properties && proto.$properties.$resources;
		if (res) {
			res.$axes = [{
				$title: "Date",
				$hierarchies: [
					["date"]
				]
			}, {
				$hierarchies: [
					["$measures"]
				]
			}];
			res.$cube = {
				$title: "Leads vs Deals",
				$hierarchies: {
					date: {
						$properties: ["date"]
					}
				},
				$measures: {
					numLeads: {},
					numDeals: {}
				}
			};
		}
	},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve(_data[0]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _data
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/_entities/entCustomers',['require','exports','module','syracuse-tablet/html/js/helpers/utils'],function (require, exports, module) {
var utils = require('syracuse-tablet/html/js/helpers/utils');

var _names = [
	"Acme, inc.",
	"Widget Corp",
	"123 Warehousing",
	"Demo Company",
	"Smith and Co.",
	"Foo Bars",
	"ABC Telecom",
	"Fake Brothers",
	"QWERTY Logistics",
	"Demo, inc.",
	"Sample Company",
	"Sample, inc",
	"Acme Corp",
	"Allied Biscuit",
	"Ankh-Sto Associates",
	"Extensive Enterprise",
	"Galaxy Corp",
	"Globo-Chem",
	"Mr. Sparkle",
	"Globex Corporation",
	"LexCorp",
	"LuthorCorp",
	"North Central Positronics",
	"Omni Consimer Products",
	"Praxis Corporation",
	"Sombra Corporation",
	"Sto Plains Holdings",
	"Tessier-Ashpool",
	"Wayne Enterprises",
	"Wentworth Industries",
	"ZiffCorp",
	"Bluth Company",
	"Strickland Propane",
	"Thatherton Fuels",
	"Three Waters",
	"Water and Power",
	"Western Gas & Electric",
	"Mammoth Pictures",
	"Mooby Corp",
	"Gringotts",
	"Thrift Bank",
	"Flowers By Irene",
	"The Legitimate Businessmens Club",
	"Osato Chemicals",
	"Transworld Consortium",
	"Universal Export",
	"United Fried Chicken",
	"Virtucon",
	"Kumatsu Motors",
	"Keedsler Motors",
	"Powell Motors",
	"Industrial Automation",
	"Sirius Cybernetics Corporation",
	"U.S. Robotics and Mechanical Men",
	"Colonial Movers",
	"Corellian Engineering Corporation",
	"Incom Corporation",
	"General Products",
	"Leeding Engines Ltd.",
	"Blammo",
	"Input, Inc.",
	"Mainway Toys",
	"Videlectrix",
	"Zevo Toys",
	"Ajax",
	"Axis Chemical Co.",
	"Barrytron",
	"Carrys Candles",
	"Cogswell Cogs",
	"Spacely Sprockets",
	"General Forge and Foundry",
	"Duff Brewing Company",
	"Dunder Mifflin",
	"General Services Corporation",
	"Monarch Playing Card Co.",
	"Krustyco",
	"Initech",
	"Roboto Industries",
	"Primatech",
	"Sonky Rubber Goods",
	"St. Anky Beer",
	"Stay Puft Corporation",
	"Vandelay Industries",
	"Wernham Hogg",
	"Gadgetron",
	"Burleigh and Stronginthearm",
	"BLAND Corporation",
	"Nordyne Defense Dynamics",
	"Petrox Oil Company",
	"Roxxon",
	"McMahon and Tate",
	"Sixty Second Avenue",
	"Charles Townsend Agency",
	"Spade and Archer",
	"Megadodo Publications",
	"Rouster and Sideways",
	"C.H. Lavatory and Sons",
	"Globo Gym American Corp",
	"The New Firm"
];

var _customers = [];
for (var c = 10000; c < 10100; c++) {
	_customers.push({
		$uuid: "" + (c - 10000), // to match array index
		bpcnum: "" + c,
		name: _names[c - 10000],

		ordersValue: 1000000 + ((c - 10000) * 200000 % 500000),
		ordersMax: 1800000,
		quotesValue: 500000 + ((c - 10000) * 2000 % 50000),
		quotesMax: 1200000,
		invoicesValue: 10000 + ((c - 10000) * 2000 % 50000),
		invoicesMax: 120000,
		min: 1000,
		addr1: "Rue Fructidor",
		addr2: "75834 Paris Cedex 17"
	});
}

exports.entity = {
	$entityName: "$localCustomer",
	$value: "{name}",
	$properties: {
		bpcnum: {
			$type: "application/x-string",
			$title: "Customer"
		},
		name: {
			$type: "application/x-string",
			$title: "Name",
		},
		addr1: {
			$type: "application/x-string",
			$title: "Street",
		},
		addr2: {
			$type: "application/x-string",
			$title: "Address",
		},
		ordersValue: {
			$type: "application/x-decimal",
			$title: "Orders value"
		},
		min: {
			$type: "application/x-decimal",
			$title: "General min value"
		},
		quotesValue: {
			$type: "application/x-decimal",
			$title: "Quotes value"
		},
		invoicesValue: {
			$type: "application/x-decimal",
			$title: "Invoices value"
		},
		ordersMax: {
			$type: "application/x-decimal",
			$title: "Max"
		},
		quotesMax: {
			$type: "application/x-decimal",
			$title: "Max"
		},
		invoicesMax: {
			$type: "application/x-decimal",
			$title: "Max"
		}
	},
	$prototype: function(proto) {
		// Add some chart information in $query prototype
		var res = utils.getPropByPath(proto, "$properties.$resources.$item.$links") || {};
		// Link to use when user click on row detail link
		res["DASHBOARD"] = {
			$title: "Detail dashboard",
			$url: "{$baseUrl}/$mobileDashboards?dashboard=$localCustomerDashboard&parameters=bpcnum%3D%7Bbpcnum%7D"
		};
	},
	$articles: {
		$query: {
			"$layoutType": "stack",
			"$items": [{
				"$bind": "$resources",
				"$detailsLink": "DASHBOARD",
				"$display": "card",
				"$cardsPerLine": 4,
				"$article": {
					"$items": [{
						"$bind": "bpcnum"
					}, {
						"$bind": "name"
					}, {
						"$bind": "addr1"
					}, {
						"$bind": "addr2"
					}]
				}
			}]
		}
	},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve(_customers[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _customers
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/_entities/entCustomerRevenues',['require','exports','module'],function (require, exports, module) {

var _months = [
	"January",
	"February",
	"March",
	"April",
	"May",
	"June",
	"July",
	"August",
	"September",
	"October",
	"November",
	"December"
];

var _revs = [];
var _uuid = 0;
for (var c = 10000; c < 10100; c++) {
	for (var m = 0; m < 12; m++) {
		_revs.push({
			$uuid: "" + _uuid,
			bpcnum: "" + c,
			month: _months[m],
			revenue: 20000 + (m * (12 + (c % 12)) % 40) * 20000
		});

		_uuid++;
	}
}

exports.entity = {
	$entityName: "$localCustomerRevenue",
	$value: "{name}",
	$properties: {
		bpcnum: {
			$type: "application/x-string",
			$title: "ID"
		},
		month: {
			$type: "application/x-string",
			$title: "Month"
		},
		revenue: {
			$type: "application/x-decimal",
			$title: "Revenue"
		}
	},
	$prototype: function(proto) {
		// Add some chart information in $query prototype
		var res = proto.$properties && proto.$properties.$resources;
		if (res) {
			res.$axes = [{
				$title: "Month",
				$hierarchies: [
					["month"]
				]
			}, {
				$hierarchies: [
					["$measures"]
				]
			}];
			res.$cube = {
				$title: "Revenue",
				$hierarchies: {
					month: {
						$properties: ["month"]
					}
				},
				$measures: {
					revenue: {}
				}
			};
		}
	},
	$articles: {},
	$services: {
		$new: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$read: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve(_revs[op.$key]);
			return deferred.promise();
		},
		$query: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve({
				$resources: _revs
			});
			return deferred.promise();
		},
		$save: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		},
		$delete: function(op, data) {
			var deferred = $.Deferred();
			deferred.resolve();
			return deferred.promise();
		}
	}
};
});

define('syracuse-tablet/html/js/demos/_entities/main',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/_entities/entTodos','syracuse-tablet/html/js/demos/_entities/entOverviewSales','syracuse-tablet/html/js/demos/_entities/entOverviewSalesLeads','syracuse-tablet/html/js/demos/_entities/entCustomers','syracuse-tablet/html/js/demos/_entities/entCustomerRevenues'],function (require, exports, module) {

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var entTodos = require('syracuse-tablet/html/js/demos/_entities/entTodos');
var entOverviewSales = require('syracuse-tablet/html/js/demos/_entities/entOverviewSales');
var entOverviewSalesLeads = require('syracuse-tablet/html/js/demos/_entities/entOverviewSalesLeads');
var entCustomers = require('syracuse-tablet/html/js/demos/_entities/entCustomers');
var entCustomerRevenues = require('syracuse-tablet/html/js/demos/_entities/entCustomerRevenues');

exports.registerAll = function() {
	clientContract.registerEntity(entTodos.entity);
	clientContract.registerEntity(entOverviewSales.entity);
	clientContract.registerEntity(entOverviewSalesLeads.entity);
	clientContract.registerEntity(entCustomers.entity);
	clientContract.registerEntity(entCustomerRevenues.entity);
};
});

define('syracuse-tablet/html/js/demos/salesMyCustomers/main',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/salesMyCustomers/dashCustomers','syracuse-tablet/html/js/demos/utils','syracuse-tablet/html/js/demos/_entities/main'],function (require, exports, module) {

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var dashCustomers = require('syracuse-tablet/html/js/demos/salesMyCustomers/dashCustomers');
var demoUtils = require('syracuse-tablet/html/js/demos/utils');
var entities = require('syracuse-tablet/html/js/demos/_entities/main');


var _demoApp = {
	"$application": {
		"$uuid": "$demoCustomers",
		"applicationName": "sagesalescustomers",
		"title": "Sales - My Customers",
		"description": "",
		"isSageApplication": true,
		"iconName": "sagesalescustomers",
		"$homeDashboard": {
			"$uuid": "$customersDashboard",
			"dashboardName": "$customersDashboard"
		}
	},
	"$dashboards": {},
	"$gadgets": {}
};

exports.register = function() {
	entities.registerAll();
	demoUtils.addToApp(_demoApp, dashCustomers);
	clientContract.registerApp(_demoApp);
};
});

define('syracuse-tablet/html/js/demos/salesMyInquiries/dashSalesInquiries',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"$salesMyInquiriesDashboard": {
		"$dashboardName": "$salesMyInquiriesDashboard",
		"$title": "Sales - My Inquiries Dashboard",
		"$description": "",
		"$vignettes": {
			"$x3PriceInquiries": {
				"$uuid": "$x3PriceInquiries",
				"$displayStyle": "$link"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Price Inquiry",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Sales Price Inquiry",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3PriceInquiries"
					}]
				}]
			}]
		}
	}
};

exports.gadgets = {
	"$x3PriceInquiries": {
		"$type": "$representation",
		"$title": "Price Inquiry",
		"entity": "SPRICESEARCH",
		"endpoint": "x3.erp.GX3APP",
		"action": "$create",
		"representation": "SPRICESEAM",
		"facet": "$create",
		"icon": "sagesalespriceinquiry"
	}
};
});

define('syracuse-tablet/html/js/demos/salesMyInquiries/main',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/salesMyInquiries/dashSalesInquiries','syracuse-tablet/html/js/demos/utils'],function (require, exports, module) {

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var dashSalesInquiries = require('syracuse-tablet/html/js/demos/salesMyInquiries/dashSalesInquiries');
var demoUtils = require('syracuse-tablet/html/js/demos/utils');


var _demoApp = {
	"$application": {
		"$uuid": "$demoSalesMyInquiries",
		"applicationName": "sagesalesinquiries",
		"title": "Sales - My Inquiries",
		"description": "",
		"isSageApplication": true,
		"iconName": "sagesalesinquiries",
		"$homeDashboard": {
			"$uuid": "$salesMyInquiriesDashboard",
			"dashboardName": "$salesMyInquiriesDashboard"
		}
	},
	"$dashboards": {},
	"$gadgets": {}
};

exports.register = function() {
	demoUtils.addToApp(_demoApp, dashSalesInquiries);
	clientContract.registerApp(_demoApp);
};
});

define('syracuse-tablet/html/js/demos/salesMyActions/dashSalesMyActions',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"$salesMyActionsDashboard": {
		"$dashboardName": "$salesMyActionsDashboard",
		"$title": "Sales - My Actions Dashboard",
		"$description": "",
		"$vignettes": {
			"$x3Orders2Sign": {
				"$uuid": "$x3Orders2Sign",
				"$displayStyle": "$full"
			},
			"$x3Quotes2Sign": {
				"$uuid": "$x3Quotes2Sign",
				"$displayStyle": "$full"
			},
			"$x3OpenOrders2Sign": {
				"$uuid": "$x3OpenOrders2Sign",
				"$displayStyle": "$link"
			},
			"$x3QuotesSigned": {
				"$uuid": "$x3QuotesSigned",
				"$displayStyle": "$link"
			},
			"$x3OrdersSigned": {
				"$uuid": "$x3OrdersSigned",
				"$displayStyle": "$link"
			},
			"$x3OpenOrdersSigned": {
				"$uuid": "$x3OpenOrdersSigned",
				"$displayStyle": "$link"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Sales - my actions",
				"$items": [{
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3OpenOrders2Sign"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3QuotesSigned"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3OrdersSigned"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3OpenOrdersSigned"
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Orders to sign",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Orders to sign",
					"$size": "full",
					"$items": [{
						"$bind": "$x3Orders2Sign"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "Quotes to sign",
					"$size": "full",
					"$items": [{
						"$bind": "$x3Quotes2Sign",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "card",
								"$article": {
									"$items": [{
										"$bind": "DEST_REF"
									}, {
										"$bind": "RCLEDEC"
									}, {
										"$bind": "RVALCTX7"
									}, {
										"$bind": "RVALCTX2_REF"
									}]
								}
							}]
						}
					}]
				}]
			}]
		}
	}
};
exports.gadgets = {
	"$x3Orders2Sign": {
		"$type": "$representation",
		"$title": "Orders to sign",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "POHTOSIGM",
		"facet": "$query",
		"icon": "sagesalesorders2sign"
	},
	"$x3Quotes2Sign": {
		"$type": "$representation",
		"$title": "Quotes to sign",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "SQHTOSIGM",
		"facet": "$query",
		"icon": "sagesalesquotes2sign"
	},
	"$x3OpenOrders2Sign": {
		"$type": "$representation",
		"$title": "Open orders to sign",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "SOCTOSIGM",
		"facet": "$query",
		"icon": "sagesalesopenorders2sign"
	},
	"$x3QuotesSigned": {
		"$type": "$representation",
		"$title": "Quotes signed",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "SQHSIGM",
		"facet": "$query",
		"icon": "sagesalesquotessigned"
	},
	"$x3OrdersSigned": {
		"$type": "$representation",
		"$title": "Quotes signed",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "SOHSIGM",
		"facet": "$query",
		"icon": "sagesalesorderssigned"
	},
	"$x3OpenOrdersSigned": {
		"$type": "$representation",
		"$title": "Quotes signed",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "SOCSIGM",
		"facet": "$query",
		"icon": "sagesalesopenorderssigned"
	}
};
});

define('syracuse-tablet/html/js/demos/salesMyActions/main',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/salesMyActions/dashSalesMyActions','syracuse-tablet/html/js/demos/utils'],function (require, exports, module) {

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var dashSalesMyActions = require('syracuse-tablet/html/js/demos/salesMyActions/dashSalesMyActions');
var demoUtils = require('syracuse-tablet/html/js/demos/utils');


var _demoApp = {
	"$application": {
		"$uuid": "$demoSalesMyActions",
		"applicationName": "sagsalesactions",
		"title": "Sales - My Actions",
		"description": "",
		"isSageApplication": true,
		"iconName": "sagesalesactions",
		"$homeDashboard": {
			"$uuid": "$salesMyActionsDashboard",
			"dashboardName": "$salesMyActionsDashboard"
		}
	},
	"$dashboards": {},
	"$gadgets": {}
};

exports.register = function() {
	demoUtils.addToApp(_demoApp, dashSalesMyActions);
	clientContract.registerApp(_demoApp);
};
});

define('syracuse-tablet/html/js/demos/purchaseMyActions/dashPurchaseMyActions',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"$purchaseMyActionsDashboard": {
		"$dashboardName": "$purchaseMyActionsDashboard",
		"$title": "Purchase My Actions Dashboard",
		"$description": "",
		"$vignettes": {
			"$x3Orders2Sign": {
				"$uuid": "$x3Orders2Sign",
				"$displayStyle": "$full"
			},
			"$x3Purchases2Sign": {
				"$uuid": "$x3Purchases2Sign",
				"$displayStyle": "$full"
			},
			"$x3OpenOrders2Sign": {
				"$uuid": "$x3OpenOrders2Sign",
				"$displayStyle": "$link"
			},
			"$x3PurchasesSigned": {
				"$uuid": "$x3PurchasesSigned",
				"$displayStyle": "$link"
			},
			"$x3OrdersSigned": {
				"$uuid": "$x3OrdersSigned",
				"$displayStyle": "$link"
			},
			"$x3OpenOrdersSigned": {
				"$uuid": "$x3OpenOrdersSigned",
				"$displayStyle": "$link"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Purchases - my actions",
				"$items": [{
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3OpenOrders2Sign"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3PurchasesSigned"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3OrdersSigned"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3OpenOrdersSigned"
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Purchase action",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Orders to sign",
					"$size": "full",
					"$items": [{
						"$bind": "$x3Orders2Sign"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "Requests to sign",
					"$size": "full",
					"$items": [{
						"$bind": "$x3Purchases2Sign"
					}]
				}]
			}]
		}
	}
};
exports.gadgets = {
	"$x3Orders2Sign": {
		"$type": "$representation",
		"$title": "Orders to sign",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "POHTOSIGM",
		"facet": "$query",
		"icon": "sagesalesorders2sign"
	},
	"$x3Purchases2Sign": {
		"$type": "$representation",
		"$title": "Purchases Requests to sign",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "PSHTOSIGM",
		"facet": "$query",
		"icon": "sagesalesquotes2sign"
	},
	"$x3OpenOrders2Sign": {
		"$type": "$representation",
		"$title": "Open Orders to sign",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "POCTOSIGM",
		"facet": "$query",
		"icon": "sagesalesopenorders2sign"
	},
	"$x3PurchasesSigned": {
		"$type": "$representation",
		"$title": "Purchase Requests signed",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "PSHSIGM",
		"facet": "$query",
		"icon": "sagesalesquotessigned"
	},
	"$x3OrdersSigned": {
		"$type": "$representation",
		"$title": "Orders signed",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "POHSIGM",
		"facet": "$query",
		"icon": "sagesalesorderssigned"
	},
	"$x3OpenOrdersSigned": {
		"$type": "$representation",
		"$title": "Open Orders signed",
		"entity": "TCAWRKHISSUI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "POCSIGM",
		"facet": "$query",
		"icon": "sagesalesopenorderssigned"
	}
};
});

define('syracuse-tablet/html/js/demos/purchaseMyActions/main',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/purchaseMyActions/dashPurchaseMyActions','syracuse-tablet/html/js/demos/utils'],function (require, exports, module) {

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var dashPurchaseMyActions = require('syracuse-tablet/html/js/demos/purchaseMyActions/dashPurchaseMyActions');
var demoUtils = require('syracuse-tablet/html/js/demos/utils');


var _demoApp = {
	"$application": {
		"$uuid": "$demoPurchaseMyActions",
		"applicationName": "sagepurchaseactions",
		"title": "Purchase My Actions",
		"description": "",
		"isSageApplication": true,
		"iconName": "sagepurchaseactions",
		"$homeDashboard": {
			"$uuid": "$purchaseMyActionsDashboard",
			"dashboardName": "$purchaseMyActionsDashboard"
		}
	},
	"$dashboards": {},
	"$gadgets": {}
};

exports.register = function() {
	demoUtils.addToApp(_demoApp, dashPurchaseMyActions);
	clientContract.registerApp(_demoApp);
};
});

define('syracuse-tablet/html/js/demos/purchaseMyInquiries/dashPurchaseMyInquiries',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"$purchaseMyInquiriesDashboard": {
		"$dashboardName": "$purchaseMyInquiriesDashboard",
		"$title": "Purchase My Inquiries Dashboard",
		"$description": "",
		"$vignettes": {
			"$x3PriceInquiry": {
				"$uuid": "$x3PriceInquiry",
				"$displayStyle": "$link"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Purchase My Inquiries",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Price Inquiriy",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3PriceInquiry"
					}]
				}]
			}]
		}
	}
};
exports.gadgets = {
	"$x3PriceInquiry": {
		"$type": "$representation",
		"$title": "Price inquiry",
		"entity": "PPRICESEARCH",
		"endpoint": "x3.erp.GX3APP",
		"action": "$create",
		"representation": "PPRICSEARCHM",
		"facet": "$create",
		"icon": "sagepurchasepriceinquiry"
	}
};
});

define('syracuse-tablet/html/js/demos/purchaseMyInquiries/main',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/purchaseMyInquiries/dashPurchaseMyInquiries','syracuse-tablet/html/js/demos/utils'],function (require, exports, module) {

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var dashPurchaseMyInquiries = require('syracuse-tablet/html/js/demos/purchaseMyInquiries/dashPurchaseMyInquiries');
var demoUtils = require('syracuse-tablet/html/js/demos/utils');


var _demoApp = {
	"$application": {
		"$uuid": "$demoPurchaseMyInquiries",
		"applicationName": "sagepurchaseinquiries",
		"title": "Purchase - My Inquiries",
		"description": "",
		"isSageApplication": true,
		"iconName": "sagepurchaseinquiries",
		"$homeDashboard": {
			"$uuid": "$purchaseMyInquiriesDashboard",
			"dashboardName": "$purchaseMyInquiriesDashboard"
		}
	},
	"$dashboards": {},
	"$gadgets": {}
};

exports.register = function() {
	demoUtils.addToApp(_demoApp, dashPurchaseMyInquiries);
	clientContract.registerApp(_demoApp);
};
});

define('syracuse-tablet/html/js/demos/myExpenses/dashExpenses',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"$expensesDashboard": {
		"$dashboardName": "$expensesDashboard",
		"$title": "Expenses Dashboard",
		"$description": "",
		"$vignettes": {
			"$x3expensesList": {
				"$uuid": "$x3expensesList",
				"$displayStyle": "$full"
			},
			"$x3expensesNotApproved": {
				"$uuid": "$x3expensesNotApproved",
				"$displayStyle": "$full"
			},
			"$x3expensesCreate": {
				"$uuid": "$x3expensesCreate",
				"$displayStyle": "$link"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Expenses",
				"$items": [{
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3expensesCreate"
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Expenses List",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Expenses list",
					"$size": "full",
					"$items": [{
						"$bind": "$x3expensesList",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "card",
								"$article": {
									"$items": [{
										"$bind": "CLB_REF"
									}, {
										"$bind": "DATEXS"
									}, {
										"$bind": "CODEXP_REF"
									}, {
										"$bind": "AMTPAY"
									}, {
										"$bind": "CUR_REF"
									}]
								}
							}]
						}
					}]
				}]
			}, {
				"$layoutType": "hubGroup",
				"$title": "Expenses Not Approved",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Expenses Not Approved",
					"$size": "all",
					"$items": [{
						"$bind": "$x3expensesNotApproved",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "table",
								"$article": {
									"$items": [{
										"$bind": "CLB_REF"
									}, {
										"$bind": "DATEXS"
									}, {
										"$bind": "CODEXP_REF"
									}, {
										"$bind": "AMTPAY"
									}, {
										"$bind": "CUR_REF"
									}]
								}
							}]
						}
					}]
				}]
			}]
		}
	}
};
exports.gadgets = {
	"$x3expensesList": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "EXPENSES",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "EXPENCNSM",
		"facet": "$query",
		"icon": "sageexpensesall"
	},
	"$x3expensesNotApproved": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "EXPENSES",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "EXPENENTM",
		"facet": "$query",
		"icon": "sageexpensesnotapproved"
	},
	"$x3expensesCreate": {
		"$type": "$representation",
		"$title": "Create expense",
		"entity": "EXPENSES",
		"endpoint": "x3.erp.GX3APP",
		"action": "$create",
		"representation": "EXPENENTM",
		"facet": "$create",
		"icon": "sageexpensescreate"
	}
};
});

define('syracuse-tablet/html/js/demos/myExpenses/main',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/myExpenses/dashExpenses','syracuse-tablet/html/js/demos/utils'],function (require, exports, module) {

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var dashExpenses = require('syracuse-tablet/html/js/demos/myExpenses/dashExpenses');
var demoUtils = require('syracuse-tablet/html/js/demos/utils');


var _demoApp = {
	"$application": {
		"$uuid": "$demoExpenses",
		"applicationName": "sageexpenses",
		"title": "My Expenses",
		"isSageApplication": true,
		"description": "",
		"iconName": "sageexpenses",
		"$homeDashboard": {
			"$uuid": "$expensesDashboard",
			"dashboardName": "$expensesDashboard"
		}
	},
	"$dashboards": {},
	"$gadgets": {}
};

exports.register = function() {
	demoUtils.addToApp(_demoApp, dashExpenses);
	clientContract.registerApp(_demoApp);
};
});

define('syracuse-tablet/html/js/demos/fixedAssets/dashFixedAssets',['require','exports','module'],function (require, exports, module) {
var _queryLinkArticlePA = {
	"$layoutType": "stack",
	"$items": [{
		"$bind": "$resources",
		"$display": "card",
		"$cardsPerRow": 3,
		"$card": {
			"$items": [{
				"$bind": "LCTCOD_REF"
			}, {
				"$bind": "PHYDES1"
			}, {
				"$bind": "PHYREF"
			}, {
				"$bind": "BAC"
			}, {
				"$bind": "PHOTO"
			}]
		}
	}]

};
var _queryLinkArticleLOC = {
	"$layoutType": "stack",
	"$items": [{
		"$bind": "$resources",
		"$display": "card",
		"$queryLinkArticle": _queryLinkArticleLOC,
		"$cardsPerRow": 3,
		"$card": {
			"$layoutType": "stack",
			"$items": [{
				"$bind": "BUICOD_REF"
			}, {
				"$bind": "LCTDES"
			}, {
				"$bind": "LCTCOD"
			}, {
				"$bind": "FLOOR"
			}, {
				"$bind": "BAC"
			}, {
				"$bind": "PHOTO"
			}]
		}
	}]
};

exports.dashboards = {
	"$fixedassetsDashboard": {
		"$dashboardName": "$fixedassetsDashboard",
		"$title": "Fixed Assets Dashboard",
		"$description": "",
		"$vignettes": {
			"$x3fixedassetsList": {
				"$uuid": "$x3fixedassetsList",
				"$displayStyle": "$full"
			},
			"$x3LocationList": {
				"$uuid": "$x3LocationList",
				"$displayStyle": "$full"
			},
			"$x3FixedAssetCreate": {
				"$uuid": "$x3FixedAssetCreate",
				"$displayStyle": "$link"
			},
			"$x3LocationCreate": {
				"$uuid": "$x3LocationCreate",
				"$displayStyle": "$link"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Create",
				"$items": [{
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3FixedAssetCreate"
					}]
				}, {
					"$layoutType": "tile",
					"$title": "",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3LocationCreate"
					}]

				}]

			}, {
				"$layoutType": "hubGroup",
				"$title": "Queries",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Physical Assets - List",
					"$size": "all",
					"$items": [{
						"$bind": "$x3fixedassetsList",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "card",
								"$queryLinkArticle": _queryLinkArticlePA,
								"$cardsPerRow": 3,
								"$card": {
									"$items": [{
										"$bind": "LCTCOD_REF"
									}, {
										"$bind": "PHYDES1"
									}, {
										"$bind": "PHYREF"
									}, {
										"$bind": "BAC"
									}, {
										"$bind": "PHOTO"
									}]
								}
							}]
						}
					}]
				}, {
					"$layoutType": "tile",
					"$title": "Locations - List",
					"$size": "all",
					"$items": [{
						"$bind": "$x3LocationList",
						"$article": {
							"$layoutType": "stack",
							"$items": [{
								"$bind": "$resources",
								"$display": "card",
								"$queryLinkArticle": _queryLinkArticleLOC,
								"$cardsPerRow": 3,
								"$card": {
									"$layoutType": "stack",
									"$items": [{
										"$bind": "BUICOD_REF"
									}, {
										"$bind": "LCTDES"
									}, {
										"$bind": "LCTCOD"
									}, {
										"$bind": "FLOOR"
									}, {
										"$bind": "BAC"
									}, {
										"$bind": "PHOTO"
									}]
								}
							}]
						}
					}]

				}]
			}]
		}
	}
};
exports.gadgets = {
	"$x3fixedassetsList": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "PHYELT",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "PHYELTM",
		"facet": "$query",
		"icon": "sagefaphysquery"
	},
	"$x3LocationList": {
		"$type": "$representation",
		"$title": "Query facet",
		"entity": "PHYLCT",
		"endpoint": "x3.erp.GX3APP",
		"action": "$query",
		"representation": "PHYLCTM",
		"facet": "$query",
		"icon": "sagefalocquery"
	},
	"$x3FixedAssetCreate": {
		"$type": "$representation",
		"$title": "Create Fixed Asset",
		"entity": "PHYELT",
		"endpoint": "x3.erp.GX3APP",
		"action": "$create",
		"representation": "PHYELTM",
		"facet": "$create",
		"icon": "sagefaphyscreate"
	},
	"$x3LocationCreate": {
		"$type": "$representation",
		"$title": "Create Location",
		"entity": "PHYLCT",
		"endpoint": "x3.erp.GX3APP",
		"action": "$create",
		"representation": "PHYLCTM",
		"facet": "$create",
		"icon": "sagefaloccreate"
	}
};
});

define('syracuse-tablet/html/js/demos/fixedAssets/main',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/fixedAssets/dashFixedAssets','syracuse-tablet/html/js/demos/utils'],function (require, exports, module) {

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var dashFixedAssets = require('syracuse-tablet/html/js/demos/fixedAssets/dashFixedAssets');
var demoUtils = require('syracuse-tablet/html/js/demos/utils');


var _demoApp = {
	"$application": {
		"$uuid": "$demoFixedassets",
		"applicationName": "PHYELT_MOBILE",
		"title": "Fixed Assets",
		"isSageApplication": true,
		"description": "",
		"iconName": "sagefixedassets",
		"$homeDashboard": {
			"$uuid": "$fixedassetsDashboard",
			"dashboardName": "$fixedassetsDashboard"
		}
	},
	"$dashboards": {},
	"$gadgets": {}
};

exports.register = function() {
	demoUtils.addToApp(_demoApp, dashFixedAssets);
	clientContract.registerApp(_demoApp);
};
});

define('syracuse-tablet/html/js/demos/availableStock/dashStock',['require','exports','module'],function (require, exports, module) {

exports.dashboards = {
	"$stockDashboard": {
		"$dashboardName": "$stockDashboard",
		"$title": "Available Stock Dashboard",
		"$description": "",
		"$vignettes": {
			"$x3stockInquiry": {
				"$uuid": "$x3stockInquiry",
				"$displayStyle": "$link"
			}
		},
		"$article": {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "Available Stock",
				"$items": [{
					"$layoutType": "tile",
					"$title": "Available Stock",
					"$size": "medium",
					"$items": [{
						"$bind": "$x3stockInquiry"
					}]
				}]
			}]
		}
	}
};
exports.gadgets = {
	"$x3stockInquiry": {
		"$type": "$representation",
		"$title": "Stock inquiry",
		"entity": "STKCNSSDI",
		"endpoint": "x3.erp.GX3APP",
		"action": "$create",
		"representation": "STKCNSSDIM",
		"facet": "$create",
		"icon": "sagestockinquiry"
	}
};
});

define('syracuse-tablet/html/js/demos/availableStock/main',['require','exports','module','syracuse-tablet/html/js/sdata/entities/clientContract','syracuse-tablet/html/js/demos/availableStock/dashStock','syracuse-tablet/html/js/demos/utils'],function (require, exports, module) {

var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var dashStock = require('syracuse-tablet/html/js/demos/availableStock/dashStock');
var demoUtils = require('syracuse-tablet/html/js/demos/utils');


var _demoApp = {
	"$application": {
		"$uuid": "$demoStock",
		"applicationName": "sageavailablestock",
		"title": "Available Stock",
		"isSageApplication": true,
		"description": "",
		"iconName": "sageavailablestock",
		"$homeDashboard": {
			"$uuid": "$stockDashboard",
			"dashboardName": "$stockDashboard"
		}
	},
	"$dashboards": {},
	"$gadgets": {}
};

exports.register = function() {
	demoUtils.addToApp(_demoApp, dashStock);
	clientContract.registerApp(_demoApp);
};
});

define('syracuse-tablet/html/js/demos/main',['require','exports','module','syracuse-tablet/html/js/demos/salesMyCustomers/main','syracuse-tablet/html/js/demos/salesMyInquiries/main','syracuse-tablet/html/js/demos/salesMyActions/main','syracuse-tablet/html/js/demos/purchaseMyActions/main','syracuse-tablet/html/js/demos/purchaseMyInquiries/main','syracuse-tablet/html/js/demos/myExpenses/main','syracuse-tablet/html/js/demos/fixedAssets/main','syracuse-tablet/html/js/demos/availableStock/main'],function (require, exports, module) {
var _demos = {
	salesMyCustomers: require('syracuse-tablet/html/js/demos/salesMyCustomers/main'),
	salesMyInquiries: require('syracuse-tablet/html/js/demos/salesMyInquiries/main'),
	salesMyActions: require('syracuse-tablet/html/js/demos/salesMyActions/main'),
	purchaseMyActions: require('syracuse-tablet/html/js/demos/purchaseMyActions/main'),
	purchaseMyInquiries: require('syracuse-tablet/html/js/demos/purchaseMyInquiries/main'),
	myExpenses: require('syracuse-tablet/html/js/demos/myExpenses/main'),
	fixedAssets: require('syracuse-tablet/html/js/demos/fixedAssets/main'),
	availableStock: require('syracuse-tablet/html/js/demos/availableStock/main')
};

exports.init = function() {
	for (var p in _demos) {
		try {
			_demos[p].register();
		} catch (e) {
			console.error("!!Error registering demo[" + p + "]", e.stack);
		}
	}
};
});

define('syracuse-tablet/html/js/init/initModules',['require','exports','module','syracuse-tablet/html/js/helpers/utils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/application/appFactory','syracuse-tablet/html/js/application/appFactoryDeps','syracuse-tablet/html/js/controls/ctrlFactoryDeps','syracuse-tablet/html/js/ajax/ajax','syracuse-tablet/html/js/storage/storage','syracuse-tablet/html/js/sdata/sdataCache','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/helpers/siteLayout','syracuse-tablet/html/js/application/metaData','syracuse-tablet/html/js/ui/developmentPage','syracuse-tablet/html/js/helpers/uiSettings','syracuse-tablet/html/js/sdata/entities/test/testApplication','syracuse-tablet/html/js/sdata/entities/welcomeApplication','syracuse-tablet/html/js/demos/main'],function (require, exports, module) {

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var factory = require('syracuse-tablet/html/js/application/appFactory');
var appFactoryDeps = require('syracuse-tablet/html/js/application/appFactoryDeps');
var ctrlFactoryDeps = require('syracuse-tablet/html/js/controls/ctrlFactoryDeps');

var ajax = require('syracuse-tablet/html/js/ajax/ajax');
var storage = require('syracuse-tablet/html/js/storage/storage');
var sdataCache = require('syracuse-tablet/html/js/sdata/sdataCache');

var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var siteLayout = require('syracuse-tablet/html/js/helpers/siteLayout');
var metaData = require('syracuse-tablet/html/js/application/metaData');
var developmentPage = require('syracuse-tablet/html/js/ui/developmentPage');
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');

//fully client side configured application to add tests later
var testApplication = require('syracuse-tablet/html/js/sdata/entities/test/testApplication');
var welcomeApplication = require('syracuse-tablet/html/js/sdata/entities/welcomeApplication');
var demos = require('syracuse-tablet/html/js/demos/main');

exports.init = function() {
	var st;
	var cache;
	var deferred = new $.Deferred();
	uiSettings.init();
	globals.setSiteLayout(siteLayout);
	st = storage.getStorage();
	st.init()
		.then(function() {
			cache = new sdataCache.SDataCache(st);
		})
		.then(function() {
			var devMode = window.location.href.indexOf("/index_debug.html") > -1 || window.location.href.indexOf("/index_joined.html") > -1;
			globals.init(devMode, st, cache, utils);
			globals.setMetaData(metaData);
		})
		.then(function() {
			return appFactoryDeps.init();
		})
		.then(function() {
			return ctrlFactoryDeps.init();
		})
		.then(function() {
			ajax.init({}, locale);
		})
		.then(function() {
			welcomeApplication.register();
			demos.init();
		})
		.then(function() {
			if (globals.isDvlpMode()) {
				testApplication.register();
			}
		})
		.then(function() {
			var app = factory.createApplication($("#s-m-app-id"));
			globals.setTabletApplication(app);
			globals.setModal(modal);
		})
		.then(function() {
			_applyDevelopmentSettings();
		})
		.then(function() {
			uiutils.triggerResizeInternal();
		})
		.then(function() {
			deferred.resolve();
		}).fail(function(e) {
			deferred.reject(e);
		});

	return deferred.promise();
};

function _applyDevelopmentSettings() {
	if (globals.isDvlpMode()) {
		if (developmentPage.wasActive()) {
			developmentPage.show();
		}
	}
}
});

define('syracuse-tablet/html/js/init/initLogin',['require','exports','module','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/application/authentication','syracuse-tablet/html/js/helpers/locale','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/notifications','syracuse-tablet/html/js/sdata/sdataCommonResources','syracuse-tablet/html/js/application/settings','syracuse-tablet/html/js/init/initContext'],function (require, exports, module) {

var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var auth = require('syracuse-tablet/html/js/application/authentication');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var sdataCommonRes = require('syracuse-tablet/html/js/sdata/sdataCommonResources');
var settings = require('syracuse-tablet/html/js/application/settings');

var initContext = require('syracuse-tablet/html/js/init/initContext');

var _gotoLogin = function(reason) {
	globals.getApplication().gotoLogin(reason);
};
/**
 * Set the context according to userProfile
 * Initialize the context and call initContext.init that notifies application that context has changed (display welcome app page)
 */
var _loginHandler = {
	// deferred is used to propagate error to the caller (login page) to display error message in asynchronous process
	// !! only one object that has been notify should resolve/reject the deferred
	notifLogin: function(userProfile, deferred) {
		$.smResolve().
		then(function() {
			var userCtx = {
				"$user": userProfile.user.$value,
				"$role": userProfile.selectedRole.code,
				"$lang": userProfile.selectedLocale.code
			};
			globals.setUserCtx(userCtx);
			globals.setUserProfile(userProfile);
			locale.setUserLocales(userProfile && userProfile.user && userProfile.user.locales);
		})
			.then(function() {
				return initContext.init(false, false);
			})
			.then(function() {
				return settings.setLastUserProfile(userProfile);
			})
			.then(function() {
				// We must resolve/reject the deferred if not null
				if (deferred) deferred.resolve();
			}).fail(function(e) {
				if (deferred) {
					// We must resolve/reject the deferred if not null
					deferred.reject(e);
				} else {
					modal.error("notifLogin failed", e);
				}
			});
	}
};


exports.init = function() {
	notifications.subscribe(_loginHandler, ["sm.login"], 1);

	try {
		uiutils.waitWheelStart();
		return auth.check()
			.then(function(status) {
				if (status.authenticated === true) {
					return sdataCommonRes.getUserProfile();
				} else {
					return null;
				}
			})
			.then(function(profile) {
				uiutils.waitWheelStop();
				if (profile) {
					notifications.publish("sm.login", profile);
				} else {
					_gotoLogin();
				}
				return $.smResolve();
			}).fail(function(e) {
				uiutils.waitWheelStop();
				auth.logout().then(function() {
					_gotoLogin("Please try login again");
				}).fail(function(e) {
					modal.error("exports.init failed", e);
				});
			});
	} catch (e) {
		_gotoLogin("Javascript exception");
		return $.smResolve();
	}
};
});

/*!

 handlebars v2.0.0

Copyright (C) 2011-2014 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license
*/
/* exported Handlebars */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define('syracuse-tablet/html/deps/handlebars-latest',[], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    root.Handlebars = root.Handlebars || factory();
  }
}(this, function () {
// handlebars/safe-string.js
var __module4__ = (function() {
  
  var __exports__;
  // Build out our basic SafeString type
  function SafeString(string) {
    this.string = string;
  }

  SafeString.prototype.toString = function() {
    return "" + this.string;
  };

  __exports__ = SafeString;
  return __exports__;
})();

// handlebars/utils.js
var __module3__ = (function(__dependency1__) {
  
  var __exports__ = {};
  /*jshint -W004 */
  var SafeString = __dependency1__;

  var escape = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "`": "&#x60;"
  };

  var badChars = /[&<>"'`]/g;
  var possible = /[&<>"'`]/;

  function escapeChar(chr) {
    return escape[chr];
  }

  function extend(obj /* , ...source */) {
    for (var i = 1; i < arguments.length; i++) {
      for (var key in arguments[i]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
          obj[key] = arguments[i][key];
        }
      }
    }

    return obj;
  }

  __exports__.extend = extend;var toString = Object.prototype.toString;
  __exports__.toString = toString;
  // Sourced from lodash
  // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
  var isFunction = function(value) {
    return typeof value === 'function';
  };
  // fallback for older versions of Chrome and Safari
  /* istanbul ignore next */
  if (isFunction(/x/)) {
    isFunction = function(value) {
      return typeof value === 'function' && toString.call(value) === '[object Function]';
    };
  }
  var isFunction;
  __exports__.isFunction = isFunction;
  /* istanbul ignore next */
  var isArray = Array.isArray || function(value) {
    return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
  };
  __exports__.isArray = isArray;

  function escapeExpression(string) {
    // don't escape SafeStrings, since they're already safe
    if (string instanceof SafeString) {
      return string.toString();
    } else if (string == null) {
      return "";
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = "" + string;

    if(!possible.test(string)) { return string; }
    return string.replace(badChars, escapeChar);
  }

  __exports__.escapeExpression = escapeExpression;function isEmpty(value) {
    if (!value && value !== 0) {
      return true;
    } else if (isArray(value) && value.length === 0) {
      return true;
    } else {
      return false;
    }
  }

  __exports__.isEmpty = isEmpty;function appendContextPath(contextPath, id) {
    return (contextPath ? contextPath + '.' : '') + id;
  }

  __exports__.appendContextPath = appendContextPath;
  return __exports__;
})(__module4__);

// handlebars/exception.js
var __module5__ = (function() {
  
  var __exports__;

  var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

  function Exception(message, node) {
    var line;
    if (node && node.firstLine) {
      line = node.firstLine;

      message += ' - ' + line + ':' + node.firstColumn;
    }

    var tmp = Error.prototype.constructor.call(this, message);

    // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
    for (var idx = 0; idx < errorProps.length; idx++) {
      this[errorProps[idx]] = tmp[errorProps[idx]];
    }

    if (line) {
      this.lineNumber = line;
      this.column = node.firstColumn;
    }
  }

  Exception.prototype = new Error();

  __exports__ = Exception;
  return __exports__;
})();

// handlebars/base.js
var __module2__ = (function(__dependency1__, __dependency2__) {
  
  var __exports__ = {};
  var Utils = __dependency1__;
  var Exception = __dependency2__;

  var VERSION = "2.0.0";
  __exports__.VERSION = VERSION;var COMPILER_REVISION = 6;
  __exports__.COMPILER_REVISION = COMPILER_REVISION;
  var REVISION_CHANGES = {
    1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
    2: '== 1.0.0-rc.3',
    3: '== 1.0.0-rc.4',
    4: '== 1.x.x',
    5: '== 2.0.0-alpha.x',
    6: '>= 2.0.0-beta.1'
  };
  __exports__.REVISION_CHANGES = REVISION_CHANGES;
  var isArray = Utils.isArray,
      isFunction = Utils.isFunction,
      toString = Utils.toString,
      objectType = '[object Object]';

  function HandlebarsEnvironment(helpers, partials) {
    this.helpers = helpers || {};
    this.partials = partials || {};

    registerDefaultHelpers(this);
  }

  __exports__.HandlebarsEnvironment = HandlebarsEnvironment;HandlebarsEnvironment.prototype = {
    constructor: HandlebarsEnvironment,

    logger: logger,
    log: log,

    registerHelper: function(name, fn) {
      if (toString.call(name) === objectType) {
        if (fn) { throw new Exception('Arg not supported with multiple helpers'); }
        Utils.extend(this.helpers, name);
      } else {
        this.helpers[name] = fn;
      }
    },
    unregisterHelper: function(name) {
      delete this.helpers[name];
    },

    registerPartial: function(name, partial) {
      if (toString.call(name) === objectType) {
        Utils.extend(this.partials,  name);
      } else {
        this.partials[name] = partial;
      }
    },
    unregisterPartial: function(name) {
      delete this.partials[name];
    }
  };

  function registerDefaultHelpers(instance) {
    instance.registerHelper('helperMissing', function(/* [args, ]options */) {
      if(arguments.length === 1) {
        // A missing field in a {{foo}} constuct.
        return undefined;
      } else {
        // Someone is actually trying to call something, blow up.
        throw new Exception("Missing helper: '" + arguments[arguments.length-1].name + "'");
      }
    });

    instance.registerHelper('blockHelperMissing', function(context, options) {
      var inverse = options.inverse,
          fn = options.fn;

      if(context === true) {
        return fn(this);
      } else if(context === false || context == null) {
        return inverse(this);
      } else if (isArray(context)) {
        if(context.length > 0) {
          if (options.ids) {
            options.ids = [options.name];
          }

          return instance.helpers.each(context, options);
        } else {
          return inverse(this);
        }
      } else {
        if (options.data && options.ids) {
          var data = createFrame(options.data);
          data.contextPath = Utils.appendContextPath(options.data.contextPath, options.name);
          options = {data: data};
        }

        return fn(context, options);
      }
    });

    instance.registerHelper('each', function(context, options) {
      if (!options) {
        throw new Exception('Must pass iterator to #each');
      }

      var fn = options.fn, inverse = options.inverse;
      var i = 0, ret = "", data;

      var contextPath;
      if (options.data && options.ids) {
        contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
      }

      if (isFunction(context)) { context = context.call(this); }

      if (options.data) {
        data = createFrame(options.data);
      }

      if(context && typeof context === 'object') {
        if (isArray(context)) {
          for(var j = context.length; i<j; i++) {
            if (data) {
              data.index = i;
              data.first = (i === 0);
              data.last  = (i === (context.length-1));

              if (contextPath) {
                data.contextPath = contextPath + i;
              }
            }
            ret = ret + fn(context[i], { data: data });
          }
        } else {
          for(var key in context) {
            if(context.hasOwnProperty(key)) {
              if(data) {
                data.key = key;
                data.index = i;
                data.first = (i === 0);

                if (contextPath) {
                  data.contextPath = contextPath + key;
                }
              }
              ret = ret + fn(context[key], {data: data});
              i++;
            }
          }
        }
      }

      if(i === 0){
        ret = inverse(this);
      }

      return ret;
    });

    instance.registerHelper('if', function(conditional, options) {
      if (isFunction(conditional)) { conditional = conditional.call(this); }

      // Default behavior is to render the positive path if the value is truthy and not empty.
      // The `includeZero` option may be set to treat the condtional as purely not empty based on the
      // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
      if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
        return options.inverse(this);
      } else {
        return options.fn(this);
      }
    });

    instance.registerHelper('unless', function(conditional, options) {
      return instance.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn, hash: options.hash});
    });

    instance.registerHelper('with', function(context, options) {
      if (isFunction(context)) { context = context.call(this); }

      var fn = options.fn;

      if (!Utils.isEmpty(context)) {
        if (options.data && options.ids) {
          var data = createFrame(options.data);
          data.contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]);
          options = {data:data};
        }

        return fn(context, options);
      } else {
        return options.inverse(this);
      }
    });

    instance.registerHelper('log', function(message, options) {
      var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
      instance.log(level, message);
    });

    instance.registerHelper('lookup', function(obj, field) {
      return obj && obj[field];
    });
  }

  var logger = {
    methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

    // State enum
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3,
    level: 3,

    // can be overridden in the host environment
    log: function(level, message) {
      if (logger.level <= level) {
        var method = logger.methodMap[level];
        if (typeof console !== 'undefined' && console[method]) {
          console[method].call(console, message);
        }
      }
    }
  };
  __exports__.logger = logger;
  var log = logger.log;
  __exports__.log = log;
  var createFrame = function(object) {
    var frame = Utils.extend({}, object);
    frame._parent = object;
    return frame;
  };
  __exports__.createFrame = createFrame;
  return __exports__;
})(__module3__, __module5__);

// handlebars/runtime.js
var __module6__ = (function(__dependency1__, __dependency2__, __dependency3__) {
  
  var __exports__ = {};
  var Utils = __dependency1__;
  var Exception = __dependency2__;
  var COMPILER_REVISION = __dependency3__.COMPILER_REVISION;
  var REVISION_CHANGES = __dependency3__.REVISION_CHANGES;
  var createFrame = __dependency3__.createFrame;

  function checkRevision(compilerInfo) {
    var compilerRevision = compilerInfo && compilerInfo[0] || 1,
        currentRevision = COMPILER_REVISION;

    if (compilerRevision !== currentRevision) {
      if (compilerRevision < currentRevision) {
        var runtimeVersions = REVISION_CHANGES[currentRevision],
            compilerVersions = REVISION_CHANGES[compilerRevision];
        throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. "+
              "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").");
      } else {
        // Use the embedded version info since the runtime doesn't know about this revision yet
        throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. "+
              "Please update your runtime to a newer version ("+compilerInfo[1]+").");
      }
    }
  }

  __exports__.checkRevision = checkRevision;// TODO: Remove this line and break up compilePartial

  function template(templateSpec, env) {
    /* istanbul ignore next */
    if (!env) {
      throw new Exception("No environment passed to template");
    }
    if (!templateSpec || !templateSpec.main) {
      throw new Exception('Unknown template object: ' + typeof templateSpec);
    }

    // Note: Using env.VM references rather than local var references throughout this section to allow
    // for external users to override these as psuedo-supported APIs.
    env.VM.checkRevision(templateSpec.compiler);

    var invokePartialWrapper = function(partial, indent, name, context, hash, helpers, partials, data, depths) {
      if (hash) {
        context = Utils.extend({}, context, hash);
      }

      var result = env.VM.invokePartial.call(this, partial, name, context, helpers, partials, data, depths);

      if (result == null && env.compile) {
        var options = { helpers: helpers, partials: partials, data: data, depths: depths };
        partials[name] = env.compile(partial, { data: data !== undefined, compat: templateSpec.compat }, env);
        result = partials[name](context, options);
      }
      if (result != null) {
        if (indent) {
          var lines = result.split('\n');
          for (var i = 0, l = lines.length; i < l; i++) {
            if (!lines[i] && i + 1 === l) {
              break;
            }

            lines[i] = indent + lines[i];
          }
          result = lines.join('\n');
        }
        return result;
      } else {
        throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
      }
    };

    // Just add water
    var container = {
      lookup: function(depths, name) {
        var len = depths.length;
        for (var i = 0; i < len; i++) {
          if (depths[i] && depths[i][name] != null) {
            return depths[i][name];
          }
        }
      },
      lambda: function(current, context) {
        return typeof current === 'function' ? current.call(context) : current;
      },

      escapeExpression: Utils.escapeExpression,
      invokePartial: invokePartialWrapper,

      fn: function(i) {
        return templateSpec[i];
      },

      programs: [],
      program: function(i, data, depths) {
        var programWrapper = this.programs[i],
            fn = this.fn(i);
        if (data || depths) {
          programWrapper = program(this, i, fn, data, depths);
        } else if (!programWrapper) {
          programWrapper = this.programs[i] = program(this, i, fn);
        }
        return programWrapper;
      },

      data: function(data, depth) {
        while (data && depth--) {
          data = data._parent;
        }
        return data;
      },
      merge: function(param, common) {
        var ret = param || common;

        if (param && common && (param !== common)) {
          ret = Utils.extend({}, common, param);
        }

        return ret;
      },

      noop: env.VM.noop,
      compilerInfo: templateSpec.compiler
    };

    var ret = function(context, options) {
      options = options || {};
      var data = options.data;

      ret._setup(options);
      if (!options.partial && templateSpec.useData) {
        data = initData(context, data);
      }
      var depths;
      if (templateSpec.useDepths) {
        depths = options.depths ? [context].concat(options.depths) : [context];
      }

      return templateSpec.main.call(container, context, container.helpers, container.partials, data, depths);
    };
    ret.isTop = true;

    ret._setup = function(options) {
      if (!options.partial) {
        container.helpers = container.merge(options.helpers, env.helpers);

        if (templateSpec.usePartial) {
          container.partials = container.merge(options.partials, env.partials);
        }
      } else {
        container.helpers = options.helpers;
        container.partials = options.partials;
      }
    };

    ret._child = function(i, data, depths) {
      if (templateSpec.useDepths && !depths) {
        throw new Exception('must pass parent depths');
      }

      return program(container, i, templateSpec[i], data, depths);
    };
    return ret;
  }

  __exports__.template = template;function program(container, i, fn, data, depths) {
    var prog = function(context, options) {
      options = options || {};

      return fn.call(container, context, container.helpers, container.partials, options.data || data, depths && [context].concat(depths));
    };
    prog.program = i;
    prog.depth = depths ? depths.length : 0;
    return prog;
  }

  __exports__.program = program;function invokePartial(partial, name, context, helpers, partials, data, depths) {
    var options = { partial: true, helpers: helpers, partials: partials, data: data, depths: depths };

    if(partial === undefined) {
      throw new Exception("The partial " + name + " could not be found");
    } else if(partial instanceof Function) {
      return partial(context, options);
    }
  }

  __exports__.invokePartial = invokePartial;function noop() { return ""; }

  __exports__.noop = noop;function initData(context, data) {
    if (!data || !('root' in data)) {
      data = data ? createFrame(data) : {};
      data.root = context;
    }
    return data;
  }
  return __exports__;
})(__module3__, __module5__, __module2__);

// handlebars.runtime.js
var __module1__ = (function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__) {
  
  var __exports__;
  /*globals Handlebars: true */
  var base = __dependency1__;

  // Each of these augment the Handlebars object. No need to setup here.
  // (This is done to easily share code between commonjs and browse envs)
  var SafeString = __dependency2__;
  var Exception = __dependency3__;
  var Utils = __dependency4__;
  var runtime = __dependency5__;

  // For compatibility and usage outside of module systems, make the Handlebars object a namespace
  var create = function() {
    var hb = new base.HandlebarsEnvironment();

    Utils.extend(hb, base);
    hb.SafeString = SafeString;
    hb.Exception = Exception;
    hb.Utils = Utils;
    hb.escapeExpression = Utils.escapeExpression;

    hb.VM = runtime;
    hb.template = function(spec) {
      return runtime.template(spec, hb);
    };

    return hb;
  };

  var Handlebars = create();
  Handlebars.create = create;

  Handlebars['default'] = Handlebars;

  __exports__ = Handlebars;
  return __exports__;
})(__module2__, __module4__, __module5__, __module3__, __module6__);

// handlebars/compiler/ast.js
var __module7__ = (function(__dependency1__) {
  
  var __exports__;
  var Exception = __dependency1__;

  function LocationInfo(locInfo) {
    locInfo = locInfo || {};
    this.firstLine   = locInfo.first_line;
    this.firstColumn = locInfo.first_column;
    this.lastColumn  = locInfo.last_column;
    this.lastLine    = locInfo.last_line;
  }

  var AST = {
    ProgramNode: function(statements, strip, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "program";
      this.statements = statements;
      this.strip = strip;
    },

    MustacheNode: function(rawParams, hash, open, strip, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "mustache";
      this.strip = strip;

      // Open may be a string parsed from the parser or a passed boolean flag
      if (open != null && open.charAt) {
        // Must use charAt to support IE pre-10
        var escapeFlag = open.charAt(3) || open.charAt(2);
        this.escaped = escapeFlag !== '{' && escapeFlag !== '&';
      } else {
        this.escaped = !!open;
      }

      if (rawParams instanceof AST.SexprNode) {
        this.sexpr = rawParams;
      } else {
        // Support old AST API
        this.sexpr = new AST.SexprNode(rawParams, hash);
      }

      // Support old AST API that stored this info in MustacheNode
      this.id = this.sexpr.id;
      this.params = this.sexpr.params;
      this.hash = this.sexpr.hash;
      this.eligibleHelper = this.sexpr.eligibleHelper;
      this.isHelper = this.sexpr.isHelper;
    },

    SexprNode: function(rawParams, hash, locInfo) {
      LocationInfo.call(this, locInfo);

      this.type = "sexpr";
      this.hash = hash;

      var id = this.id = rawParams[0];
      var params = this.params = rawParams.slice(1);

      // a mustache is definitely a helper if:
      // * it is an eligible helper, and
      // * it has at least one parameter or hash segment
      this.isHelper = !!(params.length || hash);

      // a mustache is an eligible helper if:
      // * its id is simple (a single part, not `this` or `..`)
      this.eligibleHelper = this.isHelper || id.isSimple;

      // if a mustache is an eligible helper but not a definite
      // helper, it is ambiguous, and will be resolved in a later
      // pass or at runtime.
    },

    PartialNode: function(partialName, context, hash, strip, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type         = "partial";
      this.partialName  = partialName;
      this.context      = context;
      this.hash = hash;
      this.strip = strip;

      this.strip.inlineStandalone = true;
    },

    BlockNode: function(mustache, program, inverse, strip, locInfo) {
      LocationInfo.call(this, locInfo);

      this.type = 'block';
      this.mustache = mustache;
      this.program  = program;
      this.inverse  = inverse;
      this.strip = strip;

      if (inverse && !program) {
        this.isInverse = true;
      }
    },

    RawBlockNode: function(mustache, content, close, locInfo) {
      LocationInfo.call(this, locInfo);

      if (mustache.sexpr.id.original !== close) {
        throw new Exception(mustache.sexpr.id.original + " doesn't match " + close, this);
      }

      content = new AST.ContentNode(content, locInfo);

      this.type = 'block';
      this.mustache = mustache;
      this.program = new AST.ProgramNode([content], {}, locInfo);
    },

    ContentNode: function(string, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "content";
      this.original = this.string = string;
    },

    HashNode: function(pairs, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "hash";
      this.pairs = pairs;
    },

    IdNode: function(parts, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "ID";

      var original = "",
          dig = [],
          depth = 0,
          depthString = '';

      for(var i=0,l=parts.length; i<l; i++) {
        var part = parts[i].part;
        original += (parts[i].separator || '') + part;

        if (part === ".." || part === "." || part === "this") {
          if (dig.length > 0) {
            throw new Exception("Invalid path: " + original, this);
          } else if (part === "..") {
            depth++;
            depthString += '../';
          } else {
            this.isScoped = true;
          }
        } else {
          dig.push(part);
        }
      }

      this.original = original;
      this.parts    = dig;
      this.string   = dig.join('.');
      this.depth    = depth;
      this.idName   = depthString + this.string;

      // an ID is simple if it only has one part, and that part is not
      // `..` or `this`.
      this.isSimple = parts.length === 1 && !this.isScoped && depth === 0;

      this.stringModeValue = this.string;
    },

    PartialNameNode: function(name, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "PARTIAL_NAME";
      this.name = name.original;
    },

    DataNode: function(id, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "DATA";
      this.id = id;
      this.stringModeValue = id.stringModeValue;
      this.idName = '@' + id.stringModeValue;
    },

    StringNode: function(string, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "STRING";
      this.original =
        this.string =
        this.stringModeValue = string;
    },

    NumberNode: function(number, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "NUMBER";
      this.original =
        this.number = number;
      this.stringModeValue = Number(number);
    },

    BooleanNode: function(bool, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "BOOLEAN";
      this.bool = bool;
      this.stringModeValue = bool === "true";
    },

    CommentNode: function(comment, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "comment";
      this.comment = comment;

      this.strip = {
        inlineStandalone: true
      };
    }
  };


  // Must be exported as an object rather than the root of the module as the jison lexer
  // most modify the object to operate properly.
  __exports__ = AST;
  return __exports__;
})(__module5__);

// handlebars/compiler/parser.js
var __module9__ = (function() {
  
  var __exports__;
  /* jshint ignore:start */
  /* istanbul ignore next */
  /* Jison generated parser */
  var handlebars = (function(){
  var parser = {trace: function trace() { },
  yy: {},
  symbols_: {"error":2,"root":3,"program":4,"EOF":5,"program_repetition0":6,"statement":7,"mustache":8,"block":9,"rawBlock":10,"partial":11,"CONTENT":12,"COMMENT":13,"openRawBlock":14,"END_RAW_BLOCK":15,"OPEN_RAW_BLOCK":16,"sexpr":17,"CLOSE_RAW_BLOCK":18,"openBlock":19,"block_option0":20,"closeBlock":21,"openInverse":22,"block_option1":23,"OPEN_BLOCK":24,"CLOSE":25,"OPEN_INVERSE":26,"inverseAndProgram":27,"INVERSE":28,"OPEN_ENDBLOCK":29,"path":30,"OPEN":31,"OPEN_UNESCAPED":32,"CLOSE_UNESCAPED":33,"OPEN_PARTIAL":34,"partialName":35,"param":36,"partial_option0":37,"partial_option1":38,"sexpr_repetition0":39,"sexpr_option0":40,"dataName":41,"STRING":42,"NUMBER":43,"BOOLEAN":44,"OPEN_SEXPR":45,"CLOSE_SEXPR":46,"hash":47,"hash_repetition_plus0":48,"hashSegment":49,"ID":50,"EQUALS":51,"DATA":52,"pathSegments":53,"SEP":54,"$accept":0,"$end":1},
  terminals_: {2:"error",5:"EOF",12:"CONTENT",13:"COMMENT",15:"END_RAW_BLOCK",16:"OPEN_RAW_BLOCK",18:"CLOSE_RAW_BLOCK",24:"OPEN_BLOCK",25:"CLOSE",26:"OPEN_INVERSE",28:"INVERSE",29:"OPEN_ENDBLOCK",31:"OPEN",32:"OPEN_UNESCAPED",33:"CLOSE_UNESCAPED",34:"OPEN_PARTIAL",42:"STRING",43:"NUMBER",44:"BOOLEAN",45:"OPEN_SEXPR",46:"CLOSE_SEXPR",50:"ID",51:"EQUALS",52:"DATA",54:"SEP"},
  productions_: [0,[3,2],[4,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[10,3],[14,3],[9,4],[9,4],[19,3],[22,3],[27,2],[21,3],[8,3],[8,3],[11,5],[11,4],[17,3],[17,1],[36,1],[36,1],[36,1],[36,1],[36,1],[36,3],[47,1],[49,3],[35,1],[35,1],[35,1],[41,2],[30,1],[53,3],[53,1],[6,0],[6,2],[20,0],[20,1],[23,0],[23,1],[37,0],[37,1],[38,0],[38,1],[39,0],[39,2],[40,0],[40,1],[48,1],[48,2]],
  performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {

  var $0 = $$.length - 1;
  switch (yystate) {
  case 1: yy.prepareProgram($$[$0-1].statements, true); return $$[$0-1]; 
  break;
  case 2:this.$ = new yy.ProgramNode(yy.prepareProgram($$[$0]), {}, this._$);
  break;
  case 3:this.$ = $$[$0];
  break;
  case 4:this.$ = $$[$0];
  break;
  case 5:this.$ = $$[$0];
  break;
  case 6:this.$ = $$[$0];
  break;
  case 7:this.$ = new yy.ContentNode($$[$0], this._$);
  break;
  case 8:this.$ = new yy.CommentNode($$[$0], this._$);
  break;
  case 9:this.$ = new yy.RawBlockNode($$[$0-2], $$[$0-1], $$[$0], this._$);
  break;
  case 10:this.$ = new yy.MustacheNode($$[$0-1], null, '', '', this._$);
  break;
  case 11:this.$ = yy.prepareBlock($$[$0-3], $$[$0-2], $$[$0-1], $$[$0], false, this._$);
  break;
  case 12:this.$ = yy.prepareBlock($$[$0-3], $$[$0-2], $$[$0-1], $$[$0], true, this._$);
  break;
  case 13:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], yy.stripFlags($$[$0-2], $$[$0]), this._$);
  break;
  case 14:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], yy.stripFlags($$[$0-2], $$[$0]), this._$);
  break;
  case 15:this.$ = { strip: yy.stripFlags($$[$0-1], $$[$0-1]), program: $$[$0] };
  break;
  case 16:this.$ = {path: $$[$0-1], strip: yy.stripFlags($$[$0-2], $$[$0])};
  break;
  case 17:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], yy.stripFlags($$[$0-2], $$[$0]), this._$);
  break;
  case 18:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], yy.stripFlags($$[$0-2], $$[$0]), this._$);
  break;
  case 19:this.$ = new yy.PartialNode($$[$0-3], $$[$0-2], $$[$0-1], yy.stripFlags($$[$0-4], $$[$0]), this._$);
  break;
  case 20:this.$ = new yy.PartialNode($$[$0-2], undefined, $$[$0-1], yy.stripFlags($$[$0-3], $$[$0]), this._$);
  break;
  case 21:this.$ = new yy.SexprNode([$$[$0-2]].concat($$[$0-1]), $$[$0], this._$);
  break;
  case 22:this.$ = new yy.SexprNode([$$[$0]], null, this._$);
  break;
  case 23:this.$ = $$[$0];
  break;
  case 24:this.$ = new yy.StringNode($$[$0], this._$);
  break;
  case 25:this.$ = new yy.NumberNode($$[$0], this._$);
  break;
  case 26:this.$ = new yy.BooleanNode($$[$0], this._$);
  break;
  case 27:this.$ = $$[$0];
  break;
  case 28:$$[$0-1].isHelper = true; this.$ = $$[$0-1];
  break;
  case 29:this.$ = new yy.HashNode($$[$0], this._$);
  break;
  case 30:this.$ = [$$[$0-2], $$[$0]];
  break;
  case 31:this.$ = new yy.PartialNameNode($$[$0], this._$);
  break;
  case 32:this.$ = new yy.PartialNameNode(new yy.StringNode($$[$0], this._$), this._$);
  break;
  case 33:this.$ = new yy.PartialNameNode(new yy.NumberNode($$[$0], this._$));
  break;
  case 34:this.$ = new yy.DataNode($$[$0], this._$);
  break;
  case 35:this.$ = new yy.IdNode($$[$0], this._$);
  break;
  case 36: $$[$0-2].push({part: $$[$0], separator: $$[$0-1]}); this.$ = $$[$0-2]; 
  break;
  case 37:this.$ = [{part: $$[$0]}];
  break;
  case 38:this.$ = [];
  break;
  case 39:$$[$0-1].push($$[$0]);
  break;
  case 48:this.$ = [];
  break;
  case 49:$$[$0-1].push($$[$0]);
  break;
  case 52:this.$ = [$$[$0]];
  break;
  case 53:$$[$0-1].push($$[$0]);
  break;
  }
  },
  table: [{3:1,4:2,5:[2,38],6:3,12:[2,38],13:[2,38],16:[2,38],24:[2,38],26:[2,38],31:[2,38],32:[2,38],34:[2,38]},{1:[3]},{5:[1,4]},{5:[2,2],7:5,8:6,9:7,10:8,11:9,12:[1,10],13:[1,11],14:16,16:[1,20],19:14,22:15,24:[1,18],26:[1,19],28:[2,2],29:[2,2],31:[1,12],32:[1,13],34:[1,17]},{1:[2,1]},{5:[2,39],12:[2,39],13:[2,39],16:[2,39],24:[2,39],26:[2,39],28:[2,39],29:[2,39],31:[2,39],32:[2,39],34:[2,39]},{5:[2,3],12:[2,3],13:[2,3],16:[2,3],24:[2,3],26:[2,3],28:[2,3],29:[2,3],31:[2,3],32:[2,3],34:[2,3]},{5:[2,4],12:[2,4],13:[2,4],16:[2,4],24:[2,4],26:[2,4],28:[2,4],29:[2,4],31:[2,4],32:[2,4],34:[2,4]},{5:[2,5],12:[2,5],13:[2,5],16:[2,5],24:[2,5],26:[2,5],28:[2,5],29:[2,5],31:[2,5],32:[2,5],34:[2,5]},{5:[2,6],12:[2,6],13:[2,6],16:[2,6],24:[2,6],26:[2,6],28:[2,6],29:[2,6],31:[2,6],32:[2,6],34:[2,6]},{5:[2,7],12:[2,7],13:[2,7],16:[2,7],24:[2,7],26:[2,7],28:[2,7],29:[2,7],31:[2,7],32:[2,7],34:[2,7]},{5:[2,8],12:[2,8],13:[2,8],16:[2,8],24:[2,8],26:[2,8],28:[2,8],29:[2,8],31:[2,8],32:[2,8],34:[2,8]},{17:21,30:22,41:23,50:[1,26],52:[1,25],53:24},{17:27,30:22,41:23,50:[1,26],52:[1,25],53:24},{4:28,6:3,12:[2,38],13:[2,38],16:[2,38],24:[2,38],26:[2,38],28:[2,38],29:[2,38],31:[2,38],32:[2,38],34:[2,38]},{4:29,6:3,12:[2,38],13:[2,38],16:[2,38],24:[2,38],26:[2,38],28:[2,38],29:[2,38],31:[2,38],32:[2,38],34:[2,38]},{12:[1,30]},{30:32,35:31,42:[1,33],43:[1,34],50:[1,26],53:24},{17:35,30:22,41:23,50:[1,26],52:[1,25],53:24},{17:36,30:22,41:23,50:[1,26],52:[1,25],53:24},{17:37,30:22,41:23,50:[1,26],52:[1,25],53:24},{25:[1,38]},{18:[2,48],25:[2,48],33:[2,48],39:39,42:[2,48],43:[2,48],44:[2,48],45:[2,48],46:[2,48],50:[2,48],52:[2,48]},{18:[2,22],25:[2,22],33:[2,22],46:[2,22]},{18:[2,35],25:[2,35],33:[2,35],42:[2,35],43:[2,35],44:[2,35],45:[2,35],46:[2,35],50:[2,35],52:[2,35],54:[1,40]},{30:41,50:[1,26],53:24},{18:[2,37],25:[2,37],33:[2,37],42:[2,37],43:[2,37],44:[2,37],45:[2,37],46:[2,37],50:[2,37],52:[2,37],54:[2,37]},{33:[1,42]},{20:43,27:44,28:[1,45],29:[2,40]},{23:46,27:47,28:[1,45],29:[2,42]},{15:[1,48]},{25:[2,46],30:51,36:49,38:50,41:55,42:[1,52],43:[1,53],44:[1,54],45:[1,56],47:57,48:58,49:60,50:[1,59],52:[1,25],53:24},{25:[2,31],42:[2,31],43:[2,31],44:[2,31],45:[2,31],50:[2,31],52:[2,31]},{25:[2,32],42:[2,32],43:[2,32],44:[2,32],45:[2,32],50:[2,32],52:[2,32]},{25:[2,33],42:[2,33],43:[2,33],44:[2,33],45:[2,33],50:[2,33],52:[2,33]},{25:[1,61]},{25:[1,62]},{18:[1,63]},{5:[2,17],12:[2,17],13:[2,17],16:[2,17],24:[2,17],26:[2,17],28:[2,17],29:[2,17],31:[2,17],32:[2,17],34:[2,17]},{18:[2,50],25:[2,50],30:51,33:[2,50],36:65,40:64,41:55,42:[1,52],43:[1,53],44:[1,54],45:[1,56],46:[2,50],47:66,48:58,49:60,50:[1,59],52:[1,25],53:24},{50:[1,67]},{18:[2,34],25:[2,34],33:[2,34],42:[2,34],43:[2,34],44:[2,34],45:[2,34],46:[2,34],50:[2,34],52:[2,34]},{5:[2,18],12:[2,18],13:[2,18],16:[2,18],24:[2,18],26:[2,18],28:[2,18],29:[2,18],31:[2,18],32:[2,18],34:[2,18]},{21:68,29:[1,69]},{29:[2,41]},{4:70,6:3,12:[2,38],13:[2,38],16:[2,38],24:[2,38],26:[2,38],29:[2,38],31:[2,38],32:[2,38],34:[2,38]},{21:71,29:[1,69]},{29:[2,43]},{5:[2,9],12:[2,9],13:[2,9],16:[2,9],24:[2,9],26:[2,9],28:[2,9],29:[2,9],31:[2,9],32:[2,9],34:[2,9]},{25:[2,44],37:72,47:73,48:58,49:60,50:[1,74]},{25:[1,75]},{18:[2,23],25:[2,23],33:[2,23],42:[2,23],43:[2,23],44:[2,23],45:[2,23],46:[2,23],50:[2,23],52:[2,23]},{18:[2,24],25:[2,24],33:[2,24],42:[2,24],43:[2,24],44:[2,24],45:[2,24],46:[2,24],50:[2,24],52:[2,24]},{18:[2,25],25:[2,25],33:[2,25],42:[2,25],43:[2,25],44:[2,25],45:[2,25],46:[2,25],50:[2,25],52:[2,25]},{18:[2,26],25:[2,26],33:[2,26],42:[2,26],43:[2,26],44:[2,26],45:[2,26],46:[2,26],50:[2,26],52:[2,26]},{18:[2,27],25:[2,27],33:[2,27],42:[2,27],43:[2,27],44:[2,27],45:[2,27],46:[2,27],50:[2,27],52:[2,27]},{17:76,30:22,41:23,50:[1,26],52:[1,25],53:24},{25:[2,47]},{18:[2,29],25:[2,29],33:[2,29],46:[2,29],49:77,50:[1,74]},{18:[2,37],25:[2,37],33:[2,37],42:[2,37],43:[2,37],44:[2,37],45:[2,37],46:[2,37],50:[2,37],51:[1,78],52:[2,37],54:[2,37]},{18:[2,52],25:[2,52],33:[2,52],46:[2,52],50:[2,52]},{12:[2,13],13:[2,13],16:[2,13],24:[2,13],26:[2,13],28:[2,13],29:[2,13],31:[2,13],32:[2,13],34:[2,13]},{12:[2,14],13:[2,14],16:[2,14],24:[2,14],26:[2,14],28:[2,14],29:[2,14],31:[2,14],32:[2,14],34:[2,14]},{12:[2,10]},{18:[2,21],25:[2,21],33:[2,21],46:[2,21]},{18:[2,49],25:[2,49],33:[2,49],42:[2,49],43:[2,49],44:[2,49],45:[2,49],46:[2,49],50:[2,49],52:[2,49]},{18:[2,51],25:[2,51],33:[2,51],46:[2,51]},{18:[2,36],25:[2,36],33:[2,36],42:[2,36],43:[2,36],44:[2,36],45:[2,36],46:[2,36],50:[2,36],52:[2,36],54:[2,36]},{5:[2,11],12:[2,11],13:[2,11],16:[2,11],24:[2,11],26:[2,11],28:[2,11],29:[2,11],31:[2,11],32:[2,11],34:[2,11]},{30:79,50:[1,26],53:24},{29:[2,15]},{5:[2,12],12:[2,12],13:[2,12],16:[2,12],24:[2,12],26:[2,12],28:[2,12],29:[2,12],31:[2,12],32:[2,12],34:[2,12]},{25:[1,80]},{25:[2,45]},{51:[1,78]},{5:[2,20],12:[2,20],13:[2,20],16:[2,20],24:[2,20],26:[2,20],28:[2,20],29:[2,20],31:[2,20],32:[2,20],34:[2,20]},{46:[1,81]},{18:[2,53],25:[2,53],33:[2,53],46:[2,53],50:[2,53]},{30:51,36:82,41:55,42:[1,52],43:[1,53],44:[1,54],45:[1,56],50:[1,26],52:[1,25],53:24},{25:[1,83]},{5:[2,19],12:[2,19],13:[2,19],16:[2,19],24:[2,19],26:[2,19],28:[2,19],29:[2,19],31:[2,19],32:[2,19],34:[2,19]},{18:[2,28],25:[2,28],33:[2,28],42:[2,28],43:[2,28],44:[2,28],45:[2,28],46:[2,28],50:[2,28],52:[2,28]},{18:[2,30],25:[2,30],33:[2,30],46:[2,30],50:[2,30]},{5:[2,16],12:[2,16],13:[2,16],16:[2,16],24:[2,16],26:[2,16],28:[2,16],29:[2,16],31:[2,16],32:[2,16],34:[2,16]}],
  defaultActions: {4:[2,1],44:[2,41],47:[2,43],57:[2,47],63:[2,10],70:[2,15],73:[2,45]},
  parseError: function parseError(str, hash) {
      throw new Error(str);
  },
  parse: function parse(input) {
      var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
      this.lexer.setInput(input);
      this.lexer.yy = this.yy;
      this.yy.lexer = this.lexer;
      this.yy.parser = this;
      if (typeof this.lexer.yylloc == "undefined")
          this.lexer.yylloc = {};
      var yyloc = this.lexer.yylloc;
      lstack.push(yyloc);
      var ranges = this.lexer.options && this.lexer.options.ranges;
      if (typeof this.yy.parseError === "function")
          this.parseError = this.yy.parseError;
      function popStack(n) {
          stack.length = stack.length - 2 * n;
          vstack.length = vstack.length - n;
          lstack.length = lstack.length - n;
      }
      function lex() {
          var token;
          token = self.lexer.lex() || 1;
          if (typeof token !== "number") {
              token = self.symbols_[token] || token;
          }
          return token;
      }
      var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
      while (true) {
          state = stack[stack.length - 1];
          if (this.defaultActions[state]) {
              action = this.defaultActions[state];
          } else {
              if (symbol === null || typeof symbol == "undefined") {
                  symbol = lex();
              }
              action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
              var errStr = "";
              if (!recovering) {
                  expected = [];
                  for (p in table[state])
                      if (this.terminals_[p] && p > 2) {
                          expected.push("'" + this.terminals_[p] + "'");
                      }
                  if (this.lexer.showPosition) {
                      errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                  } else {
                      errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1?"end of input":"'" + (this.terminals_[symbol] || symbol) + "'");
                  }
                  this.parseError(errStr, {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});
              }
          }
          if (action[0] instanceof Array && action.length > 1) {
              throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
          case 1:
              stack.push(symbol);
              vstack.push(this.lexer.yytext);
              lstack.push(this.lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              if (!preErrorSymbol) {
                  yyleng = this.lexer.yyleng;
                  yytext = this.lexer.yytext;
                  yylineno = this.lexer.yylineno;
                  yyloc = this.lexer.yylloc;
                  if (recovering > 0)
                      recovering--;
              } else {
                  symbol = preErrorSymbol;
                  preErrorSymbol = null;
              }
              break;
          case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column};
              if (ranges) {
                  yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
              }
              r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
              if (typeof r !== "undefined") {
                  return r;
              }
              if (len) {
                  stack = stack.slice(0, -1 * len * 2);
                  vstack = vstack.slice(0, -1 * len);
                  lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;
          case 3:
              return true;
          }
      }
      return true;
  }
  };
  /* Jison generated lexer */
  var lexer = (function(){
  var lexer = ({EOF:1,
  parseError:function parseError(str, hash) {
          if (this.yy.parser) {
              this.yy.parser.parseError(str, hash);
          } else {
              throw new Error(str);
          }
      },
  setInput:function (input) {
          this._input = input;
          this._more = this._less = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};
          if (this.options.ranges) this.yylloc.range = [0,0];
          this.offset = 0;
          return this;
      },
  input:function () {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
              this.yylineno++;
              this.yylloc.last_line++;
          } else {
              this.yylloc.last_column++;
          }
          if (this.options.ranges) this.yylloc.range[1]++;

          this._input = this._input.slice(1);
          return ch;
      },
  unput:function (ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);

          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length-len-1);
          //this.yyleng -= len;
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length-1);
          this.matched = this.matched.substr(0, this.matched.length-1);

          if (lines.length-1) this.yylineno -= lines.length-1;
          var r = this.yylloc.range;

          this.yylloc = {first_line: this.yylloc.first_line,
            last_line: this.yylineno+1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length:
                this.yylloc.first_column - len
            };

          if (this.options.ranges) {
              this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          return this;
      },
  more:function () {
          this._more = true;
          return this;
      },
  less:function (n) {
          this.unput(this.match.slice(n));
      },
  pastInput:function () {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
      },
  upcomingInput:function () {
          var next = this.match;
          if (next.length < 20) {
              next += this._input.substr(0, 20-next.length);
          }
          return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\n/g, "");
      },
  showPosition:function () {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c+"^";
      },
  next:function () {
          if (this.done) {
              return this.EOF;
          }
          if (!this._input) this.done = true;

          var token,
              match,
              tempMatch,
              index,
              col,
              lines;
          if (!this._more) {
              this.yytext = '';
              this.match = '';
          }
          var rules = this._currentRules();
          for (var i=0;i < rules.length; i++) {
              tempMatch = this._input.match(this.rules[rules[i]]);
              if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                  match = tempMatch;
                  index = i;
                  if (!this.options.flex) break;
              }
          }
          if (match) {
              lines = match[0].match(/(?:\r\n?|\n).*/g);
              if (lines) this.yylineno += lines.length;
              this.yylloc = {first_line: this.yylloc.last_line,
                             last_line: this.yylineno+1,
                             first_column: this.yylloc.last_column,
                             last_column: lines ? lines[lines.length-1].length-lines[lines.length-1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length};
              this.yytext += match[0];
              this.match += match[0];
              this.matches = match;
              this.yyleng = this.yytext.length;
              if (this.options.ranges) {
                  this.yylloc.range = [this.offset, this.offset += this.yyleng];
              }
              this._more = false;
              this._input = this._input.slice(match[0].length);
              this.matched += match[0];
              token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);
              if (this.done && this._input) this.done = false;
              if (token) return token;
              else return;
          }
          if (this._input === "") {
              return this.EOF;
          } else {
              return this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\n'+this.showPosition(),
                      {text: "", token: null, line: this.yylineno});
          }
      },
  lex:function lex() {
          var r = this.next();
          if (typeof r !== 'undefined') {
              return r;
          } else {
              return this.lex();
          }
      },
  begin:function begin(condition) {
          this.conditionStack.push(condition);
      },
  popState:function popState() {
          return this.conditionStack.pop();
      },
  _currentRules:function _currentRules() {
          return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;
      },
  topState:function () {
          return this.conditionStack[this.conditionStack.length-2];
      },
  pushState:function begin(condition) {
          this.begin(condition);
      }});
  lexer.options = {};
  lexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {


  function strip(start, end) {
    return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng-end);
  }


  var YYSTATE=YY_START
  switch($avoiding_name_collisions) {
  case 0:
                                     if(yy_.yytext.slice(-2) === "\\\\") {
                                       strip(0,1);
                                       this.begin("mu");
                                     } else if(yy_.yytext.slice(-1) === "\\") {
                                       strip(0,1);
                                       this.begin("emu");
                                     } else {
                                       this.begin("mu");
                                     }
                                     if(yy_.yytext) return 12;
                                   
  break;
  case 1:return 12;
  break;
  case 2:
                                     this.popState();
                                     return 12;
                                   
  break;
  case 3:
                                    yy_.yytext = yy_.yytext.substr(5, yy_.yyleng-9);
                                    this.popState();
                                    return 15;
                                   
  break;
  case 4: return 12; 
  break;
  case 5:strip(0,4); this.popState(); return 13;
  break;
  case 6:return 45;
  break;
  case 7:return 46;
  break;
  case 8: return 16; 
  break;
  case 9:
                                    this.popState();
                                    this.begin('raw');
                                    return 18;
                                   
  break;
  case 10:return 34;
  break;
  case 11:return 24;
  break;
  case 12:return 29;
  break;
  case 13:this.popState(); return 28;
  break;
  case 14:this.popState(); return 28;
  break;
  case 15:return 26;
  break;
  case 16:return 26;
  break;
  case 17:return 32;
  break;
  case 18:return 31;
  break;
  case 19:this.popState(); this.begin('com');
  break;
  case 20:strip(3,5); this.popState(); return 13;
  break;
  case 21:return 31;
  break;
  case 22:return 51;
  break;
  case 23:return 50;
  break;
  case 24:return 50;
  break;
  case 25:return 54;
  break;
  case 26:// ignore whitespace
  break;
  case 27:this.popState(); return 33;
  break;
  case 28:this.popState(); return 25;
  break;
  case 29:yy_.yytext = strip(1,2).replace(/\\"/g,'"'); return 42;
  break;
  case 30:yy_.yytext = strip(1,2).replace(/\\'/g,"'"); return 42;
  break;
  case 31:return 52;
  break;
  case 32:return 44;
  break;
  case 33:return 44;
  break;
  case 34:return 43;
  break;
  case 35:return 50;
  break;
  case 36:yy_.yytext = strip(1,2); return 50;
  break;
  case 37:return 'INVALID';
  break;
  case 38:return 5;
  break;
  }
  };
  lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/,/^(?:[^\x00]+)/,/^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/,/^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/,/^(?:[^\x00]*?(?=(\{\{\{\{\/)))/,/^(?:[\s\S]*?--\}\})/,/^(?:\()/,/^(?:\))/,/^(?:\{\{\{\{)/,/^(?:\}\}\}\})/,/^(?:\{\{(~)?>)/,/^(?:\{\{(~)?#)/,/^(?:\{\{(~)?\/)/,/^(?:\{\{(~)?\^\s*(~)?\}\})/,/^(?:\{\{(~)?\s*else\s*(~)?\}\})/,/^(?:\{\{(~)?\^)/,/^(?:\{\{(~)?\s*else\b)/,/^(?:\{\{(~)?\{)/,/^(?:\{\{(~)?&)/,/^(?:\{\{!--)/,/^(?:\{\{![\s\S]*?\}\})/,/^(?:\{\{(~)?)/,/^(?:=)/,/^(?:\.\.)/,/^(?:\.(?=([=~}\s\/.)])))/,/^(?:[\/.])/,/^(?:\s+)/,/^(?:\}(~)?\}\})/,/^(?:(~)?\}\})/,/^(?:"(\\["]|[^"])*")/,/^(?:'(\\[']|[^'])*')/,/^(?:@)/,/^(?:true(?=([~}\s)])))/,/^(?:false(?=([~}\s)])))/,/^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/,/^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)]))))/,/^(?:\[[^\]]*\])/,/^(?:.)/,/^(?:$)/];
  lexer.conditions = {"mu":{"rules":[6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38],"inclusive":false},"emu":{"rules":[2],"inclusive":false},"com":{"rules":[5],"inclusive":false},"raw":{"rules":[3,4],"inclusive":false},"INITIAL":{"rules":[0,1,38],"inclusive":true}};
  return lexer;})()
  parser.lexer = lexer;
  function Parser () { this.yy = {}; }Parser.prototype = parser;parser.Parser = Parser;
  return new Parser;
  })();__exports__ = handlebars;
  /* jshint ignore:end */
  return __exports__;
})();

// handlebars/compiler/helpers.js
var __module10__ = (function(__dependency1__) {
  
  var __exports__ = {};
  var Exception = __dependency1__;

  function stripFlags(open, close) {
    return {
      left: open.charAt(2) === '~',
      right: close.charAt(close.length-3) === '~'
    };
  }

  __exports__.stripFlags = stripFlags;
  function prepareBlock(mustache, program, inverseAndProgram, close, inverted, locInfo) {
    /*jshint -W040 */
    if (mustache.sexpr.id.original !== close.path.original) {
      throw new Exception(mustache.sexpr.id.original + ' doesn\'t match ' + close.path.original, mustache);
    }

    var inverse = inverseAndProgram && inverseAndProgram.program;

    var strip = {
      left: mustache.strip.left,
      right: close.strip.right,

      // Determine the standalone candiacy. Basically flag our content as being possibly standalone
      // so our parent can determine if we actually are standalone
      openStandalone: isNextWhitespace(program.statements),
      closeStandalone: isPrevWhitespace((inverse || program).statements)
    };

    if (mustache.strip.right) {
      omitRight(program.statements, null, true);
    }

    if (inverse) {
      var inverseStrip = inverseAndProgram.strip;

      if (inverseStrip.left) {
        omitLeft(program.statements, null, true);
      }
      if (inverseStrip.right) {
        omitRight(inverse.statements, null, true);
      }
      if (close.strip.left) {
        omitLeft(inverse.statements, null, true);
      }

      // Find standalone else statments
      if (isPrevWhitespace(program.statements)
          && isNextWhitespace(inverse.statements)) {

        omitLeft(program.statements);
        omitRight(inverse.statements);
      }
    } else {
      if (close.strip.left) {
        omitLeft(program.statements, null, true);
      }
    }

    if (inverted) {
      return new this.BlockNode(mustache, inverse, program, strip, locInfo);
    } else {
      return new this.BlockNode(mustache, program, inverse, strip, locInfo);
    }
  }

  __exports__.prepareBlock = prepareBlock;
  function prepareProgram(statements, isRoot) {
    for (var i = 0, l = statements.length; i < l; i++) {
      var current = statements[i],
          strip = current.strip;

      if (!strip) {
        continue;
      }

      var _isPrevWhitespace = isPrevWhitespace(statements, i, isRoot, current.type === 'partial'),
          _isNextWhitespace = isNextWhitespace(statements, i, isRoot),

          openStandalone = strip.openStandalone && _isPrevWhitespace,
          closeStandalone = strip.closeStandalone && _isNextWhitespace,
          inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

      if (strip.right) {
        omitRight(statements, i, true);
      }
      if (strip.left) {
        omitLeft(statements, i, true);
      }

      if (inlineStandalone) {
        omitRight(statements, i);

        if (omitLeft(statements, i)) {
          // If we are on a standalone node, save the indent info for partials
          if (current.type === 'partial') {
            current.indent = (/([ \t]+$)/).exec(statements[i-1].original) ? RegExp.$1 : '';
          }
        }
      }
      if (openStandalone) {
        omitRight((current.program || current.inverse).statements);

        // Strip out the previous content node if it's whitespace only
        omitLeft(statements, i);
      }
      if (closeStandalone) {
        // Always strip the next node
        omitRight(statements, i);

        omitLeft((current.inverse || current.program).statements);
      }
    }

    return statements;
  }

  __exports__.prepareProgram = prepareProgram;function isPrevWhitespace(statements, i, isRoot) {
    if (i === undefined) {
      i = statements.length;
    }

    // Nodes that end with newlines are considered whitespace (but are special
    // cased for strip operations)
    var prev = statements[i-1],
        sibling = statements[i-2];
    if (!prev) {
      return isRoot;
    }

    if (prev.type === 'content') {
      return (sibling || !isRoot ? (/\r?\n\s*?$/) : (/(^|\r?\n)\s*?$/)).test(prev.original);
    }
  }
  function isNextWhitespace(statements, i, isRoot) {
    if (i === undefined) {
      i = -1;
    }

    var next = statements[i+1],
        sibling = statements[i+2];
    if (!next) {
      return isRoot;
    }

    if (next.type === 'content') {
      return (sibling || !isRoot ? (/^\s*?\r?\n/) : (/^\s*?(\r?\n|$)/)).test(next.original);
    }
  }

  // Marks the node to the right of the position as omitted.
  // I.e. {{foo}}' ' will mark the ' ' node as omitted.
  //
  // If i is undefined, then the first child will be marked as such.
  //
  // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
  // content is met.
  function omitRight(statements, i, multiple) {
    var current = statements[i == null ? 0 : i + 1];
    if (!current || current.type !== 'content' || (!multiple && current.rightStripped)) {
      return;
    }

    var original = current.string;
    current.string = current.string.replace(multiple ? (/^\s+/) : (/^[ \t]*\r?\n?/), '');
    current.rightStripped = current.string !== original;
  }

  // Marks the node to the left of the position as omitted.
  // I.e. ' '{{foo}} will mark the ' ' node as omitted.
  //
  // If i is undefined then the last child will be marked as such.
  //
  // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
  // content is met.
  function omitLeft(statements, i, multiple) {
    var current = statements[i == null ? statements.length - 1 : i - 1];
    if (!current || current.type !== 'content' || (!multiple && current.leftStripped)) {
      return;
    }

    // We omit the last node if it's whitespace only and not preceeded by a non-content node.
    var original = current.string;
    current.string = current.string.replace(multiple ? (/\s+$/) : (/[ \t]+$/), '');
    current.leftStripped = current.string !== original;
    return current.leftStripped;
  }
  return __exports__;
})(__module5__);

// handlebars/compiler/base.js
var __module8__ = (function(__dependency1__, __dependency2__, __dependency3__, __dependency4__) {
  
  var __exports__ = {};
  var parser = __dependency1__;
  var AST = __dependency2__;
  var Helpers = __dependency3__;
  var extend = __dependency4__.extend;

  __exports__.parser = parser;

  var yy = {};
  extend(yy, Helpers, AST);

  function parse(input) {
    // Just return if an already-compile AST was passed in.
    if (input.constructor === AST.ProgramNode) { return input; }

    parser.yy = yy;

    return parser.parse(input);
  }

  __exports__.parse = parse;
  return __exports__;
})(__module9__, __module7__, __module10__, __module3__);

// handlebars/compiler/compiler.js
var __module11__ = (function(__dependency1__, __dependency2__) {
  
  var __exports__ = {};
  var Exception = __dependency1__;
  var isArray = __dependency2__.isArray;

  var slice = [].slice;

  function Compiler() {}

  __exports__.Compiler = Compiler;// the foundHelper register will disambiguate helper lookup from finding a
  // function in a context. This is necessary for mustache compatibility, which
  // requires that context functions in blocks are evaluated by blockHelperMissing,
  // and then proceed as if the resulting value was provided to blockHelperMissing.

  Compiler.prototype = {
    compiler: Compiler,

    equals: function(other) {
      var len = this.opcodes.length;
      if (other.opcodes.length !== len) {
        return false;
      }

      for (var i = 0; i < len; i++) {
        var opcode = this.opcodes[i],
            otherOpcode = other.opcodes[i];
        if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
          return false;
        }
      }

      // We know that length is the same between the two arrays because they are directly tied
      // to the opcode behavior above.
      len = this.children.length;
      for (i = 0; i < len; i++) {
        if (!this.children[i].equals(other.children[i])) {
          return false;
        }
      }

      return true;
    },

    guid: 0,

    compile: function(program, options) {
      this.opcodes = [];
      this.children = [];
      this.depths = {list: []};
      this.options = options;
      this.stringParams = options.stringParams;
      this.trackIds = options.trackIds;

      // These changes will propagate to the other compiler components
      var knownHelpers = this.options.knownHelpers;
      this.options.knownHelpers = {
        'helperMissing': true,
        'blockHelperMissing': true,
        'each': true,
        'if': true,
        'unless': true,
        'with': true,
        'log': true,
        'lookup': true
      };
      if (knownHelpers) {
        for (var name in knownHelpers) {
          this.options.knownHelpers[name] = knownHelpers[name];
        }
      }

      return this.accept(program);
    },

    accept: function(node) {
      return this[node.type](node);
    },

    program: function(program) {
      var statements = program.statements;

      for(var i=0, l=statements.length; i<l; i++) {
        this.accept(statements[i]);
      }
      this.isSimple = l === 1;

      this.depths.list = this.depths.list.sort(function(a, b) {
        return a - b;
      });

      return this;
    },

    compileProgram: function(program) {
      var result = new this.compiler().compile(program, this.options);
      var guid = this.guid++, depth;

      this.usePartial = this.usePartial || result.usePartial;

      this.children[guid] = result;

      for(var i=0, l=result.depths.list.length; i<l; i++) {
        depth = result.depths.list[i];

        if(depth < 2) { continue; }
        else { this.addDepth(depth - 1); }
      }

      return guid;
    },

    block: function(block) {
      var mustache = block.mustache,
          program = block.program,
          inverse = block.inverse;

      if (program) {
        program = this.compileProgram(program);
      }

      if (inverse) {
        inverse = this.compileProgram(inverse);
      }

      var sexpr = mustache.sexpr;
      var type = this.classifySexpr(sexpr);

      if (type === "helper") {
        this.helperSexpr(sexpr, program, inverse);
      } else if (type === "simple") {
        this.simpleSexpr(sexpr);

        // now that the simple mustache is resolved, we need to
        // evaluate it by executing `blockHelperMissing`
        this.opcode('pushProgram', program);
        this.opcode('pushProgram', inverse);
        this.opcode('emptyHash');
        this.opcode('blockValue', sexpr.id.original);
      } else {
        this.ambiguousSexpr(sexpr, program, inverse);

        // now that the simple mustache is resolved, we need to
        // evaluate it by executing `blockHelperMissing`
        this.opcode('pushProgram', program);
        this.opcode('pushProgram', inverse);
        this.opcode('emptyHash');
        this.opcode('ambiguousBlockValue');
      }

      this.opcode('append');
    },

    hash: function(hash) {
      var pairs = hash.pairs, i, l;

      this.opcode('pushHash');

      for(i=0, l=pairs.length; i<l; i++) {
        this.pushParam(pairs[i][1]);
      }
      while(i--) {
        this.opcode('assignToHash', pairs[i][0]);
      }
      this.opcode('popHash');
    },

    partial: function(partial) {
      var partialName = partial.partialName;
      this.usePartial = true;

      if (partial.hash) {
        this.accept(partial.hash);
      } else {
        this.opcode('push', 'undefined');
      }

      if (partial.context) {
        this.accept(partial.context);
      } else {
        this.opcode('getContext', 0);
        this.opcode('pushContext');
      }

      this.opcode('invokePartial', partialName.name, partial.indent || '');
      this.opcode('append');
    },

    content: function(content) {
      if (content.string) {
        this.opcode('appendContent', content.string);
      }
    },

    mustache: function(mustache) {
      this.sexpr(mustache.sexpr);

      if(mustache.escaped && !this.options.noEscape) {
        this.opcode('appendEscaped');
      } else {
        this.opcode('append');
      }
    },

    ambiguousSexpr: function(sexpr, program, inverse) {
      var id = sexpr.id,
          name = id.parts[0],
          isBlock = program != null || inverse != null;

      this.opcode('getContext', id.depth);

      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);

      this.ID(id);

      this.opcode('invokeAmbiguous', name, isBlock);
    },

    simpleSexpr: function(sexpr) {
      var id = sexpr.id;

      if (id.type === 'DATA') {
        this.DATA(id);
      } else if (id.parts.length) {
        this.ID(id);
      } else {
        // Simplified ID for `this`
        this.addDepth(id.depth);
        this.opcode('getContext', id.depth);
        this.opcode('pushContext');
      }

      this.opcode('resolvePossibleLambda');
    },

    helperSexpr: function(sexpr, program, inverse) {
      var params = this.setupFullMustacheParams(sexpr, program, inverse),
          id = sexpr.id,
          name = id.parts[0];

      if (this.options.knownHelpers[name]) {
        this.opcode('invokeKnownHelper', params.length, name);
      } else if (this.options.knownHelpersOnly) {
        throw new Exception("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
      } else {
        id.falsy = true;

        this.ID(id);
        this.opcode('invokeHelper', params.length, id.original, id.isSimple);
      }
    },

    sexpr: function(sexpr) {
      var type = this.classifySexpr(sexpr);

      if (type === "simple") {
        this.simpleSexpr(sexpr);
      } else if (type === "helper") {
        this.helperSexpr(sexpr);
      } else {
        this.ambiguousSexpr(sexpr);
      }
    },

    ID: function(id) {
      this.addDepth(id.depth);
      this.opcode('getContext', id.depth);

      var name = id.parts[0];
      if (!name) {
        // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
        this.opcode('pushContext');
      } else {
        this.opcode('lookupOnContext', id.parts, id.falsy, id.isScoped);
      }
    },

    DATA: function(data) {
      this.options.data = true;
      this.opcode('lookupData', data.id.depth, data.id.parts);
    },

    STRING: function(string) {
      this.opcode('pushString', string.string);
    },

    NUMBER: function(number) {
      this.opcode('pushLiteral', number.number);
    },

    BOOLEAN: function(bool) {
      this.opcode('pushLiteral', bool.bool);
    },

    comment: function() {},

    // HELPERS
    opcode: function(name) {
      this.opcodes.push({ opcode: name, args: slice.call(arguments, 1) });
    },

    addDepth: function(depth) {
      if(depth === 0) { return; }

      if(!this.depths[depth]) {
        this.depths[depth] = true;
        this.depths.list.push(depth);
      }
    },

    classifySexpr: function(sexpr) {
      var isHelper   = sexpr.isHelper;
      var isEligible = sexpr.eligibleHelper;
      var options    = this.options;

      // if ambiguous, we can possibly resolve the ambiguity now
      // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
      if (isEligible && !isHelper) {
        var name = sexpr.id.parts[0];

        if (options.knownHelpers[name]) {
          isHelper = true;
        } else if (options.knownHelpersOnly) {
          isEligible = false;
        }
      }

      if (isHelper) { return "helper"; }
      else if (isEligible) { return "ambiguous"; }
      else { return "simple"; }
    },

    pushParams: function(params) {
      for(var i=0, l=params.length; i<l; i++) {
        this.pushParam(params[i]);
      }
    },

    pushParam: function(val) {
      if (this.stringParams) {
        if(val.depth) {
          this.addDepth(val.depth);
        }
        this.opcode('getContext', val.depth || 0);
        this.opcode('pushStringParam', val.stringModeValue, val.type);

        if (val.type === 'sexpr') {
          // Subexpressions get evaluated and passed in
          // in string params mode.
          this.sexpr(val);
        }
      } else {
        if (this.trackIds) {
          this.opcode('pushId', val.type, val.idName || val.stringModeValue);
        }
        this.accept(val);
      }
    },

    setupFullMustacheParams: function(sexpr, program, inverse) {
      var params = sexpr.params;
      this.pushParams(params);

      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);

      if (sexpr.hash) {
        this.hash(sexpr.hash);
      } else {
        this.opcode('emptyHash');
      }

      return params;
    }
  };

  function precompile(input, options, env) {
    if (input == null || (typeof input !== 'string' && input.constructor !== env.AST.ProgramNode)) {
      throw new Exception("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
    }

    options = options || {};
    if (!('data' in options)) {
      options.data = true;
    }
    if (options.compat) {
      options.useDepths = true;
    }

    var ast = env.parse(input);
    var environment = new env.Compiler().compile(ast, options);
    return new env.JavaScriptCompiler().compile(environment, options);
  }

  __exports__.precompile = precompile;function compile(input, options, env) {
    if (input == null || (typeof input !== 'string' && input.constructor !== env.AST.ProgramNode)) {
      throw new Exception("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
    }

    options = options || {};

    if (!('data' in options)) {
      options.data = true;
    }
    if (options.compat) {
      options.useDepths = true;
    }

    var compiled;

    function compileInput() {
      var ast = env.parse(input);
      var environment = new env.Compiler().compile(ast, options);
      var templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
      return env.template(templateSpec);
    }

    // Template is only compiled on first use and cached after that point.
    var ret = function(context, options) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled.call(this, context, options);
    };
    ret._setup = function(options) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled._setup(options);
    };
    ret._child = function(i, data, depths) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled._child(i, data, depths);
    };
    return ret;
  }

  __exports__.compile = compile;function argEquals(a, b) {
    if (a === b) {
      return true;
    }

    if (isArray(a) && isArray(b) && a.length === b.length) {
      for (var i = 0; i < a.length; i++) {
        if (!argEquals(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
  }
  return __exports__;
})(__module5__, __module3__);

// handlebars/compiler/javascript-compiler.js
var __module12__ = (function(__dependency1__, __dependency2__) {
  
  var __exports__;
  var COMPILER_REVISION = __dependency1__.COMPILER_REVISION;
  var REVISION_CHANGES = __dependency1__.REVISION_CHANGES;
  var Exception = __dependency2__;

  function Literal(value) {
    this.value = value;
  }

  function JavaScriptCompiler() {}

  JavaScriptCompiler.prototype = {
    // PUBLIC API: You can override these methods in a subclass to provide
    // alternative compiled forms for name lookup and buffering semantics
    nameLookup: function(parent, name /* , type*/) {
      if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
        return parent + "." + name;
      } else {
        return parent + "['" + name + "']";
      }
    },
    depthedLookup: function(name) {
      this.aliases.lookup = 'this.lookup';

      return 'lookup(depths, "' + name + '")';
    },

    compilerInfo: function() {
      var revision = COMPILER_REVISION,
          versions = REVISION_CHANGES[revision];
      return [revision, versions];
    },

    appendToBuffer: function(string) {
      if (this.environment.isSimple) {
        return "return " + string + ";";
      } else {
        return {
          appendToBuffer: true,
          content: string,
          toString: function() { return "buffer += " + string + ";"; }
        };
      }
    },

    initializeBuffer: function() {
      return this.quotedString("");
    },

    namespace: "Handlebars",
    // END PUBLIC API

    compile: function(environment, options, context, asObject) {
      this.environment = environment;
      this.options = options;
      this.stringParams = this.options.stringParams;
      this.trackIds = this.options.trackIds;
      this.precompile = !asObject;

      this.name = this.environment.name;
      this.isChild = !!context;
      this.context = context || {
        programs: [],
        environments: []
      };

      this.preamble();

      this.stackSlot = 0;
      this.stackVars = [];
      this.aliases = {};
      this.registers = { list: [] };
      this.hashes = [];
      this.compileStack = [];
      this.inlineStack = [];

      this.compileChildren(environment, options);

      this.useDepths = this.useDepths || environment.depths.list.length || this.options.compat;

      var opcodes = environment.opcodes,
          opcode,
          i,
          l;

      for (i = 0, l = opcodes.length; i < l; i++) {
        opcode = opcodes[i];

        this[opcode.opcode].apply(this, opcode.args);
      }

      // Flush any trailing content that might be pending.
      this.pushSource('');

      /* istanbul ignore next */
      if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
        throw new Exception('Compile completed with content left on stack');
      }

      var fn = this.createFunctionContext(asObject);
      if (!this.isChild) {
        var ret = {
          compiler: this.compilerInfo(),
          main: fn
        };
        var programs = this.context.programs;
        for (i = 0, l = programs.length; i < l; i++) {
          if (programs[i]) {
            ret[i] = programs[i];
          }
        }

        if (this.environment.usePartial) {
          ret.usePartial = true;
        }
        if (this.options.data) {
          ret.useData = true;
        }
        if (this.useDepths) {
          ret.useDepths = true;
        }
        if (this.options.compat) {
          ret.compat = true;
        }

        if (!asObject) {
          ret.compiler = JSON.stringify(ret.compiler);
          ret = this.objectLiteral(ret);
        }

        return ret;
      } else {
        return fn;
      }
    },

    preamble: function() {
      // track the last context pushed into place to allow skipping the
      // getContext opcode when it would be a noop
      this.lastContext = 0;
      this.source = [];
    },

    createFunctionContext: function(asObject) {
      var varDeclarations = '';

      var locals = this.stackVars.concat(this.registers.list);
      if(locals.length > 0) {
        varDeclarations += ", " + locals.join(", ");
      }

      // Generate minimizer alias mappings
      for (var alias in this.aliases) {
        if (this.aliases.hasOwnProperty(alias)) {
          varDeclarations += ', ' + alias + '=' + this.aliases[alias];
        }
      }

      var params = ["depth0", "helpers", "partials", "data"];

      if (this.useDepths) {
        params.push('depths');
      }

      // Perform a second pass over the output to merge content when possible
      var source = this.mergeSource(varDeclarations);

      if (asObject) {
        params.push(source);

        return Function.apply(this, params);
      } else {
        return 'function(' + params.join(',') + ') {\n  ' + source + '}';
      }
    },
    mergeSource: function(varDeclarations) {
      var source = '',
          buffer,
          appendOnly = !this.forceBuffer,
          appendFirst;

      for (var i = 0, len = this.source.length; i < len; i++) {
        var line = this.source[i];
        if (line.appendToBuffer) {
          if (buffer) {
            buffer = buffer + '\n    + ' + line.content;
          } else {
            buffer = line.content;
          }
        } else {
          if (buffer) {
            if (!source) {
              appendFirst = true;
              source = buffer + ';\n  ';
            } else {
              source += 'buffer += ' + buffer + ';\n  ';
            }
            buffer = undefined;
          }
          source += line + '\n  ';

          if (!this.environment.isSimple) {
            appendOnly = false;
          }
        }
      }

      if (appendOnly) {
        if (buffer || !source) {
          source += 'return ' + (buffer || '""') + ';\n';
        }
      } else {
        varDeclarations += ", buffer = " + (appendFirst ? '' : this.initializeBuffer());
        if (buffer) {
          source += 'return buffer + ' + buffer + ';\n';
        } else {
          source += 'return buffer;\n';
        }
      }

      if (varDeclarations) {
        source = 'var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n  ') + source;
      }

      return source;
    },

    // [blockValue]
    //
    // On stack, before: hash, inverse, program, value
    // On stack, after: return value of blockHelperMissing
    //
    // The purpose of this opcode is to take a block of the form
    // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
    // replace it on the stack with the result of properly
    // invoking blockHelperMissing.
    blockValue: function(name) {
      this.aliases.blockHelperMissing = 'helpers.blockHelperMissing';

      var params = [this.contextName(0)];
      this.setupParams(name, 0, params);

      var blockName = this.popStack();
      params.splice(1, 0, blockName);

      this.push('blockHelperMissing.call(' + params.join(', ') + ')');
    },

    // [ambiguousBlockValue]
    //
    // On stack, before: hash, inverse, program, value
    // Compiler value, before: lastHelper=value of last found helper, if any
    // On stack, after, if no lastHelper: same as [blockValue]
    // On stack, after, if lastHelper: value
    ambiguousBlockValue: function() {
      this.aliases.blockHelperMissing = 'helpers.blockHelperMissing';

      // We're being a bit cheeky and reusing the options value from the prior exec
      var params = [this.contextName(0)];
      this.setupParams('', 0, params, true);

      this.flushInline();

      var current = this.topStack();
      params.splice(1, 0, current);

      this.pushSource("if (!" + this.lastHelper + ") { " + current + " = blockHelperMissing.call(" + params.join(", ") + "); }");
    },

    // [appendContent]
    //
    // On stack, before: ...
    // On stack, after: ...
    //
    // Appends the string value of `content` to the current buffer
    appendContent: function(content) {
      if (this.pendingContent) {
        content = this.pendingContent + content;
      }

      this.pendingContent = content;
    },

    // [append]
    //
    // On stack, before: value, ...
    // On stack, after: ...
    //
    // Coerces `value` to a String and appends it to the current buffer.
    //
    // If `value` is truthy, or 0, it is coerced into a string and appended
    // Otherwise, the empty string is appended
    append: function() {
      // Force anything that is inlined onto the stack so we don't have duplication
      // when we examine local
      this.flushInline();
      var local = this.popStack();
      this.pushSource('if (' + local + ' != null) { ' + this.appendToBuffer(local) + ' }');
      if (this.environment.isSimple) {
        this.pushSource("else { " + this.appendToBuffer("''") + " }");
      }
    },

    // [appendEscaped]
    //
    // On stack, before: value, ...
    // On stack, after: ...
    //
    // Escape `value` and append it to the buffer
    appendEscaped: function() {
      this.aliases.escapeExpression = 'this.escapeExpression';

      this.pushSource(this.appendToBuffer("escapeExpression(" + this.popStack() + ")"));
    },

    // [getContext]
    //
    // On stack, before: ...
    // On stack, after: ...
    // Compiler value, after: lastContext=depth
    //
    // Set the value of the `lastContext` compiler value to the depth
    getContext: function(depth) {
      this.lastContext = depth;
    },

    // [pushContext]
    //
    // On stack, before: ...
    // On stack, after: currentContext, ...
    //
    // Pushes the value of the current context onto the stack.
    pushContext: function() {
      this.pushStackLiteral(this.contextName(this.lastContext));
    },

    // [lookupOnContext]
    //
    // On stack, before: ...
    // On stack, after: currentContext[name], ...
    //
    // Looks up the value of `name` on the current context and pushes
    // it onto the stack.
    lookupOnContext: function(parts, falsy, scoped) {
      /*jshint -W083 */
      var i = 0,
          len = parts.length;

      if (!scoped && this.options.compat && !this.lastContext) {
        // The depthed query is expected to handle the undefined logic for the root level that
        // is implemented below, so we evaluate that directly in compat mode
        this.push(this.depthedLookup(parts[i++]));
      } else {
        this.pushContext();
      }

      for (; i < len; i++) {
        this.replaceStack(function(current) {
          var lookup = this.nameLookup(current, parts[i], 'context');
          // We want to ensure that zero and false are handled properly if the context (falsy flag)
          // needs to have the special handling for these values.
          if (!falsy) {
            return ' != null ? ' + lookup + ' : ' + current;
          } else {
            // Otherwise we can use generic falsy handling
            return ' && ' + lookup;
          }
        });
      }
    },

    // [lookupData]
    //
    // On stack, before: ...
    // On stack, after: data, ...
    //
    // Push the data lookup operator
    lookupData: function(depth, parts) {
      /*jshint -W083 */
      if (!depth) {
        this.pushStackLiteral('data');
      } else {
        this.pushStackLiteral('this.data(data, ' + depth + ')');
      }

      var len = parts.length;
      for (var i = 0; i < len; i++) {
        this.replaceStack(function(current) {
          return ' && ' + this.nameLookup(current, parts[i], 'data');
        });
      }
    },

    // [resolvePossibleLambda]
    //
    // On stack, before: value, ...
    // On stack, after: resolved value, ...
    //
    // If the `value` is a lambda, replace it on the stack by
    // the return value of the lambda
    resolvePossibleLambda: function() {
      this.aliases.lambda = 'this.lambda';

      this.push('lambda(' + this.popStack() + ', ' + this.contextName(0) + ')');
    },

    // [pushStringParam]
    //
    // On stack, before: ...
    // On stack, after: string, currentContext, ...
    //
    // This opcode is designed for use in string mode, which
    // provides the string value of a parameter along with its
    // depth rather than resolving it immediately.
    pushStringParam: function(string, type) {
      this.pushContext();
      this.pushString(type);

      // If it's a subexpression, the string result
      // will be pushed after this opcode.
      if (type !== 'sexpr') {
        if (typeof string === 'string') {
          this.pushString(string);
        } else {
          this.pushStackLiteral(string);
        }
      }
    },

    emptyHash: function() {
      this.pushStackLiteral('{}');

      if (this.trackIds) {
        this.push('{}'); // hashIds
      }
      if (this.stringParams) {
        this.push('{}'); // hashContexts
        this.push('{}'); // hashTypes
      }
    },
    pushHash: function() {
      if (this.hash) {
        this.hashes.push(this.hash);
      }
      this.hash = {values: [], types: [], contexts: [], ids: []};
    },
    popHash: function() {
      var hash = this.hash;
      this.hash = this.hashes.pop();

      if (this.trackIds) {
        this.push('{' + hash.ids.join(',') + '}');
      }
      if (this.stringParams) {
        this.push('{' + hash.contexts.join(',') + '}');
        this.push('{' + hash.types.join(',') + '}');
      }

      this.push('{\n    ' + hash.values.join(',\n    ') + '\n  }');
    },

    // [pushString]
    //
    // On stack, before: ...
    // On stack, after: quotedString(string), ...
    //
    // Push a quoted version of `string` onto the stack
    pushString: function(string) {
      this.pushStackLiteral(this.quotedString(string));
    },

    // [push]
    //
    // On stack, before: ...
    // On stack, after: expr, ...
    //
    // Push an expression onto the stack
    push: function(expr) {
      this.inlineStack.push(expr);
      return expr;
    },

    // [pushLiteral]
    //
    // On stack, before: ...
    // On stack, after: value, ...
    //
    // Pushes a value onto the stack. This operation prevents
    // the compiler from creating a temporary variable to hold
    // it.
    pushLiteral: function(value) {
      this.pushStackLiteral(value);
    },

    // [pushProgram]
    //
    // On stack, before: ...
    // On stack, after: program(guid), ...
    //
    // Push a program expression onto the stack. This takes
    // a compile-time guid and converts it into a runtime-accessible
    // expression.
    pushProgram: function(guid) {
      if (guid != null) {
        this.pushStackLiteral(this.programExpression(guid));
      } else {
        this.pushStackLiteral(null);
      }
    },

    // [invokeHelper]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of helper invocation
    //
    // Pops off the helper's parameters, invokes the helper,
    // and pushes the helper's return value onto the stack.
    //
    // If the helper is not found, `helperMissing` is called.
    invokeHelper: function(paramSize, name, isSimple) {
      this.aliases.helperMissing = 'helpers.helperMissing';

      var nonHelper = this.popStack();
      var helper = this.setupHelper(paramSize, name);

      var lookup = (isSimple ? helper.name + ' || ' : '') + nonHelper + ' || helperMissing';
      this.push('((' + lookup + ').call(' + helper.callParams + '))');
    },

    // [invokeKnownHelper]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of helper invocation
    //
    // This operation is used when the helper is known to exist,
    // so a `helperMissing` fallback is not required.
    invokeKnownHelper: function(paramSize, name) {
      var helper = this.setupHelper(paramSize, name);
      this.push(helper.name + ".call(" + helper.callParams + ")");
    },

    // [invokeAmbiguous]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of disambiguation
    //
    // This operation is used when an expression like `{{foo}}`
    // is provided, but we don't know at compile-time whether it
    // is a helper or a path.
    //
    // This operation emits more code than the other options,
    // and can be avoided by passing the `knownHelpers` and
    // `knownHelpersOnly` flags at compile-time.
    invokeAmbiguous: function(name, helperCall) {
      this.aliases.functionType = '"function"';
      this.aliases.helperMissing = 'helpers.helperMissing';
      this.useRegister('helper');

      var nonHelper = this.popStack();

      this.emptyHash();
      var helper = this.setupHelper(0, name, helperCall);

      var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

      this.push(
        '((helper = (helper = ' + helperName + ' || ' + nonHelper + ') != null ? helper : helperMissing'
          + (helper.paramsInit ? '),(' + helper.paramsInit : '') + '),'
        + '(typeof helper === functionType ? helper.call(' + helper.callParams + ') : helper))');
    },

    // [invokePartial]
    //
    // On stack, before: context, ...
    // On stack after: result of partial invocation
    //
    // This operation pops off a context, invokes a partial with that context,
    // and pushes the result of the invocation back.
    invokePartial: function(name, indent) {
      var params = [this.nameLookup('partials', name, 'partial'), "'" + indent + "'", "'" + name + "'", this.popStack(), this.popStack(), "helpers", "partials"];

      if (this.options.data) {
        params.push("data");
      } else if (this.options.compat) {
        params.push('undefined');
      }
      if (this.options.compat) {
        params.push('depths');
      }

      this.push("this.invokePartial(" + params.join(", ") + ")");
    },

    // [assignToHash]
    //
    // On stack, before: value, ..., hash, ...
    // On stack, after: ..., hash, ...
    //
    // Pops a value off the stack and assigns it to the current hash
    assignToHash: function(key) {
      var value = this.popStack(),
          context,
          type,
          id;

      if (this.trackIds) {
        id = this.popStack();
      }
      if (this.stringParams) {
        type = this.popStack();
        context = this.popStack();
      }

      var hash = this.hash;
      if (context) {
        hash.contexts.push("'" + key + "': " + context);
      }
      if (type) {
        hash.types.push("'" + key + "': " + type);
      }
      if (id) {
        hash.ids.push("'" + key + "': " + id);
      }
      hash.values.push("'" + key + "': (" + value + ")");
    },

    pushId: function(type, name) {
      if (type === 'ID' || type === 'DATA') {
        this.pushString(name);
      } else if (type === 'sexpr') {
        this.pushStackLiteral('true');
      } else {
        this.pushStackLiteral('null');
      }
    },

    // HELPERS

    compiler: JavaScriptCompiler,

    compileChildren: function(environment, options) {
      var children = environment.children, child, compiler;

      for(var i=0, l=children.length; i<l; i++) {
        child = children[i];
        compiler = new this.compiler();

        var index = this.matchExistingProgram(child);

        if (index == null) {
          this.context.programs.push('');     // Placeholder to prevent name conflicts for nested children
          index = this.context.programs.length;
          child.index = index;
          child.name = 'program' + index;
          this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
          this.context.environments[index] = child;

          this.useDepths = this.useDepths || compiler.useDepths;
        } else {
          child.index = index;
          child.name = 'program' + index;
        }
      }
    },
    matchExistingProgram: function(child) {
      for (var i = 0, len = this.context.environments.length; i < len; i++) {
        var environment = this.context.environments[i];
        if (environment && environment.equals(child)) {
          return i;
        }
      }
    },

    programExpression: function(guid) {
      var child = this.environment.children[guid],
          depths = child.depths.list,
          useDepths = this.useDepths,
          depth;

      var programParams = [child.index, 'data'];

      if (useDepths) {
        programParams.push('depths');
      }

      return 'this.program(' + programParams.join(', ') + ')';
    },

    useRegister: function(name) {
      if(!this.registers[name]) {
        this.registers[name] = true;
        this.registers.list.push(name);
      }
    },

    pushStackLiteral: function(item) {
      return this.push(new Literal(item));
    },

    pushSource: function(source) {
      if (this.pendingContent) {
        this.source.push(this.appendToBuffer(this.quotedString(this.pendingContent)));
        this.pendingContent = undefined;
      }

      if (source) {
        this.source.push(source);
      }
    },

    pushStack: function(item) {
      this.flushInline();

      var stack = this.incrStack();
      this.pushSource(stack + " = " + item + ";");
      this.compileStack.push(stack);
      return stack;
    },

    replaceStack: function(callback) {
      var prefix = '',
          inline = this.isInline(),
          stack,
          createdStack,
          usedLiteral;

      /* istanbul ignore next */
      if (!this.isInline()) {
        throw new Exception('replaceStack on non-inline');
      }

      // We want to merge the inline statement into the replacement statement via ','
      var top = this.popStack(true);

      if (top instanceof Literal) {
        // Literals do not need to be inlined
        prefix = stack = top.value;
        usedLiteral = true;
      } else {
        // Get or create the current stack name for use by the inline
        createdStack = !this.stackSlot;
        var name = !createdStack ? this.topStackName() : this.incrStack();

        prefix = '(' + this.push(name) + ' = ' + top + ')';
        stack = this.topStack();
      }

      var item = callback.call(this, stack);

      if (!usedLiteral) {
        this.popStack();
      }
      if (createdStack) {
        this.stackSlot--;
      }
      this.push('(' + prefix + item + ')');
    },

    incrStack: function() {
      this.stackSlot++;
      if(this.stackSlot > this.stackVars.length) { this.stackVars.push("stack" + this.stackSlot); }
      return this.topStackName();
    },
    topStackName: function() {
      return "stack" + this.stackSlot;
    },
    flushInline: function() {
      var inlineStack = this.inlineStack;
      if (inlineStack.length) {
        this.inlineStack = [];
        for (var i = 0, len = inlineStack.length; i < len; i++) {
          var entry = inlineStack[i];
          if (entry instanceof Literal) {
            this.compileStack.push(entry);
          } else {
            this.pushStack(entry);
          }
        }
      }
    },
    isInline: function() {
      return this.inlineStack.length;
    },

    popStack: function(wrapped) {
      var inline = this.isInline(),
          item = (inline ? this.inlineStack : this.compileStack).pop();

      if (!wrapped && (item instanceof Literal)) {
        return item.value;
      } else {
        if (!inline) {
          /* istanbul ignore next */
          if (!this.stackSlot) {
            throw new Exception('Invalid stack pop');
          }
          this.stackSlot--;
        }
        return item;
      }
    },

    topStack: function() {
      var stack = (this.isInline() ? this.inlineStack : this.compileStack),
          item = stack[stack.length - 1];

      if (item instanceof Literal) {
        return item.value;
      } else {
        return item;
      }
    },

    contextName: function(context) {
      if (this.useDepths && context) {
        return 'depths[' + context + ']';
      } else {
        return 'depth' + context;
      }
    },

    quotedString: function(str) {
      return '"' + str
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/\u2028/g, '\\u2028')   // Per Ecma-262 7.3 + 7.8.4
        .replace(/\u2029/g, '\\u2029') + '"';
    },

    objectLiteral: function(obj) {
      var pairs = [];

      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          pairs.push(this.quotedString(key) + ':' + obj[key]);
        }
      }

      return '{' + pairs.join(',') + '}';
    },

    setupHelper: function(paramSize, name, blockHelper) {
      var params = [],
          paramsInit = this.setupParams(name, paramSize, params, blockHelper);
      var foundHelper = this.nameLookup('helpers', name, 'helper');

      return {
        params: params,
        paramsInit: paramsInit,
        name: foundHelper,
        callParams: [this.contextName(0)].concat(params).join(", ")
      };
    },

    setupOptions: function(helper, paramSize, params) {
      var options = {}, contexts = [], types = [], ids = [], param, inverse, program;

      options.name = this.quotedString(helper);
      options.hash = this.popStack();

      if (this.trackIds) {
        options.hashIds = this.popStack();
      }
      if (this.stringParams) {
        options.hashTypes = this.popStack();
        options.hashContexts = this.popStack();
      }

      inverse = this.popStack();
      program = this.popStack();

      // Avoid setting fn and inverse if neither are set. This allows
      // helpers to do a check for `if (options.fn)`
      if (program || inverse) {
        if (!program) {
          program = 'this.noop';
        }

        if (!inverse) {
          inverse = 'this.noop';
        }

        options.fn = program;
        options.inverse = inverse;
      }

      // The parameters go on to the stack in order (making sure that they are evaluated in order)
      // so we need to pop them off the stack in reverse order
      var i = paramSize;
      while (i--) {
        param = this.popStack();
        params[i] = param;

        if (this.trackIds) {
          ids[i] = this.popStack();
        }
        if (this.stringParams) {
          types[i] = this.popStack();
          contexts[i] = this.popStack();
        }
      }

      if (this.trackIds) {
        options.ids = "[" + ids.join(",") + "]";
      }
      if (this.stringParams) {
        options.types = "[" + types.join(",") + "]";
        options.contexts = "[" + contexts.join(",") + "]";
      }

      if (this.options.data) {
        options.data = "data";
      }

      return options;
    },

    // the params and contexts arguments are passed in arrays
    // to fill in
    setupParams: function(helperName, paramSize, params, useRegister) {
      var options = this.objectLiteral(this.setupOptions(helperName, paramSize, params));

      if (useRegister) {
        this.useRegister('options');
        params.push('options');
        return 'options=' + options;
      } else {
        params.push(options);
        return '';
      }
    }
  };

  var reservedWords = (
    "break else new var" +
    " case finally return void" +
    " catch for switch while" +
    " continue function this with" +
    " default if throw" +
    " delete in try" +
    " do instanceof typeof" +
    " abstract enum int short" +
    " boolean export interface static" +
    " byte extends long super" +
    " char final native synchronized" +
    " class float package throws" +
    " const goto private transient" +
    " debugger implements protected volatile" +
    " double import public let yield"
  ).split(" ");

  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

  for(var i=0, l=reservedWords.length; i<l; i++) {
    compilerWords[reservedWords[i]] = true;
  }

  JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
    return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
  };

  __exports__ = JavaScriptCompiler;
  return __exports__;
})(__module2__, __module5__);

// handlebars.js
var __module0__ = (function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__) {
  
  var __exports__;
  /*globals Handlebars: true */
  var Handlebars = __dependency1__;

  // Compiler imports
  var AST = __dependency2__;
  var Parser = __dependency3__.parser;
  var parse = __dependency3__.parse;
  var Compiler = __dependency4__.Compiler;
  var compile = __dependency4__.compile;
  var precompile = __dependency4__.precompile;
  var JavaScriptCompiler = __dependency5__;

  var _create = Handlebars.create;
  var create = function() {
    var hb = _create();

    hb.compile = function(input, options) {
      return compile(input, options, hb);
    };
    hb.precompile = function (input, options) {
      return precompile(input, options, hb);
    };

    hb.AST = AST;
    hb.Compiler = Compiler;
    hb.JavaScriptCompiler = JavaScriptCompiler;
    hb.Parser = Parser;
    hb.parse = parse;

    return hb;
  };

  Handlebars = create();
  Handlebars.create = create;

  Handlebars['default'] = Handlebars;

  __exports__ = Handlebars;
  return __exports__;
})(__module1__, __module7__, __module8__, __module11__, __module12__);

  return __module0__;
}));

define('syracuse-tablet/html/js/helpers/handlebarsHelpers',['require','exports','module'],function (require, exports, module) {

exports.registerHelpers = function(Handlebars) {

	/**
	 * USAGE
	 * 		{{#smCompare name "Code"}}
	 *      {{#smCompare name ">" 5}}
	 */
	Handlebars.registerHelper('smCompare', function(lvalue, operator, rvalue, options) {
		var operators, result;

		if (arguments.length < 3) {
			throw new Error("Handlerbars Helper 'compare' needs 2 parameters");
		}

		if (options === undefined) {
			options = rvalue;
			rvalue = operator;
			operator = "===";
		}

		operators = {
			'==': function(l, r) {
				return l == r;
			},
			'===': function(l, r) {
				return l === r;
			},
			'!=': function(l, r) {
				return l != r;
			},
			'!==': function(l, r) {
				return l !== r;
			},
			'<': function(l, r) {
				return l < r;
			},
			'>': function(l, r) {
				return l > r;
			},
			'<=': function(l, r) {
				return l <= r;
			},
			'>=': function(l, r) {
				return l >= r;
			},
			'typeof': function(l, r) {
				return typeof l == r;
			}
		};

		if (!operators[operator]) {
			throw new Error("Handlerbars Helper 'compare' doesn't know the operator " + operator);
		}

		result = operators[operator](lvalue, rvalue);

		if (result) {
			return options.fn(this);
		} else {
			return options.inverse(this);
		}

	});
};
});

define('syracuse-tablet/html/js/main',['require','exports','module','syracuse-tablet/html/js/ui/modals/modal','syracuse-tablet/html/js/ui/uiUtils','syracuse-tablet/html/js/helpers/globals','syracuse-tablet/html/js/helpers/jsutils','syracuse-tablet/html/js/init/initStyles','syracuse-tablet/html/js/init/initLocale','syracuse-tablet/html/js/init/initModules','syracuse-tablet/html/js/init/initLogin','syracuse-tablet/html/deps/handlebars-latest','syracuse-tablet/html/js/helpers/handlebarsHelpers'],function (require, exports, module) {

var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var initStyles = require('syracuse-tablet/html/js/init/initStyles');
var initLocale = require('syracuse-tablet/html/js/init/initLocale');
var initModules = require('syracuse-tablet/html/js/init/initModules');
var initLogin = require('syracuse-tablet/html/js/init/initLogin');
// Add Handlebars to root
window.Handlebars = require('syracuse-tablet/html/deps/handlebars-latest');
// Add our own helpers
require('syracuse-tablet/html/js/helpers/handlebarsHelpers').registerHelpers(window.Handlebars);

window.onerror = function(errorMsg, url, lineNumber, error) {
	if (globals.application) {
		globals.application.waitWheelStop();
	} else {
		uiutils.waitWheelStop();
	}
	try {
		modal.error("Javascript error", {
			where: "window.onerror",
			exception: error,
			message: errorMsg + "\n" + (url ? "Url : " + jsutils.cleanStack(url) + "\nLineNumber : " + lineNumber : "")
		});
	} catch (e) {
		var msg = errorMsg + "\n" + (error ? +JSON.stringify(error, null, 2) : (url ? "Url : " + url + "\nLineNumber : " + lineNumber : ""));
		alert(msg);
	}
};

function _startup() {
	return initStyles.init()
		.then(function() {
			return initLocale.init();
		})
		.then(function() {
			return initModules.init();
		})
		.then(function() {
			return initLogin.init();
		}).fail(function(e) {
			modal.error("_startup error", e);
		});
}

$(document).ready(function() {
	if (document.location.href.indexOf("?circular") > -1) {
		xrayquire.showCycles(undefined, true);
	} else {
		_startup();
	}
});
});

