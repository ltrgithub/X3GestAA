"use strict";

/*
 * 
 * THIS COE MUST BE LOADED IN HTML PAGE
 * IOS WRAPPER NEEDS THE AVAILABILILTY OF initIOSWrapper 
 * !! This file must not be included into minimize main file
 * 
 */
(function() {

	var _log = function() {
		if (window.smNativeLogger == null || window.smNativeLogger.log == null) {
			return
		}
		window.smNativeLogger.log.apply(null, arguments)
	}
	_log = null

	if (window.webkit == null || window.webkit.messageHandlers == null) {
		return
	}
	// NATIVE IOS LOGGER
	var _IOSNativeLogger = function() {
		this.log = function(msg) {
			var args = []
			for (var i = 0; i < arguments.length; i++) {
				// IOS logger doesn't accept null value - Only Strings
				if (arguments[i] != null) {
					args.push(arguments[i] + "")
				} else {
					args.push("")
				}
			}
			window.webkit.messageHandlers.log.postMessage(args)
		}
		this.logError = function(where, e) {
			this.log(where, e.message, e.stack)
		}
	}
	window.smNativeLogger = new _IOSNativeLogger()

	// NATIVE IOS WRAPPER
	var _IOSNativeInterface = function() {
			this._promiseCpt = 0
			this._promisesMap = {}

			/*
			 * Returns an IOS NSDictionary 
			 */
			this._serializeToIOSDictionnary = function(names, args) {
					var res = {},
						data
					names.forEach(function(name, idx) {
							res[name] = args != null ? args[idx] : null
							if (res[name] != null && typeof res[name] != "string") {
								throw new Error("IOS Callback - Unexpected parameter type [" + typeof res[name] + "]- Expected string - Name[" + name + "]")
							}
						})
						//window.smNativeLogger.log(JSON.stringify(res, null, 2))
					return res
				}
				/*
				 * Creates/Stored a deferred and returns the promise
				 */
			this._createPromise = function(domain, method) {
					var deferred = $.Deferred()
					var promiseID = domain + "-" + method + "-" + this._promiseCpt++
						var promise = deferred.promise()
					this._promisesMap[promiseID] = deferred
						// ID to retrieve it later
					promise.sageX3MobleID = promiseID
						//_log && _log("promiseID = " + promise.sageX3MobleID)
					return promise
				}
				/*
				 * Resolve/Reject the promise given by promiseID which has been stored previoulsy
				 *	action reject/resolve
				 */
			this._processPromise = function(promiseID, action, result) {
					var deferred = this._promisesMap[promiseID]
					if (!deferred) {
						throw new Error("IOS - Promise not found[" + promiseID + "]")
					}
					delete this._promisesMap[promiseID]
						//_log && _log.log("IOS - processPromise", promiseID, action)
					deferred[action](result)
				}
				/**
				 * Safari doesn't support webSQL in a WKWebView
				 */
			this.getSupportedDB = function() {
					return $.smResolve("indexedDB")
				}
				/*
				 * Notify the wrapper that all the resources have been loaded and that the application is starting
				 */
			this.appStartsRunning = function() {
					_log && _log("appStartsRunning")
					window.webkit.messageHandlers.appStartsRunning.postMessage([])
				}
				/*
				 * Calls the regular isSupported wrappers's method
				 * 	The wrapper's response is sent asynchronously (see prosessResponse/prosessException)
				 */
			this.isSupported = function(domain, method) {
					var promise = this._createPromise(domain, method);
					var args = [promise.sageX3MobleID, domain, method];
					//_log && _log("isSupported args = " + args.join('-'))
					window.webkit.messageHandlers.isSupported.postMessage(this._serializeToIOSDictionnary(["promiseID", "domain", "method"], args));
					return promise;
				}
				/*
				 * Call the regular callMethod wrappers's method
				 * 	The wrapper's response is sent asynchronously (see prosessResponse/prosessException)
				 */
			this.callMethod = function(domain, method, param) {
					var promise = this._createPromise(domain, method);
					var args = [promise.sageX3MobleID, domain, method, param];
					//_log && _log("callMethod args = " + args.join('-'))
					window.webkit.messageHandlers.callMethod.postMessage(this._serializeToIOSDictionnary(["promiseID", "domain", "method", "params"], args));
					return promise;
				}
				/*
				 * Call the regular fireMethod wrappers's method
				 * 	No response is expected from the wrapper
				 */
			this.fireMethod = function(domain, method, param) {
					var args = [domain, method, param];
					//_log && _log("fireMethod args = " + args.join('-'))
					window.webkit.messageHandlers.fireMethod.postMessage(this._serializeToIOSDictionnary(["domain", "method", "params"], args))
				}
				/*
				 * Process the result of callMethod
				 * 	promiseID ID of the promise to resolve
				 *	type type of data returned by wrapper
				 *	responseStr stringified result
				 */
			this.prosessResponse = function(promiseID, type, responseStr) {
					try {
						type = decodeURIComponent(type);
						promiseID = decodeURIComponent(promiseID);
						var result = this.convertIOSData(type, decodeURIComponent(responseStr));
						this._processPromise(promiseID, "resolve", result)
						_log && _log("IOS - RESPONSE PROCESSED", promiseID, type) //, responseStr);
						return null
					} catch (e) {
						window.smNativeLogger.logError("Native call iosServiceResponse", e);
						// ISO Wrapper will recieve and log the error + the stack
						return this.convertErrorForIOS(e)
					}
				}
				/*
				 * Process an IOS exception of callMethod
				 * 	promiseID ID of the promise to reject
				 *	serializedError stringified error
				 */
			this.prosessException = function(promiseID, serializedError) {
					try {
						promiseID = decodeURIComponent(promiseID)
						serializedError = decodeURIComponent(serializedError)
						_log && _log("IOS Wrapper prosessException", serializedError);
						var error = new Error("IOS wrapper exception");
						error.stack = serializedError;
						this._processPromise(promiseID, "reject", error);
					} catch (e) {
						_log && _log("Native call iosServiceException", e.message)
							// ISO Wrapper will recieve and log the error + the stack
						return this.convertErrorForIOS(e)
					}
				}
				/*
				 * Returns the JS typed data according to the type
				 */
			this.convertIOSData = function(type, dataStr) {
				_log && _log("convertIOSData", type ? type : "NULL", dataStr ? dataStr.substr(0, 100) : "NULL")
				if (type == null || dataStr == null) {
					return null;
				}
				switch (type) {
					case "boolean":
						return "true" === dataStr;
					case "string":
						return decodeURIComponent(dataStr);
					default:
						try {
							return dataStr.trim().length === 0 ? null : JSON.parse(decodeURIComponent(dataStr));
						} catch (e) {
							throw new Error("convertIOSData - BAD JSON STRING - " + type + " - " + (dataStr || "").substr(0, 100))
						}
				}
			}

			/*
			 * Serialize a JAVASCRIPT error in a NSDictionary
			 */
			this.convertErrorForIOS = function(error) {
					var res = {
						type: "error"
					}
					if (error == null) {
						res.message = "No error message";
					} else if (typeof error == "string") {
						res.message = error;
					} else if (typeof error == "object") {
						res.message = error.message;
						if (error.stack) {
							res.stack = error.stack.replace(new RegExp(window.location.href.substring(0, window.location.href.lastIndexOf('/')), "g"), "  ");
							res.stack = res.stack.split("\n");
						}
					} else {
						res = null
					}
					return res
				}
				// Returns a type + a string
			this.convertResultForIOS = function(result) {
				if (result == null) return null;
				var res = {}
				var type = typeof result
				switch (type) {
					case "boolean":
						res.type = "boolean";
						res.data = result ? "true" : "false";
						return res;
					case "number":
					case "string":
						res.type = type;
						res.data = result;
						return res;
					case "object":
						try {
							res.type = "json";
							res.data = JSON.stringify(result, null, 2);
							return res;
						} catch (e) {
							throw new Error("convertResultForIOS - Error Stringifying result")
						}
					default:
						return null;
				}
			}
		}
		/*
		 * Called by IOSWrapper to initialize the native object when the document has been loaded (WKUserScriptInjectionTime.AtDocumentEnd)
		 *	Must be declared in html page (not in a require)
		 *	Crates all the needed object
		 */
	window.initIOSWrapper = function(promiseID, responseJSON) {
		window.smNativeLogger = new _IOSNativeLogger()
		window.smNativeInterface = new _IOSNativeInterface()
		window.smNativeLogger.log("IOS Wrapper initialized")
	};
	/*
	 * Called by IOS Wrapper to send the response to callMethod/isSuppported services
	 */
	window.iosServiceResponse = function(promiseID, type, responseStr) {
		//_log && _log("JS CALLBACK iosServiceResponse")
		if (!window.smNativeInterface) return;
		window.smNativeInterface.prosessResponse(promiseID, type, responseStr);
	};
	/*
	 * Called by IOS Wrapper to send an exception if callMethod/isSuppported failed
	 */
	window.iosServiceException = function(promiseID, serializedError) {
		//_log && _log("JS CALLBACK iosServiceException")
		if (!window.smNativeInterface) return;
		window.smNativeInterface.prosessException(promiseID, serializedError);
	};
	/*
	 * Called by IOS wrapped to invoke the given objectName/methodName javascript service
	 *	The response is returned synchronously
	 */
	window.iosJavascriptServiceCall = function(objectName, methodName, type, params) {
		try {
			if (!window.smJSCall || !window.smNativeInterface) {
				throw new Error("window.smJSCall not initialized");
			}
			var res = window.smJSCall(objectName, methodName, window.smNativeInterface.convertIOSData(type, params))

			_log && _log("iosJavascriptServiceCall", objectName, methodName, type, JSON.stringify(res).substr(0, 100));
			return window.smNativeInterface.convertResultForIOS(res);
		} catch (e) {
			return window.smNativeInterface.convertErrorForIOS(e);
		}
	}
	window.smNativeFatalError = function(message, stack) {
		if (window.webkit.messageHandlers.fatalError) {
			if (stack != null && typeof stack != "string") {
				stack = JSON.stringify(stack, null, 2)
			}
			window.webkit.messageHandlers.fatalError.postMessage([message, stack])
		}
	}
	window.smNativeLogger && window.smNativeLogger.log("IOS JS LOADED")
})();