"use strict";

var _ns = "sm";
var _nsNormalizeDict = {};

var _nsNormalize = function(prop) {
	return prop == null ? null : _nsNormalizeDict[prop] || (_nsNormalizeDict[prop] = $.camelCase(_ns + prop));
};

/* Can be used to determin root level extend on unlimited recursion
var _org_extend = $.fn.extend;
var _extend_stack = [];
jQuery.extend = function() {
	try {
		throw new Error("extend")
	} catch (e) {
		_extend_stack.push(e);
	}
	try {
		var r = _org_extend.apply(this, arguments);
	} catch (x) {
		throw _extend_stack[0];
		_extend_stack.pop();
		throw x;
	}
	_extend_stack.pop();
	return r;
};
*/

$.fn.smData = function(prop, value) {
	var result;
	if (prop != null) {
		if (prop) prop = _nsNormalize(prop);
		if (arguments.length < 2 || value === undefined) {
			result = this.data(prop);
		} else {
			result = this.data(prop, value);
		}
	}
	return result;
};

$.fn.smRemoveData = function(prop) {
	return this.removeData(_nsNormalize(prop));
};

$.fn.smPageController = function(ctrl) {
	return this.smData("controller", ctrl);
};

$.fn.smPageRemoveController = function() {
	return this.smRemoveData("controller");
};

/**
 * True if evt pageX/pageY are inside $elmt
 * typeRect: outer, inner, computed
 */
var _meths = {
	outer: ["outerWidth", "outerHeight"],
	inner: ["innerWidth", "innerHeight"],
	computed: ["width", "height"]
};
$.fn.smEvtInside = function(evt, typeRect) {
	var m = _meths[typeRect || "outer"];
	var o = this.offset();
	return evt.pageX >= o.left && evt.pageX <= o.left + this[m[0]]() && evt.pageY >= o.top && evt.pageY <= o.top + this[m[1]]();
};
/*
 * Returns a promise that immediately resolves
 * typeof first argument === "function" - > execute the function
 */
$.smResolve = function() {
	var beforeStart = arguments.length > 0 && typeof arguments[0] === "function" ? arguments[0] : null;
	var deferred = $.Deferred(beforeStart);
	deferred.resolve.apply(deferred, beforeStart ? Array.prototype.splice.call(arguments, 0, 1) : arguments);
	return deferred.promise();
};
/*
 * Returns a promise that immediately rejects
 */
$.smReject = function() {
	var deferred = $.Deferred();
	deferred.reject.apply(deferred, arguments);
	return deferred.promise();
};

$.smForEachKey = function(o, cb, ctx) {
	Object.keys(o).forEach(function(k) {
		cb.call(ctx, k, o[k]);
	});
};

$.smForEach = function(arr, cb, ctx) {
	var i = 0;
	arr.forEach(function(k) {
		cb.call(ctx, k, i++);
	});
};
$.smUrlParam = function(name) {
	var results = new RegExp('[\?&]' + name + '=([^&#]*)').exec(window.location.href);
	if (results == null) {
		return null;
	} else {
		return (results[1] && decodeURIComponent(results[1])) || null;
	}
};

/**
 * Sequentially loops over an array invoking a callback which must return a promise
 * Returns a promise which is resolved as soon as the last promise of the loop is resolved.
 */
$.smForEachPromise = function(arr, cb, resolve) {
	if (arr === undefined || arr === null)
		throw new TypeError();

	var deferred = $.Deferred();
	var queue = [];
	arr.forEach(function(elem) {
		queue.push(elem);
	});
	var idx = 0;
	var count = queue.length;

	var loop = function() {
		var elem = queue.shift();
		if (elem == null) {
			deferred.resolve();
		} else {
			var prom = cb(elem, idx, count);
			idx++;
			prom.then(function(result) {
				if (resolve) {
					if (resolve(elem, result) === true) {
						deferred.resolve();
						queue = [];
					}
				}
				loop();
			}).fail(function(e) {
				deferred.reject(e);
			});
		}
	};
	loop();
	return deferred.promise();
};

$.smFind = function(arr, fun /*, thisArg*/ ) {
	console.log("smFind");
	if (arr === undefined || arr === null)
		throw new TypeError();
	var t = Object(arr);
	var len = t.length >>> 0;
	if (typeof fun !== 'function')
		throw new TypeError();
	var thisArg = arguments.length >= 3 ? arguments[2] : void 0;
	for (var i = 0; i < len; i++) {
		if (i in t && fun.call(thisArg, t[i], i, t)) {
			return t[i];
		}
	}
	return null;
};
/**
 * Unused - we use override of promise - see myDeferred
 */


var _cpts = {
	count: 0,
	rejectWith: 0,
	resolveWith: 0
};

var _traceCpt = function() {
	//	if (_cpts.count % 50 === 0) console.log('deferreds : Sum: ' + _cpts.count + " - Rej: " + _cpts.rejectWith + " - Res: " + _cpts.resolveWith + " - Pend: " + (_cpts.count - _cpts.rejectWith - _cpts.resolveWith));
};

jQuery.extend({
	smDeferred: function(func) {
		var tuples = [
			// action, add listener, listener list, final state
			["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
			["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
			["notify", "progress", jQuery.Callbacks("memory")]
		],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done(arguments).fail(arguments);
					return this;
				},
				then: function(fnDone, fnFail, fnProgress) {
					var fns = arguments;
					return jQuery.Deferred(function(newDefer) {
						jQuery.each(tuples, function(i, tuple) {
							var fn = jQuery.isFunction(fns[i]) && fns[i];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[tuple[1]](function() {

								/////////////////////////////////////////////////////////////////////
								// This block is the only change compared to jQuery implementation
								// The goal is to reject a promise that causes an exception instead
								// of bubbling the exception which does not work in async functions
								/////////////////////////////////////////////////////////////////////
								try {
									var returned = fn && fn.apply(this, arguments);
								} catch (e) {
									newDefer.reject(e);
									return;
								}
								///////////////////////////////////////////////////////////////////
								// End
								///////////////////////////////////////////////////////////////////

								if (returned && jQuery.isFunction(returned.promise)) {
									returned.promise()
										.done(newDefer.resolve)
										.fail(newDefer.reject)
										.progress(newDefer.notify);
								} else {
									newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function(obj) {
					return obj != null ? jQuery.extend(obj, promise) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each(tuples, function(i, tuple) {
			var list = tuple[2],
				stateString = tuple[3];

			// promise[ done | fail | progress ] = list.add
			promise[tuple[1]] = list.add;

			// Handle state
			if (stateString) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

					// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[i ^ 1][2].disable, tuples[2][2].lock);
			}

			// deferred[ resolve | reject | notify ]
			deferred[tuple[0]] = function() {
				deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
				return this;
			};
			deferred[tuple[0] + "With"] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise(deferred);

		// Call given func if any
		if (func) {
			func.call(deferred, deferred);
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function(subordinate) {
		var i = 0,
			resolveValues = jQuery.fn.slice.call(jQuery.fn, arguments),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function(i, contexts, values) {
				return function(value) {
					contexts[i] = this;
					values[i] = arguments.length > 1 ? jQuery.fn.slice.call(jQuery.fn, arguments) : value;
					if (values === progressValues) {
						deferred.notifyWith(contexts, values);
					} else if (!(--remaining)) {
						deferred.resolveWith(contexts, values);
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if (length > 1) {
			progressValues = new Array(length);
			progressContexts = new Array(length);
			resolveContexts = new Array(length);
			for (; i < length; i++) {
				if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
					resolveValues[i].promise()
						.done(updateFunc(i, resolveContexts, resolveValues))
						.fail(deferred.reject)
						.progress(updateFunc(i, progressContexts, progressValues));
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if (!remaining) {
			deferred.resolveWith(resolveContexts, resolveValues);
		}

		return deferred.promise();
	}
});

//jQuery.Deferred = jQuery.smDeferred; 


/**
 * FDB implementation to solve the issue of asynchronous calls in deferred
 * Tested with the following use case
 * 	Goto pageRegular.loadData and put 'throw new Error("test")' before setDao
 * 	-> Error should be handled by _rejectError handler
 *  -> If we open a representation in vignette the vignette should show the error
 *
 *  !! NEVER put a try{}catch(e){} in the deferred success handler but add a fail handler to cath teh exception
 */

var jqDeferred = $.Deferred;
var myDeferred = function(func) {
	var deferred = jqDeferred(func);
	_cpts.count++;
	_traceCpt();
	// just to have a trace of uncaught errors
	// It souldn't occur because error is caught by the then/done method
	var resolve = deferred.resolve;
	deferred.resolve = function() {
		try {
			resolve.apply(deferred, arguments);
		} catch (e) {
			console.log("!!! UNCAUGHT DEFERRED.RESOLVE EXCEPTION\nMessage: ", typeof e === "string" || e == null ? e : e.message + (e.Stack ? "\nStack:\n" + e.stack : ""));
			throw e;
		}
	};
	// just to count resolve/rejects and compare to the number of deferred created
	var resolveWith = deferred.resolveWith;
	deferred.resolveWith = function() {
		_cpts.resolveWith++;
		_traceCpt();
		resolveWith.apply(deferred, arguments);
	};
	var rejectWith = deferred.rejectWith;
	deferred.rejectWith = function() {
		_cpts.rejectWith++;
		_traceCpt();
		rejectWith.apply(deferred, arguments);
	};
	// Override 'then' promise method to catch the exception in the success handler
	// Only 'then' can be overridden (done method should never fail)
	var promise = deferred.promise;
	deferred.promise = function() {
		var myPromise = promise.apply(deferred, arguments);
		var then = myPromise.then;
		myPromise.then = function() {
			var callBack = arguments[0];
			if (typeof callBack === 'function') {
				// Hack only if success handler is a function - avoid arrays
				return then.call(myPromise, function() {
					try {
						return callBack.apply(myPromise, arguments);
					} catch (e) {
						// TODO - See if we have to reject the old deferred - deferred.reject();
						console.log("DEFERRED.then exception - message:\n", e ? e.message ? e.message.substring(0, 200) : e : "No exception");
						console.log("then.exception - stack:\n", e ? e.stack ? e.stack : e : "No exception");
						return jqDeferred(function(def) {
							def.reject(e);
						}).promise();
					}
					// Propagate fail and notify
				}, arguments[1], arguments[2]);
			} else {
				return then.apply(myPromise, arguments);
			}
		};
		return myPromise;
	};
	return deferred;
};

jQuery.Deferred = myDeferred;