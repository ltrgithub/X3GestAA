"use strict";
var fs = require('fs');
var util = require("util");
require('npm-shadow')();
var uglify = require('uglify-js');


var node_jslint = require('./jslint');

var clientGlobals = {
	'$': '',
	'document': '',
	'alert': '',
	'window': '',
	'jQuery': '',
	'external': "",
	'XMLHttpRequest': "",

	'require': '',
	'console': '',
	'module': '',
	'exports': '',
	'Error': '',
	'Array': '',
	'undefined': '',
	'JSON': '',
	'Object': '',
	'Math': '',
	'TypeError': '',
	'RegExp': '',
	'NaN': '',
	'Infinity': "",
	'String': '',
	'Boolean': '',
	'Date': '',
	'Function': '',
	'Number': '',
	'eval': '',
	'isFinite': '',
	'isNaN': '',
	'parseInt': '',
	'parseFloat': '',
	'encodeURIComponent': '',
	'decodeURIComponent': '',
	'openDatabase': '',
	'setTimeout': '',
	'escape': '',
	'xrayquire': '',
	'Handlebars': '',
	'Highcharts': '',
	'navigator': '',
	'define': '',
	'btoa': '',
	'FileReader': '',
	'Hammer': ''
};

var commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg;
var requireRegExp = /\w*\s*(\w*)\s*=\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g;

var scannedFiles = {};

function checkFile(path, buf) {
	if (path.indexOf('/deps/') > 0) return;
	if (path.indexOf('/build/') > 0) return;
	if (path.indexOf('/native/') > 0 && !path.indexOf('js/helpers/native/') > 0) return;
	if (path.indexOf('/mockup/') > 0) return;
	if (!(path.indexOf('/test/') > 0 || path.indexOf('/html/') > 0)) return;
	if (path.indexOf('.joined.js') > 0 || path.indexOf('.min.js') > 0) return;

	var code = buf.toString('utf8');
	// remove shebang
	code = code.replace(/^\#\!.*/, '');

	var orgCode = code;
	code = '(function(){' + code + '})';
	try {
		var top = uglify.parse(code);

		var testCode = (path.indexOf('test') >= 0);
		top.figure_out_scope();
		var globals = top.globals;
		var header = path;
		var unknown = {};
		globals.each(function(a, name) {
			if (name !== 'arguments' && !(name in clientGlobals)) {
				unknown[name] = (unknown[name] || "") + (a.orig.map(function(entry) {
					return "[" + entry.start.line + ":" + entry.start.col + "]";
				}).join());
			}
		});
		var unknownKeys = Object.keys(unknown);
		if (unknownKeys && unknownKeys.length > 0){
			unknown = unknownKeys.sort().map(function(key) {
				return key + unknown[key];
			});
		}else{
			unknown = null;
		}
		var unusedDeps = depCheck(path, code);
		runLint(orgCode, function(lintRes) {
			var duplMethods = checkDoubleMethods(code);
			if (unknown || lintRes || unusedDeps || duplMethods.length > 0) {
				console.log("");
				console.log(path);
				if (unknown) {
					console.log("Unknown:");
					console.log(unknown.join(", "));
				}
				if (lintRes) {
					console.log("Lint:");
					console.log(lintRes.join("\n"));
				}
				if (duplMethods.length > 0) {
					console.log("Duplicate method names:");
					duplMethods.forEach(function(i){
						console.log("\t" + i.name + (i.type ? " - Type[" + i.type + "] - Line[" + i.line + "]" : ""));
					})
				}
				if (unusedDeps) {
					console.log("Unused requires:");
					console.log(unusedDeps.join("\n"));
				}
			}
		});
	} catch (e) {
		console.log("Parse error for " + path);
		console.log(path + ": Parser error: " + e);
	}

}

function runLint(code, endCallback) {
	// Replace multiline strings with a dummy code line
	code = code.replace(/.*'.*\\\s+((.*?)\\\s+)*.*'[;,\)\s].*/gmi, function(m) {
		var lc = [];

		var a = m.indexOf("'");
		var b = m.lastIndexOf("'");
		
		var start = m.substr(0, a - 1);
		var end =  m.substr(b + 1);
		
		var mid = m.substring(a, b - a + 1);
		var count = mid.split("\n").length + 2;
		while (count > 0) {
			lc.push("''");
			count = count -1;
		}
		var dummyLines = lc.join("+\n");

		res = start + dummyLines + end;
		
//		console.log(start);
//		console.log("->"+mid);
//		console.log(end+"<");
		
		//console.log(res);
		return res;
	});

	function end(r) {
		if (r.length == 0) {
			r = null;
		}

		var cb = endCallback;
		endCallback = null;
		cb && cb(r);
	}
	var LintStream = node_jslint.LintStream;
	var options = {
		"edition": "latest",
		"length": 100
	};
	var res = [];

	var l = new LintStream(options);

	var fileName, fileContents;

	// Note: This only fires because an emit was manually added in jslint module in
	// _stream_readable -> emitDataEvents
	// f (c === null) {
	// 	 stream.emit('end');
	//   readable = false;
	//   stream._readableState.needReadable = true;
	// }	
	l.on('end', function() {
		end(res);
	});

	l.write({
		file: fileName,
		body: code
	});

	var errors = true;
	l.on('data', function(chunk, encoding, callback) {
		// chunk is an object
		// chunk.linted is an object holding the result from running JSLint
		// chunk.linted.ok is the boolean return code from JSLINT()
		// chunk.linted.errors is the array of errors, etc.
		// see JSLINT for the complete contents of the object
		chunk.linted.errors && chunk.linted.errors.forEach(function(err) {

			// Filter error we want to see in the result
			if (["duplicate_a"].indexOf(err.code) > -1) {
				res.push(err.message + " - Line: " + err.line);
				return;
			}

			//console.log(err);
			// Check invalid reported error that block further tests
			if (["unclosed_string"].indexOf(err.code) > -1) {
				res.push("Unable to check because of: " + err.message + " - Line: " + err.line);
			}
		});
		callback && callback();
	});

}
/**
 * Improvement
 * Take advantage of code stringification to detect duplicated methods
 * Detects double exports, double class:methods and double this.method * 
 */
function checkDoubleMethods(code)
{
	var r_export = /exports\.(\S+?)\s*=/;
	var r_this_method = /this\.(\S+?)\s*=\s*function/;
	var r_class_method = /(\S+?)\s*:\s*function/;
	var duplicated = [];
	var methods = {};
	var exports = [];
	var prevLevel=0;
	var name, level, type;
	var trimedLine;
	code.split('\n').forEach(function(line, idx){
		trimedLine = (line || "").trim();
		// check comment
		if (trimedLine.indexOf("//") == 0 || trimedLine.indexOf("/*") == 0){
			return;
		}
		// Indentation level
		level = 0;
		line.split("\t").some(function(x, idx){
			if(x.length !== 0){
				level = idx;
				return true;
			}
		})
		// check EXPORTS
		name = r_export.exec(line);
		if(name){
			name = name[1];
			if(exports.indexOf(name) >= 0){
				duplicated.push({
					type: "export",
					name: name,
					line: idx + 1
				})
			}	
			exports.push(name);
		}
		// check METHODS
		var pl = prevLevel + "";
		if(level < prevLevel && methods[pl]){
			// Level down - reset counter
			var res = methods[pl];
			if (res.d.length > 0){
				res.d.forEach(function(r){
					duplicated.push(r);
				})
			}
			delete methods[pl];
		}
		name = r_this_method.exec(line);
		if (!name){
			name = r_class_method.exec(line);
			if(name){
				type = "class.method";
			}
		}else{
			type = "this.method";
		}
		if (name){
			name = name[1];
			var lv = level + "";
			if (!methods[lv]){
				methods[lv] = {
					m: [],
					d: []
				}
			}
			if(methods[lv].m.indexOf(name) >= 0){
				methods[lv].d.push({
					name: name,
					line: idx + 1, 
					type: type
				});
			}
			methods[lv].m.push(name);
		}
		prevLevel = level;
	})
	// Remainings
	for (var level in methods){
		level = methods[level];
		if(level && level.d){
			level.d.forEach(function(r){
				duplicated.push(r);
			})
		}
	}
	return duplicated;
}

function depCheck(path, code) {
	
	// Compute relative path name to fit require argument
	var relName = path;
	var i = relName.indexOf("syracuse-tablet/");
	if (i > -1) {
		relName = relName.substring(i);
	}
	var fileData = scannedFiles[relName] = {
		requires: []
	};
	
	var reqVars = {};
	var reqVarsHit = [];
	code = code.replace(commentRegExp, "").replace(requireRegExp, function(dep, p1, p2) {
		reqVars[p1] = dep;
		fileData.requires.push(p2 + ".js");
		return "";
	});
	Object.keys(reqVars).map(function(key) {
		if (!new RegExp("\\b" + key + "\\b", "g").test(code)) {
			reqVarsHit.push(reqVars[key]);
		}
	});
	if (reqVarsHit.length > 0) {
		return reqVarsHit;
	}
}

function checkForPendingMerge(f, buf) {
	var data = buf.toString('utf8');
	var lines = data.split("\n");
	var i;
	for (i = 0; i < lines.length; i++) {
		var line = lines[i];
		if (line.indexOf("<<<<<<<") === 0 ||
			line === "=======" ||
			line.indexOf(">>>>>>>") === 0)
		{
			console.log("Unresolved merge in: " + f + " at line: " + (i + 1));
			return;
		}
	}
}

function scan(f) {
	f = f.replace(/\\/g, "/");
	if (f.indexOf('socket.io/support/expresso/deps/jscoverage/tests') >= 0 //
		||
		f.indexOf('/dotnet/') >= 0 //
		||
		f.indexOf('/junk/') >= 0) return;
	var stat = fs.lstatSync(f);
	if (stat.isDirectory()) {
		fs.readdirSync(f).forEach(function(n) {
			if (n !== '.git' && n !== '.svn') scan(f + "/" + n);
		});
	} else if (!stat.isSymbolicLink()) {
		var ext = f.substring(f.lastIndexOf('.')).toLowerCase();
		
		// Do not check build dir
		if (f.indexOf('/html/build/') > -1 ||
		    f.indexOf('/codecheck/') > -1 ||
		    f.indexOf('/test/') > -1) 
		{
			return;
		}

		// In the dist dir, we check all files for broken merges only
		if (f.indexOf('/dist/') > -1) {
			var data = fs.readFileSync(f);
			checkForPendingMerge(f, data);
			return;
		}

		if (ext === '.js' || ext === '._js') {
			var data = fs.readFileSync(f);
			checkForPendingMerge(f, data);
			checkFile(f, data);
		}
	}
}

function checkRequirePaths() 
{
	var scannedFileNames = Object.keys(scannedFiles);

	scannedFileNames.forEach(function(file) {
		var fileData = scannedFiles[file];
		fileData.requires.forEach(function(req) {

			var match = scannedFileNames.some(function(known) {
				return req === known;
			});

			var matchCI = false;
			if (!match) {
				matchCI = scannedFileNames.some(function(known) {
					return req.toLowerCase() === known.toLowerCase();
				});
			}
				
			
			if (!match && matchCI) {
				console.log("Require is using wrong upper/lower case spelling in: " + file + " require: " + req);
			}
		});			
	});	
}

try {
	scan(process.argv[2] || '.');
	
	checkRequirePaths();
	
} catch (ex) {
	console.error("ERROR: " + ex);
}