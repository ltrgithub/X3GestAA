"use strict";
var fs = require('fs');
var util = require("util");
require('npm-shadow')();
var uglify = require('uglify-js');


var node_jslint = require('./jslint');

var clientGlobals = {
	'$': '',
	'document': '',
	'alert': '',
	'window': '',
	'jQuery': '',
	'external': "",
	'XMLHttpRequest': "",

	'require': '',
	'console': '',
	'module': '',
	'exports': '',
	'Error': '',
	'Array': '',
	'undefined': '',
	'JSON': '',
	'Object': '',
	'Math': '',
	'TypeError': '',
	'RegExp': '',
	'NaN': '',
	'Infinity': "",
	'String': '',
	'Boolean': '',
	'Date': '',
	'Function': '',
	'Number': '',
	'eval': '',
	'isFinite': '',
	'isNaN': '',
	'parseInt': '',
	'parseFloat': '',
	'encodeURIComponent': '',
	'decodeURIComponent': '',
	'openDatabase': '',
	'setTimeout': '',
	'escape': '',
	'xrayquire': '',
	'Handlebars': '',
	'Highcharts': '',
	'navigator': '',
	'define': '',
	'btoa': '',
	'FileReader': '',
	'Hammer': ''
};

var commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg;
var requireRegExp = /\w*\s*(\w*)\s*=\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g;

function checkFile(path, buf) {
	if (path.indexOf('/deps/') > 0) return;
	if (path.indexOf('/build/') > 0) return;
	if (path.indexOf('/native/') > 0 && !path.indexOf('js/helpers/native/') > 0) return;
	if (path.indexOf('/mockup/') > 0) return;
	if (!(path.indexOf('/test/') > 0 || path.indexOf('/html/') > 0)) return;
	if (path.indexOf('.joined.js') > 0 || path.indexOf('.min.js') > 0) return;

	var code = buf.toString('utf8');
	// remove shebang
	code = code.replace(/^\#\!.*/, '');
	var orgCode = code;
	code = '(function(){' + code + '})';
	try {
		var top = uglify.parse(code);

		var testCode = (path.indexOf('test') >= 0);
		top.figure_out_scope();
		var globals = top.globals;
		var header = path;
		var unknown = {};
		globals.each(function(a, name) {
			if (name !== 'arguments' && !(name in clientGlobals)) {
				unknown[name] = (unknown[name] || "") + a.orig.map(function(entry) {
					return "[" + entry.start.line + ":" + entry.start.col + "]";
				}).join();
			}
		});
		unknown = Object.keys(unknown).sort().map(function(key) {
			return key;
		});
		if (unknown.length == 0) {
			unknown = null;
		}
		var unusedDeps = depCheck(path, code);
		
		runLint(orgCode, function(lintRes) {
			
			var duplMethods = checkDoubleMethods(code);
			if (unknown || lintRes || unusedDeps || duplMethods) {
				console.log("");
				console.log(path);
				if (unknown) {
					console.log("Unknown:");
					console.log(unknown.join(", "));
				}
				if (lintRes) {
					console.log("Lint:");
					console.log(lintRes.join("\n"));
				}
				if (duplMethods) {
					console.log("Duplicate method names:");
					console.log(duplMethods.join("\n"));
				}
				if (unusedDeps) {
					console.log("Unused requires:");
					console.log(unusedDeps.join("\n"));
				}
			}
		});
	} catch (e) {
		console.log("Parse error for " + path);
		console.log(path + ": Parser error: " + e);
	}

}

function runLint(code, endCallback) {
	// Replace multiline strings with a dummy code line
	code = code.replace(/.*'.*\\\s+((.*?)\\\s+)*.*'[;,\)\s].*/gmi, function(m) {
		var lc = [];

		var a = m.indexOf("'");
		var b = m.lastIndexOf("'");
		
		var start = m.substr(0, a - 1);
		var end =  m.substr(b + 1);
		
		var mid = m.substring(a, b - a + 1);
		var count = mid.split("\n").length + 2;
		while (count > 0) {
			lc.push("''");
			count = count -1;
		}
		var dummyLines = lc.join("+\n");

		res = start + dummyLines + end;
		
//		console.log(start);
//		console.log("->"+mid);
//		console.log(end+"<");
		
		//console.log(res);
		return res;
	});

	function end(r) {
		if (r.length == 0) {
			r = null;
		}

		var cb = endCallback;
		endCallback = null;
		cb && cb(r);
	}
	var LintStream = node_jslint.LintStream;
	var options = {
		"edition": "latest",
		"length": 100
	};
	var res = [];

	var l = new LintStream(options);

	var fileName, fileContents;

	// Note: This only fires because an emit was manually added in jslint module in
	// _stream_readable -> emitDataEvents
	// f (c === null) {
	// 	 stream.emit('end');
	//   readable = false;
	//   stream._readableState.needReadable = true;
	// }	
	l.on('end', function() {
		end(res);
	});

	l.write({
		file: fileName,
		body: code
	});

	var errors = true;
	l.on('data', function(chunk, encoding, callback) {
		// chunk is an object
		// chunk.linted is an object holding the result from running JSLint
		// chunk.linted.ok is the boolean return code from JSLINT()
		// chunk.linted.errors is the array of errors, etc.
		// see JSLINT for the complete contents of the object
		chunk.linted.errors && chunk.linted.errors.forEach(function(err) {

			// Filter error we want to see in the result
			if (["duplicate_a"].indexOf(err.code) > -1) {
				res.push(err.message + " - Line: " + err.line);
				return;
			}

			//console.log(err);
			// Check invalid reported error that block further tests
			if (["unclosed_string"].indexOf(err.code) > -1) {
				res.push("Unable to check because of: " + err.message + " - Line: " + err.line);
			}
		});
		callback && callback();
	});

}
function checkDoubleMethods(code)
{
	var doubledMethods = [];
	// Check double exports
	var exportsMethods = [];
	var r = /exports\.(\S+?)\s*=/g;
	var e;
	while ((e = r.exec(code)) != null) {
		if (e.length > 1) {
			var m = e[1];
			if (exportsMethods.indexOf(m) > -1) {
				doubledMethods.push(m);
			} else {
				exportsMethods.push(m); // export name
			}
		}
	}
	
	// Check double declaration in objects
	// Not 100% correct but does the trick for now
	var thisMethods = [];
	var r = /this\.(\S+?)\s*=\s*function/g;
	var e;
	while ((e = r.exec(code)) != null) {
		if (e.length > 1) {
			var m = e[1];
			if (thisMethods.indexOf(m) > -1) {
				doubledMethods.push(m);
			} else {
				thisMethods.push(m); // export name
			}
		}
	}
	return doubledMethods.length > 0 ? doubledMethods : null; 
}

function depCheck(path, code) {
	var reqVars = {};
	var reqVarsHit = [];
	code = code.replace(commentRegExp, "").replace(requireRegExp, function(dep, p1) {
		reqVars[p1] = dep;
		return "";
	});
	Object.keys(reqVars).map(function(key) {
		if (!new RegExp("\\b" + key + "\\b", "g").test(code)) {
			reqVarsHit.push(reqVars[key]);
		}
	});
	if (reqVarsHit.length > 0) {
		return reqVarsHit;
	}
}

function scan(f) {
	f = f.replace(/\\/g, "/");
	if (f.indexOf('socket.io/support/expresso/deps/jscoverage/tests') >= 0 //
		||
		f.indexOf('/dotnet/') >= 0 //
		||
		f.indexOf('/junk/') >= 0) return;
	var stat = fs.lstatSync(f);
	if (stat.isDirectory()) {
		fs.readdirSync(f).forEach(function(n) {
			if (n !== '.git' && n !== '.svn') scan(f + "/" + n);
		});
	} else if (!stat.isSymbolicLink()) {
		var ext = f.substring(f.lastIndexOf('.')).toLowerCase();
		if (ext === '.js' || ext === '._js') {
			var data = fs.readFileSync(f);
			checkFile(f, data);
		}
	}
}

try {
	scan(process.argv[2] || '.');
} catch (ex) {
	console.error("ERROR: " + ex);
}