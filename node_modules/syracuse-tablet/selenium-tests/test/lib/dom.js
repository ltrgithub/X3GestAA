"use strict";

var driver = require("./driver");
var UT = require("../ut");

/**
 * Set value of element
 * Can be input or select tag
 *
 * selector: selector of element or a webelement
 * value: value to set
 * [parent]: Optional parent selector
 */
exports.setValue = function(selector, value, parent) {
	UT.log("Set value: '" + value + "' for " + JSON.stringify(selector) + (parent == null ? "" : JSON.stringify(parent)));
	return _findElement(selector, parent).then(function(element) {
		return element.getTagName().then(function(tagName) {
			if (tagName === "input") {
				return _setInputValue(element, value);
			} else if (tagName === "select") {
				return _setSelectValue(element, value);
			}
		});
	});
};

/**
 * Get attribute of element
 *
 * selector: selector of element or a webelement
 * attr: name of attribute to read
 * [parent]: Optional parent selector
 */
exports.getAttr = function(selector, attr, parent) {
	return _findElement(selector, parent).then(function(element) {
		return element.getAttribute(attr);
	});
};

/**
 * Get attribute of element
 *
 * selector: selector of element or a webelement
 * [parent]: Optional parent selector
 */
exports.getText = function(selector, parent) {
	return _findElement(selector, parent).then(function(element) {
		return element.getText();
	});
};

/**
 * Click an element
 * selector: selector of element or a webelement
 * [parent]: Optional parent selector
 */
exports.click = function(selector, parent) {
	//UT.log("Click " + JSON.stringify(selector) + (parent == null ? "" : JSON.stringify(parent)));
	return _findElement(selector, parent)
		.then(function(element) {
			return element.click();
		});
};

/**
 * Wait for an element to become visible
 * selector: selector of element
 */
exports.waitVisible = function(selector, timeout) {
	return exports.waitLocated(selector, timeout)
		.then(function(element) {
			return driver.Browser().wait(
				driver.Until.elementIsVisible(element),
				timeout);
		});
};

/**
 * Wait for one element to become available
 * selector: selector of element, if selector is an array of selectors, wait until the first is located
 *
 * Returns the first match
 */
exports.waitLocated = function(selector, timeout) {
	timeout = timeout != null ? timeout : 1;
	UT.log("Wait located: " + JSON.stringify(selector));
	if (!Array.isArray(selector)) {
		return driver.Browser().wait(
			driver.Until.elementLocated(selector),
			timeout);
	} else {
		return driver.Browser().wait(
			driver.Until.elementsLocated(function() {
				var deferred = UT.Deferred();
				var founds = [];
				var done = 0;
				selector.forEach(function(sel, idx) {
					driver.Browser().wait(
						driver.Until.elementLocated(sel), 50)
						.then(function(found) {
							founds.push(found);
						})
						.thenCatch(function() {
							// Timeout
						})
						.thenFinally(function() {
							done++;
							if (done === selector.length) {
								if (founds.length > 0) {
									deferred.fulfill(founds[0]);
								}
								// The callback of elementsLocated is called as long as we resolve with null
								deferred.fulfill(null);
							}
						});
				});
				return deferred.promise;
			}), timeout)
			.then(function(elements) {
				return elements[0];
			});
	}
};

/**
 *
 */
function _setInputValue(element, value) {
	return element.clear()
		.then(function() {
			return element.sendKeys(value);
		});
}

/**
 *
 */
function _setSelectValue(element, value) {
	UT.log("Select option: " + JSON.stringify(UT.SEL.$$Attr("value", value)));
	return element.click()
		.then(function() {
			return UT.sleep(50);
		})
		.then(function() {
			// TODO: NOT SUPPORTED BY EDGE 
			// https://dev.windows.com/en-us/microsoft-edge/platform/status/webdriver/details/
			return element.findElement(UT.SEL.$$Attr("value", value));
		})
		.then(function(optionElement) {
			return optionElement.click();
		});
}

/**
 *
 */
function _findElement(selector, parent) {
	var parentStep;

	// If selector is a webelement already, we resolve immediately
	// this is just so all functions using _findElement can be used with a webelement or a selector
	if (_isWebElement(selector)) {
		return UT.resolve(selector);
	}

	if (parent) {
		if (_isWebElement(parent)) {
			parentStep = UT.resolve(parent);
		} else {
			parentStep = driver.Browser().findElement(parent);
		}
	} else {
		parentStep = UT.resolve(driver.Browser());
	}
	return parentStep.then(function(parentElement) {
		return parentElement.findElement(selector);
	});
}

function _isWebElement(selector) {
	if (selector.driver_) {
		return true;
	}
	return false;
}