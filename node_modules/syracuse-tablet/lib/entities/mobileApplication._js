"use strict";

// Testcase: /syracuse-collaboration/test/server/mobileApplicationTest._js

var globals = require('streamline-runtime').globals;
var helpers = require('@sage/syracuse-core').helpers;
var forEachKey = helpers.object.forEachKey;
var adminHelper = require('@sage/syracuse-lib/src/collaboration/helpers').AdminHelper;
var locale = require('streamline-locale');
var sdataStatelessWC = require("syracuse-tablet/lib/sdataStatelessWC");

var tracer = null;
//var tracer = console.log;

exports.entity = {
	$titleTemplate: "Mobile application",
	$descriptionTemplate: "Mobile application definition",
	$valueTemplate: "{title}",
	$allowFactory: true,
	$factoryExcludes: ["description", "title", "roles", "endpoints", "homeDashboard", "versionNumber"],
	$properties: {
		title: {
			$title: "Title",
			$linksToDetails: true,
			$isLocalized: true,
			$isMandatory: true
		},
		description: {
			$title: "Description",
			$isLocalized: true,
			$isMandatory: true
		},
		applicationName: {
			$title: "Mobile application name",
			$isMandatory: true,
			$isUnique: true
		},
		iconName: {
			$title: "Icon",
			$isMandatory: false
		},
		Gadget: {
			$isMandatory: false,
			$isNullable: true,
			$title: "Use a gadget",
			$type: "boolean",
			$default: false
		},
		onlineOnly: {
			$isMandatory: false,
			$isNullable: true,
			$title: "Online only",
			$type: "boolean",
			$default: false
		},
		versionNumber: {
			$title: "Version",
			$isMandatory: false,
			$type: "string",
			$default: "1",
			$isHidden: true,
			$isReadOnly: true,
		},
	},
	$relations: {
		roles: {
			$type: "roles",
			$title: "Roles",
			$inv: "mobileApplications",
			$isComputed: true
		},
		endPoints: {
			$type: "endPoints",
			$title: "Endpoints"
		},
		homeDashboard: {
			$title: "Home dashboard",
			$type: "mobileDashboard",
			$isMandatory: function(_, instance) {
				return (!instance.Gadget(_));
			},
			$isDefined: function(_, instance) {
				return (!instance.Gadget(_));
			}
		},
		gadget: {
			$type: "mobileGadget",
			$title: "Gadget",
			$isMandatory: function(_, instance) {
				return (instance.Gadget(_));
			},
			$isDefined: function(_, instance) {
				return (instance.Gadget(_));
			}
		},
		representations: {
			$type: "mobileRepresentations",
			$title: "Representations",
			$isChild: true,
			$isPersistent: false
		}
	},
	$searchIndex: {
		$fields: ["title", "description", "applicationName"]
	},
	$services: {
		applicationRepresentations: {
			$method: "POST",
			$isMethod: true,
			$overridesReply: true,
			$title: "Find used representations",
			$facets: ["$edit"],
			$execute: function(_, context, instance) {
				var applicationData = {};

				var helpers;
				var cacheInfo = _getCacheInfo(_, instance);
				instance.endPoints(_).toArray(_).forEach_(_, function(_, ep) {
					helpers = _getHelpers(_, instance, context, ep);
					helpers.cacheInfo = cacheInfo;

					_gatherMetaData(_, instance, helpers, applicationData);
				});

				_updateRepresentations(_, instance, applicationData);

				instance.$diagnoses.push({
					$severity: "info",
					$message: locale.format(module, "reprsCollected", [Object.keys(applicationData.$pages).length])
				});
				return instance;
			}
		},

		/**
		 * return all mobile applications assigned with the current role
		 */
		availableApplications: {
			$isHidden: true,
			$method: "GET",
			$isMethod: false,
			$title: "Get available applications",
			$overridesReply: true,
			$execute: function(_, context) {
				var self = this;
				var $resources = [];

				var apps;
				var db = context.db;
				apps = db.fetchInstances(_, db.getEntity(_, "mobileApplication"), {});

				apps.forEach_(_, function(_, mobileApplication) {
					var app = _getApplicationInfo(_, context, mobileApplication);
					$resources.push(app);
				});

				context.reply(_, 200, {
					$resources: $resources
				});
			}
		},

		applicationMetaData: {
			$isHidden: true,
			$method: "GET",
			$isMethod: true,
			$title: "Get application meta data",
			$overridesReply: true,
			$execute: function(_, context, instance) {
				var applicationData = {};

				var cacheInfo = _getCacheInfo(_, instance);
				var endpoints = instance.endPoints(_).toArray(_);

				if (endpoints.length <= 0) {
					var up = globals && globals.context && globals.context.session && globals.context.session.getUserProfile(_);
					if (up) {
						endpoints = up.endpoints(_).toArray(_);
					}
				}
				var endpoint = context && context.parameters && context.parameters.endpoint;
				endpoints.forEach_(_, function(_, ep) {
					var curname = _getEndpointName(_, ep);
					// Only scan meta data for given endpoint or for all if no endpoint is given
					if (!endpoint || endpoint === curname) {
						helpers = _getHelpers(_, instance, context, ep);
						// eventually get role uuid as parameter
						helpers.role = context && context.parameters && context.parameters.role;
						helpers.cacheInfo = cacheInfo;

						if (instance.onlineOnly(_)) {
							// For online only app, we just return the header
							applicationData.$application = _getApplicationInfo(_, helpers.context, instance);
						} else {
							// For offline capable apps, we collect the full meta data tree
							_gatherMetaData(_, instance, helpers, applicationData);
						}
					}
				});

				var errors = Object.keys(applicationData.$pageErrors || {});
				if (errors.length > 0) {
					_sendError(_, context, 400,
						locale.format(module, "errorInvalidApp"),
						locale.format(module, "errorInvalidPages", ["\n" + Object.keys(applicationData.$pageErrors).join("\n")]));
				} else {
					// All is fine
					context.reply(_, 200, applicationData);
				}
			}
		},
		updateVersion: {
			$method: "POST",
			$isMethod: true,
			$overridesReply: false,
			$title: "Update version",
			$facets: ["$edit"],
			$execute: function(_, context, instance) {
				_incVersion(_, instance);
				instance.$diagnoses.push({
					$severity: "info",
					$message: locale.format(module, "versionNumber")
				});
				instance.save(_);
				return instance;
			}
		},
		updateVersions: {
			$method: "GET",
			$isMethod: false,
			$title: "Update versions",
			$facets: ["$query"],
			$overridesReply: true,
			$execute: function(_, context) {
				var self = this;

				var apps;
				var db = context.db;
				apps = db.fetchInstances(_, db.getEntity(_, "mobileApplication"), {});

				apps.forEach_(_, function(_, app) {
					_incVersion(_, app);
					app.save(_);
				});
				context.reply(_, 200, {
					$diagnoses: [{
						$severity: "info",
						$message: locale.format(module, "versionNumber")
					}],
				});
			}
		}

	},
	$functions: {
		$serialize: function(_) {
			var self = this;
			var db = adminHelper.getCollaborationOrm(_);
			var mobileDashboard = db.getEntity(_, "mobileDashboard");

			var result = self._internalSerialize(_);
			if (self.homeDashboard(_)) {
				var dashboardData = db.fetchInstance(_, mobileDashboard, self.homeDashboard(_).$uuid);
				result.$homeDashboard = dashboardData.$serialize(_);
			}
			return result;
		}
	},
	$events: {
		$beforeSave: [

			function(_, instance) {
				_incVersion(_, instance);
			}
		]
	}
};

function _incVersion(_, instance) {
	var version = +instance.versionNumber(_);
	if (!version || version <= 0) {
		version = 1;
	} else {
		version++;
	}
	instance.versionNumber(_, "" + version);
}

function _sendError(_, context, status, msg, stack) {
	var diags = [{
		"$severity": "error",
		"$message": msg,
		"$stackTrace": stack
	}];
	context.reply(_, status, {
		"$diagnoses": diags
	});
};

function _getEndpointName(_, endpoint) {
	return endpoint.application(_) + "." + endpoint.contract(_) + "." + endpoint.dataset(_);
}

function _getHelpers(_, instance, context, endpoint) {
	var helpers;
	var helpers = {
		context: context,
		application: endpoint.application(_),
		contract: endpoint.contract(_),
		dataset: endpoint.dataset(_),
		endpointName: _getEndpointName(_, endpoint),
		pageEntity: context.model.getEntity(_, "page"),
		mobileApplication: instance
	};

	// to make pageEntity.pageContent work when executing a method with POST
	helpers.context.instanceId = helpers.context.instanceId || instance.$uuid;
	return helpers;
}

function _getCacheInfo(_, instance) {
	var cacheInfo = {};
	instance.representations(_).toArray(_).forEach_(_, function(_, rep) {
		var key = rep.name(_) + "." + rep.facet(_);
		cacheInfo[key] = {
			cacheType: rep.cacheType(_),
			filter: rep.filter(_)
		};
	});
	return cacheInfo;
}

function _getApplicationInfo(_, context, mobileApplication) {
	var endpoints = [];
	mobileApplication.endPoints(_).toArray(_).forEach_(_, function(_, ep) {
		endpoints.push({
			application: ep.application(_),
			contract: ep.contract(_),
			dataset: ep.dataset(_),
			description: ep.description(_)
		});
	});

	var roles = [];
	mobileApplication.roles(_).toArray(_).forEach_(_, function(_, role) {
		roles.push({
			code: role.code(_),
			description: role.description(_)
		});
	});

	var db = context.db;
	var mobileDashboard = db.getEntity(_, "mobileDashboard");
	var dashboardData = db.fetchInstance(_, mobileDashboard, mobileApplication.homeDashboard(_).$uuid);

	var $metaDataUrl = context.baseUrl + "/mobileApplications('" + mobileApplication.$uuid + "')/$service/applicationMetaData";
	return {
		$metaDataUrl: $metaDataUrl,
		$uuid: mobileApplication.$uuid,
		applicationName: mobileApplication.applicationName(_),
		title: mobileApplication.title(_),
		iconName: mobileApplication.iconName(_),
		description: mobileApplication.description(_),
		$homeDashboard: dashboardData.$serialize(_),
		roles: roles,
		endpoints: endpoints,
		versionNumber: mobileApplication.versionNumber(_),
		onlineOnly: mobileApplication.onlineOnly(_)
	};
}

function _gatherMetaData(_, instance, helpers, applicationData) {

	applicationData.$application = _getApplicationInfo(_, helpers.context, instance);

	applicationData.$dashboards = {};
	applicationData.$gadgets = {};
	applicationData.$pages = {};
	applicationData.$pageErrors = {};

	tracer && tracer("Home dashboard:" + instance.homeDashboard(_).dashboardName(_));
	_processDashboard(_,
		helpers,
		applicationData,
		instance.homeDashboard(_)
	);

	tracer && tracer("Walk representations");
	_traversePages(_,
		helpers,
		applicationData);
}

function _processDashboard(_, helpers, applicationData, dashboard) {
	var dashboardName = dashboard.dashboardName(_);
	if (applicationData.$dashboards[dashboardName]) {
		return;
	}
	tracer && tracer("dashboard:" + dashboardName);
	var output = dashboard.serializeInstance(_);

	var page = _getDashboardPage(_, helpers, dashboard);

	applicationData.$pages["syracuse.collaboration.syracuse." + dashboardName] = {
		$page: {
			$article: page && page.$article,
			$views: page && page.$views
		}
	}

	var gadgets = [];
	dashboard.vignettes(_).toArray(_).forEach_(_, function(_, vignette) {
		var gadget = vignette.gadget(_);
		if (gadget) {
			gadgets.push(gadget);
		}
	});
	tracer && tracer("add dashboard: " + dashboardName);
	applicationData.$dashboards[dashboardName] = output;

	gadgets.forEach_(_, function(_, gadget) {
		_processGadget(_, helpers, applicationData, gadget);
	});
}

function _getDashboardPage(_, helpers, dashboard) {
	var page;
	try {
		var opts = {
			application: "syracuse",
			contract: "collaboration",
			endpoint: "syracuse",
			representation: dashboard.dashboardName(_),
			facet: "$mobileDashboard",
			device: "mobile",
			protoInPage: false
		};
		if (helpers.role) {
			opts.role = helpers.role;
		}
		// May have been set to false when dashboard article is fetched so ensure
		// it's put to true again since we share the context among the process
		_checkFetchProto(helpers, true)
		page = helpers.pageEntity.pageContent(_, helpers.context, opts);
		return page;
	} catch (e) {
		throw new Error("Unable to load dashboard page: " + opts.representation, e);
	}
}

function _processGadget(_, helpers, applicationData, gadget) {
	if (applicationData.$gadgets[gadget.$uuid]) {
		return;
	}

	var gt = gadget.gadgetType(_);
	tracer && tracer("gadget:" + gadget.title(_) + ":" + gt);
	var data = {
		$type: gt,
		$title: gadget.title(_),
		$description: gadget.description(_),
		icon: gadget.icon(_)
	};

	data["parameters"] = {};
	gadget.parameters(_).toArray(_).forEach_(_, function(_, p) {
		data["parameters"][p.name(_)] = {
			"title": p.title(_),
			"value": p.value(_)
		};
	});

	var endpoint;
	var fixedEp = false;
	if (gadget.endpoint(_)) {
		fixedEp = true;
		endpoint = _getEndpointName(_, gadget.endpoint(_));
	} else {
		endpoint = helpers.endpointName;
	}

	switch (gt) {
		case "$dashboard":
			var dashboardName = gadget.mobileDashboard(_);
			var dashboard = _readDashboard(_, helpers, dashboardName);
			if (dashboard) {
				data["dashboardName"] = dashboardName;
				_processDashboard(_, helpers, applicationData, dashboard);
			} else {
				data = null;
			}
			break;

		case "$representation":
			var action = gadget.action(_);
			var entity = gadget.entity(_);
			var representation = gadget.representation(_);
			var facet = _getFacetForAction(action);
			var keyParameter = gadget.keyParameter(_);
			data["entity"] = entity;
			data["action"] = action;
			data["representation"] = representation;
			data["facet"] = facet;
			data["keyParameter"] = keyParameter;
			if (fixedEp) {
				data["endpoint"] = endpoint;
			}
			var pageName = endpoint + "." + representation + "." + facet;
			_processPage(_, helpers, applicationData, pageName);
			break;

		case "$process":
			data["processName"] = gadget.processName(_);
			data["processLeg"] = gadget.processLeg(_);
			data["processMenu"] = gadget.processMenu(_);
			break;

		case "$request":
			var requestName = gadget.requestName(_);
			var requestLevel = gadget.requestLevel(_);
			var representation = "QUERY~" + requestName + (requestLevel ? "~" + requestLevel : "");
			var facet = "$query";
			data["requestName"] = requestName;
			data["requestLevel"] = requestLevel;
			data["action"] = "$query";
			data["representation"] = representation;
			data["facet"] = facet;
			if (fixedEp) {
				data["endpoint"] = endpoint;
			}

			var pageName = endpoint + "." + representation + "." + facet;
			_processPage(_, helpers, applicationData, pageName);
			break;

		case "$stats":
			var statsName = gadget.statName(_);
			var representation = "STATS~" + statsName;
			var facet = "$cube";
			data["statName"] = statsName;
			data["action"] = "$query";
			data["representation"] = representation;
			data["facet"] = facet;
			if (fixedEp) {
				data["endpoint"] = endpoint;
			}

			var pageName = endpoint + "." + representation + "." + facet;
			_processPage(_, helpers, applicationData, pageName);
			break;

		case "$external":
			data["externalUrl"] = gadget.externalUrl(_);
			break;

		default:
			throw new Error("Unknown gadget type: " + gt);
			data = null;
			break;
	}
	if (data) {
		applicationData.$gadgets[gadget.$uuid] = data;
	}
}

function _readDashboard(_, helpers, dashboardName) {
	var dashboard = helpers.context.db.fetchInstance(_, helpers.context.db.getEntity(_, "mobileDashboard", "$details"), {
		jsonWhere: {
			dashboardName: dashboardName
		}
	});
	return dashboard;
}

function _getFacetForAction(action) {
	return action;
	//return (action === "$create" ? "$edit" : action);
}

function _processPage(_, helpers, applicationData, pageName) {
	if (applicationData.$pages[pageName]) {
		return;
	}

	var repr = pageName.split(".");
	var representation = repr[3];
	var facet = repr[4];

	tracer && tracer("Page: " + pageName);

	var x3Facet = facet === "$create" ? "$edit" : facet;
	var page;
	var pageArticle;
	try {
		var opts = {
			application: repr[0],
			contract: repr[1],
			endpoint: repr[2],
			representation: representation,
			facet: x3Facet,
			device: "mobile",
			protoInPage: true
		};
		if (helpers.role) {
			opts.role = helpers.role;
		}
		tracer && tracer(opts);
		// May have been set to false when dashboard article is fetched so ensure
		// it's put to true again since we share the context among the process
		_checkFetchProto(helpers, true)
		page = helpers.pageEntity.pageContent(_, helpers.context, opts);
		if (!page.$prototype) {
			// Fdb - I got a bug with null $prototype
			throw new Error("No prototype available for this page")
		}
		// If facet is $create, we need to do it again to retrieve the "real" article for create facet
		if (facet === "$create") {
			opts.protoInPage = false;
			opts.facet = facet;
			// May have been set to false when dashboard article is fetched so ensure
			// it's put to true again since we share the context among the process
			_checkFetchProto(helpers, true)
			pageArticle = helpers.pageEntity.pageContent(_, helpers.context, opts);
			page.$article = pageArticle && pageArticle.$article || page.$article;
		}
	} catch (e) {
		tracer && tracer(e);
		applicationData.$pageErrors[pageName] = e;
		return;
	}

	// For syracuse reps, there is no inlined proto.
	// add it here (Used for testcases only currently)
	if (typeof page.$prototype === "string") {
		var proto;
		if (helpers.applicationName === "syracuse") {
			proto = helpers.context.db.getEntity(_, representation).getPrototype(_, representation, facet);
		}
		if (!proto) {
			applicationData.$pageErrors[pageName] = {};
			return;
		}
		page.$prototype = proto;
	}
	//page.$prototype = sdataStateless.transformProto(_, page.$prototype, representation, facet, x3Facet, repr[2]);
	page.$prototype = sdataStatelessWC.transformProto(_, page.$prototype, representation, facet, x3Facet, repr[2]);
	applicationData.$pages[pageName] = {
		"$notParsedYet": page
	};
}

function _traversePages(_, helpers, applicationData) {
	var $pages = applicationData.$pages;
	var done = false;
	while (!done) {
		done = true;
		Object.keys(applicationData.$pages).forEach_(_, function(_, pageName) {
			var page = $pages[pageName];
			if (page.$notParsedYet) { // only traverse each page once!
				page = page.$notParsedYet;
				var cache = _getPageCacheSettings(_, helpers, applicationData, pageName);

				applicationData.$pages[pageName] = {
					$page: page,
					$cache: cache
				};
				if (pageName.indexOf(".QUERY~") > -1) {
					// queries seem to contain some invalid links, so do not parse the proto for now
					// since we do not support links on queries right now
				} else {
					_parseProto(_, helpers, applicationData, page.$prototype, pageName);
				}
				done = false;
			}
		});
	}
}

function _parseProto(_, helpers, applicationData, prototype, pageName, allowedLinks) {
	var repr = pageName.split(".");
	var representation = repr[3];
	var facet = repr[4];
	var $links;

	tracer && tracer("Prototype: " + pageName);

	// Handle top level links $create, $delete, ...
	$links = prototype.$links;
	if ($links) {
		_parseLinks(_, helpers, applicationData, $links, allowedLinks, prototype, pageName);
	}
	$links = prototype.$properties && prototype.$properties.$resources && prototype.$properties.$resources.$item && prototype.$properties.$resources.$item.$links;
	if ($links) {
		_parseLinks(_, helpers, applicationData, $links, allowedLinks, prototype.$properties.$resources.$item, pageName);
	}
	if (prototype.$properties) {
		_parseProperties(_, helpers, applicationData, prototype.$properties, pageName);
	}
}

function _parseProperties(_, helpers, applicationData, properties, pageName) {
	var repr = pageName.split(".");
	var representation = repr[3];
	var facet = repr[4];

	var allowedLinks = facet === "$details" ? ["$details", "$summary"] : ["$lookup"];

	Object.keys(properties).forEach_(_, function(_, propName) {
		var prop = properties[propName];

		switch (prop.$type) {
			case "application/x-array":
				if (prop.$item.$type === "application/x-reference") {
					// TODO:
				} else {
					_parseProto(_, helpers, applicationData, prop.$item, pageName, allowedLinks);
				}
				break;
			case "application/x-reference":
				_parseProto(_, helpers, applicationData, prop.$item, pageName, allowedLinks);
				break;
		}
	});
}

function _parseLinks(_, helpers, applicationData, links, allowedLinks, prototype, pageName) {
	var repr = pageName.split(".");
	var representation = repr[3];
	var facet = repr[4];
	var endpoint = repr.slice(0, 3).join(".");

	Object.keys(links).forEach_(_, function(_, linkName) {
		if (!allowedLinks || allowedLinks.indexOf(linkName) > -1) { // If a list of allowed links is given, ignore other ones!
			var link = links[linkName];
			var url = link.$url;
			if (link.$isHidden) {
				return;
			}
			tracer && tracer("Link: " + url);

			if (url.indexOf("$mobileDashboards") > -1) {
				var dashboardName = _getQueryParameter(url, "dashboard");
				var dashboard = _readDashboard(_, helpers, dashboardName);
				if (dashboard) {
					_processDashboard(_, helpers, applicationData, dashboard);
				}
			} else {
				var representation = _getQueryParameter(url, "representation");
				if (url.indexOf("{$baseUrl}") != 0 || representation == null) {
					tracer && tracer("Bad url: " + url);
				} else {
					representation = representation && representation.replace(/\{(.*?)\}/g, function(match, prop) {
						var value = prototype[prop];
						return value || "";
					});

					var rep = representation.split(".");
					_processPage(_, helpers, applicationData, endpoint + "." + rep[0] + "." + rep[1]);
				}
			}
		}
	});
}

function _getQueryParameter(url, parameter) {
	var m = parameter + "=";
	var i = url.indexOf(m);
	if (i < 0) {
		return null;
	}
	url = url.substr(i + m.length);
	i = url.indexOf("&");
	if (i < 0) {
		return url;
	}
	url = url.substr(0, i);
	return url;
}

function _updateRepresentations(_, instance, applicationData) {
	var db = adminHelper.getCollaborationOrm(_);
	var entity = db.model.getEntity(_, "mobileRepresentation");
	var old = {};
	instance.representations(_).toArray(_).forEach_(_, function(_, repr) {
		var key = repr.name(_) + "." + repr.facet("_");
		old[key] = {
			cacheType: repr.cacheType(_),
			filter: repr.filter(_)
		};
	});
	instance.representations(_).reset(_);

	Object.keys(applicationData.$pages).forEach_(_, function(_, pageName) {
		var tmp = pageName.split(".");
		var rep = tmp.slice(0, 4).join(".");
		var facet = tmp[4];

		var repr = instance.representations(_).add();
		repr.name(_, rep);
		repr.facet(_, facet);
		var oldData = old[pageName];
		if (oldData) {
			repr.cacheType(_, oldData.cacheType);
			repr.filter(_, oldData.filter);
		}
	});
}

function _getPageCacheSettings(_, helpers, applicationData, pageName) {
	var cacheInfo = helpers.cacheInfo[pageName];
	if (!cacheInfo) {
		cacheInfo = {
			cacheType: "$auto",
			filter: null
		};
	}
	return cacheInfo;
}

function _checkFetchProto(helpers, value) {
	if (helpers.context && helpers.context && helpers.context.parameters) {
		helpers.context.parameters.fetchPrototype = value ? "true" : "false";
	}
}