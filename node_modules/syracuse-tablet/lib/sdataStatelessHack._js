"use strict";

var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;

/*
 *
 * This dispatcher maps client requests <-> x3 responses in terms of converting stateful data
 * structures to stateless ones needed by the tablet client.
 *
 * https://github.com/Sage-ERP-X3/platform/wiki/Stateless-mode-draft-for-tablet-client
 *
 */

var x3pool = require("syracuse-x3/lib/pool");
var helpers = require("syracuse-core/lib/helpers");
var _mobileProtocolUrlSeg = "mobile1";

var tracer = null;
//var tracer = console.log;

function InterceptResponse() {
	this.chunks = [];
	this.status = 0;
	this.head = null;
};

InterceptResponse.prototype = {
	writeHead: function(status, head) {
		this.head = head;
		this.status = status;
	},

	write: function(_, data, enc) {
		this.chunks.push(typeof data === "string" ? new Buffer(data, enc || "utf8") : data);
	},

	toString: function(enc) {
		var data = this.chunks.map(function(chunk) {
			return chunk.toString(enc || "utf8");
		}).join("");
		return data;
	},
	end: function() {}
};

/*
 * Access to prototypes
 */
exports.prototypes = function(_, context, name, id) {
	var apiPrefix = context.request.session.apiPrefix;
	var savedResponse = context.response;
	try {
		if (context.method.toLowerCase() !== "get") {
			throw new Error("Only GET allowed for prototype request");
		}

		var repr = /\$prototypes\('(.*?)\.(.*?)'\)/.exec(context.request.url);
		var facet = repr && repr[2];
		var x3Facet;
		repr = repr && repr[1];
		if (!repr) {
			throw context.badRequest("Cannot locate representation");
		}
		if (!facet) {
			throw context.badRequest("Cannot locate facet");
		}

		if (facet === "$create") {
			x3Facet = "$edit";
			context.url = context.url.replace("('" + repr + "." + facet + "')", "('" + repr + "." + x3Facet + "')");
			context.request.url = context.request.url.replace("('" + repr + "." + facet + "')", "('" + repr + "." + x3Facet + "')");
		}

		context.url = _urlSetSData(context.url, apiPrefix);
		context.request.url = _urlSetSData(context.request.url, apiPrefix);

		var intercept = new InterceptResponse();
		context.response = intercept;
		x3pool.send(_, context);
		context.response = savedResponse;

		var proto = intercept.toString();
		if (proto && proto.length > 0) {
			proto = JSON.parse(proto);
			proto = exports.transformProto(_, proto, repr, facet, x3Facet, apiPrefix);
		}

		context.reply(_, intercept.status, proto, intercept.head);
	} finally {
		context.response = savedResponse;
	}
};

/*
 * Access to working copies
 * This is contradictory in stateless mode
 */
exports.workingCopies = function(_, context, name, id) {
	tracer && tracer("Working copies url: " + context.url);
	throw context.badRequest("Using working copies in stateless mode is contradictory");
};

/*
 * This would handle URLs like
 * http://localhost:8124/sdata/x3/erp/SUPERV/$service...
 * which seem to be not supported today.
 * Usually there is a class segment in the URL before $service like
 * http://localhost:8124/sdata/x3/erp/SUPERV/ACTIVE/$service...
 * But these kind of URLs are handled by the "walk" handler and directly sent to X3
 *
 */
exports.service = function(_, context, name, id) {
	tracer && tracer("Service url: " + context.url);
	// This is more like a fallback since ending up here is the result of an invalid URL
	_handleUrl(_, context, name, id);
};

/*
 * Handle any kind of non special urls
 */
exports.walk = function(_, context, name, id) {
	tracer && tracer("Walk url: " + context.url);
	_handleUrl(_, context, name, id);
};

exports.transformProto = function(_, proto, repr, newFacet, oldFacet, dataset, apiPrefix) {
	tracer && tracer("Transforming proto: " + repr + " " + newFacet + "->" + oldFacet);
	if (oldFacet && newFacet) {
		if (proto.$url) {
			proto.$url = proto.$url.replace("." + oldFacet, "." + newFacet);
		}
		if (proto.$type) {
			proto.$type = proto.$type.replace("." + oldFacet, "." + newFacet);
		}
	}
	if (proto.$baseUrl) {
		proto.$baseUrl = _urlSetMobile(proto.$baseUrl, apiPrefix);
	}

	_transformLinks(proto, apiPrefix);
	_transformLazyPropertyUrls(_, proto, repr, newFacet, oldFacet, dataset);

	var actions = proto.$actions;
	if (actions) {
		var links = proto.$links = proto.$links || {};
		_transformActions(actions, links, newFacet, repr, proto.$url);
		delete proto["$actions"];
	}
	return proto;
};

function _transformLinks(proto, apiPrefix) {
	var links = proto.$links;
	if (links) {
		Object.keys(links).forEach(function(key) {
			var link = links[key];
			if (key === "$delete") {
				link.$method = "DELETE";
			} else if (key === "$edit") {
				link.$method = "GET";
			} else if (key === "$create") {
				link.$method = "GET";
			} else {
				if (link.$method !== "DELETE") {
					link.$method = "GET";
				}
			}

			if (link.$url) {
				if (link.$url.indexOf("/$workingCopies?") > -1) { // create or update
					if (link.$url.indexOf("/$template/") > -1) { // create
						// switch facet in case of create
						link.$url = link.$url.replace("/$workingCopies?", "?").replace(".$edit", ".$create");
					}
					// switch to stateless
					link.$url = link.$url.replace("/$workingCopies?", "?");
				}

				link.$url = _urlSetMobile(link.$url, apiPrefix);
			}
		});
	}
	if (proto.$properties) {
		Object.keys(proto.$properties).forEach(function(prop) {
			var p = proto.$properties[prop];
			if (p.$item) {
				_transformLinks(p.$item, apiPrefix);
			}
		});
	}
}

function _transformActions(actions, links, facet, representation, instanceUrl) {
	var res = {};
	Object.keys(actions).forEach(function(key) {
		var action = actions[key];
		var link;
		var url;
		var method;
		var entity;

		if (instanceUrl) {
			try {
				// Get entity name
				entity = /\/(\w*?)\W+/.exec(instanceUrl)[1];
			} catch (e) {}
		}

		url = null;
		link = null;

		switch (key) {
			case "$save":
				if (facet === "$create") {
					method = "POST";
					url = entity && "{$baseUrl}/" + entity + "?representation=" + representation + "." + facet;
				} else {
					method = "PUT";
					url = entity && "{$baseUrl}/" + entity + "('{$key}')" + "?representation=" + representation + "." + facet;
				}
				link = {
					$title: action.$title,
					$isHidden: action.$isHidden,
					$isDisabled: action.$isDisabled,
					$isAction: true,
					$method: method
				};
				break;
			case "$abort":
				// do not send $abort at all in stateless mode since there is nothing to abort
				break;
			default:
				if (facet === "$create") {
					method = "POST";
					url = entity && "{$baseUrl}/" + entity + "/$services/" + key + "?representation=" + representation + "." + facet;
				} else {
					method = "POST";
					url = entity && "{$baseUrl}/" + entity + "('{$key}')/$services/" + key + "?representation=" + representation + "." + facet;
				}
				link = {
					$title: action.$title,
					$isHidden: action.$isHidden,
					$isDisabled: action.$isDisabled,
					$isAction: true,
					$method: method
				};
				break;
		}

		if (link) {
			if (action && action.$parameters) {
				link.$parameters = action.$parameters;
			}

			if (url) {
				link.$url = url;
			}
			res[key] = links[key] = link;
		}
	});
}
/**
 * Replace $url field's properties in $edit facet by the $url of $details one
 * FYI: Temporarily to fix the bug for images in edit
 * 		url points to the workingcopy {$instanceUrl}/PBLOB
 * 		mobile client needs /BDOC(..) url
 */
function _transformLazyPropertyUrls(_, proto, repr, newFacet, oldFacet, dataset, detailsProto) {
	if (!(oldFacet === "$edit" || newFacet === "$edit")) {
		return;
	}
	if (!proto) {
		return;
	}
	if (!proto.$properties) {
		return;
	}
	// guess dataset from type
	if (!dataset) {
		dataset = proto.$baseType && proto.$baseType.split(".");
		dataset = dataset && dataset[dataset.length - 1];
	}
	if (!dataset) {
		return;
	}
	//	console.log(require("util").inspect(proto.$properties, null, {depth:5}));
	var protoDetails = detailsProto; // may be null on first level

	var getProto = function(_, repr) {
		var ep;
		var entity;
		var model;
		var protoDet;
		try {
			if (!ep) {
				var adminOrm = adminHelper.getCollaborationOrm(_);
				ep = adminOrm.fetchInstance(_, adminOrm.model.getEntity(_, "endPoint"), {
					jsonWhere: {
						dataset: dataset
					}
				});
			}
			if (!model && ep) {
				model = ep.getModel(_, false);
			}
			if (!entity && model) {
				model.resetCache();
				entity = model.getEntity(_, repr, "$details", "desktop");
			}
			if (entity) {
				protoDet = entity.getPrototype(_, repr, "$details", "desktop");
			}
		} catch (e) {
			// We silently fail to be compatible with representations that were working in V7
			// We may encounter representations that only have an edit facet but this process might also
			// read the details facet which may cause an error since it's not enabled
		}
		return protoDet;
	};

	Object.keys(proto.$properties).forEach_(_, function(_, key) {
		var prop = proto.$properties[key];

		if (prop.$url) {
			if (!protoDetails) {
				protoDetails = getProto(_, repr);
			}

			if (protoDetails && protoDetails.$properties && protoDetails.$properties[key] && protoDetails.$properties[key].$url) {
				prop.$url = protoDetails.$properties[key].$url;
			}
		}

		if (prop.$item) {
			if (!protoDetails) {
				protoDetails = getProto(_, repr);
			}
			var details$Item = protoDetails && protoDetails.$properties && protoDetails.$properties[key] && protoDetails.$properties[key].$item;
			if (details$Item) {
				_transformLazyPropertyUrls(_, prop.$item, repr, newFacet, oldFacet, dataset, details$Item);
			}
		}
	});
}

function _handleUrl(_, context, name, id) {
	var url = context.request.url;
	var method = context.method.toLowerCase();
	var savedResponse = context.response;
	var intercept;
	var status;
	var data;
	var facet;
	var newFacet;
	var representation;
	var responsTime = null; //{start: new Date().getTime()};
	try {
		var apiPrefix = context.request.session.apiPrefix;
		if (context.parameters && context.parameters.representation) {
			representation = context.parameters.representation.split(".");
			facet = representation[1];
			representation = representation[0];
			newFacet = facet;
		}

		context.url = _urlSetSData(context.url, apiPrefix);
		context.request.url = _urlSetSData(context.request.url, apiPrefix);

		if (url.indexOf("/$services/") > -1 && method === "get") {
			// stateless $service request, no need to modify
			// http://localhost:8124/mobile1/x3/erp/GX3APP/BPCUSTOMER('001')/$services/BPCLOCK?representation=BPCUSTOMERM.$query&PACTION=1
			if (newFacet === "$create") {
				facet = "$edit";
				context.parameters.representation = context.parameters.representation.replace(".$create", ".$edit");
				context.url = context.url.replace(".$create", ".$edit");
				context.request.url = context.request.url.replace(".$create", ".$edit");
			}

			intercept = new InterceptResponse();
			context.response = intercept;
			if (responsTime) responsTime.send = new Date().getTime();
			x3pool.send(_, context);
			if (responsTime) responsTime.x3response = new Date().getTime();
			data = intercept.toString();
			if (data && data.length > 0) {
				data = JSON.parse(data);
				data = _transformPayload(data, newFacet, facet, representation, apiPrefix);
			}
			status = intercept.status;
			context.response = savedResponse;
			if (responsTime) responsTime.reply = new Date().getTime();
			context.reply(_, status, data, intercept.head);
		} else if (url.indexOf("/$services/") > -1 && method !== "get") {
			// stateful action that is executed as $service
			if (responsTime) responsTime.send = new Date().getTime();
			data = _handleStatefulService(_, context, name, id);
			if (responsTime) responsTime.x3response = new Date().getTime();
			status = 200;
			context.response = savedResponse;
			if (responsTime) responsTime.reply = new Date().getTime();
			context.reply(_, status, data.data, data.head);
		} else {
			if (newFacet === "$create") {
				facet = "$edit";
				context.parameters.representation = context.parameters.representation.replace(".$create", ".$edit");
				context.url = context.url.replace(".$create", ".$edit");
				context.request.url = context.request.url.replace(".$create", ".$edit");
			}
			if (method === "delete") {
				var uuid = helpers.uuid.generate();
				context.url = context.url + "&trackingId=" + uuid;
				context.request.url = context.request.url + "&trackingId=" + uuid;
			}
			intercept = new InterceptResponse();
			context.response = intercept;

			if (responsTime) responsTime.send = new Date().getTime();
			x3pool.send(_, context);
			if (responsTime) responsTime.x3response = new Date().getTime();
			var contentType = intercept && intercept.head && intercept.head["content-type"] && intercept.head["content-type"];
			if (contentType && contentType.indexOf("application/json") < 0) {
				data = intercept.toString();
				context.response = savedResponse;
				status = intercept.status;
				context.response.writeHead(status, intercept.head);
				intercept.chunks.forEach_(_, function(_, chunk) {
					context.response.write(_, chunk);
				});
				if (responsTime) responsTime.reply = new Date().getTime();
				context.response.end();
			} else {
				data = intercept.toString();
				if (data && data.length > 0) {
					data = JSON.parse(data);
					data = _transformPayload(data, newFacet, facet, representation, apiPrefix);
				}

				status = intercept.status;
				context.response = savedResponse;
				if (responsTime) responsTime.reply = new Date().getTime();
				context.reply(_, status, data, intercept.head);
			}
		}
		if (responsTime) {
			tracer && tracer("request=" + name, "send=" + (responsTime.send - responsTime.start), "x3response=" + (responsTime.x3response - responsTime.send), "reply=" + (responsTime.reply - responsTime.x3response), "elapsed=" + (responsTime.reply - responsTime.start));
		}
	} finally {
		context.response = savedResponse;
	}
}

/*
 * Handles stateful services ($actions in WC mode)
 *
 * "{$baseUrl}/AQTCRUD/$service/WADD_LIG44444444?representation=AQTCRUD.$create"
 * "{$baseUrl}/AQTCRUD('10')/$service/WADD_LIG44444444?representation=AQTCRUD.$edit"
 *
 */
function _handleStatefulService(_, context, name, id) {
	try {
		tracer && tracer("Statful service: " + context.request.url);
		var apiPrefix = context.request.session.apiPrefix;

		var representation = context.parameters.representation.split(".");
		var facet = representation[1];
		representation = representation[0];
		var facetNew = facet;

		if (facet === "$create") {
			facet = "$edit";
			context.parameters.representation = context.parameters.representation.replace(".$create", ".$edit");
			context.url = context.url.replace(".$create", ".$edit");
			context.request.url = context.request.url.replace(".$create", ".$edit");
		}
		var url = context.request.url;

		var requestBody = JSON.parse(context.request.readAll(_));

		var wcCreateUrl;
		var parts = url.split("?");
		var params = (parts[1] ? "?" + parts[1] : "?") + "&trackingId=" + helpers.uuid.generate();

		var serviceParts = parts[0].split("/$services/");
		var noServiceUrl = serviceParts[0];
		var serviceName = serviceParts[1];

		tracer && tracer("Statful service name: " + serviceName);

		if (/\((.*?)\)\/\$services\//.exec(url)) {
			// url references an existing resource
			// "{$baseUrl}/AQTCRUD('{CODE}')/$workingCopies?representation=AQTCRUD.$edit"
			wcCreateUrl = noServiceUrl + "/$workingCopies" + params;
		} else {
			// resource not yet existing
			// "{$baseUrl}/AQTCRUD/$template/$workingCopies?representation=AQTCRUD.$edit"
			wcCreateUrl = noServiceUrl + "/$template/$workingCopies" + params;
		}
		tracer && tracer("Create WC: " + wcCreateUrl);

		var reply = x3pool.jsonSend(_,
			context.request.session,
			context.endpoint, {
				head: {
					"accept": "application/json;vnd.sage=syracuse",
					"content-type": "application/json; charset=UTF-8",
					"method": "POST",
					"url": wcCreateUrl
				},
				body: {}
			}
		);
		tracer && tracer("Create WC status: " + reply.head.statusCode);
		if (reply.head.statusCode != 200) {
			throw new Error("Error creating working copy\nStatus : " + reply.head.statusCode + "\nUrl : " + url + "\nBody:" + JSON.stringify(reply.body, null, 2));
		}

		var wcData = reply.body;
		var wcUrl = wcData.$url.replace(/\{(.*?)\}/g, function(m, p1) {
			return wcData[p1];
		});
		tracer && tracer("WC url: " + wcUrl);

		var wcUpdateData = requestBody || {};
		wcUpdateData.$uuid = wcData.$uuid;
		wcUpdateData.$url = wcUrl;
		wcUpdateData.$actions = {};
		wcUpdateData.$actions[serviceName] = {
			$isRequested: true
		};

		if (wcUpdateData.$parameters) {
			wcUpdateData.$actions[serviceName].$parameters = wcUpdateData.$parameters;
			delete wcUpdateData.$parameters;
		}
		tracer && tracer("WC update and calling action.");
		reply = x3pool.jsonSend(_, context.request.session, context.endpoint, {
			head: {
				"accept": "application/json;vnd.sage=syracuse",
				"content-type": "application/json; charset=UTF-8",
				"method": "PUT",
				"url": wcUrl
			},
			body: wcUpdateData
		});
		if (reply.head.statusCode != 200) {
			throw new Error("Error executing action\nStatus : " + reply.head.statusCode + "\nUrl : " + url + "\nBody:" + JSON.stringify(reply.body, null, 2));
		}

		var body = _transformPayload(reply.body, facetNew, facet, representation, apiPrefix);
		return {
			data: body,
			head: reply.head
		};
	} catch (ex) {
		throw new Error("Error executing action\nStatus: " + ex.message + "\n" + ex.stacktrace);
	} finally {
		if (wcUrl) {
			tracer && tracer("Delete WC: " + wcUrl);
			reply = x3pool.jsonSend(_, context.request.session, context.endpoint, {
				head: {
					"accept": "application/json;vnd.sage=syracuse",
					"content-type": "application/json; charset=UTF-8",
					"method": "DELETE",
					"url": wcUrl
				},
				body: {}
			});
			if (reply.head.statusCode != 200) {
				tracer && tracer("Deleting WC failed!\n" + JSON.stringify(reply.body));
			}
		}
	}
}

/*
 * Transform dynamic metadata which is embedded in payload
 */
function _transformPayload(payload, newFacet, oldFacet, representation, apiPrefix) {
	var links;
	if (payload.$baseUrl) {
		payload.$baseUrl = _urlSetMobile(payload.$baseUrl, apiPrefix);
	}
	// Needs to be done before converting $actions to $links to not corrupt links created based on actions!
	_transformLinks(payload, apiPrefix);
	if (payload.$actions) {
		links = payload.$links = payload.$links || {};
		_transformActions(payload.$actions, links, newFacet, representation);
		delete payload["$actions"];
	}
	if (payload.$url) {
		payload.$url = payload.$url.replace("." + oldFacet, "." + newFacet);
		payload.$url = _urlSetMobile(payload.$url, apiPrefix);
	}
	return payload;
}

// Change /mobile1/ -> /sdata/
function _urlSetSData(url, prefix) {
	var segs = url.split("/");
	var idx = segs.indexOf(prefix || _mobileProtocolUrlSeg);
	if (idx > -1) {
		segs[idx] = "sdata";
		return segs.join("/");
	}
	return url;
}

//Change /sdata/ -> /mobile1/
function _urlSetMobile(url, prefix) {
	var segs = url.split("/");
	var idx = segs.indexOf("sdata");
	if (idx > -1) {
		segs[idx] = prefix || _mobileProtocolUrlSeg;
		return segs.join("/");
	}
	return url;
}