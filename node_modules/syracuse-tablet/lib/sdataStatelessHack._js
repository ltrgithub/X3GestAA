"use strict";

/*
 *
 * This dispatcher maps client requests <-> x3 responses in terms of converting stateful data
 * structures to stateless ones needed by the tablet client.
 *
 * https://github.com/Sage-ERP-X3/platform/wiki/Stateless-mode-draft-for-tablet-client
 *
 */

var x3pool = require("syracuse-x3/lib/pool");
var helpers = require("syracuse-core/lib/helpers");
var tracer = null; //console.log;

function InterceptResponse() {
	this.data = "";
	this.status = 0;
	this.head = null;
};

InterceptResponse.prototype = {
	writeHead: function(status, head) {
		this.head = head;
		this.status = status;
		if (this.batchResponse) this.batchResponse.$httpStatus = this.status;
	},
	write: function(_, data) {
		this.data += data;
	},
	end: function() {}
};

/*
 * Access to prototypes
 */
exports.prototypes = function(_, context, name, id) {
	var savedResponse = context.response;

	if (context.method.toLowerCase() !== "get") {
		throw new Error("Only GET allowed for prototype request");
	}

	var repr = /\$prototypes\('(.*?)\.(.*?)'\)/.exec(context.request.url);
	var facet = repr && repr[2];
	var x3Facet;
	repr = repr && repr[1];
	if (!repr) {
		throw context.badRequest("Cannot locate representation");
	}
	if (!facet) {
		throw context.badRequest("Cannot locate facet");
	}

	if (facet === "$create") {
		x3Facet = "$edit";
		context.url = context.url.replace("('" + repr + "." + facet + "')", "('" + repr + "." + x3Facet + "')");
		context.request.url = context.request.url.replace("('" + repr + "." + facet + "')", "('" + repr + "." + x3Facet + "')");
	}
	var intercept = new InterceptResponse();
	context.response = intercept;
	x3pool.send(_, context);

	context.response = savedResponse;

	var proto = JSON.parse(intercept.data);
	proto = exports.transformProto(proto, repr, facet, x3Facet);

	context.reply(_, intercept.status, proto);
};

/*
 * Access to working copies
 * This is contradictory in stateless mode
 */
exports.workingCopies = function(_, context, name, id) {
	tracer && tracer("Working copies url: " + context.url);
	throw context.badRequest("Using working copies in stateless mode is contradictory");
};

/*
 * This would handle URLs like
 * http://localhost:8124/sdata/x3/erp/SUPERV/$service...
 * which seem to be not supported today.
 * Usually there is a class segment in the URL before $service like
 * http://localhost:8124/sdata/x3/erp/SUPERV/ACTIVE/$service...
 * But these kind of URLs are handled by the "walk" handler and directly sent to X3
 *
 */
exports.service = function(_, context, name, id) {
	tracer && tracer("Service url: " + context.url);
	// This is more like a fallback since ending up here is the result of an invalid URL
	_handleUrl(_, context, name, id);
};

/*
 * Handle any kind of non special urls
 */
exports.walk = function(_, context, name, id) {
	tracer && tracer("Walk url: " + context.url);
	_handleUrl(_, context, name, id);
};

exports.transformProto = function(proto, repr, newFacet, oldFacet) {
	tracer && tracer("Transforming proto: " + repr + " " + newFacet + "->" + oldFacet);
	if (oldFacet && newFacet) {
		if (proto.$url) {
			proto.$url = proto.$url.replace("." + oldFacet, "." + newFacet);
		}
		if (proto.$type) {
			proto.$type = proto.$type.replace("." + oldFacet, "." + newFacet);
		}
	}

	_transformLinks(proto);

	var actions = proto.$actions;
	if (actions) {
		var links = proto.$links = proto.$links || {};
		_transformActions(actions, links, newFacet, repr);
		delete proto["$actions"];
	}
	return proto;
};

function _transformLinks(proto) {
	var links = proto.$links;
	if (links) {
		Object.keys(links).forEach(function(key) {
			var link = links[key];
			if (key !== "$delete") {
				link.$method = "GET";
			} else {
				link.$method = "DELETE";
			}

			if (link.$url.indexOf("/$workingCopies?") > -1) { // create or update
				if (link.$url.indexOf("/$template/") > -1) { // create
					// switch facet in case of create
					link.$url = link.$url.replace("/$workingCopies?", "?").replace(".$edit", ".$create");
				}
				// switch to stateless
				link.$url = link.$url.replace("/$workingCopies?", "?");
			}
		});
	}
	if (proto.$properties) {
		Object.keys(proto.$properties).forEach(function(prop) {
			var p = proto.$properties[prop];
			if (p.$item) {
				_transformLinks(p.$item);
			}
		});
	}
}

function _transformActions(actions, links, facet, representation) {
	Object.keys(actions).forEach(function(key) {
		var action = actions[key];
		var link;
		var url;
		var method;
		switch (key) {
			case "$save":
				if (facet === "$create") {
					method = "POST";
					url = "{$baseUrl}/" + representation;
				} else {
					method = "PUT";
					url = "{$baseUrl}/" + representation + "('{$key}')";
				}
				link = {
					$title: action.$title,
					$isHidden: action.$isHidden,
					$isDisabled: action.$isDisabled,
					$isAction: true,
					$url: url,
					$method: method
				};
				break;
			case "$abort":
				// do not send $abort at all in stateless mode since there is nothing to abort
				break;
			default:
				if (facet === "$create") {
					method = "PUT";
					url = "{$baseUrl}/" + representation + "/$services/" + key + "?representation=" + representation + "." + facet;
				} else {
					method = "PUT";
					url = "{$baseUrl}/" + representation + "('{$key}')/$services/" + key + "?representation=" + representation + "." + facet;
				}
				link = {
					$title: action.$title,
					$isHidden: action.$isHidden,
					$isDisabled: action.$isDisabled,
					$isAction: true,
					$url: url,
					$method: method
				};
				break;
		}

		if (link) {
			links[key] = link;
		}
	});
}

function _handleUrl(_, context, name, id) {
	var url = context.request.url;
	var method = context.method.toLowerCase();
	var savedResponse = context.response;
	var intercept;
	var status;
	var data;
	var facet;
	var newFacet;
	var representation;

	if (context.parameters && context.parameters.representation) {
		representation = context.parameters.representation.split(".");
		facet = representation[1];
		representation = representation[0];
		newFacet = facet;
	}

	if (url.indexOf("/$services/") > -1 && method === "get") {
		// stateless $service request, no need to modify
		// http://localhost:8124/sdata/x3/erp/GX3APP/BPCUSTOMER('001')/$services/BPCLOCK?representation=BPCUSTOMERM.$query&PACTION=1&$stateless=true
		if (newFacet === "$create") {
			facet = "$edit";
			context.parameters.representation = context.parameters.representation.replace(".$create", ".$edit");
			context.url = context.url.replace(".$create", ".$edit");
			context.request.url = context.request.url.replace(".$create", ".$edit");
		}

		intercept = new InterceptResponse();
		context.response = intercept;
		x3pool.send(_, context);

		data = JSON.parse(intercept.data);
		data = _transformPayload(data, newFacet, facet, representation);

		status = intercept.status;
		context.response = savedResponse;
		context.reply(_, status, data);
	} else if (url.indexOf("/$services/") > -1 && method !== "get") {
		// stateful action that is executed as $service
		data = _handleStatefulService(_, context, name, id);
		status = 200;

		context.response = savedResponse;
		context.reply(_, status, data);
	} else {
		if (newFacet === "$create") {
			facet = "$edit";
			context.parameters.representation = context.parameters.representation.replace(".$create", ".$edit");
			context.url = context.url.replace(".$create", ".$edit");
			context.request.url = context.request.url.replace(".$create", ".$edit");
		}
		intercept = new InterceptResponse();
		context.response = intercept;

		x3pool.send(_, context);
		data = JSON.parse(intercept.data);
		data = _transformPayload(data, newFacet, facet, representation);

		status = intercept.status;
		context.response = savedResponse;
		context.reply(_, status, data);
	}
}

/*
 * Handles stateful services ($actions in WC mode)
 *
 * "{$baseUrl}/AQTCRUD/$service/WADD_LIG44444444?representation=AQTCRUD.$create"
 * "{$baseUrl}/AQTCRUD('10')/$service/WADD_LIG44444444?representation=AQTCRUD.$edit"
 *
 */
function _handleStatefulService(_, context, name, id) {
	try {
		tracer && tracer("Statful service: " + context.request.url);

		var representation = context.parameters.representation.split(".");
		var facet = representation[1];
		representation = representation[0];
		var facetNew = facet;

		if (facet === "$create") {
			facet = "$edit";
			context.parameters.representation = context.parameters.representation.replace(".$create", ".$edit");
			context.url = context.url.replace(".$create", ".$edit");
			context.request.url = context.request.url.replace(".$create", ".$edit");
		}
		var url = context.request.url;

		var requestBody = JSON.parse(context.request.readAll(_));

		var wcCreateUrl;
		var parts = url.split("?");
		var params = (parts[1] ? "?" + parts[1] : "?") + "&trackingId=" + helpers.uuid.generate();

		var serviceParts = parts[0].split("/$services/");
		var noServiceUrl = serviceParts[0];
		var serviceName = serviceParts[1];

		tracer && tracer("Statful service name: " + serviceName);

		params = params.replace("&$stateless=true", "");

		if (/\((.*?)\)\/\$services\//.exec(url)) {
			// url references an existing resource
			// "{$baseUrl}/AQTCRUD('{CODE}')/$workingCopies?representation=AQTCRUD.$edit"
			wcCreateUrl = noServiceUrl + "/$workingCopies" + params;
		} else {
			// resource not yet existing
			// "{$baseUrl}/AQTCRUD/$template/$workingCopies?representation=AQTCRUD.$edit"
			wcCreateUrl = noServiceUrl + "/$template/$workingCopies" + params;
		}
		tracer && tracer("Create WC: " + wcCreateUrl);

		var reply = x3pool.jsonSend(_,
			context.request.session,
			context.endpoint, {
				head: {
					"accept": "application/json;vnd.sage=syracuse",
					"content-type": "application/json; charset=UTF-8",
					"method": "POST",
					"url": wcCreateUrl
				},
				body: {}
			}
		);
		tracer && tracer("Create WC status: " + reply.head.statusCode);
		if (reply.head.statusCode != 200) {
			throw new Error("Error creating working copy\nStatus : " + reply.head.statusCode + "\nUrl : " + url + "\nBody:" + JSON.stringify(reply.body, null, 2));
		}

		var wcData = reply.body;
		var wcUrl = wcData.$url.replace(/\{(.*?)\}/g, function(m, p1) {
			return wcData[p1];
		});
		tracer && tracer("WC url: " + wcUrl);

		var wcUpdateData = requestBody;
		wcUpdateData.$uuid = wcData.$uuid;
		wcUpdateData.$url = wcUrl;

		wcUpdateData.$actions = {};
		wcUpdateData.$actions[serviceName] = {
			$isRequested: true
		};

		tracer && tracer("WC update and calling action.");
		reply = x3pool.jsonSend(_, context.request.session, context.endpoint, {
			head: {
				"accept": "application/json;vnd.sage=syracuse",
				"content-type": "application/json; charset=UTF-8",
				"method": "PUT",
				"url": wcUrl
			},
			body: wcUpdateData
		});
		if (reply.head.statusCode != 200) {
			throw new Error("Error executing action\nStatus : " + reply.head.statusCode + "\nUrl : " + url + "\nBody:" + JSON.stringify(reply.body, null, 2));
		}

		var body = _transformPayload(reply.body, facetNew, facet, representation);
		return body;
	} catch (ex) {
		throw new Error("Error executing action\nStatus: " + ex.message + "\n" + ex.stacktrace);
	} finally {
		if (wcUrl) {
			tracer && tracer("Delete WC: " + wcUrl);
			reply = x3pool.jsonSend(_, context.request.session, context.endpoint, {
				head: {
					"accept": "application/json;vnd.sage=syracuse",
					"content-type": "application/json; charset=UTF-8",
					"method": "DELETE",
					"url": wcUrl
				},
				body: {}
			});
			if (reply.head.statusCode != 200) {
				tracer && tracer("Deleting WC failed!\n" + JSON.stringify(reply.body));
			}
		}
	}
}

/*
 * Transform dynamic metadata which is embedded in payload
 */
function _transformPayload(payload, newFacet, oldFacet, representation) {
	var links;
	if (payload.$actions) {
		links = payload.$links = payload.$links || {};
		_transformActions(payload.$actions, links, newFacet, representation);
		delete payload["$actions"];
	}

	// TODO: Also transform links and links on properrty level

	return payload;
}