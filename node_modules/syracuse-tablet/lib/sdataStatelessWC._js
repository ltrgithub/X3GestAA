"use strict";

var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;

var x3pool = require("syracuse-x3/lib/pool");
var helpers = require('syracuse-core').helpers;
var _mobileProtocolUrlSeg = "mobile2";

var tracer = null;
//var tracer = console.log;

function InterceptResponse() {
	this.chunks = [];
	this.status = 0;
	this.head = null;
};

InterceptResponse.prototype = {
	writeHead: function(status, head) {
		this.head = head;
		this.status = status;
	},

	write: function(_, data, enc) {
		this.chunks.push(typeof data === "string" ? new Buffer(data, enc || "utf8") : data);
	},

	toString: function(enc) {
		var data = this.chunks.map(function(chunk) {
			return chunk.toString(enc || "utf8");
		}).join("");
		return data;
	},
	end: function() {}
};

/*
 * Access to prototypes
 */
exports.prototypes = function(_, context, name, id) {
	var savedResponse = context.response;
	try {
		if (context.method.toLowerCase() !== "get") {
			throw new Error("Only GET allowed for prototype request");
		}

		var repr = /\$prototypes\('(.*?)\.(.*?)'\)/.exec(context.request.url);
		var facet = repr && repr[2];
		var x3Facet;
		repr = repr && repr[1];
		if (!repr) {
			throw context.badRequest("Cannot locate representation");
		}
		if (!facet) {
			throw context.badRequest("Cannot locate facet");
		}

		if (facet === "$create") {
			x3Facet = "$edit";
			context.url = context.url.replace("('" + repr + "." + facet + "')", "('" + repr + "." + x3Facet + "')");
			context.request.url = context.request.url.replace("('" + repr + "." + facet + "')", "('" + repr + "." + x3Facet + "')");
		}

		context.url = _urlSetSData(context.url);
		context.request.url = _urlSetSData(context.request.url);

		var intercept = new InterceptResponse();
		context.response = intercept;
		x3pool.send(_, context);
		context.response = savedResponse;

		var proto = intercept.toString();
		if (proto && proto.length > 0) {
			proto = JSON.parse(proto);
			proto = exports.transformProto(_, proto, repr, facet, x3Facet);
		}

		context.reply(_, intercept.status, proto, intercept.head);
	} finally {
		context.response = savedResponse;
	}
};

/*
 * Access to working copies
 * This is contradictory in stateless mode
 */
exports.workingCopies = function(_, context, name, id) {
	_handleUrl(_, context, name, id);
};

/*
 * This would handle URLs like
 * http://localhost:8124/sdata/x3/erp/SUPERV/$service...
 * which seem to be not supported today.
 * Usually there is a class segment in the URL before $service like
 * http://localhost:8124/sdata/x3/erp/SUPERV/ACTIVE/$service...
 * But these kind of URLs are handled by the "walk" handler and directly sent to X3
 *
 */
exports.service = function(_, context, name, id) {
	tracer && tracer("Service url: " + context.url);
	// This is more like a fallback since ending up here is the result of an invalid URL
	_handleUrl(_, context, name, id);
};

/*
 * Handle any kind of non special urls
 */
exports.walk = function(_, context, name, id) {
	tracer && tracer("Walk url: " + context.url);
	_handleUrl(_, context, name, id);
};

exports.transformProto = function(_, proto, repr, newFacet, oldFacet, dataset) {
	tracer && tracer("Transforming proto: " + repr + " " + newFacet + "->" + oldFacet);
	if (oldFacet && newFacet) {
		if (proto.$url) {
			proto.$url = proto.$url.replace("." + oldFacet, "." + newFacet);
		}
		if (proto.$type) {
			proto.$type = proto.$type.replace("." + oldFacet, "." + newFacet);
		}
	}
	if (proto.$baseUrl) {
		proto.$baseUrl = _urlSetMobile(proto.$baseUrl);
	}

	_transformLazyPropertyUrls(_, proto, repr, newFacet, oldFacet, dataset);
	return proto;
};

/**
 * Replace $url field's properties in $edit facet by the $url of $details one
 * FYI: Temporarily to fix the bug for images in edit
 * 		url points to the workingcopy {$instanceUrl}/PBLOB
 * 		mobile client needs /BDOC(..) url
 */
function _transformLazyPropertyUrls(_, proto, repr, newFacet, oldFacet, dataset, detailsProto) {
	if (!(oldFacet === "$edit" || newFacet === "$edit")) {
		return;
	}
	if (!proto) {
		return;
	}
	if (!proto.$properties) {
		return;
	}
	if (!dataset) {
		dataset = _urlGetDataset(proto.$baseUrl);
	}
	if (!dataset) {
		return;
	}
	//	console.log(require("util").inspect(proto.$properties, null, {depth:5}));
	var protoDetails = detailsProto; // may be null on first level

	var getProto = function(_, repr) {
		var ep;
		var entity;
		var model;
		var protoDet;
		try {
			if (!ep) {
				var adminOrm = adminHelper.getCollaborationOrm(_);
				ep = adminOrm.fetchInstance(_, adminOrm.model.getEntity(_, "endPoint"), {
					jsonWhere: {
						dataset: dataset
					}
				});
			}
			if (!model && ep) {
				model = ep.getModel(_, false);
			}
			if (!entity && model) {
				model.resetCache();
				entity = model.getEntity(_, repr, "$details", "desktop");
			}
			if (entity) {
				protoDet = entity.getPrototype(_, repr, "$details", "desktop");
			}
		} catch (e) {
			// We silently fail to be compatible with representations that were working in V7
			// We may encounter representations that only have an edit facet but this process might also
			// read the details facet which may cause an error since it's not enabled
		}
		return protoDet;
	};

	Object.keys(proto.$properties).forEach_(_, function(_, key) {
		var prop = proto.$properties[key];

		if (prop.$url) {
			if (!protoDetails) {
				protoDetails = getProto(_, repr);
			}

			if (protoDetails && protoDetails.$properties && protoDetails.$properties[key] && protoDetails.$properties[key].$url) {
				prop.$urlStateless = protoDetails.$properties[key].$url;
			}
		}

		if (prop.$item) {
			if (!protoDetails) {
				protoDetails = getProto(_, repr);
			}
			var details$Item = protoDetails && protoDetails.$properties && protoDetails.$properties[key] && protoDetails.$properties[key].$item;
			if (details$Item) {
				_transformLazyPropertyUrls(_, prop.$item, repr, newFacet, oldFacet, dataset, details$Item);
			}
		}
	});
}

function _handleUrl(_, context, name, id) {
	var url = context.request.url;
	var method = context.method.toLowerCase();
	var savedResponse = context.response;
	var intercept;
	var status;
	var data;
	var facet;
	var newFacet;
	var representation;
	var responsTime = null; //{start: new Date().getTime()};
	try {
		if (context.parameters && context.parameters.representation) {
			representation = context.parameters.representation.split(".");
			facet = representation[1];
			representation = representation[0];
			newFacet = facet;
		}
		context.url = _urlSetSData(context.url);
		context.request.url = _urlSetSData(context.request.url);

		if (url.indexOf("/$services/") > -1 && method === "get") {
			// stateless $service request, no need to modify
			// http://localhost:8124/mobile1/x3/erp/GX3APP/BPCUSTOMER('001')/$services/BPCLOCK?representation=BPCUSTOMERM.$query&PACTION=1
			if (newFacet === "$create") {
				facet = "$edit";
				context.parameters.representation = context.parameters.representation.replace(".$create", ".$edit");
				context.url = context.url.replace(".$create", ".$edit");
				context.request.url = context.request.url.replace(".$create", ".$edit");
			}

			intercept = new InterceptResponse();
			context.response = intercept;
			if (responsTime) responsTime.send = new Date().getTime();
			x3pool.send(_, context);
			if (responsTime) responsTime.x3response = new Date().getTime();
			data = intercept.toString();
			if (data && data.length > 0) {
				data = JSON.parse(data);
				data = _transformPayload(data, newFacet, facet, representation, context.url);
			}
			status = intercept.status;
			context.response = savedResponse;
			if (responsTime) responsTime.reply = new Date().getTime();
			context.reply(_, status, data, intercept.head);
		} else if (url.indexOf("/$services/") > -1 && method !== "get" && newFacet !== "$details") {
			// stateful action that is executed as $service
			if (responsTime) responsTime.send = new Date().getTime();
			data = _handleStatefulService(_, context, name, id);
			if (responsTime) responsTime.x3response = new Date().getTime();
			status = 200;
			context.response = savedResponse;
			if (responsTime) responsTime.reply = new Date().getTime();
			context.reply(_, status, data.data, data.head);
		} else {
			if (newFacet === "$create") {
				facet = "$edit";
				context.parameters.representation = context.parameters.representation.replace(".$create", ".$edit");
				context.url = context.url.replace(".$create", ".$edit");
				context.request.url = context.request.url.replace(".$create", ".$edit");
			}
			if (method === "delete") {
				var uuid = helpers.uuid.generate();
				context.url = context.url + (context.url.indexOf('?') >= 0 ? "&trackingId=" : "?trackingId=") + uuid;
				context.request.url = context.request.url + (context.request.url.indexOf('?') >= 0 ? "&trackingId=" : "?trackingId=") + uuid;
			}
			intercept = new InterceptResponse();
			context.response = intercept;

			if (responsTime) responsTime.send = new Date().getTime();
			x3pool.send(_, context);
			if (responsTime) responsTime.x3response = new Date().getTime();
			var contentType = intercept && intercept.head && intercept.head["content-type"] && intercept.head["content-type"];
			if (contentType && contentType.indexOf("application/json") < 0) {
				data = intercept.toString();
				context.response = savedResponse;
				status = intercept.status;
				context.response.writeHead(status, intercept.head);
				intercept.chunks.forEach_(_, function(_, chunk) {
					context.response.write(_, chunk);
				});
				if (responsTime) responsTime.reply = new Date().getTime();
				context.response.end();
			} else {
				data = intercept.toString();
				if (data && data.length > 0) {
					data = JSON.parse(data);
					data = _transformPayload(data, newFacet, facet, representation, context.url);
				}

				status = intercept.status;
				context.response = savedResponse;
				if (responsTime) responsTime.reply = new Date().getTime();
				context.reply(_, status, data, intercept.head);
			}
		}
		if (responsTime) {
			tracer && tracer("request=" + name, "send=" + (responsTime.send - responsTime.start), "x3response=" + (responsTime.x3response - responsTime.send), "reply=" + (responsTime.reply - responsTime.x3response), "elapsed=" + (responsTime.reply - responsTime.start));
		}
	} finally {
		context.response = savedResponse;
	}
}

/*
 * Handles stateful services ($actions in WC mode)
 *
 * "{$baseUrl}/AQTCRUD/$service/WADD_LIG44444444?representation=AQTCRUD.$create"
 * "{$baseUrl}/AQTCRUD('10')/$service/WADD_LIG44444444?representation=AQTCRUD.$edit"
 *
 */
function _handleStatefulService(_, context, name, id) {
	try {
		tracer && tracer("Statful service: " + context.request.url);

		var representation = context.parameters.representation.split(".");
		var facet = representation[1];
		representation = representation[0];
		var facetNew = facet;

		if (facet === "$create") {
			facet = "$edit";
			context.parameters.representation = context.parameters.representation.replace(".$create", ".$edit");
			context.url = context.url.replace(".$create", ".$edit");
			context.request.url = context.request.url.replace(".$create", ".$edit");
		}
		var url = context.request.url;

		var requestBody = JSON.parse(context.request.readAll(_));

		var wcCreateUrl;
		var parts = url.split("?");
		var params = (parts[1] ? "?" + parts[1] : "?") + "&trackingId=" + helpers.uuid.generate();

		var serviceParts = parts[0].split("/$services/");
		var noServiceUrl = serviceParts[0];
		var serviceName = serviceParts[1];

		tracer && tracer("Statful service name: " + serviceName);

		if (/\((.*?)\)\/\$services\//.exec(url)) {
			// url references an existing resource
			// "{$baseUrl}/AQTCRUD('{CODE}')/$workingCopies?representation=AQTCRUD.$edit"
			wcCreateUrl = noServiceUrl + "/$workingCopies" + params;
		} else {
			// resource not yet existing
			// "{$baseUrl}/AQTCRUD/$template/$workingCopies?representation=AQTCRUD.$edit"
			wcCreateUrl = noServiceUrl + "/$template/$workingCopies" + params;
		}
		tracer && tracer("Create WC: " + wcCreateUrl);

		var reply = x3pool.jsonSend(_,
			context.request.session,
			context.endpoint, {
				head: {
					"accept": "application/json;vnd.sage=syracuse",
					"content-type": "application/json; charset=UTF-8",
					"method": "POST",
					"url": wcCreateUrl
				},
				body: {}
			}
		);
		tracer && tracer("Create WC status: " + reply.head.statusCode);
		if (reply.head.statusCode != 200) {
			throw new Error("Error creating working copy\nStatus : " + reply.head.statusCode + "\nUrl : " + url + "\nBody:" + JSON.stringify(reply.body, null, 2));
		}

		var wcData = reply.body;
		var wcUrl = wcData.$url.replace(/\{(.*?)\}/g, function(m, p1) {
			return wcData[p1];
		});
		tracer && tracer("WC url: " + wcUrl);

		var wcUpdateData = requestBody || {};
		wcUpdateData.$uuid = wcData.$uuid;
		wcUpdateData.$url = wcUrl;
		wcUpdateData.$actions = {};
		wcUpdateData.$actions[serviceName] = {
			$isRequested: true
		};

		if (wcUpdateData.$parameters) {
			wcUpdateData.$actions[serviceName].$parameters = wcUpdateData.$parameters;
			delete wcUpdateData.$parameters;
		}
		tracer && tracer("WC update and calling action.");
		reply = x3pool.jsonSend(_, context.request.session, context.endpoint, {
			head: {
				"accept": "application/json;vnd.sage=syracuse",
				"content-type": "application/json; charset=UTF-8",
				"method": "PUT",
				"url": wcUrl
			},
			body: wcUpdateData
		});
		if (reply.head.statusCode != 200) {
			throw new Error("Error executing action\nStatus : " + reply.head.statusCode + "\nUrl : " + url + "\nBody:" + JSON.stringify(reply.body, null, 2));
		}

		var body = _transformPayload(reply.body, facetNew, facet, representation, context.url);
		return {
			data: body,
			head: reply.head
		};
	} catch (ex) {
		throw new Error("Error executing action\nStatus: " + ex.message + "\n" + ex.stacktrace);
	} finally {
		if (wcUrl) {
			tracer && tracer("Delete WC: " + wcUrl);
			reply = x3pool.jsonSend(_, context.request.session, context.endpoint, {
				head: {
					"accept": "application/json;vnd.sage=syracuse",
					"content-type": "application/json; charset=UTF-8",
					"method": "DELETE",
					"url": wcUrl
				},
				body: {}
			});
			if (reply.head.statusCode != 200) {
				tracer && tracer("Deleting WC failed!\n" + JSON.stringify(reply.body));
			}
		}
	}
}

/*
 * Transform dynamic metadata which is embedded in payload
 */
function _transformPayload(payload, newFacet, oldFacet, representation, url) {
	var links;
	if (payload.$baseUrl) {
		payload.$baseUrl = _urlSetMobile(payload.$baseUrl);

		if (url) {
			payload.$baseUrl = _makeQualified(payload.$baseUrl, url);
		}
	}
	_transformLinks(payload);
	if (payload.$url) {
		payload.$url = payload.$url.replace("." + oldFacet, "." + newFacet);
		payload.$url = _urlSetMobile(payload.$url);
	}
	return payload;
}

function _transformLinks(proto) {
	var links = proto.$links;
	if (links) {
		Object.keys(links).forEach(function(key) {
			var link = links[key];
			if (link.$url) {
				link.$url = _urlSetMobile(link.$url);
			}
		});
	}
}

// Change /mobile1/ -> /sdata/
function _urlSetSData(url) {
	var segs = url.split("/");
	var idx = segs.indexOf(_mobileProtocolUrlSeg);
	if (idx > -1) {
		segs[idx] = "sdata";
		return segs.join("/");
	}
	return url;
}

//Change /sdata/ -> /mobile1/
function _urlSetMobile(url) {
	var segs = url.split("/");
	var idx = segs.indexOf("sdata");
	if (idx > -1) {
		segs[idx] = _mobileProtocolUrlSeg;
		return segs.join("/");
	}
	return url;
}

// return the dataset
// TODO don't use split but an url parser (sdatautils.parseSdataUrl) also for _urlSetMobile and _urlSetSData
function _urlGetDataset(url) {
	if (!url) return null;
	var segs = url.split("/");
	var idx = segs.indexOf(_mobileProtocolUrlSeg);
	return idx > -1 ? segs[idx + 3] : null;
}

function _makeQualified(relUrl, fullUrl) {
	if (!fullUrl || !relUrl) return relUrl;

	if (relUrl.indexOf("http") === 0) return relUrl; // Already qualified
	if (fullUrl.indexOf("http") < 0) return relUrl; // Unable to qualify using the context.url that was passed in here

	var segs = fullUrl.split("/");
	var host = segs.slice(0, 3).join("/");

	var qualifiedUrl = host + relUrl;
	return qualifiedUrl;
}