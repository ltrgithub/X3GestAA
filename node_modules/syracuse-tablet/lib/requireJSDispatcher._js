"use strict";

// / !doc
// /
// / # Server-side requirejs handler
// /
// / Handles requireJS requests coming from the tablet client and transforms
// commonJS modules to AMD modules by wrapping them with a define
// /
var fs = require('streamline-fs');
var path = require('path');
var util = require('util');
var uurl = require('url');
var querystring = require('querystring');
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var streams = require('streamline-streams');
var globals = require('streamline-runtime').globals;
var helpers = require('syracuse-core').helpers;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;

var _log = null; //console.log;

/**
 * Shared context services - TODO MOVE TO A DEDICATED DISPATCHER - /mobile/service/shared/createContext
 */

function hasErrors(body, k) {
	var msg;
	var hasErr = body && body.$diagnoses && body.$diagnoses.some(function(diag) {
		if (diag.$severity === "error") {
			msg = "Error related to field " + k + " : " + diag.$message;
			return msg;
		} else return false;
	});
	if (!hasErr) {
		for (var key in body) {
			if (typeof body[key] === "object") {
				hasErr = hasErr || hasErrors(body[key], key);
				if (hasErr) return hasErr;
			}
		}
	}
	return msg || hasErr;
};


function _processMiscSvc(_, path, qs, request, response) {
	var action = path.length > 2 ? path[3] : null;
	var err, result;
	try {
		switch (action) {
			case "connectionAlive":
				break;
			default:
				err = "unknow action " + action;
				break;
		}
	} catch (e) {
		err = e.message;
	}
	response.writeHead(err ? 404 : 200, {
		"cache-control": "no-cache"
	});
	if (err) {
		result = {
			"$diagnoses": [{
				"$message": err,
				"$severity": "error"
			}]
		};
	}
	if (result) {
		response.write(_, JSON.stringify(result));
	}
}

function _processSharedContext(_, path, qs, request, response) {
	var action = path.length > 2 ? path[3] : null;
	var err, result;
	try {
		var db = adminHelper.getCollaborationOrm(_);
		var entity = db.model.getEntity(_, "mobileSharedContext");
		switch (action) {
			case "create":
				var requestBody = JSON.parse(request.readAll(_)) || {};
				if (!requestBody) {
					err = "No request body";
					break;
				}
				_log && _log(JSON.stringify(requestBody, null, 2));
				var linkCtx = requestBody.linkCtx;
				if (!linkCtx || typeof linkCtx !== "object") {
					err = "No link context (linkCtx)";
					break;
				}
				var lifespan = parseInt(requestBody.lifespan, 10);
				if (isNaN(lifespan)) {
					lifespan = 3 * 24;
				}
				var h = entity.factory.createInstance(_, null, db);
				// JSON stringified to avoid the constraint of $ JSON properties in mongo (not allowed)
				h.linkCtx(_, JSON.stringify(linkCtx));
				h.lifespan(_, lifespan);
				err = hasErrors(h.save(_));
				if (err) {
					break;
				};
				result = {
					$uuid: h.$uuid
				};
				break;
			case "read":
				if (!qs.uuid) {
					err = "No uuid";
					break;
				}
				_log && _log(qs.uuid);
				var h = db.fetchInstance(_, entity, {
					"jsonWhere": {
						"$uuid": qs.uuid
					}
				});
				if (!h) {
					err = "No instance - uuid=" + qs.uuid;
					break;
				}
				try {
					result = JSON.parse(h.linkCtx(_));
				} catch (e) {
					err = "Bad json string - uuid=" + qs.uuid;
					break;
				}
				break;
			default:
				err = "unknow action " + action;
				break;
		}
	} catch (e) {
		err = e.message;
	}
	var status = err ? 404 : 200;
	_log && _log("\n_processSharedContext", action, status, err || "");
	response.writeHead(status, {
		"cache-control": "no-cache"
	});
	response.write(_, err ? JSON.stringify({
		"$diagnoses": [{
			"$message": err,
			"$severity": "error"
		}]
	}) : JSON.stringify(result));
}
/**
 *
 */
function _getLoginCookieName(request) {
	return "syracuse.sid.login." + request.connection.localPort;
}

function _parseCookie(request) {
	return helpers.http.parseCookie(request.headers.cookie);
}

function _getLoginCookie(request) {
	var cookieName = _getLoginCookieName(request);
	var cookie = _parseCookie(request)[cookieName];
	return cookie ? cookieName + "=" + cookie : null;
}

function _secureCookie(request, value) {
	var secure = (request.hosting && request.hosting.https) || ('authorized' in request.connection);
	var prefix = (value[value.length - 1] === ";") ? "" : ";";
	if (secure) value += prefix + 'Secure;';
	value += prefix + 'HttpOnly;';
	return value;
}
/**
 * True if login token is valid
 * TODO - loginToken entity should provide this service
 */
function _checkLoginCookie(_, loginCookie) {
	if (!loginCookie) return;
	var parts = loginCookie.split("/");
	var token = parts.pop();
	var series = parts.pop();
	var login = parts.join("/");
	var db = adminHelper.getCollaborationOrm(_);
	var loginToken = db.fetchInstance(_, db.getEntity(_, "loginToken"), series);
	if (!loginToken) return false;
	// fetch user
	var user = db.fetchInstance(_, db.model.getEntity(_, "user"), {
		jsonWhere: {
			login: login,
			active: true
		}
	});
	return user != null;
}
/**
 * Reconnect process
 * Win 10 - US 110849-10 - Fast application resume
 * Allows reconnection without login if browser is closed and Syracuse session is still alive
 * Access (Read/Write) to session cookies is not allowed on Browser it's why mobile client used these services (getToken/setToken)
 * TODO MOVE TO A DEDICATED DISPATCHER - /mobile/services/reconnect/getToken...
 */
function _processReconnectSvc(_, path, qs, request, response) {
	var action = path.length > 2 ? path[3] : null;
	_log && _log("\n_processReconnectSvc", action);
	var cookies = _parseCookie(request);
	_log && _log("cookies", JSON.stringify(cookies, null, 2));
	var loginCookieName = _getLoginCookieName(request);
	_log && _log("loginCookieName", loginCookieName);
	var loginCookie = cookies[loginCookieName];
	_log && _log("loginCookie", loginCookie);
	var status;
	var headers = {
		"cache-control": "no-cache"
	};
	switch (action) {
		case "getToken":
			// Return a token (login cookie syracuse.sid.login.8124)
			// This token is stored (by the native wrapper) and sent when mobile application is launched to try to avoid login
			if (_checkLoginCookie(_, loginCookie)) {
				status = 200;
				headers['x-reconnect-token'] = loginCookie;
			} else {
				status = 404;
			}
			break;
		case "setToken":
			status = 200;
			// Process the reconnect token
			// If no login cookie is found in headers and reconnect is a token is provided 
			//	-> Set the login cookie (syracuse.sid.login.8124) given by reconnect token
			// The mobile client will read the profile after having called reconnectSetToken
			// If the login cookie has expired or session is destroyed user will be forced to login (regular process)
			// If not no login is needed
			var headers = {};
			if (!loginCookie) {
				_log && _log("Login cookie is not provided");
				var reconnectToken = request.headers['x-reconnect-token'];
				_log && _log("reconnectToken", reconnectToken);
				if (reconnectToken) {
					headers['set-cookie'] = loginCookieName + "=" + _secureCookie(request, reconnectToken + '; path=/');
				}
			} else {
				_log && _log("Login cookie is provided");
			}
			break;
		default:
			status = 404;
			break;
	}
	_log && _log("headers", JSON.stringify(headers, null, 2), "status", status);
	response.writeHead(status, headers);
}
/**
 * These dispatcher doesn't need an authentication to be called by the client
 * It's why we put the reconnect services here
 */
exports.dispatcher = function(config) {
	var root = path.join(__dirname, "../../../node_modules/");
	return function(_, request, response) {
		var url = uurl.parse(request.url);
		var segs = url.pathname.split("/");
		var service = segs.length > 1 ? segs[2] : null;
		var qs = url.query ? querystring.parse(url.query) || {} : {};
		switch (service) {
			case "misc":
				_processMiscSvc(_, segs, qs, request, response);
				break;
			case "reconnect":
				_processReconnectSvc(_, segs, qs, request, response);
				break;
			case "sharedContext":
				_processSharedContext(_, segs, qs, request, response);
				break;
			default:
				var file = path.join(root, segs.slice(2).join("/"));
				if (!fs.exists(file, _)) {
					response.writeHead(404, {});
				} else {
					response.writeHead(200, {
						'content-type': 'application/javascript'
					});
					var content = fs.readFile(file, 'utf8', _);
					if (segs.indexOf("deps") < 0) { // do not pack dependencies in
						// an AMD format (jQuery e.g.
						// would not work)
						content = "define(function(require, exports, module) {\n" + content + "\n});";
					}
					response.write(_, content);
				}
				break;

		}
		response.end();
	};
};