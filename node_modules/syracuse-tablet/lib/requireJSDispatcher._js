"use strict";

var flows = require('streamline-runtime').flows;

// / !doc
// /
// / # Server-side requirejs handler
// /
// / Handles requireJS requests coming from the tablet client and transforms
// commonJS modules to AMD modules by wrapping them with a define
// /
var fs = require('streamline-fs');
var path = require('path');
var util = require('util');
var uurl = require('url');
var querystring = require('querystring');
var sessionManager = require('@sage/syracuse-lib/src/session/sessionManager').sessionManager;
var streams = require('streamline-streams');
var globals = require('streamline-runtime').globals;
var helpers = require('@sage/syracuse-core').helpers;
var adminHelper = require("@sage/syracuse-lib/src/collaboration/helpers").AdminHelper;
var authHelper = require('@sage/syracuse-lib/src/auth/helpers');
var config = require('config');

var _log = null; // console.log;

/**
 * Shared context services - TODO MOVE TO A DEDICATED DISPATCHER - /mobile/service/shared/createContext
 */

function hasErrors(body, k) {
	var msg;
	var hasErr = body && body.$diagnoses && body.$diagnoses.some(function(diag) {
		if (diag.$severity === "error") {
			msg = "Error related to field " + k + " : " + diag.$message;
			return msg;
		} else return false;
	});
	if (!hasErr) {
		for (var key in body) {
			if (typeof body[key] === "object") {
				hasErr = hasErr || hasErrors(body[key], key);
				if (hasErr) return hasErr;
			}
		}
	}
	return msg || hasErr;
};
/**
 * Log service
 * -1- Allows to log in Syracuse console without any authentication (contrary to logger entity)
 * -2- Allows to debug mobile client on real devices if no dxebugger is provided by the browser's dxebugger on desktop  (Eg: chrome on ios..)
 */
function _processLogSvc(_, path, qs, request, response) {
	var action = path.length > 2 ? path[3] : null;
	var err, result;
	try {
		switch (action) {
			case "write":
				if (qs && qs.text) {
					console.log(qs.text);
				}
				break;
			default:
				err = "unknow action " + action;
				break;
		}
	} catch (e) {
		err = e.message;
	}
	response.writeHead(err ? 404 : 200, {
		"cache-control": "no-cache"
	});
	if (err) {
		result = {
			"$diagnoses": [{
				"$message": err,
				"$severity": "error"
			}]
		};
	}
	if (result) {
		response.write(_, JSON.stringify(result));
	}
};

// returns a JSON with the status per authentication
var _getAuthConfig = function(_) {
	var result = {};
	var authMethods = config.session ? Array.isArray(config.session.auth) ? config.session.auth : [config.session.auth] : [];
	authMethods.forEach_(_, function(_, auth) {
		result[auth] = true;
	});
	if (result["sage-id"] === true && config.sage_id == null) {
		result["sage-id"] = false;
	}

	var saml2s = require('@sage/syracuse-lib/src/auth/saml2').getServerList(_);
	if (authHelper.isAllowed("saml2", true) && saml2s.length) {
		result["saml2"] = true
		result["$saml2"] = saml2s;
	} else {
		result["saml2"] = false;
	}
	var oauth2s = require('@sage/syracuse-lib/src/auth/oauth2').getServerList(_);
	if (authHelper.isAllowed("oauth2", true) && oauth2s.length) {
		result["oauth2"] = true;
		result["$oauth2"] = oauth2s;
	} else {
		result["oauth2"] = false;
	}

	return result;
};

function _processMiscSvc(_, path, qs, request, response) {
	var action = path.length > 2 ? path[3] : null;
	var err, result;
	try {
		switch (action) {
			case "connectionAlive":
				break;
			case "availableAuth":
				result = _getAuthConfig(_);
				break;
			default:
				err = "unknow action " + action;
				break;
		}
	} catch (e) {
		err = e.message;
	}
	response.writeHead(err ? 404 : 200, {
		"cache-control": "no-cache",
		"content-type": "application/json;charset=UTF-8"
	});
	if (err) {
		result = {
			"$diagnoses": [{
				"$message": err,
				"$severity": "error"
			}]
		};
	}
	if (result) {
		response.write(_, JSON.stringify(result));
	}
}

/**
 *
 */
function _getLoginCookieName(request) {
	return "syracuse.sid.login." + request.connection.localPort;
}

function _getSidCookieName(request) {
	return "syracuse.sid." + request.connection.localPort;
}

function _parseCookie(request) {
	return helpers.http.parseCookie(request.headers.cookie);
}

function _getLoginCookie(request) {
	var cookieName = _getLoginCookieName(request);
	var cookie = _parseCookie(request)[cookieName];
	return cookie ? cookieName + "=" + cookie : null;
}

function _secureCookie(request, value) {
	var secure = (request.hosting && request.hosting.https) || ('authorized' in request.connection);
	var prefix = (value[value.length - 1] === ";") ? "" : ";";
	if (secure) value += prefix + 'Secure;';
	value += prefix + 'HttpOnly;';
	return value;
}
/**
 * True if login token is valid
 * TODO - loginToken entity should provide this service
 */
function _checkLoginCookie(_, loginCookie) {
	if (!loginCookie) return;
	var parts = loginCookie.split("/");
	var token = parts.pop();
	var series = parts.pop();
	var login = parts.join("/");
	var db = adminHelper.getCollaborationOrm(_);
	var loginToken = db.fetchInstance(_, db.getEntity(_, "loginToken"), series);
	if (!loginToken) return false;
	// fetch user
	var user = db.fetchInstance(_, db.model.getEntity(_, "user"), {
		jsonWhere: {
			login: login,
			active: true
		}
	});
	return user != null;
}
/**
 * Reconnect process
 * Win 10 - US 110849-10 - Fast application resume
 * Allows reconnection without login if browser is closed and Syracuse session is still alive
 * Access (Read/Write) to session cookies is not allowed on Browser it's why mobile client used these services (getToken/setToken)
 * TODO MOVE TO A DEDICATED DISPATCHER - /mobile/services/reconnect/getToken...
 */
function _processReconnectSvc(_, path, qs, request, response) {
	var action = path.length > 2 ? path[3] : null;
	_log && _log("\n_processReconnectSvc", action);
	var loginCookieName = _getLoginCookieName(request);
	var sidCookieName = _getSidCookieName(request);
	var status;
	var headers = {
		"cache-control": "no-cache"
	};
	switch (action) {
		case "getToken":
			var cookies = _parseCookie(request);
			_log && _log("cookies", JSON.stringify(cookies, null, 2));
			var loginCookie = cookies[loginCookieName];
			var sidCookie = cookies[sidCookieName];
			// Returns login/sid cookies stored by the native wrapper and sent when mobile application is launched to try to avoid login
			if (_checkLoginCookie(_, loginCookie)) {
				status = 200;
				if (loginCookie != null && loginCookie.length > 0) {
					headers['x-reconnect-token'] = loginCookie;
					headers['x-reconnect-login-cookiename'] = loginCookieName;
				}
				if (sidCookie != null && sidCookie.length > 0) {
					headers['x-reconnect-sid'] = sidCookie;
					headers['x-reconnect-sid-cookiename'] = sidCookieName;
				}
			} else {
				status = 404;
			}
			break;
		case "setToken":
			status = 200;
			// The browser is not allowed to access to login/session cookie. See getToken
			// This service reads the cookies and returns them in the header
			var headers = {};
			var loginCookie = request.headers['x-reconnect-token'];
			var sidCookie = request.headers['x-reconnect-sid'];
			_log && _log("loginCookie", loginCookie, "sidCookie", sidCookie);
			if (loginCookie) {
				headers['set-cookie'] = loginCookieName + "=" + _secureCookie(request, loginCookie + '; path=/');
			}
			if (sidCookie) {
				headers['set-cookie'] = sidCookieName + "=" + _secureCookie(request, sidCookie + '; path=/');
			}
			break;
		default:
			status = 404;
			break;
	}
	_log && _log("headers", JSON.stringify(headers, null, 2), "status", status);
	response.writeHead(status, headers);
}




function _testLiveTile(_, path, qs, request, response) {
	var count = path.length > 2 ? path[3] : null;
	var err = null;
	var result;
	if (count == null || isNaN(count)) {
		err = "Error reading tile's data"
	} else {
		var item = {
			"$uuid": "444ec7bb-aad4-4bea-97a3-4db428b1e5a3",
			"$etag": "2016-06-02T11:58:02Z",
			"DATEXS": "2013-02-25",
			"NBREXS": 1,
			"ACCNUM": 6483,
			"STA": 1,
			"QTY": 1,
			"AMTPAY": 0,
			"PJTLIN": "",
			"FLGPCT": 0,
			"CLB": "ADMIN",
			"CLB_REF": {
				"$title": "Administrateur systÃ¨me",
				"$description": "Administrateur systÃ¨me"
			},
			"FCY": "PAR",
			"FCY_REF": {
				"$title": "Paris",
				"$description": "Production Paris"
			},
			"CODEXP": "BOUCHE",
			"CODEXP_REF": {
				"$title": "Bouche",
				"$description": "Repas"
			},
			"VISA": "",
			"VISA_REF": {
				"$title": ""
			},
			"CUR": "EUR",
			"CUR_REF": {
				"$title": "Euro",
				"$description": "EURO",
				"$symbol": "EUR",
				"$scale": 2,
				"$precision": 11
			}
		}
		result = {
			"$itemsPerPage": 20,
			"$resources": []
		}
		for (var i = 0; i < count; i++) {
			result.$resources.push(item)
		}
	}

	var status = err ? 404 : 200;
	_log && _log("\n_testLiveTile", count, status, err || "");
	flows.sleep(_, 5000)
	response.writeHead(status, {
		"cache-control": "no-cache",
		"content-type": "application/json;charset=UTF-8"
	});
	response.write(_, err ? JSON.stringify({
		"$diagnoses": [{
			"$message": err,
			"$severity": "error"
		}]
	}) : JSON.stringify(result));
}


/**
 * These dispatcher doesn't need an authentication to be called by the client
 * It's why we put the reconnect services here
 */
exports.dispatcher = function(config) {
	var root = path.join(__dirname, "../../../node_modules/");
	return function(_, request, response) {
		var url = uurl.parse(request.url);
		var segs = url.pathname.split("/");
		var service = segs.length > 1 ? segs[2] : null;
		var qs = url.query ? querystring.parse(url.query) || {} : {};
		switch (service) {

			case "testLiveTile":
				_testLiveTile(_, segs, qs, request, response)
				break;

			case "log":
				_processLogSvc(_, segs, qs, request, response);
				break;
			case "misc":
				_processMiscSvc(_, segs, qs, request, response);
				break;
			case "reconnect":
				_processReconnectSvc(_, segs, qs, request, response);
				break;
			default:
				var file = path.join(root, segs.slice(2).join("/"));
				//_log && _log(file)
				if (!fs.exists(file, _)) {
					response.writeHead(404, {});
				} else {
					response.writeHead(200, {
						'content-type': 'application/javascript'
					});
					var content = fs.readFile(file, 'utf8', _);
					if (segs.indexOf("deps") < 0) { // do not pack dependencies in
						// an AMD format (jQuery e.g.
						// would not work)
						content = "define(function(require, exports, module) {\n" + content + "\n});";
					}
					response.write(_, content);
				}
				break;

		}
		response.end();
	};
};