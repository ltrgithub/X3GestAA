"use strict";
var libTests = require('syracuse-tablet/test/js/libTests');

exports.modulename = "Deferred";
var testset;

function simpleResolve() {
	try {
		var testcase = testset.addTestcase("Simple resolve");
		$.smResolve("xxx")
			.then(function(param) {
				// Ok to be here			
				testcase.addResult("Resolved as expected", true);
				testcase.addResult("Value ok", param === "xxx");
			}, function(param) {
				testcase.addResult("Rejected as NOT expected", false);
			});
	} catch (e) {
		testcase.addResult("Exception as NOT expected", false);
	}
}

function simpleReject() {
	try {
		var testcase = testset.addTestcase("Simple reject");
		$.smReject("xxx")
			.then(function(param) {
				testcase.addResult("Resolved as NOT expected", false);
			}, function(param) {
				// Ok to be here
				testcase.addResult("Rejected as expected", true);
				testcase.addResult("Value ok", param === "xxx");
			});
	} catch (e) {
		testcase.addResult("Exception as NOT expected", false);
	}
}

function simpleExceptionOld() {
	var es = "error string";
	try {
		var testcase = testset.addTestcase("Simple exception (old jQuery)");
		$.smResolve("xxx")
			.then(function(param) {
				throw es;
			})
			.then(function(param) {
				testcase.addResult("Resolved as NOT expected", false);
			}, function(param) {
				testcase.addResult("Rejected as NOT expected", false);
			});
	} catch (e) {
		// Ok to be here
		testcase.addResult("Exception as expected", e === es);
	}
}

function simpleException() {
	var es = "error string";
	try {
		var testcase = testset.addTestcase("Simple exception (jQuery overridden exception handling)");
		$.smResolve("xxx")
			.then(function(param) {
				throw es;
			})
			.then(function(param) {
				testcase.addResult("Resolved as NOT expected", false);
			}, function(param) {
				// with the hack we expect to handle exception in the fail handler
				testcase.addResult("Rejected expected", param === es);
			});
	} catch (e) {
		// Exception is catched by promise.then method
		testcase.addResult("Exception not expected", false);
	}
}

function asyncExceptionOld() {
	var es = "error string";
	try {
		var testcase = testset.addTestcase("Async exception (old jQuery)");
		$.smResolve("xxx")
			.then(function(param) {
				testcase.addResult("Resolved as expected", true);
				testcase.addResult("Value ok (1)", param === "xxx");

				var d = $.Deferred();
				setTimeout(function() {
					try {
						d.resolve("yyy");

						// we never end up here because of throw
						testcase.addResult("Next statement as NOT expected", false);
					} catch (e) {
						testcase.addResult("Inner stack exception as expected", e === es);
						// We could throw again but it will never be catched since the outer catch is another stack. To avoid a confusing message in the console, there is not re-throw here.
						// throw e;
					}
				}, 0);
				return d.promise();
			})
			.then(function(param) {
				testcase.addResult("Resolved as expected", true);
				testcase.addResult("Value ok (2)", param === "yyy");

				throw es;
			})
			.then(function(param) {
				// we never end up here because of throw
				testcase.addResult("Resolved as NOT expected", false);
			}, function(param) {
				// we never end up here because of throw
				testcase.addResult("Rejected as NOT expected", false);
			});
	} catch (e) {
		// we never end up here because of throw is another async process with another stack
		testcase.addResult("Outer stack exception as NOT expected", false);
	}
}

function asyncException() {
	var es = "error string";
	var testcase = testset.addTestcase("Async exception new beahviour (jQuery overridden exception handling)");
	$.smResolve("xxx")
		.then(function(param) {
			testcase.addResult("Resolved as expected", true);
			testcase.addResult("Value ok (1)", param === "xxx");

			var d = $.Deferred();
			setTimeout(function() {
				try {
					d.resolve("yyy");
					// we end up here because exception is caught and chain is rejected
					testcase.addResult("Next statement as not expected", true, "We can't prevent it because exception is caught in promise.then");
				} catch (e) {
					// Never end end here since exception is cached in promise itself and handled as reject
					testcase.addResult("Inner stack exception as NOT expected", false);
				}
			}, 0);
			return d.promise();
		})
		.then(function(param) {
			testcase.addResult("Resolved as expected", true);
			testcase.addResult("Value ok (2)", param === "yyy");
			throw es;
		})
		.then(function(param) {
			// we never end up here because of throw
			testcase.addResult("Resolved as NOT expected", false);
		}, function(e) {
			// we end up here because of throw is caught internally y promise.then and sent to reject handler
			testcase.addResult("Rejected as expected", e == es);
		}).fail(function(param) {
			// Exception is also handled here
			testcase.addResult("Rejected expected", param == null);
		});
}

// This is just to show it's not possible to recover from a rejected promise chain
function simpleRejectNoRecover() {
	try {
		var fail1Triggered = false;
		var fail2Triggered = false;
		var then1Triggered = false;
		var testcase = testset.addTestcase("Simple reject NO recover");
		$.smReject("xxx")
			.then(function(param) {
				testcase.addResult("Resolved as NOT expected", false);
			}, function(param) {
				// Ok to be here
				testcase.addResult("Rejected as expected", true);
				testcase.addResult("Value ok", param === "xxx");
			})
			.fail(function() {
				fail1Triggered = true;
				// Also we return a resolved promise here, the promise chain will remain REJECTED !!!
				// This is the standard behaviour of JQ
				return $.smResolve();
			})
			.then(function() {
				// Never get here because of very first reject
				then1Triggered = true;
			})
			.fail(function() {
				fail2Triggered = true;
			})
			.always(function() {
				testcase.addResult("Then as NOT expected (1)", then1Triggered === false);
				testcase.addResult("Failed as expected (1)", fail1Triggered);
				testcase.addResult("Failed as expected (2)", fail2Triggered);
			});
	} catch (e) {
		testcase.addResult("Exception as NOT expected", false);
	}
}

//This is just to show how to recover in a failed promise chain
function simpleRejectWithRecover() {
	try {
		var fail1Triggered = false;
		var fail2Triggered = false;
		var then1Triggered = false;
		var testcase = testset.addTestcase("Simple reject WITH recover");

		var secondStepTrigger = $.Deferred();
		$.smReject("xxx")
			.then(function(param) {
				testcase.addResult("Resolved as NOT expected", false);
			}, function(param) {
				// Ok to be here
				testcase.addResult("Rejected as expected", true);
				testcase.addResult("Value ok", param === "xxx");
			})
			.fail(function() {
				fail1Triggered = true;
				secondStepTrigger.resolve();
			})
			.then(function() {
				secondStepTrigger.resolve();
			});

		secondStepTrigger.then(function() {
			// Never get here because of very first reject
			then1Triggered = true;
		})
			.fail(function() {
				fail2Triggered = true;
			})
			.always(function() {
				testcase.addResult("Then as expected (1)", then1Triggered);
				testcase.addResult("Failed as expected (1)", fail1Triggered);
				testcase.addResult("Failed as NOT expected (2)", fail2Triggered == false);
			});
	} catch (e) {
		testcase.addResult("Exception as NOT expected", false);
	}
}
exports.test = function() {
	testset = libTests.addTestset("Deferred pattern");

	simpleResolve();
	simpleReject();

	simpleRejectNoRecover(); // Show how failure works
	simpleRejectWithRecover(); // Show how to recover in the scenario above

	if (false) {
		simpleExceptionOld();
		asyncExceptionOld();
	} else {
		// This is the test that should be choosen
		simpleException();
		asyncException();
	}
	return $.smResolve();
};