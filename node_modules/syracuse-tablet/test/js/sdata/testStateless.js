"use strict";
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("testStateless");
var libTests = require('syracuse-tablet/test/js/libTests');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var sdataHttp = require('syracuse-tablet/html/js/sdata/sdataHttp');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');


var _round = function(num, digits) {
	digits = digits || 2;
	return Math.round(num * Math.pow(10, digits)) / Math.pow(10, digits);
};

var _getNumber = function(intPart, digits) {
	return _round(Math.random() * Math.pow(10, intPart || 1), digits || 0);
};

var _crudHttpData = function(params, context) {
	context.isTest = true;
	context.login = params.login || context.login || window.globalCtx.getLogin();
	params.endpoint = params.endpoint || context.endpoint || window.globalCtx.getEndpoint("DVLP");
	params.id = params.id || context.testId;
	params.klass = params.klass || context.klass;
	params.representation = params.representation || context.representation;
	params.endpoint = params.endpoint || context.endpoint;
	return sdataUtils.buildCrudData(params, context);
};

// SCENARII
var testCases = [{
	id: "CRUDAQTCRUDM",
	title: "TEST CRUD AQTCRUDM - Persitent entity",
	klass: "AQTCRUD",
	representation: "AQTCRUDM",
	// Default id if no id in test case
	testId: null,
	tests: [{
		// Read records
		action: "query",
		response: {
			callBack: function(testCase, test, send, result) {
				result.callBackMessage = "Nb records=" + ((result.jsonData && result.jsonData.$resources) || []).length;
			}
		}
	}, {
		// Create a record - Step 1 - Read empty object with new id
		action: "template",
		response: {
			status: {
				success: [200]
			},
			callBack: function(testCase, test, send, result) {
				if (result.isSuccess) {
					// ID is returned by $template
					// Save default id in context for next actions
					testCase.context.testId = result.jsonData.CODE;
					result.callBackMessage = "New id is " + result.jsonData.CODE;
				}
			}
		}
	}, {
		// Create a record - Step 2 - Modify fields and Save
		action: "create",
		response: {
			status: {
				success: [201]
			},
			callBack: function(testCase, test, send, result) {
				// Check if modify ok
				if (result.isSuccess) {
					if (result.jsonData.TEXTDES0 == send.send.TEXTDES0 && result.jsonData.TEXTE == send.send.TEXTE) {
						result.callBackMessage = "Record id[" + result.jsonData.CODE + "] saved - Fields updated";
					} else {
						result.status = "error";
						result.callBackMessage = "!! Fields not updated";
					}
				}
			}
		},
		send: function(test, context) {
			var ctx = context.prevJsonData;
			if (ctx) {
				// Mandatory key
				ctx.CODECHR = "{@count}";
				// Fields to modify
				ctx.TEXTDES = "TEXTDES {@time}";
				ctx.TDCB = _getNumber(3, 2);
				ctx.SITE = "ASN";
				return ctx;
			}
			throw new Error("send failed - no edit data");
		}
	}, {
		// Read record - id -> testId
		action: "details",
		response: {
			status: {
				success: [200]
			}
		}
	}, {
		// Edit record - id -> testId
		action: "edit",
		response: {
			status: {
				success: [200]
			}
		}
	}, {
		// Update record - id -> testId - Modify fields and save
		action: "update",
		response: {
			status: {
				success: [200]
			},
			callBack: function(testCase, test, send, result) {
				// Check if modify ok
				if (result.isSuccess) {
					if (result.jsonData.TEXTDES == send.send.TEXTDES && result.jsonData.TDCB == send.send.TDCB) {
						result.callBackMessage = "Fields updated";
					} else {
						result.status = "error";
						result.callBackMessage = "!! Fields not updated";
					}
				}
			}
		},
		send: function(test, context) {
			var ctx = context.prevJsonData;
			if (ctx) {
				ctx.TEXTDES = "TEXTDES {@time}";
				ctx.TDCB = _getNumber(3, 2);
				return ctx;
			}
			throw new Error("skip - no edit data");
		}
	}, {
		// Test method call
		action: "method",
		x3Method: "WADD_LIG44444444",
		x3Params: {},
		send: function(test, context) {
			var ctx = context.prevJsonData;
			if (ctx) {
				ctx.TDCB = 0;
				ctx.TDCB1 = _getNumber(3, 2);
				ctx.TDCB2 = _getNumber(3, 2);
				return ctx;
			}
			throw new Error("skip - no edit data");
		},
		response: {
			status: {
				success: [200]
			},
			callBack: function(testCase, test, send, result) {
				if (result.isSuccess) {
					var TDCB = parseFloat(result.jsonData.TDCB);
					console.log(TDCB);
					var TDCB1 = parseFloat(result.jsonData.TDCB1);
					var TDCB2 = parseFloat(result.jsonData.TDCB2);
					// We use _round because 543.24 + 680.35 -> 1223.5900000000001 with FireFox ???
					var sum = _round(TDCB1 + TDCB2, 2);
					if (TDCB === sum) {
						result.callBackMessage = "Method succeeded -> " + TDCB + " = " + TDCB1 + " + " + TDCB2;
					} else {
						result.status = "error";
						result.callBackMessage = "Method failed -> " + sum + " <> " + TDCB1 + " + " + TDCB2;
					}
				}
			}
		}
	}, {
		// Delete record - id -> testId
		action: "delete",
		id: function(test, context) {
			if (context.prevJsonData) {
				return context.prevJsonData.CODE;
			}
			throw new Error("id failed - no edit data");
		},
		response: {
			status: {
				success: [200, 410]
			}
		}
	}, {
		// Read record - id -> testId - 404 expected
		action: "details",
		response: {
			status: {
				success: [404]
			}
		},
		callBack: function(testCase, test, send, result) {
			// Check if modify ok
			if (result.status == 404) {
				result.callBackMessage = "404 is expected because resource has been deleted previously";
			}
		}
	}]
}, {
	id: "CRUDAQTACTNP",
	title: "TEST CRUD AQTACTNP - Non-Persitent entity",
	klass: "AQTACTNP",
	representation: "AQTACTNPM",
	// Default id if no id in test case
	testId: null,
	tests: [{
		// Create a record - Step 1 - Read empty object with new id
		action: "template",
		response: {
			status: {
				success: [200]
			}
		}
	}, {
		// Test method call
		action: "method",
		x3Method: "WADD_LIG44444444",
		x3Params: {},
		send: function(test, context) {
			var ctx = context.prevJsonData;
			if (ctx) {
				ctx.TDCB = 0;
				ctx.TDCB1 = _getNumber(3, 2);
				ctx.TDCB2 = _getNumber(3, 2);
				return ctx;
			}
			throw new Error("skip - no edit data");
		},
		response: {
			status: {
				success: [200]
			},
			callBack: function(testCase, test, send, result) {
				if (result.isSuccess) {
					var TDCB = parseFloat(result.jsonData.TDCB);
					console.log(TDCB);
					var TDCB1 = parseFloat(result.jsonData.TDCB1);
					var TDCB2 = parseFloat(result.jsonData.TDCB2);
					// We use _round because 543.24 + 680.35 -> 1223.5900000000001 with FireFox ???
					var sum = _round(TDCB1 + TDCB2, 2);
					if (TDCB === sum) {
						result.callBackMessage = "Method succeeded -> " + TDCB + " = " + TDCB1 + " + " + TDCB2;
					} else {
						result.status = "error";
						result.callBackMessage = "Method failed -> " + sum + " <> " + TDCB1 + " + " + TDCB2;
					}
				}
			}
		}
	}]
}];


var _tempo = function(tempo) {
	var deferred = $.Deferred();
	window.setTimeout(function() {
		deferred.resolve();
	}, tempo);
	return deferred.promise();
};
var _defResponse = {
	// Return a {status: status,message:message}
	callBack: null,
	status: {
		success: [200, 201]
	},
	data: null
};
var _execSdata = function(testCase, test) {
	var deferred = $.Deferred();
	var checkResponse = $.extend({}, _defResponse, test.response);
	var stSuccess = checkResponse.status.success || [];
	var stWarning = checkResponse.status.warning || [];
	try {
		var context = testCase.context;
		var http = _crudHttpData(test, context);
		sdataHttp.send(http).always(function(result) {
			var message, title = "Action = " + test.action;
			if (http.id) title += " - Id: " + http.id;
			if (context.login) title += " - User: " + context.login.user;
			title += " - ";
			try {
				title += "HttpStatus = " + result.status;
				message = result.textStatus + " - " + result.descrHttpStatus;
				if (checkResponse.callBack) {
					// Allows customization
					checkResponse.callBack(testCase, test, http, result);
					if (result.callBackMessage) message += "\n" + result.callBackMessage;
				}
				if (result.jsonData && result.jsonData.$diagnoses && result.jsonData.$diagnoses.length > 0) {
					result.jsonData.$diagnoses.forEach(function(d) {
						message += "\nDiagnose - " + d.$severity + " - " + d.$message;
					});
				}
				if (result.exception) message += "\n" + result.exception.message;
				status = stSuccess.indexOf(result.status) >= 0 ? "success" : stWarning.indexOf(result.status) >= 0 ? "warning" : "error";
				// Store last json data - useful for edit->update
				testCase.context.prevJsonData = result.jsonData;
			} catch (e) {
				title += "Javascript Process response Exception";
				log && log(title);
				log && log(e);
				status = "error";
				message = e.message;
				testCase.context.prevJsonData = null;
			} finally {
				testCase.addResult(title, status, message);
				deferred.resolve();
			}
		});
	} catch (e) {
		var ttl = "Javascript execSdata Exception";
		log && log(ttl);
		log && log(e);
		testCase.addResult(ttl, "error", e.message);
		deferred.resolve();
	}
	return deferred.promise();
};

var _execTestCase = function(testset, kase) {
	var deferred = $.Deferred();
	try {
		log && log("_execTestCase - Start - " + kase.title);
		var testCase = testset.addTestcase(kase.title, kase);
		var exec = function(i) {
			if (i < kase.tests.length) {
				log && log("exec test - " + i + " - " + kase.tests[i].action);
				_tempo(i == 0 ? 0 : 100).then(function() {
					_execSdata(testCase, kase.tests[i]).always(function() {
						exec(i + 1);
					});
				});
			} else {
				log && log("_execTestCase - Stop - " + kase.title);
				deferred.resolve();
			}
		};
		exec(0);
	} catch (e) {
		deferred.resolve();
	}
	return deferred.promise();
};

exports.modulename = "sdataStateless";
exports.test = function() {
	var deferred = new $.Deferred();
	try {
		var testset = libTests.addTestset("sdata StateLess Protocol Unit Tests");
		log && log("Start - " + testset.data.title);
		var caseDeferreds = [];
		$.extend(true, [], testCases).forEach(function(kase, idx) {
			caseDeferreds.push(_execTestCase(testset, kase));
		});
		// We nned to pass as many arguments as deferred to synchronize - when doen't accept an array as parameter
		$.when.apply(null, caseDeferreds).then(function() {
			// all deferred have been resolve - parallel call
			deferred.resolve();
		}, function(e) {
			deferred.reject(e, exports.modulename);
		});
	} catch (e) {
		log && log("Test Stateless - Exception");
		log && log(e);
		deferred.reject(e, exports.modulename);
	} finally {
		return deferred.promise();
	}
};