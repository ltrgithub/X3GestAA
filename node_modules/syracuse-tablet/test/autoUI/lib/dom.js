"use strict";

var _webdriver = require('selenium-webdriver');
var driver = require("./driver");
var UT = require("../ut");

function _selectorToString(selector) {
	if (_isWebElement(selector)) {
		return "WebElement";
	} else {
		return JSON.stringify(selector);
	}
}

/**
 * Set value of element
 * Can be input or select tag
 *
 * selector: selector of element or a webelement
 * value: value to set
 * [parent]: Optional parent selector
 */
exports.setValue = function(selector, value, parent) {
	UT.log("Set value: '" + value + "' for " + _selectorToString(selector, parent));
	return _findElement(selector, parent).then(function(element) {
		return element.getTagName().then(function(tagName) {
			if (tagName === "input") {
				return _setInputValue(element, value);
			} else if (tagName === "select") {
				return _setSelectValue(element, value);
			} else {
				return exports.setControlValue(element, value);
			}
		});
	});
};

/**
 * Get value of a field
 */
exports.getValue = function(selector, parent) {
	UT.log("Get value for " + _selectorToString(selector, parent));
	return _findElement(selector, parent).then(function(element) {
		return element.getTagName().then(function(tagName) {
			// Did we select DOM element directly?
			if (tagName === "input") {
				return element.getText();
			} else if (tagName === "select") {
				throw new Error("getValue not yet implemented for select elements");
			}

			return exports.getControlValue(element);
		});
	});
};

/**
 * Gets the value of a DOM element representing a logical control (e.g. generated by protoype/datatype)
 */
exports.getControlValue = function(selector, parent) {
	// Find control in the DOM
	return _findElement(selector, parent)
		.then(function(element) {

			// Check for input tag
			return element.findElement({
				css: "input"
			})
				.thenCatch(function() {
					// Fallback, find value div in details mode
					return element.findElement({
						css: ".s-m-value"
					});
				});
		})
		.then(function(field) {
			return field.getTagName()
				.then(function(tag) {
					return field.getAttribute("value");
				});
		});
};

/**
 * Gets the value of a DOM element representing a logical control (e.g. generated by protoype/datatype)
 */
exports.setControlValue = function(selector, value, parent) {
	// Find control in the DOM
	return _findElement(selector, parent)
		.then(function(element) {
			// Check for input tag
			return element.findElement({
				css: "input"
			});
		})
		.then(function(field) {
			return field.sendKeys(value);
		})
		.then(function() {
			return driver.Browser().executeScript("Window.$unitTestManager.blurFocusElmt();");
		});
};


/**
 * Get attribute of element
 *
 * selector: selector of element or a webelement
 * attr: name of attribute to read
 * [parent]: Optional parent selector
 */
exports.getAttr = function(selector, attr, parent) {
	return _findElement(selector, parent).then(function(element) {
		return element.getAttribute(attr);
	});
};

/**
 * Get attribute of element
 *
 * selector: selector of element or a webelement
 * [parent]: Optional parent selector
 */
exports.getText = function(selector, parent) {
	return _findElement(selector, parent).then(function(element) {
		return element.getText();
	});
};

/**
 * Click an element
 * selector: selector of element or a webelement
 * [parent]: Optional parent selector
 * [waiterPromise]: A promise creating function to chain after
 */
exports.click = function(selector, parent, waiterPromise) {
	UT.log("Click " + _selectorToString(selector, parent));
	return _findElement(selector, parent)
		.then(function(element) {
			return exports.makeVisible(element);
		})
		.then(function(element) {
			return element.click();
		})
		.then(function(e) {
			if (waiterPromise) {
				return waiterPromise();
			}
		});
};

/**
 * Find a DOM element and return it's webelement object
 * selector: selector of element or a webelement
 * [parent]: Optional parent selector
 */
exports.find = function(selector, parent) {
	return _findElement(selector, parent);
};
/**
 * Wait for an element to become visible
 * selector: selector of element
 */
exports.waitVisible = function(selector, timeout) {
	var locate;
	if (_isWebElement(selector)) {
		locate = UT.resolve(selector);
	} else {
		locate = exports.waitLocated(selector, timeout);
	}
	return locate.then(function(element) {
		return driver.Browser().wait(
			driver.Until.elementIsVisible(element),
			timeout);
	});
};

exports.waitVisible$ = function(selector, timeout) {
	return function() {
		return exports.waitVisible(selector, timeout);
	};
};

/***
 *
 */
exports.makeVisible = function(selector, parent) {
	return _findElement(selector, parent)
		.then(function(element) {
			var act = new _webdriver.ActionSequence(driver.Browser());

			return act.mouseMove(element, {
				x: 10,
				y: 10
			}).perform()
				.then(function() {
					return exports.waitVisible(element);
				}).then(function() {
					return UT.sleep(250);
				}).then(function() {
					return element;
				});
		});
};

/**
 * Wait for one element to become available
 * selector: selector of element, if selector is an array of selectors, wait until the first is located
 *
 * Returns the first match
 */
exports.waitLocated = function(selector, timeout) {
	timeout = timeout != null ? timeout : 1;
	UT.log("Wait located: " + _selectorToString(selector));
	if (!Array.isArray(selector)) {
		return driver.Browser().wait(
			driver.Until.elementLocated(selector),
			timeout);
	} else {
		return driver.Browser().wait(
			driver.Until.elementsLocated(function() {
				var deferred = UT.Deferred();
				var founds = [];
				var done = 0;
				selector.forEach(function(sel, idx) {
					driver.Browser().wait(
						driver.Until.elementLocated(sel), 50)
						.then(function(found) {
							founds.push(found);
						})
						.thenCatch(function() {
							// Timeout
						})
						.thenFinally(function() {
							done++;
							if (done === selector.length) {
								if (founds.length > 0) {
									deferred.fulfill(founds[0]);
								}
								// The callback of elementsLocated is called as long as we resolve with null
								deferred.fulfill(null);
							}
						});
				});
				return deferred.promise;
			}), timeout)
			.then(function(elements) {
				return elements[0];
			});
	}
};

exports.waitLocated$ = function(selector, timeout) {
	return function() {
		return exports.waitLocated(selector, timeout);
	};
};

/**
 *
 */
function _setInputValue(element, value) {
	return element.clear()
		.then(function() {
			return element.sendKeys(value);
		});
}

/**
 *
 */
function _setSelectValue(element, value) {
	UT.log("Select option: " + JSON.stringify(UT.SEL.$$Attr("value", value)));
	return element.click()
		.then(function() {
			return UT.sleep(50);
		})
		.then(function() {
			// TODO: NOT SUPPORTED BY EDGE 
			// https://dev.windows.com/en-us/microsoft-edge/platform/status/webdriver/details/
			return element.findElement(UT.SEL.$$Attr("value", value));
		})
		.then(function(optionElement) {
			return optionElement.click();
		});
}

/**
 *
 */
function _findElement(selector, parent) {
	var parentStep;

	// If selector is a webelement already, we resolve immediately
	// this is just so all functions using _findElement can be used with a webelement or a selector
	if (_isWebElement(selector)) {
		return UT.resolve(selector);
	}

	if (parent) {
		if (_isWebElement(parent)) {
			parentStep = UT.resolve(parent);
		} else {
			parentStep = driver.Browser().findElement(parent);
		}
	} else {
		parentStep = UT.resolve(driver.Browser());
	}
	return parentStep.then(function(parentElement) {
		return parentElement.findElement(selector);
	});
}

function _isWebElement(selector) {
	if (selector.driver_) {
		return true;
	}
	return false;
}