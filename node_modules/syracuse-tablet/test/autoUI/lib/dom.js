"use strict";

var _webdriver = require('selenium-webdriver');
var driver = require("./driver");
var UT = require("./ut");

function _selectorToString(selector) {
	if (_isWebElement(selector)) {
		return "WebElement";
	} else {
		return JSON.stringify(selector);
	}
}

/**
 * Set value of element
 * Can be input or select tag
 *
 * selector: selector of element or a webelement
 * value: value to set
 * [parent]: Optional parent selector
 */
exports.setValue = function(selector, value, parent) {
	UT.log("Set value: '" + value + "' for " + _selectorToString(selector, parent));
	var $$element;
	return _findElement(selector, parent)
		.then(function(_$$element) {
			$$element = _$$element;
			UT.log("Found element");
			return driver.Browser().wait(
				driver.Until.elementIsVisible($$element),
				1000)
		})
		.then(function() {
			return $$element.getTagName().then(function(tagName) {
				if (tagName === "input") {
					return _setInputValue($$element, value);
				} else if (tagName === "select") {
					return _setSelectValue($$element, value);
				} else {
					return exports.setControlValue($$element, value);
				}
			});
		});
};

/**
 * Get value of a field
 */
exports.getValue = function(selector, parent) {
	UT.log("Get value for " + _selectorToString(selector, parent));
	return _findElement(selector, parent).then(function($$element) {
		return $$element.getTagName().then(function(tagName) {
			// Did we select DOM element directly?
			if (tagName === "input") {
				return $$element.getText();
			} else if (tagName === "select") {
				throw new Error("getValue not yet implemented for select elements");
			}

			return exports.getControlValue($$element);
		});
	});
};

/**
 * Gets the value of a DOM element representing a logical control (e.g. generated by protoype/datatype)
 */
exports.getControlValue = function(selector, parent) {
	// Find control in the DOM
	return _findElement(selector, parent)
		.then(function($$element) {

			// Check for input tag
			return $$element.findElement({
					css: "input"
				})
				.catch(function() {
					// Fallback, find value div in details mode
					return $$element.findElement({
						css: ".s-m-value"
					});
				});
		})
		.then(function($$field) {
			return $$field.getTagName()
				.then(function(tag) {
					if (tag === "input") {
						return $$field.getAttribute("value");
					} else {
						return $$field.getText();
					}
				});
		});
};

/**
 * Gets the value of a DOM element representing a logical control (e.g. generated by protoype/datatype)
 */
exports.setControlValue = function(selector, value, parent) {
	// Find control in the DOM
	return _findElement(selector, parent)
		.then(function($$element) {
			// Check for input tag
			return $$element.findElement({
					css: "input"
				})
				.catch(function() {
					// No input found, try find select
					return $$element.findElement({
						css: "select"
					});
				});
		})
		.then(function($$field) {
			// Now we found the DOM element (either input or select) in the control, so set it
			return exports.setValue($$field, value);
		})
		.then(function() {
			return driver.Browser().executeScript("window.$unitTestManager.blurFocusElmt();");
		});
};


/**
 * Get attribute of element
 *
 * selector: selector of element or a webelement
 * attr: name of attribute to read
 * [parent]: Optional parent selector
 */
exports.getAttr = function(selector, attr, parent) {
	return _findElement(selector, parent).then(function($$element) {
		return $$element.getAttribute(attr);
	});
};

/**
 * Get attribute of element
 *
 * selector: selector of element or a webelement
 * [parent]: Optional parent selector
 */
exports.getText = function(selector, parent) {
	return _findElement(selector, parent).then(function($$element) {
		return $$element.getText();
	});
};

/**
 * Click an element
 * selector: selector of element or a webelement
 * [parent]: Optional parent selector
 * [waiterPromise]: A promise creating function to chain after
 */
exports.click = function(selector, parent, waiterPromise) {
	UT.log("Click " + _selectorToString(selector, parent));
	return _findElement(selector, parent)
		.then(function($$element) {
			return exports.makeVisible($$element);
		})
		.then(function($$element) {
			return $$element.click();
		})
		.then(function() {
			if (waiterPromise) {
				return waiterPromise();
			}
		});
};

/**
 * Find a DOM element and return it's webelement object
 * selector: selector of element or a webelement
 * [parent]: Optional parent selector
 */
exports.find = function(selector, parent) {
	return _findElement(selector, parent);
};
/**
 * Wait for an element to become visible
 * selector: selector of element
 */
exports.waitVisible = function(selector, timeout) {
	var locate;
	if (_isWebElement(selector)) {
		locate = UT.resolve(selector);
	} else {
		locate = exports.waitLocated(selector, timeout);
	}
	return locate.then(function($$element) {
		return driver.Browser().wait(
			driver.Until.elementIsVisible($$element),
			timeout);
	});
};

exports.waitVisible$ = function(selector, timeout) {
	return function() {
		return exports.waitVisible(selector, timeout);
	};
};

/***
 *
 */
exports.makeVisible = function(selector, parent) {
	return _findElement(selector, parent)
		.then(function($$element) {
			var act = new _webdriver.ActionSequence(driver.Browser());

			return act.mouseMove($$element, {
					x: 10,
					y: 10
				}).perform()
				.then(function() {
					// does not work if overlay with opacity 0 is used since it's
					// considered to be invisible
					//return exports.waitVisible($$element, 500);
				}).then(function() {
					return UT.sleep(250);
				}).then(function() {
					return $$element;
				});
		});
};

/**
 * Wait for one element to become available
 * selector: selector of element, if selector is an array of selectors, wait until the first is located
 *
 * Returns the first match
 */
exports.waitLocated = function(selector, timeout) {
	timeout = timeout != null ? timeout : 1;
	UT.log("Wait located: " + _selectorToString(selector));
	if (!Array.isArray(selector)) {
		return driver.Browser().wait(
			driver.Until.elementLocated(selector),
			timeout);
	} else {
		return driver.Browser().wait(
				driver.Until.elementsLocated(function() {
					var deferred = UT.Deferred();
					var founds = [];
					var done = 0;
					selector.forEach(function(sel, idx) {
						driver.Browser().wait(
								driver.Until.elementLocated(sel), 50)
							.then(function(found) {
								founds.push(found);
							})
							.catch(function() {
								// Timeout
							})
							.finally(function() {
								done++;
								if (done === selector.length) {
									if (founds.length > 0) {
										deferred.fulfill(founds[0]);
									}
									// The callback of elementsLocated is called as long as we resolve with null
									deferred.fulfill(null);
								}
							});
					});
					return deferred.promise;
				}), timeout)
			.then(function(elements) {
				return elements[0];
			});
	}
};

exports.waitLocated$ = function(selector, timeout) {
	return function() {
		return exports.waitLocated(selector, timeout);
	};
};

/**
 * Check if the give webElement is a specific modal
 */
exports.isModal = function(webElement, modalName) {
	return webElement.getAttribute("class").then(function(value) {
		return value.indexOf(modalName) > -1;
	});
};

/**
 *
 */
function _setInputValue($$element, value) {
	return $$element.clear()
		.then(function() {
			return $$element.sendKeys(value);
		});
}

/**
 *
 */
function _setSelectValue($$element, value) {
	UT.log("Select option: " + JSON.stringify(UT.Sel.Attr("value", value)));
	return $$element.click()
		.then(function() {
			return UT.sleep(50);
		})
		.then(function() {
			// TODO: NOT SUPPORTED BY EDGE 
			// https://dev.windows.com/en-us/microsoft-edge/platform/status/webdriver/details/
			return $$element.findElement(UT.Sel.Attr("value", value));
		})
		.then(function($$optionElement) {
			return $$optionElement.click();
		});
}

/**
 *
 */
function _findElement(selector, parent) {
	var parentStep;

	// If selector is a webelement already, we resolve immediately
	// this is just so all functions using _findElement can be used with a webelement or a selector
	if (_isWebElement(selector)) {
		return UT.resolve(selector);
	}

	if (parent) {
		if (_isWebElement(parent)) {
			parentStep = UT.resolve(parent);
		} else {
			parentStep = driver.Browser().findElement(parent);
		}
	} else {
		parentStep = UT.resolve(driver.Browser());
	}
	return parentStep.then(function($$parentElement) {
		return $$parentElement.findElement(selector);
	});
}

function _isWebElement(selector) {
	if (selector.driver_) {
		return true;
	}
	return false;
}

exports.getPageCycle = function(selector, parent) {
	// Find control in the DOM
	return _findElement(selector, parent)
		.then(function($$page) {
			return $$page.getAttribute("data-s-ut-update-cycle");
		});
};

exports.waitPageCycleChange = function(selector, parent, cycle) {
	// Find control in the DOM
	UT.log("Await cycle change from: " + cycle);
	return _findElement(selector, parent)
		.then(function($$page) {
			return driver.Browser().wait(function() {
				return $$page.getAttribute("data-s-ut-update-cycle")
					.then(function(domCycle) {
						// UT.log("Cycle check: old: " + cycle + " new: " + domCycle);
						return domCycle !== cycle;
					});
			});
		});
}