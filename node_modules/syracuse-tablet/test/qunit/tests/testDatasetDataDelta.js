"use strict";

/*
 * Test Dataset internal methods for value getting/setting and delta/data management
 */

var sdataReq = require("syracuse-tablet/html/js/wc/sdata/sdataRequester");
var mock = require("syracuse-tablet/test/qunit/tests/fixtures/datasetFixtures");

function _getDataset(name, dataName, protoName) {
	var data = $.extend(true, {}, mock.fixtures[name][dataName]);
	var proto = $.extend(true, {}, mock.fixtures[name][protoName]);
	var pageData = sdataReq.createPageDataJson(data, proto);
	return pageData.dataset;
}

QUnit.module("Mock-Dataset, manipulate data", function() {

	QUnit.test("Delta+data, simple prop", function(assert) {
		var ds;

		return $.smResolve()
			.then(function(result) {
				ds = _getDataset("AQMCRUDM.$edit", "CODE=8", "prototype");
			})
			.then(function() {
				var delta = ds.getDataDelta();
				var expectedKeys = ["$etag", "$url", "$uuid"];
				assert.deepEqual(Object.keys(delta).sort(), expectedKeys.sort(), "Mandatory keys only on empty delta");
			})
			.then(function() {
				// Simple prop
				ds.setValue("TEXTAXX", "0"); // set 2x to ensure it's dirty
				ds.setValue("TEXTAXX", "1");

				var delta = ds.getDataDelta();
				assert.equal(delta.TEXTAXX, "1", "Text has been set");
			})
			.always(function() {
				assert.expect(2);
			});
	});

	QUnit.test("Delta+data, ref prop", function(assert) {
		var ds;

		return $.smResolve()
			.then(function(result) {
				ds = _getDataset("AQMCRUDM.$edit", "CODE=8", "prototype");
			})
			.then(function() {
				var delta = ds.getDataDelta();
				var expectedKeys = ["$etag", "$url", "$uuid"];
				assert.deepEqual(Object.keys(delta).sort(), expectedKeys.sort(), "Mandatory keys only on empty delta");
			})
			.then(function() {
				ds.setValue('WCUR_REF', 'EUR');
				ds.setValue('WCUR_REF', 'USD');

				var delta = ds.getDataDelta();
				assert.deepEqual(delta.WCUR_REF, {}, "Currency reference has been emptied");
				assert.equal(delta.WCUR, "USD", "Currency has been set");
			})
			.always(function() {
				assert.expect(3);
			});
	});

	QUnit.test("Delta+data, array, simple and ref props", function(assert) {
		var ds;

		return $.smResolve()
			.then(function(result) {
				ds = _getDataset("AQMCRUDM.$edit", "CODE=8", "prototype");
			})
			.then(function() {
				// Simple prop
				var array = ds.getChild("ADEVADEVICEL");
				var row = array.getRowByIndex(1);
				row.setValue("ADEV_TEXTAXX", "1");
				row.setValue("ADEV_TEXTAXX", "2");

				var delta = ds.getDataDelta();

				assert.notEqual(delta.ADEVADEVICEL, null, "Complex row: Array in delta");
				assert.equal(delta.ADEVADEVICEL.length, 1, "Complex row: length ok");
				assert.notEqual(delta.ADEVADEVICEL[0].$uuid, null, "Complex row: $uuid of line set");
				assert.equal(delta.ADEVADEVICEL[0].ADEV_TEXTAXX, "2", "Complex row: Value matches");

				var data = ds.getData();
				assert.notEqual(data.ADEVADEVICEL, null, "Complex row: Array in data");
				assert.equal(data.ADEVADEVICEL.length, 4, "Complex row: length ok");
				assert.notEqual(data.ADEVADEVICEL[1].$uuid, null, "Complex row: $uuid of line set");
				assert.equal(data.ADEVADEVICEL[1].ADEV_TEXTAXX, "2", "Complex row: Value matches");
			})
			.then(function() {
				var array = ds.getChild("ADEVCTINT");
				var row = array.getRowByIndex(2);
				row.setValue("$value", 10);
				row.setValue("$value", 20);

				var delta = ds.getDataDelta();

				assert.notEqual(delta.ADEVCTINT, null, "Simple row: Array in delta");
				assert.equal(delta.ADEVCTINT.length, 4, "Simple row: length ok");
				assert.equal(delta.ADEVCTINT[2].$uuid, null, "Simple row: $uuid must not be set");
				assert.equal(delta.ADEVCTINT[2], 20, "Simple row: Value matches");

				var data = ds.getData();
				assert.notEqual(data.ADEVCTINT, null, "Simple row: Array in data");
				assert.equal(data.ADEVCTINT.length, 4, "Simple row: length ok");
				assert.equal(data.ADEVCTINT[2].$uuid, null, "Simple row: $uuid must not be set");
				assert.equal(data.ADEVCTINT[2], 20, "Simple row: Value matches");
			})
			.then(function() {
				var array = ds.getChild("ADEVCOLREF1");
				var row = array.getRowByIndex(1);
				row.setValue("FCY", "EUR");
				row.setValue("FCY", "USD");

				var delta = ds.getDataDelta();
				assert.notEqual(delta.ADEVCOLREF1, null, "Simple reference row: Array in delta");
				assert.equal(delta.ADEVCOLREF1.length, 3, "Simple reference row: length ok");
				assert.equal(delta.ADEVCOLREF1[1].FCY, "USD", "Simple reference row: Value matches");

				var data = ds.getData();
				assert.notEqual(data.ADEVCOLREF1, null, "Simple reference row: Array in data");
				assert.equal(data.ADEVCOLREF1.length, 3, "Simple reference row: length ok");
				assert.equal(data.ADEVCOLREF1[1].FCY, "USD", "Simple reference row: Value matches");
			})
			.always(function() {
				assert.expect(22);
			});
	});


	QUnit.test("Delta+data, complex array, move rows", function(assert) {
		var ds;

		return $.smResolve()
			.then(function(result) {
				ds = _getDataset("AQMCRUDM.$edit", "CODE=8", "prototype");
			})
			.then(function() {
				var array = ds.getChild("ADEVADEVICEL");
				// move first row to the end
				array.moveRow("f82e0b67-1e63-4773-89bc-4524a45a6185", 3);
				// move row that was the last one at the very beginning to the second row
				array.moveRow("239535b5-29b8-44a7-826e-4b9c35b20d17", 1);

			})
			.then(function() {
				var delta = ds.getDataDelta();

				assert.notEqual(delta.ADEVADEVICEL, null, "Complex array: Array in delta");
				assert.equal(delta.ADEVADEVICEL.length, 4, "Complex array:: Size ok");
				assert.equal(delta.ADEVADEVICEL[0].$uuid, "7178ee42-2eb9-47b6-9126-81fe7bd7559b", "Delta, row 1 ok");
				assert.equal(delta.ADEVADEVICEL[1].$uuid, "239535b5-29b8-44a7-826e-4b9c35b20d17", "Delta, row 2 ok");
				assert.equal(delta.ADEVADEVICEL[2].$uuid, "e7f216f8-120c-4134-8ec1-011d52d1a1f7", "Delta, row 3 ok");
				assert.equal(delta.ADEVADEVICEL[3].$uuid, "f82e0b67-1e63-4773-89bc-4524a45a6185", "Delta, row 4 ok");

				var data = ds.getData();
				assert.notEqual(data.ADEVADEVICEL, null, "Complex array: Array in data");
				assert.equal(data.ADEVADEVICEL.length, 4, "Complex array:: Data size ok");
				assert.equal(data.ADEVADEVICEL[0].$uuid, "7178ee42-2eb9-47b6-9126-81fe7bd7559b", "Data, row 1 ok");
				assert.equal(data.ADEVADEVICEL[1].$uuid, "239535b5-29b8-44a7-826e-4b9c35b20d17", "Data, r2 ok");
				assert.equal(data.ADEVADEVICEL[2].$uuid, "e7f216f8-120c-4134-8ec1-011d52d1a1f7", "Data, row 3 ok");
				assert.equal(data.ADEVADEVICEL[3].$uuid, "f82e0b67-1e63-4773-89bc-4524a45a6185", "Data, row 4 ok");
			})
			.always(function() {
				assert.expect(12);
			});
	});

	QUnit.test("Delta+data, simple int array, move rows", function(assert) {
		var ds;

		return $.smResolve()
			.then(function(result) {
				ds = _getDataset("AQMCRUDM.$edit", "CODE=8", "prototype");
			})
			.then(function() {
				var array = ds.getChild("ADEVCTINT");
				var first = array.getRowByIndex(0);
				var last = array.getRowByIndex(3);

				array.moveRow(first.getValue("$uuid"), 3);
				array.moveRow(last.getValue("$uuid"), 1);
			})
			.then(function() {
				var delta = ds.getDataDelta();

				// Check changes in ADEVADEVICEL
				assert.notEqual(delta.ADEVCTINT, null, "Int array: Array in delta");
				assert.equal(delta.ADEVCTINT.length, 4, "Int array: Size ok");
				assert.equal(delta.ADEVCTINT[0], 2, "Row 1 ok");
				assert.equal(delta.ADEVCTINT[1], 4, "Row 2 ok");
				assert.equal(delta.ADEVCTINT[2], 3, "Row 3 ok");
				assert.equal(delta.ADEVCTINT[3], 1, "Row 4 ok");

				var data = ds.getData();
				assert.notEqual(data.ADEVCTINT, null, "Int array: Array in data");
				assert.equal(data.ADEVCTINT.length, 4, "Int array: Size ok");
				assert.equal(data.ADEVCTINT[0], 2, "Row 1 ok");
				assert.equal(data.ADEVCTINT[1], 4, "Row 2 ok");
				assert.equal(data.ADEVCTINT[2], 3, "Row 3 ok");
				assert.equal(data.ADEVCTINT[3], 1, "Row 4 ok");
			})
			.always(function() {
				assert.expect(12);
			});
	});

	QUnit.test("Delta+data, simple ref array, move rows", function(assert) {
		var ds;

		return $.smResolve()
			.then(function(result) {
				ds = _getDataset("AQMCRUDM.$edit", "CODE=8", "prototype");
			})
			.then(function() {
				var array = ds.getChild("ADEVCOLREF1");
				var first = array.getRowByIndex(0);
				var last = array.getRowByIndex(2);

				array.moveRow(last.getValue("$uuid"), 1);
				array.moveRow(first.getValue("$uuid"), 2);
			})
			.then(function() {
				var delta = ds.getDataDelta();
				assert.notEqual(delta.ADEVCOLREF1, null, "Ref array: Array in delta");
				assert.equal(delta.ADEVCOLREF1.length, 3, "Ref array: Size ok");
				assert.equal(delta.ADEVCOLREF1[0].FCY, "081", "Row 1 ok");
				assert.equal(delta.ADEVCOLREF1[1].FCY, "073CH", "Row 2 ok");
				assert.equal(delta.ADEVCOLREF1[2].FCY, "AMB", "Row 3 ok");

				var data = ds.getData();
				assert.notEqual(data.ADEVCOLREF1, null, "Ref array: Array in data");
				assert.equal(data.ADEVCOLREF1.length, 3, "Ref array: Size ok");
				assert.equal(data.ADEVCOLREF1[0].FCY, "081", "Row 1 ok");
				assert.equal(data.ADEVCOLREF1[1].FCY, "073CH", "Row 2 ok");
				assert.equal(data.ADEVCOLREF1[2].FCY, "AMB", "Row 3 ok");
			})
			.always(function() {
				assert.expect(10);
			});
	});

	QUnit.test("Data, no changes, data not referenced", function(assert) {
		var ds;
		return $.smResolve()
			.then(function(result) {
				ds = _getDataset("AQMCRUDM.$edit", "CODE=8", "prototype");
			})
			.then(function() {
				var data = ds.getData();
				assert.equal(data.SITE, "0031", "Simple value: value ok");

				assert.notEqual(data.ADEVCOLREF1, null, "Simple reference row: Array in data");
				assert.equal(data.ADEVCOLREF1.length, 3, "Simple reference row: Array size ok");
				assert.equal(data.ADEVCOLREF1[0].FCY, "AMB", "Simple reference row: Array data value ok");
				assert.equal(data.ADEVCOLREF1[1].FCY, "073CH", "Simple reference row: Array data value ok");
				assert.equal(data.ADEVCOLREF1[2].FCY, "081", "Simple reference row: Array data value ok");

				assert.notEqual(data.ADEVCTINT, null, "Simple value row: Array in data");
				assert.equal(data.ADEVCTINT.length, 4, "Simple value row: Array size ok");
				assert.equal(data.ADEVCTINT[0], 1, "Simple value row: Array data value ok");
				assert.equal(data.ADEVCTINT[1], 2, "Simple value row: Array data value ok");
				assert.equal(data.ADEVCTINT[2], 3, "Simple value row: Array data value ok");
				assert.equal(data.ADEVCTINT[3], 4, "Simple value row: Array data value ok");

				assert.equal(data.ADEVADEVICEL[0].$uuid, "f82e0b67-1e63-4773-89bc-4524a45a6185", "Row 1 ok");
				assert.equal(data.ADEVADEVICEL[1].$uuid, "7178ee42-2eb9-47b6-9126-81fe7bd7559b", "Row 2 ok");
				assert.equal(data.ADEVADEVICEL[2].$uuid, "e7f216f8-120c-4134-8ec1-011d52d1a1f7", "Row 3 ok");
				assert.equal(data.ADEVADEVICEL[3].$uuid, "239535b5-29b8-44a7-826e-4b9c35b20d17", "Row 4 ok");


			})
			.always(function() {
				assert.expect(16);
			});
	});

	QUnit.test("Data, no changes, read data before getting full data", function(assert) {
		function _readFullArray(dataset, $bind) {
			var array = ds.getChild($bind);
			var rows = array.getNumRows();
			for (var i = 0; i < rows; i++) {
				var row = array.getRowByIndex(i);
			}
		};

		var ds;

		return $.smResolve()
			.then(function(result) {
				ds = _getDataset("AQMCRUDM.$edit", "CODE=8", "prototype");
			})
			.then(function() {
				// Important to reference all arrary before because this will wrap the simple type arrays
				// and we neet to check i getData "unwrapps" them later
				// 
				// read before getting data
				_readFullArray(ds, "ADEVCTINT");
				_readFullArray(ds, "ADEVCOLREF1");
				_readFullArray(ds, "ADEVADEVICEL");

				var data = ds.getData();
				assert.equal(data.SITE, "0031", "Simple value: value ok");

				assert.notEqual(data.ADEVCOLREF1, null, "Simple reference row: Array in data");
				assert.equal(data.ADEVCOLREF1.length, 3, "Simple reference row: Array size ok");
				assert.equal(data.ADEVCOLREF1[0].FCY, "AMB", "Simple reference row: Array data value ok");
				assert.equal(data.ADEVCOLREF1[1].FCY, "073CH", "Simple reference row: Array data value ok");
				assert.equal(data.ADEVCOLREF1[2].FCY, "081", "Simple reference row: Array data value ok");

				assert.notEqual(data.ADEVCTINT, null, "Simple value row: Array in data");
				assert.equal(data.ADEVCTINT.length, 4, "Simple value row: Array size ok");
				assert.equal(data.ADEVCTINT[0], 1, "Simple value row: Array data value ok");
				assert.equal(data.ADEVCTINT[1], 2, "Simple value row: Array data value ok");
				assert.equal(data.ADEVCTINT[2], 3, "Simple value row: Array data value ok");
				assert.equal(data.ADEVCTINT[3], 4, "Simple value row: Array data value ok");

				assert.equal(data.ADEVADEVICEL[0].$uuid, "f82e0b67-1e63-4773-89bc-4524a45a6185", "Row 1 ok");
				assert.equal(data.ADEVADEVICEL[1].$uuid, "7178ee42-2eb9-47b6-9126-81fe7bd7559b", "Row 2 ok");
				assert.equal(data.ADEVADEVICEL[2].$uuid, "e7f216f8-120c-4134-8ec1-011d52d1a1f7", "Row 3 ok");
				assert.equal(data.ADEVADEVICEL[3].$uuid, "239535b5-29b8-44a7-826e-4b9c35b20d17", "Row 4 ok");
			})
			.always(function() {
				assert.expect(16);
			});
	});

	QUnit.test("Data, no changes, read data after getting full data", function(assert) {
		function _readFullArray(dataset, $bind) {
			var array = ds.getChild($bind);
			var rows = array.getNumRows();
			for (var i = 0; i < rows; i++) {
				var row = array.getRowByIndex(i);
			}
		};

		var ds;

		return $.smResolve()
			.then(function(result) {
				ds = _getDataset("AQMCRUDM.$edit", "CODE=8", "prototype");
			})
			.then(function() {
				var data = ds.getData();

				// Important to reference all arrary before because this will wrap the simple type arrays
				// and we neet to check i getData "unwrapps" them later
				// 
				// read before getting data
				_readFullArray(ds, "ADEVCTINT");
				_readFullArray(ds, "ADEVCOLREF1");
				_readFullArray(ds, "ADEVADEVICEL");

				assert.equal(data.SITE, "0031", "Simple value: value ok");

				assert.notEqual(data.ADEVCOLREF1, null, "Simple reference row: Array in data");
				assert.equal(data.ADEVCOLREF1.length, 3, "Simple reference row: Array size ok");
				assert.equal(data.ADEVCOLREF1[0].FCY, "AMB", "Simple reference row: Array data value ok");
				assert.equal(data.ADEVCOLREF1[1].FCY, "073CH", "Simple reference row: Array data value ok");
				assert.equal(data.ADEVCOLREF1[2].FCY, "081", "Simple reference row: Array data value ok");

				assert.notEqual(data.ADEVCTINT, null, "Simple value row: Array in data");
				assert.equal(data.ADEVCTINT.length, 4, "Simple value row: Array size ok");
				assert.equal(data.ADEVCTINT[0], 1, "Simple value row: Array data value ok");
				assert.equal(data.ADEVCTINT[1], 2, "Simple value row: Array data value ok");
				assert.equal(data.ADEVCTINT[2], 3, "Simple value row: Array data value ok");
				assert.equal(data.ADEVCTINT[3], 4, "Simple value row: Array data value ok");

				assert.equal(data.ADEVADEVICEL[0].$uuid, "f82e0b67-1e63-4773-89bc-4524a45a6185", "Row 1 ok");
				assert.equal(data.ADEVADEVICEL[1].$uuid, "7178ee42-2eb9-47b6-9126-81fe7bd7559b", "Row 2 ok");
				assert.equal(data.ADEVADEVICEL[2].$uuid, "e7f216f8-120c-4134-8ec1-011d52d1a1f7", "Row 3 ok");
				assert.equal(data.ADEVADEVICEL[3].$uuid, "239535b5-29b8-44a7-826e-4b9c35b20d17", "Row 4 ok");


			})
			.always(function() {
				assert.expect(16);
			});
	});
});