"use strict";
(function($) {
	var that = $.smobile;
	var $proto = $.proto;
	var $helpers = $.helpers;
	that.controls = that.controls || {};
	that.controls.Gauge = {

		// default gauge segments if not defined differently by authoring
		_defaultGaugeSegments: [{
			propStart: 0,
			propEnd: 0.25,
			valStart: null,
			valEnd: null,
			color: '#55BF3B'
		}, {
			propStart: 0.25,
			propEnd: 0.75,
			valStart: null,
			valEnd: null,
			color: '#DDDF0D'
		}, {
			propStart: 0.75,
			propEnd: 1,
			valStart: null,
			valEnd: null,
			color: '#DF5353'
		}],
		_resolveExpr: function(expr, data, cp) {
			if (typeof expr !== "string")
				return expr;
			return expr.replace(/\{(\w+)\}/g, function(d0, d1) {
				if (data[d1] != null)
					return data[d1];
				if (cp[d1] != null)
					return cp[d1];
				return d0;
			});
		},
		// Merge default values for gauge segments with data comming from the authoring
		_mergeAuthoringAndDefaults: function($gauge) {
			if (!$gauge.segments) // Not authoring on segments
				return that.controls.Gauge._defaultGaugeSegments;
			if ($gauge.segments.length === 0) // Not authoring on segments
				return that.controls.Gauge._defaultGaugeSegments;

			var s, def, auth, res = [];
			for (s = 0; s < $gauge.segments.length; s++) {
				def = that.controls.Gauge._defaultGaugeSegments[Math.min(s, that.controls.Gauge._defaultGaugeSegments.length - 1)];
				auth = $gauge.segments[s];
				if (!auth) {
					// no authoring for this segment, use default
					res.push(def);
				} else {
					if ((auth.propStart == null || auth.propEnd == null) &&
						(auth.valStart == null || auth.valEnd == null)) {
						// not range defined, use default, not authoring
						auth.propStart = def.propStart;
						auth.propEnd = def.propEnd;
						auth.valStart = def.valStart;
						auth.valEnd = def.valEnd;
					}
					if (auth.color == null) {
						auth.color = def.color;
					}
					res.push(auth);
				}
			}
			return res;
		},
		// Create segment definitions for gauge
		_createBands: function(controller, $c, c, cp, valMin, valMax) {
			var options = c && c.options;
			var bands = [];

			// Grey background is always present
			bands.push({
				from: valMin,
				to: valMax,
				color: '#ccc',
				innerRadius: '79%',
				outerRadius: '101%'
			});

			var data = controller.getValue();
			var bandsDef = that.controls.Gauge._mergeAuthoringAndDefaults(options.gauge);
			var seg;
			var s;
			var band;
			var range = valMax - valMin;
			for (s = 0; s < bandsDef.length; s++) {
				seg = bandsDef[s];
				band = {
					innerRadius: '79%',
					outerRadius: '101%',
					color: seg.color
				};
				if (seg.valStart != null && seg.valEnd != null) {
					band.from = that.controls.Gauge._resolveExpr(seg.valStart, data, cp);
					band.to = that.controls.Gauge._resolveExpr(seg.valEnd, data, cp);
				} else if (seg.propStart != null && seg.propEnd != null) {
					band.from = valMin + range * that.controls.Gauge._resolveExpr(seg.propStart, data, cp);
					band.to = valMin + range * that.controls.Gauge._resolveExpr(seg.propEnd, data, cp);
				}
				bands.push(band);
			}
			return bands;
		},
		_renderGauge: function(controller, $c, c) {
			var options = c && c.options;
			var bind = options.bind || options.$bind;
			var labelColor = (controller.page && controller.page.indexOf("$details") > -1) ? "#34B233" : "#666";

			var val = controller.getValue(bind, null, 0);
			var valMin = 0;
			var valMax = 100;

			if (options.gauge.$bindMin != null && options.gauge.$bindMax != null) {
				if (typeof options.gauge.$bindMin === "string")
					valMin = controller.getValue(options.gauge.$bindMin, null, 0);
				else
					valMin = options.gauge.$bindMin;
				if (typeof options.gauge.$bindMax === "string")
					valMax = controller.getValue(options.gauge.$bindMax, null, 0);
				else
					valMax = options.gauge.$bindMax;
			}

			try {
				if (typeof val === "string") val = parseFloat(val);
			} catch (e) {}
			try {
				if (typeof valMin === "string") valMin = parseFloat(valMin);
			} catch (e) {}
			try {
				if (typeof valMax === "string") valMax = parseFloat(valMax);
			} catch (e) {}

			var page = controller.getPageData();
			var cp = $proto.getProto(page, bind);
			var dd = controller.getValue();

			var uom = "";
			if (cp.$rprotoparent && cp.$rprotoparent.$properties[cp.$unit] &&
				dd && dd[cp.$unit] && dd[cp.$unit].$symbol) {
				uom = dd[cp.$unit].$symbol;
			}

			var label = ((options && options.label) || "");
			var $cont = $c.find('#' + c.id + "_cont");
			var decimals = (options && options.decimals !== null) ? options.decimals : 0;

			var plotBands = that.controls.Gauge._createBands(controller, $c, c, cp, valMin, valMax);
			$cont.highcharts({
					chart: {
						type: 'gauge',
						plotBackgroundColor: null,
						plotBackgroundImage: null,
						plotBorderWidth: 0,
						plotShadow: false,
						backgroundColor: null,
						height: 180
					},
					title: {
						text: label,
						style: {
							color: labelColor
						}
					},
					pane: {
						startAngle: -90,
						endAngle: 90,
						center: ['50%', '90%'],
						size: 210,
						background: [{
							backgroundColor: '#FFF',
							borderWidth: 0
						}]
					},
					yAxis: {
						min: valMin,
						max: valMax,

						minorTickWidth: 1,
						minorTickInterval: 'auto',
						minorTickLength: 20,
						minorTickPosition: 'inside',
						minorTickColor: '#fff',

						tickPixelInterval: 30,
						tickWidth: 0,
						tickPosition: 'inside',
						tickLength: 15,
						tickColor: '#FFF',
						labels: {
							step: 1,
							rotation: 'auto',
							style: {
								color: "#666",
								cursor: "default",
								fontSize: "12px",
								lineHeight: "14px"
							},
							distance: 3
						},
						title: {
							text: uom,
							style: {
								color: "#666"
							}
						},
						plotBands: plotBands
					},
					plotOptions: {
						gauge: {
							dataLabels: {
								enabled: true,
								format: "{point.y:,." + decimals + "f}"
							}
						}
					},
					series: [{
						name: label,
						data: [val],
						tooltip: {
							valueSuffix: ' ' + uom
						}
					}]

				},
				function() {});
		},
		createGauge: function(controller, c) {
			var options = c.data;
			var html = [];
			html.push('<div id="' + c.id + '">');
			html.push('<div id="' + c.id + '_cont" class="ui-body s-m-gauge-container" >');
			html.push('</div>');
			html.push('</div>');

			if (!that.ChartsTheme.themeWasSet ||
				that.ChartsTheme.decimalPoint !== $helpers.number.decimalSep ||
				that.ChartsTheme.thousandsSep !== $helpers.number.thousandSep) {
				that.ChartsTheme.decimalPoint = $helpers.number.decimalSep;
				that.ChartsTheme.thousandsSep = $helpers.number.thousandSep;

				Highcharts.setOptions(that.ChartsTheme);
				that.ChartsTheme.themeWasSet = true;
			}

			return {
				html: html.join(''),
				bind: options.bind,
				options: options
			};
		},
		sync: true,
		handler: function(c, after) {
			return after(that.controls.Gauge.createGauge(this, after));
		},
		checkValue: function( /*$c, c*/ ) {
			// nothing to do since value of gauge cannot be changed by the user
		},
		events: function($c, c) {
			var controller = this;
			that.controls.Gauge._renderGauge(controller, $c, c);
		}
	};
})(jQuery);