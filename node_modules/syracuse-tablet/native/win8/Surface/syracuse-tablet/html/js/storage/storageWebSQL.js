define(function(require, exports, module) {
"use strict";

/*
 * WebSQL storage interface (Chrome, Safari)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("webSQL");

var _databaseName = "sage-mmd";

//Increase this number to upgrade database to schema described in _objectStores
var _databaseVersion = 12;

var _tables = [
	// meta data table for handling etags, ttl, size, ..
	"DROP TABLE IF EXISTS sdata_meta",
	"CREATE TABLE sdata_meta ( " +
	"key text, " +
	"collection text, " +
	"context text, " +
	"id text, " +
	"etag text, " +
	"last_read text" +
	")",
	"DROP INDEX IF EXISTS sdata_meta_pk",
	"CREATE UNIQUE INDEX sdata_meta_pk ON sdata_meta (key, collection, context)",
	"DROP INDEX IF EXISTS sdata_meta_id",
	"CREATE UNIQUE INDEX sdata_meta_id ON sdata_meta (id)",
	// data table
	"DROP TABLE IF EXISTS sdata_objects",
	"CREATE TABLE sdata_objects ( " +
	"id text, " +
	"data text " +
	")",
	"DROP INDEX IF EXISTS sdata_objects_pk",
	"CREATE UNIQUE INDEX sdata_objects_pk ON sdata_objects (id)"
];

function _StorageInterfaceWebSQL() {
	this.infoString = "WebSQL storage interface";
	this.databaseVersion = _databaseVersion;
	this.databaseName = _databaseName;
	this.useTestDatabase = false;
	this.databaseSize = 2 * 1024 * 1024;
	this.db = null;
};

var _storageInterfaceWebSQLClass = utils.defineClass(
	_StorageInterfaceWebSQL,
	storageInterface.StorageInterface, {
		init: function() {
			var deferred = $.Deferred();
			var self = this;
			var useTestDatabase = utils.isTestEnvironment();
			self.databaseName = _databaseName + "-test";
			self.useTestDatabase = useTestDatabase;
			try {
				self._openDB().then(function(status) {
					deferred.resolve(status);
				}, function(status) {
					deferred.reject(status);
				});
			} catch (e) {
				deferred.reject(storageInterface.buildResult(storageInterface.StatusCodes.ERROR, null, "error initializing database", e));
			} finally {
				return deferred.promise();
			}
		},
		put: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("PUT: ", opts);

				var context = JSON.stringify(opts.$context);
				var params = [opts.$key, opts.$collection, context];

				var insertData = function(metaData) {
					self._executeSql("INSERT INTO sdata_objects (data, id) values (?, ?)", [JSON.stringify(opts.$data), metaData.$id])
						.then(function() {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
						}, function(status) {
							deferred.reject(status);
						});
				};

				var updateData = function(metaData) {
					self._executeSql("UPDATE sdata_objects set data = ? where id = ?", [JSON.stringify(opts.$data), metaData.$id])
						.then(function(result) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
						}, function(status) {
							deferred.reject(status);
						});
				};

				// handle meta data
				self._readMetaData(context, params)
					.then(function(metaData) {
						if (metaData && metaData.$etag === opts.$data.$etag) {
							// record has not changed
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
						} else if (metaData) {
							// update
							metaData.$etag = opts.$data.$etag;
							self._writeMetaData(metaData)
								.then(function() {
									updateData(metaData);
								}, function(status) {
									deferred.reject(status);
								});
						} else {
							// insert
							metaData = {
								$key: opts.$key,
								$collection: opts.$collection,
								$context: opts.$context,
								$etag: opts.$data.$etag
							};
							self._writeMetaData(metaData)
								.then(function(metaData) {
									insertData(metaData);
								}, function(status) {
									deferred.reject(status);
								});
						}
					}, function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildResult(storageInterface.StatusCodes.ERROR, null, "error writing to database", e));
			} finally {
				return deferred.promise();
			}
		},

		read: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("READ: ", opts);

				var context = JSON.stringify(opts.$context);
				var params = [opts.$key, opts.$collection, context];

				self._readMetaData(context, params)
					.then(function(metaData) {
						if (!metaData) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						} else {
							self._executeSql("SELECT * FROM sdata_objects where id = ?", [metaData.$id])
								.then(function(result) {
									try {
										if (result.rows.length <= 0) {
											deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
										} else {
											deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, JSON.parse(result.rows.item(0).data)));
										}
									} catch (e) {
										deferred.reject(storageInterface.buildResult(storageInterface.StatusCodes.ERROR, null, "error reading from database", e));
									}
								}, function(status) {
									deferred.reject(status);
								});
						}
					}, function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildResult(storageInterface.StatusCodes.ERROR, null, "error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		query: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("QUERY: ", opts);

				var context = JSON.stringify(opts.$context);
				var params = [opts.$collection, context];

				self._executeSql("SELECT * FROM sdata_objects o INNER JOIN sdata_meta m ON (o.id = m.id and m.collection = ? and m.context = ?)", params)
					.then(function(result) {
						var ret = [];
						try {
							for (var i = 0; i < result.rows.length; i++) {
								ret.push(JSON.parse(result.rows.item(i).data));
							}
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, ret));
						} catch (e) {
							deferred.reject(storageInterface.buildResult(storageInterface.StatusCodes.ERROR, null, "error reading from database", e));
						}
					}, function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildResult(storageInterface.StatusCodes.ERROR, null, "error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		remove: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("REMOVE: ", opts);

				var context = JSON.stringify(opts.$context);
				var params = [opts.$key, opts.$collection, context];
				self._removeMetaData(context, params)
					.then(function(metaData) {
						if (!metaData) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						} else {
							self._executeSql("DELETE FROM sdata_objects where id = ?", [metaData.$id])
								.then(function() {
									deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
								}, function(status) {
									deferred.reject(status);
								});
						}
					}, function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildResult(storageInterface.StatusCodes.ERROR, null, "error writing to database", e));
			} finally {
				return deferred.promise();
			}
		},

		_readMetaData: function(context, params, noUpdate) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				self._executeSql("SELECT * FROM sdata_meta where key = ? and collection = ? and context = ?", params)
					.then(function(result) {
						try {
							if (result.rows.length <= 0) {
								deferred.resolve(null);
							} else {
								var item = result.rows.item(0);
								var metaData = {
									$key: item.key,
									$collection: item.collection,
									$context: item.context,
									$id: item.id,
									$etag: item.etag,
									$lastRead: utils.getCurISODateTime()
								};
								if (noUpdate === true) {
									deferred.resolve(metaData);
								} else {
									self._writeMetaData(metaData)
										.then(function() {
											// allways resolve and ignore errors
											deferred.resolve(metaData);
										});
								}
							}
						} catch (e) {
							deferred.reject(storageInterface.buildResult(storageInterface.StatusCodes.ERROR, null, "error reading from database", e));
						}
					}, function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildResult(storageInterface.StatusCodes.ERROR, null, "error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		_writeMetaData: function(metaData) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				metaData.$lastRead = utils.getCurISODateTime();
				if (!metaData.$id) {
					metaData.$id = utils.UUID();
					self._executeSql("INSERT INTO sdata_meta (key, collection, context, id, etag, last_read) values (?, ?, ?, ?, ?, ?)", [
						metaData.$key,
						metaData.$collection,
						JSON.stringify(metaData.$context),
						metaData.$id,
						metaData.$etag,
						metaData.$lastRead
					])
						.then(function() {
							deferred.resolve(metaData);
						}, function(status) {
							deferred.reject(status);
						});
				} else {
					self._executeSql("UPDATE sdata_meta set etag = ?, last_read = ? where id = ?", [metaData.$etag, metaData.$lastRead, metaData.$id])
						.then(function(result) {
							deferred.resolve(metaData);
						}, function(status) {
							deferred.reject(status);
						});
				}
			} catch (e) {
				deferred.reject(storageInterface.buildResult(storageInterface.StatusCodes.ERROR, null, "error writing meta data", e));
			} finally {
				return deferred.promise();
			}
		},

		_removeMetaData: function(context, params) {
			var deferred = $.Deferred();
			var self = this;
			try {
				self._readMetaData(context, params, true)
					.then(function(metaData) {
						if (!metaData) {
							deferred.resolve(null);
						} else {
							self._executeSql("DELETE FROM sdata_meta where id = ?", [metaData.$id])
								.then(function() {
									deferred.resolve(metaData);
								}, function(status) {
									deferred.reject(status);
								});
						}
					}, function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildResult(storageInterface.StatusCodes.ERROR, null, "error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},
		_executeSql: function(sql, params) {
			var deferred = $.Deferred();
			var self = this;
			try {
				self.db.transaction(function(tx) {
					try {
						log && log("SQL: " + sql);
						tx.executeSql(sql, params, function(tx, result) {
							deferred.resolve(result);
						}, function(tx, error) {
							deferred.reject(storageInterface.buildResult(storageInterface.StatusCodes.ERROR, null, "error initializing database: " + _errorToMessage(tx, error)));
						});
					} catch (e) {
						deferred.reject(storageInterface.buildResult(storageInterface.StatusCodes.ERROR, null, "error running SQL statement", e));
					}
				});
			} catch (e) {
				deferred.reject(storageInterface.buildResult(storageInterface.StatusCodes.ERROR, null, "error running SQL statement", e));
			}
			return deferred.promise();
		},

		/*
		 *
		 * Database migration functions
		 *
		 */
		_openDB: function() {
			var deferred = $.Deferred();
			var self = this;
			if (self.useTestDatabase === false && self.db) {
				deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
			}

			var request;
			try {
				log && log("Open database, request version: " + self.databaseVersion);
				self.db = openDatabase(self.databaseName, 7, 'Database', self.databaseSize);
				self._readCurrentVersion().then(function(version) {
					log && log("Current version: " + version);
					// In test framework create DB every time
					if (version === self.databaseVersion && self.useTestDatabase !== true) {
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
					} else {
						self._createTables().then(function(status) {
							return self._writeCurrentVersion();
						}).then(function(status) {
							deferred.resolve(status);
						}, function(status) {
							deferred.reject(status);
						});
					}
				}, function(status) {
					deferred.reject(status);
				});

			} catch (e) {
				log && log("Open database, exception", e);
				self.db = null;
				deferred.reject(storageInterface.buildResult(storageInterface.StatusCodes.ERROR, null, "error initializing database", e));
			}

			return deferred.promise();
		},
		_readCurrentVersion: function() {
			var deferred = $.Deferred();
			var self = this;
			self._executeSql('SELECT version FROM version', null).then(function(result) {
				try {
					var len = result.rows.length;
					if (len === 1) {
						var version = result.rows.item(0).version;
						log && log("Read version: " + version);
						deferred.resolve(+version);
					}
					deferred.resolve(-1);
				} catch (e) {
					deferred.reject(storageInterface.buildResult(storageInterface.StatusCodes.ERROR, null, "error reading database version", e));
				}
			}, function(status) {
				// Asume table does not exist, create it
				log && log("Creating version table");
				self._executeSql('CREATE TABLE version (version TEXT)').then(function(status) {
					deferred.resolve(-1);
				}, function(status) {
					deferred.reject(status);
				});
			});
			return deferred.promise();
		},
		_writeCurrentVersion: function() {
			var deferred = $.Deferred();
			var self = this;
			self._executeSql('DELETE FROM version', null)
				.then(function(result) {
					return self._executeSql('INSERT INTO version (version) values (?)', [_databaseVersion]);
				})
				.then(function(status) {
					deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
				}, function(status) {
					deferred.reject(status);
				});
			return deferred.promise();
		},
		_createTables: function() {
			var deferred = $.Deferred();
			var self = this;
			var p = [];
			for (var i = 0; i < _tables.length; i++) {
				p.push(self._executeSql(_tables[i]));
			}
			$.when.apply($, p).then(function() {
				deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
			}, function(status) {
				deferred.reject(status);
			});
			return deferred.promise();
		}
	}
);

function _errorToMessage(tx, error) {
	return "CODE: " + error.code + " MESSAGE: " + error.message;
}
exports.StorageInterface = _storageInterfaceWebSQLClass;
exports.isAvailable = function() {
	return (window.openDatabase != null);
};
});