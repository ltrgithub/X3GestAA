"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var ChartsTheme = require('./chartstheme').ChartsTheme;

var _Klass = utils.defineClass(function() {}, null, {
	_defaultGaugeSegments: [{
		propStart: 0,
		propEnd: 0.25,
		valStart: null,
		valEnd: null,
		color: '#55BF3B'
	}, {
		propStart: 0.25,
		propEnd: 0.75,
		valStart: null,
		valEnd: null,
		color: '#DDDF0D'
	}, {
		propStart: 0.75,
		propEnd: 1,
		valStart: null,
		valEnd: null,
		color: '#DF5353'
	}],
	_resolveExpr: function(expr, data, cp) {
		if (typeof expr !== "string") return expr;
		return expr.replace(/\{(\w+)\}/g, function(d0, d1) {
			if (data[d1] != null) return data[d1];
			if (cp[d1] != null) return cp[d1];
			return d0;
		});
	},
	// Merge default values for gauge segments with data comming from the authoring
	_mergeAuthoringAndDefaults: function($gauge) {
		var self = this;
		if (!$gauge.segments) // Not authoring on segments
			return self._defaultGaugeSegments;
		if ($gauge.segments.length === 0) // Not authoring on segments
			return self._defaultGaugeSegments;

		var s, def, auth, res = [];
		for (s = 0; s < $gauge.segments.length; s++) {
			def = self._defaultGaugeSegments[Math.min(s, self._defaultGaugeSegments.length - 1)];
			auth = $gauge.segments[s];
			if (!auth) {
				// no authoring for this segment, use default
				res.push(def);
			} else {
				if ((auth.propStart == null || auth.propEnd == null) && (auth.valStart == null || auth.valEnd == null)) {
					// not range defined, use default, not authoring
					auth.propStart = def.propStart;
					auth.propEnd = def.propEnd;
					auth.valStart = def.valStart;
					auth.valEnd = def.valEnd;
				}
				if (auth.color == null) {
					auth.color = def.color;
				}
				res.push(auth);
			}
		}
		return res;
	},
	// Create segment definitions for gauge
	_createBands: function(controller, $c, options, cp, valMin, valMax) {
		var self = this;
		var bands = [];

		// Grey background is always present
		bands.push({
			from: valMin,
			to: valMax,
			color: '#ccc',
			innerRadius: '79%',
			outerRadius: '101%'
		});

		var data = controller.getValue();
		var bandsDef = self._mergeAuthoringAndDefaults(options.gauge);
		var seg;
		var s;
		var band;
		var range = valMax - valMin;
		for (s = 0; s < bandsDef.length; s++) {
			seg = bandsDef[s];
			band = {
				innerRadius: '79%',
				outerRadius: '101%',
				color: seg.color
			};
			if (seg.valStart != null && seg.valEnd != null) {
				band.from = self._resolveExpr(seg.valStart, data, cp);
				band.to = self._resolveExpr(seg.valEnd, data, cp);
			} else if (seg.propStart != null && seg.propEnd != null) {
				band.from = valMin + range * self._resolveExpr(seg.propStart, data, cp);
				band.to = valMin + range * self._resolveExpr(seg.propEnd, data, cp);
			}
			bands.push(band);
		}
		return bands;
	},
	_renderGauge: function(controller, $c, options) {
		//self._renderGauge(controller, $$html, options);
		var self = this;
		var bind = options.bind || options.$bind;
		var labelColor = !controller.$isEditMode ? "#34B233" : "#666";

		var val = controller.getValue(bind, null, 0);
		var valMin = 0;
		var valMax = 100;

		if (options.gauge.$bindMin != null && options.gauge.$bindMax != null) {
			if (typeof options.gauge.$bindMin === "string") valMin = controller.getControllerDao().getValue(options.gauge.$bindMin);
			else valMin = options.gauge.$bindMin;
			if (typeof options.gauge.$bindMax === "string") valMax = controller.getControllerDao().getValue(options.gauge.$bindMax);
			else valMax = options.gauge.$bindMax;
		}

		try {
			if (typeof val === "string") val = parseFloat(val);
		} catch (e) {}
		try {
			if (typeof valMin === "string") valMin = parseFloat(valMin);
		} catch (e) {}
		try {
			if (typeof valMax === "string") valMax = parseFloat(valMax);
		} catch (e) {}

		var cp = controller.prototype.json;
		var dd = controller.getValue();

		var uom = "";
		if (cp.$unit && cp.$properties && cp.$properties[cp.$unit] && dd && dd[cp.$unit] && dd[cp.$unit].$symbol) {
			uom = dd[cp.$unit].$symbol;
		}

		var label = ((options && options.label) || "");
		var $cont = $c;
		var decimals = (options && options.decimals !== null) ? options.decimals : 0;

		var plotBands = self._createBands(controller, $c, options, cp, valMin, valMax);
		$cont.highcharts({
			chart: {
				type: 'gauge',
				plotBackgroundColor: null,
				plotBackgroundImage: null,
				plotBorderWidth: 0,
				plotShadow: false,
				backgroundColor: null,
				height: 180
			},
			title: {
				text: label,
				style: {
					color: labelColor
				}
			},
			pane: {
				startAngle: -90,
				endAngle: 90,
				center: ['50%', '90%'],
				size: 210,
				background: [{
					backgroundColor: '#FFF',
					borderWidth: 0
				}]
			},
			yAxis: {
				min: valMin,
				max: valMax,

				minorTickWidth: 1,
				minorTickInterval: 'auto',
				minorTickLength: 20,
				minorTickPosition: 'inside',
				minorTickColor: '#fff',

				tickPixelInterval: 30,
				tickWidth: 0,
				tickPosition: 'inside',
				tickLength: 15,
				tickColor: '#FFF',
				labels: {
					step: 1,
					rotation: 'auto',
					style: {
						color: "#666",
						cursor: "default",
						fontSize: "12px",
						lineHeight: "14px"
					},
					distance: 3
				},
				title: {
					text: uom,
					style: {
						color: "#666"
					}
				},
				plotBands: plotBands
			},
			plotOptions: {
				gauge: {
					dataLabels: {
						enabled: true,
						format: "{point.y:,." + decimals + "f}"
					}
				}
			},
			series: [{
				name: label,
				data: [val],
				tooltip: {
					valueSuffix: ' ' + uom
				}
			}]

		}, function() {});
	},
	createGauge: function(controller, $gauge) {
		var self = this;
		var options = self._setOptions(controller, $gauge);

		var $$html = $("<div>");
		$$html.addClass("s-m-gauge-container");

		var localeDecimalSep = locale.getNumberDecimalSeparator();
		var localeThousandSep = locale.getNumberGroupSeparator();

		var app = globals.getApplication();
		if (!app.getChartsTheme()) {
			app.setChartsTheme(ChartsTheme);
		} else {
			ChartsTheme = app.getChartsTheme();
		}

		if (!ChartsTheme.themeWasSet || ChartsTheme.decimalPoint !== localeDecimalSep || ChartsTheme.thousandsSep !== localeThousandSep) {
			ChartsTheme.decimalPoint = localeDecimalSep;
			ChartsTheme.thousandsSep = localeThousandSep;

			Highcharts.setOptions(ChartsTheme);
			ChartsTheme.themeWasSet = true;
		}

		self._renderGauge(controller, $$html, options);

		return $$html[0];
	},
	_setOptions: function(controller, $gauge) {
		var options = {};
		options.label = controller.getTitle();
		// TODO ??
		// options.decimals
		options.gauge = $.extend({}, $gauge);
		return options;
	}
});

exports.Klass = _Klass;