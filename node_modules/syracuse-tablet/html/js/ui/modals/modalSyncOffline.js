"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalDialog = require('syracuse-tablet/html/js/ui/modals/modalDialog');
var sdataDispatcher = require('syracuse-tablet/html/js/sdata/sdataDispatcher');
var sdataSyncUtils = require('syracuse-tablet/html/js/sdata/sdataSyncUtils');

var _templateAll = {
	header: '\
			<buttons class="pull-right"> \
				<button type="button" class="btn btn-default s-m-modal-btn-cancel" data-action="$cancel"></button> \
			</buttons> \
			<div class="modal-title">{{title}}</div> \
			',
	content: ' \
			<div class="s-m-scroll-wrapper s-m-scroll-wrapper-v">\
			<div class="s-m-scroll-element"> \
				<div class="form-group" id="s-m-sync-no-data-id"> \
					<div class="panel s-m-panel-diag-error"><div class="panel-heading">{{label_errors}}</div><ul></ul></div> \
					<center>{{label_no_data}}</center>\
				</div> \
				<div class="form-group" id="s-m-sync-actions-id"> \
					<center> \
						<button type="button" class="btn btn-default s-m-modal-btn-sync" data-action="modal-sync">{{label_sync}}</button> \
						<button type="button" class="btn btn-default s-m-modal-btn-sync-stop hidden" data-action="modal-sync-stop">{{label_sync_stop}}<div class="s-m-sync-total"><span class="label label-success ok"></span><span class="label label-danger error"></span></div></button> \
					</center> \
				</div> \
				<div class="form-group" id="s-m-sync-tree-id"> \
					<label>{{label_tree}}</label> \
					<div id="s-m-sync-tree-id"></div> \
				</div> \
			</div> \
			</div>',
	footer: ''
};

var _Klass = utils.defineClass(
	function ModalSyncOffline(syncRootData) {
		var self = this;
		modalDialog.ModalBase.call(self);
		self.syncRootData = syncRootData;
	}, modalDialog.ModalBase, {
		_getTemplates: function() {
			var self = this;
			return {
				std: _templateAll
			};
		},

		getDisplayFlags: function() {
			var self = this;
			var displayFlags = self.displayFlags || {};
			if (self.deviceType === "tablet") {
				displayFlags.modalClass = "sync-offline half_right";
			} else {
				displayFlags.modalClass = "sync-offline full";
			}
			return displayFlags;
		},

		_getDataContext: function() {
			var self = this;
			var data = {
				title: locale.text("modal.sync.title"),
				label_tree: locale.text("modal.sync.header.tree"),
				label_sync: locale.text("modal.sync.label_sync"),
				label_sync_stop: locale.text("modal.sync.label_sync_stop"),
				label_no_data: locale.text("modal.sync.nodata"),
				label_errors: locale.text("modal.sync.errors")
			};
			return data;
		},

		_onShow: function() {
			var self = this;
			modalDialog.ModalBase.prototype._onShow.call(self);
			sdataSyncUtils.getSyncStructure(self.syncRootData.pageProto)
				.then(function(tree) {
					self.syncTreeRoot = tree;
					if (self.syncTreeRoot) {
						self._buildStructHtml(tree);
					} else {
						self._noData();
					}
				})
				.fail(function(e) {
					self._noData(e);
				});
		},

		_noData: function(e) {
			var self = this;
			$("#s-m-sync-no-data-id").show();
			$("#s-m-sync-actions-id").hide();
			$("#s-m-sync-tree-id").hide();

			var $$ul = $("#s-m-sync-no-data-id ul");
			$$ul.empty();
			e = e && e.$diagnoses;
			if (e && e.length) {
				$("#s-m-sync-no-data-id .panel").show();
				var i;
				for (i = 0; i < e.length; i++) {
					var msg = e[i] && e[i].$message;
					if (msg) {
						var $$li = $("<li>");
						$$li.text(msg);
						$$ul.append($$li);
					}
				}
			} else {
				$("#s-m-sync-no-data-id .panel").hide();
			}
		},
		_buildStructHtml: function(node) {
			var self = this;
			$("#s-m-sync-no-data-id").hide();
			$("#s-m-sync-actions-id").show();
			$("#s-m-sync-tree-id").show();
			var $$sync = $("#s-m-sync-tree-id");
			var $$ul = $("<ul>");
			self._addNode($$ul, node, 0);
			$$sync.append($$ul);
		},

		_addNode: function($$parent, node, level) {
			var self = this;
			var cls = level > 0 ? "collapsed" : "expanded";
			cls = cls + (level < 1 ? " selected" : "");
			var $$li = $('\
				<li class="s-m-sync-tree-item ' + cls + '" data-params="' + node.uuid + '"> \
					<div class="s-m-tree-icon-expand" data-action="tree-click-expand" data-params="' + node.uuid + '"></div> \
					<div class="s-m-tree-label" data-action="tree-click-select" data-params="' + node.uuid + '"></div> \
					<div class="s-m-sync-count hidden"><div>"\
				</li>');
			$("div.s-m-tree-label", $$li).text(node.$title);
			$$parent.append($$li);
			if (node.$children.length > 0) {
				var $$ul = $("<ul>");
				if (node.$isDetails !== true) {
					// For $query parent, the single $details link is not added to the tree it will be handled implicitly
					var child = node.$children[0];
					if (child && child.$children && child.$children.length > 0) {
						$$li.append($$ul);
						child.$children.forEach(function(child) {
							self._addNode($$ul, child);
						});
					}
				} else {
					if (node.$children && node.$children.length > 0) {
						$$li.append($$ul);
						// For a $details parent, all child links are added as new tree level
						node.$children.forEach(function(child) {
							self._addNode($$ul, child);
						});
					}
				}
			}
			// No children added
			if ($("ul", $$li).length < 1) {
				var $$expand = $(">.s-m-tree-icon-expand", $$li);
				$$expand.removeClass("s-m-tree-icon-expand");
				$$expand.addClass("s-m-tree-icon-leaf");
				$$expand.attr("data-action", null);
			}
		},
		_onAction: function(action, param) {
			var self = this;
			if (action === "tree-click-expand") {
				self._onTreeClickExpand(param);
			} else if (action === "tree-click-select") {
				self._onTreeClickSelect(param);
			} else if (action === "modal-sync") {
				self._syncData();
			} else if (action === "modal-sync-stop") {
				self.stopSync = true;
			}

			return false;
		},
		_onValidate: function() {},

		_onCancel: function() {},

		_getResult: function() {
			return "done";
		},
		_onTreeClickExpand: function(param) {
			var self = this;
			var $$li = $('li[data-params="' + param + '"]');
			if ($$li.hasClass("expanded")) {
				$$li.removeClass("expanded");
				$$li.addClass("collapsed");
			} else {
				$$li.addClass("expanded");
				$$li.removeClass("collapsed");
			}
		},
		_onTreeClickSelect: function(param) {
			var self = this;
			var $$li = $('li[data-params="' + param + '"]');
			if ($$li.hasClass("selected")) {
				$$li = $$li.add("li", $$li);
				$$li.removeClass("selected");
			} else {
				$$li = $$li.add("li", $$li);
				$$li.addClass("selected");
			}
		},

		_syncData: function() {
			var self = this;
			self.stopSync = false;

			var $$li = $('li[data-params="' + self.syncTreeRoot.uuid + '"]');

			$('button[data-action="modal-sync"]', self.$$elmt).addClass("hidden");
			$('button[data-action="modal-sync-stop"]', self.$$elmt).removeClass("hidden");

			self.syncCount = 0;
			self.errorCount = 0;
			self._updateErrorCount();
			$.smForEachPromise(self.syncRootData.rowsData, function(row, idx, cnt) {
					if (self.stopSync) {
						return $.smResolve();
					}
					self._updateSyncCount($$li, idx, cnt);
					return self._syncNodeData(self.syncTreeRoot, row.rowData.data);
				})
				.always(function(e) {
					$('button[data-action="modal-sync"]', self.$$elmt).removeClass("hidden");
					$('button[data-action="modal-sync-stop"]', self.$$elmt).addClass("hidden");
				});
		},

		_updateSyncCount: function($$li, idx, cnt) {
			var self = this;
			var $$state = $(">div.s-m-sync-count", $$li);
			$$state.removeClass("hidden");
			$$state.text((idx + 1) + " / " + cnt);
			var $$states = $("li>div.s-m-sync-count", $$li);
			$$states.addClass("hidden");
		},

		_updateErrorCount: function() {
			var self = this;

			var $$total = $('button[data-action="modal-sync-stop"]>.s-m-sync-total', self.$$elmt);
			var $$ok = $(">.ok", $$total);
			var $$error = $(">.error", $$total);
			$$ok.text(self.syncCount);
			$$error.text(self.errorCount);
		},

		_syncNodeData: function(node, parentData) {
			var self = this;
			var $$li;

			if (self.stopSync) {
				return $.smResolve();
			}

			if (node.$isDetails !== true) {
				$$li = $('li[data-params="' + node.uuid + '"]');
				if ($$li.length < 1) {
					return $.smResolve();
				}
				if (!$$li.hasClass("selected")) {
					return $.smResolve();
				}
				node.$$listItem = $$li;
			}

			node.$$listItem.addClass("sync-progress");

			var nodeData;
			if (node.$link) {
				nodeData = self._readNodeData(node, parentData);
			} else {
				nodeData = $.smResolve(parentData);
			}
			return nodeData
				.then(function(nodeData) {
					var dataItems = nodeData && nodeData.$resources;
					if (!dataItems && nodeData) {
						dataItems = [nodeData];
					}
					if (!dataItems) {
						return $.smResolve(null);
					}
					return $.smForEachPromise(dataItems, function(dataItem, idx, cnt) {
						if (self.stopSync) {
							return $.smResolve();
						}

						if (nodeData.$resources) {
							self._updateSyncCount($$li, idx, cnt);
						}
						return $.smForEachPromise(node.$children, function(child) {
							if (self.stopSync) {
								return $.smResolve();
							}

							child.$$listItem = $$li;
							return self._syncNodeData(child, dataItem);
						}).
						then(function() {
							// Children may set the same node to finished which may be wrong
							node.$$listItem.addClass("sync-progress");
						});
					});
				})
				.then(function() {
					node.$$listItem.removeClass("sync-progress");
				});
		},
		_readNodeData: function(node, parentData) {
			var self = this;
			var deferred = $.Deferred();
			var linkUrl = utils.parseExpression(node.$link.$url, parentData, node.$prototype);
			linkUrl = linkUrl + "&nocache=true"; // Always force to not use the cache

			sdataDispatcher.dispatch({
					$url: linkUrl,
					$method: "GET"
				})
				.then(function(data) {
					// No edit link, so we are done for detail record
					if (!node.$editLink) {
						self.syncCount++;
						self._updateErrorCount();
						deferred.resolve(data);

						return data;
					}

					// We also have to fetch $edit
					return self._readEditNodeData(node, data)
						.then(function() {
							self.syncCount++;
							self._updateErrorCount();
							deferred.resolve(data);

							return data;
						});
				})
				.fail(function() {
					self.errorCount++;
					self._updateErrorCount();
					deferred.resolve(null);
				});

			return deferred.promise();
		},
		_readEditNodeData: function(node, parentData) {
			var self = this;
			var deferred = $.Deferred();

			var linkUrl = utils.parseExpression(node.$editLink.$url, parentData, node.$editPrototype);
			linkUrl = linkUrl + "&nocache=true"; // Always force to not use the cache

			sdataDispatcher.dispatch({
					$url: linkUrl,
					$method: "GET"
				})
				.then(function(data) {
					deferred.resolve(data);
					return data;
				})
				.fail(function() {
					deferred.resolve(null);
				});
			return deferred.promise();
		}
	}
);

exports.Modal = _Klass;