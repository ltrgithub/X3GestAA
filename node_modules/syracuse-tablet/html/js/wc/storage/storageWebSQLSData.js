"use strict";

/**
 * WebSQL storage interface - SDATA (META + DATA) MANAGEMENT
 * Members added to of _storageInterfaceWebSQLClass
 */

var utils = require('syracuse-tablet/html/js/wc/helpers/utils');
var storageInterface = require('syracuse-tablet/html/js/wc/storage/storageInterface');
var Base = require('syracuse-tablet/html/js/wc/storage/storageWebSQLBase').Klass;
var log = require('syracuse-tablet/html/js/wc/helpers/logger').getLogger("webSQL", false);

var _tables = {
	"sdata_meta": [
		// meta data table for handling etags, ttl, size, ..
		"DROP TABLE IF EXISTS sdata_meta",
		"CREATE TABLE sdata_meta ( " +
		"key text, " +
		"collection text, " +
		"endpoint text, " +
		"context text, " +
		"id text, " +
		"etag text, " +
		"last_read text, " +
		"last_updated text" +
		")",
		"DROP INDEX IF EXISTS sdata_meta_pk",
		"CREATE UNIQUE INDEX sdata_meta_pk ON sdata_meta (key, collection, endpoint, context)",
		"DROP INDEX IF EXISTS sdata_meta_id",
		"CREATE UNIQUE INDEX sdata_meta_id ON sdata_meta (id)"
	],
	"sdata_objects": [
		// data table
		"DROP TABLE IF EXISTS sdata_objects",
		"CREATE TABLE sdata_objects ( " +
		"id text, " +
		"data text " +
		")",
		"DROP INDEX IF EXISTS sdata_objects_pk",
		"CREATE UNIQUE INDEX sdata_objects_pk ON sdata_objects (id)"
	]
};
exports.Klass = utils.defineClass(
	function() {
		Base.call(this);
	}, Base, {
		getTables: function() {
			var res = Base.prototype.getTables.call(this);
			$.extend(res, _tables);
			return res;
		},
		put: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("PUT: ", JSON.stringify(opts));

				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [opts.$key, opts.$collection, opts.$endpoint, context];

				var insertData = function(metaData) {
					self._executeSql("INSERT INTO sdata_objects (data, id) values (?, ?)", [JSON.stringify(opts.$data), metaData.$id])
						.then(function() {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
						}).fail(function(status) {
							deferred.reject(status);
						});
				};

				var updateData = function(metaData) {
					self._executeSql("UPDATE sdata_objects set data = ? where id = ?", [JSON.stringify(opts.$data), metaData.$id])
						.then(function(result) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
						}).fail(function(status) {
							deferred.reject(status);
						});
				};

				// handle meta data
				self._readMetaData(context, params)
					.then(function(metaData) {
						if (opts.$data && opts.$data.$etag && metaData && metaData.$etag === opts.$data && opts.$data.$etag) {
							// record has not changed
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
						} else if (metaData) {
							// update
							metaData.$etag = opts.$data.$etag;
							metaData.$lastUpdated = utils.getCurISODateTime();
							self._writeMetaData(metaData)
								.then(function() {
									updateData(metaData);
								}).fail(function(status) {
									deferred.reject(status);
								});
						} else {
							// insert
							metaData = {
								$key: opts.$key,
								$collection: opts.$collection,
								$endpoint: opts.$endpoint,
								$context: opts.$context,
								$etag: opts.$data.$etag,
								$lastUpdated: utils.getCurISODateTime()
							};
							self._writeMetaData(metaData)
								.then(function(metaData) {
									insertData(metaData);
								}).fail(function(status) {
									deferred.reject(status);
								});
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error writing to database", e));
			} finally {
				return deferred.promise();
			}
		},

		read: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("READ: ", JSON.stringify(opts));

				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [opts.$key, opts.$collection, opts.$endpoint, context];

				self._readMetaData(context, params)
					.then(function(metaData) {
						if (!metaData) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						} else {
							self._executeSql("SELECT * FROM sdata_objects where id = ?", [metaData.$id])
								.then(function(result) {
									try {
										if (result.rows.length <= 0) {
											deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
										} else {
											deferred.resolve(storageInterface.buildResult(
												storageInterface.StatusCodes.OK,
												JSON.parse(result.rows.item(0).data),
												null,
												null, {
													$lastRead: metaData.$lastRead,
													$lastUpdated: metaData.$lastUpdated
												}));
										}
									} catch (e) {
										deferred.reject(storageInterface.buildErrResult("error reading from database", e));
									}
								}).fail(function(status) {
									deferred.reject(status);
								});
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		query: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("QUERY: ", JSON.stringify(opts));

				if (!opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [opts.$collection, opts.$endpoint, context];

				self._executeSql("SELECT o.*, m.last_read, m.last_updated FROM sdata_objects o INNER JOIN sdata_meta m ON (o.id = m.id and m.collection = ? and m.endpoint = ? and m.context = ?)", params)
					.then(function(result) {
						var ret = [];
						var meta = [];
						try {
							for (var i = 0; i < result.rows.length; i++) {
								var item = result.rows.item(i);
								ret.push(JSON.parse(item.data));
								meta.push({
									$lastRead: item.last_read,
									$lastUpdated: item.last_updated
								});
							}
						} catch (e) {
							deferred.reject(storageInterface.buildErrResult("error reading from database", e));
							return;
						}
						// Exception are handled by our jq deferred hack
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, ret, null, null, meta));
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		remove: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("REMOVE: ", JSON.stringify(opts));

				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [opts.$key, opts.$collection, opts.$endpoint, context];
				self._removeMetaData(context, params)
					.then(function(metaData) {
						if (!metaData) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						} else {
							self._executeSql("DELETE FROM sdata_objects where id = ?", [metaData.$id])
								.then(function() {
									deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
								}).fail(function(status) {
									deferred.reject(status);
								});
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error writing to database", e));
			} finally {
				return deferred.promise();
			}
		},
		clearCollection: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("CLEAR: ", JSON.stringify(opts));

				if (!opts.$collection || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [context];

				//self._executeSql("SELECT * FROM sdata_meta where context = ?", params)
				self._executeSql("SELECT * FROM sdata_meta")
					.then(function(result) {
						var ret = [];
						try {
							for (var i = 0; i < result.rows.length; i++) {
								var item = result.rows.item(i);
								if (opts.$collection.test(item.collection)) {
									if (!opts.$not_read_since || item.last_read < opts.$not_read_since) {
										ret.push({
											$context: opts.$context,
											$collection: item.collection,
											$endpoint: item.endpoint,
											$key: item.key
										});
									}
								}
							}
							$.smForEachPromise(ret, function(item) {
								return self.remove(item);
							}).then(function() {
								deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
							}).fail(function(e) {
								deferred.reject(e);
							});
						} catch (e) {
							deferred.reject(storageInterface.buildErrResult("error reading from database", e));
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		computeCollectionSize: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("CHECK SIZE: ", JSON.stringify(opts));

				if (!opts.$collection || !opts.$context)
					throw new Error("Insufficient parameters");

				var context = JSON.stringify(opts.$context);
				var params = [context];
				//self._executeSql("SELECT * FROM sdata_meta where context = ?", params)
				self._executeSql("SELECT m.collection, m.endpoint, m.key, m.last_read, d.data FROM sdata_meta m INNER JOIN sdata_objects d ON (d.id = m.id) where m.context = ? ", params)
					.then(function(result) {
						var returnData = {
							numRecords: 0,
							sizeRecords: 0
						};
						var ret = [];
						try {
							for (var i = 0; i < result.rows.length; i++) {
								var item = result.rows.item(i);
								if (opts.$collection.test(item.collection)) {
									if (!opts.$not_read_since || item.last_read < opts.$not_read_since) {
										returnData.numRecords++;
										returnData.sizeRecords += item.data.length;
									}
								}
							}
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, returnData));
						} catch (e) {
							deferred.reject(storageInterface.buildErrResult("error reading from database", e));
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		_readMetaData: function(context, params, noUpdate) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				self._executeSql("SELECT * FROM sdata_meta where key = ? and collection = ? and endpoint = ? and context = ?", params)
					.then(function(result) {
						try {
							if (result.rows.length <= 0) {
								deferred.resolve(null);
							} else {
								var item = result.rows.item(0);
								var metaData = {
									$key: item.key,
									$collection: item.collection,
									$endpoint: item.endpoint,
									$context: item.context,
									$id: item.id,
									$etag: item.etag,
									$lastRead: item.last_read,
									$lastUpdated: item.last_updated
								};
								log && log("Read meta data: " + JSON.stringify(metaData));
								if (noUpdate === true) {
									deferred.resolve(metaData);
								} else {
									self._writeMetaData(metaData)
										.then(function() {
											// allways resolve and ignore errors
											deferred.resolve(metaData);
										}).fail(function(e) {
											deferred.reject(storageInterface.buildErrResult("error reading from database", e));
										});
								}
							}
						} catch (e) {
							deferred.reject(storageInterface.buildErrResult("error reading from database", e));
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},
		// #8093 Locks the key and returns true if key wasn't locked
		_conflictMetaLock: function(metaId) {
			var locked = false;
			if (!this._lockedMeta) {
				this._lockedMeta = [];
			} else {
				locked = this._lockedMeta.indexOf(metaId) >= 0;
			}
			if (locked === false) {
				this._lockedMeta.push(metaId);
			}
			return locked === false;
		},
		// #8093 Put deferred and meta in waiting queue
		_conflictMetaWait: function(metaId, deferred, metaData) {
			log && log("!!CONFLICT WAIT", metaId);
			if (!this._pendingMeta) {
				this._pendingMeta = {};
			}
			var stack = this._pendingMeta[metaId];
			if (!stack) {
				stack = this._pendingMeta[metaId] = [];
			}
			stack.push({
				deferred: deferred,
				metaData: metaData
			});
		},
		// #8093 Unlock the key and process pending metaData (UPDATE) for this key if any
		_conflictMetaUnlock: function(metaId) {
			var idx = this._lockedMeta.indexOf(metaId);
			if (idx >= 0) {
				this._lockedMeta.splice(idx, 1);
			}
			var stack = this._pendingMeta ? this._pendingMeta[metaId] : null;
			if (!stack) {
				return;
			}
			var data = stack.pop();
			if (stack.length === 0) {
				delete this._pendingMeta[metaId];
			}
			if (!data) {
				return;
			}
			log && log("!!CONFLICT RETRY", metaId);
			this._writeMetaData(data.metaData).then(function(metaData) {
				data.deferred.resolve(metaData);
			}).fail(function(status) {
				data.deferred.reject(status);
			});
		},
		_writeMetaData: function(metaData) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				metaData.$lastRead = utils.getCurISODateTime();
				if (!metaData.$id) {
					// #8093 - Set metaData.$id first to force UPDATE if a retry is needed in case of conflict (It will update existing record)
					metaData.$id = utils.UUID();
					// Unique key that could create conflict (Index)
					var metaId = [
						metaData.$key,
						metaData.$collection,
						metaData.$endpoint,
						JSON.stringify(metaData.$context)
					].join('-');
					// Chek if key is locked
					if (self._conflictMetaLock(metaId)) {
						self._executeSql("INSERT INTO sdata_meta (key, collection, endpoint, context, id, etag, last_read, last_updated) values (?, ?, ?, ?, ?, ?, ?, ?)", [
								metaData.$key,
								metaData.$collection,
								metaData.$endpoint,
								JSON.stringify(metaData.$context),
								metaData.$id,
								metaData.$etag,
								metaData.$lastRead,
								metaData.$lastUpdated
							])
							.then(function() {
								// Unnlock key
								self._conflictMetaUnlock(metaId);
								deferred.resolve(metaData);
							}).fail(function(status) {
								// Unnlock key
								self._conflictMetaUnlock(metaId);
								deferred.reject(status);
							});
					} else {
						// Save deferred and data - Lets retry when key is unlocked
						self._conflictMetaWait(metaId, deferred, metaData);
					}
				} else {
					self._executeSql("UPDATE sdata_meta set etag = ?, last_read = ?, last_updated = ? where id = ?", [metaData.$etag, metaData.$lastRead, metaData.$lastUpdated, metaData.$id])
						.then(function(result) {
							deferred.resolve(metaData);
						}).fail(function(status) {
							deferred.reject(status);
						});
				}
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error writing meta data", e));
			} finally {
				return deferred.promise();
			}
		},

		_removeMetaData: function(context, params) {
			var deferred = $.Deferred();
			var self = this;
			try {
				self._readMetaData(context, params, true)
					.then(function(metaData) {
						if (!metaData) {
							deferred.resolve(null);
						} else {
							self._executeSql("DELETE FROM sdata_meta where id = ?", [metaData.$id])
								.then(function() {
									deferred.resolve(metaData);
								}).fail(function(status) {
									deferred.reject(status);
								});
						}
					}).fail(function(status) {
						deferred.reject(status);
					});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		}
	});