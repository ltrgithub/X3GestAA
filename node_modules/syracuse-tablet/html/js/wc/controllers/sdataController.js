"use strict";

var Base = require("syracuse-tablet/html/js/wc/controllers/controller").Controller;

var utils = require('syracuse-tablet/html/js/wc/helpers/utils');
var sdataReq = require("syracuse-tablet/html/js/wc/sdata/sdataRequester");
var protocolHelpers = require("syracuse-tablet/html/js/wc/sdata/protocolHelpers");
var environment = require('syracuse-tablet/html/js/wc/helpers/environment');
var modules = require('syracuse-tablet/html/js/wc/common/modules');

/**
 * parent can be null (formController)
 */
exports.SdataController = utils.defineClass(
	function SdataController(dataset, parent, isWorkingCopy) {
		Base.call(this, parent);

		this.controlsByBind = {};

		// This is to hold client side only diagnoses per field that are generated by the widgets
		// E.g. checks on $minValue or $maxLength
		// It's better to hold these information in the controller and not the widgets because
		// widgets should not have non UI state
		this.clientDiagnosesByBind = {};

		this.dataset = dataset;

		this.isWorkingCopy = true; // Default
		if (isWorkingCopy !== undefined) { // Given by parameter?
			this.isWorkingCopy = isWorkingCopy;
		} else if (parent != null) { // Try to set from parent if available
			this.isWorkingCopy = parent.isWorkingCopy;
		}

		this.dataset.addDeltaChangeListener(this);
		this.pendingRequests = 0;
	},
	Base, {

		destroy: function() {
			if (this.dataset) {
				this.dataset.removeDeltaChangeListener(this);
			}

			// Ask server to delete working copy?
			if (this.isWorkingCopy && this.isRoot()) {
				if (this.dataset) {
					// This is async but we do not care about the result, since if it does not work,
					// there is nothing more we can do
					sdataReq.deleteWC(this.dataset);
				}
			}

			if (this.isRoot()) {
				this.dataset.destroy();
			}
			this.dataset = null;
			this.prototype = null;
			this.clientDiagnosesByBind = null;
			Base.prototype.destroy.call(this);
		},

		//
		// CONTROLS START
		//
		registerControl: function(ctrl) {
			Base.prototype.registerControl.call(this, ctrl);
			var $bind = ctrl.$bind;
			if ($bind) {
				var perBind = this.controlsByBind[$bind] = this.controlsByBind[$bind] || [];
				perBind.push(ctrl);
			}
		},
		unregisterControl: function(ctrl) {
			Base.prototype.unregisterControl.call(this, ctrl);
			var $bind = ctrl.$bind;
			if ($bind) {
				var perBind = this.controlsByBind[$bind];
				if (perBind) {
					var idx = perBind.indexOf(ctrl);
					if (idx > -1) {
						perBind.splice(idx, 1);
					}
				}
			}
		},
		_controlsByBind: function($bind) {
			var c = this.controlsByBind[$bind];
			return c;
		},
		getControlsByBind: function($bind) {
			return this._controlsByBind($bind);
		},
		/**
		 * Used to store client side generated diagnoses for a field inside the controller
		 */
		setClientDiagnoses: function($bind, diags) {
			this.clientDiagnosesByBind[$bind] = diags;
		},
		/**
		 * Return all diagnoses set for a specific field
		 * Array will be empty or client side diagnoses first, server side diagnoses second
		 */
		getDiagnoses: function($bind) {
			var client = this.clientDiagnosesByBind[$bind] || [];
			var server = this.dataset.getDiagnoses($bind);
			var diags = [];
			Array.prototype.push.apply(diags, client);
			Array.prototype.push.apply(diags, server);
			return diags;
		},
		/**
		 * The purpose if this method is to scan all controls which have client side diagnoses set
		 * If there is a diagnoses, this means the widget may render a different value than the dataset
		 * because the user typed something invalid that violates constraints like "$minValue"
		 */
		findErrornousControls: function() {
			var self = this;
			var errors = [];
			Object.keys(self.clientDiagnosesByBind).forEach(function($bind) {
				var diags = self.clientDiagnosesByBind[$bind];
				if (diags && diags.length > 0) {
					var controls = self.controlsByBind[$bind];
					controls && controls.forEach(function(control) {
						if (!control.validateInput()) {
							errors.push(control);
						}
					});
				}
			});
			return errors;
		},
		//
		// CONTROLS END
		//				

		//
		// SDATA START
		//				

		/**
		 * Called by UI to get a value
		 */
		getValue: function($bind) {
			return this.dataset.getValue($bind);
		},
		/**
		 * Called by UI to set a value
		 * 
		 * $bind: Property for which to set the value
		 * value: value
		 * updateUI: Set to true if UI needs to be update, this can happen if one control sets the value of another one
		 * 
		 */
		setValue: function($bind, value, updateUI, noServerUpdate) {
			this.dataset.setValue($bind, value);

			if (updateUI === true) {
				this.onDeltaValueChanged(this.dataset, $bind);
			}

			if (noServerUpdate !== true) {
				this.root._updateServer($bind)
					.fail(function(result) {
						modules.get("modal").error(result);
					});
			}
		},
		/**
		 * 
		 */
		addRow: function() {
			var row = this.dataset.addRow();
			return this.root._updateServer()
				.then(function() {
					return row;
				});
		},
		/**
		 * 
		 */
		removeRow: function($uuid) {
			this.dataset.removeRow($uuid);
			return this.root._updateServer();
		},
		getLazyUrl: function($bind) {
			return this.dataset.getValue($bind, this.isWorkingCopy);
		},
		/**
		 * Called by UI to get meta data
		 */
		getMetaData: function($bind) {
			return this.dataset.getMetaData($bind);
		},
		/**
		 * Called by UI when an sdata action is clicked
		 */
		triggerAction: function($actionName) {
			var self = this;
			return $.smResolve()
				.then(function() {
					if (!self.dataset.isRoot()) {
						// Actions are only allowed on root level of the representation
						return false;

					}
					var $action = self.dataset.getAction($actionName);
					var $title = $action && $action.$title;
					$title = $title || $actionName;
					$title = self.dataset.resolveExpression($title);

					// Check if there are client side data changes that are not in the dataset yet
					// because of invalid input like too big, mandatory not filled, ...
					// If we fail here, no need to ask the server
					var errorControls = self.findErrornousControls();
					if (errorControls.length > 0) {
						self._showNotification($title, "Error check your input first", "error"); // TODO: NLS
						return false;
					}

					var resultPromise = $.Deferred();
					self._countRequest(sdataReq.triggerAction($actionName, self.dataset, self.isWorkingCopy))
						.fail(function(response) {
							// We end here if http code is <> 2xx
							var diag = (response.data && response.data.$diagnoses ? response.data : (response.$diagnoses ? response : response));
							if (diag) {
								modules.get("modal").error(diag);
							}
							resultPromise.resolve(false);
						})
						.then(function(response) {
							var delta = response.data;
							if (delta) {
								// If there is a delta sent by the server, we merge it
								// This will add field level diagnoses
								// error checking will be done later independently
								return self._mergeDelta(delta).then(function() {
									return response;
								});
							}
							return response;
						})
						.then(function(response) {
							return protocolHelpers.computeActionResult($actionName, response);
						})
						.then(function(result) {
							// 
							if (result.$diagnose) {
								self._showNotification($title, result.$diagnose.$message, result.$diagnose.$severity);
							}
							if (result.success) {
								// There may be a $redirect link in the actions meta data we could use to navigate to the next page
								// from here
								resultPromise.resolve(true);
							} else {
								// Failed, so do nothing and let user modify data
								resultPromise.resolve(false);
							}
						});
					return resultPromise.promise();
				})
				.always(function() {
					if (environment.isAutoUITestMode()) {
						self._updatePageUpdateCycle();
					}
				});


		},

		/**
		 * Called by UI when a sdata link is clicked
		 */
		triggerLink: function($linkName) {
			var self = this;
			$.smResolve()
				.then(function() {
					var $link = self.dataset.getLink($linkName);
					if (!$link) {
						return;
					}
					return self.openLink($link, null, null, $linkName);
				});
		},

		/**
		 * Trigger navigation to the given link
		 * May switch $url and $method of link depending on protocol to be used (working copy / stateless)
		 */
		openLink: function($link, pageOptions, loadOptions, $linkName) {
			var self = this;
			$link = protocolHelpers.adjustLinkProtocol($link, this._getUsedProtocol());

			function _openLink() {
				var $url = self.dataset.resolveExpression($link.$url, true);
				if (!$url) {
					return $.smResolve();
				}
				if ($url.indexOf("$services") < 0 && $link.$method !== "DELETE") {
					return self.gotoUrl($url, $link.$method, pageOptions, loadOptions);
				} else {
					return self._executeLink($linkName, $url, $link.$method);
				}
			}
			if ($link.$confirm) {
				return self._askConfirmation($link.$confirm)
					.then(function(confirmed) {
						if (confirmed === "yes") {
							return _openLink();
						}
					});
			} else {
				return _openLink();
			}
		},
		/**
		 * Used to managed DELETE links which are more like actions
		 */
		_executeLink: function($linkName, $url, $method) {
			var self = this;

			var $link = self.dataset.getLink($linkName);
			var $title = $link && $link.$title;
			$title = self.dataset.resolveExpression($title);
			$title = $title || $linkName;

			var resultPromise = $.Deferred();

			self._countRequest(sdataReq.executeLink($url, $method, self.dataset))
				.fail(function(response) {
					// We end here if http code is <> 2xx
					if (response.data && response.data.$diagnoses) {
						var diag = response.data.$diagnoses[0];
						self._showNotification($title, diag.$message, "error");
					}
					resultPromise.resolve(false);
				})
				.then(function(response) {
					if (response.data && response.data.$diagnoses) {
						var diag = response.data.$diagnoses[0];
						self._showNotification($title, diag.$message, diag.$severity);
					}
					resultPromise.resolve(true);
				});

			return resultPromise.promise();
		},
		triggerDrillLevel: function(level, rowDataset) {
			if (rowDataset.getLink("$drillDown")) {
				this.drillDownLink(level, rowDataset)
			} else if (rowDataset.getLink("levelUp")) {
				this.levelUpLink(level, rowDataset)
			}
		},
		drillDownLink: function(level, dataset) {
			// when drill is called from array, the dataset of the row is this.dataset
			// else the dataset is the parameter ( see getChartClickHandler in builderChart)
			var rowDataset = dataset || this.dataset
			this.gotoUrl(rowDataset.getLinkDrillDown(), null, {
				isChild: false,
				context: {
					controllerId: this.id
				},
				isChartDetail: true,
				level: level + 1
			});
		},
		levelUpLink: function(level, dataset) {
			var rowDataset = dataset || this.dataset
			this.gotoUrl(rowDataset.getLinkLevelUp(), null, {
				isChild: false,
				context: {
					controllerId: this.id
				},
				isChartDetail: true,
				level: level + 1
			});
		},
		/**
		 * 
		 */
		_updateServer: function($bind) {
			var self = this;
			return $.smResolve()
				.then(function() {
					if (!self.isWorkingCopy) {
						return $.smResolve();
					}
					if (!self.isRoot()) {
						return $.smResolve();
					}
					if (!self.dataset.isDirty()) {
						return $.smResolve();
					}
					return self._countRequest(sdataReq.updateServer(self.dataset, $bind))
						.then(function(response) {
							return self._mergeDelta(response.data);
						})
				})
				.always(function() {
					if (environment.isAutoUITestMode()) {
						self._updatePageUpdateCycle();
					}
				});
		},

		_updatePageUpdateCycle: function() {
			var $$page = $('.s-m-page[data-controller-id="' + this.id + '"]');
			environment.getUnitTestMgr().setPageUpdateCycle($$page);
		},

		/**
		 * 
		 * Merge delta into local dataset and notify affected widgets on changes
		 * Returns delta given to this function so chaining is possible
		 */
		_mergeDelta: function(delta) {
			this.dataset.applyDelta(delta);
			return $.smResolve(delta);
		},

		//
		// SDATA END
		//		
		/**
		 * 
		 * @param promise
		 */
		_countRequest: function(promise) {
			var self = this;
			self.pendingRequests = self.pendingRequests + 1;
			self._updateRequestCount(self.pendingRequests);
			return promise.always(function(result) {
				self.pendingRequests = self.pendingRequests - 1;
				self._updateRequestCount(self.pendingRequests);
				return result;
			});
		},

		//
		// DELTA MANAGEMENT START		
		//				

		/**
		 * Used by dataset delta listeners to signal value changes
		 * dataset must be this.dataset, only passed to function for flexibility reasons 
		 */
		onDeltaValueChanged: function(dataset, $bind) {
			var ctrls = this._controlsByBind($bind);
			if (ctrls) {
				for (var ii = 0, jj = ctrls.length; ii < jj; ii++) {
					var ctrl = ctrls[ii];
					ctrl.onValueChanged && ctrl.onValueChanged();
				}
			}
		},
		/**
		 * Used by dataset delta listeners to signal meta data changes
		 * dataset must be this.dataset, only passed to function for flexibility reasons
		 */
		onDeltaMetaChanged: function(dataset, $bind) {
			var ctrls = this._controlsByBind($bind);
			if (ctrls) {
				for (var ii = 0, jj = ctrls.length; ii < jj; ii++) {
					var ctrl = ctrls[ii];
					ctrl.onMetaChanged && ctrl.onMetaChanged();
				}
			}
		},
		/**
		 * Used by dataset delta listeners to signal rows have been added to array
		 * dataset must be this.dataset, only passed to function for flexibility reasons 
		 */
		onDeltaRowAdded: function(dataset, $bind, $uuid, idx) {
			// TODO: 
		},
		/**
		 * Used by dataset delta listeners to signal rows have been removed on array
		 * dataset must be this.dataset, only passed to function for flexibility reasons
		 */
		onDeltaRowRemoved: function(dataset, $bind, $uuid, idx) {
			// TODO: 
		},
		/**
		 * Called when a row has moved
		 * Note that this will be called in the order of the smallest target row first
		 * So the UI can always remove the row from it's current position and move it to the new one
		 * All later notifications will have an impact on rows with higher new indices only
		 */
		onDeltaRowMoved: function(dataset, $bind, $uuid, newIdx) {
			// TODO: 
		},
		/**
		 * Used by dataset delta listeners to signal meta data changes for an action
		 */
		onDeltaActionChanged: function(dataset, $action, metaData) {
			this.onMenuItemChanged($action, null, metaData); // Implemented by standard controller to find affected widgets and trigger rendering
		},
		/**
		 * Used by dataset delta listeners to signal meta data changes for a link
		 */
		onDeltaLinkChanged: function(dataset, $link, $bind, metaData) {
			this.onMenuItemChanged($link, $bind, metaData); // Implemented by standard controller to find affected widgets and trigger rendering
		},

		//
		// DELTA MANAGEMENT END		
		//

		//		
		// UI EVENT LISTENER START 
		//
		onSdataLinkClicked: function($linkName) {
			this.triggerLink($linkName);
		},
		onSdataActionClicked: function(actionName) {
			this.triggerAction(actionName);
		},

		//		
		// UI EVENT LISTENER END 
		//				

		isEditMode: function() {
			var facet = this.getFacet();
			if (["$edit", "$create"].indexOf(facet) > -1) {
				return true;
			}
			return false;
		},
		getFacet: function() {
			return this.dataset.getRoot().prototype.getFacet();
		},

		/**
		 * Hook a new dataset to current controller
		 * This is used when page data has changed from outside (e.g. pagination or filtering)
		 */
		setDataset: function(dataset) {
			this.dataset.removeDeltaChangeListener(this);
			this.dataset = dataset;
			this.dataset.addDeltaChangeListener(this);
		},

		_getUsedProtocol: function() {
			var rootDataset = this.root.dataset;
			var $mobileProtocol = rootDataset && rootDataset.json.$clientContext && rootDataset.json.$clientContext.$mobileProtocol;
			return $mobileProtocol;
		},

		// Not finalized yet, just a draft that will be used by cancel on row
		// detail pages to revert a working copy
		applyDatasetBackup: function(datasetJson) {
			var self = this;
			var dataset = self.dataset;
			var prototype = self.dataset.prototype;

			var $binds = Object.keys(this.controlsByBind);
			$binds.forEach(function($bind) {
				//if (dataset.isDirty($bind)) {
				if (prototype.isReference($bind)) {
					var val = prototype.propGetRefValueName($bind);
					self.setValue(val, datasetJson[val], true, true);
				} else if (prototype.propIsSimple($bind)) {
					self.setValue($bind, datasetJson[$bind], true, true);
				}
				//}
			});

			return this.root._updateServer();
		},
		actChartToolbarSetDisplay: function(opts) {
			if (this.uiAdapter && this.uiAdapter.actToolbarSetDisplay) {
				return this.uiAdapter.actToolbarSetDisplay(opts);
			}
		}
	}
);