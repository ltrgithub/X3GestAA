"use strict";

var utils = require('syracuse-tablet/html/js/wc/helpers/utils');
var modules = require('syracuse-tablet/html/js/wc/common/modules');
var native = require('syracuse-tablet/html/js/wc/helpers/native/native');
var nativeExtLink = require('syracuse-tablet/html/js/wc/helpers/native/native').getModule("extLink");

var _controllerId = 1;
var _controllers = {};

/**
 * Base class for all controllers
 * Main purpose is to allow all controlls to register with a controller
 * 
 * Specific things like sdata management is in derived classes
 */
exports.Controller = utils.defineClass(
	function Controller(parent) {
		this.id = _controllerId++;
		_controllers[this.id] = this;
		this.uiAdapter = parent ? parent.uiAdapter : null;
		this._controlsById = {};
		this._controlsWithContext = [];
		// This will contain controls that render menu items ($links, $actions or actions (data-param)
		// it's used to apply dynamic meta data on them
		// Will be automatically managed for controls that have a "onMenuItemChanged" method
		this._menuItemContainersById = {};
		this._childrenControllers = {};
		this.parent = parent;
		this.root = (parent && parent.root) || this;
		if (parent) {
			// If parent is destroyed -> Children is destroyed
			parent.registerController(this);
		}
	},
	null, {

		destroy: function() {
			this.destroyed = true;
			delete _controllers[this.id];
			this.root = null;
			if (this._childrenControllers) {
				/**
				 * Destroy all children controllers
				 */
				for (var key in this._childrenControllers) {
					if (this._childrenControllers[key]) {
						this._childrenControllers[key].destroy();
					}
				}
			}
			this._childrenControllers = null;
			if (this.parent) {
				this.parent.unregisterController(this);
			}
			this.parent = null;
			/**
			 * Destroy all controls
			 * Controls are also destroyed and unregistered from controller when we destroy the parent in tree structure
			 * So it's mandatory to destroy the control here in case :
			 * -> there are remaining controls
			 * -> the controller is destroyed without having destroyed the tree structure
			 */
			if (this._controlsById) {
				this._forEachControl(function(c) {
					c.destroy();
				});
			}
			this._controlsById = null;
			this._menuItemContainersById = null;
			this._controlsWithContext = null;
			this.uiAdapter = null;
		},

		registerController: function(controller) {
			if (!controller) {
				return;
			}
			this._childrenControllers[controller.id] = controller;
		},

		unregisterController: function(controller) {
			if (!controller || !this._childrenControllers) {
				return;
			}
			delete this._controlsById[controller.id];
		},

		//
		// CONTROLS START
		//
		getControl: function(ctrlId) {
			return this._controlById(ctrlId);
		},

		/**
		 * Returns the control that will process the event
		 * Eg: arrayRow/array controllers the control attached to the controller is the row/array itself
		 * Like there's no possibility to get the row/array we ask the parent
		 */
		getControlForEvent: function(ctrlId, eventName) {
			var ctrl = this.getControl(ctrlId);
			if (!ctrl && this.parent) {
				ctrl = this.parent.getControlForEvent(ctrlId);
			}
			return ctrl;
		},


		getControlsByType: function($types) {
			if (!Array.isArray($types)) {
				$types = [$types]
			}
			var res = []
			this._forEachControl(function(c) {
				if ($types.indexOf(c.$type) >= 0) {
					res.push(c)
				}
			});
			return res;
		},
		registerControl: function(ctrl) {
			this._controlsById[ctrl.id] = ctrl;
			if (ctrl.onMenuItemChanged) {
				this._menuItemContainersById[ctrl.id] = ctrl;
			}
			if (ctrl.savedCtxCreate) {
				this._controlsWithContext.push(ctrl);
			}
		},
		unregisterControl: function(ctrl) {
			delete this._controlsById[ctrl.id];
			delete this._menuItemContainersById[ctrl.id];
			var idx = this._controlsWithContext.indexOf(ctrl);
			if (idx >= 0) {
				this._controlsWithContext.splice(idx, 1);
			}
		},
		_controlById: function(ctrlId) {
			return this._controlsById[ctrlId];
		},
		//
		// CONTROLS END
		//				

		//
		// START UI ADAPTER
		// UI adapter is used to allow the controller to trigger events that occur in the
		// user interface. This is to remove dependencies in the controller
		//
		setUIAdapter: function(uiAdapter) {
			this.uiAdapter = uiAdapter;
		},
		setNativeCapabilities: function(options) {
			if (!options || !options.nativeCapabilities) return null;
			var res = {};
			for (var capability in options.nativeCapabilities) {
				res[capability] = options.nativeCapabilities[capability] === true && native.hasCapability(capability) === true;
			}
			this._nativeCapabilities = res;
		},
		hasNativeCapabilities: function() {
			var self = this;
			var hasNative = Object.keys(this._nativeCapabilities).reduce(function(key1, key2) {
				return self._nativeCapabilities[key1] || self._nativeCapabilities[key2]
			}, false);
			return hasNative;
		},
		_showNotification: function(title, message, severity) {
			if (this.uiAdapter && this.uiAdapter._showNotification) {
				return this.uiAdapter._showNotification(title, message, severity);
			}
		},
		_askConfirmation: function($confirm) {
			if (this.uiAdapter && this.uiAdapter._askConfirmation) {
				return this.uiAdapter._askConfirmation($confirm);
			}
			return $.smResolve("yes");
		},
		_updateRequestCount: function(count) {
			if (this.uiAdapter && this.uiAdapter._updateRequestCount) {
				return this.uiAdapter._updateRequestCount(count);
			}
		},
		//
		// END UI ADAPTER
		//

		/**
		 * Used by event listener if a data-naction data-params element was clicked
		 * 
		 */
		onDataActionClicked: function(dataAction, dataParams) {
			var method = "_act" + $.camelCase("-" + dataAction);

			// Controller implements actions?
			func = this[method];
			if (func) {
				return func.call(this, dataParams);
			}

			// Page implements actions?
			var page = modules.get("navStack").getMainStack().getTopPage();
			if (page && page[method]) {
				return page[method].call(page, dataParams);
			}

			// App implements actions?
			var app = modules.get("appController").App;
			var func = app[method];
			if (func) {
				return func.call(app, dataParams);
			}
		},

		/**
		 * Called whenever a menu item changes
		 * $itemName can be the name of an action or link or something else that the containing widgets must know
		 */
		onMenuItemChanged: function($itemName, $bind, metaData) {
			var ids = Object.keys(this._menuItemContainersById);
			for (var i = 0, j = ids.length; i < j; i++) {
				var id = ids[i];
				var ctrl = this._menuItemContainersById[id];
				ctrl && ctrl.onMenuItemChanged($itemName, $bind, metaData);
			}
		},

		/** 
		 * Is this a root dataset (e.g. page level)
		 */
		isRoot: function() {
			return this != null && this == this.root;
		},

		/**
		 * All controls that do navigation (like ctrlReference for lookups) should ask the controller
		 * to navigate instead of doing the below in their own code.
		 * Doing it centralized in the controller allows sanity checks
		 */
		gotoUrl: function($url, $method, pageOptions, loadOptions) {
			return modules.get("navHelper").gotoUrl($url, $method, pageOptions, loadOptions);
		},
		/**
		 * Navigate to an external url
		 * Used by some controls like CtrlUrl, CtrlPhone, ...
		 */
		_actOpenExternalLink: function(url) {
			if (nativeExtLink) {
				nativeExtLink.openExternalLink(url);
			} else {
				window.open(url);
			}
		},
		/* We expose the module function here so that every component that knows a 
		 * controller can find other controllers without the need of including a 
		 * require to the controller module
		 */
		findController: function(controllerId) {
			return exports.findController(controllerId);
		},

		_forEachControl: function(cb) {
			if (!this._controlsById) {
				return;
			}
			var self = this;
			Object.keys(this._controlsById).forEach(function(key) {
				var c = self._controlsById[key];
				if (c) {
					cb(c);
				}
			})
		},
		savedCtxCreate: function(opts) {
			var self = this;
			var ctxCtrls = [];
			self._controlsWithContext.forEach(function(ctrl, idx) {
				var ctrlCtx = ctrl.savedCtxCreate(opts);
				if (ctrlCtx) {
					ctxCtrls.push(ctrlCtx);
				}
			})
			return ctxCtrls;
		},
		savedCtxRestore: function(ctrlsCtx) {
			if (!ctrlsCtx) {
				return;
			}
			var self = this;
			ctrlsCtx.forEach(function(ctrlCtx, idx) {
				var ctrl = self._controlsWithContext[idx];
				if (ctrl && ctrl.savedCtxRestore) {
					ctrl.savedCtxRestore(ctrlCtx)
				}
			})
		},
		savedCtxIndexOf: function(ctrl) {
			return this._controlsWithContext == null ? -1 : this._controlsWithContext.indexOf(ctrl);
		}
	}
);

exports.findController = function(id) {
	return _controllers[id];
}

exports.findControllerByDom = function($$elmt) {
	var $$controller = $$elmt.closest("[data-controller-id]");
	var controllerId = $$controller.attr("data-controller-id");
	return exports.findController(controllerId);
}

exports.findControlByDom = function($$elmt) {
	var controller = exports.findControllerByDom($$elmt);
	if (controller) {
		var $$ctrl = $$elmt.closest(".s-m-ctrl");
		var ctrlId = $$ctrl.attr("id");
		if (ctrlId) {
			return controller.getControl(ctrlId);
		}
	}
}