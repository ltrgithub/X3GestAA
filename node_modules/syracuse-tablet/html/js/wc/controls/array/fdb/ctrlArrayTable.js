"use strict";

var Base = require('syracuse-tablet/html/js/wc/controls/array/ctrlComplexArray').CtrlComplexArray;
var CtrlArrayTableRow = require('syracuse-tablet/html/js/wc/controls/array/ctrlArrayTableRow').CtrlArrayTableRow;
var utils = require('syracuse-tablet/html/js/wc/helpers/utils');
var globals = require('syracuse-tablet/html/js/wc/app/globals');
var SdataController = require("syracuse-tablet/html/js/wc/controllers/sdataController").SdataController;
var modules = require('syracuse-tablet/html/js/wc/common/modules');

var _additionalCols = [{
	isInPtoto: false,
	$activity: "edit",
	$bind: "rowEdit"
}, {
	isInPtoto: false,
	$activity: "edit",
	$bind: "rowDelete",
	$capabilities: "delete"
}, {
	isInPtoto: false,
	$activity: "read",
	$bind: "rowDetail"
}];

exports.CtrlArrayTable = utils.defineClass(
	function CtrlArrayTable(controller, article, prototype, options) {
		Base.call(this, controller, article, prototype, options);
		// BASE
		this.$itemProto = this.prototype.propGetProtoItem();
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
		},

		buildHtml: function() {
			//  BEFORE BUILD
			this._initBeforeBuild();
			// BUILD
			Base.prototype.buildHtml.call(this);
			this._createColumnInfo();
			/*
			if (this._createColumnInfo().length > 0) {
				if (this.isRefreshContext(buildOpts)) {
					// Force display because there's no resize
					this._build(buildOpts);
				} // Otherwise build is done on resize
			} else {
				this.control.$$value.addClass("empty");
			}*/
			// AFTER BUILD
			if (this.prototype.hasCapability("append")) {
				this.$$elmt.append($('<a class="btn btn-primary" href="#" data-nevent data-naction="addRow">Add row</a>'));
			}
		},

		_initBeforeBuild: function() {

			if (this.controller.root.isLookupController) {
				this.rowDetailLinkDomAttrs = this.getDataActionAttrs("lookupAccept");
			} else {
				// TODO: Customize by authoring
				var $linkName = "$details";
				this.rowDetailLinkDomAttrs = this.getSdataLinkAttrs($linkName);
			}
			if (this.prototype.parent.isQueryLikeFacet()) {
				this.showRowDelete = false;
				this.showRowDetail = false;
			} else {
				this.showRowDetail = true;
				this.showRowDelete = this.prototype.hasCapability("delete");
			}
		},


		createRecordCtrl: function(index, recordDataset, $bind) {
			var rowController = new SdataController(recordDataset, this.arrayController);
			var opts = {
				noEdit: true,
				// This is the link on rows for "real" navigation (e.g. go to $details)
				rowDetailLinkDomAttrs: this.rowDetailLinkDomAttrs,
				// Links for child arrays to remove/edit rows
				showRowDetail: this.showRowDetail,
				showRowDelete: this.showRowDelete
			}
			var rowCtrl = new CtrlArrayTableRow(rowController, {
				$bind: $bind
			}, recordDataset.prototype, opts);
			rowCtrl.set$$container(this.$$table);
			return rowCtrl;
		},

		_actAddRow: function() {
			var self = this;

			// Let the controller create a new row and eventually sync with the server
			// Then, render the new row afterwards since the server may set some values
			self.arrayController.addRow()
				.then(function(row) {
					if (row) {
						var index = self.arrayController.dataset.getRowIndex(row.json.$uuid);
						self.buildRow(index);
					}
				})
				.fail(function(result) {
					modules.get("modal").error(result);
				});

		},

		removeRow: function(rowCtrl) {
			var self = this;
			var rowUuid = rowCtrl.controller.dataset.json.$uuid
			self.arrayController.removeRow(rowUuid)
				.then(function() {
					self._destroyRemovedRow(rowCtrl);
				})
				.fail(function(result) {
					modules.get("modal").error(result);
				});
		},

		_destroyRemovedRow: function(rowCtrl) {
			var idx = this.children.indexOf(rowCtrl);
			if (idx > -1) {
				this.children.splice(idx, 1);
			}
			var controller = rowCtrl.controller;
			rowCtrl.destroy();
			controller && controller.destroy();
		},

		// get columns that should be displayed
		_createColumnInfo: function() {
			var self = this;
			if (this._tableColumnInfo) return this._tableColumnInfo;
			this._nbAdditionalCols = 0;
			this._tableColumnInfo = [];
			var nonDataCol = 0;
			if (this.article.$arrayOptions.rowIndex) {
				this._tableColumnInfo.push({
					isInPtoto: false,
					"$bind": "rowIndex"
				});
				nonDataCol++;
			}
			var statusList = this.getRowStatusInfo();
			if (statusList != null) {
				this._tableColumnInfo.push({
					isInPtoto: false,
					"$bind": "rowStatus"
				});
				nonDataCol++;
			}
			var unfound = [];
			var items = this.article.$table;
			var protoColumns = this.getColumnsInfo(true);
			if (!items) {
				items = protoColumns;
			}
			var dataProps = this.controller.dataset.getValueByPath("$properties");
			items.forEach(function(item, idx) {
				if (item.$isHidden || (dataProps && dataProps[item.$bind] && dataProps[item.$bind].$isHidden == true)) {
					return;
				}
				item.$widthType = item.$widthType ? item.$widthType : "auto";
				item.$widthVal = parseInt(item.$widthType === "auto" ? 0 : item.$widthVal, 10);
				item.$imgHeight = item.$imgHeight || "small";
				if (isNaN(item.$widthVal)) {
					item.$widthVal = 0;
				}
				var proto = self.$itemProto.getPropertyData(item.$bind);
				if (!proto) {
					unfound.push(item);
				} else if (proto.$isExcluded != true && proto.$type != "application/x-password") {
					var col = {
						"$bind": item.$bind,
						"proto": proto,
						"article": item
					};
					// Added as class to identify the column by field name - see sortInfoUpdate
					col.css = [self.$itemProto.getFieldValueName(item.$bind)];
					if (col.article.$isTitleHidden === true) {
						col.title = "";
					} else if (col.article.$title != null && col.article.$title != item.$bind && col.article.$titleOrig.indexOf('{@') >= 0) {
						// some translated titles are wrongly in article
						// Authoring save $title with sometimes $bind - we don't display it in the page
						// Title can be overridden bay article - TODO translation
						col.title = self.$itemProto.resolveExpression(col.article.$titleOrig || col.article.$title) || "";
					} else {
						col.title = col.proto.data('$title') || "";
					}
					self._tableColumnInfo.push(col);
				}
			});
			// if we don't display all the columns of the prototype we add the link to the detail of the row
			var overflow = (this._tableColumnInfo.length - nonDataCol) != protoColumns.length;
			if (this.article.$arrayOptions.showRowDetailLink === false) {
				// To not display the icon to display row'w detail
				overflow = false;
			}
			var editMode = self.controller.isEditMode();
			_additionalCols.forEach(function(col) {
				if ((editMode && col.$activity === "edit") || (!editMode && overflow && col.$activity === "read")) {
					if (col.$capabilities == null || self.prototype.hasCapability(col.$capabilities)) {
						var c = $.extend(true, {}, col);
						c.$widthType = "auto";
						self._tableColumnInfo.push(c);
						self._nbAdditionalCols++;
					}
				}
			});
			if (unfound.length > 0 && globals.getDvlpOpt("showUnfoundFields")) {
				var html = ['Field(s) not found<ul>'];
				unfound.forEach(function(x) {
					html.push("<li><b>" + x.$bind + "</b></li>");
				});
				html.push("</ul>");
				this.insertError(html.join(''));
			}
			return this._tableColumnInfo;
		}
	});