"use strict";

var Base = require('syracuse-tablet/html/js/wc/controls/array/builderBase').BuilderBase;
var CtrlArrayTableRow = require('syracuse-tablet/html/js/wc/controls/array/ctrlArrayTableRow').CtrlArrayTableRow;
var utils = require('syracuse-tablet/html/js/wc/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/wc/ui/uiUtils');
var globals = require('syracuse-tablet/html/js/wc/app/globals');
var SdataController = require("syracuse-tablet/html/js/wc/controllers/sdataController").SdataController;
var environment = require('syracuse-tablet/html/js/wc/helpers/environment');
var settings = require('syracuse-tablet/html/js/wc/app/settings');



var _fixedSzInfo = {};
/**
 * Calculates the sizes for characters, iconCells
 */
var _getFixedSizeInfo = function($$table) {
	var dev = settings.getDeviceType();
	var r = _fixedSzInfo[dev];
	if (r) return r;
	var $$body = $('<tbody></body>').appendTo($$table);
	var $$tr = $('<tr class="s-m-record"><td><div class="s-m-control s-m-field" style="width:100%"><div class="s-m-value" style="width:100%" ><span style="width:100%" id="text">MMMMMMMMMM</span></div></div></td><td class="s-m-icon"><div class="s-m-control s-m-icon"><a href="#" class="a"><span class="fa fa-hand-o-right"></span></a></div></td></tr>');
	$$tr.appendTo($$body);
	var tdWidth = $$tr.find("td").outerWidth();
	var valWidth = $$tr.find(".s-m-value").outerWidth();
	var textWidth = $$tr.find("#toto").width();
	r = {
		cellPadding: tdWidth - valWidth,
		charWidth: Math.ceil($$tr.find("#text").width() / 10),
		iconWidth: $$tr.find("td.s-m-icon").outerWidth()
	};
	$$body.remove();
	_fixedSzInfo[dev] = r;
	return r;
};

var _additionalCols = [{
	isProtoItem: false,
	$activity: "edit",
	$bind: "rowEdit",
	$widthType: "auto",
	css: ["s-m-icon"]
}, {
	isProtoItem: false,
	$activity: "edit",
	$bind: "rowDelete",
	$capabilities: "delete",
	$widthType: "auto",
	css: ["s-m-icon"]
}, {
	isProtoItem: false,
	$activity: "read",
	$bind: "rowDetail",
	$widthType: "auto",
	css: ["s-m-icon"]
}];

exports.BuilderTable = utils.defineClass(
	function builderTable(control) {
		Base.call(this, control);
		this._nbAdditionalCols = 0;
		this._tableColumnInfo = null;
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
		},

		buildHtml: function(data, $$parent) {
			if (this.controller.root.isLookupController) {
				this.rowDetailLinkDomAttrs = this.getDataActionAttrs("lookupAccept");
			} else {
				var $linkName = "$details";
				this.rowDetailLinkDomAttrs = this.control.getSdataLinkAttrs($linkName);
			}
			Base.prototype.buildHtml.call(this);
			this._createTableColumnInfo();
			if (this._tableColumnInfo.length === 0) {
				this.$$parent.addClass("empty");
			}
		},

		buildOnResize: function(data, $$parent, context) {
			if (this._tableColumnInfo.length > 0) {
				this._buildTable(data, $$parent);
			}
		},

		_buildTable: function(data, $$parent, context) {
			if (!this.checkEmptyArray()) {
				return;
			}
			$$parent.empty();
			var scrollMax = 0;
			var $$table = $(uiUtils.createDomElement("table", ["table", "table-condensed"], null, {
				"data-controller-id": this.control.arrayController.id
			}, $$parent));
			this._calulateWidths($$parent, $$table, data);
			// _buildTableHead build the regular header and return a clone of it
			// To scroll the body we need two tables
			// -> one that displays only the header
			// -> another one that display the body with same header (to preserve columns widths) but this header is hidden
			// $$headerScroll is a clone of the regular header 
			var $$headerScroll = this._buildTableHead($$table);
			if (data.length === 0 && this.control.controller.isEditMode()) {
				this.doAfterBuild();
				return;
			}
			if (this.isScrollable()) {
				// We create an other table without header to scroll the body
				$$table = $('<table class="table table-condensed"/>').appendTo($$parent);
				// We can't hide the header of the row that scrolls - We put visibility hidden and minimize the height
				// We put an offset of -1 * $$headerScroll.height() to the scrollwrapper to better hide $headerScroll
				$$headerScroll.css({
					fontSize: "0px",
					visibility: "hidden"
				}).appendTo($$table);
				if (this.$$tabHead && this.$$tabHead.length > 0 && $$headerScroll != this.$$tabHead) {
					var top = -1 * $$headerScroll.height();
					$$table.css("top", top + "px");
					this.$$tabHead.css("z-index", 500000);
					if (!environment.isNativeScrolling()) {
						// We need to shift up the scroll in hammerScroll
						scrollMax = top;
					}
				}
			}
			var $$body = $(uiUtils.createDomElement('tbody', null, null, null, $$table));

			for (var i = 0; i < data.length; i++) {
				this._buildTableRow($$body, data[i], i);
			}

			/*this._buildTableFoot($$table, arrayData, buildOpts);*/
			if (this.isScrollable()) {
				this.newScroller("v", $$table.addClass("s-m-scroll-elmt").wrap('<div class="s-m-scroll-wrapper"/>'), {
					nopadding: true,
					valMax: scrollMax
				});
			}
			this.doAfterBuild();
		},

		_buildTableHead: function($$table) {
			var $$tabHead = $(uiUtils.createDomElement('thead', null, null, null));
			var tr = uiUtils.createDomElement('tr', null, null, null, $$tabHead);
			this._tableColumnInfo.forEach(function(col) {
				var th = uiUtils.createDomElement('th', col.cssHeader || col.css, col.title || "", null, tr);
				if (col.fixedWidth != null && col.fixedWidth > 0) {
					$(th).width(col.fixedWidth);
				}
			});
			var $$headerScroll;
			if (this.control.getAuthoring("$tableHeaderShow") !== false) {
				$$headerScroll = $$tabHead.clone();
				this.$$tabHead = $$tabHead.appendTo($$table);

			} else {
				$$headerScroll = $$tabHead;
			}
			return $$headerScroll;
		},

		_buildTableRow: function($$body, recordDataset, index) {
			var $bind = this.control.$bind + "-" + recordDataset.$bind
			var rowController = new SdataController(recordDataset, this.control.arrayController);
			var opts = {
				rowIndex: index,
				noEdit: true,
				// This is the link on rows for "real" navigation (e.g. go to $details)
				rowDetailLinkDomAttrs: this.rowDetailLinkDomAttrs,
				// Links for child arrays to remove/edit rows
				showRowDetail: this.article.showRowDetailLink,
				showRowDelete: this.prototype.hasCapability("delete")
			}
			var rowCtrl = new CtrlArrayTableRow(rowController, {
				$bind: $bind
			}, recordDataset.prototype, opts);
			rowCtrl.set$$container($$body);
			rowCtrl.page = this.page;
			rowCtrl.buildHtml(this._tableColumnInfo);
			if (environment.isAutoUITestMode()) {
				environment.getUnitTestMgr().arrayAddRowIndex(rowCtrl.$$elmt, index);
			}
		},

		_calulateWidths: function($$parent, $$table, data) {
			var size = _getFixedSizeInfo($$table);
			// We substract the icon (edit/delete/detailRow)
			var maxWidth = $$parent.width() - (this._nbAdditionalCols * size.iconWidth);
			var fixedWidth = 0;
			var width;
			// Caluclate fixed width
			this._tableColumnInfo.forEach(function(i) {
				var art = i.article;
				i.fixedWidth = 0;
				if (art && art.$widthType === "fixed" && art.$widthVal > 0) {
					width = (size.charWidth * art.$widthVal) + size.cellPadding;
					if (width > 0 && ((fixedWidth + width) < maxWidth)) {
						i.fixedWidth = width;
						fixedWidth += width;
					}
				}
			});
			var remainingWidth = maxWidth - fixedWidth;
			var percentWidth = 0;
			// Caluclate % widths
			this._tableColumnInfo.forEach(function(i) {
				var art = i.article;
				if (art && art.$widthType === "percent" && art.$widthVal > 0) {
					width = ((art.$widthVal * remainingWidth) / 100) + size.cellPadding;
					if (width > 0 && ((percentWidth + width) < remainingWidth)) {
						i.fixedWidth = width;
						percentWidth += width;
					}
				}
			});
		},

		// get columns that should be displayed
		_createTableColumnInfo: function() {
			var self = this;
			if (this._tableColumnInfo) {
				return this._tableColumnInfo;
			}
			this._nbAdditionalCols = 0;
			this._tableColumnInfo = [];
			var nonDataCol = 0;
			if (this.article.$arrayOptions.rowIndex) {
				this._tableColumnInfo.push({
					"isProtoItem": false,
					"$bind": "rowIndex",
					"cssHeader": "s-m-rowidx"
				});
				nonDataCol++;
			}
			var statusInfo = this.control.getRowStatusInfo();
			if (statusInfo != null) {
				this._tableColumnInfo.push({
					"isProtoItem": false,
					"$bind": "rowStatus",
					"statusInfo": statusInfo,
					"cssHeader": "s-m-row-status"
				});
				nonDataCol++;
			}
			var unfound = [];
			var items = this.article.$table;
			var protoColumns = this.control.getColumnsInfo(true);
			if (!items) {
				items = protoColumns;
			}
			var dataProps = this.dataset.getValueByPath("$properties");
			items.forEach(function(item, idx) {
				if (item.$isHidden || (dataProps && dataProps[item.$bind] && dataProps[item.$bind].$isHidden == true)) {
					return;
				}
				item.$widthType = item.$widthType ? item.$widthType : "auto";
				item.$widthVal = parseInt(item.$widthType === "auto" ? 0 : item.$widthVal, 10);
				item.$imgHeight = item.$imgHeight || "small";
				if (isNaN(item.$widthVal)) {
					item.$widthVal = 0;
				}
				var proto = self.$itemProto.propGetProto(item.$bind);
				if (!proto) {
					unfound.push(item);
				} else if (proto.$isExcluded != true && proto.$type != "application/x-password") {
					var col = {
						"$bind": item.$bind,
						"proto": proto,
						"article": item
					};
					// Added as class to identify the column by field name - see sortInfoUpdate
					col.css = [self.$itemProto.getFieldValueName(item.$bind)];
					if (col.article.$isTitleHidden === true) {
						col.title = "";
					} else if (col.article.$title != null && col.article.$title != item.$bind && col.article.$titleOrig.indexOf('{@') >= 0) {
						// some translated titles are wrongly in article
						// Authoring save $title with sometimes $bind - we don't display it in the page
						// Title can be overridden bay article - TODO translation
						col.title = self.$itemProto.resolveExpression(col.article.$titleOrig || col.article.$title) || "";
					} else {
						col.title = col.proto.data('$title') || "";
					}
					col.isProtoItem = true;
					self._tableColumnInfo.push(col);
				}
			});
			// if we don't display all the columns of the prototype we add the link to the detail of the row
			var overflow = (this._tableColumnInfo.length - nonDataCol) != protoColumns.length;
			if (this.article.$arrayOptions.showRowDetailLink === false) {
				// To not display the icon to display row'w detail
				overflow = false;
			}
			var editMode = this.controller.isEditMode();
			_additionalCols.forEach(function(col) {
				if ((editMode && col.$activity === "edit") || (!editMode && overflow && col.$activity === "read")) {
					if (col.$capabilities == null || self.prototype.hasCapability(col.$capabilities)) {
						var c = $.extend(true, {}, col);
						c.$widthType = "auto";
						self._tableColumnInfo.push(c);
						self._nbAdditionalCols++;
					}
				}
			});
			if (unfound.length > 0 && globals.getDvlpOpt("showUnfoundFields")) {
				var html = ['Field(s) not found<ul>'];
				unfound.forEach(function(x) {
					html.push("<li><b>" + x.$bind + "</b></li>");
				});
				html.push("</ul>");
				this.insertError(html.join(''));
			}
			return this._tableColumnInfo;
		},

		isScrollable: function() {
			return this.control.isArrayChart() || (!this.control.isArrayField() && !this.control.page.isNestedInDashboard("stack"));
		}

	});