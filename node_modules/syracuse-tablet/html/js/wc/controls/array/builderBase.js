"use strict";
var utils = require('syracuse-tablet/html/js/wc/helpers/utils');
var scroller = require('syracuse-tablet/html/js/wc/helpers/scroller/scrollerHelpers');
var modules = require('syracuse-tablet/html/js/wc/common/modules');
var fontUtils = require('syracuse-tablet/html/js/wc/ui/fontUtils');
var fieldOperators = require('syracuse-tablet/html/js/wc/helpers/fieldOperators');

exports.getHtmlStatus = function(statusInfo, rowDataset) {
	if (!statusInfo || !rowDataset) return;
	var html = ['<div class="s-m-control s-m-row-status">'];
	var h, defIcon = fontUtils.getArrayStatusDefIcon(),
		icon;
	statusInfo.list.some(function(s) {
		if (s.color && fieldOperators.evaluateOperator(s.$type, rowDataset.getValue(s.field), s.operator, s.value)) {
			icon = s.icon || defIcon;
			// We use background color for color icon
			html.push('<div class="' + icon.css + '" style="color:' + s.color.bgColor + '"/>');
			return true;
		}
	});
	html.push('</div>');
	return html.join('');
}

var _isExcluded = ["application/x-password"];

exports.BuilderBase = utils.defineClass(
	function builderBase(control) {
		this.control = control;
		this.$itemProto = this.control.$itemProto;
		this.article = this.control.article;
		this.prototype = this.control.prototype;
		this.controller = this.control.controller;
		this.dataset = this.control.controller.dataset;
	}, null, {

		destroy: function() {
			this.control = null;
			this.$itemProto = null;
			this.article = null;
			this.controller = null;
			this.dataset = null;
			this.prototype = null;
		},

		/**
		 * Initialize building and builds the fixed elements of the array that doesn't depend on the parent's size
		 * data is an array of row's dataSet
		 */
		buildHtml: function(data, $$parent) {},

		/**
		 * Method called on resize (computeLayout)
		 * Builds the elements that need the parent's size
		 * -> scroller, chart, card...
		 */
		buildOnResize: function(data, $$parent, context) {},

		appendRow: function() {},

		insertError: function(html) {
			$(['<span class="s-m-error">', html, "</span>"].join('')).prependTo(this.control.$$elmt);
		},

		/**
		 * Returns false to break build process
		 */
		checkEmptyArray: function() {
			if (this.control.isEmpty) {
				this.refreshHeaderAndGesture();
				this.control.setEmptyArrayMsg();
				return false;
			}
			return true;
		},

		doAfterBuild: function() {
			this.refreshHeaderAndGesture();
		},

		refreshHeaderAndGesture: function(resizeContext) {
			resizeContext = resizeContext || {};
			var scrollOnly = resizeContext.scrollOnly;
			var preserveScroll = resizeContext.preserveScroll;
			// we refresh only if it's a windows resize (other type if internalResize)
			var justRefresh = resizeContext != null && resizeContext.resizeEvent && resizeContext.resizeEvent.type === "resize";
			/**
			 * Workaround to check if the display of filters changed
			
			if (scrollOnly !== true) {
				this._refreshHeader(justRefresh);
			} 
			*/
			this._initGestureMgr(preserveScroll);
			/**
			if (this._lastSelectedRow) {

				 * Workaround to preserve last selected line
				 * onResize broke the regular process and onResize is call when we activate a cached page
				 * lastRowSelection is done before the onResize (page.activate) so we need to preserve the selection
				 * Here because the build of array is asynchronous so we can't call this code in ctrlArray.onResize
				
				this.selectLastSelectedRow(this._lastSelectedRow, true);
			}
			 */
		},

		_initGestureMgr: function(preserveScroll) {
			if (this._gestureMgr) {
				if (this.isScrollable()) {
					// ScrollViewRect has changed so we check to re-init or reset _gestureMgr 
					this._gestureMgr.checkViewRect(this.control.getScrollViewRect(), preserveScroll);
				} else {
					this._gestureMgr.reset();
				}
			}
			/*
			if (this._restoreSelectedRowId) {
				// Restore the selected row - We do the job here to be able to make the line visible 
				var $$row = this.selectLastSelectedRow(this._restoreSelectedRowId, true);
				if ($$row && this._gestureMgr) {
					// Scroll to make row visible
					this._gestureMgr.makeVisible($$row);
				}
				this._restoreSelectedRowId = null;
			}
			*/
		},

		isScrollable: function() {
			return true;
		},

		/**
		 * True if field is excluded
		 */
		isExcluded: function(proto) {
			return proto == null || proto.json.$isExcluded === true || _isExcluded.indexOf(proto.json.$type) >= 0;
		},

		newScroller: function(type, $$elmt, options) {
			this.destroyScroller();
			options = $.extend(true, {
				direction: type,
				name: this.control.$bind,
				isPageScroller: false
			}, options);
			if (options.valMax == null) {
				options.valMax = 0;
			};
			this._gestureMgr = scroller.newScroller($$elmt, options, modules.get("navStack").getMainStack().getTopPage().getGestureMgr());
			if (this._restoreGestureMgr != null) {
				this._gestureMgr.savedCtxRestore(this._restoreGestureMgr, false);
				this._restoreGestureMgr = null;
			}
			return this._gestureMgr;
		},

		destroyScroller: function() {
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},
		hasScroller: function() {
			return this._gestureMgr != null;
		}
	});