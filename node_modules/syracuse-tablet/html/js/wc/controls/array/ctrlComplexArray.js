"use strict";

var Base = require('syracuse-tablet/html/js/wc/controls/ctrlSdataBase').CtrlSdataBase;
var utils = require('syracuse-tablet/html/js/wc/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/wc/ui/uiUtils');
var environment = require('syracuse-tablet/html/js/wc/helpers/environment');
var SdataController = require("syracuse-tablet/html/js/wc/controllers/sdataController").SdataController;
var paginators = require("syracuse-tablet/html/js/wc/controls/array/paginators");
var RendererHeader = require('syracuse-tablet/html/js/wc/controls/array/rendererHeader').RendererHeader;
var SearchArray = require('syracuse-tablet/html/js/wc/controls/array/searchArray').SearchArray;
var FiltersSort = require('syracuse-tablet/html/js/wc/controls/array/filtersSort');


/**
 * 
 * Array control
 * 
 * Will create it's own controller to manage array only
 * Per row, it will create a row controller and row control to represent the row
 * Doing it like this, there is always a flat structure per control
 * 
 * For value rendering, "normal" field controls are used
 * 
 */
exports.CtrlComplexArray = utils.defineClass(
	function CtrlComplexArray(controller, article, prototype, options) {
		Base.call(this, controller, article, prototype, options);
		this._checkAuthoring();
		this._rendererHeader = this._ensureRendererHeader()
			// An array has it's own controller scoped to the array property only
		this.arrayDataset = controller.dataset.getChild(this.$bind);
		this.arrayController = new SdataController(this.arrayDataset, controller);
		this.arrayController.registerControl(this);
		this._ensurePaginator();
		var savedContext = this.controller.getSavedContext();
		this._search = new SearchArray(savedContext ? savedContext.$search : null);
		this._filters = new FiltersSort.Filters(this); // Predefined x3 filters
		this.filterSort = new FiltersSort.FilterSort(this); // in relation with panel filterSort

	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this.arrayDataset) {
				this.arrayDataset.destroy();
				this.arrayDataset = null;
			}

			// Since the array creates it's own controller, it must also be destroyed here
			if (this.arrayController) {
				this.arrayController.destroy();
				this.arrayController = null;
			}

			if (this.paginator) {
				this.paginator.destroy();
				this.paginator = null;
			}
			if (this._search) {
				this._search.destroy();
				this._search = null;
			}
			if (this._rendererHeader) {
				this._rendererHeader.destroy();
				this._rendererHeader = null;
			}
			if (this._filters) {
				this._filters.destroy();
				this._filters = null;
			}
			if (this.filterSort) {
				this.filterSort.destroy();
				this.filterSort = null;
			}
		},

		_ensureRendererHeader: function() {
			return new RendererHeader(this);
		},

		_checkAuthoring: function() {
			// By default
			var defAuthoring = {
				showPagination: true,
				showSortFilter: true,
				showSearch: true,
				rowIndex: this.$display === "card"
			};
			var isChartDetail = false;
			var isRowDetail = false;
			if (this.controller.isVignette != true && isChartDetail) {
				defAuthoring.showPagination = defAuthoring.showSortFilter = defAuthoring.showSearch = false;
			}
			this.article.$arrayOptions = $.extend(true, defAuthoring, this.article.$arrayOptions || {});
			if (isChartDetail) {
				// No row detail in chart detail
				this.article.$arrayOptions.showRowDetailLink = false;
			} else if (isRowDetail) {
				// Force in row detail because no authoring
				this.article.$arrayOptions.showRowDetailLink = true;
			} else if (this.article.$arrayOptions.showRowDetailLink == null) {
				// False by default in other pages
				this.article.$arrayOptions.showRowDetailLink = false;
			}
		},

		buildHtml: function() {
			if (!this.$$elmt) {
				Base.prototype.buildHtml.call(this, ["s-m-array", "s-m-" + this.article.$display]);
			}
			this._buildHeader();
			// All array rendering are table based
			this.$$table = $(uiUtils.createDomElement("table", null, null, {
				"data-controller-id": this.arrayController.id
			}, this.$$elmt));

			var jj = this.paginator.getNumRowsPage();
			for (var ii = 0; ii < jj; ii++) {
				this.buildRecord(ii);
			}

			if (this._rendererHeader) {
				this.filterSort.filterSortUpdate(this._rendererHeader.$$elmt);
			}
		},
		/**
		 * 
		 */
		buildRecord: function(index) {
			var recordDataset = this.paginator.getRowByIndex(index);
			var $bind = this.$bind + "-" + recordDataset.$bind;
			var recordCtrl = this.createRecordCtrl(index, recordDataset, $bind);
			if (recordCtrl) {
				recordCtrl.page = this.page;
				recordCtrl.buildHtml();
				if (environment.isAutoUITestMode()) {
					environment.getUnitTestMgr().arrayAddRowIndex(recordCtrl.$$elmt, index);
				}
			}
		},
		createRecordCtrl: function(index, recordDataset, $bind) {
			return null;
		},
		/** 
		 * Called by paginator on client side pagination to just redraw the array
		 * Must cleanup DOM and other stuff created before and then trigger a rebuild of the array only
		 */
		rebuildHtml: function() {
			// Children of the array are always only the array rows created by the array itself
			// since a new controller was created per row, we need to destroy the widget (child)
			// and also it's controller right after
			this.children && this.children.forEach(function(child) {
				var controller = child.controller;
				child.destroy();
				controller && controller.destroy();
			});
			this.buildHtml();
		},

		/**
		 * Called by paginator on server side pagination
		 * The paginator tells the array the new url which has to be loaded
		 * and the array just asks it's containing page to reload
		 */
		paginateTo: function($link) {
			this.page.fetchNewPageData($link)
		},

		_buildHeader: function() {
			this._rendererHeader.render();
		},

		_updateHeader: function() {
			if (this._rendererHeader) {
				this._rendererHeader.update();
			}
		},

		_ensurePaginator: function() {
			// TODO: For statistics ($cube facet) use client side paginator (ArrayPaginatorClient)
			this.paginator = new paginators.ArrayPaginatorServer(this);
			//this.paginator = new paginators.ArrayPaginatorClient(this, 10);
		},

		_actPagination: function(direction) {
			if (!this.paginator.isEnabled(direction)) {
				return;
			}
			this.paginator.paginate(direction);
		},
		_actActionArray: function(id, param) {
			switch (id) {
				case "panelfiltersort":
					this._openFilterSortPanel();
					break;
				case "filterSelected":
					this._filters.filtersSelect(param);
					break;
				case "search":
					this._search.search(this);
					break;
				case "removeSearch":
					this._search.removeSearch(this);
					break;
			}
		},
		_openFilterSortPanel: function() {
			var panel = this.page.openPanel("filterSortPanel", {
				filter: true,
				sort: true
			})
			panel.ensureParentArray(this.id)
			panel.show();
		},
		isArrayField: function() {
			if (!this.controller) return false;
			return !this.prototype.root.isQueryLikeFacet();
		},
		/*Used by filterSort filters and searchArray*/
		_optUrl: function() {
			var opt = {
				"$url": this.page.pageData.prototype.getValueByPath("$url", true, true),
				"$filters": this._filters._$filterGetInfo(),
				"sortInfo": this.page.getPageSort(),
				"filterInfos": this.page.getPageFilter(),
				"searchInfo": (this._filters ? this._filters.searchInfos : null)
			};
			return opt;
		},
		excludeChildrenFromAuthoring: function() {
			return true;
		},

		// OK FDB
		getRowStatusInfo: function() {
			var type = this.getAuthoring("$statusEnabled");
			if (type === "mono" || type === "multi") {
				var status = this.getAuthoring("$status");
				if (status == null || $.isEmptyObject(status)) return null;
				return {
					type: type,
					list: status
				};
			}
			return null;
		},

		insertError: function(html) {
			$(['<span class="s-m-error">', html, "</span>"].join('')).prependTo(this.$$elmt);
		},

		// OK FDB
		getColumnsInfo: function(onlyVisible) {
			if (!this._columnsInfo) {
				var base = {
					$title: "",
					$titleOrig: "", // title not resolved
					$type: "",
					$bind: "",
					$widthType: "auto",
					$imgHeight: "small",
					$widthVal: 0,
					$capabilities: ""
				};
				this._columnsInfo = [];
				var props = this.prototype.getValueByPath("$item.$properties");
				if (props) {
					var self = this;
					Object.keys(props).forEach(function($bind) {
						var prop = props[$bind];
						if (prop.$isHidden !== true && prop.$isExcluded !== true && ["CREUSR", "CREUSR_REF", "UPDUSR", "UPDUSR_REF"].indexOf($bind) < 0) {
							var p = $.extend(true, {}, base, prop);
							p.$title = self.$itemProto.resolveExpression(prop.$title);
							p.$titleOrig = prop.$title;
							// Bind field - Ex SITE_REF
							p.$bind = $bind;
							// Name of the field that contains the value - !=$bind for non reference fields - Ex For SITE_REF -> SITE
							p.$bindValue = self.$itemProto.getFieldValueName($bind);
							// Type of the field that contains the value - !=$type for non reference fields - Ex For SITE -> "application/x-string"
							p.$bindType = self.$itemProto.getFieldValueType($bind);
							self._columnsInfo.push(p);
						}
					});
				}
			}
			// META
			var dataProps = this.controller.dataset.getValueByPath("$properties");
			if (onlyVisible !== true || dataProps == null) {
				return this._columnsInfo;
			}
			var res = [];
			this._columnsInfo.forEach(function(prop) {
				if (dataProps[prop.$bind] == null || dataProps[prop.$bind].$isHidden !== true) {
					res.push(prop);
				}
			});
			return res;
		}

	});