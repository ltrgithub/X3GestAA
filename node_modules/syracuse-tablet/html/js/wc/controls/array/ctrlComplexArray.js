"use strict";

var Base = require('syracuse-tablet/html/js/wc/controls/ctrlSdataBase').CtrlSdataBase;
var utils = require('syracuse-tablet/html/js/wc/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/wc/ui/uiUtils');
var SdataController = require("syracuse-tablet/html/js/wc/controllers/sdataController").SdataController;
var paginators = require("syracuse-tablet/html/js/wc/controls/array/paginators");
var BuilderHeader = require('syracuse-tablet/html/js/wc/controls/array/builderHeader').BuilderHeader;
var SearchArray = require('syracuse-tablet/html/js/wc/controls/array/searchArray').SearchArray;
var FiltersSort = require('syracuse-tablet/html/js/wc/controls/array/filtersSort');
var modules = require('syracuse-tablet/html/js/wc/common/modules');
var BuilderTable = require('syracuse-tablet/html/js/wc/controls/array/builderTable').BuilderTable;
var BuilderCard = require('syracuse-tablet/html/js/wc/controls/array/builderCard').BuilderCard;
var BuilderCarousel = require('syracuse-tablet/html/js/wc/controls/array/builderCarousel').BuilderCarousel;
var BuilderSeparator = require('syracuse-tablet/html/js/wc/controls/array/builderSeparator').BuilderSeparator;
var _builders = {
	table: BuilderTable,
	card: BuilderCard,
	carousel: BuilderCarousel,
	separator: BuilderSeparator
};

/**
 * 
 * Array control
 * 
 * Will create it's own controller to manage array only
 * Per row, it will create a row controller and row control to represent the row
 * Doing it like this, there is always a flat structure per control
 * 
 * For value rendering, "normal" field controls are used
 * 
 */
exports.CtrlComplexArray = utils.defineClass(
	function CtrlComplexArray(controller, article, prototype, options) {
		Base.call(this, controller, article, prototype, options);
		this.$itemProto = this.prototype.propGetProtoItem();
		this.displayAsCarousel = false;
		this._checkAuthoring();
		// An array has it's own controller scoped to the array property only
		this.arrayDataset = controller.dataset.getChild(this.$bind);
		this.arrayController = new SdataController(this.arrayDataset, controller);
		this.arrayController.registerControl(this);
		this._ensurePaginator();
		var savedContext = this.controller.getSavedContext();
		this._search = new SearchArray(savedContext ? savedContext.$search : null);
		this._filters = new FiltersSort.Filters(this); // Predefined x3 filters
		this.filterSort = new FiltersSort.FilterSort(this); // in relation with panel filterSort
		this.isEmpty = false;
		this.builderContent = null;
		this.builderHeader = null;
		this._arrayData = null;
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this.$itemProto) {
				this.$itemProto.destroy();
				this.$itemProto = null;
			}
			if (this.arrayDataset) {
				this.arrayDataset.destroy();
				this.arrayDataset = null;
			}
			// Since the array creates it's own controller, it must also be destroyed here
			if (this.arrayController) {
				this.arrayController.destroy();
				this.arrayController = null;
			}
			if (this.paginator) {
				this.paginator.destroy();
				this.paginator = null;
			}
			if (this._search) {
				this._search.destroy();
				this._search = null;
			}
			if (this.builderHeader) {
				this.builderHeader.destroy();
				this.builderHeader = null;
			}
			if (this._filters) {
				this._filters.destroy();
				this._filters = null;
			}
			if (this.filterSort) {
				this.filterSort.destroy();
				this.filterSort = null;
			}
			if (this.builderContent) {
				this.builderContent.destroy();
				this.builderContent = null;
			}
			this.destroyArrayData();
		},

		destroyArrayData: function() {
			if (!this._arrayData) return;
			this._arrayData.forEach(function(dataSet) {
				dataSet.destroy();
			});
			this._arrayData = null;
		},

		_checkAuthoring: function() {
			var $display = this.controller.isEditMode() || !this.article.$display ? "table" : this.article.$display;
			if ($display === "carousel") {
				$display = "card";
				this.displayAsCarousel = true;
			}
			// By default
			var defAuthoring = {
				showPagination: true,
				showSortFilter: true,
				showSearch: true,
				rowIndex: this.$display === "card"
			};
			var page = this.controller.uiAdapter;
			var isChartDetail = page && page.isChild("SdataRowDetail");
			var isRowDetail = page && page.isChild("SdataChartDetail");
			if (isChartDetail && pageoptions.isVignette != true) {
				defAuthoring.showPagination = defAuthoring.showSortFilter = defAuthoring.showSearch = false;
			}
			this.article.$arrayOptions = $.extend(true, defAuthoring, this.article.$arrayOptions || {});
			if (isChartDetail) {
				// No row detail in chart detail
				this.article.$arrayOptions.showRowDetailLink = false;
			} else if (isRowDetail) {
				// Force in row detail because no authoring
				this.article.$arrayOptions.showRowDetailLink = true;
			} else if (this.article.$arrayOptions.showRowDetailLink == null) {
				// False by default in other pages
				this.article.$arrayOptions.showRowDetailLink = false;
			}
		},

		_newBuilderContent: function() {
			var BuilderClass = _builders[this.article.$display == "card" ? this.displayAsCarousel ? "carousel" : "card" : this.article.$display];
			if (!BuilderClass) {
				this.article.$display = "table";
				this.displayAsCarousel = false;
				BuilderClass = _builders.table;
			}
			return new BuilderClass(this);
		},

		_newBuilderHeader: function() {
			return new BuilderHeader(this);
		},


		_iniBeforeBuild: function() {
			this.clearContent();
			this._initArrayData();
			this.isEmpty = this._arrayData.length === 0;
			this.$$elmt.toggleClass("empty", this.isEmpty);
			var displayArray = this.controller.isEditMode() === true || this.isEmpty !== true || this.getAuthoring("$displayIfEmpty") === true;
			// Title
			var title = (this.getTitle() || "").trim();
			if (displayArray && title.length > 0 && this.getAuthoring("$isTitleHidden")) {
				$(uiUtils.createDomElement('div', ["s-m-title"])).appendTo(this.$$elmt).text(title);
			}
			// After title
			this.$$content = $(uiUtils.createDomElement('div', ["s-m-value"])).appendTo(this.$$elmt)
			if (this.$display === "card" && this.article.$arrayBgColor) {
				this.$$content.addClass("s-m-bg " + this.article.$arrayBgColor.toLowerCase());
			}
			return this._arrayData;
		},
		_initArrayData: function() {
			this.destroyArrayData();
			// Can be able to manage local pagination
			this._arrayData = [];
			var jj = this.paginator.getNumRowsPage();
			for (var ii = 0; ii < jj; ii++) {
				this._arrayData.push(this.paginator.getRowByIndex(ii))
			}
		},
		clearContent: function(refresh) {
			if (!this.$$elmt) {
				Base.prototype.buildHtml.call(this, ["s-m-array", "s-m-" + this.article.$display]);
			}
			if (this.builderContent) {
				this.builderContent.destroy();
			}
			if (this.builderHeader) {
				this.builderHeader.destroy();
			}
			this.$$elmt.empty();
			this.builderContent = this._newBuilderContent(this);
			this.builderHeader = this._newBuilderHeader(this);
		},

		buildHtml: function() {
			this._iniBeforeBuild();
			if (this.builderHeader) {
				this.builderHeader.buildHtml();
				this.filterSort.filterSortUpdate(this.builderHeader.$$elmt);
			}
			// Build elements that don't depend on parent's size
			this.builderContent.buildHtml(this._arrayData, this.$$content);
		},

		// Build elements that depend on parent's size
		buildOnResize: function(context) {
			this.builderContent.buildOnResize(this._arrayData, this.$$content, context);
		},

		computeLayout: function(context) {
			this.buildOnResize(context);
		},

		/** 
		 * Called by paginator on client side pagination to just redraw the array
		 * Must cleanup DOM and other stuff created before and then trigger a rebuild of the array only
		 */
		rebuildHtml: function() {
			// Children of the array are always only the array rows created by the array itself
			// since a new controller was created per row, we need to destroy the widget (child)
			// and also it's controller right after
			this.children && this.children.forEach(function(child) {
				var controller = child.controller;
				child.destroy();
				controller && controller.destroy();
			});
			this.buildHtml();
		},

		/**
		 * Called by paginator on server side pagination
		 * The paginator tells the array the new url which has to be loaded
		 * and the array just asks it's containing page to reload
		 */
		paginateTo: function($link) {
			this.page.fetchNewPageData($link)
		},

		_ensurePaginator: function() {
			// TODO: For statistics ($cube facet) use client side paginator (ArrayPaginatorClient)
			this.paginator = new paginators.ArrayPaginatorServer(this);
			//this.paginator = new paginators.ArrayPaginatorClient(this, 10);
		},

		_actPagination: function(direction) {
			if (!this.paginator.isEnabled(direction)) {
				return;
			}
			this.paginator.paginate(direction);
		},
		_actActionArray: function(id, param) {
			switch (id) {
				case "panelfiltersort":
					this._openFilterSortPanel();
					break;
				case "filterSelected":
					this._filters.filtersSelect(param);
					break;
				case "search":
					this._search.search(this);
					break;
				case "removeSearch":
					this._search.removeSearch(this);
					break;
			}
		},
		_openFilterSortPanel: function() {
			var panel = this.page.openPanel("filterSortPanel", {
				filter: true,
				sort: true
			})
			panel.ensureParentArray(this.id)
			panel.show();
		},
		isArrayField: function() {
			if (!this.controller) return false;
			return !this.prototype.root.isQueryLikeFacet();
		},
		isArrayChart: function() {
			return false;
		},
		/*Used by filterSort filters and searchArray*/
		_optUrl: function() {
			var opt = {
				"$url": this.page.pageData.prototype.getValueByPath("$url", true, true),
				"$filters": this._filters._$filterGetInfo(),
				"sortInfo": this.page.getPageSort(),
				"filterInfos": this.page.getPageFilter(),
				"searchInfo": (this._search ? this._search.searchInfos : null)
			};
			return opt;
		},
		excludeChildrenFromAuthoring: function() {
			return true;
		},

		getRowStatusInfo: function() {
			var type = this.getAuthoring("$statusEnabled");
			if (type === "mono" || type === "multi") {
				var status = this.getAuthoring("$status");
				if (status == null || $.isEmptyObject(status)) return null;
				return {
					type: type,
					list: status
				};
			}
			return null;
		},

		/**
		 * Returns the columns to display with all info needed by builder
		 */
		getColumnsInfo: function(onlyVisible) {
			if (!this._columnsInfo) {
				var base = {
					$title: "",
					$titleOrig: "", // title not resolved
					$type: "",
					$bind: "",
					$widthType: "auto",
					$imgHeight: "small",
					$widthVal: 0,
					$capabilities: ""
				};
				this._columnsInfo = [];
				var props = this.prototype.getValueByPath("$item.$properties");
				if (props) {
					var self = this;
					Object.keys(props).forEach(function($bind) {
						var prop = props[$bind];
						if (prop.$isHidden !== true && prop.$isExcluded !== true && ["CREUSR", "CREUSR_REF", "UPDUSR", "UPDUSR_REF"].indexOf($bind) < 0) {
							var p = $.extend(true, {}, base, prop);
							p.$title = self.$itemProto.resolveExpression(prop.$title);
							p.$titleOrig = prop.$title;
							// Bind field - Ex SITE_REF
							p.$bind = $bind;
							// Name of the field that contains the value - !=$bind for non reference fields - Ex For SITE_REF -> SITE
							p.$bindValue = self.$itemProto.getFieldValueName($bind);
							// Type of the field that contains the value - !=$type for non reference fields - Ex For SITE -> "application/x-string"
							p.$bindType = self.$itemProto.getFieldValueType($bind);
							self._columnsInfo.push(p);
						}
					});
				}
			}
			// META
			var dataProps = this.controller.dataset.getValueByPath("$properties");
			if (onlyVisible !== true || dataProps == null) {
				return this._columnsInfo;
			}
			var res = [];
			this._columnsInfo.forEach(function(prop) {
				if (dataProps[prop.$bind] == null || dataProps[prop.$bind].$isHidden !== true) {
					res.push(prop);
				}
			});
			return res;
		},

		_actAddRow: function() {
			var self = this;

			// Let the controller create a new row and eventually sync with the server
			// Then, render the new row afterwards since the server may set some values
			self.arrayController.addRow()
				.then(function(row) {
					if (row) {
						var index = self.arrayController.dataset.getRowIndex(row.json.$uuid);
						self.builderContent.appendRow(index);
					}
				})
				.fail(function(result) {
					modules.get("modal").error(result);
				});

		},

		removeRow: function(rowCtrl) {
			var self = this;
			var rowUuid = rowCtrl.controller.dataset.json.$uuid
			self.arrayController.removeRow(rowUuid)
				.then(function() {
					self._destroyRemovedRow(rowCtrl);
				})
				.fail(function(result) {
					modules.get("modal").error(result);
				});
		},

		_destroyRemovedRow: function(rowCtrl) {
			var idx = this.children.indexOf(rowCtrl);
			if (idx > -1) {
				this.children.splice(idx, 1);
			}
			var controller = rowCtrl.controller;
			rowCtrl.destroy();
			controller && controller.destroy();
		},

		_displayTitle: function(title) {
			if (title == null || title.trim().length === 0) return false;
			if (this.getAuthoring("$isTitleHidden") === true) return false;
			return this._displayArray();
		},

		_displayArray: function() {
			return this.controller.isEditMode() === true || this.isEmpty !== true || this.getAuthoring("$displayIfEmpty") === true;
		},
		getScrollViewRect: function() {
			if (this.page.parentVignette) {
				return this.page.parentVignette.getScrollViewRect();
			} else {
				return this.page.mainContentRect;
			}
		}
	});