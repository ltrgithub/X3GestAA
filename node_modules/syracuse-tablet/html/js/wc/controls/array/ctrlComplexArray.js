"use strict";

var Base = require('syracuse-tablet/html/js/wc/controls/ctrlSdataBase').CtrlSdataBase;
var utils = require('syracuse-tablet/html/js/wc/helpers/utils');
var locale = require('syracuse-tablet/html/js/wc/helpers/locale');
var uiUtils = require('syracuse-tablet/html/js/wc/ui/uiUtils');
var settings = require('syracuse-tablet/html/js/wc/app/settings');
var SdataController = require("syracuse-tablet/html/js/wc/controllers/sdataController").SdataController;
var CtrlArrayTableRow = require('syracuse-tablet/html/js/wc/controls/array/ctrlArrayTableRow').CtrlArrayTableRow;
var paginators = require("syracuse-tablet/html/js/wc/controls/array/paginators");
var BuilderHeader = require('syracuse-tablet/html/js/wc/controls/array/builderHeader').BuilderHeader;
var SearchArray = require('syracuse-tablet/html/js/wc/controls/array/searchArray').SearchArray;
var FiltersSort = require('syracuse-tablet/html/js/wc/controls/array/filtersSort');
var modules = require('syracuse-tablet/html/js/wc/common/modules');
var BuilderTable = require('syracuse-tablet/html/js/wc/controls/array/builderTable').BuilderTable;
var BuilderCard = require('syracuse-tablet/html/js/wc/controls/array/builderCard').BuilderCard;
var BuilderCarousel = require('syracuse-tablet/html/js/wc/controls/array/builderCarousel').BuilderCarousel;
var BuilderSeparator = require('syracuse-tablet/html/js/wc/controls/array/builderSeparator').BuilderSeparator;
var BuilderChart = require('syracuse-tablet/html/js/wc/controls/array/builderChart').BuilderChart;

var _builders = {
	table: BuilderTable,
	card: BuilderCard,
	carousel: BuilderCarousel,
	separator: BuilderSeparator,
	chart: BuilderChart
};

/**
 * 
 * Array control
 * 
 * Will create it's own controller to manage array only
 * Per row, it will create a row controller and row control to represent the row
 * Doing it like this, there is always a flat structure per control
 * 
 * For value rendering, "normal" field controls are used
 * 
 */
exports.CtrlComplexArray = utils.defineClass(
	function CtrlComplexArray(controller, article, prototype, options) {
		Base.call(this, controller, article, prototype, options);
		this.$itemProto = this.prototype.propGetProtoItem();
		this.$display = "table";
		this.displayAsCarousel = false;
		// An array has it's own controller scoped to the array property only
		this.arrayDataset = controller.dataset.getChild(this.$bind);
		this.arrayController = new SdataController(this.arrayDataset, controller);
		this._ensurePaginator();
		var savedContext = this.controller.getSavedContext();
		this._search = new SearchArray(savedContext ? savedContext.$search : null);
		this._filters = new FiltersSort.Filters(this); // Predefined x3 filters
		this.filterSort = new FiltersSort.FilterSort(this); // in relation with panel filterSort
		this.isEmpty = false;
		this.builderContent = null;
		this.builderHeader = null;
		this._arrayData = null;
		// END
		this._checkAuthoring();
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.$$title = this.$$content = null;
			if (this.$itemProto) {
				this.$itemProto.destroy();
				this.$itemProto = null;
			}
			if (this.arrayDataset) {
				this.arrayDataset.destroy();
				this.arrayDataset = null;
			}
			// Since the array creates it's own controller, it must also be destroyed here
			if (this.arrayController) {
				this.arrayController.destroy();
				this.arrayController = null;
			}
			if (this.paginator) {
				this.paginator.destroy();
				this.paginator = null;
			}
			if (this._search) {
				this._search.destroy();
				this._search = null;
			}
			if (this.builderHeader) {
				this.builderHeader.destroy();
				this.builderHeader = null;
			}
			if (this._filters) {
				this._filters.destroy();
				this._filters = null;
			}
			if (this.filterSort) {
				this.filterSort.destroy();
				this.filterSort = null;
			}
			if (this.builderContent) {
				this.builderContent.destroy();
				this.builderContent = null;
			}
		},


		_checkAuthoring: function() {
			this.$display = this.controller.isEditMode() || !this.article.$display ? "table" : this.article.$display;
			if (this.$display === "carousel") {
				this.$display = "card";
				this.displayAsCarousel = true;
			}
			// By default
			var defAuthoring = {
				showPagination: true,
				showSortFilter: true,
				showSearch: true,
				rowIndex: this.$display === "card"
			};
			var page = this.controller.uiAdapter;
			var isChartDetail = page && page.isChild("SdataRowDetail");
			var isRowDetail = page && page.isChild("SdataChartDetail");
			if (isChartDetail || page.isVignette() === true) {
				defAuthoring.showPagination = false;
				defAuthoring.showSortFilter = false;
				defAuthoring.showSearch = false;
			}
			// Force with parents $arrayOptions if any
			this.article.$arrayOptions = $.extend(true, defAuthoring, this.article.$arrayOptions || {});
			// Force value depending on context
			if (isChartDetail) {
				// No row detail in chart detail
				this.article.$arrayOptions.showRowDetailLink = false;
			} else if (isRowDetail) {
				// Force in row detail because no authoring
				this.article.$arrayOptions.showRowDetailLink = true;
			} else if (this.article.$arrayOptions.showRowDetailLink == null) {
				// False by default in other pages
				this.article.$arrayOptions.showRowDetailLink = false;
			}
		},

		_newBuilderContent: function() {
			var BuilderClass = _builders[this.$display == "card" ? this.displayAsCarousel ? "carousel" : "card" : this.$display];
			if (!BuilderClass) {
				this.$display = "table";
				this.displayAsCarousel = false;
				BuilderClass = _builders.table;
			}
			return new BuilderClass(this);
		},

		_newBuilderHeader: function() {
			var headerOpts = $.extend(true, null, this.article.$arrayOptions);
			// $filters
			headerOpts.$filtersAuthoring = this._filters && this._filters.$filtersAllowed() ? this.$filtersGetAuthoring() : "none";
			if (!FiltersSort.filterSortAllowed(this)) {
				headerOpts.showSortFilter = false;
			}
			if (this.isArrayField()) {
				// No pagination/search/filters for arrays nested inside pages
				headerOpts.showPagination = false;
				headerOpts.showSearch = false;
				headerOpts.showSortFilter = false;
				headerOpts.$filtersAuthoring = "none";
			}
			if (this._search == null) {
				// No search if offline
				headerOpts.showSearch = false;
			}
			if (this.prototype.isRequest() || this.prototype.isStatistics()) {
				// No search and filters for requests
				headerOpts.showSearch = false;
				headerOpts.showSortFilter = false;
				headerOpts.$filtersAuthoring = "none";
			}
			if (headerOpts.showPagination || headerOpts.showSortFilter || headerOpts.showSearch || headerOpts.$filtersAuthoring === "list") {
				return new BuilderHeader(this, headerOpts);
			}
			return null;
		},

		_iniBeforeBuild: function(refresh) {
			if (!this.$$elmt) {
				Base.prototype.buildHtml.call(this, ["s-m-array", "s-m-" + this.$display]);
			}
			if (!this.$$title) {
				this.$$title = $(uiUtils.createDomElement('div', ["s-m-title"])).appendTo(this.$$elmt).hide();
			}
			// After title
			if (!this.$$content) {
				this.$$content = $(uiUtils.createDomElement('div', ["s-m-value"])).appendTo(this.$$elmt);
				if (this.$display === "card" && this.article.$arrayBgColor) {
					this.$$content.addClass("s-m-bg " + this.article.$arrayBgColor.toLowerCase());
				}
			}
			this.clearContent(refresh);
			this._initArrayData();
			this.isEmpty = this._arrayData.length === 0;
			this.$$elmt.toggleClass("empty", this.isEmpty);
			var displayArray = this.controller.isEditMode() === true || this.isEmpty !== true || this.getAuthoring("$displayIfEmpty") === true;
			// Title
			var title = (this.getTitle() || "").trim();
			if (displayArray && title.length > 0 && this.getAuthoring("$isTitleHidden") !== true) {
				this.$$title.show();
				this.$$title.text(title);
			}
		},
		_initArrayData: function() {
			// Don't destroy rowData - they are cached in the dataSet
			// Destroyed with the dataset
			this._arrayData = [];
			var jj = this.paginator.getNumRowsPage();
			for (var ii = 0; ii < jj; ii++) {
				this._arrayData.push(this.paginator.getRowByIndex(ii))
			}
		},
		clearContent: function(refresh) {
			if (refresh !== true) {
				if (this.builderContent) {
					this.builderContent.destroy();
				}
				if (this.builderHeader) {
					this.builderHeader.destroy();
				}
				this.$$title.empty().hide();
				this.builderContent = this._newBuilderContent(this);
				this.builderHeader = this._newBuilderHeader(this);
			}
			this.$$content.empty();
		},

		buildHtml: function(refresh) {
			this._iniBeforeBuild(refresh);
			if (this.builderHeader) {
				this.builderHeader.buildHtml(this._arrayData, refresh);
			}
			if (this.builderContent) {
				// Build elements that don't depend on parent's size
				this.builderContent.buildHtml(this._arrayData, this.$$content, refresh);
			}
		},

		// Build elements that depend on parent's size
		buildOnResize: function(context) {
			if (!this.builderContent) {
				return;
			}
			this.builderContent.buildOnResize(this._arrayData, this.$$content, context);
			//Notifies cell/Tile parent - Display optimization
			this.notifyVignetteArrayHosted();
		},

		computeLayout: function(context) {
			this.buildOnResize(context);
		},

		/** 
		 * Create a TableRowCtrl
		 */
		createTableRowCtrl: function($$container, recordDataset, index) {
			var $bind = this.$bind + "-" + recordDataset.$bind + "-" + index;
			var rowLinkDomAttrs;
			if (this.controller.root.isLookupController) {
				rowLinkDomAttrs = this.getDataActionAttrs("lookupAccept");
			} else {
				var $linkName = this.getAuthoring("$detailsLink");
				if ($linkName == null) {
					$linkName = this.page.isVignette() ? "$queryfullpage" : "$details";
				}
				var $links = this.$itemProto.data("$links");
				if ($linkName == "$queryfullpage" || ($links && $links[$linkName])) {
					rowLinkDomAttrs = this.getSdataLinkAttrs($linkName);
				} else {
					rowLinkDomAttrs = null;
				}
			}
			var opts = {
				rowIndex: index,
				noEdit: true,
				// This is the link on rows for "real" navigation (e.g. go to $details)
				rowLinkDomAttrs: rowLinkDomAttrs,
				// Links for child arrays to remove/edit rows
				showRowDetail: this.article.showRowDetailLink,
				showRowDelete: this.prototype.hasCapability("delete")
			}
			var rowCtrl = new CtrlArrayTableRow(recordDataset, this.arrayController, {
				$bind: $bind
			}, recordDataset.prototype, opts);
			this.appendStructElmt(rowCtrl);
			rowCtrl.set$$container($$container);
			rowCtrl.page = this.page;
			return rowCtrl;
		},

		/**
		 * Called by paginator on server side pagination
		 * The paginator tells the array the new url which has to be loaded
		 * and the array just asks it's containing page to reload
		 */
		notifyPaginationServer: function($link) {
			this._updateSdataUrl($link)
		},

		/** 
		 * Called by paginator on client side pagination to just redraw the array
		 * Must cleanup DOM and other stuff created before and then trigger a rebuild of the array only
		 */
		notifyPaginationLocal: function() {
			// Destroy row controls
			this.destroyChildren();
			this.buildHtml(true);
		},
		/**
		 * Filter/Search
		 */
		notifyApplyFilter: function($url) {
			this._updateSdataUrl({
				"$url": $url
			})
		},

		_updateSdataUrl: function($link) {
			this.page.fetchNewPageData($link)
		},

		_ensurePaginator: function() {
			this.paginator = new paginators.ArrayPaginatorServer(this);
		},

		_actPagination: function(direction) {
			if (!this.paginator.isEnabled(direction)) {
				return;
			}
			this.paginator.paginate(direction);
		},
		_actActionArray: function(id, param) {
			switch (id) {
				case "panelfiltersort":
					this._openFilterSortPanel();
					break;
				case "filterSelected":
					this._filters.filtersSelect(param);
					break;
				case "search":
					this._search.search(this);
					break;
				case "removeSearch":
					this._search.removeSearch(this);
					break;
			}
		},
		_openFilterSortPanel: function() {
			var panel = this.page.openPanel("filterSortPanel", {
				filter: true,
				sort: true
			})
			panel.ensureParentArray(this.id)
			panel.show();
		},
		isArrayField: function() {
			if (!this.controller) return false;
			return !this.prototype.root.isQueryLikeFacet();
		},
		isArrayChart: function() {
			return false;
		},
		/*Used by filterSort filters and searchArray*/
		getFilterSortOptions: function() {
			var opt = {
				"$url": this.page.pageData.prototype.getValueByPath("$url", true, true),
				"$filters": this._filters._$filterGetInfo(),
				"sortInfo": this.page.getPageSort(),
				"filterInfos": this.page.getPageFilter(),
				"searchInfo": (this._search ? this._search.searchInfos : null)
			};
			return opt;
		},
		excludeChildrenFromAuthoring: function() {
			return true;
		},

		getRowStatusInfo: function() {
			var type = this.getAuthoring("$statusEnabled");
			if (type === "mono" || type === "multi") {
				var status = this.getAuthoring("$status");
				if (status == null || $.isEmptyObject(status)) return null;
				return {
					type: type,
					list: status
				};
			}
			return null;
		},

		/**
		 * Returns the columns to display with all info needed by builder
		 */
		getColumnsInfo: function(onlyVisible) {
			if (!this._columnsInfo) {
				var base = {
					$title: "",
					$titleOrig: "", // title not resolved
					$type: "",
					$bind: "",
					$widthType: "auto",
					$imgHeight: "small",
					$widthVal: 0,
					$capabilities: ""
				};
				this._columnsInfo = [];
				var props = this.prototype.getValueByPath("$item.$properties");
				if (props) {
					var self = this;
					Object.keys(props).forEach(function($bind) {
						var prop = props[$bind];
						if (prop.$isHidden !== true && prop.$isExcluded !== true && ["CREUSR", "CREUSR_REF", "UPDUSR", "UPDUSR_REF"].indexOf($bind) < 0) {
							var p = $.extend(true, {}, base, prop);
							p.$title = self.$itemProto.resolveExpression(prop.$title);
							p.$titleOrig = prop.$title;
							// Bind field - Ex SITE_REF
							p.$bind = $bind;
							// Name of the field that contains the value - !=$bind for non reference fields - Ex For SITE_REF -> SITE
							p.$bindValue = self.$itemProto.getFieldValueName($bind);
							// Type of the field that contains the value - !=$type for non reference fields - Ex For SITE -> "application/x-string"
							p.$bindType = self.$itemProto.getFieldValueType($bind);
							self._columnsInfo.push(p);
						}
					});
				}
			}
			// META
			var dataProps = this.controller.dataset.getValueByPath("$properties");
			if (onlyVisible !== true || dataProps == null) {
				return this._columnsInfo;
			}
			var res = [];
			this._columnsInfo.forEach(function(prop) {
				if (dataProps[prop.$bind] == null || dataProps[prop.$bind].$isHidden !== true) {
					res.push(prop);
				}
			});
			return res;
		},

		_actAddRow: function() {
			var self = this;

			// Let the controller create a new row and eventually sync with the server
			// Then, render the new row afterwards since the server may set some values
			self.arrayController.addRow()
				.then(function(row) {
					if (row) {
						var index = self.arrayController.dataset.getRowIndex(row.json.$uuid);
						self.builderContent.appendRow(index);
					}
				})
				.fail(function(result) {
					modules.get("modal").error(result);
				});

		},

		removeRow: function(rowCtrl) {
			var self = this;
			self.arrayController.removeRow(rowCtrl.getUuid())
				.then(function() {
					self._destroyRemovedRow(rowCtrl);
				})
				.fail(function(result) {
					modules.get("modal").error(result);
				});
		},

		_destroyRemovedRow: function(rowCtrl) {
			var idx = this.children.indexOf(rowCtrl);
			if (idx > -1) {
				this.children.splice(idx, 1);
			}
			rowCtrl.destroy();
		},

		_displayArray: function() {
			return this.controller.isEditMode() === true || this.isEmpty !== true || this.getAuthoring("$displayIfEmpty") === true;
		},
		getScrollViewRect: function() {
			if (this.page.parentVignette) {
				return this.page.parentVignette.getScrollViewRect();
			} else {
				return this.page.mainContentRect;
			}
		},
		/**
		 * none/tabs/list
		 * Stored in $resources array
		 */
		$filtersGetAuthoring: function() {
			var auth = this.getAuthoring("$filters", this.page.isVignette() ? "none" : "list");
			if (auth !== "none" && settings.getDeviceType() === "smartphone") {
				auth = "tabs";
			}
			return auth;
		},
		$filtersGet: function() {
			return (this._filters && this._filters._$filterGetInfo()) || [];
		},
		/**
		 * text can be overridden (chart)
		 */
		setEmptyArrayMsg: function(text) {
			this.$$content.empty();
			if (!this.isArrayField()) {
				var title = this.getTitle();
				if (title) {
					$('<div class="s-m-no-data-title"/>').appendTo(this.$$content).text(title);
				}
				$('<div class="s-m-no-data-label"/>').appendTo(this.$$content).text(text || locale.text("array.empty"));
			} else {
				// No label
			}
		},
		/**
		 * Call cell/tile parent (if any) to inform the that a array is nested in a vignette (query/stats/request only)
		 * Used to improve display - call notifSpecialArrayHosted method directly
		 * typeArray: chart/carousel
		 */
		notifyVignetteArrayHosted: function() {
			if (this.isArrayField() || this.prototype.isLookup() || !this.page.isVignette() || !this.page.parentVignette) {
				return;
			}
			// Query/stats/requests....only
			var parent = this.page.parentVignette.parent;
			// Notifies cell/tile to improve display when a chart/carousel is nested
			// hack to remove the background color since we manage it by js (not css)
			if (parent && parent.notifSpecialArrayHosted) {
				var typeArray = this.displayAsCarousel ? "carousel" : this.$display;
				parent.notifSpecialArrayHosted(typeArray);
			}
		},
		savedCtxCreate: function(type) {
			if (!this.builderContent) return;
			var res = {
				selectedRowUuid: this.$$content.find(".s-m-last-selected").attr("id")
			};
			var builderCtx = this.builderContent.savedCtxCreate(type);
			if (builderCtx) {
				res.$builder = builderCtx
			}
			var searchCtx = this._search ? this._search.savedCtxCreate(type) : null;
			if (searchCtx) {
				// Stores the search context to restore it on back - detail -> list #6734
				res.$search = searchCtx;
			}
			return $.isEmptyObject(res) ? null : res;
		},
		savedCtxRestore: function(ctx) {
			if (!ctx || !this.builderContent) {
				return;
			}
			if (ctx.selectedRowUuid) {
				this.parent.$$content.find('#' + ctx.selectedRowUuid).addClass("s-m-last-selected");
			}
			if (ctx.$builder) {
				this.builderContent.savedCtxRestore(ctx.$builder);
			}
		},
		getAvailableSizeForCards: function() {
			return {
				height: this.$$elmt.height() - (this.builderHeader ? this.builderHeader.$$elmt.height() : 0),
				width: this.$$content.width()
			};
		}
	});