"use strict";

var utils = require('syracuse-tablet/html/js/wc/helpers/utils');
var Base = require('syracuse-tablet/html/js/wc/controls/array/builderBase').BuilderBase;
var formatApi = require('syracuse-tablet/html/js/wc/helpers/formatApi');
var theme = require('syracuse-tablet/html/js/wc/controls/chart/cubeChartsTheme').theme;
var locale = require('syracuse-tablet/html/js/wc/helpers/locale');
var globals = require('syracuse-tablet/html/js/wc/app/globals');

var _merge = Highcharts.merge;
var objectClone = function(o) {
	return $.extend({}, o);
};

Highcharts.theme = theme;
Highcharts.setOptions(Highcharts.theme);

var colors = Highcharts.theme.colors;

var _style = function($style) {
	var map = {
		xy: "line",
		point: "scatter",
		stick: "column",
		radar: "spiderweb"
	};

	return $style && (map[$style] || $style);
};

function _isCubeValid(cube, proto) {
	return !!(cube && cube.$hierarchies && proto.$axes && proto.$axes.length > 0 && //
		proto.$axes[0].$hierarchies && proto.$axes[0].$hierarchies.length > 0);
}
/**
 * cube chart control class
 *
 * article:
 * $isLegendHidden: true/false
 * $isXLabelHidden: true/false
 * $isYLabelHidden: true/false
 * $isXLabelsHidden: true/false
 * $isYLabelsHidden: true/false
 * $style: line, spline, area, areaspline, bar, stick, pie
 */
exports.BuilderChartBase = utils.defineClass(
	function builderChartBase(control) {
		Base.call(this, control);
		// #6974 Add this stuff there for compatibility with desktop code
		// This block assigns some variables so that the implementations
		// in ctrlCubeChartBase which have been migrated from the desktop client
		// do not need to be modified too much!
		this.$prototype = control.prototype.json;
		this.$prototype.$properties = this.$prototype.$item.$properties;
		this._localize = {
			highCharts_showHideLegend: locale.text("highCharts_showHideLegend"),
			highCharts_seriesTitle: locale.text("highCharts_seriesTitle")
		};
		this._initializeMeta();
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.clearChart();
			this._localize = this._meta = this._dataset = this.$prototype = this.currentMetaData = null;
		},
		//#6974 clear existing chart
		clearChart: function() {
			if (this.highchartObject) {
				this.highchartObject.destroy();
			}
			this.highchartObject = null;
		},
		_mergeMetaData: function(metadata) {
			var m = {};
			if (metadata && metadata.$chartOptions) {
				metadata.$isXLabelsHidden = metadata.$chartOptions.isXLabelsHidden || false;
				metadata.$isYLabelsHidden = metadata.$chartOptions.isYLabelsHidden || false;
				metadata.$isXLabelHidden = metadata.$chartOptions.isXLabelHidden || false;
				metadata.$isYLabelHidden = metadata.$chartOptions.isYLabelHidden || false;
				metadata.$isLegendHidden = metadata.$chartOptions.isLegendHidden || false;
				metadata.$isGridLineHidden = metadata.$chartOptions.isGridLineHidden || false;
				metadata.$isTitleHidden = metadata.$chartOptions.isTitleHidden || false;
				metadata.$isLabelsHidden = metadata.$chartOptions.isLabelsHidden || false; // Only for pie
			}
			if (metadata && metadata.$axisLabels) m.$axisLabels = metadata.$axisLabels;
			if (metadata && metadata.$cube) m.$cube = metadata.$cube;
			if (metadata && metadata.$axes) m.$axes = metadata.$axes;
			if (metadata && metadata.$style) m.$style = metadata.$style;
			if (metadata && metadata.$color) m.$color = metadata.$color;
			if (metadata && metadata.$isLegendHidden) m.$isLegendHidden = metadata.$isLegendHidden;
			if (metadata && metadata.$isXLabelHidden) m.$isXLabelHidden = metadata.$isXLabelHidden;
			if (metadata && metadata.$isYLabelHidden) m.$isYLabelHidden = metadata.$isYLabelHidden;
			if (metadata && metadata.$isXLabelsHidden) m.$isXLabelsHidden = metadata.$isXLabelsHidden;
			if (metadata && metadata.$isYLabelsHidden) m.$isYLabelsHidden = metadata.$isYLabelsHidden;
			if (metadata && metadata.$isGridLineHidden) m.$isGridLineHidden = metadata.$isGridLineHidden;
			if (metadata && metadata.$isTitleHidden) m.$isTitleHidden = metadata.$isTitleHidden;
			if (metadata && metadata.$isLabelsHidden) m.$isLabelsHidden = metadata.$isLabelsHidden;
			if (metadata && metadata.$inverted) m.$inverted = metadata.$inverted;
			if (metadata && metadata.$seriesOptions) {
				m.$cube = m.$cube || {};
				m.$cube.$measures = m.$cube.$measures || {};
				Object.keys(metadata.$seriesOptions).forEach(function(key) {
					if (metadata.$seriesOptions[key]) {
						m.$cube.$measures[key] = m.$cube.$measures[key] || {};
						if (metadata.$seriesOptions[key].color) {
							m.$cube.$measures[key].$color = metadata.$seriesOptions[key].color.bgColor;
						}
						m.$cube.$measures[key].$isHidden = metadata.$seriesOptions[key].isHidden;
					}
				});
			}
			this.currentMetaData = _merge(this.currentMetaData || {}, m);

			if (metadata && metadata.$item && metadata.$item.$properties && this.currentMetaData && this.currentMetaData.$cube && this.currentMetaData.$cube.$measures) {
				$.smForEachKey(this.currentMetaData.$cube.$measures, function(key, m) {
					if (metadata.$item.$properties[key] && metadata.$item.$properties[key].$title) {
						m.$title = metadata.$item.$properties[key].$title;
					} else {
						m.$title = key;
					}
				});
			}

			return this.currentMetaData;
		},
		_ensureFormatter: function(measure) {
			measure.formatApi = {
				format: function(val, localFormat) {
					return val;
				}
			};
		},
		_localizedText: function(key) {
			return key;
		},
		_getFieldEvalTitle: function() {
			return [];
		},
		// Each time the dataset of array changes
		notifyArrayDataChanged: function(refresh, arrayData, isEmpty) {
			var self = this;
			var chartDataset = [];
			if (arrayData && arrayData.$resources) {
				arrayData.$resources.forEach(function(dao) {
					chartDataset.push(dao.data);
				});
			}
			self._dataset = chartDataset;
			self._links = null;
			if (arrayData && arrayData.$links) {
				self._links = {};
				Object.keys(arrayData.$links).forEach(function(key) {
					if (!arrayData.$links[key].$isHidden) self._links[key] = arrayData.$links[key];
				});
			}
		},
		_settingsFromValue: function() {
			var self = this,
				$cube = this.currentMetaData.$cube,
				icolor = 0,
				settings;

			var dataset = self._getChartDataSet();
			if ($cube && $cube.$style === "spiderweb") {
				settings = {};
				settings.categories = Object.keys(self._meta.series).map(function(key) {
					return self._meta.series[key].options.name;
				});

				settings.series = {};
				dataset && dataset.reduce(function(res, current) {
					var serie = {
						name: self._getMeasureLabel(current, self._meta.xAxis[0].code),
						color: colors[icolor++],
						data: [],
						pointPlacement: 'on'
					};
					if (serie.name) {
						serie.id = "#s-" + serie.name;
						$.smForEachKey(self._meta.series, function(key, s) {
							if (!s.isHidden) self._pushData(serie, key, key, current);
						});
						res.series[serie.name] = serie;
					}
					return res;
				}, settings);
			} else {
				settings = {
					categories: [],
					series: {}
				};
				dataset && dataset.reduce(function(res, current) {
					var categoryName = self._getMeasureLabel(current, self._meta.xAxis[0].code);
					if (categoryName != null) {
						res.categories.push(categoryName);
						$.smForEachKey(self._meta.series, function(key, s) {
							var serie = res.series[key];
							if (!serie) {
								serie = objectClone(s.options);
								serie.data = [];
								res.series[key] = serie;
							}
							self._pushData(serie, categoryName, key, current);
						});
					}
					return res;
				}, settings);
			}
			return settings;
		},

		_pushData: function(serie, categoryName, key, data) {
			var val = parseFloat(data.$rawV && data.$rawV[key] && data.$rawV[key].v || data[key]) || 0;
			if (this.useLogarithmicAxis) {
				this.maxValue = Math.max(this.maxValue || -Infinity, val);
				this.minValue = Math.min(this.maxValue || Infinity, val);
			}
			serie.data.push({
				name: categoryName,
				y: val,
				"rowId": data.$uuid
			});
		},
		//#6974 add options height/width.onComplete/zoomType
		createChart: function(settings, $$parent, options) {
			var self = this,
				options = _merge(self._getPref(), self._getOptions(self.$prototype, $$parent, options));
			if (self.highchartObject) {
				//#6974 clear existing chart
				self.clearChart();
			}
			if (settings) {
				options.xAxis[0].categories = settings.categories;
				$.smForEachKey(settings.series, function(key, s) {
					var serie = objectClone(s),
						serieMeta = self._meta.series[key];
					if (options.chart.polar && serie && serie.type) {
						delete serie.type;
					}
					if (!(serieMeta && serieMeta.isHidden) && !(serieMeta && serieMeta.options && serieMeta.options.isHidden)) {
						options.series.push(serie);
					}
				});
			} else {
				$.smForEachKey(self._meta.series, function(key, s) {
					var serie = objectClone(s.options);
					if (options.chart.polar && serie && serie.type) {
						delete serie.type;
					}
					serie.data = [0];
					if (!s.isHidden) {
						options.series.push(serie);
					}
				});
			}
			if (!(self.$prototype.$cube && self.$prototype.$cube.$style == "spiderweb")) {
				options.series.reverse();
			}
			if (this.useLogarithmicAxis) {
				if ((this.maxValue || 0) / (this.minValue || 1) > 10) {
					options.yAxis.type = 'logarithmic';
				}
			}
			self.highchartObject = new Highcharts.Chart(options);

			var legend = this.highchartObject.legend;
			self.displayLegend = legend && legend.display;

			var chartSeries = self.highchartObject.series,
				serie, serieMeta;
			for (var j = chartSeries.length - 1; j >= 0; j--) {
				serie = chartSeries[j];
				serieMeta = serie && serie.options.id && self._meta.series[serie.options.id.slice(3)];
				if (serieMeta && serieMeta.measure) {
					serieMeta.measure.$color = serieMeta.options.color = serie.color;
				}
			}
		},
		//#6974 add options height/width.onComplete/zoomType
		_getOptions: function(proto, $$parent, options) {
			options = options || {};
			var self = this;
			var $cube = this.currentMetaData.$cube;
			var defOptions = Highcharts.getOptions();
			var buttons = defOptions.exporting.buttons;
			var enuml;
			var $style = this.currentMetaData.$style || ($cube && $cube.$style) || (proto.$cube && proto.$cube.$style);
			var axe = proto.$axes && proto.$axes[0] || {};
			var titleCode = this._getMeasureCode(axe.$hierarchies[0][0]);
			var hierarchy = $cube.$hierarchies && $cube.$hierarchies[titleCode];
			var axeTitle = hierarchy ? hierarchy.$title : null;
			if (axeTitle === null && proto.$properties && proto.$properties[titleCode]) {
				axeTitle = proto.$properties[titleCode].$title || "";
			};
			var margin = {
				top: (this.currentMetaData.$isTitleHidden && $style !== "bar" ? 0 : null),
				bottom: (this.currentMetaData.$isXLabelsHidden && $style !== "bar" ? 0 : null),
				left: (this.currentMetaData.$isYLabelsHidden && $style !== "bar" ? 2 : null)
			};
			var legend = {};
			/*TODO :if (globals.getSiteLayout().getDeviceType() === "smartphone") {
				legend.layout = 'horizontal';
				legend.align = 'center';
				legend.verticalAlign = 'bottom';
				legend.floating = 'bottom';
				legend.notitle = true;
			};*/
			var options = {
				chart: {
					renderTo: $$parent.get(0),
					reflow: false,
					zoomType: options.zoomType || 'x',
					ignoreHiddenSeries: false,
					width: options.width,
					height: options.height,
					inverted: this.currentMetaData.$inverted,
					marginTop: margin.top,
					marginBottom: (!this.currentMetaData.$inverted ? margin.bottom : margin.left),
					marginLeft: (!this.currentMetaData.$inverted ? margin.left : margin.bottom),
					marginRight: (!this.currentMetaData.$inverted ? margin.left : margin.bottom),
					events: {
						load: options.onComplete,
					}
				},
				lang: {
					showHideLegend: self._localize.highCharts_showHideLegend
				},

				legend: {
					layout: legend.layout ? legend.layout : 'vertical',
					align: legend.align ? legend.align : 'right',
					verticalAlign: legend.verticalAlign ? legend.verticalAlign : 'top',
					y: legend.notitle ? 0 : 60,
					x: legend.notitle ? 0 : -10,
					title: {
						text: (legend.notitle ? '' : ':::: ' + self._localize.highCharts_seriesTitle)
					},
					borderWidth: legend.notitle ? 0 : 1,
					floating: legend.notitle ? false : true,
					draggable: legend.notitle ? false : true,
					zIndex: 20,
					enabled: !(this.currentMetaData.$isLegendHidden === true) && ($style !== "pie")
				},
				title: {
					text: (!this.currentMetaData.$isTitleHidden && $cube && self._localizedText($cube.$title)) || null
				},
				subtitle: {
					text: null
				},
				xAxis: [{
					categories: [],
					title: {
						text: (!this.currentMetaData.$isXLabelHidden && self._localizedText(axeTitle)) || null
					},
					labels: {
						rotation: -45,
						align: 'right',
						enabled: !(this.currentMetaData.$isXLabelsHidden === true)
					},
					gridLineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
					minorGridLineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
					lineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
					tickWidth: (this.currentMetaData.$isXLabelsHidden ? 0 : 1)
				}],

				yAxis: [{
					title: {
						text: null
					},
					labels: {
						align: 'right',
						enabled: !(this.currentMetaData.$isYLabelsHidden === true)
					},
					gridLineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
					minorGridLineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
					lineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
					tickWidth: (this.currentMetaData.$isYLabelsHidden ? 0 : 1)
				}],

				plotOptions: {
					series: {
						pointPadding: 0,
						groupPadding: 0.1,
						cursor: 'pointer',
						events: {},
						point: {
							events: {
								click: null //TODO :self.control ? self.control.getChartClickHandler() : null
							}
						},
						stacking: self._meta.stacking,
						animation: false
					}
				},

				tooltip: {
					formatter: function() {
						var seriesMeta = self._meta.series,
							serie = this.key && seriesMeta[this.key] || seriesMeta[this.series.options.id.slice(3)],
							measure = serie && serie.measure,
							data = this.series.processedYData,
							y = this.y;

						if (measure) {
							self._ensureFormatter(measure);
						}
						var label = this.series.name || measure && measure.$title,
							mformat = measure && measure.formatter;
						label = (label ? label + "<br>" : "") + (this.x || this.key) + ': <b> ' + (mformat ? mformat.format(y) : y) + '</b>';
						if (measure && (measure.$isNormalized) && data.length > 0) {
							var sum = data.reduce(function(a, b) {
								return a + b;
							});
							label += ' (' + (mformat ? mformat.formatValue(y / sum * 100) : y / sum * 100) + '%)';
						}

						return label;
					}
				},

				series: [],
			};
			if ($style === "pie") {
				options.plotOptions.pie = options.plotOptions.pie || {};
				options.plotOptions.pie.dataLabels = options.plotOptions.pie.datalabels || {};
				options.plotOptions.pie.dataLabels.enabled = (this.currentMetaData.$isLabelsHidden ? false : true);
			}
			if (Highcharts.theme.version[0] === 3) {
				// For Highcarts 3.0.0
				options.exporting = {
					type: 'image/png',
					url: 'http://export.highcharts.com/',
					buttons: {
						contextButton: { // docs
							//x: -10, // docs: x is different now
							symbol: 'menu',
							enabled: false,
							_titleKey: 'contextButtonTitle',
							menuItems: [{
								textKey: 'showHideLegend',
								onclick: function() {
									setTimeout(function() {
										self._toggleLegendDisplay();
									}, 100);
								}
							}]
						},
						legendButton: {
							enabled: false,
							textKey: 'showHideLegend',
							symbol: 'menu',
							onclick: function() {
								setTimeout(function() {
									self._toggleLegendDisplay();
								}, 100);
							}
						}
					}
				};
				var menuItems = options.exporting.buttons.contextButton.menuItems || [];
				if (this._printSupported()) {
					menuItems.push({
						text: 'Print chart',
						onclick: function() {
							this.print(self);
						}
					});
				}
				if (this._exportSupported()) {
					menuItems.push({
						separator: true
					});
					menuItems.push({
						textKey: 'downloadPNG',
						onclick: function() {
							this.exportChart();
						}
					});
					menuItems.push({
						textKey: 'downloadJPEG',
						onclick: function() {
							this.exportChart({
								type: 'image/jpeg'
							});
						}
					});
					menuItems.push({
						textKey: 'downloadPDF',
						onclick: function() {
							this.exportChart({
								type: 'application/pdf'
							});
						}
					});
					menuItems.push({
						textKey: 'downloadSVG',
						onclick: function() {
							this.exportChart({
								type: 'image/svg+xml'
							});
						}
					});
				}
			}

			if (options.xAxis[0].title.text !== options.title.text) {
				options.xAxis[0].title.text = (options.xAxis[0].title.text ? options.xAxis[0].title.text : options.title.text);
			}
			options.chart.type = self._meta.defaultStyle;

			return options;
		},

		_initializeMeta: function() {
			this._mergeMetaData(this.$prototype);
			this._mergeMetaData(this.article);

			var proto = this.$prototype;
			var cube = this.currentMetaData;

			this._meta = {
				xAxis: [{}],
				series: {},
				displaysOneMeasure: cube && cube.$displaysOneMeasure,
				hasMeasureSelector: cube && cube.$hasMeasureSelector,
				hasStyleSelector: cube && cube.$hasStyleSelector,
				defaultStyle: _style(cube.$style) || 'column',
				drill: {
					minLevel: 1,
					maxLevel: 0,
					currLevel: 1,
					currAxisHier: 0,
					levelsProperties: [],
					members: [],
					stack: [{
						$axes: proto.$axes,
						$item: proto.$item,
						$slicer: proto.$slicer
					}]
				}
			};
			this.__processMeta(proto, true);
		},

		_exportSupported: function() {
			return true;
		},

		_printSupported: function() {
			return true;
		},

		__processMeta: function(metaData, init) {
			this._processMeasures(metaData, init);
			this._processAxes(metaData, init);
		},

		_processMeasures: function(metaData, init) {
			this._mergeMetaData(metaData);

			var self = this,
				items = this.$prototype.$properties;

			// Get measures definition. If measures are not defined in the second axis members (Cf. specs),
			// we used all the measures defined in the cube
			var measures = this._getRestraintMeasures(),
				icolor = 0;
			if (measures) {
				$.smForEachKey(measures, function(key, m) {
					// Because duplicate properties is possible for cube definition... we keep the last defined
					var code = (m.$property || key);
					var measure = _merge(items[code], m);
					if (metaData && metaData.$item && metaData.$item.$properties) {
						measure = _merge(measure, metaData.$item.$properties[code]);
					}
					if (!measure.$title || measure.$title === "") {
						measure.$title = key;
					}
					// measures[key] = measure;
					var serie = self._meta.series[code];

					if (init) {
						self._ensureFormatter(measure);

						serie = self._meta.series[code] = {
							options: {
								id: '#s-' + code,
								// legendIndex: "",
								name: self._localizedText(measure.$title) || String.fromCharCode(160),
								// visible: measure.$title !== "" && !!(!self._meta.displaysOneMeasure || measure.$isDefault)
							},
							measure: measure
						};
					}
					if (serie) {
						serie.isHidden = measure.$title === "";
						serie.options.type = _style(measure.$style);
						serie.options.color = measure.$color || colors[icolor++];
						serie.options.name = self._localizedText(measure.$title) || String.fromCharCode(160);
						serie.options.visible = measure.$title !== "" && !!(!self._meta.displaysOneMeasure || measure.$isDefault);
						serie.options.isHidden = measure.$isHidden;
					}

					if (measure.$isStacked || measure.$stackingGroup) {
						serie.options.stack = measure.$stackingGroup || 0; // a stack ID
						self._meta.stacking = measure.$isNormalized ? 'percent' : self._meta.stacking || 'normal';
					}
				});
			}
		},

		_getRestraintMeasures: function() {
			var proto = this.currentMetaData,
				$cube = proto.$cube,
				measures = $cube && $cube.$measures,
				restraintMeasures = measures;
			if (measures) {
				if (proto.$axes && proto.$axes.length > 1 && proto.$axes[1].$members && proto.$axes[1].$members[0][0].length > 0) {
					restraintMeasures = {};
					$.smForEach(proto.$axes[1].$members[0][0], function(measureCode) {
						restraintMeasures[measureCode] = measures[measureCode];
					});
				}
			}
			return restraintMeasures;
		},

		_processAxes: function(proto, init) {
			var cube = this.$prototype.$cube;
			if (!_isCubeValid(cube, proto)) return false;

			var self = this,
				currAxisHier = 0,
				axis0 = proto.$axes && proto.$axes[0];

			// TODO: review this
			// Get axis analysis
			var mainHLevelsTab = null;
			if (axis0) {
				$.smForEachKey(axis0.$hierarchies, function(idx, hierarchy) {
					if (!mainHLevelsTab && hierarchy.length > 1 && hierarchy[1] == 1) {
						mainHLevelsTab = cube.$hierarchies[hierarchy[0]].$properties;
						if (mainHLevelsTab) {
							self._meta.xAxis[0].code = mainHLevelsTab[hierarchy.length > 2 ? hierarchy[2] : 0];
							currAxisHier = idx;
						}
					}
				});
				if (!mainHLevelsTab && axis0.$hierarchies[0].length > 0) {
					mainHLevelsTab = cube.$hierarchies[axis0.$hierarchies[0][0]].$properties;
					if (mainHLevelsTab && mainHLevelsTab.length > 0) self._meta.xAxis[0].code = mainHLevelsTab[0];
				}
				// Get drill definition
				var properties;
				$.smForEach(axis0.$hierarchies, function(hierarchie) {
					properties = cube.$hierarchies[hierarchie[0]].$properties;
					$.smForEach(properties, function(property) {
						this.levelsProperties[this.maxLevel++] = property;
					}, self._meta.drill);
				});
				if (axis0.$members) {
					$.smForEach(axis0.$members, function(tuple) {
						$.smForEach(tuple, function(value) {
							if (value.length > 0) {
								this.members[(this.currLevel++) - 1] = value[0];
							}
						}, this);
					}, self._meta.drill);
				}
			}
			self._meta.drill.code = proto.$codeStat || "UNKNOWN";
			self._meta.drill.axis0FieldCode = self._meta.xAxis[0].code || "";
			self._meta.drill.maxLevel = Math.max(self._meta.drill.maxLevel, self._meta.drill.minLevel);
		},

		_getPref: function() {
			return Highcharts.getOptions();
		},
		//get the measure code depending on level. May be not the best way to do that (see desktop release).
		_getMeasureCode: function(code) {
			var level = this.control.level;
			var measureCode = ((level > 1) && this.$prototype.$axes[0].$hierarchies.length >= level) ? this.$prototype.$axes[0].$hierarchies[level - 1][0] : null;
			//Authoring is yet stored by level but to keep existing authoring, we keep the key but always 1
			measureCode = (this.currentMetaData.$axisLabels) ? this.currentMetaData.$axisLabels[1] : measureCode;
			return measureCode || code;
		},
		_getMeasureLabel: function(measure, code) {
			var self = this;
			var label = this._localizedText(measure.$title);
			if (label) return label;
			code = this._getMeasureCode(code);
			if (!measure[code]) return "";
			var item = self.$prototype.$properties[code];
			if (!item) return null;
			switch (item.$type) {
				case "application/x-choice":
					label = measure[code];
					item.$value.$enum.some(function(element, i, array) {
						if (element.$value === label) {
							label = self._localizedText(element.$title);
							return true;
						}
						return false;
					});
					break;
				case "application/x-date":
					item.formatter = formatApi.getFormatter(item.$type, locale.getDateFormat(item.$type));
					label = item.formatter.formatValue(measure[code]);
					break;
				case "application/x-integer":
				case "application/x-decimal":
					item.formatter = formatApi.getFormatter(item.$type, locale.getNumberFormat(item.$type));
					label = item.formatter.formatValue(measure[code]);
					break;
				default:
					label = "" + measure[code];
					break;
			}
			return label;
		},
		_toggleLegendDisplay: function() {
			var legend = this.highchartObject.legend;
			legend && this._displayLegend(!legend.display);
		},
		_displayLegend: function(display) {
			var legend = this.highchartObject.legend;
			if (!legend) return;
			if (display) {
				legend.group.show();
				legend.box.show();
			} else {
				legend.group.hide();
				legend.box.hide();
			}
			this.displayLegend = legend.display = display;
		}
	});