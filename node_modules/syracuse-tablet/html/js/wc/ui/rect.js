"use strict";

var utils = require('syracuse-tablet/html/js/wc/helpers/utils');
var modules = require('syracuse-tablet/html/js/wc/common/modules');

var _Klass = utils.defineClass(function rect(top, left, height, width) {
	this.top = top;
	this.left = left;
	this.setHeight(height);
	this.setWidth(width);
}, null, {
	// Accept null for x or y 
	isPointInside: function(x, y) {
		return (x == null || (x >= this.left && x <= this.right)) && (y == null || (y >= this.top && y <= this.bottom));
	},
	/**
	 * rectOffset!=null means that the main has scrolled and we need to to correct the coordinates because pageX/pageY are relative document
	 */
	isEvtInside: function(evt, rectOffset) {
		if (evt.type.smStartsWith("touch")) {
			// Touch events are managed completely differently from mouse events - depends on the number of fingers in contact...
			if (evt.changedTouches && evt.changedTouches.length === 1) {
				evt = evt.changedTouches[0];
			} else if (evt.touches && evt.touches.length === 1) {
				evt = evt.touches[0];
			} else {
				// No control -> OK
				return true;
			}
		}
		var y = rectOffset != null && rectOffset.top != null ? evt.pageY - rectOffset.top : evt.pageY;
		var x = rectOffset != null && rectOffset.left != null ? evt.pageX - rectOffset.left : evt.pageX;
		return this.isPointInside(x, y);
	},
	intersectsWith: function(rect) {
		return this.left <= rect.right && rect.left < this.right && this.top < rect.bottom && rect.top < this.bottom;
	},
	contains: function(rect) {
		if (rect == null) return true;
		return this.isPointInside(rect.left, rect.top) && this.isPointInside(rect.right, rect.bottom);
	},
	equals: function(rect, justSize) {
		if (rect.width === this.width && rect.height === this.height) {
			return justSize === true || (rect.top === this.top && rect.left === this.left);
		}
		return false;
	},
	/**
	 * relative	true/false
	 */
	intersectRect: function(rect, relative) {
		if (!this.intersectsWith(rect)) return null;
		var top = Math.max(this.top, rect.top);
		var left = Math.max(this.left, rect.left);
		var right = Math.min(this.right, rect.right);
		var bottom = Math.min(this.bottom, rect.bottom);
		return new _Klass(relative ? 0 : top, relative ? 0 : left, bottom - top, right - left);
	},
	// Compare this.height with rect.height
	// Returns 0 if equals +1 if greater -1 if less
	checkHeight: function(rect) {
		if (!rect) {
			return false;
		}
		return this.height === rect.height ? 0 : this.height > rect.height ? +1 : -1;
	},
	checkWidth: function(what, rect) {
		if (!rect) {
			return false;
		}
		return this.width === rect.width ? 0 : this.width > rect.width ? +1 : -1;

	},
	setHeight: function(h) {
		this.height = Math.max(h, 0);
		this.bottom = this.top + this.height;
	},
	setWidth: function(w) {
		this.width = Math.max(w, 0);
		this.right = this.left + this.width;
	},
	moveLeft: function(l) {
		this.left = this.left + l;
		this.right = this.width + this.left;
	},
	moveTop: function(l) {
		this.top = this.top + l;
		this.bottom = this.height + this.top;
	},
	toString: function() {
		return "t:" + this.top + " l:" + this.left + " r:" + this.right + " b:" + this.bottom + " h:" + this.height + " w:" + this.width;
	},
	toRelative: function(offet) {
		if (offet == null) offet = {};
		if (offet.top == null) offet.top = 0;
		if (offet.left == null) offet.left = 0;
		return new _Klass(offet.top, offet.left, this.height, this.width);
	},
	/**
	 * timeoutOrColor	optional
	 * 						timeout in ms to delete the div
	 * 						name/code of border color
	 */
	showInDocument: function(options) {
		var scale = modules.get("siteLayout").getTransformScale();
		options = options || {};
		// To pass has param if needed
		var pos = "fixed";
		var $$parent = $(document.body);
		var $$elmt = $('<div class = "s-m-rect">').appendTo($$parent).css({
			position: pos,
			top: this.top + "px",
			left: this.left + "px",
			height: (this.height * scale) + "px",
			width: (this.width * scale) + "px",
			backgroundColor: options.color,
			zIndex: options.zIndex != null ? options.zIndex : undefined
		});
		if (options.timeout != null) {
			setTimeout(function() {
				$$elmt.remove();
			}, options.timeout);
		}
		return $$elmt;
	},
	clone: function() {
		return new _Klass(this.top, this.left, this.height, this.width);
	},
	applyTransformScale: function(scale, clone) {
		if (scale == null || scale <= 0 || typeof scale != "number") return;
		var res = clone === true ? this.clone() : this;
		res.width = res.width * scale;
		res.height = res.height * scale;
		// TODO - left / right - ok if they are equal to 0
		return res;
	}
});
var _meths = {
	outer: ["outerWidth", "outerHeight"],
	inner: ["innerWidth", "innerHeight"],
	computed: ["width", "height"],
	fixed: "position",
	relative: "offset"
};
/**
 * Returns the rectangle of $$elmt
 * 	type:		outer / inner / computed
 * 	position	!!! fixed (RELATIVE TO PARENT), relative (RELATIVE  TO DOCUMENT) - Mistake
 */
exports.elmtRect = function($$elmt, typeRect, position) {
	var scale = modules.get("siteLayout").getTransformScale();
	position = position || "relative";
	typeRect = typeRect || "outer";
	var o = $$elmt[_meths[position]]();
	var m = _meths[typeRect];
	var height = $$elmt[m[1]]();
	var width = $$elmt[m[0]]();
	var rect = new _Klass(o.top, o.left, height / scale, width / scale);
	if (typeRect === "computed" && position === "relative") {
		// We assume that padding L/R and T/B are identical
		var outW = $$elmt.outerWidth();
		var outH = $$elmt.outerHeight();
		if (outW > width) {
			rect.moveLeft((outW - width) * scale / 2);
		}
		if (outH > height) {
			rect.moveTop((outH - height) * scale / 2);
		}
	}
	return rect;
};
exports.newRect = function(top, left, height, width) {
	return new _Klass(top, left, height, width);
};