"use strict";

var _APP_RELEASE_REP = "/dist/";
var _APP_DVLP_REP = "/html/";
var _APP_RELEASE_INDEX = "index.html";
var _APP_DVLP_INDEX = "index_debug.html";
var _OPEN_LINK_IDEX = "open_link.html";

var _stringToHtml = function(str) {
	return (str || "").replace(/\n/g, "<br>");
};
var _strStartsWith = function(str, s) {
	if (!str || str.length == 0 || s == null || s.length === 0 || str.length < s.length) {
		return false;
	}
	return s.length === 1 ? str.charAt(0) === s.toString() : str.indexOf(s.toString()) === 0;
};
var _strEndsWith = function(str, s) {
	if (!str || str.length == 0 || s == null || str.length < s.length) {
		return false;
	}
	s = s.toString();
	return s.length === 1 ? str.charAt(str.length - 1) === s : str.lastIndexOf(s) === str.length - s.length;
};
var _strCapitalize = function(str) {
	if (!str || str.length === 0) {
		return str;
	}
	return str.charAt(0).toUpperCase() + str.slice(1);
};
/*
 * This module must only contain low level helper functions that do not have any dependencies!
 */
if (!window.exports) {
	// Trick - This file can be used in html pages outsite required loader - See open_link
	window.exports = window;
}
/** Parse an url 
 * !!! no @ character should be present in query params (keep them encoded)
 * There are @ query params in date where clauses
 **/
var _purlOptions = {
	strictMode: false,
	key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "querystring", "anchor"],
	q: {
		name: "query",
		parser: /(?:^|&)([^&=]*)=?([^&]*)/g
	},
	parser: {
		strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
		loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
	}
};
/*
 * {
  "anchor": "", "file": "", "password": "", "user": "", "userInfo": "",
  "querystring": "representation=AQTCRUDM.$edit",
  "directory": "/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies",
  "path": "/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies",
  "relative": "/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies?representation=AQTCRUDM.$edit",
  "port": "8124",
  "host": "pc101329.sagefr.adinternal.com",
  "authority": "pc101329.sagefr.adinternal.com:8124",
  "protocol": "http",
  "source": "http://pc101329.sagefr.adinternal.com:8124/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies?representation=AQTCRUDM.$edit",
  "query": {
    "representation": "AQTCRUDM.$edit"
  }
 */
var _parseURL = function(str) {

	// Regex based parser fails on @ in the url also it's valid according specs
	// this is why we encode it (only query params) as %40
	// The query params will be decoded at the end so there should be no harm cause by this
	// https://github.com/Sage-ERP-X3/Syracuse/issues/8660
	str = str && str.replace(/\?.*(\@)/g, function(m) {
		return m.replace(/\@/g, "%40");
	});

	var o = _purlOptions;
	var m = o.parser[o.strictMode ? "strict" : "loose"].exec(str);
	var uri = {};
	var i = 14;

	while (i--) uri[o.key[i]] = m[i] || "";

	uri[o.q.name] = {};
	uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) {
		if ($1) uri[o.q.name][$1] = decodeURIComponent($2);
	});
	return uri;
};
/**
 * Return a string url from u object which has been parsed with _parseURL
 */
var _urlToString = function(u) {
	if (!u) return "";
	var url = "";
	if (u.protocol && u.host) {
		url += u.protocol + "://" + u.host;
		if (u.port.length != 0) url += ":" + u.port;
	}
	url += u.directory ? u.directory.trim() : "";
	if (u.file) {
		if (!_strEndsWith(u.directory, "/")) {
			url += "/";
		}
		url += u.file;
	}
	var query = "";
	for (var p in u.query) {
		if (query.length != 0) query += "&";
		query += p + "=" + encodeURIComponent(u.query[p]);
	}
	if (query.length != 0) url += "?" + query;
	if (u.anchor) url += "#" + u.anchor;
	return url;
};
/**
 * Return the current url
 */
var _curUrl;
var _getCurrentUrl = function() {
	if (_curUrl) return _curUrl;
	_curUrl = _parseURL(window.location.href);
	return _curUrl;
};
/**
 * Returns the url that will contain the current page context to restore (ctx) (links, live tiles...)
 */
var _getOpenLinkUrl = function(ctxUuid) {
	var url = $.extend({}, exports.getCurrentUrl());
	// We open open_link.html that will remove the context from url and store it in sessionStorage (see _setUrlContextId)
	url.file = _OPEN_LINK_IDEX;
	if (ctxUuid) {
		if (!url.query) {
			url.query = {};
		}
		url.query.context = ctxUuid;
	}
	return exports.urlToString(url);
};
/**
 * Returns the context to restore if any (used by external links or live tiles to open a page)
 * Context has been stored by open_link.html page and removed from url (see getOpenLinkUrl, sessStorage)
 * return {endpoint:, applicationName:, history[state]}
 */
var _getUrlContextId = function() {
	// Read context in session storage if any (see open_link.html)
	var contextId;
	var sessStorage = typeof(window.sessionStorage) !== "undefined" ? window.sessionStorage : null;
	if (sessStorage) {
		contextId = sessStorage.getItem("__urlContext__");
		sessStorage.removeItem("__urlContext__");
	}
	if (!contextId) {
		// If no context check url context
		var url = exports.getCurrentUrl();
		contextId = url.quey ? url.query.context : null;
	}
	return contextId;
};
/**
 * Read url context and stores it in session storage if any
 * Remove the context param from url
 * Call idenx.htlk page
 */
var _setUrlContextId = function() {
	var sessStorage = typeof(window.sessionStorage) !== "undefined" ? window.sessionStorage : null;
	if (sessStorage) {
		sessStorage.removeItem("__urlContext__");
	}
	var url = _parseURL(window.location.href);
	try {
		var contextId = url.query && url.query.context;
		console.log("_setUrlContextId", contextId);
		if (sessStorage && contextId && contextId.trim().length > 0) {
			// Stores the context
			sessStorage.setItem("__urlContext__", contextId);
			// Remove it from url
			delete url.query.context;
		}
	} catch (e) {}
	// location.replace to prevent back button
	var file = url.file;
	url.file = url.path.indexOf(_APP_RELEASE_REP) > 0 ? _APP_RELEASE_INDEX : _APP_DVLP_INDEX;
	url.path = url.path.replace(file, url.file);
	window.location.replace(_urlToString(url));
};


var _isInstanceOf = function(o, name) {
	if (o == null) return false;
	var ctor = o.constructor;
	if (ctor && ctor.$smClasses) {
		return ctor.$smClasses.indexOf(name) > -1;
	}
	return false;
};

var _addInheritanceInfo = function(ctor, parent) {
	var classes = [];
	/**
	 * ctor.name comes from the constructor
	 *	var _Page = utils.defineClass(
	 *	function RegularPage($parent,
	 *	In that case name = "RegularPage"
	 */

	/*
	 * https://github.com/Sage-ERP-X3/Syracuse/issues/8758
	 * ctor.name does not exist on IE 11
	 * This is why we try ctor.toString() and parse the function for it's name
	 */
	var name = ctor.name;
	if (!name) {
		var ctorName = ctor && ctor.toString();
		ctorName = ctorName.match(/^function\s*([^\s(]+)/);
		name = ctorName && (ctorName.length > 1 ? ctorName[1] : null);
	}
	if (name) {
		classes.push(name);
	}
	/**
	 * FDB #7822 - we need to propagate $smClasses even if ctor.name == ""
	 * Otherwise we have to define a name for each constructor even if we just want to check the parent class name
	 * Eg: "SidePanel" - We don't want to add a constructor name for all child classes to test instanceOf ("SidePanel")
	 */
	if (parent && parent.$smClasses) {
		var i;
		for (i = 0; i < parent.$smClasses.length; i++) {
			classes.push(parent.$smClasses[i]);
		}
	}
	ctor.$smClasses = classes;
};

var _isError = function(o) {
	if (o && o instanceof Error) {
		return true;
	}
	// Old one
	return o && Error.prototype.toString === o.toString;
};

var _isException = function(o) {
	return o && o.constructor && o.constructor.name === "DOMException";
};

/** 
 * Clean error stack from current base url and limit the size due to the use of deferred
 * html: true -> Display in Html
 **/
var _stackRegexp;
var _cleanStack = function(stack, max, html) {
	if (Array.isArray(stack)) return stack;
	if (!_stackRegexp) {
		var host = window.location.protocol + "//" + window.location.host;
		var path = window.location.pathname.split('/').splice(0, 2).join('/');
		var withPath = host + path;
		var requirePath = host + "/requireJS" + path;
		_stackRegexp = {
			r1: new RegExp(withPath, "g"),
			r2: new RegExp(requirePath, "g")
		};
	}

	max = max == null ? 5 : max;
	if (stack) {
		var array = (stack.split && stack.split("\n")) || stack;;
		var res;
		if (array.length > 0) {
			array.forEach(function(l) {
				var pos1 = l.lastIndexOf(".js");
				if (pos1 > 0) {
					var pos2 = l.lastIndexOf("/", pos1);
					if (pos1 > 0) {
						if (!res) res = [];
						res.push(l.substring(pos2));
					}
				} else {
					// Unknown line format (to include details at end of stack, just add line here)
					if (!res) res = [];
					res.push(l);
				}
			});
		}
		if (!res && _stackRegexp) {
			stack = _stackRegexp ? stack.replace(_stackRegexp.r1, "").replace(_stackRegexp.r2, "") : stack;
		} else {
			stack = res.join('\n');
		}
	} else {
		stack = "";
	}
	stack = stack.split("\n");
	if (max) { // Allow max level of source stack files, stack elements not pointing to a file are always added since the may include important information
		res = [];
		stack.forEach(function(l) {
			if (l.indexOf(".js") > -1) {
				if (max > 0) {
					res.push(l);
					max--;
				}
			} else {
				res.push(l);
			}
		});
		stack = res.join(html ? "<br>&nbsp&nbsp&nbsp&nbsp&nbsp" : "\n");
	}
	return stack;
};

/*
 * Takes what ever is passed as parameter and creates an object containing and $diagnoses array
 * title: Always a string
 * e: String or Error or any kind of object*
 *
 * object*:
 * {
 *   message: "text",
 *   detail: Error or Object
 * }
 *
 */
var _convertToDiagnoses = function(e, html) {
	if (e == null) {
		e = "No error message";
	}
	if (typeof e === "string") {
		// String message
		return {
			$diagnoses: [{
				$severity: "error",
				$message: html ? _stringToHtml(e) : e
			}]
		};
	} else if (_isError(e) || _isException(e)) {
		// Exception to diagnoses
		return {
			$diagnoses: [{
				$message: html ? _stringToHtml(e.message) : e.message,
				$stackTrace: _cleanStack(e.stack, null, html),
				$severity: "error"
			}]
		};
	} else {
		// If parameter is already an object with diagnoses, do not do anything special
		if (e.$diagnoses && Array.isArray(e.$diagnoses)) {
			return e;
		}
		// Arbitrary object
		var res = {
			$diagnoses: []
		};
		var diag = {
			$severity: "error",
			$message: e.message || e.$message || e.$title || "No error message"

		};
		if (html) {
			diag.$message = _stringToHtml(diag.$message);
		}
		res.$diagnoses.push(diag);
		var detail = e.detail;
		if (detail) {
			if (_isError(detail)) {
				if (detail.message) {
					diag.$stackTrace = (diag.$stackTrace ? diag.$stackTrace + "\n" : "") + detail.message;
				}
				if (detail.stack) {
					diag.$stackTrace = (diag.$stackTrace ? diag.$stackTrace + "\n" : "") + _cleanStack(detail.stack, null, html);
				}
			} else {
				diag.$stackTrace = (diag.$stackTrace ? diag.$stackTrace + "\n" : "") + JSON.stringify(detail);
			}
		}
		var xe = e;
		while (xe.$exception != null) {
			_$exceptionAdd(res, xe.$exception, html);
			xe = xe.$exception;
		}
		return res;
	}
};
// $exception returned by storage in addition to $message
var _$exceptionAdd = function(res, $exception, html) {
	if (!$exception) return;
	var msg = typeof $exception === "string" ? $exception : $exception.message || $exception.$message;
	var stk = $exception.stack;
	if (msg || stk) {
		res.$diagnoses.push({
			$message: html ? _stringToHtml(msg) : msg,
			$stackTrace: stk ? _cleanStack(stk, null, html) : "",
			$severity: "error"
		});
	}
};
/**
 * return the value of a given path
 * 	path:	String with/without '.' as separator or array of strings
 *  cache: 	null	-> No cache
 * 		    !null	-> object that stores the cache
 */
var _getPropByPath = function(object, path, cache) {
	if (path == null || object == null) return null;
	var pathStr, pathArray;
	if (Array.isArray(path)) {
		if (path.length === 0) return null;
		pathArray = path;
		pathStr = pathArray.join(".");
	} else {
		pathArray = path.split('.');
		pathStr = path;
	}
	if (cache && cache[pathStr] != null) {
		return cache[pathStr];
	}
	// Check parent if needed
	var data = object[pathArray[0]];
	for (var i = 1; i < pathArray.length; i++) {
		if (data == null) return null;
		if (!$.isPlainObject(data) == null) {
			throw new Error('_getPropByPath - Unexpected non-plainobject');
		}
		data = data[pathArray[i]];
	}
	if (cache) {
		cache[pathStr] = data;
	}
	return data;
};


/**
 * simple function bind
 * arguments that follow context are passed to fn call back after the regular parameters
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
	var args = arguments.length > 2 ? Array.prototype.splice.call(arguments, 2) : null;
	return function boundFn() {
		var callBackArgs = arguments;
		if (args && args.length > 0) {
			args.forEach(function(a) {
				Array.prototype.push.call(callBackArgs, a);
			});
		}
		return fn.apply(context ? context : this, callBackArgs);
	};
}
//http://jsperf.com/multi-array-concat/7
// concatArrays(array1, array2, array3...) - accept undefined arguments
exports.concatArrays = function() {
	var args = [];
	for (var i = 0; i < arguments.length; i++) {
		if (arguments[i] != null) args.push(arguments[i]);
	}
	return [].concat.apply([], args);
};
exports.getPropByPath = _getPropByPath;
exports.addInheritanceInfo = _addInheritanceInfo;

/**
 * return true if o is an instance of class 'name'
 * Like this process could slow down the application it's better to register only classes for which we want to check instance
 */
exports.isInstanceOf = _isInstanceOf;

exports.isError = _isError;

exports.cleanStack = _cleanStack;

exports.convertToDiagnoses = _convertToDiagnoses;

exports.bindFn = bindFn;

exports.getCurrentUrl = _getCurrentUrl;
exports.getOpenLinkUrl = _getOpenLinkUrl;

/**
 * return http://host:port
 * acespted url: 	null 	takes current url
 * 					string
 * 					parsed Url
 */
exports.getUrlHost = function(url) {
	if (!url) {
		url = _getCurrentUrl();
	} else if (!$.isPlainObject(url)) {
		url = exports.parseURL(url);
	}
	var res = url.protocol + "://" + url.host;
	if (url.port != null) {
		res += ":" + url.port
	}
	return res;
}
exports.getCurrentHostUrl = function() {
	return exports.getUrlHost(null);
}
exports.getUrlContextId = _getUrlContextId;
exports.setUrlContextId = _setUrlContextId;
exports.parseURL = _parseURL;
exports.urlToString = _urlToString;
exports.strStartsWith = _strStartsWith;
exports.strEndsWith = _strEndsWith;
exports.strCapitalize = _strCapitalize;
exports.isReleaseVersion = function() {
	return document.location.href.indexOf("/index_debug.html") < 0 && document.location.href.indexOf("/index_release.html") < 0;
};
exports.isDvlpVersion = function() {
	return window.location.href.indexOf("/index_debug.html") > -1 || window.location.href.indexOf("/index_joined.html") > -1;
};
exports.isTestEnvironment = function() {
	return window.location.href.indexOf("/syracuse-tablet/test/index.html") > -1;
};
exports.getResourcesBasePath = function() {
	if (exports.isReleaseVersion()) {
		return "/syracuse-tablet" + _APP_RELEASE_REP;
	} else {
		return "/syracuse-tablet" + _APP_DVLP_REP;
	}
};