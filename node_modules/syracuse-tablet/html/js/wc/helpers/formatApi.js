"use strict";

var utils = require('syracuse-tablet/html/js/wc/helpers/utils');
var locale = require('syracuse-tablet/html/js/wc/helpers/locale');
var date = require('syracuse-tablet/html/js/wc/helpers/types/date');
var datetime = require('syracuse-tablet/html/js/wc/helpers/types/datetime');
var time = require('syracuse-tablet/html/js/wc/helpers/types/time');
var numberFormat = require('syracuse-tablet/html/js/wc/helpers/types/numberFormat');

var _cache = {};
var _cacheLocaleHash;

exports.getFormatter = function($type, $format) {
	if ($format == "$url") {
		// #6292 Some numeric field have $format = $url - AQMFIELDM
		// Formatter is skipped - TODO we should add a isValid method to format object
		return null;
	}
	var ctor = _formatters[$type];
	if (!ctor) {
		return null;
	}
	var curLocaleHash = locale.getCurrentLocaleHash();
	if (curLocaleHash !== _cacheLocaleHash) {
		_cacheLocaleHash = curLocaleHash;
		_cache = {};
	}
	var cache = _cache[$type];
	if (!cache) cache = _cache[$type] = {};
	var key = $format || "noformat";
	var fmt = cache[key];
	if (fmt) return fmt;
	fmt = new ctor($type, $format);
	cache[key] = fmt;
	return fmt;
};

var Formatter = utils.defineClass(function($type, $format) {
	this.$format = $format;
	this.$type = $type;
}, null, {

	_isEmpty: function(value) {
		if (value == null)
			return true;
		value = "" + value;
		value = value.trim();
		if (value === "")
			return true;
		return false;
	},

	/*
	 * Format a value for displaying
	 * This will be used on read only fields to format the internal value to a human readable localized pattern.
	 * Also, this will be used to format values in editable fields BEFORE putting the focus into the field for editing
	 * editMode: true if edit mode
	 */
	formatValue: function(value, editMode) {
		return value;
	},

	/*
	 * Format a value for editing it
	 *
	 * This will be used to format values in editable fields AFTER putting the focus into the field for editing.
	 *
	 * Example, in case of dates:
	 * A field displays "April, 1. 2014"
	 * Once the focus is put into the field, it will render the value as "01.04.2014" since it's easier to edit
	 */
	formatValueEdit: function(value) {
		return this.formatValue(value, true);
	},

	/* 
	 * Parse any kind of input string to the internal representation
	 */
	parseValue: function(value, errors) {
		errors.push("No parser for this type, return this dummy error to not override value by null");
	},

	getFormat: function() {
		return this.format;
	}
});

var DateFormatter = utils.defineClass(function($type, $format) {
	Formatter.call(this, $type, $format);
	this.format = locale.getDateFormat();
	this.twoDigitYearSwitch = 40;
}, Formatter, {
	_isEmpty: function(value) {
		if (value == null)
			return true;
		value = "" + value;
		value = value.trim();
		if (value === "")
			return true;

		if (value === "0000-00-00")
			return true;

		return false;
	},

	_checkShortYear: function(year) {
		if (year.year) {
			// Date object
			var y = year.year;
			if (y < 100) {
				year.add({
					years: y < this.twoDigitYearSwitch ? 2000 : 1900
				});
			}
		} else {
			// Number
			year = year > 99 ? year : (year < this.twoDigitYearSwitch ? 2000 + year : 1900 + year);
		}
		return year;
	},

	/**
	 * value expected to be a date string like "2014-08-19"
	 */
	formatValue: function(value, editMode) {
		if (this._isEmpty(value)) {
			return "";
		}
		var p = value.split(/[^\d]+/);
		var format;
		if (p.length >= 3) {
			p[0] = this._checkShortYear(+p[0]);
			var d = date.make(+p[0], +p[1], +p[2]);
			format = d.toString(this.format);
		} else {
			format = value;
		}
		return format;
	},
	parseValue: function(value, errors) {
		var fmt;
		if (this._isEmpty(value)) {
			return "";
		}
		try {
			fmt = date.parse(value, this.format);
			fmt = this._checkShortYear(fmt);
		} catch (e) {
			errors.push(locale.text("field.invalidInput", [this.format]));
			return value;
		}
		return fmt.toString("yyyy-MM-dd");
	},
	validateValue: function(value, errors) {
		var fmt;
		if (this._isEmpty(value)) {
			return "";
		}
		try {
			fmt = date.parse(value, this.format);
			date.validate(fmt, {}, errors)
		} catch (e) {
			errors.push(locale.text("field.invalidInput", [this.format]));
		};
		return (errors.length === 0)
	}
});

var DateTimeFormatter = utils.defineClass(function($type, $format) {
	DateFormatter.call(this, $type, $format);
	this.format = locale.getDateTimeFormat();
}, DateFormatter, {
	_isEmpty: function(value) {
		if (value == null)
			return true;
		value = "" + value;
		value = value.trim();
		if (value === "")
			return true;

		if (value === "0000-00-00T00:00:00Z")
			return true;

		return false;
	},
	/**
	 * value expected to be a date string like "2010-10-13T13:25:03.424Z"
	 * Accept "2010-10-13-14-25-03"
	 */
	formatValue: function(value, editMode) {
		if (this._isEmpty(value)) {
			// We return "" in display mode for compatibility with other fields
			// In edit mode we choose th current date time - L.Seyssel
			return editMode === true ? datetime.now().toString(this.format) : "";
		}
		var p = value.split(/[^\d]+/);
		var format;
		if (p.length >= 6) {
			p[0] = this._checkShortYear(+p[0]);
			var d = datetime.make(+p[0], +p[1], +p[2], +p[3], +p[4], +p[5]);
			format = d.toString(this.format);
		} else {
			format = value;
		}
		return format;
	},
	parseValue: function(value, errors) {
		var fmt;
		if (this._isEmpty(value)) {
			return "";
		}

		try {
			fmt = datetime.parse(value, this.format);
			fmt = this._checkShortYear(fmt);
		} catch (e) {
			errors.push(locale.text("field.invalidInput", [this.format]));
			return value;
		}
		return fmt.toString("yyyy-MM-ddTHH:mm:ss.SSS") + "Z";
	}
});

var TimeFormatter = utils.defineClass(function($type, $format) {
	Formatter.call(this, $type, $format);
	if (this.$format === "TT") {
		this.format = locale.getTimeFormat();
	} else {
		this.format = locale.getTimeFormatShort();
	}
}, Formatter, {
	/**
	 * value expected to be a date string like "13:25:03"
	 */
	formatValue: function(value, editMode) {
		if (this._isEmpty(value)) {
			return "";
		}

		var p = value.split(/[^\d]+/);
		var format;
		if (p.length >= 2) {
			var t = time.make(+p[0], +p[1], +p[2]);
			format = t.toString(this.format);
		} else {
			format = value;
		}
		return format;
	},
	parseValue: function(value, errors) {
		if (this._isEmpty(value)) {
			return "";
		}
		var p = value.split(/[^\d]+/);
		if (p.length >= 1) {
			var t = time.make(+p[0], +p[1], +p[2]);
			return t.toString("HH:mm:ss");
		}
	}
});

var NumberFormatter = utils.defineClass(function($type, $format) {
	Formatter.call(this, $type, $format);
	this.format = this.$format || locale.getNumberFormat(this.$type);
}, Formatter, {
	/*
	 * value to be expected to be a number
	 */
	formatValue: function(value, editMode) {
		if (this._isEmpty(value)) {
			return "";
		}
		var format = numberFormat.format(value, this.format);
		return format;
	},
	parseValue: function(value, errors) {
		if (this._isEmpty(value)) {
			return "";
		}
		try {
			var fmt = numberFormat.parse(value, this.format);
		} catch (e) {
			errors.push(locale.text("field.invalidInput", [this.format]));
			return value;

		}
		return fmt;
	}
});

var _formatters = {
	"application/x-integer": NumberFormatter,
	"application/x-decimal": NumberFormatter,
	"application/x-real": NumberFormatter,

	"application/x-date": DateFormatter,
	"application/x-time": TimeFormatter,
	"application/x-datetime": DateTimeFormatter
};