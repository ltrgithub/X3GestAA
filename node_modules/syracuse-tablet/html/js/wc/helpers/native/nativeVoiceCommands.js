"use strict";

var log = require('syracuse-tablet/html/js/wc/helpers/logger').getLogger("nativeVoice");
var locale = require('syracuse-tablet/html/js/wc/helpers/locale');
var nativeTestVoiceCommands = require('syracuse-tablet/html/js/wc/helpers/native/wrapperTest/nativeTestVoiceCommands');
var nativeHelpers = require('syracuse-tablet/html/js/wc/helpers/native/nativeHelpers');
var notifications = require('syracuse-tablet/html/js/wc/helpers/notifications');
var nativeExtCall = require('syracuse-tablet/html/js/wc/helpers/native/nativeExtCall');

var _VoiceCommandsMgr = function(bookmarks) {

	this.isReady = false;

	this.init = function(mobileCommands) {
		notifications.subscribe(this, ["sm.application.ready"]);
		this.availableCommands = [];
		if (!mobileCommands || mobileCommands.length === 0) return false;
		var self = this,
			ok = false;
		mobileCommands.forEach(function(b) {
			ok = self.add(b) || ok;
		});
		return ok;
	};
	/**
	 * {type: "openBookmark", title: "...", other props}
	 */
	this.add = function(mobileCommand) {
		if (!mobileCommand || !mobileCommand.title) {
			return false;
		}
		if (this.getAvailableCommand(mobileCommand.title)) {
			log && log("add voice command - Command already exists '" + mobileCommand.title + "'");
			return false;
		}
		log && log("add voice command - '" + mobileCommand.title + "'");
		// Last are shown first (test wrapper)
		this.availableCommands.unshift(mobileCommand);
		return true;
	};

	this.remove = function(title) {
		if (!title) return false;
		var idx;
		if (this.availableCommands.some(function(b, i) {
				if (b.title === title) {
					idx = i;
					return true;
				}
			})) {
			this.availableCommands.splice(idx, 1);
			log && log("remove voice command - '" + title + "'");
			return true;
		}
		return false;
	};
	/**
	 * Returns the command if keyword matches with a command's title
	 */
	this.getAvailableCommand = function(keyWord) {
		var mobileCommand = null,
			self = this;
		this.availableCommands.some(function(b, i) {
			if (b.title === keyWord) {
				mobileCommand = self.availableCommands[i];
				return true;
			}
		});
		return mobileCommand;
	};
	/**
	 *
	 */
	this.executeOperation = function(operation) {
		if (!operation) return;
		var refresh = false;
		switch (operation) {
			case "set":
				refresh = this.init(arguments[1]);
				break;
			case "add":
				refresh = this.add(arguments[1]);
				break;
			case "remove":
				refresh = this.remove(arguments[1]);
				break;
			default:
				return;
		}
		if (refresh) {
			var phraseList = [];
			this.availableCommands.forEach(function(b) {
				phraseList.push(b.title);
			});
			var data = JSON.stringify({
				Phrase: "bookmark",
				PhraseList: phraseList,
				Language: locale.getCurrentLocale().toLowerCase()
			});
		}
		if (data) {
			log && log("Update voiceCommands: " + JSON.stringify(data, null, 2));
			nativeExtCall.fireMethod("smVoice", "setPhraseList", data);
		}
	};
	/**
	 * Application is ready
	 */
	this.notifApplicationReady = function() {
		// First
		this.isReady = true;
		// Check pending commands
		var cmd = this.getPendingCommand("openBookmark");
		if (cmd) {
			log && log("Execute pending command - '" + cmd.title + "'");
			this.executeVoiceCommand(cmd);
		}
		this.pendingCommands = null;
	};

	this.executeVoiceCommand = function(data) {
		if (this.isReady) {
			if (!data || !data.command || !data.text) return;
			var cmd = this.getAvailableCommand(data.text);
			if (!cmd || data.command !== cmd.type) return;
			log && log("Execute voice command - '" + cmd.title + "'");
			nativeHelpers.callAppNativeInterface("voiceCommands", "executeVoiceCommand", cmd);
			return;
		}
		// Stores the command
		if (!this.pendingCommands) {
			this.pendingCommands = [];
		}
		log && log("Stores pending voice command - '" + data.text + "'");
		this.pendingCommands.push(data);
	};

	this.getPendingCommand = function(type) {
		if (!this.pendingCommands) return null;
		var bmk = null;
		this.pendingCommands.some(function(cmd) {
			if (!cmd || cmd.command !== type) return;
			bmk = cmd;
			return true;
		});
		return bmk;
	};

	this.hasPendingCommand = function(type) {
		return this.getPendingCommand(type) != null;
	};

	// At the end
	this.init();
};
/**
 * Manages bookmarks
 * Created here to be available ASAP
 */
var _voiceCommandsManager = new _VoiceCommandsMgr();

//Global object to be called by native code on pencil events
if (!(window.smVoiceJS)) {
	window.smVoiceJS = {

		/*
		 *  This method will be invoked from wrapper when there was a voice command
		 *
		 *  return true - Command has been handled by webapp
		 *  return false - Command has not been handled, will raise an error message
		 *
		 *  For Hey cortana, show my customers
		 *  data {
		 *  	Command: "openBookmark",
		 *  	Text: "my customers"
		 *  }
		 */
		executeVoiceCommand: function(data) {
			if (!_voiceCommandsManager || !data) return;
			_voiceCommandsManager.executeVoiceCommand({
				command: data.Command,
				text: data.Text
			});
		}
	};
}
/**
 *
 */
exports.supports = function(capability) {
	if (capability === "voiceCommands") {
		return nativeExtCall.isSupported("smVoice", "setPhraseListSupported");
	}
	return $.smResolve(false);
};
/**
 *commands [{type: "openBookmark", title: "...", context: { see page.getRestoreContext }}
 */
exports.setVoiceCommands = function(commands) {
	_voiceCommandsManager.executeOperation.call(_voiceCommandsManager, "set", commands);
};
/**
 * {type: "openBookmark", title: "...", context: { see page.getRestoreContext }
 */
exports.addVoiceCommand = function(command) {
	_voiceCommandsManager.executeOperation.call(_voiceCommandsManager, "add", command);
};
/**
 * Remove the command identified by tutle
 */
exports.removeVoiceCommand = function(title) {
	_voiceCommandsManager.executeOperation.call(_voiceCommandsManager, "remove", title);
};
/**
 * True if there is a pending command of the given type to execute
 * type: openBookmark...
 */
exports.hasPendingCommand = function(type) {
	return _voiceCommandsManager.hasPendingCommand(type);
};
/**
 * Create a voice command from a pinned page
 * voiceCommandContext is the context used to restore the page
 */
exports.createCommandFromPage = function(pinnedPage, alternativeTitle) {
	if (!pinnedPage) return null;
	if (!pinnedPage.voiceCommandContext) return null;
	if (!alternativeTitle && !pinnedPage.title) return null;

	return {
		type: "openBookmark",
		title: alternativeTitle || pinnedPage.title,
		context: $.extend(true, {}, pinnedPage.voiceCommandContext)
	};
};
/**
 * Create a voice command from a application description
 * It switches to the application and opens the home page of application
 */
exports.createCommandFromAppli = function(title, appInfo) {
	if (!title || !appInfo || !appInfo.applicationName) return null;
	return {
		type: "openBookmark",
		title: title,
		context: {
			applicationName: appInfo.applicationName,
			// Just in case we want to ask user to select a endpoint when we switch to this application
			endpoints: appInfo.endpoints
		}
	};
};
/**
 * Returns the test js wrapper
 */
exports.init = function(testMode) {
	if (window && window.smVoice) return;
	if (!testMode) return;
	log && log("Creating native voice commands test wrapper");
	window.smVoice = nativeTestVoiceCommands.create();
	return window.smVoice;
};