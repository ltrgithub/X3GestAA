"use strict";

var Base = require('syracuse-tablet/html/js/wc/pages/pageBase').Page;

var utils = require('syracuse-tablet/html/js/wc/helpers/utils');
var helpers = require('syracuse-tablet/html/js/wc/common/helpers');

var SdataController = require("syracuse-tablet/html/js/wc/controllers/sdataController").SdataController;
var articleParser = require("syracuse-tablet/html/js/wc/controls/articleParser");
var ActionAdapterPageSdata = require('syracuse-tablet/html/js/wc/pages/sdata/actionAdapterPageSdata').ActionAdapterPageSdata;

var modules = require('syracuse-tablet/html/js/wc/common/modules');
var sdataReq = require("syracuse-tablet/html/js/wc/sdata/sdataRequester");
var waiting = require('syracuse-tablet/html/js/wc/utils/waiting');
var settings = require('syracuse-tablet/html/js/wc/app/settings');
var notifications = require('syracuse-tablet/html/js/wc/helpers/notifications');
var protoHelpers = require('syracuse-tablet/html/js/wc/sdata/protocolHelpers');

/**
 * Page handling something backed-up by sdata
 * 
 * A page should
 * - Create UI controls needed for rendering, can be device specific like header/footer
 * - Create it's controller 
 */
exports.Page = utils.defineClass(
	function PageSdata(pageData, options) {
		this.pageData = pageData;
		Base.call(this, pageData.name, options);

		this.actionAdapter = new ActionAdapterPageSdata(this);
		this.actionAdapter.showDesignPage = this.allowAuthoring();
	},
	Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.pageData = null;

			if (this.controller) {
				this.controller.destroy();
				this.controller = null;
			}
			if (this.actionAdapter) {
				this.actionAdapter.destroy();
				this.actionAdapter = null;
			}
		},
		unbuild: function() {
			if (this.rootLayout) {
				this.rootLayout.destroy();
				this.rootLayout = null;
			}
			Base.prototype.unbuild.call(this);
		},
		_ensureController: function() {
			this.controller = new SdataController(this.pageData.dataset, null, this.pageData.isWorkingCopy);
			// Will raise notifications or do confirmations
			this.controller.setUIAdapter(this);
		},
		createRootElement: function() {
			Base.prototype.createRootElement.call(this);

			this.$$elmt.attr("data-controller-id", this.controller.id);
			// Needed by css - previous version
			var css = ["regular"];
			var facet = this.controller.dataset.prototype.getFacet();
			if (facet) {
				css.push(facet.smStartsWith("$") ? facet.substring(1) : facet);
			}
			this.$$elmt.addClass(css.join(" "));
		},
		initStructure: function() {
			Base.prototype.initStructure.call(this);
			this.rootLayout = articleParser.parseArticle(this.controller, this.pageData.page.$article, this);
			if (!this.rootLayout) {
				return $.smReject(helpers.createDiag(null, "error", "Page does not have a valid article")); // TODO: NLS
			}
		},
		render: function() {
			var self = this;
			return $.smResolve()
				.then(function() {
					self.attachedControlsMgr.buildHtml();
					self.rootLayout.set$$container(self.$$contentRoot);
					self.rootLayout.buildHtml();
				});
		},
		afterRender: function() {
			this.rootLayout.afterRender();
		},

		/**
		 * Called when the data on a page has changed after pagination/filter..
		 * Normally we shoudl'nt rebuild but just refresh the page
		 */
		rebuildHtml: function() {
			this.rootLayout.destroy();
			this.rootLayout = articleParser.parseArticle(this.controller, this.pageData.page.$article, this);
			this.rootLayout.set$$container(this.$$contentRoot);
			this.rootLayout.buildHtml();
			// Like the controls are destroyed we have to computeLayout to recalculate the widths
			this.computeLayout({
				refresh: true
			});
		},

		/**
		 * Compute layout starting from rootLayouts
		 */
		computeControlsLayouts: function(context) {
			Base.prototype.computeControlsLayouts.call(this, context);
			if (this.rootLayout) {
				this.rootLayout.computeLayout(context);
			}
		},
		/**
		 * True if scroll enabled in page
		 * edit/detail allows scroll in vignette
		 * query/lookup doesn't allow because scroll is done by the array
		 */
		scrollAllowed: function() {
			if (this.controller.dataset.prototype.isQueryLikeFacet()) {
				// This is the array which scrolls
				return false;
			}
			return true;
		},

		//
		// START UI ADAPTER
		//
		_showNotification: function(title, message, severity) {
			modules.get("modal").notify({
				title: title,
				body: message,
				severityClass: severity
			});
		},
		_askConfirmation: function($confirm) {
			var resultPromise = $.Deferred();
			modules.get("modal").simpleConfirm($confirm, function(confirmed) {
				resultPromise.resolve(confirmed);
			});
			return resultPromise.promise();
		},
		// This is mostly for debugging pending requests easily
		_updateRequestCount: function(count) {
			if (!this.$$counter) {
				this.$$counter = $('<span style="position: absolute; right: 0; bottom: 0; padding: 10px; background: white; z-index: 99999; opacity: 0.5;"><span>');
				this.$$elmt.append(this.$$counter);
			}
			if (count > 0) {
				this.$$counter.show();
				this.$$counter.text(count);
			} else {
				this.$$counter.hide();
			}
		},
		//
		// END UI ADAPTER
		//

		getPageTitle: function() {
			return this.controller.dataset.prototype.getValueByPath("$title", true);
		},

		_actOpenActionsPanel: function() {
			var actionsPanel = this.attachedControlsMgr.findByName("actionsPanel");
			if (!actionsPanel) {
				var info = this._getAttachedControlInfo("actionsPanel");
				if (info) {
					actionsPanel = this.attachedControlsMgr.createControl(info);
				}
			}
			if (!actionsPanel) {
				return;
			}
			actionsPanel.show();
		},

		/**
		 * Used by paging to allow the page to reload itself and update the history also
		 */
		fetchNewPageData: function($link) {
			var self = this;
			var $url = $link.$url;
			var fetchData = sdataReq.fetchPageData({
					$url: $url
				}, {
					prototype: self.pageData.prototype.json,
					page: self.pageData.page
				})
				.then(function(pageData) {
					var navStack = modules.get("navStack").findClosest(self.$$elmt);
					if (navStack) {
						navStack.replaceCurrentPageData(self, function(currentData) {
							currentData.url = $url;
							return currentData;
						});
					}
					//keep the settings
					var settings = $.extend(true, {}, self.pageData.settings);
					self.pageData = pageData;
					self.pageData.settings = settings;
					self.controller.dataset.destroy();
					self.controller.setDataset(self.pageData.dataset);
					self.rebuildHtml();
				});
			waiting.waitModal(fetchData)
				.fail(function(error) {
					modules.get("modal").error(error);
				})
				.then(function() {
					self.onPageDataChanged();
				});
		},
		getPageSort: function() {
			return this.getPageSettings().sort;
		},
		getPageFilter: function() {
			return this.getPageSettings().filter;
		},
		setPageSort: function(sort) {
			var old = this.getPageSort();
			if (sort == null && old == null) {
				return;
			}
			var changed = (old == null || sort == null) || (old.length != sort.length);
			changed = changed || sort.some(function(val, idx) {
				return sort[idx].sort !== old[idx].sort || sort[idx].field !== old[idx].field;
			});
			if (changed) {
				this.getPageSettings().sort = sort;
				this.getPageSettings().isDirty = true;
			}
		},
		setPageFilter: function(filter) {
			var old = this.getPageSort();
			if (old == null && filter == null) {
				return;
			}
			this.getPageSettings().filter = filter;
			this.getPageSettings().isDirty = true;
		},
		/* 
		 * Write user specific settings of this page
		 * Uses getPagePrefsId to compute key of the page
		 * When the key is empty, the page is assumed to have not settings and nothing is written
		 */
		writePageSettings: function() {
			var self = this;
			var pageSettings = self.getPageSettings();
			if (!pageSettings.isDirty) {
				return $.smResolve();
			}
			return $.smResolve()
				.then(function() {
					return self.getPagePrefsId();
				})
				.then(function(pagePrefsId) {
					if (pagePrefsId) {
						delete pageSettings["isDirty"];
						return settings.writeUserPagePrefs(pagePrefsId, pageSettings);
					}
				});
		},
		getPageSettings: function() {
			return this.pageData.settings || {};
		},
		/*
		 * Id to save settings if this page, can be overridden
		 * The Id the sdata url of the page. Like this, the same request
		 * always get's the same settings
		 */
		getPagePrefsId: function() {
			var id = settings.ensurePageId(this.pageData.$originalUrl || this.pageData.$url);
			return id;
		},
		/**
		 * Called when the data on a page has changed.
		 * First time called after page has rendered and the e.g. on paging
		 */
		onPageDataChanged: function() {
			Base.prototype.onPageDataChanged.call(this);
			if (!this.isVignette()) {
				// Vignettes will report to their dashboard and not directly notify here
				notifications.publish("sm.data.freshness.change", this.controller.dataset.getDataFreshness());
			}
		},
		// Arguments:  "details", "edit", "create"
		isFacet: function() {
			return this.controller.dataset.prototype.isFacet.apply(this.controller.dataset.prototype, arguments);
		},
		//
		// START: Authoring
		//
		allowAuthoring: function() {
			return true;
		},
		/**
		 * Returns name to use for saving authoring
		 * x3.erp.AQTCRUDM.$query
		 * syracuse.collaboration.testHomeDashboard.$mobileDashboard
		 */
		getAuthoringName: function() {
			var $url = this.pageData.$url;
			var repr = protoHelpers.getReprFromUrl($url);
			var ep = protoHelpers.getEndpointFromUrl($url);
			ep = ep.split(".").slice(0, 2).join(".");
			return ep + "." + repr;
		},
		getPrototype: function() {
			return this.pageData.prototype;
		},
		getRootLayout: function() {
			return this.rootLayout;
		},
		getArticle: function() {
			return this.pageData.page.$article;
		},
		authUpdateLayout: function(article) {
				this.pageData.page.$article = article;
				return Base.prototype.authUpdateLayout.call(this, article);
			}
			//
			// END: Authoring
			//
	}
);