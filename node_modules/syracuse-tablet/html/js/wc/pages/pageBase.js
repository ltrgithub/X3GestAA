"use strict";

var utils = require('syracuse-tablet/html/js/wc/helpers/utils');
var Controller = require("syracuse-tablet/html/js/wc/controllers/controller").Controller;
var AttachedControlsMgr = require('syracuse-tablet/html/js/wc/pages/attachedControlsMgr').AttachedControlsMgr;

var siteLayout = require('syracuse-tablet/html/js/wc/ui/siteLayout');
var uiRect = require('syracuse-tablet/html/js/wc/ui/rect');
var scroller = require('syracuse-tablet/html/js/wc/helpers/scroller/scrollerHelpers');
var notifications = require('syracuse-tablet/html/js/wc/helpers/notifications');

var _id = 1;
var _templates = {};
var _html = {
	fullpage: '\
		<section class="s-m-page s-m-full {{device}}" id="{{pageId}}" style="display: none" data-page-name="{{pageName}}"> \
			<header></header> \
			<section class="s-m-breadcrumbs" style="display:none"></section> \
			<section class="s-m-topToolbar"  style="display:none"></section> \
			<section class="s-m-main-content" data-s-m-content=""></section> \
			<footer style="display:none"></footer> \
		</section> \
	',
	vignette: '<section class= "s-m-page s-m-nested" id="{{pageId}}" style="display: none;" data-page-name="{{pageName}}"></section>',
	panelContainers: '\
		<div class="s-m-side-panel-dismiss" data-nevent data-naction="closePanel"></div> \
		<aside class="s-m-panel s-m-left"></aside> \
		<aside class="s-m-panel s-m-right"></aside>'

}
var _getHtml = function(name, ctx) {
	var tmpl = _templates[name];
	if (!tmpl) {
		tmpl = _templates[name] = Handlebars.compile(_html[name]);
	}
	return tmpl(ctx || {});
};

var _pages = {};

/**
 * options:
 * {
 *   isChild: true|false
 *   isVignette: true|false
 * }
 */
exports.Page = utils.defineClass(
	function PageBase(pageName, options) {
		this.pageName = pageName || "noname";
		this.id = _id++;
		_pages[this.id] = this;
		this.options = options || {};
		// set from outside, in here we want to load the page
		this.$$container = null;
		// root element of the page
		this.$$elmt = null;
		// element where the main page content is rendered to
		this.$$contentElmt = null;
		this.controller = null;
		// When a page is loaded inside a vignette, parentPage will point to the dashboard containing the vignette
		this.parentPage = null;
		// Vignette that embeds the page if any
		this.parentVignette = null;
		this.attachedControlsMgr = new AttachedControlsMgr(this);
		// Let page subclasses define their own controller if needed
		this._ensureController();
	},
	null, {
		/** 
		 * Override to create a specialized controller
		 */
		_ensureController: function() {
			this.controller = new Controller(null);
		},
		destroy: function() {
			this.destroyed = true;
			this.unbuild();
			delete _pages[this.id];
			this.parentVignette = null;
			this.parentPage = null;
			this.controller = null;
			if (this.controller) {
				this.controller.destroy();
				this.controller = null;
			}
			if (this.attachedControlsMgr) {
				this.attachedControlsMgr.destroy();
				this.attachedControlsMgr = null;
			}
		},
		/**
		 * Release resources that will be re-allocated on build
		 */
		unbuild: function() {
			if (this.attachedControlsMgr) {
				this.attachedControlsMgr.destroyControls();
			}

			if (this.$$elmt) {
				this.$$elmt.unbind();
				this.$$elmt.remove();
			}

			this.$$elmt = null;
			this.$$contentElmt = null; // Element in DOM which contains all content and eventually a scroller
			this.$$contentRoot = null; // Put content in here: Element in DOM that is eventually scrollable, could be the same as $$contentElmt if no scrolling is desired
		},
		// Return true whenever pushing this page onto the page stack
		// should clear the history and make this page the only one 
		// existing the the history (e.g. login, logout, home)
		isRootPage: function() {
			return false;
		},
		// For pages that must not be added to the history.
		// e.g. Login, logout
		isNoHistory: function() {
			return false;
		},
		set$$container: function($$container) {
			this.$$container = $$container;
		},

		/**
		 * Should be called by all subclasses
		 */
		createRootElement: function() {
			var tplName = "fullpage";
			if (this.isVignette()) {
				tplName = "vignette";
			}

			var ctx = {
				pageId: this.id,
				pageName: this.pageName,
				device: siteLayout.getDeviceType(),
			};
			this.$$elmt = $(_getHtml(tplName, ctx));
			this.$$contentElmt = this.$$elmt.find('[data-s-m-content]'); // Is there a children flagged to be the content holding element
			if (this.$$contentElmt.length === 0) {
				this.$$contentElmt = this.$$elmt; // Use root element for page content if no other element is flagged to be used
			}
			this.$$contentRoot = this.$$contentElmt;

			if (!this.isVignette()) {
				this.$$elmt.append($(_getHtml("panelContainers")));
			}
			this.$$container.append(this.$$elmt);
			this._initScrolling();
		},

		hide: function() {
			if (!this.$$elmt) {
				return;
			}
			this.$$elmt.hide();
		},

		show: function() {
			if (!this.$$elmt) {
				return $.smResolve();
			}
			this.$$elmt.show();
			var self = this;
			return $.smResolve().then(function() {
				/**
				 * Compute the layout once that page is visible
				 * It's mandatory to calculate fixed width 
				 * For a vignette computeLayout is called by the dashboard once all the vignettes have been loaded
				 */
				if (!self.isVignette()) {
					self.computeLayout();
				}

			})
		},

		/**
		 * computeLayout is called when the page is shown (show method)
		 */
		build: function() {
			var self = this;

			return $.smResolve()
				.then(function() {
					return self.createRootElement();
				})
				.then(function() {
					return self.initStructure && self.initStructure();
				})
				.then(function() {
					return self.render && self.render();
				})
				.then(function() {
					return self.afterRender && self.afterRender();
				})
				.then(function() {
					self.onPageDataChanged();
				})
		},

		initStructure: function() {
			this.createAttachedControls();
		},
		/**
		 * context: 
		 */
		computeLayout: function(context) {
			this.$$elmt.removeClass("landscape portrait");
			this.$$elmt.addClass(siteLayout.getPageOrientation());
			var layoutInfo = siteLayout.getLayoutInfo();
			if (!this.isVignette()) {
				var mainLayout = this.attachedControlsMgr.computeMainLayout(layoutInfo);
				this.$$contentElmt.css({
					top: mainLayout.contentTop + "px",
					left: mainLayout.contentLeft + "px",
					width: mainLayout.contentWidth + "px",
					height: mainLayout.contentHeight + "px"
				});
			} else {
				/**
				 * For vignette we don't calculate the H/W in pixels.
				 * To do the calculatation we need to propagate the calculation from dashboard tile -> Control (not done and needed)
				 * H/W calculation is based on css style height auto for the wrapper et 100% for $$contentElmt
				 */
			}
			this.mainContentRect = uiRect.elmtRect(this.$$contentElmt, "computed");
			this.mainContentRect.moveLeft(parseInt(this.$$contentElmt.css("padding-left"), 10));
			layoutInfo.pageContentRect = this.mainContentRect;
			// Compute controls layout
			this.computeControlsLayouts($.extend(true, context, layoutInfo));
			// Update scrolling at the end
			this._updateScrolling();
		},

		/**
		 * Can be overridden - sDataPage compute from rootLayout
		 */
		computeControlsLayouts: function(context) {
			// Compute layouts for attached controls
			if (this.attachedControlsMgr) {
				this.attachedControlsMgr.computeLayout(context);
			}
		},

		//
		// START: Scrolling stuff
		//


		/**
		 * True if scroll enabled in page
		 * By default we can scroll a page in full display
		 * In vignettes only details/edit facet are allowed to scroll - See regular page
		 * In Dashboard hub this is the layout that scrolls - Page doesn't scroll
		 */
		scrollAllowed: function() {
			return !this.isVignette() && !this.isDashboard("hub");
		},

		/**
		 * Override for pages that do not want scrolling
		 */
		_initScrolling: function(preserveScroll) {
			if (!this.scrollAllowed()) {
				return;
			}
			this.$$scrollWrapper = $('<div class="s-m-scroll-wrapper"/>').appendTo(this.$$contentElmt);
			this.$$scrollWrapper.css({
				height: "auto"
			});
			this.$$contentRoot = this.$$scrollWrapper;

			this._gestureMgr = scroller.newScroller(this.$$scrollWrapper, {
				isPageScroller: true // !self.isVignette
			});
		},
		_updateScrolling: function() {
			if (!this._gestureMgr) {
				return;
			}
			if (!this.scrollAllowed()) {
				this._gestureMgr.reset();
				return;
			}
			var viewRect = this.isVignette() ? this.parentVignette.getScrollViewRect() : this.mainContentRect;
			if (!viewRect || viewRect.height >= this.$$scrollWrapper.height()) {
				this._gestureMgr.reset();
				return;
			}
			// Force $$scrollWrapper to full height of children
			// We scroll if children height is greater than childrenRect height
			if (this.isVignette()) {
				return;
			}
			var valMax = 0;
			// If not new -> back on a cahced page - We keep scrolling
			preserveScroll = preserveScroll === true;
			// viewRect has fixed coordinate to check if the 'finger' is inside on mousemouve event
			// A page always scolls vertically - In dashboard this is the layout that scrolls horizontally
			this._gestureMgr.init(viewRect, "v", valMax, preserveScroll);
			var autoScroll = this.options["auto-scroll"];
			if (autoScroll != null) {
				// When we go to $edit form $details we keep the scrolling in order to stay at the same location (see actionManager)
				this.autoScroll(autoScroll);
				// Only when we loadd the page
				this.options["auto-scroll"] = undefined;
			}

			/*
			
			var viewRect = this.mainContentRect;
			// Force $$scrollWrapper to full heigth of childrens
			// We scroll if children height is greater than childrenRect height
			if (viewRect && viewRect.height < this.$$scrollWrapper.height()) {
				var valMax = 0;
				this._gestureMgr.init(viewRect, "v", valMax, false);
			} else {
				this._gestureMgr.reset();
			}*/
		},

		/**
		 * Called by controls that have an impact on the page size after loading
		 * Currently, this are only vignettes
		 */
		onContentChanged: function() {
			this._updateScrolling();
		},

		//
		// END: Scrolling stuff
		//

		getPageTitle: function() {
			return "";
		},

		createAttachedControls: function() {
			var self = this;
			var names = self._getDefaultAttachedControls();
			names.forEach(function(name) {
				var info = self._getAttachedControlInfo(name);
				if (info) {
					self.attachedControlsMgr.createControl(info);
				}
			});
		},

		/**
		 * Get logical name of controls that are usually attached to a page
		 * 
		 * Can be overriden per page if necessarry
		 * @returns
		 */
		_getDefaultAttachedControls: function() {
			if (this.isVignette()) {
				return [];
			}
			var device = siteLayout.getDeviceType();
			if (device === "smartphone") {
				return ["header"];
			} else {
				return ["header", "breadcrumbs", /*  "topToolbar",*/ "footer"];
			}
		},

		/**
		 * Get detail information on how to create a logical control
		 * E.g. device dependent header
		 * 
		 * Can be overriden per page if necessarry
		 * 
		 * @param name
		 * @returns
		 */
		_getAttachedControlInfo: function(name) {
			var device = siteLayout.getDeviceType();
			var defaults = {
				smartphone: {
					header: {
						topIndex: 0,
						selector: "header",
						$type: "application/x-panel-header-sdata-page-smartphone"
					},
					actionsPanel: {
						selector: "aside.s-m-panel.s-m-right",
						$type: "application/x-panel-actions"
					},
					globalPanel: {
						selector: "aside.s-m-panel.s-m-left",
						$type: "application/x-panel-global-smartphone"
					},
					filterSortPanel: {
						selector: "aside.s-m-panel.s-m-right",
						vignetteSelectorUseParent: true,
						$type: "application/x-panel-filtersort"
					}
				},
				tablet: {
					header: {
						topIndex: 0,
						selector: "header",
						$type: "application/x-panel-header-sdata-page-tablet"
					},
					breadcrumbs: {
						topIndex: 1,
						selector: ".s-m-breadcrumbs",
						$type: "application/x-panel-breadcrumbs-tablet"
					},
					topToolbar: {
						topIndex: 2,
						selector: ".s-m-topToolbar",
						$type: "application/x-panel-???" // TODO:
					},
					footer: {
						bottomIndex: 0,
						selector: "footer",
						$type: "application/x-panel-footer-sdata-page"
					},
					actionsPanel: {
						selector: "aside.s-m-panel.s-m-right",
						$type: "application/x-panel-actions"
					},
					globalPanel: {
						selector: "aside.s-m-panel.s-m-right",
						$type: "application/x-panel-global-tablet"
					},
					filterSortPanel: {
						selector: "aside.s-m-panel.s-m-right",
						vignetteSelectorUseParent: true,
						$type: "application/x-panel-filtersort"
					},
					chartDetailToolBar: {
						topIndex: 2,
						selector: ".s-m-topToolbar",
						$type: "application/x-chartdetail-toolbar"
					}
				}
			};

			var info = defaults[device][name];
			info.name = name;
			return info;
		},
		openPanel: function(name, options) {
			var panel = this.attachedControlsMgr.findByName(name);
			if (!panel) {
				var info = this._getAttachedControlInfo(name);
				if (info) {
					panel = this.attachedControlsMgr.createControl(info, options);
				}
			}
			if (!panel) {
				return;
			}
			return panel
		},
		_actOpenGlobalPanel: function() {
			var panel = this.openPanel("globalPanel");
			if (panel) panel.show();
		},
		/**
		 * Should do:
		 * - Destroy and re-create page specific controls like header/footer depending on the page size/device
		 *   (also this is mostly a development use case)
		 * - Close opened panels and popups 
		 */
		onMainPageResize: function(info, orientation, deviceType) {
			if (info.deviceChanged == true && this.attachedControlsMgr) {
				// Rebuild header/footer.. according to deviceType
				this.attachedControlsMgr.destroyControls();
				this.createAttachedControls();
				this.attachedControlsMgr.buildHtml();

			}
			this.computeLayout();
		},
		/**
		 * Called by navigator whenever the page will be closed because of a back action
		 * The back action will be done as soon as the given deferred is resolved with "true"
		 * Resolving with "false" will cancel the back action
		 * Rejecting will show the error given to reject
		 */
		onBackAction: function(def) {
			// Default is to accept back
			def.resolve(true);
		},

		onRequestUpdateScroller: function() {

		},
		/**
		 * Called when the data on a page has changed.
		 * First time called after page has rendered and the e.g. on paging
		 */
		onPageDataChanged: function() {},

		//
		// START: Authoring
		//
		allowAuthoring: function() {
			return false;
		},
		getAuthoringName: function() {

		},
		getPageName: function() {
			return this.pageName;
		},
		isVignette: function() {
			return this.options.isVignette === true;
		},
		authUpdateLayout: function() {
			var self = this;
			self.unbuild();
			return self.build().then(function() {
				return self.show();
			});
		},
		//
		// END: Authoring
		//

		/**
		 * typeDashboard = hub / stack / undefined
		 */
		isDashboard: function(typeDashboard) {
			return false;
		},

		isNestedInDashboard: function(typeDashboard) {
			return this.isVignette() && this.parentPage && this.parentPage.isDashboard(typeDashboard);
		},

		/**
		 * pageName: null, SdataRowDetail, SdataChartDetail
		 * 
		 */
		isChild: function(pageName) {
			if (pageName == null) {
				return this.options.isChild === true;
			}
			return this.options.isChild === true && this.options.pageChildName === pageName;
		},
		/**
		 * Overridden by dashboard
		 */
		getGestureMgr: function() {
			return this._gestureMgr;
		},
		/**
		 * Update the scroller - needed for staked layouts
		 * In stacked/row layout the height of the page is given by the height of the content of the vignette
		 * Used by charts and vignettes
		 * force= true to force recalculation if caller nows that scolling area changed
		 */
		notifyScrollerUpdate: function(force) {
			// _gestureMgr != null for stack (not hub structure)
			if (!this._gestureMgr) return;
			// Optimization - If the height/width din't change we skip init Scroll (works only if (scale factor == 1)
			if (force !== true && this._gestureMgr.viewRect && this.mainContentRect.equals(this._gestureMgr.viewRect, true)) {
				return;
			}
			// Init scroll because hight has changed - True to preserve scroll for authoring
			this._updateScrolling(true);
		}

	});

exports.findPage = function(id) {
	return _pages[id];
}