"use strict";

var jsutils = require('syracuse-tablet/html/js/wc/helpers/jsutils');
var waiting = require('syracuse-tablet/html/js/wc/utils/waiting');
var modules = require('syracuse-tablet/html/js/wc/common/modules');
var environment = require('syracuse-tablet/html/js/wc/helpers/environment');

var protoHelpers = require('syracuse-tablet/html/js/wc/sdata/protocolHelpers');
var metaDataCache = require('syracuse-tablet/html/js/wc/sdata/cache/metaDataCache');

/**
 * url (sdata): http://localhost:8124/mobile2/x3/erp/GX3APP/TABCUR?representation=TABCURM.$lookup
 * method: GET | SET
 * 
 * pageOptions: {
 *   isChild: ... // Open the page as a child of the current page (this means parent page is not destroyed but hidden in the DOM)
 *   
 *	 lookup: { // When url is a lookup, the control asking for the lookup adds this information so the lookup page can inject the selected value
 *	   controllerId: ...
 *	   controlId: ...
 *	   $bind: Name of property receiving the value picked in the lookup
 *     $lookupKeyName: Name of the property in a lookup item that will used as result
 *	},
 *
 *  childContext: { // For client or "detail" pages like row details or chart detail to give context of the parent
 *  	controllerId
 *  }
 * }
 * 
 * 
 * loadOptions:{
 * 		navStack: Instance of NavigationPageStack to push the page on.
 *           If null, the application's main stack is used
 *			 Setting a non standard stack is used to navigate in vignettes
 * 
 * 		noError: Do not show error modal on page loading issues, should be used by vignettes  
 * }
 * RESOLVES WITH PAGE OR NULL
 * 
 * 
 * Urls supported:
 * http://.../mobile2/... sdata pages
 * child://pageName sdata based page that fulls depends on the controller of a parent (e.g. row detail)
 * 
 * html://pageName Full client side page
 * 
 */
exports.gotoUrl = function(url, method, pageOptions, loadOptions) {
	var deferred = $.Deferred();
	try {
		var pageCreateData = {};
		// Temp: Redirect home to local home dashboard
		if (url.toLowerCase().indexOf("html://home") >= 0) {
			// $welcomeDashboard.$mobileDashboard for comatibility with autoUI tests
			url = protoHelpers.getLocalDashboardUrl('HOME');
			pageCreateData.name = "HOME";
		} else if (url.indexOf("{$hostPort}") === 0) {
			// Used by unit tests (local)
			url = url.replace("{$hostPort}", protoHelpers.getHostPort());
		}
		// pageCreateData is a simple object that should contain all information
		// that is needed to restore a page on history back or context restore
		pageCreateData.options = $.extend(true, {}, pageOptions);
		pageCreateData.url = url;
		pageCreateData.method = method;

		loadOptions = loadOptions || {};

		// Pre check step is there to check if we really want to navigate
		// this can be anything like checking if a mobile app is valid or has to be installed first
		// if precheck returns false, navigation is stopped silently

		_checkNavigation(url, method).then(function(okToNavigate) {
				if (okToNavigate === true) {
					if (environment.isAutoUITestMode()) {
						environment.getUnitTestMgr().notifPageLoaded("before");
					}
					var loadingPromise = modules.get("pageFactory").createPage(pageCreateData);
					return waiting.waitModal(loadingPromise, loadOptions.$$waitParent)
				} else {
					return null;
				}
			})
			.then(function(newPage) {
				if (!newPage || newPage.destroyed === true) {
					//Page can be destroyed before beeing dislayed (multiple back in dashboards)
					return null;
				}
				var navStack = loadOptions.navStack || modules.get("navStack").getMainStack();
				return navStack.pushPage(newPage, pageCreateData)
			})
			.then(function(page) {
				if (environment.isAutoUITestMode()) {
					environment.getUnitTestMgr().notifPageLoaded("after", page);
				}
				deferred.resolve(page)
			}).fail(function(error) {
				if (loadOptions.noError !== true) {
					modules.get("modal").asynchError(null, error).always(function() {
						deferred.resolve(null);
					})
				} else {
					deferred.reject(error);
				}
			});
	} catch (e) {
		deferred.reject(e);
	}
	return deferred.promise();

};

/**
 * 
 * @param url
 * @param method
 * @returns
 */
function _checkNavigation(url, method) {
	return $.smResolve()
		.then(function() {
			try {
				var parsed = jsutils.parseURL(url);
				if (parsed && parsed.query) {
					var appName;
					if (parsed.query.representation === "mobileApplication.$details") {
						appName = protoHelpers.getKeyFromUrl(url);
					} else if (parsed.query.$mobileApplication) {
						appName = parsed.query.$mobileApplication;
					}
					var endpoint = parsed.query.$mobileEndpoint;
					if (appName && endpoint) {
						return _checkMobileApplication(appName, endpoint);
					}
				}
			} catch (Exception) {
				return true;
			}
		})
		.then(function(okToNavigate) {

			// Safety bag, when no check occured above, we assume navigation is ok
			if (okToNavigate == null) {
				okToNavigate = true;
			}

			return okToNavigate;
		});
}


function _checkMobileApplication(appName, endpoint) {
	return $.smResolve()
		.then(function() {
			return metaDataCache.tryGetApp(appName, endpoint);
		})
		.then(function(appData) {
			if (appData === null) { // Not installed
				return _installMobileApplication(appName, endpoint);
			} else {
				return _updateMobileApplication(appName, endpoint, appData);
			}
		});
}

function _installMobileApplication(appName, endpoint) {
	var installConfirmed = true;
	return $.smResolve()
		.then(function() {
			if (installConfirmed) {
				return metaDataCache.installApp(appName, endpoint).then(function() {
					return true;
				});
			} else {
				// No install, no navigation
				return false;
			}
		});
}


function _updateMobileApplication(appName, endpoint, appData) {
	var updateConfirmed = true;
	return $.smResolve()
		.then(function() {
			return metaDataCache.isAppUpToDate(appData, endpoint);
		})
		.then(function(isUpToDate) {
			if (isUpToDate) {
				return true;
			}
			if (updateConfirmed) {
				return metaDataCache.installApp(appName, endpoint).then(function() {
					return true;
				});
			} else {
				// No update, still we can navigate to old version
				return true;
			}
		});
}