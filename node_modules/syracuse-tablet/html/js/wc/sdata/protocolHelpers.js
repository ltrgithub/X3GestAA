"use strict";

var jsutils = require('syracuse-tablet/html/js/wc/helpers/jsutils');

/**
 * 
 */
exports.getPageUrl = function(dataUrl, sdataResponse) {
	var repr = exports.getReprFromUrl(dataUrl);
	var baseUrl = exports.getHostPortFromUrl(dataUrl);
	var endpoint = exports.getEndpointFromUrl(dataUrl);

	if (repr === "mobileDashboard.$details" && sdataResponse) {
		repr = sdataResponse.dashboardName + ".$mobileDashboard";
		endpoint = "syracuse.collaboration.syracuse";
	}

	var url = baseUrl + "/sdata/syracuse/collaboration/syracuse/pages('" + endpoint + "." + repr + ",$page,,mobile')";
	return $.smResolve(url);
}

/**
 * Extract compute prototype url from url
 * http://localhost:8124/mobile2/x3/erp/GX3APP/$prototypes('TABCURM.$lookup')
 * return http://localhost:8124/mobile2/x3/erp/GX3APP$/prototypes('TABCURM.$lookup')
 */

exports.getPrototypeUrl = function(dataUrl) {
	var repr = exports.getReprFromUrl(dataUrl);
	var baseUrl = exports.getBaseUrlFromUrl(dataUrl);
	var url = baseUrl + "/$prototypes('" + repr + "')";
	return url;
}

/**
 * Returns rep and facet if any
 */
exports.getReprInfoFromUrl = function(url) {
	url = decodeURIComponent(url);
	var repr = /representation=(\S+?)\.(\$[a-zA-Z]+)/.exec(url);
	if (repr && repr.length > 2) {
		return {
			representation: repr[1],
			facet: repr[2]
		}
	}
	return null;
}

/**
 * Extract representation query parameter's value
 * {$baseUrl}/$workingCopies('2e3a0b34-994a-4909-8a50-e001a2deb0ad')?representation=AQMCRUDM.$edit"
 * return AQMCRUDM.$edit
 */
exports.getReprFromUrl = function(url) {
	var info = exports.getReprInfoFromUrl(url);
	if (info) {
		return info.representation + "." + info.facet;
	}
	return null;
}

/**
 * Extract endpoint from url
 * http://localhost:8124/mobile2/x3/erp/GX3APP/$prototypes('TABCURM.$lookup')
 * return x3.erp.GX3APP
 */
exports.getEndpointFromUrl = function(url) {
	var segs = url.split("/");
	var endpoint = segs.slice(4, 7).join(".");
	return endpoint;
}

/**
 * Extract baseurl from url
 * http://localhost:8124/mobile2/x3/erp/GX3APP/$prototypes('TABCURM.$lookup')
 * return http://localhost:8124/mobile2/x3/erp/GX3APP
 */
exports.getBaseUrlFromUrl = function(url) {
	var segs = url.split("/");
	var host = segs.slice(0, 7).join("/");
	return host;
}

/**
 * Extract key from url
 * http://localhost:8124/mobile2/x3/erp/GX3APP/$prototypes('TABCURM.$lookup')
 * "http://localhost:8124/mobile2/syracuse/collaboration/syracuse/mobileDashboards(dashboardName%20eq%20'STD_X3_ERP_EXPENSES_DASHBOARD')?representation=mobileDashboard.$details"
 * return TABCURM.$lookup or STD_X3_ERP_EXPENSES_DASHBOARD
 */
exports.getKeyFromUrl = function(url) {
	var keyOnly = /\('(.*?)'\)/.exec(url);
	if (keyOnly && keyOnly[1] != null) {
		return keyOnly[1];
	}

	var keyWithEq = /\((.*eq.*?)'(.*?)'\)/.exec(url);
	if (keyWithEq && keyWithEq[2] != null) {
		return keyWithEq[2];
	}
}

/**
 * Returns protocol, host and port the app is running on
 * return http://localhost:8124
 */
exports.getHostPort = function() {
	return exports.getHostPortFromUrl(window.location.href);
};

/**
 * Extract host, port and protocol from url
 * http://localhost:8124/mobile2/x3/erp/GX3APP/$prototypes('TABCURM.$lookup')
 * return http://localhost:8124
 */
exports.getHostPortFromUrl = function(url) {
	var segs = url.split("/");
	var host = segs.slice(0, 3).join("/");
	return host;
};

/**
 * Construct url on where to fetch a mobile application from
 */
exports.getMobileAppUrl = function(appName) {
	var php = exports.getHostPort();
	var appUrl = php + "/sdata/syracuse/collaboration/syracuse/mobileApplications(applicationName%20eq%20'" + appName + "')";
	return appUrl;
};

/**
 * For a given dashboard name, constructs the url from where to fetch the data
 */
exports.getLocalDashboardUrl = function(dashboardName) {
	return exports.getHostPort() + "/mobile2/$client/$local/$dataset/mobileDashboard('" + dashboardName + "')"
};
/**
 * 
 * Create the action url and payload to be send to the server
 * 
 */
exports.createActionData = function(dataset, $actionName, $action, workingCopy) {
	var actionData = {};

	var data = dataset.getData();
	actionData.data = data;

	if (workingCopy) {
		actionData.data.$actions = {};
		actionData.data.$actions[$actionName] = {
			$isRequested: true
		};
		actionData.$url = dataset.getUrl();
		actionData.$method = "PUT";

		if ($action.$parameters) {
			var act = actionData.data.$actions[$actionName];
			act.$parameters = {};
			Object.keys($action.$parameters).forEach(function(param) {
				act.$parameters[param] = dataset.resolveExpression($action.$parameters[param]);
			});
		}
	} else {
		var facet = dataset.getFacet();
		var $url = dataset.getUrl(true);

		// Save is a special case in stateless mode since it's managed by CRUD
		if ($actionName === "$save") {

			if (facet === "$create") {
				$url = _removeKeyFromUrl($url);
				actionData.$method = "POST"; // create
			} else {
				actionData.$method = "PUT"; // update
			}
			actionData.$url = $url;
		} else if ($actionName === "$abort") {
			return null;
		} else {

			$url = $url.replace("?", "/$services/" + $actionName + "?");
			$url = $url.replace("/sdata/", "/mobile2/");

			if (facet === "$create") {
				// Remove key if triggering action on $create facet since there is no record yet
				$url = _removeKeyFromUrl($url);
				actionData.$method = "PUT";
			} else {
				actionData.$method = "POST";
			}
			actionData.$url = $url;
		}
	}
	return actionData;
};

/**
 * Uses the server response to compute if an action was successful or not
 * 
 * Return:
 * {
 * 	   succeeded: true | false // Is the payload received a success or error response?
 *     $diagnose: { // Top level result message to show, can be null
 *         $severity: "error" | "success"
 *         $message: "..."
 *     }
 *     
 * }
 */
exports.computeActionResult = function($actionName, response) {
	var data = response.data;
	var result = {
		success: false
	};

	var actionDiags = (data && data.$actions && data.$actions[$actionName] && data.$actions[$actionName].$diagnoses) || [];
	if (actionDiags.some(
			function(diag) {
				if (diag.$severity === "success") {
					result.$diagnose = diag;
					return true;
				}
			})) { // If there is a single success diagnose on the action, we asume all is ok
		result.success = true;
		return result;
	}

	// If we end here, there is a top level message with an error
	if (actionDiags.length > 0) {
		result.$diagnose = actionDiags[0];
		result.success = false;
		return result;
	}

	// No information on header level, so scan fields for $diagnoses
	if (exports.hasFieldLevelErrors(data)) {
		result.$diagnose = {
			$severity: "error",
			$message: "Error on field level" // TODO: NLS
		};
		result.success = false;
		return result;
	}

	result.$diagnose = {
		$severity: "success",
		$message: "All fine" // TODO: NLS
	};
	result.success = true;
	return result;
}

/**
 * Scan the given data for any nodes with $diagnoses array containing an error
 * Will stop on the first match to be efficient
 * 
 */
exports.hasFieldLevelErrors = function(data) {
	function scanNode(node) {
		if (!node) {
			return false;
		}
		var errors;
		if (node.$diagnoses && Object.prototype.toString.call(node.$diagnoses) === "[object Array]") {
			errors = node.$diagnoses.some(function(diag) {
				return diag.$severity === "error";
			});
			if (errors) {
				return true;
			}
		}

		switch (Object.prototype.toString.call(node)) {
			case "[object Object]":
				errors = Object.keys(node).some(function(key) {
					return scanNode(node[key]);
				});
				if (errors) {
					return true;
				}
				break;

			case "[object Array]":
				errors = node.some(function(item) {
					return scanNode(item);
				});
				if (errors) {
					return true;
				}
				break;
		}

		return false;
	}
	return scanNode(data);
}

/*
 * 
 */
function _removeKeyFromUrl(url) {
	return url.replace(/(\/\w+)(\(\S+\))(\/\$services|\?)/, "$1$3");
}

exports.checkTransform = function($url, prototypeJson, datasetJson, articleJson) {
	var parsed = jsutils.parseURL($url);

	var $mobileProtocol = (parsed.query && parsed.query.$mobileProtocol) === "workingcopy" ? "workingcopy" : "stateless";
	var $mobileEndpoint = parsed.query && parsed.query.$mobileEndpoint;
	var $mobileApplication = parsed.query && parsed.query.$mobileApplication;

	datasetJson.$clientContext = {
		$mobileProtocol: $mobileProtocol,
		$mobileEndpoint: $mobileEndpoint,
		$mobileApplication: $mobileApplication
	};

	if (prototypeJson.$representation === "mobileApplication") {
		var $savedCtx = datasetJson.$clientContext;
		$savedCtx.$mobileProtocol = (datasetJson.onlineOnly === true ? "workingcopy" : "stateless");
		$savedCtx.$mobileApplication = datasetJson.applicationName;

		// A mobile applications json embeds all data required to render it's home dashboard
		// so we just need to extract it here
		prototypeJson = prototypeJson.$mobileDashboardProto;
		datasetJson = datasetJson.$homeDashboard;
		articleJson = articleJson.$dashboardArticle;

		datasetJson.$clientContext = $savedCtx;
	}

	if (prototypeJson.$representation === "mobileDashboard") {

		var transformed = _transformDashboard(datasetJson, prototypeJson, articleJson);
		datasetJson = transformed.datasetJson;
		prototypeJson = transformed.prototypeJson;
		articleJson = transformed.articleJson;
	}

	var result = {
		prototypeJson: prototypeJson,
		datasetJson: datasetJson,
		articleJson: articleJson
	};

	return result;
}

/**
 * Transform the prototype and data of an mobile dashboard entity instance to something that 
 * passes through the standard widget creation process:
 * - The list of vignettes is transformed to a property per vignette because
 *   the article binds to the id (persistenId) of the vignette 
 */
function _transformDashboard(datasetJson, prototypeJson, articleJson) {
	var proto = $.extend(true, {}, prototypeJson);
	var data = $.extend(true, {}, datasetJson);
	// Dashboard entity properties potentially used (title/descr)
	proto.$properties = {};
	["dashboardName", "title", "description"].forEach(function(p) {
		proto.$properties[p] = prototypeJson.$properties[p]
	})

	proto.$title = datasetJson.title;

	delete data.vignettes; // List will be replaced by concrete properties
	delete data.$properties;

	var defaultArticle = {
		"$layoutType": "stack",
		"$items": []
	}

	for (var i = 0, j = datasetJson.vignettes.length; i < j; i++) {
		var vignette = datasetJson.vignettes[i];
		var vid = vignette.persistentId;

		var gadget = datasetJson.$mobileGadgets[vignette.gadget.$uuid];
		if (!gadget) {
			throw new Error("Gadget not found " + vignette.gadget.$uuid)
		}
		gadget.$clientContext = datasetJson.$clientContext;

		var prop = proto.$properties[vid] = {
			$item: gadget
		};
		if (vignette.displayStyle === "$full") {
			prop.$type = "application/x-vignette";
		} else {
			prop.$type = "application/x-vignette-link";
		}

		prop.$title = prop.$item.$title;

		data[vid] = vignette.gadget.$uuid;
		defaultArticle.$items.push({
			$bind: vid
		});
	}

	return {
		datasetJson: data,
		prototypeJson: proto,
		articleJson: articleJson || defaultArticle
	}
}

/**
 * Convert a working copy url to a stateless one
 * 
 * Urls containing $forceProtocol=true will not be changed
 * Like this it's possible to have a client side stateless app opening a working copy mode representation
 */
exports.adjustLinkProtocol = function($link, $mobileProtocol) {
	if ($mobileProtocol !== "workingcopy" && $link.$url.indexOf("$forceProtocol=true") < 0) {
		$link = $.extend(true, {}, $link);
		if ($link.$method !== "DELETE" && $link.$url.indexOf("$services") < 0) {
			$link.$method = "GET";
		}
		if ($link.$url.indexOf("/$workingCopies?") > -1) {
			// switch to stateless
			$link.$url = $link.$url.replace("/$workingCopies?", "?");
		}
	}

	return $link;
}

exports.addClientContext = function($url, $clientContext) {
	var result = $url;
	for (var prop in $clientContext) {
		if (result.indexOf(prop + "=") < 0) {
			if ($clientContext[prop]) {
				var delim = result.indexOf("?") > -1 ? "&" : "?";
				result = result + delim + prop + "=" + encodeURIComponent($clientContext[prop]);
			}
		}
	}
	return result;
}