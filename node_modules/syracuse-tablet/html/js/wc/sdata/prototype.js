"use strict";

var utils = require('syracuse-tablet/html/js/wc/helpers/utils');
var helpers = require('syracuse-tablet/html/js/wc/common/helpers');

var Prototype = utils.defineClass(
	function Prototype(json, parent) {
		this.json = json;
		this.parent = parent;
		this.root = (parent && parent.root) || this;
		this._initRefFields();
	},
	null, {
		propExists: function($bind) {
			return (this.json.$properties && this.json.$properties[$bind]) != null;
		},
		propGetType: function($bind) {
			if (!this.propExists($bind)) {
				return null;
			}
			return this.json.$properties[$bind].$type;
		},
		propGetFormat: function($bind) {
			if (!this.propExists($bind)) {
				return null;
			}
			return this.json.$properties[$bind].$format;
		},
		propGetProto: function($bind) {
			if (!this.propExists($bind)) {
				return null;
			}
			return new Prototype(this.json.$properties[$bind], this);
		},
		propGetProtoItem: function($bind) {
			var $item;
			if (!this.propExists($bind)) {
				// If this is a proto array
				$item = this.json.$item;
			} else {
				$item = this.json.$properties[$bind].$item
			}
			if (!$item) return null;
			return new Prototype($item, this);
		},
		getProto$Item: function($bind) {
			return new Prototype(this.json.$item, this);
		},
		propIsSimple: function($bind) {
			if (!this.propExists($bind)) {
				return null;
			}
			return !this.propIsArray($bind) && !this.propIsReference($bind) && !this.propIsImage($bind) && !this.propIsText($bind);
		},
		propIsText: function($bind) {
			var t = this.propGetType($bind);
			return t && t.split("/")[0] == "text"
		},
		propIsImage: function($bind) {
			return this.propGetType($bind) === "image";
		},
		propIsArray: function($bind) {
			return this.propGetType($bind) === "application/x-array";
		},
		propIsSingleArray: function($bind) {
			if (!this.propExists($bind) || !this.propIsArray($bind)) {
				return false;
			}
			/* 
			 * Simple array is identified by either the dedicated type application/x-reference or
			 * any other type that does not supply a $properties list (like integer, decimal, ...)
			 * 
			 * Complex (mulit column arrays) are of type application/json
			 */

			var isSimple = (!this.json.$properties[$bind].$item.$properties || this.json.$properties[$bind].$item.$type === "application/x-reference") ? true : false;
			return isSimple;
		},
		/**
		 * Is $bind an x-reference field?
		 */
		propIsReference: function($bind) {
			return this.propGetType($bind) === "application/x-reference";
		},
		isReference: function() {
			return this.json.$type === "application/x-reference";
		},
		/**
		 * true if the given property is used to back up a reference field, 
		 * E.g. CUR_REF is backed up by CUR so will return true for CUR
		 */
		propIsRefValue: function($bind) {
			if (!this.propExists($bind)) {
				return false;
			}
			return (this.json.$properties[$bind].$item && this.json.$properties[$bind].$item.$refPropertyName) != null ? true : false;
		},
		/**
		 * get name of x-reference type property linked to this simple $bind property
		 * Will return "CUR_REF" of type application/x-reference for $bind="CUR" which is type of x-string 
		 */
		propGetRefProperty: function($bind) {
			if (!this.propExists($bind)) {
				return null;
			}
			return this.json.$properties[$bind].$item.$refPropertyName;
		},
		/**
		 * Returns the name of the field that contains the value ($refValue)
		 */
		propGetRefValueName: function($bind) {
			if (!this.propExists($bind)) {
				return null;
			}
			return this.json.$properties[$bind].$item.$refValueName;
		},
		/**
		 * isUrl: Is the repression an url? If yes, expressions like abc={xxx} will be abc=<uri encode xxx>
		 * extraData: Key + value to check for matches first (E.g. $parameters when resolving link urls) 
		 */
		resolveExpression: function(exp, isUrl, extraData) {
			var self = this;
			var rescan = true;
			var max = 20;
			if (exp == null) {
				return exp;
			}
			while (rescan && ((max--) > 0) && exp.replace) {
				rescan = false;
				exp = exp.replace(/\{(\S+?)\}/g, function(m, g1, idx) {
					var value;
					// Encode if we resolve an url that contains something like EXTRA_CODE={EXTRA_CODE} ?
					var encode = isUrl && idx > 0 && exp.charAt(idx - 1) === "=";
					if (extraData && g1 in extraData) {
						value = extraData[g1];
						if (value && value.indexOf && value.indexOf("{") === 0) {
							rescan = true;
						} else if (encode) {
							value = encodeURIComponent(value);
						}
					} else if (g1 in self.json) {
						value = self.json[g1];
						if (value && value.indexOf && value.indexOf("{") === 0) {
							rescan = true;
						} else if (encode) {
							value = encodeURIComponent(value);
						}
					} else if (self.root != self && g1 in self.root.json) {
						value = self.root.json[g1];
						if (value && value.indexOf && value.indexOf("{") === 0) {
							rescan = true;
						} else if (encode) {
							value = encodeURIComponent(value);
						}
					} else if (g1.charAt(0) === "@") {
						// Check on root level for localized texts
						value = (self.root.json.$localization && self.root.json.$localization[g1]) || m;
					} else {
						value = m;
					}
					return value;
				});
			}

			return exp;
		},
		/*
		 * Precompute some additional lookup data for reference fields to be faster during setting/getting values
		 */
		_initRefFields: function() {
			var props = this.json.$properties;
			if (!props) return;
			for (var p in props) {
				if (this.propIsReference(p)) {
					this._initRefField(p);
				}
			}
		},

		/*
		 * Pre-compute the name of the property containing the value of the reference field
		 * Will add some props to $item of reference field prototypes:
		 * 
		 * $refValueName: Name of sibling property containing the reference field key value
		 * $lookupKeyName: Name of the key field in lookup representation
		 * 
		 * Will also add $refPropertyName to the simple property used to back up the reference field
		 */
		_initRefField: function($bind) {
			var proto = this.json.$properties[$bind];
			var $item = proto.$item;
			if (!$item) return;

			$item.$refValueName = $item.$lookupKeyName = $bind;
			if ($item.$value && typeof $item.$value == "string") {
				// $item.$value is s.th. like {CUR}
				var vals = /{([^}]+)}/g.exec($item.$value);
				if (vals && vals.length == 2) {
					var $lookupKeyName = vals[1]; // Key of referenced item (e.g. CODE or CUR, ...)

					$item.$lookupKeyName = $lookupKeyName;

					if ($item[$lookupKeyName]) {
						var $refValueName = $item[$lookupKeyName].replace(/[{}]/g, "").trim();
						if (this.propExists($refValueName) || $item.$properties && $item.$properties[$refValueName]) {
							$item.$refValueName = $refValueName;
						}
					}
					if (!$item.$refValueName) {
						$item.$refValueName = $lookupKeyName;
					}
				} else {
					// Composed key in ref field!
					// TODO: Error?
				}
			}
			if ($item.$refValueName && this.propExists($item.$refValueName)) {
				$item.$refValueType = this.propGetType($item.$refValueName);

				this.json.$properties[$item.$refValueName].$item = this.json.$properties[$item.$refValueName].$item || {};
				// Also link simple type property to $bind reference type property
				this.json.$properties[$item.$refValueName].$item.$refPropertyName = $bind;
			}
			// TODO: precompute auto lookup?
		},
		getFacet: function() {
			var facet = /\.(\$\w+)/.exec(this.json.$type);
			facet = facet && facet.length > 1 && facet[1];
			return facet;
		},
		getType: function() {
			return this.json.$type;
		},
		getValueByPath: function(path, resolve, isUrl, extraData) {
			var val = helpers.getValueByPath(this.json, path);
			if (val != null && resolve) {
				val = this.resolveExpression(val, isUrl, extraData);
			}
			return val;
		},

		/**
		 * Check $type of the value of field $bind
		 * Will use parent prototype if called on the fields sub-prototype
		 */
		getFieldValueType: function($bind) {
			var $properties = this.json.$properties || (this.parent && this.parent.json.$properties);
			if (!$properties) {
				return;
			}
			var prop = $properties[$bind];

			var $type = prop && prop.$type ? prop.$type : "application/x-string";
			if ($type === "application/x-quantity") {
				if (prop.$value) {
					$type = prop.$value.$type;
				}
				$type = $type || "application/x-integer";
			} else if ($type === "application/x-reference") {
				if (prop.$item) {
					$type = prop.$item.$refValueType;
				}
				$type = $type || "application/x-string";
			}
			return $type;
		},
		/**
		 * Get name of simple type field backing up the reference field named by $bind
		 */
		getFieldValueName: function($bind) {
			if (this.propIsReference($bind)) {
				return this.propGetRefValueName($bind);
			}
			return $bind;
		},
		/*for exemple : url to save text*/
		getFieldUpdateUrl: function($bind) {
			var $properties = this.json.$properties || (this.parent && this.parent.json.$properties);
			if (!$properties) {
				return;
			}
			var prop = $properties[$bind];
			return prop.$url;
		},
		destroy: function() {
			this.root = null;
			this.parent = null;
			this.json = null;
		},
		createNew: function(json) {
			return new Prototype(json, this);
		},
		/**
		 * Calculates the prototype and other info for unit field
		 */
		getUnitFieldInfo: function() {
			var self = this;
			var res = {};
			res.$unit = self.json["$unit"];
			if (typeof res.$unit == "object") {
				res.unitBindName = "$unit";
				res.unitFieldProto = self.createNew($.extend({}, self.$unit));
			} else if (typeof res.$unit == "string") {
				res.unitBindName = res.$unit;
				var parent = self.parent;
				while (parent) {
					var unitProto = parent.json.$properties[res.$unit];
					if (unitProto) {
						res.unitFieldProto = self.createNew($.extend({}, unitProto));
						break;
					}
					parent = parent.parent;
				}
			}
			return res;
		},
		clone: function() {
			var json = $.extend(true, {}, this.json);
			return new Prototype(json, this.parent);
		},
		/**
		 * return true if aguments contain the facet
		 * Ex: 	isFacet("edit, "detail") return true if edit OR detail
		 * 		isFacet("detail") return true if detail
		 */
		isFacet: function() {
			return Array.prototype.indexOf.call(arguments, this.getFacet()) >= 0;
		},
		/**
		 * Stats prototype
		 */
		isCube: function() {
			return this.isFacet("$cube");
		},
		/**
		 * Query prototype
		 */
		isQuery: function() {
			return this.isFacet("$query");
		},
		isWorkingCopyFacet: function() {
			return this.isFacet("$edit") || this.isFacet("$create");
		},
		/**
		 * Lookup prototype
		 */
		isLookup: function() {
			return this.isFacet("$lookup");
		},
		isRequest: function() {
			return this.json.codeRequest != null && this.json.codeRequest.length > 0;
		},
		isQueryLikeFacet: function() {
			return this.isQuery() || this.isLookup() || this.isCube() || this.isRequest();
		},
		filterSortAllowed: function() {
			return this.isLookup() || this.isQuery();
		},
		/**
		 * returns json[prop]
		 * 	ignoreParent: true -> Don't read property in parent
		 */
		data: function(prop, dataContext, ignoreParent, noResolve) {
			if (!prop || prop.length == 0) return null;
			var val = this.json[prop];
			if (val == null) {
				if (ignoreParent == null) {
					if (["$title", "$description"].indexOf(prop) > -1) {
						ignoreParent = true;
					}
				}
				var pVal = ignoreParent !== true && this.parent ? this.parent.data(prop, dataContext, null, true) : val;
				if (pVal != null) {
					this.json[prop] = pVal;
				}
				return pVal;
			}
			if (noResolve) {
				return val;
			}
			// #5793 we resolve with searchInParents = true -> expression variable will be searched in dataContext and parent
			return this.resolveExpression(val, false, dataContext);
		},
		hasCapability: function(cap) {
			return (this.json.$capabilities && this.json.$capabilities.indexOf(cap) > -1) || false;
		},

		getPropertyNames: function() {
			return this.json.$properties ? Object.keys(this.json.$properties) : [];
		},
		getPropertyData: function(name, prop) {
			if (!name || name.length === 0) return null;
			var o = this.json.$properties && this.json.$properties[name];
			if (!o || !prop) return o;
			return this.resolveExpression(o[prop]);
		},
	}
);

exports.Prototype = Prototype;