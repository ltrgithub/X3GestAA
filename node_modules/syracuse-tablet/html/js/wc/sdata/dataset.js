"use strict";

var utils = require('syracuse-tablet/html/js/wc/helpers/utils');
var helpers = require('syracuse-tablet/html/js/wc/common/helpers');

// Keys on meta data of links and actions that will be checked for changes to notify the controller
var _linksAndActionsMetaKeys = ["$isHidden", "$isDisabled"];

var _checkQueryFullPage = function(prototype, $linkName) {
	if ($linkName !== "$queryfullpage") {
		return null;
	}
	// Query facet in full page
	if (!prototype.root || !prototype.root.isFacet("$query")) {
		throw new Error("$query facte expected for $queryfullpage link");
	}
	return {
		"$title": "$queryfullpage",
		"$target": "",
		"$type": "application/json;vnd.sage=syracuse",
		"$method": "GET",
		"$url": prototype.root.data("$url")
	}
}

/**
 * General dataset class, used for root level of objects right now
 */
var Dataset = utils.defineClass(
	function Dataset(json, prototype, parent, $bind) {
		this.json = json;
		this.prototype = prototype;
		this.parent = parent;
		this.$bind = $bind; // Name of property in parent if this dataset is a child dataset (e.g. array)
		this.root = (parent && parent.root) || this;

		this.dirtyProperties = [];
		this.childDatasets = {};
		this.deltaChangeListeners = [];
	},
	null, {
		/**
		 * Get value of property $bind
		 * 
		 * useWorkingCopy: Set to true if working copy mode is used or false if stateless is used
		 *                 This will only affect the kind of urls returned for imags and texts
		 * 
		 * Note: 
		 * For reference fields, the returned value is
		 * null or 
		 * {
		 *   $value: ... // value of "key" property of referenced entity e.g. EUR for x-ref on currency
		 *   $title: ... // optional if set by server
		 *   $description: ... // optional if set by server
		 * }
		 */
		getValue: function($bind, useWorkingCopy) {
			if ($bind.charAt(0) === "$" && !this.prototype.propExists($bind)) {
				// $-properties like $url etc
				return this.json[$bind];
			} else if (this.prototype.propIsSimple($bind)) {
				return this.json[$bind];
			} else if (this.prototype.propIsReference($bind)) {
				return this._getValueReference($bind);
			} else if (this.prototype.propIsImage($bind)) {
				return this._getValueImage($bind, useWorkingCopy);
			} else if (this.prototype.propIsText($bind)) {
				return this._getValueText($bind, useWorkingCopy);
			} else if (this.prototype.propIsDocument($bind) || this.prototype.propIsBinary($bind)) {
				return this._getValueDocument($bind, useWorkingCopy);
			} else if (this.prototype.propIsArray($bind)) {
				throw new Error("Use getChild to access arrays");
			}
		},
		/**
		 * Set value of property $bind
		 * 
		 */
		setValue: function($bind, value) {
			if (this.prototype.propIsSimple($bind)) {
				var oldValue = this.json[$bind];
				if (oldValue !== value) {
					this.json[$bind] = value;
					this.setDirty($bind);
				}
			} else if (this.prototype.propIsImage($bind)) {
				var oldValue = this.json[$bind];
				this.json[$bind] = value;
				this.setDirty($bind);
			} else if (this.prototype.propIsText($bind)) {
				var oldValue = (typeof this.json[$bind] !== "string") ? value : this.json[$bind];
				this.json[$bind] = value;
				if (oldValue !== value) {
					this.json[$bind] = value;
					this.setDirty($bind);
				}
			} else if (this.prototype.propIsReference($bind)) {
				this._setValueReference($bind, value);
			} else if (this.prototype.propIsArray($bind)) {
				throw new Error("Use getChild to access arrays");
			}
		},
		/*
		 * Get value of reference field, used by getValue
		 * Can be either
		 * null if value of referenced field is null
		 * or
		 * {
		 *   $value: xxx value of reference field
		 *   $title: ...
		 *   $description: ...
		 * }
		 */
		_getValueReference: function($bind) {
			var value = this.json[$bind];
			var $refValueName = this.prototype.propGetRefValueName($bind);
			var $value = this.json[$refValueName];
			if ($value == null) {
				return null;
			}
			value = value || {};
			value.$value = $value;
			return value;
		},
		_getValueImage: function($bind, useWorkingCopy) {
			if (this.json[$bind]) {
				var prop = "$url";
				// Currently, useWorkingCopy is always != true for images
				// this is wrong since we should use the WC url
				if (useWorkingCopy !== true && this.prototype.root.isWorkingCopyFacet()) {
					prop = "$urlStateless"
				}
				var fieldProto = this.prototype.propGetProto($bind);
				var imageUrl = (fieldProto.getValueByPath(prop) || "");
				return this.resolveExpression(imageUrl, true) + '?salt=' + ((new Date()).getTime());
			} else {
				return null
			}
		},
		_getValueText: function($bind, useWorkingCopy) {
			var prop = "$url";
			if (useWorkingCopy !== true && this.prototype.root.isWorkingCopyFacet()) {
				prop = "$urlStateless"
			}
			var fieldProto = this.prototype.propGetProto($bind);
			var textUrl = (fieldProto.getValueByPath(prop) || "");
			return this.resolveExpression(textUrl, true);
		},
		_getValueDocument: function($bind, useWorkingCopy) {
			if (this.json[$bind] == null) { // no value means no data
				return null;
			}
			var prop = "$url";
			if (useWorkingCopy !== true && this.prototype.root.isWorkingCopyFacet()) {
				prop = "$urlStateless"
			}
			var fieldProto = this.prototype.propGetProto($bind);
			var textUrl = (fieldProto.getValueByPath(prop) || "");
			return this.resolveExpression(textUrl, true);
		},
		/*
		 * Set value of reference field
		 * Currently, value must be a simple type containing the key of the referenced entity
		 */
		_setValueReference: function($bind, value) {
			var $refValueName = this.prototype.propGetRefValueName($bind);
			var oldValue = this.json[$refValueName];
			if (oldValue !== value) {
				this.json[$bind] = {}; // WCUR_REF: x-reference
				this.json[$refValueName] = value; // WCUR: x-string

				this.setDirty($bind);
				this.setDirty($refValueName);
			}
		},
		/**
		 * 
		 * Return child dataset for property $bind
		 * $bind must be an array property
		 */
		getChild: function($bind) {
			var child = this.childDatasets[$bind];
			if (!child) {
				if (this.prototype.propIsArray($bind)) {
					var data = this.json[$bind];
					if (!data) {
						data = this.json[$bind] = [];
					}
					if (!this.prototype.propIsSingleArray($bind)) {
						// Normal multi column array
						var proto = this.prototype.propGetProto($bind);
						child = new MultiArrayDataset(data, proto, this, $bind);
					} else {
						// Single column array
						var proto = this.prototype.propGetProto($bind);
						child = new SingleArrayDataset(data, proto, this, $bind);
					}
					this.childDatasets[$bind] = child;
				}
			}
			return child;
		},
		/**
		 * Set a named property ($bind) to dirty
		 * $bind can be the $uuid of a row of an array too
		 * 
		 * setDirty will report the dirty flag to the parent, so if a child is dirty asking root.isDirty will return true
		 */
		setDirty: function($bind) {
			if (this.dirtyProperties && this.dirtyProperties.indexOf($bind) < 0) {
				this.dirtyProperties.push($bind);
			}
			if (this.parent) {
				this.parent.setDirty(this.$bind);
			}
		},
		/**
		 * Check if dataset is dirty
		 * $bind (optional): If $bind is given, only check if property $bind is dirty
		 */
		isDirty: function($bind) {
			if ($bind != null) {
				return (this.dirtyProperties && this.dirtyProperties.length > 0 && this.dirtyProperties.indexOf($bind) > -1) || false;
			}
			return (this.dirtyProperties && this.dirtyProperties.length > 0) || false;
		},
		/**
		 * Mark dataset as clean (remove all dirty flags)
		 * $bind (optional): If $bind is given, only clean this property
		 * 
		 * includeChildren (optional): If false, to not include children, should only be used internally to avoid infinite child<->parent calls
		 */
		setClean: function($bind, includeChildren) {
			includeChildren = includeChildren == null ? true : false;
			if ($bind != null) {
				var idx = this.dirtyProperties.indexOf($bind);
				if (idx >= 0) {
					this.dirtyProperties.splice(idx, 1);
					if (includeChildren && this.childDatasets[$bind]) {
						this.childDatasets[$bind].setClean();
					}
				}
				// For reference fields, clean related field dirty flag too
				// We check if prop exists first since it's not always the case
				// E.g. a row dataset has a $bind uuid which is not contained in it's prototype
				if (this.prototype.propExists($bind) && this.prototype.propIsReference($bind)) {
					this.setClean(this.prototype.propGetRefValueName($bind));
				}
			} else {
				this.dirtyProperties = [];
				if (includeChildren) {
					for (var childName in this.childDatasets) {
						var child = this.childDatasets[childName];
						child.setClean();
					}
				}
			}
			// Check if all is clean, report to parent if yes
			if (this.parent && this.dirtyProperties.length < 1) {
				this.parent.setClean(this.$bind, false);
			}
		},
		/**
		 * 
		 * @param $bind
		 * @returns
		 */
		getDiagnoses: function($bind) {
			var diags = this.getValueByPath("$properties." + $bind + ".$diagnoses");

			if (this.prototype.propExists($bind) && this.prototype.propIsReference($bind)) {
				var $bindValue = this.prototype.propGetRefValueName($bind);
				var valueFieldDiags = this.getValueByPath("$properties." + $bindValue + ".$diagnoses");
				diags = diags || [];
				Array.prototype.push.apply(diags, valueFieldDiags);
			}
			return diags || [];
		},
		/**
		 * Gets the current JSON data represented by this dataset
		 * Used for stateless mode
		 */
		getData: function() {
			/*
			 * return this.json;
			 * will not work because the internal data structures change for simple property arrays (wrapped with object on read)
			 */
			var data = {};
			var props = Object.keys(this.json);
			for (var i = 0; i < props.length; i++) {
				var $bind = props[i];
				var childDataset = this.childDatasets[$bind];
				if (childDataset) {
					// If there is a child dataset for the property, let it handle to create the data
					data[$bind] = childDataset.getData();
				} else if (this.prototype.propIsSingleArray($bind)) {
					childDataset = this.getChild($bind);
					data[$bind] = childDataset.getData();
				} else {
					data[$bind] = this.json[$bind];
				}
			}
			return data;
		},
		/**
		 * Gets all the JSON data including only properties that are dirty, including children
		 * Used for working copy mode
		 */
		getDataDelta: function() {
			var delta = {
				$uuid: this.json.$uuid,
			};

			if (this.isRoot()) {
				delta.$url = this.getUrl();
				delta.$etag = this.json.$etag;
			}

			var i;
			for (i = 0; i < this.dirtyProperties.length; i++) {
				var $bind = this.dirtyProperties[i];
				if (this.childDatasets[$bind]) { //  Array or something complex?
					delta[$bind] = this.childDatasets[$bind].getDataDelta();
				} else {
					delta[$bind] = this.json[$bind];
				}
			}

			return delta;
		},
		/*Get data for text content upload :  protocol is not like other datas
		 */
		getDataText: function($bind) {
			var delta;
			var i;
			for (i = 0; i < this.dirtyProperties.length; i++) {
				var $bindDirty = this.dirtyProperties[i];
				if ($bindDirty === $bind) {
					delta = this.json[$bind]
				}
			}

			return delta;
		},
		/**
		 * Resolve expressionen on dataset and datasets prototype
		 * isUrl: Is the repression an url? If yes, expressions like abc={xxx} will be abc=<uri encode xxx>
		 * extraData: Key + value to check for matches first (E.g. $parameters when resolving link urls) 
		 */
		resolveExpression: function(exp, isUrl, extraData) {
			var self = this;
			var rescan = true;
			var max = 20;
			if (exp == null) {
				return exp;
			}
			while (rescan && ((max--) > 0) && exp.replace) {
				rescan = false;
				exp = exp.replace(/\{(\S+?)\}/g, function(m, g1, idx) {
					var value;
					// Encode if we resolve an url that contains something like EXTRA_CODE={EXTRA_CODE} ?
					var encode = isUrl && idx > 0 && exp.charAt(idx - 1) === "=";
					if (extraData && g1 in extraData) {
						value = extraData[g1];
						if (value && value.indexOf && value.indexOf("{") === 0) {
							rescan = true;
						} else if (encode) {
							value = encodeURIComponent(value);
						}
					} else if (g1 in self.json) {
						value = self.json[g1];
						if (value && value.indexOf && value.indexOf("{") === 0) {
							rescan = true;
						} else if (encode) {
							value = encodeURIComponent(value);
						}
					} else if (self.root != self && g1 in self.root.json) {
						value = self.root.json[g1];
						if (value && value.indexOf && value.indexOf("{") === 0) {
							rescan = true;
						} else if (encode) {
							value = encodeURIComponent(value);
						}
					} else {
						value = self.prototype.resolveExpression(m);
						rescan = rescan || (value != m && value && value.indexOf && value.indexOf("{") >= 0);
					}
					return value;
				});
			}
			return exp;
		},
		/**
		 * Computes Url of current resource by using $url of payload
		 * 
		 * useProtoype$Url: When NOT true, use $url of dataset or prototype for fallback if not contained in dataset
		 * 					When true: Use $url of prototype (this is the stateless URL for the resource)
		 *
		 * return:
		 * dataset based url
		 * http://localhost:8124/sdata/x3/erp/GX3APP/$workingCopies('6958bd2f-6bb4-46e0-bed7-0c4cc2692e30')?representation=AQMCRUDM.$edit
		 * prototype based url
		 * http://localhost:8124/sdata/x3/erp/GX3APP/AQMDEVICE('8')?representation=AQMCRUDM.$edit
		 * param $bind need only for text content upload, put url come from $url or the property $bind
		 */
		getUrl: function(useProtoype$Url, $bind) {
			var url;
			if ($bind) {
				url = this.prototype.getFieldUpdateUrl($bind);
			}
			if (useProtoype$Url !== true) {
				return this.resolveExpression(url || this.json.$url || this.prototype.json.$url);
			} else {
				return this.resolveExpression(url || this.prototype.json.$url);
			}
		},
		getFacet: function() {
			if (this.isRoot()) {
				return this.prototype.getFacet();
			}
		},
		/**
		 * 
		 */
		getAction: function($actionName) {
			var actionP = this.prototype.getValueByPath("$actions." + $actionName); // Must not be null in proto
			var actionD = this.getValueByPath("$actions." + $actionName) || {}; // Could be null in payload
			if (!actionP) {
				return;
			}
			var action = $.extend(true, {}, actionP, actionD);
			return action;
		},
		getActions: function() {
			var actionsP = this.prototype.getValueByPath("$actions");
			if (!actionsP) {
				return;
			}
			var actions = {};
			for (var actionName in actionsP) {
				actions[actionName] = this.getAction(actionName);
			}
			return actions;
		},
		getLink: function($linkName, $bind) {
			var link = _checkQueryFullPage(this.prototype, $linkName);
			if (link) {
				return link;
			}
			var path = $bind ? "$properties." + $bind + ".$item.$links." + $linkName : "$links." + $linkName;
			var linkP = this.prototype.getValueByPath(path);
			var linkD = this.getValueByPath(path);

			if (!linkP && !linkD) {
				return;
			}
			link = $.extend(true, {}, linkP, linkD);
			if (link.$url && /\{(\S+?)\}/.test(link.$url)) {
				link.$url = this.resolveExpression(link.$url)
			}
			return link;
		},
		getLinks: function($bind) {
			var self = this;
			var path = $bind ? "$properties." + $bind + ".$item.$links" : "$links";
			var linksP = this.prototype.getValueByPath(path);
			var linksNames = [];
			if (linksP) {
				for (var linkName in linksP) {
					linksNames.push(linkName);
				}
			}
			var linksD = this.getValueByPath(path);
			if (linksD) {
				for (var linkName in linksD) {
					linksNames.push(linkName);
				}
			}
			var links = {};
			linksNames.forEach(function(linkName) {
				links[linkName] = self.getLink(linkName, $bind);
			});
			return links;
		},
		/** 
		 * Is this a root dataset (e.g. page level)
		 */
		isRoot: function() {
			return this != null && this == this.root;
		},
		getRoot: function() {
			return this.root;
		},
		getMetaData: function($bind) {
			var protoMeta = this.prototype.getValueByPath("$properties." + $bind);
			var dataMeta = this.getValueByPath("$properties." + $bind);
			var meta = $.extend(true, {}, protoMeta, dataMeta);
			return meta;
		},
		/**
		 * Apply delta comming from server if we are in working copy mode
		 * 
		 */
		applyDelta: function(delta) {
			var i;
			/*
			 *  We collect all modified fields and fire events at the very end
			 *  since there are properties like CUR_REF and CUR that are linked to each other
			 *  so we need to update all of the first before firing the event
			 */

			var deltaNotifications = {};

			var properties = Object.keys(delta);
			for (var ii = 0, jj = properties.length; ii < jj; ii++) {
				var property = properties[ii];
				var value = delta[property];
				this._deltaSetValue(property, value, deltaNotifications);
			}

			for (var $bind in deltaNotifications) {
				var notify = deltaNotifications[$bind];
				if (notify.$value) {
					this._deltaManValueChanged($bind);
				}
				if (notify.$meta) {
					this._deltaManMetaChanged($bind);
				}
				if (notify.$action) {
					this._deltaManActionChanged($bind, notify.$action);
				}
				if (notify.$link) {
					this._deltaManLinkChanged($bind, notify.$link);
				}
			}
		},
		/*
		 * Invoked by applyDelta to apply delta of a single property
		 * 
		 */
		_deltaSetValue: function($bind, value, deltaNotifications) {
			var i = this.dirtyProperties.indexOf($bind);
			if (i >= 0) {
				this.dirtyProperties.splice(i, 1);
			}
			if ($bind === "$properties") {
				this._deltaSetProperties(value, deltaNotifications);
			} else if ($bind === "$actions") {
				this._deltaSetActions(value, deltaNotifications);
			} else if ($bind === "$links") {
				this._deltaSetLinks(value, deltaNotifications);
			} else if ($bind.charAt(0) === "$") {
				// TODO: Make this correct and recursive including notifications
				this.json[$bind] = value;
			} else {
				if (!this.prototype.propExists($bind)) {
					// Non $ properties that are sent by the server but are not present in the prototype
					// Example is ETag on X3 representations
					// We just add them to the json without taking too much care for now
					this.json[$bind] = value;
				} else if (this.prototype.propIsSimple($bind)) {
					var oldValue = this.json[$bind];
					this.json[$bind] = value;
					if (oldValue !== value) {
						if (this.prototype.propIsRefValue($bind)) {
							// Property used to backup a reference field
							var refField = this.prototype.propGetRefProperty($bind);
							var notify = deltaNotifications[refField] = deltaNotifications[refField] || {};
							notify.$value = true;
						} else {
							// Normal property
							deltaNotifications[$bind] = deltaNotifications[$bind] || {};
							deltaNotifications[$bind].$value = true;
						}
					}
				} else if (this.prototype.propIsReference($bind)) {
					var oldValue = this.json[$bind];
					this.json[$bind] = value;
					var notify = deltaNotifications[$bind] = deltaNotifications[$bind] || {};
					notify.$value = true;
				} else if (this.prototype.propIsArray($bind)) {
					var array = this.getChild($bind);
					array.applyDelta(value);
				}
			}
		},
		/*
		 * Traverse $properties
		 */
		_deltaSetProperties: function(value, deltaNotifications) {
			// For meta data changes, we just notify the keys beneath $properties to allow widgets to repaint
			var properties = Object.keys(value);
			for (var ii = 0, jj = properties.length; ii < jj; ii++) {
				var property = properties[ii];
				this.json.$properties = this.json.$properties || {};
				this.json.$properties[property] = value[property];


				if (this.prototype.propIsRefValue(property)) {
					// Property used to backup a reference field
					var refField = this.prototype.propGetRefProperty(property);
					var notify = deltaNotifications[refField] = deltaNotifications[refField] || {};
					notify.$meta = true;
				} else {
					deltaNotifications[property] = deltaNotifications[property] || {};
					deltaNotifications[property].$meta = true;
				}
			}
		},
		/*
		 * Check for changes in $actions block
		 */
		_deltaSetActions: function(value, deltaNotifications) {
			var self = this;
			var actions = Object.keys(value);
			for (var ii = 0, jj = actions.length; ii < jj; ii++) {
				var action = actions[ii];
				this.json.$actions = this.json.$actions || {};
				this.json.$actions[action] = this.json.$actions[action] || {};
				var keys = Object.keys(value[action]);

				var changed = false;
				if (keys.some(function(key) {
						if (_linksAndActionsMetaKeys.indexOf(key) > -1 && value[action][key] !== self.json.$actions[action][key]) {
							return true;
						}
					})) {
					changed = true;
				}
				this.json.$actions[action] = $.extend(true, this.json.$actions[action], value[action]);

				if (changed === true) {
					var status = {};
					var $isHidden = this.json.$actions[action].$isHidden;
					if ($isHidden == null) {
						$isHidden = this.prototype.getValueByPath("$actions." + action + ".$isHidden");
					}
					if ($isHidden != null) {
						status.$isHidden = $isHidden;
					}
					var $isDisabled = this.json.$actions[action].$isDisabled;
					if ($isDisabled == null) {
						$isDisabled = this.prototype.getValueByPath("$actions." + action + ".$isDisabled");
					}
					if ($isDisabled != null) {
						status.$isDisabled = $isDisabled;
					}

					deltaNotifications[action] = deltaNotifications[action] || {};
					deltaNotifications[action].$action = status;
				}
			}
		},
		/*
		 * Check for changes in $links block
		 * Currently, only $links on root level are checked
		 * Links on properties (e.g. $lookup) are handled by the property specific meta data change notification
		 */
		_deltaSetLinks: function(value, deltaNotifications) {
			var self = this;
			var links = Object.keys(value);
			for (var ii = 0, jj = links.length; ii < jj; ii++) {
				var link = links[ii];
				this.json.$links = this.json.$links || {};
				this.json.$links[link] = this.json.$links[link] || {};
				var keys = Object.keys(value[link]);

				var changed = false;
				if (keys.some(function(key) {
						if (_linksAndActionsMetaKeys.indexOf(key) > -1 && value[link][key] !== self.json.$links[link][key]) {
							return true;
						}
					})) {
					changed = true;
				}
				this.json.$links[link] = value[link];

				if (changed === true) {
					var status = {};
					var $isHidden = this.json.$links[link].$isHidden;
					if ($isHidden == null) {
						$isHidden = this.prototype.getValueByPath("$links." + link + ".$isHidden");
					}
					if ($isHidden != null) {
						status.$isHidden = $isHidden;
					}
					var $isDisabled = this.json.$links[link].$isDisabled;
					if ($isDisabled == null) {
						$isDisabled = this.prototype.getValueByPath("$links." + link + ".$isDisabled");
					}
					if ($isDisabled != null) {
						status.$isDisabled = $isDisabled;
					}

					deltaNotifications[link] = deltaNotifications[link] || {};
					deltaNotifications[link].$link = status;
				}
			}
		},
		/* 
		 * Invoked by _deltaSetValue when the server sent a modified value for a given property
		 */
		_deltaManValueChanged: function($bind) {
			for (var i = 0; i < this.deltaChangeListeners.length; i++) {
				this.deltaChangeListeners[i].onDeltaValueChanged(this, $bind);
			}
		},
		_deltaManMetaChanged: function($bind) {
			for (var i = 0; i < this.deltaChangeListeners.length; i++) {
				this.deltaChangeListeners[i].onDeltaMetaChanged(this, $bind);
			}
		},
		_deltaManLinkChanged: function($bind, metaData) {
			for (var i = 0; i < this.deltaChangeListeners.length; i++) {
				this.deltaChangeListeners[i].onDeltaLinkChanged(this, $bind, null, metaData);
			}
		},
		_deltaManActionChanged: function($bind, metaData) {
			for (var i = 0; i < this.deltaChangeListeners.length; i++) {
				this.deltaChangeListeners[i].onDeltaActionChanged(this, $bind, metaData);
			}
		},
		getValueByPath: function(path) {
			return helpers.getValueByPath(this.json, path);
		},
		addDeltaChangeListener: function(listener) {
			if (this.deltaChangeListeners.indexOf(listener) < 0) {
				this.deltaChangeListeners.push(listener);
			}
		},
		removeDeltaChangeListener: function(listener) {
			if (!this.deltaChangeListeners) {
				return;
			}
			var idx = this.deltaChangeListeners.indexOf(listener);
			if (idx >= 0) {
				this.deltaChangeListeners.splice(idx, 1);
			}
		},
		destroy: function() {
			if (this.parent && this.parent.childDatasets) {
				delete this.parent.childDatasets[this.$bind];
			}
			this.root = null;
			this.parent = null;
			this.prototype = null;
			this.json = null;
			this.dirtyProperties = null;
			this.deltaChangeListeners = null;

			if (this.childDatasets) {
				var $binds = Object.keys(this.childDatasets);
				for (var i = 0; i < $binds.length; i++) {
					var $bind = $binds[i];
					if (this.childDatasets[$bind]) {
						this.childDatasets[$bind].destroy();
					}
				}
				this.childDatasets = null;
			}
		},

		/**
		 * Compute last update time of this dataset
		 * 
		 * Return: 
		 * {
		 *   dateTime: milliseconds
		 *   level: "verytainted" | "tainted" | "fresh"
		 * }
		 * 
		 */
		getDataFreshness: function() {
			var freshness = {
				dateTime: new Date().getTime(),
				level: "verytainted"
			};

			function _check$ResourcesTime($resources) {
				if (!$resources) {
					return;
				}
				var utcTime = new Date().getTime();
				$resources.forEach(function(item) {
					if (item.$cache) {
						utcTime = Math.min(utils.getTimeFromString(item.$cache.$lastUpdated), utcTime);
					}
				});
				freshness.dateTime = utcTime;
			};

			if (this.isRoot()) {
				if (this.json.$cache) {
					freshness.dateTime = Math.min(freshness.dateTime, utils.getTimeFromString(this.json.$cache.$lastUpdated));
				} else {
					_check$ResourcesTime(this.json.$resources);
				}

				var diffDays = Math.round((new Date().getTime() - freshness.dateTime) / (24 * 60 * 60 * 1000));

				if (diffDays <= 7) freshness.level = "tainted";
				if (diffDays <= 1) freshness.level = "fresh";

				return freshness;
			} else {
				return this.root.getDataFreshness();
			}
		}
	}
);
exports.Dataset = Dataset;

/**
 * Base class for array dataset 
 * Never use directly. Use one of it's subclasses. 
 */
var ArrayDataset = utils.defineClass(
	function ArrayDataset(json, prototype, parent, $bind) {
		Dataset.call(this, json, prototype, parent, $bind);
		this.rowDatasetsByUuid = {};
	},
	Dataset, {

		destroy: function() {
			Dataset.prototype.destroy.call(this);
			if (this.rowDatasetsByUuid) {
				var $uuids = Object.keys(this.rowDatasetsByUuid);
				for (var i = 0; i < $uuids.length; i++) {
					this.removeDatasetByUuid($uuids[i]);
				}
			}
		},

		getChild: function($bind) {
			throw new Error("getChild not supported on ArrayDataset");
		},
		isValidIndex: function($index) {
			return ($index >= 0 && $index < this.getNumRows());
		},
		getNumRows: function() {
			return this.json ? this.json.length : 0;
		},
		/**
		 * Move row with $uuid to $index (0 to numRows-1)
		 * 
		 */
		moveRow: function($uuid, targetIndex) {
			var sourceIndex = this.getRowIndex($uuid);
			if (sourceIndex == null ||
				sourceIndex === targetIndex) {
				return;
			}
			if (!this.isValidIndex(sourceIndex) ||
				!this.isValidIndex(targetIndex)) {
				return;
			}
			var rowToMove = this.json[sourceIndex];
			if (Math.abs(targetIndex - sourceIndex) === 1) {
				this.json[sourceIndex] = this.json[targetIndex];
				this.json[targetIndex] = rowToMove;
			} else {
				this.json.splice(sourceIndex, 1);
				this.json.splice(targetIndex, 0, rowToMove);
			}
			this._setAllRowsDirty();
		},
		/**
		 * Return RowDataset representing the row identified by $index or null of $index is not valid
		 */
		getRowByIndex: function($index) {
			if (!this.isValidIndex($index)) {
				return null;
			}
			var $uuid = this.json[$index].$uuid;
			var row = this.rowDatasetsByUuid[$uuid];
			if (!row) {
				// Note that a row's $bind is the rows $uuid which allows to perfectly identify it later
				row = this.createRowDataset(this.json[$index], this.rowPrototype, $uuid, $index);
			}
			return row;
		},
		/**
		 * Return RowDataset representing the row identified by $uuid or null of $uuid is not valid
		 */
		getRowByUuid: function($uuid) {
			var row = this.rowDatasetsByUuid[$uuid];
			if (!row) {
				var index = this.getRowIndex($uuid);
				if (index != null) {
					row = this.createRowDataset(this.json[index], this.rowPrototype, $uuid, index);
				}
			}
			return row;
		},
		getRowIndex: function($uuid) {
			var self = this;
			var $index = null;
			self.json.some(function(rowData, index) {
				if (rowData.$uuid === $uuid) {
					$index = index;
					return true;
				}
				return false;
			});
			return $index;
		},
		createRowDataset: function(json, prototype, $uuid) {
			// Note that a row's $bind is the rows $uuid which allows to perfectly identify it later
			var row = new RowDataset(json, prototype, this, $uuid);
			this.rowDatasetsByUuid[$uuid] = row;
			return row;
		},
		removeRowDataset: function(dataset) {
			if (dataset && dataset.$bind) {
				this.removeDatasetByUuid(dataset.$bind);
			}
		},
		removeDatasetByUuid: function($uuid) {
			var dataset = this.rowDatasetsByUuid[$uuid];
			if (dataset) {
				dataset.destroy();
			}
			delete this.rowDatasetsByUuid[$uuid];
		},
		/**
		 * Called when a row has been added to an array
		 */
		_deltaManRowAdded: function($uuid, idx) {
			for (var i = 0; i < this.deltaChangeListeners.length; i++) {
				this.deltaChangeListeners[i].onDeltaRowAdded(this, this.$bind, $uuid, idx);
			}
		},
		/**
		 * Called when a row has been removed from an array
		 */
		_deltaManRowRemoved: function($uuid, idx) {
			for (var i = 0; i < this.deltaChangeListeners.length; i++) {
				this.deltaChangeListeners[i].onDeltaRowRemoved(this, this.$bind, $uuid, idx);
			}
		},
		/**
		 * Called when a row has moved to a new index
		 */
		_deltaManRowMoved: function($uuid, newIdx) {
			for (var i = 0; i < this.deltaChangeListeners.length; i++) {
				this.deltaChangeListeners[i].onDeltaRowMoved(this, this.$bind, $uuid, newIdx);
			}
		}
	}
);
exports.ArrayDataset = ArrayDataset;

/**
 * Array dataset wrapping complex arrays having multiple columns
 */
var MultiArrayDataset = utils.defineClass(
	function MultiArrayDataset(json, prototype, parent, $bind) {
		ArrayDataset.call(this, json, prototype, parent, $bind);
		this.rowPrototype = prototype.getProto$Item();
		// Set explicit type for ctrl row
		this.rowPrototype.json.$type = "tablet/x-array-row";
		this.rowsDeleted = {};
	},
	ArrayDataset, {
		/**
		 * Add a new row to the array, returns newly created dataset
		 */
		addRow: function() {
			var $uuid = utils.UUID();
			var rowData = {
				$uuid: $uuid
			};
			this.json.push(rowData);
			this.setDirty($uuid);
			return this.getRowByUuid($uuid);
		},
		removeRow: function($uuid) {
			var idx = this.getRowIndex($uuid);
			if (idx != null) {
				this.json.splice(idx, 1);
			}
			var row = this.getRowByUuid($uuid);
			if (row) {
				this.setDirty($uuid);
				this.rowsDeleted[$uuid] = row;
			}
			this.removeDatasetByUuid($uuid);
			this._setAllRowsDirty();
		},
		getDataDelta: function() {
			var deltaRows = [];
			var i;
			var dirtyRows = this._getOrderedDirtyRows();

			// Could better follow https://github.com/Sage-ERP-X3/platform/wiki/JSON-Delta-Format#deltas-on-lists
			// Currently, delta only (using $index all time) is used no matter on the number of changes
			for (i = 0; i < dirtyRows.length; i++) {
				var $uuid = dirtyRows[i].$uuid;
				var row = this.getRowByUuid($uuid);
				var deltaRow;

				if (row) { // modified row
					deltaRow = row.getDataDelta();
					deltaRow.$index = dirtyRows[i].$index;
					deltaRows.push(deltaRow);
					continue;
				}

				// deleted row
				row = this.rowsDeleted[$uuid];
				if (row) {
					deltaRow = {
						"$uuid": $uuid,
						"$index": dirtyRows[i].$index,
						"$isDeleted": true
					};
					deltaRows.push(deltaRow);
					continue;
				}
			}
			return deltaRows;
		},
		getData: function() {
			return this.json;
		},
		applyDelta: function(delta) {
			if (!delta) {
				return;
			}
			// If there is a $index, only changed lines are included
			var changedLinesOnly = delta.length > 0 && delta[0].$index !== undefined;
			if (changedLinesOnly) {
				// All items contain a $index element giving their new position
				this._applyDeltaIndexed(delta);
			} else {
				this._applyDeltaFull(delta);
			}
		},
		_applyDeltaIndexed: function(delta) {
			var self = this;
			var oldUuids = this.json.map(function(row) {
				return row.$uuid;
			});

			// Manage delete, insert and change
			for (var ii = 0, jj = delta.length; ii < jj; ii++) {
				var deltaRow = delta[ii];
				var $uuid = deltaRow.$uuid;
				var $index = deltaRow.$index;
				if (deltaRow.$isDeleted === true) {
					this._deltaManRowRemoved(deltaRow.$uuid, deltaRow.$index);
					this.removeDatasetByUuid(deltaRow.$uuid);

					// Do not use $index since it may not be valid after some operations
					var idx = this.getRowIndex(deltaRow.$uuid);
					if (idx !== null) {
						this.json.splice(idx, 1);
					}
					continue;
				}
				var row = this.getRowByUuid($uuid);
				if (!row) { // new row
					this.json.splice($index, 0, deltaRow);
					this._deltaManRowAdded($uuid, $index);
				} else {
					row.applyDelta(deltaRow);
				}
			}

			// Check for moved rows
			for (var ii = 0, jj = this.json.length; ii < jj; ii++) {
				var maybeMoved = this.json[ii];
				var oldIdx = oldUuids.indexOf(maybeMoved.$uuid);
				if (oldIdx > -1 && oldIdx !== ii) {
					this._deltaManRowMoved(maybeMoved.$uuid, ii);
				}
			}
			this.dirtyProperties = [];
		},
		_applyDeltaFull: function(delta) {
			var self = this;
			var oldUuids = this.json.map(function(row) {
				return row.$uuid;
			});
			for (var ii = 0; ii < this.json.length; ii++) {
				var maybeDeletedRow = this.json[ii];
				if (!delta.some(function(row) {
						return row.$uuid === maybeDeletedRow.$uuid;
					})) {
					this._deltaManRowRemoved(maybeDeletedRow.$uuid, ii);
					this.removeDatasetByUuid(maybeDeletedRow.$uuid);
					this.json.splice(ii, 1);
					ii--;
				}
			}
			for (var ii = 0, jj = delta.length; ii < jj; ii++) {
				var deltaRow = delta[ii];
				var $uuid = deltaRow.$uuid;
				var row = this.getRowByUuid($uuid);
				if (!row) { // new row
					this.json.splice(ii, 0, deltaRow);
					this._deltaManRowAdded($uuid, ii);
				} else {
					var oldIdx = oldUuids.indexOf($uuid);
					if (oldIdx !== ii) {
						this._deltaManRowMoved($uuid, ii);
					}
					row.applyDelta(deltaRow);
				}
			}
		},
		_deltaSetValue: function($bind, value) {
			throw new Error("_deltaSetValue not supported on ArrayDataset");
		},
		/*
		 *  Order row $uuids according to their position in the data model instead of the order of change.
		 *  This important when sending the delta
		 */
		_getOrderedDirtyRows: function() {
			var rows = [];

			for (var $uuid in this.rowsDeleted) {
				rows.push({
					$uuid: $uuid,
					$index: 0
				});
			}

			for (var ii = 0, jj = this.json.length; ii < jj; ii++) {
				var $uuid = this.json[ii].$uuid;
				if (this.dirtyProperties.indexOf($uuid) > -1 ||
					$uuid in this.rowsDeleted) {
					rows.push({
						$uuid: $uuid,
						$index: ii
					});
				}
			}
			return rows;
		},
		_setAllRowsDirty: function() {
			for (var ii = 0, jj = this.json.length; ii < jj; ii++) {
				var $uuid = this.json[ii].$uuid;
				this.setDirty($uuid);
			}
		},
		destroy: function() {
			ArrayDataset.prototype.destroy.call(this);
			if (this.rowPrototype) {
				this.rowPrototype.destroy();
				this.rowPrototype = null;
			}
			if (this.rowsDeleted) {
				for (var i = 0; i < this.rowsDeleted.length; i++) {
					this.rowsDeleted[i].destroy();
				}
				this.rowsDeleted = null;
			}
		}
	}
);

/**
 * Array dataset wrapping arrays having exactly one column
 */
var SingleArrayDataset = utils.defineClass(
	function SingleArrayDataset(json, prototype, parent, $bind) {
		var self = this;
		ArrayDataset.call(this, json, prototype, parent, $bind);
		this.isReferenceArray = false;
		if (this.prototype.json.$item.$type === "application/x-reference") {
			this.rowPrototype = prototype.createNew(this.prototype.json.$item.$item);
			this.rowPrototype.json.$type = "$simplePropertyArray";
			this.isReferenceArray = true;
			this.valueProperty = Object.keys(this.rowPrototype.json.$properties)[0];
			for (var i = 0; i < this.json.length; i++) {
				this.json[i].$uuid = utils.UUID();
			}
		} else {
			this.valueProperty = "$value";
			this.rowPrototype = prototype.createNew({
				$type: "$simplePropertyArray",
				$properties: {
					$value: prototype.json.$item
				}
			});
			var wrappedItems = this.json.map(function(row) {
				return self._wrapRow(row);
			});
			// Clean original json and add wrapped items
			this.json.splice(0, this.json.length);
			for (var i = 0; i < wrappedItems.length; i++) {
				this.json.push(wrappedItems[i]);
			}
		}
	},
	ArrayDataset, {
		/**
		 * Add a new row to the array, returns newly created dataset
		 */
		addRow: function() {
			var $uuid = utils.UUID();
			var rowData = {
				$uuid: $uuid
			};
			this.json.push(rowData);
			this.setDirty(this.$bind); // full array is dirty all time
			return this.getRowByUuid($uuid);
		},
		removeRow: function($uuid) {
			var idx = this.getRowIndex($uuid);
			if (idx != null) {
				this.json.splice(idx, 1);
			}
			this.setDirty(this.$bind); // full array is dirty all time
			this.removeDatasetByUuid($uuid);
		},
		getDataDelta: function() {
			// For single prop arrays, there is no delta
			// it's always all rows
			return this.getData();
		},
		getData: function() {
			var deltaRows = [];
			var i;
			//
			// we cannot do return this.json;
			// because original json is modified to allow tracking of values
			//
			for (i = 0; i < this.json.length; i++) {
				if (this.isReferenceArray) {
					var d = {};
					d[this.valueProperty] = this.json[i][this.valueProperty];
					deltaRows.push(d);
				} else {
					deltaRows.push(this.json[i][this.valueProperty]);
				}
			}
			return deltaRows;
		},
		applyDelta: function(delta) {
			var rowsAdded = 0;
			for (var ii = 0, jj = delta.length; ii < jj; ii++) {
				var deltaRow = delta[ii];
				if (ii < this.json.length) {
					var row = this.json[ii];
					var rowChanged = false;
					if (this.isReferenceArray) {
						if (row[this.valueProperty] !== deltaRow[this.valueProperty]) {
							row[this.valueProperty] = deltaRow[this.valueProperty];
							rowChanged = true;
						}
					} else {
						if (row[this.valueProperty] !== deltaRow) {
							row[this.valueProperty] = deltaRow;
							rowChanged = true;
						}
					}
					if (rowChanged) {
						// If the value changed, let the dataset representing the row know of it
						var rowDataset = this.rowDatasetsByUuid[row.$uuid];
						if (rowDataset) { // there may be no row dataset if the row was not read by the UI, so no need to notify
							rowDataset._deltaManValueChanged(this.valueProperty);
						}
					}
				} else {
					if (this.isReferenceArray) {
						// We do not care about uuid set by the server. It's not used in the protocol
						// Better create our own one to persistently identify the row on client side 
						deltaRow.$uuid = utils.UUID();
						this.json.push(deltaRow);
					} else {
						this.json.push(this._wrapRow(deltaRow));
					}
					rowsAdded++;
				}
			}
			if (delta.length < this.json.length) {
				// Cleanup dataset of removed rows
				for (var ii = delta.length, jj = this.json.length; ii < jj; ii++) {
					this._deltaManRowRemoved(this.json[ii].$uuid, ii);
					this.removeDatasetByUuid(this.json[ii].$uuid);
				}
				var rowsRemoved = this.json.length - delta.length;
				this.json.splice(delta.length, rowsRemoved);
			} else if (rowsAdded > 0) {
				for (var ii = this.json.length - rowsAdded, jj = this.json.length; ii < jj; ii++) {
					// If there are new rows, let the listeners know 
					this._deltaManRowAdded(this.json[ii].$uuid, ii);
				}
			}
			this.dirtyProperties = [];
		},
		setClean: function($bind, includeChildren) {
			// This override is only for documentation
			// once a single property array is dirty, it will never become clean again
			// console.log("Cleaning a row's dirty flag will never cleanup array for simple type arrays");
			ArrayDataset.prototype.setClean.call(this, $bind, includeChildren);
		},
		_setAllRowsDirty: function() {
			this.setDirty(this.$bind);
		},
		_wrapRow: function(row) {
			return {
				$uuid: utils.UUID(),
				$value: row
			};
		}
	}
);

exports.SingleArrayDataset = SingleArrayDataset;

/**
 * Row dataset
 * Used to represent data of an array row in MultiArrayDatasets
 * No special implementation yet but used to represent a row dataset for future extensions
 */
var RowDataset = utils.defineClass(
	function RowDataset(json, prototype, parent, $bind) {
		Dataset.call(this, json, prototype, parent, $bind);
	},
	Dataset, {
		destroy: function() {
			Dataset.prototype.destroy.call(this);
		},
		getLink: function($linkName, $bind) {
			var link = _checkQueryFullPage(this.prototype, $linkName);
			if (link) {
				return link;
			}
			var linkD;
			// This is for links that are on property ($resources.$item) level with dynamic meta
			// data only available in the root dataset (the page)
			var parentProp = this.parent && this.parent.$bind;
			if (!$bind && parentProp && this.parent.parent && this.parent.parent.$bind == null) {
				linkD = this.parent.parent.getValueByPath("$properties." + parentProp + ".$item.$links." + $linkName);
			}

			var path = $bind ? "$properties." + $bind + ".$item.$links." + $linkName : "$links." + $linkName;
			var linkP = this.prototype.getValueByPath(path);
			if (!linkD) linkD = this.getValueByPath(path);
			if (!linkP && !linkD) {
				return;
			}
			link = $.extend(true, {}, linkP, linkD);
			if (link.$isHidden) return
			if (link.$url && /\{(\S+?)\}/.test(link.$url)) {
				link.$url = this.resolveExpression(link.$url)
			}
			return link;
		},
	}
);

exports.RowDataset = RowDataset;