"use strict";

var locale = require('syracuse-tablet/html/js/helpers/locale');

var _excludedTypes = ["application/x-array", "image", "application/x-document", "application/x-binary", "application/x-object", "text/rtf", "text/html", "application/x-password"];

var _numberOperators = ["gt", "ge", "lt", "le", "eq", "ne"];
var _stringOperators = ["like", "gt", "ge", "lt", "le", "eq", "ne", "like_s"];
var _defOperators = ["eq", "ne"];

var _DATE = {
	type: "application/x-date",
	checkFieldValue: function(fieldValue) {
		return String(fieldValue);
	},
	checkValue: function(value) {
		return String(value);

	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _TIME = {
	type: "application/x-time",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return value;

	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _DATETIME = {
	type: "application/x-datetime",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return value;

	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _DEC = {
	type: "application/x-decimal",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return parseFloat(value);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _REAL = {
	type: "application/x-real",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return parseFloat(value);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _INT = {
	type: "application/x-integer",
	checkFieldValue: function(fieldValue) {
		return parseInt(fieldValue, 10);
	},
	checkValue: function(value) {
		return parseInt(value, 10);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _QTY = {
	type: "application/x-quantity",
	checkFieldValue: function(fieldValue) {
		return parseFloat(fieldValue);
	},
	checkValue: function(value) {
		return parseFloat(value);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
var _STR = {
	type: "application/x-string",
	checkFieldValue: function(fieldValue) {
		return String(fieldValue);
	},
	checkValue: function(value) {
		return String(value);
	},
	operators: _stringOperators,
	defOperator: "like"
};
var _TEXT = {
	type: "text/plain",
	checkFieldValue: function(fieldValue) {
		return String(fieldValue);
	},
	checkValue: function(value) {
		return String(value);
	},
	operators: _stringOperators,
	defOperator: "like"
};
var _REF = {
	type: "application/x-reference",
	checkFieldValue: function(fieldValue) {
		return fieldValue && fieldValue.$value ? String(fieldValue.$value).toUpperCase() : null;
	},
	checkValue: function(value) {
		return value ? String(value).toUpperCase() : null;

	},
	operators: _stringOperators,
	defOperator: "like"
};
var _CHOICE = {
	type: "application/x-choice",
	checkFieldValue: function(fieldValue) {
		return parseInt(fieldValue, 10);
	},
	checkValue: function(value) {
		return parseInt(value, 10);
	},
	operators: _numberOperators,
	defOperator: "eq"
};
/**
 * Boolean
 */
var _BOOL = {
	type: "application/x-boolean",
	checkFieldValue: function(fieldValue) {
		return fieldValue;
	},
	checkValue: function(value) {
		return value;
	},
	operators: _defOperators,
	defOperator: "eq"
};


var _types = {};
[_DATE, _TIME, _DATETIME, _DEC, _REAL, _INT, _QTY, _STR, _TEXT, _REF, _BOOL, _CHOICE].forEach(function(t) {
	_types[t.type] = t;
});


var _operatorsWithTitle = {};
/**
 * Return array of operators according to field type
 */
var _operatorsByType = function($type) {
	var t = _types[$type];
	return t ? t.operators : _defOperators;
};

var _getOperators = function($type, withTitle, exclude) {
	var operators;
	if (withTitle === true) {
		if (_operatorsWithTitle[$type] == null) {
			var ops = _operatorsByType($type);
			var res = [];
			ops.forEach(function(op) {
				res.push({
					title: locale.text("field.operator." + op),
					value: op
				});
			});
			_operatorsWithTitle[$type] = res;
		}
		operators = _operatorsWithTitle[$type];
	} else {
		operators = _operatorsByType($type);
	}
	if (exclude && exclude.length > 0) {
		var tmp = operators;
		operators = [];
		tmp.forEach(function(o) {
			if (exclude.indexOf(o) < 0) {
				operators.push(o);
			}
		});
	}
	return operators;
};

var _getDefaultOperator = function($type) {
	var t = _types[$type];
	return t ? t.defOperator : "eq";
};
var _evaluateOperator = function($type, fieldValue, operator, value) {
	var fieldType = _types[$type];
	if (fieldType == null) {
		console.log("_evaluateOperator - Type [" + $type + "] not evaluated");
		return false;
	}
	if (fieldType.operators.indexOf(operator) < 0) return false;
	fieldValue = fieldType.checkFieldValue(fieldValue);
	value = fieldType.checkValue(value);
	if (fieldValue == null || value == null) return false;
	if (operator === "eq") {
		return fieldValue == value;
	}
	if (operator === "ne") {
		return fieldValue != value;
	}
	if (operator === "like") {
		return fieldValue.indexOf ? fieldValue.indexOf(value) >= 0 : false;
	}
	if (operator === "like_s") {
		return fieldValue.smStartsWith ? fieldValue.smStartsWith(value) : false;
	}
	if (operator === "gt") {
		return fieldValue > value;
	}
	if (operator === "ge") {
		return fieldValue >= value;
	}
	if (operator === "lt") {
		return fieldValue < value;
	}
	if (operator === "le") {
		return fieldValue <= value;
	}
	return false;
};

exports.getDefaultOperator = _getDefaultOperator;
exports.getOperators = _getOperators;
exports.evaluateOperator = _evaluateOperator;
exports.acceptOperator = function($type) {
	return _excludedTypes.indexOf($type) < 0;
};
exports.checkValue = function($type, value) {
	var fieldType = _types[$type];
	return fieldType ? fieldType.checkValue(value) : null;
};