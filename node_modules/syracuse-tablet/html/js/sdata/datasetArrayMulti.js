"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/sdata/datasetArray').ArrayDataset;

/**
 * Array dataset wrapping complex arrays having multiple columns
 */
exports.MultiArrayDataset = utils.defineClass(
	function MultiArrayDataset(json, prototype, parent, $bind) {
		Base.call(this, json, prototype, parent, $bind);
		this.rowPrototype = prototype.getProto$Item();
		// Set explicit type for ctrl row
		this.rowPrototype.json.$type = "tablet/x-array-row";
		this.rowsDeleted = {};
	},
	Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this.rowPrototype) {
				this.rowPrototype.destroy();
				this.rowPrototype = null;
			}
			this._destroyDeletedRow();
			this.rowsDeleted = null;
		},
		_destroyDeletedRow: function() {
			if (this.rowsDeleted) {
				for (var i = 0; i < this.rowsDeleted.length; i++) {
					this.rowsDeleted[i].destroy();
				}
				this.rowsDeleted = {};
			}
		},
		/**
		 * Add a new row to the array, returns newly created dataset
		 */
		addRow: function() {
			var $uuid = utils.UUID();
			var rowData = {
				$uuid: $uuid
			};
			this.json.push(rowData);
			this.setDirty($uuid);
			return this.getRowByUuid($uuid);
		},
		removeRow: function($uuid) {
			var idx = this.getRowIndex($uuid);
			if (idx != null) {
				this.json.splice(idx, 1);
			}
			var row = this.getRowByUuid($uuid);
			if (row) {
				this.setDirty($uuid);
				this.rowsDeleted[$uuid] = row;
			}
			this.removeDatasetByUuid($uuid);
			this._setAllRowsDirty();
		},
		get$ItemProto: function() {
			return this.rowPrototype;
		},
		getDataDelta: function() {
			var deltaRows = [];
			var i;
			var dirtyRows = this._getOrderedDirtyRows();

			// Could better follow https://github.com/Sage-ERP-X3/platform/wiki/JSON-Delta-Format#deltas-on-lists
			// Currently, delta only (using $index all time) is used no matter on the number of changes
			for (i = 0; i < dirtyRows.length; i++) {
				var $uuid = dirtyRows[i].$uuid;
				var row = this.getRowByUuid($uuid);
				var deltaRow;

				if (row) { // modified row
					deltaRow = row.getDataDelta();
					deltaRow.$index = dirtyRows[i].$index;
					deltaRows.push(deltaRow);
					continue;
				}

				// deleted row
				row = this.rowsDeleted[$uuid];
				if (row) {
					deltaRow = {
						"$uuid": $uuid,
						"$index": dirtyRows[i].$index,
						"$isDeleted": true
					};
					deltaRows.push(deltaRow);
					continue;
				}
			}
			return deltaRows;
		},
		getData: function() {
			return this.json;
		},
		applyDelta: function(delta) {
			this._destroyDeletedRow();
			if (!delta) {
				return;
			}
			// If there is a $index, only changed lines are included
			var changedLinesOnly = delta.length > 0 && delta[0].$index !== undefined;
			if (changedLinesOnly) {
				// All items contain a $index element giving their new position
				this._applyDeltaIndexed(delta);
			} else {
				this._applyDeltaFull(delta);
			}
		},
		_applyDeltaIndexed: function(delta) {
			var self = this;
			var oldUuids = this.json.map(function(row) {
				return row.$uuid;
			});

			// Manage delete, insert and change
			for (var ii = 0, jj = delta.length; ii < jj; ii++) {
				var deltaRow = delta[ii];
				var $uuid = deltaRow.$uuid;
				var $index = deltaRow.$index;
				if (deltaRow.$isDeleted === true) {
					this._deltaManRowRemoved(deltaRow.$uuid, deltaRow.$index);
					this.removeDatasetByUuid(deltaRow.$uuid);

					// Do not use $index since it may not be valid after some operations
					var idx = this.getRowIndex(deltaRow.$uuid);
					if (idx !== null) {
						this.json.splice(idx, 1);
					}
					continue;
				}
				var row = this.getRowByUuid($uuid);
				if (!row) { // new row
					this.json.splice($index, 0, deltaRow);
					this._deltaManRowAdded($uuid, $index);
				} else {
					row.applyDelta(deltaRow);
				}
			}

			// Check for moved rows
			for (var ii = 0, jj = this.json.length; ii < jj; ii++) {
				var maybeMoved = this.json[ii];
				var oldIdx = oldUuids.indexOf(maybeMoved.$uuid);
				if (oldIdx > -1 && oldIdx !== ii) {
					this._deltaManRowMoved(maybeMoved.$uuid, ii);
				}
			}
			this.dirtyProperties = [];
		},
		_applyDeltaFull: function(delta) {
			var self = this;
			var oldUuids = this.json.map(function(row) {
				return row.$uuid;
			});
			for (var ii = 0; ii < this.json.length; ii++) {
				var maybeDeletedRow = this.json[ii];
				if (!delta.some(function(row) {
						return row.$uuid === maybeDeletedRow.$uuid;
					})) {
					this._deltaManRowRemoved(maybeDeletedRow.$uuid, ii);
					this.removeDatasetByUuid(maybeDeletedRow.$uuid);
					this.json.splice(ii, 1);
					ii--;
				}
			}
			for (var ii = 0, jj = delta.length; ii < jj; ii++) {
				var deltaRow = delta[ii];
				var $uuid = deltaRow.$uuid;
				var row = this.getRowByUuid($uuid);
				if (!row) { // new row
					this.json.splice(ii, 0, deltaRow);
					this._deltaManRowAdded($uuid, ii);
				} else {
					var oldIdx = oldUuids.indexOf($uuid);
					if (oldIdx !== ii) {
						this._deltaManRowMoved($uuid, ii);
					}
					row.applyDelta(deltaRow);
				}
			}
		},
		_deltaSetValue: function($bind, value) {
			throw new Error("_deltaSetValue not supported on ArrayDataset");
		},
		/*
		 *  Order row $uuids according to their position in the data model instead of the order of change.
		 *  This important when sending the delta
		 */
		_getOrderedDirtyRows: function() {
			var rows = [];

			for (var $uuid in this.rowsDeleted) {
				rows.push({
					$uuid: $uuid,
					$index: 0
				});
			}

			for (var ii = 0, jj = this.json.length; ii < jj; ii++) {
				var $uuid = this.json[ii].$uuid;
				if (this.dirtyProperties.indexOf($uuid) > -1 ||
					$uuid in this.rowsDeleted) {
					rows.push({
						$uuid: $uuid,
						$index: ii
					});
				}
			}
			return rows;
		},
		_setAllRowsDirty: function() {
			for (var ii = 0, jj = this.json.length; ii < jj; ii++) {
				var $uuid = this.json[ii].$uuid;
				this.setDirty($uuid);
			}
		}

	}
);