"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var sdataHttp = require('syracuse-tablet/html/js/sdata/sdataHttp');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("sdataDispatcher");

exports.Dispatcher = utils.defineClass(function() {}, null, {
	"accept": function() {
		var deferred = $.Deferred();
		deferred.resolve(true);
		return deferred.promise();
	},

	/**
	 *  Called for every request handled by the dispatcher
	 *  Can be used to disable caching in general or for specific representations
	 */
	_useCache: function(op, data) {
		return true;
	},

	// GET: {$baseUrl}/SUPERV//$prototypes('AQTCRUD.$query')
	"prototype": function(op, data) {
		var deferred = $.Deferred();
		deferred.reject("Dispatcher should never request for prototypes since they are cached in the application model on client side");
		return deferred.promise();
	},

	//GET: {$baseUrl}/SUPERV/AQTCRUD/$template?representation=AQTCRUD.$create
	"new": function(op, data) {
		var self = this;
		var link = op.$link;
		var deferred = $.Deferred();
		try {
			var cache = globals.getCache();

			log && log("Check template: " + op.$representation);
			cache.read({
				$representation: "$templates",
				$endpoint: op.$endpoint,
				$key: op.$representation
			})
				.then(function(result) {
					// got new template from cache
					if (result && self._useCache(op, data)) {
						log && log("Template from cache: " + op.$representation);

						// Change UUID since we create a new record!
						result.$uuid = utils.UUID();
						deferred.resolve(result);
					} else {
						// read template from server
						var send = {
							method: "GET",
							url: link.$url
						};
						sdataHttp.send(send)
							.then(function(result) {
								if (result.isSuccess) {
									var data = result.responseJSON;
									cache.put({
										$representation: "$templates",
										$key: op.$representation,
										$endpoint: op.$endpoint,
										$data: data
									})
										.then(function() {
											deferred.resolve(data);
										}, function(e) {
											deferred.reject(e);
										});
								} else {
									deferred.reject(e);
								}
							}, function(e) {
								deferred.reject(e);
							});
					}
				}, function(e) {
					deferred.reject(e);
				});

		} catch (e) {
			deferred.reject(e);
		}
		return deferred.promise();
	},

	//
	"read": function(op, data) {
		var self = this;
		var link = op.$link;
		var deferred = $.Deferred();
		try {
			var cache = globals.getCache();

			log && log("Read record: " + op.$representation + "(" + op.$key + ")");
			cache.read({
				$representation: op.$representation,
				$endpoint: op.$endpoint,
				$key: op.$key
			})
				.then(function(result) {
					// got new template from cache
					if (result && self._useCache(op, data)) {
						log && log("Got from cache: " + op.$representation);

						// Change UUID since we create a new record!
						deferred.resolve(result);
					} else {
						// read template from server
						var send = {
							method: "GET",
							url: link.$url
						};
						sdataHttp.send(send)
							.then(function(result) {
								if (result.isSuccess) {
									var data = result.responseJSON;
									cache.put({
										$representation: op.$representation,
										$key: op.$key,
										$endpoint: op.$endpoint,
										$data: data
									})
										.then(function() {
											deferred.resolve(data);
										}, function(e) {
											deferred.reject(e);
										});
								} else {
									deferred.reject();
								}
							}, function(e) {
								deferred.reject(e);
							});
					}
				}, function(e) {
					deferred.reject(e);
				});

		} catch (e) {
			deferred.reject(e);
		}
		return deferred.promise();
	},

	//
	"query": function(op, data) {
		op.$key = "$query$"; // fake key to cache query page: TODO: Fix this
		return this.read(op, data);
	},

	// PUT: {$baseUrl}/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$edit
	// POST: {$baseUrl}/SUPERV/AQTCRUD?representation=AQTCRUD.$create
	"save": function(op, data) {
		var link = op.$link;
		var deferred = $.Deferred();
		try {
			var cache = globals.getCache();

			log && log("Save record: " + op.$representation + "(" + op.$key + ")");
			var send = {
				method: link.$method,
				url: link.$url,
				send: data
			};
			sdataHttp.send(send)
				.then(function(result) {
					if (result.isSuccess) {
						var data = result.responseJSON;
						log && log("Add to cache: " + op.$representation + "(" + op.$key + ")");
						if (!op.$key) { // TODO: Change this once prototypes are available (to extract key!)
							op.$key = "!!!!";
						}
						cache.put({
							$representation: op.$representation,
							$key: op.$key,
							$endpoint: op.$endpoint,
							$data: data
						})
							.then(function() {
								deferred.resolve(data);
							}, function(e) {
								deferred.reject();
							});
					} else {
						deferred.reject();
					}
				}, function(e) {
					deferred.reject(e);
				});
		} catch (e) {
			deferred.reject(e);
		}
		return deferred.promise();
	},

	// DELETE: {$baseUrl}/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$query
	"delete": function(op, data) {
		var link = op.$link;
		var deferred = $.Deferred();
		try {
			var cache = globals.getCache();

			log && log("Delete record: " + op.$representation + "(" + op.$key + ")");
			var send = {
				method: link.$method,
				url: link.$url
			};
			sdataHttp.send(send)
				.then(function(result) {
					if (result.isSuccess) {
						var data = result.responseJSON;
						log && log("Remove from cache: " + op.$representation + "(" + op.$key + ")");
						cache.remove({
							$representation: op.$representation,
							$endpoint: op.$endpoint,
							$key: op.$key
						})
							.then(function() {
								deferred.resolve(data);
							}, function(e) {
								deferred.reject();
							});
					} else {
						deferred.reject();
					}
				}, function(e) {
					deferred.reject(e);
				});
		} catch (e) {
			deferred.reject(e);
		}
		return deferred.promise();
	},
	"service": function() {

	}
});