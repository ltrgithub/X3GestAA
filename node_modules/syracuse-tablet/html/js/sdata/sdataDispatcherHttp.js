"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("sdataDispatcher");
var sdataHttp = require('syracuse-tablet/html/js/sdata/sdataHttp');

// Set if cache is update is waiting to finish before sending result to caller or
// if cache is updated in parallel to get faster response times to the caller 
var _writeCacheModeSync = {
	// For query operations
	query: false,
	// For read operations
	read: false
};

// This function either returns a promise (sync stack execution) or the value
// expected to be returned by the promise (async stack execution)
function _returnSyncAsync(promise, result, sync) {
	if (sync) {
		var timeLine = utils.getTimeLine("cacheUpdate", utils.UUID());
		timeLine && timeLine.start("Start writing to cache");
		return promise.then(function() {
			timeLine && timeLine.step("completed");
			return result;
		});
	} else {
		return result;
	}
}

exports.Dispatcher = utils.defineClass(function() {}, null, {
	"accept": function() {
		var deferred = $.Deferred();
		deferred.resolve(true);
		return deferred.promise();
	},

	_isOnline: function() {
		// Just wrapped here to have eventual dedicated tracing posibility
		return globals.isOnline();
	},

	/*
	 * Returns true if the ajax response is considered to be an offline error message
	 */
	_isOfflineError: function(result) {
		if (result && result.status < 100) {
			return true;
		}
		return false;
	},

	_networkError: function(title, result) {
		if (result && result.responseJSON && result.responseJSON.$diagnoses) {
			result.responseJSON.$title = title;
			return $.smReject(result.responseJSON);
		}
		return $.smReject({
			$title: title
		});
	},

	_offlineNoCachedDataMessage: function() {
		return $.smReject({
			$diagnoses: [{
				$message: locale.text("error.network.offline.cache"),
				$severity: "error"
			}]
		});
	},

	/**
	 *  Called for every request handled by the dispatcher
	 *  Can be used to disable caching in general or for specific representations
	 */
	_useCache: function(op, data, action) {
		var cache = globals.getCache();
		if (cache.isDisabled()) { // Disabled by dev features?
			return false;
		}

		var nocache = op.$parsedUrl && op.$parsedUrl.query && op.$parsedUrl.query.nocache;
		if (nocache && action === "read") {
			return false;
		}
		if (op.$representation.indexOf(".$edit") > 0 && action === "read") {
			return false;
		}
		return true;
	},

	// GET: {$baseUrl}/SUPERV//$prototypes('AQTCRUD.$query')
	"prototype": function(op, data) {
		var deferred = $.Deferred();
		deferred.reject("Dispatcher should never request for prototypes since they are cached in the application model on client side");
		return deferred.promise();
	},

	//GET: {$baseUrl}/SUPERV/AQTCRUD/$template?representation=AQTCRUD.$create
	"new": function(op, data) {
		var self = this;

		var cacheRead;
		var usedCache;
		if (self._isOnline()) {
			cacheRead = $.smResolve();
			usedCache = false;
		} else {
			cacheRead = self._newGetCache(op, data);
			usedCache = true;
		}

		return cacheRead.then(function(result) {
			// got new template from cache
			if (result) {
				log && log("Read template from cache: " + op.$representation);
				// Change UUID since we create a new record!
				result.$uuid = utils.UUID();
				return result;
			}
			return self._newDoHttp(op, data)
				.then(function(result) {
					if (result.isSuccess) {
						var data = result.responseJSON;
						return self._newPutCache(op, data)
							.then(function() {
								return data;
							});
					}
					if (!usedCache) {
						return self._newGetCache(op, data)
							.then(function(result) {
								if (result) {
									log && log("Read template from cache fallback: " + op.$representation);
									// Change UUID since we create a new record!
									result.$uuid = utils.UUID();
									return result;
								}
								return self._networkError("Error reading $template", result);
							});
					}
					return self._networkError("Error reading $template", result);
				});
		});
	},

	_newGetCache: function(op) {
		var self = this;
		if (self._useCache(op, null, "read")) {
			var cache = globals.getCache();
			log && log("Reading template from cache: " + op.$representation);
			return cache.read({
				$representation: "$templates",
				$endpoint: op.$endpoint,
				$key: op.$representation
			});
		}
		log && log("Disabled reading template from cache : " + op.$representation);
		return $.smResolve();
	},
	_newDoHttp: function(op, data) {
		var send = {
			method: "GET",
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_newPutCache: function(op, data) {
		var self = this;
		if (self._useCache(op, data, "write")) {
			log && log("Writing template to cache: " + op.$representation);
			var cache = globals.getCache();
			return cache.put({
				$representation: "$templates",
				$key: op.$representation,
				$endpoint: op.$endpoint,
				$data: data
			});
		}
		log && log("Disabled writing template to cache : " + op.$representation);
		return $.smResolve();
	},

	//GET: {$baseUrl}/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$create
	"read": function(op, data, forceUseCache) {
		var self = this;
		var cacheRead;
		var usedCache;
		if (self._isOnline() && forceUseCache !== true) {
			cacheRead = $.smResolve();
			usedCache = false;
		} else {
			cacheRead = self._readGetCache(op, data);
			usedCache = true;
		}

		return cacheRead.then(function(result) {
			if (result) {
				log && log("Read data from cache: " + op.$representation);
				result.$cacheHint = {};
				return result;
			}
			return self._readDoHttp(op, data)
				.then(function(result) {
					if (result.isSuccess) {
						var data = result.responseJSON;
						var prom = self._readPutCache(op, data)
							.then(function() {
								return data;
							});
						return _returnSyncAsync(prom, data, _writeCacheModeSync.read);
					}
					if (!self._isOfflineError(result)) {
						return self._networkError("Error reading data", result);
					}
					if (!usedCache) {
						return self._readGetCache(op, data)
							.then(function(data) {
								if (data) {
									data.$cacheHint = {};
									return data;
								}
								return forceUseCache === true ? null : self._offlineNoCachedDataMessage();
							});
					}
					return forceUseCache === true ? null : self._offlineNoCachedDataMessage();
				});
		});
	},

	_readGetCache: function(op) {
		var self = this;
		if (self._useCache(op, null, "read")) {
			var cache = globals.getCache();
			log && log("Reading data from cache: " + op.$representation);
			return cache.read({
				$representation: op.$representation,
				$endpoint: op.$endpoint,
				$key: op.$key
			});
		}
		log && log("Disabled reading data from cache : " + op.$representation);
		return $.smResolve();
	},
	_readDoHttp: function(op, data) {
		var send = {
			method: "GET",
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_readPutCache: function(op, data) {
		var self = this;
		if (self._useCache(op, data, "write")) {
			log && log("Writing data to cache: " + op.$representation);
			var cache = globals.getCache();
			return cache.put({
				$representation: op.$representation,
				$key: op.$key,
				$endpoint: op.$endpoint,
				$data: data
			});
		}
		log && log("Disabled writing data to cache : " + op.$representation);
		return $.smResolve();
	},

	// GET: {$baseUrl}/SUPERV/AQTCRUD?representation=AQTCRUD.$create?where=xxx
	"query": function(op, data, forceUseCache) {
		var self = this;

		var cacheRead;
		var usedCache;
		if (self._isOnline() && forceUseCache !== true) {
			cacheRead = $.smResolve();
			usedCache = false;
		} else {
			cacheRead = self._queryGetCache(op, data);
			usedCache = true;
		}

		return cacheRead.then(function(result) {
			var step;
			if (result && result.length > 0) {
				log && log("Queried data from cache: " + op.$representation);
				var response = {};
				step = self._queryCutAndAddLinks(op, data, result, response).then(function() {
					if (!response.$resources) {
						response.$resources = [];
					}
					if (response.$resources.length > 0) {
						response.$cacheHint = {};
						return response;
					}
				});
			} else {
				step = $.smResolve(null);
			}

			return step.then(function(response) {
				if (response && response.$resources && response.$resources.length > 0) {
					return response;
				}
				return self._queryDoHttp(op, data)
					.then(function(result) {
						if (result.isSuccess) {
							var data = result.responseJSON || {};
							data.$resources = data.$resources || [];
							var prom = self._queryPutCache(op, data)
								.then(function() {
									return data;
								});
							return _returnSyncAsync(prom, data, _writeCacheModeSync.query);
						}
						if (!self._isOfflineError(result)) {
							return self._networkError("Error reading data", result);
						}

						if (!usedCache) {
							return self._queryGetCache(op, data)
								.then(function(result1) {
									if (result1 && result1.length > 0) {
										log && log("Queried data from cache: " + op.$representation);
										var response = {};
										return self._queryCutAndAddLinks(op, data, result1, response).then(function() {
											if (!response.$resources) {
												response.$resources = [];
											}
											if (response.$resources.length > 0) {
												response.$cacheHint = {};
												return response;
											}
										});
									}
									return forceUseCache === true ? null : self._offlineNoCachedDataMessage();
								});
						}
						return forceUseCache === true ? null : self._offlineNoCachedDataMessage();
					});
			});
		});
	},
	_queryCutAndAddLinks: function(op, data, result, response) {
		var self = this;
		var baseUrl = op.$parsedUrl.source.split("?")[0];
		var query = "";
		var key;
		var max = 30;
		var orderBy = "";

		if (op.$parsedUrl.query && op.$parsedUrl.query.where) {
			query += "&where=" + op.$parsedUrl.query.where;
		}

		key = op.$parsedUrl.query && op.$parsedUrl.query.key;
		var firstKeyRead;
		var lastKeyRead;

		var resources = response.$resources = [];
		var hasNextPage = false;
		var hasPreviousPage = false;
		var i;

		var pageName = op.$endpoint + "." + op.$representation;
		return globals.getMetaData().getPrototype(pageName)
			.then(function(proto) {
				var val;
				var kv;
				var orderBy = "";
				proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
				var keyField;
				if (proto.$key) {
					keyField = proto.$key.replace(/{/g, "").replace(/}/g, "");
				} else {
					keyField = "$uuid";
				}
				if (op.$parsedUrl.query && op.$parsedUrl.query.orderBy) {
					orderBy = self._buildOrderBy(op, keyField, op.$parsedUrl.query.orderBy);
					query += "&orderBy=" + orderBy;
				}

				var keyType = proto.$properties[keyField];
				var isNumericKey = keyType && keyType.$type && keyType.$type !== "application/x-string";
				var gotMatch = false;
				if (key && key.smStartsWith("gt")) {
					val = key.substr(3);
					val = isNumericKey ? +val : val;

					for (i = 0; i < result.length; i++) {
						if (!gotMatch) {
							kv = self._calculateKey(proto, result[i]);
							kv = isNumericKey ? +kv : "" + kv;
						}
						if (kv == val && !gotMatch) {
							gotMatch = true;
						} else if (gotMatch) {
							resources.push(result[i]);
							if (resources.length > max) {
								break;
							}
						} else {
							hasPreviousPage = true;
						}
					}
					if (resources.length > 0) {
						if (resources.length > max) {
							resources.pop();
							hasNextPage = true;
						}
						firstKeyRead = self._calculateKey(proto, resources[0]);
						lastKeyRead = self._calculateKey(proto, resources[resources.length - 1]);
					}
				} else if (key && key.smStartsWith("lt")) {

					if (key.length > 3) {
						val = isNumericKey ? +key.substr(3) : "" + key.substr(3);

						for (i = result.length - 1; i >= 0; i--) {
							if (!gotMatch) {
								kv = self._calculateKey(proto, result[i]);
								kv = isNumericKey ? 0 + kv : "" + kv;
							}

							if (kv == val && !gotMatch) {
								gotMatch = true;
							} else if (gotMatch) {
								resources.push(result[i]);
								if (resources.length > max) {
									break;
								}
							} else {
								hasNextPage = true;
							}
						}
						if (resources.length > max) {
							hasPreviousPage = true;
							resources.pop();
						}
					} else {
						for (i = result.length - 1; i >= 0; i--) {
							resources.push(result[i]);
							if (resources.length > max) {
								break;
							}
						}
					}
					if (resources.length > 0) {
						if (resources.length > max) {
							hasPreviousPage = true;
							resources.pop();
						}
						response.$resources = resources = resources.reverse();

						firstKeyRead = self._calculateKey(proto, resources[0]);
						lastKeyRead = self._calculateKey(proto, resources[resources.length - 1]);
					}
				} else {
					for (i = 0; i < result.length; i++) {
						resources.push(result[i]);
						if (resources.length > max) {
							break;
						}
					}
					if (resources.length > 0) {
						if (resources.length > max) {
							hasNextPage = true;
							resources.pop();
						}

						firstKeyRead = self._calculateKey(proto, resources[0]);
						lastKeyRead = self._calculateKey(proto, resources[resources.length - 1]);
					}
				}

				var links = response.$links = {};
				if (key) {
					links.$first = {
						$url: baseUrl + "?representation=" + op.$representation + query
					};
				}

				if (key && firstKeyRead && hasPreviousPage) {
					if (key !== "gt") { // not on first page?
						links.$previous = {
							$url: baseUrl + "?representation=" + op.$representation + query + "&key=lt." + firstKeyRead
						};
					}
				}

				if (key !== "lt" && lastKeyRead && hasNextPage) { // not on last page and more records
					links.$next = {
						$url: baseUrl + "?representation=" + op.$representation + query + "&key=gt." + lastKeyRead
					};
				}
				if (key !== "lt") {
					links.$last = {
						$url: baseUrl + "?representation=" + op.$representation + query + "&key=lt"
					};
				}

				links.$more = {
					$url: op.$parsedUrl.source + "&nocache=true"
				};
			});
	},
	_queryGetCache: function(op) {
		var self = this;
		if (self._useCache(op, null, "read")) {
			var cache = globals.getCache();
			log && log("Querying data from cache: " + op.$representation);
			var p = op.$endpoint + "." + op.$representation;
			// Ususally this should never be called since the sync call above
			// returns the prototype already.
			return globals.getMetaData().getPrototype(p).then(function(proto) {
				self._checkQueryPrototype(op, proto);

				var filters = proto.$filters;
				var where = self._extendWhereWithFilter(op, filters);

				var isRequestOrStats = proto && (proto.codeRequest || proto.codeStat);
				var proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
				var keyField;
				if (proto.$key) {
					keyField = proto.$key.replace(/{/g, "").replace(/}/g, "");
				} else {
					keyField = "$uuid";
				}
				if (!isRequestOrStats) {
					var orderBy = self._parseOrderBy(op.$orderBy, keyField);
					return cache.query({
						$proto: proto,
						$endpoint: op.$endpoint,
						$where: where,
						$orderBy: orderBy
					}).fail(function(e) {
						return $.smReject(e);
					});
				} else {
					return cache.read({
						$representation: op.$representation,
						$endpoint: op.$endpoint,
						$key: "where:" + (where || "")
					})
						.fail(function(e) {
							return $.smReject(e);
						});
				}
			});
		}
		log && log("Disabled querying data from cache : " + op.$representation);
		return $.smResolve();
	},
	_queryDoHttp: function(op, data) {
		var send = {
			method: "GET",
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_queryPutCache: function(op, data) {
		var self = this;
		if (self._useCache(op, data, "write")) {
			log && log("Writing data to cache: " + op.$representation);
			var cache = globals.getCache();

			var pageName = op.$endpoint + "." + op.$representation;
			return globals.getMetaData().getPrototype(pageName).then(function(proto) {
				var isRequestOrStats = proto && (proto.codeRequest || proto.codeStat);
				proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
				if (!isRequestOrStats) {
					return $.smForEachPromise(data.$resources || [], function(item) {
						var key = self._calculateKey(proto, item);
						if (!key) {
							key = item.$uuid;
						}
						return cache.put({
							$representation: op.$representation,
							$key: key,
							$endpoint: op.$endpoint,
							$data: item
						});
					});
				} else {
					// For statistics and requests, we store the whole array as one record with where condition as key
					// This is because subsequent requests return the same records with another uuid which
					// will grow the cache all the time
					var filters = proto.$filters;
					var where = self._extendWhereWithFilter(op, filters);
					return cache.put({
						$representation: op.$representation,
						$key: "where:" + (where || ""),
						$endpoint: op.$endpoint,
						$data: data.$resources || []
					});
				}
			});
		}
		// No cache
		return $.smResolve(data);
		log && log("Disabled writing data to cache : " + op.$representation);
	},


	// PUT: {$baseUrl}/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$edit
	// POST: {$baseUrl}/SUPERV/AQTCRUD?representation=AQTCRUD.$create
	"save": function(op, data) {
		var self = this;
		return self._saveDoHttp(op, data)
			.then(function(result) {
				if (result.isSuccess) {
					var data = result.responseJSON;
					return self._savePutCache(op, data)
						.then(function() {
							return data;
						});
				}
				return $.smReject(result);
			});
	},

	_saveDoHttp: function(op, data) {
		var send = {
			method: op.$link.$method,
			url: op.$link.$url,
			send: data
		};
		return sdataHttp.send(send);
	},

	_savePutCache: function(op, data) {
		var self = this;
		try {
			if (self._useCache(op, data, "write")) {
				log && log("Writing data to cache: " + op.$representation);
				var cache = globals.getCache();
				var key = op.$key;
				var step;
				if (!key) {
					var pageName = op.$endpoint + "." + op.$representation;
					step = globals.getMetaData().getPrototype(pageName).then(function(proto) {
						proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
						key = self._calculateKey(proto, data);
						return key;
					});
				} else {
					step = $.smResolve(key);
				}
				// write to cache is async, this is why there is not "return step.then(...)"
				step.then(function(key) {
					self._removeFromCache({
						$representation: op.$representation,
						$key: key,
						$endpoint: op.$endpoint
					}).then(function() {
						return cache.put({
							$representation: op.$representation,
							$key: key,
							$endpoint: op.$endpoint,
							$data: data
						});
					});
				});
			}
			log && log("Disabled writing data to cache : " + op.$representation);
			return $.smResolve();
		} catch (e) {
			return $.smReject(e);
		}
	},

	// DELETE: {$baseUrl}/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$query
	"delete": function(op, data) {
		var self = this;
		var deferred = $.Deferred();
		try {
			self._deleteDoHttp(op, data)
				.then(function(result) {
					if (result.isSuccess) {
						var data = result.responseJSON;
						return self._deleteRemoveCache(op, data)
							.then(function() {
								return data;
							});
					}
					return $.smReject(result); //new Error("Error saving object: " + JSON.stringify(result)));
				})
				.then(function(result) {
					deferred.resolve(result);
				}).fail(function(e) {
					deferred.reject(e);
				});
		} catch (e) {
			deferred.reject(e);
		}
		return deferred.promise();
	},
	_deleteDoHttp: function(op, data) {
		var send = {
			method: op.$link.$method,
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_deleteRemoveCache: function(op, data) {
		var self = this;
		if (self._useCache(op, data, "write")) {
			log && log("Deleting data from cache: " + op.$representation);
			var cache = globals.getCache();
			self._removeFromCache({
				$representation: op.$representation,
				$key: op.$key,
				$endpoint: op.$endpoint
			}).then(function() {
				return cache.remove({
					$representation: op.$representation,
					$key: op.$key,
					$endpoint: op.$endpoint
				});
			});
		}
		log && log("Disabled deleting data from cache : " + op.$representation);
		return $.smResolve();
	},

	"service": function(op, data) {
		if (this._isOnline()) {
			var send = {
				method: op.$link.$method,
				url: op.$link.$url,
				send: data
			};
			return sdataHttp.send(send);
		} else {
			return $.smResolve({
				"$diagnoses": [{
					"$severity": "error",
					"$message": locale.text("error.service.offline")
				}]
			});
		}
	},
	_calculateKey: function(proto, item) {
		var key;
		if (proto.$key) {
			key = proto.$key.replace(/\{(.*?)\}/g, function(match, prop) {
				return item[prop];
			});
		} else {
			key = item.$uuid;
		}
		return key;
	},
	_getKeyFields: function(proto) {
		var key = proto.$key ||
			proto.$properties &&
			proto.$properties.$resources &&
			proto.$properties.$resources.$item &&
			proto.$properties.$resources.$item.$key;
		if (key) {
			var list = [];
			key.replace(/\{(.*?)\}/g, function(match, prop) {
				list.push(prop);
			});
			if (list.length < 1) {
				return ["$uuid"];
			}
			return list;
		} else {
			return ["$uuid"];
		}
	},
	_checkQueryPrototype: function(op, proto) {
		// https://github.com/Sage-ERP-X3/Syracuse/issues/6003
		// Type of $item in queries is application/json but the cache needs a concrete type to be able to store the data
		// For requester requests, type is empty and will also be generated here
		if (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) {
			proto.$properties.$resources.$item.$type = "{$baseType}." + op.$representation;
		}
	},
	_removeFromCache: function(op) {
		var self = this;

		var cache = globals.getCache();

		var facets = ["$edit", "$create", "$details", "$query", "$lookup"];
		var rep = op.$representation.split(".")[0];

		return $.smForEachPromise(facets, function(facet) {
			if (op.$representation.indexOf("." + facet) > 0) {
				return $.smResolve();
			}
			return cache.remove({
				$representation: rep + "." + facet,
				$key: op.$key,
				$endpoint: op.$endpoint
			});
		});
	},

	_parseOrderBy: function(orderBy, keyField) {
		if (!orderBy) {
			return [{
				property: keyField,
				sort: "ASC"
			}];
		}
		var o = [];
		orderBy.split(",").map(function(field) {
			field = field.trim();
			var d = field.split(" ");
			var f = d[0].trim();
			if (f.length > 0) {
				var dir = "ASC";
				if (d.length > 1) {
					dir = d[1].toUpperCase();
					dir = dir !== "DESC" ? "ASC" : "DESC";
				}
				o.push({
					property: f,
					sort: dir
				});
			}
		});
		return o;
	},

	_buildOrderBy: function(op, keyField, orderBy) {
		if (!orderBy) {
			return keyField;
		}

		if (!(orderBy === keyField || orderBy.indexOf(keyField + " ") > -1 || orderBy.indexOf(keyField + ",") > -1)) {
			// Key field not yet in order by
			if (orderBy.indexOf(" DESC") > -1) {
				orderBy += ", " + keyField + " DESC";
			} else {
				orderBy += ", " + keyField + " ASC";
			}
		}
		return orderBy;
	},

	_extendWhereWithFilter: function(op, filters) {
		var self = this;

		var where = op.$where;
		if (!filters) {
			return where;
		}
		var filterName = op.$parsedUrl && op.$parsedUrl.query && op.$parsedUrl.query.filter;
		if (!filterName) {
			return where;
		}
		var filter = filters && filters[filterName];
		if (!filter) {
			return where;
		}

		var fw = self._checkFilterWhere(filterName, filter.$where);
		if (!fw) {
			return where;
		}

		if (where) {
			where = "(" + where + ") and (" + fw + ")";
		} else {
			where = "(" + fw + ")";
		}

		return where;
	},

	/*
	 * Check if X3 filter contains invalid references of screen elements which are not valid on client side
	 * In case it's true, the filter will be ignored and an error message will be displayer
	 */
	_checkFilterWhere: function(filterName, where) {
		var invalid = where.match(/(\[F\:\w+\]?)/g);
		if (invalid) {
			globals.getModal().error(
				locale.text("sdata.error.filter.screenFieldTitle"),
				locale.text("sdata.error.filter.screenFieldDetails", [filterName, invalid.join(","), where])
			);
			// Do not use filter, it will cause errors
			return null;
		}
		return where;
	}
});