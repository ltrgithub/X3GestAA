"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("sdataDispatcher");
var sdataHttp = require('syracuse-tablet/html/js/sdata/sdataHttp');

exports.Dispatcher = utils.defineClass(function() {}, null, {
	"accept": function() {
		var deferred = $.Deferred();
		deferred.resolve(true);
		return deferred.promise();
	},

	/**
	 *  Called for every request handled by the dispatcher
	 *  Can be used to disable caching in general or for specific representations
	 */
	_useCache: function(op, data) {
		var nocache = op.$parsedUrl && op.$parsedUrl.query && op.$parsedUrl.query.nocache;
		if (nocache) {
			return false;
		}
		return true;
	},

	// GET: {$baseUrl}/SUPERV//$prototypes('AQTCRUD.$query')
	"prototype": function(op, data) {
		var deferred = $.Deferred();
		deferred.reject("Dispatcher should never request for prototypes since they are cached in the application model on client side");
		return deferred.promise();
	},

	//GET: {$baseUrl}/SUPERV/AQTCRUD/$template?representation=AQTCRUD.$create
	"new": function(op, data) {
		var self = this;
		var deferred = $.Deferred();
		try {
			self._newGetCache(op, data)
				.then(function(result) {
					// got new template from cache
					if (result) {
						log && log("Read template from cache: " + op.$representation);
						// Change UUID since we create a new record!
						result.$uuid = utils.UUID();
						return result;
					} else {
						return self._newDoHttp(op, data)
							.then(function(result) {
								if (result.isSuccess) {
									var data = result.responseJSON;
									return self._newPutCache(op, data)
										.then(function() {
											return data;
										});
								}
								throw new Error("Error reading $template: " + JSON.stringify(result));
							}).fail(function(e) {
								return $.smReject(e);
							});
					}
				})
				.then(function(result) {
					deferred.resolve(result);
				}).fail(function(e) {
					deferred.reject(e);
				});
		} catch (e) {
			deferred.reject(e);
		}
		return deferred.promise();
	},

	_newGetCache: function(op) {
		var self = this;
		if (self._useCache(op, null, "read")) {
			var cache = globals.getCache();
			log && log("Reading template from cache: " + op.$representation);
			return cache.read({
				$representation: "$templates",
				$endpoint: op.$endpoint,
				$key: op.$representation
			});
		}
		log && log("Disabled reading template from cache : " + op.$representation);
		return $.smResolve();
	},
	_newDoHttp: function(op, data) {
		var send = {
			method: "GET",
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_newPutCache: function(op, data) {
		var self = this;
		if (self._useCache(op, data, "write")) {
			log && log("Writing template to cache: " + op.$representation);
			var cache = globals.getCache();
			return cache.put({
				$representation: "$templates",
				$key: op.$representation,
				$endpoint: op.$endpoint,
				$data: data
			});
		}
		log && log("Disabled writing template to cache : " + op.$representation);
		return $.smResolve();
	},

	//GET: {$baseUrl}/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$create
	"read": function(op, data) {
		var self = this;
		var deferred = $.Deferred();
		try {
			self._readGetCache(op, data)
				.then(function(result) {
					if (result) {
						log && log("Read data from cache: " + op.$representation);
						return result;
					} else {
						return self._readDoHttp(op, data)
							.then(function(result) {
								if (result.isSuccess) {
									var data = result.responseJSON;
									return self._readPutCache(op, data)
										.then(function() {
											return data;
										});
								}
								throw new Error("Error reading data: " + JSON.stringify(result));
							}).fail(function(e) {
								return $.smReject(e);
							});
					}
				})
				.then(function(result) {
					deferred.resolve(result);
				}).fail(function(e) {
					deferred.reject(e);
				});
		} catch (e) {
			deferred.reject(e);
		}
		return deferred.promise();
	},

	_readGetCache: function(op) {
		var self = this;
		if (self._useCache(op, null, "read")) {
			var cache = globals.getCache();
			log && log("Reading data from cache: " + op.$representation);
			return cache.read({
				$representation: op.$representation,
				$endpoint: op.$endpoint,
				$key: op.$key
			});
		}
		log && log("Disabled reading data from cache : " + op.$representation);
		return $.smResolve();
	},
	_readDoHttp: function(op, data) {
		var send = {
			method: "GET",
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_readPutCache: function(op, data) {
		var self = this;
		if (self._useCache(op, data, "write")) {
			log && log("Writing data to cache: " + op.$representation);
			var cache = globals.getCache();
			return cache.put({
				$representation: op.$representation,
				$key: op.$key,
				$endpoint: op.$endpoint,
				$data: data
			});
		}
		log && log("Disabled writing data to cache : " + op.$representation);
		return $.smResolve();
	},

	// GET: {$baseUrl}/SUPERV/AQTCRUD?representation=AQTCRUD.$create?where=xxx
	"query": function(op, data) {
		var self = this;
		var deferred = $.Deferred();
		try {
			self._queryGetCache(op, data)
				.then(function(result) {
					if (result && result.length > 0) {
						log && log("Queried data from cache: " + op.$representation);
						var response = {};
						self._queryCutAndAddLinks(op, data, result, response);
						if (response.$resources.length > 0) {
							return response;
						}
					};

					return self._queryDoHttp(op, data)
						.then(function(result) {
							if (result.isSuccess) {
								var data = result.responseJSON;
								return self._queryPutCache(op, data)
									.then(function() {
										return data;
									});
							} else {
								throw new Error("Error querying data: " + JSON.stringify(result, null, 2));
							}
						}).fail(function(e) {
							return $.smReject(e);
						});
				})
				.then(function(result) {
					deferred.resolve(result);
				}).fail(function(e) {
					deferred.reject(e);
				});
		} catch (e) {
			deferred.reject(e);
		}
		return deferred.promise();
	},
	_queryCutAndAddLinks: function(op, data, result, response) {
		var self = this;
		var baseUrl = op.$parsedUrl.source.split("?")[0];
		var query = "";
		var key;
		var max = 30;

		if (op.$parsedUrl.query && op.$parsedUrl.query.where) {
			query += "&where=" + op.$parsedUrl.query.where;
		}

		key = op.$parsedUrl.query && op.$parsedUrl.query.key;
		var firstKeyRead;
		var lastKeyRead;

		var resources = response.$resources = [];
		var hasNextPage = false;
		var hasPreviousPage = false;
		var i;

		var pageName = op.$endpoint + "." + op.$representation;
		var proto = globals.getPrototype(pageName);
		var val;
		var kv;
		proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
		var keyField;
		if (proto.$key) {
			keyField = proto.$key.replace(/{/g, "").replace(/}/g, "");
		} else {
			keyField = "$uuid";
		}
		var keyType = proto.$properties[keyField];
		var isNumericKey = keyType && keyType.$type && keyType.$type !== "application/x-string";

		if (key && key.smStartsWith("gt")) {
			val = isNumericKey ? 0 + key.substr(3) : "" + key.substr(3);

			for (i = 0; i < result.length; i++) {
				kv = self._calculateKey(proto, result[i]);
				kv = isNumericKey ? +kv : "" + kv;

				if (kv > val) {
					resources.push(result[i]);
					if (resources.length > max) {
						break;
					}
				} else {
					hasPreviousPage = true;
				}
			}
			if (resources.length > 0) {
				if (resources.length > max) {
					resources.pop();
					hasNextPage = true;
				}
				firstKeyRead = self._calculateKey(proto, resources[0]);
				lastKeyRead = self._calculateKey(proto, resources[resources.length - 1]);
			}
		} else if (key && key.smStartsWith("lt")) {

			if (key.length > 3) {
				val = isNumericKey ? +key.substr(3) : "" + key.substr(3);

				for (i = result.length - 1; i >= 0; i--) {

					kv = self._calculateKey(proto, result[i]);
					kv = isNumericKey ? 0 + kv : "" + kv;

					if (kv < val) {
						resources.push(result[i]);
						if (resources.length > max) {
							break;
						}
					} else {
						hasNextPage = true;
					}
				}
				if (resources.length > max) {
					hasPreviousPage = true;
					resources.pop();
				}
			} else {
				for (i = result.length - 1; i >= 0; i--) {
					resources.push(result[i]);
					if (resources.length > max) {
						break;
					}
				}
			}
			if (resources.length > 0) {
				if (resources.length > max) {
					hasPreviousPage = true;
					resources.pop();
				}
				response.$resources = resources = resources.reverse();

				firstKeyRead = self._calculateKey(proto, resources[0]);
				lastKeyRead = self._calculateKey(proto, resources[resources.length - 1]);
			}
		} else {
			for (i = 0; i < result.length; i++) {
				resources.push(result[i]);
				if (resources.length > max) {
					break;
				}
			}
			if (resources.length > 0) {
				if (resources.length > max) {
					hasNextPage = true;
					resources.pop();
				}

				firstKeyRead = self._calculateKey(proto, resources[0]);
				lastKeyRead = self._calculateKey(proto, resources[resources.length - 1]);
			}
		}

		var links = response.$links = {};
		if (key) {
			links.$first = {
				$url: baseUrl + "?representation=" + op.$representation + query
			};
		}

		if (key && firstKeyRead && hasPreviousPage) {
			if (key !== "gt") { // not on first page?
				links.$previous = {
					$url: baseUrl + "?representation=" + op.$representation + query + "&key=lt." + firstKeyRead
				};
			}
		}

		if (key !== "lt" && lastKeyRead && hasNextPage) { // not on last page and more records
			links.$next = {
				$url: baseUrl + "?representation=" + op.$representation + query + "&key=gt." + lastKeyRead
			};
		}
		if (key !== "lt") {
			links.$last = {
				$url: baseUrl + "?representation=" + op.$representation + query + "&key=lt"
			};
		}

		links.$more = {
			$url: op.$parsedUrl.source + "&nocache=true"
		};
	},
	_queryGetCache: function(op) {
		var self = this;
		if (self._useCache(op, null, "read")) {
			var cache = globals.getCache();
			log && log("Querying data from cache: " + op.$representation);
			var p = op.$endpoint + "." + op.$representation;
			var proto = globals.getPrototype(p);
			if (proto) {
				self._checkQueryPrototype(op, proto);
				return cache.query({
					$proto: proto,
					$endpoint: op.$endpoint,
					$where: op.$where
				});
			} else {
				// Ususally this should never be called since the sync call above
				// returns the prototype already.
				return sdataHttp.fetchRemotePrototype(op).then(function(proto) {
					self._checkQueryPrototype(op, proto);
					return cache.query({
						$proto: proto,
						$endpoint: op.$endpoint,
						$where: op.$where
					}).fail(function(e) {
						return $.smReject(e);
					});
				});
			}
		}
		log && log("Disabled querying data from cache : " + op.$representation);
		return $.smResolve();
	},
	_queryDoHttp: function(op, data) {
		var send = {
			method: "GET",
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_queryPutCache: function(op, data) {
		var self = this;
		if (self._useCache(op, data, "write")) {
			log && log("Writing data to cache: " + op.$representation);
			var cache = globals.getCache();

			var pageName = op.$endpoint + "." + op.$representation;
			var proto = globals.getPrototype(pageName);
			proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
			return data.$resources.forEachPromise(function(item) {
				var key = self._calculateKey(proto, item);
				return cache.put({
					$representation: op.$representation,
					$key: key,
					$endpoint: op.$endpoint,
					$data: item
				});
			});
		}
		// No cache
		return $.smResolve(data);
		log && log("Disabled writing data to cache : " + op.$representation);
	},


	// PUT: {$baseUrl}/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$edit
	// POST: {$baseUrl}/SUPERV/AQTCRUD?representation=AQTCRUD.$create
	"save": function(op, data) {
		var self = this;
		var deferred = $.Deferred();
		try {
			self._saveDoHttp(op, data)
				.then(function(result) {
					if (result.isSuccess) {
						var data = result.responseJSON;
						return self._savePutCache(op, data)
							.then(function() {
								return data;
							});
					}
					deferred.reject(result);
				})
				.then(function(result) {
					deferred.resolve(result);
				}).fail(function(e) {
					deferred.reject(e);
				});
		} catch (e) {
			deferred.reject(e);
		}
		return deferred.promise();
	},

	_saveDoHttp: function(op, data) {
		var send = {
			method: op.$link.$method,
			url: op.$link.$url,
			send: data
		};
		return sdataHttp.send(send);
	},

	_savePutCache: function(op, data) {
		var self = this;
		try {
			if (self._useCache(op, data, "write")) {
				log && log("Writing data to cache: " + op.$representation);
				var cache = globals.getCache();
				var key = op.$key;
				if (!key) {
					var pageName = op.$endpoint + "." + op.$representation;
					var proto = globals.getPrototype(pageName);
					proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
					key = self._calculateKey(proto, data);
				}
				return cache.put({
					$representation: op.$representation,
					$key: key,
					$endpoint: op.$endpoint,
					$data: data
				});
			}
			log && log("Disabled writing data to cache : " + op.$representation);
			return $.smResolve();
		} catch (e) {
			return $.smReject(e);
		}
	},

	// DELETE: {$baseUrl}/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$query
	"delete": function(op, data) {
		var self = this;
		var deferred = $.Deferred();
		try {
			self._deleteDoHttp(op, data)
				.then(function(result) {
					if (result.isSuccess) {
						var data = result.responseJSON;
						return self._deleteRemoveCache(op, data)
							.then(function() {
								return data;
							});
					}
					return $.smReject(result); //new Error("Error saving object: " + JSON.stringify(result)));
				})
				.then(function(result) {
					deferred.resolve(result);
				}).fail(function(e) {
					deferred.reject(e);
				});
		} catch (e) {
			deferred.reject(e);
		}
		return deferred.promise();
	},
	_deleteDoHttp: function(op, data) {
		var send = {
			method: op.$link.$method,
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_deleteRemoveCache: function(op, data) {
		var self = this;
		if (self._useCache(op, data, "write")) {
			log && log("Deleting data from cache: " + op.$representation);
			var cache = globals.getCache();
			return cache.remove({
				$representation: op.$representation,
				$key: op.$key,
				$endpoint: op.$endpoint
			});
		}
		log && log("Disabled deleting data from cache : " + op.$representation);
		return $.smResolve();
	},

	"service": function(op, data) {
		if (utils.isOnline()) {
			var send = {
				method: op.$link.$method,
				url: op.$link.$url,
				data: data
			};
			return sdataHttp.send(send);
		} else {
			return $.smResolve({
				"$diagnoses": [{
					"$severity": "error",
					"$message": locale.text("error.service.offline")
				}]
			});
		}
	},
	_calculateKey: function(proto, item) {
		var key;
		if (proto.$key) {
			key = proto.$key.replace(/\{(.*?)\}/g, function(match, prop) {
				return item[prop];
			});
		} else {
			key = item.$uuid;
		}
		return key;
	},
	_checkQueryPrototype: function(op, proto) {
		// Queries (Requester) do not generate a full prototype, add what's missing here
		if (op.$representation.smStartsWith("QUERY~")) {
			if (proto.$properties.$resources.$item && !proto.$properties.$resources.$item.$type) {
				proto.$properties.$resources.$item.$type = "{$baseType}." + op.$representation;
			}
		}
	}
});