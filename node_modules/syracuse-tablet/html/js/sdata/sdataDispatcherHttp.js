"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("sdataDispatcher");
var sdataHttp = require('syracuse-tablet/html/js/sdata/sdataHttp');

/**
 * Stores temporarily the whole JSON data of a 'query like' page
 */
var _authQueryCache = {};

// Set if cache is update is waiting to finish before sending result to caller or
// if cache is updated in parallel to get faster response times to the caller 
var _writeCacheModeSync = {
	// For query operations
	query: false,
	// For read operations
	read: false
};

// This function either returns a promise (sync stack execution) or the value
// expected to be returned by the promise (async stack execution)
function _returnSyncAsync(promise, result, sync) {
	if (sync) {
		var timeLine = utils.getTimeLine("cacheUpdate", utils.UUID());
		timeLine && timeLine.start("Start writing to cache");
		return promise.then(function() {
			timeLine && timeLine.step("completed");
			return result;
		});
	} else {
		return result;
	}
}

exports.Dispatcher = utils.defineClass(function() {
	notifications.subscribe(this, "sm.authcache.destroy");
}, null, {
	/**
	 * Called when a 'query like' page is destroyed to remove the cache stored in _authQueryCache
	 * See regularPage.destroy
	 */
	notifAuthcacheDestroy: function(pageId) {
		if (!pageId) return;
		//console.log("notifAuthcacheDestroy", pageId, _authQueryCache[pageId]!=null);
		_authQueryCache[pageId] = null;
	},
	"accept": function() {
		var deferred = $.Deferred();
		deferred.resolve(true);
		return deferred.promise();
	},

	_isOnline: function() {
		// Just wrapped here to have eventual dedicated tracing posibility
		return globals.isOnline();
	},

	/*
	 * Returns true if the ajax response is considered to be an offline error message
	 */
	_isOfflineError: function(result) {
		if (result && result.status < 100) {
			return true;
		}
		return false;
	},

	_networkError: function(title, result) {
		if (result && result.responseJSON && result.responseJSON.$diagnoses) {
			result.responseJSON.$title = title;
			return $.smReject(result.responseJSON);
		}
		return $.smReject({
			$title: title
		});
	},

	_offlineNoCachedDataMessage: function() {
		return $.smReject({
			$noConnectionError: true,
			$diagnoses: [{
				$message: locale.text("error.network.offline.cache"),
				$severity: "error"
			}]
		});
	},

	/**
	 *  Called for every request handled by the dispatcher
	 *  Can be used to disable caching in general or for specific representations
	 */
	_useCache: function(op, action) {
		var cache = globals.getCache();
		if (cache.isDisabled()) { // Disabled by dev features?
			return false;
		}

		var nocache = op.$parsedUrl && op.$parsedUrl.query && op.$parsedUrl.query.nocache;
		if (nocache && action === "read") {
			return false;
		}
		if (op.$representation.indexOf(".$edit") > 0 && action === "read") {
			return false;
		}
		return true;
	},

	// GET: {$baseUrl}/SUPERV//$prototypes('AQTCRUD.$query')
	"prototype": function(op, data, options) {
		var deferred = $.Deferred();
		deferred.reject("Dispatcher should never request for prototypes since they are cached in the application model on client side");
		return deferred.promise();
	},

	//GET: {$baseUrl}/SUPERV/AQTCRUD/$template?representation=AQTCRUD.$create
	"new": function(op, data, options) {
		var self = this;

		var cacheRead;
		var usedCache;
		if (self._isOnline()) {
			cacheRead = $.smResolve();
			usedCache = false;
		} else {
			cacheRead = self._newGetCache(op, data);
			usedCache = true;
		}

		return cacheRead.then(function(result) {
			// got new template from cache
			if (result) {
				log && log("Read template from cache: " + op.$representation);
				// Change UUID since we create a new record!
				result.$uuid = utils.UUID();
				return result;
			}
			return self._newDoHttp(op, data)
				.then(function(result) {
					if (result.isSuccess) {
						var data = result.responseJSON;
						return self._newPutCache(op, data)
							.then(function() {
								return data;
							});
					}
					var netResult = result;
					if (!usedCache) {
						return self._newGetCache(op, data)
							.then(function(result) {
								if (result) {
									log && log("Read template from cache fallback: " + op.$representation);
									// Change UUID since we create a new record!
									result.$uuid = utils.UUID();
									return result;
								}
								return self._networkError("Error reading $template", netResult);
							});
					}
					return self._networkError("Error reading $template", netResult);
				});
		});
	},

	_newGetCache: function(op) {
		var self = this;
		if (self._useCache(op, "read")) {
			var cache = globals.getCache();
			log && log("Reading template from cache: " + op.$representation);
			return cache.read({
				$representation: "$templates",
				$endpoint: op.$endpoint,
				$key: op.$representation
			});
		}
		log && log("Disabled reading template from cache : " + op.$representation);
		return $.smResolve();
	},
	_newDoHttp: function(op, data) {
		var send = {
			method: "GET",
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_newPutCache: function(op, data) {
		var self = this;
		if (self._useCache(op, "write")) {
			log && log("Writing template to cache: " + op.$representation);
			var cache = globals.getCache();
			return cache.put({
				$representation: "$templates",
				$key: op.$representation,
				$endpoint: op.$endpoint,
				$data: data
			});
		}
		log && log("Disabled writing template to cache : " + op.$representation);
		return $.smResolve();
	},

	//GET: {$baseUrl}/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$create
	"read": function(op, data, options) {
		var self = this;
		var cacheRead;
		var forceUseCache = options.forceUseCache;
		var usedCache;
		if (self._isOnline() && forceUseCache !== true) {
			cacheRead = $.smResolve();
			usedCache = false;
		} else {
			cacheRead = self._readGetCache(op, data);
			usedCache = true;
		}

		return cacheRead.then(function(result) {
			if (result) {
				log && log("Read data from cache: " + op.$representation);
				// $cacheHint tells caller that the cache has been used
				result.$cacheHint = {};
				return result;
			}
			return self._readDoHttp(op, data)
				.then(function(result) {
					if (result.isSuccess) {
						var data = result.responseJSON;
						var prom = self._readPutCache(op, data)
							.then(function() {
								return data;
							});
						return _returnSyncAsync(prom, data, _writeCacheModeSync.read);
					}
					if (!self._isOfflineError(result)) {
						return self._networkError("Error reading data", result);
					}
					if (!usedCache) {
						return self._readGetCache(op, data)
							.then(function(data) {
								if (data) {
									// $cacheHint tells caller that the cache has been used
									data.$cacheHint = {};
									return data;
								}
								return forceUseCache === true ? null : self._offlineNoCachedDataMessage();
							});
					}
					return forceUseCache === true ? null : self._offlineNoCachedDataMessage();
				});
		});
	},

	_readGetCache: function(op) {
		var self = this;
		if (self._useCache(op, "read")) {
			var cache = globals.getCache();
			log && log("Reading data from cache: " + op.$representation);
			return cache.read({
				$representation: op.$representation,
				$endpoint: op.$endpoint,
				$key: op.$key
			});
		}
		log && log("Disabled reading data from cache : " + op.$representation);
		return $.smResolve();
	},
	_readDoHttp: function(op, data) {
		var send = {
			method: "GET",
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_readPutCache: function(op, data) {
		var self = this;
		if (self._useCache(op, "write")) {
			log && log("Writing data to cache: " + op.$representation);
			var cache = globals.getCache();
			return cache.put({
				$representation: op.$representation,
				$key: op.$key,
				$endpoint: op.$endpoint,
				$data: data
			});
		}
		log && log("Disabled writing data to cache : " + op.$representation);
		return $.smResolve();
	},

	// GET: {$baseUrl}/SUPERV/AQTCRUD?representation=AQTCRUD.$create?where=xxx
	// dataToSend is unused
	"query": function(op, dataToSend, options) {
		var self = this;
		var cacheRead;
		var usedCache;
		var forceUseCache = options.forceUseCache;
		var isStatsRequest = op.$isRequest === true || op.$isStats === true;
		if ((self._useCache(op, "read") !== true) || (self._isOnline() && forceUseCache !== true)) {
			cacheRead = $.smResolve(null);
			usedCache = false;
		} else {
			cacheRead = self._queryReadCache(op, options);
			usedCache = true;
		}

		return cacheRead.then(function(cacheResult, isAuthCache) {
			var step;
			if (cacheResult != null) {
				log && log("Queried data from cache: " + op.$representation);
				if (isStatsRequest) {
					// STATS or REQUEST
					// for stats and requests we store the full page
					var response = cacheResult;
					if (!response) {
						response = {};
					}
					if (!response.$resources) {
						response.$resources = [];
					}
					step = $.smResolve(response);
				} else if (isAuthCache === true) {
					step = $.smResolve(cacheResult);
				} else {

					// QUERY
					// For queries we store the rows
					var response = {};
					step = self._queryCutAndAddLinks(op, cacheResult, response).then(function() {
						if (!response.$resources) {
							response.$resources = [];
						}
						if (response.$resources.length > 0) {
							// $cacheHint tells caller that the cache has been used
							response.$cacheHint = {};
						}
						return response;
					});
				}
			} else {
				step = $.smResolve(null);
			}

			return step.then(function(cacheResponse) {
				if (cacheResponse && cacheResponse.$resources && cacheResponse.$resources.length > 0) {
					return cacheResponse;
				}
				return self._queryDoHttp(op)
					.then(function(httpResult) {
						if (httpResult.isSuccess) {
							var data = httpResult.responseJSON || {};
							data.$resources = data.$resources || [];
							var prom;
							if (self._useCache(op, "write")) {
								var prom = self._queryPutCache(op, data, options)
									.then(function() {
										return data;
									});
							} else {
								// No cache
								log && log("Disabled writing data to cache : " + op.$representation);
								var prom = $.smResolve(data);
							}
							return _returnSyncAsync(prom, data, _writeCacheModeSync.query);
						}
						if (!self._isOfflineError(httpResult)) {
							return self._networkError("Error reading data", httpResult);
						}
						if (!usedCache) {
							// read the cache if not done before
							return self._queryReadCache(op, options)
								.then(function(cacheResult) {
									if (!cacheResult) {
										return forceUseCache === true ? null : self._offlineNoCachedDataMessage();
									}
									log && log("Queried data from cache: " + op.$representation);
									if (isStatsRequest) {
										// STATS or REQUEST
										var response = cacheResult;
										if (!response) {
											response = {};
										}
										if (!response.$resources) {
											response.$resources = [];
										}
										if (response.$resources.length > 0) {
											// $cacheHint tells caller that the cache has been used
											response.$cacheHint = {};
										}
										return $.smResolve(response);
									} else {
										// QUERY
										var response = {};
										return self._queryCutAndAddLinks(op, cacheResult, response).then(function() {
											if (!response.$resources) {
												response.$resources = [];
											}
											if (response.$resources.length > 0) {
												// $cacheHint tells caller that the cache has been used
												response.$cacheHint = {};
												return response;
											}
										});
									}
								});
						}
						return forceUseCache === true ? null : self._offlineNoCachedDataMessage();
					});
			});
		});
	},
	// Calculates pagination links according to data (rows) stored in the cache
	_queryCutAndAddLinks: function(op, result, response) {
		result = result || [];
		var self = this;
		var baseUrl = op.$parsedUrl.source.split("?")[0];
		var query = "";
		var key;
		var max = globals.OFFLINEQUERYCOUNT;
		var orderBy = "";

		if (op.$parsedUrl.query && op.$parsedUrl.query.where) {
			query += "&where=" + op.$parsedUrl.query.where;
		}

		key = op.$parsedUrl.query && op.$parsedUrl.query.key;
		var firstKeyRead;
		var lastKeyRead;

		var resources = response.$resources = [];
		var hasNextPage = false;
		var hasPreviousPage = false;
		var i;

		var pageName = op.$endpoint + "." + op.$representation;
		return globals.getMetaData().getPrototype(pageName)
			.then(function(proto) {
				var val;
				var kv;
				var orderBy = "";
				proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
				var keyField;
				if (proto.$key) {
					keyField = proto.$key.replace(/{/g, "").replace(/}/g, "");
				} else {
					keyField = "$uuid";
				}
				if (op.$parsedUrl.query && op.$parsedUrl.query.orderBy) {
					orderBy = self._buildOrderBy(op, keyField, op.$parsedUrl.query.orderBy);
					query += "&orderBy=" + orderBy;
				}

				var keyType = proto.$properties[keyField];
				var isNumericKey = keyType && keyType.$type && keyType.$type !== "application/x-string";
				var gotMatch = false;
				if (key && key.smStartsWith("gt")) {
					val = key.substr(3);
					val = isNumericKey ? +val : val;

					for (i = 0; i < result.length; i++) {
						if (!gotMatch) {
							kv = self._calculateKey(proto, result[i]);
							kv = isNumericKey ? +kv : "" + kv;
						}
						if (kv == val && !gotMatch) {
							gotMatch = true;
						} else if (gotMatch) {
							resources.push(result[i]);
							if (resources.length > max) {
								break;
							}
						} else {
							hasPreviousPage = true;
						}
					}
					if (resources.length > 0) {
						if (resources.length > max) {
							resources.pop();
							hasNextPage = true;
						}
						firstKeyRead = self._calculateKey(proto, resources[0]);
						lastKeyRead = self._calculateKey(proto, resources[resources.length - 1]);
					}
				} else if (key && key.smStartsWith("lt")) {

					if (key.length > 3) {
						val = isNumericKey ? +key.substr(3) : "" + key.substr(3);

						for (i = result.length - 1; i >= 0; i--) {
							if (!gotMatch) {
								kv = self._calculateKey(proto, result[i]);
								kv = isNumericKey ? 0 + kv : "" + kv;
							}

							if (kv == val && !gotMatch) {
								gotMatch = true;
							} else if (gotMatch) {
								resources.push(result[i]);
								if (resources.length > max) {
									break;
								}
							} else {
								hasNextPage = true;
							}
						}
						if (resources.length > max) {
							hasPreviousPage = true;
							resources.pop();
						}
					} else {
						for (i = result.length - 1; i >= 0; i--) {
							resources.push(result[i]);
							if (resources.length > max) {
								break;
							}
						}
					}
					if (resources.length > 0) {
						if (resources.length > max) {
							hasPreviousPage = true;
							resources.pop();
						}
						response.$resources = resources = resources.reverse();

						firstKeyRead = self._calculateKey(proto, resources[0]);
						lastKeyRead = self._calculateKey(proto, resources[resources.length - 1]);
					}
				} else {
					for (i = 0; i < result.length; i++) {
						resources.push(result[i]);
						if (resources.length > max) {
							break;
						}
					}
					if (resources.length > 0) {
						if (resources.length > max) {
							hasNextPage = true;
							resources.pop();
						}

						firstKeyRead = self._calculateKey(proto, resources[0]);
						lastKeyRead = self._calculateKey(proto, resources[resources.length - 1]);
					}
				}

				var links = response.$links = {};
				if (key) {
					links.$first = {
						$url: baseUrl + "?representation=" + op.$representation + query
					};
				}

				if (key && firstKeyRead && hasPreviousPage) {
					if (key !== "gt") { // not on first page?
						links.$previous = {
							$url: baseUrl + "?representation=" + op.$representation + query + "&key=lt." + firstKeyRead
						};
					}
				}

				if (key !== "lt" && lastKeyRead && hasNextPage) { // not on last page and more records
					links.$next = {
						$url: baseUrl + "?representation=" + op.$representation + query + "&key=gt." + lastKeyRead
					};
				}
				if (key !== "lt" && hasNextPage) {
					links.$last = {
						$url: baseUrl + "?representation=" + op.$representation + query + "&key=lt"
					};
				}
			});
	},
	_reqStatsGetCacheOpts: function(op, data) {
		// representation -> QUERY~QAQTGRA2~1.$query
		var key = op.$representation;
		var q = op.$parsedUrl.query;
		if (q && q.count !== null) {
			key += "~" + q.count;
		}
		if (q && op.$isRequest === true) {
			if (q.startRecord !== null) {
				key += "~" + q.startRecord;
			}
		}
		// Currently no where clause are available for query and stats
		var opts = {
			$representation: op.$representation,
			$endpoint: op.$endpoint,
			$key: key
		};
		if (data != null) {
			opts.$data = data;
		}
		return opts;
	},
	_queryReadCache: function(op, options) {
		var self = this;
		var cache = globals.getCache();
		log && log("Querying data from cache: " + op.$representation);
		var p = op.$endpoint + "." + op.$representation;
		// Ususally this should never be called since the sync call above
		// returns the prototype already.
		return globals.getMetaData().getPrototype(p).then(function(proto) {
			self._checkQueryPrototype(op, proto);
			if (op.$isRequest === true || op.$isStats === true) {
				return cache.read(self._reqStatsGetCacheOpts(op)).fail(function(e) {
					return $.smReject(e);
				});
			} else {
				if (globals.isAuthoringActive() && options.$authCacheId && _authQueryCache[options.$authCacheId]) {
					// returns the whole JSON data with $links and count parameter in authoring
					// When we refresh authoring forceUseCache=true and the pagination is broken (see _queryCutAndAddLinks)
					// -> count is wrong
					// The goal is to display the same rendering as in non-authoring mode
					// When we exit the authoring we don't refresh the page so the redering should be the same in both modes
					return $.smResolve(_authQueryCache[options.$authCacheId], true);
				}
				var filters = proto.$filters;
				var where = self._extendWhereWithFilter(op, filters);
				var proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
				var keyField;
				if (proto.$key) {
					keyField = proto.$key.replace(/{/g, "").replace(/}/g, "");
				} else {
					keyField = "$uuid";
				}
				var orderBy = self._parseOrderBy(op.$orderBy, keyField);
				return cache.query({
					$proto: proto,
					$endpoint: op.$endpoint,
					$where: where,
					$orderBy: orderBy
				}).fail(function(e) {
					return $.smReject(e);
				});
			}
		});
	},
	_queryDoHttp: function(op) {
		var send = {
			method: "GET",
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_queryPutCache: function(op, data, options) {
		var self = this;
		log && log("Writing data to cache: " + op.$representation);
		var cache = globals.getCache();
		var pageName = op.$endpoint + "." + op.$representation;
		if (!data) {
			data = {};
		}
		if (!data.$resources) {
			data.$resources = [];
		}
		return globals.getMetaData().getPrototype(pageName).then(function(proto) {
			if (op.$isRequest === true || op.$isStats === true) {
				// Stores the whole JSON data
				return cache.put(self._reqStatsGetCacheOpts(op, data));
			} else {
				if (options.$authCacheId) {
					// $authCacheId is the page id
					// Stores the last whole JSON data for this page
					// data will be read in _queryReadCache (see comments)
					// Te data are removed when the page is destoyed (see notifAuthcacheDestroy)
					_authQueryCache[options.$authCacheId] = data;
					// console.log("write _authQueryCache", options.$authCacheId)
				}
				// Store the lines
				proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
				return $.smForEachPromise(data.$resources, function(item) {
					var key = self._calculateKey(proto, item);
					if (!key) {
						key = item.$uuid;
					}
					return cache.put({
						$representation: op.$representation,
						$key: key,
						$endpoint: op.$endpoint,
						$data: item
					});
				});
			}
		});
	},


	// PUT: {$baseUrl}/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$edit
	// POST: {$baseUrl}/SUPERV/AQTCRUD?representation=AQTCRUD.$create
	"save": function(op, data, options) {
		var self = this;
		return self._saveDoHttp(op, data)
			.then(function(result) {
				if (result.isSuccess) {
					var data = result.responseJSON;
					return self._savePutCache(op, data)
						.then(function() {
							return data;
						});
				}
				return $.smReject(result);
			});
	},

	_saveDoHttp: function(op, data) {
		var send = {
			method: op.$link.$method,
			url: op.$link.$url,
			send: data
		};
		return sdataHttp.send(send);
	},

	_savePutCache: function(op, data) {
		var self = this;
		try {
			if (self._useCache(op, "write")) {
				log && log("Writing data to cache: " + op.$representation);
				var cache = globals.getCache();
				var key = op.$key;
				var step;
				if (!key) {
					var pageName = op.$endpoint + "." + op.$representation;
					step = globals.getMetaData().getPrototype(pageName).then(function(proto) {
						proto = (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
						key = self._calculateKey(proto, data);
						return key;
					});
				} else {
					step = $.smResolve(key);
				}
				// write to cache is async, this is why there is not "return step.then(...)"
				step.then(function(key) {
					self._removeFromCache({
						$representation: op.$representation,
						$key: key,
						$endpoint: op.$endpoint
					}).then(function() {
						return cache.put({
							$representation: op.$representation,
							$key: key,
							$endpoint: op.$endpoint,
							$data: data
						});
					});
				});
			}
			log && log("Disabled writing data to cache : " + op.$representation);
			return $.smResolve();
		} catch (e) {
			return $.smReject(e);
		}
	},

	// DELETE: {$baseUrl}/SUPERV/AQTCRUD('10')?representation=AQTCRUD.$query
	"delete": function(op, data, options) {
		var self = this;
		var deferred = $.Deferred();
		try {
			self._deleteDoHttp(op, data)
				.then(function(result) {
					if (result.isSuccess) {
						var data = result.responseJSON;
						return self._deleteRemoveCache(op, data)
							.then(function() {
								return data;
							});
					}
					return $.smReject(result); //new Error("Error saving object: " + JSON.stringify(result)));
				})
				.then(function(result) {
					deferred.resolve(result);
				}).fail(function(e) {
					deferred.reject(e);
				});
		} catch (e) {
			deferred.reject(e);
		}
		return deferred.promise();
	},
	_deleteDoHttp: function(op, data) {
		var send = {
			method: op.$link.$method,
			url: op.$link.$url
		};
		return sdataHttp.send(send);
	},
	_deleteRemoveCache: function(op, data) {
		var self = this;
		if (self._useCache(op, "write")) {
			log && log("Deleting data from cache: " + op.$representation);
			var cache = globals.getCache();
			self._removeFromCache({
				$representation: op.$representation,
				$key: op.$key,
				$endpoint: op.$endpoint
			}).then(function() {
				return cache.remove({
					$representation: op.$representation,
					$key: op.$key,
					$endpoint: op.$endpoint
				});
			});
		}
		log && log("Disabled deleting data from cache : " + op.$representation);
		return $.smResolve();
	},

	"service": function(op, data, options) {
		if (this._isOnline()) {
			var send = {
				method: op.$link.$method,
				url: op.$link.$url,
				send: data
			};
			return sdataHttp.send(send);
		} else {
			return $.smResolve({
				"$diagnoses": [{
					"$severity": "error",
					"$message": locale.text("error.service.offline")
				}]
			});
		}
	},
	_calculateKey: function(proto, item) {
		var key;
		if (proto.$key) {
			key = proto.$key.replace(/\{(.*?)\}/g, function(match, prop) {
				return item[prop];
			});
		} else {
			key = item.$uuid;
		}
		return key;
	},
	_getKeyFields: function(proto) {
		var key = proto.$key ||
			proto.$properties &&
			proto.$properties.$resources &&
			proto.$properties.$resources.$item &&
			proto.$properties.$resources.$item.$key;
		if (key) {
			var list = [];
			key.replace(/\{(.*?)\}/g, function(match, prop) {
				list.push(prop);
			});
			if (list.length < 1) {
				return ["$uuid"];
			}
			return list;
		} else {
			return ["$uuid"];
		}
	},
	_checkQueryPrototype: function(op, proto) {
		// https://github.com/Sage-ERP-X3/Syracuse/issues/6003
		// Type of $item in queries is application/json but the cache needs a concrete type to be able to store the data
		// For requester requests, type is empty and will also be generated here
		if (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) {
			proto.$properties.$resources.$item.$type = "{$baseType}." + op.$representation;
		}
	},
	_removeFromCache: function(op) {
		var self = this;

		var cache = globals.getCache();

		var facets = ["$edit", "$create", "$details", "$query", "$lookup"];
		var rep = op.$representation.split(".")[0];

		return $.smForEachPromise(facets, function(facet) {
			if (op.$representation.indexOf("." + facet) > 0) {
				return $.smResolve();
			}
			return cache.remove({
				$representation: rep + "." + facet,
				$key: op.$key,
				$endpoint: op.$endpoint
			});
		});
	},

	_parseOrderBy: function(orderBy, keyField) {
		if (!orderBy) {
			return [{
				property: keyField,
				sort: "ASC"
			}];
		}
		var o = [];
		orderBy.split(",").map(function(field) {
			field = field.trim();
			var d = field.split(" ");
			var f = d[0].trim();
			if (f.length > 0) {
				var dir = "ASC";
				if (d.length > 1) {
					dir = d[1].toUpperCase();
					dir = dir !== "DESC" ? "ASC" : "DESC";
				}
				o.push({
					property: f,
					sort: dir
				});
			}
		});
		return o;
	},

	_buildOrderBy: function(op, keyField, orderBy) {
		if (!orderBy) {
			return keyField;
		}

		if (!(orderBy === keyField || orderBy.indexOf(keyField + " ") > -1 || orderBy.indexOf(keyField + ",") > -1)) {
			// Key field not yet in order by
			if (orderBy.indexOf(" DESC") > -1) {
				orderBy += ", " + keyField + " DESC";
			} else {
				orderBy += ", " + keyField + " ASC";
			}
		}
		return orderBy;
	},

	_extendWhereWithFilter: function(op, filters) {
		var self = this;

		var where = op.$where;
		if (!filters) {
			return where;
		}
		var filterName = op.$parsedUrl && op.$parsedUrl.query && op.$parsedUrl.query.filter;
		if (!filterName) {
			return where;
		}
		var filter = filters && filters[filterName];
		if (!filter) {
			return where;
		}

		var fw = self._checkFilterWhere(filterName, filter.$where);
		if (!fw) {
			return where;
		}

		if (where) {
			where = "(" + where + ") and (" + fw + ")";
		} else {
			where = "(" + fw + ")";
		}

		return where;
	},

	/*
	 * Check if X3 filter contains invalid references of screen elements which are not valid on client side
	 * In case it's true, the filter will be ignored and an error message will be displayer
	 */
	_checkFilterWhere: function(filterName, where) {
		var invalid = where.match(/(\[F\:\w+\]?)/g);
		if (invalid) {
			globals.getModal().error(
				locale.text("sdata.error.filter.screenFieldTitle"),
				locale.text("sdata.error.filter.screenFieldDetails", [filterName, invalid.join(","), where])
			);
			// Do not use filter, it will cause errors
			return null;
		}
		return where;
	}
});