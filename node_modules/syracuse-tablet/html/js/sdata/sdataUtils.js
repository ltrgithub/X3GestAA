"use strict";

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var modules = require('syracuse-tablet/html/js/common/modules');
var _rID = /^(.*)\(\'(.*)\'\)$/i;
/**
 * nofail= true	return null if error
 */
exports.parseSDataURL = function(url, noFail) {
	var res = jsutils.parseURL(url);
	if (res.query && res.query.representation) {
		res.representation = res.query.representation;
		res.facet = null;
		var p = res.representation.indexOf('.');
		if (p != -1) {
			res.facet = res.representation.substr(p + 1);
			if (res.facet.charAt(0) == '$') res.facet = res.facet.substr(1);
			res.representation = res.representation.substr(0, p);
		}
	}
	var a;
	if (res.directory) {
		var idx = res.directory.indexOf("/$services/");
		if (idx > -1) {
			res.$services = res.directory.substring(idx + 11);
		}
		a = res.directory.split('/');
	}
	if (a == null || a.length <= 4) {
		if (noFail === true) return null;
		throw new Error("Bad sdata url:" + url);
	}
	res.dispatch = a[1];
	if (res.dispatch !== "mobile1" && res.dispatch !== "mobile2" && res.dispatch !== "sdata") {
		if (noFail === true) return null;
		throw new Error("Bad sdata url:" + url);
	}
	res.application = a[2];
	res.contract = a[3];
	res.dataset = a[4];
	if (a.length === 4) return res;
	var match = _rID.exec(a[5]);
	if (match && (match.length == 3)) {
		res.entity = match[1];
		res.id = match[2];
		if (res.id && res.id.trim().Length === 0) res.id = null;
	} else {
		res.entity = a[5];
		res.id = null;
	}
	if (a.length === 5) return res;
	return res;
};

/**
 * SCan diagnoses in a sdata response
 * TODO TEST
 */
exports.clearSyracuseStack = function(d) {
	if (d.$stackTrace && d.$stackTrace.indexOf("node_modules\syracuse-x3") >= 0) {
		if (d.$message && d.$stackTrace.indexOf(d.$message) >= 0) {
			// No need of stack
			delete d.$stackTrace;
		} else {
			// Remove stack because too long
			d.$stackTrace = d.$stackTrace.split("\n")[0];
		}
	}
	return d;
};
// options.remove: true -> Remove diagnoses
exports.scanDiagnoses = function(data, options) {
	var result = [];
	var done = [];
	var _scan = function(o, prop, path) {
		if (!path) path = [];
		if (done.indexOf(o) >= 0) return;
		if (Array.isArray(o)) {
			done.push(o);
			if (prop) path.push(prop);
			o.forEach(function(e, idx) {
				_scan(e, idx + "", path);
			});
			if (prop) path.pop(prop);
		} else if ($.isPlainObject(o)) {
			done.push(o);
			for (var p in o) {
				if (p === "$diagnoses") {
					if (options && options.remove === true) {
						delete o[p];
					} else {
						o[p].forEach(function(d) {
							var $path = [].concat(path);
							if (prop) $path.push(prop);
							if (p) $path.push(p);
							d = exports.clearSyracuseStack($.extend({}, d));
							d.$path = $path.join('.');
							result.push(d);
						});
					}
				} else {
					if (prop) path.push(prop);
					_scan(o[p], p, path);
					if (prop) path.pop(prop);
				}
			}
		}
	};
	if (data != null) _scan(data);
	return result;

};

exports.addWhereClause = function(url, where, params) {
	params = params || {};
	var allParamsSet = true;
	where = where.value;
	var res = where.replace(/\{(\w*?)\}/g, function(m, p1) {
		var value = params[p1];
		if (value == null) {
			allParamsSet = false;
		}
		return value != null ? value : "";
	});
	if (allParamsSet) {
		url = url + "&where=" + res;
	}
	return url;
};
/**
 * Resolves with draft dataSet
 * Wrap = true to wrap data in {data: dataSet}
 */
exports.draftReadData = function(draftId, wrap) {
	return modules.get("storage").getStorage().draftOperation("draftRead", draftId).then(function(ctx) {
		if (!ctx || !ctx.dataSet) {
			return null;
		}
		ctx.dataSet.$clientContext = {
			$mobileProtocol: "stateless",
			$mobileEndpoint: ctx.endpoint,
			$mobileApplication: ""
		};
		// Trick to propagate the comment/error in order to not have to re-input it when we save a draft with error
		ctx.dataSet.$clientContext.$draftContext = {
			comment: ctx.comment,
			status: ctx.status,
			errorMsg: ctx.errorMsg
		};
		return wrap ? {
			data: ctx.dataSet
		} : ctx.dataSet;
	})
}