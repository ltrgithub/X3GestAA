"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var helpers = require('syracuse-tablet/html/js/common/helpers');
var datasetUtils = require('syracuse-tablet/html/js/sdata/datasetUtils');


//Keys on meta data of links and actions that will be checked for changes to notify the controller
var _linksAndActionsMetaKeys = ["$isHidden", "$isDisabled"];

/**
 * General dataset class, used for root level of objects right now
 */
exports.DatasetBase = utils.defineClass(
	function DatasetBase(json, prototype, parent, $bind) {
		this.json = json;
		this.prototype = prototype;
		this.parent = parent;
		this.$bind = $bind; // Name of property in parent if this dataset is a child dataset (e.g. array)
		this.root = (parent && parent.root) || this;

		this.dirtyProperties = [];
		this.childDatasets = {};
		this.deltaChangeListeners = [];
	},
	null, {
		destroy: function() {
			if (this.parent && this.parent.childDatasets) {
				delete this.parent.childDatasets[this.$bind];
			}
			this.root = null;
			this.parent = null;
			this.prototype = null;
			this.json = null;
			this.dirtyProperties = null;
			this.deltaChangeListeners = null;

			if (this.childDatasets) {
				var $binds = Object.keys(this.childDatasets);
				for (var i = 0; i < $binds.length; i++) {
					var $bind = $binds[i];
					if (this.childDatasets[$bind]) {
						this.childDatasets[$bind].destroy();
					}
				}
				this.childDatasets = null;
			}
			this.destroyed = true;
		},
		/**
		 * Get value of property $bind
		 * 
		 * useWorkingCopy: Set to true if working copy mode is used or false if stateless is used
		 *                 This will only affect the kind of urls returned for imags and texts
		 * 
		 * Note: 
		 * For reference fields, the returned value is
		 * null or 
		 * {
		 *   $value: ... // value of "key" property of referenced entity e.g. EUR for x-ref on currency
		 *   $title: ... // optional if set by server
		 *   $description: ... // optional if set by server
		 * }
		 */
		getValue: function($bind, useWorkingCopy) {
			if ($bind.charAt(0) === "$" && !this.prototype.propExists($bind)) {
				// $-properties like $url etc
				return this.json[$bind];
			} else if (this.prototype.propIsSimple($bind)) {
				return this.json[$bind];
			} else if (this.prototype.propIsReference($bind)) {
				return this._getValueReference($bind);
			} else if (this.prototype.propIsImage($bind)) {
				return this._getValueImage($bind, useWorkingCopy);
			} else if (this.prototype.propIsText($bind)) {
				return this._getValueText($bind, useWorkingCopy);
			} else if (this.prototype.propIsDocument($bind) || this.prototype.propIsBinary($bind)) {
				return this._getValueDocument($bind, useWorkingCopy);
			} else if (this.prototype.propIsArray($bind)) {
				throw new Error("Use getChild to access arrays");
			}
		},
		/**
		 * Set value of property $bind
		 * 
		 */
		setValue: function($bind, value) {
			if (this.prototype.propIsSimple($bind)) {
				var oldValue = this.json[$bind];
				if (oldValue !== value) {
					this.json[$bind] = value;
					this.setDirty($bind);
				}
			} else if (this.prototype.propIsImage($bind)) {
				var oldValue = this.json[$bind];
				this.json[$bind] = value;
				this.setDirty($bind);
			} else if (this.prototype.propIsText($bind)) {
				var oldValue = (typeof this.json[$bind] !== "string") ? value : this.json[$bind];
				this.json[$bind] = value;
				if (oldValue !== value) {
					this.json[$bind] = value;
					this.setDirty($bind);
				}
			} else if (this.prototype.propIsReference($bind)) {
				this._setValueReference($bind, value);
			} else if (this.prototype.propIsArray($bind)) {
				throw new Error("Use getChild to access arrays");
			}
		},
		getClientContext: function(prop) {
			var ctx = this.json.$clientContext || {};
			if (!prop) {
				return ctx;
			}
			return ctx[prop];
		},
		// All sData url are working copy
		// Given by application or url param for test urls
		isWorkingCopyMode: function() {
			return this.getClientContext("$mobileProtocol") === "workingcopy";
		},
		// All sData url are stateless
		isStateLessMode: function() {
			return this.getClientContext("$mobileProtocol") === "stateless";
		},
		/*
		 * Get value of reference field, used by getValue
		 * Can be either
		 * null if value of referenced field is null
		 * or
		 * {
		 *   $value: xxx value of reference field
		 *   $title: ...
		 *   $description: ...
		 * }
		 */
		_getValueReference: function($bind) {
			var value = this.json[$bind];
			var $refValueName = this.prototype.propGetRefValueName($bind);
			var $value = this.json[$refValueName];
			if ($value == null) {
				return null;
			}
			value = value || {};
			value.$value = $value;
			return value;
		},
		_getValueImage: function($bind, useWorkingCopy) {
			if (this.json[$bind]) {
				var prop = "$url";
				// Currently, useWorkingCopy is always != true for images
				// this is wrong since we should use the WC url
				if (useWorkingCopy !== true && this.prototype.root.isWorkingCopyFacet()) {
					prop = "$urlStateless"
				}
				var fieldProto = this.prototype.propGetProto($bind);
				var imageUrl = (fieldProto.getValueByPath(prop) || "");
				return this.resolveExpression(imageUrl, true) + '?salt=' + ((new Date()).getTime());
			} else {
				return null
			}
		},
		_getValueText: function($bind, useWorkingCopy) {
			var prop = "$url";
			if (useWorkingCopy !== true && this.prototype.root.isWorkingCopyFacet()) {
				prop = "$urlStateless"
			}
			var fieldProto = this.prototype.propGetProto($bind);
			var textUrl = (fieldProto.getValueByPath(prop) || "");
			return this.resolveExpression(textUrl, true);
		},
		_getValueDocument: function($bind, useWorkingCopy) {
			if (this.json[$bind] == null) { // no value means no data
				return null;
			}
			var prop = "$url";
			if (useWorkingCopy !== true && this.prototype.root.isWorkingCopyFacet()) {
				prop = "$urlStateless"
			}
			var fieldProto = this.prototype.propGetProto($bind);
			var textUrl = (fieldProto.getValueByPath(prop) || "");
			return this.resolveExpression(textUrl, true);
		},
		/*
		 * Set value of reference field
		 * Currently, value must be a simple type containing the key of the referenced entity
		 */
		_setValueReference: function($bind, value) {
			var $refValueName = this.prototype.propGetRefValueName($bind);
			var oldValue = this.json[$refValueName];
			if (oldValue !== value) {
				this.json[$bind] = {}; // WCUR_REF: x-reference
				this.json[$refValueName] = value; // WCUR: x-string

				this.setDirty($bind);
				this.setDirty($refValueName);
			}
		},
		/**
		 * 
		 * Return child dataset for property $bind
		 * $bind must be an array property
		 */
		getChild: function($bind) {
			var child = this.childDatasets[$bind];
			if (!child) {
				if (this.prototype.propIsArray($bind)) {
					var data = this.json[$bind];
					if (!data) {
						data = this.json[$bind] = [];
					}
					var klass;
					if (this.prototype.propIsSingleArray($bind)) {
						// Single column array
						klass = datasetUtils.getImplementation("SingleArrayDataset");
					} else {
						// Normal multi column array
						klass = datasetUtils.getImplementation("MultiArrayDataset");
					}
					var proto = this.prototype.propGetProto($bind);
					child = new klass(data, proto, this, $bind);
					this.childDatasets[$bind] = child;
				}
			}
			return child;
		},
		/**
		 * Set a named property ($bind) to dirty
		 * $bind can be the $uuid of a row of an array too
		 * 
		 * setDirty will report the dirty flag to the parent, so if a child is dirty asking root.isDirty will return true
		 */
		setDirty: function($bind) {
			if (this.dirtyProperties && this.dirtyProperties.indexOf($bind) < 0) {
				console.log("dataset setDirty", $bind);
				this.dirtyProperties.push($bind);
			}
			if (this.parent) {
				this.parent.setDirty(this.$bind);
			}
		},
		/**
		 * Check if dataset is dirty
		 * $bind (optional): If $bind is given, only check if property $bind is dirty
		 */
		isDirty: function($bind) {
			if ($bind != null) {
				return (this.dirtyProperties && this.dirtyProperties.length > 0 && this.dirtyProperties.indexOf($bind) > -1) || false;
			}
			return (this.dirtyProperties && this.dirtyProperties.length > 0) || false;
		},
		/**
		 * Mark dataset as clean (remove all dirty flags)
		 * $bind (optional): If $bind is given, only clean this property
		 * 
		 * includeChildren (optional): If false, to not include children, should only be used internally to avoid infinite child<->parent calls
		 */
		setClean: function($bind, includeChildren) {
			includeChildren = includeChildren == null ? true : false;
			if ($bind != null) {
				var idx = this.dirtyProperties.indexOf($bind);
				if (idx >= 0) {
					this.dirtyProperties.splice(idx, 1);
					if (includeChildren && this.childDatasets[$bind]) {
						this.childDatasets[$bind].setClean();
					}
				}
				// For reference fields, clean related field dirty flag too
				// We check if prop exists first since it's not always the case
				// E.g. a row dataset has a $bind uuid which is not contained in it's prototype
				if (this.prototype.propExists($bind) && this.prototype.propIsReference($bind)) {
					this.setClean(this.prototype.propGetRefValueName($bind));
				}
			} else {
				this.dirtyProperties = [];
				if (includeChildren) {
					for (var childName in this.childDatasets) {
						var child = this.childDatasets[childName];
						child.setClean();
					}
				}
			}
			// Check if all is clean, report to parent if yes
			if (this.parent && this.dirtyProperties.length < 1) {
				this.parent.setClean(this.$bind, false);
			}
		},
		/**
		 * 
		 * @param $bind
		 * @returns
		 */
		getDiagnoses: function($bind) {
			var diags = this.getValueByPath("$properties." + $bind + ".$diagnoses");

			if (this.prototype.propExists($bind) && this.prototype.propIsReference($bind)) {
				var $bindValue = this.prototype.propGetRefValueName($bind);
				var valueFieldDiags = this.getValueByPath("$properties." + $bindValue + ".$diagnoses");
				diags = diags || [];
				Array.prototype.push.apply(diags, valueFieldDiags);
			}
			return diags || [];
		},
		clearDiagnoses: function($bind) {
			var props = [$bind];
			if (this.prototype.propExists($bind) && this.prototype.propIsReference($bind)) {
				props.push(this.prototype.propGetRefValueName($bind));
			}
			var self = this;
			props.forEach(function(prop) {
				var diags = self.getValueByPath("$properties." + prop + ".$diagnoses");
				if (diags && diags.length > 0) {
					self.json["$properties"][prop]["$diagnoses"] = [];
				}
			})
		},
		/**
		 * Gets the current JSON data represented by this dataset
		 * Used for stateless mode
		 */
		getData: function() {
			/*
			 * return this.json;
			 * will not work because the internal data structures change for simple property arrays (wrapped with object on read)
			 */
			var data = {};
			var props = Object.keys(this.json);
			for (var i = 0; i < props.length; i++) {
				var $bind = props[i];
				var childDataset = this.childDatasets[$bind];
				if (childDataset) {
					// If there is a child dataset for the property, let it handle to create the data
					data[$bind] = childDataset.getData();
				} else if (this.prototype.propIsSingleArray($bind)) {
					childDataset = this.getChild($bind);
					data[$bind] = childDataset.getData();
				} else {
					data[$bind] = this.json[$bind];
				}
			}
			return data;
		},
		/**
		 * Gets all the JSON data including only properties that are dirty, including children
		 * Used for working copy mode
		 */
		getDataDelta: function(forceUpdateAll) {
			var delta = {
				$uuid: this.json.$uuid,
			};

			if (this.isRoot()) {
				delta.$url = this.getUrl();
				delta.$etag = this.json.$etag;
			}

			var i;
			var properties;
			if (forceUpdateAll === true) {
				properties = this.prototype.getPropertyNames();
			} else {
				properties = this.dirtyProperties;
			}
			for (i = 0; i < properties.length; i++) {
				var $bind = properties[i];
				if (this.childDatasets[$bind]) { //  Array or something complex?
					delta[$bind] = this.childDatasets[$bind].getDataDelta(forceUpdateAll);
				} else {
					delta[$bind] = this.json[$bind];
				}
			}

			return delta;
		},
		/*Get data for text content upload :  protocol is not like other datas
		 */
		getDataText: function($bind) {
			var delta;
			var i;
			for (i = 0; i < this.dirtyProperties.length; i++) {
				var $bindDirty = this.dirtyProperties[i];
				if ($bindDirty === $bind) {
					delta = this.json[$bind]
				}
			}

			return delta;
		},
		/**
		 * Resolve expressionen on dataset and datasets prototype
		 * isUrl: Is the repression an url? If yes, expressions like abc={xxx} will be abc=<uri encode xxx>
		 * extraData: Key + value to check for matches first (E.g. $parameters when resolving link urls) 
		 */
		resolveExpression: function(exp, isUrl, extraData) {
			var self = this;
			var rescan = true;
			var max = 20;
			if (exp == null) {
				return exp;
			}
			while (rescan && ((max--) > 0) && exp.replace) {
				rescan = false;
				exp = exp.replace(/\{(\S+?)\}/g, function(m, g1, idx) {
					var value;
					// Encode if we resolve an url that contains something like EXTRA_CODE={EXTRA_CODE} ?
					var encode = isUrl && idx > 0 && exp.charAt(idx - 1) === "=";
					if (extraData && g1 in extraData) {
						value = extraData[g1];
						if (value && value.indexOf && value.indexOf("{") === 0) {
							rescan = true;
						} else if (encode) {
							value = encodeURIComponent(value);
						}
					} else if (g1 in self.json) {
						value = self.json[g1];
						if (value && value.indexOf && value.indexOf("{") === 0) {
							rescan = true;
						} else if (encode) {
							value = encodeURIComponent(value);
						}
					} else if (self.root != self && g1 in self.root.json) {
						value = self.root.json[g1];
						if (value && value.indexOf && value.indexOf("{") === 0) {
							rescan = true;
						} else if (encode) {
							value = encodeURIComponent(value);
						}
					} else {
						value = self.prototype.resolveExpression(m);
						rescan = rescan || (value != m && value && value.indexOf && value.indexOf("{") >= 0);
					}
					return value;
				});
			}
			return exp;
		},
		/**
		 * Computes Url of current resource by using $url of payload
		 * 
		 * useProtoype$Url: When NOT true, use $url of dataset or prototype for fallback if not contained in dataset
		 * 					When true: Use $url of prototype (this is the stateless URL for the resource)
		 *
		 * return:
		 * dataset based url
		 * http://localhost:8124/sdata/x3/erp/GX3APP/$workingCopies('6958bd2f-6bb4-46e0-bed7-0c4cc2692e30')?representation=AQMCRUDM.$edit
		 * prototype based url
		 * http://localhost:8124/sdata/x3/erp/GX3APP/AQMDEVICE('8')?representation=AQMCRUDM.$edit
		 * param $bind need only for text content upload, put url come from $url or the property $bind
		 */
		getUrl: function(useProtoype$Url, $bind) {
			var url;
			if ($bind) {
				url = this.prototype.getFieldUpdateUrl($bind);
			}
			if (useProtoype$Url !== true) {
				return this.resolveExpression(url || this.json.$url || this.prototype.json.$url);
			} else {
				return this.resolveExpression(url || this.prototype.json.$url);
			}
		},
		getFacet: function() {
			if (this.isRoot()) {
				return this.prototype.getFacet();
			}
		},

		getAction: function($actionName) {
			var actionP = this.prototype.getValueByPath("$actions." + $actionName); // Must not be null in proto
			var actionD = this.getValueByPath("$actions." + $actionName) || {}; // Could be null in payload
			if (!actionP) {
				return;
			}
			var action = $.extend(true, {}, actionP, actionD);
			if (action.$isExcluded === true || helpers.isOfficeLink(action)) {
				return;
			}
			return action;
		},
		/**
		 * Removes excluded and office links
		 */
		getActions: function() {
			var actionsP = this.prototype.getValueByPath("$actions");
			if (!actionsP) {
				return;
			}
			var actions = {};
			var action;
			for (var actionName in actionsP) {
				action = this.getAction(actionName);
				if (action) {
					actions[actionName] = action;
				}
			}
			return actions;
		},
		getLink: function($linkName, $bind) {
			var link = datasetUtils.checkQueryFullPage(this.prototype, $linkName);
			if (link) {
				return link;
			}
			var path = $bind ? "$properties." + $bind + ".$item.$links." + $linkName : "$links." + $linkName;
			var linkP = this.prototype.getValueByPath(path);
			var linkD = this.getValueByPath(path);

			if (!linkP && !linkD) {
				return;
			}
			link = $.extend(true, {}, linkP, linkD);
			if (link.$url && /\{(\S+?)\}/.test(link.$url)) {
				link.$url = this.resolveExpression(link.$url)
			}
			if (link.$isExcluded === true || helpers.isOfficeLink(link)) {
				return;
			}
			return link;
		},
		/**
		 * Removes excluded and office links
		 */
		getLinks: function($bind) {
			var self = this;
			var path = $bind ? "$properties." + $bind + ".$item.$links" : "$links";
			var linksP = this.prototype.getValueByPath(path);
			var linksNames = [];
			if (linksP) {
				for (var linkName in linksP) {
					linksNames.push(linkName);
				}
			}
			var linksD = this.getValueByPath(path);
			if (linksD) {
				for (var linkName in linksD) {
					linksNames.push(linkName);
				}
			}
			var links = {};
			var link;
			linksNames.forEach(function(linkName) {
				link = self.getLink(linkName, $bind);
				if (link) {
					links[linkName] = link;
				}
			});
			return links;
		},
		/** 
		 * Is this a root dataset (e.g. page level)
		 */
		isRoot: function() {
			return this != null && this == this.root;
		},
		getRoot: function() {
			return this.root;
		},
		getMetaData: function($bind) {
			var protoMeta = this.prototype.getValueByPath("$properties." + $bind);
			var dataMeta = this.getValueByPath("$properties." + $bind);
			var meta = $.extend(true, {}, protoMeta, dataMeta);
			return meta;
		},
		/**
		 * Apply delta comming from server if we are in working copy mode
		 * context: null or template
		 */
		applyDelta: function(delta, context) {
			var i;
			/*
			 *  We collect all modified fields and fire events at the very end
			 *  since there are properties like CUR_REF and CUR that are linked to each other
			 *  so we need to update all of the first before firing the event
			 */

			var deltaNotifications = {};

			var properties = Object.keys(delta);
			for (var ii = 0, jj = properties.length; ii < jj; ii++) {
				var property = properties[ii];
				var value = delta[property];
				this._deltaSetValue(property, value, deltaNotifications, context);
			}

			for (var $bind in deltaNotifications) {
				var notify = deltaNotifications[$bind];
				if (notify.$value) {
					this._deltaManValueChanged($bind);
				}
				if (notify.$meta) {
					this._deltaManMetaChanged($bind);
				}
				if (notify.$action) {
					this._deltaManActionChanged($bind, notify.$action);
				}
				if (notify.$link) {
					this._deltaManLinkChanged($bind, notify.$link);
				}
			}
		},
		/*
		 * Invoked by applyDelta to apply delta of a single property
		 * context: null or template
		 */
		_deltaSetValue: function($bind, value, deltaNotifications, context) {
			if ("template" === context) {
				if ($bind.smStartsWith("$") || !this.prototype.propExists($bind)) {
					// Skip $ fields
					// console.log("template", $bind, "skipped");
					return;
				}
				var meta = this.getMetaData($bind);
				if (this.prototype.propIsSimple($bind) && this.prototype.propIsRefValue($bind)) {
					var refFieldName = this.prototype.propGetRefProperty($bind);
					if (refFieldName && datasetUtils.isDisabled(this.getMetaData(refFieldName))) {
						// Skip CUR if CUR_REF and CUR_REF is disabled
						// console.log("template", $bind, "skipped", "reference field is disabled", refFieldName);
						return;
					}
				} else if (datasetUtils.isDisabled(meta)) {
					// console.log("template", $bind, "skipped");
					// We populate only reference field value 
					return;
				}
				// console.log("template", $bind, " not skipped");
			}
			var i = this.dirtyProperties.indexOf($bind);
			if (i >= 0) {
				this.dirtyProperties.splice(i, 1);
			}
			if ($bind === "$properties") {
				this._deltaSetProperties(value, deltaNotifications);
			} else if ($bind === "$actions") {
				this._deltaSetActions(value, deltaNotifications);
			} else if ($bind === "$links") {
				this._deltaSetLinks(value, deltaNotifications);
			} else if ($bind.smStartsWith("$")) {
				// TODO: Make this correct and recursive including notifications
				this.json[$bind] = value;
			} else {
				if (!this.prototype.propExists($bind)) {
					// Non $ properties that are sent by the server but are not present in the prototype
					// Example is ETag on X3 representations
					// We just add them to the json without taking too much care for now
					this.json[$bind] = value;
				} else if (this.prototype.propIsSimple($bind)) {
					var oldValue = this.json[$bind];
					this.json[$bind] = value;
					if (oldValue !== value) {
						if (this.prototype.propIsRefValue($bind)) {
							// Property used to backup a reference field
							var refField = this.prototype.propGetRefProperty($bind);
							var notify = deltaNotifications[refField] = deltaNotifications[refField] || {};
							notify.$value = true;
						} else {
							// Normal property
							deltaNotifications[$bind] = deltaNotifications[$bind] || {};
							deltaNotifications[$bind].$value = true;
						}
					}
				} else if (this.prototype.propIsReference($bind)) {
					var oldValue = this.json[$bind];
					this.json[$bind] = value;
					var notify = deltaNotifications[$bind] = deltaNotifications[$bind] || {};
					notify.$value = true;
				} else if (this.prototype.propIsArray($bind)) {
					var array = this.getChild($bind);
					array.applyDelta(value, context);
				}
			}
		},
		/*
		 * Traverse $properties
		 */
		_deltaSetProperties: function(value, deltaNotifications) {
			// For meta data changes, we just notify the keys beneath $properties to allow widgets to repaint
			var properties = Object.keys(value);
			for (var ii = 0, jj = properties.length; ii < jj; ii++) {
				var property = properties[ii];
				this.json.$properties = this.json.$properties || {};
				this.json.$properties[property] = value[property];


				if (this.prototype.propIsRefValue(property)) {
					// Property used to backup a reference field
					var refField = this.prototype.propGetRefProperty(property);
					var notify = deltaNotifications[refField] = deltaNotifications[refField] || {};
					notify.$meta = true;
				} else {
					deltaNotifications[property] = deltaNotifications[property] || {};
					deltaNotifications[property].$meta = true;
				}
			}
		},
		/*
		 * Check for changes in $actions block
		 */
		_deltaSetActions: function(value, deltaNotifications) {
			var self = this;
			var actions = Object.keys(value);
			for (var ii = 0, jj = actions.length; ii < jj; ii++) {
				var action = actions[ii];
				this.json.$actions = this.json.$actions || {};
				this.json.$actions[action] = this.json.$actions[action] || {};
				var keys = Object.keys(value[action]);

				var changed = false;
				if (keys.some(function(key) {
						if (_linksAndActionsMetaKeys.indexOf(key) > -1 && value[action][key] !== self.json.$actions[action][key]) {
							return true;
						}
					})) {
					changed = true;
				}
				this.json.$actions[action] = $.extend(true, this.json.$actions[action], value[action]);

				if (changed === true) {
					var status = {};
					var $isHidden = this.json.$actions[action].$isHidden;
					if ($isHidden == null) {
						$isHidden = this.prototype.getValueByPath("$actions." + action + ".$isHidden");
					}
					if ($isHidden != null) {
						status.$isHidden = $isHidden;
					}
					var $isDisabled = this.json.$actions[action].$isDisabled;
					if ($isDisabled == null) {
						$isDisabled = this.prototype.getValueByPath("$actions." + action + ".$isDisabled");
					}
					if ($isDisabled != null) {
						status.$isDisabled = $isDisabled;
					}

					deltaNotifications[action] = deltaNotifications[action] || {};
					deltaNotifications[action].$action = status;
				}
			}
		},
		/*
		 * Check for changes in $links block
		 * Currently, only $links on root level are checked
		 * Links on properties (e.g. $lookup) are handled by the property specific meta data change notification
		 */
		_deltaSetLinks: function(value, deltaNotifications) {
			var self = this;
			var links = Object.keys(value);
			for (var ii = 0, jj = links.length; ii < jj; ii++) {
				var link = links[ii];
				this.json.$links = this.json.$links || {};
				this.json.$links[link] = this.json.$links[link] || {};
				var keys = Object.keys(value[link]);

				var changed = false;
				if (keys.some(function(key) {
						if (_linksAndActionsMetaKeys.indexOf(key) > -1 && value[link][key] !== self.json.$links[link][key]) {
							return true;
						}
					})) {
					changed = true;
				}
				this.json.$links[link] = value[link];

				if (changed === true) {
					var status = {};
					var $isHidden = this.json.$links[link].$isHidden;
					if ($isHidden == null) {
						$isHidden = this.prototype.getValueByPath("$links." + link + ".$isHidden");
					}
					if ($isHidden != null) {
						status.$isHidden = $isHidden;
					}
					var $isDisabled = this.json.$links[link].$isDisabled;
					if ($isDisabled == null) {
						$isDisabled = this.prototype.getValueByPath("$links." + link + ".$isDisabled");
					}
					if ($isDisabled != null) {
						status.$isDisabled = $isDisabled;
					}

					deltaNotifications[link] = deltaNotifications[link] || {};
					deltaNotifications[link].$link = status;
				}
			}
		},
		/* 
		 * Invoked by _deltaSetValue when the server sent a modified value for a given property
		 */
		_deltaManValueChanged: function($bind) {
			for (var i = 0; i < this.deltaChangeListeners.length; i++) {
				this.deltaChangeListeners[i].onDeltaValueChanged(this, $bind);
			}
		},
		_deltaManMetaChanged: function($bind) {
			for (var i = 0; i < this.deltaChangeListeners.length; i++) {
				this.deltaChangeListeners[i].onDeltaMetaChanged(this, $bind);
			}
		},
		_deltaManLinkChanged: function($bind, metaData) {
			for (var i = 0; i < this.deltaChangeListeners.length; i++) {
				this.deltaChangeListeners[i].onDeltaLinkChanged(this, $bind, null, metaData);
			}
		},
		_deltaManActionChanged: function($bind, metaData) {
			for (var i = 0; i < this.deltaChangeListeners.length; i++) {
				this.deltaChangeListeners[i].onDeltaActionChanged(this, $bind, metaData);
			}
		},
		getValueByPath: function(path) {
			return helpers.getValueByPath(this.json, path);
		},
		addDeltaChangeListener: function(listener) {
			if (this.deltaChangeListeners.indexOf(listener) < 0) {
				this.deltaChangeListeners.push(listener);
			}
		},
		removeDeltaChangeListener: function(listener) {
			if (!this.deltaChangeListeners) {
				return;
			}
			var idx = this.deltaChangeListeners.indexOf(listener);
			if (idx >= 0) {
				this.deltaChangeListeners.splice(idx, 1);
			}
		},

		/**
		 * Compute last update time of this dataset
		 * 
		 * Return: 
		 * {
		 *   dateTime: milliseconds
		 *   level: "verytainted" | "tainted" | "fresh"
		 * }
		 * 
		 */
		getDataFreshness: function() {
			var freshness = {
				dateTime: new Date().getTime(),
				level: "verytainted"
			};

			function _check$ResourcesTime($resources) {
				if (!$resources) {
					return;
				}
				var utcTime = new Date().getTime();
				$resources.forEach(function(item) {
					if (item.$cache) {
						utcTime = Math.min(utils.getTimeFromString(item.$cache.$lastUpdated), utcTime);
					}
				});
				freshness.dateTime = utcTime;
			};

			if (this.isRoot()) {
				if (this.json.$cache) {
					freshness.dateTime = Math.min(freshness.dateTime, utils.getTimeFromString(this.json.$cache.$lastUpdated));
				} else {
					_check$ResourcesTime(this.json.$resources);
				}

				var diffDays = Math.round((new Date().getTime() - freshness.dateTime) / (24 * 60 * 60 * 1000));

				if (diffDays <= 7) freshness.level = "tainted";
				if (diffDays <= 1) freshness.level = "fresh";

				return freshness;
			} else {
				return this.root.getDataFreshness();
			}
		},
		buildTemplateData: function() {
			var result = {};
			var properties = Object.keys(this.json);
			for (var ii = 0, jj = properties.length; ii < jj; ii++) {
				var $bind = properties[ii];
				if ($bind.charAt(0) === "$" || !this.prototype.propExists($bind)) {
					continue
				} else if (this.prototype.propIsSimple($bind)) {
					result[$bind] = this.json[$bind];
				} else if (this.prototype.propIsReference($bind)) {
					result[$bind] = this.json[$bind];
				} else if (this.prototype.propIsArray($bind)) {
					var array = this.getChild($bind);
					result[$bind] = array.buildTemplateData(this.getChild($bind));
				}
			}
			return result;
		},
		/**
		 * Return json data purged from $  and other non-data properties
		 * Used for templates and drafts
		 */
		getTemplateData: function() {
			var result = this.buildTemplateData();
			return $.extend(true, null, result);
		},
		/**
		 * Update the current datasEt with the data coming from template
		 */
		setTemplateData: function(page, data) {
			var dataProcessor = new datasetUtils.DataProcessor();
			dataProcessor.process({
				addRowId: {}
			}, data);
			this.applyDelta(data, "template");
			page.controller.forceUpdateServer();
		},
		setDraftData: function(data) {
			var dataProcessor = new datasetUtils.DataProcessor();
			dataProcessor.process({
				addRowId: {}
			}, data);
			this.applyDelta(data, "template");
		}
	}
);