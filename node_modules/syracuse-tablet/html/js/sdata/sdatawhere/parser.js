"use strict";
var token = require('./token');
var operators = require('./operator');
var tokenizer = require('./tokenizer');
var expression = require('./expression');

exports.Parser = new function() {
	var self = this;
	var _maxPrecedence = 8;

	function _finishBetween(tokens, tokenIndex, exp, precedence) {
		if (tokenIndex[0] == tokens.length || !tokens[tokenIndex[0]].matches("and")) {
			throw new Error("invalid expression: expected 'and' after " + tokens[tokenIndex[0] - 1].getRemainingText());
		}
		tokenIndex[0]++;
		var arg = _parseExpression(tokens, tokenIndex, precedence);
		exp.children.push(arg);
	}

	function _parseExpression(tokens, tokenIndex, precedence) {
		var exp = _parseTerm(tokens, tokenIndex);
		while (tokenIndex[0] < tokens.length) {
			var tk = tokens[tokenIndex[0]];
			var op = tk.value instanceof operators.Operator ? tk.value : null;
			if (op == null || !op.isInfix || op.precedence > precedence) {
				break;
			}
			tokenIndex[0]++;
			if (op.code == "in") {
				if (tokenIndex[0] === tokens.length || !tokens[tokenIndex[0]].matches("(")) {
					throw new Error("invalid expression: '(' expected after " + tk.getRemainingText());
				}
				tokenIndex[0]++;
				exp = new expression.Expression({
					operator: op,
					expression1: exp
				});
				_parseArguments(tokens, tk, tokenIndex, exp.children);
			} else {
				var arg = _parseExpression(tokens, tokenIndex, op.precedence - 1);
				exp = new expression.Expression({
					operator: op,
					expression1: exp,
					expression2: arg
				});
				if (op.code == "between") {
					_finishBetween(tokens, tokenIndex, exp, op.precedence);
				}
			}
			if (!op.isAssociative && op.precedence == precedence) {
				return exp;
			}
		}
		return exp;
	}

	function _parseTerm(tokens, tokenIndex) {
		if (tokenIndex[0] == tokens.length) {
			throw new Error("premature end of expression");
		}
		var tk = tokens[tokenIndex[0]];
		switch (tk.type) {
			case token.tokenType.identifier:
				tokenIndex[0]++;
				if (tokenIndex[0] < tokens.length && tokens[tokenIndex[0]].matches("(")) {
					return _parseFunctionCall(tokens, tk, tokenIndex);
				} else {
					return new expression.Expression({
						expressionType: "identifier",
						value: tk.value
					});
				}
			case token.tokenType.literal:
				tokenIndex[0]++;
				return new expression.Expression({
					expressionType: "literal",
					value: tk.value,
					svalue: tk.svalue,
					dataType: tk.dataType
				});
			case token.tokenType.operator:
				var op = tk.value;
				if (!op.isPrefix) {
					throw new Error("invalid expression: expected beginning of term at " + tk.getRemainingText());
				}
				tokenIndex[0]++;
				return _parsePrefixOperator(tokens, op, tokenIndex);
			default:
				throw new Error("internal error: bad token type " + tk.type);
		}
	}

	function _parseArguments(tokens, tk, tokenIndex, arguments0) {
		if (tokenIndex[0] < tokens.length && tokens[tokenIndex[0]].matches(")")) {
			tokenIndex[0]++;
			return;
		}
		while (tokenIndex[0] < tokens.length) {
			var arg = _parseExpression(tokens, tokenIndex, _maxPrecedence);
			arguments0.push(arg);
			if (tokenIndex[0] < tokens.length && tokens[tokenIndex[0]].matches(")")) {
				tokenIndex[0]++;
				return;
			}
			if (tokenIndex[0] == tokens.length || !tokens[tokenIndex[0]].matches(",")) {
				throw new Error("invalid expression: expected ',' or ')' at " + tokens[tokenIndex[0]].getRemainingText());
			}
			tokenIndex[0]++;
		}
		throw new Error("invalid function call syntax: argument missing after " + tk.getRemainingText());
	}

	function _parsePrefixOperator(tokens, op, tokenIndex) {
		var arg1;
		switch (op.code) {
			case "-":
			case "not":
				arg1 = _parseExpression(tokens, tokenIndex, 1);
				return new expression.Expression({
					operator: op,
					expression1: arg1
				});
			case "(":
				arg1 = _parseExpression(tokens, tokenIndex, op.precedence);
				//require('term').stream.print('???' + tokens[tokenIndex[0]].value);
				if (tokenIndex[0] == tokens.length || !tokens[tokenIndex[0]].matches(")")) {
					throw new Error("invalid expression: expected ')' after " + tokens[tokenIndex[0] - 1].getRemainingText());
				}
				tokenIndex[0]++;
				return arg1;
			default:
				throw new Error("internal error: bad prefix operator " + op.code);
		}
	}

	function _parseFunctionCall(tokens, tk, tokenIndex) {
		tokenIndex[0]++;
		var exp = new expression.Expression({
			expressionType: "function",
			value: tk.value
		});
		_parseArguments(tokens, tk, tokenIndex, exp.children);
		return exp;
	}

	self.parse = function(str) {
		if (str == null || str.length == 0) {
			return null;
		}
		var tokens = tokenizer.Tokenizer.tokenize(str);
		var tokenIndex = [];
		tokenIndex[0] = 0;
		var exp = _parseExpression(tokens, tokenIndex, _maxPrecedence);
		if (tokenIndex[0] != tokens.length) {
			throw new Error("invalid expression: unexpected token at " + tokens[tokenIndex[0]].getRemainingText());
		}
		return exp;
	};

	return self;
};