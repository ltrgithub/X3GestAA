"use strict";

var ajax = require('syracuse-tablet/html/js/common/ajax');
var __ajax = ajax;

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var helpers = require('syracuse-tablet/html/js/common/helpers');

var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');
var dataset = require('syracuse-tablet/html/js/sdata/dataset');
var Prototype = require('syracuse-tablet/html/js/sdata/prototype').Prototype;
var articleParser = require("syracuse-tablet/html/js/controls/articleParser");

var sdataRequesterLocal = require("syracuse-tablet/html/js/sdata/sdataRequesterLocal");
var sdataRequesterOffline = require("syracuse-tablet/html/js/sdata/sdataRequesterOffline");
var sdataStatic = require('syracuse-tablet/html/js/sdata/sdataStatic');
var metaDataCache = require('syracuse-tablet/html/js/sdata/cache/metaDataCache');
var gadget = require('syracuse-tablet/html/js/controls/vignette/gadget');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("SDataRequester", false);

/**
 * Used by test cases to use ajax stub during some tests
 */
exports.__testInjectAjax = function(ajaxStub) {
	ajax = ajaxStub;
}
exports.__testRestoreAjax = function(ajaxStub) {
	ajax = __ajax;
}

/**
 * 
 * Get data from the server according to link information
 * 
 * $link: {
 *   $url: ...
 *   $method: ...
 * }
 * 
 * 
 * options: {
 * 
 * 	   Can be used to pass in predefined data structures if a page is reloaded and not fully loaded
 *     e.g. a protoype will not change when fetching the next page of a query

 *     prototype:
 *     page:
 *     data:
 *     useMetaFromCache: true -> do not try to load proto and article from server
 * }
 * 
 * 
 * return:
 * {
 *   prototype: prototype of navigation target
 *   dataset: data of navigation target,
 *   page: article json and views 
 *   isWorkingCopy: true / false
 * }
 * 
 * Injected to dataset
 * dataset in the return is comming from the server but the client add the following data to it:
 * dataset: {
 *     $clientContext: {
 *         endpoint: x3.erp.GX3APP
 *         application: STD_X3_EXPENSES
 *         protocol: workingcopy|stateless
 *     }
 * }
 * Whenever a navigation occurs, the controller will add the context to the new page so we 
 * know the "context" without the need of managing a global state for this
 * 
 * 
 * Special sdata urls:
 * 
 * Load mobile application:
 * .../syracuse/collaboration/syracuse/mobileApplications(applicationName%20eq%20'STD_X3_ERP_EXPENSES_ONLINE')?representation=mobileApplication.$details&$mobileEndpoint=x3.erp.GX3APP
 * Note $mobileEndpoint must be present to define the endpoint to load the app from
 * 
 * Load Dashboard
 * 
 */
exports.fetchPageData = function($link, options) {
	options = options || {};
	var $url = $link.$url;
	var urlParsed = jsutils.parseURL($link.$url);
	var $method = $link.$method;
	var self = this;
	// Flag if the current page will be managed by a working copy
	var isWorkingCopy = $url.indexOf("$workingCopies") > -1;

	var $mobileProtocol = $url.indexOf("$mobileProtocol=workingcopy") > -1 ? "workingcopy" : "stateless";

	if ($link.$method === "POST" && isWorkingCopy) {
		$url = $url + "&trackingId=" + utils.UUID();
	}

	// Handle client side hard coded entities
	if (protoHelpers.isLocaleUrl($url)) {
		return sdataRequesterLocal.fetchPageData($link, options);
	}

	// If the page to be opened is opened in the context of a stateless app
	// we can assume all meta data (proto+article) is available in the local
	// caches, so no need to fetch them below
	if ($mobileProtocol === "stateless") {
		options.useMetaFromCache = true;
	}

	var prototypeJson;
	var datasetJson;
	var articleJson;
	var viewsJson;
	log && log("Fetching: " + $url + " (" + $method + ")");

	// Fix facet recognition for some escaped urls
	$url = $url.replace(/\.\%24/g, ".$");

	return exports.getPrototype($url, options)
		.then(function(proto) {
			prototypeJson = proto;
			if (urlParsed.query && urlParsed.query.draftId) {
				// Read the draft
				return sdataUtils.draftReadData(urlParsed.query.draftId)
			} else {
				return _getData($url, $method, prototypeJson, null, options);
			}
		})
		.then(function(data) {
			datasetJson = data;
			return _getPage($url, $method, prototypeJson, datasetJson, options);
		})
		.then(function(page) {
			return protoHelpers.checkTransform($url, prototypeJson, datasetJson, page);
		})
		.then(function(pageDataTransformed) {
			var pageData = {};
			pageData.prototype = new Prototype(pageDataTransformed.prototypeJson);
			pageData.dataset = new dataset.Dataset(pageDataTransformed.datasetJson, pageData.prototype);
			pageData.isWorkingCopy = isWorkingCopy;
			pageData.$url = $url;
			pageData.$originalUrl = $url; // Will be overriden by pageFactory to contain original url before applying filter/sort
			pageData.page = pageDataTransformed.page;
			return pageData;
		});
};
/**
 * 
 */
function _getPrototype($prototypeUrl, options) {
	if (options && options.prototype) {
		log && log("Skip reading prototype");
		return $.smResolve(options.prototype);
	}

	// Some prototypes do never change (like mobile dashboard or app)
	// so we hard code them to save some requests in working copy mode
	var fetchProto = $.Deferred();


	var fetchStatic = $.Deferred();
	_getStaticPrototype($prototypeUrl)
		.then(function(staticProto) {
			fetchStatic.resolve(staticProto);
		})
		.fail(function(e) {
			fetchStatic.resolve(null);
		});

	fetchStatic.then(function(staticProto) {
		if (staticProto) {
			fetchProto.resolve(staticProto);
		} else {
			if (options.useMetaFromCache === true) { // true for stateless apps
				// Fetch from cache
				sdataRequesterOffline.getPrototype($prototypeUrl)
					.then(function(result) {
						fetchProto.resolve(result);
					})
					.fail(function(resultOffline) {
						// If offline fails, we use a client side test application that links to a
						// prototype that may not be in the cache
						// So this is a fallback for tesing only and will never be used in real life because in real life
						// the prototype will always be in the cache
						ajax.request($prototypeUrl)
							.then(function(result) {
								fetchProto.resolve(result.data);
							})
							.fail(function(result) {
								result.offline = true;
								fetchProto.reject(result);
							});
					});
			} else {
				ajax.request($prototypeUrl)
					.fail(function(result) {

						if (result.offline) {
							// Fetch offline if possible
							sdataRequesterOffline.getPrototype($prototypeUrl)
								.then(function(result) {
									fetchProto.resolve(result);
								})
								.fail(function(result) {
									result.offline = true;
									fetchProto.reject(result);
								});
						} else {
							// Non offline error, just bubble up
							fetchProto.reject(result);
						}
					})
					.then(function(result) {
						fetchProto.resolve(result.data);
					});
			}
		}
	});

	return fetchProto;
}

function _getStaticPrototype($prototypeUrl) {
	var endpoint = protoHelpers.getEndpointFromUrl($prototypeUrl);
	var repr = protoHelpers.getKeyFromUrl($prototypeUrl);
	var protoName = endpoint + "." + repr;

	if (protoName === "syracuse.collaboration.syracuse.mobileDashboard.$details") {
		return $.smResolve(sdataStatic.getMobileDashboardProto());
	} else if (protoName === "syracuse.collaboration.syracuse.mobileApplication.$details") {
		return $.smResolve(sdataStatic.getMobileApplicationProto());
	}
	return $.smResolve();
}

function _getData($url, $method, prototypeJson, headers, options) {
	if (options && options.data) {
		log && log("Skip reading data");
		return $.smResolve(options.data);
	}
	var writeCache = true;
	var fetchData = $.Deferred();
	var fetchStatic = $.Deferred();

	if (options && options.noCacheWrite === true) {
		writeCache = false;
	}

	_getStaticData($url, $method, prototypeJson)
		.then(function(staticData) {
			if (staticData) {
				writeCache = false;
			}
			fetchStatic.resolve(staticData);
		})
		.fail(function(e) {
			fetchStatic.reject(e);
			fetchData.reject(e);
		});

	fetchStatic.then(function(staticData) {
		// Check if data is available locally (e.g. mobile apps are in the DB all the time)
		if (staticData) {
			fetchData.resolve(staticData);
		} else {
			ajax.request($url, $method, null, headers, options && options.ajaxOptions)
				.fail(function(result) {

					if (result.offline) {

						// Fetch offline if possible
						sdataRequesterOffline.fetchData($url, $method, prototypeJson)
							.then(function(result) {
								fetchData.resolve(result);
							})
							.fail(function(result) {
								result.offline = true;
								fetchData.reject(result);
							})
					} else {

						// Non offline error, just bubble up
						fetchData.reject(result);
					}
				})
				.then(function(result) {
					if (writeCache && result.data) {
						sdataRequesterOffline.writeToCache($url, $method, result.data, prototypeJson);
					}
					fetchData.resolve(result.data);
				});
		}
	});
	return fetchData;
}

function _getStaticData($url, $method, prototypeJson) {
	if (prototypeJson.$representation === "mobileApplication") {
		// A mobile application is never loaded by the requester
		// It's installed by the navigation helper BEFORE the actual navigation
		// is started. So it's data is always available in the cache
		var appName = protoHelpers.getKeyFromUrl($url);
		var parsed = jsutils.parseURL($url);
		var endpoint = parsed.query.$mobileEndpoint;
		if (endpoint) {
			return metaDataCache.tryGetApp(appName, endpoint).then(function(mobileApp) {
				return _checkFetchGadgetData(mobileApp, endpoint);
			});
		}
	}
	return $.smResolve();
}

function _getPage($url, $method, prototypeJson, datasetJson, options) {
	if (options && options.page && options.page.$article) {
		log && log("Skip reading article");
		return $.smResolve({
			$article: options.page.$article,
			$views: options.page.$views
		});
	}

	var pageUrl;
	var fetchPage = $.Deferred();
	var fetchStatic = $.Deferred();

	_getStaticArticle($url, $method, prototypeJson, datasetJson)
		.then(function(staticArticle) {
			fetchStatic.resolve(staticArticle);
		})
		.fail(function(e) {
			fetchStatic.resolve(null);
		});

	fetchStatic.then(function(staticArticle) {
		if (staticArticle) {
			fetchPage.resolve(staticArticle);
		} else {
			if (options.useMetaFromCache === true) {
				sdataRequesterOffline.getPage($url, datasetJson)
					.then(function(result) {
						fetchPage.resolve(result);
					})
					.fail(function(resultOffline) {
						// If offline fails, we use a client side test application that links to an
						// article that may not be in the cache
						// So this is a fallback for tesing only and will never be used in real life because in real life
						// the article will always be in the cache
						protoHelpers.getPageUrl($url, datasetJson)
							.then(function(_pageUrl) {
								pageUrl = _pageUrl;
							})
							.then(function(_pageUrl) {
								return ajax.request(pageUrl);
							})
							.fail(function(result) {
								fetchPage.reject(result);
							})
							.then(function(result) {
								fetchPage.resolve(result.data);
							});
					});
			} else {
				protoHelpers.getPageUrl($url, datasetJson)
					.then(function(_pageUrl) {
						pageUrl = _pageUrl;
					})
					.then(function(_pageUrl) {
						return ajax.request(pageUrl);
					})
					.fail(function(result) {
						if (result.offline) {

							// Fetch offline if possible
							sdataRequesterOffline.getArticle($url, datasetJson)
								.then(function(result) {
									fetchPage.resolve(result);
								})
								.fail(function(result) {
									result.offline = true;
									fetchPage.reject(result);
								});
						} else {
							// Non offline error, just bubble up
							fetchPage.reject(result);
						}
					})
					.then(function(result) {
						fetchPage.resolve(result.data);
					});
			}
		}
	});

	return fetchPage.then(function(page) {
		var $article = page && page.$article;
		if (!$article) {
			if (prototypeJson && prototypeJson.$representation === "mobileDashboard") {
				// Do not generate default article for mobile dashboard, it will be generated later in transform step if needed
			} else {
				$article = articleParser.createDefaultArticle(new Prototype(prototypeJson), {
					isChartDetail: options.isChartDetail
				});
			}
		}
		return {
			$article: $article,
			$views: page && page.$views
		}
	});
}

function _getStaticArticle($url, $method, prototypeJson, datasetJson) {
	if (prototypeJson.$representation === "mobileApplication") {
		// A mobile application representation is never rendered.
		// Instead, the home dashboard or home gadget of the mobile application is rendered
		// This is why we create a fake article for the mobile application (which will not be used) 
		// The acutal article is here:
		// datasetJson.$homeDashboard.$page.$article or datasetJson.$gadgetDashboard.$page.$article;
		// Later on page load, the dashboards article will be used (protocolHelpers.checkTransform)
		return $.smResolve({
			$layoutType: "stack"
		});
	}
	return $.smResolve(null);
}

/**
 * Create page information from cached offline data.
 * 
 * Used to mock test cases or offline stateless mode
 * 
 */
exports.createPageDataJson = function(datasetJson, prototypeJson, article) {

	if (prototypeJson.$representation === "mobileDashboard") { // this is set for syracuse entities which is what matters here
		var transformed = protoHelpers.transformDashboard(datasetJson, prototypeJson);

		prototypeJson = transformed.prototypeJson;
		datasetJson = transformed.datasetJson;
	}

	var proto = new Prototype(prototypeJson);
	return {
		prototype: proto,
		dataset: new dataset.Dataset(datasetJson, proto),
		article: article || prototypeJson.$article
	};
}

/**
 * Trigger named action
 * $actionName: Name of action (e.g. Save)
 * dataset: dataset.Dataset used to build request
 * workingCopy: true or false: Use working copy or not
 * 
 * return:
 * server response
 */
exports.triggerAction = function($actionName, dataset, workingCopy) {
	var def = $.Deferred();
	$.smResolve()
		.then(function() {
			var $action = dataset.getAction($actionName);
			if (!$action) {
				return $.smReject(helpers.createDiag(null, "error", "Action does not exist: " + $actionName));
			}
			return $action;
		})
		.then(function($action) {
			var actionData = protoHelpers.createActionData(dataset, $actionName, $action, workingCopy);
			if (actionData) {
				return ajax.request(actionData.$url, actionData.$method, actionData.data);
			}
		})
		.then(function(result) {
			def.resolve(result);
		})
		.fail(function(result) {
			// If we got a diag here, just merge it into dataset later to show the error
			if (result && result.data && result.data.$diagnoses) {
				// We end up here on X3 responding with http 400 on invalid field values in stateless mode
				// In working copy mode, we get http 200 and diagnoses, so we can treat both as ok
				def.resolve(result);
			} else {
				// Not sure what happened here, better reject
				def.reject(result);
			}
		})

	return def.promise();
};

/**
 * 
 */
exports.executeLink = function($url, $method, dataset) {
	var data;
	if (["PUT", "POST"].indexOf($method) > -1) {
		data = dataset.getData();
	}
	return ajax.request($url, $method, data);
}

/**
 * Export delete working copy
 */
exports.deleteWC = function(dataset) {
	return ajax.request(dataset.getUrl(), "DELETE");
};

/**
 * Extract delta in client side working copy and send it to the server
 * parameter $bind is used to update text because url and content uploaded are not like other data
 */
exports.updateServer = function(dataset, $bind, forceUpdateAll) {
	if (!dataset.isRoot()) {
		return $.smReject(helpers.createDiag(null, "error", "Server update only possible on root dataset"));
	}
	return $.smResolve()
		.then(function() {
			var isText = $bind && dataset.prototype.propIsText($bind);
			var delta = isText ? dataset.getDataText($bind) : dataset.getDataDelta(forceUpdateAll);
			var options = {};
			if (isText) {
				options.contentType = dataset.prototype.propGetType($bind);
			}
			var $url = dataset.getUrl(false, isText ? $bind : null);
			return ajax.request($url, "PUT", delta, null, options);
		})
		.then(function(response) {
			return response;
		});
};
/*Used in ctrlText to get text content*/
exports.getLazyPropData = function($url, prototypeJson, $type) {
	var headers = {
		Accept: $type
	};
	var ajaxOptions = {
		contentType: $type
	};

	return ajax.request($url, "GET", null, headers, ajaxOptions).then(function(result) {
		return result.data;
	})
};

function _checkFetchGadgetData(appData, endpoint) {
	if (appData.useHomeGadget !== true) {
		return $.smResolve(appData);
	}

	var $mobileProtocol = appData.onlineOnly ? "workingcopy" : "stateless";
	var gproto = {
		"$item": appData.$homeGadget,
	};
	gproto.$item.$clientContext = {
		$mobileProtocol: $mobileProtocol,
		$mobileEndpoint: endpoint,
		$mobileApplication: appData.applicationName
	};
	var g = gadget.createGadget(new Prototype(gproto));
	var $link = g.getLink();
	return exports.fetchPageData($link)
		.then(function(gadgetData) {
			appData.$homeGadgetFetched = {
				prototype: gadgetData.prototype.json,
				dataset: gadgetData.dataset.json
			}
			appData.$homeGadgetFetched.dataset.$page = gadgetData.page;

			// The url used to navigate is a different one than is actually rendered so we save
			// the one which is responsible for loading the actual data in $mobileEmbeddedUrl to be able
			// to determin the "real" page name later for authoring
			appData.$homeGadgetFetched.dataset.$mobileEmbeddedUrl = $link.$url;
			return appData;
		})
}
/**
 * Return the prototype 
 */
exports.getPrototype = function($url, options) {
		return _getPrototype(protoHelpers.getPrototypeUrl($url), options)
	}
	/**
	 * Save the drafts given by draftCtx
	 * draftIdx: number of drafts uploaded
	 * resolves with response: {data:{}, status:{}, success:true/false} and draftCtx
	 */
exports.processSaveDraft = function(draftCtx, draftIdx) {
	if (!draftCtx) {
		// Draft doesn't exists any more
		return $.smResolve({
			success: true
		});
	}
	if (protoHelpers.isLocaleUrl(draftCtx.draftUrl)) {
		var deferred = $.Deferred();
		setTimeout(function() {
			// Used for UnitTests
			var data;
			if (draftIdx % 4 === 0) {
				data = {
					success: false,
					status: 200,
					data: {
						$diagnoses: [{
							$severity: "error",
							$message: "Bad field's XXX value"
						}]
					}
				}
			} else if (draftIdx % 4 === 1) {
				data = {
					success: false,
					offline: true
				}
			} else if (draftIdx % 4 === 2) {
				data = {
					success: false,
					status: 401
				}
			} else if (draftIdx % 4 === 3) {
				data = {
					success: true,
					data: $.extend(true, null, draftCtx.dataset)
				}
			}
			deferred.resolve(data, draftCtx);
		}, 2000)
		return deferred.promise();
	}
	return exports.getPrototype(draftCtx.draftUrl, {
		useMetaFromCache: true
	}).then(function(protoJson) {
		return new Prototype(protoJson);
	}).then(function(prototype) {
		var dataSet = new dataset.createFromDraft(draftCtx.dataSet, prototype);
		return exports.triggerAction("$save", dataSet, false);
	}).then(function(result) {
		return $.smResolve(result, draftCtx)
	})
}