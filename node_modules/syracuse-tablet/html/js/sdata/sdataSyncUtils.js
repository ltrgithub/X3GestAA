"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var prototypeModule = require('syracuse-tablet/html/js/sdata/prototype');
var metaDataCache = require('syracuse-tablet/html/js/sdata/cache/metaDataCache');
var ajax = require('syracuse-tablet/html/js/common/ajax');

var _syncMaxLevels = 6;

exports.getSyncStructure = function(prototype) {
	var node = {
		$title: prototype.data("$title")
	};
	var urlList = [];
	return _resolvePrototype({
		prototype: prototype,
		level: 1,
		maxLevels: _syncMaxLevels
	}, node, urlList);
};

function _resolvePrototype(opts, node, urlList) {
	node.uuid = utils.UUID();
	node.$children = [];
	if (opts.level >= opts.maxLevels) {
		return $.smResolve(node);
	}

	var $links;

	// For query facet, only take $details link into account
	if (opts.prototype.getFacet() === "$query") {
		var $resources = opts.prototype.getPropertyData("$resources");
		if ($resources && $resources.$item && $resources.$item.$links && $resources.$item.$links.$details) {
			$links = {
				$details: $resources.$item.$links.$details
			};
		}
	} else if (opts.prototype.getFacet() === "$details") {
		$links = opts.prototype.data("$links");
		if ($links && $links.$edit) {
			node.$canEdit = true;
		}
	} else {
		// Only $details and $query facets allowed, we should never end up here, just for safety
		return $.smResolve(node);
	}
	if (!$links) {
		return $.smResolve(node);
	}

	return $.smForEachPromise(Object.keys($links), function(name) {
			var link = $links[name];
			if (_isCacheableLink(link, name, urlList)) {
				//var url = sdataUtils.parseSDataURL(link.$url);
				var repr = _getRepresentation(link);
				if (repr) {
					urlList.push(link.$url);

					var child = {
						$name: name,
						$title: opts.prototype.resolveExpression(link.$title),
						$link: link,
						$representation: repr
					};
					node.$children.push(child);
					return _processNode(child, opts, urlList);
				}
			}
			return $.smResolve(node);
		})
		.then(function() {
			if (node.$canEdit) {
				node.$editLink = $links["$edit"];
				var repr = _getRepresentation(node.$editLink);
				var protoName = _getProtoName({
					$representation: repr
				}, {
					prototype: opts.prototype // Only $baseUrl is extracted
				});

				return _getPrototypeObject(protoName, repr, opts.prototype)
					.then(function(proto) {
						node.$editPrototype = proto;
					});
			}
		})
		.then(function() {
			return node;
		});
}

function _isCacheableLink(link, name, urlList) {
	if (urlList.indexOf(link.$url) > -1) {
		return false;
	}
	if (name.indexOf("$") === 0 && name !== "$details") {
		return false;
	}
	if (link.$method !== "GET" && link.$method != null) {
		return false;
	}
	if (link.$url.indexOf("/$services/") > -1) {
		return false;
	}
	if (link.$url.indexOf("representation=") < 0) {
		return false;
	}
	var repr = _getRepresentation(link);
	if (!repr || repr.indexOf(".$details") < 0 && repr.indexOf(".$query") < 0) {
		return false;
	}
	return true;
}

function _getRepresentation(link) {
	var repr = /[\?\&]representation=(\S+?)(&|$)/.exec(link.$url);
	return repr && repr[1];
}

function _processNode(node, opts, urlList) {
	return _getPrototypeObject(_getProtoName(node, opts), node.$representation, opts.prototype)
		.then(function(proto) {
			if (proto) {
				node.$prototype = proto;
				if (node.$name === "$details") {
					node.$title = proto.data("$title");
					node.$isDetails = true;
				}

				return _resolvePrototype({
					prototype: proto,
					level: opts.level + 1,
					maxLevels: opts.maxLevels
				}, node, urlList);
			}
			return proto;
		});
}

/**
 * 
 * Reads prototype in metaCache
 * If not fund gets prototype from server and stores it
 * Returns a prototype class object or null 
 * Doesn't fail if prototype not found
 */
function _getPrototypeObject(protoName, $representation, baseProto) {
	return metaDataCache.getPrototype(protoName)
		.then(function(proto) {
			if (!proto && $representation) {
				var $prototypeUrl = baseProto.resolveExpression("{$baseUrl}/$prototypes('" + $representation + "')", true);
				return ajax.request($prototypeUrl)
					.then(function(proto) {
						if (proto && proto.data) {
							metaDataCache.putPrototype(protoName, proto.data);
							return proto.data;
						}
						return null;
					})
					.fail(function() {
						return null;
					})
			}
			return proto;
		}).then(function(proto) {
			if (!$.isEmptyObject(proto)) {
				return new prototypeModule.Prototype(proto);
			}
			return null;
		})
}

function _getProtoName(node, opts) {
	var endpoint = opts.prototype.data("$baseUrl");
	endpoint = endpoint.split("/");
	endpoint = endpoint.slice(endpoint.length - 3, endpoint.length).join(".");
	return endpoint + "." + node.$representation;
}