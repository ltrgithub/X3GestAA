"use strict";

/*
 *
 */

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("SDataCache");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var storageModule = require('syracuse-tablet/html/js/storage/storage');
var parser = require('syracuse-tablet/html/js/sdata/sdatawhere/parser').Parser;
var whereUtils = require('syracuse-tablet/html/js/sdata/sdatawhere/whereUtils');
var sdataSort = require('syracuse-tablet/html/js/sdata/sdataSort');
var localStorage = require('syracuse-tablet/html/js/storage/localStorage');

// all storage entries created by the case will be prefixed with this to be able to empty the cache w/o removing settings
var _cachePrefix = "$cache_";
var _keyRegExp = /\{(.*?)\}/g;

function _SDataCache(storage) {
	this.storage = storage;
	this.context = null;
};

/*
 *
 */
var _SDataCacheClass = utils.defineClass(
	_SDataCache,
	null, {
		setContext: function(context) {
			log && log("Changing cache context: " + JSON.stringify(context));
			this.context = context;
		},

		cachePrefix: _cachePrefix,

		/**
		 * Put an instance of an sdata object into the cache
		 *
		 * Parameters:
		 * data
		 * {
		 *   $data: {} - Data to store in cache (mandatory)
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 *   $key: "mawal" - Key of data
		 * }
		 * Note that $proto OR $representation AND $key must be set
		 *
		 * Return:
		 * Resolve:
		 * null
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		put: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				if (!data.$data) {
					throw new Error("PUT: No data specified");
				}
				var repr;
				var key;
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
					key = self._getKeyValue(data.$data, $proto);
				} else if (data.$representation && data.$key) {
					repr = data.$representation;
					key = data.$key;
				} else {
					throw new Error("PUT: Neither proto nor representation and key specified");
				}
				self.storage.put({
					$context: self.context,
					$collection: _cachePrefix + repr,
					$endpoint: data.$endpoint,
					$key: key,
					$data: {
						$item: data.$data
					}
				}).then(function(result) {
					deferred.resolve();
				}).fail(function(error) {
					deferred.reject(error);
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 * Query an array of instances from cache
		 *
		 * Parameters:
		 * data
		 * {
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 *   $where: "user eq 'admin' - Optional where clause
		 *   $orderBy: [{ "property": "user", "sort" : "ASC"}, { "property": "login", "sort" : "desc"}] - Optional array of sort conditions
		 * }
		 * Note that $proto OR $representation must be set
		 *
		 * Return:
		 * Resolve:
		 * Matched instances of queried representation
		 * [
		 *   {},
		 *   {}
		 * ]
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		query: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var repr;
				log && log("Query by: " + JSON.stringify(data));
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
				} else if (data.$representation) {
					if (data.$where) {
						throw new Error("QUERY: Where clause parsing requires prototype");
					}
					if (data.$orderBy) {
						throw new Error("QUERY: Order by requires prototype");
					}
					repr = data.$representation;
				} else {
					throw new Error("QUERY: Neither proto nor representation specified");
				}
				self.storage.query({
					$context: self.context,
					$endpoint: data.$endpoint,
					$collection: _cachePrefix + repr
				}).then(function(result) {
					var res = [];
					if (data.$where) {
						var exp = parser.parse(data.$where);
						result.$data.forEach(function(item, i) {
							if (whereUtils.execWhere(item.$item, exp, $proto)) {
								var d = item.$item;
								var m = result.$metaData[i];
								d.$cache = {
									$lastRead: m.$lastRead,
									$lastUpdated: m.$lastUpdated
								};
								res.push(d);
							}
						});
					} else {
						result.$data.forEach(function(item, i) {
							var d = item.$item;
							var m = result.$metaData[i];
							d.$cache = {
								$lastRead: m.$lastRead,
								$lastUpdated: m.$lastUpdated
							};
							res.push(d);
						});
					}
					if (data.$orderBy) {
						sdataSort.sdataSortArray(res, $proto, data.$orderBy);
					}
					// Exception are handled by ou jq deferred hack
					deferred.resolve(res);
				}).fail(function(error) {
					deferred.reject(error);
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 * Read one instance from cache using given key
		 *
		 * Parameters:
		 * data
		 * {
		 *   $key: "abc~def" - Key of object to read
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 * }
		 * Note that $proto OR $representation must be set
		 *
		 * Return:
		 * Resolve:
		 * Instance for given key or null if no match
		 * { ... }
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		read: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var repr;
				if (!data.$key) {
					throw new Error("READ: No key specified");
				}
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
				} else if (data.$representation) {
					repr = data.$representation;
				} else {
					throw new Error("READ: Neither proto nor representation specified");
				}
				self.storage.read({
					$context: self.context,
					$collection: _cachePrefix + repr,
					$endpoint: data.$endpoint,
					$key: data.$key
				}).then(function(result) {
					if (result.$status === storageModule.StatusCodes.OK) {
						var res = result.$data.$item;
						res.$cache = {
							$lastRead: result.$metaData.$lastRead,
							$lastUpdated: result.$metaData.$lastUpdated
						};
						deferred.resolve(res);
					} else {
						deferred.resolve(null);
					}
				}).fail(function(error) {
					deferred.reject(error);
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 * Delete instance from cache by given key
		 *
		 * Parameters:
		 * data
		 * {
		 *   $key: "abc~def" - Key of object to read
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 * }
		 * Note that $proto OR $representation must be set
		 *
		 * Return:
		 * Resolve:
		 * null
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		remove: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var repr;
				if (!data.$key) {
					throw new Error("REMOVE: No key specified");
				}
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
				} else if (data.$representation) {
					repr = data.$representation;
				} else {
					throw new Error("READ: Neither proto nor representation specified");
				}
				self.storage.remove({
					$context: self.context,
					$collection: _cachePrefix + repr,
					$endpoint: data.$endpoint,
					$key: data.$key
				}).then(function() {
					deferred.resolve();
				}).fail(function(error) {
					deferred.reject(error);
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 *
		 * options: {
		 * $not_read_since: "2015-01-20 11-22-33"
		 * }
		 */
		clearCache: function(options) {
			var deferred = $.Deferred();
			var self = this;
			var re = new RegExp(self.cachePrefix.replace(/([\$\_]+)/g, "\\$1"));
			var opts = {
				$context: self.context,
				$collection: re
			};
			if (options && options.$not_read_since) {
				opts.$not_read_since = options.$not_read_since;
			}
			try {
				self.storage.clearCollection(opts)
					.then(function() {
						deferred.resolve();
					}).fail(function(error) {
						deferred.reject(error);
					});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		_getProto: function(proto) {
			var itemProto = (proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
			// item type of query and lookup is e.g. $queryItem
			// We want to use the base $type here ($query or $lookup)
			itemProto.$type = proto.$type;
			return itemProto;
		},
		_getRepresentation: function(proto) {
			return proto.$type.split(".").slice(1, 3).join(".").replace("$queryItem", "$query");
		},
		_getKeyValue: function(data, proto) {
			return proto.$key.replace(_keyRegExp, function(m, p) {
				return data[p];
			});
		},

		disableCache: function(isDisabled) {
			if (globals.isDvlpMode()) {
				localStorage.setItem("s.m.cache.disabled", isDisabled);
			}
			this._isDisabled = isDisabled;
		},
		isDisabled: function() {
			if (this._isDisabled == null) {
				if (globals.isDvlpMode()) {
					this._isDisabled = localStorage.getItem("s.m.cache.disabled");
					this._isDisabled = this._isDisabled === true || this._isDisabled === "true";
				} else {
					this._isDisabled = false;
				}
			}
			return this._isDisabled;
		}
	}
);

exports.SDataCache = _SDataCacheClass;