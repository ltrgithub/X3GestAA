"use strict";

/*
 *
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("SDataCache");
var storageModule = require('syracuse-tablet/html/js/storage/storage');
var parser = require('syracuse-tablet/html/js/sdata/sdatawhere/parser').Parser;
var whereUtils = require('syracuse-tablet/html/js/sdata/sdatawhere/whereUtils');
var sdataSort = require('syracuse-tablet/html/js/sdata/sdataSort');

function _SDataCache(storage) {
	this.storage = storage;
	this.context = null;
};

/*
 *
 */
var _SDataCacheClass = utils.defineClass(
	_SDataCache,
	null, {
		setContext: function(context) {
			log && log("Changing cache context: " + JSON.stringify(context));
			this.context = context;
		},

		/**
		 * Put an instance of an sdata object into the cache
		 *
		 * Parameters:
		 * data
		 * {
		 *   $data: {} - Data to store in cache (mandatory)
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 *   $key: "mawal" - Key of data
		 * }
		 * Note that $proto OR $representation AND $key must be set
		 *
		 * Return:
		 * Resolve:
		 * null
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		put: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				if (!data.$data) {
					throw new Error("PUT: No data specified");
				}
				var repr;
				var key;
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
					key = self._getKeyValue(data.$data, $proto);
				} else if (data.$representation && data.$key) {
					repr = data.$representation;
					key = data.$key;
				} else {
					throw new Error("PUT: Neither proto nor representation and key specified");
				}
				self.storage.put({
					$context: self.context,
					$collection: repr,
					$key: key,
					$data: {
						$item: data.$data
					}
				}).then(function(result) {
					deferred.resolve();
				}, function(error) {
					throw new Error("Storage error: " + JSON.stringify(error));
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred;
			}
		},

		/**
		 * Query an array of instances from cache
		 *
		 * Parameters:
		 * data
		 * {
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 *   $where: "user eq 'admin' - Optional where clause
		 *   $orderBy: [{ "property": "user", "sort" : "ASC"}, { "property": "login", "sort" : "desc"}] - Optional array of sort conditions
		 * }
		 * Note that $proto OR $representation must be set
		 *
		 * Return:
		 * Resolve:
		 * Matched instances of queried representation
		 * [
		 *   {},
		 *   {}
		 * ]
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		query: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var repr;
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
				} else if (data.$representation) {
					if (data.$where) {
						throw new Error("QUERY: Where clause parsing requires prototype");
					}
					if (data.$orderBy) {
						throw new Error("QUERY: Order by requires prototype");
					}
					repr = data.$representation;
				} else {
					throw new Error("QUERY: Neither proto nor representation specified");
				}
				self.storage.query({
					$context: self.context,
					$collection: repr
				}).then(function(result) {
					var res = [];
					try {
						if (data.$where) {
							var exp = parser.parse(data.$where);
							result.$data.forEach(function(item) {
								if (whereUtils.execWhere(item.$item, exp, $proto)) {
									res.push(item.$item);
								}
							});
						} else {
							result.$data.forEach(function(item) {
								res.push(item.$item);
							});
						}
					} catch (e) {
						deferred.reject(e);
					}
					if (data.$orderBy) {
						sdataSort.sdataSortArray(res, $proto, data.$orderBy);
					}
					deferred.resolve(res);
				}, function(error) {
					throw new Error("Storage error: " + JSON.stringify(error));
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred;
			}
		},

		/**
		 * Read one instance from cache using given key
		 *
		 * Parameters:
		 * data
		 * {
		 *   $key: "abc~def" - Key of object to read
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 * }
		 * Note that $proto OR $representation must be set
		 *
		 * Return:
		 * Resolve:
		 * Instance for given key or null if no match
		 * { ... }
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		read: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var repr;
				if (!data.$key) {
					throw new Error("READ: No key specified");
				}
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
				} else if (data.$representation) {
					repr = data.$representation;
				} else {
					throw new Error("READ: Neither proto nor representation specified");
				}
				self.storage.read({
					$context: self.context,
					$collection: repr,
					$key: data.$key
				}).then(function(result) {
					if (result.$status === storageModule.StatusCodes.OK) {
						deferred.resolve(result.$data.$item);
					} else {
						deferred.resolve(null);
					}
				}, function(error) {
					throw new Error("Storage error: " + JSON.stringify(error));
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred;
			}
		},

		/**
		 * Delete instance from cache by given key
		 *
		 * Parameters:
		 * data
		 * {
		 *   $key: "abc~def" - Key of object to read
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 * }
		 * Note that $proto OR $representation must be set
		 *
		 * Return:
		 * Resolve:
		 * null
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		remove: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var repr;
				if (!data.$key) {
					throw new Error("REMOVE: No key specified");
				}
				if (data.$proto) {
					var $proto = self._getProto(data.$proto);
					repr = self._getRepresentation($proto);
				} else if (data.$representation) {
					repr = data.$representation;
				} else {
					throw new Error("READ: Neither proto nor representation specified");
				}
				self.storage.remove({
					$context: self.context,
					$collection: repr,
					$key: data.$key
				}).then(function() {
					deferred.resolve();
				}, function(error) {
					throw new Error("Storage error: " + JSON.stringify(error));
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred;
			}
		},

		_getProto: function(proto) {
			return (proto.$properties.$resources && proto.$properties.$resources.$item) || proto;
		},
		_getRepresentation: function(proto) {
			return proto.$type.split(".").slice(1, 3).join(".").replace("$queryItem", "$query");
		},
		_getKeyValue: function(data, proto) {
			return proto.$key.replace(/\{(.*?)\}/g, function(m, p) {
				return data[p];
			});
		}
	}
);

exports.SDataCache = _SDataCacheClass;