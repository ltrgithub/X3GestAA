"use strict";

/*
 *
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("SDataCache");
var storageModule = require('syracuse-tablet/html/js/storage/storage');
var parser = require('syracuse-tablet/html/js/sdatawhere/parser').Parser;
var whereUtils = require('syracuse-tablet/html/js/sdatawhere/whereUtils');

function _SDataCache(storage) {
	this.storage = storage;
	this.context = null;
};

/*
 *
 */
var _SDataCacheClass = utils.defineClass(
	_SDataCache,
	null, {
		setContext: function(context) {
			this.context = context;
		},

		/**
		 * Parameters:
		 * data
		 * {
		 *   $data: {} - Data to store in cache (mandatory)
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 *   $key: "mawal" - Key of data
		 * }
		 * Note that $proto OR $representation AND $key must be set
		 *
		 * Return:
		 * Resolve:
		 * null
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		put: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				if (!data.$data) {
					throw new Error("PUT: No data specified");
				}
				var repr;
				var key;
				if (data.$proto) {
					repr = data.$proto.$type.split(".").slice(1, 3).join(".");
					key = data.$proto.$key.replace(/\{(.*?)\}/g, function(m, p) {
						return data.$data[p];
					});
				} else if (data.$representation && data.$key) {
					repr = data.$representation;
					key = data.$key;
				} else {
					throw new Error("PUT: Neither proto nor representation and key specified");
				}
				self.storage.put({
					$context: self.context,
					$collection: repr,
					$key: key,
					$data: {
						$item: data.$data
					}
				}).then(function(result) {
					deferred.resolve();
				}, function(error) {
					throw new Error("Storage error: " + JSON.stringify(error));
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred;
			}
		},

		/**
		 * Parameters:
		 * data
		 * {
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 * }
		 * Note that $proto OR $representation must be set
		 *
		 * Return:
		 * Resolve:
		 * Matched instances of queried representation
		 * [
		 *   {},
		 *   {}
		 * ]
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		query: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var repr;
				if (data.$proto) {
					repr = data.$proto.$type.split(".").slice(1, 3).join(".");
				} else if (data.$representation) {
					if (data.$where) {
						throw new Error("QUERY: Where clause parsing requires prototype");
					}
					repr = data.$representation;
				} else {
					throw new Error("QUERY: Neither proto nor representation specified");
				}
				self.storage.query({
					$context: self.context,
					$collection: repr
				}).then(function(result) {
					var res = [];
					try {
						if (data.$where) {
							var exp = parser.parse(data.$where);
							result.$data.forEach(function(item) {
								if (whereUtils.execWhere(item.$item, exp, data.$proto)) {
									res.push(item.$item);
								}
							});
						} else {
							result.$data.forEach(function(item) {
								res.push(item.$item);
							});
						}
					} catch (e) {
						deferred.reject(e);
					}
					deferred.resolve(res);
				}, function(error) {
					throw new Error("Storage error: " + JSON.stringify(error));
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred;
			}
		},

		/**
		 * Parameters:
		 * data
		 * {
		 *   $key: "abc~def" - Key of object to read
		 *   $proto: {} - Prototype of data
		 *   $representation: "user.$details" - Representation of data
		 * }
		 * Note that $proto OR $representation must be set
		 *
		 * Return:
		 * Resolve:
		 * Instance for given key or null if no match
		 * { ... }
		 *
		 * Reject:
		 * Instance of Error
		 *
		 */
		read: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var repr;
				if (!data.$key) {
					throw new Error("READ: No key specified");
				}
				if (data.$proto) {
					repr = data.$proto.$type.split(".").slice(1, 3).join(".");
				} else if (data.$representation) {
					repr = data.$representation;
				} else {
					throw new Error("READ: Neither proto nor representation specified");
				}
				self.storage.read({
					$context: self.context,
					$collection: repr,
					$key: data.$key
				}).then(function(result) {
					if (result.$status === storageModule.StatusCodes.OK) {
						deferred.resolve(result.$data.$item);
					} else {
						deferred.resolve(null);
					}
				}, function(error) {
					throw new Error("Storage error: " + JSON.stringify(error));
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred;
			}
		},
		remove: function(data) {}
	}
);

exports.SDataCache = _SDataCacheClass;