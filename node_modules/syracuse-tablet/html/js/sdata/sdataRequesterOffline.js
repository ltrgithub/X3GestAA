"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("SDataRequesterOffline", false);
var locale = require('syracuse-tablet/html/js/helpers/locale');
var helpers = require("syracuse-tablet/html/js/common/helpers");
var jsutils = require("syracuse-tablet/html/js/helpers/jsutils");
var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');
var modules = require('syracuse-tablet/html/js/common/modules');

var metaDataCache = require('syracuse-tablet/html/js/sdata/cache/metaDataCache');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');

var Dataset = require('syracuse-tablet/html/js/sdata/dataset').Dataset;
var Prototype = require('syracuse-tablet/html/js/sdata/prototype').Prototype;

var OFFLINEQUERYCOUNT = 20;
var _repExp = /\$prototypes\('(.*?)'\)/;
var _keyExp = /\('(.*?)'\)/;
var _keyExpEq = /\(.+'(.*?)'\)/;

var _newTemplateKey = "$$new$$";

function _getCache() {
	return modules.get("cache").getCache();
}

/**
 * Try to fetch the data specified by url from the cache
 */
exports.fetchData = function($url, $method, prototypeJson) {
	var operation;
	return $.smResolve()
		.then(function() {
			operation = _getOperation($url, $method);
		})
		.then(function() {
			console.log(operation);
			switch (operation.$operation) {
				case "new":
					return _readCacheNew(operation, prototypeJson);
				case "read":
					return _readCacheDetail(operation, prototypeJson);
				case "query":
					return _readCacheQuery(operation, prototypeJson);
			}
		});
}

/**
 * Reads an article from the cache
 */
exports.getPage = function($url, sdataResponse) {
	var base = jsutils.getUrlHost($url);
	var endpoint = protoHelpers.getEndpointFromUrl($url);
	var repr = protoHelpers.getReprFromUrl($url);

	if (repr === "mobileDashboard.$details") {
		repr = protoHelpers.getKeyFromUrl($url);
		repr += ".$mobileDashboard";
	}
	var pageName = endpoint + "." + repr;
	return $.smResolve()
		.then(function() {
			return metaDataCache.getPage(pageName);
		});
}

/**
 * Read prototype from cache
 */
exports.getPrototype = function($prototypeUrl) {
	var endpoint = protoHelpers.getEndpointFromUrl($prototypeUrl);
	var repr = protoHelpers.getKeyFromUrl($prototypeUrl);
	var protoName = endpoint + "." + repr;

	return $.smResolve()
		.then(function() {
			return metaDataCache.getPrototype(protoName);
		})
		.then(function(proto) {
			if (proto == null) {
				return $.smReject(helpers.createDiag(null, "error", locale.text("error.network.offline.cache"), "Url:" + $prototypeUrl));
			}
			return proto;
		});
}

exports.writeToCache = function($url, $method, cacheData, prototypeJson) {
	var operation;
	return $.smResolve()
		.then(function() {
			operation = _getOperation($url, $method);
		})
		.then(function() {
			switch (operation.$operation) {
				case "new":
					return _writeCacheNew(operation, cacheData, prototypeJson);
				case "read":
					return _writeCacheDetail(operation, cacheData, prototypeJson);
				case "query":
					return _writeCacheArray(operation, cacheData, prototypeJson);
			}
		});
}

function _readCacheDetail(op, prototypeJson) {
	log && log("Read cache: " + op.$endpoint + "." + op.$representation + ": " + op.$key);
	return _getCache().read({
			$representation: op.$representation,
			$key: op.$key,
			$endpoint: op.$endpoint
		})
		.then(function(result) {
			if (result) {
				log && log("Cache hit");
				return result;
			}
			log && log("Cache miss");
			return $.smReject(helpers.createDiag(null, "error", locale.text("error.network.offline.cache")));
		});
}


function _writeCacheDetail(op, data, prototypeJson) {
	log && log("Put cache: " + op.$endpoint + "." + op.$representation + ": " + op.$key);
	return _getCache().put({
		$representation: op.$representation,
		$key: op.$key,
		$endpoint: op.$endpoint,
		$data: data
	});
}

function _readCacheNew(op, prototypeJson) {
	log && log("Read cache: " + op.$endpoint + "." + op.$representation + ": " + _newTemplateKey);
	return _getCache().read({
			$representation: op.$representation,
			$key: _newTemplateKey,
			$endpoint: op.$endpoint
		})
		.then(function(result) {
			if (result) {
				log && log("Cache hit");
				return result;
			}
			log && log("Cache miss");
			return $.smReject(helpers.createDiag(null, "error", locale.text("error.network.offline.cache")));
		});
}


function _writeCacheNew(op, data, prototypeJson) {
	log && log("Put cache: " + op.$endpoint + "." + op.$representation + ": " + _newTemplateKey);
	return _getCache().put({
		$representation: op.$representation,
		$key: _newTemplateKey,
		$endpoint: op.$endpoint,
		$data: data
	});
}

function _writeCacheArray(op, data, prototypeJson) {
	if (!data || !data.$resources) {
		return $.smResolve();
	}
	if (op.$isRequest === true || op.$isStats === true) {
		return _writeCacheRequestAndStats(op, data, prototypeJson);
	} else {
		return _writeCacheQuery(op, data, prototypeJson);
	}
}

function _writeCacheQuery(op, data, prototypeJson) {
	var proto = prototypeJson.$properties && prototypeJson.$properties.$resources && prototypeJson.$properties.$resources.$item || prototypeJson;
	return $.smForEachPromise(data.$resources, function(item) {
		var key = _calculateKey(proto, item);
		if (!key) {
			key = item.$uuid;
		}
		return _getCache().put({
			$representation: op.$representation,
			$key: key,
			$endpoint: op.$endpoint,
			$data: item
		});
	});
}

function _writeCacheRequestAndStats(op, data, prototypeJson) {

}

function _readCacheArray(op, data, prototypeJson) {
	if (op.$isRequest === true || op.$isStats === true) {
		return _readCacheRequestAndStats(op, prototypeJson);
	} else {
		return _readCacheQuery(op, prototypeJson);
	}
}

function _readCacheQuery(op, prototypeJson) {
	var proto = prototypeJson.$properties && prototypeJson.$properties.$resources && prototypeJson.$properties.$resources.$item || prototypeJson;
	var filters = proto.$filters;
	var where;
	var orderBy;
	var keyField;

	// Supervisor currently sends "application/json;vnd.sage=syracuse" on $type of $item so we use the root level type
	// which should contain a representation name
	proto.$type = prototypeJson.$type;

	return $.smResolve()
		.then(function() {
			return _extendWhereWithFilter(op, filters);
		})
		.then(function(_where) {
			where = _where;
		})
		.then(function() {
			if (proto.$key) {
				keyField = proto.$key.replace(/{/g, "").replace(/}/g, "");
			} else {
				keyField = "$uuid";
			}
		})
		.then(function() {
			return _parseOrderBy(op.$orderBy, keyField);
		})
		.then(function(_orderBy) {
			orderBy = _orderBy;
		})
		.then(function() {
			return _getCache().query({
				$proto: proto,
				$endpoint: op.$endpoint,
				$where: where,
				$orderBy: orderBy
			});
		})
		.then(function(result) {
			if (result == null) {
				return $.smReject(helpers.createDiag(null, "error", locale.text("error.network.offline.cache")));
			}
			return _queryCutAndAddLinks(op, result, prototypeJson);
		})
		.then(function(result) {
			return result;
		});
}

function _readCacheRequestAndStats(op, prototypeJson) {

}

function _getOperation($url, $method) {
	$method = $method || "GET"
	var url = $url;
	var result = {
		$url: $url,
		$method: $method,
		$parsedUrl: sdataUtils.parseSDataURL($url)
	};
	result.$endpoint = result.$parsedUrl.application + "." + result.$parsedUrl.contract + "." + result.$parsedUrl.dataset;
	var dir = result.$parsedUrl.directory; // All except query parameters
	var idx;
	if ($method === "GET") {
		if (url.indexOf("$prototypes") > -1) {
			result.$operation = "prototype";
			result.$representation = _repExp.exec(url)[1];
		} else if (dir.indexOf("$template") > -1) {
			result.$operation = "new";
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
		} else if (result.$parsedUrl.$services) {
			result.$operation = "service";
			result.$service = result.$parsedUrl.$services;
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
		} else {
			var key = _keyExp.exec(dir);
			if (key != null) {
				key = key[1];
			} else {
				key = _keyExpEq.exec(dir);
				if (key != null) {
					key = key[1];
				}
			}
			result.$isStats = dir.indexOf("/STATS(") > -1;
			result.$isRequest = dir.indexOf("/QUERY(") > -1;
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
			if (key && !(result.$isStats || result.$isRequest)) {
				result.$operation = "read";
				result.$key = key;
			} else {
				result.$operation = "query";
			}
		}
		if (result.$parsedUrl.query && result.$parsedUrl.query.where) {
			result.$where = result.$parsedUrl.query.where;
		}
		if (result.$parsedUrl.query && result.$parsedUrl.query.orderBy) {
			result.$orderBy = result.$parsedUrl.query.orderBy;
		}
	} else if (result.$parsedUrl.$services) {
		result.$operation = "service";
		result.$service = result.$parsedUrl.$services;
		result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
	} else if ($method === "DELETE") {
		var key = _keyExp.exec(dir);
		result.$operation = "delete";
		result.$key = key[1];
		result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
	} else {
		// PUT/POST and no service
		var key = _keyExp.exec(dir);
		if (key) {
			result.$operation = "save";
			result.$key = key[1];
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
		} else {
			result.$operation = "save";
			result.$representation = result.$parsedUrl.query && result.$parsedUrl.query.representation;
		}
	}

	return result;
};

function _calculateKey(proto, item) {
	var key;
	if (proto.$key) {
		key = proto.$key.replace(/\{(.*?)\}/g, function(match, prop) {
			return item[prop];
		});
	} else {
		key = item.$uuid;
	}
	return key;
}

function _checkQueryPrototype(op, proto) {
	// https://github.com/Sage-ERP-X3/Syracuse/issues/6003
	// Type of $item in queries is application/json but the cache needs a concrete type to be able to store the data
	// For requester requests, type is empty and will also be generated here
	if (proto.$properties && proto.$properties.$resources && proto.$properties.$resources.$item) {
		proto.$properties.$resources.$item.$type = "{$baseType}." + op.$representation;
	}
}

function _queryCutAndAddLinks(op, result, prototypeJson) {
	var response = {};
	result = result || [];
	var baseUrl = op.$parsedUrl.source.split("?")[0];
	var query = "";
	var key;
	var max = OFFLINEQUERYCOUNT;
	var orderBy = "";

	if (op.$parsedUrl.query && op.$parsedUrl.query.where) {
		query += "&where=" + op.$parsedUrl.query.where;
	}

	key = op.$parsedUrl.query && op.$parsedUrl.query.key;
	var firstKeyRead;
	var lastKeyRead;

	var resources = response.$resources = [];
	var hasNextPage = false;
	var hasPreviousPage = false;
	var i;
	var orderBy = "";
	var val;
	var kv;
	var proto = (prototypeJson.$properties && prototypeJson.$properties.$resources && prototypeJson.$properties.$resources.$item) || prototypeJson;
	var keyField;

	return $.smResolve()
		.then(function() {
			if (proto.$key) {
				keyField = proto.$key.replace(/{/g, "").replace(/}/g, "");
			} else {
				keyField = "$uuid";
			}
		})
		.then(function() {
			if (op.$parsedUrl.query && op.$parsedUrl.query.orderBy) {
				return _buildOrderBy(op, keyField, op.$parsedUrl.query.orderBy);
			}
		})
		.then(function(_orderBy) {
			if (_orderBy) {
				orderBy = _orderBy;
				query += "&orderBy=" + orderBy;
			}

			var keyType = proto.$properties[keyField];
			var isNumericKey = keyType && keyType.$type && keyType.$type !== "application/x-string";
			var gotMatch = false;
			if (key && key.smStartsWith("gt")) {
				val = key.substr(3);
				val = isNumericKey ? +val : val;

				for (i = 0; i < result.length; i++) {
					if (!gotMatch) {
						kv = _calculateKey(proto, result[i]);
						kv = isNumericKey ? +kv : "" + kv;
					}
					if (kv == val && !gotMatch) {
						gotMatch = true;
					} else if (gotMatch) {
						resources.push(result[i]);
						if (resources.length > max) {
							break;
						}
					} else {
						hasPreviousPage = true;
					}
				}
				if (resources.length > 0) {
					if (resources.length > max) {
						resources.pop();
						hasNextPage = true;
					}
					firstKeyRead = _calculateKey(proto, resources[0]);
					lastKeyRead = _calculateKey(proto, resources[resources.length - 1]);
				}
			} else if (key && key.smStartsWith("lt")) {

				if (key.length > 3) {
					val = isNumericKey ? +key.substr(3) : "" + key.substr(3);

					for (i = result.length - 1; i >= 0; i--) {
						if (!gotMatch) {
							kv = _calculateKey(proto, result[i]);
							kv = isNumericKey ? 0 + kv : "" + kv;
						}

						if (kv == val && !gotMatch) {
							gotMatch = true;
						} else if (gotMatch) {
							resources.push(result[i]);
							if (resources.length > max) {
								break;
							}
						} else {
							hasNextPage = true;
						}
					}
					if (resources.length > max) {
						hasPreviousPage = true;
						resources.pop();
					}
				} else {
					for (i = result.length - 1; i >= 0; i--) {
						resources.push(result[i]);
						if (resources.length > max) {
							break;
						}
					}
				}
				if (resources.length > 0) {
					if (resources.length > max) {
						hasPreviousPage = true;
						resources.pop();
					}
					response.$resources = resources = resources.reverse();

					firstKeyRead = _calculateKey(proto, resources[0]);
					lastKeyRead = _calculateKey(proto, resources[resources.length - 1]);
				}
			} else {
				for (i = 0; i < result.length; i++) {
					resources.push(result[i]);
					if (resources.length > max) {
						break;
					}
				}
				if (resources.length > 0) {
					if (resources.length > max) {
						hasNextPage = true;
						resources.pop();
					}

					firstKeyRead = _calculateKey(proto, resources[0]);
					lastKeyRead = _calculateKey(proto, resources[resources.length - 1]);
				}
			}

			var links = response.$links = {};
			if (key) {
				links.$first = {
					$url: baseUrl + "?representation=" + op.$representation + query
				};
			}

			if (key && firstKeyRead && hasPreviousPage) {
				if (key !== "gt") { // not on first page?
					links.$previous = {
						$url: baseUrl + "?representation=" + op.$representation + query + "&key=lt." + firstKeyRead
					};
				}
			}

			if (key !== "lt" && lastKeyRead && hasNextPage) { // not on last page and more records
				links.$next = {
					$url: baseUrl + "?representation=" + op.$representation + query + "&key=gt." + lastKeyRead
				};
			}
			if (key !== "lt" && hasNextPage) {
				links.$last = {
					$url: baseUrl + "?representation=" + op.$representation + query + "&key=lt"
				};
			}

			return response;
		});
}

function _parseOrderBy(orderBy, keyField) {
	return $.smResolve().
	then(function() {
		if (!orderBy) {
			return [{
				property: keyField,
				sort: "ASC"
			}];
		}
		var o = [];
		orderBy.split(",").map(function(field) {
			field = field.trim();
			var d = field.split(" ");
			var f = d[0].trim();
			if (f.length > 0) {
				var dir = "ASC";
				if (d.length > 1) {
					dir = d[1].toUpperCase();
					dir = dir !== "DESC" ? "ASC" : "DESC";
				}
				o.push({
					property: f,
					sort: dir
				});
			}
		});
		return o;
	});
}

function _buildOrderBy(op, keyField, orderBy) {
	return $.smResolve().
	then(function() {
		if (!orderBy) {
			return keyField;
		}

		if (!(orderBy === keyField || orderBy.indexOf(keyField + " ") > -1 || orderBy.indexOf(keyField + ",") > -1)) {
			// Key field not yet in order by
			if (orderBy.indexOf(" DESC") > -1) {
				orderBy += ", " + keyField + " DESC";
			} else {
				orderBy += ", " + keyField + " ASC";
			}
		}
		return orderBy;
	});
}

function _extendWhereWithFilter(op, filters) {
	return $.smResolve()
		.then(function() {
			var where = op.$where;
			if (!filters) {
				return where;
			}
			var filterName = op.$parsedUrl && op.$parsedUrl.query && op.$parsedUrl.query.filter;
			if (!filterName) {
				return where;
			}
			var filter = filters && filters[filterName];
			if (!filter) {
				return where;
			}

			return _checkFilterWhere(filterName, filter.$where)
				.then(function(fw) {
					if (!fw) {
						return where;
					}

					if (where) {
						where = "(" + where + ") and (" + fw + ")";
					} else {
						where = "(" + fw + ")";
					}

					return where;
				});
		});
}

/*
 * Check if X3 filter contains invalid references of screen elements which are not valid on client side
 * In case it's true, the filter will be ignored and an error message will be displayer
 */
function _checkFilterWhere(filterName, where) {
	var invalid = where.match(/(\[F\:\w+\]?)/g);
	if (invalid) {
		return $.smReject(helpers.createDiag({}, "error", locale.text("sdata.error.filter.screenFieldDetails", [filterName, invalid.join(","), where])));
	}
	return $.smResolve(where);
}