"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("metaData", false);

var ajax = require('syracuse-tablet/html/js/common/ajax');
var modules = require('syracuse-tablet/html/js/common/modules');
var protocolHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');
var storageModule = require('syracuse-tablet/html/js/storage/storage');
var waiting = require('syracuse-tablet/html/js/utils/waiting');

var localStorage = require('syracuse-tablet/html/js/storage/localStorage');

var _storage;

// Stores apps we read from the cache so we do not need to ask the database all time
// Also, all what is in this array is assumed to be up to date with remote version
// Whenever this is emptied there will be a new version comparison with the server this happens usually
// on user profile change or when browser reloads the full app
var _cachedAppVersions = {};

function _alwaysUpdateApps() {
	return localStorage.getItem("alwaysUpdateChecked") === "true";
}

function _getStorage() {
	if (!_storage) {
		_storage = modules.get("storage").getStorage();
	}
	return _storage;
}

function _getMetaDataContext() {
	return modules.get("appController").App.getCacheContext();
}

function _getMetaData(metaType, endpoint, key) {
	return _getStorage().read({
		$context: _getMetaDataContext(),
		$collection: "$meta_" + metaType,
		$endpoint: endpoint,
		$key: key
	}).then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			return result.$data;
		} else {
			return null;
		}
	});
}

function _putMetaData(metaType, endpoint, key, data) {
	return _getStorage().put({
		$context: _getMetaDataContext(),
		$collection: "$meta_" + metaType,
		$endpoint: endpoint,
		$key: key,
		$data: data
	});
}

exports.clearCachedApps = function() {
	log && log("clearCachedApps");
	_cachedAppVersions = {};
}


/**
 * Return application header informations or null
 */
exports.tryGetApp = function(appName, endpoint) {
	log && log("Try get app: " + appName + " on " + endpoint);

	var name = endpoint + "." + appName;
	var appInMemory = _cachedAppVersions[name];
	if (appInMemory) {
		log && log("In memory app: " + appName + " on " + endpoint);
		return $.smResolve(appInMemory);
	}
	return $.smResolve()
		.then(function() {
			return _getMetaData("appHeader", "$local", name);
		})
		.then(function(appData) {
			log && log("App in cache: " + (appData !== null));
			if (appData) {
				delete appData.$isUpToDate; // Ensure to check with remote next time
				_cachedAppVersions[name] = appData;
			} else {
				delete _cachedAppVersions[name];
			}
			return appData;
		});
};

/**
 * Check if app is up to date with server version -> true or false if not up to date
 * When offline, the app is assumed to be up to date -> true
 */
exports.isAppUpToDate = function(appData, endpoint) {
	log && log("isAppUpToDate: " + appData.versionNumber);
	var url = protocolHelpers.getMobileAppUrl(appData.applicationName);
	var appDataRemote;

	var name = endpoint + "." + appData.applicationName;
	// Usually app header is in memory already, this is just for safety
	var appInMemory = _cachedAppVersions[name] = _cachedAppVersions[name] || appData;
	if (appInMemory.$isUpToDate) {
		return $.smResolve(true);
	}

	var d = $.Deferred();
	log && log("Check app up to date: " + appData.applicationName);
	ajax.request(url)
		.fail(function(result) {
			if (result.offline) {
				log && log("Offline, assume up to date");
				d.resolve(true); // If we are offline, we assume the app is up to date
			} else {
				d.reject(result); // Critical error
			}
		})
		.then(function(result) {
			appDataRemote = result.data;
		})
		.then(function() {
			log && log("Local version: " + appData.versionNumber);
			log && log("Remote version: " + appDataRemote.versionNumber);
			if (appDataRemote.versionNumber === appData.versionNumber) {
				// We push the remote version to memory since also it's up to date, there may be a newer article included 
				appInMemory = _cachedAppVersions[name] = appDataRemote;
				appInMemory.$isUpToDate = true;
				if (_alwaysUpdateApps()) {
					log && log("Update forced by development flag");
					d.resolve(false);
				} else {
					d.resolve(true);
				}
			} else {
				appInMemory.$isUpToDate = false;
				d.resolve(false);
			}
		});

	return d.promise();
};

/**
 * Fetches meta data for given app from the server and put's it into the local storage
 */
exports.installApp = function(appName, endpoint) {
	var url = protocolHelpers.getMobileAppUrl(appName);

	// Note: If an app is declared as onle only, this service operation will return the header only and all
	// prototype information is fetched on demand
	var appMetaDataUrl = url + "/$service/applicationMetaData?endpoint=" + endpoint;
	var appData;

	log && log("Installing app: " + appName);
	var install = $.smResolve()
		.then(function() {
			log && log("Fetching meta data: " + appName);
			return ajax.request(appMetaDataUrl);
		})
		.then(function(result) {
			appData = result.data;

			// Save header information
			log && log("Saving header: " + appName + " on " + endpoint + " Mode: " + (appData.$application.onlineOnly ? "workingcopy" : "stateless"));
			return _putMetaData("appHeader", "$local", endpoint + "." + appName, appData.$application);
		})
		.then(function() {
			// save pages
			var $pages = appData.$pages || {};
			return $.smForEachPromise(Object.keys($pages), function(page) {
				var $page = $pages[page].$page;

				var article = $page.$article;
				var views = $page.$views;
				var prototype = $page.$prototype;

				return $.smResolve()
					.then(function() {
						if (article) {
							log && log("Saving page: " + page);
							return _putMetaData("page", "$local", page, {
								$article: article,
								$views: views
							});
						}
					})
					.then(function() {
						if (prototype) {
							delete prototype.$article; // We do not need this, so delete before storing to save some space
							log && log("Saving prototype: " + page);
							return _putMetaData("prototype", "$local", page, prototype);
						}
					});
			});
		})
		.then(function() {
			var $dashboards = appData.$dashboards || {};
			return $.smForEachPromise(Object.keys($dashboards), function(dashboard) {
				var $dashboard = $dashboards[dashboard];
				return $.smResolve()
					.then(function() {
						log && log("Saving dashboard: " + dashboard);
						return _putMetaData("dashboard", "$local", dashboard, $dashboard);
					});
			});
		})
		.then(function() {
			var appHeader = appData.$application;
			var name = endpoint + "." + appHeader.applicationName;
			log && log("Saving header: " + name + " Version: " + appHeader.versionNumber);

			appHeader.$isUpToDate = true;
			_cachedAppVersions[name] = appHeader;

			return _putMetaData("appHeader", "$local", name, appHeader);
		});

	return waiting.waitModal(install);
}

exports.getPage = function(pageName) {
	log && log("Read meta data (page): " + pageName);
	return _getMetaData("page", "$local", pageName)
		.then(function(page) {
			if (page) {
				log && log("Cache hit");
				return page;
			}
			log && log("Cache miss");
		});
}

exports.getPrototype = function(prototypeName) {
	log && log("Read meta data (prototype): " + prototypeName);
	return _getMetaData("prototype", "$local", prototypeName)
		.then(function(proto) {
			if (proto) {
				log && log("Cache hit");
				return proto;
			}
			log && log("Cache miss");
		});
}
exports.initApplicationsList = function() {
	var self = this;
	return ajax.request("/sdata/syracuse/collaboration/syracuse/mobileApplications/$service/availableApplications")
		.then(function(result) {
			if (result.data) {
				return _putMetaData("applications", "$local", "$applications", result.data.$resources);
			} else {
				throw new Error("Empty applications list");
			}
		})
}
exports.getApplicationsList = function() {
	log && log("Read meta data (applications list): ");
	return _getMetaData("applications", "$local", "$applications")
		.then(function(appList) {
			if (appList) {
				log && log("Cache hit");
				return appList;
			}
			log && log("Cache miss");
		});
}
exports.getDashboard = function(dashboardName) {
	log && log("Read meta data (dashboard): " + dashboardName);
}

exports.putArticle = function(page, article, views) {
	return _putMetaData("page", "$local", page, {
		$article: article,
		$views: views
	});
}

exports.putPrototype = function(prototypeName, data) {
	return _putMetaData("prototype", "$local", prototypeName, data);
}