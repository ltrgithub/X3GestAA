"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/sdata/datasetArray').ArrayDataset;

/**
 * Array dataset wrapping arrays having exactly one column
 */
exports.SingleArrayDataset = utils.defineClass(
	function SingleArrayDataset(json, prototype, parent, $bind) {
		var self = this;
		Base.call(this, json, prototype, parent, $bind);
		this.isReferenceArray = false;
		if (this.prototype.json.$item.$type === "application/x-reference") {
			this.isReferenceArray = true;
			this.valueProperty = Object.keys(this.prototype.json.$item.$item.$properties)[0];
			var json = {
				$properties: {
					$value_ref: $.extend(true, {}, this.prototype.json.$item),
				}
			}
			json.$properties.$value_ref.$item[this.valueProperty] = "{" + this.valueProperty + "}";
			json.$properties[this.valueProperty] = $.extend(true, {}, this.prototype.json.$item.$item.$properties[this.valueProperty]);
			json.$properties[this.valueProperty].$isExcluded = true;
			json.$type = "$simplePropertyArray";
			//this.rowPrototype = prototype.createNew(this.prototype.json.$item.$item);
			//this.valueProperty = Object.keys(this.rowPrototype.json.$properties)[0];
			//this.rowPrototype.json.$type = "$simplePropertyArray";
			this.rowPrototype = prototype.createNew(json)
			for (var i = 0; i < this.json.length; i++) {
				this.json[i].$uuid = utils.UUID();
			}
		} else {
			this.valueProperty = "$value";
			this.rowPrototype = prototype.createNew({
				$type: "$simplePropertyArray",
				$properties: {
					$value: prototype.json.$item
				}
			});
			var wrappedItems = this.json.map(function(row) {
				return self._wrapRow(row);
			});
			// Clean original json and add wrapped items
			this.json.splice(0, this.json.length);
			for (var i = 0; i < wrappedItems.length; i++) {
				this.json.push(wrappedItems[i]);
			}
		}
	},
	Base, {

		get$ItemProto: function() {
			return this.rowPrototype;
		},

		/**
		 * Add a new row to the array, returns newly created dataset
		 */
		addRow: function() {
			var $uuid = utils.UUID();
			var rowData = {
				$uuid: $uuid
			};
			this.json.push(rowData);
			this.setDirty(this.$bind); // full array is dirty all time
			return this.getRowByUuid($uuid);
		},
		removeRow: function($uuid) {
			var idx = this.getRowIndex($uuid);
			if (idx != null) {
				this.json.splice(idx, 1);
			}
			this.setDirty(this.$bind); // full array is dirty all time
			this.removeDatasetByUuid($uuid);
		},
		getDataDelta: function(forceUpdateAll) {
			// For single prop arrays, there is no delta
			// it's always all rows
			return this.getData();
		},
		getData: function() {
			var deltaRows = [];
			var i;
			//
			// we cannot do return this.json;
			// because original json is modified to allow tracking of values
			//
			for (i = 0; i < this.json.length; i++) {
				if (this.isReferenceArray) {
					var d = {};
					// X3 doesn't accept undefined (adding reference field in singleArray)
					d[this.valueProperty] = this.json[i][this.valueProperty] || "";
					deltaRows.push(d);
				} else {
					deltaRows.push(this.json[i][this.valueProperty]);
				}
			}
			return deltaRows;
		},
		applyDelta: function(delta, context) {
			if (context === "template") {
				// Clear array's content
				this.removeAllRows();
			}
			var rowsAdded = 0;
			for (var ii = 0, jj = delta.length; ii < jj; ii++) {
				var deltaRow = delta[ii];
				if (ii < this.json.length) {
					var row = this.json[ii];
					var rowChanged = false;
					var $bind;
					if (this.isReferenceArray) {
						if (row[this.valueProperty] !== deltaRow[this.valueProperty]) {
							row[this.valueProperty] = deltaRow[this.valueProperty];
							$bind = "$value_ref";
							rowChanged = true;
						}
					} else {
						if (row[this.valueProperty] !== deltaRow) {
							row[this.valueProperty] = deltaRow;
							$bind = this.valueProperty;
							rowChanged = true;
						}
					}
					if (rowChanged && $bind) {
						// If the value changed, let the dataset representing the row know of it
						var rowDataset = this.rowDatasetsByUuid[row.$uuid];
						if (rowDataset) { // there may be no row dataset if the row was not read by the UI, so no need to notify
							rowDataset._deltaManValueChanged($bind);
						}
					}
				} else {
					if (this.isReferenceArray) {
						// We do not care about uuid set by the server. It's not used in the protocol
						// Better create our own one to persistently identify the row on client side 
						deltaRow.$uuid = utils.UUID();
						this.json.push(deltaRow);
					} else {
						this.json.push(this._wrapRow(deltaRow));
					}
					rowsAdded++;
				}
			}
			if (delta.length < this.json.length) {
				// Cleanup dataset of removed rows
				for (var ii = delta.length, jj = this.json.length; ii < jj; ii++) {
					this._deltaManRowRemoved(this.json[ii].$uuid, ii);
					this.removeDatasetByUuid(this.json[ii].$uuid);
				}
				var rowsRemoved = this.json.length - delta.length;
				this.json.splice(delta.length, rowsRemoved);
			} else if (rowsAdded > 0) {
				for (var ii = this.json.length - rowsAdded, jj = this.json.length; ii < jj; ii++) {
					// If there are new rows, let the listeners know 
					this._deltaManRowAdded(this.json[ii].$uuid, ii);
				}
			}
			this.dirtyProperties = [];
		},
		setClean: function($bind, includeChildren) {
			// This override is only for documentation
			// once a single property array is dirty, it will never become clean again
			// console.log("Cleaning a row's dirty flag will never cleanup array for simple type arrays");
			Base.prototype.setClean.call(this, $bind, includeChildren);
		},
		_setAllRowsDirty: function() {
			this.setDirty(this.$bind);
		},
		_wrapRow: function(row) {
			if (row && row.$value != null) {
				// Already wrapped
				return row;
			}
			return {
				$uuid: utils.UUID(),
				$value: row
			};
		},
		buildTemplateData: function() {
			var result = [];
			for (var ii = 0, jj = this.json.length; ii < jj; ii++) {
				var row = this.json[ii];
				if (this.isReferenceArray) {
					result.push(row);
				} else {
					result.push(row[this.valueProperty]);
				}
			}
			return result;
		}
	}
);