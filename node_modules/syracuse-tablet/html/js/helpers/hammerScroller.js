"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("scroll", false);
var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var Hammer = require('syracuse-tablet/html/deps/hammerjs-2.0.4/hammer');
var _scrollerId = 1;

var _stopClickEvent = function(mgr, evt, reason) {
	log && log("Clicked canceled", reason, mgr.id);
	evt.stopPropagation();
	evt.preventDefault();
	evt.$stop = true;
};
// Time to wait before allowing click events a scrolling
var _lastClickTO = 400;
// Enable the slowdown process - scroll continue after panend (mouse up ) like on native devices
var _slowDown = true;
// Move the $$elmt after _slowDownTO in slowdown process
var _slowDownTO = 10;
/**
 * returns the distance to move according to velocity v
 */
var _velocityToDist = function(velocity) {
	// Velocity of the move - 0 if we move the finger slowly and ~ 2 for fast - TO IMPROVE REGARDING THE CONTEXT - TOUCH/DESKTOP 
	var v = Math.abs(Math.round(velocity * 4));
	// Distance to move - square function of velocity (non linear) 
	// Allow to move slow and fast if we increase the speed of the finger
	return Math.max(1, v * v / 2);
};
/**
 * Creates a vertical/horizontal scroller which emulates the tablet native behavior
 * 		$$elmt		element to scroll
 * 		options		callBack		Optional Called on event and skip default process
 * 					valMax			maximum top - 0 by default - 50 for pages with header...
 * 					direction		h/v
 * 					isPageScroller	true/false
 * 		parentMgr	parent scroll manager (the page's one for an array scroller)
 * 					used to deal with click event
 * 		$$nativeScroll 	div that will take the native scroll when we disable the scrolling (for test and authoring)
 * 						optional - $elmt if null
 */
var _consts = {
	pan: {
		v: "panup pandown panstart panend",
		h: "panleft panright panstart panend"
	},
	dir: {
		v: Hammer.DIRECTION_VERTICAL,
		h: Hammer.DIRECTION_HORIZONTAL
	},
	upEvt: {
		v: "panup",
		h: "panleft"
	},
	dirToAxis: {
		v: "y",
		h: "x"
	},
	dirToOtherAxis: {
		v: "x",
		h: "y"
	}
};
var _Klass = utils.defineClass(function hammerScroller($$elmt, options, parentMgr, $$nativeScroll) {
	options = options || {};
	this.useNativeScroll = true;
	this.hammer = null;
	this.$$elmt = $$elmt;
	this.$$nativeScroll = $$nativeScroll || $$elmt;
	if ($$elmt == "null") throw new Error("hammerScroller - null $$elmt");
	this.id = $$elmt.closest("[id]").attr("id");
	// Max top always 0 because we scroll in relative / parent - If needed pass it in parameter
	this.valMax = options.valMax != null ? options.valMax : 0;
	this.name = options.name || "scroller";
	this.parentMgr = parentMgr;
	this.callBack = options.callBack;
	this.isPageScroller = options.isPageScroller === true;
	// Init hammer manager
	if (!this.useNativeScroll) {
		this.hammer = new Hammer(this.$$elmt.get(0));
	}
	// Direction of scroller
	if (options.direction) {
		this._initDir(options.direction);
	}
	if (this.useNativeScroll) {
		this._setCSS();
	}
	// evts enabled - false by default
	this._evtsEnabled = false;
	// To allow disable/Enable - General HammerScroller objects - all object will be toggled
	notifications.subscribe(this, ["sm.scroller.toggle"], 1);
}, null, {
	/**
	 * Init direction and associated pan events
	 */
	_initDir: function(direction) {
		this.dir = direction;
		if (this.dir !== "v" && this.dir !== "h") throw new Error("hammerScroller - Unexpected direction [" + this.dir + "]");
		// event than means up or right
		this.upEvtType = _consts.upEvt[this.dir];
	},
	_setCSS: function(dir) {
		dir = dir || this.dir || "v";
		var $$parent = this.$$elmt.parent();
		var css = {};
		css["overflow-" + _consts.dirToAxis[dir]] = "auto"; // scrolling axis
		css["overflow-" + _consts.dirToOtherAxis[dir]] = "hidden"; // "unused" or fixed axis


		$$parent.css(css);

		/*
		var pan = "pan-" + _consts.dirToAxis[dir]; // -> pan-x or pan-y;
		var panCss = {};
		panCss["-ms-touch-action"] = pan;
		panCss["touch-action"] = pan;
		$$parent.css(panCss);
		this.$$elmt.css(panCss);
		*/

		// remove default touch action on all elements
		// would be better if doing this by loading a css file with the appropriate * {} selector instead of setting it on each element
		$("*").css({
			"touch-action": "auto",
			"-ms-touch-action": "auto"
		});
	},

	/**
	 * Called before init
	 * I reset the old scrolling on $$elmt before calculating the new viewRect
	 * Init is called in callBack function
	 */
	resetScrolling: function(callBack) {
		if (this.val != null) {
			this.setVal(this.valMax);
			this.refresh();
			this.reset();
		}
		if (callBack) callBack();
	},
	/**
	 * We need to initialize the scroll after creation
	 * Scrollable object arrays/pages have an empty scroll which is initialized if needed
	 * Initialization needs to be called when the object has been displayed (after show) to make sure that viewRect is ok
	 * To manage savedCtxRestore it's also the better way
	 * 		- save ctx (top)is stored and took into account at initialization
	 * Params
	 * 		viewRect		rectangle (uiUtils/rect class) of the view within we will move the content of $$elmt (kind of window)
	 * 						!!!top/left must be in fixed coordinates (relative to document)
	 * 						in order to be able to check if mouse pointer belongs to this rect on mousemove/pandown
	 * 		dir				To change dir if needed (orientation changed)
	 * 		valMax			To change valMax if needed (orientation changed)
	 * 		keepScrolling	true to init scrollRect and keep the scrolling
	 * 						used to for child pages
	 */
	init: function(viewRect, dir, valMax, keepScrolling) {
		if (this.useNativeScroll) {
			this._setCSS(dir);
			return;
		}
		if (viewRect == null) throw new Error("hammerScroller - Unexpected null viewRect");
		if (keepScrolling === true && this.val != null) {
			this.restoredVal = this.val;
		}
		// Reset the scroller - not all values - keep valMax, dir, restoredVal...
		this.reset(true);
		// Init can override direction
		if (dir != null && this.dir != dir) {
			this._initDir(dir);
		}
		if (this.dir == null) throw new Error("hammerScroller - Unexpected null direction");
		if (globals.getSiteLayout().getTransformScale() != 1) {
			viewRect = viewRect.applyTransformScale(globals.getSiteLayout().getTransformScale(), true);
		}
		// viewRect defines the boundaries
		this.viewRect = viewRect;
		// We need pan and not swipe
		this.hammer.get("pan").set({
			threshold: 0, // Small threshold to bloc the click (mouseup) as son as pan start- To test on mobile devices
			direction: _consts.dir[this.dir]
		});
		// We need press to stop the scolling
		this.hammer.get("press").set({
			time: 1 //Small timeout needed to stop immediately when press
		});
		// Create handlers
		this._panHandler = Hammer.bindFn(this.onPan, this);
		this._pressHandler = Hammer.bindFn(this.onPress, this);
		this._clickHandler = Hammer.bindFn(this.onClick, this);
		// - altClick enable/disable the scrolling
		this.$$elmt.on('click', this._clickHandler);
		// Bind events
		// Original rectangle - used to enable/disable scrolling
		// !!! Images and components loaded by URL need to have a fix height !!! otherwise we can't calculate the height
		this._originalRect = uiRect.elmtRect(this.$$elmt);
		// Store the original offset because it's the reference (only for embedded object like page into vignette and arrays)
		// globals.getCurrentPage() can be nul since we use scroller in modal (globals.getCurrentPage() is null if an error occure on page loading)
		this._originalScrollOffset = this.isPageScroller || !globals.getCurrentPage() ? null : globals.getCurrentPage().getScrollOffset();
		this._enableEvents(true);
		// Init can override valMax
		if (valMax != null) this.valMax = valMax;
		// Values set by restoreSaveContext - back 
		this.setVal(this.restoredVal == null ? this.valMax : this.restoredVal);
		if (keepScrolling === true && this.restoredVal != null) {
			// If keepScrolling we have to adjust in case the newValMin < previousVal < newValMax
			this.adjust();
		}
		this.restoredVal = null;
		// Reset the new scrolling
		this.refresh();
	},
	/**
	 * Enable / Disable events
	 * Used by reset and Alt Click
	 * toggleStatus: true means that we toggle 'native scroll' <-> 'hammer scroll'
	 */
	_enableEvents: function(yes) {
		//this.viewRect == null -> scroller has not been initialized
		// Can occurs because we create a non-initialized scroller for pages/array so they can be notified even if they've not been initialized
		if (!this.viewRect) return;
		var wasDisabled = this._evtsEnabled === false;
		// ENABLED
		if (yes === true && this._evtsEnabled !== true) {
			this._evtsEnabled = true;
			this.hammer.on(_consts.pan[this.dir], this._panHandler);
			this.hammer.on("press", this._pressHandler);
			// Just to find elmt with debugger
			this.$$elmt.addClass("s-m-scroll" + this.dir);
		}
		// DISABLED
		if (yes === false && this._evtsEnabled !== false) {
			if (this._evtsEnabled === false) return;
			this._evtsEnabled = false;
			if (this.hammer) {
				this.hammer.off(_consts.pan[this.dir], this._panHandler);
				this.hammer.off("press", this._pressHandler);
			}
			this.$$elmt.removeClass("s-m-scroll" + this.dir);
		}
		// IN ANY CASES
		if (wasDisabled) {
			// Nothing
		} else {
			this.panStart = false;
			this.stopSlowingDown();
			this.cancelClick = false;
			this.lastClickAllowed = null;
		}
	},
	/**
	 * Disable scroll but keep the capability to re-initialize it
	 */
	reset: function(dontResetValue) {
		if (this.useNativeScroll) {
			return;
		}
		if (dontResetValue !== true && this.viewRect != null) {
			this.setVal(this.valMax);
			// Put initial value
			this.refresh();
		}
		// !! FIRST - Disable events
		this._enableEvents(false);
		// Disable click - No mo more scrolling compared to disable/enable
		if (this.$$elmt) {
			// TODO - There a double destroy ??
			this.$$elmt.off('click', this._clickHandler);
		}
		// After
		this.viewRect = null;
		// True if panstart - mouse start to move
		this.panStart = false;
		// True if the scroll is slowing down after panend (mouse up)
		this.stopSlowingDown();
		// Cancel click on a link
		this.cancelClick = false;
		//Prevent click after _lastClickTO ms after a panend
		this.lastClickAllowed = null;
		// Null to force to set value on init ( context restored)
		this.val = null;
		this.isLocked = false;
		// !! DO NOT RESET - dir, valMax, parentMgr, restoredVal
	},
	/**
	 * Destroy scroller
	 */
	destroy: function() {
		// First
		this.reset();
		// After
		if (this.hammer) {
			this.hammer.destroy();
			this.hammer = null;
		}
		this.$$elmt = null;
		this.$$nativeScroll = null;
		this.callBack = null;
		this._panHandler = null;
		this._pressHandler = null;
		this._toggleRect(false);
		this._clickHandler = null;
		notifications.unsubscribe(this);
	},
	/**
	 * Refresh scrolling
	 * 	internal call or called to refresh scrolling when we activate cached pages
	 */
	refresh: function() {
		if (this.useNativeScroll) {
			return;
		}
		if (!this.$$elmt || !this.dir) return;
		if (this.dir == "v") {
			this.$$elmt.css({
				top: this.val + "px"
			});
		} else {
			this.$$elmt.css({
				left: this.val + "px"
			});
		}
	},
	_getScrollOffset: function() {
		if (this.isPageScroller || this._originalScrollOffset == null) return null;
		var o = globals.getCurrentPage().getScrollOffset();
		if (o == null) return null;
		return {
			top: o.top - this._originalScrollOffset.top,
			left: o.left - this._originalScrollOffset.left
		};
	},
	_toggleRect: function(remove) {
		// Debug show the rectangle - fixed position 
		if (this._$$viewRect) {
			this._$$viewRect.remove();
			this._$$viewRect.off('click', this._clickHandler);
			this._$$viewRect = null;
		} else if (remove !== false) {
			this._$$viewRect = this.viewRect.showInDocument();
			var o = this._getScrollOffset();
			if (o) {
				this._$$viewRect.css({
					marginTop: "+=" + o.top,
					marginLeft: "+=" + o.left
				});
			}
			this._$$viewRect.on('click', this._clickHandler);
		}
	},
	/**
	 * Intercept click/mouseup events for filtering
	 * We need to filter click events to control the triggering of links
	 * altClick 	-> Enables/Disables scrolling
	 * shiftClick	-> Displays/Hides the viewRect
	 */
	onClick: function(evt) {
		log && log("onClick Status", "slowingDown:", this.slowingDown, "panStart:", this.panStart, "cancelClick:", this.cancelClick, "lastClickAllowed:", this.lastClickAllowed ? new Date().getTime() - this.lastClickAllowed : null);
		evt.$stop = false;
		if (evt.shiftKey) {
			this._toggleRect();
			return _stopClickEvent(this, evt, "Show rectangle");
		}
		// If disable we skip
		if (this._evtsEnabled === false) return;
		if (this.slowingDown) {
			return _stopClickEvent(this, evt, "slowing down");
		}
		if (this.cancelClick) {
			this.cancelClick = false;
			return _stopClickEvent(this, evt, "Click canceled");
		}
		if (this.lastClickAllowed != null && ((new Date().getTime() - this.lastClickAllowed) < 0)) {
			// Click is authorized if not slowingDown or if not cancelClick
			// We wait _lastClickTO after panend (mouseup) to allow click
			this.lastClickAllowed = null;
			return _stopClickEvent(this, evt, "Last click timeout");
		}
		if (this.parentMgr && this.parentMgr.dir != this.dir) {
			// For double scroll direction one by parent and one by a grid we need to sak the parent to cancel the click 
			this.parentMgr.onClick(evt);
			if (evt.$stop === true) {
				return _stopClickEvent(this, evt, "Parent stopped click");
			}
		}
		log && log("onClick not stopped");
	},
	/**
	 * Used to stop the slowdown process
	 */
	onPress: function(evt) {
		this.lastPress = new Date().getTime();
		if (this.slowingDown) {
			this.stopSlowingDown();
			// Last click is avoided - The click evt that is always triggered after press a event
			this.cancelClick = true;
		}
		if (this.parentMgr) this.parentMgr.isLocked = false;
		log && log(this.id, "onPress", "slowingDown=" + this.slowingDown, "panStart=" + this.panStart, "cancelClick =" + this.cancelClick, "lastClickAllowed =" + this.lastClickAllowed);
	},
	/**
	 * pan event - mousedown/mousemove/mouseup
	 */
	onPan: function(evt) {
		log && log(this.id, evt.type, this.dir, utils.isEvtDirection(evt, this.dir), "isLocked", this.isLocked);
		if (!utils.isEvtDirection(evt, this.dir)) return;
		if (this.isLocked === true) return;
		try {
			if (false && !this.viewRect.isEvtInside(evt.srcEvent, this._getScrollOffset())) {
				// outside the viewRect -> Stop process
				log && log("outside");
				return;
			}
			if (evt.type === "panstart") {
				// Mouse mousedown + mousemove event - start the process
				log && log(evt.type);
				this.panStart = true;
				this.cancelClick = true;
				this.stopSlowingDown();
				if (this.parentMgr && (this.parentMgr.dir === this.dir)) this.parentMgr.isLocked = true;
			} else if (evt.type === "panend") {
				// mouseup  - we continue to scroll (_slowDown) until the user do a press event to stop scrolling
				log && log(evt.type);
				this.panStart = false;
				if (_slowDown && this.lastVelocity != null) {
					// We keep the last velocity for slowdown process
					this.lastVelocity = Math.abs(this.lastVelocity);
					if (this.lastVelocity > 0.3 && this.lastVelocity < 1) {
						// If velocity is too small we keep 1
						this.lastVelocity = 1;
					} else {
						// under.3 we consider that we need to stop scrolling
						this.lastVelocity = Math.min(this.lastVelocity, 2);
					}
					if (this.lastVelocity >= 1) {
						// _slowDown option continue the process by decreasing the speed slowly and moving $$elmt
						this.slowingDown = true;
						this.slowDown(this.lastVelocity, this.lastUp);
						this.lastVelocity = this.lastUp = null;
					} else {
						if (this.parentMgr) this.parentMgr.isLocked = false;
					}
				} else {
					// avoid click on mouse up
					this.lastClickAllowed = new Date().getTime() + _lastClickTO;
					if (this.parentMgr) this.parentMgr.isLocked = false;
				}
				return;
			}
			// Direction of the scroll
			// Up means up or right 
			var up = evt.type === this.upEvtType || evt.type === "panstart" && evt.deltaY < 0;
			if (this.move(_velocityToDist(evt.velocity), up)) {
				this.lastVelocity = Math.abs(evt.velocity);
				this.lastUp = up;
			} else {
				this.lastVelocity = this.lastUp = null;
			}
		} catch (e) {
			console.log(JSON.stringify(jsutils.convertToDiagnoses(e), null, 2));
			return false;
		}
	},
	stopSlowingDown: function() {
		this.slowingDown = false;
		if (this.parentMgr) this.parentMgr.isLocked = false;
	},
	/**
	 * Keep the last speed to continue scrolling process until the user do a press evt
	 */
	slowDown: function(v, up) {
		var self = this;
		if (self.panStart || !self.slowingDown) {
			this.stopSlowingDown();
			return;
		}
		// keep the same velocity - to improve - we can decrease...
		if (v < 1) {
			this.stopSlowingDown();
			return;
		}
		if (self.move(_velocityToDist(v), up)) {
			// Move until stop with _slowDownTO timeout
			setTimeout(function() {
				self.slowDown(v, up);
			}, _slowDownTO);
		} else {
			this.stopSlowingDown();
		}
	},
	/**
	 * Move $$elmt vertically
	 */
	move: function(dist, up) {
		try {
			if (dist == 0) return;
			// Check boundaries
			var val = up ? this.val - dist : this.val + dist;
			var valMin = this.getValMin();
			val = Math.max(Math.min(this.valMax, val), valMin);
			if (val === this.valMax || val === valMin) {
				log && log(this.id, "end scrolling");
				// avoid click during xx ms on mouse up at the end of scrolling
				this.lastClickAllowed = new Date().getTime() + _lastClickTO;
				this.cancelClick = false;
				if (this.val === val) {
					// Overflow -> Stop
					// log && log("move overflow")
					return false;
				}
			}
			this.setVal(val);
			if (this.callBack) {
				return this.callBack(this.val);
			} else {
				// Move elmt
				this.refresh();
				return true;
			}
		} catch (e) {
			console.log(JSON.stringify(jsutils.convertToDiagnoses(e), null, 2));
			return false;
		}
	},
	// Save context if enabled
	savedCtxCreate: function() {
		return this.hammer ? {
			val: this.val
		} : null;
	},
	// Restored context
	savedCtxRestore: function(ctx, refresh) {
		if (ctx == null || ctx.val == null) return;
		// Set val - if refresh == false that means that we need to call init method 
		this.restoredVal = ctx.val;
		if (refresh) {
			// By example called by a cached pages which has been activated
			this.refresh();
		}
	},
	getOffset: function() {
		return {
			top: this.dir == "v" ? this.val : 0,
			left: this.dir == "h" ? this.val : 0
		};
	},
	/**
	 * status	null	 	toggles this._evtsEnabled otherwise
	 * 			true 		forces enable
	 * 			false		forces disable
	 */
	notifScrollerToggle: function(status) {
		this._enableEvents(status == null ? !this._evtsEnabled : status === true, true);
		/**
		 * Set $$elmt and $$nativeScroll to enable/disable native scrolling (browser's scroll bar)
		 */
		// Set $$nativeScroll properties - overflow and width/height
		var css = {
			overflow: "hidden"
		};
		// Set the width/height with right values
		var prop = this.dir === "h" ? "width" : "height";
		//!! _originalRect is not changed only if toggleStatus == true
		css[prop] = this._originalRect[prop] + "px";
		this.$$nativeScroll.css(css);
		// Set $$elmts properties - top and overflow
		var css = {
			overflow: "hidden"
		};
		// Position to default offset
		css[this.dir === "h" ? "left" : "top"] = this.valMax + "px";
		this.$$elmt.css(css);
		this.setVal(this.valMax);
	},
	/**
	 * Show element in page - scroll if needed
	 * c is a JQuery elmt or an object with $$elmt property
	 */
	makeVisible: function($$e) {
		if (this.useNativeScroll) {
			return;
		}
		if (this.slowingDown) {
			this.stopSlowingDown();
			// Last click is avoided - The click evt that is always triggered after press a event
			this.cancelClick = true;
		}
		if (!$$e || !$$e.jquery || $$e.length == 0) return;
		if (!$$e.is(":visible")) {
			$$e.parents(".s-m-stack").map(function(stack) {
				var stackLayout = globals.getCurrentPage().getLayout($(this).attr("id"));
				stackLayout && stackLayout.setAuthState({
					"collapsed": false
				});
			});
		}

		if (this.viewRect == null) return;
		if ($$e.closest(this.$$elmt).length === 0) return;
		if (!this._evtsEnabled) return;



		var prop = this.dir === "v" ? "top" : "left";
		var size = this.dir === "v" ? "height" : "width";
		var o = $$e.offset();
		var offset = globals.getSiteLayout().getTransformScale() * $$e[size]() / 2;
		o[prop] = o[prop] + offset;
		if (o[prop] > this.viewRect[prop] && o[prop] < (this.viewRect[prop] + this.viewRect[size] - 10)) {
			return;
		}
		this.$$elmt.css("visibility", "hidden");
		var f = o[prop] > this.viewRect[prop] ? -1 : +1;
		//$$e.css("background-color", "red");
		// FDB - Best way I found to right position $$e - Perhaps we can do that in one shot
		// Comparing this.$elmt.offset et $e.offset doesn't work
		var stopPos = this.viewRect[prop] + this.viewRect[size] / 2;
		var stop = !$$e.is(":visible");
		while (!stop) {
			var pos = $$e.offset()[prop] + offset;
			stop = f > 0 ? pos > stopPos : pos < stopPos;
			if (!stop) {
				this.setVal(this.val + 50 * f);
				this.refresh();
			}
		}
		var valMin = this.getValMin();
		if (this.val < valMin) {
			this.setVal(valMin);
			this.refresh();
		}
		if (this.val > this.valMax) {
			this.setVal(this.valMax);
			this.refresh();
		}
		this.$$elmt.css("visibility", "visible");
	},
	autoScroll: function(value) {
		this.move(Math.abs(value), value < 0);
	},
	getScrollValue: function(value) {
		return this.val;
	},
	/**
	 * Calculated dynamically because the content of the page can be modified after initisalization of scroller
	 */
	getValMin: function() {
		var prop = this.dir == "v" ? "height" : "width";
		var x = this.$$elmt[prop]();
		if (false && globals.getSiteLayout().getTransformScale() != 1) {
			// disabled because doesn't work fine - Like we scaled viewRect we should scale x 
			x = x * globals.getSiteLayout().getTransformScale();
		}
		// 30 pixel more
		return Math.min(this.valMax - x + this.viewRect[prop] - 30, this.valMax);
	},
	// Adjust the scroller after modification of DOM to make this.$elmt visible
	// By example after an action which hides lines we need to call this method to adjust scrolling because the visible area can be outside the viewRect
	adjust: function() {
		// Panel has not been initialized
		if (this.viewRect == null) return;
		var newVal = null;
		var elmtRect = uiRect.elmtRect(this.$$elmt);
		if (this.viewRect.contains(elmtRect)) {
			newVal = this.valMax;
		} else {
			if (this.val > this.valMax) {
				newVal = this.valMax;
			}
			var prop = this.dir == "v" ? "height" : "width";
			var valmin = this.valMax - elmtRect[prop] + this.viewRect[prop];
			if (this.val < valmin) {
				newVal = this.getValMin();
			}
		}
		if (newVal != null) {
			this.setVal(newVal);
			this.refresh();
		}
	},
	// Move to beginning 
	scrollToBeginning: function() {
		this.setVal(this.valMax);
		this.refresh();
	},
	/**
	 * Check if the current scroll element is contained by  viewRect
	 * If true -> reset scrollin - no need
	 * Else re-init scrolling
	 */
	checkViewRect: function(viewRect, preserveScroll) {
		if (this.useNativeScroll) {
			return;
		}
		var reset = true;
		if (viewRect && this.$$elmt) {
			// For multiselection in card mode we can hide cards. We need to scroll to beginning in order to calculate the right rect
			var val = this.val;
			this.scrollToBeginning();
			if (preserveScroll) {
				this.setVal(val);
			}
			var myRect = uiRect.elmtRect(this.$$elmt, "computed");
			var intersectRect = viewRect.intersectRect(myRect, false);
			if (intersectRect != null) {
				this.init(intersectRect, null, null, preserveScroll);
				reset = false;
				if (preserveScroll) {
					// If preserveScroll we have to adjust in case the newValMin < previousVal < newValMax
					this.adjust();
				}
			}
		}
		if (reset) {
			this.reset();
		}
		return !reset;
	},
	setVal: function(v) {
		if (isNaN(v)) v = 0;
		this.val = v;
	}
});

var _createSimpleScroller = function($$elmt) {
	var $$scrolls = $$elmt.find(".s-m-scroll-element");
	var i;
	var scrollers = {};

	for (i = 0; i < $$scrolls.length; i++) {
		_scrollerId++;

		var $$se = $($$scrolls[i]);
		var $$wrapper = $$se.parent();
		var dir = $$wrapper.hasClass("s-m-scroll-wrapper-h") ? "h" : "v";

		$$wrapper.attr("data-scroller-id", _scrollerId);

		var parentScroller = null;
		var $$parentScroller = $$wrapper.parent().closest(".s-m-scroll-wrapper");
		if ($$parentScroller.length > 0) {
			parentScroller = scrollers[$$parentScroller.attr("data-scroller-id")];
		}

		var css = {};
		css["overflow-" + dir] = "auto";
		$$wrapper.css(css);

		var gestureMgr = new _Klass($$se, {
			direction: dir,
			valMax: 0,
			name: "_scroller_" + _scrollerId,
			isPageScroller: false
		}, parentScroller);
		scrollers[_scrollerId] = gestureMgr;

		var scrollRect = uiRect.elmtRect($$se, "outer");
		var wrapperRect = uiRect.elmtRect($$wrapper, "outer");
		var viewRect = wrapperRect.intersectRect(scrollRect);
		if (viewRect && !viewRect.contains(scrollRect)) {
			gestureMgr.init(viewRect);
		} else {
			gestureMgr.reset();
		}
	}

	return scrollers;
};

exports.Klass = _Klass;
exports.Hammer = Hammer;
exports.createSimpleScroller = _createSimpleScroller;