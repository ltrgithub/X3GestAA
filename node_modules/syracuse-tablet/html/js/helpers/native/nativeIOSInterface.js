"use strict";

/*
 * 
 * THIS COE MUST BE LOADED IN HTML PAGE
 * IOS WRAPPER NEEDS THE AVAILABILILTY OF initIOSWrapper 
 * !! This file must not be included into minimize main file
 * 
 */

/*
 * TEMPORARY - DOM Logger
 */
/*
var _$$logIos
var _logIos = function(msg) {
	if (!_$$logIos) _$$logIos = document.querySelector("#logios")
	if (!_$$logIos) return;
	var args = Array.prototype.concat.apply([], arguments);
	var h = _$$logIos.innerHTML
	_$$logIos.innerHTML = h + "<br>" + args.join(' - ')
}
window.logIos = _logIos
<div style="height:300px;overflow-y:auto;color:red;z-index:2000000;right:0;position:absolute;background-color:black;" id="logios"></div>
*/

// NATIVE IOS LOGGER
var _IOSNativeLogger = function() {
	this.log = function(msg) {
		var args = []
		for (var i = 0; i < arguments.length; i++) {
			// IOS logger doesn't accept null value - Only Strings
			if (arguments[i] != null) {
				args[i] = arguments[i] + ""
			} else {
				args[i] = ""
			}
		}
		window.webkit.messageHandlers.log.postMessage(args)
	}
	this.logError = function(where, e) {
		this.log(where, e.message, e.stack)
	}
}
if (window.webkit) {
	window.smNativeLogger = new _IOSNativeLogger()
}

// NATIVE IOS WRAPPER
var _IOSNativeInterface = function() {
		this._promiseCpt = 0
		this._promisesMap = {}

		/*
		 * Returns an IOS NSDictionary 
		 */
		this._serializeToIOSDictionnary = function(names, args) {
				var res = {},
					data
				names.forEach(function(name, idx) {
						res[name] = args != null ? args[idx] : null
						if (res[name] != null && typeof res[name] != "string") {
							throw new Error("IOS Callback - Unexpected parameter type [" + typeof res[name] + "]- Expected string - Name[" + name + "]")
						}
					})
					//window.smNativeLogger.log(JSON.stringify(res, null, 2))
				return res
			}
			/*
			 * Creates/Stored a deferred and returns the promise
			 */
		this._createPromise = function(domain, method) {
				var deferred = $.Deferred()
				var promiseID = domain + "-" + method + "-" + this._promiseCpt++
					var promise = deferred.promise()
				this._promisesMap[promiseID] = deferred
					// ID to retrieve it later
				promise.sageX3MobleID = promiseID
					//window.smNativeLogger.log("promiseID = " + promise.sageX3MobleID)
				return promise
			}
			/*
			 * Resolve/Reject the promise given by promiseID which has been stored previoulsy
			 *	action reject/resolve
			 */
		this._processPromise = function(promiseID, action, result) {
				var deferred = this._promisesMap[promiseID]
				if (!deferred) {
					throw new Error("IOS - Promise not found[" + promiseID + "]")
				}
				delete this._promisesMap[promiseID]
					//	window.smNativeLogger.log("IOS - processPromise", promiseID, action)
				deferred[action](result)
			}
			/**
			 * Safari doesn't support webSQL in a WKWebView
			 */
		this.getSupportedDB = function() {
				return $.smResolve("indexedDB")
			}
			/*
			 * Notify the wrapper that all the resources have been loaded and that the application is starting
			 */
		this.appStartsRunning = function() {
				window.smNativeLogger.log("appStartsRunning")
				window.webkit.messageHandlers.appStartsRunning.postMessage([])
			}
			/*
			 * Calls the regular isSupported wrappers's method
			 * 	The wrapper's response is sent asynchronously (see prosessResponse/prosessException)
			 */
		this.isSupported = function(domain, method) {
				var promise = this._createPromise(domain, method);
				var args = [promise.sageX3MobleID, domain, method];
				//window.smNativeLogger.log("isSupported args = " + args.join('-'))
				window.webkit.messageHandlers.isSupported.postMessage(this._serializeToIOSDictionnary(["promiseID", "domain", "method"], args));
				return promise;
			}
			/*
			 * Call the regular callMethod wrappers's method
			 * 	The wrapper's response is sent asynchronously (see prosessResponse/prosessException)
			 */
		this.callMethod = function(domain, method, param) {
				var promise = this._createPromise(domain, method);
				var args = [promise.sageX3MobleID, domain, method, param];
				//window.smNativeLogger.log("callMethod args = " + args.join('-'))
				window.webkit.messageHandlers.callMethod.postMessage(this._serializeToIOSDictionnary(["promiseID", "domain", "method", "params"], args));
				return promise;
			}
			/*
			 * Call the regular fireMethod wrappers's method
			 * 	No response is expected from the wrapper
			 */
		this.fireMethod = function(domain, method, param) {
				var args = [domain, method, param];
				// window.smNativeLogger.log("fireMethod args = " + args.join('-'))
				window.webkit.messageHandlers.fireMethod.postMessage(this._serializeToIOSDictionnary(["domain", "method", "params"], args))
			}
			/*
			 * Process the result of callMethod
			 * 	promiseID ID of the promise to resolve
			 *	type type of data returned by wrapper
			 *	responseStr stringified result
			 */
		this.prosessResponse = function(promiseID, type, responseStr) {
				try {
					type = decodeURIComponent(type);
					promiseID = decodeURIComponent(promiseID);
					var result = this.convertIOSData(type, decodeURIComponent(responseStr));
					this._processPromise(promiseID, "resolve", result)
					window.smNativeLogger.log("IOS - RESPONSE PROCESSED", promiseID, type) //, responseStr);
					return null
				} catch (e) {
					window.smNativeLogger.logError("Native call iosServiceResponse", e);
					// ISO Wrapper will recieve and log the error + the stack
					return this.convertErrorForIOS(e)
				}
			}
			/*
			 * Process an IOS exception of callMethod
			 * 	promiseID ID of the promise to reject
			 *	serializedError stringified error
			 */
		this.prosessException = function(promiseID, serializedError) {
				try {
					promiseID = decodeURIComponent(promiseID)
					serializedError = decodeURIComponent(serializedError)
					window.smNativeLogger.log("IOS Wrapper prosessException", serializedError);
					var error = new Error("IOS wrapper exception");
					error.stack = serializedError;
					this._processPromise(promiseID, "reject", error);
				} catch (e) {
					window.smNativeLogger.logError("Native call iosServiceException", e.message)
						// ISO Wrapper will recieve and log the error + the stack
					return this.convertErrorForIOS(e)
				}
			}
			/*
			 * Returns the JS typed data according to the type
			 */
		this.convertIOSData = function(type, dataStr) {

			window.smNativeLogger.log("convertIOSData", type, dataStr)
			if (type == null || dataStr == null) {
				return null;
			}
			switch (type) {
				case "boolean":
					return "true" === dataStr;
				case "string":
					return decodeURIComponent(dataStr);
				default:
					try {
						return dataStr.trim().length === 0 ? null : JSON.parse(decodeURIComponent(dataStr));
					} catch (e) {
						throw new Error("convertIOSData - BAD JSON STRING - " + type + " - " + dataStr)
					}
			}
		}

		/*
		 * Serialize a JAVASCRIPT error in a NSDictionary
		 */
		this.convertErrorForIOS = function(error) {
				var res = {
					type: "error"
				}
				if (error == null) {
					res.message = "No error message";
				} else if (typeof error == "string") {
					res.message = error;
				} else if (typeof error == "object") {
					res.message = error.message;
					if (error.stack) {
						res.stack = error.stack.replace(new RegExp(window.location.href.substring(0, window.location.href.lastIndexOf('/')), "g"), "  ");
						res.stack = res.stack.split("\n");
					}
				} else {
					res = null
				}
				return res
			}
			// Returns a type + a string
		this.convertResultForIOS = function(result) {
			if (result == null) return null;
			var res = {}
			var type = typeof result
			switch (type) {
				case "boolean":
					res.type = "boolean";
					res.data = result ? "true" : "false";
					return res;
				case "number":
				case "string":
					res.type = type;
					res.data = result;
					return res;
				case "object":
					try {
						res.type = "json";
						res.data = JSON.stringify(result, null, 2);
						return res;
					} catch (e) {
						throw new Error("convertResultForIOS - Error Stringifying result")
					}
				default:
					return null;
			}
		}
	}
	/*
	 * Called by IOSWrapper to initialize the native object when the document has been loaded (WKUserScriptInjectionTime.AtDocumentEnd)
	 *	Must be declared in html page (not in a require)
	 *	Crates all the needed object
	 */
window.initIOSWrapper = function(promiseID, responseJSON) {
	window.smNativeLogger = new _IOSNativeLogger()
	window.smNativeInterface = new _IOSNativeInterface()
	window.smNativeLogger.log("IOS Wrapper initialized")
};
/*
 * Called by IOS Wrapper to send the response to callMethod/isSuppported services
 */
window.iosServiceResponse = function(promiseID, type, responseStr) {
	// window.smNativeLogger.log("JS CALLBACK iosServiceResponse")
	if (!window.smNativeInterface) return;
	window.smNativeInterface.prosessResponse(promiseID, type, responseStr);
};
/*
 * Called by IOS Wrapper to send an exception if callMethod/isSuppported failed
 */
window.iosServiceException = function(promiseID, serializedError) {
	// window.smNativeLogger.log("JS CALLBACK iosServiceException")
	if (!window.smNativeInterface) return;
	window.smNativeInterface.prosessException(promiseID, serializedError);
};
/*
 * Called by IOS wrapped to invoke the given objectName/methodName javascript service
 *	The response is returned synchronously
 */
window.iosJavascriptServiceCall = function(objectName, methodName, type, params) {
	try {
		if (!window.smJSCall || !window.smNativeInterface) {
			throw new Error("window.smJSCall not initialized");
		}
		var res = window.smJSCall(objectName, methodName, window.smNativeInterface.convertIOSData(type, params))

		window.smNativeLogger.log("iosJavascriptServiceCall", objectName, methodName, type, params) //, JSON.stringify(res));
		return window.smNativeInterface.convertResultForIOS(res);
	} catch (e) {
		return window.smNativeInterface.convertErrorForIOS(e);
	}
}
window.smNativeLogger && window.smNativeLogger.log("IOS JS LOADED")