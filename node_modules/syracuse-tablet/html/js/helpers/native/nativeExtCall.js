"use strict";

/*
 * This module is called JS to call methods in an by an external wrapper
 */

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeExtCall", false);
var logios = require('syracuse-tablet/html/js/helpers/logger').getLogger("ios nativeExtCall", false);

var _testMode = false;

/**
 * True is application runs inside a wrapper native or Javascript
 */
exports.isNativeModeEnabled = function() {
	return (window && window.smNativeInterface) || _testMode === true;
};

/**
 * Returns a promise
 * 	Resolves with the DB (indexedDB or webSQL or null)
 *  	null means regular process (we ask the browser)
 *  	indexedDB:webSQL forces the use of the given db
 * 			Safari in IOS wrapper doesn't support webSQL while Safari out side the wrapper does
 */
exports.getSupportedDB = function() {
	if (window && window.smNativeInterface && window.smNativeInterface.getSupportedDB) {
		return window.smNativeInterface.getSupportedDB();
	}
	// TODO - Null means we use the regular process
	return $.smResolve(null);
};
/**
 * Call a native method if it is available.
 * Will return true if method is available and method call returns true
 * Otherwise returns false
 */
exports.isSupported = function(domain, method) {
	var sup = false;

	domain = domain || "";
	method = method || "";

	var caller = window && window.smNativeInterface && window.smNativeInterface.isSupported;
	if (caller && !_testMode) {
		// Do not change to caller.isSupported it will not work!!!;
		sup = window.smNativeInterface.isSupported(domain, method);
	} else if (_testMode) {
		// Arguments here should be 100% equal to the ones used for window.smNativeInterface.isSupported
		// to allow exact validation
		sup = _isSupportedTest(domain, method);
	} else {
		log && log("Native: isSupported no such interface - " + domain + ", " + method + ")");
	}
	var promise;
	if (sup != null && typeof sup === "object" && typeof sup.then === "function" && typeof sup.fail === "function") {
		promise = sup;
		logios && logios("Native: isSupported is a promise");
	} else {
		logios && logios("Native: isSupported is not a promise");
		promise = $.smResolve(sup);
	}
	return promise.then(function(supported) {
		logios && logios("Native: isSupported (" + domain + ", " + method + ")");
		logios && logios("->" + supported);
		return supported;
	});
};

/**
 * Call a native method and receive a return value
 */
exports.callMethod = function(domain, method, data) {
	var ret;

	var param = data;
	if (param != null && typeof param !== "string") {
		param = JSON.stringify(param);
	}
	domain = domain || "";
	method = method || "";
	param = param || "";

	log && log("Native: callMethod (" + domain + ", " + method + "): " + param);
	var caller = window && window.smNativeInterface && window.smNativeInterface.callMethod;
	if (caller && !_testMode) {
		// Do not change to caller.callMethod it will not work!!!
		ret = window.smNativeInterface.callMethod(domain, method, param);
		try {
			ret = JSON.parse(ret);
		} catch (e) {}
	} else if (_testMode) {
		// Arguments here should be 100% equal to the ones used for window.smNativeInterface.callMethod
		// to allow exact validation
		ret = _callMethodTest(domain, method, param);
		try {
			ret = JSON.parse(ret);
		} catch (e) {}
	} else {
		log && log("Native: callMethod no such interface");
	}
	return ret;
};

/**
 * Call a native method (fire and forget with no return value)
 */
exports.fireMethod = function(domain, method, data) {
	var param = data;
	if (param != null && typeof param !== "string") {
		param = JSON.stringify(param);
	}
	domain = domain || "";
	method = method || "";
	param = param || "";

	log && log("Native: fireMethod (" + domain + ", " + method + "): " + param);
	var caller = window && window.smNativeInterface && window.smNativeInterface.fireMethod;
	if (caller && !_testMode) {
		// Do not change to caller.fireMethod it will not work!!!
		window.smNativeInterface.fireMethod(domain, method, param);
	} else if (_testMode) {
		// Arguments here should be 100% equal to the ones used for window.smNativeInterface.fireMethod
		// to allow exact validation
		_fireMethodTest(domain, method, param);
	} else {
		log && log("Native: fireMethod no such interface");
	}
};

function _isSupportedTest(domain, method) {
	var obj = window[domain];
	var caller = obj && obj[method];
	if (!caller) {
		log && log("_isSupportedTest: No such method: window." + domain + "." + method);
		return false;
	}
	var sup = caller.call(obj);
	return sup;
}

/**
 *
 */
function _callMethodTest(domain, method, param) {
	var obj = window[domain];
	var caller = obj && obj[method];
	if (!caller) {
		log && log("_callMethodTest: No such method: window." + domain + "." + method);
		return null;
	}
	var ret = caller.call(obj, param);
	return ret;

}

/**
 *
 */
function _fireMethodTest(domain, method, param) {
	var obj = window[domain];
	var caller = obj && obj[method];
	if (!caller) {
		log && log("_fireMethodTest: No such method: window." + domain + "." + method);
		return null;
	}
	caller.call(obj, param);
}

exports.init = function(testMode) {
	_testMode = testMode === true;
};