"use strict";

var globals = require('syracuse-tablet/html/js/app/globals');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("nativeWUPApp", false);
var nativeTestApp = require('syracuse-tablet/html/js/helpers/native/wrapperTest/nativeTestApp');
var nativeExtCall = require('syracuse-tablet/html/js/helpers/native/nativeExtCall');
var modules = require('syracuse-tablet/html/js/common/modules');


//Global object to be called by native code on low level events
if (!(window.smWrapperJS)) {
	window.smWrapperJS = {

		/*
		 *  This method will be invoked from wrapper when the user clicks the
		 *  hardware back button
		 *
		 *  return "true" - Back action is handled by JS code
		 *  return "false" - Back action is handled by native code (usually to close app).
		 */
		backButtonPressed: function() {
			var app = modules.get("appController").App;
			var canGoBack = app.canGoBack();
			if (canGoBack) {
				modules.get("appController").App.goBack();
				return true;
			}
			return false;
		},

		/*
		 * Called by native wrapper when the application is going to terminate
		 */
		applicationClosing: function() {
			var currentAppState = modules.get("appController").App.nativeApplicationClosing();
			return currentAppState;
		},

		/*
		 * Called only on the following scenaria
		 * Application is loaded but the user navigates back on a page that is driven by native code
		 * so the web app becomes invisible
		 * As soon as the user decides to start the same web app again (make it visible again) this method is called.
		 *
		 * The intention of this method is to check for online/offline mode and other things that may have changed
		 * since the web app was visible for the last time
		 */
		applicationActivated: function() {
			modules.get("appController").App.nativeApplicationActivated();
		},

		/*
		 * connected:
		 * true: The index.html used to start this app can be accessed by the wrapper which usually means network is ok
		 * false: Network is down, index.html is not accessible
		 */
		connectivityChanged: function(connected) {
			log && log("connectivityChanged: " + connected);
			globals.setOffline(connected != true, false, true);
		}
	};
}


/**
 * Running inside a native container?
 * !!! Return a boolean
 */
exports.supports = function(capability) {
	if (capability === "nativeApp") {
		return nativeExtCall.isSupported("smApp", "nativeWrapperSupported");
	}
	if (capability === "hardwareBackButton") {
		return nativeExtCall.isSupported("smApp", "hardwareBackButtonSupported");
	}
	if (capability === "dispatcherListener") {
		return nativeExtCall.isSupported("smApp", "dispatcherListenerSupported");
	}
	if (capability === "extLink") {
		return nativeExtCall.isSupported("smApp", "openExternalLinkSupported");
	}
	if (capability === "nativeScrolling") {
		return nativeExtCall.isSupported("smApp", "nativeScrollingSupported");
	}

	return $.smResolve(false);
};

/**
 * Opens a link in a new browser window
 */
exports.openExternalLink = function(url) {
	nativeExtCall.fireMethod("smApp", "openExternalLink", url);
};

/**
 * Management of reconnection
 * Returns the login and session cookies (reconnectToken) as string
 * To be compliant with win10 version getReconnectToken can return 
 * 	a string (login cookie)
 * 	an object with login and session cookies {loginCookie: loginCookie, sidCookie: sidCookie}
 */
exports.getReconnectToken = function() {
	var deferred = $.Deferred()
	nativeExtCall.callMethod("smApp", "getReconnectToken").then(function(result) {
		var loginCookie = null,
			sidCookie = null;
		if (result == null || typeof result == "string") {
			loginCookie = result;
		} else {
			loginCookie = result.loginCookie;
			sidCookie = result.sidCookie;
		}
		deferred.resolve(loginCookie, sidCookie);
	})
	return deferred.promise();
};
/**
 * Management of reconnection
 * Stores the login token (reconnectToken)
 * Native method is called with a stringified context
 * token: login cookie provided by syracuse server
 * userLogin: user name (login) stored in login cookie
 * sid: session id to preserve the same session for all requests sent to server
 * loginCookieName, sidCookieName: cookies name used if there's a reverse proxy that hide the port
 */
exports.setReconnectToken = function(token, userLogin, sid, loginCookieName, sidCookieName) {
	var data = {}
	if (typeof token === "string") {
		data.SyracuseSidLogin = token;
		data.UserLogin = userLogin;
	}
	if (typeof sid === "string") {
		data.SyracuseSid = sid
	}
	if (typeof loginCookieName === "string") {
		data.LoginCookieName = loginCookieName
	}
	if (typeof sidCookieName === "string") {
		data.SidCookieName = sidCookieName
	}
	nativeExtCall.fireMethod("smApp", "setReconnectToken", data);
};
/**
 * Management of reconnection
 * Returns the user context to restore (context) as string
 * {
 * 		userCtx:
 * 		userProfile:
 *  	context:
 *  }
 */
exports.getReconnectContext = function() {
	return nativeExtCall.callMethod("smApp", "getReconnectContext");
};
exports.configServer = function() {
	nativeExtCall.fireMethod("smApp", "configServer");
};
exports.selectServer = function() {
	nativeExtCall.fireMethod("smApp", "selectServer");
};

/*
 * This is ment to allow the wrapper to listen to dispatched sdata events
 * Can be used to trigger actions on the native side transparently
 *
 * E.g. if a native wrapper shows a live feed of data somewhere (live tiles) he can check if the sdata
 * url dispatched here concerns the same class as the data feed and trigger an internal update
 * without forcing the JS code to know about it
 *
 * link:
 * {
 * 	 Method: PUT|GET|POST
 * 	 Url: what ever url
 * }
 */
exports.dispatcherNotifyAfter = function(link) {
	nativeExtCall.fireMethod("smApp", "dispatcherNotifyAfter", link);
};


/*
 * Invokes the native app to tell loading the app has been finished to avoid a timeout
 */
exports.notifLoaded = function() {
	log && log("notifLoaded");
	nativeExtCall.fireMethod("smApp", "webappLoaded");
};

/*
 * Invokes the native app to tell application is unloaded
 * historyContext	Page history stack
 * 					Used by natoveTestWrapper top store history
 * Can return a message to display (error)
 */
exports.notifUnloaded = function(historyContext) {
	// This is only used by test code
	log && log("OnWebappUnloaded");
	if (window && window.smApp && window.smApp.onWebappUnloaded) {
		return window.smApp.onWebappUnloaded(historyContext ? JSON.stringify(historyContext, null, 2) : null);
	}
};

/*
 * Invokes native app to signal there was a critical error loading the app
 */
exports.notifStartFail = function(msg) {
	nativeExtCall.fireMethod("smApp", "webappLoadFail", msg);
};
/**
 * Returns the test js wrapper
 */
exports.init = function(testMode) {
	if (window && window.smApp) return;
	if (!testMode) return;
	log && log("Creating native nativeApp test wrapper");
	window.smApp = nativeTestApp.create();
	return window.smApp;
};