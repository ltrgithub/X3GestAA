"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiRect = require('syracuse-tablet/html/js/ui/rect');

var _Klass = utils.defineClass(function scroller($$elmt, options) {
	this.options = options = options ? $.extend(options) : {};
	this.name = options.name || "scroller";
	this.$$elmt = $$elmt;
	this.isPageScroller = options.isPageScroller === true;
	this._initDir(options.direction);
	// Max top always 0 because we scroll in relative / parent - If needed pass it in parameter
	// options.valMax kept for compatibility with previous version
	this.scrollMax = options.valMax != null ? options.valMax : options.scrollMax != null ? options.scrollMax : 0;
	this.restoredScroll = null;
}, null, {
	destroy: function() {
		this.reset();
		this.$$elmt = null;
	},
	_initDir: function(dir) {
		if (dir == null) {
			if (this.dir != null) return;
			this.dir = "v";
			return;
		}
		this.dir = dir;
	},
	init: function(viewRect, dir, scrollMax, preserveScroll) {
		if (viewRect == null) {
			throw new Error("Unexpected null viewRect");
		}
		var scroll = this.getScroll();
		if (preserveScroll === true && this.restoredScroll != null && scroll != null && scroll !== this.scrollMax) {
			// preserve the current scrolling - Just set restoredScroll
			// ! in charge to the parent class to refresh with restoredScroll 
			this.restoredScroll = scroll;
		}
		this.reset(true);
		this._initDir(dir);
		if (scrollMax != null) {
			this.scrollMax = scrollMax;
		}
		this.viewRect = viewRect;
		this._doInit(viewRect, dir, scrollMax, preserveScroll);
		var refreshed = false;
		if (preserveScroll === true && this.restoredScroll != null) {
			// If preserveScroll we have to adjust in case the newValMin < previousVal < newscrollMax
			refreshed = this.adjust(this.restoredScroll);
		}
		if (!refreshed) {
			this._refresh(this.restoredScroll, true);
		}
		this.restoredScroll = null;
	},
	/**
	 * Child classes initialization
	 */
	_doInit: function(viewRect, dir, scrollMax, preserveScroll) {
		throw new Error("Not implemented");
	},
	isInitialized: function() {
		return this.$$elmt != null && this.viewRect != null;
	},
	/**
	 * Disable scroll but keep the capability to re-initialize it
	 */
	reset: function(dontResetValue) {
		if (dontResetValue !== true) {
			// Put initial value
			this._refresh(this.scrollMax);
		}
		this.viewRect = null;
	},
	/**
	 * Applies the scrolling
	 */
	_refresh: function(scroll, force) {
		throw new Error("Not implemented");
	},
	/**
	 * Context management on back to restore the scrolling
	 */
	savedCtxCreate: function() {
		return {
			scroll: this.getScroll()
		};
	},
	savedCtxRestore: function(ctx, refresh) {
		if (ctx == null || ctx.scroll == null) return;
		if (refresh && this.isInitialized()) {
			this._refresh(ctx.scroll);
		} else {
			this.restoredScroll = ctx.scroll;
		}
	},
	getOffset: function() {
		return {
			top: this.dir == "v" ? this.getScroll() : 0,
			left: this.dir == "h" ? this.getScroll() : 0
		};
	},
	/**
	 * Make $$e visible
	 */
	makeVisible: function($$e) {
		throw new Error("Not implemented");
	},
	/**
	 * Auto-scroll to  value
	 */
	autoScroll: function(value) {
		throw new Error("Not implemented");
	},
	/**
	 * Returns the current scrolling
	 */
	getScroll: function(value) {
		throw new Error("Not implemented");
	},
	/**
	 * Returns the min scrolling (rather the max)
	 */
	_getScrollMin: function() {
		throw new Error("Not implemented");
	},
	/**
	 * Check if the current scroll element is contained by  viewRect
	 * If true -> reset scrolling Else re-init scrolling
	 */
	checkViewRect: function(viewRect, preserveScroll) {
		var reset = true;
		if (viewRect && this.$$elmt) {
			// For multi-selection in card mode we can hide cards. We need to scroll to beginning in order to calculate the right rect
			var val = this.getScroll();
			this._scrollToBeginning();
			var myRect = uiRect.elmtRect(this.$$elmt, "computed");
			var intersectRect = viewRect.intersectRect(myRect, false);
			if (intersectRect != null) {
				if (preserveScroll) {
					this.resoredVal = val;
				}
				this.init(intersectRect, null, null);
				reset = false;
				if (preserveScroll) {
					// If preserveScroll we have to adjust in case the newValMin < previousVal < newscrollMax
					this.adjust();
				}
			}
		}
		if (reset) {
			this.reset();
		}
	},
	/**
	 * Move to beginning
	 */
	_scrollToBeginning: function() {
		this._refresh(this.scrollMax);
	},
	/**
	 *  Adjust the scroller after modification of DOM to make this.$$elmt visible
	 *  By example after an action which have hidden lines we need to call this method to adjust scrolling because the visible area can be outside the viewRect
	 */
	adjust: function(restoredScroll) {
		if (!this.isInitialized()) return;
		// Check if restoredScroll is ok
		restoredScroll = restoredScroll == null ? this.getScroll() : restoredScroll;
		var newVal = null;
		var elmtRect = uiRect.elmtRect(this.$$elmt);
		if (this.viewRect.contains(elmtRect)) {
			// No scroll we set scrollMax
			newVal = this.scrollMax;
		} else {
			if (restoredScroll < this.scrollMax) {
				// outside the scop we set scrollMax
				newVal = this.scrollMax;
			}
			var prop = this.dir == "v" ? "height" : "width";
			var valmin = this.scrollMax - elmtRect[prop] + this.viewRect[prop];
			if (restoredScroll < valmin) {
				// outside the scop we set scrollMin
				newVal = this._getScrollMin();
			}
		}
		if (newVal != null) {
			this._refresh(newVal);
			return true;
		}
		return false;
	}
});

exports.Klass = _Klass;