"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/helpers/scroller/scrollerBase').Klass;

var _consts = {
	dirToAxis: {
		v: "y",
		h: "x"
	},
	dirToOtherAxis: {
		v: "x",
		h: "y"
	}
};

var _Klass = utils.defineClass(function NativeScroller($$elmt, options) {
	Base.call(this, $$elmt, options);
}, Base, {
	_doInit: function(viewRect, dir, scrollMax, preserveScroll) {
		var css = {};
		css["overflow-" + _consts.dirToAxis[this.dir]] = "auto"; // scrolling axis
		css["overflow-" + _consts.dirToOtherAxis[this.dir]] = "hidden"; // "unused" or fixed axis
		this.$$elmt.addClass("isScrollElmt").parent().css(css).addClass("isScrollWrapper");
		// remove default touch action on all elements
		// would be better if doing this by loading a css file with the appropriate * {} selector instead of setting it on each element
		var css = {};
		if (this.scrollMax === 0 && this.options.nopadding !== true) {
			var prop = this.dir === "h" ? "right" : "bottom";
			// blank line of 10 pixels at the end of scrolling
			css["padding-" + prop] = "10px";
		}
		var prop = this.dir === "h" ? "width" : "height";
		var valProp = this.viewRect[prop];
		if (false) {
			css["border"] = "red solid 1px";
			// To actually see the rectangle
			valProp -= 2;
		}
		this.$$elmt.parent()[prop](valProp).css(css);
	},
	reset: function(dontResetValue) {
		this._refresh(0, true);
		var wasInitialized = this.isInitialized();
		Base.prototype.reset.call(this, dontResetValue);
		if (!this.$$elmt || !wasInitialized) return;
		var prop = this.dir === "h" ? "width" : "height";
		// We restore 100% rather than auto (auto doesn't work i panels when we switch orientation) - 100% is better for the wrapper
		this.$$elmt.parent().css(prop, "100%");
	},
	getScroll: function() {
		return this.$$elmt ? this.$$elmt.parent()[this.dir === "h" ? "scrollLeft" : "scrollTop"]() : this.scrollMax;
	},
	_refresh: function(scroll, force) {
		if (!this.$$elmt) return;
		if (scroll == null && force !== true) return;
		scroll = Math.max(scroll == null ? this.scrollMax : scroll, this.scrollMax);
		var cur = this.getScroll();
		if (cur === scroll && force !== true) return;
		this.$$elmt.parent()[this.dir === "h" ? "scrollLeft" : "scrollTop"](scroll);
	},
	makeVisible: function($$e) {
		if (!$$e || $$e.length === 0 || $$e.is(":visible") || !$$e.get(0).scrollIntoView) {
			return;
		}
		$$e.get(0).scrollIntoView(false);
	},
	autoScroll: function(value) {
		if (!this.isInitialized()) {
			// Set at initialization
			this.restoredScroll = value;
		} else {
			this._refresh(value, true);
		}
	},
	_getScrollMin: function() {
		return this.$$elmt ? this.$$elmt.height() : 0;
	}
});

exports.Klass = _Klass;