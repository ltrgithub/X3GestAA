"use strict";

var _ns = "sm";
var _nsNormalizeDict = {};

var _nsNormalize = function(prop) {
	return prop == null ? null : _nsNormalizeDict[prop] || (_nsNormalizeDict[prop] = $.camelCase(_ns + prop));
};

$.fn.smData = function(prop, value) {
	var result;
	if (prop != null) {
		if (prop) prop = _nsNormalize(prop);
		if (arguments.length < 2 || value === undefined) {
			result = this.data(prop);
		} else {
			result = this.data(prop, value);
		}
	}
	return result;
};

$.fn.smRemoveData = function(prop) {
	return this.removeData(_nsNormalize(prop));
};

$.fn.smPageController = function(ctrl) {
	return this.smData("controller", ctrl);
};

$.fn.smPageRemoveController = function() {
	return this.smRemoveData("controller");
};

/*
 * Returns a promise that immediately resolves
 */
$.smResolve = function() {
	var deferred = $.Deferred();
	deferred.resolve.apply(deferred, arguments);
	return deferred.promise();
};
/*
 * Returns a promise that immediately rejects
 */
$.smReject = function() {
	var deferred = $.Deferred();
	deferred.reject.apply(deferred, arguments);
	return deferred.promise();
};

$.smForEachKey = function(o, cb, ctx) {
	Object.keys(o).forEach(function(k) {
		cb.call(ctx, k, o[k]);
	});
};

$.smForEach = function(arr, cb, ctx) {
	var i = 0;
	arr.forEach(function(k) {
		cb.call(ctx, k, i++);
	});
};
$.smUrlParam = function(name) {
	var results = new RegExp('[\?&]' + name + '=([^&#]*)').exec(window.location.href);
	if (results == null) {
		return null;
	} else {
		return (results[1] && decodeURIComponent(results[1])) || null;
	}
};

jQuery.extend({
	smDeferred: function(func) {
		var tuples = [
			// action, add listener, listener list, final state
			["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
			["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
			["notify", "progress", jQuery.Callbacks("memory")]
		],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done(arguments).fail(arguments);
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function(newDefer) {
						jQuery.each(tuples, function(i, tuple) {
							var fn = jQuery.isFunction(fns[i]) && fns[i];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[tuple[1]](function() {

								/////////////////////////////////////////////////////////////////////
								// This block is the only change compared to jQuery implementation
								// The goal is to reject a promise that causes an exception instead
								// of bubbling the exception which does not work in async functions
								/////////////////////////////////////////////////////////////////////
								try {
									var returned = fn && fn.apply(this, arguments);
								} catch (e) {
									newDefer.reject(e);
									return;
								}
								///////////////////////////////////////////////////////////////////
								// End
								///////////////////////////////////////////////////////////////////

								if (returned && jQuery.isFunction(returned.promise)) {
									returned.promise()
										.done(newDefer.resolve)
										.fail(newDefer.reject)
										.progress(newDefer.notify);
								} else {
									newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function(obj) {
					return obj != null ? jQuery.extend(obj, promise) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each(tuples, function(i, tuple) {
			var list = tuple[2],
				stateString = tuple[3];

			// promise[ done | fail | progress ] = list.add
			promise[tuple[1]] = list.add;

			// Handle state
			if (stateString) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

					// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[i ^ 1][2].disable, tuples[2][2].lock);
			}

			// deferred[ resolve | reject | notify ]
			deferred[tuple[0]] = function() {
				deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
				return this;
			};
			deferred[tuple[0] + "With"] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise(deferred);

		// Call given func if any
		if (func) {
			func.call(deferred, deferred);
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function(subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = jQuery.fn.slice.call(jQuery.fn, arguments),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function(i, contexts, values) {
				return function(value) {
					contexts[i] = this;
					values[i] = arguments.length > 1 ? jQuery.fn.slice.call(jQuery.fn, arguments) : value;
					if (values === progressValues) {
						deferred.notifyWith(contexts, values);
					} else if (!(--remaining)) {
						deferred.resolveWith(contexts, values);
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if (length > 1) {
			progressValues = new Array(length);
			progressContexts = new Array(length);
			resolveContexts = new Array(length);
			for (; i < length; i++) {
				if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
					resolveValues[i].promise()
						.done(updateFunc(i, resolveContexts, resolveValues))
						.fail(deferred.reject)
						.progress(updateFunc(i, progressContexts, progressValues));
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if (!remaining) {
			deferred.resolveWith(resolveContexts, resolveValues);
		}

		return deferred.promise();
	}
});

/**
 * FDB implementation to solve the issue of asynchronous calls in deferred
 * Tested with the following use case
 * 	Goto pageRegular.loadData and put 'throw new Error("test")' before setDao
 * 	-> Error should be handled by _rejectError handler
 *  -> If we open a representation in vignette the vignette should show the error
 *
 *  !! NEVER put a try{}catch(e){} in the deferred success handler but add a fail handler to cath teh exception
 */
var jqDeferred = $.Deferred;
var myDeferred = function(func) {
	var deferred = jqDeferred(func);
	var resolve = deferred.resolve;
	deferred.resolve = function() {
		try {
			resolve.apply(deferred, arguments);
		} catch (e) {
			console.log("!!! UNCAUGHT DEFERRED EXCEPTION\nMessage: ", typeof e === "string" || e == null ? e : e.message + (e.Stack ? "\nStack:\n" + e.stack : ""));
			throw e;
		}
	};
	// Override the promise method to catch the exception in the then method of the promise
	var promise = deferred.promise;
	deferred.promise = function() {
		var myPromise = promise.apply(deferred, arguments);
		var then = myPromise.then;
		myPromise.then = function() {
			var args = arguments;
			var self = this;
			return then.call(deferred, args.length > 0 ? function() {
				// console.log("then.success - ", args.length, " - ", Array.prototype.join.call(arguments, '-'))
				try {
					return args[0].apply(self, arguments);
				} catch (e) {
					// Just to control if the error if actually handled
					console.log("myDeferred.then.exception:\n", e ? e.stack ? e.stack : e : "No exception");
					// Returns the error as a reject
					return jqDeferred(function(def) {
						def.reject(e);
					}).promise();
				}
			} : null, args.length > 1 ? function() {
				// console.log("then.failed - ", Array.prototype.join.call(arguments, '-'))
				return args[1].apply(self, arguments);
			} : null);
		};
		return myPromise;
	};
	return deferred;
};

jQuery.Deferred = myDeferred; //sjQuery.smDeferred;