"use strict";

var _ns = "sm";
var _nsNormalizeDict = {};

var _nsNormalize = function(prop) {
	return prop == null ? null : _nsNormalizeDict[prop] || (_nsNormalizeDict[prop] = $.camelCase(_ns + prop));
};

/* Can be used to determin root level extend on unlimited recursion
var _org_extend = $.fn.extend;
var _extend_stack = [];
jQuery.extend = function() {
	try {
		throw new Error("extend")
	} catch (e) {
		_extend_stack.push(e);
	}
	try {
		var r = _org_extend.apply(this, arguments);
	} catch (x) {
		throw _extend_stack[0];
		_extend_stack.pop();
		throw x;
	}
	_extend_stack.pop();
	return r;
};
*/

$.fn.smData = function(prop, value) {
	var result;
	if (prop != null) {
		if (prop) prop = _nsNormalize(prop);
		if (arguments.length < 2 || value === undefined) {
			result = this.data(prop);
		} else {
			result = this.data(prop, value);
		}
	}
	return result;
};

$.fn.smRemoveData = function(prop) {
	return this.removeData(_nsNormalize(prop));
};

$.fn.smPageController = function(ctrl) {
	return this.smData("controller", ctrl);
};

$.fn.smPageRemoveController = function() {
	return this.smRemoveData("controller");
};

/**
 * True if evt pageX/pageY are inside $elmt
 * typeRect: outer, inner, computed
 */
var _meths = {
	outer: ["outerWidth", "outerHeight"],
	inner: ["innerWidth", "innerHeight"],
	computed: ["width", "height"]
};
$.fn.smEvtInside = function(evt, typeRect) {
	var m = _meths[typeRect || "outer"];
	var o = this.offset();
	return evt.pageX >= o.left && evt.pageX <= o.left + this[m[0]]() && evt.pageY >= o.top && evt.pageY <= o.top + this[m[1]]();
};
/*
 * Returns a promise that immediately resolves
 * typeof first argument === "function" - > execute the function
 */
$.smResolve = function() {
	var beforeStart = arguments.length > 0 && typeof arguments[0] === "function" ? arguments[0] : null;
	var deferred = $.Deferred(beforeStart);
	deferred.resolve.apply(deferred, beforeStart ? Array.prototype.splice.call(arguments, 0, 1) : arguments);
	return deferred.promise();
};
/*
 * Returns a promise that immediately rejects
 */
$.smReject = function() {
	var deferred = $.Deferred();
	deferred.reject.apply(deferred, arguments);
	return deferred.promise();
};

$.smForEachKey = function(o, cb, ctx) {
	Object.keys(o).forEach(function(k) {
		cb.call(ctx, k, o[k]);
	});
};

$.smForEach = function(arr, cb, ctx) {
	var i = 0;
	arr.forEach(function(k) {
		cb.call(ctx, k, i++);
	});
};
$.smUrlParam = function(name) {
	var results = new RegExp('[\?&]' + name + '=([^&#]*)').exec(window.location.href);
	if (results == null) {
		return null;
	} else {
		return (results[1] && decodeURIComponent(results[1])) || null;
	}
};

/**
 * Sequentially loops over an array invoking a callback which must return a promise
 * Returns a promise which is resolved as soon as the last promise of the loop is resolved.
 */
$.smForEachPromise = function(arr, cb, resolve) {
	if (arr === undefined || arr === null)
		throw new TypeError();

	var deferred = $.Deferred();
	var queue = [];
	arr.forEach(function(elem) {
		queue.push(elem);
	});
	var idx = 0;
	var count = queue.length;

	var loop = function() {
		var elem = queue.shift();
		if (elem == null) {
			deferred.resolve();
		} else {
			var prom = cb(elem, idx, count);
			idx++;
			prom.then(function(result) {
				if (resolve) {
					if (resolve(elem, result) === true) {
						deferred.resolve();
						queue = [];
					}
				}
				loop();
			}).fail(function(e) {
				deferred.reject(e);
			});
		}
	};
	loop();
	return deferred.promise();
};

$.smFind = function(arr, fun /*, thisArg*/ ) {
	if (arr === undefined || arr === null)
		throw new TypeError();
	var t = Object(arr);
	var len = t.length >>> 0;
	if (typeof fun !== 'function')
		throw new TypeError();
	var thisArg = arguments.length >= 3 ? arguments[2] : void 0;
	for (var i = 0; i < len; i++) {
		if (i in t && fun.call(thisArg, t[i], i, t)) {
			return t[i];
		}
	}
	return null;
};