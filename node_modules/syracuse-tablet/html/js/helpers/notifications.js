"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').log;
var utils = require('syracuse-tablet/html/js/helpers/utils');

/**
 * publish/subscribe - Observer/Observable pattern with jQuery
 * We use jQuery triggering and use body as dispatcher
 * TODO - Eventually implement our own dispatcher
 **/

var _nameSpace = "sm";
var _subscriptions = {};

var _err = function(msg) {
	throw new Error("Notification -" + msg);
};

/**
 *  publish an event ("sm-login") or an array of events ["sm-login","sm-logout"]
 * 		Subscribers are notified through method notifEventname - object.notifLogin, object.notifLogout
 * 		argument that follow events parameter are passed to the Subscriber
 * */
var _publish = function(events) {
	if (!events) {
		_err("No topic to publish");
	}
	var events = typeof events === "string" ? [events] : events;
	var args, subscription, subscription, res;
	var count = 0,
		array;
	args = Array.prototype.slice.call(arguments, 1);
	events.forEach(function(evt) {
		array = _subscriptions[evt];
		if (array) {
			array = array.slice();
			for (var i = 0, l = array.length; i < l; i++) {
				subscription = array[i];
				res = subscription.method.apply(subscription.object, args);
				count++;
				// TO SEE - -stop is res = false if ( res === false ) { break; }
			}
		}
	});
};
/**
 * object subscribes for events (string or array)
 * Events starts with "sm" (sm-login, sm-logout)
 * High priority subscriptions are called first
 */
var _subscribe = function(object, events, priority) {
	if (!events) {
		_err("No topic to publish");
	}
	priority = priority || 10;
	var events = typeof events === "string" ? [events] : events;
	events.forEach(function(evt) {
		var methodName = evt.split('.');
		if (methodName[0] != _nameSpace) _err("Bad event domain name");
		methodName = $.camelCase("notif-" + methodName.splice(1).join('-'));
		var method = object[methodName],
			added;
		if (!method) {
			_err("Object must implement " + methodName);
		}
		added = false;
		if (!_subscriptions[evt]) {
			_subscriptions[evt] = [];
		}
		var subscriptionInfo = {
			method: method,
			object: object,
			priority: priority
		};
		for (var i = _subscriptions[evt].length - 1; i >= 0; i--) {
			if (_subscriptions[evt][i].priority <= priority) {
				_subscriptions[evt].splice(i + 1, 0, subscriptionInfo);
				added = true;
				break;
			}
		}
		if (!added) {
			_subscriptions[evt].unshift(subscriptionInfo);
		}
	});
};

/**
 * object unsubscribes for events
 *  object != null
 * 		Remove all object's subscription for given events
 *  object == null
 * 		Remove all subscription for given events
 *  events string or array
 * 		null -> unsubscribe for allevent
 */
var _unsubscribe = function(object, events) {
	if (!events) {
		events = Object.keys(_subscriptions);
	} else if (typeof events == "string") {
		events = [events];
	}
	events.forEach(function(evt) {
		var array = _subscriptions[evt];
		if (array) {
			for (var i = 0, l = array.length; i < l; i++) {
				if (object == null || array[i].object === object) {
					array.splice(i, 1);
					// Adjust counter and length for removed item
					i--;
					l--;
				}
			}
		}

	});
};

// Remove all subscription
var _reset = function(object, events) {
	// For tests
	_unsubscribe(null, null);
	// We could just do _subscriptions = {};
};

// the number of subscriptions per event (for object if != null)
var _check = function(object) {
	var res = {};
	Object.keys(_subscriptions).forEach(function(key) {
		if (object == null) {
			res[key] = _subscriptions[key].length;
		} else {
			res[key] = 0;
			var arr = _subscriptions[key];
			for (var i = 0, l = arr.length; i < l; i++) {
				if (arr[i].object === object) res[key] = res[key] + 1;
			}
		}
	});
	return res;
};

exports.check = _check;
exports.reset = _reset;
exports.subscribe = _subscribe;
exports.unsubscribe = _unsubscribe;
exports.publish = _publish;