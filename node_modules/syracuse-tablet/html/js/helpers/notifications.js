"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("notifs");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
/**
 * publish/subscribe - Observer/Observable pattern with jQuery
 * TODO - !!! Attach a _subscriptions to application and one per page
 * --> Switch the page _subscriptions with the page in order to not notify inactive pages (parent page)
 * Temporarily we check inactive in page notif methods
 *
 **/

var _nameSpace = "sm";
var _subscriptions = {};

var _err = function(e) {
	log && log("Error", e);
	if (typeof e == "string") {
		throw new Error("Notification - " + e);
	} else {
		throw e;
	}
};

/**
 * _callHandler outside _publish function to preserve args if call to multiple objects in the loop
 */
var _callCheck = function(object) {
	// Don't notify object that are not active (ex: cached pages)
	if (jsutils.isInstanceOf(object, "Page") && !object.isActive()) return false;
	if (jsutils.isInstanceOf(object, "StructElmt") && (object.controller == null || !object.controller.isActive())) return false;
	return true;
};
var _callHandler = function(callBack, object, args) {
	if (!_callCheck(object)) return;
	return setTimeout(function() {
		callBack.apply(object, args);
	}, 0);
};
var _callHandlerSynch = function(callBack, object, args) {
	if (!_callCheck(object)) return;
	callBack.apply(object, args);
};

/**
 *  publish an event ("sm.login") or an array of events ["sm.login"...]
 * 		Functional Object Subscribers
 * 			 notified through method notifEventname - object.notifLogin, object.notifLogout
 * 		Simple callBack Subscriber
 * 			called with event as first parameter
 * 	Argument that follow events parameter are passed to the Subscriber
 *  If event starts with 'synch.' all the callback will be called synchronously otherwise they will be called asynchronously (setTimeout)
 * */
var _publish = function(events) {
	try {
		if (!events) {
			throw new Error("No topic to publish");
		}
		var events = typeof events === "string" ? [events] : events;
		log && log("Publish " + events.join(" - "));
		var args, subscription, subscription, res;
		var count = 0,
			array;
		var objArgs, args = arguments,
			synch, callHandler;
		events.forEach(function(evt) {
			synch = evt.smStartsWith("synch.");
			if (synch) {
				evt = evt.split("synch.")[1];
				callHandler = _callHandlerSynch;
			} else {
				callHandler = _callHandler;
			}
			array = _subscriptions[evt];
			if (array) {
				array = array.slice();
				for (var i = 0, l = array.length; i < l; i++) {
					subscription = array[i];
					if (subscription.object) {
						if (!objArgs) objArgs = Array.prototype.slice.call(args, 1);
						// Remove first argument and call the method - setTimeout(0) for asynchronism and release call stack
						res = callHandler(subscription.callBack, subscription.object, objArgs);
					} else {
						// call the function with evt as first parameter - setTimeout(0) for asynchronism and release call stack
						args[0] = evt;
						res = callHandler(subscription.callBack, null, args);
					}
					count++;
					// TO SEE - -stop is res = false if ( res === false ) { break; }
				}
			} else {
				// No subscribers is not an error!
				// throw new Error("Unknown notification event " + evt);
			}
		});
	} catch (e) {
		_err(e);
	}
};

/**
 *  Same as _publish with options
 *  TODO -> Merge both
 * */
var _publishEx = function(events, opts) {
	try {
		if (!events) {
			throw new Error("No topic to publish");
		}
		var events = typeof events === "string" ? [events] : events;
		log && log("Publish " + events.join(" - "));
		var args, subscription, subscription, res;
		var count = 0,
			array;
		var exclude = opts && opts.exclude || [];
		var objArgs, args = arguments;
		var synch, callHandler;
		events.forEach(function(evt) {
			synch = evt.smStartsWith("synch.");
			if (synch) {
				evt = evt.split("synch.")[1];
				callHandler = _callHandlerSynch;
			} else {
				callHandler = _callHandler;
			}
			array = _subscriptions[evt];
			if (array) {
				array = array.slice();
				for (var i = 0, l = array.length; i < l; i++) {
					subscription = array[i];
					if (subscription.object) {
						if ((!exclude || exclude.indexOf(subscription.object)) < 0) {
							if (!objArgs) objArgs = Array.prototype.slice.call(args, 2);
							// Remove first argument and call the method - setTimeout(0) for asynchronism and release call stack
							res = callHandler(subscription.callBack, subscription.object, objArgs);
						}
					} else {
						// call the function with evt as first parameter - setTimeout(0) for asynchronism and release call stack
						args[0] = evt;
						res = callHandler(subscription.callBack, null, args);
					}
					count++;
					// TO SEE - -stop is res = false if ( res === false ) { break; }
				}
			} else {
				// No subscribers is not an error!
				// throw new Error("Unknown notification event " + evt);
			}
		});
	} catch (e) {
		_err(e);
	}
};


/**
 * object subscribes for events (string or array)
 * 		object can be an functional Object or a function
 * 		functional Object must implement a method notifEventName  sm.Login.user -> Method notifLoginUser
 * Events starts with "sm" (sm.login)
 * High priority subscriptions are called first
 */
var _subscribe = function(object, events, priority) {
	if (!events) {
		_err("No topic to publish");
	}
	if (!object) {
		_err("Null object");
	}
	priority = priority || 10;
	var events = typeof events === "string" ? [events] : events;
	log && log("Subscribe " + events.join(" - ") + " - priority=" + priority);
	var objectArray, removeIdx;
	events.forEach(function(evt) {
		var callBackFct, callBackObj;
		if (typeof object == "function") {
			callBackFct = object;
			callBackObj = null;
		} else {
			callBackObj = object;
			var methodName = evt.split('.');
			if (methodName[0] != _nameSpace) _err("Bad event domain name");
			methodName = $.camelCase("notif-" + methodName.splice(1).join('-'));
			callBackFct = object[methodName];
			if (!callBackFct) {
				_err("Object must implement " + methodName);
			}
		}
		var added = false;
		objectArray = _subscriptions[evt];
		if (!objectArray) {
			objectArray = _subscriptions[evt] = [];
		} else {
			// check if object has already subscribed
			var removeIdx = -1;
			objectArray.some(function(o, idx) {
				if (o && (o.object === object || o.callBack === object)) {
					removeIdx = idx;
					return true;
				}
			});
			if (removeIdx >= 0) {
				objectArray.splice(removeIdx, 1);
			}
		}
		var subscriptionInfo = {
			callBack: callBackFct,
			object: callBackObj,
			priority: priority
		};
		for (var i = objectArray.length - 1; i >= 0; i--) {
			if (objectArray[i].priority <= priority) {
				objectArray.splice(i + 1, 0, subscriptionInfo);
				added = true;
				break;
			}
		}
		if (!added) {
			objectArray.unshift(subscriptionInfo);
		}
	});
};

/**
 * object unsubscribes for events
 *  object != null
 * 		Remove all object's subscription for given events
 * 		object can be an Object or a function
 *  object == null
 * 		Remove all subscription for given events
 *  events string or array
 * 		null -> unsubscribe for allevent
 */
var _unsubscribe = function(object, events) {
	if (!events) {
		events = Object.keys(_subscriptions);
	} else if (typeof events == "string") {
		events = [events];
	}

	var propToCheck = typeof object === "function" ? "callBack" : "object";
	events.forEach(function(evt) {
		var array = _subscriptions[evt];
		if (array) {
			var lg = array.length;
			for (var i = 0, l = lg; i < l; i++) {
				if (object == null || array[i][propToCheck] === object) {
					array.splice(i, 1);
					// Adjust counter and length for removed item
					i--;
					l--;
				}
			}
			if (false && lg != array.length) {
				console.log("_unsubscribe ", evt, object == null ? "all" : propToCheck, lg, array.length, _check().total);
			}
		}

	});
};

// Remove all subscription
var _reset = function(object, events) {
	log && log("Reset");
	// For tests
	_unsubscribe(null, null);
	// We could just do _subscriptions = {};
};

// the number of subscriptions per event (for object if != null)
var _check = function(object) {
	var res = {};
	res.total = 0;
	var propToCheck = typeof object === "function" ? "callBack" : "object";
	Object.keys(_subscriptions).forEach(function(key) {
		res.total += _subscriptions[key].length;
		if (object == null) {
			res[key] = _subscriptions[key].length;
		} else {
			res[key] = 0;
			var arr = _subscriptions[key];
			for (var i = 0, l = arr.length; i < l; i++) {
				if (arr[i][propToCheck] === object) res[key] = res[key] + 1;
			}
		}
	});
	return res;
};
/**
 * Notify a specified page or the current one
 * We can't used the standard notification process for pages because we need to notify only one page
 * We can have potentially multiple pages objects (vignettes, disabled pages..)
 * We keep the subscription/publication method to to call asynchronously the method to release the stack
 * TODO - Review/improve later the project according to global needs
 * event: 	only one event
 * page:	second parameter - no parameter for current page
 * arguments:	callback arguments
 */
var _notifyController = function(event, page) {
	try {
		if (!event) throw new Error("_notifyController - Unexpected empty event");
		if (typeof event !== "string") throw new Error("_notifyController - string event expected");
		log && log("notifyController " + event);
		var args;
		if (page !== null) {
			args = Array.prototype.slice.call(arguments, 2);
		} else {
			page = globals.getCurrentPage();
			args = Array.prototype.slice.call(arguments, 1);
		}
		if (!page) throw new Error("_notifyController - Unexpected null page");
		var synch = event.smStartsWith("synch.");
		var callHandler;
		if (synch) {
			event = event.split("synch.")[1];
			callHandler = _callHandlerSynch;
		} else {
			callHandler = _callHandler;
		}
		var array = _subscriptions[event];
		if (array) {
			for (var i = 0, l = array.length; i < l; i++) {
				if (array[i].object === page) {
					return callHandler(array[i].callBack, page, args);
				}
			}
		} else {
			console.log("_notifyController - No sunsciption for event " + event);
		}
	} catch (e) {
		_err(e);
	}
};
exports.check = _check;
exports.reset = _reset;
exports.subscribe = _subscribe;
exports.unsubscribe = _unsubscribe;
exports.publish = _publish;
exports.publishEx = _publishEx;
exports.notifyController = _notifyController;