"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("notifs");

/**
 * publish/subscribe - Observer/Observable pattern with jQuery
 * We use jQuery triggering and use body as dispatcher
 * TODO - Eventually implement our own dispatcher
 **/

var _nameSpace = "sm";
var _subscriptions = {};

var _err = function(e) {
	log && log("Error", e);
	if (typeof e == "string") {
		throw new Error("Notification - " + e);
	} else {
		throw e;
	}
};

/**
 *  publish an event ("sm.login") or an array of events ["sm.login","sm.logout"]
 * 		Functional Object Subscribers
 * 			 notified through method notifEventname - object.notifLogin, object.notifLogout
 * 		Simple callBack Subscriber
 * 			called with event as first parameter
 * 	Argument that follow events parameter are passed to the Subscriber
 * */
var _publish = function(events) {
	try {
		if (!events) {
			throw new Error("No topic to publish");
		}
		var events = typeof events === "string" ? [events] : events;
		log && log("Publish " + events.join(" - "));
		var args, subscription, subscription, res;
		var count = 0,
			array;
		var objArgs, args = arguments;
		events.forEach(function(evt) {
			array = _subscriptions[evt];
			if (array) {
				array = array.slice();
				for (var i = 0, l = array.length; i < l; i++) {
					subscription = array[i];
					if (subscription.object) {
						if (!objArgs) objArgs = Array.prototype.slice.call(args, 1);
						// Remove first argument and call the method
						res = subscription.callBack.apply(subscription.object, objArgs);
					} else {
						// call the function with evt as first parameter
						args[0] = evt;
						res = subscription.callBack.apply(null, args);
					}
					count++;
					// TO SEE - -stop is res = false if ( res === false ) { break; }
				}
			}
		});
	} catch (e) {
		_err(e);
	}
};
/**
 * object subscribes for events (string or array)
 * 		object can be an functional Object or a function
 * 		functional Object must implement a method notifEventName  sm.Login.user -> Method notifLoginUser
 * Events starts with "sm" (sm.login, sm.logout)
 * High priority subscriptions are called first
 */
var _subscribe = function(object, events, priority) {
	if (!events) {
		_err("No topic to publish");
	}
	if (!object) {
		_err("Null object");
	}
	priority = priority || 10;
	var events = typeof events === "string" ? [events] : events;
	log && log("Subscribe " + events.join(" - ") + " - priority=" + priority);
	events.forEach(function(evt) {
		var callBackFct, callBackObj;
		if (typeof object == "function") {
			callBackFct = object;
			callBackObj = null;
		} else {
			callBackObj = object;
			var methodName = evt.split('.');
			if (methodName[0] != _nameSpace) _err("Bad event domain name");
			methodName = $.camelCase("notif-" + methodName.splice(1).join('-'));
			callBackFct = object[methodName];
			if (!callBackFct) {
				_err("Object must implement " + methodName);
			}
		}
		var added = false;
		if (!_subscriptions[evt]) {
			_subscriptions[evt] = [];
		}
		var subscriptionInfo = {
			callBack: callBackFct,
			object: callBackObj,
			priority: priority
		};
		for (var i = _subscriptions[evt].length - 1; i >= 0; i--) {
			if (_subscriptions[evt][i].priority <= priority) {
				_subscriptions[evt].splice(i + 1, 0, subscriptionInfo);
				added = true;
				break;
			}
		}
		if (!added) {
			_subscriptions[evt].unshift(subscriptionInfo);
		}
	});
};

/**
 * object unsubscribes for events
 *  object != null
 * 		Remove all object's subscription for given events
 * 		object can be an Object or a function
 *  object == null
 * 		Remove all subscription for given events
 *  events string or array
 * 		null -> unsubscribe for allevent
 */
var _unsubscribe = function(object, events) {
	if (!events) {
		events = Object.keys(_subscriptions);
	} else if (typeof events == "string") {
		events = [events];
	}

	var propToCheck = typeof object === "function" ? "callBack" : "object";
	events.forEach(function(evt) {
		var array = _subscriptions[evt];
		if (array) {
			for (var i = 0, l = array.length; i < l; i++) {
				if (object == null || array[i][propToCheck] === object) {
					array.splice(i, 1);
					// Adjust counter and length for removed item
					i--;
					l--;
				}
			}
		}

	});
};

// Remove all subscription
var _reset = function(object, events) {
	log && log("Reset");
	// For tests
	_unsubscribe(null, null);
	// We could just do _subscriptions = {};
};

// the number of subscriptions per event (for object if != null)
var _check = function(object) {
	var res = {};
	var propToCheck = typeof object === "function" ? "callBack" : "object";
	Object.keys(_subscriptions).forEach(function(key) {
		if (object == null) {
			res[key] = _subscriptions[key].length;
		} else {
			res[key] = 0;
			var arr = _subscriptions[key];
			for (var i = 0, l = arr.length; i < l; i++) {
				if (arr[i][propToCheck] === object) res[key] = res[key] + 1;
			}
		}
	});
	return res;
};

exports.check = _check;
exports.reset = _reset;
exports.subscribe = _subscribe;
exports.unsubscribe = _unsubscribe;
exports.publish = _publish;