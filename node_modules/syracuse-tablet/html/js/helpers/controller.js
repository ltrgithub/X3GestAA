"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var _Klass = utils.defineClass(
	function(id, prototype, article, options) {
		this.options = options || {};
		this.id = id || utils.UUID();
		this.prototype = prototype;
		this.article = article;
		this.rootLayout = null;
		this.dao = null;
		this._evtListener = null;
		this.isVignette = false;
		this._controlsMap = {};
		this._layoutsMap = {};
		// read/edit/create - read by default
		this.$activity = "read";
		globals.addController(this);
		notifications.subscribe(this, ["sm.lookup.selection"], 1);
		this.destroyed = false;
		this.isUnitTest = prototype.data("$isUnitTest") === true;
	}, null, {
		/**
		 * Used by page updateLayouts
		 */
		resetMaps: function() {
			this._controlsMap = {};
			this._layoutsMap = {};
		},
		destroy: function() {
			if (this.destroyed) return;
			globals.removeController(this);
			this._controlsMap = null;
			this._layoutsMap = null;
			if (this.dao) {
				this.dao.destroy();
				this.dao = null;
			}
			if (this.rootLayout) {
				this.rootLayout.destroy();
				this.rootLayout = null;
			}
			if (this.prototype) {
				this.prototype.destroy();
				this.prototype = null;
			}
			this.removeEventListener();
			notifications.unsubscribe(this);
			this.article = null;
			this.prototype = null;
			// in asynch process we sometimes need to check if controller have been destroyer - Paged loaded but controller destroyed
			this.destroyed = true;
		},
		addControl: function(c) {
			if (!c || !this._controlsMap) return;
			this._controlsMap[c.id] = c;
		},
		removeControl: function(c) {
			if (!c || !this._controlsMap) return;
			delete this._controlsMap[c.id];
		},
		addLayout: function(c) {
			if (!c || !this._layoutsMap) return;
			this._layoutsMap[c.id] = c;
		},
		getControl: function(id) {
			return this._controlsMap && this._controlsMap[id];
		},
		getLayout: function(id) {
			return this._layoutsMap && this._layoutsMap[id];
		},
		getStructElmt: function(id) {
			return this.getControl(id) || this.getLayout(id);
		},
		/**
		 * scans _controlsMap and calls callBack
		 * -> callBack returns true to stop
		 * returns control that stopped the scan
		 */
		forEachControl: function(callBack) {
			if (!callBack) return;
			var c = null;
			for (var id in this._controlsMap) {
				if (callBack(id, this._controlsMap[id])) {
					c = this._controlsMap[id];
					break;
				}
			}
			return c;
		},
		getControlByBind: function($bind) {
			for (var p in this._controlsMap) {
				if (this._controlsMap[p].$bind === $bind) return this._controlsMap[p];
			}
			return null;
		},
		setDao: function(dao) {
			if (this.dao && this.dao.destroy) this.dao.destroy();
			this.dao = dao;
		},
		isEditMode: function() {
			return this.$activity === "edit" || this.$activity === "create";
		},
		setActivity: function(activity) {
			this.$activity = activity || "read";
		},
		buildControlsTree: function(opts) {
			if (this.rootLayout) {
				this.rootLayout.destroy();
			}
			this.rootLayout = articleParser.article2Controls(this, this.article, this.prototype, opts || {});
			return this.rootLayout;
		},
		render: function($$parent, buildOpts) {
			if (!this.rootLayout) return;
			this.rootLayout.buildHtml($$parent, this.dao, buildOpts);
			// USed to retrieve the controller on events
			this.rootLayout.$$elmt.attr("data-controller-id", this.id);
		},
		/**
		 * Refresh the page
		 */
		refresh: function(options, callBackInterface) {
			throw new Error("Not implemeneted");
		},
		/**
		 * Used by refresh method to update controls after having loaded new data
		 * ids == null means all controls
		 * Returns the list controls with an error
		 */
		refreshControls: function(ids, options) {
			var self = this;
			var errors = [];
			var _refresh = function(ctrl) {
				if (!ctrl) return;
				ctrl.refresh(self.dao, options);
				if (ctrl.hasError()) {
					errors.push(ctrl);
				}
			};
			if (ids && ids.length > 0) {
				ids.forEach(function(id) {
					_refresh(self._controlsMap[id]);
				});
			} else {
				Object.keys(self._controlsMap).forEach(function(key) {
					_refresh(self._controlsMap[key]);
				});
			}
			return errors;
		},
		/** Event sm.action.link
		 *  Notified when a action succeeded - sdata link - see action manager
		 *  success:	true/false
		 *  link:		Link info
		 *  result:		Json response
		 */
		notifActionLink: function(success, link, result, options) {
			throw new Error("not implemented");
		},
		/**
		 * When we select a value in a lookup
		 * 		rowData:	Selected row  - {data, proto} - data: selected JSON data - proto - prototype of row data
		 * 		controlId:	Id of control to refresh
		 */
		notifLookupSelection: function(rowData, controlId) {
			try {
				var ctrl = this.getControl(controlId);
				if (!ctrl) throw new Error("Control not found '" + controlId + "'");
				if (!ctrl.setLookupValue) throw new Error("Control must implement setLookupValue '" + controlId + "'");
				ctrl.setLookupValue(rowData);
			} catch (e) {
				globals.getModal().error("notifLookupSelection failed", e);
			}
		},
		/**
		 * Check controls data - Edit mode only
		 * Return true if ok
		 * Display fields errors if any
		 */
		checkControlsData: function() {
			if (!this.isEditMode()) return true;
			var self = this;
			var ok = true;
			var firstError, c;
			Object.keys(self._controlsMap).forEach(function(key) {
				c = self._controlsMap[key];
				if (c && c.checkData) {
					ok = ok && c.checkData();
					if (!ok && firstError == null) firstError = c;
				}
			});
			if (firstError) {
				firstError.setFocus();
			}
			return ok;
		},
		/**
		 * Show element in page - scroll if needed
		 * c is a JQuery elmt or an object with $$elmt property
		 */
		makeVisible: function(c) {
			// TODO - Implement a gestureManager in base controller to allow makeVisible
		},
		applyChange: function(newData) {
			if (!newData || !this.dao) return;
			this.dao.applyChange(newData);
			this.refreshControls(null, {
				refreshValue: true
			});
		},
		/**
		 * Allows child controllers to listen events
		 * controller event listener is called before coaling control listener
		 * Signature		mylistener(when, ctrl, $$target, event)
		 * 					when		"before" or "after"
		 * 									"before"	call before calling control event
		 * 										return false 	to continue
		 * 										return true 	to stop the process and not call control's listener
		 * 									"after" 	call after calling control event
		 * 					ctrl		control object
		 * 					$$target	target elmt
		 * 					event		event
		 * eventName		click, change, blur...
		 */
		addEventListener: function(eventName, method) {
			if (!method || typeof method !== "function") return;
			if (!this._evtListener) {
				this._evtListener = {};
			}
			this._evtListener[eventName] = jsutils.bindFn(method, this);
		},
		removeEventListener: function(eventName) {
			if (!this._evtListener) return;
			if (eventName) {
				this._evtListener[eventName] = null;
			} else {
				for (var p in this._evtListener) {
					this._evtListener = null;
				}
			}
		},
		getEventListener: function(eventName) {
			return this._evtListener ? this._evtListener[eventName] : null;
		}
	});


exports.Klass = _Klass;