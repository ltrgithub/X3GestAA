"use strict";

var locale = require("syracuse-tablet/html/js/helpers/locale");
var _decimalInfo = locale.getDecimalInfo;

var localeKeys = {
	gs: "numberGroupSeparator",
	ds: "numberDecimalSeparator"
};

//======================
//	Useful elements
//======================

/**
 * Format object used to handle format. Useful for the formatting and parsing methods
 * @param {Object} prefix	Any text before directives
 * @param {Object} postfix	Any text after directives
 * @param {Object} properties	Properties are : hasDecimalSeparator, hasGroupSeparator, mandatoryAfter, maxAfter, groupSize, mandatoryBefore, directive, hasPercent, hasPermil, hasSignFormat
 */
function FormatObj(prefix, postfix, properties) {
	this.prefix = prefix;
	this.postfix = postfix;
	this.properties = properties;
}

/**
 * Set number format properties from directive parameter.
 * @param {String}	directive
 * @param {Object}	fObj
 * @return {Object}	Returns a formatObj with properties set
 */
function _processDirective(directive, fObj) {
	// properties to set:   

	// result
	var f = new FormatObj(fObj.prefix, fObj.postfix, fObj.properties);

	var hasDecimalSeparator, hasGroupSeparator;

	var dsIndex = directive.indexOf('.');
	var gsIndex = directive.indexOf(',');

	// decimal and group separator properties
	f.properties.hasDecimalSeparator = hasDecimalSeparator = dsIndex > -1;
	f.properties.hasGroupSeparator = hasGroupSeparator = gsIndex > -1;

	// after properties	
	if (hasDecimalSeparator) {
		var decimal = directive.substring(dsIndex + 1);
		f.properties.mandatoryAfter = decimal.indexOf("0") > -1 ? decimal.match(/0/g).length : 0;
		f.properties.maxAfter = decimal.length;
	}

	// group size property
	if (hasGroupSeparator) {
		f.properties.groupSize = hasDecimalSeparator ? dsIndex - gsIndex - 1 : directive.substring(gsIndex + 1).length;
	}

	// before property
	var integer = hasDecimalSeparator ? directive.substring(0, dsIndex) : directive;
	f.properties.mandatoryBefore = integer.indexOf("0") > -1 ? integer.match(/0/g).length : 0;

	// directive
	f.properties.directive = directive;

	// percent/permil property
	f.properties.hasPercent = directive.indexOf("%") > -1;
	f.properties.hasPermil = directive.indexOf("‰") > -1;

	// sign format
	f.properties.hasSignFormat = directive.indexOf('+') > -1 && directive.indexOf('+') === 0;

	return f;
}

/**
 * Walk through the given format and run functions in map
 * @param {Object} format
 * @param {Object} map
 */
function _walkFormat(format, map) {
	var i = 0,
		len = format.length;

	// valid directive characters in format (except ';')
	var validDir = "0#.,%‰+"; //	'E' or 'e' are not supported yet
	function count(i) {
		var ch = format[i],
			k = 1;
		while (validDir.indexOf(format[i + k]) > -1)
			k++;
		return k;
	}

	while (i < len) {
		var c = format[i];
		switch (c) {
			case "'":
				i++;
				var literal = '';
				// going to the end of the following litteral or to the format end
				for (; i < len; i++) {
					if (format[i] === "'") {
						i++;
						// check wether the "'" is not doubled
						if (format[i] === "'") {
							literal += "'";
						} else break;
					} else {
						literal += format[i];
					}
				}
				map.literal(literal);
				break;
			case "0":
			case "#":
			case ".":
			case "%":
			case "‰":
			case "+":
				var directiveLength = count(i);
				map.directive(i, i + directiveLength);
				i += directiveLength;
				break;
			case ";":
				map.listSeparator();
				i++;
				break;
			default:
				map.literal(c);
				i++;
		}
		// at the end of the loop
		if (i === len) {
			map.listSeparator();
		}
	}
}

/**
 * Add separator parameter after every digits group of size value to the number paramater.
 * @param {Object} num
 * @param {Object} gs
 * @param {Object} size
 */
function _addSeparator(num, gs, size) {
	var result = "";
	var len = num.length;
	var c = "";
	var count = 0;
	for (var i = len - 1; i >= 0; i--) {
		c = num[i];
		result += c;
		++count;
		if ((count % size === 0) && i > 0) {
			result += gs;
		}
	}
	return result.split("").reverse().join("");
}

/**
 * Returns key value from either user preferences or locale resources values
 * @param {Object} key
 */
function _localized(key) {
	return _resources()[key];
}

//======================
//	Format functions
//======================

/**
 * Forat a number
 * @param {Object} val	Raw number
 * @param {Object} format	Format to apply
 * @return {String} Returns a string value containing formatted number
 */
exports.format = function(val, format) {

	//	if (!val)
	//		throw new Error("empty number value");

	if (isNaN(val)) throw new Error(locale.text("numberFormat.notNumber", val));

	if (format == null) {
		val = val.toString();
		var dsIndex = val.indexOf('.');
		var hasDecimal = dsIndex > -1;
		var intPart = hasDecimal ? val.substring(0, dsIndex) : val;
		var decimalPart = hasDecimal ? val.substring(dsIndex + 1) : '';
		var gs = _localized(localeKeys.gs) || "";
		var ds = hasDecimal ? (_localized(localeKeys.ds) || ".") : '';
		return _addSeparator(intPart, gs, 3) + ds + decimalPart;
	} else {
		return _format(val, format);
	}

};

function _format(val, format) {
	var prefix, postfix;
	// position in val
	var j = 0;
	// format list (used in case of list of formats separated with ';', empty otherwise)
	var formatsList = [];

	var directiveProcessed = false;

	var f = new FormatObj('', '', {});

	_walkFormat(format, {
		literal: function(literal) {
			// set prefix or postfix value
			directiveProcessed ? f.postfix += literal : f.prefix += literal;
		},
		directive: function(beg, end) {
			// get directive part of the format
			var directive = format.substring(beg, end);

			// process directive
			f = _processDirective(directive, f);

			directiveProcessed = true;
		},
		listSeparator: function() {
			directiveProcessed = false;
			formatsList.push(f);
			f = new FormatObj('', '', {});
			prefix = '';
			postfix = '';
		}
	});

	var flen = formatsList.length;
	switch (flen) {
		case 1:
			return _formatNumber(val, formatsList[0]);
			break;
		case 2:
		case 3:
			if (val === 0) return _formatZero(formatsList[2]);
			else return val < 0 ? _formatNumber(val.toString().substring(1), formatsList[1]) : _formatNumber(val, formatsList[0]);
			break;
		default:
			throw new Error(flen === 0 ? locale.text("numberFormat.noFormat") : locale.text("numberFormat.manyFormat"));
	}
}

function _formatZero(fObj) {
	return fObj.prefix;
}

function _formatNumber(num, fObj) {
	var res = '';

	// locale separators
	var gs = _localized(localeKeys.gs);
	var ds = _localized(localeKeys.ds);

	var directive = fObj.properties.directive;

	// special case for percentages
	num = fObj.properties.hasPercent ? num * 100 : num;
	num = fObj.properties.hasPermil ? num * 1000 : num;

	// == decimal ==
	if (fObj.properties.hasDecimalSeparator) {
		var decimalPart = '';
		var maxAfter = fObj.properties.maxAfter;
		var decimalFormat = directive.substr(directive.indexOf('.') + 1, maxAfter);
		var decimalValue = num % 1;
		var decimalString = '' + decimalValue.toFixed(maxAfter);
		decimalString = decimalString.substring(decimalString.indexOf('.') + 1);
		for (var i = 0; i < maxAfter; i++) {
			var f = decimalFormat.charAt(i);
			var n = decimalString.charAt(i);
			if (f === '0') {
				decimalPart += n;
			} else if (f === '#' && n !== '0') {
				decimalPart += n;
			} else if (f === '#' && n === '0') { // end loop if only '0' left in decimalString
				var notParsed = decimalString.substring(i);
				if (notParsed.match('[1-9]')) decimalPart += n;
				else break;
			}
		}
		res = decimalPart ? ds + decimalPart : res; // in case of integer value, decimalPart --> ''
	} else {
		// it is possible to have decimal number and format not containing decimal separator
		num = Math.round(num);
	}

	// == integer ==
	var intPart = num < 0 ? '' + Math.ceil(num) : '' + Math.floor(num);
	intPart = intPart.replace(/[^\d]+/g, '');
	var intFormat = directive.indexOf('.') === -1 ? directive : directive.substring(0, directive.indexOf('.'));
	// padding if necessary
	if (intPart.length < fObj.properties.mandatoryBefore) {
		var missing = fObj.properties.mandatoryBefore - intPart.length;
		var toAdd = '';
		for (var i = 0; i < missing; i++) {
			toAdd += '0';
		}
		intPart = toAdd + intPart;
	}
	// adding group separator if needed
	if (fObj.properties.hasGroupSeparator) {
		if (fObj.properties.groupSize < intPart.length) {
			intPart = _addSeparator(intPart, gs, fObj.properties.groupSize);
		}
	}

	// in case of no mandatory digit before decimal separator, no character for int part
	intPart = (parseInt(intPart, 10) === 0 && fObj.properties.mandatoryBefore === 0) ? '' : intPart;

	intPart = intPart && num < 0 ? '-' + intPart : intPart;
	res = intPart + res;

	// == specific cases ==
	// sign format
	res = fObj.properties.hasSignFormat && num > 0 ? '+' + res : res;

	// percent and/or permil
	res += fObj.properties.hasPercent ? "%" : '';
	res += fObj.properties.hasPermil ? "‰" : '';

	return fObj.prefix + res + fObj.postfix;
}

//======================
//	Parsing functions
//======================

// * @param {Object} fn	Function called if number returned doesn't match with the integer type (only use)
// exports.parse = function(str, format, fn){
/**
 * Get a number from a formatted number string value
 * @param {Object} str	Formatted number
 * @param {Object} format	Format supposedly used
 * @return {Object}	Returns a number (integer : floor(number), decimal : BigDecimal, real : number)
 */
exports.parse = function(str, format) {
	if (!str) return 0;
	//throw new Error("number string is null");

	if (format == null) {
		return parseFloat(str);
	} else {
		return _parse(str, format);
	}
};

function _parse(str, format) {
	//format = /[0-9-+,.#eE%‰;()\s]/g.exec();
	var prefix, postfix;

	// position in str
	var j = 0;

	// format list (used in case of list of formats separated with ';', empty otherwise)
	var formatsList = [];

	var directiveProcessed = false;

	var f = new FormatObj('', '', {});

	_walkFormat(format, {
		literal: function(literal) {
			// set prefix or postfix value
			directiveProcessed ? f.postfix += literal : f.prefix += literal;
		},
		directive: function(beg, end) {
			// get directive part of the format
			var directive = format.substring(beg, end);

			// process directive
			f = _processDirective(directive, f);

			directiveProcessed = true;
		},
		listSeparator: function() {
			directiveProcessed = false;
			formatsList.push(f);
			f = new FormatObj('', '', {});
			prefix = '';
			postfix = '';
		}
	});

	return _parseFormats(str, formatsList);
}

function _parseFormats(str, formatsList, negative) {
	var flen = formatsList.length;
	var num;
	// locale separators
	var gs = _localized(localeKeys.gs);
	var ds = _localized(localeKeys.ds);

	switch (flen) {
		case 1:
			var fObj = formatsList[0];
			var formatNumber = str;
			var integerPart, decimalPart;
			// extract prefix and postfix
			var prefix = fObj.prefix;
			var postfix = fObj.postfix;
			formatNumber = prefix ? formatNumber.substring(prefix.length) : formatNumber;
			formatNumber = postfix ? formatNumber.substring(0, formatNumber.length - postfix.length) : formatNumber;

			// splitting into integer and decimal parts
			var splitted = formatNumber.split(ds);
			// error : too many periods
			if (splitted.length > 2) throw new Error(locale.text("numberFormat.oneSep", formatNumber));
			// setting integer and decimal parts values
			integerPart = splitted[0] ? splitted[0].match(/[0-9]/g).join('') : '0';
			decimalPart = splitted.length > 1 ? splitted[1].match(/[0-9]/g).join('') : '';
			num = parseFloat(decimalPart ? integerPart + "." + decimalPart : integerPart);

			// == specific cases ==
			// negative value
			num = formatNumber.charAt(0) === '-' ? parseFloat('-' + num) : num;
			// percent or permil
			num = fObj.properties.hasPercent ? num / 100 : num;
			num = fObj.properties.hasPermil ? num / 1000 : num;
			// negative value set for list separator cases
			num = negative ? parseFloat('-' + num) : num;
			break;
		case 2:
		case 3:
			// valid characters in formatted number
			var validFormat = "1234567890" + ds + gs + "%‰-+"; // 'E' or 'e' are not supported yet
			var len = formatsList.length;
			var slen = str.length;

			for (var i = 0; i < len; i++) {
				var f = formatsList[i];
				var prefix = f.prefix;
				var postfix = f.postfix;

				var prefixDefined = prefix ? true : false;
				var postfixDefined = postfix ? true : false;

				var pre, post;

				pre = prefixDefined ? str.substring(0, prefix.length) : '';
				post = postfixDefined ? str.substring(slen - postfix.length) : '';

				if (((prefixDefined && !postfixDefined) && pre.indexOf(prefix) > -1) || ((prefixDefined && postfixDefined) && (pre.indexOf(prefix) > -1 && post.indexOf(postfix) > -1)) || ((!prefixDefined && postfixDefined) && post.indexOf(postfix) > -1) || ((!prefixDefined && !postfixDefined) && (validFormat.indexOf(str.charAt(0)) > -1 && validFormat.indexOf(str.charAt(slen - 1)) > -1))) {
					break;
				}
			}
			var flist = [];
			flist.push(formatsList[i]);
			switch (i) {
				case 0:
					num = _parseFormats(str, flist);
					break;
				case 1:
					num = _parseFormats(str, flist, true);
					break;
				case 2:
					num = 0;
					break;
				default:
					throw new Error(locale.text("numberFormat.cannotParse"));
			}
			break;
		default:
			throw new Error(flen === 0 ? locale.text("numberFormat.noFormat") : locale.text("numberFormat.manyFormats"));
	}
	return num;
}