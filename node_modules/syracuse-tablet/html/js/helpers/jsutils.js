"use strict";
/*
 * This module must only contain low level helper functions that do not have any dependencies!
 */

var _isInstanceOf = function(o, name) {
	if (o == null) return false;
	var ctor = o.constructor;
	if (ctor && ctor.$smClasses) {
		return ctor.$smClasses.indexOf(name) > -1;
	}
	return false;
};

var _addInheritanceInfo = function(ctor, parent) {
	var classes = [];
	/**
	 * ctor.name comes from the constructor
	 *	var _Page = utils.defineClass(
	 *	function RegularPage($parent,
	 *	In that case name = "RegularPage"
	 *	if function($parent.. nmae= ""
	 */
	if (ctor.name) {
		classes.push(ctor.name);
		if (parent && parent.$smClasses) {
			var i;
			for (i = 0; i < parent.$smClasses.length; i++) {
				classes.push(parent.$smClasses[i]);
			}
		}
	}
	ctor.$smClasses = classes;
};

var _isError = function(o) {
	return o && Error.prototype.toString === o.toString;
};

var _isException = function(o) {
	return o && o.constructor && o.constructor.name === "DOMException";
};

/** 
 * Clean error stack from current base url and limit the size due to the use of deferred
 * html: true -> Display in Html
 **/
var _stackRegexp;
var _cleanStack = function(stack, max, html) {
	if (Array.isArray(stack)) return stack;
	var globals = window.$sm;
	if (!globals) return stack;
	if (!_stackRegexp && globals && globals.baseLocation()) {
		_stackRegexp = {
			r1: new RegExp(globals.baseLocation().withPath, "g"),
			r2: new RegExp(globals.baseLocation().requirePath, "g")
		};
	}

	max = max == null ? 5 : max;
	if (stack) {
		var array = (stack.split && stack.split("\n")) || stack;;
		var res;
		if (array.length > 0) {
			array.forEach(function(l) {
				var pos1 = l.lastIndexOf(".js");
				if (pos1 > 0) {
					var pos2 = l.lastIndexOf("/", pos1);
					if (pos1 > 0) {
						if (!res) res = [];
						res.push(l.substring(pos2));
					}
				} else {
					// Unknown line format (to include details at end of stack, just add line here)
					if (!res) res = [];
					res.push(l);
				}
			});
		}
		if (!res && _stackRegexp) {
			stack = _stackRegexp ? stack.replace(_stackRegexp.r1, "").replace(_stackRegexp.r2, "") : stack;
		} else {
			stack = res.join('\n');
		}
	} else {
		stack = "";
	}
	stack = stack.split("\n");
	if (max) { // Allow max level of source stack files, stack elements not pointing to a file are always added since the may include important information
		res = [];
		stack.forEach(function(l) {
			if (l.indexOf(".js") > -1) {
				if (max > 0) {
					res.push(l);
					max--;
				}
			} else {
				res.push(l);
			}
		});
		stack = res.join(html ? "<br>&nbsp&nbsp&nbsp&nbsp&nbsp" : "\n");
	}
	return stack;
};

/*
 * Takes what ever is passed as parameter and creates an object containing and $diagnoses array
 * title: Always a string
 * e: String or Error or any kind of object*
 *
 * object*:
 * {
 *   message: "text",
 *   detail: Error or Object
 * }
 *
 */
var _convertToDiagnoses = function(title, e) {
	// Handle case where first parameter is an Error
	if (e == null) {
		e = title;
		title = null;
	}
	if (e == null) {
		e = "No error message";
	}
	if (typeof e === "string") {
		// String message
		return {
			$diagnoses: [{
				$severity: "error",
				$message: e
			}]
		};
	} else if (_isError(e) || _isException(e)) {
		// Exception to diagnoses
		return {
			$diagnoses: [{
				$message: e.message,
				$stackTrace: _cleanStack(e.stack),
				$severity: "error"
			}]
		};
	} else {
		// If parameter is already an object with diagnoses, do not do anything special
		if (e.$diagnoses && Array.isArray(e.$diagnoses)) {
			return e;
		}

		// Arbitrary object
		var res = {
			$diagnoses: [{}]
		};
		var diag = res.$diagnoses[0];
		// SOme processes post $message or $title error (see sDataCommonResources)
		diag.$message = e.message || e.$message || e.$title || title;
		diag.$severity = "error";
		var detail = e.detail;
		if (detail) {
			if (_isError(detail)) {
				if (detail.message) {
					diag.$stackTrace = (diag.$stackTrace ? diag.$stackTrace + "\n" : "") + detail.message;
				}
				if (detail.stack) {
					diag.$stackTrace = (diag.$stackTrace ? diag.$stackTrace + "\n" : "") + _cleanStack(detail.stack);
				}
			} else {
				diag.$stackTrace = (diag.$stackTrace ? diag.$stackTrace + "\n" : "") + JSON.stringify(detail);
			}
		}

		return res;
	}
};

/**
 * return the value of a given path
 * 	path:	String with/without '.' as separator or array of strings
 *  cache: 	null	-> No cache
 * 		    !null	-> object that stores the cache
 */
var _getPropByPath = function(object, path, cache) {
	if (path == null || object == null) return null;
	var pathStr, pathArray;
	if (Array.isArray(path)) {
		if (path.length === 0) return null;
		pathArray = path;
		pathStr = pathArray.join(".");
	} else {
		pathArray = path.split('.');
		pathStr = path;
	}
	if (cache && cache[pathStr] != null) {
		return cache[pathStr];
	}
	// Check parent if needed
	var data = object[pathArray[0]];
	for (var i = 1; i < pathArray.length; i++) {
		if (data == null) return null;
		if (!$.isPlainObject(data) == null) {
			throw new Error('_getPropByPath - Unexpected non-plainobject');
		}
		data = data[pathArray[i]];
	}
	if (cache) {
		cache[pathStr] = data;
	}
	return data;
};


/**
 * simple function bind
 * arguments that follow context are passed to fn call back after the regular parameters
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
	var args = arguments.length > 2 ? Array.prototype.splice.call(arguments, 2) : null;
	return function boundFn() {
		var callBackArgs = arguments;
		if (args && args.length > 0) {
			args.forEach(function(a) {
				Array.prototype.push.call(callBackArgs, a);
			});
		}
		return fn.apply(context ? context : this, callBackArgs);
	};
}
//http://jsperf.com/multi-array-concat/7
// concatArrays(array1, array2, array3...) - accept undefined arguments
exports.concatArrays = function() {
	var args = [];
	for (var i = 0; i < arguments.length; i++) {
		if (arguments[i] != null) args.push(arguments[i]);
	}
	return [].concat.apply([], args);
};
exports.getPropByPath = _getPropByPath;
exports.addInheritanceInfo = _addInheritanceInfo;

/**
 * return true if o is an instance of class 'name'
 * Like this process could slow down the application it's better to register only classes for which we want to check instance
 */
exports.isInstanceOf = _isInstanceOf;

exports.isError = _isError;

exports.cleanStack = _cleanStack;

exports.convertToDiagnoses = _convertToDiagnoses;

exports.bindFn = bindFn;

var _userAgent = navigator.userAgent.toLowerCase();
/* chrome, safari, opera, msie, mozilla */
exports.checkBrowser = function() {
	for (var i = 0; i < arguments.length; i++) {
		if (!new RegExp(arguments[i]).test(_userAgent)) {
			return false;
		}
	}
	return true;
};
var _currentBrowser;
exports.checkCurrentBrowser = function(name) {
	if (!_currentBrowser) {
		["chrome", "safari", "opera", "msie", "mozilla"].some(function(name) {
			if (exports.checkBrowser(name)) {
				_currentBrowser = name;
				return true;
			}
		});
	}
	return name === _currentBrowser;
};