"use strict";
/*
 * This module must only contain low level helper functions that do not have any dependencies!
 */
if (!window.exports) {
	// Trick - This file can be used in html pages outsite required loader - See open_link
	window.exports = window;
}
/** Parse an url 
 * !!! no @ character should be present in query params (keep them encoded)
 * There are @ query params in date where clauses
 **/
var _purlOptions = {
	strictMode: false,
	key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "querystring", "anchor"],
	q: {
		name: "query",
		parser: /(?:^|&)([^&=]*)=?([^&]*)/g
	},
	parser: {
		strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
		loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
	}
};
/*
 * {
  "anchor": "", "file": "", "password": "", "user": "", "userInfo": "",
  "querystring": "representation=AQTCRUDM.$edit",
  "directory": "/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies",
  "path": "/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies",
  "relative": "/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies?representation=AQTCRUDM.$edit",
  "port": "8124",
  "host": "pc101329.sagefr.adinternal.com",
  "authority": "pc101329.sagefr.adinternal.com:8124",
  "protocol": "http",
  "source": "http://pc101329.sagefr.adinternal.com:8124/sdata/x3/erp/SUPERV/AQTCRUD/$template/$workingCopies?representation=AQTCRUDM.$edit",
  "query": {
    "representation": "AQTCRUDM.$edit"
  }
 */
var _parseURL = function(str) {
	var o = _purlOptions;
	var m = o.parser[o.strictMode ? "strict" : "loose"].exec(str);
	var uri = {};
	var i = 14;

	while (i--) uri[o.key[i]] = m[i] || "";

	uri[o.q.name] = {};
	uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) {
		if ($1) uri[o.q.name][$1] = decodeURIComponent($2);
	});
	return uri;
};
/**
 * Return a string url from u object which has been parsed with _parseURL
 */
var _urlToString = function(u) {
	if (!u) return "";
	var url = "";
	if (u.protocol && u.host) {
		url += u.protocol + "://" + u.host;
		if (u.port.length != 0) url += ":" + u.port;
	}
	url += u.path;
	var query = "";
	for (var p in u.query) {
		if (query.length != 0) query += "&";
		query += p + "=" + encodeURIComponent(u.query[p]);
	}
	if (query.length != 0) url += "?" + query;
	if (u.anchor) url += "#" + u.anchor;
	return url;
};
/**
 * Return the current url
 */
var _curUrl;
var _getCurrentUrl = function() {
	if (_curUrl) return _curUrl;
	_curUrl = _parseURL(window.location.href);
	return _curUrl;
};
/**
 * Returns the url that will contain the current page context to restore (ctx) (links, live tiles...)
 */
var _getOpenLinkUrl = function(ctxUuid) {
	var url = exports.getCurrentUrl();
	// We open open_link.html that will remove the context from url and store it in sessionStorage (see _setUrlContextId)
	var file = url.file;
	url.file = "open_link.html";
	url.path = url.path.replace(file, url.file);
	if (ctxUuid) {
		if (!url.query) url.query = {};
		url.query.context = ctxUuid;
	}
	return exports.urlToString(url);
};
/**
 * Returns the context to restore if any (used by external links or live tiles to open a page)
 * Context has been stored by open_link.html page and removed from url (see getOpenLinkUrl, sessStorage)
 * return {endpoint:, applicationName:, history[state]}
 */
var _getUrlContextId = function() {
	// Read context in session storage if any (see open_link.html)
	var contextId;
	var sessStorage = typeof(sessionStorage) !== "undefined" ? sessionStorage : null;
	if (sessStorage) {
		contextId = sessStorage.getItem("__urlContext__");
		sessStorage.removeItem("__urlContext__");
	}
	if (!contextId) {
		// If no context check url context
		var url = exports.getCurrentUrl();
		contextId = url.quey ? url.query.context : null;
	}
	return contextId;
};
/**
 * Read url context and stores it in session storage if any
 * Remove the context param from url
 * Call idenx.htlk page
 */
var _setUrlContextId = function() {
	var sessStorage = typeof(sessionStorage) !== "undefined" ? sessionStorage : null;
	if (sessStorage) {
		sessStorage.removeItem("__urlContext__");
	}
	var url = _parseURL(window.location.href);
	try {
		var contextId = url.query && url.query.context;
		console.log("_setUrlContextId", contextId);
		if (sessStorage && contextId && contextId.trim().length > 0) {
			// Stores the context
			sessStorage.setItem("__urlContext__", contextId);
			// Remove it from url
			delete url.query.context;
		}
	} catch (e) {}
	// location.replace to prevent back button
	var file = url.file;
	url.file = url.path.indexOf('/dist/') > 0 ? "index.html" : "index_debug.html";
	url.path = url.path.replace(file, url.file);
	window.location.replace(_urlToString(url));
};


var _isInstanceOf = function(o, name) {
	if (o == null) return false;
	var ctor = o.constructor;
	if (ctor && ctor.$smClasses) {
		return ctor.$smClasses.indexOf(name) > -1;
	}
	return false;
};

var _addInheritanceInfo = function(ctor, parent) {
	var classes = [];
	/**
	 * ctor.name comes from the constructor
	 *	var _Page = utils.defineClass(
	 *	function RegularPage($parent,
	 *	In that case name = "RegularPage"
	 *	if function($parent.. nmae= ""
	 */
	if (ctor.name) {
		classes.push(ctor.name);
		if (parent && parent.$smClasses) {
			var i;
			for (i = 0; i < parent.$smClasses.length; i++) {
				classes.push(parent.$smClasses[i]);
			}
		}
	}
	ctor.$smClasses = classes;
};

var _isError = function(o) {
	return o && Error.prototype.toString === o.toString;
};

var _isException = function(o) {
	return o && o.constructor && o.constructor.name === "DOMException";
};

/** 
 * Clean error stack from current base url and limit the size due to the use of deferred
 * html: true -> Display in Html
 **/
var _stackRegexp;
var _cleanStack = function(stack, max, html) {
	if (Array.isArray(stack)) return stack;
	var globals = window.$sm;
	if (!globals) return stack;
	if (!_stackRegexp && globals && globals.baseLocation()) {
		_stackRegexp = {
			r1: new RegExp(globals.baseLocation().withPath, "g"),
			r2: new RegExp(globals.baseLocation().requirePath, "g")
		};
	}

	max = max == null ? 5 : max;
	if (stack) {
		var array = (stack.split && stack.split("\n")) || stack;;
		var res;
		if (array.length > 0) {
			array.forEach(function(l) {
				var pos1 = l.lastIndexOf(".js");
				if (pos1 > 0) {
					var pos2 = l.lastIndexOf("/", pos1);
					if (pos1 > 0) {
						if (!res) res = [];
						res.push(l.substring(pos2));
					}
				} else {
					// Unknown line format (to include details at end of stack, just add line here)
					if (!res) res = [];
					res.push(l);
				}
			});
		}
		if (!res && _stackRegexp) {
			stack = _stackRegexp ? stack.replace(_stackRegexp.r1, "").replace(_stackRegexp.r2, "") : stack;
		} else {
			stack = res.join('\n');
		}
	} else {
		stack = "";
	}
	stack = stack.split("\n");
	if (max) { // Allow max level of source stack files, stack elements not pointing to a file are always added since the may include important information
		res = [];
		stack.forEach(function(l) {
			if (l.indexOf(".js") > -1) {
				if (max > 0) {
					res.push(l);
					max--;
				}
			} else {
				res.push(l);
			}
		});
		stack = res.join(html ? "<br>&nbsp&nbsp&nbsp&nbsp&nbsp" : "\n");
	}
	return stack;
};

/*
 * Takes what ever is passed as parameter and creates an object containing and $diagnoses array
 * title: Always a string
 * e: String or Error or any kind of object*
 *
 * object*:
 * {
 *   message: "text",
 *   detail: Error or Object
 * }
 *
 */
var _convertToDiagnoses = function(title, e) {
	// Handle case where first parameter is an Error
	if (e == null) {
		e = title;
		title = null;
	}
	if (e == null) {
		e = "No error message";
	}
	if (typeof e === "string") {
		// String message
		return {
			$diagnoses: [{
				$severity: "error",
				$message: e
			}]
		};
	} else if (_isError(e) || _isException(e)) {
		// Exception to diagnoses
		return {
			$diagnoses: [{
				$message: e.message,
				$stackTrace: _cleanStack(e.stack),
				$severity: "error"
			}]
		};
	} else {
		// If parameter is already an object with diagnoses, do not do anything special
		if (e.$diagnoses && Array.isArray(e.$diagnoses)) {
			return e;
		}

		// Arbitrary object
		var res = {
			$diagnoses: [{}]
		};
		var diag = res.$diagnoses[0];
		// SOme processes post $message or $title error (see sDataCommonResources)
		diag.$message = e.message || e.$message || e.$title || title;
		diag.$severity = "error";
		var detail = e.detail;
		if (detail) {
			if (_isError(detail)) {
				if (detail.message) {
					diag.$stackTrace = (diag.$stackTrace ? diag.$stackTrace + "\n" : "") + detail.message;
				}
				if (detail.stack) {
					diag.$stackTrace = (diag.$stackTrace ? diag.$stackTrace + "\n" : "") + _cleanStack(detail.stack);
				}
			} else {
				diag.$stackTrace = (diag.$stackTrace ? diag.$stackTrace + "\n" : "") + JSON.stringify(detail);
			}
		}

		return res;
	}
};

/**
 * return the value of a given path
 * 	path:	String with/without '.' as separator or array of strings
 *  cache: 	null	-> No cache
 * 		    !null	-> object that stores the cache
 */
var _getPropByPath = function(object, path, cache) {
	if (path == null || object == null) return null;
	var pathStr, pathArray;
	if (Array.isArray(path)) {
		if (path.length === 0) return null;
		pathArray = path;
		pathStr = pathArray.join(".");
	} else {
		pathArray = path.split('.');
		pathStr = path;
	}
	if (cache && cache[pathStr] != null) {
		return cache[pathStr];
	}
	// Check parent if needed
	var data = object[pathArray[0]];
	for (var i = 1; i < pathArray.length; i++) {
		if (data == null) return null;
		if (!$.isPlainObject(data) == null) {
			throw new Error('_getPropByPath - Unexpected non-plainobject');
		}
		data = data[pathArray[i]];
	}
	if (cache) {
		cache[pathStr] = data;
	}
	return data;
};


/**
 * simple function bind
 * arguments that follow context are passed to fn call back after the regular parameters
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
	var args = arguments.length > 2 ? Array.prototype.splice.call(arguments, 2) : null;
	return function boundFn() {
		var callBackArgs = arguments;
		if (args && args.length > 0) {
			args.forEach(function(a) {
				Array.prototype.push.call(callBackArgs, a);
			});
		}
		return fn.apply(context ? context : this, callBackArgs);
	};
}
//http://jsperf.com/multi-array-concat/7
// concatArrays(array1, array2, array3...) - accept undefined arguments
exports.concatArrays = function() {
	var args = [];
	for (var i = 0; i < arguments.length; i++) {
		if (arguments[i] != null) args.push(arguments[i]);
	}
	return [].concat.apply([], args);
};
exports.getPropByPath = _getPropByPath;
exports.addInheritanceInfo = _addInheritanceInfo;

/**
 * return true if o is an instance of class 'name'
 * Like this process could slow down the application it's better to register only classes for which we want to check instance
 */
exports.isInstanceOf = _isInstanceOf;

exports.isError = _isError;

exports.cleanStack = _cleanStack;

exports.convertToDiagnoses = _convertToDiagnoses;

exports.bindFn = bindFn;

exports.getCurrentUrl = _getCurrentUrl;
exports.getOpenLinkUrl = _getOpenLinkUrl;
exports.getUrlContextId = _getUrlContextId;
exports.setUrlContextId = _setUrlContextId;
exports.parseURL = _parseURL;
exports.urlToString = _urlToString;

var _userAgent = navigator.userAgent.toLowerCase();
/* chrome, safari, opera, msie, mozilla */
exports.checkBrowser = function() {
	for (var i = 0; i < arguments.length; i++) {
		if (!new RegExp(arguments[i]).test(_userAgent)) {
			return false;
		}
	}
	return true;
};
var _currentBrowser;
exports.checkCurrentBrowser = function(name) {
	if (!_currentBrowser) {
		["chrome", "safari", "opera", "msie", "mozilla"].some(function(name) {
			if (exports.checkBrowser(name)) {
				_currentBrowser = name;
				return true;
			}
		});
	}
	return name === _currentBrowser;
};