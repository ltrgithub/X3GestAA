"use strict";
var utils = require('syracuse-tablet/html/js/helpers/utils');
var log = require('syracuse-tablet/html/js/helpers/logger').log;
var Gadget = require('syracuse-tablet/html/js/application/gadget').Klass;

var _defMetaData = {
	"$isExcluded": false,
	"$isHidden": false,
	"isMandatory": false,
	"$isReadOnly": false,
	"$isDisabled": false
};
/**
 * Property of prototype that contains row index
 */
var _rowIdxProperty = "$ROWIDX";
var _rowIdxProto = null;
/**
 * getFieldNameForValue
 */
var _reg1 = /{[^}]+}/g,
	_reg2 = /[{}]/g;
/**
 * Prototype class
 * 	Provides all the method to deal with prototype
 * 	manage prototype chaining parent -> child
 * !!use Prototype methods instead of dealing directly with JSON
 */
var _Prototype = utils.defineClass(function(json, parent) {
	var self = this;
	self.json = json || {};
	if (typeof self.json == "string") {
		self.json = JSON.parse(self.json);
	}
	self._children = null;
	if (parent) {
		parent._appendChild(self);
		self.parent = parent;
	}
}, null, {
	destroy: function() {
		var self = this;
		self.parent = null;
		self.json = null;
		if (self._children) {
			self.children.forEach(function(c) {
				if (c) c.destroy();
			});
		}
		self._children = null;
	},
	/**
	 * For destroy
	 */
	_appendChild: function(child) {
		var self = this;
		if (!self._children) self._children = [];
		self._children.push(child);
	},
	/**
	 * returns json[prop]
	 */
	data: function(prop, dataContext) {
		var self = this;
		if (!prop || prop.length == 0) return null;
		var val = self.json[prop];
		if (val == null) {
			return self.parent ? self.parent.data(prop) : val;
		}
		return self._getVal(val, dataContext);
	},
	/**
	 * returns JSON for json.$properties[name]
	 * If prop!=null returns json.$properties[name][prop]
	 * dataContext: optional
	 */
	property: function(name, prop, dataContext) {
		var self = this;
		if (!name || name.length === 0) return null;
		var o = self.json.$properties ? self.json.$properties[name] : self.parent ? self.parent.property(name) : null;
		if (!o || !prop) return o;
		return self._getVal(o[prop], dataContext);
	},
	_getVal: function(val, dataContext) {
		if (val && val.indexOf && val.indexOf('{') >= 0) {
			val = utils.parseExpression(val, dataContext, this);
		}
		return val;
	},
	getMetaData: function(name) {
		var self = this;
		if (!self._metaData) self._metaData = {};
		var meta = self._metaData[name];
		if (meta) return meta;
		meta = self._metaData[name] = $.extend({}, _defMetaData, self.property(name));
		return meta;
	},
	localization: function(val) {
		var self = this;
		var loc = self.json.$localization || {};
		return loc[val] ? loc[val] : self.parent ? self.parent.localization(val) : null;
	},
	/**
	 * returns a prototype object for json.$properties[prop] or $item proto for grids
	 */
	getPrototype: function(prop) {
		if (prop === "$item") {
			var json = this.data(prop);
		} else {
			var json = this.property(prop);
		}
		return json ? exports.create($.extend({}, json), this) : null;
	},
	/**
	 * Query prototype
	 */
	isQuery: function() {
		if (this._isQuery != null) return this._isQuery;
		var url = this.data("$url");
		this._isQuery = url && url.smEndsWith("$query") ? true : false;
		return this._isQuery;
	},
	/**
	 * Lookup prototype
	 */
	isLookup: function() {
		if (this._isLookup != null) return this._isLookup;
		var url = this.data("$url");
		this._isLookup = url && url.smEndsWith("$lookup") ? true : false;
		return this._isLookup;
	},
	/**
	 * Format for display a value according to proto description
	 * Temporarily
	 */
	formatDisplay: function(prop, dataContext) {
		var self = this;
		var info = self.property(prop);

	},
	/**
	 * Temporarily - Add our own property - TODO Find another way
	 * 		Add row index in prototype for grids
	 */
	addProperty: function(name, descr) {
		var self = this;
		if (descr && self.json.$properties && !self.json.$properties[name]) {
			self.json.$properties[name] = descr;
		}
	},
	getPropTitle: function(propName) {
		var self = this;
		var prop = self.property(propName);
		return prop && prop.$title ? self._getVal(prop.$title) : "";

	},
	/**
	 * Returns the name of the field that contains the value ($refValue)
	 * 	For std type it returns name
	 * 	For reference type
	 * 		Set $refValue in prototype
	 * 		Set $lookupdescr - I don't remember if it will be used in tablet but I suppose - TODO remove if not used
	 * 		In mobile client this method was called after having loaded the prototype to calculated additionnal information needed by the client
	 */
	getFieldNameForValue: function(name) {
		var self = this;
		var protoField = self.property(name);
		if (!protoField) throw new Error("Field proto expected[" + name + "]");
		var item = protoField.$item;
		if (!item) return name;
		if (item.$refValue) return item.$refValue;
		item.$refValue = name;
		if (item.$value && typeof item.$value == "string") {
			var vals = item.$value.match(_reg1);
			if (vals && vals.length == 1) {
				// In X3 we expect only one param in $values -> "{CUR}"
				// v : must point to key of cd object - { $value:"{F1}", F1:"{F2}"} - F2 must be a field of cd parent
				var f1 = vals[0].replace(_reg2, "").trim();
				if (item.$properties && item.$properties[f1]) {
					// Field/Property that contains the value in data returned selection in lookup list
					item.$lookupvalue = f1;
				}
				if (item[f1]) {
					var f2 = item[f1].replace(_reg2, "").trim();
					if (self.property(f2)) {
						// Field that contains the value in the prototype - Same field in collaboration - Dedicated field in X3 :-(
						item.$refValue = f2;
					} // else field not found in parent keep $$refValue = property
				} // else item  key not found keep $refValue = property
			} else {
				log && log("!!! _getRefenceValue - Only one value is expected");
			}
		}
		// Copied from mobile client - TODO see if still useful
		// Add $lookupdescr which gives the field that contains $description 
		if (item.$description && item.$properties && typeof item.$description == "string") {
			var descrs = item.$description.match(_reg1);
			if (descrs && descrs.length == 1) {
				var fld = descrs[0].replace(_reg2, "").trim();
				if (item.$properties[fld]) {
					item.$lookupdescr = fld;
				}
			}
		}
		return item.$refValue;
	},
	getVignetteGadget: function() {
		var json = this.data("$gadget");
		return json ? new Gadget(json) : null;
	}
});
exports.rowIdxProperty = _rowIdxProperty;
exports.getRowIdxProto = function() {
	if (_rowIdxProto) return _rowIdxProto;
	_rowIdxProto = exports.create({
		$type: "application/x-integer"
	});
};
exports.create = function(json, parent) {
	return new _Prototype(json, parent);
};