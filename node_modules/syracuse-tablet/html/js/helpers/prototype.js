"use strict";
var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("prototype");
var Gadget = require('syracuse-tablet/html/js/application/gadget').Klass;
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');

var _testFacet = /representation=.*\.\$(.*)/;
// Add display info for facet actions - Simplify by adding name.action.$edit... in resources
var _addFacetLink = function(info, facet) {
	info.icon = fontUtils.getIconByName(facet);
	switch (facet) {
		case "$edit":
			info.title = "Edit";
			break;
		case "$query":
			info.title = "List";
			break;
		case "$save":
			info.title = "Save";
			break;
		case "$details":
			info.title = "Detail";
			break;
		case "$delete":
			info.title = "Delete";
			break;
		case "$create":
			info.title = "Create";
			break;
		default:
			log && log("Facet " + facet + " not implemented yet");
			info.title = facet || "???";
			break;
	}
};

var _isOfficeLink = function(name) {
	return name.smStartsWith("$word") || name.smStartsWith("$excel");
};
var _isPaginLink = function(name) {
	return name === "$first" || name === "$previous" || name === "$next" || name === "$last" || name === "$more";
};

var _linksMap = {
	header: {
		smartphone: {
			details: {
				$edit: true,
				$delete: true
			},
			edit: {
				$canceledit: true,
				$save: true
			},
			query: {
				$create: true
			},
			create: {
				$save: true,
				$canceledit: true
			}
		},
		tablet: {}
	},
	footer: {
		smartphone: {},
		tablet: {
			details: {
				$edit: true,
				$delete: true,
				$query: true
			},
			edit: {
				$save: true,
				$canceledit: true
			},
			query: {
				$create: true
			},
			create: {
				$save: true,
				$canceledit: true
			}
		}
	},
	actionpanelparent: {
		tablet: {
			details: {},
			edit: {},
			query: {},
			create: {}
		},
		smartphone: {
			details: {
				$query: true
			},
			edit: {},
			query: {},
			create: {}
		}
	},
	actionpanel: {}
};

/**
 * Property of prototype that contains row index
 */
var _rowIdxProto = null;
/**
 * getFieldNameForValue
 */
var _reg1 = /{[^}]+}/g,
	_reg2 = /[{}]/g;
/**
 * Prototype class
 * 	Provides all the method to deal with prototype
 * 	manage prototype chaining parent -> child
 * !!use Prototype methods instead of dealing directly with JSON
 */
var _Prototype = utils.defineClass(function(json, parent) {
	var self = this;
	self.json = json || {};
	if (typeof self.json == "string") {
		self.json = JSON.parse(self.json);
	}
	self._children = null;
	if (parent) {
		parent._appendChild(self);
		self.parent = parent;
	}
	self.init();
}, null, {
	init: function() {
		var self = this;
		var props = self.json.$properties;
		if (!props) return;
		for (var p in props) {
			if (props[p].$type === "application/x-reference") {
				self.initRefField(props[p], p);
			}
		}
	},
	destroy: function() {
		var self = this;
		// Just set to null
		self.parent = null;
		// Just set to null
		self.json = null;
		if (self._children) {
			self._children.forEach(function(c) {
				if (c) c.destroy();
			});
			self._children = null;
		}
	},
	/**
	 * For destroy
	 */
	_appendChild: function(child) {
		var self = this;
		if (!self._children) self._children = [];
		self._children.push(child);
	},
	/**
	 * returns json[prop]
	 * 	ignoreParent: true -> Don't read property in parent
	 */
	data: function(prop, dataContext, ignoreParent) {
		var self = this;
		if (!prop || prop.length == 0) return null;
		var val = self.json[prop];
		if (val == null) {
			if (ignoreParent == null) {
				if (["$title", "$description"].indexOf(prop) > -1) {
					ignoreParent = true;
				}
			}
			return ignoreParent !== true && self.parent ? self.parent.data(prop) : val;
		}
		return self.resolveExpression(val, dataContext);
	},
	/**
	 * returns JSON for json.$properties[name]
	 * If prop!=null returns json.$properties[name][prop]
	 * dataContext: optional
	 */
	property: function(name, prop, dataContext) {
		var self = this;
		if (!name || name.length === 0) return null;
		var o = self.json.$properties ? self.json.$properties[name] : self.parent ? self.parent.property(name) : null;
		if (!o || !prop) return o;
		return self.resolveExpression(o[prop], dataContext);
	},
	/**
	 * True if the property prop is a x-reference
	 */
	isReference: function(propname) {
		var res;
		if (this._cacheRef != null) {
			res = this._cacheRef[propname];
			if (res != null) return res;
		}
		var p = this.property(propname);
		res = p != null && p.$type === "application/x-reference";
		if (!this._cacheRef) this._cacheRef = {};
		this._cacheRef[propname] = res;
		return res;
	},
	/**
	 * True proto is a x-array
	 */
	isArray: function() {
		return this.json.$type === "application/x-array";
	},
	/**
	 * True proto is a x-array
	 */
	isBlob: function() {
		var t = this.json.$type;
		return t === "image" || t === "application/x-document" || t === "application/x-array";
	},
	/**
	 * Check value and resolve if it's an expression or title otherwise return val
	 * 	dataContext optional (used for expressions other than localization)
	 */
	resolveExpression: function(val, dataContext) {
		if (val && val.indexOf && val.indexOf('{') >= 0) {
			val = utils.parseExpression(val, dataContext, this);
		}
		return val;
	},
	localization: function(val) {
		var self = this;
		var loc = self.json.$localization || {};
		return loc[val] ? loc[val] : self.parent ? self.parent.localization(val) : null;
	},
	/**
	 * returns a prototype object for json.$properties[prop] or $item proto for grids
	 * prop			$items for arrays
	 * 				propertyName for fields
	 * 				path with . as separator of data in other cases (rowDetail)
	 *  override: 	optional - override JSON properties
	 *  			used by row detail to get page prototype from array field proto
	 */
	getPrototype: function(prop, override) {
		var json;
		if (prop.indexOf(".") > 0) {
			json = this.getDataByPath(prop);
		} else if (prop === "$item") {
			json = this.data(prop);
			if (this.isSingleArray(true)) { /** we create a standard proto compliant with multiple columns arrays **/
				var newJson = {
					$properties: {},
					$type: "application/json"
				};
				newJson.$properties[globals.SINGLEARRAYPROP] = json;
				json = newJson;
			}
		} else {
			json = this.property(prop);
		}
		return json ? exports.create($.extend(true, {}, json, override), this) : null;
	},
	/**
	 * Query prototype
	 */
	isQuery: function() {
		return this.isFacet("query");
	},
	/**
	 * Lookup prototype
	 */
	isLookup: function() {
		return this.isFacet("lookup");
	},
	/**
	 * return true if aguments contain the facet
	 * Ex: 	isFacet("edit, "detail") return true if edit OR detail
	 * 		isFacet("detail") return true if detail
	 */
	isFacet: function() {
		if (this._facet == null) {
			var t = _testFacet.exec(this.data("$url"));
			this._facet = t != null && t.length == 2 ? t[1] : "";
		}
		return Array.prototype.indexOf.call(arguments, this._facet) >= 0;
	},
	/**
	 * Format for display a value according to proto description
	 * Temporarily
	 */
	formatDisplay: function(prop, dataContext) {
		var self = this;
		var info = self.property(prop);

	},
	/**
	 * Temporarily - Add our own property - TODO Find another way
	 * 		Add row index in prototype for grids
	 */
	addProperty: function(name, descr) {
		var self = this;
		if (descr && self.json.$properties && !self.json.$properties[name]) {
			self.json.$properties[name] = descr;
		}
	},
	getPropTitle: function(propName) {
		var self = this;
		var prop = self.property(propName);
		return prop && prop.$title ? self.resolveExpression(prop.$title) : "";

	},
	getFacet: function() {
		return this._facet;
	},
	/**
	 * Returns the name of the field that contains the value ($refValue)
	 * 	For std type it returns name
	 * 	For reference type
	 * 		Set $refValue in prototype
	 * 		Set $lookupdescr - I don't remember if it will be used in tablet but I suppose - TODO remove if not used
	 * 		In mobile client this method was called after having loaded the prototype to calculated additionnal information needed by the client
	 */

	getFieldNameForValue: function(name) {
		var protoField = this.property(name);
		var item = protoField && protoField.$item;
		// reference fiels have been initialized at creation of proto object - initRefField
		return item && item.$refValue ? item.$refValue : name;
	},
	/**
	 * TODO - Test with Syracuse entities
	 */
	initRefField: function(protoField, name) {
		var self = this;
		if (!protoField) throw new Error("Field proto expected[" + name + "]");
		var item = protoField.$item;
		if (!item || item.$refValue) return;
		item.$refValue = name;
		if (item.$value && typeof item.$value == "string") {
			var vals = item.$value.match(_reg1);
			if (vals && vals.length == 1) {
				// In X3 we expect only one param in $values -> "{CUR}"
				// v : must point to key of cd object - { $value:"{F1}", F1:"{F2}"} - F2 must be a field of cd parent
				var f1 = vals[0].replace(_reg2, "").trim();
				if (item[f1]) {
					var f2 = item[f1].replace(_reg2, "").trim();
					if (self.property(f2)) {
						// Field that contains the value in the prototype - Same field in collaboration - Dedicated field in X3 :-(
						item.$refValue = f2;
					} // else field not found in parent keep $$refValue = property
				} else {
					item.$refValue = f1; // else item  key not found keep $refValue = property
				}
			} else {
				throw new Error("Prototype.initRefField - Only one value is expected");
			}
		}
		return item.$refValue;
	},
	/**
	 * Retruns the nale of the fiels that contains value/description/title
	 */
	getLookupInfo: function() {
		var res = {};
		var $props = this.json;
		if ($props.$description) {
			res.$description = $props.$description.replace(_reg2, "").trim();
		}
		if ($props.$title) {
			res.$title = $props.$title.replace(_reg2, "").trim();
		}
		if ($props.$value) {
			res.$value = $props.$value.replace(_reg2, "").trim();
		}
		return res;
	},
	/**
	 * return the value of a given path
	 * 	path:	String with/without '.' as separator or array of strings
	 */
	getDataByPath: function(path) {
		return utils.getPropByPath(this.json, path, this);
	},
	getVignetteGadget: function() {
		var json = this.data("$gadget");
		return json ? new Gadget(json) : null;
	},
	/**
	 * Return an array of link info according to toolbar
	 *		toolbar - can be "header", "footer", "actionpanel"
	 * !!! There's a hack in \lib\sdataStatelessHack._js that transform the original proto to put $actions in $links
	 * 		Set a $isAction = true for actions (false for $links)
	 */
	getLinks: function(controllerDao, toolbar, options) {
		var self = this;
		var result = [];
		if (!controllerDao) {
			// controllerDao is needed to calculated links provided by prototye
			// TODO - In the current version ony regular pages (representaion) have a dao
			// So there no $link in dashboards - To add links n dashboard a dao is neededq
			return [];
		}
		options = options || {};

		if (!_linksMap[toolbar]) {
			throw new Error("Unexpected toolbar parameter. Expected 'header', 'footer' or 'actionpanel', received" + toolbar);
		}
		var lMap = _linksMap[toolbar];
		var deviceType = options.deviceType || "tablet";
		if (toolbar !== "actionpanel") {
			lMap = _linksMap[toolbar][deviceType][controllerDao.prototype.getFacet()];
			if (!lMap) throw new Error("No facet set in prototype");
		}

		//  override prototype status with the data ones ($links properties) if exists
		//  !! controllerDao.isChild is true fir child page  -> We don't read parent proto (just $links of the current JSON)
		//     otherwise we display the actions of the parent page in child page
		var $links = $.extend(true, {}, self.data("$links", null, true), controllerDao.getValue("$links"));
		if ($links && !$.isEmptyObject($links)) {
			$.each($links, function(name, value) {
				try {

					// do not consider links that are not allowed for the facet according to the links map
					// validate actionpanel links
					if (toolbar !== "actionpanel" && !lMap[name]) {
						return;
					} else {

						// in case of action panel, do not add facet links. They are added with 'actionpanelparent' if needed
						if (toolbar === "actionpanel" && (name === "$edit" || name === "$create" || name === "$delete" || name === "$details" || name === "$query" || name === "$save" || name === "$canceledit")) {
							return;
						}
					}

					if (value == null || value.$isExcluded === true) {
						return;
					}
					if (value.$type != null && value.$type.length !== 0 && value.$type !== "application/json;vnd.sage=syracuse") {
						return;
					}
					var visible = name.smStartsWith('$');
					if (visible && _isOfficeLink(name)) {
						return;
					}
					/*if (visible && filters.noPagin && _isPaginLink(name)) {
						return;
					}*/

					var info;
					if (value.$url && value.$url.length > 0) {
						var link = sdataUtils.getLinkInfo(value.$url, controllerDao);
						info = $.extend(link, value);
						if (info.$services) {
							/**
							 * $services are considered like actions. $isACtions is not set to true in proto
							 * -> We force true in link info (used to trigger action/navigation) in action manager and side panel actions
							 */
							info.$isAction = true;
						}
					} else {
						// Child page actions - No url
						info = $.extend({}, value);
						// Force notification
						info.$isAction = true;
					}
					info.name = name;

					// add info for action panel links
					if (toolbar === "actionpanel") {
						info.title = self.resolveExpression(value.$title);
						info.icon = "";
					} else {
						_addFacetLink(info, name);
					}

					result.push(info);

				} catch (e) {
					value = value || {};
					// Force console because unexpected
					// We don't want to stop application
					// -> utils.report to force to report error
					log && log("getLinks - invalid link - name:" + name + " - Title: " + self.resolveExpression(value.$title || 'no title') + "\n\t" + (value.$url || 'no url'));
				}
			});
		}
		return result;
	},
	/**
	 * Calculates the prototype and other info for unit field
	 */
	getUnitFieldInfo: function() {
		var self = this;
		var res = {};
		res.$unit = self.data("$unit");
		if (typeof res.$unit == "object") {
			res.unitBindName = "$unit";
			res.unitFieldProto = exports.create($.extend({}, self.$unit));
		} else if (typeof res.$unit == "string") {
			res.unitBindName = res.$unit;
			var parent = self.parent;
			while (parent) {
				var unitProto = parent.property(res.$unit);
				if (unitProto) {
					res.unitFieldProto = exports.create($.extend({}, unitProto));
					break;
				}
				parent = parent.parent;
			}
		}
		return res;
	},

	/**
	 * True if array has one column - Single array
	 * Protocole isn't consistent because there a confusion with x-reference fields
	 * current object is array proto or array.$item proto
	 **/
	isSingleArray: function(noFail) {
		if (this.$singleArray) return this.$singleArray;
		var jsonArray = articleParser.getArrayJsonProto(this);
		if (jsonArray == null && noFail) return false;
		if (jsonArray == null) throw new Error("Unexpected parent array");
		this.$singleArray = articleParser.isSingleArray(jsonArray);
		return this.$singleArray;
	},
	/**
	 * Create a child proto from JSON
	 * Used by example for unknown fields
	 */
	create: function(json) {
		return exports.create($.extend(true, {}, json), this);
	}
});
/**
 * To manage a row index in arrays
 */
exports.getRowIdxProto = function() {
	if (_rowIdxProto) return _rowIdxProto;
	_rowIdxProto = exports.create({
		$type: "application/x-integer"
	});
	return _rowIdxProto;
};
/**
 * Constructor
 */
exports.create = function(json, parent) {
	return new _Prototype(json, parent);
};