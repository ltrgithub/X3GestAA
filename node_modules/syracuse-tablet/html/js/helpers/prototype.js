"use strict";
var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');

/**
 * Return json prototype of an array or null if proto is not an array
 * proto is a prototype object or a JSON object
 * This code is shared with prototype class
 */
var _getArrayJsonProto = function(proto) {
	if (!proto) return null;
	var json;
	if (!$.isPlainObject(proto)) {
		if (proto.isArray()) {
			json = proto.json;
		} else if (proto.parent) {
			json = proto.parent.json;
		}
	} else {
		json = proto;
	}
	if (json == null || json.$type !== "application/x-array") return null;
	return json;
};

var _testFacet = /representation=.*\.\$(\w+)[&]*/;

/**
 * getFieldNameForValue
 */
var _reg1 = /{[^}]+}/g,
	_reg2 = /[{}]/g;
/**
 * Prototype class
 * 	Provides all the method to deal with prototype
 * 	manage prototype chaining parent -> child
 * !!use Prototype methods instead of dealing directly with JSON
 */
var _Prototype = utils.defineClass(function(json, parent) {
	var self = this;
	this.json = json || {};
	if (typeof this.json == "string") {
		this.json = JSON.parse(self.json);
	}
	if (parent) {
		this.parent = parent;
	}
	this.init();
}, null, {
	init: function() {
		var props = this.json.$properties;
		if (!props) return;
		for (var p in props) {
			if (props[p].$type === "application/x-reference") {
				this.initRefField(props[p], p);
			}
		}
	},
	destroy: function() {
		// Just set to null
		this.parent = null;
		// Just set to null
		this.json = null;
	},
	/**
	 * returns json[prop]
	 * 	ignoreParent: true -> Don't read property in parent
	 */
	data: function(prop, dataContext, ignoreParent, noResolve) {
		if (!prop || prop.length == 0) return null;
		var val = this.json[prop];
		if (val == null) {
			if (ignoreParent == null) {
				if (["$title", "$description"].indexOf(prop) > -1) {
					ignoreParent = true;
				}
			}
			var pVal = ignoreParent !== true && this.parent ? this.parent.data(prop, dataContext, null, true) : val;
			if (pVal != null) {
				this.json[prop] = pVal;
			}
			return pVal;
		}
		if (noResolve) {
			return val;
		}
		// #5793 we resolve with searchInParents = true -> expression variable will be searched in dataContext and parent
		return this.resolveExpression(val, dataContext, true);
	},
	/**
	 * returns JSON for json.$properties[name]
	 * If prop!=null returns json.$properties[name][prop]
	 * dataContext: optional
	 */
	property: function(name, prop, dataContext) {
		if (!name || name.length === 0) return null;
		var o = this.json.$properties ? this.json.$properties[name] : this.parent ? this.parent.property(name) : null;
		if (!o || !prop) return o;
		return this.resolveExpression(o[prop], dataContext);
	},
	/**
	 * True if the property prop is a x-reference
	 */
	isReference: function(propname) {
		var res;
		if (this._cacheRef != null) {
			res = this._cacheRef[propname];
			if (res != null) return res;
		}
		var p = this.property(propname);
		res = p != null && p.$type === "application/x-reference";
		if (!this._cacheRef) this._cacheRef = {};
		this._cacheRef[propname] = res;
		return res;
	},
	/**
	 * True proto is a x-array
	 */
	isArray: function() {
		return this.json.$type === "application/x-array";
	},
	/**
	 * True proto is a x-array
	 */
	isBlob: function() {
		var t = this.json.$type;
		return t === "image" || t === "application/x-document" || t === "application/x-array";
	},
	isHidden: function() {
		return this.json.$isHidden === true || false;
	},
	/**
	 * Check value and resolve if it's an expression or title otherwise return val
	 * 	dataContext optional (used for expressions other than localization)
	 */
	resolveExpression: function(val, dataContext, searchInParent, keepPlaceholder) {
		if (val && val.indexOf && val.indexOf('{') >= 0) {
			val = utils.parseExpression(val, dataContext, this, searchInParent, keepPlaceholder);
		}
		return val;
	},
	localization: function(val) {
		var self = this;
		var loc = self.json.$localization || {};
		return loc[val] ? loc[val] : self.parent ? self.parent.localization(val) : null;
	},
	/**
	 * returns a prototype object for json.$properties[prop] or $item proto for grids
	 * prop			$items for arrays
	 * 				propertyName for fields
	 * 				path with . as separator of data in other cases (rowDetail)
	 *  override: 	optional - override JSON properties
	 *  			used by row detail to get page prototype from array field proto
	 *  facet		force facet
	 */
	getPrototype: function(prop, override, facet) {
		var json;
		if (prop.indexOf(".") > 0) {
			json = this.getDataByPath(prop);
		} else if (prop === "$item") {
			json = this.data(prop);
			if (this.isSingleArray(true)) { /** we create a standard proto compliant with multiple columns arrays **/
				var newJson = {
					$properties: {},
					$type: "application/json"
				};
				newJson.$properties[globals.SINGLEARRAYPROP] = json;
				json = newJson;
			}
		} else {
			json = this.property(prop);
		}
		if (!json) return null;
		override = $.extend(true, {}, json, override);
		var proto = exports.create(override, this);
		if (proto.json.$links) {
			Object.keys(proto.json.$links).forEach(function(key) {
				if (key.indexOf("$") != 0 && ((proto.json.$links[key].$url && proto.json.$links[key].$url.indexOf("http") == 0) || proto.json.$links[key].$url === "")) {
					proto.json.$format = proto.json.$format || "$url";
					proto.json.$urlkey = key;
				}
			});

		}
		if (facet) {
			proto._facet = facet;
		}
		return proto;
	},
	/**
	 * Stats prototype
	 */
	isStats: function() {
		return this.isFacet("cube");
	},
	/**
	 * Query prototype
	 */
	isQuery: function() {
		return this.isFacet("query");
	},
	/**
	 * Lookup prototype
	 */
	isLookup: function() {
		return this.isFacet("lookup");
	},
	isQueryLikeFacet: function() {
		return this.isQuery() || this.isLookup() || this.isStats() || this.isRequest();
	},
	isDetails: function() {
		return this.isFacet("details");
	},
	isRequest: function() {
		return this.json.codeRequest != null && this.json.codeRequest.length > 0;
	},
	isStatistics: function() {
		return this.json.codeStat != null && this.json.codeStat.length > 0;
	},
	acceptServerPagination: function() {
		return this.isQuery() || this.isLookup() || this.isRequest();
	},
	/**
	 * return true if aguments contain the facet
	 * Ex: 	isFacet("edit, "detail") return true if edit OR detail
	 * 		isFacet("detail") return true if detail
	 */
	isFacet: function() {
		return Array.prototype.indexOf.call(arguments, this.getFacet()) >= 0;
	},
	/**
	 * Format for display a value according to proto description
	 * Temporarily
	 */
	formatDisplay: function(prop, dataContext) {
		var self = this;
		var info = self.property(prop);

	},
	/**
	 * Temporarily - Add our own property - TODO Find another way
	 * 		Add row index in prototype for grids
	 */
	addProperty: function(name, descr) {
		var self = this;
		if (descr && self.json.$properties && !self.json.$properties[name]) {
			self.json.$properties[name] = descr;
		}
	},
	getPropTitle: function(propName) {
		var self = this;
		var prop = self.property(propName);
		return prop && prop.$title ? self.resolveExpression(prop.$title) : "";

	},
	getUrlLink: function(propName) {
		var prop = this.property(propName, "$links");
		return prop ? prop[this.json.$urlkey] : null;
	},
	getFacet: function() {
		if (this._facet == null) {
			// We read the facet from this -> parent and keep the first one
			// !! do not take the one of root parent 
			var p = this,
				t;
			while (p != null && t == null) {
				if (p.json.$url != null && p.json.$url.trim().length != 0) {
					t = _testFacet.exec(p.json.$url);
					t = t != null && t.length == 2 ? t[1] : null;
				}
				p = p.parent;
			}
			this._facet = t || "";
		}
		return this._facet;
	},
	/**
	 * Returns the name of the field that contains the value ($refValue)
	 * 	For std type it returns name
	 * 	For reference type
	 * 		Set $refValue in prototype
	 * 		Set $lookupdescr - I don't remember if it will be used in tablet but I suppose - TODO remove if not used
	 * 		In mobile client this method was called after having loaded the prototype to calculated additionnal information needed by the client
	 */

	getFieldNameForValue: function(name) {
		var protoField = this.property(name);
		var item = protoField && protoField.$item;
		// reference fiels have been initialized at creation of proto object - initRefField
		return item && item.$refValue ? item.$refValue : name;
	},
	getFieldTypeForValue: function(name) {
		var protoField = this.property(name);
		var item = protoField && protoField.$item;
		// Type of bind field - Same as $type for non reference type and non quantity field
		var type = item && item.$refValueType ? item.$refValueType : null;
		var value = protoField && protoField.$value;
		type = value && value.$type ? value.$type : null;
		return type ? type : protoField.$type;
	},
	/**
	 * TODO - Test with Syracuse entities and X3 test screens
	 */
	initRefField: function(protoField, name) {
		var self = this;
		if (!protoField) throw new Error("Field proto expected[" + name + "]");
		var item = protoField.$item;
		if (!item || item.$refValue) return;
		item.$refValue = item.$lookupValue = name;
		if (item.$value && typeof item.$value == "string") {
			var vals = item.$value.match(_reg1);
			if (vals && vals.length == 1) {
				// In X3 we expect only one param in $values -> "{CUR}"
				// v : must point to key of cd object - { $value:"{F1}", F1:"{F2}"} - F2 must be a field of cd parent
				var f1 = vals[0].replace(_reg2, "").trim();
				// See AQTCRUDM Tabel Diverse -> $value = {CODE} means that value of xref field value is given by the field CODE
				item.$lookupValue = f1;
				if (item[f1]) {
					var f2 = item[f1].replace(_reg2, "").trim();
					if (self.property(f2)) {
						// Field that contains the value in the prototype - Same field in collaboration - Dedicated field in X3 :-(
						item.$refValue = f2;
					} // else field not found in parent keep $$refValue = property
				} else {
					item.$refValue = f1; // else item  key not found keep $refValue = property
				}
			} else {
				throw new Error("Prototype.initRefField - Only one value is expected");
			}
		}
		if (item.$refValue) {
			var p = self.property(item.$refValue);
			if (p && p.$type) {
				item.$refValueType = p.$type;
			}
		}
		return item.$refValue;
	},
	/**
	 * return the value of a given path
	 * 	path:	String with/without '.' as separator or array of strings
	 */
	getDataByPath: function(path) {
		if (!this._cahePath) this._cahePath = {};
		return utils.getPropByPath(this.json, path, this._cahePath);
	},
	getVignetteGadget: function() {
		return this.data("$gadget");
	},
	/**
	 * Calculates the prototype and other info for unit field
	 */
	getUnitFieldInfo: function() {
		var self = this;
		var res = {};
		res.$unit = self.data("$unit");
		if (typeof res.$unit == "object") {
			res.unitBindName = "$unit";
			res.unitFieldProto = exports.create($.extend({}, self.$unit));
		} else if (typeof res.$unit == "string") {
			res.unitBindName = res.$unit;
			var parent = self.parent;
			while (parent) {
				var unitProto = parent.property(res.$unit);
				if (unitProto) {
					res.unitFieldProto = exports.create($.extend({}, unitProto));
					break;
				}
				parent = parent.parent;
			}
		}
		return res;
	},

	/**
	 * True if array has one column - Single array
	 * Protocole isn't consistent because there a confusion with x-reference fields
	 * current object is array proto or array.$item proto
	 * field!=null -> Check field's proto
	 **/
	isSingleArray: function(noFail, field) {
		var jsonArray;
		if (field != null) {
			jsonArray = this.property(field);
		} else {
			if (this.$singleArray) return this.$singleArray;
			jsonArray = _getArrayJsonProto(this);
		}
		if (jsonArray == null && noFail) return false;
		if (jsonArray == null) throw new Error("Unexpected parent array");
		var res = articleParser.isSingleArray(jsonArray);
		if (field != null) {
			// Cache
			this.$singleArray = res;
		}
		return res;
	},
	getPropertyNames: function() {
		var props = this.json.$properties;
		if (props) {
			return Object.keys(props);
		}
		return [];
	},
	getProperties: function(select) {
		var props = this.json.$properties;
		var $properties = [];
		Object.keys(props).forEach(function(v) {
			if (select(props[v], v)) {
				$properties[v] = $.extend(true, {}, props[v], {});
			}
		});
		return $properties;
	},
	/**
	 * Create a child proto from JSON
	 * Used by example for unknown fields
	 */
	create: function(json, notChild) {
		return exports.create($.extend(true, {}, json), notChild === true ? null : this);
	},
	/**
	 * this is the prototype of an array field
	 * return information on columns to display
	 * $bindValue is the field that contains the value - For non-refrence bindValue = $bind
	 */
	arrayTableGetColInfo: function() {
		var base = {
			$title: "",
			$titleOrig: "", // title not resolved
			$type: "",
			$bind: "",
			$widthType: "auto",
			$imgHeight: "small",
			$widthVal: 0,
			$capabilities: ""
		};
		var res = [];
		if (this.isSingleArray()) {
			var prop = this.getDataByPath("$item");
			var p = $.extend({}, base, prop);
			p.$title = this.resolveExpression(this.$title);
			p.$titleOrig = this.$title;
			p.$bind = globals.SINGLEARRAYPROP;
			res.push(p);
		} else {
			var props = this.getDataByPath("$item.$properties");
			if (!props) return null;
			var prop;
			var self = this;
			var itemProto = this.getPrototype("$item");
			Object.keys(props).forEach(function(key) {
				prop = props[key];
				// #6792  we exclude hidden columns because the protocol doesn't allow to sho/hide columns - hidden means excluded
				if (prop.$isHidden !== true && prop.$isExcluded !== true && (globals.EXCLUDEFIELDS.indexOf(key) < 0)) {
					var p = $.extend({}, base, prop);
					p.$title = self.resolveExpression(prop.$title);
					p.$titleOrig = prop.$title;
					// Bind field - Ex SITE_REF
					p.$bind = key;
					// Name of the field that contains the value - !=$bind for non reference fields - Ex For SITE_REF -> SITE
					p.$bindValue = itemProto.getFieldNameForValue(key);
					// Type of the field that contains the value - !=$type for non reference fields - Ex For SITE -> "application/x-string"
					p.$bindType = itemProto.getFieldTypeForValue(key);
					res.push(p);
				}
			});
		}
		return res;
	},
	chartGetMeasureInfo: function() {
		var res = {}, prop;
		var props = this.getDataByPath("$item.$properties");
		var measures = this.getDataByPath("$cube.$measures");
		Object.keys(measures).forEach(function(key) {
			prop = props[key];
			prop.$bind = key;
			res[key] = prop;
		});
		return res;
	},
	chartGetNbMeasures: function() {
		var res = 0;
		var measures = this.getDataByPath("$cube.$measures");
		Object.keys(measures).forEach(function(key) {
			res++;
		});
		return res;
	},
	getRepDotFacet: function() {
		var self = this;
		return self.data("$type").split(".").slice(-2).join(".");
	},
	isValid: function() {
		return this.json != null;
	},
	getLayoutCategoriesTitle: function() {
		var title = [];
		var uniqTitle = {};
		var self = this;

		function _walk($layout) {
			if (!$layout)
				return;
			$layout.$items.forEach(function(item) {
				var tit = {};
				if (item.$title && !uniqTitle[item.$title]) {
					uniqTitle[item.$title] = {};
					tit.value = item.$title;
					tit.title = self.resolveExpression(item.$title);
					title.push(tit);
				}
				_walk(item.$layout);
			});
			return title;
		};
		_walk(this.getDataByPath("$article.$layout"));
		return title;
	},
	getAllX3Title: function() {
		var title = [],
			self = this,
			localization = self.json.$localization || {};
		Object.keys(localization).forEach(function(key) {
			var tit = {};
			tit.value = "{" + key + "}";
			tit.title = localization[key];
			title.push(tit);
		});
		return title.sort(function(a, b) {
			var aTit = a.title.toLowerCase();
			var bTit = b.title.toLowerCase();
			return ((aTit < bTit) ? -1 : ((aTit > bTit) ? 1 : 0));
		});
	}
});
/**
 * To manage a row index in arrays
 */
exports.getRowIdxProto = function() {
	return exports.create({
		$type: "tablet/x-row-index"
	});
};
/**
 * Constructor
 */
exports.create = function(json, parent) {
	return new _Prototype(json, parent);
};