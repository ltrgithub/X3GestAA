"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/pages/page').Page;
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var modalMultiButtons = require('syracuse-tablet/html/js/ui/modals/modalMultiButtons');
var mobileDetect = require('syracuse-tablet/html/js/helpers/mobileDetect');

var _Page = utils.defineClass(

	function DashboardPage($parent, state, prototype, article, options, views) {
		if (options.breadcrumbs == null) options.breadcrumbs = true;
		Base.call(this, $parent, state, prototype, article, options, views);
		this.vignettes = [];
		this._vignettesLoaderStates = [];
		var app = globals.getApplication();
		if (app.dao.isSageApplication() && this.state.dashboardName === app.dao.getHomeDashboardName()) {
			this.$$contentElmt.addClass(app.dao.getAppBackGroundClass());
		}
		this._nbCharts = 0;
		this._editModeVignettes = null;
	}, Base, {

		destroy: function() {
			if (this.destroyed) return;
			Base.prototype.destroy.call(this);
			this._editModeVignettes = null;
			this.vignettes = null;
			this._vignettesLoaderStates = null;
		},

		loadData: function(loadOptions) {
			return null;
		},
		reload: function(options) {
			this.vignettes = [];
			return Base.prototype.reload.call(this, options);
		},
		beforeAddContent: function() {
			// #5583 - disabled rendering of title because redundant with header title
		},

		addControl: function(c) {
			Base.prototype.addControl.call(this, c);
			if (c && c.isVignette && c.isVignette()) {
				this.vignettes.push(c);
			}
		},
		afterRender: function(loadOptions, buildOpts) {
			var self = this;
			return Base.prototype.afterRender.call(self, loadOptions, buildOpts).then(function() {
				if (self.vignettes == null || self.vignettes.length == 0) return;
				var vignetteNum = 0;
				var dashName = self.prototype.data("$dashboardName");
				var join = $.Deferred();
				// If authoring is active we wait until all vignettes are loaded (needed by the ui)
				loadOptions.forceSynchroVignettes = globals.isAuthoringActive() || loadOptions.forceSynchroVignettes;
				setTimeout(function() {
					if (self.destroyed || !self.vignettes) return;
					self.vignettes.forEach(function(v) {
						vignetteNum++;
						// Load all async and maybe join at the end
						var vignetteId = dashName + "#" + vignetteNum;
						// Context to restore if any - see getRestoredContext
						var restoredState = self.state.options.vignettesPageStates && self.state.options.vignettesPageStates[vignetteId];
						var pageOptions = restoredState || {};
						pageOptions.sdataParameters = self.state.options && self.state.options.sdataParameters || {};
						var vLoadOptions = {
							updateLayout: loadOptions.updateLayout === true
						};
						v.load(vignetteId, pageOptions, vLoadOptions).then(function(page, error) {
							self._checkVignetteLoadError(error);
							if (vignetteNum === self.vignettes.length) {
								join.resolve();
							}
							if (page && page.nbCharts != null) {
								//#6974 Fix svg issue in chrome - see countChartLoaded
								self.nbCharts += page.nbCharts;
							}
							if (page && page.isEditMode && page.isEditMode()) {
								if (!self._editModeVignettes) {
									self._editModeVignettes = [];
								}
								self._editModeVignettes.push(page);
							}
							return page;
						});
					});
				});
				if (loadOptions.forceSynchroVignettes === true) {
					// Wait until all vignettes have been loaded
					return join.promise();
				} else {
					// DOn't wait so user can navigate without having to wait
					return $.smResolve();
				}
			});
		},

		/*
		 * Called once a vignette has been loaded
		 * Once all vignettes are loaded, we check if there was an error we need to handle globally
		 */
		_checkVignetteLoadError: function(error) {
			var self = this;
			if (!self.vignettes || !self._vignettesLoaderStates) {
				// dashboard could have been destroyed when afterRender is called
				return;
			}
			self._vignettesLoaderStates.push({
				error: error
			});
			// We got a state from all vignettes that are pending to load
			if (self._vignettesLoaderStates.length === this.vignettes.length) {
				// Check if we went offline
				var goLogin = false;
				var e;
				self._vignettesLoaderStates.some(function(s) {
					if (s.error && s.error.$redirectPage === "login") {
						e = s.error;
						return true;
					}
				});
				self._vignettesLoaderStates = [];
				if (e) {
					modal.error(locale.text("error.page.loading"), e, function() {
						globals.getApplication().gotoLogin(locale.text("login.timeout.message"));
					});
				}
			}
		},
		onMainPageResize: function(info, orientation, deviceType) {
			Base.prototype.onMainPageResize.call(this, info, orientation, deviceType);
			//#6974 Fix svg issue in chrome - see countChartLoaded
			this._chartsCounter = 0;
			/**
			 * We need to load the vignettes after having resized the main page
			 * otherwise we load page which is nested in the vignette two times, onMainPageResize and after the vignette has been loaded (asynch)
			 * If we load vignette here we make sure that onMainPageResize resizes only the vignette (not the nested page)
			 * Nested page will be resized after having been loaded
			 */
			this.vignettes.forEach(function(v) {
				v.onMainPageResize(info, orientation, deviceType);
			});
		},
		/** 
		 * #6974 Fix svg issue in chrome
		 * Chrome displays partially the charts in test hub dahsborad when we change the orientation
		 * It's a bug is due to svg engine in chrome
		 * We force to create a link tag in header and just remove it to trigger a redraw of svg object after having loaded all the charts
		 * Calling the svg forceRedraw method or modifying the chart or svg dom attribute/style has no effect
		 * This trick solves the bug :-(
		 */
		countChartLoaded: function(chart) {
			if (this._chartsCounter == null || !globals.getCurrentPage().isDashboard("hub") || !mobileDetect.checkBrowserName("chrome")) return;
			this._chartsCounter++;
			if (this._chartsCounter === this.nbCharts) {
				if (!this._$$fakeLink) {
					this._$$fakeLink = $('<link rel="stylesheet" type="text/css">');
				}
				this._$$fakeLink.appendTo($("head")).detach();
				this._chartsCounter = null;
			}
		},
		authUpdateLayout: function(article, vignetteToUpdt) {
			// Set new article which comes from authoring panel
			this.article = article;
			if (vignetteToUpdt) {
				return vignetteToUpdt.reloadPage({
					updateLayout: true,
					authoringUpdate: true
				});
			}
			this.vignettes = [];
			return Base.prototype.authUpdateLayout.call(this, article);
		},
		/**
		 * Context to store when dashboard is destroyed
		 * We save the context for each vignette (scroll, selection....)
		 * Context of the vignette will be retrieved with the index which is the identifier
		 * Vignette id is recalculated at creation and changes each time the vignette is loaded
		 * type	back/link - Used to manage the content according to the type
		 */
		savedCtxCreate: function(type) {
			var ctx = Base.prototype.savedCtxCreate.call(this, type);
			ctx.vignettes = [];
			var p;
			this.vignettes && this.vignettes.forEach(function(v) {
				p = v.getPage();
				// We store a context even if p == null - Vignette can be destroyed before the end of load process and we must preserve the index in vignette array
				// Vignette is identified by its index
				ctx.vignettes.push(p ? p.savedCtxCreate(type) : null);
			});
			if (this.isDashboard("hub") && this.rootLayout) {
				// Store the scroll of hub layout
				ctx.hubCtx = this.rootLayout.savedCtxCreate(type);
			}
			return ctx;
		},
		/**
		 * Restore the context for the dashboard (not for the vignette)
		 */
		savedCtxRestore: function(ctx) {
			// Std restore for all page
			Base.prototype.savedCtxRestore.call(this, ctx);
			// store vignettes context
			this._savedVignetteContext = ctx.vignettes;
			if (ctx.hubCtx && this.isDashboard("hub")) {
				// Restore the scroll of hub layout
				this.rootLayout.savedCtxRestore(ctx.hubCtx);
			}
		},
		/**
		 * Returns the context of a vignette v
		 * Called by the vignette  -Vignettes contexts is stored in dashboard context
		 */
		getSavedCtxVignette: function(v) {
			if (v == null || this._savedVignetteContext == null) return null;
			var idx = this.vignettes.indexOf(v);
			if (idx == -1 || idx > this._savedVignetteContext.length - 1) return null;
			return this._savedVignetteContext[idx];
		},
		getPinPageId: function() {
			var self = this;
			return self.state.dashboardName + "_" + JSON.stringify(self.state.options.sdataParameters);
		},
		_sdataParam2String: function() {
			var self = this;
			var params;
			if (self.state.options.sdataParameters) {
				Object.keys(self.state.options.sdataParameters).forEach(function(key) {
					var opt = key + "=" + self.state.options.sdataParameters[key];
					if (params) {
						params += "&" + opt;
					} else {
						params = opt;
					}
				});
			};
			return params;
		},
		getPinPageData: function() {
			var pageData = Base.prototype.getPinPageData.call(this);
			pageData.dashboardName = this.state.dashboardName;
			// See vignetteBase - Used to set the application icon if isAppHomePage = true
			pageData.$type = this.state.options && this.isAppHomePage() === true ? "$application" : "$dashboard";
			// sdataParameters is serialized to put in a link
			pageData.sdataParameters = this._sdataParam2String(); // In case of a filtered dashboard, may be null
			pageData.endpoint = globals.getEndpoint();
			return pageData;
		},
		/**
		 * Returns an object that allows the application to reopen the page
		 * reason: nativeAppClosing, pinPage, sharedLink...
		 */
		getRestoreContext: function(reason) {
			var ctx = Base.prototype.getRestoreContext.call(this, reason);
			if (this.state.options.sdataParameters) {
				// Not serialized
				ctx.currentState.options["sdataParameters"] = this.state.options.sdataParameters;
			}
			// If there are edit/create facets in the dashboard we save the context
			if (!this.vignettes) return;
			var vStates = ctx.currentState.options.vignettesPageStates;
			this.vignettes.forEach(function(v) {
				var p = v.getPage();
				if (p) {
					var state = p.getRestoreContext(reason);
					if (!state.currentState || !state.currentState.options) return;
					if (!vStates) {
						vStates = ctx.currentState.options.vignettesPageStates = {};
					}
					vStates[v.vignetteId] = state.currentState.options;
				}
			});
			return ctx;
		},
		/**
		 * typeDashboard = hub / stack / undefined
		 */
		isDashboard: function(typeDashboard) {
			return typeDashboard && this.article ? this.article.$layoutType === typeDashboard : true;
		},
		getGestureMgr: function() {
			return this.isDashboard("hub") && this.rootLayout ? this.rootLayout.getGestureMgr() : Base.prototype.getGestureMgr.call(this);
		},
		getScrollOffset: function() {
			var offset = globals.getApplication().getScrollOffset();
			if (this.isDashboard("hub") && this.getGestureMgr()) {
				var o = this.getGestureMgr().getOffset();
				// Application content can be scrolled (native in authoring)
				offset.top += o.top;
				offset.left += o.left;
				return o;
			} else {
				// No offset
				return offset;
			}
		},
		/**
		 * Return a boolean or promise
		 */
		checkBack: function() {
			if (!this._editModeVignettes || this._editModeVignettes.length == 0) {
				return Base.prototype.checkBack.call(this);
			}
			if (this._editModeVignettes.length === 1) {
				// If there's only one page in edit mode this is this page that manages the chekBack
				return this._editModeVignettes[0].checkBack();
			} else {
				// If there are more than one pages in edit mode we check the global dirty
				// No draft management - User have to activate the vignette and clcik cancel
				var isDirty = this._editModeVignettes.some(function(page) {
					return page && page.dao && page.dao.isDirty;
				});
				if (!isDirty) return true;
				return this.askDiscardChanges();
			}
		},
		/**
		 * Returns a wich resolves with true to discard and false to stay on the current page
		 */
		askDiscardChanges: function() {
			var opts = {
				buttons: [],
				defaultAction: "no"
			};
			// Buttons displayed in dialog
			["no", "yes"].forEach(function(act) {
				opts.buttons.push({
					action: act,
					label: locale.text(act)
				});
			});
			return new modalMultiButtons.Modal(locale.text("dashboard.discardchanges.title"), locale.text("dashboard.discardchanges.info"), opts).show().then(function(result) {
				return result === "yes";
			});

		},
		/**
		 * Scroll handled by hub
		 */
		scrollAllowed: function() {
			return !this.isDashboard("hub");
		}
	});

exports.Page = _Page;