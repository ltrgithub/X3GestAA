"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/pages/page').Page;
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');

var _Page = utils.defineClass(

	function DashboardPage($parent, state, prototype, article, options) {
		Base.call(this, $parent, state, prototype, article, options);
		this.vignettes = [];
		this._vignettesLoaderStates = [];
		this.cacheNotify = true;
		var app = globals.getApplication();
		if (app.dao.isSageApplication() && this.state.dashboardName === app.dao.getHomeDashboardName()) {
			this.$$contentElmt.addClass(app.dao.getAppBackGroundClass());
		}
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			this.vignettes = null;
		},

		loadData: function() {
			this.cacheNotify = true;
			return null;
		},

		beforeAddContent: function() {
			// #5583 - disabled rendering of title because redundant with header title
		},

		addControl: function(c) {
			Base.prototype.addControl.call(this, c);
			if (c && c.isVignette && c.isVignette()) {
				this.vignettes.push(c);
			}
		},
		afterRender: function(updateLayout, buildOpts) {
			var self = this;
			Base.prototype.afterRender.call(this, updateLayout, buildOpts);
			// Empty dashboard
			if (!this.vignettes || this.vignettes.length < 1) {
				// Todo, better check in another way
				//this.renderEmptyDashboardMessage();
			} else {
				var vignetteNum = 0;
				var dashName = self.prototype.data("$dashboardName");
				var join = [];

				this.vignettes.forEach(function(v) {
					var options = {
						sdataParameters: self.state.options && self.state.options.sdataParameters || {},
						vignetteName: dashName + "#" + vignetteNum
					};
					vignetteNum++;
					var loadPromise = v.load(null, options).then(function(page, error) {
						self._checkVignetteLoadError(error);
						return page;
					});
					join.push(loadPromise);
				});

				// In case authoring is active, we wait until all vignettes are loaded
				// If it's non authoring, just let them load async
				if (globals.isAuthoringActive()) {
					return $.smForEachPromise(join, function(loader) {
						return loader;
					});
				}
			}
		},

		/*
		 * Called once a vignette has been loaded
		 * Once all vignettes are loaded, we check if there was an error we need to handle globally
		 */
		_checkVignetteLoadError: function(error) {
			var self = this;
			self._vignettesLoaderStates.push({
				error: error
			});
			// We got a state from all vignettes that are pending to load
			if (self._vignettesLoaderStates.length === this.vignettes.length) {
				// Check if we went offline
				var goLogin = false;
				var e;
				self._vignettesLoaderStates.some(function(s) {
					if (s.error && s.error.$redirectPage === "login") {
						e = s.error;
						return true;
					}
				});
				self._vignettesLoaderStates = [];
				if (e) {
					modal.error(locale.text("error.page.loading", ""), e, function() {
						globals.getApplication().gotoLogin(locale.text("login.timeout.message"));
					});
				}
			}
		},
		onMainPageResize: function(info, orientation, deviceClass) {
			Base.prototype.onMainPageResize.call(this, info, orientation, deviceClass);
			/**
			 * We need to load the vignettes after having resized the main page
			 * otherwise we load page which is nested in the vignette two times, onMainPageResize and after the vignette has been loaded (asynch)
			 * If we load vignette here we make sure that onMainPageResize resizes only the vignette (not the nested page)
			 * Nested page will be resized after having been loaded
			 */
			this.vignettes.forEach(function(v) {
				v.onMainPageResize(info, orientation, deviceClass);
			});
		},

		authUpdateLayout: function(article) {
			this.vignettes = [];
			return Base.prototype.authUpdateLayout.call(this, article);
		},
		/**
		 * Context to store when dashboard is destroyed
		 * We save the context for each vignette (scroll, selection....)
		 * Context of the vignette will be retrieved with the index which is the identifier
		 * Vignette id is recalculated at creation and changes each time the vignette is loaded
		 */
		savedCtxCreate: function() {
			var ctx = Base.prototype.savedCtxCreate.call(this);
			ctx.vignettes = [];
			var p;
			this.vignettes && this.vignettes.forEach(function(v) {
				p = v.getPage();
				// We store a context even if p == null - Vignette can be destroyed before the end of load process and we must preserve the index in vignette array
				// Vignette is identified by its index
				ctx.vignettes.push(p ? p.savedCtxCreate() : null);
			});
			if (this.isHubLayout()) {
				// Store the scroll of hub layout
				ctx.hubCtx = this.rootLayout.savedCtxCreate();
			}
			return ctx;
		},
		/**
		 * Restore the context for the dashboard (not for the vignette)
		 */
		savedCtxRestore: function(ctx) {
			// Std restore for all page
			Base.prototype.savedCtxRestore.call(this, ctx);
			// store vignettes context
			this._savedVignetteContext = ctx.vignettes;
			if (ctx.hubCtx && this.isHubLayout()) {
				// Restore the scroll of hub layout
				this.rootLayout.savedCtxRestore(ctx.hubCtx);
			}
		},
		/**
		 * Returns the context of a vignette v
		 * Called by the vignette
		 */
		savedCtxVignette: function(v) {
			if (v == null || this._savedVignetteContext == null) return null;
			var idx = this.vignettes.indexOf(v);
			if (idx == -1 || idx > this._savedVignetteContext.length - 1) return null;
			return {
				current: this._savedVignetteContext[idx]
			};
		},

		renderEmptyDashboardMessage: function() {
			var text;
			if (this.state.isWelcomePage) {
				text = locale.text("dashboard.welcome.empty");
			} else {
				text = locale.text("dashboard.all.empty");
			}

			this.rootLayout.$$elmt.prepend('<div class="s-m-dashboard-msg-empty">' + text + "</div>");
		},
		getPinPageId: function() {
			var self = this;
			return self.state.dashboardName + "_" + JSON.stringify(self.state.options.sdataParameters);
		},
		getPinPageData: function() {
			var self = this;
			var params;
			if (self.state.options.sdataParameters) {
				Object.keys(self.state.options.sdataParameters).forEach(function(key) {
					var opt = key + "=" + self.state.options.sdataParameters[key];
					if (params) {
						params += "&" + opt;
					} else {
						params = opt;
					}
				});
			}
			var pageData = Base.prototype.getPinPageData.call(self);
			pageData.dashboardName = self.state.dashboardName;
			pageData.sdataParameters = params; // In case of a filtered dashboard, may be null
			return pageData;
		},

		cachedDataNotification: function(message) {
			if (this.cacheNotify === true) {
				globals.getModal().notify(message);
				this.cacheNotify = false;
			}
		},
		isHubLayout: function() {
			return this.rootLayout && this.rootLayout.$type === "hub";
		},
		getGestureMgr: function() {
			return this.isHubLayout() ? this.rootLayout.getGestureMgr() : Base.prototype.getGestureMgr.call(this);
		},
		getScrollOffset: function() {
			var offset = globals.getApplication().getScrollOffset();
			if (this.isHubLayout() && this.getGestureMgr()) {
				var o = this.getGestureMgr().getOffset();
				// Application content can be scrolled (native in authoring)
				offset.top += o.top;
				offset.left += o.left;
				return o;
			} else {
				// No offset
				return offset;
			}
		}
	});

exports.Page = _Page;