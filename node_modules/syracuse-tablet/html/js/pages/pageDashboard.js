"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/pages/page').Page;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("page");
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _Page = utils.defineClass(

	function DashboardPage($parent, state, prototype, article) {
		var self = this;
		Base.call(self, $parent, state, prototype, article);
		self.vignettes = [];
	}, Base, {

		destroy: function() {
			var self = this;
			Base.prototype.destroy.call(self);
			self.vignettes = null;
		},

		loadData: function() {
			return null;
		},

		beforeAddContent: function() {
			var self = this;
			self.addTitle(self.prototype.data("$title"), self.prototype.data("$description"));
		},

		addControl: function(c, isPageControl) {
			var self = this;
			Base.prototype.addControl.call(self, c, isPageControl);
			if (c && c.isVignette()) {
				self.vignettes.push(c);
			}
		},

		afterRender: function(options) {
			var self = this;
			// Empty dashboard
			if (!self.vignettes || self.vignettes.length < 1) {
				self.renderEmptyDashboardMessage();
			}
			return Base.prototype.afterRender.call(self, options);
		},

		/**
		 * Scan vignettes to find control per id
		 * 	Allows to call ctrl actions in vignettes
		 * ctrlId is a unicid for all controls of all pages
		 */
		findVignetteControl: function(ctrlId) {
			var self = this;
			if (!self.vignettes) return null;
			var c, v;
			for (var i = 0; i < self.vignettes.length; i++) {
				v = self.vignettes[i];
				c = v.getPageControl(ctrlId);
				if (c) {
					return {
						control: c,
						vignette: v
					};
				}
			}
			return null;
		},
		/**
		 * Scan vignettes to find page per id
		 */
		findVignettePage: function(pageId) {
			var self = this;
			if (!self.vignettes) return null;
			for (var i = 0, v; i < self.vignettes.length; i++) {
				v = self.vignettes[i];
				if (v.getPage() && v.getPage().id === pageId) {
					return {
						page: v.getPage(),
						vignette: v
					};
				}
			}
			return null;
		},

		onMainPageResize: function(info, orientation, deviceClass) {
			var self = this;
			Base.prototype.onMainPageResize.call(self, info, orientation, deviceClass);
			/**
			 * We need to load the vignettes after having resized the main page
			 * otherwise we load page which is nested in the vignette two times, onMainPageResize and after the vignette has been loaded (asynch)
			 * If we load vignette here we make sure that onMainPageResize resizes only the vignette (not the nested page)
			 * Nested page will be resized after having been loaded
			 */
			self.vignettes.forEach(function(v) {
				var options = {
					sdataParameters: self.state.options && self.state.options.sdataParameters || {}
				};
				v.load(null, options);
			});
		},
		updateLayout: function(article) {
			var self = this;
			self.vignettes = [];
			return Base.prototype.updateLayout.call(self, article);
		},
		/**
		 * Context to store when dashboard is destroyed
		 * We save the context for each vignette (scroll, selection....)
		 * Context of the vignette will be retrieved with the index which is the identifier
		 * Vignette id is recalculated at creation and changes each time the vignette is loaded
		 */
		savedCtxCreate: function() {
			var self = this;
			var ctx = Base.prototype.savedCtxCreate.call(self);
			ctx.vignettes = [];
			var p;
			self.vignettes && self.vignettes.forEach(function(v) {
				p = v.getPage();
				// We store a context even if p == null - Vignette can be destroyed before the end of load process and we must preserve the index in vignette array
				// Vignette is identified by its index
				ctx.vignettes.push(p ? p.savedCtxCreate() : null);
			});
			if (this.rootLayout && this.rootLayout.getGestureMgr()) {
				// Store the scroll of hub layout
				ctx.hubScroll = this.rootLayout.getGestureMgr().savedCtxCreate();
			}
			return ctx;
		},
		/**
		 * Restore the context for the dashboard (not for the vignette)
		 */
		savedCtxRestore: function(ctx) {
			// Std restore for all page
			Base.prototype.savedCtxRestore.call(this, ctx);
			// store vignettes context
			this._savedVignetteContext = ctx.vignettes;
			if (ctx.hubScroll && this.rootLayout && this.rootLayout.getGestureMgr()) {
				// Restore the scroll of hub layout
				this.rootLayout.getGestureMgr().savedCtxRestore(ctx.hubScroll);
			}
		},
		/**
		 * Returns the context of a vignette v
		 * Called by the vignette
		 */
		savedCtxVignette: function(v) {
			var self = this;
			if (v == null || this._savedVignetteContext == null) return null;
			var idx = self.vignettes.indexOf(v);
			if (idx == -1 || idx > this._savedVignetteContext.length - 1) return null;
			return {
				current: this._savedVignetteContext[idx]
			};
		},

		renderEmptyDashboardMessage: function() {
			var self = this;
			var text;
			if (self.state.isWelcomePage) {
				text = locale.text("dashboard.welcome.empty");
			} else {
				text = locale.text("dashboard.all.empty");
			}

			self.rootLayout.$$elmt.prepend('<div class="s-m-dashboard-msg-empty">' + text + "</div>");
		}

	});

exports.Page = _Page;