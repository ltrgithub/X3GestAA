"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalMultiButtons = require('syracuse-tablet/html/js/ui/modals/modalMultiButtons');
var modalSaveDraft = require('syracuse-tablet/html/js/ui/modals/modalSaveDraft');

/**
 * Manages the drafts process in pageRegular
 * 		Asks user to save the draft on back/cancel page.chekBack
 * 		Load the draft from DB in page.loadData process
 */
var _DraftMgr = function(page) {
	this._page = page;
	this._draftStatus = null;

	this.destroy = function() {
		this._page = null;
	};
	/**
	 * Return a promise or a boolean (true to continue back process)
	 * forcePromise: true force top return a promise
	 * Ask user to save the draft or to remove an offline draft
	 */
	this.checkBack = function(forcePromise) {
		var self = this;
		if (self._offlineDraftId) {
			//  Ask user to remove offline draft which has been created automatically on connection error
			return self.offlineDraftAskRemove();
		}
		//  No modification in dao - skip checkBack
		if (!self._page.dao || !self._page.dao.isDirty) {
			return forcePromise ? $.smResolve(true) : true;
		}
		//  Ask user to discard changes or save as draft
		return self.askSaveDraft();
	};
	/**
	 * Ask user to discard changes or save as draft
	 * Resolves with true if save has been skipped or succeeded
	 * Resolves false if user canceled the operation
	 */
	this.askSaveDraft = function() {
		var self = this;
		var opts = {
			buttons: [],
			defaultAction: "no"
		};
		// Buttons displayed in dialog
		["drafts.dlog.savedraft.button", "no", "yes"].forEach(function(act) {
			opts.buttons.push({
				action: act,
				label: locale.text(act)
			});
		});
		// Id of label is taken as action id for convenience
		var modal = new modalMultiButtons.Modal(locale.text("drafts.dlog.savedraft.title"), locale.text("drafts.dlog.savedraft.info"), opts);
		return modal.show().then(function(result) {
			if (result === "drafts.dlog.savedraft.button") {
				return self.save(false).then(function(saved, draftCtx) {
					// back is allowed if no error otherwise we need to save again and say no is error is persisting
					return saved === true;
				});
			} else {
				return result !== "no";
			}
		});
	};
	/**
	 * Ask user to input a comment and save/cancel action
	 * offline: true if user is asked to save an offline draft
	 * Resolve with true/false and draft context
	 */
	this.save = function(offline) {
		var self = this;
		var deferred = $.Deferred();
		var modal = new modalSaveDraft.Modal(self._comment || "", offline === true);
		modal.show().then(function(result) {
			result = result || {};
			if (result.action !== "save") {
				deferred.resolve(false, null);
				return;
			}
			self.saveInDB(result.comment, offline).then(function(ctx) {
				globals.getModal().notify({
					severityClass: "success",
					title: locale.text("drafts.notify.saved")
				});
				deferred.resolve(true, ctx);
			}).fail(function(e) {
				globals.getModal().error(locale.text("drafts.error.saving"), e, function() {
					deferred.resolve(false, null);
				});
			});
		});
		return deferred.promise();
	};
	/**
	 *Save draft in DB
	 */
	this.saveInDB = function(comment, offline) {
		var self = this;
		var uuid = jsutils.getPropByPath(self._page, "dao.data.$uuid");
		if (!uuid) {
			return $.smReject("Unexpected null uuid");
		}
		var restoredCtx = self._page.getRestoreContext();
		restoredCtx.currentState.options["workingCopy-Id"] = null;
		restoredCtx.currentState.options["draft-id"] = uuid;
		if (!self._draftSaveLink) {
			var links = self._page.getProtoLinks();
			Object.keys(links).some(function(key) {
				if (key === "$save") {
					self._draftSaveLink = links[key];
					return true;
				}
			});
		}
		if (!self._draftSaveLink) {
			return $.smReject("Unexpected $save link not found in prototype");
		}
		var draftContext = {
			"id": uuid,
			"endpoint": globals.getEndpoint(),
			"representation": self._page.prototype.data("$representation"),
			"status": offline ? "offline" : self._draftStatus || "unsavedchanges",
			"title": self._page.prototype.data("$title") || "",
			"comment": comment || "",
			"restoredContext": restoredCtx,
			"dataSet": self._page.dao.data,
			"saveLink": self._draftSaveLink,
			"creation_date": utils.getCurISODateTime(new Date())
		};
		return globals.getStorage().draftOperation("draftSave", draftContext);
	};
	/**
	 * New data loaded in parent's page
	 */
	this.notifDataLoaded = function(loadOption, loadedFrom) {
		// No need to wait the promise
		this.offlineDraftRemove();
		if (loadedFrom === "draft") {
			// If data is loaded from a draft we force dirty in order to ask user for saving the draft even if dao hasn't been modified
			this._page.dao.setDirty();
			// Remove the draft id - A new one will be created if the form is saved again or reloaded
			this._page.state.options["draft-id"] = null;
		}
		this._draftStatus = null;
	};
	/**
	 * Save action succeeded in parent's page
	 */
	this.notifSaveSucceeded = function() {
		// No need to wait the promise
		this.offlineDraftRemove();

	};
	/**
	 * Save action failed in parent's page
	 */
	this.notifSaveFailed = function(result) {
		var self = this;
		if (result.responseJSON.$noConnectionError === true) {
			/**
			 * No connection - we save the draft and keep the id to ask user to remove it when he/she will exit the page
			 */
			if (self._offlineDraftId) {
				// draft already saved
				return;
			}
			self.save(true).then(function(saved, draftCtx) {
				if (saved) {
					self._offlineDraftId = draftCtx.uuid;
					// To not be prompt if we exit (back) or cancel edit
					self._page.dao.resetDirty();
					// Store the comment to recall it (see checkBack with _offlineDraftId)
					self._comment = draftCtx.comment;
				} else {
					self._offlineDraftId = null;
					self._comment = null;
				}
			});
			return;
		}
		// No need to wait the promise
		self.offlineDraftRemove();
		self._draftStatus = "error";
	};
	/**
	 * Ask user to remove of keep the current draft
	 * Resolves with false if user canceled the action
	 * Resolves false if user canceled the operation
	 */
	this.offlineDraftAskRemove = function() {
		var self = this;
		var opts = {
			buttons: [],
			defaultAction: "no"
		};
		// Buttons displayed in dialog
		["cancel", "no", "drafts.dlog.removeoffline.button"].forEach(function(act) {
			opts.buttons.push({
				action: act,
				label: locale.text(act)
			});
		});
		var modal = new modalMultiButtons.Modal(locale.text("drafts.dlog.removeoffline.title"), locale.text("drafts.dlog.removeoffline.info"), opts);
		return modal.show().then(function(result) {
			if (result === "drafts.dlog.removeoffline.button") {
				return self.offlineDraftRemove().always(function() {
					self._offlineDraftId = null;
					return "removed";
				});
			} else if (result === "cancel") {
				return "cancel";
			} else {
				return "kept";
			}
		}).then(function(result) {
			if (result === "cancel") return false;
			self._offlineDraftId = null;
			if (result === "removed") return true;
			// Result = kept
			if (self._page.dao.isDirty) {
				// Data has been modified since last save. Save with previous comment and offline mode
				return self.saveInDB(self._comment, true).always(function() {
					return true;
				});
			}
			return true;
		});
	};
	/**
	 * Removes an offline draft
	 */
	this.offlineDraftRemove = function() {
		var self = this;
		var deferred = $.Deferred();
		if (!self._offlineDraftId) {
			deferred.resolve();
		} else {
			globals.getStorage().draftOperation("draftDelete", self._offlineDraftId).always(function() {
				self._offlineDraftId = null;
				deferred.resolve();
			});
		}
		return deferred.promise();
	};
	/**
	 * Called by parent's page if there's ad draft-id in state.options (edit draft action in pageDrafts)
	 * Read draft from DB and delete it
	 * Draft will be eventually saved again if user decide to re-save it
	 * Resolves with data or null
	 */
	this.loadFromDraft = function(draftId) {
		var self = this;
		self._comment = null;
		return globals.getStorage().draftOperation("draftRead", draftId).then(function(ctx) {
			return globals.getStorage().draftOperation("draftDelete", draftId).then(function() {
				var data;
				if (ctx && ctx.dataSet) {
					data = ctx.dataSet;
					// Used in order to propagate the comment if we save the draft again
					self._comment = ctx.comment;
					// To restore the status if back without modification - see notifDataLoaded loadedFrom == draft
					self._draftStatus = ctx.status;
				}
				return $.smResolve(data, data != null ? "draft" : null);
			});
		}).fail(function(e) {
			// Eventually display an error
			return null;
		});
	};
};

exports.Klass = _DraftMgr;