"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var modalMultiButtons = require('syracuse-tablet/html/js/ui/modals/modalMultiButtons');
var modalSaveDraft = require('syracuse-tablet/html/js/ui/modals/modalSaveDraft');

/**
 * Manages the drafts process in pageRegular
 * 		Asks user to save the draft on back/cancel page.chekBack
 * 		Load the draft from DB in page.loadData process
 */
var _DraftMgr = function(page) {
	this._page = page;
	this._draftStatus = null;

	this.destroy = function() {
		this._page = null;
	};
	/**
	 * Return a promise or a boolean (true to continue back process)
	 * forcePromise: true force top return a promise
	 * Ask user to save the draft or to remove an offline draft
	 */
	this.checkBack = function(forcePromise) {
		var self = this;
		if (self._offlineDraftId) {
			//  Ask user to remove offline draft which has been created automatically on connection error
			return self.offlineDraftAskRemove();
		}
		//  No modification in dao - skip checkBack
		if (!self._page.dao || !self._page.dao.isDirty) {
			return forcePromise ? $.smResolve(true) : true;
		}
		if (this.pageLoadedFromDraft()) {
			// We save without asking the user
			return this.save(false, false);
		}
		//  Ask user to discard changes or save as draft
		return self.askSaveDraft();
	};
	/**
	 * Ask user to discard changes or save as draft
	 * Resolves with true if save has been skipped or succeeded
	 * Resolves false if user canceled the operation
	 */
	this.askSaveDraft = function() {
		var self = this;
		var opts = {
			buttons: [],
			defaultAction: "no"
		};
		// Buttons displayed in dialog
		["drafts.dlog.savedraft.button", "no", "yes"].forEach(function(act) {
			opts.buttons.push({
				action: act,
				label: locale.text(act)
			});
		});
		// Id of label is taken as action id for convenience
		var modal = new modalMultiButtons.Modal(locale.text("drafts.dlog.savedraft.title"), locale.text("drafts.dlog.savedraft.info"), opts);
		return modal.show().then(function(result) {
			if (result === "drafts.dlog.savedraft.button") {
				return self.save(false, true).then(function(saved, draftCtx) {
					// back is allowed if no error otherwise we need to save again and say no is error is persisting
					return saved === true;
				});
			} else {
				return result !== "no";
			}
		});
	};
	/**
	 * offline: 	true if user is asked to save an offline draft
	 * confirm: 	Ask user to input a comment and save/cancel action
	 * Resolve 		with true/false and draft context
	 */
	this.save = function(offline, confirm) {
		var self = this;
		var deferred = $.Deferred();
		var step;
		if (confirm === true) {
			step = new modalSaveDraft.Modal(self._comment || "", offline === true).show();
		} else {
			step = $.smResolve({
				action: "save",
				comment: self._comment
			});
		}
		step.then(function(result) {
			if (result == null || result.action != "save") return null;
			return self.saveInDB(result.comment, offline);
		}).then(function(ctx) {
			if (ctx) {
				globals.getModal().notify({
					severityClass: offline ? "warning" : "success",
					title: locale.text("drafts.notify.saved")
				});
			}
			deferred.resolve(ctx != null, ctx);
		}).fail(function(e) {
			globals.getModal().error(locale.text("drafts.error.saving"), e, function() {
				deferred.resolve(false, null);
			});
		});
		return deferred.promise();
	};
	/**
	 *Save draft in DB
	 */
	this.saveInDB = function(comment, offline) {
		var self = this;
		var uuid = jsutils.getPropByPath(self._page, "dao.data.$uuid");
		if (!uuid) {
			return $.smReject("Unexpected null uuid");
		}
		var restoredCtx = self._page.getRestoreContext();
		restoredCtx.currentState.options["workingCopy-Id"] = null;
		restoredCtx.currentState.options["draft-id"] = uuid;
		if (!self._draftSaveLink) {
			var links = self._page.getProtoLinks();
			Object.keys(links).some(function(key) {
				if (key === "$save") {
					self._draftSaveLink = links[key];
					return true;
				}
			});
		}
		if (!self._draftSaveLink) {
			return $.smReject("Unexpected $save link not found in prototype");
		}
		var draftContext = {
			"id": uuid,
			"endpoint": globals.getEndpoint(),
			"representation": self._page.prototype.data("$representation"),
			"status": offline ? "offline" : self._draftStatus || "unsavedchanges",
			"title": self._page.prototype.data("$title") || "",
			"comment": comment || "",
			"restoredContext": restoredCtx,
			"dataSet": self._page.dao.data,
			"saveLink": self._draftSaveLink,
			"creation_date": utils.getCurISODateTime(new Date())
		};
		return globals.getStorage().draftOperation("draftSave", draftContext);
	};
	/**
	 * New data loaded in parent's page
	 */
	this.notifDataLoaded = function(loadOption, loadedFrom) {
		// No need to wait the promise
		this.offlineDraftRemove();
		this._pageLoadedFrom = loadedFrom;
		if (loadedFrom === "draft") {
			// Remove the draft id - A new one will be created if the form is saved again or reloaded
			this._page.state.options["draft-id"] = null;
		} else if (loadedFrom === "workingCopy") {
			// To force ask user on back
			this._page.dao.setDirty();
		}
		this._draftStatus = null;
	};
	this.pageLoadedFromDraft = function() {
		return this._pageLoadedFrom === "draft";
	};
	/**
	 * Save action succeeded in parent's page
	 */
	this.notifSaveSucceeded = function() {
		// No need to wait the promise
		this.offlineDraftRemove();

	};
	/**
	 * Save action failed in parent's page
	 */
	this.notifSaveFailed = function(result) {
		var self = this;
		if (result.responseJSON.$noConnectionError === true) {
			/**
			 * No connection - we save the draft and keep the id to ask user to remove it when he/she will exit the page
			 */
			// self._offlineDraftId != null - Save dialog only he first time we save the offline draft 
			// pageLoadedFromDraft == true we also don't ask the user
			self.save(true, self._offlineDraftId == null && !self.pageLoadedFromDraft()).then(function(saved, draftCtx) {
				if (saved) {
					self._offlineDraftId = draftCtx.id;
					// To not be prompt if we exit (back) or cancel edit
					self._page.dao.resetDirty();
					// Store the comment to recall it (see checkBack with _offlineDraftId)
					self._comment = draftCtx.comment;
				} else {
					self._offlineDraftId = null;
					self._comment = null;
				}
			});
			return;
		} else {
			self._offlineDraftId = null;
		}
		// No need to wait the promise
		self.offlineDraftRemove();
		self._draftStatus = "error";
	};
	/**
	 * Ask user to remove of keep the current draft
	 * Resolves with false if user canceled the action
	 * Resolves false if user canceled the operation
	 */
	this.offlineDraftAskRemove = function() {
		var self = this;
		var opts = {
			buttons: [],
			defaultAction: "no"
		};
		// Buttons displayed in dialog
		["cancel", "no", "drafts.dlog.removeoffline.button"].forEach(function(act) {
			opts.buttons.push({
				action: act,
				label: locale.text(act)
			});
		});
		var modal = new modalMultiButtons.Modal(locale.text("drafts.dlog.removeoffline.title"), locale.text("drafts.dlog.removeoffline.info"), opts);
		return modal.show().then(function(result) {
			if (result === "drafts.dlog.removeoffline.button") {
				return self.offlineDraftRemove().always(function() {
					self._offlineDraftId = null;
					return "removed";
				});
			} else if (result === "cancel") {
				return "cancel";
			} else {
				return "kept";
			}
		}).then(function(result) {
			if (result === "cancel") return false;
			self._offlineDraftId = null;
			if (result === "removed") return true;
			// Result = kept
			if (self._page.dao.isDirty) {
				// Data has been modified since last save. Save with previous comment and offline mode
				return self.saveInDB(self._comment, true).always(function() {
					return true;
				});
			}
			return true;
		});
	};
	/**
	 * Removes an offline draft
	 */
	this.offlineDraftRemove = function() {
		var self = this;
		var deferred = $.Deferred();
		if (!self._offlineDraftId) {
			deferred.resolve();
		} else {
			globals.getStorage().draftOperation("draftDelete", self._offlineDraftId).always(function() {
				self._offlineDraftId = null;
				deferred.resolve();
			});
		}
		return deferred.promise();
	};
	/**
	 * Called by parent's page if there's a draft-id in state.options (edit draft action in pageDrafts)
	 * Read draft from DB
	 * Resolves with data or null
	 */
	this.loadFromDraft = function(draftId) {
		var self = this;
		self._comment = null;
		return globals.getStorage().draftOperation("draftRead", draftId).then(function(ctx) {
			var data;
			if (ctx && ctx.dataSet) {
				data = ctx.dataSet;
				// Used in order to propagate the comment if we save the draft again
				self._comment = ctx.comment;
				// To restore the status if back without modification - see notifDataLoaded loadedFrom == draft
				self._draftStatus = ctx.status;
			}
			return $.smResolve(data, data != null ? "draft" : null);
		}).fail(function(e) {
			// Eventually display an error
			return null;
		});
	};
};

exports.Klass = _DraftMgr;