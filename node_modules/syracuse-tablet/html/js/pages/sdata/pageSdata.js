"use strict";

var Base = require('syracuse-tablet/html/js/pages/pageBase').Page;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var helpers = require('syracuse-tablet/html/js/common/helpers');

var SdataController = require("syracuse-tablet/html/js/controllers/sdataController").SdataController;
var articleParser = require("syracuse-tablet/html/js/controls/articleParser");
var ActionAdapterPageSdata = require('syracuse-tablet/html/js/pages/sdata/actionAdapterPageSdata').ActionAdapterPageSdata;

var modules = require('syracuse-tablet/html/js/common/modules');
var sdataReq = require("syracuse-tablet/html/js/sdata/sdataRequester");
var waiting = require('syracuse-tablet/html/js/utils/waiting');
var settings = require('syracuse-tablet/html/js/app/settings');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var native = require('syracuse-tablet/html/js/helpers/native/native');
var wpHelpers = require('syracuse-tablet/html/js/sdata/wpHelpers');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var panelEditTemplates = require('syracuse-tablet/html/js/controls/panels/aside/panelEditTemplates');


/**
 * Page handling something backed-up by sdata
 * 
 * A page should
 * - Create UI controls needed for rendering, can be device specific like header/footer
 * - Create it's controller 
 */
exports.Page = utils.defineClass(
	function PageSdata(pageData, options) {
		this.pageData = pageData;
		options = options || {};
		Base.call(this, pageData.name, options);
		this.actionAdapter = new ActionAdapterPageSdata(this);
		this.actionAdapter.showDesignPage = this.allowAuthoring();
		this.actionAdapter.showPageShare = this._checkSharePanelActive();
		if (options.isChild !== true) {
			this.actionAdapter.showPinPage = true;
			this.actionAdapter.showEditTemplates = this.controller.isEditMode();
		}
		this._publishOptions = null;
		notifications.subscribe(this, ["sm.auth.set.selection"]);
	},
	Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			notifications.unsubscribe(this, ["sm.auth.set.selection"]);
			this.pageData = null;

			if (this.controller) {
				this.controller.destroy();
				this.controller = null;
			}
			if (this.actionAdapter) {
				this.actionAdapter.destroy();
				this.actionAdapter = null;
			}
		},
		unbuild: function() {
			if (this.rootLayout) {
				this.rootLayout.destroy();
				this.rootLayout = null;
			}
			Base.prototype.unbuild.call(this);
		},
		_ensureController: function() {
			this.controller = new SdataController(this.pageData.dataset, null, this.isWorkingCopyDataUrl());
			// Will raise notifications or do confirmations
			this.controller.setUIAdapter(this);
		},
		createRootElement: function() {
			Base.prototype.createRootElement.call(this);
			this.$$elmt.attr("data-controller-id", this.controller.id);
			// Needed by css - previous version
			var css = ["regular"];
			var facet = this.controller.dataset.prototype.getFacet();
			if (facet) {
				css.push(facet.smStartsWith("$") ? facet.substring(1) : facet);
			}
			this.$$elmt.addClass(css.join(" "));
		},
		initStructure: function() {
			Base.prototype.initStructure.call(this);
			this.rootLayout = articleParser.parseArticle(this.controller, this.getArticle(), this);
			if (!this.rootLayout) {
				return $.smReject(helpers.createDiag(null, "error", locale.text("page.invalid.article")));
			}
		},
		render: function() {
			var self = this;
			self.attachedControlsMgr.buildHtml();
			return self.renderRootLayout()
				.then(function() {
					if (self.parentVignette) {
						return $.smResolve()
					} else {
						return self.actionAdapter.showPinPage && wpHelpers.isPagePinned(self.getPinPageId())
							.then(function(state) {
								notifications.publish(["sm.pin.status.change"], state);
							})
					}
				}).then(function() {
					if (self.actionAdapter.showEditTemplates === true) {
						panelEditTemplates.publishEditTemplateStatus(self);
					}
				})
		},
		renderRootLayout: function() {
			var self = this;
			return $.smResolve().then(function() {
				self.rootLayout.set$$container(self.$$contentRoot);
				self.rootLayout.buildHtml();
			})
		},
		afterRender: function() {
			this.rootLayout.afterRender();
			if (this.controller.showNavigationStackBar()) {
				this._actActionStack(this.controller.currentStack || 0)
			}
		},

		/**
		 * Called when the data on a page has changed after pagination/filter..
		 * Normally we shoudl'nt rebuild but just refresh the page
		 */
		rebuildHtml: function() {
			this.rootLayout.destroy();
			this.rootLayout = articleParser.parseArticle(this.controller, this.getArticle(), this);
			this.rootLayout.set$$container(this.$$contentRoot);
			this.rootLayout.buildHtml();
			// Like the controls are destroyed we have to computeLayout to recalculate the widths
			this.computeLayout({
				refresh: true
			});
		},

		/**
		 * Compute layout starting from rootLayouts
		 */
		computeControlsLayouts: function(context) {
			Base.prototype.computeControlsLayouts.call(this, context);
			if (this.rootLayout) {
				this.rootLayout.computeLayout(context);
			}
		},
		/**
		 * True if scroll enabled in page
		 * edit/detail allows scroll in vignette
		 * query/lookup doesn't allow because scroll is done by the array
		 */
		scrollAllowed: function() {
			if (this.controller.dataset.prototype.isQueryLikeFacet()) {
				// This is the array which scrolls
				return false;
			}
			return true;
		},

		//
		// START UI ADAPTER
		//

		/**
		 * Called before processing an action
		 * Returns a promise
		 * Resolve with (true/false, beforeContext)
		 * 	-> false to stop the action - true to continue
		 * 	-> beforeContext (optional) is a context passed to afterOnSdataActionClicked 
		 */
		beforeOnSdataActionClicked: function(actionName, controller) {
			var context = null;
			var goAhead = true;
			if (actionName === "$edit") {
				// Used to stay at the same position when we edit the page
				var selector = '.s-m-control.s-m-field';
				this.$$contentElmt.find(selector).each(function() {
					var $$e = $(this);
					if ($$e.is(":visible") && $$e.offset().top > 50) {
						// Pass the first 'visible' element
						context = {
							selector: selector,
							id: $$e.attr("id").split('-')[0],
							offset: $$e.offset().top
						}
						return false;
					}
				})
			}
			return $.smResolve(goAhead, context)
		},

		/**
		 * Called after an action/link has been processed
		 * actionName: name of clicked action/link
		 * success: true/false
		 * beforeContext: context given by beforeOnSdataActionClicked
		 * response: ajax JSON response if any
		 * No return expected
		 */
		afterOnSdataActionClicked: function(actionName, success, beforeContext, response) {
			if ((actionName === "$save" || actionName === "$delete") && success === true) {
				setTimeout(function() {
					// TODO - Add an authoring property to manage the behavior 
					modules.get("appController").App.goBack();
				})
			} else if (actionName === "$edit" && beforeContext != null) {
				if (this && this.getGestureMgr()) {
					// Scroll in order to restore the same offset
					var id = beforeContext.id + "-";
					var self = this;
					this.$$contentElmt.find(beforeContext.selector).each(function() {
						var $$e = $(this);
						if ($$e.attr("id").smStartsWith(id)) {
							self.getGestureMgr().adjust(beforeContext.offset - ($$e.offset().top));
							return false;
						}
					})
				}
			}
		},
		_showNotification: function(title, message, severity) {
			modules.get("modal").notify({
				title: title,
				body: message,
				severityClass: severity
			});
		},
		_askConfirmation: function($confirm) {
			var resultPromise = $.Deferred();
			$confirm = utils.isExpression($confirm) ? this.controller.dataset.resolveExpression($confirm) : $confirm;
			this.controller.dataset.resolveExpression($confirm)
			modules.get("modal").simpleConfirm($confirm, function(confirmed) {
				resultPromise.resolve(confirmed);
			});
			return resultPromise.promise();
		},
		// This is mostly for debugging pending requests easily
		_updateRequestCount: function(count) {
			if (!this.$$counter) {
				this.$$counter = $('<span style="position: absolute; right: 0; bottom: 0; padding: 10px; background: white; z-index: 99999; opacity: 0.5;"><span>');
				this.$$elmt.append(this.$$counter);
			}
			if (count > 0) {
				this.$$counter.show();
				this.$$counter.text(count);
			} else {
				this.$$counter.hide();
			}
		},
		//
		// END UI ADAPTER
		//

		getPageTitle: function() {
			return this.controller.dataset.prototype.getValueByPath("$title", true);
		},

		/**
		 * Used by paging to allow the page to reload itself and update the history also
		 */
		fetchNewPageData: function($link) {
			var self = this;
			var $url = $link.$url;
			var fetchData = sdataReq.fetchPageData({
					$url: $url
				}, {
					prototype: self.pageData.prototype.json,
					page: self.pageData.page
				})
				.then(function(pageData) {
					var navStack = modules.get("navStack").findClosest(self.$$elmt);
					if (navStack) {
						navStack.replaceCurrentPageData(self, function(currentData) {
							currentData.url = $url;
							return currentData;
						});
					}
					// Saved context
					self.options.savedCtx = self.savedCtxCreate({
						noScroll: true
					});
					//keep the settings
					var settings = $.extend(true, {}, self.pageData.settings);
					self.pageData = pageData;
					self.pageData.settings = settings;
					self.controller.dataset.destroy();
					self.controller.setDataset(self.pageData.dataset);
					self.rebuildHtml();
				});
			// !! Returns the promise
			return waiting.waitModal(fetchData)
				.fail(function(error) {
					modules.get("modal").error(error);
				})
				.then(function() {
					self.onPageDataChanged();
				});
		},
		getPageSort: function() {
			return this.getPageSettings().sort;
		},
		getPageFilter: function() {
			return this.getPageSettings().filter;
		},
		getPageSearch: function() {
			return this.getPageSettings().search;
		},
		setPageSort: function(sort) {
			var old = this.getPageSort();
			if (sort == null && old == null) {
				return;
			}
			var changed = (old == null || sort == null) || (old.length != sort.length);
			changed = changed || sort.some(function(val, idx) {
				return sort[idx].sort !== old[idx].sort || sort[idx].field !== old[idx].field;
			});
			if (changed) {
				this.getPageSettings().sort = sort;
				this.getPageSettings().isDirty = true;
			}
		},
		setPageFilter: function(filter) {
			var old = this.getPageSort();
			if (old == null && filter == null) {
				return;
			}
			this.getPageSettings().filter = filter;
			this.getPageSettings().isDirty = true;
		},
		setPageSearch: function(searchchInfo) {
			this.getPageSettings().search = $.extend(true, null, searchchInfo);
			this.getPageSettings().isDirty = true;
			this.writePageSettings();
		},
		/* 
		 * Write user specific settings of this page
		 * Uses getPagePrefsId to compute key of the page
		 * When the key is empty, the page is assumed to have not settings and nothing is written
		 */
		writePageSettings: function() {
			var self = this;
			var pageSettings = self.getPageSettings();
			if (!pageSettings.isDirty) {
				return $.smResolve();
			}
			return $.smResolve()
				.then(function() {
					var pagePrefsId = self.getPagePrefsId();
					if (pagePrefsId) {
						delete pageSettings["isDirty"];
						return settings.writeUserPagePrefs(pagePrefsId, pageSettings);
					}
				});
		},
		getPageSettings: function() {
			if (!this.pageData.settings) {
				this.pageData.settings = {};
			}
			return this.pageData.settings;
		},
		/**
		 * Called when the data on a page has changed.
		 * First time called after page has rendered and the e.g. on paging
		 */
		onPageDataChanged: function() {
			Base.prototype.onPageDataChanged.call(this);
			if (!this.isVignette()) {
				// Vignettes will report to their dashboard and not directly notify here
				notifications.publish("sm.data.freshness.change", this.controller.dataset.getDataFreshness());
			}
		},
		// Arguments:  $details, $edit, $create, $query
		isFacet: function() {
			return this.controller.dataset.prototype.isFacet.apply(this.controller.dataset.prototype, arguments);
		},
		//
		// START: Authoring
		//
		allowAuthoring: function() {
			return true;
		},
		/**
		 * Returns name to use for saving authoring
		 * 
		 * Note: If the current page is the first page of a mobile application and is defined by a single homeGadget,
		 * the url to navigate to the page is the mobile application url. BUT the url used to determine the page
		 * name is the representations name and is stored in $mobileEmbeddedUrl
		 * 
		 * x3.erp.AQTCRUDM.$query
		 * syracuse.collaboration.testHomeDashboard.$mobileDashboard
		 */
		getAuthoringName: function() {
			var $url = this.pageData.dataset.json.$mobileEmbeddedUrl || this.pageData.$url;
			var repr = protoHelpers.getReprFromUrl($url);
			var ep = protoHelpers.getEndpointFromUrl($url);
			ep = ep.split(".").slice(0, 2).join(".");
			return ep + "." + repr;
		},
		/**
		 * Returns FULL name to use for reading articles
		 * The difference to getAuthoringName is, it also includes the dataset name (e.g. GX3APP)
		 * 
		 * Note: If the current page is the first page of a mobile application and is defined by a single homeGadget,
		 * the url to navigate to the page is the mobile application url. BUT the url used to determine the page
		 * name is the representations name and is stored in $mobileEmbeddedUrl
		 * 
		 * x3.erp.GX3APP.AQTCRUDM.$query
		 * syracuse.collaboration.testHomeDashboard.$mobileDashboard
		 */
		getAuthoringFullName: function() {
			var $url = this.pageData.dataset.json.$mobileEmbeddedUrl || this.pageData.$url;
			var repr = protoHelpers.getReprFromUrl($url);
			var ep = protoHelpers.getEndpointFromUrl($url);
			ep = ep.split(".").slice(0, 3).join(".");
			return ep + "." + repr;
		},
		getPrototype: function() {
			return this.pageData.prototype;
		},
		getRootLayout: function() {
			return this.rootLayout;
		},
		getArticle: function() {
			return this.pageData.page.$article;
		},
		getDataset: function() {
			return this.pageData.dataset;
		},
		getRepresentation: function() {
			return this.getPrototype().getRepresentation();
		},
		authUpdateLayout: function(article) {
			this.pageData.page.$article = article;
			if (this.actionAdapter) {
				this.actionAdapter.clearCachedItems();
			}
			return Base.prototype.authUpdateLayout.call(this, article);
		},
		//
		// END: Authoring
		//
		isDownloadEnabled: function() {
			return false;
		},
		isSData: function() {
			return true;
		},
		// true is the CURRENT data url is a working copy
		isWorkingCopyDataUrl: function() {
			return this.pageData && this.pageData.isWorkingCopy;
		},
		// True if ALL url's are stateless
		isStateLessMode: function() {
			return this.pageData.dataset.isStateLessMode();
		},
		// True if ALL url's are workingcopy (return true for query even query is always stateless)
		// Given by application settings or url param for test url's
		isWorkingCopyMode: function() {
			return this.pageData.dataset.isWorkingCopyMode();
		},
		getAuthoring: function(path, defValue) {
			var val = utils.getPropByPath(utils.getPropByPath(this, "pageData.page.$article"), path);
			return val != null ? val : defValue;
		},
		multiSelectionIsEnabed: function() {
			return false;
		},
		_actPinPage: function() {
			var self = this;
			var data = this.getPinPageData();
			wpHelpers.pinPage(data)
				.then(function(pagePined) {
					if (pagePined) {
						notifications.publish(["sm.pin.status.change"], pagePined);
						modules.get("modal").notify({
							body: locale.text("pin.page.add.ok", [self.getPageTitle()]),
							severityClass: "success"
						});
					}
				})
		},
		_actUnpinPage: function() {
			var self = this;
			var data = this.getPinPageData();
			wpHelpers.unPinPage(data)
				.then(function(pageUnPined) {
					if (pageUnPined) {
						notifications.publish(["sm.pin.status.change"], !pageUnPined);
						modules.get("modal").notify({
							body: locale.text("pin.page.remove.ok", [self.getPageTitle()]),
							severityClass: "success"
						});
					}
				})
		},
		getPinPageId: function() {
			var urlParsed = sdataUtils.parseSDataURL(this.pageData.$url);
			return this.pageName + (urlParsed && urlParsed.id ? "_" + urlParsed.id : "");
		},
		getPinPageData: function() {
			var name = this.pageName.split(".");
			var urlParsed = sdataUtils.parseSDataURL(this.pageData.$url);
			return {
				$title: this.getPageTitle() + (urlParsed.id ? " - " + urlParsed.id : ""),
				$type: "$representation",
				action: this.controller.getFacet(),
				applicationName: this.getDataset().getClientContext("$mobileApplication") || "none",
				entity: urlParsed.entity,
				key: urlParsed.id,
				representation: this.getRepresentation(),
				facet: this.controller.getFacet(),
				id: this.getPinPageId(),
				name: name[0],
				icon: "star",
			};
		},
		// What does the page basically support
		getPagePublishOptions: function() {
			if (this._publishOptions) {
				return this._publishOptions;
			}
			if (this.options.isChild) {
				this._publishOptions = {};
				return this._publishOptions;
			}
			var opts = {
				"scheduleMessage": {
					page: this
				},
				"share": {
					page: this
				}
			}
			if (this.pageData.prototype.isQuery()) {
				opts.liveTile = {
					page: this, // page to open on tile click
					pages: [this] // page to use for tile content (same as page or a vignette)
				}
			}
			this._publishOptions = opts;
			return this._publishOptions;
		},
		getPublishOptions: function() {
			var supportedByPage = this.getPagePublishOptions();
			var opts = {};
			Object.keys(supportedByPage).forEach(function(fn) {
				if (native.hasCapability(fn)) {
					opts[fn] = supportedByPage[fn];
				}
			});
			return opts;
		},
		_checkSharePanelActive: function() {
			if (this.options.isVignette) { // Will be handled by dashboard
				return false;
			}
			var opts = this.getPublishOptions();
			return Object.keys(opts).length > 0;
		},
		_actShowEditTemplates: function() {
			var panel = this.attachedControlsMgr.findByName("editTemplatesPanel");
			if (!panel) {
				panel = this.attachedControlsMgr.createControl(this._getAttachedControlInfo("editTemplatesPanel"));
			}
			if (!panel) {
				return;
			}
			panel.show();
		},
		_actActionStack: function(param) {
			this._toogleFirstLevelStack(parseInt(param, 10));
			this.controller.currentStack = parseInt(param, 10);
			notifications.publish(["sm.scroller.update"]);
			notifications.publish(["sm.stack.select"], param);
		},
		_toogleFirstLevelStack: function(idx) {
			if (!this.rootLayout.children || this.rootLayout.children.length === 0) return;
			this.rootLayout.children.forEach(function(elmt, index) {
				if (elmt.$type === "stack") {
					if (idx === index || idx === undefined) {
						elmt.show()
					} else {
						elmt.hide()
					}
				}
			});
		},
		//Send by authoring when select an element in the left panel
		notifAuthSetSelection: function(id, noScroll) {
			if (this.controller.showNavigationStackBar()) {
				var idx;
				var elmt = this.controller._controlsById[id];
				if (!elmt) return;
				var stack = elmt.$$elmt.closest(".s-m-stack[data-level='1'");
				if (!this.rootLayout.children || this.rootLayout.children.length === 0 || !stack) return;
				this.rootLayout.children.forEach(function(elmt, index) {
					if (elmt.$type === "stack") {
						if (elmt.id === stack.attr("id")) {
							idx = index
						}
					}
				});
				$("[data-naction='actionStack']", this.$$elmt).removeClass("active");
				$("[data-naction='actionStack'][data-params='" + idx + "']", this.$$elmt).addClass("active");
				this._actActionStack(idx)
			}
		}
	}
);