"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var modules = require('syracuse-tablet/html/js/common/modules');

/**
 * 
 */
exports.AttachedControlsMgr = utils.defineClass(
	function AttachedControlsMgr(page) {
		this.page = page;
		this.controls = [];
	},
	null, {
		destroyControls: function() {
			this.controls.forEach(function(control) {
				control.control.destroy();
			});
			this.controls = [];
		},
		destroy: function() {
			this.destroyControls();
			this.page = null;
		},
		/**
		 * hidden: the control is not displayed in the page (use toggleControls to show it)
		 */
		createControl: function(info, options, hidden) {
			var self = this;

			if (self.findByName(info.name) != null) {
				throw new Error("There can only be one control for a unique name");
			}

			var ctrlFactory = modules.get("ctrlFactory");
			var ctrl = ctrlFactory.createControl(self.page.controller, {
				$type: info.$type
			}, null, null, options);
			if (ctrl) {
				ctrl.attachedControlsMgr = self;
				ctrl.attachedControlInfo = info;

				ctrl.setActionAdapter && ctrl.setActionAdapter(self.page.actionAdapter);
				var c = $.extend(true, {}, info, {
					control: ctrl,
					isVisible: hidden !== true
				});
				self.controls.push(c);
			}
			return ctrl;
		},
		/**
		 * Create a control outside initialization process
		 * This control is hidden by default
		 * 
		 */
		createAddtionalControl: function(panelInfo, options) {
			var ctrl = this.createControl(panelInfo, {}, true);
			this.ensureControl$$container(ctrl, panelInfo);
			ctrl.buildHtml();
			return ctrl;
		},
		/**
		 * Search the container dedicated to enclose the control and set it for the control
		 */
		ensureControl$$container: function(control, attachedControlInfo) {
			var page;
			if (this.page.isVignette() && attachedControlInfo.vignetteSelectorUseParent) {
				page = this.page.parentPage;
			} else {
				page = this.page;
			}
			var $$container = page.$$elmt.find(attachedControlInfo.selector).first();
			if (!$$container || $$container.length < 1) {
				console.log("Container for control not found: " + attachedControlInfo.selector);
			}
			control.set$$container($$container);
			control.page = page;
		},
		/**
		 * Returns a CtrlBase object
		 */
		findByName: function(name) {
			var entry = this._findEntryByName(name);
			return entry && entry.control;
		},
		/**
		 * Returns a controls entry object
		 */
		_findEntryByName: function(name) {
			var entry = null;
			this.controls.some(function(control) {
				if (name === control.name) {
					entry = control;
					return true;
				}
			});
			return entry;
		},
		_findEntryByControl: function(ctrl) {
			var entry = null;
			this.controls.some(function(control) {
				if (ctrl === control.control) {
					entry = control;
					return true;
				}
			});
			return entry;
		},
		buildHtml: function() {
			var self = this;
			self.controls.forEach(function(control) {
				self.ensureControl$$container(control.control, control.control.attachedControlInfo);
				control.control.buildHtml();
			});
		},
		computeLayout: function(context) {
			this.controls.forEach(function(control) {
				if (control.control.computeLayout) {
					control.control.computeLayout(context);
				}
			});
		},
		/**
		 * 
		 */
		computeMainLayout: function(layoutInfo) {
			var self = this;
			var mainLayout = {
				contentTop: 0,
				contentLeft: 0,
				contentHeight: layoutInfo.application.height,
				contentWidth: layoutInfo.application.width
			};
			var tops = [];
			var bottoms = [];
			var bottomsHeight = 0;
			self.controls.forEach(function(control) {
				if (control.isVisible !== true) {
					return;
				}
				if (control.topIndex != null) {
					tops[control.topIndex] = control;
				}
				if (control.bottomIndex != null) {
					bottoms[control.bottomIndex] = control;
					bottomsHeight += control.control.getDesiredHeight();
				}
			});
			var top = 0;
			var heightSubstract = 0;
			tops.forEach(function(control) {
				if (control == null) {
					return;
				}
				var height = control.control.getDesiredHeight();
				control.control.setTop(top);
				heightSubstract = heightSubstract + height;
				top = top + height;
			});
			mainLayout.contentTop = top;
			top = mainLayout.contentHeight - bottomsHeight;
			bottoms.forEach(function(control) {
				if (control == null) {
					return;
				}
				var height = control.control.getDesiredHeight();
				control.control.setTop(top);
				heightSubstract = heightSubstract + height;
				top = top + height;
			});
			mainLayout.contentHeight -= heightSubstract;
			return mainLayout;
		},
		/**
		 * Toggle the control name1 (force show/hide if show == true/false)
		 * Toggle the control name2 to the reverse status of name1
		 * Returns true if new status is visible
		 */
		toggleControls: function(name1, name2, show) {
			var wasVisible = this.isVisible(name1);
			show = show == null ? !wasVisible : show;
			if ((wasVisible && show) || (!wasVisible && !show)) {
				return;
			}
			var self = this
			var ctrls = [{
				name: name1,
				show: show
			}, {
				name: name2,
				show: !show
			}];
			ctrls.forEach(function(i) {
				var entry = self._findEntryByName(i.name);
				if (!entry) {
					return;
				}
				entry.control.$$elmt.toggle(i.show);
				entry.isVisible = i.show;
				if (i.show) {
					entry.control.computeLayout();
				}
			})
			return show;
		},
		/**
		 * nameOrCtrl is string or CtrlBase
		 */
		isVisible: function(nameOrCtrl) {
			if (!nameOrCtrl) {
				return false;
			}
			var entry;
			if (typeof nameOrCtrl === "string") {
				entry = this._findEntryByName(nameOrCtrl);
			} else {
				entry = this._findEntryByControl(nameOrCtrl);
			}
			return entry && entry.isVisible === true;
		}
	});