"use strict";

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/pages/pageRegular').Page;
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var userPreferences = require('syracuse-tablet/html/js/helpers/userPrefs');
var chartsUtils = require('syracuse-tablet/html/js/controls/chart/chartsUtils');

var notifications = require('syracuse-tablet/html/js/helpers/notifications');


/**
 * Child page that displays chart detail
 */
var _Page = utils.defineClass(
	// Name ChartDetailPage used for instanceof
	function ChartDetailPage($parent, state, prototype, article, parentPage, options) {
		if (globals.isAuthoringActive()) {
			options.header = false;
			options.footer = false;
			options.breadcrumbs = false;
		}
		// For parent page to create the container
		options.topToolbar = true;
		if (!article.$display) {
			article.$display = "bothSideToSide";
		}
		this.parentPage = parentPage;
		if (!this.parentPage) throw new Error("chartdetail page - Unexpected empty parent page");
		Base.call(this, $parent, state, prototype, article, options);
		// Preference id is passed by parent control 
		this._userPrefs = userPreferences.createUserPrefs("toolbar", state.options["dataParams"]);
	}, Base, {

		destroy: function() {
			if (this.destroyed) return;
			Base.prototype.destroy.call(this);
			this.parentPage = null;
			this._notifData = null;
			if (this._userPrefs) {
				this._userPrefs.destroy();
				this._userPrefs = null;
			}
		},
		/**
		 * Create the toolbar
		 */
		createPageControl: function(id) {
			if (id === "topToolbar") {
				return globals.isAuthoringActive() ? null : ctrlFactory.createPageControl("topToolbarChartDetail", this);
			}
			return ctrlFactory.createPageControl(id, this);
		},
		buildHtmlOption: function(loadOptions) {
			if (loadOptions) {
				// No need to send a request - data are in the cache because already read by the dashboard
				loadOptions.updateLayout = (this.state.level != null && this.state.level > 1) ? false : true;
			}
			return Base.prototype.buildHtmlOption.call(this, loadOptions).then(function(opts) {
				return $.extend(true, {}, opts, {
					toolBars: {
						showAuthoring: false,
						showUserMenuLinks: true,
						showHome: true,
						showActions: false,
						statusPinPage: false
					}
				});

			});
		},
		afterRender: function(loadOptions, buildOpts) {
			var self = this;
			return Base.prototype.afterRender.call(this, loadOptions, buildOpts).then(function() {
				var chart = self.getChart();
				var array = self.getArray();
				if (chart && chart.article.$isHidden === false && array && array.article.$isHidden === false) {
					// Both controls are
					array.paginAddSynchro(chart);
				}
			});
		},
		/**
		 * Page is visible
		 */
		activated: function() {
			var opts = {
				display: this.article.$display,
				style: this.getChart().article.$style
			};
			notifications.publish("sm.chartdetail.updt.toolbar", opts);
		},
		/**
		 * Return data for parent
		 */
		getParentNotif: function() {
			if (this._notifData) {
				return {
					parentId: this.state.options.parentId,
					controlId: this.state.options.controlOriginId || this.state.options.controlId,
					notifId: "sm.updt.chart.detail.article",
					notifData: this._notifData
				};
			} else if (this.parentPage && this.parentPage.isVignette) {
				/**
				 * #6843
				 * Multiple charts in dashboards
				 * If we click on a chart detail before all the charts have been loaded the size of the charts could be wrong
				 * --> because chart in dashboard could be rendered while the chartDetail page is loading
				 * So when the chartDetail is closed it publishes this notification to allow the charts in parent's dashboard to check the height
				 */
				return {
					// no parentId is provided because we want to notify all the nested pages in the dashboard
					notifId: "sm.updt.chart.dashboard",
					notifData: this.state.options.parentId
				};
			}
			return null;
		},
		scrollAllowed: function() {
			return true;
		},

		getChart: function() {
			return this._findArrayCtrl(true);
		},
		getArray: function() {
			return this._findArrayCtrl(false);
		},
		getControl: function(controlId) {
			var control = this._controlsMap && this._controlsMap[controlId];
			if (control) return control;
			if (this.parentPage) return this.parentPage.getControl(controlId);
			return null;
		},
		_findArrayCtrl: function(chartDisplay) {
			var self = this;
			var res;
			this.forEachControl(function(id, ctrl) {
				if (jsutils.isInstanceOf(ctrl, "CtrlArrayChart") && (chartDisplay ? ctrl.isHighChart() : !ctrl.isHighChart())) {
					res = ctrl;
					return true;
				}
			});
			return res;
		},
		_actSaveChartDetail: function() {
			this._notifData = {};
			this._notifData.article = $.extend(true, {}, this.article);
			this._notifData.level = this.state.level == null ? 0 : this.state.level;
			// Do not create redundant data here on save, the separated information can be extracted also shortly before rendering
			// Also, the change below broke existing page definitions because json changed completely
			// --- old comment below here ---
			// We save the chart article and the array article to be able to rebuild the chartDetail layout (which is fixed sideToSie, chartOnly, arrayOnly)
			//this._notifData.article.$chartArticle = $.extend(true, {}, this.getChart().article);
			//this._notifData.article.$arrayArticle = $.extend(true, {}, this.getArray().article);

			globals.getApplication().goBack();
		},
		authUpdateLayout: function(article, vignetteToUpdt) {
			// Clear preferences in order to see the changes when we exit authoring
			// Otherwise the preferences will override the authoring
			this._userPrefs.savePrefs(null);
			return Base.prototype.authUpdateLayout.call(this, article);
		},
		_setDisplay: function() {
			var chart = this.getChart();
			var array = this.getArray();
			if (!chart || !array) return false;
			// If authoring we take the article of the controls chart and array and force display to bothside2side
			var prefs = this._userPrefs.getPrefs();
			var opts = {
				display: prefs ? prefs.display : null,
				style: prefs ? prefs.style : null
			};
			// Create structure article (chart) by using the article of the controls to preserve authoring 
			var article = chartsUtils.getChartDetailArticle(opts, chart.$bind, chart ? chart.article : null, array ? array.article : null);
			// Copy the properties specific to the page article - e.g $display..
			for (var p in this.article) {
				if (p != "$layoutType" && p != "$items") {
					article[p] = this.article[p];
				}
			}
			// Update layout
			var self = this;
			var pagingInfo;
			if (array && array.article.$isHidden === true) {
				pagingInfo = chart.paginGetInfo();
			} else {
				pagingInfo = array.paginGetInfo();
			}
			Base.prototype.authUpdateLayout.call(this, article).then(function() {
				notifications.publish("sm.chartdetail.updt.toolbar", opts);
				if (pagingInfo && pagingInfo.currentIdx > 0) {
					self.getChart().paginSetInfo(pagingInfo);
					self.getArray().paginSetInfo(pagingInfo);
				}
			});
			return true;
		},
		actToolbarSetDisplay: function(opts) {
			if (globals.isAuthoringActive()) return;
			this._userPrefs.savePrefs(opts);
			this._setDisplay();
		}
	});

exports.Page = _Page;