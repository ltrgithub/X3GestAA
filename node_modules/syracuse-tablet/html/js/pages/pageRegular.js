"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var Base = require('syracuse-tablet/html/js/pages/page').Page;
var globals = require('syracuse-tablet/html/js/helpers/globals');
var dispatcher = require('syracuse-tablet/html/js/sdata/sdataDispatcher');
var factory = require('syracuse-tablet/html/js/application/appFactory');
var daoSdata = require('syracuse-tablet/html/js/application/daoSdata');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var sessStorage = require('syracuse-tablet/html/js/storage/sessionStorage');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var native = require('syracuse-tablet/html/js/helpers/native/native');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var Gadget = require('syracuse-tablet/html/js/application/gadget').Klass;
var modalSaveDraft = require('syracuse-tablet/html/js/ui/modals/modalSaveDraft');

var _notInPanel = ["$edit", "$create", "$delete", "$details", "$query", "$save", "$canceledit"];
var _excludeFromPanel = function(name, forceFooterHeader, link, facet) {
	if (_notInPanel.indexOf(name) >= 0) return true;
	if (facet === "query" && link && link.$url && _isSingleItemLink(link.$url)) return true;
	return forceFooterHeader === true;
};

var _isSingleItemLink = function(url) {
	// Ensure it is an sdata link and not any other external link by checking for ?representation=
	// Also check if there are brackets ( <key> ) including a key with dynamic place holders {code}
	if (/\((\S*\{\S*\}\S*)\).*\?.*representation=/.test(url)) {
		return true;
	}
	return false;
};
var _isOfficeLink = function(name, info) {
	return name.smStartsWith("$word") || name.smStartsWith("$excel") || (info.$type != null && info.$type.indexOf("openxml") >= 0);
};
var _isPaginLink = function(name) {
	return name === "$first" || name === "$previous" || name === "$next" || name === "$last";
};
var _checkLink = function(name, info) {
	if (info == null || info.$isExcluded === true) {
		return false;
	}
	if (_isPaginLink(name)) {
		return false;
	}
	if (name.smStartsWith('$') && _isOfficeLink(name, info)) {
		return false;
	}
	return true;
};
var _linksMap = {
	header: {
		smartphone: {
			details: {
				$edit: true,
				$delete: true
			},
			edit: {
				$canceledit: true,
				$save: true
			},
			query: {
				$create: true
			},
			create: {
				$save: true,
				$canceledit: true
			}
		},
		tablet: {}
	},
	footer: {
		smartphone: {},
		tablet: {
			details: {
				$edit: true,
				$delete: true,
				$query: true
			},
			edit: {
				$save: true,
				$canceledit: true
			},
			query: {
				$create: true
			},
			create: {
				$save: true,
				$canceledit: true
			}
		}
	},
	actionpanel: {}
};
var _getLinkMap = function(toolbar, deviceType, facet) {
	var lMap = _linksMap[toolbar];
	if (!lMap) {
		throw new Error("Unexpected toolbar parameter [" + toolbar + "]. Expected 'header', 'footer' or 'actionpanel'");
	}
	if (toolbar === "actionpanel") return lMap;
	lMap = lMap[deviceType || "tablet"];
	if (!lMap) {
		throw new Error("Unexpected deviceType parameter [" + deviceType + "]. Expected 'tablet', 'smartphone'");
	}
	if (facet === "lookup") facet = "query";
	if (facet === "summary") facet = "details";
	lMap = lMap[facet];
	if (!lMap) {
		throw new Error("Unexpected facet parameter [" + facet + "]");
	}
	return lMap;
};
/*
 * Returns appropriate right value for where request
 * For example, for the filter 'CODE contains aa', the where clause should look like
 * CODE like '%aa%'. This function will return '%aa%'
 */
var _setFilterRightValue = function(filter) {
	var cp = filter.prop;
	var cv, value = (filter.originalValue || filter.value) == null ? "" : (filter.originalValue || filter.value);
	switch (cp.$type) {
		case "application/x-password":
		case "application/x-string":
			cv = value.replace(/'/g, "\\'");
			if (filter.operator === "like") cv = '%' + cv + '%';
			else if (filter.operator === "like_s") cv = cv + '%';
			cv = "'" + cv + "'";
			return cv;
		case "application/x-integer":
		case "application/x-real":
		case "application/x-decimal":
		case "application/x-quantity":
			return value;
		case "application/x-date":
			if (!value) return null;
			return '@' + value + '@';
		case "application/x-datetime":
			return '@' + value + '@';
		case "application/x-time":
			return null;
		case "application/x-boolean":
			return value ? "true" : "false";
		case "application/x-choice":
			if (cp.$value && cp.$value.$type === "application/x-string") {
				return "'" + value.replace(/'/g, "\\'") + "'";
			} else return value + "";
			break;
		case "application/x-reference":
			if (typeof value != "string") {
				value = filter.value;
			}
			cv = (value || '').replace(/'/g, "\\'");
			cv = "'" + cv + "'";
			return cv;
		default:
			break;

	}
	return null;
};

/**
 * Page with representation and sdata back-end
 */
var _Page = utils.defineClass(
	function RegularPage($parent, state, prototype, article, options) {
		if (options.breadcrumbs == null) {
			// Show breadcrumbs by default if not hidden by child class
			options.breadcrumbs = true;
		}
		Base.call(this, $parent, state, prototype, article, options);
		// Gadget is created her because this.state must contain only JSON (restore context)
		this.gadget = this.state.options.gadget ? new Gadget(this.state.options.gadget) : null;
		this.openedFromDashboard = this.gadget != null;
		this._originalSdataUrl = this.state.options["sdata-url"];
		if (!this._originalSdataUrl) {
			if (this.gadget) {
				this._originalSdataUrl = this.gadget.getSDataUrl(this.prototype);
			} else {
				this._originalSdataUrl = this.prototype.data("$url");
			}
		}
		this._init$Filters();
		this._initSdataInfo();
		notifications.subscribe(this, ["sm.rowdetail.update", "sm.rowdetail.delete", "sm.action.link"], 1);
		var url = this.prototype.data("$url");
		var facet;
		if (url && url.length > 0) {
			facet = sdataUtils.parseSDataURL(url).facet;
		} else if (this.parentPage) {
			facet = this.parentPage.$facet;
		}
		// Override the standard "display" activity
		if (facet) {
			this.$facet = facet;
			this.setActivity(facet === "edit" ? "edit" : facet === "create" ? "create" : "read");
		}
		// Working copy is managed only if nativeApp because it is used to restore the context on nativeAppClosing/nativeAppResume events
		// Disabled temporarily for rowDetail see class
		this.enableWorkingCopy = this.isEditMode() && native.hasCapability("nativeApp") && !this.isChild;
		if (this.isEditMode() && !this.isChild) {
			this._draftMgr = new _DraftMgr(this);
		}
	}, Base, {
		_init$Filters: function() {
			var savedCtx = this.getSavedContext();
			// Rstoration of sort/filter if any (only if page is restored from a link)
			if (savedCtx && savedCtx.sortInfo) {
				this.filterSortWrite("sort", savedCtx.sortInfo);
			}
			if (savedCtx && savedCtx.filterInfo) {
				this.filterSortWrite("filter", savedCtx.filterInfo);
			}
			// Restore the selected $filters (filters given by prototype)
			var $filterId = savedCtx ? savedCtx.$filterId : null;
			this._$filters = [{
				id: "nofilter",
				$title: locale.text("nofilter")
			}];
			// Authoring on filters - none/list/tabs
			var auth = this.$filtersGetAuthoring();
			var filters = $.extend(true, {}, this.prototype.data("$filters"));
			if (auth === "none" || !filters || $.isEmptyObject(filters)) {
				this._$filtersDisabled = true;
				return;
			}
			var defFilter = null;
			for (var p in filters) {
				var ttl = this.prototype.resolveExpression(filters[p].$title);
				if (ttl) {
					var f = $.extend(true, {}, filters[p]);
					f.$title = ttl;
					f.id = p;
					f.$isDefault = false;
					if ($filterId && f.id === $filterId) {
						defFilter = f;
					} else if (!defFilter && f.$isDefault === true) {
						defFilter = f;
					}
					this._$filters.push(f);
				}
			}
			if (this._$filters.length == 0) return;
			if (defFilter) {
				defFilter.$isDefault = true;
			} else {
				this._$filters[0].$isDefault = true;
			}
		},

		/**
		 *  Init sdata url - Called in constructor and page refresh
		 * 	sdataUrl is optional in case of a gadget (to see with Mathias)
		 *  Can be overridden - rowdetail
		 */
		_initSdataInfo: function(sdataUrl) {
			if (!sdataUrl) sdataUrl = this._originalSdataUrl;
			if (this.gadget) {
				var params = this.gadget.getParameters();
				if (params.where) {
					sdataUrl = sdataUtils.addWhereClause(sdataUrl, params.where, this.state.options.sdataParameters);
				}
			}
			if (!sdataUrl) throw new Error("$url (sDataUrl) is expected");
			this.state.options["sdata-url"] = this.sDataUrl = sdataUrl;
			this.sDataMethod = this.state.options["sdata-method"] || "GET";
		},
		getOriginalSdataUrl: function() {
			return this._originalSdataUrl;
		},
		destroy: function() {
			if (this.destroyed) return;
			if (this._draftMgr) {
				this._draftMgr.destroy();
				this._draftMgr = null;
			}
			if (this.prototype && !this.prototype.isLookup()) {
				var keepWorkingCopy = this.enableWorkingCopy === true && this.state.options["workingCopy-Id"];
				if (!this.isVignette && !keepWorkingCopy && !this.isChild) {
					// Delete all the working copies because not needed any more - Page will not be restored
					globals.getStorage().draftOperation("wrkcpyDeleteAll");
				} else if (this.isVignette && !keepWorkingCopy && this.dao && this.dao.workingCopyGetId()) {
					// in a dashboard with multiple create/edit facest we just delete the current WorkingCopy (transatcion) because we don't know if other pages will be restored
					globals.getStorage().draftOperation("wrkcpyDelete", null, this.dao.workingCopyGetId());
				}
			}
			if (this.prototype && this.prototype.acceptServerPagination() && !globals.isAuthoringActive()) {
				// Clear the cache used by authoring for this page - Only if authoring not active
				// On a dashboard when we change an authoring property the page is destroyed and recreated so we don't destroy the cache
				notifications.publish("sm.authcache.destroy", this.id);
			}
			Base.prototype.destroy.call(this);
			this.gadget = null;
		},

		sisSamePage: function(pageName, pageOptions) {
			if (!Base.prototype.isSamePage.call(this, pageName, pageOptions)) {
				return false;
			}
			if (!this.state.options || !pageOptions) return true;
			return pageOptions["sdata-url"] === this.state.options["sdata-url"];
		},

		initOnLoad: function() {
			// TODO: Load filter settings
		},

		beforeAddContent: function() {
			if (false && !this.isVignette) {
				// #5583 - disabled because redundant with header title
				var ttl = this.prototype.data("$title");
				this.addTitle(globals.getApplication().getTitle() + (ttl ? " - " + ttl : ""));
			}
		},

		afterRender: function(loadOptions, buildOpts) {
			var self = this;
			return Base.prototype.afterRender.call(self, loadOptions, buildOpts).then(function() {
				if (self.isVignette) return;
				var diags = self.dao && self.dao.data && self.dao.data.$diagnoses;
				if (diags && diags.length > 0) {
					diags.forEach(function(diag) {
						var notify = {
							severityClass: globals.X3_SEVERITY_TO_BS[diag.$severity] || diag.$severity || "error",
							title: diag.$message
						};
						globals.getModal().notify(notify);
					});
				}
			});
		},
		activate: function(pageToClose, cb) {
			Base.prototype.activate.call(this, pageToClose, cb);
			// !!! Notification is called (noot on loadData) here because we the current page should be activated to trigger the notification event
			notifications.publish("sm.data.freshness.change", this.dao.dataFreshness());
		},
		/**
		 * Used by html builder to create a link to full page
		 */
		getOpenLinkAttrs: function() {
			var res = Base.prototype.getOpenLinkAttrs.call(this);
			res["data-sdata-url"] = this.sDataUrl;
			res["data-sdata-method"] = this.sDataMethod;
			res["data-gadget-id"] = this.gadget.data("$uuid");
			return res;
		},

		/**
		 * Refresh the page - Specific to pageRegular - The standard method is page.reload
		 * Manages specific options ( TODO override reload)
		 * 	Called from a vignette or full page (callBackInterface)
		 * 	options.sdata-url -> New url
		 * 	options.controlId!=null -> refresh the control
		 *  options.type Type of refresh (pagination...)
		 *  callBackInterface
		 *  	waitStop(ctrlId) / waitStart(ctrlId)
		 */
		refresh: function(options, callBackInterface) {
			var self = this;
			options = options || {};
			var deferred = $.Deferred();
			var url = options["sdata-url"];
			var controlId = options["controlId"];
			var type = options.type || "";
			var force = type === "filtersort" || options.forceRefresh === true;
			var _wait = function(status) {
				var suffix = self["wait" + status.smCapitalize()];
				if (callBackInterface) {
					var meth = self["wait" + suffix];
					if (meth) {
						callBackInterface[meth].call(null, controlId);
					}
				} else {
					var meth = self["waitWheel" + suffix];
					if (meth) {
						meth.call(self, controlId);
					}
				}
			};
			try {
				var _succeeded = function() {
					_wait("stop");
					self.refreshControls(controlId ? [controlId] : null, options);
					deferred.resolve();
				};
				if (!url && force !== true) {
					_succeeded();
				} else {
					_wait("start");
					if (url) {
						/* url can change on refresh (paginations)*/
						self._initSdataInfo(url);
					}
					self.loadData({
						refresh: true
					})
						.then(function() {
							_succeeded();
						}).fail(function(e) {
							_wait("stop");
							deferred.reject(e);
						});
				}
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},
		/**
		 * Url with where clause
		 */
		_getFullSdataUrl: function() {
			return this._filterSortAllowed() ? this._filterSortUpdateUrl() : this.sDataUrl;
		},
		/**
		 * reason: nativeAppClosing, pinPage, sharedLink...
		 */
		getRestoreContext: function(reason) {
			var ctx = Base.prototype.getRestoreContext.call(this, reason);
			if (!ctx) return ctx;
			if (this.state.options.sdataParameters) {
				ctx.currentState.options["sdataParameters"] = this.state.options.sdataParameters;
			}
			ctx.currentState.options["sdata-url"] = this.sDataUrl;
			if (this.dao && reason === "nativeAppClosing" && this.enableWorkingCopy === true) {
				ctx.currentState.options["workingCopy-Id"] = this.dao.workingCopyGetId(true);
			}
			return ctx;
		},
		savedCtxCreate: function(type) {
			var ctx = Base.prototype.savedCtxCreate.call(this, type);
			var $f = this._$filterGetInfo();
			// Save $filter info to restore it
			ctx.$filterId = $f && $f.id;
			if (type != "link" || !this._filterSortAllowed()) {
				return ctx;
			}
			// For a link context we save the filterSortInfo
			// -> By default this info is saved in sessionStorage (user prefs)
			ctx.sortInfo = this.filterSortRead("sort");
			ctx.filterInfo = this.filterSortRead("filter");
			return ctx;
		},
		loadData: function(loadOptions) {
			var self = this;
			loadOptions = loadOptions || {};
			self._dataLoadedFrom = null;
			var step;
			var enableWorkingCopy = this.enableWorkingCopy === true;
			if (loadOptions.reload !== true && this.state.options["draft-id"]) {
				// First
				step = self.loadFromDraft(this.state.options["draft-id"]);
			} else if (enableWorkingCopy) {
				step = self.loadCheckWorkingCopy(loadOptions);
			} else {
				step = $.smResolve(null);
			}
			return step.then(function(data, loadedFrom) {
				if (data) return $.smResolve(data, loadedFrom);
				return self.loadFromSData(loadOptions);
			}).then(function(data, loadedFrom) {
				self._dataLoadedFrom = loadedFrom;
				if (self.destroyed) {
					// Security - Page can be destroyed while loading in dashboard  
					return;
				}
				// If no json returned we create en empty dao
				self.setDao(data ? factory.createDaoSdata(data, self.prototype, {
					enableWorkingCopy: enableWorkingCopy
				}) : self.getEmptyDao(self.prototype));
				if (loadedFrom === "draft") {
					// If data is loaded from a draft we force dirty in order to ask user for saving the draft even if dao hasn't been modified
					self.dao.setDirty();
				}
				if (loadOptions.refresh === true) {
					// Only on page refresh otherwise see activate method - next/previous datas in grid...
					notifications.publish("sm.data.freshness.change", self.dao.dataFreshness());
				}
			});
		},
		/**
		 * Resolves with data or null
		 * Null -> Data are loaded from sData dispatcher
		 */
		loadCheckWorkingCopy: function(loadOptions) {
			if (loadOptions.reload === true) {
				// Page reloaded we delete the current working copy 
				// No need to wait - wrkcpyDelete resolves with true/false
				if (this.dao && this.dao.workingCopyGetId()) {
					globals.getStorage().draftOperation("wrkcpyDelete", this.dao.workingCopyGetId());
				}
				return $.smResolve(null);
			} else if (this.state.options["workingCopy-Id"]) {
				var id = this.state.options["workingCopy-Id"];
				//Delete workingCopy-Id - It will be set by getRestoreContext if we need to keep the working copy
				this.state.options["workingCopy-Id"] = null;
				// Page not reloaded we read the current working copy 
				return globals.getStorage().draftOperation("wrkcpyRead", id).then(function(data) {
					return $.smResolve(data, data != null ? "workingCopy" : null);
				});
			}
			// Nothing
			return $.smResolve(null);
		},
		/**
		 * Resolves with data or null
		 */
		loadFromDraft: function(draftId) {
			var self = this;
			return globals.getStorage().draftOperation("draftRead", draftId).then(function(ctx) {
				self.state.options["draft-id"] = null;
				return globals.getStorage().draftOperation("draftDelete", draftId).then(function() {
					var data = ctx ? ctx.dataSet : null;
					return $.smResolve(data, data != null ? "draft" : null);
				});
			}).fail(function(e) {
				return null;
			});
		},
		loadFromSData: function(loadOptions) {
			var self = this;
			// Force to read data in the cache to speed up rendering
			var forceUseCache = loadOptions.updateLayout || utils.forceUseCache();
			var dispatchOptions = {
				forceUseCache: forceUseCache
			};
			if (self.prototype.acceptServerPagination()) {
				// Tells the dispatcher to store locally the whole JSON of the page to be used in authoring mode 
				// If forceUseCache=true the pagination managed by the cache doesn't work the same way
				// cache is cleared when the page is destroyed
				dispatchOptions.$authCacheId = self.id;
			}
			return dispatcher.dispatch({
				$url: self._getFullSdataUrl(),
				$method: self.sDataMethod
			}, null, dispatchOptions).then(function(data) {
				if (!forceUseCache) {
					// if forceUseCache we don't know if we on/off line
					globals.setOffline(data != null && (data.$cache != null || data.$cacheHint != null));
				}
				return $.smResolve(data, "sdata");
			});
		},
		/**
		 * Lookup notification
		 * 		rowData:	Selected row data
		 * 		controlId:	Id of control to refresh
		 */
		notifLookupSelection: function(rowData, controlId) {
			if (!this.isActive()) return;
			Base.prototype.notifLookupSelection.call(this, rowData, controlId);
		},
		/** Event sm.action.link
		 *  Notified when a action succeeded - sdata link - see action manager
		 *  success:	true/false
		 *  link:		Link info
		 *  result:		Json response
		 */
		notifActionLink: function(success, link, result, options) {
			var self = this;
			if (!self.isActive()) return;
			try {
				var responseJSON = result ? result.responseJSON || {} : {};
				var _displayMessage = function(thereIsFieldErrors) {
					if (thereIsFieldErrors === true && success === true) {
						// No success message if fields errors
						return;
					}
					globals.getModal().displayActionMsg(success, link.name, self.prototype, responseJSON);
				};
				switch (link.name) {
					case "$save":
						self._doActSave(success, link, responseJSON, options);
						break;
					case "$delete":
						self.goBack().always(function() {
							_displayMessage();
						});
						break;
					case "$canceledit":
						self.checkBack(true).then(function() {
							if (self.$activity === "create") {
								self.reload();
							} else {
								var autoScroll = self.getScrollValue();
								self.goBack().then(function(newPage) {
									if (newPage) {
										// We stay at the same location - .8 because the height of the page is less in detail than edit
										// in actionManager we also preserve scrolling when we go from edit to detail
										setTimeout(function() {
											newPage.autoScroll(autoScroll * 0.8);
										});
									}
								});
							}
						});
						break;
					default:
						var thereIsFieldErrors = false;
						if (link.$isAction === true && responseJSON) {
							thereIsFieldErrors = self._myApplyChange(responseJSON);
						}
						var settings = self.actionGetSettings(link.name, "options");
						if (success === true && settings && settings.backIfSuccess === true) {
							self.goBack().then(function() {
								_displayMessage(thereIsFieldErrors);
							});
						} else if (settings && settings.refreshPage === true) {
							self.refresh({
								forceRefresh: true
							}).then(function() {
								_displayMessage(thereIsFieldErrors);
							});
						} else {
							_displayMessage(thereIsFieldErrors);
						}
						break;
				}
			} catch (e) {
				globals.getModal().error("notifActionLink failed", e);
			}
		},
		/**
		 * For right panel action we call standard applyChange that check DATA + META-DATA and refresh controls
		 * TODO - Use always this process after having removed the old _updateMeta in daoSData
		 * Return true if field errors
		 */
		_myApplyChange: function(responseJSON) {
			this.dao.applyChange(responseJSON, {
				$isPartialDelta: false,
				$isEditMode: this.isEditMode()
			});
			var errors = this.refreshControls(null, {
				refreshValue: true
			});
			if (errors.length > 0) {
				// Set focus on the first error field
				errors[0].setFocus();
			}
			if (this._gestureMgr) {
				// We need to adjust the scroller because line can be removed -> Make content visible
				this._gestureMgr.adjust();
			}
			return errors.length > 0;
		},
		/**
		 * Validate data before sending an action
		 */
		validateBeforeActionLink: function(link) {
			if (!link) return true;
			if (link.$method !== "POST" && link.$method !== "PUT") return true;
			return this.checkControlsData();
		},
		// Action on child pages
		_doActSave: function(success, link, responseJSON, options) {
			var self = this;
			if (success) {
				if (this._draftMgr) {
					this._draftMgr.setStatus(false);
				}
				self.dao.resetDirty();
				if (self.openedFromDashboard && self.$activity === "create") {
					// We open a create form from the dashboard - We stay on the page and relaod it to allow a new creation - No back
					// Displays diagnoses contained in response
					globals.getModal().displayActionMsg(success, link.title || link.name, self.prototype, responseJSON);
					self.reload();
				} else {
					self.goBack().always(function(dstPage) {
						// Displays diagnoses contained in response if any once the back page has been displayed
						globals.getModal().displayActionMsg(success, link.title || link.name, self.prototype, responseJSON);
						if (dstPage && dstPage.$activity === "create") {
							// If we stay on a create page we reload it - Create page inside the vignette - goBAck returns the initial $create page
							dstPage.reload();
						}
					});
				}
			} else {
				// !! We expect that input fields errors come always with success = false
				// We just update the meta to extract diagnoses
				if (self.dao.updateMeta(responseJSON)) {
					// Update controls - Display diagnoses
					var errors = self.refreshControls(null, {});
					if (errors.length > 0) {
						// Set focus on the first error field
						errors[0].setFocus();
					}
					if (self._gestureMgr) {
						// We need to adjust the scroller because line can be removed -> Make content visible
						self._gestureMgr.adjust();
					}
				}
				var diags = responseJSON ? responseJSON.$diagnoses : null;
				if (!diags || diags.length == 0) {
					// Unexpected
					diags = [{
						$message: locale.text("drafts.reason.error"),
						$severity: "error"
					}];
				}
				// Display global message
				globals.getModal().actionResult("Action: " + link.name, responseJSON);
				if (this._draftMgr) {
					this._draftMgr.setStatus(true, diags[0].$message);
				}
			}
		},
		/**
		 * True if scroll enabled in page
		 * edit/detail allows scroll in vignette
		 * query/lookup doesn't allow because scroll is done by the array
		 */
		scrollAllowed: function() {
			if (this.prototype.isQueryLikeFacet()) {
				// This is the array which scrolls
				return false;
			}
			return true;
		},
		/**
		 * Save a rowDetail dao (childDao) into the current dao
		 */
		notifRowdetailUpdate: function(info, arrayId) {
			if (!info) return;
			var childDao = info.dao;
			if (!childDao) return;
			// singleArrayRowIdx needed for single arrays
			var array = this.getControl(arrayId);
			if (!array) return;
			var create = info.activity === "create";
			var singleArrayRowIdx;
			if (!create && array.prototype.isSingleArray()) {
				// For single arrays we added a $uuid in arrayData to manage them as other arrays
				// When we update the dao we need to retreive the index from the uuid because there's no uuid in for theses row in parent dao
				singleArrayRowIdx = array.rowId2Idx(childDao.getValue("$uuid"));
			} // If not singleArray the row will be rtreive in parent from th uuid contained in childDao
			if (childDao.updateParentRow(create, singleArrayRowIdx)) {
				var errors = this.refreshControls([arrayId], {});
				if (errors.length > 0) {
					// Set focus on the firts error field
					errors[0].setFocus();
				}
			}
			// True to destroy the prototype
			// The prototype has been created with the row detail dao and we need them in parent page (here)
			// So we have to destroy them once we have updated the parent page dao (not destroyed when row detail page is destroyed)
			childDao.destroy(true);
		},
		/**
		 * Delete a row (data.uuid) in current dao - Row has been deleted by Delete footer action
		 */
		notifRowdetailDelete: function(data, arrayId) {
			if (!data || !data.uuid) return;
			var array = this.getControl(arrayId);
			if (!array) return;
			var rowidOrIdx = data.uuid;
			if (array.prototype.isSingleArray()) {
				rowidOrIdx = array.rowId2Idx(data.uuid);
			}
			// Remove the row in dao by idx or rowid 
			this.dao.deleteRow(array.$bind, rowidOrIdx);
			// Remove html identofied by uuid
			array.removeRow(data.uuid);
		},
		getPinPageId: function() {
			var self = this;
			return self.state.name + "_" + self.sDataUrl;
		},
		getPinPageData: function() {
			var self = this;
			var pageData = Base.prototype.getPinPageData.call(self);

			pageData.sDataUrl = self.sDataUrl;
			pageData.key = self.prototype.data("$key", self.dao);

			var pu = jsutils.parseURL(pageData.sDataUrl);
			var repr = pu.query.representation.split(".");
			pageData.representation = repr[0];
			pageData.facet = repr[1];
			pageData.action = repr[1];

			var ps = pu.path.split("/");
			pageData.entity = ps[5];
			pageData.endpoint = pu.path.split("/").slice(2, 5).join(".");

			var value = self.prototype.data("$value", self.dao);
			if (value) {
				pageData.title = self.prototype.data("$title") + " - " + value;
			}
			return pageData;
		},
		filterSortRead: function(type) {
			if (!this._filterSortAllowed()) return null;
			var id = this._filterInfoSaveId(type);
			if (!this._filterSortInfo) this._filterSortInfo = {};
			var info = this._filterSortInfo[id];
			if (info) return info;
			info = sessStorage.getItem(id);
			if (info) {
				try {
					info = JSON.parse(info);
					return info;
				} catch (e) {}
			}
			return null;
		},
		filterSortWrite: function(type, info, refresh) {
			if (!this._filterSortAllowed()) return null;
			var id = this._filterInfoSaveId(type);
			var save = false;
			if (info && info.length > 0) {
				var old = this.filterSortRead(type);
				if (old == null || !this._filterSortEquals(type, info, old)) {
					save = true;
				}
			} else {
				save = info != this._filterSortInfo[id];
			}
			if (save !== true) return;
			sessStorage.setItem(id, info ? JSON.stringify(info) : null);
			this._filterSortInfo[id] = info;
			if (refresh === true) {
				this._filterSortRefresh();
			}
		},
		searchRefresh: function() {
			this._filterSortRefresh();
		},
		searchInfoRead: function() {
			// Like it's a query lookup we assume that field's name is $resources
			// We need to know the id of array to apply the search clause at page loading when we restore the context (detail to list)
			if (!this._filterSortAllowed()) return;
			var field = this.getControlByBind("$resources");
			if (!field || !field.searchInfoGet) return null;
			var info = field.searchInfoGet();
			if (info == null || info.length == 0) return null;
			return info;
		},
		_filterSortRefresh: function() {
			if (!this._filterSortAllowed()) return;
			var ctrlArray = this.getControlByBind("$resources");
			if (!ctrlArray) return;
			var attrs = {
				"data-control-id": ctrlArray.id,
				"data-nav-target": this.isVignette ? "vignette" : "application",
				"data-nav-type": "filtersort"
			};
			// Set original URL - Remove pagination - Ex we change the filter/sort criteria in a pagination 
			this._initSdataInfo(null);
			setTimeout(function() {
				eventListener.triggerRefreshPage(ctrlArray.$$elmt, attrs);
			});
		},
		/**
		 * Only for query and lookup in current version
		 */
		_filterSortAllowed: function() {
			return this.prototype.isLookup() || this.prototype.isQuery();
		},
		_filterInfoSaveId: function(type) {
			if (!this._filterSortAllowed()) return;
			if (!this._filtersortUrlId) {
				this._filtersortUrlId = this._originalSdataUrl;
			}
			var id = this._filtersortUrlId + "#" + type;
			if (this.isVignette && this.getParentVignette()) {
				var vid = this.getParentVignette().vignetteId;
				if (vid) {
					id = vid + "#" + id;
				}
			}
			return id;
		},

		/*
		 * Check if sort or filter has changed
		 * This is just to detect changes to trigger a page reload
		 * If e.g. sort criterias are not change, the page will not be reloaded
		 */
		_filterSortEquals: function(type, info, old) {
			if (info == null || old == null) return true;
			if (type == "sort") {
				if (old.length != info.length) return false;
				for (var i = 0; i < info.length; i++) {
					if (info[i].sort !== old[i].sort) return false;
					if (info[i].field !== old[i].field) return false;
				}
				return true;
			} else if (type == "filter") {
				// Filters are hard to compare because the can change and still be logically the same
				// So we always asume changed filter conditions here
				return false;
			}
		},
		_filterSortUpdateUrl: function() {
			var self = this;
			var sdataUrl = jsutils.parseURL(self.sDataUrl);
			// Add filters describe in proto - the filter is selected by the user ($isDefault === true)
			var $f = this._$filterGetInfo();
			if ($f) {
				if (!sdataUrl.query) {
					sdataUrl.query = {};
				}
				if ($f.id === "nofilter") {
					delete sdataUrl.query.filter;
				} else {
					sdataUrl.query.filter = $f.id;
				}
			}
			if (!self._filterSortAllowed()) {
				return jsutils.urlToString(sdataUrl);
			}
			// Add filter/sort clause for Lookup and Query if any
			// build sort clause
			var sortClause = null;
			var info = self.filterSortRead("sort");
			if (info != null && info.length != 0) {
				info.some(function(i) {
					if (i.sort != "none") {
						sortClause = {
							order: i.sort,
							field: i.id
						};
						return true;
					}
				});
			}
			// build filter clause
			var filterClause = '';
			info = self.filterSortRead("filter");
			if (info != null && info.length != 0) {
				$.each(info, function(idx, filter) {
					var cf = '(' + filter.id + ' ' + (filter.operator === "like_s" ? "like" : filter.operator) + ' ' + _setFilterRightValue(filter) + ')';
					filterClause = filterClause.length == 0 ? cf : filterClause + ' and ' + cf;
				});
			}
			// build search clause
			var searchClause = '';
			var searchInfo = self.searchInfoRead();
			if (searchInfo) {
				$.each(searchInfo, function(idx, search) {
					var cf = '(' + search.id + ' ' + search.operator + ' ' + _setFilterRightValue(search) + ')';
					searchClause = searchClause.length == 0 ? cf : searchClause + ' or ' + cf;
				});
				if (searchClause) {
					searchClause = '(' + searchClause + ')';
				}
			}
			// apply sort clause
			if (!sortClause && !filterClause && !searchClause) return jsutils.urlToString(sdataUrl);;
			// sdataUrl.query.key != null means it's a pagination request
			// -> The pagination request contains already the sort criteria so we don't add them
			// -> Otherwise we add sort criteria to the request
			if (sortClause && sdataUrl.query.key == null) {
				var old = sdataUrl.query.orderBy;
				sdataUrl.query.orderBy = sortClause.field + ' ' + sortClause.order;
				if (old) sdataUrl.query.orderBy = ", " + old;
			}
			// apply filter clause
			if (filterClause && sdataUrl.query.key == null) {
				var old = sdataUrl.query.where;
				sdataUrl.query.where = filterClause;
				if (old) sdataUrl.query.where = old + ' and ' + sdataUrl.query.where;
			}

			// apply search clause
			if (searchClause && sdataUrl.query.key == null) {
				var old = sdataUrl.query.where;
				sdataUrl.query.where = searchClause;
				if (old) sdataUrl.query.where = old + ' and ' + sdataUrl.query.where;
			}

			return jsutils.urlToString(sdataUrl);
		},
		_$filterGetInfo: function() {
			if (this.$filtersGet().length === 0 || this._$filtersDisabled === true) return null;
			var f = null;
			this.$filtersGet().some(function(x) {
				if (x.$isDefault === true) {
					f = x;
					return true;
				}
			});
			return f;
		},
		/**
		 * List of filters given by the prototype ($filters)
		 */
		$filtersGet: function() {
			return this._$filters;
		},
		/**
		 * Select a filter
		 */
		$filtersSelect: function(filterId) {
			if (!this._$filters) return;
			this._$filtersDisabled = false;
			this._$filters.forEach(function(f) {
				f.$isDefault = false;
				if (filterId === f.id) {
					f.$isDefault = true;
				}
			});
			this._filterSortRefresh();
		},
		/**
		 * none/tabs/list
		 * Stored in $resources array
		 */
		$filtersGetAuthoring: function() {
			var c = this.getControlByBind("$resources");
			if (c && c.$filtersGetAuthoring) {
				return c.$filtersGetAuthoring();
			}
			return null;
		},
		setDao: function(dao) {
			Base.prototype.setDao.call(this, dao);
			this._multiSelectionLinks = this._protoLinks = this._toolbarLinks = null;
		},
		getMultiSelectionLinks: function() {
			var self = this;
			if (!self.prototype.isQuery()) return null;
			if (self._multiSelectionLinks == null) {
				self._multiSelectionLinks = [];
				var $links = self.getProtoLinks(),
					info, link;
				if ($links) {
					var actSettings;
					$.each($links, function(name, value) {
						if (!_checkLink(name, value) || value.$url == null || value.$url.length == 0) {
							return;
						}
						// Multiselection is given by authoring waiting for having this flaging the prototype
						actSettings = self.actionGetSettings(name);
						if (actSettings == null || (actSettings.options != null && actSettings.options.multiselection !== true)) {
							return;
						}
						info = $.extend({}, link, value);
						info.css = (info.css || "") + " s-m-ismultisel";
						if (actSettings && actSettings.icon != null) {
							info.icon = actSettings.icon.css;
						}
						self._multiSelectionLinks.push(info);
					});
				}
			}
			return self._multiSelectionLinks.length == 0 ? null : self._multiSelectionLinks;
		},
		/**
		 * onlyFooterHeader		true: 	take into account links with footerHeader property == true (defined by authoring on actions)
		 * onlyFooterHeader		false:	take into account all links
		 */
		hasFooterHeaderActions: function(onlyFooterHeader) {
			var tl = this.getToolbarLinks(globals.getSiteLayout().getDeviceType() === "smartphone" ? "header" : "footer");
			if (tl.length === 0) return false;
			if (onlyFooterHeader === true) {
				for (var i = 0; i < tl.length; i++) {
					if (tl[i].footerHeader === true) return true;
				}
				return false;
			} else {
				return tl.length > 0;
			}
		},
		/**
		 * Accept getProtoLinks("$query", $details"...)
		 */
		getProtoLinks: function() {
			var self = this;
			if (self._protoLinks == null) {
				var $links = $.extend(true, {}, self.prototype.data("$links", null, true), self.dao ? self.dao.getValue("$links") : null);
				self._protoLinks = {};
				var info, sdataInfo;
				if (this.prototype.isQuery()) {
					// This code is disabled - It adds the actions tied to the $resources for queries
					var queryLinks = this.prototype.getDataByPath("$properties.$resources.$item.$links");
					if (queryLinks) {
						$.extend(true, $links, queryLinks);
					}
				}
				$.each($links, function(name, info) {
					if (!_checkLink(name, info)) {
						return;
					}
					info.name = name;
					info.title = info.$title ? self.prototype.resolveExpression(info.$title) : "";
					info.icon = fontUtils.getIconByName(name);
					if (info.$type == null || info.$type.length !== 0 || info.$type === "application/json;vnd.sage=syracuse") {
						if (info.$url) {
							info.$parameters && $.each(info.$parameters, function(paramName, paramValue) {
								// PARAMETER_ESCAPING
								// If there are placeholders in a parameters value, we try to resolve them here
								// In any case, the result is encoded to ensure sdataUtils.getLinkInfo will not fail if there
								// are non valid characters in the url
								// As a result, in multiselection, eventually left over encoded placeholders need to be
								// unescaped and replaced later in the process (see multiSelectionMgr.js -> PARAMETER_ESCAPING)
								if (paramValue.indexOf("{") > -1 && self.dao) {
									var pv2 = self.prototype.resolveExpression(paramValue, self.dao);
									if (pv2 && pv2.length > 0) {
										paramValue = encodeURIComponent(pv2);
									} else {
										paramValue = encodeURIComponent(paramValue);
									}
								}
								info.$url = info.$url.replace("{" + paramName + "}", paramValue);
							});
							var urlParsed = self.prototype.resolveExpression(info.$url, self.dao, false, true);
							if (urlParsed.indexOf("/mobile1/") > -1) { // mobile1 means it's an sdata request
								sdataInfo = sdataUtils.getLinkInfo(info.$url, self.dao, true);
								if (!sdataInfo) return;
								$.extend(info, sdataInfo);
								if (info.$services) {
									info.$isAction = true;
								}
							} else {
								// Free type link (for maps)
								info.externalUrl = info.$url;
							}
						} else {
							// Force notification
							info.$isAction = true;
						}
						if (info.$uuid == null) {
							info.$uuid = utils.UUID();
						}
						info.css = info.css || [];
						if (info.$isHidden === true) info.css.push("hidden");
						if (info.$isDisabled === true) info.css.push("disabled");
						info.css = info.css.join(' ');
						self._protoLinks[name] = info;
						return;
					}
				});
			}
			if (arguments.length == 0) {
				return $.isEmptyObject(self._protoLinks) ? null : self._protoLinks;
			}
			var res;
			for (var i = 0; i < arguments.length; i++) {
				if (self._protoLinks[arguments[i]]) {
					if (res == null) res = {};
					res[arguments[i]] = self._protoLinks[arguments[i]];
				}
			}
			return res;

		},
		/**
		 * Return an array of link info according to toolbar
		 *		toolbar - can be "header", "footer", "actionpanel"
		 * !!! There's a hack in \lib\sdataStatelessHack._js that transform the original proto to put $actions in $links
		 * 		Set a $isAction = true for actions (false for $links)
		 */
		getToolbarLinks: function(toolbar, options) {
			var self = this;
			options = options || {};
			if (!self.dao) {
				// non regular pages
				return [];
			}
			if (self._toolbarLinks == null) self._toolbarLinks = {};
			var device = globals.getSiteLayout().getDeviceType();
			var facet = self.prototype.getFacet();
			var key = toolbar + device + facet;
			if (self._toolbarLinks[key]) return self._toolbarLinks[key];
			var links = self._toolbarLinks[key] = [];
			var $links = self.getProtoLinks();
			if ($links) {
				var lMap = _getLinkMap(toolbar, device, facet);
				var authSettings, forceFooterHeader;
				$.each($links, function(name, value) {
					// authSettings -> {multiselection:true/false, authSettings.footerHeader:true/false}
					authSettings = self.actionGetSettings(name) || {};
					if (!$.isEmptyObject(authSettings)) {
						// Customized icon - we clone value - Todo not needed ?
						value = $.extend(true, {}, value);
						if (authSettings.icon != null) {
							value.icon = authSettings.icon.css;
						}
						value.footerHeader = authSettings.options != null && authSettings.options.footerHeader === true;
					}
					// multiselection action are not displayed in panel or footer/header - Managed by multiselection manager
					if (authSettings.options && authSettings.options.multiselection === true) return;
					// forceFooterHeader only for tablet - TODO see how we could add action in smartphone header
					forceFooterHeader = value.footerHeader && (device !== "smartphone");
					if (forceFooterHeader !== true && toolbar !== "actionpanel" && !lMap[name]) {
						return;
					}
					if (toolbar === "actionpanel" && _excludeFromPanel(name, forceFooterHeader, value, facet)) {
						return;
					}
					links.push(value);
				});
			}
			return links;
		},
		getEmptyDao: function(proto) {
			return daoSdata.emptyDao(proto);
		},
		/**
		 * forcePromise: true for local use (dialog in cancelEdit)
		 */
		checkBack: function(forcePromise) {
			if (this._draftMgr) {
				return this._draftMgr.checkBack(forcePromise);
			}
			return forcePromise ? $.smResolve(true) : true;
		},
		/**
		 * True if the page is the same as state
		 */
		isSamePage: function(state) {
			return Base.prototype.isSamePage.call(this) && state.options && state.options["sdata-url"] === this.sDataUrl;
		}
	});

var _DraftMgr = function(page) {
	this._page = page;

	this.setStatus = function(error, reason) {
		// !! _status is also user as a class in draf list
		this._status = error == true ? "error" : "notsaved";
		this._statusReason = reason;
	};
	this.destroy = function() {
		this._page = null;
	};
	this.checkBack = function(forcePromise) {
		var self = this;
		if (!this._page.dao || !this._page.dao.isDirty) {
			return forcePromise ? $.smResolve(true) : true;
		}
		var modal = new modalSaveDraft.Modal(locale.text("draft.save"), locale.text("draft.save.info"));
		return modal.show().then(function(result) {
			result = result || {};
			if (result.action === "yes") {
				return self.save(result.comment);
			}
			return result === "cancel" ? false : true;
		});
	};
	this.save = function(comment) {
		var self = this;
		var uuid = jsutils.getPropByPath(self._page, "dao.data.$uuid");
		if (!uuid) return;
		var restoredCtx = self._page.getRestoreContext();
		restoredCtx.currentState.options["workingCopy-Id"] = null;
		restoredCtx.currentState.options["draft-id"] = uuid;
		if (!self._draftSaveLink) {
			var links = self._page.getProtoLinks();
			Object.keys(links).some(function(key) {
				if (key === "$save") {
					self._draftSaveLink = links[key];
					return true;
				}
			});
		}
		if (!self._draftSaveLink) return;
		var draftContext = {
			"id": uuid,
			"endpoint": globals.getEndpoint(),
			"representation": self._page.prototype.data("$representation"),
			"status": self._status,
			"reason": self._statusReason || locale.text("drafts.reason." + self._status),
			"title": self._page.prototype.data("$title") || "",
			"comment": comment || "",
			"restoredContext": restoredCtx,
			"dataSet": self._page.dao.data,
			"saveLink": self._draftSaveLink,
			"creation_date": utils.getCurISODateTime(new Date())
		};
		return globals.getStorage().draftOperation("draftSave", draftContext);
	};

	this.setStatus(false);
};
exports.isOfficeLink = _isOfficeLink;
exports.Page = _Page;