"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var Base = require('syracuse-tablet/html/js/pages/page').Page;
var globals = require('syracuse-tablet/html/js/helpers/globals');
var dispatcher = require('syracuse-tablet/html/js/sdata/sdataDispatcher');
var factory = require('syracuse-tablet/html/js/application/appFactory');
var daoSdata = require('syracuse-tablet/html/js/application/daoSdata');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var sessStorage = require('syracuse-tablet/html/js/storage/sessionStorage');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var native = require('syracuse-tablet/html/js/helpers/native/native');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var Gadget = require('syracuse-tablet/html/js/application/gadget').Klass;
var draftMgr = require('syracuse-tablet/html/js/pages/helpers/draftManager');
var pageHelpers = require('syracuse-tablet/html/js/pages/helpers/helpers');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');

/**
 * Page with representation and sdata back-end
 */
var _Page = utils.defineClass(
	function RegularPage($parent, state, prototype, article, options) {
		if (options.breadcrumbs == null) {
			// Show breadcrumbs by default if not hidden by child class
			options.breadcrumbs = true;
		}
		Base.call(this, $parent, state, prototype, article, options);
		// Gadget is created her because this.state must contain only JSON (restore context)
		this.gadget = this.state.options.gadget ? new Gadget(this.state.options.gadget) : null;
		this.openedFromDashboard = this.gadget != null;
		this._originalSdataUrl = this.state.options["sdata-url"];
		if (!this._originalSdataUrl) {
			if (this.gadget) {
				this._originalSdataUrl = this.gadget.getSDataUrl(this.prototype);
			} else {
				this._originalSdataUrl = this.prototype.data("$url");
			}
		}
		this._init$Filters();
		this._initSdataInfo();
		notifications.subscribe(this, ["sm.rowdetail.update", "sm.rowdetail.delete", "sm.action.link"], 1);
		var url = this.prototype.data("$url");
		var facet;
		if (url && url.length > 0) {
			facet = sdataUtils.parseSDataURL(url).facet;
		} else if (this.parentPage) {
			facet = this.parentPage.$facet;
		}
		// Override the standard "display" activity
		if (facet) {
			this.$facet = facet;
			this.setActivity(facet === "edit" ? "edit" : facet === "create" ? "create" : "read");
		}
		// Working copy is managed only if nativeApp because it is used to restore the context on nativeAppClosing/nativeAppResume events
		// Disabled temporarily for rowDetail see class
		this.enableWorkingCopy = this.isEditMode() && native.hasCapability("nativeApp") && !this.isChild;
		if (this.isEditMode() && !this.isChild) {
			this._draftMgr = new draftMgr.Klass(this);
		}
		this.representation = this.prototype.data("$representation");
	}, Base, {
		_init$Filters: function() {
			var savedCtx = this.getSavedContext();
			// Rstoration of sort/filter if any (only if page is restored from a link)
			if (savedCtx && savedCtx.sortInfo) {
				this.filterSortWrite("sort", savedCtx.sortInfo);
			}
			if (savedCtx && savedCtx.filterInfo) {
				this.filterSortWrite("filter", savedCtx.filterInfo);
			}
			// Restore the selected $filters (filters given by prototype)
			var $filterId = savedCtx ? savedCtx.$filterId : null;
			this._$filters = [{
				id: "nofilter",
				$title: locale.text("nofilter")
			}];
			// Authoring on filters - none/list/tabs
			var auth = this.$filtersGetAuthoring();
			var filters = $.extend(true, {}, this.prototype.data("$filters"));
			if (auth === "none" || !filters || $.isEmptyObject(filters)) {
				this._$filtersDisabled = true;
				return;
			}
			var defFilter = null;
			for (var p in filters) {
				var ttl = this.prototype.resolveExpression(filters[p].$title);
				if (ttl) {
					var f = $.extend(true, {}, filters[p]);
					f.$title = ttl;
					f.id = p;
					f.$isDefault = false;
					if ($filterId && f.id === $filterId) {
						defFilter = f;
					} else if (!defFilter && f.$isDefault === true) {
						defFilter = f;
					}
					this._$filters.push(f);
				}
			}
			if (this._$filters.length == 0) return;
			if (defFilter) {
				defFilter.$isDefault = true;
			} else {
				this._$filters[0].$isDefault = true;
			}
		},

		/**
		 *  Init sdata url - Called in constructor and page refresh
		 * 	sdataUrl is optional in case of a gadget (to see with Mathias)
		 *  Can be overridden - rowdetail
		 */
		_initSdataInfo: function(sdataUrl) {
			if (!sdataUrl) sdataUrl = this._originalSdataUrl;
			if (this.gadget) {
				var params = this.gadget.getParameters();
				if (params.where) {
					sdataUrl = sdataUtils.addWhereClause(sdataUrl, params.where, this.state.options.sdataParameters);
				}
			}
			if (!sdataUrl) throw new Error("$url (sDataUrl) is expected");
			this.state.options["sdata-url"] = this.sDataUrl = sdataUrl;
			this.sDataMethod = this.state.options["sdata-method"] || "GET";
		},
		getOriginalSdataUrl: function() {
			return this._originalSdataUrl;
		},
		destroy: function() {
			if (this.destroyed) return;
			if (this._draftMgr) {
				this._draftMgr.destroy();
				this._draftMgr = null;
			}
			if (this.prototype && !this.prototype.isLookup()) {
				var keepWorkingCopy = this.enableWorkingCopy === true && this.state.options["workingCopy-Id"];
				if (!this.isVignette && !keepWorkingCopy && !this.isChild) {
					// Delete all the working copies because not needed any more - Page will not be restored
					globals.getStorage().draftOperation("wrkcpyDeleteAll");
				} else if (this.isVignette && !keepWorkingCopy && this.dao && this.dao.workingCopyGetId()) {
					// in a dashboard with multiple create/edit facest we just delete the current WorkingCopy (transaction) because we don't know if other pages will be restored
					globals.getStorage().draftOperation("wrkcpyDelete", this.dao.workingCopyGetId());
				}
			}
			if (this.prototype && this.prototype.acceptServerPagination() && !globals.isAuthoringActive()) {
				// Clear the cache used by authoring for this page - Only if authoring not active
				// On a dashboard when we change an authoring property the page is destroyed and recreated so we don't destroy the cache
				notifications.publish("sm.authcache.destroy", this.id);
			}
			Base.prototype.destroy.call(this);
			if (this._editTemplatesPanel) {
				this._editTemplatesPanel.destroy();
				this._editTemplatesPanel = null;
			}
			this.gadget = null;
		},
		/**
		 * True if the page is the same as state
		 */
		isSamePage: function(state) {
			return Base.prototype.isSamePage.call(this) && state && state.options && state.options["sdata-url"] === this.sDataUrl;
		},
		initOnLoad: function() {
			// TODO: Load filter settings
		},
		beforeAddContent: function() {
			if (false && !this.isVignette) {
				// #5583 - disabled because redundant with header title
				var ttl = this.prototype.data("$title");
				this.addTitle(globals.getApplication().getTitle() + (ttl ? " - " + ttl : ""));
			}
		},
		afterRender: function(loadOptions, buildOpts) {
			var self = this;
			return Base.prototype.afterRender.call(self, loadOptions, buildOpts).then(function() {
				if (self.isVignette) return;
				var diags = self.dao && self.dao.data && self.dao.data.$diagnoses;
				if (diags && diags.length > 0) {
					diags.forEach(function(diag) {
						var notify = {
							severityClass: globals.X3_SEVERITY_TO_BS[diag.$severity] || diag.$severity || "error",
							title: diag.$message
						};
						globals.getModal().notify(notify);
					});
				}
			});
		},
		activate: function(pageToClose, cb) {
			Base.prototype.activate.call(this, pageToClose, cb);
			// !!! Notification is called (not on loadData) here because we the current page should be activated to trigger the notification event
			notifications.publish("sm.data.freshness.change", this.dao.dataFreshness());
		},
		/**
		 * Used by html builder to create a link to full page
		 */
		getOpenLinkAttrs: function() {
			var res = Base.prototype.getOpenLinkAttrs.call(this);
			res["data-sdata-url"] = this.sDataUrl;
			res["data-sdata-method"] = this.sDataMethod;
			res["data-gadget-id"] = this.gadget.data("$uuid");
			return res;
		},

		/**
		 * Refresh the page - Specific to pageRegular - The standard method is page.reload
		 * Manages specific options ( TODO override reload)
		 * 	Called from a vignette or full page (callBackInterface)
		 * 	options.sdata-url -> New url
		 * 	options.controlId!=null -> refresh the control
		 *  options.type Type of refresh (pagination...)
		 *  callBackInterface
		 *  	waitStop(ctrlId) / waitStart(ctrlId)
		 */
		refresh: function(options, callBackInterface) {
			var self = this;
			options = options || {};
			var deferred = $.Deferred();
			var url = options["sdata-url"];
			var controlId = options["controlId"];
			var type = options.type || "";
			var force = type === "filtersort" || options.forceRefresh === true;
			var _wait = function(status) {
				var suffix = self["wait" + status.smCapitalize()];
				if (callBackInterface) {
					var meth = self["wait" + suffix];
					if (meth) {
						callBackInterface[meth].call(null, controlId);
					}
				} else {
					var meth = self["waitWheel" + suffix];
					if (meth) {
						meth.call(self, controlId);
					}
				}
			};
			try {
				var _succeeded = function() {
					_wait("stop");
					self.refreshControls(controlId ? [controlId] : null, options);
					deferred.resolve();
				};
				if (!url && force !== true) {
					_succeeded();
				} else {
					_wait("start");
					if (url) {
						/* url can change on refresh (paginations)*/
						self._initSdataInfo(url);
					}
					self.loadData({
						refresh: true
					})
						.then(function() {
							_succeeded();
						}).fail(function(e) {
							_wait("stop");
							deferred.reject(e);
						});
				}
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},
		/**
		 * Url with where clause
		 */
		_getFullSdataUrl: function() {
			return this._filterSortAllowed() ? this._filterSortUpdateUrl() : this.sDataUrl;
		},
		/**
		 * reason: nativeAppClosing, pinPage, sharedLink...
		 */
		getRestoreContext: function(reason) {
			var ctx = Base.prototype.getRestoreContext.call(this, reason);
			if (!ctx) return ctx;
			if (this.state.options.sdataParameters) {
				ctx.currentState.options["sdataParameters"] = this.state.options.sdataParameters;
			}
			ctx.currentState.options["sdata-url"] = this.sDataUrl;
			if (this.dao && reason === "nativeAppClosing" && this.enableWorkingCopy === true) {
				ctx.currentState.options["workingCopy-Id"] = this.dao.workingCopyGetId(true);
			}
			return ctx;
		},
		savedCtxCreate: function(type) {
			var ctx = Base.prototype.savedCtxCreate.call(this, type);
			var $f = this._$filterGetInfo();
			// Save $filter info to restore it
			ctx.$filterId = $f && $f.id;
			if (type != "link" || !this._filterSortAllowed()) {
				return ctx;
			}
			// For a link context we save the filterSortInfo
			// -> By default this info is saved in sessionStorage (user prefs)
			ctx.sortInfo = this.filterSortRead("sort");
			ctx.filterInfo = this.filterSortRead("filter");
			return ctx;
		},
		loadData: function(loadOptions) {
			var self = this;
			loadOptions = loadOptions || {};
			var step;
			var enableWorkingCopy = this.enableWorkingCopy === true;
			// If the page is opened with state.options.draft-id we try to read the draft (used by editDraft action)
			if (loadOptions.reload !== true && this.state.options["draft-id"] && self._draftMgr) {
				// First
				step = self._draftMgr.loadFromDraft(this.state.options["draft-id"]);
			} else if (enableWorkingCopy) {
				// If the page is opened with state.options.workingCopy-Id" we try to read the workng copy (used when we restore a context)
				step = self.loadCheckWorkingCopy(loadOptions);
			} else {
				// Read data from sdata dispatcher (server or sdata cache)
				step = $.smResolve(null);
			}
			return step.then(function(data, loadedFrom) {
				if (data) return $.smResolve(data, loadedFrom);
				return self.loadFromSData(loadOptions);
			}).then(function(data, loadedFrom) {
				// Eventually to put an icon/info to let the user know
				if (self.destroyed) {
					// Security - Page can be destroyed while loading in dashboard  
					return;
				}
				data = self._processSdataParams(data);
				self._dataLoadedFrom = loadedFrom;
				// If no json returned we create en empty dao
				self.setDao(data ? factory.createDaoSdata(data, self.prototype, {
					enableWorkingCopy: enableWorkingCopy
				}) : self.getEmptyDao(self.prototype));
				if (loadOptions.refresh === true) {
					// Only on page refresh otherwise see activate method - next/previous datas in grid...
					notifications.publish("sm.data.freshness.change", self.dao.dataFreshness());
				}
				if (loadedFrom === "workingCopy") {
					// To force save button enabled and ask user to save draft
					self.dao.setDirty();
				}
				if (loadedFrom === "draft") {
					// Remove the draft id - A new one will be created if the form is saved again or reloaded
					self.state.options["draft-id"] = null;
					// !! No dao.setDirty because if user click back he goes back to list (no dialog)
					// We enable only save button with getLinksInitStatus and keep dao not dirty
				}
				if (self._draftMgr) {
					self._draftMgr.notifDataLoaded();
				}
			});
		},
		// #7811 - take into account the sdataParameter to update the create facte dao with selected values
		// TODO - Finalize
		_processSdataParams: function(data) {
			if (this.$activity !== "create" || this.gadget == null) return data;
			var params = this.gadget.getParameters();
			if (!params || !params.context) return data;
			if ($.isEmptyObject(this.state.options.sdataParameters)) return data;
			var ctx = {}, prop, val, suffix, fldName;
			for (var p in params.context) {
				// To improve - Just a proof of concept
				fldName = p + "_REF";
				prop = this.prototype.property(fldName);
				if (prop) {
					// Add the value
					val = utils.parseExpression(params.context[p], this.state.options.sdataParameters);
					if (prop.$type === "application/x-reference") {
						ctx[fldName] = {
							"$value": val
						};
						ctx[p] = val;
					} else {
						val = fieldOperators.checkValue(prop.$type, val);
						ctx[p] = val;
					}
				}
			}
			return $.isEmptyObject(ctx) ? data : $.extend(data, ctx);
		},
		/**
		 * Returns the status of save/showTemplates link to enable/disable the button when header/footer is created
		 * See ctrlHelpers.checkLinkInitStatus
		 */
		getLinksInitStatus: function() {
			var self = this;
			if (!self.dao || self.destroyed) {
				return $.smResolve(null);
			}
			var res = {
				dirtyDao: {
					// We force true if the page is loaded from a draft because the user can save without having modified the page
					isDirty: self.dao.isDirty || self._dataLoadedFrom === "draft",
					$uuid: self.dao.data.$uuid
				}
			};
			var ep = globals.getEndpoint();
			return globals.getStorage().templateOperation("count", ep, self.representation).then(function(count) {
				res.editTemplates = {
					count: count,
					getendpoint: ep,
					representation: self.representation
				};
				return res;
			});
		},
		/**
		 * Resolves with data or null
		 * Null -> Data are loaded from sData dispatcher
		 */
		loadCheckWorkingCopy: function(loadOptions) {
			if (loadOptions.reload === true) {
				// Page reloaded we delete the current working copy 
				// No need to wait - wrkcpyDelete resolves with true/false
				if (this.dao && this.dao.workingCopyGetId()) {
					globals.getStorage().draftOperation("wrkcpyDelete", this.dao.workingCopyGetId());
				}
				return $.smResolve(null);
			} else if (this.state.options["workingCopy-Id"]) {
				var id = this.state.options["workingCopy-Id"];
				//Delete workingCopy-Id - It will be set by getRestoreContext if we need to keep the working copy
				this.state.options["workingCopy-Id"] = null;
				// Page not reloaded we read the current working copy 
				return globals.getStorage().draftOperation("wrkcpyRead", id).then(function(data) {
					return $.smResolve(data, data != null ? "workingCopy" : null);
				});
			}
			// Nothing
			return $.smResolve(null);
		},
		loadFromSData: function(loadOptions) {
			var self = this;
			// Force to read data in the cache to speed up rendering
			var forceUseCache = loadOptions.updateLayout || utils.forceUseCache();
			var dispatchOptions = {
				forceUseCache: forceUseCache
			};
			if (self.prototype.acceptServerPagination()) {
				// Tells the dispatcher to store locally the whole JSON of the page to be used in authoring mode 
				// If forceUseCache=true the pagination managed by the cache doesn't work the same way
				// cache is cleared when the page is destroyed
				dispatchOptions.$authCacheId = self.id;
			}
			return dispatcher.dispatch({
				$url: self._getFullSdataUrl(),
				$method: self.sDataMethod
			}, null, dispatchOptions).then(function(data) {
				if (!forceUseCache) {
					// if forceUseCache we don't know if we on/off line
					globals.setOffline(data != null && (data.$cache != null || data.$cacheHint != null));
				}
				return $.smResolve(data, "sdata");
			});
		},
		/**
		 * Lookup notification
		 * 		rowData:	Selected row data
		 * 		controlId:	Id of control to refresh
		 */
		notifLookupSelection: function(rowData, controlId) {
			if (!this.isActive()) return;
			Base.prototype.notifLookupSelection.call(this, rowData, controlId);
		},
		/** Event sm.action.link
		 *  Notified when a action succeeded - sdata link - see action manager
		 *  success:	true/false
		 *  link:		Link info
		 *  result:		Json response
		 */
		notifActionLink: function(success, link, result, options) {
			var self = this;
			if (!self.isActive()) return;
			try {
				result = result || {};
				result.responseJSON = result.responseJSON || {};
				var _displayMessage = function(thereIsFieldErrors) {
					if (thereIsFieldErrors === true && success === true) {
						// No success message if fields errors
						return;
					}
					globals.getModal().displayActionMsg(success, link.name, self.prototype, result.responseJSON);
				};
				switch (link.name) {
					case "$save":
						self._doActSave(success, link, result, options);
						break;
					case "$delete":
						self.goBack().always(function() {
							_displayMessage();
						});
						break;
					case "$canceledit":
						self.checkBack().then(function(kontinue) {
							if (kontinue != true) {
								// Process stopped because user canced saveDraft action - We stay on the form
								return;
							}
							// If data loaded from draft we go back to draft list
							if (self.$activity === "create" && self._dataLoadedFrom !== "draft") {
								self.reload();
							} else {
								// To avoid chekBack to display save draft
								self.dao.resetDirty();
								var autoScroll = self.getScrollValue();
								self.goBack().then(function(newPage) {
									if (newPage == null || self._dataLoadedFrom === "draft") return;
									// Cancel in edit facet - We try to keep the scrolling of the page
									// We stay at the same location - .8 because the height of the page is less in detail than edit
									// in actionManager we also preserve scrolling when we go from edit to detail
									setTimeout(function() {
										newPage.autoScroll(autoScroll * 0.8);
									});
								});
							}
						});
						break;
					case "$showtemplates":
						if (!this._editTemplatesPanel) {
							this._editTemplatesPanel = this.panelCreate(globals.PANELEDITTEMPLATES, {});
						}
						this.panelAttach("right", this._editTemplatesPanel, "toggle");
						break;
					default:
						var thereIsFieldErrors = false;
						if (link.$isAction === true && result.responseJSON) {
							thereIsFieldErrors = self._myApplyChange(result.responseJSON);
						}
						var settings = self.actionGetSettings(link.name, "options");
						if (success === true && settings && settings.backIfSuccess === true) {
							self.goBack().then(function() {
								_displayMessage(thereIsFieldErrors);
							});
						} else if (settings && settings.refreshPage === true) {
							self.refresh({
								forceRefresh: true
							}).then(function() {
								_displayMessage(thereIsFieldErrors);
							});
						} else {
							_displayMessage(thereIsFieldErrors);
						}
						break;
				}
			} catch (e) {
				globals.getModal().error("notifActionLink failed", e);
			}
		},
		/**
		 * For right panel action we call standard applyChange that check DATA + META-DATA and refresh controls
		 * TODO - Use always this process after having removed the old _updateMeta in daoSData
		 * Return true if field errors
		 */
		_myApplyChange: function(responseJSON) {
			this.dao.applyChange(responseJSON, {
				$isPartialDelta: false,
				$isEditMode: this.isEditMode()
			});
			var errors = this.refreshControls(null, {
				refreshValue: true
			});
			if (errors.length > 0) {
				// Set focus on the first error field
				errors[0].setFocus();
			}
			if (this._gestureMgr) {
				// We need to adjust the scroller because line can be removed -> Make content visible
				this._gestureMgr.adjust();
			}
			return errors.length > 0;
		},
		/**
		 * Validate data before sending an action
		 */
		validateBeforeActionLink: function(link) {
			if (!link) return true;
			if (link.$method !== "POST" && link.$method !== "PUT") return true;
			return this.checkControlsData();
		},
		// Action on child pages
		_doActSave: function(success, link, result, options) {
			var self = this;
			if (success) {
				// To not ask the user to save as draft when page change
				self.dao.resetDirty();
				var step;
				if (self._draftMgr) {
					// Removes the current draft
					step = self._draftMgr.notifSaveSucceeded(result);
				} else {
					step = $.smResolve();
				}
				step.always(function() {
					if (self.openedFromDashboard && self.$activity === "create") {
						// When we open a create form from the dashboard we stay on the page and relaod it to allow a new creation - No back
						// Displays diagnoses contained in response
						globals.getModal().displayActionMsg(success, link.title || link.name, self.prototype, result.responseJSON);
						self.reload();
					} else {
						self.goBack().always(function(dstPage) {
							// Displays diagnoses contained in response if any once the back page has been displayed
							globals.getModal().displayActionMsg(success, link.title || link.name, self.prototype, result.responseJSON);
							if (dstPage && dstPage.$activity === "create") {
								// If we stay on a create page we reload it - Create page inside the vignette - goBAck returns the initial $create page
								dstPage.reload();
							}
						});
					}
				});
			} else {
				// !! We expect that input fields errors come always with success = false
				// We just update the meta to extract diagnoses
				if (self.dao.updateMeta(result.responseJSON)) {
					// Update controls - Display diagnoses
					var errors = self.refreshControls(null, {});
					if (errors.length > 0) {
						// Set focus on the first error field
						errors[0].setFocus();
					}
					if (self._gestureMgr) {
						// We need to adjust the scroller because line can be removed -> Make content visible
						self._gestureMgr.adjust();
					}
				}
				if (self._draftMgr == null || self._draftMgr.notifSaveFailed(result)) {
					// Display global message
					globals.getModal().actionResult(locale.text("action.save.failed"), result.responseJSON);
				}
			}
		},
		/**
		 * True if scroll enabled in page
		 * edit/detail allows scroll in vignette
		 * query/lookup doesn't allow because scroll is done by the array
		 */
		scrollAllowed: function() {
			if (this.prototype.isQueryLikeFacet()) {
				// This is the array which scrolls
				return false;
			}
			return true;
		},
		/**
		 * Save a rowDetail dao (childDao) into the current dao
		 */
		notifRowdetailUpdate: function(info, arrayId) {
			if (!info) return;
			var childDao = info.dao;
			if (!childDao) return;
			// singleArrayRowIdx needed for single arrays
			var array = this.getControl(arrayId);
			if (!array) return;
			var create = info.activity === "create";
			var singleArrayRowIdx;
			if (!create && array.prototype.isSingleArray()) {
				// For single arrays we added a $uuid in arrayData to manage them as other arrays
				// When we update the dao we need to retreive the index from the uuid because there's no uuid in for theses row in parent dao
				singleArrayRowIdx = array.rowId2Idx(childDao.getValue("$uuid"));
			} // If not singleArray the row will be rtreive in parent from th uuid contained in childDao
			if (childDao.updateParentRow(create, singleArrayRowIdx)) {
				var errors = this.refreshControls([arrayId], {});
				if (errors.length > 0) {
					// Set focus on the firts error field
					errors[0].setFocus();
				}
			}
			// True to destroy the prototype
			// The prototype has been created with the row detail dao and we need them in parent page (here)
			// So we have to destroy them once we have updated the parent page dao (not destroyed when row detail page is destroyed)
			childDao.destroy(true);
		},
		/**
		 * Delete a row (data.uuid) in current dao - Row has been deleted by Delete footer action
		 */
		notifRowdetailDelete: function(data, arrayId) {
			if (!data || !data.uuid) return;
			var array = this.getControl(arrayId);
			if (!array) return;
			var rowidOrIdx = data.uuid;
			if (array.prototype.isSingleArray()) {
				rowidOrIdx = array.rowId2Idx(data.uuid);
			}
			// Remove the row in dao by idx or rowid 
			this.dao.deleteRow(array.$bind, rowidOrIdx);
			// Remove html identofied by uuid
			array.removeRow(data.uuid);
		},
		getPinPageId: function() {
			return this.state.name + "_" + this.sDataUrl;
		},
		getPinPageData: function() {
			var self = this;
			var pageData = Base.prototype.getPinPageData.call(self);

			pageData.sDataUrl = self.sDataUrl;
			pageData.key = self.prototype.data("$key", self.dao);

			var pu = jsutils.parseURL(pageData.sDataUrl);
			var repr = pu.query.representation.split(".");
			pageData.representation = repr[0];
			pageData.facet = repr[1];
			pageData.action = repr[1];

			var ps = pu.path.split("/");
			pageData.entity = ps[5];
			pageData.endpoint = pu.path.split("/").slice(2, 5).join(".");

			var value = self.prototype.data("$value", self.dao);
			if (value) {
				pageData.title = self.prototype.data("$title") + " - " + value;
			}
			return pageData;
		},
		filterSortRead: function(type) {
			if (!this._filterSortAllowed()) return null;
			var id = this._filterInfoSaveId(type);
			if (!this._filterSortInfo) this._filterSortInfo = {};
			var info = this._filterSortInfo[id];
			if (info) return info;
			info = sessStorage.getItem(id);
			if (info) {
				try {
					info = JSON.parse(info);
					return info;
				} catch (e) {}
			}
			return null;
		},
		filterSortWrite: function(type, info, refresh) {
			if (!this._filterSortAllowed()) return null;
			var id = this._filterInfoSaveId(type);
			var save = false;
			if (info && info.length > 0) {
				var old = this.filterSortRead(type);
				if (old == null || !this._filterSortEquals(type, info, old)) {
					save = true;
				}
			} else {
				save = info != this._filterSortInfo[id];
			}
			if (save !== true) return;
			sessStorage.setItem(id, info ? JSON.stringify(info) : null);
			this._filterSortInfo[id] = info;
			if (refresh === true) {
				this._filterSortRefresh();
			}
		},
		searchRefresh: function() {
			this._filterSortRefresh();
		},
		searchInfoRead: function() {
			// Like it's a query lookup we assume that field's name is $resources
			// We need to know the id of array to apply the search clause at page loading when we restore the context (detail to list)
			if (!this._filterSortAllowed()) return;
			var field = this.getControlByBind("$resources");
			if (!field || !field.searchInfoGet) return null;
			var info = field.searchInfoGet();
			if (info == null || info.length == 0) return null;
			return info;
		},
		_filterSortRefresh: function() {
			if (!this._filterSortAllowed()) return;
			var ctrlArray = this.getControlByBind("$resources");
			if (!ctrlArray) return;
			var attrs = {
				"data-control-id": ctrlArray.id,
				"data-nav-target": this.isVignette ? "vignette" : "application",
				"data-nav-type": "filtersort"
			};
			// Set original URL - Remove pagination - Ex we change the filter/sort criteria in a pagination 
			this._initSdataInfo(null);
			setTimeout(function() {
				eventListener.triggerRefreshPage(ctrlArray.$$elmt, attrs);
			});
		},
		/**
		 * Only for query and lookup in current version
		 */
		_filterSortAllowed: function() {
			return this.prototype.isLookup() || this.prototype.isQuery();
		},
		_filterInfoSaveId: function(type) {
			if (!this._filterSortAllowed()) return;
			if (!this._filtersortUrlId) {
				this._filtersortUrlId = this._originalSdataUrl;
			}
			var id = this._filtersortUrlId + "#" + type;
			if (this.isVignette && this.getParentVignette()) {
				var vid = this.getParentVignette().vignetteId;
				if (vid) {
					id = vid + "#" + id;
				}
			}
			return id;
		},

		/*
		 * Check if sort or filter has changed
		 * This is just to detect changes to trigger a page reload
		 * If e.g. sort criterias are not change, the page will not be reloaded
		 */
		_filterSortEquals: function(type, info, old) {
			if (info == null || old == null) return true;
			if (type == "sort") {
				if (old.length != info.length) return false;
				for (var i = 0; i < info.length; i++) {
					if (info[i].sort !== old[i].sort) return false;
					if (info[i].field !== old[i].field) return false;
				}
				return true;
			} else if (type == "filter") {
				// Filters are hard to compare because the can change and still be logically the same
				// So we always asume changed filter conditions here
				return false;
			}
		},
		_filterSortUpdateUrl: function() {
			var self = this;
			var sdataUrl = jsutils.parseURL(self.sDataUrl);
			// Add filters describe in proto - the filter is selected by the user ($isDefault === true)
			var $f = this._$filterGetInfo();
			if ($f) {
				if (!sdataUrl.query) {
					sdataUrl.query = {};
				}
				if ($f.id === "nofilter") {
					delete sdataUrl.query.filter;
				} else {
					sdataUrl.query.filter = $f.id;
				}
			}
			if (!self._filterSortAllowed()) {
				return jsutils.urlToString(sdataUrl);
			}
			// Add filter/sort clause for Lookup and Query if any
			// build sort clause
			var sortClause = null;
			var info = self.filterSortRead("sort");
			if (info != null && info.length != 0) {
				info.some(function(i) {
					if (i.sort != "none") {
						sortClause = {
							order: i.sort,
							field: i.id
						};
						return true;
					}
				});
			}
			// build filter clause
			var filterClause = '';
			info = self.filterSortRead("filter");
			if (info != null && info.length != 0) {
				$.each(info, function(idx, filter) {
					var cf = '(' + filter.id + ' ' + (filter.operator === "like_s" ? "like" : filter.operator) + ' ' + pageHelpers.setFilterRightValue(filter) + ')';
					filterClause = filterClause.length == 0 ? cf : filterClause + ' and ' + cf;
				});
			}
			// build search clause
			var searchClause = '';
			var searchInfo = self.searchInfoRead();
			if (searchInfo) {
				$.each(searchInfo, function(idx, search) {
					var cf = '(' + search.id + ' ' + search.operator + ' ' + pageHelpers.setFilterRightValue(search) + ')';
					searchClause = searchClause.length == 0 ? cf : searchClause + ' or ' + cf;
				});
				if (searchClause) {
					searchClause = '(' + searchClause + ')';
				}
			}
			// apply sort clause
			if (!sortClause && !filterClause && !searchClause) return jsutils.urlToString(sdataUrl);;
			// sdataUrl.query.key != null means it's a pagination request
			// -> The pagination request contains already the sort criteria so we don't add them
			// -> Otherwise we add sort criteria to the request
			if (sortClause && sdataUrl.query.key == null) {
				var old = sdataUrl.query.orderBy;
				sdataUrl.query.orderBy = sortClause.field + ' ' + sortClause.order;
				if (old) sdataUrl.query.orderBy = ", " + old;
			}
			// apply filter clause
			if (filterClause && sdataUrl.query.key == null) {
				var old = sdataUrl.query.where;
				sdataUrl.query.where = filterClause;
				if (old) sdataUrl.query.where = old + ' and ' + sdataUrl.query.where;
			}

			// apply search clause
			if (searchClause && sdataUrl.query.key == null) {
				var old = sdataUrl.query.where;
				sdataUrl.query.where = searchClause;
				if (old) sdataUrl.query.where = old + ' and ' + sdataUrl.query.where;
			}

			return jsutils.urlToString(sdataUrl);
		},
		_$filterGetInfo: function() {
			if (this.$filtersGet().length === 0 || this._$filtersDisabled === true) return null;
			var f = null;
			this.$filtersGet().some(function(x) {
				if (x.$isDefault === true) {
					f = x;
					return true;
				}
			});
			return f;
		},
		/**
		 * List of filters given by the prototype ($filters)
		 */
		$filtersGet: function() {
			return this._$filters;
		},
		/**
		 * Select a filter
		 */
		$filtersSelect: function(filterId) {
			if (!this._$filters) return;
			this._$filtersDisabled = false;
			this._$filters.forEach(function(f) {
				f.$isDefault = false;
				if (filterId === f.id) {
					f.$isDefault = true;
				}
			});
			this._filterSortRefresh();
		},
		/**
		 * none/tabs/list
		 * Stored in $resources array
		 */
		$filtersGetAuthoring: function() {
			var c = this.getControlByBind("$resources");
			if (c && c.$filtersGetAuthoring) {
				return c.$filtersGetAuthoring();
			}
			return null;
		},
		setDao: function(dao) {
			Base.prototype.setDao.call(this, dao);
			this._multiSelectionLinks = this._protoLinks = this._toolbarLinks = null;
		},
		getMultiSelectionLinks: function() {
			var self = this;
			if (!self.prototype.isQuery()) return null;
			if (self._multiSelectionLinks == null) {
				self._multiSelectionLinks = [];
				var $links = self.getProtoLinks(),
					info, link;
				if ($links) {
					var actSettings;
					$.each($links, function(name, value) {
						if (!pageHelpers.checkLink(name, value) || value.$url == null || value.$url.length == 0) {
							return;
						}
						// Multiselection is given by authoring waiting for having this flaging the prototype
						actSettings = self.actionGetSettings(name);
						if (actSettings == null || (actSettings.options != null && actSettings.options.multiselection !== true)) {
							return;
						}
						info = $.extend({}, link, value);
						info.css = (info.css || "") + " s-m-ismultisel";
						if (actSettings && actSettings.icon != null) {
							info.icon = actSettings.icon.css;
						}
						self._multiSelectionLinks.push(info);
					});
				}
			}
			return self._multiSelectionLinks.length == 0 ? null : self._multiSelectionLinks;
		},
		/**
		 * onlyFooterHeader		true: 	take into account links with footerHeader property == true (defined by authoring on actions)
		 * onlyFooterHeader		false:	take into account all links
		 */
		hasFooterHeaderActions: function(onlyFooterHeader) {
			var tl = this.getToolbarLinks(globals.getSiteLayout().getDeviceType() === "smartphone" ? "header" : "footer");
			if (tl.length === 0) return false;
			if (onlyFooterHeader === true) {
				for (var i = 0; i < tl.length; i++) {
					if (tl[i].footerHeader === true) return true;
				}
				return false;
			} else {
				return tl.length > 0;
			}
		},
		/**
		 * Accept getProtoLinks("$query", $details"...)
		 */
		getProtoLinks: function() {
			var self = this;
			if (self._protoLinks == null) {
				var $links = $.extend(true, {}, self.prototype.data("$links", null, true), self.dao ? self.dao.getValue("$links") : null);
				self._protoLinks = {};
				var info, sdataInfo;
				if (this.prototype.isQuery()) {
					// This code is disabled - It adds the actions tied to the $resources for queries
					var queryLinks = this.prototype.getDataByPath("$properties.$resources.$item.$links");
					if (queryLinks) {
						$.extend(true, $links, queryLinks);
					}
				}
				$.each($links, function(name, info) {
					if (!pageHelpers.checkLink(name, info)) {
						return;
					}
					info.name = name;
					info.title = info.$title ? self.prototype.resolveExpression(info.$title) : "";
					info.icon = fontUtils.getIconByName(name);
					if (info.$type == null || info.$type.length !== 0 || info.$type === "application/json;vnd.sage=syracuse") {
						if (info.$url) {
							info.$parameters && $.each(info.$parameters, function(paramName, paramValue) {
								// PARAMETER_ESCAPING
								// If there are placeholders in a parameters value, we try to resolve them here
								// In any case, the result is encoded to ensure sdataUtils.getLinkInfo will not fail if there
								// are non valid characters in the url
								// As a result, in multiselection, eventually left over encoded placeholders need to be
								// unescaped and replaced later in the process (see multiSelectionMgr.js -> PARAMETER_ESCAPING)
								if (paramValue.indexOf("{") > -1 && self.dao) {
									var pv2 = self.prototype.resolveExpression(paramValue, self.dao);
									if (pv2 && pv2.length > 0) {
										paramValue = encodeURIComponent(pv2);
									} else {
										paramValue = encodeURIComponent(paramValue);
									}
								}
								info.$url = info.$url.replace("{" + paramName + "}", paramValue);
							});
							var urlParsed = self.prototype.resolveExpression(info.$url, self.dao, false, true);
							if (urlParsed.indexOf("/mobile1/") > -1) { // mobile1 means it's an sdata request
								sdataInfo = sdataUtils.getLinkInfo(info.$url, self.dao, true);
								if (!sdataInfo) return;
								$.extend(info, sdataInfo);
								if (info.$services) {
									info.$isAction = true;
								}
							} else {
								// Free type link (for maps)
								info.externalUrl = info.$url;
							}
						} else {
							// Force notification
							info.$isAction = true;
						}
						if (info.$uuid == null) {
							info.$uuid = utils.UUID();
						}
						info.css = info.css || [];
						if (info.$isHidden === true) info.css.push("hidden");
						if (info.$isDisabled === true) info.css.push("disabled");
						info.css = info.css.join(' ');
						self._protoLinks[name] = info;
						return;
					}
				});
			}
			if (arguments.length == 0) {
				return $.isEmptyObject(self._protoLinks) ? null : self._protoLinks;
			}
			var res;
			for (var i = 0; i < arguments.length; i++) {
				if (self._protoLinks[arguments[i]]) {
					if (res == null) res = {};
					res[arguments[i]] = self._protoLinks[arguments[i]];
				}
			}
			return res;

		},
		/**
		 * Return an array of link info according to toolbar
		 *		toolbar - can be "header", "footer", "actionpanel"
		 * !!! There's a hack in \lib\sdataStatelessHack._js that transform the original proto to put $actions in $links
		 * 		Set a $isAction = true for actions (false for $links)
		 */
		getToolbarLinks: function(toolbar, options) {
			var self = this;
			options = options || {};
			if (!self.dao) {
				// non regular pages
				return [];
			}
			if (self._toolbarLinks == null) self._toolbarLinks = {};
			var device = globals.getSiteLayout().getDeviceType();
			var facet = self.prototype.getFacet();
			var key = toolbar + device + facet;
			if (self._toolbarLinks[key]) return self._toolbarLinks[key];
			var links = self._toolbarLinks[key] = [];
			var $links = self.getProtoLinks();
			if ($links) {
				var lMap = pageHelpers.getLinkMap(toolbar, device, facet);
				var authSettings, forceFooterHeader;
				$.each($links, function(name, value) {
					// authSettings -> {multiselection:true/false, authSettings.footerHeader:true/false}
					authSettings = self.actionGetSettings(name) || {};
					if (!$.isEmptyObject(authSettings)) {
						// Customized icon - we clone value - Todo not needed ?
						value = $.extend(true, {}, value);
						if (authSettings.icon != null) {
							value.icon = authSettings.icon.css;
						}
						value.footerHeader = authSettings.options != null && authSettings.options.footerHeader === true;
					}
					// multiselection action are not displayed in panel or footer/header - Managed by multiselection manager
					if (authSettings.options && authSettings.options.multiselection === true) return;
					// forceFooterHeader only for tablet - TODO see how we could add action in smartphone header
					forceFooterHeader = value.footerHeader && (device !== "smartphone");
					if (forceFooterHeader !== true && toolbar !== "actionpanel" && !lMap[name]) {
						return;
					}
					if (toolbar === "actionpanel" && pageHelpers.excludeFromPanel(name, forceFooterHeader, value, facet)) {
						return;
					}
					links.push(value);
				});
			}
			return links;
		},
		getEmptyDao: function(proto) {
			return daoSdata.emptyDao(proto);
		},
		/**
		 * !! Must always returns a promise (see checkBack in cancelEdit)
		 */
		checkBack: function() {
			return this._draftMgr ? this._draftMgr.checkBack() : $.smResolve(true);
		}
	});

exports.Page = _Page;