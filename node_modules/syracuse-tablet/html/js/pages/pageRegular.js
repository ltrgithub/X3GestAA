"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("page");
var Base = require('syracuse-tablet/html/js/pages/page').Page;
var globals = require('syracuse-tablet/html/js/helpers/globals');
var dispatcher = require('syracuse-tablet/html/js/sdata/sdataDispatcher');
var factory = require('syracuse-tablet/html/js/application/appFactory');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');
var sessStorage = require('syracuse-tablet/html/js/storage/sessionStorage');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var locale = require('syracuse-tablet/html/js/helpers/locale');


/*
 * Returns appropriate right value for where request
 * For example, for the filter 'CODE contains aa', the where clause should look like
 * CODE like '%aa%'. This function will return '%aa%'
 */
var _setFilterRightValue = function(filter) {
	var cp = filter.prop;
	var cv, value = filter.value == null ? "" : filter.value;
	switch (cp.$type) {
		case "application/x-password":
		case "application/x-string":
			cv = value.replace(/'/g, "\\'");
			if (filter.operator === "like") cv = '%' + cv + '%';
			else if (filter.operator === "like_s") cv = cv + '%';
			cv = "'" + cv + "'";
			return cv;
		case "application/x-integer":
		case "application/x-real":
		case "application/x-decimal":
		case "application/x-quantity":
			return value;
		case "application/x-date":
			if (!value) return null;
			return '@' + value + '@';
		case "application/x-datetime":
			return '@' + value + '@';
		case "application/x-time":
			return null;
		case "application/x-boolean":
			return value ? "true" : "false";
		case "application/x-choice":
			if (cp.$value && cp.$value.$type === "application/x-string") {
				return "'" + value.replace(/'/g, "\\'") + "'";
			} else return value + "";
			break;
		case "application/x-reference":
			cv = (value || '').replace(/'/g, "\\'");
			cv = "'" + cv + "'";
			return cv;
		default:
			break;

	}
	return null;
};

/**
 * Page with representation and sdata back-end
 */
var _Page = utils.defineClass(
	function RegularPage($parent, state, prototype, article, options) {
		Base.call(this, $parent, state, prototype, article, options);
		this.gadget = this.state.options.gadget;
		this._originalSdataUrl = this.state.options["sdata-url"];
		if (!this._originalSdataUrl) {
			if (this.gadget) {
				this._originalSdataUrl = this.gadget.getSDataUrl(this.prototype);
			} else {
				this._originalSdataUrl = this.prototype.data("$url");
			}
		}
		this._init$Filters();
		this._initSdataInfo();
		notifications.subscribe(this, ["sm.rowdetail.update", "sm.rowdetail.delete", "sm.action.link"], 1);
		if (this.prototype.data("$url")) {
			this.$facet = sdataUtils.parseSDataURL(this.prototype.data("$url")).facet;
			// Override the standard "display" activity
			this.setActivity(this.$facet === "edit" ? "edit" : this.$facet === "create" ? "create" : "read");
		}
		notifications.subscribe(this, ["sm.action.link"], 1);
	}, Base, {
		_init$Filters: function() {
			this._$filters = [];
			// Authoring on filters - none/list/tabs
			var auth = this.$filtersGetAuthoring();
			var filters = this.prototype.data("$filters");
			if (auth === "none" || !filters) {
				this._$filtersDisabled = true;
				return;
			}
			var def = false;
			for (var p in filters) {
				var ttl = this.prototype.resolveExpression(filters[p].$title);
				if (ttl) {
					var f = $.extend(true, {}, filters[p]);
					f.$title = ttl;
					f.id = p;
					def = def || f.$isDefault === true;
					this._$filters.push(f);
				}
			}
			if (this._$filters.length == 0) return;
			if (!def) {
				this._$filters[0].$isDefault = true;
			}
		},
		/**
		 *  Init sdata url - Called in constructor and page refresh
		 * 	sdataUrl is optional in case of a gadget (to see with Mathias)
		 *  Can be overridden - rowdetail
		 */
		_initSdataInfo: function(sdataUrl) {
			if (!sdataUrl) sdataUrl = this._originalSdataUrl;
			if (this.gadget) {
				var params = this.gadget.getParameters();
				if (params.where) {
					sdataUrl = sdataUtils.addWhereClause(sdataUrl, params.where, this.state.options.sdataParameters);
				}
			}
			if (!sdataUrl) throw new Error("$url (sDataUrl) is expected");
			this.state.options["sdata-url"] = this.sDataUrl = sdataUrl;
			this.sDataMethod = this.state.options["sdata-method"] || "GET";
		},

		destroy: function() {
			Base.prototype.destroy.call(this);
			this.gadget = null;
		},

		beforeAddContent: function() {
			if (false && !this.isVignette) {
				// #5583 - disabled because redundant with header title
				var ttl = this.prototype.data("$title");
				this.addTitle(globals.getApplication().getTitle() + (ttl ? " - " + ttl : ""));
			}
		},

		/**
		 * Used by html builder to create a link to full page
		 */
		getOpenLinkAttrs: function() {
			var res = Base.prototype.getOpenLinkAttrs.call(this);
			res["data-sdata-url"] = this.sDataUrl;
			res["data-sdata-method"] = this.sDataMethod;
			res["data-gadget-id"] = this.gadget.data("$uuid");
			return res;
		},

		/**
		 * Refresh the page
		 * 	Called from a vignette or full page (callBackInterface)
		 * 	options.sdata-url -> New url
		 * 	options.controlId!=null -> refresh the control
		 *  options.type Type of refresh (pagination...)
		 *  callBackInterface
		 *  	waitStop(ctrlId) / waitStart(ctrlId)
		 */
		refresh: function(options, callBackInterface) {
			var self = this;
			options = options || {};
			var deferred = $.Deferred();
			var url = options["sdata-url"];
			var controlId = options["controlId"];
			var type = options.type || "";
			var force = type === "filtersort";
			var _wait = function(status) {
				self["waitWheel" + status.smCapitalize()].call(self, controlId);
			};
			try {
				var _succeeded = function() {
					_wait("stop");
					self.refreshControls(controlId ? [controlId] : null, options);
					deferred.resolve();
				};
				if (!url && force !== true) {
					_succeeded();
				} else {
					_wait("start");
					if (url) {
						/* url can change on refresh (paginations)*/
						self._initSdataInfo(url);
					}
					self.loadData()
						.then(function() {
							_succeeded();
						}).fail(function(e) {
							_wait("stop");
							deferred.reject(e);
						});
				}
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		loadData: function() {
			var deferred = $.Deferred();
			var self = this;
			var _rejectError = function(e) {
				log && log("loadData failed", e);
				deferred.reject(e);
			};
			try {
				dispatcher.dispatch({
					$url: self._filterSortAllowed(false) ? self._filterSortUpdateUrl() : self.sDataUrl,
					$method: self.sDataMethod
				}).then(function(data) {
					if (data) {
						self.setDao(factory.createDaoSdata("representation", data, self.prototype, null));
						if (data.$cacheHint) {
							var notify = {
								severityClass: "warning",
								title: locale.text("info.network.offline.title"),
								body: locale.text("info.network.offline.outdated")
							};
							if (!self.isVignette) {
								globals.getModal().notify(notify);
							} else {
								// For vignettes, if they are loaded from cache, the notification is displayed only once
								// per dashboard
								var dashboardPage = globals.getApplication().currentPage;
								if (dashboardPage && dashboardPage.cachedDataNotification) {
									dashboardPage.cachedDataNotification(notify);
								} else {
									// Fallback
									globals.getModal().notify(notify);
								}
							}
						}
					} else {
						globals.getModal().actionResult("updateDao", {
							$diagnoses: [{
								$message: "NO DATA",
								$severity: "info"
							}]
						});
					}
					return deferred.resolve();
				}).fail(function(e) {
					_rejectError(e);
				});
			} catch (e) {
				_rejectError(e);
			} finally {
				return deferred.promise();
			}
		},
		/**
		 * Lookup notification
		 * 		rowData:	Selected row data
		 * 		controlId:	Id of control to refresh
		 */
		notifLookupSelection: function(rowData, controlId) {
			if (!this.isActive()) return;
			Base.prototype.notifLookupSelection.call(this, rowData, controlId);
		},
		/** Event sm.action.link
		 *  Notified when a action succeeded - sdata link - see action manager
		 *  success:	true/false
		 *  link:		Link info
		 *  result:		Json response
		 */
		notifActionLink: function(success, link, result, options) {
			if (!this.isActive()) return;
			try {
				var responseJSON = result ? result.responseJSON || {} : {};
				// TODO  - scan/display field errors	
				switch (link.name) {
					case "$save":
						this._doActSave(success, link, responseJSON, options);
						break;
					case "$delete":
						globals.getApplication().goBack().always(function() {
							sdataUtils.displayActionMsg(success, link.name, responseJSON);
						});
						break;
					case "$canceledit":
						var autoScroll = this.getScrollValue();
						globals.getApplication().goBack().always(function(newPage) {
							if (newPage) {
								// We stay at the same location - .8 because the height of the page is less in detail than edit
								// in actionManager we also preserve scrolling when we go from edit to detail
								setTimeout(function() {
									newPage.autoScroll(autoScroll * 0.8);
								});
							}
						});
						break;
					default:
						if (link.$isAction === true && responseJSON) {
							this._myApplyChange(responseJSON);
						}
						sdataUtils.displayActionMsg(success, link.name, responseJSON);
						break;
				}
			} catch (e) {
				globals.getModal().error("notifActionLink failed", e);
			}
		},
		/**
		 * For right panel action we call standard applyChange that check DATA + META-DATA and refresh controls
		 * TODO - Use always this process after having removed the old _updateMeta in daoSData
		 */
		_myApplyChange: function(responseJSON) {
			this.dao.applyChange(responseJSON, {
				$isPartialDelta: false,
				$isEditMode: this.isEditMode()
			});
			var errors = this.refreshControls(null, {
				refreshValue: true
			});
			if (errors.length > 0) {
				// Set focus on the firts error field
				errors[0].setFocus();
			}
			if (this._gestureMgr) {
				// We need to adjust the scroller because line can be removed -> Make content visible
				this._gestureMgr.adjust();
			}
		},
		/**
		 * Validate data before sending an action
		 */
		validateBeforeActionLink: function(link) {
			if (link && link.name === "$save") {
				return this.checkControlsData();
			}
			return true;
		},
		// Action on child pages
		_doActSave: function(success, link, responseJSON, options) {
			var self = this;
			if (success) {
				globals.getApplication().goBack().always(function() {
					// Displays diagnoses contained in response if any once the back page has been displayed
					sdataUtils.displayActionMsg(success, link.name, responseJSON);
				});
			} else {
				// !! We expect that input fields errors come always with success = false
				// We just update the meta to extract diagnoses
				if (self.dao.updateMeta(responseJSON)) {
					// Update controls - Display diagnoses
					var errors = self.refreshControls(null, {});
					if (errors.length > 0) {
						// Set focus on the firts error field
						errors[0].setFocus();
					}
					if (self._gestureMgr) {
						// We need to adjust the scroller because line can be removed -> Make content visible
						self._gestureMgr.adjust();
					}
				}
				if (!success && (responseJSON == null || (!responseJSON.$diagnoses || responseJSON.$diagnoses.length == 0))) {
					// Unexpected
					responseJSON.$diagnoses = [{
						$message: "Save action failed without any message",
						$severity: "error"
					}];
				}
				// Display global message
				globals.getModal().actionResult("Action: " + link.name, responseJSON);
			}
		},
		/**
		 * True if scroll enabled in page
		 * edit/detail allows scroll in vignette
		 * query/lookup doesn't allow because scroll is done by the array
		 */
		scrollAllowed: function() {
			if (this.prototype.isLookup() || this.prototype.isQuery()) {
				// This is the array which scrolls
				return false;
			}
			return true;
		},
		/**
		 * Save a rowDetail dao (childDao) into the current dao
		 */
		notifRowdetailUpdate: function(info, arrayId) {
			if (!info) return;
			var childDao = info.dao;
			if (!childDao) return;
			// singleArrayRowIdx needed for single arrays
			var array = this.getControl(arrayId);
			if (!array) return;
			var create = info.activity === "create";
			var singleArrayRowIdx;
			if (!create && array.prototype.isSingleArray()) {
				// For single arrays we added a $uuid in arrayData to manage them as other arrays
				// When we update the dao we need to retreive the index from the uuid because there's no uuid in for theses row in parent dao
				singleArrayRowIdx = array.rowId2Idx(childDao.getValue("$uuid"));
			} // If not singleArray the row will be rtreive in parent from th uuid contained in childDao
			if (childDao.updateParentRow(create, singleArrayRowIdx)) {
				var errors = this.refreshControls([arrayId], {});
				if (errors.length > 0) {
					// Set focus on the firts error field
					errors[0].setFocus();
				}
			}
			childDao.destroy();
		},
		/**
		 * Delete a row (data.uuid) in current dao - Row has been deleted by Delete footer action
		 */
		notifRowdetailDelete: function(data, arrayId) {
			if (!data || !data.uuid) return;
			var array = this.getControl(arrayId);
			if (!array) return;
			var rowidOrIdx = data.uuid;
			if (array.prototype.isSingleArray()) {
				rowidOrIdx = array.rowId2Idx(data.uuid);
			}
			// Remove the row in dao by idx or rowid 
			this.dao.deleteRow(array.$bind, rowidOrIdx);
			// Remove html identofied by uuid
			array.removeRow(data.uuid);
		},
		getPinPageId: function() {
			var self = this;
			return self.state.name + "_" + self.sDataUrl;
		},
		getPinPageData: function() {
			var self = this;
			var pageData = Base.prototype.getPinPageData.call(self);

			pageData.sDataUrl = self.sDataUrl;
			pageData.key = self.prototype.data("$key", self.dao);

			var pu = utils.parseURL(pageData.sDataUrl);
			var repr = pu.query.representation.split(".");
			pageData.representation = repr[0];
			pageData.facet = repr[1];
			pageData.action = repr[1];

			var ps = pu.path.split("/");
			pageData.entity = ps[5];

			var value = self.prototype.data("$value", self.dao);
			if (value) {
				pageData.title = self.prototype.data("$title") + " - " + value;
			}
			return pageData;
		},
		filterSortRead: function(type, ctrl) {
			if (!this._filterSortAllowed(true)) return;
			var id = this._filterInfoSaveId(type, ctrl);
			if (!this._filterSortInfo) this._filterSortInfo = {};
			var info = this._filterSortInfo[id];
			if (info) return info;
			info = sessStorage.getItem(id);
			if (info) {
				try {
					info = JSON.parse(info);
					return info;
				} catch (e) {}
			}
			return null;
		},
		filterSortWrite: function(type, info, ctrl, refresh) {
			if (!this._filterSortAllowed(true)) return;
			var id = this._filterInfoSaveId(type, ctrl);
			var save = false;
			if (info && info.length > 0) {
				var old = this.filterSortRead(type, ctrl);
				if (old == null || !this._filterSortEquals(type, info, old)) {
					save = true;
				}
			} else {
				save = info != this._filterSortInfo[id];
			}

			if (save) {
				sessStorage.setItem(id, info ? JSON.stringify(info) : null);
				this._filterSortInfo[id] = info;
				if (refresh === true) {
					this._filterSortRefresh(ctrl);
				}
			}
		},
		_filterSortRefresh: function(ctrlArray) {
			var attrs = {
				"data-control-id": ctrlArray.id,
				"data-nav-target": this.isVignette ? "vignette" : "application",
				"data-nav-type": "filtersort"
			};
			// Set original URL - Remove pagination - Ex we change the filter/sort criteria in a pagination 
			this._initSdataInfo(null);
			setTimeout(function() {
				eventListener.triggerRefreshPage(ctrlArray.$$elmt, attrs);
			});
		},
		/**
		 * Only for query and lookup in current version
		 */
		_filterSortAllowed: function(log) {
			return this.prototype.isLookup() || this.prototype.isQuery();
		},
		_filterInfoSaveId: function(type, ctrl) {
			if (!this._filtersortUrlId) {
				this._filtersortUrlId = this._originalSdataUrl;
			}
			var id = this._filtersortUrlId + "#" + type;
			if (this.prototype.isLookup() || this.prototype.isQuery()) {
				// For isLookup and isQuery no field ID
				return id;
			}
			// Adds id for filter/sort on array fields in details pages - Not implemenred currently
			return id + '_' + ctrl.$bind;
		},

		/*
		 * Check if sort or filter has changed
		 * This is just to detect changes to trigger a page reload
		 * If e.g. sort criterias are not change, the page will not be reloaded
		 */
		_filterSortEquals: function(type, info, old) {
			if (info == null || old == null) return true;
			if (type == "sort") {
				if (old.length != info.length) return false;
				for (var i = 0; i < info.length; i++) {
					if (info[i].sort !== old[i].sort) return false;
					if (info[i].field !== old[i].field) return false;
				}
				return true;
			} else if (type == "filter") {
				// Filters are hard to compare because the can change and still be logically the same
				// So we always asume changed filter conditions here
				return false;
			}
		},
		_filterSortUpdateUrl: function() {
			var self = this;
			var sdataUrl = utils.parseURL(self.sDataUrl);
			// Add filters describe in proto - the filter is selected by the user ($isDefault === true)
			if (this.$filtersGet().length > 0 && this._$filtersDisabled != true) {
				var f = null;
				this.$filtersGet().some(function(x) {
					if (x.$isDefault === true) {
						f = x;
						return true;
					}
				});
				if (f) {
					if (!sdataUrl.query) sdataUrl.query = {};
					sdataUrl.query.filter = f.id;
				}
			}
			if (!self._filterSortAllowed(true)) return utils.urlToString(sdataUrl);
			// Add filter/sort clause for Lookup and Query if any
			// build sort clause
			var sortClause = null;
			var info = self.filterSortRead("sort");
			if (info != null && info.length != 0) {
				info.some(function(i) {
					if (i.sort != "none") {
						sortClause = {
							order: i.sort,
							field: i.id
						};
						return true;
					}
				});
			}
			// build filter clause
			var filterClause = '';
			info = self.filterSortRead("filter");
			if (info != null && info.length != 0) {
				$.each(info, function(idx, filter) {
					var cf = '(' + filter.id + ' ' + (filter.operator === "like_s" ? "like" : filter.operator) + ' ' + _setFilterRightValue(filter) + ')';
					filterClause = filterClause.length == 0 ? cf : filterClause + ' and ' + cf;
				});
			}
			// apply sort clause
			if (!sortClause && !filterClause) return utils.urlToString(sdataUrl);;
			// sdataUrl.query.key != null means it's a pagination request
			// -> The pagination request contains already the sort criteria so we don't add them
			// -> Otherwise we add sort criteria to the request
			if (sortClause && sdataUrl.query.key == null) {
				var old = sdataUrl.query.orderBy;
				sdataUrl.query.orderBy = sortClause.field + ' ' + sortClause.order;
				if (old) sdataUrl.query.orderBy = ", " + old;
			}
			// apply filter clause
			if (filterClause && sdataUrl.query.key == null) {
				var old = sdataUrl.query.where;
				sdataUrl.query.where = filterClause;
				if (old) sdataUrl.query.where = old + ' and ' + sdataUrl.query.where;
			}

			return utils.urlToString(sdataUrl);
		},
		/**
		 * List of filters given by the prototype ($filters)
		 */
		$filtersGet: function() {
			return this._$filters;
		},
		/**
		 * Select a filter
		 */
		$filtersSelect: function(filterId, ctrlArray) {
			if (!this._$filters) return;
			this._$filtersDisabled = false;
			this._$filters.forEach(function(f) {
				f.$isDefault = false;
				if (filterId === f.id) {
					f.$isDefault = true;
				}
			});
			this._filterSortRefresh(ctrlArray);
		},
		/**
		 * none/tabs/list
		 * Stored in $resources array
		 */
		$filtersGetAuthoring: function() {
			var c = this.getControlByBind("$resources");
			if (c) {
				return c.$filtersGetAuthoring();
			}
			return null;
		}
	});

exports.Page = _Page;