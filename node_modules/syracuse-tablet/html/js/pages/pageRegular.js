"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("page");
var Base = require('syracuse-tablet/html/js/pages/page').Page;
var globals = require('syracuse-tablet/html/js/helpers/globals');
var dispatcher = require('syracuse-tablet/html/js/sdata/sdataDispatcher');
var factory = require('syracuse-tablet/html/js/application/appFactory');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');

//These link enable wait on control - TODO enable only if data not in cache for next, prev...
var _controlWheel = ["$more"]; //"$next", "$last", "$previous","$more","$first"];
/**
 * Page with representation and sdata back-end
 */
var _Page = utils.defineClass(
	function($parent, state, prototype, article, options) {
		Base.call(this, $parent, state, prototype, article, options);
		this._actionPanel = null;
		this.gadget = this.state.options.gadget;
		this._initSdataInfo(this.state.options["sdata-url"], this.state.options["sdata-method"]);
		notifications.subscribe(this, ["sm.lookup.selection", "sm.rowdetail.update", "sm.rowdetail.delete"], 1);
		if (this.prototype.data("$url")) {
			this.$facet = sdataUtils.parseSDataURL(this.prototype.data("$url")).facet;
			// Override the standard "display" activity
			this.$activity = this.$facet === "edit" ? "edit" : this.$facet === "create" ? "create" : "read";
		}
	}, Base, {
		/**
		 *  Init sdata url - Called in constructor and page refresh
		 * 	sdataUrl is optional in case of a gadget (to see with Mathias)
		 * 	sdataMethod is optional
		 *  Can be overridden - rowdetail
		 */
		_initSdataInfo: function(sdataUrl, sdataMethod) {
			if (!sdataUrl) {
				if (this.gadget) {
					sdataUrl = this.gadget.getSDataUrl(this.prototype);
				} else {
					sdataUrl = this.prototype.data("$url");
				}
			}
			if (this.gadget) {
				var params = this.gadget.getParameters();
				if (params.where) {
					sdataUrl = sdataUtils.addWhereClause(sdataUrl, params.where, this.state.options.sdataParameters);
				}
			}
			if (!sdataUrl) throw new Error("$url (sDataUrl) is expected");
			this.state.options["sdata-url"] = this.sDataUrl = sdataUrl;
			this.sDataMethod = sdataMethod || "GET";
		},

		destroy: function() {
			Base.prototype.destroy.call(this);
			this.gadget = null;
			if (this._actionPanel) this._actionPanel.destroy();
			this._actionPanel = null;
		},
		/**
		 * True if display is edit mode
		 */
		isEditMode: function() {
			return this.$activity === "edit" || this.$activity === "create";
		},

		beforeAddContent: function() {
			if (!this.isVignette) {
				var ttl = this.prototype.data("$title");
				this.addTitle(globals.getApplication().getTitle() + (ttl ? " - " + ttl : ""));
			}
		},

		/**
		 * Used by html builder to create a link to full page
		 */
		getOpenLinkAttrs: function() {
			var res = Base.prototype.getOpenLinkAttrs.call(this);
			res["data-sdata-url"] = this.sDataUrl;
			res["data-sdata-method"] = this.sDataMethod;
			res["data-gadget-id"] = this.gadget.data("$uuid");
			return res;
		},

		/**
		 * Refresh the page
		 * 	Called from a vignette or full page (callBackInterface)
		 * 	options.sdata-url -> New url
		 * 	options.controlId!=null -> refresh the control
		 *  options.type Type of refresh (pagination...)
		 *  callBackInterface
		 *  	waitStop(ctrlId) / waitStart(ctrlId)
		 */
		refresh: function(options, callBackInterface) {
			var self = this;
			options = options || {};
			var deferred = $.Deferred();
			var url = options["sdata-url"];
			var controlId = options["controlId"];
			var _wait = function(status) {
				// I added the capability to enable the wait on the control
				// True if the type of refresh needs the display of wheel on control ($more)
				var ctrlWheel = controlId ? _controlWheel.indexOf(options.type) >= 0 : false;
				if (callBackInterface) {
					// Caller wheel - Ex: vignette
					var m = "wait" + status.smCapitalize();
					if (callBackInterface[m]) callBackInterface[m](ctrlWheel ? controlId : null);
					return;
				}
				// Page wheel or control wheel if ctrlId && pagination
				// TODO use the same name waitStart/waitStop for all objects
				self["waitWheel" + status.smCapitalize()].call(self, ctrlWheel ? controlId : null);
			};
			try {
				var _succeeded = function() {
					_wait("stop");
					self.refreshControls(controlId ? [controlId] : null, options);
					deferred.resolve();
				};
				if (!url) {
					_succeeded();
				} else {
					_wait("start");
					/* url can change on refresh (paginations)*/
					self._initSdataInfo(url);
					self.loadData()
						.then(function() {
							_succeeded();
						}).fail(function(e) {
							_wait("stop");
							deferred.reject(e);
						});
				}
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		loadData: function() {
			var deferred = $.Deferred();
			var self = this;
			var _rejectError = function(e) {
				log && log("loadData failed", e);
				deferred.reject(e);
			};
			try {
				dispatcher.dispatch({
					$url: self.sDataUrl,
					$method: self.sDataMethod
				}).then(function(data) {
					if (data) {
						self.setDao(factory.createDaoSdata("representation", data, self.prototype, null));
					} else {
						globals.getModal().actionResult("updateDao", {
							$diagnoses: [{
								$message: "NO DATA",
								$severity: "info"
							}]
						});
					}
					return deferred.resolve();
				}).fail(function(e) {
					_rejectError(e);
				});
			} catch (e) {
				_rejectError(e);
			} finally {
				return deferred.promise();
			}
		},
		/**
		 * Lookup notification
		 * 		rowData:	Selected row data
		 * 		controlId:	Id of control to refresh
		 */
		notifLookupSelection: function(rowData, controlId) {
			if (!this.isActive()) return;
			try {
				var ctrl = this.getControl(controlId);
				if (!ctrl) throw new Error("Control not found '" + controlId + "'");
				ctrl.setFieldValue(rowData);
			} catch (e) {
				globals.getModal().error("notifLookupSelection failed", e);
			}
		},
		/** Event sm.action.link
		 *  Notified when a action succeeded - sdata link - see action manager
		 *  success:	true/false
		 *  link:		Link info
		 *  result:		Json response
		 */
		notifActionLink: function(success, link, result, options) {
			if (!this.isActive()) return;
			try {
				var responseJSON = result ? result.responseJSON || {} : {};
				// TODO  - scan/display field errors	
				switch (link.name) {
					case "$save":
						this._doActSave(success, link, responseJSON, options);
						break;
					case "$delete":
						globals.getApplication().goBack().always(function() {
							sdataUtils.displayActionMsg(success, link.name, responseJSON);
						});
						break;
					case "$canceledit":
						var autoScroll = this.getScrollValue();
						globals.getApplication().goBack().always(function(newPage) {
							if (newPage) {
								// We stay at the same location - .8 beacause the height of the page is less in detail than edit
								// in actionManager we also preserve scrolling when we go from edit to detail
								setTimeout(function() {
									newPage.autoScroll(autoScroll * 0.8);
								});
							}
						});
						//sdataUtils.displayActionMsg(success, link.name, responseJSON);
						//this.goBack();
						break;
					default:
						if (link.$isAction === true) {
							this._updateMeta(responseJSON);
						}
						sdataUtils.displayActionMsg(success, link.name, responseJSON);
						break;
				}
			} catch (e) {
				globals.getModal().error("notifActionLink failed", e);
			}
		},
		/**
		 * Validate data before sending an action
		 */
		validateBeforeActionLink: function(link) {
			if (link && link.name === "$save") {
				// Always ok if not edit
				if (!this.isEditMode()) return true;
				var self = this,
					ok = true,
					firstError, c;
				Object.keys(self.controlsMap).forEach(function(key) {
					c = self.controlsMap[key];
					if (c) {
						ok = ok && c.checkData();
						if (!ok && firstError == null) firstError = c;
					}
				});
				if (firstError) {
					firstError.setFocus();
				}
				return ok;
			}
			return true;
		},
		// Action on child pages
		_doActSave: function(success, link, responseJSON, options) {
			var self = this;
			if (success) {
				globals.getApplication().goBack().always(function() {
					// Displays diagnoses contained in response if any once the back page has been displayed
					sdataUtils.displayActionMsg(success, link.name, responseJSON);
				});
			} else {
				// !! We expect that input fields errors come always with success = false
				// We display field $diagnoses and global message
				self._updateMeta(responseJSON);
				if (!success && (responseJSON == null || (!responseJSON.$diagnoses || responseJSON.$diagnoses.length == 0))) {
					// Unexpected
					responseJSON.$diagnoses = [{
						$message: "Save action failed without message",
						$severity: "error"
					}];
				}
				// Display global message
				globals.getModal().actionResult("Action: " + link.name, responseJSON);
			}
		},
		/**
		 * update dao only with meta $properties that contain potential diagnoses  and $links
		 * We don't update all data because X3 doesn't return input data (if we input a bad SITE (lookup) X3 returns empty value
		 */
		_updateMeta: function(responseJSON) {
			if (this.dao.updateMeta(responseJSON)) {
				// Update controls - Display diagnoses
				var errors = this.refreshControls(null, {});
				if (errors.length > 0) {
					// Set focus on the firts error field
					errors[0].setFocus();
				}
				if (this._gestureMgr) {
					/**
					 * We need to adjust the scrolle rbeacuse line can be removed -> Make content visible
					 */
					this._gestureMgr.adjust();
				}
			}
		},
		/**
		 * True if scroll enabled in page
		 * edit/detail allows scroll in vignette
		 * query/lookup doesn't allow because scroll is done by the array
		 */
		scrollAllowed: function() {
			if (this.prototype.isLookup() || this.prototype.isQuery()) {
				// This is the array which scrolls
				return false;
			}
			return true;
		},
		onMainPageResize: function(info, orientation, deviceClass) {
			Base.prototype.onMainPageResize.call(this, info, orientation, deviceClass);
			if (this.prototype.isLookup() || (this.prototype.isQuery() && !this.isVignette)) {
				// set content top and width - not height
				this.$$contentElmt.css({
					height: this.getMainContentRect().height + "px"
				});
			}
		},
		/**
		 * Save a rowDetail dao (childDao) into the current dao
		 */
		notifRowdetailUpdate: function(info, arrayId) {
			if (!info) return;
			var childDao = info.dao;
			if (!childDao) return;
			// singleArrayRowIdx needed for single arrays
			var array = this.getControl(arrayId);
			if (!array) return;
			var create = info.activity === "create";
			var singleArrayRowIdx;
			if (!create && array.prototype.isSingleArray()) {
				// For single arrays we added a $uuid in arrayData to manage them as other arrays
				// When we update the dao we need to retreive the index from the uuid because there's no uuid in for theses row in parent dao
				singleArrayRowIdx = array.rowId2Idx(childDao.getValue("$uuid"));
			} // If not singleArray the row will be rtreive in parent from th uuid contained in childDao
			if (childDao.updateParentRow(create, singleArrayRowIdx)) {
				var errors = this.refreshControls([arrayId], {});
				if (errors.length > 0) {
					// Set focus on the firts error field
					errors[0].setFocus();
				}
			}
			childDao.destroy();
		},
		/**
		 * Delete a row (data.uuid) in current dao - Row has been deleted by Delete footer action
		 */
		notifRowdetailDelete: function(data, arrayId) {
			if (!data || !data.uuid) return;
			var array = this.getControl(arrayId);
			if (!array) return;
			var rowidOrIdx = data.uuid;
			if (array.prototype.isSingleArray()) {
				rowidOrIdx = array.rowId2Idx(data.uuid);
			}
			// Remove the row in dao by idx or rowid 
			this.dao.deleteRow(array.$bind, rowidOrIdx);
			// Remove html identofied by uuid
			array.removeRow(data.uuid);
		},
		/**
		 * Returns action panel - Attached to the page but opened by footer or other component (only one action panel par page)
		 */
		panelGet: function(panelId) {
			if (panelId != "pageactionpanel") return null;
			if (this._actionPanel == null) {
				this._actionPanel = ctrlFactory.createPanel("regularpageactionpanel", panelId, this);
			}
			return this._actionPanel;
		}
	});

exports.Page = _Page;