"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/helpers/controller').Klass;;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("page");
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');
var HammerScroller = require('syracuse-tablet/html/js/helpers/hammerScroller').Klass;
var settings = require('syracuse-tablet/html/js/application/settings');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var native = require('syracuse-tablet/html/js/helpers/native/native');
var sdataCommonResources = require('syracuse-tablet/html/js/sdata/sdataCommonResources');
// !! Array sorted from top position to bottom
var _insidePageControls = ["header", "breadcrumbs", "topToolbar", "footer"];
var _topPageControls = ["header", "breadcrumbs", "topToolbar"];

/**
 * s-m-side-panel-dismiss: div that traps the events outside the panel when a panel if open
 */
var _templates = {
	fullpage: '\
		<section class="s-m-page s-m-full {{type}} {{subtype}}" id="{{pageid}}" {{#if parentId}}data-parent-id="{{parentId}}"{{/if}} class="ctrl-event-click" style=""> \
			<header></header> \
			<section class="s-m-breadcrumbs" style="display:none"></section> \
			<section class="s-m-topToolbar"  style="display:none"></section> \
			<section class="s-m-main-content"></section> \
			<footer class="s-m-color-footer" style="display:none"></footer> \
		</section> \
	',
	vignette: '<section class= "s-m-page s-m-nested {{type}} {{subtype}}" id="{{pageid}}"></section>',
	panels: '\
		<div class="s-m-side-panel-dismiss" data-action="toggleSidePanel" data-params="close,all"></div> \
		<aside class="s-m-panel s-m-left"></aside> \
		<aside class="s-m-panel s-m-right"></aside>'
};
/**
 * Native capabilities per page's type/subtype
 */
var _nativeCapabilities = {
	liveTile: {
		regular: {
			query: true,
			stat: true,
			cube: true
		}
	},
	scheduleMessage: {
		regular: {
			query: true,
			details: true,
			edit: false
		},
		dashboard: {
			std: true,
			welcome: false
		}
	},
	share: {
		regular: {
			query: true,
			details: true
		},
		dashboard: {
			std: true,
			welcome: false
		}
	}
};
//Need to be called after module's initialization
var _getNativeCapabilities = function(type, subtype) {
	var result = {};
	["liveTile", "scheduleMessage", "share"].forEach(function(capability) {
		var pageCapability = _nativeCapabilities[capability];
		result[capability] = pageCapability && native.hasCapability(capability);
		if (result[capability]) {
			result[capability] = pageCapability[type] != null && pageCapability[type][subtype] === true;
		}
	});
	return result;
};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx || {});
};
/*********** PANELS MANAGER ***********
 * !! Created/Destroyed only on main page (not on vignettes)
 * page		Main/Current page
 *************************************/
var PanelManager = function(page) {
	this.page = page;
	if (!page.isVignette) {
		// init $$elmts for panels
		page.$$elmt.append($(_getHtml("panels")));
		page.$$dismissPanel = page.$$elmt.children(".s-m-side-panel-dismiss");
	}
	this.destroy = function() {
		this.page = null;
	};
	/**
	 * Panels are attached to the main page
	 */
	this.mainPage = function() {
		return this.page.isVignette ? globals.getCurrentPage() : this.page;
	};
	/**
	 * Adds a panel to left or right sections - sidePanel class
	 * 		If not exists create it
	 * where	"left" or "right"
	 * panel	panel object
	 */
	this.panelAttach = function(where, panel, action) {
		var controller = this.mainPage();
		if (!controller.$$dismissPanel || !panel || (where != "right" && where != "left")) return;
		var currentPanel = controller.getPageControl(where);
		if (currentPanel && currentPanel != panel) {
			this.panelDetach(where);
		}
		if (!panel.isAttached(where)) {
			var $$parent = controller.$$elmt.children("aside.s-m-panel.s-m-" + where);
			if ($$parent.length != 1) return;
			// Add the control to the list
			controller.addControl(panel);
			controller._pageControls.add(where, panel).attach($$parent, where);
		}
		return this.panelToggle(where, panel, action);
	};
	/**
	 * Toggle panel
	 */
	this.panelToggle = function(where, panel, action) {
		var controller = this.mainPage();
		if (!panel) panel = controller.getPageControl(where);
		if (!panel || !panel.$$elmt) return null;
		// close -> Force hide - resize -> stay visible - toggle -> toggle
		panel.$$elmt.toggle(action === "close" ? false : undefined);
		var visible = panel.$$elmt.is(':visible') === true;
		var newWidth = visible ? panel.$$elmt.width() : 0;
		if (panel.closeBox != true) {
			controller.$$dismissPanel[visible ? "addClass" : "removeClass"](where);
			controller.$$dismissPanel.css(where, newWidth);
		}
		if (panel.overlap != true) {
			var self = this;
			var shiftElmts = [controller.$$contentElmt];
			_insidePageControls.forEach(function(id) {
				var c = controller.getPageControl(id);
				if (c) {
					shiftElmts.push(c.$$elmt.parent());
				}
			});
			shiftElmts.forEach(function($$elmt) {
				$$elmt.css("left", (visible ? (where === "right" ? -1 : 1) * newWidth : 0) + "px");
			});
		}
		panel.notifyToggled(where, action, visible);
		return panel;
	};
	/**
	 * Removes the panel but not destroy it
	 * where	"left" or "right"
	 */
	this.panelDetach = function(where) {
		var controller = this.mainPage();
		if (!controller.$$dismissPanel) return;
		var p = controller.getPageControl(where);
		if (!p) return;
		this.panelToggle(where, p, "close");
		controller.removeControl(p);
	};
	/**
	 * Returns a panel - Just to have ctrlFactory declared here
	 * id	globals.PANELACTIONSREGULAR, globals.PANELUSERSMARTPHONE, globals.PANELFILTERSORT
	 */
	this.panelCreate = function(panelId, options) {
		// controller of the control is the current page because we could need to access to this page from the panel (Ex for a panel attached to a vignette)
		return ctrlFactory.createPanel(this.page, panelId, options);
	};
	this.panelResize = function(context) {
		var controller = this.mainPage();
		["right", "left"].forEach(function(w) {
			var p = controller.getPageControl(w);
			if (p && p.onResize) p.onResize(context);
		});
	};
};
/*********** PAGE CONTROLS MANAGER ***********
 * Page controls are not attached to rootLayout
 * header/footer
 ************************************************/
var PageControls = function(page) {
	this.page = page;
	this.map = {};
	this.statics = {};
	this.add = function(id, ctrl) {
		if (!ctrl) return;
		if (this.map[id]) {
			console.log("Page Control " + id + " already exists");
		}
		this.map[id] = ctrl;
		if (_insidePageControls.indexOf(id) >= 0) {
			this.statics[id] = ctrl;
		}
		return ctrl;
	};
	this.get = function(id) {
		return this.map[id];
	};
	this.remove = function(ctrl) {
		if (!ctrl) return;
		var ctrlType = null;
		for (var id in this.map) {
			if (this.map[id] === ctrl) {
				ctrlType = id;
				break;
			}
		}
		if (ctrlType) {
			// Delete - Do not set to undefined because we want to remove the entry
			delete this.map[ctrlType];
			delete this.statics[ctrlType];
		}
		if (ctrl.detach) {
			ctrl.detach();
		} else if (ctrl.$$elmt) {
			ctrl.$$elmt.detach();
		}
		return ctrl;
	};
	this.destroyControls = function() {
		if (!this.map) return;
		for (var id in this.map) {
			if (this.map[id]) {
				this.map[id].destroy();
			}
		}
		this.map = {};
		this.statics = {};
	};
	this.status = function() {
		var x = [];
		for (var id in this.map) {
			x.push(id + "=" + this.map[id].id);
		}
		return x.join('/');
	};
	this.destroy = function() {
		this.page = null;
		this.destroyControls();
	};
	/**
	 * Only on static controls header/footer
	 */
	this.buildHtml = function(dao, buildOptions) {
		for (var id in this.statics) {
			var $$parent = this.page.$$elmt.children(id); // id = tag name of container (for footer/header)
			if ($$parent.length < 1) {
				$$parent = this.page.$$elmt.children(".s-m-" + id); // id = class name tag name of container (for breadcrumbs)
			}
			this.statics[id].buildHtml($$parent, dao, buildOptions);
		}
	};
	this.afterRender = function(buildOpts) {
		for (var id in this.statics) {
			if (this.statics[id].afterRender) this.statics[id].afterRender(buildOpts);
		}
	};
	/**
	 * All controls header/footer/leftPanel/rightPanel
	 */
	this.forAllCtrls = function(cb) {
		for (var id in this.map) {
			cb(id, this.map[id]);
		}
	};
	this.closeSidePanel = function() {
		// TODO
	};
	// Called when we skip controls - Refresh them
	this.doAfterPageReload = function(addToControlMap) {
		var c;
		for (var id in this.map) {
			var c = this.map[id];
			// Put the controls in control map
			if (addToControlMap) {
				this.page.addControl(c);
			}
			// Refresh the controls 
			if (c.refresh) {
				c.refresh();
			}
		}
	};
};
/****************** PAGE CLASS *********************
 * Base class for all pages
 *  $$parent: Parent element
 * 	state: Page information - JSON structure stored in history
 *  prototype: Prototype object (class prototype)
 *  article: JSON article
 *  !! Temporarily prototype and article can be null for html pages
 ***************************************************/
var _defOpts = {
	header: true,
	footer: true,
	breadcrumbs: false,
	topToolbar: false
};

var _Page = utils.defineClass(
	function Page($$parent, state, prototype, article, options) {
		Base.call(this, state.uuid, prototype, article, $.extend({}, _defOpts, options));
		this._pageControls = null;
		this._panelsManager = null;
		this._$$parent = $$parent;
		this.state = state;
		this.state.options = state.options || {};
		this.ctrlAfterRenderCalls = [];
		this.ctrlSaveCtxCalls = [];
		this._offline = false;
		this.isVignette = state.options.vignette === true;
		this.isChild = state.options.parentId != null;
		this.nativeCapabilities = _getNativeCapabilities(this.state.type, this.state.subtype.split(" ")[0]);
		if (this.isChild) {
			// Children pages are cached - no destry if we open a child page from this page
			this.state.cached = true;
		}
		this._initRootElmt($$parent);
		// true if page is created - set by page loader when page is activated
		this.isNew = false;
		// Last selected row - Used to save/restore context of last selected row
		this.lastSelectedRow = null;
		this.nbCharts = 0;
		// Panel that displays shared Settings
		this._panelSharedSettings = null;
		notifications.subscribe(this, ["sm.select.row", "sm.updt.card.article", "sm.updt.chart.detail.article", "sm.scroller.update"], 1);
	}, Base, {
		resetMaps: function() {
			Base.prototype.resetMaps.call(this);
			// Contains controls that need to be called after Render - outside pageControls
			this.ctrlAfterRenderCalls = [];
			// Contains controls that have a context to save in order to retrieve it when page will be load (eg: back navigation)
			this.ctrlSaveCtxCalls = [];
		},
		/**
		 * Create and return root DOM element of every page
		 * 		DOM element is hidden and contains only the structure
		 * 		Page object is stored in DOM element under data("smcontroller")
		 */
		_initRootElmt: function($$parent) {
			var self = this;
			var type = self.state.type;
			var root, ctx = {
					pageid: self.id,
					type: type, // regular/html/dashboard
					subtype: self.state.subtype, // regular - > facet - dashboard -> std/welcome/home - html -> login/about...
					parentId: self.getParentId()
				};
			if (self.isVignette) {
				// only content in a vignette
				self.$$contentElmt = self.$$elmt = $(_getHtml("vignette", ctx));
			} else {
				self.$$elmt = $(_getHtml("fullpage", ctx));
				self.$$contentElmt = self.$$elmt.children("section.s-m-main-content");
				// Page controls only for main page
				self._pageControls = new PageControls(self);
				var shift = 0;
				_topPageControls.forEach(function(id) {
					if (self.options[id] === true) {
						shift += uiSettings.getProp(id + ".height");
					}
				});
				if (shift > 0) {
					// It's better to fix the top before mainResize even if it can change
					// When we restore context (scroll...) on back we need that because restore context is done before mainREsize
					self.$$contentElmt.css({
						top: shift
					});
				}
			}
			// Panel manager should be attached to the main page - For vignettes we should take toe one of the main page
			//  -> Temporarlilly we create a Panel manager for vignettes because main page (globals.currentPage) is not available when we create the controls of the vignette
			//  -> Ex when we create an array sortFilter panel in a vignette
			//  -> TODO - Review the loading process of vignettes to pass the main page (pageToOpen) as a parameter or option 
			//  -> After that we will be able to set self._panelsManager = mainPage._panelsManager for vignettes
			self._panelsManager = new PanelManager(self);
			if (self.scrollAllowed()) {
				// Scroll in page is allowed for $details and $edit
				// For dashboard this is the layout which scrolls (not the page)
				// For query this si the array  which scrolls (not the page)
				// Only if scroll allowed - Ex: In wignette with charts we musn't have the scroll wrapper becaus eit breaks size calculation 
				self.$$scrollWrapper = $('<div class="s-m-scroll-wrapper"/>').appendTo(self.$$contentElmt);
				self.$$scrollWrapper.css({
					height: "auto"
				});
				self.$$ctrlsRootElmt = self.$$scrollWrapper;
				// Create scroll manager here because it must be created when we restore the context on back
				self._gestureMgr = new HammerScroller(self.$$scrollWrapper, {
					// isPageScroller: true for full page
					// isPageScroller: false for vignette - The view rectangle scolls with the content of the page
					isPageScroller: !self.isVignette
				});
			} else {
				self.$$ctrlsRootElmt = self.$$contentElmt;
			}
			self.$$elmt.hide();
			self.$$elmt.appendTo($$parent);
			// attaches page object to DOM element
			// !!Important because it allows the application/vignette to remove all pages/subpages by using the dom - See application.removeAllChildPages
			self.$$elmt.smPageController(self);
		},
		destroy: function() {
			if (this.destoyed) return;
			// Fisrt to destroy the rootLayout
			Base.prototype.destroy.call(this);
			// Destoy own stuff
			this._$$parent = null;
			if (this._pageControls) {
				this._pageControls.destroy();
				this._pageControls = null;
			}
			if (this._panelsManager) {
				this._panelsManager.destroy();
				this._panelsManager = null;
			}
			if (this._waiting) {
				uiutils.waitWheelDestroy(this._waiting);
				this._waiting = null;
			}
			this.ctrlAfterRenderCalls = null;
			this.ctrlSaveCtxCalls = null;
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
			if (this.$$elmt) {
				this.$$elmt.smPageRemoveController(this);
				this.$$elmt.unbind();
				this.$$elmt.remove();
				this.$$elmt = null;
			}
			if (this._panelSharedSettings) {
				notifications.unsubscribe(this, "sm.page.share");
				this._panelSharedSettings.destroy();
				this._panelSharedSettings = null;
			}
		},
		/**
		 * Called be pageLoader - TODO TEST
		 */
		destroySiblings: function() {
			if (this.$$elmt) {
				log && log("Page destroySiblings", "destroySiblings");
				var next = this.$$elmt.siblings(function(idx) {
					var ctrl = $(this).smPageController();
					if (ctrl) ctrl.destroy();
				});
			}
		},
		isSamePage: function(pageName, pageOptions) {
			return !this.destropyed && this.isActive() && this.state.name === pageName;
		},
		_actPageShare: function() {
			if (native.hasCapability("liveTile")) {
				if (!this._panelSharedSettings) {
					notifications.subscribe(this, "sm.page.share");
					this._panelSharedSettings = this.panelCreate(globals.PANELPAGESHARE);
				}
				this.panelAttach("right", this._panelSharedSettings, "toggle");
			}
		},
		getPageShareContext: function() {
			var settings = {
				opt: this.nativeCapabilities,
				ctx: {
					pageTitle: this.state.$title
				},
				vignettes: []
			};
			if (this.vignettes) {
				this.vignettes.forEach(function(vignette) {
					var page = vignette.getPage();
					if (page && page.showPageShare()) {
						settings.vignettes.push({
							id: vignette.id,
							opt: page.nativeCapabilities,
							ctx: {
								pageTitle: page.state.$title || vignette.parent.title
							}
						});
					}
				});
			}
			return settings;
		},
		/**
		 * dashboard/regular/html
		 */
		getType: function() {
			return this.state.type;
		},
		/**
		 * Allows prop = "options.parentId"
		 */
		getProp: function(prop) {
			return utils.getPropByPath(this.state, prop);
		},
		/**
		 * typeControl: "header", "breadcrumbs", "topToolbar", "footer"
		 */
		getPageControl: function(typeControl) {
			return this._pageControls ? this._pageControls.get(typeControl) : false;
		},
		/**
		 * Set by vignette at page loading
		 */
		openLinkInVignette: function() {
			return this.state.options.openLinkInVignette === true;
		},
		/**
		 * Load the page
		 * 		The result is that the page is created and attached to DOM document and hidden
		 * 		the contoller of the page (applictaion/vignette) has to call activate method to display the page (see pageLoader module)
		 * loadOptions:
		 * 		updateLayout -> true to not load the data and update only main layout
		 */
		load: function(loadOptions) {
			var self = this;
			loadOptions = loadOptions || {};
			var timeLine = utils.getTimeLine("page", self.state.name);
			timeLine && timeLine.start();
			return $.smResolve()
				.then(function() {
					return self.initOnLoad();
				})
				.then(function() {
					return self.buildHtmlOption(loadOptions);
				})
				.then(function(opts) {
					self.buildOpts = opts;
					return self.loadStructure(loadOptions);
				})
				.then(function() {
					timeLine && timeLine.step("loadStructure");
					if (self.destroyed) {
						return;
					}
					return self.loadData(loadOptions);
				})
				.then(function() {
					timeLine && timeLine.step("loadData");
					if (self.destroyed) {
						return;
					}
					return self.render(loadOptions, self.buildOpts);
				})
				.then(function() {
					timeLine && timeLine.step("render");
					if (self.destroyed) {
						return;
					}
					return self.afterRender(loadOptions, self.buildOpts);
				})
				.then(function() {
					timeLine && timeLine.stop();
				});
		},
		/**
		 * Create layout/control tree structure according to article
		 */
		loadStructure: function(loadOptions) {
			var self = this;
			return $.smResolve().then(function() {
				if (!self.article || !self.prototype) throw new Error("loadStructure - NULL article or prototype");
				if (self._pageControls && loadOptions.skipPageControls !== true) {
					var top = 0;
					_insidePageControls.forEach(function(id) {
						if (self.options[id] === true) {
							var ctrl = self.createPageControl(id);
							if (ctrl) {
								// Save orginal header in case we can change it (vignette context) _pageHeader, _pageFooter...
								self["_page" + id.smCapitalize()] = self._pageControls.add(id, ctrl);
								if (_topPageControls.indexOf(id) >= 0) {
									// Save root and show - _$$breadcrumbs, _$$topTolBar
									self["_$$" + id] = self.$$elmt.children("section.s-m-" + id).show().css("top", top);
									// Set top in advanced to avoid moving elements
									top += uiSettings.getProp(id + ".height");
								}
							}
						};
					});
				}
				// Creates control / fields tree(from article)
				var opts = {
					// If edit/create in vignette we need to notify focus on fields to enbable/disable vignette selection
					notifyFocus: self.isVignette && (self.$activity === "edit" || self.$activity === "create")
				};
				self.buildControlsTree(opts);
			});
		},
		/**
		 * Can be overridden
		 */
		createPageControl: function(id) {
			return ctrlFactory.createPageControl(id, this);
		},
		/**
		 * Load page data
		 */
		loadData: function(loadOptions) {
			var self = this;
			return $.smResolve().then(function() {
				self.setDao(null);
			});
		},
		/**
		 * Rendering - Build html and attachs dom elements to document
		 */
		render: function(loadOptions, buildOpts) {
			var self = this;
			return $.smResolve().then(function() {
				if (!self.rootLayout) {
					throw new Error("buildHtml - NULL rootLayout");
				}
				// Renders header/footer
				if (self._pageControls && loadOptions.skipPageControls !== true) {
					self._pageControls.buildHtml(self.dao, buildOpts);
				}

				if (self.$$ctrlsRootElmt) {
					self.beforeAddContent();
					// Renders tree controls (article)
					Base.prototype.render.call(self, self.$$ctrlsRootElmt, buildOpts);
				}
			});
		},

		/*
		 * First action (deferred) called on page loading
		 * Can be used to cache data from async operations that are needed later in
		 * page loading in sync processes
		 */
		initOnLoad: function() {
			return $.smResolve();
		},

		/**
		 * return build options for controls
		 * Set options for all controls
		 * Header -> options for header control
		 * Can be overridden
		 */
		buildHtmlOption: function(loadOptions) {
			var self = this;
			var resultOpts = {
				authoringUpdate: loadOptions.authoringUpdate === true,
				updateLayout: loadOptions.updateLayout === true,
				makeFullHeight: self.isVignette,
				toolBars: {
					showAuthoring: self.state.disableAuthoring !== true,
					showUserMenuLinks: !self.isChild,
					showHome: !self.isChild && !this.state.isWelcomePage,
					showActions: true,
					showNativeShare: self.nativeCapabilities.share,
					showPageShare: self.showPageShare()
				}
			};
			return settings.isPinnedPage(self.getPinPageId())
				.then(function(isPinned) {
					resultOpts.toolBars.statusPinPage = !self.isChild ? (isPinned ? 2 : 1) : 0;
				})
				.then(function() {
					if (self.isChild) {
						// Child pages are not allowed to be authored, except for lookups
						if (self.$facet === "lookup") {
							resultOpts.showAuthoring = resultOpts.showAuthoring && true;
						} else {
							resultOpts.showAuthoring = false;
						}
					}
				})
				.then(function() {
					return resultOpts;
				});
		},
		/**
		 * Called from authoring to update the page's article
		 */
		authUpdateLayout: function(article, options) {
			this.article = article;
			options = options || {};
			options.authoringUpdate = true;
			return this.reload(options);
		},
		/**
		 * Reload the page by default
		 * Overridden - pagrRegular refresh sdataUrl....
		 */
		refresh: function(options, callBackInterface) {
			return this.reload();
		},
		/**
		 * Reload page - Only Data
		 */
		reload: function(options) {
			var self = this;
			self.waitWheelStart();
			// Init controsl maps
			self.resetMaps();
			// destroy all controls and layouts
			self.rootLayout.destroy();
			// $pageActionSettings needs to redraw the header/footer
			var updatePageControls = (self.article.$allowDownload != null || self.article.$pageActionSettings != null) && self._pageControls != null;
			if (updatePageControls) {
				self._pageControls.destroyControls();
			}
			// Clear dom
			self.$$ctrlsRootElmt.empty();
			options = options || {};
			// Reload with updateLayout and skipPageControls option
			// 	-> don't load data
			//	-> don't create page controls
			// Don't forget to check overridden method if we add new properties in options
			if (options.updateLayout == null) {
				// options.updateLayout can be != null - In certain rare cases we want to force to load data
				options.updateLayout = true;
			}
			options.reload = true;
			options.skipPageControls = updatePageControls === false;
			return self.load(options).then(function() {
				// Add page controls to maps
				if (self._pageControls) {
					self._pageControls.doAfterPageReload(options.skipPageControls);
				}
				// Recalculate layouts
				uiutils.triggerResizeInternal(options);
			}).then(function() {
				self.waitWheelStop();
			}).fail(function(e) {
				self.waitWheelStop();
				globals.getModal().error("Error", e);
			});
		},
		/**
		 * Resize of application main page
		 * info give the size in pixels of mainContent/header/footer - see siteLayout
		 * We need it to pass to rootLayout without having to set the size od $$contentElmt
		 * $$contentElmt must have css.height set to auto for scrolling
		 * info.updateLayout = true if page updated by authoring
		 */
		onMainPageResize: function(info, orientation, deviceClass) {
			var self = this;
			if (!this.isVignette) {
				if (info.deviceChanged) {
					// Restore the regular header/footer - Modified by actions in vignettes
					// Needed to apply onMainPageResize on the right controls
					this.toggleHeaderFooter("header", null, true);
					this.toggleHeaderFooter("footer", null, true);
				}
				// Set device type for css
				if (this._deviceType) this.$$elmt.removeClass(this._deviceType);
				this._deviceType = globals.getSiteLayout().getDeviceType();
				this.$$elmt.addClass(this._deviceType);
				/**
				 * or main page we calculate the H/W in pixels - BAs of calculation comes from application/SiteLayout
				 */
				var top = 0,
					left = 0;
				var contentHeight = info.application.height;
				var contentWidth = info.application.width;
				if (self._pageControls) {
					info.contentWidth = contentWidth;
					info.contentHeight = contentHeight;
					self._pageControls.forAllCtrls(function(id, ctrl) {
						if (ctrl.onMainPageResize) {
							ctrl.onMainPageResize(info, orientation, deviceClass);
						}
					});
					// We need to iterate on _insidePageControls with the right to to bottom order
					var ctrl;
					_insidePageControls.forEach(function(id) {
						ctrl = self.getPageControl(id);
						if (ctrl && ctrl.isVisible()) {
							var ch = ctrl.getHeight();
							contentHeight -= ch;
							if (_topPageControls.indexOf(id) >= 0) {
								var $$root = self["_$$" + id];
								if ($$root) {
									$$root.css({
										top: top
									});
									top += ch;
								}
							}
						}
					});
				}
				self.$$contentElmt.css({
					top: top + "px",
					left: left + "px",
					width: contentWidth + "px",
					height: contentHeight + "px"
				});
			} else {
				/**
				 * For vignette we don't calculate the H/W in pixels.
				 * To do the calculatation we need to propagate the calculation from dashboard tile -> Control (not done and needed)
				 * H/W calculation is based on css style height auto for the wrapper et 100% for $$contentElmt
				 */
			}
			/**
			 * We need to create the scroller for main page and page embeded in vignette
			 */
			// Save content rectangle for scrolling and hub layout - "computed" to ignore padding
			self._mainContentRect = uiRect.elmtRect(self.$$contentElmt, "computed");
			// We need to set the right coordinates for intersectRect with scroller
			self._mainContentRect.moveLeft(parseInt(self.$$contentElmt.css("padding-left"), 10));
			self._initScroll(info && info.preserveScroll);
			// info is the context of resize - info.u^dateLayout = true if page updated by authoring
			self.onResize(info);
		},
		/**
		 * returns main content rect for hub layout
		 */
		getMainContentRect: function() {
			return this._mainContentRect;
		},
		/**
		 * Resize handler called by window.resize
		 */
		onResize: function(context) {
			if (this.sizeModified != true) {
				if (this._resizeContext && context) {
					// Optimization for triggerResize on back - We need to know if sized changed (orientation/device type...)
					this.sizeModified = this._resizeContext.contentHeight != context.contentHeight || this._resizeContext.contentWidth != context.contentWidth;
				} else {
					this.sizeModified = false;
				}
			}
			this._resizeContext = $.extend({}, context);
			// Call resize handler in tree hierachy
			if (this.rootLayout && this.rootLayout.onResize) {
				this.rootLayout.onResize(context);
			}
			if (this._panelsManager) {
				this._panelsManager.panelResize(context);
			}
		},
		/**
		 * Specific procces after rendering
		 */
		afterRender: function(loadOptions, buildOpts) {
			var self = this;
			return $.smResolve().then(function() {
				// afterRender for controls - outside pageControls
				self.ctrlAfterRenderCalls.forEach(function(c) {
					c.afterRender(buildOpts);
				});
				if (self._pageControls && loadOptions.skipPageControls !== true) {
					// for _pageControls afterRender is called only at the creation of the page
					self._pageControls.afterRender(buildOpts);
				}
			});
		},
		beforeAddContent: function() {},
		addTitle: function(title, description) {
			var html = "";
			if (title) html = '<header class="s-m-page-title">' + title + '</header>';
			if (description) html += '<p>' + description + '<p>';
			if (html.length > 0) $(html).prependTo(this.$$ctrlsRootElmt);
		},
		/**
		 *  called each tile a control/layout is created
		 **/
		addControl: function(c) {
			Base.prototype.addControl.call(this, c);
			// For controls others that page Controls
			if (!c.isPageControl()) {
				// stores controls that need specific processes
				// !!! It's the simplest way to identify controls by testing the presence of the method when we add them
				// Another way woud be that it's the control that asks the page to be notified
				// After render
				if (c.afterRender) this.ctrlAfterRenderCalls.push(c);
				// Save context
				if (c.savedCtxCreate && c.savedCtxRestore) this.ctrlSaveCtxCalls.push(c);
			} // PageControls are managed separately because of updateLayout 
			if (c.$type === "application/x-array" && jsutils.isInstanceOf(c, "CtrlArrayChart") && c.isHighChart()) {
				//#6974 Fix svg issue in chrome - see dashBoard page
				this.nbCharts++;
			}
		},
		removeControl: function(c) {
			if (!c) {
				return;
			}
			Base.prototype.removeControl.call(this, c);
			if (this._pageControls && c.isPageControl()) {
				// removeControl if any
				this._pageControls.remove(c);
			}
			return c;
		},
		/**
		 * Display the page and hides currentPage
		 * 		Manage transitions (effect) according  to self.getProp("transition")
		 *		Do not call show directly
		 * 		cb is called after oage hs been displayed (we don't use deferred)
		 * pageToClose is the page ths will be replaced by this
		 * 		For a child page currentPage is the parent page
		 *			Used by rowdetail page to read the DAO
		 */
		activate: function(pageToClose, cb) {
			var self = this;
			self._show(pageToClose, function() {
				if (self.getSavedContext()) {
					self.savedCtxRestore(self.getSavedContext());
				} else if (self.lastSelectedRow) {
					// We allways restore last selected row because it is stored in page when we clik the link that opens the 'child' page
					self._hilightLastSelectedRow(self.lastSelectedRow);
				}
				if (cb) cb();
			});

		},
		/**
		 * Called after the page have bee activated
		 * Page and controls are visible
		 */
		activated: function() {},
		/**
		 * Hide the page
		 * 	Do not call hide or show directly
		 * A "cached" page is deactivated instead of being destroyed on navigation event
		 */
		deactivate: function(cb) {
			this._hide(cb);
		},
		/**
		 * returns the context to save
		 * It scanss al the controls taht implement savedCtxCreate (self.ctrlSaveCtxCalls)
		 * To add data to savedContext we just need to impement this methid on the control and return a JSON object
		 * Can be overridden (ex dashboard to manage contexts of vignettes)
		 * type		added for context restoration needs for links (email, handleLink see nativeShare)
		 * 			it's used to manage the content of the context and the restoration (see pageLoader)
		 * 			Values:
		 * 				"back"
		 * 					by default the type is "back" because originally the savedContext was used to manage context restoration on back
		 * 				"link"
		 * 					tells the page/controls that the context will be used in a link
		 *
		 */
		savedCtxCreate: function(type) {
			var self = this;
			type = type || "back";
			var ctx = {
				type: type,
				pageName: this.state.name,
				lastSelectedRow: self.lastSelectedRow
			};
			if (self._gestureMgr) {
				// Save page scrolling
				ctx.scroll = self._gestureMgr.savedCtxCreate(type);
			}
			if (self.ctrlSaveCtxCalls && self.ctrlSaveCtxCalls.length > 0) {
				ctx.ctxCtrls = {};
				// Save controls contexts - All controls who implement savedCtxCreate are added to ctrlSaveCtxMap
				// We take $bind as control ID because id is changed each time we create a control
				self.ctrlSaveCtxCalls.forEach(function(c) {
					var ctrlCtx = c.savedCtxCreate(type);
					if (ctrlCtx) ctx.ctxCtrls[c.$bind] = ctrlCtx;
				});
			}
			return ctx;
		},
		/**
		 * Restore page context - Called after activation (show)
		 * Restore page + controls contexts
		 */
		savedCtxRestore: function(ctx) {
			var self = this;
			if (!ctx) return;
			if (ctx.pageName != this.state.name) {
				// The page is not able to restore child pages inside a vignette - TODO if needed
				// If we go to detail page in ful page from a dashboard and go back a vignette that contains a detail page will not restore the context if current page was a child page
				// -> Only main parent page is restored
				return;
			}
			if (self._gestureMgr && ctx.scroll) {
				// Restore page scrolling
				self._gestureMgr.savedCtxRestore(ctx.scroll, true);
			}
			if (ctx.ctxCtrls) {
				// Restore controls context
				// We take $bind as control ID because id is changed each time we create a control
				for (var bind in ctx.ctxCtrls) {
					var c = self.getControlByBind(bind);
					var ctrlCtx = self.getCtrlSavedContext(bind);
					if (c && c.savedCtxRestore && ctrlCtx) {
						c.savedCtxRestore(ctrlCtx);
					}
				}
			}
		},
		/**
		 * returns the saved context
		 */
		getSavedContext: function(propName) {
			var ctx = this.state.savedContext;
			if (!propName || !ctx) return ctx;
			return ctx[propName];
		},
		/**
		 * Update the saved context when the page is closed - Called by pageLoader
		 * SavedContext  is stored in page state to be persistent
		 */
		updateSavedContext: function(clear) {
			this.state.savedContext = clear ? null : this.savedCtxCreate();
		},
		/**
		 * The regular context management restores the context when the page is activated (see savedCtxRestore)
		 * This process is generic and works fine for page and controls
		 * In some particular cases we need to restore the context before activating the page (when we create the control)
		 * The only case is the restauration of the search criteria for the array in query facet. We need the value (if any) before loading the page for sDataUrl
		 * This method is called by the control if it's absolutely needed otherwise we should keep the regular process
		 * Returns the context for 'bind' contrl if any
		 */
		getCtrlSavedContext: function(bind) {
			var ctx = this.getSavedContext('ctxCtrls');
			return ctx && bind ? ctx[bind] : null;
		},
		_hilightLastSelectedRow: function(lastSelectedRow, old) {
			var self = this;
			var toggle = function(rowInfo, show) {
				// We take array$Bind as control ID because id is changed each time we create a control
				var c = self.getControlByBind(rowInfo.array$Bind);
				if (c && c.selectLastSelectedRow) {
					c.selectLastSelectedRow(rowInfo.rowId, show);
				}
			};
			if (old) toggle(old, false);
			if (lastSelectedRow) {
				toggle(lastSelectedRow, true);
				return true;
			}
			return false;
		},
		_show: function(currentPage, cb) {
			var self = this;
			var transition = self.getProp("transition");
			if (currentPage) {
				currentPage._hide(function() {
					self.$$elmt.show(transition || 0, function() {
						if (cb) cb();
					});
				});
				return;
			}
			self.$$elmt.show(transition == null ? 0 : transition, cb);
		},
		_hide: function(cb) {
			if (!this.$$elmt) {
				if (cb) cb();
				// page has been destroyed
				return;
			}
			// Close panels
			if (this._pageControls) {
				this._pageControls.closeSidePanel("all");
			}
			var transition = this.getProp("transition");
			this.$$elmt.hide(transition == null ? 0 : transition, cb);
		},
		isActive: function() {
			return this.$$elmt && this.$$elmt.is(":visible");
		},
		/**
		 * True is page is a lookup
		 */
		isLookup: function() {
			return this.prototype && this.prototype.isLookup();
		},
		isAppHomePage: function() {
			return this.state.name === globals.getApplication().homePageId;
		},
		/**
		 * Return the info to notify parent when the child page is closed
		 * It depends on the kind of page
		 * Ex: lookup notifies parent control with selected value
		 */
		getParentNotif: function() {
			throw new Error("not implemented");
		},
		/**
		 * Return the id of parent page if any
		 */
		getParentId: function() {
			return this.isChild ? this.state.options.parentId : null;
		},

		/**
		 * Returns attribute for the link that opens this page (used to open this page from a vignette to full page)
		 * Overriden by regular page to put s-data-url
		 */
		getOpenLinkAttrs: function() {
			return {
				"data-nav": this.state.name
			};
		},

		/***
		 * Test action
		 */
		_actTest: function(params) {
			var e = $('<h5 style="color:red">Action test succeeded</h5>').prependTo(this.$$elmt);
			window.setTimeout(function() {
				e.remove();
			}, 2000);
		},
		/**
		 * Click on home in footer/header
		 * Can be overrridden - rowDetail
		 */
		_actHome: function() {
			globals.getApplication().gotoWelcomeApplication();
		},
		/**
		 * Wait wheel management
		 * We need one plugin per page
		 */
		waitWheelStart: function(controlId) {
			if (controlId) {
				var c = this.getControl(controlId);
				if (c && c.waitStart) c.waitStart();
				return;
			}
			if (this.getParentVignette()) {
				this.getParentVignette().waitStart();
				return;
			}
			if (!this._waiting) {
				this._waiting = uiutils.waitWheelCreate(this.$$elmt);
			}
			uiutils.waitWheelStart(this._waiting);
		},
		waitWheelStop: function(controlId) {
			if (controlId) {
				var c = this.getControl(controlId);
				if (c && c.waitStop) c.waitStop();
				return;
			}
			if (this.getParentVignette()) {
				this.getParentVignette().waitStop();
				return;
			}
			if (this._waiting) {
				uiutils.waitWheelStop(this._waiting);
			}
		},
		/**
		 * Called synchronously by an array when a row has been selected
		 * 	arrayId		Id of array
		 * 	rowId		Id of row
		 * 	rowdata		data of the row used by loojup page
		 */
		notifSelectRow: function(arrayId, rowId, rowdata) {
			var c = this.getControl(arrayId);
			if (!c) return;
			// !! selections works with $uuid - it doesn't work if no $uuid or same $uuid whihc occurs sometime in X3 dvlp folders 
			var old = this.lastSelectedRow;
			this.lastSelectedRow = {
				array$Bind: c.$bind,
				rowId: rowId
			};
			this._hilightLastSelectedRow(this.lastSelectedRow, old);
		},
		goBack: function() {
			if (this.isVignette) {
				return this.getParentVignette().goBack();
			} else {
				return globals.getApplication().goBack();
			}
		},
		/**
		 * Update the scroll for a vignette
		 *
		 */
		initVignetteScroll: function(back) {
			if (!this._gestureMgr) return;
			var viewRect = this.getParentVignette().getScrollViewRect();
			//if (back === true || (viewRect.height < this.$$scrollWrapper.height())) {
			// If back into a vignette we keep old scrolling - To improve 
			var keepOldScrolling = back === true;
			this._gestureMgr.init(viewRect, "v", 0, keepOldScrolling);
			//}
		},
		/**
		 * Enable/Disable scrolling
		 */
		_initScroll: function(preserveScroll) {
			if (!this._gestureMgr) return;
			if (this.scrollAllowed()) {
				var viewRect = this.isVignette ? this.getParentVignette().getScrollViewRect() : this._mainContentRect;
				// Force $$scrollWrapper to full heigth of childrens
				// We scroll if childen height is greater than childrenRect height
				if (viewRect && viewRect.height < this.$$scrollWrapper.height()) {
					var valMax = 0;
					// If not new -> back on a cahced page - We keep scrolling
					preserveScroll = preserveScroll === true || this.isNew !== true;
					//viewRect has fixed coordinate to check if the 'finger' is inside on mousemouve event
					// A page always scolls verticaly - In dashboard this is the layout that scrolls horizontally
					this._gestureMgr.init(viewRect, "v", valMax, preserveScroll);
					var autoScroll = this.state.options["auto-scroll"];
					if (autoScroll != null) {
						// When we go to $edit form $details we keep the scrolling in order to stay at the same location (see actionManager)
						this.autoScroll(autoScroll);
						// Only when we loadd the page
						this.state.options["auto-scroll"] = undefined;
					}
				} else {
					this._gestureMgr.reset();
				}
			} else {
				// Disable _gestureMgr if any
				this._gestureMgr.reset();
			}
		},
		/**
		 * Update the scroller - needed for staked layouts
		 * In stacked/row layout the height of the page is given by the height of the content of the vignette
		 * Used by charts and vignettes
		 */
		notifScrollerUpdate: function() {
			// _gestureMgr != null for stack (not hub structure)
			if (!this._gestureMgr) return;
			// Optimization - If the height/width din't change we skip init Scroll (works only if (scale factor == 1)
			if (this._gestureMgr.viewRect && this._mainContentRect.equals(this._gestureMgr.viewRect, true)) return;
			// Init scroll because hight has changed - True to preserve scroll for authoring
			this._initScroll(true);
		},
		/**
		 * Scroll the page
		 */
		autoScroll: function(value) {
			// TODO - scroll the rootLayout for the dashboard
			if (this._gestureMgr) this._gestureMgr.autoScroll(value);
		},
		/**
		 * True if scroll enabled in page
		 * By default we can scroll a page in full display
		 * In vignettes only details/edit facet are allowed to scroll - See regular page
		 * In Dashboard hub this is the layout that scrolls - Page doesn't scroll
		 */
		scrollAllowed: function() {
			return !this.isVignette && !this.isDashboard("hub");
		},
		/**
		 * typeDashboard = hub / stack / undefined
		 */
		isDashboard: function(typeDashboard) {
			return false;
		},
		isNestedInDashboard: function(typeDashboard) {
			if (!this.isVignette) return false;
			if (!this.getParentVignette()) return false;
			return this.getParentVignette().controller.isDashboard(typeDashboard);
		},
		/**
		 * Returns the offset of the scrollRect top/left in fixed position (document)
		 * Overridden by dashboard
		 */
		getScrollOffset: function() {
			// Application content can be scrcolled (native in authoring)
			return globals.getApplication().getScrollOffset();
		},
		/**
		 * returns the value of the page's scroller
		 * 0 by default even if no scroller		 *
		 */
		getScrollValue: function() {
			return this._gestureMgr ? this._gestureMgr.getScrollValue() : 0;
		},
		setParentVignette: function(v) {
			this._parentVignette = v;
		},
		getParentVignette: function() {
			return this._parentVignette;
		},
		getVignettePageDashboard: function() {
			if (!this.isVignette || !this.getParentVignette()) {
				// If not avail we take the currentpage of mobile application (setParentVignette not initialized)
				return globals.getApplication().currentPage;
			};
			return this.getParentVignette().parent;
		},
		/**
		 * Return null, stack, hub
		 */
		getParentDashboardType: function() {
			if (!this.isVignette || !this.getParentVignette()) return null;
			return jsutils.isInstanceOf(this.getParentVignette().parent, "LayoutTile") ? "hub" : "stack";
		},
		getGestureMgr: function() {
			return this._gestureMgr;
		},
		/**
		 * Show element in page - scroll if needed
		 * c is a JQuery elmt or an object with $$elmt property
		 */
		makeVisible: function(c) {
			if (!c || !this.getGestureMgr() || !c.$$elmt) {
				return;
			}
			this.getGestureMgr().makeVisible(c.$$elmt);
		},
		/**
		 * Adds a panel to left or right sections - sidePanel class
		 */
		panelAttach: function(where, panel, action) {
			return this._panelsManager ? this._panelsManager.panelAttach(where, panel, action) : null;
		},
		/**
		 * Detach a panel from left or right sections - sidePanel class - needed by header
		 */
		panelDetach: function(where) {
			return this._panelsManager ? this._panelsManager.panelDetach(where) : null;
		},
		/**
		 * Returns a panel - Just to have ctrlFactory declared here
		 */
		panelCreate: function(panelId, options) {
			return this._panelsManager ? this._panelsManager.panelCreate(panelId, options) : null;
		},
		/**
		 * Toggle left/right panel - data-action="sidePanel"
		 * 	panel : left or right
		 * 	action toggle
		 */
		_actToggleSidePanel: function(action, side) {
			if (!this._panelsManager) return;
			var self = this;
			var side = side == null || side === "all" ? ["left", "right"] : [side];
			side.forEach(function(where) {
				self._panelsManager.panelToggle(where, null, action);
			});
		},
		externalLink: function(param) {
			window.open(param);
		},
		_actExternalLink: function(param) {
			/* sometime the link can contains coma. but the caller of _act (_doAct) split params form coma.
			 *
			 */
			var Url = "";
			for (var i = 0, l = arguments.length; i < l; i++) {
				if (typeof arguments[i] === "string") {
					Url = Url ? Url + "," : "";
					Url += arguments[i];
				}
			}
			this.externalLink(Url);
		},
		getPinPageId: function() {
			// Overridden by child classes!
		},
		getPinPageData: function() {
			return {
				name: this.state.name,
				title: this.prototype.data("$title") || locale.text("no.title"),
				id: this.getPinPageId(),
				icon: "star",
				applicationName: this.state.applicationName,
				voiceCommandContext: this.getRestoreContext("pinPage")
			};
		},
		/**
		 * Returns an object that allows the application to reopen the page
		 * reason: nativeAppClosing, pinPage, sharedLink...
		 */
		getRestoreContext: function(reason) {
			var self = this;
			var ctx = {
				endpoint: globals.getEndpoint(),
				applicationName: self.state.applicationName,
				role: globals.getUserRole(),
				currentState: {
					name: self.state.name,
					savedContext: self.savedCtxCreate("link"),
					options: {}
				}
			};
			if (self.state.options) {
				// sdata-url is set in pageRegular
				["dataParams"].forEach(function(p) {
					ctx.currentState.options[p] = self.state.options[p];
				});
			}
			return ctx;
		},
		getTileLinkContext: function() {
			var self = this;
			return sdataCommonResources.createSharedContext(this.getRestoreContext("sharedLink")).then(function(uuid) {
				return {
					Title: self.state.$title,
					DeepLink: {
						Title: self.state.$title,
						Url: jsutils.getOpenLinkUrl(uuid)
					}
				};
			}).fail(function() {
				return null;
			});
		},
		/**
		 * Returns page authoring property
		 * path: string with or without '.' separator or array of string
		 */
		getAuthoring: function(path, defValue) {
			var val = utils.getPropByPath(this.article, path);
			return val != null ? val : defValue;
		},
		notifUpdtCardArticle: function(notifData, controlId) {
			var array = this.getControl(controlId);
			if (!array || !notifData) return;
			array.setCardAuthoring(notifData.article);
		},
		notifUpdtChartDetailArticle: function(notifData, controlId) {
			var chart = this.getControl(controlId);
			if (!chart || !notifData) return;
			chart.setChartDetailAuthoring(notifData.article);
		},
		/**
		 * Used by test entities to attach an article to a link
		 * - When we open a detail from a query (array)
		 * 		$detailLinkArticle attribute
		 * 		$queryLinkArticle attribute
		 * - when we open a facet form a $link vignette
		 * 		$linkArticle attribute
		 */
		getLinkedPageArticle: function(ctrlId) {
			if (!ctrlId) return;
			var ctrl = utils.findControl($("#" + ctrlId, this.$$elmt));
			if (!ctrl || !ctrl.getLinkedPageArticle) return;
			return ctrl.getLinkedPageArticle();
		},
		getToolbarLinks: function() {
			return null;
		},
		getProtoLinks: function() {
			return null;
		},
		getMultiSelectionLinks: function() {
			return null;
		},
		/**
		 * actName	action's name
		 * prop		null -> All properties
		 * 			"options", "icon"
		 * 			options: {footerHeader:true/false, multiselection/false, refreshPage: true/false}}
		 */
		actionGetSettings: function(actName, prop) {
			var $actionsSettings = this.getAuthoring("$pageActionSettings");
			if (!$actionsSettings) return null;
			var res;
			$actionsSettings.some(function(setting) {
				if (setting.name === actName) {
					res = setting;
					return true;
				}
				return false;
			});
			return res == null ? null : prop == null ? res : res[prop];
		},
		isMultiSelectionEnabled: function() {
			return this.getAuthoring("$allowDownload") === true || this.getMultiSelectionLinks() != null;
		},
		hasFooterHeaderActions: function() {
			return false;
		},
		/**
		 * typeControl= "header" or "footer"
		 * newControl= Header or Footer control
		 * Switchs current footer/header by newControl
		 * Returns the current footer/header
		 * newControl =  null -> Restores the original footer/header
		 * show:	undefined toggle current footer/header with
		 * 			true display newControl
		 * 			false remove newControl
		 */
		toggleHeaderFooter: function(typeControl, newControl, show) {
			var currentControl = this.getPageControl(typeControl);
			if (newControl == null) {
				// Default control
				newControl = this["_page" + typeControl.smCapitalize()];
				// Regular toggle
				show = undefined;
			}
			if (show === true && newControl === currentControl) {
				// Already displayed
				return currentControl;
			}
			if (show === false && newControl !== currentControl) {
				// Already removed
				return currentControl;
			}
			if (currentControl) {
				this.removeControl(currentControl);
				if (newControl === currentControl && show === false) {
					// We set the regular footer/header
					newControl = this["_page" + typeControl.smCapitalize()];
				}
			}
			this._pageControls.add(typeControl, newControl);
			this.addControl(newControl);
			var $$root = this.$$elmt.children(typeControl);
			if (!newControl.$$elmt) {
				newControl.buildHtml($$root, this.dao);
			} else {
				$$root.append(newControl.$$elmt);
				// JQuery work around for 'a' tags - the JQuery.defaultDisplay function returns 'inline' for a and we need 'inline-block'
				// if we attach a footer and reattach it, call show/hide restores the defaultDisplay instead the orginal one 
				// if we don't detach the footer it works ok so we force inline-block
				newControl.$$elmt.find("a").css("display", "inline-block");
			}
			newControl.notifToggled(true);
			return currentControl;
		},
		showPageShare: function() {
			return this.nativeCapabilities && (this.nativeCapabilities.liveTile || this.nativeCapabilities.scheduleMsg || this.nativeCapabilities.share);
		},
		/**
		 * Switch from oof to on line
		 * yes	trus/false
		 * TODO - Do not manage at page level but as a global level to not notify user each time we open a page
		 */
		setOffLine: function(yes, notify) {
			this._offline = yes === true;
		},
		isOffLine: function() {
			return this._offline === true;
		},
		/**
		 * Called by sharePanel
		 */
		notifPageShare: function(action, data) {
			switch (action) {
				case "link":
					this._sharePageLink();
					break;
				case "liveTile":
					this._shareAddLiveTile(data);
					break;
				case "schedule":
					this._shareScheduleMessage(data);
					break;
			}
		},
		_sharePageLink: function() {
			this.getTileLinkContext().then(function(ctx) {
				native.getModule("share").sharePageLink({
					pageData: ctx
				});
			});
		},
		_shareAddLiveTile: function(data) {
			var liveTileModule = native.getModule("liveTile");
			if (!data || !liveTileModule) return;
			var options = {}, self = this;
			self.getTileLinkContext().then(function(ctx) {
				var page = data.vignette ? self.getControl(data.vignette).getPage() : self;
				var pageData = page.getPinPageData(); // allow to add information by subclasses;
				options = $.extend(true, {}, pageData, ctx, data);
				options.applicationName = self.state.applicationName;
				options.endpoint = pageData.endpoint || globals.getEndpoint();
				return liveTileModule.addLiveTile(options);
			}).then(function(result) {
				var notify;
				if (result && result.error) {
					notify = {
						severityClass: "warning",
						body: result.error.text,
						onlyWebapp: false
					};
				} else {
					notify = {
						severityClass: "success",
						title: "",
						body: locale.text("liveTile.page.add.ok"),
						onlyWebapp: false
					};
				}
				globals.getModal().notify(notify);
			});
		},
		_shareScheduleMessage: function(data) {
			var scheduleMessageModule = native.getModule("scheduleMessage");
			if (!data || !scheduleMessageModule) return;
			this.getTileLinkContext().then(function(ctx) {
				if (!ctx) return;
				data.DeepLink = ctx.DeepLink;
				scheduleMessageModule.scheduledMsg(data);
			});
		}
	}
);

exports.Page = _Page;