"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("page");
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var HammerScroller = require('syracuse-tablet/html/js/controls/hammerScroller').Klass;

/**
 * TODO - See how to manage header/footer height
 */
var _sizes = {
	header: {
		h: 50
	},
	footer: {
		h: 50
	}
};
/**
 * s-m-side-panel-dismiss: div that traps the events outside the panel when a panel if open
 */
var _templates = {
	fullpage: '\
		<section class="s-m-page s-m-full {{type}} {{subtype}}" id="{{pageid}}" {{#if parentId}}data-parent-id="{{parentId}}"{{/if}} class="ctrl-event-click" style=""> \
			<header></header> \
			<section class="s-m-main-content"></section> \
			<footer></footer> \
			<div class="s-m-side-panel-dismiss" data-action="sidePanel" data-params="close"></div> \
		</section> \
	',
	vignette: '<section class= "s-m-page s-m-nested {{type}} {{subtype}}" id="{{pageid}}"></section>',
	leftpanel: '<section class="s-m-panel s-m-left"></section>',
	rightpanel: '<section class="s-m-panel s-m-right"></section>'
};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx || {});
};
/**
 * Dispatching of navigation and action control
 */
var _panel2Control = {
	leftpanel: "tablet/x-navigationpanel",
	rightpanel: "tablet/x-pageactionpanel",
	header: "tablet/x-pageheader",
	footer: "tablet/x-pagefooter"
};
var _control2panel = {};
for (var p in _panel2Control) {
	_control2panel[_panel2Control[p]] = p;
}
/**
 * Static controls used by non HTML pages
 */
var StaticControls = function() {
	var _map = {};
	/**
	 * panelId:   name of panel header/footer/leftpanel/rightpanel
	 * ctrlType:  type of the control
	 * 		Ex: display navigation panel in leftpanel
	 * 		Ex: display action panel in rightpanel
	 */
	this.addPanel = function(panelId, page) {
		// For panelId header/footer
		var $$parent;
		if (panelId.indexOf('panel') >= 0) {
			// Create the container bea cus panel are only available for regular/dashboard pages (not for html)
			$$parent = $(_getHtml(panelId)).appendTo(page.$$elmt);
		} else {
			// Header/footer already present
			$$parent = page.$$elmt.find(panelId);
		}
		if ($$parent.length > 0) {
			_map[panelId] = {
				$$parent: $$parent,
				ctrlType: _panel2Control[panelId]
			};
		}
	};
	this.hasPanels = function() {
		return _map['leftpanel'] != null || _map['rightpanel'] != null;
	};
	this.destroy = function() {
		if (!_map) return;
		for (var id in _map) {
			if (_map[id].control) _map[id].control.destroy();
		}
		_map = null;
	};
	this.create = function(controller) {
		if (!_map) return;
		for (var id in _map) {
			_map[id].control = controller.createStaticControl(_map[id].ctrlType);
		}
	};
	this.buildHtml = function(dao, buildOptions) {
		if (!_map) return;
		var c;
		for (var id in _map) {
			c = _map[id];
			c.control.buildHtml(c.$$parent, dao, buildOptions);
		}
	};
	this.afterRender = function() {
		if (!_map) return;
		var c;
		for (var id in _map) {
			c = _map[id];
			if (c.control.afterRender) c.control.afterRender();
		}
	};
	this.get = function(id) {
		return (_map[id] || {});
	};
	this.has = function(id) {
		return this.get(id).control != null;
	};
	this.doSidePanelAction = function(page, side, action) {
		var id = side + "panel";
		var c = _map[id];
		if (!c) return;
		c.control.toggle(action, function(newWidth) {
			if (side === "left") {
				// Only for left panel shifts content
				var shift = [page.$$contentElmt];
				if (_map["header"]) shift.push(_map["header"].$$parent.find(".navbar"));
				if (_map["footer"]) shift.push(_map["footer"].$$parent.find(".navbar"));
				shift.forEach(function(e) {
					e.css("left", newWidth);
				});
			}
			// Dismiss 
			var dismiss = page.$$elmt.children(".s-m-side-panel-dismiss");
			dismiss[newWidth > 0 ? "addClass" : "removeClass"](side);
			dismiss.css(side, newWidth);
		});
		return c;
	};
	this.addToControlMap = function(page) {
		for (var id in _map) {
			page.addControl(_map[id].control, true);
		}
	};
};
/**
 * Base class for all pages
 *  $$parent: Parent element
 * 	state: Page information - JSON structure stored in history
 *  prototype: Prototype object (class prototype)
 *  article: JSON article
 *  !! Temporarily prototype and article can be null for html pages
 */
var _Page = utils.defineClass(
	function Page($$parent, state, prototype, article, options) {
		var self = this;
		state.options = state.options || {};
		// article, prototype, rootLayout null for html pages
		self.prototype = prototype;
		self.article = article;
		self.rootLayout = null;
		self._staticControls = null;
		self._$$parent = $$parent;
		self.state = state;
		self.id = state.uuid;
		self._initMaps();
		self.dao = null;
		self.isVignette = state.options.vignette === true;
		self.isChild = state.options.parentId != null;
		if (self.isChild) {
			// Children pages are cached - no destry if we open a child page from this page
			self.state.cached = true;
		}
		self._initRootElmt($$parent);
		notifications.subscribe(self, ["sm.action.link", "sm.select.row"], 1);
		// read/edit/create - read by default - overridden by child pages
		self.$activity = "read";
		// true if page is created - set by page loader when page is activated
		self.isNew = false;
		// Last selected row - Used to save/restore context of last selected row
		self.lastSelectedRow = null;
		self._gestureMgr = null;
	}, null, {
		_initMaps: function() {
			// Contains all the controls of the page including static controls
			this.controlsMap = {};
			// Contains controls that need to be called after Render - outside staticControls
			this.ctrlAfterRenderCalls = [];
			// Contains controls that need to be called after Show - outside staticControls
			this.ctrlAfterShowCalls = [];
			// Contains controls that have a context to save in order to retrieve it when page will be load (eg: back navigation)
			this.ctrlSaveCtxCalls = [];
		},
		/**
		 * Create and return root DOM element of every page
		 * 		DOM element is hidden and contains only the structure
		 * 		Page object is stored in DOM element under data("smcontroller")
		 */
		_initRootElmt: function($$parent) {
			var self = this;
			var type = self.state.type;
			var root, ctx = {
					pageid: self.id,
					type: type, // regular/html/dashboard
					subtype: self.state.subtype, // regular - > facet - dashboard -> std/welcome/home - html -> login/about...
					parentId: self.getParentId()
				};
			if (self.isVignette) {
				// only content in a vignette
				self.$$contentElmt = self.$$elmt = $(_getHtml("vignette", ctx));
			} else if (self.state.type === "html") {
				self.$$elmt = $(_getHtml("fullpage", ctx));
				self.$$contentElmt = self.$$elmt.find("section.s-m-main-content");
				// No controls/header/footers for html pages - Managed by the page itself
			} else {
				// Type "dashboard", "regular"
				self.$$elmt = $(_getHtml("fullpage", ctx));
				self.$$contentElmt = self.$$elmt.find("section.s-m-main-content");
				self._initStaticControls();
			}
			self.$$elmt.hide();
			self.$$elmt.appendTo($$parent);
			// attaches page object to DOM element
			self.$$elmt.smPageController(self);
		},
		_initStaticControls: function() {
			var self = this;
			if (self.state.type === "html" || self.isVignette) {
				return;
			}
			// Static controls for non html or vignette pages
			self._staticControls = new StaticControls(self);
			['header', 'footer', 'leftpanel', 'rightpanel'].forEach(function(p) {
				self.addPanel(p);
			});
			if (self._staticControls.hasPanels()) {
				notifications.subscribe(self, ["sm.side.panel.ready"], 1);
			}
		},
		_initGestureMgr: function() {
			var viewRect, typeScroll;
			if (this.isVignette) {
				// Scroll should be avoided - just for test vignette which need scroll
				typeScroll = "v";
			} else {
				if (this.isDashboard()) {
					var o = globals.getApplication().orientation || "landscape";
					typeScroll = o === "landscape" ? "h" : "v";
				} else {
					typeScroll = "v";
				}
			}
			// Create a disabled scroller
			var valMax;
			if (typeScroll === "v") {
				valMax = this._staticControls && this._staticControls.has("header") ? _sizes.header.h : 0;
			} else {
				valMax = 0;
			}
			this._gestureMgr = new HammerScroller(this.getScrollElement(), {
				direction: typeScroll,
				valmax: valMax,
				isPageScroller: true
			});
		},
		isDashboard: function() {
			return this.getType() === "dashboard";
		},
		/**
		 * Add control in control list
		 * panelId: header, footer, leftpanel, rightpanel
		 * Can be overridden to disable creation of controls
		 */
		addPanel: function(panelId) {
			return this._staticControls.addPanel(panelId, this);
		},
		/**
		 * Create the control object
		 * ctrlType: control's type
		 * Can be overridden to provide it's own control
		 */
		createStaticControl: function(ctrlType) {
			return ctrlFactory.createPageControl(ctrlType, this);
		},
		destroy: function() {
			var self = this;
			log && log('destroy page ' + self.state.name);
			if (self.dao) {
				self.dao.destroy();
				self.dao = null;
			}
			// At the end to destroy childs before parent
			if (self.$$elmt) {
				utils.unbindObj(self.$$elmt);
				self.$$elmt = null;
			}
			if (self._staticControls) {
				// TODO - Review FDB
				notifications.unsubscribe(self, ["sm.side.panel.ready"]);
				self._staticControls.destroy();
				self._staticControls = null;
			}
			if (self._waiting) {
				uiutils.waitWheelDestroy(self._waiting);
				self._waiting = null;
			}
			if (self.rootLayout) {
				self.rootLayout.destroy();
				self.rootLayout = null;
			}
			if (self.prototype) {
				// We destroy the proto
				self.prototype.destroy();
				self.prototype = null;
			}
			self._initMaps();
			utils.unbindObj(self);
			self.article = null;
			self.prototype = null;
			self._$$parent = null;
			if (self._gestureMgr) {
				self._gestureMgr.destroy();
				self._gestureMgr = null;
			}
		},
		/**
		 * Called be pageLoader - TODO TEST
		 */
		destroySiblings: function() {
			var self = this;
			if (self.$$elmt) {
				log && log("Page destroySiblings", "destroySiblings");
				var next = self.$$elmt.siblings(function(idx) {
					var ctrl = $(this).smPageController();
					if (ctrl) ctrl.destroy();
				});
			}
		},
		/**
		 * dashboard/regular/html
		 */
		getType: function() {
			return this.state.type;
		},
		/**
		 * Allows prop = "options.parentId"
		 */
		getProp: function(prop) {
			return utils.getPropByPath(this.state, prop);
		},
		/**
		 * Set by vignette at page loading
		 */
		openLinkInVignette: function() {
			return this.state.options.openLinkInVignette === true;
		},
		setDao: function(dao) {
			var self = this;
			if (self.dao && self.dao.destroy) self.dao.destroy();
			self.dao = dao;
		},
		/**
		 * Refresh the page
		 */
		refresh: function(options, callBackInterface) {
			throw new Error("Not implemeneted");
		},
		/**
		 * Used by refresh method to update controls after having loaded new data
		 * ids == null means all controls
		 */
		refreshControls: function(ids, options) {
			var self = this;
			var c;
			if (ids && ids.length > 0) {
				ids.forEach(function(id) {
					c = self.controlsMap[id];
					if (c) c.refresh(self.dao, options);
				});
			} else {
				Object.keys(self.controlsMap).forEach(function(key) {
					c = self.controlsMap[key];
					if (c) c.refresh(self.dao, options);
				});
			}
		},
		/**
		 * Load the page
		 * 		The result is that the page is created and attached to DOM document and hidden
		 * 		the contoller of the page (applictaion/vignette) has to call activate method to display the page (see pageLoader module)
		 * options:
		 * 			updateLayout:	true to not load the data and update only main layout
		 * 			parentPage:		parentPage when we load a rowdetail page
		 * 							!! do not store this page
		 */
		load: function(options) {
			var self = this;
			options = options || {};
			var deferred = $.Deferred();
			try {
				self.loadStructure(options)
					.then(function() {
						if (options.updateLayout) {
							return $.smResolve();
						}
						return self.loadData(options);
					})
					.then(function() {
						return self.render(options);
					})
					.then(function() {
						// Gesture event on page - we need to have create controls (header/footer)
						self._initGestureMgr();
						return self.afterRender(options);
					})
					.then(function() {
						deferred.resolve();
					}).fail(function(e) {
						deferred.reject(e);
					});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},
		/**
		 * Create layout/control tree structure according to article
		 */
		loadStructure: function(options) {
			var deferred = $.Deferred();
			var self = this;
			try {
				if (!self.article || !self.prototype) throw new Error("loadStructure - NULL article or prototype");
				// Creates header/footer/leftPanel/rightpanel controls - only if not update layout
				if (self._staticControls && options.updateLayout !== true) {
					self._staticControls.create(self);
				}
				// Creates control/fields tree (from article)
				self.rootLayout = articleParser.article2Controls(self, self.article, self.prototype, {}, self.state.options.layoutPath);
				deferred.resolve();
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},
		/**
		 * Load page data
		 */
		loadData: function() {
			var deferred = $.Deferred();
			var self = this;
			try {
				self.setDao(null);
				deferred.resolve();
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},
		/**
		 * Rendering - Build html and attachs dom elements to document
		 */
		render: function(options) {
			var self = this;
			try {
				if (!self.rootLayout) {
					throw new Error("buildHtml - NULL rootLayout");
				}
				var buildOpts = self.buildHtmlOption();
				// Renders header/footer/leftPanel/right controls
				if (self._staticControls && options.updateLayout !== true) {
					self._staticControls.buildHtml(self.dao, buildOpts);
				}
				if (self.$$contentElmt) {
					self._beforeAddContent();

					// Renders tree controls (article)
					self.rootLayout.buildHtml(self.$$contentElmt, self.dao, buildOpts);
				}
			} catch (e) {
				return $.smReject(e);
			}
			return $.smResolve();
		},
		/**
		 * return build ptions for controls
		 * Set options for all controls
		 * Header -> options for header control
		 * Can be overridden
		 */
		buildHtmlOption: function() {
			var self = this;
			return {
				makeFullHeight: self.isVignette,
				header: {
					showAuthoring: self.state.disableAuthoring !== true,
					isChild: self.isChild
				}
			};
		},
		/**
		 * Called from authoring
		 *	TODO Review FDB - use pageNotification or reload the page
		 */
		updateLayout: function(article) {
			var self = this;
			// Set new article which comes from authoring panel
			self.article = article;
			// Init controsl maps
			self._initMaps();
			// destroy all controls and layouts
			self.rootLayout.destroy();
			// Clear dom
			self.$$contentElmt.empty();
			// Reload with updateLayout option
			// 	-> don't load data
			//	-> don't create static controls
			return self.load({
				updateLayout: true
			}).then(function() {
				// Add static controls to maps
				self._staticControls.addToControlMap(self);
				// Recalculate layouts
				uiutils.triggerResizeInternal();
			});
		},
		/**
		 * Resize of application main page
		 * info give the size in pixels of mainContent/header/footer - see siteLayout
		 * We need it to pass to rootLayout without having to set the size od $$contentElmt
		 * $$contentElmt must have css.height set to auto for scrolling
		 */
		onMainPageResize: function(info, orientation) {
			var self = this;
			var h = 0;
			var contentHeight = info.application.height;
			var contentWidth = info.application.width;
			if (self._staticControls) {
				// Html page doesn't have header/footer
				// set header
				var s = self._staticControls.get("header");
				if (s && s.control && s.$$parent) {
					h = _sizes.header.h;
					contentHeight -= h;
					s.$$parent.css({
						top: 0 + "px",
						left: 0 + "px",
						width: contentWidth + "px",
						height: _sizes.header.h + "px"
					});
				}
				// set footer
				var s = self._staticControls.get("footer");
				if (s && s.control && s.$$parent) {
					contentHeight -= _sizes.footer.h;
					s.$$parent.css({
						top: (contentHeight + h) + "px",
						left: 0 + "px",
						width: contentWidth + "px",
						height: _sizes.footer.h + "px"
					});
				}
			}
			// Save content rectangle for scrolling and hub layout
			self._mainContentRect = uiRect.newRect(h, 0, contentHeight, contentWidth);
			// set content top and width - not height
			var top = h,
				left = 0;
			if (self._gestureMgr && self._gestureMgr.val != null) {
				// We need to take into account the scolling (context restored on back)
				if (self._gestureMgr.dir === "v") {
					top += self._gestureMgr.val;
				} else if (self._gestureMgr.dir === "h") {
					left += self._gestureMgr.val;
				}
			}
			self.$$contentElmt.css({
				top: top + "px",
				left: left + "px",
				width: contentWidth + "px"
			});
			self.onResize();
		},
		/**
		 * returns main content rect for hub layout
		 */
		getMainContentRect: function() {
			return this._mainContentRect;
		},
		/**
		 * Resize handler called by window.resize
		 */
		onResize: function() {
			var self = this;
			// Call resize handler in tree hierachy
			if (self.rootLayout && self.rootLayout.onResize) {
				self.rootLayout.onResize();
			}
		},
		/**
		 * Specific procces after rendering
		 */
		afterRender: function(options) {
			var self = this;
			// afterRender for controls - outside staticControls
			self.ctrlAfterRenderCalls.forEach(function(c) {
				c.afterRender();
			});
			if (self._staticControls && options.updateLayout !== true) {
				// for _staticControls afterRender is called only at the creation of the page
				self._staticControls.afterRender();
			}
		},
		isEditMode: function() {
			return false;
		},
		_beforeAddContent: function() {},
		addTitle: function(title, description) {
			var self = this;
			var html = "";
			if (title) html = '<header><h3>' + title + '</h3></header>';
			if (description) html += '<p>' + description + '<p>';
			if (html.length > 0) $(html).prependTo(self.$$contentElmt);
		},
		/**
		 *  called each tile a control/layout is created
		 *  isPageControl: 	true is it's a page/static control - Panel, Header, Footer...
		 **/
		addControl: function(c, isPageControl) {
			if (!c) return;
			// controlsMap contains all controls
			this.controlsMap[c.id] = c;
			// For controls others that static/page Controls
			if (isPageControl !== true) {
				// stores controls that need specific processes
				// !!! It's the simplest way to identify controls by testing the presence of the method when we add them
				// Another way woud be that it's the control that asks the page to be notified
				// After render
				if (c.afterRender) this.ctrlAfterRenderCalls.push(c);
				// Called after afterShow because scolling isinitialized in afterShow
				if (c.afterShow) this.ctrlAfterShowCalls.push(c);
				// Save context after afterShow
				if (c.savedCtxCreate && c.savedCtxRestore) this.ctrlSaveCtxCalls.push(c);
			} // StaticControls are managed separately because of updateMayout 
		},
		/**
		 * return the control/layout
		 * 	id:  id attribute of dom element
		 * */
		getControl: function(id) {
			return this.controlsMap && this.controlsMap[id];
		},
		/**
		 * Display the page and hides currentPage
		 * 		Manage transitions (effect) according  to self.getProp("transition")
		 *		Do not call show directly
		 * 		cb is called after oage hs been displayed (we don't use deferred)
		 * pageToClose is the page ths will be replaced by this
		 * 		For a child page currentPage is the parent page
		 *			Used by rowdetail page to read the DAO
		 * savedContext
		 * 		Context is propvided by pageToClose (or dashboard for vignettes)
		 * 		It contains a status to restore after it has been displayed (scroll...)
		 */
		activate: function(pageToClose, savedContext, cb) {
			var self = this;
			self._show(pageToClose, function() {
				// Called after afterShow because scolling isinitialized in afterShow
				if (savedContext) {
					// Set saved context use for back to 'parent' page
					self.savedContext = savedContext.parent;
					// We restore the current contex (ex scroll)
					self.savedCtxRestore(savedContext.current);
				} else if (self.lastSelectedRow) {
					// We allways restore last selected row because it is stored in page when we clik the link that opens the 'child' page
					self._hilightLastSelectedRow(self.lastSelectedRow);
				}
				// Controls that need to be called after show (calculate height/width..)
				self.ctrlAfterShowCalls.forEach(function(c) {
					c.afterShow();
				});
				if (cb) cb();
			});

		},
		/**
		 * Hide the page
		 * 	Do not call hide or show directly
		 * A "cached" page is deactivated instead of being destroyed on navigation event
		 */
		deactivate: function(cb) {
			this._hide(cb);
		},
		/**
		 * Save previous page context - Called by page loader before deactivating the page
		 * We propagate the context of previous pages into the page to be able to retrieve it on back navigation
		 */
		contextSave: function(pageToClose) {
			var self = this;
			if (!pageToClose) return;
			self.savedContext = {
				// Parent context is saved
				parent: pageToClose.savedContext,
				// Context to restore when this pageToClose will be reopen on back navigation
				current: pageToClose.savedCtxCreate()
			};
		},
		/**
		 * returns the context to save
		 * 		default:	page scroll coordinates
		 * Can be overridden (ex dashboard to manage contexts of vignettes)
		 */
		savedCtxCreate: function() {
			var self = this;
			var ctx = {
				pageName: this.state.name,
				lastSelectedRow: self.lastSelectedRow
			};
			if (self._gestureMgr) {
				// Save page scrolling
				ctx.scroll = self._gestureMgr.savedCtxCreate();
			}
			if (self.ctrlSaveCtxCalls.length > 0) {
				// Save controls contexts - All controls who implement savedCtxCreate are added to ctrlSaveCtxMap
				// We take index as control ID because index is not changed on page relaod  (id is changed eahc time we create a control)
				var idsArray = Object.keys(self.controlsMap);
				ctx.ctxCtrls = {};
				self.ctrlSaveCtxCalls.forEach(function(c) {
					var ctrlCtx = c.savedCtxCreate();
					if (ctrlCtx) ctx.ctxCtrls[idsArray.indexOf(c.id) + ""] = ctrlCtx;
				});
			}
			return ctx;
		},
		/**
		 * Restore page context - Called after activation (show)
		 * 		default:	page scroll coordinates
		 */
		savedCtxRestore: function(ctx) {
			var self = this;
			this._lastScrollCtx = null;
			if (!ctx) return;
			if (ctx.pageName != this.state.name) {
				// The page is not able to restore child pages inside a vignette - TODO if needed
				// If we go to detail page in ful page from a dashboard and go back a vignette that contains a detail page will not restore the context if current page was a child page
				// -> Only main parent page is restored
				return;
			}
			if (self._gestureMgr && ctx.scroll) {
				// Restore page scrolling
				self._gestureMgr.savedCtxRestore(ctx.scroll, true);
			}
			self._hilightLastSelectedRow(ctx.lastSelectedRow);
			if (ctx.ctxCtrls) {
				this._lastScrollCtx;
				// Restore controls context
				// We take index as control ID because index is not changed on page relaod  (id is changed eahc time we create a control)
				var idsArray = Object.keys(self.controlsMap);
				Object.keys(ctx.ctxCtrls).forEach(function(idx) {
					self.getControl(idsArray[idx]).savedCtxRestore(ctx.ctxCtrls[idx + ""]);
				});
			}
		},
		_hilightLastSelectedRow: function(lastSelectedRow, old) {
			var self = this;
			var toggle = function(rowInfo, show) {
				// We take index as control ID because index is not changed on page relaod  (id is changed eahc time we create a control)
				var id = Object.keys(self.controlsMap)[rowInfo.arrayKeyIdx];
				// Sometime control is lost when we want to restore a child pages inside a vignette after having opened a detail in full page
				//-> The page is not able to restore child pages inside a vignette - TODO if needed
				if (id && self.controlsMap[id]) self.controlsMap[id].selectLastSelectedRow(rowInfo.rowId, show);
			};
			if (old) toggle(old, false);
			if (lastSelectedRow) toggle(lastSelectedRow, true);
		},
		_show: function(currentPage, cb) {
			var self = this;
			var transition = self.getProp("transition");
			if (currentPage) {
				currentPage._hide(function() {
					self.$$elmt.show(transition || 0, function() {
						if (cb) cb();
					});
				});
				return;
			}
			self.$$elmt.show(transition == null ? 0 : transition, cb);
		},
		_hide: function(cb) {
			var self = this;
			if (!self.$$elmt) {
				if (cb) cb();
				// page has been destroyed
				return;
			}
			// Close panels
			self._actSidePanel("close", "all");
			var transition = self.getProp("transition");
			self.$$elmt.hide(transition == null ? 0 : transition, cb);
		},
		isActive: function() {
			var self = this;
			return self.$$elmt && self.$$elmt.is(":visible");
		},
		/**
		 * True is page is a lookup
		 */
		isLookup: function() {
			return this.prototype && this.prototype.isLookup();
		},
		/**
		 * Return the info to notify parent when the child page is closed
		 * It depends on the kind of page
		 * Ex: lookup notifies parent control with selected value
		 */
		getParentNotif: function() {
			throw new Error("not implemented");
		},
		/**
		 * Return the id of parent page if any
		 */
		getParentId: function() {
			return this.isChild ? this.state.options.parentId : null;
		},

		/**
		 * Returns attribute for the link that opens this page (used to open this page from a vignette to full page)
		 * Overriden by regular page to put s-data-url
		 */
		getOpenLinkAttrs: function() {
			return {
				"data-nav": this.state.name
			};
		},

		/***
		 * Test action
		 */
		_actTest: function(params) {
			var e = $('<h5 style="color:red">Action test succeeded</h5>').prependTo(this.$$elmt);
			window.setTimeout(function() {
				e.remove();
			}, 2000);
		},

		/**
		 * Toggle left/right panel - data-action="sidePanel"
		 * 	panel : left or right
		 * 	action toggle or resize
		 */
		_actSidePanel: function(action, side) {
			var self = this;
			if (self._staticControls) {
				side = side || "all";
				var side = side === "all" ? ["left", "right"] : [side];
				side.forEach(function(panel) {
					var c = self._staticControls.doSidePanelAction(self, panel, action);
				});
			}
		},

		/** Event sm.side.panel.ready
		 *  Notified when the panel have been created
		 *  Functional panel is identifyed by the typeControl
		 *  It is dispatched to a UI panel left/right (depends on OS)
		 */
		notifSidePanelReady: function(typeControl) {
			var self = this;
			if (!self.isActive()) return;
			if (!self._staticControls) return;
			var foot = self._staticControls.get("footer");
			if (!foot) return;
			foot.control.enablePanel(_control2panel[typeControl]);
		},

		/**
		 * Wait wheel management
		 * We need one plugin per page
		 */
		waitWheelStart: function(controlId) {
			var self = this;
			if (controlId) {
				var c = self.controlsMap[controlId];
				if (c && c.waitStart) c.waitStart();
				return;
			}
			if (!self._waiting) {
				self._waiting = uiutils.waitWheelCreate(self.$$elmt);
			}
			uiutils.waitWheelStart(self._waiting);
		},
		waitWheelStop: function(controlId) {
			var self = this;
			if (controlId) {
				var c = self.controlsMap[controlId];
				if (c && c.waitStop) c.waitStop();
				return;
			}
			if (self._waiting) {
				uiutils.waitWheelStop(self._waiting);
			}
		},

		/** Event sm.action.link
		 *  Notified asynchronously when a action succeeded - overriden
		 *  link:		Link info
		 *  result:		Json response
		 */
		notifActionLink: function(link, result) {
			throw new Error("not implemented");
		},
		/**
		 * Called synchronously by an array when a row has been selected
		 * 	arrayId		Id of array
		 * 	rowId		Id of row
		 * 	rowdata		data of the row used by loojup page
		 * 	updateUI	True to update UI
		 * 				When the page is not destroyed by the link we clicked we have to remove old selection
		 * 				Otherwise the selction the line will be hightlighted after creation of the page
		 */
		notifSelectRow: function(arrayId, rowId, rowdata, updateUI) {
			var old = this.lastSelectedRow;
			this.lastSelectedRow = {
				arrayKeyIdx: Object.keys(this.controlsMap).indexOf(arrayId),
				rowId: rowId
			};
			if (updateUI) {
				this._hilightLastSelectedRow(this.lastSelectedRow, old);
			}
		},
		/**
		 * USed by child pages
		 * TODO - Improve by using orr own history stack to avoid forward
		 */
		goBack: function() {
			window.history.back();
		},
		/**
		 * Enable/Disable scrolling
		 */
		enableScroll: function(enable) {
			if (!this._gestureMgr) return;
			if (!this.isNew) {
				// Cached page which has been activated
				this._gestureMgr.refresh();
				return;
			}
			if (this.scrollAllowed() && enable === true) {
				// Enable _gestureMgr
				var viewRect = this.getScrollViewRect();
				if (viewRect != null) {
					//viewRect has fixed coordinate to check if the 'finger' is inside on mousemouve event
					this._gestureMgr.init(viewRect, "v");
				}
			} else {
				// Disable _gestureMgr if any
				this._gestureMgr.reset();
			}
		},
		getScrollViewRect: function() {
			// Enable _gestureMgr
			var viewRect;
			if (this.isVignette) {
				// Scroll should be avoided - just for test vignette which need scroll
				viewRect = this.getParentVignette().getScrollViewRect();
				// To allow scrolling
				this.$$contentElmt.css({
					height: "auto"
				});
			} else {
				// Full page
				viewRect = this._mainContentRect;
			}
			var myRect = uiRect.elmtRect(this.$$contentElmt, "outer");
			return !viewRect.contains(myRect) ? viewRect : null;
		},
		getScrollElement: function() {
			return this.$$contentElmt;
		},
		/**
		 * True if scroll enabled in page
		 * By default we can scroll page in full display
		 * In vignette only details(/edit) facet ar allowed - See regular page
		 */
		scrollAllowed: function() {
			return this.isVignette !== true;
		},
		/**
		 * Returns the offset of the scrollRect top/left in foxed position (document)
		 */
		getScrollOffset: function() {
			if (this.isDashboard()) {
				// For readability t's better to put this code here than in dasborad class
				// return hub dashboard H or V shifting
				var g = this.rootLayout ? this.rootLayout.getGestureMgr() : {
					top: 0,
					left: 0
				};
				if (!g) return {
					top: 0,
					left: 0
				};
				var o = g.getOffset();
				o.top -= g.$$elmt.scrollTop();
				o.left -= g.$$elmt.scrollLeft();
				return o;
			} else {
				// No offset
				return {
					top: 0,
					left: 0
				};
			}
		},
		getParentVignette: function() {
			if (!this.isVignette) return null;
			if (this._parentVignette) return this._parentVignette;
			// We fail because vignette is expected
			this._parentVignette = utils.findParentVignette(this.$$elmt, false);
			return this._parentVignette;
		},
		getMainPageGestureMgr: function() {
			var p = globals.getCurrentPage();
			if (p.isDashboard()) {
				// It's the hub layout that scrolls - not  the page
				// For readability t's better to put this code here than in dasborad class
				return p.rootLayout ? p.rootLayout.getGestureMgr() : null;
			} else {
				return p._gestureMgr;
			}
		}
	}
);

exports.Page = _Page;