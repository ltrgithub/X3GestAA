"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("page");
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var _templates = {
	fullpage: '\
		<section class="s-m-page s-m-full" id="{{pageid}}" data-appid="{{appid}}" class="ctrl-event-click" style=""> \
			<header></header> \
			<section class="s-m-main-content"></section> \
			<footer></footer> \
			<div class="s-m-side-panel-dismiss" data-action="sidePanel" data-params="close"></div> \
		</section> \
	',
	// data-pageid used to retrieve the page
	vignette: '<section class= "s-m-page s-m-nested" data-pageid="{{pageid}}"></section>',
	leftpanel: '<section class="s-m-left-panel"></section>',
	rightpanel: '<section class="s-m-right-panel"></section>'
};

/**
 * Static controls used by non HTML pages
 */
var StaticControls = function() {
	var _map = {};
	this.addCtrl = function(panelId, selector, $$pageElmt, ctrlName) {
		var $$e = $$pageElmt.find(selector);
		if ($$e.length > 0) {
			_map[panelId] = {
				$$parent: $$e,
				ctrlName: ctrlName || panelId
			};
		}
	};
	this.destroy = function() {
		if (!_map) return;
		for (var id in _map) {
			if (_map[id].control) _map[id].control.destroy();
		}
		_map = null;
	};
	this.create = function(controller) {
		if (!_map) return;
		for (var id in _map) {
			_map[id].control = ctrlFactory.createPageControl(_map[id].ctrlName, controller);
		}
	};
	this.render = function(dao, buildOptions) {
		if (!_map) return;
		for (var id in _map) {
			_map[id].control.buildHtml(_map[id].$$parent, dao, buildOptions);
		}
	};
	this.afterRender = function(dao, buildOptions) {
		if (!_map) return;
		for (var id in _map) {
			_map[id].control.afterRender(_map[id].$$parent, dao, buildOptions);
		}
	};
	this.get = function(id) {
		return (_map[id] || {}).control;
	};
	this.doAction = function(page, side, action) {
		var id = side + "panel";
		var c = _map[id];
		if (!c) return;
		c.control.toggle(action, function(newWidth) {
			if (side === "left") {
				// Only for left panel shifts content
				var shift = [page.$$contentElmt];
				if (_map["header"]) shift.push(_map["header"].$$parent.find(".navbar"));
				if (_map["footer"]) shift.push(_map["footer"].$$parent.find(".navbar"));
				shift.forEach(function(e) {
					e.css("left", newWidth);
				});
			}
			// Dismiss 
			var visible = c.control.$$elmt.is(":visible");
			var dismiss = page.$$elmt.children(".s-m-side-panel-dismiss");
			dismiss[visible ? "addClass" : "removeClass"](side);
			dismiss.css(side, newWidth);
		});
		return c;
	};
};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};
// These link enable wait on control - TODO enable only if data not in cache for next, prev...
var _controlWheel = ["$more"]; //"$next", "$last", "$previous","$more","$first"];
/**
 * Base class for all pages
 *  $$parent: Parent element
 * 	state: Page information - JSON structure stored in history
 *  prototype: Prototype object (class prototype)
 *  article: JSON article
 *  !! Temporarily prototype and article can be null for html pages
 */
var _Page = utils.defineClass(
	function($$parent, state, prototype, article) {
		var self = this;
		// article, prototype, rootLayout null for html pages
		self.prototype = prototype;
		self.article = article;
		self.rootLayout = null;
		self._staticControls = null;
		self.vignette = state.options && state.options.vignette;
		// For breadCrumb
		self.historyLength = 0;
		self.historyTitle = state.id;
		self._$$parent = $$parent;
		self.state = state;
		self.id = state.uuid;
		self.controlsMap = {};
		self._nbControls = 0;
		self.dao = null;
		self._initRootElmt($$parent);
		if (!self.vignette) {
			notifications.subscribe(self, ["sm.side.panel.ready"], 1);
		}
	}, null, {

		/**
		 * Create and return root DOM element of every page
		 * 		DOM element is hidden and contains only the structure
		 * 		Page object is stored in DOM element under data("smcontroller")
		 */
		_initRootElmt: function($$parent) {
			var self = this;
			var root, ctx = {
					appid: self.state.appId,
					pageid: self.id
				};
			if (self.isVignette()) {
				// only content in a vignette
				self.$$contentElmt = self.$$elmt = $(_getHtml("vignette", ctx));
			} else {
				self.$$elmt = $(_getHtml("fullpage", ctx));
				self.$$contentElmt = self.$$elmt.find("section.s-m-main-content");
				if (["dashboard", "regular"].indexOf(self.state.type) >= 0) {
					// Static controls for non html pages
					// Add specific panels here - Adding a parent class for dashboard and regular is not needed
					// Add left panel for dashboard and regular only
					$(_getHtml("leftpanel")).appendTo(self.$$elmt);
					$(_getHtml("rightpanel")).appendTo(self.$$elmt);
					self._staticControls = new StaticControls(self);
					// TODO - create according page configuration
					self._staticControls.addCtrl('header', 'header', self.$$elmt);
					self._staticControls.addCtrl('footer', 'footer', self.$$elmt);
					self._staticControls.addCtrl('rightpanel', 'section.s-m-right-panel', self.$$elmt);
					self._staticControls.addCtrl('leftpanel', 'section.s-m-left-panel', self.$$elmt, "navigationpanel");
					self._staticControls.addCtrl('rightpanel', 'section.s-m-right-panel', self.$$elmt, "actionpanel");
				}
			}
			self.$$elmt.hide();
			self.$$elmt.appendTo($$parent);
			// attaches page object to DOM element
			self.$$elmt.smPageController(self);
		},

		destroy: function() {
			var self = this;
			if (self._waiting) {
				uiutils.waitWheelDestroy(self._waiting);
				self._waiting = null;
			}
			log && log("Page destroy", self.id);
			if (self.getProp["type"] === "appdashboard") {
				// app dashboard page -> Destroy all related pages
				self._destroyAppChilds();
			}
			if (self._staticControls) {
				self._staticControls.destroy();
				self._staticControls = null;
			}
			if (self.controlsMap) {
				for (var id in self.controlsMap) {
					self.controlsMap[id].destroy();
				}
				self.controlsMap = null;
			}
			self._nbControls = 0;
			if (self.dao) {
				self.dao.destroy();
				self.dao = null;
			}
			// At the end to destroy childs before parent
			if (self.$$elmt) {
				utils.unbindObj(self.$$elmt);
				self.$$elmt = null;
			}
			utils.unbindObj(self);
			self.article = null;
			self.prototype = null;
			self._$$parent = null;
		},

		/**
		 * TODO
		 */
		_destroyAppChilds: function() {
			var self = this;
			if (self.$$elmt) {
				// destroy all page that belongs to an application except this (dashboard)
				var childs = self._$$parent.find('.class[data-appId="' + self.getProp("appId") + '"]');
				if (childs.length > 0) {
					log && log("Page destroychilds", self.id);
					childs.each(function(idx) {
						var ctrl = $(this).smPageController();
						if (ctrl && ctrl != self) ctrl.destroy();
					});
				}
			}
		},
		/**
		 * TODO
		 */
		destroySiblings: function() {
			var self = this;
			if (self.$$elmt) {
				// destroy all siblings if any when direct access with the breadcrumb
				log && log("Page destroySiblings", "destroySiblings");
				var next = self.$$elmt.siblings(function(idx) {
					var ctrl = $(this).smPageController();
					if (ctrl) ctrl.destroy();
				});
			}
		},
		/**
		 * dashboard/regular/html
		 */
		getType: function() {
			return this.state.type;
		},

		getProp: function(prop) {
			return this.state[prop];
		},

		setDao: function(dao) {
			var self = this;
			if (self.dao && self.dao.destroy) self.dao.destroy();
			self.dao = dao;
		},

		getDao: function() {
			return this.dao;
		},

		/**
		 * Refresh the page
		 * 	options.sdata-url -> New url
		 * 	options.controlId!=null -> refresh the control
		 *  options.type Type of refresh (pagination...)
		 *  callBackInterface
		 *  	waitStop(ctrlId) / waitStart(ctrlId)
		 */
		refresh: function(options, callBackInterface) {
			var self = this;
			var deferred = $.Deferred();
			var url = options["sdata-url"];
			var controlId = options["controlId"];
			var _wait = function(status) {
				// I added the capability to enable the wait on the control
				// True if the type of refresh needs the display of wheel on control ($more)
				var ctrlWheel = controlId ? _controlWheel.indexOf(options.type) >= 0 : false;
				if (callBackInterface) {
					// Caller wheel - Ex: vignette
					var m = "wait" + status.smCapitalize();
					if (callBackInterface[m]) callBackInterface[m](ctrlWheel ? controlId : null);
					return;
				}
				// Page wheel or control wheel if ctrlId && pagination
				// TODO use the same name waitStart/waitStop for all objects
				self["waitWheel" + status.smCapitalize()].call(self, ctrlWheel ? controlId : null);
			};
			try {
				var _succeeded = function() {
					_wait("stop");
					self.refreshControls(controlId ? [controlId] : null, options);
					deferred.resolve();
				};
				if (!url) {
					_succeeded();
				} else {
					_wait("start");
					self.state.options["sdata-url"] = url;
					self.loadData()
						.then(function() {
							_succeeded();
						}, function(e) {
							_wait("stop");
							deferred.reject(e);
						});
				}
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 * ids == null means all controls
		 */
		refreshControls: function(ids, options) {
			var self = this;
			var array;
			if (ids && ids.length > 0) {
				array = [];
				ids.forEach(function(id) {
					array.push(self.controlsMap[id]);
				});
			} else {
				array = self.controlsMap;
			}
			array.forEach(function(c) {
				c.refresh(self.dao, options);
			});
		},
		/**
		 * Load the page
		 * 		The result is that the page is created and attached to DOM document and hidden
		 * 		the contoller of the page (applictaion/vignette) has to call activate method to display the page (see pageLoader module)
		 */
		load: function() {
			var self = this;
			var deferred = $.Deferred();
			try {
				self.loadStructure()
					.then(function() {
						try {
							return self.loadData();
						} catch (e) {
							return $.smReject(e);
						}
					})
					.then(function() {
						try {
							return self.render();
						} catch (e) {
							return $.smReject(e);
						}
					})
					.then(function() {
						try {
							return self.afterRender();
						} catch (e) {
							return $.smReject(e);
						}
					})
					.then(function() {
						deferred.resolve();
					}, function(e) {
						deferred.reject(e);
					});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},
		/**
		 * Create layout/control tree structure according to article
		 */
		loadStructure: function() {
			var deferred = $.Deferred();
			var self = this;
			try {
				if (!self.article || !self.prototype) throw new Error("loadStructure - NULL article or prototype");
				// Creates header/footer/leftPanel/rightpanel controls
				if (self._staticControls) {
					self._staticControls.create(self);
				}
				// Creates control/fields tree (from article)
				self.rootLayout = articleParser.article2Controls(self, self.article, self.prototype);
				deferred.resolve();
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},
		/**
		 * Load page data
		 */
		loadData: function() {
			var deferred = $.Deferred();
			var self = this;
			try {
				self.setDao(null);
				deferred.resolve();
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},
		/**
		 * Rendering - Build html and attachs dom elements to document
		 */
		render: function() {
			var self = this;
			try {
				if (!self.rootLayout) throw new Error("buildHtml - NULL rootLayout");
				// Renders header/footer/leftPanel/right controls
				if (self._staticControls) {
					self._staticControls.render(self.dao);
				}
				if (self.$$contentElmt) {
					self._beforeAddContent();
					// Renders tree controls (article)
					self.rootLayout.buildHtml(self.$$contentElmt, self.dao, null);
				}
			} catch (e) {
				return $.smReject(e);
			}
			return $.smResolve();
		},
		/**
		 * Specific procces after rendering
		 */
		afterRender: function() {
			var self = this;
			// AfterRenders header/footer/leftPanel/right controls
			// Calles ater all static controls have been rendered
			if (self._staticControls) {
				self._staticControls.afterRender();
			}
			if (self.isVignette() && self.getNbControls() === 1) {
				// Needed for charts dashboard to display chart in full vignette
				// Stacked layouts with one control are full height in vignettes
				// Make cell 100% height - TODO temporarilly
				self.rootLayout.$$elmt.height("100%");
			}
		},

		isEditMode: function() {
			return false;
		},

		_beforeAddContent: function() {

		},

		addTitle: function(title, description) {
			var self = this;
			var html = "";
			if (title) html = '<header><h3>' + title + '</h3></header>';
			if (description) html += '<p>' + description + '<p>';
			if (html.length > 0) $(html).prependTo(self.$$contentElmt);
		},


		/**
		 *  called each tile a control/layout is created
		 **/
		addControl: function(c) {
			if (!c) return;
			this._nbControls++;
			this.controlsMap[c.id] = c;
		},
		/**
		 * return the control/layout
		 * 	id:  id attribute of dom element
		 * */
		getControl: function(id) {
			return this.controlsMap && this.controlsMap[id];
		},

		getNbControls: function(id) {
			return this._nbControls;
		},
		/**
		 * Display the page and hides currentPage
		 * 		Manage transitions (effect) according  to self.getProp("transition")
		 * Do not call show directly
		 * cb is called after oage hs been displayed (we don't use deferred)
		 */
		activate: function(currentPage, cb) {
			var self = this;
			log && log("Page activate", self.id);
			self.historyLength = window.history.length;
			self._show(currentPage, cb);
		},
		/**
		 * Hide the page
		 * 	Do not call hide or show directly
		 * A "cached" page is deactivated instead of being destroyed on navigation event
		 */
		deactivate: function(cb) {
			var self = this;
			log && log("Page deactivate", self.id);
			self._hide(cb);
		},

		_show: function(currentPage, cb) {
			var self = this;
			var transition = self.getProp("transition");
			if (currentPage) {
				currentPage._hide(function() {
					self.$$elmt.show(transition || 0, function() {
						if (cb) cb();
					});
				});
				return;
			}
			self.$$elmt.show(transition == null ? 0 : transition, cb);
		},

		_hide: function(cb) {
			var self = this;
			if (!self.$$elmt) {
				if (cb) cb();
				// page has been destroyed
				return;
			}
			// Close panels
			self._actSidePanel("close", "all");
			var transition = self.getProp("transition");
			self.$$elmt.hide(transition == null ? 0 : transition, cb);
		},

		isActive: function() {
			var self = this;
			return self.$$elmt && self.$$elmt.is(":visible");
		},

		/**
		 * True is page is nested in a vignette
		 */
		isVignette: function() {
			var self = this;
			return self.vignette === true;
		},
		/**
		 * Returns attribute for the link that opens this page (used to open this page from a vignette to full page)
		 * Overriden by regular page to put s-data-url
		 */
		getOpenLinkAttrs: function() {
			return {
				"data-nav": this.state.name
			};
		},

		/***
		 * Test action
		 */
		_actTest: function(params) {
			var e = $('<h5 style="color:red">Action test succeeded</h5>').prependTo(this.$$elmt);
			window.setTimeout(function() {
				e.remove();
			}, 2000);
		},

		/**
		 * Toggle left/right panel - data-action="sidePanel"
		 * 	panel : left or right
		 * 	action toggle or resize
		 */
		_actSidePanel: function(action, side) {
			var self = this;
			if (self._staticControls) {
				side = side || "all";
				var side = side === "all" ? ["left", "right"] : [side];
				side.forEach(function(panel) {
					var c = self._staticControls.doAction(self, panel, action);
				});
			}
		},

		_actSwitchApp: function(info) {
			var self = this;
			if (!info) return;
			settings.getMyApplicationDetail(info).then(function(data) {
				notifications.publish("sm.switch.app", data);
			}, function(e) {
				utils.modalError("Error switching to application", e);
			});
		},

		// Event sm.panel.enabled
		notifSidePanelReady: function(data) {
			var self = this;
			var foot = self._staticControls ? self._staticControls.get("footer") : null;
			if (!foot) return;
			if (data === "navigation") {
				data = "left";
			} else if (data === "actions") {
				data = "right";
			}
			foot.enablePanel(data);
		},

		/**
		 * Wait wheel management
		 * We need one plugin per page
		 */
		waitWheelStart: function(controlId) {
			var self = this;
			if (controlId) {
				var c = self.controlsMap[controlId];
				if (c && c.waitStart) c.waitStart();
				return;
			}
			if (!self._waiting) {
				self._waiting = uiutils.waitWheelCreate(self.$$elmt);
			}
			uiutils.waitWheelStart(self._waiting);
		},
		waitWheelStop: function(controlId) {
			var self = this;
			if (controlId) {
				var c = self.controlsMap[controlId];
				if (c && c.waitStop) c.waitStop();
				return;
			}
			if (self._waiting) {
				uiutils.waitWheelStop(self._waiting);
			}
		}
	}
);

exports.Page = _Page;