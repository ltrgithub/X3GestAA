"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Controller = require("syracuse-tablet/html/js/controllers/controller").Controller;
var AttachedControlsMgr = require('syracuse-tablet/html/js/pages/attachedControlsMgr').AttachedControlsMgr;
var settings = require('syracuse-tablet/html/js/app/settings');
var siteLayout = require('syracuse-tablet/html/js/ui/siteLayout');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var modules = require('syracuse-tablet/html/js/common/modules');

var _id = 1;
var _templates = {};
var _html = {
	fullpage: '\
		<section class="s-m-page s-m-full {{device}}" id="{{pageId}}" style="display: none" data-page-name="{{pageName}}"> \
			<header></header> \
			<section class="s-m-topToolbar"  style="display:none"></section> \
			<section class="s-m-main-content" data-s-m-content=""></section> \
			<footer style="display:none"></footer> \
		</section> \
	',
	vignette: '<section class= "s-m-page s-m-nested" id="{{pageId}}" style="display: none;" data-page-name="{{pageName}}"></section>',
	panelContainers: '\
		<div class="s-m-side-panel-dismiss" data-nevent data-naction="closePanel"></div> \
		<aside class="s-m-panel s-m-left"></aside> \
		<aside class="s-m-panel s-m-freeleft"></aside> \
		<aside class="s-m-panel s-m-freeright"></aside> \
		<aside class="s-m-panel s-m-right"></aside>'

}
var _getHtml = function(name, ctx) {
	var tmpl = _templates[name];
	if (!tmpl) {
		tmpl = _templates[name] = Handlebars.compile(_html[name]);
	}
	return tmpl(ctx || {});
};

var _pages = {};

/**
 * options:
 * {
 *   isChild: true|false
 *   isVignette: true|false
 * }
 */
exports.Page = utils.defineClass(
	function PageBase(pageName, options) {
		options = options || {};
		options.nativeCapabilities = options.nativeCapabilities || {}
		this.pageName = pageName || "noname";
		this.id = String(_id++);
		_pages[this.id] = this;
		this.options = options || {};
		// set from outside, in here we want to load the page
		this.$$container = null;
		// root element of the page
		this.$$elmt = null;
		// element where the main page content is rendered to
		this.$$contentElmt = null;
		this.controller = null;
		// When a page is loaded inside a vignette, parentPage will point to the dashboard containing the vignette
		this.parentPage = null;
		// Vignette that embeds the page if any
		this.parentVignette = null;
		this.parentPage = null;
		if (options.isVignette) {
			this.parentVignette = options.parentVignette;
			this.parentPage = options.parentPage;
		}
		this.attachedControlsMgr = new AttachedControlsMgr(this);
		// Let page subclasses define their own controller if needed
		this._ensureController();
	},
	null, {
		/** 
		 * Override to create a specialized controller
		 */
		_ensureController: function() {
			this.controller = new Controller(null);
		},
		destroy: function() {
			this.destroyed = true;
			this.unbuild();
			delete _pages[this.id];
			this.parentVignette = null;
			this.parentPage = null;
			if (this.controller) {
				this.controller.destroy();
				this.controller = null;
			}
			if (this.attachedControlsMgr) {
				this.attachedControlsMgr.destroy();
				this.attachedControlsMgr = null;
			}
			notifications.unsubscribe(this);
		},
		/**
		 * Release resources that will be re-allocated on build
		 */
		unbuild: function() {
			if (this.attachedControlsMgr) {
				this.attachedControlsMgr.destroyControls();
			}

			if (this.$$elmt) {
				this.$$elmt.unbind();
				this.$$elmt.remove();
			}

			this.$$elmt = null;
			this.$$contentElmt = null; // Element in DOM which contains all content and eventually a scroller
			this.$$contentRoot = null; // Put content in here: Element in DOM that is eventually scrollable, could be the same as $$contentElmt if no scrolling is desired
			this.$$scrollWrapper = null; // Don't forget this otherwise scrolling is frozen
		},
		// Return true whenever pushing this page onto the page stack
		// should clear the history and make this page the only one 
		// existing the the history (e.g. login, logout, home)
		isRootPage: function() {
			return false;
		},
		// For pages that must not be added to the history.
		// e.g. Login, logout
		isNoHistory: function() {
			return false;
		},
		set$$container: function($$container) {
			this.$$container = $$container;
		},

		/**
		 * Should be called by all subclasses
		 */
		createRootElement: function() {
			var tplName = "fullpage";
			if (this.isVignette()) {
				tplName = "vignette";
			}

			var ctx = {
				pageId: this.id,
				pageName: this.pageName,
				device: siteLayout.getDeviceType(),
			};
			this.$$elmt = $(_getHtml(tplName, ctx));
			this.$$contentElmt = this.$$elmt.find('[data-s-m-content]'); // Is there a children flagged to be the content holding element
			if (this.$$contentElmt.length === 0) {
				this.$$contentElmt = this.$$elmt; // Use root element for page content if no other element is flagged to be used
			}
			this.$$contentRoot = this.$$contentElmt;

			if (!this.isVignette()) {
				this.$$elmt.append($(_getHtml("panelContainers")));
			}
			this.$$container.append(this.$$elmt);
		},

		hide: function() {
			if (!this.$$elmt) {
				return;
			}
			this.$$elmt.hide();
		},
		/**
		 * noCompute: 	true 	to not compute the layout
		 * 						Eg: 	when we show a 'cached' page we just display it with recomputing
		 * 								if it's a vignette page we also do'nt compute the page (done once all the pages have been loaded)
		 * 				false 	(default) we compute the layout
		 * 						We need to compute the layout once the control are visible because we need height/width (scrolling, cards, layouts stack/ub...)
		 * 						
		 */
		show: function(noCompute) {
			if (!this.$$elmt) {
				return $.smResolve();
			}
			this.$$elmt.show();
			var self = this;
			return $.smResolve().then(function() {
				/**
				 * Compute the layout once that page is visible
				 * It's mandatory to calculate fixed width 
				 * For a vignette computeLayout is called by the dashboard once all the vignettes have been loaded
				 */
				if (noCompute !== true && !self.isVignette()) {
					self.computeLayout();
				}
				/**
				 * Else nothing has to be restored
				 * Perhaps if we change the size of the child page we should recalculate the layout of the parent on back (not usual)
				 */
			})
		},

		/**
		 * computeLayout is called when the page is shown (show method)
		 */
		build: function() {
			var self = this;

			return $.smResolve()
				.then(function() {
					return self.createRootElement();
				})
				.then(function() {
					return self.initStructure && self.initStructure();
				})
				.then(function() {
					self._initScrolling();
					return self.render && self.render();
				})
				.then(function() {
					return self.afterRender && self.afterRender();
				})
				.then(function() {
					self.onPageDataChanged();
				})
				.then(function() {
					notifications.publish(["sm.page.loaded"], self);
				});
		},

		initStructure: function() {
			this.createAttachedControls();
		},
		/**
		 * context: 
		 */
		computeLayout: function(context) {
			this.$$elmt.removeClass("landscape portrait");
			this.$$elmt.addClass(siteLayout.getPageOrientation());
			var layoutInfo = siteLayout.getLayoutInfo();
			if (!this.isVignette()) {
				var mainLayout = this.attachedControlsMgr.computeMainLayout(layoutInfo);
				this.$$contentElmt.css({
					top: mainLayout.contentTop + "px",
					left: mainLayout.contentLeft + "px",
					width: mainLayout.contentWidth + "px",
					height: mainLayout.contentHeight + "px"
				});
			} else {
				/**
				 * For vignette we don't calculate the H/W in pixels.
				 * To do the calculatation we need to propagate the calculation from dashboard tile -> Control (not done and needed)
				 * H/W calculation is based on css style height auto for the wrapper et 100% for $$contentElmt
				 */
			}
			this.mainContentRect = uiRect.elmtRect(this.$$contentElmt, "outer");
			this.mainContentNoPaddingRect = uiRect.elmtRect(this.$$contentElmt, "computed");
			layoutInfo.pageContentRect = this.mainContentRect;
			layoutInfo.pageContentNoPaddingRect = this.mainContentNoPaddingRect;
			// Compute controls layout
			this.computeControlsLayouts($.extend(true, context, layoutInfo));
			// Update scrolling at the end
			this._updateScrolling();
			// Restore context on first compute
			if (this.options.savedCtx) {
				this.savedCtxRestore(this.options.savedCtx);
				delete this.options.savedCtx;
			}
		},

		/**
		 * Can be overridden - sDataPage compute from rootLayout
		 */
		computeControlsLayouts: function(context) {
			// Compute layouts for attached controls
			if (this.attachedControlsMgr) {
				this.attachedControlsMgr.computeLayout(context);
			}
		},

		//
		// START: Scrolling stuff
		//


		/**
		 * True if scroll enabled in page
		 * By default we can scroll a page in full display
		 * In vignettes only details/edit facet are allowed to scroll - See regular page
		 * In Dashboard hub this is the layout that scrolls - Page doesn't scroll
		 */
		scrollAllowed: function() {
			return !this.isVignette() && !this.isDashboard("hub");
		},

		/**
		 * Override for pages that do not want scrolling
		 */
		_initScrolling: function(preserveScroll) {
			if (!this.scrollAllowed() || this.$$scrollWrapper) {
				return;
			}
			this.$$scrollWrapper = $('<div class="s-m-scroll-wrapper"/>').appendTo(this.$$contentRoot);
			this.$$scrollWrapper.css({
				height: "auto"
			});
			this.$$contentRoot = this.$$scrollWrapper;
			this._gestureMgr = scroller.newScroller(this.$$scrollWrapper, {
				isPageScroller: true // !self.isVignette
			});
		},
		_updateScrolling: function(preserveScroll) {
			if (!this._gestureMgr || !this.$$elmt.is(":visible")) {
				return;
			}
			if (!this.scrollAllowed()) {
				this._gestureMgr.reset();
				return;
			}
			var viewRect = this.isVignette() ? this.parentVignette.getScrollViewRect() : this.mainContentRect;
			if (!viewRect || viewRect.height >= this.$$scrollWrapper.height()) {
				this._gestureMgr.reset();
				return;
			}
			var valMax = 0;
			// If not new -> back on a cached page - We keep scrolling
			preserveScroll = preserveScroll === true;
			// viewRect has fixed coordinate to check if the 'finger' is inside on mousemouve event
			// A page always scolls vertically - In dashboard this is the layout that scrolls horizontally
			this._gestureMgr.init(viewRect, "v", valMax, preserveScroll);
			var autoScroll = this.options["auto-scroll"];
			if (autoScroll != null) {
				// When we go to $edit form $details we keep the scrolling in order to stay at the same location (see actionManager)
				this.autoScroll(autoScroll);
				// Only when we loadd the page
				this.options["auto-scroll"] = undefined;
			}
			var viewRect = this.isVignette() ? this.parentVignette.getScrollViewRect() : this.mainContentRect;
			if (!viewRect || viewRect.height >= this.$$scrollWrapper.height()) {
				this._gestureMgr.reset();
			}
		},

		/**
		 * Called by controls that have an impact on the page size after loading
		 * Currently, this are only vignettes
		 */
		onContentChanged: function() {
			this._updateScrolling();
		},

		//
		// END: Scrolling stuff
		//

		getPageTitle: function() {
			return "";
		},

		createAttachedControls: function() {
			var self = this;
			var names = self._getDefaultAttachedControls();
			names.forEach(function(name) {
				var info = self._getAttachedControlInfo(name);
				if (info) {
					self.attachedControlsMgr.createControl(info);
				}
			});
		},

		/**
		 * Get logical name of controls that are usually attached to a page
		 * 
		 * Can be overriden per page if necessarry
		 * @returns
		 */
		_getDefaultAttachedControls: function() {
			if (this.isVignette()) {
				return [];
			}
			return ["header"];
		},

		/**
		 * Get detail information on how to create a logical control
		 * E.g. device dependent header
		 * 
		 * Can be overriden per page if necessarry
		 * 
		 * @param name
		 * @returns
		 */
		_getAttachedControlInfo: function(name) {
			var defaults = {
				header: {
					topIndex: 0,
					selector: "header",
					$type: "application/x-panel-header-sdata-page"
				},
				breadcrumbs: {
					topIndex: 1,
					selector: "aside.s-m-panel.s-m-freeleft",
					$type: "application/x-panel-breadcrumbs"
				},
				actionsPanel: {
					selector: "aside.s-m-panel.s-m-freeright",
					$type: "application/x-panel-actions"
				},
				globalPanel: {
					selector: "aside.s-m-panel.s-m-left",
					$type: "application/x-panel-global"
				},
				filterSortPanel: {
					selector: "aside.s-m-panel.s-m-right",
					vignetteSelectorUseParent: true,
					$type: "application/x-panel-filtersort"
				},
				chartDetailToolBar: {
					topIndex: 2,
					selector: ".s-m-topToolbar",
					$type: "application/x-chartdetail-toolbar"
				},
				sharePanel: {
					selector: "aside.s-m-panel.s-m-right",
					vignetteSelectorUseParent: true,
					$type: "application/x-panel-share"
				},
				dashboardTemplatePanel: {
					selector: "aside.s-m-panel.s-m-right",
					$type: "application/x-panel-dashboard-template"
				},
				editTemplatesPanel: {
					selector: "aside.s-m-panel.s-m-right",
					$type: "application/x-panel-edittemplates"
				}
			};
			var info = defaults[name];
			info.name = name;
			return info;
		},
		getPanel: function(name) {
			return this.attachedControlsMgr.findByName(name);
		},
		/**
		 * It doesn't show the panel
		 */
		openPanel: function(name, options) {
			var panel = this.getPanel(name);
			if (!panel) {
				var info = this._getAttachedControlInfo(name);
				if (info) {
					panel = this.attachedControlsMgr.createControl(info, options);
				}
			}
			if (!panel) {
				return;
			}
			return panel
		},
		_actOpenActionsPanel: function() {
			var actionsPanel = this.getPanel("actionsPanel");
			if (!actionsPanel) {
				var info = this._getAttachedControlInfo("actionsPanel");
				if (info) {
					actionsPanel = this.attachedControlsMgr.createControl(info);
				}
			}
			if (!actionsPanel) {
				return;
			}
			actionsPanel.show();
		},
		_actOpenGlobalPanel: function() {
			var panel = this.openPanel("globalPanel");
			if (panel) panel.show();
		},
		_actPageShare: function() {
			var panel = this.openPanel("sharePanel");
			panel.show();
		},
		/**
		 * Should do:
		 * - Destroy and re-create page specific controls like header/footer depending on the page size/device
		 *   (also this is mostly a development use case)
		 * - Close opened panels and popups 
		 */
		onMainPageResize: function(info, orientation, deviceType) {
			var actionsPanel = this.getPanel("actionsPanel");
			if (actionsPanel) actionsPanel.hide();
			if (info.deviceChanged == true && this.attachedControlsMgr) {
				// Rebuild header/footer.. according to deviceType
				this.attachedControlsMgr.destroyControls();
				this.createAttachedControls();
				this.attachedControlsMgr.buildHtml();

			}
			this.computeLayout(info);
		},
		/**
		 * Called by navigator whenever the page will be closed because of a back action
		 * The back action will be done as soon as onBackAction will resolve with "true"
		 * returns a promise
		 */
		onBackAction: function() {
			return $.smResolve(true);
		},
		/**
		 * Called when the data on a page has changed.
		 * First time called after page has rendered and the e.g. on paging
		 */
		onPageDataChanged: function() {},

		//
		// START: Authoring
		//
		allowAuthoring: function() {
			return false;
		},
		getAuthoringName: function() {

		},
		getAuthoringFullName: function() {

		},
		getPageName: function() {
			return this.pageName;
		},
		isVignette: function() {
			return this.options.isVignette === true;
		},
		isHome: function() {
			return this.pageName === "HOME";
		},
		authUpdateLayout: function() {
			var self = this;
			self.unbuild();
			return self.build()
				.then(function() {
					return self.show();
				});
		},
		//
		// END: Authoring
		//

		/**
		 * typeDashboard = hub / stack / undefined
		 */
		isDashboard: function(typeDashboard) {
			return false;
		},
		isChartDetail: function(typeDashboard) {
			return false;
		},
		isCardDetail: function() {
			return false;
		},
		isNestedInDashboard: function(typeDashboard) {
			return this.isVignette() && this.parentPage && this.parentPage.isDashboard(typeDashboard);
		},

		/**
		 * pageName: null, SdataRowDetail, SdataChartDetail
		 * 
		 */
		isChild: function(pageName) {
			if (pageName == null) {
				return this.options.isChild === true;
			}
			return this.options.isChild === true && this.options.childPageName === pageName;
		},
		/**
		 * Overridden by dashboard
		 */
		getGestureMgr: function() {
			return this._gestureMgr;
		},

		/**
		 * Show element in page - scroll if needed
		 * c is a JQuery elmt or an object with $$elmt property
		 * smoothOffset optional (see scroller)
		 */
		makeVisible: function($$elmt, smoothOffset) {
			if ($$elmt && this._gestureMgr) {
				this._gestureMgr.makeVisible($$elmt, smoothOffset);
			}
		},
		/**
		 * Update the scroller - needed for staked layouts
		 * In stacked/row layout the height of the page is given by the height of the content of the vignette
		 * Used by charts and vignettes
		 * force= true to force recalculation if caller nows that scolling area changed
		 */
		notifyScrollerUpdate: function(force) {
			// _gestureMgr != null for stack (not hub structure)
			if (!this._gestureMgr || !this.$$elmt.is(":visible")) {
				return;
			}
			// Init scroll because hight has changed - True to preserve scroll for authoring
			this._updateScrolling(true);
			this._gestureMgr.adjust();
		},
		isFacet: function() {
			return false;
		},
		/**
		 * opts : 	noScroll	True to not restore the scolling and last Selectedrow
		 */
		savedCtxCreate: function(opts) {
			if (this.destroyed) {
				return;
			}
			var ctx = {
				pageName: this.pageName,
				ctxCtrls: this.controller.savedCtxCreate(opts)
			};
			if (this._gestureMgr) {
				// Save page scrolling if is not a link (by email, pinned page...)
				ctx.scroll = this._gestureMgr.savedCtxCreate(opts);
			}
			return ctx;
		},
		/**
		 * If we want to get the savedCtx of a control before savedCtxRestore
		 */
		savedCtxCtrlRead: function(ctrl) {
			if (this.destroyed) {
				return;
			}
			var ctx;
			if (this.options.savedCtx && this.options.savedCtx.ctxCtrls) {
				var idx = this.controller.savedCtxIndexOf(ctrl);
				ctx = idx >= 0 ? this.options.savedCtx.ctxCtrls[idx] : null;
			}
			return ctx;
		},
		savedCtxRestore: function(ctx) {
			if (this.destroyed) {
				return;
			}
			ctx = ctx || this.options.savedCtx;
			if (!ctx) return;
			if (this.pageName != ctx.pageName) {
				return;
			}
			if (this._gestureMgr && ctx.scroll != null) {
				// Restore page scrolling
				this._gestureMgr.savedCtxRestore(ctx.scroll, true);
			}
			if (ctx.ctxCtrls) {
				this.controller.savedCtxRestore(ctx.ctxCtrls);
			}
		},
		/**
		 * Used to store settings (filters/search...)
		 */
		getPagePrefsId: function() {
			return settings.getPagePrefsId(this.pageName, this.parentVignette)
		},
		getPinActionState: function() {

		},
		isSData: function() {
			return false;
		}
	});

exports.findPage = function(id) {
	return _pages[id];
}