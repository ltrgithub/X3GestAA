"use strict";

/*
 * IndexDB storage interface (Internet Explorer, Firefox)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var Base = storageInterface.Klass;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("indexedDB", true);

// Increase this number to upgrade database to schema described in objectStores
var _databaseVersion = 25;
var _indexedDB = window.indexedDB || window.webkitIndexedDB;

var _logError = function(title, status) {
	log && log(title + " ERROR");
	if (!status) return;
	var request = status.target || status.currentTarget || status.originalTarget;
	if (request && request.error && request.error.message) {
		log && log((request.error.name ? "[" + request.error.name + "]" : "") + request.error.message);
		return;
	}
	log && log(storageInterface.resultToString(status));
};

exports.Klass = utils.defineClass(
	function() {
		Base.call(this, "IndexedDB storage interface", _databaseVersion);
	},
	Base, {

		init: function(requester) {
			var self = this;
			requester = requester || "";
			log && log("_INIT " + requester);
			var deferred = $.Deferred();
			var step = jsutils.isTestEnvironment() ? self._initTestDB() : $.smResolve();
			step.then(function() {
				if (self.db) {
					log && log("DATABASE ALREADY INITIALIZED!");
					return (storageInterface.buildResult(storageInterface.StatusCodes.OK));
				}
				log && log("DATABASE INIT!");
				return self._openDB();
			}).then(function(status) {
				log && log("_openDB OK " + requester);
				deferred.resolve(status);
			}).fail(function(e) {
				_logError("_openDB KO " + requester);
				var msg = locale.text("db.err.init");
				var err = self._eventToMessage(e);
				if (err && err.toLowerCase().indexOf("versionerrror") >= 0) {
					msg += "\n" + locale.text("db.err.version");
				}
				deferred.reject(self._eventToDiagnose(msg, e));
			});
			return deferred.promise();
		},

		_initTestDB: function(requester) {
			var self = this;
			var deferred = $.Deferred();
			$.smResolve().then(function() {
				if (self.db) {
					self.db.close();
					self.db = null;
				}
				self.useTestDatabase = true;
				self.databaseName = storageInterface.databaseName + "-test";
				log && log("DATABASE IN TEST MODE! " + requester);
				var req = _indexedDB.deleteDatabase(self.databaseName);
				req.onsuccess = function() {
					deferred.resolve();
				};
				req.onerror = function(e) {
					_logError("REQUEST ERROR! " + requester);
					deferred.reject(e);
				};
				req.onblocked = function(e) {
					_logError("REQUEST BLOCKED! " + requester);
					deferred.reject(e);
				};
			}).fail(function(e) {
				_logError("_initTestDB KO " + requester);
				deferred.reject(e);
			});
			return deferred.promise();
		},

		_openDB: function() {
			var deferred = $.Deferred();
			var self = this;
			if (self.useTestDatabase === false && self.db) {
				deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
			} else {
				var request;
				try {
					log && log("Open database, request version: " + self.databaseVersion);
					request = _indexedDB.open(self.databaseName, self.databaseVersion);
					request.onupgradeneeded = function(e) {
						log && log("Open database, need upgrade");
						self.db = (e.target.result || e.target.source);
						self._createObjectStore();
					};
					request.onblocked = function(e) {
						_logError("Open database, blocked", e);
						deferred.reject(e);
					};
					request.onsuccess = function(e) {
						log && log("Open database, success");
						var db = (e.target.result || e.target.source);
						if (!db.setVersion && (self.databaseVersion != db.version)) {
							log && log("Open database, versions missmatch: " + self.DatabaseVersion + " != " + db.version);
							var sdv = db.setVersion(self.databaseVersion);
							sdv.onsuccess = function(e) {
								log && log("Open database, setting version, success");
								self.db = db;
								self._createObjectStore();
								log && log("Open database, opened");
								deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
							};
							sdv.onerror = function(e) {
								log && log("Open database, setting version, error", e);
								self.db = null;
								deferred.reject(e);
							};
						} else {
							log && log("Open database, opened");
							self.db = db;
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
						}
					};
					request.onerror = function(e) {
						_logError("Open database, error", e);
						self.db = null;
						deferred.reject(e);
					};
				} catch (ex) {
					_logError("Open database, exception", ex);
					self.db = null;
					deferred.reject(ex);
				}
			}
			return deferred.promise();
		},
		/**
		 * Returns the objectStore to create
		 */
		getObjectStores: function() {
			return {};
		},
		// Create schema of database on version change
		_createObjectStore: function() {
			var self = this;
			var db = self.db;
			log && log("Updating database");
			try {
				var objectStores = this.getObjectStores();
				Object.keys(objectStores).forEach(function(name) {
					var os = objectStores[name];
					if (db.objectStoreNames.contains(name)) {
						log && log("Deleting objectStore: " + name);
						db.deleteObjectStore(name);
					}
					log && log("Creating objectStore: " + name);
					var obj = db.createObjectStore(name, os.options);
					Object.keys(os.indexes).forEach(function(iname) {
						var idx = os.indexes[iname];
						log && log("Creating index: " + iname);
						obj.createIndex(iname, idx.key, idx.options);
					});
				});
			} catch (e) {
				// Log because error doesn't bubble to the mail caller (caught by onupgradeneeded)
				_logError("_createObjectStore, error", e);
				throw e;
			}
		},
		// Used by children classes
		_eventToMessage: function(event) {
			var request = event.target || event.currentTarget || event.originalTarget;
			if (request && request.error && request.error.message) {
				return (request.error.name ? "[" + request.error.name + "]" : "") + request.error.message;
			}
			return JSON.stringify(event);
		},
		_eventToDiagnose: function(msg, e) {
			if (jsutils.isError(e) || jsutils.isDOMException(e)) {
				var diags = jsutils.convertToDiagnoses(e);
				diags.$diagnoses[0].$message = msg + "\n" + diags.$diagnoses[0].$message;
				return diags;
			}
			var request = e.target || e.currentTarget || e.originalTarget;
			var stack;
			if (request && request.error && request.error.message) {
				stack = (request.error.name ? "[" + request.error.name + "]" : "") + request.error.message;
			} else {
				stack = JSON.stringify(e, null, 2);
			}
			return {
				"$diagnoses": [{
					"$severity": "error",
					"$message": msg,
					"$stackTrace": stack
				}]
			};
		},
		// Needed because we can't clear the cache manually on FF and IE - #7942
		clearDatabaseSupported: function() {
			return true;
		},
		clearDatabase: function() {
			var self = this;
			var deferred = $.Deferred();
			$.smResolve().then(function() {
				var req = window.indexedDB.deleteDatabase(self.databaseName);
				req.onsuccess = function() {
					deferred.resolve(true);
				};
				req.onerror = function(e) {
					deferred.resolve(false);
					console.log("Database deletion failed");
					console.log(e);
				};
			}).fail(function() {
				deferred.resolve(false);
			});
			return deferred.promise();
		}

	}
);