"use strict";

/*
 * IndexDB storage interface (Internet Explorer, Firefox)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var Base = storageInterface.Klass;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("indexedDB", false);

// Increase this number to upgrade database to schema described in objectStores
var _databaseVersion = 20;
var _indexedDB = window.indexedDB || window.webkitIndexedDB;

var _Klass = utils.defineClass(
	function() {
		Base.call(this, "IndexedDB storage interface", _databaseVersion);
	},
	Base, {

		init: function(requester) {
			requester = requester || "";
			log && log("_INIT " + requester);
			var deferred = $.Deferred();
			var self = this;
			var useTestDatabase = globals.isTestEnvironment();
			try {
				var _doInit = function() {
					log && log("DATABASE INIT!");
					self._openDB().then(function(status) {
						log && log("_openDB OK " + requester);
						deferred.resolve(status);
					}).fail(function(status) {
						log && log("_openDB KO " + requester);
						deferred.resolve(status);
					});
				};
				if (useTestDatabase === true) {
					if (self.db) {
						self.db.close();
						self.db = null;
					}
					self.useTestDatabase = true;
					self.databaseName = storageInterface.databaseName + "-test";
					log && log("DATABASE IN TEST MODE! " + requester);
					var req = _indexedDB.deleteDatabase(self.databaseName);
					req.onsuccess = function() {
						_doInit();
					};
					req.onerror = function(e) {
						log && log("REQUEST ERROR! " + requester);
						deferred.reject(storageInterface.buildErrResult("error deleting database"));
					};
					req.onblocked = function(e) {
						log && log("REQUEST BLOCKED! " + requester);
						deferred.reject(storageInterface.buildErrResult("error deleting database (blocked)"));
					};
				} else if (!self.db) {
					_doInit();
				}
			} catch (e) {
				log && log("init ERROR " + requester);
				deferred.reject(storageInterface.buildErrResult("error initializing database", e));
			} finally {
				return deferred.promise();
			}
		},

		_openDB: function() {
			var deferred = $.Deferred();
			var self = this;
			if (self.useTestDatabase === false && self.db) {
				deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
			}

			var request;
			try {
				log && log("Open database, request version: " + self.databaseVersion);
				request = _indexedDB.open(self.databaseName, self.databaseVersion);
				request.onupgradeneeded = function(e) {
					log && log("Open database, need upgrade");
					self.db = (e.target.result || e.target.source);
					self._createObjectStore();
				};
				request.onsuccess = function(e) {
					log && log("Open database, success");
					var db = (e.target.result || e.target.source);
					if (!db.setVersion && (self.databaseVersion != db.version)) {
						log && log("Open database, versions missmatch: " + self.DatabaseVersion + " != " + db.version);
						var sdv = db.setVersion(self.databaseVersion);
						sdv.onsuccess = function(e) {
							log && log("Open database, setting version, success");
							self.db = db;
							self._createObjectStore();
							log && log("Open database, opened");
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
						};
						sdv.onerror = function(e) {
							log && log("Open database, setting version, error", e);
							self.db = null;
							deferred.reject(storageInterface.buildErrResult("error initializing database: " + self._eventToMessage(e)));
						};
					} else {
						log && log("Open database, opened");
						self.db = db;
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
					}
				};
				request.onerror = function(e) {
					log && log("Open database, error", e);
					self.db = null;
					deferred.reject(storageInterface.buildErrResult("error initializing database: " + self._eventToMessage(e)));
				};
			} catch (ex) {
				log && log("Open database, exception", ex);
				self.db = null;
				deferred.reject(storageInterface.buildErrResult("error initializing database", ex));
			}

			return deferred.promise();
		},
		/**
		 * Returns the objectStore to create
		 */
		getObjectStores: function() {
			return {};
		},
		// Create schema of database on version change
		_createObjectStore: function() {
			var self = this;
			var db = self.db;
			log && log("Updating database");

			var objectStores = this.getObjectStores();
			Object.keys(objectStores).forEach(function(name) {
				var os = objectStores[name];
				if (db.objectStoreNames.contains(name)) {
					log && log("Deleting objectStore: " + name);
					db.deleteObjectStore(name);
				}

				log && log("Creating objectStore: " + name);
				var obj = db.createObjectStore(name, os.options);
				Object.keys(os.indexes).forEach(function(iname) {
					var idx = os.indexes[iname];
					log && log("Creating index: " + iname);
					obj.createIndex(iname, idx.key, idx.options);
				});
			});
		},
		_eventToMessage: function(event) {
			return JSON.stringify(event);
		}

	}
);

exports.Klass = _Klass;