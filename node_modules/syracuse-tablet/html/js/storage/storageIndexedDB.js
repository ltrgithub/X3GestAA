"use strict";

/*
 * IndexDB storage interface (Internet Explorer, Firefox)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("indexedDB");

var _indexedDB = window.indexedDB || window.webkitIndexedDB;
var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
var IDBDatabaseException = window.IDBDatabaseException || window.webkitIDBDatabaseException;

var READ_ONLY = (IDBTransaction && IDBTransaction.READ_ONLY) || "readonly";
var READ_WRITE = (IDBTransaction && IDBTransaction.READ_WRITE) || "readwrite";

var _databaseName = "sage-mmd";

// Increase this number to upgrade database to schema described in _objectStores
var _databaseVersion = 7;

var _objectStores = {
	"sdata": {
		"options": {
			"autoIncrement": true
		},
		"indexes": {
			"read_write_one": {
				"key": ["key", "collection", "context"],
				"options": {
					"unique": true
				}
			},
			"read_write_all": {
				"key": ["collection", "context"],
				"options": {
					"unique": false
				}
			}
		}
	}
};

function _StorageInterfaceIndexedDB() {
	this.infoString = "IndexedDB storage interface";
	this.databaseVersion = _databaseVersion;
	this.databaseName = _databaseName;
	this.useTestDatabase = false;
	this.db = null;
};

var _storageInterfaceIndexedDBClass = utils.defineClass(
	_StorageInterfaceIndexedDB,
	storageInterface.StorageInterface, {

		init: function(useTestDatabase) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var _doInit = function() {
					self._openDB().then(function() {
						deferred.resolve(_buildResult(storageInterface.StatusCodes.OK));
					});
				};

				if (useTestDatabase === true) {
					if (self.db) self.db.close();
					self.useTestDatabase = true;
					self.databaseName = _databaseName + "-test";
					log && log("DATABASE IN TEST MODE!");
					var req = _indexedDB.deleteDatabase(self.databaseName);
					req.onsuccess = _doInit();
					req.onerror = function(e) {
						deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error deleting database"));
					};
					req.onblocked = function(e) {
						deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error deleting database (blocked)"));
					};
				} else if (!self.db) {
					_doInit();
				}
			} catch (e) {
				deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error initializing database", e));
			} finally {
				return deferred.promise();
			}
		},

		put: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("PUT: ", opts);
				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$key, opts.$collection, context];

				var index = objectStore.index("read_write_one");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);

				var doInsert = function() {
					var obj = {
						"context": context,
						"collection": opts.$collection,
						"key": opts.$key,
						"data": opts.$data,
					};

					var reqt = objectStore.add(obj);
					reqt.onerror = function(event) {
						deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error writing to database: " + _eventToMessage(event)));
					};
					reqt.onsuccess = function(event) {
						deferred.resolve(_buildResult(storageInterface.StatusCodes.OK, opts.$data));
					};
				};
				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							cr["delete"]();
							cr["continue"]();
						} else {
							doInsert();
						}
					} catch (e) {
						deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error writing to database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						doInsert();
					} else {
						deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error writing to database: " + _eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error writing to database", e));
			} finally {
				return deferred.promise();
			}
		},

		read: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("READ: ", opts);
				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$key, opts.$collection, context];

				var index = objectStore.index("read_write_one");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);

				request.onsuccess = function(event) {
					try {
						var cr = event.target && event.target.result && event.target.result.value;
						if (!cr) {
							deferred.resolve(_buildResult(storageInterface.StatusCodes.NOT_FOUND));
						} else {
							deferred.resolve(_buildResult(storageInterface.StatusCodes.OK, cr.data));
						}
					} catch (e) {
						deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						// Resolve since it's a logical issue and not neccessarily an error
						deferred.resolve(_buildResult(storageInterface.StatusCodes.NOT_FOUND));
					} else {
						deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error reading from database: " + _eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		query: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("QUERY: ", opts);
				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$collection, context];

				var index = objectStore.index("read_write_all");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);
				var results = [];

				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							var data = cr.value.data;
							results.push(data);
							cr["continue"]();
						} else {
							deferred.resolve(_buildResult(storageInterface.StatusCodes.OK, results));
						}
					} catch (e) {
						deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						// Resolve since it's a logical issue and not neccessarily an error
						deferred.resolve(results);
					} else {
						deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error reading from database: " + _eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		remove: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("REMOVE: ", opts);
				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$key, opts.$collection, context];

				var index = objectStore.index("read_write_one");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);

				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							cr["delete"]();
							deferred.resolve(_buildResult(storageInterface.StatusCodes.OK));
						} else {
							deferred.resolve(_buildResult(storageInterface.StatusCodes.NOT_FOUND));
						}
					} catch (e) {
						deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error deleting from database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						// Resolve since it's a logical issue and not neccessarily an error
						deferred.resolve(_buildResult(storageInterface.StatusCodes.NOT_FOUND));
					} else {
						deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error reading from database: " + _eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error deleting from database", e));
			} finally {
				return deferred.promise();
			}
		},

		_openDB: function() {
			var deferred = $.Deferred();
			var self = this;
			if (self.useTestDatabase === false && self.db) {
				deferred.resolve(_buildResult(storageInterface.StatusCodes.OK));
			}

			var request;
			try {
				log && log("Open database, request version: " + self.databaseVersion);
				request = _indexedDB.open(self.databaseName, self.databaseVersion);
				request.onupgradeneeded = function(e) {
					log && log("Open database, need upgrade");
					self.db = (e.target.result || e.target.source);
					self._createObjectStore();
				};
				request.onsuccess = function(e) {
					log && log("Open database, success");
					var db = (e.target.result || e.target.source);
					if (!db.setVersion && (self.databaseVersion != db.version)) {
						log && log("Open database, versions missmatch: " + self.DatabaseVersion + " != " + db.version);
						var sdv = db.setVersion(self.databaseVersion);
						sdv.onsuccess = function(e) {
							log && log("Open database, setting version, success");
							self.db = db;
							self._createObjectStore();
							log && log("Open database, opened");
							deferred.resolve(_buildResult(storageInterface.StatusCodes.OK));
						};
						sdv.onerror = function(e) {
							log && log("Open database, setting version, error", e);
							self.db = null;
							deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error initializing database: " + _eventToMessage(e)));
						};
					} else {
						log && log("Open database, opened");
						self.db = db;
						deferred.resolve(_buildResult(storageInterface.StatusCodes.OK));
					}
				};
				request.onerror = function(e) {
					log && log("Open database, error", e);
					self.db = null;
					deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error initializing database: " + _eventToMessage(e)));
				};
			} catch (ex) {
				log && log("Open database, exception", ex);
				self.db = null;
				deferred.reject(_buildResult(storageInterface.StatusCodes.ERROR, null, "error initializing database", e));
			}

			return deferred.promise();
		},

		// Create schema of database on version change
		_createObjectStore: function() {
			var self = this;
			var db = self.db;
			log && log("Updating database");
			Object.keys(_objectStores).forEach(function(name) {
				var os = _objectStores[name];
				if (db.objectStoreNames.contains(name)) {
					log && log("Deleting objectStore: " + name);
					db.deleteObjectStore(name);
				}

				log && log("Creating objectStore: " + name);
				var obj = db.createObjectStore(name, os.options);
				Object.keys(os.indexes).forEach(function(iname) {
					var idx = os.indexes[iname];
					log && log("Creating index: " + iname);
					obj.createIndex(iname, idx.key, idx.options);
				});
			});
		}
	}
);


function _buildResult(status, data, message, exception) {
	var res = {
		$status: status
	};
	if (data) res.$data = data;
	if (message) res.$message = message;
	if (exception) res.$exception = exception;

	return res;
}

function _eventToMessage(event) {
	return JSON.stringify(event);
}

exports.StorageInterface = _storageInterfaceIndexedDBClass;
exports.isAvailable = function() {
	return (_indexedDB != null);
};