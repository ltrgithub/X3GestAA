"use strict";

/*
 * IndexDB storage interface (Internet Explorer, Firefox)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("indexedDB");

var _indexedDB = window.indexedDB || window.webkitIndexedDB;
var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
var IDBDatabaseException = window.IDBDatabaseException || window.webkitIDBDatabaseException;

var READ_ONLY = (IDBTransaction && IDBTransaction.READ_ONLY) || "readonly";
var READ_WRITE = (IDBTransaction && IDBTransaction.READ_WRITE) || "readwrite";


// Increase this number to upgrade database to schema described in _objectStores
var _databaseVersion = 11;

var _objectStores = {
	"sdata": {
		"options": {
			"autoIncrement": true
		},
		"indexes": {
			"read_write_one": {
				"key": "key_collection_endpoint_context",
				"options": {
					"unique": true
				}
			},
			"read_write_all": {
				"key": "collection_endpoint_context",
				"options": {
					"unique": false
				}
			},
			"read_write_ctx": {
				"key": "context",
				"options": {
					"unique": false
				}
			}
		}
	}
};

function _StorageInterfaceIndexedDB() {
	this.infoString = "IndexedDB storage interface";
	this.databaseVersion = _databaseVersion;
	this.databaseName = storageInterface.databaseName;
	this.useTestDatabase = false;
	this.db = null;
};

var _storageInterfaceIndexedDBClass = utils.defineClass(
	_StorageInterfaceIndexedDB,
	storageInterface.StorageInterface, {

		init: function(requester) {
			requester = requester || "";
			log && log("_INIT " + requester);
			var deferred = $.Deferred();
			var self = this;
			var useTestDatabase = globals.isTestEnvironment();
			try {
				var _doInit = function() {
					log && log("DATABASE INIT!");
					self._openDB().then(function(status) {
						log && log("_openDB OK " + requester);
						deferred.resolve(status);
					}).fail(function(status) {
						log && log("_openDB KO " + requester);
						deferred.resolve(status);
					});
				};
				if (useTestDatabase === true) {
					if (self.db) {
						self.db.close();
						self.db = null;
					}
					self.useTestDatabase = true;
					self.databaseName = storageInterface.databaseName + "-test";
					log && log("DATABASE IN TEST MODE! " + requester);
					var req = _indexedDB.deleteDatabase(self.databaseName);
					req.onsuccess = function() {
						_doInit();
					};
					req.onerror = function(e) {
						log && log("REQUEST ERROR! " + requester);
						deferred.reject(storageInterface.buildErrResult("error deleting database"));
					};
					req.onblocked = function(e) {
						log && log("REQUEST BLOCKED! " + requester);
						deferred.reject(storageInterface.buildErrResult("error deleting database (blocked)"));
					};
				} else if (!self.db) {
					_doInit();
				}
			} catch (e) {
				log && log("init ERROR " + requester);
				deferred.reject(storageInterface.buildErrResult("error initializing database", e));
			} finally {
				return deferred.promise();
			}
		},

		put: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("PUT: ", JSON.stringify(opts));
				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$key, opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_one");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);
				var mustInsert = true;
				var datetime = utils.getCurISODateTime();
				var doInsert = function() {
					var obj = {
						"context": context,
						"collection": opts.$collection,
						"endpoint": opts.$endpoint,
						"key": opts.$key,
						"last_updated": datetime,
						"last_read": datetime,
						"key_collection_endpoint_context": key,
						"collection_endpoint_context": [opts.$collection, opts.$endpoint, context].join("_"),
						"data": opts.$data,
					};

					var reqt = objectStore.add(obj);
					reqt.onerror = function(event) {
						deferred.reject(storageInterface.buildErrResult("error writing to database: " + _eventToMessage(event)));
					};
					reqt.onsuccess = function(event) {
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
					};
				};
				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							if (opts.$data.$etag) {
								var etag = cr.value && cr.value.data.$etag;
								if (etag === opts.$data.$etag) {
									deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
									return;
								}
							}
							cr["delete"]();
							cr["continue"]();
						} else {
							doInsert();
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error writing to database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						doInsert();
					} else {
						deferred.reject(storageInterface.buildErrResult("error writing to database: " + _eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error writing to database", e));
			} finally {
				return deferred.promise();
			}
		},

		read: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("READ: ", JSON.stringify(opts));
				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");
				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);
				var key = [opts.$key, opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_one");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);

				request.onsuccess = function(event) {
					try {
						var cr = event.target && event.target.result && event.target.result.value;
						if (!cr) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						} else {
							deferred.resolve(storageInterface.buildResult(
								storageInterface.StatusCodes.OK,
								cr.data,
								null,
								null, {
									$lastRead: cr.last_read,
									$lastUpdated: cr.last_updated
								}));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						// Resolve since it's a logical issue and not neccessarily an error
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + _eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		query: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("QUERY: ", JSON.stringify(opts));
				if (!opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_all");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);
				var results = [];
				var meta = [];

				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							var data = cr.value.data;
							results.push(data);
							meta.push({
								$lastRead: cr.last_read,
								$lastUpdated: cr.last_updated
							});
							cr["continue"]();
						} else {
							deferred.resolve(storageInterface.buildResult(
								storageInterface.StatusCodes.OK,
								results,
								null,
								null,
								meta));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						// Resolve since it's a logical issue and not neccessarily an error
						deferred.resolve(storageInterface.buildResult(
							storageInterface.StatusCodes.OK,
							results,
							null,
							null,
							meta));
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + _eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		remove: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("REMOVE: ", JSON.stringify(opts));
				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$key, opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_one");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);

				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							cr["delete"]();
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
						} else {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error deleting from database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						// Resolve since it's a logical issue and not neccessarily an error
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + _eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error deleting from database", e));
			} finally {
				return deferred.promise();
			}
		},

		clearCollection: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("CLEAR: ", JSON.stringify(opts));
				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = context;

				//				var index = objectStore.index("read_write_ctx");
				//				var keyRange = IDBKeyRange.only(key);
				//				var request = index.openCursor(keyRange);
				var request = objectStore.openCursor();

				var records = [];

				var deleteMatches = function() {
					$.smForEachPromise(records, function(rec) {
						return self.remove({
							$context: opts.$context,
							$collection: rec.collection,
							$endpoint: rec.endpoint,
							$key: rec.key
						});
					}).then(function() {
						deferred.resolve();
					}).fail(function(e) {
						deferred.reject(e);
					});
				};
				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							if (opts.$collection.test(cr.value.collection)) {
								if (!opts.$not_read_since || cr.value.last_read < opts.$not_read_since) {
									records.push(cr.value);
								}
							}
							cr["continue"]();
						} else {
							deleteMatches();
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						deleteMatches();
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + _eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		computeCollectionSize: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("SIZE: ", JSON.stringify(opts));
				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = context;

				//				var index = objectStore.index("read_write_ctx");
				//				var keyRange = IDBKeyRange.only(key);
				//				var request = index.openCursor(keyRange);
				var request = objectStore.openCursor();
				var returnData = {
					numRecords: 0,
					sizeRecords: 0
				};

				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							if (opts.$collection.test(cr.value.collection)) {
								if (!opts.$not_read_since || cr.value.last_read < opts.$not_read_since) {
									returnData.numRecords++;
									returnData.sizeRecords += JSON.stringify(cr.value).length;
								}
							}
							cr["continue"]();
						} else {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, returnData));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						deferred.resolve();
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + _eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		_openDB: function() {
			var deferred = $.Deferred();
			var self = this;
			if (self.useTestDatabase === false && self.db) {
				deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
			}

			var request;
			try {
				log && log("Open database, request version: " + self.databaseVersion);
				request = _indexedDB.open(self.databaseName, self.databaseVersion);
				request.onupgradeneeded = function(e) {
					log && log("Open database, need upgrade");
					self.db = (e.target.result || e.target.source);
					self._createObjectStore();
				};
				request.onsuccess = function(e) {
					log && log("Open database, success");
					var db = (e.target.result || e.target.source);
					if (!db.setVersion && (self.databaseVersion != db.version)) {
						log && log("Open database, versions missmatch: " + self.DatabaseVersion + " != " + db.version);
						var sdv = db.setVersion(self.databaseVersion);
						sdv.onsuccess = function(e) {
							log && log("Open database, setting version, success");
							self.db = db;
							self._createObjectStore();
							log && log("Open database, opened");
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
						};
						sdv.onerror = function(e) {
							log && log("Open database, setting version, error", e);
							self.db = null;
							deferred.reject(storageInterface.buildErrResult("error initializing database: " + _eventToMessage(e)));
						};
					} else {
						log && log("Open database, opened");
						self.db = db;
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
					}
				};
				request.onerror = function(e) {
					log && log("Open database, error", e);
					self.db = null;
					deferred.reject(storageInterface.buildErrResult("error initializing database: " + _eventToMessage(e)));
				};
			} catch (ex) {
				log && log("Open database, exception", ex);
				self.db = null;
				deferred.reject(storageInterface.buildErrResult("error initializing database", ex));
			}

			return deferred.promise();
		},

		// Create schema of database on version change
		_createObjectStore: function() {
			var self = this;
			var db = self.db;
			log && log("Updating database");
			Object.keys(_objectStores).forEach(function(name) {
				var os = _objectStores[name];
				if (db.objectStoreNames.contains(name)) {
					log && log("Deleting objectStore: " + name);
					db.deleteObjectStore(name);
				}

				log && log("Creating objectStore: " + name);
				var obj = db.createObjectStore(name, os.options);
				Object.keys(os.indexes).forEach(function(iname) {
					var idx = os.indexes[iname];
					log && log("Creating index: " + iname);
					obj.createIndex(iname, idx.key, idx.options);
				});
			});
		}
	}
);

function _eventToMessage(event) {
	return JSON.stringify(event);
}

exports.StorageInterface = _storageInterfaceIndexedDBClass;
exports.isAvailable = function() {
	return (_indexedDB != null);
};