"use strict";

/*
 * IndexDB storage interface (Internet Explorer, Firefox)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("indexedDB");

var _indexedDB = window.indexedDB || window.webkitIndexedDB;
var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
var IDBDatabaseException = window.IDBDatabaseException || window.webkitIDBDatabaseException;

var READ_ONLY = (IDBTransaction && IDBTransaction.READ_ONLY) || "readonly";
var READ_WRITE = (IDBTransaction && IDBTransaction.READ_WRITE) || "readwrite";

var _databaseName = "sage-mmd";

// Increase this number to upgrade database to schema described in _objectStores
var _databaseVersion = 7;

var _objectStores = {
	"draft": {
		"keyPath": "id",
		"indexes": {
			"appid": {
				"unique": false
			},
			"original_url": {
				"unique": false
			}
		},
		"delAppOn": "appid"
	},
	"sdata": {
		"keyPath": "url",
		"indexes": {
			"appid": {
				"unique": false
			},
			"entity_url": {
				"unique": false
			},
			"status": {
				"unique": false
			}
		},
		"delAppOn": "appid"
	},
	"apps": {
		"keyPath": "id",
		"indexes": {
			"url": {
				"unique": false
			},
			"id": {
				"unique": true
			}
		},
		"delAppOn": "id"
	},
	"sdatafav": {
		"keyPath": "url",
		"indexes": {
			"appid": {
				"unique": false
			},
			"entity_url": {
				"unique": false
			}
		},
		"delAppOn": "appid"
	},
	"template": {
		"keyPath": "$uuid",
		"indexes": {
			"lookup": {
				"unique": false
			},
			"appid": {
				"unique": false
			}
		},
		"delAppOn": "appid"
	}
};

function _StorageInterfaceIndexedDB() {
	this.infoString = "IndexedDB storage interface";
	this.databaseVersion = _databaseVersion;
	this.databaseName = _databaseName;
	this.useTestDatabase = false;
	this.db = null;
};

var _storageInterfaceIndexedDBClass = utils.defineClass(
	_StorageInterfaceIndexedDB,
	storageInterface.StorageInterface, {
		init: function(useTestDatabase) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var _doInit = function() {
					self._openDB().then(function() {
						deferred.resolve();
					});
				};

				if (useTestDatabase === true) {
					if (self.db) self.db.close();
					self.useTestDatabase = true;
					self.databaseName = _databaseName + "-test";
					log && log("DATABASE IN TEST MODE!");
					var req = _indexedDB.deleteDatabase(self.databaseName);
					req.onsuccess = _doInit();
					req.onerror = function(e) {
						deferred.reject("onerror - error deleting database");
					};
					req.onblocked = function(e) {
						deferred.reject("onblocked - error deleting database");
					};
				} else if (!self.db) {
					_doInit();
				}
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/*==================================
         * App management
         ==================================*/
		queryAppConfigs: function(cb) {
			var deferred = $.Deferred();

			var self = this;
			var db = self.db;

			var tx = db.transaction(["apps"], READ_ONLY);
			var objectStore = tx.objectStore("apps");
			var index = objectStore.index("url");
			var request = index.openCursor();
			var results = [];

			request.onsuccess = function(event) {
				var cr = event.target.result;
				if (cr) {
					var data = cr.value;
					results.push({
						id: data.id,
						url: data.url,
						title: data.title,
						dsdescription: data.dsdescription,
						description: data.description,
						icon: data.icon,
						baseURL: data.baseURL,
						version: data.version
					});
					cr["continue"]();
				} else {
					deferred.resolve(results);
				}
			};
			request.onerror = function(event) {
				if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
					deferred.resolve(results);
				} else {
					deferred.reject(event);
				}
			};

			return deferred.promise();
		},

		createAppConfig: function(data) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("Insert new app: ", data);
				var tx = db.transaction(["apps"], READ_WRITE);
				var objectStore = tx.objectStore("apps");
				var index = objectStore.index("url");
				var keyRange = IDBKeyRange.only(data.url);
				var request = index.openCursor(keyRange);

				var doInsert = function() {
					var reqt = objectStore.add(data);
					reqt.onerror = function(event) {
						deferred.reject(event);
					};
					reqt.onsuccess = function(event) {
						deferred.resolve(data);
					};
				};
				request.onsuccess = function(event) {
					var cr = event.target.result;
					if (cr) {
						if (cr.value.baseURL == data.baseURL) {
							cr["delete"]();
						}
						cr["continue"]();
					} else {
						doInsert();
					}
				};
				request.onerror = function(event) {
					if (event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						doInsert();
					} else {
						deferred.reject(even);
					}
				};
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		readAppConfig: function(appid) {
			var deferred = $.Deferred();

			var self = this;
			var db = self.db;

			log && log("Read app: ", appid);

			var tx = db.transaction(["apps"], READ_ONLY);
			var objectStore = tx.objectStore("apps");
			var request = objectStore.get(appid);

			request.onsuccess = function(event) {
				var cr = event.target.result;
				if (cr) {
					deferred.resolve(cr);
				} else {
					deferred.resolve();
				}
			};
			request.onerror = function(event) {
				deferred.reject(event);
			};

			return deferred.promise();
		},

		deleteAppConfig: function(id) {
			var deferred = $.Deferred();

			var self = this;
			var db = self.db;

			log && log("Delete app: ", id);

			var stores = [];

			// Delete records in all object stores that have an appid index
			Object.keys(_objectStores).forEach(function(name) {
				var os = _objectStores[name];
				if (os.delAppOn) {
					stores.push(name);
				}
			});

			var tx = db.transaction(stores, READ_WRITE);

			function deleteNextObjectStore() {
				if (stores.length > 0) {
					var os = stores.pop();
					log && log("Delete app in: " + os + "(" + id + ")");

					var ostx = tx.objectStore(os);
					var index = ostx.index(_objectStores[os].delAppOn);
					var keyRange = IDBKeyRange.only(id);

					try {
						var request = index.openCursor(keyRange);
						request.onsuccess = function(event) {
							if (event.target.result) {
								var cr = event.target.result;
								cr["delete"]();
								cr["continue"]();
							} else {
								deleteNextObjectStore();
							}
						};
						request.onerror = function(event) {
							deferred.reject(event);
						};
					} catch (ex) {
						deferred.reject(ex);
					}
				} else {
					deferred.resolve();
				}
			}
			deleteNextObjectStore();

			return deferred.promise();
		},

		_openDB: function() {
			var deferred = $.Deferred();
			var self = this;
			if (self.useTestDatabase === false && self.db) {
				deferred.resolve();
			}

			var request;
			try {
				log && log("Open database, request version: " + self.databaseVersion);
				request = _indexedDB.open(self.databaseName, self.databaseVersion);
				request.onupgradeneeded = function(e) {
					log && log("Open database, need upgrade");
					self.db = (e.target.result || e.target.source);
					self._createObjectStore();
				};
				request.onsuccess = function(e) {
					log && log("Open database, success");
					var db = (e.target.result || e.target.source);
					if (!db.setVersion && (self.databaseVersion != db.version)) {
						log && log("Open database, versions missmatch: " + self.DatabaseVersion + " != " + db.version);
						var sdv = db.setVersion(self.databaseVersion);
						sdv.onsuccess = function(e) {
							log && log("Open database, setting version, success");
							self.db = db;
							self._createObjectStore();
							log && log("Open database, opened");
							deferred.resolve();
						};
						sdv.onerror = function(e) {
							log && log("Open database, setting version, error", e);
							self.db = null;
							deferred.reject(e);
						};
					} else {
						log && log("Open database, opened");
						self.db = db;
						deferred.resolve();
					}
				};
				request.onerror = function(e) {
					log && log("Open database, error", e);
					self.db = null;
					deferred.reject(e);
				};
			} catch (ex) {
				log && log("Open database, exception", ex);
				self.db = null;
				deferred.reject(ex);
			}

			return deferred.promise();
		},

		// Create schema of database on version change
		_createObjectStore: function() {
			var self = this;
			var db = self.db;
			log && log("Updating database");
			Object.keys(_objectStores).forEach(function(name) {
				var os = _objectStores[name];
				if (db.objectStoreNames.contains(name)) {
					log && log("Deleting objectStore: " + name);
					db.deleteObjectStore(name);
				}

				log && log("Creating objectStore: " + name);
				var obj = db.createObjectStore(name, {
					"keyPath": os.keyPath
				});
				Object.keys(os.indexes).forEach(function(iname) {
					var idx = os.indexes[iname];
					log && log("Creating index: " + iname);
					obj.createIndex(iname, iname, idx);
				});
			});
		}
	}
);

exports.StorageInterface = _storageInterfaceIndexedDBClass;
exports.isAvailable = function() {
	return (_indexedDB != null);
};