"use strict";

/*
 * IndexDB storage interface (Internet Explorer, Firefox)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var Base = require('syracuse-tablet/html/js/storage/storageIndexedDBSData').Klass;
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("drafts", false);
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
var IDBDatabaseException = window.IDBDatabaseException || window.webkitIDBDatabaseException;

var READ_ONLY = (IDBTransaction && IDBTransaction.READ_ONLY) || "readonly";
var READ_WRITE = (IDBTransaction && IDBTransaction.READ_WRITE) || "readwrite";


var _objectStores = {
	"drafts": {
		"options": {
			"keyPath": "id",
			"autoIncrement": true
		},
		"indexes": {}
	},
	"workingcopies": {
		"options": {
			"keyPath": "id",
			"autoIncrement": true
		},
		"indexes": {}
	}
};

var _logError = function(who, e) {
	if (!log) return;
	log("INDEXED DB - ERROR");
	for (var i = 0; i < arguments.length; i++) {
		var e = arguments[i];
		if (typeof e === "string") {
			log(e);
			continue;
		}
		if (e && e.target) {
			if (e.target.errorCode != IDBDatabaseException.NOT_FOUND_ERR) {
				log(JSON.stringify(e, null, 2));
				continue;
			}
		}
		log(JSON.stringify(jsutils.convertToDiagnoses(e), null, 2));
	}
};

var _objName = function(type) {
	return type === "d" ? "drafts" : "workingcopies";
};
/**
 * Manages drafts and working copies storage
 */
var _Klass = utils.defineClass(
	function() {
		Base.call(this);
	},
	Base, {
		/** Overridden method */
		getObjectStores: function() {
			var res = Base.prototype.getObjectStores.call(this);
			$.extend(res, _objectStores);
			return res;
		},

		/** OMethods below are private - Use a dedicated name specific to the class */

		/**
		 * type: d for drafts -  w for workingcopies
		 * Resolves with object store or rejects
		 */
		_draftsObjectStore: function(type, readOpt) {
			var self = this;
			var deferred = $.Deferred();
			try {
				var tx = self.db.transaction([_objName(type)], readOpt || READ_WRITE);
				tx.oncomplete = function(event) {
					log && log("tx.oncomplete", JSON.stringify(event, null, 2));
				};
				tx.onerror = function(event) {
					log && log("tx.onerror", JSON.stringify(event, null, 2));
					//_logError({$diagnoses: [{$message : _objName(type) + " - - IndexedDB.Transaction error", $stackTrace: self._eventToMessage(event)}]});
				};
				deferred.resolve(tx.objectStore(_objName(type)));
			} catch (e) {
				_logError('_draftsObjectStore - ' + _objName(type), e);
				deferred.reject(e);
			}
			return deferred.promise();
		},
		/**
		 * type: d for drafts -  w for workingcopies
		 * Resolves with data if record identified by id or null
		 * fail = true to reject if error
		 */
		_draftGetObject: function(type, id, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._draftsObjectStore(type, READ_ONLY).then(function(objectStore) {
				var request = objectStore.get(id);
				request.onsuccess = function(event) {
					try {
						var result = request.result && request.result.data ? JSON.parse(request.result.data) : null;
						deferred.resolve(result);
						log && log("_draftGetObject - " + _objName(type), "OK");
					} catch (e) {
						log && log("_draftGetObject - " + _objName(type), "Error parsing data");
						if (fail) {
							deferred.reject({
								$diagnoses: [{
									$message: "_draftGetObject - " + _objName(type) + " - Error parsing data"
								}]
							});
						} else {
							deferred.resolve(null);
						}
					}
				};
				request.onerror = function(event) {
					_logError("_draftGetObject - " + _objName(type), event);
					if (fail) {
						deferred.reject({
							$diagnoses: [{
								$message: _objName(type) + " - IndexedDB.OpenCursor error",
								$stackTrace: self._eventToMessage(event)
							}]
						});
					} else {
						deferred.resolve(null);
					}
				};
			}).fail(function(e) {
				if (fail) {
					deferred.reject(e);
				} else {
					deferred.resolve(null);
				}
			});
			return deferred.promise();
		},
		/**
		 * type: d for drafts -  w for workingcopies
		 * Resolves with and array of all records or []
		 * fail = true to reject if error
		 */
		_draftGetAllObjects: function(type, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._draftsObjectStore(type, READ_ONLY).then(function(objectStore) {
				// objectStore.getAll not implemented in FF
				var request = objectStore.openCursor();
				var result = [],
					data;
				request.onsuccess = function(event) {
					var cursor = event.target.result;
					if (cursor) {
						try {
							data = cursor.value && cursor.value.data ? JSON.parse(cursor.value.data) : null;
							if (data) {
								result.push(data);
							}
						} catch (e) {
							log && log("_draftGetAllObjects - " + _objName(type), "Error parsing data");
						}
						cursor.continue ();
					} else {
						log && log("_draftGetAllObjects - " + _objName(type), "OK");
						deferred.resolve(result);
					}
				};
				request.onerror = function(event) {
					_logError("_draftGetAllObjects - " + _objName(type), event);
					if (fail) {
						deferred.reject({
							$diagnoses: [{
								$message: _objName(type) + " - IndexedDB.openCursor error",
								$stackTrace: self._eventToMessage(event)
							}]
						});
					} else {
						deferred.resolve([]);
					}
				};
			}).fail(function(e) {
				if (fail) {
					deferred.reject(e);
				} else {
					deferred.resolve([]);
				}
			});
			return deferred.promise();
		},
		/**
		 * type: d for drafts - w for workingcopies
		 * Create a record of update the existing one if any
		 * Resolves with data  and true if record has been created
		 * fail = true to reject if error
		 */
		_draftPutObject: function(type, id, data, fail) {
			var self = this;
			var deferred = $.Deferred();
			if (!data || !id) {
				_logError("_draftPutObject - " + _objName(type), "Invalid parameters");
				if (fail) {
					deferred.reject({
						$diagnoses: [{
							$message: "_draftPutObject - " + _objName(type) + " - Invalid parameters"
						}]
					});
				} else {
					deferred.resolve(null);
				}
			} else {
				self._draftsObjectStore(type, READ_WRITE).then(function(objectStore) {
					var _put = function(created) {
						var request = objectStore.put({
							"id": id,
							"data": JSON.stringify(data),
							"creation_date": utils.getCurISODateTime(new Date())
						});
						request.onsuccess = function(event) {
							log && log("_draftPutObject - " + _objName(type), "OK");
							deferred.resolve(data, created);
						};
						request.onerror = function(event) {
							_logError("_draftPutObject - " + _objName(type), event);
							if (fail) {
								deferred.reject({
									$diagnoses: [{
										$message: _objName(type) + " - IndexedDB.put error",
										$stackTrace: self._eventToMessage(event)
									}]
								});
							} else {
								deferred.resolve(null);
							}
						};
					};
					// Just to return created or updated
					var request = objectStore.get(id);
					request.onsuccess = function(event) {
						_put(true);
					};
					request.onerror = function(event) {
						_put(false);
					};
				}).fail(function(e) {
					if (fail) {
						deferred.reject(e);
					} else {
						deferred.resolve(null);
					}
				});
			}
			return deferred.promise();
		},
		/**
		 * type: d for drafts - w for workingcopies
		 * Delete a record if any
		 * Resolves with true (deleted) or false (no record deleted)
		 * fail = true to reject if error
		 */
		_draftDeleteObject: function(type, id, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._draftsObjectStore(type, READ_WRITE).then(function(objectStore) {
				var request = objectStore["delete"](id);
				request.onsuccess = function(event) {
					log && log("_draftDeleteObject - " + _objName(type), "OK");
					deferred.resolve(true);
				};
				request.onerror = function(event) {
					_logError("_draftDeleteObject - " + _objName(type), event);
					if (fail) {
						deferred.reject({
							$diagnoses: [{
								$message: _objName(type) + " -  IndexedDB.delete error",
								$stackTrace: self._eventToMessage(event)
							}]
						});
					} else {
						deferred.resolve(false);
					}
				};
			}).fail(function(e) {
				if (fail) {
					deferred.reject(e);
				} else {
					deferred.resolve(false);
				}
			});
			return deferred.promise();
		},
		/**
		 * type: d for drafts - w for workingcopies
		 * Delete all records
		 * Resolves with true (deleted) or false (no record deleted)
		 * fail = true to reject if error
		 */
		_draftDeleteAllObjects: function(type, id, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._draftsObjectStore(type, READ_WRITE).then(function(objectStore) {
				var request = objectStore.clear();
				request.onsuccess = function(event) {
					log && log("_draftDeleteAllObjects" + _objName(type), "OK");
					deferred.resolve(true);
				};
				request.onerror = function(event) {
					_logError("_draftDeleteAllObjects" + _objName(type), event);
					if (fail) {
						deferred.reject({
							$diagnoses: [{
								$message: _objName(type) + " -  IndexedDB.clear error",
								$stackTrace: self._eventToMessage(event)
							}]
						});
					} else {
						deferred.resolve(false);
					}
				};
			}).fail(function(e) {
				if (fail) {
					deferred.reject(e);
				} else {
					deferred.resolve(false);
				}
			});
			return deferred.promise();
		},
		/**
		 * type: d for drafts - w for workingcopies
		 * Count all records
		 * Resolves with count
		 * fail = true to reject if error
		 */
		_draftCountAllObjects: function(type, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._draftsObjectStore(type, READ_ONLY).then(function(objectStore) {
				var request = objectStore.count();
				request.onsuccess = function(event) {
					log && log("_draftCountAllObjects" + _objName(type), "OK", request.result);
					deferred.resolve(request.result);
				};
				request.onerror = function(event) {
					_logError("_draftCountAllObjects" + _objName(type), event);
					if (fail) {
						deferred.reject({
							$diagnoses: [{
								$message: _objName(type) + " -  IndexedDB.count error",
								$stackTrace: self._eventToMessage(event)
							}]
						});
					} else {
						deferred.resolve(0);
					}
				};
			}).fail(function(e) {
				if (fail) {
					deferred.reject(e);
				} else {
					deferred.resolve(0);
				}
			});
			return deferred.promise();
		},
		/**
		 * Resolve with data/null
		 */
		_wrkcpyRead: function(id) {
			return this._draftGetObject("w", id, false);
		},
		/**
		 * Resolve with  true/false
		 * Delete all the working copies that belong to transaction_id
		 */
		_wrkcpyDelete: function(id) {
			return this._draftDeleteObject("w", id, false);
		},
		/**
		 * Resolve with true/false
		 */
		_wrkcpyDeleteAll: function() {
			return this._draftDeleteAllObjects("w", false);
		},
		/**
		 * Resolve with dataSet/null
		 */
		_wrkcpyUpdate: function(dataSet) {
			if (!dataSet) {
				return $.smResolve(null);
			}
			return this._draftPutObject("w", dataSet.$uuid, dataSet, false);
		},
		_wrkcpyCreate: function(dataSet) {
			return this._wrkcpyUpdate(dataSet);
		},
		/**
		 * Resolve with [resources]/[]
		 */
		_draftReadList: function() {
			return this._draftGetAllObjects("d", false);
		},
		/**
		 * Resolve with data/null
		 */
		_draftRead: function(id) {
			return this._draftGetObject("d", id, false);
		},
		/**
		 * Resolve with  true/false
		 */
		_draftDelete: function(id) {
			var self = this;
			return self._draftDeleteObject("d", id, false).then(function(result) {
				self._draftNotifyChanged();
				return result;
			});
		},
		/**
		 * Resolve with true/false
		 */
		_draftDeleteAll: function() {
			var self = this;
			return self._deleteAllObject("d", false).then(function(result) {
				self._draftNotifyChanged();
				return result;
			});
		},
		/**
		 * Resolve with draft context or reject with an exception
		 */
		_draftSave: function(ctx) {
			if (!ctx) {
				return $.smResolve(null);
			}
			var self = this;
			return self._draftPutObject("d", ctx.id, ctx, false).then(function(data, created) {
				if (created) {
					self._draftNotifyChanged();
				}
				return data;
			});
		},
		_draftCount: function(notify) {
			return this._draftCountAllObjects("d", false).then(function(count) {
				if (notify) {
					notifications.publish("sm.drafts.changed", count);
				}
				return count;
			});
		},
		/**
		 * Notifies to update the number of draft in 'List of draft' menu item
		 */
		_draftNotifyChanged: function() {
			return this._draftCount(true);
		},
		/**
		 * Drafts
		 * op: Operation
		 * 		save
		 * 			args(1) create true/false
		 * 		read
		 * 		query
		 * 		delete
		 * 		switchStatus
		 */
		draftOperation: function(op) {
			switch (op) {
				case "wrkcpyUpdate":
					return this._wrkcpyUpdate(arguments[1]);
				case "wrkcpyRead":
					return this._wrkcpyRead(arguments[1]);
				case "wrkcpyDelete":
					return this._wrkcpyDelete(arguments[1]);
				case "wrkcpyCreate":
					return this._wrkcpyCreate(arguments[1], arguments[2]);
				case "wrkcpyDeleteAll":
					return this._wrkcpyDeleteAll(arguments[1]);
				case "draftSave":
					return this._draftSave(arguments[1]);
				case "draftDelete":
					return this._draftDelete(arguments[1]);
				case "draftDeleteAll":
					return this._draftDeleteAll();
				case "draftRead":
					return this._draftRead(arguments[1]);
				case "draftReadList":
					return this._draftReadList();
				case "draftCount":
					return this._draftCount(false);
				case "draftNotifyChanged":
					var self = this;
					setTimeout(function() {
						self._draftNotifyChanged();
					});
					return;
				default:
					return $.smReject(storageInterface.buildErrResult("Unknown Draft operation[" + op + "]"));
			}
		}
	}
);

exports.Klass = _Klass;