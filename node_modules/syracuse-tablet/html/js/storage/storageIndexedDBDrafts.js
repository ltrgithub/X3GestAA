"use strict";

/*
 * IndexDB storage interface (Internet Explorer, Firefox)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var Base = require('syracuse-tablet/html/js/storage/storageIndexedDBSData').Klass;
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("drafts", true);

var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
var IDBDatabaseException = window.IDBDatabaseException || window.webkitIDBDatabaseException;

var READ_ONLY = (IDBTransaction && IDBTransaction.READ_ONLY) || "readonly";
var READ_WRITE = (IDBTransaction && IDBTransaction.READ_WRITE) || "readwrite";


var _objectStores = {
	"drafts": {
		"options": {
			"keyPath": "id",
			"autoIncrement": true
		},
		"indexes": {}
	}
};

var _logError = function(who, e) {
	if (!log) return;
	log("INDEXED DB - ERROR");
	for (var i = 0; i < arguments.length; i++) {
		var e = arguments[i];
		if (typeof e === "string") {
			log(e);
			continue;
		}
		if (e && e.target && IDBDatabaseException) {
			if (e.target.errorCode != IDBDatabaseException.NOT_FOUND_ERR) {
				log(JSON.stringify(e, null, 2));
				continue;
			}
		}
		log(JSON.stringify(jsutils.convertToDiagnoses(e), null, 2));
	}
};

/**
 * Manages drafts and working copies storage
 */
exports.Klass = utils.defineClass(
	function() {
		Base.call(this);
	},
	Base, {
		/** Overridden method */
		getObjectStores: function() {
			var res = Base.prototype.getObjectStores.call(this);
			$.extend(res, _objectStores);
			return res;
		},

		/** OMethods below are private - Use a dedicated name specific to the class */

		/**
		 * Resolves with object store or rejects
		 */
		_draftsObjectStore: function(readOpt) {
			var tx = this.db.transaction(["drafts"], readOpt || READ_WRITE);
			tx.oncomplete = function(event) {
				log && log("tx.oncomplete", JSON.stringify(event, null, 2));
			};
			tx.onerror = function(event) {
				log && log("tx.onerror", JSON.stringify(event, null, 2));
			};
			return tx.objectStore("drafts");
		},
		/**
		 * Resolve with [resources]/[]
		 */
		_draftReadList: function() {
			var deferred = $.Deferred();
			try {
				// objectStore.getAll not implemented in FF
				var request = this._draftsObjectStore(READ_ONLY).openCursor();
				var result = [];
				request.onsuccess = function(event) {
					var cursor = event.target.result;
					if (cursor) {
						try {
							var data = cursor.value && cursor.value.data ? JSON.parse(cursor.value.data) : null;
							if (data) {
								result.push(data);
							}
						} catch (e) {
							log && log("_draftReadList", "Error parsing data", e);
						}
						cursor.continue();
					} else {
						log && log("_draftReadList", "OK");
						deferred.resolve(result);
					}
				};
				request.onerror = function(event) {
					_logError("_draftReadList", event);
					deferred.resolve([]);
				};
			} catch (e) {
				log && log("ERROR - _draftReadList", e);
				deferred.resolve([]);
			}
			return deferred.promise();

		},
		/**
		 * Resolve with data/null
		 */
		_draftRead: function(id) {
			var deferred = $.Deferred();
			try {
				var objectStore = this._draftsObjectStore(READ_ONLY);
				var request = objectStore.get(id);
				request.onsuccess = function(event) {
					try {
						var result = request.result && request.result.data ? JSON.parse(request.result.data) : null;
						deferred.resolve(result);
						log && log("_draftRead", "OK");
					} catch (e) {
						log && log("_draftRead", "Error parsing data", e);
						deferred.resolve(null);
					}
				};
				request.onerror = function(event) {
					_logError("_draftRead", event);
					deferred.resolve(null);
				};
			} catch (e) {
				log && log("_draftRead", e);
				deferred.resolve(null);
			}
			return deferred.promise();
		},
		/**
		 * Resolve with  true/false
		 */
		_draftDelete: function(id) {
			var deferred = $.Deferred();
			try {
				var objectStore = this._draftsObjectStore(READ_WRITE);
				var request = objectStore["delete"](id);
				request.onsuccess = function(event) {
					log && log("_draftDelete", "OK");
					deferred.resolve(true);
				};
				request.onerror = function(event) {
					_logError("_draftDelete", event);
					deferred.resolve(false);
				};
			} catch (e) {
				log && log("_draftDelete", e);
				deferred.resolve(false);
			}
			return deferred.promise();
		},
		/**
		 * Resolve with true/false
		 */
		_draftDeleteAll: function() {
			var deferred = $.Deferred();
			try {
				var objectStore = this._draftsObjectStore(READ_WRITE);
				var request = objectStore.clear();
				request.onsuccess = function(event) {
					log && log("_draftDeleteAll", "OK");
					deferred.resolve(true);
				};
				request.onerror = function(event) {
					_logError("_draftDeleteAll", event);
					deferred.resolve(false);
				};
			} catch (e) {
				log && log("_draftDeleteAll", e);
				deferred.resolve(false);
			}
			return deferred.promise();
		},
		/**
		 * Resolve with draft context or reject with an exception
		 */
		_draftSave: function(ctx) {
			if (!ctx) {
				return $.smResolve(null);
			}
			var deferred = $.Deferred();
			try {
				var objectStore = this._draftsObjectStore(READ_WRITE);
				var _put = function(created) {
					var request = objectStore.put({
						"id": ctx.id,
						"data": JSON.stringify(ctx),
						"creation_date": utils.getCurISODateTime(new Date())
					});
					request.onsuccess = function(event) {
						log && log("_draftSave", "OK");
						deferred.resolve(ctx, created);
					};
					request.onerror = function(event) {
						_logError("_draftSave", event);
						deferred.resolve(null);
					};
				};
				// Just to return created or updated
				var request = objectStore.get(ctx.id);
				request.onsuccess = function(event) {
					_put(true);
				};
				request.onerror = function(event) {
					_put(false);
				};
			} catch (e) {
				log && log("ERROR _draftSave", e);
				deferred.resolve(null);
			}
			return deferred.promise();
		},
		_draftCount: function(notify) {
			var deferred = $.Deferred();
			try {
				var objectStore = this._draftsObjectStore(READ_ONLY);
				var request = objectStore.count();
				request.onsuccess = function(event) {
					log && log("_draftCount", "OK", request.result);
					deferred.resolve(request.result);
				};
				request.onerror = function(event) {
					_logError("_draftCount", event);
					deferred.resolve(0);
				};
			} catch (e) {
				log && log("ERROR _draftCount", e);
				deferred.resolve(0);
			}
			return deferred.promise();
		},
		/**
		 * Drafts
		 * op: Operation
		 * 		save
		 * 			args(1) create true/false
		 * 		read
		 * 		query
		 * 		delete
		 * 		switchStatus
		 */
		draftOperation: function(op) {
			switch (op) {
				case "draftSave":
					return this._draftSave(arguments[1]);
				case "draftDelete":
					return this._draftDelete(arguments[1]);
				case "draftDeleteAll":
					return this._draftDeleteAll();
				case "draftRead":
					return this._draftRead(arguments[1]);
				case "draftReadList":
					return this._draftReadList();
				case "draftCount":
					return this._draftCount(false);
				default:
					return $.smReject(storageInterface.buildErrResult("Unknown Draft operation[" + op + "]"));
			}
		}
	}
);