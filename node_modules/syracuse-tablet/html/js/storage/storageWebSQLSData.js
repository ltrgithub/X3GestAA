"use strict";

/**
 * WebSQL storage interface - SDATA (META + DATA) MANAGEMENT
 * Members added to of _storageInterfaceWebSQLClass
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("webSQL");

var _tables = {
	"sdata_meta": [
		// meta data table for handling etags, ttl, size, ..
		"DROP TABLE IF EXISTS sdata_meta",
		"CREATE TABLE sdata_meta ( " +
		"key text, " +
		"collection text, " +
		"endpoint text, " +
		"context text, " +
		"id text, " +
		"etag text, " +
		"last_read text, " +
		"last_updated text" +
		")",
		"DROP INDEX IF EXISTS sdata_meta_pk",
		"CREATE UNIQUE INDEX sdata_meta_pk ON sdata_meta (key, collection, endpoint, context)",
		"DROP INDEX IF EXISTS sdata_meta_id",
		"CREATE UNIQUE INDEX sdata_meta_id ON sdata_meta (id)"
	],
	"sdata_objects": [
		// data table
		"DROP TABLE IF EXISTS sdata_objects",
		"CREATE TABLE sdata_objects ( " +
		"id text, " +
		"data text " +
		")",
		"DROP INDEX IF EXISTS sdata_objects_pk",
		"CREATE UNIQUE INDEX sdata_objects_pk ON sdata_objects (id)"
	]
};

var _members = {

	put: function(opts) {
		var deferred = $.Deferred();
		var self = this;
		try {
			var db = self.db;
			log && log("PUT: ", JSON.stringify(opts));

			if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
				throw new Error("Insufficient parameters");

			var context = JSON.stringify(opts.$context);
			var params = [opts.$key, opts.$collection, opts.$endpoint, context];

			var insertData = function(metaData) {
				self._executeSql("INSERT INTO sdata_objects (data, id) values (?, ?)", [JSON.stringify(opts.$data), metaData.$id])
					.then(function() {
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
					}).fail(function(status) {
						deferred.reject(status);
					});
			};

			var updateData = function(metaData) {
				self._executeSql("UPDATE sdata_objects set data = ? where id = ?", [JSON.stringify(opts.$data), metaData.$id])
					.then(function(result) {
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
					}).fail(function(status) {
						deferred.reject(status);
					});
			};

			// handle meta data
			self._readMetaData(context, params)
				.then(function(metaData) {
					if (metaData && metaData.$etag === opts.$data.$etag) {
						// record has not changed
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
					} else if (metaData) {
						// update
						metaData.$etag = opts.$data.$etag;
						metaData.$lastUpdated = utils.getCurISODateTime();
						self._writeMetaData(metaData)
							.then(function() {
								updateData(metaData);
							}).fail(function(status) {
								deferred.reject(status);
							});
					} else {
						// insert
						metaData = {
							$key: opts.$key,
							$collection: opts.$collection,
							$endpoint: opts.$endpoint,
							$context: opts.$context,
							$etag: opts.$data.$etag,
							$lastUpdated: utils.getCurISODateTime()
						};
						self._writeMetaData(metaData)
							.then(function(metaData) {
								insertData(metaData);
							}).fail(function(status) {
								deferred.reject(status);
							});
					}
				}).fail(function(status) {
					deferred.reject(status);
				});
		} catch (e) {
			deferred.reject(storageInterface.buildErrResult("error writing to database", e));
		} finally {
			return deferred.promise();
		}
	},

	read: function(opts) {
		var deferred = $.Deferred();
		var self = this;
		try {
			var db = self.db;
			log && log("READ: ", JSON.stringify(opts));

			if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
				throw new Error("Insufficient parameters");

			var context = JSON.stringify(opts.$context);
			var params = [opts.$key, opts.$collection, opts.$endpoint, context];

			self._readMetaData(context, params)
				.then(function(metaData) {
					if (!metaData) {
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
					} else {
						self._executeSql("SELECT * FROM sdata_objects where id = ?", [metaData.$id])
							.then(function(result) {
								try {
									if (result.rows.length <= 0) {
										deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
									} else {
										deferred.resolve(storageInterface.buildResult(
											storageInterface.StatusCodes.OK,
											JSON.parse(result.rows.item(0).data),
											null,
											null, {
												$lastRead: metaData.$lastRead,
												$lastUpdated: metaData.$lastUpdated
											}));
									}
								} catch (e) {
									deferred.reject(storageInterface.buildErrResult("error reading from database", e));
								}
							}).fail(function(status) {
								deferred.reject(status);
							});
					}
				}).fail(function(status) {
					deferred.reject(status);
				});
		} catch (e) {
			deferred.reject(storageInterface.buildErrResult("error reading from database", e));
		} finally {
			return deferred.promise();
		}
	},

	query: function(opts) {
		var deferred = $.Deferred();
		var self = this;
		try {
			var db = self.db;
			log && log("QUERY: ", JSON.stringify(opts));

			if (!opts.$collection || !opts.$endpoint || !opts.$context)
				throw new Error("Insufficient parameters");

			var context = JSON.stringify(opts.$context);
			var params = [opts.$collection, opts.$endpoint, context];

			self._executeSql("SELECT o.*, m.last_read, m.last_updated FROM sdata_objects o INNER JOIN sdata_meta m ON (o.id = m.id and m.collection = ? and m.endpoint = ? and m.context = ?)", params)
				.then(function(result) {
					var ret = [];
					var meta = [];
					try {
						for (var i = 0; i < result.rows.length; i++) {
							var item = result.rows.item(i);
							ret.push(JSON.parse(item.data));
							meta.push({
								$lastRead: item.last_read,
								$lastUpdated: item.last_updated
							});
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
						return;
					}
					// Exception are handled by our jq deferred hack
					deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, ret, null, null, meta));
				}).fail(function(status) {
					deferred.reject(status);
				});
		} catch (e) {
			deferred.reject(storageInterface.buildErrResult("error reading from database", e));
		} finally {
			return deferred.promise();
		}
	},

	remove: function(opts) {
		var deferred = $.Deferred();
		var self = this;
		try {
			var db = self.db;
			log && log("REMOVE: ", JSON.stringify(opts));

			if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
				throw new Error("Insufficient parameters");

			var context = JSON.stringify(opts.$context);
			var params = [opts.$key, opts.$collection, opts.$endpoint, context];
			self._removeMetaData(context, params)
				.then(function(metaData) {
					if (!metaData) {
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
					} else {
						self._executeSql("DELETE FROM sdata_objects where id = ?", [metaData.$id])
							.then(function() {
								deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
							}).fail(function(status) {
								deferred.reject(status);
							});
					}
				}).fail(function(status) {
					deferred.reject(status);
				});
		} catch (e) {
			deferred.reject(storageInterface.buildErrResult("error writing to database", e));
		} finally {
			return deferred.promise();
		}
	},
	clearCollection: function(opts) {
		var deferred = $.Deferred();
		var self = this;
		try {
			var db = self.db;
			log && log("CLEAR: ", JSON.stringify(opts));

			if (!opts.$collection || !opts.$context)
				throw new Error("Insufficient parameters");

			var context = JSON.stringify(opts.$context);
			var params = [context];

			//self._executeSql("SELECT * FROM sdata_meta where context = ?", params)
			self._executeSql("SELECT * FROM sdata_meta")
				.then(function(result) {
					var ret = [];
					try {
						for (var i = 0; i < result.rows.length; i++) {
							var item = result.rows.item(i);
							if (opts.$collection.test(item.collection)) {
								if (!opts.$not_read_since || item.last_read < opts.$not_read_since) {
									ret.push({
										$context: opts.$context,
										$collection: item.collection,
										$endpoint: item.endpoint,
										$key: item.key
									});
								}
							}
						}
						$.smForEachPromise(ret, function(item) {
							return self.remove(item);
						}).then(function() {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
						}).fail(function(e) {
							deferred.reject(e);
						});
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				}).fail(function(status) {
					deferred.reject(status);
				});
		} catch (e) {
			deferred.reject(storageInterface.buildErrResult("error reading from database", e));
		} finally {
			return deferred.promise();
		}
	},

	computeCollectionSize: function(opts) {
		var deferred = $.Deferred();
		var self = this;
		try {
			var db = self.db;
			log && log("CHECK SIZE: ", JSON.stringify(opts));

			if (!opts.$collection || !opts.$context)
				throw new Error("Insufficient parameters");

			var context = JSON.stringify(opts.$context);
			var params = [context];
			//self._executeSql("SELECT * FROM sdata_meta where context = ?", params)
			self._executeSql("SELECT m.collection, m.endpoint, m.key, m.last_read, d.data FROM sdata_meta m INNER JOIN sdata_objects d ON (d.id = m.id)")
				.then(function(result) {
					var returnData = {
						numRecords: 0,
						sizeRecords: 0
					};
					var ret = [];
					try {
						for (var i = 0; i < result.rows.length; i++) {
							var item = result.rows.item(i);
							if (opts.$collection.test(item.collection)) {
								if (!opts.$not_read_since || item.last_read < opts.$not_read_since) {
									returnData.numRecords++;
									returnData.sizeRecords += item.data.length;
								}
							}
						}
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, returnData));
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				}).fail(function(status) {
					deferred.reject(status);
				});
		} catch (e) {
			deferred.reject(storageInterface.buildErrResult("error reading from database", e));
		} finally {
			return deferred.promise();
		}
	},

	_readMetaData: function(context, params, noUpdate) {
		var deferred = $.Deferred();
		var self = this;
		try {
			var db = self.db;
			self._executeSql("SELECT * FROM sdata_meta where key = ? and collection = ? and endpoint = ? and context = ?", params)
				.then(function(result) {
					try {
						if (result.rows.length <= 0) {
							deferred.resolve(null);
						} else {
							var item = result.rows.item(0);
							var metaData = {
								$key: item.key,
								$collection: item.collection,
								$endpoint: item.endpoint,
								$context: item.context,
								$id: item.id,
								$etag: item.etag,
								$lastRead: item.last_read,
								$lastUpdated: item.last_updated
							};
							log && log("Read meta data: " + JSON.stringify(metaData));
							if (noUpdate === true) {
								deferred.resolve(metaData);
							} else {
								self._writeMetaData(metaData)
									.then(function() {
										// allways resolve and ignore errors
										deferred.resolve(metaData);
									}).fail(function(e) {
										deferred.reject(storageInterface.buildErrResult("error reading from database", e));
									});
							}
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				}).fail(function(status) {
					deferred.reject(status);
				});
		} catch (e) {
			deferred.reject(storageInterface.buildErrResult("error reading from database", e));
		} finally {
			return deferred.promise();
		}
	},

	_writeMetaData: function(metaData) {
		var deferred = $.Deferred();
		var self = this;
		try {
			var db = self.db;
			metaData.$lastRead = utils.getCurISODateTime();
			if (!metaData.$id) {
				metaData.$id = utils.UUID();

				self._executeSql("INSERT INTO sdata_meta (key, collection, endpoint, context, id, etag, last_read, last_updated) values (?, ?, ?, ?, ?, ?, ?, ?)", [
					metaData.$key,
					metaData.$collection,
					metaData.$endpoint,
					JSON.stringify(metaData.$context),
					metaData.$id,
					metaData.$etag,
					metaData.$lastRead,
					metaData.$lastUpdated
				])
					.then(function() {
						deferred.resolve(metaData);
					}).fail(function(status) {
						deferred.reject(status);
					});
			} else {
				self._executeSql("UPDATE sdata_meta set etag = ?, last_read = ?, last_updated = ? where id = ?", [metaData.$etag, metaData.$lastRead, metaData.$lastUpdated, metaData.$id])
					.then(function(result) {
						deferred.resolve(metaData);
					}).fail(function(status) {
						deferred.reject(status);
					});
			}
		} catch (e) {
			deferred.reject(storageInterface.buildErrResult("error writing meta data", e));
		} finally {
			return deferred.promise();
		}
	},

	_removeMetaData: function(context, params) {
		var deferred = $.Deferred();
		var self = this;
		try {
			self._readMetaData(context, params, true)
				.then(function(metaData) {
					if (!metaData) {
						deferred.resolve(null);
					} else {
						self._executeSql("DELETE FROM sdata_meta where id = ?", [metaData.$id])
							.then(function() {
								deferred.resolve(metaData);
							}).fail(function(status) {
								deferred.reject(status);
							});
					}
				}).fail(function(status) {
					deferred.reject(status);
				});
		} catch (e) {
			deferred.reject(storageInterface.buildErrResult("error reading from database", e));
		} finally {
			return deferred.promise();
		}
	}
};

exports.members = _members;
exports.tables = _tables;