"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var Base = require('syracuse-tablet/html/js/storage/storageIndexedDBDrafts').Klass;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("templates", false);

var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
var IDBDatabaseException = window.IDBDatabaseException || window.webkitIDBDatabaseException;

var READ_ONLY = (IDBTransaction && IDBTransaction.READ_ONLY) || "readonly";
var READ_WRITE = (IDBTransaction && IDBTransaction.READ_WRITE) || "readwrite";


var _objectStores = {
	"edittemplates": {
		"options": {
			"keyPath": "id",
			"autoIncrement": true
		},
		"indexes": {
			"repandep": {
				"key": ["representation", "endpoint"],
				"options": {
					"unique": false
				}
			}
		}
	}
};

var _logError = function(who, e) {
	if (!log) return;
	log("INDEXED DB - ERROR");
	for (var i = 0; i < arguments.length; i++) {
		var e = arguments[i];
		if (typeof e === "string") {
			log(e);
			continue;
		}
		if (e && e.target) {
			if (IDBDatabaseException && e.target.errorCode != IDBDatabaseException.NOT_FOUND_ERR) {
				log(JSON.stringify(e, null, 2));
				continue;
			}
		}
		log(JSON.stringify(jsutils.convertToDiagnoses(e), null, 2));
	}
};

exports.Klass = utils.defineClass(
	function() {
		Base.call(this);
	},
	Base, {
		/** Overridden method */
		getObjectStores: function() {
			return $.extend(Base.prototype.getObjectStores.call(this), _objectStores);
		},

		/** !! Methods below are private - Use a dedicated name specific to the class - Not shared with drafts or sdata*/
		_tmplOnError: function(deferred, event, fail, value, caller) {
			_logError(caller, event);
			if (fail) {
				deferred.reject({
					$diagnoses: [{
						$message: "IndexedDB Error - " + caller,
						$stackTrace: this._eventToMessage(event)
					}]
				});
			} else {
				deferred.resolve(value);
			}
		},
		/**
		 * Resolves with object store or reject
		 * Needs to be synchronous (don't use deferred) (IE, FF) 
		 */
		_tmplObjectStore: function(readOpt) {
			var tx = this.db.transaction("edittemplates", readOpt || READ_WRITE);
			tx.oncomplete = function(event) {
				log && log("tx.oncomplete", JSON.stringify(event, null, 2));
			};
			tx.onerror = function(event) {
				log && log("tx.onerror", JSON.stringify(event, null, 2));
			};
			return tx.objectStore("edittemplates");
		},
		/**
		 * Resolves with data if record identified by id or null
		 * fail = true to reject if error
		 */
		_tmplGetObject: function(id, fail) {
			var self = this;
			return $.smResolve().then(function() {
				var deferred = $.Deferred();
				var request = self._tmplObjectStore(READ_ONLY).get(id);
				request.onsuccess = function(event) {
					deferred.resolve(request.result);
				};
				request.onerror = function(event) {
					self._tmplOnError(deferred, event, fail, null, "_tmplGetObject");
				};
				return deferred.promise();
			})
		},
		/**
		 * Resolves with and array of all records or []
		 * fail = true to reject if error
		 */
		_tmplGetAllObjects: function(fail, filter) {
			var self = this;
			return $.smResolve().then(function() {
				var deferred = $.Deferred();
				var request = self._tmplObjectStore(READ_ONLY).openCursor();
				var result = [];
				request.onsuccess = function(event) {
					var cursor = event.target.result;
					if (cursor) {
						if (cursor.value && (filter == null || filter(cursor.value) === true)) {
							result.push(cursor.value);
						}
						cursor.continue();
					} else {
						deferred.resolve(result);
					}
				};
				request.onerror = function(event) {
					self._tmplOnError(deferred, event, fail, [], "_tmplGetAllObjects");
				};
				return deferred.promise();
			})
		},
		/**
		 * Create a record of update the existing one if any
		 * Resolves with data  and true if record has been created
		 * fail = true to reject if error
		 */
		_tmplPutObject: function(data, updateDate, fail) {
			var self = this;
			return $.smResolve().then(function() {
				if (!data || !data.id) {
					if (fail) {
						return $.smReject({
							$diagnoses: [{
								$message: "_tmplPutObject - Invalid parameters"
							}]
						});
					}
					return null;
				}
				var deferred = $.Deferred();
				var id = data.id;
				var objectStore = self._tmplObjectStore(READ_WRITE);
				var _put = function(created) {
					data = $.extend(true, {}, data);
					if (data["creation_date"] == null || updateDate) {
						data["creation_date"] = utils.getCurISODateTime(new Date());
					}
					var request = objectStore.put(data);
					request.onsuccess = function(event) {
						deferred.resolve(data, created);
					};
					request.onerror = function(event) {
						self._tmplOnError(deferred, event, fail, null, "_tmplPutObject");
					};
				};
				// Just to return created or updated
				var request = objectStore.get(id);
				request.onsuccess = function(event) {
					_put(true);
				};
				request.onerror = function(event) {
					_put(false);
				};
				return deferred.promise();
			});
		},
		/**
		 * Delete a record if any
		 * Resolves with true (deleted) or false (no record deleted)
		 * fail = true to reject if error
		 */
		_tmplDeleteObject: function(id, fail) {
			var self = this;
			return $.smResolve().then(function() {
				var deferred = $.Deferred();
				var request = self._tmplObjectStore(READ_WRITE)["delete"](id);
				request.onsuccess = function(event) {
					deferred.resolve(true);
				};
				request.onerror = function(event) {
					self._tmplOnError(deferred, event, fail, false, "_tmplDeleteObject");
				};
				return deferred.promise();
			});
		},
		/**
		 * Delete all records
		 * Resolves with true (deleted) or false (no record deleted)
		 * fail = true to reject if error
		 */
		_tmplDeleteAllObjects: function(id, fail) {
			var self = this;
			return $.smResolve().then(function() {
				var deferred = $.Deferred();
				var request = self._tmplObjectStore(READ_WRITE).clear();
				request.onsuccess = function(event) {
					deferred.resolve(true);
				};
				request.onerror = function(event) {
					self._tmplOnError(deferred, event, fail, false, "_tmplDeleteAllObjects");
				};
				return deferred.promise();
			});
		},
		/**
		 * Count all records
		 * Resolves with count
		 * fail = true to reject if error
		 */
		_tmplCountAllObjects: function(fail) {
			var self = this;
			return $.smResolve().then(function() {
				var deferred = $.Deferred();
				var request = self._tmplObjectStore(READ_ONLY).count();
				request.onsuccess = function(event) {
					deferred.resolve(request.result);
				};
				request.onerror = function(event) {
					self._tmplOnError(deferred, event, fail, 0, "_tmplCountAllObjects");
				};
				return deferred.promise();
			});
		},
		_tmplReadInfo: function(data) {
			if (!data) return null;
			try {
				return {
					"id": data.id,
					"endpoint": data.endpoint || "",
					"representation": data.representation || "",
					"title": data.title || "",
					"dataSet": data.dataSet,
					"creation_date": data["creation_date"]
				};
			} catch (e) {
				log && log("_tmplReadInfo", "KO", data.id);
				return null;
			}
		},
		/**
		 * Resolve with [resources]/[] or reject with a exception
		 * Not supported by IE
		 */
		_tmplQueryWidthCompoundIndex: function(representation, endpoint, fail) {
			var self = this;
			return $.smResolve().then(function() {
				var deferred = $.Deferred();
				var objectStore = self._tmplObjectStore(READ_ONLY);
				var request;
				if (representation || endpoint) {
					var index = objectStore.index('repandep');
					request = index.openCursor(IDBKeyRange.only([representation, endpoint]));
				} else {
					request = objectStore.openCursor();
				}
				var result = [],
					data;
				request.onsuccess = function(event) {
					var cursor = event.target.result;
					if (cursor && cursor.value) {
						result.push(cursor.value);
						cursor.continue();
					} else {
						log && log("_tmplQuery - OK");
						deferred.resolve(result);
					}
				};
				request.onerror = function(event) {
					self._tmplOnError(deferred, event, fail, [], "_tmplGetAllObjects");
				};
				return deferred.promise();
			});
		},
		/**
		 * Resolve with [resources]/[] or reject with a exception
		 */
		_tmplQuery: function(representation, endpoint, fail) {
			return this._tmplGetAllObjects(fail, function(value) {
				if (representation != null && representation != value.representation) return false;
				if (endpoint != null && endpoint != value.endpoint) return false;
				return true;
			});
		},
		/**
		 * Resolve with data/null or reject with a exception
		 */
		_tmplRead: function(id) {
			return this._tmplGetObject(id, false);
		},
		/**
		 * Resolve or reject with a exception
		 */
		_tmplUpdate: function(id, ctx) {
			var self = this;
			return self._tmplRead(id).then(function(result) {
				if (!result || !ctx) return;
				return self._tmplSave($.extend(result, ctx), false);
			});
		},
		/**
		 * Resolve or reject with a exception
		 */
		_tmplDelete: function(id) {
			return this._tmplDeleteObject(id, false);
		},
		/**
		 * Resolve or reject with a exception
		 */
		_tmplDeleteAll: function() {
			return this._tmplDeleteAllObjects(false);
		},
		/**
		 * Resolve with template context or reject with an exception
		 */
		_tmplSave: function(ctx, updateDate) {
			var self = this;
			if (!ctx || !ctx.id) {
				log && log("_tmplSave error", "Invalid parameters");
				return $.smReject(new Error("Invalid parameters"));
			}
			return self._tmplDelete(ctx.id).then(function() {
				return self._tmplPutObject(ctx, updateDate, false);
			}).then(function() {
				log && log("_tmplSave", ctx.id, "OK");
				return ctx;
			}).fail(function(status) {
				_logError("_tmplSave", status);
				return $.smReject(status.$exception || new Error(status.message));
			});
		},
		_tmplCount: function() {
			return this._tmplCountAllObjects();
		},
		templateOperation: function(op) {
			switch (op) {
				case "save":
					return this._tmplSave(arguments[1], true);
				case "delete":
					return this._tmplDelete(arguments[1]);
				case "deleteAll":
					return this._tmplDeleteAll(arguments[1], arguments[2]);
				case "read":
					return this._tmplRead(arguments[1]);
				case "update":
					return this._tmplUpdate(arguments[1], arguments[2]);
				case "query":
					return this._tmplQuery(arguments[1], arguments[2], arguments[3]);
				case "readall":
					return this._tmplQuery(arguments[1]);
				case "count":
					return this._tmplCount();
				default:
					return $.smReject(storageInterface.buildErrResult("Unknown template operation[" + op + "]"));
			}
		}
	});