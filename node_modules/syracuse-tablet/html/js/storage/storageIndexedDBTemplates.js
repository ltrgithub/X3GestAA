"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var Base = require('syracuse-tablet/html/js/storage/storageIndexedDBDrafts').Klass;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("templates", true);

var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
var IDBDatabaseException = window.IDBDatabaseException || window.webkitIDBDatabaseException;

var READ_ONLY = (IDBTransaction && IDBTransaction.READ_ONLY) || "readonly";
var READ_WRITE = (IDBTransaction && IDBTransaction.READ_WRITE) || "readwrite";


var _objectStores = {
	"edittemplates": {
		"options": {
			"keyPath": "id",
			"autoIncrement": true
		},
		"indexes": {
			"repandep": {
				"key": ["representation", "endpoint"],
				"options": {
					"unique": false
				}
			}
		}
	}
};

var _logError = function(who, e) {
	if (!log) return;
	log("INDEXED DB - ERROR");
	for (var i = 0; i < arguments.length; i++) {
		var e = arguments[i];
		if (typeof e === "string") {
			log(e);
			continue;
		}
		if (e && e.target) {
			if (e.target.errorCode != IDBDatabaseException.NOT_FOUND_ERR) {
				log(JSON.stringify(e, null, 2));
				continue;
			}
		}
		log(JSON.stringify(jsutils.convertToDiagnoses(e), null, 2));
	}
};

var _Klass = utils.defineClass(
	function() {
		Base.call(this);
	},
	Base, {

		_onError: function(deferred, event, fail, value, caller) {
			_logError(caller, event);
			if (fail) {
				deferred.reject({
					$diagnoses: [{
						$message: "IndexedDB Error - " + caller,
						$stackTrace: this._eventToMessage(event)
					}]
				});
			} else {
				deferred.resolve(value);
			}
		},
		_onExcep: function(deferred, fail, e, value) {
			if (fail) {
				deferred.reject(e);
			} else {
				deferred.resolve(value);
			}
		},
		getObjectStores: function() {
			return $.extend(Base.prototype.getObjectStores.call(this), _objectStores);
		},
		/**
		 * Resolves with object store or rejects
		 */
		_objectStore: function(readOpt) {
			var self = this;
			var deferred = $.Deferred();
			try {
				var tx = self.db.transaction("edittemplates", readOpt || READ_WRITE);
				tx.oncomplete = function(event) {
					log && log("tx.oncomplete", JSON.stringify(event, null, 2));
				};
				tx.onerror = function(event) {
					log && log("tx.onerror", JSON.stringify(event, null, 2));
				};
				deferred.resolve(tx.objectStore("edittemplates"));
			} catch (e) {
				_logError('_objectStore', e);
				deferred.reject(e);
			}
			return deferred.promise();
		},
		/**
		 * Resolves with data if record identified by id or null
		 * fail = true to reject if error
		 */
		_getObject: function(id, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._objectStore(READ_ONLY).then(function(objectStore) {
				var request = objectStore.get(id);
				request.onsuccess = function(event) {
					deferred.resolve(request.result);
				};
				request.onerror = function(event) {
					self._onError(deferred, event, fail, null, "_getObject");
				};
			}).fail(function(e) {
				self._onExcep(deferred, fail, e, null);
			});
			return deferred.promise();
		},
		/**
		 * Resolves with and array of all records or []
		 * fail = true to reject if error
		 */
		_getAllObjects: function(fail) {
			var self = this;
			var deferred = $.Deferred();
			self._objectStore(READ_ONLY).then(function(objectStore) {
				var request = objectStore.openCursor();
				var result = [],
					data;
				request.onsuccess = function(event) {
					var cursor = event.target.result;
					if (cursor) {
						if (cursor.value) {
							result.push(cursor.value);
						}
						cursor.continue ();
					} else {
						deferred.resolve(result);
					}
				};
				request.onerror = function(event) {
					self._onError(deferred, event, fail, [], "_getAllObjects");
				};
			}).fail(function(e) {
				self._onExcep(deferred, fail, e, []);
			});
			return deferred.promise();
		},
		/**
		 * Create a record of update the existing one if any
		 * Resolves with data  and true if record has been created
		 * fail = true to reject if error
		 */
		_putObject: function(data, updateDate, fail) {
			var self = this;
			var deferred = $.Deferred();
			if (!data || !data.id) {
				if (fail) {
					deferred.reject({
						$diagnoses: [{
							$message: "_putObject - Invalid parameters"
						}]
					});
				} else {
					deferred.resolve(null);
				}
			} else {
				var id = data.id;
				self._objectStore(READ_WRITE).then(function(objectStore) {
					var _put = function(created) {
						data = $.extend(true, {}, data);
						if (data["creation_date"] == null || updateDate) {
							data["creation_date"] = utils.getCurISODateTime(new Date());
						}
						var request = objectStore.put(data);
						request.onsuccess = function(event) {
							deferred.resolve(data, created);
						};
						request.onerror = function(event) {
							self._onError(deferred, event, fail, null, "_putObject");
						};
					};
					// Just to return created or updated
					var request = objectStore.get(id);
					request.onsuccess = function(event) {
						_put(true);
					};
					request.onerror = function(event) {
						_put(false);
					};
				}).fail(function(e) {
					self._onExcep(deferred, fail, e, null);
				});
			}
			return deferred.promise();
		},
		/**
		 * Delete a record if any
		 * Resolves with true (deleted) or false (no record deleted)
		 * fail = true to reject if error
		 */
		_deleteObject: function(id, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._objectStore(READ_WRITE).then(function(objectStore) {
				var request = objectStore["delete"](id);
				request.onsuccess = function(event) {
					deferred.resolve(true);
				};
				request.onerror = function(event) {
					self._onError(deferred, event, fail, false, "_deleteObject");
				};
			}).fail(function(e) {
				self._onExcep(deferred, fail, e, false);
			});
			return deferred.promise();
		},
		/**
		 * Delete all records
		 * Resolves with true (deleted) or false (no record deleted)
		 * fail = true to reject if error
		 */
		_deleteAllObjects: function(id, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._objectStore(READ_WRITE).then(function(objectStore) {
				var request = objectStore.clear();
				request.onsuccess = function(event) {
					deferred.resolve(true);
				};
				request.onerror = function(event) {
					self._onError(deferred, event, fail, false, "_deleteAllObjects");
				};
			}).fail(function(e) {
				self._onExcep(deferred, fail, e, false);
			});
			return deferred.promise();
		},
		/**
		 * Count all records
		 * Resolves with count
		 * fail = true to reject if error
		 */
		_countAllObjects: function(fail) {
			var self = this;
			var deferred = $.Deferred();
			self._objectStore(READ_ONLY).then(function(objectStore) {
				var request = objectStore.count();
				request.onsuccess = function(event) {
					deferred.resolve(request.result);
				};
				request.onerror = function(event) {
					self._onError(deferred, event, fail, 0, "_countAllObjects");
				};
			}).fail(function(e) {
				self._onExcep(deferred, fail, e, 0);
			});
			return deferred.promise();
		},
		_tmplReadInfo: function(data) {
			if (!data) return null;
			try {
				return {
					"id": data.id,
					"endpoint": data.endpoint || "",
					"representation": data.representation || "",
					"title": data.title || "",
					"dataSet": data.dataSet,
					"creation_date": data["creation_date"]
				};
			} catch (e) {
				log && log("_tmplReadInfo", "KO", data.id);
				return null;
			}
		},
		/**
		 * Resolve with [resources]/[] or reject with a exception
		 */
		_tmplQuery: function(representation, endpoint, fail) {
			var self = this;
			var deferred = $.Deferred();
			self._objectStore(READ_ONLY).then(function(objectStore) {
				var request;
				if (representation || endpoint) {
					var index = objectStore.index('repandep');
					request = index.openCursor(IDBKeyRange.only([representation, endpoint]));
				} else {
					request = objectStore.openCursor();
				}
				var result = [],
					data;
				request.onsuccess = function(event) {
					var cursor = event.target.result;
					if (cursor && cursor.value) {
						result.push(cursor.value);
						cursor.continue ();
					} else {
						log && log("_tmplQuery - OK");
						deferred.resolve(result);
					}
				};
				request.onerror = function(event) {
					self._onError(deferred, event, fail, [], "_getAllObjects");
				};
			}).fail(function(e) {
				self._onExcep(deferred, fail, e, []);
			});
			return deferred.promise();
		},
		/**
		 * Resolve with data/null or reject with a exception
		 */
		_tmplRead: function(id) {
			return this._getObject(id, false);
		},
		/**
		 * Resolve or reject with a exception
		 */
		_tmplUpdate: function(id, ctx) {
			var self = this;
			return self._tmplRead(id).then(function(result) {
				if (!result || !ctx) return;
				return self._tmplSave($.extend(result, ctx), false);
			});
		},
		/**
		 * Resolve or reject with a exception
		 */
		_tmplDelete: function(id) {
			return this._deleteObject(id, false);
		},
		/**
		 * Resolve or reject with a exception
		 */
		_tmplDeleteAll: function() {
			return this._deleteAllObjects(false);
		},
		/**
		 * Resolve with template context or reject with an exception
		 */
		_tmplSave: function(ctx, updateDate) {
			var self = this;
			var deferred = $.Deferred();
			if (!ctx || !ctx.id) {
				log && log("_tmplSave error", "Invalid parameters");
				deferred.reject(new Error("Invalid parameters"));
			} else {
				self._tmplDelete(ctx.id).then(function() {
					return self._putObject(ctx, updateDate, false);
				}).then(function() {
					log && log("_tmplSave", ctx.id, "OK");
					deferred.resolve(ctx);
				}).fail(function(status) {
					_logError("_tmplSave", status);
					deferred.reject(status.$exception || new Error(status.message));
				});
			}
			return deferred.promise();
		},
		_tmplCount: function() {
			return this._countAllObjects();
		},
		templateOperation: function(op) {
			switch (op) {
				case "save":
					return this._tmplSave(arguments[1], true);
				case "delete":
					return this._tmplDelete(arguments[1]);
				case "deleteAll":
					return this._tmplDeleteAll(arguments[1], arguments[2]);
				case "read":
					return this._tmplRead(arguments[1]);
				case "update":
					return this._tmplUpdate(arguments[1], arguments[2]);
				case "query":
					return this._tmplQuery(arguments[1], arguments[2], arguments[3]);
				case "readall":
					return this._tmplQuery(arguments[1]);
				case "count":
					return this._tmplCount();
				default:
					return $.smReject(storageInterface.buildErrResult("Unknown template operation[" + op + "]"));
			}
		}
	});

exports.Klass = _Klass;