"use strict";

/*
 * WebSQL storage interface (Chrome, Safari)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var Base = storageInterface.Klass;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("webSQL");
//Increase this number to upgrade database to schema described in _objectStores
var _databaseVersion = 19;
var _databaseSize = 2 * 1024 * 1024;

var _Klass = utils.defineClass(
	function() {
		Base.call(this, "WebSQL storage interface", _databaseVersion);
		this.databaseSize = _databaseSize;
	},
	Base, {
		init: function() {
			var deferred = $.Deferred();
			var self = this;
			var useTestDatabase = globals.isTestEnvironment();
			self.databaseName = storageInterface.databaseName + "-test";
			self.useTestDatabase = useTestDatabase;
			try {
				self._openDB().then(function(status) {
					deferred.resolve(status);
				}).fail(function(status) {
					deferred.reject(status);
				});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error initializing database", e));
			} finally {
				return deferred.promise();
			}
		},
		/**
		 * Returns the tables to create
		 */
		getTables: function() {
			return {};
		},
		_executeSql: function(sql, params) {
			var deferred = $.Deferred();
			var self = this;
			try {
				self.db.transaction(function(tx) {
					try {
						log && log("SQL: " + sql);
						log && log(params);
						tx.executeSql(sql, params, function(tx, result) {
							deferred.resolve(result);
						}, function(tx, error) {
							deferred.reject(storageInterface.buildErrResult("DB error initializing database: " + self.sqlErrorToMessage(error)));
						});
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error running SQL statement", e));
					}
				}, function(error) {
					deferred.reject(storageInterface.buildErrResult("DB transaction error: " + self.sqlErrorToMessage(error) + ". Try to reload the page"));
				});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error running SQL statement", e));
			}
			return deferred.promise();
		},

		/*
		 *
		 * Database migration functions
		 *
		 */
		_openDB: function() {
			var deferred = $.Deferred();
			var self = this;
			if (self.useTestDatabase === false && self.db) {
				deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
			}
			var request;
			try {
				log && log("Open database, request version: " + self.databaseVersion);
				self.db = openDatabase(self.databaseName, 7, 'Database', self.databaseSize);
				self._readCurrentVersion().then(function(version) {
					log && log("Current version: " + version);
					// In test framework create DB every time
					if (version === self.databaseVersion && self.useTestDatabase !== true) {
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
					} else {
						self._createTables().then(function(status) {
							return self._writeCurrentVersion();
						}).then(function(status) {
							deferred.resolve(status);
						}).fail(function(status) {
							deferred.reject(status);
						});
					}
				}).fail(function(status) {
					deferred.reject(status);
				});

			} catch (e) {
				log && log("Open database, exception", e);
				self.db = null;
				deferred.reject(storageInterface.buildErrResult("error initializing database", e));
			}

			return deferred.promise();
		},
		_readCurrentVersion: function() {
			var deferred = $.Deferred();
			var self = this;
			self._executeSql('SELECT version FROM version', null).then(function(result) {
				try {
					var len = result.rows.length;
					if (len === 1) {
						var version = result.rows.item(0).version;
						log && log("Read version: " + version);
						deferred.resolve(+version);
					}
					deferred.resolve(-1);
				} catch (e) {
					deferred.reject(storageInterface.buildErrResult("error reading database version", e));
				}
			}).fail(function(status) {
				// Asume table does not exist, create it
				log && log("Creating version table");
				self._executeSql('CREATE TABLE version (version TEXT)').then(function(status) {
					deferred.resolve(-1);
				}).fail(function(status) {
					globals.getModal().error("Error Creating version table", status, function() {
						deferred.reject(status);
					});
				});
			});
			return deferred.promise();
		},
		_writeCurrentVersion: function() {
			var deferred = $.Deferred();
			var self = this;
			self._executeSql('DELETE FROM version', null)
				.then(function(result) {
					return self._executeSql('INSERT INTO version (version) values (?)', [_databaseVersion]);
				})
				.then(function(status) {
					deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
				}).fail(function(status) {
					deferred.reject(status);
				});
			return deferred.promise();
		},
		_createTables: function() {
			var deferred = $.Deferred();
			var self = this;
			var p = [];
			var errors = [];
			var nbExec = 0;
			var tables = this.getTables();
			// FDB - Redid this way because the old implementation with $.when() didn't bubble up errors rejected to the main process
			for (var name in tables) {
				nbExec += tables[name].length;
			}
			for (var name in tables) {
				tables[name].forEach(function(descr) {
					self._executeSql(descr).then(function() {
						nbExec--;
						if (nbExec === 0) {
							if (errors.length > 0) {
								deferred.reject(errors.join('\n'));
							} else {
								deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
							}
						}
					}, function(status) {
						nbExec--;
						errors.push(status.$message);
						if (nbExec === 0) {
							deferred.reject(errors.join('\n'));
						}
					});
				});
			};
			return deferred.promise();
		},
		sqlErrorToMessage: function(error) {
			return "CODE: " + error.code + " MESSAGE: " + error.message;
		}
	}
);

exports.Klass = _Klass;