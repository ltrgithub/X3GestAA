"use strict";

/*
 * WebSQL storage interface (Chrome, Safari)
 */
var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var Base = storageInterface.Klass;
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("webSQL", false);

//Increase this number to upgrade database to schema described in _objectStores
var _databaseVersion = 23;
var _databaseSize = 2 * 1024 * 1024;

exports.Klass = utils.defineClass(
	function() {
		Base.call(this, "WebSQL storage interface", _databaseVersion);
		this.databaseSize = _databaseSize;
	},
	Base, {
		init: function() {
			var deferred = $.Deferred();
			var self = this;
			$.smResolve().then(function() {
				self.useTestDatabase = jsutils.isTestEnvironment();
				self.databaseName = storageInterface.databaseName + (self.useTestDatabase ? "-test" : "");
				if (self.useTestDatabase === false && self.db) {
					return $.smResolve(storageInterface.StatusCodes.OK);
				} else {
					return self._openDB();
				}
			}).then(function(status) {
				deferred.resolve(status);
			}).fail(function(e) {
				log && log("Open database exception", JSON.stringify(storageInterface.buildErrResult(e), null, 2));
				var msg = locale.text("db.err.init");
				var diags;
				if (jsutils.isError(e) || jsutils.isDOMException(e)) {
					var diags = jsutils.convertToDiagnoses(e);
					diags.$diagnoses[0].$message = msg;
				} else {
					diags = storageInterface.buildErrResult(msg, e);
				}
				deferred.reject(diags);
			});
			return deferred.promise();
		},
		_openDB: function() {
			var self = this;
			return $.smResolve().then(function() {
				var request;
				log && log("Open database, request version: " + self.databaseVersion);
				self.db = openDatabase(self.databaseName, 7, 'Database', self.databaseSize);
				return self._readCurrentVersion().then(function(version) {
					log && log("Current version: " + version);
					// In test framework create DB every time
					if (version === self.databaseVersion && self.useTestDatabase !== true) {
						return storageInterface.StatusCodes.OK;
					} else {
						return self._createTables().then(function(status) {
							return self._writeCurrentVersion();
						});
					}
				});
			});
		},
		_writeCurrentVersion: function() {
			var self = this;
			var deferred = $.Deferred();
			self._executeSql('DELETE FROM version', null).then(function(result) {
				return self._executeSql('INSERT INTO version (version) values (?)', [_databaseVersion]).then(function(status) {
					deferred.resolve(status);
				});
			}).fail(function(e) {
				log && log("_writeCurrentVersion exception", JSON.stringify(storageInterface.buildErrResult(e), null, 2));
				deferred.reject(storageInterface.buildErrResult("writeCurrentVersion", e));
			});
			return deferred.promise();
		},
		/**
		 * Returns the tables to create
		 */
		getTables: function() {
			return {};
		},
		_executeSql: function(sql, params) {
			var deferred = $.Deferred();
			var self = this;
			try {
				self.db.transaction(function(tx) {
					try {
						log && log("SQL: " + sql);
						log && log(params);
						tx.executeSql(sql, params, function(tx, result) {
							deferred.resolve(result);
						}, function(tx, error) {
							deferred.reject(storageInterface.buildErrResult("DB error initializing database: " + self.sqlErrorToMessage(error, sql, params)));
						});
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error running SQL statement", e));
					}
				}, function(error) {
					deferred.reject(storageInterface.buildErrResult("DB transaction error: " + self.sqlErrorToMessage(error, sql, params) + ". Try to reload the page"));
				});
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error running SQL statement", e));
			}
			return deferred.promise();
		},
		_readCurrentVersion: function() {
			var deferred = $.Deferred();
			var self = this;
			self._executeSql('SELECT version FROM version', null).then(function(result) {
				try {
					var len = result.rows.length;
					if (len === 1) {
						var version = result.rows.item(0).version;
						log && log("Read version: " + version);
						deferred.resolve(+version);
					}
					deferred.resolve(-1);
				} catch (e) {
					deferred.reject(storageInterface.buildErrResult("error reading database version", e));
				}
			}).fail(function(e1) {
				// Assume table does not exist, create it
				log && log("Creating version table");
				self._executeSql('CREATE TABLE version (version TEXT)').then(function(status) {
					deferred.resolve(-1);
				}).fail(function(e2) {
					log && log("Error creating version table", JSON.stringify(storageInterface.buildErrResult(e2), null, 2));
					deferred.reject(storageInterface.buildErrResult("error reading database version", e1));
				});
			});
			return deferred.promise();
		},
		_createTables: function() {
			var deferred = $.Deferred();
			var self = this;
			var p = [];
			var errors = [];
			var nbExec = 0;
			var tables = this.getTables();
			// FDB - Redid this way because the old implementation with $.when() didn't bubble up errors rejected to the main process
			for (var name in tables) {
				nbExec += tables[name].length;
			}
			for (var name in tables) {
				tables[name].forEach(function(descr) {
					self._executeSql(descr).then(function() {
						nbExec--;
						if (nbExec === 0) {
							if (errors.length > 0) {
								deferred.reject(storageInterface.buildErrResult("Error creating database tables", errors.join('\n')));
							} else {
								deferred.resolve(storageInterface.StatusCodes.OK);
							}
						}
					}, function(status) {
						nbExec--;
						errors.push(status.$message);
						if (nbExec === 0) {
							deferred.reject(storageInterface.buildErrResult("Error creating database tables", errors.join('\n')));
						}
					});
				});
			};
			return deferred.promise();
		},
		sqlErrorToMessage: function(error, sql, params) {
			if (log) {
				var e = {};
				for (var p in error) {
					if (typeof error[p] === "function") continue;
					if (error[p] == "object" && (!Array.isArray(error[p]) || !$.isPlainObject(error[p]))) continue;
					e[p] = error[p];
				}
				log && log("ERROR REQUEST:", sql);
				log && log("ERROR PARAMS:", params);
				log && log(JSON.stringify(e, null, 2));
			}
			return "CODE: " + error.code + " MESSAGE: " + error.message;
		},
		// No need because we can clear the cache manually - #7942
		clearDatabaseSupported: function() {
			return false;
		}
	}
);