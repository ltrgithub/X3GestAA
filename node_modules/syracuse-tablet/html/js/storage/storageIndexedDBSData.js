"use strict";

/*
 * IndexDB storage interface (Internet Explorer, Firefox)
 */

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/storage/storageIndexedDBBase').Klass;
var storageInterface = require('syracuse-tablet/html/js/storage/storageInterface');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("sData", false);

var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
var IDBDatabaseException = window.IDBDatabaseException || window.webkitIDBDatabaseException;

var READ_ONLY = (IDBTransaction && IDBTransaction.READ_ONLY) || "readonly";
var READ_WRITE = (IDBTransaction && IDBTransaction.READ_WRITE) || "readwrite";

var _objectStores = {
	"sdata": {
		"options": {
			"autoIncrement": true
		},
		"indexes": {
			"read_write_one": {
				"key": "key_collection_endpoint_context",
				"options": {
					"unique": true
				}
			},
			"read_write_all": {
				"key": "collection_endpoint_context",
				"options": {
					"unique": false
				}
			},
			"read_write_ctx": {
				"key": "context",
				"options": {
					"unique": false
				}
			}
		}
	}
};

var _Klass = utils.defineClass(
	function() {
		Base.call(this);
	},
	Base, {

		getObjectStores: function() {
			var res = Base.prototype.getObjectStores.call(this);
			$.extend(res, _objectStores);
			return res;
		},

		put: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("PUT: ", JSON.stringify(opts));
				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$key, opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_one");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);
				var mustInsert = true;
				var datetime = utils.getCurISODateTime();
				var doInsert = function() {
					var obj = {
						"context": context,
						"collection": opts.$collection,
						"endpoint": opts.$endpoint,
						"key": opts.$key,
						"last_updated": datetime,
						"last_read": datetime,
						"key_collection_endpoint_context": key,
						"collection_endpoint_context": [opts.$collection, opts.$endpoint, context].join("_"),
						"data": opts.$data,
					};
					var reqt = objectStore.add(obj);
					reqt.onerror = function(event) {
						deferred.reject(storageInterface.buildErrResult("error writing to database: " + self._eventToMessage(event)));
					};
					reqt.onsuccess = function(event) {
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
					};
				};
				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							if (opts.$data.$etag) {
								var etag = cr.value && cr.value.data.$etag;
								if (etag === opts.$data.$etag) {
									deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, opts.$data));
									return;
								}
							}
							cr["delete"]();
							cr["continue"]();
						} else {
							doInsert();
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error writing to database", e));
					}
				};
				request.onerror = function(event) {
					if (IDBDatabaseException && event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						doInsert();
					} else {
						deferred.reject(storageInterface.buildErrResult("error writing to database: " + self._eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error writing to database", e));
			} finally {
				return deferred.promise();
			}
		},

		read: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("READ: ", JSON.stringify(opts));
				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");
				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);
				var key = [opts.$key, opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_one");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);

				request.onsuccess = function(event) {
					try {
						var cr = event.target && event.target.result && event.target.result.value;
						if (!cr) {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						} else {
							deferred.resolve(storageInterface.buildResult(
								storageInterface.StatusCodes.OK,
								cr.data,
								null,
								null, {
									$lastRead: cr.last_read,
									$lastUpdated: cr.last_updated
								}));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (IDBDatabaseException && event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						// Resolve since it's a logical issue and not neccessarily an error
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + self._eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		query: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("QUERY: ", JSON.stringify(opts));
				if (!opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_all");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);
				var results = [];
				var meta = [];

				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							var data = cr.value.data;
							results.push(data);
							meta.push({
								$lastRead: cr.value.last_read,
								$lastUpdated: cr.value.last_updated
							});
							cr["continue"]();
						} else {
							deferred.resolve(storageInterface.buildResult(
								storageInterface.StatusCodes.OK,
								results,
								null,
								null,
								meta));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (IDBDatabaseException && event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						// Resolve since it's a logical issue and not neccessarily an error
						deferred.resolve(storageInterface.buildResult(
							storageInterface.StatusCodes.OK,
							results,
							null,
							null,
							meta));
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + self._eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		remove: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("REMOVE: ", JSON.stringify(opts));
				if (!opts.$key || !opts.$collection || !opts.$endpoint || !opts.$context)
					throw new Error("Insufficient parameters");

				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = [opts.$key, opts.$collection, opts.$endpoint, context].join("_");

				var index = objectStore.index("read_write_one");
				var keyRange = IDBKeyRange.only(key);
				var request = index.openCursor(keyRange);

				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							cr["delete"]();
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK));
						} else {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error deleting from database", e));
					}
				};
				request.onerror = function(event) {
					if (IDBDatabaseException && event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						// Resolve since it's a logical issue and not neccessarily an error
						deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.NOT_FOUND));
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + self._eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error deleting from database", e));
			} finally {
				return deferred.promise();
			}
		},

		clearCollection: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("CLEAR: ", JSON.stringify(opts));
				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = context;

				//				var index = objectStore.index("read_write_ctx");
				//				var keyRange = IDBKeyRange.only(key);
				//				var request = index.openCursor(keyRange);
				var request = objectStore.openCursor();

				var records = [];

				var deleteMatches = function() {
					$.smForEachPromise(records, function(rec) {
						return self.remove({
							$context: opts.$context,
							$collection: rec.collection,
							$endpoint: rec.endpoint,
							$key: rec.key
						});
					}).then(function() {
						deferred.resolve();
					}).fail(function(e) {
						deferred.reject(e);
					});
				};
				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							if (opts.$collection.test(cr.value.collection)) {
								if (!opts.$not_read_since || cr.value.last_read < opts.$not_read_since) {
									records.push(cr.value);
								}
							}
							cr["continue"]();
						} else {
							deleteMatches();
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (IDBDatabaseException && event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						deleteMatches();
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + self._eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		},

		computeCollectionSize: function(opts) {
			var deferred = $.Deferred();
			var self = this;
			try {
				var db = self.db;
				log && log("SIZE: ", JSON.stringify(opts));
				var tx = db.transaction(["sdata"], READ_WRITE);
				var objectStore = tx.objectStore("sdata");
				var context = JSON.stringify(opts.$context);

				var key = context;

				//				var index = objectStore.index("read_write_ctx");
				//				var keyRange = IDBKeyRange.only(key);
				//				var request = index.openCursor(keyRange);
				var request = objectStore.openCursor();
				var returnData = {
					numRecords: 0,
					sizeRecords: 0
				};

				request.onsuccess = function(event) {
					try {
						var cr = event.target.result;
						if (cr) {
							if (opts.$collection.test(cr.value.collection)) {
								if (!opts.$not_read_since || cr.value.last_read < opts.$not_read_since) {
									returnData.numRecords++;
									returnData.sizeRecords += JSON.stringify(cr.value).length;
								}
							}
							cr["continue"]();
						} else {
							deferred.resolve(storageInterface.buildResult(storageInterface.StatusCodes.OK, returnData));
						}
					} catch (e) {
						deferred.reject(storageInterface.buildErrResult("error reading from database", e));
					}
				};
				request.onerror = function(event) {
					if (IDBDatabaseException && event.target.errorCode == IDBDatabaseException.NOT_FOUND_ERR) {
						deferred.resolve();
					} else {
						deferred.reject(storageInterface.buildErrResult("error reading from database: " + self._eventToMessage(event)));
					}
				};
			} catch (e) {
				deferred.reject(storageInterface.buildErrResult("error reading from database", e));
			} finally {
				return deferred.promise();
			}
		}
	}
);

exports.Klass = _Klass;