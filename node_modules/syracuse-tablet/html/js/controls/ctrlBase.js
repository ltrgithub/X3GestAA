"use strict";

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/app/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var localeModule = require('syracuse-tablet/html/js/helpers/locale');
var environment = require('syracuse-tablet/html/js/helpers/environment');
var eventListener = require('syracuse-tablet/html/js/app/eventListener');

/**
 * Root base class for controls and layouts (was structElmt before).
 * 
 *
 */
exports.CtrlBase = utils.defineClass(
	function CtrlBase(controller, $type, article, options) {
		this.options = options || {};
		this.controller = controller;
		this.$type = $type;
		this.typeName = utils.getTypeName($type);
		this.article = article || {};
		this.children = null;
		this.parent = null;
		this.destroyed = false;
		this.id = this.createId(this.typeName);
		// Set after creation by ctrlFactory - Property not mandatory
		this.page = null;

		controller.registerControl(this);
	}, null, {
		destroy: function() {
			this.destroyed = true;
			this.page = null;
			if (this.controller) {
				this.controller.unregisterControl(this);
			}
			this.controller = null;
			// First destroy the children before removing $$elmt
			this.destroyChildren();
			notifications.unsubscribe(this);
			if (this.$$elmt) {
				this.$$elmt.unbind();
				this.$$elmt.remove();
				this.$$elmt = null;
			}
			if (this.parent) {
				this.parent.removeChild(this);
				this.parent = null;
			}
		},
		removeChild: function(ctrl) {
			if (!this.children) {
				return;
			}
			var idx = this.children.indexOf(ctrl);
			if (idx > -1) {
				this.children.splice(idx, 1);
			}
		},
		destroyChildren: function() {
			if (!this.children) {
				return;
			}
			for (var i = this.children.length - 1; i >= 0; i--) {
				if (this.children[i]) {
					// destroy removes the child in the parent
					this.children[i].destroy();
				}
			}
			// this.children should be equal to 0
			// We set [] per security because this method can be called by authoring if a control or layout is removed by the user
			this.children = [];
		},
		createId: function(typeName) {
			return utils.readableuid(typeName);
		},

		//
		// START: Rendering
		//
		/**
		 * Set container where html of this control will be placed
		 * Must be called by parent before invoking buildHtml
		 */
		set$$container: function($$container) {
			this.$$container = $$container;
		},
		/**
		 * Each subclass must implement this method to work properly
		 */
		buildHtml: function(classes) {
			throw new Error("Controll does not implement buildHtml");
		},
		/**
		 * Create the root element of the control/layout/vignette
		 * This element is identified by this.id
		 */
		createRootElement: function(classList) {
			if (!this.$$container) {
				throw new Error("No container set for rendering");
			}
			var domElement = uiUtils.createDomElement(this.getRootElementTag(), classList, null, {
				"id": this.id
			});
			var $$elmt = $(domElement);
			this.setRootElement($$elmt, this.$$container);
			if (environment.isAutoUITestMode()) {
				environment.getUnitTestMgr().addBindAttribute(this);
			}
			return $$elmt;
		},
		getRootElementTag: function() {
			return "div";
		},
		/**
		 * 
		 */
		setRootElement: function($$elmt, $$parent) {
			if (!$$parent.jquery) {
				throw new Error("Invalid parent");
			}
			if (!$$elmt.jquery) {
				throw new Error("Invalid root");
			}
			this.$$elmt = $$elmt;
			this.$$elmt.appendTo($$parent);

			if (environment.isAutoUITestMode()) {
				var i = this.getUnitTestId();
				if (i) {
					environment.getUnitTestMgr().addStructElmtId(this.$$elmt, i);
				}
			}
			return this.$$elmt;
		},
		afterRender: function() {
			this.children && this.children.forEach(function(child) {
				child.afterRender();
			});
		},
		//
		// END: Rendering
		//


		//
		// START: Authoring
		//
		/**
		 * Returns field/layout authoring
		 * path: string with or without '.' separator or array of string
		 */
		getAuthoring: function(path, defValue) {
			var val = utils.getPropByPath(this.article, path);
			return val != null ? val : defValue;
		},

		/*
		 * Must return the article of this control/layout node
		 * The article must only contain static authoring.
		 * Dynamic settings that are added by payload must not be part of the returned data structure
		 * since this structure will be used to create the article tree for the page and will
		 * be stored on the server!
		 */
		getArticle: function() {
			return this.article;
		},
		/*
		 * Returns the article used for authoring of this element
		 * Note that sub level informations usually nested in $items MUST NOT be returned here
		 */
		getAuthArticle: function() {
			var authArticle = {};
			var nodeArticle = this.getArticle();
			Object.keys(nodeArticle).forEach(function(key) {
				if (key !== "$items") {
					authArticle[key] = nodeArticle[key];
				}
			});
			return authArticle;
		},

		getAuthState: function(dirtyKeys) {
			return null;
		},
		setAuthState: function(state) {

		},
		//
		// END: Authoring
		//

		isRoot: function() {
			return this.parent == null || this.parent === this.controller;
		},
		isVisible: function() {
			return this.$$elmt && this.$$elmt.is(":visible");
		},
		isHidden: function() {
			return !this.isVisible();
		},
		/**
		 * Set the focus on this field and scroll
		 */
		setFocus: function() {
			// Just make ctrl visible
			this.makeVisible();
			// Focus is set after by CtrlFieldBase which manages inputs fields
		},
		makeVisible: function() {
			if (!this.page || !this.$$elmt) {
				return;
			}
			this.page.makeVisible(this.$$elmt);
		},
		show: function() {
			if (this.$$elmt) {
				this.$$elmt.show();
			}
		},
		hide: function() {
			if (this.$$elmt) {
				this.$$elmt.hide();
			}
		},
		//
		// START: Tree / child management
		//

		/**
		 * Append structElmt c as a child of this
		 */
		appendStructElmt: function(c) {
			if (!c) return;
			if (!this.children) this.children = [];
			c.parent = this;
			this.children.push(c);
		},

		getNbChilds: function() {
			return this.children && this.children.length > 0;
		},

		getIndexOfChild: function(child) {
			var idx = -1;
			this.children && this.children.some(function(c) {
				idx = idx + 1;
				if (c === child) {
					return true;
				}
				return false;
			});
			return idx;
		},
		getChildByIndex: function(idx) {
			return this.children && this.children[idx];
		},

		/*
		 * Add new child before nextChild
		 * If nextChild is null, it's added at the end of the container
		 */
		addChildBefore: function(ctrl, nextChild) {
			var added = false;
			var _children = [];
			this.children && this.children.forEach(function(c) {
				if (nextChild && (c.id === nextChild.id)) {
					_children.push(ctrl);
					added = true;
				}
				if (c.id !== ctrl.id) {
					_children.push(c);
				}
			});

			if (!added) {
				_children.push(ctrl);
			}
			this.children = _children;
		},

		/*
		 * Removes reference to child without destroying the child!
		 */
		removeChildRef: function(c) {
			var _children = [];
			this.children && this.children.forEach(function(child) {
				if (child.id !== c.id) {
					_children.push(child);
				}
			});
			this.children = _children;
		},

		/*
		 * Start by this node and go up the layout tree storing all the indexes of the current not in the parent container
		 */
		getPathInTree: function() {
			var ctrl = this;
			var path = [];
			var parent = this.parent;

			// Special case: this is the root layout of a vignette
			if (parent == null && this.page && this.page.parentVignette) {
				parent = this.page.parentVignette.parent;
				path.push(0);
			}
			// The intention of this function is to stop at root level, not at the first controller found
			// The first controller might be the vignette containing the control, but we want to get the page/dashboard
			// containing the full screen not only a single vignette
			//while (parent && parent != this.controller) {
			while (parent) {
				var idx = parent.getIndexOfChild(ctrl);
				path.push(idx);

				ctrl = parent;
				parent = ctrl.parent;
				if (parent == null && ctrl.page && ctrl.page.parentVignette) {
					path.push(0);
					ctrl = ctrl.page.parentVignette;
					parent = ctrl.parent;
				}
			}
			path.reverse();
			return path;
		},

		/*
		 * Resolve the path generated by getPathInTree to find the children again
		 */
		findChildByPath: function(path) {
			if (!path) {
				return;
			}

			var node = this;
			path.some(function(idx) {
				if (jsutils.isInstanceOf(node, "CtrlVignette")) {
					var page = node.getTopPage();
					node = page && page.rootLayout;
					return false;
				}
				node = node && node.getChildByIndex(+idx);
				if (!node) {
					return true;
				}
			});
			return node;
		},
		//
		// END: Tree / child management
		//

		getArticleText: function(property) {
			if (!this.article[property]) {
				return "";
			}

			var self = this;
			var $articleLocalizationDashboard;
			if (self.page.parentVignette) {
				$articleLocalizationDashboard = self.page.parentVignette.$articleLocalization;
			}

			var locale = localeModule.getCurrentLocale();
			var prop = self.article[property];
			var text = prop && prop.replace(/\{\@(\S+)\}/g, function(m, g) {
				var localization = self.$articleLocalization[locale];
				var fallback = self.$articleLocalization[globals.fallbackLocaleCode];

				var match = (localization && localization[g]) ||
					(fallback && fallback[g]) ||
					($articleLocalizationDashboard && $articleLocalizationDashboard[locale] && $articleLocalizationDashboard[locale][g]) ||
					($articleLocalizationDashboard && $articleLocalizationDashboard[globals.fallbackLocaleCode] && $articleLocalizationDashboard[globals.fallbackLocaleCode][g]);

				if (match === null || match === undefined) {
					return m;
				}
				return match;
			});
			if (text && prop === text) {
				text = this.controller.dataset.prototype.resolveExpression(text);
			};

			return text || "";
		},
		getArticleTextUUID: function(property) {
			if (!this.article[property] || this.article[property].indexOf("{@") < 0) {
				return "";
			};
			var uuid = this.article[property].match(/\{\@(\S+)\}/);
			return (uuid && uuid[1]);
		},
		//
		// START: Testing
		//
		getUnitTestId: function() {
			return null;
		},

		/**
		 * Used by unit test entities to display info
		 */
		getUnitTestMsg: function() {
			return this.article && this.article.$unitTest ? this.article.$unitTest.message : null;
		},
		//
		// END: Testing
		//

		getDataActionAttrs: function(dataAction, dataParams) {
			return eventListener.getDataActionAttrs(this.controller.id, dataAction, dataParams);
		},
		isControl: function() {
			return true;
		},
		isLayout: function() {
			return false;
		},
		isArrayChart: function() {
			return false;
		},
		isAuthoringPropAllowed: function(property, value) {
			return true;
		},
		isVignette: function() {
			return false;
		},
		/**
		 * Set true for controls that contain children but do not allow authoring on these children
		 * because authoring is managed by parent.
		 * Currently, only arrays set this to true
		 * 
		 */
		excludeChildrenFromAuthoring: function() {
			return false;
		},

		setBuildOption: function(optionName, optionValue) {
			if (optionValue != null) {
				this.options[optionName] = optionValue;
			} else {
				delete this.options[optionName];
			}
		},
		setBuildOptionPerClass: function(className, optionName, optionValue) {
			if (jsutils.isInstanceOf(this, className)) {
				this.setBuildOption(optionName, optionValue);
			}
			this.children && this.children.forEach(function(c) {
				c.setBuildOptionPerClass(className, optionName, optionValue);
			});
		}
	}
);