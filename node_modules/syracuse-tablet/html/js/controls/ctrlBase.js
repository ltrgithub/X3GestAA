"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/structElmt').Klass;
/**
 * PROPOSAL OF FIELD AUTHORING
 * {
 * "$bind": "$title",
 * “$tablet”:{
 * 		$value:{
 * 			$theme:"A","B"...,
 * 			$beforelabel:true/false,
 * 			$isTitleHidden:true/false,
 * 			$position: "stack"/"center"/"right",
 * 			$fontStyle: "b"/"i"/"u", "bu"/"ubi" is allowed
 * 			$fontSize: "small"/"medium"/"large",
 * 			$expression:"{FieldA} + {FieldB}",
 * 			$refDescrHidden: true/false
 * 			$refdescr : {
 * 				$theme:,
 *  			$fontStyle:,
 * 				$fontSize:
 * 			}
 * 		},
 * 		$label:{
 * 			…
 * 		},
 * Plateform/Device properties for android that override general properties (if any)
 * 		$android:{ $value: {}, $label: {}},
 * 		$android-sm:{ General properties for android small devices},
 * 		$android-sm-portrait:{ General properties for android small devices portrait},
 * 		$android-sm-landcsape:{ General properties for android small devices landcsape},
 * 		$ios:{}…
 * }
 */


/**
 * Used to generate the html of control Icon/Button
 * generate a link and call cb to get the content of the control (icon/button...)
 * cb	Add html text to html param
 */
var _genHtmlCtrlLink = function(proto, dao, options, cb) {
	var self = this;
	options = options || {};
	var html = [];
	var url = proto.data("$url");
	var tag = options.tag || 'a';
	var css = options.css || 'a';
	if (url && url.length) {
		html.push('<');
		html.push(tag);
		html.push(' href="' + url + '"');
		if (css) {
			html.push(' class="' + css + '"');
		}
		html.push('>');
	} else {
		// attributes for data-nav or data-action
		var action = proto.data("$action") || self.prototype.data("$navigation");
		if (action) {
			html.push('<');
			html.push(tag);
			html.push(' href="#"');
			for (var p in action) {
				html.push(' ' + p + '="' + encodeURIComponent(dao ? dao.parseExpression(action[p]) : action[p]) + '"');
			}
			if (css) {
				html.push(' class="' + css + '"');
			}
			html.push('>');
		}
	}
	if (cb) cb(html);
	if (html.length > 1) {
		html.push('</');
		html.push(tag);
		html.push('>');
	}
	return html.join('');
};

/**
 * Default ctrl html  - Just the value embedded into a div
 * 	options:	Passed to create Control by creator
 * 	TODO - Remove this class if not used
 */
var _Klass = utils.defineClass(

	function CtrlBase(controller, article, prototype, options) {
		var self = this;
		options = options || {};
		self.prototype = prototype;
		self.$bind = article.$bind;
		Base.call(self, controller, prototype.data('$type'), article, options);
		self.$isEditMode = controller.isEditMode() && article.$isEditMode !== false && options.isTableCell !== true;
		self._dao = null;
	}, Base, {
		destroy: function() {
			var self = this;
			Base.prototype.destroy.call(self);
			if (self.prototype) {
				// We destroy the proto
				self.prototype.destroy();
				self.prototype = null;
			}
			self._dao = null;
		},
		createId: function(typeName) {
			// Add $bind in id for readability - Id can be minimized in non debug version
			return utils.readableuid(this.$bind, typeName.substr(0, 3));
		},
		/**
		 * controllerDao is the page dao or the row data for a grid
		 * 	We need to store it to keep acces
		 */
		buildHtml: function($$parent, controllerDao, buildOptions, classes) {
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions);
			this._dao = controllerDao;
			var css = ["s-m-control"];
			if (classes) css.push(classes.join(' '));
			this.createRootElement(css, $$parent);
		},
		afterRender: function(buildOpts) {
			// Apply meta after build html
			this.applyMetaData(this.getMetaData());
		},
		/**
		 * return the dao given by buildHtml or dao controller
		 */
		getDao: function() {
			return this._dao ? this._dao : this.controller.dao;
		},
		/**
		 * Refreshes the control
		 * We have to apply meta-data
		 */
		refresh: function(controllerDao, options) {
			this._dao = controllerDao;
			this.applyMetaData(this.getMetaData());
		},
		/**
		 * dao.getMetaData does the merge between prototype and data
		 * metaProp		optional - name of the meta $readonly...
		 * 				if null returns all the meta
		 */
		getMetaData: function(metaProp) {
			var dao = this.getDao();
			var meta = dao ? dao.getMetaData("$properties", this.$bind) : null;
			if (metaProp) return meta ? meta[metaProp] : null;
			return meta;
		},
		getTitle: function() {
			return (this.article && this.article.$title) || this.prototype.data("$title") || this.prototype.getPropTitle(this.$bind);
		},
		/**
		 * Applies meta-data
		 * In edit mode the dom element to which meta-data apply is identify by s-m-meta class
		 * In detail mode meta-data apply to fieldSlot
		 */
		applyMetaData: function(metaData) {
			var self = this;
			if (metaData == null) return;
			if (self.$isEditMode) {
				// default
				var e = self.$$elmt.find(".s-m-meta");
				if (e.length > 0) {
					// Apply $isDisabled and $isReadOnly
					// is("input") returns true for button tags -> we check the BS class .btn
					if (e.is("input") && !e.is(".btn")) {
						// only for input tags
						e[metaData.$isReadOnly === true ? "attr" : "removeAttr"]("readonly", "");
						e[metaData.$isDisabled === true ? "attr" : "removeAttr"]("disabled", "");
					} else {
						// other tags
						e[metaData.$isReadOnly === true || metaData.$isDisabled === true ? "attr" : "removeAttr"]("disabled", "");
					}
				}
			}
			var visible = self.$$elmt.is(":visible");
			if ((metaData.$isHidden === true && visible === false) || (metaData.$isHidden === false && visible === true)) {
				// Do not toggle in any case to not set style="display..." if no meta hidden
				self.$$elmt.toggle(metaData.$isHidden !== true);
			}
		},
		getValue: function() {
			return this.getDao().getValue(this.$bind);
		},
		/**
		 * Change internal value (non UI only)
		 * value parameter must be a correct datatype value without UI specific formatting
		 */
		setValue: function(value) {
			this.getDao().setValue(this.$bind, value);
		},
		/**
		 *  Validate the value and display error if any
		 *  returns true if OK
		 *  Used to validate a form
		 */
		checkData: function() {
			// Only field controls check the value
			return true;
		},
		setErrorStatus: function(yes) {
			if (!this.$$elmt) return;
			this.$$elmt[yes === true ? "addClass" : "removeClass"]("error");
		},
		/**
		 * True if ctrl has an error
		 */
		hasError: function() {
			return this.$$elmt && this.$$elmt.hasClass("error");
		},
		/**
		 * Set the focus on this field and scroll
		 */
		setFocus: function() {
			if (!this.controller) return;
			// Just make ctrl visible
			this.controller.makeVisible(this);
			// Focus is set on CtrlFields with inputs fields for the moment
		}
	}
);

exports.genHtmlCtrlLink = _genHtmlCtrlLink;
exports.Klass = _Klass;