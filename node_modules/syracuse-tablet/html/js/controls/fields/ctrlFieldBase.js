"use strict";

var Base = require('syracuse-tablet/html/js/controls/ctrlSdataBase').CtrlSdataBase;

var globals = require('syracuse-tablet/html/js/app/globals');
var environment = require('syracuse-tablet/html/js/helpers/environment');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var validator = require('syracuse-tablet/html/js/controls/validator').Validator;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var modules = require("syracuse-tablet/html/js/common/modules");
var native = require("syracuse-tablet/html/js/helpers/native/native");
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("ctrlFieldBase", false);

var _label_pos = ["top", "left"];
var _texr_align = ["right", "left", "center"];
/**
 * Give the authoring property that enables the capability if any
 */
var _nativeCapabilityAutoring = {
	"scanBarcode": "$scanBarcode",
	"GPS": "$scanGPS"
};

/**
 * 
 * Base class for controls that display exactly one value/property (Use article: { $bind: .. } )
 * 
 * options: {
 *   noEdit: Display field read only
 *   displayCtx: "table" render table specific (Mostly not show diagnosis)
 *   noTitle: Do not render title
 * }
 */
exports.CtrlFieldBase = utils.defineClass(
	function CtrlFieldBase(controller, article, prototype, options) {
		Base.call(this, controller, article, prototype, options);
		if (options.noEdit === true) {
			this.$isEditMode = false;
		}
		this.formatter = formatApi.getFormatter(this.$type, this.prototype.getValueByPath('$format'));
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.formatter = null;
		},

		//
		// START: Callbacks called by sdataController
		//
		/**
		 * Invoked by controller if value changed
		 */
		onValueChanged: function() {
			this.refreshValue();

			// Value updated by server, still we check client side contraints to show
			// invalid values reported by the server or to remove old client side diagnoses
			// e.g. If an empty mandatory field has been set with a value by the server
			var errors = [];
			this.validateValue(this.getValue(), errors);
			this.controller.setClientDiagnoses(this.$bind, errors);
			this.renderDiagnoses();
		},
		refreshValue: function() {
			if (!this.$$elmt) return;
			if (!this.$$value) return;

			this.buildFieldValue();
			this.checkEmptyValue();
		},
		/**
		 * Invoked by controller if meta data changed
		 * Returns true if a diagnose has been rendered 
		 * -> the controller must put the focus on this control
		 * -> used to make first field's diagnose visible
		 */
		onMetaChanged: function() {
			if (!this.$$elmt) return false;
			var meta = this.getMetaData();
			return this.applyMetaData(meta);
		},
		//
		// END: Callbacks called by sdataController
		//

		//
		// START: Value set/get functions called from "UI"
		//

		/**
		 * Ask controller to return the value of the control
		 */
		getValue: function() {
			var value = this.controller.getValue(this.$bind);
			return value;
		},
		/**
		 * Ask controller to store a new value for the control
		 * 
		 * The controller will never call this method to set the value of the control
		 * It wil always use "onValueChanged" to let the control re-render
		 * 
		 * This method is likely to be called in blur events or similar
		 * 
		 * value parameter must be a correct data type value without UI specific formatting
		 */
		setValue: function(value) {
			this.controller.setValue(this.$bind, value);
		},

		//
		// END: Value set/get functions called from "UI"
		//

		//
		// START: Set, parse, format values from UI related interactions
		//
		/**
		 * Set internal value (controller) and visible formatted value (UI) by applying formatting if needed
		 * value parameter must be a correct data type value without UI specific formatting
		 */
		setFieldValue: function(value) {
			this.setDisplayValue(this.getFormattedValue(value));
			this.setValue(value);
		},
		/**
		 * Field value (input) is set by an external widget (date picker, lookup...)
		 * We force the focus in the field - Use to switch the status of an editable vignette
		 */
		//TODO: DO we really need this?
		setFieldValueFromSelector: function(value) {
			this.setFieldValue(value);
			// Enable to put focus into field after a value has been selected by lookup
			// On last discussion, we decided to not put the focus is the better choice
			// this.setFocus();
		},

		/**
		 * Get value as string to be displayed in control (e.g. formatted specific to locale)
		 * Used by rendering to get string to be displayed
		 */
		getFormattedValue: function(value) {
			if (!this.formatter) {
				return value == null ? "" : new String(value);
			}
			try {
				return this.$isEditMode === true ? this.formatter.formatValueEdit(value) : this.formatter.formatValue(value);
			} catch (e) {
				this.controller.setClientDiagnoses(this.$bind, [{
					$severity: "error",
					$message: e.message
				}]);
				this.renderDiagnoses();
				return "";
			}
		},

		/**
		 * value: value inputed into the field as string
		 * errors: array where to add parsing errors as strings
		 *
		 * return: Parsed value as represented in sdata data
		 * E.g. "2014-12-31" for dates or 123 for numbers
		 */
		parseValue: function(value, errors) {
			if (!this.formatter) {
				return value;
			}
			return this.formatter.parseValue(value, errors);
		},
		//
		// END: Set, parse, format values from UI related interactions
		//

		//
		// START: Rendering
		//
		/**
		 */
		buildHtml: function(classes) {
			classes = classes || [];
			classes.push("s-m-field");

			// add the type of field if needed for css selector
			if (this.cssType) {
				classes.push(this.cssType);
			}
			if (this.getAuthoring("$value.$valueFirst", false)) {
				classes.push("s-m-valueFirst");
			}

			Base.prototype.buildHtml.call(this, classes);
			this._oldValue = this.getValue();

			this.buildFieldTitle();
			this.buildFieldValue();

			// authoring
			this._applyLabelAuthoring();
			this.applyMetaData(this.getMetaData());
			this.renderDiagnoses();
			this.checkEmptyValue();
			this._checkNumVisiblePickers();
		},

		/**
		 * Create the main input field that is bind to blur event and other event
		 * s-m-meta indicates the element to which meta will be applied in edit mode
		 */
		createMainInput: function(value, type, attrs, $$parent) {
			type = type || "text";
			this._addNativePickers();

			var checkBox = "checkbox" === type;

			var css = ["s-m-meta"];
			attrs = attrs || {};
			attrs.type = type;
			var element = "input";
			if ("text" === type) {
				css.push("form-control");
				attrs["data-nevent-ctrl-blur"] = "";
				attrs.value = value;
			} else if ("textplain" === type) {
				element = "textarea";
				css.push("form-control");
				attrs["data-nevent-ctrl-blur"] = "";
			} else if (checkBox) {
				attrs["data-nevent-ctrl-click"] = "";
			}
			if (this.options.notifyFocus === true) {
				attrs["data-nevent-ctrl-focus"] = "";
			}
			this.$$input = $(uiUtils.createDomElement(element, css, null, attrs)).prependTo(this._$$inputGroup || $$parent || this.$$value);
			if (checkBox) {
				this.$$input.prop("checked", value);
			}
			return this.$$input;
		},

		/**
		 * Displays title under fieldSlot ($$elmt)
		 */
		buildFieldTitle: function() {
			this.$$elmt.removeClass("s-m-title-hidden");
			if (this.getAuthoring("$isTitleHidden")) {
				this.$$elmt.addClass("s-m-title-hidden");
				return;
			}
			// don't build field title if grid cell
			if (this.options.displayCtx === "table" ||
				this.options.noTitle === true) {
				return;
			}

			var ttl = (this.getTitle() || "").trim();
			if (ttl.length > 0) {
				if (this.getMetaData("$isMandatory") === true) {
					ttl += "*";
				}
				this.$$title = $(uiUtils.createDomElement("div", ["s-m-title"], ttl, null, this.$$elmt));
			}
			if (!ttl.length) {
				this.$$elmt.addClass("s-m-title-hidden");
			}
		},

		/**
		 * Just create the value slot under $$elmt
		 * Child class has to add the value
		 */
		_ensure$$value: function() {
			if (!this.$$value) {
				this._create$$value();
			}
		},
		_create$$value: function() {
			var classes = ["s-m-value"];
			if (this.$isEditMode) {
				classes.push("edit");
			}
			this.$$value = $(uiUtils.createDomElement("div", classes, null, null, this.$$elmt));
			return this.$$value;
		},
		_clear$$value: function() {
			if (this.$$value) {
				this.$$value.empty();
			}
			this.$$input = null;
			this._$$inputGroup = null;
			this._$$inputGroupBtn = null;
		},
		/**
		 * Add a text value to the valueSlot
		 * Used by default to display value with $details facet
		 */
		appendTextValue: function(value) {
			if (value == null) return;
			if (typeof value !== "string") {
				value = value.toString ? value.toString() : "??Can't display??";
			}
			value = value.trim();
			if (value.length > 0) {
				uiUtils.appendTextNode(this.$$value, value);
			}
		},

		/**
		 * Can be overridden - gauge
		 * forceEmpty used by asynchronous processes (ctrlText)
		 */
		checkEmptyValue: function(forceEmpty) {
			if (this.$isEditMode) return;
			/**
			 * We add a blank value if top aligned in order to align fields in a cell
			 */
			this.$$elmt.css("display", "");
			this.isEmpty = forceEmpty === true || this.$$value == null || this.$$value.is(":empty");
			this.$$elmt.toggleClass("s-m-empty", this.isEmpty);
			if (!this.isEmpty) return;
			// Capability to hide the field if no value
			if (this.getAuthoring("$hideIfEmpty") === true) {
				// No title and No value -> No display
				this.$$elmt.css("display", "none");
				return;
			}
			if (this.getAuthoring("$labelPosition") === "top") {
				// For alignment 
				this._ensure$$value();
				this.$$value.html("&nbsp;");
			}
		},
		/*
		 * Apply authoring properties related to the label:
		 * - labelPosition which can have values top,right,bottom,left
		 * - textAlignment which can have values left, right
		 */
		_applyLabelAuthoring: function() {
			// Code below could be optimized by using classList
			var val = this.getAuthoring("$labelPosition");
			this.$$elmt.removeClass("s-m-top");
			if (val == "top") {
				this.$$elmt.addClass("s-m-top");
			}
			this.$$elmt.removeClass("s-m-left s-m-right s-m-center");
			if (val === "top") {
				val = this.getAuthoring("$labelAlign");
				if (val != null && _texr_align.indexOf(val) >= 0) {
					this.$$elmt.addClass("s-m-" + val);
				}
			}
		},
		_ensureInputGroup: function() {
			var $$input;
			if (!this._$$inputGroup) {
				$$input = this.$$input ? this.$$input.detach() : null;
				this._$$inputGroup = $('<div class="input-group"/>').appendTo(this.$$value);
			}
			if (!this._$$inputGroupBtn) {
				this._$$inputGroupBtn = $('<span class="input-group-btn"/>').appendTo(this._$$inputGroup);
			}
			if ($$input) {
				$$input.prependTo(this._$$inputGroup);
			}
		},
		addPickerSdataLink: function($linkName, icon) {
			this._ensureInputGroup();
			var attrs = this.getSdataLinkAttrs($linkName);

			var $$picker = $('<button class="btn btn-default s-m-meta"><span class="' + icon + '"></span></button>');
			$.each(attrs, function(key, value) {
				$$picker.attr(key, value);
			});

			return $$picker.appendTo(this._$$inputGroupBtn);
		},
		/**
		 * Add a picker on the left hand side of the control
		 * Must be called before calling createMainInput
		 */
		addPicker: function(type, icon) {
			this._ensureInputGroup();
			var $$picker = $('<button data-control-id="' + this.id + '" data-nevent="" data-naction="' + type + 'Picker" class="btn btn-default s-m-meta"><span class="' + icon + '"></span></button>');
			return $$picker.appendTo(this._$$inputGroupBtn);
		},

		/**
		 * Returns true if a diagnose has been rendered 
		 * -> the controller must put the focus on this control
		 */
		applyMetaData: function(metaData) {
			Base.prototype.applyMetaData.call(this, metaData);
			if (metaData == null) return;

			if (this.$isEditMode) {
				// default
				var $$e = this.$$elmt.find(".s-m-meta");
				if ($$e.length > 0) {
					// Apply $isDisabled and $isReadOnly
					// is("input") returns true for button tags -> we check the BS class .btn
					if ($$e.is("input") && !$$e.is(".btn")) {
						// only for input tags
						$$e[metaData.$isReadOnly === true ? "attr" : "removeAttr"]("readonly", "");
						$$e[metaData.$isDisabled === true ? "attr" : "removeAttr"]("disabled", "");
					} else {
						// other tags
						$$e[metaData.$isReadOnly === true || metaData.$isDisabled === true ? "attr" : "removeAttr"]("disabled", "");
					}
				}
			}

			if (this.article.$isHidden != null || metaData.$isHidden != null) {
				this.$$elmt.toggleClass('s-m-hidden', this.article.$isHidden === true || metaData.$isHidden === true);
			}

			// returns true to put the focus
			return this.renderDiagnoses();
		},
		/**
		 * Returns true if a diagnose has been rendered
		 */
		renderDiagnoses: function() {
			if (!this.$$elmt) {
				return false;
			}
			this.$$elmt.removeClass("error info warning");
			if (this.$$message) {
				this.$$message.empty();
			}
			var diags = this.controller.getDiagnoses(this.$bind);
			if (diags.length === 0) {
				return false;
			}
			if (this.options.displayCtx !== "table") {
				if (!this.$$message) {
					this.$$message = $('<span class="s-m-message"/>').appendTo(this.$$elmt);
				}
			}
			var self = this;
			var nbErrors = 0;
			diags.forEach(function(diag) {
				if (self.options.displayCtx !== "table") {
					self.$$message.append($("<p class=s-m-" + diag.$severity + ">").text(diag.$message));
				}
				if (diag.$severity === "error") {
					nbErrors++
				}
			});
			this.$$elmt.toggleClass("error", nbErrors > 0);
			return true;
		},
		clearClientDiagnoses: function() {
			this.controller.setClientDiagnoses(this.$bind, []);
			this.renderDiagnoses();
		},

		_checkNumVisiblePickers: function() {
			if (!this._$$inputGroupBtn) return;
			var $$pickers = $("button", this._$$inputGroupBtn);
			var count = 0;
			$.each($$pickers, function(idx, picker) {
				// We do not is $.is..or :visible because elements may not be attached to the dom yet
				if ($(picker).css("display") !== "none") {
					count = count + 1;
				}
			});
			this._$$inputGroupBtn.toggle(count > 0);
		},
		//
		// END: Rendering
		//

		/**
		 * Change visible value (UI only)
		 * value parameter must be formatted already!
		 */
		setDisplayValue: function(value) {
			if (this.$$input) {
				this.$$input.val(value);
			}
		},

		//
		// START: Authoring
		//
		/**
		 * Pickers are displayed in authoring mode even if capability is not enabled to make user aware
		 * We toggle them when we clode authoring
		 */
		notifAuthClose: function() {
			if (!this.$$elmt) return;
			for (var p in _nativeCapabilityAutoring) {
				// Restore according to native capabilities - false to say that it's not authoring mode
				this.$$elmt.find('button[data-action="' + p + 'Picker"]').toggle(this.isNativeCapabilityEnabled(p, false));
			}
			this._checkNumVisiblePickers();
		},
		/**
		 * Pickers are displayed in authoring mode even if capability is not enabled to make user aware
		 * We toggle them when we open authoring
		 */
		notifAuthSetPage: function() {
			if (!this.$$elmt) return;
			for (var p in _nativeCapabilityAutoring) {
				this.$$elmt.find('button[data-action="' + p + 'Picker"]').toggle(this.isNativeCapabilityEnabled(p, true));
			}
			this._checkNumVisiblePickers();
		},
		//
		// End: Authoring
		//


		//
		// START: UI Stuff
		//
		onFocus: function(justCheck) {
			notifications.publish("sm.field.focus", this);
		},

		/**
		 * Return true if value OK
		 * justCheck	true to not set the value
		 */
		onBlur: function() {
			this.validateInput();
		},

		/**
		 * Parse and validate after user input
		 */
		validateInput: function() {
			this.clearClientDiagnoses();
			if (!this.$$input) {
				this.renderDiagnoses();
				return true;
			}

			var value = this.$$input.val();
			var errors = [];
			value = this.parseValue(value, errors);
			if (errors.length === 0) {
				this.validateValue(value, errors);
				// Set displayed value, also it may violate constraints later
				// This is because a parseable value is reformatted here to eliminate wrong characters
				// Internal value remains unchanged until all constraints are met
				this.setDisplayValue(this.getFormattedValue(value));
				if (errors.length === 0) {
					this.setValue(value);
				}
			}
			this.controller.setClientDiagnoses(this.$bind, errors);
			this.renderDiagnoses();
			return errors.length == 0;
		},

		/**
		 * value: value inputed into the field as string
		 * errors: array where to add validation errors as strings
		 * return true if ok
		 */
		validateValue: function(value, errors) {
			return validator.validate(this, value, errors, ["$isMandatory"]);
		},

		/**
		 * Set the focus on this field and scroll
		 */
		setFocus: function() {
			// !! First make visible
			Base.prototype.setFocus.call(this);
			if (this.$isEditMode && this.acceptFocus()) {
				// !! Second setFocus
				// !! setFocus scrolls the page and we don't want that because we don't use native scrolling 
				// We need to make th control visible before focus in order to not scroll the page
				// If it doesn't work fine we can save/srestore the page scrolling
				var $$elmt = this.getFocusElmt();
				if ($$elmt && $$elmt.is("input, select")) {
					// focus evt is triggered by dom focus
					$$elmt.focus();
					$$elmt.select();
				} else {
					// focus evt is triggered by application because the elmt doesn't actually take the focus
					// In next brother versions all kind of elements should accept focus
					notifications.publish("sm.field.focus", this);
				}
			}
		},
		/**
		 * Can be overridden (ctrlBinary...)
		 * Regular fields have an input
		 */
		getFocusElmt: function() {
			return this.$$input;
		},
		acceptFocus: function() {
			return this.getFocusElmt() != null;
		},
		//
		// END: UI Stuff
		//
		/**
		 * authoringOnly: force to skip native interface capability
		 * -> Used to display the pickers in authoring mode
		 */
		isNativeCapabilityEnabled: function(capability, authoringOnly) {
			var res;
			authoringOnly = authoringOnly === true;
			if (authoringOnly === true && globals.isAuthoringActive()) {
				// Forces to display pickers in authoring mode to make user aware
				var authoring = this.getNativeCapabilityAuthoring(capability);
				res = authoring != null && this.article[authoring] === true;
			} else if (this._nativeCapabilities == null || this._nativeCapabilities[capability] !== true) {
				res = false;
			} else {
				var authoring = this.getNativeCapabilityAuthoring(capability);
				res = authoring == null || this.article[authoring] === true;
			}
			res = res === true;
			log && log("isNativeCapabilityEnabled: " + capability + " (" + authoringOnly + "): " + res);
			//return true;
			return res;
		},
		addNativePicker: function(nativeCapability) {
			return this.addPicker(nativeCapability, fontUtils.getIconByName(nativeCapability + "Picker"));
		},
		_getNativePicker: function() {
			if (!this._nativeCapabilities) return null;
			if (this.isNativeCapabilityEnabled("scanBarcode")) {
				return "scanBarcode";
			} else if (this.isNativeCapabilityEnabled("GPS")) {
				return "GPS";
			} else if (this.isNativeCapabilityEnabled("penTextInput")) {
				return "penTextInput";
			}
			return null;
		},
		_addNativePickers: function() {
			if (!this._nativeCapabilities) return;
			if (environment.isMobile()) {
				var nativeCapability = this._getNativePicker();
				if (nativeCapability) {
					// First
					this.addNativePicker(nativeCapability);
				}
				return;
			}
			// In desktop mode, for authoring, we add all the pickers and show hide them according to the $ property on sm.auth.close/sm.auth.set.page events
			var self = this;
			["penTextInput", "GPS", "scanBarcode"].forEach(function(nativeCapability) {
				self.addNativePicker(nativeCapability).toggle(self.isNativeCapabilityEnabled(nativeCapability, true));
			});
			// USed to toggle the pickers
			notifications.subscribe(this, ["sm.auth.close", "sm.auth.set.page"]);
		},
		getNativeCapabilityAuthoring: function(capability) {
			// use this.options.nativeCapabilities because it's not filtered by native.hasCapability
			// Authoring doesn't require the native wrapper
			if (!this.options || this.options.nativeCapabilities == null || this.options.nativeCapabilities[capability] !== true) {
				return null;
			}
			return _nativeCapabilityAutoring[capability];
		},
		_actPenTextInputPicker: function() {
			var self = this;
			native.getModule("penTextInput").getPenTextInput({
				title: self.getTitle(),
				value: self.getValue()
			}).then(
				function(data) {
					if (data.action === "ok") {
						if (data.matches && data.matches.length) {
							var values = [];
							data.matches.forEach(function(val) {
								val = self.parseValue(val);
								if (val != null || val != "") {
									values.push(val);
								}
							});
							if (values.length === 0) return;
							// Only the first one if it's a number
							values = self.typeName === "string" ? values.join(' ') : values[0];
							self.setFieldValue(values);
						}
					}
				}
			);
		},
		_actGPSPicker: function() {
			var self = this;
			native.getModule("GPS").getGPSCoordinates().then(
				function(data) {
					if (data.succeeded === true) {
						self.setFieldValue(data.latitude + ", " + data.longitude);
					} else {
						modules.get("modal").notify({
							severityClass: "error",
							title: locale.text("gps.error")
						});
					}
				}
			).fail(function() {});
		},
		_actScanBarcodePicker: function() {
			var self = this;
			native.getModule("scanBarcode").scanBarcode()
				.then(function(data) {
					if (data.action === "ok") {
						self.setFieldValue(data.content);
					} else if (data.action === "cancelled") {
						modules.get("modal").notify({
							severityClass: "info",
							title: locale.text("barcode.cancelled")
						});
					} else {
						modules.get("modal").notify({
							severityClass: "error",
							title: locale.text("barcode.error")
						});
					}
				}).fail(function() {})
		},
		//
		// END: Native capabilities
		//
	});