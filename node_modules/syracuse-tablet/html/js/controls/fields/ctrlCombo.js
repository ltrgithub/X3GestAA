"use strict";

var Base = require('syracuse-tablet/html/js/controls/fields/ctrlFieldBase').CtrlFieldBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var datasetUtils = require('syracuse-tablet/html/js/sdata/datasetUtils');

/**
 * 
 * 
 * Rendering:
 * Radio buttons: ok
 * Combobox: ok
 * 
 * MetaData:
 * $isReadOnly: ok
 * $isDisabled: ok
 * $isHidden: ok
 * 
 */
exports.CtrlCombo = utils.defineClass(

	function CtrlCombo(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		Base.call(this, controller, article, prototype, options);
	}, Base, {

		/**
		 * 
		 */
		buildFieldValue: function(fieldSlot, buildOptions) {
			this._ensure$$value();
			this._updateList(false);
		},

		/**
		 * 
		 */
		refreshValue: function(buildOptions) {
			this._updateList(true);
		},

		/**
		 * 
		 */
		applyMetaData: function(metaData) {
			Base.prototype.applyMetaData.call(this, metaData);
			this._updateList(metaData, true);
		},

		/**
		 * 
		 */
		_updateList: function(valueChanged, metaDataChanged) {
			var self = this;
			if (!self.$$value) {
				return;
			}
			var metaData = this.getMetaData();
			this._isDisabled = datasetUtils.isDisabled(metaData);

			var newList = metaData && metaData.$value ? metaData.$value.$enum : null;
			if (valueChanged !== true && _compareEnum(newList, self._choiceList) && metaDataChanged !== true) {
				return;
			}
			self.$$value.empty();

			self._choiceList = $.extend(true, [], newList);
			if (self.$isEditMode) {
				self.$format = (metaData && metaData.$format) || "$combo";
				if (self.$format == '$radios') {
					self._renderRadios(metaData);
				} else {
					self._renderCombo(metaData);
				}
			} else if (self._choiceList.length > 0) {
				self._renderReadOnly(metaData);
			}
		},

		/**
		 * 
		 */
		_renderRadios: function(metaData) {
			var self = this;
			if (self._choiceList.length < 0) {
				return;
			}
			var value = self.currentValue = self.getValue();
			$.each(self._choiceList, function(index, choiceItem) {
				var choiceItemDom = uiUtils.createDomElement("div", ["s-m-field-radio-item"]);
				var inputDom = uiUtils.createDomElement("input", ["s-m-field-choice-radio", "s-m-meta"], null, {
					"type": "radio",
					"value": index,
					"data-sdata-value": choiceItem.$value,
					"name": "s-m-radio-" + self.id,
					"data-nevent-ctrl-click": ""
				});
				if (value && choiceItem.$value == value) {
					inputDom.setAttribute("checked", true);
				} else if (self._isDisabled) {
					inputDom.setAttribute("disabled", true);
				}
				var parsedTitle = self.prototype.resolveExpression(choiceItem.$title);
				var titleDom = uiUtils.createDomElement("div", ["s-m-field-choice-radio-title"], parsedTitle);
				self.$$value[0].appendChild(inputDom);
				self.$$value[0].appendChild(titleDom);
			});
		},

		/**
		 * 
		 */
		_renderCombo: function(metaData) {
			var self = this;
			if (self._choiceList.length < 0) {
				return;
			}
			var value = self.currentValue = self.getValue();
			var selectDom = uiUtils.createDomElement("select", ["form-control", "s-m-meta"], null, {
				"data-nevent-ctrl-change": ""
			});

			var selected = false;
			var opts = [];
			var optDom;

			$.each(self._choiceList, function(index, choiceItem) {
				var parsedTitle = self.prototype.resolveExpression(choiceItem.$title);
				if (parsedTitle) {
					optDom = uiUtils.createDomElement("option", null, parsedTitle, {
						"value": choiceItem.$value
					}, null);
					if (choiceItem.$value == value) {
						optDom.setAttribute("selected", true);
						selected = true;
					}
					opts.push(optDom);
				}
			});

			self.$$value[0].appendChild(selectDom);
			if (datasetUtils.isDisabled(metaData)) {
				selectDom.setAttribute("disabled", true);
			} else {
				selectDom.removeAttribute("disabled");
			}
			if (!selected) {
				if (opts.length > 0) {
					//#7129 - If no value provided by the server we display a blank line and select it
					// This case is not usual if functional developer takes care of providing a value
					// No text like 'Choose a value...' because we don't know the size of the select 
					// TODO: Improve
					// The best way would be to manage our own select without select tag
					opts.push(uiUtils.createDomElement("option", ["empty"], "", {
						"value": "",
						"selected": true
					}, null));
					if (metaData && metaData.$isMandatory) {
						//#7129 - If it's a mandatory field we remove the blank line after having selected a value
						$(selectDom).addClass("removeEmptyOption");
					}
				}
				if (value != null) {
					// #7129 - If value is defined but not found in list we display an error message
					// For quality to detect inconsistencies
					this.controller.setClientDiagnoses(this.$bind, [{
						$severity: "error",
						$message: locale.text("unexpected.value", [" (" + value + ")"])
					}]);

					this.renderDiagnoses();
				}
			}
			//#7129 - IE doesn't work fine if we insert an empty option in the dom $(select).prepend($opt)- So we attach options at the end 
			opts.forEach(function(opt) {
				selectDom.appendChild(opt);
			});
		},

		/**
		 * 
		 */
		_renderReadOnly: function(metaData) {
			var self = this;
			var value = self.currentValue = self.getValue();
			value = self._getChoiceTitle(value);
			value = self.prototype.resolveExpression(value);
			self.appendTextValue(value);
		},

		/**
		 * 
		 */
		_getChoiceTitle: function(value) {
			var res;
			$.each(this._choiceList, function(index, choice) {
				res = choice.$value == value ? choice.$title : res;
				if (res) {
					return false;
				}
			});
			return res;
		},

		/**
		 * 
		 */
		getChoiceTitles: function() {
			var res = [],
				self = this;
			$.each(this._choiceList, function(index, choice) {
				res.push({
					$value: choice.$value,
					title: self.prototype.resolveExpression(choice.$title)
				});
			});
			return res;
		},

		/**
		 * 
		 */
		setDisplayValue: function(value) {
			var self = this;
			if (value == self.currentValue) {
				return
			}
			if (!self.$isEditMode) {
				return;
			}
			if (self.$format !== '$radios') {
				return;
			}
			$.each(self.$$elmt.find("input"), function(idx, input) {
				if ($(input).attr("data-sdata-value") === value) {
					input.checked = true;
				} else {
					input.checked = false;
					if (self._isDisabled) {
						input.disabled = true;
					}
				}
			});
		},

		/**
		 * 
		 */
		setFieldValue: function(value) {
			this.setDisplayValue(value);
			this.currentValue = value;
			this.setValue(value);
		},

		/**
		 * 
		 */
		onClick: function(evt) {
			var $$t = $(evt.target);
			if (this.$format === '$radios') {
				this.setFieldValue(this._getChoiceValue($(evt.target)));
			}
			return true;
		},

		/**
		 * 
		 */
		_getChoiceValue: function($$elmt) {
			return $$elmt.attr("data-sdata-value");
		},

		/**
		 * 
		 */
		onChange: function(evt) {
			var $$t = $(evt.target);
			if ($$t.is("select") && $$t.is(".removeEmptyOption")) {
				// //#7129 - remove the empty option
				$$t.removeClass("removeEmptyOption").find("option.empty").remove();
			}
			this.setFieldValue(evt.target.value);
		},
	});

/**
 * 
 * @param enum1
 * @param enum2
 * @returns {Boolean}
 */
function _compareEnum(enum1, enum2) {
	if (!enum1 || !enum2) return false;
	if (enum1.length != enum2.length) return false;
	for (var i = 0, l = enum1.length; i < l; i++) {
		if (enum1.$value != enum2.$value) return false;
		if (enum1.$title != enum2.$title) return false;
	}
	return true;
}