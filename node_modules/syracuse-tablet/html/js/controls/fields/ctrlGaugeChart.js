"use strict";

var Base = require('syracuse-tablet/html/js/controls/fields/ctrlFieldBase').CtrlFieldBase;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var chartsTheme = require('syracuse-tablet/html/js/controls/chart/gaugeChartstheme').ChartsTheme;
var locale = require('syracuse-tablet/html/js/helpers/locale');

exports.CtrlGaugeChart = utils.defineClass(
	function CtrlGaugeChart(controller, article, prototype, options) {
		options = options || {};
		options.nativeCapabilities = null;
		Base.call(this, controller, article, prototype, options);

	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			var $$chartSlot = $(".s-m-gauge-container", this.$$elmt);
			if ($$chartSlot && $$chartSlot.length > 0) {
				$$chartSlot.remove();
			}
		},

		buildFieldTitle: function(fieldSlot, buildOptions) {
			// overridden because nothing to do
		},

		_defaultGaugeSegments: [{
			propStart: 0,
			propEnd: 0.25,
			valStart: null,
			valEnd: null,
			color: '#41A940'
		}, {
			propStart: 0.25,
			propEnd: 0.75,
			valStart: null,
			valEnd: null,
			color: '#FF5800'
		}, {
			propStart: 0.75,
			propEnd: 1,
			valStart: null,
			valEnd: null,
			color: '#CB3500'
		}],
		buildHtml: function(classes) {
			classes = classes || [];
			classes.push("s-m-gauge");
			Base.prototype.buildHtml.call(this, classes);
		},
		buildFieldValue: function() {
			var localeDecimalSep = locale.getNumberDecimalSeparator();
			var localeThousandSep = locale.getNumberGroupSeparator();

			this._ensure$$value();
			this._clear$$value();

			if (!this.chartsTheme) {
				this.chartsTheme = chartsTheme;
			}
			if (!this.chartsTheme.themeWasSet || this.chartsTheme.decimalPoint !== localeDecimalSep || this.chartsTheme.thousandsSep !== localeThousandSep) {
				this.chartsTheme.decimalPoint = localeDecimalSep;
				this.chartsTheme.thousandsSep = localeThousandSep;

				Highcharts.setOptions(this.chartsTheme);
				this.chartsTheme.themeWasSet = true;
			}
		},
		computeLayout: function(context) {
			this._renderGauge();
		},
		_renderGauge: function() {
			var $$chartSlot = $(".s-m-gauge-container", this.$$value);
			if ($$chartSlot && $$chartSlot.length > 0) {
				$$chartSlot.remove();
			}

			$$chartSlot = $("<div>").addClass("s-m-gauge-container");
			this.$$value.append($$chartSlot);

			var gauge = this.article.$gauge;
			var labelColor = !this.$isEditMode ? "#34B233" : "#666";

			var val = this.getValue();
			var valMin = 0;
			var valMax = 100;

			if (gauge.$bindMin != null && gauge.$bindMax != null) {
				if (isNaN(gauge.$bindMin)) {
					valMin = this.controller.getValue(gauge.$bindMin);
				} else {
					valMin = gauge.$bindMin;
				}
				if (isNaN(gauge.$bindMax)) {
					valMax = this.controller.getValue(gauge.$bindMax);
				} else {
					valMax = gauge.$bindMax;
				}
			}

			try {
				if (typeof val === "string") val = parseFloat(val);
			} catch (e) {}
			try {
				if (typeof valMin === "string") valMin = parseFloat(valMin);
			} catch (e) {}
			try {
				if (typeof valMax === "string") valMax = parseFloat(valMax);
			} catch (e) {}

			var cp = this.prototype.json;

			var uom = "";
			if (cp.$unit && cp.$properties && cp.$properties[cp.$unit] && val && val[cp.$unit] && val[cp.$unit].$symbol) {
				uom = val[cp.$unit].$symbol;
			}

			var label = this.getTitle();
			var decimals = this._getScale();
			var plotBands = this._createBands(cp, valMin, valMax);

			this._calcDesiredHeight();
			var spacingBottom = 35;
			var height = this.desiredHeight;
			var centerA = "50%";
			var centerB = (height - 20) / height * 100 + "%";
			var size = height - 30;

			$$chartSlot.highcharts({
				chart: {
					type: 'gauge',
					plotBackgroundColor: null,
					plotBackgroundImage: null,
					plotBorderWidth: 0,
					plotShadow: false,
					backgroundColor: null,
					height: height,
					borderWidth: 0,
					spacingBottom: spacingBottom
				},
				title: {
					text: label,
					style: {
						color: labelColor,
						fontWeight: "normal",
						textTransform: "uppercase"
					},
					verticalAlign: "bottom",
					y: 27
				},
				pane: {
					startAngle: -90,
					endAngle: 90,
					center: [centerA, centerB],
					size: size,
					background: [{
						backgroundColor: '#FFF',
						borderWidth: 0
					}]
				},
				yAxis: {
					min: valMin,
					max: valMax,

					minorTickWidth: 1,
					minorTickInterval: 'auto',
					minorTickLength: 20,
					minorTickPosition: 'inside',
					minorTickColor: '#fff',

					tickPixelInterval: 30,
					tickWidth: 0,
					tickPosition: 'inside',
					tickLength: 15,
					tickColor: '#FFF',
					labels: {
						step: 1,
						rotation: 'auto',
						style: {
							color: "#666",
							cursor: "default",
							fontSize: "0.9em",
							fontFamily: "Arial",
							lineHeight: "14px"
						},
						distance: 10,
						y: 0,
						verticalAlign: 'center',
						align: 'center'
					},
					title: {
						text: uom,
						style: {
							color: "#666"
						}
					},
					plotBands: plotBands
				},
				plotOptions: {
					gauge: {
						dataLabels: {
							enabled: true,
							format: "{point.y:,." + decimals + "f}",
							style: {
								fontFamily: "Arial"
							}
						}
					}
				},
				exporting: {
					buttons: null
				},
				series: [{
					name: label,
					data: [val],
					tooltip: {
						valueSuffix: ' ' + uom
					}
				}]

			}, function() {});
		},
		_getScale: function() {
			function getScaleFromFormat($format) {
				var match = $format.match(/\.(.*)/g);
				return match.length >= 1 ? match.length : 0;
			}

			if (this.article.$scale) {
				return this.article.$scale;
			} else {
				if (this.article.$format) {
					return getScaleFromFormat(this.article.$format);
				} else {
					return 0;
				}
			}
		},
		// Create segment definitions for gauge
		_createBands: function(cp, valMin, valMax) {
			var bands = [];

			// Grey background is always present
			bands.push({
				from: valMin,
				to: valMax,
				color: '#ccc',
				innerRadius: '79%',
				outerRadius: '101%'
			});

			var data = this.getValue();
			var bandsDef = this._mergeAuthoringAndDefaults();
			var seg;
			var s;
			var band;
			var range = valMax - valMin;
			for (s = 0; s < bandsDef.length; s++) {
				seg = bandsDef[s];
				band = {
					innerRadius: '79%',
					outerRadius: '101%',
					color: seg.color
				};
				if (seg.valStart != null && seg.valEnd != null) {
					band.from = this._resolveExpr(seg.valStart, data, cp);
					band.to = this._resolveExpr(seg.valEnd, data, cp);
				} else if (seg.propStart != null && seg.propEnd != null) {
					band.from = valMin + range * this._resolveExpr(seg.propStart, data, cp);
					band.to = valMin + range * this._resolveExpr(seg.propEnd, data, cp);
				}
				bands.push(band);
			}
			return bands;
		},
		// Merge default values for gauge segments with data comming from the authoring
		_mergeAuthoringAndDefaults: function() {
			var $gauge = this.article.$gauge;
			if (!$gauge.segments) // Not authoring on segments
				return this._defaultGaugeSegments;
			if ($gauge.segments.length === 0) // Not authoring on segments
				return this._defaultGaugeSegments;

			var s, def, auth, res = [];
			for (s = 0; s < $gauge.segments.length; s++) {
				def = this._defaultGaugeSegments[Math.min(s, this._defaultGaugeSegments.length - 1)];
				auth = $gauge.segments[s];
				if (!auth) {
					// no authoring for this segment, use default
					res.push(def);
				} else {
					if ((auth.propStart == null || auth.propEnd == null) && (auth.valStart == null || auth.valEnd == null)) {
						// not range defined, use default, not authoring
						auth.propStart = def.propStart;
						auth.propEnd = def.propEnd;
						auth.valStart = def.valStart;
						auth.valEnd = def.valEnd;
					}
					if (auth.color == null) {
						auth.color = def.color;
					}
					res.push(auth);
				}
			}
			return res;
		},
		_resolveExpr: function(expr, data, cp) {
			if (typeof expr !== "string") return expr;
			return expr.replace(/\{(\w+)\}/g, function(d0, d1) {
				if (data[d1] != null) return data[d1];
				if (cp[d1] != null) return cp[d1];
				return d0;
			});
		},
		_calcDesiredHeight: function() {
			var $$pscroll = this.$$elmt.closest(".s-m-scroll-wrapper");
			var isSingleChild = $(".s-m-control", $$pscroll).length < 2;
			var isInTile = $$pscroll.closest(".s-m-tile").length > 0;

			if (isInTile && isSingleChild) {
				// if we are the only control in a tile, we use up the full space
				var $$tile = $$pscroll.parent();
				this.desiredHeight = $$tile.height() - 20; // 20 for eventual header
			} else {
				// use a default size if there are other items or we are not in a tile
				this.desiredHeight = 200;
			}
		}
	});