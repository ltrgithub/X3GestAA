"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/layout/layoutBase').Klass;
var layoutHubGroup = require('syracuse-tablet/html/js/controls/layout/layoutHubGroup');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var HammerScroller = require('syracuse-tablet/html/js/controls/hammerScroller').Klass;

var _tileMargin = 10;
/**
 * Top level layout node that must only contain layoutHubGroups as children
 * This "hub" expands horizontally and only uses the available vertical space
 * Use this to define pages which only scroll horizontally
 */
var _Klass = utils.defineClass(
	function LayoutHub(controller, type, article, opts) {
		var self = this;
		Base.call(self, controller, type, article, opts);
		this._gestureMgr = null;
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},

		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			buildOptions = buildOptions || {};
			buildOptions.noTitle = true;
			Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions);
			self.$$elmt.addClass("s-m-hub");
			self.$$scrollElmt = $('<div style="position:relative; height:100%; width:100%">').appendTo(self.$$elmt);
			self.children.forEach(function(child) {
				child.buildHtml(self.$$scrollElmt, controllerDao, buildOptions);
			});
			if (self._gestureMgr) self._gestureMgr.destroy();
			self._gestureMgr = new HammerScroller(self.$$scrollElmt, {
				direction: self.getScrollDir(),
				valmax: 0,
				isPageScroller: true
			});
		},
		/**
		 * Resize handler called by window.resize
		 */
		onResize: function() {
			var self = this;
			/**
			 * Returns the visible rectangle of main page content
			 *
			 */
			var parentRect = self.controller.getMainContentRect();
			var pos = self.$$elmt.position();

			var w = parentRect.width;
			var h = parentRect.height - pos.top - 10;

			var rel = w / h;
			var posX = 0;
			var posY = 0;
			var opts;
			var width = 0,
				height = 0,
				cw, ch;

			self.orientation = (rel > 1.2 && h >= layoutHubGroup.minLandscapeHeigth) ? "landscape" : "portrait";
			if (self.orientation === "landscape") {
				self.$$elmt.css({
					width: "100%",
					height: h + "px"
				});
			} else {
				self.$$elmt.css({
					width: w + "px",
					height: "100%"
				});
			}

			self.children.forEach(function(child) {
				opts = {
					posX: posX,
					posY: posY,
					maxHeight: h,
					maxWidth: w,
					orientation: self.orientation
				};
				child.onResize(opts);
				cw = child.getWidth();
				ch = child.getHeight();

				if (self.orientation === "landscape") {
					posX += cw + _tileMargin;
				} else {
					posY += ch + _tileMargin;
				}
			});

			if (self.orientation === "landscape") {
				width = posX;
				height = h;
			} else {
				width = w;
				height = posY;
			}
			// Used by scroller
			var o = self.$$elmt.offset();
			self.$$scrollElmt.width(width);
			self.$$scrollElmt.height(height);
			self.insideRect = uiRect.newRect(o.top, o.left, height, width);

			var viewRect = self.getScrollViewRect();
			if (viewRect) {
				self._gestureMgr.init(viewRect, self.getScrollDir());
			} else {
				self._gestureMgr.reset();
			}
		},
		getScrollDir: function() {
			var self = this;
			return self.orientation && self.orientation === "portrait" ? "v" : "h";
		},
		getScrollViewRect: function() {
			var scrollRect = uiRect.elmtRect(this.$$scrollElmt, "outer");
			var viewRect = scrollRect.intersectRect(uiRect.elmtRect(this.$$elmt, "outer"));
			return viewRect != null && !viewRect.contains(scrollRect) ? viewRect : null;
		},
		getGestureMgr: function() {
			return this._gestureMgr;
		}
	});

exports.Klass = _Klass;