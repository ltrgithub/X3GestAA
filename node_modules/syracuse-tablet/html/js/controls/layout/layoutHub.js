"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/layout/layoutBase').Klass;
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');
var uiSettings = require('syracuse-tablet/html/js/helpers/uiSettings');

/**
 * Top level layout node that must only contain layoutHubGroups as children
 * This "hub" expands horizontally and only uses the available vertical space
 * Use this to define pages which only scroll horizontally
 */
var _Klass = utils.defineClass(
	function LayoutHub(controller, type, article, opts) {
		var self = this;
		Base.call(self, controller, type, article, opts);
		this._gestureMgr = null;
		this._tilesGroupSpacing = uiSettings.getProp("hubLayout.groupSpacing");
		this._minLandscapeHeigth = uiSettings.getProp("hubLayout.landscapeMinHeigth");
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},

		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			buildOptions = buildOptions || {};
			Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions);
			self.$$elmt.addClass("s-m-hub");
			self.$$scrollElmt = $('<div class="s-m-scroll-elmt">').appendTo(self.$$elmt);
			self.buildChildrenHtml(self.$$scrollElmt, controllerDao, buildOptions);
			if (self._gestureMgr) {
				self._gestureMgr.reset();
			} else {
				/**
				 * Direction and valMax will be set on onResize when we know the orientations
				 * _gestureMgr needs to be created here to be able to store the restored value (see dashboard.savedCtxRestore)
				 * On back navigation we should restore the scrolling
				 */
				self._gestureMgr = scroller.newScroller(self.$$scrollElmt, {
					isPageScroller: true
				});
			}
		},
		/**
		 * Resize handler called by window.resize
		 */
		onResize: function(context) {
			var self = this;
			var linksOnly = self.article.$linksOnly;
			if (context && context.footerSwipe === true) {
				// To not resize the tiles on footerSwipe - TODO test and improve
				return;
			}

			/**
			 * Returns the visible rectangle of main page content
			 *
			 */
			var parentRect = self.controller.getMainContentRect();
			var pos = self.$$elmt.position();

			var w = parentRect.width;
			var h = parentRect.height - pos.top; // - 10;

			var rel = w / h;
			var posX = 0;
			var posY = 0;
			var opts;
			/* Layout orientation */
			self.scrollDirection = (rel > 1.2 && h >= this._minLandscapeHeigth) ? "h" : "v";
			if (self.scrollDirection === "h") {
				self.$$elmt.css({
					width: "100%",
					height: h + "px"
				});
			} else {
				self.$$elmt.css({
					width: w + "px",
					height: "100%"
				});
			}
			if (self.children) {
				var last = self.children.length - 1;
				self.children.forEach(function(child, idx) {
					opts = {
						posX: posX,
						posY: posY,
						maxHeight: h,
						maxWidth: w,
						scrollDirection: self.scrollDirection,
						allowSmallTiles: linksOnly && rel > 1.2,
					};
					child.onResize(context, opts);
					if (self.scrollDirection === "h") {
						posX += child.getWidth() + (idx < last ? self._tilesGroupSpacing : 0);
					} else {
						posY += child.getHeight() + (idx < last ? self._tilesGroupSpacing : 0);
					}
				});
			}
			var width, height;
			if (self.scrollDirection === "h") {
				width = posX;
				height = h;
			} else {
				width = w;
				height = posY;
			}
			var oldScroll = null;
			if (context && context.preserveScroll === true) {
				oldScroll = self._gestureMgr.getScroll();
			}
			// reset old scrolling to calculate width/height (mandatory in native mode)
			self._gestureMgr.reset();
			self.$$scrollElmt.width(width);
			self.$$scrollElmt.height(height);
			var scrollRect = uiRect.elmtRect(self.$$scrollElmt, "outer");
			var viewRect = parentRect.intersectRect(scrollRect);
			viewRect != null && !viewRect.contains(scrollRect) ? viewRect : null;
			if (!viewRect) return;
			self._gestureMgr.init(viewRect, self.scrollDirection, 0);
			if (oldScroll != null) {
				self._gestureMgr.autoScroll(oldScroll);
			}
		},
		/**
		 * layout hub gesture manager is the gesture manager of the dashboard
		 * in dashborad we don't scroll the whole page but just the content ofthe layout hub
		 * This method returns the _gestureMgr attached to the dashboard
		 */
		getGestureMgr: function() {
			return this._gestureMgr;
		},
		/**
		 * Context to store when dashboard is destroyed
		 * We save gesture manager context (scroll)
		 * type	back/link - Used to manage the content according to the type
		 */
		savedCtxCreate: function(type) {
			if (type === "link") {
				// Scroll is not saved when we send a link by email
				return null;
			}
			return this._gestureMgr ? {
				hubScroll: this._gestureMgr.savedCtxCreate()
			} : null;
		},
		/**
		 * Restore the context for the hublayout
		 */
		savedCtxRestore: function(ctx) {
			if (ctx != null && this._gestureMgr) {
				// Restore the scroll of hub layout
				this._gestureMgr.savedCtxRestore(ctx.hubScroll);
			}
		},
	});

exports.Klass = _Klass;