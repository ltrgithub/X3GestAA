"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;

var _compareEnum = function(enum1, enum2) {
	if (!enum1 || !enum2) return false;
	if (enum1.length != enum2.length) return false;
	for (var i = 0, l = enum1.length; i < l; i++) {
		if (enum1.$value != enum2.$value) return false;
		if (enum1.$title != enum2.$title) return false;
	}
	return true;
};
var _Klass = utils.defineClass(

	function CtrlCombo(controller, article, prototype, options) {
		Base.call(this, controller, article, prototype, options);
	}, Base, {
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			this.radioItemList = null;
			this._choiceList = null;
			this.valueSlot = null;
		},
		/**
		 * Not called on refreshValue - only at creation
		 */
		buildFieldValue: function(fieldSlot, buildOptions) {
			// create the $$value slot at creation
			this.valueSlot = Base.prototype.buildFieldValue.call(this, fieldSlot, buildOptions);
			// Else _updateList manages the update of list and value
			this._updateList(this.getMetaData(), false);
		},
		/**
		 * Refresh only the value if it changed
		 */
		refreshValue: function(buildOptions) {
			this._updateList(this.getMetaData(), true);
		},
		_updateList: function(metaData, valueChanged) {
			var self = this;
			if (!self.valueSlot) return;
			var newList = metaData && metaData.$value ? metaData.$value.$enum : null;
			if (valueChanged !== true && _compareEnum(newList, self._choiceList)) return;
			$(self.valueSlot).empty();
			// We need to clone because the deltaManager modifies the content of the list
			self._choiceList = $.extend(true, [], newList);
			if (self.$isEditMode) {
				var $format = metaData ? metaData.$format : null;
				if (!$format) {
					$format = self.prototype.data("$format");
				}
				// if '$format' is set it can only have values '$combo' or '$radio'
				if ($format && ($format != '$radios' && $format != '$combo')) {
					$format = '$combo';
				}
				// ## set display in case of edit mode ##
				var value = self.currentValue = self.getValue();
				var domValue;
				if (self._choiceList.length > 0) {
					// display in case of '$radios' format
					if ($format == '$radios') {
						self.radioItemList = [];
						$.each(self._choiceList, function(index, choiceItem) {
							// building choice item display
							var choiceItemDom = uiUtils.createDomElement("div", ["s-m-field-radio-item"]);
							var inputDom = uiUtils.createDomElement("input", ["s-m-field-choice-radio", "ctrl-evt-click", "s-m-meta"], null, {
								"type": "radio",
								"value": index,
								"name": "s-m-radio-" + self.id
							});
							if (value && choiceItem.$value == value) {
								inputDom.setAttribute("checked", true);
							}
							var titleDom = uiUtils.createDomElement("div", ["s-m-field-choice-radio-title"], choiceItem.$title);

							// build radioItemList array
							self.radioItemList.push({
								"inputDom": inputDom,
								"titleDom": titleDom
							});
							// appending to parent layout
							self.valueSlot.appendChild(inputDom);
							self.valueSlot.appendChild(titleDom);
						});
					}
					// default format is '$combo'
					else {
						var selectDom = uiUtils.createDomElement("select", ["form-control ctrl-evt-change", "s-m-meta"]);
						// build list
						var selected = false;
						var opts = [],
							optDom;
						$.each(self._choiceList, function(index, choiceItem) {
							var parsedTitle = self.prototype.resolveExpression(choiceItem.$title);
							optDom = uiUtils.createDomElement("option", null, parsedTitle, {
								"value": choiceItem.$value
							}, null);
							if (choiceItem.$value == value) {
								optDom.setAttribute("selected", true);
								selected = true;
							}
							opts.push(optDom);
						});
						self.valueSlot.appendChild(selectDom);
						// Apply metaData.$isReadOnly and/or metaData.$isDisabled on select
						// select can only be set as readonly with the 'disabled' attribute
						if (metaData.$isReadOnly || metaData.$isDisabled) {
							selectDom.setAttribute("disabled", true);
						} else {
							selectDom.removeAttribute("disabled");
						}
						if (!selected) {
							if (opts.length > 0) {
								//#7129 - If no value provided by the server we display a blank line and select it
								// This case is not usual if functional developer takes care of providing a value
								// No text like 'Choose a value...' because we don't know the size of the select - TODO Improve
								// The best way would be to manage our own select without select tag
								opts.push(uiUtils.createDomElement("option", ["empty"], "", {
									"value": "",
									"selected": true
								}, null));
								if (metaData && metaData.$isMandatory) {
									//#7129 - If it's a mandatory field we remove the blank line after having selecting a value
									$(selectDom).addClass("removeEmptyOption");
								}
							}
							if (value != null) {
								//#7129 - If value is defined but not found in list we display an error message - For quality to detect inconsistencies
								// Message is removed on click
								this.showInputErrors(locale.text("unexpected.value", [" (" + value + ")"]));
								$(selectDom).addClass("ctrl-evt-click", true);
							}
						}
						//#7129 - IE doesn't work fine if we insert an empty option in the dom $(select).prepend($opt)- So we attach options at the end 
						opts.forEach(function(opt) {
							selectDom.appendChild(opt);
						});
					}
				}
			} else if (self._choiceList.length > 0) {
				// ## set display in case of edit mode ##
				var value = self.currentValue = self.getValue();
				value = self._getChoiceTitle(value);
				value = self.prototype.resolveExpression(value);
				self.appendTextValue(self.valueSlot, value);
			}
		},
		_getChoiceTitle: function(value) {
			var res;
			$.each(this._choiceList, function(index, choice) {
				res = choice.$value == value ? choice.$title : res;
				if (res) {
					return false;
				}
			});
			return res;
		},
		getChoiceTitles: function() {
			var res = [],
				self = this;
			$.each(this._choiceList, function(index, choice) {
				res.push({
					$value: choice.$value,
					title: self.prototype.resolveExpression(choice.$title)
				});
			});
			return res;
		},
		_getChoiceValue: function(title) {
			var res;
			$.each(this._choiceList, function(index, choice) {
				res = choice.$title == title ? choice.$value : res;
				if (res) {
					return false;
				}
			});
			return res;
		},
		setDisplayValue: function(value, index) {
			var self = this;
			if (self.$isEditMode) {
				// in case of radio choice
				if (self.prototype.data("$format") == '$radios') {
					// apply change if new value
					if (value != self.currentValue) {
						// update widget
						$.each(self.radioItemList, function(idx, radioItem) {
							setTimeout(function() {
								// if new choice index is defined
								if (index) {
									radioItem.inputDom.checked = index == idx;
								}
								// if new choice index is not defined
								else {
									radioItem.inputDom.checked = self._choiceList[idx].$value == value;
								}
							}, 5);
						});
					}
				}

			}
		},

		setFieldValue: function(value, index) {
			this.setDisplayValue(value, index);
			this.currentValue = value;
			this.setValue(value);
		},

		onClick: function(evt) {
			var $$t = $(evt.target);
			if (this.prototype.data("$format") == '$radios') {
				this.setFieldValue(this._getChoiceValue(evt.target.nextElementSibling.textContent), $(evt.target.parentNode).index());
			} else if ($$t.is("select")) {
				////#7129 - Clear unexpected value error message if any
				this.clearInputErrors();
				// No more click
				$$t.removeClass("ctrl-evt-click");
			}
		},

		onChange: function(evt) {
			var $$t = $(evt.target);
			if ($$t.is("select") && $$t.is(".removeEmptyOption")) {
				// //#7129 - remove the empty option
				$$t.removeClass("removeEmptyOption").find("option.empty").remove();
			}
			this.setFieldValue(evt.target.value, evt.target.selectedIndex);
		},
		applyMetaData: function(metaData, buildOptions) {
			Base.prototype.applyMetaData.call(this, metaData, buildOptions);
			this._updateList(metaData);
		}
	});

exports.Klass = _Klass;