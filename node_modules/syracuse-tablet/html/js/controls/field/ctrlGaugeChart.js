"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var Base = require('syracuse-tablet/html/js/controls/field/ctrlFieldBase').Klass;
var chartsTheme = require('syracuse-tablet/html/js/controls/chart/gaugeChartstheme').ChartsTheme;

var _Klass = utils.defineClass(function CtrlGaugeChart(controller, article, prototype, options) {
	options = options || {};
	options.nativeCapabilities = null;
	Base.call(this, controller, article, prototype, options);
}, Base, {

	_defaultGaugeSegments: [{
		propStart: 0,
		propEnd: 0.25,
		valStart: null,
		valEnd: null,
		color: '#41A940'
	}, {
		propStart: 0.25,
		propEnd: 0.75,
		valStart: null,
		valEnd: null,
		color: '#FF5800'
	}, {
		propStart: 0.75,
		propEnd: 1,
		valStart: null,
		valEnd: null,
		color: '#CB3500'
	}],
	buildFieldValue: function(fieldSlot, buildOptions) {
		var self = this;

		var localeDecimalSep = locale.getNumberDecimalSeparator();
		var localeThousandSep = locale.getNumberGroupSeparator();

		if (!self.chartsTheme) {
			self.chartsTheme = chartsTheme;
		}
		if (!self.chartsTheme.themeWasSet || self.chartsTheme.decimalPoint !== localeDecimalSep || self.chartsTheme.thousandsSep !== localeThousandSep) {
			self.chartsTheme.decimalPoint = localeDecimalSep;
			self.chartsTheme.thousandsSep = localeThousandSep;

			Highcharts.setOptions(self.chartsTheme);
			self.chartsTheme.themeWasSet = true;
		}

		self._renderGauge();
	},

	checkEmptyValue: function() {
		return;
	},

	buildFieldTitle: function(fieldSlot, buildOptions) {
		// override because nothing to do
	},
	_resolveExpr: function(expr, data, cp) {
		if (typeof expr !== "string") return expr;
		return expr.replace(/\{(\w+)\}/g, function(d0, d1) {
			if (data[d1] != null) return data[d1];
			if (cp[d1] != null) return cp[d1];
			return d0;
		});
	},
	// Merge default values for gauge segments with data comming from the authoring
	_mergeAuthoringAndDefaults: function() {
		var self = this;
		var $gauge = self.article.$gauge;
		if (!$gauge.segments) // Not authoring on segments
			return self._defaultGaugeSegments;
		if ($gauge.segments.length === 0) // Not authoring on segments
			return self._defaultGaugeSegments;

		var s, def, auth, res = [];
		for (s = 0; s < $gauge.segments.length; s++) {
			def = self._defaultGaugeSegments[Math.min(s, self._defaultGaugeSegments.length - 1)];
			auth = $gauge.segments[s];
			if (!auth) {
				// no authoring for this segment, use default
				res.push(def);
			} else {
				if ((auth.propStart == null || auth.propEnd == null) && (auth.valStart == null || auth.valEnd == null)) {
					// not range defined, use default, not authoring
					auth.propStart = def.propStart;
					auth.propEnd = def.propEnd;
					auth.valStart = def.valStart;
					auth.valEnd = def.valEnd;
				}
				if (auth.color == null) {
					auth.color = def.color;
				}
				res.push(auth);
			}
		}
		return res;
	},
	// Create segment definitions for gauge
	_createBands: function(cp, valMin, valMax) {
		var self = this;
		var bands = [];

		// Grey background is always present
		bands.push({
			from: valMin,
			to: valMax,
			color: '#ccc',
			innerRadius: '79%',
			outerRadius: '101%'
		});

		var data = self.getValue();
		var bandsDef = self._mergeAuthoringAndDefaults();
		var seg;
		var s;
		var band;
		var range = valMax - valMin;
		for (s = 0; s < bandsDef.length; s++) {
			seg = bandsDef[s];
			band = {
				innerRadius: '79%',
				outerRadius: '101%',
				color: seg.color
			};
			if (seg.valStart != null && seg.valEnd != null) {
				band.from = self._resolveExpr(seg.valStart, data, cp);
				band.to = self._resolveExpr(seg.valEnd, data, cp);
			} else if (seg.propStart != null && seg.propEnd != null) {
				band.from = valMin + range * self._resolveExpr(seg.propStart, data, cp);
				band.to = valMin + range * self._resolveExpr(seg.propEnd, data, cp);
			}
			bands.push(band);
		}
		return bands;
	},
	_getScale: function() {
		var self = this;

		function getScaleFromFormat($format) {
			var match = $format.match(/\.(.*)/g);
			return match.length >= 1 ? match.length : 0;
		}

		if (self.article.$scale) {
			return self.article.$scale;
		} else {
			if (self.article.$format) {
				return getScaleFromFormat(self.article.$format);
			} else {
				return 0;
			}
		}
	},

	_renderGauge: function() {
		var self = this;

		var $$chartSlot = $(".s-m-gauge-container", self.$$elmt);
		if ($$chartSlot && $$chartSlot.length > 0) {
			$$chartSlot.remove();
		}

		$$chartSlot = $("<div>").addClass("s-m-gauge-container");
		self.$$elmt.append($$chartSlot);

		var gauge = self.article.$gauge;
		var labelColor = !self.$isEditMode ? "#34B233" : "#666";

		var val = self.getValue();
		var valMin = 0;
		var valMax = 100;

		if (gauge.$bindMin != null && gauge.$bindMax != null) {
			if (isNaN(gauge.$bindMin)) {
				valMin = self.getDao().getValue(gauge.$bindMin);
			} else {
				valMin = gauge.$bindMin;
			}
			if (isNaN(gauge.$bindMax)) {
				valMax = self.getDao().getValue(gauge.$bindMax);
			} else {
				valMax = gauge.$bindMax;
			}
		}

		try {
			if (typeof val === "string") val = parseFloat(val);
		} catch (e) {}
		try {
			if (typeof valMin === "string") valMin = parseFloat(valMin);
		} catch (e) {}
		try {
			if (typeof valMax === "string") valMax = parseFloat(valMax);
		} catch (e) {}

		var cp = self.prototype.json;

		var uom = "";
		if (cp.$unit && cp.$properties && cp.$properties[cp.$unit] && val && val[cp.$unit] && val[cp.$unit].$symbol) {
			uom = val[cp.$unit].$symbol;
		}

		var label = self.getTitle();
		var decimals = self._getScale();
		var plotBands = self._createBands(cp, valMin, valMax);

		self._calcDesiredHeight();
		var spacingBottom = 35;
		var height = self.desiredHeight;
		var centerA = "50%";
		var centerB = (height - 20) / height * 100 + "%";
		var size = height - 30;

		$$chartSlot.highcharts({
			chart: {
				type: 'gauge',
				plotBackgroundColor: null,
				plotBackgroundImage: null,
				plotBorderWidth: 0,
				plotShadow: false,
				backgroundColor: null,
				height: height,
				borderWidth: 0,
				spacingBottom: spacingBottom
			},
			title: {
				text: label,
				style: {
					color: labelColor,
					fontWeight: "normal",
					textTransform: "uppercase"
				},
				verticalAlign: "bottom",
				y: 27
			},
			pane: {
				startAngle: -90,
				endAngle: 90,
				center: [centerA, centerB],
				size: size,
				background: [{
					backgroundColor: '#FFF',
					borderWidth: 0
				}]
			},
			yAxis: {
				min: valMin,
				max: valMax,

				minorTickWidth: 1,
				minorTickInterval: 'auto',
				minorTickLength: 20,
				minorTickPosition: 'inside',
				minorTickColor: '#fff',

				tickPixelInterval: 30,
				tickWidth: 0,
				tickPosition: 'inside',
				tickLength: 15,
				tickColor: '#FFF',
				labels: {
					step: 1,
					rotation: 'auto',
					style: {
						color: "#666",
						cursor: "default",
						fontSize: "0.9em",
						fontFamily: "Arial",
						lineHeight: "14px"
					},
					distance: 10,
					y: 0,
					verticalAlign: 'center',
					align: 'center'
				},
				title: {
					text: uom,
					style: {
						color: "#666"
					}
				},
				plotBands: plotBands
			},
			plotOptions: {
				gauge: {
					dataLabels: {
						enabled: true,
						format: "{point.y:,." + decimals + "f}",
						style: {
							fontFamily: "Arial"
						}
					}
				}
			},
			exporting: {
				buttons: null
			},
			series: [{
				name: label,
				data: [val],
				tooltip: {
					valueSuffix: ' ' + uom
				}
			}]

		}, function() {});
	},
	onResize: function() {
		var self = this;
		self._renderGauge();
	},
	_calcDesiredHeight: function() {
		var self = this;
		var $$pscroll = self.$$elmt.closest(".s-m-scroll-wrapper");
		var isSingleChild = $(".s-m-control", $$pscroll).length < 2;
		var isInTile = $$pscroll.closest(".s-m-tile").length > 0;

		if (isInTile && isSingleChild) {
			// if we are the only control in a tile, we use up the full space
			var $$tile = $$pscroll.parent();
			self.desiredHeight = $$tile.height() - 20; // 20 for eventual header
		} else {
			// use a default size if there are other items or we are not in a tile
			self.desiredHeight = 200;
		}
	},
	destroy: function() {
		var self = this;
		Base.prototype.destroy.call(self);
		var $$chartSlot = $(".s-m-gauge-container", self.$$elmt);
		if ($$chartSlot && $$chartSlot.length > 0) {
			$$chartSlot.remove();
		}
	}
});

exports.Klass = _Klass;