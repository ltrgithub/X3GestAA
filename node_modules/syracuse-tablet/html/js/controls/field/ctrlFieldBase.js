"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var validator = require('syracuse-tablet/html/js/controls/validator').Validator;

/* 
	$isTitleHidden: false / true
	$labelPosition: left / right / top / bottom
	$labelAlign: left / right
	$theme: a, b, c
*/

/**
 * Base class for controls that display exactly one value/property
 */
var _Klass = utils.defineClass(

	function(controller, article, prototype, options) {
		var self = this;
		Base.call(self, controller, article, prototype, options);
		self.formatter = self.initFormatter();
		// css to add to fieldSlot elmt
		self.cssType = null;
	}, Base, {

		initFormatter: function() {
			return formatApi.getFormatter(this.$type, this.prototype.data('$format'));
		},

		destroy: function() {
			var self = this;
			Base.prototype.destroy.call(self);
			self.formatter = null;
		},

		getTitle: function() {
			var self = this;
			return (self.article && self.article.$title) || self.prototype.getPropTitle(self.$bind);
		},
		/**
		 */
		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			if (!controllerDao) throw new Error("BuildHtml - dao is expected for data parameter");
			buildOptions = buildOptions || {};
			self.dao = controllerDao;
			var classes = ["s-m-control s-m-field"];
			if (self.cssType) {
				// add the type of field if needed for css selector
				classes.push(self.cssType);
			}
			if (self.prototype.data("$isAdvanced") === true) {
				classes.push("s-m-advanced");
			}
			if (self.getAuthoring("$value.$valueFirst", false)) {
				classes.push("s-m-valueFirst");
			}
			self.createRootElement(classes, $$parent);
			var fieldSlot = self.$$elmt.get(0);
			self.buildFieldTitle(fieldSlot, buildOptions);
			self.buildFieldValue(fieldSlot, buildOptions);

		},
		afterRender: function() {
			var self = this;
			Base.prototype.afterRender.call(self);
			// Apply meta after build html
			self.applyMetaData(self._getMetaData());
		},

		/**
		 * Refreshes the control
		 * We have to apply meta-data
		 */
		refresh: function(controllerDao, options) {
			var self = this;
			self.applyMetaData(self._getMetaData());
		},
		/**
		 * dao.getMetaData does the merge between prototype and data
		 */
		_getMetaData: function() {
			return this.dao.getMetaData(this.$bind);
		},

		/**
		 * Applies meta-data
		 * In edit mode the dom element to which meta-data apply is identify by s-m-meta class
		 * In detail mode meta-data apply to fieldSlot
		 */
		applyMetaData: function(metaData) {
			var self = this;
			if (metaData == null) return;
			if (self.$isEditMode) {
				// default
				var e = self.$$elmt.find(".s-m-meta");
				if (e.length > 0) {
					// Apply $isDisabled and $isReadOnly
					// is("input") returns true for button tags -> we check the BS class .btn
					if (e.is("input") && !e.is(".btn")) {
						// only for input tags
						e[metaData.$isReadOnly === true ? "attr" : "removeAttr"]("readonly", "");
						e[metaData.$isDisabled === true ? "attr" : "removeAttr"]("disabled", "");
					} else {
						// other tags
						e[metaData.$isReadOnly === true || metaData.$isDisabled === true ? "attr" : "removeAttr"]("disabled", "");
					}
				}
			}
			self.$$elmt.toggle(metaData.$isHidden !== true);
		},
		/**
		 * Create the main input field that is bind to blur event and other event
		 * s-m-meta indicates the element to which meta will be applied in edit mode
		 * self.domInput contains the dom element used by event hanlders
		 */
		createMainInput: function(parent, value, type) {
			var self = this;
			type = type || "text";
			var css = ["s-m-meta"];
			var attrs = {
				"type": type
			};
			if ("text" === type) {
				css.push("form-control");
				css.push("ctrl-evt-blur");
				attrs.value = value;
			} else if ("checkbox" === type) {
				css.push("ctrl-evt-click");
			}
			self.domInput = uiUtils.createDomElement("input", css, null, attrs, parent);
			if ("checkbox" === type) self.domInput.checked = value;
			return self.domInput;
		},
		/**
		 * Displays title under fieldSlot ($$elmt)
		 */
		buildFieldTitle: function(fieldSlot, buildOptions) {
			var self = this;
			// don't build field title if grid cell
			if (self.getAuthoring("$isTitleHidden") !== true && buildOptions.isGridCell !== true) {
				return uiUtils.createDomElement("div", ["s-m-title"], self.getTitle(), null, fieldSlot);
			}
			return null;
		},

		/**
		 * Just create the value slot under fieldSlot ($$elmt)
		 * Child class has to add the value
		 */
		buildFieldValue: function(fieldSlot, buildOptions) {
			return uiUtils.createDomElement("div", ["s-m-value"], null, null, fieldSlot);
		},

		/**
		 * Add a text value to the valueSlot
		 * USed by default to display value with $details facet
		 */
		appendTextValue: function(valueSlot, value) {
			if (valueSlot == null || value == null) return;
			if (typeof value !== "string") value = value.toString ? value.toString() : "??Can't display??";
			value = value.trim();
			if (value.length > 0) uiUtils.appendTextNode(valueSlot, value);
		},

		/*
		 * value: value inputed into the field as string
		 * errors: array where to add validation errors as strings
		 * return true if ok
		 */
		validateValue: function(value, errors) {
			return validator.validate(this, value, errors, ["$isMandatory"]);
		},

		/*
		 * value: value inputed into the field as string
		 * errors: array where to add parsing errors as strings
		 *
		 * return: Parsed value as represented in sdata data
		 * E.g. "2014-12-31" for dates or 123 for numbers
		 */
		parseValue: function(value, errors) {
			if (!this.formatter) {
				return value;
			}
			return this.formatter.parseValue(value, errors);
		},
		showInputErrors: function(errors) {
			var self = this;
			if (!self.$$message) {
				self.$$message = $('<span class="s-m-field-message"/>').appendTo(self.$$elmt);
			}
			self.$$message.empty();
			if (errors) {
				errors.forEach(function(error) {
					self.$$message.append($("<p>").text(error));
				});
			}
		},
		clearInputErrors: function() {
			this.showInputErrors(null);
		},

		/*
		 * Get value as string to be displayed in control (ev. formatted specific to locale)
		 */
		getFormattedValue: function(value) {
			if (!this.formatter) {
				return value || "";
			}
			return this.formatter.formatValue(value);
		},

		getValue: function() {
			return this.dao.getValue(this.$bind);
		},

		/*
		 * Change visible value (UI only)
		 * value parameter must be formatted already!
		 */
		setDisplayValue: function(value) {
			if (this.domInput) {
				this.domInput.value = value;
			}
		},

		/*
		 * Change internal value (non UI only)
		 * value parameter must be a correct datatype value without UI specific formatting
		 */
		setValue: function(value) {
			this.dao.setValue(this.$bind, value);
		},

		/*
		 * Set internal value (controller) and visible formatted value (UI) by applying formatting if needed
		 * value parameter must be a correct datatype value without UI specific formatting
		 */
		setFieldValue: function(value) {
			var self = this;
			self.setDisplayValue(self.getFormattedValue(value));
			self.dao.setValue(self.$bind, value);
		},

		onBlur: function() {
			var self = this;
			if (!self.domInput) return;
			var value = self.domInput.value;
			var errors = [];

			value = self.parseValue(value, errors);
			if (errors.length > 0) {
				self.showInputErrors(errors);
				return;
			}

			// Set displayed value, also it may violate constraints later
			// This is because a parseable value is reformatted here to emiminate wrong characters
			// Internat value remains unchanged until all constraints are met
			self.setDisplayValue(self.getFormattedValue(value));

			self.validateValue(value, errors);
			if (errors.length > 0) {
				self.showInputErrors(errors);
			} else {
				self.clearInputErrors();
				self.setValue(value);
			}
		}
	});

exports.Klass = _Klass;