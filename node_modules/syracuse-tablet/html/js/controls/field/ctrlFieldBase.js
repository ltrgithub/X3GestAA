"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');

var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var validator = require('syracuse-tablet/html/js/controls/validator').Validator;

/**
 * Base class for controls that display exactly one value/property
 */
var _Klass = utils.defineClass(

	function(controller, article, prototype) {
		var self = this;
		Base.call(self, controller, article, prototype);
		self.$format = prototype.data('$format');
		self.formatter = formatApi.getFormatter(self.$type, self.$format);
		self.ensureEditMode();
	}, Base, {

		ensureEditMode: function() {
			var self = this;
			// Get page edit mode
			self.$isEditMode = self.controller.isEditMode();
			if (self.$isEditMode !== false) {
				// if page is NOT in read only mode, article can override edit mode of widget
				if (self.article.$isEditMode != null) {
					self.$isEditMode = self.article.$isEditMode;
				}
			}
		},

		destroy: function() {
			var self = this;
			Base.prototype.destroy.call(self);
			self.formatter = null;
		},

		getTitle: function() {
			var self = this;
			return (self.article && self.article.$title) || self.prototype.getPropTitle(self.$bind);
		},

		getPropertyType: function() {
			var self = this;
			return self.prototype.data("$type");
		},

		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			if (!controllerDao) throw new Error("BuildHtml - dao is expected for data parameter");
			buildOptions = buildOptions || {};
			self.dao = controllerDao;
			var classes = ["s-m-control s-m-field-slot"];
			if (self.prototype.data("$isAdvanced") === true) {
				classes.push("s-m-field-advanced");
			}
			self.createRootElement(classes, $$parent);
			var fieldSlot = self.$$elmt.get(0);

			this.buildFieldTitle(fieldSlot, buildOptions);
			this.buildFieldCore(fieldSlot, buildOptions);

			this.applyMetaData();
		},

		getFieldProperties: function() {
			var self = this;
			var $propertiesList = ["$isHidden", "$isReadOnly", "$isDisabled"];
			var $properties = {};

			$propertiesList.forEach(function($property, index) {
				$properties[$property] = self.prototype.data($property) || (self.article && self.article[$property]) || (self.dao.getValue("$properties") && self.dao.getValue("$properties")[self.$bind] && self.dao.getValue("$properties")[self.$bind][$property]);
			});
			return $properties;
		},
		applyMetaData: function(metaData) {

			var self = this;

			if (self.$isEditMode) {
				if (metaData) {
					switch (self.getPropertyType()) {
						case "application/x-choice":
							if (metaData.$isReadOnly != undefined || metaData.$isDisabled != undefined) {
								var $format = self.prototype.data("$format");
								if ($format && $format == '$radios') {
									self.$$elmt.find(".s-m-field-choice-radio").attr("disabled", (metaData.$isReadOnly || metaData.$isDisabled));
								} else {
									self.$$elmt.find("select").attr("disabled", (metaData.$isReadOnly || metaData.$isDisabled));
								}
							}
							break;
						case "application/x-boolean":
							if (metaData.$isReadOnly != undefined || metaData.$isDisabled != undefined) {
								self.$$elmt.find(".s-m-field-input-boolean").attr("disabled", (metaData.$isReadOnly || metaData.$isDisabled));
							}
							break;
						default:
							// apply $isReadOnly state if it is set
							if (metaData.$isReadOnly != undefined) {
								self.$$elmt.find(".s-m-field-input").attr("readonly", metaData.$isReadOnly ? "readonly" : "");
							}
							// apply $isDisabled state if it is set
							if (metaData.$isDisabled != undefined) {
								self.$$elmt.find(".s-m-field-input").attr("disabled", metaData.$isDisabled);
							}
					}
				} else {
					if (!self.hasInitMetaData) {
						var $properties = self.getFieldProperties();
						switch (self.getPropertyType()) {
							case "application/x-choice":
								if ($properties.$isReadOnly || $properties.$isDisabled) {
									var $format = self.prototype.data("$format");
									if ($format && $format == '$radios') {
										self.$$elmt.find(".s-m-field-choice-radio").attr("disabled", true);
									} else {
										self.$$elmt.find("select").attr("disabled", true);
									}
								}
								break;
							case "application/x-boolean":
								if ($properties.$isReadOnly || $properties.$isDisabled) {
									self.$$elmt.find(".s-m-field-input-boolean").attr("disabled", true);
								}
								break;
							default:
								// apply $isReadOnly state if it is set
								if ($properties.$isReadOnly) {
									self.$$elmt.find(".s-m-field-input").attr("readonly", "readonly");
								}
								// apply $isDisabled state if it is set
								if ($properties.$isDisabled) {
									self.$$elmt.find(".s-m-field-input").attr("disabled", true);
								}
						}
						self.hasInitMetaData = true;
					}
				}
			}
		},

		buildFieldTitle: function(parentSlot, buildOptions) {
			var self = this;
			// don't build field title if grid cell
			if (!(self.article.$isTitleHidden === true) && buildOptions.isGridCell !== true) {
				parentSlot.appendChild(uiUtils.createDomElement("div", ["s-m-field-title"], self.getTitle()));
			}
		},

		buildFieldCore: function(parentSlot, buildOptions) {
			var fieldCore = uiUtils.createDomElement("div", ["s-m-field-core"]);
			var fieldValueSlot = uiUtils.createDomElement("div", ["s-m-field-value-slot"]);
			var fieldValue = uiUtils.createDomElement("div", ["s-m-field-value"]);
			fieldValueSlot.appendChild(fieldValue);
			fieldCore.appendChild(fieldValueSlot);

			this.buildFieldValue(fieldValue, buildOptions);
			this.buildFieldMessage(fieldCore, buildOptions);

			parentSlot.appendChild(fieldCore);
		},

		buildFieldValue: function(parentSlot, buildOptions) {
			var self = this;
			var value;

			value = self.getFormattedValue(self.getValue());
			if (this.$isEditMode) {
				self.domInput = parentSlot.appendChild(uiUtils.createDomElement("input", ["s-m-field-input", "form-control", "ctrl-evt-blur"], null, {
					"type": "text",
					"value": value

				}));
			} else {
				self.createFieldValueElement(parentSlot, value);
			}
		},

		createFieldValueElement: function(parentSlot, value) {
			return uiUtils.createDomElement("div", ["s-m-field-value-read"], value || null, null, parentSlot);
		},

		buildFieldMessage: function(parentSlot, buildOptions) {
			this.domMessage = uiUtils.createDomElement("div", ["s-m-field-message"]);
			parentSlot.appendChild(this.domMessage);
		},

		/*
		 * value: value inputed into the field as string
		 * errors: array where to add validation errors as strings
		 * return true if ok
		 */
		validateValue: function(value, errors) {
			var ok = true;
			ok = validator.validate(this, value, errors, ["$isMandatory"]) && ok;
			return ok;
		},

		/*
		 * value: value inputed into the field as string
		 * errors: array where to add parsing errors as strings
		 *
		 * return: Parsed value as represented in sdata data
		 * E.g. "2014-12-31" for dates or 123 for numbers
		 */
		parseValue: function(value, errors) {
			if (!this.formatter) {
				return value;
			}
			return this.formatter.parseValue(value, errors);
		},
		showInputErrors: function(errors) {
			var $$msg = $(this.domMessage);
			$$msg.empty();
			if (errors) {
				errors.forEach(function(error) {
					$$msg.append($("<p>").text(error));
				});
			}
		},
		clearInputErrors: function() {
			this.showInputErrors(null);
		},

		/*
		 * Get value as string to be displayed in control (ev. formatted specific to locale)
		 */
		getFormattedValue: function(value) {
			if (!this.formatter) {
				return value || "";
			}
			return this.formatter.formatValue(value);
		},

		getValue: function() {
			return this.dao.getValue(this.$bind);
		},

		/*
		 * Change visible value (UI only)
		 * value parameter must be formatted already!
		 */
		setDisplayValue: function(value) {
			if (this.domInput) {
				this.domInput.value = value;
			}
		},

		/*
		 * Change internal value (non UI only)
		 * value parameter must be a correct datatype value without UI specific formatting
		 */
		setValue: function(value) {
			this.dao.setValue(this.$bind, value);
		},

		/*
		 * Set internal value (controller) and visible formatted value (UI) by applying formatting if needed
		 * value parameter must be a correct datatype value without UI specific formatting
		 */
		setFieldValue: function(value) {
			var self = this;
			self.setDisplayValue(self.getFormattedValue(value));
			self.dao.setValue(self.article.$bind, value);
		},

		onBlur: function() {
			var value = this.domInput.value;
			var errors = [];

			value = this.parseValue(value, errors);
			if (errors.length > 0) {
				this.showInputErrors(errors);
				return;
			}

			// Set displayed value, also it may violate constraints later
			// This is because a parseable value is reformatted here to emiminate wrong characters
			// Internat value remains unchanged until all constraints are met
			this.setDisplayValue(this.getFormattedValue(value));

			this.validateValue(value, errors);
			if (errors.length > 0) {
				this.showInputErrors(errors);
			} else {
				this.clearInputErrors();
				this.setValue(value);
			}
		}
	});

exports.Klass = _Klass;