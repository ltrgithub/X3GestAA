"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var validator = require('syracuse-tablet/html/js/controls/validator').Validator;

var authorPropCtrl = require('syracuse-tablet/html/js/authoring/authoringPropertiesCtrls');
var _label_pos = ["top", "left"];
var _texr_align = ["right", "left", "center"];
/**
 * Base class for controls that display exactly one value/property
 */
var _Klass = utils.defineClass(

	function CtrlFieldBase(controller, article, prototype, options) {
		Base.call(this, controller, article, prototype, options);
		this.formatter = this.initFormatter();
		// css to add to fieldSlot elmt
		this.cssType = null;
	}, Base, {

		initFormatter: function() {
			return formatApi.getFormatter(this.$type, this.prototype.data('$format'));
		},
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			this.domInput = null;
			this.$$message = null;
			this.$$value = null; // To force to recreate the value
		},
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.formatter = null;
		},
		/**
		 */
		buildHtml: function($$parent, controllerDao, buildOptions) {
			var classes = ["s-m-field"];
			// add the type of field if needed for css selector
			if (this.cssType) classes.push(this.cssType);
			if (this.getAuthoring("$value.$valueFirst", false)) classes.push("s-m-valueFirst");
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions, classes);
			var fieldSlot = this.$$elmt.get(0);
			this.buildFieldTitle(fieldSlot, buildOptions);
			this.buildFieldValue(fieldSlot, buildOptions);
			// authoring
			this._applyLabelAuthoring();
			this._applyThemeAuthoring();
			this.checkDiagnoses();
			this.checkEmptyValue();
		},
		/**
		 * Refresh only the value
		 */
		refreshValue: function(buildOptions) {
			if (!this.$$value) return;
			this.buildFieldValue(this.$$elmt.get(0), buildOptions);
			this.checkEmptyValue();
		},
		/**
		 * Can be overridden - gauge
		 */
		checkEmptyValue: function(forceEmpty) {
			if (this.$isEditMode) return;
			/**
			 * We add a blank value if top aligned in order to align fields in a cell
			 * To improve if needed
			 */
			this.isEmpty = forceEmpty != null ? forceEmpty : this.$$value == null || this.$$value.is(":empty");
			this.$$elmt.toggleClass("s-m-empty", this.isEmpty);
			if (!this.isEmpty) return;
			if (this.getAuthoring("$labelPosition") === "top") {
				if (!this.$$value) this.$$value = this._create$$value();
				this.$$value.html("&nbsp;");
			} else if (this.getAuthoring("$isTitleHidden")) {
				// No title and No value -> No display
				this.$$elmt.css("display", "none");
			}
		},
		/*
		 * Apply theme authoring:
		 * - different theme values come from authorProp (a, b, c, ...)
		 */
		_applyThemeAuthoring: function() {
			var $theme = this.getAuthoring("$theme");
			if ($theme) {
				var self = this;
				authorPropCtrl.getThemeProperties().values.map(function(val, index, obj) {
					self.$$elmt.toggleClass("s-m-control-" + val.value, false);
				});
				this.$$elmt.toggleClass("s-m-control-" + $theme, true);
			}
		},
		/*
		 * Apply authoring properties related to the label:
		 * - labelPosition which can have values top,right,bottom,left
		 * - textAlignment which can have values left, right
		 */
		_applyLabelAuthoring: function() {
			// Code below could be optimized by using classList
			var val = this.getAuthoring("$labelPosition");
			this.$$elmt.removeClass("s-m-top");
			if (val == "top") {
				this.$$elmt.addClass("s-m-top");
			}
			this.$$elmt.removeClass("s-m-left s-m-right s-m-center");
			if (val === "top") {
				val = this.getAuthoring("$labelAlign");
				if (val != null && _texr_align.indexOf(val) >= 0) {
					this.$$elmt.addClass("s-m-" + val);
				}
			}
		},
		/**
		 * Create the main input field that is bind to blur event and other event
		 * s-m-meta indicates the element to which meta will be applied in edit mode
		 * self.domInput contains the dom element used by event hanlders
		 */
		createMainInput: function(parent, value, type) {
			type = type || "text";
			var css = ["s-m-meta"];
			var attrs = {
				"type": type
			};
			if ("text" === type) {
				css.push("form-control");
				css.push("ctrl-evt-blur");
				attrs.value = value;
			} else if ("checkbox" === type) {
				css.push("ctrl-evt-click");
			}
			if (this.options.notifyFocus === true) {
				css.push("ctrl-evt-focus");
			}
			this.domInput = uiUtils.createDomElement("input", css, null, attrs, parent);
			if ("checkbox" === type) this.domInput.checked = value;
			return this.domInput;
		},
		onFocus: function(justCheck) {
			notifications.publish("sm.field.focus", this);
		},
		/**
		 * Displays title under fieldSlot ($$elmt)
		 */
		buildFieldTitle: function(fieldSlot, buildOptions) {
			this.$$elmt.removeClass("s-m-title-hidden");
			if (this.getAuthoring("$isTitleHidden")) {
				this.$$elmt.addClass("s-m-title-hidden");
				return;
			}
			// don't build field title if grid cell
			if (buildOptions && buildOptions.displayCtx === "table") return;
			var ttl = (this.getTitle() || "").trim();
			if (ttl.length > 0) {
				if (this.getMetaData("$isMandatory") === true) ttl += "*";
				this.$$title = $(uiUtils.createDomElement("div", ["s-m-title"], ttl, null, fieldSlot));
			}
			if (!ttl.length) {
				this.$$elmt.addClass("s-m-title-hidden");
			}
		},

		/**
		 * Just create the value slot under fieldSlot ($$elmt)
		 * Child class has to add the value
		 */
		buildFieldValue: function(fieldSlot, buildOptions) {
			if (this.$$value) {
				this.$$value.empty();
				this.clearInputErrors();
				this.$$message = null;
			} else {
				this._create$$value(fieldSlot);
			}
			return this.$$value.get(0);
		},
		_create$$value: function(fieldSlot) {
			if (this.$$value) {
				this.$$value.empty();
			} else {
				this.$$value = $(uiUtils.createDomElement("div", ["s-m-value", (this.$isEditMode ? "edit" : "")], null, null, fieldSlot || this.$$elmt));
			}
			return this.$$value;
		},
		/**
		 * Add a text value to the valueSlot
		 * USed by default to display value with $details facet
		 */
		appendTextValue: function(valueSlot, value) {
			if (valueSlot == null || value == null) return;
			if (typeof value !== "string") value = value.toString ? value.toString() : "??Can't display??";
			value = value.trim();
			if (value.length > 0) uiUtils.appendTextNode(valueSlot, value);
		},

		/*
		 * value: value inputed into the field as string
		 * errors: array where to add validation errors as strings
		 * return true if ok
		 */
		validateValue: function(value, errors) {
			return validator.validate(this, value, errors, ["$isMandatory"]);
		},

		/*
		 * value: value inputed into the field as string
		 * errors: array where to add parsing errors as strings
		 *
		 * return: Parsed value as represented in sdata data
		 * E.g. "2014-12-31" for dates or 123 for numbers
		 */
		parseValue: function(value, errors) {
			if (!this.formatter) {
				return value;
			}
			return this.formatter.parseValue(value, errors);
		},

		applyMetaData: function(metaData) {
			Base.prototype.applyMetaData.call(this, metaData);
			if (metaData && metaData.$diagnoses) {
				var errors = [];
				metaData.$diagnoses.forEach(function(d) {
					errors.push(d.$message);
				});
				this.showInputErrors(errors);
			}
		},
		showInputErrors: function(errors) {
			if (!this.$$message) {
				this.$$message = $('<span class="s-m-error"/>').appendTo(this.$$elmt);
			} else {
				this.$$message.empty();
			}
			this.$$elmt.removeClass("error");
			if (errors && errors.length > 0) {
				this.$$elmt.addClass("error");
				var self = this;
				errors.forEach(function(error) {
					if (error != null && (error + "").trim().length > 0) {
						self.$$message.append($("<p>").text(error));
					}
				});
			}
		},
		clearInputErrors: function() {
			this.showInputErrors(null);
		},

		/*
		 * Get value as string to be displayed in control (ev. formatted specific to locale)
		 */
		getFormattedValue: function(value) {
			if (!this.formatter) {
				return value || "";
			}
			return this.formatter.formatValue(value);
		},
		setValue: function(value, forceSetFocus) {
			Base.prototype.setValue.call(this, value);
			if (forceSetFocus === true) {
				this.setFocus();
			}
		},
		/**
		 * Set internal value (controller) and visible formatted value (UI) by applying formatting if needed
		 * value parameter must be a correct datatype value without UI specific formatting
		 * data: 		string/int
		 * 				object with {$value:,$description:,$title:} for x-reference
		 */
		setFieldValue: function(value, forceSetFocus) {
			this.setDisplayValue(this.getFormattedValue(value));
			this.setValue(value, forceSetFocus);
		},
		/**
		 * Field value (input) is set by an external widget (date picker, lookup...)
		 * We force the focus in the field - Use to switch the status of an editable vignette
		 */
		setFieldValueFromSelector: function(value) {
			this.setFieldValue(value, true);
		},
		/**
		 * Return true if value OK
		 * justCheck	true to not set the value
		 */
		onBlur: function(justCheck) {
			this.clearInputErrors();
			if (!this.domInput) return true;
			var value = this.domInput.value;
			var errors = [];
			value = this.parseValue(value, errors);
			if (errors.length === 0) {
				this.validateValue(value, errors);
				if (justCheck !== true) {
					// Set displayed value, also it may violate constraints later
					// This is because a parseable value is reformatted here to emiminate wrong characters
					// Internat value remains unchanged until all constraints are met
					this.setDisplayValue(this.getFormattedValue(value));
					if (errors.length === 0) {
						this.setValue(value);
					}
				}
			}
			if (errors.length > 0) {
				this.showInputErrors(errors);
			}
			return errors.length == 0;
		},
		/**
		 * Change visible value (UI only)
		 * value parameter must be formatted already!
		 */
		setDisplayValue: function(value) {
			if (this.domInput) {
				this.domInput.value = value;
			}
			this.clearInputErrors();
			this.removeDiagnoses();
		},
		refresh: function(controllerDao, options) {
			Base.prototype.refresh.call(this, controllerDao, options);
			this.checkDiagnoses();
		},
		checkDiagnoses: function() {
			var errors = [];
			var diags = this.getMetaData("$diagnoses");
			if (diags && diags.length > 0) {
				diags.forEach(function(d) {
					if (d.$severity === "error") {
						errors.push(d.$message);
					}
				});
			}
			if (errors.length > 0) {
				this.showInputErrors(errors);
			}
			return errors.length === 0;
		},
		/**
		 *  Validate the value and display error if any
		 *  returns true if OK
		 *  Use to validate a form
		 */
		checkData: function(checkDiagnoses) {
			this.clearInputErrors();
			var meta = this.getMetaData();
			if (meta && (meta.$isDisabled === true || meta.$isReadOnly === true || meta.$isHidden === true)) return true;
			if (!this.onBlur(true)) {
				return false;
			}
			var errors = [];
			var value = this.getValue();
			this.validateValue(value, errors);
			if (errors.length > 0) {
				this.showInputErrors(errors);
			}
			return errors.length === 0;
		},
		removeDiagnoses: function() {
			if (this.getDao()) {
				this.getDao().removeMetaDiagnoses(this.$bind);
			}
		},
		/**
		 * Set the focus on this field and scroll
		 */
		setFocus: function() {
			// !! First make visible
			Base.prototype.setFocus.call(this);
			if (this.acceptFocus()) {
				// !! Second setFocus
				// !! setFocus scrolls the page and we don't want that because we don't use native scrolling 
				// We need to make th control visible before focus in order to not scroll the page
				// If it doesn't work fine we can save/srestore the page scrolling
				if (this.getFocusElmt().is("input, select")) {
					// focus evt is triggered by dom focus
					this.getFocusElmt().focus();
				} else {
					// focus evt is triggered by application because the elmt doesn't actually take the focus
					// In next brother versions all kind of elements should accept focus
					notifications.publish("sm.field.focus", this);
				}
			}
		},
		/**
		 * Can be overridden (ctrlBinary...)
		 * Regular fields have an input
		 */
		getFocusElmt: function() {
			return $(this.domInput);
		},
		acceptFocus: function() {
			return this.getFocusElmt() != null;
		}
	});

exports.Klass = _Klass;