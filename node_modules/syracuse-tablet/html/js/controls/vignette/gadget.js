"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');

/**
 * Helper to wrap gadget data
 * 
 * TODO: Handle sdata where condition passed by parent page
 * Parent page calls dashboard with these url's right now:
 * We need to preserver this old url schema, the new one should be better aligned to sdata
 * {$baseUrl}/$mobileDashboards?dashboard=testContextDashboardChild&parameters=group%3D%7Bgroup%7D
 * 
 * Better (new form) will be:
 * .../mobile2/syracuse/collaboration/syracuse/mobileDashboards(dashboardName%20eq%20'STD_X3_ERP_EXPENSES_DASHBOARD')?representation=mobileDashboard.$details&parameters=group%3D%7Bgroup%7D
 *
 * 
 * parameters are values passed to the dashboard to filter the gadgets and are in the form:
 * parameters: {
 *   CODE: { // name of parameter
 *     value: "10"
 *   }
 * }
 *   
 * 
 */
exports.Gadget = utils.defineClass(
	function Gadget(gadgetJson, parameters) {
		this.json = gadgetJson;
		/* use for test only
		this.json.parameters = {
			where: {
				value: "CODE eq '{CODE}'"
			}
		};
		*/
		this.parameters = parameters;
	}, null, {
		destroy: function() {},

		data: function(prop) {
			return this.json ? this.json[prop] : null;
		},

		getType: function() {
			return this.json.$type;
		},

		getExternalUrl: function() {
			return this.json.externalUrl;
		},

		/**
		 * Compute the link that is used to fetch information represented by this gadget
		 * return: 
		 * {
		 *   $url: ...
		 *   $method: ...
		 * }
		 */
		getLink: function() {
			var $link;
			// For client side test gadgets, we directly enter $url and $method in gadget data
			// like that, a client side gadget can point to another client side dashboard etc or also
			// to a real X3 entity
			if (this.json.$url && this.json.$method) {
				$link = {
					$url: this._buildUrl(this.json.$url, false),
					$method: this.json.$method
				};
			} else {
				var method = "_computeLink_" + (this.json.$type === "$representation" ? (this.json.$type + "_" + this.json.facet) : this.json.$type);
				$link = this[method].call(this);
			}
			return $link;
		},
		_computeLink_$representation_$query: function() {
			var url;
			var url = "{$baseUrl}/" + this.json.entity +
				"?representation=" + this.json.representation + "." + this.json.facet;
			url = this._buildUrl(url, true, true);

			return {
				$url: url,
				$method: "GET"
			};
		},
		_computeLink_$representation_$details: function() {
			var url;
			url = "{$baseUrl}/" + this.json.entity +
				"('{$key}')" +
				"?representation=" + this.json.representation + "." + this.json.facet;
			url = this._buildUrl(url, true, true);
			return {
				$url: url,
				$method: "GET"
			};
		},
		_computeLink_$representation_$edit: function() {
			var url;
			url = "{$baseUrl}/" + this.json.entity +
				"('{$key}')" +
				(this._useWorkingCopyUrl() ? "/$workingCopies" : "") +
				"?representation=" + this.json.representation + "." + this.json.facet;
			url = this._buildUrl(url, true, true);
			return {
				$url: url,
				$method: this._useWorkingCopyUrl() ? "PUT" : "GET"
			};
		},
		_computeLink_$representation_$create: function() {
			var url;
			url = "{$baseUrl}/" + this.json.entity +
				"/$template" +
				(this._useWorkingCopyUrl() ? "/$workingCopies" : "") +
				"?representation=" + this.json.representation + "." + this.json.facet;
			url = this._buildUrl(url, true, true);
			return {
				$url: url,
				$method: this._useWorkingCopyUrl() ? "POST" : "GET"
			};
		},
		_computeLink_$dashboard: function() {
			var url;
			url = "{$collaborationBaseUrl}/" +
				"mobileDashboards(dashboardName%20eq%20'" +
				this.json.dashboardName +
				"')?representation=mobileDashboard.$details";
			url = this._buildUrl(url, false, true);
			return {
				$url: url,
				$method: "GET"
			};
		},
		_computeLink_$application: function() {
			var url;
			url = "{$collaborationBaseUrl}/" +
				"mobileApplications(applicationName%20eq%20'" +
				this.json.applicationName +
				"')?representation=mobileApplication.$details";
			url = this._buildUrl(url, false, true);
			return {
				$url: url,
				$method: "GET"
			};
		},
		_computeLink_$external: function() {
			var url = this.json.externalUrl;
			url = this._buildUrl(url, false);
			return {
				$url: url,
				$method: "GET"
			};
		},
		_computeLink_$request: function() {
			var url = "{$baseUrl}/QUERY('" + this.json.requestName + "')?representation=QUERY~" +
				this.json.requestName + (this.json.requestLevel ? "~" + this.json.requestLevel : "") + "." +
				this.json.facet;
			url = this._buildUrl(url, true, true);
			return {
				$url: url,
				$method: "GET"
			};
		},
		_computeLink_$stats: function() {
			var url = "{$baseUrl}/STATS('" + this.json.statName + "')?representation=STATS~" +
				this.json.statName + "." +
				this.json.facet;
			url = this._buildUrl(url, true, true);
			return {
				$url: url,
				$method: "GET"
			};
		},
		_buildUrl: function(url, addParameters, addContext) {
			var self = this;
			url = url.replace(/\{(\S+?)\}/g, function(m, p) {
				return self._getGadgetValue(p);
			});

			if (addParameters) { // Add parameters defined in the gadget definition, resolve place holders by parameter values passed to gadget via dashboard
				var params = [];
				this.json.parameters && Object.keys(this.json.parameters).forEach(function(paramName) {
					var paramValue = self._getParamValue(self.json.parameters[paramName].value);
					if (paramValue != null) {
						params.push(paramName + "=" + paramValue);
					}
				});
				if (params.length > 0) {
					var sep = url.indexOf("?") < 0 ? "?" : "&";
					url = url + sep + params.join("&");
				}
			}
			if (addContext) {
				url = protoHelpers.addClientContext(url, this.json.$clientContext);
			}
			return url;
		},
		_getParamValue: function(paramValue) {
			var self = this;
			if (paramValue.indexOf("{") < 0) { // static value?
				return paramValue;
			}
			var allParamsSet = true;
			var res = paramValue.replace(/\{(\S+?)\}/g, function(m, p) {
				var param = self.parameters && self.parameters[p];
				var value = param && param.value;
				if (value == null) {
					allParamsSet = false;
				}
				return value != null ? value : "";
			});
			return allParamsSet == true ? res : null;
		},
		/**
		 * key: $baseUrl, $key, ...
		 */
		_getGadgetValue: function(key) {
			var method = "_get_" + key;
			return this[method].call(this);
		},
		_get_$baseUrl: function() {
			var baseUrl = protoHelpers.getHostPort();
			var endpoint = this._getEndpoint();
			var url = baseUrl + "/mobile2/" + endpoint.split(".").join("/");
			return url;
		},
		_get_$hostPort: function() {
			return protoHelpers.getHostPort();
		},
		_get_$key: function() {
			return this.json.keyParameter;
		},
		_get_$collaborationBaseUrl: function() {
			var baseUrl = protoHelpers.getHostPort();
			return baseUrl + "/mobile2/syracuse/collaboration/syracuse";
		},

		_useWorkingCopyUrl: function() {
			return (this.json.$clientContext && this.json.$clientContext.$mobileProtocol) === "workingcopy";
		},

		_getEndpoint: function() {
			// Does gadget definition use a fixed endpoint?
			var endpoint = this.json.endpoint;
			if (!endpoint) {
				// No endpoint specified in gadget so use the one specified while loading the dashboard
				endpoint = this.json.$clientContext.$mobileEndpoint;
			}
			return endpoint;
		}
	});

exports.createGadget = function(proto, dashboardParameters) {
	if (proto) {
		var $item = proto.getValueByPath("$item");
		if ($item) {
			return new exports.Gadget(proto.getValueByPath("$item"), dashboardParameters);
		}
	}
}