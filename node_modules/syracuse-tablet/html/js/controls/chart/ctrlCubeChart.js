"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/chart/ctrlCubeChartBase').Klass;
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var locale = require("syracuse-tablet/html/js/helpers/locale");
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');


var _getArticle = function(type, $bind) {
	if (type === "stack") {
		return {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "stack",
				"$items": [{
					"$bind": $bind,
					"$isTitleHidden": true,
					"$style": "bar"
				}]
			}, {
				"$layoutType": "stack",
				"$items": [{
					"$bind": $bind,
					"$isTitleHidden": true,
					"$forceArray": true
				}]
			}]
		};
	}
	if (type === "row") {
		return {
			"$layoutType": "stack",
			"$items": [{
				"$layoutType": "row",
				"$items": [{
					"$layoutType": "cell",
					"$widthXs": "12",
					"$widthSm": "6",
					"$widthMd": "6",
					"$widthLg": "6",
					"$items": [{
						"$bind": $bind,
						"$isTitleHidden": true,
						"$style": "bar"
					}]
				}, {
					"$layoutType": "cell",
					"$widthXs": "12",
					"$widthSm": "6",
					"$widthMd": "6",
					"$widthLg": "6",
					"$items": [{
						"$bind": $bind,
						"$isTitleHidden": true,
						"$forceArray": true
					}]
				}]
			}]
		};
	}
	if (type === "hub") {
		return {
			"$layoutType": "hub",
			"$items": [{
				"$layoutType": "hubGroup",
				"$title": "",
				"$items": [{
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$size": "full",
					"$items": [{
						"$layoutType": "stack",
						"$items": [{
							"$bind": $bind,
							"$isTitleHidden": true,
							"$style": "bar"
						}]
					}]
				}, {
					"$layoutType": "tile",
					"$bgColor": "darkgrey",
					"$size": "full",
					"$items": [{
						"$layoutType": "stack",
						"$items": [{
							"$bind": $bind,
							"$isTitleHidden": true,
							"$forceArray": true
						}]
					}]
				}]
			}]
		};
	}
};
var _getMinHeight = function(h) {
	if (h === "xsmall") return 50;
	if (h === "small") return 100;
	if (h === "medium") return 200;
	if (h === "large") return 400;
	if (h === "xlarge") return 700;
	return 200;
};
/**
 * cube chart control class
 */

// CtrlCubeChart used by isInstanceOf 
var _Klass = utils.defineClass(function CtrlCubeChart(controller, article, prototype, options) {
	Base.call(this, controller, article, prototype, options);
	this.itemProto = prototype.getPrototype("$item");
	if (article.$minHeight == null) {
		article.$minHeight = "medium";
	}
}, Base, {
	/**
	 * Init the properties to allow reuse of this control
	 */
	initReuseProperties: function() {
		Base.prototype.initReuseProperties.call(this);
		this.dataset = null;
	},

	buildHtml: function($$parent, controllerDao, buildOptions) {
		Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions, ["s-m-chart"]);
		if (!this.article) {
			this.article = {};
		}
		this._minHeight = _getMinHeight(this.article.$minHeight);
		if (this.article.$openDetail == null) {
			this.article.$openDetail = this.controller.isVignette;
		}
		if (this.article.$openDetail) {
			$('<div class="s-m-catchevt" data-control-id="' + this.id + '" data-action="' + globals.ACTCHARTDETAIL + '"></div>').appendTo(this.$$elmt);
		}
		this._$$chartSlot = $('<div class="s-m-slot"/>').appendTo(this.$$elmt).hide();
		this._buildChart();
	},
	_buildChart: function() {
		// This block assigns some variables so that the implementations
		// in ctrlCubeChartBase which have been migrated from the desktop client
		// do not need to be modified too much!
		this.$prototype = this.prototype.json;
		this.$prototype.$properties = this.$prototype.$item.$properties;
		this._localize = {
			highCharts_showHideLegend: locale.text("highCharts_showHideLegend"),
			highCharts_seriesTitle: locale.text("highCharts_seriesTitle")
		};
		this._initializeMeta();

		this.dataset = this.getDao().getQueryResources();

		var settings = this._settingsFromValue();
		this._createChart(settings, this._$$chartSlot);
	},

	_ensureFormatter: function(measure) {
		measure.formatApi = {
			format: function(val, localFormat) {
				return val;
			}
		};
	},
	_localizedText: function(key) {
		return key;
	},

	_getFieldEvalTitle: function() {
		return [];
	},

	destroy: function() {
		Base.prototype.destroy.call(this);
		this.dataset = null;
	},
	/**
	 * Used also by authoring
	 */
	needsMinHeight: function() {
		return this._layouytType === "stack";
	},
	isChartDetailPage: function() {
		return this.controller.state.type === "chartdetail";
	},
	/**
	 * Call by page on resize - TODO generalize the resize process
	 */
	onResize: function(context) {
		var chart = this._$$chartSlot.highcharts();
		if (!chart) return;
		if (this._layouytType == null) {
			// Needed here to access to all elements (getParentVignette)
			// We do that just once
			if (this.isChartDetailPage()) {
				// in that case the chart is displayed in a 'detail's page
				this._layouytType = jsutils.isInstanceOf(this.parent, "LayoutCell") ? "stack" : "hub	";
			} else {
				// Chart in vignettes
				this._layouytType = this.controller.getParentDashboardType();
				// We top the cell/tile to adapt the css when a chart is nested
				if (this.controller.isVignette && this.controller.getParentVignette()) {
					this.controller.getParentVignette().parent.$$elmt.addClass("s-m-chart");
				}
			}
			if (this._layouytType === "stack") {
				this._cell = this.controller.isVignette ? this.controller.getParentVignette().parent : this.parent;
				this._row = this._cell.parent;
				// relative is needed
				this._$$chartSlot.css("position", "relative");
			}
		} else if (this._layouytType === "stack") {
			/*	if (context.authoringUpdate === true){
				if (self._row.children.length > 1){
					self._row.children.forEach(function(c){
						var chart = c.children[0];
						if (c.$$elmt.height() >= self._minHeight){
							cellH = Math.max(c.$$elmt.height(), cellH);
							return true;
						}
					})
				}
			}*/
			console.log(this._row.id, "reset", this.id);
			// Reset to take into account minHeight authoring property
			this._$$chartSlot.height(0);
			chart.setSize(0, 0, false);
		}
		var self = this;
		setTimeout(function() {
			if (self._layouytType === "stack") {
				/**
				 * In stacked layout we don't have fixed height
				 * We search for sibling cells
				 * If just one cell we set the height to minheight
				 * If multiple cells we take the height of the max height cells we find with height > minheight
				 */
				var cellH = self._minHeight;
				if (self._row.children.length > 1) {
					self._row.children.forEach(function(c) {

						console.log(self._row.id, "Cell", c.children[0].id, c.$$elmt.height());
						if (c.$$elmt.height() >= self._minHeight) {
							cellH = Math.max(c.$$elmt.height(), cellH);
							return true;
						}
					});
				}
				self._$$chartSlot.height(cellH);
				// if self._$$chartSlot if not visible we show it to better calculate the width/height
				var shown = !self._$$chartSlot.is(":visible");
				if (shown) {
					self._$$chartSlot.show();
				}
				var width = self._$$chartSlot.width();
				var height = self._$$chartSlot.height();
				if (shown) {
					self._$$chartSlot.hide();
				}
				chart.setSize(width, height, false);
			} else {
				chart.setSize(self._$$chartSlot.width(), self._$$chartSlot.height(), false);
			}
			self._$$chartSlot.show();
			if (self._layouytType === "stack") {
				// Needed to init the scroll
				if (self.controller.isVignette) {
					notifications.notifyController("sm.scroller.update", self.controller.getParentVignette().controller);
				} else {
					notifications.notifyController("sm.scroller.update", self.controller);
				}
			}
		});
	},
	_actChartDetail: function() {
		// Trigger a navigation to rowDetail page
		var attrs = {
			"data-control-id": this.id,
			"data-parent-id": this.controller.id,
			"data-nav": "chartdetail",
			"data-nav-target": "application"
		};
		eventListener.triggerNavigation(this.$$elmt, attrs);
	},
	childPageGetPageInfo: function(typePage, currentPage) {
		var pageInfo = {
			home: false,
			type: typePage,
			cached: false,
			refreshed: false,
			changeHash: false
		};

		if (typePage === "chartdetail") {
			var article = _getArticle("row", this.$bind);
			var protoJson = $.extend(true, {}, this.controller.prototype.json);
			protoJson.$title = locale.text("chartdetail.page.name");
			var proto = this.prototype.create(protoJson, true);
			pageInfo.prototype = proto;
			pageInfo.subtype = "details";
			pageInfo.article = article;
			pageInfo.name = currentPage.state.name + "." + this.$bind + "." + typePage;
		} else {
			throw new Error("Unknown page type " + typePage);
		}
		return pageInfo;
	}
});

exports.Klass = _Klass;