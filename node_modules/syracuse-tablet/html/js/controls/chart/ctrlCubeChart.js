"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/chart/ctrlCubeChartBase').Klass;
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var locale = require("syracuse-tablet/html/js/helpers/locale");
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var chartUserPrefs = require('syracuse-tablet/html/js/controls/chart/chartUserPrefs');

var _getUserPrefs = function(id) {
	return chartUserPrefs.createPrefs(id);
};

var _getChartDetailArticle = function(opt, $bind, chartArticle, arrayArticle) {
	opt = opt || {};
	// !! set opts with the right values - used by caller
	opt.display = opt.display || "bothSideToSide";
	opt.style = opt.style || (chartArticle ? chartArticle.$style : "bar");
	if (!chartArticle) {
		chartArticle = {
			"$bind": $bind,
			"$isTitleHidden": true
		};
	} else {
		chartArticle = $.extend({}, true, chartArticle);
	}
	if (opt && opt.openedFromArrayChart === true) {
		// We set $display to force to open a CtrlCubeChart class
		// The prototype of the control is an array so it doesn't contain $cube
		chartArticle.$display = "chart";
	}
	if (!arrayArticle) {
		arrayArticle = {
			"$bind": $bind,
			"$isTitleHidden": true,
			"$forceArray": true
		};
	} else {
		arrayArticle = $.extend({}, true, arrayArticle);
	}
	var res;
	// $isHidden = false -> keeps the control in page to be able to preserve article
	chartArticle.$isHidden = arrayArticle.$isHidden = false;
	switch (opt.display) {
		case "chartOnly":
			arrayArticle.$isHidden = true;
			res = {
				"$layoutType": "stack",
				"$items": [{
					"$layoutType": "row",
					"$items": [chartArticle, arrayArticle]
				}]
			};
			break;
		case "arrayOnly":
			chartArticle.$isHidden = true;
			res = {
				"$layoutType": "stack",
				"$items": [{
					"$layoutType": "row",
					"$items": [arrayArticle, chartArticle]
				}]
			};
			break;
		case "bothStacked":
			res = {
				"$layoutType": "stack",
				"$items": [{
					"$layoutType": "row",
					"$items": [chartArticle, arrayArticle]
				}]
			};
			break;
		default:
			res = {
				"$layoutType": "stack",
				"$items": [{
					"$layoutType": "row",
					"$items": [{
						"$layoutType": "cell",
						"$widthXs": "12",
						"$widthSm": "6",
						"$widthMd": "6",
						"$widthLg": "6",
						"$bgColor": "transparent",
						"$items": [chartArticle]
					}, {
						"$layoutType": "cell",
						"$widthXs": "12",
						"$widthSm": "6",
						"$widthMd": "6",
						"$widthLg": "6",
						"$bgColor": "transparent",
						"$items": [arrayArticle]
					}]
				}]
			};
			break;
	}
	// Pass the display info to the page - needed to set the tool bar
	chartArticle.$style = opt.style;
	// Pass the display info to the page - needed to set the tool bar
	res.$display = opt.display;
	return res;
};
var _getChartDetailDefaultArticle = function($bind) {
	return _getChartDetailArticle(null, $bind);
};
var _getHeight = function(h) {
	if (h === "xsmall") return 50;
	if (h === "small") return 100;
	if (h === "medium") return 200;
	if (h === "large") return 400;
	if (h === "xlarge") return 700;
	return 200;
};

/**
 * cube chart control class
 */

// CtrlCubeChart used by isInstanceOf 
var _Klass = utils.defineClass(function CtrlCubeChart(controller, article, prototype, options) {
	Base.call(this, controller, article, prototype, options);
	this.itemProto = prototype.getPrototype("$item");
	notifications.subscribe(this, "sm.updt.chart.dashboard");
}, Base, {
	/**
	 * Init the properties to allow reuse of this control
	 */
	initReuseProperties: function() {
		Base.prototype.initReuseProperties.call(this);
		this.dataset = null;
	},

	buildHtml: function($$parent, controllerDao, buildOptions) {
		Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions, ["s-m-chart"]);
		if (!this.article) {
			this.article = {};
		}
		this._height = _getHeight(this.article.$chartHeight);
		if (this.article.$openDetail == null) {
			this.article.$openDetail = this.controller.isVignette;
		}
		this.dataset = this.getDao().getQueryResources();
		if (this.dataset && this.dataset.length > 0) {
			if (globals.isAuthoringActive() || (this.article.$openDetail && !this.isChartDetailPage())) {
				$('<div class="s-m-catchevt" data-control-id="' + this.id + '" data-action="' + globals.ACTCHARTDETAIL + '"></div>').appendTo(this.$$elmt);
			}
			this._$$chartSlot = $('<div class="s-m-slot"/>').appendTo(this.$$elmt).hide();
			this._buildChart();
		} else {
			this._$$chartSlot = $('<div class="s-m-slot"/>').appendTo(this.$$elmt);
			var $item = this.prototype.data("$item");
			var title = $item && $item.$title;
			var $$title = $('<div class="s-m-no-data-title"></div>');
			$$title.appendTo(this._$$chartSlot);
			$$title.text(title);
			var $$label = $('<div class="s-m-no-data-label"></div>');
			$$label.appendTo(this._$$chartSlot);
			$$label.text(locale.text("label.chart.nodata"));
		}
	},
	_buildChart: function() {
		// This block assigns some variables so that the implementations
		// in ctrlCubeChartBase which have been migrated from the desktop client
		// do not need to be modified too much!
		this.$prototype = this.prototype.json;
		this.$prototype.$properties = this.$prototype.$item.$properties;
		this._localize = {
			highCharts_showHideLegend: locale.text("highCharts_showHideLegend"),
			highCharts_seriesTitle: locale.text("highCharts_seriesTitle")
		};
		this._initializeMeta();

		var settings = this._settingsFromValue();
		this._createChart(settings, this._$$chartSlot);
	},
	getMeasureCount: function() {
		var count = this.prototype.chartGetMeasureCount();
		var $seriesOptions = this.article.$seriesOptions;
		if (!$seriesOptions) return count;
		var self = this;
		Object.keys($seriesOptions).forEach(function(key) {
			if ($seriesOptions[key].isHidden) {
				count--;
			}
		});
		return count;
	},
	_ensureFormatter: function(measure) {
		measure.formatApi = {
			format: function(val, localFormat) {
				return val;
			}
		};
	},
	_localizedText: function(key) {
		return key;
	},

	_getFieldEvalTitle: function() {
		return [];
	},

	destroy: function() {
		Base.prototype.destroy.call(this);
		this.dataset = null;
	},
	/**
	 * Used also by authoring
	 */
	needsHeight: function() {
		return this._layouytType === "stack" && !this.isChartDetailPage();
	},
	isChartDetailPage: function() {
		return this.controller.state.type === "chartdetail";
	},
	/**
	 * Call by page on resize - TODO generalize the resize process
	 */
	onResize: function(context) {
		if (this.destroyed || !this.highchartObject) return;

		if (!this.$$elmt || !this.$$elmt.is(':visible')) {
			if (!this._subscribedExpand) {
				this._subscribedExpand = true;
				notifications.subscribe(this, ["sm.layout.expanded"]);
			}
		}
		var delay = 0;
		// Notifies cell/tile to improve display
		this.notifChartHosted();
		if (this._layouytType == null) {
			// Needed here to access to all elements (getParentVignette)
			// We do that just once
			if (this.isChartDetailPage()) {
				// in that case the chart is displayed in a 'detail's page
				this._layouytType = "stack";
			} else {
				// Chart in vignettes
				this._layouytType = this.controller.getParentDashboardType();
			}
			if (this._layouytType === "stack") {
				// relative is needed
				this._$$chartSlot.css("position", "relative");
			}
		} else {
			// Reset heights
			this.highchartObject.setSize(0, 0, false);
			// Hide slot
			this._$$chartSlot.hide();
			delay = 10;
		}
		var self = this;
		setTimeout(function() {
			self._setChartHeight(true);
		}, delay);
	},

	notifLayoutExpanded: function() {
		var self = this;
		setTimeout(function() {
			self._setChartHeight();
		});
	},

	_setChartHeight: function(show) {
		if (this.destroyed || !this.highchartObject) return;
		var stackController, height;
		if (this._layouytType === "stack") {
			// in stack mode we need a height
			if (this.isChartDetailPage()) {
				stackController = this.controller;
				// Height set to device height
				height = stackController.getMainContentRect().height - 10;
			} else if (this.controller.isVignette) {
				stackController = this.controller.getParentVignette().controller;
				// Height always less or equal than the device height
				height = Math.min(this._height, stackController.getMainContentRect().height - 10);
			} else {
				console.log("onResize chart - unexpected controller");
				return;
			}
		} else {
			// in hub mode we take the paren'ts height because the tile has a fixed height
			height = this._$$chartSlot.height();
		}
		var width = this._$$chartSlot.width();
		this.highchartObject.setSize(width, height, false);
		if (show) {
			this._$$chartSlot.show();
			if (stackController) {
				// Needed to update the scroller
				notifications.notifyController("sm.scroller.update", stackController);
			}
		}
	},
	_actChartDetail: function() {
		this.openChartDetailPage(this);
	},
	/**
	 * #6843
	 * Multiple charts in dashboards
	 * If we click on a chart detail before all the charts have been loaded the size of the charts could be wrong
	 * --> because chart in dashboard could be rendered while the chartDetail page is loading
	 * So when the chartDetail is closed it publishes this notification to allow the charts in parent's dashboard to check the height
	 */
	notifUpdtChartDashboard: function(pageId) {
		if (!this.controller) return;
		if (this._$$chartSlot.height() !== this._$$chartSlot.children(":first-child").height()) {
			// Set size only if slot height is different from chart height
			this._setChartHeight();
		};

	}
});

exports.Klass = _Klass;
exports.getChartDetailArticle = _getChartDetailArticle;
exports.getUserPrefs = _getUserPrefs;

/**
 * Methods use by ctrlArrayChart and ctrlCybeChart controls
 * 	getUserPrefsId
 * 	openChartDetailPage
 * 	setChartDetailAuthoring
 * 	childPageGetPageInfo
 * 	notifChartHosted
 */
exports.ctrlCubeChartInterface = {
	/**
	 * Returns the id for user preferences
	 */
	getUserPrefsId: function() {
		var id = [];
		if (this.controller.isVignette && this.controller.getParentVignette()) {
			var vignette = this.controller.getParentVignette();
			var prototype = vignette.prototype;
			// Dashboard name - 1th key
			var uuid = vignette.controller.state.dashboardName || vignette.controller.state.name;
			if (uuid) {
				id.push(uuid);
			}
			// Vignette id - 2d key
			uuid = prototype.data("$uuid");
			if (uuid) {
				id.push('-');
				id.push(uuid);
			}

		}
		if (id.length === 0) {
			// In case it's not a vignette - unexpected
			id.push(this.$bind);
			id.push('-');
			id.push(this.controller.getOriginalSdataUrl());
		}
		return id.join('');
	},
	/**
	 * Opens chart detail page
	 */
	openChartDetailPage: function() {
		eventListener.openChartDetailPage(this);
	},
	/**
	 * Save detail article in control's article
	 */
	setChartDetailAuthoring: function(article) {
		this.article.$chartDetail = article;
		notifications.publish("sm.auth.change.item.prop.ui");
	},
	/**
	 * Return the page info proto/article for the chart detail page
	 */
	childPageGetPageInfo: function(typePage) {
		var pageInfo = {
			home: false,
			type: typePage,
			cached: false,
			refreshed: false,
			changeHash: false
		};
		if (typePage !== "chartdetail") throw new Error("Unknown page type " + typePage);
		var userPrefs = _getUserPrefs(this.getUserPrefsId());
		if (globals.isAuthoringActive()) {
			// Clear prefs when we open chartDetail in authoring to design from regular layout (side2Side)
			userPrefs.reset();
		}
		// We need the prefs to define the right layout and the preferences of chart
		var opt = userPrefs.getPrefs() || {};
		opt.openedFromArrayChart = this.$type === "tablet/x-array-chart";
		var article = this.article.$chartDetail;

		var chartArticle = article && _findChartArticle(article);
		var arrayArticle = article && _findArrayArticle(article);
		article = _getChartDetailArticle(opt, this.$bind, chartArticle, arrayArticle);
		var protoJson = $.extend(true, {}, this.controller.prototype.json);
		protoJson.$title = this.prototype.getDataByPath("$cube.$title") || locale.text("chartdetail.page.name");
		pageInfo.prototype = this.prototype.create(protoJson, true);
		pageInfo.subtype = "details";
		pageInfo.article = article;
		// The name of a chart detail page is the name of the dashboard 
		// it is opened from plus the id of the vignetted container to get a unique name of the page
		// Be careful, a page name must be <name> . <facet> , no more that exactly one dot in the name
		// this is why dashboard name and vignette are concatenated with an underscore
		var parentVignette = this.controller.getParentVignette();
		if (!parentVignette) throw new Error("Chart detail is allowed only in dashboards");
		var parentDashboardName = parentVignette.controller.prototype.getDataByPath("$dashboardName");
		pageInfo.name = parentDashboardName + "_" + parentVignette.$bind + ".$" + typePage;
		return pageInfo;
	},

	/**
	 * Return the page info proto/article for the chart detail page
	 */
	notifChartHosted: function() {
		// Notifies cell/tile to improve display when a chart is nested
		if (this.controller.isVignette && this.controller.getParentVignette()) {
			var parent = this.controller.getParentVignette().parent;
			// hack to remove the background color since we manage it by js (not css)
			if (parent.notifChartHosted) {
				parent.notifChartHosted();
			}
		}
	}
};
/**
 * Add interface members
 */
utils.addClassMembers(_Klass, exports.ctrlCubeChartInterface);

function _findChartArticle(article) {
	var self = this;
	var chartNode = _traverseArticleNodes(article, function(node) {
		if (node.$bind && node.$chartOptions) {
			return true;
		}
	});
	return chartNode;
}

function _findArrayArticle(article) {
	var chartArray = _traverseArticleNodes(article, function(node) {
		if (node.$bind && !node.$chartOptions) {
			return true;
		}
	});
	return chartArray;
}

function _traverseArticleNodes(node, matcher) {
	if (matcher(node) === true) {
		return node;
	}
	if (node.$items && node.$items.length > 0) {
		var i;
		var match;
		for (i = 0; i < node.$items.length; i++) {
			match = _traverseArticleNodes(node.$items[i], matcher);
			if (match) {
				return match;
			}
		}
	}
	return null;
}