"use strict";

var locale = require('syracuse-tablet/html/js/helpers/locale');

/*
 *
 * Collection of all SData contraints and a validation function per constraint
 *
 */

var _validator = {
	validate: function(ctrl, value, errors, constraints) {
		var proto = ctrl.prototype;
		var ok = true;
		for (var i = 0; i < constraints.length; i++) {
			var c = constraints[i];
			var prop = null;
			if (ctrl && ctrl.getMetaData) {
				prop = ctrl.getMetaData(c);
			}
			if (prop != null) { // constraint set in prototype
				var fn = _validator[c];
				if (fn) {
					ok = fn(value, errors, prop) && ok;
				} else {
					errors.push({
						$severity: "error",
						$message: locale.text("field.unknownConstraint", [c])
					});
					ok = false;
				}
			}
		}
		return ok;
	},

	// General
	$isMandatory: function(value, errors, constraint) {
		if (constraint && (value == null || value === "")) {
			errors.push({
				$severity: "error",
				$message: locale.text("field.valMand")
			});
			return false;
		}
		return true;
	},

	// Strings
	$pattern: function(value, errors, constraint) {
		var self = this;
		if (value && constraint) {
			var re = new RegExp(constraint);
			if (!re.test(value)) {
				errors.push({
					$severity: "error",
					$message: locale.text("field.patternError", [constraint])
				});
				return false;
			}
		}
		return true;
	},

	// Numeric
	$minimum: function(value, errors, constraint) {
		var self = this;
		if (value != null && value < constraint) {
			errors.push({
				$severity: "error",
				$message: locale.text("field.minimum", [constraint])
			});
			return false;
		}
		return true;
	},
	$maximum: function(value, errors, constraint) {
		var self = this;
		if (value != null && value > constraint) {
			errors.push({
				$severity: "error",
				$message: locale.text("field.maximum", [constraint])
			});
			return false;
		}
		return true;
	},
	$exclusiveMinimum: function(value, errors, constraint) {
		var self = this;
		if (value != null && value <= constraint) {
			errors.push({
				$severity: "error",
				$message: locale.text("field.exclusiveMinimum", [constraint])
			});
			return false;
		}
		return true;
	},
	$exclusiveMaximum: function(value, errors, constraint) {
		var self = this;
		if (value != null && value >= constraint) {
			errors.push({
				$severity: "error",
				$message: locale.text("field.exclusiveMaximum", [constraint])
			});
			return false;
		}
		return true;
	},
	$minLength: function(value, errors, constraint) {
		var self = this;
		if (!value || value.length < constraint) {
			errors.push({
				$severity: "error",
				$message: locale.text("field.minLength", [constraint])
			});
			return false;
		}
		return true;
	},
	$maxLength: function(value, errors, constraint) {
		var self = this;
		if (value && value.length > constraint) {
			errors.push({
				$severity: "error",
				$message: locale.text("field.maxLength", [constraint])
			});
			return false;
		}
		return true;
	},
	$precision: function(value, errors, constraint) {
		var self = this;
		if (value) {
			var txt = ("" + value).split(".").join("");
			if (txt.length > constraint) {
				errors.push({
					$severity: "error",
					$message: locale.text("field.precision", [constraint])
				});
				return false;
			}
		}
		return true;
	},
	$scale: function(value, errors, constraint) {
		var self = this;
		if (value) {
			var txt = ("" + value).split(".");
			txt = txt && txt[1] || "";
			if (txt.length > constraint) {
				errors.push({
					$severity: "error",
					$message: locale.text("field.scale", [constraint])
				});
				return false;
			}
		}
		return true;
	}

};

exports.Validator = _validator;