"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var prototype = require('syracuse-tablet/html/js/helpers/prototype');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var HammerScroller = require('syracuse-tablet/html/js/helpers/hammerScroller').Klass;
var uiRect = require('syracuse-tablet/html/js/ui/rect');

/**
 * Base left/right panel control for dashBoards and regular pages
 * 	Adapted from Metro Bootstrap navbar-side
 */
var _Klass = utils.defineClass(
	/**
	 * SidePanel used by instanceOf
	 */
	function SidePanel(controller, $type, panelId, options) {
		this.panelId = panelId;
		this.actionManager = null;
		// Close on click by default
		this.closeBox = options.closeBox === true;
		// Overlap by default
		this.overlap = options.overlap !== false;
		// False by default - !! If true the child class must provide a DOM elmt with s-m-scroll-elmt class
		this.enableGesture = options.enableGesture === true;
		Base.call(this, controller, {
			$bind: this.panelId + "panel"
		}, prototype.create({
			$type: $type
		}), options);
		this._gestureMgr = null;
	}, Base, {
		destroy: function() {
			if (this.actionManager) {
				this.actionManager.destroy();
				this.actionManager = null;
			}
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
			this._$$scrollElmt = null;
			this._$$scrollWrapper = null;
			this.detach();
			Base.prototype.destroy.call(this);
		},
		/**
		 * Build doesn't attach $$elmt to a parent - see attach/detach
		 */
		buildHtml: function(side) {
			this.side = side;
			Base.prototype.buildHtml.call(this, null, this.controller.dao, {}, [this.typeName]);
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},
		attach: function($$parent, side) {
			if (this.$$elmt && (this.side != null && side != this.side)) {
				this.$$elmt.remove();
				this.$$elmt = null;
			}
			if (!this.$$elmt) {
				this.buildHtml(side);
			};
			if (this.isAttached()) {
				console.log("sidePanel.attach - Unexpected attached $$elmt");
				this.detach();
			}
			if (!$$parent) return;
			$$parent.append(this.$$elmt);
		},
		isAttached: function(side) {
			return this.$$elmt != null && this.$$elmt.closest(".s-m-panel").length > 0 && this.side == side;
		},
		detach: function() {
			if (!this.$$elmt) return;
			this.$$elmt.detach();
		},
		isEnabled: function() {
			return true;
		},
		/**
		 * Notified by page when toggled
		 */
		notifyToggled: function(side, action, visible) {
			if (!visible) return;
			this._updateGesture();
		},
		applyMetaData: function(metaData, buildOptions) {
			//  No meta for this control 
			return;
		},
		onClick: function(evt) {
			this.close();
		},
		// Trigger evt to let page manage the close and all additional actions
		close: function() {
			eventListener.triggerAction(this.$$elmt, "toggleSidePanel", "close," + this.side);
		},
		setActionManager: function(amgr) {
			if (this.actionManager) {
				this.actionManager.destroy();
			}
			this.actionManager = amgr;
		},
		// Returns a deferred
		// .then(function(success, link, data, options) {}).fail(function() {})
		_actActionLink: function(uuid) {
			if (this.actionManager) {
				return this.actionManager.triggerLink(uuid, this.controller).then(function(success, link, data, options) {}).fail(function() {});
			} else {
				return $.smResolve();
			}
		},
		hasLinks: function() {
			throw new Error("Not implemented");
		},
		/**
		 * Called if orientation/device/size changes
		 */
		onResize: function(context) {
			if (this._gestureMgr) {
				this._updateGesture();
			}
		},
		_updateGesture: function() {
			if (this.enableGesture !== true) return;
			if (!this.$$elmt || !this.$$elmt.is(':visible')) {
				if (this._gestureMgr) {
					this._gestureMgr.reset();
				}
				return;
			}
			if (!this._gestureMgr) {
				this.$$scrollElmt = this.$$elmt.find(".s-m-scroll-elmt");
				if (this.$$scrollElmt.length === 0) {
					if (globals.isDvlpMode()) {
						globals.getModal().notify({
							severityClass: "error",
							body: "Panel scrolling - Unexpected empty .s-m-scroll-elmt dom element"
						});
					}
					this.enableGesture = false;
					return;
				}
				this.$$scrollElmt.css({
					height: "auto",
					position: "relative"
				});
				// $$scrollWrapper is generally this.$$elmt
				this.$$scrollWrapper = this.$$elmt.find(".s-m-scroll-wrapper");
				if (this.$$scrollWrapper.length === 0) {
					this.$$scrollWrapper = this.$$elmt;
				}
				this._gestureMgr = new HammerScroller(this.$$scrollElmt, {
					direction: "v",
					valMax: 0,
					name: this.$bind,
					isPageScroller: false
				});
			}
			// top=0px needed to calculate the right viewrect
			var scrollRect = uiRect.elmtRect(this.$$scrollElmt.css({
				top: "0px"
			}), "outer");
			var wrapperRect = uiRect.elmtRect(this.$$scrollWrapper, "outer");
			var viewRect = wrapperRect.intersectRect(scrollRect);
			if (viewRect && !viewRect.contains(scrollRect)) {
				// Keep scrolling
				this._gestureMgr.init(viewRect, null, null, true);
			} else {
				this._gestureMgr.reset();
			}
		}
	});

exports.Klass = _Klass;