"use strict";

var Base = require('syracuse-tablet/html/js/controls/panels/panelSdataPage').PanelSdataPage;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');
var uiRect = require('syracuse-tablet/html/js/ui/rect');

var _html = {
	mainContainer: '\
		<nav class="navbar s-m-side-panel {{side}} {{additionnalCss}}" role="navigation">\
			<div class="s-m-panel-content s-m-scroll-elmt">\
			</div>\
		</nav>'
}

var _templates = {};

function _getHtml(name, ctx) {
	var tmpl = _templates[name];
	if (!tmpl) {
		tmpl = _templates[name] = Handlebars.compile(_html[name]);
	}
	return tmpl(ctx);
};

/**
 * options.noCloseOnClick
 * 		panel is not closed when we click the background
 * 		used by panels that have input fields like dialog panel that manages a close box
 * 
 * options.noMainScroller true if no main scroller
 * 		If the panel wants to manage it's own scroller (see panelEditTemplate):
 * 			set options.noMainScroller = true
 * 			put a s-m-scroll-elmt class in the element to scroll
 * 			put s-m-list-wrapper in the div that wraps the s-m-scroll-elmt
 */
exports.PanelAsideBase = utils.defineClass(
	function PanelAsideBase(controller, type, article, opts) {
		Base.call(this, controller, type, article, opts);
		this._gestureMgr = null;
	}, Base, {

		destroy: function() {
			if (this.$$container) {
				this.$$container.off();
			}
			Base.prototype.destroy.call(this);
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},

		///
		/// START: Rendering
		///

		/**
		 * 
		 */
		buildHtml: function() {
			var selectorElmts = this.attachedControlInfo.selector ? this.attachedControlInfo.selector.split("-") : [];
			if (selectorElmts.length) {
				switch (selectorElmts[selectorElmts.length - 1]) {
					case "left":
						this.attachedSide = "left";
						break;
					case "freeleft":
						this.attachedSide = "freeleft";
						break;
					case "freeright":
						this.attachedSide = "freeright";
						break;
					default:
						this.attachedSide = "right";
				}
			}
			this._ensure$$container();
			Base.prototype.buildHtml.call(this);
			var type = this.$type.split("application/x-panel-");
			if (type.length > 0) {
				// Add type for css selector needs
				this.$$elmt.addClass(type[1]);
			}
			this.$$elmt.html(_getHtml("mainContainer", {
				side: this.attachedSide,
				additionnalCss: this._getAdditionnalCss()
			}));
			this.$$panelContent = this.$$elmt.find(".s-m-panel-content");
			if (this.options.noMainScroller === true) {
				this.$$panelContent.removeClass("s-m-scroll-elmt");
			}
			if (this.options.noCloseOnClick !== true) {
				this.$$container.click(jsutils.bindFn(this.onClickPanel, this));
			}
		},
		_getAdditionnalCss: function() {
			return "navbar-inverse";
		},
		///
		/// END: Rendering
		///
		show: function() {
			if (!this.$$elmt) {
				this.buildHtml();
			}
			this._makeVisible();
		},
		hide: function() {
			this._makeInvisible();
		},

		/**
		 * Can be overridden if we want to cathc event and not close the panel (panel with input fields like share)
		 */
		onClickPanel: function(event) {
			if (!this.$$elmt.is(":visible")) {
				return
			}
			this.hide();
		},

		_ensure$$container: function() {
			// Ensure the manager of this control points us to the correct container to be used
			this.attachedControlsMgr.ensureControl$$container(this, this.attachedControlInfo);
		},
		/**
		 * 
		 */
		computeLayout: function(layoutInfo) {
			if (!this.$$container) {
				return;
			}
		},
		_updateGesture: function() {
			this.$$scrollElmt = this.$$elmt.find(".s-m-scroll-elmt");
			if (this.$$scrollElmt.length === 0) {
				return;
			}
			if (!this.$$elmt || !this.$$elmt.is(':visible')) {
				if (this._gestureMgr) {
					this._gestureMgr.reset();
				}
				return;
			}
			if (!this._gestureMgr) {
				// $$scrollWrapper is generally this.$$elmt
				this.$$scrollWrapper = this.$$elmt.find(".s-m-scroll-wrapper");
				if (this.$$scrollWrapper.length === 0) {
					this.$$scrollWrapper = this.$$elmt;
				}
				this._gestureMgr = scroller.newScroller(this.$$scrollElmt, {
					direction: "v",
					valMax: 0,
					name: this.$type,
					isPageScroller: false
				});
			}
			// reset old scrolling to calculate width/height (mandatory in native mode)
			this._gestureMgr.reset();
			// top=0px needed to calculate the right viewrect
			var scrollRect = uiRect.elmtRect(this.$$scrollElmt.css({
				top: "0px"
			}), "outer");
			var wrapperRect = uiRect.elmtRect(this.$$scrollWrapper, "outer");
			var viewRect = wrapperRect.intersectRect(scrollRect);
			if (viewRect && !viewRect.contains(scrollRect)) {
				// Keep scrolling
				this._gestureMgr.init(viewRect, null, null, true);
			}
		},
		///
		/// END: Rendering
		///

		onMenuItemChanged: function($itemName, $bind, metaData) {
			// Hide/unhide elements
			Base.prototype.onMenuItemChanged.call(this, $itemName, $bind, metaData);

			// Ensure scrolling is reset
			this._updateGesture();
		},
		_actClosePanel: function() {
			this.hide();
		},
		_makeVisible: function() {
			this._ensure$$dismiss();
			this.$$container.fadeIn(200);
			this.$$elmt.show(); // Do not only show/hide the container but also the panel since one container can be used by several panels!

			var panelWidth = this.$$elmt.width();
			this.$$dismiss.addClass(this.attachedSide).css(this.attachedSide, panelWidth);
			// TODO:
			// We fake the dismiss as being a piece of markup of the panel control so the event handler knows where to route the close event
			// Better would be to create a panel specific dismiss element to avoid this hack
			this.$$dismiss.addClass("s-m-ctrl");
			this.$$dismiss.attr("data-controller-id", this.controller.id)
			this.$$dismiss.attr("id", this.id);

			this._updateGesture();
		},
		_makeInvisible: function() {
			this._ensure$$dismiss();

			this.$$dismiss.removeClass(this.attachedSide).css(this.attachedSide, 0);
			this.$$dismiss.removeClass("s-m-ctrl");
			this.$$dismiss.attr("id", null);

			this.$$container.hide();
			this.$$elmt.hide(); // Do not only show/hide the container but also the panel since one container can be used by several panels!
		},
		_ensure$$dismiss: function() {
			this._ensure$$container();
			this.$$dismiss = this.$$container.parent().find(".s-m-side-panel-dismiss");
		}
	});