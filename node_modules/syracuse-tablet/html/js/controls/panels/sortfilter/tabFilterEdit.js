"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var formController = require('syracuse-tablet/html/js/controllers/formController');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');
var Dataset = require('syracuse-tablet/html/js/sdata/dataset').Dataset;
var modules = require('syracuse-tablet/html/js/common/modules');


var _templates = {
	main: '\
		<section id="formtabroot">\
			<div class="s-m-scroll-wrapper">\
				<div id="formtabform"/>\
			</div>\
			<div class="btn-group btn-group-justified" role="group">\
				<a type="button" class="btn btn-default" data-params="cancelFilterEdit">\
					<i class="fa fa-times" data-params="cancelFilterEdit"></i>\
				</a>\
				<a type="button" class="btn btn-default disabled" data-params="submitFilterEdit">\
					<i class="fa fa-check" data-params="submitFilterEdit"></i>\
				</a>\
			</div>\
		</section>'
};


var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

var _buildOperatorsEnum = function(operators) {
	var res = [];
	$.each(operators, function(idx, op) {
		res.push({
			$value: op,
			$title: locale.text("field.operator." + op)
		});
	});
	return res;
};

var FormKlass = utils.defineClass(
	function(proto, dao, filtersMap, $$formParent) {
		formController.Klass.call(this, utils.readableuid("FILTERFORM"), proto, null, dao, {
			$activity: "edit"
		});
		this.$$formParent = $$formParent;
		this.filtersMap = filtersMap;
	}, formController.Klass, {
		destroy: function() {
			formController.Klass.prototype.destroy.call(this);
		},
		// user changes Input value 
		setValue: function($bind, value) {
			var self = this;
			switch ($bind) {
				case "FIELDS":

					// nothing to do. user selected "select field" option
					if (value == 0) {
						// set button validate disabled
						this._toggleSave(false);
						return;
					} else {
						// set button validate enabled
						this._toggleSave(true);
						var fm = self.filtersMap[value - 1];
						// UPDATE OPERATORS CHOICE CTRL & VALUE FIELD TYPE

						// build new enum
						var operators = fm.operators;
						var $newEnum = _buildOperatorsEnum(operators);

						var newData = {
							"$properties": {
								"OPERATORS": {
									"$value": {
										$enum: $newEnum
									},
									$isReadOnly: false
								}
							},
							"OPERATORS": $newEnum[0].$value
						};
						// hide previously displayed value field
						if (self.keyToHide) {
							newData.$properties[self.keyToHide] = {
								$isHidden: true
							};
						}
						// For reference fields, meta-data ($properties) is given by the field that contains the data
						//var keyToShow = fm.isReference ? fm.id : "VALUE-" + fm.id;
						var keyToShow = "VALUE-" + fm.id;
						newData.$properties[keyToShow] = {
							$isHidden: false
						};
						self.keyToHide = keyToShow;

						// apply change
						window.setTimeout(function() {
							self.applyChange($.extend(true, {}, newData));
						});
					}
					break;
				case "OPERATORS":
					// TODO handle specific operators such as "between", "empty", "not empty"
					formController.Klass.prototype.setValue.call(this, $bind, value, true)
					break;
				default:
					formController.Klass.prototype.setValue.call(this, $bind, value, true)
			}
		},
		// check that data is set
		validateForm: function() {
			var self = this;
			var res = true;
			this.forEachControl(function(ctrl, idx) {
				var bind = ctrl.$bind;
				res = (bind && (bind !== "OPERATORS" || bind !== "FIELDS" || bind !== self.keyToHide)) ? (res ? ctrl.validateInput() : res) : res
			});
			return res;
		},
		applyChange: function(newData) {
			formController.Klass.prototype.applyChange.call(this, newData);
			this._toggleSave(newData != null && !$.isEmptyObject(newData));
		},
		render: function($$parent, buildOpts) {
			formController.Klass.prototype.render.call(this, $$parent, buildOpts);
			this._toggleSave(false);
		},
		_toggleSave: function(enable) {
			$("a[data-params='submitFilterEdit']", this.$$formParent).toggleClass("disabled", !enable);
		}
	});
/**
 * Filter edit tab
 */
exports.TabFilterEdit = utils.defineClass(
	function(parentTab) {
		this.controller = null;
		this.$$content = $(_getHtml("main", {}));
		this.$$formtabform = this.$$content.find("#formtabform");
		this.parentTab = parentTab;
		this.panel = parentTab.panel;
	}, null, {
		destroy: function() {
			if (this.controller) {
				this.controller.destroy();
				this.controller = null;
			}
			this.$$content = null;
			this.$$formtabform = null;
			this.parentTab = null;
			this.panel = null;
			this.panel = null;
		},
		/**
		 * Create content
		 */
		create: function($$container) {
			var self = this;

			if (self.$$content.parent().length == 0) {
				$$container.append(self.$$content);
			}

			self.$$formtabform.empty();

			var protoJson;
			var dataJson;

			var res = self._buildProtoJson();
			protoJson = res.protoJson;
			dataJson = res.dataJson;


			var proto = formController.createProto(protoJson, null, self.panel.parentArray.prototype.data("$baseUrl"));
			var dataset = new Dataset(dataJson, proto);

			self.controller = new FormKlass(proto, dataset, self.filtersMap, self.$$content);
			self.controller.render(self.$$formtabform, {});
			self.updateGesture();
			if (self.initData) {
				window.setTimeout(function() {
					// Enable save if a filter exists
					self.controller.applyChange($.extend(true, {}, self.initData), true);
					self.controller.keyToHide = self.initKeyToHide;
				});
			}

		},
		updateGesture: function() {
			this.parentTab.updateGesture();
		},
		_getFiltersMap: function() {
			var self = this;
			self.filtersMap = self.filtersMap || self.panel.filterMapGet();
			return self.filtersMap;
		},
		_buildProtoJson: function() {
			var self = this;

			var choiceData = {};

			self.filtersMap = self._getFiltersMap();

			// init json
			var protoJson = {
				"$properties": {
					"FIELDS": {
						"$title": locale.text("panels.array.filterForm.field"),
						"$type": "application/x-choice",
						"$value": {
							"$type": "application/x-integer",
							"$enum": []
						},
						"$isMandatory": true
					},
					"OPERATORS": {
						"$title": locale.text("panels.array.filterForm.operator"),
						"$type": "application/x-choice",
						"$value": {
							"$type": "application/x-string",
							"$enum": []
						},
						"$isReadOnly": true
					}
				},
				$localization: self.panel.parentArray.prototype.root.getValueByPath("$localization")
			};

			for (var ii = 0, jj = self.filtersMap.length; ii < jj; ii++) {

				var ff = self.filtersMap[ii];
				var key = "VALUE-" + ff.id;
				protoJson.$properties[key] = {
					$title: locale.text("panels.array.filterForm.value"),
					$type: ff.prop.$type,
					$isHidden: true,
					$item: ff.prop.$item,
					$value: ff.prop.$value
				};
				if (ff.isReference) {
					protoJson.$properties[ff.prop.$bindValue] = {
						$type: protoJson.$properties[ff.prop.$bindType],
						$isHidden: true,
						$isExcluded: true
					};
				}
				// in case of application/x-choice field, first value must be added to init dao
				if (ff.prop.$type.indexOf("choice") >= 0) {
					choiceData[key] = ff.prop.$value.$enum[0].$value;
				} else if (ff.prop.$type.indexOf("boolean") >= 0) {
					choiceData[key] = true;
					protoJson.$properties[key].$format = "$switch";
				}
			}


			// set fields choice ctrl values
			// protoJson.$properties.FIELDS.$value.$enum
			var $fieldEnum = [];
			$fieldEnum.push({
				$value: 0,
				$title: locale.text("panels.array.filterForm.fieldDefault")
			});
			$.each(self.filtersMap, function(idx, ff) {
				$fieldEnum.push({
					$value: idx + 1,
					$title: ff.fieldName
				});
			});
			protoJson.$properties.FIELDS.$value.$enum = $fieldEnum;

			// set operators choice ctrl default value
			// protoJson.$properties.OPERATORS.$value.$enum
			var $operatorDefEnum = [];
			var operators = fieldOperators.getOperators();
			protoJson.$properties.OPERATORS.$value.$enum = _buildOperatorsEnum(operators);

			var result = {
				protoJson: protoJson,
				dataJson: choiceData
			};

			return result;
		},
		/**
		 * Save sort info
		 */
		doActionApply: function() {
			if (!this.controller) {
				return $.smResolve(true);
			}
			if (!this.controller.checkControlsData()) {
				modules.get("modal").error("Data are invalid");
				return $.smResolve(false);
			} else {
				modules.get("modal").info("Data are valid");
				return this.panel.savePagePrefs().then(function() {
					return true;
				});
			}
		},
		doContentAction: function(evt, $$target, params) {
			var self = this;
			switch (params) {
				case "submitFilterEdit":
					self.onFilterEditSubmit();
					break;
				case "cancelFilterEdit":
					self.onCancelEdit();
					break;
			}
		},
		/*
		 * If user submits filter edit, update filter tab info,
		 */
		onFilterEditSubmit: function() {
			var self = this;
			if (self.controller.validateForm()) {
				// build filterInfo object with the following format
				/* {
					filterMapIdx: 'index in filterMap array',
					fieldName: "fieldName",
					operatorLabel: "operator label",
					value: "value to filter by",
					operator: "filter operator"
					id: "field code",
					prop: "field $value object"
				}
				*/
				self.filtersMap = self._getFiltersMap();
				var data = self.controller.dataset.getData();
				var fieldId, value, prop
				Object.keys(data.$properties).forEach(function(propertie) {
					if (propertie != "OPERATORS") { //only one
						fieldId = propertie;
						value = data[propertie];
					}

				});
				var filterMapIdx = -1,
					idx = 0
				self.filtersMap.forEach(function(filter) {
					if (fieldId === "VALUE-" + filter.id) {
						filterMapIdx = idx;
					}
					idx++
				})
				var operator = self.controller.dataset.getValue('OPERATORS');
				var prop = self.filtersMap[filterMapIdx].prop;

				var info = {
					filterMapIdx: filterMapIdx,
					fieldName: self.filtersMap[filterMapIdx].fieldName,
					operatorLabel: locale.text("field.operator." + operator),
					value: self._getValue(prop, value),
					operator: operator,
					id: self.filtersMap[filterMapIdx].id,
					prop: prop,
					originalValue: value,
					isReference: self.filtersMap[filterMapIdx].isReference
				};
				self.filterTab = self.filterTab || self.panel.getTabs().filter;
				self.filterTab.onFilterUpdate(info, !isNaN(parseInt(self.initIdx, 10)) && self.initIdx >= 0 ? self.initIdx : null);
				self._onTabClose();
			}
		},
		/* 	get value to be displayed in filter list (text value)
		 * 	this is particularly useful in case of application/x-choice fields
		 */
		_getValue: function(prop, value) {
			var self = this;
			var vv;
			if (typeof value === 'object') {
				vv = value.$value || value.$description || value.$title;
			} else {
				// in case of application/x-choice item, 
				// value to display should be $title of $enum if $value.$type -> 'application/x-integer'
				// else, value parameter is already ok
				if (prop.$type.indexOf("choice") >= 0) {
					vv = prop.$value.$type.indexOf("integer") >= 0 ? self.panel.parentArray.prototype.resolveExpression(prop.$value.$enum[parseInt(value - 1, 10)].$title) : value;
				} else {
					vv = value;
				}
			}
			return vv;
		},
		/*
		 * If user cancels filter edit, hide form and show filters list
		 */
		onCancelEdit: function() {
			var self = this;
			self._onTabClose();
			self.parentTab.toggleList(true);
		},
		/*
		* Create init data for that will be used to create the filter edit
		* init data JSON structure is {
			"FIELDS": "index among enum, as a string",
			"OPERATORS": "operator value",
			"VALUE": "filter value"
		}

		info parameter JSON structure is {
			filterMapIdx: 'index in filterMap array',
			fieldName: "fieldName",
			operatorLabel: "operator label",
			value: "value to filter by",
			operator: "filter operator"
			id: "field code",
			prop: "field $value object"
		}
		*/
		setInitData: function(info, initIdx) {
			var self = this;

			self.filtersMap = self._getFiltersMap();

			// get idx
			var filterMapIdx = info.filterMapIdx;
			var ff = self.filtersMap[filterMapIdx];

			// build init data
			self.initData = {
				$properties: {
					OPERATORS: {
						$value: {
							$enum: _buildOperatorsEnum(ff.operators)
						},
						$isReadOnly: false
					}
				},
				FIELDS: filterMapIdx + 1,
				OPERATORS: info.operator
			};

			if (ff.isReference) {
				self.initData[ff.id] = info.originalValue.$value;
			}
			self.initData["VALUE-" + ff.id] = info.originalValue;
			// For reference fields, meta-data ($properties) is given by the field that contains the data
			var bind = "VALUE-" + ff.id;
			self.initData.$properties[bind] = {
				$isHidden: false
			};

			self.initIdx = initIdx;

			// bind key will be used by the formController
			self.initKeyToHide = bind;
		},
		/*
		 * Cleaning actions
		 */
		_onTabClose: function() {
			var self = this;
			self.controller && self.controller.destroy();
			self.controller = null;
			self.initData = null;
			self.initIdx = null;
		}
	});