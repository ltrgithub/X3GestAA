"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var Base = require('syracuse-tablet/html/js/controls/panels/aside/panelAsideBase').PanelAsideBase;
var locale = require('syracuse-tablet/html/js/helpers/locale');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _Sort = require('syracuse-tablet/html/js/controls/panels/sortfilter/tabSort').TabSort;
var _Filter = require('syracuse-tablet/html/js/controls/panels/sortfilter/tabFilter').TabFilter;
var _Memo = require('syracuse-tablet/html/js/controls/panels/sortfilter/tabMemo').TabMemo;

var _templates = {
	main: '\
			<nav class="nav-header">\
				<nav class="title">\
					<div >{{title}}</div>\
				</nav>\
				<div class="btn-group header-btn" role="group">\
					<a type="button" class="btn btn-default ' + fontUtils.sortFilterTab("memo") + '" data-params="memo"></a>\
					<a type="button" class="btn btn-default ' + fontUtils.sortFilterTab("apply") + '" data-params="apply"></a>\
				</div>\
			</nav>\
			<ul class="nav nav-pills" role="tablist"> \
				{{#each tabs}}\
					<li><a href="#{{id}}" class="" role="tab" data-toggle="tab">{{title}}</a></li> \
				{{/each}}\
			</ul> \
			<div class="tab-content">\
				{{#each tabs}}\
					<div id="{{id}}" role="tabpanel" class="tab-pane {{type}}">\
					</div>\
				{{/each}}\
			</div>',
};


var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};

var _tabDescr = [{
	klass: _Sort,
	options: {
		name: "sort",
		isActive: true,
		singleCriteria: true,
	}
}, {
	klass: _Filter,
	options: {
		name: "filter",
		isActive: false,
	}
}, {
	klass: _Memo,
	options: {
		name: "memo",
		isActive: false
	}
}];

/**
 * Arrays Sort/Filter panel
 * Options
		filter: 		false to hide filter tab
		sort: 			false to hide sort tab
 */
exports.PanelFilterSort = utils.defineClass(
	function PanelFilterSort(controller, $type, article, options) {
		options = options || {};
		// Scroller is managed by tabs
		options.enableGesture = false;
		this._tabs = {};
		Base.call(this, controller, $type, article, options);
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this._activeTab = null;
			var self = this;
			notifications.unsubscribe(self, ["sm.click.icon.filterSort"]);
			if (this._tabs) {
				$.each(this._tabs, function(key, value) {
					value.destroy();
				});
				this._tabs = null;
			}
			if (this.$$btnBar) {
				this.$$btnBar.unbind();
				this.$$btnBar.remove();
				this.$$btnBar = null;
			};
			this.parentArray = null
		},
		/**
		 * Build panel and tabs html
		 */
		buildHtml: function(side) {
			var self = this;
			notifications.subscribe(self, ["sm.click.icon.filterSort"]);
			Base.prototype.buildHtml.call(this, side);
			self.$$elmt.addClass(self.typeName);
			if (self.$$panel) {
				self.$$panel.remove();
			}
			var ctx = {
				title: locale.text("panels.array.title"),
				ctrlId: self.id,
				side: side,
				apply: locale.text("panels.array.apply"),
				close: locale.text("panels.array.close"),
				/* There's no titles for queries*/
				tabs: [],
			};
			var descriptions = [];
			/**
			 * We can disable filter or sort with self.options.filter = false or  self.options.sort
			 */
			_tabDescr.forEach(function(descr) {
				descr = $.extend({}, descr);
				descr.options.hidden = self.options[descr.options.name] === false;
				descriptions.push(descr);
			});
			var ids = {};
			descriptions.forEach(function(descr) {
				ids[descr.options.name] = utils.readableuid("array" + descr.options.name);
				ctx.tabs.push({
					id: ids[descr.options.name],
					//title: descr.title || locale.text("panels.array." + descr.options.name),
					icon: fontUtils.sortFilterTab(descr.options.name),
					type: descr.options.name,
					buttons: descr.options.buttons,
					title: locale.text("panels.array." + descr.options.name),
				});
			});
			self.$$panel = $(_getHtml("main", ctx));
			if (self.$$panel && self.$$panel.length) {
				self.$$panelContent.append(self.$$panel);
				var visibleTabs = [];
				var activeIdx = -1;
				// Create tabs
				descriptions.forEach(function(descr, idx) {
					var t = new descr.klass(self, ids[descr.options.name], descr.options);
					if (descr.options.hidden) {
						t.hide();
					} else {
						visibleTabs.push(t);
						if (descr.options.isActive) {
							activeIdx = idx;
						}
					}
					self._tabs[descr.options.name] = t;
				});
				if (visibleTabs.length > 0) {
					this._activeTab = visibleTabs[activeIdx === -1 ? 0 : activeIdx];
					// Adjust width
					var width = visibleTabs.length === 1 ? "100%" : Math.round(1000 * 100 / visibleTabs.length) / 1000 + "%";
					visibleTabs.forEach(function(t) {
						t.setWidth(width);
					});
					self.$$btnBar = self.$$panelContent.find('.nav-header>.btn-group.header-btn');
					self.$$btnBar.on('click', '[data-params]', jsutils.bindFn(self.onBtnBarClick, this));
				} else {
					this.close();
				}
			}
		},
		/**
		 * Notification when panel is opened/closed
		 * Pass event to tabs
		 */
		notifyToggled: function(visible) {
			$.each(this._tabs, function(id, tab) {
				tab[visible ? "notifyOpenPanel" : "notifyClosePanel"]();
			});
			if (visible && this._activeTab) {
				this._activeTab.triggerActivate();
			}
		},
		onResize: function(context) {
			Base.prototype.onResize.call(this, context);
			if (this.destoyed || !this._tabs) return;
			$.each(this._tabs, function(id, tab) {
				tab.onResize(context);
			});
		},
		onBtnBarClick: function(evt) {
			evt.preventDefault();
			evt.stopPropagation();
			var $$target = $(evt.target);
			var params = $$target.attr("data-params");
			switch (params) {
				case "apply":
					this.applyTabSettings();
					break;
				case "memo":
					this.addFavorite();
					break;
			}
		},
		// Redirect apply button event to active tab
		applyTabSettings: function() {
			var self = this;
			if (!this._activeTab) {
				return;
			}
			this._activeTab.doActionApply()
				.then(function(close) {
					if (close) {
						self.hide();
					}
				});
		},
		// Collect data of every tab and send it to memo management tab
		addFavorite: function() {
			if (!this._activeTab) {
				return;
			}
			var favData = null;
			$.each(this._tabs, function(key, tab) {
				// Does panel contribute to favorites item?
				if (tab.getFavoritesData) {
					favData = favData || {};
					favData[key] = tab.getFavoritesData();
				}
			});
			if (favData) {
				favData.title = locale.text("panels.array.memo") + " " + utils.getCurISODateTime();
				var memoTab = this._tabs["memo"];
				memoTab.addFavorite(favData);
			}
		},
		notifyActiveTab: function(tab) {
			this._activeTab = tab;
			this.setButtonsState(true, true);
		},
		/*
		 *	Returns panel tabs
		 */
		getTabs: function() {
			return this._tabs;
		},
		notifClickIconFilterSort: function(context) {
			if (context && context.className) {
				if (context.className.indexOf("sorted") >= 0) {
					this.getTabs()["sort"].triggerActivate();
				} else if (context.className.indexOf("filtered") >= 0) {
					this.getTabs()["filter"].triggerActivate();
				}
			}
		},
		setButtonsState: function(memo, apply) {
			this.$$btnBar.find("[data-params='memo']").toggleClass("disabled", !memo);
			this.$$btnBar.find("[data-params='apply']").toggleClass("disabled", !apply);
		},
		getPagePrefs: function() {
			return this.parentArray.page.getPageSettings();

		},
		savePagePrefs: function() {
			// async write settings
			return this.parentArray.page.writePageSettings().then(function() {
				return true
			});
		},
		///
		/// END: Rendering
		///
		show: function() {
			if (!this.$$elmt) {
				this.buildHtml("right");
			}
			this._makeVisible();
			this.notifyToggled(true)
		},
		hide: function() {
			this._makeInvisible();
		},
		ensureParentArray: function(parentArrayId) {
			this.parentArray = this.controller.getControl(parentArrayId)
		},
		filterInfoGet: function() {
			return this.parentArray.filterSort.filterInfoGet()
		},
		filterInfoSet: function(info, refresh) {
			this.parentArray.filterSort.filterInfoSet(info, refresh)
		},
		filterMapGet: function() {
			return this.parentArray.filterSort.filterMapGet()
		},
		sortInfoGet: function() {
			return this.parentArray.filterSort.sortInfoGet()
		},
		sortInfoSet: function(info, refresh) {
			this.parentArray.filterSort.sortInfoSet(info, refresh)
		}
	});