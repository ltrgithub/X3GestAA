"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var PageLoader = require('syracuse-tablet/html/js/application/pageLoader').Klass;
var pageRegistry = require('syracuse-tablet/html/js/application/pageRegistry');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("app");
var locale = require('syracuse-tablet/html/js/helpers/locale');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');
var Gadget = require('syracuse-tablet/html/js/application/gadget').Klass;

var _actionTitleMgr = {
	action: "togglePinVignette",
	/**
	 * Allows vignetteCtrl to add title to cell/tile
	 * Returns true if action bar found
	 */
	iconActionAdd: function(vignetteCtrl) {
		if (vignetteCtrl._$$actionIcon) {
			// We store the icon to not add it multiple time
			return true;
		}
		var icon = fontUtils.getPinVignetteIcon("off") || "";
		var iconBarCtrl = _actionTitleMgr.getIconBarCtrl(vignetteCtrl);
		if (!iconBarCtrl || icon.length === 0) {
			return false;
		}
		iconBarCtrl.$$header.addClass("s-m-has-act-icon").attr({
			"data-action": _actionTitleMgr.action,
			"data-control-id": vignetteCtrl.id
		}).append($('<i class="s-m-tile-act ' + icon + '" style="float:right"/>'));
		if (vignetteCtrl.controller.isDashboard("hub")) {
			iconBarCtrl.$$elmt.css("padding-top", iconBarCtrl.$$header.height() + "px");
		}
		vignetteCtrl._$$actionIcon = _actionTitleMgr.iconActionToggleStatus(vignetteCtrl, "off");
		return true;
	},
	/**
	 * Allows vignetteCtrl to toggle the status of the action's icon
	 * status on/off
	 */
	iconActionToggleStatus: function(vignetteCtrl, status) {
		status = status || "off";
		var iconBarCtrl = _actionTitleMgr.getIconBarCtrl(vignetteCtrl);
		if (!iconBarCtrl) return;
		// We need to force it because of default tile color which is hard coded
		//	(vignetteCtrl._currentPage.isEditMode() ? iconBarCtrl.$$header : iconBarCtrl.$$elmt).toggleClass("s-m-color-" + globals.CELLENABLEDCOLOR, status === "on");
		iconBarCtrl.$$header.toggleClass("s-m-color-" + globals.CELLENABLEDCOLOR, status === "on");
		var $$res = iconBarCtrl.$$header.find('i.s-m-tile-act');
		$$res.removeClass(fontUtils.getPinVignetteIcon("all")).addClass(fontUtils.getPinVignetteIcon(status));
		return $$res;
	},
	/**
	 * Returns the parent controls that handles the icon bar
	 * tile or cell
	 */
	getIconBarCtrl: function(vignetteCtrl) {
		var ctrl = vignetteCtrl.parent;
		if (!ctrl || !ctrl._ensureHeader || !ctrl.$$elmt) return null;
		// creates header
		ctrl._ensureHeader();
		return ctrl;
	}
};
var _waitConfig = {
	className: 'waiting-blocks',
	elements: 5,
	auto: true,
	speed: 200
};
var _templates = {
	main: '\
		<section/>\
		<footer style="display:none"/> \
		<div class="s-m-waiting bckg" style="display:none"/> \
		<div class="s-m-waiting wheel" style="display:none"/> \
	',
	iframe: '\
		<br><iframe src="{{url}}" style="position: absolute; top: 0px; left: 0px; height: 100vh; width: 100vh;"/>\
	',
	navbtns: '\
		<span data-action="vignetteBack" class="' + fontUtils.vignetteIcons("back") + '" style="display:none"></span>\
		<span  data-action="vignetteHome" class="' + fontUtils.vignetteIcons("home") + '" style="display:none"></span>\
	',
	vignetteError: '\
		<a draggable="false" href="#" data-action="vignetteError">{{text}}</a>\
	',
	linkPage: '\
		<div draggable="false" href="{{href}}"\
			class="s-m-link-page">\
				{{#if icon}}\
					<section class="s-m-icon">\
						<div>\
							<div class="{{icon}}"></div>\
						</div>\
					</section>\
				{{/if}}\
				<section class="s-m-title">\
					<div>{{title}}</div>\
				</section>\
		</div>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};


var _Klass = utils.defineClass(

	function VignetteBase(controller, article, prototype, opts) {
		article.$article = article.$article || {};
		Base.call(this, controller, article, prototype, opts);
		this._currentPage = null;
		this._pageLoader = null;
		this._$$wait = null;
		this._stateStack = [];
		this._error = null;
		this.displayStyle = prototype.data("$displayStyle");
		this.openLinkInVignette = globals.$config("openLinkInVignette");
		this._actionsEnabled = false;
	}, Base, {
		destroy: function() {
			this.destroyActionControls();
			this._error = null;
			// First - destroy all pages attached to the vignette - Otherwise removing this.$$elmt removes all data (smPageController) in children
			this.clearContent();
			if (this._$$wait) {
				uiUtils.waitPluginDestroy(this._$$wait);
			}
			if (this._pageLoader) {
				this._pageLoader.destroy();
				this._pageLoader = null;
			}
			this._$$actionIcon = null;
			Base.prototype.destroy.call(this);
		},
		clearContent: function() {
			if (this._currentPage) {
				// Current page
				this._currentPage.destroy();
				this._currentPage = null;
			}
			if (this._$$content) {
				// cached pages and all pending pages if navigation allowed in the vignette
				globals.getApplication().removeAllChildPages(this._$$content);
				this._$$content.empty();
			}
			this._stateStack = [];
		},
		/**
		 * If vignette contains a page return the control object identified by id
		 */
		getPageControl: function(ctrlId) {
			return this._currentPage && this._currentPage.getControl && this._currentPage.getControl(ctrlId);
		},
		getPageLayout: function(id) {
			return this._currentPage && this._currentPage.getLayout && this._currentPage.getLayout(id);
		},
		getPageStructElmt: function(id) {
			return this.getPageControl(id) || this.getPageLayout(id);
		},
		getPage: function() {
			return this._currentPage;
		},
		onMainPageResize: function(info, orientation, deviceClass) {
			if (this._actionsEnabled && info.deviceChanged) {
				// Disable
				this._doTogglePinVignette(false);
				// Destroy controls to force create new ones - smartphone: headerControl - tablet: footerControl
				this.destroyActionControls();
			}
			if (this._currentPage == null || this._currentPage.state.options.$displayStyle !== "$full") return;
			this._currentPage.onMainPageResize(info, orientation, deviceClass);
		},
		/**
		 * Change current page - called from eventListener
		 * 	data-nav action has been clicked in a vignette's link
		 * 	we could have a parameter that indicates if the link has to be opened full page or inside the vignette
		 */
		changePage: function(state, options) {
			options = options || {};
			// Propagate openLinkInVignette to child page - used to open reflinks...
			options.openLinkInVignette = this._openLinkInsideVignette();
			// Always full page
			options.$displayStyle = "$full";
			this._loadPage("openNewPage", state, options);
		},
		/**
		 * Refresh current page - called from eventListener
		 */
		refreshPage: function(options) {
			var self = this;
			if (!self._currentPage) throw new Error("No current page");
			if (self._error) this._removeError();
			self._currentPage.refresh(options, {
				waitWheelStart: function(controlId) {
					// Wait managed by vignette
					self.waitWheelStart();
				},
				waitWheelStop: function(controlId) {
					self.waitWheelStop();
				}
			}).then(function() {
				//	Eventually do something in vignette control	
			}).fail(function(e) {
				modal.error(locale.text("err.load.main"), e);
			});
		},
		hasBtnsBar: function() {
			return this._openLinkInsideVignette();
		},
		_openLinkInsideVignette: function(state) {
			if (this.openLinkInVignette === true) return true;
			var name;
			if (state == null) {
				name = this._currentPage ? this._currentPage.state.name : null;
			} else if ($.isPlainObject(state)) {
				name = state.name;
			} else {
				name = state;
			}
			if (typeof name === "string" && (name === "rowdetail" || name === "carddesign" || name.smEndsWith("$lookup"))) {
				this.openLinkInVignette = true;
			}
			if (this._currentPage && this._currentPage.isChild) this.openLinkInVignette = true;;
			return this.openLinkInVignette;
		},
		/**
		 * Mainly used by authoring to reload the page
		 * Returns a promise
		 */
		reloadPage: function(loadOptions) {
			if (!this.$displayStyle === "$full" || !this._currentPage) {
				return $.smResolve();
			}
			this._reloadSavedCtx = null;
			if (loadOptions && loadOptions.authoringUpdate === true && this.getPage()) {
				// Save the current context (scroll)
				this._reloadSavedCtx = this.getPage().savedCtxCreate();
			}
			var pageInfo = $.extend(true, {}, this._currentPage.state);
			this.clearContent();
			if (!this._pageLoader) {
				this._initPageLoader();
			}
			var self = this;
			return $.smResolve().then(function() {
				return self._pageLoader.load(pageInfo, false, loadOptions);
			}).fail(function(e) {
				self._displayError(locale.text("error.page.loading"), e);
			});
		},
		/**
		 * Load a page
		 * 	state
		 * 				state of the  page - stored in page object
		 * 	pageOptions
		 * 				options of the  page - stored in page object
		 * 	action: 	back for a back in vignette actions
		 * 				home for a home in vignette actions
		 * 	loadOptions
		 * 				updateLayout...
		 */
		_loadPage: function(action, state, pageOptions, loadOptions) {
			var self = this;
			self._error = null;
			if (!self._pageLoader) {
				self._initPageLoader();
			}
			var step;
			if (action === "back" || action === "home" || (action === "openNewPage" && typeof state === "object")) {
				step = $.smResolve(state);
			} else if (action === "openNewPage" && typeof state === "string") {
				// Read page info
				pageOptions = pageOptions || {};
				pageOptions.vignette = true;
				var articleCopy = pageOptions.vignetteArticle; // Backup of original article, this MUST NOT be cloned
				step = pageRegistry.getPageInfo(state, pageOptions, self._currentPage)
					.then(function(pageInfo) {
						pageInfo.options = pageInfo.options || {};
						if (articleCopy) {
							pageInfo.options.vignetteArticle = articleCopy;
						}
						// Pass the parentVignette to the page
						pageInfo.options.parentVignette = self;
						return pageInfo;
					});
			} else {
				throw new Error("Unexpected object state");
			}
			return step.then(function(pageInfo) {
				if (pageInfo.options && pageInfo.options.$displayStyle === "$full") {
					// action "home" is not a back. It's like an open page because we want to store the state in history
					return self._pageLoader.load(pageInfo, action === "back", loadOptions);
				} else if (pageOptions.gadget) {
					var gadget = new Gadget(pageOptions.gadget);
					var icon = self._getCssIcon(gadget, "s-m-sage-gadget-icon");
					var attrs = {
						"data-nav": pageInfo.name,
						"data-gadget-id": gadget.data("$uuid"),
						"data-application-name": gadget.data("applicationName"),
						"title": self.article && self.article.$article && self.article.$article.$title ? self.article.$article.$title : gadget.data("$title"),
						"icon": icon
					};
					if (pageInfo.options.$displayStyle === "$link" && self.article && self.article.$linkArticle) {
						// Used by test entities to pass an article to the page
						attrs["data-link-article"] = self.id;
					}
					self._addPicker(attrs);
					return $.smResolve();
				} else {
					throw new Error("Unexpected vignette page");
				}
			}).fail(function(e) {
				self._displayError(locale.text("error.page.loading"), e);
			});
		},

		_initPageLoader: function() {
			var self = this;
			/**
			 * Page loader shared with application
			 * Load a page
			 */
			self._pageLoader = new PageLoader({
				waitWheelStop: function() {
					self.waitWheelStop();
				},
				waitWheelStart: function() {
					self.waitWheelStart();
				},
				getRootElmt: function() {
					return self._$$content;
				},
				getCurrentPage: function() {
					return self._currentPage;
				},
				setCurrentPage: function(page) {
					self._currentPage = page;
					if (page != null) {
						// $full vignettes must be notified if a create/edit vignette takes the focus in order to toggle selection
						notifications.subscribe(self, ["sm.field.focus"]);
					} else {
						notifications.unsubscribe(self, ["sm.field.focus"]);
					}
				},
				historyPush: function(state) {
					// Add state in stack in all case - We need it for link to row Detail
					self._stateStack.push(state);
				},
				succeeded: function(dstPage, pageToClose, parentNotifInfo, back, loadOptions) {
					if (!self.controller) return; //Vignette destroyed before end of load process
					if (self.hasBtnsBar()) {
						self.refreshBtnsBar();
					}
					if (parentNotifInfo && parentNotifInfo.notifId) {
						/**
						 * _notifyController  to notify only the page
						 */
						if (dstPage.id === parentNotifInfo.parentId) {
							notifications.notifyController(parentNotifInfo.notifId, self._currentPage, parentNotifInfo.notifData, parentNotifInfo.controlId);
						} else {
							modal.error("Child page notification warning", "Parent page is not the current page");
						}
					}
					// page has been loaded - Used to prevent multiple onresize calls to current page
					log && log("vignette loaded" + self.id);
					// Call resize handler each time a page has been loaded for calculations
					if (dstPage.state.options.$displayStyle === "$full") {
						/* setTimeout to resize dstPage after current process - #5737*/
						self._initActionDashboard(dstPage);
						setTimeout(function() {
							// Propagate load options
							var info = $.extend(true, {}, loadOptions);
							info.updateLayout = back === true || (loadOptions && loadOptions.updateLayout);
							dstPage.onMainPageResize(info);
						});
					}
				},
				loadingError: function(deferred, state, e) {
					self._displayError(locale.text("error.page.loading"), e);

					// No reject
					deferred.resolve(null, e);
				},
				/**
				 * Specific interface method for vignettes
				 * Returns the context of a page nested in a vignette and also context of the vignette (selection)
				 * Called by the pageLoader after the vignette has been displayed
				 */
				getSavedCtxVignette: function() {
					if (self._reloadSavedCtx != null) {
						// Restore the current context (scroll)
						var ctx = self._reloadSavedCtx;
						self._reloadSavedCtx = null;
						return ctx;
					}
					// It's the dashboard that manage the storage when we load a vignette
					if (!self.controller) {
						//Page has been destroyed before calling this method
						// If we have multiple vignettes and we click a link before all vignettes has been displayed we get this case
						return;
					}
					// The context has been saved before loading the vignettes and stored in self.controller(dashboard)
					return self.controller.getSavedCtxVignette(self);
				}
			});
		},
		/**
		 * If multiselection is enabled for the page we enable the switch of footer
		 * An icon in tile/cells's title allows the user to swicth the current footer by the one of the nested page (dstPage)
		 */
		_initActionDashboard: function(dstPage) {
			if (!dstPage) return;
			if (dstPage.isChild) {
				// Child page - wee add the actionControl
				this._updateActionControl();
			} else {
				// hasFooterHeaderActions(true) to enable action only if we declared footerHeader action in authoring
				// eg: all the query have a $create and we do'nt want to allow $create in vignettes - Only if we add $creatin in 'Action control' authoring
				this._typeAction = dstPage.isMultiSelectionEnabled() ? globals.ACTMULTISEL : dstPage.hasFooterHeaderActions(true) ? "footerHeader" : null;
				if (this._typeAction == null) return;
				this.openLinkInVignette = this._typeAction === "footerHeader";
				// True is action are allowed  - multiselection or crud
				this._actionsEnabled = _actionTitleMgr.iconActionAdd(this);
				notifications[this._actionsEnabled ? "subscribe" : "unsubscribe"](this, ["sm.vignette.pinned", "sm.multisel.stopped"]);
			}
		},
		/**
		 * Disables the vignette if we stop multi-selection (download)
		 */
		notifMultiselStopped: function(pageId) {
			// MultiselStopped notifies all the vignettes - In a dashboard it's only the vignette that embeds the page (pageId) that processes the event
			if (this._currentPage == null || this._currentPage.id !== pageId) return;
			if (!this._actionsEnabled || !this._actionControl) return;
			this._doTogglePinVignette(false);
		},
		/**
		 * Click on icon in tile/cells's header
		 */
		_actTogglePinVignette: function() {
			if (!this._actionControl) {
				// If the current vignette doesn't have the focus we disable the vignette which as the focus (notification)
				//!! notifications is synchrounous - We must disable the current enabled tile/cell (if any) before enabling
				notifications.publish("synch.sm.vignette.pinned", this.id);
			}
			// Toggles current vignette status after
			this._doTogglePinVignette();
		},
		/**
		 * Toggle the status of vignettes other than the vignette that has publihed the notification
		 */
		notifVignettePinned: function(skipThisId) {
			if (this.id == skipThisId) return;
			if (!this._actionsEnabled || !this._actionControl) return;
			// disable the vignette
			this._doTogglePinVignette(false);
		},
		/**
		 * Focus on a field
		 * If it's a field of the vignette we enable the vignette otherwise we disable
		 */
		notifFieldFocus: function(control) {
			if (!control || !control.controller.isVignette) return;
			var enable = control.controller.getParentVignette() === this;
			if ((enable && this._actionControl) || (!enable && !this._actionControl)) return;
			this._doTogglePinVignette();
		},
		/**
		 * Toggle icon status and switchs the footer
		 * id is used to select only the current object when we notify synch.sm.vignette.pinned
		 * show:	true force show
		 * 			false hide
		 * 			undefined toggle status
		 */
		_doTogglePinVignette: function(show) {
			if (!this._actionsEnabled || !this._currentPage) return;
			// Disables the vignette that have the focus and switchs current status
			//show =  show === false ? false :  show === true ? true : undefined;
			var status = show === false ? "off" : show === true ? "on" : this._actionControl ? "off" : "on";
			var controlToggle;
			var type = this.getTypeActionControl();
			if (status === "on") {
				this._actionControl = this._getActionControl(true);
				// We take the type header/footer depending on the device
				type = this.getTypeActionControl();
				controlToggle = this._actionControl;
			} else {
				if (!this._actionControl) {
					// nothing to restore
					return;
				}
				controlToggle = this._actionControl;
				// We take the type header/footer of the current control (can be different from current device when we switch device in developement mode)
				type = controlToggle.getPageControlType();
				this._actionControl = null;
			}
			// this._actionControl = null forces to restore the regular footer/header
			this.controller.toggleHeaderFooter(type, controlToggle, status === "on");
			// Toggle status and header icon
			_actionTitleMgr.iconActionToggleStatus(this, status);
		},
		/**
		 * Restore the right actionControl (footer/header) - used when navigation inside the vignette
		 */
		_updateActionControl: function() {
			if (!this._actionsEnabled) return;
			this._actionControl = this._getActionControl(true);
			this._doTogglePinVignette(true);
		},
		_getActionControl: function(create) {
			// _actionControlsCache because we can have multiple pages in a vignette
			// eg: Main page + child page (row detail..)
			// when we create X3 oject in vignettes we need to store the action control (header/footer) per page to restore it on back
			// id of control is the id of the page
			if (!this._actionControlsCache) this._actionControlsCache = {};
			var ctrl = this._actionControlsCache[this._currentPage.id];
			if (!ctrl && create) {
				ctrl = ctrlFactory.createActionControl(this.getTypeActionControl(), this, {
					multiSelectionOnly: this._typeAction === globals.ACTMULTISEL,
					//buildOpts are the one of the dashboard - #7932
					buildOpts: $.extend(true, {}, (this.controller.buildOpts || {}).toolBars)
				});
				this._actionControlsCache[this._currentPage.id] = ctrl;
			}
			return ctrl;
		},
		destroyActionControls: function() {
			if (!this._actionControlsCache || !this.controller) return;
			if (this._actionControl) {
				// remove from controller and restore regular one (null)
				this.controller.toggleHeaderFooter(this._actionControl.getPageControlType(), null);
			}
			var ctrl;
			for (var p in this._actionControlsCache) {
				ctrl = this._actionControlsCache[p];
				if (ctrl) {
					this.controller.removeControl(ctrl);
					ctrl.destroy();
				}
			}
			this._actionControl = this._actionControlsCache = null;
		},

		getTypeActionControl: function() {
			return globals.getSiteLayout().getDeviceType() === "smartphone" ? "header" : "footer";
		},

		_loadRepresentation: function(gadget, pageOptions, loadOptions) {
			var self = this;
			var name = gadget.getPageName();
			pageOptions = $.extend({}, pageOptions);
			pageOptions.openLinkInVignette = self._openLinkInsideVignette(name);
			pageOptions.$displayStyle = self.displayStyle;
			// !!pageOptions MUST contains only JSON (not class object) - Restore context
			pageOptions.gadget = gadget.getJSON();
			pageOptions.vignetteArticle = self.article.$article; // sub article in case the layout of a vignette is defined in the dashboard layout
			// authoring properties of the page are stored by the vignette ($actionSettings..) and passed to  the page when we create the article
			// it's better to pass them independently from vignetteArticle to be able to merge them with a generated article if any
			pageOptions.vignetteAuthPageProps = {};
			utils.authCopyPageProperties(self.article, pageOptions.vignetteAuthPageProps);
			return self._loadPage("openNewPage", name, pageOptions, loadOptions);
		},

		_displayError: function(msg, detail) {
			var self = this;
			self._error = {
				message: msg,
				detail: detail
			};
			if (self.$$elmt) {
				self._$$content.hide();
				self.$$elmt.addClass("s-m-error");
				self.$$elmt.prepend(_getHtml("vignetteError", {
					text: locale.text("vignette.load.failed")
				}));
				self.refreshBtnsBar();
			} else {
				globals.getModal().actionResult(locale.text("error.page.loading"), self._error, true);
			}
		},

		_removeError: function() {
			this.$$elmt.children('a[data-action="vignetteError"]').remove();
			this.$$elmt.removeClass("s-m-error");
			this._$$content.show();
			this._error = null;
		},

		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			if (self._stateStack.length > 0) {
				// There could be cached pages

			} else {
				Base.prototype.buildHtml.call(self, $$parent, controllerDao, buildOptions, ["s-m-vignette"]);
				self.$$elmt.html(_getHtml("main", {}));
				self._$$content = self.$$elmt.children("section");
				self.$$footer = self.$$elmt.children("footer");
				self._$$waitBckg = self.$$elmt.children(".s-m-waiting.bckg");
			}
		},

		/**
		 * First load of the page
		 */
		load: function(vignetteId, pageOptions, loadOptions) {
			var self = this;
			// id that identify the vignette dahsboardName + vignette index
			self.vignetteId = vignetteId;
			pageOptions = pageOptions || {};

			var deferred = $.Deferred();

			var _finalize = function(page, error) {
				deferred.resolve(page, error);
				if (page != null) {
					// With stack layout the content (height) of the controller depends on vignette's size
					// We need to notify the controller to update the scroller - see #6401
					notifications.notifyController("sm.scroller.update", self.controller, self.id, page, error);
				}
			};
			var _fail = function(e) {
				self._displayError(locale.text("error.page.loading"), e);
				// Deferred is not rejected because error is displayed in the vignette
				_finalize();
			};
			try {
				var gadget = new Gadget(self.prototype.getVignetteGadget());
				if (gadget && gadget.isValid()) {
					if (pageOptions.resize === true) {
						// Always clear content if resize to rebuild a new one
						this.clearContent();
					}
					switch (gadget.data("$type")) {
						case "$representation":
						case "$stats":
						case "$request":
							self._loadRepresentation(gadget, pageOptions, loadOptions)
								.then(function(page, error) {
									_finalize(page, error);
								})
								.fail(function(e) {
									_fail(e);
								});
							break;
						case "$dashboard":
							self._loadDashboard(gadget);
							_finalize();
							break;
						case "$application":
							self._loadApplication(gadget);
							_finalize();
							break;
						case "$external":
							self._loadExternal(gadget);
							_finalize();
							break;
						case "$gadgetMissing":
							self._displayError(locale.text("vignette.load.gadget.missing", [gadget.data("$uuid")]));
							_finalize();
							break;
						default:
							self._displayError(locale.text("vignette.load.gadget.unsupported", [gadget.data("$type")]));
							_finalize();
							break;
					}
				} else {
					self._displayError(locale.text("vignette.load.gadget.invalid", gadget && gadget.getInvalidReason() ? [gadget.getInvalidReason()] : "Unknown reason"));
					_finalize();
				}
			} catch (e) {
				_fail(e);
			} finally {
				return deferred.promise();
			}
		},

		_getCssIcon: function(gadget, sageBaseCss) {
			var icon = gadget.data("icon") || this.article && this.article.$icon;
			if (icon) {
				if (icon.smStartsWith("s-m-")) {
					// our own gadget icons
					icon = sageBaseCss + " " + icon;
				} else {
					// FontAwesome
					icon = fontUtils.getIconByName(icon);
				}
			}
			return icon || "";
		},

		_loadDashboard: function(gadget) {
			this._addPicker({
				"data-nav": globals.getMetaData().getDashboardPageName(gadget.data("dashboardName")),
				"data-application-name": gadget.data("applicationName"),
				"data-gadget-id": gadget.data("$uuid"),
				"data-sdata-parameters": gadget.data("sdataParameters"),
				"title": gadget.data("$title"),
				"icon": this._getCssIcon(gadget, "s-m-sage-gadget-icon")
			});
		},

		_loadApplication: function(gadget) {
			this._addPicker({
				"data-application-name": gadget.data("applicationName"),
				"title": gadget.data("$title"),
				"icon": this._getCssIcon(gadget, "s-m-sage-app-icon"),
			});
		},

		_loadExternal: function(gadget) {
			var self = this,
				url = gadget.data("externalUrl");
			self._addPicker({
				"data-external-link": url,
				"title": gadget.data("$title")
			});
			if (self.displayStyle !== "$link") {
				var iFrame = _getHtml("iframe", {
					url: url
				});
				$(iFrame).appendTo(self._$$content);
			}
		},

		_addPicker: function(context) {
			// #8095 we add the link attributes to parent (tile/cell/stack) to have the whole area sentive/clickable
			var linkAttrs = {
				"data-nav-target": "application"
			};
			var vignetteCtx = {};
			for (var p in context) {
				if (p.smStartsWith("data-")) {
					linkAttrs[p] = context[p];
				} else {
					vignetteCtx[p] = context[p];
				}
			}
			$(_getHtml("linkPage", vignetteCtx)).appendTo(this._$$content);
			(this.parent.$$elmt || this.$$elmt).attr(linkAttrs);
		},

		waitWheelStart: function() {
			var self = this;
			if (!self._$$wait) {
				self._$$wait = uiUtils.waitPluginCreate(self.$$elmt.children(".s-m-waiting.wheel"), _waitConfig).wrap('<div class="s-m-wait-root"/>');
			}
			uiUtils.waitPluginEnable(this._$$wait);
			this._$$waitBckg.show();
		},
		waitWheelStop: function() {
			if (this._$$wait) {
				uiUtils.waitPluginDisable(this._$$wait);
			}
			this._$$waitBckg.hide();
		},

		refreshBtnsBar: function() {
			if (this._openLinkInsideVignette()) {
				var show = false;
				if (!this.$$icnBack) {
					this.$$footer.prepend(_getHtml("navbtns"));
					this.$$icnBack = this.$$footer.children("[data-action=vignetteBack]");
					this.$$icnHome = this.$$footer.children("[data-action=vignetteHome]");
				}
				var l = this._stateStack.length;
				this.$$icnBack.toggle(l > 1);
				this.$$icnHome.toggle(l > 2 && !this._currentPage.prototype.isLookup());
				show = this._stateStack.length > 1;
				this.$$footer.toggle(show);
				this.$$elmt.toggleClass("footer", show);
			}
		},
		/**
		 * Return a promise - Resolve with the displayed page
		 */
		_actVignetteHome: function() {
			var self = this;
			if (self._stateStack.length == 0) return $.smResolve(this._currentPage);
			var state = self._stateStack[0];
			self._stateStack = []; // to force clearContent
			return self._loadPage("home", state).then(function(page, error) {
				self._updateActionControl();
				return $.smResolve(page);
			});
		},
		/**
		 * Return a promise - Resolve with the displayed page
		 */
		_actVignetteBack: function() {
			var self = this;
			if (self._stateStack.length <= 1) return $.smResolve(this._currentPage);
			self._stateStack.pop();
			// !!! true for BACK in order to unstack the current page
			return self._loadPage("back", self._stateStack[self._stateStack.length - 1]).then(function(page, error) {
				self._updateActionControl();
				return $.smResolve(page);
			});
		},
		// Allows call from extern module 
		goBack: function() {
			return this._actVignetteBack();
		},
		// Allows call from extern module 
		goHome: function() {
			return this._actVignetteHome();
		},
		_actVignetteError: function() {
			var self = this;
			if (self._error.detail) {
				modal.error(self._error.message, self._error.detail);
			} else {
				modal.error("Vignette load error", self._error);
			}
		},
		_actVignetteRefresh: function() {
			this.refreshPage({});
		},
		isOverflow: function() {
			if (!this._currentPage) return;
			return (this._currentPage.$$elmt.height() - this.$$elmt.height()) > 0;

		},
		getScrollViewRect: function() {
			return uiRect.elmtRect(this._$$content, "inner");
		},
		isVignette: function() {
			return true;
		},
		// Only for test entities - We can attache an article to a $link vignette
		getLinkedPageArticle: function() {
			return this.article ? this.article.$linkArticle : null;
		}
	});

exports.Klass = _Klass;