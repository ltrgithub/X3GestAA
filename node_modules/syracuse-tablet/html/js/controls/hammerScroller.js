"use strict";

var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("scroll");
var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');


var _getMainPageOffset = function() {
	//return globals.getCurrentPage().getScrollOffset();
	return {
		top: globals.getCurrentPage().rootLayout.$$elmt.scrollTop(),
		left: globals.getCurrentPage().rootLayout.$$elmt.scrollLeft()
	};
};
// Time to wait before allowing click events a scrolling
var _lastClickTO = 500;
// Bottom/right margin  - we scroll _margin pixels more that the height/width of viewRect
var _margin = 0;
// Enable the slowdown process - scroll continue after panend (mouse up ) like on native devices
var _slowDown = true;
// Move the $$elmt after _slowDownTO in slowdown process
var _slowDownTO = 30;
/**
 * Creates a vertical scroller which emulates the tablet native behavior
 * 		$$elmt		element to scroll
 * 		$$callBack	Optional Called on event and skip default process
 * 		valMax		maximum top - 0 by default - 50 for pages with header...
 */
var _consts = {
	pan: {
		v: "panup pandown panstart panend",
		h: "panleft panright panstart panend"
	},
	dir: {
		v: Hammer.DIRECTION_VERTICAL,
		h: Hammer.DIRECTION_HORIZONTAL
	},
	upEvt: {
		v: "panup",
		h: "panleft"
	}
};
var _Klass = utils.defineClass(function hammerScroller($$elmt, direction, valMax, callBack) {
	this.hammer = null;
	this.$$elmt = $$elmt;
	this.callBack = callBack;
	// Max top always 0 because we scroll in relative / parent - If needed pass it in parameter
	this.valMax = valMax != null ? valMax : 0;
	// Direction of scroller
	this.dir = direction;
	if (this.dir !== "v" && this.dir !== "h") throw new Error("hammerScroller - Unexpected direction [" + this.dir + "]");
	// event than means up or right
	this.upEvtType = _consts.upEvt[this.dir];
}, null, {
	/**
	 * We need to initialize the scroll after creation
	 * Scrollable object arrays/pages have an empty scroll which is initialized if needed
	 * Initialization needs to be called when the object has been displayed (after show) to make sure that viewRect is ok
	 * To manage savedCtxRestore it's also the better way
	 * 		- save ctx (top)is stored and take into account at initialization
	 * Params
	 * 		viewRect		rectangle (uiUtils/rect class) of the view within we will move the content of $$elmt
	 * 						!!!top/left must be in fixed coordinates (relative to document)
	 * 						in order to be able to check if mouse pointer belongs to this rect on mousemove/pandown
	 */
	init: function(viewRect) {
		// before reset - this.val != null is context restored
		var restoredVal = this.val;
		this.reset();
		// viewRect defines the boundaries
		this.viewRect = viewRect;
		this.hammer = new Hammer(this.$$elmt.get(0));
		// We need pan and not swipe
		this.hammer.get("pan").set({
			direction: _consts.dir[this.dir]
		});
		this.hammer.on(_consts.pan[this.dir], Hammer.bindFn(this.onPan, this));
		// We need press to stop the scolling
		this.hammer.get("press").set({
			time: 10 //Small timeout needed to stop immediately when press
		});
		this.hammer.on("press", Hammer.bindFn(this.onPress, this));
		this._clickHandler = Hammer.bindFn(this.onClick, this);
		// We need to filter click events to control the triggering of links
		this.$$elmt.on('click', this._clickHandler);
		if (false) {
			// Debug show the rectangle - fixed position 
			viewRect.showInDocument(2000);
		}
		this.val = restoredVal == null ? this.valMax : restoredVal;
		// Just to find elmt with debugger
		this.$$elmt.addClass("s-m-scroll" + this.dir);
		this.refresh();
	},
	/**
	 * Disable scroll but keep the capability to re-initialize it
	 */
	reset: function() {
		this.viewRect = null;
		// True if panstart - mouse start to move
		this.panStart = false;
		// True if the scroll is slowing down after panend (mouse up)
		this.slowingDown = false;
		// Cancel click on a link
		this.cancelClick = false;
		//Prevent click after _lastClickTO ms after a panend
		this.lasClickAllowed = null;
		// Null to force to set value on init ( context restored)
		this.val = null;
		// Null to force to set value on pan event
		this.valMin = null;
		if (this._clickHandler) {
			this.$$elmt.off('click', this._clickHandler);
			this._clickHandler = null;
		}
		if (this.hammer) this.hammer.destroy();
		this.hammer = null;
		this.$$elmt.removeClass("s-m-scroll" + this.dir);
	},
	/**
	 * Destroy scroller
	 */
	destroy: function() {
		this.reset();
		this.$$elmt = null;
		this.callBack = null;
	},
	/**
	 * Refresh scrolling
	 * 	internal call or called to refresh scrolling when we activate cached pages
	 */
	refresh: function() {
		if (this.dir == "v") {
			this.$$elmt.css({
				top: this.val + "px"
			});
		} else {
			this.$$elmt.css({
				left: this.val + "px"
			});
		}
	},
	/**
	 * Intercept click events for filtering
	 */
	onClick: function(evt) {
		log && log("onClick Status", this.slowingDown, this.panStart, this.cancelClick, this.lasClickAllowed ? new Date().getTime() - this.lasClickAllowed : null);
		var cancel = true;
		if (evt.type === "click" && this.slowingDown === false && this.cancelClick === false) {
			// Click is authorized if not slowingDown or if not cancelClick
			// We wait _lastClickTO after panend (mouseup) to allow click
			cancel = this.lasClickAllowed != null ? (new Date().getTime() - this.lasClickAllowed) < 0 : false;
		}
		if (cancel) {
			log && log("Cancel click");
			evt.stopPropagation();
			evt.preventDefault();
		} else {
			this.lasClickAllowed = null;
			log && log("LINK ALLOWED");
		}
		if (evt.type === "click") this.cancelClick = false;
	},
	/**
	 * Used to stop the slowdown process
	 */
	onPress: function(evt) {
		log && log("onPress Status", this.slowingDown, this.panStart, this.cancelClick);
		if (this.slowingDown) {
			this.slowingDown = false;
			// Last click is avoided - The click evt that is always triggered after press a event
			this.cancelClick = true;
			// Wait _lastClickTO to allow click
			this.lasClickAllowed = new Date().getTime() + _lastClickTO;
		}
	},
	/**
	 * pan event - mousedown/mousemove/mouseup
	 */
	onPan: function(evt) {
		// console.log(evt)
		if (!utils.isEvtDirection(evt, this.dir)) return;
		try {
			if (this.valMin == null) {
				// We initialize this.val here because I noticed that $$elmt.height could be wrong if we in constructor
				// To check again - Maybe it comes from image that are loaded async - We need to set fix width/height for images		
				var prop = this.dir == "v" ? "height" : "width";
				this.valMin = this.valMax - this.$$elmt[prop]() - _margin + this.viewRect[prop];
			}
			if (!this.viewRect.isEvtInside(evt.srcEvent, _getMainPageOffset())) {
				// outside the viewRect -> Stop process
				log && log("outside");
				return;
			}
			if (evt.type === "panstart") {
				// Mouse mousedown + mousemove event - start the process
				log && log(evt.type);
				this.panStart = true;
				this.cancelClick = true;
				this.slowingDown = false;
			} else if (evt.type === "panend") {
				// mouseup  - we continue to scroll (_slowDown) until the user do a press event to stop scrolling
				log && log(evt.type);
				this.panStart = false;
				if (_slowDown && this.lastVelocity != null) {
					// We keep the last velocity for slowdown process
					this.lastVelocity = Math.abs(this.lastVelocity);
					if (this.lastVelocity > 0.3 && this.lastVelocity < 1) {
						// If velocity is too small we keep 1
						this.lastVelocity = 1;
					} else {
						// under.3 we consider that we need to stop scrolling
						this.lastVelocity = Math.min(this.lastVelocity, 2);
					}
					if (this.lastVelocity >= 1) {
						// _slowDown option continue the process by decreasing the speed slowly and moving $$elmt
						this.slowingDown = true;
						this.slowDown(this.lastVelocity, this.lastUp);
						this.lastVelocity = this.lastUp = null;
					}
				} else {
					this.lasClickAllowed = new Date().getTime() + _lastClickTO;
				}
				return;
			}
			// Direction of the scroll
			// Up means up or right 
			var up = evt.type === this.upEvtType || evt.type === "panstart" && evt.deltaY < 0;
			if (this.move(evt.velocity, up)) {
				this.lastVelocity = Math.abs(evt.velocity);
				this.lastUp = up;
			} else {
				this.lastVelocity = this.lastUp = null;
			}
		} catch (e) {
			log && log(JSON.stringify(jsutils.convertToDiagnoses("hammer scroller error", e), null, 2));
			this.destroy();
			return false;
		}
	},
	/**
	 * Keep the last speed to continue scrolling process until the user do a press evt
	 */
	slowDown: function(v, up) {
		var self = this;
		if (self.panStart || !self.slowingDown) {
			this.slowingDown = false;
			return;
		}
		// keep the same velocity - to improve - we can decrease...
		if (v < 1) {
			this.slowingDown = false;
			return;
		}
		if (self.move(v, up)) {
			// Move until stop with _slowDownTO timeout
			setTimeout(function() {
				self.slowDown(v, up);
			}, _slowDownTO);
		} else {
			this.slowingDown = false;
		}
	},
	/**
	 * Move $$elmt vertically
	 */
	move: function(velocity, up) {
		try {
			// Velocity of the move - 0 if we move the finger slowly and ~ 2 for fast
			var v = Math.abs(Math.round(velocity * 5));
			// Distance to move - square function of velocity (non linear) 
			// Allow to move slow and fast if we increase the speed of the finger
			var dist = Math.max(1, v * v / 2);
			if (dist == 0) return;
			// Check boundaries
			var val = up ? this.val - dist : this.val + dist;
			val = Math.max(Math.min(this.valMax, val), this.valMin);
			if (val === this.valMax || val === this.valMin) {
				this.lasClickAllowed = new Date().getTime() + _lastClickTO;
				if (this.val === val) {
					// Overflow -> Stop
					// log && log("move overflow")
					return false;
				}
			}
			this.val = val;
			if (this.callBack) {
				return this.callBack(this.val);
			} else {
				// Move elmt
				this.refresh();
				return true;
			}
		} catch (e) {
			log && log("Page VerticalScroller onMove Error - disable scroll");
			log && log(JSON.stringify(jsutils.convertToDiagnoses("VScrolling error", e), null, 2));
			this.destroy();
			return false;
		}
	},
	// Save context if enabled
	savedCtxCreate: function() {
		return this.hammer ? {
			val: this.val
		} : null;
	},
	// Restored context
	savedCtxRestore: function(ctx, refresh) {
		if (ctx == null || ctx.val == null) return;
		// Set val - if refresh == false that means that we need to call init method 
		this.val = ctx.val;
		if (refresh) {
			// By example called by a cached pages which has been activated
			this.refresh();
		}
	}
});

exports.Klass = _Klass;