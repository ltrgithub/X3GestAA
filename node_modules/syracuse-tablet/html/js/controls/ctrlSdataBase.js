"use strict";

var Base = require('syracuse-tablet/html/js/controls/ctrlBase').CtrlBase;

var globals = require('syracuse-tablet/html/js/app/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var native = require('syracuse-tablet/html/js/helpers/native/native');
var eventListener = require('syracuse-tablet/html/js/app/eventListener');
var environment = require('syracuse-tablet/html/js/helpers/environment');

/**
 * Base class for all controls
 * Main purpose is to register with the controller
 */
exports.CtrlSdataBase = utils.defineClass(
	function CtrlSdataBase(controller, article, prototype, options) {
		// Set $bind before calling super ctor because super ctor will register $bind with controller!
		this.$bind = article.$bind;

		Base.call(this, controller, prototype.getType(), article, options);
		this.prototype = prototype;
		this.$isEditMode = controller.isEditMode();
		this._nativeCapabilities = this._initNativeCapabilities(options);
	}, Base, {
		destroy: function() {
			var self = this;
			Base.prototype.destroy.call(self);

			// Do not call prototype.destroy here
			// the control uses the prototype but destruction is done on higher level
			// is is possible a prototype is reused (e.g. same proto for several array items)
			self.prototype = null;
		},
		createId: function(typeName) {
			// Add $bind in id for readability - Id can be minimized in non debug version
			return utils.readableuid(this.$bind, typeName.substr(0, 3));
		},

		//
		// END: Start 
		//
		/**
		 * controllerDao is the page dao or the row data for a grid
		 * 	We need to store it to keep acces
		 */
		buildHtml: function(classes) {
			classes = classes || [];
			classes.push("s-m-control");
			classes.push("s-m-ctrl");

			var $theme = this.getAuthoring("$theme");
			if ($theme && $theme !== "none") {
				classes.push("s-m-theme-" + $theme);
			}

			this.createRootElement(classes);

			if (environment.isAutoUITestMode()) {
				environment.getUnitTestMgr().addBindAttribute(this);
			}
		},
		afterRender: function() {},
		/**
		 * Applies meta-data
		 */
		applyMetaData: function(metaData) {
			// Must be managed optionally in subclasses
		},
		//
		// END: Rendering 
		//

		//
		// START: Sdata 
		//
		/**
		 * dao.getMetaData does the merge between prototype and data
		 * metaProp		optional - name of the meta $readonly...
		 * 				if null returns all the meta
		 */
		getMetaData: function(metaProp) {
			var meta = this.controller.getMetaData(this.$bind);
			return meta && (metaProp ? meta[metaProp] : meta);
		},
		getTitle: function() {
			var ttl = (this.article && this.article.$title) || this.prototype.getValueByPath("$title", true) || "";
			if (ttl.length === 0 && globals.isAuthoringActive() && this.prototype.isFacet("details", "edit")) {
				// #7148- It's better to display title if no title and force the user to hide them in authoring mode
				ttl = this.$bind;
			}
			return ttl;
		},
		getSdataLinkAttrs: function($linkName) {
			return eventListener.getSdataLinkAttrs(this.controller.id, $linkName, this.$bind);
		},
		getDataActionAttrs: function(action, params) {
			return eventListener.getDataActionAttrs(this.controller.id, action, params);
		},
		//
		// END: Sdata
		//

		//
		// START: Testing
		//
		getUnitTestId: function() {
			if (this.$bind) {
				return utils.unitTestId(this.$bind);
			} else {
				return utils.unitTestId(this.typeName);
			}
		},
		//
		// END: Testing
		//
		//
		// START: Native capabilities
		//
		_initNativeCapabilities: function(options) {
			if (!options || !options.nativeCapabilities) return null;
			var res = {};
			for (var capability in options.nativeCapabilities) {
				res[capability] = options.nativeCapabilities[capability] === true && native.hasCapability(capability) === true;
			}
			return res;
		},
		getNativeCapabilities: function() {
			return this._nativeCapabilities;
		}
	}
);

/**
 * Used to generate the html of control Icon/Button
 * generate a link and call cb to get the content of the control (icon/button...)
 * cb	Add html text to html param
 */
function _genHtmlCtrlLink(proto, dao, options, cb) {
	var self = this;
	options = options || {};
	var html = [];
	var url = proto.data("$url");
	var tag = options.tag || 'a';
	var css = options.css || 'a';
	if (url && url.length) {
		html.push('<');
		html.push(tag);
		html.push(' href="' + url + '"');
		if (css) {
			html.push(' class="' + css + '"');
		}
		html.push('>');
	} else {
		// attributes for data-nav or data-action
		var action = proto.data("$action") || self.prototype.data("$navigation");
		if (action) {
			html.push('<');
			html.push(tag);
			html.push(' href="#"');
			for (var p in action) {
				html.push(' ' + p + '="' + encodeURIComponent(dao ? dao.parseExpression(action[p]) : action[p]) + '"');
			}
			if (css) {
				html.push(' class="' + css + '"');
			}
			html.push('>');
		}
	}
	if (cb) cb(html);
	if (html.length > 1) {
		html.push('</');
		html.push(tag);
		html.push('>');
	}
	return html.join('');
};

exports.genHtmlCtrlLink = _genHtmlCtrlLink;