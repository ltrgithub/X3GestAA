"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/array/builderBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');

var _tfootPagin = function($$tbl, nbCols, nbRecords) {
	this.nbRecords = Math.max(0, nbRecords);
	this.$$root = $('<tfoot><tr><td colspan="' + nbCols + '"></td></tr></tfoot>').appendTo($$tbl);
	this.$$text = this.$$root.find("td");
	this.update = function(idx) {
		this.$$root.removeClass().addClass("s-m-card-pagin");
		if (this.nbRecords > 0 && idx >= 0 && idx < this.nbRecords) {
			this.$$text.html("Page " + (idx + 1) + "/" + this.nbRecords);
			if (idx === this.nbRecords) {
				this.$$root.addClass("s-m-first");
			} else if (idx === 0) {
				this.$$root.addClass("s-m-last");
			}
		}
	};
};

var _captionPagin = function($$tbl, nbCols, nbRecords) {
	this.nbRecords = Math.max(0, nbRecords);
	this.$$root = $('<caption/>').appendTo($$tbl);
	this.update = function(idx) {
		this.$$root.removeClass().addClass("s-m-card-pagin");
		if (this.nbRecords > 0 && idx >= 0 && idx < this.nbRecords) {
			this.$$root.html("Page " + (idx + 1) + "/" + this.nbRecords);
			if (idx === this.nbRecords) {
				this.$$root.addClass("s-m-first");
			} else if (idx === 0) {
				this.$$root.addClass("s-m-last");
			}
		}
	};
};

/**
 * Vertical card builder
 * Authoring see ctrlArray
 */
var _Klass = utils.defineClass(
	function(control, options) {
		var self = this;
		Base.call(self, control, options);
		self._layoutRoot = null;
		self.cardsPerRow = self.$articleArray.$cardsPerRow;
		self.cardsPerRow = Math.min(20, Math.max(0, self.cardsPerRow == null ? 1 : parseInt(self.cardsPerRow, 10)));
	}, Base, {
		destroy: function() {
			var self = this;
			Base.prototype.destroy.call(self);
			if (self.hammer) self.hammer.destroy();
			self.hammer = null;
			if (self._layoutRoot) {
				self._layoutRoot.destroy();
				self._layoutRoot = null;
			}
		},
		onSwipePan: function(evt) {
			var self = this;
			var panInfo = this._panEvtInfo;
			var scale = 0.1;
			if (panInfo.deltaY == null) panInfo.deltaY = 0;
			var dy = Math.abs(evt.deltaY);
			// Delta in pixels since last event
			var delta = Math.abs(panInfo.deltaY - dy);
			// Nb rows to move
			var count = Math.round(scale * delta);
			//console.log(evt.distance, delta, "count = " + count, delta);
			if (count === 0) return;
			// Save last state
			panInfo.deltaY = dy;
			// Index to start to move rows
			if (self._curIdx == null) self._curIdx = 0;
			var lastidx = self._curIdx;
			if (evt.type === "panup") {
				var newIdx = Math.max(0, Math.min(panInfo.maxIdx, lastidx + count));
				for (var i = lastidx; i < newIdx; i++) {
					panInfo.$$trs[i].hide();
				}
			} else if (evt.type === "pandown") {
				var newIdx = Math.max(0, Math.min(panInfo.maxIdx, lastidx - count));
				for (var i = lastidx; i >= newIdx; i--) {
					panInfo.$$trs[i].show();
				}
			}
			// Save start idx
			self._curIdx = newIdx;
		},
		/**
		 * return all info to deal with pan event - scroll up/down
		 */
		_getPanEvtInfo: function() {
			var d = {
				parentHeight: this.control.$$elmt.parent().height(),
				bodyHeight: this.$$tbody.height(),
				bodyTop: this.$$tbody.position().top
			};
			d.bodyVisibleHeight = d.parentHeight - d.bodyTop;
			d.overFlow = (d.bodyHeight - d.bodyVisibleHeight > 0);
			if (d.overFlow > 0) {
				d.trHeight = this.$$tbody.children("tr:first-child").height();
				d.rsrcLen = this.control.getArrayData().$resources.length;
				d.maxIdx = Math.round(d.rsrcLen / this.cardsPerRow) - 1;
				d.$$trs = this.$$tbody.children("tr");
				// Store jquery object
				for (var i = 0; i < d.rsrcLen; i++) {
					d.$$trs[i] = $(d.$$trs[i]);
				}
			}
			return d;
		},
		afterShow: function() {
			var self = this;
			if (!self.control.isArrayField() && self.$$tbody) {
				self._panEvtInfo = self._getPanEvtInfo();
				if (self._panEvtInfo.overFlow) {
					if (self.hammer) self.hammer.destroy();
					self.hammer = new Hammer(self.$$tbody.get(0));
					self.hammer.get("pan").set({
						direction: Hammer.DIRECTION_VERTICAL
					});
					self.hammer.on("pandown panup", function(ev) {
						self.onSwipePan(ev);
					});
					if (this._restoredScrollIdx != null) {
						// Restore the last scroll
						self._curIdx = self._restoredScrollIdx;
						for (var i = 0; i < self._restoredScrollIdx; i++) {
							self._panEvtInfo.$$trs[i].hide();
						}
					}
				}
			}
		},
		buildHtml: function(arrayData, buildOptions) {
			var self = this;
			Base.prototype.buildHtml.call(self, arrayData, buildOptions);
			if (!self.$article) return;
			if (!self._layoutRoot) {
				// Create HTML generator
				self._layoutRoot = articleParser.cardV2Controls(self.control);
			}
			self.$$tbl = $('<table/>').appendTo(self.$$value);
			var cardsPerRow = self.cardsPerRow;
			if (cardsPerRow > 1) {
				/* non need of header - used to create columns with same width*/
				var w = Math.round(100 / cardsPerRow);
				var wr = 100 - w * cardsPerRow;
				var $$tr = $("<thead><tr>").appendTo(self.$$tbl).children(":first-child");
				for (var i = 0; i < cardsPerRow; i++) {
					$("<th>").css({
						width: (i === cardsPerRow - 1 ? w + wr : w) + "%"
					}).appendTo($$tr);
				}
			}
			self.$$tbody = $("<tbody>").appendTo(self.$$tbl);
			if (self.control.isArrayField()) {
				/* array field in card mode - we display ONE card at a time and add swipe */
				self._curIdx = this._restoredScrollIdx ? this._restoredScrollIdx : 0;
				self.$$cardRow = $("<tr>").appendTo(self.$$tbody);
				self.updateCardRow(null, buildOptions);
			} else {
				/* Query/Lookup we display all cards in stack mode */
				var remaining = 0,
					$$row, $$cell;
				arrayData.$resources.forEach(function(rowData, idx) {
					remaining = idx % cardsPerRow;
					if (remaining === 0) $$row = $("<tr>").appendTo(self.$$tbody);
					$$cell = $(self.buildDetailLink(rowData, {
						tag: "td",
						parent: $$row,
						createIfNoLink: true
					}));
					self.callGenerateHtml(self._layoutRoot, $$cell, rowData, false, buildOptions);
				});
				self._addEmptyCells($$row, remaining, buildOptions);
			}
		},
		/**
		 * next		null	first card
		 * 			true	next card
		 * 			false	prev card
		 */
		updateCardRow: function(next, buildOptions) {
			try {

				var self = this;
				var rsrcs = self.control.getArrayData().$resources;
				var force = next == null;
				var idx = force ? 0 : next === true ? self._curIdx + 1 : self._curIdx - 1;
				if (idx < 0 || idx >= rsrcs.length) return;
				self._curIdx = idx;
				var rowData = rsrcs[idx];
				if (self.$$cardCell) self.$$cardCell.remove();
				if (!rowData) {
					self.$$cardCell = self._addEmptyCells(self.$$cardRow, 1, buildOptions);
				} else {
					self.$$cardCell = $(self.buildDetailLink(rowData, {
						tag: "td",
						parent: self.$$cardRow,
						createIfNoLink: true,
						css: "nohover"
					}));
					self.callGenerateHtml(self._layoutRoot, self.$$cardCell, rowData, false, buildOptions);
					if (rsrcs.length > 1) {
						if (!self._pagin) {
							// Display header in caption to keep the same Y coordinate the same place when we swipe
							// _tfootPagin displays pagin in footer but position changes according to card height
							self._pagin = new _captionPagin(self.$$tbl, 1, rsrcs.length);
						}
						// Add horizontal swipe evt
						if (self.hammer) self.hammer.destroy();
						//!! We need to recreate it afetr ecah swipe otherwise it doesn't work
						// $$value is not removed - I suppose that it's because we rebuild $value children...
						self.hammer = new Hammer(self.$$value.get(0));
						self.hammer.get("swipe").set({
							direction: Hammer.DIRECTION_HORIZONTAL
						});
						// listen to events...
						self.hammer.on("swipeleft swiperight", function(ev) {
							self.onSwipe(ev);
						});
						self._pagin.update(idx);
					}
				}
			} catch (e) {
				alert(e);
			}
		},
		onSwipe: function(evt) {
			var self = this;
			setTimeout(function() {
				self.updateCardRow(evt.type === "swipeleft");
			});
		},
		/**
		 * Return the context to save.
		 * It will be be restored afer page has been loaded
		 * The context is saved and restored by the page
		 * Stores the scroll index
		 */
		savedCtxCreate: function() {
			return {
				scrollIdx: this._curIdx
			};
		},
		/**
		 * Called by the page to restore the context
		 * Restores the scroll index
		 */
		savedCtxRestore: function(ctx) {
			this._restoredScrollIdx = ctx ? ctx.scrollIdx : 0;
		}
	});

exports.Klass = _Klass;