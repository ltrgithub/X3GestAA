"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/array/builderBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');

var _tfootPagin = function($$tbl, nbCols, nbRecords) {
	this.nbRecords = Math.max(0, nbRecords);
	this.$$root = $('<tfoot><tr><td colspan="' + nbCols + '"></td></tr></tfoot>').appendTo($$tbl);
	this.$$text = this.$$root.find("td");
	this.update = function(idx) {
		this.$$root.removeClass().addClass("s-m-card-pagin");
		if (this.nbRecords > 0 && idx >= 0 && idx < this.nbRecords) {
			this.$$text.html("Page " + (idx + 1) + "/" + this.nbRecords);
			if (idx === this.nbRecords) {
				this.$$root.addClass("s-m-first");
			} else if (idx === 0) {
				this.$$root.addClass("s-m-last");
			}
		}
	};
};

var _captionPagin = function($$tbl, nbCols, nbRecords) {
	this.nbRecords = Math.max(0, nbRecords);
	this.$$root = $('<caption/>').appendTo($$tbl);
	this.update = function(idx) {
		this.$$root.removeClass().addClass("s-m-card-pagin");
		if (this.nbRecords > 0 && idx >= 0 && idx < this.nbRecords) {
			this.$$root.html("Page " + (idx + 1) + "/" + this.nbRecords);
			if (idx === this.nbRecords) {
				this.$$root.addClass("s-m-first");
			} else if (idx === 0) {
				this.$$root.addClass("s-m-last");
			}
		}
	};
};

/**
 * Vertical card builder
 * Authoring see ctrlArray
 */
var _Klass = utils.defineClass(
	function(control, options) {
		var self = this;
		Base.call(self, control, options);
		self._layoutRoot = null;
	}, Base, {
		destroy: function() {
			var self = this;
			Base.prototype.destroy.call(self);
			if (self.hammer) self.hammer.destroy();
			self.hammer = null;
			if (self._layoutRoot) {
				self._layoutRoot.destroy();
				self._layoutRoot = null;
			}
		},
		buildHtml: function(arrayData, buildOptions) {
			var self = this;
			Base.prototype.buildHtml.call(self, arrayData, buildOptions);
			if (!self.$article) return;
			var cardsPerRow = self.$articleArray.$cardsPerRow;
			cardsPerRow = Math.min(20, Math.max(0, cardsPerRow == null ? 1 : parseInt(cardsPerRow, 10)));
			if (!self._layoutRoot) {
				// Create HTML generator
				self._layoutRoot = articleParser.cardV2Controls(self.control);
			}
			self.$$tbl = $('<table/>').appendTo(self.$$value);
			if (cardsPerRow > 1) {
				/* non need of header - used to create columns with same width*/
				var w = Math.round(100 / cardsPerRow);
				var wr = 100 - w * cardsPerRow;
				var $$tr = $("<thead><tr>").appendTo(self.$$tbl).children(":first-child");
				for (var i = 0; i < cardsPerRow; i++) {
					$("<th>").css({
						width: (i === cardsPerRow - 1 ? w + wr : w) + "%"
					}).appendTo($$tr);
				}
			}
			self.$$tbody = $("<tbody>").appendTo(self.$$tbl);
			if (self.control.isArrayField()) {
				/* array field in card mode - we display ONE card at a time and add swipe */
				self._curIdx = this._restoredScrollIdx ? this._restoredScrollIdx : 0;
				self.$$cardRow = $("<tr>").appendTo(self.$$tbody);
				self.updateCardRow(null, buildOptions);
			} else {
				/* Query/Lookup we display all cards in stack mode */
				var remaining = 0,
					$$row, $$cell;
				arrayData.$resources.forEach(function(rowData, idx) {
					remaining = idx % cardsPerRow;
					if (remaining === 0) $$row = $("<tr>").appendTo(self.$$tbody);
					$$cell = $(self.buildDetailLink(rowData, {
						tag: "td",
						parent: $$row,
						createIfNoLink: true
					}));
					self.callGenerateHtml(self._layoutRoot, $$cell, rowData, false, buildOptions);
				});
				self._addEmptyCells($$row, remaining, buildOptions);
			}
		},
		/**
		 * next		null	first card
		 * 			true	next card
		 * 			false	prev card
		 */
		updateCardRow: function(next, buildOptions) {
			try {

				var self = this;
				var rsrcs = self.control.getArrayData().$resources;
				var force = next == null;
				var idx = force ? 0 : next === true ? self._curIdx + 1 : self._curIdx - 1;
				if (idx < 0 || idx >= rsrcs.length) return;
				self._curIdx = idx;
				var rowData = rsrcs[idx];
				if (self.$$cardCell) self.$$cardCell.remove();
				if (!rowData) {
					self.$$cardCell = self._addEmptyCells(self.$$cardRow, 1, buildOptions);
				} else {
					self.$$cardCell = $(self.buildDetailLink(rowData, {
						tag: "td",
						parent: self.$$cardRow,
						createIfNoLink: true,
						css: "nohover"
					}));
					self.callGenerateHtml(self._layoutRoot, self.$$cardCell, rowData, false, buildOptions);
					if (rsrcs.length > 1) {
						if (!self._pagin) {
							// Display header in caption to keep the same Y coordinate the same place when we swipe
							// _tfootPagin displays pagin in footer but position changes according to card height
							self._pagin = new _captionPagin(self.$$tbl, 1, rsrcs.length);
						}
						// Add horizontal swipe evt
						if (self.hammer) self.hammer.destroy();
						//!! We need to recreate it afetr ecah swipe otherwise it doesn't work
						// $$value is not removed - I suppose that it's because we rebuild $value children...
						self.hammer = new Hammer(self.$$value.get(0));
						self.hammer.get("swipe").set({
							direction: Hammer.DIRECTION_HORIZONTAL
						});
						// listen to events...
						self.hammer.on("swipeleft swiperight", function(ev) {
							self.onSwipe(ev);
						});
						self._pagin.update(idx);
					}
				}
			} catch (e) {
				alert(e);
			}
		},
		onSwipe: function(evt) {
			var self = this;
			setTimeout(function() {
				self.updateCardRow(evt.type === "swipeleft");
			});
		},
		/**
		 * Return the context to save.
		 * It will be be restored afer page has been loaded
		 * The context is saved and restored by the page
		 * Stores the scroll index
		 */
		savedCtxCreate: function() {
			return this._panEvtInfo ? {
				scrollIdx: this._curIdx
			} : null;
		},
		/**
		 * Called by the page to restore the context
		 * Restores the scroll index
		 */
		savedCtxRestore: function(ctx) {
			this._restoredScrollIdx = ctx ? ctx.scrollIdx : 0;
		}
	});

exports.Klass = _Klass;