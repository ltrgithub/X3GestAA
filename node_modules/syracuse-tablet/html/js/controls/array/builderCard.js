"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/array/builderBase').Klass;
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var articleGen = require('syracuse-tablet/html/js/authoring/authoringArticleGen');
var HammerScroller = require('syracuse-tablet/html/js/helpers/hammerScroller').Klass;
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');
var layoutRow = require('syracuse-tablet/html/js/controls/layout/layoutRow');


/**
 * Vertical card builder
 * Authoring
 * 		$numberOfRows 			number of card s per row
 * 		$displayEmptyCells 		Display or not empty cells true by default
 */
var _Klass = utils.defineClass(
	function(control, disp, options) {
		Base.call(this, control, disp, options);
		this._layoutRoot = null;
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._layoutRoot) {
				this._layoutRoot.destroy();
				this._layoutRoot = null;
			}
			if (this._oneCardGestureMgr) {
				this._oneCardGestureMgr.destroy();
				this._oneCardGestureMgr = null;
			}
			this._$$body = null;
			this._$$cellTmpl = null;
			this._tds = null;
			if (!this._$$rows) {
				this._$$rows = null;
			}
		},
		/**
		 * Just build $$td cells
		 * Build of array will be done on resize because we need to have the height of the parent control.$$value to calculate the number of roww
		 */
		buildHtml: function(arrayData, buildOpts) {
			var self = this;
			this.$articleArray.$minWidth = this.$articleArray.$minWidth || 6;
			Base.prototype.buildHtml.call(self, arrayData, buildOpts);
			if (self._layoutRoot == null) {
				var cardArticle = self.$articleArray.$card;
				if (!cardArticle) {
					cardArticle = articleGen.genNewArticle({
						page: {
							prototype: self.control.prototype
						}
					}, true);
				};
				var options = {
					displayCtx: "card"
				};
				self._layoutRoot = articleParser.article2Controls(self.control.controller, cardArticle, self.$itemProto, options);
			}
			// Like we rebuild a new _$$body we have to destroy the scroller
			self.destroyScroller();
			self._$$body = $('<tbody>').appendTo($('<table/>').appendTo(self.control.$$value));
			var $$td;
			self._$$cellTmpl = $('<section class="s-m-card s-m-std"/>');
			var $$cell, $$root;
			self._tds = [];
			var statusInfo = this.control.getRowStatusInfo();
			arrayData.$resources.forEach(function(rowData, idx) {
				$$td = $(self.buildRecordMainElmt(rowData, {
					tag: "td",
					parent: null,
					createIfNoLink: true
				}, idx));
				$$root = $$cell = self._$$cellTmpl.clone().appendTo($$td);
				if (self.$arrayOptions.rowIndex === true) {
					$('<span class="badge index">' + (idx + 1) + '</span>').appendTo($$cell);
				}
				if (statusInfo) {
					$$root = self.checkStatusManagement($$td, statusInfo, $$cell, rowData);
				}
				self.callGenerateHtml(self._layoutRoot, $$root, rowData, false, buildOpts, idx);
				self._tds.push({
					"$$td": $$td,
					"$$card": $$cell
				});
			});
			if (this.isRefreshContext(buildOpts)) {
				// Force display because there's no resize
				self._build(buildOpts);
			} // Otherwise build is done on resize
		},
		checkStatusManagement: function($$td, statusInfo, $$cell, rowData) {
			if (!statusInfo) return;
			var $$newCell = $$cell;
			var $$rootIcon = $$cell.find(".s-m-status");
			if ($$rootIcon.length === 0) {
				$$rootIcon = $('<div class="s-m-status"/>').appendTo($$cell);
			}
			var nbBckg = 0;
			statusInfo.list.some(function(s) {
				if (s.color && fieldOperators.evaluateOperator(s.$type, rowData.getValue(s.field), s.operator, s.value)) {
					/**
					 * We need to set color and bg-color because using css property doesn't work due to css inheritance
					 * Using css forces to declare all css selectors (td:not(.s-m-multi-selected)...) for each color of the palette
					 */
					if (s.icon) {
						$('<div class="s-m-status-icon ' + s.icon.css + '" style="color:' + s.color.bgColor + '"/>').appendTo($$rootIcon);
						return statusInfo.type === "mono";
					} else if (s.color.css && nbBckg === 0) {
						//$$cell.css("padding", "0px");
						//$$newCell = $('<div class="s-m-status-color ' + s.color.css + '" style="padding:0px;width:100%;margin:0px">').appendTo($$cell);
						$$td.addClass('s-m-status-color ' + s.color.css);
						nbBckg++;
					}
					return statusInfo.type === "mono";
				}
			});
			return $$newCell;
		},
		onResize: function(context) {
			if (this.destroyed) return;
			// Used by multi-selection - we just want to refresh the scroll
			var scrollOnly = context != null && context.scrollOnly === true;
			if (scrollOnly !== true && this._layoutRoot && this._tds.length > 0) {
				/**
				 * We rebuild in any cases in order to have a good display
				 * To be able to calculate  parentH in nested pages we use table display for s-m-control and table-row for children
				 * --> In that case control.$$value has the right height
				 * For non nested paged table display doens't allow to calculate the height of the array without removing the old one...
				 * Other option was to check if $$value height changed to rebuild array
				 */
				var buildOpts = {
					updateLayout: context && context.updateLayout
				};
				this._build(buildOpts, context);
			} else {
				Base.prototype.onResize.call(this, context);
			}
		},
		/**
		 * !! check the multi-selection if we modify  _build
		 */
		_build: function(buildOpts, resizeContext) {
			if (!this.checkEmptyArray()) {
				return;
			}
			buildOpts = buildOpts || {};
			var dirArray = globals.getScrollingDirection() || "v";
			var initScroll = buildOpts.refresh === true || resizeContext;
			dirArray = this.control.isArrayField() ? "h" : dirArray === "h" ? "v" : "v"; //"h";
			if (!this.hasScroller() || this._dirArray == null || this._dirArray != dirArray) {
				this.newScroller(dirArray, this._$$body.parent());
				this._dirArray = dirArray;
				initScroll = true;
			}
			buildOpts.cardAuthoring = {
				$emptycell: this.$articleArray.$emptycell || "nodisplay",
				$minWidth: this.authMinSize2Pixels(this.$articleArray.$minWidth),
				$cardsPerRow: parseInt(this.$articleArray.$cardsPerRow, 10) || 2
			};
			if (!this._$$body) {
				// Sometimes the body can be empty - Ex when we exit multi-selection mode
				return;
			}
			var sz = this.control.getAvailableSize();
			var parentH = sz.height;
			var parentW = sz.width;
			// Border spacing used for calculation
			var bs = this._$$body.parent().css("border-spacing");
			if (bs) {
				bs = bs.split("px");
				bs = bs && bs.length > 0 ? parseInt(bs[0], 10) : 0;
			}
			//parentH = parentH - bs;
			//parentW = parentW - bs;
			var $$hiddenRow;
			var visibleTds = [];
			// We keep the $$td's to not recreate them and arrange according the new configuration
			// We first detach them and select the visible ones (used by multiselection)
			// We put non-visible ones in $$hiddenRow to let them available in the dom (used by multiselection)
			this._tds.forEach(function(o, idx) {
				// Clear the height/width because they are calculated according to the device/parent size
				o.$$card.css({
					height: "",
					width: ""
				});
				o.$$td.detach();
				if (o.$$td.css('display') != "none") {
					visibleTds.push(o);
				} else {
					if (!$$hiddenRow) {
						$$hiddenRow = $("<tr>").hide();
					}
					o.$$td.appendTo($$hiddenRow);
				}
			});
			// !! Call $$body after having detached $$td because empty() removes the data attached to the node ($.smData) used by multi-selection (diagnoses)
			this._$$body.empty();
			if ($$hiddenRow) {
				$$hiddenRow.appendTo(this._$$body);
			}
			if (visibleTds.length === 0) return;
			this["buildCard" + dirArray.toUpperCase()](visibleTds, bs, parentH, parentW, buildOpts);
			this.control.$$elmt.addClass("card" + dirArray.toUpperCase());
			var top = Math.max(0, (parentH - this._$$body.parent().outerHeight()) / 2);
			this._$$body.parent().css({
				top: top + "px"
			});
			this.doAfterBuild(resizeContext, initScroll);
		},
		/**
		 * Like the rows are not stored as controls (html generated) we get the $$row and apply the rocess to detect empty row
		 * Same process for the row layout
		 */
		checkEmptyRows: function($$card) {
			if (!this._$$rows) {
				this._$$rows = $$card.find(".s-m-row");
			}
			layoutRow.checkEmptyRows(this._$$rows);
		},
		buildCardV: function(visibleTds, bs, parentH, parentW, buildOpts) {
			this._$$body.parent().width("100%");
			var $$row, realW, nbCardPerRow;
			var minWidth = buildOpts.cardAuthoring.$minWidth;
			var remaining = 0;
			var self = this;
			visibleTds.some(function(o, idx) {
				if (idx === 0 || nbCardPerRow == 1 || (nbCardPerRow > 1 && idx % nbCardPerRow === 0)) {
					$$row = $("<tr>").appendTo(self._$$body);
					remaining = nbCardPerRow;
				}
				remaining--;
				o.$$td.appendTo($$row);
				if (idx === 0) {
					var padding = o.$$card.outerWidth() - o.$$card.width();
					nbCardPerRow = buildOpts.cardAuthoring.$cardsPerRow;
					while (nbCardPerRow > 1) {
						realW = Math.round((parentW - ((nbCardPerRow + 1) * bs)) / nbCardPerRow) - padding;
						if (realW >= minWidth) break;
						nbCardPerRow--;
					}
					if (nbCardPerRow > 1) {
						realW = Math.min(Math.max(minWidth, realW));
					}
				}
				if (nbCardPerRow > 1) {
					o.$$card.width(realW);
				} else {
					o.$$card.css({
						width: "100%"
					});
				}
			});
			if (remaining && buildOpts.cardAuthoring.$emptyCell !== "nodisplay") {
				this.addEmptyCells(this._layoutRoot, $$row, remaining, buildOpts, this._$$cellTmpl);
			}
			this.checkEmptyRows(this._$$body);
		},
		buildCardH: function(visibleTds, bs, parentH, parentW, buildOpts) {
			var $$row, realH, realW;
			var nbCardPerRow, numberOfRows;
			var nbVisiblecardsPerRow = buildOpts.cardAuthoring.$cardsPerRow;
			var minWidth = buildOpts.cardAuthoring.$minWidth;
			parentH = parentH - bs;
			var remaining = 0;
			var self = this;
			var maxHeight = 0,
				h, heightChanged;
			visibleTds.some(function(o, idx) {
				if (idx == 0 || nbCardPerRow == 1 || (nbCardPerRow > 1 && idx % nbCardPerRow === 0)) {
					$$row = $("<tr>").appendTo(self._$$body);
					remaining = nbCardPerRow;
				}
				o.$$td.appendTo($$row);
				if (idx === 0) {
					// Calculate the number of rows after having create the first cell
					realH = o.$$td.height() + bs;
					parentW = parentW - ((nbVisiblecardsPerRow + 1) * bs);
					var padding = o.$$card.outerWidth() - o.$$card.width();
					realW = Math.round(parentW / nbVisiblecardsPerRow) - padding;
					if (self.control.isArrayField() || (visibleTds.length * realW < parentW)) {
						// Force to display all the cells on one line because there's enough room
						numberOfRows = 1;
						nbCardPerRow = visibleTds.length;
					} else {
						// Calculate the number of rows to fit the parent height
						numberOfRows = Math.max(1, Math.floor(parentH / realH));
						nbCardPerRow = Math.ceil(visibleTds.length / numberOfRows);
						if (visibleTds.length <= numberOfRows * nbVisiblecardsPerRow) {
							// Dispatch the cards by filling the lines from the top to bottom
							nbCardPerRow = nbVisiblecardsPerRow;
						}
					}
					remaining = nbCardPerRow;
				}
				o.$$card.width(Math.min(parentW, Math.max(minWidth, realW)));
				var h = o.$$card.height();
				console.log(self.control.$bind, h);
				if (maxHeight === 0) {
					maxHeight = h;
				} else if (maxHeight != h) {
					heightChanged = true;
					maxHeight = Math.max(maxHeight, h);
				}
				remaining--;
			});
			if (heightChanged) {
				// Set the same height for cards (could occurs if there are arrays in cards)
				visibleTds.forEach(function(o) {
					o.$$card.height(maxHeight);
				});
			}
			if (remaining && buildOpts.cardAuthoring.$emptyCell !== "nodisplay") {
				var $$emptyCells = this.addEmptyCells(this._layoutRoot, $$row, remaining, buildOpts, this._$$cellTmpl);
				if (heightChanged) {
					$$emptyCells.height(maxHeight);
				}
			}
			if (self.control.isArrayField()) {
				if (this._oneCardGestureMgr) {
					this._oneCardGestureMgr.destroy();
					this._oneCardGestureMgr = null;
				}
				this._oneCardGestureMgr = new HammerScroller($(self._$$body.parent()), {
					direction: "h",
					valMax: 0,
					name: this.control.$bind,
					isPageScroller: false
				});
				this._oneCardGestureMgr.init(uiRect.elmtRect(this.control.$$value));
			}
			this.checkEmptyRows(this._$$body);
		},
		authMinSize2Pixels: function(val) {
			var max = 700,
				min = 100;
			val = parseInt(val, 10);
			if (val == null || isNaN(val)) return 200;
			if (val > 20) return max;
			if (val < 1) return min;
			return min + (val * (max - min) / 20);
		},
		getColumnsInfo: function(onlyVisible) {
			var cols = null;
			if (!this.control.prototype.isSingleArray() && onlyVisible === true && this._layoutRoot) {
				cols = [];
				var _scan = function(node) {
					if (!node || !node.children) return;
					node.children.forEach(function(c) {
						if (c.isControl() && c.$bind) {
							cols.push(c.$bind);
						} else {
							_scan(c);
						}
					});
				};
				_scan(this._layoutRoot);
			}
			var protoCols = this.control.prototype.arrayTableGetColInfo();
			if (cols == null) {
				return protoCols;
			}
			var res = [];
			protoCols.forEach(function(c) {
				if (cols.indexOf(c.$bind) >= 0) {
					res.push(c);
				}
			});
			return res;
		}
	});

exports.Klass = _Klass;