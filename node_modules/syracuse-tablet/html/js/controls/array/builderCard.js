"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/array/builderBase').BuilderBase;
var App = require('syracuse-tablet/html/js/app/appController').App;
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');
var environment = require('syracuse-tablet/html/js/helpers/environment');
var authoringArticleGen = require('syracuse-tablet/html/js/authoring/authoringArticleGen');

exports.BuilderCard = utils.defineClass(
	function builderCard(control) {
		Base.call(this, control);
		this.direction = this.control.isArrayField() ? "h" : "v";
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			this._tds = null;
			if (this._$$body) {
				this._$$body.remove();
				this.destroyScroller();
			}
			this._$$body = null;
		},

		buildHtml: function(data, $$container, refresh) {
			this.article.$minWidth = this.article.$minWidth || 6;
			Base.prototype.buildHtml.call(this, data, $$container, refresh);
			this._cardArticle = this._createCardArticle();
			this._statusInfo = this.control.getRowStatusInfo();
			if (refresh === true) {
				// Build the real content only in that case because parent's size is ok
				// Otherwise buildOnResize is called on computeLayout
				this.buildOnResize(data, $$container, {
					refresh: true
				});
			}
		},

		buildOnResize: function(data, $$container, context) {
			if (this.destroyed) {
				return;
			}
			if (!this.checkEmptyArray()) {
				return;
			}
			this.buildCards(data, $$container, context);
		},

		buildCards: function(data, $$container, context) {
			var context = context || {};
			var refresh = context.refresh == true;
			if (!this._$$body) {
				this.destroyScroller();
				this._$$table = $('<table/>').appendTo($$container)
				this._$$body = $('<tbody>').appendTo(this._$$table);
				this._tds = [];
				var self = this;
				data.forEach(function(rowData, idx) {
					self._tds.push({
						"$$td": $('<td class="s-m-record"/>'),
						rowData: rowData
					});
				});
			}
			var sz = this.control.getAvailableSizeForCards();
			var parentH = sz.height;
			var parentW = sz.width;
			// Border spacing used for calculation
			var bs = this._$$body.parent().css("border-spacing");
			if (bs) {
				bs = bs.split("px");
				bs = bs && bs.length > 0 ? parseInt(bs[0], 10) : 0;
			}
			var $$hiddenRow;
			var visibleTds = [];
			// We keep the $$td's to not recreate them and arrange according the new configuration
			// We first detach them and select the visible ones (used by multiselection)
			// We put non-visible ones in $$hiddenRow to let them available in the dom (used by multiselection)
			this._tds.forEach(function(o, idx) {
				if (o.$$card) {
					// Clear the height/width because they are calculated according to the device/parent size
					o.$$card.css({
						height: "",
						width: ""
					});
				}
				o.$$td.detach();
				if (o.$$td.css('display') != "none") {
					visibleTds.push(o);
				} else {
					if (!$$hiddenRow) {
						$$hiddenRow = $("<tr>").hide();
					}
					o.$$td.appendTo($$hiddenRow);
				}
			});
			// !! Call $$body after having detached $$td because empty() removes the data attached to the node ($.smData) used by multi-selection (diagnoses)
			this._$$body.empty();
			if ($$hiddenRow) {
				$$hiddenRow.appendTo(this._$$body);
			}
			if (visibleTds.length === 0) return;
			if (this.direction === "h") {
				this.buildCardH(visibleTds, bs, parentH, parentW);
			} else {
				this.buildCardV(visibleTds, bs, parentW);
			}
			// Center the table in the parent - only if fixed height
			this._centerCardInParent(parentH);
			this.initScroller($$container);
			this.doAfterBuild();
		},
		_centerCardInParent: function(parentH) {
			// Center the table in the parent - only if fixed height
			if (!this.control.isArrayField() && !this.control.page.isNestedInDashboard("stack")) {
				var top = Math.max(0, (parentH - this._$$body.parent().outerHeight()) / 2);
				this._$$body.parent().css({
					top: top + "px"
				});
			}
		},
		initScroller: function($$container) {
			if (this.direction === "h" || (this.direction === "v" && !this.control.page.isNestedInDashboard("stack"))) {
				this.newScroller(this.direction, this._$$body.parent());
			}
		},
		buildCardV: function(visibleTds, bs, parentW) {
			var scale = this.control.getTransformScale();
			var cardW;
			var remaining = 0;
			var nbCardPerRow = isNaN(this.article.$cardsPerRow) ? 2 : (parseInt(this.article.$cardsPerRow, 10) || 2);
			var $$row = null;
			var self = this;
			visibleTds.some(function(o, idx) {
				if ($$row == null || nbCardPerRow == 1 || (nbCardPerRow > 1 && idx % nbCardPerRow === 0)) {
					$$row = $("<tr>").appendTo(self._$$body);
					remaining = nbCardPerRow;
				}
				remaining--;
				o.$$td.appendTo($$row);
				if (!o.$$card) {
					// !! We create the card here because we need to have the $$card attached to the dom to calculate children width/row... eg: cards inside card
					// If we crate the card at the same time as $$td the generation of html is wrong
					o.$$card = self.createCardContent(o.$$td, idx, o.rowData);
				}
				if (idx === 0) {
					// We have to substract the padding of the card to set the right width
					var padding = (o.$$card.outerWidth() - o.$$card.width());
					// Width of the row minus the borderSpacings
					var availWidth = o.$$td.width() / scale;
					var minWidth = Math.min(availWidth - padding, self.authMinSize2Pixels(self.article.$minWidth));
					while (nbCardPerRow > 0) {
						cardW = Math.round(((availWidth - ((nbCardPerRow - 1) * bs)) / nbCardPerRow)) - padding;
						if (cardW >= minWidth) {
							// nbCardPerRow is ok 
							availWidth = cardW
							break;
						}
						// Width is to small -> We decrease nbCardPerRow
						nbCardPerRow--;
					}
					nbCardPerRow = Math.max(nbCardPerRow, 1);
				}
				o.$$card.width(cardW);
			});
			var $emptycell = this.article.$emptycell || "nodisplay";
			if (remaining && this._cardArticle.$emptyCell !== "nodisplay") {
				this.addEmptyCells(this._layoutRoot, $$row, remaining, visibleTds.length);
			}
			if (this.article.$arrayOptions.hideEmptyRows === true) {
				this.checkEmptyRows();
			}
		},
		buildCardH: function(visibleTds, bs, parentH, parentW) {
			var scale = this.control.getTransformScale();
			var cardW;
			var nbCardPerRow = isNaN(this.article.$cardsPerRow) ? 2 : (parseInt(this.article.$cardsPerRow, 10) || 2)
			var remaining = 0;
			var maxHeight = 0;
			var heightChanged;
			var $$row = null;
			var self = this;
			visibleTds.some(function(o, idx) {
				if (!$$row || nbCardPerRow == 1 || (nbCardPerRow > 1 && idx % nbCardPerRow === 0)) {
					$$row = $("<tr>").appendTo(self._$$body);
					remaining = nbCardPerRow;
				}
				o.$$td.appendTo($$row);
				if (!o.$$card) {
					o.$$card = self.createCardContent(o.$$td, idx, o.rowData);
				}
				if (idx === 0) {
					var realH = (o.$$td.height() / scale) + bs;
					parentW = parentW - ((nbVisiblecardsPerRow + 1) * bs);
					var padding = o.$$card.outerWidth() - o.$$card.width();
					// Width of the row minus the borderSpacings
					var availWidth = o.$$td.width() / scale;
					var minWidth = Math.min(availWidth - padding, self.authMinSize2Pixels(self.article.$minWidth));
					var nbVisiblecardsPerRow = nbCardPerRow;
					while (nbVisiblecardsPerRow > 0) {
						cardW = Math.round(((availWidth - ((nbVisiblecardsPerRow - 1) * bs)) / nbVisiblecardsPerRow)) - padding;
						if (cardW >= minWidth) {
							// nbCardPerRow is ok 
							availWidth = cardW
							break;
						}
						// Width is to small -> We decrease nbCardPerRow
						nbVisiblecardsPerRow--;
					}
					nbVisiblecardsPerRow = Math.max(nbVisiblecardsPerRow, 1);
					if (true || self.control.isArrayField() || (visibleTds.length * cardW < parentW)) {
						// Force to display all the cells on one line because there's enough room
						nbCardPerRow = visibleTds.length;
					} else {
						// Calculate the number of rows to fit the parent height
						var numberOfRows = Math.max(1, Math.floor((parentH - bs) / realH));
						nbCardPerRow = Math.ceil(visibleTds.length / numberOfRows);
						if (visibleTds.length <= numberOfRows * nbVisiblecardsPerRow) {
							// Dispatch the cards by filling the lines from the top to bottom
							nbCardPerRow = nbVisiblecardsPerRow;
						}
					}
					remaining = nbCardPerRow;
				}
				o.$$card.width(cardW);
				var cardH = o.$$card.height() / scale;
				if (maxHeight === 0) {
					maxHeight = cardH;
				} else if (maxHeight != cardH) {
					heightChanged = true;
					maxHeight = Math.max(maxHeight, cardH);
				}
				remaining--;
			});
			if (heightChanged === true) {
				// Set the same height for cards (could occurs if there are arrays in cards)
				visibleTds.forEach(function(o) {
					o.$$card.height(maxHeight);
				});
			}
			var $emptycell = this.article.$emptycell || "nodisplay";
			if (remaining > 0 && $emptycell !== "nodisplay") {
				var $$emptyCells = this.addEmptyCells(this._layoutRoot, $$row, remaining);
				if ($$emptyCells && heightChanged) {
					$$emptyCells.height(maxHeight);
				}
			}
			if (this.article.$arrayOptions.hideEmptyRows === true) {
				this.checkEmptyRows();
			}
		},
		createCardContent: function($$container, index, rowData) {
			var $$card = $('<section class="s-m-card"/>').appendTo($$container).attr("data-idx", index);
			$('<span class="badge checked fa fa-check">&nbsp;</span>').appendTo($$card);
			if (this.article.$arrayOptions.rowIndex === true && index != null) {
				$('<span class="badge index">' + (index + 1) + '</span>').appendTo($$card);
			}
			if (this._statusInfo) {
				this.checkStatusManagement($$card, this._statusInfo, $$card, rowData);
			}
			var cardCtrl = this.control.createRecordCtrl($$card, rowData, index, {
				cardArticle: this._cardArticle
			});
			if (cardCtrl) {
				cardCtrl.buildHtml(this._tableColumnInfo);
				if (environment.isAutoUITestMode()) {
					environment.getUnitTestMgr().arrayAddRowIndex(cardCtrl.$$elmt, index);
				}
			}
			return $$card;
		},
		checkStatusManagement: function($$parent, statusInfo, $$cell, rowData) {
			if (!statusInfo) return;
			var $$rootIcon = $$cell.find(".s-m-status");
			if ($$rootIcon.length === 0) {
				$$rootIcon = $('<div class="s-m-status"/>').appendTo($$cell);
			}
			var nbBckg = 0;
			statusInfo.list.some(function(s) {
				if (s.color && fieldOperators.evaluateOperator(s.$type, rowData.getValue(s.field), s.operator, s.value)) {
					/**
					 * We need to set color and bg-color because using css property doesn't work due to css inheritance
					 * Using css forces to declare all css selectors (td:not(.s-m-multi-selected)...) for each color of the palette
					 */
					if (s.icon) {
						$('<div class="s-m-status-icon ' + s.icon.css + '" style="color:' + s.color.bgColor + '"/>').appendTo($$rootIcon);
						return statusInfo.type === "mono";
					} else if (s.color.css && nbBckg === 0) {
						$$parent.addClass('s-m-status-color ' + s.color.css);
						nbBckg++;
					}
					return statusInfo.type === "mono";
				}
			});
		},
		authMinSize2Pixels: function(val) {
			var max = 700,
				min = 100;
			val = parseInt(val, 10);
			if (val == null || isNaN(val)) return 200;
			if (val > 20) return max;
			if (val < 1) return min;
			return min + (val * (max - min) / 20);
		},
		_createCardArticle: function() {
			var cardArticle = this.article.$card;
			if (!cardArticle) {
				cardArticle = authoringArticleGen.genCardArticle(this.control.prototype);
			};
			return cardArticle;
		},
		getLastSelectedRowId: function() {
			return this.control.$$content.find(".s-m-last-selected > .s-m-card > .s-m-ctrl").attr("id");
		},
		setLastSelectedRowId: function(selectedRowUuid) {
			this.control.$$content.find('#' + selectedRowUuid).closest("td").addClass("s-m-last-selected");
		},
		/**
		 * Add nb empty cells
		 * this.article.$emptycell:
		 * -> "empty" no card is added
		 * -> "withtitle" add empty cards with fields titles displayed
		 * -> "filled" add an empty card
		 */
		addEmptyCells: function(rootLayout, $$parent, nb, startIdx) {
			if (nb < 1) return null;
			// dispEmpty: withtitle, filled, empty
			var dispEmpty = this.article.$emptycell;
			if (dispEmpty === "withtitle" || dispEmpty === "filled") {
				for (var i = 0; i < nb; i++) {
					this.createCardContent($('<td class="s-m-record s-m-empty s-m-' + dispEmpty + ' nohover">').appendTo($$parent), startIdx + i);
				}
				return $$parent.find("td.s-m-empty");
			} else {
				return null;
			}
		},
		/**
		 * Like the rows are not stored as controls (html generated) we get the $$row and apply the rocess to detect empty row
		 * Same process for the row layout
		 */
		checkEmptyRows: function() {
			if (!this._$$body) return;
			if (!this._$$rows) {
				this._$$rows = this._$$body.find(".s-m-row");
			}
			this._$$rows.each(function() {
				_checkEmptyRow($(this));
			});
		},
		updateRowIndex: function($$parent, index) {
			$$parent.find(".badge.index").text(index);
		}

	});


/**
 * Detects empty rows and hide them with the class .s-m-empty.s-m-fullwidth
 * An empty cell (s-m-empty) is hidden if the cell is full width
 * 		takes the full width of the row - depends on bootstrap grid classes)
 * If all non full width cells (emptyNotfw) are empty
 * 		eg; 2 empty cells with width=50% (6/12  of the row) + another one with width=100% (12/12  of the row)
 * A row is hidden if
 * 		All the cells are empty (s-m-empty)
 *
 */
function _checkEmptyRow($$row) {
	if (!$$row) return;
	var fullCellMinWidth = $$row.width();
	fullCellMinWidth = fullCellMinWidth - fullCellMinWidth / 12;
	var emptyNotfw = [];
	$$row.children().each(function() {
		var $$cell = $(this);
		if ($$cell.width() > fullCellMinWidth) {
			$$cell.addClass("s-m-fullwidth");
		} else {
			$$cell.removeClass("s-m-fullwidth");
			if (emptyNotfw && $$cell.is(".s-m-empty")) {
				emptyNotfw.push($$cell);
			} else {
				// Breaks the process on first non empty cell
				emptyNotfw = null;
			}
		}
	});
	if (emptyNotfw) {
		// Hide all these cells
		emptyNotfw.forEach(function($$cell) {
			$$cell.addClass("s-m-fullwidth");
		});
	}
}