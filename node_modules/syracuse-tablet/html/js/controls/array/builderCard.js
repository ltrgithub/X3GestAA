"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/array/builderBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');
var uiRect = require('syracuse-tablet/html/js/ui/rect');

var _cellSizes = {
	"small": {
		w: 150,
		h: 150
	},
	"medium": {
		w: 200,
		h: 200
	},
	"wide": {
		w: 300,
		h: 150
	},
	"large": {
		w: 400,
		h: 400
	}
};

/**
 * Vertical card builder
 * Authoring
 * 		$numberOfRows 			number of card s per row
 * 		$displayEmptyCells 		Display or not empty cells true by default
 */
var _Klass = utils.defineClass(
	function(control, disp, options) {
		Base.call(this, control, disp, options);
		this._layoutRoot = null;
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._layoutRoot) {
				this._layoutRoot.destroy();
				this._layoutRoot = null;
			}
			this._$$body = null;
			this._$$cellTmpl = null;
			this._tds = null;
		},
		/**
		 * Just build $$td cells
		 * Build of array will be done on resize because we need to have the height of the parent control.$$value to calculate the number of roww
		 */
		buildHtml: function(arrayData, buildOptions) {
			Base.prototype.buildHtml.call(this, arrayData, buildOptions);
			if (!this.$article) return;
			if (!this._layoutRoot) {
				// Create HTML generator
				this._layoutRoot = articleParser.card2Controls(this.control);
			}
			this._$$body = $('<tbody>').appendTo($('<table/>').appendTo(this.control.$$value));
			var $$td;
			this._$$cellTmpl = $('<section class="s-m-card s-m-std"/>');
			var $$cell;
			var self = this;
			this._tds = [];
			arrayData.$resources.forEach(function(rowData, idx) {
				$$td = $(self.buildRecordMainElmt(rowData, {
					tag: "td",
					parent: null,
					createIfNoLink: true
				}, idx));
				$$cell = self._$$cellTmpl.clone().appendTo($$td);
				$('<span class="badge index">' + (idx + 1) + '</span>').appendTo($$cell);
				self.callGenerateHtml(self._layoutRoot, $$cell, rowData, false, buildOptions, idx);
				self._tds.push({
					"$$td": $$td,
					"$$card": $$cell
				});
			});
			this.buildArrayHeader(arrayData, buildOptions);
			if (buildOptions && buildOptions.refresh === true) {
				this._build(buildOptions);
			} // Otherwise build is done on resize
		},
		onResize: function(context) {
			if (this._layoutRoot && this._tds.length > 0) {
				/**
				 * We rebuild in any cases in order to have a good display
				 * To be able to calculate  parentH in nested pages we use table display for s-m-control and table-row for children
				 * --> In that case control.$$value has the right height
				 * For non nested paged table display doens't allow to calculate the height of the array without removing the old one...
				 * Other option was to check if $$value height changed to rebuild array
				 */
				this._build(null, context);
			} else {
				Base.prototype.onResize.call(this, context);
			}
		},
		/**
		 * !! check the multi-selection if we modify  _build
		 */
		_build: function(buildOptions, resizeContext) {
			var self = this;
			buildOptions = buildOptions || {};
			/**
			 * setTimeout to better calculate the height of $$value
			 */
			var dirArray = (globals.getScrollingDirection() || "v");
			var initScroll = buildOptions.refresh === true || resizeContext;
			dirArray = dirArray === "h" ? "v" : "h";
			if (self._dirArray == null || self._dirArray != dirArray) {
				self.newScroller(dirArray, self._$$body.parent());
				self._dirArray = dirArray;
				initScroll = true;
			}
			self.$articleArray.$emptycell = "filled";
			setTimeout(function() {
				if (!self._$$body) {
					// Sometimes the body can be empty - Ex when we exit multi-selection mode
					return;
				}
				if (self.control.controller.isVignette) {
					// TODO -> css
					self.control.$$value.height("100%");
				}
				var parentH = self.control.$$value.height();
				var parentW = self.control.$$value.width();
				// Border spacing used for calculation
				var bs = self._$$body.parent().css("border-spacing");
				if (bs) {
					bs = bs.split("px");
					bs = bs && bs.length > 0 ? parseInt(bs[0], 10) : 0;
				}
				//parentH = parentH - bs;
				//parentW = parentW - bs;
				var $$hiddenRow;
				var visibleTds = [];
				// We keep the $$td's to not recreate them and arrange according the new configuration
				// We first detach them and select the visible ones (used by multiselection)
				// We put non-visible ones in $$hiddenRow to let them available in the dom (used by multiselection)
				self._tds.forEach(function(o, idx) {
					o.$$td.detach();
					if (o.$$td.css('display') != "none") {
						visibleTds.push(o);
					} else {
						if (!$$hiddenRow) {
							$$hiddenRow = $("<tr>").hide();
						}
						o.$$td.appendTo($$hiddenRow);
					}
				});
				// !! Call $$body after having detached $$td because empty() removes the data attached to the node ($.smData) used by multi-selection (diagnoses)
				self._$$body.empty();
				if ($$hiddenRow) {
					$$hiddenRow.appendTo(self._$$body);
				}
				if (visibleTds.length === 0) return;
				self["buildCard" + dirArray.toUpperCase()](visibleTds, bs, parentH, parentW, buildOptions);
				var top = Math.max(0, (parentH - self._$$body.parent().outerHeight()) / 2);
				self._$$body.parent().css({
					top: top + "px"
				});
				if (initScroll) {
					// refreshes the gestureMgr
					Base.prototype.onResize.call(self, resizeContext);
				}
			});
		},
		buildCardV: function(visibleTds, bs, parentH, parentW, buildOptions) {
			var self = this;
			self._$$body.parent().width("100%");
			var $$row, realW;
			var nbCardPerRow = 2,
				remaining = 0;
			parentW = parentW - ((nbCardPerRow + 1) * bs);
			var realW;
			visibleTds.forEach(function(o, idx) {
				if (idx === 0 || nbCardPerRow == 1 || (nbCardPerRow > 1 && idx % nbCardPerRow === 0)) {
					$$row = $("<tr>").appendTo(self._$$body);
					remaining = nbCardPerRow;
				}
				remaining--;
				o.$$td.appendTo($$row);
				if (idx === 0) {
					var padding = o.$$card.outerWidth() - o.$$card.width();
					realW = Math.round(parentW / nbCardPerRow) - padding;
				}
				o.$$card.width(realW);
			});
			if (remaining) {
				self.addEmptyCells(self._layoutRoot, $$row, remaining, buildOptions, self._$$cellTmpl);
			}
		},
		buildCardH: function(visibleTds, bs, parentH, parentW, buildOptions) {
			var self = this;
			self.control.$$value.height("100%");
			var $$row, realH, realW;
			var nbCardPerRow, numberOfRows;
			var nbVisiblecardsPerRow = 2;
			parentH = parentH - bs;
			var remaining = 0;
			visibleTds.forEach(function(o, idx) {
				if (idx == 0 || nbCardPerRow == 1 || (nbCardPerRow > 1 && idx % nbCardPerRow === 0)) {
					$$row = $("<tr>").appendTo(self._$$body);
					remaining = nbCardPerRow;
				}
				o.$$td.appendTo($$row);
				if (idx === 0) {
					// Calculate the number of rows after having create the first cell
					realH = o.$$td.height() + bs;
					parentW = parentW - (nbVisiblecardsPerRow + 1) * bs;
					var padding = o.$$card.outerWidth() - o.$$card.width();
					realW = Math.round(parentW / nbVisiblecardsPerRow) - padding;
					if (visibleTds.length * realW < parentW) {
						// Force to display all the cells on one line because there's enough room
						numberOfRows = 1;
						nbCardPerRow = visibleTds.length;
					} else {
						// Calculate the number of rows to fit the parent height
						numberOfRows = Math.max(1, Math.floor(parentH / realH));
						nbCardPerRow = Math.ceil(visibleTds.length / numberOfRows);
						if (visibleTds.length <= numberOfRows * nbVisiblecardsPerRow) {
							// Dispatch the cards by filling the lines from the top to bottom
							nbCardPerRow = nbVisiblecardsPerRow;
						}
					}
					remaining = nbCardPerRow;
				}
				o.$$card.width(realW);
				remaining--;
			});
			//if (numberOfRows > 1 && $$row) {
			//var remaining = nbCardPerRow - visibleTds.length % nbCardPerRow;
			if (remaining) {
				self.addEmptyCells(self._layoutRoot, $$row, remaining, buildOptions, self._$$cellTmpl);
			}
			//}
		}
	});

exports.Klass = _Klass;