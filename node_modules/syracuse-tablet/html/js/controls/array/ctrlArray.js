"use strict";


var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');
var SearchArray = require('syracuse-tablet/html/js/controls/array/searchArray').Klass;
var factory = require('syracuse-tablet/html/js/application/appFactory');

var _typeDefValue = function(prop) {
	switch (prop.$type) {
		case "application/x-password":
		case "application/x-string":
			return "";
		case "application/x-quantity":
			return 0.0;
		case "application/x-decimal":
		case "application/x-real":
			return 0.0;
		case "application/x-integer":
			return 0;
		case "application/x-boolean":
			return false;
		case "application/x-date":
			return '';
		case "application/x-datetime":
			return '';
		case "application/x-time":
			return '';
		case "application/x-choice":
			return prop.$value.$enum[0].$value;
		case "application/x-reference":
			return {
				$value: "",
				$description: "",
				$title: ""
			};
		case "application/x-array":
			return [];
		default:
			return null;
	}
};
var _dataProps = ["$isMandatory", "$isReadOnly", "$isHidden", "$isExcluded", "$isDisabled", "$actions", "$format"];
var _proto2Instance = function(protoArray) {
	var res;
	if (protoArray.isSingleArray()) {
		res = {
			$properties: {
				"~data~": ""
			}
		};
	} else {
		res = {
			$properties: {}
		};
		var props = protoArray.getDataByPath("$item.$properties");
		for (var propName in props) {
			if (!propName.smStartsWith("$")) {
				var prop = props[propName];
				res[propName] = _typeDefValue(prop);
				var $properties = res.$properties[propName] = {};
				_dataProps.forEach(function(p) {
					if (prop[p] != null) {
						$properties[p] = prop[p];
					}
				});
			}
		}
	}
	return res;
};
/**
 * Manages local pagination
 */
var _LocalPaginator = utils.defineClass(function(arrayCtrl, options) {
	options = options || {};
	this._length = options.length;
	this.count = options.count || 10;
	this._arrayCtrl = arrayCtrl;
	this._nbPagin = Math.floor(this._length / this.count);
	this._lastIdx = this.count * (this._length % this.count === 0 ? this._nbPagin - 1 : this._nbPagin);
	if (this._lastIdx < this.count) this._lastIdx = 0;
	this.first();

}, null, {
	destroy: function(destroyProto) {
		this._arrayCtrl = null;
	},
	first: function() {
		this.currentIdx = 0;
		return this.currentIdx;
	},
	last: function() {
		this.currentIdx = this._lastIdx;
		return this._lastIdx;
	},
	next: function() {
		this.currentIdx = Math.min(this._lastIdx, this.currentIdx + this.count);
		return this.currentIdx;
	},
	prev: function() {
		this.currentIdx = Math.max(0, this.currentIdx - this.count);
		return this.currentIdx;
	},
	isActionEnabled: function(act) {
		switch (act) {
			case "$last":
			case "$next":
				return this.currentIdx < this._lastIdx;
			case "$first":
			case "$previous":
				return this.currentIdx > 0;
		}
	},
	isEnabled: function() {
		return this._length > this.count;
	},
	doAction: function(act) {
		switch (act) {
			case "$next":
				return this.next();
			case "$previous":
				return this.prev();
			case "$first":
				return this.first();
			case "$last":
				return this.last();
		}
	}
});

var _sortFilterExclude = ["application/x-array", "image", "application/x-document", "application/x-binary", "application/x-object", "text/rtf", "text/html", "text/plain"];

var _notImplemented = function(text) {
	throw new Error("The following feature in not implemented -> " + text);
};
var Builders = {
	table: require('syracuse-tablet/html/js/controls/array/builderTable').Klass,
	card: require('syracuse-tablet/html/js/controls/array/builderCard').Klass,
	carousel: require('syracuse-tablet/html/js/controls/array/builderCarousel').Klass,
	separator: require('syracuse-tablet/html/js/controls/array/builderSeparator').Klass
};
var _destroyArrayData = function(a) {
	if (!a || !a.$resources) return null;
	a.$resources.forEach(function(r) {
		if (r) r.destroy();
	});
	return null;
};
/**
 * x-array control class
 * Authoring
 * 			$isTitleHidden: 		true/false
 * 			$height					height of array - if no height displays full array
 * 									add pan event to scroll(no swipe)
 * 			$width					100% by default - not needed
 * 			$displayIfEmpty:		true/false - Maybe a general property for fields to not display the control if empty
 *                              	If false we display the label and default value
 *      							Useful to optimize display
 *  		$emptycell				Ford cards mode - Value! ’empty’, ‘filled’, ‘withtitle’
 * 				empty:		 			doesn't fill grid with empty cells
 * 				filled:					fills grid with empty cells
 * 				withtitle:				fills grid with cards wit titles and default field values
 * 			$display				display mode table / card
 * 			for card
 * 				$cardMode	 			Display mode
 * 					single 					to display one card at a time with a swipe to walk inside the collection
 * 					multiple 				to display a list of cards
 * 				$cardsPerRow 			number of cards per row
 * 										height is calculated in percentage based on control width (full parent page with by default)
 * 				for field array 		s-m-control.s-m-array parent page has class detail or edit
 * 					$pagination				Displays N cards at a time on other ones on swipe
 *         $onselect 					detail 		Open detail fullpage
 *         								fullpage	Open query fullpage
 */
var _Klass = utils.defineClass(
	// CtrlArray used by isInstanceOf 
	function CtrlArray(controller, article, prototype, options) {
		Base.call(this, controller, article, prototype, options);
		this._initArrayAuththoring();
		this._newBuilder(options);
		this._arrayData = null;
		// #6734 - we need to restore the search context (if any) at the creation of SearchArray to allow the page controller to add the clause in sdataUrl
		// This is not the regular process but it's needed
		var savedContext = controller.getCtrlSavedContext(this.$bind);
		this._search = new SearchArray(savedContext ? savedContext.$search : null);
		// All the rows with a link to rowDetail are registered in _rowDetailCache - id: {pathId,pathBind}
		// When we display arrays nested in arrays in card mode we need to store the path to access to the data/proto of the selected row
		// -> Cards Html is generated and the control object is not stored so we need to store the path to retrieve it from mainControl (htmlRootCtrl)
		this._rowDetailCache = {};
		// Info of the clicked row
		this._rowDetailInfo = null;
		// Set the default color - Forced to be modified by authoring
		if (article.$arrayBgColor == null) {
			// Used only in card mode - table has no color
			article.$arrayBgColor = globals.CARDARRAYDEFCOLOR;
		}
	}, Base, {
		_initArrayAuththoring: function() {
			this.$display = this.controller.isEditMode() || !this.article.$display ? "table" : this.article.$display;
			var defaults;
			if (this.controller.isVignette) {
				defaults = {
					showPagination: false,
					showSortFilter: false
				};
			} else if (this.controller.state.type === "chartdetail") {
				defaults = {
					showPagination: false,
					showSortFilter: false,
					showSearch: false
				};
			} else {
				defaults = {
					showPagination: true,
					showSortFilter: true,
					showSearch: true
				};
			}
			defaults.rowIndex = this.$display === "card";
			this.article.$arrayOptions = $.extend(defaults, this.article.$arrayOptions || {});
		},
		_newBuilder: function(options) {
			if (this.$display === "carousel") {
				// To keep card mode - carousel is based on card mode
				this.$display = "card";
				options.displayAsCarousel = true;
			}
			// Force one card display for cards nested in cards
			var BuilderClass = Builders[this.$display == "card" ? options.displayAsCarousel ? "carousel" : "card" : this.$display];
			if (!BuilderClass) {
				BuilderClass = Builders.table;
			}
			if (options.acceptRowSelectAction == null) {
				// List detail link by default
				options.acceptRowSelectAction = true;
			}
			this.builder = new BuilderClass(this, this.$display, options);
		},
		isCarouselDisplay: function() {
			return this.$display === "card" && this.options.displayAsCarousel === true;
		},
		getMode: function() {
			return this.builder && this.builder.$display;
		},
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			if (this._arrayData) this._arrayData = _destroyArrayData(this._arrayData);
			if (this.builder) this.builder.initReuseProperties();
			this.$$ttl = null;
		},
		destroy: function() {
			this._multiSelStop();
			// Just set to null - destroyed by rowDetail page
			this._rowDetailInfo = null;
			// Just set to null
			this._rowDetailCache = null;
			if (this._localPaginator) {
				this._localPaginator.destroy();
				this._localPaginator = null;
			}
			Base.prototype.destroy.call(this);
			this.prototype = null;
			if (this.builder) {
				this.builder.destroy();
				this.builder = null;
			}
			if (this._arrayData) {
				this._arrayData = _destroyArrayData(this._arrayData);
				this._arrayData = null;
			}
			if (this._waiting) {
				uiUtils.waitWheelDestroy(this._waiting);
				this._waiting = null;
			}
			if (this._filterSortPanel) {
				this._filterSortPanel.destroy();
				this._filterSortPanel = null;
			}
			if (this._search) {
				this._search.destroy();
				this._search = null;
			}
		},
		isArrayField: function() {
			if (!this.controller) return false;
			return !this.controller.prototype.isQueryLikeFacet();
		},
		/**
		 * Overridden
		 */
		isArrayChart: function() {
			return false;
		},
		/**
		 *	Build html DOM object + bind event
		 **/
		buildHtml: function($$parent, controllerDao, buildOptions) {
			if (this.builder == null) {
				throw new Error("Null builder");
			} else if (this.builder.$display !== this.$display) {
				// Changing display via authoring recreates controls
				throw new Error("Unexpected display type", "Current display", this.builder.$display, "New display", this.$display);
			}
			var css = "s-m-" + this.$display;
			// Build root elm
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions, ["s-m-array", css]);
			// Set up array data and isEmpty property used to managed authoring - Display title
			this._setArrayData(controllerDao, false);
			var hasFilerSort = !this.isArrayField();
			if (hasFilerSort) {
				this._filterSortPanel = this.controller.panelCreate(globals.PANELFILTERSORT, {
					parentArray: this,
					filter: true,
					sort: true
				});
			}
			if (this._arrayData.$properties) {
				buildOptions.$items = this._arrayData.$properties;
			}
			this.builder.buildHtml(this._arrayData, buildOptions);
			if (this.prototype.isSingleArray() && this.builder.isEmptySingleArray()) {
				// #5529 Special case -> single array and all records with $isHidden = true -> test AQMCRUDM
				this.isEmpty = true;
			}
			// Hidden if no data and no title - take into account this.isEmpty for singleArrays
			//  #6887 Only if array field - For query/Lookup we display no Record
			if (this.isArrayField() && !this._displayArray() && (this.$$ttl == null || this.$$ttl.empty())) {
				this.$$elmt.hide();
			}
		},
		/**
		 * Refreshes the control
		 */
		refresh: function(controllerDao, options) {
			this._rowDetailInfo = null;
			this._capabilities = null;
			if (this.builder == null) throw new Error("Null builder");
			this.builder.refresh(this._setArrayData(controllerDao, true), options);
		},
		onResize: function(context) {
			/**
			 * Add with collapsible stack
			 * We don't display array if not visible because not needed and because card needs a visible element to calculate width/height/padding...
			 * :visible takes into account parents (maybe costly in cpu)
			 * subscibes event expand layout to render the array
			 */
			if (context && context.footerSwipe === true) {
				// No need to refresh
				return;
			}
			if (!this.$$elmt || !this.$$elmt.is(':visible')) {
				if (!this._subscribedExpand) {
					this._subscribedExpand = true;
					notifications.subscribe(this, ["sm.layout.expanded"]);
				}
				// No display
				return;
			} else if (this._subscribedExpand) {
				notifications.unsubscribe(this, ["sm.layout.expanded"]);
				this._subscribedExpand = false;
			}
			this.builder.onResize(context);
			//Notifies cell/Tile parent - Display optimization
			this.notifyVignetteArrayHosted();
		},
		/**
		 * synch to select the row before switching tp selected page
		 */
		_notifSelectedRow: function(rowId, rowData) {
			notifications.notifyController("synch.sm.select.row", this.controller, this.id, rowId, rowData);
		},
		/**
		 * handle selection of a row for lookup
		 */
		_actRowSelect: function(rowId, $$target) {
			if (this._multiSelSelect($$target)) {
				return;
			}
			var rowData = this.getRowById(rowId);
			if (!rowData) return;
			rowData = rowData.row;
			if (this.controller.isLookup()) {
				/** SELECTION ON LOOKUP ARRAY**/
				// Proto to allow caller to read/display $description, $title... 
				var proto = $.extend(true, {}, this.prototype.getDataByPath("$item"));
				var data = $.extend(true, {}, rowData.data);
				// Notify selection to lookup page
				this._notifSelectedRow(rowId, {
					data: data,
					proto: proto
				});
			} else {
				/** SELECTION ON REGULAR ARRAY**/
				var links = this.builder.$itemProto.data("$links");
				// We can force the detail link by authoring (Fixed Assets)
				var forceLink = this.getAuthoring("$detailsLink");
				var link;
				if (forceLink == null) {
					forceLink = this.controller.isVignette ? "$queryfullpage" : "$details";
				}
				if (forceLink === "$queryfullpage") {
					if (!this.controller.isVignette) throw new Error("Vignette context expected");
					link = {
						page: this.controller.state.name
					};
					// No selected row in that case
					// Check if there is an article for query link - ONLY FOR TEST ENTITIES
					this._forceArticle = this.article ? this.article.$queryLinkArticle : null;
				} else {
					var linkProto = links[forceLink] ? links[forceLink] : links.$details;
					link = linkProto ? sdataUtils.getLinkInfo(linkProto.$url, rowData) : null;
					// Notify last selected row to current page
					this._notifSelectedRow(rowId, rowData);
					// Check if there is an article for detail link - ONLY FOR TEST ENTITIES
					this._forceArticle = this.article ? this.article.$detailLinkArticle : null;
				}
				if (link) {
					var attrs = {};
					attrs["data-nav"] = link.page;
					attrs["data-nav-target"] = this.controller.openLinkInVignette() ? "vignette" : "application";
					if (link.sDataUrl) {
						attrs["data-sdata-url"] = link.sDataUrl;
					}
					if (link.parameters) {
						var params = utils.parseExpression(link.parameters, rowData);
						attrs["data-sdata-parameters"] = params;
					}
					if (this._forceArticle) {
						attrs["data-link-article"] = this.id;
					}
					eventListener.triggerNavigation(this.$$elmt, attrs);
				}
			}
		},
		/**
		 * Called when we click on editRow, detailRow, createRow
		 * Calculate information dao/proto/name for rorwDetail page
		 * Each time a rowDetail link is generated, we store link info in _rowDetailCache
		 * 		Path of array from the current array
		 * 		Path of row ids from current array
		 * This method retrieve dao/proto objects from stored info
		 * 		rowDetail page needs _rowDetailInfo.dao in lodaData method
		 *  	pageHelpers._getRowdetailPage needs _rowDetailInfo.proto and _rowDetailInfo.pathBind to build rowDetail page proto
		 *
		 *  rowInfofId is the id of the cached info
		 */
		_openDetailRow: function(rowInfofId, activity) {
			var self = this;
			try {
				// Info that has been set by the builder - Contains path of $binds and ids for each row displayed
				var info = self._rowDetailCache[rowInfofId];
				if (!info) throw new Error("rowDetailGetDao - Unexpected null row info");
				var isRowCreation = activity === "create";
				// Path of parent arrays
				var pathBind = info.pathBind;
				if (isRowCreation && pathBind.length > 1) {
					// TODO - Create new row in an array embedded inside a card
					// Currently we force table mode in edit mode
					_notImplemented("Creating row in an array embedded inside a card");
				} else {
					// Ok if not patpathBindhBind.length > 1 in display mode 
					// We allow display of row detail in an arrayy embedded inside a card - Tested
				}
				// Id of parent rows
				var pathId = info.pathId;
				var proto = self.prototype.parent;
				var protoPath = ["$properties"];
				var dao = self.getDao();
				for (var i = 0; i < pathBind.length; i++) {
					protoPath.push(pathBind[i]);
					// Get Proto and dao for the ith array
					proto = proto.getPrototype(protoPath.join("."));
					// Some explanations about the way to retreive the right row dao
					// When we generate cards or grids we don't store controls and associated dao object (see html generator) - We keep only the generated html
					// We need a way to retreive the right row dao when we click on a row Detail link (there are complex use cases with cards arrays inside cards arrays)
					// -> We save the path of row ids and path of $bind in _rowDetailCache
					// To retreive the row dao we scan the current Dao from to pathBinds and pathRowIds
					var arrayData;
					if (self.$bind === pathBind[i]) {
						// We are on the current dao -> we take the current object dao
						// It's important in order to set rowDetail parent with the right dao object
						//  -> pageRegular.notifRowdetailUpdate -> childDao.updateParentRow will update the right parent dao
						arrayData = self._arrayData;
					} else {
						if (!dao) throw new Error("Unexpected null dao");
						// We are on a parent of the current dao -> we create a new dao object
						arrayData = dao.getArrayData(pathBind[i], proto);
					}
					// Search the row by id in dao
					var res = self.getRowById(pathId[i], arrayData);
					if (!res) {
						if (!isRowCreation) throw new Error("Unexpected empty row");
						res = {
							row: self.getArrayEmptyRow(this.controller, proto, pathBind[i], dao)
						};
					}
					// Current dao	
					dao = res.row;
					// Current path root in protoype
					protoPath = ["$item.$properties"];
				}
				if (!dao || dao === self.getDao()) return;
				// Create the dao AND the proto of rowDetail page
				var rowDetailDao = factory.createDaoRowDetail(dao, self.controller, self._getProtoRowDetail(proto));
				pathBind = info.pathBind.join('.');
				// Stores row Detail in info - RowDetail info will be requested by rowDetail page in loadData method
				self._rowDetailInfo = {
					// Path of the array from root (page) - use dto calculated the id of the rowDetail page
					pathBind: pathBind,
					dao: rowDetailDao,
					activity: activity
				};
				// Trigger a navigation to rowDetail page
				var attrs = {
					"data-control-id": self.id,
					"data-parent-id": self.controller.id,
					"data-nav": "rowdetail",
					"data-params": dao.getValue("$uuid")
				};
				if (self.controller.isVignette) {
					// It's the vignette which will load the page
					// We open row detail in the same vignette
					attrs["data-nav-target"] = "vignette";
				}
				// Notify last selected row - see selectLastSelectedRow - true to update UI because link doesn't destroy the page
				if (!isRowCreation) {
					// Synch because we want to make sure that controller has been notofied before calling eventListener.triggerNavigation 
					notifications.notifyController("synch.sm.select.row", self.controller, self.id, dao.getValue("$uuid"), null);
				}
				eventListener.triggerNavigation(self.$$elmt, attrs);
			} catch (e) {
				globals.getModal().error("Error loading row detail page", e);
			}
		},
		_getProtoRowDetail: function(proto) {
			var protoJson = {
				$url: "",
				$typ: "rowdetail",
				$links: {}
			};
			// add $links
			if (this.controller.isEditMode()) {
				protoJson.$links.$save = {
					"$title": locale.text("array.links.save")
				};
				// TODO - delete is always possible in rowDetail - for tests
				if (true || this.controller.prototype.getDataByPath("$links.$delete")) {
					protoJson.$links.$delete = {
						"$title": locale.text("array.links.delete"),
						"$confirm": locale.text("actions.del.confirm")
					};
				}
			}
			protoJson.$title = proto.data("$title");
			if (proto.isSingleArray()) {
				var p = $.extend({}, proto.getDataByPath("$item"));
				p.$isMandatory = true;
				p.$isReadOnly = p.$isHidden = p.$isDisabled = false;
				protoJson.$properties = {
					"~data~": p
				};
				return proto.create(protoJson);
			} else {
				return proto.getPrototype("$item", protoJson, this.controller.$activity === "read" ? "details" : "edit");
			}
		},
		getArrayEmptyRow: function(controller, proto, bind, parentDao) {
			var rsrc = _proto2Instance(proto);
			rsrc.$uuid = utils.UUID();
			// We path pathBind as $bind in empty dao to be able to retrieve the full path of prototype in nested arrays
			return factory.createDaoSdata(rsrc, this._getProtoRowDetail(proto), {
				parent: parentDao,
				$bind: bind,
				enableWorkingCopy: parentDao.enableWorkingCopy
			});
		},
		/**
		 * Click on display or edit row detail
		 * Id is stored in s-m-record parent dom elment
		 */
		_actRowDetail: function(rowInfofId, target, event) {
			this._openDetailRow(rowInfofId, this.controller.isEditMode() ? "edit" : "read");
			if (event) {
				event.stopPropagation();
			}
		},
		/**
		 * Click on create a new row
		 * Id is stored data-cation element
		 * This action is not really a row action, it's an array action
		 */
		_actRowCreate: function(rowInfofId) {
			this._openDetailRow(rowInfofId, "create");
		},
		/**
		 * handle delete row
		 */
		_actRowDelete: function(rowId) {
			var self = this;
			// Info that has been set by the builder - Contains path of $binds and ids for each row displayed
			var info = self._rowDetailCache[rowId];
			if (!info) return;
			modal.simpleConfirm(locale.text("actions.del.confirm"), function(confirmed) {
				if (confirmed) {
					// Retreive the current array in path
					var pathBind = info.pathBind;
					var pathId = info.pathId;
					while (pathBind.length != 0 && pathBind[0] != self.$bind) {
						pathBind.shift();
						pathId.shift();
					}
					if (pathBind.length == 0) throw new Error("Unexpected null pathBind");
					var field = pathBind.pop();
					/**
					 * pathBind.length > 1 means that we have to retreive the row in a child according to pathId
					 * We can have this case if we edit an array cards inside a card. The current array is th card's parent and we wantto delete the row in a child array
					 * --> Not implemented for the moment because not tested
					 */
					if (pathBind.length > 1 || field !== self.$bind) {
						_notImplemented("Deleting row in an array embedded inside a card");
					} else {
						// TODO - Retreive the row in newted child arrays (id is unic) and delete it
					}
					// Temporarily - Remove row in current array
					self.removeRow(rowId);
				}
			});
		},
		/**
		 * Remove rowId in datasets and html
		 * Can be called also from regularPage when we click on Delete action in rowDetail footer
		 */
		removeRow: function(rowId) {
			// Remove the row in _arrayData
			var array = this._arrayData;
			if (!array || !array.$resources || array.$resources.length == 0) return;
			var idx = -1;
			array.$resources.some(function(r, i) {
				if (r.getValue("$uuid") === rowId) {
					idx = i;
					return true;
				}
			});
			if (idx < 0 || idx >= array.$resources.length) return;
			array.$resources.splice(idx, 1);
			// Remove the row in html	
			this.builder.removeRowById(rowId);
			// Remove the row in dao - If it's a single array we use idx becaus there's no uuid in backoffice data (uuid is added by tablet client in arrayData to manage singleArrasy like other arrays)
			this.getDao().deleteRow(this.$bind, this.prototype.isSingleArray() ? idx : rowId);
		},
		/**
		 * Register a row in rowDetail cache to be able to reteive infortiaon on ckcik on 'rowDetail' Link (_actRowDetail)
		 */
		rowDetailAdd: function(id, data) {
			this._rowDetailCache[id + ""] = data;
		},
		/**
		 *  Return the dao and other information of the selected row (see _actRowDetail)		 *
		 **/
		rowDetailGetInfo: function(create) {
			// Read/ Edit row detail
			return this._rowDetailInfo;
		},
		/**
		 * Return the page info used buy pageRegistry
		 */
		childPageGetPageInfo: function(typePage) {
			var pageInfo = {
				home: false,
				type: typePage,
				cached: false,
				refreshed: false,
				changeHash: false
			};
			if (typePage === "rowdetail") {
				if (!this._rowDetailInfo) throw new Error("childPageGetPageInfo - Null details row data");
				// Proto is given by dao
				pageInfo.prototype = this._rowDetailInfo.dao.prototype;
				pageInfo.subtype = this.controller.isEditMode() ? "edit" : "details";
				pageInfo.article = null;
				// To store the generated page in aplication page we nee the full path of the selected row
				// By exmaple for AQMCRUDM -  if we add a $article to the array level 1 we display i the card array level 2
				// When we click on rowDetail we need to display the row of level 2 ADEVADEVICEL.ADEVADEVICELADEVICELL
				// Page name is 
				//		AQMCRUDM.$details.ADEVADEVICEL if no article in ADEVADEVICEL
				//		AQMCRUDM.$details.ADEVADEVICEL.ADEVADEVICELADEVICELL if there's an article in ADEVADEVICEL
				//		AQMCRUDM.$details.ADEVADEVICEL.ADEVADEVICELADEVICELL.ADEVADEVICELADEVICELLDLLLif there's an article in ADEVADEVICEL.ADEVADEVICELADEVICELL
				pageInfo.name = this.controller.state.name + "." + this._rowDetailInfo.pathBind;
			} else if (typePage === "carddesign") {
				pageInfo.prototype = this._getProtoCardDesign();
				pageInfo.subtype = "details";
				pageInfo.article = this.article.$card ? this.article.$card : null;
				pageInfo.name = this.controller.state.name + "." + this.$bind + "." + typePage;
			}
			return pageInfo;
		},
		/**
		 * Select the last selected row
		 * lastSelectedrow is stored in page context and restores on back
		 * It highlights the last selected row
		 * Done by builder because depends on the way array has been rendered
		 */
		selectLastSelectedRow: function(rowId, show) {
			this.builder.selectLastSelectedRow(rowId, show);
		},
		/**
		 *	returns array rows
		 *		depends on the kind of page query/lookup or detail/edit
		 *		called one time to create the dao - then use getArrayData()
		 **/
		readArrayData: function(controllerDao) {
			if (this.options.localPagination === true && this._localPaginator == null) {
				this._localPaginator = this.createLocalPaginator(controllerDao);
				if (this._localPaginator == null) {
					this.options.localPagination = false;
				}
			}
			var res;
			if (this.prototype.isQuery()) {
				res = controllerDao.getQueryData(this.prototype, this._localPaginator);
			} else if (this.prototype.isLookup()) {
				res = controllerDao.getLookupData(this.prototype, this._localPaginator);
			} else if (this.prototype.isCube()) {
				res = controllerDao.getCubeData(this.$bind, this.prototype, this._localPaginator);
			} else {
				res = controllerDao.getArrayData(this.$bind, this.prototype, this._localPaginator);
			}
			if (!res || !res.$resources) {
				res = {
					$resources: []
				};
			}
			return res;
		},
		hasLocalPagination: function() {
			return this._localPaginator != null && this._localPaginator.isEnabled();
		},
		createLocalPaginator: function(controllerDao) {
			throw new Error("Not implemented");
		},
		getLocalPaginator: function() {
			return this._localPaginator;
		},
		_actPagination: function(linkName, target, event) {
			if (this._localPaginator) {
				this._localPaginator.doAction(linkName);
				this.refresh(this.controller.dao);
			} else {
				var attrs = {
					"data-nav-refresh": true,
					"data-nav-type": linkName,
					"data-sdata-url": this.prototype.resolveExpression(this.getArrayData().$links[linkName].$url),
					"data-control-id": this.id,
					"data-nav-target": this.controller.isVignette ? "vignette" : "application"
				};
				eventListener.triggerNavigation(this.$$elmt, attrs);
			}
		},
		/**
		 *	Set array data - depends on array type
		 **/
		_setArrayData: function(controllerDao, refresh) {
			this._multiSelReset();
			this.isEmpty = true;
			if (!this.hasLocalPagination()) {
				_destroyArrayData(this._arrayData);
			}

			this._arrayData = this.readArrayData(controllerDao);
			this.isEmpty = this._arrayData.$resources.length === 0;
			this.$$elmt.toggleClass("empty", this.isEmpty);
			if (this.builder) {
				this.builder.notifyArrayDataChanged(refresh, this._arrayData, this.isEmpty);
			}
			// Clear control content
			this.clearContent(refresh);
			if (!refresh) {
				// Build the base structure common to all ctrls - Title and value
				var title = this.getTitle();
				if (this._displayTitle(title)) {
					if (!this.$$ttl) this.$$ttl = $(uiUtils.createDomElement('div', ["s-m-title"])).appendTo(this.$$elmt);
					this.$$ttl.text(title);
				} else if (this.$$ttl) {
					this.$$ttl.empty();
				}
				// After title
				this.$$value = $(uiUtils.createDomElement('div', ["s-m-value"], null, null, this.$$elmt));
				this.$$value.before(this.$$header = $('<header/>'));
				if (this.$display === "card") {
					var bgColor = (this.article.$arrayBgColor || "").toLowerCase();
					if (bgColor.length > 0) {
						bgColor = "s-m-color-" + bgColor;
					}
					if (bgColor) {
						this.$$value.addClass("s-m-bg " + bgColor);
					}
				}
			}
			return this._arrayData;
		},
		/**
		 * !! Notify the builder that the content is cleared - chart builder destroy the plugin highchart
		 */
		clearContent: function(refresh) {
			if (this.builder) {
				this.builder.notifClearContent(refresh);
			}
			if (refresh) {
				this.$$value.empty();
			} else {
				this.$$elmt.empty();
			}
		},
		_displayTitle: function(title) {
			if (title == null || title.trim().length === 0) return false;
			if (this.getAuthoring("$isTitleHidden") === true) return false;
			return this._displayArray();
		},
		_displayArray: function() {
			return this.controller.isEditMode() === true || this.isEmpty !== true || this.getAuthoring("$displayIfEmpty") === true;
		},
		/**
		 *	returns array rows
		 *		controllerDao optional
		 **/
		getArrayData: function() {
			return this._arrayData;
		},
		getNbRecords: function() {
			return this._arrayData ? this._arrayData.$resources.length : 0;
		},
		waitStart: function() {
			if (!this._waiting) {
				// TODO - Optimization
				this._waiting = uiUtils.waitWheelCreate(this.$$elmt.parent());
				this._waiting.$$bckg.css({
					position: "absolute"
				});
				this._waiting.$$wheel.css({
					position: "absolute"
				});
			}
			uiUtils.waitWheelStart(this._waiting);
		},
		waitStop: function() {
			if (this._waiting) {
				uiUtils.waitWheelStop(this._waiting);
			}
		},
		// arrayData is used for recursice search in arrays nested in arrays
		getRowById: function(rowId, arrayData) {
			var self = this;
			arrayData = arrayData || self._arrayData;
			if (!arrayData || !arrayData.$resources || arrayData.$resources.length == 0) return null;
			var idx = 0;
			var result = null;
			arrayData.$resources.some(function(r) {
				if (r.getValue("$uuid") === rowId) {
					result = r;
					return true;
				}
				idx++;
			});
			return result ? {
				row: result,
				idx: idx
			} : null;
		},
		// Used for single Arrays
		_getRowByIdx: function(idx, arrayData) {
			arrayData = arrayData || this._arrayData;
			idx = parseInt(idx, 10);
			if (!arrayData || !arrayData.$resources || arrayData.$resources.length <= idx) return null;
			return {
				row: arrayData.$resources[idx],
				idx: idx
			};
		},
		/**
		 * return the context to save. It will be be restored afer page has been loaded
		 * type	back/link - Used to manage the content according to the type
		 */
		savedCtxCreate: function(type) {
			if (!this.builder) return;
			var res = {
				$builder: this.builder.savedCtxCreate(type)
			};
			if (this._search) {
				// Stores the search context to restore it on back - detail -> list #6734
				res.$search = this._search.savedCtxCreate(type);
			}
			return res;
		},
		/**
		 * Called by the page to restore the context
		 */
		savedCtxRestore: function(ctx) {
			// $search context is not restored beacause it's done in constructor (not regular process)
			if (ctx && ctx.$builder) {
				this.builder.savedCtxRestore(ctx.$builder);
			}
		},
		getScrollViewRect: function() {
			if (this.controller.isVignette) {
				var v = this.controller.getParentVignette();
				return v ? v.getScrollViewRect() : null;
			} else {
				return this.controller.getMainContentRect();
			}
		},
		/**
		 * Returns idx from rowId
		 * Used by single arrays
		 */
		rowId2Idx: function(uuid) {
			if (!this._arrayData || !this._arrayData.$resources) return -1;
			var rowIdx = -1;
			this._arrayData.$resources.some(function(r, idx) {
				if (r.getValue("$uuid") === uuid) {
					rowIdx = idx;
					return true;
				}
			});
			return rowIdx;
		},
		//Used when authoring to go to sublevel. the goal is to select the first record.
		rowIdx2Id: function(idx) {
			if (!this._arrayData || !this._arrayData.$resources) return -1;
			var rowId = -1;
			rowId = this._arrayData.$resources[idx].getValue("$uuid");
			return rowId;
		},
		_actActionArray: function(id, param) {
			if (id === globals.PANELFILTERSORT) {
				// Manual filters
				this.controller.panelAttach("right", this._filterSortPanel, "toggle");
				notifications.publish("sm.click.icon.filterSort", param.context);
				return;
			}
			if (id === "filterSelected") {
				// Selection of a filter given by the proto
				this.controller.$filtersSelect(param);
				return;
			}
			if (id === "search") {
				this.getSearcher().search(this);
				this.controller.searchRefresh();
				return;
			}
			if (id === "removeSearch") {
				this.getSearcher().removeSearch(this);
				this.controller.searchRefresh();
				return;
			}
		},
		/**
		 *  return array of sortInfo (not null)
		 */
		sortInfoGet: function() {
			var info = this.controller.filterSortRead("sort");
			if (info == null || info.length === 0) {
				var cols = this.builder.getColumnsInfo(true);
				if (cols) {
					info = [];
					cols.forEach(function(c) {
						if (_sortFilterExclude.indexOf(c.$type) === -1 && c.$capabilities && c.$capabilities.indexOf("sort") >= 0) {
							info.push({
								name: c.$title,
								// $bindValue is $bind for non reference field
								id: c.$bindValue,
								sort: "none"
							});
						}
					});
				}
				this.sortInfoSet(info, false);
			}
			return info;
		},
		sortInfoSet: function(info, refresh) {
			this.controller.filterSortWrite("sort", info, refresh);
		},
		/**
		 *  returns an array of filterInfo
		 */
		filterInfoGet: function() {
			var info = this.controller.filterSortRead("filter");
			return info;
		},
		/**
		* Sets filter info. Array of objects 
		* {
		*	fieldName : "fieldName",
		*	operatorLabel: "operator label",
		*	value: "value",
		*	operator: "operator code"
		}
		*/
		filterInfoSet: function(info, refresh) {
			this.controller.filterSortWrite("filter", info, refresh);
		},

		/**
		 * Returns filters map with following structure
		 *  [{
		 *		fieldName: 'field name',
		 *		operators: [], // array of possible operators according to field type,
		 *		id: proto.getFieldNameForValue(key),
		 *		prop: propertyValue, // Object
		 *		isReference: isReference // Boolean. Whether property is a reference or not
		 *	}, ...]
		 */
		searchInfoGet: function() {
			return this.getSearcher().getSearchInfos();
		},
		filterMapGet: function() {
			var self = this;
			var map = [];
			var props = this.builder.getColumnsInfo(false);
			if (props) {
				props.forEach(function(prop) {
					if (_sortFilterExclude.indexOf(prop.$type) === -1 && prop.$capabilities && prop.$capabilities.indexOf("filter") >= 0) {
						map.push({
							fieldName: prop.$title,
							operators: fieldOperators.getOperators(prop.$type),
							// $bindValue is $bind for non reference field
							id: prop.$bindValue,
							prop: prop,
							isReference: prop.$type.indexOf("x-reference") >= 0
						});
					}
				});
			}
			return map;
		},
		/**
		 * Retunrs the option for header - Should work in buildHtml and refresh
		 */
		getHeaderOptions: function() {
			var queryOrLookup = !this.isArrayField();
			var opts = {};
			// This is a query array
			// Manual sort/filters
			opts.filterEnabled = opts.sortEnabled = opts.paginEnabled = opts.searchEnabled = queryOrLookup;
			opts.searchEnabled = (opts.searchEnabled && !this.controller.offLine);
			// Filters given by prototype
			opts.$filters = queryOrLookup && this.controller.$filtersGet ? this.controller.$filtersGet() : null;
			// No search and filters for requests
			if (this.controller.prototype.isRequest() || this.controller.prototype.isStatistics()) {
				opts.sortEnabled = opts.searchEnabled = opts.filterEnabled = false;
				opts.$filters = null;
			}
			return opts;
		},
		/**
-		 * none/tabs/list
		 */
		$filtersGetAuthoring: function() {
			var auth = this.getAuthoring("$filters", this.controller.isVignette ? "none" : "list");
			if (auth !== "none" && globals.getSiteLayout().getDeviceType() === "smartphone") {
				auth = "tabs";
			}
			return auth;
		},
		/**
		 * enable/disable multiselection
		 */
		multiSelSetMgr: function(mgr) {
			if (this._multiselHandler) {
				this._multiselHandler = null;
			}
			if (mgr) {
				this._multiselHandler = jsutils.bindFn(mgr.callbackArray, mgr);
			}
		},
		/**
		 * Array as changed - Exit multisselection if any
		 */
		_multiSelStop: function() {
			if (this._multiselHandler) {
				this._multiselHandler(this, "$stopmultisel", null);
			}
		},
		_multiSelReset: function() {
			if (this._multiselHandler) {
				this._multiselHandler(this, "$reset", null);
			}
		},
		/**
		 * Row selection
		 */
		_multiSelSelect: function($$target) {
			if (this._multiselHandler) {
				this._multiselHandler(this, "$selectmultisel", $$target);
				return true;
			}
			return false;
		},
		/**
		 * Multiselection action is selectAll, unselectAll
		 * data-action with ctrlmId == array's id
		 */
		_actMultiSelectionAction: function(params, $target) {
			if (!this._multiselHandler) return;
			this._multiselHandler(this, params, $target);
		},
		authOnSlideMinSize: function(size, action) {
			if (!this.builder.authMinSize2Pixels) return;
			if (this.builder.$display != "card" || !this._arrayData || this._arrayData.length > 0) return;
			var value = this.builder.authMinSize2Pixels(size);
			var left = ((this.$$value.width() - value) / 2) + "px";
			value += "px";
			if (action == "start") {
				var height = this.$$value.find(this.$$value.find('[data-params="' + this._arrayData.$resources[0].getValue("$uuid") + '"]')).height();
				this.$$value.css({
					opacity: "0.3"
				});
				this._$$cardSize = $('<div class="s-m-auth-minsize"><span>Min size' + value + '</span></div>').appendTo(this.$$elmt);
				this._$$cardSize.css({
					height: height + "px",
					width: value,
					top: ((this.$$value.height() - height) / 2) + "px",
					left: left
				});
				return;
			}
			if (action == "stop") {
				this.$$value.css({
					opacity: "inherit"
				});
				this._$$cardSize.remove();
				this._$$cardSize = null;
				return;
			}
			if (action == "slide") {
				if (this._$$cardSize) {
					// slide action is called to get the text to display before starting the slider
					this._$$cardSize.css({
						width: value,
						left: left
					});
					if (!this._minCardText) {
						this._minCardText = locale.text("array.minCardWidth") + " ";
						this._minCardSpan = this._$$cardSize.children("span");
					}
					this._minCardSpan.text(this._minCardText + value);
				}
				return value;
			}
		},
		setCardAuthoring: function(article) {
			this.article.$card = article;
			notifications.publish("sm.auth.change.item.prop.ui");
		},
		// Only for test entities - We can attach an article to a link to detail or query
		getLinkedPageArticle: function() {
			return this._forceArticle;
		},
		notifLayoutExpanded: function() {
			// If we display an array on bloc expand we need to rfresh the scroller onec array has been displayed - #6541
			var self = this;
			setTimeout(function() {
				self.onResize();
			});
		},
		getSearcher: function() {
			return this._search;
		},
		checkCapabilities: function(value) {
			if (value == null) return true;
			if (!this._capabilities) {
				this._capabilities = {};
				var self = this;
				(this.getMetaData("$capabilities") || "").split(',').forEach(function(c) {
					c = c.trim();
					if (c.length > 0) {
						self._capabilities[c.trim()] = true;
					}
				});
			}
			return this._capabilities[value] === true;
		},
		getRowStatusInfo: function() {
			var type = this.getAuthoring("$statusEnabled");
			if (type === "mono" || type === "multi") {
				var status = this.getAuthoring("$status");
				if (!status || status.length === 0) return null;
				return {
					type: type,
					list: status
				};
			}
			return null;
		},
		/**
		 * Used by external tools (multiselection) to disable status temprorarily in cards
		 */
		toggleCardStatusColor: function(disable) {
			if (this.$display === "table") return;
			if (!this.getRowStatusInfo()) return;
			var style = disable ? "inherit" : "";
			this.$$value.find(".s-m-status-color").css({
				"background-color": style,
				"color": style
			});
		},
		/**
		 * Height/Width available to render the array
		 */
		getAvailableSize: function() {
			return {
				height: this.$$elmt.height() - this.$$header.height(),
				width: this.$$value.width()
			};
		},
		_actExternalLink: function(param) {
			this.controller.externalLink(param);
		},
		// Called by builder - can be overriden (chart array)
		setEmptyArrayMsg: function() {
			if (!this.isArrayField()) {
				var title = this.getTitle();
				if (title) {
					// Set in $$value to be removed on refresh
					$('<div class="s-m-no-data-title"/>').appendTo(this.$$value).text(title);
				}
				// Set in $$value to be removed on refresh
				$('<div class="s-m-no-data-label"/>').appendTo(this.$$value).text(locale.text("array.empty"));
			} else {
				// No label
			}
		},
		/**
		 * Call cell/tile parent (if any) to inform the that a array is nested in a vignette (query/stats/request only)
		 * Used to improve display - call notifSpecialArrayHosted method directly
		 * typeArray: chart/carousel
		 */
		notifyVignetteArrayHosted: function() {
			if (this.isArrayField() || this.prototype.isLookup() || !this.controller.isVignette || !this.controller.getParentVignette()) return;
			// Query/stats/requests....only
			var parent = this.controller.getParentVignette().parent;
			// Notifies cell/tile to improve display when a chart/carousel is nested
			// hack to remove the background color since we manage it by js (not css)
			if (parent && parent.notifSpecialArrayHosted) {
				var typeArray = this.isCarouselDisplay() ? "carousel" : this.$display;
				parent.notifSpecialArrayHosted(typeArray);
			}
		},
		_getProtoCardDesign: function() {
			var proto = this.prototype;
			var protoJson = {
				$url: "",
				$typ: "carddesign",
				$title: this.$bind,
				$links: {}
			};
			if (proto.isSingleArray()) {
				throw new Error("No card design for single array");
			} else {
				proto = proto.getPrototype("$item", protoJson, "details");
				var props = proto.data("$properties");
				Object.keys(props).forEach(function(key) {
					props[key].$isHidden = false;
				});
				return proto;
			}
		},
		_getSdataUrl: function(opt) {
			if (!opt || !opt.action) return this._getMainController(this.controller).getOriginalSdataUrl();
			var row = this.getRowById(opt.rowId, this._arrayData);
			return this.prototype.resolveExpression(this._arrayData.$links[opt.action].$url, row.row.data, true);
		},
		isAuthoringPropAllowed: function(property, value) {
			if (property !== "arrayDisplay") {
				return Base.prototype.isAuthoringPropAllowed.call(this, property, value);
			}
			switch (value) {
				case "table":
					return true;
				case "separator":
					return this.prototype.isSingleArray();
				case "card":
				case "carousel":
					return !this.prototype.isSingleArray();
				default:
					return false;
			};
		},
		hasSublevel: function() {
			if (this._arrayData.$links == null || this._arrayData.$links.$drillDown == null) return false;
			return !this._arrayData.$links.$drillDown.$isHidden;
		},
		isSublevel: function() {
			if (this._arrayData.$links == null || this._arrayData.$links.$drillUp == null) return false;
			return !this._arrayData.$links.$drillUp.$isHidden;
		}
	});

exports.Klass = _Klass;
exports.LocalPaginator = _LocalPaginator;