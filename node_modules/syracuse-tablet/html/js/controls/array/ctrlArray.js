"use strict";

var Base = require('syracuse-tablet/html/js/controls/ctrlSdataBase').CtrlSdataBase;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var datasetUtils = require('syracuse-tablet/html/js/sdata/datasetUtils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var settings = require('syracuse-tablet/html/js/app/settings');
var SdataController = require("syracuse-tablet/html/js/controllers/sdataController").SdataController;
var CtrlArrayTableRow = require('syracuse-tablet/html/js/controls/array/ctrlArrayTableRow').CtrlArrayTableRow;
var CtrlArrayCardCell = require('syracuse-tablet/html/js/controls/array/ctrlArrayCardCell').CtrlArrayCardCell;
var paginators = require("syracuse-tablet/html/js/controls/array/paginators");
var BuilderHeader = require('syracuse-tablet/html/js/controls/array/builderHeader').BuilderHeader;
var SearchArray = require('syracuse-tablet/html/js/controls/array/searchArray').SearchArray;
var FiltersSort = require('syracuse-tablet/html/js/controls/array/filtersSort');
var modules = require('syracuse-tablet/html/js/common/modules');
var BuilderTable = require('syracuse-tablet/html/js/controls/array/builderTable').BuilderTable;
var BuilderCard = require('syracuse-tablet/html/js/controls/array/builderCard').BuilderCard;
var BuilderCarousel = require('syracuse-tablet/html/js/controls/array/builderCarousel').BuilderCarousel;
var BuilderSeparator = require('syracuse-tablet/html/js/controls/array/builderSeparator').BuilderSeparator;
var BuilderChart = require('syracuse-tablet/html/js/controls/array/builderChart').BuilderChart;
var consts = require('syracuse-tablet/html/js/common/consts');
var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');

var _builders = {
	table: BuilderTable,
	card: BuilderCard,
	carousel: BuilderCarousel,
	separator: BuilderSeparator,
	chart: BuilderChart
};
/**
 * Used to create empty rowDataset
 */
var _typeDefValue = function(prop) {
	switch (prop.$type) {
		case "application/x-password":
		case "application/x-string":
			return "";
		case "application/x-quantity":
			return 0.0;
		case "application/x-decimal":
		case "application/x-real":
			return 0.0;
		case "application/x-integer":
			return 0;
		case "application/x-boolean":
			return false;
		case "application/x-date":
			return '';
		case "application/x-datetime":
			return '';
		case "application/x-time":
			return '';
		case "application/x-choice":
			return prop.$value.$enum[0].$value;
		case "application/x-reference":
			return {
				$value: "",
				$description: "",
				$title: ""
			};
		case "application/x-array":
			return [];
		default:
			return null;
	}
};
var _dataProps = ["$isMandatory", "$isReadOnly", "$isHidden", "$isExcluded", "$isDisabled", "$actions", "$format"];
var _proto2Instance = function(protoArray) {
	var res = {
		$properties: {}
	};
	var props = protoArray.getValueByPath("$properties");
	for (var propName in props) {
		if (!propName.smStartsWith("$")) {
			var prop = props[propName];
			res[propName] = _typeDefValue(prop);
			var $properties = res.$properties[propName] = {};
			_dataProps.forEach(function(p) {
				if (prop[p] != null) {
					$properties[p] = prop[p];
				}
			});
		}
	}
	return res;
};

/**
 * 
 * Array control
 * 
 * Will create it's own controller to manage array only
 * Per row, it will create a row controller and row control to represent the row
 * Doing it like this, there is always a flat structure per control
 * 
 * For value rendering, "normal" field controls are used
 * 
 */
exports.CtrlArray = utils.defineClass(
	function CtrlArray(controller, article, prototype, options) {
		Base.call(this, controller, article, prototype, options);
		this.$display = "table";
		this.displayAsCarousel = false;
		// An array has it's own controller scoped to the array property only
		this.arrayController = new SdataController(controller.dataset.getChild(this.$bind), controller);
		// UiAdapter is the arrayControl for server feedback
		this.arrayController.setUIAdapter(this);
		this._ensurePaginator();
		this.filterSearch = this.filterSortAllowed() ? new SearchArray(this) : null;
		// Predefined x3 filters
		this.filterX3 = this.filterSortAllowed() ? new FiltersSort.Filters(this) : null;
		// in relation with panel filterSort
		this.filterSort = this.filterSortAllowed() ? new FiltersSort.FilterSort(this) : null;
		this.builderContent = null;
		this.builderHeader = null;
		this._checkAuthoring();
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this.$$title = this.$$content = null;
			// Since the array creates it's own controller, it must also be destroyed here
			if (this.arrayController) {
				this.arrayController.destroy();
				this.arrayController = null;
			}
			if (this.paginator) {
				this.paginator.destroy();
				this.paginator = null;
			}
			if (this.filterSearch) {
				this.filterSearch.destroy();
				this.filterSearch = null;
			}
			if (this.builderHeader) {
				this.builderHeader.destroy();
				this.builderHeader = null;
			}
			if (this.filterX3) {
				this.filterX3.destroy();
				this.filterX3 = null;
			}
			if (this.filterSort) {
				this.filterSort.destroy();
				this.filterSort = null;
			}
			if (this.builderContent) {
				this.builderContent.destroy();
				this.builderContent = null;
			}
		},
		filterSortAllowed: function() {
			var page = this.tryGetPage();
			return page && !page.isChild("SdataRowDetail") && (this.prototype.root.isLookup() || this.prototype.root.isQuery());
		},
		_checkAuthoring: function() {
			this.$display = this.controller.isEditMode() || !this.article.$display ? "table" : this.article.$display;
			if (this.$display === "carousel") {
				this.$display = "card";
				this.displayAsCarousel = true;
			}
			// By default			
			// page is not set during initialization :-(
			var page = this.tryGetPage();
			var isChartDetail = page && page.isChild("SdataRowDetail");
			var isRowDetail = page && page.isChild("SdataChartDetail");
			var defAuthoring = {
				showPagination: !isChartDetail && !page.isVignette(),
				showSortFilter: this.filterSort != null,
				showSearch: this.filterSearch != null,
				rowIndex: this.$display === "card"
			};
			// Force with parents $arrayOptions if any
			this.article.$arrayOptions = $.extend(true, defAuthoring, this.article.$arrayOptions || {});
			// Force value depending on context
			if (this.displayAsCarousel === true) {
				this.article.$cardsPerRow = 1;
				this.article.$minWidth = 1;
				this.article.$filters = "none";
				this.article.$detailsLink = "$none";
				this.article.$arrayOptions = $.extend(true, this.article.$arrayOptions, {
					showPagination: false,
					showSortFilter: false,
					showSearch: false,
					rowIndex: true,
					showRowDetailLink: false
				})
			} else if (isChartDetail) {
				// No row detail in chart detail
				this.article.$arrayOptions.showRowDetailLink = false;
			} else if (isRowDetail) {
				// Force in row detail because no authoring
				this.article.$arrayOptions.showRowDetailLink = true;
			} else if (this.article.$arrayOptions.showRowDetailLink == null) {
				// False by default in other pages
				this.article.$arrayOptions.showRowDetailLink = false;
			}
			if (this.filterSortAllowed()) {
				var arrayOption = {
					showSearch: this.article.$arrayOptions.showSearch && (this._getArrayData().length > 0 || this.filterSearch.hasSearchCriteria()),
					showSortFilter: this.article.$arrayOptions.showSortFilter,
				}
				this.controller.setActionAdapterArrayOptions(arrayOption, this.filterSearch)
			}
		},

		get$ItemProto: function() {
			// this proto contains the right prototype for single arrays
			return this.arrayController.dataset.get$ItemProto();
		},

		_newBuilderContent: function() {
			var BuilderClass = _builders[this.$display == "card" ? this.displayAsCarousel ? "carousel" : "card" : this.$display];
			if (!BuilderClass) {
				this.$display = "table";
				this.displayAsCarousel = false;
				BuilderClass = _builders.table;
			}
			return new BuilderClass(this);
		},

		_newBuilderHeader: function() {
			if (this.isSingleArray()) {
				return null;
			}
			var headerOpts = $.extend(true, null, this.article.$arrayOptions);
			// $filters
			headerOpts.$filtersAuthoring = this.$filtersGetAuthoring();
			headerOpts.showSortFilter = headerOpts.showSortFilter && (this.filterSort != null) && this.page.isVignette();
			headerOpts.showSearch = headerOpts.showSearch && (this.filterSearch != null) && this.page.isVignette();
			if (this.isArrayField()) {
				// No pagination/search/filters for arrays nested inside pages
				headerOpts.showPagination = false;
			}
			if (headerOpts.showPagination || headerOpts.showSortFilter || headerOpts.showSearch || headerOpts.$$filtersAuthoring === "list") {
				return new BuilderHeader(this, headerOpts);
			}
			return null;
		},

		_iniBeforeBuild: function(refresh) {
			if (!this.$$elmt) {
				var css = ["s-m-array", "s-m-" + this.$display];
				if (this.displayAsCarousel) {
					css.push("s-m-carousel");
				}
				if (this.isSingleArray()) {
					css.push("s-m-single-array");
				}
				Base.prototype.buildHtml.call(this, css);
			}
			if (!this.$$title) {
				this.$$title = $(uiUtils.createDomElement('div', ["s-m-title"])).appendTo(this.$$elmt).hide();
			}
			// After title
			if (!this.$$content) {
				this.$$content = $(uiUtils.createDomElement('div', ["s-m-value"])).appendTo(this.$$elmt);
				if (this.$display === "card") {
					var bgColor = this.article.$arrayBgColor || "darkgrey";
					this.$$content.addClass("s-m-bg s-m-color-" + bgColor.toLowerCase());
				}
			}
			this.clearContent(refresh);
			this.$$elmt.toggleClass("empty", this.isEmpty());
			// Title
			var title = (this.getTitle() || "").trim();
			if (this._displayArray() && title.length > 0 && this.getAuthoring("$isTitleHidden") !== true) {
				this.$$title.show();
				this.$$title.text(title);
			}
		},
		/**
		 * Nb rows displayed (not the one in dataset if local paginator)
		 */
		getNbRows: function() {
			return this.paginator.getNumRowsPage();
		},
		isEmpty: function() {
			return this.getNbRows() == 0;
		},
		/**
		 * Returns the control attached to rowDataset.$uuid == rowId 
		 */
		getRowCtrlById: function(rowId) {
			return this.arrayController.getControl(consts.ROWID_PREFIX + rowId)
		},
		/**
		 * return an array of rowDataset
		 * Calculated because rows can be removed by server on server feedback
		 */
		_getArrayData: function() {
			var arrayData = [];
			var jj = this.paginator.getNumRowsPage();
			for (var ii = 0; ii < jj; ii++) {
				arrayData.push(this.paginator.getRowByIndex(ii))
			}
			return arrayData;
		},
		clearContent: function(refresh) {
			if (refresh !== true) {
				if (this.builderContent) {
					this.builderContent.destroy();
				}
				if (this.builderHeader) {
					this.builderHeader.destroy();
				}
				this.$$title.empty().hide();
				this.builderContent = this._newBuilderContent(this);
				this.builderHeader = this._newBuilderHeader(this);
			}
			this.$$content.empty();
		},
		buildHtml: function(refresh) {
			this._iniBeforeBuild(refresh);
			var arrayData = this._getArrayData();
			if (this.builderHeader) {
				this.builderHeader.buildHtml(arrayData, refresh);
			}
			if (this.builderContent) {
				// Build elements that don't depend on parent's size
				this.builderContent.buildHtml(arrayData, this.$$content, refresh);
			}
		},

		// Build elements that depend on parent's size
		buildOnResize: function(context) {
			if (!this.builderContent) {
				return;
			}
			var arrayData = this._getArrayData();
			this.builderContent.buildOnResize(arrayData, this.$$content, context);
			//Notifies cell/Tile parent - Display optimization
			this.notifyVignetteArrayHosted();
		},

		computeLayout: function(context) {
			this.buildOnResize(context);
		},

		/** 
		 * Create a CardCellCtrl or CardCellCtrl
		 */
		createRecordCtrl: function($$container, recordDataset, index, opts) {
			if (recordDataset == null) {
				recordDataset = this.createEmptyRowDataset();
			}
			var $bind = this.$bind + "-" + recordDataset.$bind + "-" + index;
			var klass;
			var noEdit = true;
			if (this.$display === "card") {
				klass = CtrlArrayCardCell;
			} else if (this.$display === "table") {
				klass = CtrlArrayTableRow;
				// Edit allowed for single arrays
				noEdit = this.isSingleArray() !== true
			} else {
				throw new Error("Unknown record array control")
			}
			opts = $.extend(true, {
				rowIndex: index,
				noEdit: noEdit,
				// This is the link on rows for "real" navigation (e.g. go to $details)
				rowLinkDomAttrs: this._createRecordLinkAttr(),
				drillDownDomAttrs: this._createDrillDownLinkAttr(),
				// Links for child arrays to remove/edit rows
				showRowDetail: this.article.showRowDetailLink,
				showRowDelete: this.prototype.hasCapability("delete")
			}, opts);

			var rowCtrl = new klass(recordDataset, this.arrayController, {
				$bind: this.$bind + "-" + recordDataset.$bind + "-" + index
			}, recordDataset.prototype, opts);
			this.appendStructElmt(rowCtrl);
			rowCtrl.set$$container($$container);
			rowCtrl.page = this.page;
			return rowCtrl;
		},
		_createRecordLinkAttr: function() {
			if (this.isArrayField() || this.isArrayChart()) return null
			var linkDomAttrs;
			if (this.controller.root.isLookupController) {
				linkDomAttrs = this.getDataActionAttrs("lookupAccept");
			} else {
				var $linkName = this.getAuthoring("$detailsLink");
				if ($linkName == null) {
					$linkName = this.page.isVignette() ? "$queryfullpage" : "$details";
				}
				var $links = this.get$ItemProto().data("$links");
				if ($linkName == "$queryfullpage" || ($links && $links[$linkName])) {
					linkDomAttrs = this.getSdataLinkAttrs($linkName);
				} else {
					linkDomAttrs = null;
				}
			}
			return linkDomAttrs;
		},
		_createDrillDownLinkAttr: function() {
			if (!this.isChartDetailPage()) return null
			var $linkName = "",
				linkDomAttrs = null;
			var $links = this.get$ItemProto().data("$links");
			if (!$links) return null;
			if ($links.$drillDown) $linkName = "drillDown";
			if ($links.levelUp) $linkName = "levelUp";
			if ($linkName !== "") linkDomAttrs = this.getDataActionAttrs($linkName);
			return linkDomAttrs;
		},
		/**
		 * Force to update the scroller
		 */
		notifyScrollerUpdate: function() {
			if (this.builderContent) {
				this.builderContent.updateGestureMgr();
			}
		},
		/**
		 * Called by paginator on server side pagination
		 * The paginator tells the array the new url which has to be loaded
		 * and the array just asks it's containing page to reload
		 */
		notifyPaginationServer: function($link) {
			this._updateSdataUrl($link)
		},

		/** 
		 * Called by paginator on client side pagination to just redraw the array
		 * Must cleanup DOM and other stuff created before and then trigger a rebuild of the array only
		 */
		notifyPaginationLocal: function() {
			// Destroy row controls
			this.destroyChildren();
			this.buildHtml(true);
		},
		/**
		 * Filter/Search
		 */
		notifyApplyFilter: function($url) {
			this._updateSdataUrl({
				"$url": $url
			})
		},
		_updateSdataUrl: function($link) {
			$link && $link.$url && ($link.$url = protoHelpers.addClientContext($link.$url, this.controller.dataset.root.json.$clientContext));
			this.page.fetchNewPageData($link)
		},

		_ensurePaginator: function() {
			this.paginator = new paginators.ArrayPaginatorServer(this);
		},
		_actPagination: function(direction) {
			if (!this.paginator.isEnabled(direction)) {
				return;
			}
			this.paginator.paginate(direction);
		},
		_actActionArray: function(id) {
			switch (id) {
				case "panelfiltersort":
					this._openFilterSortPanel();
					break;
				case "filterSelected":
					var filterId = arguments[1]
					if (filterId) {
						this.filterX3.filtersSelect(filterId);
					}
					break;
				case "search":
					this.filterSearch.search();
					break;
				case "removeSearch":
					this.filterSearch.removeSearch();
					break;
			}
		},
		_openFilterSortPanel: function() {
			var panel = this.page.openPanel("filterSortPanel", {
				filter: true,
				sort: true
			})
			panel.ensureParentArray(this.id)
			panel.show();
		},
		isArrayField: function() {
			if (!this.controller) return false;
			return !this.prototype.root.isQueryLikeFacet();
		},

		isSingleArray: function() {
			return this.prototype.isSingleArray();
		},

		isArrayChart: function() {
			return false;
		},
		/*Used by filterSort filters and searchArray*/
		getFilterSortOptions: function() {
			var opt = {
				"$url": this.page.pageData.prototype.getValueByPath("$url", true, true),
				"$filters": this.filterX3 ? this.filterX3.get$filterToApply() : null,
				"sortInfo": this.page.getPageSort(),
				"filterInfos": this.page.getPageFilter(),
				"searchInfo": this.filterSearch ? this.filterSearch.searchInfos : null
			};
			return opt;
		},
		excludeChildrenFromAuthoring: function() {
			return true;
		},

		getRowStatusInfo: function() {
			var type = this.getAuthoring("$statusEnabled");
			if (type === "mono" || type === "multi") {
				var status = this.getAuthoring("$status");
				if (status == null || $.isEmptyObject(status)) return null;
				return {
					type: type,
					list: status
				};
			}
			return null;
		},

		/**
		 * Returns the columns to display with all info needed by builder
		 */
		getColumnsInfo: function(onlyVisible) {
			if (!this._columnsInfo) {
				var base = {
					$title: "",
					$titleOrig: "", // title not resolved
					$type: "",
					$bind: "",
					$widthType: "auto",
					$imgHeight: "small",
					$widthVal: 0,
					$capabilities: ""
				};
				this._columnsInfo = [];
				var itemProto = this.get$ItemProto();
				var props = itemProto.data("$properties");
				if (props) {
					var self = this;
					Object.keys(props).forEach(function($bind) {
						var prop = props[$bind];
						if (prop.$isHidden !== true && prop.$isExcluded !== true && ["CREUSR", "CREUSR_REF", "UPDUSR", "UPDUSR_REF"].indexOf($bind) < 0) {
							var p = $.extend(true, {}, base, prop);
							p.$title = itemProto.resolveExpression(prop.$title);
							p.$titleOrig = prop.$title;
							// Bind field - Ex SITE_REF
							p.$bind = $bind;
							// Name of the field that contains the value - !=$bind for non reference fields - Ex For SITE_REF -> SITE
							p.$bindValue = itemProto.getFieldValueName($bind);
							// Type of the field that contains the value - !=$type for non reference fields - Ex For SITE -> "application/x-string"
							p.$bindType = itemProto.getFieldValueType($bind);
							self._columnsInfo.push(p);
						}
					});
				}
			}
			// META
			var dataProps = this.controller.dataset.getValueByPath("$properties");
			if (onlyVisible !== true || dataProps == null) {
				return this._columnsInfo;
			}
			var res = [];
			this._columnsInfo.forEach(function(prop) {
				if (dataProps[prop.$bind] == null || dataProps[prop.$bind].$isHidden !== true) {
					res.push(prop);
				}
			});
			return res;
		},

		_actAddRow: function() {
			var self = this;
			// Let the controller create a new row and eventually sync with the server
			// Then, render the new row afterwards since the server may set some values
			this.arrayController.addRow()
				.then(function(rowDataset) {
					if (rowDataset) {
						self.builderContent.appendRow(rowDataset).doAfterClickAddRow(self.isSingleArray());
					}
				})
				.fail(function(result) {
					modules.get("modal").error(result);
				});

		},
		/**
		 * Called by a click action
		 */
		removeRow: function(rowCtrl) {
			var self = this;
			this.arrayController.removeRow(rowCtrl.getUuid()).then(function() {
					self._deleteCtrlRow(rowCtrl);
				})
				.fail(function(result) {
					modules.get("modal").error(result);
				});
		},
		/**
		 * 
		 */
		_deleteCtrlRow: function(rowCtrl) {
			if (!rowCtrl) {
				return;
			}
			rowCtrl.destroy();
			this._updateRowsIndex();
		},
		/**
		 * After a deletion/insertion refresh index and background (add/even)
		 */
		_updateRowsIndex: function(skipRowCtrl) {
			var self = this;
			var realIdx = 1;
			this._getArrayData().forEach(function(rowDataset, idx) {
				var rowCtrl = self.getRowCtrlById(rowDataset.getUuid());
				if (rowCtrl != null && (skipRowCtrl == null || skipRowCtrl != rowCtrl)) {
					// rowCtrl can be null if it's the row that has just been removed (_deleteCtrlRow)
					// The rowDataset is actually removed after ui process 
					rowCtrl.updateRowIndex(realIdx++);
				}
			})
		},

		_displayArray: function() {
			return this.controller.isEditMode() === true || !this.isEmpty() || this.getAuthoring("$displayIfEmpty") === true;
		},
		getScrollViewRect: function() {
			if (this.page.parentVignette) {
				return this.page.parentVignette.getScrollViewRect();
			} else {
				return this.page.mainContentRect;
			}
		},
		/**
		 * none/tabs/list
		 * Stored in $resources array
		 */
		$filtersGetAuthoring: function() {
			if (!this.filterX3) {
				return "none";
			}
			var auth = this.getAuthoring("$filters", this.page.isVignette() ? "none" : "list");
			if (auth !== "none" && settings.getDeviceType() === "smartphone") {
				auth = "tabs";
			}
			return auth;
		},
		$filtersAllowed: function() {
			return this.filterX3 != null && this.filterX3.hasFilters();
		},
		/**
		 * text can be overridden (chart)
		 */
		setEmptyArrayMsg: function(text) {
			this.$$content.empty();
			if (!this.isArrayField()) {
				var title = this.getTitle();
				if (title) {
					$('<div class="s-m-no-data-title"/>').appendTo(this.$$content).text(title);
				}
				$('<div class="s-m-no-data-label"/>').appendTo(this.$$content).text(text || locale.text("array.empty"));
			} else {
				// No label
			}
		},
		/**
		 * Call cell/tile parent (if any) to inform the that a array is nested in a vignette (query/stats/request only)
		 * Used to improve display - call notifSpecialArrayHosted method directly
		 * typeArray: chart/carousel
		 */
		notifyVignetteArrayHosted: function() {
			if (this.isArrayField() || this.prototype.isLookup() || !this.page.isVignette() || !this.page.parentVignette) {
				return;
			}
			// Query/stats/requests....only
			var parent = this.page.parentVignette.parent;
			// Notifies cell/tile to improve display when a chart/carousel is nested
			// hack to remove the background color since we manage it by js (not css)
			if (parent && parent.notifSpecialArrayHosted) {
				var typeArray = this.displayAsCarousel ? "carousel" : this.$display;
				parent.notifSpecialArrayHosted(typeArray);
			}
		},
		savedCtxCreate: function(opts) {
			if (!this.builderContent) return;
			var res = {};
			var builderCtx = this.builderContent.savedCtxCreate(opts);
			if (builderCtx) {
				res.$builder = builderCtx
			}
			return $.isEmptyObject(res) ? null : res;
		},
		savedCtxRestore: function(ctx) {
			if (!ctx) {
				return;
			}
			if (this.builderContent && ctx.$builder) {
				this.builderContent.savedCtxRestore(ctx.$builder);
			}
		},
		/**
		 * Returns the size available to display cards
		 */
		getAvailableSizeForCards: function() {
			var scale = this.getTransformScale();
			return {
				height: (this.$$elmt.height() - (this.builderHeader ? this.builderHeader.$$elmt.height() : 0)) / scale,
				width: this.$$content.width() / scale
			};
		},
		/**
		 * Returns an empty row dataset
		 */
		createEmptyRowDataset: function() {
			var proto = this.arrayController.dataset.rowPrototype;
			var json = _proto2Instance(proto);
			json.$uuid = utils.UUID();
			// We path pathBind as $bind in empty dao to be able to retrieve the full path of prototype in nested arrays
			return this.arrayController.dataset.createRowDataset(json, proto, json.$uuid);
		},
		/**
		 * Called when we set the minimum size of a card
		 */
		authOnSlideMinSize: function(size, action) {
			if (!this.builderContent || !this.builderContent.authMinSize2Pixels) {
				return;
			}
			var arrayData = this._getArrayData();
			if (this.$display != "card" || arrayData.length == 0) {
				return;
			}
			var scale = this.getTransformScale();
			var value = this.builderContent.authMinSize2Pixels(size);
			var contentW = this.$$content.width() / scale;
			var contentH = this.$$content.height() / scale;

			var left = ((contentW - value) / 2) + "px";
			value += "px";
			if (action == "start") {
				var height = this.$$content.find(this.$$content.find("#" + consts.ROWID_PREFIX + arrayData[0].getValue("$uuid"))).closest(".s-m-record").height();
				height = height
				this.$$content.css({
					opacity: "0.3"
				});
				this._$$cardSize = $('<div class="s-m-auth-minsize"><span>Min size' + value + '</span></div>').appendTo(this.$$elmt);
				this._$$cardSize.css({
					height: height + "px",
					width: value,
					top: this.$$content.position().top + (height / 2) + "px",
					left: left
				});
				return;
			}
			if (action == "stop") {
				this.$$content.css({
					opacity: "inherit"
				});
				this._$$cardSize.remove();
				this._$$cardSize = null;
				return;
			}
			if (action == "slide") {
				if (this._$$cardSize) {
					// slide action is called to get the text to display before starting the slider
					this._$$cardSize.css({
						width: value,
						left: left
					});
					if (!this._minCardText) {
						this._minCardText = locale.text("array.minCardWidth") + " ";
						this._minCardSpan = this._$$cardSize.children("span");
					}
					this._minCardSpan.text(this._minCardText + value);
				}
				return value;
			}
		},
		isChartDetailPage: function() {
			return false;
		},
		isAuthoringPropAllowed: function(property, value) {
			if (property !== "arrayDisplay") {
				return Base.prototype.isAuthoringPropAllowed.call(this, property, value);
			}
			switch (value) {
				case "table":
					return true;
				case "separator":
					return this.isSingleArray();
				case "card":
				case "carousel":
					return !this.isSingleArray();
				default:
					return false;
			}
		},
		getCardDetailPageData: function() {
			var dataset = this.getAuthoringDataset();
			return {
				prototype: dataset.prototype,
				dataset: dataset,
				page: {
					$article: this.article.$card
				}
			};
		},
		getAuthoringDataset: function() {
			var datasetJson;
			var arrayDataSet = this.arrayController.dataset;
			var num = arrayDataSet.getNumRows();
			if (num > 0) {
				datasetJson = arrayDataSet.getRowByIndex(0).json;
			} else {
				datasetJson = {};
			}
			var prototype = arrayDataSet.rowPrototype.clone();
			var klass = datasetUtils.getImplementation("RowDataset");
			var dataset = new klass(datasetJson, prototype, arrayDataSet, "$cardDetailDummy");

			// In authoring, there are only operations on the prototype, so we inject placeholders here to make
			// the text available later with no need to reference the data
			prototype.json.$title = dataset.resolveExpression(prototype.json.$title);
			return dataset;
		},
		setCardDetailArticle: function(article) {
			this.article.$card = article;
		},
		/**
		 * Used to convert .height()/.width() to the real px
		 */
		getTransformScale: function() {
			return modules.get("siteLayout").getTransformScale();
		},
		/**
		 * Disable/Enable array's header
		 */
		multiSelToggleStatus: function(enabled) {
			if (this.builderHeader) {
				this.builderHeader.disable(enabled === true);
			}
		},
		/**
		 * Returns the selected rows
		 */
		multiSelGetSelectedData: function(disableClick) {
			var self = this;
			var data = [];
			this.$$content.find(".s-m-record.s-m-multi-selected").each(function(idx, record) {
				record = $(record);
				// avoid click
				if (disableClick) {
					record.attr("disabled", "true");
				}
				var selector = '.s-m-control.s-m-ctrl[data-sdata-link-bind="$resources"]';
				var rowId = record.is(selector) ? record : record.find(selector);
				rowId = rowId.attr("id").split(consts.ROWID_PREFIX);
				if (rowId.length > 0) {
					rowId = rowId[1];
					var rowdata = self.arrayController.dataset.getRowByUuid(rowId);
					if (rowdata) {
						data.push({
							rowData: rowdata,
							rowId: rowId,
							$$record: record,
							idx: idx,
							status: "init"
						});
					}
				}
			});
			return data;
		},
		/**
		 * Add a diagnose and check the row/card as error
		 * data.$$record record that failed
		 * data.$diagnoses diagnoses to display
		 */
		multiSelAddDiagnoses: function(data) {
			// error/success
			data.$$record.addClass(data.status);
			if (data.success !== true && data.$diagnoses && data.$diagnoses.length > 0) {
				var diag = data.$diagnoses[0];
				var $$diag = $('<div " class="alert alert-' + (diag.$severity === "error" ? "danger" : "success") + '" role="alert">' + diag.$message + '</div>');
				var $$root;
				var smoothOffset;
				if (this.$display == "table") {
					var colSpan = data.$$record.children('td').length;
					$$root = $('<tr class="s-m-multisel-diag" data-nevent data-naction="multiSelTriggerAction" data-params="showdiagnoses"><td colspan="' + colSpan + '"/></tr>');
					data.$$record.after($$root);
					$$diag.appendTo($$root.find("td"));
					smoothOffset = 30;
				} else {
					$$root = $('<section style="padding:2px;width:100%;left: 0px;bottom:0px;" class="s-m-multisel-diag" data-nevent data-naction="multiSelTriggerAction" data-params="showdiagnoses"/>').prependTo(data.$$record.find(".s-m-card"));
					$$diag.appendTo($$root);
					smoothOffset = 5;
				}
				$$root.smData('diagnoses', data.$diagnoses);
				this.notifyScrollerUpdate();
			}
			// smoothOffset != null -> smooth scrolling (value is empirical)
			this.builderContent.makeVisible(data.$$record, smoothOffset)
		},
		/**
		 * Show the diagnose attached to  diagnose and check the row/card as error
		 */
		multiSelShowDiagnoses: function(event) {
			if (!event) {
				return;
			}
			var $$elmt = $(event.target).closest(".s-m-multisel-diag");
			var diags = $$elmt.smData('diagnoses');
			if (diags == null || diags.length == 0) return;
			modules.get("modal").error({
				$diagnoses: diags
			});
		},
		/**
		 * Called when exit multiselection processing
		 */
		multiSelExit: function() {
			// error/success
			this.$$content.find(".s-m-record").removeClass("error success");
			var $$diags = this.$$content.find(".s-m-multisel-diag");
			$$diags.smRemoveData('diagnoses').remove();
			$$diags.remove();
			// Enable click on row
			this.$$content.find(".s-m-record.s-m-multi-selected").removeAttr("disabled");
			this.notifyScrollerUpdate();
		},
		/**
		 * Called when the data set is modified
		 * action: added, removed, moved
		 * $uuid: row's uuid
		 * idx: rows idx
		 */
		onDeltaRow: function(action, arrayDataset, $uuid, idx) {
			// Removes the existing row
			var rowCtrl;
			this.arrayController.forEachControl(function(row) {
				if (row && row.getUuid() == $uuid) {
					rowCtrl = row;
					return true;
				}
			})
			if (rowCtrl) {
				this._deleteCtrlRow(rowCtrl);
			}
			if (action == "removed") {
				return;
			}
			// Create row
			var rowDataset = arrayDataset.getRowByUuid($uuid);
			if (!rowDataset) {
				return;
			}
			// Always append
			rowCtrl = this.builderContent.appendRow(rowDataset);
			this._updateRowsIndex();
		}
	});