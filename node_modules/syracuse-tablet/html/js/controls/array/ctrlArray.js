"use strict";


var utils = require('syracuse-tablet/html/js/helpers/utils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var Base = require('syracuse-tablet/html/js/controls/ctrlBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var modal = require('syracuse-tablet/html/js/ui/modal');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var daoSdata = require('syracuse-tablet/html/js/application/daoSdata');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _filterSortPanelId = "filtersortpanel";

var _notImplemented = function(text) {
	throw new Error("The following feature in not implemented -> " + text);
};
var Builders = {
	table: require('syracuse-tablet/html/js/controls/array/builderTable').Klass,
	cardV: require('syracuse-tablet/html/js/controls/array/builderCardV').Klass,
	cardH: require('syracuse-tablet/html/js/controls/array/builderCardH').Klass
};
var _destroyArrayData = function(a) {
	if (!a || !a.$resources) return null;
	a.$resources.forEach(function(r) {
		if (r) r.destroy();
	});
	return null;
};
/**
 * x-array control class
 * Authoring
 * 			$isTitleHidden: 		true/false
 * 			$height					height of array - if no height displays full array
 * 									add pan event to scroll(no swipe)
 * 			$width					100% by default - not needed
 * 			$displayIfEmpty:		true/false - Maybe a general property for fields to not display the control if empty
 *                              	If false we display the label and default value
 *      							Useful to optimize display
 *  		$emptycell				Ford cards mode - Value! ’empty’, ‘filled’, ‘withtitle’
 * 				empty:		 			doesn't fill grid with empty cells
 * 				filled:					fills grid with empty cells
 * 				withtitle:				fills grid with cards wit titles and default field values
 * 			$display				display mode cardV, cardH, table
 * 			for cardV
 * 				$cardMode	 			Display mode
 * 					single 					to display one card at a time with a swipe to walk inside the collection
 * 					multiple 				to display a list of cards
 * 				$cardsPerRow 			number of cards per row
 * 										height is calculated in percentage based on control width (full parent page with by default)
 * 				for field array 		s-m-control.s-m-array parent page has class detail or edit
 * 					$pagination				Displays N cards at a time on other ones on swipe
 * 											Default is 1
 * 			for cardH
 * 				$cardsPerLine 			number of cards per line
 * 										height is calculated in percentage based on control height (mandatory)
 * 				for field array 		s-m-control.s-m-array parent page has class detail or edit
 * 					$pagination			Displays N cards at a time and other ones on swipe
 * 										Default is 1
 */
var _Klass = utils.defineClass(
	function(controller, article, prototype, options) {
		var self = this;
		Base.call(self, controller, article, prototype, options);
		article.$article = article.$article || {};
		var Builder = Builders[article.$display];
		if (!Builder) {
			Builder = Builders.table;
		}
		self.builder = new Builder(self, options);
		self._arrayData = null;
		// All the rows with a link to rowDetail are registered in _rowDetailCache - id: {pathId,pathBind}
		// When we display arrays nested in arrays in card mode we need to store the path to access to the data/proto of the selected row
		// -> Cards Html is generated and the control object is not stored so we need to store the path to retrieve it from mainControl (htmlRootCtrl)
		self._rowDetailCache = {};
		// Info of the clicked row
		self._rowDetailInfo = null;
	}, Base, {
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			if (this._arrayData) this._arrayData = _destroyArrayData(this._arrayData);
			if (this.builder) this.builder.initReuseProperties();
		},
		destroy: function() {
			// Just set to null - destroyed by rowDetail page
			this._rowDetailInfo = null;
			// Just set to null
			this._rowDetailCache = null;
			Base.prototype.destroy.call(this);
			this.prototype = null;
			if (this.builder) {
				this.builder.destroy();
				this.builder = null;
			}
			if (this._arrayData) {
				this._arrayData = _destroyArrayData(this._arrayData);
				this._arrayData = null;
			}
			if (this._waiting) {
				uiUtils.waitWheelDestroy(this._waiting);
				this._waiting = null;
			}
			if (this._waiting) {
				this._filterSortPanel.destroy();
				this._filterSortPanel = null;
			}
		},
		isArrayField: function() {
			return !this.prototype.isLookup() && !this.prototype.isQuery();
		},
		/**
		 *	Build html DOM object + bind event
		 **/
		buildHtml: function($$parent, controllerDao, buildOptions) {
			if (this.builder == null) throw new Error("Null builder");
			// Create standard root elmt
			var disp = this.article.$display || "table";
			var css = "s-m-";
			if (disp === "cardV") {
				css += "card s-m-V";
			} else if (disp === "cardH") {
				css += "card s-m-H";
			} else {
				css += disp;
			}
			// Build root elm
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions, ["s-m-array", css]);
			// Set up array data and isEmpty property used to managed authoring - Display title
			this._setArrayData(controllerDao, false);
			if (this._displayArray()) {
				if (!this.isArrayField()) {
					buildOptions.filterEnabled = buildOptions.sortEnabled = buildOptions.paginEnabled = true;
					this._filterSortPanel = this.controller.panelCreate(_filterSortPanelId, {
						parentArray: this,
						filter: buildOptions.filterEnabled,
						sort: buildOptions.sortEnabled
					});
				}
				this.builder.buildHtml(this._arrayData, buildOptions);
				if (this.prototype.isSingleArray() && this.builder.isEmptySingleArray()) {
					// #5529 Special case -> single array and all records with $isHidden = true -> test AQMCRUDM
					this.isEmpty = true;
				} else if (buildOptions.sortEnabled === true) {
					this._filterSortUpdateHeader();
				}
			}
			// Hidden if no data and no title - take into account this.isEmpty for singleArrays
			if (!this._displayArray() && (this.$$ttl == null || this.$$ttl.empty())) {
				this.$$elmt.hide();
			}
		},
		/**
		 * Refreshes the control
		 */
		refresh: function(controllerDao, options) {
			this._rowDetailInfo = null;
			if (this.builder == null) throw new Error("Null builder");
			var selRowId = this.builder.getSelectedRowId();
			this.builder.refresh(this._setArrayData(controllerDao, true), options);
			if (selRowId) {
				this.builder.selectLastSelectedRow(selRowId, true);
			}
			if (this._filterSortPanel) {
				this._filterSortUpdateHeader();
			}
		},
		onResize: function() {
			if (this.builder.onResize) {
				this.builder.onResize();
			}
		},
		_notifSelectedRow: function(rowId, rowData) {
			notifications.pageNotify("sm.select.row", this.controller, this.id, rowId, rowData, false);
		},
		/**
		 * handle selection of a row for lookup
		 */
		_actRowSelect: function(rowId) {
			var rowData = this._getRowById(rowId);
			if (!rowData) return;
			rowData = rowData.row;
			if (this.controller.isLookup()) {
				/** SELECTION ON LOOKUP ARRAY**/
				// Extract title/description
				var info = rowData.prototype.getLookupInfo();
				var res = {};
				for (var p in info) {
					res[p] = rowData.getValue(info[p]);
				}
				// Notify selection to lookup page
				this._notifSelectedRow(rowId, res);
			} else {
				/** SELECTION ON REGULAR ARRAY**/
				// Notify last selected row to current page - Stores the lastSelectedRowId - see selectLastSelectedRow
				// false to not update UI because link destroy the page
				this._notifSelectedRow(rowId, rowData);
				// Open the link
				var links = this.builder.$itemProto.data("$links");
				var linkProto = (links && links.DASHBOARD) || (links && links.$details);
				if (linkProto) {
					var attrs = {};
					var link = sdataUtils.getLinkInfo(linkProto.$url, rowData);
					attrs["data-nav"] = link.page;
					attrs["data-nav-target"] = this.controller.openLinkInVignette() ? "vignette" : "application";
					if (link.sDataUrl) {
						attrs["data-sdata-url"] = link.sDataUrl;
					}
					if (link.parameters) {
						var params = utils.parseExpression(link.parameters, rowData);
						attrs["data-sdata-parameters"] = params;
					}
					eventListener.triggerNavigation(this.$$elmt, attrs);
				}
			}
		},
		/**
		 * Called when we click on editRow, detailRow, createRow
		 * Calculate information dao/proto/name for rorwDetail page
		 * Each time a rowDetail link is generated, we store link info in _rowDetailCache
		 * 		Path of array from the current array
		 * 		Path of row ids from current array
		 * This method retrieve dao/proto objects from stored info
		 * 		rowDetail page needs _rowDetailInfo.dao in lodaData method
		 *  	pageHelpers._getRowdetailPage needs _rowDetailInfo.proto and _rowDetailInfo.pathBind to build rowDetail page proto
		 *
		 *  rowInfofId is the id of the cached info
		 */
		_openDetailRow: function(rowInfofId) {
			var self = this;
			try {
				// Info that has been set by the builder - Contains path of $binds and ids for each row displayed
				var info = self._rowDetailCache[rowInfofId];
				if (!info) throw new Error("rowDetailGetDao - Unexpected null row info");
				var isRowCreation = info.activity === "create";
				// Path of parent arrays
				var pathBind = info.pathBind;
				if (isRowCreation && pathBind.length > 1) {
					// TODO - Create new row in an array embedded inside a card
					// Currently we force table mode in edit mode
					_notImplemented("Creating row in an array embedded inside a card");
				} else {
					// Ok if not patpathBindhBind.length > 1 in display mode 
					// We allow display of row detail in an arrayy embedded inside a card - Tested
				}
				// Id of parent rows
				var pathId = info.pathId;
				var proto = self.prototype.parent;
				var protoPath = ["$properties"];
				var dao = self.getDao();
				for (var i = 0; i < pathBind.length; i++) {
					protoPath.push(pathBind[i]);
					// Get Proto and dao for the ith array
					proto = proto.getPrototype(protoPath.join("."));
					// Some explanations about he way to retreive the right row dao
					// When we generate cards or grids we don't store controls and associated dao object (see html generator) - We keep only the generated html
					// We need a way to retreive the right row dao when we click on a row Detail link (there are complex use cases with cards arrays inside cards arrays)
					// -> We save the path of row ids and path of $bind in _rowDetailCache
					// To retreive the row dao we scan the current Dao from to pathBinds and pathRowIds
					var arrayData;
					if (self.$bind === pathBind[i]) {
						// We are on the current dao -> we take the current object dao
						// It's important in order to set rowDetail parent with the right dao object
						//  -> pageRegular.notifRowdetailUpdate -> childDao.updateParentRow will update the right parent dao
						arrayData = self._arrayData;
					} else {
						if (!dao) throw new Error("Unexpected null dao");
						// We are on a parent of the current dao -> we create a new dao object
						arrayData = dao.getArrayData(pathBind[i], proto);
					}
					// Search the row by id in dao
					var res = self._getRowById(pathId[i], arrayData);
					if (!res) {
						if (!isRowCreation) throw new Error("Unexpected empty row");
						res = {
							row: daoSdata.getArrayEmptyRow(this, proto, pathBind[i], dao)
						};
					}
					// Current dao	
					dao = res.row;
					// Current path root in protoype
					protoPath = ["$item.$properties"];
				}
				if (!dao || dao === self.getDao()) return;
				// we create the proto for detail row
				proto = daoSdata.getProtoRowDetail(this, proto);
				pathBind = info.pathBind.join('.');
				// Stores row Detail in info - RowDetail info will be requested by rowDetail page in loadData method
				self._rowDetailInfo = {
					// Path of the array from root (page) - use dto calculated the id of the rowDetail page
					pathBind: pathBind,
					// dao of rowDetail page
					dao: dao.clone(),
					// Proto of row detail page
					proto: proto,
					activity: info.activity
				};
				// Trigger a navigation to rowDetail page
				var attrs = {
					"data-control-id": self.id,
					"data-parent-id": self.controller.id,
					"data-nav": "rowdetail",
					"data-params": dao.getValue("$uuid")
				};
				if (self.controller.isVignette) {
					// It's the vignette which will load the page
					// We open row detail in the same vignette
					attrs["data-nav-target"] = "vignette";
				}
				// Notify last selected row - see selectLastSelectedRow - true to update UI because link doesn't destroy the page
				if (!isRowCreation) {
					notifications.pageNotify("sm.select.row", self.controller, self.id, dao.getValue("$uuid"), null, true);
				}
				eventListener.triggerNavigation(self.$$elmt, attrs);
			} catch (e) {
				globals.getModal().error("Error loading row detail page", e);
			}
		},
		/**
		 * Click on display or edit row detail
		 * Id is stored in s-m-record parent dom elment
		 */
		_actRowDetail: function(rowInfofId) {
			this._openDetailRow(rowInfofId);
		},
		/**
		 * Click on create a new row
		 * Id is stored data-cation element
		 * This action is nor really a row action, it's an array action
		 */
		_actRowCreate: function(rowInfofId) {
			this._openDetailRow(rowInfofId);
		},
		/**
		 * handle delete row
		 */
		_actRowDelete: function(rowId) {
			var self = this;
			// Info that has been set by the builder - Contains path of $binds and ids for each row displayed
			var info = self._rowDetailCache[rowId];
			if (!info) return;
			modal.simpleConfirm(locale.text("actions.del.confirm"), function(confirmed) {
				if (confirmed) {
					// Retreive the current array in path
					var pathBind = info.pathBind;
					var pathId = info.pathId;
					while (pathBind.length != 0 && pathBind[0] != self.$bind) {
						pathBind.shift();
						pathId.shift();
					}
					if (pathBind.length == 0) throw new Error("Unexpected null pathBind");
					var field = pathBind.pop();
					/**
					 * pathBind.length > 1 means that we have to retreive the row in a child according to pathId
					 * We can have this case if we edit an array cards inside a card. The current array is th card's parent and we wantto delete the row in a child array
					 * --> Not implemented for the moment because not tested
					 */
					if (pathBind.length > 1 || field !== self.$bind) {
						_notImplemented("Deleting row in an array embedded inside a card");
					} else {
						// TODO - Retreive the row in newted child arrays (id is unic) and delete it
					}
					// Temporarily - Remove row in current array
					self.removeRow(rowId);
				}
			});
		},
		/**
		 * Remove rowId in datasets and html
		 * Can be called also from regularPage when we click on Delete action in rowDetail footer
		 */
		removeRow: function(rowId) {
			// Remove the row in _arrayData
			var array = this._arrayData;
			if (!array || !array.$resources || array.$resources.length == 0) return;
			var idx = -1;
			array.$resources.some(function(r, i) {
				if (r.getValue("$uuid") === rowId) {
					idx = i;
					return true;
				}
			});
			if (idx < 0 || idx >= array.$resources.length) return;
			array.$resources.splice(idx, 1);
			// Remove the row in html	
			this.builder.removeRowById(rowId);
			// Remove the row in dao - If it's a single array we use idx becaus there's no uuid in backoffice data (uuid is added by tablet client in arrayData to manage singleArrasy like other arrays)
			this.getDao().deleteRow(this.$bind, this.prototype.isSingleArray() ? idx : rowId);
		},
		/**
		 * Register a row in rowDetail cache to be able to reteive infortiaon on ckcik on 'rowDetail' Link (_actRowDetail)
		 */
		rowDetailAdd: function(id, data) {
			this._rowDetailCache[id + ""] = data;
		},
		/**
		 *  Return the dao and other information of the selected row (see _actRowDetail)		 *
		 **/
		rowDetailGetInfo: function(create) {
			// Read/ Edit row detail
			return this._rowDetailInfo;
		},
		/**
		 * Return the prototype of a row detail page
		 */
		rowDetailGetPrototype: function() {
			return this._rowDetailInfo.proto;
		},
		/**
		 * Returns the id of the page used to store it into application page
		 * The rowDetail page is generated one time
		 */
		rowDetailGetPageName: function(root) {
			if (!this._rowDetailInfo) throw new Error("rowDetailGetPageName - Null details row data");
			// To store the generated page in aplication page we nee the full path of the selected row
			// By exmaple for AQMCRUDM -  if we add a $article to the array level 1 we display i the card array level 2
			// When we click on rowDetail we need to display the row of level 2 ADEVADEVICEL.ADEVADEVICELADEVICELL
			// Page name is 
			//		AQMCRUDM.$details.ADEVADEVICEL if no article in ADEVADEVICEL
			//		AQMCRUDM.$details.ADEVADEVICEL.ADEVADEVICELADEVICELL if there's an article in ADEVADEVICEL
			//		AQMCRUDM.$details.ADEVADEVICEL.ADEVADEVICELADEVICELL.ADEVADEVICELADEVICELLDLLLif there's an article in ADEVADEVICEL.ADEVADEVICELADEVICELL
			return root + "." + this._rowDetailInfo.pathBind;
		},
		/**
		 * Select the last selected row
		 * lastSelectedrow is stored in page context and restores on back
		 * It highlights the last selected row
		 * Done by builder because depends on the way array has been rendered
		 */
		selectLastSelectedRow: function(rowId, show) {
			this.builder.selectLastSelectedRow(rowId, show);
		},
		/**
		 *	returns array rows
		 *		depends on the kind of page query/lookup or detail/edit
		 *		called one time to create the dao - then use getArrayData()
		 **/
		readArrayData: function(controllerDao) {
			var self = this;
			if (self.prototype.isQuery()) {
				return controllerDao.getQueryData(self.prototype);
			} else if (self.prototype.isLookup()) {
				return controllerDao.getLookupData(self.prototype);
			} else {
				return controllerDao.getArrayData(self.$bind, self.prototype);
			}
		},
		/**
		 *	Set array data - depends on array type
		 **/
		_setArrayData: function(controllerDao, refresh) {
			this.isEmpty = true;
			// Clear control content
			if (refresh) {
				this.$$value.empty();
			} else {
				this.$$elmt.empty();
			}
			_destroyArrayData(this._arrayData);
			this._arrayData = controllerDao ? this.readArrayData(controllerDao) : {
				$resources: []
			};
			if (this._arrayData == null) throw new Error("Null arrayData");
			this.isEmpty = this._arrayData.$resources.length === 0;
			if (!refresh) {
				// Build the base structure common to all ctrls - Title and value
				var title = this.getTitle();
				if (this._displayTitle(title)) {
					if (!this.$$ttl) this.$$ttl = $(uiUtils.createDomElement('div', ["s-m-title"])).appendTo(this.$$elmt);
					this.$$ttl.text(title);
				} else if (this.$$ttl) {
					this.$$ttl.empty();
				}
				// After title
				this.$$value = $(uiUtils.createDomElement('div', ["s-m-value"], null, null, this.$$elmt));
				this.$$value.before(this.$$header = $('<header/>'));
			}
			return this._arrayData;
		},
		_displayTitle: function(title) {
			if (title == null || title.trim().length === 0) return false;
			if (this.getAuthoring("$isTitleHidden") === true) return false;
			return this._displayArray();
		},
		_displayArray: function() {
			return this.controller.isEditMode() === true || this.isEmpty !== true || this.getAuthoring("$displayIfEmpty") === true;
		},
		/**
		 *	returns array rows
		 *		controllerDao optional
		 **/
		getArrayData: function() {
			return this._arrayData;
		},
		waitStart: function() {
			if (!this._waiting) {
				// TODO - Optimization
				this._waiting = uiUtils.waitWheelCreate(this.$$elmt.parent());
				this._waiting.$$bckg.css({
					position: "absolute"
				});
				this._waiting.$$wheel.css({
					position: "absolute"
				});
			}
			uiUtils.waitWheelStart(this._waiting);
		},
		waitStop: function() {
			if (this._waiting) {
				uiUtils.waitWheelStop(this._waiting);
			}
		},
		// arrayData is used for recursice search in arrays nested in arrays
		_getRowById: function(rowId, arrayData) {
			var self = this;
			arrayData = arrayData || self._arrayData;
			if (!arrayData || !arrayData.$resources || arrayData.$resources.length == 0) return null;
			var idx = 0;
			var result = null;
			arrayData.$resources.some(function(r) {
				if (r.getValue("$uuid") === rowId) {
					result = r;
					return true;
				}
				idx++;
			});
			return result ? {
				row: result,
				idx: idx
			} : null;
		},
		// Used for single Arrays
		_getRowByIdx: function(idx, arrayData) {
			arrayData = arrayData || this._arrayData;
			idx = parseInt(idx, 10);
			if (!arrayData || !arrayData.$resources || arrayData.$resources.length <= idx) return null;
			return {
				row: arrayData.$resources[idx],
				idx: idx
			};
		},
		/**
		 * return the context to save. It will be be restored afer page has been loaded
		 */
		savedCtxCreate: function() {
			return this.builder.savedCtxCreate();
		},
		/**
		 * Called by the page to restore the context
		 */
		savedCtxRestore: function(ctx) {
			this.builder.savedCtxRestore(ctx);
		},
		getScrollViewRect: function() {
			if (this.controller.isVignette) {
				var v = this.controller.getParentVignette();
				return v ? v.getScrollViewRect() : null;
			} else {
				return this.controller.getMainContentRect();
			}
		},
		/**
		 * Returns idx from rowId
		 * Used by single arrays
		 */
		rowId2Idx: function(uuid) {
			if (!this._arrayData || !this._arrayData.$resources) return -1;
			var rowIdx = -1;
			this._arrayData.$resources.some(function(r, idx) {
				if (r.getValue("$uuid") === uuid) {
					rowIdx = idx;
					return true;
				}
			});
			return rowIdx;
		},
		_actActionArray: function(id) {
			if (id === _filterSortPanelId) {
				this.controller.panelAttach("right", this._filterSortPanel, "toggle");
			}
		},
		_filterSortUpdateHeader: function(id) {
			if (id === "sort" || id == null) {
				var info = this.sortInfoGet();
				var order = null,
					field;
				// take the first sorted column
				// Currently we support sorting on only one column
				// -> We can display a asc/desc icon in the header
				// Sort panel can manage sorting on multiple columns but it's disabled
				info.some(function(i) {
					if (i.sort != "none") {
						order = i.sort;
						field = i.id;
						return true;
					}
				});
				this.builder.sortInfoUpdate(order, field);
			}
			if (id === "filter" || id == null) {
				var info = this.filterInfoGet();
				if (info) {
					// TODO - Display only if filter info
					var $$icon = this.$$header.find(".s-m-filtered");
					$$icon.toggle(info && info.length > 0);
				}
			}
		},
		// return array of sortInfo (not null)
		sortInfoGet: function() {
			var info = this.controller.filterSortRead("sort", this);
			if (info == null) {
				var proto = this.prototype.create(this.prototype.getDataByPath("$item"));
				var props = proto.data("$properties");
				if (props) {
					info = [];
					$.each(props, function(key, value) {
						if (!value.$isExcluded) {
							info.push({
								name: proto.resolveExpression(value.$title),
								id: proto.getFieldNameForValue(key),
								sort: "none"
							});
						}
					});
				}
				this.sortInfoSet(info, false);
			}
			return info;
		},
		sortInfoSet: function(info, refresh) {
			this.controller.filterSortWrite("sort", info, this, refresh);
		},
		// return array of filterInfo
		filterInfoGet: function() {
			var info = this.controller.filterSortRead("filter", this);
			if (info == null) {
				// TODO Build filter info
				this.filterInfoSet(info, false);
			}
			return info;
		},
		filterInfoSet: function(info, refresh) {
			this.controller.filterSortWrite("filter", info, this, refresh);
		}
	});

exports.Klass = _Klass;