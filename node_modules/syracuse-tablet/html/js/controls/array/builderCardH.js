"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/array/builderBase').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');
var uiRect = require('syracuse-tablet/html/js/ui/rect');

var _cellSizes = {
	"small": {
		w: 150,
		h: 150
	},
	"medium": {
		w: 200,
		h: 200
	},
	"wide": {
		w: 300,
		h: 150
	},
	"large": {
		w: 400,
		h: 400
	}
};

/**
 * Vertical card builder
 * Authoring
 * 		$numberOfRows 			number of card s per row
 * 		$displayEmptyCells 		Display or not empty cells true by default
 */
var _Klass = utils.defineClass(
	function(control, disp, options) {
		Base.call(this, control, disp, options);
		this._layoutRoot = null;
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._layoutRoot) {
				this._layoutRoot.destroy();
				this._layoutRoot = null;
			}
			this._$$body = null;
			this._$$cellTmpl = null;
			this._tds = null;
		},
		/**
		 * Just build $$td cells
		 * Build of array will be done on resize because we need to have the height of the parent control.$$value to calculate the number of roww
		 */
		buildHtml: function(arrayData, buildOptions) {
			Base.prototype.buildHtml.call(this, arrayData, buildOptions);
			if (!this.$article) return;
			if (!this._layoutRoot) {
				// Create HTML generator
				this._layoutRoot = articleParser.cardV2Controls(this.control);
			}
			var cellsize = _cellSizes[this.$articleArray.$cellSizes || "medium"];
			this._$$body = $('<tbody>').appendTo($('<table/>').appendTo(this.control.$$value));
			this.newScroller("h", this._$$body.parent());
			var $$td;
			this._$$cellTmpl = $('<section class="s-m-card s-m-H"/>').css({
				width: cellsize.w + "px",
				height: cellsize.h + "px"
			});
			var $$cell;
			var self = this;
			this._tds = [];
			arrayData.$resources.forEach(function(rowData, idx) {
				$$td = $(self.buildRecordMainElmt(rowData, {
					tag: "td",
					parent: null,
					createIfNoLink: true
				}, idx));
				$$cell = self._$$cellTmpl.clone().appendTo($$td);
				$('<span class="badge index">' + (idx + 1) + '</span>').appendTo($$cell);
				self.callGenerateHtml(self._layoutRoot, $$cell, rowData, false, buildOptions, idx);
				self._tds.push($$td);
			});
			this.buildArrayHeader(arrayData, buildOptions);
			if (buildOptions && buildOptions.refresh === true) {
				this._build(buildOptions);
			} // Otherwise build is done on resize
		},
		onResize: function() {
			if (this._layoutRoot) {
				/**
				 * We rebuild in any cases in order to have a good display
				 * To be able to calculate  parentH in nested pages we use table display for s-m-control and table-row for children
				 * --> In that case control.$$value has the right height
				 * For non nested paged table display doens't allow to calculate the height of the array without removing the old one...
				 * Other option was to check if $$value height changed to rebuild array
				 */
				this._build(null, true);
			} else {
				Base.prototype.onResize.call(this);
			}
		},
		/**
		 * !! check the multi-selection if we modify  _build
		 */
		_build: function(buildOptions, resize) {
			var self = this;
			/**
			 * setTimeout to better calculate the height of $$value
			 */
			setTimeout(function() {
				if (!self._$$body) {
					// Sometimes the body can be empty - exit multi-selection mode to switch from carH to cardV
					return;
				}
				buildOptions = buildOptions || {};
				self._$$body.empty();
				// $$value height is not OK in not nested pages for queries (page footer not taken into account). We should use display:table-row like in nested pages but it doesn't work fine
				// self.control.$$elmt height is ok so we calculate intersection and we get the right height of $$value
				var r = uiRect.elmtRect(self.control.$$elmt).intersectRect(uiRect.elmtRect(self.control.$$value));
				var parentH = r.height;
				var parentW = r.width;
				// Border spacing
				var bs = self._$$body.parent().css("border-spacing");
				if (bs) {
					bs = bs.split("px");
					bs = bs && bs.length > 0 ? parseInt(bs[0], 10) : 0;
				}
				parentH = parentH - bs;
				parentW = parentW - bs;
				var nbCardPerRow, numberOfRows;
				var $$row;
				var visibleTds = [];
				self._tds.forEach(function($$td, idx) {
					$$td.detach();
					if ($$td.css('display') != "none") {
						visibleTds.push($$td);
					} else {
						if (!$$row) {
							$$row = $("<tr>").appendTo(self._$$body).hide();
						}
						// Add non-visible $td just to have alls tds in the array
						// We need to have all $$td in the array for multiselection
						$$td.appendTo($$row);
					}
				});
				if (visibleTds.length === 0) return;
				visibleTds.forEach(function($$td, idx) {
					if (visibleTds.indexOf($$td) >= 0) {
						if (idx == 0 || (nbCardPerRow > 1 && idx % nbCardPerRow === 0)) {
							$$row = $("<tr>").appendTo(self._$$body);
						}
						$$td.appendTo($$row);
						if (idx === 0) {
							// Calculate the number of rows after having create the first cell
							var realH = $$td.height() + bs * 2;
							var realW = $$td.width() + bs * 2;
							if (visibleTds.length * realW < parentW) {
								// Force to display all the cells on one line because there's enough room
								numberOfRows = 1;
								nbCardPerRow = visibleTds.length;
							} else {
								// Calculate the number of rows to fit the parent height
								numberOfRows = Math.max(1, Math.floor(parentH / realH));
								nbCardPerRow = Math.ceil(visibleTds.length / numberOfRows);
							}
						}
					}
				});
				if (numberOfRows > 1 && $$row) {
					var remaining = nbCardPerRow - visibleTds.length % nbCardPerRow;
					if (remaining) {
						self.addEmptyCells(self._layoutRoot, $$row, remaining, buildOptions, self._$$cellTmpl);
					}
				}
				var top = Math.max(0, (parentH - self._$$body.parent().outerHeight()) / 2);
				self._$$body.parent().css({
					top: top + "px"
				});
				if (buildOptions.refresh === true || resize) {
					// refreshes the gestureMgr
					Base.prototype.onResize.call(self);
				}
			});
		}
	});

exports.Klass = _Klass;