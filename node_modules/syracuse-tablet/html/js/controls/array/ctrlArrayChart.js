"use strict";


var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var array = require('syracuse-tablet/html/js/controls/array/ctrlArray');
var Base = array.Klass;
var locale = require('syracuse-tablet/html/js/helpers/locale');
var BuiderCart = require('syracuse-tablet/html/js/controls/array/builderChart').Klass;
var chartUserPrefs = require('syracuse-tablet/html/js/controls/chart/chartUserPrefs');
var chartsUtils = require('syracuse-tablet/html/js/controls/chart/chartsUtils');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

/**
 * Make sure that we've the $forceArray property
 * For compliance with existing authoring - #7719
 */
var _checkChartArticle = function(article, $bind) {
	if (!article) return;
	var arrayArticle = _traverseArticleNodes(article, function(node) {
		return node.$bind === $bind && node.$forceArray === true;
	});
	// Ok because we expect a $forceArray in arrayArticle
	if (arrayArticle) {
		return article;
	}
	// No $forceArray has been found and we need it
	arrayArticle = _traverseArticleNodes(article, function(node) {
		if (node.$bind != $bind || node.$display == "chart" || node.$seriesOptions != null) {
			return false;
		}
		if (node.$display != null) {
			// Its an array
			return true;
		}
		// Unexpected null $display -  #7719 - We should find a way to detect the array
		if (node.$table || node.$card != null || node.$separator !== null) {
			// It's an array
			return true;
		}
		if (node.arrayOptions && node.rowIndex) {
			// It's an array
			return true;
		}
		return false;
	});
	if (arrayArticle) {
		// Set mandatory $forceArray
		arrayArticle.$forceArray = true;
	}
	return article;
};
/**
 * Retrieve chart and array article in chart Detail page article
 */
var _findChartArticle = function(article, $bind) {
	var self = this;
	var chartNode = _traverseArticleNodes(article, function(node) {
		// We got the chart not if forceArray is not set or is false
		if (node.$bind === $bind && node.$forceArray !== true) {
			return true;
		}
	});
	return chartNode;
};
var _findArrayArticle = function(article, $bind) {
	var arrayNode = _traverseArticleNodes(article, function(node) {
		if (node.$bind === $bind && node.$forceArray === true) {
			return true;
		}
	});
	return arrayNode;
};
var _traverseArticleNodes = function(node, matcher) {
	if (matcher(node) === true) {
		return node;
	}
	if (node.$items && node.$items.length > 0) {
		var i;
		var match;
		for (i = 0; i < node.$items.length; i++) {
			match = _traverseArticleNodes(node.$items[i], matcher);
			if (match) {
				return match;
			}
		}
	}
	return null;
};
/**
 * Array tied to a chart
 * Can be displayed as a grid/card/chart (article.$display = "chart" or "card" or "table")
 */
var _Klass = utils.defineClass(
	function CtrlArrayChart(controller, article, prototype, options) {
		options = options || {};
		options.localPagination = prototype.isCube();
		article.$arrayOptions = article.$arrayOptions || {};
		// Disabled for statistics and requests
		article.$arrayOptions.showSortFilter = false;
		article.$arrayOptions.showSearch = false;
		if (!article.$display) {
			article.$display = "chart";
		}
		Base.call(this, controller, article, prototype, options);
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			this._paginSynchro = null;
		},
		isArrayChart: function() {
			return true;
		},
		buildHtml: function($$parent, controllerDao, buildOptions) {
			Base.prototype.buildHtml.call(this, $$parent, controllerDao, buildOptions);
			if (this.isHighChart()) {
				this.$$elmt.addClass("s-m-chart");
			} else {
				if (this.isOpenDetailEnabled()) {
					// action on $$value not on $$elmt ( pagination)
					this.addChartDetailLink(this.$$value);
				}
				this.$$elmt.addClass("s-m-chart-array");
			}
		},
		/**
		 * Called also by builderChart
		 */
		isOpenDetailEnabled: function() {
			if (this.isChartDetailPage()) return false;
			// We can't manage click to chart detail and click to next slide - TODO
			if (this.isCarouselDisplay()) return false;
			if (this.controller.isVignette) return this.article.$openDetail !== false;
			return true;
		},
		/**
		 * Called also by builderChart
		 */
		addChartDetailLink: function($$elmt) {
			$$elmt.attr("data-control-id", this.id).attr("data-action", globals.ACTCHARTDETAIL);
		},
		isDisplayedInDetailPage: function() {
			return this.isChartDetailPage() || !this.controller.isVignette;
		},
		isChartDetailPage: function() {
			return this.controller.state.type === "chartdetail";
		},
		isHighChart: function() {
			return this.$display === "chart";
		},
		_newBuilder: function(options) {
			// No _actRowSelect Action
			options.acceptRowSelectAction = false;
			if (this.isHighChart()) {
				if (this.$$value) {
					this.$$value.empty();
				}
				// Display as chart
				this.builder = new BuiderCart(this, this.$display, options);
			} else {
				// Display as table or card
				Base.prototype._newBuilder.call(this, options);
			}
		},
		_actChartDetail: function() {
			if (this.isEmpty) return;
			this.triggerOpenChartDetail();
		},
		_setArrayData: function(controllerDao, refresh) {
			var res = Base.prototype._setArrayData.call(this, controllerDao, refresh);
			if (this.$$ttl) {
				this.$$ttl.removeClass("s-m-no-data-title");
			}
			return res;
		},
		getTitle: function() {
			return this.isHighChart() ? Base.prototype.getTitle.call(this) : this._findTitle();
		},
		/** 
		 * Traverses the prototype hierarchy to find a title for the array that can be
		 * accessed later if there is no data
		 */
		_findTitle: function(proto) {
			proto = proto || this.prototype;
			var $title = proto.data("$title");
			if ($title) {
				return $title;
			}
			var $cube = proto.data("$cube");
			$title = $cube && $cube.$title;
			if ($title) {
				return $title;
			}

			if (proto.parent) {
				return this._findTitle(proto.parent);
			}
			return "";
		},
		_displayTitle: function(title) {
			if (title == null || title.trim().length === 0 || this.getAuthoring("$isTitleHidden") === true) {
				return false;
			}
			// Display the title if empty
			return true;
		},
		/**
		 *  Same look and size as chart for table mode
		 */
		setEmptyArrayMsg: function() {
			if (!this.isArrayField()) {
				if (this.$$ttl) {
					// !! remove it on refresh
					this.$$ttl.addClass("s-m-no-data-title");
				}
				// Set in $$value to be removed on refresh
				$('<div class="s-m-no-data-label"/>').appendTo(this.$$value).text(locale.text("label.chart.nodata"));

			}
		},
		/**
		 * Local pagination for stats
		 */
		createLocalPaginator: function(controllerDao) {
			if (!this.prototype.isCube()) return null;
			var gadget = this.controller.state.type == "chartdetail" ? this.controller.parentPage.gadget : this.controller.gadget;
			if (!gadget) return null;
			var rsrcs = controllerDao.getValue(this.$bind);
			if (!rsrcs) return null;
			var count = gadget.parameters && gadget.parameters.count != null ? gadget.parameters.count : 10;
			if (rsrcs.length <= count) return null;
			return new array.LocalPaginator(this, {
				count: count,
				length: rsrcs.length
			});
		},
		/**
		 * Returns the id for user preferences to store chart details
		 */
		_getChartDetailUserPrefsId: function() {
			var id = [];
			if (this.controller.isVignette && this.controller.getParentVignette()) {
				var vignette = this.controller.getParentVignette();
				var prototype = vignette.prototype;
				// Dashboard name - 1th key
				var uuid = vignette.controller.state.dashboardName || vignette.controller.state.name;
				if (uuid) {
					id.push(uuid);
				}
				// Vignette id - 2d key
				uuid = prototype.data("$uuid");
				if (uuid) {
					id.push('-');
					id.push(uuid);
				}

			}
			if (id.length === 0) {
				// In case it's not a vignette - unexpected
				id.push(this.$bind);
				id.push('-');
				id.push(this.controller.getOriginalSdataUrl());
			}
			return id.join('');
		},
		/**
		 * Opens chart detail page
		 * Called also from authoring
		 */
		triggerOpenChartDetail: function(opt) {
			if (!this.$$elmt) return;
			this.level = opt ? opt.level || 0 : 0;
			var attrs = {
				"data-control-id": this.id,
				"data-parent-id": this.controller.id,
				"data-nav": "chartdetail",
				"data-nav-target": "application",
				"data-sdata-url": opt ? this._getSdataUrl(opt) : this._getMainPage(this.controller).getOriginalSdataUrl(),
				"data-params": this._getChartDetailUserPrefsId()
			};
			eventListener.triggerNavigation(this.$$elmt, attrs);
		},
		_getMainPage: function(controller) {
			if (controller.parentPage) {
				return this._getMainPage(controller.parentPage);
			} else {
				return controller;
			}
		},
		/**
		 * Save chart detail article in control's article
		 */
		setChartDetailAuthoring: function(article) {
			this.article.$chartDetail = article;
			notifications.publish("sm.auth.change.item.prop.ui");
		},
		/**
		 * Return the page info proto/article for the chart detail page
		 */
		childPageGetPageInfo: function(typePage) {
			if (typePage === "chartdetail") {
				return this._getChartDetailPageInfo(typePage);
			} else {
				// Row detail/card detail
				return Base.prototype.childPageGetPageInfo.call(this, typePage);
			}
		},
		_getChartDetailPageInfo: function(typePage) {
			var pageInfo = {
				home: false,
				type: typePage,
				cached: false,
				refreshed: false,
				changeHash: false
			};
			var userPrefs = chartUserPrefs.createChartDetailPrefs(this._getChartDetailUserPrefsId());
			if (globals.isAuthoringActive()) {
				// Clear prefs when we open chartDetail in authoring to design from regular layout (side2Side)
				userPrefs.reset();
			}
			// We need the prefs to define the right layout and the preferences of chart
			var opt = userPrefs.getPrefs() || {};
			var article = _checkChartArticle(this.article.$chartDetail, this.$bind);
			var chartArticle = article && _findChartArticle(article, this.$bind);
			var arrayArticle = article && _findArrayArticle(article, this.$bind);
			article = chartsUtils.getChartDetailArticle(opt, this.$bind, chartArticle, arrayArticle);
			pageInfo.subtype = "details";
			pageInfo.article = article;
			// The name of a chart detail page is the name of the dashboard 
			// it is opened from plus the id of the vignetted container to get a unique name of the page
			// Be careful, a page name must be <name> . <facet> , no more that exactly one dot in the name
			// this is why dashboard name and vignette are concatenated with an underscore
			var parentVignette = this.controller.getParentVignette();
			var name = "",
				title = "";
			if (parentVignette) {
				name = parentVignette.controller.prototype.getDataByPath("$dashboardName");
				pageInfo.level = 1;
				pageInfo.name = name + "_" + parentVignette.$bind + ".$" + typePage;
				title = this.prototype.getDataByPath("$cube.$title") || locale.text("chartdetail.page.name");
			} else {
				pageInfo.level = this.controller.state.level + 1;
				pageInfo.name = this.controller.state.name;
				title = locale.text("chartdetail.page.level") + " " + pageInfo.level;
			}
			var protoJson = $.extend(true, {}, this.controller.prototype.json);
			protoJson.$title = title;
			pageInfo.prototype = this.prototype.create(protoJson, true);
			return pageInfo;
		},
		/**
		 * Called by chart authoring to know if we should display height property
		 * Mandatory for charts in a row/cell layout because we need to fix the height of the chart
		 * For hub the height is given by the tile
		 */
		chartNeedsHeight: function() {
			return this.$display === "chart" && this._layouytType === "stack" && !this.isDisplayedInDetailPage();
		},
		/**
		 * Called by chart authoring
		 */
		chartGetCurrentDrillLevel: function() {
			if (!this.builder && this.$display != "chart") return "";
			return this.builder.getCurrentDrillLevel();
		},
		_actPagination: function(linkName) {
			Base.prototype._actPagination.call(this, linkName);
			if (this._paginSynchro) {
				this._paginSynchro.forEach(function(ctrl) {
					setTimeout(function() {
						ctrl._actPagination(linkName);
					});
				});
			}
		},
		/**
		 * Used by chartDetail - Synchronization of pagination between chart and array
		 * Allow the array to trigger pagination to chart - when we paginate on array the chart is synchronized
		 * Only for local pagination
		 */
		paginAddSynchro: function(ctrl) {
			if (!ctrl || !ctrl.paginAddSynchro) return;
			if (!this._paginSynchro) {
				this._paginSynchro = [];
			}
			if (this._paginSynchro.indexOf(ctrl) >= 0) return;
			this._paginSynchro.push(ctrl);
		},
		/**
		 * Used by chartDetail - Synchronization of pagination between chart and array
		 * Only for local pagination
		 */
		paginGetInfo: function() {
			if (!this._localPaginator) return null;
			return {
				local: true,
				currentIdx: this._localPaginator.currentIdx
			};
		},
		/**
		 * Used by chartDetail - Synchronization of pagination between chart and array
		 * Only for local pagination
		 */
		paginSetInfo: function(paginInfo) {
			if (!paginInfo || !paginInfo.local || !this._localPaginator) return null;
			this._localPaginator.currentIdx = paginInfo.currentIdx;
			this.refresh(this.controller.dao);
		},
		isAuthoringPropAllowed: function(property, value) {
			if (property !== "arrayDisplay") {
				return Base.prototype.isAuthoringPropAllowed.call(this, property, value);
			}
			if (value === "separator") {
				return false;
			}
			if (!this.isChartDetailPage()) {
				// All properties included chart
				return true;
			}
			// Chart only for chart (left control) - Table/Card for array (right control)
			return this.article.$forceArray === true ? value !== "chart" : value === "chart";
		}
	});

exports.Klass = _Klass;