"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
/**
 * Scroll a table or vertical card array
 * TODO - Add vertical swipe - scroll in pixels instead of rows
 */
var _Klass = utils.defineClass(
	function(builder, options) {
		this.hammer = null;
		this.options = options = options || {};
		if (options.scale == null) options.scale = 0.1;
		this.builder = builder;
		this.control = builder.control;
		this.$$tbody = builder.$$tbody;
		if (!this.$$tbody) throw new Error("$$tbody expected");
		// Context restored by the page after loading if any
		this._restoredScrollIdx = null;
	}, null, {
		destroy: function() {
			this.builder = null;
			this.control = null;
			this.$$tbody = null;
			if (this.hammer) {
				this.hammer.destroy();
				this.hammer = null;
			}
		},
		afterShow: function() {
			// First
			if (this._initPanelInfo()) {
				this.hammer = new Hammer(this.$$tbody.get(0));
				this.initPanEvt();
			}
		},
		initPanEvt: function() {
			var self = this;
			self.hammer.get("pan").set({
				direction: Hammer.DIRECTION_VERTICAL
			});
			self.hammer.on("pandown panup", function(ev) {
				self.onSwipePan(ev);
			});
		},
		/**
		 * Init all info needed to deal with pan event - scroll up/down
		 * return true if scroll is needed
		 */
		_initPanelInfo: function() {
			this.parentHeight = this.control.$$elmt.parent().height();
			this.bodyHeight = this.$$tbody.height();
			this.bodyTop = this.$$tbody.position().top;
			// Restores the last scroll
			this.curIdx = this._restoredScrollIdx != null ? this._restoredScrollIdx : 0;
			this.bodyVisibleHeight = this.parentHeight - this.bodyTop;
			this.overFlow = (this.bodyHeight - this.bodyVisibleHeight > 0);
			if (this.overFlow > 0) {
				this.trHeight = this.$$tbody.children("tr:first-child").height();
				this.rsrcLen = this.control.getArrayData().$resources.length;
				this.$$trs = this.$$tbody.children("tr");
				this.maxIdx = this.$$trs.length - 1;
				var tr;
				for (var i = 0; i < this.rsrcLen; i++) {
					// Stores jquery object
					tr = this.$$trs[i] = $(this.$$trs[i]);
					if (this.curIdx != null && i < this.curIdx) {
						// Restores the last scroll
						tr.hide();
					}
				}
			}
			return this.overFlow;
		},
		onSwipePan: function(evt) {
			var self = this;
			var scale = this.options.scale;
			if (this.deltaY == null) this.deltaY = 0;
			var dy = Math.abs(evt.deltaY);
			// Delta in pixels since last event
			var delta = Math.abs(this.deltaY - dy);
			// Nb rows to move
			var count = Math.round(scale * delta);
			//console.log(evt.distance, delta, "count = " + count, delta);
			if (count === 0) return;
			// Save last state
			this.deltaY = dy;
			var lastidx = self.curIdx;
			if (evt.type === "panup") {
				var newIdx = Math.max(0, Math.min(this.maxIdx, lastidx + count));
				for (var i = lastidx; i < newIdx; i++) {
					this.$$trs[i].hide();
				}
			} else if (evt.type === "pandown") {
				var newIdx = Math.max(0, Math.min(this.maxIdx, lastidx - count));
				for (var i = lastidx; i >= newIdx; i--) {
					this.$$trs[i].show();
				}
			}
			// Save start idx
			self.curIdx = newIdx;
		},
		/**
		 * Return the context to save
		 */
		savedCtxCreate: function(ctx) {
			return {
				scrollIdx: this.curIdx
			};
		},
		/**
		 * Called by the page to restore the context
		 * Restores the scroll index
		 */
		savedCtxRestore: function(ctx) {
			this._restoredScrollIdx = ctx ? ctx.scrollIdx : 0;
		}
	});

exports.Klass = _Klass;