"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var Base = require('syracuse-tablet/html/js/controls/array/builderChartBase').Klass;
var notifications = require('syracuse-tablet/html/js/helpers/notifications');


var _getHeight = function(h) {
	if (h === "xsmall") return 50;
	if (h === "small") return 100;
	if (h === "medium") return 200;
	if (h === "large") return 400;
	if (h === "xlarge") return 700;
	return 200;
};

/**
 * HIGHCHART BUILDER
 */
var _Klass = utils.defineClass(
	function(control, disp, options) {
		Base.call(this, control, disp, options);
	}, Base, {
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			this.resetProps(false);
		},
		destroy: function() {
			Base.prototype.destroy.call(this);
		},
		buildHtml: function(arrayData, buildOpts) {
			Base.prototype.buildHtml.call(this, arrayData, buildOpts);
			var article = this.$articleArray;
			// sometimes we need the height - see chartNeedsHeight
			this._height = _getHeight(article.$chartHeight);
			this._$$chartSlot = $('<div class="s-m-slot"/>').appendTo(this.control.$$value);
			if (this.getDataSet().length > 0) {
				//isAuthoringActive to allow the selection of the chart
				if (globals.isAuthoringActive() || this.control.isOpenDetailEnabled()) {
					// Catch chart events
					var $$catchEvt = $('<div class="s-m-catchevt"/>').appendTo(this.control.$$value);
					if (this.control.isOpenDetailEnabled()) {
						this.control.addChartDetailLink($$catchEvt);
					}
				}
			} else {
				var title = this.control.prototype.getDataByPath("$cube.$title");
				if (title) {
					$('<div class="s-m-no-data-title"/>').appendTo(this._$$chartSlot).text(title);
				}
				$('<div class="s-m-no-data-label"/>').appendTo(this._$$chartSlot).text(locale.text("label.chart.nodata"));
				this._$$chartSlot.css("position", "relative");
			}
		},
		onResize: function(context) {
			if (this.control.destroyed) return;
			var dataset = this.getDataSet();
			if (dataset == null || dataset.length === 0) {
				// It needs to count all charts even empty ones
				this._notifyChartCounter();
				return;
			}
			if (!this.control.$$value || !this.control.$$value.is(':visible')) {
				if (!this._subscribedExpand) {
					this._subscribedExpand = true;
					notifications.subscribe(this, ["sm.layout.expanded"]);
				}
			}
			// Notifies cell/tile to improve display (no bg color) - Only if not empty
			this._notifyChartHosted();
			if (this._layouytType == null) {
				// Needed here to access to all elements (getParentVignette)
				// We do that just once
				if (this.control.isChartDetailPage()) {
					// in that case the chart is displayed in a 'detail's page
					this._layouytType = "stack";
				} else {
					// Chart in vignettes
					this._layouytType = this.control.controller.getParentDashboardType();
				}
				if (this._layouytType === "stack") {
					// relative is needed
					this._$$chartSlot.css("position", "relative");
				}
			}
			this._displayChart(true);
		},
		notifLayoutExpanded: function() {
			this._displayChart();
		},
		/**
		 * #6974 When all the charts are loaded we force the browser to redraw (svg bug in chrome)
		 * We need to count the charts
		 * Call notifChartHosted method directly
		 */
		_notifyChartCounter: function() {
			if (globals.getCurrentPage().countChartLoaded) {
				globals.getCurrentPage().countChartLoaded(this);
			}
		},
		/**
		 * Call cell/tile parent if any to inform the that a chart is nested
		 * Used to improve display - call notifChartHosted method directly
		 */
		_notifyChartHosted: function() {
			var controller = this.control.controller;
			// Notifies cell/tile to improve display when a chart is nested
			if (controller.isVignette && controller.getParentVignette()) {
				var parent = controller.getParentVignette().parent;
				// hack to remove the background color since we manage it by js (not css)
				if (parent.notifChartHosted) {
					parent.notifChartHosted();
				}
			}
		},
		_displayChart: function(updtScroller) {
			if (this.control.destroyed) return;
			var self = this;
			// SetTimeout to improve UX when there are multiple charts to display (dashboard)
			setTimeout(function() {
				var stackController, height;
				if (self._layouytType === "stack") {
					// in stack mode we need a height
					if (self.control.isChartDetailPage()) {
						stackController = self.control.controller;
						// Height set to device height
						height = stackController.getMainContentRect().height - 10;
					} else if (self.control.controller.isVignette) {
						stackController = self.control.controller.getParentVignette().controller;
						// Height always less or equal than the device height
						height = Math.min(self._height, stackController.getMainContentRect().height - 10);
					} else {
						console.log("onResize chart - unexpected controller");
						return;
					}
				} else {
					// Parent's height
					height = null;
				}
				self.createChart(self._settingsFromValue(), self._$$chartSlot, {
					height: height,
					// Parent's width
					width: null,
					onComplete: function() {
						//#6974 Fix svg issue in chrome
						self._notifyChartCounter();
					}
				});
				if (updtScroller && stackController) {
					// Needed to update the scroller
					notifications.notifyController("sm.scroller.update", stackController);
				}
			}, 10);
		}
	});

exports.Klass = _Klass;