"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/array/builderBase').Klass;
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');
var articleGen = require('syracuse-tablet/html/js/authoring/authoringArticleGen');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');
var layoutRow = require('syracuse-tablet/html/js/controls/layout/layoutRow');


var _Klass = utils.defineClass(
	function(control, disp, options) {
		Base.call(this, control, disp, options);
		this._layoutRoot = null;
		this._$$cellTmpl = $('<section class="s-m-card"/>');
	}, Base, {
		initReuseProperties: function() {
			Base.prototype.initReuseProperties.call(this);
			// Initialize properties when we generate multiple card with the same control tree
			// No destroy because this._$$body is in the dom - we create another one
			this._$$body = null;
			this._$$rows = null;
			this._statusInfo = null;
		},
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._layoutRoot) {
				this._layoutRoot.destroy();
				this._layoutRoot = null;
			}
			if (this._$$body) {
				// Destroy all children carousel  - if cards nested in cards to make sure we clear handlers and data
				this._$$body.find(".carousel").remove();
				// To remove the handlers/data attach to dom elements and descendants (carousel)
				this._$$body.remove();
				this._$$body = null;
			}
			this._$$cellTmpl = null;
			if (!this._$$rows) {
				this._$$rows = null;
			}
		},
		buildHtml: function(arrayData, buildOpts) {
			Base.prototype.buildHtml.call(this, arrayData, buildOpts);
			if (this._layoutRoot == null) {
				var cardArticle = this.$articleArray.$card;
				if (!cardArticle) {
					cardArticle = articleGen.genNewArticle({
						page: {
							prototype: this.control.prototype
						}
					}, true);
				};
				var options = {
					displayCtx: "card",
					displayAsCarousel: buildOpts.htmlRootCtrl !== null,
					hideEmptyRows: this.$arrayOptions.hideEmptyRows === true
				};
				this._layoutRoot = articleParser.article2Controls(this.control.controller, cardArticle, this.$itemProto, options);
			}
			this._bgColor = this.$articleArray.$bgColor;
			this._statusInfo = this.control.getRowStatusInfo();
			if (this._bgColor == null) {
				this._bgColor = "s-m-default";
			} else if (this._bgColor.length > 0) {
				this._bgColor = "s-m-color-" + this._bgColor;
			}
			if (this.isRefreshContext(buildOpts)) {
				// Force display because there's no resize
				this.buildCards(buildOpts);
			} // Otherwise build is done on resize
		},
		createCard: function($$parent, idx, rowData, buildOpts) {
			var $$card = this._$$cellTmpl.clone().appendTo($$parent);
			if (this._bgColor.length > 0) {
				$$card.addClass("s-m-bg " + this._bgColor);
			}
			if (this.$arrayOptions.rowIndex === true) {
				$('<span class="badge index">' + (idx + 1) + '</span>').appendTo($$card);
			}
			if (this._statusInfo) {
				this.checkStatusManagement($$parent, this._statusInfo, $$card, rowData);
			}
			this.callGenerateHtml(this._layoutRoot, $$card, rowData, false, buildOpts, idx);
			return $$card;
		},
		checkStatusManagement: function($$parent, statusInfo, $$cell, rowData) {
			if (!statusInfo) return;
			var $$rootIcon = $$cell.find(".s-m-status");
			if ($$rootIcon.length === 0) {
				$$rootIcon = $('<div class="s-m-status"/>').appendTo($$cell);
			}
			var nbBckg = 0;
			statusInfo.list.some(function(s) {
				if (s.color && fieldOperators.evaluateOperator(s.$type, rowData.getValue(s.field), s.operator, s.value)) {
					/**
					 * We need to set color and bg-color because using css property doesn't work due to css inheritance
					 * Using css forces to declare all css selectors (td:not(.s-m-multi-selected)...) for each color of the palette
					 */
					if (s.icon) {
						$('<div class="s-m-status-icon ' + s.icon.css + '" style="color:' + s.color.bgColor + '"/>').appendTo($$rootIcon);
						return statusInfo.type === "mono";
					} else if (s.color.css && nbBckg === 0) {
						$$parent.addClass('s-m-status-color ' + s.color.css);
						nbBckg++;
					}
					return statusInfo.type === "mono";
				}
			});
		},
		onResize: function(context) {
			if (this.destroyed) return;
			// Used by multi-selection - we just want to refresh the scroll
			var scrollOnly = context != null && context.scrollOnly === true;
			if (scrollOnly !== true) {
				/**
				 * We rebuild in any cases in order to have a good display
				 * To be able to calculate  parentH in nested pages we use table display for s-m-control and table-row for children
				 * --> In that case control.$$value has the right height
				 * For non nested paged table display doens't allow to calculate the height of the array without removing the old one...
				 * Other option was to check if $$value height changed to rebuild array
				 */
				var buildOpts = {
					updateLayout: context && context.updateLayout
				};
				this.buildCards(buildOpts, context);
			} else {
				Base.prototype.onResize.call(this, context);
			}
		},
		/**
		 * !! check the multi-selection if we modify  buildCards
		 */
		buildCards: function(buildOpts, resizeContext) {
			throw new Error("Not implemented");
		},
		authMinSize2Pixels: function(val) {
			var max = 700,
				min = 100;
			val = parseInt(val, 10);
			if (val == null || isNaN(val)) return 200;
			if (val > 20) return max;
			if (val < 1) return min;
			return min + (val * (max - min) / 20);
		},
		/**
		 * Like the rows are not stored as controls (html generated) we get the $$row and apply the rocess to detect empty row
		 * Same process for the row layout
		 */
		checkEmptyRows: function() {
			if (!this._$$body) return;
			if (!this._$$rows) {
				this._$$rows = this._$$body.find(".s-m-row");
			}
			layoutRow.checkEmptyRows(this._$$rows);
		},
		getColumnsInfo: function(onlyVisible) {
			var cols = null;
			if (!this.control.prototype.isSingleArray() && onlyVisible === true && this._layoutRoot) {
				cols = [];
				var _scan = function(node) {
					if (!node || !node.children) return;
					node.children.forEach(function(c) {
						if (c.isControl() && c.$bind) {
							cols.push(c.$bind);
						} else {
							_scan(c);
						}
					});
				};
				_scan(this._layoutRoot);
			}
			var protoCols = this.control.prototype.arrayTableGetColInfo();
			if (cols == null) {
				return protoCols;
			}
			var res = [];
			protoCols.forEach(function(c) {
				if (cols.indexOf(c.$bind) >= 0) {
					res.push(c);
				}
			});
			return res;
		}
	});

exports.Klass = _Klass;