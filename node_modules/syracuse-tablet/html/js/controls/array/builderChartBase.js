"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var Base = require('syracuse-tablet/html/js/controls/array/builderBase').Klass;
var formatApi = require('syracuse-tablet/html/js/helpers/formatApi');
var theme = require('syracuse-tablet/html/js/controls/chart/cubeChartsTheme').theme;
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');

var _merge = Highcharts.merge;
var objectClone = function(o) {
	return $.extend({}, o);
};

Highcharts.theme = theme;
Highcharts.setOptions(Highcharts.theme);

var colors = Highcharts.theme.colors;

var _style = function($style) {
	var map = {
		xy: "line",
		point: "scatter",
		stick: "column",
		radar: "spiderweb"
	};

	return $style && (map[$style] || $style);
};

function _isCubeValid(cube, proto) {
	return !!(cube && cube.$hierarchies && proto.$axes && proto.$axes.length > 0 && //
		proto.$axes[0].$hierarchies && proto.$axes[0].$hierarchies.length > 0);
}
/**
 * cube chart control class
 *
 * article:
 * $isLegendHidden: true/false
 * $isXLabelHidden: true/false
 * $isYLabelHidden: true/false
 * $isXLabelsHidden: true/false
 * $isYLabelsHidden: true/false
 * $style: line, spline, area, areaspline, bar, stick, pie
 */
var _Klass = utils.defineClass(function(control, disp, options) {
	Base.call(this, control, disp, options);
	// #6974 Add this stuff there for compatibility with desktop code
	// This block assigns some variables so that the implementations
	// in ctrlCubeChartBase which have been migrated from the desktop client
	// do not need to be modified too much!
	this.$prototype = control.prototype.json;
	this.$prototype.$properties = this.$prototype.$item.$properties;
	this._localize = {
		highCharts_showHideLegend: locale.text("highCharts_showHideLegend"),
		highCharts_seriesTitle: locale.text("highCharts_seriesTitle")
	};
	this._initializeMeta();
}, Base, {
	destroy: function() {
		Base.prototype.destroy.call(this);
		this.clearChart();
		this._localize = this._meta = this._dataset = this.$prototype = this.currentMetaData = null;
	},
	//#6974 clear existing chart
	clearChart: function() {
		if (this.highchartObject) {
			this.highchartObject.destroy();
		}
		this.highchartObject = null;
	},
	_mergeMetaData: function(metadata) {
		var m = {};
		if (metadata && metadata.$chartOptions) {
			metadata.$isXLabelsHidden = metadata.$chartOptions.isXLabelsHidden || false;
			metadata.$isYLabelsHidden = metadata.$chartOptions.isYLabelsHidden || false;
			metadata.$isXLabelHidden = metadata.$chartOptions.isXLabelHidden || false;
			metadata.$isYLabelHidden = metadata.$chartOptions.isYLabelHidden || false;
			metadata.$isLegendHidden = metadata.$chartOptions.isLegendHidden || false;
			metadata.$isGridLineHidden = metadata.$chartOptions.isGridLineHidden || false;
			metadata.$isTitleHidden = metadata.$chartOptions.isTitleHidden || false;
			metadata.$isLabelsHidden = metadata.$chartOptions.isLabelsHidden || false; // Only for pie
		}
		if (metadata && metadata.$axisLabels) m.$axisLabels = metadata.$axisLabels;
		if (metadata && metadata.$cube) m.$cube = metadata.$cube;
		if (metadata && metadata.$axes) m.$axes = metadata.$axes;
		if (metadata && metadata.$style) m.$style = metadata.$style;
		if (metadata && metadata.$color) m.$color = metadata.$color;
		if (metadata && metadata.$isLegendHidden) m.$isLegendHidden = metadata.$isLegendHidden;
		if (metadata && metadata.$isXLabelHidden) m.$isXLabelHidden = metadata.$isXLabelHidden;
		if (metadata && metadata.$isYLabelHidden) m.$isYLabelHidden = metadata.$isYLabelHidden;
		if (metadata && metadata.$isXLabelsHidden) m.$isXLabelsHidden = metadata.$isXLabelsHidden;
		if (metadata && metadata.$isYLabelsHidden) m.$isYLabelsHidden = metadata.$isYLabelsHidden;
		if (metadata && metadata.$isGridLineHidden) m.$isGridLineHidden = metadata.$isGridLineHidden;
		if (metadata && metadata.$isTitleHidden) m.$isTitleHidden = metadata.$isTitleHidden;
		if (metadata && metadata.$isLabelsHidden) m.$isLabelsHidden = metadata.$isLabelsHidden;
		if (metadata && metadata.$inverted) m.$inverted = metadata.$inverted;
		if (metadata && metadata.$seriesOptions) {
			m.$cube = m.$cube || {};
			m.$cube.$measures = m.$cube.$measures || {};
			Object.keys(metadata.$seriesOptions).forEach(function(key) {
				if (metadata.$seriesOptions[key]) {
					m.$cube.$measures[key] = m.$cube.$measures[key] || {};
					if (metadata.$seriesOptions[key].color) {
						m.$cube.$measures[key].$color = metadata.$seriesOptions[key].color.bgColor;
					}
					m.$cube.$measures[key].$isHidden = metadata.$seriesOptions[key].isHidden;
				}
			});
		}
		this.currentMetaData = _merge(this.currentMetaData || {}, m);

		if (metadata && metadata.$item && metadata.$item.$properties && this.currentMetaData && this.currentMetaData.$cube && this.currentMetaData.$cube.$measures) {
			$.smForEachKey(this.currentMetaData.$cube.$measures, function(key, m) {
				if (metadata.$item.$properties[key] && metadata.$item.$properties[key].$title) {
					m.$title = metadata.$item.$properties[key].$title;
				} else {
					m.$title = key;
				}
			});
		}

		return this.currentMetaData;
	},
	getDataSet: function() {
		return this._dataset || [];
	},
	_ensureFormatter: function(measure) {
		measure.formatApi = {
			format: function(val, localFormat) {
				return val;
			}
		};
	},
	_localizedText: function(key) {
		return key;
	},
	_getFieldEvalTitle: function() {
		return [];
	},
	// Each time the dataset of array changes
	notifyArrayDataChanged: function(refresh, arrayData, isEmpty) {
		var self = this;
		Base.prototype.notifyArrayDataChanged.call(self, refresh, arrayData, isEmpty);
		var chartDataset = [];
		if (arrayData && arrayData.$resources) {
			arrayData.$resources.forEach(function(dao) {
				chartDataset.push(dao.data);
			});
		}
		self._dataset = chartDataset;
		self._links = null;
		if (arrayData && arrayData.$links) {
			self._links = {};
			Object.keys(arrayData.$links).forEach(function(key) {
				if (!arrayData.$links[key].$isHidden) self._links[key] = arrayData.$links[key];
			});
		}
	},
	_settingsFromValue: function() {
		var self = this,
			$cube = this.currentMetaData.$cube,
			icolor = 0,
			settings;

		var dataset = self.getDataSet();
		if ($cube && $cube.$style === "spiderweb") {
			settings = {};
			settings.categories = Object.keys(self._meta.series).map(function(key) {
				return self._meta.series[key].options.name;
			});

			settings.series = {};
			dataset && dataset.reduce(function(res, current) {
				var serie = {
					name: self._getMeasureLabel(current, self._meta.xAxis[0].code),
					color: colors[icolor++],
					data: [],
					pointPlacement: 'on'
				};
				if (serie.name) {
					serie.id = "#s-" + serie.name;
					$.smForEachKey(self._meta.series, function(key, s) {
						if (!s.isHidden) self._pushData(serie, key, key, current);
					});
					res.series[serie.name] = serie;
				}
				return res;
			}, settings);
		} else {
			settings = {
				categories: [],
				series: {}
			};
			dataset && dataset.reduce(function(res, current) {
				var categoryName = self._getMeasureLabel(current, self._meta.xAxis[0].code);
				if (categoryName != null) {
					res.categories.push(categoryName);
					$.smForEachKey(self._meta.series, function(key, s) {
						var serie = res.series[key];
						if (!serie) {
							serie = objectClone(s.options);
							serie.data = [];
							res.series[key] = serie;
						}
						self._pushData(serie, categoryName, key, current);
					});
				}
				return res;
			}, settings);
		}
		return settings;
	},

	_pushData: function(serie, categoryName, key, data) {
		var val = parseFloat(data.$rawV && data.$rawV[key] && data.$rawV[key].v || data[key]) || 0;
		if (this.useLogarithmicAxis) {
			this.maxValue = Math.max(this.maxValue || -Infinity, val);
			this.minValue = Math.min(this.maxValue || Infinity, val);
		}
		serie.data.push({
			name: categoryName,
			y: val,
			"rowId": data.$uuid
		});
	},
	//#6974 add options height/width.onComplete/zoomType
	createChart: function(settings, $$parent, options) {
		var self = this,
			options = _merge(self._getPref(), self._getOptions(self.$prototype, $$parent, options));
		if (self.highchartObject) {
			//#6974 clear existing chart
			self.clearChart();
		}
		if (settings) {
			options.xAxis[0].categories = settings.categories;
			$.smForEachKey(settings.series, function(key, s) {
				var serie = objectClone(s),
					serieMeta = self._meta.series[key];
				if (options.chart.polar && serie && serie.type) {
					delete serie.type;
				}
				if (!(serieMeta && serieMeta.isHidden) && !(serieMeta && serieMeta.options && serieMeta.options.isHidden)) {
					options.series.push(serie);
				}
			});
		} else {
			$.smForEachKey(self._meta.series, function(key, s) {
				var serie = objectClone(s.options);
				if (options.chart.polar && serie && serie.type) {
					delete serie.type;
				}
				serie.data = [0];
				if (!s.isHidden) {
					options.series.push(serie);
				}
			});
		}
		if (!(self.$prototype.$cube && self.$prototype.$cube.$style == "spiderweb")) {
			options.series.reverse();
		}
		if (this.useLogarithmicAxis) {
			if ((this.maxValue || 0) / (this.minValue || 1) > 10) {
				options.yAxis.type = 'logarithmic';
			}
		}
		self.highchartObject = new Highcharts.Chart(options);

		var legend = this.highchartObject.legend;
		self.displayLegend = legend && legend.display;

		var chartSeries = self.highchartObject.series,
			serie, serieMeta;
		for (var j = chartSeries.length - 1; j >= 0; j--) {
			serie = chartSeries[j];
			serieMeta = serie && serie.options.id && self._meta.series[serie.options.id.slice(3)];
			if (serieMeta && serieMeta.measure) {
				serieMeta.measure.$color = serieMeta.options.color = serie.color;
			}
		}
	},
	//#6974 add options height/width.onComplete/zoomType
	_getOptions: function(proto, $$parent, options) {
		options = options || {};
		var self = this,
			$cube = this.currentMetaData.$cube,
			defOptions = Highcharts.getOptions(),
			buttons = defOptions.exporting.buttons,
			enuml,
			$style = this.currentMetaData.$style || ($cube && $cube.$style) || (proto.$cube && proto.$cube.$style),
			axe = proto.$axes && proto.$axes[0] || {},
			axeTitle = $cube.$hierarchies && $cube.$hierarchies[this._getMeasureCode(axe.$hierarchies[0][0])].$title;
		var margin = {
			top: (this.currentMetaData.$isTitleHidden && $style !== "bar" ? 0 : null),
			bottom: (this.currentMetaData.$isXLabelsHidden && $style !== "bar" ? 0 : null),
			left: (this.currentMetaData.$isYLabelsHidden && $style !== "bar" ? 2 : null)
		};
		var legend = {};
		if (globals.getSiteLayout().getDeviceType() === "smartphone") {
			legend.layout = 'horizontal';
			legend.align = 'center';
			legend.verticalAlign = 'bottom';
			legend.floating = 'bottom';
			legend.notitle = true;
		};
		var options = {
			chart: {
				renderTo: $$parent.get(0),
				reflow: false,
				zoomType: options.zoomType || 'x',
				ignoreHiddenSeries: false,
				width: options.width,
				height: options.height,
				inverted: this.currentMetaData.$inverted,
				marginTop: margin.top,
				marginBottom: (!this.currentMetaData.$inverted ? margin.bottom : margin.left),
				marginLeft: (!this.currentMetaData.$inverted ? margin.left : margin.bottom),
				marginRight: (!this.currentMetaData.$inverted ? margin.left : margin.bottom),
				events: {
					load: options.onComplete,
				}
			},
			lang: {
				showHideLegend: self._localize.highCharts_showHideLegend
			},

			legend: {
				layout: legend.layout ? legend.layout : 'vertical',
				align: legend.align ? legend.align : 'right',
				verticalAlign: legend.verticalAlign ? legend.verticalAlign : 'top',
				y: legend.notitle ? 0 : 60,
				x: legend.notitle ? 0 : -10,
				title: {
					text: (legend.notitle ? '' : ':::: ' + self._localize.highCharts_seriesTitle)
				},
				borderWidth: legend.notitle ? 0 : 1,
				floating: legend.notitle ? false : true,
				draggable: legend.notitle ? false : true,
				zIndex: 20,
				enabled: !(this.currentMetaData.$isLegendHidden === true) && ($style !== "pie")
			},
			title: {
				text: (!this.currentMetaData.$isTitleHidden && $cube && self._localizedText($cube.$title)) || null
			},
			subtitle: {
				text: null
			},
			xAxis: [{
				categories: [],
				title: {
					text: (!this.currentMetaData.$isXLabelHidden && self._localizedText(axeTitle)) || null
				},
				labels: {
					rotation: -45,
					align: 'right',
					enabled: !(this.currentMetaData.$isXLabelsHidden === true)
				},
				gridLineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
				minorGridLineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
				lineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
				tickWidth: (this.currentMetaData.$isXLabelsHidden ? 0 : 1)
			}],

			yAxis: [{
				title: {
					text: null
				},
				labels: {
					align: 'right',
					enabled: !(this.currentMetaData.$isYLabelsHidden === true)
				},
				gridLineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
				minorGridLineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
				lineWidth: (this.currentMetaData.$isGridLineHidden ? 0 : 1),
				tickWidth: (this.currentMetaData.$isYLabelsHidden ? 0 : 1)
			}],

			plotOptions: {
				series: {
					pointPadding: 0,
					groupPadding: 0.1,
					cursor: 'pointer',
					events: {},
					point: {
						events: {
							click: self.control ? self.control.getChartClickHandler() : null
						}
					},
					stacking: self._meta.stacking,
					animation: false
				}
			},

			tooltip: {
				formatter: function() {
					var seriesMeta = self._meta.series,
						serie = this.key && seriesMeta[this.key] || seriesMeta[this.series.options.id.slice(3)],
						measure = serie && serie.measure,
						data = this.series.processedYData,
						y = this.y;

					if (measure) {
						self._ensureFormatter(measure);
					}
					var label = this.series.name || measure && measure.$title,
						mformat = measure && measure.formatter;
					label = (label ? label + "<br>" : "") + (this.x || this.key) + ': <b> ' + (mformat ? mformat.format(y) : y) + '</b>';
					if (measure && (measure.$isNormalized) && data.length > 0) {
						var sum = data.reduce(function(a, b) {
							return a + b;
						});
						label += ' (' + (mformat ? mformat.formatValue(y / sum * 100) : y / sum * 100) + '%)';
					}

					return label;
				}
			},

			series: [],
		};
		if ($style === "pie") {
			options.plotOptions.pie = options.plotOptions.pie || {};
			options.plotOptions.pie.dataLabels = options.plotOptions.pie.datalabels || {};
			options.plotOptions.pie.dataLabels.enabled = (this.currentMetaData.$isLabelsHidden ? false : true);
		}
		if (Highcharts.theme.version[0] === 3) {
			// For Highcarts 3.0.0
			options.exporting = {
				type: 'image/png',
				url: 'http://export.highcharts.com/',
				buttons: {
					contextButton: { // docs
						//x: -10, // docs: x is different now
						symbol: 'menu',
						enabled: false,
						_titleKey: 'contextButtonTitle',
						menuItems: [{
							textKey: 'showHideLegend',
							onclick: function() {
								setTimeout(function() {
									self._toggleLegendDisplay();
								}, 100);
							}
						}]
					},
					legendButton: {
						enabled: false,
						textKey: 'showHideLegend',
						symbol: 'menu',
						onclick: function() {
							setTimeout(function() {
								self._toggleLegendDisplay();
							}, 100);
						}
					}
				}
			};
			var menuItems = options.exporting.buttons.contextButton.menuItems || [];
			if (this._printSupported()) {
				menuItems.push({
					text: 'Print chart',
					onclick: function() {
						this.print(self);
					}
				});
			}
			if (this._exportSupported()) {
				menuItems.push({
					separator: true
				});
				menuItems.push({
					textKey: 'downloadPNG',
					onclick: function() {
						this.exportChart();
					}
				});
				menuItems.push({
					textKey: 'downloadJPEG',
					onclick: function() {
						this.exportChart({
							type: 'image/jpeg'
						});
					}
				});
				menuItems.push({
					textKey: 'downloadPDF',
					onclick: function() {
						this.exportChart({
							type: 'application/pdf'
						});
					}
				});
				menuItems.push({
					textKey: 'downloadSVG',
					onclick: function() {
						this.exportChart({
							type: 'image/svg+xml'
						});
					}
				});
			}
		}

		if (options.xAxis[0].title.text !== options.title.text) {
			options.xAxis[0].title.text = (options.xAxis[0].title.text ? options.xAxis[0].title.text : options.title.text);
		}
		options.chart.type = self._meta.defaultStyle;

		return options;
	},

	_initializeMeta: function() {
		this._mergeMetaData(this.$prototype);
		this._mergeMetaData(this.$articleArray);

		var proto = this.$prototype;
		var cube = this.currentMetaData;

		this._meta = {
			xAxis: [{}],
			series: {},
			displaysOneMeasure: cube && cube.$displaysOneMeasure,
			hasMeasureSelector: cube && cube.$hasMeasureSelector,
			hasStyleSelector: cube && cube.$hasStyleSelector,
			defaultStyle: _style(cube.$style) || 'column',
			drill: {
				minLevel: 1,
				maxLevel: 0,
				currLevel: 1,
				currAxisHier: 0,
				levelsProperties: [],
				members: [],
				stack: [{
					$axes: proto.$axes,
					$item: proto.$item,
					$slicer: proto.$slicer
				}]
			}
		};
		this.__processMeta(proto, true);
	},

	_exportSupported: function() {
		return true;
	},

	_printSupported: function() {
		return true;
	},

	__processMeta: function(metaData, init) {
		this._processMeasures(metaData, init);
		this._processAxes(metaData, init);
	},

	_processMeasures: function(metaData, init) {
		this._mergeMetaData(metaData);

		var self = this,
			items = this.$prototype.$properties;

		// Get measures definition. If measures are not defined in the second axis members (Cf. specs),
		// we used all the measures defined in the cube
		var measures = this._getRestraintMeasures(),
			icolor = 0;
		if (measures) {
			$.smForEachKey(measures, function(key, m) {
				// Because duplicate properties is possible for cube definition... we keep the last defined
				var code = (m.$property || key);
				var measure = _merge(items[code], m);
				if (metaData && metaData.$item && metaData.$item.$properties) {
					measure = _merge(measure, metaData.$item.$properties[code]);
				}
				if (!measure.$title || measure.$title === "") {
					measure.$title = key;
				}
				// measures[key] = measure;
				var serie = self._meta.series[code];

				if (init) {
					self._ensureFormatter(measure);

					serie = self._meta.series[code] = {
						options: {
							id: '#s-' + code,
							// legendIndex: "",
							name: self._localizedText(measure.$title) || String.fromCharCode(160),
							// visible: measure.$title !== "" && !!(!self._meta.displaysOneMeasure || measure.$isDefault)
						},
						measure: measure
					};
				}
				if (serie) {
					serie.isHidden = measure.$title === "";
					serie.options.type = _style(measure.$style);
					serie.options.color = measure.$color || colors[icolor++];
					serie.options.name = self._localizedText(measure.$title) || String.fromCharCode(160);
					serie.options.visible = measure.$title !== "" && !! (!self._meta.displaysOneMeasure || measure.$isDefault);
					serie.options.isHidden = measure.$isHidden;
				}

				if (measure.$isStacked || measure.$stackingGroup) {
					serie.options.stack = measure.$stackingGroup || 0; // a stack ID
					self._meta.stacking = measure.$isNormalized ? 'percent' : self._meta.stacking || 'normal';
				}
			});
		}
	},

	_getRestraintMeasures: function() {
		var proto = this.currentMetaData,
			$cube = proto.$cube,
			measures = $cube && $cube.$measures,
			restraintMeasures = measures;
		if (measures) {
			if (proto.$axes && proto.$axes.length > 1 && proto.$axes[1].$members && proto.$axes[1].$members[0][0].length > 0) {
				restraintMeasures = {};
				$.smForEach(proto.$axes[1].$members[0][0], function(measureCode) {
					restraintMeasures[measureCode] = measures[measureCode];
				});
			}
		}
		return restraintMeasures;
	},

	_processAxes: function(proto, init) {
		var cube = this.$prototype.$cube;
		if (!_isCubeValid(cube, proto)) return false;

		var self = this,
			currAxisHier = 0,
			axis0 = proto.$axes && proto.$axes[0];

		// TODO: review this
		// Get axis analysis
		var mainHLevelsTab = null;
		if (axis0) {
			$.smForEachKey(axis0.$hierarchies, function(idx, hierarchy) {
				if (!mainHLevelsTab && hierarchy.length > 1 && hierarchy[1] == 1) {
					mainHLevelsTab = cube.$hierarchies[hierarchy[0]].$properties;
					if (mainHLevelsTab) {
						self._meta.xAxis[0].code = mainHLevelsTab[hierarchy.length > 2 ? hierarchy[2] : 0];
						currAxisHier = idx;
					}
				}
			});
			if (!mainHLevelsTab && axis0.$hierarchies[0].length > 0) {
				mainHLevelsTab = cube.$hierarchies[axis0.$hierarchies[0][0]].$properties;
				if (mainHLevelsTab && mainHLevelsTab.length > 0) self._meta.xAxis[0].code = mainHLevelsTab[0];
			}
			// Get drill definition
			var properties;
			$.smForEach(axis0.$hierarchies, function(hierarchie) {
				properties = cube.$hierarchies[hierarchie[0]].$properties;
				$.smForEach(properties, function(property) {
					this.levelsProperties[this.maxLevel++] = property;
				}, self._meta.drill);
			});
			if (axis0.$members) {
				$.smForEach(axis0.$members, function(tuple) {
					$.smForEach(tuple, function(value) {
						if (value.length > 0) {
							this.members[(this.currLevel++) - 1] = value[0];
						}
					}, this);
				}, self._meta.drill);
			}
		}
		self._meta.drill.code = proto.$codeStat || "UNKNOWN";
		self._meta.drill.axis0FieldCode = self._meta.xAxis[0].code || "";
		self._meta.drill.maxLevel = Math.max(self._meta.drill.maxLevel, self._meta.drill.minLevel);
	},

	_getPref: function() {
		return Highcharts.getOptions();
	},
	//get the measure code depending on level. May be not the best way to do that (see desktop release).
	_getMeasureCode: function(code) {
		var level = this.control.level;
		var measureCode = (level > 1) ? this.$prototype.$axes[0].$hierarchies[level - 1][0] : null;
		//Authoring is yet stored by level but to keep existing authoring, we keep the key but always 1
		measureCode = (this.currentMetaData.$axisLabels) ? this.currentMetaData.$axisLabels[1] : measureCode;
		return measureCode || code;
	},
	_getMeasureLabel: function(measure, code) {
		var self = this;
		var label = this._localizedText(measure.$title);
		if (label) return label;
		code = this._getMeasureCode(code);
		if (!measure[code]) return "";
		var item = self.$prototype.$properties[code];
		if (!item) return null;
		switch (item.$type) {
			case "application/x-choice":
				label = measure[code];
				item.$value.$enum.some(function(element, i, array) {
					if (element.$value === label) {
						label = self._localizedText(element.$title);
						return true;
					}
					return false;
				});
				break;
			case "application/x-date":
				item.formatter = formatApi.getFormatter(item.$type, locale.getDateFormat(item.$type));
				label = item.formatter.formatValue(measure[code]);
				break;
			case "application/x-integer":
			case "application/x-decimal":
				item.formatter = formatApi.getFormatter(item.$type, locale.getNumberFormat(item.$type));
				label = item.formatter.formatValue(measure[code]);
				break;
			default:
				label = "" + measure[code];
				break;
		}
		return label;
	},
	_toggleLegendDisplay: function() {
		var legend = this.highchartObject.legend;
		legend && this._displayLegend(!legend.display);
	},
	_displayLegend: function(display) {
		var legend = this.highchartObject.legend;
		if (!legend) return;
		if (display) {
			legend.group.show();
			legend.box.show();
		} else {
			legend.group.hide();
			legend.box.hide();
		}
		this.displayLegend = legend.display = display;
	}
});

exports.Klass = _Klass;