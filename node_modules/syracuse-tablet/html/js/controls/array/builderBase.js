"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var HammerScroller = require('syracuse-tablet/html/js/helpers/hammerScroller').Klass;
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var _filterSortPanelId = globals.PANELFILTERSORT;

var _templates = {
	pagin: '\
			<nav class="s-m-pagin"> \
				<ul class="pagination"> \
					{{#each links}}\
						<li>\
							<a class="s-m-link {{css}}"\
								href = "#"\
								{{#if url}}\
									data-nav-refresh="true"\
									data-nav-type="{{type}}"\
									data-sdata-url="{{url}}"\
									data-control-id="{{id}}"\
									data-nav-target="{{target}}"\"\
								{{/if}}\
								{{#if action}}\
									data-action="{{action}}"\
									data-params="{{type}}"\
									data-control-id="{{id}}"\
								{{/if}}\
								draggable="false">\
							</a>\
						</li>\
					{{/each}}\
				</ul> \
			</nav> \
		',
	filterSort: '\
		<div class="s-m-filterSort" data-action="actionArray" data-params="{{panelId}}">\
			<i class="s-m-sorted" style="display:none"></i>\
			<i class="s-m-filtered ' + fontUtils.filterIcon("filtered") + '" style="display:none"></i>\
			<i class="' + fontUtils.filterIcon("panel") + '"></i>\
		</div>',
	$filtersList: '\
		<nav class="s-m-filterslist">\
			<select	class="form-control" data-action="actionArray">\
				{{#each filters}}\
					<option value="filterSelected,{{id}}" {{#if $isDefault}}selected=""{{/if}}>{{$title}}</option>\
				{{/each}}\
			</select>\
		</nav>',
	$filterstabs: '\
		<nav class="s-m-filtertabs">\
			<ul class="nav nav-pills nav-justified">\
				{{#each filters}}\
					<li role="presentation" role="tab" data-toggle="tab" data-action="actionArray" data-params="filterSelected,{{id}}" class="{{#if $isDefault}}active{{/if}}"><a href="#">{{$title}}</a></li>\
				{{/each}}\
			</ul>\
		</nav>'

};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	if (!tmpl) alert("template " + name + " not found");
	return tmpl(ctx);
};

var _isExcluded = ["application/x-password"];
var _paginLinks = ["$first", "$previous", "$next", "$last"];
/**
 * Array builder base class
 * Authoring global properties
 * 		$isTitleHidden		Hide the column title
 * 		$rowIdx				Show/Hide row index
 */
var _Klass = utils.defineClass(
	function(control, disp, options) {
		this.$display = disp;
		this.options = options || {};
		if (control == null) throw new Error("Null control");
		this.control = control;
		this.$articleArray = control.article;
		this.$arrayOptions = this.$articleArray.$arrayOptions;
		this.$itemProto = control.prototype.getPrototype("$item");
		this._gestureMgr = null;
		this._lastSelectedRow = null;
	}, null, {
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			// Nested array controls are not stored in controller (gerenateHtml)
			// We need to destoy the scroller
			// To not destroy the scroller we should keep the context off the builder in parent control to destroy all children context when we destroy the parent
			this.destroyScroller();
			this._$$stdHeader = null;
			this._lastSelectedRow = null;

		},
		destroy: function() {
			this.control = null;
			if (this.$itemProto) {
				// We destroy the proto
				this.$itemProto.destroy();
				this.$itemProto = null;
			}
			this.destroyScroller();
		},
		refresh: function(arrayData, buildOptions) {
			buildOptions = buildOptions || {};
			// Option for buildHtml
			buildOptions.refresh = true;
			this.buildHtml(arrayData, buildOptions);
		},
		/**
		 * $$value parent that contains the table - same strcture for all controls
		 * 	arrayData is an object that contains all data needed by array
		 * 	arrayData.$resources contains rows data - Array of dao
		 */
		buildHtml: function(arrayData, buildOptions, classes) {},
		isRefreshContext: function(buildOpts) {
			// We force display if it's an array in a card because there's no resize in that case
			return (buildOpts && (buildOpts.refresh === true || buildOpts.cardDesign === true)) || (this.options && this.options.displayCtx === "card");
		},
		checkEmptyArray: function() {
			if (!this.control._displayArray()) {
				this.control.$$value.empty();
				if (this.control.isEmpty) {
					this.refreshHeaderAndGesture();
					this.control.setEmptyArrayMsg();
				}
				return false;
			}
			return true;
		},
		/**
		 * Parent control notifies the builder taht it's going to clear the content
		 * Overridden by chart builder
		 */
		notifClearContent: function(refresh) {
			// Nothing 
		},
		/**
		 * Can be overridden to clear cached data
		 */
		notifyArrayDataChanged: function(refresh, arrayData, isEmpty) {
			this.destroyScroller();
		},
		onResize: function(context) {
			this.refreshHeaderAndGesture(context);
		},
		doAfterBuild: function(resizeContext, refreshHeaderGesture) {
			if (refreshHeaderGesture || this._needToBuildHeader()) {
				// refreshes the gestureMgr
				this.refreshHeaderAndGesture(resizeContext);
			}
			if (this.control.controller.prototype.isFacet("details", "edit", "create")) {
				// We notify the controller because arrays are built asynchronously - #6541
				// Only detail/edit because for queries the scroller is managed by the array (refreshHeaderAndGesture);
				notifications.notifyController("sm.scroller.update", this.control.controller);
			}
		},
		_needToBuildHeader: function() {
			if (this._arrayHeaderWasCreated === true) {
				return false;
			}
			var $filtersAuth = null;
			var headerOpts = this.control.getHeaderOptions ? this.control.getHeaderOptions() : null;
			if (headerOpts && headerOpts.$filters && headerOpts.$filters.length > 1) {
				$filtersAuth = this.control.controller.$filtersGetAuthoring ? this.control.controller.$filtersGetAuthoring() : null;
			}
			return this._isHeaderVisible($filtersAuth);
		},

		/**
		 * Init gesture manager on onResize because we need to calculate the viewRect
		 */
		refreshHeaderAndGesture: function(resizeContext) {
			var scrollOnly = resizeContext != null && resizeContext.scrollOnly;
			var preserveScroll = resizeContext != null && resizeContext.preserveScroll;
			// we refresh only if it's a windows resize (other type if internalResize)
			var justRefresh = resizeContext != null && resizeContext.resizeEvent && resizeContext.resizeEvent.type === "resize";
			/**
			 * Workaround to check if the display of filters changed
			 */
			if (scrollOnly !== true) {
				this._refreshHeader(justRefresh);
			}
			this._initGestureMgr(preserveScroll);
			if (this._lastSelectedRow) {
				/**
				 * Workaround to preserve last selected line
				 * onResize broke the regular process and onResize is call when we activate a cached page
				 * lastRowSelection is done before the onResize (page.activate) so we need to preserve the selection
				 * Here because the build of array is asynchronous so we can't call this code in ctrlArray.onResize
				 */
				this.selectLastSelectedRow(this._lastSelectedRow, true);
			}
		},
		_initGestureMgr: function(preserveScroll) {
			if (this._gestureMgr) {
				if (this.isScrollable()) {
					// ScrollViewRect has changed so we check to re-init or reset _gestureMgr 
					this._gestureMgr.checkViewRect(this.control.getScrollViewRect(), preserveScroll);
				} else {
					this._gestureMgr.reset();
				}
			}
			if (this._restoreSelectedRowId) {
				// Restore the selected row - We do the job here to be able to make the line visible 
				var $$row = this.selectLastSelectedRow(this._restoreSelectedRowId, true);
				if ($$row && this._gestureMgr) {
					// Scroll to make row visible
					this._gestureMgr.makeVisible($$row);
				}
				this._restoreSelectedRowId = null;
			}
		},
		/**
		 * Can be overridden
		 */
		isScrollable: function() {
			return this.control.getArrayData().$resources.length > 0;
		},
		/**
		 * Display an error
		 */
		insertError: function(html) {
			$(['<span class="s-m-error">', html, "</span>"].join('')).prependTo(this.control.$$elmt);
		},
		/**
		 * Refreshed header and filters
		 * We need to call _refreshHeader in onResize and buildHtml
		 * We display filters/sort and $filter when array is empty -> We need to be able to modify the filter if result returns no data
		 */
		_refreshHeader: function(justRefresh) {
			var $filtersAuth = null;
			var headerOpts = this.control.getHeaderOptions ? this.control.getHeaderOptions() : null;
			if (headerOpts && headerOpts.$filters && headerOpts.$filters.length > 1) {
				$filtersAuth = this.control.controller.$filtersGetAuthoring ? this.control.controller.$filtersGetAuthoring() : null;
			}
			if (justRefresh !== true && this._isHeaderVisible($filtersAuth)) {
				this.control.$$header.children(".s-m-stdheader").remove();
				this._buildArrayHeader(this.control.getArrayData(), $filtersAuth);
			}
			if ($filtersAuth === "tabs") {
				// Displayed below  _$$stdHeader
				this.control.$$header.find(".s-m-filtertabs").remove();
				this._build$Filters(headerOpts.$filters, $filtersAuth);
			}
		},
		_isHeaderVisible: function($filtersAuth) {
			return this.$arrayOptions.showPagination ||
				this.$arrayOptions.showSortFilter ||
				this.$arrayOptions.showSearch ||
				$filtersAuth === "list";

		},
		_buildArrayHeader: function(arrayData, $filtersAuth) {
			var headerOpts = this.control.getHeaderOptions ? this.control.getHeaderOptions() : {};
			var empty = true;
			this._arrayHeaderWasCreated = true;
			this._$$stdHeader = $('<nav class="s-m-stdheader"/>').prependTo(this.control.$$header);
			if (headerOpts.paginEnabled === true && this.$arrayOptions.showPagination === true && !this.control.isCarouselDisplay()) {
				this._buildPagin(this._$$stdHeader, arrayData);
				empty = false;
			}
			if (headerOpts.searchEnabled === true && this.$arrayOptions.showSearch === true) {
				this._$$stdHeader.append(this.control.getSearcher().getHtml());
				empty = false;
			}
			if ((headerOpts.filterEnabled === true || headerOpts.sortEnabled === true) &&
				this.$arrayOptions.showSortFilter === true) {
				this._buildSortFilter(this._$$stdHeader);
				empty = false;
			}
			if ($filtersAuth === "list") {
				this._build$Filters(headerOpts.$filters, $filtersAuth);
				empty = false;
			}
			this._$$stdHeader.toggle(!this._$$stdHeader.is(":empty"));
		},
		_build$Filters: function(filters, $filtersAuth) {
			if (!$filtersAuth || $filtersAuth == "none") return;
			if ($filtersAuth == "list") {
				$(_getHtml("$filtersList", {
					filters: filters
				})).appendTo(this._$$stdHeader);
				return;
			}
			if ($filtersAuth == "tabs") {
				// #6725 in tab mode, we do not show the "all" filter since it feels strange
				var filtersWithoutAll = [];
				for (var i = 1; i < filters.length; i++) {
					filtersWithoutAll.push(filters[i]);
				}
				// #6884 if there's only one filter we don't show it since  it feels also strange
				if (filtersWithoutAll.length > 1) {
					$(_getHtml("$filterstabs", {
						filters: filtersWithoutAll
					})).appendTo(this.control.$$header);
				}
				return;
			}
		},
		_buildPagin: function($$parent, arrayData) {
			var self = this;
			var ctxLinks = {
				links: []
			};
			if (self.control.hasLocalPagination()) {
				var paginator = self.control.getLocalPaginator();
				_paginLinks.forEach(function(linkName) {
					var ctx = {
						css: fontUtils.paginationIcon(linkName)
					};
					if (paginator.isActionEnabled(linkName)) {
						ctx.action = "localPagin";
						ctx.type = linkName;
						ctx.id = self.control.id;
					} else {
						ctx.css += " disabled";
					}
					ctxLinks.links.push(ctx);
				});
			} else if (arrayData.$links && !$.isEmptyObject(arrayData.$links)) {
				_paginLinks.forEach(function(linkName) {
					var ctx = {
						css: fontUtils.paginationIcon(linkName)
					};;
					if (arrayData.$links[linkName] != null) {
						ctx.type = linkName;
						ctx.url = self.control.prototype.resolveExpression(arrayData.$links[linkName].$url);
						ctx.id = self.control.id;
						ctx.target = self.control.controller.isVignette ? "vignette" : "application";
					} else {
						ctx.css += " disabled";
					}
					ctxLinks.links.push(ctx);
				});
			}
			if (ctxLinks.links.length > 0) {
				$$parent.prepend($(_getHtml("pagin", ctxLinks)));
			}
		},
		_buildSortFilter: function($$parent) {
			this._$$sortFilter = $(_getHtml("filterSort", {
				ctrlId: this.control.id,
				panelId: _filterSortPanelId
			}));
			$$parent.append(this._$$sortFilter);
			var sortOrder = null,
				sortField = null,
				hasFilter = false;
			var info = this.control.sortInfoGet();
			if (info) {
				// select the first sorted column
				// Currently we support sorting on only one column
				// -> We can display a asc/desc icon in the header
				// Sort panel can manage sorting on multiple columns but it's disabled
				info.some(function(i) {
					if (i.sort != "none") {
						sortOrder = i.sort;
						sortField = i.id;
						return true;
					}
				});
			}
			var info = this.control.filterInfoGet();
			hasFilter = info && info.length > 0;
			this.filterSortUpdate(sortOrder, sortField, hasFilter);
		},
		/**
		 * Update icons when sort change
		 * Can be overridden
		 */
		filterSortUpdate: function(sortOrder, sortField, hasFilter) {
			if (!this._$$stdHeader) return;
			var $$icon = this._$$stdHeader.find(".s-m-sorted").toggle(sortOrder != null).removeClass();
			if (sortOrder != null) {
				$$icon.addClass("s-m-sorted " + fontUtils.sortIcon(sortOrder));
			}
			this._$$stdHeader.find(".s-m-filtered").toggle(hasFilter === true);
		},
		/**
		 * Can be overridden - lookup
		 * This is the DOM element that contains the record
		 * 	class		s-m-record
		 * 	data-params	rowId
		 * Action (edit/detail/delete) which are children of this element use data-param as parameter see hack in eventistener._bindActions
		 * 	rowId is generated only one time
		 */
		buildRecordMainElmt: function(rowData, options, idx) {
			if (!options || !options.tag) {
				throw new Error("buildRecordMainElmt - Bad options");
			}
			options.css = options.css || [];
			options.css.unshift(globals.RECORDCLASS);
			if (this.options.acceptRowSelectAction === true && rowData) {
				this._addRowSelAction(options, rowData.getValue("$uuid"));
			}
			return uiUtils.createDomElement(options.tag, options.css, options.title, options.attrs, options.parent);
		},
		/**
		 * Add Row Select action
		 */
		_addRowSelAction: function(options, rowId) {
			if (rowId == null || rowId.length === 0) return;
			options.attrs = options.attrs || {};
			// We set data-params on the main dom element of the record (RECORDCLASS)
			options.attrs["data-params"] = encodeURIComponent(rowId);
			var hasLink = this.control.prototype.isLookup();
			if (!hasLink) {
				var links = this.$itemProto.data("$links");
				if (links) {
					var forceLink = this.control.getAuthoring("$detailsLink");
					hasLink = (forceLink && links[forceLink] != null) || links.$details != null;;
				}
			}
			if (hasLink) {
				if (options.tag === "a") {
					options.attrs["href"] = "#";
				}
				// Trigger an action in array control for additional processes before open link
				options.attrs["data-action"] = globals.ACTROWSEL;
			}
		},
		/**
		 * True if field is excluded
		 */
		isExcluded: function(proto) {
			return proto == null || proto.$isExcluded === true || _isExcluded.indexOf(proto.$type) >= 0;
		},
		/**
		 * Returns control id eventually concatenated with arguments
		 * 	Allows to get unic ids for control childs if needed
		 */
		getId: function() {
			var self = this;
			if (arguments.length > 0) {
				return self.control.id + " - " + Array.prototype.join.call(arguments, '-');
			} else {
				return self.control.id;
			}
		},
		_getRowById: function(rowId) {
			return this.control.$$elmt.find('tbody .' + globals.RECORDCLASS + '[data-params="' + rowId + '"]');
		},
		removeRowById: function(rowId) {
			return this._getRowById(rowId).remove();
		},
		/**
		 * lastSelectedRow is restored when after a back action - See page.savedCtxRestore
		 */
		selectLastSelectedRow: function(rowId, show) {
			this._lastSelectedRow = rowId ? rowId : null;
			if (rowId == null) {
				this.control.$$value.find('.s-m-last-selected').removeClass("s-m-last-selected");
			} else {
				return this._getRowById(rowId)[show ? "addClass" : "removeClass"]("s-m-last-selected");
			}
		},
		getSelectedRowId: function() {
			return this.control.$$elmt.find("." + globals.RECORDCLASS + ".s-m-last-selected").attr('data-params');
		},
		callGenerateHtml: function(ctrlToGenerate, $$parent, rowData, destroyAfter, buildOptions, idx) {
			buildOptions = buildOptions || {};
			// htmlRootCtrl is the array control that is stored in memory
			// If we have a card array X with other arrays displayed inside the card (multiple levels) htmlRootCtrl is X
			// -> used to store info if needed (rowDetail links/edit/delete) (see array.rowDetailAdd)
			// -> Like controls are not stord as object in memory (we just generate html) we need to store info for actions in htmlRootCtrl
			var htmlRootCtrl = buildOptions.htmlRootCtrl || this.control;
			// Build HTML
			var $$elmt = ctrlToGenerate.generateHtml($$parent, rowData, htmlRootCtrl, buildOptions.updateLayout);
			if (this.control.prototype.isSingleArray() && idx != null) {
				var meta = ctrlToGenerate.getMetaData();
				// For single array we hide the row if the cell is hidden
				// We hide also the edit/delete buttons if readOnly or disabled
				var d;
				if (ctrlToGenerate.$type === "application/x-reference") {
					//#5344 - $isHidden is stored in data ??
					d = rowData.getValue(globals.SINGLEARRAYPROP);
				} else if (rowData.parent && rowData.parent.data.$properties) {
					// For int collection meta are stores in an array in $properties of array field 
					d = rowData.parent.data.$properties;
					if (d && d[rowData.$bind]) {
						d = d[rowData.$bind].$items[idx];
					}
				}
				if (d) {
					if (!meta) meta = {};
					["$isHidden", "$isReadOnly", "$isDisabled"].forEach(function(p) {
						if (d[p] != null) meta[p] = d[p];
					});
				}
				if (meta.$isHidden === true || meta.$isReadOnly) {
					// Hide row or hide button with readonly
					$$elmt.closest(".s-m-record").addClass(meta.$isHidden ? "hidden" : "readonly");
				}
				ctrlToGenerate.applyMetaData(meta);
			}
			// reste $$elmt to not destroy it when we'll destroy the control
			ctrlToGenerate.$$elmt = null;
			if (destroyAfter === true) {
				// Destroy if needed
				ctrlToGenerate.destroy();
			}
			return $$elmt;
		},
		addEmptyCells: function(rootLayout, $$row, nb, buildOptions, $$wrapper) {
			var self = this;
			if (nb < 1) return;
			// dispEmpty: withtitle, filled, empty
			var dispEmpty = self.$articleArray.$emptycell;
			if (dispEmpty === "withtitle" || dispEmpty === "filled") {
				var $$td = $('<td class="s-m-empty s-m-' + dispEmpty + ' nohover">');
				if ($$wrapper) {
					$$parent = $$wrapper.appendTo($$td);
				}
				var $$parent;
				for (var i = 0; i < nb; i++) {
					$$parent = $$td.clone().appendTo($$row);
					if ($$wrapper) $$parent = $$parent.children().first();
					this.callGenerateHtml(rootLayout, $$parent, null, false, buildOptions);
				}
			}
			return $$row.children("td.s-m-empty");
		},
		/**
		 * Return the context to save.
		 * It will be be restored afer page has been loaded
		 * The context is saved and restored by the page
		 * Stores the scroll index
		 */
		savedCtxCreate: function() {
			return {
				$display: this.$display,
				gestureMgr: this._gestureMgr ? this._gestureMgr.savedCtxCreate() : null,
				lastSelectedRow: this._lastSelectedRow
			};
		},
		savedCtxRestore: function(ctx) {
			if (this._gestureMgr && ctx.gestureMgr && this.$display === ctx.$display) {
				// Restore context and refresh only if $display didn't change
				this._gestureMgr.savedCtxRestore(ctx.gestureMgr, true);
			}
			if (ctx.lastSelectedRow) {
				this._restoreSelectedRowId = ctx.lastSelectedRow;
			}
		},
		newScroller: function(type, $$elmt, valMax) {
			// Set gesture manager - disabled - Enabled onResize
			this.destroyScroller();
			/**
			 * We wrap a parent that will give the Height/Width for scrolling
			 */
			this._gestureMgr = new HammerScroller($$elmt, {
				direction: type,
				valMax: valMax == null ? 0 : valMax,
				name: this.control.$bind,
				isPageScroller: false
			}, globals.getMainPageGestureMgr()); //, $$elmt.wrap('<div class="s-m-scroll-wrapper"/>').parent());
			return this._gestureMgr;
		},
		destroyScroller: function() {
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},
		hasScroller: function() {
			return this._gestureMgr != null;
		},
		/**
		 * Must be called after buildHtml
		 * True if a singme array is empty - $isHidden on all records
		 */
		isEmptySingleArray: function() {
			if (!this.control || !this.control.getArrayData()) return false;
			if (this.control.getArrayData().length > 0) return false;
			return this.control.prototype.isSingleArray() && this.control.$$value.find(".s-m-record.hidden").length === this.control.getArrayData().$resources.length;
		},
		isColumnDisplayed: function($bind) {
			var cols = this.getColumnsInfo(true);
			if (!cols) return false;
			return cols.some(function(c) {
				return c.$bind === $bind;
			});
		},
		getColumnsInfo: function(onlyVisible) {
			throw new Error("Not implemented");
		}
	});

exports.Klass = _Klass;