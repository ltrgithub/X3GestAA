"use strict";
var utils = require('syracuse-tablet/html/js/helpers/utils');
var scroller = require('syracuse-tablet/html/js/helpers/scroller/scrollerHelpers');
var modules = require('syracuse-tablet/html/js/common/modules');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var fieldOperators = require('syracuse-tablet/html/js/helpers/fieldOperators');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

exports.getHtmlStatus = function(statusInfo, rowDataset) {
	if (!statusInfo || !rowDataset) return;
	var html = ['<div class="s-m-control s-m-row-status">'];
	var h, defIcon = fontUtils.getArrayStatusDefIcon(),
		icon;
	statusInfo.list.some(function(s) {
		if (s.color && fieldOperators.evaluateOperator(s.$type, rowDataset.getValue(s.field), s.operator, s.value)) {
			icon = s.icon || defIcon;
			// We use background color for color icon
			html.push('<div class="' + icon.css + '" style="color:' + s.color.bgColor + '"/>');
			return true;
		}
	});
	html.push('</div>');
	return html.join('');
}

var _isExcluded = ["application/x-password"];

exports.BuilderBase = utils.defineClass(
	function builderBase(control) {
		this.control = control;
		this.$itemProto = this.control.get$ItemProto();
		this.article = this.control.article;
		this.prototype = this.control.prototype;
		this.controller = this.control.controller;
	}, null, {

		destroy: function() {
			this.destroyed = true;
			this.control = null;
			this.$itemProto = null;
			this.article = null;
			this.controller = null;
			this.prototype = null;
			notifications.unsubscribe(this);
		},

		isDestroyed: function() {
			return this.control == null || this.control.destroyed;
		},

		/**
		 * Initialize building and builds the fixed elements of the array that doesn't depend on the parent's size
		 * data is an array of row's dataSet
		 */
		buildHtml: function(data, $$parent, refresh) {},

		/**
		 * Method called on resize (computeLayout)
		 * Builds the elements that need the parent's size
		 * -> scroller, chart, card...
		 */
		buildOnResize: function(data, $$parent, context) {},

		appendRow: function(recordDataset) {
			throw new Error("Not implemented");
		},

		insertError: function(html) {
			$(['<span class="s-m-error">', html, "</span>"].join('')).prependTo(this.control.$$elmt);
		},

		/**
		 * Returns false to break build process
		 */
		checkEmptyArray: function(forceEmpty) {
			if (this.control.isEmpty() || forceEmpty === true) {
				this.updateGestureMgr();
				this.control.setEmptyArrayMsg();
				return false;
			}
			return true;
		},

		doAfterBuild: function() {
			this.updateGestureMgr();
			if (this.control.page.isFacet("details", "edit", "create")) {
				// We notify the controller because arrays are built asynchronously - #6541
				// Only detail/edit because for queries the scroller is managed by the array (refreshHeaderAndGesture);
				this.control.page.notifyScrollerUpdate();
			}
		},

		updateGestureMgr: function(resizeContext) {
			resizeContext = resizeContext || {};
			var scrollOnly = resizeContext.scrollOnly;
			var preserveScroll = resizeContext.preserveScroll;
			if (this._gestureMgr) {
				if (this.isScrollable()) {
					// ScrollViewRect has changed so we check to re-init or reset _gestureMgr 
					this._gestureMgr.checkViewRect(this.control.getScrollViewRect(), preserveScroll);
				} else {
					this._gestureMgr.reset();
				}
			}
		},
		makeVisible: function($$elmt, smoothOffset) {
			if (this._gestureMgr) {
				this._gestureMgr.makeVisible($$elmt, smoothOffset);
			}
		},
		isScrollable: function() {
			return true;
		},

		/**
		 * True if field is excluded
		 */
		isExcluded: function(proto) {
			return proto == null || proto.json.$isExcluded === true || _isExcluded.indexOf(proto.json.$type) >= 0;
		},

		newScroller: function(type, $$elmt, options) {
			this.destroyScroller();
			options = $.extend(true, {
				direction: type,
				name: this.control.$bind,
				isPageScroller: false
			}, options);
			if (options.valMax == null) {
				options.valMax = 0;
			};
			this._gestureMgr = scroller.newScroller($$elmt, options, modules.get("navStack").getMainStack().getTopPage().getGestureMgr());
			return this._gestureMgr;
		},

		destroyScroller: function() {
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},
		hasScroller: function() {
			return this._gestureMgr != null;
		},
		savedCtxCreate: function(opts) {
			if (this._gestureMgr == null || (opts && opts.noScroll === true)) {
				return {};
			}
			var res = {
				$display: this.control.$display,
				selectedRowUuid: this.getLastSelectedRowId()
			};
			res.gestureMgr = this._gestureMgr ? this._gestureMgr.savedCtxCreate(opts) : null;
			return res;
		},
		savedCtxRestore: function(ctx) {
			this.control.$$content.find(".s-m-last-selected").removeClass("s-m-last-selected");
			if (ctx.selectedRowUuid) {
				this.setLastSelectedRowId(ctx.selectedRowUuid);
			}
			if (ctx.gestureMgr != null && this.control.$display === ctx.$display) {
				if (this._gestureMgr) {
					// Restore context and refresh only if $display didn't change
					this._gestureMgr.savedCtxRestore(ctx.gestureMgr, true);
				} else {
					this._restoreGestureMgr = ctx.gestureMgr;
				}
			}
		},
		getLastSelectedRowId: function() {
			throw new Error("Not implemented")
		},
		setLastSelectedRowId: function(selectedRowUuid) {
			throw new Error("Not implemented")
		},
		/**
		 * Update row's index in html
		 */
		updateRowIndex: function($$parent, index) {
			// nothing
		}

	});