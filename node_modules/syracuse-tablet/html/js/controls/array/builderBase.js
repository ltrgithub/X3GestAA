"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var uiRect = require('syracuse-tablet/html/js/ui/rect');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var HammerScroller = require('syracuse-tablet/html/js/helpers/hammerScroller').Klass;

var _filterSortPanelId = "filtersortpanel";

var _templates = {
	pagin: '\
			<nav class="s-m-pagin"> \
				<ul class="pagination"> \
					{{#each links}}\
						<li>\
							<a class="s-m-link {{css}}"\
								href = "#"\
								{{#if url}}\
									data-nav-refresh="true"\
									data-nav-type="{{type}}"\
									data-sdata-url="{{url}}"\
									data-control-id="{{id}}"\
									data-nav-target="{{target}}"\
								{{/if}}\
								draggable="false">\
							</a>\
						</li>\
					{{/each}}\
				</ul> \
			</nav> \
		',
	filterSort: '\
		<div class="s-m-filterSort" data-action="actionArray" data-params="{{panelId}}">\
			<i class="s-m-sorted" style="display:none"></i>\
			<i class="s-m-filtered ' + fontUtils.filterIcon("filtered") + '" style="display:none"></i>\
			<i class="' + fontUtils.filterIcon("panel") + '"></i>\
		</div>'

};
var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	if (!tmpl) alert("template " + name + " not found");
	return tmpl(ctx);
};

var _isExcluded = ["application/x-password"];
var _paginLinks = ["$first", "$previous", "$more", "$next", "$last"];
/**
 * Array builder base class
 * Authoring global properties
 * 		$isTitleHidden		Hide the column title
 * 		$rowIdx				Show/Hide row index
 */
var _Klass = utils.defineClass(
	function(control, options) {
		var self = this;
		self.options = options || {};
		if (control == null) throw new Error("Null control");
		self.control = control;
		// Article of content inside this control
		// This should not be self.$article
		self.$article = control.article.$article;
		// Article of control itself with $bind, $isTitleHidden, $cardsPer<xxx>, all that does affect the control itself
		// Normally, this should be self.$article
		self.$articleArray = control.article;
		self.$itemProto = control.prototype.getPrototype("$item");
		self.displayRowIdx = self.$article.$rowIdx === true;
		self._gestureMgr = null;
	}, null, {
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {},
		destroy: function() {
			this.control = null;
			if (this.$itemProto) {
				// We destroy the proto
				this.$itemProto.destroy();
				this.$itemProto = null;
			}
			if (this._gestureMgr) {
				this._gestureMgr.destroy();
				this._gestureMgr = null;
			}
		},
		refresh: function(arrayData, buildOptions) {
			buildOptions = buildOptions || {};
			// Option for buildHtml
			buildOptions.refresh = true;
			this.buildHtml(arrayData, buildOptions);
			if (this._gestureMgr) {
				this._gestureMgr.reset();
				this._initGestureMgr();
			}
		},
		/**
		 * $$value parent that contains the table - same strcture for all controls
		 * 	arrayData is an object that contains all data needed by array
		 * 	arrayData.$resources contains rows data - Array of dao
		 */
		buildHtml: function(arrayData, buildOptions, classes) {
			if (!this.$article || !this.$article.$items) {
				// a$article is expected - see articlePArse which set the default article
				this.insertError("<b>No $article found for array " + this.control.$bind + "<b>");
			}
		},
		/**
		 * Init gesture manager on onResize because we need to calculate the viewRect
		 */
		onResize: function() {
			this._initGestureMgr();
		},
		_initGestureMgr: function() {
			if (!this._gestureMgr) return;
			var reset = true;
			if (this.control.getArrayData().$resources.length > 0) {
				// Page rect
				var viewRect = this.control.getScrollViewRect();
				if (viewRect) {
					// tbody rect
					var bodyRect = uiRect.elmtRect(this._gestureMgr.$$elmt, "computed");
					//intersectRect has fixed coordinate to check if the 'finger' is inside on mousemouve event
					var intersectRect = viewRect.intersectRect(bodyRect, false);
					if (intersectRect != null) {
						// Enable scroll
						this._gestureMgr.init(intersectRect);
						reset = false;
					}
				}
			}
			if (reset) {
				// we reset only if no init call
				// reset clears the restored context so we lost it
				this._gestureMgr.reset();
			}
		},
		/**
		 * Display an error
		 */
		insertError: function(html) {
			var err = ['<div class="s-m-error">'];
			err.push(html);
			err.push("</div>");
			$(err.join('')).appendTo(this.control.$$elmt);
		},
		buildArrayHeader: function(arrayData, buildOptions) {
			buildOptions = buildOptions || {};
			if (buildOptions.paginEnabled === true || (this._$$pagin && buildOptions.refresh)) {
				this.buildPagin(arrayData, buildOptions);
			}
			if (buildOptions.filterEnabled === true || buildOptions.sortEnabled === true) {
				this.buildSortFilter();
			}
		},
		buildPagin: function(arrayData, buildOptions) {
			var self = this;
			if (buildOptions.refresh == true) {
				// TODO just refresh
				if (self._$$pagin) self._$$pagin.remove();
			}
			// Temporarily disabled - during mobile gesture implementation
			var addLink = function(parent, linkName, attrs) {
				$(uiUtils.createDomElement('a', ["s-m-link", fontUtils.paginationIcon(linkName), linkName.substr(1)],
					null, attrs)).appendTo(parent);
			};
			if (arrayData.$links) {
				var ctxLinks = {
					links: []
				}, ctx;
				// We wan to display all the links and disable the ones that are not in $link - except $more id cache.disabled
				_paginLinks.forEach(function(linkName) {
					if (linkName === "$more" && globals.getCache().isDisabled()) {
						return;
					}
					ctx = {
						css: fontUtils.paginationIcon(linkName)
					};
					if (arrayData.$links[linkName]) {
						ctx.type = linkName;
						ctx.url = arrayData.$links[linkName].$url;
						ctx.id = self.control.id;
						ctx.target = self.control.controller.isVignette ? "vignette" : "application";
					} else {
						ctx.css += " disabled";
					}
					ctxLinks.links.push(ctx);
				});
				self._$$pagin = $(_getHtml("pagin", ctxLinks));
				self.control.$$header.prepend(self._$$pagin);
			}
		},
		buildSortFilter: function() {
			if (this._$$sortFilter) return;
			this._$$sortFilter = $(_getHtml("filterSort", {
				ctrlId: this.control.id,
				panelId: _filterSortPanelId
			}));
			this.control.$$header.append(this._$$sortFilter);
		},
		/**
		 * Update icons when sort change
		 */
		sortInfoUpdate: function(order) {
			var $$icon = this.control.$$header.find(".s-m-sorted");
			$$icon.toggle(order != null);
			if (order == null) return;
			$$icon.removeClass().addClass("s-m-sorted " + fontUtils.sortIcon(order));
		},
		/**
		 * Can be overridden - lookup
		 * This is the DOM element that contains the record
		 * 	class		s-m-record
		 * 	data-params	rowId
		 * Action (edit/detail/delete) which are children of this element use data-param as parameter see hack in eventistener._bindActions
		 * 	rowId is generated only one time
		 */
		buildRecordMainElmt: function(rowData, options, idx) {
			if (options == null) throw new Error("Null options");
			var self = this;
			var attrs = options.attrs || {};
			if (rowData) {
				// We set data-params on the main dom element of the record (RECORDCLASS)
				attrs["data-params"] = encodeURIComponent(rowData.getValue("$uuid") || "");
			}
			options.css = options.css || [];
			options.css.unshift(globals.RECORDCLASS);
			var hasLink = self.control.prototype.isLookup();
			if (!hasLink) {
				var links = self.$itemProto.data("$links");
				// If there is a DASHBOARD link it replaces $details
				hasLink = ((links && links.DASHBOARD) || (links && links.$details)) != null;
			}
			if (hasLink) {
				if (options.tag === "a") {
					attrs["href"] = "#";
				}
				// Trigger an action in array control for additional processes before open link
				attrs["data-action"] = globals.ACTROWSEL;
			}
			if (hasLink || options.createIfNoLink) {
				return uiUtils.createDomElement(options.tag, options.css, options.title, attrs, options.parent);
			}
			return null;
		},
		/**
		 * True if field is excluded
		 */
		isExcluded: function(proto) {
			return proto == null || proto.$isExcluded === true || _isExcluded.indexOf(proto.$type) >= 0;
		},
		/**
		 * Returns control id eventually concatenated with arguments
		 * 	Allows to get unic ids for control childs if needed
		 */
		getId: function() {
			var self = this;
			if (arguments.length > 0) {
				return self.control.id + " - " + Array.prototype.join.call(arguments, '-');
			} else {
				return self.control.id;
			}
		},
		_getRowById: function(rowId) {
			return this.control.$$elmt.find('tbody .' + globals.RECORDCLASS + '[data-params="' + rowId + '"]');
		},
		removeRowById: function(rowId) {
			this._getRowById(rowId).remove();
		},
		/**
		 * lastSelectedRow is restored when after a back action - See page.savedCtxRestore
		 */
		selectLastSelectedRow: function(rowId, show) {
			this._getRowById(rowId)[show ? "addClass" : "removeClass"]("s-m-last-selected");
		},
		getSelectedRowId: function() {
			return this.control.$$elmt.find("." + globals.RECORDCLASS + ".s-m-last-selected").attr('data-params');
		},
		callGenerateHtml: function(ctrlToGenerate, $$parent, rowData, destroyAfter, buildOptions, idx) {
			// htmlRootCtrl is the array control that is stored in memory
			// If we have a card array X with other arrays displayed inside the card (multiple levels) htmlRootCtrl is X
			// -> used to store info if needed (rowDetail links/edit/delete) (see array.rowDetailAdd)
			// -> Like controls are not stord as object in memory (we just generate html) we need to store info for actions in htmlRootCtrl
			var htmlRootCtrl = buildOptions && buildOptions.htmlRootCtrl ? buildOptions.htmlRootCtrl : this.control;
			// Build HTML
			var $$elmt = ctrlToGenerate.generateHtml($$parent, rowData, destroyAfter, htmlRootCtrl);
			// Get Meta Data
			var meta = ctrlToGenerate.getMetaData();
			if (this.control.prototype.isSingleArray() && idx != null) {
				// For single array we hide the row if the cell is hidden
				// We hide also the edit/delete buttons if readOnly or disabled
				var d;
				if (ctrlToGenerate.$type === "application/x-reference") {
					//#5344 - $isHidden is stored in data ??
					d = rowData.getValue(globals.SINGLEARRAYPROP);
				} else if (rowData.parent && rowData.parent.data.$properties) {
					// For int collection meta are stores in an array in $properties of array field 
					d = rowData.parent.data.$properties;
					if (d && d[rowData.$bind]) {
						d = d[rowData.$bind].$items[idx];
					}
				}
				if (d) {
					if (!meta) meta = {};
					["$isHidden", "$isReadOnly", "$isDisabled"].forEach(function(p) {
						if (d[p] != null) meta[p] = d[p];
					});
				}
				if (meta.$isHidden === true || meta.$isReadOnly) {
					// Hide row or hide button with readonly
					$$elmt.closest(".s-m-record").addClass(meta.$isHidden ? "hidden" : "readonly");
				}
			}
			if (meta) {
				// Apply meta fater build
				ctrlToGenerate.applyMetaData(meta);
			}
			// reste $$elmt to not destroy it when we'll destroy the control
			ctrlToGenerate.$$elmt = null;
			if (destroyAfter === true) {
				// Destroy if needed
				ctrlToGenerate.destroy();
			}
		},
		addEmptyCells: function($$row, nb, buildOptions) {
			var self = this;
			if (nb < 1) return;
			// dispEmpty: withtitle, filled, empty
			var dispEmpty = self.$articleArray.$emptycell;
			if (dispEmpty === "withtitle" || dispEmpty === "filled") {
				var td = '<td class="s-m-empty s-m-' + dispEmpty + ' nohover">';
				for (var i = 0; i < nb; i++) {
					this.callGenerateHtml(this._layoutRoot, $(td).appendTo($$row), null, false, buildOptions);
				}
			}
			return $$row.children("td");
		},
		/**
		 * Return the context to save.
		 * It will be be restored afer page has been loaded
		 * The context is saved and restored by the page
		 * Stores the scroll index
		 */
		savedCtxCreate: function() {
			if (this._gestureMgr) {
				return this._gestureMgr.savedCtxCreate();
			}
		},
		savedCtxRestore: function(ctx) {
			if (this._gestureMgr) {
				// Restore context and refresh
				this._gestureMgr.savedCtxRestore(ctx, true);
			}
		},
		newScroller: function(type, $$elmt) {
			// Set gesture manager - disabled - Enabled onResize
			if (this._gestureMgr) this._gestureMgr.destroy();
			/**
			 * We wrap a parent that will give the Height/Width for scrolling
			 * It is used also to enable native scrolls (for test) by alt click
			 */
			var $$nativeScroll = $$elmt.wrap('<div class="s-m-scroll-wrapper"/>').parent();
			this._gestureMgr = new HammerScroller($$elmt, {
				direction: type,
				valMax: 0,
				name: this.control.$bind,
				isPageScroller: false
			}, this.control.controller.getMainPageGestureMgr(), $$nativeScroll);
		},
		/**
		 * Must be called after buildHtml
		 * True if a singme array is empty - $isHidden on all records
		 */
		isEmptySingleArray: function() {
			if (!this.control || !this.control.getArrayData()) return false;
			if (this.control.getArrayData().length > 0) return false;
			return this.control.prototype.isSingleArray() && this.control.$$value.find(".s-m-record.hidden").length === this.control.getArrayData().$resources.length;
		}
	});

exports.Klass = _Klass;