"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var builderBase = require('syracuse-tablet/html/js/controls/array/builderBase');
var Base = builderBase.Klass;
var Scroller = require('syracuse-tablet/html/js/controls/array/verticalScroller').Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var reqProto = require('syracuse-tablet/html/js/helpers/prototype');;
var modal = require('syracuse-tablet/html/js/ui/modal');
var daoSdata = require('syracuse-tablet/html/js/application/daoSdata');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');

var _isExcluded = ["application/json", "application/x-array", "application/x-document", "application/x-binary"];
var _ADDROW = "$ADDROW";
var _addRowBtn = {
	$activity: "create",
	$type: "tablet/x-button",
	$icon: "addrow",
	$bind: _ADDROW,
	$text: "Add row"
};
var _additionalCols = [{
	$type: "tablet/x-icon",
	css: ["s-m-icon"],
	$activity: "edit",
	$icon: "editrow",
	$bind: "$EDITROW"
}, {
	$type: "tablet/x-icon",
	css: ["s-m-icon"],
	$activity: "edit",
	$icon: "delrow",
	$bind: "$DELETEROW",
	$action: "delrow"
}, {
	$type: "tablet/x-icon",
	css: ["s-m-icon"],
	$activity: "display",
	$icon: "detailrow",
	$bind: "$DETAILROW"
}];
/**
 * x-array control class
 * Array authoring - $article
 * 		$items 				Columns authoring
 * 				$title			Override the title
 * 				$width			Set the width
 * 				$isAdvanced		Not displayed in grid
 */
var _Klass = utils.defineClass(
	function(control, options) {
		var self = this;
		Base.call(self, control, options);
		self._columnInfo = null;
		self._scroller = null;
	}, Base, {
		destroy: function() {
			var self = this;
			Base.prototype.destroy.call(self);
			if (self._scroller) {
				self._scroller.destroy();
				self._scroller = null;
			}
			if (self._columnInfo) {
				self._columnInfo.forEach(function(col) {
					if (col.control) col.control.destroy();
				});
				self._columnInfo = null;
			}
		},
		buildHtml: function(arrayData, options) {
			var self = this;
			Base.prototype.buildHtml.call(self, arrayData, options);
			if (!self.$article) return;
			if (self._createColumnInfo(options).length > 0) {
				var $$table = $(uiUtils.createDomElement('table', ["table table-hover table-condensed"], null, null, self.$$value));
				self._buildTableHead($$table, options);
				self._buildTableBody($$table, arrayData, options);
				self._buildTableFoot($$table, options);
				self.buildPagingLinks(arrayData, {
					top: true,
					bottom: false
				});
				if (arrayData.$resources.length > 0 && this.$$tbody) {
					// Create a scroller - Scroller will be initialized afterShow
					if (!this.control.isArrayField()) {
						// Temporarily - Scroll only for query and lookup
						// For fields array we need to set the height
						// This object manages events and also callback - It is used also by CardV builder
						this._scroller = new Scroller(this, {
							scale: 0.1
						});
					}
				}
			} else {
				self.$$value.addClass("empty");
			}
		},
		afterShow: function() {
			if (this._scroller) {
				// Init scroller
				this._scroller.afterShow();
			}
		},
		// get columns that should be displayed
		_createColumnInfo: function(options) {
			var self = this;
			if (self._columnInfo) return self._columnInfo;
			self._columnInfo = [];
			if (self.displayRowIdx) {
				self._columnInfo.push({
					"$bind": globals.ROWIDXPROP,
					"proto": reqProto.getRowIdxProto(),
					css: "s-m-rowidx"
				});
			}
			var proto, nbCols = 0,
				unfound = [],
				col;
			self.$article.$items.forEach(function(item, idx) {
				proto = self.$itemProto.property(item.$bind);
				if (!proto) {
					unfound.push(item);
					// TODO - Display error
				} else {
					nbCols++;
					if (!self.isExcluded(item, proto)) {
						col = {
							"$bind": item.$bind,
							"proto": self.$itemProto.create(proto),
							"article": item
						};
						if (col.article.$isTitleHidden === true) {
							col.title = "";
						} else if (col.article.$title != null) {
							// Title can be overridden bay article - TODO translation
							col.title = self.$itemProto.resolveExpression(col.article.$title) || "";
						} else {
							col.title = col.proto.data('$title') || "";
						}
						self._columnInfo.push(col);
					}
				}
			});
			var edit = self.control.controller.isEditMode();
			var overflow = self._columnInfo.length != nbCols;
			_additionalCols.forEach(function(col) {
				if ((edit && col.$activity === "edit") || (!edit && overflow && col.$activity === "display")) {
					self._columnInfo.push($.extend(true, {}, col));
				}
			});
			if (unfound.length > 0) {
				// Add unfound columns
				var html = ['Field(s) not found<ul>'];
				unfound.forEach(function(x) {
					html.push("<li><b>" + x.$bind + "</b></li>");
				});
				html.push("</ul>");
				self.insertError(html.join(''));
			}
			return self._columnInfo;
		},
		isExcluded: function(item, proto) {
			var self = this;
			if (Base.prototype.isExcluded.call(self, proto)) return true;
			return _isExcluded.indexOf(proto.$type) >= 0 || item.$isAdvanced === true;
		},
		_buildTableHead: function($$table, options) {
			var self = this;
			var tabHead = uiUtils.createDomElement('thead', null, null, null, $$table);
			var tr = uiUtils.createDomElement('tr', null, null, null, tabHead);
			var th, css;
			self._columnInfo.forEach(function(col) {
				th = uiUtils.createDomElement('th', col.css, col.title, null, tr);
				if (col.article) {
					css = {};
					if (col.article.$width != null) {
						// TODO -Use our own styles for table not BS
						css["max-width"] = css.width = col.article.$width;
					}
					$(th).css(css);
				}
			});
		},
		_buildTableFoot: function($$table, options) {
			var self = this;
			if (self.control.controller.isEditMode()) {
				var $$cell = $('<tfoot/><tr><td colspan="' + self._columnInfo.length + '"></td></tr></tfoot>').appendTo($$table).find("td");
				var fieldProto = self._getOtherColProto(_addRowBtn, "");
				/**
				 * Build cell html and append it to parent
				 * Control is used only one time
				 */
				var ctrl = articleParser.tableCell2Control(self.control, $$cell, _addRowBtn.$bind, fieldProto);
				self.callGenerateHtml(ctrl, $$cell, daoSdata.emptyDao(fieldProto), true, options);
			}
		},
		_buildTableBody: function($$table, arrayData, options) {
			var self = this;
			self.$$tbody = $(uiUtils.createDomElement('tbody', null, null, null, $$table));
			// Build rows
			for (var i = 0; i < arrayData.$resources.length; i++) {
				self._buildTableRow(self.$$tbody.get(0), arrayData.$resources[i], i, options);
			}
		},
		_buildTableRow: function(tabBody, rowData, idx, options) {
			var self = this;
			var cssRowIdx;
			if (self.displayRowIdx) {
				rowData.setRowIndex(idx);
			}
			var rowId = rowData.getValue("$uuid");
			var tr = self.buildDetailLink(rowData, {
				tag: "tr",
				parent: tabBody,
				createIfNoLink: true,
				css: rowId === self.control.controller.lastSelectedRowId ? "s-m-selected" : undefined
			});
			var $$cell, rowIdx, fieldProto;
			self._columnInfo.forEach(function(col, idx) {
				rowIdx = self.displayRowIdx && col.$bind === globals.ROWIDXPROP;
				$$cell = $(uiUtils.createDomElement('td', rowIdx ? col.css : null, null, null, tr));
				fieldProto = col.$activity != null ? self._getOtherColProto(col, rowId, rowData, options) : col.proto;
				if (!col.control) {
					// Creates the control used for generating html in cells
					col.control = articleParser.tableCell2Control(self.control, $$cell, col.$bind, fieldProto);
				}
				col.control.generateHtml($$cell, rowData, false);
			});
		},
		/**
		 * Returns the proto for button, icons for actions
		 * 		Add new row			array._actRowDetail
		 * 		Detelete row		array._actDelrow
		 * 		Goto row detail		array._actRowDetail
		 * 		Edit row detail		array._actRowDetail
		 * In row detail page we will get a null rowid for creation
		 */
		_getOtherColProto: function(colInfo, rowId, rowData, options) {
			var self = this;
			var action = colInfo.$action || builderBase.ACTROWDETAIL;
			var params;
			var rowInfo = {
				pathBind: [],
				isCreate: false
			};
			if (rowData) {
				// EDIT/DETAIL ROW
				var rowId = rowData.getValue("$uuid");
				// Build the path of array field and rowsid's and stores it in mainArrayCtrl
				var rd = rowData;
				rowInfo.pathId = [];
				rowInfo.pathId.unshift(rowId);
				rowInfo.pathBind.unshift(rd.$bind);
				while (rd.parent && rd.parent.prototype.isArray()) {
					rowInfo.pathId.unshift(rd.parent.getValue("$uuid"));
					rowInfo.pathBind.unshift(rd.parent.$bind);
					rd = rd.parent;
				}
				// Expression resolved by the control(type is given by colInfo.$type)
				params = "{$uuid}";
			} else {
				// CREATE ROW
				rowInfo.isCreate = true;
				var rd = self.control.getDao();
				rowInfo.pathBind = rd.$bind.length === 0 ? [self.control.$bind] : (rd.$bind + "." + self.control.$bind).split('.');
				rowId = utils.UUID();
				params = rowId;
			}
			// mainArrayCtrl is the array control at the origin of the creation of the table/card
			// When we generate html cards for arrays nested is a parent array the main control is propagated by options.htmlRootCtrl
			// Otherwise the maincontrol is self.control
			var mainArrayCtrl = options && options.htmlRootCtrl ? options.htmlRootCtrl : self.control;
			// Registers the row info into the main Array control
			// Like html generator destroy the control and dao after generation we need to store the paths (ids and $bind) to retreive row dao and proto
			mainArrayCtrl.rowDetailAdd(rowId, rowInfo);
			var json = {
				$action: {
					"data-action": action,
					"data-params": params
				}
			};
			// Additional info needed to create the control (button, icon...)
			["$type", "$icon", "$text"].forEach(function(x) {
				if (x != null && x != "$activity") json[x] = colInfo[x];
			});
			return reqProto.create(json);
		},
		/**
		 * Store/Restore scroller context for back navigation
		 * It's why we need to create the scroller before afterShow
		 */
		savedCtxCreate: function() {
			return this._scroller ? this._scroller.savedCtxCreate() : null;
		},
		savedCtxRestore: function(ctx) {
			if (this._scroller) this._scroller.savedCtxRestore(ctx);
		}
	});

exports.Klass = _Klass;