"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var builderBase = require('syracuse-tablet/html/js/controls/array/builderBase');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var Base = builderBase.Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var reqProto = require('syracuse-tablet/html/js/helpers/prototype');;
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');

var _fixedSzInfo = {};
/**
 * Calculates the sizes for characters, iconCells
 */
var _getFixedSizeInfo = function($$table) {
	var dev = globals.getSiteLayout().getDeviceType();
	var r = _fixedSzInfo[dev];
	if (r) return r;
	var $$body = $('<tbody></body>').appendTo($$table);
	var $$tr = $('<tr class="s-m-record"><td><div class="s-m-control s-m-field" style="width:100%"><div class="s-m-value" style="width:100%" ><span style="width:100%" id="text">MMMMMMMMMM</span></div></div></td><td class="s-m-icon"><div class="s-m-control s-m-icon"><a href="#" class="a"><span class="fa fa-hand-o-right"></span></a></div></td></tr>');
	$$tr.appendTo($$body);
	var tdWidth = $$tr.find("td").outerWidth();
	var valWidth = $$tr.find(".s-m-value").outerWidth();
	var textWidth = $$tr.find("#toto").width();
	r = {
		cellPadding: tdWidth - valWidth,
		charWidth: Math.ceil($$tr.find("#text").width() / 10),
		iconWidth: $$tr.find("td.s-m-icon").outerWidth()
	};
	$$body.remove();
	_fixedSzInfo[dev] = r;
	return r;
};


/**
 * Return a table cell control
 * Article is calculated from the fieldProto
 */
var _createCellControl = function(arrayCtrl, $$parent, colInfo, fieldProto) {
	var article = {
		"$bind": colInfo.$bind
	};
	return ctrlFactory.createCellFieldCtrl($$parent, arrayCtrl.controller, colInfo.article || colInfo, fieldProto);
};

var _isExcluded = ["application/json", "application/x-array", "application/x-document", "application/x-binary"];
var _ADDROW = "$ADDROW";
// !! $activity same code as page.$activity
var _addRowBtn = {
	$activity: "create",
	$type: "tablet/x-button",
	$icon: "addrow",
	$bind: _ADDROW,
	$text: "grid.addrow.label",
	$action: "rowCreate",
	$capabilities: ["append"]
};
var _additionalCols = [{
	$type: "tablet/x-icon",
	css: ["s-m-icon"],
	$activity: "edit",
	$icon: "editrow",
	$bind: "$EDITROW",
	$action: globals.ACTROWDETAIL
}, {
	$type: "tablet/x-icon",
	css: ["s-m-icon"],
	$activity: "edit",
	$icon: "delrow",
	$bind: "$DELETEROW",
	$action: globals.ACTROWDEL,
	$capabilities: "delete"
}, {
	$type: "tablet/x-icon",
	css: ["s-m-icon"],
	$activity: "read",
	$icon: "detailrow",
	$bind: "$DETAILROW",
	$action: globals.ACTROWDETAIL
}];

var _templates = {
	sortedHeader: '<div><span>{{title}}</span><i class="{{css}}"></i></div>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};
/**
 * x-array control class
 * Array authoring - $article
 * 		$items 				Columns authoring
 * 				$title			Override the title
 * 				$width			Set the width
 * 				$isAdvanced		Not displayed in grid
 */
var _Klass = utils.defineClass(
	function(control, disp, options) {
		Base.call(this, control, disp, options);
		// TODO - Find a more general way
		if (control.controller.state.type === "chartdetail") {
			// No row detail in chart detail
			this.$arrayOptions.showRowDetailLink = false;
		} else if (control.controller.state.type === "rowdetail") {
			// Force in row detail because no authoring
			this.$arrayOptions.showRowDetailLink = true;
		} else if (this.$arrayOptions.showRowDetailLink == null) {
			// False by default in other pages
			this.$arrayOptions.showRowDetailLink = false;
		}
		this._columnInfo = null;
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._columnInfo) {
				this._columnInfo.forEach(function(col) {
					if (col.control) col.control.destroy();
				});
				this._columnInfo = null;
			}
		},
		buildHtml: function(arrayData, buildOpts) {
			buildOpts = buildOpts || {};
			Base.prototype.buildHtml.call(this, arrayData, buildOpts);
			if (this._createColumnInfo(buildOpts).length > 0) {
				if (this.isRefreshContext(buildOpts)) {
					// Force display because there's no resize
					this._build(buildOpts);
				} // Otherwise build is done on resize
			} else {
				this.control.$$value.addClass("empty");
			}
		},
		notifyArrayDataChanged: function(refresh, arrayData, isEmpty) {
			Base.prototype.notifyArrayDataChanged.call(this, refresh, arrayData, isEmpty);
			// Clear cached data here
		},
		onResize: function(context) {
			if (this.isDestroyed()) return;
			// Used by multi-selection - we just want to refresh the scroll
			var scrollOnly = context != null && context.scrollOnly === true;
			if (scrollOnly != true && this._columnInfo && this._columnInfo.length > 0) {
				var buildOpts = {
					updateLayout: context && context.updateLayout
				};
				this._build(buildOpts, context);
			} else {
				Base.prototype.onResize.call(this, context);
			}
		},
		/**
		 * We need to build the table on resize when the table is visible to calculate widths		 *
		 */
		_build: function(buildOpts, resizeContext) {
			if (!this.checkEmptyArray()) {
				return;
			}
			buildOpts = buildOpts || {};
			var self = this;
			var initScroll = buildOpts.refresh === true || resizeContext;
			self.control.$$value.empty();
			var arrayData = self.control.getArrayData();
			if (!arrayData) return;
			var scrollMax = 0;
			var $$table = $('<table class="table table-condensed"/>').appendTo(self.control.$$value);
			self._calulateWidths($$table, arrayData);
			// _buildTableHead build the regular header and return a clone of it
			// To scroll the body we need two tables
			// -> one that displays only the header
			// -> another one that display the body with same header (to preserve columns widths) but this heaedr is hidden
			// $$headerScroll is a clone of the regular header 
			var $$headerScroll = self._buildTableHead($$table, buildOpts);
			if (arrayData.$resources.length > 0 || self.control.controller.isEditMode) {
				var scrollable = this.isScrollable();
				// We create an other table without header to scroll the body
				if (scrollable) {
					$$table = $('<table class="table table-condensed"/>').appendTo(self.control.$$value);
					// We can't hide the header of the row that scrolls - We pu visibility hidden and minimize the height
					// We put an offset of -1 * $$headerScroll.height() to the scrollwrapper to better hide $headerScroll
					$$headerScroll.css({
						fontSize: "0px",
						visibility: "hidden"
					}).appendTo($$table);
					if (self.$$tabHead && self.$$tabHead.length > 0 && $$headerScroll != self.$$tabHead) {
						var top = -1 * $$headerScroll.height();
						$$table.css("top", top + "px");
						self.$$tabHead.css("z-index", 500000);
						if (!globals.isNativeScrolling()) {
							// We need to shift up the scroll in hammerScroll
							scrollMax = top;
						}
					}
				}
				var $$body = $(uiUtils.createDomElement('tbody', null, null, null, $$table));
				var size = _getFixedSizeInfo($$body);
				// Build rows
				for (var i = 0; i < arrayData.$resources.length; i++) {
					self._buildTableRow($$body, arrayData.$resources[i], i, buildOpts);
				}
				self._buildTableFoot($$table, arrayData, buildOpts);
				// Create a scroller -> initialized onResize
				if (scrollable) {
					// WE SCROLL ONLY ARRAYS IN QUERY OR LOOKUP
					// Set gesture manager - disabled - Enabled onResize
					self.newScroller("v", $$table.addClass("s-m-scroll-elmt").wrap('<div class="s-m-scroll-wrapper"/>'), {
						nopadding: true,
						valMax: scrollMax
					});
				} else {

				}
			}
			this.doAfterBuild(resizeContext, true);
		},
		isScrollable: function() {
			return this.control.$type === ctrlFactory.type("arrayChart") || (!this.control.isArrayField() && !this.control.controller.isNestedInDashboard("stack"));
		},
		/**
		 * Caluclate fixed widths according to authoring properties
		 * To improve
		 */
		_calulateWidths: function($$table, arrayData) {
			var self = this;
			var size = _getFixedSizeInfo($$table);
			// We substract the icon (edit/delete/detailRow)
			var maxWidth = self.control.$$value.width() - (self._nbAdditionalCols * size.iconWidth);
			var fixedWidth = 0,
				width;
			// Caluclate fixed width
			self._columnInfo.forEach(function(i) {
				var art = i.article;
				i.fixedWidth = 0;
				if (art && art.$widthType === "fixed" && art.$widthVal > 0) {
					width = (size.charWidth * art.$widthVal) + size.cellPadding;
					if (width > 0 && ((fixedWidth + width) < maxWidth)) {
						i.fixedWidth = width;
						fixedWidth += width;
					}
				}
			});
			var remainingWidth = maxWidth - fixedWidth;
			var percentWidth = 0;
			// Caluclate % widths
			self._columnInfo.forEach(function(i) {
				var art = i.article;
				if (art && art.$widthType === "percent" && art.$widthVal > 0) {
					width = ((art.$widthVal * remainingWidth) / 100) + size.cellPadding;
					if (width > 0 && ((percentWidth + width) < remainingWidth)) {
						i.fixedWidth = width;
						percentWidth += width;
					}
				}
			});
		},
		// get columns that should be displayed
		_createColumnInfo: function(buildOpts) {
			var self = this;
			if (self._columnInfo) return self._columnInfo;
			self._nbAdditionalCols = 0;
			self._columnInfo = [];
			var nonDataCol = 0;
			if (self.$arrayOptions.rowIndex) {
				self._columnInfo.push({
					"$bind": globals.ROWIDXPROP,
					"proto": reqProto.getRowIdxProto(),
					"cssHeader": "s-m-rowidx"
				});
				nonDataCol++;
			}
			this._statusList = this.control.getRowStatusInfo();
			if (this._statusList != null) {
				self._columnInfo.push({
					$bind: "$ROWSTATUS",
					css: "s-m-row-status",
					proto: reqProto.create({
						$type: "tablet/x-row-status"
					})
				});
				nonDataCol++;
			}
			var proto,
				unfound = [],
				col;
			var items = self.$articleArray.$table;
			var protocols = self.control.prototype.arrayTableGetColInfo();
			if (!items) items = protocols;
			items.forEach(function(item, idx) {
				/* #6148 - skip these columns - No possibility to show/hide columns currently*/
				if (item.$isHidden) return;
				item.$widthType = item.$widthType ? item.$widthType : "auto";
				item.$widthVal = parseInt(item.$widthType === "auto" ? 0 : item.$widthVal, 10);
				item.$imgHeight = item.$imgHeight || "small";
				if (isNaN(item.$widthVal)) item.$widthVal = 0;
				proto = self.$itemProto.property(item.$bind);
				if (!proto) {
					unfound.push(item);
					// TODO - Display error
				} else {
					if (!self.isExcluded(item, proto)) {
						col = {
							"$bind": item.$bind,
							"proto": self.$itemProto.create(proto),
							"article": item,
						};
						// Added as class to identify the column by field name - see sortInfoUpdate
						col.css = [self.$itemProto.getFieldNameForValue(item.$bind)];
						if (col.article.$isTitleHidden === true) {
							col.title = "";
						} else if (col.article.$title != null && col.article.$title != item.$bind && col.article.$titleOrig.indexOf('{@') >= 0) { // some translated titles are wrongly in article
							// Authoring save $title with sometimes $bind - we don't display it in the page
							// Title can be overridden bay article - TODO translation
							//col.title = self.$itemProto.resolveExpression(col.article.$title) || "";
							col.title = self.$itemProto.resolveExpression(col.article.$titleOrig || col.article.$title) || "";
						} else {
							col.title = col.proto.data('$title') || "";
						}
						self._columnInfo.push(col);
					}
				}
			});
			var edit = self.control.controller.isEditMode();
			// if we don't display all the columns of the prototype we add the link to the detail of the row
			var overflow = !this.control.prototype.isSingleArray() && ((self._columnInfo.length - nonDataCol) != protocols.length);
			if (this.$arrayOptions.showRowDetailLink === false) {
				// For to not display the icon to display row'w detail
				overflow = false;
			}
			var c;
			_additionalCols.forEach(function(col) {
				if ((edit && col.$activity === "edit") || (!edit && overflow && col.$activity === "read")) {
					if (self.control.checkCapabilities(col.$capabilities)) {
						c = $.extend(true, {}, col);
						c.$widthType = "auto";
						self._columnInfo.push(c);
						self._nbAdditionalCols++;
					}
				}
			});
			if (unfound.length > 0 && globals.getDvlpOpt("showUnfoundFields")) {
				// Add unfound columns
				var html = ['Field(s) not found<ul>'];
				unfound.forEach(function(x) {
					html.push("<li><b>" + x.$bind + "</b></li>");
				});
				html.push("</ul>");
				self.insertError(html.join(''));
			}
			return self._columnInfo;
		},
		getColumnInfo: function() {
			return this._columnInfo;
		},
		isExcluded: function(item, proto) {
			var self = this;
			if (Base.prototype.isExcluded.call(self, proto)) return true;
			return _isExcluded.indexOf(proto.$type) >= 0 || item.$isAdvanced === true;
		},
		_buildTableHead: function($$table, buildOpts) {
			var self = this;
			var $$tabHead = $(uiUtils.createDomElement('thead', null, null, null));
			var tr = uiUtils.createDomElement('tr', null, null, null, $$tabHead);
			var th;
			self._columnInfo.forEach(function(col) {
				th = uiUtils.createDomElement('th', col.cssHeader || col.css, col.title, null, tr);
				if (col.fixedWidth != null && col.fixedWidth > 0) {
					$(th).width(col.fixedWidth);
				}
			});
			var $$headerScroll;
			if (this.control.getAuthoring("$tableHeaderShow") !== false) {
				$$headerScroll = $$tabHead.clone();
				this.$$tabHead = $$tabHead.appendTo($$table);

			} else {
				$$headerScroll = $$tabHead;
			}
			return $$headerScroll;
		},
		_buildTableFoot: function($$table, arrayData, buildOpts) {
			var self = this;
			if (self.control.controller.isEditMode() && this.control.checkCapabilities(_addRowBtn.$capabilities)) {
				//#5529 - we add addRow in any case
				var $$cell = $('<tfoot><tr><td colspan="' + self._columnInfo.length + '"></td></tr></tfoot>').appendTo($$table).find("td");
				var fieldProto = self._getOtherColProto(_addRowBtn, "");
				/**
				 * Build cell html and append it to parent
				 * Control is used only one time
				 */
				var ctrl = _createCellControl(self.control, $$cell, _addRowBtn, fieldProto);
				self.callGenerateHtml(ctrl, $$cell, self.control.controller.getEmptyDao(fieldProto), true, buildOpts);
			}
		},
		_buildTableRow: function($$body, rowData, idx, buildOpts) {
			var self = this;
			var cssRowIdx;
			if (self.$arrayOptions.rowIndex) {
				rowData.setRowIndex(idx + 1);
			}
			var css = [];
			var error = rowData.data.$arrayUpdateError;
			if (error === true) {
				css.push("error");
			}
			if (idx % 2 === 0) {
				css.push("s-m-even");
			}
			var tr = self.buildRecordMainElmt(rowData, {
				tag: "tr",
				parent: $$body,
				css: css
			}, idx);
			var $$cell, fieldProto;
			self._columnInfo.forEach(function(col, idx) {
				// We display the css stored in _columnInfo
				// Used by rowIndex (to apply a style) and columns with icon (to set width)
				$$cell = $(uiUtils.createDomElement('td', col.css || "", null, null, tr));
				fieldProto = col.$activity != null ? self._getOtherColProto(col, rowData.data.$uuid, rowData, buildOpts) : col.proto;
				if (!col.control) {
					// Creates the control used for generating html in cells
					col.control = _createCellControl(self.control, $$cell, col, fieldProto);
				}
				self.callGenerateHtml(col.control, $$cell, rowData, false, buildOpts, idx);
			});
			return tr;
		},
		/**
		 * Returns the proto for button, icons for actions
		 * 		Add new row			array._actRowDetail
		 * 		Detelete row		array._actDelrow
		 * 		Goto row detail		array._actRowDetail
		 * 		Edit row detail		array._actRowDetail
		 * In row detail page we will get a null rowid for creation
		 */
		_getOtherColProto: function(colInfo, rowId, rowData, buildOpts) {
			var self = this;
			// mainArrayCtrl is the array control at the origin of the creation of the table/card
			// When we generate html cards for arrays nested is a parent array the main control is propagated by buildOpts.htmlRootCtrl
			// Otherwise the maincontrol is self.control
			var mainArrayCtrl = buildOpts && buildOpts.htmlRootCtrl ? buildOpts.htmlRootCtrl : self.control;
			var action = colInfo.$action;
			var rowInfo = {
				pathBind: [],
				pathId: [],
				activity: colInfo.$activity
			};
			var create = colInfo.$activity === "create";
			if (create) {
				// CREATE ROW - Build the path to retrieve the row when we click on AddRow
				rowId = utils.UUID();
				rowInfo.pathId.unshift(rowId);
				rowInfo.pathBind.unshift(self.control.$bind);
			} else {
				if (!rowData) throw new Error("unexpected null row data");
				// Build the path of array field and rowsid's and stores it in mainArrayCtrl
				var rd = rowData;
				// EDIT/DETAIL ROW
				rowInfo.pathId.unshift(rowId);
				rowInfo.pathBind.unshift(rd.$bind);
				// Build the path id/bind to access to the resource. We need to store it because the controls/dao/proto are destroyed after creation
				// rd.parent.$bind && rd.parent.$bind.length >0 added to build the bing array working with a protoRow = protoArray.getPrototype("$item"); - sess getArrayData in prototype
				// To test multiple level in display mode pput card display in 'Collection Object' of AQMCRUDM. We see the card with an array inside. If we click on 'rowDetail' icon we've pathBind/pathId.length == 2 
				while (rd.$bind !== mainArrayCtrl.$bind) {
					rowInfo.pathId.unshift(rd.parent.getValue("$uuid"));
					rowInfo.pathBind.unshift(rd.parent.$bind);
					rd = rd.parent;
				}
			}
			// Registers the row info into the main Array control
			// Like html generator destroy the control and dao after generation we need to store the paths (ids and $bind) to retreive row dao and proto
			mainArrayCtrl.rowDetailAdd(rowId, rowInfo);
			var json = {
				$action: {
					"data-action": action
				}
			};
			if (create) {
				// For create we add the parameter in data-params
				json.$action["data-params"] = rowId;
			} else {
				// For other action than create the id of the row is added in the dom elmt of the record - see builderBase.buildRecordMainElmt
				// It allows to not add uuid for each action delete/select/edit...
			}
			// Additional info needed to create the control (button, icon...)
			["$type", "$icon", "$text"].forEach(function(x) {
				if (x != null && x != "$activity") {
					json[x] = colInfo[x];
					if (x === "$text") {
						json[x] = locale.text(json[x]);
					}
				}
			});
			return reqProto.create(json);
		},
		/**
		 * Update icons when sort/filter change
		 */
		filterSortUpdate: function(sortOrder, sortField, hasFilters) {
			Base.prototype.filterSortUpdate.call(this, sortOrder, sortField, hasFilters);
			if (sortOrder && sortField && this.$$tabHead) {
				var $$th = this.$$tabHead.find(".s-m-sorted");
				if ($$th.length > 1) {
					// remove the current - To test because necer occurs as the array is rebuilt on refresh
					var text = $$th.find("div > span")[0].text();
					$$th.removeClass();
				}
				// set the content with sort info
				$$th = this.$$tabHead.find("." + sortField);
				if ($$th.length > 0) {
					var title = $$th.text();
					$$th.html(_getHtml("sortedHeader", {
						title: title,
						css: fontUtils.sortIcon(sortOrder)
					}));
					$$th.addClass("s-m-sorted " + sortOrder);
				}
			};
			this.searchUpdate();
		},
		searchUpdate: function() {
			var $$th, searcher = this.control.getSearcher(),
				self = this;
			if (self.$$tabHead) {
				self.$$tabHead.find(".s-m-search").removeClass("s-m-search");
				if (searcher) {
					searcher.searchInfos.forEach(function(column) {
						$$th = self.$$tabHead.find("." + column.id);
						$$th.addClass("s-m-search ");
					});
				}
			}
		},
		getColumnsInfo: function(onlyVisible) {
			var cols;
			if (!this.control.prototype.isSingleArray() && onlyVisible === true) {
				var ci = this._createColumnInfo();
				if (ci && ci.length > 0) {
					var cols = [];
					ci.forEach(function(c) {
						if (c.$action !== true) {
							cols.push(c.$bind);
						}
					});
				}
			}
			var protoCols = this.control.prototype.arrayTableGetColInfo();
			if (cols == null) {
				return protoCols;
			}
			var res = [];
			protoCols.forEach(function(c) {
				if (cols.indexOf(c.$bind) >= 0) {
					res.push(c);
				}
			});
			return res;
		}
	});

exports.Klass = _Klass;