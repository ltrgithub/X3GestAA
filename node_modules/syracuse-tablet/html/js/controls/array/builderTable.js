"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var builderBase = require('syracuse-tablet/html/js/controls/array/builderBase');
var Base = builderBase.Klass;
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var reqProto = require('syracuse-tablet/html/js/helpers/prototype');;
var daoSdata = require('syracuse-tablet/html/js/application/daoSdata');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var ctrlFactory = require('syracuse-tablet/html/js/controls/ctrlFactory');

var _fixedSzInfo = {};
/**
 * Calculates the sizes for characters, iconCells
 */
var _getFixedSizeInfo = function($$table) {
	var dev = globals.getSiteLayout().getDeviceType();
	var r = _fixedSzInfo[dev];
	if (r) return r;
	var $$body = $('<tbody></body>').appendTo($$table);
	var $$tr = $('<tr class="s-m-record"><td><div class="s-m-control s-m-field"><div class="s-m-value "><span id="text">MMMMMMMMMM</span></div></div></td><td class="s-m-icon"><div class="s-m-control s-m-icon"><a href="#" class="a"><span class="fa fa-hand-o-right"></span></a></div></td></tr>');
	$$tr.appendTo($$body);
	var tdWidth = $$tr.find("td").outerWidth();
	var valWidth = $$tr.find(".s-m-value").outerWidth();
	var textWidth = $$tr.find("#toto").width();
	r = {
		cellPadding: tdWidth - valWidth,
		charWidth: Math.ceil($$tr.find("#text").width() / 10),
		iconWidth: $$tr.find("td.s-m-icon").outerWidth()
	};
	$$body.remove();
	_fixedSzInfo[dev] = r;
	return r;
};


/**
 * Return a table cell control
 * Article is calculated from the fieldProto
 */
var _createCellControl = function(arrayCtrl, $$parent, colInfo, fieldProto) {
	var article = {
		"$bind": colInfo.$bind
	};
	return ctrlFactory.createCellFieldCtrl($$parent, arrayCtrl.controller, colInfo.article || colInfo, fieldProto);
};

var _isExcluded = ["application/json", "application/x-array", "application/x-document", "application/x-binary"];
var _ADDROW = "$ADDROW";
// !! $activity same code as page.$activity
var _addRowBtn = {
	$activity: "create",
	$type: "tablet/x-button",
	$icon: "addrow",
	$bind: _ADDROW,
	$text: "Add row",
	$action: "rowCreate"
};
var _additionalCols = [{
	$type: "tablet/x-icon",
	css: ["s-m-icon"],
	$activity: "edit",
	$icon: "editrow",
	$bind: "$EDITROW",
	$action: globals.ACTROWDETAIL
}, {
	$type: "tablet/x-icon",
	css: ["s-m-icon"],
	$activity: "edit",
	$icon: "delrow",
	$bind: "$DELETEROW",
	$action: globals.ACTROWDEL
}, {
	$type: "tablet/x-icon",
	css: ["s-m-icon"],
	$activity: "read",
	$icon: "detailrow",
	$bind: "$DETAILROW",
	$action: globals.ACTROWDETAIL
}];

var _templates = {
	sortedHeader: '<div><span>{{title}}</span><i class="{{css}}"></i></div>'
};

var _getHtml = function(name, ctx) {
	var key = name + "compiled";
	var tmpl = _templates[key];
	if (!tmpl) {
		tmpl = _templates[key] = Handlebars.compile(_templates[name]);
	}
	return tmpl(ctx);
};
/**
 * x-array control class
 * Array authoring - $article
 * 		$items 				Columns authoring
 * 				$title			Override the title
 * 				$width			Set the width
 * 				$isAdvanced		Not displayed in grid
 */
var _Klass = utils.defineClass(
	function(control, disp, options) {
		Base.call(this, control, disp, options);
		this._columnInfo = null;
	}, Base, {
		destroy: function() {
			Base.prototype.destroy.call(this);
			if (this._columnInfo) {
				this._columnInfo.forEach(function(col) {
					if (col.control) col.control.destroy();
				});
				this._columnInfo = null;
			}
		},
		buildHtml: function(arrayData, options) {
			options = options || {};
			Base.prototype.buildHtml.call(this, arrayData, options);
			if (!this.$article) return;
			if (this._createColumnInfo(options).length > 0) {
				if (options && options.refresh === true) {
					this._build(options);
				} // Otherwise build is done on resize
			} else {
				this.control.$$value.addClass("empty");
			}
		},
		onResize: function(context) {
			// Used by multi-selection - we just want to refresh the scroll
			var scrollOnly = context != null && context.scrollOnly === true;
			if (scrollOnly != true && this._columnInfo && this._columnInfo.length > 0) {
				this._build(null, context);
			} else {
				Base.prototype.onResize.call(this, context);
			}
		},
		/**
		 * We need to build the table on resize when the table is visible to calculate widths		 *
		 */
		_build: function(options, resizeContext) {
			if (!this.control._displayArray()) {
				if (this.control.isEmpty) {
					this.buildEmptyArray();
				}
				return;
			}
			options = options || {};
			var self = this;
			setTimeout(function() {
				var initScroll = options.refresh === true || resizeContext;
				self.control.$$value.empty();
				var arrayData = self.control.getArrayData();
				if (!arrayData) return;
				var $$table = $('<table class="table table-condensed"/>').appendTo(self.control.$$value);
				self._calulateWidths($$table, arrayData);
				// _buildTableHead build the regular header and return a clone of it
				// To scroll the body we need two tables
				// -> one that displays only the header
				// -> another one that display the body with same header (to preserve columns widths) but this heaedr is hidden
				// $$headerScroll is a clone of the regular header 
				var $$headerScroll = self._buildTableHead($$table, options);
				if (arrayData.$resources.length > 0 || self.control.controller.isEditMode) {
					var scrollable = !self.control.isArrayField();
					// We create an other table without header to scroll the body
					if (scrollable) {
						$$table = $('<table class="table table-condensed"/>').appendTo(self.control.$$value);
						var css = {
							fontSize: "0px",
							height: "0px",
							maxHeight: "0px",
							lineHeight: "0px",
							minHeight: "0px"
						};
						// We can't hide the header of the row that scrolls - We pu visibility hidden and minimize the height
						// We put an offset of -1 * $$headerScroll.height() to the scrollwrapper to better hide $headerScroll
						$$headerScroll.css({
							fontSize: "0px",
							visibility: "hidden"
						}).appendTo($$table);
					}
					var $$body = $(uiUtils.createDomElement('tbody', null, null, null, $$table));
					var size = _getFixedSizeInfo($$body);
					// Build rows
					for (var i = 0; i < arrayData.$resources.length; i++) {
						self._buildTableRow($$body, arrayData.$resources[i], i, options);
					}
					self._buildTableFoot($$table, arrayData, options);
					// Create a scroller -> initialized onResize
					if (scrollable) {
						// WE SCROLL ONLY ARRAYS IN QUERY OR LOOKUP
						// Set gesture manager - disabled - Enabled onResize
						var scroller = self.newScroller("v", $$table.wrap('<div class="s-m-scroll-wrapper"/>'), -1 * $$headerScroll.height());
					}
				}
				self.refreshHeaderAndGesture(resizeContext != null && resizeContext.scrollOnly, resizeContext != null && resizeContext.preserveScroll);
			});
		},
		/**
		 * Caluclate fixed widths according to authoring properties
		 * To improve
		 */
		_calulateWidths: function($$table, arrayData) {
			var self = this;
			var size = _getFixedSizeInfo($$table);
			// We substract the icon (edit/delete/detailRow)
			var maxWidth = self.control.$$value.width() - (self._nbAdditionalCols * size.iconWidth);
			var fixedWidth = 0,
				width;
			// Caluclate fixed width
			self._columnInfo.forEach(function(i) {
				var art = i.article;
				i.fixedWidth = 0;
				if (art && art.$widthType === "fixed" && art.$widthVal > 0) {
					width = (size.charWidth * art.$widthVal) + size.cellPadding;
					if (width > 0 && ((fixedWidth + width) < maxWidth)) {
						i.fixedWidth = width;
						fixedWidth += width;
					}
				}
			});
			var remainingWidth = maxWidth - fixedWidth;
			var percentWidth = 0;
			// Caluclate % widths
			self._columnInfo.forEach(function(i) {
				var art = i.article;
				if (art && art.$widthType === "percent" && art.$widthVal > 0) {
					width = ((art.$widthVal * remainingWidth) / 100) + size.cellPadding;
					if (width > 0 && ((percentWidth + width) < remainingWidth)) {
						i.fixedWidth = width;
						percentWidth += width;
					}
				}
			});
		},
		// get columns that should be displayed
		_createColumnInfo: function(options) {
			var self = this;
			if (self._columnInfo) return self._columnInfo;
			self._nbAdditionalCols = 0;
			self._columnInfo = [];
			if (self.displayRowIdx) {
				self._columnInfo.push({
					"$bind": globals.ROWIDXPROP,
					"proto": reqProto.getRowIdxProto(),
					css: "s-m-rowidx"
				});
			}
			var proto, nbCols = 0,
				unfound = [],
				col;
			var items = self.$articleArray.$table;
			if (!items) items = self.control.prototype.arrayTableGetColInfo();
			items.forEach(function(item, idx) {
				item.$widthType = item.$widthType ? item.$widthType : "auto";
				item.$widthVal = parseInt(item.$widthType === "auto" ? 0 : item.$widthVal, 10);
				if (isNaN(item.$widthVal)) item.$widthVal = 0;
				proto = self.$itemProto.property(item.$bind);
				if (!proto) {
					unfound.push(item);
					// TODO - Display error
				} else {
					nbCols++;
					if (!self.isExcluded(item, proto)) {
						col = {
							"$bind": item.$bind,
							"proto": self.$itemProto.create(proto),
							"article": item,
						};
						// Added as class to identify the column by field name - see sortInfoUpdate
						col.css = [self.$itemProto.getFieldNameForValue(item.$bind)];
						if (col.article.$isTitleHidden === true) {
							col.title = "";
						} else if (col.article.$title != null && col.article.$title != item.$bind) {
							// Authoring save $title with sometimes $bind - we don't display it in the page
							// Title can be overridden bay article - TODO translation
							col.title = self.$itemProto.resolveExpression(col.article.$title) || "";
						} else {
							col.title = col.proto.data('$title') || "";
						}
						self._columnInfo.push(col);
					}
				}
			});
			var edit = self.control.controller.isEditMode();
			var overflow = self._columnInfo.length != nbCols,
				c;
			_additionalCols.forEach(function(col) {
				if ((edit && col.$activity === "edit") || (!edit && overflow && col.$activity === "read")) {
					c = $.extend(true, {}, col);
					c.$widthType = "auto";
					self._columnInfo.push(c);
					self._nbAdditionalCols++;
				}
			});
			if (unfound.length > 0 && globals.getDvlpOpt("showUnfoundFields")) {
				// Add unfound columns
				var html = ['Field(s) not found<ul>'];
				unfound.forEach(function(x) {
					html.push("<li><b>" + x.$bind + "</b></li>");
				});
				html.push("</ul>");
				self.insertError(html.join(''));
			}
			return self._columnInfo;
		},
		isExcluded: function(item, proto) {
			var self = this;
			if (Base.prototype.isExcluded.call(self, proto)) return true;
			return _isExcluded.indexOf(proto.$type) >= 0 || item.$isAdvanced === true;
		},
		_buildTableHead: function($$table, options) {
			var self = this;
			var $$tabHead = $(uiUtils.createDomElement('thead', null, null, null));
			var tr = uiUtils.createDomElement('tr', null, null, null, $$tabHead);
			var th, css;
			self._columnInfo.forEach(function(col) {
				th = uiUtils.createDomElement('th', col.css, col.title, null, tr);
				if (col.fixedWidth != null && col.fixedWidth > 0) {
					$(th).width(col.fixedWidth);
				}
			});
			var $$headerScroll;
			if (this.control.getAuthoring("$tableHeaderShow") !== false) {
				$$headerScroll = $$tabHead.clone();
				this.$$tabHead = $$tabHead.appendTo($$table);

			} else {
				$$headerScroll = $$tabHead;
			}
			return $$headerScroll;
		},
		_buildTableFoot: function($$table, arrayData, options) {
			var self = this;
			if (self.control.controller.isEditMode()) {
				//#5529 - we add addRow in any case
				var $$cell = $('<tfoot><tr><td colspan="' + self._columnInfo.length + '"></td></tr></tfoot>').appendTo($$table).find("td");
				var fieldProto = self._getOtherColProto(_addRowBtn, "");
				/**
				 * Build cell html and append it to parent
				 * Control is used only one time
				 */
				var ctrl = _createCellControl(self.control, $$cell, _addRowBtn, fieldProto);
				self.callGenerateHtml(ctrl, $$cell, daoSdata.emptyDao(fieldProto), true, options);
			}
		},
		_buildTableRow: function($$body, rowData, idx, options) {
			var self = this;
			var cssRowIdx;
			if (self.displayRowIdx) {
				rowData.setRowIndex(idx);
			}
			var css = [];
			var rowId = rowData.data.$uuid;
			if (rowId === self.control.controller.lastSelectedRowId) {
				css.push("s-m-selected");
			}
			var error = rowData.data.$arrayUpdateError;
			if (error === true) {
				css.push("error");
			}
			var tr = self.buildRecordMainElmt(rowData, {
				tag: "tr",
				parent: $$body,
				createIfNoLink: true,
				css: css
			}, idx);
			var $$cell, fieldProto;
			self._columnInfo.forEach(function(col, idx) {
				// We display the css stored in _columnInfo
				// Used by rowIndex (to apply a style) and columns with icon (to set width)
				$$cell = $(uiUtils.createDomElement('td', col.css || "", null, null, tr));
				fieldProto = col.$activity != null ? self._getOtherColProto(col, rowId, rowData, options) : col.proto;
				if (!col.control) {
					// Creates the control used for generating html in cells
					col.control = _createCellControl(self.control, $$cell, col, fieldProto);
				}
				self.callGenerateHtml(col.control, $$cell, rowData, false, options, idx);
			});
			return tr;
		},
		/**
		 * Returns the proto for button, icons for actions
		 * 		Add new row			array._actRowDetail
		 * 		Detelete row		array._actDelrow
		 * 		Goto row detail		array._actRowDetail
		 * 		Edit row detail		array._actRowDetail
		 * In row detail page we will get a null rowid for creation
		 */
		_getOtherColProto: function(colInfo, rowId, rowData, options) {
			var self = this;
			// mainArrayCtrl is the array control at the origin of the creation of the table/card
			// When we generate html cards for arrays nested is a parent array the main control is propagated by options.htmlRootCtrl
			// Otherwise the maincontrol is self.control
			var mainArrayCtrl = options && options.htmlRootCtrl ? options.htmlRootCtrl : self.control;
			var action = colInfo.$action;
			var rowInfo = {
				pathBind: [],
				pathId: [],
				activity: colInfo.$activity
			};
			var create = colInfo.$activity === "create";
			if (create) {
				// CREATE ROW - Build the path to retrieve the row when we click on AddRow
				rowId = utils.UUID();
				rowInfo.pathId.unshift(rowId);
				rowInfo.pathBind.unshift(self.control.$bind);
			} else {
				if (!rowData) throw new Error("unexpected null row data");
				// Build the path of array field and rowsid's and stores it in mainArrayCtrl
				var rd = rowData;
				// EDIT/DETAIL ROW
				rowInfo.pathId.unshift(rowId);
				rowInfo.pathBind.unshift(rd.$bind);
				// Build the path id/bind to access to the resource. We need to store it because the controls/dao/proto are destroyed after creation
				// rd.parent.$bind && rd.parent.$bind.length >0 added to build the bing array working with a protoRow = protoArray.getPrototype("$item"); - sess getArrayData in prototype
				// To test multiple level in display mode pput card display in 'Collection Object' of AQMCRUDM. We see the card with an array inside. If we click on 'rowDetail' icon we've pathBind/pathId.length == 2 
				while (rd.$bind !== mainArrayCtrl.$bind) {
					rowInfo.pathId.unshift(rd.parent.getValue("$uuid"));
					rowInfo.pathBind.unshift(rd.parent.$bind);
					rd = rd.parent;
				}
			}
			// Registers the row info into the main Array control
			// Like html generator destroy the control and dao after generation we need to store the paths (ids and $bind) to retreive row dao and proto
			mainArrayCtrl.rowDetailAdd(rowId, rowInfo);
			var json = {
				$action: {
					"data-action": action
				}
			};
			if (create) {
				// For create we add the parameter in data-params
				json.$action["data-params"] = rowId;
			} else {
				// For other action than create the id of the row is added in the dom elmt of the record - see builderBase.buildRecordMainElmt
				// It allows to not add uuid for each action delete/select/edit...
			}
			// Additional info needed to create the control (button, icon...)
			["$type", "$icon", "$text"].forEach(function(x) {
				if (x != null && x != "$activity") json[x] = colInfo[x];
			});
			return reqProto.create(json);
		},
		/**
		 * Update icons when sort/filter change
		 */
		filterSortUpdate: function(sortOrder, sortField, hasFilters) {
			Base.prototype.filterSortUpdate.call(this, sortOrder, sortField, hasFilters);
			if (sortOrder && sortField && this.$$tabHead) {
				var $$th = this.$$tabHead.find(".s-m-sorted");
				if ($$th.length > 1) {
					// remove the current - To test because necer occurs as the array is rebuilt on refresh
					var text = $$th.find("div > span")[0].text();
					$$th.removeClass();
				}
				// set the content with sort info
				$$th = this.$$tabHead.find("." + sortField);
				if ($$th.length > 0) {
					var title = $$th.text();
					$$th.html(_getHtml("sortedHeader", {
						title: title,
						css: fontUtils.sortIcon(sortOrder)
					}));
					$$th.addClass("s-m-sorted " + sortOrder);
				}
			}
		}
	});

exports.Klass = _Klass;