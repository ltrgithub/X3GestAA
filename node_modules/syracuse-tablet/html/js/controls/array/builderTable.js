"use strict";

var Base = require('syracuse-tablet/html/js/controls/array/builderBase').BuilderBase;
var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var environment = require('syracuse-tablet/html/js/helpers/environment');
var settings = require('syracuse-tablet/html/js/app/settings');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');


var _isExcluded = ["application/json", "application/x-array", "application/x-document", "application/x-binary"];

var _fixedSzInfo = {};
/**
 * Calculates the sizes for characters, iconCells
 */
var _getFixedSizeInfo = function($$table) {
	var dev = settings.getDeviceType();
	var r = _fixedSzInfo[dev];
	if (r) return r;
	var $$body = $('<tbody></body>').appendTo($$table);
	var $$tr = $('<tr class="s-m-record"><td><div class="s-m-control s-m-field" style="width:100%"><div class="s-m-value" style="width:100%" ><span style="width:100%" id="text">MMMMMMMMMM</span></div></div></td><td class="s-m-icon"><div class="s-m-control s-m-icon"><a href="#" class="a"><span class="fa fa-hand-o-right"></span></a></div></td></tr>');
	$$tr.appendTo($$body);
	var tdWidth = $$tr.find("td").outerWidth();
	var valWidth = $$tr.find(".s-m-value").outerWidth();
	var textWidth = $$tr.find("#toto").width();
	r = {
		cellPadding: tdWidth - valWidth,
		charWidth: Math.ceil($$tr.find("#text").width() / 10),
		iconWidth: $$tr.find("td.s-m-icon").outerWidth()
	};
	$$body.remove();
	_fixedSzInfo[dev] = r;
	return r;
};

var _additionalCols = [{
	isProtoItem: false,
	$activity: "edit",
	$bind: "rowEdit",
	$widthType: "auto",
	css: ["s-m-icon"]
}, {
	isProtoItem: false,
	$activity: "edit",
	$bind: "rowDelete",
	$capabilities: "delete",
	$widthType: "auto",
	css: ["s-m-icon"]
}, {
	isProtoItem: false,
	$activity: "read",
	$bind: "rowDetail",
	$widthType: "auto",
	css: ["s-m-icon"]
}];

exports.BuilderTable = utils.defineClass(
	function builderTable(control) {
		Base.call(this, control);
		this._nbAdditionalCols = 0;
		this._tableColumnInfo = null;
	}, Base, {

		destroy: function() {
			Base.prototype.destroy.call(this);
			this._$$body = null;
		},

		buildHtml: function(data, $$parent, refresh) {
			Base.prototype.buildHtml.call(this, data, $$parent, refresh);
			this._createTableColumnInfo();
			if (this._tableColumnInfo && this._tableColumnInfo.length === 0) {
				$$parent.addClass("empty");
			}
			if (refresh === true) {
				// Build the real content only in that case because parent's size is ok
				// Otherwise buildOnResize is called on computeLayout
				this.buildOnResize(data, $$parent, {
					refresh: true
				});
			}
		},

		buildOnResize: function(data, $$parent, context) {
			if (this.destroyed) {
				return;
			}
			var forceEmpty = this._tableColumnInfo == null || this._tableColumnInfo.length === 0;
			if (!this.checkEmptyArray(forceEmpty) && !this.control.controller.isEditMode()) {
				return;
			}
			this._buildTable(data, $$parent, context);
		},

		_buildTable: function(data, $$parent, context) {
			$$parent.empty();
			var scrollMax = 0;
			var $$table = $(uiUtils.createDomElement("table", ["table", "table-condensed"], null, {
				"data-controller-id": this.control.arrayController.id
			}, $$parent));
			this._calulateWidths($$parent, $$table, data);
			var $$headerScroll = this._buildTableHead($$table);
			if (data.length === 0 && !this.control.controller.isEditMode()) {
				this.doAfterBuild();
				return;
			}
			if ($$headerScroll != null && this.isScrollable()) {
				// We create an other table without header to scroll the body
				$$table = $('<table class="table table-condensed"/>').appendTo($$parent);
				// We can't hide the header of the row that scrolls - We put visibility hidden and minimize the height
				// We put an offset of -1 * $$headerScroll.height() to the scrollwrapper to better hide $headerScroll
				$$headerScroll.css({
					fontSize: "0px",
					visibility: "hidden"
				}).appendTo($$table);
				if (this.$$tabHead && this.$$tabHead.length > 0 && $$headerScroll != this.$$tabHead) {
					var top = -1 * $$headerScroll.height() / this.control.getTransformScale();
					$$table.css("top", top + "px");
					this.$$tabHead.css("z-index", 500000);
					if (!environment.isNativeScrolling()) {
						// We need to shift up the scroll in hammerScroll
						scrollMax = top;
					}
				}
			}
			this._$$body = $(uiUtils.createDomElement('tbody', null, null, null, $$table));

			for (var i = 0; i < data.length; i++) {
				this._buildTableRow(data[i], i);
			}

			this._buildTableFooter($$table);

			if (this.isScrollable()) {
				this.newScroller("v", $$table.addClass("s-m-scroll-elmt").wrap('<div class="s-m-scroll-wrapper"/>'), {
					nopadding: true,
					valMax: scrollMax
				});
			}
			this.doAfterBuild();
		},

		_buildTableFooter: function($$table) {
			var nbCols = this._tableColumnInfo.length;
			if (nbCols > 0 && this.control.controller.isEditMode() && this.control.prototype.hasCapability("append")) {
				var $$footer = $('<tfoot><tr><td colspan="' + nbCols + '"><div style= "text-align:center;" class="s-m-control s-m-icon"><a href="#" data-nevent data-naction="addRow" data-params="" class="a"><span class="' + fontUtils.tableActionIcon("rowAdd") + '"></span></a></div></td></tr></tfoot>');
				$$footer.appendTo($$table);
			}
		},

		/** _buildTableHead build the regular header and return a clone of it
		 * To scroll the body we need two tables
		 * -> one that displays only the header
		 * -> another one that display the body with same header (to preserve columns widths) but this header is hidden
		 * $$headerScroll is a clone of the regular header 
		 */
		_buildTableHead: function($$table) {
			this.$$tabHead = $(uiUtils.createDomElement('thead', null, null, null));
			var tr = uiUtils.createDomElement('tr', null, null, null, this.$$tabHead);
			this._tableColumnInfo.forEach(function(col) {
				var th = uiUtils.createDomElement('th', col.cssHeader || col.css, col.title || "", null, tr);
				if (col.fixedWidth != null && col.fixedWidth > 0) {
					$(th).width(col.fixedWidth);
				}
			});
			var showHeader = this.control.getAuthoring("$tableHeaderShow") !== false;
			if (showHeader != true || this.control.isSingleArray()) {
				// Displayed header to get the right column with in edit mode
				this.$$tabHead.appendTo($$table)
					// Don't show it but (thead is applied) - !!No display:none
				this.$$tabHead.css("visibility", "hidden");
				return null;
			}
			// Cloned before appending to $$table
			var $$headerScroll = this.$$tabHead.clone();
			// Displayed header
			this.$$tabHead.appendTo($$table);
			if (this.control.filterSort) {
				this.control.filterSort.tableHeadUpdate(this.$$tabHead);
			}
			if (this.control.filterSearch) {
				this.control.filterSearch.tableHeadUpdate(this.$$tabHead);
			}
			// header use to scroll the array (needs to be the same as this.$$tabHead to have columns aligned)
			return $$headerScroll;
		},

		_buildTableRow: function(recordDataset, index) {
			var rowCtrl = this.control.createRecordCtrl(this._$$body, recordDataset, index);
			if (rowCtrl) {
				rowCtrl.buildHtml(this._tableColumnInfo);
				if (environment.isAutoUITestMode()) {
					environment.getUnitTestMgr().arrayAddRowIndex(rowCtrl.$$elmt, index);
				}
			}
			return rowCtrl;
		},

		appendRow: function(rowDataset) {
			var index = this.control.arrayController.dataset.getRowIndex(rowDataset.json.$uuid);
			return this._buildTableRow(rowDataset, index);
		},

		_calulateWidths: function($$parent, $$table, data) {
			var size = _getFixedSizeInfo($$table);
			// We substract the icon (edit/delete/detailRow)
			var maxWidth = $$parent.width() - (this._nbAdditionalCols * size.iconWidth);
			var fixedWidth = 0;
			var width;
			// Calculate fixed width
			this._tableColumnInfo.forEach(function(i) {
				var art = i.article;
				i.fixedWidth = 0;
				if (art && art.$widthType === "fixed" && art.$widthVal > 0) {
					width = (size.charWidth * art.$widthVal) + size.cellPadding;
					if (width > 0 && ((fixedWidth + width) < maxWidth)) {
						i.fixedWidth = width;
						fixedWidth += width;
					}
				}
			});
			var remainingWidth = maxWidth - fixedWidth;
			var percentWidth = 0;
			// Caluclate % widths
			this._tableColumnInfo.forEach(function(i) {
				var art = i.article;
				if (art && art.$widthType === "percent" && art.$widthVal > 0) {
					width = ((art.$widthVal * remainingWidth) / 100) + size.cellPadding;
					if (width > 0 && ((percentWidth + width) < remainingWidth)) {
						i.fixedWidth = width;
						percentWidth += width;
					}
				}
			});
		},

		isExcluded: function(item, proto) {
			if (Base.prototype.isExcluded.call(this, proto)) return true;
			return _isExcluded.indexOf(proto.json.$type) >= 0 || item.$isAdvanced === true;
		},

		// get columns that should be displayed
		_createTableColumnInfo: function() {
			if (this._tableColumnInfo) {
				return this._tableColumnInfo;
			}
			this._nbAdditionalCols = 0;
			this._tableColumnInfo = [];
			var nonDataCol = 0;
			if (this.article.$arrayOptions.rowIndex === true) {
				this._tableColumnInfo.push({
					"isProtoItem": false,
					"$bind": "rowIndex",
					"cssHeader": "s-m-rowidx"
				});
				nonDataCol++;
			}
			var statusInfo = this.control.getRowStatusInfo();
			if (statusInfo != null) {
				this._tableColumnInfo.push({
					"isProtoItem": false,
					"$bind": "rowStatus",
					"statusInfo": statusInfo,
					"cssHeader": "s-m-row-status"
				});
				nonDataCol++;
			}
			var unfound = [];
			var items = this.article.$table;
			var protoColumns = this.control.getColumnsInfo(true);
			if (!items) {
				items = protoColumns;
			}
			var self = this;
			var dataProps = this.controller.dataset.getValueByPath("$properties");
			items.forEach(function(item, idx) {
				if (item.$isHidden || (dataProps && dataProps[item.$bind] && dataProps[item.$bind].$isHidden == true)) {
					return;
				}
				item.$widthType = item.$widthType ? item.$widthType : "auto";
				item.$widthVal = parseInt(item.$widthType === "auto" ? 0 : item.$widthVal, 10);
				item.$imgHeight = item.$imgHeight || "small";
				if (isNaN(item.$widthVal)) {
					item.$widthVal = 0;
				}
				var proto = self.$itemProto.propGetProto(item.$bind);
				if (!proto) {
					unfound.push(item);
				} else if (!self.isExcluded(item, proto)) {
					var col = {
						"$bind": item.$bind,
						"proto": proto,
						"article": item
					};
					// Added as class to identify the column by field name - see sortInfoUpdate
					col.css = [self.$itemProto.getFieldValueName(item.$bind)];
					if (col.article.$isTitleHidden === true) {
						col.title = "";
					} else if (col.article.$title != null && col.article.$title != item.$bind && (col.article.$titleOrig == null || col.article.$titleOrig.indexOf('{@') >= 0)) {
						// some translated titles are wrongly in article
						// Authoring save $title with sometimes $bind - we don't display it in the page
						// Title can be overridden by article - TODO translation
						col.title = self.$itemProto.resolveExpression(col.article.$titleOrig || col.article.$title) || "";
					} else {
						col.title = col.proto.data('$title') || "";
					}
					col.isProtoItem = true;
					self._tableColumnInfo.push(col);
				}
			});
			// if we don't display all the columns of the prototype we add the link to the detail of the row
			var overflow = (this._tableColumnInfo.length - nonDataCol) != protoColumns.length;
			if (this.article.$arrayOptions.showRowDetailLink === false) {
				// To not display the icon to display row'w detail
				overflow = false;
			}
			var editMode = this.controller.isEditMode();
			_additionalCols.forEach(function(col) {
				if (editMode && self.control.isSingleArray() && col.$bind === "rowEdit") {
					// Single arrays accept edit mode in the grid
					return
				}
				if ((editMode && col.$activity === "edit") || (!editMode && overflow && col.$activity === "read")) {
					if (col.$capabilities == null || self.prototype.hasCapability(col.$capabilities)) {
						var c = $.extend(true, {}, col);
						c.$widthType = "auto";
						self._tableColumnInfo.push(c);
						self._nbAdditionalCols++;
					}
				}
			});
			if (unfound.length > 0 && jsutils.isDvlpVersion("showUnfoundFields")) {
				var html = ['Field(s) not found<ul>'];
				unfound.forEach(function(x) {
					html.push("<li><b>" + x.$bind + "</b></li>");
				});
				html.push("</ul>");
				this.insertError(html.join(''));
			}
			return this._tableColumnInfo;
		},

		isScrollable: function() {
			return this.control.isArrayChart() || (!this.control.isArrayField() && !this.control.page.isNestedInDashboard("stack"));
		},
		getLastSelectedRowId: function() {
			return this.control.$$content.find(".s-m-last-selected").attr("id");
		},
		setLastSelectedRowId: function(selectedRowUuid) {
			this.control.$$content.find('#' + selectedRowUuid).addClass("s-m-last-selected");
		},
		updateRowIndex: function($$parent, index) {
			$$parent.find(".s-m-control.s-m-row-index > .badge").text(index);
		}
	});