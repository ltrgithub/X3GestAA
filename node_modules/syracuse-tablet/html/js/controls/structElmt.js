"use strict";

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

/**
 * Base class for controls and layouts
 *
 * controller: page (or child controller)
 * 		must implements addControl Method
 *
 */
var _Klass = utils.defineClass(
	function StructElmt(controller, $type, article, options) {
		this.options = options || {};
		this.controller = controller;
		this.$type = $type;
		this.typeName = utils.getTypeName($type);
		this.article = article || {};
		this.children = null;
		this.parent = null;
		this._dao = null;
		this.initReuseProperties();
		this.destroyed = false;
		/* It's the responsibility of each structElmt to set isEmpty = true */
		this.isEmpty = false;
	}, null, {
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			this.$$elmt = null;
			this.id = this.createId(this.typeName);
		},
		destroy: function() {
			// First destroy the children before removing $$elmt
			if (this.children) {
				this.children.forEach(function(child) {
					if (child) child.destroy();
				});
				this.children = null;
			}
			if (this._htmlGeneratorContexts) {
				this.destroyHtmlGeneratorContexts();
			}
			notifications.unsubscribe(this);
			if (this.$$elmt) {
				this.$$elmt.unbind();
				this.$$elmt.remove();
				this.$$elmt = null;
			}
			this.controller = null;
			this._dao = null;
			this.parent = null;
			// Used to prevent error in asynchronous processes
			this.destroyed = true;
		},
		isRoot: function() {
			return this.parent == null || this.parent === this.controller;
		},
		/**
		 * Generate html
		 * Use the same control buildHtml multiple html with different id's
		 * It's used by cards to build the tree structure for a card and reuse it for all the cards instead of creating a new tree structure for each card
		 * Same as buildHtml but:
		 * 		calls initReuseProperties to reset ID and properties used by previous build (cache, dom elmts...)
		 * !! It's the responsibility of the caller to destroy or not the control after having set $$elmt to null
		 * Returns $$elmt
		 */
		generateHtml: function($$parent, controllerDao, htmlRootCtrl, updateLayout) {
			var opts = this.options;
			this.isEmpty = false;
			if (htmlRootCtrl) {
				opts.htmlRootCtrl = htmlRootCtrl;
			}
			opts.isHtmlGenerator = true;
			opts.updateLayout = updateLayout === true;
			/**
			 * !! When we build html of a rootLayout with isHtmlGenerator = true we call afterRender (recursively) after having called buildHtml to apply meta-data
			 * It's done in LayoutBase buildChildrenHtml
			 */
			this.buildHtml($$parent, controllerDao, opts);
			if (this.afterRender) {
				// Call afterRender on current element - afterRender is called by LayoutBase.buildChildrenHtml for children if any
				this.afterRender(opts);
			}
			return this.$$elmt;
		},
		applyMetaData: function(metaData, buildOptions) {
			// Nothing by default - used by controls
		},
		getDao: function() {
			if (this.destroyed) return null;
			if (this._dao && !this._dao.isValid()) {
				// Trick - Like we store the dao we don't know if it's still valid - It'd be better to not store the dao but not easy for arrays
				this._dao = null;
			}
			return this._dao ? this._dao : this.controller ? this.controller.dao : null;
		},
		/**
		 * Build html for a control/layout
		 * !! CHILD CLASSES BUILDHTML METHOD MUST CALL THIS METHOD BEFORE PROCESSING
		 */
		buildHtml: function($$parent, controllerDao, buildOptions) {
			/**
			 * We need to store the dao to build cards - dao is the data row which is different from controller.dao
			 * It's better to store it for asynchronous calls
			 */
			this._dao = controllerDao;
			this.isEmpty = false;
			if (buildOptions && buildOptions.isHtmlGenerator === true) {
				if (this._needReuse) {
					this.initReuseProperties();
				} else {
					// First call don't call _initReuse
					this._needReuse = true;
				}
			}
		},
		/**
		 * Only for controls by method is need for all structElmts
		 */
		getMetaData: function(metaProp) {
			return null;
		},
		/**
		 * Returns field/layout authoring
		 * path: string with or without '.' separator or array of string
		 */
		getAuthoring: function(path, defValue) {
			var val = utils.getPropByPath(this.article, path);
			return val != null ? val : defValue;
		},
		/**
		 * Appends style authoring to classArray
		 * It's a draft just to start dealing with authoring
		 * classArray: 	array of classes used by createDomElement
		 * pathOrData: 	string or array of string that points points to an authoring value
		 * 				JS plain object that is the authoring object
		 */
		appendStyleAuthoring: function(classArray, pathOrData) {
			classArray = classArray || [];
			if (!pathOrData) return classArray;
			if ($.isPlainObject(pathOrData)) {
				// pathOrData is the authoring object
				var data = pathOrData;
			} else {
				// pathOrData points to an authoring value
				var data = this.getAuthoring(pathOrData);
			}
			if (!data) return classArray;
			// Apply style classes - To improve/enhance
			for (var p in data) {
				if (["$theme", "$fontStyle", "$fontSize"].indexOf(p) >= 0) {
					classArray.push(data[p]);
				}
			}
			return classArray;
		},
		/**
		 * Empty current element
		 * 	Called before a refresh
		 *  Keep control objects
		 */
		empty: function() {
			if (this.children) {
				this.children.forEach(function(child) {
					if (child) child.empty();
				});
			}
			if (this.$$elmt) {
				this.$$elmt.empty();
			}
		},
		isLayout: function() {
			return false;
		},
		isVignette: function() {
			return false;
		},
		isControl: function() {
			return false;
		},
		createId: function(typeName) {
			return utils.readableuid(typeName);
		},
		/**
		 * Append structElmt c as a child of this
		 */
		appendStructElmt: function(c) {
			if (!c) return;
			if (!this.children) this.children = [];
			c.parent = this;
			this.children.push(c);
		},

		getNbChilds: function() {
			return this.children && this.children.length > 0;
		},
		/**
		 * Create the root element of the control/layout/vignette
		 * 	This element is identified by this.id
		 */
		createRootElement: function(css, $$parent) {
			// No id for generated html
			var e = this.setRootElement(uiUtils.createDomElement("div", css, null, this.options.isHtmlGenerator === true ? null : {
				"id": this.id
			}), $$parent);
			return e;
		},
		setRootElement: function(e, $$parent) {
			if (!e) {
				return null;
			}
			if (!e.jquery) {
				e = $(e);
			}
			this.$$elmt = e;
			if ($$parent) {
				if (!$$parent.jquery) {
					$$parent = $($$parent);
				}
				e.appendTo($$parent);
			}
			return e;
		},
		isVisible: function() {
			return this.$$elmt && this.$$elmt.is(":visible");
		},
		isHidden: function() {
			return !this.isVisible();
		},
		show: function() {
			if (this.$$elmt) this.$$elmt.show();
		},
		hide: function() {
			if (this.$$elmt) this.$$elmt.hide();
		},
		/**
		 * Set the focus on this field and scroll
		 */
		setFocus: function() {

		},
		/*
		 * Must return the article of this control/layout node
		 * The article must only contain static authoring.
		 * Dynamic settings that are added by payload must not be part of the returned data structure
		 * since this structure will be used to create the article tree for the page and will
		 * be stored on the server!
		 */
		getArticle: function() {
			return this.article;
		},

		/*
		 * Called by authoring if a control or layout is removed by the user
		 */
		removeChild: function(structElmt) {
			var _children = [];
			this.children.forEach(function(child) {
				if (child && child.id === structElmt.id) {
					child.destroy();
				} else {
					_children.push(child);
				}
			});
			this.children = _children;
		},
		/*
		 * Called by authoring if a control or layout is removed by the user
		 */
		removeChildren: function() {
			this.children && this.children.forEach(function(child) {
				child.destroy();
			});
			this.children = [];
		},
		getIndexOfChild: function(child) {
			var idx = -1;
			this.children && this.children.some(function(c) {
				idx = idx + 1;
				if (c === child) {
					return true;
				}
				return false;
			});
			return idx;
		},
		getChildByIndex: function(idx) {
			return this.children && this.children[idx];
		},

		/*
		 * Add new child before nextChild
		 * If nextChild is null, it's added at the end of the container
		 */
		addChildBefore: function(ctrl, nextChild) {
			var added = false;
			var _children = [];
			this.children && this.children.forEach(function(c) {
				if (nextChild && (c.id === nextChild.id)) {
					_children.push(ctrl);
					added = true;
				}
				if (c.id !== ctrl.id) {
					_children.push(c);
				}
			});

			if (!added) {
				_children.push(ctrl);
			}
			this.children = _children;
		},

		/*
		 * Removes reference to child without destorying the child!
		 */
		removeChildRef: function(c) {
			var _children = [];
			this.children && this.children.forEach(function(child) {
				if (child.id !== c.id) {
					_children.push(child);
				}
			});
			this.children = _children;
		},

		/*
		 * Start by this node and go up the layout tree storing all the indexes of the current not in the parent container
		 */
		getPathInTree: function() {
			var ctrl = this;
			var parent;
			var path = [];
			parent = this.parent;

			// The intention of this function is to stop at root level, not at the first controller found
			// The first controller might be the vignette containing the control, but we want to get the page/dashboard
			// containing the full screen not only a single vignette
			//while (parent && parent != this.controller) {
			while (parent) {
				var idx;
				if (jsutils.isInstanceOf(parent, "Page")) {
					if (parent.isVignette) {
						var vgnt = parent.getParentVignette();
						idx = 0;
						parent = vgnt.parent;
					} else { // We reached the root page -> done
						break;
					}
				} else {
					idx = parent.getIndexOfChild(ctrl);
				}
				path.push(idx);
				ctrl = parent;
				parent = parent.parent;
			}
			path.reverse();
			return path;
		},

		/*
		 * Resolve the path generated by getPathInTree to find the children again
		 */
		findChildByPath: function(path) {
			if (!path) {
				return;
			}

			var node = this;
			path.some(function(idx) {
				if (jsutils.isInstanceOf(node, "VignetteBase")) {
					if (node.getPage()) {
						node = node.getPage().rootLayout;
					} else {
						node = null;
						return true;
					}
				}
				node = node.getChildByIndex(+idx);
			});
			return node;
		},

		/*
		 * Returns the article used for authoring of this element
		 * Note that sub level informations usually nested in $items MUST NOT be returned here
		 */
		getAuthArticle: function() {
			var authArticle = {};
			var nodeArticle = this.getArticle();
			Object.keys(nodeArticle).forEach(function(key) {
				if (key !== "$items") {
					authArticle[key] = nodeArticle[key];
				}
			});
			return authArticle;
		},

		getAuthState: function(dirtyKeys) {
			return null;
		},
		setAuthState: function(state) {

		},
		getArticleText: function(property) {
			if (!this.article[property]) {
				return "";
			}
			var self = this;
			var text = self.article[property] && self.article[property].replace(/\{\@(\S+)\}/g, function(m, g) {
				var localization = self.options.$localization;
				if (self.isVignette && !localization) {
					localization = utils.getArticleLocalization(utils.getCurrentPage().article);
				}
				return (localization && localization[g]) ||
					(localization && localization.$fallback && localization.$fallback[g]) ||
					(m);
			});
			if (text && this.article[property] === text) {
				text = this.controller.prototype.resolveExpression(text, null, true);
			};
			return text || "";
		},
		/**
		 * Stores all objects created by html generator which need to be destroyed
		 * ctx.handler 	= the ctx.handler called to destoy data
		 * ctx.data		= data to destroy
		 * When we generate HTML from a tree structure we pass the htmlRootCtrl in build options (see this.generate html)
		 * 	Example for customer addresses we generate multiple cards (which contains carousel) with the same tree structure
		 * All the controls generated can store a context in htmlRootCtrl to be destroyed with htmlRootCtrl
		 * Example for carousel generated inside a card (customer addresses)
		 * 	Carousel uses carousel plugin and eventually a slider
		 * 	We need to destroy them when we destroy htmlRootCtrl (the card's array)
		 */
		addHtmlGeneratorContext: function(ctx) {
			if (!ctx) return;
			if (!this._htmlGeneratorContexts) {
				this._htmlGeneratorContexts = [];
			}
			this._htmlGeneratorContexts.push(ctx);
		},
		/**
		 * Destroy all contexts created by htmt generator
		 */
		destroyHtmlGeneratorContexts: function() {
			if (!this._htmlGeneratorContexts) return;
			this._htmlGeneratorContexts.forEach(function(ctx) {
				if (ctx.handler && ctx.data) {
					ctx.handler(ctx.data);
				}
			});
			this._htmlGeneratorContexts = null;
		},
		/**
		 * Used by unit test entities to display info
		 */
		getUnitTestMsg: function() {
			return this.article && this.article.$unitTest ? this.article.$unitTest.message : null;
		},
		displayUnitTestMsg: function($$parent) {
			if (!this.controller.isUnitTest || !$$parent) return;
			var msg = this.getUnitTestMsg();
			if (!msg) return;
			$$parent.find(".s-m-unitest-msg").remove();
			$('<div class="s-m-unitest-msg"/>').text(msg).appendTo($$parent);
		}
	}
);

exports.Klass = _Klass;