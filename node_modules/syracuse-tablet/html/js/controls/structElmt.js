"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');

var _typeNames = {};
var _regExp = /-|\//g;
/**
 * Bas element for controls and layouts controller: page (or child controller)
 * Implements addControl Method
 */
var _Klass = utils
	.defineClass(
		function(controller, type, article) {
			var self = this;
			self.controller = controller;
			self.typeName = _typeNames[type];
			if (!self.typeName) {
				// used to generate readable ids - type expected
				// "application/x-name" or "text/plain"
				var a = type.split(_regExp);
				self.typeName = _typeNames[type] = a[a.length - 1];
			}
			self.article = article || {};
			self.id = self.createId(self.typeName);
			/* Render method sets $$elmt */
			self.$elmt = null;
			self.children = null;
			self.parent = null;
			if (!self.controller.addControl)
				throw new Error(
					"Controller must implement addControl method");
			self.controller.addControl(self);
			self.templates = globals.getTemplates();
		},
		null, {
			destroy: function() {
				var self = this;
				self.controller = null;
				self.parent = null;
				utils.unbindObj(self.$elmt);
				utils.unbindObj(self);
			},
			isLayout: function() {
				return this.typeName === "layout";
			},
			isVignette: function() {
				return this.typeName === "vignette";
			},
			isControl: function() {
				return this.isLayout() && !this.isVignette();
			},
			createId: function(typeName) {
				return utils.readableuid(typeName);
			},
			appendChild: function(c) {
				var self = this;
				if (!c)
					return;
				if (!self.children)
					self.children = [];
				c.parent = self;
				self.children.push(c);
			},
			isRoot: function() {
				return this.controller === this.parent || this.parent == null;
			},
			xbuildHtml: function(html, data) {
				// used to set values in the template.
				var context = {};

				context.id = this.id;
				context.$layoutType = this.article.$layoutType;
				context.isTabLayout = this.isTabLayout = this.article.$layoutType === "tabs";
				if (this.isTabLayout) {
					context.navListItem = [];

					for (var ii = 0, jj = this.children.length; ii < jj; ii++) {
						context.navListItem.push({
							active: ii == 0 ? true : false,
							$title: this.children[ii].article.$title
						});
					}
				} else {
					context.$title = !this.isTabSection ? this.article.$title : "";
				}

				// set cells/columns widths for row layout type
				if (this.article.$layoutType == "row") {
					this.isRowLayout = true;

					// TODO To improve. If no value specified, set to 12
					// by default ??
					if (!this.article.$widthMd && !this.article.$widthSm && !this.article.$widthXs && !this.article.$widthLd) {
						throw new Error("Columns widths not specified");
					}

					// only desktop ($widthMd) is handled for test
					// purpose
					var $widthMd = this.article.$widthMd.split(",");

				}

				// if (this.children.length == 1) {
				// context.hasOneChild = true;
				// context.childHTML = this.children[0].buildHtml(html,
				// data);
				// } else {
				// build childItem context
				context.coreItem = [];
				for (var ii = 0, jj = this.children.length; ii < jj; ii++) {
					// set isTabsection property value to true for
					// children item
					if (this.isTabLayout) {
						this.children[ii].isTabSection = true;
					}

					context.coreItem.push({
						$layoutType: this.article.$layoutType,
						isRowLayout: this.isRowLayout,
						$widthMd: $widthMd && $widthMd[ii],
						display: !(this.isTabLayout && ii != 0),
						coreItemContent: this.children[ii].buildHtml(
							html, data)
					});
				}
				// }
				html.push(this.templates
					.execSync("tmplLayout", context));
				return html;
			},
			buildHtml: function(html, data) {
				var self = this;
				self.buildHtmlBefore(html, data);
				if (self.children) {
					self.children.forEach(function(child, idx) {
						self.buildHtmlBeforeChild(html, data, child,
							idx);
						child.buildHtml(html, data);
						self
							.buildHtmlAfterChild(html, data, child,
								idx);
					});
				}
				self.buildHtmlAfter(html, data);
				return html;
			},
			/**
			 * Control can override this methods
			 */
			buildHtmlBeforeChild: function(html, data, child, idx) {},
			/**
			 * Control can override this methods
			 */
			buildHtmlAfterChild: function(html, data, child, idx) {},
			/**
			 * Control can override this methods
			 */
			buildHtmlBefore: function(html, data) {
				var self = this;
				html
					.push('<div style="color:white; border:1px solid red; padding: 5px;" id="');
				html.push(self.id);
				html.push('">');
				html.push('<h1>' + self.typeName + '</h1><p>' + self.id + '</p>');
				return html;
			},
			/**
			 * Control can override this methods
			 */
			buildHtmlAfter: function(html, data) {
				var self = this;
				html.push('</div>');
				return html;
			},
			/**
			 * Called for each control after buildHtml in
			 * page.afterRender method
			 */
			render: function($elmt) {
				// log && log ("render " + this.id)
				this.$elmt = $elmt;
			}
		});

exports.Klass = _Klass;