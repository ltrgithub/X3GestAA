"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("ctrls", false);

var _typeNames = {};
var _regExp = /-|\//g;

/**
 * Base class for controls and layouts
 *
 * controller: page (or child controller)
 * 		must implements addControl Method
 *
 */
var _Klass = utils.defineClass(
	function StructElmt(controller, $type, article, options) {
		var self = this;
		self.options = options || {};
		self.controller = controller;
		self.$type = $type;
		self.typeName = _typeNames[$type];
		if (!self.typeName) {
			// used to generate readable ids - type expected "application/x-name" or "text/plain"
			var a = $type.split(_regExp);
			self.typeName = _typeNames[$type] = a[a.length - 1];
		}
		self.article = article || {};
		self.children = null;
		self.parent = null;
		self.initReuseProperties();
	}, null, {
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			this.$$elmt = null;
			this.id = this.createId(this.typeName);
		},
		destroy: function() {
			this.controller = null;
			this.parent = null;
			if (this._gestures) {
				this._gestures.destroy();
				this._gestures = null;
			}
			utils.unbindObj(this.$$elmt);
			utils.unbindObj(this);
			if (this.children) {
				this.children.forEach(function(child) {
					if (child) child.destroy();
				});
				this.children = null;
			}
			if (this.$$elmt) {
				this.$$elmt.remove();
				this.$$elmt = null;
			}
		},
		/**
		 * Generate html
		 * Use the same control buildHtml multiple html with different id's
		 * It's used by cards to build the tree structure for a card and reuse it for all the cards instead of creating a new tree structure for each card
		 * Same as buildHtml but:
		 * 		calls initReuseProperties to reset ID and properties used by previous build (cache, dom elmts...)
		 * !! It's the responsibility of the caller to destroy or not the control after having set $$elmt to null
		 * Returns $$elmt
		 */
		generateHtml: function($$parent, controllerDao, htmlRootCtrl) {
			var opts = this.options;
			if (htmlRootCtrl) {
				opts.htmlRootCtrl = htmlRootCtrl;
			}
			opts.isHtmlGenerator = true;
			this.buildHtml($$parent, controllerDao, opts);
			return this.$$elmt;
		},
		/**
		 * Build html for a control/layout
		 * !! CHILD CLASSES BUILDHTML METHOD MUST CALL THIS METHOD BEFORE PROCESSING
		 */
		buildHtml: function($$parent, controllerDao, buildOptions) {
			if (buildOptions && buildOptions.isHtmlGenerator === true) {
				if (this._needReuse) {
					this.initReuseProperties();
				} else {
					// First call don't call _initReuse
					this._needReuse = true;
				}
			}
		},
		/**
		 * Only for controls by method is need for all structElmts
		 */
		getMetaData: function(metaProp) {
			return null;
		},
		/**
		 * Returns field/layout authoring
		 * path: string with or without '.' separator or array of string
		 */
		getAuthoring: function(path, defValue) {
			var self = this;
			if (!path || !self.article) return defValue;
			if (typeof path === "string") {
				path = path.split('.');
			} else if (!Array.isArray(path)) {
				throw new Error("Unexpected path type");
			}
			var data = self.article;
			for (var i = 0; i < path.length; i++) {
				data = data[path[i]];
				if (data == null) {
					return defValue;
				}
				if (!$.isPlainObject(data) == null) {
					log && log('Unexpected non-plainobject');
					return defValue;
				}
			}
			return (data != null ? data : defValue);
		},
		/**
		 * Appends style authoring to classArray
		 * It's a draft just to start dealing with authoring
		 * classArray: 	array of classes used by createDomElement
		 * pathOrData: 	string or array of string that points points to an authoring value
		 * 				JS plain object that is the authoring object
		 */
		appendStyleAuthoring: function(classArray, pathOrData) {
			classArray = classArray || [];
			if (!pathOrData) return classArray;
			if ($.isPlainObject(pathOrData)) {
				// pathOrData is the authoring object
				var data = pathOrData;
			} else {
				// pathOrData points to an authoring value
				var data = this.getAuthoring(pathOrData);
			}
			if (!data) return classArray;
			// Apply style classes - To improve/enhance
			for (var p in data) {
				if (["$theme", "$fontStyle", "$fontSize"].indexOf(p) >= 0) {
					classArray.push(data[p]);
				}
			}
			return classArray;
		},
		/**
		 * Empty current element
		 * 	Called before a refresh
		 *  Keep control objects
		 */
		empty: function() {
			var self = this;
			if (self.children) {
				self.children.forEach(function(child) {
					if (child) child.empty();
				});
			}
			if (self.$$elmt) {
				self.$$elmt.empty();
			}
		},
		isLayout: function() {
			return this.typeName === "layout";
		},
		isVignette: function() {
			return this.typeName === "vignette";
		},
		isControl: function() {
			return this.isLayout() && !this.isVignette();
		},
		createId: function(typeName) {
			return utils.readableuid(typeName);
		},
		/**
		 * Append structElmt c as a child of this
		 */
		appendStructElmt: function(c) {
			var self = this;
			if (!c) return;
			if (!self.children) self.children = [];
			c.parent = self;
			self.children.push(c);
		},

		getNbChilds: function() {
			return this.children && this.children.length > 0;
		},
		/**
		 * Create the root element of the control/layout/vignette
		 * 	This element is identified by self.id
		 */
		createRootElement: function(css, $$parent) {
			var self = this;
			// No id for generated html
			var e = self.setRootElement(uiUtils.createDomElement("div", css, null, self.options.isHtmlGenerator === true ? null : {
				"id": self.id
			}), $$parent);
			return e;
		},
		setRootElement: function(e, $$parent) {
			if (!e) {
				return null;
			}
			if (!e.jquery) {
				e = $(e);
			}
			this.$$elmt = e;
			if ($$parent) {
				if (!$$parent.jquery) {
					$$parent = $($$parent);
				}
				e.appendTo($$parent);
			}
			if (this.options.isHtmlGenerator !== true) {
				e.attr("data-layout-path", this.getAuthoringPath());
			}
			return e;
		},
		log: function() {
			log && log.apply(null, arguments);
		},
		setAuthoringPath: function(layoutPath) {
			this.layoutPath = layoutPath;
		},
		getAuthoringPath: function() {
			return this.layoutPath;

		},
		isVisible: function() {
			return this.$$elmt && this.$$elmt.is(":visible");
		},
		isHidden: function() {
			return !this.isVisible();
		},
		show: function() {
			if (this.$$elmt) this.$$elmt.show();
		},
		hide: function() {
			if (this.$$elmt) this.$$elmt.hide();
		},
		/**
		 * Set the focus on this field and scroll
		 */
		setFocus: function() {

		}
	}
);

exports.Klass = _Klass;