"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("ctrls", false);

var _typeNames = {};
var _regExp = /-|\//g;

var _hamerRecognizers = {
	pinch: Hammer.Pinch,
	rotate: Hammer.Rotation,
	tap: Hammer.Tap,
	pan: Hammer.Pan,
	swipe: Hammer.Swipe,
	press: Hammer.Press
};
var _Hammer = function($$elmt) {
	if (!$$elmt || $$elmt.length === 0) throw new Error("gesture - Null dom elmt");
	if ($$elmt.jquery) $$elmt = $$elmt.get(0);
	this.mgr = new Hammer($$elmt); //new Hammer.Manager($$elmt);
	/* Add new gesture pan, swipe... based on default settings */
	this.addss = function(gesture, options, handler) {
		var opts = $.extend({}, options) || {};
		if (!this.mgr) return;
		var gest = this.mgr.get(gesture);
		if (!gest) throw new Error("Gesture[" + gesture + "] Not found in default Hammer");
		var direction = opts.direction;
		if (direction) {
			opts.direction = Hammer["DIRECTION_" + direction.toUpperCase()];
			gest.set(opts);
		}
		var g = "";
		if (gesture === "swipe" || gesture === "pan") {
			if (direction === "horizontal" || direction === "all") {
				// Needed
				g += " " + gesture + "left " + gesture + "right ";
			}
			if (direction === "vertical" || direction === "all") {
				// Needed
				g += " " + gesture + "up " + gesture + "down ";
			}
			if (g.length === 0) g = gesture + direction;
		} else {
			g = gesture;
		}
		this.mgr.on(g, handler);
	};
	/* Add new gesture - Create recognizer */
	this.add = function(gesture, options, handler) {
		var opts = $.extend({}, options) || {};
		if (!this.mgr) return;
		var recognizer = _hamerRecognizers[gesture];
		if (!recognizer) throw new Error("gesture - Unknown gesture [" + gesture + "]");
		var gest = this.mgr.get(recognizer);
		// Maybe we can just set options
		if (gest) this.mgr.remove(recognizer);
		var direction = opts.direction;
		if (direction) {
			opts.direction = Hammer["DIRECTION_" + direction.toUpperCase()];
		}
		gest = new recognizer(opts);
		this.mgr.add(gest, handler);
		var g = "";
		if (gesture === "swipe" || gesture === "pan") {
			if (direction === "horizontal" || direction === "all") {
				// Needed
				g += " " + gesture + "left " + gesture + "right ";
			}
			if (direction === "vertical" || direction === "all") {
				// Needed
				g += " " + gesture + "up " + gesture + "down ";
			}
			if (g.length === 0) g = gesture + direction;
		} else {
			g = gesture;
		}
		this.mgr.on(g, handler);
	};
	this.enable = function(yes) {
		if (!this.mgr) return;
		this.mgr.set({
			enable: yes !== false
		});
	};
	this.destroy = function() {
		if (!this.mgr) return;
		this.mgr.destroy();
	};
};
/**
 * Base class for controls and layouts
 *
 * controller: page (or child controller)
 * 		must implements addControl Method
 *
 */
var _Klass = utils.defineClass(
	function StructElmt(controller, $type, article, options) {
		var self = this;
		self.options = options || {};
		self.controller = controller;
		self.$type = $type;
		self.typeName = _typeNames[$type];
		if (!self.typeName) {
			// used to generate readable ids - type expected "application/x-name" or "text/plain"
			var a = $type.split(_regExp);
			self.typeName = _typeNames[$type] = a[a.length - 1];
		}
		self.article = article || {};
		self.children = null;
		self.parent = null;
		self.initReuseProperties();
	}, null, {
		/**
		 * Init the properties to allow reuse of this control
		 */
		initReuseProperties: function() {
			this.$$elmt = null;
			this.id = this.createId(this.typeName);
		},
		destroy: function() {
			var self = this;
			self.controller = null;
			self.parent = null;
			if (this._gestures) {
				this._gestures.destroy();
				this._gestures = null;
			}
			utils.unbindObj(self.$$elmt);
			utils.unbindObj(self);
			if (self.children) {
				self.children.forEach(function(child) {
					if (child) child.destroy();
				});
				self.children = null;
			}
			if (self.$$elmt) {
				self.$$elmt.remove();
				self.$$elmt = null;
			}
		},
		/**
		 * Generate html
		 * Use the same control buildHtml multiple html with different id's
		 * It's used by cards to build the tree structure for a card and reuse it for all the cards instead of creating a new tree structure for each card
		 * Same as buildHtml but:
		 * 		calls initReuseProperties to reset ID and properties used by previous build (cache, dom elmts...)
		 * 		destroyAfter:true	Detach $$elmt and destroy control
		 * 		destroyAfter:false	Do not destroy control - Just detach $$elmt
		 * Returns $$elmt
		 */
		generateHtml: function($$parent, controllerDao, destroyAfter, htmlRootCtrl) {
			var self = this;
			var opts = self.options;
			if (htmlRootCtrl) {
				opts.htmlRootCtrl = htmlRootCtrl;
			}
			opts.isHtmlGenerator = true;
			self.buildHtml($$parent, controllerDao, opts);
			// Detach $$elmt to not clear it at destroy
			var $$elmt = self.$$elmt;
			self.$$elmt = null;
			if (destroyAfter === true) {
				// Destroy if needed
				self.destroy();
			}
			return $$elmt;
		},
		/**
		 * Build html for a control/layout
		 * !! CHILD CLASSES BUILDHTML METHOD MUST CALL THIS METHOD BEFORE PROCESSING
		 */
		buildHtml: function($$parent, controllerDao, buildOptions) {
			var self = this;
			if (buildOptions.isHtmlGenerator === true) {
				if (self._needReuse) {
					self.initReuseProperties();
				} else {
					// First call don't call _initReuse
					self._needReuse = true;
				}
			}
		},
		/**
		 * Returns field/layout authoring
		 * path: string with or without '.' separator or array of string
		 */
		getAuthoring: function(path, defValue) {
			var self = this;
			if (!path || !self.article) return defValue;
			if (typeof path === "string") {
				path = path.split('.');
			} else if (!Array.isArray(path)) {
				throw new Error("Unexpected path type");
			}
			var data = self.article;
			for (var i = 0; i < path.length; i++) {
				data = data[path[i]];
				if (data == null) {
					return defValue;
				}
				if (!$.isPlainObject(data) == null) {
					log && log('Unexpected non-plainobject');
					return defValue;
				}
			}
			return (data != null ? data : defValue);
		},
		/**
		 * Appends style authoring to classArray
		 * It's a draft just to start dealing with authoring
		 * classArray: 	array of classes used by createDomElement
		 * pathOrData: 	string or array of string that points points to an authoring value
		 * 				JS plain object that is the authoring object
		 */
		appendStyleAuthoring: function(classArray, pathOrData) {
			classArray = classArray || [];
			if (!pathOrData) return classArray;
			if ($.isPlainObject(pathOrData)) {
				// pathOrData is the authoring object
				var data = pathOrData;
			} else {
				// pathOrData points to an authoring value
				var data = this.getAuthoring(pathOrData);
			}
			if (!data) return classArray;
			// Apply style classes - To improve/enhance
			for (var p in data) {
				if (["$theme", "$fontStyle", "$fontSize"].indexOf(p) >= 0) {
					classArray.push(data[p]);
				}
			}
			return classArray;
		},
		/**
		 * Empty current element
		 * 	Called before a refresh
		 *  Keep control objects
		 */
		empty: function() {
			var self = this;
			if (self.children) {
				self.children.forEach(function(child) {
					if (child) child.empty();
				});
			}
			if (self.$$elmt) {
				self.$$elmt.empty();
			}
		},
		isLayout: function() {
			return this.typeName === "layout";
		},
		isVignette: function() {
			return this.typeName === "vignette";
		},
		isControl: function() {
			return this.isLayout() && !this.isVignette();
		},
		createId: function(typeName) {
			return utils.readableuid(typeName);
		},
		/**
		 * Append structElmt c as a child of this
		 */
		appendStructElmt: function(c) {
			var self = this;
			if (!c) return;
			if (!self.children) self.children = [];
			c.parent = self;
			self.children.push(c);
		},

		getNbChilds: function() {
			return this.children && this.children.length > 0;
		},

		/**
		 * Refreshes the control
		 */
		refresh: function(controllerDao, options) {
			throw new Error("not implemented");
		},
		/**
		 * Create the root element of the control/layout/vignette
		 * 	This element is identified by self.id
		 */
		createRootElement: function(css, $$parent) {
			var self = this;
			// No id for generated html
			var e = self.setRootElement(uiUtils.createDomElement("div", css, null, self.options.isHtmlGenerator === true ? null : {
				"id": self.id
			}), $$parent);
			return e;
		},
		setRootElement: function(e, $$parent) {
			var self = this;
			var dom = e;
			var pom = $$parent;
			if (!e) {
				return null;
			}
			if (typeof e === "string" || !e.jquery) {
				e = $(e);
			}
			self.$$elmt = e;
			if ($$parent) {
				if (!$$parent.jquery) {
					$$parent = $($$parent);
				}
				e.appendTo($$parent);
			}
			if (self.options.isHtmlGenerator !== true) e.attr("data-layout-path", self.getAuthoringPath());
			return e;
		},
		log: function() {
			log && log.apply(null, arguments);
		},
		setAuthoringPath: function(layoutPath) {
			this.layoutPath = layoutPath;
		},
		getAuthoringPath: function() {
			return this.layoutPath;

		},
		onGesture: function(evt) {
			//if (evt.type.indexOf("swipe") === 0 || evt.type === "panstart" || evt.type === "panend") console.log (this.id + " onGesture" + " - " + evt.type)
			console.log(this.id + " " + evt.type);
		},
		gestureAdd: function($$elmt, gesture, options, handler) {
			$$elmt = $$elmt || this.$$elmt;
			handler = Hammer.bindFn(this.onGesture, this);
			if (!$$elmt || $$elmt.length === 0) throw new Error("gesture - Null dom elmt");
			if (!this._gestures) {
				this._gestures = new _Hammer($$elmt || this.$$elmt);
			}
			this._gestures.add(gesture, options || {}, handler);
		},
		/**
		 *  Add a swipe event
		 *  	direction:	"non", "all", "vertical", "horizontal", "left", "right", "up", "down"
		 *  	withPan		add pan usefull in complement to span to adjust position more accuratlely
		 *  				no used for only swiping cards
		 */
		gestureAddSwipe: function($$elmt, direction, withPan, handler) {
			var self = this;
			if (!direction) throw new Error("gesture - Null direction");
			var opts = {
				direction: direction
			};
			// We can add other options threshold, veolicty in opts 
			self.gestureAdd($$elmt, "swipe", opts, handler);
			if (withPan) this.gestureAddPan($$elmt, direction, handler);
		},
		/**
		 * Add pan event like a scroll
		 * handler is called with event
		 * 	panstart (mouve down + move) , panup/down/left/right, panend (mouse up)
		 * 	deltaX/Y is reset on panstart
		 */
		gestureAddPan: function($$elmt, direction, handler) {
			var self = this;
			if (!direction) throw new Error("gesture - Null direction");
			var opts = {
				direction: direction
			};
			self.gestureAdd($$elmt, "pan", opts, handler);
		}
	}
);

exports.Klass = _Klass;