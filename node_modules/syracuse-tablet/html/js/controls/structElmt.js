"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var uiUtils = require('syracuse-tablet/html/js/ui/uiUtils');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("ctrls");
var _typeNames = {};
var _regExp = /-|\//g;
/**
 * Base class for controls and layouts
 *
 * controller: page (or child controller)
 * 		must implements addControl Method
 *
 */
var _Klass = utils.defineClass(
	function(controller, $type, article, options) {
		var self = this;
		self.options = options || {};
		self.controller = controller;
		self.$type = $type;
		self.typeName = _typeNames[$type];
		if (!self.typeName) {
			// used to generate readable ids - type expected "application/x-name" or "text/plain"
			var a = $type.split(_regExp);
			self.typeName = _typeNames[$type] = a[a.length - 1];
		}
		self.article = article || {};
		self.id = self.createId(self.typeName);
		self.children = null;
		self.parent = null;
		self.displayOptions = $.extend({}, self.article.displayOptions);
		self.$$elmt = null;
	}, null, {
		destroy: function() {
			var self = this;
			self.controller = null;
			self.parent = null;
			utils.unbindObj(self.$$elmt);
			utils.unbindObj(self);
			if (self.children) {
				self.children.forEach(function(child) {
					if (child) child.destroy();
				});
				self.children = null;
			}
			self.$$elmt = null;
		},
		/**
		 * Temporarily
		 * 	Detach the $$elmt and destroy the object
		 * Used by grid cells
		 * TODO - For grid celleit's not necessary to create object
		 * It's better to have generator the return html/dom elmt per type of control to be able to call the generator without creating objects
		 */
		detachElmt: function() {
			var e = this.$$elmt;
			this.$$elmt = null;
			this.destroy();
			return e;
		},
		/**
		 * Set field authoring - See structure in top of the file
		 * Used in dvlp phase to set authoring programmatically
		 * Should be embedded in $article
		 */
		setAuthoring: function(auth) {
			this._authoring = auth;
		},
		/**
		 * Returns field/layout authoring
		 * path: string with or without '.' separator or array of string
		 */
		getAuthoring: function(path, defValue) {
			var self = this;
			if (!path || !self._authoring) return defValue;
			if (typeof path === "string") {
				path = path.split('.');
			} else if (!Array.isArray(path)) {
				throw new Error("Unexpected path type");
			}
			var data = self._authoring[path[0]];
			for (var i = 1; i < path.length; i++) {
				if (data == null) return null;
				if (!$.isPlainObject(data) == null) {
					throw new Error('Unexpected non-plainobject');
				}
				data = data[path[i]];
			}
			return data;
		},
		/**
		 * Appends style authoring to classArray
		 * It's a draft just to start dealing with authoring
		 * classArray: 	array of classes used by createDomElement
		 * pathOrData: 	string or array of string that points points to an authoring value
		 * 				JS plain object that is the authoring object
		 */
		appendStyleAuthoring: function(classArray, pathOrData) {
			classArray = classArray || [];
			if (!pathOrData) return classArray;
			if ($.isPlainObject(pathOrData)) {
				// pathOrData is the authoring object
				var data = pathOrData;
			} else {
				// pathOrData points to an authoring value
				var data = this.getAuthoring(pathOrData);
			}
			if (!data) return classArray;
			// Apply style classes - To improve/enhance
			for (var p in data) {
				if (["$theme", "$fontstyle", "$fontsize"].indexOf(p) >= 0) {
					classArray.push(data[p]);
				}
			}
			return classArray;
		},
		/**
		 * Empty current element
		 * 	Called before a refresh
		 *  Keep control objects
		 */
		empty: function() {
			var self = this;
			if (self.children) {
				self.children.forEach(function(child) {
					if (child) child.empty();
				});
			}
			if (self.$$elmt) {
				self.$$elmt.empty();
			}
		},
		/**
		 * return the dao of the controller (page)
		 */
		getControllerDao: function() {
			return this.controller.dao;
		},
		isLayout: function() {
			return this.typeName === "layout";
		},
		isVignette: function() {
			return this.typeName === "vignette";
		},
		isControl: function() {
			return this.isLayout() && !this.isVignette();
		},
		createId: function(typeName) {
			return utils.readableuid(typeName);
		},
		/**
		 * Append structElmt c as a child of this
		 */
		appendStructElmt: function(c) {
			var self = this;
			if (!c) return;
			if (!self.children) self.children = [];
			c.parent = self;
			self.children.push(c);
		},
		isRoot: function() {
			return this.controller === this.parent || this.parent == null;
		},

		getNbChilds: function() {
			return this.children && this.children.length > 0;
		},

		buildHtml: function($$parent, controllerDao, buildOptions) {
			throw new Error("Must be overridden");
		},
		afterRender: function() {
			// Do nothing by default
			// Some controls needs this method (footer, panel)
			// For field affterRender applies meta-data
		},

		/**
		 * Refreshes the control
		 */
		refresh: function(controllerDao, options) {
			throw new Error("not implemented");
		},
		/**
		 * Create the root element of the control/layout/vignette
		 * 	This element is identified by self.id
		 */
		createRootElement: function(css, $$parent) {
			var self = this;
			return self.setRootElement(uiUtils.createDomElement("div", css, null, {
				"id": self.id
			}), $$parent);
		},
		setRootElement: function(e, $$parent) {
			var dom = e;
			var pom = $$parent;
			if (!e) return null;
			if (typeof e === "string" || !e.jquery) e = $(e);
			this.$$elmt = e;
			if ($$parent) {
				if (!$$parent.jquery) $$parent = $($$parent);
				e.appendTo($$parent);
			}
			return e;
		},
		// common log for controls
		log: function() {
			log && log.apply(null, arguments);
		},
		hasLog: function() {
			return log != null;
		}
	}
);

exports.Klass = _Klass;