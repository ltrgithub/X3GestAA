"use strict";
var helpers = require('syracuse-tablet/html/js/common/helpers');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var globals = require('syracuse-tablet/html/js/app/globals');
var locale = require('syracuse-tablet/html/js/helpers/locale');

/**
 * 
 * Resolves only if http code is something ok
 * Rejects in all other situations
 * options:{
 * 		timeout:			request timeout
 * 		contentType:		request content type (default is application/json;charset=utf-8)
 * 		acceptStatusCode	[] list of status codes considered as success (eg 404)
 * }
 * Returned object for reject and resolve:
 * {
 *   success: true or false (true if resolve, false if reject)
 *   offline: true: If rejected because of offline
 *   unauthenticated: true: If rejected because of not authorized
 *   $diagnoses: [] // Top level diagnoses (may be created on client side)
 *   data: { // Data coming from the server if any, may include additional diagnoses
 *     CODE: 10,
 *     TEXT: "abc",
 *     $diagnoses: []
 *   }
 * }
 */
exports.request = function(url, method, data, headers, options) {
	options = options || {};
	method = (method && method.toUpperCase()) || "GET";
	var timeout = options.timeout == null ? globals.getHttpTimeout(url) : options.timeout;
	var acceptStatusCode = options.acceptStatusCode || [];
	//  Quickly fake offline if needed	
	//	if (url.indexOf("representation")>-1&&true) {
	//		return $.smReject({
	//			offline: true
	//		});
	//	} 

	var lang = locale.getCurrentLocale() || "en-US";
	var allHeaders = {
		"Accept": "application/json;vnd.sage=syracuse",
	};
	if (method === "POST" || method === "PUT") {
		allHeaders["Content-Type"] = "application/json";
	}
	if (lang) {
		allHeaders["Accept-Language"] = lang;
	}
	if (headers) {
		$.extend(allHeaders, headers);
	}
	var ajaxData = {
		headers: allHeaders,
		type: method,
		url: url,
		timeout: timeout
			//processData : false
	};
	// We need this option to deal with non-json data
	var parseJson = allHeaders.Accept.indexOf("application/json") >= 0;
	if (parseJson) {
		ajaxData.dataType = "json";
	}
	if (["PUT", "POST"].indexOf(method) >= 0 && data != null) {
		ajaxData.contentType = options.contentType || "application/json;charset=utf-8";
		ajaxData.data = data;

		if (ajaxData.contentType.indexOf("application/json") >= 0 && typeof data === "object") {
			try {
				ajaxData.data = JSON.stringify(data);
			} catch (e) {
				return $.smReject(helpers.createDiag(null, "error", e.Message));
			}
		};
	}

	var deferred = $.Deferred();
	$.ajax(ajaxData).always(function(jqXHR, textStatus, jqXHRSuccess) {
		var result;
		try {
			if (jqXHRSuccess && jqXHRSuccess.getAllResponseHeaders) {
				jqXHR = jqXHRSuccess;
			}
			var status = jqXHR.status != null ? jqXHR.status : textStatus == "success" ? 200 : 500;
			var regularSuccess = (status >= 200 && status < 300) || status === 304;
			result = {
				headers: {},
				status: status,
				success: regularSuccess || acceptStatusCode.indexOf(status) >= 0
			};

			if (result.success && parseJson) {
				result.data = jqXHR.responseJSON;
				if (result.data == null && regularSuccess) {
					// No parsing if acceptStatusCode
					var txt = (jqXHR.responseText || "").trim()
					if (txt.length > 0) {
						// Error parsing JSON - ajax doesn't return error status is parsig fails
						try {
							result.data = JSON.parse(txt);
						} catch (e) {
							deferred.reject(helpers.createDiag(null, "error", "Error parsing HTTP response", e.message + "\nUrl: " + url + "\n" + jsutils.cleanStack(e.stack)));
							return;
						}
					}
				} else if (result.data && result.data.mobileClientConfig) {
					// Set the config given by nodelocal.js
					globals.setMobileClientConfig(result.data.mobileClientConfig);
				}
			} else {
				// responseText if non-json data
				result.data = parseJson && jqXHR.responseJSON ? jqXHR.responseJSON : jqXHR.responseText;
			}
			var headerStr = jqXHR.getAllResponseHeaders();
			if (headerStr) {
				var _rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg;
				var match;
				while ((match = _rheaders.exec(headerStr))) {
					result.headers[match[1].toLowerCase()] = match[2];
				}
			}
			var diags = null;

			// Success (status OK or acceptStatusCode)
			if (result.success === true) {
				deferred.resolve(result);
			}
			// offline
			else if (status === 0) {
				result.offline = true;
				deferred.reject(helpers.createDiag(result, "error", locale.text("client.offline")));
			}
			// Not found
			else if (status === 404) {
				var message;
				if (result.data && result.data.$diagnoses && result.data.$diagnoses.length > 0) {
					message = result.data.$diagnoses[0].$message + " (Status 404)";
				}
				deferred.reject(helpers.createDiag(result, "error", message || locale.text("http404"), "url:" + url));
			}
			// not authorized
			else if (status === 401) {
				result.unauthenticated = true;
				deferred.reject(helpers.createDiag(result, "error", locale.text("user.not.authenticated")));
			}
			// Unknown error, check if diag is in payload, create one if no one is there
			else {
				if (result.data && result.data.$diagnoses) {
					diags = result;
					diags.$diagnoses = result.data.$diagnoses;
				} else {
					diags = helpers.createDiag(result, "error", "Error http " + status + " reading resource", "url:" + url + "\n" + jqXHR.responseText);
				}
				deferred.reject(diags);
			}
		} catch (e) {
			deferred.reject(helpers.createDiag(null, "error", e.message));
		}
	});

	return deferred.promise();
}