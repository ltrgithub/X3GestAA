"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("pageLoader");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var locale = require('syracuse-tablet/html/js/helpers/locale');

/**
 * Load a page in a container
 * 	container must provide the following interface
 * 	Use by application and vignette - code factorization
 * 	callerInterface - see CALLER INTERFACE below
 */
var _PageLoader = utils.defineClass(
	function PageLoader(callerInterface) {
		this.callerInterface = callerInterface;
		this.factory = globals.getApplication().factory;
	}, null, {

		destroy: function() {
			this.destroyed = true;
			this.callerInterface = null;
			this.factory = null;
		},
		/**
		 * loadOptions
		 * 		dontDisplayLoadErr = true to not display a modal,
		 * 		restoreSavedContext: true to restore the savedContext even if it's not a back (open a link by email)
		 */
		load: function(state, back, loadOptions) {
			var self = this;
			if (self.destroyed) {
				return $.smResolve();
			}
			var deferred = $.Deferred();
			var pageToOpen = null;
			var pageToClose = null;
			state.options = state.options || {};
			loadOptions = loadOptions || {};
			var _fail = function(e) {
				if (self.destroyed) {
					return deferred.reject(e);
				}
				self.loading = false;
				if (!back && (!e || !e.$redirectPage)) {
					if (pageToOpen) {
						// Only if !back
						pageToOpen.destroy();
					}
					// Stay on the same page - Mode offline if we click on a detail that doesn't exist we stay on the list
					e.$redirectPage = "current";
				}
				// Otherwise we goto welcome page
				self.waitWheelStop();
				if (self.callerInterface.loadingError) {
					self.callerInterface.loadingError(deferred, state, e);
				} else if (loadOptions.dontDisplayLoadErr !== true) {
					if (e && e.$noConnectionError === true) {
						globals.setOffline(true, {
							severityClass: "success",
							body: locale.text("no.local.data.available")
						});
						deferred.reject(e);
					} else {
						modal.error(locale.text("error.page.loading"), e, function() {
							deferred.reject(e);
						});
					}
				} else {
					deferred.reject(e);
				}
			};
			var timeLine = utils.getTimeLine("pageLoader", state.name);
			timeLine && timeLine.start();
			var _success = function(pageToOpen, pageToClose, parentNotifInfo) {
				if (self.destroyed) {
					return deferred.resolve(null);
				}
				self.loading = false;
				self.waitWheelStop();
				if (pageToOpen) {
					if (back !== true && state.options.noHistoryBack !== true) {
						// Store page in history - noHistoryBack option is used by example for pagination actions
						if (pageToOpen.prototype) {
							pageToOpen.state.$title = pageToOpen.prototype.data("$title");
						}
						self.historyPush(pageToOpen.state);
					}
					self.succeeded(pageToOpen, pageToClose, parentNotifInfo, back, loadOptions);
					timeLine && timeLine.stop(pageToOpen.isNew ? "newPage" : "existingPage");
					pageToOpen.activated();
				}
				deferred.resolve(pageToOpen);
			};
			try {
				if (self.loading) {
					_success(null);
				}
				self.loading = true;
				if (state === null || typeof state != "object") throw new Error("Bad state object");
				log && log("_gotoPage", "start", "page: " + state.uuid);
				pageToClose = self.getCurrentPage();
				if (pageToClose && pageToClose.getProp("uuid") === state.uuid) {
					log && log("\tPage is current -> Skip");
					return;
				}
				var parentNotifInfo = null;
				var childNotifInfo = null;
				if (pageToClose && pageToClose.isChild) {
					/**
					 * If the current page is a child and wants to notify the parent (ex lookup...) it should provide at least
					 * a JSONobject that contains a notifyId with the id of notification
					 * We need to store this data before the page it's destroyed
					 * Information is passed to parent in succeeded interface method (at the end of the process)
					 */
					parentNotifInfo = pageToClose.getParentNotif();
				}
				self.waitWheelStart();
				pageToOpen = $("#" + state.uuid).smPageController();
				// Page found -> Direct access -> Activate and remove childs
				if (pageToOpen != null) {
					log && log("\tPage found in dom -> Activate");
					if (!pageToOpen) throw new Error("Unexpected null page data");
					// Page retrieve from cache
					pageToOpen.isNew = false;
					self._pageActivate(pageToOpen, function() {
						timeLine && timeLine.step("activated");
						// After activation to keep current page for transition
						// No siblings expected
						pageToOpen.destroySiblings();
						_success(pageToOpen, pageToClose, parentNotifInfo);
					}, back);
					return deferred.promise();
				}
				// Page not found -> Create and display
				var parentPage = null;
				if (state.options.parentId) {
					// For child page like state.type === "carddesign" || state.type === "rowdetail"
					parentPage = globals.getController(state.options.parentId);
				}
				var $forceLinkArticle;
				if (pageToClose) {
					// linkArticle contains the id of the vignette that contains the page article
					// Used in test entities to attach a $article to a $link vignette
					// -> convenient for unit test
					var ctrlId = state.options["linkArticle"];
					$forceLinkArticle = back ? state.forceLinkArticle : pageToClose.getLinkedPageArticle(ctrlId);
				}
				self.factory.createPage(self.getRootElmt(), state, parentPage, $forceLinkArticle)
					.then(function(p) {
						if (self.destroyed) return;
						timeLine && timeLine.step("created");
						pageToOpen = p;
						// Page created
						pageToOpen.isNew = true;
						// Context to restore
						var savedContext = state.savedContext;
						// By default we restore nothing - clear the context
						state.savedContext = null;
						if (pageToOpen.isNew) {
							if (!back && pageToOpen.isVignette && pageToClose == null) {
								// Restore the context of a page nested in a vignette after it has been loaded (only - pageToClose == null)
								// E.g. 	when we open a detail form a vignette we need to store the status (scroll, selection...) of the vignette to restore it on back
								state.savedContext = self.getSavedCtxVignette();
							} else if (back || loadOptions.restoreSavedContext == true) {
								// Originally the savedContext was restored on back (last clicked row, searchInfo, scroll...)
								// --> Back in full page or vignette page - we restore context
								// When we implemented the capability to restore a page from a link we allowed the restoration of savedContext when we open the page
								// --> loadOptions.restoreSavedContext = true just means that it's not the regular back proccess
								state.savedContext = savedContext;
							}
						}
						return pageToOpen.load(loadOptions);
					})
					.then(function() {
						if (self.destroyed) return;
						timeLine && timeLine.step("loaded");
						self._pageActivate(pageToOpen, function() {
							timeLine && timeLine.step("activated");
							_success(pageToOpen, pageToClose, parentNotifInfo);
						}, back);
					}).fail(function(e) {
						_fail(e);
					});
			} catch (e) {
				_fail(e);
			}
			return deferred.promise();
		},

		_pageActivate: function(pageToOpen, cb, back) {
			var self = this;
			if (self.destroyed) return;
			var pageToClose = self.getCurrentPage();
			if (pageToClose && pageToClose.destroyed === true) {
				// Unexpected but...
				pageToClose = null;
			}
			// Destroy=true if the pageToClose has to be destroyed
			// We destroy the page if back or if pageToClose is not cached or if pageToOpen is a not child
			var destroy = pageToClose && (back === true || (pageToClose.getProp("cached") !== true && pageToOpen.isChild !== true));
			if (pageToClose) {
				// Update the saved context before closing to allow restoration
				// only if destroy and !back -if not destroy (cahed ) page no need to save context (idem if back)
				var clearCtx = (!destroy || back);
				pageToClose.updateSavedContext(clearCtx);
			}
			pageToOpen.activate(pageToClose, function() {
				self.setCurrentPage(pageToClose, pageToOpen, destroy);
				if (cb) cb();
			});
		},

		/**
		 * CALLER INTERFACE BEGIN
		 */

		/* Methods MUST be implemented */
		historyPush: function(state) {
			this.callerInterface.historyPush(state);
		},

		waitWheelStop: function() {
			this.callerInterface.waitWheelStop();
		},

		waitWheelStart: function() {
			this.callerInterface.waitWheelStart();
		},

		getRootElmt: function() {
			return this.callerInterface.getRootElmt();
		},

		getCurrentPage: function() {
			return this.callerInterface.getCurrentPage();
		},
		getSavedCtxVignette: function() {
			var meth = this.callerInterface.getSavedCtxVignette;
			return meth ? meth() : null;
		},
		setCurrentPage: function(pageToClose, pageToOpen, destroy) {
			var self = this;
			if (pageToClose) {
				if (destroy === true) {
					// To postpone destroy and let asynchronous processes stop (prevent bugs when we work on local data)
					setTimeout(function() {
						pageToClose.destroy();
					});
				} else {
					// Keep cached page only if not back - Ex: List -> Detail
					pageToClose.deactivate();
				}
			}
			self.callerInterface.setCurrentPage(pageToOpen);
		},

		succeeded: function(pageToOpen, pageToClose, parentNotifInfo, back, loadOptions) {
			var self = this;
			notifications.publish("sm.page.loaded", self.getCurrentPage());
			if (this.callerInterface.succeeded) {
				this.callerInterface.succeeded(pageToOpen, pageToClose, parentNotifInfo, back, loadOptions);
			}
		}
		/**
		 * CALLER INTERFACE END
		 */
	});

exports.Klass = _PageLoader;