"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("pageLoader");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var modal = require('syracuse-tablet/html/js/ui/modal');
var Gadget = require('syracuse-tablet/html/js/application/gadget').Klass;
var notifications = require('syracuse-tablet/html/js/helpers/notifications');


/**
 * Load a page in a container
 * 	container must provide the following interface
 * 	Use by application and vignette - code factorization
 * 	callerInterface - see CALLER INTERFACE below
 */
var _PageLoader = utils.defineClass(
	function(callerInterface) {
		this.callerInterface = callerInterface;
		this.factory = globals.getApplication().factory;
	}, null, {

		destroy: function() {
			this.callerInterface = null;
			this.factory = null;
		},

		load: function(state, back) {
			var deferred = $.Deferred();
			var self = this;
			var _fail = function(e) {
				self.waitStop();
				self.loadingError(deferred, state, e);
			};
			var _success = function(pageToOpen, parentNotifInfo) {
				self.waitStop();
				if (back !== true && (state.options == null || state.options.noHistoryBack !== true)) {
					// Store page in history - noHistoryBack option is used by example for pagination actions
					self.setHistory(pageToOpen.state);
				}
				self.succeeded(pageToOpen, parentNotifInfo);
				deferred.resolve(pageToOpen);
			};
			try {
				if (state === null || typeof state != "object") throw new Error("Bad state object");
				log && log("_gotoPage", "start", "page: " + state.uuid);
				var pageToClose = self.getCurrentPage();
				if (pageToClose && pageToClose.getProp("uuid") === state.uuid) {
					log && log("\tPage is current -> Skip");
					return;
				}
				var parentNotifInfo = null;
				var childNotifInfo = null;
				if (pageToClose && pageToClose.isChild) {
					/**
					 * If the current page is a child and wants to notify the parent (ex lookup...) it should provide at least
					 * a JSONobject that contains a notifyId with the id of notification
					 * We need to store this data before the page it's destroyed
					 * Information is passed to parent in succeeded interface method (at the end of the process)
					 */
					parentNotifInfo = pageToClose.getParentNotif();
				}
				self.waitStart();
				var pageToOpen = $("#" + state.uuid).smPageController();
				// Page found -> Direct access -> Activate and remove childs
				if (pageToOpen != null) {
					log && log("\tPage found in dom -> Activate");
					if (!pageToOpen) throw new Error("Unexpected null page data");
					self._pageActivate(pageToOpen, function() {
						// After activation to keep current page for transition
						// No siblings expected
						pageToOpen.destroySiblings();
						_success(pageToOpen, parentNotifInfo);
					}, back);
					return deferred.promise();
				}
				// Page not found -> Create and display
				var options = {};
				if (state.type === "rowdetail") {
					options.parentPage = pageToClose;
				}
				self.factory.createPage(self.getRootElmt(), state, options)
					.then(function(p) {
						pageToOpen = p;
						return pageToOpen.load(options);
					})
					.then(function() {
						self._pageActivate(pageToOpen, function() {
							_success(pageToOpen, parentNotifInfo);
						}, back);
					}).fail(function(e) {
						_fail(e);
					});
			} catch (e) {
				_fail(e);
			}
			return deferred.promise();
		},

		_pageActivate: function(pageToOpen, cb, back) {
			var self = this;
			pageToOpen.activate(self.getCurrentPage(), function() {
				self.setCurrentPage(pageToOpen, back);
				if (cb) cb();
			});
		},

		/**
		 * CALLER INTERFACE BEGIN
		 */

		/* Methods MUST be implemented */
		setHistory: function(state) {
			this.callerInterface.setHistory(state);
		},

		waitStop: function() {
			this.callerInterface.waitStop();
		},

		waitStart: function() {
			this.callerInterface.waitStart();
		},

		getRootElmt: function() {
			return this.callerInterface.getRootElmt();
		},

		getCurrentPage: function() {
			return this.callerInterface.getCurrentPage();
		},

		setCurrentPage: function(pageToOpen, back) {
			var self = this;
			var pageToClose = self.getCurrentPage();
			if (pageToClose) {
				/**
				 * Parent page is cached if we open a child page
				 */
				if (back === true || (pageToClose.getProp("cached") !== true && pageToOpen.isChild !== true)) {
					pageToClose.destroy();
				} else {
					// Keep cached page only if not back - Ex: List -> Detail
					pageToClose.deactivate();
				}
			}
			self.callerInterface.setCurrentPage(pageToOpen, back);
		},
		/* Methods CAN be overridden */
		loadingError: function(deferred, state, e) {
			if (this.callerInterface.loadingError) {
				this.callerInterface.loadingError(deferred, state, e);
			} else {
				modal.error("Loading page [" + state.name + "] error", e, function() {
					deferred.reject(e);
				});
			}
		},
		succeeded: function(pageToOpen, parentNotifInfo) {
			var self = this;
			notifications.publish("sm.page.loaded", self.getCurrentPage());
			if (this.callerInterface.succeeded) {
				this.callerInterface.succeeded(pageToOpen, parentNotifInfo);
			}
		}
		/**
		 * CALLER INTERFACE END
		 */
	});

/**
 * window.history accepts only json object (no class/prototype based object)
 * We have to serialize/deserialize object contained by state
 */
var _stateSerialize = function(state) {
	if (!state || !state.options || !state.options.gadget) return state;
	// Object that represents the gadget data
	state.options.gadget = state.options.gadget.getJSON();
	return state;
};
var _stateDeserialize = function(state) {
	if (!state || !state.options || !state.options.gadget) return state;
	state.options.gadget = new Gadget(state.options.gadget);
	return state;
};

exports.stateSerialize = _stateSerialize;
exports.stateDeserialize = _stateDeserialize;
exports.Klass = _PageLoader;