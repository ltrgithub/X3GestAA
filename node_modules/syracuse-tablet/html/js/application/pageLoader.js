"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("pageLoader");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var modal = require('syracuse-tablet/html/js/ui/modal');
var Gadget = require('syracuse-tablet/html/js/application/gadget').Klass;
var notifications = require('syracuse-tablet/html/js/helpers/notifications');


/**
 * Load a page in a container
 * 	container must provide the following interface
 * 	Use by application and vignette - code factorization
 * 	callerInterface - see CALLER INTERFACE below
 */
var _PageLoader = utils.defineClass(
	function(callerInterface) {
		this.callerInterface = callerInterface;
		this.factory = globals.getApplication().factory;
	}, null, {

		destroy: function() {
			this.callerInterface = null;
			this.factory = null;
		},

		load: function(state, back) {
			var deferred = $.Deferred();
			var self = this;
			var _fail = function(e) {
				self.waitStop();
				self.loadingError(deferred, state, e);
			};
			var timeLine = utils.getTimeLine("pageLoader", state.name);
			timeLine && timeLine.start();
			var _success = function(pageToOpen, parentNotifInfo) {
				self.waitStop();
				if (back !== true && (state.options == null || state.options.noHistoryBack !== true)) {
					// Store page in history - noHistoryBack option is used by example for pagination actions
					self.historyPush(pageToOpen.state);
				}
				self.succeeded(pageToOpen, parentNotifInfo, back);
				timeLine && timeLine.stop(pageToOpen.isNew ? "newPage" : "existingPage");
				deferred.resolve(pageToOpen);
			};
			try {
				if (state === null || typeof state != "object") throw new Error("Bad state object");
				log && log("_gotoPage", "start", "page: " + state.uuid);
				var pageToClose = self.getCurrentPage();
				if (pageToClose && pageToClose.getProp("uuid") === state.uuid) {
					log && log("\tPage is current -> Skip");
					return;
				}
				var parentNotifInfo = null;
				var childNotifInfo = null;
				if (pageToClose && pageToClose.isChild) {
					/**
					 * If the current page is a child and wants to notify the parent (ex lookup...) it should provide at least
					 * a JSONobject that contains a notifyId with the id of notification
					 * We need to store this data before the page it's destroyed
					 * Information is passed to parent in succeeded interface method (at the end of the process)
					 */
					parentNotifInfo = pageToClose.getParentNotif();
				}
				self.waitStart();
				var pageToOpen = $("#" + state.uuid).smPageController();
				// Page found -> Direct access -> Activate and remove childs
				if (pageToOpen != null) {
					log && log("\tPage found in dom -> Activate");
					if (!pageToOpen) throw new Error("Unexpected null page data");
					// Page retrieve from cache
					pageToOpen.isNew = false;
					self._pageActivate(pageToOpen, function() {
						timeLine && timeLine.step("activated");
						// After activation to keep current page for transition
						// No siblings expected
						pageToOpen.destroySiblings();
						_success(pageToOpen, parentNotifInfo);
					}, back);
					return deferred.promise();
				}
				// Page not found -> Create and display
				var savedContext = null;
				var parentPage = state.type === "rowdetail" ? pageToClose : null;
				self.factory.createPage(self.getRootElmt(), state, parentPage)
					.then(function(p) {
						timeLine && timeLine.step("created");
						pageToOpen = p;
						// Page created
						pageToOpen.isNew = true;
						return pageToOpen.load();
					})
					.then(function() {
						timeLine && timeLine.step("loaded");
						if (pageToOpen.isNew) {
							// We restore the context only if pageToOpen has been destroyed and re-created
							if (!back && pageToOpen.isVignette && pageToClose == null) {
								// Restore the context of a page nested in a vignette after it has been loaded (only - pageToClose == null)
								// Ex: 	when we open a detail form a vignette we need to store the status (scroll, selection...) of the vignette to restore it on back
								savedContext = self.savedCtxVignette();
							} else if (back) {
								// Back in full page or vignette page - we restore context
								savedContext = pageToClose ? pageToClose.savedContext : null;
							}
						}
						self._pageActivate(pageToOpen, function() {
							timeLine && timeLine.step("activated");
							_success(pageToOpen, parentNotifInfo);
						}, back, savedContext);
					}).fail(function(e) {
						_fail(e);
					});
			} catch (e) {
				_fail(e);
			}
			return deferred.promise();
		},

		_pageActivate: function(pageToOpen, cb, back, savedContext) {
			var self = this;
			var pageToClose = self.getCurrentPage();
			// Destroy=true if the pageToClose has to be destroyed
			// We destroy the page if back or if pageToClose is not cached or if pageToOpen is a not child
			var destroy = pageToClose && (back === true || (pageToClose.getProp("cached") !== true && pageToOpen.isChild !== true));
			if (destroy && back !== true) {
				// Save context - Like pages is destroyed we need to save a context in current page to retrieve if on back navigation
				// Context object containt the context f current page and context of parent page for chaining
				pageToOpen.contextSave(pageToClose);
			}
			pageToOpen.activate(pageToClose, savedContext, function() {
				self.setCurrentPage(pageToClose, pageToOpen, destroy);
				if (cb) cb();
			});
		},

		/**
		 * CALLER INTERFACE BEGIN
		 */

		/* Methods MUST be implemented */
		historyPush: function(state) {
			this.callerInterface.historyPush(state);
		},

		waitStop: function() {
			this.callerInterface.waitStop();
		},

		waitStart: function() {
			this.callerInterface.waitStart();
		},

		getRootElmt: function() {
			return this.callerInterface.getRootElmt();
		},

		getCurrentPage: function() {
			return this.callerInterface.getCurrentPage();
		},
		savedCtxVignette: function() {
			var meth = this.callerInterface.savedCtxVignette;
			return meth ? meth() : null;
		},
		setCurrentPage: function(pageToClose, pageToOpen, destroy) {
			var self = this;
			if (pageToClose) {
				if (destroy === true) {
					pageToClose.destroy();
				} else {
					// Keep cached page only if not back - Ex: List -> Detail
					pageToClose.deactivate();
				}
			}
			self.callerInterface.setCurrentPage(pageToOpen);
		},
		/* Methods CAN be overridden */
		loadingError: function(deferred, state, e) {
			if (this.callerInterface.loadingError) {
				this.callerInterface.loadingError(deferred, state, e);
			} else {
				modal.error("Loading page [" + state.name + "] error", e, function() {
					deferred.reject(e);
				});
			}
		},
		succeeded: function(pageToOpen, parentNotifInfo) {
			var self = this;
			notifications.publish("sm.page.loaded", self.getCurrentPage());
			if (this.callerInterface.succeeded) {
				this.callerInterface.succeeded(pageToOpen, parentNotifInfo);
			}
		}
		/**
		 * CALLER INTERFACE END
		 */
	});

/**
 * window.history accepts only json object (no class/prototype based object)
 * We have to serialize/deserialize object contained by state
 */
var _stateSerialize = function(state) {
	if (!state || !state.options || !state.options.gadget) return state;
	// Object that represents the gadget data
	state.options.gadget = state.options.gadget.getJSON();
	return state;
};
var _stateDeserialize = function(state) {
	if (!state || !state.options || !state.options.gadget) return state;
	state.options.gadget = new Gadget(state.options.gadget);
	return state;
};

exports.stateSerialize = _stateSerialize;
exports.stateDeserialize = _stateDeserialize;
exports.Klass = _PageLoader;