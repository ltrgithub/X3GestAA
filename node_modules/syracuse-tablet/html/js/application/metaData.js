"use strict";

/*
 * This module should be used to access any kind of meta data
 * It either queries the local database or fetches the information
 * remotely and adds it to the local database
 *
 * Getting meta data is done in three levels for performance and maintainance reasons
 * 1 - In memory JS objects, once a piece of metadata has been read from level 2
 *     This level should be handled in this file
 * 2 - IndexedDB/WebSQL, persistent over restarts but slower than level 1
 *     This level should be handled in metaDataCache.js
 * 3 - Remote access to the server
 *     This level should be handled in metaDataCache.js
 */

var globals = require('syracuse-tablet/html/js/helpers/globals');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var metaDataCache = require('syracuse-tablet/html/js/application/metaDataCache');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("metaData");
var prototypeModule = require('syracuse-tablet/html/js/helpers/prototype');
var articleGen = require('syracuse-tablet/html/js/authoring/authoringArticleGen');

/**
 * Added to page class attribute to identify requests
 */
var _REQUEST_SUBTYPE = "query request";
var _STAT_SUBTYPE = "stat";
var _mobileDashSuffix = ".$mobileDashboard";
var _currentApplicationContext = {};
var _currentPrototypeContext = {};

// Applications depending on context
var _applications = null;
var _applicationDetails = {};
// Applications defined client side (always available)
var _applicationsStatic = {};

// Prototypes
var _prototypes = {};

/*
 *
 */
function _checkApplicationCtx() {
	var ctx = globals.getUserCtx();
	var endpoint = globals.getEndpoint();
	if (_currentApplicationContext.user != ctx.$user ||
		_currentApplicationContext.role != ctx.$role ||
		_currentApplicationContext.lang != ctx.$lang ||
		_currentApplicationContext.endpoint != endpoint) {
		_currentApplicationContext.user = ctx.$user;
		_currentApplicationContext.role = ctx.$role;
		_currentApplicationContext.lang = ctx.$lang;
		_currentApplicationContext.endpoint = endpoint;
		log && log("Application context changed to: " + JSON.stringify(_currentApplicationContext));
		_resetApplicationCache();
	}
}

/*
 *
 */
function _resetApplicationCache() {
	_applications = null;
	_applicationDetails = {};
}

function _readApplications(forceReadFromServer) {
	var deferred = $.Deferred();
	forceReadFromServer = forceReadFromServer && globals.isOnline();
	metaDataCache.getKnownApplications(_currentApplicationContext, forceReadFromServer).then(function(apps) {
		deferred.resolve(apps);
	}).fail(function(e) {
		if (forceReadFromServer === true && e && e.$noConnectionError === true) {
			// Try to read cached data to allow to build welcome page if no network connection 
			metaDataCache.getKnownApplications(_currentApplicationContext, false).then(function(apps) {
				deferred.resolve(apps);
			}).fail(function(e) {
				deferred.reject(e);
			});
		} else {
			deferred.reject(e);
		}
	});
	return deferred.promise();
}
/*
 *
 */
function _initApplications(forceReadFromServer) {
	log && log("Reading applications");
	var step = _readApplications(forceReadFromServer).then(function(apps) {
		var matchedApps = [];
		apps.forEach(function(app) {
			var epMatch = true;
			if (app.endpoints && app.endpoints.length > 0) {
				epMatch = epMatch && app.endpoints.some(function(ep) {
					return (ep.application + "." + ep.contract + "." + ep.dataset === _currentApplicationContext.endpoint);
				});
			}
			var roleMatch = true;
			if (globals.isDvlpMode()) {
				roleMatch = true;
			} else {
				if (app.roles && app.roles.length > 0 && epMatch) {
					roleMatch = roleMatch && app.roles.some(function(role) {
						return (role.code === _currentApplicationContext.role);
					});

				}
			}
			if (roleMatch && epMatch) {
				matchedApps.push(app);
			}
		});

		// Always add static resources
		Object.keys(_applicationsStatic).forEach(function(name) {
			matchedApps.push(_applicationsStatic[name].$application);
		});
		_applications = matchedApps;
		log && log("Number of applications: " + _applications.length);
	});
	// Scan version number after valid apps have been fetched
	return step.then(function() {
		return $.smForEachPromise(_applications, function(app) {
			return exports.getApplication(app.applicationName, true)
				.then(function(appData) {
					if (appData) {
						app.localVersionNumber = appData.$application.versionNumber; // This is the version number in the local cache
					} else {
						app.localVersionNumber = null; // Need to setup first
					}
				});
		});
	});
}

/*
 * Returns true if there is an update for this application
 */
exports.checkApplicationUpdate = function(appName) {
	var appHeader;
	return _getApplicationHeaderByName(appName)
		.then(function(_appHeader) {
			appHeader = _appHeader;
			return exports.getApplication(appName, true);
		})
		.then(function(appDetails) {
			if (!appDetails || !appHeader) { // not installed yet, so return false -> no update question to the user
				return false;
			}

			if (appHeader.versionNumber === appDetails.$application.versionNumber) {
				return false;
			}

			return true;
		});
};

/*
 *
 */
function _getApplicationHeaderByName(name) {
	var match = null;
	return $.smResolve()
		.then(function() {
			if (!_applications) {
				return _initApplications();
			}
		})
		.then(function() {
			_applications && _applications.some(function(app) {
				if (app.applicationName == name) {
					match = app;
					return true;
				}
			});
			return match;
		});
}

/*
 *
 */
exports.registerStaticApp = function(app) {
	if (!app || !app.$application) return;
	log && log("Register static application: " + app.$application.applicationName);
	app.isStaticApp = true;
	_applicationsStatic[app.$application.applicationName] = app;
};

/*
 * Return full details of requested application
 * name:
 * Name of application
 */
exports.getApplication = function(name, localOnly, forceUpdate) {
	// Application details already available?
	var app = forceUpdate !== true ? (_applicationsStatic[name] || _applicationDetails[name]) : null;
	if (app) {
		log && log("Application from cache: " + name);
		return $.smResolve(app);
	}
	return _getApplicationHeaderByName(name)
		.then(function(header) {
			if (header) {
				return metaDataCache.getApplication(header, _currentApplicationContext, localOnly, forceUpdate)
					.then(function(app) {
						if (app) {
							_applicationDetails[name] = app;
						}
						return app;
					})
					.then(function(app) {
						if (app && !localOnly) {
							$.each(_applications, function(idx, app1) {
								if (app1.applicationName === app.$application.applicationName) {
									app1.localVersionNumber = app.$application.versionNumber;
									app1.versionNumber = app.$application.versionNumber;
								}
							});
						}
						return app;
					});
			}
			log && log("Unknown application: " + name);
			return null;
		});
};

/*
 * Return all applications available for current context
 */
exports.getApplications = function(forceReadFromServer) {
	_checkApplicationCtx();
	if (_applications != null && forceReadFromServer !== true) {
		return $.smResolve(_applications);
	}
	return _initApplications(forceReadFromServer).then(function() {
		return _applications;
	});
};

exports.removeApplications = function() {
	return metaDataCache.removeApplications(_currentApplicationContext)
		.then(function() {
			_resetApplicationCache();
		});
};

/*
 *
 */
function _checkPrototypeCtx() {
	var ctx = globals.getUserCtx();
	var endpoint = globals.getEndpoint();
	if (_currentPrototypeContext.user != ctx.$user ||
		_currentPrototypeContext.role != ctx.$role ||
		_currentPrototypeContext.lang != ctx.$lang ||
		_currentPrototypeContext.endpoint != endpoint) {
		_currentPrototypeContext.user = ctx.$user;
		_currentPrototypeContext.role = ctx.$role;
		_currentPrototypeContext.lang = ctx.$lang;
		_currentPrototypeContext.endpoint = endpoint;
		log && log("Prototype context changed to: " + JSON.stringify(_currentPrototypeContext));
		_resetPrototypeCache();
	}
}

/*
 *
 */
function _resetPrototypeCache() {
	_prototypes = {};
}

/*
 * name:
 * application.protocol.dataset.representation.facet
 */
exports.getPrototype = function(name) {
	log && log("Getting prototype: " + name);
	var repr = name.split(".");
	if (repr.length < 5) { // Client side representations names are not fully qualified
		proto = clientContract.getPrototype(repr[0], repr[1]);
		log && log("Prototype (client side entitiy): " + name);
		return $.smResolve(proto);
	}

	_checkPrototypeCtx();
	var proto = _prototypes[name];
	if (proto) {
		return $.smResolve(proto);
	}
	var app = globals.getApplication();
	var appMetaData = app && app.dao && app.dao.appMetaData;
	var page = appMetaData && appMetaData.$pages && appMetaData.$pages[name];
	proto = page && page.$page && page.$page.$prototype;
	if (proto) {
		_prototypes[name] = proto;
		return $.smResolve(proto);
	}

	return metaDataCache.getPrototype(name, _currentPrototypeContext).then(function(proto) {
		log && log("Got prototype: " + name);
		_prototypes[name] = proto;
		return proto;
	});
};
/**
 * Update authoring of pageId in local database
 * The purpose is to avoid the reloading of the appplication each time we save an authoring (too long)
 * updatePageAuthoring is called by authoring after the article has been saved successfully in mongo DB
 */
exports.updatePageAuthoring = function(pageName, $article) {
	if (!pageName || !$article || $.isEmptyObject($article)) {
		return $.smResolve(false);
	}
	return $.smResolve().then(function() {
		var ctx = globals.getUserCtx();
		var endpoint = globals.getEndpoint();
		var cac = _currentApplicationContext;
		if (!cac || cac.user != ctx.$user || cac.role != ctx.$role || cac.lang != ctx.$lang || cac.endpoint != endpoint) {
			throw new Error("unexpected bad context");
		}
		var app = globals.getApplication();
		var isDashBoard = pageName.smEndsWith(_mobileDashSuffix);
		if (isDashBoard) {
			pageName = pageName.split(_mobileDashSuffix)[0];
		}
		var appMetaData = app && app.dao && app.dao.appMetaData;
		if (!appMetaData) {
			throw new Error("Unknown appMetaData " + pageName);
		}
		appMetaData = $.extend(true, {}, appMetaData);
		// Just to force the saving
		appMetaData.$etag = utils.UUID();
		// Array because there are dots inpage name
		var $path = isDashBoard ? ["$dashboards", pageName] : ["$pages", pageName, "$page"];
		var pageInfo = jsutils.getPropByPath(appMetaData, $path);
		if (!pageInfo) {
			throw new Error("Unknown page " + pageName);
		}
		pageInfo.$article = $.extend(true, {}, $article);
		if (_applicationsStatic[app.applicationName]) {
			_applicationsStatic[app.applicationName] = appMetaData;
			return $.smÃ¹ Resolmve(appMetaData);
		}
		return metaDataCache.updateApplicationDetail(appMetaData, ctx, endpoint).then(function() {
			if (_applicationDetails[app.applicationName]) {
				_applicationDetails[app.applicationName] = appMetaData;
			}
			// Dashboards are not cached
			app.dao.setApplication(appMetaData);
		});
	});
};

function _getDashboardByName(name) {
	var appMetaData = globals.getApplication().dao.appMetaData;
	var $dashboards = appMetaData.$dashboards;

	var dashboard;
	if (!Object.keys($dashboards).some(function(key) {
		dashboard = $dashboards[key];
		if (dashboard.$dashboardName === name) {
			return true;
		}
	})) {
		dashboard = null;
	};

	return dashboard;
}
/*
 * name:
 * Name of dashboard
 *
 * Returns full meta data of dashboard
 * Gadgets will be added in node $gadget of the dashboard data so that
 * there is no need to query the application later
 */
exports.getDashboard = function(name) {
	var appMetaData = globals.getApplication().dao.appMetaData;
	var $dashboards = appMetaData.$dashboards;

	var dashboard = _getDashboardByName(name);
	//console.log(name);
	//console.log(dashboard);
	return $.smResolve()
		.then(function() {
			if (dashboard) {
				if (dashboard && dashboard.$update) {
					return dashboard.$update(dashboard);
				} else {
					return dashboard;
				}
			}
		})
		.then(function(dashboard) {
			if (dashboard) {
				dashboard.$gadgets = dashboard.$gadgets || {};
				// Copy gadgets to dashboard
				if (appMetaData.$gadgets) {
					for (var vignette in dashboard.$vignettes) {
						var v = dashboard.$vignettes[vignette];
						if (appMetaData.$gadgets[v.$uuid]) {
							dashboard.$gadgets[v.$uuid] = appMetaData.$gadgets[v.$uuid];
						}
					}
				}
			}
			return dashboard;
		});
};

/*
 *
 */
exports.getDashboardPageName = function(dashboardName) {
	return dashboardName + _mobileDashSuffix;
};

/*
 * For the name of a page, get it's type (dashboard, regular =proto based, static =html based)
 * Also return some other flags like, cached page, etc...
 */
exports.getPageInfo = function(pageName) {
	return _getDashboardPageInfo(pageName)
		.then(function(pageInfo) {
			if (pageInfo) {
				return pageInfo;
			}
			return _getRegularPageInfo(pageName);
		});
};

function _getDashboardPageInfo(pageName) {
	if (!pageName.smEndsWith(_mobileDashSuffix)) {
		return $.smResolve(null);
	}
	var dashboardName = pageName.substring(0, pageName.length - 17);
	var dashboard = _getDashboardByName(dashboardName);
	if (!dashboard) {
		return $.smResolve(null);
	}
	var pageInfo = dashboard.$pageInfo || {};
	pageInfo.name = pageName;
	pageInfo.type = "dashboard";
	pageInfo.subtype = pageInfo.isWelcomePage ? "welcome" : "std";
	pageInfo.dashboardName = dashboard.$dashboardName;
	pageInfo.cached = false;
	pageInfo.refreshed = false;
	return $.smResolve(pageInfo);
}

function _getRegularPageInfo(pageName) {
	var appMetaData = globals.getApplication().dao.appMetaData;
	var $pages = appMetaData && appMetaData.$pages;
	var page = $pages && $pages[pageName];
	if (!page) {
		return $.smResolve(null);
	}

	var pageInfo = {
		name: pageName,
		home: false,
		type: "regular",
		subtype: "unknown",
		cached: false,
		refreshed: false
	};

	return $.smResolve(page.$page.$prototype)
		.then(function(prototype) {
			if (!prototype) {
				return exports.getPrototype(pageInfo.name);
			}
			return prototype;
		})
		.then(function(prototype) {
			if (prototype) {
				if (prototype.codeRequest != null) {
					// To confirm E Boyard
					pageInfo.subtype = _REQUEST_SUBTYPE;
				} else if (prototype.codeStat != null) {
					pageInfo.subtype = _STAT_SUBTYPE;
				} else {
					var facet = prototype.$type;
					if (!facet) {
						// if no type we take $url - in test representation  $type is not set
						facet = prototype.$url;
					}
					pageInfo.subtype = facet.substring(facet.lastIndexOf('.$') + 2);
					if (!pageInfo.subtype) {
						throw new Error("Unexpected facet for page " + pageName + "\n$url=" + prototype.$url);
					}
				}
			}
		})
		.then(function() {
			return pageInfo;
		});
}

/*
 * For a prototype based page, return article and prototype
 */
exports.getPageDetails = function(pageInfo) {
	var pageDetails;
	if (pageInfo.type === "regular") {
		return _getRegularPageDetails(pageInfo);
	}
	if (pageInfo.type === "rowdetail" || pageInfo.type === "carddesign" || pageInfo.type === "chartdetail") {
		return _getArrayChildPageDetails(pageInfo);
	}
	throw new Error("Unsupported page type: " + pageInfo.type);
};

function _getRegularPageDetails(pageInfo) {
	var pageDetails;
	var appMetaData = globals.getApplication().dao.appMetaData;
	var $pages = appMetaData && appMetaData.$pages;


	return $.smResolve().
	then(function() {
		// Get page from application meta data
		var page = $pages && $pages[pageInfo.name];
		if (page) {
			return {
				prototype: page.$page && page.$page.$prototype,
				article: page.$page && page.$page.$article,
				views: page.$page && page.$page.$views
			};
		}
	})
		.then(function(pageDetails) {
			if (!pageDetails) {
				// Check if this page is defined by a client side JS entity
				return clientContract.getRegularPageInfo(pageInfo.name)
					.then(function(page) {
						if (page) {
							return {
								prototype: page.$page && page.$page.$prototype,
								article: page.$page && page.$page.$article
							};
						}
					});
			}
			return pageDetails;
		})
		.then(function(pageDetails) {
			// Page not found in app meta data and not in client side contract, must be lazy loaded representation
			if (!pageDetails) {
				return exports.getPrototype(pageInfo.name)
					.then(function(proto) {
						if (proto) {
							return {
								prototype: proto,
							};
						}
					});
			}
			// Maybe there is an article on the client but prototype is comming from server
			if (!pageDetails.prototype) {
				return exports.getPrototype(pageInfo.name)
					.then(function(proto) {
						if (proto) {
							pageDetails.prototype = proto;
							return pageDetails;
						}
					});
			}
			return pageDetails;
		})
		.then(function(pageDetails) {
			if (pageDetails) {
				// Wrap prototype in class
				pageDetails.prototype = prototypeModule.create(pageDetails.prototype); //, parentProto)
			}
			return pageDetails;
		})
		.then(function(pageDetails) {
			if (pageDetails) {
				return _ensureRegularPageDetailsArticle(pageInfo, pageDetails)
					.then(function() {
						if (pageDetails.prototype && pageDetails.prototype.data("codeRequest") != null) {
							// To confirm E Boyard
							pageInfo.subtype = _REQUEST_SUBTYPE;
						}
						return pageDetails;
					});
			}
			// Page not found
			return null;
		});
}

function _getArrayChildPageDetails(pageInfo) {
	return $.smResolve()
		.then(function() {
			var pageDetails = {
				prototype: pageInfo.prototype,
				article: pageInfo.article
			};
			return _ensureRegularPageDetailsArticle(pageInfo, pageDetails)
				.then(function() {
					return pageDetails;
				});
		});
}

function _ensureRegularPageDetailsArticle(pageInfo, pageDetails) {
	// If !vignetteArticle we take the one of the pageDetails if any
	var article;
	var genArticle;
	var vignetteArticle = pageInfo.options.vignetteArticle;
	var emptyVignetteArticle = vignetteArticle && $.isEmptyObject(vignetteArticle);
	if (vignetteArticle && !emptyVignetteArticle) {
		// In dashboard page's article is given by the vignette (stored in in vignette's article
		article = vignetteArticle;
	} else {
		// Page article if any
		article = pageDetails.article;
	}
	if (article && !$.isEmptyObject(article)) {
		genArticle = $.smResolve(article);
	} else {
		genArticle = $.smResolve().then(function() {
			return articleGen.genNewArticle({
				page: {
					prototype: pageDetails.prototype
				}
			}).then(function(protoArticle) {
				article = protoArticle;
			});
		});
	}
	return genArticle.then(function() {
		if (emptyVignetteArticle) {
			//#6861 - !! we need to keep the same json object in order to be able to modify it by authoring
			// That means that in a dasboard all page article should be attached to the articel of the dasboard
			// So like we created a new article we need to keep the empty vignette object and copy all the properties or new article
			for (var p in article) {
				vignetteArticle[p] = article[p];
			}
			pageDetails.article = vignetteArticle;
		} else {
			pageDetails.article = article;
		}
		/**
		 * We add authoring properties of the page given by the vignette (E.g: actionsSettings...
		 * Doing this way we get the layout article form vignette or from generator and add these props after
		 */
		var vignetteAuthPageProps = pageInfo.options.vignetteAuthPageProps;
		if (!$.isEmptyObject(vignetteAuthPageProps)) {
			utils.authCopyPageProperties(vignetteAuthPageProps, pageDetails.article);
		}
	});
}