"use strict";

/*
 * This module should be used to access any kind of meta data
 * It either queries the local database or fetches the information
 * remotely and adds it to the local database
 *
 * Getting meta data is done in three levels for performance and maintainance reasons
 * 1 - In memory JS objects, once a piece of metadata has been read from level 2
 *     This level should be handled in this file
 * 2 - IndexedDB/WebSQL, persistent over restarts but slower than level 1
 *     This level should be handled in metaDataCache.js
 * 3 - Remote access to the server
 *     This level should be handled in metaDataCache.js
 */

var globals = require('syracuse-tablet/html/js/helpers/globals');
var clientContract = require('syracuse-tablet/html/js/sdata/entities/clientContract');
var metaDataCache = require('syracuse-tablet/html/js/application/metaDataCache');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("metaData");
var prototypeModule = require('syracuse-tablet/html/js/helpers/prototype');
var articleGen = require('syracuse-tablet/html/js/authoring/authoringArticleGen');

var _currentApplicationContext = {};
var _currentPrototypeContext = {};

// Applications depending on context
var _applications = null;
var _applicationDetails = {};
// Applications defined client side (always available)
var _applicationsStatic = {};

// Prototypes
var _prototypes = {};

/*
 *
 */
function _checkApplicationCtx() {
	var ctx = globals.getUserCtx();
	var endpoint = globals.getEndpoint();
	if (_currentApplicationContext.user != ctx.$user ||
		_currentApplicationContext.role != ctx.$role ||
		_currentApplicationContext.lang != ctx.$lang ||
		_currentApplicationContext.endpoint != endpoint) {
		_currentApplicationContext.user = ctx.$user;
		_currentApplicationContext.role = ctx.$role;
		_currentApplicationContext.lang = ctx.$lang;
		_currentApplicationContext.endpoint = endpoint;
		log && log("Application context changed to: " + JSON.stringify(_currentApplicationContext));
		_resetApplicationCache();
	}
}

/*
 *
 */
function _resetApplicationCache() {
	_applications = null;
	_applicationDetails = {};
}

/*
 *
 */
function _initApplications(forceReadFromServer) {
	log && log("Reading applications");
	var apps = metaDataCache.getKnownApplications(_currentApplicationContext, forceReadFromServer)
		.then(function(apps) {
			var matchedApps = [];
			apps.forEach(function(app) {
				var epMatch = true;
				if (app.endpoints && app.endpoints.length > 0) {
					epMatch = epMatch && app.endpoints.some(function(ep) {
						return (ep.application + "." + ep.contract + "." + ep.dataset === _currentApplicationContext.endpoint);
					});
				}
				var roleMatch = true;
				if (globals.isDvlpMode()) {
					roleMatch = true;
				} else {
					if (app.roles && app.roles.length > 0 && epMatch) {
						roleMatch = roleMatch && app.roles.some(function(role) {
							return (role.code === _currentApplicationContext.role);
						});

					}
				}
				if (roleMatch && epMatch) {
					matchedApps.push(app);
				}
			});

			// Always add static resources
			Object.keys(_applicationsStatic).forEach(function(name) {
				matchedApps.push(_applicationsStatic[name].$application);
			});
			_applications = matchedApps;
			log && log("Number of applications: " + _applications.length);
		});
	// Scan version number after valid apps have been fetched
	return apps.then(function() {
		return $.smForEachPromise(_applications, function(app) {
			return exports.getApplication(app.applicationName, true)
				.then(function(appData) {
					if (appData) {
						app.localVersionNumber = appData.$application.versionNumber; // This is the version number in the local cache
					} else {
						app.localVersionNumber = null; // Need to setup first
					}
				});
		});
	});
}

/*
 *
 */
function _getApplicationHeaderByName(name) {
	var match = null;
	return $.smResolve()
		.then(function() {
			if (!_applications) {
				return _initApplications();
			}
		})
		.then(function() {
			_applications && _applications.some(function(app) {
				if (app.applicationName == name) {
					match = app;
					return true;
				}
			});
			return match;
		});
}

/*
 *
 */
exports.registerStaticApp = function(app) {
	log && log("Register static application: " + app.$application.applicationName);
	_applicationsStatic[app.$application.applicationName] = app;
};

/*
 * Return full details of requested application
 * name:
 * Name of application
 */
exports.getApplication = function(name, localOnly) {
	// Application details already available?
	var app = _applicationsStatic[name] || _applicationDetails[name];
	if (app) {
		log && log("Application from cache: " + name);
		return $.smResolve(app);
	}
	return _getApplicationHeaderByName(name)
		.then(function(header) {
			if (header) {
				return metaDataCache.getApplication(header, _currentApplicationContext, localOnly).then(function(app) {
					_applicationDetails[name] = app;
					return app;
				});
			}
			log && log("Unknown application: " + name);
			return null;
		});
};

/*
 * Return all applications available for current context
 */
exports.getApplications = function(forceReadFromServer) {
	_checkApplicationCtx();
	if (_applications != null && forceReadFromServer !== true) {
		return $.smResolve(_applications);
	}
	return _initApplications(forceReadFromServer).then(function() {
		return _applications;
	});
};

exports.removeApplications = function() {
	return metaDataCache.removeApplications(_currentApplicationContext)
		.then(function() {
			_resetApplicationCache();
		});
};

/*
 *
 */
function _checkPrototypeCtx() {
	var ctx = globals.getUserCtx();
	var endpoint = globals.getEndpoint();
	if (_currentPrototypeContext.user != ctx.$user ||
		_currentPrototypeContext.role != ctx.$role ||
		_currentPrototypeContext.lang != ctx.$lang ||
		_currentPrototypeContext.endpoint != endpoint) {
		_currentPrototypeContext.user = ctx.$user;
		_currentPrototypeContext.role = ctx.$role;
		_currentPrototypeContext.lang = ctx.$lang;
		_currentPrototypeContext.endpoint = endpoint;
		log && log("Prototype context changed to: " + JSON.stringify(_currentPrototypeContext));
		_resetPrototypeCache();
	}
}

/*
 *
 */
function _resetPrototypeCache() {
	_prototypes = {};
}

/*
 * name:
 * application.protocol.dataset.representation.facet
 */
exports.getPrototype = function(name) {
	log && log("Getting prototype: " + name);
	var repr = name.split(".");
	if (repr.length < 5) { // Client side representations names are not fully qualified
		proto = clientContract.getPrototype(repr[0], repr[1]);
		log && log("Prototype (client side entitiy): " + name);
		return $.smResolve(proto);
	}

	_checkPrototypeCtx();
	var proto = _prototypes[name];
	if (proto) {
		return $.smResolve(proto);
	}
	var app = globals.getApplication();
	var appMetaData = app && app.dao && app.dao.appMetaData;
	var page = appMetaData && appMetaData.$pages && appMetaData.$pages[name];
	proto = page && page.$page && page.$page.$prototype;
	if (proto) {
		_prototypes[name] = proto;
		return $.smResolve(proto);
	}

	return metaDataCache.getPrototype(name, _currentPrototypeContext).then(function(proto) {
		log && log("Got prototype: " + name);
		_prototypes[name] = proto;
		return proto;
	});
};

function _getDashboardByName(name) {
	var appMetaData = globals.getApplication().dao.appMetaData;
	var $dashboards = appMetaData.$dashboards;

	var dashboard;
	if (!Object.keys($dashboards).some(function(key) {
		dashboard = $dashboards[key];
		if (dashboard.$dashboardName === name) {
			return true;
		}
	})) {
		dashboard = null;
	};

	return dashboard;
}
/*
 * name:
 * Name of dashboard
 *
 * Returns full meta data of dashboard
 * Gadgets will be added in node $gadget of the dashboard data so that
 * there is no need to query the application later
 */
exports.getDashboard = function(name) {
	var appMetaData = globals.getApplication().dao.appMetaData;
	var $dashboards = appMetaData.$dashboards;

	var dashboard = _getDashboardByName(name);
	//console.log(name);
	//console.log(dashboard);
	return $.smResolve()
		.then(function() {
			if (dashboard) {
				if (dashboard && dashboard.$update) {
					return dashboard.$update(dashboard);
				} else {
					return dashboard;
				}
			}
		})
		.then(function(dashboard) {
			if (dashboard) {
				dashboard.$gadgets = dashboard.$gadgets || {};
				// Copy gadgets to dashboard
				if (appMetaData.$gadgets) {
					for (var vignette in dashboard.$vignettes) {
						var v = dashboard.$vignettes[vignette];
						if (appMetaData.$gadgets[v.$uuid]) {
							dashboard.$gadgets[v.$uuid] = appMetaData.$gadgets[v.$uuid];
						}
					}
				}
			}
			return dashboard;
		});
};

/*
 *
 */
exports.getDashboardPageName = function(dashboardName) {
	return dashboardName + ".$mobileDashboard";
};

/*
 * For the name of a page, get it's type (dashboard, regular =proto based, static =html based)
 * Also return some other flags like, cached page, etc...
 */
exports.getPageInfo = function(pageName) {
	return _getDashboardPageInfo(pageName)
		.then(function(pageInfo) {
			if (pageInfo) {
				return pageInfo;
			}
			return _getRegularPageInfo(pageName);
		});
};

function _getDashboardPageInfo(pageName) {
	if (!pageName.smEndsWith(".$mobileDashboard")) {
		return $.smResolve(null);
	}
	var dashboardName = pageName.substring(0, pageName.length - 17);
	var dashboard = _getDashboardByName(dashboardName);
	if (!dashboard) {
		return $.smResolve(null);
	}
	var pageInfo = dashboard.$pageInfo || {};
	pageInfo.name = pageName;
	pageInfo.type = "dashboard";
	pageInfo.subtype = pageInfo.isWelcomePage ? "welcome" : "std";
	pageInfo.dashboardName = dashboard.$dashboardName;
	pageInfo.cached = false;
	pageInfo.refreshed = false;
	pageInfo.changeHash = false;

	return $.smResolve(pageInfo);
}

function _getRegularPageInfo(pageName) {
	var appMetaData = globals.getApplication().dao.appMetaData;
	var $pages = appMetaData && appMetaData.$pages;
	var page = $pages && $pages[pageName];
	if (!page) {
		return $.smResolve(null);
	}

	var pageInfo = {
		name: pageName,
		home: false,
		type: "regular",
		subtype: "unknown",
		cached: false,
		refreshed: false,
		changeHash: false,
	};

	return $.smResolve(page.$page.$prototype)
		.then(function(prototype) {
			if (!prototype) {
				return exports.getPrototype(pageInfo.name);
			}
			return prototype;
		})
		.then(function(prototype) {
			if (prototype) {
				var facet = prototype.$type;
				if (!facet) {
					// if no type we take $url - in test representation  $type is not set
					facet = prototype.$url;
				}
				pageInfo.subtype = facet.substring(facet.lastIndexOf('.$') + 2);
				if (!pageInfo.subtype) {
					throw new Error("Unexpected facet for page " + pageName + "\n$url=" + prototype.$url);
				}
			}
		})
		.then(function() {
			return pageInfo;
		});
}

/*
 * For a prototype based page, return article and prototype
 */
exports.getPageDetails = function(pageInfo) {
	var pageDetails;
	if (pageInfo.type === "regular") {
		return _getRegularPageDetails(pageInfo);
	}
	if (pageInfo.type === "rowdetail" || pageInfo.type === "carddesign" || pageInfo.type === "chartdetail") {
		return _getArrayChildPageDetails(pageInfo);
	}
	throw new Error("Unsupported page type: " + pageInfo.type);
};

function _getRegularPageDetails(pageInfo) {
	var pageDetails;
	var appMetaData = globals.getApplication().dao.appMetaData;
	var $pages = appMetaData && appMetaData.$pages;


	return $.smResolve().
	then(function() {
		// Get page from application meta data
		var page = $pages && $pages[pageInfo.name];
		if (page) {
			return {
				prototype: page.$page && page.$page.$prototype,
				article: page.$page && page.$page.$article
			};
		}
	})
		.then(function(pageDetails) {
			if (!pageDetails) {
				// Check if this page is defined by a client side JS entity
				return clientContract.getRegularPageInfo(pageInfo.name)
					.then(function(page) {
						if (page) {
							return {
								prototype: page.$page && page.$page.$prototype,
								article: page.$page && page.$page.$article
							};
						}
					});
			}
			return pageDetails;
		})
		.then(function(pageDetails) {
			// Page not found in app meta data and not in client side contract, must be lazy loaded representation
			if (!pageDetails) {
				return exports.getPrototype(pageInfo.name)
					.then(function(proto) {
						if (proto) {
							return {
								prototype: proto,
							};
						}
					});
			}
			// Maybe there is an article on the client but prototype is comming from server
			if (!pageDetails.prototype) {
				return exports.getPrototype(pageInfo.name)
					.then(function(proto) {
						if (proto) {
							pageDetails.prototype = proto;
							return pageDetails;
						}
					});
			}
			return pageDetails;
		})
		.then(function(pageDetails) {
			if (pageDetails) {
				// Wrap prototype in class
				pageDetails.prototype = prototypeModule.create(pageDetails.prototype); //, parentProto)
			}
			return pageDetails;
		})
		.then(function(pageDetails) {
			if (pageDetails) {
				return _ensureRegularPageDetailsArticle(pageInfo, pageDetails)
					.then(function() {
						return pageDetails;
					});
			}
			// Page not found
			return null;
		});
}

function _getArrayChildPageDetails(pageInfo) {
	return $.smResolve()
		.then(function() {
			var pageDetails = {
				prototype: pageInfo.prototype,
				article: pageInfo.article
			};
			return _ensureRegularPageDetailsArticle(pageInfo, pageDetails)
				.then(function() {
					return pageDetails;
				});
		});
}

function _ensureRegularPageDetailsArticle(pageInfo, pageDetails) {
	// If !vignetteArticle we take the one of the pageDetails if any
	var article;
	var genArticle;
	// For dashboard the article of the vignette can be defined in the article of the dashboard
	var vignetteArticle = pageInfo.options.vignetteArticle;

	if (!vignetteArticle) { // Not a vignette, so we can use article of full page
		article = pageDetails.article;
	} else if (vignetteArticle && $.isEmptyObject(vignetteArticle)) { // Vignette but no article given by dashboard -> use page article or create one
		article = pageDetails.article;;
	} else if (vignetteArticle && !$.isEmptyObject(vignetteArticle)) { // Vignette andarticle given by dashboard -> use it
		article = vignetteArticle;
	}
	if (article && !$.isEmptyObject(article)) {
		genArticle = $.smResolve(article);
	} else {
		genArticle = $.smResolve().then(function() {
			return articleGen.genNewArticle({
				page: {
					prototype: pageDetails.prototype
				}
			}).then(function(protoArticle) {
				article = protoArticle;
			});
		});
	}
	return genArticle.then(function() {
		pageDetails.article = article;
	});
}