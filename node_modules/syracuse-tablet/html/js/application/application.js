"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var modal = require('syracuse-tablet/html/js/ui/modal');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("app");
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var auth = require('syracuse-tablet/html/js/application/authentication');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var pageLoader = require('syracuse-tablet/html/js/application/pageLoader');
var initContext = require('syracuse-tablet/html/js/init/initContext');
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var pageRegistry = require('syracuse-tablet/html/js/application/pageRegistry');
var authoring = require('syracuse-tablet/html/js/authoring/authoring');
var developmentPage = require('syracuse-tablet/html/js/ui/developmentPage');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var settings = require('syracuse-tablet/html/js/application/settings');

/**
 * Default application config
 */
var _appConfig = {
	transition: null,
	// FDB - openLinkInVignette=true to allow test in vignettes (children page, lookup...)
	// MW - Changed to false as default since this is more what we are going to use.
	openLinkInVignette: false,
	// FK - to allow display of user photo
	loadUserImage: true
};
/**
 * Subscriptions
 */
var _subscribe = function(self) {
	notifications.subscribe(self, ["sm.context.changed", "sm.switch.app", "sm.modal.open", "sm.modal.close", "sm.main.layout.changed"], 1);
};
/**
 * Tablet application class
 */
var _Application = utils.defineClass(
	function($$elmt, factory) {
		var self = this;
		self.$$elmt = $$elmt;
		self.currentPage = null;
		self._$config = $.extend(true, {}, _appConfig);
		self.factory = factory;
		self._pageLoader = null;
		self._nbModals = 0;
		self._wait = uiutils.waitWheelCreate($$elmt);
		// Id of the home dashboard of current application
		// Used to go to home page
		self.homePageId = null;
		// Default appid when login page is loaded without current application
		self.uuid = "root";
		// Application history stack
		self.history = [];
		// Force pushState on first page
		self.pushState = true;
	}, null, {
		/**
		 * Called after object has been created
		 **/
		init: function() {
			var self = this;
			// Can't be called in constructor
			eventListener.bindEvents(self);
			self.dao = self.factory.createDaoApp(self);
			_subscribe(self);
			self.$$elmt.show();
		},

		destroy: function() {
			var self = this;
			if (self._wait) uiutils.waitWheelDestroy(self._wait);
			notifications.unsubscribe();
			self.removeAllChildPages(self.$$elmt);
			self.currentPage = null;
			if (self._pageLoader == null) {
				self._pageLoader.destroy();
				self._pageLoader = null;
			}
			utils.unbindObj(self);
			utils.unbindObj(self.$$elmt);
			$(window).unbind();
		},
		/**
		 * True if current 'mobile application' is welcome application
		 */
		isWelcomeApplication: function() {
			return this.uuid === "$welcomeApplication";
		},
		/**
		 * For page display
		 */
		getTitle: function() {
			return this.dao.getApplicationTitle();
		},
		/**
		 * Goto home page of current 'mobile application'
		 */
		gotoHome: function() {
			var self = this;
			setTimeout(function() {
				self.changePage(self.homePageId);
			});
		},
		/**
		 * Accept path like "array.gridMaxCols"
		 */
		$config: function(id) {
			return utils.getPropByPath(this._$config, id, this._$config);
		},
		/**
		 * User, role, endpoint or language changed
		 * !! resolve/reject deferred is not null
		 * -> deferred used to catch error in transition phase - before page has been loaded
		 */
		notifContextChanged: function(deferred) {
			this.gotoWelcomeApplication(deferred);
		},

		notifModalOpen: function() {
			this._nbModals++;
			log && log("notifModalOpen nbModals=" + this._nbModals);
		},

		notifModalClose: function() {
			this._nbModals = Math.max(this._nbModals - 1, 0);
			log && log("notifModalClose nbModals=" + this._nbModals);
		},
		/**
		 * info - sizes of application and main page components header/footer/content - see siteLayout
		 * 		application.width	Application width
		 * 		application.weight	Application height
		 * 		content.width		Main page content width
		 * 		content.height		Main page content height
		 * 		...footer and header
		 * orientation	portrait/landscape
		 */
		notifMainLayoutChanged: function(info, orientation, deviceClass) {
			var self = this;
			//	self.orientation = orientation;
			// Container including header, content, footer
			// Set fixed with/height for application
			self.$$elmt.width(info.application.width);
			self.$$elmt.height(info.application.height);
			if (self.currentPage) {
				self.currentPage.onMainPageResize(info, orientation, deviceClass);
			}
		},
		/**
		 * Application can be scrolled (native scroll) in authoring mode
		 */
		getScrollOffset: function() {
			return {
				top: this.$$elmt.scrollTop(),
				left: this.$$elmt.scrollLeft()
			};
		},
		hasModalOpen: function() {
			log && log("_nbModals=" + this._nbModals);
			return this._nbModals > 0;
		},

		_actGotoWelcomeApplication: function() {
			this.gotoWelcomeApplication();
		},
		_actLogout: function(actionName) {
			this.logout();
		},
		/**
		 * Called by link with data-action = historyBack
		 */
		_actHistoryBack: function() {
			window.history.back();
		},
		// Switch role, endpoint, language
		_actSwitchContext: function() {
			var self = this;
			initContext.init(true, true).then(function(context) {}).fail(function(e) {
				modal.error("Switch context error", e);
			});
		},
		_actDevelopmentPage: function() {
			developmentPage.show();
		},
		_actClearCache: function() {
			var self = this;

			return globals.getModal().simpleConfirmPromise({
				message: locale.text("confirm.clear.cache.msg")
			})
				.then(function(confirm) {
					if (confirm.action === "yes") {
						self.waitWheelStart();
						return globals.getCache().clearCache();
					}
				}).
			then(function(e) {
				self.waitWheelStop();
				var notify = {
					severityClass: "success",
					title: "",
					body: locale.text("notify.clear.cache.ok")
				};
				globals.getModal().notify(notify);
			})
				.fail(function(e) {
					self.waitWheelStop();
					setTimeout(function() {
						modal.error("Clear cache error", e, function() {
							self.waitWheelStop();
						});
					}, 10);
				});

		},
		_actDesignPage: function() {
			authoring.toggleDesignPage();
		},
		/**
		 * Open about page
		 */
		_actAbout: function() {
			this.changePage("about", {});
		},
		/**
		 * User has selected a new Syracuse mobile application
		 * appInfo json description of application
		 */
		notifSwitchApp: function(appName) {
			var self = this;
			globals.getMetaData().getApplication(appName).then(function(appDetails) {
				self._setCurrentApplication(appDetails);
			});
		},

		/**
		 * Goto tablet applications home page  - Welcome dashboard
		 * deferred to resolve/reject in not null - used by asynchronous calls
		 * Ex: For login page we display the error in login page instead of modal
		 */
		gotoWelcomeApplication: function(deferred) {
			var self = this;
			if (globals.isLoggedIn()) {
				globals.getMetaData().getApplication("$welcomeApplication").then(function(appDetails) {
					self._setCurrentApplication(appDetails, {
						deferred: deferred
					});
				});
			} else {
				if (deferred) {
					deferred.resolve();
				}
				this.gotoLogin();
			}
		},
		/**
		 * Goto login page
		 */
		gotoLogin: function(reason) {
			var self = this;
			// !!When we display login we always reset applications status (clear existing pages and history)
			// goback to last opened page is not implemented
			self.historyReset();
			setTimeout(function() {
				self.changePage("login", {
					reason: reason || locale.text("login.authentication")
				});
			}, 0);
		},
		/**
		 * Set the current 'mobile application'
		 * Called after a switch context (application selection) or when tablet application is launched
		 * 'Welcome dashboard' page is a real application with only one dashboard
		 * options
		 * {
		 *    deferred: deferred to resolve/reject if not null - used by asynchronous calls to be notified
		 *    noPageChange: Don't change to application home dashboard
		 * }
		 *
		 */
		_setCurrentApplication: function(appInfo, options) {
			var self = this;

			options = options || {};
			var deferred = options.deferred;

			var _fail = function(msg, e) {
				self.waitWheelStop();
				if (deferred) {
					deferred.reject(e);
				} else {
					modal.error(msg, e, function() {
						if (self.currentPage) self.currentPage.activate();
					});
				}
			};
			var _success = function(appDetail) {
				try {
					self.waitWheelStop();
					if (!appDetail.$application.$uuid) throw new Error("No application $uuid - " + appDetail.applicationName);
					if (self.uuid !== appDetail.$application.$uuid) {
						// Application changed
						self.dao.setApplication(appDetail);
						self.homePageId = globals.getMetaData().getDashboardPageName(self.dao.getHomeDashboardName());
						self.uuid = appDetail.$application.$uuid;
					}
					if (options.noPageChange !== true) {
						self.gotoHome();
					}
					if (deferred) {
						deferred.resolve();
					}
				} catch (e) {
					_fail("Error loading new application", e);
				}
			};
			try {
				if (!appInfo) {
					throw new Error("Null appInfo");
				}
				log && log("Switch to Syracuse Mobile Application " + appInfo.applicationName);
				if (self.currentPage) {
					self.currentPage.deactivate();
				}
				self.waitWheelStart();
				_success(appInfo);
			} catch (e) {
				_fail("Error switching application", e);
			}
		},
		/**
		 * Open a page
		 * !! Do not call directly - Use changePage
		 */
		_gotoPage: function(state, back) {
			var self = this;
			if (!self._pageLoader) {
				self._pageLoader = self._createPageLoader();
			}
			/**
			 * Page loader shared with vignette
			 * Load a page
			 */
			if (state.isLogin === false && !globals.isLoggedIn()) {
				self.gotoLogin("Authentication is required");
				return $.smResolve();
			} else {
				return self._pageLoader.load(state, back);
			}
		},

		_createPageLoader: function() {
			var self = this;
			var loader = new pageLoader.Klass({
				waitStop: function() {
					self.waitWheelStop();
				},
				getRootElmt: function() {
					return self.$$elmt;
				},
				waitStart: function() {
					self.waitWheelStart();
				},
				getCurrentPage: function() {
					return self.currentPage;
				},
				setCurrentPage: function(page) {
					self.currentPage = page;
					if (page.state.isLogin === true) {
						self.historyReset(page);
					} else if (self.isWelcomeApplication()) {
						if (page.state.isHomeDashboard) {
							self.historyReset(page);
						}
					} else if (page.state.name === self.homePageId) {
						// Destroy all cached pages except current home page
						log && log("Home page " + self.homePageId + " - Destroy all pages except current");
						self.removeAllChildPages(self.$$elmt, page);
					}
				},
				historyPush: function(state) {
					self.history.push(state);
					// Refresh browser history to keep only one page in history for tablet application
					if (self.pushState) {
						window.history.pushState({
							x: new Date()
						}, utils.UUID(), null);
					} else {
						window.history.replaceState({
							x: new Date()
						}, utils.UUID(), null);
					}
					// self.historyLog("historyPush");
				},
				succeeded: function(dstPage, parentNotifInfo, back) {
					log && log("succeeded" + " - win=" + window.history.length + " - app=" + self.history.length);
					uiutils.triggerResizeInternal();
					if (parentNotifInfo && parentNotifInfo.notifId) {
						/**
						 * If the child application wants to notify the parent it should return info for notification
						 * parentNotifInfo contain :
						 * 		notifId:  	with the notification id
						 * 		notifData: 	with data  needed for processing this event
						 * 		controlId: 	If action as been trigered by a control
						 * 		parentId: 	id of the page
						 */
						var pageToNotify = dstPage.id === parentNotifInfo.parentId ? dstPage : null;
						if (pageToNotify == null && dstPage.isDashboard() != null) {
							// We can display a lookup full page for an edit displayed in a vignette
							pageToNotify = (dstPage.findVignettePage(parentNotifInfo.parentId) || {}).page;
						}
						if (pageToNotify) {
							notifications.pageNotify(parentNotifInfo.notifId, pageToNotify, parentNotifInfo.notifData, parentNotifInfo.controlId);
						} else {
							modal.error("Child page notification warning", "Parent page is not the current page");
						}
					}
				}
			});

			return loader;
		},

		historyReset: function(page) {
			// Destroy all cached pages except page parameter
			this.removeAllChildPages(this.$$elmt, page);
			this.history = [];
		},
		/**
		 * Call cb(state)
		 * Stop if cb returns true
		 */
		historyScan: function(cb) {
			for (var i = this.history.length - 1; i >= 0; i--) {
				if (cb(this.history[i]) === true) break;
			}
		},
		historyLog: function(title) {
			console.log(title);
			this.historyScan(function(state) {
				console.log("\t", state.name);
			});
		},
		/**
		 * Called by browser history.back
		 * !! never call this method directlty - Call window.back - except if we want to be notified with cb callback
		 * cb is a function if we want to be notified whe the page has been loaded
		 * 	- by example to display a message
		 * pageFilter callback to select the targetPage
		 * 		If pageFilter == null goto previous page
		 * 		pageFilter(pageState)
		 * 		returns true/false
		 * 		If true goto a selected page
		 * 		if false  back is canceled
		 *
		 */
		historyPop: function(event, cb, pageFilter) {
			try {
				var self = this;
				log && log("History pop before" + " - win=" + window.history.length + " - app=" + self.history.length);
				// No back if a modal is open
				if (self._nbModals > 0) {
					if (event) {
						event.preventDefault();
					}
					return;
				}
				if (self.uuid === "root" || self.history.length === 0) {
					// No application has been loaded - Goto previous browser history
					// ?? return without preventDefault doesn't continue back action on browser side
					// -> We repost a back
					window.history.back();
					return;
				}
				if (pageFilter && self.history.length > 0) {
					var selectedIdx = -1;
					for (var i = self.history.length - 1; i >= 0; i--) {
						if (pageFilter(self.history[i])) {
							selectedIdx = i;
							break;
						}
					}
					if (selectedIdx < 0) {
						if (event) {
							event.preventDefault();
						}
						return;
					}
					while (self.history.length > (selectedIdx + 2)) {
						var state = self.history.pop();
						var pageToRemove = $("#" + state.uuid).smPageController();
						if (pageToRemove) {
							pageToRemove.destroy();
						}
					}
				}
				// Remove current state
				var state = self.history.length > 0 ? self.history.pop() : null;
				if (state && (state.isWelcomePage || state.isLogin)) {
					// Homepage if login or welcome
					// ?? return without preventDefault doesn't continue back action on browser side
					// -> We repost a back

					// MW 2015-02-9 commented since it caused a double back action
					//window.history.back();
					return;
				} else {
					// Get previous state
					state = self.history.length > 0 ? self.history[self.history.length - 1] : null;
				}
				if (event) {
					event.preventDefault();
				}
				// Force pushState on display page - Last state has been removed
				self.pushState = true;
				// self.historyLog("historyPop");
				// Open page
				if (state) {
					setTimeout(function() {
						var promise;
						if (state.isWelcomePage) {
							var deferred = $.Deferred();
							self.gotoWelcomeApplication(deferred);
							promise = deferred.promise();
						} else {
							promise = self._gotoPage(state, true);
						}
						if (cb) cb(promise);
					}, 0);
				}
			} catch (e) {
				modal.error("historyPop error", e, function() {
					if (cb) cb($.smReject(e));
				});
			}
		},
		/**
		 * Goto to previous page if any
		 * pageFilter == null	-> Goto to previous page
		 * pageFilter != null	-> Goto to selected page  - see historyPop
		 *
		 */
		goBack: function(pageFilter) {
			var deferred = $.Deferred();
			this.historyPop(null, function(promise) {
				if (promise) {
					promise.then(function(newPage) {
						deferred.resolve(newPage);
					}).fail(function(e) {
						deferred.reject(e);
					});
				} else {
					deferred.resolve();
				}
			}, pageFilter);
			return deferred.promise();
		},
		/** 
		 * pageName - name of the page
		 * option - Option override standard pageInfo and allows to store a context
		 * {
		 *   applicationName: allows to switch application before changing page
		 * }
		 **/
		changePage: function(pageName, options) {
			var self = this;
			var changeApp;

			if (options && options.applicationName) {
				var curApp = self.dao && self.dao.getApplicationName();
				if (curApp !== options.applicationName) {
					changeApp = $.Deferred();
					globals.getMetaData().getApplication(options.applicationName).then(function(appDetails) {
						self._setCurrentApplication(appDetails, {
							deferred: changeApp,
							noPageChange: true
						});
					});
				}
			}

			// If there is no application change going on, we just resolve to quickly change the page
			if (!changeApp) {
				changeApp = $.smResolve();
			}
			return changeApp
				.then(function() {
					return pageRegistry.getPageInfo(pageName, options, self.currentPage);
				})
				.then(function(pageInfo) {
					return self._gotoPage(pageInfo);
				});
		},

		logout: function() {
			var deferred = $.Deferred();
			var self = this;
			var _loggedOut = function() {
				log && log("User Logged out");
				globals.setUserCtx(null);
				deferred.resolve();
				self.gotoLogin("You have been logged out");
			};
			self.waitWheelStart();
			auth.logout().then(function(ok, message) {
				self.waitWheelStop();
				if (ok) {
					_loggedOut();
				} else {
					modal.error(message, function() {
						_loggedOut();
					});
				}
			}).fail(function(e) {
				self.waitWheelStop();
				modal.error("Logout error", e, function() {
					_loggedOut();
				});
			});
			return deferred.promise();
		},

		/**
		 * Refresh current page - called from eventListener
		 */
		refreshPage: function(options) {
			var self = this;
			if (!self.currentPage) throw new Error("No current page");
			self.currentPage.refresh(options).then(function() {
				//	Eventually do something in vignette control	
			}).fail(function(e) {
				self.modalError("Refresh page", e);
			});
		},
		/**
		 * One waiting plugin per page
		 */
		waitWheelStart: function() {
			uiutils.waitWheelStart(this._wait);
		},
		waitWheelStop: function() {
			uiutils.waitWheelStop(this._wait);
		},
		/**
		 * Also exported in globals
		 */
		modalError: function(title, e, cb) {
			modal.error(title, e, cb);
		},
		getMessageSlot: function() {
			// tablet or smartphone
			if (!this._$$actMsgSlot) this._$$actMsgSlot = {};
			var deviceType = globals.getSiteLayout().getDeviceType();
			if (this._$$actMsgSlot[deviceType]) return this._$$actMsgSlot[deviceType];
			var $$slot = this._$$actMsgSlot[deviceType] = $("<div>").addClass("s-m-act-msg-slot").addClass(deviceType);
			(deviceType !== "tablet" && this.currentPage ? this.currentPage.$$contentElmt : this.$$elmt).prepend($$slot);
			return $$slot;
		},
		_actPinPage: function() {
			var self = this;
			var page = self.currentPage;
			var unpin = false;
			settings.isPinnedPage(page.getPinPageId())
				.then(function(isPinned) {
					var message;
					if (isPinned) {
						unpin = true;
						message = locale.text("pin.page.remove.confirm");
					} else {
						message = locale.text("pin.page.add.confirm");
					}
					return globals.getModal().simpleConfirmPromise({
						message: message
					});
				})
				.then(function(confirm) {
					if (confirm.action === "yes") {
						var pageData = page.getPinPageData(pageData); // allow to add information by subclasses
						if (unpin) {
							return settings.removePinnedPage(pageData.id)
								.then(function() {
									var notify = {
										severityClass: "success",
										title: "",
										body: locale.text("pin.page.remove.ok", [pageData.title]),
									};
									globals.getModal().notify(notify);
									notifications.publish("sm.page.pin.state.change", 1);
								});
						} else {
							// Save full context
							pageData.applicationName = self.dao.getApplicationName();
							pageData.endpoint = globals.getEndpoint();
							return settings.addPinnedPage(pageData)
								.then(function() {
									var notify = {
										severityClass: "success",
										title: "",
										body: locale.text("pin.page.add.ok", [pageData.title]),
									};
									globals.getModal().notify(notify);
									notifications.publish("sm.page.pin.state.change", 2);
								});
						}
					}
				})
				.fail(function(e) {
					globals.getModal().error(e);
				});
		},

		removeAllChildPages: function($$elmt) {
			if (!$$elmt) return;
			if (!$$elmt.jquery) $$elmt = $($$elmt);
			var exclude = Array.prototype.slice.call(arguments, 1);
			$$elmt.children(".s-m-page").each(function(idx) {
				var page = $(this).smPageController();
				if (page && Array.prototype.indexOf.call(exclude, page) == -1) {
					page.destroy();
				}
			});
		}
	});


exports.Application = _Application;