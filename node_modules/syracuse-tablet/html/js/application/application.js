"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("app");
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var auth = require('syracuse-tablet/html/js/application/authentication');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var pageLoader = require('syracuse-tablet/html/js/application/pageLoader');
var initContext = require('syracuse-tablet/html/js/init/initContext');
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var pageRegistry = require('syracuse-tablet/html/js/application/pageRegistry');
var authoring = require('syracuse-tablet/html/js/authoring/authoring');
var developmentPage = require('syracuse-tablet/html/js/ui/developmentPage');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var settings = require('syracuse-tablet/html/js/application/settings');
var modalShowLegal = require('syracuse-tablet/html/js/ui/modals/modalShowLegal');
var modalSettings = require('syracuse-tablet/html/js/ui/modals/modalSettings');
var modalConfirm = require('syracuse-tablet/html/js/ui/modals/modalConfirm');
var nativeLiveTile = require('syracuse-tablet/html/js/helpers/native/nativeLiveTile');
var nativeShare = require('syracuse-tablet/html/js/helpers/native/nativeShare');
var nativeApp = require('syracuse-tablet/html/js/helpers/native/nativeSageX3WUPApp');
/**
 * Default application config
 */
var _appConfig = {
	transition: null,
	// FDB - openLinkInVignette=true to allow test in vignettes (children page, lookup...)
	// MW - Changed to false as default since this is more what we are going to use.
	openLinkInVignette: false,
	// FK - to allow display of user photo
	loadUserImage: true
};
/**
 * Subscriptions
 */
var _subscribe = function(self) {
	notifications.subscribe(self, ["sm.switch.app", "sm.modal.open", "sm.modal.close", "sm.main.layout.changed", "sm.user.logged.in"], 1);
};
/**
 * Tablet application class
 */
var _Application = utils.defineClass(
	function($$elmt, factory) {
		this.$$elmt = $$elmt;
		this.currentPage = null;
		this._$config = $.extend(true, {}, _appConfig);
		this.factory = factory;
		this._pageLoader = null;
		this._nbModals = 0;
		this._wait = uiutils.waitWheelCreate($$elmt);
		// Id of the home dashboard of current application
		// Used to go to home page
		this.homePageId = null;
		// Default appid when login page is loaded without current application
		this.uuid = "root";
		// Application history stack
		this.history = [];
		// Force pushState on first page
		this.pushState = true;
	}, null, {
		/**
		 * Called after object has been created
		 **/
		init: function() {
			// Can't be called in constructor
			eventListener.bindEvents(this);
			this.dao = this.factory.createDaoApp(this);
			_subscribe(this);
			this.$$elmt.show();
		},

		destroy: function() {
			authoring.destroy();
			if (this._wait) {
				uiutils.waitWheelDestroy(this._wait);
				this._wait = null;
			}
			if (this.currentPage) {
				this.currentPage.destroy();
				this.currentPage = null;
			}
			if (this.$$elmt) {
				this.removeAllChildPages(this.$$elmt);
				this.$$elmt.unbind();
				this.$$elmt.remove();
				this.$$elmt = null;
			}
			if (this.dao) {
				this.dao.destroy();
				this.dao = null;
			}
			if (this._pageLoader) {
				this._pageLoader.destroy();
				this._pageLoader = null;
			}
			notifications.unsubscribe();
			$(window).unbind();
		},
		// Called on page unload
		onUnload: function() {
			this.destroy();
		},
		// Called on page onBeforeUnload - We have time to call processes
		onBeforeUnload: function() {
			if (nativeApp.isSageX3WUPApp()) {
				nativeApp.notifUnloaded(this._getHistoryContext());
			}
		},
		/**
		 * True if current 'mobile application' is welcome application
		 */
		isWelcomeApplication: function() {
			return this.uuid === "$welcomeApplication";
		},
		/**
		 * For page display
		 */
		getTitle: function() {
			return this.dao.getApplicationTitle();
		},
		/**
		 * Goto home page of current 'mobile application'
		 */
		gotoHome: function() {
			var self = this;
			var deferred = $.Deferred();
			setTimeout(function() {
				self.changePage(self.homePageId).then(function() {
					deferred.resolve();
				}).fail(function(e) {
					deferred.reject(e);
				});
			});
			return deferred.promise();
		},
		/**
		 * Accept path like "array.gridMaxCols"
		 */
		$config: function(id) {
			return utils.getPropByPath(this._$config, id);
		},

		notifModalOpen: function() {
			this._nbModals++;
			log && log("notifModalOpen nbModals=" + this._nbModals);
		},

		notifModalClose: function() {
			this._nbModals = Math.max(this._nbModals - 1, 0);
			log && log("notifModalClose nbModals=" + this._nbModals);
		},
		/**
		 * info - sizes of application and main page components header/footer/content - see siteLayout
		 * 		application.width	Application width
		 * 		application.weight	Application height
		 * 		content.width		Main page content width
		 * 		content.height		Main page content height
		 * 		...footer and header
		 * orientation	portrait/landscape
		 */
		notifMainLayoutChanged: function(info, orientation, deviceClass) {
			var self = this;
			//	self.orientation = orientation;
			// Container including header, content, footer
			// Set fixed with/height for application
			self.$$elmt.width(info.application.width);
			self.$$elmt.height(info.application.height);
			if (self.currentPage) {
				self.currentPage.onMainPageResize(info, orientation, deviceClass);
			}
		},
		/**
		 * Application can be scrolled (native scroll) in authoring mode
		 */
		getScrollOffset: function() {
			return {
				top: this.$$elmt.scrollTop(),
				left: this.$$elmt.scrollLeft()
			};
		},
		hasModalOpen: function() {
			log && log("_nbModals=" + this._nbModals);
			return this._nbModals > 0;
		},

		_actGotoWelcomeApplication: function() {
			return this.gotoWelcomeApplication();
		},
		_actLogout: function(actionName) {
			this.logout();
		},
		/**
		 * Called by link with data-action = historyBack
		 */
		_actHistoryBack: function() {
			window.history.back();
		},
		// Switch role, endpoint, language
		_actSwitchContext: function() {
			var self = this;
			initContext.init(true)
				.then(function(profile) {
					return self.gotoWelcomeApplication();
				})
				.fail(function(e) {
					self.logout().then(function() {
						// In the init process we can post error with "$nomessage$" to break it (eg cancel settings dialog)
						if (e != null && e.message !== "$nomessage$") {
							globals.getModal().error(locale.text("user.context.error"), e);
						}
					});
				});
		},
		_actDevelopmentPage: function() {
			developmentPage.show();
		},
		_actSettings: function() {
			var self = this;
			return settings.getGlobalSettings()
				.then(function(set) {
					var modal = new modalSettings.Modal(set);
					return modal.show();
				})
				.then(function(result) {
					if (result) {
						return settings.setGlobalSettings(result);
					}
				});
		},
		_actDesignPage: function() {
			authoring.toggleDesignPage();
		},
		/**
		 * Open about page
		 */
		_actAbout: function() {
			var modal = new modalShowLegal.Modal();
			modal.show();
		},
		/**
		 * User has selected a new Syracuse mobile application
		 * appInfo json description of application
		 */
		notifSwitchApp: function(appName) {
			var self = this;
			var forceUpdate = false;
			globals.getMetaData().checkApplicationUpdate(appName).
			then(function(update) {
				if (update !== true) { // no new version available
					return false;
				}
				var modal = new modalConfirm.Modal(locale.text("modal.confirm.update"), null, true);
				return modal.show()
					.then(function(result) {
						if (result === "yes") {
							return true; // Update app
						}
						return false;
					});
			})
				.then(function(forceUpdate) {
					return globals.getMetaData().getApplication(appName, false, forceUpdate);
				})
				.then(function(appDetails) {
					return self._setCurrentApplication(appDetails);
				})
				.fail(function(e) {
					globals.getModal().error(null, e);
				});
		},

		/**
		 * Goto tablet applications home page  - Welcome dashboard
		 * Ex: For login page we display the error in login page instead of modal
		 */
		gotoWelcomeApplication: function() {
			var self = this,
				step;
			if (globals.isLoggedIn()) {
				step = globals.getMetaData().getApplication("$welcomeApplication").then(function(appDetails) {
					return self._setCurrentApplication(appDetails);
				});
			} else {
				step = this.gotoLogin();
			}
			return step;
		},
		/**
		 * Goto login page
		 */
		gotoLogin: function(reason) {
			var self = this;
			var deferred = $.Deferred();
			setTimeout(function() {
				self.changePage("login", {
					reason: reason || locale.text("login.authentication")
				}).then(function() {
					deferred.resolve();
				}).fail(function(e) {
					deferred.reject(e);
				});
			}, 0);
			return deferred.promise();
		},
		/**
		 * Set the current 'mobile application'
		 * Called after a switch context (application selection) or when tablet application is launched
		 * 'Welcome dashboard' page is a real application with only one dashboard
		 * options
		 * {
		 *    noPageChange: Don't change to application home dashboard
		 * }
		 *
		 */
		_setCurrentApplication: function(appInfo, options) {
			var self = this;
			var deferred = $.Deferred();
			options = options || {};
			try {
				if (!appInfo) {
					throw new Error("Null appInfo");
				}
				log && log("Switch to Syracuse Mobile Application " + appInfo.applicationName);
				if (self.currentPage) {
					self.currentPage.deactivate();
				}
				if (!appInfo.$application.$uuid) {
					throw new Error("No application $uuid - " + appInfo.applicationName);
				}
				if (self.uuid !== appInfo.$application.$uuid) {
					// Application changed
					self.dao.setApplication(appInfo);
					self.homePageId = globals.getMetaData().getDashboardPageName(self.dao.getHomeDashboardName());
					self.uuid = appInfo.$application.$uuid;
				}
				if (options.noPageChange !== true) {
					self.gotoHome().then(function() {
						deferred.resolve();
					}).fail(function(e) {
						deferred.reject(e);
					});
				} else {
					deferred.resolve();
				}
			} catch (e) {
				if (options.dontDiplayErrors === true) {
					deferred.reject(e);
				} else {
					modal.error("Error switching application", e, function() {
						if (self.currentPage) {
							self.currentPage.activate();
						}
						deferred.reject(e);
					});
				}
			}
			return deferred.promise();
		},
		/**
		 * Open a page
		 * !! Do not call directly - Use changePage
		 * loadOptions
		 * 		dontDisplayLoadErr = true to not display a modal
		 */
		_gotoPage: function(state, back, loadOptions) {
			var self = this;
			if (!self._pageLoader) {
				self._pageLoader = self._createPageLoader();
			}
			/**
			 * Page loader shared with vignette
			 * Load a page
			 */
			if (state.isLogin === false && !globals.isLoggedIn()) {
				self.gotoLogin("Authentication is required");
				return $.smResolve();
			} else if (self._pageLoader.loading) {
				// Nothing if a page is currently loading
				// #5872 - We could load a login page two time that causes an error (called from http401Error and init login) 
				return $.smResolve();
			} else {
				return self._pageLoader.load(state, back, loadOptions)
					.then(function(page) {
						notifications.publish(["sm.history.push"], self.history);
						return page;
					});
			}
		},

		_createPageLoader: function() {
			var self = this;
			var loader = new pageLoader.Klass({
				waitStop: function() {
					self.waitWheelStop();
				},
				getRootElmt: function() {
					return self.$$elmt;
				},
				waitStart: function() {
					self.waitWheelStart();
				},
				getCurrentPage: function() {
					return self.currentPage;
				},
				setCurrentPage: function(page) {
					self.currentPage = page;
					if (page.state.isLogin === true) {
						self.historyReset(page);
					} else if (page.state.name === self.homePageId) {
						// Destroy all cached pages except current home page
						log && log("Home page " + self.homePageId + " - Destroy all pages except current");
						self.removeAllChildPages(self.$$elmt, page);
					}
				},
				historyPush: function(state) {
					self.history.push(state);
					notifications.publish(["sm.history.push"], self.history);
					// Refresh browser history to keep only one page in history for tablet application
					if (self.pushState) {
						window.history.pushState({
							x: new Date()
						}, utils.UUID(), null);
					} else {
						window.history.replaceState({
							x: new Date()
						}, utils.UUID(), null);
					}
					// self.historyLog("historyPush");
				},
				succeeded: function(dstPage, pageToClose, parentNotifInfo, back, loadOptions) {
					log && log("succeeded" + " - win=" + window.history.length + " - app=" + self.history.length);
					// dstPage.isNew - > Page has been created -> trigger resize
					// back && !dstPage.isNew -> dstPage was stored in the cache - back from child page (pageToClose.isChild should be true)
					// -> We resize on only if size has changed - Otherwise we just show the page
					if (dstPage.isNew || (back && pageToClose && pageToClose.isChild && pageToClose.sizeModified)) {
						uiutils.triggerResizeInternal();
					}
					if (parentNotifInfo && parentNotifInfo.notifId) {
						/**
						 * If the child application wants to notify the parent it should return info for notification
						 * parentNotifInfo contain :
						 * 		notifId:  	with the notification id
						 * 		notifData: 	with data  needed for processing this event
						 * 		controlId: 	If action as been trigered by a control
						 * 		parentId: 	id of the controller to notify
						 */
						var controllerToNotify = globals.getController(parentNotifInfo.parentId);
						if (controllerToNotify) {
							notifications.notifyController(parentNotifInfo.notifId, controllerToNotify, parentNotifInfo.notifData, parentNotifInfo.controlId);
						} else {
							// if no controller id is provided we publish a global event - Eg: in dashboard we want to notify oal the nested pages - see sm.updt.chart.dashboard
							notifications.publish(parentNotifInfo.notifId, parentNotifInfo.notifData);
						}
					}
				}
			});

			return loader;
		},

		historyReset: function(page) {
			// Destroy all cached pages except page parameter
			this.removeAllChildPages(this.$$elmt, page);
			this.history = [];
		},
		/**
		 * Call cb(state)
		 * Stop if cb returns true
		 */
		historyScan: function(cb) {
			for (var i = this.history.length - 1; i >= 0; i--) {
				if (cb(this.history[i]) === true) break;
			}
		},
		historyLog: function(title) {
			this.historyScan(function(state) {
				console.log("\t", state.name);
			});
		},
		/**
		 * Called by browser history.back
		 * !! never call this method directlty - Call window.back - except if we want to be notified with cb callback
		 * cb is a function if we want to be notified whe the page has been loaded
		 * 	- by example to display a message
		 * pageFilter callback to select the targetPage
		 * 		If pageFilter == null goto previous page
		 * 		pageFilter(pageState)
		 * 		returns true/false
		 * 		If true goto a selected page
		 * 		if false  back is canceled
		 * Returns true if page has changed
		 */
		historyPop: function(event, cb, pageFilter) {
			try {
				if (!authoring.checkBack()) {
					return false;
				}
				var self = this;
				log && log("History pop before" + " - win=" + window.history.length + " - app=" + self.history.length);
				// No back if a modal is open
				if (self._nbModals > 0) {
					if (event) {
						event.preventDefault();
					}
					return false;
				}
				if (self.uuid === "root" || self.history.length === 0) {
					// No application has been loaded - Goto previous browser history
					// ?? return without preventDefault doesn't continue back action on browser side
					// -> We repost a back
					window.history.back();
					return false;
				}
				if (pageFilter && self.history.length > 0) {
					var selectedIdx = -1;
					for (var i = self.history.length - 1; i >= 0; i--) {
						if (pageFilter(self.history[i])) {
							selectedIdx = i;
							break;
						}
					}
					if (selectedIdx < 0) {
						if (event) {
							event.preventDefault();
						}
						return false;
					}
					while (self.history.length > (selectedIdx + 2)) {
						var state = self.history.pop();
						var pageToRemove = $("#" + state.uuid).smPageController();
						if (pageToRemove) {
							pageToRemove.destroy();
						}
					}
				}
				// Remove current state
				var state = self.history.length > 0 ? self.history.pop() : null;
				if (state && (state.isWelcomePage || state.isLogin)) {
					// Homepage if login or welcome
					// ?? return without preventDefault doesn't continue back action on browser side
					// -> We repost a back

					// MW 2015-02-9 commented since it caused a double back action
					//window.history.back();
					return false;
				} else {
					// Get previous state
					state = self.history.length > 0 ? self.history[self.history.length - 1] : null;
				}
				if (event) {
					event.preventDefault();
				}
				notifications.publish(["sm.history.pop"], self.history);
				// Force pushState on display page - Last state has been removed
				self.pushState = true;
				// self.historyLog("historyPop");
				// Open page
				if (state) {
					setTimeout(function() {
						var promise;
						if (state.isWelcomePage) {
							promise = self.gotoWelcomeApplication();
						} else {
							promise = self._gotoPage(state, true);
						}
						if (cb) cb(promise);
					}, 0);
					return true;
				}
			} catch (e) {
				modal.error("historyPop error", e, function() {
					if (cb) cb($.smReject(e));
				});
			}
			return false;
		},
		/**
		 * Goto to previous page if any
		 * pageFilter == null	-> Goto to previous page
		 * pageFilter != null	-> Goto to selected page  - see historyPop
		 * 						   pageFilter is a function taht recieve the current hostory page state in parameter
		 * 						   it returns true to stop the historyPop
		 * 						   it's used if we want to stop at a given page
		 */
		goBack: function(pageFilter) {
			var deferred = $.Deferred();
			this.historyPop(null, function(promise) {
				if (promise) {
					promise.then(function(newPage) {
						deferred.resolve(newPage);
					}).fail(function(e) {
						deferred.reject(e);
					});
				} else {
					deferred.resolve();
				}
			}, pageFilter);
			return deferred.promise();
		},
		/** 
		 * pageName - name of the page
		 * pageOptions - Option override standard pageInfo and allows to store a context
		 * 		{
		 *   		applicationName: allows to switch application before changing page
		 * 		}
		 * changePageOpts - changePageOpts methods options
		 * 		callerhandlesErrors = true  - caller handle loading errors (message and redirection)
		 **/
		changePage: function(pageName, pageOptions, changePageOpts) {
			var self = this;
			changePageOpts = changePageOpts || {};
			var changeApp;
			if (pageOptions && pageOptions.applicationName) {
				var curApp = self.dao && self.dao.getApplicationName();
				if (curApp !== pageOptions.applicationName) {
					changeApp = globals.getMetaData().getApplication(pageOptions.applicationName).then(function(appDetails) {
						return self._setCurrentApplication(appDetails, {
							noPageChange: true
						});
					});
				}
			}
			// If there is no application change going on, we just resolve to quickly change the page
			if (!changeApp) {
				changeApp = $.smResolve();
			}
			return changeApp
				.then(function() {
					var curPage;
					if (pageOptions && pageOptions.parentId && pageOptions.parentId.length > 0) {
						// Open a child page in fullpage mode
						curPage = globals.getController(pageOptions.parentId);
						if (!curPage) throw new Error("changePage - Can't find parent page - " + pageOptions.parentId);
					} else {
						curPage = self.currentPage;
					}
					return pageRegistry.getPageInfo(pageName, pageOptions, curPage);
				})
				.then(function(pageInfo) {
					return self._gotoPage(pageInfo, false, {
						dontDisplayLoadErr: changePageOpts.callerhandlesErrors
					});
				})
				.fail(function(e) {
					var next = e && e.$redirectPage || "welcomePage";
					if (next === "current") {
						self.refreshPage();
					} else if (next === "login") {
						self.gotoLogin(locale.text("login.timeout.message"));
					} else if (changePageOpts.callerhandlesErrors !== true) {
						// callerhandlesErrors = true means that it's the caller that will hanlde the redirection
						// 	On an error, we will go to the welcome page
						self.gotoWelcomeApplication();
					}
					return (e);
				});
		},

		logout: function(msgId) {
			var deferred = $.Deferred();
			var self = this;
			var _loggedOut = function() {
				log && log("User Logged out");
				globals.setUserCtx(null);
				deferred.resolve();
				self.gotoLogin(locale.text(msgId || "logout.msg"));
			};
			self.waitWheelStart();
			settings.logoutForgetMe().then(function(forgetMe) {
				return auth.logout(forgetMe);
			}).then(function(ok, message) {
				self.waitWheelStop();
				if (ok) {
					_loggedOut();
				} else {
					modal.error(message, function() {
						_loggedOut();
					});
				}
			}).fail(function(e) {
				self.waitWheelStop();
				modal.error("Logout error", e, function() {
					_loggedOut();
				});
			});
			return deferred.promise();
		},

		/**
		 * Refresh current page - called from eventListener
		 */
		refreshPage: function(options) {
			var self = this;
			if (!self.currentPage) {
				throw new Error("No current page");
			}
			self.currentPage.refresh(options).then(function() {
				//	Eventually do something in vignette control	
			}).fail(function(e) {
				self.modalError(locale.text("err.load.main"), e, function() {
					var next = e && e.$redirectPage;
					if (next === "login") {
						self.gotoLogin(locale.text("login.timeout.message"));
					}
				});
			});
		},
		/**
		 * One waiting plugin per page
		 */
		waitWheelStart: function() {
			uiutils.waitWheelStart(this._wait);
		},
		waitWheelStop: function() {
			uiutils.waitWheelStop(this._wait);
		},
		/**
		 * Also exported in globals
		 */
		modalError: function(title, e, cb) {
			modal.error(title, e, cb);
		},
		getMessageSlot: function() {
			// tablet or smartphone
			if (!this._$$actMsgSlot) this._$$actMsgSlot = {};
			var deviceType = globals.getSiteLayout().getDeviceType();
			if (this._$$actMsgSlot[deviceType]) return this._$$actMsgSlot[deviceType];
			var $$slot = this._$$actMsgSlot[deviceType] = $("<div>").addClass("s-m-act-msg-slot").addClass(deviceType);
			(deviceType !== "tablet" && this.currentPage ? this.currentPage.$$contentElmt : this.$$elmt).prepend($$slot);
			return $$slot;
		},
		_actPinPage: function() {
			var self = this;
			var page = self.currentPage;
			var unpin = false;
			var removelivetile = false;
			settings.isPinnedPage(page.getPinPageId())
				.then(function(isPinned) {
					var message;
					if (isPinned) {
						unpin = true;
						message = locale.text("pin.page.remove.confirm");
					} else {
						message = locale.text("pin.page.add.confirm");
					}
					return nativeLiveTile.getLiveTile(page.getPinPageId())
						.then(function(isliveTile) {
							if (!page.supportsLiveTile()) {
								return globals.getModal().simpleConfirmPromise({
									message: message
								});
							} else {
								removelivetile = isliveTile;
								return globals.getModal().modalPinAndLiveTile({
									pageTitle: page.state.$title,
									pinwelcome: isPinned,
									livetile: isliveTile
								});
							}
						});
				})
				.then(function(result) {
					if (result.action !== "yes") return;
					var pageData = page.getPinPageData() // allow to add information by subclasses;
					if (!result.content || result.content.togglepinwelcome) {
						if (unpin) {
							settings.removePinnedPage(pageData.id)
								.then(function() {
									var notify = {
										severityClass: "success",
										title: "",
										body: locale.text("pin.page.remove.ok", [pageData.title]),
									};
									globals.getModal().notify(notify);
									notifications.publish("sm.page.pin.state.change", 1);
								});
						} else {
							// Save full context
							pageData.applicationName = self.dao.getApplicationName();
							pageData.endpoint = pageData.endpoint || globals.getEndpoint();
							if (pageData.dashboardName && pageData.applicationName === self.dao.getApplicationName() && pageData.dashboardName === self.dao.getHomeDashboardName()) {
								// We keep the application Icon if we pin the home dashboard
								pageData.icon = self.dao.getApplicationIcon();
							}
							settings.addPinnedPage(pageData)
								.then(function() {
									var notify = {
										severityClass: "success",
										title: "",
										body: locale.text("pin.page.add.ok", [pageData.title]),
									};
									globals.getModal().notify(notify);
									notifications.publish("sm.page.pin.state.change", page.supportsLiveTile() ? 1 : 2);
								});
						}
					}
					var action;
					if (result.content && result.content.togglelivetile) {
						var options = {}, provider;
						if (removelivetile) {
							options = pageData.id;
							provider = nativeLiveTile.removeLiveTile;
							action = "remove";
						} else {
							options = pageData;
							options.applicationName = self.dao.getApplicationName();
							options.endpoint = pageData.endpoint || globals.getEndpoint();
							provider = nativeLiveTile.addLiveTile;
							action = "add";
						}
						provider(options)
							.then(function(result) {
								var notify = {};
								if (result && result.error) {
									notify = {
										severityClass: "warning",
										body: result.error.text
									};
								} else {
									notify = {
										severityClass: "success",
										title: "",
										body: locale.text("livetile.page." + action + ".ok"),
									};
								}
								globals.getModal().notify(notify);
								notifications.publish("sm.page.pin.state.change", 1);
							});
					}
				})
				.fail(function(e) {
					globals.getModal().error(e);
				});
		},
		_actNativeShare: function() {
			var options = {
				pageData: this.currentPage.getNavigationPageData()
			};
			nativeShare.sharePageLink(options)
				.then(function(result) {
					var notify = {};
					if (result && result.action) {
						notify = {
							severityClass: result.action === "ok" ? "success" : "warning",
							title: "",
							body: locale.text("share.page." + result.action)
						};
					} else {
						notify = {
							severityClass: "warning",
							title: "",
							body: locale.text("share.page.error"),
						};
					};
					globals.getModal().notify(notify);
				});
		},
		removeAllChildPages: function($$elmt) {
			if (!$$elmt) return;
			if (!$$elmt.jquery) $$elmt = $($$elmt);
			var exclude = Array.prototype.slice.call(arguments, 1);
			$$elmt.children(".s-m-page").each(function(idx) {
				var page = $(this).smPageController();
				if (page && Array.prototype.indexOf.call(exclude, page) == -1) {
					page.destroy();
				}
			});
		},
		getHistory: function() {
			return this.history;
		},
		_getHistoryContext: function() {
			var self = this;
			if (!self.currentPage || self.currentPage.state.isLogin || self.currentPage.state.isWelcomePage) return null;
			var context = {
				applicationName: self.uuid,
				history: []
			};
			self.historyScan(function(state) {
				if (state.isLogin || state.isWelcomePage) return true;
				context.history.unshift(state);
				if (state.name === self.homePageId) return true;
			});
			return context.history.length === 0 ? null : context;
		},
		/**
		 * fromInitProcess	true if login occurred after initialization of the application
		 */
		notifUserLoggedIn: function(fromInitProcess) {
			var self = this;
			if (fromInitProcess !== true || !nativeApp.isSageX3WUPApp()) {
				self.gotoWelcomeApplication();
			}
			try {
				self.gotoWelcomeApplication().then(function() {
					var context = nativeApp.getHistoryContext();
					if (!context || context.history.length === 0) return;
					var gotoState = null;
					var max = context.history.length - 1;
					context.history.forEach(function(state, idx) {
						if (idx < max) {
							self.history.push(state);
						} else {
							gotoState = state;
						}
					});
					if (!gotoState) return;
					var opts = $.extend(true, {}, gotoState.options);
					opts.applicationName = context.applicationName;
					self.changePage(gotoState.name, opts).fail(function(e) {
						console.log("notifUserLoggedIn failed", "changePage", e);
						self.gotoWelcomeApplication();
					});
				}).fail(function(e) {
					console.log("notifUserLoggedIn failed", "gotoWelcomeApplication", e);
					self.gotoWelcomeApplication();
				});
			} catch (e) {
				console.log("notifUserLoggedIn failed", e);
				self.gotoWelcomeApplication();
			}
		},
		nativeInterface: function(action) {
			if (action === "applicationClosing") {
				return {

				};

			}
			if (action === "applicationResuming") {

			}
			if (action === "backButtonPressed") {
				// returns false to let the native wrapper handle the back action
				if (!this.currentPage || this.currentPage.state.isLogin || this.currentPage.state.isWelcomePage) {
					// On the login page, we can never go back, let the wrapper handle the back button
					return false;
				}
				// returns true if page changed
				return this.historyPop();
			}
		}
	});


exports.Application = _Application;