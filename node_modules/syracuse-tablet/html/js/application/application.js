"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("app");
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var auth = require('syracuse-tablet/html/js/application/authentication');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var pageLoader = require('syracuse-tablet/html/js/application/pageLoader');
var initContext = require('syracuse-tablet/html/js/init/initContext');
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var pageRegistry = require('syracuse-tablet/html/js/application/pageRegistry');
var authoring = require('syracuse-tablet/html/js/authoring/authoring');
var developmentPage = require('syracuse-tablet/html/js/ui/developmentPage');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var settings = require('syracuse-tablet/html/js/application/settings');
var modalShowLegal = require('syracuse-tablet/html/js/ui/modals/modalShowLegal');
var modalSettings = require('syracuse-tablet/html/js/ui/modals/modalSettings');
var modalConfirm = require('syracuse-tablet/html/js/ui/modals/modalConfirm');
var native = require('syracuse-tablet/html/js/helpers/native/native');
var sdataCommonResources = require('syracuse-tablet/html/js/sdata/sdataCommonResources');
/**
 * Default application config
 */
var _appConfig = {
	transition: null,
	// FDB - openLinkInVignette=true to allow test in vignettes (children page, lookup...)
	// MW - Changed to false as default since this is more what we are going to use.
	openLinkInVignette: false,
	// FK - to allow display of user photo
	loadUserImage: true
};
/**
 * Subscriptions
 */
var _subscribe = function(self) {
	notifications.subscribe(self, ["sm.modal.open", "sm.modal.close", "sm.main.layout.changed", "sm.user.logged.in"], 1);
};
/**
 * Tablet application class
 */
var _Application = utils.defineClass(
	function($$elmt, factory) {
		this.$$elmt = $$elmt;
		this.currentPage = null;
		this._$config = $.extend(true, {}, _appConfig);
		this.factory = factory;
		this._pageLoader = null;
		this._nbModals = 0;
		this._wait = uiutils.waitWheelCreate($$elmt);
		// Id of the home dashboard of current application
		// Used to go to home page
		this.homePageId = null;
		// Default appid when login page is loaded without current application
		this.uuid = "root";
		// Application history stack
		this.history = [];
		// Force pushState on first page
		this.pushState = true;
	}, null, {
		/**
		 * Called after object has been created
		 **/
		init: function() {
			// Can't be called in constructor
			eventListener.bindEvents(this);
			this.dao = this.factory.createDaoApp(this);
			_subscribe(this);
			this.$$elmt.show();
		},

		destroy: function() {
			authoring.destroy();
			if (this._wait) {
				uiutils.waitWheelDestroy(this._wait);
				this._wait = null;
			}
			if (this.currentPage) {
				this.currentPage.destroy();
				this.currentPage = null;
			}
			if (this.$$elmt) {
				this.removeAllChildPages(this.$$elmt);
				this.$$elmt.unbind();
				this.$$elmt.remove();
				this.$$elmt = null;
			}
			if (this.dao) {
				this.dao.destroy();
				this.dao = null;
			}
			if (this._pageLoader) {
				this._pageLoader.destroy();
				this._pageLoader = null;
			}
			notifications.unsubscribe();
			$(window).unbind();
		},
		isLoadingPage: function() {
			// Returns true if page is loading - #7426
			// When we click back arrow of the browser with the focus on an input field JQuery triggers a blur evt which is processed while the page is loading
			// We skip blur/click events on controls
			return this._pageLoader != null && this._pageLoader.loading === true;
		},
		// Called on page unload
		onUnload: function() {
			console.log("onUnload");
			this.destroy();
		},
		// Called on page onBeforeUnload - We have time to call processes
		// Can return a message to display (error if any)
		onBeforeUnload: function() {
			// TEST USE CLOSE APP BUTTON
			if (false && native.hasCapability("nativeApp")) {
				return native.getModule("nativeApp").notifUnloaded();
			}
		},
		/**
		 * True if current 'mobile application' is welcome application
		 */
		isWelcomeApplication: function() {
			return this.uuid === "$welcomeApplication";
		},
		/**
		 * For page display
		 */
		getTitle: function() {
			return this.dao.getApplicationTitle();
		},
		/**
		 * Goto home page of current 'mobile application'
		 */
		gotoHome: function() {
			var self = this;
			var deferred = $.Deferred();
			setTimeout(function() {
				self.changePage(self.homePageId).then(function() {
					deferred.resolve();
				}).fail(function(e) {
					deferred.reject(e);
				});
			});
			return deferred.promise();
		},
		/**
		 * Accept path like "array.gridMaxCols"
		 */
		$config: function(id) {
			return utils.getPropByPath(this._$config, id);
		},

		notifModalOpen: function() {
			this._nbModals++;
			log && log("notifModalOpen nbModals=" + this._nbModals);
		},

		notifModalClose: function() {
			this._nbModals = Math.max(this._nbModals - 1, 0);
			log && log("notifModalClose nbModals=" + this._nbModals);
		},
		/**
		 * info - sizes of application and main page components header/footer/content - see siteLayout
		 * 		application.width	Application width
		 * 		application.weight	Application height
		 * 		content.width		Main page content width
		 * 		content.height		Main page content height
		 * 		...footer and header
		 * orientation	portrait/landscape
		 */
		notifMainLayoutChanged: function(info, orientation, deviceClass) {
			var self = this;
			//	self.orientation = orientation;
			// Container including header, content, footer
			// Set fixed with/height for application
			self.$$elmt.width(info.application.width);
			self.$$elmt.height(info.application.height);
			if (self.currentPage) {
				self.currentPage.onMainPageResize(info, orientation, deviceClass);
			}
			if (info.deviceChanged) {
				// Like we change the device we rebuilt the header and must refresh darft count
				self.triggerUpdtDraftsCount();
			}
		},
		/**
		 * Application can be scrolled (native scroll) in authoring mode
		 */
		getScrollOffset: function() {
			return {
				top: this.$$elmt.scrollTop(),
				left: this.$$elmt.scrollLeft()
			};
		},
		hasModalOpen: function() {
			log && log("_nbModals=" + this._nbModals);
			return this._nbModals > 0;
		},

		_actGotoWelcomeApplication: function() {
			return this.gotoWelcomeApplication();
		},
		_actLogout: function(actionName) {
			this.logout();
		},
		_actOpenDraft: function(draftId) {
			var self = this;
			if (!draftId) return;
			return globals.getStorage().draftOperation("draftRead", draftId).then(function(ctx) {
				if (!ctx || !ctx.restoredContext) return;
				self._swicthToContext(ctx.restoredContext);
			});
		},
		/**
		 * Called by link with data-action = historyBack
		 */
		_actHistoryBack: function() {
			window.history.back();
		},
		// Switch role, endpoint, language
		_actSwitchContext: function() {
			var self = this;
			initContext.askNewContext()
				.then(function(canceled) {
					if (canceled == true) {
						// Operation canceled
						return;
					}
					self.gotoWelcomeApplication();
				})
				.fail(function(e) {
					if (e != null && e.$redirectPage === "login") {
						var msg;
						// Error management is a little messy
						if (e.$diagnoses && e.$diagnoses.length > 0) {
							msg = e.$diagnoses[0].$message;
						} else {
							msg = e.message || e.$message;
						}
						self.logout(msg);
					} else {
						globals.getModal().error(locale.text("user.context.error"), e);
					}
				});
		},
		_actDevelopmentPage: function() {
			developmentPage.show();
		},
		_actSettings: function() {
			var self = this;
			return settings.getGlobalSettings()
				.then(function(set) {
					var modal = new modalSettings.Modal(set);
					return modal.show();
				})
				.then(function(result) {
					if (result) {
						return settings.setGlobalSettings(result);
					}
				});
		},
		_actDesignPage: function() {
			authoring.toggleDesignPage();
		},
		_addRemovePinPage: function(add) {
			if (add === undefined) return;
			var self = this;
			var pageData = self.currentPage.getPinPageData() // allow to add information by subclasses;
			if (add) {
				if (pageData.dashboardName && pageData.applicationName === self.dao.getApplicationName() && pageData.dashboardName === self.dao.getHomeDashboardName()) {
					// We keep the application Icon if we pin the home dashboard
					pageData.icon = self.dao.getApplicationIcon();
				}
				settings.addPinnedPage(pageData)
					.then(function() {
						var notify = {
							severityClass: "success",
							title: "",
							body: locale.text("pin.page.add.ok", [pageData.title]),
							onlyWebapp: true
						};
						globals.getModal().notify(notify);
						notifications.publish("sm.page.pin.state.change", 2);
					});
			} else {
				settings.removePinnedPage(pageData.id)
					.then(function() {
						var notify = {
							severityClass: "success",
							title: "",
							body: locale.text("pin.page.remove.ok", [pageData.title]),
							onlyWebapp: true
						};
						globals.getModal().notify(notify);
						notifications.publish("sm.page.pin.state.change", 1);
					});
			}
		},
		/**
		 * Open about page
		 */
		_actAbout: function() {
			var modal = new modalShowLegal.Modal();
			modal.show();
		},
		/**
		 * options	: {noPageChange:true} to not display the home page
		 */
		_switchToApplication: function(appName, options) {
			var self = this;
			return globals.getMetaData().checkApplicationUpdate(appName)
				.then(function(update) {
					if (update !== true) { // no new version available
						return false;
					}
					var modal = new modalConfirm.Modal(locale.text("modal.confirm.update"), null, true);
					return modal.show().then(function(result) {
						return result === "yes";
					});
				})
				.then(function(forceUpdate) {
					return globals.getMetaData().getApplication(appName, false, forceUpdate);
				})
				.then(function(appDetails) {
					return self._setCurrentApplication(appDetails, options);
				})
				.fail(function(e) {
					// In wheel is not stop (can occur with unexpected errors)
					self.waitWheelStop();
					if (e && e.$noConnectionError == true) {
						// Error reading meta data
						globals.setOffline(true, {
							severityClass: "error",
							body: locale.text("action.needs.net")
						});
					}
					return $.smReject(e);
				});
		},

		/**
		 * Goto tablet applications home page  - Welcome dashboard
		 * Ex: For login page we display the error in login page instead of modal
		 */
		gotoWelcomeApplication: function() {
			var self = this,
				step;
			if (globals.isLoggedIn()) {
				step = globals.getMetaData().getApplication("$welcomeApplication").then(function(appDetails) {
					return self._setCurrentApplication(appDetails);
				});
			} else {
				step = this.gotoLogin();
			}
			return step;
		},
		/**
		 * Goto login page
		 */
		gotoLogin: function(reason, isError) {
			var self = this;
			var deferred = $.Deferred();
			setTimeout(function() {
				self.changePage("login", {
					reason: reason || locale.text("login.authentication"),
					isError: isError === true
				}).then(function() {
					deferred.resolve();
				}).fail(function(e) {
					deferred.reject(e);
				});
			}, 0);
			return deferred.promise();
		},
		/**
		 * Set the current 'mobile application'
		 * Called after a switch context (application selection) or when tablet application is launched
		 * 'Welcome dashboard' page is a real application with only one dashboard
		 * options
		 * {
		 *    noPageChange: Don't change to application home dashboard
		 * }
		 *
		 */
		_setCurrentApplication: function(appInfo, options) {
			var self = this;
			var deferred = $.Deferred();
			options = options || {};
			try {
				if (!appInfo) {
					throw new Error("Null appInfo");
				}
				log && log("Switch to Syracuse Mobile Application " + appInfo.applicationName);
				if (self.currentPage) {
					// Keep the current page for next step (change page)
					// Used for child pages and by welcome page to calculate the gadget of pinned pages
					self.currentPage.deactivate();
				}
				if (!appInfo.$application.$uuid) {
					throw new Error("No application $uuid - " + appInfo.applicationName);
				}
				if (self.uuid !== appInfo.$application.$uuid) {
					// Application changed
					self.dao.setApplication(appInfo);
					self.homePageId = globals.getMetaData().getDashboardPageName(self.dao.getHomeDashboardName());
					self.uuid = appInfo.$application.$uuid;
					self.applicationName = appInfo.$application.applicationName || self.uuid;
				}
				if (options.noPageChange !== true) {
					self.gotoHome().then(function() {
						deferred.resolve();
					}).fail(function(e) {
						deferred.reject(e);
					});
				} else {
					deferred.resolve();
				}
			} catch (e) {
				if (self.currentPage) {
					self.currentPage.activate();
				}
				if (options.dontDiplayErrors === true) {
					deferred.reject(e);
				} else {
					modal.error("Error switching application", e, function() {
						deferred.reject(e);
					});
				}
			}
			return deferred.promise();
		},
		/**
		 * Open a page
		 * !! Do not call directly - Use changePage
		 * loadOptions
		 * 		dontDisplayLoadErr = true to not display a modal
		 */
		_gotoPage: function(state, back, loadOptions) {
			var self = this;
			if (!self._pageLoader) {
				self._pageLoader = self._createPageLoader();
			}
			/**
			 * Page loader shared with vignette
			 * Load a page
			 */
			if (state.isLogin === false && !globals.isLoggedIn()) {
				self.gotoLogin("Authentication is required");
				return $.smResolve();
			} else if (self._pageLoader.loading) {
				// Nothing if a page is currently loading
				// #5872 - We could load a login page two time that causes an error (called from http401Error and init login) 
				return $.smResolve();
			} else {
				return self._pageLoader.load(state, back, loadOptions)
					.then(function(page) {
						// Notify that main page has been loaded
						notifications.publish(["sm.mainpage.loaded"], self.history);
						return page;
					});
			}
		},

		_createPageLoader: function() {
			var self = this;
			var loader = new pageLoader.Klass({
				waitStop: function() {
					self.waitWheelStop();
				},
				getRootElmt: function() {
					return self.$$elmt;
				},
				waitStart: function() {
					self.waitWheelStart();
				},
				getCurrentPage: function() {
					return self.currentPage;
				},
				setCurrentPage: function(page) {
					self.currentPage = page;
					if (page.state.isLogin === true) {
						self.historyReset(page);
					} else if (page.state.name === self.homePageId) {
						// Destroy all cached pages except current home page
						log && log("Home page " + self.homePageId + " - Destroy all pages except current");
						self.removeAllChildPages(self.$$elmt, page);
					}
				},
				historyPush: function(state) {
					self.history.push(state);
					// Refresh browser history to keep only one page in history for tablet application
					if (self.pushState) {
						window.history.pushState({
							x: new Date()
						}, utils.UUID(), null);
					} else {
						window.history.replaceState({
							x: new Date()
						}, utils.UUID(), null);
					}
					// self.historyLog("historyPush");
				},
				succeeded: function(dstPage, pageToClose, parentNotifInfo, back, loadOptions) {
					log && log("succeeded" + " - win=" + window.history.length + " - app=" + self.history.length);
					// dstPage.isNew - > Page has been created -> trigger resize
					// back && !dstPage.isNew -> dstPage was stored in the cache - back from child page (pageToClose.isChild should be true)
					// -> We resize on only if size has changed - Otherwise we just show the page
					if (dstPage.isNew || (back && pageToClose && pageToClose.isChild && pageToClose.sizeModified)) {
						uiutils.triggerResizeInternal();
					}
					if (parentNotifInfo && parentNotifInfo.notifId) {
						/**
						 * If the child application wants to notify the parent it should return info for notification
						 * parentNotifInfo contain :
						 * 		notifId:  	with the notification id
						 * 		notifData: 	with data  needed for processing this event
						 * 		controlId: 	If action as been trigered by a control
						 * 		parentId: 	id of the controller to notify
						 */
						var controllerToNotify = globals.getController(parentNotifInfo.parentId);
						if (controllerToNotify) {
							notifications.notifyController(parentNotifInfo.notifId, controllerToNotify, parentNotifInfo.notifData, parentNotifInfo.controlId);
						} else {
							// if no controller id is provided we publish a global event - Eg: in dashboard we want to notify oal the nested pages - see sm.updt.chart.dashboard
							notifications.publish(parentNotifInfo.notifId, parentNotifInfo.notifData);
						}
					}
					// Update drafts counter in header menu or smatphone panel when page is loaded
					self.triggerUpdtDraftsCount();
				}
			});

			return loader;
		},
		triggerUpdtDraftsCount: function() {
			globals.getStorage().draftOperation("draftNotifyChanged");
		},
		historyReset: function(page) {
			// Destroy all cached pages except page parameter
			this.removeAllChildPages(this.$$elmt, page);
			this.history = [];
		},
		/**
		 * Call cb(state)
		 * Stop if cb returns true
		 */
		historyScan: function(cb) {
			for (var i = this.history.length - 1; i >= 0; i--) {
				if (cb(this.history[i]) === true) break;
			}
		},
		historyLog: function(title) {
			this.historyScan(function(state) {
				console.log("\t", state.name);
			});
		},
		/**
		 * !!!! returns a boolean or a promise
		 *  - true if back is allowed
		 *  - false if back is not allowed
		 *  - promise:  the promise must resolve with true or false
		 *  			used if a dialog is displayed
		 */
		_checkBack: function() {
			if (authoring && !authoring.checkBack()) {
				return false;
			}
			return this.currentPage ? this.currentPage.checkBack() : true;
		},
		/**
		 * Called by browser history.back
		 * !! never call this method directlty - Call window.back - except if we want to be notified with cb callback
		 * cb is a function if we want to be notified whe the page has been loaded
		 * 	- by example to display a message
		 * pageFilter callback to select the targetPage
		 * 		If pageFilter == null goto previous page
		 * 		pageFilter(pageState)
		 * 		returns true/false
		 * 		If true goto a selected page
		 * 		if false  back is canceled
		 * Returns a promise
		 */
		historyPop: function(event, cb, pageFilter) {
			var self = this;
			var res = self._checkBack();
			var step;
			if (utils.isPromise(res)) {
				step = res;
			} else {
				step = $.smResolve(res);
			}
			return step.always(function(processBack) {
				try {
					if (processBack !== true) {
						return false;
					}
					log && log("History pop before" + " - win=" + window.history.length + " - app=" + self.history.length);
					// No back if a modal is open
					if (self._nbModals > 0) {
						if (event) {
							event.preventDefault();
						}
						return false;
					}
					if (self.uuid === "root" || self.history.length === 0) {
						// No application has been loaded - Goto previous browser history
						// ?? return without preventDefault doesn't continue back action on browser side
						// -> We repost a back
						window.history.back();
						return false;
					}
					if (pageFilter && self.history.length > 0) {
						var selectedIdx = -1;
						for (var i = self.history.length - 1; i >= 0; i--) {
							if (pageFilter(self.history[i])) {
								selectedIdx = i;
								break;
							}
						}
						if (selectedIdx < 0) {
							if (event) {
								event.preventDefault();
							}
							return false;
						}
						while (self.history.length > (selectedIdx + 2)) {
							var state = self.history.pop();
							var pageToRemove = $("#" + state.uuid).smPageController();
							if (pageToRemove) {
								pageToRemove.destroy();
							}
						}
					}
					// Remove current state
					var state = self.history.length > 0 ? self.history.pop() : null;
					if (state && (state.isWelcomePage || state.isLogin)) {
						// Homepage if login or welcome
						// ?? return without preventDefault doesn't continue back action on browser side
						// -> We repost a back

						// MW 2015-02-9 commented since it caused a double back action
						//window.history.back();
						return false;
					} else {
						// Get previous state
						state = self.history.length > 0 ? self.history[self.history.length - 1] : null;
					}
					if (event) {
						event.preventDefault();
					}
					// Force pushState on display page - Last state has been removed
					self.pushState = true;
					// self.historyLog("historyPop");
					// Open page
					if (state) {
						setTimeout(function() {
							var promise;
							if (state.isWelcomePage) {
								promise = self.gotoWelcomeApplication();
							} else {
								promise = self._gotoPage(state, true);
							}
							if (cb) cb(promise);
						}, 0);
						return true;
					}
				} catch (e) {
					modal.error("historyPop error", e, function() {
						if (cb) cb($.smReject(e));
					});
				}
				return false;
			});
		},
		/**
		 * Goto to previous page if any
		 * pageFilter == null	-> Goto to previous page
		 * pageFilter != null	-> Goto to selected page  - see historyPop
		 * 						   pageFilter is a function taht recieve the current hostory page state in parameter
		 * 						   it returns true to stop the historyPop
		 * 						   it's used if we want to stop at a given page
		 */
		goBack: function(pageFilter) {
			var deferred = $.Deferred();
			if (this.historyPop(null, function(promise) {
				if (promise) {
					promise.then(function(newPage) {
						deferred.resolve(newPage);
					}).fail(function(e) {
						deferred.reject(e);
					});
				} else {
					deferred.resolve();
				}
			}, pageFilter)) {
				return deferred.promise();
			} else {
				deferred.resolve();
				return deferred.promise();
			}
		},
		/** 
		 * pageName - name of the page - nul/empty for homepage
		 * pageOptions - Option override standard pageInfo and allows to store a context
		 * 		{
		 *   		applicationName: allows to switch application before changing page
		 * 		}
		 * changePageOpts - changePageOpts methods options
		 * 		callerhandlesErrors = true  - caller handle loading errors (message and redirection)
		 * savedContext 	savedContext to restore (normapreviously the savedContext was restored on back)
		 **/
		changePage: function(pageName, pageOptions, changePageOpts, savedContext) {
			var self = this;
			pageOptions = pageOptions || {};
			changePageOpts = changePageOpts || {};
			var step;
			if (pageOptions.applicationName && self.applicationName != pageOptions.applicationName) {
				step = self._switchToApplication(pageOptions.applicationName, {
					noPageChange: true
				});
			} else {
				step = $.smResolve();
			}
			return step
				.then(function() {
					if (!pageName) {
						// Go to home if no page
						pageName = self.homePageId;
					}
					var curPage;
					if (pageOptions.parentId && pageOptions.parentId.length > 0) {
						// Open a child page in fullpage mode
						curPage = globals.getController(pageOptions.parentId);
						if (!curPage) {
							throw new Error("changePage - Can't find parent page - " + pageOptions.parentId);
						}
					} else {
						curPage = self.currentPage;
					}
					return pageRegistry.getPageInfo(pageName, pageOptions, curPage);
				})
				.then(function(pageInfo) {
					if (savedContext) {
						// We want to restore savedContext so we copy it in the state provided by meta-data
						pageInfo["savedContext"] = savedContext;
					}
					return self._gotoPage(pageInfo, false, {
						dontDisplayLoadErr: changePageOpts.callerhandlesErrors,
						// Just to inform the page loader that it's not the regular process (back)
						restoreSavedContext: savedContext != null
					});
				})
				.fail(function(e) {
					self.waitWheelStop();
					var next = e && e.$redirectPage || "welcomePage";
					if (next === "current" && self.currentPage) {
						self.refreshPage();
					} else if (next === "login") {
						self.gotoLogin(locale.text("login.timeout.message"), true);
					} else if (changePageOpts.callerhandlesErrors !== true) {
						// callerhandlesErrors = true means that it's the caller that will hanlde the redirection
						// 	On an error, we will go to the welcome page
						if (e && e.$noConnectionError == true) {
							self.gotoWelcomeApplication();
						} else {
							globals.getModal().error(null, e, function() {
								self.gotoWelcomeApplication();
							});
						}
					}
					return (e);
				});
		},
		logout: function(msgOrLocaleId, isError) {
			var deferred = $.Deferred();
			var self = this;
			var _loggedOut = function() {
				log && log("User Logged out");
				globals.clearUserCtx();
				deferred.resolve();
				if (!msgOrLocaleId) {
					msgOrLocaleId = "logout.msg";
					isError = false;
				}
				var text = locale.textNoFail(msgOrLocaleId);
				if (!text) {
					// We assume it's a message (X3...)
					text = msgOrLocaleId;
				}
				self.gotoLogin(text, isError);
			};
			self.waitWheelStart();
			auth.logout().then(function(ok, message) {
				self.waitWheelStop();
				if (ok) {
					_loggedOut();
				} else {
					modal.error(message, function() {
						_loggedOut();
					});
				}
			}).fail(function(e) {
				self.waitWheelStop();
				modal.error("Logout error", e, function() {
					_loggedOut();
				});
			});
			return deferred.promise();
		},

		/**
		 * Refresh current page - called from eventListener
		 */
		refreshPage: function(options) {
			var self = this;
			if (!self.currentPage) {
				throw new Error("No current page");
			}
			self.currentPage.refresh(options).then(function() {
				//	Eventually do something in vignette control	
			}).fail(function(e) {
				self.modalError(locale.text("err.load.main"), e, function() {
					var next = e && e.$redirectPage;
					if (next === "login") {
						self.gotoLogin(locale.text("login.timeout.message"), true);
					}
				});
			});
		},
		/**
		 * One waiting plugin per page
		 */
		waitWheelStart: function() {
			uiutils.waitWheelStart(this._wait);
		},
		waitWheelStop: function() {
			uiutils.waitWheelStop(this._wait);
		},
		/**
		 * Also exported in globals
		 */
		modalError: function(title, e, cb) {
			modal.error(title, e, cb);
		},
		getMessageSlot: function() {
			if (!this._$$actMsgSlot) this._$$actMsgSlot = {};
			var deviceType = globals.getSiteLayout().getDeviceType();
			if (this._$$actMsgSlot[deviceType]) return this._$$actMsgSlot[deviceType];
			var $$slot = this._$$actMsgSlot[deviceType] = $("<div>").addClass("s-m-act-msg-slot").addClass(deviceType);
			this.$$elmt.prepend($$slot);
			return $$slot;
		},
		_actPinPage: function() {
			var self = this;
			var pin = false;
			var liveTileRemove = false;
			var nativeLiveTile = self.currentPage.nativeCapabilities.liveTile ? native.getModule("liveTile") : null;
			settings.isPinnedPage(self.currentPage.getPinPageId())
				.then(function(isPinned) {
					pin = !isPinned;
					var message = locale.text("pin.page." + (pin ? "add" : "remove") + ".confirm");
					return globals.getModal().simpleConfirmPromise({
						message: message
					});
				})
				.then(function(result) {
					if (result.action !== "yes") return;
					self._addRemovePinPage(pin);
				})
				.fail(function(e) {
					globals.getModal().error(e);
				});

		},
		removeAllChildPages: function($$elmt) {
			if (!$$elmt) return;
			if (!$$elmt.jquery) $$elmt = $($$elmt);
			var exclude = Array.prototype.slice.call(arguments, 1);
			$$elmt.children(".s-m-page").each(function(idx) {
				var page = $(this).smPageController();
				if (page && Array.prototype.indexOf.call(exclude, page) == -1) {
					page.destroy();
				}
			});
		},
		getHistory: function() {
			return this.history;
		},
		_nativeGetContextToRestore: function() {
			var self = this;
			if (!self.currentPage || self.currentPage.state.isLogin || self.currentPage.state.isWelcomePage) return null;
			var stackHistory = [];
			if (self.history) {
				self.history.forEach(function(state) {
					// Don't restore child pages - TODO
					if (state.isLogin || state.isWelcomePage || (state.options && state.options.parentId != null)) return;
					stackHistory.push(state);
				});
			}
			//stackHistory contains the actual pages to restore
			var history = null;
			// We skip the last state (currentState to restore) and push the other ones in history
			var start = stackHistory && stackHistory.length > 0 ? stackHistory.length - 2 : -1,
				state;
			for (var i = start; i >= 0; i--) {
				state = stackHistory[i];
				if (!history) {
					history = [];
				}
				history.unshift(state);
				if (state.name === self.homePageId) break;
			}
			var context;
			if (self.currentPage.isChild) {
				// Current page is not the current state to restore (child pages not restored)
				// We take the last state of stackHistory (parent page of child pages)
				var state = stackHistory[stackHistory.length - 1];
				if (!state) return;
				context = {
					endpoint: globals.getEndpoint(),
					applicationName: state.applicationName,
					role: globals.getUserRole(),
					currentState: state
				};
			} else {
				// Current page is the current state to restore
				context = self.currentPage.getRestoreContext("nativeAppClosing");
			}
			if (!context) return;
			// Add history to context
			context.history = history;
			return context;
		},
		/**
		 * fromInitProcess	true if login occurred after initialization of the application
		 * restoredContext	Context to restore if any (url context in email link or context provided by nativeWrapper)
		 * 					We assume that enpoint is ok
		 */
		notifUserLoggedIn: function(fromInitProcess, restoredContext) {
			var self = this;
			self._restoreHistoryContext(restoredContext).then(function() {
				if (fromInitProcess === true) {
					notifications.publish(["sm.application.ready"], true);
				}
			}).fail(function() {
				// If retore context failed we goto welcome mage and notify application.ready with false
				self.gotoWelcomeApplication().always(function() {
					if (fromInitProcess === true) {
						notifications.publish(["sm.application.ready"], false);
					}
				});
			});
		},
		/**
		 * restoredContext
		 * 		historyContext to restore if any (url context in email link or context provided by nativeWrapper at initialization)
		 * 		restoredContext.history is the histpory stack
		 * 		restoredContext.currentState is the page to open
		 */
		_restoreHistoryContext: function(restoredContext) {
			var self = this;
			// Restores the context
			// -1- gotoWelcomeApplication is mandatory (this page needs to be displayed to continue)
			// If historyContext:
			// -2- Push context states in history (except the last one)
			// -3- Goto the page given by the last state
			var step = self.gotoWelcomeApplication();
			if (!restoredContext || restoredContext.applicationName == null) {
				return step;
			}
			return step.then(function() {
				var appName = restoredContext.applicationName;
				if (appName !== self.applicationName || appName !== self.uuid) {
					// Check application name
					return globals.getMetaData().getApplication(appName).then(function(app) {
						var def = $.Deferred();
						if (app) {
							def.resolve(restoredContext);
						} else {
							// Cancel historyContext
							globals.getModal().actionResult(locale.text("restorecontext.bad"), locale.text("restorecontext.badapp", [appName]));
							restoredContext = null;
							def.resolve();
						}
						return def.promise();
					});
				} else {
					// History is Ok
					return $.smResolve(restoredContext);
				}
			}).then(function() {
				if (!restoredContext || !restoredContext.currentState) return null;
				if (restoredContext.history && restoredContext.history.length > 0) {
					// Restores the stack if any - No stack for page link only for close/resume application
					restoredContext.history.forEach(function(state) {
						self.history.push(state);
					});
				}
				var opts = $.extend(true, {}, restoredContext.currentState.options);
				opts.applicationName = restoredContext.applicationName;
				return self.changePage(restoredContext.currentState.name, opts, null, restoredContext.currentState.savedContext);
			});
		},
		/**
		 * Interface called by smWrapperJS
		 */
		nativeWrapperJSInterface: function(moduleName, action) {
			var self = this;
			if (moduleName === "nativeApp" && action === "applicationClosing") {
				// Called when application close (onBeforeUnload in test mode)
				// Returns histopry context stringify
				var ctx = self._nativeGetContextToRestore(true);
				//console.log(JSON.stringify(ctx, null, 2));
				return ctx ? JSON.stringify(ctx, null, 2) : null;
			}
			if (moduleName === "nativeApp" && action === "backButtonPressed") {
				// returns false to let the native wrapper handle the back action
				if (!self.currentPage || self.currentPage.state.isLogin || self.currentPage.state.isWelcomePage) {
					// On the login page, we can never go back, let the wrapper handle the back button
					return false;
				}
				// returns true if page changed
				return self.historyPop();
			}
			if (moduleName === "nativeApp" && action === "applicationActivated") {
				if (!self.currentPage || !self.currentPage.state.isLogin) {
					return;
				}
				// If we are on the login page, we reload it to allow to detect online mode changes
				// If we do not do this, the user has to do an offline login (with hidden user and password fields) 
				// to do an online login again later
				self.gotoLogin();
			}
			if (moduleName === "voiceCommands" && action === "executeVoiceCommand") {
				// cmd : {type: "openBookmark...", context: "", title:""}
				var cmd = arguments[2];
				if (!cmd) return;
				if (cmd.type === "openBookmark") {
					// Link to a page given by cmd.context
					if (!cmd.context) return;
					log && log("Bookmark: " + JSON.stringify(cmd || {}));
					self._swicthToContext(cmd.context);
					return;
				}
			}
			if (moduleName === "share" && action === "handleLink") {
				var contextId = arguments[2];
				//!! we need a connection to Syracuse server to restore a context (handle links on the same device don't work)
				var step = contextId ? sdataCommonResources.readSharedContext(contextId) : $.smResolve(null);
				step.then(function(context) {
					self._restoreHistoryContext(context);
				});
				return;
			}
		},
		/**
		 * Switch to the given context (used by voice commands)
		 * if context.endpoint -> switch endpoint
		 * switch to the given application context.applicationName
		 * if context.currentState!= null goto this page otherwise displays application home page
		 * context given by page.getRestoreContext: {
		 * 		endpoint:
		 * 		applicationName:
		 * 		currentState:
		 * }
		 */
		_swicthToContext: function(context) {
			var self = this;
			if (!context) return;
			var step, context;
			if (context.endpoint && context.endpoint !== globals.getEndpoint()) {
				// We need to swicth the endpoint
				step = initContext.switchContext(context).then(function(contextToRestore) {
					// Force gotoWelcomeApplication
					return $.smResolve(contextToRestore && contextToRestore.applicationName, true);
				});
			} else {
				// No need to switch endpoint - force gotoWelcomeApplication if not the current page
				step = $.smResolve(context.applicationName, !self.currentPage.state.isWelcomePage);
			}
			step.then(function(applicationName, forceGotoWelcomeApp) {
				// We need to be on the welcome application page to switch to another application
				var step = forceGotoWelcomeApp === true ? self.gotoWelcomeApplication() : $.smResolve();
				return step.then(function() {
					if (applicationName) {
						// noPageChange: true to not display homePage because 
						return self._switchToApplication(applicationName, {
							noPageChange: true
						});
					}
				});
			}).then(function() {
				if (!context.currentState) {
					// Only if no currentState
					// if we pin the homepage of an application the currentState is the home page
					// -> so we don't goto home page otherwise we have 2 home pages opened
					return self.gotoHome();
				}
				// Open the page
				var opts = $.extend(true, {}, context.currentState.options);
				return self.changePage(context.currentState.name, opts);
			}).fail(function(e) {
				if (e && e.$noConnectionError == true) {
					// Nothing - no modal
				} else {
					globals.getModal().error(e);
				}
			});
		}
	});


exports.Application = _Application;