"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var dispatcher = require('syracuse-tablet/html/js/sdata/sdataDispatcher');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

/**
 * Parse code=abc&value=cde to
 * {
 * code: "abc",
 * value: "cde"
 * }
 */
var _parseParameters = function(params) {
	var p = params.split("&");
	var res = {};
	for (var i = 0; i < p.length; i++) {
		var v = p[i].split("=");
		res[v[0]] = v[1];
	}
	return res;
};

/**
 * Set pageOpts with auto scroll value to preserve scrolling when we go from detail -> edit
 * We do the same for cancelEdit action in pageRegular when we go from edit -> detail
 */
var _preserveScrolling = function(page, link, pageOpts) {
	if (!page || !link || !pageOpts) return;
	var val = page.getScrollValue();
	// Auto-scroll - If we edit a page we keep the scrolling
	if (!isNaN(val) && val !== 0) {
		// 1.2 because the height of the page is higher in edit mode 
		// To improve or disable but to me it's great to keep the scrolling when we edit a page
		pageOpts["auto-scroll"] = page.getScrollValue() * 1.2;
	}
};
/**
 * Default message display
 * TODO - Message + detail
 */
var _displayMessage = function(title, data, cb) {
	if (data === null) data = "";
	if (jsutils.isError(data)) {
		data = data.message;
	} else if (typeof data === "string") {
		// Nothing
	} else {
		var diags = sdataUtils.scanDiagnoses(data);
		if (diags.length > 0) {
			var msg = [];
			diags.forEach(function(d) {
				msg.push(d.$message);
			});
			data = msg.join('\n');
		} else {
			data = JSON.stringify(data, null, 2);
		}
	};
	globals.getModal().info(title, data, cb);
};
/**
 * Manage action on links given by prototype
 * Used by footer/header/navigation panel
 */
var _Klass = utils.defineClass(

	function(controller, toolbar, options) {
		this.options = options || {};
		this.toolbar = toolbar;
		this.controller = controller;
		this._initLinks();
	}, null, {

		destroy: function() {
			this.options = null;
			this.controller = null;
		},
		/**
		 * To update links if by example deviceType changed
		 */
		_initLinks: function() {
			var self = this;
			var deviceType = globals.getSiteLayout().getDeviceType();
			var beginLinks = [];
			if (self.options.addMultiSelection && !self.controller.isEditMode()) {
				beginLinks.push(self.getMultiSelectionLink());
			}
			// multiSelectionOnly = true - Only multi-selection is enabled - Used by vignettes
			// In that case it's not necessary to set addMultiSelection = true
			if (self.options.multiSelectionOnly != true) {
				var toolBarLinks = self.controller.getToolbarLinks(self.toolbar) || [];
				var endLinks = [];
				if (self.options.addCancelEditAction && self.controller.isEditMode()) {
					endLinks.push(self.getCancelEditAction(self.options.addCancelEditAction));
				}
			}
			self.links = jsutils.concatArrays(beginLinks, toolBarLinks, endLinks);
		},
		addLink: function(lnk) {
			if (!lnk || this.findLink(lnk.$uuid) != null) return lnk;
			if (!this.links) this.links = [];
			this.links.push(lnk);
			return lnk;
		},
		/**
		 * Add action to links
		 */
		getCancelEditAction: function(actionName) {
			return {
				name: "$canceledit",
				icon: fontUtils.getIconByName("$cancelEdit"),
				isClientAction: true,
				action: actionName || "cancelEdit",
				title: locale.text("action.cancelEdit"),
				$uuid: utils.UUID()
			};
		},
		getMultiSelectionLink: function() {
			return {
				name: "$multiSelection",
				icon: fontUtils.getIconByName("$multiSelection"),
				isClientAction: true,
				action: globals.ACTMULTISEL,
				css: ["s-m-ismultisel"],
				title: locale.text("action.multiselect"),
				$uuid: utils.UUID()
			};
		},
		/**
		 * exclude: array/string of $uuid to exclude
		 */
		getLinks: function(exclude, filter) {
			if (exclude && typeof exclude === "string") {
				exclude = [exclude];
			}
			if (this.links == null || exclude == null || exclude.length == 0 || !filter) {
				return this.links;
			}
			filter = filter || [];
			var lnks = [];
			this.links.forEach(function(l) {
				if (!exclude.some(function($uuid) {
					return l.$uuid === $uuid;
				})) {
					if (filter.some(function(props) {
						var found = true;
						Object.keys(props).forEach(function(key) {
							if ((l[key] && props[key] != l[key]) || (l[key] == null && props[key] != false)) {
								found = false;
							}
						});
						return found;
					})) {
						lnks.push(l);
					}
				}
			});
			return lnks;
		},
		hasLinks: function() {
			return this.links && this.links.length > 0;
		},
		findLink: function(uuid) {
			if (!this.links) return null;
			var lnk;
			this.links.some(function(l) {
				if (l.$uuid === uuid) {
					lnk = l;
					return true;
				}
			});
			return lnk;
		},
		/**
		 *  Triggers a link action/navigation and resolve/reject
		 *  		displayed eventually a message if diagnoses have been returned by server
		 *  uuid
		 *  		Id of the link which has been stored in the html (data-params)
		 *  page: optional - page that will be notified with data returned by action
		 *  	  mandatory for cancelEdit action
		 * 	options
		 * 		For a navigation link
		 * 			If options.noRedirection == true resolve with the following data
		 * 				{
		 * 					gotoPage:{
		 * 						name:"PageName",
		 * 						options{Pages options}
		 * 					}
		 * 				}
		 * 				It's the caller that calls application.changepage
		 * 			Else it does redirection to the target page
		 */
		triggerLink: function(uuid, page) {
			var deferred = $.Deferred();
			try {
				var self = this;
				// reads link info
				var link = this.findLink(uuid);
				if (!link) return;
				// ACTION WITH CONFIRMATION
				if (link.$confirm) {
					// Action with confirmation asked by server
					globals.getModal().simpleConfirm(link.$confirm, function(confirmed) {
						if (confirmed) {
							self._execLink(deferred, page, link);
						}
					});
					return;
				} else {
					self._execLink(deferred, page, link);
				}

			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},
		_execLink: function(deferred, page, link) {
			var self = this;
			// CLIENT ACTION - NON SDATA ACTION
			if (link.isClientAction) {
				if (!page) throw new Error("triggerLink - Page is expected");
				self._notifyAndResolve(page, deferred, true, link);
				return;
			}
			/**
			 * $isAction comes from prototype (true for save, delete...)
			 * If url contains $services $isAction is set to true (see prototype.getLinks)
			 * 		$services urls are considered as actions
			 * !! No url and $isAction means child page action
			 */
			// ACTION - #6195 we consider DELETE to be an action because we stay on the same page
			if (link.$isAction || link.$method === "DELETE") {
				// Action which stays on the same page
				self._doLinkAction(deferred, page, link);
				return;
			}
			// NAVIGATION
			if (link.page) {
				// Navigation to a page
				var pageOpts = {
					"sdata-url": link.sDataUrl,
					"sdata-method": link.$method,
					"sdata-parameter": link.parameters
				};
				if (pageOpts["sdata-parameter"]) {
					pageOpts["sdataParameters"] = _parseParameters(pageOpts["sdata-parameter"]);
				}

				if (page) {
					// Auto-scroll - If we edit a page we keep the scrolling
					if (page.state.name.replace(".$details", ".$edit") === link.page) {
						_preserveScrolling(page, link, pageOpts);
					}
				};
				if (self.options.noRedirection === true) {
					// Caller wants to manage redirection
					self._notifyAndResolve(page, deferred, true, link, {
						gotoPage: {
							name: link.page,
							options: pageOpts
						}
					}, self.options);
				} else {
					// callerhandlesErrors: we don't want the caller to redirect to homepage if there's an error
					// -> We stay on the current page
					var opts = {
						callerhandlesErrors: true
					};
					globals.getApplication().changePage(link.page, pageOpts, opts).then(function() {
						// Page is changed so it's not necessary
						deferred.resolve();
					}).fail(function(e) {
						// Display error message and stays on current page
						if (e) {
							if (e.responseJSON && e.responseJSON.$diagnoses) {
								e = {
									$diagnoses: e.responseJSON.$diagnoses
								};
							} else {
								var msg = "";
								if (e.status != null) {
									msg += "httpStatus=" + e.status;
								}
								if (e.message != null) {
									msg += " - " + e.message;
								}
								e = {
									$diagnoses: [{
										$severity: "error",
										$message: msg
									}]
								};
							}
						}
						globals.getModal().actionResult(locale.text("error.page.loading"), e);
						deferred.resolve();
					});
				}
				return;
			} else if (link.externalUrl) {
				var url = utils.parseExpression(link.externalUrl, page.dao, page.prototype);
				window.open(url);
				return;
			}
			// Unexpected case
			_displayMessage("Unexpected link type", link, function() {
				self._notifyAndResolve(page, deferred, false, link, null, self.options);
			});
		},

		/**
		 * Send an action to server and process result
		 * Resolve/reject deferred
		 */
		_doLinkAction: function(deferred, page, link) {
			var self = this;
			var _end = function(success, data) {
				self._notifyAndResolve(page, deferred, success, link, data);
			};
			try {
				// Validate the data before processing - Synchronous call
				if (page && page.validateBeforeActionLink && page.validateBeforeActionLink(link) === false) {
					// Just resolve - No notification because action has not been sent
					deferred.resolve(false);
					return;
				}
				if (link.sDataUrl) {
					if (page) page.waitWheelStart();
					var $method = link.$method || "GET";
					var payload = ($method === "POST" || $method === "PUT") ?
						(page ? page.dao.getActionPayload(link, page) : null) :
						null;
					dispatcher.dispatch({
						$url: link.sDataUrl,
						$method: $method
					}, payload).then(function(data) {
						if (page) page.waitWheelStop();
						// True for success
						_end(true, data);
					}).fail(function(e) {
						if (page) page.waitWheelStop();
						if (!jsutils.isError(e) && $.isPlainObject(e)) {
							// false for fail
							_end(false, e);
						} else {
							// Exception - we display the message
							_displayMessage("Action '" + link.title + "' failed", e, function() {
								deferred.reject(e);
							});
						}
					});
				} else {
					// Child page action - True for success - no data
					_end(true);
				}
			} catch (e) {
				_displayMessage("Action '" + link.title + "' javascript exception", e, function() {
					deferred.reject(e);
				});
			}
		},
		/**
		 * Notify (the page controller) to do some stuff after an action succeeded
		 * Save/Delete...
		 */
		_notifyAndResolve: function(page, deferred, success, link, result) {
			if (page) {
				notifications.notifyController("sm.action.link", page, success, link, result, this.options);
			}
			if (deferred) {
				deferred.resolve(success, link, result, this.options);
			}
		}
	});

exports.Klass = _Klass;

/**
 * toolbar	header, footer, actionpanel...
 * opts
 * 			addCancelEditAction
 * 				Name aof action to trigger (headerAction; footerAction...)
 * 				Link is not added if null
 * 			noMessage
 */
exports.create = function(controller, toolbar, opts) {
	return new _Klass(controller, toolbar, opts || {});
};