"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("actionMgr");
var globals = require('syracuse-tablet/html/js/helpers/globals');
var dispatcher = require('syracuse-tablet/html/js/sdata/sdataDispatcher');
var sdataUtils = require('syracuse-tablet/html/js/sdata/sdataUtils');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');

//Add display info for facet actions - Simplify by adding name.action.$edit... in resources
var _addFacetLink = function(info, facet) {
	info.icon = fontUtils.getIconByName(facet);
	switch (facet) {
		case "$edit":
		case "$query":
		case "$save":
		case "$details":
		case "$delete":
		case "$create":
			info.title = locale.text("action." + facet);
			break;
		default:
			log && log("Facet " + facet + " not implemented yet");
			info.title = facet || "???";
			break;
	}
};

var _isOfficeLink = function(name) {
	return name.smStartsWith("$word") || name.smStartsWith("$excel");
};
var _isPaginLink = function(name) {
	return name === "$first" || name === "$previous" || name === "$next" || name === "$last" || name === "$more";
};

var _linksMap = {
	header: {
		smartphone: {
			details: {
				$edit: true,
				$delete: true
			},
			edit: {
				$canceledit: true,
				$save: true
			},
			query: {
				$create: true
			},
			create: {
				$save: true,
				$canceledit: true
			}
		},
		tablet: {}
	},
	footer: {
		smartphone: {},
		tablet: {
			details: {
				$edit: true,
				$delete: true,
				$query: true
			},
			edit: {
				$save: true,
				$canceledit: true
			},
			query: {
				$create: true
			},
			create: {
				$save: true,
				$canceledit: true
			}
		}
	},
	actionpanelparent: {
		tablet: {
			details: {},
			edit: {},
			query: {},
			create: {}
		},
		smartphone: {
			details: {
				$query: true
			},
			edit: {},
			query: {},
			create: {}
		}
	},
	actionpanel: {}
};
var _getLinkMap = function(toolbar, deviceType, facet) {
	var lMap = _linksMap[toolbar];
	if (!lMap) {
		throw new Error("Unexpected toolbar parameter [" + toolbar + "]. Expected 'header', 'footer' or 'actionpanel'");
	}
	if (toolbar === "actionpanel") return lMap;
	lMap = lMap[deviceType || "tablet"];
	if (!lMap) {
		throw new Error("Unexpected deviceType parameter [" + deviceType + "]. Expected 'tablet', 'smartphone'");
	}
	if (facet === "lookup") facet = "query";
	if (facet === "summary") facet = "details";
	lMap = lMap[facet];
	if (!lMap) {
		throw new Error("Unexpected facet parameter [" + facet + "]");
	}
	return lMap;
};

/**
 * Return an array of link info according to toolbar
 *		toolbar - can be "header", "footer", "actionpanel"
 * !!! There's a hack in \lib\sdataStatelessHack._js that transform the original proto to put $actions in $links
 * 		Set a $isAction = true for actions (false for $links)
 */

var _getLinks = function(controller, toolbar, options, links) {
	var proto = controller.prototype;
	var dao = controller.dao;

	var result = links || [];
	if (!dao) {
		// dao is needed to calculated links provided by prototype
		// TODO - In the current version only regular pages (representaion) have a dao
		// So there no $link in dashboards - To add links n dashboard a dao is needed
		return [];
	}
	options = options || {};
	var lMap = _getLinkMap(toolbar, options.deviceType || globals.getSiteLayout().getDeviceType(), dao.prototype.getFacet());
	//  override prototype status with the data ones ($links properties) if exists
	//  !! dao.isChild is true fir child page  -> We don't read parent proto (just $links of the current JSON)
	//     otherwise we display the actions of the parent page in child page
	var $links = $.extend(true, {}, proto.data("$links", null, true), dao.getValue("$links"));
	if ($links && !$.isEmptyObject($links)) {
		$.each($links, function(name, value) {
			try {
				// do not consider links that are not allowed for the facet according to the links map
				// validate actionpanel links
				if (toolbar !== "actionpanel" && !lMap[name]) {
					return;
				}
				// in case of action panel, do not add facet links. They are added with 'actionpanelparent' if needed
				if (toolbar === "actionpanel" && (name === "$edit" || name === "$create" || name === "$delete" || name === "$details" || name === "$query" || name === "$save" || name === "$canceledit")) {
					return;
				}
				if (value == null || value.$isExcluded === true) {
					return;
				}
				if (value.$type != null && value.$type.length !== 0 && value.$type !== "application/json;vnd.sage=syracuse") {
					return;
				}
				var visible = name.smStartsWith('$');
				if (visible && _isOfficeLink(name)) {
					return;
				}
				if (_isPaginLink(name)) {
					return;
				}
				var info;
				if (value.$url && value.$url.length > 0) {
					var link = sdataUtils.getLinkInfo(value.$url, dao);
					info = $.extend(link, value);
					if (info.$services) {
						/**
						 * $services are considered like actions. $isACtions is not set to true in proto
						 * -> We force true in link info (used to trigger action/navigation) in action manager and side panel actions
						 */
						info.$isAction = true;
					}
				} else {
					// Child page actions - No url
					info = $.extend({}, value);
					// Force notification
					info.$isAction = true;
				}
				info.name = name;

				// add info for action panel links
				if (toolbar === "actionpanel") {
					info.title = proto.resolveExpression(value.$title);
					info.icon = "";
				} else {
					_addFacetLink(info, name);
				}

				result.push(info);

			} catch (e) {
				value = value || {};
				// Force console because unexpected
				// We don't want to stop application
				log && log("getLinks - invalid link - name:" + name + " - Title: " + proto.resolveExpression(value.$title || 'no title') + "\n\t" + (value.$url || 'no url'));
			}
		});
	}
	return result;
};
/**
 * Set pageOpts with auto scroll value to preserve scrolling when we go from detail -> edit
 * We do the same for cancelEdit action in pageRegular when we go from edit -> detail
 */
var _preserveScrolling = function(page, link, pageOpts) {
	if (!page || !link || !pageOpts) return;
	// Auto-scroll - If we edit a page we keep the scrolling
	if (page.getScrollValue() !== 0) {
		// 1.2 because the height of the page is higher in edit mode 
		// To improve or disable but to me it's great to keep the scrolling when we edit a page
		pageOpts["auto-scroll"] = page.getScrollValue() * 1.2;
	}
};
/**
 * Default message display
 * TODO - Message + detail
 */
var _displayMessage = function(title, data, cb) {
	if (data === null) data = "";
	if (jsutils.isError(data)) {
		data = data.message;
	} else if (typeof data === "string") {
		// Nothing
	} else {
		var diags = sdataUtils.scanDiagnoses(data);
		if (diags.length > 0) {
			var msg = [];
			diags.forEach(function(d) {
				msg.push(d.$message);
			});
			data = msg.join('\n');
		} else {
			data = JSON.stringify(data, null, 2);
		}
	};
	globals.getModal().info(title, data, cb);
};
/**
 * Manage action on links given by prototype
 * Used by footer/navigation panel
 *
 * options
 * 		links: 			List of link to manage - see prototype.getLinks
 * 		noMessage 		true if caller doesn't want this object to display messages
 * 	    noRedirection	true allows the caller to do the redirection
 * 		callback: 		callback interface - not implemented - It's lighter than creating child classes
 * Resolve with			success, liknInfo, data, options
 * 							success = false if action returned a diagnose
 * 						reject with javaScript error
 */
var _Klass = utils.defineClass(

	function(controller, options) {
		this.options = options || {};
		this.controller = controller;
		if (!this.options.deviceType) {
			this.options.deviceType = globals.getSiteLayout().getDeviceType();
		}
	}, null, {

		destroy: function() {
			this.options = null;
			this.controller = null;
		},
		/**
		 * To update links if by example deviceType changed
		 */
		updateLinks: function(toolbar) {
			var self = this;
			var deviceType = globals.getSiteLayout().getDeviceType();
			if (self.links && deviceType === self.options.deviceType) return;
			self.links = [];
			self.options.deviceType = deviceType;
			if (self.options.addMultiSelection && !this.controller.isEditMode()) {
				self._addMultiSelection(self.options.addMultiSelection);
			}
			_getLinks(this.controller, toolbar, self.options, self.links);
			if (self.options.addCancelEditAction && this.controller.isEditMode()) {
				self._addCancelEditAction(self.options.addCancelEditAction);
			}
			// Add specific properties
			self.links.forEach(function(l, idx) {
				if (!l.css) l.css = [];
				if (l.$isHidden === true) l.css.push("hidden");
				if (l.$isDisabled === true) l.css.push("disabled");
				l.css = l.css.join(' ');
				if (!l.icon) l.icon = fontUtils.getIconByIdx(20 + idx);
				if (!l.$uuid) l.$uuid = utils.UUID();
			});
		},
		/**
		 * Add action to links
		 */
		_addCancelEditAction: function(actionName) {
			this.links.push({
				name: "$canceledit",
				icon: fontUtils.getIconByName("$cancelEdit"),
				isClientAction: true,
				action: actionName || "cancelEdit",
				title: locale.text("action.cancelEdit")
			});
		},
		_addMultiSelection: function(actionName) {
			this.links.push({
				name: "$multiSelection",
				icon: fontUtils.getIconByName("$multiSelection"),
				isClientAction: true,
				action: actionName || "multiSelection",
				css: ["s-m-ismultisel"],
				title: locale.text("action.multiselect")
			});
		},
		getLinks: function() {
			return this.links;
		},
		hasLinks: function() {
			return this.links && this.links.length > 0;
		},
		/**
		 *  Triggers a link action/navigation and resolve/reject
		 *  		displayed eventually a message if diagnoses have been returned by server
		 *  uuid
		 *  		Id of the link which has been stored in the html (data-params)
		 *  page: optional - page that will be notified with data returned by action
		 *  	  mandatory for cancelEdit action
		 * 	options
		 * 		For a navigation link
		 * 			If options.noRedirection == true resolve with the following data
		 * 				{
		 * 					gotoPage:{
		 * 						name:"PageName",
		 * 						options{Pages options}
		 * 					}
		 * 				}
		 * 				It's the caller that calls application.changepage
		 * 			Else it does redirection to the target page
		 */
		triggerLink: function(uuid, page) {
			var deferred = $.Deferred();
			try {
				var self = this;
				// reads link info
				var link = null;
				self.getLinks().some(function(l) {
					if (l.$uuid === uuid) {
						link = l;
						return true;
					}
				});
				if (!link) return;
				// CLIENT ACTION - NON SDATA ACTION
				if (link.isClientAction) {
					if (!page) throw new Error("triggerLink - Page is expected");
					self._notifyAndResolve(page, deferred, true, link);
					return;
				}
				// ACTION WITH CONFIRMATION
				if (link.$confirm) {
					// Action with confirmation asked by server
					globals.getModal().simpleConfirm(link.$confirm, function(confirmed) {
						if (confirmed) {
							self._doLinkAction(deferred, page, link);
						}
					});
					return;
				}
				/**
				 * $isAction comes from prototype (true for save, delete...)
				 * If url contains $services $isAction is set to true (see prototype.getLinks)
				 * 		$services urls are considered as actions
				 * !! No url and $isAction means child page action
				 */
				// ACTION
				if (link.$isAction) {
					// Action which stays on the same page
					self._doLinkAction(deferred, page, link);
					return;
				}
				// NAVIGATION
				if (link.page) {
					// Navigation to a page
					var pageOpts = {
						"sdata-url": link.sDataUrl,
						"sdata-method": link.$method
					};
					if (page) {
						// Auto-scroll - If we edit a page we keep the scrolling
						if (page.state.name.replace(".$details", ".$edit") === link.page) {
							_preserveScrolling(page, link, pageOpts);
						}
					};
					if (self.options.noRedirection === true) {
						self._notifyAndResolve(page, deferred, true, link, {
							gotoPage: {
								name: link.page,
								options: pageOpts
							}
						}, self.options);
					} else {
						setTimeout(function() {
							globals.getApplication().changePage(link.page, pageOpts);
						});
						// Page is changed so it's not necessary
						deferred.resolve();
					}
					return;
				}
				// Unexpected case
				_displayMessage("Unexpected link type", link, function() {
					self._notifyAndResolve(page, deferred, false, link, null, self.options);
				});
			} catch (e) {
				deferred.reject(e);
			} finally {
				return deferred.promise();
			}
		},

		/**
		 * Send an action to server and process result
		 * Resolve/reject deferred
		 */
		_doLinkAction: function(deferred, page, link) {
			var self = this;
			var _end = function(success, data) {
				self._notifyAndResolve(page, deferred, success, link, data);
			};
			try {
				// Validate the data before processing - Synchronous call
				if (page && page.validateBeforeActionLink && page.validateBeforeActionLink(link) === false) {
					// Just resolve - No notification because action has not been sent
					deferred.resolve(false);
					return;
				}
				if (link.sDataUrl) {
					if (page) page.waitWheelStart();
					var payload = page ? page.dao.getActionPayload(link) : null;
					dispatcher.dispatch({
						$url: link.sDataUrl,
						$method: link.$method || "GET"
					}, payload).then(function(data) {
						if (page) page.waitWheelStop();
						// True for success
						_end(true, data);
					}).fail(function(e) {
						if (page) page.waitWheelStop();
						if (!jsutils.isError(e) && $.isPlainObject(e)) {
							// false for fail
							_end(false, e);
						} else {
							// Exception - we display the message
							_displayMessage("Action '" + link.title + "' failed", e, function() {
								deferred.reject(e);
							});
						}
					});
				} else {
					// Child page action - True for success - no data
					_end(true);
				}
			} catch (e) {
				_displayMessage("Action '" + link.title + "' javascript exception", e, function() {
					deferred.reject(e);
				});
			}
		},
		/**
		 * Notify (the page controller) to do some stuff after an action succeeded
		 * Save/Delete...
		 */
		_notifyAndResolve: function(page, deferred, success, link, result) {
			if (page) {
				notifications.notifyController("sm.action.link", page, success, link, result, this.options);
			}
			if (deferred) {
				deferred.resolve(success, link, result, this.options);
			}
		}
	});

exports.Klass = _Klass;
exports.getLinks = _getLinks;

/**
 * toolbar	header, footer, actionpanel...
 * opts		deviceType
 * 			addCancelEditAction
 * 				Name aof action to trigger (headerAction; footerAction...)
 * 				Link is not added if null
 * 			noMessage
 */
exports.create = function(controller, toolbar, opts, createIfNoLik) {
	var am = new _Klass(controller, opts || {});
	am.updateLinks(toolbar);
	return am;
};