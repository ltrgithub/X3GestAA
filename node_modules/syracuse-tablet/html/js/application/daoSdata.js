"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');


var _defMetaData = {
	$properties: {
		"$isExcluded": false,
		"$isHidden": false,
		"$isMandatory": false,
		"$isReadOnly": false,
		"$isDisabled": false,
		"$diagnoses": null
	},
	$links: {
		"$isDisabled": false,
		"$isHidden": false,
		"$style": false,
		"$isRequested": false
	}
};

var _typeDefValue = function(prop) {
	switch (prop.$type) {
		case "application/x-password":
		case "application/x-string":
			return "";
		case "application/x-quantity":
			return 0.0;
		case "application/x-decimal":
		case "application/x-real":
			return 0.0;
		case "application/x-integer":
			return 0;
		case "application/x-boolean":
			return false;
		case "application/x-date":
			return '';
		case "application/x-datetime":
			return '';
		case "application/x-time":
			return '';
		case "application/x-choice":
			return prop.$value.$enum[0].$value;
		default:
			return null;
	}
};
var _dataProps = ["$isMandatory", "$isReadOnly", "$isHidden", "$isExcluded", "$isDisabled", "$actions", "$format"];
var _proto2Instance = function(protoArray) {
	var res = {
		$properties: {}
	};
	if (protoArray.isSingleArray()) {

	} else {
		var props = protoArray.getDataByPath("$item.$properties");
		for (var propName in props) {
			if (!propName.smStartsWith("$")) {
				var prop = props[propName];
				res[propName] = _typeDefValue(prop);
				var $properties = res.$properties[propName] = {};
				_dataProps.forEach(function(p) {
					if (prop[p] != null) {
						$properties[p] = prop[p];
					}
				});
			}
		}
	}
	return res;
};
var _getArrayEmptyRow = function(protoArray, pathBind) {
	var rsrc;
	if (protoArray.isSingleArray()) {
		rsrc = _proto2Instance(protoArray);
	} else {
		rsrc = _proto2Instance(protoArray);
	}
	// We path pathBind as $bind in empty dao to be able to retrieve the full path of prototype in nested arrays
	return new _Dao(rsrc, protoArray, null, pathBind);
};
/**
 * Class that manages access to sdata data structure
 *  	data: 		JOSN data
 *  	prototype: 	Prototype
 *  	parent:		Parent DAO (see getPrototype)
 *  	$bind		For a child it's the name of the field from which dao has bee created
 * Manages DAO chaining parent -> child
 * !!use DAO methods instead of dealing directly with JSON
 */
var _Dao = utils.defineClass(function(data, prototype, parent, $bind) {
	var self = this;
	self.$bind = $bind || "";
	self.data = data || {};
	if (!prototype) throw new Error("Prototype is mandatory");
	if (!data) throw new Error("jsonData is mandatory");
	self.prototype = prototype;
	self.resetCache();
	self.parent = parent;
}, null, {

	destroy: function() {
		var self = this;
		self.parent = null;
		self.data = null;
		self.prototype = null;
	},
	resetCache: function() {
		this._cache = {
			metaData: {},
			queryData: null
		};
	},
	/**
	 * Set field's value
	 * For x-reference fields value can be a string or an object {$value,$description, $title}
	 */
	setValue: function(name, value, notify) {
		var done = false;
		var curVal = this.data[name];
		if (this.prototype.isReference(name)) {
			var valName = this.prototype.getFieldNameForValue(name);
			if (valName !== name) {
				// X3 entities 
				var strVal;
				if (typeof value === "object") {
					strVal = value.$value || "";
				} else {
					strVal = value + "";
				}
				if (strVal != this.data[valName]) {
					if (!curVal) curVal = {};
					// Field value
					this.data[valName] = strVal;
					if (strVal === value) {
						// value is a string - TODO remove all other properties??
						curVal.$value = strVal;
					} else {
						// set _REF value/descr/ttl to allow refresh of all fields data
						for (var p in value) {
							if (p != "$value") curVal[p] = value[p];
						}
					}
					done = true;
				}
			} else if (curVal == null || curVal.$value != value) {
				throw new Error("Syracuse entities - x-refrence setValue not implemented");
			}
		} else if (curVal == null || curVal !== value) {
			if (false && !this.prototype.isBlob(name) && typeof curVal === "object") {
				throw new Error("daoSdata.setValue - Unexpected Object value for " + name);
			}
			this.data[name] = value;
			done = true;
		}
		if (done && notify === true) {
			notifications.publish('sm.dao.updated', this, name, value);
		}
		return done;
	},
	/**
	 * Get field's value
	 */
	getValue: function(name, defValue) {
		if (!name || name.length === 0) return defValue;
		var val = this.data[name];
		if (val != null && this.prototype.isReference(name) && typeof val === "object" && val.$value == null) {
			// Add $value in value with the value of the linked field 
			var nameValue = this.prototype.getFieldNameForValue(name);
			if (nameValue != name) {
				if (false && name === globals.SINGLEARRAYPROP) {
					// !! THIS METHOD NOT USED - SEE getArrayData which adds the value in parent dataset adn works with links
					// On case of single array of x-reference the value is stored into the field object and not in parent dataset
					// Example below  for field FCY_REF -> $refValue = FCY
					// { $data:{ $description: "Site AA2 long", $title: "Site AA2", FCY: "AA2"} }
					val.$value = this.data[name][nameValue];
					if (val.$value == null && defValue != null) val.$value = defValue;
				} else {
					val.$value = this.getValue(nameValue, defValue);
				}
			} else {
				val.$value = val;
			}
			return val;
		}
		return val != null ? val : this.parent ? this.parent.getValue(name, defValue) : defValue;
	},
	/**
	 * Return the 'type' meta-data
	 * 	type		$properties for fields
	 * 				$links for actions
	 *  propName 	Name of the field for type = $properties
	 */
	getMetaData: function(type, propName) {
		if (propName != null && type == "$properties" && this.prototype.isReference(propName)) {
			propName = this.prototype.getFieldNameForValue(propName);
		}
		if (!type) throw new Error("getMetaData - type expected");
		var props = _defMetaData[type];
		if (!props) throw new Error("getMetaData - unexpected type[" + type + "]");
		var meta = this._cache.metaData[type];
		if (meta) {
			if (propName == null) return meta;
			if (propName != null && meta[propName] != null) return meta[propName];
			meta = meta[propName] = {};
		} else {
			meta = this._cache.metaData[type] = {};
			if (propName != null) meta = meta[propName] = {};
		}
		var proto = this.prototype.data(type);
		if (proto && propName != null) proto = proto[propName];
		var data = this.data[type];
		if (data && propName != null) data = data[propName];
		for (var p in props) {
			if (data && data[p] != null) {
				meta[p] = data[p];
				continue;
			} else if (proto && proto[p] != null) {
				meta[p] = proto[p];
			} else {
				meta[p] = props[p];
			}
		}
		return meta;
	},
	/**
	 * Fields $diagnoses are removed after having being displayed
	 */
	removeMetaDiagnoses: function(fieldName) {
		if (this.prototype.isReference(fieldName)) {
			fieldName = this.prototype.getFieldNameForValue(fieldName);
		}
		[this.data, this._cache.metaData].forEach(function(data) {
			var meta = data.$properties;
			if (meta && meta[fieldName]) meta[fieldName]["$diagnoses"] = undefined;
		});
	},
	getFieldInfo: function(name) {
		return {
			meta: this.getMetaData(),
			value: this.getValue()
		};
	},
	/**
	 * current proto is controller's proto
	 * name: array field name
	 * protoArray: prototype of array field
	 * Returns Array field data
	 * 	$resources an array of dao per row
	 *  No server pagination for array field in Syracuse
	 */
	getArrayData: function($bind, protoArray) {
		var self = this;
		var res = {
			$resources: [],
		};
		var rsrcs = self.getValue($bind) || [];
		if (protoArray.isSingleArray()) {
			// $resources contains an array of single type $resource:[2,6,8,9], $resources:[{$description:,$title:,FCY:},{$description:,$title:,FCY:}]
			// We create the same field structure as multiple columns arrays with a hard coded field name SINGLEARRAYPROP {$data:1} {$data:{$description:,$title:,FCY:}}
			rsrcs.forEach(function(rsrc) {
				var data = {};
				data[globals.SINGLEARRAYPROP] = rsrc;
				var proto = protoArray.getPrototype("$item");
				if (proto.property(globals.SINGLEARRAYPROP).$type === "application/x-reference") {
					// THIS METHOD IS BETTER THAN THE ONE OF  getValue BECAUSE IT'S COMPLIANT WITH LINKS
					// If it's a single array of x-reference we need to add the value ($refValue) calculated by prototype.getFieldNameForValue
					// Example below  for field FCY_REF -> $refValue = FCY
					//{
					//  	$data:{ $description: "Site AA2 long", $title: "Site AA2", FCY: "AA2"},
					//-->	FCY: "AA2"
					//}
					// TODO - test with Syracuse entities
					var valFld = proto.getFieldNameForValue(globals.SINGLEARRAYPROP);
					if (valFld) data[valFld] = rsrc[valFld];
				}
				res.$resources.push(new _Dao(data, proto, self, $bind));
			});
		} else {
			// Fix the display of values in arrays - !! dependencies with builderTable._getOtherColProto
			var protoRow = protoArray.getPrototype("$item");
			rsrcs.forEach(function(rsrc) {
				res.$resources.push(new _Dao(rsrc, protoRow, self, $bind));
			});
		}
		return res;
	},
	/**
	 * Returns query info
	 * 	Pagination info : 	$itemsPerPage $links
	 * 	Data : 				$resources an array of dao per row
	 *
	 */
	getQueryData: function(protoArray) {
		var self = this;
		var res = {
			$itemsPerPage: self.getValue("$itemsPerPage"),
			$resources: [],
			$links: self.getValue("$links")
		};
		if (!protoArray) throw new Error("getQueryData - Prototype Array is mandatory");
		var rowProto = protoArray.getPrototype("$item");
		var $bind = "$resources";
		var rsrcs = self.getValue($bind);
		rsrcs.forEach(function(rsrc) {
			res.$resources.push(new _Dao(rsrc, rowProto, self, $bind));
		});
		return res;
	},
	/**
	 * Lookup info
	 */
	getLookupData: function(protoArray) {
		return this.getQueryData(protoArray);
	},
	getQueryResources: function() {
		return this.getValue("$resources");
	},
	/* Resolve expression according to current dataset and prototype*/
	parseExpression: function(expression) {
		return utils.parseExpression(expression, this, this.prototype);
	},
	/**
	 * Set row index for arrays
	 */
	setRowIndex: function(value) {
		this.setValue(globals.ROWIDXPROP, value, false);
	},
	/**
	 * return action's payload
	 * $method: "POST"
	 * $url: "{$baseUrl}/AQMDEVICE?representation=AQMCRUDM.$create"
	 * $uuid: "6cdcb613-323f-495d-8a29-f54efad77f53"
	 * name: "$save"
	 * page: "x3.erp.SUPERV.AQMCRUDM.$create"
	 * sdataurl: "/sdata/x3/erp/SUPERV/AQMDEVICE?representation=AQMCRUDM.$create"
	 */
	getActionPayload: function(link) {
		switch (link.name) {
			case "$save":
			case "$edit":
				// TODO - Eventually remove unused properties
				return $.extend({}, this.data);
				break;
			default:
				return null;
				break;
		}
	},
	clone: function() {
		return new _Dao($.extend(true, {}, this.data), this.prototype, this.parent, this.$bind);
	},
	/**
	 * Merge dao with json (json is by example the result of an action)
	 */
	update: function(json) {
		if (!json) return;
		this.resetCache();
		$.extend(this.data, json);
	}
});
// for override only
exports.Dao = _Dao;
exports.emptyDao = function(prototype, parent) {
	return new _Dao({
		$properties: {}
	}, prototype, parent);
};
exports.getArrayEmptyRow = _getArrayEmptyRow;