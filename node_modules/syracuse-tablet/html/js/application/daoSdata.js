"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var articleParser = require('syracuse-tablet/html/js/helpers/articleParser');
var deltaManager = require('syracuse-tablet/html/js/helpers/deltaManager');


var _getResourcesTime = function($resources) {
	var utcTime = new Date().getTime();
	if (!$resources) return utcTime;
	$resources.forEach(function(item) {
		if (item.$cache) {
			utcTime = Math.min(utils.getTimeFromString(item.$cache.$lastUpdated), utcTime);
		}
	});
	return utcTime;
};

var _defMetaData = {
	$properties: {
		"$isExcluded": false,
		"$isHidden": false,
		"$isMandatory": false,
		"$isReadOnly": false,
		"$isDisabled": false,
		"$diagnoses": null,
		"$x3Format": null,
		"$value": null,
		"$format": null,
		"$capabilities": null
	},
	$links: {
		"$isDisabled": false,
		"$isHidden": false,
		"$style": false,
		"$isRequested": false
	}
};
/**
 * Recursive update of meta-data
 */
var _updt = function(src, dst) {
	var m = {}, j;
	for (var p in _defMetaData) {
		j = src[p];
		if (j && !$.isEmptyObject(j)) m[p] = j;
	}
	if (!$.isEmptyObject(m)) {
		$.extend(dst, m);
		return m;
	}
	return null;
};
var _updateMeta = function(fromData, toData, properties, isRowData) {
	if (!fromData || !toData) return false;
	var meta = _updt(fromData, toData);
	if (isRowData == true && meta && meta.$properties) {
		// We need to update the parent that there's a child on error 
		// If there's an error in a nested array we need to display the row in error at the first level
		for (var p in meta.$properties) {
			if (meta.$properties[p].$diagnoses != null) {
				toData.$arrayUpdateError = true;
				break;
			}
		}
	}
	var done = meta != null;
	if (properties) {
		for (var name in properties) {
			var proto = properties[name];
			if (proto && proto.$type === "application/x-array" && fromData[name]) {
				if (!articleParser.isSingleArray(proto)) {
					var arrSrc = fromData[name];
					var arrDst = toData[name];
					if (!arrDst) throw new Error("Unexpected empty data array - " + name);
					for (var idx = 0; idx < arrSrc.length && idx < arrDst.length; idx++) {
						// _updateMeta first
						var rowData = arrDst[idx];
						meta = _updateMeta(arrSrc[idx], rowData, proto.$item.$properties, true);
						if (rowData.$arrayUpdateError && isRowData) {
							toData.$arrayUpdateError = true;
						}
						done = meta != null || done;
					}
				} else if (proto.$item.$type === "application/x-reference") {
					// meta of x-reference single arrays are sent in data			
					var arrSrc = fromData[name];
					var arrDst = toData[name];
					var dst, src;
					for (var idx = 0; idx < arrSrc.length && idx < arrDst.length; idx++) {
						dst = arrDst[idx];
						src = arrSrc[idx];
						for (var p in _defMetaData.$properties) {
							if (src && src[p] != null) {
								dst[p] = src[p];
							} else if (proto.$item[p] != null) {
								dst[p] = proto.$item[p];
							} else {
								dst[p] = _defMetaData.$properties[p];
							}
						}
					}
				}
			}
		}
	}
	return done;
};
/**
 * Class that manages access to sdata data structure
 *  	data: 		JOSN data
 *  	prototype: 	Prototype
 *  	options.parent:		Parent DAO (see getPrototype)
 *  	options.$bind		For a child it's the name of the field from which dao has bee created
 * Manages DAO chaining parent -> child
 * !!use DAO methods instead of dealing directly with JSON
 */
var _Dao = utils.defineClass(function(data, prototype, options) {
	options = options || {};
	if (!prototype) throw new Error("Prototype is mandatory");
	this.prototype = prototype;
	this.data = data || {};
	this.$bind = options.$bind || "";
	this.parent = options.parent;
	if (!this.parent) {
		this._creationDate = new Date();
	}
	this.resetCache();
	this.enableWorkingCopy = false;
	this.resetDirty();
	this.isRowDetailDao = options.isRowDetailDao === true;
}, null, {
	/**
	 * destroyProto: true in some cases (rowDetail dao - see notifRowdetailUpdate)
	 */
	destroy: function(destroyProto) {
		this.parent = null;
		this.data = null;
		if (destroyProto === true && this.prototype) {
			this.prototype.destroy();
		}
		this.prototype = null;
	},
	resetCache: function() {
		this._cache = {
			metaData: {},
			queryData: null
		};
	},
	/**
	 * Set field's value
	 * For x-reference fields value can be a string or an object {$value,$description, $title}
	 */
	setValue: function(name, value, notify) {
		var done = false;
		var curVal = this.data[name];
		if (this.prototype.isReference(name)) {
			var valName = this.prototype.getFieldNameForValue(name);
			if (valName !== name) {
				// X3 entities 
				var strVal;
				if (typeof value === "object") {
					strVal = value.$value || "";
				} else {
					strVal = value + "";
				}
				if (strVal != this.data[valName]) {
					// Reset value
					this.data[name] = curVal = {};
					// Set field value
					this.data[valName] = strVal;
					// Set value
					if (strVal === value) {
						// value is a string - TODO remove all other properties??
						curVal.$value = strVal;
					} else {
						// set _REF value/descr/ttl to allow refresh of all fields data
						for (var p in value) {
							curVal[p] = value[p];
						}
					}
					// for ref fields in single arrays we've to set this value {$value:"ASN", FCY:"ASN"}
					curVal[valName] = strVal;
					done = true;
				}
			} else if (curVal == null || curVal.$value != value) {
				throw new Error("Syracuse entities - x-refrence setValue not implemented");
			}
		} else if (curVal == null || curVal !== value) {
			this.data[name] = value;
			done = true;
		}
		if (done) {
			this.setDirty();
		}
		return done;
	},
	resetDirty: function() {
		this.isDirty = false;
	},
	/**
	 * !! Do not call this.isDirty = true - use this methode because overridden for working copies
	 */
	setDirty: function() {
		this.isDirty = true;
	},
	/**
	 * Get field's value
	 * searchInParents should be equals to true - remove it if not used
	 */
	getValue: function(name, defValue, searchInParents) {
		if (!name || name.length === 0) return defValue;
		var val = this.data[name];
		if (val != null && this.prototype.isReference(name) && typeof val === "object" && val.$value == null) {
			// Add $value in value with the value of the linked field 
			var nameValue = this.prototype.getFieldNameForValue(name);
			if (nameValue != name) {
				val.$value = this.getValue(nameValue, defValue);
			} else {
				val.$value = val;
			}
			return val;
		}
		if (val != null) return val;
		if (searchInParents && val == null && this.parent) {
			var pVal = this.parent.getValue(name, defValue, searchInParents);
			val = pVal;
		}
		return val != null ? val : defValue;
	},
	/**
	 * Return the 'type' meta-data
	 * 	type		$properties for fields
	 * 				$links for actions
	 *  propName 	Name of the field for type = $properties
	 */
	getMetaData: function(type, propName) {
		if (!type) throw new Error("getMetaData - type expected");
		if (propName == null) return;
		/* NOTE: #6097 For Reference fields, meta data like $isHidden is set on e.g. CRY_REF NOT on CRY so there must be NO mapping from CRY_REF->CRY
		 */
		var protoPropName = propName;
		if (type === "$properties" && this.prototype.isReference(propName)) {
			propName = this.prototype.getFieldNameForValue(propName);
		}

		var meta = this._cache.metaData[type];
		if (meta) {
			if (propName == null) return meta;
			if (propName != null && meta[propName] != null) return meta[propName];
			meta = meta[propName] = {};
		} else {
			meta = this._cache.metaData[type] = {};
			if (propName != null) meta = meta[propName] = {};
		}
		var proto = this.prototype.data(type);
		if (proto && propName != null) proto = proto[protoPropName];
		var data = this.data[type];
		if (data && propName != null) data = data[propName];
		var props = _defMetaData[type];
		if (!props) throw new Error("getMetaData - unexpected type[" + type + "]");
		for (var p in props) {
			if (data && data[p] != null) {
				meta[p] = data[p];
				continue;
			} else if (proto && proto[p] != null) {
				meta[p] = proto[p];
			} else {
				meta[p] = props[p];
			}
		}
		return meta;
	},
	/**
	 * Fields $diagnoses are removed after having being displayed
	 */
	removeMetaDiagnoses: function(fieldName) {
		if (this.prototype.isReference(fieldName)) {
			fieldName = this.prototype.getFieldNameForValue(fieldName);
		}
		[this.data, this._cache.metaData].forEach(function(data) {
			var meta = data.$properties;
			if (meta && meta[fieldName]) meta[fieldName]["$diagnoses"] = undefined;
		});
	},
	getFieldInfo: function(name) {
		return {
			meta: this.getMetaData(),
			value: this.getValue()
		};
	},
	/**
	 * current proto is controller's proto
	 * name: array field name
	 * protoArray: prototype of array field
	 * Returns Array field data
	 * 	$resources an array of dao per row
	 *  No server pagination for array field in Syracuse
	 */
	getArrayData: function($bind, protoArray, localPaginator) {
		if (!protoArray) throw new Error("getArrayData - Prototype Array is mandatory");
		var arrayData;
		if (protoArray.isSingleArray()) {
			// $resources contains an array of single type $resource:[2,6,8,9], $resources:[{$description:,$title:,FCY:},{$description:,$title:,FCY:}]
			// We create the same field structure as multiple columns arrays with a hard coded field name SINGLEARRAYPROP {$data:1} {$data:{$description:,$title:,FCY:}}
			arrayData = [];
			var rsrcs = this.getValue($bind) || [];
			var meta = this.data.$properties && this.data.$properties[$bind];
			meta = meta ? meta.$items : null;
			var proto = protoArray.getPrototype("$item");
			var self = this;
			rsrcs.forEach(function(rsrc, idx) {
				var data = {};
				data[globals.SINGLEARRAYPROP] = rsrc;
				data.$uuid = utils.UUID();
				var diag = null;
				var errEntry;
				if (proto.property(globals.SINGLEARRAYPROP).$type === "application/x-reference") {
					// Add the field's value in data object {CUR_REF:{}, CUR:"USD"} -> {"~data~":{...}, CUR:"USD"}
					var valFld = proto.getFieldNameForValue(globals.SINGLEARRAYPROP);
					if (valFld) {
						data[valFld] = rsrc[valFld];
					}
					if (rsrc.$diagnoses) {
						diag = rsrc.$diagnoses;
						// Error is given by valFld $properties 
						errEntry = valFld;
					}
				} else {
					if (meta && meta[idx]) {
						diag = meta[idx].$diagnoses;
					}
					errEntry = globals.SINGLEARRAYPROP;
				}
				if (diag && diag.length > 0) {
					// add diagnoses returned by backoffice
					data.$arrayUpdateError = true;
					data.$properties = {};
					data.$properties[errEntry] = {
						$diagnoses: diag
					};
				}
				arrayData.push(new _Dao(data, proto, {
					parent: self,
					$bind: $bind
				}));
			});
		} else {
			arrayData = this._createArrayData($bind, protoArray, localPaginator);
		}
		return {
			$resources: arrayData || []
		};
	},
	/**
	 * localPaginator is defined in ctrlArray - It manages local pagination if any
	 */
	_createArrayData: function($bind, protoArray, localPaginator) {
		var res = [];
		var rsrcs = this.getValue($bind);
		if (rsrcs && rsrcs.length > 0) {
			var startIdx = localPaginator ? Math.max(0, localPaginator.currentIdx) : 0;
			var length = localPaginator ? Math.min(rsrcs.length, startIdx + localPaginator.count) : rsrcs.length;
			var protoRow = protoArray.getPrototype("$item");
			for (var i = startIdx; i < length; i++) {
				res.push(new _Dao(rsrcs[i], protoRow, {
					parent: this,
					$bind: $bind
				}));
			}
		}
		return res;
	},
	/**
	 * Returns query info
	 * 	Pagination info : 	$itemsPerPage $links
	 * 	Data : 				$resources an array of dao per row
	 */
	getQueryData: function(protoArray, localPaginator) {
		if (!protoArray) throw new Error("getQueryData - Prototype Array is mandatory");
		var res = {
			$itemsPerPage: this.getValue("$itemsPerPage"),
			$links: this.getValue("$links")
		};
		res.$resources = this._createArrayData("$resources", protoArray, localPaginator);
		return res;
	},
	/**
	 * Lookup info
	 */
	getLookupData: function(protoArray, localPaginator) {
		return this.getQueryData(protoArray, localPaginator);
	},
	getQueryResources: function() {
		return this.getValue("$resources") || [];
	},
	/* Resolve expression according to current dataset and prototype*/
	parseExpression: function(expression) {
		return utils.parseExpression(expression, this, this.prototype);
	},
	/**
	 * Set row index for arrays
	 */
	setRowIndex: function(value) {
		this.setValue(globals.ROWIDXPROP, value, false);
	},
	/**
	 * return action's payload
	 * $method: "POST"
	 * $url: "{$baseUrl}/AQMDEVICE?representation=AQMCRUDM.$create"
	 * $uuid: "6cdcb613-323f-495d-8a29-f54efad77f53"
	 * name: "$save"
	 * page: "x3.erp.SUPERV.AQMCRUDM.$create"
	 * sdataurl: "/sdata/x3/erp/SUPERV/AQMDEVICE?representation=AQMCRUDM.$create"
	 */
	getActionPayload: function(link, controller) {
		// !! We remove unused properties from dataset before sending a request
		var operations = {
			test: false,
			removeprop: {
				regExp: /^\$/,
				exclude: ["$parameters", "$uuid", "$index", "$serverIndex", "$etag", "$trackingId"]
			}
		};
		var result = this._processData(operations);
		// For test- 
		if (operations.test) {
			console.log("getActionPayload - operations - Elsaped=", new Date().getTime() - operations.startTime);
			console.log("Result: ", JSON.stringify(result, null, 2));
		}
		if (!link) return;
		var payload;
		if ((link.$method === "PUT" || link.$method === "POST") && controller && controller.isEditMode()) {
			// TODO - Eventually remove unused properties
			payload = $.extend({}, this.data);
		} else {
			payload = {};
		}
		payload.$parameters = payload.$parameters || {};
		var self = this;
		$.each(link.$parameters || [], function(name, value) {
			payload.$parameters[name] = self.parseExpression(value);
		});
		return payload;
	},
	clone: function() {
		return new _Dao($.extend(true, {}, this.data), this.prototype, {
			parent: this.parent,
			$bind: this.$bind,
			isRowDetailDao: this.isRowDetailDao === true
		});
	},
	workingCopyGetId: function(onlyIfDirty) {
		return null;
	},
	/**
	 * Merge dao with json (json is by example the result of an action)
	 * We take into account the meta $properties and $links
	 * -> It's work only with meta - Should be replaced by applyChange
	 * retuns true if meta to refresh
	 */
	updateMeta: function(src) {
		if (!src) return false;
		this.resetCache();
		var done = _updateMeta(src, this.data, this.prototype.data("$properties"));
		if (done) {
			this.setDirty();
		}
		return done;
	},
	/**
	 * Update the parent dao - used by child pages
	 * Retrun true if change has been detected
	 * create				add new row
	 * singleArrayRowIdx	index of row for singleArrayRowIdx because no $uuid
	 */
	updateParentRow: function(create, singleArrayRowIdx) {
		if (!this.parent || !this.data || $.isEmptyObject(this.data)) return false;
		var id = this.data.$uuid;
		var grid = this.parent.data[this.$bind];
		if (!grid) {
			if (!create) return false;
			grid = this.parent.data[this.$bind] = [];
		}
		var single = this.prototype.isSingleArray();
		if (create) {
			var newdata = single ? this.data[globals.SINGLEARRAYPROP] : this.data;
			grid.push($.isPlainObject(newdata) ? $.extend({}, newdata) : newdata);
		} else {
			var idx = -1;
			var newdata = this.data;
			if (single) {
				// in single arrays there's no uuid
				if (grid.length > singleArrayRowIdx) idx = singleArrayRowIdx;
				if (idx < 0) return false;
				// In signle arrays we manage data in SINGLEARRAYPROP field for compliance with other arrays
				newdata = this.data[globals.SINGLEARRAYPROP];
			} else {
				grid.some(function(r, i) {
					if (r.$uuid == id) {
						idx = i;
						return true;
					}
				});
				if (idx < 0) return false;
			}
			if (utils.areEqual(newdata, grid[idx])) return false;
			grid[idx] = $.isPlainObject(newdata) ? $.extend({}, newdata) : newdata;
		}
		this.parent.setDirty();
		return true;
	},
	/**
	 * Delete a row
	 * 	isSingleArray		> rowidoridx is the index beacuse there's no uuid in data
	 * 	not isSingleArray	-> rowidoridx is the uuid
	 */
	deleteRow: function(field, rowidoridx) {
		var grid = this.data[field];
		if (!grid) return false;
		var idx = -1;
		if (this.prototype.isSingleArray(false, field)) {
			rowidoridx = parseInt(rowidoridx, 10);
			// in single arrays there's no uuid
			if (grid.length > rowidoridx) idx = rowidoridx;
		} else {
			grid.some(function(r, i) {
				if (r.$uuid == rowidoridx) {
					idx = i;
					return true;
				}
			});
		}
		if (idx < 0) return false;
		grid.splice(idx, 1);
		this.setDirty();
		return true;
	},
	/**
	 * Called when we save a rowDetail page
	 * If the dao has errors it keeps error status ($arrayUpdateError) at true
	 * If no error it sets $arrayUpdateError to false
	 * If we save a representation with nested arrays and have an error in the last level the parent lines are shown with errors (red border)
	 * If we change the value in error we clear the error
	 * If no error remains we have to remove the error status ($arrayUpdateError) in parent lines
	 */
	checkArrayUpdateError: function() {
		var d = this.data,
			errors = false;
		if (d.$properties) {
			// check diagnoes in fields
			for (var p in d.$properties) {
				if (p.$diagnoses && p.$diagnoses.length > 0) {
					errors = true;
					break;
				}
			}
		}
		if (!errors) {
			// check error status ($arrayUpdateError) in array fields lines
			var props = this.prototype.data("$properties") || {};
			for (var p in props) {
				if (props[p].$type === "application/x-array" && this.data[p] && this.data[p].some(function(r) {
					if (r.$arrayUpdateError) return true;
				})) {
					errors = true;
					break;
				}
			}
		}
		if (!errors) {
			// If no error found reser error status to not display the red border for this row
			d.$arrayUpdateError = false;
		}
	},
	/**
	 * This is the method we shoudl call to update data + metat data
	 * It uses Daniels's deltaManager
	 * TODO - Re-implement the management of data/meta-data like in desktop client
	 */
	applyChange: function(newData, opts) {
		if (!newData) newData = {};
		this.resetCache();
		if (!opts) opts = {};
		if (opts.$isPartialDelta == null) opts.$isPartialDelta = true;
		if (opts.$isEditMode == null) opts.$isEditMode = true;
		//console.log("BEFORE", JSON.stringify(this.data, null, 2));
		deltaManager.applyObjectDelta(opts, this.data, newData);
		//console.log("AFTER", JSON.stringify(this.data, null, 2));
		this.setDirty();
	},
	isValid: function() {
		return this.prototype != null && this.data != null && this.prototype.isValid();
	},
	expired: function(timeout) {
		var creDate, dao = this;
		while (dao != null && ((creDate = dao._creationDate) != null)) {
			dao = this.parent;
		}
		if (!creDate) return false;
		return (new Date().getTime() - creDate.getTime()) > timeout;
	},
	_walkArray: function(o, operation, result) {
		if (!o) return;
		var self = this;
		o.forEach(function(e) {
			if (typeof(e) === 'object') {
				self._walk(e, operation, result);
			} else {
				// nothing
			}
		});
	},
	_walkPlainObject: function(o, operation, result) {
		if (!o) return;
		var p = Object.keys(o),
			e, name, match;
		for (var ii = 0, jj = p.length; ii < jj; ii++) {
			name = p[ii];
			e = o[name];
			if (operation.removeprop) {
				if (operation.removeprop.exclude == null || operation.removeprop.exclude.indexOf(name) === -1) {
					match = false;
					if (!match && operation.removeprop.regExp) {
						match = operation.removeprop.regExp.test(name);
					}
					if (!match && operation.removeprop.props) {
						match = operation.removeprop.props.indexOf(name) >= 0;
					}
					if (match) {
						delete o[name]; // Perhaps  o[name]= undefined; is better
						if (operation.test) {
							if (result.removeprop == null) {
								result.removeprop = {
									_nbRemoved: 0
								};
							}
							if (result.removeprop[name] == null) {
								result.removeprop[name] = 0;
							}
							result.removeprop[name]++;
							result.removeprop._nbRemoved++;
						}
					}
				}
			}
			if (typeof(e) === 'object') {
				this._walk(e, operation, result);
			} else {
				// Nothing
			}
		}
	},
	_walk: function(o, operation, result) {
		if (!o || !operation || !result) return;
		if (typeof o == 'object') {
			if (Array.isArray(o)) {
				this._walkArray(o, operation, result);
			} else if ($.isPlainObject(o)) {
				this._walkPlainObject(o, operation, result);
			}
		} else {
			// Nothing
		}
	},
	_processData: function(operation) {
		if (operation.test) {
			operation.startTime = new Date().getTime();
		}
		var result = {};
		this._walk(this.data, operation, result);
		return result;
	},

	/** data.$cacheHint:{}
	 *data.$cache: Object
	 *	$lastRead: "2015-11-10-12-05-53"
	 *		$lastUpdated: "2015-11-10-12-04-50"
	 *
	 * data.$cacheHint:{}
	 * data.$resources[0].$cache
	 *		$lastRead: "2015-11-10-12-05-53"
	 * 	    $lastUpdated: "2015-11-10-12-04-50
	 */
	dataFreshness: function() {
		var freshNess = {
			dateTime: 0
		};
		if (this.data) {
			freshNess.dateTime = new Date().getTime();
			if (this.data.dateTime) {
				//nothing for moment
				freshNess.dateTime = Math.min(freshNess.dateTime, new Date().getTime());
			}
			if (this.data.$cacheHint) {
				if (this.data.$cache) {
					freshNess.dateTime = Math.min(freshNess.dateTime, utils.getTimeFromString(this.data.$cache.$lastUpdated));
				} else {
					freshNess.dateTime = Math.min(freshNess.dateTime, _getResourcesTime(this.data.$resources));
				}
			};
		}
		return freshNess;
	},
});
// for override only
exports.Dao = _Dao;
exports.emptyDao = function(prototype) {
	return new _Dao({
		$properties: {}
	}, prototype);
};