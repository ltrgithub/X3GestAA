"use strict";

/*
 * This module handles level 2 meta data access and persistance of meta data on client side
 * See metaData.js for details
 */

var globals = require('syracuse-tablet/html/js/helpers/globals');
var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("metaData");
var storageModule = require('syracuse-tablet/html/js/storage/storage');
var sdataCommonRes = require('syracuse-tablet/html/js/sdata/sdataCommonResources');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var ajax = require('syracuse-tablet/html/js/ajax/ajax').getAjax().ajax;

function _startWait() {
	var app = globals.getApplication();
	if (app) {
		app.waitWheelStart();
	}
}

function _stopWait() {
	var app = globals.getApplication();
	if (app) {
		app.waitWheelStop();
	}
}

/*
 * Gets all application stored on the client or
 * asks the server in case there is nothing stored on the client
 *
 * Note: This reads ALL applications known, not only the ones matching the role and endpoint
 */
exports.getKnownApplications = function(context, forceReadFromServer) {
	var storage = globals.getStorage();

	var ctx = {
		"$user": "none",
		"$role": "none",
		"$lang": context.lang
	};

	var readCache;
	var cache = globals.getCache();
	if (cache.isDisabled()) { // Disabled by dev features?
		readCache = $.smResolve({
			$status: storageModule.StatusCodes.NOT_FOUND
		});
	} else {
		readCache = storage.read({
			$context: ctx,
			$collection: "$metacache_$meta_apps",
			$endpoint: "$local",
			$key: "$applications"
		});
	}
	var def = $.Deferred();
	readCache.then(function(result) {
		// If we do not request an update from the server and data is there, we are done
		if (!forceReadFromServer && result.$status === storageModule.StatusCodes.OK) {
			var apps = result.$data;
			log && log("Application list from cache");
			def.resolve(apps);
			return;
		}
		log && log("Fetching remote application list");
		sdataCommonRes.queryAllApplications()
			.then(function(apps) {
				return _storeKnownApplications(apps, ctx)
					.then(function() {
						def.resolve(apps);
					});
			})
			.fail(function(e) {
				// If we fail because of a connection issue, we will
				// fall back to the cache
				if (e && e.$noConnectionError === true && result && result.$data) {
					def.resolve(result.$data);
				}
				def.reject(e);
			});
	});
	return def.promise();
};

/*
 * Store list of apps locally
 */
function _storeKnownApplications(apps, ctx) {
	var storage = globals.getStorage();
	return storage.put({
		$context: ctx,
		$collection: "$metacache_$meta_apps",
		$endpoint: "$local",
		$key: "$applications",
		$data: apps
	}).then(function(result) {
		return apps;
	});
}

/*
 * Cached in the context of user, role and language
 * Return application detail for a given JSON description
 */
exports.getApplication = function(header, context, localOnly, forceUpdate) {
	var storage = globals.getStorage();
	var ctx = {
		"$user": context.user,
		"$role": context.role,
		"$lang": context.lang
	};

	var readCache;
	if (forceUpdate === true) {
		readCache = $.smResolve({
			$status: storageModule.StatusCodes.NOT_FOUND
		});
	} else {
		readCache = storage.read({
			$context: ctx,
			$collection: "$metacache_$meta_app",
			$endpoint: context.endpoint,
			$key: "$application_" + header.applicationName
		});
	}
	return readCache
		.then(function(result) {
			if (result.$status === storageModule.StatusCodes.OK) {
				log && log("Application details from cache");
				return result.$data;
			} else {
				if (localOnly === true) { // App not cached yet!
					return null;
				}
				log && log("Fetching remote application details");
				_startWait();
				return sdataCommonRes.queryApplicationDetail(header, context.endpoint)
					.then(function(app) {
						return _storeApplicationDetail(app, ctx, context.endpoint).then(function() {
							return app;
						});
					})
					.then(function(app) {
						_stopWait();
						return app;
					})
					.fail(function(e) {
						_stopWait();
						return $.smReject(e);
					});
			}
		});
};

/*
 * Remove all application details from local storage so they are update by querying the server
 *
 */
exports.removeApplications = function(context) {
	var storage = globals.getStorage();
	var ctx = {
		"$user": context.user,
		"$role": context.role,
		"$lang": context.lang
	};
	return storage.query({
			$context: ctx,
			$collection: "$metacache_$meta_app",
			$endpoint: context.endpoint
		})
		.then(function(result) {
			if (result.$status === storageModule.StatusCodes.OK) {
				return $.smForEachPromise(result.$data, function(app) {
					var key = "$application_" + app.$application.applicationName;
					return storage.remove({
							$context: ctx,
							$collection: "$metacache_$meta_app",
							$endpoint: context.endpoint,
							$key: key
						})
						.always(function() {
							return $.smResolve();
						});
				});
			}
		});
};

/*
 * Store details of single app locally
 */
function _storeApplicationDetail(app, ctx, ep) {
	var storage = globals.getStorage();
	return storage.put({
		$context: ctx,
		$collection: "$metacache_$meta_app",
		$endpoint: ep,
		$key: "$application_" + app.$application.applicationName,
		$data: app
	});
}

exports.updateApplicationDetail = function(app, ctx, ep) {
	return _storeApplicationDetail(app, ctx, ep);
};
/*
 * Gets a prototype
 * Asks the server in case there is nothing stored on the client
 *
 */
exports.getPrototype = function(name, context) {
	var storage = globals.getStorage();

	var ctx = {
		"$user": context.user,
		"$role": context.role,
		"$lang": context.lang
	};

	var readCache;
	readCache = storage.read({
		$context: ctx,
		$collection: "$metacache_$meta_proto",
		$endpoint: "$local",
		$key: "$prototype_" + name
	});
	return readCache.then(function(result) {
		if (result.$status === storageModule.StatusCodes.OK) {
			var proto = result.$data;
			log && log("Prototype from cache");
			return proto;
		} else {
			log && log("Fetching remote prototype");
			return _fetchRemotePrototype(name)
				.then(function(prototype) {
					return _storePrototype(name, prototype, ctx).then(function() {
						return prototype;
					});
				});
		}
	});
};

/*
 *
 */
function _fetchRemotePrototype(name) {
	var deferred = $.Deferred();
	try {
		var base = globals.baseLocation();
		var segs = name.split(".");
		var ep = segs.slice(0, 3).join("/");
		var repr = segs.slice(3, 5).join(".");
		var url = base.host + "/mobile1/" + ep + "/$prototypes('" + repr + "')";

		var headers = {
			"Accept-Language": locale.getCurrentLocale()
		};

		ajax("GET", url, null, headers)
			.then(function(data) {
				if (data.isSuccess) {
					deferred.resolve(data.responseJSON);
				} else {
					return $.smReject(data.responseJSON);
				}
			}).fail(function(e) {
				deferred.reject(e);
			});
	} catch (e) {
		deferred.reject(e);
	} finally {
		return deferred.promise();
	}
}

function _storePrototype(name, prototype, ctx) {
	var storage = globals.getStorage();
	return storage.put({
		$context: ctx,
		$collection: "$metacache_$meta_proto",
		$endpoint: "$local",
		$key: "$prototype_" + name,
		$data: prototype
	});
}