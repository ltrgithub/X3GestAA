"use strict";
/*
 * Ajax module (Default browser implementation)
 */


var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("ajaxDefault");
var utils = require('syracuse-tablet/html/js/helpers/utils');


function _AjaxInterface() {};

/*
 * All storage interfaces must inherit the "Not implemented" methods of this super class
 */
var _httpStatus = {
	"200": 'Ok',
	"201": 'Created',
	"400": 'Bad Request',
	"401": 'Unauthenticated',
	"403": 'Forbidden',
	"404": 'Not Found',
	"405": 'Method Not Allowed',
	"406": 'Not Acceptable',
	"409": 'Conflict',
	"410": 'Gone',
	"411": 'Length Required',
	"412": 'Precondition Failed',
	"413": 'Request Entity Too Large',
	"414": 'Request URI Too Long',
	"415": 'Unsupported Media Type',
	"422": 'Unprocessable Entity',
	"429": 'Too Many Requests',
	"500": 'Internal Server Error',
	"501": 'Not Implemented',
	"502": 'Bad Gateway',
	"503": 'Service Unavailable',
	"504": 'Gateway Timeout'
};
var _rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg;
var _ajaxInterfaceClass = utils.defineClass(
	_AjaxInterface,
	null, {
		ajax: function(method, url, send, headers, options) {
			var deferred = $.Deferred();
			method = method || "GET";
			options = options || {};
			var doAjax = function() {
				var allHeaders = {
					"Accept": "application/json;vnd.sage=syracuse"
				};
				if (headers) {
					$.extend(allHeaders, headers);
				}
				// TODO: Authentication
				var ajaxData = {
					headers: allHeaders,
					type: method,
					url: url,
					timeout: options.timeout == null ? 0 : options.timeout
					//processData : false
				};
				if (["PUT", "POST"].indexOf(method) >= 0 && send != null) {
					ajaxData.contentType = options.contentType || "application/json;charset=utf-8";
					if (ajaxData.contentType.indexOf("application/json") >= 0 && typeof send === "object") {
						try {
							send = JSON.stringify(send);
						} catch (e) {
							throw new Error("Error parsing send data\nurl: " + url);
						}
					};
					ajaxData.data = send;
				}
				// If completeCallback we don't parse the data 
				if (options.completeCallback) options.noJsonParsing = true;
				// We need this option to deal with non-json data
				var autoParseJson = allHeaders.Accept.indexOf("application/json") >= 0 && options.noJsonParsing !== true;
				if (autoParseJson) {
					ajaxData.dataType = "json";
				}
				log && log("'" + method + "':" + url);
				// $.ajax is replaced after startup to ensure the module  ajax/ajax.is used since $.ajax will not work
				// in winJS container because of blocked CORS.
				// Here, it's ok to use $.ajax since if we are in a winJS container, this function will be replaced by a
				// function that redirects the call to a winJS function.
				// If we end up here, we are sure we are in standalone browser mode and $.ajax will work as usually

				var ajax = $.ajax_original || $.ajax;
				var promise = ajax(ajaxData);
				if (options.completeCallback) {
					// We need this option for tests and to deal with non json data - no data processing
					promise.complete(function(jqXHR, textStatus) {
						var result = {
							textStatus: textStatus,
							responseText: jqXHR.responseText
						};
						result.status = jqXHR.status != null ? jqXHR.status : textStatus == "success" ? 200 : 500;
						result.descrHttpStatus = _httpStatus[result.status] || "";
						result.isSuccess = result.status >= 200 && result.status < 300 || result.status === 304;
						result.headers = {};
						var match, headerStr = jqXHR.getAllResponseHeaders();
						if (headerStr) {
							while ((match = _rheaders.exec(headerStr))) {
								result.headers[match[1].toLowerCase()] = match[2];
							}
						}
						// Result returns all the data needed by caller independently from jqXHR						
						// Resolve with result {status, isSuccess, responseText, headers, textStatus, descrHttpStatus}
						deferred.resolve(result);
					});
				} else {
					promise.success(function(data, textStatus, jqXHR) {
						var respHeaders = {
							status: jqXHR ? jqXHR.status : 200,
							location: jqXHR ? jqXHR.getResponseHeader("Location") : ""
						};
						deferred.resolve(data, respHeaders);
					});
					promise.error(function(jqXHR, textStatus, errorThrown) {
						var status = jqXHR ? jqXHR.status : 200;
						if (status == 200 && (status.responseText == null || status.responseText.trim() == 0)) {
							// this is an invalid response, handle it as server error for now
							status = 500;
						}

						var respHeaders = {
							status: status,
							location: jqXHR ? jqXHR.getResponseHeader("Location") : ""
						};
						deferred.reject(status, respHeaders);
					});
				}
				return promise;
			};

			doAjax();
			return deferred.promise();
		}
	}
);

exports.AjaxInterfaceClass = _ajaxInterfaceClass;