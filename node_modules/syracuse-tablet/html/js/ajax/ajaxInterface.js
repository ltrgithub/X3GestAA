"use strict";
/*
 * Ajax module (Default browser implementation)
 */


var log = require('syracuse-tablet/html/js/helpers/logger').getLogger("ajax");
var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');

// Locale module passed in init because if dependency cycle
var _locale;

function _AjaxInterface() {};

var _httpStatus = {
	"200": 'Ok',
	"201": 'Created',
	"400": 'Bad Request',
	"401": 'Unauthenticated',
	"403": 'Forbidden',
	"404": 'Not Found',
	"405": 'Method Not Allowed',
	"406": 'Not Acceptable',
	"409": 'Conflict',
	"410": 'Gone',
	"411": 'Length Required',
	"412": 'Precondition Failed',
	"413": 'Request Entity Too Large',
	"414": 'Request URI Too Long',
	"415": 'Unsupported Media Type',
	"422": 'Unprocessable Entity',
	"429": 'Too Many Requests',
	"500": 'Internal Server Error',
	"501": 'Not Implemented',
	"502": 'Bad Gateway',
	"503": 'Service Unavailable',
	"504": 'Gateway Timeout'
};
var _rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg;
var _ajaxInterfaceClass = utils.defineClass(
	_AjaxInterface,
	null, {
		/**
		 *
		 * Parameters:
		 *
		 * method: GET, PUT, POST, DELETE, HEAD
		 * url: http URL
		 * send: Data to send (Objects will be stringified to json on POST and PUT)
		 * headers: headers to add to the request
		 * options: {
		 *   noJsonParsing: true, : Returns response body as string without trying to parse and return an object. (Default: Parse and return object)
		 *   timeout: 1000 : Request timeout (Default: 0)
		 *   dontCatchHttp401: true (Default: false): true = Return 401 to caller instead of redirecting to login page
		 * }
		 *
		 * When promise is resolved, callback gets the following object as parameter:
		 * {
		 *     textStatus: e.g. "success", "errror"
		 *     status: http status code (200, 404, 500, ...)
		 *     descrHttpStatus: description of http status code (e.g. "Internal Server Error")
		 *     isSuccess: true for: status >= 200 && status < 300 || status === 304
		 *     responseJSON: Contains parsed object returned by server (Unless response did not contain JSON or option noJsonParsing was set)
		 *     responseText: Contains response as returned by server (as string)
		 *     headers: { ... } : Contains returned http headers
		 * }
		 *
		 */
		ajax: function(method, url, send, headers, options) {
			var deferred = $.Deferred();
			try {
				method = method ? method.toUpperCase() : "GET";
				/*
				 * https://github.com/Sage-ERP-X3/Syracuse/issues/6824
				 * Not sure what the intension of this is
				 * Doing a GET with payload is not valid, sending an arbitrary payload
				 * by query params is not possible and also done wrong here for object type values
				 * So removed for now
				if (method === "GET" && send) {
					if (url.indexOf('?') === -1) url += "?";
					var params = [];
					for (var p in send) {
						if (send[p] != null) {
							params.push(encodeURIComponent(p) + "=" + encodeURIComponent(send[p].toString()));
						}
					}
					url += params.join('&');
				}
				*/
				options = options || {};
				var doAjax = function() {
					try {
						var lang = _locale && _locale.getCurrentLocale();
						var allHeaders = {
							"Accept": "application/json;vnd.sage=syracuse",
						};
						if (lang) {
							allHeaders["Accept-Language"] = lang;
						}
						if (headers) {
							$.extend(allHeaders, headers);
						}
						// TODO: Authentication
						var ajaxData = {
							headers: allHeaders,
							type: method,
							url: url,
							timeout: options.timeout == null ? 0 : options.timeout
							//processData : false
						};
						if (["PUT", "POST"].indexOf(method) >= 0 && send != null) {
							ajaxData.contentType = options.contentType || "application/json;charset=utf-8";
							if (ajaxData.contentType.indexOf("application/json") >= 0 && typeof send === "object") {
								try {
									send = JSON.stringify(send);
								} catch (e) {
									throw new Error("Error parsing send data\nurl: " + url);
								}
							};
							ajaxData.data = send;
						}
						var timeLine = utils.getTimeLine("ajax", url);
						timeLine && timeLine.start("send");
						// We need this option to deal with non-json data
						var parseJson = allHeaders.Accept.indexOf("application/json") >= 0 && options.noJsonParsing !== true;
						if (parseJson) {
							ajaxData.dataType = "json";
						}
						log && log("'" + method + "':" + url);
						// $.ajax is replaced after startup to ensure the module  ajax/ajax.is used since $.ajax will not work
						// in winJS container because of blocked CORS.
						// Here, it's ok to use $.ajax since if we are in a winJS container, this function will be replaced by a
						// function that redirects the call to a winJS function.
						// If we end up here, we are sure we are in standalone browser mode and $.ajax will work as usually

						var ajax = $.ajax_original || $.ajax;
						var promise = ajax(ajaxData);
						promise.complete(function(jqXHR, textStatus) {
							try {
								timeLine && timeLine.step("completed");
								var status = jqXHR.status != null ? jqXHR.status : textStatus == "success" ? 200 : 500;
								var result = {
									textStatus: textStatus,
									status: status,
									descrHttpStatus: _httpStatus[status] || ("unknown: " + status),
									isSuccess: status >= 200 && status < 300 || status === 304,
									headers: {}
								};
								if (parseJson) {
									result.responseJSON = jqXHR.responseJSON;
								} else {
									result.responseText = jqXHR.responseText;
								}
								var match, headerStr = jqXHR.getAllResponseHeaders();
								if (headerStr) {
									while ((match = _rheaders.exec(headerStr))) {
										result.headers[match[1].toLowerCase()] = match[2];
									}
								}
								if (status === 0 && !(options.dontCatchHttp0 === true)) {
									_handleHttp0(deferred, result);
									return;
								}
								if (status === 401 && !(options.dontCatchHttp401 === true)) {
									_handleHttp401(deferred, result);
									return;
								}
								deferred.resolve(result);
							} catch (e) {
								deferred.reject(e);
							}
						});
					} catch (e) {
						deferred.reject(e);
					}
				};
				doAjax();
			} catch (e) {
				deferred.reject(e);
			}
			return deferred.promise();
		}
	}
);

exports.AjaxInterfaceClass = _ajaxInterfaceClass;

/*
 * config
 * locale moduel syracuse-tablet/html/js/helpers/locale passed as parameter because of dependencies
 *
 */
exports.init = function(config, locale) {
	_locale = locale;
	config = config || {};
	$.ajaxSetup({
		timeout: config.timeout == null ? 20000 : config.timeout,
		async: true
	});
};

/*
 *
 */
function _handleHttp401(deferred, result) {
	if (globals.isTestEnvironment()) {
		deferred.reject("Please login before running this testcase");
		return;
	}
	var responseJSON = result.responseJSON;
	if (!responseJSON) {
		try {
			responseJSON = JSON.parse(result.responseText);
		} catch (e) {} // if we cannot parse, we will not get a diag below and let the error bubble up
	}
	var diag = responseJSON && responseJSON.$diagnoses && responseJSON.$diagnoses[0];
	var link = diag && diag.$links && diag.$links.$redirect;
	if (!link) { // Response unexpected, resume original chain any maybe report error
		deferred.resolve(result);
		return;
	}

	var diag = {
		$message: _locale.text("error.session.timeout"),
		$severity: "error",
		$links: {
			$redirect: link
		}
	};
	responseJSON = responseJSON || {};
	/* We only set our own diag on 401 and do not add it to the one comming from the server
	responseJSON.$diagnoses = responseJSON.$diagnoses || [];
	responseJSON.$diagnoses.unshift(diag);
	*/
	responseJSON.$diagnoses = [diag];
	responseJSON.$redirectPage = "login";

	result.responseJSON = responseJSON;
	deferred.resolve(result);
}
/**
 * Set the right message and $noConnectionError to true for caller
 */
function _handleHttp0(deferred, result) {
	result.responseJSON = {
		"$noConnectionError": true,
		"$diagnoses": [{
			"$message": (_locale ? _locale.text("no.connection") : "No network connection") + " - HttpStatus=0",
			"$severity": "error"
		}]
	};
	deferred.resolve(result);
}