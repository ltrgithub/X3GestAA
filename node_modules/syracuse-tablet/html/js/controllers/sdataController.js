"use strict";

var Base = require("syracuse-tablet/html/js/controllers/controller").Controller;

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var sdataReq = require("syracuse-tablet/html/js/sdata/sdataRequester");
var protocolHelpers = require("syracuse-tablet/html/js/sdata/protocolHelpers");
var environment = require('syracuse-tablet/html/js/helpers/environment');
var modules = require('syracuse-tablet/html/js/common/modules');
var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');
var locale = require('syracuse-tablet/html/js/helpers/locale');


var _isServiceLink = function($link) {
		if (!$link) {
			return false;
		}
		return $link.$url.indexOf("$services") >= 0 || $link.$method === "DELETE";
	}
	/**
	 * parent can be null (formController)
	 */
exports.SdataController = utils.defineClass(
	function SdataController(dataset, parent, isWorkingCopy) {
		Base.call(this, parent);

		this.controlsByBind = {};

		// This is to hold client side only diagnoses per field that are generated by the widgets
		// E.g. checks on $minValue or $maxLength
		// It's better to hold these information in the controller and not the widgets because
		// widgets should not have non UI state
		this.clientDiagnosesByBind = {};

		this.dataset = dataset;

		this.isWorkingCopy = true; // Default
		if (isWorkingCopy !== undefined) { // Given by parameter?
			this.isWorkingCopy = isWorkingCopy;
		} else if (parent != null) { // Try to set from parent if available
			this.isWorkingCopy = parent.isWorkingCopy;
		}

		this.dataset.addDeltaChangeListener(this);
		this.pendingRequests = 0;
	},
	Base, {

		destroy: function() {
			if (this.destroyed === true) {
				return;
			}
			if (this.dataset) {
				this.dataset.removeDeltaChangeListener(this);
			}

			// Ask server to delete working copy?
			if (this.isWorkingCopy && this.isRoot()) {
				if (this.dataset) {
					// This is async but we do not care about the result, since if it does not work,
					// there is nothing more we can do
					sdataReq.deleteWC(this.dataset);
				}
			}

			if (this.isRoot()) {
				this.dataset.destroy();
			}
			this.dataset = null;
			this.prototype = null;
			this.clientDiagnosesByBind = null;
			Base.prototype.destroy.call(this);
		},

		//
		// CONTROLS START
		//
		registerControl: function(ctrl) {
			Base.prototype.registerControl.call(this, ctrl);
			var $bind = ctrl.$bind;
			if ($bind) {
				var perBind = this.controlsByBind[$bind] = this.controlsByBind[$bind] || [];
				perBind.push(ctrl);
			}
		},
		unregisterControl: function(ctrl) {
			Base.prototype.unregisterControl.call(this, ctrl);
			var $bind = ctrl.$bind;
			if ($bind) {
				var perBind = this.controlsByBind[$bind];
				if (perBind) {
					var idx = perBind.indexOf(ctrl);
					if (idx > -1) {
						perBind.splice(idx, 1);
					}
					if (perBind.length == 0) {
						delete this.controlsByBind[$bind];
					}
				}
			}
		},
		_controlsByBind: function($bind) {
			var c = this.controlsByBind[$bind];
			return c;
		},
		getControlsByBind: function($bind) {
			return this._controlsByBind($bind);
		},
		/**
		 * Used to store client side generated diagnoses for a field inside the controller
		 */
		setClientDiagnoses: function($bind, diags) {
			diags = diags || [];
			// Sometimes we receive string instead of diagnoses (internally) - It's ok to consider strings as errors
			for (var i = 0; i < diags.length; i++) {
				if (typeof diags[i] == "string") {
					diags[i] = {
						"$severity": "error",
						"$message": diags[i]
					}
				}
			}
			this.clientDiagnosesByBind[$bind] = diags;
		},
		/**
		 * Return all diagnoses set for a specific field
		 * Array will be empty or client side diagnoses first, server side diagnoses second
		 * $$severity1, 2, ...: optional - add only the given severities
		 */
		getDiagnoses: function($bind, $severity1, $severity2) {
			var client = this.clientDiagnosesByBind[$bind] || [];
			var server = this.dataset.getDiagnoses($bind);
			var diags = [];
			Array.prototype.push.apply(diags, client);
			Array.prototype.push.apply(diags, server);
			var severities = Array.prototype.slice.call(arguments, 1);
			if (severities == null || severities.length == 0) {
				return diags;
			}
			var results = [];
			diags.forEach(function(d) {
				if (severities.indexOf(d.$severity) >= 0) {
					results.push(d);
				}
			})
			return results
		},
		/**
		 * The purpose if this method is to scan all controls which have client side diagnoses set
		 * If there is a diagnoses, this means the widget may render a different value than the dataset
		 * because the user typed something invalid that violates constraints like "$minValue"
		 */
		findErrornousControls: function() {
			var self = this;
			var errors = [];
			Object.keys(self.clientDiagnosesByBind).forEach(function($bind) {
				var diags = self.clientDiagnosesByBind[$bind];
				if (diags && diags.length > 0) {
					var controls = self.controlsByBind[$bind];
					controls && controls.forEach(function(control) {
						if (!control.validateInput()) {
							errors.push(control);
						}
					});
				}
			});
			return errors;
		},
		//
		// CONTROLS END
		//				

		//
		// SDATA START
		//				

		/**
		 * Called by UI to get a value
		 */
		getValue: function($bind) {
			return this.dataset.getValue($bind);
		},
		/**
		 * Called by UI to set a value
		 * 
		 * $bind: Property for which to set the value
		 * value: value
		 * updateUI: Set to true if UI needs to be update, this can happen if one control sets the value of another one
		 * 
		 */
		setValue: function($bind, value, updateUI, noServerUpdate) {
			this.dataset.setValue($bind, value);

			if (updateUI === true) {
				if (noServerUpdate === true) {
					// We assume that the value is OK (lookup input) so we delete the potential diagnose
					// eg: We input a bad value into a ref field + blur -> A diagnose is displayed
					//     Then we select a value -> We have to clear the server diagnose
					//     We need to clear the diagnose here because it should remain displayed if we cancel the lookup dialog
					this.dataset.clearDiagnoses(this.$bind);
				}
				this.onDeltaValueChanged(this.dataset, $bind);
			}

			if (noServerUpdate !== true) {
				this.root._updateServer($bind)
					.fail(function(result) {
						modules.get("modal").error(result);
					});
			}
		},
		/**
		 * 
		 */
		addRow: function() {
			var row = this.dataset.addRow();
			return this.root._updateServer()
				.then(function() {
					return row;
				});
		},
		/**
		 * 
		 */
		removeRow: function($uuid) {
			this.dataset.removeRow($uuid);
			return this.root._updateServer();
		},
		getLazyUrl: function($bind) {
			return this.dataset.getValue($bind, this.isWorkingCopy);
		},
		/**
		 * Called by UI to get meta data
		 */
		getMetaData: function($bind) {
			return this.dataset.getMetaData($bind);
		},
		/**
		 * Called by UI when an sdata action is clicked
		 * Resolves with (success, response)
		 */
		triggerAction: function($actionName) {
			var self = this;
			return $.smResolve()
				.then(function() {
					if (!self.dataset.isRoot()) {
						// Actions are only allowed on root level of the representation
						return false;

					}
					var $action = self.dataset.getAction($actionName);
					var $title = $action && $action.$title;
					$title = $title || $actionName;
					$title = self.dataset.resolveExpression($title);

					// Check if there are client side data changes that are not in the dataset yet
					// because of invalid input like too big, mandatory not filled, ...
					// If we fail here, no need to ask the server
					var errorControls = self.findErrornousControls();
					if (errorControls.length > 0) {
						self._showNotification($title, locale.text("action.check.input"), "error");
						return false;
					}

					var resultPromise = $.Deferred();
					self._countRequest(sdataReq.triggerAction($actionName, self.dataset, self.isWorkingCopy))
						.fail(function(response) {
							// We end here if http code is <> 2xx
							var diag = (response.data && response.data.$diagnoses ? response.data : (response.$diagnoses ? response : response));
							if (diag) {
								modules.get("modal").error(diag);
							}
							resultPromise.resolve(false, response);
						})
						.then(function(response) {
							var delta = response.data;
							if (delta) {
								// If there is a delta sent by the server, we merge it
								// This will add field level diagnoses
								// error checking will be done later independently
								return self._mergeDelta(delta).then(function() {
									return response;
								});
							}
							return response;
						})
						.then(function(response) {
							return protocolHelpers.computeActionResult($actionName, response);
						})
						.then(function(result) {
							// 
							if (result.$diagnoses && result.$diagnoses.length > 0) {
								var diag = result.$diagnoses[0];
								self._showNotification($title, diag.$message, diag.$severity);
							}
							if (result.success) {
								// There may be a $redirect link in the actions meta data we could use to navigate to the next page
								// from here
								resultPromise.resolve(true, result);
							} else {
								// Failed, so do nothing and let user modify data
								resultPromise.resolve(false, result);
							}
						});
					return resultPromise.promise();
				})
				.always(function() {
					if (environment.isAutoUITestMode()) {
						self._updatePageUpdateCycle();
					}
				});


		},

		/**
		 * Called by UI when a sdata link is clicked
		 */
		triggerLink: function($linkName) {
			var self = this;
			return $.smResolve()
				.then(function() {
					var $link = self.dataset.getLink($linkName);
					if (!$link) {
						return;
					}

					// Check if the links is a link to a dashboard with parameters in V11 syntax and convert it to a valid one
					// return input if it's any other url
					$link = protoHelpers.transformOldDashboardUrl($link, self.dataset);

					return self.openLink($link, null, null, $linkName);
				})
		},

		/**
		 * Trigger navigation to the given link
		 * May switch $url and $method of link depending on protocol to be used (working copy / stateless)
		 */
		openLink: function($link, pageOptions, loadOptions, $linkName) {
			var self = this;
			$link = protocolHelpers.adjustLinkProtocol($link, this._getUsedProtocol());

			function _openLink() {
				var $url = self.dataset.resolveExpression($link.$url, true);
				if (!$url) {
					return $.smResolve();
				}
				if (_isServiceLink($link)) {
					return self._executeLink($linkName, $url, $link.$method);
				} else {
					$url = protoHelpers.addClientContext($url, self.dataset.root.json.$clientContext);
					return self.gotoUrl($url, $link.$method, pageOptions, loadOptions);
				}
			}
			if ($link.$confirm) {
				return self._askConfirmation($link.$confirm)
					.then(function(confirmed) {
						if (confirmed === "yes") {
							return _openLink();
						}
					});
			} else {
				return _openLink();
			}
		},
		/**
		 * Used to managed DELETE links which are more like actions
		 * Resolves with (success, response)
		 */
		_executeLink: function($linkName, $url, $method) {
			var self = this;

			var $link = self.dataset.getLink($linkName);
			var $title = $link && $link.$title;
			$title = self.dataset.resolveExpression($title);
			$title = $title || $linkName;

			var resultPromise = $.Deferred();

			self._countRequest(sdataReq.executeLink($url, $method, self.dataset))
				.fail(function(response) {
					// We end here if http code is <> 2xx
					if (response && response.$diagnoses) {
						var diag = response.$diagnoses[0];
						self._showNotification($title, diag.$message, "error");
					}
					resultPromise.resolve(false, null);
				})
				.then(function(response) {
					if (response.data) {
						// If there is a delta sent by the server, we merge it also for service links (field diagnoses)
						return self._mergeDelta(response.data).then(function() {
							return response;
						});
					}
					return response;
				})
				.then(function(response) {
					if (response.data && response.data.$diagnoses) {
						var diag = response.data.$diagnoses[0];
						self._showNotification($title, diag.$message, diag.$severity);
					}
					resultPromise.resolve(true, response);
				});

			return resultPromise.promise();
		},
		triggerDrillLevel: function(level, rowDataset) {
			if (rowDataset.getLink("$drillDown")) {
				this.drillDownLink(level, rowDataset)
			} else if (rowDataset.getLink("levelUp")) {
				this.levelUpLink(level, rowDataset)
			}
		},
		drillDownLink: function(level, dataset) {
			// when drill is called from array, the dataset of the row is this.dataset
			// else the dataset is the parameter ( see getChartClickHandler in builderChart)
			var rowDataset = dataset || this.dataset
			var $link = rowDataset.getLink("$drillDown");
			if (!$link || !$link.$url) return null
			var $url = rowDataset.resolveExpression($link.$url);

			this.gotoUrl($url, null, {
				isChild: false,
				context: {
					controllerId: this.id
				},
				isChartDetail: true,
				level: level + 1
			});
		},
		levelUpLink: function(level, dataset) {
			var rowDataset = dataset || this.dataset
			var $link = rowDataset.getLink("levelUp");
			if (!$link || !$link.$url) return null
			var $url = protoHelpers.getHostPort() + rowDataset.resolveExpression($link.$url);

			this.gotoUrl($url, null, {
				isChild: false,
				context: {
					controllerId: this.id
				},
				isChartDetail: true,
				level: level + 1
			});
		},
		/**
		 * 
		 */
		_updateServer: function($bind, forceUpdateAll) {
			var self = this;
			return $.smResolve()
				.then(function() {
					if (!self.isWorkingCopy) {
						return $.smResolve();
					}
					if (!self.isRoot()) {
						return $.smResolve();
					}
					if (forceUpdateAll !== true && !self.dataset.isDirty()) {
						return $.smResolve();
					}
					return self._countRequest(sdataReq.updateServer(self.dataset, $bind, forceUpdateAll))
						.then(function(response) {
							if (self.destroyed) {
								// Occurs if we change a value in an input field and click on back
								// -> page is closed before server response has been received
								return;
							}
							return self._mergeDelta(response.data);
						})
				})
				.always(function() {
					if (environment.isAutoUITestMode()) {
						self._updatePageUpdateCycle();
					}
				});
		},
		forceUpdateServer: function() {
			return this._updateServer(null, true);
		},
		_updatePageUpdateCycle: function() {
			var $$page = $('.s-m-page[data-controller-id="' + this.id + '"]');
			environment.getUnitTestMgr().setPageUpdateCycle($$page);
		},
		/**
		 * 
		 * Merge delta into local dataset and notify affected widgets on changes
		 * Returns delta given to this function so chaining is possible
		 */
		_mergeDelta: function(delta) {
			this.dataset.applyDelta(delta);
			if (this.isRoot() && this.uiAdapter) {
				this.uiAdapter.notifyScrollerUpdate();
			}
			return $.smResolve(delta);
		},
		getCacheContext: function() {
			return modules.get("appController").App.getCacheContext();
		},
		//
		// SDATA END
		//		
		/**
		 * 
		 * @param promise
		 */
		_countRequest: function(promise) {
			var self = this;
			self.pendingRequests = self.pendingRequests + 1;
			self._updateRequestCount(self.pendingRequests);
			return promise.always(function(result) {
				self.pendingRequests = self.pendingRequests - 1;
				self._updateRequestCount(self.pendingRequests);
				return result;
			});
		},

		//
		// DELTA MANAGEMENT START		
		//				

		/**
		 * Used by dataset delta listeners to signal value changes
		 * dataset must be this.dataset, only passed to function for flexibility reasons 
		 */
		onDeltaValueChanged: function(dataset, $bind) {
			var ctrls = this._controlsByBind($bind);
			if (ctrls) {
				for (var ii = 0, jj = ctrls.length; ii < jj; ii++) {
					var ctrl = ctrls[ii];
					ctrl.onValueChanged && ctrl.onValueChanged();
				}
			}
		},
		/**
		 * Used by dataset delta listeners to signal meta data changes
		 * dataset must be this.dataset, only passed to function for flexibility reasons
		 */
		onDeltaMetaChanged: function(dataset, $bind) {
			var ctrls = this._controlsByBind($bind);
			if (ctrls) {
				var setCtrlErrFocus = null;
				for (var ii = 0, jj = ctrls.length; ii < jj; ii++) {
					var ctrl = ctrls[ii];
					// onMetaChanged -> true if a diagnose has been rendered
					if (ctrl && ctrl.onMetaChanged && ctrl.onMetaChanged() === true && setCtrlErrFocus == null) {
						// Save the first control to put the focus on
						setCtrlErrFocus = ctrl;
					}
				}
				if (this.uiAdapter && this.uiAdapter.notifChildError) {
					// Notifies uiAdapter that there could be an error  (highlight row if there's a an error in children)
					// setCtrlErrFocus == null doesn't mean necessarily that there's no error (EG: nested array if there's only one field's error in the last level)
					this.uiAdapter.notifChildError();
				}
				if (setCtrlErrFocus) {
					// Put focus on first field (at least make it visible)
					setCtrlErrFocus.setFocus();
				}
			}
		},
		/**
		 * Used by dataset delta listeners to signal rows have been added to array
		 * dataset must be this.dataset, only passed to function for flexibility reasons 
		 */
		onDeltaRowAdded: function(dataset, $bind, $uuid, idx) {
			if (this.uiAdapter && jsutils.isInstanceOf(this.uiAdapter, "CtrlArray")) {
				this.uiAdapter.onDeltaRow("added", dataset, $uuid, idx);
			}
		},
		/**
		 * Used by dataset delta listeners to signal rows have been removed on array
		 * dataset must be this.dataset, only passed to function for flexibility reasons
		 */
		onDeltaRowRemoved: function(dataset, $bind, $uuid, idx) {
			if (this.uiAdapter && jsutils.isInstanceOf(this.uiAdapter, "CtrlArray")) {
				this.uiAdapter.onDeltaRow("removed", dataset, $uuid, idx);
			}
		},
		/**
		 * Called when a row has moved
		 * Note that this will be called in the order of the smallest target row first
		 * So the UI can always remove the row from it's current position and move it to the new one
		 * All later notifications will have an impact on rows with higher new indices only
		 */
		onDeltaRowMoved: function(dataset, $bind, $uuid, newIdx) {
			if (this.uiAdapter && jsutils.isInstanceOf(this.uiAdapter, "CtrlArray")) {
				this.uiAdapter.onDeltaRow("moved", dataset, $uuid, newIdx);
			}
		},
		/**
		 * Used by dataset delta listeners to signal meta data changes for an action
		 */
		onDeltaActionChanged: function(dataset, $action, metaData) {
			this.onMenuItemChanged($action, null, metaData); // Implemented by standard controller to find affected widgets and trigger rendering
		},
		/**
		 * Used by dataset delta listeners to signal meta data changes for a link
		 */
		onDeltaLinkChanged: function(dataset, $link, $bind, metaData) {
			this.onMenuItemChanged($link, $bind, metaData); // Implemented by standard controller to find affected widgets and trigger rendering
		},

		//
		// DELTA MANAGEMENT END		
		//

		//		
		// UI EVENT LISTENER START 
		//

		/**
		 * uiAdapter can implement beforeOnSdataActionClicked/afterOnSdataActionClicked if needed
		 * -> beforeOnSdataActionClicked resolves with goAhead true/false
		 * Eg: Multi-selection action is handled at page level and returns false
		 * -> afterOnSdataActionClicked 
		 * Allows the page to do some job after the action has been executed
		 * Eg: go to detail facet after save...
		 * method: "triggerLink" or "trigerAction"
		 */
		_checkUIAdapterAction: function(actionName, method) {
			var first;
			if (this.uiAdapter && this.uiAdapter.beforeOnSdataActionClicked) {
				first = this.uiAdapter.beforeOnSdataActionClicked(actionName, this);
			} else {
				first = $.smResolve(true, null);
			}
			var self = this;
			return first.then(function(goAhead, beforeContext) {
				//beforeContext is passed from beforeOnSdataActionClicked to afterOnSdataActionClicked
				if (goAhead !== true) {
					return true;
				}
				return method.call(self, actionName).then(function(successOrPage, response) {
					var currentPage, success;
					if (jsutils.isInstanceOf(successOrPage, "PageSdata")) {
						// Page has changed (non service link $edit)
						currentPage = successOrPage;
						response = null;
						success = true;
					} else {
						// Same page (action/service $save)
						currentPage = self.uiAdapter;
						success = successOrPage;
					}
					if (currentPage && currentPage.afterOnSdataActionClicked) {
						currentPage.afterOnSdataActionClicked(actionName, success, beforeContext, response);
					}
					return success;
				});
			}).fail(function(result) {
				modules.get("modal").error(result);
			});
		},

		onSdataLinkClicked: function($linkName) {
			if ($linkName === "$edit" || _isServiceLink(this.dataset.getLink($linkName))) {
				// These links are handled like actions
				return this._checkUIAdapterAction($linkName, this.triggerLink);
			}
			// navigation link (details...)
			return this.triggerLink($linkName).fail(function(result) {
				modules.get("modal").error(result);
			});
		},

		onSdataActionClicked: function(actionName) {
			return this._checkUIAdapterAction(actionName, this.triggerAction);
		},

		//		
		// UI EVENT LISTENER END 
		//				

		isEditMode: function() {
			var facet = this.getFacet();
			if (["$edit", "$create"].indexOf(facet) > -1) {
				return true;
			}
			return false;
		},
		getFacet: function() {
			return this.dataset.getRoot().prototype.getFacet();
		},

		/**
		 * Hook a new dataset to current controller
		 * This is used when page data has changed from outside (e.g. pagination or filtering)
		 */
		setDataset: function(dataset) {
			this.dataset.removeDeltaChangeListener(this);
			this.dataset = dataset;
			this.dataset.addDeltaChangeListener(this);
		},

		_getUsedProtocol: function() {
			var rootDataset = this.root.dataset;
			var $mobileProtocol = rootDataset && rootDataset.json.$clientContext && rootDataset.json.$clientContext.$mobileProtocol;
			return $mobileProtocol;
		},

		// Not finalized yet, just a draft that will be used by cancel on row
		// detail pages to revert a working copy
		applyDatasetBackup: function(datasetJson) {
			var self = this;
			var dataset = self.dataset;
			var prototype = self.dataset.prototype;

			var $binds = Object.keys(this.controlsByBind);
			$binds.forEach(function($bind) {
				//if (dataset.isDirty($bind)) {
				if (prototype.isReference($bind)) {
					var val = prototype.propGetRefValueName($bind);
					self.setValue(val, datasetJson[val], true, true);
				} else if (prototype.propIsSimple($bind)) {
					self.setValue($bind, datasetJson[$bind], true, true);
				}
				//}
			});

			return this.root._updateServer();
		},
		actChartToolbarSetDisplay: function(opts) {
			var articles = this.getArticlesByBind("$resources");
			if (this.uiAdapter && this.uiAdapter.actToolbarSetDisplay) {
				return this.uiAdapter.actToolbarSetDisplay(opts);
			}
		},
		getArticlesByBind: function($bind) {
			var chartArticle, arrayChartArticle;
			var controls = this.getControlsByBind($bind);
			controls.forEach(function(ctrl) {
				if (ctrl.isArrayChart()) {
					if (ctrl.isHighChart()) {
						chartArticle = $.extend(true, {}, ctrl.article);
					} else {
						arrayChartArticle = $.extend(true, {}, ctrl.article);
					}
				}
			})
			return {
				"chartArticle": chartArticle,
				"arrayChartArticle": arrayChartArticle
			}
		},
		getChart: function() {
			var controls = this.getControlsByBind("$resources");
			var chart
			controls.forEach(function(ctrl) {
				if (ctrl.isArrayChart()) {
					if (ctrl.isHighChart()) {
						chart = ctrl
					}
				}
			})
			return chart;
		},
		canBePinned: function() {
			return (!this.uiAdapter.pageData.prototype.isApplication());
			// a page can be pinned/unpind if it's not an application dashboard;
		},
		setActionAdapterArrayOptions: function(arrayOptions, ctrl) {
			this.uiAdapter.actionAdapter.showSortFilter = arrayOptions.showSortFilter;
			this.uiAdapter.actionAdapter.showSearch = arrayOptions.showSearch;
			this.uiAdapter.actionAdapter.searchCtrl = ctrl;
		},
		isStackBarAvailable: function() {
			var article = this.uiAdapter.getArticle();
			var stackList = this.getRootStackList();
			return stackList.length > 1 && (stackList.length === article.$items.length);
		},
		getRootStackList: function() {
			var article = this.uiAdapter.getArticle();
			if (!article.$items) return [];
			var stackList = article.$items.filter(function(item) {
				return (item.$layoutType === "stack")
			})
			return stackList;
		},
		showNavigationStackBar: function() {
			return (this.isStackBarAvailable() & this.uiAdapter.getArticle().$stackbar)
		}
	}
);