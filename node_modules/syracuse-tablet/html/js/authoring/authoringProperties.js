"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var authVal = require('syracuse-tablet/html/js/authoring/authoringVal');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');

var _err = function(title, ee) {
	modal.error(title, ee);
	return true;
};


var _properties = {
	/*
	 * Titel hidden
	 */
	"isTitleHidden": {
		"key": "$isTitleHidden",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: _createMarkupRadio,
		type: "default" // Default, just for header color selection
	},

	/* 
	 * Position of label
	 * left:   <label> <value>
	 *
	 * top:    <label>
	 * 		   <value>
	 */
	"labelPosition": {
		"key": "$labelPosition",
		"default": "left",
		"values": [{
			"value": "left"
		}, {
			"value": "top"
		}],
		createMarkup: _createMarkupRadio
	},

	/* 
	 * Text alignment of label
	 * left:   |<label>      |
	 * right:  |      <value>|
	 */
	"labelAlign": {
		"key": "$labelAlign",
		"default": "left",
		"values": [{
			"value": "left"
		}, {
			"value": "center",
			"isHidden": true
		}, {
			"value": "right"
		}],
		createMarkup: _createMarkupRadio,
		refreshMarkup: _refreshMarkupRadio
	},

	/* 
	 * Theme for control
	 */
	"theme": {
		"key": "$theme",
		"default": "a",
		"values": [{
			"value": "a"
		}, {
			"value": "b"
		}, {
			"value": "c"
		}],
		createMarkup: _createMarkupRadio
	},

	/*
	 * Reference field description position
	 * bottom: <value>
	 *         <desc>
	 *
	 * right:  <value> <desc>
	 * left:   <desc> <value>
	 *
	 * top:    <desc>
	 *         <value>
	 */
	"refDescPosition": {
		"key": "$refDescPosition",
		"default": "right",
		"values": [{
			"value": "bottom"
		}, {
			"value": "right"
		}, {
			"value": "left"
		}, {
			"value": "top"
		}, {
			"value": "none"
		}],
		createMarkup: _createMarkupRadio
	},

	/*
	 * Reference field description format
	 * desc:      <desc>
	 *         
	 * title:     <title>

	 * desctitle: <desc> - <title>
	 * -> If both values are equal, skip display of second value
	 * 
	 * titledesc: <title> - <desc>
	 * -> If both values are equal, skip display of second value
	 */
	"refDescFormat": {
		"key": "$refDescFormat",
		"default": "desc",
		"values": [{
			"value": "desc"
		}, {
			"value": "title"
		}, {
			"value": "desctitle"
		}, {
			"value": "titledesc"
		}],
		createMarkup: _createMarkupRadio
	},
	/*
	 * Color of tile and layout cell
	 */
	"tileColor": {
		"key": "$bgColor",
		"default": "lime",
		"values": [{
			"value": "transparent"
		}, {
			"value": "teal"
		}, {
			"value": "green"
		}, {
			"value": "brown"
		}, {
			"value": "lime"
		}, {
			"value": "red"
			/*		}, { disabled for now, does not fit nicely into the palette
			"value": "purple" */
		}, {
			"value": "pink"
		}, {
			"value": "magenta"
		}, {
			"value": "orange"
		}, {
			"value": "blue"
		}],
		createMarkup: _createMarkupRadioBgColor
	},

	/*
	 * Size of tile
	 */
	"tileSize": {
		"key": "$size",
		"default": "medium",
		"values": [{
			"value": "small"
		}, {
			"value": "medium"
		}, {
			"value": "wide"
		}, {
			"value": "large"
		}, {
			"value": "full"
		}, {
			"value": "all"
		}],
		createMarkup: _createMarkupRadio
	},

	/*
	 * Title of layout node
	 */
	"layoutTitle": {
		"key": "$title",
		"default": "",
		createMarkup: _createMarkupInput
	},


	/*
	 * Title of a tile
	 */
	"tileTitle": {
		"key": "$title",
		"default": "",
		createMarkup: _createMarkupInput
	},

	/*
	 * Height of layout stack
	 */
	"rowHeight": {
		"key": "$rowHeight",
		"default": "200px",
		createMarkup: _createMarkupInput
	},

	/*
	 * Size of tile
	 *
	 * Handles the following elements: $widthXs, $widthSm, $widthMd, $widthLg
	 */
	"cellSize": {
		"default": 4,
		createMarkup: _createMarkupCellSize
	},

	"arrayDisplay": {
		"key": "$display",
		"default": "table",
		values: [{
			value: "table"
		}, {
			value: "cardV"
		}, {
			value: "cardH"
		}],
		createMarkup: _createMarkupRadio
	},

	// only cardV	
	"arrayCardsPerRow": {
		"key": "$cardsPerRow",
		"default": "1",
		values: [{
			value: "1"
		}, {
			value: "2"
		}, {
			value: "3"
		}],
		createMarkup: _createMarkupRadio,
		refreshMarkup: _refreshMarkupRadio
	},

	// only cardH
	"arrayCellSizes": {
		"key": "$cellSizes",
		"default": "medium",
		"values": [{
			"value": "small"
		}, {
			"value": "medium"
		}, {
			"value": "wide"
		}, {
			"value": "large"
		}],
		createMarkup: _createMarkupRadio,
		refreshMarkup: _refreshMarkupRadio
	},

	// only cardH
	"arrayEmptyCells": {
		"key": "$emptycell",
		"default": "nodisplay",
		values: [{
			value: "filled"
		}, {
			value: "withtitle"
		}, {
			value: "nodisplay"
		}],
		createMarkup: _createMarkupRadio,
		refreshMarkup: _refreshMarkupRadio
	},

	// only query array
	"arrayQueryFilters": {
		"key": "$filters",
		"default": "list",
		values: [{
			value: "list"
		}, {
			value: "tabs"
		}, {
			value: "none"
		}],
		createMarkup: _createMarkupRadio,
		refreshMarkup: _refreshMarkupRadio
	},

	// only query array - link to details values are created dynamically
	"arrayDetailsLink": {
		"key": "$detailsLink",
		"default": "$details",
		values: [],
		createMarkup: _createMarkupRadio,
		refreshMarkup: _refreshMarkupRadio
	},

	// only CLOB field (text plain, text html, text rtf)
	"textHeight": {
		"key": "$textHeight",
		"default": "medium",
		values: [{
			value: "small"
		}, {
			value: "medium"
		}, {
			value: "large"
		}, {
			value: "xlarge"
		}],
		createMarkup: _createMarkupRadio,
		refreshMarkup: _refreshMarkupRadio
	},

	/*
	 *	Display numeric data either as normal number field or as gauge
	 */
	"numDisplay": {
		"key": "$numDisplay",
		"default": "normal",
		values: [{
			value: "normal"
		}, {
			value: "gauge"
		}],
		createMarkup: _createMarkupRadio,
		refreshMarkup: _refreshMarkupRadio
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Says whether gauge has min AND max value (kind of a boolean)
	 */
	"gSetBorderValues": {
		"key": "$gSetBorderValues",
		"default": "no",
		values: [{
			value: "yes"
		}, {
			value: "no"
		}],
		createMarkup: _createMarkupRadio,
		refreshMarkup: _refreshMarkupRadio
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Says how gauge border values (min and max) are set
	 *	It will be either through a prototype property or with a direct input
	 */
	"gBorderValuesType": {
		"key": "$gBorderValuesType",
		"default": "input",
		values: [{
			value: "input"
		}, {
			value: "property"
		}],
		createMarkup: _createMarkupRadio,
		refreshMarkup: _refreshMarkupRadio
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Set border values (min/max). It will be either a textarea or a selector
	 */
	"gBorderValues": {
		"default": "",
		createMarkup: _createMarkupGBorderValues
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Number of gauge segmets
	 */
	"gSegmentsNumber": {
		"default": "",
		createMarkup: _createMarkupGSegmentsNumbers
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Configure gauge segments
	 */
	"gSegmentsConfig": {
		"default": "",
		createMarkup: _createMarkupGSegmentsConfig
	},

	/*
	 * Dummy to add a separator
	 */
	"SEPARATOR": {},

	/*
	 * Used to allow creation of a new layout for the whole page
	 */
	"pageLAYOUTType": {
		"key": "$pageLAYOUTType",
		createMarkup: _createMarkupGenLayout,
	},

	/*
	 * Full JSON article of selection for experts
	 */
	"JSON": {
		"key": "$JSON",
		createMarkup: _createMarkupJSON,
		type: "expert"
	},
	/*
	 * Read only display of prototype
	 */
	"PROTOTYPE": {
		"key": "$PROTOYPE",
		createMarkup: _createMarkupPrototype,
		type: "expert"
	},

};


var _initProperties;
exports.initProperties = function(helpers) {
	/* 
	 * TODO: Handle language change
	 */
	if (_initProperties) {
		return;
	}

	var pre = "auth";
	Object.keys(_properties).forEach(function(prop) {
		var lk = pre + "." + prop;
		var p = _properties[prop];
		if (p.label == null) {
			p.label = locale.text(lk);
		}
		p.name = prop;
		if (p.values) {
			p.values.forEach(function(v) {
				var vk = lk + "." + ("" + v.value);
				if (v.label == null) {
					v.label = locale.text(vk);
				}
			});
		}
	});
	_initProperties = true;
};

exports.getAllProperties = function() {
	return _properties;
};

/*
 * Which layout node supports which properties to edit in authoring
 */
var _layoutProps = {
	"stack": [],
	"row": [_properties.rowHeight],
	"hub-group": [_properties.layoutTitle],
	"tile": [_properties.tileTitle, _properties.tileColor, _properties.tileSize],
	"cell": [_properties.tileColor, _properties.cellSize]
};

exports.getProperties = function(sel, data) {

	var $$elmt = sel.$$elmt;
	var props = [];

	var controller = utils.findController($$elmt);
	/*
	 * Layout nodes have simple static properties
	 */
	if ($$elmt.hasClass("s-m-layout")) {
		Object.keys(_layoutProps).some(function(key) {
			var cls = "s-m-" + key;
			if ($$elmt.hasClass(cls)) {
				_layoutProps[key].forEach(function(p) {
					props.push(p);
				});
				return true;
			}
			return false;
		});
	} else if ($$elmt.hasClass("s-m-field")) {
		// Properties for all types of fields
		var labelAlign = _getLabelAlign(sel, data);
		var props = [_properties.isTitleHidden, _properties.labelPosition, labelAlign, _properties.theme];

		// Properties for reference fields only 
		if (data.type === "reference") {
			props.push(_properties.refDescFormat);
			props.push(_properties.refDescPosition);
		}

		// Properties for enriched text fields only (html, plain, rtf)
		if (data.type === "rtf" || data.type === "html" || data.type === "plain") {
			props.push(_properties.textHeight);
		}

		// Properties for numeric field
		_setNumDisplayConfig(data, props);

	} else if ($$elmt.hasClass("s-m-array")) {
		var labelAlign = _getLabelAlign(sel, data);
		var cardsPerRow = _getArrayCardsPerRow(sel, data);
		var cellSizes = _getArrayCellSizes(sel, data);
		var displayEmptyCells = _getArrayEmptyCells(sel, data);
		var queryFiltersOpts = null;
		if (_supportsFilterAuthoring(controller)) {
			queryFiltersOpts = _getArrayQueryFilters(sel, data);
		}
		var detailsLinkOpts = null;
		if (controller && controller.prototype.isQuery()) {
			detailsLinkOpts = _getQueryDetailsLinkOptions(controller, sel, data);
		}
		var props = [_properties.isTitleHidden, _properties.labelPosition, labelAlign, _properties.theme, _properties.arrayDisplay, cardsPerRow, cellSizes, displayEmptyCells];
		if (queryFiltersOpts) {
			props.push(queryFiltersOpts);
		}
		if (detailsLinkOpts) {
			props.push(detailsLinkOpts);
		}
	}

	// Only for page to add function to create default layout
	if ($$elmt.hasClass("s-m-page")) {
		props.push(_properties.pageLAYOUTType);
	}

	// Always add JSON editting and proto display
	props.push(_properties.SEPARATOR);
	if ($$elmt.hasClass("s-m-page")) {
		props.push(_properties.JSON);
	}
	props.push(_properties.PROTOTYPE);
	return props;
};

function _setNumDisplayConfig(data, props) {
	if (data.type === "integer" || data.type === "real" || data.type === "decimal") {

		var isGauge = data.articleSelection["$gauge"] ? true : false;

		// set $numDisplay article value
		data.articleSelection["$numDisplay"] = isGauge ? "gauge" : "normal";

		props.push(_properties.numDisplay);

		// push gauge authoring properties according to article values
		if (isGauge) {

			// set the value of "gSetBorderValues" property
			if (data.articleSelection["$gauge"]["$bindMin"] && data.articleSelection["$gauge"]["$bindMax"]) {
				data.articleSelection["$gSetBorderValues"] = "yes";
			}

			// add "gSetBorderValues" property
			props.push(_properties.gSetBorderValues);

			// if "gSetBorderValues" is set to "yes"
			// add "gBorderValuesType" and "gBorderValues" properties
			if (data.articleSelection["$gSetBorderValues"] === "yes") {
				// TODO
				/*var hasBorderVal = data.articleSelection["$gauge"]["$bindMax"] ? true : false;
				if(!data.articleSelection["$gBorderValuesType"]){
					data.articleSelection["$gBorderValuesType"] = hasBorderVal ? (typeof data.articleSelection["$gauge"]["$bindMin"] == "string" ? "property" : "input") : "input";	
				}

				props.push(_properties.gBorderValuesType);*/
				props.push(_properties.gBorderValues);
			}

			// add "gSegmentsNumber" property
			props.push(_properties.gSegmentsNumber);

			// add segments if necessary
			if (data.articleSelection["$gauge"].segments && data.articleSelection["$gauge"].segments.length > 0) {
				props.push(_properties.gSegmentsConfig);
			}
		}
	}
}

function _supportsFilterAuthoring(controller) {
	if (controller && (controller.prototype.isLookup() || controller.prototype.isQuery())) {
		return controller._$filters && controller._$filters.length > 0;
		// Also on  a smartphone combobox will never be allowed, we do not disable authoring since in preview, we might set smartphone
		// and a user should see rendering is done as tabs
		// && globals.getSiteLayout().getDeviceType() !== "smartphone";		
	}
	return false;
}

function _isQuery(controller) {
	if (controller && (controller.prototype.isLookup() || controller.prototype.isQuery())) {
		return controller._$filters && controller._$filters.length > 0;
		// Also on  a smartphone combobox will never be allowed, we do not disable authoring since in preview, we might set smartphone
		// and a user should see rendering is done as tabs
		// && globals.getSiteLayout().getDeviceType() !== "smartphone";		
	}
	return false;
}
// Centered label is only possible on top or bottom positioned label
function _getLabelAlign(sel, data) {
	var valPos = _getValueOrDefault(_properties.labelPosition, sel, data);

	var props = $.extend(true, {}, _properties.labelAlign);
	props.values.forEach(function(val) {
		if (valPos === "left" && val.value === "center") {
			val.isHidden = true;
		} else {
			val.isHidden = false;
		}
	});
	return props;
}

//Only for cardV
function _getArrayCardsPerRow(sel, data) {
	var valPos = _getValueOrDefault(_properties.arrayDisplay, sel, data);
	if (valPos !== "cardV") {
		return _propertyValuesHideAll(_properties.arrayCardsPerRow, true);
	} else {
		return _propertyValuesHideAll(_properties.arrayCardsPerRow, false);
	}
}

//Only for cardH
function _getArrayCellSizes(sel, data) {
	var valPos = _getValueOrDefault(_properties.arrayDisplay, sel, data);
	if (valPos !== "cardH") {
		return _propertyValuesHideAll(_properties.arrayCellSizes, true);
	} else {
		return _propertyValuesHideAll(_properties.arrayCellSizes, false);
	}
}

//Only for card<xxx>
function _getArrayEmptyCells(sel, data) {
	var valPos = _getValueOrDefault(_properties.arrayDisplay, sel, data);
	if (valPos === "table") {
		return _propertyValuesHideAll(_properties.arrayEmptyCells, true);
	} else {
		return _propertyValuesHideAll(_properties.arrayEmptyCells, false);
	}
}

//Only for array in queries
function _getArrayQueryFilters(sel, data) {
	return _propertyValuesHideAll(_properties.arrayQueryFilters, false);
}
//Only for array in queries
function _getQueryDetailsLinkOptions(controller, sel, data) {
	if (!controller.getControl(sel.id)) return null;
	var links = controller.getControl(sel.id).prototype.getDataByPath("$item.$links");
	if (!links || links.length === 0) return null;
	var props = $.extend(true, {}, _properties.arrayDetailsLink);
	if (!props.values) {
		props.values = [];
	}
	if (controller.isVignette) {
		// Add the capability to open query full page - Default option
		props.default = "$queryfullpage";
		props.values.push({
			value: "$queryfullpage",
			label: locale.text("auth.arrayDetailsLink.queryfullpage")
		});
	}
	// Add $links
	$.each(links, function(key, link) {
		props.values.push({
			value: key,
			label: link.$title ? controller.prototype.resolveExpression(link.$title) + " - " + key : key
		});
	});
	if (props.length === 1 && props[0].value === "$details") return null;
	return _propertyValuesHideAll(props);
}

/*
 * Enable or disable all possible values of a authoring property
 */
function _propertyValuesHideAll(property, hide) {
	var props = $.extend(true, {}, property);
	props.values.forEach(function(val) {
		val.isHidden = hide;
	});
	return props;
}

function _getValueOrDefault(prop, sel, data) {
	var value = data.articleSelection && data.articleSelection[prop.key];
	value = (value != null) ? value : prop["default"];
	return value;
}

function _setValue(prop, sel, data, value) {
	data.articleSelection[prop.key] = value;
}

function _createMarkupRadio($$parent, prop, sel, data) {

	var ctx = {
		group: "auth_opt_" + prop.name,
		options: []
	};

	var value = _getValueOrDefault(prop, sel, data);
	var allHidden = true;

	prop.values.forEach(function(v) {
		ctx.options.push({
			id: ctx.group + "_" + v.value,
			value: "" + v.value,
			label: v.label,
			display: (v.isHidden ? "none" : "block")
		});
		allHidden = allHidden && v.isHidden;
	});

	var html = authHtml.execute("authPanelPropertyRadio", ctx);
	var $$panel = $(html);
	$("label[data-s-m-auth-value='" + ("" + value) + "']", $$panel).eq(0).button("toggle");
	$("label", $$panel).on("click", function(e) {
		var $$ct = $(e.currentTarget);
		var value = $$ct.attr("data-s-m-auth-value");
		$$ct.eq(0).button("toggle");

		/*
		 * Important! Use boolean datatype for boolean properties!
		 */
		if (value === "true") {
			value = true;
		} else if (value === "false") {
			value = false;
		}
		_setValue(prop, sel, data, value);
		_notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);

	if (allHidden) {
		$$parent.parent(".s-m-panel-auth-prop").hide();
	} else {
		$$parent.parent(".s-m-panel-auth-prop").show();
	}
}

function _refreshMarkupRadio($$parent, prop, sel, data) {
	var allHidden = true;
	prop.values.forEach(function(v) {
		var id = "auth_opt_" + prop.name + "_" + v.value;
		var $$btn = $("#" + id, $$parent);
		var display = v.isHidden ? "none" : "block";
		$$btn.css("display", display);
		allHidden = allHidden && v.isHidden;
	});
	if (allHidden) {
		$$parent.parent(".s-m-panel-auth-prop").hide();
	} else {
		$$parent.parent(".s-m-panel-auth-prop").show();
	}
}

function _createMarkupRadioBgColor($$parent, prop, sel, data) {

	var ctx = {
		group: "auth_opt_" + prop.name,
		options: []
	};

	var value = _getValueOrDefault(prop, sel, data);

	prop.values.forEach(function(v) {
		ctx.options.push({
			id: ctx.group + "_" + v.value,
			value: "" + v.value,
			label: v.label,
			color: v.value
		});
	});

	var html = authHtml.execute("authPanelPropertyRadioColor", ctx);
	var $$panel = $(html);
	$("label[data-s-m-auth-value='" + ("" + value) + "']", $$panel).eq(0).button("toggle");
	$("label", $$panel).on("click", function(e) {
		var $$ct = $(e.currentTarget);
		var value = $$ct.attr("data-s-m-auth-value");
		$$ct.eq(0).button("toggle");

		/*
		 * Important! Use boolean datatype for boolean properties!
		 */
		if (value === "true") {
			value = true;
		} else if (value === "false") {
			value = false;
		}
		_setValue(prop, sel, data, value);
		_notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);
}


function _createMarkupInput($$parent, prop, sel, data) {
	var value = _getValueOrDefault(prop, sel, data);
	var html = authHtml.execute("authPanelPropertyInput", {
		id: "auth_opt_" + prop.name,
		value: value
	});
	var $$panel = $(html);
	$("input", $$panel).blur(function() {
		var value = $(this).val();
		_setValue(prop, sel, data, value);
		_notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);
}

function _createMarkupCellSize($$parent, prop, sel, data) {
	var values = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
	var sizes = [{
		"prop": "widthXs",
		"label": locale.text("auth.cellSize.$widthXs"),
		"class": "s-m-auth-highlight-xs"
	}, {
		"prop": "widthSm",
		"label": locale.text("auth.cellSize.$widthSm"),
		"class": "s-m-auth-highlight-sm"
	}, {
		"prop": "widthMd",
		"label": locale.text("auth.cellSize.$widthMd"),
		"class": "s-m-auth-highlight-md"
	}, {
		"prop": "widthLg",
		"label": locale.text("auth.cellSize.$widthLg"),
		"class": "s-m-auth-highlight-lg"
	}];

	var html = authHtml.execute("authPanelPropertyCellSize", {
		id: "auth_opt_" + prop.name,
		sizes: sizes,
		values: values
	});
	var $$panel = $(html);
	var last = "12";
	sizes.forEach(function(size) {
		var value = data.articleSelection && data.articleSelection["$" + size.prop];
		value = value || last;
		last = value;
		$("label[data-s-m-auth-prop='" + size.prop + "'][data-s-m-auth-value='" + value + "']", $$panel).button("toggle");
	});

	$("label", $$panel).on("click", function(e) {
		var $$ct = $(e.currentTarget);
		$$ct.eq(0).button("toggle");
		sizes.forEach(function(size) {
			$$ct = $$panel.find("label.active[data-s-m-auth-prop='" + size.prop + "']");
			if ($$ct.length > 0) {
				var value = $$ct.attr("data-s-m-auth-value");
				data.articleSelection["$" + size.prop] = value;
			}
		});
		_notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);
}

function _createMarkupGBorderValues($$parent, prop, sel, data) {
	//TODO localize
	var ctx = {};
	ctx.label_apply = "Apply";
	var idMin = "s-m-auth-g-borders-min";
	var idMax = "s-m-auth-g-borders-max";

	// markup depends if border type is input or property
	var isProperty = data.articleSelection["$gBorderValuesType"] === "property" ? true : false;

	// if property, build a selection markup, filled with numeric types within the prototype
	if (isProperty) {
		//TODO

		ctx.label_tip = "Select properties in which min and max values are set. Both have to be set to be recognized";
		ctx.label_min = "Bind min";
		ctx.label_max = "Bind max";
	}

	// if input, build input markup
	else {
		//var valMin = data.articleSelection["$gauge"]["$bindMin"] ? parseInt(data.articleSelection["$gauge"]["$bindMin"], 10) : "";
		//var valMax = data.articleSelection["$gauge"]["$bindMax"] ? parseInt(data.articleSelection["$gauge"]["$bindMax"], 10) : "";
		var valMin = data.articleSelection["$gauge"]["$bindMin"] || "";
		var valMax = data.articleSelection["$gauge"]["$bindMax"] || "";

		ctx.label_tip = "Enter min and max values. Both have to be set to be recognized";
		ctx.label_min = "Minimum value";
		ctx.label_max = "Maximum value";
		ctx.markupMin = authHtml.execute("gaugeBorderInput", {
			id: idMin,
			value: valMin
		});
		ctx.markupMax = authHtml.execute("gaugeBorderInput", {
			id: idMax,
			value: valMax
		});
	}

	var html = authHtml.execute("authPanelPropertyGBorderValues", ctx);
	var $$panel = $(html);

	// /!\ In bind, allow use of 0
	// onclick, update data and refresh
	$("button", $$panel).on("click", function(e) {
		var err = false;
		var vvMin = $(e.target).parent().find("#" + idMin).val();
		var vvMax = $(e.target).parent().find("#" + idMax).val();

		// min and max are both numbers
		if (!isNaN(parseInt(vvMin), 10) && !isNaN(parseInt(vvMax), 10)) {

			if (vvMax < vvMin) {
				//TODO localize
				err = _err("Gauge Authoring Error - Border values", "Max " + vvMax + " is lower than Min " + vvMin);
			}
			// else, all good. update value
		} else {

			// min and max should both be string values
			if (!(typeof vvMin == "string" && typeof vvMax == "string")) {
				//TODO localize
				err = _err("Gauge Authoring Error - Border values", "Expected both values as Strings. Min=" + vvMin + " Max=" + vvMax);
			}

			// if min and max are supposed to be numbers
			// TODO
			/*if (!isProperty) {
				//TODO localize
				err = _err("Gauge Authoring Error - Border values", "Expected numbers. Min=" + vvMin + " Max=" + vvMax);
			}*/
			// TODO maybe another control ?
			// else, all good. update value
		}

		if (!err) {
			data.articleSelection["$gauge"]["$bindMin"] = vvMin;
			data.articleSelection["$gauge"]["$bindMax"] = vvMax;
			_notifyChangePropUI($$parent, sel, data);
		}
	});

	// append html
	$$parent.append($$panel);
}


function _createMarkupGSegmentsNumbers($$parent, prop, sel, data) {
	// build html
	//TODO localize
	var value = data.articleSelection["$gauge"].segments ? data.articleSelection["$gauge"].segments.length : "";
	var ctx = {
		id: "s-m-auth-g-segnumbers-txt",
		label_apply: "Apply",
		value: value
	};

	var html = authHtml.execute("authPanelPropertyGSegmentsNumber", ctx);
	var $$panel = $(html);

	// bind click on apply button
	// onclick, update data and refresh
	$("button", $$panel).on("click", function(e) {

		var vv = $(e.target).prev().val();

		if (value != vv) {
			if (vv && isNaN(parseInt(vv, 10))) {
				//TODO localize
				_err("Gauge Authoring Error - Segments number", "Expected a number, got '" + vv + "'");
			} else {
				if (vv) {
					data.articleSelection["$gauge"]["segments"] = data.articleSelection["$gauge"]["segments"] || [];
					if (data.articleSelection["$gauge"]["segments"].length > vv) {
						data.articleSelection["$gauge"]["segments"].splice(vv);
					}
					for (var ii = 0, jj = vv; ii < jj; ii++) {
						data.articleSelection["$gauge"]["segments"][ii] = data.articleSelection["$gauge"]["segments"][ii] || {};
					}
				} else {
					data.articleSelection["$gauge"]["segments"] = null;
				}
				_notifyChangePropUI($$parent, sel, data);
			}
		}
	});

	// append html
	$$parent.append($$panel);
}

function _createMarkupGSegmentsConfig($$parent, prop, sel, data) {
	// TODO localize

	// build html
	var tabs = [];
	var segs = data.articleSelection["$gauge"].segments;

	for (var ii = 0, jj = segs.length; ii < jj; ii++) {

		var segInfo = {};
		segInfo.id = "s-m-auth-seg-" + ii;
		segInfo.title = "Segment " + (ii + 1);

		segInfo.label_valstart = "Val Start";
		segInfo.value_valstart = segs[ii].valStart;

		segInfo.label_valend = "Val End";
		segInfo.value_valend = segs[ii].valEnd;

		segInfo.label_propstart = "Prop Start";
		segInfo.value_propstart = segs[ii].propStart;

		segInfo.label_propend = "Prop End";
		segInfo.value_propend = segs[ii].propEnd;

		segInfo.label_color = "Color";
		segInfo.value_color = segs[ii].color;

		tabs.push(segInfo);
	}

	var html = authHtml.execute("gaugeSegmets", {
		tabs: tabs,
		label_apply: "Apply"
	});
	var $$panel = $(html);

	// set nav tabs width
	var navTabs = $("ul.nav.nav-pills li", $$panel);
	var width = navTabs.length === 1 ? "100%" : Math.round(1000 * 100 / navTabs.length) / 1000 + "%";
	$.each(navTabs, function(idx, val) {
		$(val).width(width);
	});
	/*$(navTabs).forEach(function(t) {
		t.setWidth(width);
	});*/

	/*
	 *	Bind events
	 */

	// update range output value
	$("input", $$panel).on("input", function(e) {
		var $$input = $(e.target);
		var $$output = $$input.next();
		$$output.val($$input.val());
	});

	// update active tab style
	navTabs.on("click", function(e) {
		var navs = $("ul.nav.nav-pills li", $$parent);
		navs.toggleClass("active", false);
		$(e.target).toggleClass("active", true);
	});

	// bind click on apply button
	// onclick, update data and refresh
	$("button", $$panel).on("click", function(e) {
		var segs = [];
		var tabs = $(".tab-pane", $$parent);
		for (var ii = 0, jj = tabs.length; ii < jj; ii++) {
			var $$tab = $(tabs[ii]);
			var id = $$tab.attr("id");
			var segInfo = {};
			segInfo.valStart = $(id + "-valstart", $$tab).val();
			segInfo.valEnd = $(id + "-valend", $$tab).val();
			segInfo.propStart = $(id + "-propstart", $$tab).val();
			segInfo.propEnd = $(id + "-propend", $$tab).val();
			segInfo.color = $(id + "-color", $$tab).val();

			//TODO validate values
			segs.push(segInfo);
		}

		data.articleSelection["$gauge"]["segments"] = segs;
		_notifyChangePropUI($$parent, sel, data);
	});

	$$parent.append($$panel);
}

function _createMarkupGenLayout($$parent, prop, sel, data) {
	var html = authHtml.execute("authPanelPropertyGenLayout", {
		id: "auth_opt_" + prop.name,
		label_horizontal: locale.text("auth.panel.label_horizontal"),
		label_vertical: locale.text("auth.panel.label_vertical")
	});
	var $$panel = $(html);
	$("label", $$panel).click(function() {
		if ($(this).attr("id") === "s-m-auth-new-layout-horizontal") {
			notifications.publish(["sm.auth.new.layout"], "horizontal");
		} else {
			notifications.publish(["sm.auth.new.layout"], "vertical");
		}
	});
	$$parent.append($$panel);
}

function _createMarkupJSON($$parent, prop, sel, data) {
	// This is only displayed if the full page is selected, so we always show the article of the page and not the article
	// of the selected UI compontent (UI component is always the page)
	var value = authVal.toSortedJSON(data.articlePage);
	var html = authHtml.execute("authPanelPropertyJSON", {
		id: "auth_opt_" + prop.name,
		value: value,
		label_apply: locale.text("auth.panel.label_apply")
	});
	var $$panel = $(html);
	var apply = function(value) {
		// Full page article exchange
		var articleParsed = authVal.validateJSON(true, value, _properties);
		if (articleParsed) {
			var articlePage = authVal.toSortedJSON(articleParsed);
			notifications.publish(["sm.auth.change.prop.ui"], articlePage);
		}
	};
	$("button", $$panel).click(function() {
		apply($("textarea", $$panel).val());
	});
	$$parent.append($$panel);
}

function _createMarkupPrototype($$parent, prop, sel, data) {
	var value = data.control && data.control.prototype && data.control.prototype.json;
	if (value) {
		value = JSON.stringify(value, null, " ");
	} else {
		value = locale.text("auth.PROTOTYPE_NONE");
	}
	var html = authHtml.execute("authPanelPropertyPROTOTYPE", {
		id: "auth_opt_" + prop.name,
		value: value
	});
	var $$panel = $(html);
	$$parent.append($$panel);
}

function _notifyChangePropUI($$parent, sel, data) {
	var $$json = $("textarea#auth_opt_JSON");
	$$json.val(authVal.toSortedJSON(data.articleSelection));
	notifications.publish(["sm.auth.change.item.prop.ui"], data);
}

exports.properties = _properties;