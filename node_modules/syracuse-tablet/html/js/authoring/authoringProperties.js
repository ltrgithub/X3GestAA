"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var authVal = require('syracuse-tablet/html/js/authoring/authoringVal');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var authoringPropertiesGauge = require('syracuse-tablet/html/js/authoring/authoringPropertiesGauge');
var authoringPropertiesGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');

var _err = authoringPropertiesGeneral.err;


var _properties = {
	/*
	 * Titel hidden
	 */
	"isTitleHidden": {
		"key": "$isTitleHidden",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: authoringPropertiesGeneral.createMarkupRadio,
		type: "default" // Default, just for header color selection
	},

	/* 
	 * Position of label
	 * left:   <label> <value>
	 *
	 * top:    <label>
	 * 		   <value>
	 */
	"labelPosition": {
		"key": "$labelPosition",
		"default": "left",
		"values": [{
			"value": "left"
		}, {
			"value": "top"
		}],
		createMarkup: authoringPropertiesGeneral.createMarkupRadio
	},

	/* 
	 * Text alignment of label
	 * left:   |<label>      |
	 * right:  |      <value>|
	 */
	"labelAlign": {
		"key": "$labelAlign",
		"default": "left",
		"values": [{
			"value": "left"
		}, {
			"value": "center",
			"isHidden": true
		}, {
			"value": "right"
		}],
		createMarkup: authoringPropertiesGeneral.createMarkupRadio,
		refreshMarkup: authoringPropertiesGeneral.refreshMarkupRadio
	},

	/* 
	 * Theme for control
	 */
	"theme": {
		"key": "$theme",
		"default": "a",
		"values": [{
			"value": "a"
		}, {
			"value": "b"
		}, {
			"value": "c"
		}],
		createMarkup: authoringPropertiesGeneral.createMarkupRadio
	},

	/*
	 * Reference field description position
	 * bottom: <value>
	 *         <desc>
	 *
	 * right:  <value> <desc>
	 * left:   <desc> <value>
	 *
	 * top:    <desc>
	 *         <value>
	 */
	"refDescPosition": {
		"key": "$refDescPosition",
		"default": "right",
		"values": [{
			"value": "bottom"
		}, {
			"value": "right"
		}, {
			"value": "left"
		}, {
			"value": "top"
		}, {
			"value": "none"
		}],
		createMarkup: authoringPropertiesGeneral.createMarkupRadio
	},

	/*
	 * Reference field description format
	 * desc:      <desc>
	 *         
	 * title:     <title>

	 * desctitle: <desc> - <title>
	 * -> If both values are equal, skip display of second value
	 * 
	 * titledesc: <title> - <desc>
	 * -> If both values are equal, skip display of second value
	 */
	"refDescFormat": {
		"key": "$refDescFormat",
		"default": "desc",
		"values": [{
			"value": "desc"
		}, {
			"value": "title"
		}, {
			"value": "desctitle"
		}, {
			"value": "titledesc"
		}],
		createMarkup: authoringPropertiesGeneral.createMarkupRadio
	},
	/*
	 * Color of tile and layout cell
	 */
	"tileColor": {
		"key": "$bgColor",
		"default": "lime",
		"values": [{
			"value": "transparent"
		}, {
			"value": "teal"
		}, {
			"value": "green"
		}, {
			"value": "brown"
		}, {
			"value": "lime"
		}, {
			"value": "red"
			/*		}, { disabled for now, does not fit nicely into the palette
			"value": "purple" */
		}, {
			"value": "pink"
		}, {
			"value": "magenta"
		}, {
			"value": "orange"
		}, {
			"value": "blue"
		}],
		createMarkup: _createMarkupRadioBgColor
	},

	/*
	 * Size of tile
	 */
	"tileSize": {
		"key": "$size",
		"default": "medium",
		"values": [{
			"value": "small"
		}, {
			"value": "medium"
		}, {
			"value": "wide"
		}, {
			"value": "large"
		}, {
			"value": "full"
		}, {
			"value": "all"
		}],
		createMarkup: authoringPropertiesGeneral.createMarkupRadio
	},

	/*
	 * Title of layout node
	 */
	"layoutTitle": {
		"key": "$title",
		"default": "",
		createMarkup: _createMarkupInput
	},

	/*
	 * Title of layout node
	 */
	"layoutCollapsible": {
		"key": "$collapsible",
		"default": "notcollapsible",
		"values": [{
			"value": "notcollapsible"
		}, {
			"value": "expanded"
		}, {
			"value": "collapsed"
		}],
		createMarkup: authoringPropertiesGeneral.createMarkupRadio
	},

	/*
	 * Title of a tile
	 */
	"tileTitle": {
		"key": "$title",
		"default": "",
		createMarkup: _createMarkupInput
	},

	/*
	 * Height of layout stack
	 */
	"rowHeight": {
		"key": "$rowHeight",
		"default": "200px",
		createMarkup: _createMarkupInput
	},

	/*
	 * Size of tile
	 *
	 * Handles the following elements: $widthXs, $widthSm, $widthMd, $widthLg
	 */
	"cellSize": {
		"default": 4,
		createMarkup: _createMarkupCellSize
	},

	"arrayDisplay": {
		"key": "$display",
		"default": "table",
		values: [{
			value: "table"
		}, {
			value: "card"
		}],
		createMarkup: authoringPropertiesGeneral.createMarkupRadio
	},

	// only card
	"arrayCardsPerRow": {
		"key": "$cardsPerRow",
		"default": "2",
		values: [{
			value: "1"
		}, {
			value: "2"
		}, {
			value: "3"
		}, {
			value: "4"
		}],
		createMarkup: authoringPropertiesGeneral.createMarkupRadio,
		refreshMarkup: authoringPropertiesGeneral.refreshMarkupRadio
	},

	// only card
	"arrayCardsMinWidth": {
		"key": "$minWidth",
		"default": 1,
		"min": 0,
		"max": 20,
		"step": 1,
		createMarkup: _createMarkupCardsMinWidthSlider,
		destroyMarkup: _destroyMarkupCardsMinWidthSlider,
		refreshMarkup: _refreshMarkupSlider
	},

	// only card
	"arrayCardsEmptyCells": {
		"key": "$emptycell",
		"default": "nodisplay",
		values: [{
			value: "filled"
		}, {
			value: "withtitle"
		}, {
			value: "nodisplay"
		}],
		createMarkup: authoringPropertiesGeneral.createMarkupRadio,
		refreshMarkup: authoringPropertiesGeneral.refreshMarkupRadio
	},

	// only query array
	"arrayQueryFilters": {
		"key": "$filters",
		"default": "list",
		values: [{
			value: "list"
		}, {
			value: "tabs"
		}, {
			value: "none"
		}],
		createMarkup: authoringPropertiesGeneral.createMarkupRadio,
		refreshMarkup: authoringPropertiesGeneral.refreshMarkupRadio
	},

	// only query array - link to details values are created dynamically
	"arrayDetailsLink": {
		"key": "$detailsLink",
		"default": "$details",
		values: [],
		createMarkup: authoringPropertiesGeneral.createMarkupRadio,
		refreshMarkup: authoringPropertiesGeneral.refreshMarkupRadio
	},

	// only CLOB field (text plain, text html, text rtf)
	"textHeight": {
		"key": "$textHeight",
		"default": "medium",
		values: [{
			value: "small"
		}, {
			value: "medium"
		}, {
			value: "large"
		}, {
			value: "xlarge"
		}],
		createMarkup: authoringPropertiesGeneral.createMarkupRadio,
		refreshMarkup: authoringPropertiesGeneral.refreshMarkupRadio
	},

	/*
	 * Dummy to add a separator
	 */
	"SEPARATOR": {},

	/*
	 * Full JSON article of selection for experts
	 */
	"JSON": {
		"key": "$JSON",
		createMarkup: _createMarkupJSON,
		type: "expert"
	},
	/*
	 * Read only display of prototype
	 */
	"PROTOTYPE": {
		"key": "$PROTOYPE",
		createMarkup: _createMarkupPrototype,
		type: "expert"
	},

};


var _initProperties;
exports.initProperties = function(helpers) {
	/* 
	 * TODO: Handle language change
	 */
	if (_initProperties) {
		return;
	}

	var pre = "auth";
	Object.keys(_properties).forEach(function(prop) {
		var lk = pre + "." + prop;
		var p = _properties[prop];
		if (p.label == null) {
			p.label = locale.text(lk);
		}
		p.name = prop;
		if (p.values) {
			p.values.forEach(function(v, idx) {
				if ($.isPlainObject(v)) {
					var vk = lk + "." + ("" + v.value);
					if (v.label == null) {
						v.label = locale.text(vk);
					}
				} else {
					p.values[idx] = {
						label: v + "",
						valu: v
					};
				}
			});
		}
	});
	_initProperties = true;
};

exports.getAllProperties = function() {
	return _properties;
};

/*
 * Which layout node supports which properties to edit in authoring
 */
var _layoutProps = {
	"stack": [_properties.layoutTitle, _properties.layoutCollapsible],
	"row": [_properties.rowHeight],
	"hub-group": [_properties.layoutTitle],
	"tile": [_properties.tileTitle, _properties.tileColor, _properties.tileSize],
	"cell": [_properties.tileColor, _properties.cellSize]
};

exports.getProperties = function(sel, data) {

	var $$elmt = sel.$$elmt;
	var props = [];

	var controller = utils.findController($$elmt);
	/*
	 * Layout nodes have simple static properties
	 */
	if ($$elmt.hasClass("s-m-layout")) {
		Object.keys(_layoutProps).some(function(key) {
			var cls = "s-m-" + key;
			if ($$elmt.hasClass(cls)) {
				_layoutProps[key].forEach(function(p) {
					props.push(p);
				});
				return true;
			}
			return false;
		});
	} else if ($$elmt.hasClass("s-m-field")) {
		// Properties for all types of fields
		var labelAlign = _getLabelAlign(sel, data);
		var props = [_properties.isTitleHidden, _properties.labelPosition, labelAlign, _properties.theme];

		// Properties for reference fields only 
		if (data.type === "reference") {
			props.push(_properties.refDescFormat);
			props.push(_properties.refDescPosition);
		}

		// Properties for enriched text fields only (html, plain, rtf)
		if (data.type === "rtf" || data.type === "html" || data.type === "plain") {
			props.push(_properties.textHeight);
		}

		// Properties for numeric field
		authoringPropertiesGauge.setNumDisplayConfig(data, props);

	} else if ($$elmt.hasClass("s-m-array")) {
		var labelAlign = _getLabelAlign(sel, data);
		var cardsPerRow = _getArrayCardsPerRow(sel, data);
		var cardsMinWidth = _getArrayCardsMinWidth(sel, data);
		var displayEmptyCells = _getArrayCardsEmptyCells(sel, data);
		var queryFiltersOpts = null;
		if (_supportsFilterAuthoring(controller)) {
			queryFiltersOpts = _getArrayQueryFilters(sel, data);
		}
		var detailsLinkOpts = null;
		if (controller && controller.prototype.isQuery()) {
			detailsLinkOpts = _getQueryDetailsLinkOptions(controller, sel, data);
		}
		var props = [_properties.isTitleHidden, _properties.labelPosition, labelAlign, _properties.theme, _properties.arrayDisplay, cardsPerRow, displayEmptyCells, cardsMinWidth];
		if (queryFiltersOpts) {
			props.push(queryFiltersOpts);
		}
		if (detailsLinkOpts) {
			props.push(detailsLinkOpts);
		}
	}

	// Always add JSON editting and proto display
	props.push(_properties.SEPARATOR);
	if ($$elmt.hasClass("s-m-page")) {
		props.push(_properties.JSON);
	}
	props.push(_properties.PROTOTYPE);
	return props;
};



function _supportsFilterAuthoring(controller) {
	if (controller && (controller.prototype.isLookup() || controller.prototype.isQuery())) {
		return controller._$filters && controller._$filters.length > 0;
		// Also on  a smartphone combobox will never be allowed, we do not disable authoring since in preview, we might set smartphone
		// and a user should see rendering is done as tabs
		// && globals.getSiteLayout().getDeviceType() !== "smartphone";		
	}
	return false;
}

function _isQuery(controller) {
	if (controller && (controller.prototype.isLookup() || controller.prototype.isQuery())) {
		return controller._$filters && controller._$filters.length > 0;
		// Also on  a smartphone combobox will never be allowed, we do not disable authoring since in preview, we might set smartphone
		// and a user should see rendering is done as tabs
		// && globals.getSiteLayout().getDeviceType() !== "smartphone";		
	}
	return false;
}
// Centered label is only possible on top or bottom positioned label
function _getLabelAlign(sel, data) {
	var valPos = _getValueOrDefault(_properties.labelPosition, sel, data);

	var props = $.extend(true, {}, _properties.labelAlign);
	props.values.forEach(function(val) {
		if (valPos === "left" && val.value === "center") {
			val.isHidden = true;
		} else {
			val.isHidden = false;
		}
	});
	return props;
}

//Only for card
function _getArrayCardsPerRow(sel, data) {
	var valPos = _getValueOrDefault(_properties.arrayDisplay, sel, data);
	if (valPos !== "card") {
		return _propertyValuesHideAll(_properties.arrayCardsPerRow, true);
	} else {
		return _propertyValuesHideAll(_properties.arrayCardsPerRow, false);
	}
}

//Only for card
function _getArrayCardsEmptyCells(sel, data) {
	var valPos = _getValueOrDefault(_properties.arrayDisplay, sel, data);
	if (valPos === "table") {
		return _propertyValuesHideAll(_properties.arrayCardsEmptyCells, true);
	} else {
		return _propertyValuesHideAll(_properties.arrayCardsEmptyCells, false);
	}
}

//Only for card
function _getArrayCardsMinWidth(sel, data) {
	var valPos = _getValueOrDefault(_properties.arrayCardsMinWidth, sel, data);
	if (valPos === "table") {
		return _propertyValuesHideAll(_properties.arrayCardsMinWidth, true);
	} else {
		return _propertyValuesHideAll(_properties.arrayCardsMinWidth, false);
	}
}

//Only for array in queries
function _getArrayQueryFilters(sel, data) {
	return _propertyValuesHideAll(_properties.arrayQueryFilters, false);
}
//Only for array in queries
function _getQueryDetailsLinkOptions(controller, sel, data) {
	if (!controller.getControl(sel.id)) return null;
	var links = controller.getControl(sel.id).prototype.getDataByPath("$item.$links");
	if (!links || links.length === 0) return null;
	var props = $.extend(true, {}, _properties.arrayDetailsLink);
	if (!props.values) {
		props.values = [];
	}
	if (controller.isVignette) {
		// Add the capability to open query full page - Default option
		props.default = "$queryfullpage";
		props.values.push({
			value: "$queryfullpage",
			label: locale.text("auth.arrayDetailsLink.queryfullpage")
		});
	}
	// Add $links
	$.each(links, function(key, link) {
		props.values.push({
			value: key,
			label: link.$title ? controller.prototype.resolveExpression(link.$title) + " - " + key : key
		});
	});
	if (props.length === 1 && props[0].value === "$details") return null;
	return _propertyValuesHideAll(props);
}

/*
 * Enable or disable all possible values of a authoring property
 */
function _propertyValuesHideAll(property, hide) {
	var props = $.extend(true, {}, property);
	if (!props.values) return props;
	props.values.forEach(function(val) {
		val.isHidden = hide;
	});
	return props;
}

function _getValueOrDefault(prop, sel, data) {
	return authoringPropertiesGeneral.getValueOrDefault(prop, sel, data);
}

function _setValue(prop, sel, data, value) {
	authoringPropertiesGeneral.setValue(prop, sel, data, value);
}


function _createMarkupRadioBgColor($$parent, prop, sel, data) {

	var ctx = {
		group: "auth_opt_" + prop.name,
		options: []
	};

	var value = _getValueOrDefault(prop, sel, data);

	prop.values.forEach(function(v) {
		ctx.options.push({
			id: ctx.group + "_" + v.value,
			value: "" + v.value,
			label: v.label,
			color: v.value
		});
	});

	var html = authHtml.execute("authPanelPropertyRadioColor", ctx);
	var $$panel = $(html);
	$("label[data-s-m-auth-value='" + ("" + value) + "']", $$panel).eq(0).button("toggle");
	$("label", $$panel).on("click", function(e) {
		var $$ct = $(e.currentTarget);
		var value = $$ct.attr("data-s-m-auth-value");
		$$ct.eq(0).button("toggle");

		/*
		 * Important! Use boolean datatype for boolean properties!
		 */
		if (value === "true") {
			value = true;
		} else if (value === "false") {
			value = false;
		}
		_setValue(prop, sel, data, value);
		_notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);
}


function _createMarkupInput($$parent, prop, sel, data) {
	var value = _getValueOrDefault(prop, sel, data);
	var html = authHtml.execute("authPanelPropertyInput", {
		id: "auth_opt_" + prop.name,
		value: value
	});
	var $$panel = $(html);
	$("input", $$panel).blur(function() {
		var value = $(this).val();
		_setValue(prop, sel, data, value);
		_notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);
}

function _createMarkupCardsMinWidthSlider($$parent, prop, sel, data) {
	var ctrl = utils.findController(sel.$$elmt).getControl(sel.$$elmt.attr('id'));
	var value = _getValueOrDefault(prop, sel, data);
	var $$panel = $(authHtml.execute("authPanelCardMinSizeSliderControl", {
		id: "auth_opt_" + prop.name,
		value: value,
		min: prop.min,
		max: prop.max,
		step: prop.step || 1,
		valText: prop.val2Text ? prop.val2Text(value) : value
	}));
	$$parent.append($$panel);
	var $$text = $("header", $$panel);
	var slider = $("input", $$panel).slider({});
	slider.on("slide", jsutils.bindFn(ctrl.authOnSlideMinSize, ctrl, "slide"));
	slider.on("slideStart", jsutils.bindFn(ctrl.authOnSlideMinSize, ctrl, "start"));
	slider.on("slideStop", jsutils.bindFn(_cardsMinWidthSliderSetVal, null, $$parent, ctrl, prop, sel, data, value));
	$$panel.find("button").on("click", function(evt) {
		eventListener.triggerAction(ctrl.$$elmt, "cardDesign", null, ctrl.id);
	});
}

function _cardsMinWidthSliderSetVal(slideEvt, $$parent, ctrl, prop, sel, data, originValue) {
	ctrl.authOnSlideMinSize(slideEvt, "stop");
	if (originValue != slideEvt.value) {
		_setValue(prop, sel, data, slideEvt.value);
		_notifyChangePropUI($$parent, sel, data);
	}
}

function _destroyMarkupCardsMinWidthSlider($$parent, prop) {
	var $$slider = $$parent.find('#auth_opt_' + prop.name);
	if ($$slider.length > 0 && $$slider.slider) {
		$$slider.slider('destroy');
	}
}

function _refreshMarkupSlider($$parent, prop, sel, data) {
	var allHidden = true;
}

function _createMarkupCellSize($$parent, prop, sel, data) {
	var values = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
	var sizes = [{
		"prop": "widthXs",
		"label": locale.text("auth.cellSize.$widthXs"),
		"class": "s-m-auth-highlight-xs"
	}, {
		"prop": "widthSm",
		"label": locale.text("auth.cellSize.$widthSm"),
		"class": "s-m-auth-highlight-sm"
	}, {
		"prop": "widthMd",
		"label": locale.text("auth.cellSize.$widthMd"),
		"class": "s-m-auth-highlight-md"
	}, {
		"prop": "widthLg",
		"label": locale.text("auth.cellSize.$widthLg"),
		"class": "s-m-auth-highlight-lg"
	}];

	var html = authHtml.execute("authPanelPropertyCellSize", {
		id: "auth_opt_" + prop.name,
		sizes: sizes,
		values: values
	});
	var $$panel = $(html);
	var last = "12";
	sizes.forEach(function(size) {
		var value = data.articleSelection && data.articleSelection["$" + size.prop];
		value = value || last;
		last = value;
		$("label[data-s-m-auth-prop='" + size.prop + "'][data-s-m-auth-value='" + value + "']", $$panel).button("toggle");
	});

	$("label", $$panel).on("click", function(e) {
		var $$ct = $(e.currentTarget);
		$$ct.eq(0).button("toggle");
		sizes.forEach(function(size) {
			$$ct = $$panel.find("label.active[data-s-m-auth-prop='" + size.prop + "']");
			if ($$ct.length > 0) {
				var value = $$ct.attr("data-s-m-auth-value");
				data.articleSelection["$" + size.prop] = value;
			}
		});
		_notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);
}

function _createMarkupJSON($$parent, prop, sel, data) {
	// This is only displayed if the full page is selected, so we always show the article of the page and not the article
	// of the selected UI compontent (UI component is always the page)
	var value = authVal.toSortedJSON(data.articlePage);
	var html = authHtml.execute("authPanelPropertyJSON", {
		id: "auth_opt_" + prop.name,
		value: value,
		label_apply: locale.text("auth.panel.label_apply")
	});
	var $$panel = $(html);
	var apply = function(value) {
		// Full page article exchange
		var articleParsed = authVal.validateJSON(true, value, _properties);
		if (articleParsed) {
			var articlePage = authVal.toSortedJSON(articleParsed);
			notifications.publish(["sm.auth.change.prop.ui"], articlePage);
		}
	};
	$("button", $$panel).click(function() {
		apply($("textarea", $$panel).val());
	});
	$$parent.append($$panel);
}

function _createMarkupPrototype($$parent, prop, sel, data) {
	var value = data.control && data.control.prototype && data.control.prototype.json;
	if (value) {
		value = JSON.stringify(value, null, " ");
	} else {
		value = locale.text("auth.PROTOTYPE_NONE");
	}
	var html = authHtml.execute("authPanelPropertyPROTOTYPE", {
		id: "auth_opt_" + prop.name,
		value: value
	});
	var $$panel = $(html);
	$$parent.append($$panel);
}

function _notifyChangePropUI($$parent, sel, data) {
	authoringPropertiesGeneral.notifyChangePropUI($$parent, sel, data);
}

exports.properties = _properties;