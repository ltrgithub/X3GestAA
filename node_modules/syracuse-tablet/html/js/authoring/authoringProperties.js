"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var authVal = require('syracuse-tablet/html/js/authoring/authoringVal');
var globals = require('syracuse-tablet/html/js/helpers/globals');

var _properties = {
	/*
	 * Titel hidden
	 */
	"isTitleHidden": {
		"key": "$isTitleHidden",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: _createMarkupRadio,
		type: "default" // Default, just for header color selection
	},

	/* 
	 * Position of label
	 * left:   <label> <value>
	 *
	 * top:    <label>
	 * 		   <value>
	 */
	"labelPosition": {
		"key": "$labelPosition",
		"default": "left",
		"values": [{
			"value": "left"
		}, {
			"value": "top"
		}],
		createMarkup: _createMarkupRadio
	},

	/* 
	 * Text alignment of label
	 * left:   |<label>      |
	 * right:  |      <value>|
	 */
	"labelAlign": {
		"key": "$labelAlign",
		"default": "left",
		"values": [{
			"value": "left"
		}, {
			"value": "center",
			"isHidden": true
		}, {
			"value": "right"
		}],
		createMarkup: _createMarkupRadio,
		refreshMarkup: _refreshMarkupRadio
	},

	/* 
	 * Theme for control
	 */
	"theme": {
		"key": "$theme",
		"default": "a",
		"values": [{
			"value": "a"
		}, {
			"value": "b"
		}, {
			"value": "c"
		}],
		createMarkup: _createMarkupRadio
	},

	/*
	 * Reference field description position
	 * bottom: <value>
	 *         <desc>
	 *
	 * right:  <value> <desc>
	 * left:   <desc> <value>
	 *
	 * top:    <desc>
	 *         <value>
	 */
	"refDescPosition": {
		"key": "$refDescPosition",
		"default": "right",
		"values": [{
			"value": "bottom"
		}, {
			"value": "right"
		}, {
			"value": "left"
		}, {
			"value": "top"
		}, {
			"value": "none"
		}],
		createMarkup: _createMarkupRadio
	},

	/*
	 * Reference field description format
	 * desc:      <desc>
	 *         
	 * title:     <title>

	 * desctitle: <desc> - <title>
	 * -> If both values are equal, skip display of second value
	 * 
	 * titledesc: <title> - <desc>
	 * -> If both values are equal, skip display of second value
	 */
	"refDescFormat": {
		"key": "$refDescFormat",
		"default": "desc",
		"values": [{
			"value": "desc"
		}, {
			"value": "title"
		}, {
			"value": "desctitle"
		}, {
			"value": "titledesc"
		}],
		createMarkup: _createMarkupRadio
	},
	/*
	 * Color of tile and layout cell
	 */
	"tileColor": {
		"key": "$bgColor",
		"default": "lime",
		"values": [{
			"value": "transparent"
		}, {
			"value": "purple"
		}, {
			"value": "magenta"
		}, {
			"value": "teal"
		}, {
			"value": "brown"
		}, {
			"value": "lime"
		}, {
			"value": "pink"
		}, {
			"value": "orange"
		}, {
			"value": "blue"
		}, {
			"value": "red"
		}, {
			"value": "green"
		}],
		createMarkup: _createMarkupRadioBgColor
	},

	/*
	 * Size of tile
	 */
	"tileSize": {
		"key": "$size",
		"default": "medium",
		"values": [{
			"value": "small"
		}, {
			"value": "medium"
		}, {
			"value": "wide"
		}, {
			"value": "large"
		}, {
			"value": "full"
		}, {
			"value": "all"
		}],
		createMarkup: _createMarkupRadio
	},

	/*
	 * Tilel of layout node
	 */
	"layoutTitle": {
		"key": "$title",
		"default": "",
		createMarkup: _createMarkupInput
	},

	/*
	 * Height of layout stack
	 */
	"rowHeight": {
		"key": "$rowHeight",
		"default": "200px",
		createMarkup: _createMarkupInput
	},

	/*
	 * Size of tile
	 *
	 * Handles the following elements: $widthXs, $widthSm, $widthMd, $widthLg
	 */
	"cellSize": {
		"default": 4,
		createMarkup: _createMarkupCellSize
	},

	"arrayDisplay": {
		"key": "$display",
		"default": "table",
		values: [{
			value: "table"
		}, {
			value: "cardV"
		}, {
			value: "cardH"
		}],
		createMarkup: _createMarkupRadio
	},

	// only cardV	
	"arrayCardsPerRow": {
		"key": "$cardsPerRow",
		"default": "1",
		values: [{
			value: "1"
		}, {
			value: "2"
		}, {
			value: "3"
		}],
		createMarkup: _createMarkupRadio,
		refreshMarkup: _refreshMarkupRadio
	},

	// only cardH
	"arrayCellSizes": {
		"key": "$cellSizes",
		"default": "medium",
		"values": [{
			"value": "small"
		}, {
			"value": "medium"
		}, {
			"value": "wide"
		}, {
			"value": "large"
		}],
		createMarkup: _createMarkupRadio,
		refreshMarkup: _refreshMarkupRadio
	},

	// only cardH
	"arrayEmptyCells": {
		"key": "$emptycell",
		"default": "nodisplay",
		values: [{
			value: "filled"
		}, {
			value: "withtitle"
		}, {
			value: "nodisplay"
		}],
		createMarkup: _createMarkupRadio,
		refreshMarkup: _refreshMarkupRadio
	},

	// only query array
	"arrayQueryFilters": {
		"key": "$filters",
		"default": "list",
		values: [{
			value: "list"
		}, {
			value: "tabs"
		}, {
			value: "none"
		}],
		createMarkup: _createMarkupRadio,
		refreshMarkup: _refreshMarkupRadio
	},

	/*
	 * Dummy to add a separator
	 */
	"SEPARATOR": {},

	/*
	 * Used to allow creation of a new layout for the whole page
	 */
	"pageLAYOUTType": {
		"key": "$pageLAYOUTType",
		createMarkup: _createMarkupGenLayout,
	},

	/*
	 * Full JSON article of selection for experts
	 */
	"JSON": {
		"key": "$JSON",
		createMarkup: _createMarkupJSON,
		type: "expert"
	},
	/*
	 * Read only display of prototype
	 */
	"PROTOTYPE": {
		"key": "$PROTOYPE",
		createMarkup: _createMarkupPrototype,
		type: "expert"
	},

};

var _initProperties;
exports.initProperties = function(helpers) {
	/* 
	 * TODO: Handle language change
	 */
	if (_initProperties) {
		return;
	}

	var pre = "auth";
	Object.keys(_properties).forEach(function(prop) {
		var lk = pre + "." + prop;
		var p = _properties[prop];
		p.label = locale.text(lk);
		p.name = prop;
		if (p.values) {
			p.values.forEach(function(v) {
				var vk = lk + "." + ("" + v.value);
				v.label = locale.text(vk);
			});
		}
	});
	_initProperties = true;
};

exports.getAllProperties = function() {
	return _properties;
};

/*
 * Which layout node supports which properties to edit in authoring
 */
var _layoutProps = {
	"stack": [],
	"row": [_properties.rowHeight],
	"hub-group": [_properties.layoutTitle],
	"tile": [_properties.tileColor, _properties.tileSize],
	"cell": [_properties.tileColor, _properties.cellSize]
};

exports.getProperties = function(sel, data) {

	var $$elmt = sel.$$elmt;
	var props = [];

	var controller = utils.findController($$elmt);
	/*
	 * Layout nodes have simple static properties
	 */
	if ($$elmt.hasClass("s-m-layout")) {
		Object.keys(_layoutProps).some(function(key) {
			var cls = "s-m-" + key;
			if ($$elmt.hasClass(cls)) {
				_layoutProps[key].forEach(function(p) {
					props.push(p);
				});
				return true;
			}
			return false;
		});
	} else if ($$elmt.hasClass("s-m-field")) {
		// Properties for all types of fields
		var labelAlign = _getLabelAlign(sel, data);
		var props = [_properties.isTitleHidden, _properties.labelPosition, labelAlign, _properties.theme];

		// Properties for reference fields only 
		if (data.type === "reference") {
			props.push(_properties.refDescFormat);
			props.push(_properties.refDescPosition);
		}
	} else if ($$elmt.hasClass("s-m-array")) {
		var labelAlign = _getLabelAlign(sel, data);
		var cardsPerRow = _getArrayCardsPerRow(sel, data);
		var cellSizes = _getArrayCellSizes(sel, data);
		var displayEmptyCells = _getArrayEmptyCells(sel, data);
		var queryFiltersOpts = null;

		if (_supportsFilterAuthoring(controller)) {
			queryFiltersOpts = _getArrayQueryFilters(sel, data);
		}
		var props = [_properties.isTitleHidden, _properties.labelPosition, labelAlign, _properties.theme, _properties.arrayDisplay, cardsPerRow, cellSizes, displayEmptyCells];
		if (queryFiltersOpts) {
			props.push(queryFiltersOpts);
		}
	}

	// Only for page to add function to create default layout
	if ($$elmt.hasClass("s-m-page")) {
		props.push(_properties.pageLAYOUTType);
	}

	// Always add JSON editting and proto display
	props.push(_properties.SEPARATOR);
	props.push(_properties.JSON);
	props.push(_properties.PROTOTYPE);
	return props;
};

function _supportsFilterAuthoring(controller) {
	if (controller && (controller.prototype.isLookup() || controller.prototype.isQuery())) {
		return controller._$filters && controller._$filters.length > 0;
		// Also on  a smartphone combobox will never be allowed, we do not disable authoring since in preview, we might set smartphone
		// and a user should see rendering is done as tabs
		// && globals.getSiteLayout().getDeviceType() !== "smartphone";		
	}
	return false;
}

// Centered label is only possible on top or bottom positioned label
function _getLabelAlign(sel, data) {
	var valPos = _getValueOrDefault(_properties.labelPosition, sel, data);

	var props = $.extend(true, {}, _properties.labelAlign);
	props.values.forEach(function(val) {
		if (valPos === "left" && val.value === "center") {
			val.isHidden = true;
		} else {
			val.isHidden = false;
		}
	});
	return props;
}

//Only for cardV
function _getArrayCardsPerRow(sel, data) {
	var valPos = _getValueOrDefault(_properties.arrayDisplay, sel, data);
	if (valPos !== "cardV") {
		return _propertyValuesHideAll(_properties.arrayCardsPerRow, true);
	} else {
		return _propertyValuesHideAll(_properties.arrayCardsPerRow, false);
	}
}

//Only for cardH
function _getArrayCellSizes(sel, data) {
	var valPos = _getValueOrDefault(_properties.arrayDisplay, sel, data);
	if (valPos !== "cardH") {
		return _propertyValuesHideAll(_properties.arrayCellSizes, true);
	} else {
		return _propertyValuesHideAll(_properties.arrayCellSizes, false);
	}
}

//Only for card<xxx>
function _getArrayEmptyCells(sel, data) {
	var valPos = _getValueOrDefault(_properties.arrayDisplay, sel, data);
	if (valPos === "table") {
		return _propertyValuesHideAll(_properties.arrayEmptyCells, true);
	} else {
		return _propertyValuesHideAll(_properties.arrayEmptyCells, false);
	}
}

//Only for array in queries
function _getArrayQueryFilters(sel, data) {
	return _propertyValuesHideAll(_properties.arrayQueryFilters, false);
}
/*
 * Enable or disable all possible values of a authoring property
 */
function _propertyValuesHideAll(property, hide) {
	var props = $.extend(true, {}, property);
	props.values.forEach(function(val) {
		val.isHidden = hide;
	});
	return props;
}

function _getValueOrDefault(prop, sel, data) {
	var value = data.articleSelection && data.articleSelection[prop.key];
	value = (value != null) ? value : prop["default"];
	return value;
}

function _setValue(prop, sel, data, value) {
	data.articleSelection[prop.key] = value;
}

function _createMarkupRadio($$parent, prop, sel, data) {

	var ctx = {
		group: "auth_opt_" + prop.name,
		options: []
	};

	var value = _getValueOrDefault(prop, sel, data);
	var allHidden = true;

	prop.values.forEach(function(v) {
		ctx.options.push({
			id: ctx.group + "_" + v.value,
			value: "" + v.value,
			label: v.label,
			display: (v.isHidden ? "none" : "block")
		});
		allHidden = allHidden && v.isHidden;
	});

	var html = authHtml.execute("authPanelPropertyRadio", ctx);
	var $$panel = $(html);
	$("label[data-s-m-auth-value='" + ("" + value) + "']", $$panel).eq(0).button("toggle");
	$("label", $$panel).on("click", function(e) {
		var $$ct = $(e.currentTarget);
		var value = $$ct.attr("data-s-m-auth-value");
		$$ct.eq(0).button("toggle");

		/*
		 * Important! Use boolean datatype for boolean properties!
		 */
		if (value === "true") {
			value = true;
		} else if (value === "false") {
			value = false;
		}
		_setValue(prop, sel, data, value);
		_notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);

	if (allHidden) {
		$$parent.parent(".s-m-panel-auth-prop").hide();
	} else {
		$$parent.parent(".s-m-panel-auth-prop").show();
	}
}

function _refreshMarkupRadio($$parent, prop, sel, data) {
	var allHidden = true;
	prop.values.forEach(function(v) {
		var id = "auth_opt_" + prop.name + "_" + v.value;
		var $$btn = $("#" + id, $$parent);
		var display = v.isHidden ? "none" : "block";
		$$btn.css("display", display);
		allHidden = allHidden && v.isHidden;
	});
	if (allHidden) {
		$$parent.parent(".s-m-panel-auth-prop").hide();
	} else {
		$$parent.parent(".s-m-panel-auth-prop").show();
	}
}

function _createMarkupRadioBgColor($$parent, prop, sel, data) {

	var ctx = {
		group: "auth_opt_" + prop.name,
		options: []
	};

	var value = _getValueOrDefault(prop, sel, data);

	prop.values.forEach(function(v) {
		ctx.options.push({
			id: ctx.group + "_" + v.value,
			value: "" + v.value,
			label: v.label,
			color: v.value
		});
	});

	var html = authHtml.execute("authPanelPropertyRadioColor", ctx);
	var $$panel = $(html);
	$("label[data-s-m-auth-value='" + ("" + value) + "']", $$panel).eq(0).button("toggle");
	$("label", $$panel).on("click", function(e) {
		var $$ct = $(e.currentTarget);
		var value = $$ct.attr("data-s-m-auth-value");
		$$ct.eq(0).button("toggle");

		/*
		 * Important! Use boolean datatype for boolean properties!
		 */
		if (value === "true") {
			value = true;
		} else if (value === "false") {
			value = false;
		}
		_setValue(prop, sel, data, value);
		_notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);
}


function _createMarkupInput($$parent, prop, sel, data) {
	var value = _getValueOrDefault(prop, sel, data);
	var html = authHtml.execute("authPanelPropertyInput", {
		id: "auth_opt_" + prop.name,
		value: value
	});
	var $$panel = $(html);
	$("input", $$panel).blur(function() {
		var value = $(this).val();
		_setValue(prop, sel, data, value);
		_notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);
}

function _createMarkupCellSize($$parent, prop, sel, data) {
	var values = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
	var sizes = [{
		"prop": "widthXs",
		"label": locale.text("auth.cellSize.$widthXs"),
		"class": "s-m-auth-highlight-xs"
	}, {
		"prop": "widthSm",
		"label": locale.text("auth.cellSize.$widthSm"),
		"class": "s-m-auth-highlight-sm"
	}, {
		"prop": "widthMd",
		"label": locale.text("auth.cellSize.$widthMd"),
		"class": "s-m-auth-highlight-md"
	}, {
		"prop": "widthLg",
		"label": locale.text("auth.cellSize.$widthLg"),
		"class": "s-m-auth-highlight-lg"
	}];

	var html = authHtml.execute("authPanelPropertyCellSize", {
		id: "auth_opt_" + prop.name,
		sizes: sizes,
		values: values
	});
	var $$panel = $(html);
	var last = "12";
	sizes.forEach(function(size) {
		var value = data.articleSelection && data.articleSelection["$" + size.prop];
		value = value || last;
		last = value;
		$("label[data-s-m-auth-prop='" + size.prop + "'][data-s-m-auth-value='" + value + "']", $$panel).button("toggle");
	});

	$("label", $$panel).on("click", function(e) {
		var $$ct = $(e.currentTarget);
		$$ct.eq(0).button("toggle");
		sizes.forEach(function(size) {
			$$ct = $$panel.find("label.active[data-s-m-auth-prop='" + size.prop + "']");
			if ($$ct.length > 0) {
				var value = $$ct.attr("data-s-m-auth-value");
				data.articleSelection["$" + size.prop] = value;
			}
		});
		_notifyChangePropUI($$parent, sel, data);
	});
	$$parent.append($$panel);
}

function _createMarkupGenLayout($$parent, prop, sel, data) {
	var html = authHtml.execute("authPanelPropertyGenLayout", {
		id: "auth_opt_" + prop.name,
		label_horizontal: locale.text("auth.panel.label_horizontal"),
		label_vertical: locale.text("auth.panel.label_vertical")
	});
	var $$panel = $(html);
	$("label", $$panel).click(function() {
		if ($(this).attr("id") === "s-m-auth-new-layout-horizontal") {
			notifications.publish(["sm.auth.new.layout"], "horizontal");
		} else {
			notifications.publish(["sm.auth.new.layout"], "vertical");
		}
	});
	$$parent.append($$panel);
}

function _createMarkupJSON($$parent, prop, sel, data) {
	var value = authVal.toSortedJSON(data.articleSelection);
	var html = authHtml.execute("authPanelPropertyJSON", {
		id: "auth_opt_" + prop.name,
		value: value,
		label_apply: locale.text("auth.panel.label_apply")
	});
	var $$panel = $(html);
	var apply = function(value) {
		if (data.type !== "page") {
			// Single field/node edit
			var obj = authVal.validateJSON(false, value, _properties);
			if (obj) {
				authVal.injectJSON(data, obj);
				if (authVal.validateJSON(true, authVal.toSortedJSON(data.articlePage), _properties) != null) {
					_notifyChangePropUI($$parent, sel, data);
				}
			}
		} else {
			// Full page article exchange
			var articleParsed = authVal.validateJSON(true, value, _properties);
			if (articleParsed) {
				var articlePage = authVal.toSortedJSON(articleParsed);
				notifications.publish(["sm.auth.change.prop.ui"], articlePage);
			}
		}

	};
	$("button", $$panel).click(function() {
		apply($("textarea", $$panel).val());
	});
	$$parent.append($$panel);
}

function _createMarkupPrototype($$parent, prop, sel, data) {
	var value = data.control && data.control.prototype && data.control.prototype.json;
	if (value) {
		value = JSON.stringify(value, null, " ");
	} else {
		value = locale.text("auth.PROTOTYPE_NONE");
	}
	var html = authHtml.execute("authPanelPropertyPROTOTYPE", {
		id: "auth_opt_" + prop.name,
		value: value
	});
	var $$panel = $(html);
	$$parent.append($$panel);
}

function _notifyChangePropUI($$parent, sel, data) {
	var $$json = $("textarea#auth_opt_JSON");
	$$json.val(authVal.toSortedJSON(data.articleSelection));
	notifications.publish(["sm.auth.change.prop.ui"], authVal.toSortedJSON(data.articlePage));
}

exports.properties = _properties;