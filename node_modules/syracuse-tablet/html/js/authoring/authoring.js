"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/app/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var authoringPanelRight = require('syracuse-tablet/html/js/authoring/authoringPanelRight');
var authoringPanelLeft = require('syracuse-tablet/html/js/authoring/authoringPanelLeft');
var authoringPage = require('syracuse-tablet/html/js/authoring/authoringPage');
var authoringHeader = require('syracuse-tablet/html/js/authoring/authoringHeader');
var authoringFooter = require('syracuse-tablet/html/js/authoring/authoringFooter');
var authoringArticleGen = require('syracuse-tablet/html/js/authoring/authoringArticleGen');
var authVal = require('syracuse-tablet/html/js/authoring/authoringVal');
var authCommons = require('syracuse-tablet/html/js/authoring/authoringCommons');
var modules = require('syracuse-tablet/html/js/common/modules');

var modalSaveAuth = require('syracuse-tablet/html/js/ui/modals/modalSaveAuth');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var authProps = require('syracuse-tablet/html/js/authoring/authoringProperties');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _authInterface;

var _authEvents = ["sm.page.loaded",
	"sm.all.vignettes.loaded",
	"sm.auth.change.item.prop.ui",
	"sm.auth.change.prop.ui",
	"sm.auth.close",
	"sm.auth.save",
	"sm.auth.new.layout",
	"sm.auth.set.page",
	"sm.auth.display.changed",
	"sm.auth.undo",
	"sm.auth.open.card.design"
];
/*
 * This module glues together the action done in the page and the two panels
 */

exports.toggleDesignPage = function() {
	if (!_authInterface) {
		_authInterface = new AuthInterface();
	}

	_authInterface.toggleDesignPage();
};
exports.isEnabled = function() {
	return _authInterface && _authInterface.isActive;
};
/**
 * Returns true if back process can continue
 */
// Called on unload event - application.onUnload
exports.destroy = function() {
	if (!_authInterface) return;
	_authInterface.destroy();
	_authInterface = null;
};
var AuthInterface = utils.defineClass(function AuthoringInterface() {
	var self = this;
	self.$$authPanel = null;
	self.isActive = false;

	self.undoPageHistory = {};
	self.isDirty = false // True if not all changes are saved yet, used by close button;

	/*
	 * Right panel interaction
	 */
	self.rightPanel = new authoringPanelRight.Panel();

	/*
	 * Left panel interaction
	 */
	self.leftPanel = new authoringPanelLeft.Panel();

	/*
	 * Header
	 */
	self.headerPanel = new authoringHeader.Panel();

	/*
	 * Footer
	 */
	self.footerPanel = new authoringFooter.Panel();

	/*
	 * Page interaction
	 */
	self.authPage = new authoringPage.AuthPage();

	authProps.initProperties(authHelpers);
	authVal.setProperties(authProps);
}, null, {

	destroy: function() {
		var self = this;
		// TODO - improve destroy
		["rightPanel", "leftPanel", "headerPanel", "authPage"].forEach(function(p) {
			if (self[p] && self[p].destroy) {
				self[p].destroy();
			}
			self[p] = null;
		});
	},

	toggleDesignPage: function(forceStatus) {
		if (this.isActive || forceStatus === false) {
			this.disable();
		} else {
			this.enable();
		}
	},

	enable: function() {
		var self = this;

		self._subscribe();

		self.authPage.enable();
		self.rightPanel.show();
		self.leftPanel.show();
		self.headerPanel.show();
		self.footerPanel.show();

		var page = authCommons.getCurrentPage();
		authHelpers.getPageVariants(page)
			.then(function(variants) {
				page.variants = variants;
				return authHelpers.getPageViews(page)
			})
			.then(function(views) {
				_mergeViews(page, views);
			})
			.then(function() {
				notifications.publish(["sm.auth.set.page"], page);
				authHelpers.triggerResizeInternal({
					preserveScroll: true,
					layout: {
						authPanelLeft: {
							visible: true
						},
						authPanelRight: {
							visible: true
						},
						authPanelHeader: {
							visible: true
						},
						authPanelFooter: {
							visible: true
						},
						pageParameters: {
							forcePreview: true
						}
					}
				});

				self.authPage.enableAuthCss();

				self.isActive = true;
				self.isDirty = false;
				globals.setAuthoringActive(true);
			})
			.fail(function(e) {
				modules.get("modal").error(e);
			});
	},

	disable: function() {
		var self = this;

		self.authPage.disable();
		self.rightPanel.hide();
		self.leftPanel.hide();
		self.headerPanel.hide();
		self.footerPanel.hide();
		self.isActive = false;

		self.authPage.disableAuthCss();

		authHelpers.triggerResizeInternal({
			preserveScroll: true,
			layout: {
				authPanelLeft: {
					visible: false
				},
				authPanelRight: {
					visible: false
				},
				authPanelHeader: {
					visible: false
				},
				authPanelFooter: {
					visible: false
				},
				pageParameters: {
					forcePreview: false
				}
			}
		});
		self.isActive = false;
		self._unscribe();
		globals.setAuthoringActive(false);
	},

	_subscribe: function() {
		notifications.subscribe(this, _authEvents);
	},

	_unscribe: function() {
		notifications.unsubscribe(this, _authEvents);
	},

	notifAllVignettesLoaded: function(dashboardPage) {
		var self = this;
		if (!self.isActive) {
			return;
		}
		self.authPage.enableAuthCss();
		if (dashboardPage) {
			notifications.publish(["sm.auth.set.page"], dashboardPage);
			// computeLayout after having enableAuthCss
			// Card size in vignette depends on enableAuthCss so we have to recompute
			dashboardPage.computeLayout();
		}

	},

	notifPageLoaded: function(page) {
		var self = this;
		if (!self.isActive) {
			return;
		}

		if (page && !page.allowAuthoring()) {
			self.authPage.disableAuthCss();
			self.toggleDesignPage();
			return;
		}

		if (page.isVignette() || page.isDashboard()) {
			// Vignettes do not have to trigger a refresh on load
			// for dashboard, we handle update of the page by notifAllVignettesLoaded
			return;
		}

		notifications.publish(["sm.auth.set.page"], page);
		self.authPage.enableAuthCss();
	},

	notifAuthSetPage: function(page) {
		var self = this;
		var parentAuthoringName = self.currentPageName;
		self.currentPageName = page.getAuthoringName();
		self.currentPageFullName = page.getAuthoringName();

		// Copy of article before we start changing it
		self.displayedArticle = JSON.stringify(page.getArticle());
		// init history on page change
		if (!self.undoPageHistory[self.currentPageName]) {
			self.undoPageHistory[self.currentPageName] = {
				parentPageName: parentAuthoringName,
				articles: []
			};
		}
		notifications.publish(["sm.auth.history.change"], self.undoPageHistory[self.currentPageName].articles);
	},

	// Called if a new article is to be applied on the page by a user interaction
	// Here, we need to put the previous article in the undo buffer
	notifAuthChangePropUi: function(articlePage, states, vignetteToUpdt) {
		var self = this;

		if (self.displayedArticle != null) {
			self.isDirty = true; // As soon as we put something into the undo history, we got dirty changes we need to save
			self.undoPageHistory[self.currentPageName].articles.push(self.displayedArticle);
			notifications.publish(["sm.auth.history.change"], self.undoPageHistory[self.currentPageName].articles);
			self.displayedArticle = null;
		}
		self._updateLayoutPage(articlePage, states, vignetteToUpdt);
	},

	// Called by panels if something has changed to trigger a repaint of the page content and also reinitialize the panels
	notifAuthChangeItemPropUi: function() {
		var self = this;
		var page = authCommons.getCurrentPage();
		var states = {};
		var articleJSON = authHelpers.rebuildArticleByPageStruct(page, states);
		notifications.publish(["sm.auth.change.prop.ui"], articleJSON, states);
	},

	notifAuthClose: function(articlePage) {
		var self = this;
		var page = authCommons.getCurrentPage();
		if (page && page.isCardDetail()) {
			self._closeCardDesign();
		} else {
			self._authCloseAuthoring(articlePage);
		}
	},

	_authCloseAuthoring: function(articlePage) {
		var self = this;
		var _end = function() {
			self.undoPageHistory = {};
			notifications.publish(["sm.auth.history.change"], []);
			self.disable();
			authHelpers.triggerResizeInternal();
		};
		if (self.isDirty === true) {
			modal.simpleConfirmPromise({
					message: locale.text("auth.msg.close")
				})
				.then(function(result) {
					if (result.action === "yes") {
						_end();
					}
				});
		} else {
			_end();
		}
	},

	/**
	 * When we change orientation, device, scale
	 * type = orientation, device, scale
	 */
	notifAuthDisplayChanged: function(type) {
		// We need to remove current selection
		// Indeed, sometimes authoring depends on the type of device or orientation
		// We remove the current selection in order to recreate it on click with new context
		// Ex: query filters are forced to tabs' for smartphone so we must not display property 'Filters' for $resources if device= smartphone
		this.leftPanel.setSelection(null);
	},

	notifAuthSave: function() {
		var self = this;
		var page = authCommons.getCurrentPage();
		if (page && page.isCardDetail()) {
			self._saveCardDesign();
			return;
		}

		var article = authCommons.getCurrentPage().getArticle();
		var articleParsed = authVal.validateJSON(true, article, authProps.getAllProperties());
		if (!articleParsed) {
			return;
		}
		var propertiesVariantSelected = authHelpers.getPropertiesCurrentVariant(page);
		var comment = articleParsed && articleParsed.$comment;
		var context = {
			code: propertiesVariantSelected.code || locale.text("auth.panel.authCodeDefault"),
			title: propertiesVariantSelected.title || locale.text("auth.panel.authTitleDefault"),
			description: propertiesVariantSelected.description || locale.text("auth.panel.authDescriptionDefault"),
			isFactory: propertiesVariantSelected.isFactory,
			isGlobal: propertiesVariantSelected.isGlobal,
			isPersonal: propertiesVariantSelected.isPersonal,
			factoryOwner: propertiesVariantSelected.factoryOwner,
			securityProfile: authCommons.getSecurityProfile(),
			uuid: propertiesVariantSelected.uuid,
			comment: propertiesVariantSelected.comment || comment,
			variants: authHelpers.getPropertiesVariants(page),
		};
		context.pageName = self.currentPageName;
		var modal = new modalSaveAuth.Modal(context);
		var canceled = false;
		var modalCtx;
		modal.show()
			.then(function(ctx) {
				modalCtx = ctx;
				canceled = modalCtx == null;
				if (canceled) return;
				articleParsed.$comment = ctx.comment;
				var params = {
					code: ctx.code,
					title: ctx.title,
					description: ctx.description,
					variantType: ctx.variantType,
					uuid: ctx.uuid,
					article: articleParsed
				};
				params.article = utils.sanitizeArticle(params.article);
				return authHelpers.saveAuthoring(page, params);
			}).then(function() {
				if (canceled) return;
				if (!modalCtx.uuid) { //refresh right panel because of new view
					self.rightPanel.notifAuthSetSelection();
				}
				self.isDirty = false;
			}).then(function() {
				if (canceled) return;
				modules.get("modal").info(locale.text("auth.panel.save_ok_title"), locale.text("auth.panel.save_ok_text"));
			}).fail(function(e) {
				modules.get("modal").error(locale.text("auth.panel.save_error_title"), e);
			});
	},
	notifAuthNewLayout: function(type, template) {
		var self = this;
		var page = authCommons.getCurrentPage();
		authoringArticleGen.genNewArticle({
				page: page,
				orientation: type,
				template: template
			})
			.then(function(article) {
				var articleJSON = authVal.toSortedJSON(article);
				notifications.publish(["sm.auth.change.prop.ui"], articleJSON);
			})
			.fail(function(e) {
				modal.error(e);
			});
	},
	notifAuthUndo: function(all) {
		var self = this;
		var article;
		if (all) {
			article = self.undoPageHistory[self.currentPageName].articles.shift();
			self.undoPageHistory[self.currentPageName].articles = [];
		} else {
			article = self.undoPageHistory[self.currentPageName].articles.pop();
		}

		notifications.publish(["sm.auth.history.change"], self.undoPageHistory[self.currentPageName].articles);
		notifications.publishEx(["sm.auth.change.prop.ui"], {
			exclude: [self]
		}, article);

		self._updateLayoutPage(article);
	},
	notifAuthOpenCardDesign: function() {
		this._openCardDesign();
	},
	/**
	 * vignetteToUpdt!=null means just reload this vignette  - see pageDashboard.authUpdateLayout
	 */
	_updateLayoutPage: function(articlePage, states, vignetteToUpdt) {
		var self = this;
		var page = authCommons.getCurrentPage();
		try {
			var articleParsed = JSON.parse(articlePage);
		} catch (e) {
			// Never end up here because validated before
		}
		if (!articleParsed) {
			return;
		}

		var path = self._findSelectionPath();

		authHelpers.savePanelStates();

		// Copy of article before we start changing it once again
		self.displayedArticle = articlePage;
		self.authPage.disableAuthCss();
		page.authUpdateLayout(articleParsed, vignetteToUpdt)
			.then(function() {
				self.authPage.enableAuthCss();
				if (states) {
					self._applyPreviousStates(states);
				}
				self._selectByPath(path);
			}).fail(function(e) {
				modules.get("modal").error(e);
			});

	},
	_applyPreviousStates: function(states) {
		var self = this;
		var page = authCommons.getCurrentPage();
		for (var statePath in states) {
			statePath = statePath.length > 0 ? statePath.split(".") : [];
			var node = page.rootLayout.findChildByPath(statePath);
			if (node) {
				node.setAuthState(states[statePath]);
			}
		}
	},
	/**
	 * returns $$currentpage$$ if root page elmt is selected
	 */
	_findSelectionPath: function() {
		var id = this.authPage.getCurrentSelectionId();
		if (id === authCommons.getCurrentPage().id) {
			return "$$currentpage$$";
		}
		var sel = id && authHelpers.getSelectionById(id);
		var data = sel && authHelpers.getSelectionData(sel);
		if (!data || !data.control) {
			return null;
		}
		var path = data.control.getPathInTree();
		return path;
	},

	_selectByPath: function(path) {
		var page = authCommons.getCurrentPage();
		if (!path || !page) {
			return;
		}
		if (path === "$$currentpage$$") {
			path = page.id;
		} else {
			var node = page.rootLayout.findChildByPath(path);
			path = node ? node.id : null;
		}
		if (path) {
			notifications.publishEx(["sm.auth.set.selection"], {
				exclude: [this]
			}, path);
		}
	},
	_isArticleChange: function(articleBefore) {
		//Be careful : article is a string of json 
		//			   Only for carddesign and chartdetail
		var article = JSON.stringify(authCommons.getCurrentPage().getArticle());
		return (articleBefore !== article);
	},

	_openCardDesign: function() {
		var id = this.authPage.getCurrentSelectionId();
		var sel = id && authHelpers.getSelectionById(id);
		var data = sel && authHelpers.getSelectionData(sel);
		if (!data || !data.control || !data.control.getCardDetailPageData) {
			return null;
		}

		var page = data.control.page || authCommons.getCurrentPage();
		modules.get("navHelper").gotoUrl("child://SdataCardDetail", null, {
			isChild: true,
			childContext: {
				controllerId: page.controller.id,
				arrayControlId: data.control.id,
				cardDetailPageData: data.control.getCardDetailPageData()
			}
		});
	},

	_closeCardDesign: function() {
		this._goBack();
	},
	_saveCardDesign: function() {
		var self = this;
		var page = authCommons.getCurrentPage();

		var cardArticle = page.getCardArticle();
		var arrayControl = page.getCardArrayControl();

		self._goBack()
			.then(function() {
				page = authCommons.getCurrentPage();

				// Inject article of card detail page into array control
				if (arrayControl) {
					arrayControl.setCardDetailArticle(cardArticle);
				}
				notifications.publish(["sm.auth.change.item.prop.ui"]);
			});
	},
	_goBack: function() {
		var navStack = modules.get("navStack").getMainStack();
		if (navStack) {
			return navStack.goBack().then(function() {
				var page = navStack.getTopPage();
				notifications.publish(["sm.auth.set.page"], page);
			});
		}
		return $.smResolve();
	}
});

function _mergeViews(page, views) {
	var pviews = page.pageData.page.$views = page.pageData.page.$views || [];
	views.forEach(function(view) {
		// View not yet know by client so add it but it also cannot be selected
		view.$selected = false;

		pviews.some(function(pview) {
			var match = pview.$url === view.$url;
			if (match) {
				view.$selected = pview.$selected;
			}
			return match;
		});
	})
	page.pageData.page.$views = views;
}