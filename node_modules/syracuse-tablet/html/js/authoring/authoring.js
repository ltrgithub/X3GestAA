"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var authoringPanelRight = require('syracuse-tablet/html/js/authoring/authoringPanelRight');
var authoringPanelLeft = require('syracuse-tablet/html/js/authoring/authoringPanelLeft');
var authoringPage = require('syracuse-tablet/html/js/authoring/authoringPage');
var authoringHeader = require('syracuse-tablet/html/js/authoring/authoringHeader');
var authoringFooter = require('syracuse-tablet/html/js/authoring/authoringFooter');
var authoringArticleGen = require('syracuse-tablet/html/js/authoring/authoringArticleGen');
var authVal = require('syracuse-tablet/html/js/authoring/authoringVal');
var modalSaveAuth = require('syracuse-tablet/html/js/ui/modals/modalSaveAuth');

var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var authProps = require('syracuse-tablet/html/js/authoring/authoringProperties');
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _authInterface;
var _saveContext;

/*
 * This module glues together the action done in the page and the two panels
 */

exports.toggleDesignPage = function() {
	if (!_authInterface) {
		_authInterface = new AuthInterface();
	}

	_authInterface.toggleDesignPage();
};

var AuthInterface = utils.defineClass(function AuthoringInterface() {
	var self = this;
	self.$$authPanel = null;
	self.isActive = false;

	self.undoHistory = {
		pageName: null, // Page for which this history is valid (to detect page change)
		articles: [] // List of articles, history of changes
	};
	self.isDirty = false // True if not all changes are saved yet, used by close button;

	/*
	 * Right panel interaction
	 */
	self.rightPanel = new authoringPanelRight.Panel();

	/*
	 * Left panel interaction
	 */
	self.leftPanel = new authoringPanelLeft.Panel();

	/*
	 * Header
	 */
	self.headerPanel = new authoringHeader.Panel();

	/*
	 * Footer
	 */
	self.footerPanel = new authoringFooter.Panel();

	/*
	 * Page interaction
	 */
	self.authPage = new authoringPage.AuthPage();

	authProps.initProperties(authHelpers);
	authVal.setProperties(authProps);
}, null, {
	toggleDesignPage: function() {
		var self = this;

		if (self.isActive) {
			self.disable();
		} else {
			self.enable();
		}
		uiutils.triggerResizeInternal();
	},

	enable: function() {
		var self = this;

		self._subscribe();

		self.authPage.enable();
		self.rightPanel.show();
		self.leftPanel.show();
		self.headerPanel.show();
		self.footerPanel.show();

		var page = globals.getApplication().currentPage;
		notifications.publish(["sm.auth.set.page"], page);

		uiutils.triggerResizeInternal({
			layout: {
				authPanelLeft: {
					visible: true
				},
				authPanelRight: {
					visible: true
				},
				authPanelHeader: {
					visible: true
				},
				authPanelFooter: {
					visible: true
				},
				pageParameters: {
					forcePreview: true
				}
			}
		});

		self.authPage.enableAuthCss();

		self.isActive = true;
		self.isDirty = false;
		globals.setAuthoringActive(true);
	},

	disable: function() {
		var self = this;

		self.authPage.disable();
		self.rightPanel.hide();
		self.leftPanel.hide();
		self.headerPanel.hide();
		self.footerPanel.hide();
		self.isActive = false;

		self.authPage.disableAuthCss();

		uiutils.triggerResizeInternal({
			layout: {
				authPanelLeft: {
					visible: false
				},
				authPanelRight: {
					visible: false
				},
				authPanelHeader: {
					visible: false
				},
				authPanelFooter: {
					visible: false
				},
				pageParameters: {
					forcePreview: false
				}
			}
		});
		self.isActive = false;
		self._unscribe();
		globals.setAuthoringActive(false);
	},

	_subscribe: function() {
		var self = this;
		notifications.subscribe(self, ["sm.page.loaded"]);
		notifications.subscribe(self, ["sm.auth.change.item.prop.ui"]);
		notifications.subscribe(self, ["sm.auth.change.prop.ui"]);
		notifications.subscribe(self, ["sm.auth.close"]);
		notifications.subscribe(self, ["sm.auth.save"]);
		notifications.subscribe(self, ["sm.auth.new.layout"]);
		notifications.subscribe(self, ["sm.auth.set.page"]);
		notifications.subscribe(self, ["sm.auth.display.changed"]);
		notifications.subscribe(self, ["sm.auth.undo"]);
	},

	_unscribe: function() {
		var self = this;
		notifications.unsubscribe(self, ["sm.page.loaded"]);
		notifications.unsubscribe(self, ["sm.auth.change.item.prop.ui"]);
		notifications.unsubscribe(self, ["sm.auth.change.prop.ui"]);
		notifications.unsubscribe(self, ["sm.auth.close"]);
		notifications.unsubscribe(self, ["sm.auth.save"]);
		notifications.unsubscribe(self, ["sm.auth.new.layout"]);
		notifications.unsubscribe(self, ["sm.auth.set.page"]);
		notifications.unsubscribe(self, ["sm.auth.display.changed"]);
		notifications.unsubscribe(self, ["sm.auth.undo"]);
	},

	notifPageLoaded: function(page) {
		var self = this;
		if (!self.isActive) {
			return;
		}

		if (page && page.state && page.state.disableAuthoring) {
			self.authPage.disableAuthCss();
			self.toggleDesignPage();
			return;
		}

		if (page && !page.isVignette) {
			notifications.publish(["sm.auth.set.page"], page);
		}
		self.authPage.enableAuthCss();
	},

	notifAuthSetPage: function(page) {
		var self = this;
		self.currentPageName = page.state.authoringName;

		// Copy of article before we start changing it
		self.displayedArticle = JSON.stringify(page.article);

		// Clean history on page change
		if (self.currentPageName !== self.undoHistory.pageName) {
			self.undoHistory.pageName = self.currentPageName;
			self.undoHistory.articles = [];
			notifications.publish(["sm.auth.history.change"], self.undoHistory);
		}
	},

	// Called if a new article is to be applied on the page by a user interaction
	// Here, we need to put the previous article in the undo buffer
	notifAuthChangePropUi: function(articlePage, states) {
		var self = this;

		if (self.displayedArticle != null) {
			self.isDirty = true; // As soon as we put something into the undo history, we got dirty changes we need to save

			self.undoHistory.articles.push(self.displayedArticle);
			notifications.publish(["sm.auth.history.change"], self.undoHistory);
			self.displayedArticle = null;
		}
		self._updateLayoutPage(articlePage, states);
	},

	// Called by panels if something has changed to trigger a repaint of the page content and also reinitialize the panels
	notifAuthChangeItemPropUi: function(data) {
		var self = this;
		var page = globals.getApplication().currentPage;
		var states = {};
		var articleJSON = authHelpers.rebuildArticleByPageStruct(page, states);
		notifications.publish(["sm.auth.change.prop.ui"], articleJSON, states);
	},

	notifAuthClose: function(articlePage) {
		var self = this;
		if (self.isDirty === true) {
			modal.simpleConfirmPromise({
				message: locale.text("auth.msg.close")
			})
				.then(function(result) {
					if (result.action === "yes") {
						self.undoHistory.articles = [];
						self.disable();
					}
				});
		} else {
			self.undoHistory.articles = [];
			self.disable();
		}
	},

	/**
	 * When we change orientation, device, scale
	 * type = orientation, device, scale
	 */
	notifAuthDisplayChanged: function(type) {
		// We need to remove current selection
		// Indeed, sometimes authoring depends on the type of device or orientation
		// We remove the current selection in order to recreate it on click with new context
		// Ex: query filters are forced to tabs' for smartphone so we must not display property 'Filters' for $resources if device= smartphone
		this.leftPanel.setSelection(null);
	},


	notifAuthSave: function() {
		var self = this;
		var article = self.rightPanel.getPageArticle();
		var articleParsed = authVal.validateJSON(true, article, authProps.getAllProperties());
		if (!articleParsed) {
			return;
		}

		_saveContext = _saveContext || {
			code: locale.text("auth.panel.authCodeDefault"),
			title: locale.text("auth.panel.authTitleDefault"),
			description: locale.text("auth.panel.authDescriptionDefault"),
			saveAs: "personal_copy"
		};
		_saveContext.pageName = self.currentPageName;
		var modal = new modalSaveAuth.Modal(_saveContext);
		modal.show()
			.then(function(ctx) {
				if (ctx != null) {
					_saveContext = ctx; // Remember for next time

					var params = {
						code: ctx.code,
						title: ctx.title,
						description: ctx.description,

						// "factory_variant", "personal_copy", "global_variant"
						// -> "shared_copy" not yet supported
						saveAs: ctx.saveAs,
						article: articleParsed
					};
					authHelpers.saveAuthoring(self.currentPageName, params);

					self.isDirty = false;
				}
			}).fail(function(e) {
				globals.getModal().error(e);
			});
	},

	notifAuthNewLayout: function(type, template) {
		var page = globals.getApplication().currentPage;
		authoringArticleGen.genNewArticle({
			page: page,
			orientation: type,
			template: template
		})
			.then(function(article) {
				var articleJSON = authVal.toSortedJSON(article);
				notifications.publish(["sm.auth.change.prop.ui"], articleJSON);
			})
			.fail(function(e) {
				modal.error(e);
			});
	},

	notifAuthUndo: function(all) {
		var self = this;
		var article;
		if (all) {
			article = self.undoHistory.articles.shift();
			self.undoHistory.articles = [];
		} else {
			article = self.undoHistory.articles.pop();
		}

		notifications.publish(["sm.auth.history.change"], self.undoHistory);
		notifications.publishEx(["sm.auth.change.prop.ui"], {
			exclude: [self]
		}, article);

		self._updateLayoutPage(article);
	},

	_updateLayoutPage: function(articlePage, states) {
		var self = this;
		var page = globals.getApplication().currentPage;
		try {
			var articleParsed = JSON.parse(articlePage);
		} catch (e) {
			// Never end up here because validated before
		}
		if (!articleParsed) {
			return;
		}

		var path = self._findSelectionPath();

		authHelpers.savePanelStates();

		// Copy of article before we start changing it once again
		self.displayedArticle = articlePage;

		self.authPage.disableAuthCss();
		page.authUpdateLayout(articleParsed)
			.then(function() {
				self.authPage.enableAuthCss();
				if (states) {
					self._applyPreviousStates(states);
				}
				self._selectByPath(path);
			});

	},

	_applyPreviousStates: function(states) {
		var self = this;
		var page = globals.getApplication().currentPage;
		for (var statePath in states) {
			statePath = statePath.length > 0 ? statePath.split(".") : [];
			var node = page.rootLayout.findChildByPath(statePath);
			if (node) {
				node.setAuthState(states[statePath]);
			}
		}
	},

	_findSelectionPath: function() {
		var self = this;
		var id = self.authPage.getCurrentSelectionId();
		var sel = id && authHelpers.getSelectionById(id);
		var data = sel && authHelpers.getSelectionData(sel);
		if (!data || !data.control) {
			return null;
		}
		var path = data.control.getPathInTree();
		return path;
	},

	_selectByPath: function(path) {
		var self = this;
		if (!path) {
			return;
		}
		var page = globals.getApplication().currentPage;
		var node = page.rootLayout.findChildByPath(path);

		if (node) {
			notifications.publishEx(["sm.auth.set.selection"], {
				exclude: [self]
			}, node.id);
		}
	}
});