"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var globals = require('syracuse-tablet/html/js/helpers/globals');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var authHelpers = require('syracuse-tablet/html/js/authoring/authoringHelpers');
var authoringPanelRight = require('syracuse-tablet/html/js/authoring/authoringPanelRight');
var authoringPanelLeft = require('syracuse-tablet/html/js/authoring/authoringPanelLeft');
var authoringPage = require('syracuse-tablet/html/js/authoring/authoringPage');
var authoringHeader = require('syracuse-tablet/html/js/authoring/authoringHeader');
var authoringFooter = require('syracuse-tablet/html/js/authoring/authoringFooter');
var authoringArticleGen = require('syracuse-tablet/html/js/authoring/authoringArticleGen');
var authVal = require('syracuse-tablet/html/js/authoring/authoringVal');
var modalSaveAuth = require('syracuse-tablet/html/js/ui/modals/modalSaveAuth');
var eventListener = require('syracuse-tablet/html/js/application/eventListener');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');
var authProps = require('syracuse-tablet/html/js/authoring/authoringProperties');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _authInterface;
var _saveContext;

/*
 * This module glues together the action done in the page and the two panels
 */

exports.toggleDesignPage = function() {
	if (!_authInterface) {
		_authInterface = new AuthInterface();
	}

	_authInterface.toggleDesignPage();
};
exports.isEnabled = function() {
	return _authInterface && _authInterface.isActive;
};
/**
 * Returns true if back process can continue
 */
exports.checkBack = function() {
	if (!exports.isEnabled()) return true;
	return _authInterface.checkBack();
};
// Called on unload event - application.onUnload
exports.destroy = function() {
	if (!_authInterface) return;
	_authInterface.destroy();
	_authInterface = null;
};
var AuthInterface = utils.defineClass(function AuthoringInterface() {
	var self = this;
	self.$$authPanel = null;
	self.isActive = false;

	self.undoPageHistory = {};
	self.isDirty = false // True if not all changes are saved yet, used by close button;

	/*
	 * Right panel interaction
	 */
	self.rightPanel = new authoringPanelRight.Panel();

	/*
	 * Left panel interaction
	 */
	self.leftPanel = new authoringPanelLeft.Panel();

	/*
	 * Header
	 */
	self.headerPanel = new authoringHeader.Panel();

	/*
	 * Footer
	 */
	self.footerPanel = new authoringFooter.Panel();

	/*
	 * Page interaction
	 */
	self.authPage = new authoringPage.AuthPage();

	authProps.initProperties(authHelpers);
	authVal.setProperties(authProps);
}, null, {

	destroy: function() {
		var self = this;
		// TODO - improve destroy
		["rightPanel", "leftPanel", "headerPanel", "authPage"].forEach(function(p) {
			if (self[p] && self[p].destroy) {
				self[p].destroy();
			}
			self[p] = null;
		});
	},

	toggleDesignPage: function(forceStatus) {
		if (this.isActive || forceStatus === false) {
			this.disable();
		} else {
			this.enable();
		}
	},

	enable: function() {
		var self = this;

		self._subscribe();

		self.authPage.enable();
		self.rightPanel.show();
		self.leftPanel.show();
		self.headerPanel.show();
		self.footerPanel.show();

		var page = globals.getApplication().currentPage;
		notifications.publish(["sm.auth.set.page"], page);

		authHelpers.triggerResizeInternal({
			preserveScroll: true,
			layout: {
				authPanelLeft: {
					visible: true
				},
				authPanelRight: {
					visible: true
				},
				authPanelHeader: {
					visible: true
				},
				authPanelFooter: {
					visible: true
				},
				pageParameters: {
					forcePreview: true
				}
			}
		});

		self.authPage.enableAuthCss();

		self.isActive = true;
		self.isDirty = false;
		globals.setAuthoringActive(true);
	},

	disable: function() {
		var self = this;

		self.authPage.disable();
		self.rightPanel.hide();
		self.leftPanel.hide();
		self.headerPanel.hide();
		self.footerPanel.hide();
		self.isActive = false;

		self.authPage.disableAuthCss();

		authHelpers.triggerResizeInternal({
			preserveScroll: true,
			layout: {
				authPanelLeft: {
					visible: false
				},
				authPanelRight: {
					visible: false
				},
				authPanelHeader: {
					visible: false
				},
				authPanelFooter: {
					visible: false
				},
				pageParameters: {
					forcePreview: false
				}
			}
		});
		self.isActive = false;
		self._unscribe();
		globals.setAuthoringActive(false);
	},

	_subscribe: function() {
		var self = this;
		notifications.subscribe(self, ["sm.page.loaded"]);
		notifications.subscribe(self, ["sm.auth.change.item.prop.ui"]);
		notifications.subscribe(self, ["sm.auth.change.prop.ui"]);
		notifications.subscribe(self, ["sm.auth.close"]);
		notifications.subscribe(self, ["sm.auth.save"]);
		notifications.subscribe(self, ["sm.auth.new.layout"]);
		notifications.subscribe(self, ["sm.auth.set.page"]);
		notifications.subscribe(self, ["sm.auth.display.changed"]);
		notifications.subscribe(self, ["sm.auth.undo"]);
	},

	_unscribe: function() {
		var self = this;
		notifications.unsubscribe(self, ["sm.page.loaded"]);
		notifications.unsubscribe(self, ["sm.auth.change.item.prop.ui"]);
		notifications.unsubscribe(self, ["sm.auth.change.prop.ui"]);
		notifications.unsubscribe(self, ["sm.auth.close"]);
		notifications.unsubscribe(self, ["sm.auth.save"]);
		notifications.unsubscribe(self, ["sm.auth.new.layout"]);
		notifications.unsubscribe(self, ["sm.auth.set.page"]);
		notifications.unsubscribe(self, ["sm.auth.display.changed"]);
		notifications.unsubscribe(self, ["sm.auth.undo"]);
	},

	notifPageLoaded: function(page) {
		var self = this;
		if (!self.isActive) {
			return;
		}

		if (page && page.state && page.state.disableAuthoring) {
			self.authPage.disableAuthCss();
			self.toggleDesignPage();
			return;
		}

		if (page && !page.isVignette) {
			notifications.publish(["sm.auth.set.page"], page);
		}
		self.authPage.enableAuthCss();
	},

	notifAuthSetPage: function(page) {
		var self = this;
		var parentAuthoringName = self.currentPageName;
		self.currentPageName = page.state.authoringName;

		// Copy of article before we start changing it
		self.displayedArticle = JSON.stringify(page.article);
		// init history on page change
		if (!self.undoPageHistory[self.currentPageName]) {
			self.undoPageHistory[self.currentPageName] = {
				parentPageName: parentAuthoringName,
				articles: []
			};
		}
		notifications.publish(["sm.auth.history.change"], self.undoPageHistory[self.currentPageName].articles);
	},

	// Called if a new article is to be applied on the page by a user interaction
	// Here, we need to put the previous article in the undo buffer
	notifAuthChangePropUi: function(articlePage, states, vignetteToUpdt) {
		var self = this;

		if (self.displayedArticle != null) {
			self.isDirty = true; // As soon as we put something into the undo history, we got dirty changes we need to save
			self.undoPageHistory[self.currentPageName].articles.push(self.displayedArticle);
			notifications.publish(["sm.auth.history.change"], self.undoPageHistory[self.currentPageName].articles);
			self.displayedArticle = null;
		}
		self._updateLayoutPage(articlePage, states, vignetteToUpdt);
	},

	// Called by panels if something has changed to trigger a repaint of the page content and also reinitialize the panels
	notifAuthChangeItemPropUi: function(data) {
		var self = this;
		var page = globals.getApplication().currentPage;
		var states = {};
		var articleJSON = authHelpers.rebuildArticleByPageStruct(page, states);
		var vignetteToUpdt = null;
		if (data && data.control && data.control.controller) {
			vignetteToUpdt = data.control.controller.getParentVignette();
		}
		notifications.publish(["sm.auth.change.prop.ui"], articleJSON, states, vignetteToUpdt);
	},

	notifAuthClose: function(articlePage) {
		var self = this;
		var pageType = globals.getApplication().currentPage.state.type;
		if (pageType === "carddesign" || pageType === "chartdetail") {
			self._authGoBackAuthoring(articlePage);
		} else {
			self._authCloseAuthoring(articlePage);
		}
	},
	_authCloseAuthoring: function(articlePage) {
		var self = this;
		if (self.isDirty === true) {
			modal.simpleConfirmPromise({
				message: locale.text("auth.msg.close")
			})
				.then(function(result) {
					if (result.action === "yes") {
						self.undoPageHistory = {};
						notifications.publish(["sm.auth.history.change"], []);
						self.disable();
					}
				});
		} else {
			self.undoPageHistory = {};
			notifications.publish(["sm.auth.history.change"], []);
			self.disable();
		}
	},
	_authGoBackAuthoring: function(articlePage) {
		// No close authoring - Just back to previous page - TODO Improve to reselect the control in main page
		var self = this;
		if (this._isArticleChange(this.displayedArticle)) {
			modal.simpleConfirmPromise({
				message: locale.text("auth.msg.close")
			})
				.then(function(result) {
					if (result.action === "yes") {
						var article = self.undoPageHistory[self.currentPageName].articles.shift();
						self.undoPageHistory[self.currentPageName].articles = [];
						notifications.publish(["sm.auth.history.change"], self.undoPageHistory[self.currentPageName].articles);
						notifications.publishEx(["sm.auth.change.prop.ui"], {
							exclude: [self]
						}, article);
						globals.getApplication().goBack();
					}
				});
		} else {
			globals.getApplication().goBack();
		}
	},
	/**
	 * When we change orientation, device, scale
	 * type = orientation, device, scale
	 */
	notifAuthDisplayChanged: function(type) {
		// We need to remove current selection
		// Indeed, sometimes authoring depends on the type of device or orientation
		// We remove the current selection in order to recreate it on click with new context
		// Ex: query filters are forced to tabs' for smartphone so we must not display property 'Filters' for $resources if device= smartphone
		this.leftPanel.setSelection(null);
	},


	notifAuthSave: function(typeSave) {
		var self = this;
		if (typeSave) {
			if (this._isArticleChange(this.displayedArticle)) {
				self.undoPageHistory[self.currentPageName].articles = [];
				var parentPageName = self.undoPageHistory[self.currentPageName].parentPageName;
				if (parentPageName) {
					notifications.publish(["sm.auth.history.change"], self.undoPageHistory[parentPageName].articles);
				}
			}
			// saveCardDesign / saveChartDetail
			eventListener.triggerAction(globals.getApplication().currentPage.$$elmt, typeSave);
			return;
		}
		var article = self.rightPanel.getPageArticle();
		var articleParsed = authVal.validateJSON(true, article, authProps.getAllProperties());
		if (!articleParsed) {
			return;
		}
		var comment = articleParsed && articleParsed.$comment;
		_saveContext = _saveContext || {
			code: locale.text("auth.panel.authCodeDefault"),
			title: locale.text("auth.panel.authTitleDefault"),
			description: locale.text("auth.panel.authDescriptionDefault"),
			saveAs: "personal_copy",
			comment: comment
		};
		_saveContext.pageName = self.currentPageName;
		var modal = new modalSaveAuth.Modal(_saveContext);
		modal.show()
			.then(function(ctx) {
				if (ctx != null) {
					_saveContext = ctx; // Remember for next time
					articleParsed.$comment = ctx.comment;
					var params = {
						code: ctx.code,
						title: ctx.title,
						description: ctx.description,

						// "factory_variant", "personal_copy", "global_variant"
						// -> "shared_copy" not yet supported
						saveAs: ctx.saveAs,
						article: articleParsed
					};
					authHelpers.saveAuthoring(self.currentPageName, params);

					self.isDirty = false;
				}
			}).fail(function(e) {
				globals.getModal().error(e);
			});
	},

	notifAuthNewLayout: function(type, template) {
		var page = globals.getApplication().currentPage;
		authoringArticleGen.genNewArticle({
			page: page,
			orientation: type,
			template: template
		})
			.then(function(article) {
				var articleJSON = authVal.toSortedJSON(article);
				notifications.publish(["sm.auth.change.prop.ui"], articleJSON);
			})
			.fail(function(e) {
				modal.error(e);
			});
	},

	notifAuthUndo: function(all) {
		var self = this;
		var article;
		if (all) {
			article = self.undoPageHistory[self.currentPageName].articles.shift();
			self.undoPageHistory[self.currentPageName].articles = [];
		} else {
			article = self.undoPageHistory[self.currentPageName].articles.pop();
		}

		notifications.publish(["sm.auth.history.change"], self.undoPageHistory[self.currentPageName].articles);
		notifications.publishEx(["sm.auth.change.prop.ui"], {
			exclude: [self]
		}, article);

		self._updateLayoutPage(article);
	},
	/**
	 * vignetteToUpdt!=null means just reload this vignette  - see pageDashboard.authUpdateLayout
	 */
	_updateLayoutPage: function(articlePage, states, vignetteToUpdt) {
		var self = this;
		var page = globals.getApplication().currentPage;
		try {
			var articleParsed = JSON.parse(articlePage);
		} catch (e) {
			// Never end up here because validated before
		}
		if (!articleParsed) {
			return;
		}

		var path = self._findSelectionPath();

		authHelpers.savePanelStates();

		// Copy of article before we start changing it once again
		self.displayedArticle = articlePage;
		self.authPage.disableAuthCss();
		page.authUpdateLayout(articleParsed, vignetteToUpdt)
			.then(function() {
				self.authPage.enableAuthCss();
				if (states) {
					self._applyPreviousStates(states);
				}
				self._selectByPath(path);
			});

	},
	_applyPreviousStates: function(states) {
		var self = this;
		var page = globals.getApplication().currentPage;
		for (var statePath in states) {
			statePath = statePath.length > 0 ? statePath.split(".") : [];
			var node = page.rootLayout.findChildByPath(statePath);
			if (node) {
				node.setAuthState(states[statePath]);
			}
		}
	},
	/**
	 * returns $$currentpage$$ if root page elmt is selected
	 */
	_findSelectionPath: function() {
		var id = this.authPage.getCurrentSelectionId();
		if (id === globals.getApplication().currentPage.id) {
			return "$$currentpage$$";
		}
		var sel = id && authHelpers.getSelectionById(id);
		var data = sel && authHelpers.getSelectionData(sel);
		if (!data || !data.control) {
			return null;
		}
		var path = data.control.getPathInTree();
		return path;
	},

	_selectByPath: function(path) {
		var page = globals.getApplication().currentPage;
		if (!path || !page) {
			return;
		}
		if (path === "$$currentpage$$") {
			path = page.id;
		} else {
			var node = page.rootLayout.findChildByPath(path);
			path = node ? node.id : null;
		}
		if (path) {
			notifications.publishEx(["sm.auth.set.selection"], {
				exclude: [this]
			}, path);
		}
	},
	_isArticleChange: function(articleBefore) {
		//Be careful : article is a string of json 
		//			   Only for carddesign and chartdetail
		var article = JSON.stringify(globals.getApplication().currentPage.article);
		return (articleBefore !== article);
	},
	checkBack: function() {
		var pageType = globals.getApplication().currentPage.state.type;
		if (pageType === "carddesign" || pageType === "chartdetail") {
			return true;
		}
		notifications.publish(["sm.auth.close"]);
		return false;
	}
});