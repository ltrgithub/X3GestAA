"use strict";

var locale = require('syracuse-tablet/html/js/helpers/locale');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var authPropsGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');

var _err = authPropsGeneral.err;
var maxSegments = 5;

var _properties = {
	/*
	 *	Display numeric data either as normal number field or as gauge
	 */
	"numDisplay": {
		"key": "$numDisplay",
		"default": "normal",
		values: [{
			value: "normal"
		}, {
			value: "gauge"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Sets gauge range (min/max) values origin. Either "default", "bind", or "value"
	 *	- default : gauge component default range values
	 *	- bind : use one field value as range value
	 *	- value : user specified directly range values in input field
	 */
	"gSetBorderValues": {
		"key": "$gSetBorderValues",
		"default": "default",
		values: [{
			value: "default"
		}, {
			value: "value"
		}, {
			value: "bind"
		}],
		createMarkup: authPropsGeneral.createMarkupRadio,
		refreshMarkup: authPropsGeneral.refreshMarkupRadio,
		type: "child"
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Set border values (min/max). It will be either a textarea or a selector
	 */
	"gBorderValues": {
		"default": "",
		createMarkup: _createMarkupGBorderValues,
		type: "child"
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Number of gauge segmets
	 */
	"gSegmentsNumber": {
		"default": "",
		createMarkup: _createMarkupGSegmentsNumbers,
		type: "child"
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Configure gauge segments
	 */
	"gSegmentsConfig": {
		"default": "",
		createMarkup: _createMarkupGSegmentsConfig,
		type: "child",
		destroyMarkup: _destroySlider
	},
	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Apply button for segments configuration
	 */
	"gSegmentsConfigApply": {
		applyMarkup: _createMarkupApply
	}
};



function _createMarkupGBorderValues($$parent, prop, sel, data) {
	var ctx = {};
	ctx.label_apply = locale.text("auth.g.label_apply");
	var idMin = "s-m-auth-g-borders-min";
	var idMax = "s-m-auth-g-borders-max";

	// markup depends if border is value or bind
	var isProperty = data.articleSelection.$gSetBorderValues === "bind" ? true : false;

	// if property, build a selection markup, filled with numeric types within the prototype
	if (isProperty) {
		var valMin = data.articleSelection.$gauge.$bindMin;
		var valMax = data.articleSelection.$gauge.$bindMax;

		ctx.label_tip = locale.text("auth.gBorderValues.label_tip.property");
		ctx.label_min = locale.text("auth.gBorderValues.label_min.property");
		ctx.label_max = locale.text("auth.gBorderValues.label_max.property");

		// get number properties from prototype
		var optionsMin = [];
		var optionsMax = [];
		optionsMin.push({
			option_value: "0",
			selected: valMin === "0"
		});

		if (data.control.controller.prototype && data.control.controller.prototype.json && data.control.controller.prototype.json.$properties) {
			$.each(data.control.controller.prototype.json.$properties, function(bind, value) {
				if (_isGaugeValuePropertyType(value.$type) && bind !== data.control.$bind && bind !== data.articleSelection.$bind) {
					optionsMin.push({
						option_value: bind,
						selected: valMin === bind
					});
					optionsMax.push({
						option_value: bind,
						selected: valMax === bind
					});
				}
			});

			ctx.markupMin = authHtml.execute("gaugeSelect", {
				id: idMin,
				options: optionsMin
			});

			ctx.markupMax = authHtml.execute("gaugeSelect", {
				id: idMax,
				options: optionsMax
			});
		} else {
			_err(locale.text("auth.gBorderValues.err.prototype.title"), locale.text("auth.gBorderValues.err.prototype.msg"));
			return;
		}

	}

	// if input, build input markup
	else {
		var valMin, valMax;
		// set valMin considering that user switched from "property" to "input"
		if (data.articleSelection.$gauge.$bindMin && typeof data.articleSelection.$gauge.$bindMin == "string") {
			valMin = data.control.controller.dao.data[data.articleSelection.$gauge.$bindMin];
		} else {
			valMin = data.articleSelection.$gauge.$bindMin;
		}

		// set valMax considering that user switched from "property" to "input"
		if (data.articleSelection.$gauge.$bindMax && typeof data.articleSelection.$gauge.$bindMax == "string") {
			valMax = data.control.controller.dao.data[data.articleSelection.$gauge.$bindMax];
		} else {
			valMax = data.articleSelection.$gauge.$bindMax;
		}

		ctx.label_tip = locale.text("auth.gBorderValues.label_tip.input");
		ctx.label_min = locale.text("auth.gBorderValues.label_min.input");
		ctx.label_max = locale.text("auth.gBorderValues.label_max.input");
		ctx.markupMin = authHtml.execute("gaugeBorderInput", {
			id: idMin,
			value: valMin
		});
		ctx.markupMax = authHtml.execute("gaugeBorderInput", {
			id: idMax,
			value: valMax
		});
	}

	var html = authHtml.execute("authPanelPropertyGBorderValues", ctx);
	var $$panel = $(html);

	// /!\ In bind, allow use of 0
	// onclick, update data and refresh
	$("button", $$panel).on("click", function(e) {
		var err = false;
		var vvMin = $(e.target).parent().find("#" + idMin).val();
		var vvMax = $(e.target).parent().find("#" + idMax).val();
		var errTitle = locale.text("auth.gBorderValues.err.title");

		// min and max are both numbers
		if (!isNaN(parseInt(vvMin), 10) && !isNaN(parseInt(vvMax), 10)) {

			if (vvMax < vvMin) {
				err = _err(errTitle, locale.text("auth.gBorderValues.err.msg.lowerMax", [vvMax, vvMin]));
			}
		} else {

			// min and max should both be string values
			if (!(typeof vvMin == "string" && typeof vvMax == "string")) {
				err = _err(errTitle, locale.text("auth.gBorderValues.err.msg.bothString", [vvMin, vvMax]));
			}

			if (vvMin === vvMax) {
				err = _err(errTitle, locale.text("auth.gBorderValues.err.msg.samebind"));
			}
		}

		if (!err) {
			data.articleSelection.$gauge.$bindMin = vvMin;
			data.articleSelection.$gauge.$bindMax = vvMax;
			authPropsGeneral.notifyChangePropUI($$parent, sel, data);
		}
	});

	// append html
	$$parent.append($$panel);
}


function _createMarkupGSegmentsNumbers($$parent, prop, sel, data) {
	// build html
	var value = data.articleSelection.$gauge.segments ? data.articleSelection.$gauge.segments.length : "";
	var options = [];
	for (var ii = 0, jj = (maxSegments + 1); ii < jj; ii++) {
		var opt = {};
		if (ii == 0) {
			opt.option_value = locale.text("auth.gSegmentsNumber.default");
			opt.selected = value ? true : false;
		} else {
			opt.option_value = ii;
			opt.selected = value == ii;
		}
		options.push(opt);
	}
	var ctx = {
		value: authHtml.execute("gaugeSelect", {
			id: "s-m-auth-g-segnumbers-txt",
			options: options
		}),
		label_apply: locale.text("auth.g.label_apply")

	};

	var html = authHtml.execute("authPanelPropertyGSegmentsNumber", ctx);
	var $$panel = $(html);


	// bind click on apply button
	// onclick, update data and refresh
	$("button", $$panel).on("click", function(e) {

		var vv = $(e.target).prev().val();

		if (value != vv) {
			if (vv && isNaN(parseInt(vv, 10))) {
				_err(locale.text("auth.gSegmentsNumber.err.title"), locale.text("auth.gSegmentsNumber.err.msg.expectedNumber", [vv]));
			} else {
				if (vv) {
					data.articleSelection.$gauge.segments = data.articleSelection.$gauge.segments || [];
					if (data.articleSelection.$gauge.segments.length > vv) {
						data.articleSelection.$gauge.segments.splice(vv);
					}
					for (var ii = 0, jj = vv; ii < jj; ii++) {
						data.articleSelection.$gauge.segments[ii] = data.articleSelection.$gauge.segments[ii] || {};
					}
				} else {
					data.articleSelection.$gauge.segments = null;
				}
				authPropsGeneral.notifyChangePropUI($$parent, sel, data);
			}
		}
	});

	// append html
	$$parent.append($$panel);
}

function _createMarkupGSegmentsConfig($$parent, prop, sel, data) {

	// build html

	var seg = data.articleSelection.$gauge.segments[prop.segIdx];
	var idRoot = "s-m-auth-seg-";
	var idx = prop.segIdx;

	var segInfo = {};
	segInfo.id = idRoot + idx;

	segInfo.label_valstart = locale.text("auth.gSegmentsConfig.label_valstart");
	segInfo.value_valstart = seg.valStart;

	segInfo.label_valend = locale.text("auth.gSegmentsConfig.label_valend");
	segInfo.value_valend = seg.valEnd;

	segInfo.label_propstart = locale.text("auth.gSegmentsConfig.label_propstart");
	segInfo.value_propstart = authHtml.execute("authPanelGaugeSlider", {
		id: segInfo.id + "-propstart",
		min: 0,
		max: 1,
		step: 0.1,
		value: seg.propStart
	});

	segInfo.label_propend = locale.text("auth.gSegmentsConfig.label_propend");
	segInfo.value_propend = authHtml.execute("authPanelGaugeSlider", {
		id: segInfo.id + "-propend",
		min: 0,
		max: 1,
		step: 0.1,
		value: seg.propEnd
	});

	segInfo.label_color = locale.text("auth.gSegmentsConfig.label_color");
	segInfo.value_color = seg.color;
	segInfo.label_apply = locale.text("auth.g.label_apply");

	var html = authHtml.execute("gaugeSegment", segInfo);
	var $$panel = $(html);

	/*
	 *	Bind events
	 */
	// generate slider
	var $$rangeInputArr = $("input.s-m-auth-g-range", $$panel);
	$$rangeInputArr.slider();
	// update range output value
	$$rangeInputArr.on("slide", function(slideEvt) {
		var $$input = $(slideEvt.target);
		var $$output = $$input.next();
		$$output.text(slideEvt.value);
	});

	$$parent.append($$panel);
}

function _createMarkupApply($$parent, prop, sel, data) {
	var html = authHtml.execute("authPanelButton", {
		label: locale.text("auth.gSegmentsConfigApply.label"),
		css: "s-m-auth-g-apply"
	});
	var $$panel = $(html);

	/* bind click on button. apply segments configuration */
	$("button", $$panel).on("click", function(e) {
		var segs = [];
		var $$segments = $(e.target).parent().parent().find(".s-m-auth-seg-slot");
		for (var ii = 0, jj = $$segments.length; ii < jj; ii++) {
			var $$seg = $($$segments[ii]);
			var id = $$seg.attr("id");
			var segInfo = {};
			segInfo.valStart = $("#" + id + "-valstart", $$seg).val();
			segInfo.valEnd = $("#" + id + "-valend", $$seg).val();
			segInfo.propStart = $("#" + id + "-propstart", $$seg).val();
			segInfo.propEnd = $("#" + id + "-propend", $$seg).val();
			segInfo.color = $("#" + id + "-color", $$seg).val();

			// if valStart, valEnd, propStart, propEnd, color value == "", set it to null 
			// this is necessary to comply with the gauge ctrl behavior
			segInfo.valStart = segInfo.valStart === "" ? null : segInfo.valStart;
			segInfo.valEnd = segInfo.valEnd === "" ? null : segInfo.valEnd;
			segInfo.propStart = segInfo.propStart === "" ? null : segInfo.propStart;
			segInfo.propEnd = segInfo.propEnd === "" ? null : segInfo.propEnd;
			segInfo.color = segInfo.color === "" ? null : segInfo.color;

			// check if valStart and valEnd are numeric values
			var vStart = segInfo.valStart;
			var vEnd = segInfo.valEnd;
			if (vStart && isNaN(parseInt(vStart.replace(".", "").replace(",", ""), 10))) {
				_err(locale.text("auth.gSegmentsConfig.err.title"), locale.text("auth.gSegmentsConfig.err.msg.expectedNumber", [locale.text("auth.gSegmentsConfig.label_valstart"), vStart]));
				return;
			}
			if (vEnd && isNaN(parseInt(vEnd.replace(".", "").replace(",", ""), 10))) {
				_err(locale.text("auth.gSegmentsConfig.err.title"), locale.text("auth.gSegmentsConfig.err.msg.expectedNumber", [locale.text("auth.gSegmentsConfig.label_valend"), vEnd]));
				return;
			}
			segs.push(segInfo);
		}
		data.articleSelection.$gauge.segments = segs;
		authPropsGeneral.notifyChangePropUI($$parent, sel, data);
	});

	$$parent.append($$panel);
}

function _destroySlider($$parent, prop) {
	var $$slider = $$parent.find('input.s-m-auth-g-range');
	if ($$slider.length > 0 && $$slider.slider) {
		$$slider.slider('destroy');
	}
}



function _getModuleProperties($$elmt, controller, props, sel, data) {

	if (_isGaugeValuePropertyType(data.type)) {

		var isGauge;

		if (data.articleSelection.$numDisplay) {
			isGauge = data.articleSelection.$numDisplay === "gauge";
		} else {
			// set $numDisplay article value if not set
			isGauge = data.articleSelection.$gauge ? true : false;
			data.articleSelection.$numDisplay = isGauge ? "gauge" : "normal";
		}

		props.push(_properties.numDisplay);

		// push gauge authoring properties according to article values
		if (isGauge) {

			if (!data.articleSelection.$gSetBorderValues) {
				// set the value of "gSetBorderValues" property
				if (data.articleSelection.$gauge.$bindMax) {
					data.articleSelection.$gSetBorderValues = typeof data.articleSelection.$gauge.$bindMax == "string" ? "bind" : "value";
				} else {
					data.articleSelection.$gSetBorderValues = "default";
				}
			}

			// add "gSetBorderValues" property
			props.push(_properties.gSetBorderValues);

			// if "gSetBorderValues" is not "default"
			// add "gBorderValues" properties
			if (data.articleSelection.$gSetBorderValues !== "default") {
				props.push(_properties.gBorderValues);
			}

			// add "gSegmentsNumber" property
			props.push(_properties.gSegmentsNumber);

			// add segments if necessary
			if (data.articleSelection.$gauge.segments && data.articleSelection.$gauge.segments.length > 0) {
				for (var ii = 0, jj = data.articleSelection.$gauge.segments.length; ii < jj; ii++) {
					var name = "gSegmentsConfig" + ii;
					_properties[name] = {
						"default": "",
						createMarkup: _createMarkupGSegmentsConfig,
						type: "child-child",
						destroyMarkup: _destroySlider,
						label: locale.text("auth.gSegmentsConfig", [(ii + 1)]),
						segIdx: ii,
						name: name
					};
					props.push(_properties[name]);
				}
				props.push(_properties.gSegmentsConfigApply);
			}
		}
	}
}

function _isGaugeValuePropertyType(type) {
	if (type.indexOf("integer") >= 0 || type.indexOf("real") >= 0 || type.indexOf("decimal") >= 0 || type.indexOf("quantity") >= 0) {
		return true;
	}
	return false;
}
exports.initModuleProperties = function(dest) {
	authPropsGeneral.initProperties(_properties, dest);
};
exports.getModuleProperties = _getModuleProperties;