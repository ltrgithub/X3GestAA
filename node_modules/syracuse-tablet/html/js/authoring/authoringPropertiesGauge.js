"use strict";

var locale = require('syracuse-tablet/html/js/helpers/locale');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var authoringPropertiesGeneral = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');

var _err = authoringPropertiesGeneral.err;
var maxSegments = 5;

var _properties = {
	/*
	 *	Display numeric data either as normal number field or as gauge
	 */
	"numDisplay": {
		"key": "$numDisplay",
		"default": "normal",
		values: [{
			value: "normal"
		}, {
			value: "gauge"
		}],
		createMarkup: authoringPropertiesGeneral.createMarkupRadio,
		refreshMarkup: authoringPropertiesGeneral.refreshMarkupRadio
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Sets gauge range (min/max) values origin. Either "default", "bind", or "value"
	 *	- default : gauge component default range values
	 *	- bind : use one field value as range value
	 *	- value : user specified directly range values in input field
	 */
	"gSetBorderValues": {
		"key": "$gSetBorderValues",
		"default": "default",
		values: [{
			value: "default"
		}, {
			value: "value"
		}, {
			value: "bind"
		}],
		createMarkup: authoringPropertiesGeneral.createMarkupRadio,
		refreshMarkup: authoringPropertiesGeneral.refreshMarkupRadio,
		type: "child"
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Set border values (min/max). It will be either a textarea or a selector
	 */
	"gBorderValues": {
		"default": "",
		createMarkup: _createMarkupGBorderValues,
		type: "child"
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Number of gauge segmets
	 */
	"gSegmentsNumber": {
		"default": "",
		createMarkup: _createMarkupGSegmentsNumbers,
		type: "child"
	},

	/*
	 *	Authoring property used for gauge numeric display authoring.
	 *	Configure gauge segments
	 */
	"gSegmentsConfig": {
		"default": "",
		createMarkup: _createMarkupGSegmentsConfig,
		type: "child",
		destroyMarkup: _destroySlider
	}
};


function initProperties() {
	var pre = "auth";
	Object.keys(_properties).forEach(function(prop) {
		var lk = pre + "." + prop;
		var p = _properties[prop];
		if (p.label == null) {
			p.label = locale.text(lk);
		}
		p.name = prop;
		if (p.values) {
			p.values.forEach(function(v, idx) {
				if ($.isPlainObject(v)) {
					var vk = lk + "." + ("" + v.value);
					if (v.label == null) {
						v.label = locale.text(vk);
					}
				} else {
					p.values[idx] = {
						label: v + "",
						valu: v
					};
				}
			});
		}
	});
}

function _setNumDisplayConfig(data, props) {
	initProperties();

	if (data.type === "integer" || data.type === "real" || data.type === "decimal") {

		var isGauge;

		if (data.articleSelection.$numDisplay) {
			isGauge = data.articleSelection.$numDisplay === "gauge";
		} else {
			// set $numDisplay article value if not set
			isGauge = data.articleSelection.$gauge ? true : false;
			data.articleSelection.$numDisplay = isGauge ? "gauge" : "normal";
		}

		props.push(_properties.numDisplay);

		// push gauge authoring properties according to article values
		if (isGauge) {

			if (!data.articleSelection.$gSetBorderValues) {
				// set the value of "gSetBorderValues" property
				if (data.articleSelection.$gauge.$bindMax) {
					data.articleSelection.$gSetBorderValues = typeof data.articleSelection.$gauge.$bindMax == "string" ? "bind" : "value";
				} else {
					data.articleSelection.$gSetBorderValues = "default";
				}
			}

			// add "gSetBorderValues" property
			props.push(_properties.gSetBorderValues);

			// if "gSetBorderValues" is not "default"
			// add "gBorderValues" properties
			if (data.articleSelection.$gSetBorderValues !== "default") {
				props.push(_properties.gBorderValues);
			}

			// add "gSegmentsNumber" property
			props.push(_properties.gSegmentsNumber);

			// add segments if necessary
			if (data.articleSelection.$gauge.segments && data.articleSelection.$gauge.segments.length > 0) {
				props.push(_properties.gSegmentsConfig);
			}
		}
	}
}


function _createMarkupGBorderValues($$parent, prop, sel, data) {
	var ctx = {};
	ctx.label_apply = locale.text("auth.g.label_apply");
	var idMin = "s-m-auth-g-borders-min";
	var idMax = "s-m-auth-g-borders-max";

	// markup depends if border is value or bind
	var isProperty = data.articleSelection.$gSetBorderValues === "bind" ? true : false;

	// if property, build a selection markup, filled with numeric types within the prototype
	if (isProperty) {
		var valMin = data.articleSelection.$gauge.$bindMin;
		var valMax = data.articleSelection.$gauge.$bindMax;

		ctx.label_tip = locale.text("auth.gBorderValues.label_tip.property");
		ctx.label_min = locale.text("auth.gBorderValues.label_min.property");
		ctx.label_max = locale.text("auth.gBorderValues.label_max.property");

		// get number properties from prototype
		var optionsMin = [];
		var optionsMax = [];
		if (data.control.controller.prototype && data.control.controller.prototype.json && data.control.controller.prototype.json.$properties) {
			$.each(data.control.controller.prototype.json.$properties, function(bind, value) {
				if ((value.$type.indexOf("integer") >= 0 || value.$type.indexOf("decimal") >= 0 || value.$type.indexOf("real") >= 0) && bind !== data.control.$bind && bind !== data.articleSelection.$bind) {
					optionsMin.push({
						option_value: bind,
						selected: valMin === bind
					});
					optionsMax.push({
						option_value: bind,
						selected: valMax === bind
					});
				}
			});

			ctx.markupMin = authHtml.execute("gaugeSelect", {
				id: idMin,
				options: optionsMin
			});

			ctx.markupMax = authHtml.execute("gaugeSelect", {
				id: idMax,
				options: optionsMax
			});
		} else {
			_err(locale.text("auth.gBorderValues.err.prototype.title"), locale.text("auth.gBorderValues.err.prototype.msg"));
			return;
		}

	}

	// if input, build input markup
	else {
		var valMin, valMax;
		// set valMin considering that user switched from "property" to "input"
		if (data.articleSelection.$gauge.$bindMin && typeof data.articleSelection.$gauge.$bindMin == "string") {
			valMin = data.control.controller.dao.data[data.articleSelection.$gauge.$bindMin];
		} else {
			valMin = data.articleSelection.$gauge.$bindMin;
		}

		// set valMax considering that user switched from "property" to "input"
		if (data.articleSelection.$gauge.$bindMax && typeof data.articleSelection.$gauge.$bindMax == "string") {
			valMax = data.control.controller.dao.data[data.articleSelection.$gauge.$bindMax];
		} else {
			valMax = data.articleSelection.$gauge.$bindMax;
		}

		ctx.label_tip = locale.text("auth.gBorderValues.label_tip.input");
		ctx.label_min = locale.text("auth.gBorderValues.label_min.input");
		ctx.label_max = locale.text("auth.gBorderValues.label_max.input");
		ctx.markupMin = authHtml.execute("gaugeBorderInput", {
			id: idMin,
			value: valMin
		});
		ctx.markupMax = authHtml.execute("gaugeBorderInput", {
			id: idMax,
			value: valMax
		});
	}

	var html = authHtml.execute("authPanelPropertyGBorderValues", ctx);
	var $$panel = $(html);

	// /!\ In bind, allow use of 0
	// onclick, update data and refresh
	$("button", $$panel).on("click", function(e) {
		var err = false;
		var vvMin = $(e.target).parent().find("#" + idMin).val();
		var vvMax = $(e.target).parent().find("#" + idMax).val();
		var errTitle = locale.text("auth.gBorderValues.err.title");

		// min and max are both numbers
		if (!isNaN(parseInt(vvMin), 10) && !isNaN(parseInt(vvMax), 10)) {

			if (vvMax < vvMin) {
				err = _err(errTitle, locale.text("auth.gBorderValues.err.msg.lowerMax", [vvMax, vvMin]));
			}
			// else, all good. update value
		} else {

			// min and max should both be string values
			if (!(typeof vvMin == "string" && typeof vvMax == "string")) {
				err = _err(errTitle, locale.text("auth.gBorderValues.err.msg.bothString", [vvMin, vvMax]));
			}

			// if min and max are supposed to be numbers
			if (!isProperty) {
				err = _err(errTitle, locale.text("auth.gBorderValues.err.msg.expectedNumbers", [vvMin, vvMax]));
			}

			if (vvMin === vvMax) {
				err = _err(errTitle, locale.text("auth.gBorderValues.err.msg.samebind"));
			}

			// TODO maybe another control ?

			// else, all good. update value
		}

		if (!err) {
			data.articleSelection.$gauge.$bindMin = vvMin;
			data.articleSelection.$gauge.$bindMax = vvMax;
			authoringPropertiesGeneral.notifyChangePropUI($$parent, sel, data);
		}
	});

	// append html
	$$parent.append($$panel);
}


function _createMarkupGSegmentsNumbers($$parent, prop, sel, data) {
	// build html
	var value = data.articleSelection.$gauge.segments ? data.articleSelection.$gauge.segments.length : "";
	var options = [];
	for (var ii = 0, jj = (maxSegments + 1); ii < jj; ii++) {
		var opt = {};
		if (ii == 0) {
			opt.option_value = locale.text("auth.gSegmentsNumber.default");
			opt.selected = value ? true : false;
		} else {
			opt.option_value = ii;
			opt.selected = value == ii;
		}
		options.push(opt);
	}
	var ctx = {
		value: authHtml.execute("gaugeSelect", {
			id: "s-m-auth-g-segnumbers-txt",
			options: options
		}),
		label_apply: locale.text("auth.g.label_apply")

	};

	var html = authHtml.execute("authPanelPropertyGSegmentsNumber", ctx);
	var $$panel = $(html);


	// bind click on apply button
	// onclick, update data and refresh
	$("button", $$panel).on("click", function(e) {

		var vv = $(e.target).prev().val();

		if (value != vv) {
			if (vv && isNaN(parseInt(vv, 10))) {
				_err(locale.text("auth.gSegmentsNumber.err.title"), locale.text("auth.gSegmentsNumber.err.msg.expectedNumber", [vv]));
			} else {
				if (vv) {
					data.articleSelection.$gauge.segments = data.articleSelection.$gauge.segments || [];
					if (data.articleSelection.$gauge.segments.length > vv) {
						data.articleSelection.$gauge.segments.splice(vv);
					}
					for (var ii = 0, jj = vv; ii < jj; ii++) {
						data.articleSelection.$gauge.segments[ii] = data.articleSelection.$gauge.segments[ii] || {};
					}
				} else {
					data.articleSelection.$gauge.segments = null;
				}
				authoringPropertiesGeneral.notifyChangePropUI($$parent, sel, data);
			}
		}
	});

	// append html
	$$parent.append($$panel);
}

function _createMarkupGSegmentsConfig($$parent, prop, sel, data) {

	// build html
	var tabs = [];
	var segs = data.articleSelection.$gauge.segments;

	for (var ii = 0, jj = segs.length; ii < jj; ii++) {

		var segInfo = {};
		segInfo.id = "s-m-auth-seg-" + ii;
		segInfo.title = locale.text("auth.gSegmentsConfig.label_segment", [(ii + 1)]);

		segInfo.label_valstart = locale.text("auth.gSegmentsConfig.label_valstart");
		segInfo.value_valstart = segs[ii].valStart;

		segInfo.label_valend = locale.text("auth.gSegmentsConfig.label_valend");
		segInfo.value_valend = segs[ii].valEnd;

		segInfo.label_propstart = locale.text("auth.gSegmentsConfig.label_propstart");
		segInfo.value_propstart = authHtml.execute("authPanelCardMinSizeSliderControlWithOutput", {
			id: segInfo.id + "propStart",
			min: 0,
			max: 1,
			step: 0.1,
			value: segs[ii].propStart
		});

		segInfo.label_propend = locale.text("auth.gSegmentsConfig.label_propend");
		segInfo.value_propend = authHtml.execute("authPanelCardMinSizeSliderControlWithOutput", {
			id: segInfo.id + "propEnd",
			min: 0,
			max: 1,
			step: 0.1,
			value: segs[ii].propEnd
		});

		segInfo.label_color = locale.text("auth.gSegmentsConfig.label_color");
		segInfo.value_color = segs[ii].color;

		tabs.push(segInfo);
	}

	var html = authHtml.execute("gaugeSegments", {
		tabs: tabs,
		label_apply: locale.text("auth.g.label_apply")
	});
	var $$panel = $(html);

	// set nav tabs width
	var navTabs = $("ul.nav.nav-pills li", $$panel);
	var width = navTabs.length === 1 ? "100%" : Math.round(1000 * 100 / navTabs.length) / 1000 + "%";
	$.each(navTabs, function(idx, val) {
		$(val).width(width);
	});

	/*
	 *	Bind events
	 */
	// generate slider
	var $$rangeInputArr = $("input.s-m-auth-g-range", $$panel);
	$$rangeInputArr.slider();
	// update range output value
	$$rangeInputArr.on("slide", function(slideEvt) {
		var $$input = $(slideEvt.target);
		var $$output = $$input.next();
		$$output.text(slideEvt.value);
	});


	// update active tab style
	navTabs.on("click", function(e) {
		var navs = $("ul.nav.nav-pills li", $$parent);
		navs.toggleClass("active", false);
		$(e.target).toggleClass("active", true);
	});

	// bind click on apply button
	// onclick, update data and refresh
	$("button", $$panel).on("click", function(e) {
		var segs = [];
		var tabs = $(".tab-pane", $$parent);
		for (var ii = 0, jj = tabs.length; ii < jj; ii++) {
			var $$tab = $(tabs[ii]);
			var id = $$tab.attr("id");
			var segInfo = {};
			segInfo.valStart = $("#" + id + "-valstart", $$tab).val();
			segInfo.valEnd = $("#" + id + "-valend", $$tab).val();
			segInfo.propStart = $("#" + id + "propStart", $$tab).val();
			segInfo.propEnd = $("#" + id + "propEnd", $$tab).val();
			segInfo.color = $("#" + id + "-color", $$tab).val();

			// if valStart, valEnd, propStart, propEnd, color value == "", set it to null 
			// this is necessary to comply with the gauge ctrl behavior
			segInfo.valStart = segInfo.valStart === "" ? null : segInfo.valStart;
			segInfo.valEnd = segInfo.valEnd === "" ? null : segInfo.valEnd;
			segInfo.propStart = segInfo.propStart === "" ? null : segInfo.propStart;
			segInfo.propEnd = segInfo.propEnd === "" ? null : segInfo.propEnd;
			segInfo.color = segInfo.color === "" ? null : segInfo.color;

			// check if valStart and valEnd are numeric values
			var vStart = segInfo.valStart;
			var vEnd = segInfo.valEnd;
			if (vStart && isNaN(parseInt(vStart.replace(".", "").replace(",", ""), 10))) {
				_err(locale.text("auth.gSegmentsConfig.err.title"), locale.text("auth.gSegmentsConfig.err.msg.expectedNumber", [locale.text("auth.gSegmentsConfig.label_valstart"), vStart]));
				return;
			}
			if (vEnd && isNaN(parseInt(vEnd.replace(".", "").replace(",", ""), 10))) {
				_err(locale.text("auth.gSegmentsConfig.err.title"), locale.text("auth.gSegmentsConfig.err.msg.expectedNumber", [locale.text("auth.gSegmentsConfig.label_valend"), vEnd]));
				return;
			}

			segs.push(segInfo);
		}

		data.articleSelection.$gauge.segments = segs;
		authoringPropertiesGeneral.notifyChangePropUI($$parent, sel, data);
	});

	$$parent.append($$panel);
}

function _destroySlider($$parent, prop) {
	var $$slider = $$parent.find('.s-m-auth-g-slider');
	if ($$slider.length > 0 && $$slider.slider) {
		$$slider.slider('destroy');
	}
}

exports.setNumDisplayConfig = _setNumDisplayConfig;