"use strict";

var locale = require('syracuse-tablet/html/js/helpers/locale');
var modal = require('syracuse-tablet/html/js/ui/modals/modal');

/*
 *
 * Simple article validation module
 *
 */


exports.validateJSON = function(fullPage, jsonText, properties) {
	var obj;
	try {
		if ($.isPlainObject(jsonText)) {
			obj = jsonText;
		} else if (jsonText != null && jsonText.length > 0) {
			obj = JSON.parse(jsonText);
		} else {
			throw new Error("Unexpected bad JSONtext");
		}

		var errors = _validate(fullPage, obj, properties);
		if (errors.length > 0) {
			var text = "\n" + errors.join("\n");
			modal.error(locale.text("auth.panel.save_error_title"), {
				message: locale.text("auth.panel.save_error_json"),
				detail: text
			});
		} else {
			return obj;
		}
	} catch (e) {
		modal.error(locale.text("auth.panel.save_error_title"), {
			message: locale.text("auth.panel.save_error_json"),
			detail: e
		});
	}
};

/*
 * display $items and $article nodes at the end of JSON
 */
exports.toSortedJSON = function(obj) {
	var toJSON = function() {
		var self = this;
		var that = {};
		var $items;
		var $article;

		Object.keys(self).forEach(function(key) {
			if (key === "$items") {
				$items = self[key];
			} else if (key === "$article") {
				$article = self[key];
			} else {
				that[key] = self[key];
			}
		});
		if ($article) {
			that.$article = $article;
		}
		if ($items) {
			that.$items = $items;
		}
		return that;
	};
	// Step one: Hook property ordering
	JSON.stringify(obj,
		function replacer(key, value) {
			if ($.isPlainObject(value)) {
				value.toJSON = toJSON;
			}
			return value;
		});
	// Build json
	var str = JSON.stringify(obj, null, " ");
	return str;
};

/*
 * fullPage: true = article is an object describing a full page so also nesting constraints can be checked
 * fullPage: false = article is an object describing a control or container so nesting constraints cannot be fully checked
 * article: Article object
 */
function _validate(fullPage, article, properties) {

	var errors = [];
	try {
		_checkNode(fullPage, null, article, properties, errors);
	} catch (e) {
		errors.push(e.message);
	}
	return errors;
};

var _propertiesToCheck = {
	$layoutType: _checkLayoutType,
	$rowHeight: _checkRowHeight,
	$bgColor: _checkBgColor,
	$size: _checkTileSize,
	$widthXs: _checkCellSize,
	$widthSm: _checkCellSize,
	$widthMd: _checkCellSize,
	$widthLg: _checkCellSize
};

function _checkNode(fullPage, parent, node, properties, errors) {

	Object.keys(_propertiesToCheck).forEach(function(key) {
		if (node[key] !== undefined) {
			_propertiesToCheck[key](fullPage, parent, node, key, properties, errors);
		}
	});

	var children;
	if (node.$items) {
		children = node.$items;
	} else if (node.$article) {
		children = [node.$article];
	}
	if (children) {
		children.forEach(function(child) {
			_checkNode(fullPage, node, child, properties, errors);
		});
	}
}

function _checkLayoutType(fullPage, parent, node, key, properties, errors) {
	var type = node.$layoutType;
	var ptype = parent && parent.$layoutType;
	var known = ["stack", "row", "cell", "hub", "hubGroup", "tile"];
	if (known.indexOf(type) < 0) {
		errors.push(locale.text("auth.err.unknown.layout", [type]));
		return;
	}
	if (!fullPage) {
		return;
	}
	switch (type) {
		case "hub":
			if (parent != null) {
				errors.push(locale.text("auth.err.hub.notroot"));
			}
			break;
		case "hubGroup":
			if (ptype != "hub") {
				errors.push(locale.text("auth.err.hubgroup.nohub"));
			}
			break;
		case "tile":
			if (ptype != "hubGroup") {
				errors.push(locale.text("auth.err.tile.nohubgroup"));
			}
			break;
	}
}

function _checkRowHeight(fullPage, parent, node, key, properties, errors) {
	var value = node[key];
	if (!value.match(/^[0-9]+px$/)) {
		errors.push(locale.text("auth.err.rowheight", [value]));
	}
}

function _checkBgColor(fullPage, parent, node, key, properties, errors) {
	var value = node[key];

	var valid = properties.tileColor.values.map(function(e) {
		return e.value;
	});
	if (valid.indexOf(value) < 0) {
		errors.push(locale.text("auth.err.bgColor", [key, valid.join(", "), value]));
	}
}

function _checkCellSize(fullPage, parent, node, key, properties, errors) {
	var value = +node[key];
	if (!(value >= 1 && value <= 12)) {
		errors.push(locale.text("auth.err.cellSize", [key, value]));
	}
}

function _checkTileSize(fullPage, parent, node, key, properties, errors) {
	var value = node[key];
	var valid = properties.tileSize.values.map(function(e) {
		return e.value;
	});

	if (valid.indexOf(value) < 0) {
		errors.push(locale.text("auth.err.tileSize", [valid.join(", "), value]));
	}
}