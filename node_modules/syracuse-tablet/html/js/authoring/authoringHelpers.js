"use strict";

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var pageBase = require('syracuse-tablet/html/js/pages/pageBase');
var utils = require('syracuse-tablet/html/js/helpers/utils');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var authoringSData = require('syracuse-tablet/html/js/authoring/authoringSData');
var authProps = require('syracuse-tablet/html/js/authoring/authoringProperties');
var authHtml = require('syracuse-tablet/html/js/authoring/authoringHtml');
var authVal = require('syracuse-tablet/html/js/authoring/authoringVal');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');
var uiutils = require('syracuse-tablet/html/js/ui/uiUtils');
var authCommons = require('syracuse-tablet/html/js/authoring/authoringCommons');
var modules = require('syracuse-tablet/html/js/common/modules');
var metaDataCache = require('syracuse-tablet/html/js/sdata/cache/metaDataCache');

var _openPanels = [];

exports.triggerResizeInternal = function(opts) {
	uiutils.triggerResizeInternal(opts);
};

exports.selectElement = function(sel) {
	$(".s-m-auth-selected").removeClass("s-m-auth-selected");
	var $$elmt = $("#" + sel.id, $("#s-m-app-id"));
	var domItem = $$elmt[0];
};

/*
 * Find control instance from DOM element
 */
exports.findControl = function($$ctrl) {
	return modules.get("controller").findControlByDom($$ctrl);
};

exports.getSelectionById = function(id) {
	var $$item = $("#s-m-app-id #" + id);
	if ($$item.length <= 0) {
		return null;
	}
	return {
		$$elmt: $$item,
		id: id
	};
};

exports.getSelectionData = function(sel) {
	if (!sel || !sel.id) {
		return null;
	}
	var article = $.extend(true, {}, authCommons.getCurrentPage().getArticle());

	var title;
	var type;
	var page;

	var control = exports.findControl(sel.$$elmt);
	if (control && !control.isLayout()) {
		title = control.prototype && control.prototype.data("$title");
		if (title) {
			title += " (" + control.$bind + ")";
		} else {
			title = control.$bind;
		}
		type = control.typeName;
	} else if (control) {
		title = locale.text("auth.label_layout");
		type = control.typeName;
	} else if (sel.$$elmt.hasClass("s-m-page")) {
		page = pageBase.findPage(sel.id);
	}
	// If no control it means that it's a page authring
	// -> we pass the authoring of the page not cloned like for controls to be able to manage authoring properties for the page
	var articleSelection = (control && control.getArticle()) || authCommons.getCurrentPage().getArticle();
	return {
		articlePage: article,
		articleSelection: articleSelection,
		title: title,
		type: type,
		control: control,
		page: page
	};
};

var _PropertyPanel = function($$parent) {
	this.$$parent = $$parent;
	// For properties that are not objects
	this.destroyHandlers = [];
	this.propInstances = [];
	this.destroy = function() {
		// First
		this.destroyHandlers.forEach(function(h) {
			if (h) h();
		});
		this.propInstances.forEach(function(p) {
			if (p.destroyMarkup) p.destroyMarkup();
		});
		this.destroyHandlers = this.propInstances = null;
		// Second
		if (this.$$parent) {
			this.$$parent.empty();
		}
	};
	this.addDestroyHandler = function($$content, prop) {
		this.destroyHandlers.push(jsutils.bindFn(prop.destroyMarkup, null, $$content, prop));
	};
	this.addPropInstance = function(prop) {
		this.propInstances.push(prop);
	};
};
// sm.auth.articlechange.ui
exports.createPropertyPanel = function($$parent, sel, data) {
	var props = authProps.getProperties(sel, data);
	if (!props) {
		return;
	}
	var propertyPanel = new _PropertyPanel($$parent);
	var $$accord = $('<div class="panel-group" id="accordion" role="tablist" aria-multiselectable="true">');
	var id;
	var num = 0;
	var toDestroy = [];
	var article = sel.articleSelection;
	var topButtons = [];
	props.forEach(function(prop) {
		id = "auth_prop_" + prop.name;
		var expanded = false;
		if (prop.createMarkup) {
			var $$block = $(
				authHtml.execute("authPanelPropertyGroup", {
					id: id,
					expanded: expanded,
					label: prop.label,
					type: prop.type || "default"
				}));
			var $$content = $('#collapse_' + id, $$block);
			prop.createMarkup($$content, prop, sel, data);
			if ($.isPlainObject(prop) && prop.destroyMarkup) {
				propertyPanel.addDestroyHandler($$content, prop);
			} else if (prop.constructor) {
				propertyPanel.addPropInstance(prop);
			}
			if (prop.isHidden === true) {
				$$block.hide();
			}
		} else if (prop.createButtonMarkup) {
			// Add button at the top of property panel
			topButtons.unshift(prop);
		} else {
			if (prop.applyMarkup) {
				prop.applyMarkup($$accord, prop, sel, data);
			} else if (prop.isSeparatror) {
				var $$block = $(
					authHtml.execute("authPanelPropertySeperator", {
						id: id,
						expanded: expanded,
						label: prop.label,
						type: prop.type || "default"
					}));
			}
		}
		$$accord.append($$block);
		num++;
	});
	topButtons.forEach(function(prop) {
		notifications.publish("sm.auth.top.button", "add", prop);
	});
	$$parent.append($$accord);
	// Expand all collapsible saved into _openPanels (all levels - see cahrts authoring)
	_openPanels.forEach(function(id) {
		$$parent.find("#" + id).collapse({
			toggle: true
		});
	});
	return propertyPanel;
};

exports.refreshPropertyPanels = function(sel, data) {
	var props = authProps.getProperties(sel, data);
	if (!props) {
		return;
	}
	props.forEach(function(prop) {
		if (prop.refreshMarkup) {
			var id = "#collapse_auth_prop_" + prop.name;
			var $$panel = $(id);
			prop.refreshMarkup($$panel, prop, sel, data);
		}
	});
};

exports.savePanelStates = function() {
	// Saved all expanded collapsibles (all levels - see cahrts authoring)
	_openPanels = [];
	$(".collapse.in", "#authPanelControlSimple").each(function() {
		_openPanels.push($(this).attr("id"));
	});
};
exports.getPageVariants = function(page) {
	return authoringSData.getPageVariants(page.getAuthoringName());
};
exports.getPageViews = function(page) {
	return authoringSData.getPageViews(page.getAuthoringFullName());
};
exports.saveAuthoring = function(page, opts) {
	var isCreation;
	var _views;
	var _variants;
	var _variant;
	var segs = page.getAuthoringName().split(".");

	return $.smResolve()
		.then(function() {
			var pageData = {
				application: segs[0],
				contract: segs[1],
				representation: segs[2],
				facet: segs[3],

				roles: [],
				users: [],
				endpoints: [],

				saveAsOption: opts.variantType,

				variantCode: opts.code,
				variantTitle: opts.title,
				variantDescription: opts.description,

				article: opts.article,
				variant: opts.uuid
			};
			if (pageData.saveAsOption === "personal_copy") {
				pageData.users.push({
					$uuid: authCommons.getCurrentUserUuid()
				});
			};
			return authoringSData.savePageDefinition(pageData);
		})
		.then(function(variant) {
			_variant = variant;
			return exports.getPageVariants(page);
		})
		.then(function(variants) {
			_variants = variants;
			return exports.getPageViews(page);
		})
		.then(function(views) {
			_views = views;
			return _updatePageMetaData(page, _variant, _variants, _views, opts.article);
		});
};
exports.getPropertiesVariants = function(page) {
	var propertiesVariants = [],
		properties = {},
		viewSelected, isPersonal, self = this;
	var views = page.pageData.page.$views || [];
	if (!views || !views.length || !page.variants || page.variants.length === 0) {
		return propertiesVariants;
	}
	viewSelected = $.smFind(views, function(view) {
		return view.$selected;
	});
	page.variants.forEach(function(variant) {
		isPersonal = (!variant.$factory &&
			(!variant.roles || !variant.roles.length) &&
			(!variant.endpoints || !variant.endpoints.length) &&
			(variant.users && variant.users.length === 1));
		properties = {
			description: variant.description,
			isFactory: variant.$factory,
			isPersonal: isPersonal,
			isGlobal: (!variant.$factory && !isPersonal),
			title: variant.title,
			code: variant.code,
			comment: variant.comment,
			factoryOwner: variant.$factoryOwner,
			uuid: variant.$uuid,
			isSelected: viewSelected != null && viewSelected.$url && viewSelected.$url.indexOf(variant.$uuid) > -1
		};
		propertiesVariants.push(properties);
	});
	return propertiesVariants;
};

exports.getPropertiesCurrentVariant = function(page) {
	var properties = {};
	var views = page.pageData.page.$views || [];
	if (!views || !views.length || !page.variants || !page.variants.length) {
		return properties;
	}
	var viewSelected = $.smFind(views, function(view) {
		return view.$selected;
	});
	if (!viewSelected) {
		return properties;
	}
	var variantSelected = $.smFind(page.variants, function(variant) {
		if (viewSelected.$url.indexOf(variant.$uuid) > -1) {
			return true;
		};
		return false;
	});
	if (!variantSelected) return properties;
	var isPersonal = (!viewSelected.$isFactory && !variantSelected.roles.length && !variantSelected.endpoints.length && variantSelected.users.length === 1);
	/* Be carefull : shared are not managed !!!
	 * shared is when !viewSelected.isFactory && (viewSelected.roles.length!=0 || viewSelected.roles.length!=0 || viewSelected.endpoints.users.length> 1
	 */
	properties = {
		description: viewSelected.$description,
		isFactory: viewSelected.$isFactory,
		isPersonal: isPersonal,
		isGlobal: (!viewSelected.$isFactory && !isPersonal),
		title: viewSelected.$title,
		url: viewSelected.$url,
		code: variantSelected.code,
		comment: variantSelected.comment,
		factoryOwner: variantSelected.$factoryOwner,
		uuid: variantSelected.$uuid
	};
	return properties;
};

exports.rebuildArticleByPageStruct = function(page, states) {

	function _copyLocNode(uuid) {
		Object.keys($localization).forEach(function(lang) {
			var texts = $localizationNew[lang] = $localizationNew[lang] || {};
			texts[uuid] = $localization[lang][uuid];
		});
	}

	function _findLocMatch(text) {
		var oldTexts = $localization[curLang] || {};
		var match;
		Object.keys(oldTexts).some(function(uuid) {
			if (oldTexts[uuid] === text) {
				match = uuid;
				return true;
			}
			return false;
		});
		return match;
	}

	function _checkLocalization(nodeArticle) {
		var propsPerNode = ["$title"];
		propsPerNode.forEach(function(key) {
			var text = nodeArticle[key];
			if (nodeArticle.$theme === "advanced") {
				/*
				the title of "advanced" stack is wrongly stored as translated text (because of previous authoring).
				The goal of this hack is to clean the article.
				Can be removed for avengers version (after Laurent will do the authoring with his hack).
				*/
				text = "";
				nodeArticle[key] = "";
			}
			if (text) {
				var uuid = text.match(/\{\@(\S+)\}/);
				if (uuid && uuid[1]) { // text is already a placeholder, just copy to new structure
					_copyLocNode(uuid[1]);
				} else {
					uuid = _findLocMatch(text);
					if (!uuid) { // Create new ID or keep existing key (modify value only)
						var keepKey = nodeArticle.keepKey ? nodeArticle.keepKey.match(/\{\@(\S+)\}/) : null;
						uuid = keepKey ? keepKey[1] : utils.UUID();
						if (keepKey) {
							_copyLocNode(uuid);
							delete(nodeArticle.keepKey);
						}
						var texts = $localizationNew[curLang] = $localizationNew[curLang] || {};
						texts[uuid] = text;
					} else {
						_copyLocNode(uuid);
					}
					nodeArticle[key] = "{@" + uuid + "}";
				}
			}
		});
	}

	function _walkNode(article, node) {
		var nodeArticle = node.getAuthArticle();
		_checkLocalization(nodeArticle);
		if (states) {
			var state = node.getAuthState(nodeArticle.$isDirty || {});
			if (state) {
				var path = node.getPathInTree();
				path = path.join(".");
				states[path] = state;
			}
		}
		// Remove dirty flags
		delete nodeArticle.$isDirty;
		Object.keys(nodeArticle).forEach(function(key) {
			article[key] = nodeArticle[key];
		});

		if (node.isVignette()) {
			var page = node.getTopPage();
			if (page) { // Page is set if content of vignette is not a link
				var rootLayout = page.rootLayout;
				article.$article = {};
				_walkNode(article.$article, rootLayout);
			}
		} else {
			if (!node.excludeChildrenFromAuthoring() &&
				node.children && node.children.length > 0) {
				article.$items = [];
				node.children.forEach(function(child) {
					var childArticle = {};
					article.$items.push(childArticle);
					_walkNode(childArticle, child);
				});
			}
		}
	}
	var curLang = locale.getCurrentLocale();
	var rootLayout = page.rootLayout;
	var $localization = page.getArticle() && page.getArticle().$localization || {};
	var $localizationNew = {};
	var jsonArticlePage = {};

	_authCopyPageProperties(page, jsonArticlePage);

	_walkNode(jsonArticlePage, rootLayout);

	jsonArticlePage.$localization = $localizationNew;

	var articleJSON = authVal.toSortedJSON(jsonArticlePage);
	return articleJSON;
};

/**
 * Authoring properties of a page
 */
function _authCopyPageProperties(page, dst) {
	if (!page.isSData()) {
		return;
	}
	var src = page.getArticle();
	if (!src || !dst) return;
	var _authPageProps = ["$pageActionSettings"];
	if (page.isStateLessMode()) {
		_authPageProps.push("$allowDownload");
	}
	_authPageProps.forEach(function(p) {
		if (src[p] != null || (dst[p] != null && src[p] == null)) {
			dst[p] = src[p];
		}
	});
};

//Add views fetched from server to views from meta data
//ensure the selected flag of view from meta data is set to new list of views
function _updatePageMetaData(page, variant, variants, views, article) {
	//Update live page object
	// Make the view we just saved also the selected one in meta data
	variant && variant.variantId && views.forEach(function(view) {
		view.$selected = !!(view.$url && view.$url.indexOf(variant.variantId) > -1);
	});
	page.pageData.page.$views = views;
	page.variants = variants;
	var pageName = page.getAuthoringFullName();
	return metaDataCache.putArticle(pageName, article, views);
}