"use strict";

var authUtils = require('syracuse-tablet/html/js/authoring/authoringPropertiesGeneral');
var authoringPropertiesArrays = require('syracuse-tablet/html/js/authoring/arrays/authoringPropertiesArrays');
var authoringPropertiesGauge = require('syracuse-tablet/html/js/authoring/authoringPropertiesGauge');
var fontUtils = require('syracuse-tablet/html/js/ui/fontUtils');

var _modules = [authoringPropertiesArrays, authoringPropertiesGauge];

var _canBeEmpty = function(typ) {
	switch (typ) {
		case "integer":
		case "real":
		case "decimal":
		case "quantity":
		case "boolean":
			return false;
		default:
			return true;
	}
};
var _ctrlFieldsProperties = {
	"checkBoxDisplayAs": {
		"key": "$displayAs",
		"default": "icon",
		"values": [{
			"value": "icon"
		}, {
			"value": "text"
		}],
		createMarkup: authUtils.createMarkupRadio
	},
	/*
	 * Title hidden
	 */
	"isTitleHidden": {
		"key": "$isTitleHidden",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: authUtils.createMarkupRadio,
		type: "default" // Default, just for header color selection
	},
	/*
	 * Hide if empty value
	 */
	"hideIfEmpty": {
		"key": "$hideIfEmpty",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: authUtils.createMarkupRadio
	},
	/*
	 * Is signature
	 */
	"isSignature": {
		"key": "$isSignature",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: authUtils.createMarkupRadio
	},
	/*
	 * scale
	 */
	"imgScale": {
		"key": "$imgScale",
		"default": "original",
		"values": [{
			"value": "original"
		}, {
			"value": "small"
		}, {
			"value": "medium"
		}, {
			"value": "large"
		}],
		createMarkup: authUtils.createMarkupRadio
	},
	/*
	 * Is GPS
	 */
	"scanGPS": {
		"key": "$scanGPS",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: authUtils.createMarkupRadio
	},

	/*
	 * Barcode scanning
	 */
	"scanBarcode": {
		"key": "$scanBarcode",
		"default": false,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: authUtils.createMarkupRadio
	},

	/* 
	 * Position of label
	 * left:   <label> <value>
	 *
	 * top:    <label>
	 * 		   <value>
	 */
	"labelPosition": {
		"key": "$labelPosition",
		"default": "left",
		"values": [{
			"value": "left"
		}, {
			"value": "top"
		}],
		createMarkup: authUtils.createMarkupRadio
	},

	/* 
	 * Text alignment of label and values
	 * Wee keep $labelAlign for compatibility
	 */
	"labelAlign": {
		"key": "$labelAlign",
		"default": "left",
		"values": [{
			"value": "left"
		}, {
			"value": "center"
		}, {
			"value": "right"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	},

	/* 
	 * Theme for control
	 */
	"theme": {
		"key": "$theme",
		"default": "none",
		"values": [{
			"value": "none"
		}, {
			"value": "largetitle"
		}],
		createMarkup: authUtils.createMarkupRadio,
		toggleTheme: function($$elmt, theme) {
			this.removeTheme($$elmt, theme);
			this.addTheme($$elmt, theme);
		},
		removeTheme: function($$elmt, theme) {
			var e = $$elmt.get(0);
			if (!e.className || e.className.indexOf("s-m-theme") === -1) return;
			var newClassName = [];
			e.className.split(" ").forEach(function(c) {
				if (c && !c.smStartsWith("s-m-theme")) {
					newClassName.push(c);
				}
			});
			if (e.className.length === 0) return;
			e.className = newClassName.join(' ');
		},
		addTheme: function($$elmt, theme) {
			if (!theme || theme === "none") return;
			$$elmt.addClass("s-m-theme-" + theme);
		}
	},

	/*
	 * Reference field description position
	 * bottom: <value>
	 *         <desc>
	 *
	 * right:  <value> <desc>
	 * left:   <desc> <value>
	 *
	 * top:    <desc>
	 *         <value>
	 */
	"refDescPosition": {
		"key": "$refDescPosition",
		"default": "right",
		"values": [{
			"value": "bottom"
		}, {
			"value": "right"
		}, {
			"value": "left"
		}, {
			"value": "top"
		}, {
			"value": "none"
		}],
		createMarkup: authUtils.createMarkupRadio
	},

	/*
	 * Reference field description format
	 * desc:      <desc>
	 *         
	 * title:     <title>

	 * desctitle: <desc> - <title>
	 * -> If both values are equal, skip display of second value
	 * 
	 * titledesc: <title> - <desc>
	 * -> If both values are equal, skip display of second value
	 */
	"refDescFormat": {
		"key": "$refDescFormat",
		"default": "desc",
		"values": [{
			"value": "desc"
		}, {
			"value": "title"
		}, {
			"value": "desctitle"
		}, {
			"value": "titledesc"
		}],
		createMarkup: authUtils.createMarkupRadio
	},
	/*
	 * Show/hide reference field value display mode only
	 */
	"refValueDisplay": {
		"key": "$refValueDisplay",
		"default": true,
		"values": [{
			"value": true
		}, {
			"value": false
		}],
		createMarkup: authUtils.createMarkupRadio
	},
	// only CLOB field (text plain, text html, text rtf)
	"textHeight": {
		"key": "$textHeight",
		"default": "medium",
		values: [{
			value: "small"
		}, {
			value: "medium"
		}, {
			value: "large"
		}, {
			value: "xlarge"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	},
	"emptyImageIcon": {
		"key": "$emptyImageIcon",
		"default": fontUtils.getEmptyImageDefIcon(),
		"values": fontUtils.getEmptyImageIconList(),
		createMarkup: authUtils.createMarkupIconPicker,
		destroyMarkup: authUtils.destroyMarkupIconPicker
	},
	"emptyIconSize": {
		"key": "$emptyIconSize",
		"default": "small",
		values: [{
			value: "small"
		}, {
			value: "medium"
		}, {
			value: "large"
		}, {
			value: "xlarge"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	},
	"urlIcon": {
		"key": "$urlIcon",
		"default": fontUtils.getUrlDefIcon(),
		"values": fontUtils.getUrlIconList(),
		createMarkup: authUtils.createMarkupIconPicker,
		destroyMarkup: authUtils.destroyMarkupIconPicker
	},
	"urlIconSize": {
		"key": "$urlIconSize",
		"default": "small",
		values: [{
			value: "small"
		}, {
			value: "medium"
		}, {
			value: "large"
		}, {
			value: "xlarge"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	},
	"imgHeight": {
		"key": "$imgHeight",
		"default": "small",
		values: [{
			value: "xsmall"
		}, {
			value: "small"
		}, {
			value: "medium"
		}, {
			value: "large"
		}, {
			value: "xlarge"
		}],
		createMarkup: authUtils.createMarkupRadio,
		refreshMarkup: authUtils.refreshMarkupRadio
	}
};

exports.initModuleProperties = function(dest) {
	// Init fields properties
	authUtils.initProperties(_ctrlFieldsProperties, dest);
	// Init other type of fields properties
	_modules.forEach(function(module) {
		module.initModuleProperties(dest);
	});
};
exports.getModuleProperties = function($$elmt, controller, props, sel, data) {
	var isField = sel.$$elmt.is(".s-m-control.s-m-field");
	var isArray = sel.$$elmt.is(".s-m-control.s-m-array");
	if (isField || (isArray && !controller.dataset.root.prototype.isQueryLikeFacet())) {
		props.push(_ctrlFieldsProperties.isTitleHidden);
		var labelPosition = true,
			alignment = true;
		if (authUtils.getValueOrDefault(_ctrlFieldsProperties.isTitleHidden, sel, data)) {
			labelPosition = false;
		} else if (authUtils.getValueOrDefault(_ctrlFieldsProperties.labelPosition, sel, data) !== "top") {
			alignment = false;
		}
		if (isArray) {
			labelPosition = false;
		}
		if (labelPosition) {
			props.push(_ctrlFieldsProperties.labelPosition);
		}
		if (alignment) {
			props.push(_ctrlFieldsProperties.labelAlign);
		}
	} else if (sel.$$elmt.is(".s-m-control.s-m-chart-array")) {
		// To deal with title
		props.push(_ctrlFieldsProperties.isTitleHidden);
	}
	// ctrlFieldBase
	if (isField) {
		if (_canBeEmpty(data.type)) {
			props.push(_ctrlFieldsProperties.hideIfEmpty);
		}
		props.push(_ctrlFieldsProperties.theme);
		if (data.type === "boolean") {
			props.push(_ctrlFieldsProperties.checkBoxDisplayAs);
		}
		// Properties for reference fields only 
		if (data.type === "reference") {
			if (!controller.isEditMode()) {
				props.push(_ctrlFieldsProperties.refValueDisplay);
			}
			props.push(_ctrlFieldsProperties.refDescFormat);
			props.push(_ctrlFieldsProperties.refDescPosition);
		}
		// Properties for enriched text fields only (html, plain, rtf)
		if (data.type === "rtf" || data.type === "html" || data.type === "plain") {
			props.push(_ctrlFieldsProperties.textHeight);
		}
		if (data.type === "image") {
			props.push(_ctrlFieldsProperties.emptyImageIcon, _ctrlFieldsProperties.emptyIconSize, _ctrlFieldsProperties.imgHeight);
			if (controller.isEditMode()) {
				props.push(_ctrlFieldsProperties.imgScale, _ctrlFieldsProperties.isSignature);
			}
		}
		if (data.type === "string" && data.control && data.control.cssType === "s-m-url") {
			props.push(_ctrlFieldsProperties.urlIcon, _ctrlFieldsProperties.urlIconSize);
		}
		if (controller.isEditMode()) {
			if (data.control.getNativeCapabilityAuthoring("GPS") != null) {
				props.push(_ctrlFieldsProperties.scanGPS);
			}
			if (data.control.getNativeCapabilityAuthoring("scanBarcode") != null) {
				props.push(_ctrlFieldsProperties.scanBarcode);
			}
		}
		// Properties for numeric field
		authoringPropertiesGauge.getModuleProperties($$elmt, controller, props, sel, data);
	} else if (isArray) {
		if (data.control.$display === "separator") {
			props.push(_ctrlFieldsProperties.theme);
		}
		// ctrlFieldArray
		authoringPropertiesArrays.getModuleProperties($$elmt, controller, props, sel, data);
	}
};

exports.toggleTheme = function($$elmt, theme) {
	if (!$$elmt) return;
	return _ctrlFieldsProperties.theme.toggleTheme($$elmt, theme);
};