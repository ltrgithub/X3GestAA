"use strict";

var utils = require('syracuse-tablet/html/js/helpers/utils');
var environment = require('syracuse-tablet/html/js/helpers/environment');
var modules = require('syracuse-tablet/html/js/common/modules');
var locale = require('syracuse-tablet/html/js/helpers/locale');

var _id = 1;
var _stacks = {};
var _mainStack;

/**
 * This class manages a stack of pages and does all what is needed to go back and do cleanups etc
 * There is one stack for the application (the global one) and also one stack per vignette
 *  
 */
var NavigationPageStack = utils.defineClass(function NavigationPageStack($$elmt) {
	this.id = String(_id++);
	this.$$elmt = $$elmt;
	this.$$elmt.attr("data-nav-stack-id", this.id);

	_stacks[this.id] = this;
	// Unique id of stack items to be able to go back easily
	this._itemId = 1;

	this._pageStack = [];
	this._topPage = null; // Page currently visible
	this._isBusy = false;
}, null, {
	destroy: function() {
		this.$$elmt = null;
		delete _stacks[this.id];
		if (this._pageStack) {
			this._pageStack.forEach(function(page) {
				if (page.page) {
					page.page.destroy();
				}
			})
		}
		this._pageStack = null;
	},

	/**
	 * 
	 */
	getTopPage: function() {
		return this._topPage;
	},
	isEmpty: function() {
		return this.count() == 0;
	},
	count: function() {
		return this._pageStack == null ? 0 : this._pageStack.length;
	},
	/**
	 * Used to aqquire current top level page == page visible to the user
	 */
	_getTopStackItem: function() {
		if (this._pageStack.length > 0) {
			var stackItem = this._pageStack[this._pageStack.length - 1];
			return stackItem;
		}
	},
	/**
	 * Get all items in the stack
	 * Used to show the stack in form of the breadcrumbs for example
	 */
	getStackItems: function() {
		return this._pageStack;
	},

	/**
	 * Go back exactly one page
	 */
	goBack: function() {
		var prevPage = this._getPrevPageInHistory();
		if (prevPage) {
			return this.goBackToId(prevPage.id);
		}
		return $.smResolve();
	},
	/**
	 * Check if going back is possible at the moment
	 */
	canGoBack: function() {
		return this._getPrevPageInHistory() != null;
	},
	_getPrevPageInHistory: function() {
		var prevPage = null;
		var list = this._pageStack.slice();
		list.pop();
		while (!prevPage && list.length > 0) {
			prevPage = list.pop();
			if (prevPage.noHistory) {
				prevPage = null;
			}
		}
		return prevPage;
	},
	_popTopStackItem: function() {
		if (this._pageStack.length > 0) {
			var stackItem = this._pageStack[this._pageStack.length - 1];
			this._pageStack = this._pageStack.slice(0, -1);
			return stackItem;
		}
	},

	/**
	 * Go back to the stack item with the given id
	 */
	goBackToId: function(id) {
		var self = this;
		id = Number(id);
		if (isNaN(id)) {
			throw new Error("Bad id : Number expected")
		}

		function _closeTopPage(stackItem) {
			var close = $.Deferred()

			var page = stackItem.page;
			var step;
			if (page) {
				step = page.onBackAction();
			} else {
				step = $.smResolve(true);
			}
			var closeAllowed;
			step.then(function(_closeAllowed) {
					closeAllowed = _closeAllowed;
					if (!closeAllowed) {
						close.resolve(false);
						return;
					}
					// Remove page from stack
					self._popTopStackItem();
					return $.smResolve()
						.then(function() {
							if (page) {
								return page.hide();
							}
						})
						.then(function() {
							if (page) {
								return page.destroy();
							}
						})
						.then(function() {
							return _checkCurrent();
						});
				})
				.fail(function(e) {
					close.reject(e);
				})
				.then(function() {
					if (closeAllowed) {
						close.resolve(true);
					}
				});

			return close.promise();
		}

		function _checkCurrent() {
			return $.smResolve()
				.then(function() {
					var top = self._getTopStackItem();
					if (top != null && top.id !== id) {
						return _closeTopPage(top);
					} else if (top != null) {
						return self._activateTopPage();
					}
				});
		}

		return _checkCurrent();
	},
	_activateTopPage: function() {
		var self = this;
		var top = self._getTopStackItem();
		var getPage;
		if (top != null) {
			var cached = top.page != null;
			if (cached !== true) {
				getPage = modules.get("pageFactory").createPage(top.pageCreateData)
					.then(function(page) {
						top.page = page;
						return self._renderPage(page);
					});
			} else {
				getPage = $.smResolve(top.page);
			}
			return getPage
				.then(function(page) {
					self._topPage = top.page;
					return top.page.show(cached);
				})
				.then(function() {
					environment.getUnitTestMgr().notifPageLoaded("after", self._topPage);
				});
		} else {
			return $.smReject(locale.text("no.top.page"));
		}
	},
	_renderPage: function(page) {
		var self = this;
		return $.smResolve()
			.then(function() {
				self._topPage = page;

				// Tell the page where it has to render in
				page.set$$container(self.$$elmt);
				return page.build();
			})
			.then(function() {
				if (environment.isAutoUITestMode()) {
					environment.getUnitTestMgr().addPageData(page);
				}
			});
	},

	/**
	 * Push page will push a page to the navigation stack and render the page
	 * The previous page will be hidden (if going to a child page) or destroyed 
	 * 
	 * page: Page to push on the stack
	 * pageCreateData: Date that can be used by page factory to fully restore a previously opened page
	 * RESOLVE WITH the page
	 * 
	 */
	pushPage: function(page, pageCreateData) {
		var self = this;
		var first;
		if (!page) {
			return $.smResolve(null);
		}

		if (page.isRootPage()) {
			this._pageStack.forEach(function(stackItem) {
				if (stackItem.page) {
					stackItem.page.destroy();
				}
			});
			this._pageStack = [];
		}

		var prevStackItem = self._getTopStackItem();
		var prevPage = prevStackItem && prevStackItem.page;

		if (prevPage) {
			if (page.options.isChild) {
				first = $.smResolve()
					.then(function() {
						return prevPage.hide();
					});
			} else {
				first = $.smResolve()
					.then(function() {
						return prevPage.hide();
					})
					.then(function() {
						// Set saved context
						prevStackItem.pageCreateData.options.savedCtx = prevPage.savedCtxCreate();
						prevPage.destroy();
						prevStackItem.page = null; // this ensures page recreation when going back
					});
			}
		} else {
			first = $.smResolve();
		}

		return first
			.then(function() {
				self._itemId = self._itemId + 1;
				var item = {
					id: self._itemId,
					page: page,
					title: page.getPageTitle(),
					pageCreateData: pageCreateData,
					noHistory: page.isNoHistory(),
					pageType: self._pageType(page)
				};
				self._pageStack.push(item);
				if (self.manageBrowserHistory) {
					window.history.pushState(item.id, null, null);
				}
			})
			.then(function() {
				return self._renderPage(page);
			})
			.then(function() {
				return page.show();
			})
			.then(function() {
				return page;
			});
	},
	_pageType: function(page) {
		if (!page || !page.isSData()) return
		if (page.isHome()) return "home";
		if (page.isDashboard()) return "dashboard";
		if (page.isChartDetail()) return "chartDetail";
		return page.controller.getFacet();
	},
	/**
	 * 
	 */
	replaceCurrentPageData: function(page, callback) {
		var self = this;
		var topItem = self._getTopStackItem();
		topItem.page = page;

		var pageCreateData = topItem.pageCreateData;
		pageCreateData = callback(pageCreateData);
		topItem.pageCreateData = pageCreateData;

		topItem.title = page.getPageTitle();
	},

	setBusy: function(busy) {
		var old = this._isBusy;
		this._isBusy = busy;
		return old !== busy;
	},
	isBusy: function(busy) {
		return this._isBusy;
	},
	filterTopPage: function(filterCb) {
		for (var i = this._pageStack.length - 1; i >= 0; i--) {
			var page = this._pageStack[i] && this._pageStack[i].page;
			if (page && filterCb(page) === true) {
				return page;
			}
		}
	}
});

/**
 * Returns main page stack (full page pages)
 * 
 */
exports.getMainStack = function() {
	if (!_mainStack) {
		_mainStack = exports.getStackForElmt($("#s-m-app-id"));
		_mainStack.manageBrowserHistory = true;
	}
	return _mainStack;
};

/**
 * Returns a page stack by the DOM element the stack is used for
 * 
 */
exports.getStackForElmt = function($$elmt) {
	var id = $$elmt.attr("data-nav-stack-id");
	var stack;
	if (id) {
		stack = _stacks[id];
	}
	if (!stack) {
		stack = new NavigationPageStack($$elmt);
	}

	return stack;
}

/**
 * Go up the DOM and find next matching navigation stack
 */
exports.findClosest = function($$elmt) {
	var $$stack = $$elmt.closest("[data-nav-stack-id]");
	var id = $$stack.attr("data-nav-stack-id");
	if (id) {
		return _stacks[id];
	}
}