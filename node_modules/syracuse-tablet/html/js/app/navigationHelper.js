"use strict";

var jsutils = require('syracuse-tablet/html/js/helpers/jsutils');
var waiting = require('syracuse-tablet/html/js/utils/waiting');
var modules = require('syracuse-tablet/html/js/common/modules');
var environment = require('syracuse-tablet/html/js/helpers/environment');
var locale = require('syracuse-tablet/html/js/helpers/locale');
var helpers = require('syracuse-tablet/html/js/common/helpers');
var notifications = require('syracuse-tablet/html/js/helpers/notifications');

var protoHelpers = require('syracuse-tablet/html/js/sdata/protocolHelpers');
var metaDataCache = require('syracuse-tablet/html/js/sdata/cache/metaDataCache');
var sharedContext = require('syracuse-tablet/html/js/helpers/sharedContext');

/**
 * url (sdata): http://localhost:8124/mobile2/x3/erp/GX3APP/TABCUR?representation=TABCURM.$lookup
 * method: GET | SET
 * 
 * pageOptions: {
 *   isChild: ... // Open the page as a child of the current page (this means parent page is not destroyed but hidden in the DOM)
 *   
 *	 lookup: { // When url is a lookup, the control asking for the lookup adds this information so the lookup page can inject the selected value
 *	   controllerId: ...
 *	   controlId: ...
 *	   $bind: Name of property receiving the value picked in the lookup
 *     $lookupKeyName: Name of the property in a lookup item that will used as result
 *	},
 *
 *  childContext: { // For client or "detail" pages like row details or chart detail to give context of the parent
 *  	controllerId
 *  }
 * }
 * 
 * 
 * loadOptions:{
 * 		navStack: Instance of NavigationPageStack to push the page on.
 *           If null, the application's main stack is used
 *			 Setting a non standard stack is used to navigate in vignettes
 * 
 * 		noError: Do not show error modal on page loading issues, should be used by vignettes  
 * 		firstPage: true if the application is trying to open a dedicated page when  at start (url param in query string) 
 * 		noRedirectOnError: avoid infinite loop in case of error
 * }
 * RESOLVES WITH PAGE OR NULL
 * 
 * 
 * Urls supported:
 * http://.../mobile2/... sdata pages
 * child://pageName sdata based page that fulls depends on the controller of a parent (e.g. row detail)
 * 
 * html://pageName Full client side page
 *
 * contextId://<uuid> Server side stored context identified by uuid
 * context://<contextString> String describing the context of the app (contextString is what is returned by server when using contextId)
 *
 */
exports.gotoUrl = function(url, method, pageOptions, loadOptions) {
	// Only allow one navigation at a time
	loadOptions = loadOptions || {};
	var navStack = loadOptions.navStack || modules.get("navStack").getMainStack();

	var changedToBusy = navStack.setBusy(true);
	if (!changedToBusy) {
		// There is already a navigation going on
		return $.smResolve(null);
	}

	if (method == null) {
		try {
			var parsedUrl = jsutils.parseURL(url);
			var $method = parsedUrl && parsedUrl.query && parsedUrl.query.$method;
			if ($method) {
				method = $method;
			}
		} catch (e) {
			// ignore
		}
	}
	var deferred = $.Deferred();
	var checkRestoreContext;
	if (url.indexOf("contextId://") === 0) { // server side stored context (for emails, sending links)
		checkRestoreContext = _fetchContext(url.substr(12))
			.then(function(contextPageData) {
				if (!contextPageData) {
					return $.smReject(helpers.createDiag(null, "error", locale.text("invalid.link")));
				}
				url = contextPageData.$url;
				method = contextPageData.$method;
				pageOptions = contextPageData.pageOptions;
				loadOptions = {};
			})
	} else if (url.indexOf("context://") === 0) { // client side stored context for mobile app resume in native environment
		checkRestoreContext = $.smResolve()
			.then(function() {
				var contextPageData;
				try {
					contextPageData = JSON.parse(decodeURIComponent(url.substr(10)));
				} catch (e) {}
				if (!contextPageData) {
					return $.smReject(helpers.createDiag(null, "error", locale.text("invalid.link")));
				}
				url = contextPageData.$url;
				method = contextPageData.$method;
				pageOptions = contextPageData.pageOptions;
				loadOptions = {};
			});
	} else {
		checkRestoreContext = $.smResolve();
	}

	var pageCreateData = {};
	checkRestoreContext.then(function() {
			// Temp: Redirect home to local home dashboard
			if (url.toLowerCase().indexOf("html://home") >= 0) {
				pageCreateData.name = "HOME";
			} else if (url.toLowerCase().indexOf("html://mock") >= 0) {
				url = protoHelpers.getLocalDashboardUrl('MOCK');
				pageCreateData.name = "MOCK";
			} else if (url.indexOf("{$hostPort}") === 0) {
				// Used by unit tests (local)
				url = url.replace("{$hostPort}", protoHelpers.getHostPort());
			}
			// pageCreateData is a simple object that should contain all information
			// that is needed to restore a page on history back or context restore
			pageCreateData.options = $.extend(true, {}, pageOptions);
			pageCreateData.url = url;
			pageCreateData.method = method;

			// Pre check step is there to check if we really want to navigate
			// this can be anything like checking if a mobile app is valid or has to be installed first
			// if precheck returns false, navigation is stopped silently
			return _checkNavigation(url, method);
		})
		.then(function(okToNavigate) {
			if (okToNavigate === true) {
				if (environment.isAutoUITestMode()) {
					environment.getUnitTestMgr().notifPageLoaded("before");
				}
				var loadingPromise = modules.get("pageFactory").createPage(pageCreateData);
				return waiting.waitModal(loadingPromise, loadOptions.$$waitParent)
			} else {
				return null;
			}
		})
		.then(function(newPage) {
			if (!newPage || newPage.destroyed === true) {
				//Page can be destroyed before being displayed (multiple back in dashboards)
				return null;
			}
			return navStack.pushPage(newPage, pageCreateData)
		})
		.then(function(page) {
			if (environment.isAutoUITestMode()) {
				environment.getUnitTestMgr().notifPageLoaded("after", page);
			}
			notifications.publish("sm.navigated.to.page", page);
			deferred.resolve(page)
		})
		.always(function() {
			if (changedToBusy) { // Only set to idle if we set no busy by or self
				navStack.setBusy(false);
			}
		})
		.fail(function(error) {
			if (loadOptions.noError !== true) {
				modules.get("modal")
					.asynchError(null, error)
					.always(function() {
						deferred.resolve(null);
						if (loadOptions.noRedirectOnError == true) {
							return;
						}
						var target = "html://home";
						var pageOptions = {};
						var method = "GET";
						if (error && error.unauthenticated) {
							target = "html://login";
						} else if (loadOptions.firstPage === true) {
							// The url provided can be wrong so we try to go to home dashboard
							// -> Before checking offline
							target = "html://home";
						} else if (error && error.offline) {
							// Avoid blank page
							target = "html://login";
							pageOptions.offline = true;
						} else {
							target = "html://home";
						}
						if (target) {
							// noRedirectOnError to avoid infinite loop if an other error occurs in gotoUrl
							exports.gotoUrl(target, method, pageOptions, {
								noRedirectOnError: true
							});
						}
					})
			} else {
				deferred.reject(error);
			}
		});
	return deferred.promise();

};

/**
 * 
 * @param url
 * @param method
 * @returns
 */
function _checkNavigation(url, method) {
	return $.smResolve()
		.then(function() {
			var currentPage = modules.get("navStack").getMainStack().getTopPage();
			var parsedUrl = jsutils.parseURL(url);
			return currentPage ? currentPage.onGotoUrlAction(false, parsedUrl) : $.smResolve(true);
		}).then(function(kontinue) {
			if (kontinue === false) {
				// Stop navigation
				return false;
			}
			try {
				var parsed = jsutils.parseURL(url);
				if (parsed && parsed.query) {
					var appName;
					if (parsed.query.representation === "mobileApplication.$details") {
						appName = protoHelpers.getKeyFromUrl(url);
					} else if (parsed.query.$mobileApplication) {
						appName = parsed.query.$mobileApplication;
					}
					var endpoint = parsed.query.$mobileEndpoint;
					if (appName && endpoint) {
						return _checkMobileApplication(appName, endpoint);
					}
				}
			} catch (Exception) {
				return true;
			}
		})
		.then(function(okToNavigate) {
			// Null means true
			return okToNavigate !== false;
		});
}


function _checkMobileApplication(appName, endpoint) {
	return $.smResolve()
		.then(function() {
			return metaDataCache.tryGetApp(appName, endpoint);
		})
		.then(function(appData) {
			if (appData === null) { // Not installed
				return _installMobileApplication(appName, endpoint);
			} else {
				return _updateMobileApplication(appName, endpoint, appData);
			}
		});
}

function _installMobileApplication(appName, endpoint) {
	var installConfirmed = true;
	return $.smResolve()
		.then(function() {
			if (installConfirmed) {
				return metaDataCache.installApp(appName, endpoint).then(function() {
					return true;
				});
			} else {
				// No install, no navigation
				return false;
			}
		});
}


function _updateMobileApplication(appName, endpoint, appData) {
	var updateConfirmed = true;
	return $.smResolve()
		.then(function() {
			return metaDataCache.isAppUpToDate(appData, endpoint);
		})
		.then(function(isUpToDate) {
			if (isUpToDate) {
				return true;
			}
			if (updateConfirmed) {
				return metaDataCache.installApp(appName, endpoint).then(function() {
					return true;
				});
			} else {
				// No update, still we can navigate to old version
				return true;
			}
		});
}

function _fetchContext(uuid) {
	return sharedContext.readSharedContext(uuid)
		.then(function(context) {
			return context && sharedContext.createPageLoadDataFromContext(context);
		});
}