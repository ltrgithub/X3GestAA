"use strict";

// Generate a part of a unit test for the patching system
// only considers text files with extension *.txt and binary files with extension *.bin
// record a unit test: 
// use some local git repository without *.txt and *.bin files. Perform some changes (add/delete/modify
// text files with extension .txt and binary files with extension .bin), stage the changes and run
// this program directly from _node using 2 parameters: first parameter must be name of test, the second must be a short description
// (only characters A-Z, a-z, 0-9, and _ allowed). This will be used for the commit comment and for the generated patch file within the 
// 'fixtures' directory.
// In the end, invoke the program with second parameter being 'END'. This writes a cleanup procedure into the test script.

var exec = require('child_process').exec;
var fs = require('streamline-fs');
var crypto = require('crypto');
var util = require('util');
var path = require('path');
var patchcreate = require("syracuse-patch/lib/patchcreate");
var patchtools = require("syracuse-patch/lib/patchtools");
var tracer; // = console.log;

// execute a command line

function execute(cmdline, callback) {
	exec(cmdline, function(error, stdout, stderr) {
		if (error !== null) {
			callback(error);
		}
		if (stderr) {
			tracer && tracer('STDERR: ' + stderr);
		}
		callback(null, stdout);
	});
}

/// perform a GIT commit of the current changes and write file of difference

function gitcommit(patchfile, _) {
	// there must be changes to commit, and all changed files must be staged
	var gitStatus = execute('git status', _);
	tracer && tracer("git status");
	if (gitStatus.indexOf('# Changed but not updated') > 0 || gitStatus.indexOf('# Changes not staged for commit') > 0) {
		tracer && tracer("Please stage files");
		process.exit(1);
	}
	if (gitStatus.indexOf('nothing to commit') > 0 || gitStatus.indexOf('nothing added to commit') > 0) {
		tracer && tracer("Nothing to commit");
		process.exit(2);
	}
	/// hash code of current commit
	var hashOld = execute('git log -1 --pretty=format:%H', _);
	hashOld = hashOld.replace(/\W/g, "");

	/// commit changes
	execute('git commit -m "Commit ' + process.argv[3] + '"', _);
	tracer && tracer("git commit");

	/// hash code of new commit
	var hash = execute('git log -1 --pretty=format:%H', _);
	hash = hash.replace(/\W/g, "");

	/// comparison
	var diff = execute('git diff --irreversible-delete --binary --unified=0 --no-color ' + hashOld + ' ' + hash, _);
	var lines = diff.split(/[\r\n]+/);
	var target = [];
	patchcreate.shrink(target, lines);
	fs.writeFile(patchfile, target.join("\n"), "utf8", _);
	tracer && tracer("git diff");

}

// search all .txt and .bin files within directory and return their relative names and SHA1 checksums in an object 

function makehash(directory, _) {
	var output = {};
	hashDir(directory, "", output, null, _);
	return output;
}

exports.makehash = makehash;

// search all .txt and .bin files within directory and compare their existence and SHA1 checksums with the object in 2nd parameter (usually generated by makehash)

function testhash(directory, expectedOutput, _) {
	var errors = [];
	hashDir(directory, "", expectedOutput, errors, _);
	for (var name in expectedOutput) {
		errors.push("File " + name + " has not been created");
	}
	return errors.join("; ");
}

exports.testhash = testhash;

// searches a directory recursively and either collects SHA1 checksums or mismatches

function hashDir(start, directory, output, errors, _) {
	var files = fs.readdir(start + directory, _);
	for (var i = 0; i < files.length; i++) {
		if (files[i] === ".checksums") // exclude checksums file
			continue;
		var name = directory + "/" + files[i];
		if (fs.stat(start + name, _).isDirectory()) {
			if (!/\.git$/.exec(name)) hashDir(start, name, output, errors, _);
		} else {
			if (/\.(?:txt|bin)$/.exec(name)) {
				var buffer = fs.readFile(start + name, _);
				if (/\.(?:txt)$/.exec(name)) {
					var text = buffer.toString('utf8');
					text = text.replace(/\r?\n/g, "\n");
					buffer = new Buffer(text, "utf8");
				}
				var shasum = crypto.createHash('sha1');
				shasum.update(buffer);
				var digest = shasum.digest('hex');
				if (errors !== null) {
					if (!(name in output)) {
						errors.push("File " + name + " does not exist");
					} else if (output[name] !== digest) {
						errors.push("Wrong checksum in file " + name + " >" + output[name] + "< >" + digest + "<");
					}
					delete output[name];
				} else {
					output[name] = digest;
					tracer && tracer("output " + name + " = " + digest);
				}
			}
		}
	}
}

function main(_) {
	if (!process.argv[2] || !process.argv[3] || !/^\w+$/.exec(process.argv[2]) || !/^\w+$/.exec(process.argv[3])) {
		tracer && tracer("No or wrong argument specified. Arguments: 1. file name without extension and 2. test name or END (to write cleanup code). Only upper/lower case letters, digits, underscore allowed");
		process.exit(3);
	}

	// file for corresponding unit test
	var outputfile = path.normalize(__dirname + path.sep + ".." + path.sep + "server" + path.sep + process.argv[2] + "._js");
	var patchfile = process.argv[2] + '_' + process.argv[3] + '.patch';
	// 	full path of patch file
	var patchfileFull = path.normalize(__dirname + path.sep + patchfile);

	if (patchtools.exists(patchfileFull, _)) {
		tracer && tracer("Output file " + patchfile + " already exists");
		process.exit(4);
	}

	if (!patchtools.exists(outputfile, _)) {
		var text = [
			'"use strict";',
			'var module = QUnit.module;',
			'var patch = require("syracuse-patch/lib/integrate");',
			'var unit = require("syracuse-patch/test/fixtures/unit");',
			'var fs = require("streamline-fs");',
			'module("patch");',
			'',
			'asyncTest("start", 0, function(_) { fs.mkdir("patchunittest", _); start(); })',
			'',
			''
		];

		fs.writeFile(outputfile, text.join("\n"), "utf8", _);
		tracer && tracer("Write header of test file");
	}

	if (process.argv[3] === "END") {
		fs.appendFile(outputfile, 'asyncTest("end", 0, function(_) { unit.rmdirRec("patchunittest", _); start(); })\n', "utf8", _);
		tracer && tracer("Write end of test file");
	} else {
		gitcommit(patchfileFull, _);
		var output = makehash(".", _);
		var text = [
			'asyncTest("' + process.argv[3] + '", 1, function(_) {',
			'	patch.normalPatch("patchunittest", __dirname+"/../fixtures/' + patchfile + '", {}, _);',
			'	var errors = unit.testhash("patchunittest", ' + util.format(output) + ', _);',
			'	strictEqual(errors, "");',
			'	start(); });',
			'',
			''
		];
		fs.appendFile(outputfile, text.join("\n"), "utf8", _);
		tracer && tracer("Write test " + process.argv[3]);
	}
}

if (require.main === module) {
	main(function(err) {
		if (err) throw err;
	});
}

/// delete directory recursively
exports.rmdirRec = function(path, _) {
	if (!fs.exists(path, _)) return;
	var files = fs.readdir(path, _);

	/* Loop through and delete everything in the sub-tree after checking it */
	for (var i = 0; i < files.length; i++) {
		var currFile = fs.lstat(path + "/" + files[i], _);

		if (currFile.isDirectory()) // Recursive function back to the beginning
			exports.rmdirRec(path + "/" + files[i], _);

		else // Assume it's a file - perhaps a try/catch belongs here?
			fs.unlink(path + "/" + files[i], _);
	}
	return fs.rmdir(path, _);
};