
// Generate a part of a unit test for the patching system
// only considers text files with extension *.txt and binary files with extension *.bin
// record a unit test: 
// use some local git repository without *.txt and *.bin files. Perform some changes (add/delete/modify
// text files with extension .txt and binary files with extension .bin), stage the changes and run
// this program directly from _node using 2 parameters: first parameter must be name of test, the second must be a short description
// (only characters A-Z, a-z, 0-9, and _ allowed). This will be used for the commit comment and for the generated patch file within the 
// 'fixtures' directory.
// In the end, invoke the program with second parameter being 'END'. This writes a cleanup procedure into the test script.


var exec = require('child_process').exec
var fs = require('fs');
var crypto = require('crypto');
var util = require('util');
var path = require('path');
var write = require("syracuse-patch/lib/write")

// execute a command line
function execute(cmdline, callback) {
	exec(cmdline, function(error, stdout, stderr) {
		if (error !== null) {
			callback(error);
		}
		if (stderr) {
			console.log('STDERR: '+stderr);
		}
		callback(null, stdout);
	});
}

/// perform a GIT commit of the current changes and write file of difference
function gitcommit(patchfile, _) {
	// there must be changes to commit, and all changed files must be staged
	var gitStatus = execute('git status', _);
	console.log("git status");
	if (gitStatus.indexOf('# Changed but not updated') > 0 || gitStatus.indexOf('# Changes not staged for commit') > 0) {
		console.log("Please stage files");
		process.exit(1);
	}
	if (gitStatus.indexOf('nothing to commit') > 0 || gitStatus.indexOf('nothing added to commit') > 0) {
		console.log("Nothing to commit");
		process.exit(2);
	}
	/// hash code of current commit
	var hashOld = execute('git log -1 --pretty=format:%H', _);
	hashOld = hashOld.replace(/\W/g, "");
	
	/// commit changes
	execute('git commit -m "Commit '+process.argv[3]+'"', _);
	console.log("git commit");
	
	/// hash code of new commit
	var hash = execute('git log -1 --pretty=format:%H', _);
	hash = hash.replace(/\W/g, "");
	
	/// comparison
	var diff = execute('git diff --irreversible-delete --binary --unified=0 --no-color '+hashOld+' '+hash, _);
	fs.writeFile(patchfile, diff, "utf8", _);
	console.log("git diff");

}

// search all .txt and .bin files within directory and return their relative names and SHA1 checksums in an object 
function makehash(directory, _) {
	var output = {};
	hashDir(directory, "", output, null, _);
	return output;
}

exports.makehash = makehash;

// search all .txt and .bin files within directory and compare their existence and SHA1 checksums with the object in 2nd parameter (usually generated by makehash)
function testhash(directory, expectedOutput, _) {
	console.log("Expected "+util.format(expectedOutput))
	var errors = [];
	hashDir(directory, "", expectedOutput, errors, _);
	console.log("Expected2 "+util.format(expectedOutput))
	for (var name in expectedOutput) {
		errors.push("File "+name+" has not been created");
	}
	return errors.join("; ");
}
	
exports.testhash = testhash;

// searches a directory recursively and either collects SHA1 checksums or mismatches
function hashDir(start, directory, output, errors, _) {
	console.log("HASHDIR "+start+"/"+directory)
	var files = fs.readdir(start+directory, _);
	for (var i = 0; i < files.length; i++) {
		if (files[i] === ".checksums") // exclude checksums file
			continue;
		var name = directory+"/"+files[i];
		if (fs.stat(start+name, _).isDirectory()) {
			if (!/\.git$/.exec(name))
				hashDir(start, name, output, errors, _);
		} else {
			if (/\.(?:txt|bin)$/.exec(name)) {
				var buffer = fs.readFile(start+name, _);
				if (/\.(?:txt)$/.exec(name)) {
					var text = buffer.toString('utf8');
					text = text.replace(/\r?\n/g, "\n");
					console.log("repl "+text);
					buffer = new Buffer(text, "utf8");
				}
				var shasum = crypto.createHash('sha1');
				shasum.update(buffer);
				var digest = shasum.digest('hex');
				if (errors !== null) {
					if (!(name in output)) {
						errors.push("File "+name+" does not exist");
					} else 
					if (output[name] !== digest) {
						errors.push("Wrong checksum in file "+name+" >"+output[name]+"< >"+digest+"<");
					}
					delete output[name];
				} else {
					output[name] = digest;
					console.log("output "+name+" = "+digest)
				}
			}
		}
	}
}

if (require.main === module) { // if invoked standalone: generate data and code for unit tests
	if (!process.argv[2] || !process.argv[3] || !/^\w+$/.exec(process.argv[2]) || !/^\w+$/.exec(process.argv[3])) {
		console.log("No or wrong argument specified. Arguments: 1. file name without extension and 2. test name or END (to write cleanup code). Only upper/lower case letters, digits, underscore allowed");
		process.exit(3);
	}
	
	// file for corresponding unit test
	var outputfile = path.normalize(__dirname + path.sep + ".." + path.sep + "server" + path.sep + process.argv[2] + "._js");
	var patchfile = process.argv[2]+'_'+process.argv[3]+'.patch';
	// 	full path of patch file
	var patchfileFull = path.normalize(__dirname + path.sep + patchfile); 


	if (write.exists(patchfileFull, _)) {
		console.log("Output file "+patchfile+ " already exists");
		process.exit(4);
	}

	if (!write.exists(outputfile, _)) {
		var text = [
		    'var module = QUnit.module;',
		    'var patch = require("syracuse-patch/lib/integrate");',
		    'var unit = require("syracuse-patch/test/fixtures/unit");',
		    'var fs = require("fs");',
		    'module("patch");',
		    '',
		    'asyncTest("start", 0, function(_) { fs.mkdir("patchunittest", _); start(); })',
		    '',
		    ''
		    ];
	
		fs.writeFile(outputfile, text.join("\n"), "utf8", _);
		console.log("Write header of test file");
	}

	if (process.argv[3] === "END") {
		fs.appendFile(outputfile, 'asyncTest("end", 0, function(_) { unit.rmdirRec("patchunittest", _); start(); })\n', "utf8", _);
		console.log("Write end of test file");
	} else {
		gitcommit(patchfileFull, _);
		var output = makehash(".", _);
		var text = [
		    'asyncTest("'+process.argv[3]+'", 1, function(_) {',
		    '	patch.patch("patchunittest", "node_modules/syracuse-patch/test/fixtures/'+patchfile+'", {}, _);',
		    '	var errors = unit.testhash("patchunittest", '+util.format(output)+', _);',
		    '	strictEqual(errors, "");',
		    '	start(); });',
		    '',
		    ''
		];
		fs.appendFile(outputfile, text.join("\n"), "utf8", _);
		console.log("Write test "+process.argv[3]);
	}
}

/// delete directory recursively
exports.rmdirRec = function(path, _) {
    var files;
    try {
        files = fs.readdir(path, _);
    } catch (err) {}

    /* Loop through and delete everything in the sub-tree after checking it */
    for(var i = 0; i < files.length; i++) {
        var currFile = fs.lstat(path + "/" + files[i], _);

        if(currFile.isDirectory()) // Recursive function back to the beginning
            exports.rmdirRec(path + "/" + files[i], _);

        else // Assume it's a file - perhaps a try/catch belongs here?
            fs.unlink(path + "/" + files[i], _);
    }
    return fs.rmdir(path, _);
};

