"use strict";
var integrate = require("syracuse-patch/lib/integrate");
var patchtools = require("syracuse-patch/lib/patchtools");
var fs = require('streamline-fs');
var unit = require("syracuse-patch/test/fixtures/unit");
// Test for recursive copy and checksum creation/checking.
// Warning: The unit tests are not independent of each other, the ordering is important. Changing one unit test may disturb others!

QUnit.module(module.id);

asyncTest("start", 0, function(_) {
	fs.mkdir("patchunittest", _);
	start();
});

// write a dummy patch file
// parameters: path path for file
// version1: start version (only patch number)
// version2: end version (only patch number)
// append: append to existing file
// frame: add X3 patch header/footer 
function writeDummyPatchFile(path, release1, version1, release2, version2, append, frame, _, streamlineConfig) {
	var contents = "syracuse patch " + release1 + " " + version1 + " 2013-03-2" + version2 + " " + release2 + " " + version2 + " aaaaaaaaaa" + version1 + " aaaaaaaaaa" + version2 + " ssss" + version2 + "\n";
	contents += "syracuse patchcomment comment" + version2 + "\n";
	if (streamlineConfig) {
		contents += 'syracuse streamline {"test":' + version2 + "}\n";
	}
	contents += "blabla " + version2 + "\n";
	if (frame) {
		contents = '2,"ASR","PATCH"\n' + contents + '7,"ASR","PATCH"\n';
	}
	if (append) fs.appendFile(path, contents, "utf8", _);
	else fs.writeFile(path, contents, "utf8", _);
}



asyncTest("collect files", 11, function(_) {
	// write some patch files
	fs.mkdir("patchunittest/" + patchtools.TEMP_DIRECTORY, _);
	var error = false;
	try {
		integrate.collectFiles("patchunittest", "patchunittest", "aaaaaaaaaa3", "aaaaaaaaaa2", _);
	} catch (e) {
		error = true;
		console.log("No patch content " + e);
	};
	strictEqual(error, true, "No patch content");

	writeDummyPatchFile("patchunittest/patch1.dat", 1, 0, 1, 1, false, false, _);
	writeDummyPatchFile("patchunittest/patch2.dat", 1, 1, 1, 2, false, true, _);
	writeDummyPatchFile("patchunittest/patch3.dat", 1, 3, 1, 4, false, true, _);
	writeDummyPatchFile("patchunittest/patch3.dat", 1, 2, 1, 3, true, true, _);
	writeDummyPatchFile("patchunittest/patch5.dat", 1, 6, 1, 8, true, true, _);
	var error = true;
	try {
		integrate.collectFiles("patchunittest", "patchunittest/patch1.dat", "aaaaaaaaaa3", "aaaaaaaaaa2", _);
		error = false;
	} catch (e) {};
	strictEqual(error, true, "patch file does not fit");
	strictEqual(integrate.collectFiles("patchunittest", "patchunittest/patch2.dat", "aaaaaaaaaa2", "aaaaaaaaaa1", _), "", "patch already integrated");
	strictEqual(integrate.collectFiles("patchunittest", "patchunittest/patch2.dat", "aaaaaaaaaa2", "aaaaaaaaaa0", _), "", "patch already integrated");
	strictEqual(integrate.collectFiles("patchunittest", "patchunittest/patch3.dat", "aaaaaaaaaa3", "aaaaaaaaaa2", _), "syracuse patch 1 3 2013-03-24 1 4 aaaaaaaaaa3 aaaaaaaaaa4 ssss4\nsyracuse patchcomment comment4\nblabla 4\n", "new patch, both fit");
	// var resultingPatchFile = fs.readFile("patchunittest/"+patchtools.TEMP_DIRECTORY+"/lastpatch.bbb", "utf8", _);
	// strictEqual(resultingPatchFile, "syracuse patch 1 3 2013-03-24 1 4 aaaaaaaaaa3 aaaaaaaaaa4\nsyracuse patchcomment comment4\nblabla 4\n", "correct file contents")
	strictEqual(integrate.collectFiles("patchunittest", "patchunittest/patch3.dat", "aaaaaaaaaa0", "aaaaaaaaaa3", _), "syracuse patch 1 3 2013-03-24 1 4 aaaaaaaaaa3 aaaaaaaaaa4 ssss4\nsyracuse patchcomment comment4\nblabla 4\n", "new patch, release fits");
	strictEqual(integrate.collectFiles("patchunittest", "patchunittest/patch3.dat", "aaaaaaaaaa3", "aaaaaaaaaa0", _), "syracuse patch 1 3 2013-03-24 1 4 aaaaaaaaaa3 aaaaaaaaaa4 ssss4\nsyracuse patchcomment comment4\nblabla 4\n", "new patch, current version fits");
	strictEqual(integrate.collectFiles("patchunittest", "patchunittest/patch3.dat", "aaaaaaaaaa2", "aaaaaaaaaa0", _), "syracuse patch 1 2 2013-03-24 1 4 aaaaaaaaaa2 aaaaaaaaaa4 ssss4\nsyracuse patchcomment comment4\nblabla 3\nblabla 4\n", "new patch, current version fits, integrate 2 patches");
	strictEqual(integrate.collectFiles("patchunittest", "patchunittest", "aaaaaaaaaa0", "aaaaaaaaaa7", _), "syracuse patch 1 0 2013-03-24 1 4 aaaaaaaaaa0 aaaaaaaaaa4 ssss4\nsyracuse patchcomment comment4\nblabla 1\nblabla 2\nblabla 3\nblabla 4\n", "new patch, all files in directory");
	strictEqual(integrate.collectFiles("patchunittest", "patchunittest", "aaaaaaaaaa6", "aaaaaaaaaa7", _), "syracuse patch 1 6 2013-03-28 1 8 aaaaaaaaaa6 aaaaaaaaaa8 ssss8\nsyracuse patchcomment comment8\nblabla 8\n", "new patch, last file");
	// test with given content
	var content = fs.readFile("patchunittest/patch3.dat", _).toString();
	strictEqual(integrate.collectFiles("patchunittest", null, "aaaaaaaaaa3", "aaaaaaaaaa2", _, content), "syracuse patch 1 3 2013-03-24 1 4 aaaaaaaaaa3 aaaaaaaaaa4 ssss4\nsyracuse patchcomment comment4\nblabla 4\n", "patch contents not from file");

	start();
});

asyncTest("collect files with streamline configuration", 11, function(_) {
	// write some patch files
	try {
		fs.mkdir("patchunittest/" + patchtools.TEMP_DIRECTORY, _);
	} catch (e) {
		console.log("Cannot create directory " + e);
	}
	writeDummyPatchFile("patchunittest/patch1.dat", 1, 0, 1, 1, false, false, _);
	writeDummyPatchFile("patchunittest/patch2.dat", 1, 1, 1, 2, false, true, _, true);
	writeDummyPatchFile("patchunittest/patch3.dat", 1, 3, 1, 4, false, true, _);
	writeDummyPatchFile("patchunittest/patch3.dat", 1, 2, 1, 3, true, true, _, true);
	writeDummyPatchFile("patchunittest/patch5.dat", 1, 6, 1, 8, true, true, _, true);
	var error = true;
	try {
		integrate.collectFiles("patchunittest", "patchunittest/patch1.dat", "aaaaaaaaaa3", "aaaaaaaaaa2", _);
		error = false;
	} catch (e) {};
	strictEqual(error, true, "patch file does not fit");
	strictEqual(integrate.collectFiles("patchunittest", "patchunittest/patch2.dat", "aaaaaaaaaa2", "aaaaaaaaaa1", _), "", "patch already integrated");
	strictEqual(integrate.collectFiles("patchunittest", "patchunittest/patch2.dat", "aaaaaaaaaa1", "aaaaaaaaaa0", _), "syracuse patch 1 1 2013-03-22 1 2 aaaaaaaaaa1 aaaaaaaaaa2 ssss2\nsyracuse patchcomment comment2\nsyracuse streamline {\"test\":2}\nblabla 2\n", "new patch with streamline configuration");

	strictEqual(integrate.collectFiles("patchunittest", "patchunittest/patch3.dat", "aaaaaaaaaa3", "aaaaaaaaaa2", _), "syracuse patch 1 3 2013-03-24 1 4 aaaaaaaaaa3 aaaaaaaaaa4 ssss4\nsyracuse patchcomment comment4\nblabla 4\n", "new patch without streamline configuration, both fit");
	// var resultingPatchFile = fs.readFile("patchunittest/"+patchtools.TEMP_DIRECTORY+"/lastpatch.bbb", "utf8", _);
	// strictEqual(resultingPatchFile, "syracuse patch 1 3 2013-03-24 1 4 aaaaaaaaaa3 aaaaaaaaaa4\nsyracuse patchcomment comment4\nblabla 4\n", "correct file contents")
	strictEqual(integrate.collectFiles("patchunittest", "patchunittest/patch3.dat", "aaaaaaaaaa0", "aaaaaaaaaa3", _), "syracuse patch 1 3 2013-03-24 1 4 aaaaaaaaaa3 aaaaaaaaaa4 ssss4\nsyracuse patchcomment comment4\nblabla 4\n", "new patch without streamline configuration, release fits");
	strictEqual(integrate.collectFiles("patchunittest", "patchunittest/patch3.dat", "aaaaaaaaaa3", "aaaaaaaaaa0", _), "syracuse patch 1 3 2013-03-24 1 4 aaaaaaaaaa3 aaaaaaaaaa4 ssss4\nsyracuse patchcomment comment4\nblabla 4\n", "new patch without streamline configuration, current version fits");
	strictEqual(integrate.collectFiles("patchunittest", "patchunittest/patch3.dat", "aaaaaaaaaa2", "aaaaaaaaaa0", _), "syracuse patch 1 2 2013-03-24 1 4 aaaaaaaaaa2 aaaaaaaaaa4 ssss4\nsyracuse patchcomment comment4\nsyracuse streamline {\"test\":3}\nblabla 3\nblabla 4\n", "new patch with streamline configuration, current version fits, integrate 2 patches");
	strictEqual(integrate.collectFiles("patchunittest", "patchunittest", "aaaaaaaaaa0", "aaaaaaaaaa7", _), "syracuse patch 1 0 2013-03-24 1 4 aaaaaaaaaa0 aaaaaaaaaa4 ssss4\nsyracuse patchcomment comment4\nsyracuse streamline {\"test\":3}\nblabla 1\nblabla 2\nblabla 3\nblabla 4\n", "new patch, all files in directory (2 streamline configurations)");
	writeDummyPatchFile("patchunittest/patch4.dat", 1, 4, 1, 5, false, true, _);
	strictEqual(integrate.collectFiles("patchunittest", "patchunittest", "aaaaaaaaaa0", "aaaaaaaaaa7", _), "syracuse patch 1 0 2013-03-25 1 5 aaaaaaaaaa0 aaaaaaaaaa5 ssss5\nsyracuse patchcomment comment5\nsyracuse streamline {\"test\":3}\nblabla 1\nblabla 2\nblabla 3\nblabla 4\nblabla 5\n", "new patch, all (even more) files in directory (2 streamline configurations)");
	strictEqual(integrate.collectFiles("patchunittest", "patchunittest", "aaaaaaaaaa6", "aaaaaaaaaa7", _), "syracuse patch 1 6 2013-03-28 1 8 aaaaaaaaaa6 aaaaaaaaaa8 ssss8\nsyracuse patchcomment comment8\nsyracuse streamline {\"test\":8}\nblabla 8\n", "new patch with streamline configuration, last file");
	writeDummyPatchFile("patchunittest/patch9.dat", 1, 5, 1, 6, false, true, _, true);
	strictEqual(integrate.collectFiles("patchunittest", "patchunittest", "aaaaaaaaaa0", "aaaaaaaaaa7", _), "syracuse patch 1 0 2013-03-28 1 8 aaaaaaaaaa0 aaaaaaaaaa8 ssss8\nsyracuse patchcomment comment8\nsyracuse streamline {\"test\":8}\nblabla 1\nblabla 2\nblabla 3\nblabla 4\nblabla 5\nblabla 6\nblabla 8\n", "new patch, all (even more) files in directory (4 streamline configurations)");

	start();
});


asyncTest("collect files with streamline configuration over release border", 9, function(_) {
	// write some patch files
	try {
		fs.mkdir("patchunittest/" + patchtools.TEMP_DIRECTORY, _);
	} catch (e) {
		console.log("Cannot create directory " + e);
	}
	writeDummyPatchFile("patchunittest/patch0.dat", 1, 1, 1, 2, false, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 1, 2, 2, 0, true, false, _, true);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 0, 2, 3, true, true, _, true);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 3, 2, 4, true, false, _, true);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 4, 2, 5, true, false, _);
	var desired = "syracuse patch 1 1 2013-03-20 2 0 aaaaaaaaaa1 aaaaaaaaaa0 ssss0\nsyracuse patchcomment comment0\nsyracuse streamline {\"test\":0}\nblabla 2\nblabla 0\nsyracuse patch 2 0 2013-03-25 2 5 aaaaaaaaaa0 aaaaaaaaaa5 ssss5\nsyracuse patchcomment comment5\nsyracuse streamline {\"test\":4}\nblabla 3\nblabla 4\nblabla 5\n";
	var result = integrate.collectFiles("patchunittest", "patchunittest/patch0.dat", "aaaaaaaaaa1", "aaaaaaaaaa1", _);
	console.log("------------------------");
	console.log(desired);
	console.log("<<" + result + ">>");
	console.log("------------------------");
	strictEqual(result, desired, "patch with streamline configurations before and after release");

	writeDummyPatchFile("patchunittest/patch0.dat", 1, 1, 1, 2, false, true, _, true);
	writeDummyPatchFile("patchunittest/patch0.dat", 1, 2, 2, 0, true, true, _, true);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 0, 2, 3, true, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 3, 2, 4, true, true, _, true);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 4, 2, 5, true, true, _);
	var desired = "syracuse patch 1 1 2013-03-20 2 0 aaaaaaaaaa1 aaaaaaaaaa0 ssss0\nsyracuse patchcomment comment0\nsyracuse streamline {\"test\":0}\nblabla 2\nblabla 0\nsyracuse patch 2 0 2013-03-25 2 5 aaaaaaaaaa0 aaaaaaaaaa5 ssss5\nsyracuse patchcomment comment5\nsyracuse streamline {\"test\":4}\nblabla 3\nblabla 4\nblabla 5\n";
	var result = integrate.collectFiles("patchunittest", "patchunittest/patch0.dat", "aaaaaaaaaa1", "aaaaaaaaaa1", _);
	strictEqual(result, desired, "patch with streamline configurations before and after release, 2 configuration changes before release");

	writeDummyPatchFile("patchunittest/patch0.dat", 1, 1, 1, 2, false, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 1, 2, 2, 0, true, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 0, 2, 3, true, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 3, 2, 4, true, true, _, true);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 4, 2, 5, true, true, _, true);
	var desired = "syracuse patch 1 1 2013-03-20 2 0 aaaaaaaaaa1 aaaaaaaaaa0 ssss0\nsyracuse patchcomment comment0\nblabla 2\nblabla 0\nsyracuse patch 2 0 2013-03-25 2 5 aaaaaaaaaa0 aaaaaaaaaa5 ssss5\nsyracuse patchcomment comment5\nsyracuse streamline {\"test\":5}\nblabla 3\nblabla 4\nblabla 5\n";
	var result = integrate.collectFiles("patchunittest", "patchunittest/patch0.dat", "aaaaaaaaaa1", "aaaaaaaaaa1", _);
	strictEqual(result, desired, "patch with streamline configurations after release");

	writeDummyPatchFile("patchunittest/patch0.dat", 1, 1, 1, 2, false, true, _, true);
	writeDummyPatchFile("patchunittest/patch0.dat", 1, 2, 2, 0, true, true, _, true);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 0, 2, 3, true, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 3, 2, 4, true, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 4, 2, 5, true, true, _);
	var desired = "syracuse patch 1 1 2013-03-20 2 0 aaaaaaaaaa1 aaaaaaaaaa0 ssss0\nsyracuse patchcomment comment0\nsyracuse streamline {\"test\":0}\nblabla 2\nblabla 0\nsyracuse patch 2 0 2013-03-25 2 5 aaaaaaaaaa0 aaaaaaaaaa5 ssss5\nsyracuse patchcomment comment5\nblabla 3\nblabla 4\nblabla 5\n";
	var result = integrate.collectFiles("patchunittest", "patchunittest/patch0.dat", "aaaaaaaaaa1", "aaaaaaaaaa1", _);
	strictEqual(result, desired, "patch with streamline configurations before release");

	writeDummyPatchFile("patchunittest/patch0.dat", 1, 1, 1, 2, false, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 1, 2, 2, 0, true, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 0, 2, 3, true, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 3, 2, 4, true, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 4, 2, 5, true, true, _);
	var desired = "syracuse patch 1 1 2013-03-20 2 0 aaaaaaaaaa1 aaaaaaaaaa0 ssss0\nsyracuse patchcomment comment0\nblabla 2\nblabla 0\nsyracuse patch 2 0 2013-03-25 2 5 aaaaaaaaaa0 aaaaaaaaaa5 ssss5\nsyracuse patchcomment comment5\nblabla 3\nblabla 4\nblabla 5\n";
	var result = integrate.collectFiles("patchunittest", "patchunittest/patch0.dat", "aaaaaaaaaa1", "aaaaaaaaaa1", _);
	strictEqual(result, desired, "patch without streamline configurations");

	writeDummyPatchFile("patchunittest/patch0.dat", 1, 2, 2, 0, false, true, _, true);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 0, 2, 5, true, true, _, true);
	var desired = "syracuse patch 1 2 2013-03-20 2 0 aaaaaaaaaa2 aaaaaaaaaa0 ssss0\nsyracuse patchcomment comment0\nsyracuse streamline {\"test\":0}\nblabla 0\nsyracuse patch 2 0 2013-03-25 2 5 aaaaaaaaaa0 aaaaaaaaaa5 ssss5\nsyracuse patchcomment comment5\nsyracuse streamline {\"test\":5}\nblabla 5\n";
	var result = integrate.collectFiles("patchunittest", "patchunittest/patch0.dat", "aaaaaaaaaa2", "aaaaaaaaaa2", _);
	strictEqual(result, desired, "patch with streamline configurations before and after release, only 2 parts");

	// Error cases
	writeDummyPatchFile("patchunittest/patch0.dat", 1, 2, 2, 3, false, true, _, true);
	try {
		integrate.collectFiles("patchunittest", "patchunittest/patch0.dat", "aaaaaaaaaa2", "aaaaaaaaaa2", _);
		throw new Error("No error detected");
	} catch (e) {
		strictEqual("" + e, "Error: No patch ending in current release", "Missing release border detected (1 patch)");
	}

	writeDummyPatchFile("patchunittest/patch0.dat", 1, 1, 1, 2, false, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 1, 4, 2, 0, true, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 0, 2, 3, true, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 1, 2, 2, 3, true, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 3, 2, 3, true, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 3, 2, 4, true, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 4, 2, 5, true, true, _);
	try {
		integrate.collectFiles("patchunittest", "patchunittest/patch0.dat", "aaaaaaaaaa2", "aaaaaaaaaa2", _);
		throw new Error("No error detected");
	} catch (e) {
		strictEqual("" + e, "Error: No patch ending in current release", "Missing release border detected (release border available but not in chain)");
	}

	writeDummyPatchFile("patchunittest/patch0.dat", 1, 1, 1, 2, false, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 1, 2, 2, 0, true, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 0, 2, 3, true, true, _);
	writeDummyPatchFile("patchunittest/patch0.dat", 2, 3, 3, 4, true, true, _);
	try {
		integrate.collectFiles("patchunittest", "patchunittest/patch0.dat", "aaaaaaaaaa2", "aaaaaaaaaa2", _);
		throw new Error("No error detected");
	} catch (e) {
		strictEqual("" + e, "Error: No patch ending in current release", "Missing release border detected (release border for older release");
	}

	start();
});


// test for getMetaData

asyncTest("getMetaData", 3, function(_) {
	// normal patch file
	var patch1 = "syracuse patch 11 0 2013-09-19 12 0 e90f28 a52340 f73cb8e\n";
	strictEqual(integrate.getMetaData(patch1), "11 0 2013-09-19 12 0 e90f28 a52340 f73cb8e", "one patch");

	// patch file over release border
	var patch2 = "ABC\nsyracuse patch 11 0 2013-09-19 12 0 e90f28 a52340 f73cb8e\nsyracuse patch 12 0 2013-09-19 12 1 a52340 0b34ad 381549\n";
	strictEqual(integrate.getMetaData(patch2), "11 0 2013-09-19 12 1 e90f28 0b34ad 381549", "double patch");

	// no correct information
	var patch2 = "ABC syracuse patch 11 0 2013-09-19 12 0 e90f28 a52340 f73cb8e\n";
	strictEqual(integrate.getMetaData(patch2), null, "no patch");

	start();
});


asyncTest("end", 0, function(_) {
	unit.rmdirRec("patchunittest", _);
	start();
});