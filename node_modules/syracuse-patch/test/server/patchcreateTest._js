"use strict";
var p = require("syracuse-patch/lib/patchcreate");
var patchtools = require("syracuse-patch/lib/patchtools");
var fs = require('streamline-fs');
var path = require("path");
var util = require('util');
var writeFile = require('syracuse-patch/lib/patchtools').writeFile;
QUnit.module(module.id);

var actions = [];

// Test transformation rules
asyncTest("makeRule abc.txt", 3, function(_) {
	var rule;
	rule = p.makeRule("t", "abc.txt");
	strictEqual(rule[1], "t", "Correct rule name");
	strictEqual(rule[0].toString(), "/^abc\\.txt$/", "Correct constant pattern");
	strictEqual(rule[0].test("abc.txt"), true, "Correct constant pattern");
	start();
});

asyncTest("makeRule nocrypt abc.txt", 3, function(_) {
	var rule;
	rule = p.makeRule("hide", "abc.txt", 1);
	strictEqual(rule[1], "uglify", "Correct rule name");
	strictEqual(rule[0].toString(), "/^abc\\.txt$/", "Correct constant pattern");
	strictEqual(rule[0].test("abc.txt"), true, "Correct constant pattern");
	start();
});

asyncTest("makeRule nocrypt 2 abc.txt", 4, function(_) {
	var rule;
	rule = p.makeRule("hide", "abc.txt", 2);
	strictEqual(rule[1], "streamline", "Correct rule name");
	strictEqual(rule[0].toString(), "/^abc\\.txt$/", "Correct constant pattern");
	strictEqual(rule[0].test("abc.txt"), true, "Correct constant pattern");
	rule = p.makeRule("hidepretty", "abc.txt", 2);
	strictEqual(rule[1], "streamline", "Correct rule name");
	start();
});

asyncTest("makeRule nocrypt -1 abc.txt", 8, function(_) {
	var rule;
	rule = p.makeRule("hide", "abc.txt", -1);
	strictEqual(rule[1], "hidepretty", "Correct rule name");
	strictEqual(rule[0].toString(), "/^abc\\.txt$/", "Correct constant pattern");
	strictEqual(rule[0].test("abc.txt"), true, "Correct constant pattern");
	rule = p.makeRule("hidepretty", "abc.txt", -1);
	strictEqual(rule[1], "hidepretty", "Correct rule name");
	rule = p.makeRule("uglify", "abc.txt", -1);
	strictEqual(rule[1], "streamline", "Correct rule name");
	rule = p.makeRule("streamline", "abc.txt", -1);
	strictEqual(rule[1], "streamline", "Correct rule name");
	rule = p.makeRule("copy", "abc.txt", -1);
	strictEqual(rule[1], "copy", "Correct rule name");
	rule = p.makeRule("encrypt", "abc.txt", -1);
	strictEqual(rule[1], "encryptpretty", "Correct rule name");
	start();
});

asyncTest("makeRule hide abc.txt", 3, function(_) {
	var rule;
	rule = p.makeRule("hide", "abc.txt");
	strictEqual(rule[1], "hide", "Correct rule name");
	strictEqual(rule[0].toString(), "/^abc\\.txt$/", "Correct constant pattern");
	strictEqual(rule[0].test("abc.txt"), true, "Correct constant pattern");
	start();
});

asyncTest("makeRule **/abc.txt", 3, function(_) {
	var rule = p.makeRule("t", "**/abc.txt");
	strictEqual(rule[0].test("abc.txt"), true, "Found abc.txt");
	strictEqual(rule[0].test("cd/xx/abc.txt"), true, "Found cd/xx/abc.txt");
	strictEqual(rule[0].test("abc.txt/abc.txt1"), false, "Not found abc.txt/abc.txt1");
	start();
});
asyncTest("makeRule */abc.txt", 4, function(_) {
	var rule = p.makeRule("t", "*/abc.txt");
	strictEqual(rule[0].test("abc.txt"), false, "Not Found abc.txt");
	strictEqual(rule[0].test("cd/xx/abc.txt"), false, "Not found cd/xx/abc.txt");
	strictEqual(rule[0].test("abc.tx/abc.txt"), true, "found abc.tx/abc.txt1");
	strictEqual(rule[0].test("x/abc.txt1"), false, "Not found x/abc.txt1");
	start();
});

asyncTest("makeRule ?a*t", 5, function(_) {
	var rule = p.makeRule("t", "?a*t");
	strictEqual(rule[0].test("5abc.txt"), true, " Found 5abc.txt");
	strictEqual(rule[0].test("abc.txt"), false, "Not found abc.txt");
	strictEqual(rule[0].test("aat"), true, "found aat");
	strictEqual(rule[0].test("xat/xat"), false, "Not found xat/xat");
	strictEqual(rule[0].test("aat1"), false, "not found aat1");
	start();
});

//Test 
asyncTest("findRule", 30, function(_) {
		var rules = [p.makeRule("extra", "**/abc.js"), p.makeRule("extra", "**/enc*"), p.makeRule("ignore", "**/abc.js"), p.makeRule("streamline", "**/str*"), p.makeRule("encrypt", "**/enc*")];
		var config = {
			transformationRules: rules
		};
		var t = p.findRule("D node_modules/syracuse-patch/test/fixtures/abc.js", config, true);
		strictEqual(t.file, "node_modules/syracuse-patch/test/fixtures/abc.js", "filename node_modules/syracuse-patch/test/fixtures/abc.js");
		strictEqual(t.mode, "D", "mode");
		strictEqual(t.f, "node_modules/syracuse-patch/test/fixtures/abc.js", "original filename");
		strictEqual(t.rule, "ignore", "rulename");
		strictEqual(t.extra, true, "extra");
		t = p.findRule("D node_modules/syracuse-patch/test/fixtures/zzz.js", config, true);
		strictEqual(t.file, "node_modules/syracuse-patch/test/fixtures/zzz.js", "filename node_modules/syracuse-patch/test/fixtures/zzz.js");
		strictEqual(t.mode, "D", "mode");
		strictEqual(t.f, "node_modules/syracuse-patch/test/fixtures/zzz.js", "original filename");
		strictEqual(t.rule, "norule", "rulename");
		strictEqual(t.extra, undefined, "extra");
		t = p.findRule("A str._js", config, true);
		strictEqual(t.file, "str.js", "filename str._js");
		strictEqual(t.mode, "A", "mode");
		strictEqual(t.f, "str._js", "original filename");
		strictEqual(t.rule, "streamline", "rulename");
		strictEqual(t.extra, undefined, "extra");
		t = p.findRule("A str.txt", config, true);
		strictEqual(t.file, "str.txt", "filename str.txt");
		strictEqual(t.mode, "A", "mode");
		strictEqual(t.f, "str.txt", "original filename");
		strictEqual(t.rule, "copy", "rulename");
		strictEqual(t.extra, undefined, "extra");
		t = p.findRule("A str.js", config, true);
		strictEqual(t.file, "str.js", "filename str.js");
		strictEqual(t.mode, "A", "mode");
		strictEqual(t.f, "str.js", "original filename");
		strictEqual(t.rule, "copy", "rulename");
		strictEqual(t.extra, undefined, "extra");
		t = p.findRule("A enc._js", config, true);
		strictEqual(t.file, "enc.jsc", "filename enc._js");
		strictEqual(t.mode, "A", "mode");
		strictEqual(t.f, "enc._js", "original filename");
		strictEqual(t.rule, "encrypt", "rulename");
		strictEqual(t.extra, true, "extra");
		start();
	}

);

//Test for replacements
asyncTest("replacements: slash, $$, $R ", 1, function(_) {
	console.log("REPL");
	var result = p.replacements("$$ $$$R$$$/", "REPO");
	strictEqual(result, "$ $REPO$" + path.sep);
	start();
});

// Test for commitData

asyncTest("commitData", 13, function(_) {
	var result;
	result = p.commitData("9b91935655bc723b8b5f112b875c49201e4ae82c 2012-09-28 1 0 6c86f9b7ca62cc160f5e5410357f99a32f6aaed0 - Info 1", true);
	strictEqual(result.rollout, "9b91935655bc723b8b5f112b875c49201e4ae82c", "rollout hash");
	strictEqual(result.release, true, "is release");
	strictEqual(result.source, "6c86f9b7ca62cc160f5e5410357f99a32f6aaed0", "source hash");
	strictEqual(result.relNumber, "1", "rel number");
	strictEqual(result.comment, "Info 1", "comment");
	strictEqual(result.patchNumber, 0, "patch number");
	result = p.commitData("9b91935655bc723b8b5f112b875c49201e4ae82c 2012-09-28 1 1 6c86f9b7ca62cc160f5e5410357f99a32f6aaed0 - Info 1", true);
	strictEqual(result, null, "not found");
	result = p.commitData("9b91935655bc723b8b5f112b875c49201e4ae82c 2012-09-28 1 1 6c86f9b7ca62cc160f5e5410357f99a32f6aaed0 - Info 1", false);
	strictEqual(result.rollout, "9b91935655bc723b8b5f112b875c49201e4ae82c", "rollout hash");
	strictEqual(result.release, false, "is release");
	strictEqual(result.source, "6c86f9b7ca62cc160f5e5410357f99a32f6aaed0", "source hash");
	strictEqual(result.relNumber, "1", "rel number");
	strictEqual(result.comment, "Info 1", "comment");
	strictEqual(result.patchNumber, 1, "patch number");
	start();
});

// Test for splitargs
asyncTest("splitargs", 4, function(_) {
	var res = p.splitargs('a  b c "d e  f" g h ""');
	strictEqual(res.length, 7, "Correct number of arguments");
	strictEqual(res.join(","), "a,b,c,d e  f,g,h,", "Correct contents");
	res = p.splitargs('"" "a"  b c="d e  f" g');
	strictEqual(res.length, 5, "Correct number of arguments");
	strictEqual(res.join(","), ',a,b,c="d e  f",g', "Correct contents");
	start();
});