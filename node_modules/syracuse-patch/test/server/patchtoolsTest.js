"use strict";
const assert = require('chai').assert;
Object.keys(assert).forEach(key => {
	if (key !== 'isNaN') global[key] = assert[key];
});

describe(module.id, () => {
	var patchtools = require("syracuse-patch/lib/patchtools");



	// test for rights elevation
	it('elevate', function() {
		strictEqual(patchtools.elevate(""), "664", "elevation of empty rights");
		strictEqual(patchtools.elevate("000"), "664", "elevation of 000 is 664");
		strictEqual(patchtools.elevate("755"), "775", "elevation of 755 is 775");
		strictEqual(patchtools.elevate("123"), "767", "elevation of 123 is 767");
		strictEqual(patchtools.elevate("1444"), "1664", "elevation of 1444 is 1664");
	});

	it('nextRelease', function() {
		var result;
		try {
			result = patchtools.nextRelease([], "1.X5");
			throw new Error("No error occurred!");
		} catch (e) {
			strictEqual("Error: Wrong pattern", "" + e, "Wrong pattern 1.X5");
		}
		try {
			result = patchtools.nextRelease([], "1.X.X");
			throw new Error("No error occurred!");
		} catch (e) {
			strictEqual("Error: Invalid characters in pattern", "" + e, "Wrong pattern 1.XX");
		}
		try {
			result = patchtools.nextRelease([], "1.5.5");
			throw new Error("No error occurred!");
		} catch (e) {
			strictEqual("Error: Wrong pattern", "" + e, "Wrong pattern 1.5.5");
		}
		result = patchtools.nextRelease([], "X");
		strictEqual(result[0], "", "empty list: no predecessor");
		strictEqual(result[1], "0", "empty list: version 0");
		result = patchtools.nextRelease([], "7.X.1");
		strictEqual(result[0], "", "empty list: no predecessor");
		strictEqual(result[1], "7.0.1", "empty list: version 7.0.1");
		try {
			result = patchtools.nextRelease(["3.0", "8.1"], "1.X");
			throw new Error("No error occurred!");
		} catch (e) {
			strictEqual("Error: No previous version found", "" + e, "No previous version exists");
		}
		result = patchtools.nextRelease(["1.0", "2", "2.0", "2.0.1", "2.1", "3"], "2.0.X");
		strictEqual(result[0], "2.0.1", "2.0.X predecessor");
		strictEqual(result[1], "2.0.2", "2.0.X version");
		result = patchtools.nextRelease(["1.0", "2", "2.0", "2.0.1", "2.1", "3"], "2.0.3.X");
		strictEqual(result[0], "2.0.1", "2.0.X predecessor");
		strictEqual(result[1], "2.0.3.0", "2.0.X version");
		result = patchtools.nextRelease(["1.0", "2", "2.0", "2.0.1", "2.1"], "X");
		strictEqual(result[0], "2.1", "X predecessor");
		strictEqual(result[1], "3", "X version");
	});
});