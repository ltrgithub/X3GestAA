"use strict";
var p = require("syracuse-patch/lib/patchcreate");
var patchtools = require("syracuse-patch/lib/patchtools");
var fs = require('streamline-fs');
var path = require("path");
var util = require('util');
var writeFile = require('syracuse-patch/lib/patchtools').writeFile;
var unit = require("syracuse-patch/test/fixtures/unit");
var isFibers = true; //require('streamline-runtime').globals.runtime == "fibers-fast";

var config = require('config');
var tracer = console.log;
var patchconfig = {
	streamline: {
		"runtime": "fibers",
		"cache": true,
		"verbose": false,
		"aggressive": true
	},
	uglify: {
		"sequences": false,
		"unsafe": false,
		"unused": false,
		"hoist_vars": false,
		"if_return": false,
		"cascade": false,
		"side_effects": false,
		"hoist_funs": false
	},
	transformationRules: [p.makeRule("encrypt", "**/*")]
};



import {
	assert
} from 'chai';
Object.keys(assert).forEach(key => {
	if (key !== 'isNaN') global[key] = assert[key];
});

describe(module.id, () => {

	var actions = [];

	function performTest(_, async, orig_module, transformed_module, parameter, consumer, text) {
		var stack_orig;
		try {
			console.error("Result" + async ? orig_module.test(parameter, _) : orig_module.test(parameter));
		} catch (e) {
			tracer && tracer(text + " original " + e + " " + e.stack);
			stack_orig = e.stack;
		}
		var stack_trans;
		try {
			console.error("Result" + async ? transformed_module.test(parameter, _) : transformed_module.test(parameter));
		} catch (e) {
			tracer && tracer(text + " transformed " + e + " " + e.stack);
			stack_trans = e.stack;
		}
		var lines_orig = p._analyzeStack(stack_orig);
		var lines_trans = p._analyzeStack(stack_trans);
		for (var i = 0; i < lines_orig.length; i++) {
			var originalLine = lines_orig[i];
			if (originalLine.comp.indexOf("sourcemap") >= 0) {
				var transformedLine = lines_trans[i];
				p._translate(transformedLine, consumer);
				tracer && tracer("transformed line " + transformedLine.line + " - original line " + originalLine.line + " | transformed column " + transformedLine.column + " - original column " + originalLine.column);
				strictEqual(transformedLine.line, originalLine.line, "Line " + originalLine.line + " " + text);
				strictEqual(transformedLine.column, originalLine.column, "Column " + originalLine.column + " " + text);
			}
		}
	}

	it('analyze stack trace Firefox (partial)', function(_) {
		var trace = "exports.EventListener<._bindFieldEvents/<@http://localhost:8124/streamline-require/lib/client/require.js:75\njQuery.event.dispatch@http://localhost:8124/syracuse-ui/deps/jquery/jquery-3.1.1.min.js:3128\n";
		var res = p._analyzeStack(trace, "node_modules/test/def/eventListener.js\nnode_modules/abc/def/eventListener.js\nnode_modules/abc/def/event.js\n");
		strictEqual(res.workdir, ".", "Work directory");
		strictEqual(res.length, 2, "2 entries");
		strictEqual(res[0].name, "._bindFieldEvents/", "entry 1: name");
		strictEqual(res[0].comp, "node_modules/abc/def/eventListener.js", "entry 1: component");
		// strictEqual(res[0].line, 64, "entry 1: line");
		strictEqual(res[0].column, -1, "entry 1: column");
		strictEqual(res[1].name, "jQuery.event.dispatch", "entry 2: name");
		strictEqual(res[1].comp, "node_modules/syracuse-ui/deps/jquery/jquery-3.1.1.min.js", "entry 2: component");
		// strictEqual(res[1].line, 3117, "entry 2: line");
		strictEqual(res[1].column, -1, "entry 2: column");
		tracer && tracer("ANAL " + util.format(res));
	});

	//test for analyze stack trace
	it('analyze stack trace', function(_) {
		var stack = "Error: Test\n    at c:\\workspace\\Syracuse2\\node_modules\\syracuse-main\\lib\\syracuse._js:3:7\n  at c:\\workspace\\Syracuse2\\node_modules\\streamline\\lib\\fibers-fast\\runtime.js:47:14";
		var res = p._analyzeStack(stack);
		strictEqual(res.length, 2, "Number of elements");
		strictEqual(res[0].line, 3, "Line");
		strictEqual(res[0].column, 7, "Column");
		strictEqual(res[0].comp, "c:/workspace/Syracuse2/node_modules/syracuse-main/lib/syracuse._js", "component");
		strictEqual(res[0].name, null, "function");
		strictEqual(res.errortext, "Error: Test", "Errortext");
		strictEqual(res.workdir, "c:/workspace/Syracuse2", "workdir");

		// extra "node_modules" in syracuse._js
		var stack = "Error: Hallo\n at disp (c:\\workspace\\Syracuse2\\node_modules\\bla\\node_modules\\syracuse-main\\lib\\syracuse._js:1114:3)\n at disp (c:\\workspace\\Syracuse2\\index.js:1114:3)";
		var res = p._analyzeStack(stack);
		strictEqual(res.length, 2, "Number of elements");
		strictEqual(res[0].line, 1114, "Line");
		strictEqual(res[0].column, 3, "Column");
		strictEqual(res[0].comp, "c:/workspace/Syracuse2/node_modules/bla/node_modules/syracuse-main/lib/syracuse._js", "component");
		strictEqual(res[0].name, "disp", "function");
		strictEqual(res.errortext, "Error: Hallo", "Errortext");
		strictEqual(res.workdir, "c:/workspace/Syracuse2", "workdir");

		// extra "node_modules" in syracuse._js
		var stack = "Error: Hallo\n at disp (c:\\workspace\\Syracuse2\\index.js:1114:3)\n at disp (c:\\workspace\\Syracuse2\\node_modules\\bla\\node_modules\\syracuse-main\\lib\\syracuse._js:1114:3)\n";
		var res = p._analyzeStack(stack);
		strictEqual(res.length, 2, "Number of elements");
		strictEqual(res[0].line, 1114, "Line");
		strictEqual(res[0].column, 3, "Column");
		strictEqual(res[0].comp, "c:/workspace/Syracuse2/index.js", "component");
		strictEqual(res[0].name, "disp", "function");
		strictEqual(res.errortext, "Error: Hallo", "Errortext");
		// strictEqual(res.workdir, "c:/workspace/Syracuse2", "workdir");

	});




	// Test transformation rules
	it('makeRule abc.txt', function(_) {
		var rule;
		rule = p.makeRule("t", "abc.txt");
		strictEqual(rule[1], "t", "Correct rule name");
		strictEqual(rule[0].toString(), "/^abc\\.txt$/", "Correct constant pattern");
		strictEqual(rule[0].test("abc.txt"), true, "Correct constant pattern");
	});

	it('makeRule nocrypt abc.txt', function(_) {
		var rule;
		rule = p.makeRule("hide", "abc.txt", 1);
		strictEqual(rule[1], "uglify", "Correct rule name");
		strictEqual(rule[0].toString(), "/^abc\\.txt$/", "Correct constant pattern");
		strictEqual(rule[0].test("abc.txt"), true, "Correct constant pattern");
	});

	it('makeRule nocrypt 2 abc.txt', function(_) {
		var rule;
		rule = p.makeRule("hide", "abc.txt", 2);
		strictEqual(rule[1], "streamline", "Correct rule name");
		strictEqual(rule[0].toString(), "/^abc\\.txt$/", "Correct constant pattern");
		strictEqual(rule[0].test("abc.txt"), true, "Correct constant pattern");
		rule = p.makeRule("hidepretty", "abc.txt", 2);
		strictEqual(rule[1], "streamline", "Correct rule name");
	});

	it('makeRule nocrypt -1 abc.txt', function(_) {
		var rule;
		rule = p.makeRule("hide", "abc.txt", -1);
		strictEqual(rule[1], "hidepretty", "Correct rule name");
		strictEqual(rule[0].toString(), "/^abc\\.txt$/", "Correct constant pattern");
		strictEqual(rule[0].test("abc.txt"), true, "Correct constant pattern");
		rule = p.makeRule("hidepretty", "abc.txt", -1);
		strictEqual(rule[1], "hidepretty", "Correct rule name");
		rule = p.makeRule("uglify", "abc.txt", -1);
		strictEqual(rule[1], "streamline", "Correct rule name");
		rule = p.makeRule("streamline", "abc.txt", -1);
		strictEqual(rule[1], "streamline", "Correct rule name");
		rule = p.makeRule("copy", "abc.txt", -1);
		strictEqual(rule[1], "copy", "Correct rule name");
		rule = p.makeRule("encrypt", "abc.txt", -1);
		strictEqual(rule[1], "encryptpretty", "Correct rule name");
	});

	it('makeRule hide abc.txt', function(_) {
		var rule;
		rule = p.makeRule("hide", "abc.txt");
		strictEqual(rule[1], "hide", "Correct rule name");
		strictEqual(rule[0].toString(), "/^abc\\.txt$/", "Correct constant pattern");
		strictEqual(rule[0].test("abc.txt"), true, "Correct constant pattern");
	});

	it('makeRule **/abc.txt', function(_) {
		var rule = p.makeRule("t", "**/abc.txt");
		strictEqual(rule[0].test("abc.txt"), true, "Found abc.txt");
		strictEqual(rule[0].test("cd/xx/abc.txt"), true, "Found cd/xx/abc.txt");
		strictEqual(rule[0].test("abc.txt/abc.txt1"), false, "Not found abc.txt/abc.txt1");
	});
	it('makeRule */abc.txt', function(_) {
		var rule = p.makeRule("t", "*/abc.txt");
		strictEqual(rule[0].test("abc.txt"), false, "Not Found abc.txt");
		strictEqual(rule[0].test("cd/xx/abc.txt"), false, "Not found cd/xx/abc.txt");
		strictEqual(rule[0].test("abc.tx/abc.txt"), true, "found abc.tx/abc.txt1");
		strictEqual(rule[0].test("x/abc.txt1"), false, "Not found x/abc.txt1");
	});

	it('makeRule ?a*t', function(_) {
		var rule = p.makeRule("t", "?a*t");
		strictEqual(rule[0].test("5abc.txt"), true, " Found 5abc.txt");
		strictEqual(rule[0].test("abc.txt"), false, "Not found abc.txt");
		strictEqual(rule[0].test("aat"), true, "found aat");
		strictEqual(rule[0].test("xat/xat"), false, "Not found xat/xat");
		strictEqual(rule[0].test("aat1"), false, "not found aat1");
	});

	//Test 
	it('findRule', function(_) {
			var rules = [p.makeRule("extra", "**/abc.js"), p.makeRule("extra", "**/enc*"), p.makeRule("ignore", "**/abc.js"), p.makeRule("streamline", "**/str*"), p.makeRule("encrypt", "**/enc*")];
			var config = {
				transformationRules: rules
			};
			var t = p.findRule("D node_modules/syracuse-patch/test/fixtures/abc.js", config, true);
			strictEqual(t.file, "node_modules/syracuse-patch/test/fixtures/abc.js", "filename node_modules/syracuse-patch/test/fixtures/abc.js");
			strictEqual(t.mode, "D", "mode");
			strictEqual(t.f, "node_modules/syracuse-patch/test/fixtures/abc.js", "original filename");
			strictEqual(t.rule, "ignore", "rulename");
			strictEqual(t.extra, true, "extra");
			t = p.findRule("D node_modules/syracuse-patch/test/fixtures/zzz.js", config, true);
			strictEqual(t.file, "node_modules/syracuse-patch/test/fixtures/zzz.js", "filename node_modules/syracuse-patch/test/fixtures/zzz.js");
			strictEqual(t.mode, "D", "mode");
			strictEqual(t.f, "node_modules/syracuse-patch/test/fixtures/zzz.js", "original filename");
			strictEqual(t.rule, "norule", "rulename");
			strictEqual(t.extra, undefined, "extra");
			t = p.findRule("A str._js", config, true);
			strictEqual(t.file, "str.es5", "filename str._js");
			strictEqual(t.mode, "A", "mode");
			strictEqual(t.f, "str._js", "original filename1");
			strictEqual(t.rule, "streamline", "rulename");
			strictEqual(t.extra, undefined, "extra");
			t = p.findRule("A str.txt", config, true);
			strictEqual(t.file, "str.txt", "filename str.txt");
			strictEqual(t.mode, "A", "mode");
			strictEqual(t.f, "str.txt", "original filename");
			strictEqual(t.rule, "copy", "rulename");
			strictEqual(t.extra, undefined, "extra");
			t = p.findRule("A str.js", config, true);
			strictEqual(t.file, "str.es5", "filename str.js");
			strictEqual(t.mode, "A", "mode");
			strictEqual(t.f, "str.js", "original filename2");
			strictEqual(t.rule, "babel", "rulename");
			strictEqual(t.extra, undefined, "extra");
			t = p.findRule("A enc._js", config, true);
			strictEqual(t.file, "enc.jsc", "filename enc._js");
			strictEqual(t.mode, "A", "mode");
			strictEqual(t.f, "enc._js", "original filename3");
			strictEqual(t.rule, "encrypt", "rulename");
			strictEqual(t.extra, true, "extra");
		}

	);

	//Test for replacements
	it('replacements: slash, $$, $R ', function(_) {
		tracer && tracer("REPL");
		var result = p.replacements("$$ $$$R$$$/", "REPO");
		strictEqual(result, "$ $REPO$" + path.sep);
	});

	// Test for commitData

	it('commitData', function(_) {
		var result;
		result = p.commitData("9b91935655bc723b8b5f112b875c49201e4ae82c 2012-09-28 1 0 6c86f9b7ca62cc160f5e5410357f99a32f6aaed0 - Info 1", true);
		strictEqual(result.rollout, "9b91935655bc723b8b5f112b875c49201e4ae82c", "rollout hash");
		strictEqual(result.release, true, "is release");
		strictEqual(result.source, "6c86f9b7ca62cc160f5e5410357f99a32f6aaed0", "source hash");
		strictEqual(result.relNumber, "1", "rel number");
		strictEqual(result.comment, "Info 1", "comment");
		strictEqual(result.patchNumber, 0, "patch number");
		result = p.commitData("9b91935655bc723b8b5f112b875c49201e4ae82c 2012-09-28 1 1 6c86f9b7ca62cc160f5e5410357f99a32f6aaed0 - Info 1", true);
		strictEqual(result, null, "not found");
		result = p.commitData("9b91935655bc723b8b5f112b875c49201e4ae82c 2012-09-28 1 1 6c86f9b7ca62cc160f5e5410357f99a32f6aaed0 - Info 1", false);
		strictEqual(result.rollout, "9b91935655bc723b8b5f112b875c49201e4ae82c", "rollout hash");
		strictEqual(result.release, false, "is release");
		strictEqual(result.source, "6c86f9b7ca62cc160f5e5410357f99a32f6aaed0", "source hash");
		strictEqual(result.relNumber, "1", "rel number");
		strictEqual(result.comment, "Info 1", "comment");
		strictEqual(result.patchNumber, 1, "patch number");
	});

	// Test for splitargs
	it('splitargs', function(_) {
		var res = p.splitargs('a  b c "d e  f" g h ""');
		strictEqual(res.length, 7, "Correct number of arguments");
		strictEqual(res.join(","), "a,b,c,d e  f,g,h,", "Correct contents");
		res = p.splitargs('"" "a"  b c="d e  f" g');
		strictEqual(res.length, 5, "Correct number of arguments");
		strictEqual(res.join(","), ',a,b,c="d e  f",g', "Correct contents");
	});


	//test for source maps
	it('source map with babel', function(_) {

		try {
			var tempdir = __dirname + "/tempfiles";
			fs.mkdir(tempdir, _);
			var filename = __dirname + "/../fixtures/sourcemap1.js";
			var orig = fs.readFile(filename, "utf8", _);
			orig = orig.replace(/\t/g, "    "); // replace tabulators because _transform also does this
			var filename = tempdir + "/sourcemap1.js";
			var filename5 = tempdir + "/sourcemap1.ec5";
			tracer && tracer("Original text <<<" + orig + ">>>");
			fs.writeFile(filename5, orig, "utf8", _);
			var orig_module = require(filename5);
			var result = p._transform(orig, filename, "babel", null, true);
			var consumer = new p.Consumer(result[1]);
			var tempfile = tempdir + "/s1.ec5";
			tracer && tracer("Transformed text <<<" + result[0] + ">>>");
			fs.writeFile(tempfile, result[0], _);
			try {
				var transformed_module = require(tempfile);
			} catch (e) {
				tracer && tracer("ZZZ " + e);
			}
			performTest(_, false, orig_module, transformed_module, 0, consumer, "babel parameter 0");
			performTest(_, false, orig_module, transformed_module, 1, consumer, "babel parameter 1");

		} finally {
			unit.rmdirRec(tempdir, _);
		}

	});

	//test for source maps
	it('source map with uglify', function(_) {

		try {
			var tempdir = __dirname + "/tempfiles";
			fs.mkdir(tempdir, _);
			var filename = __dirname + "/../fixtures/sourcemap1.js";
			var orig = fs.readFile(filename, "utf8", _);
			orig = orig.replace(/\t/g, "    "); // replace tabulators because _transform also does this
			var filename = tempdir + "/sourcemap1.js";
			tracer && tracer("Original text <<<" + orig + ">>>");
			fs.writeFile(filename, orig, "utf8", _);
			var orig_module = require(filename);
			var result = p._transform(orig, filename, "uglify", null, true);
			var consumer = new p.Consumer(result[1]);
			var tempfile = tempdir + "/s1.js";
			tracer && tracer("Transformed text <<<" + result[0] + ">>>");
			fs.writeFile(tempfile, result[0], _);
			try {
				var transformed_module = require(tempfile);
			} catch (e) {
				tracer && tracer("ZZZ " + e);
			}
			performTest(_, false, orig_module, transformed_module, 0, consumer, "uglify parameter 0");
			performTest(_, false, orig_module, transformed_module, 1, consumer, "uglify parameter 1");

		} finally {
			unit.rmdirRec(tempdir, _);
		}

	});

	it('conditions in configuration', function(_) {
			var config = "[FILES]\nif(A) copy a.txt\nif ( B )copy b.txt\nif( ! A) copy c.txt";
			var t = p._rc(config);
			console.log("TEST ", require('util').format(t));

			strictEqual(t.transformationRules.length, 1, "no symbol: 1 rule");
			strictEqual(t.transformationRules[0][2], 4, "no symbol: line 4");
			var t = p._rc(config, ['A']);
			console.log("TEST ", JSON.stringify(t));
			strictEqual(t.transformationRules.length, 1, "symbol A: 1 rule");
			strictEqual(t.transformationRules[0][2], 2, "symbol A: line 2");
			var t = p._rc(config, ['A', 'B']);
			console.log("TEST ", require('util').format(t));
			strictEqual(t.transformationRules.length, 2, "symbol A,B: 2 rules");
			strictEqual(t.transformationRules[0][2], 2, "symbol A,B: line 2");
			strictEqual(t.transformationRules[1][2], 3, "symbol A,B: line 3");
			var t = p._rc(config, ['B']);
			console.log("TEST ", require('util').format(t));
			strictEqual(t.transformationRules.length, 2, "symbol B: 2 rules");
			strictEqual(t.transformationRules[0][2], 3, "symbol B: line 3");
			strictEqual(t.transformationRules[1][2], 4, "symbol A,B: line 4");
			var t = p._rc(config, ['a', 'C']);
			console.log("TEST ", require('util').format(t));
			strictEqual(t.transformationRules.length, 1, "symbol a,C: 1 rule");
			strictEqual(t.transformationRules[0][2], 4, "symbol a,C: line 4");


		})
		// test for source maps
	isFibers && it('source map with streamline', function(_) {

		var filename = __dirname + "/../fixtures/sourcemap2._js";
		var orig = fs.readFile(filename, _);
		try {
			var tempdir = __dirname + "/tempfiles";
			fs.mkdir(tempdir, _);
			tracer && tracer("Original text <<<" + orig + ">>>");
			fs.writeFile(tempdir + "/sourcemap0._js", orig.toString().replace(/\t/g, "    "), "utf8", _);
			var orig_module = require(tempdir + "/sourcemap0");
			var result = p._transform(orig, filename, "streamline", patchconfig, true);
			var consumer;
			if (result[1]) consumer = new p.Consumer(result[1]);
			var tempfile = tempdir + "/s2.js";
			fs.writeFile(tempfile, result[0], _);
			tracer && tracer("Transformed text <<<" + result[0] + ">>>");
			try {
				var transformed_module = require(tempfile);
			} catch (e) {
				tracer && tracer("ZZZ " + e);
			}
			performTest(_, true, orig_module, transformed_module, 0, consumer, "streaml parameter 0");
			performTest(_, true, orig_module, transformed_module, 1, consumer, "streaml parameter 1");

		} finally {
			unit.rmdirRec(tempdir, _);
		}

	});

	//test for source maps
	isFibers && it('source map with streamline and uglify', function(_) {

		var filename = __dirname + "/../fixtures/sourcemap2._js";
		var orig = fs.readFile(filename, _);
		try {
			var tempdir = __dirname + "/tempfiles";
			fs.mkdir(tempdir, _);
			tracer && tracer("Original text <<<" + orig + ">>>");
			fs.writeFile(tempdir + "/sourcemap0._js", orig.toString().replace(/\t/g, "    "), "utf8", _);
			var orig_module = require(tempdir + "/sourcemap0");
			var result = p._transform(orig, filename, "streamline", patchconfig, true);
			var consumer;
			if (result[1]) consumer = new p.Consumer(result[1]);
			var tempfile = tempdir + "/s3.js";
			fs.writeFile(tempfile, result[0], _);
			tracer && tracer("Transformed text <<<" + result[0] + ">>>");
			try {
				var transformed_module = require(tempfile);
			} catch (e) {
				tracer && tracer("ZZZ " + e);
			}
			performTest(_, true, orig_module, transformed_module, 0, consumer, "streaml/uglify parameter 0");
			performTest(_, true, orig_module, transformed_module, 1, consumer, "streaml/uglify parameter 1");

		} finally {
			unit.rmdirRec(tempdir, _);
		}
	});
});