"use strict";
var fs = require('streamline-fs');
var util = require('util');
var zlib = require('zlib');
var child_process = require('child_process');
var os = require('os');
var path = require('path');
var locale = require("syracuse-core/lib/locale");
var config = require('syracuse-main/lib/nodeconfig').config;
var mock = require('syracuse-load/lib/mock');
var ballot = require('./ballot');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var patchtools = require('syracuse-patch/lib/patchtools');

/// !doc
/// # Patch integration  
/// ```javascript
/// var integrate = require('syracuse-patch/lib/integrate')  
/// ```
/// 

var tracer = console.log;

var LOGFILE = os.tmpDir()+"/patch.log";

// var tracer = console.log;
/* var tracer = function(text) {
	fs.appendFileSync(LOGFILE, JSON.stringify(new Date())+text+"\n")
}
*/

var DIFF_ENTRIES = 0x01
var LOADED = 0x02
var BINARY = 0x04

// timeout for patch integration request (should exceed http.Server.timeout)
var PATCH_INTEGRATION_TIMEOUT = 130000;


// for base85 decoding
var d85 = [  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			 0, 0, 0,63, 0,64,65,66,67, 0,
			68,69,70,71, 0,72, 0, 0, 1, 2,
			 3, 4, 5, 6, 7, 8, 9,10, 0,73,
			74,75,76,77,78,11,12,13,14,15,
			16,17,18,19,20,21,22,23,24,25,
			26,27,28,29,30,31,32,33,34,35,
			36, 0, 0, 0,79,80,81,37,38,39,
			40,41,42,43,44,45,46,47,48,49,
			50,51,52,53,54,55,56,57,58,59,
			60,61,62,82,83,84,85 ];

			
			
function BinBuffer(buffer) {
	this.b = buffer;
	this.offset = 0;
}

BinBuffer.prototype.readLength = function() {
	if (this.offset >= this.b.length)
		throw locale.format(module, "endOfBuffer");
	var result = 0;
	var shift = 0;	
	while (this.offset < this.b.length) {
		var current = this.b[this.offset]
		if (current & 0x80) { // not last byte
			result += (current & 0x7F) << shift;
		} else { // last byte
			result += (current & 0x7F) << shift;
			this.offset++;
			return result;
		}
		shift += 7;
		this.offset++;
		if (shift > 32) 
			throw locale.format(module, "tooMany", this.offset);
	}
}

BinBuffer.prototype.readInstruction = function() {
	if (this.offset >= this.b.length)
		return false; // no further instructions
	var type = this.b[this.offset++];
	var resultOffset = 0;
	var resultLength = 0;
	var sourceBuffer = this.sourceBuf;
	if (type & 0x80) { // copy instruction
		if (type & 0x01)
			resultOffset += this.b[this.offset++]
		if (type & 0x02)
			resultOffset += (this.b[this.offset++] << 8)
		if (type & 0x04)
			resultOffset += (this.b[this.offset++] << 16)
		if (type & 0x08)
			resultOffset += (this.b[this.offset++] << 24)
		if (type & 0x70) { // length not maximum length of 64 kB
			if (type & 0x10)
				resultLength += this.b[this.offset++]
			if (type & 0x20)
				resultLength += (this.b[this.offset++] << 8)
			if (type & 0x40)
				resultLength += (this.b[this.offset++] << 16)
		} else {
			resultLength = 0x10000;
		}
		if (this.offset > this.b.length+1) // too many bytes
			throw locale.format(module, "tooManyCopy");
		// tracer && tracer("Copy offset "+resultOffset+ " length " + resultLength);
		
	} else { // insert instruction
		sourceBuffer = this.b;
		resultOffset = this.offset;
		this.offset += type;
		resultLength = type;
		if (this.offset > this.b.length+1) // too many bytes
			throw locale.format(module, "tooManyInsert");
		// tracer && tracer("Insert offset "+resultOffset+ " length " + resultLength);
	}	
	sourceBuffer.copy(this.destBuf, this.targetOffset, resultOffset, resultOffset+resultLength);
	this.targetOffset += resultLength;
	return true;
}
	
	
BinBuffer.prototype.transform = function(targetDirectory, file_from, file_to, sha1_from, sha1_to, checksums, _) {
	this.offset = 0; // offset of instruction buffer
	this.targetOffset = 0; // offset of target buffer
	var sourceLen = this.readLength();
	var destLen = this.readLength();
	this.sourceBuf = fs.readFile(targetDirectory+"/"+file_from, _);
	if (sourceLen !== this.sourceBuf.length)
		throw locale.format(module, "wrongLength", file_from, sourceLen, this.sourceBuf.len);
	if (!patchtools.check_sha1_binary(this.sourceBuf, sha1_from))
		throw locale.format(module, "wrongChecksum",file_from);
	this.destBuf = new Buffer(destLen);
	// perform insert/copy instructions
	while (this.readInstruction()) {}
	if (destLen !== this.targetOffset)
		throw locale.format(module, "wrongLength", file_to, destLen, this.targetOffset);
	if (!patchtools.check_sha1_binary(this.destBuf, sha1_to))
		throw locale.format(module, "wrongChecksum", file_to);
	patchtools.writeFile(targetDirectory +"/"+ file_to, this.destBuf, _);
	checksums[path.dirname(file_to)][path.basename(file_to)] = "F "+sha1_to;
}

function _decode85(line, buffer, bufferoffset) {
	// first character is length of bytes
	var len = line.charCodeAt(0)-64;
	if (len > 32) len -= 6;
	// deciphering base85
	var i, code, decode, number;
	number = 0;
	for (i=1; i< line.length; i++) {
		var code = line.charCodeAt(i);
		if (code >= d85.length || (decode = d85[code]) === 0)
			throw locale.format(module, "invalidChar", code, line)
		number = 85*number+decode-1;
		if (i % 5 === 0) {
			var transfer = len > 4 ? 4 : len;
			len -= transfer;
			if (transfer < 4) {
				number >>>= (32-8*transfer)
			}
			for (var j = transfer-1; j >= 0; j--) {
				// console.log("b["+(bufferoffset+j)+"] = "+(number % 256)+" "+number);
				buffer[bufferoffset+j] = number % 256
				number >>>= 8;
			}
			bufferoffset += transfer
			if (len === 0)
				return bufferoffset;
		}
	}
	throw locale.format(module, "tooShort", line);
}
	
/// reads lines in binary GIT patch format
/// result: object with i: index in lines array after last content line, buffer: buffer with data
function _readBinary(lines, i, read, _) {
	// find out length of base85 decoded data
	var len = 0;
	var j = i;
	var literal = false;
	var fullLength = 0;
	var r;
	if (r = /^(literal|delta) (\d+)/.exec(lines[j])) {
		if (r[1] === "literal")
			literal = true;
		fullLength = r[2];
	} else {
		if (read)
			throw locale.format(module, "wrongDescBinary", lines[j]);
		else {
			var result = { i: j};
			return result;
		}
	}
	j++;
	i++;
	// all but last line have maximal length 52 and start with 'z'
	while (j < lines.length && lines[j].substr(0, 1) === 'z') {
		len += 52;
		j++;
	}
	// last line may be shorter
	if (j < lines.length && lines[j].match(/^[A-Za-y]\S+$/)) {
	    var lastLength = lines[j].charCodeAt(0)-64;
		if (lastLength > 32)
			lastLength -= 6;
		len += lastLength;
		j++;
	}
	if (!read) {
		var result = { i: j, literal: literal };
		return result;
	}
	
	// console.log("LENGTH1"+len);
	var zipBuffer = new Buffer(len);
	var bufferoffset = 0;
	while (i < j) {
		bufferoffset = _decode85(lines[i], zipBuffer, bufferoffset);
		i++;
	}
	var buffer;
	buffer = zlib.inflate(zipBuffer, ~_);
	if (buffer.length - fullLength != 0)
		throw locale.format(module, "wrongLengthInflate", buffer.length, fullLength);
	// console.log("BLEN"+buffer.length+" lit "+literal);
	var result = { i: j, buffer: buffer, literal: literal };
	return result;
}

/// write target text file
function _write_data(targetDirectory, status, file_from, file_to, sha1_to, file_lines, checksums, access_rights, _) {
	if ((status & LOADED) != 0) {
		if (file_from && file_from !== file_to) {
			fs.unlink(targetDirectory + "/" + file_from, _);
			delete checksums[path.dirname(file_from)][path.basename(file_from)];
		}
		var buffer = new Buffer(file_lines.join("\n"), "utf8");
		var sha1 = patchtools.get_sha1_binary(buffer);
		if (!patchtools.equal_sha1(sha1, sha1_to)) {
			tracer("Wrong check sum for "+file_to+" expected "+sha1_to);
			throw new Error(locale.format(module, "wrongChecksum", file_to));
		}
		tracer("Write file "+targetDirectory+"/"+file_to+" access rights "+access_rights);		
		patchtools.writeFile(targetDirectory + "/" + file_to, buffer, _); 
		fs.chmod(targetDirectory + "/" + file_to, access_rights || "644", _);
		checksums[path.dirname(file_to)][path.basename(file_to)] = "F "+sha1;
	} else if ((status & DIFF_ENTRIES) != 0 && file_from && file_from !== file_to) {
		// just renaming
		fs.rename(targetDirectory+"/"+file_from, targetDirectory+"/"+file_to, _);
		checksums[path.dirname(file_to)][path.basename(file_to)] = checksums[path.dirname(file_from)][path.basename(file_from)];
		delete checksums[path.dirname(file_from)][path.basename(file_from)];
	}
	status = 0;
}

// checks whether the current version of the installation matches the patch file, and copies contents to the temp directory
function _checkVersions(parts, _) {
	var oldRelNumber = parts[2];
	var oldPatchNumber = parts[3];
	var newDate = parts[4];
	var newRelNumber = parts[5];
	var newPatchNumber = parts[6];
	var oldHash = parts[7];
	var newHash = parts[8];
	var baseDir = patchtools.BASE_DIRECTORY;
	tracer("checkVersions: Data: oldHash "+oldHash+" old release number "+oldRelNumber+" new hash "+newHash+" new release number "+newRelNumber);				
	// consistency checks
	var versionInformation = {};
	// check whether there is release directory
	if (!patchtools.exists(patchtools.BASE_DIRECTORY+"/"+patchtools.RELEASE_DIRECTORY, _)) {
		tracer("No release directory available");
		versionInformation = patchtools.readVersionFile(patchtools.BASE_DIRECTORY, _);
		if (!versionInformation.init)
			throw new Error(locale.format(module, "noRelease"))
		tracer("Copy recursive . to "+patchtools.RELEASE_DIRECTORY);
		patchtools.copyRec(patchtools.BASE_DIRECTORY, patchtools.BASE_DIRECTORY+"/"+patchtools.RELEASE_DIRECTORY, false, _);
		tracer("End copy recursive . to "+patchtools.RELEASE_DIRECTORY);
	} else {
		if (oldPatchNumber === "0")
			baseDir = patchtools.BASE_DIRECTORY+"/"+patchtools.RELEASE_DIRECTORY;
		versionInformation = patchtools.readVersionFile(baseDir, _);
	}
	tracer("Version information "+util.format(versionInformation))
	if (versionInformation.commit === newHash) // patch already applied
		return null;
	if (versionInformation.commit !== oldHash) 
		throw new Error(locale.format(module, "wrongBaseVersion", versionInformation.relNumber+"-"+versionInformation.patchNumber, versionInformation.comment, oldRelNumber+"-"+oldPatchNumber));
	versionInformation.init = false;
	versionInformation.commit = newHash;
	versionInformation.relNumber = newRelNumber;
	versionInformation.patchNumber = newPatchNumber;
	// copy everything into temporary directory
	tracer("Fast copy recursive "+baseDir+" to "+patchtools.TEMP_DIRECTORY);
	try {
		patchtools.copyRec(baseDir, patchtools.BASE_DIRECTORY+"/"+patchtools.TEMP_DIRECTORY, true, _);
		// copy nodelocal.js into temp directory
		var buf = fs.readFile("nodelocal.js", _);
		patchtools.writeFile(patchtools.BASE_DIRECTORY+"/"+patchtools.TEMP_DIRECTORY+"/nodelocal.js", buf, _);
		
	} catch (e) { // errors in fast copy: check base directory 
		tracer("Error in fast copy "+e);
		var errors = patchtools.checkChecksumsV(baseDir, _);
		if (errors.length > 0) {
			tracer("Errors in checkChecksumsV "+errors.join(", "));
			throw new Error(locale.format(module, "invalidBaseDirectory", baseDir))
		}
		// base directory OK. Therefore full copy
		tracer("Full copy recursive "+baseDir+" to "+patchtools.TEMP_DIRECTORY);
		patchtools.copyRec(baseDir, patchtools.BASE_DIRECTORY+"/"+patchtools.TEMP_DIRECTORY, false, _);
	}
	if (!newPatchNumber) { // extra check when installing new release
		errors = patchtools.checkChecksumsV(patchtools.BASE_DIRECTORY+"/"+patchtools.TEMP_DIRECTORY, _);
		tracer("Check temp directory "+errors.join(";"));
		if (errors.length > 0)
			throw new Error(locale.format(module, "inconsistenciesTemp"))
	}
	tracer("End checkVersion "+util.format(versionInformation));
	return versionInformation;
}	


function getMetaData(contents) {
	var startIndex = contents.indexOf('syracuse patch');
	if (startIndex >= 0) {
		var endIndex = contents.indexOf('\n', startIndex);
		if (endIndex >= 0) {
			return contents.substring(startIndex+15, endIndex);
		}
	}
	return null;
}

/// ------------
/// ## Patch integration in a cluster
/// Arguments: filename on the computer which receives the patch: name of file or directory with patches. Is empty on servers which just get the contents from another server 
///            contents: contents of the patch
function clusterPatch(filename, contents, options, _) {
	if (LOGFILE) {
		try {
			console.log("Delete log file "+LOGFILE);
			fs.unlink(LOGFILE, _)
		} catch (e) {}
	}
	tracer("============= PATCH =================")
	// find out current versions
	tracer("Base directory "+patchtools.BASE_DIRECTORY)
	try {
		fs.mkdir(patchtools.BASE_DIRECTORY+"/"+patchtools.TEMP_DIRECTORY, _);		
	} catch (e) {} // ignore
	var integratePatch = true;
	var currentVersion = patchtools.readVersionFile(patchtools.BASE_DIRECTORY, _);
	var releaseVersion;
	var markIntegration = false; // write into database that new patch is in temp directory
	try {
		releaseVersion = patchtools.readVersionFile(patchtools.BASE_DIRECTORY+"/"+patchtools.RELEASE_DIRECTORY, _);		
	} catch (e) {
		console.error("release directory version file "+e)
		releaseVersion = currentVersion;
	}
	
	tracer("Current version "+util.format(currentVersion)+" "+util.format(releaseVersion));
	if (filename) {
		// preparation of patch files
		contents = collectFiles(patchtools.BASE_DIRECTORY, filename, currentVersion.commit, releaseVersion.commit, _, contents);
		// error or patch already integrated
		if (!contents) return contents;		
	}
	var serverCount = 0; // number of servers on which a patch can be integrated
	if (config.mockServer) {
		var opt = { path: "/nannyCommand/infojson", method: "GET"};
		try {
			var text = mock.simpleRequest(config.mockServer.mockClient, opt, null, _)
			var clusterData = JSON.parse(text);
			clusterData.forEach(function(host) {
				if (host.status >= 3) serverCount++; 
			})
		} catch (e) {				
			console.error("Error "+e);
		}
	}
	var notificationFuture; // notification request to other servers
	var patchMetaData = getMetaData(contents)
	var metadataParts = patchMetaData.split(" ");
	if (!filename || serverCount > 1) { // patch has to be integrated on several hosts
		var data = {patch: patchMetaData};
		var time = ballot.writeVote(null, data, _);
		if (filename) { // notify other servers
			var opt = { path: "/nannyCommand/notifyOtherNannies/notifyOne/patchIntegration", method: "PUT", timeout: PATCH_INTEGRATION_TIMEOUT};
			// start notification as a future
			notificationFuture = mock.simpleRequest(config.mockServer.mockClient, opt, contents);			
		}
		ballot.wait(1000, _);
		var firstServer = ballot.readVotes(data, time, _);
		if (firstServer !== os.hostname()) {
			integratePatch = false;
			markIntegration = true;
			tracer && tracer("No patch integration: different host is first "+firstServer)
		} else {
			var tempVersion = patchtools.readVersionFile(patchtools.BASE_DIRECTORY+'/'+patchtools.TEMP_DIRECTORY, _);
			tracer && tracer("Meta data parts "+patchMetaData+" "+util.format(metadataParts))
			if (tempVersion.commit === metadataParts[6]) { // patch already integrated
				integratePatch = false;
				markIntegration = true;
				console.log("Patch already integrated in temp directory")
			}			
		}
	}
	if (integratePatch) {
		options.content = true;
		normalPatch(patchtools.BASE_DIRECTORY, contents, options, _);	
	}
	if (integratePatch || markIntegration) { // write into database that new patch has been integrated in temp directory
		var db = adminHelper.getCollaborationOrm(_);
		var hostData = db.fetchInstance(_, db.model.getEntity(_, "host"), { hostname: os.hostname() });
		hostData.patchStatus(_, metadataParts[3]+"."+metadataParts[4]);
		hostData.syracuseNoNotifyMarker = true; // do not notify other hosts about this change 
		hostData.save(_);
	}
	// wait for other servers
	if (notificationFuture) {
		try {
			notificationFuture(_);
		} catch (e) {
			console.log("Error in notification "+e)
		}
	}
	if (filename && (integratePatch || markIntegration)) {
		// notify servers that server is about to stop
		require('syracuse-main/lib/syracuse').notifyEnd(_);
		if (config.mockServer) {
			var options = { path: "/nannyCommand/notifyNannies/stopSessions", method: "PUT", headers: {}};
			options.headers[mock.BALANCER_HEADER] = config.port
			try {
				console.log("Sent stop sessions request");
				console.log(mock.simpleRequest(config.mockServer.mockClient, options, null, _));
				console.log("Finish stop sessions request");
			} catch (e) {
				console.log("Error "+e);
			}
		}		
	}
	return 1;
}

exports.clusterPatch = clusterPatch;


function collectFiles(targetDirectory, filename, currentVersion, currentRelease, _, content) {
	// one or more patch files
	var patchfiles;
	if (!content) {
		if (fs.stat(filename, _).isDirectory()) {
			var files = fs.readdir(filename, _);
			patchfiles = [];
			files.forEach(function(file) {
				if (file.lastIndexOf('.dat') === file.length-4) {
					patchfiles.push(filename+"/"+file)
				}
			})
		} else {
			patchfiles = [filename];
		}		
	}
	// copy interesting parts together
	var patchContents = {};
	var currentVersionFits = false;
	var currentReleaseFits = false;
	var currentVersionFitsEnd = false;
	var j = content ? 1 : patchfiles.length;
	while (--j >= 0) {
		var startIndex = 0;
		var metadata = [];
		var lines;
		if (content) {
			console.log("Content given");
			lines = content.split(/[\n\r]+/);
		} else {
			var file = patchfiles[j];
			console.log("Patch file "+file)
			var lines = fs.readFile(file, 'utf8', _).split(/[\n\r]+/);			
		}
		for (var i=0; i<lines.length; i++) {
			var line = lines[i];
			if (line.substr(0, 8) === '2,"ASR",') {
				startIndex = i+1;
				console.log("STARTINDEX "+startIndex)
			}
			if (i === startIndex && line.substr(0, 15) === 'syracuse patch ') {
				metadata = line.substr(15).split(" ");
				tracer && tracer("Syracuse patch "+line.substr(15)+" metadata "+util.format(metadata)+" current "+currentVersion+" "+currentRelease);
				if (metadata[5] === currentVersion) currentVersionFits = true;
				if (metadata[5] === currentRelease) currentReleaseFits = true;
				if (metadata[6] === currentVersion) currentVersionFitsEnd = true;
			};
			if (i === startIndex+1 && line.substr(0, 22) === 'syracuse patchcomment ')
				metadata[7] = line;
			if (line.substr(0, 8) === '7,"ASR",') {
				// end of Syracuse patch section
				if (metadata.length > 7) {
					metadata[8] = lines.slice(startIndex+2, i).join("\n");
					patchContents[metadata[5]] = metadata;
					metadata = []; 
					console.log("PC "+util.format(metadata))
				}
			} 
		}
		if (!startIndex && metadata.length) { // no surrounding elements but Syracuse data
			var endIndex = lines.length;
			if (lines[endIndex-1] === '') endIndex--;
			metadata[8] = lines.slice(2, endIndex).join("\n");			
			patchContents[metadata[5]] = metadata;
			console.log("PC1 "+util.format(metadata))
		}				
	};
	tracer && tracer("curr vers fits "+currentVersionFits+" curr release fits "+currentReleaseFits+" curr vers fits end "+currentVersionFitsEnd )
	var startVersion = (currentVersionFits ? currentVersion : (currentReleaseFits ? currentRelease : null));
	tracer && tracer("start version "+startVersion)
	if (!startVersion) {
		if (currentVersionFitsEnd) return ""; // no patch integration necessary
		// patch does not fit to current version
		throw new Error(locale.format(module, "baseVersionMismatch"));
	}
	// console.log("PATCHCONT "+util.format(patchContents))
	var versions = [startVersion];
	var lastStartVersion = startVersion;
	var lastVersion = startVersion;
	if (lastStartVersion in patchContents) {
		while ((lastVersion = patchContents[lastStartVersion][6]) in patchContents) {
			lastStartVersion = lastVersion;
		}
	}
	if (lastVersion === currentVersion) // patch already integrated
		return "";
	// write final file
	var metadata = patchContents[startVersion];
	var result = "syracuse patch "+metadata[0]+" "+metadata[1]+" ";
	metadata = patchContents[lastStartVersion];
    result += metadata[2]+" "+metadata[3]+" "+metadata[4]+" "+startVersion+" "+metadata[6];
    result += "\n"+metadata[7]+"\n";
	var tempVersion = startVersion;
	while (tempVersion != lastVersion) {
		var metadata = patchContents[tempVersion];
		result += metadata[8]+"\n";
		tempVersion = metadata[6];
	}
	// console.log("RESULT "+result);
	// fs.writeFile(targetDirectory+"/"+patchtools.TEMP_DIRECTORY+"/lastpatch.bbb", result, _);
	return result;
}

// for unit tests
exports.collectFiles = collectFiles;

/// -------------
/// ## Patch integration function `patch`
/// integrate a Syracuse patch
/// Parameters:
/// - targetDirectory: directory in which the file changes should take place
/// - patchdata: name of patch file (may only contain a single Syracuse patch) or contents of patch (when option 'content' is set)
/// - options: tryagain: make full copy if there are errors during patch integration; restart: restart node after integrating the patch; content: patch contents are given
///
/// Result: empty object: patch could be applied, no further action
///         object with versionerror: patch cannot be applied due to version issues; versionerror===null: patch already applied; other values: errors when checking versions
///         object with kill: kill node and execute the contained function
function normalPatch(targetDirectory, patchdata, options, _) {
	if (LOGFILE) {
		try {
			console.log("Delete log file "+LOGFILE);
			fs.unlink(LOGFILE, _)
		} catch (e) {}
	}
	tracer("============= PATCH =================")
	var lines = (options.content ? patchdata : fs.readFile(patchdata, 'utf8', _)).split(/[\n\r]+/);
	if (options.tryagain) {
		try {
			return _patchIntern(targetDirectory, lines, options, _);
		} catch (e) {
			tracer("Exception when integrating patch: "+e);
			// exception when integrating patch: maybe temp directory is corrupt. Full copy
			var errors = patchtools.checkChecksumsV(".", _);
			tracer("Check checksums: "+util.format(errors));
			var baseDirectory = ".";
			if (errors.length > 0) {
				errors = patchtools.checkChecksumsV(patchtools.RELEASE_DIRECTORY, _);
				tracer("Check checksums in release directory: "+util.format(errors));
				if (errors.length === 0)
					baseDirectory = patchtools.RELEASE_DIRECTORY;
				else
					throw new Error(locale.format(module, "corruptDirectories"));				
			}
			tracer("Second attempt after full copying directory "+baseDirectory+" into temp directory")
			patchtools.copyRec(baseDirectory, patchtools.BASE_DIRECTORY+"/"+patchtools.TEMP_DIRECTORY, false, _);
		}
	}
	return _patchIntern(targetDirectory, lines, options, _);
}

// internal function to integrate a patch
function _patchIntern(targetDirectory, lines, options, _) {
	var i;
	var file_from;
	var file_to;
	var sha1_from;
	var sha1_to;
	var status = 0x0; // bits: 1: care about diff entries, 2: input file already loaded, 4: binary content, 8: no line feed at end
	var file_lines;
	var access_rights;
	var checksums = {};
	var versionInformation = null;
	for (i=0; i<lines.length; i++) {
		var line = lines[i];
		if (line.substr(0, 9) === "syracuse ") { // patch meta information
			var parts = line.split(/\s+/);
			tracer("T "+util.format(parts));
			
			if (parts[1] === "patch") {
				tracer("Before checkVersions");
				versionInformation = _checkVersions(parts, _);
				if (versionInformation === null) // patch already applied
						return {versionerror: null};					
				
				tracer("Set targetDirectory");
				targetDirectory = patchtools.BASE_DIRECTORY+"/"+patchtools.TEMP_DIRECTORY;
			}
			if (parts[1] === "patchcomment" && versionInformation) 
				versionInformation.comment = parts.slice(2).join(" ");
		} 
		var m;
		// start of diff
		if (line.substr(0, 5) === "FILE ") {
			_write_data(targetDirectory, status, file_from, file_to, sha1_to, file_lines, checksums, access_rights, _);				
			m = /^FILE (\w) (\d+) \"(.*?)\" \"(.*?)\" (\w*)\-(\w*)/.exec(line);
			if (m) {
				sha1_from = m[5];
				sha1_to = m[6];
				file_from = m[3];
				file_to = m[4] || file_from;
				status = DIFF_ENTRIES;
				if (m[1] === "N") {
					file_from = "";
					file_lines = [];
					status |= LOADED;
				}
				// get access rights of original file
				if (file_from) {
					try {
						var stats = fs.stat(targetDirectory+"/"+file_from, _);
						access_rights = (stats.mode*1 & 0xFFF).toString(8);
					} catch (e)	{
						access_rights = m[2];
					}				
				} else {
					access_rights = m[2];		
				}
				if (status) {
					var parent = path.dirname(file_from);
					if (!(parent in checksums))
						checksums[parent] = patchtools.getChecksumContent(targetDirectory, parent, _);
					parent = path.dirname(file_to);
					if (checksums && !(parent in checksums))
						checksums[parent] = patchtools.getChecksumContent(targetDirectory, parent, _);				
				}
				if (m[1] === "D") {
					fs.unlink(targetDirectory + "/" + file_from, _);
					delete checksums[path.dirname(file_from)][path.basename(file_from)]
					status = 0;
				}
			}
			continue;					
		}
		if (line.substr(0, 8) === "literal " || line.substr(0, 6) === "delta ") {
			var res = _readBinary(lines, i, status !== 0, _);
			i = res.i;
			// end
			if (status) {
				if (res.literal) {
					if (!patchtools.check_sha1_binary(res.buffer, sha1_to))
						throw locale.format(module, "wrongChecksum", file_to)
					patchtools.writeFile(targetDirectory + "/" + file_to, res.buffer, _);
					checksums[path.dirname(file_to)][path.basename(file_to)] = "F "+sha1_to;
					// console.log("NACH fs.write"+file_to+res.buffer.length);
				} else {
					// apply changes
					var binBuffer = new BinBuffer(res.buffer, file_from);
					binBuffer.transform(targetDirectory, file_from, file_to, sha1_from, sha1_to, checksums, _);
				}
				fs.chmod(targetDirectory+"/"+file_to, access_rights, _);
				tracer("Write binary file "+file_to+" access rights "+access_rights);
			}
			// optional information for undoing the patch (not used)
			res = _readBinary(lines, i, false, _);
			i = res.i;
			status = 0;
			i--;
			continue;
		}

		// diff area
		if (m = /^\@\@ \-\d+(?:,(\d+))? +\+(\d+)(?:,(\d+))?(\!)?/.exec(line)) {
			// read input file unless read
			if ((status & (DIFF_ENTRIES+LOADED)) === DIFF_ENTRIES) {
				if (!patchtools.equal_sha1(checksums[path.dirname(file_from)][path.basename(file_from)], sha1_from))
					throw new Error(locale.format(module, "wrongChecksum", file_from))
				file_lines = fs.readFile(targetDirectory + "/" + file_from, 'utf8', _).split(/(?:\r\n|\r|\n)/);
				status |= LOADED;
			}
			// lines count from 1, index counts from 0
			var cur_line = m[2]-1;
			var remainingExistingLines = (m[1] === undefined ? 1 : 1*m[1]);
			var remainingTargetLines = (m[3] === undefined ? 1 : 1*m[3]);
			if (remainingTargetLines == 0)
				cur_line++;
			if (m[4] && remainingExistingLines > 0) { // in compressed patch format there are no deleted lines
				// remove these lines
				file_lines.splice(cur_line, remainingExistingLines)				
				remainingExistingLines = 0;
			}
			i++;
			var partialLine = "";
			while (i < lines.length && (remainingExistingLines > 0 || remainingTargetLines > 0) && (m = /^([\\ \-\+\=])/.exec(lines[i]))) {
				if (!(status & DIFF_ENTRIES))
					break;
				line = lines[i].substr(1);
				switch (m[1]) {
				case ' ': // just test current line
					remainingExistingLines--;
					remainingTargetLines--;
					if (remainingExistingLines < 0 || remainingTargetLines < 0) {
						tracer("Too many lines in diff area at "+lines[i]);						
						status = 0;
					} else if (line !== file_lines[cur_line]) {
						tracer("Line mismatch: >"+line+"< expected: >"+file_lines[cur_line]+"<");
						status = 0;
					}
					cur_line++;
					break;
				case '=': // part of long line
					partialLine += line;
					break;
				case '+': // insert line at current position
					remainingTargetLines--;
					if (remainingExistingLines < 0) {
						tracer("Too many lines deleted at "+lines[i]);
						status = 0;
					} else {
						file_lines.splice(cur_line++, 0, partialLine+line)
						partialLine = "";
					}
					// check for line break
					var next_line = lines[i+1];
					if (next_line.substr(0, 1) !== '+') {
						if (next_line.substr(0, 12) === "\\ No newline") { // no new line at end of appended block
							if (file_lines.length === cur_line+1 && file_lines[cur_line] === '')
								file_lines.pop();
						} else {
							if (file_lines.length === cur_line)
								file_lines.push('');
						}
					}
					// maybe 
					break;
				case '-': // delete line at current position
					// console.log("del");
					remainingExistingLines--;
					if (remainingExistingLines < 0) {
						tracer("Too many lines deleted at "+i+" "+lines[i]);
						status = 0;
					} else if (line !== file_lines[cur_line]) {
						tracer("Line mismatch: >"+line+"< expected: >"+file_lines[cur_line]+"<");
						status = 0;
					} else {
						file_lines.splice(cur_line, 1)
					}
					break;
				case '\\': // no new line
					break;
				}
				if (remainingExistingLines < 0 || remainingTargetLines < 0) {
						tracer("Too many lines");
						status = 0;
				}
				i++;
			}
			i--;
			continue;
		}	
		// this code is here just for compatibility and to run old unit tests. This enables the module to read git diff output directly
		if (line.substr(0, 10) === 'diff --git') {
			_write_data(targetDirectory, status, file_from, file_to, sha1_to, file_lines, checksums, access_rights, _);				
			if (m = /^diff --git a\/(.*) b\/\1$/.exec(line)) {
				file_from = m[1];
				file_to = m[1];
				sha1_from = "";
				sha1_to = "";
				status = DIFF_ENTRIES;				
			} else
			if (m = /^diff --git a\/(\S+) b\/(\S+)$/.exec(line)) {
				file_from = m[1];
				file_to = m[2];
				sha1_from = "";
				sha1_to = "";
				status = DIFF_ENTRIES;
			} else {
				status = 0;
				tracer('wrong file names in '+line);
			}
			if (status) {
				var parent = path.dirname(file_from);
				if (!(parent in checksums))
					checksums[parent] = patchtools.getChecksumContent(targetDirectory, parent, _);
				parent = path.dirname(file_to);
				if (checksums && !(parent in checksums))
					checksums[parent] = patchtools.getChecksumContent(targetDirectory, parent, _);				
			}
			continue;
		}
		if (line.substr(0, 6) === 'index ') {
			var r = /^index ([0-9a-f]+)\.\.([0-9a-f]+)(?:\s+(\d+))?/.exec(lines[i]);
			if (r) {			
				sha1_from = r[1];
				sha1_to = r[2];
				var tmp_rights = r[3] || "";
				access_rights = tmp_rights.substr(tmp_rights.length-3);
				// console.log("SHA1 "+sha1_from+" "+sha1_to);
			} else {
				status = 0;
				tracer('no index available for '+file_from);
			}
		}
		if (line.substr(0, 8) === 'new file') {
			file_from = "";
			file_lines = [];
			status |= LOADED;
			continue;
		}
		if (line.substr(0, 12) === 'deleted file') {
			fs.unlink(targetDirectory + "/" + file_from, _);
			delete checksums[path.dirname(file_from)][path.basename(file_from)]
			status = 0;
			continue;
		}
		if (line.substr(0, 3) === '+++' || line.substr(0, 3) === '---' || /^(?:copy|rename|GIT binary) /.exec(line))
			continue;
	}
	_write_data(targetDirectory, status, file_from, file_to, sha1_to, file_lines, checksums, access_rights, _);
	if (patchtools.exists(patchtools.EXTRA_FUNCTIONS, _)) {
		tracer("Copy "+patchtools.EXTRA_FUNCTIONS+" to "+targetDirectory+"/"+patchtools.EXTRA_FUNCTIONS_OLD)
		var extraOld = fs.readFile(patchtools.EXTRA_FUNCTIONS, _)
		patchtools.writeFile(targetDirectory+"/"+patchtools.EXTRA_FUNCTIONS_OLD, extraOld, _);
		// update checksum for copy of extra.fkt
		if (!("." in checksums))
			checksums["."] = patchtools.getChecksumContent(targetDirectory, ".", _) 
		checksums["."][patchtools.EXTRA_FUNCTIONS_OLD] = "F "+patchtools.get_sha1_binary(extraOld);
	}
	var sha1 = patchtools.updateChecksums(targetDirectory, checksums, _);	
	if (versionInformation) {
		versionInformation.sha1 = sha1;
		// write new version information
		tracer("Write version information "+JSON.stringify(versionInformation))		
		patchtools.writeFile(patchtools.BASE_DIRECTORY+"/"+patchtools.TEMP_DIRECTORY+"/"+patchtools.VERSION_FILE, new Buffer(JSON.stringify(versionInformation)), _);
	}
	return {};
}

exports.normalPatch = normalPatch;


