"use strict";

var child_process = require('child_process');
var util = require('util');
var write = require('./write');
var fs = require('fs');
var path = require('path');
var os = require('os');

// sha1 hash of first commit of the Syracuse repository
var FIRST_COMMIT = '9c1bdb6f3144a8295416acb66197f1a99ce4d71e';
var CONFIG_FILE = "config.txt";

var LOGFILE = os.tmpDir()+"/patch.log"

// var patchlogger = console.log;
var patchlogger = function(text) {
	fs.appendFileSync(LOGFILE, text+"\n")
}

// markers for patch and release
var PATCH = "PATCH";
var RELEASE = "RELEASE";

/// returns array of all releases. If testRelease is given, it checks whether the value is contained 
/// in the list of releases. If not, an exception occurs
function taglist(globalConfig, testRelease, _) {
	var tags = [];
	var tmptags = execute('git tag', globalConfig.rolloutRepo, _).trim().split(/[\r\n\s]+/);
	var found = !testRelease
	var i = 0;
	while (i < tmptags.length) {		
		var tag = tmptags[i++];
		if (/^T\d[\d\.]*$/.test(tag))
			tags.push(tag.substr(1));
		if (!found && "T"+testRelease === tag)
			found = true;
	}
	if (!found)
		throw new Error("Release "+testRelease+ " does not exist");
	return tags;
}

/// function patch
/// create a Syracuse patch
/// Parameters: 
///   newPatch generate new patch from source repository into roll-out repository
///   startFromRelease output patch file should start from latest release rather than from latest patch
///   newRelease generate new release (implies newPatch)
///   relNumberNew number of new release (only necessary if newRelease is true). Release number must only consist of digits and dots and must be greater than 
///       previous release number
///   commitComment comment. This is obligatory if newPatch or newRelease is true. Otherwise the contents will override the comment of the latest patch/release (if set)
///   baseRelease  optional: number of release for which the action should be performed. Default is latest release
///   patchfile: path of patchfile which will be generated
///   sha1Old:  SHA1 hash of commit of base version of patch file in roll-out repository. Must not be set when new patch/release will be created. Will be set to hash of latest patch of base release or base release itself if empty.
///   sha1New:  SHA1 hash of commit of final version of patch file in roll-out repository. Must not be set when new patch/release will be created. Default: HEAD.
///   Remark: for each new patch/release there must be changes of the roll-out repository to commit, e. g. if a patch of just node.js should be delivered, there must be data to commit in the roll-out repository
///    (e. g. just stage the changes in node.js)
function patch(newPatch, startFromRelease, newRelease, relNumberNew, commitComment, baseRelease, patchfile, sha1Old, sha1New, globalConfig, _) {
	try {
		console.log("Delete log file "+LOGFILE);
		write.unlink(LOGFILE, _)
	} catch (e) {}
	if (!globalConfig) 
		throw new Error("No patch without patch settings in global configuration object");
	if (!write.exists(globalConfig.rolloutRepo, _))
		throw new Error("Roll-out repository path does not exist: "+globalConfig.rolloutRepo)
	patchlogger("START PATCH newPatch "+newPatch+" startFromRelease "+startFromRelease+" newRelease "+newRelease+" relNumberNew "+relNumberNew+" commitComment "+commitComment+" baseRelease "+baseRelease+" sha1Old "+sha1Old+" sha1New "+sha1New+" patchfile "+patchfile);
	patchlogger("Rollout repository "+globalConfig.rolloutRepo+" Customer image directory "+globalConfig.customerImage);
	// get list of tags, select tags which start with 'R' and strip 'R' 
	var tags = taglist(globalConfig, baseRelease, _);
	patchlogger("releases "+util.format(tags));
	if (tags.length == 0) {
		if (!newRelease)
			throw new Error("No release data available. New release must be created");
	} else {
		if (!baseRelease)
			baseRelease = tags[tags.length-1]; // latest release by default
	}
	if (newRelease) {
		if (!relNumberNew)
			throw new Error("Release number for new release must be provided");
		if (!/^\d[\d\.]*$/.test(relNumberNew))
			throw new Error("Release number can only consist of digits and dots "+relNumberNew);
		if (baseRelease) {
			if (baseRelease !== tags[tags.length-1])
				throw new Error("For new release, base release must be latest release");
			if (relNumberNew <= baseRelease)
				throw new Error("For new release, number must be greater than number of base release "+baseRelease);
		}
		newPatch = true;
	}
	
	if (newPatch && (sha1Old || sha1New))
		throw new Error("No explicit commit hashes when new patch/release is created");
	
	// switch roll-out repo to correct release. Branch name is R+(release number)
	if (baseRelease)
		execute('git checkout -f R'+baseRelease, globalConfig.rolloutRepo, _);	
	
	var baseVersion; // base version for patch file
	var latestPatch; // latest patch of roll-out repository for updating roll-out repository from source repository when a new version is created
	var targetVersion; // final version for patch file
	if (tags.length > 0) { // get log data from git
		if (sha1Old) {			
			baseVersion = commitDataFromHash(sha1Old, globalConfig, _)
		} else {
			var gitlog = new GitLog(globalConfig.rolloutRepo);
			latestPatch = gitlog.next(false, _);
			if (!latestPatch)
				throw new Error("Inconsistency: Tags available but no release");				
			if (startFromRelease) {
				if (newPatch) { // a new patch/release will be created. Then old version is latest already available release
					if (latestPatch.release) // latest current patch is release
						baseVersion = latestPatch; 
					else 
						baseVersion = gitlog.next(true, _);
				} else { // previous version is latest release before latest patch
					baseVersion = gitlog.next(true, _);
				}
			} else {
				if (newPatch) // a new patch/release will be created. Then old version is latest already available patch/release
					baseVersion = latestPatch;
				else // set previous version which is patch/release before latest patch
					baseVersion = gitlog.next(false, _);
			}
		}
	}
	if (newPatch) { // collect data for new patch or release (newPatch will be set if newRelease is set)
		// configuration for copying contents to roll-out repository
		var config = readConfig(_);
		// take rolloutRepo from globalConfig so that globalConfig need not be passed to all functions
		config.rolloutRepo = globalConfig.rolloutRepo;
		patchlogger("-------------- Collect files for patch");
		if (!commitComment) {
			throw new Error("No comment provided");
		}
		if (newRelease && latestPatch) {
			// create new branch for new release
			execute('git branch R'+relNumberNew, globalConfig.rolloutRepo, _);
			execute('git checkout -f R'+relNumberNew, globalConfig.rolloutRepo, _);
		}
		var sourceCommitOld = (latestPatch ? latestPatch.source : FIRST_COMMIT);
		var sourceCommitCurrent = execute('git log -1 --pretty=format:%H', ".", _);
		collect(sourceCommitOld, sourceCommitCurrent, config, _);
		// commit data
		var comment = [];
		if (newRelease)
			comment.push("RELEASE");
		else
			comment.push("PATCH");
		comment.push(sourceCommitCurrent);
		// maybe for release number
		if (newRelease)
			comment.push(relNumberNew);
		else
			comment.push(baseRelease);
		// add real comment
		comment.push(commitComment);
		
		// are there changes?
		var status = execute('git status --porcelain', globalConfig.rolloutRepo, _);
		if (!status)
			throw new Error("No resulting changes in roll-out repository");
		// commit the changes
		execute('git commit -m "'+comment.join(" ")+'"', globalConfig.rolloutRepo, _);
		if (newRelease) {
			if (!latestPatch) {
				// create new branch
				execute('git branch R'+relNumberNew, globalConfig.rolloutRepo, _);
			}
			// create tag
			execute('git tag T'+relNumberNew, globalConfig.rolloutRepo, _);
		}
		// get the hash of the current commit
		patchlogger("-------------- Roll-out repository updated");
		if (!latestPatch) {			
			createCustomerImage(globalConfig, _, relNumberNew, rolloutCommitCurrent, commitComment);
			return; // do not create patch file 
		} else { // set data of targetVersion to the really latest new data 
			targetVersion = commitDataFromHash("HEAD", globalConfig, _);
		}
	} else {
		if (sha1New)
			targetVersion = commitDataFromHash(sha1New, globalConfig, _);
		else
			targetVersion = commitDataFromHash("HEAD", globalConfig, _);
	}
	// create patch file
	if (baseVersion.rollout === targetVersion.rollout) 
		throw new Error("Base version equals target version - empty patch");
	if (baseVersion.relNumber > targetVersion.relNumber)
		throw new Error("No release downgrade with patch from "+baseVersion.relNumber+" to "+targetVersion.relNumber);
	patchlogger("-------------- Create patch file "+patchfile);
	if (!patchfile)
		throw new Error("Patch file name missing");
	var header = [ "syracuse patch", baseVersion.rollout, baseVersion.release ? baseVersion.relNumber : "-", targetVersion.rollout, targetVersion.release ? targetVersion.relNumber : "-", targetVersion.comment];
	var patchElement = '"SYR","PATCH","'+targetVersion.comment+'"\n';
	executeF('git diff --irreversible-delete --minimal --binary --no-color --unified=0 '+baseVersion.rollout+' '+targetVersion.rollout, globalConfig.rolloutRepo, patchfile, '1,"","ENG","1","","X3","1",\n2,'+patchElement+header.join(" ")+"\n", '**********\n7,'+patchElement+'8,""\n', _);
	patchlogger("-------------- Patch file created");
	patchlogger("END PATCH");
}

exports.patch = patch;



/// creates customer image from rollout repository which contains all necessary metadata for Syracuse patching, but no .git data
/// parameters:
///  globalConfig: paths of rollout repository and customer image
/// optional parameters:
/// release: release number of release (latest release if empty)
/// releaseHash: sha1 of latest release,
/// releaseComment: commit comment of latest release 
function createCustomerImage(globalConfig, _, release, releaseHash, releaseComment) {
	if (!globalConfig || !globalConfig.rolloutRepo || !globalConfig.customerImage) {
		throw new Error("Directories must be given "+util.format(globalConfig));
	}
	if (!write.exists(globalConfig.rolloutRepo, _))
		throw new Error("Roll-out repository path does not exist: "+globalConfig.rolloutRepo)
	patchlogger("-------------- Create customer image "+globalConfig.customerImage+" from "+globalConfig.rolloutRepo);
	// find out or check release
	var tags = taglist(globalConfig, release, _);
	if (tags.length === 0)
		throw new Error("Customer repository empty")
	if (!release)
		release = tags[tags.length-1];
	// remove existing customerImage
	if (write.exists(globalConfig.customerImage, _)) {
		if (fs.stat(globalConfig.customerImage, _).isDirectory) {
			patchlogger("Delete existing directory "+globalConfig.customerImage);
			write.rmdirRec(globalConfig.customerImage, _);
		} else {
			patchlogger("Delete existing file "+globalConfig.customerImage);
			write.unlink(globalConfig.customerImage, _);
		}
	}
	// use git to create a copy of repository which has unix style line endings (-l: local copy, -s: do not copy objects)
	execute('git clone -l -s -c core.eol=lf -c core.autocrlf=input --branch T'+release+' '+globalConfig.rolloutRepo+' '+globalConfig.customerImage, ".", _);
	if (!releaseHash || !releaseComment) {
		var gitlog = new GitLog(globalConfig.customerImage, _);
		var newVersion = gitlog.next(false, _);
		if (!newVersion)
			throw new Error("Inconsistency: Tags available but no release");
		releaseHash = newVersion.rollout;
		releaseComment = newVersion.comment;
	}
	// delete git contents of customer image
	patchlogger("Delete .git subdirectory")
	write.rmdirRec(globalConfig.customerImage+"/.git", _);
	// create checksum files
	patchlogger("Write checksum files")
	var	sha1 = write.makeChecksums(globalConfig.customerImage, _);
	// create file for initial version
	var initialVersion = JSON.stringify({commit: releaseHash, relNumber: release, comment: releaseComment, init: true, release: true, sha1: sha1});
	patchlogger("Write "+write.VERSION_FILE+": "+initialVersion);
	write.writeFile(globalConfig.customerImage+"/"+write.VERSION_FILE, initialVersion, _);
	patchlogger("Double-check checksums");
	var errors= write.checkChecksumsV(globalConfig.customerImage, _) 
	if (errors.length > 0) {
		throw new Error("Errors when checking checksums "+errors.join("\n"));
		patchlogger("errors when checking checksums "+errors.join(","))		
	}
	patchlogger("-------------- Create customer image completed");
}

exports.createCustomerImage = createCustomerImage;

/// reads config file and writes results to config object: transformationRules as an array of regular expressions with corresponding actions,
///  commands hash with one time action names and corresponding batch file invocations
function readConfig(_) {
	patchlogger("Read config file");
	var contents = fs.readFile(__dirname +"/"+ CONFIG_FILE, "utf8", _);
	var lines = contents.split(/(?:\r\n|\r|\n)/);
	var config = {};
	config.transformationRules = [];
	config.commands = {};
	var i = 0;
	var r;
	var section = ""; 
	while (i < lines.length){
		var line = lines[i++];
		r = /^(\w+)\s+(.*)/.exec(line);
		if (r) {
			if (section === "files") { // associations of file paths to actions
				if (r[1].indexOf('_') === 0 && !(r[1] in config.commands))
					throw new Error("Command "+r[1]+ " is not defined");
				config.transformationRules.push(makeRule(r[1], r[2]));
			} else if (section === "commands"){	// definitions of one time actions
				if (!/\w.*\|.*\w/.test(r[2]))
					throw new Error("Wrong format of command "+r[2]);
				config.commands[r[1]] = r[2];
			} 
		} else {
			r = /^\[(\w+)\]/i.exec(line)
			if (r)
				section = r[1].toLowerCase();			
		}
	}
	patchlogger("Rules "+util.format(config));
	return config;
}	
	
function execute(cmdline, directory, callback) {
	patchlogger("EXECUTE ("+directory+") "+cmdline)
	if (!directory)
		return callback(new Error("Working directory empty"));
	child_process.exec(cmdline, {maxBuffer: 1024*1024, cwd: directory }, function(error, stdout, stderr) {
		if (error !== null) {
			patchlogger("Error: "+stdout+" "+stderr)
			return callback(error);
		}
		if (stderr)
			patchlogger('Warning: '+stderr);
		return callback(null, stdout);
	});
}


function executeF(cmdline, directory, outputFile, prefix, postfix, callback) {
	patchlogger("EXECUTEF ("+directory+", "+outputFile+") "+cmdline);
	var args = cmdline.trim().split(/\s+/);
	var stderr = "";
	write.createWriteStream(outputFile, function(error, output) {
		if (error)
			return callback(error);
		// make stream buffered
		output.markReady = true;
		output.buffers = [];
		output.writeOrEnd = function(data) {
			if (data === undefined) {
				this.end();
				this.destroy();
				this.markReady = false;
				return callback(null, 0);
			} else
				this.markReady = this.write(data);
		};
		output.writeBuffered = function(data) {
			if (!this.markReady)
				this.buffers.push(data);
			else 
				this.writeOrEnd(data);
		};
		output.on('drain', function() {
			if (!output.markReady) {
				output.markReady = true;
			}
			while (output.buffers.length > 0 && output.markReady) 
				output.writeOrEnd(output.buffers.shift());
		});
		// real code
		output.writeBuffered(prefix);
		var child = child_process.spawn(args[0], args.slice(1), { cwd: directory});
		child.stdout.on('data', function (data) {
			output.writeBuffered(data);
		});
		child.stderr.on('data', function(data) {
			stderr += data.toString("utf8");
		});
		child.on('exit', function (code) {
			if (code !== 0) {
				return callback(stderr);
			} else {
				output.writeBuffered(postfix);
				// end the stream
				output.writeBuffered(undefined);
				if (stderr)
					console.error(stderr);
			}
		})
	});
}


// adds file name for git commit
function gitadd(filename, config, _) {
	execute('git add "'+filename+'"', config.rolloutRepo, _);
}


// apply encrypt and copy rule for one file
function applyRule(rulename, filename, mode, config, _) {
	if (rulename === "ignore")
		return;
	var targetFileName = filename;
	if (rulename === "encrypt") // change file name when encrypting
		targetFileName = encryptName(filename);
	var fullTargetFileName = config.rolloutRepo + "/" + targetFileName;
	if (mode === "D") // delete and mark file for commit
		execute('git rm '+targetFileName, config.rolloutRepo, _);
	else {
		if (rulename === "copy") { // copy file 
			var buff = fs.readFile(filename, _);
			write.writeFile(fullTargetFileName, buff, _);
		} else 
			encrypt(filename, fullTargetFileName, _);
		// add file for git commit
		gitadd(targetFileName, config, _);
	}
	return;
}

// parse file path pattern and replace backslashes and convert "**/", "*", "?" into regular expressions
function makeRule(name, pattern) {
	// make regular expression
	// replace backslashes with slashes for paths
	pattern = pattern.replace(/\\/g, "/");
	// temporary replace of **/
	pattern = pattern.replace(/\*{2,}\//g, "\0");
	// replace *
	pattern = pattern.replace(/\*+/g, "[^\\/]*");
	// replace ?
	pattern = pattern.replace(/\?/g, "[^\\/]");
	// mask of .
	pattern = pattern.replace(/\./g, "\\.");
	// real replace of **/
	pattern = pattern.replace(/\x00/g, "(?:.*\/)?");
	return [new RegExp("^"+pattern+"$"), name];
}

/// parse a line for a one time action and replace $$, $/, $R, $S, $1..$9 with corresponding values
function replacements(line, rolloutRepo) { 			// split with '|'
	var index = line.indexOf('|');
	var files = line.substr(0, index).trim().split(/\s+/);
	files = files.map(function(element) { return path.normalize(element.replace(/\\/g, "/"))});
	line = line.substr(index+1).trim();
	// 	temporarily replace $$
	line = line.replace(/\$\$/g, "\0");
	// file names
	line = line.replace(/\$([1-9])/g, function(str, number) { return files[number-1]});
	// 	slash
	line = line.replace(/\$\//g, path.sep);
	// source repository
	line = line.replace(/\$S/g, path.normalize(process.cwd()))
	// roll-out repository
	line = line.replace(/\$R/g, path.normalize(rolloutRepo));
	// finally replace $$ with $.
	line = line.replace(/\x00/g, "$");
	files.command = line;
	return files;
}

function executeDiff(diff, applyRule, config, _) {
	var pattern = /([A-Z]+)\s+(.*)/g;
	var ruleName;
	var r;
	var oneTimeActions = {}; // actions which only should be applied once
	while (r = pattern.exec(diff)) {
		var filename = r[2];
		var filemode = r[1];
		var i = 0;
		var match = false;
		while (i < config.transformationRules.length) {
		    var rule = config.transformationRules[i++];
			var ru = rule[1];
			if (rule[0].test(filename)) {
				patchlogger(ru+"("+i+") "+r[0]);
				match = true;
					if (ru === "ignore")
						break;
					if (ru.indexOf('_') === 0) {
						oneTimeActions[ru] = "";
						break;
					}
					if (ru === "extra") {
						var contents = fs.readFile(filename, "utf8", _);
						var functionPattern = /(?:^|[\r\n])\s*exports\.(patch\w+)/g;
						var regexpResult;
						oneTimeActions.extra = oneTimeActions.extra || [];
						while (regexpResult = functionPattern.exec(contents)) {
							patchlogger("Pattern for extra function "+regexpResult[1]);
							oneTimeActions.extra.push(filename+ " "+regexpResult[1]);
						}						
					} else {
						applyRule(ru, filename, filemode, config, _);
					}
				if (ru !== "extra") {
					break; // no more rules to examine					
				}
			}
		}
		if (!match)
			patchlogger("Warning: no rule for "+r[0])
	}
	patchlogger("END EXEC");
	return oneTimeActions;
}

/// collect differences from git log
function collect(oldCommit, newCommit, config, _) {
	// log differences
	var diff = execute('git diff --name-status '+oldCommit+' '+newCommit, '.', _);
	if (!diff) {
		throw new Error("No difference found - patch would be empty");
	}
	var oneTimeActions = executeDiff(diff, applyRule, config, _);
	diff = ""; // data are not necessary any more
	// execute oneTimeActions
	if ("extra" in oneTimeActions) {
		patchlogger("EXTRA "+oneTimeActions.extra.sort().join("##"))
		write.writeFile(config.rolloutRepo+"/"+write.EXTRA_FUNCTIONS, oneTimeActions.extra.sort().join("\n") + "\n", _);
		gitadd(write.EXTRA_FUNCTIONS, config, _);
		delete oneTimeActions.extra;
	}
	var actions = [];
	for (var action in oneTimeActions)
		actions.push(action);
	var i = actions.length;
	while (--i >= 0) { // one time action as a batch file
		patchlogger("One time action "+actions[i]);
		var result = replacements(config.commands[actions[i]], config.rolloutRepo);
		// execute the command
		try {
			execute(result.command, ".", _);
		} catch (e) {
			throw new Error("Error in one time action "+actions[i]+" with command "+result.command+": "+e);
		}
		try {
			// mark files as changed
			gitadd(result.join(" "), config, _);
		} catch (e) {
			throw new Error("Error in one time action "+actions[i]+" with files "+result.join(" ")+": "+e);
		}
	}
}




function GitLog(directory) {
	this._logs = [];
	this.finished = false;
	this._i = 1;
	
	// get data from previous release or patch
	// parameter release: only look for release commits
	this.next = function(release, _) {
		while (!this.finished) {		
			while (this._i < this._logs.length) {
				var res = commitData(this._logs[this._i++], release);
				if (res)
					return res;
			}	
			var currentCommit = "HEAD";
			if (this._logs.length > 0) {
				currentCommit = this._logs[this._logs.length-1].substr(0, 40);
				this._i = 1;
			} else
				this._i = 0;
			this._logs = execute('git log -100 --pretty=oneline '+currentCommit, directory, _).split(/[\r\n]+/);
			if (!this._logs[this._logs.length-1])
				this._logs.pop();
			if (this._logs.length <= this._i) {
				this.finished = true;
				return null;
			} 
		}
		return null;
	}
}

// extract information from "git log --pretty=oneline" line
function commitData(line, release) {
	patchlogger("commitData "+release+" "+line);
	var pattern = release ? /(\w{40}) (RELEASE) (\w{40}) ([\d\.]+) (.*)/ : /(\w{40}) (PATCH|RELEASE) (\w{40}) ([\d\.]+) (.*)/;
	var r = pattern.exec(line);
	if (r)
		return { release: (r[2] === "RELEASE"), source: r[3], rollout: r[1], relNumber: r[4], comment: r[5] };
	return null;
}

// invoke git to get all data from the commit with the given sha1 checksum
function commitDataFromHash(sha1, globalConfig, _) {
	var result = commitData(execute('git log -1 --pretty=oneline '+sha1, globalConfig.rolloutRepo, _), false);
	if (!result)
		throw new Error("Inconsistency: No data for commit "+sha1);
	return result;
}




// for unit tests
exports.makeRule = makeRule;
exports.executeDiff = executeDiff;
exports.replacements = replacements;
exports.commitData = commitData;


function encryptName(filename) {
	return filename + "E";
}

function encrypt(sourceFile, targetFile, _) {
	var content = fs.readFile(sourceFile, "utf8", _);
	content = "E###E" + content + "F###F";
	write.writeFile(targetFile, content, _);
}
