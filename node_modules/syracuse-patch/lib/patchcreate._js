"use strict";

var child_process = require('child_process');
var util = require('util');
var write = require('./write');
var fs = require('fs');
var path = require('path');
var os = require('os');

// sha1 hash of first commit of the repository
// var FIRST_COMMIT = '3b77cf6f501cc5cfb822a214babe069138918c0e' 
var FIRST_COMMIT = '9c1bdb6f3144a8295416acb66197f1a99ce4d71e';
var CONFIG_FILE = "config.txt";

var LOGFILE = os.tmpDir()+"/patch.log"

// var patchlogger = console.log;
var patchlogger = function(text) {
	fs.appendFileSync(LOGFILE, text+"\n")
}

// markers for patch and release
var PATCH = "PATCH";
var RELEASE = "RELEASE";

/// function patch
/// create a Syracuse patch
/// Parameters: 
///   newPatch generate new patch from source repository into roll-out repository
///   startFromRelease output patch file should start from latest release rather than from latest patch
///   newRelease generate new release (implies newPatch)
///   relNumberNew number of new release (only necessary if newRelease is true). Release number must only consist of digits and dots and must be greater than 
///       previous release number
///   commitComment comment. This is obligatory if newPatch or newRelease is true. Otherwise the contents will override the comment of the latest patch/release (if set)
///   baseRelease  optional: number of release for which the action should be performed. Default is latest release
function patch(newPatch, startFromRelease, newRelease, relNumberNew, commitComment, baseRelease, patchfile, _) {
	try {
		console.log("Delete log file "+LOGFILE);
		fs.unlinkSync(LOGFILE)
	} catch (e) {}
	patchlogger("START PATCH newPatch "+newPatch+" startFromRelease "+startFromRelease+" newRelease "+newRelease+" relNumberNew "+relNumberNew+" commitComment "+commitComment+" baseRelease "+baseRelease+" patchfile "+patchfile);
	// get list of tags, select tags which start with 'R' and strip 'R' 
	var config = {};
	try {
		config = readConfig(CONFIG_FILE);
	} catch (e) { throw e };
	var tmptags = execute('git tag', config.rollOutRepo, _).trim().split(/[\r\n\s]+/);
	var tags = [];
	var i = 0;
	while (i < tmptags.length) {
		var tag = tmptags[i++];
		if (/^T\d[\d\.]*$/.test(tag))
			tags.push(tag.substr(1));
	}
	tmptags = null;
	patchlogger("releases "+util.format(tags));
	if (tags.length == 0 && !newRelease) {
		throw new Error("No release data available. New release must be created");
	}
	if (tags.length > 0) {
		if (baseRelease) {
			var i = tags.length;
			while (--i >= 0)
				if (baseRelease === tags[i])
					break;
			if (i < 0)
				throw new Error("Given value of base release "+baseRelease+" is no valid release. Valid releases: "+tags.join(", "));
		} else {
			baseRelease = tags[tags.length-1]; // latest release by default
		}
	}
	if (newRelease) {
		if (!relNumberNew)
			throw new Error("Release number for new release must be provided");
		if (!/^\d[\d\.]*$/.test(relNumberNew))
			throw new Error("Release number can only consist of digits and dots "+relNumberNew);
		if (baseRelease) {
			if (baseRelease !== tags[tags.length-1])
				throw new Error("For new release, base release must be latest release");
			if (relNumberNew <= baseRelease)
				throw new Error("For new release, number must be greater than number of base release "+baseRelease);
		}
		newPatch = true;
	}
	
	// switch roll-out repo to correct release. Branch name is R+(release number)
	if (baseRelease)
		execute('git checkout -f R'+baseRelease, config.rollOutRepo, _);	
	
	var latestPatch;
	var previousVersion; // old version of roll-out repository for creating patch file
	var rolloutCommitCurrent;
	if (tags.length > 0) { // get log data from git
		var gitlog = new GitLog(config.rollOutRepo, _);
		latestPatch = gitlog.next();
		if (!latestPatch)
			throw new Error("Inconsistency: Tags available but no release");				
		if (startFromRelease) {
			if (newPatch) { // a new patch/release will be created. Then old version is latest already available release
				if (latestPatch.release) // latest current patch is release
					previousVersion = latestPatch; 
				else 
					previousVersion = gitlog.nextRelease();
			} else { // previous version is latest release before latest patch
				previousVersion = gitlog.nextRelease();
			}
		} else {
			if (newPatch) // a new patch/release will be created. Then old version is latest already available patch/release
				previousVersion = latestPatch;
			else // set previous version which is patch/release before latest patch
				previousVersion = gitlog.next();
		}
	}
	
	if (newPatch) { // collect data for new patch or release (newPatch will be set if newRelease is set)
		patchlogger("-------------- Collect files for patch");
		if (!commitComment) {
			throw new Error("No comment provided");
		}
		if (newRelease && latestPatch) {
			// create new branch for new release
			execute('git branch R'+relNumberNew, config.rollOutRepo, _);
			execute('git checkout -f R'+relNumberNew, config.rollOutRepo, _);
		}
		var sourceCommitOld = (latestPatch ? latestPatch.source : FIRST_COMMIT);
		var sourceCommitCurrent = execute('git log -1 --pretty=format:%H', ".", _);
		collect(sourceCommitOld, sourceCommitCurrent, config, _);
		// commit data
		var comment = [];
		if (newRelease)
			comment.push("RELEASE");
		else
			comment.push("PATCH");
		comment.push(sourceCommitCurrent);
		// maybe for release number
		if (newRelease)
			comment.push(relNumberNew);
		else
			comment.push(baseRelease);
		// add real comment
		comment.push(commitComment);
		
		// first version: add .gitignore for versioning file
		if (!latestPatch) {
			patchlogger("Write .gitignore");
			fs.appendFile(config.rollOutRepo+"/.gitignore", "\n"+write.VERSION_FILE+"\n", _);
			gitadd(".gitignore", config, _);
		}
		// are there changes?
		var status = execute('git status --porcelain', config.rollOutRepo, _);
		if (!status)
			throw new Error("No resulting changes in roll-out repository");
		// commit the changes
		execute('git commit -m "'+comment.join(" ")+'"', config.rollOutRepo, _);
		if (newRelease) {
			if (!latestPatch) {
				// create new branch
				execute('git branch R'+relNumberNew, config.rollOutRepo, _);
			}
			// create tag
			execute('git tag T'+relNumberNew, config.rollOutRepo, _);
		}
		// get the hash of the current commit
		rolloutCommitCurrent = execute('git log -1 --pretty=format:%H', config.rollOutRepo, _);
		if (!latestPatch) {
			var initialVersion = JSON.stringify({commit: rolloutCommitCurrent, relNumber: relNumberNew, comment: commitComment, init: true, release: true});
			patchlogger("Write "+write.VERSION_FILE+": "+initialVersion);
			write.writeFile(config.rollOutRepo+"/"+write.VERSION_FILE, initialVersion, _);
		}
		patchlogger("-------------- Roll-out repository updated");
	} else {
		rolloutCommitCurrent = latestPatch.rollout;
	}
	if (latestPatch) { // create patch file		
		patchlogger("-------------- Create patch file");
		if (!previousVersion) 
			throw new Error("No previous patch/release available");
		if (!patchfile)
			throw new Error("Patch file name missing");
		if (!commitComment)
			commitComment = latestPatch.comment;
		var patchElement = '"SYR","PATCH","'+commitComment+'"\n';
		var header = [ "syracuse patch", previousVersion.rollout];
		if (previousVersion.release) { // start from release
			header.push(previousVersion.relNumber);			
		} else 
			header.push("-");			
		header.push(rolloutCommitCurrent);		
		if (newRelease) // end in release
			header.push(relNumberNew)
		else
			header.push("-");
		header.push(commitComment)
		var patchElement = '"SYR","PATCH","'+commitComment+'"\n';
		executeF('git diff --irreversible-delete --minimal --binary --no-color --unified=0 '+previousVersion.rollout+' '+rolloutCommitCurrent, config.rollOutRepo, patchfile, '1,"","ENG","1","","X3","1",\n2,'+patchElement+header.join(" ")+"\n", '**********\n7,'+patchElement+'8,""\n', _);
		patchlogger("-------------- Patch file created");
	}
	patchlogger("END PATCH");
}

exports.patch = patch;
	
function readConfig(filename) {
	patchlogger("Read config file "+filename);
	var contents = fs.readFileSync(filename || CONFIG_FILE, "utf8");
	var lines = contents.split(/[\r\n]+/);
	var config = {};
	config.transformationRules = [];
	config.commands = {};
	var i = 0;
	var r;
	var section = ""; 
	while (i < lines.length){
		var line = lines[i++];
		r = /(?:^|[\r\n])(\w+)\s+(.*)/.exec(line);
		if (r) {
			if (section === "files") { // associations of file paths to actions
				if (r[1].indexOf('_') === 0 && !(r[1] in config.commands))
					throw new Error("Command "+r[1]+ " is not defined");
				config.transformationRules.push(makeRule(r[1], r[2]));
			} else if (section === "commands"){	// definitions of one time actions
				if (!/\w.*\|.*\w/.test(r[2]))
					throw new Error("Wrong format of command "+r[2]);
				config.commands[r[1]] = r[2];
			} else if (section === "settings") { // general settings
				if (r[1] === "rollOutRepo")
					config.rollOutRepo = r[2];
				if (r[1] === "patchfile")
					config.patchfile = r[2];
			}
		} else {
			r = /^\[(\w+)\]/i.exec(line)
			if (r)
				section = r[1].toLowerCase();			
		}
	}
	patchlogger("Rules "+util.format(config));
	return config;
}	
	
function execute(cmdline, directory, callback) {
	patchlogger("EXECUTE ("+directory+") "+cmdline)
	child_process.exec(cmdline, {maxBuffer: 1024*1024, cwd: directory }, function(error, stdout, stderr) {
		if (error !== null) {
			patchlogger("Error: "+stdout+" "+stderr)
			callback(error);
		}
		if (stderr)
			patchlogger('Warning: '+stderr);
		callback(null, stdout);
	});
}


function executeF(cmdline, directory, outputFile, prefix, postfix, callback) {
	patchlogger("EXECUTEF ("+directory+", "+outputFile+") "+cmdline);
	var args = cmdline.trim().split(/\s+/);
	var stderr = "";
	write.createWriteStream(outputFile, function(error, output) {
		if (error)
			return callback(error);
		// make stream buffered
		output.markReady = true;
		output.buffers = [];
		output.writeOrEnd = function(data) {
			if (data === undefined) {
				this.end();
				this.destroy();
				this.markReady = false;
				return callback(null, 0);
			} else
				this.markReady = this.write(data);
		};
		output.writeBuffered = function(data) {
			if (!this.markReady)
				this.buffers.push(data);
			else 
				this.writeOrEnd(data);
		};
		output.on('drain', function() {
			if (!output.markReady) {
				output.markReady = true;
			}
			while (output.buffers.length > 0 && output.markReady) 
				output.writeOrEnd(output.buffers.shift());
		});
		// real code
		output.writeBuffered(prefix);
		var child = child_process.spawn(args[0], args.slice(1), { cwd: directory});
		child.stdout.on('data', function (data) {
			output.writeBuffered(data);
		});
		child.stderr.on('data', function(data) {
			stderr += data.toString("utf8");
		});
		child.on('exit', function (code) {
			if (code !== 0) {
				return callback(stderr);
			} else {
				output.writeBuffered(postfix);
				// end the stream
				output.writeBuffered(undefined);
				if (stderr)
					console.error(stderr);
			}
		})
	});
}


// adds file name for git commit
function gitadd(filename, config, _) {
	execute('git add "'+filename+'"', config.rollOutRepo, _);
}


// apply encrypt and copy rule for one file
function applyRule(rulename, filename, mode, config, _) {
	if (rulename === "ignore")
		return;
	var targetFileName = filename;
	if (rulename === "encrypt") // change file name when encrypting
		targetFileName = encryptName(filename);
	var fullTargetFileName = config.rollOutRepo + "/" + targetFileName;
	if (mode === "D") // delete and mark file for commit
		execute('git rm '+targetFileName, config.rollOutRepo, _);
	else {
		if (rulename === "copy") { // copy file 
			var buff = fs.readFile(filename, _);
			write.writeFile(fullTargetFileName, buff, _);
		} else 
			encrypt(filename, fullTargetFileName, _);
		// add file for git commit
		gitadd(targetFileName, config, _);
	}
	return;
}

// parse file path pattern and replace backslashes and convert "**/", "*", "?" into regular expressions
function makeRule(name, pattern) {
	// make regular expression
	// replace backslashes with slashes for paths
	pattern = pattern.replace(/\\/g, "/");
	// temporary replace of **/
	pattern = pattern.replace(/\*{2,}\//g, "\0");
	// replace *
	pattern = pattern.replace(/\*+/g, "[^\\/]*");
	// replace ?
	pattern = pattern.replace(/\?/g, "[^\\/]");
	// mask of .
	pattern = pattern.replace(/\./g, "\\.");
	// real replace of **/
	pattern = pattern.replace(/\x00/g, "(?:.*\/)?");
	return [new RegExp("^"+pattern+"$"), name];
}

/// parse a line for a one time action and replace $$, $/, $R, $S, $1..$9 with corresponding values
function replacements(line, rollOutRepo) { 			// split with '|'
	var index = line.indexOf('|');
	var files = line.substr(0, index).trim().split(/\s+/);
	files = files.map(function(element) { return path.normalize(element.replace(/\\/g, "/"))});
	line = line.substr(index+1).trim();
	// 	temporarily replace $$
	line = line.replace(/\$\$/g, "\0");
	// file names
	line = line.replace(/\$([1-9])/g, function(str, number) { return files[number-1]});
	// 	slash
	line = line.replace(/\$\//g, path.sep);
	// source repository
	line = line.replace(/\$S/g, path.normalize(process.cwd()))
	// roll-out repository
	line = line.replace(/\$R/g, path.normalize(rollOutRepo));
	// finally replace $$ with $.
	line = line.replace(/\x00/g, "$");
	files.command = line;
	return files;
}

function executeDiff(diff, applyRule, config, _) {
	var pattern = /([A-Z]+)\s+(.*)/g;
	var ruleName;
	var r;
	var oneTimeActions = {}; // actions which only should be applied once
	while (r = pattern.exec(diff)) {
		var filename = r[2];
		var filemode = r[1];
		var i = 0;
		var match = false;
		while (i < config.transformationRules.length) {
		    var rule = config.transformationRules[i++];
			var ru = rule[1];
			if (rule[0].test(filename)) {
				patchlogger(ru+"("+i+") "+r[0]);
				match = true;
				try {
					if (ru === "ignore")
						break;
					if (ru.indexOf('_') === 0) {
						oneTimeActions[ru] = "";
						break;
					}
					if (ru === "extra") {
						var contents = fs.readFile(filename, "utf8", _);
						var functionPattern = /(?:^|[\r\n])\s*exports\.(patch\w+)/g;
						var regexpResult;
						oneTimeActions.extra = oneTimeActions.extra || [];
						while (regexpResult = functionPattern.exec(contents)) {
							patchlogger("Pattern for extra function "+regexpResult[1]);
							oneTimeActions.extra.push(filename+ " "+regexpResult[1]);
						}						
					} else {
						applyRule(ru, filename, filemode, config, _);
					}
				} catch (e) {
					patchlogger(filename+": error with "+rule[1]+" mode "+filemode+": "+e);
				}
				if (ru !== "extra") {
					break; // no more rules to examine					
				}
			}
		}
		if (!match)
			patchlogger("Warning: no rule for "+r[0])
	}
	patchlogger("END EXEC");
	return oneTimeActions;
}

function collect(oldCommit, newCommit, config, _) {
	// log differences
	var diff = execute('git diff --name-status '+oldCommit+' '+newCommit, '.', _);
	if (!diff) {
		throw new Error("No difference found - patch would be empty");
	}
	var oneTimeActions = executeDiff(diff, applyRule, config, _);
	diff = ""; // data are not necessary any more
	// execute oneTimeActions
	if ("extra" in oneTimeActions) {
		patchlogger("EXTRA "+oneTimeActions.extra.sort().join("##"))
		write.writeFile(config.rollOutRepo+"/"+write.EXTRA_FUNCTIONS, oneTimeActions.extra.sort().join("\n") + "\n", _);
		gitadd(write.EXTRA_FUNCTIONS, config, _);
		delete oneTimeActions.extra;
	}
	var actions = [];
	for (var action in oneTimeActions)
		actions.push(action);
	var i = actions.length;
	while (--i >= 0) { // one time action as a batch file
		patchlogger("One time action "+actions[i]);
		var result = replacements(config.commands[actions[i]], config.rollOutRepo);
		// execute the command
		try {
			execute(result.command, ".", _);
		} catch (e) {
			throw new Error("Error in one time action "+actions[i]+" with command "+result.command+": "+e);
		}
		try {
			// mark files as changed
			gitadd(result.join(" "), config, _);
		} catch (e) {
			throw new Error("Error in one time action "+actions[i]+" with files "+result.join(" ")+": "+e);
		}
	}
}



function GitLog(directory, _) {
	this.pattern = /(?:^|[\r\n])(\w{40}) (PATCH|RELEASE) (\w{40}) ([\d\.]+) (.*)/g;
	this.latestCommit = function() {
		return this._logs.substr(0, 40);
	}
	this.next = function() {
		var r = this.pattern.exec(this._logs);
		if (r) {
			return { release: (r[2] === "RELEASE"), source: r[3], rollout: r[1], relNumber: r[4], comment: r[5]};
		} 
		return null;
	} 
	this.nextRelease = function() {
		var res;
		while ((res = this.next()) != null) {
			if (res.release)
				return res;
		}
		return null;
	}
	try {
		this._logs = execute('git log -1000 --pretty=oneline', directory, _);
	} catch (e) {
		console.error("git not available "+e);					
	}
}



// for unit tests
exports.makeRule = makeRule;
exports.executeDiff = executeDiff;
exports.replacements = replacements;


function encryptName(filename) {
	return filename + "E";
}

function encrypt(sourceFile, targetFile, _) {
	var content = fs.readFile(sourceFile, "utf8", _);
	content = "E###E" + content + "F###F";
	write.writeFile(targetFile, content, _);
}
