"use strict";

var child_process = require('child_process');
var util = require('util');
var write = require('./write');
var fs = require('fs');
var path = require('path');
var os = require('os');

var extraFunctions = 'extra.fkt';
var semaphoreFile = os.tmpDir()+"/"+"syra.syra"
// sha1 hash of first commit of the repository
// var FIRST_COMMIT = '3b77cf6f501cc5cfb822a214babe069138918c0e' 
var FIRST_COMMIT = '9c1bdb6f3144a8295416acb66197f1a99ce4d71e';

var config = readConfig("config.txt");

var patchlogger = console.log;

// markers for patch and release
var PATCH = "PATCH";
var RELEASE = "RELEASE";
// name of temporary branch of source repository
var TMP_BRANCH_SRC = "ppatch"

/// function patch
/// create a Syracuse patch
/// Parameters: 
///   mode string which can contain 
///	       C (collect differences from version comparison of source repository and commit changes in roll-out repository)
///        S start from release
///        E end in new release
///        W write output patch file
///   sourceCommitOld, rolloutCommitOld: SHA1 hashes of base commits in repositories. sourceCommitOld will correspond to latest patch in roll-out repository
///           rolloutCommitOld will be used to generate resulting patch file, need not necessarily correspond to sourceCommitOld  
///   sourceCommitCurrent: SHA1 hash of target commit in source repository
///   rolloutCommitCurrent: SHA1 hash of target commit (either to be created when mode contains C) or existing commit.
///	  commitComment comment for new commit in rollout repository
///   relNumberOld number of old release, relNumberNew for newly created release
function patch(newPatch, startFromRelease, newRelease, relNumberNew, commitComment, baseRelease, _) {
	// get list of tags (= release names)	
	var tags = execute('git tag', config.rollOutRepo, _).trim().split(/[\r\n\s]+/);
	console.log("TAGS "+util.format(tags));
	if (tags.length == 0 && !newRelease)
		throw new Error("No release data available. New release must be created");
	if (tags.length > 0) {
		if (baseRelease) {
			var i = tags.length;
			while (--i >= 0)
				if (baseRelease === tags[i])
					break;
			if (i < 0)
				throw new Error("Given value of base release "+baseRelease+" is no valid release. Valid releases: "+tags.join(", "));
		} else {
			baseRelease = tags[tags.length-1]; // latest release by default
		}
	}
	if (newRelease) {
		if (!relNumberNew)
			throw new Error("Release number for new release must be provided");
		if (baseRelease) {
			if (baseRelease !== tags[tags.length-1])
				throw new Error("For new release, base release must be latest release");
			if (!/^[0-9\.]+$/.test(relNumberNew))
				throw new Error("Release number can only consist of digits and dots "+relNumberNew);
			if (relNumberNew <= baseRelease)
				throw new Error("For new release, number must be greater than number of base release "+baseRelease);
		}
	}
	
	// switch roll-out repo to correct release
	if (baseRelease)
		execute('git checkout -f '+baseRelease, config.rollOutRepo, _);	
	
	var latestRelease;
	var latestPatch;
	var previousPatch;
	var rolloutCommitCurrent;
	if (tags.length > 0) { // get log data from git
		var gitlog = new GitLog(config.rollOutRepo, _);
		latestPatch = gitlog.next();
		if (latestPatch.release)
			latestRelease = latestPatch;
		previousPatch = gitlog.next();
		if (latestPatch.release)
			latestRelease = latestPatch;
		else if (previousPatch && previousPatch.release)
			latestRelease = previousPatch;
		else
			latestRelease = log.nextRelease();
	}
	
	if (newPatch || newRelease) { // collect data for new patch
		if (!commitComment) {
			throw new Error("No comment provided");
		}
		var sourceCommitOld = (latestPatch ? latestPatch.source : FIRST_COMMIT);
		var sourceCommitCurrent = execute('git log -1 --pretty=format:%H', ".", _);
		collect(sourceCommitOld, sourceCommitCurrent, _);
		// commit data
		var comment = [];
		if (newRelease)
			comment.push("RELEASE");
		else
			comment.push("PATCH");
		comment.push(sourceCommitCurrent);
		// maybe for release number
		if (newRelease)
			comment.push(relNumberNew);
		else
			comment.push(baseRelease);
		// add real comment
		comment.push(commitComment);
		
		console.log("Comment "+comment.join(" "));
		// test whether there are changes to commit
		// commit the changes
		execute('git commit -m "'+comment.join(" ")+'"', config.rollOutRepo, _);
		// create new branch
		execute('git branch '+relNumberNew, config.rollOutRepo, _);
		// create tag
		execute('git tag '+relNumberNew, config.rollOutRepo, _);
		// get the hash of the current commit
		rolloutCommitCurrent = execute('git log -1 --pretty=format:%H', config.rollOutRepo, _);
	} else {
		rolloutCommitCurrent = latestPatch.rollout;
	}
	if (latestPatch) { // create patch file		
		var rolloutCommitOld; // commit which should mark start of patch file
		if (startFromRelease)
			rolloutCommitOld = latestRelease.rollout;
		else if (newPatch || newRelease)
			rolloutCommitOld = latestPatch.rollout;
		else
			rolloutCommitOld = previousPatch.rollout;
		var patchElement = '"SYR","PATCH","'+query.comment+'"\n';
		var header = "syracuse "+rolloutCommitOld;
		if (startFromRelease) { // start from release
			header += " R "			
		} else 
			header += " - ";
		header += rolloutCommitCurrent;
		if (newRelease) { // end in release
			header += " R "+relNumberNew+" "			
		} else 
			header += " - "+relNumberOld+" ";
		header += commitComment+"\n";		
		var patchElement = '"SYR","PATCH","'+commitComment+'"\n';
		executeF('git diff --irreversible-delete --minimal --binary --no-color --unified=0 '+rolloutCommitOld+' '+rolloutCommitCurrent, config.rollOutRepo, config.patchfile, '1,"","ENG","1","","X3","1",\n2,'+patchElement+header, '**********\n7,'+patchElement+'8,""\n', _);
	}
}

exports.patch = patch;
	
function readConfig(filename) {
	var contents = fs.readFileSync(filename || "config.txt", "utf8");
	var lines = contents.split(/[\r\n]+/);
	var config = {};
	config.transformationRules = [];
	config.commands = {};
	var i = 0;
	var r;
	var section = ""; 
	while (i < lines.length){
		var line = lines[i++];
		r = /(?:^|[\r\n])(\!?\w+)\s+(.*)/.exec(line);
		if (r) {
			if (section === "files") { // associations of file paths to actions
				if (r[1].indexOf('_') === 0 && !(r[1] in config.commands))
					throw new Error("Command "+r[1]+ " is not defined");
				config.transformationRules.push(makeRule(r[1], r[2]));
			} else if (section === "commands"){	// definitions of one time actions
				if (!/\w.*\|.*\w/.test(r[2]))
					throw new Error("Wrong format of command "+r[2]);
				config.commands[r[1]] = r[2];
			} else if (section === "settings") { // general settings
				if (r[1] === "rollOutRepo")
					config.rollOutRepo = r[2];
				if (r[1] === "patchfile")
					config.patchfile = r[2];
			}
		} else {
			r = /^\[(\w+)\]/i.exec(line)
			if (r)
				section = r[1].toLowerCase();			
		}
	}
	return config;
}	
	
function execute(cmdline, directory, callback) {
	patchlogger("EXECUTE ("+directory+") "+cmdline)
	child_process.exec(cmdline, {maxBuffer: 1024*1024, cwd: directory }, function(error, stdout, stderr) {
		if (error !== null) {
			console.error("Error: "+stdout+" "+stderr)
			callback(error);
		}
		if (stderr)
			console.error('Warning: '+stderr);
		callback(null, stdout);
	});
}


function executeF(cmdline, directory, outputFile, prefix, postfix, callback) {
	patchlogger("EXECUTEF ("+directory+", "+outputFile+") "+cmdline);
	var args = cmdline.trim().split(/\s+/);
	var stderr = "";
	write.createWriteStream(outputFile, function(error, output) {
		if (error)
			return callback(error);
		// make stream buffered
		output.markReady = true;
		output.buffers = [];
		output.writeOrEnd = function(data) {
			if (data === undefined) {
				this.end();
				this.destroy();
				this.markReady = false;
				return callback(null, 0);
			} else
				this.markReady = this.write(data);
		};
		output.writeBuffered = function(data) {
			if (!this.markReady)
				this.buffers.push(data);
			else 
				this.writeOrEnd(data);
		};
		output.on('drain', function() {
			if (!output.markReady) {
				output.markReady = true;
			}
			while (output.buffers.length > 0 && output.markReady) 
				output.writeOrEnd(output.buffers.shift());
		});
		// real code
		output.writeBuffered(prefix);
		var child = child_process.spawn(args[0], args.slice(1), { cwd: directory});
		child.stdout.on('data', function (data) {
			output.writeBuffered(data);
		});
		child.stderr.on('data', function(data) {
			stderr += data.toString("utf8");
		});
		child.on('exit', function (code) {
			if (code !== 0) {
				return callback(stderr);
			} else {
				output.writeBuffered(postfix);
				// end the stream
				output.writeBuffered(undefined);
				if (stderr)
					console.error(stderr);
			}
		})
	});
}


// adds file name for git commit
function gitadd(filename, _) {
	execute('git add "'+filename+'"', config.rollOutRepo, _);
}


// apply encrypt and copy rule for one file
function applyRule(rulename, filename, mode, _) {
	console.log("APPLY "+rulename+" "+filename+" "+mode)
	if (rulename === "ignore")
		return;
	var targetFileName = filename;
	if (rulename === "encrypt") // change file name when encrypting
		targetFileName = encryptName(filename);
	var fullTargetFileName = config.rollOutRepo + "/" + targetFileName;
	if (mode === "D") // delete and mark file for commit
		execute('git rm '+targetFileName, config.rollOutRepo, _);
	else {
		if (rulename === "copy") { // copy file 
			var buff = fs.readFile(filename, _);
			write.writeFile(fullTargetFileName, buff, _);
		} else 
			encrypt(filename, fullTargetFileName, _);
		// add file for git commit
		gitadd(targetFileName, _);
	}
	return;
}

// parse file path pattern and replace backslashes and convert "**/", "*", "?" into regular expressions
function makeRule(name, pattern) {
	// make regular expression
	// replace backslashes with slashes for paths
	pattern = pattern.replace(/\\/g, "/");
	// temporary replace of **/
	pattern = pattern.replace(/\*{2,}\//g, "\0");
	// replace *
	pattern = pattern.replace(/\*+/g, "[^\\/]*");
	// replace ?
	pattern = pattern.replace(/\?/g, "[^\\/]");
	// mask of .
	pattern = pattern.replace(/\./g, "\\.");
	// real replace of **/
	pattern = pattern.replace(/\x00/g, "(?:.*\/)?");
	return [new RegExp("^"+pattern+"$"), name];
}

/// parse a line for a one time action and replace $$, $/, $R, $S, $1..$9 with corresponding values
function replacements(line, rollOutRepo) { 			// split with '|'
	var index = line.indexOf('|');
	var files = line.substr(0, index).trim().split(/\s+/);
	files = files.map(function(element) { return path.normalize(element.replace(/\\/g, "/"))});
	line = line.substr(index+1).trim();
	// 	temporarily replace $$
	line = line.replace(/\$\$/g, "\0");
	// file names
	line = line.replace(/\$([1-9])/g, function(str, number) { return files[number-1]});
	// 	slash
	line = line.replace(/\$\//g, path.sep);
	// source repository
	line = line.replace(/\$S/g, path.normalize(process.cwd()))
	// roll-out repository
	line = line.replace(/\$R/g, path.normalize(rollOutRepo));
	// finally replace $$ with $.
	line = line.replace(/\x00/g, "$");
	files.command = line;
	return files;
}

function executeDiff(diff, applyRule, transformationRules, _) {
	console.log("EXEC"+util.format(transformationRules)+" DIFF: "+diff);
	var pattern = /([A-Z]+)\s+(.*)/g;
	var ruleName;
	var r;
	var oneTimeActions = {}; // actions which only should be applied once
	while (r = pattern.exec(diff)) {
		var filename = r[2];
		var filemode = r[1];
		var i = 0;
		var match = false;
		while (i < transformationRules.length) {
		    var rule = transformationRules[i++];
			var ru = rule[1];
			if (rule[0].test(filename)) {
				patchlogger(ru+"("+i+") "+r[0]);
				match = true;
				try {
					if (ru === "ignore")
						break;
					if (ru.indexOf('_') === 0) {
						oneTimeActions[ru] = "";
						break;
					}
					if (ru === "extra") {
						var contents = fs.readFile(filename, "utf8", _);
						var functionPattern = /(?:^|[\r\n])\s*exports\.(patch\w+)/g;
						var regexpResult;
						oneTimeActions.extra = oneTimeActions.extra || [];
						while (regexpResult = functionPattern.exec(contents)) {
							console.log("PATTERN FOUND "+regexpResult[1]);
							oneTimeActions.extra.push(filename+ " "+regexpResult[1]);
						}						
					} else {
						applyRule(ru, filename, filemode, _);
					}
				} catch (e) {
					console.log(filename+": error with "+rule[1]+" mode "+filemode+": "+e);
				}
				if (ru !== "extra") {
					break; // no more rules to examine					
				}
			}
		}
		if (!match)
			patchlogger("Warning: no rule for "+r[0])
	}
	console.log("END EXEC");
	return oneTimeActions;
}

function collect(oldCommit, newCommit, _) {
		// log differences
		var diff = execute('git diff --name-status '+oldCommit+' '+newCommit, '.', _);
		if (!diff) {
			throw new Error("No difference found - patch would be empty");
		}
			
		var oneTimeActions = executeDiff(diff, applyRule, config.transformationRules, _);
		diff = ""; // data are not necessary any more
		// execute oneTimeActions
		if ("extra" in oneTimeActions) {
			patchlogger("EXTRA "+oneTimeActions.extra.sort().join("##"))
			write.writeFile(config.rollOutRepo+"/"+extraFunctions, oneTimeActions.extra.sort().join("\n") + "\n", _);
			gitadd(extraFunctions, _);
			delete oneTimeActions.extra;
		}
		var actions = [];
		for (var action in oneTimeActions)
			actions.push(action);
		var i = actions.length;
		while (--i >= 0) { // one time action as a batch file
			patchlogger("One time action "+actions[i]);
			var result = replacements(config.commands[actions[i]], config.rollOutRepo);
			// execute the command
			try {
				execute(result.command, ".", _);
			} catch (e) {
				throw new Error("Error in one time action "+actions[i]+" with command "+result.command+": "+e);
			}
			try {
				// mark files as changed
				gitadd(result.join(" "), _);
			} catch (e) {
				throw new Error("Error in one time action "+actions[i]+" with files "+result.join(" ")+": "+e);
			}
		}
		var status = execute('git status --porcelain', config.rollOutRepo, _);
		if (!status)
			throw new Error("No resulting changes in roll-out repository");
}



function GitLog(directory, _) {
	this.pattern = /(?:^|[\r\n])(\w{40}) (PATCH|RELEASE) (\w{40}) ([\d\.]+) (.*)/g;
	this.latestCommit = function() {
		return this._logs.substr(0, 40);
	}
	this.next = function() {
		var r = this.pattern.exec(this._logs);
		if (r) {
			return { release: (r[2] === "RELEASE"), source: r[3], rollout: r[1], relNumber: r[4], comment: r[5]};
		} 
		return null;
	} 
	this.nextRelease = function() {
		var res;
		while ((res = this.next()) != null) {
			if (res.release)
				return res;
		}
		return null;
	}
	try {
		this._logs = execute('git log -1000 --pretty=oneline', directory, _);
	} catch (e) {
		console.error("git not available "+e);					
	}
}



// for unit tests
exports.makeRule = makeRule;
exports.executeDiff = executeDiff;
exports.replacements = replacements;


function encryptName(filename) {
	return filename + "E";
}

function encrypt(sourceFile, targetFile, _) {
	var content = fs.readFile(sourceFile, "utf8", _);
	content = "E###E" + content + "F###F";
	write.writeFile(targetFile, content, _);
}


	

/* old code
 * 	var branch = "";
	try {
		if (newCommit !== "HEAD") {
			// maybe create temporary branch to get correct sources
			var branches = execute('git branch', '.', _);
			var r = /(?:^|[\r\n])\* (.+)/.exec(branches);
			if (r) {
				branch = r[1];
			} else {
				throw new Error("No current branch found in "+branches);
			}
			execute('git branch '+TMP_BRANCH_SRC+' '+newCommit, ".", _);
			execute('git checkout '+TMP_BRANCH_SRC, ".", _);		
		} else { // find out SHA1 hash of current commit
			newCommit = execute('git log -1 --pretty=format:%H', '.', _);
			console.log("NEW COMMIT "+newCommit)
		}
		if (oldCommit === "-")
			oldCommit = FIRST_COMMIT;
	} finally {
		if (branch) { // delete temporary branch
			execute('git checkout '+branch, '.', _);
			execute('git branch -d '+TMP_BRANCH_SRC, '.', _);
		}
	}

*/
/// getGitData
/// returns in an object 
/// - the sha1 hash of the latest commit of the roll-out repository
/// - the list of all release names
/// - the data of the latest patch and the previous patch and the latest release of the roll-out repository
///   (data consist in sha1 hash of commit in rollout and source repository, comment, release number, information whether it is a release)
/*
function getGitData(baseRelease, _) {
	// get list of tags (= release names)
	var tags = execute('git tag', config.rollOutRepo, _).trim().split(/[\r\n\s]+/);
	console.log("TAGS "+util.format(tags));
	if (!baseRelease && tags.size) {
		baseRelease = tags[tags.length-1]; // usually use last release
	}	
	// switch to correct release
	console.log("BASE "+baseRelease)
	if (baseRelease) {
		// clear all unstaged changes
		execute('git checkout -f '+baseRelease, config.rollOutRepo, _);
	}
	var log = new GitLog(config.rollOutRepo, _);
	var latestPatch = log.next();
	var latestRelease = null;
	var previousPatch = null;
	if (latestPatch) {
		if (latestPatch.release)
			latestRelease = latestPatch;
		previousPatch = log.next();
		if (latestPatch.release)
			latestRelease = latestPatch;
		else if (previousPatch && previousPatch.release)
			latestRelease = previousPatch;
		else
			latestRelease = log.nextRelease();
	}
	return { latestPatch: latestPatch, previousPatch: previousPatch, latestRelease: latestRelease, latestCommit: log.latestCommit(), releases: tags};
}
exports.getGitData = getGitData;
*/
