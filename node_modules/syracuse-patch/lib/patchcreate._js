"use strict";

var child_process = require('child_process');
var util = require('util');
var write = require('./write');
var fs = require('fs');
var path = require('path');
var os = require('os');

// sha1 hash of first commit of the Syracuse repository
var FIRST_COMMIT = '9c1bdb6f3144a8295416acb66197f1a99ce4d71e';
var CONFIG_FILE = "config.txt";

var LOGFILE = os.tmpDir()+"/patch.log"

var tracer = console.log;
var patchlogger = function(text) {
	fs.appendFileSync(LOGFILE, JSON.stringify(new Date())+text+"\n")
}

// markers for patch and release
var PATCH = "PATCH";
var RELEASE = "RELEASE";

// relNumberCmp: comparison of release numbers
// split release numbers in parts with dots as delimiters and numerically compare the parts
// result is negative, 0, positive if first release number is smaller, equal, bigger than second
function relNumberCmp(rel1, rel2) {
	var parts1 = rel1.split(/\.+/); 
	var parts2 = rel2.split(/\.+/);
	var bound = Math.min(parts1.length, parts2.length);
	for (var i = 0; i<bound; i++) {
		var diff = parts1[i] - parts2[i]; 
		if (diff != 0)
			return diff;		
	}
	return parts1.length-parts2.length;
}



/// returns array of all releases. If testRelease is given, it checks whether the value is contained 
/// in the list of releases. If not, an exception occurs
function taglist(globalConfig, testRelease, _) {
	var tags = [];
	var tmptags = execute('git tag', globalConfig.rolloutRepo, _).trim().split(/[\r\n\s]+/);
	var found = !testRelease
	var i = 0;
	while (i < tmptags.length) {		
		var tag = tmptags[i++];
		if (/^T\d[\d\.]*$/.test(tag))
			tags.push(tag.substr(1));
		if (!found && "T"+testRelease === tag)
			found = true;
	}
	if (!found)
		throw new Error("Release "+testRelease+ " does not exist");
	tags = tags.sort(relNumberCmp);
	return tags;
}

/// function patch
/// create a Syracuse patch
/// Parameters: 
///   newPatch generate new patch from source repository into roll-out repository
///   startFromRelease output patch file should start from latest release rather than from latest patch
///   newRelease generate new release (implies newPatch)
///   relNumberNew number of new release (only necessary if newRelease is true). Release number must only consist of digits and dots and must be greater than 
///       previous release number
///   commitComment comment. This is obligatory if newPatch or newRelease is true. Otherwise the contents will override the comment of the latest patch/release (if set)
///   baseRelease  optional: number of release for which the action should be performed. Default is latest release
///   patchfile: path of patchfile which will be generated
///   sha1Old:  SHA1 hash of commit of base version of patch file in roll-out repository. Must not be set when new patch/release will be created. Will be set to hash of latest patch of base release or base release itself if empty.
///   sha1New:  SHA1 hash of commit of final version of patch file in roll-out repository. Must not be set when new patch/release will be created. Default: HEAD.
///   x3Information: include X3 header and footer for patches
///   Remark: for each new patch/release there must be changes of the roll-out repository to commit, e. g. if a patch of just node.js should be delivered, there must be data to commit in the roll-out repository
///    (e. g. just stage the changes in node.js)
function patch(newPatch, startFromRelease, newRelease, relNumberNew, commitComment, baseRelease, patchfile, sha1Old, sha1New, x3Information, globalConfig, _) {
	try {
		console.log("Delete log file "+LOGFILE);
		fs.unlink(LOGFILE, _)
	} catch (e) {}
	var stdlogger = tracer;
	tracer = patchlogger;
	try {
	if (!globalConfig) 
		throw new Error("No patch without patch settings in global configuration object");
	if (!write.exists(globalConfig.rolloutRepo, _))
		throw new Error("Roll-out repository path does not exist: "+globalConfig.rolloutRepo)
	tracer("START PATCH newPatch "+newPatch+" startFromRelease "+startFromRelease+" newRelease "+newRelease+" relNumberNew "+relNumberNew+" commitComment "+commitComment+" baseRelease "+baseRelease+" sha1Old "+sha1Old+" sha1New "+sha1New+" patchfile "+patchfile);
	tracer("Rollout repository "+globalConfig.rolloutRepo+" Customer image directory "+globalConfig.customerImage);
	// get list of tags, select tags which start with 'R' and strip 'R' 
	var tags = taglist(globalConfig, baseRelease, _);
	tracer("releases "+util.format(tags));
	if (tags.length == 0) {
		if (!newRelease)
			throw new Error("No release data available. New release must be created");
		baseRelease = null;
	} else {
		if (!baseRelease)
			baseRelease = tags[tags.length-1]; // latest release by default
	}
	if (newRelease) {
		if (!relNumberNew)
			throw new Error("Release number for new release must be provided");
		if (!/^\d[\d\.]*$/.test(relNumberNew))
			throw new Error("Release number can only consist of digits and dots "+relNumberNew);
		if (baseRelease) {
			if (baseRelease !== tags[tags.length-1])
				throw new Error("For new release, base release must be latest release");
			if (relNumberCmp(relNumberNew, baseRelease) <= 0)
				throw new Error("For new release, number must be greater than number of base release "+baseRelease);
		}
		newPatch = true;
	}
	
	if (newPatch && (sha1Old || sha1New))
		throw new Error("No explicit commit hashes when new patch/release is created");
	
	var latestSha1 = "HEAD";
	var currentBranchNo; // number of current branch before switching to new branch (stays undefined if there is no active branch)
	// switch roll-out repo to correct release. Branch name is R+(release number). Keep unstaged files.
	if (baseRelease) {
		var branches = execute('git branch -v --no-abbrev', globalConfig.rolloutRepo, _);		
		if (newPatch) { 
			// new patch: checkout relevant release
			var r = /(?:^|\r|\n)\*\s(\S+)/.exec(branches);
			if (r) {
				currentBranchNo = r[1];				
			}
			if (!r || r[1] !== 'R'+baseRelease) // not on correct branch
				execute('git checkout R'+baseRelease, globalConfig.rolloutRepo, _);
		} else {
			// just get head commit of that release
			var reg = new RegExp("(?:^|\r|\n)\*?\s+R"+baseRelease.replace(/\./g, ".")+"\s+(\w+)");
			console.log(reg);
			var r = new RegExp("(?:^|\\r|\\n)\\*?\\s+R"+baseRelease.replace(/\./g, ".")+"\\s+(\\w+)").exec(branches);			
			if (r)
				latestSha1 = r[1];
			else
				throw new Error("Inconsistency. Base release not in "+branches);
		}
	}
	console.log("LATEST "+latestSha1);
	var baseVersion; // base version for patch file
	var latestPatch; // latest patch of roll-out repository for updating roll-out repository from source repository when a new version is created
	var targetVersion; // final version for patch file
	if (tags.length > 0) { // get log data from git
		if (sha1Old) {			
			baseVersion = commitDataFromHash(sha1Old, globalConfig, _)
		} else {
			var gitlog = new GitLog(globalConfig.rolloutRepo, latestSha1);
			latestPatch = gitlog.next(false, _);
			if (!latestPatch)
				throw new Error("Inconsistency: Tags available but no release");				
			if (startFromRelease) {
				if (newPatch) { // a new patch/release will be created. Then old version is latest already available release
					if (latestPatch.release) // latest current patch is release
						baseVersion = latestPatch; 
					else 
						baseVersion = gitlog.next(true, _);
				} else { // previous version is latest release before latest patch
					baseVersion = gitlog.next(true, _);
				}
			} else {
				if (newPatch) // a new patch/release will be created. Then old version is latest already available patch/release
					baseVersion = latestPatch;
				else // set previous version which is patch/release before latest patch
					baseVersion = gitlog.next(false, _);
			}
		}
	}
	tracer("Base version "+baseVersion);
	tracer("Latest patch "+util.format(latestPatch));
	if (newPatch) { // collect data for new patch or release (newPatch will be set if newRelease is set)
		// configuration for copying contents to roll-out repository
		var config = readConfig(_);
		// take rolloutRepo from globalConfig so that globalConfig need not be passed to all functions
		config.rolloutRepo = globalConfig.rolloutRepo;
		tracer("-------------- Collect files for patch");
		if (!commitComment) {
			throw new Error("No comment provided");
		}
		if (newRelease && latestPatch) {
			// create new branch for new release
			execute('git branch R'+relNumberNew, globalConfig.rolloutRepo, _);
			execute('git checkout -f R'+relNumberNew, globalConfig.rolloutRepo, _);
		}
		var sourceCommitOld = (latestPatch ? latestPatch.source : FIRST_COMMIT);
		var sourceCommitCurrent = execute('git log -1 --pretty=format:%H', ".", _);
		collect(sourceCommitOld, sourceCommitCurrent, config, _);
		// add changes to staging area
		execute('git add --all .', globalConfig.rolloutRepo, _);
		// commit data
		var comment = [];
		if (newRelease) {
			comment.push(relNumberNew);
			comment.push("0"); // patch number 0 for new release
		}
		else {
			comment.push(baseRelease);
			comment.push(1*latestPatch.patchNumber+1);
		}
		comment.push(sourceCommitCurrent);
		// for future use
		comment.push("-");
		// add real comment
		comment.push(commitComment);
		
		var commentString = comment.join(" ");
		commentString = commentString.replace(/\"/g, "'"); // replace quotation marks
		// commit the changes
		try {
			execute('git commit --no-status -q -m "'+commentString+'"', globalConfig.rolloutRepo, _);			
		} catch (e) {
			var status = execute('git status --porcelain', globalConfig.rolloutRepo, _);
			if (!status) {
				if (currentBranchNo && latestPatch) { // delete newly created branch
					execute('git checkout '+currentBranchNo, globalConfig.rolloutRepo, _);
					execute('git branch -d R'+relNumberNew, globalConfig.rolloutRepo, _)
				}
				throw new Error("No changes in roll-out repository");
			}
			throw new Error("Changes cannot be committed: "+e);
		}
		if (newRelease) {
			if (!latestPatch) {
				// create new branch
				execute('git branch R'+relNumberNew, globalConfig.rolloutRepo, _);
			}
			// create tag
			execute('git tag T'+relNumberNew, globalConfig.rolloutRepo, _);
		}
		// get the hash of the current commit
		tracer("-------------- Roll-out repository updated");
		targetVersion = commitDataFromHash("HEAD", globalConfig, _); // set data of targetVersion to the really latest new data 
		if (!latestPatch) {			
			createCustomerImage(globalConfig, _, relNumberNew, targetVersion.rollout, commitComment);
			return; // do not create patch file 
		} 
	} else {
		if (sha1New)
			targetVersion = commitDataFromHash(sha1New, globalConfig, _);
		else
			targetVersion = commitDataFromHash("HEAD", globalConfig, _);
	}
	// create patch file
	if (baseVersion.rollout === targetVersion.rollout) 
		throw new Error("Base version equals target version - empty patch");
	if (relNumberCmp(baseVersion.relNumber, targetVersion.relNumber) > 0 || 
			baseVersion.relNumber === targetVersion.relNumber && baseVersion.patchNumber-targetVersion.patchNumber > 0)
		throw new Error("No downgrade with patch from "+baseVersion.relNumber+"-"+baseVersion.patchNumber+" to "+targetVersion.relNumber+"-"+targetVersion.patchNumber);
	tracer("-------------- Create patch file "+patchfile);
	if (!patchfile)
		throw new Error("Patch file name missing");
	var patchElement = '"SYR","PATCH","'+targetVersion.comment+'"';
	var gitDiff = execute('git diff --irreversible-delete --minimal --binary --no-color --unified=0 '+baseVersion.rollout+' '+targetVersion.rollout, globalConfig.rolloutRepo, _).split(/[\r\n]+/);
	// filter the output
	var target = [];
	if (x3Information)
		target.push('1,"","ENG","1","","X3","1",', "2,"+patchElement); 
	target.push("syracuse patch "+baseVersion.relNumber+" "+baseVersion.patchNumber+" "+targetVersion.date+" "+targetVersion.relNumber+" "+targetVersion.patchNumber+" "+baseVersion.rollout+" "+targetVersion.rollout,
	            "syracuse patchcomment "+targetVersion.comment);
	// remove 
	shrink(target, gitDiff);
	if (x3Information) {
		if (target[target.length-1] === '')
			target.pop();
		target.push('**********', 
					'7,'+patchElement, 
					'8,""',
					'');
	}
	fs.writeFile(patchfile, target.join("\n"), "utf8", _);	
	tracer("-------------- Patch file created");
	tracer("END PATCH");
	} finally {
		tracer = stdlogger;
	}
}

exports.patch = patch;



function shrink(target, gitDiff) {
	var binary = false;
	var file_from;
	var file_to;
	var mode;	
	for (var i=0; i<gitDiff.length; i++) {
		var line = gitDiff[i];
		var r;
		// lines to ignore
		if (line.substr(0, 3) === '+++' || line.substr(0, 3) === '---' || /^(copy|rename|GIT binary) /.exec(line))
			continue;
		if (line.substr(0, 1) === '-') { // remove deleted lines (including '\ No new line')
			while (i < gitDiff.length-1 && /^[\-\\]/.test(gitDiff[i+1]))
				i++;
			continue;
		}
		if (line.substr(0, 10) === 'diff --git') {
			if (r = /^diff --git a\/(.*) b\/\1$/.exec(line)) {
				file_from = r[1];
				file_to = r[1];
			} else if (m = /^diff --git a\/(\S+) b\/(\S+)$/.exec(line)) {
				file_from = r[1];
				file_to = r[2];
			}
			mode = 'A';
			continue;
		}
		if (line.substr(0, 8) === 'new file') {
			mode = 'N';
			continue;
		}
		if (line.substr(0, 12) === 'deleted file') {
			mode = 'D';
			continue;
		}
		if (line.substr(0, 6) === 'index ') {
			r = /^index ([0-9a-f]+)\.\.([0-9a-f]+)/.exec(line);
			var res = "FILE "+mode+" ";
			if (mode === 'N')
				r[1] = "";
			else if (mode === 'D')
				r[2] = "";
			if (file_to === file_from)
				file_to = "";
			target.push("FILE "+mode+' "'+file_from+'" "'+file_to+'" '+r[1]+'-'+r[2]);
			continue;
		}
		// remove second part of binary patch		
		if (/^(literal|delta) /.test(line)) {
			binary = !binary;
			if (!binary) {
				// all but last line have maximal length 52 and start with 'z'
				while (i < gitDiff.length-1 && gitDiff[i+1].substr(0, 1) === 'z') {
					i++;
				}
				if (i < gitDiff.length-1 && gitDiff[i+1].match(/^[A-Za-y]\S+$/))
					i++;
				continue;				
			}
		}
		// diff area
		var r = /\@\@[\-\+\d, ]+/.exec(line);
		if (r) {
			line = r[0].trim()+"!";
		}
		target.push(line);
	}
}

/// creates customer image from rollout repository which contains all necessary metadata for Syracuse patching, but no .git data
/// parameters:
///  globalConfig: paths of rollout repository and customer image
/// optional parameters:
/// release: release number of release (latest release if empty)
/// releaseHash: sha1 of latest release,
/// releaseComment: commit comment of latest release 
function createCustomerImage(globalConfig, _, release, releaseHash, releaseComment) {
	if (!globalConfig || !globalConfig.rolloutRepo || !globalConfig.customerImage) {
		throw new Error("Directories must be given "+util.format(globalConfig));
	}
	if (!write.exists(globalConfig.rolloutRepo, _))
		throw new Error("Roll-out repository path does not exist: "+globalConfig.rolloutRepo)
	var oldlogger = tracer;
	tracer = patchlogger;
	try {
		tracer("-------------- Create customer image "+globalConfig.customerImage+" from "+globalConfig.rolloutRepo);
		// find out or check release
		var tags = taglist(globalConfig, release, _);
		if (tags.length === 0)
			throw new Error("Customer repository empty")
		if (!release)
			release = tags[tags.length-1];
		// 	remove existing customerImage
		if (write.exists(globalConfig.customerImage, _)) {
			if (fs.stat(globalConfig.customerImage, _).isDirectory) {
				tracer("Delete existing directory "+globalConfig.customerImage);
				write.rmdirRec(globalConfig.customerImage, _);
			} else {
				tracer("Delete existing file "+globalConfig.customerImage);
				fs.unlink(globalConfig.customerImage, _);
			}
		}
		// use git to create a copy of repository which has unix style line endings (-l: local copy, -s: do not copy objects)
		execute('git clone -l -s -c core.eol=lf -c core.autocrlf=input --branch T'+release+' '+globalConfig.rolloutRepo+' '+globalConfig.customerImage, ".", _);
		tracer("Clone finished");
		if (!releaseHash || !releaseComment) {
			var gitlog = new GitLog(globalConfig.customerImage);
			var newVersion = gitlog.next(false, _);
			if (!newVersion)
				throw new Error("Inconsistency: Tags available but no release");
			releaseHash = newVersion.rollout;
			releaseComment = newVersion.comment;
		}
		// 	delete git contents of customer image
		tracer("Delete .git subdirectory")
		write.rmdirRec(globalConfig.customerImage+"/.git", _);
		// 		create checksum files
		tracer("Write checksum files")
		var	sha1 = write.makeChecksums(globalConfig.customerImage, _);
		// create file for initial version
		var initialVersion = JSON.stringify({commit: releaseHash, relNumber: release, patchNumber: 0, comment: releaseComment, init: true, sha1: sha1});
		tracer("Write "+write.VERSION_FILE+": "+initialVersion);
		write.writeFile(globalConfig.customerImage+"/"+write.VERSION_FILE, initialVersion, _);
		tracer("Double-check checksums");
		var errors= write.checkChecksumsV(globalConfig.customerImage, _) 
		if (errors.length > 0) {
			throw new Error("Errors when checking checksums "+errors.join("\n"));
			tracer("errors when checking checksums "+errors.join(","))		
		}
		tracer("-------------- Create customer image completed");	
	} finally {
		tracer = oldlogger;
	}
}

exports.createCustomerImage = createCustomerImage;

/// reads config file and writes results to config object: transformationRules as an array of regular expressions with corresponding actions,
///  commands hash with one time action names and corresponding batch file invocations
function readConfig(_) {
	tracer("Read config file");
	var contents = fs.readFile(__dirname +"/"+ CONFIG_FILE, "utf8", _);
	var lines = contents.split(/(?:\r\n|\r|\n)/);
	var config = {};
	config.transformationRules = [];
	config.commands = {};
	var i = 0;
	var r;
	var section = ""; 
	while (i < lines.length){
		var line = lines[i++];
		r = /^(\w+)\s+(.*)/.exec(line);
		if (r) {
			if (section === "files") { // associations of file paths to actions
				if (r[1].indexOf('_') === 0 && !(r[1] in config.commands))
					throw new Error("Command "+r[1]+ " is not defined");
				config.transformationRules.push(makeRule(r[1], r[2]));
			} else if (section === "commands"){	// definitions of one time actions
				config.commands[r[1]] = r[2];
			} 
		} else {
			r = /^\[(\w+)\]/i.exec(line)
			if (r)
				section = r[1].toLowerCase();			
		}
	}
	tracer("Rules "+util.format(config));
	return config;
}	
	
// splits command line into parts; parts surrounded by "" will be treated as one argument. No special treatment of ''!
function splitargs(cmdline) {
	var args1 = cmdline.trim().split(/\"/);
	var result = [];
	for (var i = 0; i<args1.length; i++) {
		if (i % 2) {
			if (args1[i-1].charAt(args1[i-1].length-1) === ' ')
				result.push(args1[i])
			else
				result[result.length-1] += '"'+args1[i]+'"';
		} else {
			if (args1[i] === "")
				continue;
			var tmpArgs = args1[i].trim().split(/\s+/);
			for (var j = 0; j < tmpArgs.length; j++)
				result.push(tmpArgs[j]);
		}
	}
	return result;
}

// execute external command and return stdout as a string. There is no fixed limit on the size of stdout.
function execute(cmdline, directory, callback) {
	tracer("EXECUTE ("+directory+") "+cmdline);
	if (!directory)
		return callback(new Error("Working directory empty"));
	var args = splitargs(cmdline);
	var buffers = [];
	var stderr = "";
	var child = child_process.spawn(args[0], args.slice(1), { cwd: directory });
	child.stdout.on('data', function (data) {
		buffers.push(data);
	});
	child.stderr.on('data', function(data) {
		stderr += data.toString("utf8");
	});
	child.on('exit', function (code) {
		var length = 0;
		for (var i = buffers.length-1; i>= 0; i--)
			length += buffers[i].length;
		var b = new Buffer(length);
		length = 0;
		for (var i = 0; i < buffers.length; i++) {
			buffers[i].copy(b, length);
			length += buffers[i].length;
		}
		var stdout = b.toString("utf8");
		b = null;
		if (code !== 0) {
			tracer("Error: "+stdout+" "+stderr)
			return callback(stderr ? stderr : stdout);
		} else {
			if (stderr)
				tracer('Warning: '+stderr);
			return callback(null, stdout);
		}
	});
}


// apply encrypt and copy rule for one file
function applyRule(rulename, filename, mode, config, _) {
	if (rulename === "ignore")
		return;
	var targetFileName = filename;
	if (rulename === "encrypt") // change file name when encrypting
		targetFileName = encryptName(filename);
	var fullTargetFileName = config.rolloutRepo + "/" + targetFileName;
	if (mode === "D") { // delete and mark file for commit
		try {
			fs.unlink(fullTargetFileName, _);
		} catch (e) {
			if (e.code === "ENOENT") {
				tracer("Already deleted "+targetFileName);
			} else
				throw e;
		}
	} else {
		if (rulename === "copy") { // copy file 
			var buff = fs.readFile(filename, _);
			write.writeFile(fullTargetFileName, buff, _);
		} else 
			encrypt(filename, fullTargetFileName, _);
	}
	return targetFileName;
}

// parse file path pattern and replace backslashes and convert "**/", "*", "?" into regular expressions
function makeRule(name, pattern) {
	// make regular expression
	// replace backslashes with slashes for paths
	pattern = pattern.replace(/\\/g, "/");
	// temporary replace of **/
	pattern = pattern.replace(/\*{2,}\//g, "\0");
	// replace *
	pattern = pattern.replace(/\*+/g, "[^\\/]*");
	// replace ?
	pattern = pattern.replace(/\?/g, "[^\\/]");
	// mask of .
	pattern = pattern.replace(/\./g, "\\.");
	// real replace of **/
	pattern = pattern.replace(/\x00/g, "(?:.*\/)?");
	return [new RegExp("^"+pattern+"$"), name];
}

/// parse a line for a one time action and replace $$, $/, $R, $S with corresponding values
function replacements(line, rolloutRepo) { 	
	line = line.trim();
	// 	temporarily replace $$
	line = line.replace(/\$\$/g, "\0");
	// 	slash
	line = line.replace(/\$\//g, path.sep);
	// source repository
	line = line.replace(/\$S/g, path.normalize(process.cwd()))
	// roll-out repository
	line = line.replace(/\$R/g, path.normalize(rolloutRepo));
	// finally replace $$ with $.
	line = line.replace(/\x00/g, "$");
	return line;
}

function executeDiff(diff, applyRule, config, _) {
	var pattern = /([A-Z]+)\s+(.*)/g;
	var ruleName;
	var r;
	var oneTimeActions = {}; // actions which only should be applied once
	while (r = pattern.exec(diff)) {
		var filename = r[2];
		var filemode = r[1];
		var i = 0;
		var match = false;
		var extraActions = [];
		while (i < config.transformationRules.length) {
		    var rule = config.transformationRules[i++];
			var ru = rule[1];
			if (rule[0].test(filename)) {
				tracer(ru+"("+i+") "+r[0]);
				match = true;
					if (ru === "ignore")
						break;
					if (ru.indexOf('_') === 0) {
						oneTimeActions[ru] = "";
						break;
					}
					if (ru === "extra") {
						if (filemode != "D") {
							var contents = fs.readFile(filename, "utf8", _);
							var functionPattern = /(?:^|[\r\n])\s*exports\.(patch\w+)/g;
							var regexpResult;
							oneTimeActions.extra = oneTimeActions.extra || [];
							while (regexpResult = functionPattern.exec(contents)) {
								extraActions.push(regexpResult[1]);
								tracer("Pattern for extra function "+regexpResult[1]);
							}						
						}
					} else {
						var targetName = applyRule(ru, filename, filemode, config, _);
						if (targetName && extraActions.length > 0) {
							var i = extraActions.length;
							while (--i >= 0)
								oneTimeActions.extra.push(targetName+ " "+extraActions[i]);
						}
					}
				if (ru !== "extra") {
					break; // no more rules to examine					
				}
			}
		}
		if (!match)
			tracer("Warning: no rule for "+r[0])
	}
	tracer("END EXEC");
	return oneTimeActions;
}

/// collect differences from git log
function collect(oldCommit, newCommit, config, _) {
	// log differences
	var diff = execute('git diff --name-status '+oldCommit+' '+newCommit, '.', _);
	var oneTimeActions = executeDiff(diff, applyRule, config, _);
	diff = ""; // data are not necessary any more
	// execute oneTimeActions
	if ("extra" in oneTimeActions) {
		tracer("EXTRA "+oneTimeActions.extra.sort().join("##"))
		write.writeFile(config.rolloutRepo+"/"+write.EXTRA_FUNCTIONS, oneTimeActions.extra.sort().join("\n") + "\n", _);
		delete oneTimeActions.extra;
	}
	var actions = Object.keys(oneTimeActions);
	var i = actions.length;
	while (--i >= 0) { // one time action as a batch file
		tracer("One time action "+actions[i]);
		var result = replacements(config.commands[actions[i]], config.rolloutRepo);
		// execute the command
		try {
			execute(result, ".", _);
		} catch (e) {
			throw new Error("Error in one time action "+actions[i]+" with command "+result.command+": "+e);
		}
	}
}

// loops over git log and parses the commit comments
function GitLog(directory, headCommit) {
	this._logs = [];
	this.finished = false;
	this._i = 1;
	this._count = 10;
	
	// get data from previous release or patch
	// parameter release: only look for release commits
	this.next = function(release, _) {
		while (!this.finished) {		
			while (this._i < this._logs.length) {
				var res = commitData(this._logs[this._i++], release);
				if (res)
					return res;
			}	
			var currentCommit = headCommit || "HEAD";
			if (this._logs.length > 0) {
				currentCommit = this._logs[this._logs.length-1].substr(0, 40);
				this._i = 1;
			} else
				this._i = 0;
			this._logs = execute('git log -'+this._count+' --pretty=format:"%H %cd %s" --date=short '+currentCommit, directory, _).split(/[\r\n]+/);
			this._count *= 2;
			if (!this._logs[this._logs.length-1])
				this._logs.pop();
			if (this._logs.length <= this._i) {
				this.finished = true;
				return null;
			} 
		}
		return null;
	}
}

// returns all versions of all releases. This cannot be done just using GitLog, because there may be branches from older
function allPatches(globalConfig, _) {
	// find out branch names and patch sha1 checksums
	var tmpBranches = execute('git branch -v --no-abbrev', globalConfig.rolloutRepo, _).split(/[\r\n]+/);
	var releases = [];
	var releasesHash = {};
	var i = 0;
	while (i < tmpBranches.length) {		
		var line = tmpBranches[i++];
		var r = /^[\*\s]+R(\d[\d\.]*)\s+(\w{40})/.exec(line);
		if (r) {
			releases.push(r[1]);
			releasesHash[r[1]] = r[2];
		}
	}
	tmpBranches = undefined;
	releases = releases.sort(relNumberCmp);
	i = releases.length;
	var branchings = {};
	var result = [];
	var patch = null;
	var gitlog = new GitLog(globalConfig.rolloutRepo, releasesHash[releases[i-1]]);
	while (--i >= 0) {
		var currentRelease = releases[i];
		if (!patch)
			patch = gitlog.next(false, _);
		var found = false;
		while (patch) {
			if (patch.relNumber === currentRelease) {
				if (patch.rollout in branchings)
					patch.branchings = branchings[patch.rollout].trim();
				result.push(patch);
				found = true;
				patch = gitlog.next(false, _);
				continue;
			}
			// older patch
			if (found) {
				if (patch.rollout in branchings) 
					branchings[patch.rollout] += currentRelease+" ";
				else
					branchings[patch.rollout] = currentRelease+" ";				
			}
			if (i > 0 && patch.rollout !== releasesHash[releases[i-1]]) {
				console.log("BREAK")
				gitlog = new GitLog(globalConfig.rolloutRepo, releasesHash[releases[i-1]]);
				patch = null;
			}
			break;
		}
	}
	return result;
}

exports.allPatches = allPatches;

// extract information from "git log --pretty=oneline" line
function commitData(line, release) {
	tracer("commitData "+release+" "+line);
	// matching group 6 is for future use!
	var pattern = release ? /^\"?(\w{40}) (\d\d\d\d\-\d\d\-\d\d) ([\d\.]+) (0) (\w{40}) (\S+) ([^"]*)/ : /^\"?(\w{40}) (\d\d\d\d\-\d\d\-\d\d) ([\d\.]+) (\d+) (\w{40}) (\S+) ([^"]*)/;
	var r = pattern.exec(line);
	if (r) {
		return { release: (r[4] === "0"), source: r[5], rollout: r[1], relNumber: r[3], patchNumber: 1*r[4], comment: r[7], date: r[2] };
	}
	return null;
}

// invoke git to get all data from the commit with the given sha1 checksum
function commitDataFromHash(sha1, globalConfig, _) {
	var result = commitData(execute('git log -1 --pretty=format:"%H %cd %s" --date=short '+sha1, globalConfig.rolloutRepo, _), false);
	if (!result)
		throw new Error("Inconsistency: No data for commit "+sha1);
	return result;
}

exports.commitDataFromHash = commitDataFromHash;


// for unit tests
exports.makeRule = makeRule;
exports.executeDiff = executeDiff;
exports.replacements = replacements;
exports.commitData = commitData;
exports.relNumberCmp = relNumberCmp;
exports.shrink = shrink;
exports.splitargs  = splitargs;

function encryptName(filename) {
	return filename + "E";
}

function encrypt(sourceFile, targetFile, _) {
	var content = fs.readFile(sourceFile, "utf8", _);
	content = "# E###E\n" + content + "\n# F###F";
	write.writeFile(targetFile, content, _);
}
