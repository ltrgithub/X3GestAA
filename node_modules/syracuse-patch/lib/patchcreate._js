"use strict";

var child_process = require('child_process');
var util = require('util');
var write = require('./write');
var fs = require('fs');

var rollOutRepo = 'c:/patching/rollout';
var extraFunctions = 'extra.fkt';
var config = [ '[COMMANDS]', '_addin p/add1.txt p/add2.txt | c:$/patching\\test.bat $S $R $S$/$1', '[FILES]', '!extra **/*.js', 'ignore a/?*/**/*._js', 'copy *._js' , 'encrypt **/*.js', '_addin **/*.cs', ];
var patchfile = "c:\\patching\\patch.txt" 


// markers for patch and release
var PATCH = "PATCH";
var RELEASE = "RELEASE";
// name of temporary branch of source repository
var TMP_BRANCH_SRC = "ppatch"


function execute(cmdline, directory, callback) {
	console.log("EXECUTE ("+directory+") "+cmdline)
	child_process.exec(cmdline, {maxBuffer: 1024*1024, cwd: directory }, function(error, stdout, stderr) {
		if (error !== null) {
			callback(error);
		}
		/* if (stderr) {
			callback('STDERR: '+stderr);
		} */
		callback(null, stdout);
	});
}

function executeF(cmdline, directory, outputFile, prefix, postfix, callback) {
	console.log("EXECUTEF ("+directory+") "+cmdline)
	var args = cmdline.trim().split(/\s+/);
	var stderr = "";
	write.createWriteStream(outputFile, function(error, output) {
		if (error)
			return callback(error);
		// make stream buffered
		output.markReady = true;
		output.buffers = [];
		output.writeOrEnd = function(data) {
			if (data === undefined) {
				this.end();
				this.destroy();
				this.markReady = false;
				return callback(null, 0);
			} else
				this.markReady = this.write(data);
		};
		output.writeBuffered = function(data) {
			console.log("WRITEB "+data);
			if (!this.markReady)
				this.buffers.push(data);
			else 
				this.writeOrEnd(data);
			console.log("WRITEB2 "+this.buffers.length);
		};
		output.on('drain', function() {
			console.log("DRAIN"+output.buffers.length);
			if (!output.markReady) {
				output.markReady = true;
			}
			while (output.buffers.length > 0 && output.markReady) 
				output.writeOrEnd(output.buffers.shift());
			console.log("DRAIN2"+output.buffers.length);
		});		
		output.writeBuffered(prefix);
		var child = child_process.spawn(args[0], args.slice(1), { cwd: directory});
		child.stdout.on('data', function (data) {
			console.log("DATA >>"+data+"<<");
			output.writeBuffered(data);
		});
		child.stderr.on('data', function(data) {
			stderr += data.toString("utf8");
		});
		child.on('exit', function (code) {
			if (code !== 0) {
				return callback(stderr);
			} else {
				output.writeBuffered(postfix);
				// end the stream
				output.writeBuffered(undefined);
				if (stderr)
					console.error(stderr);
			}
		})
	});
}


// adds file name for git commit
function gitadd(filename, _) {
	execute('git add '+filename, rollOutRepo, _);
}

function applyRule(rulename, filename, mode, _) {
	console.log("APPLY "+rulename+" "+filename+" "+mode)
	if (rulename === "ignore")
		return;
	var targetFileName = filename;
	if (rulename === "encrypt") // change file name when encrypting
		targetFileName = encryptName(filename);
	var fullTargetFileName = rollOutRepo + "/" + targetFileName;
	if (mode === "D") // delete and mark file for commit
		execute('git rm '+targetFileName, rollOutRepo, _);
	else {
		if (rulename === "copy") // copy file
			util.pump(fs.createReadStream(filename), write.createWriteStream(fullTargetFileName, _), _);
		else 
			encrypt(filename, fullTargetFileName, _);
		// add file for git commit
		gitadd(targetFileName, _);
	}
	return;
}

function makeRule(name, pattern) {
	// make regular expression
	// replace backslashes with slashes for paths
	pattern = pattern.replace(/\\/g, "/");
	// temporary replace of **/
	pattern = pattern.replace(/\*{2,}\//g, "\0");
	// replace *
	pattern = pattern.replace(/\*+/g, "[^\\/]*");
	// replace ?
	pattern = pattern.replace(/\?/g, "[^\\/]");
	// mask of .
	pattern = pattern.replace(/\./g, "\\.");
	// real replace of **/
	pattern = pattern.replace(/\x00/g, "(?:.*\/)?");
	return [new RegExp("^"+pattern+"$"), name];
}


function executeDiff(diff, applyRule, transformationRules, _) {
	console.log("EXEC"+util.format(transformationRules)+" DIFF: "+diff);
	var pattern = /([A-Z]+)\s+(.*)/g;
	var ruleName;
	var oneTimeActions = {}; // actions which only should be applied once
	while (r = pattern.exec(diff)) {
		console.log("RRpp "+r[1]+"---"+r[2]);
		var filename = r[2];
		var i = 0;
		while (i < transformationRules.length) {
		    var rule = transformationRules[i++];
			console.log("Test "+filename+"--"+util.format(rule))
			var ru = rule[1];
			if (rule[0].test(filename)) {
				try {
					console.log("ANFANG "+rule)
					if (ru === "ignore")
						break;
					if (ru.indexOf('_') === 0) {
						oneTimeActions[ru] = "";
						break;
					}
					if (ru.indexOf('!') === 0) {
						console.log("READSTART "+filename);
						var contents = fs.readFile(filename, "utf8", _);
						console.log("READSTART2 "+contents);
						var functionPattern = /(?:^|[\r\n])\s*exports\.(patch\w+)/g;
						var regexpResult;
						oneTimeActions.extra = oneTimeActions.extra || [];
						console.log("READSTART3 ")
						while (regexpResult = functionPattern.exec(contents)) {
							console.log("PATTERN FOUND "+regexpResult[1]);
							oneTimeActions.extra.push(filename+ " "+regexpResult[1]);
						}						
					} else {
						console.log("B applyRule");
						applyRule(ru, filename, r[1], _);
						console.log("nach B applyRule");
					}
				} catch (e) {
					console.log(filename+": error with "+rule[1]+" mode "+r[1]+": "+e);
				}
				if (ru.substr(0, 1) !== "!") {
					break; // no more rules to examine					
				}
			}
		}
	}
	console.log("END EXEC");
	return oneTimeActions;
}


if (require.main === module) { // if invoked standalone: generate data and code for unit tests
	console.log("START")
	if (!process.argv[2]) { // detect commits for latest rollout and release
		console.log("START2")
		var logs = execute('git log -1000 --pretty=oneline', rollOutRepo, _);
		console.log("START3")
		var pattern = /(.+)/g;
		var patchCommit = ""; // SHA1 hash of last patch commit in source repository
		var patchCommitR = ""; // SHA1 hash of last patch commit in roll-out repository
		var releaseCommit = ""; // SHA1 hash of last release commit in source repository
		var releaseCommitR = ""; // SHA1 hash of last release commit in roll-out repository
		var releaseNumber = ""; // release number
		var currentCommitR = ""; // SHA1 hash of current commit in roll-out repository
		var r; // result of regex execution
		while ((!patchCommit || !releaseCommit) && (r = pattern.exec(logs))) {
			console.log("ZEILE"+r[1])
			var parts = r[1].split(/\s+/);
			console.log("PARTS"+parts.join('--'));
			if (!currentCommitR)
				currentCommitR = parts[0];
			if (!patchCommit && parts[1] === PATCH) {
				patchCommitR = parts[0];
				patchCommit = parts[2];
				releaseNumber = parts[3];
			}
			if (!releaseCommit && parts[1] === RELEASE) {
				releaseCommitR = parts[0];
				releaseCommit = parts[2];
				releaseNumber = parts[3];
				if (!patchCommit) { // for the first patch after a release, the release entry counts as patch entry
					patchCommit = releaseCommit;
					patchCommitR = releaseCommitR;
				}
			}
		}	
		if (!releaseCommit) {				
			console.log("Parameters '4 "+currentCommitR+" - <commit> Number Comment' to create first release");
		} else {
			console.log("Parameters '1 "+releaseCommitR+" "+releaseCommit+" <commit> Number Comment' to create next release");
			console.log("Parameters '2 "+releaseCommitR+" "+releaseCommit+" <commit> "+releaseNumber+" Comment' to create next patch based on release");
			console.log("Parameters '3 "+patchCommitR+" "+patchCommit+" <commit> "+releaseNumber+" Comment' to create next patch from previous patch");
			console.log("Parameters '5' create a patch between the latest patch commit and the previous patch commit");
			
			console.log()
		}
		console.log("Here <commit> is the hash of the desired commit of the source repository (may be HEAD)");
		process.exit(0);
	}
	
	var mode = process.argv[2];
	
	if (mode == 5) { // just create patch file
		var logs = execute('git log -1000 --pretty=oneline', rollOutRepo, _);
		console.log("START3")
		var pattern = /(.+)/g;
		var commits = []; // SHA1 hash of latest commits
		var comment = process.argv.slice(3);
		while (commits.length < 2 && (r = pattern.exec(logs))) {
			console.log("ZEILE"+r[1])
			var parts = r[1].split(/\s+/);
			console.log("PARTS"+parts.join('--'));
			if (parts[1] === PATCH || parts[1] === RELEASE) {
				commits.push(parts[0]);
			}
		}	
		var patchElement = '"SYR","PATCH","'+comment+'"\n';
		executeF('git diff --binary --no-color --unified=0 '+commits[1]+' '+commits[0], rollOutRepo, patchfile, '1,"","ENG","1","","X3","1",\n2,'+patchElement, '**********\n7,'+patchElement+'8,""\n', _);
		process.exit(0);
	}
		
	
	// make release or patch
	if (process.argv.length < 7) {
		console.log("Not enough parameters");
		process.exit(1);
	}
	console.log(process.argv[6])
	if (!/^[0-9\.]+$/.test(process.argv[6])) {
		console.log("Version number can only consist of digits and dots");
		process.exit(1);
	}
	

	var oldCommitR = process.argv[3];
	var oldCommit = process.argv[4];
	if (oldCommit === '-')  { // hash of initial commit of source repository
		oldCommit = '3b77cf6f501cc5cfb822a214babe069138918c0e' // '9c1bdb6f3144a8295416acb66197f1a99ce4d71e';
	}
	var newCommit = process.argv[5];
	var releaseNumber = process.argv[6];
	var commitComment = process.argv.slice(7).join(" ");
	var branch = "";
	var rollOutRepoIncludes = "";  // which 
	var extraCode = "";
	
	var transformationRules = [];
	var commands = {};
	
	var i = 0;
	var files = false; 
	while (i < config.length){
		var line = config[i++];
		// setting
		
		// file association
		r = /(?:^|[\r\n])(\!?\w+)\s+(.*)/.exec(line);
		if (r) {
			if (files) {
				if (r[1].indexOf('_') === 0 && !(r[1] in commands))
					throw new Error("Command "+r[1]+ " is not defined");
				transformationRules.push(makeRule(r[1], r[2]));
			} else {				
				commands[r[1]] = r[2];
			}
		} else {
			if (/\[files\]/i.test(line))
				files = true;
		}
	}
	console.log("RULES "+util.format(transformationRules));


	// maybe change branch in source repository
	try {
		if (newCommit !== "HEAD") {
			// maybe create temporary branch to get correct sources
			var branches = execute('git branch', '.', _);
			r = /(?:^|[\r\n])\* (.+)/.exec(branches);
			if (r) {
				branch = r[1];
			} else {
				throw new Error("No current branch found in "+branches);
			}
			execute('git branch '+TMP_BRANCH_SRC+' '+newCommit, ".", _);
			execute('git checkout '+TMP_BRANCH_SRC, ".", _);		
		} else { // find out SHA1 hash of current commit
			newCommit = execute('git log -1 --pretty=format:%H', '.', _);
			console.log("NEW COMMIT "+newCommit)
		}
		// log differences
		var diff = execute('git diff --name-status '+oldCommit+' '+newCommit, '.', _);
		if (!diff) {
			throw new Error("No difference found - patch would be empty");
		}
			
		var oneTimeActions = executeDiff(diff, applyRule, transformationRules, _);
		diff = ""; // data are not necessary any more
		// execute oneTimeActions
		if ("extra" in oneTimeActions) {
			console.log("EXTRA "+oneTimeActions.extra.sort().join("##"))
			write.writeFile(rollOutRepo+"/"+extraFunctions, oneTimeActions.extra.sort().join("\n") + "\n", _);
			gitadd(extraFunctions, _);
		}
		delete oneTimeActions.extra;
		var actions = [];
		for (var action in oneTimeActions)
			actions.push(action);
		var i = actions.length;
		while (--i >= 0) {
			// split with '|'
			var line = commands[actions[i]];
			var index = line.indexOf('|');
			var files = line.substr(0, index).trim().split(/\s+/);
			line = line.substr(index+1).trim();
			// replacements
			// temporary replace $$
			line.replace(/\$\$/, "\0");
			// file names
			line.replace(/\$([1-9])/g, function(str, number) { return path.normalize(files[number-1])});
			// slash
			line.replace(/\$\//g, path.sep);
			// source repository
			line.replace(/\$S/g, path.normalize(process.cwd()))
			// roll-out repository
			line.replace(/\$R/g, path.normalize(rollOutRepo));
			// execute the command
			execute(line, ".", _);
			// mark files as changed
			gitadd(files.join(" "), _);
		}
		if ("_addin" in oneTimeActions) {
			console.log("_addin");
			fs.appendFile(rollOutRepo+"/addin.txt", "abc\n", "utf8", _);
			gitadd("addin.txt", _);
		}
		// TODO ... more actions
		//
		// generate the commit comment
		var comment = [];
		if (mode == 1 || mode == 4)  // comparison with implicit type conversion
			comment.push("RELEASE");
		else
			comment.push("PATCH");
		comment.push(newCommit);
		// maybe for release number
		comment.push(releaseNumber);
		// add real comment
		comment.push(commitComment);

		console.log("Comment "+comment.join(" "));
		// commit the changes
		execute('git commit -m "'+comment.join(" ")+'"', rollOutRepo, _);
		// generate final patch file
		if (mode != 4) {
			var patchElement = '"SYR","PATCH","'+commitComment+'"\n';
			diff = executeF('git diff --binary --no-color --unified=0 '+oldCommitR+' HEAD ', rollOutRepo, patchfile, '1,"","ENG","1","","X3","1",\n2,'+patchElement, '**********\n7,'+patchElement+'8,""\n', _);
			// add X3 patch header and footer
			// fs.writeFile("c:\\patching\\patch.txt", diff, "utf8", _);
		}
		
	
	} catch (e) {
		console.log("EXC: "+e);
	} finally {
		if (branch) { // delete temporary branch
			execute('git checkout '+branch, '.', _);
			execute('git branch -d '+TMP_BRANCH_SRC, '.', _);
		}
	}
} else {
	// for unit tests
	exports.makeRule = makeRule;
	exports.executeDiff = executeDiff;
}




function encryptName(filename) {
	return filename + "E";
}

function encrypt(sourceFile, targetFile, _) {
	var content = fs.readFile(sourceFile, "utf8", _);
	content = "E###E" + content + "F###F";
	write.writeFile(targetFile, content, _);
}



	


