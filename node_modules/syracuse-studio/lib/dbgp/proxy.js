"use strict";
/// !doc
/// 
/// # Dbgp proxy server  
/// This server act as a forwarder for debug commands and responses.  
/// Debug commands are sent by Eclipse IDE.  
/// Response are sent by Adonix processes.  
/// The basis of the protocol is based on the [DBGP protocol](http://xdebug.org/docs-dbgp.php).  
/// 
/// The general workflow is:  
/// 
/// * A `proxyinit` command is sent by the Eclipse IDE to register its uuid into the proxy  
/// * A `proxyinit` payload is returned by the proxy to the IDE 
/// * An `init` payload is sent by the adonix process to the proxy when a debug session starts  
/// * The debug session is registered by the proxy  
/// * The `init` payload is forwarded by the proxy to the IDE  
/// * The session is accepted or rejected by the IDE  
/// * If the session is accepted:  
///  
///   * The IDE debug context is started
///   * Every debug command are sent to the proxy.
///   * Command received by the proxy are forwarded to the adonix process  
///   * Every payload sent by the adonix process to the proxy are forwarded to the IDE  
///  
/// 
/// ```
/// ---------|                    |------------|                    |----------------
///  Eclipse |                    | Dbgp Proxy |                    | x3 process
/// ---------|                    |------------|                    |----------------
///          | --- proxyinit -->> |            |                    |
///          |                    |  Register  |                    |
///          | <<- <proxyinit> -- |            |                    |
///          |                    |            |                    |
///  Accept  | <<--- <init> ----- |   <<---    | <<--- <init> ----- | start debug
///    or    |                    |            |                    |
///  Reject  |                    |            |                    |
///          | -- feature_set ->> |   --->>    | -- feature_set ->> | 
///          |                    |            |                    |
///          | <<-- <response> -- |   <<---    | <<-- <response> -- | feature_set payload <response command="feature_set" feature_name="xxxx" ... />
///          |                    |            |                    |
///          | ---- step_in --->> |   --->>    | ---- step_in --->> | 
///          |                    |            |                    |
///          | <<-- <response> -- |   <<---    | <<-- <response> -- | step_in payload
///          |                    |            |                    |
///          |        ...         |            |        ...         |
/// ```
/// 

var sys = require("util");
var fs = require("fs");
var fsp = require("path");
var crypto = require('crypto');
var net = require('net');
var uuid = require('syracuse-core/lib/uuid');
var jsxml = require("jsxml/lib/jsxml");

var cwd = process.cwd();

var tracer = console.log;
var tolerance;
var secret;

try {
	fs.mkdirSync(cwd + "/log");
} catch (e) {
	if (e.code != "EEXIST") throw new Error(e);
}
var log = logger(cwd + "/log/dbgpProxy.log");

function logger(fname) {
	var stream = fs.createWriteStream(fname, {
		flags: 'w+',
		encoding: null,
		mode: "0666"
	});

	function _write(s, clog) {
		clog && console.log(s);
		stream.write(s);
	}

	return function(chunk, clog) {
		var now = new Date();
		if (typeof(chunk) === "string") {
			_write(now.toISOString() + " " + chunk.replace(/\0/g, "[NULL]") + "\n", clog);
		} else {
			_write(now.toISOString() + " " + chunk.toString("utf8").replace(/\0/g, "[NULL]") + "\n", clog);
		}
	};
}

var server,
	mode,
	connections = {};

function _setKey(key) {
	var x = 0;
	secret = key && key.replace(/./g, function(c) {
		return String.fromCharCode(0x21 + ((x += c.charCodeAt(0)) & 0x3f));
	});
}
exports.setKey = _setKey;

function startServer(cb, opt) {
	var dbgpPort = opt && opt.port || 9514;
	tracer = tracer || (opt && opt.trace);
	tolerance = opt.tolerance;
	_setKey(opt.key);

	mode = opt.mode || "redirect";
	server = net.createServer(dbgpListener).listen(dbgpPort, function() { //'listening' listener
		log("[PXY] Dbgp proxy server bound");
	});
	// Put a friendly message on the terminal of the server.
	log("[PXY] Dbgp proxy server running at port " + dbgpPort, true);

	return dbgpPort;
}

var count = 0;

function dbgpListener(socket) {
	// Identify this client
	socket.context = {
		uuid: uuid.generate(),
		name: socket.remoteAddress + ":" + socket.remotePort
	};
	connections[socket.context.uuid] = socket;
	log("[PXY] NEW " + JSON.stringify(socket.context));

	// DBGP is a text protocol
	socket.setEncoding('utf8');
	socket.setNoDelay(true);

	socket.on('data', function(data) {
		log("[>>>] (" + (++count) + ") DATA " + JSON.stringify(socket.context) + "\n" + data);
		parseRequest(data, socket);
	});

	// Remove the client from the list when it leaves
	// socket.on('end', function() {
	// 	log("[PXY] END " + JSON.stringify(socket.context));
	// 	cleanUpSocketContext(socket);
	// });

	socket.on('close', function(hadError) {
		log("[-C-] CLOSE hadError=" + hadError + ", " + JSON.stringify(socket.context));
		cleanUpSocketContext(socket);
	});

	socket.on('error', function(e) {
		log("[-E-] ERROR " + JSON.stringify(socket.context) + "\n" + e.message);
		cleanUpSocketContext(socket);
		socket.destroy();
	});
}

function cleanUpSocketContext(socket) {
	if (!(socket && socket.context)) return;
	var ctx = socket.context,
		peer = peers[ctx.type];
	peer && peer.cleanUpSocketContext(socket);
	delete connections[ctx.uuid];
	log("[---] cleanUpSocketContext: " + ctx.uuid + "\nconnections=" + Object.keys(connections) + "\nsessionMap=" + Object.keys(sessionMap) + "\nideMap=" + Object.keys(ideMap) + "\n====");
	ctx.bound && cleanUpSocketContext(connections[ctx.bound]);
	socket.context = null;
}

// == proxy command
// proxyinit -k 7f542ecb-a09a-4117-9a65-50f275098534 -m 1[NULL]
// == Init message
// 404[NULL]<init idekey="b23efbcb-ddc3-4ffd-96fb-e29bdb94d261" fileuri="" session="com.sage.x3.xdt.dltk.debugger" thread="2330794" parent="/produits/v170/SOLSUPV7/runtime" appid="sodaix02:17001/SUPERV/erbou/107175946" language="X3" protocol_version="1.0"><engine version="17r.202"/><author>Sage</author><url><![CDATA[http://www.sage.com]]></url><copyright><![CDATA[Copyright (c) 2000-2014 Sage]]></copyright></init>[NULL]
// == Ide Command
// feature_set -n max_children -i 0 -v 32[NULL]
// == Debugger message
// 92[NULL]<response command="feature_set" transaction_id="0" feature_name="max_children" success="1"/>[NULL]

function parseRequest(message, sender) {
	var c = message.charCodeAt(0),
		m;
	if (c >= 48 && c <= 57) {
		// Init message ?
		m = message.match(/^(\d+)\0(<init\b\s+[^\0]*)\0$/i);
		if (m) {
			processDebuggerInitMessage(m, sender);
			return true;
		}
	} else if (!consumeProxyMessage(message, sender)) {
		sender.end();
	}
}

function consumeProxyMessage(message, sender) {
	var m = message.match(/^\s*proxy(\w+)\b(\s+(.*))?\0$/i),
		cmd;
	// m && log("[>>>] message='" + message + "'\nparts: " + JSON.stringify(m.slice(1)));
	if (!(cmd = m && proxyCommand[m[1].toLowerCase()]))
		return;
	log("[PXY] " + message);
	cmd(parseProxyOptions(m[3]), sender);
	return true;
}

function processDebuggerInitMessage(matches, sender) {
	var msg = safeParseXml(matches[2]) || {},
		idekey = ((msg.init || {}).$ || {})["idekey"],
		ide = ideMap[idekey];
	// tracer && tracer("[>>>] initial debug message: idekey=" + idekey);
	if (ide && ide.socket) {
		sender.context.idekey = idekey;
		sender.context.type = "debug";
		sessionMap[sender.context.uuid] = sender;
		pipe(sender, ide.socket, matches[0]);
	} else {
		sender.end();
	}
}

function pipe(x3, ide, data) {
	ide.removeAllListeners('data');
	// ide.removeAllListeners('end');
	x3.removeAllListeners('data');
	// x3.removeAllListeners('end');
	ide.context.bound = x3.context.uuid;
	x3.context.bound = ide.context.uuid;

	ide.write(data, function() {
		// tracer && tracer("[>>>] Write initial data to " + JSON.stringify(ide.context) + "\n" + data);
		log("[DBG>>>IDE] " + data);
		switch (mode) {
			case "pipe":
				// ide.pipe(process.stdout);
				// x3.pipe(process.stdout);
				ide.pipe(x3).pipe(ide);
				break;
			default:
				ide.on('data', function(data) {
					log("[IDE>>>DBG] " + data);
					x3.write(data);
				});
				x3.on('data', function(data) {
					log("[DBG>>>IDE] " + data);
					ide.write(data);
				});
				break;
		}
	});
}

function safeParseXml(xml) {
	try {
		return jsxml.parse(xml);
	} catch (e) {
		return;
	}
}

var ideMap = {},
	sessionMap = {};

var proxyCommand = {
	init: function(options, sender) {
		// proxyinit -a ip:port -k ide_key -m [0|1]
		var token = parseToken(options["-k"]);
		if (token.diagnoses) {
			sendProxyResponse(sender, "init", token.diagnoses);
			sender.end();
		}
		var ide = ideMap[token.key];
		if (ide && sender.context && ide.token.key != sender.context.idekey) {
			sender.end();
		}
		ide = ideMap[token.key] = {
			token: token,
			socket: sender,
			sessions: []
		};
		sender.context.idekey = token.key;
		sender.context.type = "ide";
		sendProxyResponse(sender, "init");
		return true;
	},
	stop: function(options, sender) {
		// proxystop -k ide_key
		var ide = ideMap[(sender.context || {}).idekey];
		log("[PXY] STOP ide=" + sys.inspect(ide) + ", sender.context=" + JSON.stringify(sender.context));
		if (ide && sender.context && ide.token.key === sender.context.idekey) {
			sendProxyResponse(sender, "stop");
		}
		sender.end();
	},
	state: function(options, sender) {
		// proxystate
		log("[PXY] STATE client peer=" + sender.remoteAddress + ":" + sender.remotePort);
		var token = parseToken(options["-k"]),
			verbose = options["-v"],
			technical = options["-t"],
			info = {
				$: {
					pid: process.pid,
					status: "running",
					port: sender.localPort,
					load: -1
				}
			}, root = {
				info: info
			}, e, sessions;

		var ide = ideMap[token.key];
		if (ide && sender.context && ide.token.key != sender.context.idekey) {
			sender.end();
		}
		ide = ideMap[token.key] = {
			token: token,
			socket: sender,
			sessions: []
		};
		sender.context.idekey = token.key;
		sender.context.type = technical ? "tech" : "ide";

		if (verbose) {
			info.$.contextId = sender.context.uuid;
			sessions = info.ideSessions = [];
			Object.keys(ideMap).forEach(function(k) {
				e = ideMap[k];
				sessions.push({
					$: {
						key: e.token && e.token.key,
						peer: e.socket && (e.socket.remoteAddress + ":" + e.socket.remotePort),
						myself: e.token && token && (e.token.key === token.key)
					}
				});
			});
			sessions = info.debugSessions = [];
			Object.keys(sessionMap).forEach(function(k) {
				e = sessionMap[k];
				sessions.push({
					$: {
						ide: e.socket.context && e.socket.context.idekey,
						peer: e.socket && (e.socket.remoteAddress + ":" + e.socket.remotePort)
					}
				});
			});
			sessions = info.connections = [];
			Object.keys(connections).forEach(function(k) {
				e = connections[k];
				sessions.push({
					$: {
						uuid: e.context && e.context.uuid,
						type: e.context && e.context.type,
						key: e.context && e.context.idekey,
						bound: e.context && e.context.bound,
						peer: (e.remoteAddress + ":" + e.remotePort)
					}
				});
			});
		}
		server.getConnections(function(err, count) {
			info.$.load = err ? -1 : count;
			sendProxyResponse(sender, "state", null, jsxml.stringify(root));
		});
	}
};

function parseProxyOptions(optString) {
	if (!optString)
		return {};
	var options = {},
		parts = optString.split(/\s+/);
	parts.slice().forEach(function(p, i) {
		if (p[0] === "-") {
			options[p] = parts[i + 1];
		}
	});
	return options;
}

function getToken(key, date, once) {
	var md5sum = crypto.createHash('md5'),
		now = new Date(),
		token = {
			"key": key,
			"date": date || now.toISOString(),
			"once": once || uuid.generate()
		},
		str = token.key + '/' + token.date + '/' + token.once + '/' + secret;
	md5sum.update(str, "ascii");
	token.signature = md5sum.digest("hex");
	return token;
}

function parseToken(b64token, err) {
	err = err || defaultError;
	var token = new Buffer(b64token, 'base64').toString('utf8');
	token = JSON.parse(token);
	var d = new Date(token.date);
	var now = new Date();
	if (!d) {
		return err(101, "Not authenticate");
	}
	if (Math.abs(d - now) > tolerance * 60 * 1000) {
		return err(101, "Token expired");
	}
	var computedToken = getToken(token.key, token.date, token.once);
	if (computedToken.signature !== token.signature) {
		return err(101, "Bad token");
	}

	return token;
}

/// see [dbgp packet description](http://xdebug.org/docs-dbgp.php#message-packets)

function sendResponse(socket, resp) {
	var data = "" + (resp || "").length + "\0" + resp + "\0";
	log("[PXY] " + data);
	socket.write(data);
}

function sendProxyResponse(socket, type, diagnosis, data) {
	var resp = '<proxy' + type + ' success="' + (diagnosis ? 0 : 1) + '" ';
	resp += 'idekey="' + (socket.context && socket.context.idekey || "") + '" ';
	resp += 'address="' + socket.remoteAddress + '" ';
	resp += 'port="' + socket.remotePort + '">';
	if (diagnosis) {
		resp += '<error code="' + diagnosis.error + '">';
		resp += diagnosis.message ? '<message>' + diagnosis.message + '</message> ' : "";
		resp += '</error>';
	}
	resp += data || "";
	resp += '</proxy' + type + '>';
	sendResponse(socket, resp);
}

function error(cmd, tid, diagnosis) {
	var resp = '<response command="' + cmd + '" transaction_id="' + tid + '">';
	resp += '<error code="' + diagnosis.error + '">';
	resp += diagnosis.message ? '<message>' + diagnosis.message + '</message>' : "";
	resp += '</error>';
	resp += '</response > ';
	// tracer && tracer("[>>>] error: " + resp);
}

function diagnosis(error, message) {
	return {
		error: error,
		message: message
	};
}

function defaultError(error, message) {
	return {
		diagnoses: [diagnosis(error, message)]
	};
}

var peers = {
	debug: {
		cleanUpSocketContext: function(socket) {
			log("[---] cleanUp debug: \nsessionMap=" + Object.keys(sessionMap) + "\nideMap=" + Object.keys(ideMap) + "\n====");
			delete sessionMap[(socket.context || {}).uuid];
		}
	},
	ide: {
		cleanUpSocketContext: function(socket) {
			log("[---] cleanUp ide: \nsessionMap=" + Object.keys(sessionMap) + "\nideMap=" + Object.keys(ideMap) + "\n====");
			delete sessionMap[(socket.context || {}).uuid];
			delete ideMap[(socket.context || {}).idekey];
		}
	}
};

exports.startServer = startServer;

// startServer(function(err, res) {
// 	if (err) return console.error(err);
// }, config);