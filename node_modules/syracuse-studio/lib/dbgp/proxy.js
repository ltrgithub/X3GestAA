"use strict";
/// !doc
/// 
/// # Dbgp proxy server  
/// This server act as a forwarder for debug commands and responses.  
/// Debug commands are sent by Eclipse IDE.  
/// Response are sent by Adonix processes.  
/// The basis of the protocol is based on the [DBGP protocol](http://xdebug.org/docs-dbgp.php).  
/// 
/// ## General workflow
/// 
/// * A `proxyinit` command is sent by the Eclipse IDE to register its uuid into the proxy  
/// * A `proxyinit` payload is returned by the proxy to the IDE 
/// * An `init` payload is sent by the adonix process to the proxy when a debug session starts  
/// * The debug session is registered by the proxy  
/// * The `init` payload is forwarded by the proxy to the IDE  
/// * The session is accepted or rejected by the IDE  
/// * If the session is accepted:  
///  
///   * The IDE debug context is started
///   * Every debug command are sent to the proxy.
///   * Command received by the proxy are forwarded to the adonix process  
///   * Every payload sent by the adonix process to the proxy are forwarded to the IDE  
///  
/// 
/// ```
/// ---------|                    |------------|                    |----------------
///  Eclipse |                    | Dbgp Proxy |                    | x3 process
/// ---------|                    |------------|                    |----------------
///          | --- proxyinit -->> |            |                    |
///          |                    |  Register  |                    |
///          | <<- <proxyinit> -- |            |                    |
///          |                    |            |                    |
///  Accept  | <<--- <init> ----- |   <<---    | <<--- <init> ----- | start debug
///    or    |                    |            |                    |
///  Reject  |                    |            |                    |
///          | -- feature_set ->> |   --->>    | -- feature_set ->> | 
///          |                    |            |                    |
///          | <<-- <response> -- |   <<---    | <<-- <response> -- | feature_set payload <response command="feature_set" feature_name="xxxx" ... />
///          |                    |            |                    |
///          | ---- step_in --->> |   --->>    | ---- step_in --->> | 
///          |                    |            |                    |
///          | <<-- <response> -- |   <<---    | <<-- <response> -- | step_in payload
///          |                    |            |                    |
///          |        ...         |            |        ...         |
/// ```
/// 

var sys = require("util");
var fs = require("fs");
var fsp = require("path");
var crypto = require('crypto');
var net = require('net');
var uuid = require('syracuse-core/lib/uuid');
var jsxml = require("jsxml/lib/jsxml");
var Transform = require('stream').Transform;

var cwd = process.cwd(),
	logDir = cwd + "/logs";

var tracer; // = console.log;
var tolerance;
var secret;
var log;

var server,
	_connections = {};

function _setKey(key) {
	var x = 0;
	secret = key && key.replace(/./g, function(c) {
		return String.fromCharCode(0x21 + ((x += c.charCodeAt(0)) & 0x3f));
	});
}
exports.setKey = _setKey;

function startServer(cb, opt) {
	var dbgpPort = opt && opt.port || 9514;
	tracer = tracer || (opt && opt.trace);
	tolerance = opt.tolerance;
	_setKey(opt.key);

	createLogger(logDir, opt, function(err, res) {
		if (err)
			return cb(err);
		log = res;
		cb(null, dbgpPort);
		server = net.createServer(dbgpListener).listen(dbgpPort, function() { //'listening' listener
			log && log("[PXY] Dbgp proxy server bound");
		});
		// Write a friendly message on the terminal of the server.
		log && log("[PXY] Dbgp proxy server running at port " + dbgpPort, true);
	});

	return dbgpPort;
}

var count = 0;

function dbgpListener(socket) {
	// Identify this client
	socket.context = {
		uuid: uuid.generate(),
		name: socket.remoteAddress + ":" + socket.remotePort
	};
	_connections[socket.context.uuid] = socket;
	log && log("[PXY] NEW " + JSON.stringify(socket.context));

	// DBGP is a text protocol
	socket.setEncoding('utf8');
	socket.setNoDelay(true);

	socket.on('data', function(data) {
		log && log("[>>>] (" + (++count) + ") DATA " + JSON.stringify(socket.context) + "\n" + data);
		parseRequest(data, socket);
	});

	socket.on('close', function(hadError) {
		log && log("[-C-] CLOSE hadError=" + hadError + ", " + JSON.stringify(socket.context));
		cleanUpSocketContext(socket);
	});

	socket.on('error', function(e) {
		log && log("[-E-] ERROR " + JSON.stringify(socket.context) + "\n" + e.message);
		cleanUpSocketContext(socket);
		socket.destroy();
	});
}

function cleanUpSocketContext(socket) {
	if (!(socket && socket.context)) return;
	var ctx = socket.context,
		peer = peers[ctx.type],
		socket2;
	peer && peer.cleanUpSocketContext(socket);
	delete _connections[ctx.uuid];
	log && log("[---] cleanUpSocketContext: " + ctx.uuid + "\nconnections=" + Object.keys(_connections) + "\nideMap=" + Object.keys(_ideMap) + "\n====");
	if (ctx.bound) {
		socket2 = _connections[ctx.bound];
		if (socket2.context && socket2.context.bound === ctx.uuid) {
			delete socket2.context.bound;
		}
		cleanUpSocketContext(socket2);
	}
	socket.context = null;
}

/// ## Message packets
/// 
/// The message packets are fully described in [DBGP message packets](http://xdebug.org/docs-dbgp.php#message-packets) section.  
/// We describe below some examples of the most relevant packets. The `[NULL]` string represent the null char `\0`.  
// ### proxy command
/// ```
/// proxyinit -k 7f542ecb-a09a-4117-9a65-50f275098534 -m 1
/// [NULL]
/// ```
// ### Init message
/// ```
/// 404
/// [NULL]
/// <init idekey="b23efbcb-ddc3-4ffd-96fb-e29bdb94d261" fileuri="" session="com.sage.x3.xdt.dltk.debugger" 
///       thread="2330794" parent="/produits/v170/SOLSUPV7/runtime" appid="sodaix02:17001/SUPERV/erbou/107175946" 
///       language="X3" protocol_version="1.0">
///   <engine version="17r.202"/>
///   <author>Sage</author>
///   <url><![CDATA[http://www.sage.com]]></url>
///   <copyright><![CDATA[Copyright (c) 2000-2014 Sage]]></copyright>
/// </init>
/// [NULL]
/// ```
// ### Ide Command
/// ```
/// feature_set -n max_children -i 0 -v 32
/// [NULL]
/// ```
// ### Debugger message
/// ```
/// 92
/// [NULL]
/// <response command="feature_set" transaction_id="0" feature_name="max_children" success="1"/>
/// [NULL]
/// ```
function parseRequest(message, sender) {
	try {
		var c = message.charCodeAt(0),
			m;
		if (c >= 48 && c <= 57) {
			// Init message ?
			m = message.match(/^(\d+)\0(<init\b\s+[^\0]*)\0$/i);
			if (m) {
				processDebuggerInitMessage(m, sender);
				return true;
			}
		} else if (!consumeProxyMessage(message, sender)) {
			sender.end();
		}
	} catch (e) {
		log && log("[PXY] FATAL ERROR during request parsing: " + e.message);
		sender.end();
	}
}

function consumeProxyMessage(message, sender) {
	var m = message.match(/^\s*proxy(\w+)\b(\s+(.*))?\0$/i),
		cmd;
	// m && log && log("[>>>] message='" + message + "'\nparts: " + JSON.stringify(m.slice(1)));
	if (!(cmd = m && _proxyCommand[m[1].toLowerCase()]))
		return false;
	log && log("[PXY] " + message);
	try {
		cmd(parseProxyOptions(m[3]), sender);
	} catch (e) {
		log && log("[PXY] ERROR Failed to process proxy command '" + m[0] + "': " + e.message);
		sendProxyResponse(sender, m[1], _diagnosis("Failed to process proxy command '" + m[0] + "'", e.message));
		sender.end();
	}
	return true;
}

function processDebuggerInitMessage(matches, sender) {
	var msg = safeParseXml(matches[2]) || {},
		idekey = ((msg.init || {}).$ || {})["idekey"],
		ide = _ideMap[idekey];
	// tracer && tracer("[>>>] initial debug message: idekey=" + idekey);
	if (ide) {
		bindSession(ide, sender, matches[0]);
	} else {
		sender.end();
	}
}

function pipe(x3, ide, data) {
	ide.removeAllListeners('data');
	x3.removeAllListeners('data');

	ide.write(data, function() {
		// tracer && tracer("[>>>] Write initial data to " + JSON.stringify(ide.context) + "\n" + data);
		log && log("[DBG>>>IDE] " + data);
		ide.pipe(x3).pipe(ide);
		// ide.pipe(x3).pipe(new LogStream("[IDE>>>DBG]", {
		// 	highWaterMark: 1024 * 1024
		// }));
		// x3.pipe(ide).pipe(new LogStream("[DBG>>>IDE]", {
		// 	highWaterMark: 1024 * 1024
		// }));
	});
}

function safeParseXml(xml) {
	try {
		return jsxml.parse(xml);
	} catch (e) {
		return;
	}
}

var _ideMap = {};

var _proxyCommand = {
	init: function(options, sender) {
		// proxyinit -a ip:port -k ide_key -m [0|1]
		var token = parseToken(options["-k"]);
		if (token.diagnoses) {
			sendProxyResponse(sender, "init", token.diagnoses);
			sender.end();
		}
		createIdeSession(token, sender);
		sendProxyResponse(sender, "init");
		return true;
	},
	stop: function(options, sender) {
		// proxystop -k ide_key
		var ide = _ideMap[(sender.context || {}).idekey];
		log && log("[PXY] STOP ide=" + sys.inspect(ide) + ", sender.context=" + JSON.stringify(sender.context));
		if (ide && sender.context && ide.token.key === sender.context.idekey) {
			sendProxyResponse(sender, "stop");
		}
		sender.end();
	},
	state: function(options, sender) {
		// proxystate
		log && log("[PXY] STATE client peer=" + sender.remoteAddress + ":" + sender.remotePort);
		var token = parseToken(options["-k"]),
			verbose = options["-v"],
			info = {
				$: {
					pid: process.pid,
					status: "running",
					port: sender.localPort,
					load: -1
				}
			}, root = {
				info: info
			}, sessions, item;

		createIdeSession(token, sender, true);

		if (verbose) {
			info.$.contextId = sender.context.uuid;
			sessions = info.ideSessions = [];
			Object.keys(_ideMap).forEach(function(k) {
				var e = _ideMap[k];
				item = {
					$: {
						key: e.token && e.token.key,
					}
				};
				item.sessions = Object.keys(e.sessions).map(function(k) {
					var e = _connections[k];
					return {
						$: {
							uuid: e.context && e.context.uuid,
							bound: e.context && e.context.bound,
							peer: e.remoteAddress + ":" + e.remotePort
						}
					};
				});
				sessions.push(item);
			});
			sessions = info.connections = [];
			Object.keys(_connections).forEach(function(k) {
				var e = _connections[k];
				sessions.push({
					$: {
						uuid: e.context && e.context.uuid,
						bound: e.context && e.context.bound,
						type: e.context && e.context.type,
						key: e.context && e.context.idekey,
						peer: e.remoteAddress + ":" + e.remotePort
					}
				});
			});
		}
		server.getConnections(function(err, count) {
			info.$.load = err ? -1 : count;
			sendProxyResponse(sender, "state", null, jsxml.stringify(root));
		});
	}
};

function createIdeSession(token, sender, technical) {
	var ide = !technical && (_ideMap[token.key] || (_ideMap[token.key] = {
		token: token,
		sessions: {}
	})),
		session;

	if (ide) {
		session = ide.sessions[sender.context.uuid];
		if (session && ide.token.key != sender.context.idekey) {
			throw new Error("Ide session token mismatch: expected " + sender.context.idekey + " got " + ide.token.key);
		}
		ide.sessions[sender.context.uuid] = sender;
	}
	if (sender.context.idekey && sender.context.idekey !== token.key) {
		throw new Error("Token mismatch: expected " + sender.context.idekey + " got " + token.key);
	}
	sender.context.idekey = token.key;
	sender.context.type = sender.context.type || (technical ? "tech" : "ide");
}

function bindSession(ide, x3, data) {
	var session = findUnbound(ide);
	if (!session) {
		log && log("[PXY] No available ide session for idekey " + ide.token.key);
		x3.end();
	}
	session.context.bound = x3.context.uuid;
	x3.context.bound = session.context.uuid;
	x3.context.idekey = ide.token.key;
	x3.context.type = "debug";
	log && log("[PXY] Binding ide session for idekey " + ide.token.key + ": ide=" + session.context.uuid + ", x3=" + x3.context.uuid);
	pipe(x3, session, data);
}

function findUnbound(ide) {
	var session;
	for (var k in ide.sessions) {
		session = ide.sessions[k];
		if (session && !session.context.bound)
			return session;
	}
}

function parseProxyOptions(optString) {
	if (!optString)
		return {};
	var options = {},
		parts = optString.split(/\s+/);
	parts.slice().forEach(function(p, i) {
		if (p[0] === "-") {
			options[p] = parts[i + 1];
		}
	});
	return options;
}

function getToken(key, date, once) {
	var md5sum = crypto.createHash('md5'),
		now = new Date(),
		token = {
			"key": key,
			"date": date || now.toISOString(),
			"once": once || uuid.generate()
		},
		str = token.key + '/' + token.date + '/' + token.once + '/' + secret;
	md5sum.update(str, "ascii");
	token.signature = md5sum.digest("hex");
	return token;
}

function parseToken(b64token, err) {
	err = err || defaultError;
	var token = new Buffer(b64token, 'base64').toString('utf8');
	token = JSON.parse(token);
	var d = new Date(token.date);
	var now = new Date();
	if (!d) {
		return err(101, "Not authenticate");
	}
	if (Math.abs(d - now) > tolerance * 60 * 1000) {
		return err(101, "Token expired");
	}
	var computedToken = getToken(token.key, token.date, token.once);
	if (computedToken.signature !== token.signature) {
		return err(101, "Bad token");
	}

	return token;
}

function sendResponse(socket, resp) {
	var data = "" + (resp || "").length + "\0" + resp + "\0";
	log && log("[PXY] " + data);
	socket.write(data);
}

function sendProxyResponse(socket, type, diagnosis, data) {
	var resp = '<proxy' + type + ' success="' + (diagnosis ? 0 : 1) + '" ';
	resp += 'idekey="' + (socket.context && socket.context.idekey || "") + '" ';
	resp += 'address="' + socket.remoteAddress + '" ';
	resp += 'port="' + socket.remotePort + '">';
	if (diagnosis) {
		resp += '<error code="' + diagnosis.error + '">';
		resp += diagnosis.message ? '<message>' + diagnosis.message + '</message> ' : "";
		resp += '</error>';
	}
	resp += data || "";
	resp += '</proxy' + type + '>';
	sendResponse(socket, resp);
}

function error(cmd, tid, diagnosis) {
	var resp = '<response command="' + cmd + '" transaction_id="' + tid + '">';
	resp += '<error code="' + diagnosis.error + '">';
	resp += diagnosis.message ? '<message>' + diagnosis.message + '</message>' : "";
	resp += '</error>';
	resp += '</response > ';
	// tracer && tracer("[>>>] error: " + resp);
}

function _diagnosis(error, message) {
	return {
		error: error,
		message: message
	};
}

function defaultError(error, message) {
	return {
		diagnoses: [_diagnosis(error, message)]
	};
}

var peers = {
	debug: {
		cleanUpSocketContext: function(socket) {
			log && log("[---] cleanUp debug: \nideMap=" + Object.keys(_ideMap) + "\n====");
			var ide = _ideMap[(socket.context || {}).idekey];
			if (ide)
				delete ide.sessions[(socket.context || {}).bound];
		}
	},
	ide: {
		cleanUpSocketContext: function(socket) {
			log && log("[---] cleanUp ide: \nideMap=" + Object.keys(_ideMap) + "\n====");
			var ide = _ideMap[(socket.context || {}).idekey];
			if (ide)
				delete ide.sessions[(socket.context || {}).uuid];
		}
	}
};

exports.startServer = startServer;

function createLogger(path, opt, cb) {
	var lgr = logger(path, opt);
	try {
		lgr.init();
		return cb(null, lgr.log);
	} catch (err) {
		return cb(err);
	}
}


function logger(dir, opt) {
	var logSize = (opt.logSize || 2) * 1024 * 1024, // 2 Mb by default
		logCount = opt.logCount || 3, // 3 files for rotating log
		name = fsp.resolve(dir, "dbgpProxy"),
		ctlName = name + "Ctl.json",
		ctl = {
			current: 0
		},
		stream;

	function _init() {
		try {
			fs.mkdirSync(dir);
		} catch (err) {
			if (err.code != 'EEXIST') throw err;
		}
		if (!fs.existsSync(ctlName)) {
			ctl.datetime = new Date().toISOString();
			ctl.current = 0;
			fs.writeFileSync(ctlName, JSON.stringify(ctl, null, 2));
		} else {
			var data = fs.readFileSync(name + "Ctl.json", {
				encoding: "utf8"
			});
			ctl = JSON.parse(data);
		}
		_createStream('a');
	}

	function _createStream(flags) {
		var fullName = name + "_" + ctl.current + ".log",
			stat;
		ctl.size = 0;
		if (flags === 'a') {
			try {
				stat = fs.statSync(fullName);
				ctl.size = stat.size;
			} catch (err) {
				if (err.code != 'ENOENT') throw err;
			}
		}
		stream = fs.createWriteStream(name + "_" + ctl.current + ".log", {
			flags: flags,
			encoding: null,
			mode: "0666"
		});
	}

	function _write(s, clog) {
		if (s == null) return;
		// clog && console.log(s);
		console.log(s);
		ctl.size += s.length;
		if (ctl.size > logSize) {
			stream.end();
			ctl.current = ++ctl.current % logCount;
			ctl.datetime = new Date().toISOString();
			delete ctl.size;
			fs.writeFile(ctlName, JSON.stringify(ctl, null, 2), function(err) {
				if (err) console.error(err);
			});
			_createStream('w');
			ctl.size = 0;
		}
		stream.write(s);
	}

	function _log(chunk, clog) {
		var now = new Date();
		if (typeof(chunk) === "string") {
			_write(now.toISOString() + " " + chunk.replace(/\0/g, "[NULL]") + "\n", clog);
		} else {
			_write(now.toISOString() + " " + chunk.toString("utf8").replace(/\0/g, "[NULL]") + "\n", clog);
		}
	}

	return {
		init: _init,
		log: _log
	};
}

// LogStream is a simple transform stream to allow logging of message
sys.inherits(LogStream, Transform);

function LogStream(prefix, options) {
	if (!(this instanceof LogStream))
		return new LogStream(prefix, options);
	this.prefix = prefix;
	Transform.call(this, options);
}

LogStream.prototype._transform = function(chunk, encoding, cb) {
	log && log(this.prefix + " " + chunk);
	cb(null, chunk);
};