"use strict";
/// !doc
/// 
/// # Dbgp proxy server  
/// This server act as a forwarder for debug commands and responses.  
/// Debug commands are sent by Eclipse IDE.  
/// Response are sent by Adonix processes.  
/// The basis of the protocol is based on the [DBGP protocol](http://xdebug.org/docs-dbgp.php).  
/// 
/// The general workflow is:  
/// 
/// * A `proxyinit` command is sent by the Eclipse IDE to register its uuid into the proxy  
/// * A `proxyinit` payload is returned by the proxy to the IDE 
/// * An `init` payload is sent by the adonix process to the proxy when a debug session starts  
/// * The debug session is registered by the proxy  
/// * The `init` payload is forwarded by the proxy to the IDE  
/// * The session is accepted or rejected by the IDE  
/// * If the session is accepted:  
///  
///   * The IDE debug context is started
///   * Every debug command are sent to the proxy.
///   * Command received by the proxy are forwarded to the adonix process  
///   * Every payload sent by the adonix process to the proxy are forwarded to the IDE  
///  
/// 
/// ```
/// ---------|                |------------|                |------------
///  Eclipse |                | Dbgp Proxy |                | x3 process
/// ---------|                |------------|                |------------
///          |   proxyinit    |            |                |
///          | -------------> |  Register  |                |
///          |                |            |                |
///          |  <proxyinit>   |            |                |
///          | <------------- |            |                |
///          |                |            |                |
///          |     <init>     |            |     <init>     |
///  Accept  | <------------- |    <---    | <------------- | start debug
///    or    |                |            |                |
///  Reject  |     step_in    |            |    step_in     |
///          | -------------> |    --->    | -------------> | 
///          |                |            |                |
///          |    <step_in>   |            |    <step_in>   |
///          | <------------- |    <---    | <------------- | step in payload
///          |                |            |                |
///          |       ...      |            |      ...       |
/// ```
/// 

var sys = require("util");
var fs = require("fs");
var fsp = require("path");
var crypto = require('crypto');
var net = require('net');
var uuid = require('syracuse-core/lib/uuid');
var jsxml = require("jsxml/lib/jsxml");

var cwd = process.cwd();

var tracer = console.log;
var tolerance;
var secret;

try {
	fs.mkdirSync(cwd + "/log");
} catch (e) {
	if (e.code != "EEXIST") throw new Error(e);
}
var log = logger(cwd + "/log/dbgpProxy.log");

function logger(fname) {
	var stream = fs.createWriteStream(fname, {
		flags: 'w+',
		encoding: null,
		mode: "0666"
	});

	function _write(s) {
		console.log(s);
		stream.write(s);
	}

	return function(chunk, encoding) {
		var now = new Date();
		if (typeof(chunk) === "string") {
			_write(now.toISOString() + " " + chunk.replace(/\0/g, "[NULL]") + "\n");
		} else {
			_write(now.toISOString() + " " + chunk.toString(encoding || "utf8").replace(/\0/g, "[NULL]") + "\n");
		}
	};
}

var server;

function _setKey(key) {
	var x = 0;
	secret = key && key.replace(/./g, function(c) {
		return String.fromCharCode(0x21 + ((x += c.charCodeAt(0)) & 0x3f));
	});
}
exports.setKey = _setKey;

function startServer(cb, opt) {
	var dbgpPort = opt && opt.port || 9514;
	tracer = tracer || (opt && opt.trace);
	tolerance = opt.tolerance;
	_setKey(opt.key);

	server = net.createServer(dbgpListener).listen(dbgpPort, function() { //'listening' listener
		log("[PXY] Dbgp proxy server bound");
		// console.log('Dbgp proxy server bound');
	});
	// Put a friendly message on the terminal of the server.
	log("[PXY] Dbgp proxy server running at port " + dbgpPort);

	// console.log("Dbgp proxy server running at port " + dbgpPort + "\n");
	return dbgpPort;
}

function dbgpListener(socket) {
	var count = 0;
	// Identify this client
	socket.context = {
		uuid: uuid.generate(),
		name: socket.remoteAddress + ":" + socket.remotePort
	};
	log("[PXY] NEW context=" + JSON.stringify(socket.context));

	socket.setEncoding('utf8');
	socket.on('data', function(data) {
		log("[>>>] receive data: (" + (++count) + ") context=" + JSON.stringify(socket.context) + "\n" + data);
		// tracer && tracer("[>>>] receive data: (" + (++count) + ") context=" + JSON.stringify(socket.context) + "\n" + data);
		parseDbgpRequest(data, socket);
	});

	// Remove the client from the list when it leaves
	socket.on('end', function() {
		log("[PXY] END context=" + JSON.stringify(socket.context));
		cleanUpSocketContext(socket);
	});

	socket.on('error', function() {
		log("[PXY] ERROR context=" + JSON.stringify(socket.context));
		cleanUpSocketContext(socket);
	});
}

function cleanUpSocketContext(socket) {
	var peer = peers[(socket.context || {}).type];
	peer && peer.cleanUpSocketContext(socket);
	socket.context = null;
}

// == proxy command
// proxyinit -k 7f542ecb-a09a-4117-9a65-50f275098534 -m 1[NULL]
// == Init message
// 404[NULL]<init idekey="b23efbcb-ddc3-4ffd-96fb-e29bdb94d261" fileuri="" session="com.sage.x3.xdt.dltk.debugger" thread="2330794" parent="/produits/v170/SOLSUPV7/runtime" appid="sodaix02:17001/SUPERV/erbou/107175946" language="X3" protocol_version="1.0"><engine version="17r.202"/><author>Sage</author><url><![CDATA[http://www.sage.com]]></url><copyright><![CDATA[Copyright (c) 2000-2014 Sage]]></copyright></init>[NULL]
// == Ide Command
// @b23efbcb-ddc3-4ffd-96fb-e29bdb94d261[NULL]feature_set -n max_children -i 0 -v 32[NULL]
// == Debugger message
// 92[NULL]<response command="feature_set" transaction_id="0" feature_name="max_children" success="1"/>[NULL]

function parseRequest(message, sender) {
	sender.context.parts = (sender.context.parts || []).concat(message.split("\0"));
}

function parseDbgpRequest(message, sender) {
	try {
		var m, sessionId, pos, len, type = sender.context.type;
		if (type === "debug") {
			tracer && tracer("[>>>] parseDbgRequest: sessionId=" + sender.context.uuid);
			return forwardDebuggerMessage(message, sender);
		} else if (type === "ide") {
			if (message[0] === '@') {
				pos = message.indexOf("\0");
				sessionId = message.substring(1, pos);
				message = message.substring(pos + 1);
				tracer && tracer("[>>>] parseIdeRequest: sessionId=" + sessionId);
			}
			log("[IDE] " + message);
			return consumeProxyMessage(message, sender) || forwardIdeCommand(message, sender, sessionId);
		} else {
			if (message.charCodeAt(0) >= 48 && message.charCodeAt(0) <= 57) {
				log("[DBG] " + message);
				// Initialisation message ?
				m = message.match(/^(\d+)\0(<init\b\s+[^\0]*)\0$/i);
				if (m) {
					return processDebuggerInitMessage(m, sender);
				}
			} else {
				log("[IDE] " + message);
				return consumeProxyMessage(message, sender) || forwardIdeCommand(message, sender, sessionId);
			}
		}
	} catch (e) {
		log("[EXCEPTION] " + e.message + "\n" + e.stack);
	}
}

function consumeProxyMessage(message, sender) {
	var m = message.match(/^\s*proxy(\w+)\b(\s+(.*))?\0$/i),
		cmd;
	m && log("[>>>] message='" + message + "'\nparts: " + JSON.stringify(m.slice(1)));
	if (!(cmd = m && proxyCommand[m[1].toLowerCase()]))
		return;
	cmd(parseProxyOptions(m[3]), sender);
	return true;
}

function processDebuggerInitMessage(matches, sender) {
	var msg = safeParseXml(matches[2]) || {},
		idekey = ((msg.init || {}).$ || {})["idekey"],
		ide = ideMap[idekey];
	tracer && tracer("[>>>] initial debug message: idekey=" + idekey);
	if (ide && ide.socket) {
		sender.context.idekey = idekey;
		sender.context.type = "debug";
		sessionMap[sender.context.uuid] = sender;
		forwardDebuggerMessage(matches[0], sender);
	} else {
		sender.end();
	}
}

function safeParseXml(xml) {
	try {
		return jsxml.parse(xml);
	} catch (e) {
		return;
	}
}

function forwardDebuggerMessage(message, sender) {
	var ide = ideMap[sender.context.idekey];
	if (ide && ide.socket) {
		var data = "@" + sender.context.uuid + "\0" + message;
		log("[DBG] " + data);
		ide.socket.write(data);
	} else {
		sender.end();
	}
}

function forwardIdeCommand(message, sender, sessionId) {
	var ide = ideMap[sender.context.idekey],
		session = sessionMap[sessionId];
	if (ide && ide.socket) {
		session && session.write(message);
	} else {
		sender.end();
	}
}

function sendRecorded(sender) {
	var msg = '<init idekey="2105b642-eaaf-4177-8ffd-f51d549e4e5c" fileuri="" session="com.sage.x3.xdt.dltk.debugger" thread="2330794" parent="/produits/v170/SOLSUPV7/runtime" appid="sodaix02:17001/SUPERV/erbou/107175946" language="X3" protocol_version="1.0"><engine version="17r.202"/><author>Sage</author><url><![CDATA[http://www.sage.com]]></url><copyright><![CDATA[Copyright (c) 2000-2014 Sage]]></copyright></init>';
	msg = (msg || "").length + "\0" + msg + "\0";
	forwardDebuggerMessage(msg, sender);
}

var ideMap = {},
	sessionMap = {};

var proxyCommand = {
	init: function(options, sender) {
		// proxyinit -a ip:port -k ide_key -m [0|1]
		var token = parseToken(options["-k"]);
		if (token.diagnoses) {
			sendProxyResponse(sender, "init", token.diagnoses);
			sender.end();
		}
		var ide = ideMap[token.key];
		if (ide && sender.context && ide.token.key != sender.context.idekey) {
			sender.end();
		}
		ide = ideMap[token.key] = {
			token: token,
			socket: sender,
			sessions: []
		};
		sender.context.idekey = token.key;
		sender.context.type = "ide";
		sendProxyResponse(sender, "init");
		// sendRecorded(sender);
		return true;
	},
	stop: function(options, sender) {
		// proxystop -k ide_key
		var ide = ideMap[(sender.context || {}).idekey];
		log("[PXY] STOP ide=" + sys.inspect(ide) + ", sender.context=" + JSON.stringify(sender.context));
		if (ide && sender.context && ide.token.key === sender.context.idekey) {
			sendProxyResponse(sender, "stop");
		}
		sender.end();
	},
	state: function(options, sender) {
		// proxystate
		log("[PXY] STATE client peer=" + sender.remoteAddress + ":" + sender.remotePort);
		var token = parseToken(options["-k"]),
			verbose = options["-v"],
			info = {
				$: {
					pid: process.pid,
					status: "running",
					load: -1
				}
			}, root = {
				info: info
			}, e, sessions;

		var ide = ideMap[token.key];
		if (ide && sender.context && ide.token.key != sender.context.idekey) {
			sender.end();
		}
		ide = ideMap[token.key] = {
			token: token,
			socket: sender,
			sessions: []
		};
		sender.context.idekey = token.key;
		sender.context.type = "ide";

		if (verbose) {
			info.$.contextId = sender.context.uuid;
			sessions = info.ideSessions = [];
			Object.keys(ideMap).forEach(function(k) {
				e = ideMap[k];
				sessions.push({
					$: {
						key: e.token && e.token.key,
						peer: e.socket && (e.socket.remoteAddress + ":" + e.socket.remotePort),
						myself: e.token && token && (e.token.key === token.key)
					}
				});
			});
			sessions = info.debugSessions = [];
			Object.keys(sessionMap).forEach(function(k) {
				e = sessionMap[k];
				sessions.push({
					$: {
						ide: e.socket.context && e.socket.context.idekey,
						peer: e.socket && (e.socket.remoteAddress + ":" + e.socket.remotePort)
					}
				});
			});
		}
		server.getConnections(function(err, count) {
			info.$.load = err ? -1 : count;
			console.log("GetState: " + JSON.stringify(root));
			sendProxyResponse(sender, "state", null, jsxml.stringify(root));
			// sendResponse(sender, JSON.stringify(info));
		});
	}
};

function parseProxyOptions(optString) {
	if (!optString)
		return {};
	var options = {},
		parts = optString.split(/\s+/);
	parts.slice().forEach(function(p, i) {
		if (p[0] === "-") {
			options[p] = parts[i + 1];
		}
	});
	return options;
}

function getToken(key, date, once) {
	var md5sum = crypto.createHash('md5'),
		now = new Date(),
		token = {
			"key": key,
			"date": date || now.toISOString(),
			"once": once || uuid.generate()
		},
		str = token.key + '/' + token.date + '/' + token.once + '/' + secret;
	md5sum.update(str, "ascii");
	token.signature = md5sum.digest("hex");
	return token;
}

function parseToken(b64token, err) {
	err = err || defaultError;
	var token = new Buffer(b64token, 'base64').toString('utf8');
	token = JSON.parse(token);
	var d = new Date(token.date);
	var now = new Date();
	if (!d) {
		return err(101, "Not authenticate");
	}
	if (Math.abs(d - now) > tolerance * 60 * 1000) {
		return err(101, "Token expired");
	}
	var computedToken = getToken(token.key, token.date, token.once);
	if (computedToken.signature !== token.signature) {
		return err(101, "Bad token");
	}

	return token;
}

/// see [dbgp packet description](http://xdebug.org/docs-dbgp.php#message-packets)

function sendResponse(socket, resp) {
	var data = "" + (resp || "").length + "\0" + resp + "\0";
	log("[PXY] " + data);
	socket.write(data);
}

function sendProxyResponse(socket, type, diagnosis, data) {
	var resp = '<proxy' + type + ' success="' + (diagnosis ? 0 : 1) + '" ';
	resp += 'idekey="' + (socket.context && socket.context.idekey || "") + '" ';
	resp += 'address="' + socket.remoteAddress + '" ';
	resp += 'port="' + socket.remotePort + '">';
	if (diagnosis) {
		resp += '<error code="' + diagnosis.error + '">';
		resp += diagnosis.message ? '<message>' + diagnosis.message + '</message> ' : "";
		resp += '</error>';
	}
	resp += data || "";
	resp += '</proxy' + type + '>';
	sendResponse(socket, resp);
}

function error(cmd, tid, diagnosis) {
	var resp = '<response command="' + cmd + '" transaction_id="' + tid + '">';
	resp += '<error code="' + diagnosis.error + '">';
	resp += diagnosis.message ? '<message>' + diagnosis.message + '</message>' : "";
	resp += '</error>';
	resp += '</response > ';
	tracer && tracer("[>>>] error: " + resp);
}

function diagnosis(error, message) {
	return {
		error: error,
		message: message
	};
}

function defaultError(error, message) {
	return {
		diagnoses: [diagnosis(error, message)]
	};
}

var peers = {
	debug: {
		cleanUpSocketContext: function(socket) {
			delete sessionMap[(socket.context || {}).uuid];
		}
	},
	ide: {
		cleanUpSocketContext: function(socket) {
			delete ideMap[(socket.context || {}).idekey];
		}
	}
};

exports.startServer = startServer;

// startServer(function(err, res) {
// 	if (err) return console.error(err);
// }, config);