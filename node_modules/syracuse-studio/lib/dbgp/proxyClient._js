"use strict";
/// !doc
/// 
/// # DBGP proxy client
/// 
/// Send request and listen to incomming DBGP packet
/// 
/// ``` javascript
/// var client = require('syracuse-studio/lib/dbgp/proxyClient');
/// ```
var sys = require("util");
var ez = require('ez-streams');
var helpers = require('syracuse-core/lib/helpers');
var uuid = require('syracuse-core/lib/uuid');
var jsxml = require("jsxml/lib/jsxml");
var config = require('syracuse-main/lib/nodeconfig').config;

var tracer = (config.studio || {}).trace;

var trackers = {};

exports.create = function _create(port, host, token) {
	return new DbgpProxyClient(port, host, token);
};

function DbgpMessage(size, xml) {
	this.size = typeof(size) == "string" ? parseInt(size, 10) : size;
	this.xml = xml;
	if (xml.length !== this.size)
		throw new Error("Dbgp message size mismatch: expected " + size + " got " + xml.length);
}

DbgpMessage.prototype.toString = function() {
	return [this.size, this.xml, ""].join("\0");
};

function DbgpProxyClient(port, hostname, token) {
	this.token = token;

	var stream;

	function _ensureConnect(_) {
		if (!stream) {
			stream = ez.devices.net.tcpClient(port, hostname).connect(_);
			stream.setEncoding("utf8").setNoDelay(true);
		}
	}

	function readSegment(_) {
		var seg = "",
			c;
		while ((c = stream.read(_, 1, false)) && c.charCodeAt(0) !== 0) {
			seg += c;
		}
		if (c == null) {
			throw new Error("Dbgp protocol error: End of stream - closed=" + stream.closed);
		}

		return seg;
	}

	Object.defineProperty(this, 'isAlive', {
		get: function() {
			return stream && !stream.closed;
		}
	});

	this.close = function() {
		stream && stream.end();
		stream && stream.destroy();
		stream = null;
	};

	this._write = function(_, data) {
		_ensureConnect(_);
		tracer && tracer("DbgpClient.write: " + data);
		stream.write(_, data);
	};

	this._read = function(_) {
		var size = 0,
			c = 0,
			data = readSegment(_);
		size = parseInt(data, 10);
		if (isNaN(size))
			throw new Error("Dbgp protocol error: Size is not valid");
		data = stream.read(_, size, false);

		// read the last null char
		c = stream.read(_, 1, false);
		if (c == null)
			throw new Error("Dbgp protocol error: End of stream");
		if (c.charCodeAt(0) !== 0)
			throw new Error("Dbgp protocol sync issue: expected 0 got " + c.charCodeAt(0));
		var msg = new DbgpMessage(size, data);
		tracer && tracer("DbgpClient.read: " + msg);
		return msg;
	};
}

exports.DbgpProxyClient = helpers.defineClass(DbgpProxyClient, null, {
	parseXml: function(xml) {
		var o = jsxml.parse(xml);
		return o && o[Object.keys(o)[0]];
	},

	getState: function(_, opts) {
		opts = opts || {};
		var args = ["-k", this.token];
		if (opts.v) args = args.concat("-v", opts.v);
		var data = this.sendCommand(_, "proxystate", args);
		return data.xml;
	},

	execCommand: function(_, cmd, opts) {
		opts = opts || {};
		var args = ["-k", this.token];
		Object.keys(opts).filter(function(k) {
			return k && k.length === 1 && /[a-zA-Z]/.exec(k);
		}).forEach(function(k) {
			args = args.concat("-" + k.toLowerCase(), opts[k]);
		});
		var data = this.sendCommand(_, "proxy" + cmd, args);
		return data.xml;
	},

	poll: function(_, trackingId, options) {
		try {
			var tracker;
			if (options) {
				options.onTimeout = options.onTimeout || function(tracker) {
					throw new Error("Dbgp proxy client request timeout");
				};
				tracker = _makeReadTracker(_, this, trackingId);
				return _asyncCall(_, tracker, options);
			}
			return trackingId && this._getResult(_, trackingId) || this._read(_);
		} catch (e) {
			this.close();
			throw e;
		}
	},

	submitCommand: function(_, cmd, args, options) {
		try {
			var tracker;
			// Build the command in the dbgp format: command [SPACE] [arguments...] [NULL]
			cmd = cmd.split(/\s+/).concat(args || []).join(" ").split(/\0/)[0] + "\0";
			this._write(_, cmd);
			tracker = _makeReadTracker(_, this);
			options && _asyncCall(_, tracker, options);
			return tracker;
		} catch (e) {
			this.close();
			throw e;
		}
	},

	_getResult: function(_, trackingId, wait) {
		var tracker = trackers[trackingId];
		delete trackers[trackingId];
		return tracker && (tracker.result || wait && tracker.future && tracker.future(_));
	},

	sendCommand: function(_, cmd, args) {
		var tracker = this.submitCommand(_, cmd, args);
		return this._getResult(_, tracker.id, true);
	}

});

function _wrapOnComplete(f) {
	return function(tracker) {
		if (tracker) {
			tracker.future = null;
			delete trackers[tracker.id];
		}
		f && f(tracker);
	};
}

function _makeReadTracker(_, client, trackingId) {
	trackingId = trackingId || helpers.uuid.generate();
	return trackers[trackingId] || (trackers[trackingId] = {
		id: trackingId,
		// create future to get the result later
		future: client._read(!_)
	});
}

function _asyncCall(_, tracker, options) {
	if (!options)
		throw new Error("Cannot start async call");

	tracer && tracer("DbgpClient._asyncCall: " + tracker.id);

	if (tracker && tracker.result) {
		tracer && tracer("DbgpClient._asyncCall onComplete: " + tracker.id + "\n>>> " + tracker.result);
		return tracker.context && tracker.context.onComplete && tracker.context.onComplete(tracker);
	}
	delete tracker.timeout;
	var ctx = tracker.context = tracker.context || {};

	ctx.onTimeout = options.onTimeout;
	ctx.onComplete = _wrapOnComplete(options.onComplete);
	ctx.onError = options.onError;
	ctx.timeout = options.timeout || 4000;
	ctx.timer = setTimeout(function() {
		tracker.timeout = ctx.timeout;
		tracer && tracer("DbgpClient._asyncCall [timeout] onTimeout: " + tracker.id);
		if (tracker.result === undefined) {
			ctx.onTimeout && ctx.onTimeout(tracker);
		} else if (tracker.future) {
			// should not happen
			tracer && tracer("DbgpClient._asyncCall [timeout] onComplete: " + tracker.id + "\n>>> " + tracker.result);
			ctx.onComplete(tracker);
		}
	}, ctx.timeout);

	if (ctx.running)
		return;

	tracer && tracer("DbgpClient._asyncCall [call future]: " + tracker.id);
	ctx.running = true;
	tracker.future(_ >> function(e, r) {
		clearTimeout(ctx.timer);
		delete ctx.running;
		if (e) {
			tracer && tracer("DbgpClient._asyncCall [future] onError: " + tracker.id + "\n>>> " + e.message);
			return ctx.onError(e, tracker);
		}
		tracker.result = r;
		if (tracker.timeout != null) {
			tracer && tracer("DbgpClient._asyncCall [future] timeout: " + tracker.id + "\n>>> " + tracker.result);
			return;
		}
		tracer && tracer("DbgpClient._asyncCall [future] onComplete: " + tracker.id + "\n>>> " + tracker.result);
		ctx.onComplete(tracker);
	});
}