"use strict";
/// !doc
/// 
/// # DBGP proxy client
/// 
/// Send request and listen to incomming DBGP packet
/// 
/// ``` javascript
/// var client = require('syracuse-studio/lib/dbgp/proxyClient');
/// ```
var sys = require("util");
var crypto = require('crypto');
var ez = require('ez-streams');
var helpers = require('syracuse-core/lib/helpers');
var datetime = require("syracuse-core/lib/types/datetime");
var jsxml = require("jsxml/lib/jsxml");
var config = require('config');
var studioConfig = config.studio || {};
var dbgpConfig = studioConfig.dbgp || {};

var tracer = require("syracuse-trace/lib/helper").getTracer("studio.proxy") || {
	debug: studioConfig.trace,
	info: studioConfig.trace,
	warn: studioConfig.trace,
	error: studioConfig.trace,
};

var trackers = {};

var oky = dbgpConfig.key || (dbgpConfig.key = "da85538b-c44c-4864-96aa-5ab5263fbf89");
var secret = (function() {
	var o = {
		k: oky
	};
	var x = 0;
	return o.k.replace(/./g, function(c) {
		return String.fromCharCode(0x21 + ((x += c.charCodeAt(0)) & 0x3f));
	});

})();

function getToken(key) {
	var md5sum = crypto.createHash('md5'),
		token = {
			"key": key,
			"date": datetime.now().toString(),
			"once": helpers.uuid.generate()
		};
	md5sum.update(token.key + '/' + token.date + '/' + token.once + '/' + secret, "ascii");
	token.signature = md5sum.digest("hex");
	return new Buffer(JSON.stringify(token)).toString('base64');
}

exports.create = function _create(port, host, opt) {
	return new DbgpProxyClient(port, host, opt);
};

function DbgpMessage(size, xml) {
	this.size = typeof(size) === "string" ? parseInt(size, 10) : size;
	var length;
	if (typeof(xml) === "string") {
		this.xml = xml;
		length = Buffer.byteLength(xml, 'utf8');
	} else {
		this.xml = xml.toString("utf8");
		length = xml.length;
	}
	if (length !== this.size)
		throw new Error("Dbgp message size mismatch: expected " + this.size + " got " + length);
}

DbgpMessage.prototype.toString = function() {
	return [this.size, this.xml, ""].join("\0");
};

function DbgpProxyClient(port, hostname, opt) {
	opt = opt || {};
	this.family = opt.family;
	this.key = helpers.uuid.generate();

	var stream;
	var self = this;

	function _isAlive() {
		return stream && !stream.closed;
	}

	function _ensureConnect(_) {
		if (!_isAlive()) {
			stream = ez.devices.net.tcpClient(port, hostname).connect(_);
			stream.setNoDelay(true);
		}
	}

	function readSegment(_) {
		var seg = [],
			c;
		while ((c = stream.read(_, 1, false)) && c && c[0] !== 0) {
			seg.push(c[0]);
		}
		if (c == null) {
			throw new Error("Dbgp protocol error: End of stream - closed=" + stream.closed + ", client=" + (self.name));
		}
		return new Buffer(seg);
	}

	Object.defineProperty(this, 'isAlive', {
		get: function() {
			return _isAlive();
		}
	});

	Object.defineProperty(this, 'name', {
		get: function() {
			return (this.family + "." + this.key);
		}
	});

	this.close = function(_, transposed) {
		this.transposed = transposed;
		if (!_isAlive()) {
			stream = null;
			return;
		}
		tracer.debug && tracer.debug("DbgpClient.close: client=" + this.name + ", transposed=" + transposed + ", tracker=" + (this.trackerId) + ", peer=" + stream.localAddress + ":" + stream.localPort);
		stream.close(_);
		stream = null;
	};

	this._write = function(_, data) {
		_ensureConnect(_);
		tracer.debug && tracer.debug("DbgpClient.write: client=" + this.name + ", data=" + data);
		stream.write(_, data);
	};

	this._read = function(_, trackingId) {
		this.trackingId = trackingId;
		tracer.debug && tracer.debug("DbgpClient.read before: client=" + this.name + ", trackingId=" + trackingId + "\n" + //
			"\taddress=" + stream.localAddress + ":" + stream.localPort);
		_ensureConnect(_);
		var size = 0,
			c = 0,
			data = readSegment(_);
		size = parseInt(data.toString("utf8"), 10);
		if (isNaN(size))
			throw new Error("Dbgp protocol error: Size is not valid");
		data = stream.read(_, size, false);

		// read the last null char
		c = stream.read(_, 1, false);
		if (c == null)
			throw new Error("Dbgp protocol error: End of stream");
		if (c[0] !== 0)
			throw new Error("Dbgp protocol sync issue: expected 0 got " + c[0]);
		var msg = new DbgpMessage(size, data);
		tracer.debug && tracer.debug("DbgpClient.read after: client=" + this.name + ", trackingId=" + trackingId + "\n" + //
			"\taddress=" + stream.localAddress + ":" + stream.localPort + "\n" + //
			"\tdata=" + msg);
		return msg;
	};
}

helpers.defineClass(DbgpProxyClient, null, {
	parseXml: function(xml) {
		var o = jsxml.parse(xml);
		return o && o[Object.keys(o)[0]];
	},

	getState: function(_, opts) {
		opts = opts || {};
		var args = ["-k", getToken(this.key)];
		if (opts.v) args = args.concat("-v", opts.v);
		var data = this.sendCommand(_, "proxystate", args);
		return data.xml;
	},

	execCommand: function(_, cmd, opts) {
		opts = opts || {};
		var args = ["-k", getToken(this.key)];
		Object.keys(opts).filter(function(k) {
			return k && k.length === 1 && /[a-zA-Z]/.exec(k);
		}).forEach(function(k) {
			args = args.concat("-" + k.toLowerCase(), opts[k]);
		});
		var data = this.sendCommand(_, "proxy" + cmd, args);
		return data.xml;
	},

	poll: function(_, trackingId, options) {
		try {
			this.lastTrackingId = trackingId;
			var tracker;
			if (options) {
				options.onTimeout = options.onTimeout || function(tracker) {
					throw new Error("Dbgp proxy client request timeout");
				};
				tracer.debug && tracer.debug("DbgpClient.poll: [async] trackingId=" + trackingId + ", client=" + this.name);
				tracker = _makeReadTracker(_, this, trackingId);
				return _asyncCall(tracker, options);
			}
			tracer.debug && tracer.debug("DbgpClient.poll: [sync] trackingId=" + trackingId + ", client=" + this.name);
			return trackingId && this._getResult(_, trackingId) || this._read(_, trackingId);
		} catch (e) {
			this.close(_);
			throw e;
		}
	},

	submitCommand: function(_, cmd, args, options) {
		try {
			var tracker;
			// Build the command in the dbgp format: command [SPACE] [arguments...] [NULL]
			cmd = cmd.split(/\s+/).concat(args || []).join(" ").split(/\0/)[0] + "\0";
			this._write(_, cmd);
			tracker = _makeReadTracker(_, this);
			options && _asyncCall(tracker, options);
			return tracker;
		} catch (e) {
			this.close(_);
			throw e;
		}
	},

	_getResult: function(_, trackingId, wait) {
		var tracker = trackers[trackingId];
		delete trackers[trackingId];
		return tracker && (tracker.result || wait && tracker.future && tracker.future(_));
	},

	sendCommand: function(_, cmd, args) {
		var tracker = this.submitCommand(_, cmd, args);
		return this._getResult(_, tracker.id, true);
	}

});

function _wrapOnComplete(f) {
	return function(tracker) {
		tracer.debug && tracer.debug("DbgpClient._wrapOnComplete: id=" + tracker.id + ", hasFuture=" + !! tracker.future + //
			", timeout=" + tracker.timeout + "\n  >>> " + tracker.result);
		if (tracker) {
			tracker.future = null;
			delete trackers[tracker.id];
		}
		f && f(tracker);
	};
}

function _makeReadTracker(_, client, trackingId) {
	trackingId = trackingId || helpers.uuid.generate();
	var tracker = trackers[trackingId];
	tracer.debug && tracer.debug("_makeReadTracker: " + (tracker && tracker.id));
	if (tracker && tracker.client && tracker.client.transposed) {
		delete trackers[trackingId];
		tracker = null;
	}
	return tracker || (trackers[trackingId] = {
		client: client,
		id: trackingId,
		// create future to get the result later
		future: client._read(!_, trackingId)
	});
}

function _asyncCall(tracker, options) {
	if (!options)
		throw new Error("Cannot start async call");

	if (!tracker)
		return;

	tracer.debug && tracer.debug("DbgpClient._asyncCall: tracker=" + tracker.id);
	tracker.onTimeout = function(tracker) {
		var transposed = tracker.client && tracker.client.transposed;
		var t = trackers[tracker.id];
		if (transposed) {
			tracker.reason = "transposed";
			if (t.client === tracker.client) {
				trackers[tracker.id] = undefined;
			}
		}
		options.onTimeout(tracker);
	};
	tracker.onComplete = function(tracker) {
		options.onComplete(tracker);
		delete trackers[tracker.id];
	};
	tracker.onError = function(tracker, transposed) {
		if (transposed) {
			tracker.reason = "transposed";
			options.onTimeout(tracker);
		} else {
			options.onError(tracker);
		}
		delete trackers[tracker.id];
	};

	if (tracker.done) {
		if (tracker.error) {
			tracer.debug && tracer.debug("DbgpClient._asyncCall onError: trackerId=" + tracker.id + "\n  >>> " + tracker.result);
			return tracker.onError && tracker.onError(tracker);
		} else {
			tracer.debug && tracer.debug("DbgpClient._asyncCall onComplete: trackerId=" + tracker.id + ", onComplete=" + typeof(tracker.onComplete) + "\n  >>> " + tracker.result);
			return tracker.onComplete && tracker.onComplete(tracker);
		}
	}

	tracker.timeout = options.timeout || 4000;
	tracker.timer = setTimeout(function() {
		var transposed = tracker.client && tracker.client.transposed;
		tracer.debug && tracer.debug("DbgpClient._asyncCall [timeout] onTimeout: trackerId=" + tracker.id +
			", transposed=" + transposed +
			", client=" + (tracker.client && tracker.client.name));
		tracker.onComplete = null;
		tracker.onError = null;
		tracker.onTimeout && tracker.onTimeout(tracker);
	}, tracker.timeout);

	if (tracker.running)
		return;

	tracer.debug && tracer.debug("DbgpClient._asyncCall [call future]: trackerId=" + tracker.id + " hasFuture= " + !! tracker.future);
	var callback = function(e, r) {
		tracer.debug && tracer.debug("DbgpClient._asyncCall [future] callback: trackerId=" + tracker.id + ", client=" + (tracker.client && tracker.client.name) + "\n  >>> e=" + e + ", r=" + r);
		tracker.future = null;
		tracker.error = e;
		tracker.done = true;
		tracker.result = r;
		clearTimeout(tracker.timer);
		tracker.onTimeout = null;

		var transposed = tracker.client && tracker.client.transposed;
		if (e) {
			tracer.debug && tracer.debug("DbgpClient._asyncCall [future] onError: trackerId=" + tracker.id +
				", transposed=" + transposed +
				", client=" + (tracker.client && tracker.client.name) +
				"\n  >>> " + e.message);
			return tracker.onError && tracker.onError(tracker, transposed);
		}
		tracer.debug && tracer.debug("DbgpClient._asyncCall [future] onComplete: trackerId=" + tracker.id +
			", onComplete=" + typeof(tracker.onComplete) +
			", transposed=" + transposed +
			", client=" + (tracker.client && tracker.client.name) +
			"\n  >>> " + tracker.result);
		return tracker.onComplete && tracker.onComplete(tracker, transposed);
	};
	tracker.running = true;
	tracker.future && tracker.future(_ >> callback);
}