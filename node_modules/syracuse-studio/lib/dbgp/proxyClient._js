"use strict";
/// !doc
/// 
/// # DBGP proxy client
/// 
/// Send request and listen to incomming DBGP packet
/// 
/// ``` javascript
/// var client = require('syracuse-studio/lib/dbgp/proxyClient');
/// ```
var sys = require("util");
var ez = require('ez-streams');
var helpers = require('syracuse-core/lib/helpers');
var uuid = require('syracuse-core/lib/uuid');
var jsxml = require("jsxml/lib/jsxml");

var trackers = {};

exports.create = function _create(port, host, token) {
	return new DbgpProxyClient(port, host, token);
};

function DbgpMessage(size, xml) {
	this.size = typeof(size) == "string" ? parseInt(size, 10) : size;
	this.xml = xml;
	if (xml.length !== this.size)
		throw new Error("Dbgp message size mismatch: expected " + size + " got " + xml.length);
}

DbgpMessage.prototype.toString = function() {
	return [this.size, this.xml, ""].join("\0");
};

function DbgpProxyClient(port, hostname, token) {
	this.token = token;

	var stream;

	function _ensureConnect(_) {
		if (!stream) {
			stream = ez.devices.net.tcpClient(port, hostname).connect(_);
			stream.setEncoding("utf8").setNoDelay(true);
		}
	}

	// Object.defineProperty(this, 'isAlive') {
	// 	get: function() {
	// 		return stream && !stream.closed;
	// 	}
	// };

	this.close = function() {
		stream && stream.destroy();
		stream = null;
	};

	this._write = function(_, data) {
		_ensureConnect(_);
		stream.write(_, data);
	};

	this._read = function(_) {
		var data = "",
			c = 0;
		while ((c = stream.read(_, 1, false)).charCodeAt(0) !== 0) {
			data += c;
		}
		var size = parseInt(data, 10);
		data = stream.read(_, size, false);
		// read the last null char
		c = stream.read(_, 1, false);
		if (c.charCodeAt(0) !== 0) {
			throw new Error("Dbgp protocol sync issue: expected 0 got " + c.charCodeAt(0));
		}
		return new DbgpMessage(size, data);
	};
}

exports.DbgpProxyClient = helpers.defineClass(DbgpProxyClient, null, {
	parseXml: function(xml) {
		var o = jsxml.parse(xml);
		return o && o[Object.keys(o)[0]];
	},

	getState: function(_, opts) {
		opts = opts || {};
		var args = ["-k", this.token];
		if (opts.v || opts.verbose) args = args.concat("-v", "1");
		var data = this.sendCommand(_, "proxystate", args);
		return data.xml;
	},

	poll: function(_, trackingId, options) {
		try {
			var tracker;
			if (options) {
				options.onTimeout = options.onTimeout || function(tracker) {
					throw new Error("Dbgp proxy client request timeout");
				};
				tracker = _makeReadTracker(_, this, trackingId);
				return _asyncCall(_, tracker, options);
			}
			return trackingId && this._getResult(_, trackingId) || this._read(_);
		} catch (e) {
			this.close();
			throw e;
		}
	},

	submitCommand: function(_, cmd, args, options) {
		try {
			var tracker;
			cmd = cmd.split(/\s+/).concat(args || []).join(" ");
			this._write(_, cmd + "\0");
			tracker = _makeReadTracker(_, this);
			options && _asyncCall(_, tracker, options);
			return tracker;
		} catch (e) {
			this.close();
			throw e;
		}
	},

	_getResult: function(_, trackingId, wait) {
		var tracker = trackers[trackingId];
		delete trackers[trackingId];
		return tracker && (tracker.result || wait && tracker.future && tracker.future(_));
	},

	sendCommand: function(_, cmd, args) {
		var tracker = this.submitCommand(_, cmd, args);
		return this._getResult(_, tracker.id, true);
	}

});

function _wrapOnComplete(f) {
	return function(tracker) {
		if (tracker) {
			tracker.future = null;
			delete trackers[tracker.id];
		}
		f && f(tracker);
	};
}

function _makeReadTracker(_, client, trackingId) {
	trackingId = trackingId || helpers.uuid.generate();
	return trackers[trackingId] || (trackers[trackingId] = {
		id: trackingId,
		// create future to get the result later
		future: client._read(!_)
	});
}

function _asyncCall(_, tracker, options) {
	if (!options)
		throw new Error("Cannot start async call");

	var onTimeout = options.onTimeout,
		onComplete = _wrapOnComplete(options.onComplete),
		onError = options.onError,
		timeout = options.timeout || 4000;

	if (tracker && tracker.result) {
		return onComplete(tracker);
	}
	var tm = setTimeout(function() {
		tracker.timeout = timeout;
		if (tracker.result === undefined) {
			onTimeout && onTimeout(tracker);
		} else if (tracker.future) {
			// should not happen
			onComplete(tracker);
		}
	}, timeout);
	tracker.future(_ >> function(e, r) {
		clearTimeout(tm);
		if (e) return onError(e, tracker);
		tracker.result = r;
		if (tracker.timeout != null) {
			return;
		}
		onComplete(tracker);
	});
}