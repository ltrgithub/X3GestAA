"use strict";
/// !doc
/// 
/// # DBGP proxy client
/// 
/// Send request and listen to incomming DBGP packet
/// 
/// ``` javascript
/// var client = require('syracuse-studio/lib/dbgp/proxyClient');
/// ```
var sys = require("util");
var ez = require('ez-streams');
var helpers = require('syracuse-core/lib/helpers');
var uuid = require('syracuse-core/lib/uuid');
var jsxml = require("jsxml/lib/jsxml");
var config = require('syracuse-main/lib/nodeconfig').config;

var tracer = (config.studio || {}).trace;

var trackers = {};

exports.create = function _create(port, host, token, key) {
	return new DbgpProxyClient(port, host, token, key);
};

function DbgpMessage(size, xml) {
	this.size = typeof(size) == "string" ? parseInt(size, 10) : size;
	this.xml = xml;
	if (xml.length !== this.size)
		throw new Error("Dbgp message size mismatch: expected " + size + " got " + xml.length);
}

DbgpMessage.prototype.toString = function() {
	return [this.size, this.xml, ""].join("\0");
};

function DbgpProxyClient(port, hostname, token, key) {
	this.token = token;
	this.key = key;

	var stream;

	function _isAlive() {
		return stream && !stream.closed;
	}

	function _ensureConnect(_) {
		if (!_isAlive()) {
			stream = ez.devices.net.tcpClient(port, hostname).connect(_);
			stream.setEncoding("utf8").setNoDelay(true);
		}
	}

	function readSegment(_) {
		var seg = "",
			c;
		while ((c = stream.read(_, 1, false)) && c.charCodeAt(0) !== 0) {
			seg += c;
		}
		if (c == null) {
			throw new Error("Dbgp protocol error: End of stream - closed=" + stream.closed);
		}

		return seg;
	}

	Object.defineProperty(this, 'isAlive', {
		get: function() {
			return _isAlive();
		}
	});

	this.close = function() {
		if (!_isAlive()) {
			stream = null;
			return;
		}
		stream.end();
		stream.destroy();
		stream = null;
	};

	this._write = function(_, data) {
		_ensureConnect(_);
		tracer && tracer("DbgpClient.write: key=" + this.key + ", data=" + data);
		stream.write(_, data);
	};

	this._read = function(_, trackingId) {
		tracer && tracer("DbgpClient.read before _ensureConnect: key=" + this.key + ", trackingId=" + trackingId + "\n" + //
			"\taddress=" + stream.localAddress + ":" + stream.localPort);
		_ensureConnect(_);
		tracer && tracer("DbgpClient.read after _ensureConnect: key=" + this.key + ", trackingId=" + trackingId + "\n" + //
			"\taddress=" + stream.localAddress + ":" + stream.localPort);
		var size = 0,
			c = 0,
			data = readSegment(_);
		size = parseInt(data, 10);
		if (isNaN(size))
			throw new Error("Dbgp protocol error: Size is not valid");
		data = stream.read(_, size, false);

		// read the last null char
		c = stream.read(_, 1, false);
		if (c == null)
			throw new Error("Dbgp protocol error: End of stream");
		if (c.charCodeAt(0) !== 0)
			throw new Error("Dbgp protocol sync issue: expected 0 got " + c.charCodeAt(0));
		var msg = new DbgpMessage(size, data);
		tracer && tracer("DbgpClient.read: key=" + this.key + ", trackingId=" + trackingId + "\n" + //
			"\taddress=" + stream.localAddress + ":" + stream.localPort + "\n" + //
			"\tdata=" + msg);
		return msg;
	};
}

exports.DbgpProxyClient = helpers.defineClass(DbgpProxyClient, null, {
	parseXml: function(xml) {
		var o = jsxml.parse(xml);
		return o && o[Object.keys(o)[0]];
	},

	getState: function(_, opts) {
		opts = opts || {};
		var args = ["-k", this.token];
		if (opts.v) args = args.concat("-v", opts.v);
		var data = this.sendCommand(_, "proxystate", args);
		return data.xml;
	},

	execCommand: function(_, cmd, opts) {
		opts = opts || {};
		var args = ["-k", this.token];
		Object.keys(opts).filter(function(k) {
			return k && k.length === 1 && /[a-zA-Z]/.exec(k);
		}).forEach(function(k) {
			args = args.concat("-" + k.toLowerCase(), opts[k]);
		});
		var data = this.sendCommand(_, "proxy" + cmd, args);
		return data.xml;
	},

	poll: function(_, trackingId, options) {
		try {
			var tracker;
			if (options) {
				options.onTimeout = options.onTimeout || function(tracker) {
					throw new Error("Dbgp proxy client request timeout");
				};
				tracer && tracer("DbgpClient.poll: [async] trackingId=" + trackingId + ", key=" + this.key);
				tracker = _makeReadTracker(_, this, trackingId);
				return _asyncCall(tracker, options);
			}
			tracer && tracer("DbgpClient.poll: [sync] trackingId=" + trackingId + ", key=" + this.key);
			return trackingId && this._getResult(_, trackingId) || this._read(_, trackingId);
		} catch (e) {
			this.close();
			throw e;
		}
	},

	submitCommand: function(_, cmd, args, options) {
		try {
			var tracker;
			// Build the command in the dbgp format: command [SPACE] [arguments...] [NULL]
			cmd = cmd.split(/\s+/).concat(args || []).join(" ").split(/\0/)[0] + "\0";
			this._write(_, cmd);
			tracker = _makeReadTracker(_, this);
			options && _asyncCall(tracker, options);
			return tracker;
		} catch (e) {
			this.close();
			throw e;
		}
	},

	_getResult: function(_, trackingId, wait) {
		var tracker = trackers[trackingId];
		delete trackers[trackingId];
		return tracker && (tracker.result || wait && tracker.future && tracker.future(_));
	},

	sendCommand: function(_, cmd, args) {
		var tracker = this.submitCommand(_, cmd, args);
		return this._getResult(_, tracker.id, true);
	}

});

function _wrapOnComplete(f) {
	return function(tracker) {
		tracer && tracer("DbgpClient._wrapOnComplete: id=" + tracker.id + ", hasFuture=" + !! tracker.future + //
			", timeout=" + tracker.timeout + "\n  >>> " + tracker.result);
		if (tracker) {
			tracker.future = null;
			delete trackers[tracker.id];
		}
		f && f(tracker);
	};
}

function _makeReadTracker(_, client, trackingId) {
	trackingId = trackingId || helpers.uuid.generate();
	var tracker = trackers[trackingId];
	tracer && tracer("_makeReadTracker: " + (tracker && tracker.id));
	return trackers[trackingId] || (trackers[trackingId] = {
		id: trackingId,
		// create future to get the result later
		future: client._read(!_, trackingId)
	});
}

function _asyncCall(tracker, options) {
	if (!options)
		throw new Error("Cannot start async call");

	if (!tracker)
		return;

	tracer && tracer("DbgpClient._asyncCall: " + tracker.id);
	tracker.onTimeout = options.onTimeout;
	tracker.onComplete = function(tracker) {
		options.onComplete(tracker);
		delete trackers[tracker.id];
	};
	tracker.onError = function(tracker) {
		options.onError(tracker);
		delete trackers[tracker.id];
	};

	if (tracker.done) {
		if (tracker.error) {
			tracer && tracer("DbgpClient._asyncCall onError: trackerId=" + tracker.id + "\n  >>> " + tracker.result);
			return tracker.onError && tracker.onError(tracker);
		} else {
			tracer && tracer("DbgpClient._asyncCall onComplete: trackerId=" + tracker.id + ", onComplete=" + typeof(tracker.onComplete) + "\n  >>> " + tracker.result);
			return tracker.onComplete && tracker.onComplete(tracker);
		}
	}

	tracker.timeout = options.timeout || 4000;
	tracker.timer = setTimeout(function() {
		tracer && tracer("DbgpClient._asyncCall [timeout] onTimeout: trackerId=" + tracker.id);
		tracker.onComplete = null;
		tracker.onError = null;
		tracker.onTimeout && tracker.onTimeout(tracker);
	}, tracker.timeout);

	if (tracker.running)
		return;

	tracer && tracer("DbgpClient._asyncCall [call future]: trackerId=" + tracker.id + " hasFuture= " + !! tracker.future);
	var callback = function(e, r) {
		tracer && tracer("DbgpClient._asyncCall [future] callback: trackerId=" + tracker.id + "\n  >>> e=" + e + ", r=" + r);
		tracker.future = null;
		tracker.error = e;
		tracker.done = true;
		tracker.result = r;
		clearTimeout(tracker.timer);
		tracker.onTimeout = null;
		if (e) {
			tracer && tracer("DbgpClient._asyncCall [future] onError: trackerId=" + tracker.id + "\n  >>> " + e.message);
			return tracker.onError && tracker.onError(tracker);
		}
		tracer && tracer("DbgpClient._asyncCall [future] onComplete: trackerId=" + tracker.id + ", onComplete=" + typeof(tracker.onComplete) + "\n  >>> " + tracker.result);
		return tracker.onComplete && tracker.onComplete(tracker);
	};
	tracker.running = true;
	tracker.future && tracker.future(_ >> callback);
}