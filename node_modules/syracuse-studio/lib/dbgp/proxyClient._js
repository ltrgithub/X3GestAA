"use strict";
var sys = require("util");
var crypto = require('crypto');
var net = require('net');
var streams = require('streamline/lib/streams/streams');
var helpers = require('syracuse-core/lib/helpers');
var datetime = require("syracuse-core/lib/types/datetime");
var uuid = require('syracuse-core/lib/uuid');
var jsxml = require("jsxml/lib/jsxml");

exports.create = function _create(port, host, token) {
	return new DbgpProxyClient(port, host, token);
};

function DbgpProxyClient(port, hostname, token) {
	this.token = token;
	this.hostname = hostname;
	this.port = port;
}

exports.DbgpProxyClient = helpers.defineClass(DbgpProxyClient, null, {
	isAlive: function() {
		return this.stream && !this.stream.closed;
	},
	getState: function(_, opts) {
		opts = opts || {};
		var args = ["-k", this.token];
		if (opts.v || opts.verbose) args = args.concat("-v", "1");
		return this._sendCommand(_, "proxystate", args);
	},
	_ensureConnect: function(_) {
		if (!this.stream) {
			this.stream = streams.tcpClient(this.port, this.hostname).connect(_);
			this.stream.setEncoding("utf8").setNoDelay(true);
		}
	},
	_sendCommand: function(_, cmd, args) {
		try {
			cmd = cmd + (args && args.length && (" " + args.join(" ")) || "");
			this._ensureConnect(_);
			this.stream.write(_, cmd + "\0");
			return this._readPayload(_);
		} catch (e) {
			this.stream && this.stream.destroy();
			this.stream = null;
			throw e;
		}
	},
	_readPayload: function(_) {
		var data = "",
			c = 0;
		while ((c = this.stream.read(_, 1, false)).charCodeAt(0) !== 0) {
			data += c;
		}
		var size = parseInt(data, 10);
		data = this.stream.read(_, size, false);
		// read the last null char
		c = this.stream.read(_, 1, false);
		if (c.charCodeAt(0) !== 0) {
			throw new Error("dbgp protocol sync issue");
		}
		return data;
	}
});