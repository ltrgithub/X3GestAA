"use strict";
var sys = require("util");
var helpers = require('syracuse-core').helpers;
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require('streamline-locale');
var datetime = require('syracuse-core').types.datetime;
var config = require('config');
var studio = require('syracuse-studio/lib/studioSession');
var etnaDebugger = require('etna/lib/engine/debugger/server');
var proxyManager = require('syracuse-studio/lib/dbgp/proxyManager');
var proxyClient = require('syracuse-studio/lib/dbgp/proxyClient');
var sdataLocalizedText = locale.format.bind(undefined, require.cache[require.resolve('syracuse-sdata/lib/sdataDispatch')]);
var forEachKey = helpers.object.forEachKey;
var glob = require('streamline-runtime').globals;

var studioConfig = config.studio || {};
var dbgpConfig = studioConfig.dbgp || {};

var uuid = helpers.uuid;
var cfgTracer = (config.studio || {}).trace;
var tracer = require('syracuse-core').getTracer("studio.dispatch");

function getDiagnose(severity, message) {
	return JSON.stringify({
		$diagnoses: [{
			$severity: severity ? severity : "error",
			$message: message
		}]
	});
}

function getErrorDiagnose(error) {
	return JSON.stringify({
		$diagnoses: [{
			$severity: 'error',
			$message: error.message,
			$stackTrace: studioConfig.debug ? error.stack : undefined
		}]
	});
}

// Requests
// - Registering Studio's workspace to the server
//    => POST http://host/studio/$register('ac2c57db-fdb6-4688-8c39-99df0d18eef2')
// - Retrieving the list of endpoints
//    => GET  http://host/sdata/syracuse/collaboration/syracuse/endPoints?representation=endPoints.$query&where=protocol eq 'x3'
// - Get specific x3server
//    => GET  http://host/sdata/syracuse/collaboration/syracuse/x3servers('573894aa-711e-4134-8afe-7efaa37ff365')?representation=x3servers.$details
// - Invoke Funprog (NYI): For now we use the regular convergence protocol
//    => POST http://host/studio/{appplication}/{contact}/{dataset}/$invoke
//    => { "$method": { name: "AXDTMAIN.GET_ENV_INFO", args: [""] }, $sign="sdlkjsdlkshs" }

//URL is http://host/studio/
var _studioMap = {
	walk: function(_, context, name, id) {
		context.applicationName = name;
		return _dispatch(_, context, _applicationMap);
	},
	get: function(_, context) {
		return context.reply(_, 204);
	},

	// POST http://host/studio/$register('id')
	// { "$uuid": "ac2c57db-fdb6-4688-8c39-99df0d18eef2" }
	register: function(_, context, id) {
		if (context.method !== "post") {
			throw context.badMethod(context.method);
		}
		// start the dbgp proxy if it has not been started yet
		proxyManager.startDbgpProxy(_);
		var data = JSON.parse(context.request.readAll(_));
		tracer.debug && tracer.debug("register: data=" + sys.inspect(data));
		context.reply(_, 200, studio.createStudioSession(_, context, data));
	},

	// POST http://host/studio/$attach('id')
	// { "$sid": "7cbf6933-d6f8-4e71-9f15-bd8f82987e77" }
	attach: function(_, context, id) {
		if (context.method !== "post") {
			throw context.badMethod(context.method);
		}
		var data = JSON.parse(context.request.readAll(_));
		var sid = data.$sid || id;
		tracer.debug && tracer.debug("attach: data=" + sys.inspect(data));

		studio.checkFeature(_, "debug");

		var dbgpCtx = _getDbgpContext(context, true);
		tracer.debug && tracer.debug("attach: dbgpCtx.lastId=" + dbgpCtx.lastId + ", clients=" + dbgpCtx.getClientPairs());
		if (dbgpCtx.lastId) {
			var oldClient = _removeDbgpClient(context, dbgpCtx.lastId);
			var debugClient = _createDbgpEtnaClient(_);
			debugClient.$isVerified = true;
			var res = debugClient.sendCommand(_, "attach", ["-s", sid, "-j", 1]);
			dbgpCtx.setPending(dbgpCtx.lastId, debugClient);
			// close existing client and delegate result to the new one
			oldClient && oldClient.close && oldClient.close(_, true);
			context.reply(_, 200, res);
		} else {
			context.reply(_, 500, "no available client");
		}
	},

	// POST http://host/studio/$proxy
	proxy: function(_, context, id) {
		return _dispatch(_, context, _proxyServiceMap);
	}

	// // POST http://host/studio/$direct
	// direct: function(_, context, id) {
	// 	return _dispatch(_, context, _proxyServiceMap);
	// }
};

//URL is http://host/studio/{appplication}
var _applicationMap = {
	walk: function(_, context, name, id) {
		context.contractName = name;
		// var app = adminHelper.getApplication(_, context.applicationName, context.contractName);
		// if (!app || (app && app.protocol(_) !== "x3")) throw context.notFound(locale.format(module, "applicationNotFound", context.applicationName, context.contractName));
		// context.applicationRef = app;
		// //
		return _dispatch(_, context, _contractMap);
	}
};

//URL is http://host/studio/{appplication}/{contact}
var _contractMap = {
	walk: function(_, context, name, id) {
		context.dataset = name;

		// if (context.applicationRef) { // TEST to allow stubs
		// find the endpoint
		// var ep = adminHelper.getEndpoint(_, {
		// 	dataset: name
		// });
		var ep = adminHelper.getEndpoint(_, {
			application: context.applicationName,
			contract: context.contractName,
			dataset: name
		});

		if (!ep) throw context.notFound(sdataLocalizedText("endpointNotFound", context.applicationName, context.contractName, name));
		context.endpoint = ep;
		//
		context.baseUrl = context.walked();
		// }
		return _dispatch(_, context, _datasetMap);
	}
};

//URL is http://host/studio/{appplication}/{contact}/{dataset}
var _datasetMap = {
	// POST http://host/studio/{appplication}/{contact}/{dataset}/$operation
	// { "$operation": "update", "$data": { "folder": "SUPERV", "filename": "AXDTMAIN","content":"..." } }
	operation: function(_, context) {
		if (context.method !== "post") {
			throw context.badMethod();
		}
		var data = JSON.parse(context.request.readAll(_));
		var ses = studio.getStudioSession();
		if (!ses || !ses.$uuid) {
			tracer.debug && tracer.debug("studio-operation failed: data=" + JSON.stringify(data) + ", studioSession=" + ses + ', $uuid=' + (ses && ses.$uuid));
			throw context.forbidden("Not registered");
		}
		var op = data.$operation && ses[data.$operation];
		if (!op) {
			throw context.forbidden("Invalid operation");
		}

		context.reply(_, 200, op.call(ses, _, context.endpoint, data.$data || {}));
	},

	// POST http://host/studio/{appplication}/{contact}/{dataset}/$invoke
	// { "$method": { name: "AXDTMAIN.GET_ENV_INFO", args: [""] }, $sign="sdlkjsdlkshs" }
	invoke: function(_, context, id) {
		throw context.niy("invoke");
	},
};

var _proxyServiceMap = {
	walk: function(_, context, name, id) {
		context.operation = name;
		var op = _proxyServiceOperationMap[name] || _proxyServiceOperationMap["_admin_"],
			method = op && op[context.method];
		if (!method)
			throw context.notFound();
		return method.call(op, _, context);
	}
};

function _adminOperation(_, context, id) {
	var dbgpClient = _getDbgpProxyClient(_, context, "admin", uuid.generate()),
		proxyState = null,
		headers = {
			"content-type": "text/xml"
		};

	studio.checkFeature(_, "debug");

	proxyState = dbgpClient.execCommand(_, context.operation, context.parameters);
	dbgpClient.close(_);
	if (context.parameters.alt !== "xml") {
		headers["content-type"] = "application/json";
		proxyState = dbgpClient.parseXml(proxyState);
	}
	_rawReply(context, 200, proxyState, headers);
	dbgpClient = null;
}

var _proxyServiceOperationMap = {
	_admin_: {
		// GET http://host/studio/$proxy/<operation>
		// GET http://host/studio/$proxy/<operation>?alt=xml&t=100&u=c2c6c6af-53e6-4265-972d-a087a386c179
		get: _adminOperation,
		// POST http://host/studio/$proxy/<operation>
		// POST http://host/studio/$proxy/<operation>?alt=xml&t=100&u=c2c6c6af-53e6-4265-972d-a087a386c179
		post: _adminOperation
	},

	start: {
		// POST http://host/studio/$proxy/start
		post: function(_, context, id) {
			return context.reply(_, 200, proxyManager.startDbgpProxy(_));
		}
	},

	connect: {
		// POST http://host/studio/$proxy/connect?sid=xxxxxxxx-yyyy-zzzz-wwww-vvvvvvvvvvvv
		// This url is used to create a new proxy connection
		post: function(_, context, id) {
			tracer.debug && tracer.debug("studio-proxy-connect: " + context.url + "?" + context.rawQuery);
			if (context.parameters.sid == null)
				throw context.badRequest("sid parameter expected");
			var data = JSON.parse(context.request.readAll(_)) || {};
			tracer.debug && tracer.debug("studio-proxy-connect: data=" + JSON.stringify(data));
			studio.touchStudioSessionInfo(_, context, data, {
				proxy: true
			});
			studio.checkFeature(_, "debug");

			var sid = data.$sid;
			var dbgpClient = _getDbgpProxyClient(_, context, "session", sid);
			dbgpClient.$isVerified = true;
			return context.reply(_, 200, {
				$sid: sid
			});
		}
	},

	disconnect: {
		// POST http://host/studio/$proxy/disconnect?sid=xxxxxxxx-yyyy-zzzz-wwww-vvvvvvvvvvvv
		post: function(_, context, id) {
			var sid = context.parameters.sid;
			if (sid == null)
				throw context.badRequest("sid parameter expected");
			_closeDbgpClient(_, context, sid);
			return context.reply(_, 200, {
				$sid: sid
			});
		}
	},

	session: {
		// GET http://host/studio/$proxy/session?sid=xxxxxxxx-yyyy-zzzz-wwww-vvvvvvvvvvvv
		// GET http://host/studio/$proxy/session?sid=xxxxxxxx-yyyy-zzzz-wwww-vvvvvvvvvvvv&trackingId=aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee
		// This url is used to poll and read dbgp packets sent by the X3 debugger through the dbgp proxy
		get: function(_, context, id) {
			tracer.debug && tracer.debug("studio-proxy-poll: " + context.url + "?" + context.rawQuery);
			var sid = context.parameters.sid;
			if (sid == null)
				throw context.badRequest("sid parameter expected");
			var dbgpClient = _getDbgpClient(_, context, sid),
				timeout = context.parameters.timeout || dbgpConfig.longPollingMillis,
				httpSession = context.httpSession;

			if (!dbgpClient) {
				throw context.forbidden("Not initialized");
			}
			if (!dbgpClient.$isVerified) {
				throw context.forbidden("Not verified");
			}
			httpSession && httpSession.touch();
			dbgpClient.poll(_, context.parameters.trackingId, _makeAsyncOptions(context, timeout));
		},
		// POST http://host/studio/$proxy/session?sid=xxxxxxxx-yyyy-zzzz-wwww-vvvvvvvvvvvv
		// This url is used to forward a dbgp command to the X3 debugger through the dbgp proxy
		post: function(_, context, id) {
			tracer.debug && tracer.debug("studio-proxy-command: " + context.url + "?" + context.rawQuery);
			var sid = context.parameters.sid;
			if (sid == null)
				throw context.badRequest("sid parameter expected");
			// Respond with 202 and a tracking id after the given timeout
			var dbgpClient = _getDbgpClient(_, context, sid),
				timeout = context.parameters.timeout || dbgpConfig.trackingMillis;

			if (!dbgpClient) {
				throw context.forbidden("Not initialized");
			}
			if (!dbgpClient.$isVerified) {
				throw context.forbidden("Not verified");
			}
			var data = context.request.readAll(_);
			tracer.debug && tracer.debug("studio-proxy-command: " + data);
			dbgpClient.submitCommand(_, data, null, _makeAsyncOptions(context, timeout));
		}
	}
};

function _getDbgpContext(context, initialize) {
	var session = context.request && context.request.session;
	if (!(session && session.setData))
		throw new Error("Bad session context");

	var dbgpCtx = session.getData("dbgpContext");
	if (dbgpCtx == null && initialize)
		session.setData("dbgpContext", dbgpCtx = new DbgpContext());
	return dbgpCtx || new DbgpContext();
}

function DbgpContext() {
	this.map = {};
	this.pendings = {};
}

DbgpContext.prototype = {
	getClients: function() {
		return this.map || (this.map = {});
	},
	getClientPairs: function() {
		var clients = this.map;
		return Object.keys(clients).map(function(k) {
			return [k, clients[k].name];
		});
	},
	getClient: function(id) {
		return this.map[id || ""];
	},
	setClient: function(id, client) {
		return (this.map[id || ""] = client);
	},
	removeClient: function(id) {
		id = id || "";
		var c = this.map[id];
		delete this.map[id];
		return c;
	},
	closeAll: function(_) {
		var clients = this.map;
		Object.keys(clients).forEach_(_, function(_, k) {
			var c = clients[k];
			delete clients[k];
			c && c.close && c.close(_);
		});
	},
	getPending: function(id) {
		return this.pendings[id || ""];
	},
	setPending: function(id, client) {
		this.pendings[id || ""] = client;
	}

};

// function MultiplexedClient(sid) {
// 	this.sid = sid;
// 	this.channels = {};
// }

// MultiplexedClient.prototype = {
// 	create:function (_, type, fnCreate) {
// 		this.channels[type] = fnCreate(_)
// 	},
// 	getPrimary: function() {
// 		return this.channels.$primary;
// 	}
// };

// ["poll", "close"].forEach(function(name) {
// 	MultiplexedClient.prototype[name] = function(_) {
// 		var args = Array.prototype.slice.call(arguments, 1);
// 		Object.keys(this.channels).forEach_(_, function(_, k) {
// 			if ()
// 			var c = this.channels[k]
// 			flows.apply(_, c[name], c, args, 0);
// 		});
// 	}
// });

function _getDbgpProxyClient(_, context, type, sid) {
	// start the dbgp proxy if it has not been started yet
	proxyManager.startDbgpProxy(_);

	return _getDbgpClient(_, context, sid, type, proxyManager.createClient);
}

function _getDbgpEtnaClient(_, context, sid) {
	return _getDbgpClient(_, context, sid, "etna", function(_) {
		return _createDbgpEtnaClient(_);
	});
}

function _createDbgpEtnaClient(_) {
	var port = etnaDebugger.getPort();
	return proxyClient.create(port, "", {
		family: "etna"
	});
}

function _getDbgpClient(_, context, sid, type, create) {
	var dbgpCtx = _getDbgpContext(context, true);
	tracer.debug && tracer.debug("_getDbgpClient: " + context.url + "?" + context.rawQuery + //
		"\n\tclientId=" + context.httpSession.id +
		"\n\tsid=" + sid + ", type=" + type +
		"\n\tlast=" + dbgpCtx.lastId +
		"\n\tclients=" + JSON.stringify(dbgpCtx.getClientPairs()) +
		"\n\tpending=" + JSON.stringify(dbgpCtx.getPending(dbgpCtx.lastId))
	);

	if (!studio.canDebug(_)) {
		dbgpCtx.closeAll(_);
		throw studio.notAuthorized("debug");
	}

	var c = dbgpCtx.getClient(sid);
	if (!c) {
		c = dbgpCtx.getPending(sid);
		if (c) dbgpCtx.setClient(sid, c);
	}
	if (c == null && create != null) {
		c = dbgpCtx.setClient(sid, create(_, {
			type: type,
			sid: sid
		}));
		dbgpCtx.lastId = sid;
	}
	tracer.debug && tracer.debug("_getDbgpClient returns: client=" + (c && c.name) + ", isAlive=" + (c && c.isAlive) + ", $isVerified=" + (c && c.$isVerified));
	return c;
}

function _removeDbgpClient(context, sid) {
	var dbgpCtx = _getDbgpContext(context);
	tracer.debug && tracer.debug("_removeDbgpClient: " + context.url + "?" + context.rawQuery + //
		"\nclientId=" + context.httpSession.id +
		"\nsid=" + sid +
		"\nclients=" + JSON.stringify(dbgpCtx.getClientPairs())
	);
	return dbgpCtx.removeClient(sid);
}

function _closeDbgpClient(_, context, sid) {
	var dbgpCtx = _getDbgpContext(context);
	tracer.debug && tracer.debug("_closeDbgpClient: " + context.url + "?" + context.rawQuery + //
		"\nclientId=" + context.httpSession.id +
		"\nsid=" + sid +
		"\nclients=" + JSON.stringify(dbgpCtx.getClientPairs())
	);

	var c = dbgpCtx.removeClient(sid);
	tracer.debug && tracer.debug("_closeDbgpClient returns: client=" + (c && c.name) + ", isAlive=" + (c && c.isAlive));
	return c && c.close && c.close(_);
}

function _rawReply(context, statusCode, result, headers) {
	var sid = context.parameters.sid;
	if (cfgTracer) {
		var dbgpCtx = _getDbgpContext(context);
		cfgTracer("_rawReply =============\n" + //
			"\turl=" + context.url + "?" + context.rawQuery + "\n" + //
			"\tclosed=" + context.response.closed + "\n" + //
			"\tclients=" + dbgpCtx.getClientPairs() + "\n" + //
			"\tresult=" + (typeof(result) === "object" ? JSON.stringify(result) : result));
	}

	function callback(e, r) {
		tracer.debug && tracer.debug("Cannot send response: Request response is closed - " + context.url + "?" + context.rawQuery);
	}
	if (context.response.closed) {
		var session = studio.getStudioSession(context);
		if (session && session.$uuid && sid != session.$uuid)
			_closeDbgpClient(callback, context, session.$uuid);
		if (sid) {
			_closeDbgpClient(callback, context, sid);
		}
		return;
	}
	context.response.writeHead(statusCode, headers);
	context.response.end(typeof(result) === "object" ? JSON.stringify(result) : result, "utf8");
}

function _trackerReply(tracker, context, statusCode, result, headers) {
	cfgTracer && cfgTracer("StudioDispatcher._trackerReply: id=" + tracker.id + ", hasFuture=" + !! tracker.future + //
		", timeout=" + tracker.timeout + "\n  >>> result=" + tracker.result);
	_rawReply(context, statusCode, result, headers);
}

function _makeAsyncOptions(context, timeout) {
	return {
		onTimeout: function(tracker) {
			_trackerReply(tracker, context, 202, {
				$trackingId: tracker.id,
				$reason: tracker.reason,
				$pollingMillis: 200
			}, {
				"content-type": "application/json"
			});
		},
		onComplete: function(tracker) {
			_trackerReply(tracker, context, 200, tracker.result.toString(), {
				"content-type": "text/plain"
			});
		},
		onError: function(tracker) {
			var e = tracker.error;
			var sid = context.parameters.sid;
			tracer.error && tracer.error("ERROR in AsyncCall: " + e.message + " \n" + e.stack);
			var session = studio.getStudioSession(context);
			// if (tracker.client && tracker.client.gracefulClose) {
			// 	cfgTracer && cfgTracer("Retry polling for client marked for graceful Close " + sid);
			// 	return _trackerReply(tracker, context, 202, {
			// 		$trackingId: tracker.id,
			// 		$pollingMillis: 200
			// 	}, {
			// 		"content-type": "application/json"
			// 	});
			// }
			_trackerReply(tracker, context, 500, {
				$trackingId: tracker.id,
				$diagnoses: [{
					$severity: "error",
					$message: e.message,
					$stackTrace: studioConfig.debug ? e.stack : undefined
				}]
			}, {
				"content-type": "application/json"
			});
		},
		timeout: timeout
	};
}

function _parseSegment(segment) {
	var match = /^([^\/(]*)(\('([^']*)'\))?$/.exec(segment);
	return match ? {
		name: match[1],
		id: match[3]
	} : {
		name: segment
	};
}

function _dispatch(_, context, map) {
	var seg = context.walkUrl();
	if (seg == null) {
		// we reached the end of the URL, dispatch method
		//var method = context.request.method.toLowerCase();
		var method = context.method;
		if (map[method]) return map[method](_, context);
		else throw context.badMethod(method);
	} else {
		var pair = _parseSegment(seg);
		if (pair.name[0] === '$') {
			var name = pair.name.substring(1);
			if (map[name]) {
				return map[name](_, context, pair.id);
			}
		} else if (map.walk) {
			return map.walk(_, context, pair.name, pair.id);
		}
		throw context.badRequest(sdataLocalizedText("unexpectedSegment", seg));
	}
}

function _doIt(_, context) {
	var protocol = context.walkUrl();
	if (protocol !== "studio") {
		throw new Error("bad Url: protocol mismatch [" + protocol + "]");
	}
	_dispatch(_, context, _studioMap);
}

exports.dispatcher = function(config) {
	return function(_, request, response) {
		var context = new Context(request, response, config),
			_request = request._request,
			_response = response._response;

		request.context = context;
		if (cfgTracer) {
			var studioSession = studio.getStudioSession();
			var dbgpCtx = _getDbgpContext(context);

			cfgTracer("dispatcher: " + context.url + "?" + context.rawQuery + //
				"\n\tcookie=" + request.headers["cookie"] + //
				"\n\tstudioSession=" + studioSession + ", $uuid=" + (studioSession && studioSession.$uuid) + //
				"\nclients=" + JSON.stringify(dbgpCtx.getClientPairs())
			);
		}
		try {
			studio.authorized(context);
			_doIt(_, context);
		} catch (e) {
			console.error(request.url + " - " + e.stack);
			tracer.error && tracer.error("Dispatching error: " + request.url + " - " + e.stack);
			var headers = {
				"content-type": "application/json"
			};
			context.response.writeHead(500, headers);
			context.response.end(getErrorDiagnose(e));
		}
	};
};