"use strict";
var sys = require("util");
var jsxml = require("jsxml/lib/jsxml");
var helpers = require('syracuse-core/lib/helpers');
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var datetime = require("syracuse-core/lib/types/datetime");
var config = require('config');
var studio = require('syracuse-studio/lib/studioSession');
var proxyManager = require('syracuse-studio/lib/dbgp/proxyManager');
var sdataLocalizedText = locale.format.bind(undefined, require.cache[require.resolve('syracuse-sdata/lib/sdataDispatch')]);
var forEachKey = helpers.object.forEachKey;
var glob = require("streamline/lib/globals");

var studioConfig = config.studio || {};
var dbgpConfig = studioConfig.dbgp || {};

var uuid = helpers.uuid;
var cfgTracer = (config.studio || {}).trace;
var tracer = require("syracuse-trace/lib/helper").getTracer("studio.dispatch");

function getDiagnose(severity, message) {
	return JSON.stringify({
		$diagnoses: [{
			$severity: severity ? severity : "error",
			$message: message
		}]
	});
}

function getErrorDiagnose(error) {
	return JSON.stringify({
		$diagnoses: [{
			$severity: 'error',
			$message: error.message,
			$stackTrace: studioConfig.debug ? error.stack : undefined
		}]
	});
}

// Requests
// - Registering Studio's workspace to the server
//    => POST http://host/studio/$register('ac2c57db-fdb6-4688-8c39-99df0d18eef2')
// - Retrieving the list of endpoints
//    => GET  http://host/sdata/syracuse/collaboration/syracuse/endPoints?representation=endPoints.$query&where=protocol eq 'x3'
// - Get specific x3server
//    => GET  http://host/sdata/syracuse/collaboration/syracuse/x3servers('573894aa-711e-4134-8afe-7efaa37ff365')?representation=x3servers.$details
// - Invoke Funprog (NYI): For now we use the regular convergence protocol
//    => POST http://host/studio/{appplication}/{contact}/{dataset}/$invoke
//    => { "$method": { name: "AXDTMAIN.GET_ENV_INFO", args: [""] }, $sign="sdlkjsdlkshs" }

//URL is http://host/studio/
var _studioMap = {
	walk: function(_, context, name, id) {
		context.applicationName = name;
		return _dispatch(_, context, _applicationMap);
	},
	get: function(_, context) {
		return context.reply(_, 204);
	},

	// POST http://host/studio/$register('id')
	// { "$uuid": "ac2c57db-fdb6-4688-8c39-99df0d18eef2" }
	register: function(_, context, id) {
		if (context.method !== "post") {
			throw context.badMethod(context.method);
		}
		// start the dbgp proxy if it has not been started yet
		proxyManager.startDbgpProxy(_);
		var data = JSON.parse(context.request.readAll(_));
		tracer.debug && tracer.debug("register: data=" + sys.inspect(data));
		context.reply(_, 200, studio.createStudioSession(_, context, data));
	},

	// POST http://host/studio/$proxy
	proxy: function(_, context, id) {
		return _dispatch(_, context, _proxyServiceMap);
	}
};

//URL is http://host/studio/{appplication}
var _applicationMap = {
	walk: function(_, context, name, id) {
		context.contractName = name;
		// var app = adminHelper.getApplication(_, context.applicationName, context.contractName);
		// if (!app || (app && app.protocol(_) !== "x3")) throw context.notFound(locale.format(module, "applicationNotFound", context.applicationName, context.contractName));
		// context.applicationRef = app;
		// //
		return _dispatch(_, context, _contractMap);
	}
};

//URL is http://host/studio/{appplication}/{contact}
var _contractMap = {
	walk: function(_, context, name, id) {
		context.dataset = name;

		// if (context.applicationRef) { // TEST to allow stubs
		// find the endpoint
		// var ep = adminHelper.getEndpoint(_, {
		// 	dataset: name
		// });
		var ep = adminHelper.getEndpoint(_, {
			application: context.applicationName,
			contract: context.contractName,
			dataset: name
		});

		if (!ep) throw context.notFound(sdataLocalizedText("endpointNotFound", context.applicationName, context.contractName, name));
		context.endpoint = ep;
		//
		context.baseUrl = context.walked();
		// }
		return _dispatch(_, context, _datasetMap);
	}
};

//URL is http://host/studio/{appplication}/{contact}/{dataset}
var _datasetMap = {
	// POST http://host/studio/{appplication}/{contact}/{dataset}/$operation
	// { "$operation": "update", "$data": { "folder": "SUPERV", "filename": "AXDTMAIN","content":"..." } }
	operation: function(_, context) {
		if (context.method !== "post") {
			throw context.badMethod();
		}
		var data = JSON.parse(context.request.readAll(_));
		var ses = studio.getStudioSession();
		if (!ses || !ses.$uuid) {
			tracer.debug && tracer.debug("studio-operation failed: data=" + JSON.stringify(data) + ", studioSession=" + ses + ', $uuid=' + (ses && ses.$uuid));
			throw context.forbidden("Not registered");
		}
		var op = data.$operation && ses[data.$operation];
		if (!op) {
			throw context.forbidden("Invalid operation");
		}

		context.reply(_, 200, op.call(ses, _, context.endpoint, data.$data || {}));
	},

	// POST http://host/studio/{appplication}/{contact}/{dataset}/$invoke
	// { "$method": { name: "AXDTMAIN.GET_ENV_INFO", args: [""] }, $sign="sdlkjsdlkshs" }
	invoke: function(_, context, id) {
		throw context.niy("invoke");
	}
};

var _proxyServiceMap = {
	walk: function(_, context, name, id) {
		context.operation = name;
		var op = _proxyServiceOperationMap[name] || _proxyServiceOperationMap["_generic_"],
			method = op && op[context.method];
		if (!method)
			throw context.notFound();
		return method.call(op, _, context);
	}
};

function _genericOperation(_, context, id) {
	var dbgpClient = _getDbgpClient(_, context, "admin"),
		proxyState = null,
		headers = {
			"content-type": "text/xml"
		};

	studio.checkFeature(_, "debug");

	proxyState = dbgpClient.execCommand(_, context.operation, context.parameters);
	dbgpClient.close();
	if (context.parameters.alt !== "xml") {
		headers["content-type"] = "application/json";
		proxyState = dbgpClient.parseXml(proxyState);
	}
	_rawReply(context, 200, proxyState, headers);
	dbgpClient = null;
}

var _proxyServiceOperationMap = {
	_generic_: {
		// GET http://host/studio/$proxy/<operation>
		// GET http://host/studio/$proxy/<operation>?alt=xml&t=100&u=c2c6c6af-53e6-4265-972d-a087a386c179
		get: _genericOperation,
		// POST http://host/studio/$proxy/<operation>
		// POST http://host/studio/$proxy/<operation>?alt=xml&t=100&u=c2c6c6af-53e6-4265-972d-a087a386c179
		post: _genericOperation
	},

	start: {
		// POST http://host/studio/$proxy/start
		post: function(_, context, id) {
			return context.reply(_, 200, proxyManager.startDbgpProxy(_));
		}
	},

	connect: {
		// POST http://host/studio/$proxy/connect?sid=xxxxxxxx-yyyy-zzzz-wwww-vvvvvvvvvvvv
		// This url is used to create a new proxy connection
		post: function(_, context, id) {
			tracer.debug && tracer.debug("studio-proxy-connect: " + context.url + "?" + context.rawQuery);
			if (context.parameters.sid == null)
				throw context.badRequest("sid parameter expected");
			var data = JSON.parse(context.request.readAll(_)) || {};
			tracer.debug && tracer.debug("studio-proxy-connect: data=" + JSON.stringify(data));
			studio.touchStudioSessionInfo(_, context, data, {
				proxy: true
			});
			studio.checkFeature(_, "debug");

			var sid = data.$sid;
			var dbgpClient = _getDbgpClient(_, context, "session", sid),
				timeout = context.parameters.timeout || dbgpConfig.trackingMillis;
			dbgpClient.$isVerified = true;
			return context.reply(_, 200, {
				$sid: sid
			});
		}
	},

	disconnect: {
		// POST http://host/studio/$proxy/disconnect?sid=xxxxxxxx-yyyy-zzzz-wwww-vvvvvvvvvvvv
		post: function(_, context, id) {
			var sid = context.parameters.sid;
			if (sid == null)
				throw context.badRequest("sid parameter expected");
			_closeDbgpClient(context, "session", sid);
			return context.reply(_, 200, {
				$sid: sid
			});
		}
	},

	session: {
		// GET http://host/studio/$proxy/session?sid=xxxxxxxx-yyyy-zzzz-wwww-vvvvvvvvvvvv
		// GET http://host/studio/$proxy/session?sid=xxxxxxxx-yyyy-zzzz-wwww-vvvvvvvvvvvv&trackingId=aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee
		// This url is used to poll and read dbgp packets sent by the X3 debugger through the dbgp proxy
		get: function(_, context, id) {
			tracer.debug && tracer.debug("studio-proxy-poll: " + context.url + "?" + context.rawQuery);
			var sid = context.parameters.sid;
			if (sid == null)
				throw context.badRequest("sid parameter expected");
			var dbgpClient = _getDbgpClient(_, context, "session", sid),
				timeout = context.parameters.timeout || dbgpConfig.longPollingMillis,
				httpSession = context.httpSession;

			if (!dbgpClient.$isVerified) {
				throw context.forbidden("Not verified");
			}
			httpSession && httpSession.touch();
			dbgpClient.poll(_, context.parameters.trackingId, _makeAsyncOptions(context, timeout));
		},
		// POST http://host/studio/$proxy/session?sid=xxxxxxxx-yyyy-zzzz-wwww-vvvvvvvvvvvv
		// This url is used to forward a dbgp command to the X3 debugger through the dbgp proxy
		post: function(_, context, id) {
			tracer.debug && tracer.debug("studio-proxy-command: " + context.url + "?" + context.rawQuery);
			var sid = context.parameters.sid;
			if (sid == null)
				throw context.badRequest("sid parameter expected");
			// Respond with 202 and a tracking id after the given timeout
			var dbgpClient = _getDbgpClient(_, context, "session", sid),
				timeout = context.parameters.timeout || dbgpConfig.trackingMillis;

			if (!dbgpClient.$isVerified) {
				throw context.forbidden("Not verified");
			}
			var data = context.request.readAll(_);
			tracer.debug && tracer.debug("studio-proxy-command: " + data);
			dbgpClient.submitCommand(_, data, null, _makeAsyncOptions(context, timeout));
		}
	}
};

function _getSessionDbgpClients(context, initialize) {
	var session = context.request && context.request.session;
	if (!(session && session.setData))
		throw new Error("Bad session context");

	var clients = session.getData("dbgpClients");
	if (clients == null && initialize)
		session.setData("dbgpClients", clients = {});
	return clients || {};
}


function _getDbgpClient(_, context, type, sid) {
	// start the dbgp proxy if it has not been started yet
	proxyManager.startDbgpProxy(_);

	var clients = _getSessionDbgpClients(context, true);
	tracer.debug && tracer.debug("_getDbgpClient: " + context.url + "?" + context.rawQuery + //
		"\nclientId=" + context.httpSession.id +
		"\nkey=" + type + "_" + sid +
		"\nclients=" + Object.keys(clients)
	);

	var key = type + "_" + sid,
		c = clients[key];

	if (!studio.canDebug(_)) {
		Object.keys(clients).forEach(function(k) {
			var c = clients[k];
			delete clients[k];
			c && c.close && c.close();
		});
		throw studio.notAuthorized("debug");
	}

	tracer.debug && tracer.debug("_getDbgpClient returns: client=" + (c && c.key) + ", isAlive=" + (c && c.isAlive) + ", $isVerified=" + (c && c.$isVerified));
	return c ? c : (clients[key] = proxyManager.createClient(_, key));
}

function _closeDbgpClient(context, type, sid) {
	var clients = _getSessionDbgpClients(context);
	tracer.debug && tracer.debug("_closeDbgpClient: " + context.url + "?" + context.rawQuery + //
		"\nclientId=" + context.httpSession.id +
		"\nkey=" + type + "_" + sid +
		"\nclients=" + Object.keys(clients)
	);

	var key = type + "_" + (sid || ""),
		c = clients[key];
	tracer.debug && tracer.debug("_closeDbgpClient returns: client=" + (c && c.key) + ", isAlive=" + (c && c.isAlive));
	delete clients[key];
	return c && c.close && c.close();
}

function _rawReply(context, statusCode, result, headers) {
	var sid = context.parameters.sid;
	if (cfgTracer) {
		var clients = _getSessionDbgpClients(context);
		cfgTracer("_rawReply =============\n" + //
			"\turl=" + context.url + "?" + context.rawQuery + "\n" + //
			"\tclosed=" + context.response.closed + "\n" + //
			"\tclients=" + Object.keys(clients) + "\n" + //
			"\tresult=" + (typeof(result) === "object" ? JSON.stringify(result) : result));
	}
	if (context.response.closed) {
		var session = studio.getStudioSession(context);
		if (session && session.$uuid && sid != session.$uuid)
			_closeDbgpClient(context, "session", session.$uuid);
		if (sid) {
			_closeDbgpClient(context, "session", sid);
		}
		return;
	}
	context.response.writeHead(statusCode, headers);
	context.response.end(typeof(result) === "object" ? JSON.stringify(result) : result, "utf8");
}

function _trackerReply(tracker, context, statusCode, result, headers) {
	cfgTracer && cfgTracer("StudioDispatcher._trackerReply: id=" + tracker.id + ", hasFuture=" + !! tracker.future + //
		", timeout=" + tracker.timeout + "\n  >>> result=" + tracker.result);
	_rawReply(context, statusCode, result, headers);
}

function _makeAsyncOptions(context, timeout) {
	return {
		onTimeout: function(tracker) {
			_trackerReply(tracker, context, 202, {
				$trackingId: tracker.id,
				$pollingMillis: 200
			}, {
				"content-type": "application/json"
			});
		},
		onComplete: function(tracker) {
			_trackerReply(tracker, context, 200, tracker.result.toString(), {
				"content-type": "text/plain"
			});
		},
		onError: function(tracker) {
			var e = tracker.error;
			tracer.error && tracer.error("ERROR in AsyncCall: " + e.message + " \n" + e.stack);
			_trackerReply(tracker, context, 500, {
				$trackingId: tracker.id,
				$diagnoses: [{
					$severity: "error",
					$message: e.message,
					$stackTrace: studioConfig.debug ? e.stack : undefined
				}]
			}, {
				"content-type": "application/json"
			});
		},
		timeout: timeout
	};
}

function _parseSegment(segment) {
	var match = /^([^\/(]*)(\('([^']*)'\))?$/.exec(segment);
	return match ? {
		name: match[1],
		id: match[3]
	} : {
		name: segment
	};
}

function _dispatch(_, context, map) {
	var seg = context.walkUrl();
	if (seg == null) {
		// we reached the end of the URL, dispatch method
		//var method = context.request.method.toLowerCase();
		var method = context.method;
		if (map[method]) return map[method](_, context);
		else throw context.badMethod(method);
	} else {
		var pair = _parseSegment(seg);
		if (pair.name[0] === '$') {
			var name = pair.name.substring(1);
			if (map[name]) {
				return map[name](_, context, pair.id);
			}
		} else if (map.walk) {
			return map.walk(_, context, pair.name, pair.id);
		}
		throw context.badRequest(sdataLocalizedText("unexpectedSegment", seg));
	}
}

function _doIt(_, context) {
	var protocol = context.walkUrl();
	if (protocol !== "studio") {
		throw new Error("bad Url: protocol mismatch [" + protocol + "]");
	}
	_dispatch(_, context, _studioMap);
}

exports.dispatcher = function(config) {
	return function(_, request, response) {
		var context = new Context(request, response, config),
			_request = request._request,
			_response = response._response;

		request.context = context;
		if (cfgTracer) {
			var studioSession = studio.getStudioSession(),
				clients = _getSessionDbgpClients(context);

			cfgTracer("dispatcher: " + context.url + "?" + context.rawQuery + //
				"\n\tcookie=" + request.headers["cookie"] + //
				"\n\tstudioSession=" + studioSession + ", $uuid=" + (studioSession && studioSession.$uuid) + //
				"\nclients=" + Object.keys(clients)
			);
		}
		try {
			studio.authorized(context);
			_doIt(_, context);
		} catch (e) {
			console.error(request.url + " - " + e.stack);
			tracer.error && tracer.error("Dispatching error: " + request.url + " - " + e.stack);
			var headers = {
				"content-type": "application/json"
			};
			context.response.writeHead(500, headers);
			context.response.end(getErrorDiagnose(e));
		}
	};
};