"use strict";
var jsxml = require("jsxml/lib/jsxml");
var helpers = require('syracuse-core/lib/helpers');
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var datetime = require("syracuse-core/lib/types/datetime");
var config = require('syracuse-main/lib/nodeconfig').config;
var studio = require('syracuse-studio/lib/studioSession');
var proxyManager = require('syracuse-studio/lib/dbgp/proxyManager');
var sdataLocalizedText = locale.format.bind(undefined, require.cache[require.resolve('syracuse-sdata/lib/sdataDispatch')]);

var studioConfig = config.studio || {};
var x3Config = (config || {}).x3fusion || {};

var uuid = helpers.uuid;
var tracer = (config.studio || {}).trace;

function getDiagnose(severity, message) {
	return JSON.stringify({
		$diagnoses: [{
			$severity: severity ? severity : "error",
			$message: message
		}]
	});
}

function getErrorDiagnose(error) {
	return JSON.stringify({
		$diagnoses: [{
			$severity: 'error',
			$message: error.message,
			$stackTrace: studioConfig.debug && error.stack
		}]
	});
}

var studioSessions = {};
var dbgpServer;

// Requests
// - Registering Studio's workspace to the server
//    => POST http://host/studio/$register('ac2c57db-fdb6-4688-8c39-99df0d18eef2')
// - Retrieving the list of endpoints
//    => GET  http://host/sdata/syracuse/collaboration/syracuse/endPoints?representation=endPoints.$query&where=protocol eq 'x3'
// - Get specific x3server
//    => GET  http://host/sdata/syracuse/collaboration/syracuse/x3servers('573894aa-711e-4134-8afe-7efaa37ff365')?representation=x3servers.$details
// - Invoke Funprog
//    => POST http://host/studio/{dataset}/$invoke
//    => { "$method": { name: "AXDTMAIN.GET_ENV_INFO", args: [""] }, $sign="sdlkjsdlkshs" }

//URL is http://host/studio/{dataset}
var _studioMap = {
	walk: function(_, context, name, id) {
		context.dataset = name;
		var ep = adminHelper.getEndpoint(_, {
			dataset: name
		});
		context.endpoint = ep;
		return _dispatch(_, context, _datasetMap);
	},
	get: function(_, context) {
		return context.reply(_, 204);
	},

	// POST http://host/studio/$register('id')
	// { "$uuid": "ac2c57db-fdb6-4688-8c39-99df0d18eef2" }
	register: function(_, context, id) {
		if (context.method !== "post") {
			throw context.badMethod(context.method);
		}
		// start the dbgp proxy if it has not been started yet
		proxyManager.startDbgpProxy();
		var data = JSON.parse(context.request.readAll(_));
		context.reply(_, 200, studio.createStudioSession(_, context, data, id));
	},

	// POST http://host/studio/$proxy('opid')
	proxy: function(_, context, id) {
		var op = _proxyServiceMap[id];
		return op && op(_, context);
	}
};

//URL is http://host/studio/{dataset}/${service}
var _datasetMap = {
	// POST http://host/studio/{dataset}/$operation
	// { "$operation": "update", "$data": { "folder": "SUPERV", "filename": "AXDTMAIN","content":"..." } }
	operation: function(_, context) {
		if (context.method !== "post") {
			throw context.badMethod();
		}
		var ses = context.httpSession.studioSession;
		if (!ses || !ses.$uuid) {
			throw context.forbidden("Not registered");
		}
		var data = JSON.parse(context.request.readAll(_));
		// tracer && tracer("studio-operation: " + (data || {}).$operation);
		var op = data.$operation && ses[data.$operation];
		if (!op) {
			throw context.forbidden("Invalid operation");
		}

		context.reply(_, 200, op.call(ses, _, context.endpoint, data.$data || {}));
	},

	// POST http://host/studio/{dataset}/$invoke
	// { "$method": { name: "AXDTMAIN.GET_ENV_INFO", args: [""] }, $sign="sdlkjsdlkshs" }
	invoke: function(_, context, id) {
		throw context.niy("invoke");

		// tracer && tracer("studio-invoke: " + context.dataset + (id ? ", " + id : ""));
		// var request = context.request;
		// if (!request.session) {
		// 	throw new Error("no valid session");
		// }
		// // var client = x3pool.getClient(_, context.httpSession, context.endpoint);
		// context._reply = context.reply;
		// var _statusCode = 200,
		// 	_result,
		// 	_headers;

		// var session;
		// if (context.cvgSessionId) {
		// 	session = request.session.getCvgSession(context.cvgSessionId);
		// } else {
		// 	// trap reply
		// 	context.reply = function(_, statusCode, result, headers) {
		// 		_statusCode = statusCode;
		// 		_result = result;
		// 		_headers = headers;
		// 		context.cvgSessionId = /\$sessions\('([a-z0-9\-]+)'\)/.exec(headers.location || "")[1];
		// 	};
		// 	context.parameters.f = context.parameters.f || "";
		// 	// context.parameters.ack = context.parameters.ack || "1078";
		// 	cvgServices.connect(_, context, x3Config);
		// 	tracer && tracer("studio-invoke: -- connected" + context.dataset + (id ? ", " + id : ""));
		// 	// restore normal reply
		// 	context.reply = context._reply;
		// }

		// delete context._reply;

		// if (_statusCode === 200) {
		// 	context.reply(_, 200, {
		// 		$status: "Invoked"
		// 	});
		// } else {
		// 	context.reply(_, _statusCode, _result, _headers);
		// }
	}
};

function rawReply(context, statusCode, result, headers) {
	context.response.writeHead(statusCode, headers);
	context.response.end(typeof(result) === "object" ? JSON.stringify(result) : result, "utf8");
}

var _proxyServiceMap = {

	// GET http://host/studio/$proxy('state')
	// GET http://host/studio/$proxy('state')?alt=xml
	state: function(_, context, id) {
		if (context.method !== "get") {
			throw context.badMethod(context.method);
		}
		var studio = context.httpSession.studioSession,
			token;
		if (!studio)
			throw context.serverError("No Eclipse session registered");

		var dbgpClient = studio.dbgpClient || (studio.dbgpClient = proxyManager.createClient()),
			proxyState = dbgpClient.getState(_, context.parameters),
			headers = {
				"content-type": "text/xml"
			};
		if (context.parameters.alt !== "xml") {
			headers["content-type"] = "application/json";
			proxyState = jsxml.parse(proxyState);
		}
		rawReply(context, 200, proxyState, headers);
	},

	// POST http://host/studio/$proxy('start')
	start: function(_, context, id) {
		if (context.method !== "post") {
			throw context.badMethod(context.method);
		}
		return context.reply(_, 200, proxyManager.startDbgpProxy());
	}
};

function _parseSegment(segment) {
	var match = /^([^\/(]*)(\('([^']*)'\))?$/.exec(segment);
	return match ? {
		name: match[1],
		id: match[3]
	} : {
		name: segment
	};
}

function _dispatch(_, context, map) {
	var seg = context.walkUrl();
	if (seg == null) {
		// we reached the end of the URL, dispatch method
		//var method = context.request.method.toLowerCase();
		var method = context.method;
		if (map[method]) return map[method](_, context);
		else throw context.badMethod(method);
	} else {
		var pair = _parseSegment(seg);
		if (pair.name[0] === '$') {
			var name = pair.name.substring(1);
			if (map[name]) {
				return map[name](_, context, pair.id);
			}
		} else if (map.walk) {
			return map.walk(_, context, pair.name, pair.id);
		}
		throw context.badRequest(sdataLocalizedText("unexpectedSegment", seg));
	}
}

function _doIt(_, context) {
	var protocol = context.walkUrl();
	if (protocol !== "studio") {
		throw new Error("bad Url: protocol mismatch [" + protocol + "]");
	}
	_dispatch(_, context, _studioMap);
}

exports.dispatcher = function(config) {
	return function(_, request, response) {
		var context = new Context(request, response, config),
			_request = request._request,
			_response = response._response;

		request.context = context;
		try {
			_doIt(_, context);
		} catch (e) {
			var headers = {
				"content-type": "application/json"
			};
			context.response.writeHead(500, headers);
			context.response.end(getErrorDiagnose(e));
		}
	};
};