"use strict";
var jsxml = require("jsxml/lib/jsxml");
var helpers = require('syracuse-core/lib/helpers');
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var datetime = require("syracuse-core/lib/types/datetime");
var config = require('syracuse-main/lib/nodeconfig').config;
var studio = require('syracuse-studio/lib/studioSession');
var proxyManager = require('syracuse-studio/lib/dbgp/proxyManager');
var sdataLocalizedText = locale.format.bind(undefined, require.cache[require.resolve('syracuse-sdata/lib/sdataDispatch')]);

var studioConfig = config.studio || {};
var dbgpConfig = studioConfig.dbgp || {};
var x3Config = (config || {}).x3fusion || {};

var uuid = helpers.uuid;
var tracer = (config.studio || {}).trace;

function getDiagnose(severity, message) {
	return JSON.stringify({
		$diagnoses: [{
			$severity: severity ? severity : "error",
			$message: message
		}]
	});
}

function getErrorDiagnose(error) {
	return JSON.stringify({
		$diagnoses: [{
			$severity: 'error',
			$message: error.message,
			$stackTrace: studioConfig.debug && error.stack
		}]
	});
}

var studioSessions = {};
var dbgpServer;

// Requests
// - Registering Studio's workspace to the server
//    => POST http://host/studio/$register('ac2c57db-fdb6-4688-8c39-99df0d18eef2')
// - Retrieving the list of endpoints
//    => GET  http://host/sdata/syracuse/collaboration/syracuse/endPoints?representation=endPoints.$query&where=protocol eq 'x3'
// - Get specific x3server
//    => GET  http://host/sdata/syracuse/collaboration/syracuse/x3servers('573894aa-711e-4134-8afe-7efaa37ff365')?representation=x3servers.$details
// - Invoke Funprog (NYI): For now we use the regular convergence protocol
//    => POST http://host/studio/{dataset}/$invoke
//    => { "$method": { name: "AXDTMAIN.GET_ENV_INFO", args: [""] }, $sign="sdlkjsdlkshs" }

//URL is http://host/studio/{dataset}
var _studioMap = {
	walk: function(_, context, name, id) {
		context.dataset = name;
		var ep = adminHelper.getEndpoint(_, {
			dataset: name
		});
		context.endpoint = ep;
		return _dispatch(_, context, _datasetMap);
	},
	get: function(_, context) {
		return context.reply(_, 204);
	},

	// POST http://host/studio/$register('id')
	// { "$uuid": "ac2c57db-fdb6-4688-8c39-99df0d18eef2" }
	register: function(_, context, id) {
		if (context.method !== "post") {
			throw context.badMethod(context.method);
		}
		// start the dbgp proxy if it has not been started yet
		proxyManager.startDbgpProxy(_);
		var data = JSON.parse(context.request.readAll(_));
		context.reply(_, 200, studio.createStudioSession(_, context, data, id));
	},

	// POST http://host/studio/$proxy
	proxy: function(_, context, id) {
		return _dispatch(_, context, _proxyServiceMap);
	}
};

//URL is http://host/studio/{dataset}/${service}
var _datasetMap = {
	// POST http://host/studio/{dataset}/$operation
	// { "$operation": "update", "$data": { "folder": "SUPERV", "filename": "AXDTMAIN","content":"..." } }
	operation: function(_, context) {
		if (context.method !== "post") {
			throw context.badMethod();
		}
		var ses = context.httpSession.studioSession;
		if (!ses || !ses.$uuid) {
			throw context.forbidden("Not registered");
		}
		var data = JSON.parse(context.request.readAll(_));
		// tracer && tracer("studio-operation: " + (data || {}).$operation);
		var op = data.$operation && ses[data.$operation];
		if (!op) {
			throw context.forbidden("Invalid operation");
		}

		context.reply(_, 200, op.call(ses, _, context.endpoint, data.$data || {}));
	},

	// POST http://host/studio/{dataset}/$invoke
	// { "$method": { name: "AXDTMAIN.GET_ENV_INFO", args: [""] }, $sign="sdlkjsdlkshs" }
	invoke: function(_, context, id) {
		throw context.niy("invoke");

		// tracer && tracer("studio-invoke: " + context.dataset + (id ? ", " + id : ""));
		// var request = context.request;
		// if (!request.session) {
		// 	throw new Error("no valid session");
		// }
		// // var client = x3pool.getClient(_, context.httpSession, context.endpoint);
		// context._reply = context.reply;
		// var _statusCode = 200,
		// 	_result,
		// 	_headers;

		// var session;
		// if (context.cvgSessionId) {
		// 	session = request.session.getCvgSession(context.cvgSessionId);
		// } else {
		// 	// trap reply
		// 	context.reply = function(_, statusCode, result, headers) {
		// 		_statusCode = statusCode;
		// 		_result = result;
		// 		_headers = headers;
		// 		context.cvgSessionId = /\$sessions\('([a-z0-9\-]+)'\)/.exec(headers.location || "")[1];
		// 	};
		// 	context.parameters.f = context.parameters.f || "";
		// 	// context.parameters.ack = context.parameters.ack || "1078";
		// 	cvgServices.connect(_, context, x3Config);
		// 	tracer && tracer("studio-invoke: -- connected" + context.dataset + (id ? ", " + id : ""));
		// 	// restore normal reply
		// 	context.reply = context._reply;
		// }

		// delete context._reply;

		// if (_statusCode === 200) {
		// 	context.reply(_, 200, {
		// 		$status: "Invoked"
		// 	});
		// } else {
		// 	context.reply(_, _statusCode, _result, _headers);
		// }
	}
};

var _proxyServiceMap = {
	walk: function(_, context, name, id) {
		context.operation = name;
		var op = _proxyServiceOperationMap[name] || _proxyServiceOperationMap["_generic_"],
			method = op && op[context.method];
		if (!method)
			throw context.notFound();
		return method.call(op, _, context);
	}
};

function _genericOperation(_, context, id) {
	var dbgpClient = _getDbgpClient(_, context, "admin"),
		proxyState = null,
		headers = {
			"content-type": "text/xml"
		};

	proxyState = dbgpClient.execCommand(_, context.operation, context.parameters);
	dbgpClient.close();
	if (context.parameters.alt !== "xml") {
		headers["content-type"] = "application/json";
		proxyState = dbgpClient.parseXml(proxyState);
	}
	_rawReply(context, 200, proxyState, headers);
	dbgpClient = null;
}

var _proxyServiceOperationMap = {
	_generic_: {
		// GET http://host/studio/$proxy/<operation>
		// GET http://host/studio/$proxy/<operation>?alt=xml&t=100&u=c2c6c6af-53e6-4265-972d-a087a386c179
		get: _genericOperation,
		// POST http://host/studio/$proxy/<operation>
		// POST http://host/studio/$proxy/<operation>?alt=xml&t=100&u=c2c6c6af-53e6-4265-972d-a087a386c179
		post: _genericOperation
	},

	start: {
		// POST http://host/studio/$proxy/start
		post: function(_, context, id) {
			return context.reply(_, 200, proxyManager.startDbgpProxy(_));
		}
	},

	connect: {
		// POST http://host/studio/$proxy/connect?sid=1
		// This url is used to create a new proxy connection
		post: function(_, context, id) {
			tracer && tracer("studio-proxy-connect: " + context.url);
			var sid = context.parameters.sid;
			if (sid == null)
				throw context.badRequest("sid parameter expected");
			var dbgpClient = _getDbgpClient(_, context, "session", sid),
				timeout = context.parameters.timeout || dbgpConfig.trackingMillis;
			return context.reply(_, 200, {
				$sid: sid
			});
		}
	},

	disconnect: {
		// POST http://host/studio/$proxy/disconnect?sid=1
		post: function(_, context, id) {
			var sid = context.parameters.sid;
			if (sid == null)
				throw context.badRequest("sid parameter expected");
			_closeDbgpClient(context, "session", sid);
			return context.reply(_, 200, {
				$sid: sid
			});
		}
	},

	session: {
		// GET http://host/studio/$proxy/session?sid=1
		// GET http://host/studio/$proxy/session?sid=1&trackingId=aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee
		// This url is used to poll and read dbgp packets sent by the X3 debugger through the dbgp proxy
		get: function(_, context, id) {
			tracer && tracer("studio-proxy-poll: " + context.url);
			var sid = context.parameters.sid;
			if (sid == null)
				throw context.badRequest("sid parameter expected");
			var dbgpClient = _getDbgpClient(_, context, "session", sid),
				timeout = context.parameters.timeout || dbgpConfig.longPollingMillis;
			dbgpClient.poll(_, context.parameters.trackingId, _makeAsyncOptions(context, timeout));
		},
		// POST http://host/studio/$proxy/session
		// This url is used to forward a dbgp command to the X3 debugger through the dbgp proxy
		post: function(_, context, id) {
			tracer && tracer("studio-proxy-command: " + context.url);
			var sid = context.parameters.sid;
			if (sid == null)
				throw context.badRequest("sid parameter expected");
			// Respond with 202 and a tracking id after the given timeout
			var dbgpClient = _getDbgpClient(_, context, "session", sid),
				timeout = context.parameters.timeout || dbgpConfig.trackingMillis;
			var data = context.request.readAll(_);
			tracer && tracer("studio-proxy-command: " + data);
			dbgpClient.submitCommand(_, data, null, _makeAsyncOptions(context, timeout));
		}
	}

};

function _getDbgpClient(_, context, type, sid) {
	// start the dbgp proxy if it has not been started yet
	proxyManager.startDbgpProxy(_);
	sid = ~~sid;
	var key = type + "_" + (sid || 0),
		clients = context.httpSession.dbgpClients || (context.httpSession.dbgpClients = {}),
		ca = clients[type] || (clients[type] = []),
		c = ca[sid];
	return c && c.isAlive ? c : (ca[sid] = proxyManager.createClient(_));
}

function _closeDbgpClient(context, type, sid) {
	sid = ~~sid;
	var key = type + "_" + (sid || 0),
		clients = context.httpSession.dbgpClients || (context.httpSession.dbgpClients = {}),
		ca = clients[type] || (clients[type] = []),
		c = ca[sid];
	delete ca[sid];
	return c.close && c.close();
}

function _rawReply(context, statusCode, result, headers) {
	tracer && tracer("_rawReply =============\n" + (typeof(result) === "object" ? JSON.stringify(result) : result));
	context.response.writeHead(statusCode, headers);
	context.response.end(typeof(result) === "object" ? JSON.stringify(result) : result, "utf8");
}

function _makeAsyncOptions(context, timeout) {
	return {
		onTimeout: function(tracker) {
			_rawReply(context, 202, {
				$trackingId: tracker.id,
				$pollingMillis: 200
			}, {
				"content-type": "application/json"
			});
		},
		onComplete: function(tracker) {
			_rawReply(context, 200, tracker.result.toString(), {
				"content-type": "text/plain"
			});
		},
		onError: function(e, tracker) {
			tracer && tracer("ERROR " + e.message + " \n" + e.stack);
			_rawReply(context, 500, {
				$trackingId: tracker.id,
				$diagnoses: [{
					$severity: "error",
					$message: e.message
				}]
			}, {
				"content-type": "application/json"
			});
		},
		timeout: timeout
	};
}

function _parseSegment(segment) {
	var match = /^([^\/(]*)(\('([^']*)'\))?$/.exec(segment);
	return match ? {
		name: match[1],
		id: match[3]
	} : {
		name: segment
	};
}

function _dispatch(_, context, map) {
	var seg = context.walkUrl();
	if (seg == null) {
		// we reached the end of the URL, dispatch method
		//var method = context.request.method.toLowerCase();
		var method = context.method;
		if (map[method]) return map[method](_, context);
		else throw context.badMethod(method);
	} else {
		var pair = _parseSegment(seg);
		if (pair.name[0] === '$') {
			var name = pair.name.substring(1);
			if (map[name]) {
				return map[name](_, context, pair.id);
			}
		} else if (map.walk) {
			return map.walk(_, context, pair.name, pair.id);
		}
		throw context.badRequest(sdataLocalizedText("unexpectedSegment", seg));
	}
}

function _doIt(_, context) {
	var protocol = context.walkUrl();
	if (protocol !== "studio") {
		throw new Error("bad Url: protocol mismatch [" + protocol + "]");
	}
	_dispatch(_, context, _studioMap);
}

exports.dispatcher = function(config) {
	return function(_, request, response) {
		var context = new Context(request, response, config),
			_request = request._request,
			_response = response._response;

		request.context = context;
		try {
			_doIt(_, context);
		} catch (e) {
			console.error(e.stack);
			var headers = {
				"content-type": "application/json"
			};
			context.response.writeHead(500, headers);
			context.response.end(getErrorDiagnose(e));
		}
	};
};