"use strict";
var sys = require("util");
var fs = require("fs");
var fsp = require("path");
var crypto = require('crypto');
var net = require('net');
var uuid = require('syracuse-core/lib/uuid');
var jsxml = require("jsxml/lib/jsxml");

var cwd = process.cwd();

var tracer;
var tolerance;
var secret;

try {
	fs.mkdirSync(cwd + "/log");
} catch (e) {
	if (e.code != "EEXIST") throw new Error(e);
}
var log = logger(cwd + "/log/dbgpProxy.log");

function logger(fname) {
	var stream = fs.createWriteStream(fname, {
		flags: 'w+',
		encoding: null,
		mode: "0666"
	});
	return function(chunk, encoding) {
		var now = new Date();
		if (typeof(chunk) === "string") {
			stream.write(now.toISOString() + " " + chunk.replace(/\0/g, "[NULL]") + "\n");
		} else {
			stream.write(now.toISOString() + " " + chunk.toString(encoding || "utf8").replace(/\0/g, "[NULL]") + "\n");
		}
	};
}

function startServer(cb, opt) {
	var dbgpPort = opt && opt.port || 9514,
		x = 0;
	tracer = tracer || (opt && opt.trace);
	tolerance = opt.tolerance;
	secret = opt.key && opt.key.replace(/./g, function(c) {
		return String.fromCharCode(0x21 + ((x += c.charCodeAt(0)) & 0x3f));
	});

	net.createServer(dbgpListener).listen(dbgpPort);
	// Put a friendly message on the terminal of the server.
	console.log("Dbgp proxy server running at port " + dbgpPort + "\n");
}

function dbgpListener(socket) {
	var count = 0;
	// Identify this client
	socket.context = {
		uuid: uuid.generate(),
		name: socket.remoteAddress + ":" + socket.remotePort
	};
	socket.setEncoding('utf8');
	socket.on('data', function(data) {
		tracer && tracer("[>>>] receive data: (" + (++count) + ") context=" + JSON.stringify(socket.context) + "\n" + data);
		parseDbgpRequest(data, socket);
	});

	// Remove the client from the list when it leaves
	socket.on('end', function() {
		log("[PXY] END context=" + JSON.stringify(socket.context));
		cleanUpSocketContext(socket);
	});

	socket.on('error', function() {
		log("[PXY] ERROR context=" + JSON.stringify(socket.context));
		cleanUpSocketContext(socket);
	});
}

function cleanUpSocketContext(socket) {
	if ((socket.context || {}).type === "ide") {
		delete ideMap[(socket.context || {}).idekey];
	}
	if ((socket.context || {}).type === "debug") {
		delete sessionMap[(socket.context || {}).uuid];
	}
	socket.context = null;
}

// == proxy command
// proxyinit -k 7f542ecb-a09a-4117-9a65-50f275098534 -m 1[NULL]
// == Init message
// 404[NULL]<init idekey="b23efbcb-ddc3-4ffd-96fb-e29bdb94d261" fileuri="" session="com.sage.x3.xdt.dltk.debugger" thread="2330794" parent="/produits/v170/SOLSUPV7/runtime" appid="sodaix02:17001/SUPERV/erbou/107175946" language="X3" protocol_version="1.0"><engine version="17r.202"/><author>Sage</author><url><![CDATA[http://www.sage.com]]></url><copyright><![CDATA[Copyright (c) 2000-2014 Sage]]></copyright></init>[NULL]
// == Ide Command
// @b23efbcb-ddc3-4ffd-96fb-e29bdb94d261[NULL]feature_set -n max_children -i 0 -v 32[NULL]
// == Debugger message
// 92[NULL]<response command="feature_set" transaction_id="0" feature_name="max_children" success="1"/>[NULL]

function parseRequest(message, sender) {
	sender.context.parts = (sender.context.parts || []).concat(message.split("\0"));
}

function parseDbgpRequest(message, sender) {
	try {
		var m, sessionId, pos, len, type = sender.context.type;
		if (type === "debug") {
			tracer && tracer("[>>>] parseDbgRequest: sessionId=" + sender.context.uuid);
			return forwardDebuggerMessage(message, sender);
		} else if (type === "ide") {
			if (message[0] === '@') {
				pos = message.indexOf("\0");
				sessionId = message.substring(1, pos);
				message = message.substring(pos + 1);
				tracer && tracer("[>>>] parseIdeRequest: sessionId=" + sessionId);
			}
			log("[IDE] " + message);
			return processProxyMessage(message, sender) || forwardIdeCommand(message, sender, sessionId);
		} else { // Initialisation message
			if (message.charCodeAt(0) >= 48 && message.charCodeAt(0) <= 57) {
				log("[DBG] " + message);
				m = message.match(/^(\d+)\0(<init\b\s+[^\0]*)\0$/i);
				if (m) {
					return processDebuggerInitMessage(m, sender);
				}
			} else {
				log("[IDE] " + message);
				return processProxyMessage(message, sender) || forwardIdeCommand(message, sender, sessionId);
			}
		}
	} catch (e) {
		log("[EXCEPTION] " + e.message + "\n" + e.stack);
	}
}

function processProxyMessage(message, sender) {
	var m = message.match(/^\s*proxy(\w+)\b\s+(.*)$/i);
	return m && proxyCommand[m[1].toLowerCase()].process(parseProxyOptions(m[2]), sender);
}

function processDebuggerInitMessage(matches, sender) {
	var msg = safeParseXml(matches[2]) || {},
		idekey = ((msg.init || {}).$ || {})["idekey"],
		ide = ideMap[idekey];
	tracer && tracer("[>>>] initial debug message: idekey=" + idekey);
	if (ide && ide.socket) {
		sender.context.idekey = idekey;
		sender.context.type = "debug";
		sessionMap[sender.context.uuid] = sender;
		forwardDebuggerMessage(matches[0], sender);
	} else {
		sender.end();
	}
}

function safeParseXml(xml) {
	try {
		return jsxml.parse(xml);
	} catch (e) {
		return;
	}
}

function forwardDebuggerMessage(message, sender) {
	var ide = ideMap[sender.context.idekey];
	if (ide && ide.socket) {
		var data = "@" + sender.context.uuid + "\0" + message;
		log("[DBG] " + data);
		ide.socket.write(data);
	} else {
		sender.end();
	}
}

function forwardIdeCommand(message, sender, sessionId) {
	var ide = ideMap[sender.context.idekey],
		session = sessionMap[sessionId];
	if (ide && ide.socket) {
		session && session.write(message);
	} else {
		sender.end();
	}
}

function sendRecorded(sender) {
	var msg = '<init idekey="2105b642-eaaf-4177-8ffd-f51d549e4e5c" fileuri="" session="com.sage.x3.xdt.dltk.debugger" thread="2330794" parent="/produits/v170/SOLSUPV7/runtime" appid="sodaix02:17001/SUPERV/erbou/107175946" language="X3" protocol_version="1.0"><engine version="17r.202"/><author>Sage</author><url><![CDATA[http://www.sage.com]]></url><copyright><![CDATA[Copyright (c) 2000-2014 Sage]]></copyright></init>';
	msg = (msg || "").length + "\0" + msg + "\0";
	forwardDebuggerMessage(msg, sender);
}

var ideMap = {},
	sessionMap = {};

var proxyCommand = {
	"init": {
		process: function(options, sender) {
			// proxyinit -a ip:port -k ide_key -m [0|1]
			var token = parseToken(options["-k"]);
			if (token.diagnoses) {
				sendProxyResponse(sender, "init", token.diagnoses);
				sender.end();
			}
			var ide = ideMap[token.key];
			if (ide && sender.context && ide.token.key != sender.context.idekey) {
				sender.end();
			}
			ide = ideMap[token.key] = {
				token: token,
				socket: sender,
				sessions: []
			};
			sender.context.idekey = token.key;
			sender.context.type = "ide";
			sendProxyResponse(sender, "init");
			// sendRecorded(sender);
		}
	},
	"stop": {
		process: function(options, sender) {
			// proxystop -k ide_key
			var ide = ideMap[(sender.context || {}).idekey];
			log("[PXY] STOP ide=" + sys.inspect(ide) + ", sender.context=" + JSON.stringify(sender.context));
			if (ide && sender.context && ide.token.key === sender.context.idekey) {
				sendProxyResponse(sender, "stop");
			}
			sender.end();
		}
	}
};

function parseProxyOptions(optString) {
	var options = {},
		parts = optString.split(/\s+/);
	parts.slice().forEach(function(p, i) {
		if (p[0] === "-") {
			options[p] = parts[i + 1];
		}
	});
	return options;
}

function getToken(key, date, once) {
	var md5sum = crypto.createHash('md5'),
		now = new Date(),
		token = {
			"key": key,
			"date": date || now.toISOString(),
			"once": once || uuid.generate()
		},
		str = token.key + '/' + token.date + '/' + token.once + '/' + secret;
	md5sum.update(str, "ascii");
	token.signature = md5sum.digest("hex");
	return token;
}

function parseToken(b64token, err) {
	err = err || defaultError;
	var token = new Buffer(b64token, 'base64').toString('utf8');
	token = JSON.parse(token);
	var d = new Date(token.date);
	var now = new Date();
	if (!d) {
		return err(101, "Not authenticate");
	}
	if (Math.abs(d - now) > tolerance * 60 * 1000) {
		return err(101, "Token expired");
	}
	var computedToken = getToken(token.key, token.date, token.once);
	if (computedToken.signature !== token.signature) {
		return err(101, "Bad token");
	}

	return token;
}

/// see <http://xdebug.org/docs-dbgp.php#message-packets> for dbgp packet description

function sendResponse(socket, resp) {
	var data = "" + (resp || "").length + "\0" + resp + "\0";
	log("[PRX] " + data);
	socket.write(data);
}

function sendProxyResponse(socket, type, diagnosis) {
	var resp = '<proxy' + type + ' success="' + (diagnosis ? 0 : 1) + '" ';
	resp += 'idekey="' + (socket.context && socket.context.idekey) + '" ';
	resp += 'address="' + socket.remoteAddress + '" ';
	resp += 'port="' + socket.remotePort + '>';
	if (diagnosis) {
		resp += '<error code="' + diagnosis.error + '">';
		resp += diagnosis.message ? '<message>' + diagnosis.message + '</message> ' : "";
		resp += '</error>';
	}
	resp += '</proxy' + type + '>';
	sendResponse(socket, resp);
}

function error(cmd, tid, diagnosis) {
	var resp = '<response command="' + cmd + '" transaction_id="' + tid + '">';
	resp += '<error code="' + diagnosis.error + '">';
	resp += diagnosis.message ? '<message>' + diagnosis.message + '</message>' : "";
	resp += '</error>';
	resp += '</response > ';
	tracer && tracer("[>>>] error: " + resp);
}

function diagnosis(error, message) {
	return {
		error: error,
		message: message
	};
}

function defaultError(error, message) {
	return {
		diagnoses: [diagnosis(error, message)]
	};
}

exports.startServer = startServer;

// startServer(function(err, res) {
// 	if (err) return console.error(err);
// }, config);