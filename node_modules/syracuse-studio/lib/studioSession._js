"use strict";

/// !doc
/// 
/// # X3 Studio session
/// 
/// Manage the SAFE X3 Studio for Eclipse session
/// 
/// ``` javascript
/// var studio = require('./studioSession');
/// var session = studio.createStudioSession(_, context, data, id);
/// ```

var fsp = require("path");
var helpers = require('@sage/syracuse-core').helpers;
var datetime = require('@sage/syracuse-core').types.datetime;
var adminHelper = require("@sage/syracuse-lib/src/collaboration/helpers").AdminHelper;
var config = require('config');
var SadFsqClient = require('syracuse-x3/lib/clients/sadfsq/sadfsqClient').SadFsqClient;
var globals = require('streamline-runtime').globals;
var proxyManager = require('./dbgp/proxyManager');
var studioConfig = (config || {}).studio || {};
var tracer = require('@sage/syracuse-core').getTracer("studio.session");

/// ## Static functions
/// 
/// -------------
/// ### createStudioSession
/// ``` javascript
/// var session = studio.createStudioSession(_, context, data);
/// ```
/// Create a studio session or return a previously created session if has already be assign to the current httpSession.
/// 
/// * `context` the context of the current request.
/// * `data` the data send with the request.
/// 
exports.createStudioSession = function(_, context, data) {
	exports.touchStudioSessionInfo(_, context, data);
	exports.checkFeature(_, "edit");

	var httpSession = context.httpSession;
	var ses = _getStudioSession(httpSession) || new StudioSession(data);

	exports.setStudioSession(context, ses);
	var hits = ++ses.$hits;
	tracer.debug && tracer.debug("Created session $uuid=" + (ses && ses.$uuid));

	return {
		$uuid: data.$uuid,
		$hits: hits,
		$status: hits > 1 ? "alreadyRegistered" : "registered",
		$longPollingMillis: studioConfig.dbgp.longPollingMillis,
		$version: 2
	};
};

exports.touchStudioSessionInfo = function(_, context, data, opt) {
	opt = opt || {};
	_authorized();
	_initUserContext(_);

	if (!data || !data.$uuid || !data.$wsid || !data.$username || !data.$clientName || !data.$clientVersion) {
		tracer.error && tracer.error("touchStudioSessionInfo: Invalid data=" + JSON.stringify(data));
		throw context.forbidden("Invalid data");
	}

	var httpSession = context.httpSession,
		id = data.$uuid,
		instance = _getStudioSessionInfo(_, id);
	httpSession.touch();

	var requestInfo = (httpSession.getData("requestInfo") || {}),
		diagnoses = [],
		forceSave = false;

	if (!instance) {
		instance = _createStudioSessionInfo(_, id);
		instance.getAllDiagnoses(_, diagnoses);
	}
	if (opt.proxy) {
		var proxies = exports.canDebug(_) ? proxyManager.getProxyAddressesAsString() : "";
		if (instance.debugProxy(_) !== proxies) {
			tracer.debug && tracer.debug("touchStudioSessionInfo: change proxies from " + instance.debugProxy(_) + " to " + proxies);
			instance.debugProxy(_, proxies);
			forceSave = true;
		}
	}
	if (forceSave || instance.wsid(_) != data.$wsid || instance.sid(_) != httpSession.id || instance.studioVersion(_) != data.$clientVersion || instance.peerAddress(_) != requestInfo.peerAddress) {
		instance.login(_, httpSession.getUserLogin(_));
		instance.lastAccess(_, datetime.now());
		instance.sid(_, httpSession.id);
		instance.clientId(_, httpSession.clientId);
		instance.wsid(_, data.$wsid);
		instance.lastOperation(_, (context.request || {}).url);
		instance.studioName(_, data.$clientName);
		instance.studioVersion(_, data.$clientVersion);
		instance.peerAddress(_, requestInfo.peerAddress);
		instance.peerUser(_, data.$username);
		instance.save(_);
		instance.getAllDiagnoses(_, diagnoses);
	}
	var errors = diagnoses.filter(function(d) {
		return d.$severity === "error";
	});
	if (errors.length > 0) {
		tracer.error && tracer.error("Failed to update studio session info: " + JSON.stringify(errors));
	}
	return diagnoses;
};

function _globalSession() {
	var session = globals.context.session;
	if (session == null) {
		tracer.error && tracer.error("_globalSession: Bad session context");
		throw new Error("Bad session context");
	}
	return session;
}

function _initUserContext(_) {
	var studioContext = _globalSession().getData("studioContext");
	if (studioContext == null) {
		studioContext = {};
		var userProfile = _globalSession().getUserProfile(_);
		var user = userProfile.user(_);
		var devRole;

		user.getUserRolesList(_).some_(_, function(_, role) {
			var canEdit, canDebug;
			canEdit = role.securityProfile(_).canCreateClass(_, "studioSessionInfo", true);
			canDebug = role.securityProfile(_).canExecuteService(_, "studioSessionInfo", true);
			if (canEdit) {
				devRole = role;
				studioContext.canEdit = canEdit;
				studioContext.canDebug = canDebug;
				if (canDebug) {
					return true;
				}
			}
		});
		if (devRole && userProfile.selectedRole(_).code(_) !== devRole.code(_)) {
			tracer.debug && tracer.debug("touchStudioSessionInfo: Auto select best development role '" + devRole.code(_) + "'");
			userProfile.selectedRole(_, devRole);
		}
		_globalSession().setData("studioContext", studioContext);
	}
}

function _getStudioUserContext() {
	return _globalSession().getData("studioContext") || {};
}

function feature(op) {
	return {
		isAllowed: function(_) {
			return _globalSession().getSecurityProfile(_)[op](_, "studioSessionInfo");
		}
	};
}

var _features = {
	"edit": feature("canCreateClass"),
	"debug": feature("canExecuteService")
};

exports.canEdit = function(_) {
	return _features["edit"].isAllowed(_);
};

exports.canDebug = function(_) {
	return _features["debug"].isAllowed(_);
};

exports.checkFeature = function(_, f) {
	if (!_features[f] || !_features[f].isAllowed(_)) {
		throw exports.notAuthorized();
	}
};

exports.notAuthorized = function() {
	return new Error("Not authorized");
};

exports.setStudioSession = function(context, ses) {
	_authorized();
	_globalSession().setData("studioSession", ses);
};

function _getStudioSession(httpSession) {
	return (httpSession || _globalSession()).getData("studioSession");
}

function _createStudioSessionInfo(_, id) {
	var db = adminHelper.getCollaborationOrm(_);
	var e = db.getEntity(_, "studioSessionInfo"),
		instance = e.createInstance(_, db);
	instance.studioId(_, id);
	return instance;
}

function _getStudioSessionInfo(_, id) {
	var db = adminHelper.getCollaborationOrm(_);
	var e = db.getEntity(_, "studioSessionInfo");
	return db.fetchInstance(_, e, {
		jsonWhere: {
			studioId: id
		}
	});
}

exports.getStudioSessionInfo = _getStudioSessionInfo;

// context parameter is required when called from a timeout
exports.getStudioSession = function(context) {
	context = context || {};
	_authorized(context);
	var httpSession = context.httpSession || _globalSession();
	httpSession.touch();
	return _getStudioSession(httpSession);
};

var minver = (2 << 16) + (0 << 8) + 1;

function _authorized(context) {
	if (studioConfig.disabled) {
		throw exports.notAuthorized();
	}
	context = context || {};
	var request = context.request || globals.context.request,
		httpSession = context.httpSession || _globalSession();
	if (!request)
		throw new Error("No request");
	if (!httpSession)
		throw new Error("No session");
	var studioSession = _getStudioSession(httpSession);
	if (studioSession) {
		var ver = studioSession.$clientVersion && studioSession.$clientVersion.split(/\./);
		ver = (~~ver[0] << 16) + (~~ver[1] << 8) + ~~ver[2];
		if (ver < minver) {
			throw new Error("Version unauthorized");
		}
	}
}
exports.authorized = _authorized;

function precond(ses) {
	_authorized();
	var studioSession = _getStudioSession();
	if (studioSession.$uuid !== ses.$uuid)
		throw new Error("Studio session mismatch: expected " + studioSession.$uuid + ", got " + ses.$uuid);

	ses.$tick = Date.now();
}

var _propertyNames = ["$uuid", "$username", "$clientName", "$clientVersion", "$platform", "$platformVersion", "$javaVersion", "$javaVM"];

function StudioSession(data) {
	var self = this;
	_propertyNames.forEach(function(k) {
		self[k] = data[k];
	});
	this.$hits = 0;
	this.$tick = Date.now();
	this.sadfs = {};
}

/// ## Instance functions
/// 
exports.StudioSession = helpers.defineClass(StudioSession, null, {

	/// -------------
	/// ### getEngineVersion
	/// ``` javascript
	/// var ver = studioSession.getEngineVersion(_, endpoint);
	/// ```
	/// Return the engine version of the current context
	/// 
	/// * `endpoint` the endpoint on which the method applies.
	/// 
	getEngineVersion: function(_, endpoint) {
		precond(this);
		var sadfs = this._ensureSadfs(_, endpoint),
			folder = endpoint.x3ServerFolder(_);

		if (!folder)
			throw new Error("Endpoint not a valid");

		// adonix -v NOM_DE_DOSSIER
		// returns a string like "Version 17r.218 24/09/2014"
		var ver = sadfs.exec(_, "adonix -v " + folder);
		tracer.debug && tracer.debug("Operation.getEngineVersion: result=" + ver);
		return {
			$result: ver
		};
	},

	/// -------------
	/// ### update
	/// ``` javascript
	/// studioSession.update(_, endpoint, data);
	/// ```
	/// Return a true if succesful or false otherwise.
	/// 
	/// * `endpoint` the endpoint on which the method applies.
	/// * `data` the data sent with the request.
	/// A typical data content is:
	/// ``` json
	/// { "folder": "SUPERV", "filename": "AXDTMAIN", "content": "...", $sign="..." }
	/// ```
	/// 
	update: function(_, endpoint, data) {
		// used by X3UpdateManager
		// data.folder, data.filename, data.content;
		precond(this);
		var sadfs = this._ensureSadfs(_, endpoint),
			folder = endpoint.x3ServerFolder(_);

		// First send file in "TRT" dir using "src" extention
		var filedesc = {
			folder: data.folder || folder,
			path: "TRT",
			name: data.filename,
			extension: "src"
		};
		sadfs.writeFile(_, filedesc, data.content, {
			flag: "w"
		});
		// Then compile file
		var res = _compile(_, sadfs, filedesc.folder, filedesc.name);
		tracer.debug && tracer.debug("Operation.update: result=" + JSON.stringify(res));
		return res;
	},

	/// -------------
	/// ### getFileStamp
	/// ``` javascript
	/// studioSession.getFileStamp(_, endpoint, data);
	/// ```
	/// Return the file stamp
	/// 
	/// * `endpoint` the endpoint on which the method applies.
	/// * `data` the data sent with the request.
	/// A typical data content is:
	/// ``` json
	/// { "path": "xxx/yyy" }
	/// ```
	/// 
	getFileStamp: function(_, endpoint, data) {
		// used by X3UpdateManager
		precond(this);
		var sadfs = this._ensureSadfs(_, endpoint),
			folder = data.folder || endpoint.x3ServerFolder(_);

		var filedesc = _getFileDesc(data.path, folder),
			stamp = "",
			stats;
		if (sadfs.exists(_, filedesc)) {
			stats = sadfs.stat(_, filedesc, ["mtime"]);
			stamp = "" + Date.parse(stats.mtime);
		}
		tracer.debug && tracer.debug("Operation.getFileStamp: result=" + stamp);
		return {
			$result: stamp
		};
	},

	/// -------------
	/// ### getFileSize
	/// ``` javascript
	/// studioSession.getFileSize(_, endpoint, data);
	/// ```
	/// Return the file stamp
	/// 
	/// * `endpoint` the endpoint on which the method applies.
	/// * `data` the data sent with the request.
	/// A typical data content is:
	/// ``` json
	/// { "path": "xxx/yyy" }
	/// ```
	/// 
	getFileSize: function(_, endpoint, data) {
		// used by X3UpdateManager
		precond(this);
		var sadfs = this._ensureSadfs(_, endpoint),
			folder = data.folder || endpoint.x3ServerFolder(_);

		var filedesc = _getFileDesc(data.path, folder),
			size = -1,
			stats;
		if (sadfs.exists(_, filedesc)) {
			stats = sadfs.stat(_, filedesc, ["size"]);
			size = stats.size;
		}
		tracer.debug && tracer.debug("Operation.getFileSize: result=" + size);
		return {
			$result: size
		};
	},

	/// -------------
	/// ### fileExist
	/// ``` javascript
	/// studioSession.fileExist(_, endpoint, data);
	/// ```
	/// Return if the file exists
	/// 
	/// * `endpoint` the endpoint on which the method applies.
	/// * `data` the data sent with the request.
	/// A typical data content is:
	/// ``` json
	/// { "path": "xxx/yyy", folder:"SUPERV" }
	/// ```
	/// 
	fileExist: function(_, endpoint, data) {
		// used by X3UpdateManager
		// replace also isFileOnServer used by XdtResourceHelper
		precond(this);
		var sadfs = this._ensureSadfs(_, endpoint),
			folder = data.folder || endpoint.x3ServerFolder(_);

		var filedesc = _getFileDesc(data.path, folder),
			result = sadfs.exists(_, filedesc);
		tracer.debug && tracer.debug("Operation.fileExist: result=" + result);
		return {
			$result: result
		};
	},

	_getFileInfo: function(_, endpoint, data, info, transform) {
		// used by X3UpdateManager
		precond(this);
		var sadfs = this._ensureSadfs(_, endpoint),
			folder = data.folder || endpoint.x3ServerFolder(_);

		var filedesc = _getFileDesc(data.path, folder),
			ret,
			stats;
		if (sadfs.exists(_, filedesc)) {
			stats = sadfs.stat(_, filedesc, [info]);
			ret = stats[info];
		}
		return {
			$result: transform && transform(info)
		};
	},

	/// -------------
	/// ### deleteFile
	/// ``` javascript
	/// studioSession.deleteFile(_, endpoint, data);
	/// ```
	/// 
	/// * `endpoint` the endpoint on which the method applies.
	/// * `data` the data sent with the request.
	/// A typical data content is:
	/// ``` json
	/// { "path": "dir/file.ext" }
	/// ```
	/// 
	deleteFile: function(_, endpoint, data) {
		// only used by X3UpdateManager for time marker
		// It would be better to specialize this function to only manage this time marker
		precond(this);
		var sadfs = this._ensureSadfs(_, endpoint),
			folder = data.folder || endpoint.x3ServerFolder(_);
		var dir = fsp.dirname(data.path);

		tracer.debug && tracer.debug("Operation.deleteFile: path=" + data.path + ", dir=" + dir);
		// Only allow deletion of files into the tmp folder
		if (["tmp", "TRT"].indexOf(dir) === -1)
			throw new Error("Not supported");

		var filedesc = _getFileDesc(data.path, folder);
		sadfs.unlink(_, filedesc);
		tracer.debug && tracer.debug("Operation.deleteFile: result=true");
		return {
			$result: true
		};
	},

	/// -------------
	/// ### writeFile
	/// ``` javascript
	/// studioSession.writeFile(_, endpoint, data);
	/// ```
	/// 
	/// * `endpoint` the endpoint on which the method applies.
	/// * `data` the data sent with the request.
	/// A typical data content is:
	/// ``` json
	/// { "path": "dir/file.ext" , "content": "hello world..."}
	/// ```
	/// 
	writeFile: function(_, endpoint, data) {
		// Only used by X3UpdateManager for time marker
		// It would be better to specialize this function to only manage this time marker
		precond(this);
		var sadfs = this._ensureSadfs(_, endpoint),
			folder = data.folder || endpoint.x3ServerFolder(_);
		var dir = fsp.dirname(data.path);

		tracer.debug && tracer.debug("Operation.writeFile: path=" + data.path + ", dir=" + dir);
		// Only allow deletion of files into the tmp folder
		if (["tmp", "TRT"].indexOf(dir) === -1)
			throw new Error("Not supported");

		var filedesc = _getFileDesc(data.path, folder);
		sadfs.writeFile(_, filedesc, data.content, {
			flag: "w"
		});

		return {
			$result: ""
		};
	},

	/// -------------
	/// ### getFileList
	/// ``` javascript
	/// studioSession.getFileList(_, endpoint, data);
	/// ```
	/// 
	/// * `endpoint` the endpoint on which the method applies.
	/// * `data` the data sent with the request.
	/// A typical data content is:
	/// ``` json
	/// { "folder": "SUPERV" , "directory": "TRT", "extension": "src"}
	/// ```
	/// 
	getFileList: function(_, endpoint, data) {
		// Used by X3FileManager
		precond(this);
		var sadfs = this._ensureSadfs(_, endpoint),
			folder = data.folder || endpoint.x3ServerFolder(_),
			options = data.options || "",
			cmd = ["lsadx", "-a", folder, options, data.directory, data.extension].join(" ");

		tracer.debug && tracer.debug("Operation.getFileList: cmd=" + cmd);
		var output = sadfs.exec(_, cmd);
		tracer.debug && tracer.debug("Operation.getFileList: output=" + output);
		return {
			$result: output && output.split("\n")
		};
	},

	// sadfsqGetFileContent(String x3Folder, String fileDir, String fileName, String fileExt) ==> String
	/// -------------
	/// ### readFile
	/// ``` javascript
	/// studioSession.readFile(_, endpoint, data);
	/// ```
	/// 
	/// * `endpoint` the endpoint on which the method applies.
	/// * `data` the data sent with the request.
	/// A typical data content is:
	/// ``` json
	/// { "folder": "SUPERV" , "directory": "TRT", "filename": "ZEBHELLO", "extension": "src" }
	/// ```
	/// 
	readFile: function(_, endpoint, data) {
		// Used by X3DebugTraceView.setTraceContent
		precond(this);
		var sadfs = this._ensureSadfs(_, endpoint),
			folder = data.folder || endpoint.x3ServerFolder(_),
			encoding = data.encoding || "utf8",
			filedesc = data.path && _getFileDesc(data.path, folder) || {
				folder: folder,
				path: data.directory,
				name: data.filename,
				extension: data.extension
			};
		tracer.debug && tracer.debug("Operation.readFile");
		return {
			$result: sadfs.readFile(_, filedesc, {
				flag: "r",
				encoding: encoding
			})
		};
	},

	_ensureSadfs: function(_, endpoint) {
		var x3server, dataset = endpoint.dataset(_),
			sadfs = this.sadfs[dataset];
		if (!sadfs) {
			sadfs = this.sadfs[dataset] = new SadFsqClient(_, endpoint, null, null, false);
		}
		return sadfs;
	}

});

function _compile(_, sadfs, folder, filename) {
	var filedesc = {
		folder: folder,
		path: "tmp",
		name: filename,
		extension: "out"
	};
	var outpath = sadfs.path(_, filedesc),
		cmd = ["valtrt", "-l", "ENG", folder, filename, ">", outpath, "2>&1"].join(" ");
	tracer.debug && tracer.debug("SubOperation.compile: cmd='" + cmd + "'");
	sadfs.exec(_, cmd);
	var output = sadfs.readFile(_, filedesc, {
		encoding: "ascii"
	});
	tracer.debug && tracer.debug("SubOperation.compile: output=" + output);
	sadfs.unlink(_, filedesc);

	// Errors are formatted like:
	// Erreur no 5
	// ( Ligne 2, Colonne 7 )
	// Erreur de syntaxe : Caractère illégal
	// "Error No 5\n(Line 2, Column 10)\nSyntax Error : Illegal Character\n"
	var message = "success";
	var lines = output.split("\n").map(function(l) {
		return l.replace(/\s+$/g, "");
	});
	var diagnoses;
	if (lines[1] || lines[2]) {
		// var m = /[^0-9]*([0-9]+)[^0-9]*,[^0-9]*([0-9]+)[^0-9]/.exec(lines[1]);
		// if (m || lines[2]) {
		message = lines[0];
		message += " ";
		message = lines[1] || "";
		message += " - ";
		message += lines[2] || "";
		diagnoses = [{
			$severity: "error",
			$message: message
		}];
		// }
	}

	return {
		$result: diagnoses == null,
		$diagnoses: diagnoses
	};
}

function _getFileDesc(path, folder) {
	var ext = fsp.extname(path),
		desc = {
			folder: folder,
			path: fsp.dirname(path),
			name: fsp.basename(path, ext),
			extension: ext.substring(1)
		};
	tracer.debug && tracer.debug("SubOperation.getFileDesc: " + JSON.stringify(desc));
	return desc;
}