// s2.2.7.5/6/7

'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.doneParser = doneParser;
exports.doneInProcParser = doneInProcParser;
exports.doneProcParser = doneProcParser;
var marked0$0 = [parseToken, doneParser, doneInProcParser, doneProcParser].map(_regeneratorRuntime.mark);
var STATUS = {
  MORE: 0x0001,
  ERROR: 0x0002,
  // This bit is not yet in use by SQL Server, so is not exposed in the returned token
  INXACT: 0x0004,
  COUNT: 0x0010,
  ATTN: 0x0020,
  SRVERROR: 0x0100
};

function parseToken(parser, options) {
  var status, more, sqlError, rowCountValid, attention, serverError, curCmd, rowCount;
  return _regeneratorRuntime.wrap(function parseToken$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return parser.readUInt16LE();

      case 2:
        status = context$1$0.sent;
        more = !!(status & STATUS.MORE);
        sqlError = !!(status & STATUS.ERROR);
        rowCountValid = !!(status & STATUS.COUNT);
        attention = !!(status & STATUS.ATTN);
        serverError = !!(status & STATUS.SRVERROR);
        context$1$0.next = 10;
        return parser.readUInt16LE();

      case 10:
        curCmd = context$1$0.sent;
        rowCount = undefined;

        if (!(options.tdsVersion < "7_2")) {
          context$1$0.next = 18;
          break;
        }

        context$1$0.next = 15;
        return parser.readUInt32LE();

      case 15:
        rowCount = context$1$0.sent;
        context$1$0.next = 21;
        break;

      case 18:
        context$1$0.next = 20;
        return parser.readUInt64LE();

      case 20:
        rowCount = context$1$0.sent;

      case 21:
        return context$1$0.abrupt('return', {
          name: 'DONE',
          event: 'done',
          more: more,
          sqlError: sqlError,
          attention: attention,
          serverError: serverError,
          rowCount: rowCountValid ? rowCount : undefined,
          curCmd: curCmd
        });

      case 22:
      case 'end':
        return context$1$0.stop();
    }
  }, marked0$0[0], this);
}

function doneParser(parser, colMetadata, options) {
  var token;
  return _regeneratorRuntime.wrap(function doneParser$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        return context$1$0.delegateYield(parseToken(parser, options), 't0', 1);

      case 1:
        token = context$1$0.t0;

        token.name = 'DONE';
        token.event = 'done';
        return context$1$0.abrupt('return', token);

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, marked0$0[1], this);
}

function doneInProcParser(parser, colMetadata, options) {
  var token;
  return _regeneratorRuntime.wrap(function doneInProcParser$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        return context$1$0.delegateYield(parseToken(parser, options), 't0', 1);

      case 1:
        token = context$1$0.t0;

        token.name = 'DONEINPROC';
        token.event = 'doneInProc';
        return context$1$0.abrupt('return', token);

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, marked0$0[2], this);
}

function doneProcParser(parser, colMetadata, options) {
  var token;
  return _regeneratorRuntime.wrap(function doneProcParser$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        return context$1$0.delegateYield(parseToken(parser, options), 't0', 1);

      case 1:
        token = context$1$0.t0;

        token.name = 'DONEPROC';
        token.event = 'doneProc';
        return context$1$0.abrupt('return', token);

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, marked0$0[3], this);
}

// If rowCount > 53 bits then rowCount will be incorrect (because Javascript uses IEEE_754 for number representation).