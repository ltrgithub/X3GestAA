"use strict";
/* jshint -W079 */
/* jshint unused: false */
/* global QUnit: false, asyncTest: false, test: false, strictEqual: false, ok: false, start: false, stop: false */

var helpers = require('syracuse-core/lib/helpers');
var streams = require("streamline/lib/streams/streams");
var sys = require("util");

var elasticIndex = require("syracuse-search/lib/elasticIndex");

var elasticBaseUrl = "http://localhost:9200";
var indexName = "unittest";
var entityName = "test1";

var tracer; // = console.log;

function _makeQuery(q) {
	return {
		query: {
			filtered: {
				query: {
					query_string: {
						query: q + "*",
						analyze_wildcard: true,
						default_operator: "AND"
					}
				}
			}
		}
	};
}
var useStdSettings = true;

function _makeSettings(std, idxLoc) {
	return std ? elasticIndex.getIndexSettings(idxLoc) : {
		"settings": {
			"index": {
				"analysis": {
					"filter": {
						"my_stemmer": {
							"type": "stemmer",
							"name": "french"
						},
						"my_stop": {
							"type": "stop",
							"stopwords": "_french_"
						},
						"delimiter": {
							"type": "word_delimiter",
							"type_table": ["@ => ALPHANUM", ". => ALPHANUM"]
						}
					},
					"analyzer": {
						"default": {
							"type": "custom",
							//							"tokenizer": "uax_url_email",
							"tokenizer": "whitespace",
							"filter": ["delimiter", "asciifolding", "lowercase", "elision", "my_stemmer", "my_stop"]
						},
						"search": {
							"type": "custom",
							//							"tokenizer": "uax_url_email",
							"tokenizer": "whitespace",
							"filter": ["delimiter", "asciifolding", "lowercase", "elision", "my_stemmer", "my_stop"]
						}
					}
				}
			}
		}
	};
}

function _elasticPost(_, segment, data, status) {
	var options = {
		url: [elasticBaseUrl, indexName, entityName, segment].join("/"),
		method: "POST"
	};
	var req = streams.httpRequest(options);
	req.write(_, JSON.stringify(data));
	var resp = req.end().response(_);
	strictEqual(resp.statusCode, status, "POST Status Ok");
	return JSON.parse(resp.readAll(_));
}

function _analyze(_, analyzer, q) {
	var options = {
		url: [elasticBaseUrl, indexName, "_analyze"].join("/") + "?analyzer=" + analyzer + "&text=" + q + "&pretty=true",
		method: "GET"
	};
	var req = streams.httpRequest(options);
	var resp = req.end().response(_);
	return JSON.parse(resp.readAll(_));
}
//


var doStop = false;
QUnit.module(module.id, {
	setup: function() {},
	teardown: function() {
		if (doStop) {
			setTimeout(function() {
				process.kill(process.pid);
			}, 100);
		}
	}
});


asyncTest("index french tests", 21, function(_) {
	// test index exists
	var par = {
		url: elasticBaseUrl + "/" + indexName,
		method: 'HEAD'
	};
	var resp = streams.httpRequest(par).end().response(_);
	tracer && tracer("Index exists status (35):" + resp.statusCode);
	var reqUrl;
	if (resp.statusCode !== 404) {
		// delete index
		reqUrl = elasticBaseUrl + "/" + indexName;
		par = {
			url: reqUrl,
			method: 'DELETE'
		};
		resp = streams.httpRequest(par).end().response(_);
		var r = resp.readAll(_);
	}
	// create index
	reqUrl = elasticBaseUrl + "/" + indexName;
	par = {
		url: reqUrl,
		method: 'PUT'
	};
	var data = _makeSettings(useStdSettings, "fr-fr");
	var req = streams.httpRequest(par);
	req.write(_, JSON.stringify(data));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index create status Ok");
	var respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index create response (53):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index create result ok");
	// create a mapping
	var mapping = {};
	mapping[entityName] = {
		properties: {}
	};
	var options = {
		url: elasticBaseUrl + "/" + indexName + "/" + entityName + "/_mapping",
		method: 'PUT'
	};
	req = streams.httpRequest(options);
	req.write(_, JSON.stringify(mapping));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index mapping update status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index mapping response (81):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index mapping update ok");
	// index some data
	var id1 = helpers.uuid.generate();
	var reqOptions = {
		url: [elasticBaseUrl, indexName, entityName, id1].join("/"),
		method: 'PUT'
	};
	req = streams.httpRequest(reqOptions);
	data = {
		stringInEnglish: "here's some english phrase to index",
		stringInFrench: "voilà une proposition à indexer en français"
	};
	req.write(_, JSON.stringify(data));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 201, "Index data status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index data response (98):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index data result ok");

	// analyzer tests
	respJSON = _analyze(_, "default", "english phrase*");
	tracer && tracer("Analyze search (170):" + sys.inspect(respJSON));
	strictEqual(respJSON.tokens[1].token, "phras", "Phrase = phras ok");
	respJSON = _analyze(_, "default", "voilà*");
	tracer && tracer("Analyze search (173):" + sys.inspect(respJSON));
	var respJSONfr = _analyze(_, "french", "voilà*");
	tracer && tracer("Analyze search (175):" + sys.inspect(respJSONfr));
	strictEqual(respJSON.tokens[0].token, respJSONfr.tokens[0].token, "Voilà analyzed ok");
	var respJSONfr = _analyze(_, "french", "voilà une proposition à indexer en français");
	tracer && tracer("Analyze phrase french (178):" + sys.inspect(respJSONfr));
	respJSON = _analyze(_, "default", "voila francais voilà français");
	tracer && tracer("Analyze search (179):" + sys.inspect(respJSON));
	var respJSONfr = _analyze(_, "french", "voila francais voilà français");
	tracer && tracer("Analyze phrase french (181):" + sys.inspect(respJSONfr));
	var respJSON = _analyze(_, "default", "cristi.nitescu@sage.com");
	tracer && tracer("Analyze email (184):" + sys.inspect(respJSON));
	strictEqual(respJSON.tokens[0].token, "cristi.nitescu@sage.com", "Email analyzed ok");
	// partial email
	var respJSON = _analyze(_, "default", "cristi.nitescu@sage");
	tracer && tracer("Analyze email (184):" + sys.inspect(respJSON));
	strictEqual(respJSON.tokens[0].token, "cristi.nitescu@sag", "Partial email analyzed ok");
	// elision
	var respJSON = _analyze(_, "default", "l'avion");
	tracer && tracer("Analyze elision (188):" + sys.inspect(respJSON));
	strictEqual(respJSON.tokens[0].token, "avion", "Elision analyzed ok");

	// search tests
	options = {
		url: [elasticBaseUrl, indexName, "_refresh"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	resp = req.end().response(_).readAll(_);
	// search something not to be found default analyzer
	options = {
		url: [elasticBaseUrl, indexName, entityName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	var search = _makeQuery("not_existing_query");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (122):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 0, "No result ok");
	// search something in english default analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = _makeQuery("english phrase");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (145):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "English: One result ok");
	// search something in french, french analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = _makeQuery("voilà");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (170):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "French 1: One result ok");
	// search something in french, french analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = _makeQuery("voila francais voilà français");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (192):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "French 2 (all terms): One result ok");
	// search single term no accent in french, french analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = _makeQuery("voila");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (192):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "French 2 (no accent): One result ok");
	//
	start();
});

asyncTest("email field tests", 15, function(_) {
	var search;
	// test index exists
	var par = {
		url: elasticBaseUrl + "/" + indexName,
		method: 'HEAD'
	};
	var resp = streams.httpRequest(par).end().response(_);
	tracer && tracer("Index exists status (243):" + resp.statusCode);
	var reqUrl;
	if (resp.statusCode !== 404) {
		// delete index
		reqUrl = elasticBaseUrl + "/" + indexName;
		par = {
			url: reqUrl,
			method: 'DELETE'
		};
		resp = streams.httpRequest(par).end().response(_);
		var r = resp.readAll(_);
	}
	// create index
	reqUrl = elasticBaseUrl + "/" + indexName;
	par = {
		url: reqUrl,
		method: 'PUT'
	};
	var data = _makeSettings(useStdSettings, "fr-fr");
	var req = streams.httpRequest(par);
	req.write(_, JSON.stringify(data));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index create status Ok");
	var respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index create response (279):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index create result ok");
	// create a mapping
	var entityName = "test1";
	var mapping = {};
	mapping[entityName] = {
		properties: {
			/*			my_email: {
				type: "string",
				analyzer: "keyword"
			}*/
		}
	};
	var options = {
		url: elasticBaseUrl + "/" + indexName + "/" + entityName + "/_mapping",
		method: 'PUT'
	};
	req = streams.httpRequest(options);
	req.write(_, JSON.stringify(mapping));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index mapping update status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index mapping response (81):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index mapping update ok");
	// index some data
	var id1 = helpers.uuid.generate();
	var reqOptions = {
		url: [elasticBaseUrl, indexName, entityName, id1].join("/"),
		method: 'PUT'
	};
	req = streams.httpRequest(reqOptions);
	data = {
		my_email: "cristi.nitescu@sage.com"
	};
	req.write(_, JSON.stringify(data));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 201, "Index data status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index data response (98):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index data result ok");
	// !!! LET INDEXING DO BEFORE SEARCH
	options = {
		url: [elasticBaseUrl, indexName, "_refresh"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	resp = req.end().response(_).readAll(_);
	// Simple search
	respJSON = _elasticPost(_, "_search", _makeQuery("cristi"), 200);
	tracer && tracer("Search response (339):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "Simple search ok");
	// This query shouldn't have any result
	respJSON = _elasticPost(_, "_search", _makeQuery("cristi.fake@sage.com"), 200);
	tracer && tracer("Search response (339):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 0, "No result ok");
	// explain
	respJSON = _elasticPost(_, id1 + "/_explain", _makeQuery("cristi.fake@sage.com"), 200);
	tracer && tracer("Explain response (315):" + sys.inspect(respJSON, null, 6));
	// This query should have a result
	respJSON = _elasticPost(_, "_search", _makeQuery("cristi.*@sage.com"), 200);
	tracer && tracer("Search response (359):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "Found email with wildcard ok");
	// exact search
	respJSON = _elasticPost(_, "_search", _makeQuery("cristi.nitescu@sage.com"), 200);
	tracer && tracer("Search response (352):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "Found email with exact search ok");

	start();
});

asyncTest("stop  tests", 0, function(_) {
	doStop = true;
	start();
});