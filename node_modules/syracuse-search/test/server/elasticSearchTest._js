"use strict"

var module = QUnit.module;
var helpers = require('syracuse-core/lib/helpers');
var streams = require("streamline/lib/streams/streams");
var sys = require("util");

var elasticBaseUrl = "http://localhost:9200";
var indexName = "unittest";

var tracer = console.log;
//var tracer = null;

//
var doStop = false;
module("elasticSearchTest", {
	setup: function() {},
	teardown: function() {
		if (doStop) {
			//syracuse.server.close();
			setTimeout(function() {
				process.kill(process.pid);
			}, 100)
		}
	}
});

asyncTest("index french tests", 16, function(_) {
	// test index exists
	var par = {
			url: elasticBaseUrl + "/" + indexName,
			method: 'HEAD'
		};
	var resp = streams.httpRequest(par).end().response(_);
	tracer&& tracer("Index exists status (35):" + resp.statusCode);
	if(resp.statusCode != 404) {
		// delete index
		var reqUrl = elasticBaseUrl + "/" + indexName;
		var par = {
				url: reqUrl,
				method: 'DELETE'
			};
		var resp = streams.httpRequest(par).end().response(_);
		var r = resp.readAll(_);
	}
	// create index
	var reqUrl = elasticBaseUrl + "/" + indexName;
	var par = {
			url: reqUrl,
			method: 'PUT'
		};
	var data = {
		"settings": {
			"index": {
				"analysis": {
					"analyzer": {
						"default": {
							type: "french"
						}
					}
				}
			}
		}
	}
	var req = streams.httpRequest(par);
	req.write(_, JSON.stringify(data));
	var resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index create status Ok");
	var respJSON = JSON.parse(resp.readAll(_));
	tracer&& tracer("Index create response (53):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index create result ok");
	// create a mapping
	var entityName = "test1";
	var mapping = {};
	mapping[entityName] = {
		properties: {}
	};
/*	var pm = mapping[entityName].properties;
	pm.stringInEnglish = {
			type: "string",
			analyzer: "english"
		};
	pm.stringInFrench = {
			type: "string",
			analyzer: "french"
		};*/
	var options = {
		url: elasticBaseUrl + "/" + indexName + "/" + entityName + "/_mapping",
		method: 'PUT'
	};
	var req = streams.httpRequest(options);
	req.write(_, JSON.stringify(mapping));
	var resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index mapping update status Ok");
	var respJSON = JSON.parse(resp.readAll(_));
	tracer&& tracer("Index mapping response (81):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index mapping update ok");
	// index some data
	var id1 = helpers.uuid.generate();
	var reqOptions = {
		url: [elasticBaseUrl, indexName, entityName, id1].join("/"),
		method: 'PUT'
	};
	var req = streams.httpRequest(reqOptions);
	var data = {
		stringInEnglish: "here's some english phrase to index",
		stringInFrench: "voilà une proposition à indexer en français"
	};
	req.write(_, JSON.stringify(data));
	var resp = req.end().response(_);
	strictEqual(resp.statusCode, 201, "Index data status Ok");
	var respJSON = JSON.parse(resp.readAll(_));
	tracer&& tracer("Index data response (98):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index data result ok");
	// !!! LET INDEXING DO BEFORE SEARCH
    var options = {
    		url: [elasticBaseUrl, indexName, "_refresh"].join("/"),
    		method: "POST"
    	};
    var req = streams.httpRequest(options);
	var resp = req.end().response(_).readAll(_);
	// search something not to be found default analyzer
    var options = {
		url: [elasticBaseUrl, indexName, entityName, "_search"].join("/"),
		method: "POST"
	};
   	var req = streams.httpRequest(options);
   	var search = {
   		query: {
   			filtered: {
   				query: {
   					query_string: {
   						query: "not_existing_query"
    				}
				}
			}
		}
	};
	req.write(_, JSON.stringify(search));
	var resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	var respJSON = JSON.parse(resp.readAll(_));
	tracer&& tracer("Search response (122):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 0, "No result ok");
	// search something in english default analyzer
    var options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
   	var req = streams.httpRequest(options);
   	var search = {
   		query: {
   			filtered: {
   				query: {
   					query_string: {
   						query: "english phrase"
    				}
				}
			}
		}
	};
	req.write(_, JSON.stringify(search));
	var resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	var respJSON = JSON.parse(resp.readAll(_));
	tracer&& tracer("Search response (145):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "English: One result ok");
	// search something in french, french analyzer
    var options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
   	var req = streams.httpRequest(options);
   	var search = {
   		query: {
   			filtered: {
   				query: {
   					query_string: {
   						query: "voilà"
    				}
				}
			}
		}
	};
	req.write(_, JSON.stringify(search));
	var resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	var respJSON = JSON.parse(resp.readAll(_));
	tracer&& tracer("Search response (170):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "French 1: One result ok");
	// search something in french, french analyzer
    var options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
   	var req = streams.httpRequest(options);
   	var search = {
   		query: {
   			filtered: {
   				query: {
   					query_string: {
   						query: "voila francais voilà français",
   						analyze_wildcard: true,
   						default_operator: "AND"
    				}
				}
			}
		}
	};
	req.write(_, JSON.stringify(search));
	var resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	var respJSON = JSON.parse(resp.readAll(_));
	tracer&& tracer("Search response (192):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "French 2 (all terms): One result ok");
	// search single term no accent in french, french analyzer
    var options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
   	var req = streams.httpRequest(options);
   	var search = {
   		query: {
   			filtered: {
   				query: {
   					query_string: {
   						query: "voila"
    				}
				}
			}
		}
	};
	req.write(_, JSON.stringify(search));
	var resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	var respJSON = JSON.parse(resp.readAll(_));
	tracer&& tracer("Search response (192):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "French 2 (no accent): One result ok");
	//
	start();
});

asyncTest("stop  tests", 0, function(_) {
	doStop = true;
	start();
});
