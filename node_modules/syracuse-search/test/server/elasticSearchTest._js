"use strict";
/* jshint -W079 */
/* jshint unused: false */
/* global QUnit: false, asyncTest: false, test: false, strictEqual: false, ok: false, start: false, stop: false */

var helpers = require('syracuse-core/lib/helpers');
var streams = require("streamline/lib/streams/streams");
var sys = require("util");

var elasticBaseUrl = "http://localhost:9200";
var indexName = "unittest";

var tracer = console.log;
//var tracer = null;

//
var doStop = false;
QUnit.module(module.id, {
	setup: function() {},
	teardown: function() {
		if (doStop) {
			//syracuse.server.close();
			setTimeout(function() {
				process.kill(process.pid);
			}, 100);
		}
	}
});

asyncTest("index french tests", 16, function(_) {
	// test index exists
	var par = {
		url: elasticBaseUrl + "/" + indexName,
		method: 'HEAD'
	};
	var resp = streams.httpRequest(par).end().response(_);
	tracer && tracer("Index exists status (35):" + resp.statusCode);
	var reqUrl;
	if (resp.statusCode !== 404) {
		// delete index
		reqUrl = elasticBaseUrl + "/" + indexName;
		par = {
			url: reqUrl,
			method: 'DELETE'
		};
		resp = streams.httpRequest(par).end().response(_);
		var r = resp.readAll(_);
	}
	// create index
	reqUrl = elasticBaseUrl + "/" + indexName;
	par = {
		url: reqUrl,
		method: 'PUT'
	};
	var data = {
		"settings": {
			"index": {
				"analysis": {
					"analyzer": {
						"default": {
							type: "french"
						}
					}
				}
			}
		}
	};
	var req = streams.httpRequest(par);
	req.write(_, JSON.stringify(data));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index create status Ok");
	var respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index create response (53):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index create result ok");
	// create a mapping
	var entityName = "test1";
	var mapping = {};
	mapping[entityName] = {
		properties: {}
	};
	/*	var pm = mapping[entityName].properties;
	pm.stringInEnglish = {
			type: "string",
			analyzer: "english"
		};
	pm.stringInFrench = {
			type: "string",
			analyzer: "french"
		};*/
	var options = {
		url: elasticBaseUrl + "/" + indexName + "/" + entityName + "/_mapping",
		method: 'PUT'
	};
	req = streams.httpRequest(options);
	req.write(_, JSON.stringify(mapping));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index mapping update status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index mapping response (81):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index mapping update ok");
	// index some data
	var id1 = helpers.uuid.generate();
	var reqOptions = {
		url: [elasticBaseUrl, indexName, entityName, id1].join("/"),
		method: 'PUT'
	};
	req = streams.httpRequest(reqOptions);
	data = {
		stringInEnglish: "here's some english phrase to index",
		stringInFrench: "voilà une proposition à indexer en français"
	};
	req.write(_, JSON.stringify(data));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 201, "Index data status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index data response (98):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index data result ok");
	// !!! LET INDEXING DO BEFORE SEARCH
	options = {
		url: [elasticBaseUrl, indexName, "_refresh"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	resp = req.end().response(_).readAll(_);
	// search something not to be found default analyzer
	options = {
		url: [elasticBaseUrl, indexName, entityName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	var search = {
		query: {
			filtered: {
				query: {
					query_string: {
						query: "not_existing_query"
					}
				}
			}
		}
	};
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (122):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 0, "No result ok");
	// search something in english default analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = {
		query: {
			filtered: {
				query: {
					query_string: {
						query: "english phrase"
					}
				}
			}
		}
	};
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (145):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "English: One result ok");
	// search something in french, french analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = {
		query: {
			filtered: {
				query: {
					query_string: {
						query: "voilà"
					}
				}
			}
		}
	};
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (170):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "French 1: One result ok");
	// search something in french, french analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = {
		query: {
			filtered: {
				query: {
					query_string: {
						query: "voila francais voilà français",
						analyze_wildcard: true,
						default_operator: "AND"
					}
				}
			}
		}
	};
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (192):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "French 2 (all terms): One result ok");
	// search single term no accent in french, french analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = {
		query: {
			filtered: {
				query: {
					query_string: {
						query: "voila"
					}
				}
			}
		}
	};
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (192):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "French 2 (no accent): One result ok");
	//
	start();
});

asyncTest("stop  tests", 0, function(_) {
	doStop = true;
	start();
});