"use strict";
/* jshint -W079 */
/* jshint unused: false */
/* global QUnit: false, asyncTest: false, test: false, strictEqual: false, ok: false, start: false, stop: false */

var helpers = require('syracuse-core/lib/helpers');
var streams = require("streamline/lib/streams/streams");
var sys = require("util");
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var port = 3004;
var dataModel = require("syracuse-orm/lib/dataModel");
var elasticQuery = require("syracuse-search/lib/elasticQuery");

var elasticIndex = require("syracuse-search/lib/elasticIndex");
var IndexHelper = require("syracuse-search/lib/elasticIndex").IndexHelper;
var jsonImport = require("syracuse-import/lib/jsonImport");
var adminTestFixtures = require("syracuse-collaboration/test/fixtures/adminTestFixtures");
var mongodb = require('streamline-mongodb');
var testData = require('syracuse-sdata/test/fixtures/testDB');
var testEndPoint = testData.endpoint;
// Replace application and contract name

//force basic auth
config.session = config.session || {};
config.session.auth = "basic";
//no integration server
config.integrationServer = null;
var db;
var endPoint;
testEndPoint.datasets = {
	test: {
		driver: "mongodb",
		database: "test",
		hostname: "localhost",
		port: 27017
	}
};

config.sdata.endpoints.push(testEndPoint);


var indexHelper = elasticIndex.IndexHelper;
var elasticBaseUrl = "http://localhost:9200";
var indexName = "unittest";
var entityName = "test1";

var tracer; // = console.log;
var h;


function _extractHighlight(resources) {
	var highlights = [];

	function isHighlight(item, prop, key) {

		if (typeof prop.$isHighlight === "undefined" && Object.keys(prop).length > 0) {

			Object.keys(prop).map(function(k) {
				isHighlight(item, prop[k], key + "." + k);
			});
		}
		if (prop.$isHighlight) {
			highlights.push({
				$properties: prop,
				$key: item.$representation + "." + key
			});
		}
	}
	resources.map(function(item) {

		Object.keys(item.$properties).map(function(property) {

			isHighlight(item, item.$properties[property], property);
		});
	});
	return highlights;
}

function _makeContextQuerySearch(search, opt) {
	var ctx = {
		parameters: {
			q: search,
			count: 20,
			startIndex: 1,
		},
		reply: function(_, statusCode, mess) {
			opt.status = statusCode;
			opt.result = mess;
		},
		replySearchResults: function(_, statusCode, result) {
			opt.status = statusCode;
			opt.result = result;
		},
		getUserProfile: function(_) {
			return {
				selectedEndpoint: function(_) {
					return endPoint;
				},
				endpoints: function(_) {
					return [endPoint];
				}
			};
		},

	};
	if (opt.searchEntityName) {
		ctx.searchEntityName = "queryResult";
	} else {
		ctx.representation = {
			entity: "queryResult"
		};
	}
	return ctx;
}

function _makeQuery(q) {
	return {
		query: {
			filtered: {
				query: {
					query_string: {
						query: q + "*",
						analyze_wildcard: true,
						default_operator: "AND"
					}
				}
			}
		}
	};
}
var useStdSettings = true;

function _makeSettings(std, idxLoc) {
	return std ? elasticIndex.getIndexSettings(idxLoc) : {
		"settings": {
			"index": {
				"analysis": {
					"filter": {
						"my_stemmer": {
							"type": "stemmer",
							"name": "french"
						},
						"my_stop": {
							"type": "stop",
							"stopwords": "_french_"
						},
						"delimiter": {
							"type": "word_delimiter",
							"type_table": ["@ => ALPHANUM", ". => ALPHANUM"]
						}
					},
					"analyzer": {
						"default": {
							"type": "custom",
							//							"tokenizer": "uax_url_email",
							"tokenizer": "whitespace",
							"filter": ["delimiter", "asciifolding", "lowercase", "elision", "my_stemmer", "my_stop"]
						},
						"search": {
							"type": "custom",
							//							"tokenizer": "uax_url_email",
							"tokenizer": "whitespace",
							"filter": ["delimiter", "asciifolding", "lowercase", "elision", "my_stemmer", "my_stop"]
						}
					}
				}
			}
		}
	};
}

function _elasticPost(_, segment, data, status) {
	var options = {
		url: [elasticBaseUrl, indexName, entityName, segment].join("/"),
		method: "POST"
	};
	var req = streams.httpRequest(options);
	req.write(_, JSON.stringify(data));
	var resp = req.end().response(_);
	strictEqual(resp.statusCode, status, "POST Status Ok");
	return JSON.parse(resp.readAll(_));
}

function _analyze(_, analyzer, q) {
	var options = {
		url: [elasticBaseUrl, indexName, "_analyze"].join("/") + "?analyzer=" + analyzer + "&text=" + q + "&pretty=true",
		method: "GET"
	};
	var req = streams.httpRequest(options);
	var resp = req.end().response(_);
	return JSON.parse(resp.readAll(_));
}
//


var doStop = false;
QUnit.module(module.id, {
	setup: function() {},
	teardown: function() {
		if (doStop) {
			setTimeout(function() {
				process.kill(process.pid);
			}, 100);
		}
	}
});


asyncTest("index french tests", 21, function(_) {
	// test index exists
	var par = {
		url: elasticBaseUrl + "/" + indexName,
		method: 'HEAD'
	};
	var resp = streams.httpRequest(par).end().response(_);
	tracer && tracer("Index exists status (35):" + resp.statusCode);
	var reqUrl;
	if (resp.statusCode !== 404) {
		// delete index
		reqUrl = elasticBaseUrl + "/" + indexName;
		par = {
			url: reqUrl,
			method: 'DELETE'
		};
		resp = streams.httpRequest(par).end().response(_);
		var r = resp.readAll(_);
	}
	// create index
	reqUrl = elasticBaseUrl + "/" + indexName;
	par = {
		url: reqUrl,
		method: 'PUT'
	};
	var data = _makeSettings(useStdSettings, "fr-fr");
	var req = streams.httpRequest(par);
	req.write(_, JSON.stringify(data));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index create status Ok");
	var respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index create response (53):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index create result ok");
	// create a mapping
	var mapping = {};
	mapping[entityName] = {
		properties: {}
	};
	var options = {
		url: elasticBaseUrl + "/" + indexName + "/" + entityName + "/_mapping",
		method: 'PUT'
	};
	req = streams.httpRequest(options);
	req.write(_, JSON.stringify(mapping));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index mapping update status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index mapping response (81):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index mapping update ok");
	// index some data
	var id1 = helpers.uuid.generate();
	var reqOptions = {
		url: [elasticBaseUrl, indexName, entityName, id1].join("/"),
		method: 'PUT'
	};
	req = streams.httpRequest(reqOptions);
	data = {
		stringInEnglish: "here's some english phrase to index",
		stringInFrench: "voilà une proposition à indexer en français"
	};
	req.write(_, JSON.stringify(data));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 201, "Index data status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index data response (98):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index data result ok");

	// analyzer tests
	respJSON = _analyze(_, "default", "english phrase*");
	tracer && tracer("Analyze search (170):" + sys.inspect(respJSON));
	strictEqual(respJSON.tokens[1].token, "phras", "Phrase = phras ok");
	respJSON = _analyze(_, "default", "voilà*");
	tracer && tracer("Analyze search (173):" + sys.inspect(respJSON));
	var respJSONfr = _analyze(_, "french", "voilà*");
	tracer && tracer("Analyze search (175):" + sys.inspect(respJSONfr));
	strictEqual(respJSON.tokens[0].token, respJSONfr.tokens[0].token, "Voilà analyzed ok");
	var respJSONfr = _analyze(_, "french", "voilà une proposition à indexer en français");
	tracer && tracer("Analyze phrase french (178):" + sys.inspect(respJSONfr));
	respJSON = _analyze(_, "default", "voila francais voilà français");
	tracer && tracer("Analyze search (179):" + sys.inspect(respJSON));
	var respJSONfr = _analyze(_, "french", "voila francais voilà français");
	tracer && tracer("Analyze phrase french (181):" + sys.inspect(respJSONfr));
	var respJSON = _analyze(_, "default", "cristi.nitescu@sage.com");
	tracer && tracer("Analyze email (184):" + sys.inspect(respJSON));
	strictEqual(respJSON.tokens[0].token, "cristi.nitescu@sage.com", "Email analyzed ok");
	// partial email
	var respJSON = _analyze(_, "default", "cristi.nitescu@sage");
	tracer && tracer("Analyze email (184):" + sys.inspect(respJSON));
	strictEqual(respJSON.tokens[0].token, "cristi.nitescu@sag", "Partial email analyzed ok");
	// elision
	var respJSON = _analyze(_, "default", "l'avion");
	tracer && tracer("Analyze elision (188):" + sys.inspect(respJSON));
	strictEqual(respJSON.tokens[0].token, "avion", "Elision analyzed ok");

	// search tests
	options = {
		url: [elasticBaseUrl, indexName, "_refresh"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	resp = req.end().response(_).readAll(_);
	// search something not to be found default analyzer
	options = {
		url: [elasticBaseUrl, indexName, entityName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	var search = _makeQuery("not_existing_query");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (122):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 0, "No result ok");
	// search something in english default analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = _makeQuery("english phrase");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (145):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "English: One result ok");
	// search something in french, french analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = _makeQuery("voilà");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (170):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "French 1: One result ok");
	// search something in french, french analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = _makeQuery("voila francais voilà français");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (192):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "French 2 (all terms): One result ok");
	// search single term no accent in french, french analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = _makeQuery("voila");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (192):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "French 2 (no accent): One result ok");
	//
	start();
});

asyncTest("email field tests", 15, function(_) {
	var search;
	// test index exists
	var par = {
		url: elasticBaseUrl + "/" + indexName,
		method: 'HEAD'
	};
	var resp = streams.httpRequest(par).end().response(_);
	tracer && tracer("Index exists status (243):" + resp.statusCode);
	var reqUrl;
	if (resp.statusCode !== 404) {
		// delete index
		reqUrl = elasticBaseUrl + "/" + indexName;
		par = {
			url: reqUrl,
			method: 'DELETE'
		};
		resp = streams.httpRequest(par).end().response(_);
		var r = resp.readAll(_);
	}
	// create index
	reqUrl = elasticBaseUrl + "/" + indexName;
	par = {
		url: reqUrl,
		method: 'PUT'
	};
	var data = _makeSettings(useStdSettings, "fr-fr");
	var req = streams.httpRequest(par);
	req.write(_, JSON.stringify(data));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index create status Ok");
	var respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index create response (279):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index create result ok");
	// create a mapping
	var entityName = "test1";
	var mapping = {};
	mapping[entityName] = {
		properties: {
			/*			my_email: {
				type: "string",
				analyzer: "keyword"
			}*/
		}
	};
	var options = {
		url: elasticBaseUrl + "/" + indexName + "/" + entityName + "/_mapping",
		method: 'PUT'
	};
	req = streams.httpRequest(options);
	req.write(_, JSON.stringify(mapping));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index mapping update status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index mapping response (81):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index mapping update ok");
	// index some data
	var id1 = helpers.uuid.generate();
	var reqOptions = {
		url: [elasticBaseUrl, indexName, entityName, id1].join("/"),
		method: 'PUT'
	};
	req = streams.httpRequest(reqOptions);
	data = {
		my_email: "cristi.nitescu@sage.com"
	};
	req.write(_, JSON.stringify(data));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 201, "Index data status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index data response (98):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index data result ok");
	// !!! LET INDEXING DO BEFORE SEARCH
	options = {
		url: [elasticBaseUrl, indexName, "_refresh"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	resp = req.end().response(_).readAll(_);
	// Simple search
	respJSON = _elasticPost(_, "_search", _makeQuery("cristi"), 200);
	tracer && tracer("Search response (339):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "Simple search ok");
	// This query shouldn't have any result
	respJSON = _elasticPost(_, "_search", _makeQuery("cristi.fake@sage.com"), 200);
	tracer && tracer("Search response (339):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 0, "No result ok");
	// explain
	respJSON = _elasticPost(_, id1 + "/_explain", _makeQuery("cristi.fake@sage.com"), 200);
	tracer && tracer("Explain response (315):" + sys.inspect(respJSON, null, 6));
	// This query should have a result
	respJSON = _elasticPost(_, "_search", _makeQuery("cristi.*@sage.com"), 200);
	tracer && tracer("Search response (359):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "Found email with wildcard ok");
	// exact search
	respJSON = _elasticPost(_, "_search", _makeQuery("cristi.nitescu@sage.com"), 200);
	tracer && tracer("Search response (352):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "Found email with exact search ok");

	start();
});


// test elastic search integration 
asyncTest("init database", 1, function(_) {
	//
	db = adminTestFixtures.initializeTestEnvironnement(_);
	ok(db != null, "Environnement initialized");
	//
	start();
});

function onlyInfo(diags) {
	return adminTestFixtures.onlyInfo(diags);
}

asyncTest("database initialization test", 6, function(_) {
	// check pages
	var count = db.count(_, db.model.getEntity(_, "dashboardDef"), {});
	strictEqual(count, 1, "pages count ok");
	// fetch home dashboard
	var home = db.fetchInstance(_, db.model.getEntity(_, "dashboardDef"), {
		jsonWhere: {
			dashboardName: "home"
		}
	});
	ok(home != null, "Found home dashboard");
	// check variants count
	strictEqual(home.variants(_).getLength(), 1, "Home has one variant ok");
	// check vignettes count
	strictEqual(home.variants(_).toArray(_)[0].vignettes(_).getLength(), 5, "Variants vignettes count ok");
	// check groups
	var guest = db.fetchInstance(_, db.getEntity(_, "group"), {
		jsonWhere: {
			"description.en-us": "Guests"
		}
	});
	strictEqual(guest.description(_), "Guests", "Guests group fetched");
	strictEqual(guest.role(_).description(_), "Guest", "Guest role fetched ok");
	//
	start();
});


// test integration search 
asyncTest("import demo database", 11, function(_) {
	// import
	var diag = [];
	jsonImport.jsonImport(_, db, "syracuse-admin-demo.json", {
		$diagnoses: diag,
		tracer: tracer,
	});
	tracer && tracer("import demo db diags (134): " + sys.inspect(diag));
	ok(onlyInfo(diag), "Demo database import ok");
	// check roles
	var role = db.fetchInstance(_, db.model.getEntity(_, "role"), {
		jsonWhere: {
			description: "Sales manager"
		}
	});
	strictEqual(role.description(_), "Sales manager", "role fetch ok");
	var count = db.count(_, db.model.getEntity(_, "role"), {});
	strictEqual(count, 8, "roles count ok");
	// check endpoints
	var ep = db.fetchInstance(_, db.model.getEntity(_, "endPoint"), {
		jsonWhere: {
			description: "Global CRM"
		}
	});
	strictEqual(ep.description(_), "Global CRM", "endpoint fetch ok");
	var count = db.count(_, db.model.getEntity(_, "endPoint"), {});
	strictEqual(count, 5, "endpoint count ok");
	// check groups
	var gp = db.fetchInstance(_, db.model.getEntity(_, "group"), {
		jsonWhere: {
			description: "Sales managers"
		}
	});
	strictEqual(gp.description(_), "Sales managers", "group fetch ok");
	strictEqual(gp.endPoints(_).getLength(), 3, "Sales managers enpoint count ok");
	var count = db.count(_, db.model.getEntity(_, "group"), {});
	strictEqual(count, 11, "group count ok");
	// check users
	var user = db.fetchInstance(_, db.model.getEntity(_, "user"), {
		jsonWhere: {
			login: "hedum"
		}
	});
	strictEqual(user.login(_), "hedum", "user fetch ok");
	strictEqual(user.groups(_).getLength(), 2, "hedum group count ok");
	var count = db.count(_, db.model.getEntity(_, "user"), {});
	strictEqual(count, 11, "user count ok");

	start();
});


asyncTest("init indexHelper ", function(_) {
	endPoint = adminTestFixtures.modifyCollaborationEndpoint("unit_test");


	h = new IndexHelper(endPoint, "en-us");
	ok(true, "initialized indexHelper");
	start();
});

/*asyncTest("test delete index  syracuse administration", function(_) {
	try {
		var req = {
			url: elasticBaseUrl + "/syracuse.collaboration.unit_test.en-us/_mapping",
			method: 'GET'
		};
		var resp = streams.httpRequest(req).end().response(_);
		strictEqual(resp.statusCode, 200, "index  exists ok");


		// check existance of index 
		var diag = [];
		elasticIndex.deleteEndpointIndex(_, endPoint, "en-us", diag);
		ok(true, "launch delete indexation  ");

		var req = {
			url: elasticBaseUrl + "/syracuse.collaboration.unit_test.en-us/_mapping",
			method: 'GET'
		};
		var resp = streams.httpRequest(req).end().response(_);
		strictEqual(resp.statusCode, 404, "index not exists  ok");

	} catch (e) {
		ok(false, " delete indexation failed " + e.stack);

	}
	start();
});*/

asyncTest("test indexation syracuse administration", function(_) {
	try {
		h.updateIndex(_, false, {
			locale: "en-us",
			tracer: tracer,
			unit_test: true
		});
		ok(true, "launch indexation ");
		// check existance of index 
		var req = {
			url: elasticBaseUrl + "/syracuse.collaboration.unit_test.en-us/_mapping",
			method: 'GET'
		};
		var resp = streams.httpRequest(req).end().response(_);
		strictEqual(resp.statusCode, 200, "index created ok");

	} catch (e) {
		ok(false, "launch indexation failed " + e.stack);

	}
	start();
});


asyncTest("test query syracuse administration 1", 24, function(_) {
	var searchConfig = {
		editDistance: 2,
		prototype: false
	};
	var result = {};
	var ctx = _makeContextQuerySearch("testing", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "search ok ");
	strictEqual(ctx.totalCount, 0, "total result ok for test : " + ctx.totalCount);
	strictEqual(result.result.$resources.length, 0, "search body response ok for test: " + result.result.$resources.length);
	strictEqual(ctx.searchRequest.query.filtered.query.query_string.query, "testing OR testing~2", "check query string ok : " + ctx.searchRequest.query.filtered.query.query_string.query);



	ctx = _makeContextQuerySearch("admin", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "search ok ");
	strictEqual(ctx.totalCount != 0, true, "total result ok for admin : " + ctx.totalCount);
	//console.log("-------result  admin "+JSON.stringify(result.result.$resources,null,2));
	strictEqual(result.result.$resources.length != 0, true, "search body response ok for admin : " + result.result.$resources.length);
	//check request to elastic search 
	strictEqual(ctx.searchRequest.query.filtered.query.query_string.query, "admin OR admin~2", "check query string ok : " + ctx.searchRequest.query.filtered.query.query_string.query);
	//check highlight
	var hl = _extractHighlight(result.result.$resources);
	strictEqual(hl.length != 0, true, "check highlight " + hl.length);

	ctx = _makeContextQuerySearch("guest", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "search ok ");
	strictEqual(ctx.totalCount != 0, true, "total result ok for guest : " + ctx.totalCount);
	strictEqual(result.result.$resources.length != 0, true, "search body response ok for guest : " + result.result.$resources.length);
	strictEqual(ctx.searchRequest.query.filtered.query.query_string.query, "guest OR guest~2", "check query string ok : " + ctx.searchRequest.query.filtered.query.query_string.query);
	hl = _extractHighlight(result.result.$resources);
	strictEqual(hl.length != 0, true, "check highlight " + hl.length);


	ctx = _makeContextQuerySearch("group", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "search ok ");
	strictEqual(ctx.totalCount != 0, true, "total result ok for group : " + ctx.totalCount);
	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	strictEqual(ctx.searchRequest.query.filtered.query.query_string.query, "group OR group~2", "check query string ok : " + ctx.searchRequest.query.filtered.query.query_string.query);
	hl = _extractHighlight(result.result.$resources);
	strictEqual(hl.length != 0, true, "check highlight " + hl.length);


	ctx = _makeContextQuerySearch("setting", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "search ok ");
	strictEqual(ctx.totalCount != 0, true, "total result ok for group : " + ctx.totalCount);
	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	strictEqual(ctx.searchRequest.query.filtered.query.query_string.query, "setting OR setting~2", "check query string ok : " + ctx.searchRequest.query.filtered.query.query_string.query);
	hl = _extractHighlight(result.result.$resources);
	strictEqual(hl.length != 0, true, "check highlight " + hl.length);

	start();
});


asyncTest("test query syracuse administration 2", 19, function(_) {
	var searchConfig = {
		editDistance: 2,
		prototype: false
	};
	var result = {};
	var ctx = _makeContextQuerySearch("guest", result);
	elasticQuery.search(_, ctx, searchConfig);
	// check first result is the right one 
	strictEqual(result.status, 200, "Exact match search completed ok ");
	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	strictEqual(result.result.$resources[0].code, "<em>GUEST</em>", "resource that match the most ok : return " + result.result.$resources[0].code);

	// test fuzzy search with spelling - edit distance 1
	ctx = _makeContextQuerySearch("guet", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Fuzzy search edit=1 distance=2 completed ok");
	strictEqual(result.result.$resources.length != 0, true, "Search body response ok : " + result.result.$resources.length);
	strictEqual(result.result.$resources[0].code, "<em>GUEST</em>", "resource that match the most ok : return " + result.result.$resources[0].code);

	// test fuzzy search with spelling - edit distance is 2
	ctx = _makeContextQuerySearch("guets", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Fuzzy search edit=2 distance=2 completed ok");
	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	strictEqual(result.result.$resources[0].code, "<em>GUEST</em>", "resource that match the most ok : return " + result.result.$resources[0].code);

	// test fuzzy search with spelling - edit distance is 3
	// This should fail as the edit distance > 2
	ctx = _makeContextQuerySearch("geutss", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Fuzzy search edit=3 distance=2 completed ok");
	strictEqual(result.result.$resources.length == 0, true, "search body response empty : " + result.result.$resources.length);

	// test fuzzy search with spelling - edit distance is 3
	// Increasing the edit distance should cause this test to pass
	searchConfig.editDistance = 4;
	ctx = _makeContextQuerySearch("guetss", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Fuzzy search edit=3 distance=3 completed ok");
	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	strictEqual(result.result.$resources[0].code, "<em>GUEST</em>", "resource that match the most ok : return " + result.result.$resources[0].code);

	// test fuzzy search with spelling - edit distance is 2
	// Reducing the edit distance should cause this test to fail
	searchConfig.editDistance = 1;
	ctx = _makeContextQuerySearch("geust", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Search completed ok ");
	strictEqual(result.result.$resources.length == 0, true, "search body response empty : " + result.result.$resources.length);

	// Closer match should successfully 
	// test fuzzy search with spelling - edit distance 1
	ctx = _makeContextQuerySearch("gueft", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Search completed ok ");
	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	strictEqual(result.result.$resources[0].code, "<em>GUEST</em>", "resource that match the most ok : return " + result.result.$resources[0].code);

	start();
});

asyncTest("prototype query syracuse administration 1", function(_) {
	var searchConfig = {
		prototype: true,
		minSimilarity: 0.5,
		ignoreFrequency: true
	};
	var result = {};

	// Exact match should be unaffected by new search
	var ctx = _makeContextQuerySearch("certificates", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Search completed ok ");
	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	if (result.result.$resources[0].code === "S_<em>CERTIFICATES</em>" ||
		result.result.$resources[0].code === "S_CA_<em>CERTIFICATES</em>") {
		ok(true, "resource that match the most ok : return " + result.result.$resources[0].code);
	}

	// test fuzzy search with spelling - edit distance is 2
	ctx = _makeContextQuerySearch("certiifcates", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Search completed ok ");
	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	if (result.result.$resources[0].code === "S_<em>CERTIFICATES</em>" ||
		result.result.$resources[0].code === "S_CA_<em>CERTIFICATES</em>") {
		ok(true, "resource that match the most ok : return " + result.result.$resources[0].code);
	}

	// test fuzzy search with spelling - edit distance is 2
	// Adjust minimum similarity to cause the test to fail
	searchConfig.minSimilarity = 0.9;
	ctx = _makeContextQuerySearch("certifcates", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Search completed ok ");
	strictEqual(result.result.$resources.length == 0, true, "search body response empty : " + result.result.$resources.length);

	// test fuzzy search with spelling - edit distance is 4
	ctx = _makeContextQuerySearch("certiifactes", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Search completed ok ");
	strictEqual(result.result.$resources.length == 0, true, "search body response empty : " + result.result.$resources.length);

	searchConfig.minSimilarity = 0.3;
	ctx = _makeContextQuerySearch("certiifactes", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Search completed ok ");
	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	if (result.result.$resources[0].code === "S_<em>CERTIFICATES</em>" ||
		result.result.$resources[0].code === "S_CA_<em>CERTIFICATES</em>") {
		ok(true, "resource that match the most ok : return " + result.result.$resources[0].code);
	}


	start();
});

asyncTest("test delete index  syracuse administration", function(_) {
	try {
		var req = {
			url: elasticBaseUrl + "/syracuse.collaboration.unit_test.en-us/_mapping",
			method: 'GET'
		};
		var resp = streams.httpRequest(req).end().response(_);
		strictEqual(resp.statusCode, 200, "index  exists ok");


		// check existance of index 
		var diag = [];
		elasticIndex.deleteEndpointIndex(_, endPoint, "en-us", diag);
		ok(true, "launch delete indexation  ");

		var req = {
			url: elasticBaseUrl + "/syracuse.collaboration.unit_test.en-us/_mapping",
			method: 'GET'
		};
		var resp = streams.httpRequest(req).end().response(_);
		strictEqual(resp.statusCode, 404, "index not exists  ok");

	} catch (e) {
		ok(false, " delete indexation failed " + e.stack);

	}
	start();
});


asyncTest("test creation elastic search filter", function(_) {
	elasticQuery._addRightFilterCondition("( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )", {}, {}, {});

	//elasticQuery._addRightFilterCondition(_,"$uuid eq \"uuid-1\"",{},{},{});



	start();
});

asyncTest("stop  tests", 0, function(_) {
	doStop = true;
	start();
});