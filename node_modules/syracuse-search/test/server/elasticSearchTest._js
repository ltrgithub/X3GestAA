"use strict";
/* jshint -W079 */
/* jshint unused: false */
/* global QUnit: false, asyncTest: false, test: false, strictEqual: false, ok: false, start: false, stop: false */

var helpers = require('syracuse-core/lib/helpers');
var streams = require("streamline/lib/streams/streams");
var sys = require("util");
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var port = 3004;
var dataModel = require("syracuse-orm/lib/dataModel");
var elasticQuery = require("syracuse-search/lib/elasticQuery");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;

var elasticIndex = require("syracuse-search/lib/elasticIndex");
var IndexHelper = require("syracuse-search/lib/elasticIndex").IndexHelper;
var jsonImport = require("syracuse-import/lib/jsonImport");
var adminTestFixtures = require("syracuse-collaboration/test/fixtures/adminTestFixtures");
var mongodb = require('streamline-mongodb');
var testData = require('syracuse-sdata/test/fixtures/testDB');
var testEndPoint = testData.endpoint;
var searchEngine = require('syracuse-search/lib/elasticSearch');
var recOptions = {
	recMode: config.qunit && config.qunit.online ? "REC" : "PLAY",
	path: "node_modules/syracuse-search/test/server/"
};
// Replace application and contract name



//force basic auth
config.session = config.session || {};
config.session.auth = "basic";
//no integration server
config.integrationServer = null;
var db;
var endPoint;
testEndPoint.datasets = {
	test: {
		driver: "mongodb",
		database: "test",
		hostname: "localhost",
		port: 27017
	}
};

config.sdata.endpoints.push(testEndPoint);


var indexHelper = elasticIndex.IndexHelper;
var elasticBaseUrl = "http://localhost:9200";
var indexName = "unittest";
var entityName = "test1";

var tracer = null; //console.log;
var configTest = {};
configTest.hostname = "localhost";
configTest.port = 9200;
configTest.baseUrl = "http://" + configTest.hostname + ":" + configTest.port;
//
//

var h;


function _extractHighlight(resources) {
	var highlights = [];

	function isHighlight(item, prop, key) {

		if (typeof prop.$isHighlight === "undefined" && Object.keys(prop).length > 0) {

			Object.keys(prop).map(function(k) {
				isHighlight(item, prop[k], key + "." + k);
			});
		}
		if (prop.$isHighlight) {
			highlights.push({
				$properties: prop,
				$key: item.$representation + "." + key
			});
		}
	}
	resources.map(function(item) {

		Object.keys(item.$properties).map(function(property) {

			isHighlight(item, item.$properties[property], property);
		});
	});
	return highlights;
}

function _makeContextQuerySearch(search, opt) {
	var ctx = {
		parameters: {
			q: search,
			count: 20,
			startIndex: 1
		},
		reply: function(_, statusCode, mess) {
			opt.status = statusCode;
			opt.result = mess;
		},
		replySearchResults: function(_, statusCode, result) {
			opt.status = statusCode;
			opt.result = result;
		},
		getUserProfile: function(_) {
			return {

				selectedEndpoint: function(_) {
					return endPoint;
				},
				getAccessRightAuthorizations: function(_, endp) {
					return null;
				},
				user: function(_) {
					return {
						login: function(_) {
							return "guest";
						},
						getEndpointLogin: function(_, uuid) {
							return "guest_edl";
						}
					};
				}
			};
		}
	};
	if (opt.searchEntityName) {
		ctx.searchEntityName = "queryResult";
	} else {
		ctx.representation = {
			entity: "queryResult"
		};
	}
	return ctx;
}

function _makeQuery(q) {
	return {
		query: {
			filtered: {
				query: {
					query_string: {
						query: q + "*",
						analyze_wildcard: true,
						default_operator: "AND"
					}
				}
			}
		}
	};
}
var useStdSettings = true;

function _makeSettings(std, idxLoc) {
	return std ? elasticIndex.getIndexSettings(idxLoc) : {
		"settings": {
			"index": {
				"analysis": {
					"filter": {
						"my_stemmer": {
							"type": "stemmer",
							"name": "french"
						},
						"my_stop": {
							"type": "stop",
							"stopwords": "_french_"
						},
						"delimiter": {
							"type": "word_delimiter",
							"type_table": ["@ => ALPHANUM", ". => ALPHANUM"]
						}
					},
					"analyzer": {
						"default": {
							"type": "custom",
							//							"tokenizer": "uax_url_email",
							"tokenizer": "whitespace",
							"split_on_numerics": false,
							"filter": ["delimiter", "asciifolding", "lowercase", "elision", "my_stemmer", "my_stop"]
						},
						"search": {
							"type": "custom",
							//							"tokenizer": "uax_url_email",
							"tokenizer": "whitespace",
							"filter": ["delimiter", "asciifolding", "lowercase", "elision", "my_stemmer", "my_stop"]
						},
						"dave": {
							"type": "custom",
							//							"tokenizer": "uax_url_email",
							"tokenizer": "keyword",
							"filter": ["delimiter", "asciifolding", "lowercase", "elision", "my_stemmer", "my_stop"]
						}
					}
				}
			}
		}
	};
}

function _elasticPost(_, segment, data, status) {
	var options = {
		url: [elasticBaseUrl, indexName, entityName, segment].join("/"),
		method: "POST"
	};
	var req = streams.httpRequest(options);
	req.write(_, JSON.stringify(data));
	var resp = req.end().response(_);
	strictEqual(resp.statusCode, status, "POST Status Ok");
	return JSON.parse(resp.readAll(_));
}

function _analyze(_, analyzer, q) {
	var options = {
		url: [elasticBaseUrl, indexName, "_analyze"].join("/") + "?analyzer=" + analyzer + "&text=" + q + "&pretty=true",
		method: "GET"
	};
	var req = streams.httpRequest(options);
	var resp = req.end().response(_);
	return JSON.parse(resp.readAll(_));
}
//


var doStop = false;
QUnit.module(module.id, {
	setup: function() {},
	teardown: function() {
		if (doStop) {
			setTimeout(function() {
				process.kill(process.pid);
			}, 100);
		}
	}
});


asyncTest("index french tests", 22, function(_) {
	// test index exists
	var par = {
		url: elasticBaseUrl + "/" + indexName,
		method: 'HEAD'
	};
	var resp = streams.httpRequest(par).end().response(_);
	tracer && tracer("Index exists status (35):" + resp.statusCode);
	var reqUrl;
	if (resp.statusCode !== 404) {
		// delete index
		reqUrl = elasticBaseUrl + "/" + indexName;
		par = {
			url: reqUrl,
			method: 'DELETE'
		};
		resp = streams.httpRequest(par).end().response(_);
		var r = resp.readAll(_);
	}
	// create index
	reqUrl = elasticBaseUrl + "/" + indexName;
	par = {
		url: reqUrl,
		method: 'PUT'
	};
	var data = _makeSettings(useStdSettings, "fr-fr");
	var req = streams.httpRequest(par);
	req.write(_, JSON.stringify(data));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index create status Ok");
	var respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index create response (53):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index create result ok");
	// create a mapping
	var mapping = {};
	mapping[entityName] = {
		properties: {}
	};
	var options = {
		url: elasticBaseUrl + "/" + indexName + "/" + entityName + "/_mapping",
		method: 'PUT'
	};
	req = streams.httpRequest(options);
	req.write(_, JSON.stringify(mapping));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index mapping update status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index mapping response (81):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index mapping update ok");
	// index some data
	var id1 = helpers.uuid.generate();
	var reqOptions = {
		url: [elasticBaseUrl, indexName, entityName, id1].join("/"),
		method: 'PUT'
	};
	req = streams.httpRequest(reqOptions);
	data = {
		stringInEnglish: "here's some english phrase to index",
		stringInFrench: "voilà une proposition à indexer en français"
	};
	req.write(_, JSON.stringify(data));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 201, "Index data status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index data response (98):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index data result ok");

	// analyzer tests
	respJSON = _analyze(_, "default", "english phrase*");
	tracer && tracer("Analyze search (170):" + sys.inspect(respJSON));
	strictEqual(respJSON.tokens[1].token, "phras", "Phrase = phras ok");
	respJSON = _analyze(_, "default", "voilà*");
	tracer && tracer("Analyze search (173):" + sys.inspect(respJSON));
	var respJSONfr = _analyze(_, "french", "voilà*");
	tracer && tracer("Analyze search (175):" + sys.inspect(respJSONfr));
	strictEqual(respJSON.tokens[0].token, respJSONfr.tokens[0].token, "Voilà analyzed ok");
	var respJSONfr = _analyze(_, "french", "voilà une proposition à indexer en français");
	tracer && tracer("Analyze phrase french (178):" + sys.inspect(respJSONfr));
	respJSON = _analyze(_, "default", "voila francais voilà français");
	tracer && tracer("Analyze search (179):" + sys.inspect(respJSON));
	var respJSONfr = _analyze(_, "french", "voila francais voilà français");
	tracer && tracer("Analyze phrase french (181):" + sys.inspect(respJSONfr));
	var respJSON = _analyze(_, "default", "cristi.nitescu@sage.com");
	tracer && tracer("Analyze email (184):" + sys.inspect(respJSON));
	strictEqual(respJSON.tokens[0].token, "cristi.nitescu@sage.com", "Email analyzed ok");
	// partial email
	var respJSON = _analyze(_, "default", "cristi.nitescu@sage");
	tracer && tracer("Analyze email (184):" + sys.inspect(respJSON));
	strictEqual(respJSON.tokens[0].token, "cristi.nitescu@sag", "Partial email analyzed ok");
	// elision
	var respJSON = _analyze(_, "default", "l'avion");
	tracer && tracer("Analyze elision (188):" + sys.inspect(respJSON));
	strictEqual(respJSON.tokens[0].token, "avion", "Elision analyzed ok");
	respJSON = _analyze(_, "default", "ASS001");
	tracer && tracer("Analyze search (170):" + sys.inspect(respJSON));
	strictEqual(respJSON.tokens.length, 1, "Word delimiter not split on numeric ok");

	// search tests
	options = {
		url: [elasticBaseUrl, indexName, "_refresh"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	resp = req.end().response(_).readAll(_);
	// search something not to be found default analyzer
	options = {
		url: [elasticBaseUrl, indexName, entityName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	var search = _makeQuery("not_existing_query");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (122):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 0, "No result ok");
	// search something in english default analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = _makeQuery("english phrase");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (145):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "English: One result ok");
	// search something in french, french analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = _makeQuery("voilà");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (170):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "French 1: One result ok");
	// search something in french, french analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = _makeQuery("voila francais voilà français");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (192):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "French 2 (all terms): One result ok");
	// search single term no accent in french, french analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = _makeQuery("voila");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Search response (192):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "French 2 (no accent): One result ok");
	//
	start();
});

asyncTest("email field tests", 15, function(_) {
	var search;
	// test index exists
	var par = {
		url: elasticBaseUrl + "/" + indexName,
		method: 'HEAD'
	};
	var resp = streams.httpRequest(par).end().response(_);
	tracer && tracer("Index exists status (243):" + resp.statusCode);
	var reqUrl;
	if (resp.statusCode !== 404) {
		// delete index
		reqUrl = elasticBaseUrl + "/" + indexName;
		par = {
			url: reqUrl,
			method: 'DELETE'
		};
		resp = streams.httpRequest(par).end().response(_);
		var r = resp.readAll(_);
	}
	// create index
	reqUrl = elasticBaseUrl + "/" + indexName;
	par = {
		url: reqUrl,
		method: 'PUT'
	};
	var data = _makeSettings(useStdSettings, "fr-fr");
	var req = streams.httpRequest(par);
	req.write(_, JSON.stringify(data));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index create status Ok");
	var respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index create response (279):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index create result ok");
	// create a mapping
	var entityName = "test1";
	var mapping = {};
	mapping[entityName] = {
		properties: {
			my_email: {
				type: "string",
				analyzer: "keyword"
			}
		}
	};
	var options = {
		url: elasticBaseUrl + "/" + indexName + "/" + entityName + "/_mapping",
		method: 'PUT'
	};
	req = streams.httpRequest(options);
	req.write(_, JSON.stringify(mapping));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index mapping update status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index mapping response (81):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index mapping update ok");
	// index some data
	var id1 = helpers.uuid.generate();
	var reqOptions = {
		url: [elasticBaseUrl, indexName, entityName, id1].join("/"),
		method: 'PUT'
	};
	req = streams.httpRequest(reqOptions);
	data = {
		my_email: "cristi.nitescu@sage.com"
	};
	req.write(_, JSON.stringify(data));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 201, "Index data status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	tracer && tracer("Index data response (98):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index data result ok");
	// !!! LET INDEXING DO BEFORE SEARCH
	options = {
		url: [elasticBaseUrl, indexName, "_refresh"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	resp = req.end().response(_).readAll(_);
	// Simple search
	respJSON = _elasticPost(_, "_search", _makeQuery("cristi"), 200);
	tracer && tracer("Search response (339):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "Simple search ok");
	// This query shouldn't have any result
	respJSON = _elasticPost(_, "_search", _makeQuery("cristi.fake@sage.com"), 200);
	tracer && tracer("Search response (339):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 0, "No result ok");
	// explain
	respJSON = _elasticPost(_, id1 + "/_explain", _makeQuery("cristi.fake@sage.com"), 200);
	tracer && tracer("Explain response (315):" + sys.inspect(respJSON, null, 6));
	// This query should have a result
	respJSON = _elasticPost(_, "_search", _makeQuery("cristi.*@sage.com"), 200);
	tracer && tracer("Search response (359):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "Found email with wildcard ok");
	// exact search
	respJSON = _elasticPost(_, "_search", _makeQuery("cristi.nitescu@sage.com"), 200);
	tracer && tracer("Search response (352):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "Found email with exact search ok");

	start();
});


// test elastic search integration 
asyncTest("init database", 1, function(_) {
	//
	db = adminTestFixtures.initializeTestEnvironnement(_);
	ok(db != null, "Environnement initialized");
	//
	start();
});

function onlyInfo(diags) {
	return adminTestFixtures.onlyInfo(diags);
}




// test integration search 
asyncTest("import demo database", 11, function(_) {
	// import
	var diag = [];
	jsonImport.jsonImport(_, db, "syracuse-admin-demo.json", {
		$diagnoses: diag,
		tracer: tracer,
	});
	tracer && tracer("import demo db diags (134): " + sys.inspect(diag));
	ok(onlyInfo(diag), "Demo database import ok");
	// check roles
	var role = db.fetchInstance(_, db.model.getEntity(_, "role"), {
		jsonWhere: {
			description: "Sales manager"
		}
	});
	strictEqual(role.description(_), "Sales manager", "role fetch ok");
	var count = db.count(_, db.model.getEntity(_, "role"), {});
	strictEqual(count, 8, "roles count ok");
	// check endpoints
	var ep = db.fetchInstance(_, db.model.getEntity(_, "endPoint"), {
		jsonWhere: {
			description: "Global CRM"
		}
	});
	strictEqual(ep.description(_), "Global CRM", "endpoint fetch ok");
	var count = db.count(_, db.model.getEntity(_, "endPoint"), {});
	strictEqual(count, 5, "endpoint count ok");
	// check groups
	var gp = db.fetchInstance(_, db.model.getEntity(_, "group"), {
		jsonWhere: {
			description: "Sales managers"
		}
	});
	strictEqual(gp.description(_), "Sales managers", "group fetch ok");
	strictEqual(gp.endPoints(_).getLength(), 3, "Sales managers enpoint count ok");
	var count = db.count(_, db.model.getEntity(_, "group"), {});
	strictEqual(count, 11, "group count ok");
	// check users
	var user = db.fetchInstance(_, db.model.getEntity(_, "user"), {
		jsonWhere: {
			login: "hedum"
		}
	});
	strictEqual(user.login(_), "hedum", "user fetch ok");
	strictEqual(user.groups(_).getLength(), 2, "hedum group count ok");
	var count = db.count(_, db.model.getEntity(_, "user"), {});
	strictEqual(count, 11, "user count ok");

	start();
});


asyncTest("init indexHelper ", function(_) {
	endPoint = adminTestFixtures.modifyCollaborationEndpoint("unit_test");


	h = new IndexHelper(endPoint, "en-us");
	ok(true, "initialized indexHelper");
	start();
});

asyncTest("test delete index  syracuse administration", function(_) {
	try {

		elasticIndex.tracer = tracer;
		elasticIndex.serverConfig = configTest;
		var req = {
			url: elasticBaseUrl + "/syracuse.collaboration.unit_test.en-us/_mapping",
			method: 'GET'
		};
		var resp = streams.httpRequest(req).end().response(_);
		strictEqual(resp.statusCode, 404, "index  exists ok");


		// check existance of index 
		var diag = [];
		elasticIndex.deleteEndpointIndex(_, endPoint, "en-us", diag);
		ok(true, "launch delete indexation  ");

		var req = {
			url: elasticBaseUrl + "/syracuse.collaboration.unit_test.en-us/_mapping",
			method: 'GET'
		};
		var resp = streams.httpRequest(req).end().response(_);
		strictEqual(resp.statusCode, 404, "index not exists  ok");

	} catch (e) {
		ok(false, " delete indexation failed " + e.stack);

	}
	start();
});

asyncTest("test indexation syracuse administration", function(_) {
	try {

		elasticIndex.tracer = tracer;
		elasticIndex.serverConfig = configTest;
		h.updateIndex(_, false, {
			locale: "en-us",
			tracer: tracer,
			unit_test: true
		});
		ok(true, "launch indexation ");
		// check existance of index 
		var req = {
			url: elasticBaseUrl + "/syracuse.collaboration.unit_test.en-us/_mapping",
			method: 'GET'
		};
		var resp = streams.httpRequest(req).end().response(_);
		strictEqual(resp.statusCode, 200, "index created ok");

	} catch (e) {
		ok(false, "launch indexation failed " + e.stack);

	}
	start();
});


asyncTest("test query syracuse administration 1", function(_) {
	recOptions.fileName = "test";
	var searchConfig = {
		editDistance: 2,
		prototype: false,
		recOptions: recOptions,
		keepInContext: true
	};

	// no data
	elasticQuery.tracer = tracer;
	elasticQuery.serverConfig = configTest;
	var result = {};
	var ctx = _makeContextQuerySearch("testing", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "search ok ");
	strictEqual(ctx.totalCount, 0, "total result ok for test : " + ctx.totalCount);
	strictEqual(result.result.$resources.length, 0, "search body response ok for test: " + result.result.$resources.length);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "testing", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);


	// basic
	ctx = _makeContextQuerySearch("admin", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "search ok ");
	strictEqual(ctx.totalCount !== 0, true, "total result ok for admin : " + ctx.totalCount);
	//console.log("-------result  admin "+JSON.stringify(result.result.$resources,null,2));
	strictEqual(result.result.$resources.length != 0, true, "search body response ok for admin : " + result.result.$resources.length);
	//check request to elastic search 
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "admin", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	//check highlight
	var hl = _extractHighlight(result.result.$resources);
	strictEqual(hl.length !== 0, true, "check highlight " + hl.length);

	// case sensitivity
	ctx = _makeContextQuerySearch("AdmIn", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "search ok ");
	strictEqual(ctx.totalCount !== 0, true, "total result ok for admin : " + ctx.totalCount);
	//console.log("-------result  admin "+JSON.stringify(result.result.$resources,null,2));
	strictEqual(result.result.$resources.length != 0, true, "search body response ok for admin : " + result.result.$resources.length);
	//check request to elastic search
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "admin", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	//check highlight


	// test for checking relevant result
	ctx = _makeContextQuerySearch("guest", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "search ok ");
	strictEqual(ctx.totalCount !== 0, true, "total result ok for guest : " + ctx.totalCount);
	strictEqual(result.result.$resources.length != 0, true, "search body response ok for guest : " + result.result.$resources.length);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "guest", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	hl = _extractHighlight(result.result.$resources);
	strictEqual(hl.length !== 0, true, "check highlight " + hl.length);


	// check list of word
	ctx = _makeContextQuerySearch("Sales manager", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "search ok ");
	strictEqual(ctx.totalCount !== 0, true, "total result ok for group admin : " + ctx.totalCount);
	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "sales manager", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	hl = _extractHighlight(result.result.$resources);
	strictEqual(hl.length !== 0, true, "check highlight " + hl.length);

	// forbidden character
	ctx = _makeContextQuerySearch("*setting", result);
	try {
		strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "*setting", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);

		elasticQuery.search(_, ctx, searchConfig);

		ok(false, "test character * ok ");
	} catch (e) {
		ok(true, "test character * ok ");
	}

	ctx = _makeContextQuerySearch("/setting", result);
	try {
		elasticQuery.search(_, ctx, searchConfig);
		ok(true, "test character / ok ");
	} catch (e) {
		ok(false, "test character / ok ");
	}

	// search on date
	/*ctx = _makeContextQuerySearch("04-12-2014", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "04/12/2014", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
    */


	// search on numeric
	ctx = _makeContextQuerySearch("10,01", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "10.01", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);



	start();
});

asyncTest("test syracuse right filter  ", function(_) {
	var search = {
		query: {
			filtered: {}
		}
	};
	var syraRight = {
		"$mode": "restriction",
		"$entities": {
			"typeTest": {
				"restriction": true,
			},
		}
	};


	// test syracuse filter generation on data
	syraRight.$entities.typeTest.condition = "author.$uuid eq test and toto.$uuid eq tst" // test replace author in by  .$uuid $key;
	elasticQuery.addSyracuseRightFilter(_, syraRight, search, false);
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"query":{"field":{"author.$key":"test"}}},{"query":{"field":{"toto.$key":"tst"}}},{"query":{"field":{"_type":"typeTest"}}}]}]}', "syracuse right filter : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	syraRight.$entities.typeTest.condition = "$uuid eq bla" // test replace author in by $uuid _id;
	elasticQuery.addSyracuseRightFilter(_, syraRight, search, false);
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"query":{"field":{"_id":"bla"}}},{"query":{"field":{"_type":"typeTest"}}}]}]}', "syracuse right filter " + JSON.stringify(search.query.filtered.filter));


	search.query.filtered = {};
	syraRight.$entities.typeTest.condition = "$uuid eq bla and $uuid in (test)" // test replace author in by $uuid _id;
	elasticQuery.addSyracuseRightFilter(_, syraRight, search, false);
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"query":{"field":{"_id":"bla"}}},{"terms":{"_id":["test"]}},{"query":{"field":{"_type":"typeTest"}}}]}]}', "syracuse right filter " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	syraRight.$entities.typeTest.condition = "author in (test,test2) and author in (toto) and author eq test" // test replace author in by author.$key;
	elasticQuery.addSyracuseRightFilter(_, syraRight, search, false);
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"terms":{"author.$key":["test","test2"]}},{"terms":{"author.$key":["toto"]}},{"query":{"field":{"author":"test"}}},{"query":{"field":{"_type":"typeTest"}}}]}]}', "syracuse right filter ok : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	syraRight.$entities.typeTest.condition = "(teams eq null) or ((teams ne null) and (teams in (test1) or teams in (test2) or teams in (test3)))"; // test replace author in by author.$key
	elasticQuery.addSyracuseRightFilter(_, syraRight, search, false);
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"or":[{"missing":{"field":"teams"}},{"and":[{},{"or":[{"terms":{"teams.$key":["test1"]}},{"terms":{"teams.$key":["test2"]}},{"terms":{"teams.$key":["test3"]}}]}]}]},{"query":{"field":{"_type":"typeTest"}}}]}]}', "syracuse right filter ok : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	syraRight.$entities.typeTest.condition = "(administrator ne null and administrator.$uuid eq test1 or (authors ne null and authors in (test1) or (members ne null and members in (test1))))"; // test replace author in by author.$key
	elasticQuery.addSyracuseRightFilter(_, syraRight, search, false);

	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"or":[{"and":[{},{"query":{"field":{"administrator.$key":"test1"}}}]},{"and":[{},{"terms":{"authors.$key":["test1"]}}]},{"and":[{},{"terms":{"members.$key":["test1"]}}]}]},{"query":{"field":{"_type":"typeTest"}}}]}]}', "syracuse right filter ok : " + JSON.stringify(search.query.filtered.filter));



});

asyncTest("test right filter  ", function(_) {
	var search = {
		query: {
			filtered: {}
		}
	};
	var syraRight = {
		"$accessCode": "restriction",
		"$authorizedFunctions": "*",
		"$disableFunctions": "",
		"$authorizedRepresentations": {
			"AQCITEM1": {

			},
			"AQCITEM2": {

			},
			"AQCITEM3": {

			},
			"AQCITEM4": {

			}
		}
	};
});
/*
asyncTest("test query syracuse administration 2", 19, function(_) {
	var searchConfig = {
		editDistance: 2,
		prototype: false,
        keepInContext: true
	};

	elasticQuery.tracer = tracer;
	elasticQuery.serverConfig = configTest;
	var result = {};
	var ctx = _makeContextQuerySearch("gues", result);

	elasticQuery.search(_, ctx, searchConfig);
	// check first result is the right one 
	strictEqual(result.status, 200, "startWith match search completed ok ");
	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	var res = '{"filtered":{"query":{"query_string":{"query":"gues*","default_operator":"AND","analyze_wildcard":true,"allow_leading_wildcard":false}}}}';
	strictEqual(res, JSON.stringify(ctx.searchRequest.query), "request ok ");
	strictEqual(result.result.$resources[0].groups, "<em>Guests</em>", "resource that match the most ok : return " + result.result.$resources[0].groups);

	// test fuzzy search with spelling - edit distance 1
	searchConfig.minSimilarity = 0.5;
	ctx = _makeContextQuerySearch("guet", result);
	elasticQuery.fsearch(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Fuzzy search minSimilarity=0.5  completed ok");
	res = '{"filtered":{"query":{"bool":{"should":[{"custom_boost_factor":{"query":{"query_string":{"query":"guet","boost":100,"analyze_wildcard":true,"allow_leading_wildcard":false}},"boost_factor":2.5}},{"constant_score":{"query":{"fuzzy_like_this":{"like_text":"guet","max_query_terms":20,"min_similarity":0.5,"ignore_tf":true,"boost":1}},"boost":1}}]}}}}';
	strictEqual(res, JSON.stringify(ctx.searchRequest.query), "request ok ");
	strictEqual(result.result.$resources.length != 0, true, "Search body response ok : " + result.result.$resources.length);
	strictEqual(result.result.$resources[0].groups, "<em>Guests</em>", "resource that match the most ok : return " + result.result.$resources[0].groups);


	// test fuzzy search with spelling - edit distance is 2
	searchConfig.minSimilarity = 1;

	ctx = _makeContextQuerySearch("guets", result);
	elasticQuery.fsearch(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Fuzzy search minSimilarity=1 completed ok");
	res = '{"filtered":{"query":{"bool":{"should":[{"custom_boost_factor":{"query":{"query_string":{"query":"guets","boost":100,"analyze_wildcard":true,"allow_leading_wildcard":false}},"boost_factor":2.5}},{"constant_score":{"query":{"fuzzy_like_this":{"like_text":"guets","max_query_terms":20,"min_similarity":0.5,"ignore_tf":true,"boost":1}},"boost":1}}]}}}}';
	strictEqual(res, JSON.stringify(ctx.searchRequest.query), "request ok ");
	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	strictEqual(result.result.$resources[0].login, "<em>guest</em>", "resource that match the most ok : return " + result.result.$resources[0].code);

	// test fuzzy search with spelling - edit distance is 3
	// This should fail as the edit distance > 2
	searchConfig.minSimilarity = 3;

	ctx = _makeContextQuerySearch("geutss", result);
	elasticQuery.fsearch(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Fuzzy search minSimilarity=3 completed ok");
	strictEqual(result.result.$resources.length == 0, true, "search body response empty : " + result.result.$resources.length);

	// test fuzzy search with spelling - edit distance is 3
	// Increasing the edit distance should cause this test to pass
	ctx = _makeContextQuerySearch("guest", result);
	elasticQuery.xsearch(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Fuzzy search exact completed ok");

	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);

	strictEqual(result.result.$resources[0].code, "<em>GUEST</em>", "resource that match the most ok : return " + result.result.$resources[0].code);

	// test fuzzy search with spelling - edit distance is 2
	// Reducing the edit distance should cause this test to fail
	searchConfig.minSimilarity = 2;
	ctx = _makeContextQuerySearch("geust", result);
	elasticQuery.fsearch(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Search completed ok ");
	strictEqual(result.result.$resources.length == 0, true, "search body response empty : " + result.result.$resources.length);
	strictEqual(result.result.$resources[0].code, "<em>GUEST</em>", "resource that match the most ok : return " + result.result.$resources[0].code);


	// Closer match should successfully 
	// test fuzzy search with spelling - edit distance 1
	searchConfig.minSimilarity = 3;
	ctx = _makeContextQuerySearch("gueft", result);
	elasticQuery.fsearch(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Search completed ok ");

	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	strictEqual(result.result.$resources[0].code, "<em>GUEST</em>", "resource that match the most ok : return " + result.result.$resources[0].code);

	start();
});

asyncTest("prototype query syracuse administration 1", function(_) {
	var searchConfig = {
		prototype: true,
		minSimilarity: 0.5,
		ignoreFrequency: true,
        keepInContext: true
	};
	var result = {};

	elasticQuery.tracer = tracer;
	elasticQuery.serverConfig = configTest;

	// Exact match should be unaffected by new search
	var ctx = _makeContextQuerySearch("certificates", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Search completed ok ");
	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	if (result.result.$resources[0].code === "S_<em>CERTIFICATES</em>" ||
		result.result.$resources[0].code === "S_CA_<em>CERTIFICATES</em>") {
		ok(true, "resource that match the most ok : return " + result.result.$resources[0].code);
	}

	// test fuzzy search with spelling - edit distance is 2
	ctx = _makeContextQuerySearch("certiifcates", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Search completed ok ");
	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	if (result.result.$resources[0].code === "S_<em>CERTIFICATES</em>" ||
		result.result.$resources[0].code === "S_CA_<em>CERTIFICATES</em>") {
		ok(true, "resource that match the most ok : return " + result.result.$resources[0].code);
	}

	// test fuzzy search with spelling - edit distance is 2
	// Adjust minimum similarity to cause the test to fail
	searchConfig.minSimilarity = 0.9;
	ctx = _makeContextQuerySearch("certifcates", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Search completed ok ");
	strictEqual(result.result.$resources.length == 0, true, "search body response empty : " + result.result.$resources.length);

	// test fuzzy search with spelling - edit distance is 4
	ctx = _makeContextQuerySearch("certiifactes", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Search completed ok ");
	strictEqual(result.result.$resources.length == 0, true, "search body response empty : " + result.result.$resources.length);

	searchConfig.minSimilarity = 0.3;
	ctx = _makeContextQuerySearch("certiifactes", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "Search completed ok ");
	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	if (result.result.$resources[0].code === "S_<em>CERTIFICATES</em>" ||
		result.result.$resources[0].code === "S_CA_<em>CERTIFICATES</em>") {
		ok(true, "resource that match the most ok : return " + result.result.$resources[0].code);
	}


	start();
});
*/
asyncTest("test delete index  syracuse administration", function(_) {
	try {

		elasticIndex.tracer = tracer;
		elasticIndex.serverConfig = configTest;
		var req = {
			url: elasticBaseUrl + "/syracuse.collaboration.unit_test.en-us/_mapping",
			method: 'GET'
		};
		var resp = streams.httpRequest(req).end().response(_);
		strictEqual(resp.statusCode, 200, "index  exists ok");


		// check existance of index 
		var diag = [];
		elasticIndex.deleteEndpointIndex(_, endPoint, "en-us", diag);
		ok(true, "launch delete indexation  ");

		req = {
			url: elasticBaseUrl + "/syracuse.collaboration.unit_test.en-us/_mapping",
			method: 'GET'
		};
		resp = streams.httpRequest(req).end().response(_);
		strictEqual(resp.statusCode, 404, "index not exists  ok");




	} catch (e) {
		ok(false, " delete indexation failed " + e.stack);

	}
	start();
});

asyncTest("test creation elastic search filter", function(_) {
	var search = {
		query: {
			filtered: {}
		}
	};
	// test add filter
	elasticQuery._addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
	var res = '{"query":{"filtered":{"filter":{"and":[{"and":[{"or":[{"query":{"field":{"$uuid":"uuid-1"}}},{"query":{"field":{"test.ap":"test"}}}]},{"query":{"field":{"test.toto":"23"}}}]}]}}}}';
	strictEqual(res, JSON.stringify(search), "generate simple filter ok");

	search = {
		query: {
			filtered: {}
		}
	};
	elasticQuery._addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
	res = '{"query":{"filtered":{"filter":{"and":[{"and":[{"or":[{"query":{"field":{"$uuid":"uuid-1"}}},{"query":{"field":{"test.ap":"test"}}}]},{"query":{"field":{"test.toto":"23"}}}]}]}}}}';
	strictEqual(res, JSON.stringify(search), "generate complexe filter ok");

	var search = {
		query: {
			filtered: {}
		}
	};
	elasticQuery._addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
	res = '{"query":{"filtered":{"filter":{"and":[{"and":[{"or":[{"query":{"field":{"$uuid":"uuid-1"}}},{"query":{"field":{"test.ap":"test"}}}]},{"query":{"field":{"test.toto":"23"}}}]}]}}}}';
	strictEqual(res, JSON.stringify(search), "generate filter ok");

	elasticQuery._addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
	console.log(JSON.stringify(search));
	res = '{"query":{"filtered":{"filter":{"and":[{"and":[{"or":[{"query":{"field":{"$uuid":"uuid-1"}}},{"query":{"field":{"test.ap":"test"}}}]},{"query":{"field":{"test.toto":"23"}}}]}]}}}}';
	strictEqual(res, JSON.stringify(search), "add filter ok");

	//elasticQuery._addRightFilterCondition(_,"$uuid eq \"uuid-1\"",{},{},{});
	start();
});

asyncTest("stop  tests", 0, function(_) {
	doStop = true;
	start();
});