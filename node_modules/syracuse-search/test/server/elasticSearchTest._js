"use strict";
/* jshint -W079 */
/* jshint unused: false */
/* global QUnit: false, asyncTest: false, test: false, strictEqual: false, ok: false, start: false, stop: false */

/*global QUnit, start, ok*/
var helpers = require('syracuse-core/lib/helpers');
var streams = require("streamline/lib/streams/streams");
var sys = require("util");
var config = require('config'); // must be first syracuse require
var port = 3004;
var dataModel = require("syracuse-orm/lib/dataModel");
var elasticQuery = require("syracuse-search/lib/elasticQuery");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;

var elasticIndex = require("syracuse-search/lib/elasticIndex");
var IndexHelper = require("syracuse-search/lib/elasticIndex").IndexHelper;
var jsonImport = require("syracuse-import/lib/jsonImport");
var adminTestFixtures = require("syracuse-collaboration/test/fixtures/adminTestFixtures");
var mongodb = require('streamline-mongodb');
var testData = require('syracuse-sdata/test/fixtures/testDB');
var testEndPoint = testData.endpoint;
var searchEngine = require('syracuse-search/lib/elasticSearch');
var recOptions = {
	recMode: config.qunit && config.qunit.online ? "REC" : "PLAY",
	path: "node_modules/syracuse-search/test/server/"
};

//force basic auth
config.session = config.session || {};
config.session.auth = "basic";
//no integration server
config.integrationServer = null;
var db;
var endPoint;
testEndPoint.datasets = {
	test: {
		driver: "mongodb",
		database: "test",
		hostname: "localhost",
		port: 27017
	}
};

config.sdata.endpoints.push(testEndPoint);


var indexHelper = elasticIndex.IndexHelper;
var elasticBaseUrl = "http://localhost:9200";
var indexName = "unittest";
var entityName = "test1";

var configTest = {};
configTest.hostname = "localhost";
configTest.port = 9200;
configTest.baseUrl = "http://" + configTest.hostname + ":" + configTest.port;

var tracer = null; // console.log;

function debugTrace(mesg) {
	if (tracer) {
		tracer(mesg);
	}
}
//
//

var h;


function _extractHighlight(resources) {
	var highlights = [];

	function isHighlight(item, prop, key) {
		if (prop.$isHighlight === "undefined" && Object.keys(prop).length > 0) {

			Object.keys(prop).map(function(k) {
				isHighlight(item, prop[k], key + "." + k);
			});
		}
		if (prop.$isHighlight) {
			highlights.push({
				$properties: prop,
				$key: item.$representation + "." + key
			});
		}
	}
	resources.map(function(item) {

		Object.keys(item.$properties).map(function(property) {
			if (item.$properties[property])
				isHighlight(item, item.$properties[property], property);
		});
	});
	return highlights;
}

function _makeContextQuerySearch(search, opt) {
	var ctx = {
		dataset: "syracuse",
		parameters: {
			q: search,
			count: 20,
			startIndex: 1
		},
		reply: function(_, statusCode, mess) {
			opt.status = statusCode;
			opt.result = mess;
		},
		replySearchResults: function(_, statusCode, result) {
			opt.status = statusCode;
			opt.result = result;
		},
		getUserProfile: function(_) {
			return {
				selectedLocale: function(_) {
					return {
						code: opt.locale || "en-us",
						enabled: true,
						shortDate: function(_) {
							return opt.shortDate || "dd/mm/yyyy";
						}
					};
				},
				selectedEndpoint: function(_) {
					return endPoint;
				},
				getAccessRightAuthorizations: function(_, endp) {
					return null;
				},
				user: function(_) {
					return {
						login: function(_) {
							return "guest";
						},
						getEndpointLogin: function(_, uuid) {
							return "guest_edl";
						}
					};
				}
			};
		}
	};
	if (opt.searchEntityName) {
		ctx.searchEntityName = "queryResult";
	} else {
		ctx.representation = {
			entity: "queryResult"
		};
	}
	if (opt.searchType) {
		ctx.parameters.searchType = opt.searchType;
	}
	return ctx;
}

function _makeQuery(q) {
	return {
		query: {
			filtered: {
				query: {
					query_string: {
						query: q + "*",
						analyze_wildcard: true,
						default_operator: "AND"
					}
				}
			}
		}
	};
}
var useStdSettings = true;

function _makeSettings(std, idxLoc) {
	return std ? elasticIndex.getIndexSettings(idxLoc) : {
		"settings": {
			"index": {
				"analysis": {
					"filter": {
						"my_stemmer": {
							"type": "stemmer",
							"name": "french"
						},
						"my_stop": {
							"type": "stop",
							"stopwords": "_french_"
						},
						"delimiter": {
							"type": "word_delimiter",
							"type_table": ["@ => ALPHANUM", ". => ALPHANUM"]
						}
					},
					"analyzer": {
						"default": {
							"type": "custom",
							//							"tokenizer": "uax_url_email",
							"tokenizer": "whitespace",
							"split_on_numerics": false,
							"filter": ["delimiter", "asciifolding", "lowercase", "elision", "my_stemmer", "my_stop"]
						},
						"search": {
							"type": "custom",
							//							"tokenizer": "uax_url_email",
							"tokenizer": "whitespace",
							"filter": ["delimiter", "asciifolding", "lowercase", "elision", "my_stemmer", "my_stop"]
						},
						"dave": {
							"type": "custom",
							//							"tokenizer": "uax_url_email",
							"tokenizer": "keyword",
							"filter": ["delimiter", "asciifolding", "lowercase", "elision", "my_stemmer", "my_stop"]
						}
					}
				}
			}
		}
	};
}

function _elasticPost(_, segment, data, status) {
	var options = {
		url: [elasticBaseUrl, indexName, entityName, segment].join("/"),
		method: "POST"
	};
	var req = streams.httpRequest(options);
	req.write(_, JSON.stringify(data));
	var resp = req.end().response(_);
	strictEqual(resp.statusCode, status, "POST Status Ok");
	return JSON.parse(resp.readAll(_));
}

function _analyze(_, analyzer, q) {
	var options = {
		url: [elasticBaseUrl, indexName, "_analyze"].join("/") + "?analyzer=" + analyzer + "&text=" + q + "&pretty=true",
		method: "GET"
	};
	var req = streams.httpRequest(options);
	var resp = req.end().response(_);
	return JSON.parse(resp.readAll(_));
}
//


var doStop = false;
QUnit.module(module.id, {
	setup: function() {},
	teardown: function() {
		if (doStop) {
			setTimeout(function() {
				process.kill(process.pid);
			}, 100);
		}
	}
});

// First set of tests - checked and running.

asyncTest("index french tests", 22, function(_) {
	// test index exists
	var par = {
		url: elasticBaseUrl + "/" + indexName,
		method: 'HEAD'
	};
	var resp = streams.httpRequest(par).end().response(_);
	debugTrace("Index exists status (35):" + resp.statusCode);
	var reqUrl;
	if (resp.statusCode !== 404) {
		// delete index
		reqUrl = elasticBaseUrl + "/" + indexName;
		par = {
			url: reqUrl,
			method: 'DELETE'
		};
		resp = streams.httpRequest(par).end().response(_);
		var r = resp.readAll(_);
		debugTrace(r);
	}
	// create index
	reqUrl = elasticBaseUrl + "/" + indexName;
	par = {
		url: reqUrl,
		method: 'PUT'
	};
	var data = _makeSettings(useStdSettings, "fr-fr");
	var req = streams.httpRequest(par);
	req.write(_, JSON.stringify(data));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index create status Ok");
	var respJSON = JSON.parse(resp.readAll(_));
	debugTrace("Index create response (53):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index create result ok");
	// create a mapping
	var mapping = {};
	mapping[entityName] = {
		properties: {}
	};
	var options = {
		url: elasticBaseUrl + "/" + indexName + "/" + entityName + "/_mapping",
		method: 'PUT'
	};
	req = streams.httpRequest(options);
	req.write(_, JSON.stringify(mapping));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index mapping update status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	debugTrace("Index mapping response (81):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index mapping update ok");
	// index some data
	var id1 = helpers.uuid.generate();
	var reqOptions = {
		url: [elasticBaseUrl, indexName, entityName, id1].join("/"),
		method: 'PUT'
	};
	req = streams.httpRequest(reqOptions);
	data = {
		stringInEnglish: "here's some english phrase to index",
		stringInFrench: "voilà une proposition à indexer en français"
	};
	req.write(_, JSON.stringify(data));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 201, "Index data status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	debugTrace("Index data response (98):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index data result ok");

	// analyzer tests
	respJSON = _analyze(_, "default", "english phrase*");
	debugTrace("Analyze search (170):" + sys.inspect(respJSON));
	strictEqual(respJSON.tokens[1].token, "phras", "Phrase = phras ok");
	respJSON = _analyze(_, "default", "voilà*");
	debugTrace("Analyze search (173):" + sys.inspect(respJSON));
	var respJSONfr = _analyze(_, "french", "voilà*");
	debugTrace("Analyze search (175):" + sys.inspect(respJSONfr));
	strictEqual(respJSON.tokens[0].token, respJSONfr.tokens[0].token, "Voilà analyzed ok");
	respJSONfr = _analyze(_, "french", "voilà une proposition à indexer en français");
	debugTrace("Analyze phrase french (178):" + sys.inspect(respJSONfr));
	respJSON = _analyze(_, "default", "voila francais voilà français");
	debugTrace("Analyze search (179):" + sys.inspect(respJSON));
	respJSONfr = _analyze(_, "french", "voila francais voilà français");
	debugTrace("Analyze phrase french (181):" + sys.inspect(respJSONfr));
	respJSON = _analyze(_, "default", "cristi.nitescu@sage.com");
	debugTrace("Analyze email (184):" + sys.inspect(respJSON));
	strictEqual(respJSON.tokens[0].token, "cristi.nitescu@sage.com", "Email analyzed ok");
	// partial email
	respJSON = _analyze(_, "default", "cristi.nitescu@sage");
	debugTrace("Analyze email (184):" + sys.inspect(respJSON));
	strictEqual(respJSON.tokens[0].token, "cristi.nitescu@sag", "Partial email analyzed ok");
	// elision
	respJSON = _analyze(_, "default", "l'avion");
	debugTrace("Analyze elision (188):" + sys.inspect(respJSON));
	strictEqual(respJSON.tokens[0].token, "avion", "Elision analyzed ok");
	respJSON = _analyze(_, "default", "ASS001");
	debugTrace("Analyze search (170):" + sys.inspect(respJSON));
	strictEqual(respJSON.tokens.length, 1, "Word delimiter not split on numeric ok");

	// search tests
	options = {
		url: [elasticBaseUrl, indexName, "_refresh"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	resp = req.end().response(_).readAll(_);
	// search something not to be found default analyzer
	options = {
		url: [elasticBaseUrl, indexName, entityName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	var search = _makeQuery("not_existing_query");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	debugTrace("Search response (122):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 0, "No result ok");
	// search something in english default analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = _makeQuery("english phrase");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	debugTrace("Search response (145):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "English: One result ok");
	// search something in french, french analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = _makeQuery("voilà");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	debugTrace("Search response (170):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "French 1: One result ok");
	// search something in french, french analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = _makeQuery("voila francais voilà français");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	debugTrace("Search response (192):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "French 2 (all terms): One result ok");
	// search single term no accent in french, french analyzer
	options = {
		url: [elasticBaseUrl, indexName, "_search"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	search = _makeQuery("voila");
	req.write(_, JSON.stringify(search));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Search status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	debugTrace("Search response (192):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "French 2 (no accent): One result ok");
	//
	start();
});

asyncTest("email field tests", 15, function(_) {
	// test index exists
	var par = {
		url: elasticBaseUrl + "/" + indexName,
		method: 'HEAD'
	};
	var resp = streams.httpRequest(par).end().response(_);
	debugTrace("Index exists status (243):" + resp.statusCode);
	var reqUrl;
	if (resp.statusCode !== 404) {
		// delete index
		reqUrl = elasticBaseUrl + "/" + indexName;
		par = {
			url: reqUrl,
			method: 'DELETE'
		};
		resp = streams.httpRequest(par).end().response(_);
		var r = resp.readAll(_);
		debugTrace(r);
	}
	// create index
	reqUrl = elasticBaseUrl + "/" + indexName;
	par = {
		url: reqUrl,
		method: 'PUT'
	};
	var data = _makeSettings(useStdSettings, "fr-fr");
	var req = streams.httpRequest(par);
	req.write(_, JSON.stringify(data));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index create status Ok");
	var respJSON = JSON.parse(resp.readAll(_));
	debugTrace("Index create response (279):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index create result ok");
	// create a mapping
	var entityName = "test1";
	var mapping = {};
	mapping[entityName] = {
		properties: {
			my_email: {
				type: "string",
				analyzer: "keyword"
			}
		}
	};
	var options = {
		url: elasticBaseUrl + "/" + indexName + "/" + entityName + "/_mapping",
		method: 'PUT'
	};
	req = streams.httpRequest(options);
	req.write(_, JSON.stringify(mapping));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 200, "Index mapping update status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	debugTrace("Index mapping response (81):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index mapping update ok");
	// index some data
	var id1 = helpers.uuid.generate();
	var reqOptions = {
		url: [elasticBaseUrl, indexName, entityName, id1].join("/"),
		method: 'PUT'
	};
	req = streams.httpRequest(reqOptions);
	data = {
		my_email: "cristi.nitescu@sage.com"
	};
	req.write(_, JSON.stringify(data));
	resp = req.end().response(_);
	strictEqual(resp.statusCode, 201, "Index data status Ok");
	respJSON = JSON.parse(resp.readAll(_));
	debugTrace("Index data response (98):" + sys.inspect(respJSON));
	ok(respJSON.ok, "Index data result ok");
	// !!! LET INDEXING DO BEFORE SEARCH
	options = {
		url: [elasticBaseUrl, indexName, "_refresh"].join("/"),
		method: "POST"
	};
	req = streams.httpRequest(options);
	resp = req.end().response(_).readAll(_);
	// Simple search
	respJSON = _elasticPost(_, "_search", _makeQuery("cristi"), 200);
	debugTrace("Search response (339):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "Simple search ok");
	// This query shouldn't have any result
	respJSON = _elasticPost(_, "_search", _makeQuery("cristi.fake@sage.com"), 200);
	debugTrace("Search response (339):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 0, "No result ok");
	// explain
	respJSON = _elasticPost(_, id1 + "/_explain", _makeQuery("cristi.fake@sage.com"), 200);
	debugTrace("Explain response (315):" + sys.inspect(respJSON, null, 6));
	// This query should have a result
	respJSON = _elasticPost(_, "_search", _makeQuery("cristi.*@sage.com"), 200);
	debugTrace("Search response (359):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "Found email with wildcard ok");
	// exact search
	respJSON = _elasticPost(_, "_search", _makeQuery("cristi.nitescu@sage.com"), 200);
	debugTrace("Search response (352):" + sys.inspect(respJSON));
	strictEqual(respJSON.hits.total, 1, "Found email with exact search ok");

	start();
});


// test elastic search integration 
asyncTest("init database", 1, function(_) {
	//
	db = adminTestFixtures.initializeTestEnvironnement(_);
	ok(db != null, "Environnement initialized");
	//
	start();
});

function onlyInfo(diags) {
	return adminTestFixtures.onlyInfo(diags);
}

// test integration search 
asyncTest("import demo database", 11, function(_) {
	// import
	var diag = [];
	jsonImport.jsonImport(_, db, "syracuse-admin-demo.json", {
		$diagnoses: diag,
		tracer: tracer
	});
	debugTrace("import demo db diags (134): " + sys.inspect(diag));
	ok(onlyInfo(diag), "Demo database import ok");
	// check roles
	var role = db.fetchInstance(_, db.model.getEntity(_, "role"), {
		jsonWhere: {
			description: "Sales manager"
		}
	});
	strictEqual(role.description(_), "Sales manager", "role fetch ok");
	var count = db.count(_, db.model.getEntity(_, "role"), {});
	strictEqual(count, 8, "roles count ok");
	// check endpoints
	var ep = db.fetchInstance(_, db.model.getEntity(_, "endPoint"), {
		jsonWhere: {
			description: "Global CRM"
		}
	});
	strictEqual(ep.description(_), "Global CRM", "endpoint fetch ok");
	count = db.count(_, db.model.getEntity(_, "endPoint"), {});
	strictEqual(count, 5, "endpoint count ok");
	// check groups
	var gp = db.fetchInstance(_, db.model.getEntity(_, "group"), {
		jsonWhere: {
			description: "Sales managers"
		}
	});
	strictEqual(gp.description(_), "Sales managers", "group fetch ok");
	strictEqual(gp.endPoints(_).getLength(), 3, "Sales managers enpoint count ok");
	count = db.count(_, db.model.getEntity(_, "group"), {});
	strictEqual(count, 11, "group count ok");
	// check users
	var user = db.fetchInstance(_, db.model.getEntity(_, "user"), {
		jsonWhere: {
			login: "hedum"
		}
	});
	strictEqual(user.login(_), "hedum", "user fetch ok");
	strictEqual(user.groups(_).getLength(), 2, "hedum group count ok");
	count = db.count(_, db.model.getEntity(_, "user"), {});
	strictEqual(count, 11, "user count ok");

	start();
});


asyncTest("init indexHelper ", 1, function(_) {
	endPoint = adminTestFixtures.modifyCollaborationEndpoint("unit_test");


	h = new IndexHelper(endPoint, "en-us");
	ok(true, "initialized indexHelper");
	start();
});








asyncTest("test indexation syracuse administration", 2, function(_) {
	try {

		elasticIndex.tracer = tracer;
		elasticIndex.serverConfig = configTest;
		h.updateIndex(_, false, {
			locale: "en-us"
		});
		ok(true, "launch indexation ");
		// check existance of index 
		var req = {
			url: elasticBaseUrl + "/syracuse.collaboration.unit_test.en-us/_mapping",
			method: 'GET'
		};
		var resp = streams.httpRequest(req).end().response(_);
		strictEqual(resp.statusCode, 200, "index created ok");

	} catch (e) {
		ok(false, "launch indexation failed " + e.stack);

	}
	start();
});


asyncTest("test query syracuse administration 1", function(_) {
	recOptions.fileName = "test";
	var searchConfig = {
		editDistance: 2,
		prototype: false,
		recOptions: recOptions,
		keepInContext: true
	};

	// no data
	elasticQuery.tracer = tracer;
	elasticQuery.serverConfig = configTest;
	var result = {};
	var ctx = _makeContextQuerySearch("testing", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "search ok ");
	strictEqual(ctx.totalCount, 0, "total result ok for test : " + ctx.totalCount);
	strictEqual(result.result.$resources.length, 0, "search body response ok for test: " + result.result.$resources.length);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "testing", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);


	// basic
	ctx = _makeContextQuerySearch("admin", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "search ok ");
	strictEqual(ctx.totalCount !== 0, true, "total result ok for admin : " + ctx.totalCount);
	//debugTrace("-------result  admin "+JSON.stringify(result.result.$resources,null,2));
	strictEqual(result.result.$resources.length != 0, true, "search body response ok for admin : " + result.result.$resources.length);
	//check request to elastic search 
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "admin", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	//check highlight
	var hl = _extractHighlight(result.result.$resources);
	strictEqual(hl.length !== 0, true, "check highlight " + hl.length);

	// case sensitivity
	ctx = _makeContextQuerySearch("AdmIn", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "search ok ");
	strictEqual(ctx.totalCount !== 0, true, "total result ok for admin : " + ctx.totalCount);
	//debugTrace("-------result  admin "+JSON.stringify(result.result.$resources,null,2));
	strictEqual(result.result.$resources.length != 0, true, "search body response ok for admin : " + result.result.$resources.length);
	//check request to elastic search
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "admin", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	//check highlight


	// test for checking relevant result
	ctx = _makeContextQuerySearch("guest", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "search ok ");
	strictEqual(ctx.totalCount !== 0, true, "total result ok for guest : " + ctx.totalCount);
	strictEqual(result.result.$resources.length != 0, true, "search body response ok for guest : " + result.result.$resources.length);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "guest", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	hl = _extractHighlight(result.result.$resources);
	strictEqual(hl.length !== 0, true, "check highlight " + hl.length);


	// check list of word
	ctx = _makeContextQuerySearch("Sales manager", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "search ok ");
	strictEqual(ctx.totalCount !== 0, true, "total result ok for group admin : " + ctx.totalCount);
	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "sales manager", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	hl = _extractHighlight(result.result.$resources);
	strictEqual(hl.length !== 0, true, "check highlight " + hl.length);

	// forbidden character
	ctx = _makeContextQuerySearch("*setting", result);
	try {
		strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "*setting", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);

		elasticQuery.search(_, ctx, searchConfig);

		ok(false, "test character * ok ");
	} catch (e) {
		ok(true, "test character * ok ");
	}

	ctx = _makeContextQuerySearch("/setting", result);
	try {
		elasticQuery.search(_, ctx, searchConfig);
		ok(true, "test character / ok ");
	} catch (e) {
		ok(false, "test character / ok ");
	}

	// search on numeric
	ctx = _makeContextQuerySearch("10,01", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "10.01", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);

	// search on numeric that is store as integer in elatic
	ctx = _makeContextQuerySearch("17000", result);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "17000", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	strictEqual(ctx.totalCount !== 0, true, "total result ok  : " + ctx.totalCount);

	start();
});


asyncTest("test query syracuse administration with noHighlight parameter ", function(_) {
	recOptions.fileName = "test";
	var searchConfig = {
		editDistance: 2,
		prototype: false,
		recOptions: recOptions,
		keepInContext: true
	};

	// no data
	elasticQuery.tracer = tracer;
	elasticQuery.serverConfig = configTest;
	var result = {};

	// basic
	var ctx = _makeContextQuerySearch("admin", result);
	ctx.parameters.noHighlight = true;
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "search ok ");
	strictEqual(ctx.totalCount !== 0, true, "total result ok for admin : " + ctx.totalCount);
	//debugTrace("-------result  admin "+JSON.stringify(result.result.$resources,null,2));
	strictEqual(result.result.$resources.length != 0, true, "search body response ok for admin : " + result.result.$resources.length);
	//check request to elastic search
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "admin", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	//check highlight
	var hl = _extractHighlight(result.result.$resources);
	strictEqual(hl.length === 0, true, "check highlight " + hl.length);

	// case sensitivity



	// test for checking relevant result
	ctx = _makeContextQuerySearch("guest", result);
	ctx.parameters.noHighlight = true;

	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "search ok ");
	strictEqual(ctx.totalCount !== 0, true, "total result ok for guest : " + ctx.totalCount);
	strictEqual(result.result.$resources.length != 0, true, "search body response ok for guest : " + result.result.$resources.length);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "guest", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	hl = _extractHighlight(result.result.$resources);
	strictEqual(hl.length === 0, true, "check highlight " + hl.length);


	// check list of word
	ctx = _makeContextQuerySearch("Sales manager", result);
	ctx.parameters.noHighlight = true;

	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(result.status, 200, "search ok ");
	strictEqual(ctx.totalCount !== 0, true, "total result ok for group admin : " + ctx.totalCount);
	strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "sales manager", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	hl = _extractHighlight(result.result.$resources);
	strictEqual(hl.length === 0, true, "check highlight " + hl.length);


	start();
});



asyncTest("test date query syracuse administration", function(_) {
	recOptions.fileName = "test";
	var searchConfig = {
		editDistance: 2,
		prototype: false,
		recOptions: recOptions,
		keepInContext: true
	};

	elasticQuery.tracer = tracer;
	elasticQuery.serverConfig = configTest;
	var ctx,
		opts = {
			locale: "en-gb",
			shortDate: "dd/MM/yyyy"
		};
	// UK date format
	ctx = _makeContextQuerySearch("04/12/2014", opts);
	elasticQuery.search(_, ctx, searchConfig);
	debugTrace("Query: " + sys.inspect(ctx.searchRequest.query.filtered.query.multi_match));
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "2014-12-04", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);

	// Date that would fail in US format
	ctx = _makeContextQuerySearch("25/12/2014", opts);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "2014-12-25", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);

	opts = {
		locale: "fr-fr",
		shortDate: "dd-MM-yyyy"
	};
	// hyphen separated date format
	ctx = _makeContextQuerySearch("04-12-2014", opts);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "2014-12-04", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);

	// Date that would fail in US format
	ctx = _makeContextQuerySearch("25-12-2014", opts);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "2014-12-25", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);

	opts = {
		locale: "en-us",
		shortDate: "MM/dd/yyyy"
	};
	// US date format
	ctx = _makeContextQuerySearch("12/04/2014", opts);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "2014-12-04", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);

	// Date that would fail in UK format
	ctx = _makeContextQuerySearch("12/25/2014", opts);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "2014-12-25", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);

	// Two final tests using system date format
	ctx = _makeContextQuerySearch("2014-12-04", opts);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "2014-12-04", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);

	ctx = _makeContextQuerySearch("2014-12-25", opts);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "2014-12-25", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	start();


});

asyncTest("test query with boolean OR and AND and NOT on syracuse administration", function(_) {
	recOptions.fileName = "test";
	var searchConfig = {
		editDistance: 2,
		prototype: false,
		recOptions: recOptions,
		keepInContext: true
	};

	elasticQuery.tracer = tracer;
	elasticQuery.serverConfig = configTest;
	var ctx,
		opts = {
			locale: "en-gb",
			shortDate: "dd/MM/yyyy"
		};
	ctx = _makeContextQuerySearch("super && admin", opts);
	elasticQuery.search(_, ctx, searchConfig);
	debugTrace("Query: " + sys.inspect(ctx.searchRequest.query.filtered.query.multi_match));
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "super && admin", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	strictEqual(JSON.stringify(ctx.searchRequest.highlight), '{"fields":{"*":{"highlight_query":{"bool":{"must":[{"match":{"content":{"query":"super","type":"phrase_prefix"}}},{"match":{"content":{"query":"admin","type":"phrase_prefix"}}}]}}}}}', " highligh query ok");
	strictEqual(opts.status, 200, "search ok ");
	strictEqual(ctx.totalCount !== 0, true, "total result ok : " + ctx.totalCount);
	strictEqual(opts.result.$resources.length != 0, true, "search body response ok : " + opts.result.$resources.length);
	strictEqual(_extractHighlight(opts.result.$resources).length != 0, true, "search body highlighted response ok : " + _extractHighlight(opts.result.$resources).length);

	ctx = _makeContextQuerySearch("super AND admin", opts);
	elasticQuery.search(_, ctx, searchConfig);
	debugTrace("Query: " + sys.inspect(ctx.searchRequest.query.filtered.query.multi_match));
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "super AND admin", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	strictEqual(JSON.stringify(ctx.searchRequest.highlight), '{"fields":{"*":{"highlight_query":{"bool":{"must":[{"match":{"content":{"query":"super","type":"phrase_prefix"}}},{"match":{"content":{"query":"admin","type":"phrase_prefix"}}}]}}}}}', " highligh query ok");


	ctx = _makeContextQuerySearch("super || admin", opts);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "super || admin", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	strictEqual(JSON.stringify(ctx.searchRequest.highlight), '{"fields":{"*":{"highlight_query":{"bool":{"must":[{"match":{"content":{"query":"super","type":"phrase_prefix"}}},{"match":{"content":{"query":"admin","type":"phrase_prefix"}}}]}}}}}', " highligh query ok");
	strictEqual(opts.status, 200, "search ok ");
	strictEqual(ctx.totalCount !== 0, true, "total result ok : " + ctx.totalCount);
	strictEqual(opts.result.$resources.length != 0, true, "search body response ok : " + opts.result.$resources.length);
	strictEqual(_extractHighlight(opts.result.$resources).length != 0, true, "search body highlighted response ok : " + _extractHighlight(opts.result.$resources).length);

	ctx = _makeContextQuerySearch("super OR admin", opts);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "super OR admin", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	strictEqual(JSON.stringify(ctx.searchRequest.highlight), '{"fields":{"*":{"highlight_query":{"bool":{"must":[{"match":{"content":{"query":"super","type":"phrase_prefix"}}},{"match":{"content":{"query":"admin","type":"phrase_prefix"}}}]}}}}}', " highligh query ok");



	ctx = _makeContextQuerySearch("admin", opts);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "admin", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	strictEqual(JSON.stringify(ctx.searchRequest.highlight), '{"fields":{"*":{}}}', " highligh query ok");
	strictEqual(opts.status, 200, "search ok ");
	strictEqual(ctx.totalCount !== 0, true, "total result ok : " + ctx.totalCount);
	strictEqual(opts.result.$resources.length != 0, true, "search body response ok : " + opts.result.$resources.length);
	strictEqual(_extractHighlight(opts.result.$resources).length != 0, true, "search body highlighted response ok : " + _extractHighlight(opts.result.$resources).length);

	ctx = _makeContextQuerySearch("(super AND admin) OR super AND admin", opts);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(ctx.searchRequest.query.filtered.query.multi_match.query, "(super AND admin) OR super AND admin", "check query string ok : " + ctx.searchRequest.query.filtered.query.multi_match.query);
	strictEqual(JSON.stringify(ctx.searchRequest.highlight), '{"fields":{"*":{"highlight_query":{"bool":{"must":[{"match":{"content":{"query":"super","type":"phrase_prefix"}}},{"match":{"content":{"query":"admin","type":"phrase_prefix"}}}]}}}}}', " highligh query ok");

	start();


});

asyncTest("test query syracuse administration 2", 21, function(_) {
	function verifySearchResult(type, resource) {
		if (resource.$representation === 'user') {
			strictEqual(resource.$searchItemTitle, "mr  <em>Guest</em>", "resource that match the most ok : return " + resource.$searchItemTitle);
		} else if (resource.$representation === 'role') {
			strictEqual(resource.$searchItemTitle, "<em>Guest</em>", "resource that match the most ok : return " + resource.$searchItemTitle);
		} else if (resource.$representation === 'group') {
			strictEqual(resource.$searchItemTitle, "<em>Guests</em>", "resource that match the most ok : return " + resource.$searchItemTitle);
		} else if (resource.$representation === 'team') {
			strictEqual(resource.members[0], "<em>guest</em>", "resource that match the most ok : return " + resource.members);
		} else if (resource.$representation === 'endPoint') {
			strictEqual(resource.groups[0], "<em>Guests</em>", "resource that match the most ok : return " + resource.groups[0]);
		} else {
			strictEqual(resource.code, "<em>GUEST</em>", "resource that match the most ok : return " + resource.code);
		}

		debugTrace("================== Query Type : " + type + "=======================");
		debugTrace("Search Response :" + JSON.stringify(resource));
	}
	var searchConfig = {
		editDistance: 2,
		prototype: false,
		keepInContext: true
	};

	elasticQuery.tracer = tracer;
	elasticQuery.serverConfig = configTest;
	var opts = {};
	var ctx = _makeContextQuerySearch("gues", opts);

	elasticQuery.search(_, ctx, searchConfig);
	// check first result is the right one 
	strictEqual(opts.status, 200, "startWith match search completed ok ");
	strictEqual(opts.result.$resources.length != 0, true, "search body response ok : " + opts.result.$resources.length);
	var res = '{"filtered":{"query":{"multi_match":{"fields":["_all"],"query":"gues","type":"phrase_prefix"}}}}';
	strictEqual(res, JSON.stringify(ctx.searchRequest.query), "request ok ");
	verifySearchResult("startsWith", opts.result.$resources[0]);

	// Exact search may be redundant
	opts.qt = "exact";
	ctx = _makeContextQuerySearch("guest", opts);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(opts.status, 200, "Fuzzy search exact completed ok");
	strictEqual(opts.result.$resources.length != 0, true, "search body response ok : " + opts.result.$resources.length);
	verifySearchResult("exact", opts.result.$resources[0]);

	// test fuzzy search with spelling - edit distance 1
	opts.qt = "fuzzy";
	searchConfig.searchType = "fuzzy";
	searchConfig.minSimilarity = 0.5;
	ctx = _makeContextQuerySearch("guet", opts);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(opts.status, 200, "Fuzzy search minSimilarity=0.5  completed ok");
	res = '{"filtered":{"query":{"bool":{"should":[{"custom_boost_factor":{"query":{"query_string":{"query":"guet","boost":100,"analyze_wildcard":true,"allow_leading_wildcard":false}},"boost_factor":2.5}},{"constant_score":{"query":{"fuzzy_like_this":{"like_text":"guet","max_query_terms":20,"min_similarity":0.5,"ignore_tf":true,"boost":1}},"boost":1}}]}}}}';
	strictEqual(opts.result.$resources.length != 0, true, "Search body response ok : " + opts.result.$resources.length);
	verifySearchResult("Fuzzy (1)", opts.result.$resources[0]);

	// test fuzzy search with spelling - edit distance is 2
	searchConfig.minSimilarity = 0.5;
	searchConfig.searchType = "fuzzy";

	ctx = _makeContextQuerySearch("guets", opts);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(opts.status, 200, "Fuzzy search minSimilarity=1 completed ok");
	res = '{"filtered":{"query":{"bool":{"should":[{"custom_boost_factor":{"query":{"query_string":{"query":"guets","boost":100,"analyze_wildcard":true,"allow_leading_wildcard":false}},"boost_factor":2.5}},{"constant_score":{"query":{"fuzzy_like_this":{"like_text":"guets","max_query_terms":20,"min_similarity":0.5,"ignore_tf":true,"boost":1}},"boost":1}}]}}}}';
	strictEqual(res, JSON.stringify(ctx.searchRequest.query), "request ok ");
	strictEqual(opts.result.$resources.length != 0, true, "search body response ok : " + opts.result.$resources.length);
	verifySearchResult("Fuzzy (2)", opts.result.$resources[0]);

	// test fuzzy search with spelling - edit distance is 3
	// This should fail as the edit distance > 2
	searchConfig.minSimilarity = 0.9;

	ctx = _makeContextQuerySearch("geutss", opts);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(opts.status, 200, "Fuzzy search minSimilarity=3 completed ok");
	strictEqual(opts.result.$resources.length == 0, true, "search body response empty : " + opts.result.$resources.length);

	debugTrace("================= Expected empty Response ===================");
	debugTrace("Search Response :" + JSON.stringify(opts.result.$resources[0]));

	// test fuzzy search with spelling - edit distance is 3
	// Increasing the edit distance should cause this test to pass
	// test fuzzy search with spelling - edit distance is 2
	// Reducing the edit distance should cause this test to fail
	searchConfig.minSimilarity = 0.7;
	ctx = _makeContextQuerySearch("geust", opts);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(opts.status, 200, "Search completed ok ");
	strictEqual(opts.result.$resources.length == 0, true, "search body response empty : " + opts.result.$resources.length);

	debugTrace("================= Expected empty Response ===================");
	debugTrace("Search Response :" + JSON.stringify(opts.result.$resources[0]));

	// Closer match should successfully 
	// test fuzzy search with spelling - edit distance 1
	searchConfig.minSimilarity = 0.7;
	ctx = _makeContextQuerySearch("gueft", opts);
	elasticQuery.search(_, ctx, searchConfig);
	strictEqual(opts.status, 200, "Search completed ok ");

	strictEqual(opts.result.$resources.length != 0, true, "search body response ok : " + opts.result.$resources.length);
	verifySearchResult("Fuzzy (3)", opts.result.$resources[0]);

	start();
});

asyncTest("test creation elastic search filter", function(_) {
	var search = {
		query: {
			filtered: {}
		}
	};
	// test add filter
	elasticQuery.addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
	var res = '{"query":{"filtered":{"filter":{"and":[{"and":[{"or":[{"query":{"field":{"$uuid":"uuid-1"}}},{"query":{"field":{"test.ap":"test"}}}]},{"query":{"field":{"test.toto":"23"}}}]}]}}}}';
	strictEqual(res, JSON.stringify(search), "generate simple filter ok");

	search = {
		query: {
			filtered: {}
		}
	};
	elasticQuery.addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
	res = '{"query":{"filtered":{"filter":{"and":[{"and":[{"or":[{"query":{"field":{"$uuid":"uuid-1"}}},{"query":{"field":{"test.ap":"test"}}}]},{"query":{"field":{"test.toto":"23"}}}]}]}}}}';
	strictEqual(res, JSON.stringify(search), "generate complexe filter ok");

	search = {
		query: {
			filtered: {}
		}
	};
	elasticQuery.addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
	res = '{"query":{"filtered":{"filter":{"and":[{"and":[{"or":[{"query":{"field":{"$uuid":"uuid-1"}}},{"query":{"field":{"test.ap":"test"}}}]},{"query":{"field":{"test.toto":"23"}}}]}]}}}}';
	strictEqual(res, JSON.stringify(search), "generate filter ok");

	elasticQuery.addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
	debugTrace(JSON.stringify(search));
	//res = '{"query":{"filtered":{"filter":{"and":[{"and":[{"or":[{"query":{"field":{"$uuid":"uuid-1"}}},{"query":{"field":{"test.ap":"test"}}}]},{"query":{"field":{"test.toto":"23"}}}]}]}}}}';
	res = '{"query":{"filtered":{"filter":{"and":[{"and":[{"or":[{"query":{"field":{"$uuid":"uuid-1"}}},{"query":{"field":{"test.ap":"test"}}}]},{"query":{"field":{"test.toto":"23"}}}]},{"and":[{"or":[{"query":{"field":{"$uuid":"uuid-1"}}},{"query":{"field":{"test.ap":"test"}}}]},{"query":{"field":{"test.toto":"23"}}}]}]}}}}';
	strictEqual(res, JSON.stringify(search), "add filter ok");

	debugTrace("==========================================");
	debugTrace("Query :" + JSON.stringify(search));
	//elasticQuery._addRightFilterCondition(_,"$uuid eq \"uuid-1\"",{},{},{});
	start();
});


asyncTest("test creation elastic search filter", function(_) {
	var search = {
		query: {
			filtered: {}
		}
	};
	// test add filter
	elasticQuery.addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
	var res = '{"query":{"filtered":{"filter":{"and":[{"and":[{"or":[{"query":{"field":{"$uuid":"uuid-1"}}},{"query":{"field":{"test.ap":"test"}}}]},{"query":{"field":{"test.toto":"23"}}}]}]}}}}';
	strictEqual(res, JSON.stringify(search), "generate simple filter ok");

	search = {
		query: {
			filtered: {}
		}
	};
	elasticQuery.addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
	res = '{"query":{"filtered":{"filter":{"and":[{"and":[{"or":[{"query":{"field":{"$uuid":"uuid-1"}}},{"query":{"field":{"test.ap":"test"}}}]},{"query":{"field":{"test.toto":"23"}}}]}]}}}}';
	strictEqual(res, JSON.stringify(search), "generate complexe filter ok");

	search = {
		query: {
			filtered: {}
		}
	};
	elasticQuery.addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
	res = '{"query":{"filtered":{"filter":{"and":[{"and":[{"or":[{"query":{"field":{"$uuid":"uuid-1"}}},{"query":{"field":{"test.ap":"test"}}}]},{"query":{"field":{"test.toto":"23"}}}]}]}}}}';
	strictEqual(res, JSON.stringify(search), "generate filter ok");

	elasticQuery.addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
	debugTrace(JSON.stringify(search));
	//res = '{"query":{"filtered":{"filter":{"and":[{"and":[{"or":[{"query":{"field":{"$uuid":"uuid-1"}}},{"query":{"field":{"test.ap":"test"}}}]},{"query":{"field":{"test.toto":"23"}}}]}]}}}}';
	res = '{"query":{"filtered":{"filter":{"and":[{"and":[{"or":[{"query":{"field":{"$uuid":"uuid-1"}}},{"query":{"field":{"test.ap":"test"}}}]},{"query":{"field":{"test.toto":"23"}}}]},{"and":[{"or":[{"query":{"field":{"$uuid":"uuid-1"}}},{"query":{"field":{"test.ap":"test"}}}]},{"query":{"field":{"test.toto":"23"}}}]}]}}}}';
	strictEqual(res, JSON.stringify(search), "add filter ok");

	debugTrace("==========================================");
	debugTrace("Query :" + JSON.stringify(search));
	//elasticQuery._addRightFilterCondition(_,"$uuid eq \"uuid-1\"",{},{},{});
	start();
});

asyncTest("test delete index  syracuse administration", 3, function(_) {
	try {
		elasticIndex.tracer = tracer;
		elasticIndex.serverConfig = configTest;
		var req = {
			url: elasticBaseUrl + "/syracuse.collaboration.unit_test.en-us/_mapping",
			method: 'GET'
		};
		var resp = streams.httpRequest(req).end().response(_);
		strictEqual(resp.statusCode, 200, "index  exists ok");
		// check existance of index 
		var diag = [];
		elasticIndex.deleteEndpointIndex(_, endPoint, "en-us", diag);
		ok(true, "launch delete indexation  ");
		req = {
			url: elasticBaseUrl + "/syracuse.collaboration.unit_test.en-us/_mapping",
			method: 'GET'
		};
		resp = streams.httpRequest(req).end().response(_);
		strictEqual(resp.statusCode, 404, "index not exists  ok");
	} catch (e) {
		ok(false, " delete indexation failed " + e.stack);
	}
	start();
});

asyncTest("stop  tests", 0, function(_) {
	doStop = true;
	start();
});