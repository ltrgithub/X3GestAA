"use strict";
/* jshint -W079 */
/* jshint unused: false */
/* global QUnit: false, it: false, strictEqual: false, ok: false, start: false, stop: false */

/*global QUnit, start, ok*/
var helpers = require('@sage/syracuse-core').helpers;
var ez = require("ez-streams");
var sys = require("util");
var config = require('config'); // must be first syracuse require
var port = (config.unit_test && config.unit_test.serverPort) || 3004;
var dataModel = require("@sage/syracuse-lib/src/orm/dataModel");
var elasticQuery = require('../../lib/elasticQuery');
var adminHelper = require("@sage/syracuse-lib/src/collaboration/helpers").AdminHelper;

var elasticIndex = require('../../lib/elasticIndex');
var IndexHelper = require('../../lib/elasticIndex').IndexHelper;
var jsonImport = require("@sage/syracuse-lib/src/import/jsonImport");
var apis = require('@sage/syracuse-core').apis;
var testAdmin = apis.get('test-admin');
var mongodb = require('mongodb');
var testData = require('@sage/syracuse-lib/test/sdata/fixtures/testDB');
var testEndPoint = testData.endpoint;
var searchEngine = require('../../lib/elasticSearch');
var recOptions = {
	recMode: config.qunit && config.qunit.online ? "REC" : "PLAY",
	path: "node_modules/syracuse-search/test/server/"
};

//force basic auth
config.session = config.session || {};
config.session.auth = "basic";
//no integration server
config.integrationServer = null;
var db;
var endPoint;
testEndPoint.datasets = {
	test: {
		driver: "mongodb",
		database: "test",
		hostname: "localhost",
		port: config.collaboration.port || 27017
	}
};

config.sdata.endpoints.push(testEndPoint);


var indexHelper = elasticIndex.IndexHelper;
var hostname = (config.searchEngine && config.searchEngine.hostname) || "localhost";

var indexName = "unittest";
var entityName = "test1";



var tracer = null; //console.log;
config.qunit = config.qunit | {}
var searchConfig = {
	1: { // version 1.5 or upper
		port: config.qunit.elasticSearch && config.qunit.elasticSearch["1"] && config.qunit.elasticSearch["1"].port || 9200,
		hostname: config.qunit.elasticSearch && config.qunit.elasticSearch["1"] && config.qunit.elasticSearch["1"].hostname || "localhost"

	},
	2: { // version 2 or upper
		port: config.qunit.elasticSearch && config.qunit.elasticSearch["2"] && config.qunit.elasticSearch["2"].port || 9201,
		hostname: config.qunit.elasticSearch && config.qunit.elasticSearch["2"] && config.qunit.elasticSearch["2"].hostname || "localhost"

	}
}

import {
	assert
} from 'chai';
Object.keys(assert).forEach(key => {
	if (key !== 'isNaN') global[key] = assert[key];
});

describe(module.id, () => {

	// First set of tests - checked and running.
	// make the test for each version of elastic search supported 1.5.1 and 2.4.1

	// test elastic search integration
	it('init database', function(_) {
		//
		db = testAdmin.initializeTestEnvironnement(_);
		ok(db != null, "Environnement initialized");
		//
	});

	function debugTrace(mesg) {
		if (tracer) {
			tracer(mesg);
		}
	}

	function onlyInfo(diags) {
		return testAdmin.onlyInfo(diags);
	}

	// test integration search
	it('import demo database', function(_) {
		// import
		var diag = [];
		jsonImport.jsonImport(_, db, "syracuse-admin-demo.json", {
			$diagnoses: diag
		});
		debugTrace("import demo db diags (134): " + sys.inspect(diag));
		ok(onlyInfo(diag), "Demo database import ok");
		// check roles
		var role = db.fetchInstance(_, db.model.getEntity(_, "role"), {
			jsonWhere: {
				description: "Sales manager"
			}
		});
		strictEqual(role.description(_), "Sales manager", "role fetch ok");
		var count = db.count(_, db.model.getEntity(_, "role"), {});
		strictEqual(count, 9, "roles count ok");
		// check endpoints
		var ep = db.fetchInstance(_, db.model.getEntity(_, "endPoint"), {
			jsonWhere: {
				description: "Global CRM"
			}
		});
		strictEqual(ep.description(_), "Global CRM", "endpoint fetch ok");
		count = db.count(_, db.model.getEntity(_, "endPoint"), {});
		ok(count > 0, "endpoint count ok");
		// check groups
		var gp = db.fetchInstance(_, db.model.getEntity(_, "group"), {
			jsonWhere: {
				description: "Sales managers"
			}
		});
		strictEqual(gp.description(_), "Sales managers", "group fetch ok");
		strictEqual(gp.endPoints(_).getLength(), 3, "Sales managers enpoint count ok");
		count = db.count(_, db.model.getEntity(_, "group"), {});
		strictEqual(count, 12, "group count ok");
		// check users
		var user = db.fetchInstance(_, db.model.getEntity(_, "user"), {
			jsonWhere: {
				login: "hedum"
			}
		});
		strictEqual(user.login(_), "hedum", "user fetch ok");
		strictEqual(user.groups(_).getLength(), 2, "hedum group count ok");
		count = db.count(_, db.model.getEntity(_, "user"), {});
		strictEqual(count, 12, "user count ok");

	});

	// TODO add unit test for 2.4
	[1].forEach(function(item) {

		var h;

		function getQueryValue(ctx) {
			if (item == 1) {
				return ctx.searchRequest.query.filtered.query.multi_match.query;
			} else {
				console.log(JSON.stringify(ctx, null, 2));
				return ctx.searchRequest.query.bool.must.multi_match.query
			}
		}

		function getQueryStringValue(ctx) {
			if (item == 1) {
				return ctx.searchRequest.query.filtered.query.query_string.query;
			} else {
				return ctx.searchRequest.query.query_string.query;
			}
		}

		function _extractHighlight(resources) {
			var highlights = [];

			function isHighlight(item, prop, key) {
				if (prop.$isHighlight === "undefined" && Object.keys(prop).length > 0) {

					Object.keys(prop).map(function(k) {
						isHighlight(item, prop[k], key + "." + k);
					});
				}
				if (prop.$isHighlight) {
					highlights.push({
						$properties: prop,
						$key: item.$representation + "." + key
					});
				}
			}
			resources.map(function(item) {

				Object.keys(item.$properties).map(function(property) {
					if (item.$properties[property])
						isHighlight(item, item.$properties[property], property);
				});
			});
			return highlights;
		}

		function _makeContextQuerySearch(search, opt) {
			var ctx = {
				dataset: "syracuse",
				parameters: {
					q: search,
					count: 20,
					startIndex: 1
				},
				reply: function(_, statusCode, mess) {
					opt.status = statusCode;
					opt.result = mess;
				},
				replySearchResults: function(_, statusCode, result) {
					opt.status = statusCode;
					opt.result = result;
				},
				getUserProfile: function(_) {
					return {
						selectedLocale: function(_) {
							return {
								code: opt.locale || "en-us",
								enabled: true,
								shortDate: function(_) {
									return opt.shortDate || "dd/mm/yyyy";
								}
							};
						},
						selectedEndpoint: function(_) {
							return endPoint;
						},
						getAccessRightAuthorizations: function(_, endp) {
							return null;
						},
						user: function(_) {
							return {
								login: function(_) {
									return "guest";
								},
								getEndpointLogin: function(_, uuid) {
									return "guest_edl";
								}
							};
						}
					};
				}
			};
			if (opt.searchEntityName) {
				ctx.searchEntityName = "queryResult";
			} else {
				ctx.representation = {
					entity: "queryResult"
				};
			}
			if (opt.searchType) {
				ctx.parameters.searchType = opt.searchType;
			}
			return ctx;
		}

		function _makeQuery(q) {
			return {
				query: {
					filtered: {
						query: {
							query_string: {
								query: q + "*",
								analyze_wildcard: true,
								default_operator: "AND"
							}
						}
					}
				}
			};
		}
		var useStdSettings = true;

		function _makeSettings(std, idxLoc) {
			return std ? elasticIndex.getIndexSettings(idxLoc) : {
				"settings": {
					"index": {
						"analysis": {
							"filter": {
								"my_stemmer": {
									"type": "stemmer",
									"name": "french"
								},
								"my_stop": {
									"type": "stop",
									"stopwords": "_french_"
								},
								"delimiter": {
									"type": "word_delimiter",
									"type_table": ["@ => ALPHANUM", ". => ALPHANUM"]
								}
							},
							"analyzer": {
								"default": {
									"type": "custom",
									//							"tokenizer": "uax_url_email",
									"tokenizer": "whitespace",
									"split_on_numerics": false,
									"filter": ["delimiter", "asciifolding", "lowercase", "elision", "my_stemmer", "my_stop"]
								},
								"search": {
									"type": "custom",
									//							"tokenizer": "uax_url_email",
									"tokenizer": "whitespace",
									"filter": ["delimiter", "asciifolding", "lowercase", "elision", "my_stemmer", "my_stop"]
								},
								"dave": {
									"type": "custom",
									//							"tokenizer": "uax_url_email",
									"tokenizer": "keyword",
									"filter": ["delimiter", "asciifolding", "lowercase", "elision", "my_stemmer", "my_stop"]
								}
							}
						}
					}
				}
			};
		}

		function _elasticPost(_, segment, data, status) {
			var options = {
				url: [elasticBaseUrl, indexName, entityName, segment].join("/"),
				method: "POST"
			};
			var req = ez.devices.http.client(options);
			req.write(_, JSON.stringify(data));
			var resp = req.end().response(_);
			strictEqual(resp.statusCode, status, "POST Status Ok");
			return JSON.parse(resp.readAll(_));
		}

		function _analyze(_, analyzer, q) {
			var options = {
				url: [elasticBaseUrl, indexName, "_analyze"].join("/") + "?analyzer=" + analyzer + "&text=" + q + "&pretty=true",
				method: "GET"
			};
			var req = ez.devices.http.client(options);
			var resp = req.end().response(_);
			return JSON.parse(resp.readAll(_));
		}
		//


		var port = searchConfig[item].port || 9200;
		var hostname = searchConfig[item].hostname || "localhost";
		var elasticBaseUrl = "http://" + hostname + ":" + port;
		var configTest = {};
		configTest.hostname = hostname;
		configTest.port = port;
		configTest.baseUrl = elasticBaseUrl;

		// check if elastic seaerch is started and disable the test if it's not
		var noElastic = true;
		var par = {
			url: elasticBaseUrl,
			method: 'GET'
		};
		ez.devices.http.client(par).end().response(function(err) {
			if (!err) {
				it('index french tests - version elastic ' + item, function(_) {
					// test index exists
					var par = {
						url: elasticBaseUrl + "/" + indexName,
						method: 'HEAD'
					};
					var resp = ez.devices.http.client(par).end().response(_);
					debugTrace("Index exists status (35):" + resp.statusCode);
					var reqUrl;
					if (resp.statusCode !== 404) {
						// delete index
						reqUrl = elasticBaseUrl + "/" + indexName;
						par = {
							url: reqUrl,
							method: 'DELETE'
						};
						resp = ez.devices.http.client(par).end().response(_);
						var r = resp.readAll(_);
						debugTrace(r);
					}
					// create index
					reqUrl = elasticBaseUrl + "/" + indexName;
					par = {
						url: reqUrl,
						method: 'PUT'
					};
					var data = _makeSettings(useStdSettings, "fr-fr");
					var req = ez.devices.http.client(par);
					req.write(_, JSON.stringify(data));
					resp = req.end().response(_);
					strictEqual(resp.statusCode, 200, "Index create status Ok");
					var respJSON = JSON.parse(resp.readAll(_));
					debugTrace("Index create response (53):" + sys.inspect(respJSON));
					ok(respJSON.ok || respJSON.acknowledged, "Index create result ok");
					// create a mapping
					var mapping = {};
					mapping[entityName] = {
						properties: {}
					};
					var options = {
						url: elasticBaseUrl + "/" + indexName + "/" + entityName + "/_mapping",
						method: 'PUT'
					};
					req = ez.devices.http.client(options);
					req.write(_, JSON.stringify(mapping));
					resp = req.end().response(_);
					strictEqual(resp.statusCode, 200, "Index mapping update status Ok");
					respJSON = JSON.parse(resp.readAll(_));
					debugTrace("Index mapping response (81):" + sys.inspect(respJSON));
					ok(respJSON.ok || respJSON.acknowledged, "Index mapping update ok");
					// index some data
					var id1 = helpers.uuid.generate();
					var reqOptions = {
						url: [elasticBaseUrl, indexName, entityName, id1].join("/"),
						method: 'PUT'
					};
					req = ez.devices.http.client(reqOptions);
					data = {
						stringInEnglish: "here's some english phrase to index",
						stringInFrench: "voilà une proposition à indexer en français"
					};
					req.write(_, JSON.stringify(data));
					resp = req.end().response(_);
					strictEqual(resp.statusCode, 201, "Index data status Ok");
					respJSON = JSON.parse(resp.readAll(_));
					debugTrace("Index data response (98):" + sys.inspect(respJSON));
					ok(respJSON.ok || respJSON.created, "Index data result ok");

					// analyzer tests
					respJSON = _analyze(_, "default", "english phrase*");
					debugTrace("Analyze search (170):" + sys.inspect(respJSON));
					strictEqual(respJSON.tokens[1].token, "phras", "Phrase = phras ok");
					respJSON = _analyze(_, "default", "voilà*");
					debugTrace("Analyze search (173):" + sys.inspect(respJSON));
					var respJSONfr = _analyze(_, "french", "voilà*");
					debugTrace("Analyze search (175):" + sys.inspect(respJSONfr));
					strictEqual(respJSON.tokens[0].token, respJSONfr.tokens[0].token, "Voilà analyzed ok");
					respJSONfr = _analyze(_, "french", "voilà une proposition à indexer en français");
					debugTrace("Analyze phrase french (178):" + sys.inspect(respJSONfr));
					respJSON = _analyze(_, "default", "voila francais voilà français");
					debugTrace("Analyze search (179):" + sys.inspect(respJSON));
					respJSONfr = _analyze(_, "french", "voila francais voilà français");
					debugTrace("Analyze phrase french (181):" + sys.inspect(respJSONfr));
					respJSON = _analyze(_, "default", "cristi.nitescu@sage.com");
					debugTrace("Analyze email (184):" + sys.inspect(respJSON));
					strictEqual(respJSON.tokens[0].token, "cristi.nitescu@sage.com", "Email analyzed ok");
					// partial email
					respJSON = _analyze(_, "default", "cristi.nitescu@sag");
					debugTrace("Analyze email (184):" + sys.inspect(respJSON));
					strictEqual(respJSON.tokens[0].token, "cristi.nitescu@sag", "Partial email analyzed ok");
					// elision
					respJSON = _analyze(_, "default", "l'avion");
					debugTrace("Analyze elision (188):" + sys.inspect(respJSON));
					strictEqual(respJSON.tokens[0].token, "avion", "Elision analyzed ok");
					respJSON = _analyze(_, "default", "ASS001");
					debugTrace("Analyze search (170):" + sys.inspect(respJSON));
					strictEqual(respJSON.tokens.length, 1, "Word delimiter not split on numeric ok");

					// search tests
					options = {
						url: [elasticBaseUrl, indexName, "_refresh"].join("/"),
						method: "POST"
					};
					req = ez.devices.http.client(options);
					resp = req.end().response(_).readAll(_);
					// search something not to be found default analyzer
					options = {
						url: [elasticBaseUrl, indexName, entityName, "_search"].join("/"),
						method: "POST"
					};
					req = ez.devices.http.client(options);
					var search = _makeQuery("not_existing_query");
					req.write(_, JSON.stringify(search));
					resp = req.end().response(_);
					strictEqual(resp.statusCode, 200, "Search status Ok");
					respJSON = JSON.parse(resp.readAll(_));
					debugTrace("Search response (122):" + sys.inspect(respJSON));
					strictEqual(respJSON.hits.total, 0, "No result ok");
					// search something in english default analyzer
					options = {
						url: [elasticBaseUrl, indexName, "_search"].join("/"),
						method: "POST"
					};
					req = ez.devices.http.client(options);
					search = _makeQuery("english phrase");
					req.write(_, JSON.stringify(search));
					resp = req.end().response(_);
					strictEqual(resp.statusCode, 200, "Search status Ok");
					respJSON = JSON.parse(resp.readAll(_));
					debugTrace("Search response (145):" + sys.inspect(respJSON));
					strictEqual(respJSON.hits.total, 1, "English: One result ok");
					// search something in french, french analyzer
					options = {
						url: [elasticBaseUrl, indexName, "_search"].join("/"),
						method: "POST"
					};
					req = ez.devices.http.client(options);
					search = _makeQuery("voilà");
					req.write(_, JSON.stringify(search));
					resp = req.end().response(_);
					strictEqual(resp.statusCode, 200, "Search status Ok");
					respJSON = JSON.parse(resp.readAll(_));
					debugTrace("Search response (170):" + sys.inspect(respJSON));
					strictEqual(respJSON.hits.total, 1, "French 1: One result ok");
					// search something in french, french analyzer
					options = {
						url: [elasticBaseUrl, indexName, "_search"].join("/"),
						method: "POST"
					};
					req = ez.devices.http.client(options);
					search = _makeQuery("voila francais voilà français");
					req.write(_, JSON.stringify(search));
					resp = req.end().response(_);
					strictEqual(resp.statusCode, 200, "Search status Ok");
					respJSON = JSON.parse(resp.readAll(_));
					debugTrace("Search response (192):" + sys.inspect(respJSON));
					strictEqual(respJSON.hits.total, 1, "French 2 (all terms): One result ok");
					// search single term no accent in french, french analyzer
					options = {
						url: [elasticBaseUrl, indexName, "_search"].join("/"),
						method: "POST"
					};
					req = ez.devices.http.client(options);
					search = _makeQuery("voila");
					req.write(_, JSON.stringify(search));
					resp = req.end().response(_);
					strictEqual(resp.statusCode, 200, "Search status Ok");
					respJSON = JSON.parse(resp.readAll(_));
					debugTrace("Search response (192):" + sys.inspect(respJSON));
					strictEqual(respJSON.hits.total, 1, "French 2 (no accent): One result ok");
					//
				});

				it('email field tests- version elastic ' + item, function(_) {
					// test index exists
					var par = {
						url: elasticBaseUrl + "/" + indexName,
						method: 'HEAD'
					};
					var resp = ez.devices.http.client(par).end().response(_);
					debugTrace("Index exists status (243):" + resp.statusCode);
					var reqUrl;
					if (resp.statusCode !== 404) {
						// delete index
						reqUrl = elasticBaseUrl + "/" + indexName;
						par = {
							url: reqUrl,
							method: 'DELETE'
						};
						resp = ez.devices.http.client(par).end().response(_);
						var r = resp.readAll(_);
						debugTrace(r);
					}
					// create index
					reqUrl = elasticBaseUrl + "/" + indexName;
					par = {
						url: reqUrl,
						method: 'PUT'
					};
					var data = _makeSettings(useStdSettings, "fr-fr");
					var req = ez.devices.http.client(par);
					req.write(_, JSON.stringify(data));
					resp = req.end().response(_);
					strictEqual(resp.statusCode, 200, "Index create status Ok");
					var respJSON = JSON.parse(resp.readAll(_));
					debugTrace("Index create response (279):" + sys.inspect(respJSON));
					ok(respJSON.ok || respJSON.acknowledged, "Index create result ok");
					// create a mapping
					var entityName = "test1";
					var mapping = {};
					mapping[entityName] = {
						properties: {
							my_email: {
								type: "string",
								analyzer: "keyword"
							}
						}
					};
					var options = {
						url: elasticBaseUrl + "/" + indexName + "/" + entityName + "/_mapping",
						method: 'PUT'
					};
					req = ez.devices.http.client(options);
					req.write(_, JSON.stringify(mapping));
					resp = req.end().response(_);
					strictEqual(resp.statusCode, 200, "Index mapping update status Ok");
					respJSON = JSON.parse(resp.readAll(_));
					debugTrace("Index mapping response (81):" + sys.inspect(respJSON));
					ok(respJSON.ok || respJSON.acknowledged, "Index mapping update ok");
					// index some data
					var id1 = helpers.uuid.generate();
					var reqOptions = {
						url: [elasticBaseUrl, indexName, entityName, id1].join("/"),
						method: 'PUT'
					};
					req = ez.devices.http.client(reqOptions);
					data = {
						my_email: "cristi.nitescu@sage.com"
					};
					req.write(_, JSON.stringify(data));
					resp = req.end().response(_);
					strictEqual(resp.statusCode, 201, "Index data status Ok");
					respJSON = JSON.parse(resp.readAll(_));
					debugTrace("Index data response (98):" + sys.inspect(respJSON));
					ok(respJSON.ok || respJSON.created, "Index data result ok");
					// !!! LET INDEXING DO BEFORE SEARCH
					options = {
						url: [elasticBaseUrl, indexName, "_refresh"].join("/"),
						method: "POST"
					};
					req = ez.devices.http.client(options);
					resp = req.end().response(_).readAll(_);
					// Simple search
					respJSON = _elasticPost(_, "_search", _makeQuery("cristi"), 200);
					debugTrace("Search response (339):" + sys.inspect(respJSON));
					strictEqual(respJSON.hits.total, 1, "Simple search ok");
					// This query shouldn't have any result
					respJSON = _elasticPost(_, "_search", _makeQuery("cristi.fake@sage.com"), 200);
					debugTrace("Search response (339):" + sys.inspect(respJSON));
					strictEqual(respJSON.hits.total, 0, "No result ok");
					// explain
					respJSON = _elasticPost(_, id1 + "/_explain", _makeQuery("cristi.fake@sage.com"), 200);
					debugTrace("Explain response (315):" + sys.inspect(respJSON, null, 6));
					// This query should have a result
					respJSON = _elasticPost(_, "_search", _makeQuery("cristi.*@sage.com"), 200);
					debugTrace("Search response (359):" + sys.inspect(respJSON));
					strictEqual(respJSON.hits.total, 1, "Found email with wildcard ok");
					// exact search
					respJSON = _elasticPost(_, "_search", _makeQuery("cristi.nitescu@sage.com"), 200);
					debugTrace("Search response (352):" + sys.inspect(respJSON));
					strictEqual(respJSON.hits.total, 1, "Found email with exact search ok");

				});


				it('init indexHelper - version elastic ' + item, function(_) {
					endPoint = testAdmin.modifyCollaborationEndpoint("unit_test");


					h = new IndexHelper(endPoint, "en-us");
					ok(true, "initialized indexHelper");
				});


				it('test indexation syracuse administration - version elastic ' + item, function(_) {
					try {
						console.log("url ", elasticBaseUrl);

						elasticIndex.tracer = tracer;
						elasticIndex.serverConfig = configTest;
						h.updateIndex(_, false, {
							locale: "en-us"
						});
						ok(true, "launch indexation ");
						// check existance of index
						var req = {
							url: elasticBaseUrl + "/syracuse.collaboration.unit_test.en-us/_mapping",
							method: 'GET'
						};
						var resp = ez.devices.http.client(req).end().response(_);
						strictEqual(resp.statusCode, 200, "index created ok");

					} catch (e) {
						ok(false, "launch indexation failed " + e.stack);

					}
				});


				it('test query syracuse administration 1 - version elastic ' + item, function(_) {
					recOptions.fileName = "test";
					var searchConfig = {
						editDistance: 2,
						prototype: false,
						recOptions: recOptions,
						keepInContext: true
					};

					// no data
					elasticQuery.tracer = tracer;
					elasticQuery.serverConfig = configTest;
					var result = {};
					var ctx = _makeContextQuerySearch("testing", result);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(result.status, 200, "search ok ");
					strictEqual(ctx.totalCount, 0, "total result ok for test : " + ctx.totalCount);
					strictEqual(result.result.$resources.length, 0, "search body response ok for test: " + result.result.$resources.length);
					strictEqual(getQueryValue(ctx), "testing", "check query string ok : " + getQueryValue(ctx));


					// basic
					ctx = _makeContextQuerySearch("admin", result);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(result.status, 200, "search ok ");
					strictEqual(ctx.totalCount !== 0, true, "total result ok for admin : " + ctx.totalCount);
					//debugTrace("-------result  admin "+JSON.stringify(result.result.$resources,null,2));
					strictEqual(result.result.$resources.length != 0, true, "search body response ok for admin : " + result.result.$resources.length);
					//check request to elastic search
					strictEqual(getQueryValue(ctx), "admin", "check query string ok : " + getQueryValue(ctx));
					//check highlight
					var hl = _extractHighlight(result.result.$resources);
					strictEqual(hl.length !== 0, true, "check highlight " + hl.length);

					// case sensitivity
					ctx = _makeContextQuerySearch("AdmIn", result);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(result.status, 200, "search ok ");
					strictEqual(ctx.totalCount !== 0, true, "total result ok for admin : " + ctx.totalCount);
					//debugTrace("-------result  admin "+JSON.stringify(result.result.$resources,null,2));
					strictEqual(result.result.$resources.length != 0, true, "search body response ok for admin : " + result.result.$resources.length);
					//check request to elastic search
					strictEqual(getQueryValue(ctx), "admin", "check query string ok : " + getQueryValue(ctx));
					//check highlight


					// test for checking relevant result
					ctx = _makeContextQuerySearch("guest", result);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(result.status, 200, "search ok ");
					strictEqual(ctx.totalCount !== 0, true, "total result ok for guest : " + ctx.totalCount);
					strictEqual(result.result.$resources.length != 0, true, "search body response ok for guest : " + result.result.$resources.length);
					strictEqual(getQueryValue(ctx), "guest", "check query string ok : " + getQueryValue(ctx));
					hl = _extractHighlight(result.result.$resources);
					strictEqual(hl.length !== 0, true, "check highlight " + hl.length);


					// check list of word
					ctx = _makeContextQuerySearch("Sales manager", result);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(result.status, 200, "search ok ");
					strictEqual(ctx.totalCount !== 0, true, "total result ok for group admin : " + ctx.totalCount);
					strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
					strictEqual(getQueryValue(ctx), "sales manager", "check query string ok : " + getQueryValue(ctx));
					hl = _extractHighlight(result.result.$resources);
					strictEqual(hl.length !== 0, true, "check highlight " + hl.length);

					// forbidden character
					ctx = _makeContextQuerySearch("*setting", result);
					try {
						strictEqual(getQueryValue(ctx), "*setting", "check query string ok : " + getQueryValue(ctx));

						elasticQuery.search(_, ctx, searchConfig);

						ok(false, "test character * ok ");
					} catch (e) {
						ok(true, "test character * ok ");
					}

					ctx = _makeContextQuerySearch("/setting", result);
					try {
						elasticQuery.search(_, ctx, searchConfig);
						ok(true, "test character / ok ");
					} catch (e) {
						ok(false, "test character / ok ");
					}

					// search on numeric
					ctx = _makeContextQuerySearch("10,01", result);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(getQueryValue(ctx), "10.01", "check query string ok : " + getQueryValue(ctx));

					// search on numeric that is store as integer in elatic
					ctx = _makeContextQuerySearch("17000", result);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(getQueryValue(ctx), "17000", "check query string ok : " + getQueryValue(ctx));
					strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
					strictEqual(ctx.totalCount !== 0, true, "total result ok  : " + ctx.totalCount);

				});


				it('test query syracuse administration with noHighlight parameter - version elastic ' + item, function(_) {
					recOptions.fileName = "test";
					var searchConfig = {
						editDistance: 2,
						prototype: false,
						recOptions: recOptions,
						keepInContext: true
					};

					// no data
					elasticQuery.tracer = tracer;
					elasticQuery.serverConfig = configTest;
					var result = {};

					// basic
					var ctx = _makeContextQuerySearch("admin", result);
					ctx.parameters.noHighlight = true;
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(result.status, 200, "search ok ");
					strictEqual(ctx.totalCount !== 0, true, "total result ok for admin : " + ctx.totalCount);
					//debugTrace("-------result  admin "+JSON.stringify(result.result.$resources,null,2));
					strictEqual(result.result.$resources.length != 0, true, "search body response ok for admin : " + result.result.$resources.length);
					//check request to elastic search
					strictEqual(getQueryValue(ctx), "admin", "check query string ok : " + getQueryValue(ctx));
					//check highlight
					var hl = _extractHighlight(result.result.$resources);
					strictEqual(hl.length === 0, true, "check highlight " + hl.length);

					// case sensitivity


					// test for checking relevant result
					ctx = _makeContextQuerySearch("guest", result);
					ctx.parameters.noHighlight = true;

					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(result.status, 200, "search ok ");
					strictEqual(ctx.totalCount !== 0, true, "total result ok for guest : " + ctx.totalCount);
					strictEqual(result.result.$resources.length != 0, true, "search body response ok for guest : " + result.result.$resources.length);
					strictEqual(getQueryValue(ctx), "guest", "check query string ok : " + getQueryValue(ctx));
					hl = _extractHighlight(result.result.$resources);
					strictEqual(hl.length === 0, true, "check highlight " + hl.length);


					// check list of word
					ctx = _makeContextQuerySearch("Sales manager", result);
					ctx.parameters.noHighlight = true;

					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(result.status, 200, "search ok ");
					strictEqual(ctx.totalCount !== 0, true, "total result ok for group admin : " + ctx.totalCount);
					strictEqual(result.result.$resources.length != 0, true, "search body response ok : " + result.result.$resources.length);
					strictEqual(getQueryValue(ctx), "sales manager", "check query string ok : " + getQueryValue(ctx));
					hl = _extractHighlight(result.result.$resources);
					strictEqual(hl.length === 0, true, "check highlight " + hl.length);


				});


				it('test date query syracuse administration - version elastic ' + item, function(_) {
					recOptions.fileName = "test";
					var searchConfig = {
						editDistance: 2,
						prototype: false,
						recOptions: recOptions,
						keepInContext: true
					};

					elasticQuery.tracer = tracer;
					elasticQuery.serverConfig = configTest;
					var ctx,
						opts = {
							locale: "en-gb",
							shortDate: "dd/MM/yyyy"
						};
					// UK date format
					ctx = _makeContextQuerySearch("04/12/2014", opts);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(getQueryValue(ctx), "2014-12-04", "check query string ok : " + getQueryValue(ctx));

					// Date that would fail in US format
					ctx = _makeContextQuerySearch("25/12/2014", opts);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(getQueryValue(ctx), "2014-12-25", "check query string ok : " + getQueryValue(ctx));

					opts = {
						locale: "fr-fr",
						shortDate: "dd-MM-yyyy"
					};
					// hyphen separated date format
					ctx = _makeContextQuerySearch("04-12-2014", opts);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(getQueryValue(ctx), "2014-12-04", "check query string ok : " + getQueryValue(ctx));

					// Date that would fail in US format
					ctx = _makeContextQuerySearch("25-12-2014", opts);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(getQueryValue(ctx), "2014-12-25", "check query string ok : " + getQueryValue(ctx));

					opts = {
						locale: "en-us",
						shortDate: "MM/dd/yyyy"
					};
					// US date format
					ctx = _makeContextQuerySearch("12/04/2014", opts);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(getQueryValue(ctx), "2014-12-04", "check query string ok : " + getQueryValue(ctx));

					// Date that would fail in UK format
					ctx = _makeContextQuerySearch("12/25/2014", opts);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(getQueryValue(ctx), "2014-12-25", "check query string ok : " + getQueryValue(ctx));

					// Two final tests using system date format
					ctx = _makeContextQuerySearch("2014-12-04", opts);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(getQueryValue(ctx), "2014-12-04", "check query string ok : " + getQueryValue(ctx));

					ctx = _makeContextQuerySearch("2014-12-25", opts);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(getQueryValue(ctx), "2014-12-25", "check query string ok : " + getQueryValue(ctx));


				});

				it('test query with boolean OR and AND and NOT on syracuse administration - version elastic ' + item, function(_) {

					recOptions.fileName = "test";
					var searchConfig = {
						editDistance: 2,
						prototype: false,
						recOptions: recOptions,
						keepInContext: true
					};

					elasticQuery.tracer = tracer;
					elasticQuery.serverConfig = configTest;
					var ctx,
						opts = {
							locale: "en-gb",
							shortDate: "dd/MM/yyyy"
						};

					ctx = _makeContextQuerySearch("super AND admin", opts);
					elasticQuery.search(_, ctx, searchConfig);
					debugTrace("Query: " + sys.inspect(getQueryStringValue(ctx)));
					strictEqual(getQueryStringValue(ctx), "super AND admin", "check query string ok : " + getQueryStringValue(ctx));
					console.log(" highlight ", JSON.stringify(ctx.searchRequest.highlight, null, 2));

					strictEqual(JSON.stringify(ctx.searchRequest.highlight.fields), '{"*":{"highlight_query":{"bool":{"must":[{"match":{"content":{"query":"super","type":"phrase_prefix"}}},{"match":{"content":{"query":"admin","type":"phrase_prefix"}}}]}}}}', " highligh query ok");


					ctx = _makeContextQuerySearch("super OR admin", opts);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(getQueryStringValue(ctx), "super OR admin", "check query string ok : " + getQueryStringValue(ctx));
					strictEqual(JSON.stringify(ctx.searchRequest.highlight.fields), '{"*":{"highlight_query":{"bool":{"must":[{"match":{"content":{"query":"super","type":"phrase_prefix"}}},{"match":{"content":{"query":"admin","type":"phrase_prefix"}}}]}}}}', " highligh query ok");


					ctx = _makeContextQuerySearch("admin", opts);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(getQueryValue(ctx), "admin", "check query string ok : " + getQueryValue(ctx));
					strictEqual(JSON.stringify(ctx.searchRequest.highlight.fields), '{"*":{}}', " highligh query ok");
					strictEqual(opts.status, 200, "search ok ");
					strictEqual(ctx.totalCount !== 0, true, "total result ok : " + ctx.totalCount);
					strictEqual(opts.result.$resources.length != 0, true, "search body response ok : " + opts.result.$resources.length);
					strictEqual(_extractHighlight(opts.result.$resources).length != 0, true, "search body highlighted response ok : " + _extractHighlight(opts.result.$resources).length);

					ctx = _makeContextQuerySearch("(super AND admin) OR super AND admin", opts);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(getQueryStringValue(ctx), "(super AND admin) OR super AND admin", "check query string ok : " + getQueryStringValue(ctx));
					strictEqual(JSON.stringify(ctx.searchRequest.highlight.fields), '{"*":{"highlight_query":{"bool":{"must":[{"match":{"content":{"query":"super","type":"phrase_prefix"}}},{"match":{"content":{"query":"admin","type":"phrase_prefix"}}}]}}}}', " highligh query ok");


				});

				it('test query syracuse administration 2 - version elastic ' + item, function(_) {
					function verifySearchResult(type, resource) {
						if (resource.$representation === 'user') {

							strictEqual(resource.$searchItemTitle, "mr  Super administrator", "resource that match the most ok : return " + resource.$searchItemTitle);
						} else if (resource.$representation === 'role') {
							strictEqual(resource.$searchItemTitle, "Super administrator", "resource that match the most ok : return " + resource.$searchItemTitle);
						} else if (resource.$representation === 'group') {
							strictEqual(resource.$searchItemTitle, "Super administrators", "resource that match the most ok : return " + resource.$searchItemTitle);
						} else if (resource.$representation === 'team') {
							strictEqual(resource.members[0], "<em>admin</em>", "resource that match the most ok : return " + resource.members);
						} else if (resource.$representation === 'endPoint') {
							strictEqual(resource.groups[0], "<em>Admin</em>", "resource that match the most ok : return " + resource.groups[0]);
						} else {
							strictEqual(resource.code, "<em>ADMIN</em>", "resource that match the most ok : return " + resource.code);
						}

						debugTrace("================== Query Type : " + type + "=======================");
						debugTrace("Search Response :" + JSON.stringify(resource));
					}

					var searchConfig = {
						editDistance: 2,
						prototype: false,
						keepInContext: true
					};

					elasticQuery.tracer = tracer;
					elasticQuery.serverConfig = configTest;
					var opts = {
						qt: "fuzzy"
					};
					searchConfig.searchType = "fuzzy";

					var ctx = _makeContextQuerySearch("admi", opts);

					elasticQuery.search(_, ctx, searchConfig);
					// check first result is the right one
					strictEqual(opts.status, 200, "startWith match search completed ok ");
					strictEqual(opts.result.$resources.length != 0, true, "search body response ok : " + opts.result.$resources.length);
					if (item == 1) {
						var res = '{"filtered":{"query":{"bool":{"should":[{"constant_score":{"query":{"fuzzy_like_this":{"like_text":"admi","max_query_terms":20,"min_similarity":0.5,"ignore_tf":true,"boost":1}},"boost":1}},{"function_score":{"query":{"query_string":{"query":"admi","boost":100,"analyze_wildcard":true,"allow_leading_wildcard":false}},"boost_factor":2.5}}]}}}}';
						strictEqual(res, JSON.stringify(ctx.searchRequest.query), "request ok ");
					}
					verifySearchResult("startsWith", opts.result.$resources[0]);

					// Exact search may be redundant
					opts.qt = "exact";
					ctx = _makeContextQuerySearch("admin", opts);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(opts.status, 200, "Fuzzy search exact completed ok");
					strictEqual(opts.result.$resources.length != 0, true, "search body response ok : " + opts.result.$resources.length);
					verifySearchResult("exact", opts.result.$resources[0]);

					// test fuzzy search with spelling - edit distance 1
					opts.qt = "fuzzy";
					searchConfig.searchType = "fuzzy";
					searchConfig.minSimilarity = 0.5;
					ctx = _makeContextQuerySearch("admn", opts);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(opts.status, 200, "Fuzzy search minSimilarity=0.5  completed ok");

					strictEqual(opts.result.$resources.length != 0, true, "Search body response ok : " + opts.result.$resources.length);
					verifySearchResult("Fuzzy (1)", opts.result.$resources[0]);

					// test fuzzy search with spelling - edit distance is 2
					searchConfig.minSimilarity = 0.5;
					searchConfig.searchType = "fuzzy";

					ctx = _makeContextQuerySearch("admni", opts);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(opts.status, 200, "Fuzzy search minSimilarity=1 completed ok");
					if (item == 1) {

						res = '{"filtered":{"query":{"bool":{"should":[{"constant_score":{"query":{"fuzzy_like_this":{"like_text":"admni","max_query_terms":20,"min_similarity":0.5,"ignore_tf":true,"boost":1}},"boost":1}},{"function_score":{"query":{"query_string":{"query":"admni","boost":100,"analyze_wildcard":true,"allow_leading_wildcard":false}},"boost_factor":2.5}}]}}}}';

						strictEqual(res, JSON.stringify(ctx.searchRequest.query), "request ok ");
					}
					strictEqual(opts.result.$resources.length != 0, true, "search body response ok : " + opts.result.$resources.length);
					verifySearchResult("Fuzzy (2)", opts.result.$resources[0]);

					// test fuzzy search with spelling - edit distance is 3
					// This should fail as the edit distance > 2
					searchConfig.minSimilarity = 0.9;

					ctx = _makeContextQuerySearch("adminn", opts);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(opts.status, 200, "Fuzzy search minSimilarity=3 completed ok");
					if (item == 1)
						strictEqual(opts.result.$resources.length == 0, true, "search body response empty : " + opts.result.$resources.length);

					debugTrace("================= Expected empty Response ===================");
					debugTrace("Search Response :" + JSON.stringify(opts.result.$resources[0]));

					// test fuzzy search with spelling - edit distance is 3
					// Increasing the edit distance should cause this test to pass
					// test fuzzy search with spelling - edit distance is 2
					// Reducing the edit distance should cause this test to fail
					searchConfig.minSimilarity = 0.7;
					ctx = _makeContextQuerySearch("amdin", opts);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(opts.status, 200, "Search completed ok ");
					if (item == 1)
						strictEqual(opts.result.$resources.length == 0, true, "search body response empty : " + opts.result.$resources.length);

					debugTrace("================= Expected empty Response ===================");
					debugTrace("Search Response :" + JSON.stringify(opts.result.$resources[0]));

					// Closer match should successfully
					// test fuzzy search with spelling - edit distance 1
					searchConfig.minSimilarity = 0.7;
					ctx = _makeContextQuerySearch("admiu", opts);
					elasticQuery.search(_, ctx, searchConfig);
					strictEqual(opts.status, 200, "Search completed ok ");

					strictEqual(opts.result.$resources.length != 0, true, "search body response ok : " + opts.result.$resources.length);
					verifySearchResult("Fuzzy (3)", opts.result.$resources[0]);

				});

				it('test creation elastic search filter - version elastic ' + item, function(_) {

					function _getFilter(search) {
						var gen;
						if (item === 1) {
							gen = JSON.stringify(search.query.filtered.filter);
						} else {
							gen = JSON.stringify(search.query.bool.filter);
						}
						return gen;
					}

					var search = {
						query: {
							filtered: {}
						}
					};
					// test add filter
					elasticQuery.addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
					var res = '{"and":[{"and":[{"or":[{"query":{"term":{"$uuid":"uuid-1"}}},{"query":{"term":{"test.ap":"test"}}}]},{"query":{"term":{"test.toto":"23"}}}]}]}';
					var gen = _getFilter(search);

					strictEqual(res, gen, "generate simple filter ok");

					search = {
						query: {
							filtered: {}
						}
					};
					elasticQuery.addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
					res = '{"and":[{"and":[{"or":[{"query":{"term":{"$uuid":"uuid-1"}}},{"query":{"term":{"test.ap":"test"}}}]},{"query":{"term":{"test.toto":"23"}}}]}]}';
					strictEqual(res, _getFilter(search), "generate complexe filter ok");

					search = {
						query: {
							filtered: {}
						}
					};
					elasticQuery.addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
					res = '{"and":[{"and":[{"or":[{"query":{"term":{"$uuid":"uuid-1"}}},{"query":{"term":{"test.ap":"test"}}}]},{"query":{"term":{"test.toto":"23"}}}]}]}';
					strictEqual(res, _getFilter(search), "generate filter ok");

					elasticQuery.addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
					debugTrace(JSON.stringify(search));
					//res = '{"query":{"filtered":{"filter":{"and":[{"and":[{"or":[{"query":{"field":{"$uuid":"uuid-1"}}},{"query":{"field":{"test.ap":"test"}}}]},{"query":{"field":{"test.toto":"23"}}}]}]}}}}';
					res = '{"and":[{"and":[{"or":[{"query":{"term":{"$uuid":"uuid-1"}}},{"query":{"term":{"test.ap":"test"}}}]},{"query":{"term":{"test.toto":"23"}}}]},{"and":[{"or":[{"query":{"term":{"$uuid":"uuid-1"}}},{"query":{"term":{"test.ap":"test"}}}]},{"query":{"term":{"test.toto":"23"}}}]}]}';
					strictEqual(res, _getFilter(search), "add filter ok");

					debugTrace("==========================================");
					debugTrace("Query :" + JSON.stringify(search));
					//elasticQuery._addRightFilterCondition(_,"$uuid eq \"uuid-1\"",{},{},{});
					search = {
						query: {
							filtered: {}
						}
					};
					// test add filter
					elasticQuery.addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
					var res = '{"and":[{"and":[{"or":[{"query":{"term":{"$uuid":"uuid-1"}}},{"query":{"term":{"test.ap":"test"}}}]},{"query":{"term":{"test.toto":"23"}}}]}]}';

					console.log("search ", _getFilter(search))
					strictEqual(res, _getFilter(search), "generate simple filter ok");

					search = {
						query: {
							filtered: {}
						}
					};
					elasticQuery.addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
					res = '{"and":[{"and":[{"or":[{"query":{"term":{"$uuid":"uuid-1"}}},{"query":{"term":{"test.ap":"test"}}}]},{"query":{"term":{"test.toto":"23"}}}]}]}';
					strictEqual(res, _getFilter(search), "generate complexe filter ok");

					search = {
						query: {
							filtered: {}
						}
					};
					elasticQuery.addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
					res = '{"and":[{"and":[{"or":[{"query":{"term":{"$uuid":"uuid-1"}}},{"query":{"term":{"test.ap":"test"}}}]},{"query":{"term":{"test.toto":"23"}}}]}]}';
					strictEqual(res, _getFilter(search), "generate filter ok");

					elasticQuery.addSdataWhere(search.query, "( ( $uuid eq \"uuid-1\" ) or ( test.ap eq \"test\" ) ) and ( test.toto eq \"23\" )");
					debugTrace(JSON.stringify(search));
					//res = '{"query":{"filtered":{"filter":{"and":[{"and":[{"or":[{"query":{"term":{"$uuid":"uuid-1"}}},{"query":{"term":{"test.ap":"test"}}}]},{"query":{"term":{"test.toto":"23"}}}]}]}}}}';
					res = '{"and":[{"and":[{"or":[{"query":{"term":{"$uuid":"uuid-1"}}},{"query":{"term":{"test.ap":"test"}}}]},{"query":{"term":{"test.toto":"23"}}}]},{"and":[{"or":[{"query":{"term":{"$uuid":"uuid-1"}}},{"query":{"term":{"test.ap":"test"}}}]},{"query":{"term":{"test.toto":"23"}}}]}]}';
					strictEqual(res, _getFilter(search), "add filter ok");

					debugTrace("==========================================");
					debugTrace("Query :" + JSON.stringify(search));
					//elasticQuery._addRightFilterCondition(_,"$uuid eq \"uuid-1\"",{},{},{});
				});

				it('test delete index  syracuse administration - version elastic ' + item, function(_) {
					try {
						elasticIndex.tracer = tracer;
						elasticIndex.serverConfig = configTest;
						var req = {
							url: elasticBaseUrl + "/syracuse.collaboration.unit_test.en-us/_mapping",
							method: 'GET'
						};
						var resp = ez.devices.http.client(req).end().response(_);
						strictEqual(resp.statusCode, 200, "index  exists ok");
						// check existance of index
						var diag = [];
						elasticIndex.deleteEndpointIndex(_, endPoint, "en-us", diag);
						ok(true, "launch delete indexation  ");
						req = {
							url: elasticBaseUrl + "/syracuse.collaboration.unit_test.en-us/_mapping",
							method: 'GET'
						};
						resp = ez.devices.http.client(req).end().response(_);
						strictEqual(resp.statusCode, 404, "index not exists  ok");
					} catch (e) {
						ok(false, " delete indexation failed " + e.stack);
					}
				});
			} else {
				it("skip elastic search version" + item, function(_) {
					ok(true, "Elastic searc is not started");

				});
			}
		});
	});


});