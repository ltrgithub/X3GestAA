"use strict";
/* jshint -W079 */
/* jshint unused: false */
/* global QUnit: false, asyncTest: false, test: false, strictEqual: false, ok: false, start: false, stop: false */

/*global QUnit, start, ok*/
var helpers = require('syracuse-core/lib/helpers');
var sys = require("util");
var config = require('config'); // must be first syracuse require
var port = 3004;
var dataModel = require("syracuse-orm/lib/dataModel");
var elasticQuery = require("syracuse-search/lib/elasticQuery");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;

var elasticIndex = require("syracuse-search/lib/elasticIndex");
var IndexHelper = require("syracuse-search/lib/elasticIndex").IndexHelper;
var jsonImport = require("syracuse-import/lib/jsonImport");
var adminTestFixtures = require("syracuse-collaboration/test/fixtures/adminTestFixtures");
var mongodb = require('streamline-mongodb');
var testData = require('syracuse-sdata/test/fixtures/testDB');
var testEndPoint = testData.endpoint;
var searchEngine = require('syracuse-search/lib/elasticSearch');

var doStop = false;
QUnit.module(module.id, {
	setup: function() {},
	teardown: function() {
		if (doStop) {
			setTimeout(function() {
				process.kill(process.pid);
			}, 100);
		}
	}
});

asyncTest("test syracuse right filter  ", function(_) {
	var search = {
		query: {
			filtered: {}
		}
	};
	var syraRight = {
		"purgeCache": true,
		"$mode": "restriction",
		"$entities": {
			"typeTest": {
				"restriction": true
			}
		}
	};
	var prototypeUnitTest = {
		"http://localhost:9200/syracuse.collaboration.syracuse.en-us_entities/$entities/typeTest": {
			"teams": {
				$type: "application/x-reference"
			},
			"authors": {
				$type: "application/x-reference"
			},
			"author": {
				$type: "application/x-reference"
			},
			"administrator": {
				$type: "application/x-reference"
			},
			"members": {
				$type: "application/x-reference"
			},
			"Ateams": {
				$type: "application/x-array",
				$item: {
					$type: "application/x-reference"
				}
			}
		}
	};
	var baseUrlIndex = "http://localhost:9200/syracuse.collaboration.syracuse.en-us";

	// test syracuse filter generation on data


	syraRight.$entities.typeTest.condition = "author.$uuid eq test and toto.$uuid eq tst"; // test replace author in by  .$uuid $key;
	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, false, prototypeUnitTest);
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"query":{"field":{"author.$key":"test"}}},{"query":{"field":{"toto.$key":"tst"}}},{"query":{"field":{"_type":"typeTest"}}}]}]}', "syracuse right filter : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, true, prototypeUnitTest);
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"missing":{"field":"representationRef.entity"}},{"query":{"field":{"representationRef.entity":"typeTest"}}}]}]}', "syracuse right filter : " + JSON.stringify(search.query.filtered.filter));

	// test filter on function with no condition but a restriction
	search.query.filtered = {};
	delete syraRight.$entities.typeTest.condition; // test replace author in by  .$uuid $key;
	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, true, prototypeUnitTest);
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"missing":{"field":"representationRef.entity"}},{"not":{"query":{"field":{"representationRef.entity":"typeTest"}}}}]}]}', "syracuse right filter : " + JSON.stringify(search.query.filtered.filter));


	search.query.filtered = {};
	syraRight.$entities.typeTest.condition = "$uuid eq bla"; // test replace author in by $uuid _id;
	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, false, prototypeUnitTest);
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"query":{"field":{"_id":"bla"}}},{"query":{"field":{"_type":"typeTest"}}}]}]}', "syracuse right filter " + JSON.stringify(search.query.filtered.filter));
	search.query.filtered = {};

	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, true, prototypeUnitTest);

	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"missing":{"field":"representationRef.entity"}},{"query":{"field":{"representationRef.entity":"typeTest"}}}]}]}', "syracuse right filter : " + JSON.stringify(search.query.filtered.filter));


	search.query.filtered = {};
	syraRight.$entities.typeTest.condition = "$uuid eq bla and $uuid in (test)"; // test replace author in by $uuid _id;
	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, false, prototypeUnitTest);
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"query":{"field":{"_id":"bla"}}},{"terms":{"_id":["test"]}},{"query":{"field":{"_type":"typeTest"}}}]}]}', "syracuse right filter " + JSON.stringify(search.query.filtered.filter));
	search.query.filtered = {};

	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, true, prototypeUnitTest);

	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"missing":{"field":"representationRef.entity"}},{"query":{"field":{"representationRef.entity":"typeTest"}}}]}]}', "syracuse right filter : " + JSON.stringify(search.query.filtered.filter));


	search.query.filtered = {};
	syraRight.$entities.typeTest.condition = "author in (test,test2) and author in (toto) and author eq test"; // test replace author in by author.$key;
	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, false, prototypeUnitTest);
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"terms":{"author.$key":["test","test2"]}},{"terms":{"author.$key":["toto"]}},{"query":{"field":{"author":"test"}}},{"query":{"field":{"_type":"typeTest"}}}]}]}', "syracuse right filter ok : " + JSON.stringify(search.query.filtered.filter));
	search.query.filtered = {};

	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, true, prototypeUnitTest);

	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"missing":{"field":"representationRef.entity"}},{"query":{"field":{"representationRef.entity":"typeTest"}}}]}]}', "syracuse right filter : " + JSON.stringify(search.query.filtered.filter));



	search.query.filtered = {};
	syraRight.$entities.typeTest.condition = "(teams eq null) or ((teams ne null) and (teams in (test1) or teams in (test2) or teams in (test3)))"; // test replace author in by author.$key
	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, false, prototypeUnitTest);
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"or":[{"missing":{"field":"teams"}},{"and":[{"not":{"missing":{"field":"teams"}}},{"or":[{"terms":{"teams.$key":["test1"]}},{"terms":{"teams.$key":["test2"]}},{"terms":{"teams.$key":["test3"]}}]}]}]},{"query":{"field":{"_type":"typeTest"}}}]}]}', "syracuse right filter ok : " + JSON.stringify(search.query.filtered.filter));
	search.query.filtered = {};

	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, true, prototypeUnitTest);
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"missing":{"field":"representationRef.entity"}},{"query":{"field":{"representationRef.entity":"typeTest"}}}]}]}', "syracuse right filter : " + JSON.stringify(search.query.filtered.filter));



	search.query.filtered = {};
	syraRight.$entities.typeTest.condition = "(administrator ne null and administrator.$uuid eq test1 or (authors ne null and authors in (test1) or (members ne null and members in (test1))))"; // test replace author in by author.$key
	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, false, prototypeUnitTest);
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"or":[{"and":[{"not":{"missing":{"field":"administrator"}}},{"query":{"field":{"administrator.$key":"test1"}}}]},{"and":[{"not":{"missing":{"field":"authors"}}},{"terms":{"authors.$key":["test1"]}}]},{"and":[{"not":{"missing":{"field":"members"}}},{"terms":{"members.$key":["test1"]}}]}]},{"query":{"field":{"_type":"typeTest"}}}]}]}', "syracuse right filter ok : " + JSON.stringify(search.query.filtered.filter));
	search.query.filtered = {};

	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, true, prototypeUnitTest);

	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"missing":{"field":"representationRef.entity"}},{"query":{"field":{"representationRef.entity":"typeTest"}}}]}]}', "syracuse right filter : " + JSON.stringify(search.query.filtered.filter));


	// test with property using in  members.in
	search.query.filtered = {};
	syraRight.$entities.typeTest.condition = "(administrator ne null and administrator.$uuid eq test1 or (authors ne null and authors in (test1) or (members ne null and members.toto in (test1))))"; // test replace author in by author.$key
	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, false, prototypeUnitTest);

	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"or":[{"and":[{"not":{"missing":{"field":"administrator"}}},{"query":{"field":{"administrator.$key":"test1"}}}]},{"and":[{"not":{"missing":{"field":"authors"}}},{"terms":{"authors.$key":["test1"]}}]},{"and":[{"not":{"missing":{"field":"members"}}},{"terms":{"members.toto":["test1"]}}]}]},{"query":{"field":{"_type":"typeTest"}}}]}]}', "syracuse right filter ok : " + JSON.stringify(search.query.filtered.filter));
	search.query.filtered = {};

	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, true, prototypeUnitTest);

	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"missing":{"field":"representationRef.entity"}},{"query":{"field":{"representationRef.entity":"typeTest"}}}]}]}', "syracuse right filter : " + JSON.stringify(search.query.filtered.filter));

	// test with a property that is not a relation
	search.query.filtered = {};
	syraRight.$entities.typeTest.condition = "(administrator ne null and administrator.$uuid eq test1 or (authors ne null and authors in (test1) or (members ne null and userName in (test1))))"; // test replace author in by author.$key
	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, false, prototypeUnitTest);

	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"or":[{"and":[{"not":{"missing":{"field":"administrator"}}},{"query":{"field":{"administrator.$key":"test1"}}}]},{"and":[{"not":{"missing":{"field":"authors"}}},{"terms":{"authors.$key":["test1"]}}]},{"and":[{"not":{"missing":{"field":"members"}}},{"terms":{"userName":["test1"]}}]}]},{"query":{"field":{"_type":"typeTest"}}}]}]}', "syracuse right filter ok : " + JSON.stringify(search.query.filtered.filter));
	search.query.filtered = {};

	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, true, prototypeUnitTest);

	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"missing":{"field":"representationRef.entity"}},{"query":{"field":{"representationRef.entity":"typeTest"}}}]}]}', "syracuse right filter : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	syraRight.$entities.typeTest.condition = "(administrator ne null and administrator.$uuid eq test1 or (authors ne null and authors in (test1) or (Ateams ne null and Ateams in (test1))))"; // test replace author in by author.$key
	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, false, prototypeUnitTest);

	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"or":[{"and":[{"not":{"missing":{"field":"administrator"}}},{"query":{"field":{"administrator.$key":"test1"}}}]},{"and":[{"not":{"missing":{"field":"authors"}}},{"terms":{"authors.$key":["test1"]}}]},{"and":[{"not":{"missing":{"field":"Ateams"}}},{"terms":{"Ateams.$key":["test1"]}}]}]},{"query":{"field":{"_type":"typeTest"}}}]}]}', "syracuse right filter ok : " + JSON.stringify(search.query.filtered.filter));
	search.query.filtered = {};

	elasticQuery.addSyracuseRightFilter(_, syraRight, search, baseUrlIndex, true, prototypeUnitTest);

	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"missing":{"field":"representationRef.entity"}},{"query":{"field":{"representationRef.entity":"typeTest"}}}]}]}', "syracuse right filter : " + JSON.stringify(search.query.filtered.filter));

	start();
});

asyncTest("test x3 right filter  ", function(_) {
	var search = {
		query: {
			filtered: {}
		}
	};
	var x3Right = {
		"$mode": "authorize",
		"purgeCache": true,
		"$accessCodes": {
			"AAAAAAA": true,
			"ACCPP2": true,
			"ADMIN": true,
			"ALL": true,
			"AQCACS1": true,
			"AQCACS2": true,
			"AUTO": true,
			"BBBBBBBB": true,
			"BOBSLEIGH": true,
			"BOPP": true,
			"BRETAGNE": true,
			"CCL": true,
			"CHANGE": true,
			"CHM": true,
			"CME": true,
			"CMX": true,
			"CNS": true,
			"CONSULT": true,
			"CONSULTEXE": true,
			"CONSULTMOD": true,
			"CP": true,
			"CPT": true,
			"CREDITCHEC": true,
			"CXX": true,
			"DEL": true,
			"DOM": true,
			"EEEEEEE": true,
			"EXE": true,
			"EXECUT": true,
			"EXENOT": true,
			"FG": true,
			"FOURN": true,
			"GB": true,
			"GB2": true,
			"GH": true,
			"GIET": true,
			"HUB": true,
			"JML": true,
			"LESAUTRES": true,
			"LIASSE": true,
			"LLC": true,
			"LOCK": true,
			"LUGE": true,
			"LV01": true,
			"MARGE": true,
			"MBT": true,
			"MLS": true,
			"MODIF": true,
			"MODIFEXE": true,
			"MSL": true,
			"MYOWNCODE": true,
			"NATURE": true,
			"NOACCES": true,
			"NOCHANGE": true,
			"NOEXE": true,
			"NONE": true,
			"OKMODIF": true,
			"PAR1": true,
			"PAR2": true,
			"PARB": true,
			"PARIS": true,
			"PASOKMODIF": true,
			"PESEUR1": true,
			"PESEUR2": true,
			"PP": true,
			"PP2": true,
			"PROACE": true,
			"SDR": true,
			"SKI": true,
			"SOPHIA": true,
			"SORDIV": true,
			"STA": true,
			"TBD": true,
			"TBORD": true,
			"TEST": true,
			"TOTO": true,
			"TTTT": true,
			"VELO": true,
			"XXX": true,
			"YYY": true,
			"ZCB": true,
			"ZELISA": true,
			"ZHB": true,
			"ZINC": true,
			"ZZCP": true,
			"ZZEB": true,
			"ZZERB": true,
			"ZZMB": true,
			"ZZMB1": true,
			"ZZMB2": true,
			"ZZMB3": true,
			"ZZMB4": true,
			"ZZZX": true,
			"ZZZZ": true
		}
	};



	var baseUrlIndex = "http://localhost:9200/x3.erp.sydev.en-us";
	var resBool = false;
	// test with only accessCode
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "data filter , test with only accessCode has right ");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"regexp":{"$access":"aaaaaaa|accpp2|admin|all|aqcacs1|aqcacs2|auto|bbbbbbbb|bobsleigh|bopp|bretagne|ccl|change|chm|cme|cmx|cns|consult|consultexe|consultmod|cp|cpt|creditchec|cxx|del|dom|eeeeeee|exe|execut|exenot|fg|fourn|gb|gb2|gh|giet|hub|jml|lesautres|liasse|llc|lock|luge|lv01|marge|mbt|mls|modif|modifexe|msl|myowncode|nature|noacces|nochange|noexe|none|okmodif|par1|par2|parb|paris|pasokmodif|peseur1|peseur2|pp|pp2|proace|sdr|ski|sophia|sordiv|sta|tbd|tbord|test|toto|tttt|velo|xxx|yyy|zcb|zelisa|zhb|zinc|zzcp|zzeb|zzerb|zzmb|zzmb1|zzmb2|zzmb3|zzmb4|zzzx|zzzz|_all|all"}}]}]}', "x3 right filter : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "function filter, test with only accessCode has no right ");
	strictEqual(!search.query.filtered.filter, true, "x3right filter : " + JSON.stringify(search.query.filtered.filter));

	// test with function authorized only to all function
	x3Right = {
		$functions: {
			"*": true
		}
	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "data filter, test with function restriction set - access all function has right. for data see only _all entity");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"regexp":{"$access":"_all|all"}}]}]}', "x3right filter : " + JSON.stringify(search.query.filtered.filter));
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "functon filter, test with function restriction set - access all function has right. for data see only _all entity");
	strictEqual(!search.query.filtered.filter, true, "x3right filter : " + JSON.stringify(search.query.filtered.filter));


	// test with function but specified only few
	x3Right = {
		$functions: {
			GESAUS: true,
			"666": true,
			NUMBEROFTHEBEAST: true,
			IRONMAIDEN: true
		}
	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "data filter, test with function but specified only few has right ");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"regexp":{"$access":"666|gesaus|numberofthebeast|ironmaiden|_all|all"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "function filter, test with function but specified only few has no right ");
	strictEqual(!search.query.filtered.filter, true, "x3right filter : " + JSON.stringify(search.query.filtered.filter));

	// empty access code only
	x3Right = {
		$accessCodes: {
			"": true
		}
	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "data filter, empty access code only has no right ");

	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"regexp":{"$access":"_all|all"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "function filter, empty access code only has  no right ");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"regexp":{"$access":"_all|all"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));
	// no right properties
	x3Right = {

	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "function filter, no right properties. access to all data and function");
	strictEqual(!search.query.filtered.filter, true, "x3right right filter : " + JSON.stringify(search.query.filtered.filter));
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "data filter, no right properties has no right");
	strictEqual(!search.query.filtered.filter, true, "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	//only $representation without condition,site or access code
	x3Right = {
		$representations: {
			TEST1: {},
			TEST2: {},
			TEST3: {}
		}
	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without condition,site or access code has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"query":{"field":{"_type":"test1"}}},{"query":{"field":{"_type":"test2"}}},{"query":{"field":{"_type":"test3"}}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "only $representation without condition,site or access code has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"query":{"field":{"representationRef.entity":"test1"}}},{"query":{"field":{"representationRef.entity":"test2"}}},{"query":{"field":{"representationRef.entity":"test3"}}},{"missing":{"field":"representationRef.entity"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));


	//only $representation without condition,site or access code but with entity name and representation is different
	x3Right = {
		$representations: {
			TEST1: {
				$entity: "TESTENTITY1"
			},
			TEST2: {

			},
			TEST3: {
				$entity: "TESTENTITY3"

			}
		}
	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without condition,site or access code has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"query":{"field":{"_type":"testentity1"}}},{"query":{"field":{"_type":"test2"}}},{"query":{"field":{"_type":"testentity3"}}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "only $representation without condition,site or access code has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"query":{"field":{"representationRef.entity":"testentity1"}}},{"query":{"field":{"representationRef.entity":"test2"}}},{"query":{"field":{"representationRef.entity":"testentity3"}}},{"missing":{"field":"representationRef.entity"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	//only $representation without condition,site
	x3Right = {
		$representations: {
			TEST1: {
				$accessCodes: "TEST1"
			}
		},

	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without condition,site has  right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"query":{"field":{"_type":"test1"}}},{"terms":{"$access":["_all","test1"]}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "only $representation without condition,site");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"query":{"field":{"representationRef.entity":"test1"}}},{"missing":{"field":"representationRef.entity"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	//only $representation without condition,site with multiple accessCode and multiple representation
	x3Right = {
		$representations: {
			TEST1: {
				$accessCodes: "TEST1"
			},
			TEST2: {
				$accessCodes: "TEST1,TEST2"

			},
			TEST3: {
				$accessCodes: "TEST1,TEST3"
			}
		},

	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without condition,site has  right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"and":[{"query":{"field":{"_type":"test1"}}},{"terms":{"$access":["_all","test1"]}}]},{"and":[{"query":{"field":{"_type":"test2"}}},{"terms":{"$access":["_all","test1","test2"]}}]},{"and":[{"query":{"field":{"_type":"test3"}}},{"terms":{"$access":["_all","test1","test3"]}}]}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "only $representation without condition,site");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"query":{"field":{"representationRef.entity":"test1"}}},{"query":{"field":{"representationRef.entity":"test2"}}},{"query":{"field":{"representationRef.entity":"test3"}}},{"missing":{"field":"representationRef.entity"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	//only $representation without accessCodes,site with no condition but an empty array with 1 representation
	x3Right = {
		$representations: {
			TEST1: {
				$conditions: []
			}
		}
	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without accessCodes,site with 0 condition with multiple representation has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"query":{"field":{"_type":"test1"}}}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "only $representation without accessCodes,site with 0 condition with multiple representation has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"query":{"field":{"representationRef.entity":"test1"}}},{"missing":{"field":"representationRef.entity"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));



	//only $representation without accessCodes,site with 1 condition and $type
	x3Right = {
		$representations: {
			TEST1: {
				$conditions: [{
					$type: "authorization",
					$where: "test eq uuid and test2.toto in (ab,ac,ad)"
				}]
			}
		},

	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without accessCodes,site with 1 condition has  right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"query":{"field":{"_type":"test1"}}},{"query":{"field":{"test":"uuid"}}},{"terms":{"test2.toto":["ab","ac","ad"]}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "only $representation without accessCodes,site with 1 condition has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"query":{"field":{"representationRef.entity":"test1"}}},{"missing":{"field":"representationRef.entity"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));


	//only $representation without accessCodes,site with 1 restriction
	x3Right = {
		$representations: {
			TEST1: {
				$conditions: [{
					$type: "restriction",
					$where: "test eq uuid and test2.toto in (ab,ac,ad)"
				}]
			}
		},

	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without accessCodes,site with 1 restriction has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"query":{"field":{"_type":"test1"}}},{"not":{"and":[{"query":{"field":{"test":"uuid"}}},{"terms":{"test2.toto":["ab","ac","ad"]}}]}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "only $representation without accessCodes,site with 1 restriction has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"query":{"field":{"representationRef.entity":"test1"}}},{"missing":{"field":"representationRef.entity"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	//only $representation without accessCodes,site with 1 condition with multiple representation
	x3Right = {
		$representations: {
			TEST1: {
				$conditions: [{
					$type: "authorization",
					$where: "test eq uuid and test2.toto in (ab,ac,ad)"
				}]
			},
			TEST2: {
				$conditions: [{
					$type: "authorization",
					$where: "test eq uuid and test2.toto like %ab"
				}]
			},
			TEST3: {
				$conditions: [{
					$type: "authorization",
					$where: "test3.toto in (ab,ac,ad)"
				}]
			}
		}
	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without accessCodes,site with 1 condition with multiple representation has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"and":[{"query":{"field":{"_type":"test1"}}},{"query":{"field":{"test":"uuid"}}},{"terms":{"test2.toto":["ab","ac","ad"]}}]},{"and":[{"query":{"field":{"_type":"test2"}}},{"query":{"field":{"test":"uuid"}}},{"regexp":{"test2.toto":".*ab"}}]},{"and":[{"query":{"field":{"_type":"test3"}}},{"terms":{"test3.toto":["ab","ac","ad"]}}]}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "only $representation without accessCodes,site with 1 condition with multiple representation has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"query":{"field":{"representationRef.entity":"test1"}}},{"query":{"field":{"representationRef.entity":"test2"}}},{"query":{"field":{"representationRef.entity":"test3"}}},{"missing":{"field":"representationRef.entity"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));


	//only $representation without accessCodes,site with multiple condition with 1 representation
	x3Right = {
		$representations: {
			TEST1: {
				$conditions: [{
					$type: "authorization",
					$where: "test eq uuid and test2.toto in (ab,ac,ad)"
				}, {
					$type: "authorization",
					$where: "test2 eq uuid"
				}, {
					$type: "authorization",
					$where: "test3 eq uuid and test2.toto like ab"
				}]
			}
		}
	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without accessCodes,site with multiple condition with 1 representation has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"query":{"field":{"_type":"test1"}}},{"query":{"field":{"test":"uuid"}}},{"terms":{"test2.toto":["ab","ac","ad"]}},{"query":{"field":{"test2":"uuid"}}},{"query":{"field":{"test3":"uuid"}}},{"regexp":{"test2.toto":"ab"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "only $representation without accessCodes,site with multiple condition with 1 representation has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"query":{"field":{"representationRef.entity":"test1"}}},{"missing":{"field":"representationRef.entity"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));


	//only $representation without accessCodes,site with multiple condition and restriction with 1 representation
	x3Right = {
		$representations: {
			TEST1: {
				$conditions: [{
					$type: "authorization",
					$where: "test eq uuid and test2.toto in (ab,ac,ad)"
				}, {
					$type: "authorization",
					$where: "test2 eq uuid"
				}, {
					$type: "restriction",
					$where: "test3 eq uuid and test2.toto like ab"
				}]
			}
		}
	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without accessCodes,site with multiple condition and restriction with 1 representation has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"query":{"field":{"_type":"test1"}}},{"query":{"field":{"test":"uuid"}}},{"terms":{"test2.toto":["ab","ac","ad"]}},{"query":{"field":{"test2":"uuid"}}},{"not":{"and":[{"query":{"field":{"test3":"uuid"}}},{"regexp":{"test2.toto":"ab"}}]}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "only $representation without accessCodes,site with multiple condition and restriction with 1 representation has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"query":{"field":{"representationRef.entity":"test1"}}},{"missing":{"field":"representationRef.entity"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	//only $representation without accessCodes,site with multiple condition and restriction with multiple representation
	x3Right = {
		$representations: {
			TEST1: {
				$conditions: [{
					$type: "authorization",
					$where: "test eq uuid and test2.toto in (ab,ac,ad)"
				}, {
					$type: "authorization",
					$where: "test2 eq uuid"
				}, {
					$type: "restriction",
					$where: "test3 eq uuid and test2.toto like ab"
				}]
			},
			TEST2: {
				$conditions: [{
					$type: "authorization",
					$where: "test eq uuid and test2.toto in (ab,ac,ad)"
				}]
			},
			TEST3: {
				$conditions: [{
					$type: "authorization",
					$where: "test eq uuid and test2.toto in (ab,ac,ad)"
				}, {
					$type: "restriction",
					$where: "test3 eq uuid and test2.toto like ab"
				}]
			}
		}
	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without accessCodes,site with multiple condition and restriction with multiple representation has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"and":[{"query":{"field":{"_type":"test1"}}},{"query":{"field":{"test":"uuid"}}},{"terms":{"test2.toto":["ab","ac","ad"]}},{"query":{"field":{"test2":"uuid"}}},{"not":{"and":[{"query":{"field":{"test3":"uuid"}}},{"regexp":{"test2.toto":"ab"}}]}}]},{"and":[{"query":{"field":{"_type":"test2"}}},{"query":{"field":{"test":"uuid"}}},{"terms":{"test2.toto":["ab","ac","ad"]}}]},{"and":[{"query":{"field":{"_type":"test3"}}},{"query":{"field":{"test":"uuid"}}},{"terms":{"test2.toto":["ab","ac","ad"]}},{"not":{"and":[{"query":{"field":{"test3":"uuid"}}},{"regexp":{"test2.toto":"ab"}}]}}]}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "only $representation without accessCodes,site with multiple condition and restriction with multiple representation has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"query":{"field":{"representationRef.entity":"test1"}}},{"query":{"field":{"representationRef.entity":"test2"}}},{"query":{"field":{"representationRef.entity":"test3"}}},{"missing":{"field":"representationRef.entity"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	//only $representation without condition,accessCode with site and 1 representation
	x3Right = {
		$representations: {
			TEST1: {
				$sites: "A1"
			}
		}
	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without condition,accessCode with site and 1 representation has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"query":{"field":{"_type":"test1"}}},{"terms":{"$site":["_all","a1"]}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "only $representation without condition,accessCode with site and 1 representation has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"query":{"field":{"representationRef.entity":"test1"}}},{"missing":{"field":"representationRef.entity"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	//only $representation without condition,accessCode with multiple site  and 1 representation
	x3Right = {
		$representations: {
			TEST1: {
				$sites: "A1,A2,A3"
			}
		}
	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without condition,accessCode with site and 1 representation has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"query":{"field":{"_type":"test1"}}},{"terms":{"$site":["_all","a1","a2","a3"]}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "only $representation without condition,accessCode with site and 1 representation has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"query":{"field":{"representationRef.entity":"test1"}}},{"missing":{"field":"representationRef.entity"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	//only $representation without condition,accessCode with multiple site  and multiple representation
	x3Right = {
		$representations: {
			TEST1: {
				$sites: "A1,A2,A3"
			},
			TEST2: {
				$sites: "A1"
			},
			TEST3: {
				$sites: "A1,A2"
			}
		}
	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without condition,accessCode with site and multiple representation has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"and":[{"query":{"field":{"_type":"test1"}}},{"terms":{"$site":["_all","a1","a2","a3"]}}]},{"and":[{"query":{"field":{"_type":"test2"}}},{"terms":{"$site":["_all","a1"]}}]},{"and":[{"query":{"field":{"_type":"test3"}}},{"terms":{"$site":["_all","a1","a2"]}}]}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "only $representation without condition,accessCode with site and multiple representation has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"query":{"field":{"representationRef.entity":"test1"}}},{"query":{"field":{"representationRef.entity":"test2"}}},{"query":{"field":{"representationRef.entity":"test3"}}},{"missing":{"field":"representationRef.entity"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	//only $representation  condition,accessCode with  1 representation
	x3Right = {
		$accessCodes: {
			LEVEL1: true,
			TEST1: true,
			TEST2: true,
			TEST3: true

		},
		$functions: {
			GESAUS: true,
			'666': true,
			NUMBEROFTHEBEAST: true,
			TEST1: true,
			IRONMAIDEN: true,
			BOTTLENECK: true,
			SWIPPING: true
		},
		$representations: {
			TEST1: {
				$sites: "A1,A2,A3"
			},
			TEST2: {
				$sites: "A1,A2,A3"

			},
			TEST3: {
				$sites: "A1,A2,A3"

			},
			TEST4: {

			},
		}
	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without condition,accessCode with site and multiple representation has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"and":[{"query":{"field":{"_type":"test1"}}},{"terms":{"$site":["_all","a1","a2","a3"]}}]},{"and":[{"query":{"field":{"_type":"test2"}}},{"terms":{"$site":["_all","a1","a2","a3"]}}]},{"and":[{"query":{"field":{"_type":"test3"}}},{"terms":{"$site":["_all","a1","a2","a3"]}}]},{"query":{"field":{"_type":"test4"}}}]},{"or":[{"regexp":{"$access":"level1|test1|test2|test3|_all|all"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, true);
	strictEqual(resBool, true, "only $representation without condition,accessCode with site and multiple representation has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"or":[{"query":{"field":{"representationRef.entity":"test1"}}},{"query":{"field":{"representationRef.entity":"test2"}}},{"query":{"field":{"representationRef.entity":"test3"}}},{"query":{"field":{"representationRef.entity":"test4"}}},{"missing":{"field":"representationRef.entity"}}]},{"or":[{"regexp":{"$access":"666|gesaus|numberofthebeast|test1|ironmaiden|bottleneck|swipping|_all|all"}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));


	//only $representation without condition,accessCode with multiple site  with hyphen
	x3Right = {
		$representations: {
			TEST1: {
				$sites: "A1-2,A2,A3"
			}
		}
	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without condition,accessCode with multiple site  with hyphen has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"query":{"field":{"_type":"test1"}}},{"terms":{"$site":["_all","a1-2","a2","a3"]}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	//only $representation without condition with multiple site and access  with hyphen
	x3Right = {
		$representations: {
			TEST1: {
				$accessCodes: "A=2,A+2,A3",
				$sites: "A1-2,A2,A3"
			}
		}
	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without condition,accessCode with multiple site  with hyphen has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"query":{"field":{"_type":"test1"}}},{"terms":{"$access":["_all","a=2","a+2","a3"]}},{"terms":{"$site":["_all","a1-2","a2","a3"]}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	//access code and  $representation without condition with multiple site and access  with hyphen
	x3Right = {

		$representations: {
			TEST1: {
				$accessCodes: "A=2,A+2,A3",
				$sites: "A1-2,A2,A3"
			}
		}
	};
	search.query.filtered = {};
	resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without condition,accessCode with multiple site  with hyphen has right");
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"query":{"field":{"_type":"test1"}}},{"terms":{"$access":["_all","a=2","a+2","a3"]}},{"terms":{"$site":["_all","a1-2","a2","a3"]}}]}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));



	start();
});

asyncTest("test facet filter  ", function(_) {
	var search = {
		query: {
			filtered: {}
		}
	};
	var x3Right = {

		$representations: {
			TEST1: {
				$accessCodes: "A=2,A+2,A3",
				$sites: "A1-2,A2,A3"
			}
		}
	};
	search.query.filtered = {};
	var resBool = elasticQuery.addX3RightFilter(_, x3Right, search, false);
	strictEqual(resBool, true, "only $representation without condition,accessCode with multiple site  with hyphen has right");
	// add filter
	elasticQuery.addFilters(search.query, {
		"role": ["test"]
	});

	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"query":{"field":{"_type":"test1"}}},{"terms":{"$access":["_all","a=2","a+2","a3"]}},{"terms":{"$site":["_all","a1-2","a2","a3"]}}]},{"regexp":{"facet_role":"test"}}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));
	elasticQuery.addFilters(search.query, {
		"group": ["POEutea"]
	});
	strictEqual(JSON.stringify(search.query.filtered.filter), '{"and":[{"and":[{"query":{"field":{"_type":"test1"}}},{"terms":{"$access":["_all","a=2","a+2","a3"]}},{"terms":{"$site":["_all","a1-2","a2","a3"]}}]},{"regexp":{"facet_role":"test"}},{"regexp":{"facet_group":"POEutea"}}]}', "x3right right filter : " + JSON.stringify(search.query.filtered.filter));

	start();

});