"use strict";

var Context = require("@sage/syracuse-lib/src/sdata/sdataContext").Context;
var elasticQuery = require("./elasticQuery");
var elasticIndex = require("./elasticIndex");
var elasticVersion = require("./elasticVersion");
var elasticHelpers = require('./helpers');
var flows = require('streamline-runtime').flows;
var url = require('url');

//var tracer = console.log;
var serverConfig = exports.serverConfig = {};
var tracer = require('@sage/syracuse-core').getTracer("search");

var _operationMap = {
	_update: require("./elasticIndex").updateIndex,
	_delete: require("./elasticIndex").deleteIndex,
	_search: require("./elasticQuery").search
};

var _methodMap = {
	"put": require("./elasticIndex").updateIndex,
	"delete": require("./elasticIndex").deleteIndex,
	"get": elasticQuery.search
};

/*
 function that check if we upgrade elastic search from 1.5 to 2.4 in order to reexecute the schedule indexation task register in syracuse to reindex data
 */
var taskRunned = [];
var checkUpdateInProgress;
exports.checkUpdateVersion2 = function(_, db) {
	// check version
	try {
		if (checkUpdateInProgress) return;
		checkUpdateInProgress = true;
		var version = elasticVersion.getElasticVersion(_, serverConfig.baseUrl);
		if (version[0] === 2 && elasticVersion.hasNoIndexes(_, serverConfig.baseUrl)) {
			// check if some indexes are present and schedule task for indexation are defined
			var tab = db.fetchInstances(_, db.getEntity(_, "automate"));

			tab && tab.forEach_(_, function(_, item) {
				var tasks = item && item.automateTasks(_).toArray(_);
				tasks.forEach_(_, function(_, task) {
					var description = task.description(_);
					if (taskRunned.indexOf(description) && task.process(_).$type === "searchAdmin") {
						var diag = [];
						taskRunned.push(description);
						task.run(!_, diag, true);
					}
				});
			});
		}
		checkUpdateInProgress = false;
	} catch (e) {
		// elastic search not started - nothin to do
		checkUpdateInProgress = false;
		console.log("ERROR reschedule elastic on 2.4 ", e.stack);
	} finally {
		taskRunned = [];
	}

};


// url is like /search/[contract/][application/][entity/]_update
// or like /search?[index=contract&][type=entity][q=[field:]value&...]
exports.dispatch = function(_, request, response) {
	var context = new Context(request, response);
	var segments = request.url.split("?")[0].split("/");

	// operation is last segment
	var operation = segments[segments.length - 1];
	var application = (segments.length > 3) ? segments[2] : null;
	var contract = (segments.length > 4) ? segments[3] : null;
	var dataset = (segments.length > 5) ? segments[4] : null;
	var entity = (segments.length > 6) ? segments[5] : null;
	tracer.debug && tracer.debug("elasticSearch url segments: " + contract + "," + application + "," + dataset + "," + entity + "," + operation + " method=" + context.method);

	if (operation && _operationMap[operation]) {
		tracer.debug && tracer.debug("Search invoked via operation map");
		_operationMap[operation](_, context, contract, application, dataset, entity);
	} else if (context.method && _methodMap[context.method]) {
		tracer.debug && tracer.debug("Search invoked via method map");
		_methodMap[context.method](_, context, contract, application, dataset, entity);
	} else {
		context.reply(_, 404);
	}
	//		context.response.writeHead("301",{Location:request.url.replace("/search", "/syracuse-main/html/search.html")});
	//
	context.response.end();
};

function _config() {
	if (!serverConfig) {
		var config;
		try {
			config = require("config").searchEngine;
		} catch (e) {}
		serverConfig = exports.setup(config);
	}
	return serverConfig;
}

function _computeBaseUrl(searchConf) {
	return searchConf.baseUrl || ("http://" + (searchConf.hostname || "localhost") + (":" + (searchConf.port || 9200)));
}

exports.getBaseUrl = function() {
	return serverConfig.baseUrl || _computeBaseUrl(_config());
};

exports.setup = function(configOptions) {
	configOptions = configOptions || {};
	//tracer = configOptions.tracer;

	serverConfig.baseUrl = _computeBaseUrl(configOptions);
	var serverUrl = url.parse(serverConfig.baseUrl);
	serverConfig.hostname = serverUrl.hostname;
	serverConfig.port = +serverUrl.port || (serverUrl.protocol === 'https:' ? 443 : 80);

	//elasticIndex.tracer = tracer;
	//elasticQuery.tracer = tracer;
	//elasticVersion.tracer = tracer;
	return serverConfig;
};

exports.config = _config;

exports.search = elasticQuery.search;
exports.updateIndex = elasticIndex.updateIndex;
exports.deleteIndex = elasticIndex.deleteIndex;