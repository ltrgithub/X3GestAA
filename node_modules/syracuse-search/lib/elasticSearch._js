"use strict";

var Context = require("@sage/syracuse-lib/src/sdata/sdataContext").Context;
var elasticQuery = require("./elasticQuery");
var elasticIndex = require("./elasticIndex");
var elasticVersion = require("./elasticVersion");
var elasticHelpers = require('./helpers');
var flows = require('streamline-runtime').flows;

//var tracer = console.log;
var serverConfig = exports.serverConfig = {};
var tracer = require('@sage/syracuse-core').getTracer("search");

var _operationMap = {
	_update: require("./elasticIndex").updateIndex,
	_delete: require("./elasticIndex").deleteIndex,
	_search: require("./elasticQuery").search
};

var _methodMap = {
	"put": require("./elasticIndex").updateIndex,
	"delete": require("./elasticIndex").deleteIndex,
	"get": elasticQuery.search
};

/*
 function that check if we upgrade elastic search from 1.5 to 2.4 in order to reexecute the schedule indexation task register in syracuse to reindex data
 */
var taskRunned = [];
exports.checkUpdateVersion2 = function(_, db) {
	// check version
	try {
		var version = elasticVersion.getElasticVersion(_, serverConfig.baseUrl);
		if (version[0] === 2 && elasticVersion.hasNoIndexes(_, serverConfig.baseUrl)) {
			// check if some indexes are present and schedule task for indexation are defined
			var tab = db.fetchInstances(_, db.getEntity(_, "automate"));

			tab && tab.forEach_(_, function(_, item) {
				var tasks = item && item.automateTasks(_).toArray(_);
				tasks.forEach_(_, function(_, task) {
					var description = task.description(_);
					if (taskRunned.indexOf(description) && task.process(_).$type === "searchAdmin") {
						var diag = [];
						taskRunned.push(description);
						task.run(!_, diag, true)
					}
				})
			});
		}
	} catch (e) {
		// elastic search not started - nothin to do
		console.log("ERROR reschedule elastic on 2.4 ", e.stack);
	} finally {
		taskRunned = [];
	}

};


// url is like /search/[contract/][application/][entity/]_update
// or like /search?[index=contract&][type=entity][q=[field:]value&...]
exports.dispatch = function(_, request, response) {
	var context = new Context(request, response);
	var segments = request.url.split("?")[0].split("/");

	// operation is last segment
	var operation = segments[segments.length - 1];
	var application = (segments.length > 3) ? segments[2] : null;
	var contract = (segments.length > 4) ? segments[3] : null;
	var dataset = (segments.length > 5) ? segments[4] : null;
	var entity = (segments.length > 6) ? segments[5] : null;
	tracer.debug && tracer.debug("elasticSearch url segments: " + contract + "," + application + "," + dataset + "," + entity + "," + operation + " method=" + context.method);

	if (operation && _operationMap[operation]) {
		tracer.debug && tracer.debug("Search invoked via operation map");
		_operationMap[operation](_, context, contract, application, dataset, entity);
	} else if (context.method && _methodMap[context.method]) {
		tracer.debug && tracer.debug("Search invoked via method map");
		_methodMap[context.method](_, context, contract, application, dataset, entity);
	} else {
		context.reply(_, 404);
	}
	//		context.response.writeHead("301",{Location:request.url.replace("/search", "/syracuse-main/html/search.html")});
	//
	context.response.end();
};

exports.setup = function(configOptions) {
	configOptions = configOptions || {};
	//
	//tracer = configOptions.tracer;
	//
	serverConfig.hostname = configOptions.hostname || "localhost";
	serverConfig.baseUrl = elasticHelpers.getElasticBaseUrl(configOptions);
	if (!configOptions.excludePort) {
		// Not actually used anywhere
		serverConfig.port = configOptions.port || 9200;
	}

	//elasticIndex.tracer = tracer;
	elasticIndex.serverConfig = serverConfig;
	//
	//elasticQuery.tracer = tracer;
	elasticQuery.serverConfig = serverConfig;

	//elasticVersion.tracer = tracer;
	elasticVersion.serverConfig = serverConfig;
};

exports.search = elasticQuery.search;
exports.updateIndex = elasticIndex.updateIndex;
exports.deleteIndex = elasticIndex.deleteIndex;