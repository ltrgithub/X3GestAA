"use strict";

var streams = require("streamline/lib/streams/streams");
var locale = require("syracuse-core/lib/locale");
var sys = require("util");

exports.functionIndexName = "sage.x3.functions";
exports.fallbackLocale = "en-us";

exports.indexExists = function(_, baseUrl, indexName, options) {
	var opt = options || {};
	var par = {
		url: baseUrl + "/" + indexName,
		method: 'HEAD'
	};
	opt.tracer && opt.tracer("elasticIndex.index indexExists: url: " + par.url);
	// TODO: configure if elasticSearch really exists for this server
	try {
		var resp = streams.httpRequest(par).end().response(_);
		opt.tracer && opt.tracer("elasticIndex.index exists status: " + resp.statusCode);
		resp.readAll(_);
		return (resp.statusCode === 200);
	} catch (e) {
		if (!opt.silent) {
			if (e.code === "ECONNREFUSED") throw new Error(locale.format(module, "connRefused", baseUrl));
			else throw e;
		}
		return false;
	}
};
var _elasticVersion;

exports.checkElasticSearchVersion = function(_, url) {
	if (!_elasticVersion) {
		var options = {
			url: url,
			method: "GET"
		};
		var req = streams.httpRequest(options);
		var about = JSON.parse(req.end().response(_).readAll(_));
		_elasticVersion = about.version.number.split(".");
	}
	if (_elasticVersion[1] < 90 || _elasticVersion[2] < 5) {
		throw new Error(locale.format(module, "elasticSearchVersion", _elasticVersion[0] + "." + _elasticVersion[1] + "." + _elasticVersion[2]));
	}

};
exports.getIndexFacets = function(_, baseUrl, indexName, options) {
	var opt = options || {};
	// TODO: real pagination
	var par = {
		url: baseUrl + "/" + indexName + "/$facet/_search?q=*&size=1000",
		method: 'GET'
	};
	opt.tracer && opt.tracer("elasticIndex.index getIndexFacets: url: " + par.url);
	var resp = streams.httpRequest(par).end().response(_);
	opt.tracer && opt.tracer("elasticIndex.index getIndexFacets status: " + resp.statusCode);
	var content = resp.readAll(_);
	opt.tracer && opt.tracer("elasticIndex.index getIndexFacets content: " + content);
	if (resp.statusCode === 200) {
		content = JSON.parse(content);
		return ((content.hits && content.hits.hits) || []).map(function(h) {
			return h._source;
		});
	} else return [];
};