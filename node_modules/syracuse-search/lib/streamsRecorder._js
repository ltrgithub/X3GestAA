"use strict";
var helpers = require('syracuse-core/lib/helpers');
var util = require('util');
var ufs = require('streamline-fs');
var ubuf = require('buffer');
var datetime = require("syracuse-core/lib/types/datetime");
var upath = require('path');

var _tracer = console.log;


function _createFile(_, opts) {
	var opts = opts || {};
	var fileName = opts.fileName;
	try {
		var path = this._getFullPath(fileName);
		if (ufs.exists(_, path)) {
			if (fileName == null || opts.overwrite) {
				ufs.unlink(path, _);
			} else {
				var r = new RegExp(fileName + "_([\\d]+).json"),
					max = -1;
				var files = _self._getFileNames(_, function(file) {
					var name = upath.basename(file);
					if (name == fileName) return true;
					var num = -1;
					name.replace(r, function(p1, p2) {
						num = p2;
					});
					if (!isNaN(num) && num >= 0) {
						max = Math.max(max, num);
						return true;
					}
					return false;
				});
				path = this._getFullPath(fileName + "_" + (max + 1));
			}
		}
		ufs.appendFile(path, '', 'utf8', _);
		_tracer && _tracer("recordMgr._createFile :" + path);
		return path;
	} catch (e) {
		_logerr(e, "recordMgr._createFile - ERROR  - File '" + fileName + ".json'");
		fileName = null;
	}
};

function _log(txt) {
	_tracer(txt);
};

function _logerr(e, txt) {
	_log(txt);
	_log(e.stack ? e.stack : e.message ? e.message : e);
};


function _readJson(_, path) {
	try {
		var json = ufs.readFile(path, 'utf8', _) || "";
		json = json.trim();
		if (json.length == 0) throw new Error("Empty file");
		if (json[json.length - 1] == ',') json = json.substring(0, json.length - 1);
		json = "[" + json + "]";
	} catch (e) {
		throw new Error("Error reading record file [" + path + "]\n" + (e.message ? e.message : e));
	}
	try {
		json = JSON.parse(json);
		return json;
	} catch (e) {
		throw new Error("Error parsing record file [" + path + "]\n" + (e.message ? e.message : e));
	}
}



/// ## HttpRecorder constructor
/// ```
/// ```
/// create an http recorder that allow to record all http exchange and replay the exchange.
///
/// * The `httpStream` http streams
/// * The `file` file where the record will be store
/// * The `opts` record option that describe the fileName, file path, record mode (PLAY OR REC)...etc here a example of recOptions
/// ```javascript
/// var recOptions = {
///     recMode : "REC",
///     fileName : "toto"
/// };
/// ```
/// * The `config` parameter is used to identify different clients on the same server.
///
var HttpRecorder = exports.HttpRecorder = helpers.defineClass(function(_, httpStream, file, opts, config) {
	var self = this;
	self._filepath = this._getFullPath(opts.fileName);
	if (opts.recMode === "PLAY") {
		// read all steps
		self._step = _readJson(_, self._filepath);
	} else {
		self._file = file;

	}
	self._config = config;
	self._nbLines = 0;
	self._stream = httpStream;
	self._startRecord(_, opts);
}, null, {

	_getFullPath: function(fileName) {
		if (!fileName) fileName = ("record_" + new Date().toISOString()).replace(/[^\dA-Za-z]/g, '-');
		if (fileName.indexOf('.') == -1) fileName = fileName + ".json";
		return this._dumpDir + upath.sep + fileName;
	},
	end: function() {
		this._stopRecord();
		this._stream = null;
	},
	_stopPlay: function(_) {

	},
	_startPlay: function(_, opts) {
		var self = this;
		if (!self._stream) return;
		var stream = self._stream;
		self._saveHttpRequest = self._stream.httpRequest;
		stream.httpRequest = function(option) {
			if (option) self.dumpHttpRequest(option);
			return self._saveHttpRequest.call(option);
		};
		stream._saveReadAll = stream.readAll;
		stream.readAll = function(_) {
			var data = self._saveReadAll.call(_);
			if (data) self.dumpHttpResponse(_, data);

			return resp;
		};
		// !! First line - Contains information about record context displayed in cvgRecord entity
		self._dumpLine(_, {
			type: "RECINFO",
			data: opts
		});
		self.dumpComment(_, "Date : " + datetime.now().toString());
	},
	_startRecord: function(_, opts) {
		var self = this;
		if (!self._stream) return;
		var stream = self._stream;
		self._saveHttpRequest = self._stream.httpRequest;
		stream.httpRequest = function(option) {
			if (option) self.dumpHttpRequest(option);

			return self._saveHttpRequest.call(option);

		};
		stream._saveReadAll = stream.readAll;
		stream.readAll = function(_) {
			var data = self._saveReadAll.call(_);
			if (data) self.dumpHttpResponse(_, data);

			return resp;
		};
		// !! First line - Contains information about record context displayed in cvgRecord entity
		self._dumpLine(_, {
			type: "RECINFO",
			data: opts
		});
		self.dumpComment(_, "Date : " + datetime.now().toString());
	},
	_stopRecord: function() {
		var self = this;
		// Remove dump handlers on stream object
		// close is needed for reused clients
		try {
			if (!self._stream) return;
			if (self._saveReadAll) {
				self._stream.readAll = self._saveReadAll;
				self._saveReadAll = null;
			}
			if (self._saveHttpRequest) {
				self._stream.httpRequest = self._saveHttpRequest;
				self._saveHttpRequest = null;
			}
		} catch (e) {
			console.log("recorder.close error - " + (e.message ? e.message : e));
		};
	},
	dumpComment: function(_, txt) {
		var line = {
			type: "COMMENT",
			data: txt
		};
		this._dumpLine(_, line);
	},

	dumpHttpRequest: function(_, options) {
		var line = {
			type: "HTTPREQ",
			data: JSON.stringify(options) || ""
		};
		this._dumpLine(_, line);
	},
	dumpHttpResponse: function(_, data) {
		var line = {
			type: "HTTPRESP",
			data: data || ""
		};
		this._dumpLine(_, line);
	},
	_dumpLine: function(_, line) {
		var record = this._nbLines > 0 ? ",\n" : "";
		record += JSON.stringify(line);
		ufs.appendFile(this._file, record, 'utf8', _);
		this._nbLines++;
	},

});

exports.createRecorder = function(_, stream, opts, config) {
	try {
		var conf = config ? config : {};
		// Record client _self.config in order to restore them in player

		return new HttpRecorder(_, stream, _createFile(_, opts), opts, conf);
	} catch (e) {
		_logerr(e, "recordMgr - ERROR - Can't create recorder");
		throw e;
	}
};