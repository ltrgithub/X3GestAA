"use strict";

var sdataRegistry = require("syracuse-sdata/lib/sdataRegistry");
var streams = require("streamline/lib/streams/streams");
var elasticHelpers = require("syracuse-search/lib/helpers");
var helpers = require('syracuse-core/lib/helpers');
var forEachKey = helpers.object.forEachKey;
var jsurl = require("jsurl");
//var indexMeta = require("syracuse-search/lib/indexMeta");
var sys = require("util");
var locale = require("syracuse-core/lib/locale");
var datetime = require("syracuse-core/lib/types/datetime");

var httpHelper = require("syracuse-sdata/lib/httpHelper");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var Parser = require("syracuse-sdata/lib/parser/parser").Parser;
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require


exports.tracer = null;
exports.serverConfig = null;
var elasticVersion = null;


var formatDate = [
	"dd-mm-yy",

];

function _indexToContract(indexName) {
	var parts = indexName.split(".");
	return sdataRegistry.getContract(parts[0], parts[1], false);
}

function _getTypeTitle(mapping, typeName) {
	var title = typeName;
	Object.keys(mapping).forEach(function(idx) {
		var map = mapping[idx][typeName];
		if (map && map._meta && map._meta.$classTitle) title = map._meta.$classTitle;
	});
	return title;
}

function _addFacets(query, contract) {
	if (!contract || !contract.searchFacets) return;
	query.facets = query.facets || {
		type: {
			terms: {
				field: "_type"
			}
		}
	};
	forEachKey(contract.searchFacets, function(key, facet) {
		query.facets[key] = {
			terms: {
				fields: ["facet_" + key]
			}
		};
	});
}

function _addFilters(query, filters) {
	if (!filters) return;
	if (!Object.keys(filters).some(function(k) {
		return (k !== "type");
	})) return;
	//
	var filter = query.filtered.filter = query.filtered.filter || {};
	filter.and = filter.and || [];
	forEachKey(filters, function(key, facet) {
		if (key === "type") return;
		//
		var part = {
			query: {
				terms: {}
			}
		};
		part.query.terms["facet_" + key] = facet.slice(0);
		filter.and.push(part);
	});
}

function _makeFilterFromSdata(where) {
	function _left(where) {
		var result = "";
		if (!where) return result;
		switch (where.type) {
			case "operator":
				switch (where.value.code) {
					case ".":
						result = _left(where.children[0]) + "." + _left(where.children[1]);
						break;
					default:
						throw new Error("_left : \"" + where.value.code + "\" not yet implemented");
				}
				break;
			default:
				result = where.value;
		}
		return result;
	}

	function _format(value, isDate) {
		return isDate ? new Date(value) : ((typeof value === "object") && value.toString()) ? value.toString() : value;
	}

	var result = {};
	var isDate = false;
	switch (where.type) {
		case "operator":
			switch (where.value.code) {
				case "and":
					if (where.children.length < 2) throw new Error("Invalid \"AND\" condition");
					result = {
						and: [_makeFilterFromSdata(where.children[0]), _makeFilterFromSdata(where.children[1])]
					};
					break;
				case "or":
					if (where.children.length < 2) throw new Error("Invalid \"OR\" condition");
					result = {
						or: [_makeFilterFromSdata(where.children[0]), _makeFilterFromSdata(where.children[1])]
					};
					break;
				case "=":
					result.query = {
						field: {}
					};
					result.query.field[_left(where.children[0])] = _format(where.children[1].value, isDate);
					break;
				case "like":
					var right = where.children[1] && _format(where.children[1].value, isDate);
					if (right.charAt(0) != "%") right = "^" + right;
					right = right.replace(/%/g, ".*");
					result.regexp = {};
					result.regexp[_left(where.children[0])] = right;
					break;
				case "in":
					right = where.children.slice(1).map(function(c) {
						return c && _format(c.value, isDate);
					});
					result.terms = {};
					result.terms[_left(where.children[0])] = right;
					break;
				default:
					// range ?
					if (["<", "<=", ">=", ">", "between"].indexOf(where.value.code)) {
						var rg;
						if (typeof where.children[1] === "number") rg = result.numeric_range = {};
						else rg = result.range = {};
						var l = rg[_left(where.children[0])] = {};
						var r = _format(where.children[1].value, isDate);
						switch (where.value.code) {
							case "<":
								l.lt = r;
								break;
							case "<=":
								l.lte = r;
								break;
							case ">":
								l.gt = r;
								break;
							case ">=":
								l.gte = r;
								break;
							case "between":
								l.gte = r;
								l.lte = _format(where.children[2].value, isDate);
								break;
						}
					}
			}
			break;
		default:
			throw new Error(where.type + " not yet implemented");
	}
	return result;
}

function _addSdataWhere(query, where) {
	// accept string sdata clause or parsed sdata clause
	if (where && (typeof where === "string")) where = Parser.parse(where);
	//
	return query.filtered.filter = _makeFilterFromSdata(where);
	//
	/*var filter = query.filtered.filter = query.filtered.filter || {};
	filter.and = filter.and || [];
	//
	filter.and.push(_makeFilterFromSdata(where));*/
}

var _prototype = {};

function _updateResource(_, hit, properties, resource) {
	// get prototype store in elasticSearch 

	var sSource = hit._source;
	var sHighlight = hit.highlight;

	var baseUrl = [exports.serverConfig.baseUrl].join('/');
	var options = {
		method: "GET"
	};
	var prop;
	if (hit._type != "function") {
		options.url = baseUrl + "/" + hit._index + "_entities" + "/$entities/" + hit._type;
		if (_prototype[options.url]) {
			prop = _prototype[options.url];
		} else {
			var req = streams.httpRequest(options);
			var proto = JSON.parse(req.end().response(_).readAll(_));
			// manage summary for syracuse but use search for x3
			prop = proto._source.$prototype.$properties.$resources ? proto._source.$prototype.$properties.$resources.$item.$properties : proto._source.$prototype.$properties;
			_prototype[options.url] = prop;
		}
	} else {

		options.url = baseUrl + "/" + hit._index + "/_mapping/";
		if (_prototype[options.url]) {
			prop = _prototype[options.url];
		} else {
			var req = streams.httpRequest(options);
			var mapping = JSON.parse(req.end().response(_).readAll(_));
			prop = mapping[hit._index].

			function.properties;
			_prototype[options.url] = prop;

		}
	}

	if (prop) {
		var res = {

		};


		Object.keys(prop).map(function(k) {
			var hh = k;

			function _getSubProperties(propItem) {
				if (Object.keys(propItem).length === 0) {
					return null;
				} else if (Object.keys(propItem.$item).indexOf("$properties") > 0) {
					return propItem.$item.$properties;
				} else {
					return _getSubProperties(propItem.$item);
				}
			};

			function getRecord(propItem, hh) {
				var res = {
					properties: {},
					resource: {}
				};
				if (typeof propItem === "object") {
					if (propItem.$type !== "application/x-array" && propItem.$type !== "application/x-object") {
						// check if properties is date and is highlight -> elastic search doesn't manage that 
						var p = {
							$isSummary: propItem.$isSummary || propItem.$type === "application/x-date" ? true : false,
							$isHighlight: (sHighlight && sHighlight[hh] ? true : false),
							$title: propItem.$title
						};
						var r = sHighlight && sHighlight[hh] && hh !== "$url" ? (sHighlight[hh].length > 1 ? sHighlight[hh] : sHighlight[hh][0]) : sSource[hh.indexOf(".") !== -1 ? hh.split(".").slice(-1) : hh];
						res.properties = p;
						res.resource = r;

					} else {
						if (propItem.$item.$type === "application/x-reference") {
							res = getRecord(propItem.$item, hh);
							res.properties.$title = propItem.$title;
						} else {
							var psub = _getSubProperties(propItem);
							if (psub) {
								Object.keys(psub).map(function(key) {
									var hl = hh !== "" ? hh + "." + key : key;
									var resp = getRecord(psub[key], hl);
									res.properties[key] = resp.properties;
									if (resp.resource) {
										res.resource[key] = resp.resource;
									}
								});
							}
						}
					}
				}
				return res;
			};


			function getRecordFunction(key, propItem, hh) {
				var res = {
					properties: {},
					resource: {}
				};
				if (typeof propItem === "object") {
					if (propItem.type) {
						var p = {
							$isSummary: key.indexOf('$') !== 0 ? true : false,
							$isHighlight: (sHighlight && sHighlight[hh] && hh !== "$url") ? true : false,
							$title: key
						};

						var r = sHighlight && sHighlight[hh] && hh !== "$url" ? (sHighlight[hh].length > 1 ? sHighlight[hh] : sHighlight[hh][0]) : sSource[hh.indexOf(".") !== -1 ? hh.split(".").slice(-1) : hh];
						res.properties = p;
						res.resource = r;

					} else {
						Object.keys(propItem.properties).map(function(key) {
							hh += hh !== "" ? "." + key : key;
							var resp = getRecordFunction(key, propItem.properties[key], hh);
							res.properties[key] = resp.properties;
							if (resp.resource) {
								res.resource[key] = resp.resource;
							}
						});
					}
				}
				return res;
			};

			var res = hit._type != "function" ? getRecord(prop[k], hh) : getRecordFunction(k, prop[k], hh);
			properties[k] = res.properties;
			resource[k] = res.resource;
		});
	}

}

function _getDescriptionResult(source, highlight) {
	var hgl = highlight || {};
	var r;
	var hh = Object.keys(hgl).map(function(pp) {
		return pp[0] === "$" ? "" : highlight[pp].join(", ");
	}).filter(function(it) {
		return it;
	}).join(", ");
	if (Array.isArray(source)) {
		r = source.map(function(item) {
			return _getDescriptionResult(item);
		}).filter(function(item) {
			return item;
		}).join(", ");
	} else if (typeof source === "object") {
		r = Object.keys(source).filter(function(k) {
			return (k[0] !== "$") && !hgl[k]; // TODO: manage a prefix for references as in highlight dot notation is used
		}).map(function(k) {
			return _getDescriptionResult(source[k]);
		}).filter(function(item) {
			return item;
		}).join(", ");
	} else r = (typeof source === "string" ? source : source.toString());
	if (hh) r = hh + ", " + r;
	return (r.length > 512) ? r.substr(0, 512) + " ..." : r;
}

function _makeFunctionResource(_, endpoint, mapping, hit, isMultiEP) {

	var title = _getTypeTitle(mapping, hit._type);
	// items base url
	var localized = isMultiEP ? locale.format(module, "functionMultiDescription", hit._source.$description, endpoint.description(_)) : locale.format(module, "functionMonoDescription", hit._source.$description);
	var r = {
		$url: hit._source.$url,
		$baseUrl: endpoint.getBaseUrl(_),
		$uuid: hit._id,
		//type: title,
		$resultTypeTitle: title,
		$representation: hit._type,
		title: localized,
		//$title: localized,
		//description: _getDescriptionResult(hit._source, hit.highlight),
		icon: (hit._source.$icon ? {
			$url: hit._source.$icon,
			$type: "image"
		} : null),


	};
	var prop = {};
	_updateResource(_, hit, prop, r);
	r.$properties = prop;

	if (hit._source.linkType === "$function") r.$baseUrl = r.$baseUrl.replace("/sdata/", "/trans/");
	return r;
}

function _makeResource(_, mapping, hit, representation, resFormat) {
	var title = _getTypeTitle(mapping, hit._type);
	// items base url
	// hint: for now, $description goes into title and description is a concatenation of all fields
	var r;
	switch (resFormat) {
		case "$query":
		case "$lookup":
		case "$select":
			r = hit._source;
			break;
		default:
			var prop = {};
			r = {
				$url: hit._source.$url,
				$uuid: hit._id,
				//type: title,
				$resultTypeTitle: title,
				$representation: hit._type,
				title: hit._source.$description,
				//$title: hit._source.$description,
				//description: _getDescriptionResult(hit._source, hit.highlight),
				icon: (hit._source.$icon ? {
					$url: hit._source.$icon,
					$type: "image"
				} : null),
			};
			_updateResource(_, hit, prop, r);
			r.$properties = prop;

	}
	// substitute representation for given representation
	if (representation !== "queryResult") r.$url = r.$url.replace(/representation=.*\.\$/, "representation=" + representation + ".$");
	//
	r.$key = hit._id;
	return r;
}

//select existing indexes available to the user

function _selectIndexes(_, elasticBaseUrl, userProfile, sources, selectedIndexName) {
	function _addIndex(_, indexName, localeCode) {
		var idx = indexName + "." + localeCode.toLowerCase();
		if (elasticHelpers.indexExists(_, elasticBaseUrl, idx)) indexes.push(idx);
		else(localeCode !== elasticHelpers.fallbackLocale) && _addIndex(_, indexName, elasticHelpers.fallbackLocale);
	}

	function _addEP(_, ep, localeCode) {
		var idx = ep.getIndexName(_, localeCode || locale.current);
		if (elasticHelpers.indexExists(_, elasticBaseUrl, idx)) {
			indexes.push(idx);
		} else(localeCode !== elasticHelpers.fallbackLocale) && _addEP(_, ep, elasticHelpers.fallbackLocale);
	}
	//
	var indexes = [];
	if (sources.indexOf("data") >= 0) {
		if (selectedIndexName) _addIndex(_, selectedIndexName, locale.current);
		else {
			if (userProfile) {
				if (userProfile.selectedEndpoint(_)) _addEP(_, userProfile.selectedEndpoint(_));
				else {
					userProfile.endpoints(_).toArray(_).forEach_(_, function(_, endpoint) {
						_addEP(_, endpoint);
					});
				}
			}
		}
	}
	if (sources.indexOf("functions") >= 0) {
		var epF = userProfile.selectedEndpoint(_);
		_addIndex(_, elasticHelpers.functionIndexName + "." + epF.application(_).toLowerCase() + "." + epF.contract(_).toLowerCase() + "." + epF.dataset(_).toLowerCase(), locale.current);
	}
	//
	return indexes;
}

// select endpoints available to the user

function _selectEndpoints(_, userProfile) {
	var eps = [];
	if (userProfile) {
		if (userProfile.selectedEndpoint(_)) {
			eps.push(userProfile.selectedEndpoint(_));
		} else {
			eps = userProfile.endpoints(_).toArray(_).slice(0);
		}
	}
	return eps;
}


function _isSupportEditDistance() {
	if (elasticVersion.length !== 3) return false;
	else if (elasticVersion[0] > 0) return true;
	else {
		if (elasticVersion[1] >= 90)
			return true;
		return false;
	}


}

//issue 3171 check if string is a date and convert to the right string to search else return query entered

function _convertDateToString(q) {
	function getDateStr(arr) {
		if (arr.length === 3) {
			if (arr[2].length === 4)
				return arr.reverse().join("-");
			if (arr[0].length === 4)
				return arr.join("-");
		}
		return arr.join("-") + " OR " + arr.reverse().join("-");
	}
	try {

		// try to get date from all kind of format 
		var r = /(\d*)[^A-Za-z_0-9](\d*)[^A-Za-z_0-9](\d*)/.exec(q);
		r = r && r.slice(1);
		//console.log("regexp " + JSON.stringify(r, null, 2));
		if (r && r.length > 1) {
			var rUs;
			if (r.length === 3) {
				if ([2].length === 4) {
					// change day and month for american format
					rUs = [r[1], r[0], r[2]];
				} else {
					rUs = [r[0], r[2], r[1]];
				}
			}
			return getDateStr(r) + (rUs ? " OR " + getDateStr(rUs) : "");
		}

		var d = new Date(q);
		//console.log("date " + d);
		if (d.getFullYear()) {
			var date = d.getDate();
			var month = d.getMonth() + 1;
			var year = d.getFullYear();
			// it's a date -> create a new query in x3 raw date format and elastic search format
			return year + "-" + (month < 10 ? "0" + month : month) + "-" + (date < 10 ? "0" + date : date);
		}
		return null;
	} catch (e) {
		//console.log(e.stack);
		// not a date - continu in standard
		return null;
	}
}

exports.search = function(_, context) {
	// get version of elastic search 
	var urlSegs = [exports.serverConfig.baseUrl];

	if (!elasticVersion) {
		var options = {
			url: urlSegs.join("/"),
			method: "GET"
		};
		var req = streams.httpRequest(options);
		var about = JSON.parse(req.end().response(_).readAll(_));
		elasticVersion = about.version.number.split(".");
	}

	var sources = (context.parameters.source || "data").split(",");
	var filters = jsurl.parse(context.parameters.filters);
	var where = context.parameters.where;
	var adminEP = adminHelper.getCollaborationEndpoint(_);
	var up = context.getUserProfile(_);
	// TODO: as we cannot match an entity and his index, we should execute search one index at a time
	// to allow search on index1.entity1 and index2.entity2 but not index1.entity2
	// for now just push entities into allEntities.
	//
	// load index names
	var allEntities = [];
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	var indexNames = _selectIndexes(_, elasticBaseUrl, up, sources, (filters && filters.index && filters.index[0]) || context.searchIndexName);
	var endpoints = _selectEndpoints(_, up);
	exports.tracer && exports.tracer("elasticQuery.indexNames: " + sys.inspect(indexNames));
	if (!indexNames.length) return context.reply(_, httpHelper.HttpStatus.NotFound, locale.format(module, "noIndexAvailable", locale.current, elasticHelpers.fallbackLocale));
	//
	//console.log("elasticQuery.context.parameters: " + sys.inspect(context));
	var contextEntity = context.searchEntityName || context.representation.entity;
	var entityName = context.parameters.entity || (contextEntity !== "queryResult" ? contextEntity : "");
	if (entityName) allEntities.push(entityName);
	// entity filter; overrides any entity parameters
	if (filters && filters.type) allEntities = filters.type.slice(0);
	// TODO : entity filter - when user has entity restrictions, generate an entity name like entity1,entity2,entityN
	//
	indexNames.length && urlSegs.push(indexNames.join(","));
	allEntities.length && urlSegs.push(allEntities.join(","));
	// Get Mappings
	var options = {
		url: urlSegs.join("/") + "/_mapping",
		method: "GET"
	};
	var req = streams.httpRequest(options);
	var mappings = JSON.parse(req.end().response(_).readAll(_));
	// if there is one entity only, mappings won't have the index name node. So add it to simplify code
	/*	if((allEntities.length === 1) && (indexNames.length === 1))
		mappings = {
			"index": mappings
		}*/
	var mapKeys = mappings && Object.keys(mappings);
	if (mapKeys && mapKeys.length)
	// first level is NOT an index name ?
		if (indexNames.indexOf(mapKeys[0]) < 0)
		// normalize mappings structure
			mappings = {
				"index": mappings
			};
		//
	exports.tracer && exports.tracer("elasticQuery.search mappings. Url: " + urlSegs.join("/") + "/_mapping ; result" + sys.inspect(mappings, null, 5));
	// Search
	options = {
		url: urlSegs.join("/") + "/_search",
		method: "POST"
	};

	req = streams.httpRequest(options);
	var q = context.parameters.q || context.parameters.search;
	var queryDate = _convertDateToString(q);

	var isFuzzySearch = context.parameters.fuzzy;

	// Set up the skeleton of the search before we decide which
	// type of query we will actually be using.
	var search = {
		from: context.parameters.startIndex - 1,
		size: context.parameters.count,
		query: {
			filtered: {
				query: {}
			}
		},
		highlight: {
			fields: {
				"*": {}
			}
		}
	};

	// analyse if we entered a date of not

	var isAroundQuote = false;
	var editDistance = config.searchEngine && config.searchEngine.editDistance ? config.searchEngine.editDistance : 2;

	var qstr = "";
	// issue 2918 prevent elastic search syntax error 
	if (q.indexOf("/") >= 0) {
		q = q.replace(/\//g, "");
	}

	// Analyse the search string to decide the best query type to use
	// If the query string already includes characters that would make it a complex
	// query, regular expression or suchlike then assume that the user knows what
	// they are doing and simply pass the query string "as is"

	var queryStr;
	if (!isFuzzySearch || q.indexOf("*") >= 0 || q.indexOf("[") >= 0) {
		exports.tracer && exports.tracer("elasticQuery.search - Found complex regexp query");
		queryStr = q;
	} else {
		// Split into words - regexp /s+/ doesn't seem to work
		var terms = q.split(" ");
		var first = terms[0];
		var last = terms[terms.length - 1];
		// check if first and last term are character " or not 
		isAroundQuote = terms && terms.length >= 0 && first[0] === "\"" && last[last.length - 1] === "\"";


		// iterate over the words, building back into a query string
		exports.tracer && exports.tracer("elasticQuery.search - Fuzzify search terms : " + terms);
		for (var t = 0; t < terms.length; t++) {
			// Append a space between the search terms
			if (qstr !== "")
				qstr += " ";
			var unquoteTerm = terms[t].replace(/\"/g, "");
			var tlower = unquoteTerm.toLowerCase();
			if (tlower == "or" || tlower == "and") {
				// Boolean operators simply get appended
				qstr += unquoteTerm;
			} else {
				// ordinary search term - add and fuzzify
				qstr += unquoteTerm;
				if (!isAroundQuote && terms[t].length > 0) {
					qstr += "~" + (_isSupportEditDistance() && editDistance ? editDistance : ""); //fuzzy each word
				}
			}
		}
		queryStr = (isAroundQuote ? "\"" + qstr + "\"~" + (_isSupportEditDistance() && editDistance ? editDistance : "") : qstr);

	}

	var queryCheckDate = queryDate ? queryDate + " OR " + queryStr : queryStr;
	// Finally plug the query string into the query filter
	search.query.filtered.query.query_string = {
		default_field: "_all",
		query: q + " OR " + queryCheckDate, // fuzzy all string if around quote

		//default_operator: "AND",
		analyze_wildcard: true,
		allow_leading_wildcard: false
	};
	//
	var facetsMap = {};
	indexNames.forEach_(_, function(_, indexName) {
		facetsMap = elasticHelpers.getIndexFacets(_, elasticBaseUrl, indexName, {
			tracer: exports.tracer
		}).reduce(function(prev, f) {
			prev[f.code] = f;
			return prev;
		}, facetsMap);
	});
	_addFacets(search, {
		searchFacets: facetsMap
	});
	exports.tracer && exports.tracer("elasticQuery.search facetsMap: " + sys.inspect(facetsMap, null, 4));
	//
	filters && _addFilters(search.query, filters);
	where && _addSdataWhere(search.query, where);
	//
	exports.tracer && exports.tracer("elasticQuery.search query: " + sys.inspect(search, null, 8));
	//
	req.write(_, JSON.stringify(search));

	//console.log("url " + require("util").inspect(options));


	// added for unit test in order to validate the request send to elastic search 
	context.searchRequest = search;
	var resp = req.end().response(_);
	var respData = JSON.parse(resp.readAll(_));
	//console.log("elasticQuery.search response: " + sys.inspect(respData, null, 5));
	//
	if (respData.error) return context.reply(_, respData.status, respData.error);
	//
	var resultRes = {
		$resources: []
	};
	// create resources
	var fEp = endpoints.slice(0);
	if (adminEP && up.endpoints(_).get(_, adminEP.$uuid) && !fEp.some_(_, function(_, ep) {
		return ep.protocol(_) === "syracuse";
	})) fEp.push(adminEP);
	if (respData.hits && respData.hits.hits) respData.hits.hits.forEach_(_, function(_, hit) {

		//console.log("--------------type "+hit._type);
		// replace source element by hightlight when necessary
		if (hit._type !== "$entities") {
			if (hit._type === "function") {
				var r = hit._source.$rawData;
				r && _selectEndpoints(_, up).forEach_(_, function(_, e) {
					if (r.endpoint && (e.$uuid !== r.endpoint)) return;
					if (r.application && (e.applicationRef(_).$uuid !== r.application)) return;
					if (resultRes.$resources.length >= search.size) return;
					resultRes.$resources.push(_makeFunctionResource(_, e, mappings, hit, endpoints.length > 1));
				});
			} else resultRes.$resources.push(_makeResource(_, mappings, hit, context.representation ? context.representation.entity : context.searchEntityName, context.representation.type));
		}
	});
	// create search facets

	function membersMap(item) {
		var facetMember = {
			$title: item.term,
			$value: item.term,
			$count: item.count,
			$links: {}
		};
		if (facet === "type") facetMember.$title = _getTypeTitle(mappings, item.term);
		// filters
		if (filters && filters[facet])
			if (Array.isArray(filters[facet]) && (filters[facet].indexOf(item.term) >= 0)) facetMember.$selected = true;
			// links
		return facetMember;
	}
	var facet;
	if (respData.facets) {
		resultRes.$searchFacets = [];
		for (facet in respData.facets) {
			var facetDef = {};
			if (facet === "type") facetDef = {
				$title: "Type"
			};
			else facetDef = facetsMap[facet];
			resultRes.$searchFacets.push({
				$facet: facet,
				$title: facetDef.description,
				$missing: respData.facets[facet].missing,
				$members: (respData.facets[facet].terms || []).map(membersMap)
			});
		}
	}
	//
	resultRes.query = context.parameters.q || context.parameters.search;
	/*if (resultRes.$resources.length < search.size) {
		context.totalCount = resultRes.$resources.length;
	} else {*/
	context.totalCount = respData && respData.hits && respData.hits.total;
	//}
	context.replySearchResults(_, 200, resultRes);

	// purge list of prototype read - optim search 
	_prototype = {};
};