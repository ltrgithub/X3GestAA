"use strict";

var sdataRegistry = require("syracuse-sdata/lib/sdataRegistry");
var dataModel = require("syracuse-orm/lib/dataModel");
var http = require("http");
var streams = require("streamline/lib/streams/streams");
var helpers = require('syracuse-core/lib/helpers')
var forEachKey = helpers.object.forEachKey;
var pluralize = helpers.string.pluralize;
var jsurl = require("jsurl");
var querystring = require("querystring");
var indexMeta = require("syracuse-search/lib/indexMeta");
var sys = require("util");

exports.tracer = null;
exports.serverConfig = null;

function _shortIndexName(indexName) {
	return indexName.split(".").slice(-3).slice(0, 2).join(".");
}

function _indexToContract(indexName) {
	var parts = indexName.split(".").slice(-3);
	return sdataRegistry.getContract(parts[0], parts[1], false);
}

function _getMeta(indexName, typeName) {
	var contract = _indexToContract(indexName);
	if(contract && contract.entities[typeName])
		return contract.entities[typeName];
	var shortIndexName = _shortIndexName(indexName);
	if(indexMeta.index[shortIndexName] && indexMeta.index[shortIndexName].entities[typeName])
		return indexMeta.index[shortIndexName].entities[typeName];
}

function _getTitle(meta) {
	return (meta.$titleTemplate && meta.$titleTemplate.expression) || meta.$title;
}

function _getPlural(meta) {
	return meta.$plural || pluralize(meta.name);
}

function _addFacets(query, contract) {
	if (!contract || !contract.searchFacets) return;
	query.facets = query.facets || {
		type: {
			terms: {
				field: "_type"
			}
		}
	};
	forEachKey(contract.searchFacets, function(key, facet) {
		query.facets[key] = {
			terms: {
				fields: ["facet_"+key]
			}
		};
	});
}

function _addFilters(query, filters) {
	if(!filters) return;
	var filter = query.filtered.filter = query.filtered.filter || {};
	filter.and = filter.and || [];
	forEachKey(filters, function(key, facet) {
		if(key === "type") return;
		//
		var part = { query: { terms: {}}};
		part.query.terms["facet_"+key] = facet.slice(0);
		filter.and.push(part);
	});
}

exports.search = function(_, context, contractName, applicationName, datasetName, entityName) {
	var filters = jsurl.parse(context.parameters.filters);
	// TODO: as we cannot match an entity and his index, we should execute search one index at a time
	// to allow search on index1.entity1 and index2.entity2 but not index1.entity2
	// for now just push entities into allEntities.
	//
	// load index names
	var indexNames = [];
	var allEntities = [];
	var searchIndexName = (filters && filters.index && filters.index[0]) || context.searchIndexName;
/*	if(searchIndexName) {
		// extract index and entities names
		// index names syntax example : a1.c1.d1.ent1,a1.c2.d2[ent2,ent3], ...
		indexNames = searchIndexName.match(/.*?((\[.*?\])|,|$)/g).filter(
				function(item) {
					// regexp noise
					return ((item != "") && (item != ","));
				}).map(
					function(indexName) {
						//
						var segs = indexName.split(".");
						// extract entities
						var ent = indexName.match(/(\[.*\])/);
						if(ent && ent.length)
							ent[0].slice(1,-1).split(",").forEach(function(entity) {
								allEntities.push(entity);
							});
						else	
							// entity is 4th segment
							segs[3] && allEntities.push(segs[3].split(",")[0]);
						// index name is allways first 3 segments
						segs[2] = segs[2].split("[")[0];
						return segs.slice(0,3).join(".");
					});
		exports.tracer && exports.tracer("elasticQuery.searchIndexNames: "+sys.inspect(indexNames)+"; entities: "+sys.inspect(allEntities));
	} else {*/
	if(searchIndexName) 
		indexNames.push(searchIndexName)
	else {
		var userProfile = context.getUserProfile(_);
		if(userProfile) {
			if(userProfile.selectedEndpoint(_))
				indexNames.push(userProfile.selectedEndpoint(_).getIndexName(_));
			else
				userProfile.endpoints(_).toArray(_).forEach_(_, function(_, endpoint) {
					endpoint.enableSearch(_) && indexNames.push(endpoint.getIndexName(_));
				});
		}
	}
	// allow searching on default index, temporary for demos
	if(indexNames.length == 0)
		indexNames.push("syracuse.collaboration.syracuse");
	exports.tracer && exports.tracer("elasticQuery.indexNames: "+sys.inspect(indexNames));
	//
	entityName = context.searchEntityName || entityName;
	if(entityName) allEntities.push(entityName);
	// entity filter; overrides any entity parameters
	if(filters && filters.type) 
		allEntities = filters.type.slice(0);
	// TODO : entity filter - when user has entity restrictions, generate an entity name like entity1,entity2,entityN
	//
	var options = {
		url: exports.serverConfig.baseUrl + "/" + (indexNames.length?indexNames.join(",")+"/" : "") + (allEntities.length?allEntities.join(",")+"/" : "") + "_search",
		method: "POST"
	};
	var req = streams.httpRequest(options);
	//	var q = context.parameters.q || (require("querystring").parse(context.request.readAll(_).toString()) || {}).q;
	var q = context.parameters.q;
	var search = {
		from: context.parameters.startIndex - 1,
		size: context.parameters.count,
		query: {
			filtered: {
				query: {
					field: {
						_all: q
					}
				},
				filter: { // right management example
					and: [{
						or: [{
							query: {
								field: {
									authorizations: "Administrator"
								}
							}
						}, {
							missing: {
								field: "authorizations"
							}
						}]
					}]
				}
			}
		}
	};
	//
	indexNames.forEach_(_, function(_, indexName) {
		var contract = _indexToContract(indexName);
		contract && _addFacets(search, contract);
	});
	//
	filters && _addFilters(search.query, filters);
	//
//	console.log("query: " + sys.inspect(search, null, 8));
	//
	req.write(_, JSON.stringify(search));
	var resp = req.end().response(_);
	var respData = JSON.parse(resp.readAll(_));
	exports.tracer && exports.tracer("elasticQuery.search response: " + sys.inspect(respData, null, 5));
	var resultRes = {
		$resources: []
	};
	// items base url
	var url = "/sdata/";
	// create resources
	if (respData.hits && respData.hits.hits) respData.hits.hits.forEach(function(hit) {
		var meta = _getMeta(hit._index, hit._type);
		var title = _getTitle(meta);
		var plural = _getPlural(meta);
		resultRes.$resources.push({
			// we just manage the case when data call is on the same host. We can add later host:port as they are first 2 index name parts
			$url: hit._source.$url,
			$baseUrl: url + (hit._index || "").split(".").slice(-3).join("/"),
			$uuid: hit._id,
			$key: (meta && hit._source[meta.$key]) || hit._id,
			type: title,
			$representation: hit._type,
			$pluralType: plural,
			description: hit._source.$description,
			icon: (hit._source.$icon?{$url: hit._source.$icon, $type: "image"}:null),
			$links:{
				$query: {
					$title: "List of "+pluralize(title)
				}
			},
			$: {
				description: {
					$links: {
						$details: {
							$title: "Details",
							$type: "application/json;vnd.sage=syracuse",
							$url: "{$url}"
						}
					}
				}
			}
		});
	});
	// create search facets
	var facet;
	if (respData.facets) {
		resultRes.$searchFacets = [];
		for (facet in respData.facets) {
			var facetDef = {};
			if(facet === "type")
				facetDef = {$title:"Type"};
			else
				// search facet, TODO: optimize
				indexNames.forEach(function(name) {
					var contract = _indexToContract(name);
					if(contract)
						facetDef = contract.searchFacets[facet] || {};
					else {
						var index = indexMeta[_shortIndexName(name)];
						if(index)
							facetDef = index.searchFacets[facet] || {};
					}
				});
//			var facetDef = contract.searchFacets[facet] || {};
			var facetLookupDef = facetDef.$lookup;
			var facetBaseUrl = "/sdata/"+applicationName+"/"+contractName+"/"+datasetName+"/";
			resultRes.$searchFacets.push({
				$facet: facet,
//				$title: facet,
				$title: facetDef.$title,
				$missing: respData.facets[facet].missing,
				$members: (respData.facets[facet].terms || []).map(function(item) {
					var facetMember = {$title:item.term, $count:item.count,$links:{}};
					// filters
					if(filters && filters[facet])
						if(Array.isArray(filters[facet]) && (filters[facet].indexOf(item.term) >= 0))
							facetMember.$selected = true;
					// links
/*					if(facetLookupDef) {
						var detWhere = querystring.stringify({where: facetLookupDef.$keyField+" eq "+"'"+item.term+"'"});
						facetMember.$links.$query = {
							$title: "List of " + contract.entities[facetLookupDef.$entity].plural,
							$url: facetBaseUrl + contract.entities[facetLookupDef.$entity].plural + "?representation=" + facetLookupDef.$entity + ".$query&role={$role}",
							$type: "application/json;vnd.sage=syracuse"
						}
					}*/
					return facetMember;
				})
			});
		}
//		console.log("facets: "+sys.inspect(respData.facets, null, 4));
	}
	//
	context.totalCount = respData && respData.hits && respData.hits.total;
	context.replySearchResults(_, 200, resultRes.$resources, resultRes.$searchFacets);
}


// http://localhost:8124/syracuse-main/html/main.html?type=application/json;vnd.sage.syracuse.representation=syracuse.search.syracuse.queryResult.$query&url=/search/_search?q=adm*