"use strict";

var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var sdataRegistry = require("syracuse-sdata/lib/sdataRegistry");
var streams = require("streamline/lib/streams/streams");
var streamsRecorder = require("syracuse-search/lib/streamsRecorder");

var elasticHelpers = require("syracuse-search/lib/helpers");
var elasticVersion = require("syracuse-search/lib/elasticVersion");
var helpers = require('syracuse-core/lib/helpers');
var forEachKey = helpers.object.forEachKey;
var jsurl = require("jsurl");
//var indexMeta = require("syracuse-search/lib/indexMeta");
var sys = require("util");
var locale = require("syracuse-core/lib/locale");
var datetime = require("syracuse-core/lib/types/datetime");
var decimal = require("syracuse-core/lib/types/decimal");

var httpHelper = require("syracuse-sdata/lib/httpHelper");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var Parser = require("syracuse-sdata/lib/parser/parser").Parser;
var httpClient = require("syracuse-httpclient/lib/httpClient");

var loghelper = require("syracuse-trace/lib/helper");
var logger = loghelper.getTracer(_, "search");

exports.tracer = null;
exports.serverConfig = null;

var cacheFilterUser = {};

function _indexToContract(indexName) {
	var parts = indexName.split(".");
	return sdataRegistry.getContract(parts[0], parts[1], false);
}

function _getTypeTitle(mapping, typeName) {
	var title = typeName;
	Object.keys(mapping).forEach(function(idx) {
		var map = mapping[idx][typeName];
		if (map && map._meta && map._meta.$classTitle) {
			title = map._meta.$classTitle;
		}
	});
	return title;
}

function _addFacets(query, contract) {
	if (!contract || !contract.searchFacets) {
		return;
	}
	query.facets = query.facets || {
		type: {
			terms: {
				field: "_type"
			}
		}
	};
	forEachKey(contract.searchFacets, function(key, facet) {
		query.facets[key] = {
			terms: {
				fields: ["facet_" + key]
			}
		};
	});
}

function _addRegexpFilter(query, property, rg) { // export for unit test
	// accept string sdata clause or parsed sdata clause
	//
	query.filtered = query.filtered || {};
	// crnit 140228 >>>: DO NOT replace query.filtered.filter as filters should cumulate: ex. filters (as in facet filters) + where + rights
	// operator should be AND in this case, if other is requires it should be in parameters
	//	return query.filtered.filter = _makeFilterFromSdata(where);
	//
	query.filtered.filter = query.filtered.filter || {};
	var filter = query.filtered.filter;
	var sdatafilter = null;
	if (filter.and && filter.and.filters) {
		sdatafilter = filter.and.filters;
	} else {
		filter.and = filter.and || [];
		sdatafilter = filter.and;
	}
	//
	filter = {
		regexp: {}
	};
	filter.regexp[property] = rg;
	sdatafilter.push({
		or: [filter]
	});
	// crnit 140228 <<<
}

function _addSdataWhere(query, where) { // export for unit test
	// accept string sdata clause or parsed sdata clause
	if (where && (typeof where === "string")) {
		where = Parser.parse(where);
	}
	//
	query.filtered = query.filtered || {};
	// crnit 140228 >>>: DO NOT replace query.filtered.filter as filters should cumulate: ex. filters (as in facet filters) + where + rights
	// operator should be AND in this case, if other is requires it should be in parameters
	//	return query.filtered.filter = _makeFilterFromSdata(where);
	//
	query.filtered.filter = query.filtered.filter || {};
	var filter = query.filtered.filter;
	var sdatafilter = null;
	if (filter.and && filter.and.filters) {
		sdatafilter = filter.and.filters;
	} else {
		filter.and = filter.and || [];
		sdatafilter = filter.and;
	}
	//
	sdatafilter.push(_makeFilterFromSdata(where));
	// crnit 140228 <<<
}
exports.addSdataWhere = _addSdataWhere;

function _addFilters(query, filters) {
	if (!filters) {
		return;
	}
	if (!Object.keys(filters).some(function(k) {
		return (k !== "type");
	})) {
		return;
	}
	//
	query.filtered = query.filtered || {};
	query.filtered.filter = query.filtered.filter || {};

	var filter = query.filtered.filter;
	var sdatafilter = null;
	if (filter.and && filter.and.filters) {
		sdatafilter = filter.and.filters;
	} else {
		filter.and = filter.and || [];
		sdatafilter = filter.and;
	}
	var condition = "",
		i, cond;
	forEachKey(filters, function(key, facet) {
		if (key === "type") {
			return;
		}
		for (i = 0; i < facet.length; i++) {
			cond = "facet_" + key + " like '" + facet[i] + "'"; // add like for generate regexp because fields filter doesn't work with space
			condition = condition ? condition + " and " + cond : cond;
		}
	});
	_addSdataWhere(query, condition);
}
// for unit test
exports.addFilters = _addFilters;

function _replaceSearchDollar(value) {
	var result;
	if (value === "$id") {
		result = value.replace('$id', '_id');
	} else if (value === "$type") {
		result = value.replace('$type', '_type');
	} else {
		result = value;
	}
	return result;
}

function _makeFilterFromSdata(where) {
	function _left(where) {
		var result = "";
		if (!where) {
			return result;
		}
		switch (where.type) {
			case "operator":
				switch (where.value.code) {
					case ".":
						result = _left(where.children[0]) + "." + _left(where.children[1]);
						break;
					default:
						throw new Error("_left : \"" + where.value.code + "\" not yet implemented");
				}
				break;
			default:
				result = _replaceSearchDollar(where.value);

		}
		return result;
	}

	/*
	 *
	 * get the branch of the tree that have a different operation that the one passed in parameter
	 */
	function getBranchElement(operator, left, right) {
		var tab = [];
		if (left) {
			if (left.value.code === operator) {
				getBranchElement(operator, left.children[0], left.children[1]).forEach(function(item) {
					tab.push(item);
				});
			} else {
				tab.push(_makeFilterFromSdata(left));
			}
		}
		if (right) {
			if (right.value.code === operator) {
				getBranchElement(operator, right.children[0], right.children[1]).forEach(function(item) {
					tab.push(item);
				});
			} else {
				tab.push(_makeFilterFromSdata(right));
			}
		}
		return tab;
	}

	function _format(value, isDate) {
		if (!value) {
			return value;
		}
		return isDate ? new Date(value) : ((typeof value === "object") && value.toString()) ? value.toString() : value;
	}

	var result = {};
	var isDate = false;
	var r;
	switch (where.type) {
		case "operator":
			switch (where.value.code) {
				case "and":
					if (where.children.length < 2) {
						throw new Error("Invalid \"AND\" condition");
					}
					var res = getBranchElement(where.value.code, where.children[0], where.children[1]);
					result = {
						and: res
					};
					break;
				case "or":
					if (where.children.length < 2) {
						throw new Error("Invalid \"OR\" condition");
					}
					var res = getBranchElement(where.value.code, where.children[0], where.children[1]);
					result = {
						or: res
					};
					break;
				case "=":
					var val = _format(where.children[1].value, isDate);
					if (val == null) {
						result.missing = {
							field: _left(where.children[0])
						};
					} else {
						result.query = {
							field: {}
						};
						result.query.field[_left(where.children[0])] = (val && val === "$all" ? "_all" : val);
					}
					break;
				case "like":
					r = where.children[1] && _format(where.children[1].value, isDate);
					//if (right.charAt(0) != "%") right = "^" + right;
					r = r.replace(/%/g, ".*");
					result.regexp = {};
					result.regexp[_left(where.children[0])] = r;
					break;
				case "not":
					r = _makeFilterFromSdata(where.children[0]);
					result.not = r;
					break;
				case "in":
					r = where.children.slice(1).map(function(c) {
						return c && _format(c.value.replace("$all", "_all"), isDate);
					});
					result.terms = {};
					result.terms[_left(where.children[0])] = r;
					break;

				default:
					// range ?
					if (["<", "<=", ">=", ">", "between"].indexOf(where.value.code) > 0) {
						var rg;
						if (typeof where.children[1] === "number") {
							rg = result.numeric_range = {};
						} else {
							rg = result.range = {};
						}
						var l = rg[_left(where.children[0])] = {};
						var r = _format(where.children[1].value, isDate);
						switch (where.value.code) {
							case "<":
								l.lt = r;
								break;
							case "<=":
								l.lte = r;
								break;
							case ">":
								l.gt = r;
								break;
							case ">=":
								l.gte = r;
								break;
							case "between":
								l.gte = r;
								l.lte = _format(where.children[2].value, isDate);
								break;
						}
					}
			}
			break;
		default:
			throw new Error(where.type + " not yet implemented");
	}
	return result;
}

function _addFunctionsFilter(_, query, endpoints) {
	var where = "application eq null";

	// Ensure that the functions returned are valid for the user
	endpoints.forEach_(_, function(_, endpoint) {
		where = where + " or (application.$key eq '" + endpoint.applicationRef(_).$uuid + "' and endpoint eq null) or (endpoint.$key eq '" + endpoint.$uuid + "' and application.$key eq '" + endpoint.applicationRef(_).$uuid + "')";
	});
	var adminEP = adminHelper.getCollaborationEndpoint(_);
	where = where + " or (application.$key eq '" + adminEP.applicationRef(_).$uuid + "' and endpoint eq null) or (endpoint.$key eq '" + adminEP.$uuid + "' and application.$key eq '" + adminEP.applicationRef(_).$uuid + "')";

	// add admin endpoint
	_addSdataWhere(query, where);
}

var _prototype = {};

function _getPrototypeCache(_, url) {
	var options = {
		method: "GET",
		url: url
	};
	var prop;
	if (_prototype[options.url]) {
		prop = _prototype[options.url];
	} else {
		var proto = JSON.parse(httpClient.httpRequest(_, options).end().response(_).readAll(_));
		// manage summary for syracuse but use search for x3
		if (!proto._source) {

			prop = {};
		} else {
			prop = proto._source.$prototype.$properties.$resources ? proto._source.$prototype.$properties.$resources.$item.$properties : proto._source.$prototype.$properties;
			prop.$summary = proto._source.$prototype.$summary;
		}
		_prototype[options.url] = prop;
	}
	return prop;
}


function _formatValueDecimal(_, val, item, locale) {
	var groupSize = locale.numberGroupSize(_);
	var res;
	if (typeof val !== 'float') {
		res = parseFloat(val);
	}
	if (res && item.$maxLength) {
		// contruct format expected for decimal
		var decimalPart = (item.$maxLength % 1).toFixed(1) * 10;
		var integerPart = Math.floor(item.$maxLength);
		var format = "";
		for (var i = 0; i < integerPart - 1; i++) {
			if (i > 0 && i % groupSize === 0) {
				format = format + ",#";
			} else {
				format = format + "#";
			}

		}
		format = format + "0.";
		for (var i = 0; i < decimalPart; i++) {
			format += "0";
		}
		return decimal.format(res, format) + "";
	}
	return val;
}

function _formatValueDate(_, resVal, item, locale) {
	var shortDateFormat = locale.shortDate(_);
	var date = datetime.parse(resVal, "yyyy-MM-dd");
	return date.toString(shortDateFormat);
	//return resVal;
}

var mapFormatValue = {
	"application/x-decimal": _formatValueDecimal,
	"application/x-date": _formatValueDate,
};

function _formatValue(_, value, item, context) {
	if (item && value && mapFormatValue[item.$type]) {
		var locale = context.getUserProfile(_).selectedLocale(_);

		var isHighlight = typeof value === "string" && value.indexOf("<em>") !== -1;
		var resVal = isHighlight ? value.replace("<em>", "").replace("</em>", "") : value;
		resVal = mapFormatValue[item.$type](_, resVal, item, locale);
		resVal = isHighlight ? "<em>" + resVal + "</em>" : resVal;
		return resVal;
	}
	return value;
}
exports.formatValue = _formatValue;

// add right parmeter to filter all field that the user have not able to see in result - TODO use in elastic 1.x filter source and for request field pattern to exclude some field for the search
/*
    result : true of the data have to be add because highlight value has to be display (right on column) -> restriction elastic 0.90.12
             false if no value is highlight -> an highlight value is return by elastic but right column disable this field on display

 */
function _updateResource(_, hit, properties, resource, right, queryString, context) {
	// get prototype store in elasticSearch
	var hasHighlightProperty = false;
	var mustFormatServerSide = context.representation.type === "$search";
	/*
	 *  return the value formatted if decimal or date else return the value receive in parameter
	 */


	function _fromHighlight(hglt, kk, isInArray) {
		var result = hglt && hglt[kk] && kk !== "$url" ? (isInArray || hglt[kk].length > 1 ? hglt[kk] : hglt[kk][0]) : null;
		if (result) {
			hasHighlightProperty = true;
		}
		return result;
	}

	function _fromSource(src, kk) {
		function _makeValue(it) {
			return typeof it === "object" && it.hasOwnProperty("$value") ? it.$value : it;
		}
		var ktab = kk.indexOf(".") !== -1 ? kk.split(".") : [kk];
		// get the right value from the key (k1.k2 => k1 : { k2 : value }
		if (ktab.length === 0) {
			return null;
		}

		var srcVal = src;
		var i;
		for (i = 0; i < ktab.length && srcVal[ktab[i]]; i++) {
			srcVal = srcVal[ktab[i]];
		}
		if (i === ktab.length && srcVal) {
			var res;
			if (Array.isArray(srcVal)) {
				var out = [];
				for (i = 0; i < srcVal.length; i++) {
					out.push(srcVal[i].$value ? srcVal[i].$value : srcVal[i]);
				}
				res = out;
			} else {
				res = srcVal.$value ? srcVal.$value : srcVal;
			}
			if (res.toString() === queryString) { // hack
				hasHighlightProperty = true;
			}
			return res;
		}
		return null;
	}
	var sSource = hit._source;
	var sHighlight = hit.highlight;

	var baseUrl = [exports.serverConfig.baseUrl].join('/');

	var type = hit._type;
	var index = hit._index;
	var adminEP = adminHelper.getCollaborationEndpoint(_);
	var locale = hit._index.substring(hit._index.lastIndexOf("."));
	if (type === "function") {
		type = "menuItem";
		index = adminEP.application(_) + "." + adminEP.contract(_) + "." + adminEP.dataset(_) + locale;
	}
	var prop = _getPrototypeCache(_, baseUrl + "/" + index + "_entities" + "/$entities/" + type);
	var isGlobalSummary = prop.$summary;

	if (prop) {


		/*
		 * look on all property of the prototype to create  $resource array
		 *   item of each $resource  must follow protocol describe in issue github 3163
		 *
		 */
		Object.keys(prop).forEach_(_, function(_, k) {
			var hh = k; // highlight key (i.e :  CTY.TOTO)

			function _getSubProperties(propItem) {
				if (!propItem) {
					return null;
				}
				if (Object.keys(propItem).length === 0) {
					return null;
				}
				if (propItem.$item && Object.keys(propItem.$item).indexOf("$properties") > 0) {
					return propItem.$item.$properties;
				}

				return _getSubProperties(propItem.$item);
			}

			/*
			 * propItem : object that represent the current prototype property
			 * hh : the highlight key is associate to the current property
			 */

			function getRecord(_, propItem, hh, isInArray, context) {
				var res = {
					properties: {},
					resource: {}
				};
				// check if user has right to see the field
				if (propItem.$access) {
					if (right && right.$X3entities && right.$X3entities[type] && right.$X3entities[type].accessCodes && right.$X3entities[type].accessCodes.length && right.$X3entities[type].accessCodes.indexOf(propItem.$access) === -1) {
						return null; // do nothin
					}
					if (right && right.$accessCodes && Object.keys(right.$accessCodes).indexOf(propItem.$access) === -1) {
						return null; // do nothin
					}
				}
				if (typeof propItem === "object") {
					switch (propItem.$type) {
						case "application/x-reference":
							// crnit: TODO: we should format references so they be compatible with standard reference format ($query)
							// check if properties is date and is highlight -> elastic search doesn't manage that
							res.properties = {
								$isSummary: propItem.$isSummary || propItem.$type === "application/x-date" || isGlobalSummary ? true : false,
								$isHighlight: (sHighlight && (sHighlight[hh] || sHighlight[hh + ".$value"]) ? true : false),
								$title: propItem.$title
							};
							var resVal = _fromHighlight(sHighlight, hh, isInArray) || _fromHighlight(sHighlight, hh + ".$value", isInArray) || _fromSource(sSource, hh) || _fromSource(sSource, hh + ".$value");
							res.resource = mustFormatServerSide ? _formatValue(_, resVal, propItem, context) : resVal;

							break;
						case "application/x-array":
						case "application/x-object":
							if (propItem.$item.$type === "application/x-reference") {
								res = getRecord(_, propItem.$item, hh, true, context);
								res.properties.$title = propItem.$title;
							} else {
								var psub = _getSubProperties(propItem);
								if (psub) {
									Object.keys(psub).forEach_(_, function(_, key) {
										var hl = hh !== "" ? hh + "." + key : key;
										var resp = getRecord(_, psub[key], hl, true, context);
										if (resp) {
											res.properties[key] = resp.properties;
											if (resp.resource) {
												res.resource[key] = resp.resource;
											}
										}
									});
								}
							}

							break;
						default:
							// check if properties is date and is highlight -> elastic search doesn't manage that
							res.properties = {
								$isSummary: propItem.$isSummary || propItem.$type === "application/x-date" || isGlobalSummary ? true : false,
								$isHighlight: (sHighlight && sHighlight[hh] ? true : false),
								$title: propItem.$title
							};
							var resVal = _fromHighlight(sHighlight, hh, isInArray) || _fromSource(sSource, hh);
							res.resource = mustFormatServerSide ? _formatValue(_, resVal, propItem, context) : resVal;


					}
				}
				// hack remove highligh with no wanted - issue 99070 TODO will be remove with elastic 1.x
				if (context.parameters && context.parameters.noHighlight) {
					if (res.properties.$isHighlight) {
						var reg1 = new RegExp('<em>', 'g');
						var reg2 = new RegExp('</em>', 'g');
						if (typeof res.resource === "string") {
							res.resource = res.resource.replace(reg1, '').replace(reg2, '');
						} else if (res.resource.length) {
							res.resource.forEach(function(item, i) {
								res.resource[i] = item.replace(reg1, '').replace(reg2, '');
							});
						}
						res.properties.$isHighlight = false;
					}

				}

				return res;
			}



			var result = getRecord(_, prop[k], hh, false, context);
			if (result) {
				properties[k] = result.properties;
				resource[k] = result.resource || resource[k];
			}
		});
	}
	return hasHighlightProperty;
}


function _makeFunctionResource(_, endpoint, mapping, hit, isMultiEP, right, queryString, context) {

	var title = _getTypeTitle(mapping, hit._type);
	// items base url
	var adminEP = adminHelper.getCollaborationEndpoint(_);
	var localized = isMultiEP ? locale.format(module, "functionMultiDescription", hit._source.$description, endpoint.description(_)) : locale.format(module, "functionMonoDescription", hit._source.$description);
	var r = {
		$url: hit._source.$url,
		$baseUrl: hit._source.application && hit._source.application.$key === endpoint.applicationRef(_).$uuid ? endpoint.getBaseUrl(_) : adminEP.getBaseUrl(_),
		$uuid: hit._id,
		$resultTypeTitle: title,
		$representation: hit._type,
		$searchItemTitle: localized,
		//title: localized,

		icon: (hit._source.$icon ? {
			$url: hit._source.$icon,
			$type: "image"
		} : null)


	};
	var prop = {};
	var isDisplay = _updateResource(_, hit, prop, r, right, queryString, context);
	if (isDisplay) { // must be manage with elastic 1.0 by the filter - no possible in 0.90.12 TODO
		r.$properties = prop;

		if (hit._source.linkType === "$function") {
			r.$baseUrl = r.$baseUrl.replace("/sdata/", "/trans/");
		}
		return r;
	}

	return null;
}

function _makeResource(_, mapping, hit, representation, resFormat, right, queryString, context) {
	var title = _getTypeTitle(mapping, hit._type);
	// items base url
	// hint: for now, $description goes into title and description is a concatenation of all fields
	var r;
	var prop = {};

	switch (resFormat) {
		case "$query":
		case "$lookup":
		case "$select":
			r = hit._source;
			break;
		default:
			r = {
				$url: hit._source.$url,
				$uuid: hit._id,
				$resultTypeTitle: title,
				$representation: hit._type,
				$searchItemTitle: hit.highlight && hit.highlight.$description ? hit.highlight.$description[0] : hit._source.$description,
				$description: hit.highlight && hit.highlight.description ? hit.highlight.description : hit._source.description,
				icon: (hit._source.$icon ? {
					$url: hit._source.$icon,
					$type: "image"
				} : null)
			};


	}
	var isDisplay = _updateResource(_, hit, prop, r, right, queryString, context);

	if (isDisplay) { // must be manage with elastic 1.0 by the filter - no possible in 0.90.12 TODO
		r.$properties = prop;

		// substitute representation for given representation
		if (representation !== "queryResult") {
			r.$url = r.$url.replace(/representation=.*\.\$/, "representation=" + representation + ".$");
		}
		//
		r.$key = hit._id;
		return r;
	}

	return null;
}

//select existing indexes available to the user

function _selectIndexes(_, elasticBaseUrl, userProfile, sources, selectedIndexName) {
	var indexes = [];

	function _addIndex(_, indexName, localeCode) {
		var idx = indexName + "." + localeCode.toLowerCase();
		if (elasticHelpers.indexExists(_, elasticBaseUrl, idx)) {
			indexes.push(idx);
		} else if (localeCode !== elasticHelpers.fallbackLocale) {
			_addIndex(_, indexName, elasticHelpers.fallbackLocale);
		}
	}

	function _addEP(_, ep, localeCode) {
		var idx = ep.getIndexName(_, localeCode || locale.current);
		if (elasticHelpers.indexExists(_, elasticBaseUrl, idx)) {
			indexes.push(idx);
		} else if (localeCode !== elasticHelpers.fallbackLocale) {
			_addEP(_, ep, elasticHelpers.fallbackLocale);
		}
	}
	//
	if (sources.indexOf("data") >= 0) {
		if (selectedIndexName) {
			_addIndex(_, selectedIndexName, locale.current);
		} else {
			if (userProfile) {
				if (userProfile.selectedEndpoint(_)) {
					_addEP(_, userProfile.selectedEndpoint(_));
				} else {
					userProfile.endpoints(_).toArray(_).forEach_(_, function(_, endpoint) {
						_addEP(_, endpoint);
					});
				}
			}
		}
	}
	if (sources.indexOf("functions") >= 0) {
		var epF = userProfile.selectedEndpoint(_);
		_addIndex(_, elasticHelpers.functionIndexName, locale.current);
	}
	//
	return indexes;
}

// select endpoints available to the user

function _selectEndpoints(_, userProfile) {
	var eps = [];
	if (userProfile) {
		if (userProfile.selectedEndpoint(_)) {
			eps.push(userProfile.selectedEndpoint(_));
		} else {
			eps = userProfile.endpoints(_).toArray(_).slice(0);
		}
	}
	return eps;
}



//issue 3171 check if string is a date and convert to the right string to search else return query entered

function _convertDateToString(_, q, locale) {
	function getDateStr(_, arr) {
		// check with local preference if start with d,m or year

		if (arr.length === 3) {
			if (arr[2].length === 4) {
				var dateFormat = locale.shortDate(_) || "MM/dd/yyyy";
				try {
					var v = datetime.parse(q, dateFormat).value;
					logger.debug(_) && logger.debug(_, "Parsed date: " + v);
					var d = new Date(v);
					logger.debug(_) && logger.debug(_, "Date: " + d);
					var date = d.getDate();
					var month = d.getMonth() + 1;
					var year = d.getFullYear();
					// it's a date -> create a new query in x3 raw date format and elastic search format
					return year + "-" + (month < 10 ? "0" + month : month) + "-" + (date < 10 ? "0" + date : date);
				} catch (e) {
					// not a date that match the dataformat return null to search on the specify string 
					return null;
				}
			} else if (arr[0].length === 4) {
				return arr.join("-");
			}
		}
		return arr.join("-");
	}


	// try to get date from all kind of format
	//	var r = /(\d*)[^A-Za-z_0-9](\d*)[^A-Za-z_0-9](\d*)/.exec(q);
	// This should catch dd/mm/yyyy, dd-mm-yyy, mm/dd/yyyy, mm-dd-yyyy
	// as well as yyyy-mm-dd
	var r = /(\d+)[\-|\/](\d+)[\-|\/](\d+)/.exec(q);
	r = r && r.slice(1);
	//console.log("regexp " + JSON.stringify(r, null, 2));
	if (r && r.length > 1) {

		return getDateStr(_, r);
	}

	/*var d = new Date(q);
    //console.log("date " + d);
    if (d.getFullYear()) {
        var date = d.getDate();
        var month = d.getMonth() + 1;
        var year = d.getFullYear();
        // it's a date -> create a new query in x3 raw date format and elastic search format
        return year + "-" + (month < 10 ? "0" + month : month) + "-" + (date < 10 ? "0" + date : date);
    }*/
	return null;

}

/*
 * return true if access is grante for some date , else is no access to no data is define
 */
function _addX3RightFilter(_, allRight, search, isFunction) {

	var right = (allRight ? (isFunction ? allRight.$functions : allRight.$accessCodes) : null);
	var rep = allRight ? allRight.$representations : null;
	var attr = isFunction ? "representationRef.entity" : "$type";
	if (right && right === "*") {
		return true; // no restriction
	}
	var condition = "";
	var accessRegexp = "";
	if (right && Object.keys(right).length > 0) { //simple right

		Object.keys(right).map(function(it) {
			if (it && it !== '*') {
				var ac = it.toLowerCase(); // escape all special character
				accessRegexp = accessRegexp + (!accessRegexp ? ac : "|" + ac);
			}
		});
		if (accessRegexp) {
			search.query.filtered.filter = {};
			accessRegexp = accessRegexp + "|_all";
		}
	}


	var listEntity = {};
	allRight.$X3entities = listEntity;
	if (rep && Object.keys(rep).length > 0) {

		Object.keys(rep).forEach(function(key) { // watch all representation and define condition for entity
			// get the entity name from the representation name
			var repRight = rep[key];
			var entityName;
			if (repRight["$entity"]) {
				entityName = repRight["$entity"];
			} else {
				entityName = key;
			}
			if (Object.keys(listEntity).indexOf(entityName) === -1) { // entity name not treate add default type condition

				listEntity[entityName] = {
					type: attr + " eq " + entityName,
					site: "",
					condition: "",
					access: ""
				};
			}

			var cond = listEntity[entityName];
			if (!isFunction) {
				// if condition, accessCOde or site define we have to add it to the current conditon
				if (repRight.$conditions && repRight.$conditions.length > 0) {
					repRight.$conditions.forEach(function(item) {
						if (item.$type === "restriction") {
							var cd = "not (" + item.$where + ")";
							cond.condition = cond.condition + (cond.condition ? " and " + cd : cd);
						} else if (item.$type === "authorization") {
							cond.condition = cond.condition + (cond.condition ? " and " + item.$where : item.$where);
						}
					});
				}
				//filter on access code
				if (repRight.$accessCodes && repRight.$accessCodes.length > 0) {
					cond.access = " $access in ( $all";
					repRight.$accessCodes.split(",").forEach(function(it) {
						cond.access = cond.access + ",'" + it.toLowerCase() + "'";
						// add for filter by column - TODO will be remove while use source and field pattern in 1.X of elastic search
						cond.accessCodes = cond.accessCodes || [];
						cond.accessCodes.push(it);
					});
					cond.access = cond.access + ")";

				}

				// add restriction on site only if there are some in database
				if (repRight.$sites && repRight.$sites.length > 0) {
					cond.site = "$site in ( $all";
					repRight.$sites.split(",").forEach(function(it) {
						var s = "'" + it.toLowerCase() + "'";
						cond.site = cond.site + (cond.site[cond.site.length - 1] === '(' ? s : "," + s);
					});
					cond.site = cond.site + ")";
				}
			}
		});
		// generate the final condition
		Object.keys(listEntity).forEach(function(key) {
			var c = listEntity[key].type;
			c = c + (listEntity[key].access ? " and " + listEntity[key].access : "");
			c = c + (listEntity[key].site ? " and " + listEntity[key].site : "");
			c = c + (listEntity[key].condition ? " and " + listEntity[key].condition : "");
			condition = condition ? condition + " or ( " + c + " )" : "( " + c + " )";
		});

		if (isFunction) {
			condition = condition ? condition + " or (" + attr + " eq null )" : "( " + attr + " eq null )";
		}
	}
	if (!condition && !accessRegexp) {
		return false;
	}
	if (condition) { // no access right
		_addSdataWhere(search.query, condition);
	}
	if (accessRegexp) {
		_addRegexpFilter(search.query, "$access", accessRegexp);
	}


	return true;
}

function hasLeadingWildcard(q) {
	// Split the query string into individual terms
	var found = false;
	var terms = [];
	if (q.indexOf(" ") > 0) {
		terms = q.split(" ");
	} else {
		terms[0] = q;
	}

	var t, term;
	for (t = 0; t < terms.length; t++) {
		term = terms[t];
		if (term.charAt(0) === "*" || term.charAt(0) === "?") {
			found = true;
		}
	}
	return found;
}

function preProcessSearch(_, q, locale, searchType) {

	// If the search string contains any character to suggest it is a regulaer
	// expression then assume specialised knowledge and pass it straight on
	if (q.indexOf(/[\!\$\%\^\&\(\)\_\+\|\~\=\{\}\[\]:\";\'<>]*/) >= 0) {
		return {
			fulltext: q
		};
	}
	var queryExpr;
	try {
		queryExpr = Parser.parse(q.replace(/\|\|/g, " OR ").replace(/&&/g, " AND "));
	} catch (e) {
		// not a parsable expression
		queryExpr = null;
	}
	// Split the query string into individual terms
	var terms = [];
	if (q.indexOf(" ") > 0) {
		terms = q.split(" ");
	} else {
		terms[0] = q;
	}

	var qstr = "",
		t, term, numbers, termDate;
	for (t = 0; t < terms.length; t++) {
		term;
		// hack for decimal number in order to search while type coma instead of point
		numbers = /[0-9]*,[0-9]*/g.exec(terms[t]);
		if (numbers && numbers.length) {
			numbers.forEach(function(item) {
				var item2 = item.replace(",", ".");
				terms[t] = terms[t].replace(item, item2);
			});
		}
		term = terms[t];

		// Append a space between the search terms
		if (qstr !== "") {
			qstr += " ";
		}
		//console.log("term "+term);


		// Regex that should catch all numerical date representations
		termDate = _convertDateToString(_, term, locale);
		logger.debug(_) && logger.debug(_, "Date converted to X3 format=> " + termDate);
		if (termDate) {
			term = termDate;
		} else {
			// Boolean operators simply get appended
			if (term !== "OR" && term !== "AND") {

				term = typeof term === "string" ? term.toLowerCase() : term;

			}
		}
		// Finally append the term
		qstr += term;
	}

	return {
		fulltext: qstr,
		expression: queryExpr
	};
}

function defineStartWithQuery(searchConfig, q) {
	var allowLeading = (searchConfig.allowLeadingWildcard) ? searchConfig.allowLeadingWildcard : false;

	var query = {

		multi_match: {
			fields: ["_all"], // Exact matches
			query: q,
			type: "phrase_prefix"
		}
	};

	return query;
}


function defineExactQuery(searchConfig, q) {
	var allowLeading = (searchConfig.allowLeadingWildcard) ? searchConfig.allowLeadingWildcard : false;

	var query = {
		query_string: {
			query: q, // Exact matches
			//default_operator: "AND",
			analyze_wildcard: true,
			allow_leading_wildcard: allowLeading
		}
	};

	return query;
}

function defineFuzzyQuery(searchConfig, q) {
	var minSimilarity = (searchConfig.minSimilarity) ? searchConfig.minSimilarity : 0.5;
	var ignoreFrequency = (searchConfig.ignoreFrequency) ? searchConfig.ignoreFrequency : true;

	var query = {
		fuzzy_like_this: {
			like_text: q,
			max_query_terms: 20,
			min_similarity: minSimilarity,
			ignore_tf: ignoreFrequency
		}
	};

	return query;
}

function defineExactPlusFuzzyQuery(searchConfig, q) {
	var minSimilarity = (searchConfig.minSimilarity) ? searchConfig.minSimilarity : 0.5;
	var ignoreFrequency = (searchConfig.ignoreFrequency) ? searchConfig.ignoreFrequency : true;
	var allowLeading = (searchConfig.allowLeadingWildcard) ? searchConfig.allowLeadingWildcard : false;

	var query = {
		bool: {
			should: [{
				custom_boost_factor: {
					query: {
						query_string: {
							query: q, // Exact matches
							boost: 100.0,
							//default_operator: "AND",
							analyze_wildcard: true,
							allow_leading_wildcard: allowLeading
						}
					},
					boost_factor: 2.5
				}
			}, {
				constant_score: {
					query: {
						fuzzy_like_this: {
							like_text: q,
							max_query_terms: 20,
							min_similarity: minSimilarity,
							ignore_tf: ignoreFrequency,
							boost: 1.0
						}
					},
					boost: 1.0
				}
			}]
		}
	};

	return query;
}

/*
 list cache <=> user
 */

function _addCacheFilter(_, search, user, endpoint, isFunction, suffixCache) {

	var queryFilter = search.query.filtered.filter;
	if (queryFilter) {
		var keyFilter = Object.keys(queryFilter).length > 0 ? Object.keys(queryFilter)[0] : null;
		var filter = queryFilter[keyFilter];
		if (filter && (keyFilter === "or" || keyFilter === "and")) {
			var userLog = user.getEndpointLogin(_, endpoint.$uuid);
			var cacheKey = endpoint.dataset(_) + "_" + userLog + "_" + (isFunction ? "function" : "data") + (suffixCache ? "_" + suffixCache : "");
			search.query.filtered.filter[keyFilter] = {
				filters: filter,
				_cache: true,
				_cacheKey: cacheKey
			};
			if (!cacheFilterUser[userLog]) {
				cacheFilterUser[userLog] = [];
			}
			if (cacheFilterUser[userLog].indexOf(cacheKey) < 0) {
				cacheFilterUser[userLog].push(cacheKey);
			}

		}
	}
}



function _addSyracuseRightFilter(_, allRight, search, baseUrlIndex, isFunction, prototypeUnit) {

	// return true if a property Name is a reference to another entity and not only a basic type property. i.e user.endpint endpoint is a propertyReference of user
	function isPropertyReference(propertyName, prototype) {
		var property = prototype;
		var tabProp = propertyName.indexOf(".") ? propertyName.split(".") : [propertyName];
		tabProp.forEach(function(item) {
			property = property[item] ? property[item] : property.$item && property.$item.$properties && property.$item.$properties[item];
		});
		if (property && (property.$type === "application/x-reference" ||
			(property.$type === "application/x-array" && property.$item && property.$item.$type === "application/x-reference"))) {
			return true;
		}
		return false;
	}

	if (!allRight || config.searchEngine.deactivateRight) {
		return;
	}
	var attr = (!isFunction ? "$type" : "representationRef.entity");

	var right = allRight.$entities;

	if (right && Object.keys(right).length > 0) { //simple right
		search.query.filtered.filter = search.query.filtered.filter || {};



		var condition = isFunction ? attr + " eq null" : "";
		Object.keys(right).forEach_(_, function(_, it) {
			var proto = prototypeUnit ? prototypeUnit[baseUrlIndex + "_entities" + "/$entities/" + it] : _getPrototypeCache(_, baseUrlIndex + "_entities" + "/$entities/" + it);
			var cond;
			// add specific filter restriction regarding condition
			if (right[it].condition) { // can access if condition is ok
				// replace of $uuid
				if (!isFunction) {
					var filterElastic = right[it].condition;
					var tab = filterElastic.match(/[a-zA-Z\$\.]*\s+in/g);

					filterElastic = filterElastic.replace(/\.\$uuid/gm, ".$key"); // replace uud of sub property is indexes as $key
					filterElastic = filterElastic.replace(/\$uuid/gm, "$id"); //root $uuid is _id

					tab && tab.forEach(function(item) {
						var split = item.split(" ");
						// get singular if necessary
						if (split[0].indexOf("$uuid") === -1 &&
							split[0].indexOf("$id") === -1 &&
							split[0].indexOf(".") === -1 &&
							proto && isPropertyReference(split[0], proto)) {
							filterElastic = filterElastic.replace(new RegExp(split[0] + "\\s*in", "g"), split[0] + ".$key in"); // replace Author in by Author.$key in;
						}

					});

					cond = "( " + filterElastic + " ) and " + attr + " eq " + it;
				} else {
					cond = attr + " eq " + it; // can access to the function

				}
			} else if (!right[it].restriction) {
				cond = attr + " eq " + it;
			} else {
				cond = " not ( " + attr + " eq " + it + " )";
			}
			if (cond) {
				condition = condition ? condition + " or " + cond : cond;
			}

		});
		if (condition) {
			_addSdataWhere(search.query, condition);
		}

	}
}
exports.addSyracuseRightFilter = _addSyracuseRightFilter;
exports.addX3RightFilter = _addX3RightFilter;


/*
 * highlighQuery : correspond to the highlight query object pass in the elastic request
 * querExp : correspond to the expression generate using sdata parser from the full text query entered by the client
 *
 * generate and add the highlight query regarding the quuerExp receive to allow elastic to hightlight the right element
 */
function _addHighlightQuery(queryExp, highlightQuery, treated) {
	if (!queryExp)
		return null;

	var query = highlightQuery;
	treated = treated || {
		and: [],
		not: []
	};

	switch (queryExp.type) {
		case "operator":
			switch (queryExp.value.code) {
				case "and":
				case "or":
					if (queryExp.children.length) {
						query = query || {
							bool: {
								must: []
							}
						};

						if (queryExp.children[0].type === "operator") {
							query = _addHighlightQuery(queryExp.children[0], query, treated);
						} else {
							var val = queryExp.children[0].value;
							if (treated.and.indexOf(val) === -1) {
								treated.and.push(val);
								query.bool.must.push({
									match: {
										content: {
											query: val,
											type: "phrase_prefix"
										}
									}
								});
							}
						}
						if (queryExp.children[1].type === "operator") {
							query = _addHighlightQuery(queryExp.children[1], query, treated);
						} else {
							var val = queryExp.children[1].value;
							if (treated.and.indexOf(val) === -1) {
								treated.and.push(val);
								query.bool.must.push({
									match: {
										content: {
											query: val,
											type: "phrase_prefix"
										}
									}
								});
							}
						}
					}
					break;
				case "not":

					break;
				case "in":

					break;
				default:
					// range TODO
					if (["<", "<=", ">=", ">", "between"].indexOf(queryExp.value.code) > 0) {

					}
			}
			break;
		default:
			// do nothin
	}
	return query;
}


var rights = {};

//Unit test interface allows the configuration to be overridden
exports.search = function(_, context, configOverride) {
	// Allow config from nodelocal.js to be overridden to make sure that
	// unit tests have the correct config settings
	var searchConfig = configOverride || config.searchEngine || {};
	var keepInContext = configOverride && configOverride.keepInContext;
	var urlSegs = [exports.serverConfig.baseUrl];
	var diag = [];
	var req, options = {};

	// Update the log trace to pick up config changes
	logger = loghelper.getTracer(_, "search");

	elasticHelpers.checkStartSearchEngine(_, exports.serverConfig.baseUrl, diag, true, true);
	if (diag && diag.length === 0) {
		// Check the version of elastic search
		try {
			elasticVersion.checkVersion(_, urlSegs.join("/"));
		} catch (e) {
			diag && diag.push({
				$severity: "error",
				$message: e.message
			});
		}
	}
	if (diag && diag.length !== 0) {
		return context.reply(_, httpHelper.HttpStatus.NotFound, diag[0].$message);
	}

	// Check for leading wildcard much earlier than before
	var q = context.parameters.q || context.parameters.search;
	if (!searchConfig.allowLeadingWildcard) {
		if (hasLeadingWildcard(q)) {
			return context.reply(_, httpHelper.HttpStatus.NotFound, locale.format(module, "badSearchString", q));
		}
	}
	// Sort out the parameters etc
	var sources = (context.parameters.source || "data").split(",");
	var filters = jsurl.parse(context.parameters.filters);
	var suffixFilterCache = context.parameters.filters;
	var where = context.parameters.where;
	var adminEP = adminHelper.getCollaborationEndpoint(_);
	var up = context.getUserProfile(_);
	var user = up.user(_);
	var currentEndpoint = up.selectedEndpoint(_);
	var selectedLocale = up.selectedLocale(_);
	if (!currentEndpoint) { // no selected endpoint we disable this feature for prevent security issue about right
		return context.reply(_, httpHelper.HttpStatus.BadRequest, locale.format(module, "noSelectedEndpoint"));
	}
	var isFunction = context.parameters.source === "functions";

	//console.log("right " + JSON.stringify(right, null, 2));

	var allEntities = [];
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	var indexNames = _selectIndexes(_, elasticBaseUrl, up, sources, (filters && filters.index && filters.index[0]) || context.searchIndexName);
	var endpoints = _selectEndpoints(_, up);
	logger.info(_) && logger.info(_, "elasticQuery.indexNames: " + sys.inspect(indexNames));

	if (!indexNames.length) {
		return context.reply(_, httpHelper.HttpStatus.NotFound, locale.format(module, isFunction ? "noFunctionIndexAvailable" : "noDataIndexAvailable", up.selectedEndpoint(_).description(_), locale.current));
	}
	// get authorized function and authorization from x3
	// issue SAM 101135
	var isCollaboration = context.request._request.url.indexOf("/sdata/syracuse/collaboration/syracuse/") !== -1;
	var collabEd = adminHelper.getEndpoint(_, {
		dataset: "syracuse"
	}) || currentEndpoint;
	var edRight = isCollaboration ? collabEd : currentEndpoint;

	var right = up.getAccessRightAuthorizations(_, edRight);
	if (right && right.$diagnoses) {
		return context.reply(_, httpHelper.HttpStatus.BadRequest, locale.format(module, "X3Right", right.$diagnoses[0].$message));
	}
	if (right && right.purgeCache) { // purge after reload right (new http session)
		if (!Object.keys(cacheFilterUser).length) { // server restart - first user - clear all filter cache
			options = {
				url: urlSegs.join("/") + "/_cache/clear",
				method: "GET"
			};
			httpClient.httpRequest(_, options).end().response();
		} else {
			var userLog = user.getEndpointLogin(_, currentEndpoint.$uuid);
			if (cacheFilterUser[userLog]) { // clear all filter cached for current user - user relogged
				cacheFilterUser[userLog].forEach_(_, function(_, key) {
					options = {
						url: urlSegs.join("/") + "/_cache/clear?filter_keys=" + key,
						method: "GET"
					};
					httpClient.httpRequest(_, options).end().response();
				});

			} //else nothin no filter cached for current user
		}

	}
	//
	//console.log("elasticQuery.context.parameters: " + sys.inspect(context));
	var contextEntity = context.searchEntityName || context.representation.entity;
	var entityName = context.parameters.entity || (contextEntity !== "queryResult" ? contextEntity : "");
	if (entityName) {
		allEntities.push(entityName);
	}
	// entity filter; overrides any entity parameters
	if (filters && filters.type) {
		allEntities = filters.type.slice(0);
	}
	// TODO : entity filter - when user has entity restrictions, generate an entity name like entity1,entity2,entityN
	//
	if (indexNames.length > 0) {
		urlSegs.push(indexNames.join(","));
	}
	if (allEntities.length > 0) {
		urlSegs.push(allEntities.join(","));
	}
	// Get Mappings
	options = {
		url: urlSegs.join("/") + "/_mapping",
		method: "GET"
	};
	req = httpClient.httpRequest(_, options);
	var end = req.end();
	var resp = end.response(_);
	var mappings = JSON.parse(resp.readAll(_));

	// if there is one entity only, mappings won't have the index name node. So add it to simplify code
	/*	if((allEntities.length === 1) && (indexNames.length === 1))
		mappings = {
			"index": mappings
		}*/
	var mapKeys = mappings && Object.keys(mappings);
	if (mapKeys && mapKeys.length) {
		// first level is NOT an index name ?
		if (indexNames.indexOf(mapKeys[0]) < 0) {
			// normalize mappings structure
			mappings = {
				"index": mappings
			};
		}
		logger.info(_) && logger.info(_, "elasticQuery.search mappings. Url: " + urlSegs.join("/") + "/_mapping ; result" + sys.inspect(mappings, null, 5));
		// Search
	}


	// Search type can be specified as a parameter in the URL or via the configuration
	// but defaults to a "starts with" search.
	var searchType = context.parameters.qt || searchConfig.searchType || "startsWith";

	// Search string is pre-processed according to the type
	var qProcessed = preProcessSearch(_, q, selectedLocale, searchType);

	// Set up the skeleton of the search before we decide which
	// type of query we will actually be using.
	var search = {
		from: context.parameters.startIndex - 1,
		size: context.parameters.count,
		query: {
			filtered: {
				query: {}
			}
		},

	};
	//if (!context.parameters.noHighlight) { desactivate for manage issue 99070 - TODO will be reactivet with elastic 1.x
	// add highlight_query to match only the field value and not the operation entered by the user (i.e : AND, OR, RANGE etc...)
	search.highlight = {
		fields: {
			"*": {}
		}
	};
	var hlquery = _addHighlightQuery(qProcessed.expression);
	if (hlquery) search.highlight.fields['*'].highlight_query = hlquery;
	//}
	var facetsMap = {};
	indexNames.forEach_(_, function(_, indexName) {
		facetsMap = elasticHelpers.getIndexFacets(_, elasticBaseUrl, indexName, {
			tracer: exports.tracer ? exports.tracer.trace : null
		}).reduce(function(prev, f) {
			prev[f.code] = f;
			return prev;
		}, facetsMap);
	});
	_addFacets(search, {
		searchFacets: facetsMap
	});

	// issue 2918 prevent elastic search syntax error
	if (qProcessed.fulltext.indexOf("/") >= 0) {
		qProcessed.fulltext = qProcessed.fulltext.replace(/\//g, "");
	}

	switch (searchType) {
		case "fuzzy":
			// Exact + fuzzy gives better results than just a fuzzy query
			// search.query = defineFuzzyQuery(searchConfig, q);
			search.query.filtered.query = defineExactPlusFuzzyQuery(searchConfig, qProcessed.fulltext);
			break;
		case "exact":
			search.query.filtered.query = defineExactQuery(searchConfig, qProcessed.fulltext);

			break;
		case "startsWith":

		default:
			// startsWith is the default query type,
			search.query.filtered.query = defineStartWithQuery(searchConfig, qProcessed.fulltext);
			break;
	}
	logger.debug(_) && logger.debug(_, "elasticQuery.search query: " + JSON.stringify(search.query, null, "\t"));


	// add management of right for the 2 kind of request.
	var hasNoAccess = false;
	if (right && !right.$entities) {
		hasNoAccess = !_addX3RightFilter(_, right, search, isFunction);
	} else if (right) {
		// don't generate filter for syracuse right in patch 3
		_addSyracuseRightFilter(_, right, search, urlSegs[0] + "/" + urlSegs[1], isFunction);
	}
	var respData = {};
	// console.log("has no access "+hasNoAccess);
	if (!hasNoAccess) {


		logger.debug(_) && logger.debug(_, "elasticQuery.search facetsMap: " + sys.inspect(facetsMap, null, 4));
		//

		var applyFilter = true;
		if (filters) {
			_addFilters(search.query, filters);
		}
		if (isFunction) {
			_addFunctionsFilter(_, search.query, endpoints);
		}
		if (where) {
			_addSdataWhere(search.query, where);
			applyFilter = false;

		}
		// apply cache filter


		if (applyFilter && currentEndpoint) {
			var suffix = suffixFilterCache ? suffixFilterCache : null;
			_addCacheFilter(_, search, user, currentEndpoint, isFunction, suffix);
		}

		logger.debug(_) && logger.debug(_, "elasticQuery.search query: " + JSON.stringify(search.query, null, "\t"));
		logger.info(_) && logger.info(_, "search " + JSON.stringify(search, null, 2));



		// !!!!!!! WARNING : stringify with indentation increase a lot the size - can cause crash !!!!!!
		//console.log("search " + JSON.stringify(search, null, 2));

		// Manage packet of 32ko, to prevent too big writes.
		var packetSize = 32768;
		var buf = new Buffer(JSON.stringify(search), "utf8");
		var idx = 0;
		options = {
			url: urlSegs.join("/") + "/_search",
			method: "POST",
			headers: {
				'content-type': 'application/json',
				'content-length': buf.length,
			}
		};
		req = httpClient.httpRequest(_, options);
		while (idx < buf.length) {
			var newIdx = (buf.length - idx > packetSize) ? (idx + packetSize) : buf.length;
			req.write(_, buf.slice(idx, newIdx));
			idx = newIdx;
		}

		//console.log("url " + require("util").inspect(options));

		// added for unit test in order to validate the request send to elastic search
		// Condition added to not keep the request in real cases !
		if (keepInContext) {
			context.searchRequest = search;
		}
		resp = req.end().response(_);
		respData = JSON.parse(resp.readAll(_));
		logger.debug(_) && logger.debug(_, "elasticQuery.search response: " + sys.inspect(respData, null, 5));
	}
	//
	if (respData.error) {
		return context.reply(_, respData.status, respData.error);
	}
	//
	var resultRes = {
		$resources: []
	};
	// create resources
	var fEp = endpoints.slice(0);
	if (adminEP && up.endpoints && up.endpoints(_).get(_, adminEP.$uuid) && !fEp.some_(_, function(_, ep) {
		return ep.protocol(_) === "syracuse";
	})) {
		fEp.push(adminEP);
	}
	context.totalCount = respData && respData.hits && respData.hits.total;

	if (respData.hits && respData.hits.hits) {
		respData.hits.hits.forEach_(_, function(_, hit) {
			/*
			 *  remove facet regarding the right, as we remove data we have also to remove facet that count certain value
			 */
			function _removeFacet(hit, context, respData) {
				var i;
				Object.keys(respData.facets).forEach(function(facetKey) {
					if (hit._source["facet_" + facetKey]) {
						for (i = 0; respData.facets[facetKey] && i < respData.facets[facetKey].terms.length && respData.facets[facetKey].terms[i].term === hit._source["facet_" + facetKey]; i++) {}
						if (respData.facets[facetKey] && respData.facets[facetKey].terms && respData.facets[facetKey].terms[i] && respData.facets[facetKey].terms[i].term === hit._source["facet_" + facetKey]) {
							respData.facets[facetKey].terms[i - 1].count--;
							if (respData.facets[facetKey].terms[i - 1].count === 0) {
								delete respData.facets[facetKey];
							}
						}
					}
				});
				for (i = 0; respData.facets.type && i < respData.facets.type.length && respData.facets.type.terms[i].term === hit._type; i++) {}
				if (respData.facets.type && respData.facets.type.terms && respData.facets.type.terms[i - 1] && respData.facets.type.terms[i - 1].term === hit._type) {
					respData.facets.type.terms[i - 1].count--;
					if (respData.facets.type.terms[i - 1].count === 0) {
						delete respData.facets.type;
					}
				}
				context.totalCount--;
			}

			//console.log("--------------type "+hit._type);
			// replace source element by hightlight when necessary
			var resource;
			if (hit._type === "function") {
				var r = hit._source.$rawData;
				r && _selectEndpoints(_, up).forEach_(_, function(_, e) {
					resource = _makeFunctionResource(_, e, mappings, hit, endpoints.length > 1, right, qProcessed.fulltext, context);
					if (resource) {
						resultRes.$resources.push(resource);
					} else {
						respData.facets && _removeFacet(hit, context, respData);
					}
				});
			} else {
				resource = _makeResource(_, mappings, hit, context.representation ? context.representation.entity : context.searchEntityName, context.representation.type, right, qProcessed.fulltext, context);
				if (resource) {
					resultRes.$resources.push(resource);
				} else {
					respData.facets && _removeFacet(hit, context, respData);
				}
			}

		});
	}
	// create search facets
	var facet;

	function membersMap(item) {
		var facetMember = {
			$title: item.term,
			$value: item.term,
			$count: item.count,
			$links: {}
		};
		if (facet === "type") {
			facetMember.$title = _getTypeTitle(mappings, item.term);
		}
		// filters
		if (filters && filters[facet]) {
			if (Array.isArray(filters[facet]) && (filters[facet].indexOf(item.term) >= 0)) {
				facetMember.$selected = true;
			}
		}
		// links
		return facetMember;
	}
	if (respData.facets) {
		resultRes.$searchFacets = [];
		for (facet in respData.facets) {
			var facetDef = {};
			if (facet === "type") {
				facetDef = {
					$title: "Type"
				};
			} else {
				facetDef = facetsMap[facet];
			}
			resultRes.$searchFacets.push({
				$facet: facet,
				$title: facetDef.description,
				$missing: respData.facets[facet].missing,
				$members: (respData.facets[facet].terms || []).map(membersMap)
			});
		}
	}
	//
	resultRes.query = context.parameters.q || context.parameters.search;

	//}

	context.replySearchResults(_, 200, resultRes);

	// purge list of prototype read - optim search
};