"use strict";

var sdataRegistry = require("syracuse-sdata/lib/sdataRegistry");
var dataModel = require("syracuse-orm/lib/dataModel");
var http = require("http");
var streams = require("streamline/lib/streams/streams");
var helpers = require('syracuse-core/lib/helpers')
var elasticHelpers = require("syracuse-search/lib/helpers");
var forEachKey = helpers.object.forEachKey;
var jsurl = require("jsurl");
//var indexMeta = require("syracuse-search/lib/indexMeta");
var sys = require("util");
var locale = require("syracuse-core/lib/locale");
var httpHelper = require("syracuse-sdata/lib/httpHelper");

exports.tracer = null;
exports.serverConfig = null;

function _indexToContract(indexName) {
	var parts = indexName.split(".");
	return sdataRegistry.getContract(parts[0], parts[1], false);
}

function _getTypeTitle(mapping, typeName) {
	var title = typeName;
	Object.keys(mapping).forEach(function(idx) {
		var map = mapping[idx][typeName];
		//console.log("map(31): "+typeName+"; "+sys.inspect(mapping[idx]));
		if(map && map._meta && map._meta.$classTitle)
			title = map._meta.$classTitle;
	});
	return title;
}

function _addFacets(query, contract) {
	if (!contract || !contract.searchFacets) return;
	query.facets = query.facets || {
		type: {
			terms: {
				field: "_type"
			}
		}
	};
	forEachKey(contract.searchFacets, function(key, facet) {
		query.facets[key] = {
			terms: {
				fields: ["facet_"+key]
			}
		};
	});
}

function _addFilters(query, filters) {
	if(!filters) return;
	var filter = query.filtered.filter = query.filtered.filter || {};
	filter.and = filter.and || [];
	forEachKey(filters, function(key, facet) {
		if(key === "type") return;
		//
		var part = { query: { terms: {}}};
		part.query.terms["facet_"+key] = facet.slice(0);
		filter.and.push(part);
	});
}

function _makeFunctionResource(_, endpoint, mapping, hit, isMultiEP) {
	var title = _getTypeTitle(mapping, hit._type);
	// items base url
	var r = {
		$url: hit._source.$url,
		$baseUrl: endpoint.getBaseUrl(_),
		$uuid: hit._id,
		type: title,
		$representation: hit._type,
		description: locale.format(module, isMultiEP ? "functionMultiDescription" : "functionMonoDescription", hit._source.$description, endpoint.description(_)),
		icon: (hit._source.$icon?{$url: hit._source.$icon, $type: "image"}:null),
		$properties: {
			description: {
				$links: {
					$details: {
						$type: "application/json;vnd.sage=syracuse",
						$url: "{$url}",
						$method: hit._source.$method
					}
				}
			}
		}
	}
	if(hit._source.linkType === "$function")
		r.$baseUrl = r.$baseUrl.replace("/sdata/", "/trans/");
	return r;
}

function _makeResource(mapping, hit) {
	var title = _getTypeTitle(mapping, hit._type);
	// items base url
	var r = {
		$url: hit._source.$url,
		$uuid: hit._id,
		type: title,
		$representation: hit._type,
		description: hit._source.$description,
		icon: (hit._source.$icon?{$url: hit._source.$icon, $type: "image"}:null),
		$properties: {
			description: {
				$links: {
					$details: {
						$type: "application/json;vnd.sage=syracuse",
						$url: "{$url}"
					}
				}
			}
		}
	}
	return r;
}


//select existing indexes available to the user
function _selectIndexes(_, elasticBaseUrl, userProfile, selectedIndexName) {
	function _addIndex(_, indexName, localeCode) {
		var idx = indexName + "." + localeCode.toLowerCase();
		if(elasticHelpers.indexExists(_, elasticBaseUrl, idx)) 
			indexes.push(idx);
		else
			(localeCode !== elasticHelpers.fallbackLocale) && _addIndex(_, indexName, elasticHelpers.fallbackLocale);
	}
	function _addEP(_, ep, localeCode) {
		var idx = ep.getIndexName(_, localeCode || locale.current);
		if(elasticHelpers.indexExists(_, elasticBaseUrl, idx)) {
			indexes.push(idx);
		} else
			(localeCode !== elasticHelpers.fallbackLocale) && _addEP(_, ep, elasticHelpers.fallbackLocale);
	}
	//
	var indexes = [];
	if(selectedIndexName) 
		_addIndex(_, selectedIndexName, locale.current);
	else {
		if(userProfile) {
			if(userProfile.selectedEndpoint(_)) 
				_addEP(_, userProfile.selectedEndpoint(_));
			else {
				userProfile.endpoints(_).toArray(_).forEach_(_, function(_, endpoint) {
					_addEP(_, endpoint);
				});
			}
		}
	}
	_addIndex(_, elasticHelpers.functionIndexName, locale.current);
	//
	return indexes;
}

	// select endpoints available to the user
function _selectEndpoints(_, userProfile) {
	var eps = [];
	if(userProfile) {
		if(userProfile.selectedEndpoint(_)) 
			eps.push(userProfile.selectedEndpoint(_));
		else {
			eps = userProfile.endpoints(_).toArray(_).slice(0);
		}
	}
	return eps;
}

exports.search = function(_, context, contractName, applicationName, datasetName, entityName) {
	var filters = jsurl.parse(context.parameters.filters);
	// TODO: as we cannot match an entity and his index, we should execute search one index at a time
	// to allow search on index1.entity1 and index2.entity2 but not index1.entity2
	// for now just push entities into allEntities.
	//
	// load index names
	var allEntities = [];
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	var indexNames = _selectIndexes(_, elasticBaseUrl, context.getUserProfile(_), (filters && filters.index && filters.index[0]) || context.searchIndexName);
	var endpoints = _selectEndpoints(_, context.getUserProfile(_));
	exports.tracer && exports.tracer("elasticQuery.indexNames: "+sys.inspect(indexNames));
	if(!indexNames.length)
		return context.reply(_, httpHelper.HttpStatus.NotFound, locale.format(module, "noIndexAvailable", locale.current, elasticHelpers.fallbackLocale))
	//
	entityName = context.searchEntityName || entityName;
	if(entityName) allEntities.push(entityName);
	// entity filter; overrides any entity parameters
	if(filters && filters.type) 
		allEntities = filters.type.slice(0);
	// TODO : entity filter - when user has entity restrictions, generate an entity name like entity1,entity2,entityN
	//
	var urlSegs = [exports.serverConfig.baseUrl];
	indexNames.length && urlSegs.push(indexNames.join(","));
	allEntities.length && urlSegs.push(allEntities.join(","));
	// Get Mappings
	var options = {
			url: urlSegs.join("/") + "/_mapping",
			method: "GET"
		};
	var req = streams.httpRequest(options);
	var mappings = JSON.parse(req.end().response(_).readAll(_));
	// if there is one entity only, mappings won't have the index name node. So add it to simplify code
	if(allEntities.length === 1)
		mappings = {
			"index": mappings
		}
	//
	exports.tracer && exports.tracer("elasticQuery.search mappings: " + sys.inspect(mappings, null, 5));
	// Search
    var options = {
		url: urlSegs.join("/") + "/_search",
		method: "POST"
	};
	var req = streams.httpRequest(options);
	var q = context.parameters.q;
	var search = {
		from: context.parameters.startIndex - 1,
		size: context.parameters.count,
		query: {
			filtered: {
				query: {
					query_string: {
						default_field: "_all",
						query: q,
						default_operator: "AND",
						analyze_wildcard: true
					}
				},
				filter: { // right management example
					and: [{
						or: [{
							query: {
								field: {
									authorizations: "Administrator"
								}
							}
						}, {
							missing: {
								field: "authorizations"
							}
						}]
					}]
				}
			}
		}
	};
	//
	indexNames.forEach_(_, function(_, indexName) {
		var contract = _indexToContract(indexName);
		contract && _addFacets(search, contract);
	});
	//
	filters && _addFilters(search.query, filters);
	//
	exports.tracer && exports.tracer("elasticQuery.search query: " + sys.inspect(search, null, 8));
	//
	req.write(_, JSON.stringify(search));
	var resp = req.end().response(_);
	var respData = JSON.parse(resp.readAll(_));
	exports.tracer && exports.tracer("elasticQuery.search response: " + sys.inspect(respData, null, 5));
	//
	if(respData.error)
		return context.reply(_, respData.status, respData.error);
	//
	var resultRes = {
		$resources: []
	};
	// create resources
	if (respData.hits && respData.hits.hits) respData.hits.hits.forEach_(_, function(_, hit) {
		if(hit._type === "function") {
			var r = hit._source.$rawData;
			r && endpoints.forEach_(_, function(_, e) {
				if(r.endpoint && (e.$uuid !== r.endpoint)) return;
				if(r.application && (e.applicationRef(_).$uuid !== r.application)) return;
				resultRes.$resources.push(_makeFunctionResource(_, e, mappings, hit, endpoints.length > 1));
			});
		} else
			resultRes.$resources.push(_makeResource(mappings, hit));
	});
	// create search facets
	var facet;
	if (respData.facets) {
		resultRes.$searchFacets = [];
		for (facet in respData.facets) {
			var facetDef = {};
			if(facet === "type")
				facetDef = {$title:"Type"};
			else
				// search facet, TODO: optimize
				indexNames.forEach(function(name) {
					var contract = _indexToContract(name);
					if(contract)
						facetDef = contract.searchFacets[facet] || {};
					else {
//						var index = indexMeta[name];
//						if(index)
//							facetDef = index.searchFacets[facet] || {};
					}
				});
//			var facetDef = contract.searchFacets[facet] || {};
			var facetBaseUrl = "/sdata/"+applicationName+"/"+contractName+"/"+datasetName+"/";
			resultRes.$searchFacets.push({
				$facet: facet,
//				$title: facet,
				$title: facetDef.$title,
				$missing: respData.facets[facet].missing,
				$members: (respData.facets[facet].terms || []).map(function(item) {
					var facetMember = {
						$title: item.term, 
						$value: item.term,
						$count: item.count,
						$links: {}
					};
					if(facet === "type") 
						facetMember.$title = _getTypeTitle(mappings, item.term);
					// filters
					if(filters && filters[facet])
						if(Array.isArray(filters[facet]) && (filters[facet].indexOf(item.term) >= 0))
							facetMember.$selected = true;
					// links
					return facetMember;
				})
			});
		}
//		console.log("facets: "+sys.inspect(respData.facets, null, 4));
	}
	//
	context.totalCount = respData && respData.hits && respData.hits.total;
	context.replySearchResults(_, 200, resultRes.$resources, resultRes.$searchFacets);
}

