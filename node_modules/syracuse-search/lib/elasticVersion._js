"use strict";

var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var streams = require('streamline/lib/streams/streams');
var locale = require('syracuse-core/lib/locale');

var loghelper = require("syracuse-trace/lib/helper");

// Installed version, Minimum compatible version and Recommended version
var installedVersion;
var minVersion = [0, 90, 8];
var recVersion = [0, 90, 12];

// Maximum version is not currently used, hence the setting
var maxVersion = [99, 99, 999];

exports.serverConfig = null;

function isRecVersion(instVer, recVers) {
	return (instVer[0] === recVers[0] && instVer[1] === recVers[1] && instVer[2] === recVers[2]);
}

function compatibleVersion(instVer, compVer, higher) {
	var isCompatible;

	// Version checking is somewhat more complex due to the major, minor, increment
	// parts of the version number which need to be considered in order.

	if (higher) {
		if (instVer[0] === compVer[0]) {
			if (instVer[1] === compVer[1]) {
				isCompatible = (instVer[2] >= compVer[2]);
			} else {
				isCompatible = (instVer[1] > compVer[1]);
			}
		} else {
			isCompatible = (instVer[0] > compVer[0]);
		}
	} else {
		if (instVer[0] === compVer[0]) {
			if (instVer[1] === compVer[1]) {
				isCompatible = (instVer[2] <= compVer[2]);
			} else {
				isCompatible = (instVer[1] < compVer[1]);
			}
		} else {
			isCompatible = (instVer[0] < compVer[0]);
		}
	}

	// Check major/minor/increment in that order
	return isCompatible;
}

// Return the requested version (min, max, rec), primarily for configuration
// of the unit tests.

exports.getSupportedVersion = function(ver) {
	var retVer;
	switch (ver) {
		case "min":
			retVer = minVersion;
			break;
		case "max":
			retVer = maxVersion;
			break;
		default:
			retVer = recVersion;
			break;
	}

	return retVer;
};

exports.getAboutInfo = function(_) {
	var searchConf = config.searchEngine || {};
	var req = streams.httpRequest({
		url: exports.serverConfig.baseUrl,
		method: "GET"
	});
	return JSON.parse(req.end().response(_).readAll(_));
};

exports.getElasticVersion = function(_, searchBaseUrl, opts) {

	// Query the elastic search base URL to get the about information
	var options = {
		url: searchBaseUrl,
		method: "GET"
	};
	var req = streams.httpRequest(options);
	var about = JSON.parse(req.end().response(_).readAll(_));
	var version = (opts && opts.version) || about.version.number;

	// Split the version into numbers for easy comparison
	installedVersion = version.split(".").map(function(v) {
		return +v;
	});

	return installedVersion;
};

/*S
 * return true if the version installed is the recommended version else false
 * throw an error when the version installed is not supported
 */
exports.checkVersion = function(_, searchBaseUrl, opts) {
	var instVersion = exports.getElasticVersion(_, searchBaseUrl, opts);
	var logger = loghelper.getTracer("search");
	logger.debug() && logger.debug("Installed version: " + instVersion);

	if (!compatibleVersion(instVersion, opts && opts.minVersion || minVersion, true)) {
		throw new Error(locale.format(module, "incompatibleVersion", instVersion.join("."), (opts.minVersion || minVersion).join("."), (opts.recVersion || recVersion).join(".")));
	}

	if (!compatibleVersion(instVersion, opts && opts.maxVersion || maxVersion, false)) {
		throw new Error(locale.format(module, "newerVersion", instVersion.join("."), (opts.recVersion || recVersion).join("."), (opts.minVersion || minVersion).join("."), (opts.maxVersion || maxVersion).join(".")));
	}

	return isRecVersion(instVersion, opts && opts.recVersion || recVersion);
};