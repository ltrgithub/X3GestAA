"use strict";

var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var globals = require('streamline/lib/globals');
var flows = require('streamline/lib/util/flows');
var helpers = require('syracuse-core/lib/helpers');
var forEachKey = helpers.object.forEachKey;
var streams = require("streamline/lib/streams/streams");
var resourceHelpers = require("syracuse-core/lib/resource/util");
var resourceProxy = require("syracuse-core/lib/resource/resourceProxy");
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var datetime = require("syracuse-core/lib/types/datetime");
var locale = require("syracuse-core/lib/locale");
var elasticHelpers = require("syracuse-search/lib/helpers");
var sys = require("util");

exports.tracer = null;
//exports.tracer = console.log;
exports.serverConfig = null;

// defines
var functionIndexName = "sage.x3.functions";

// TODO: map all locales codes to supported elasticsearch analyzers
var _analyzersMap = {
	"en-us": "english",
	"en-gb": "english",
	"fr-fr": "french",
	"de-de": "german",
	"it-it": "italian",
	"es-es": "spanish"
};

function _createInstanceIndexResource(_, instance, endpoint, options) {
	function _computeUrl(_, inst) {
		//		console.log("compute url: " + sys.inspect(entity.$urlTemplate));
		return entity.$urlTemplate && entity.$urlTemplate.resolve({
			$baseUrl: endpoint.getBaseUrl(_),
			$key: instance.computeKey()
		});
	}

	function decodeTemplate(_, inst, templ) {
		if (!templ) return;
		var template = templ;
		if (typeof templ === "string") template = new resourceProxy.Template(templ);
		var res = template.expression;
		template.matches.forEach_(_, function(_, match) {
			var prop = match.substring(1, match.length - 1);
			if (inst._meta.$properties[prop]) res = res.replace(match, resourceHelpers.formatValue(inst._meta.$properties[prop], inst[prop](_)) || "");
			else if (inst._meta.$relations[prop]) {
				if (inst._meta.$relations[prop].isPlural) res = res.replace(match, inst[prop](_).toArray(_).map_(_, function(_, elem) {
					return decodeTemplate(_, elem, inst._meta.$relations[prop].targetEntity.$valueTemplate);
				}).join(","));
				else res = res.replace(match, decodeTemplate(_, inst[prop](_), inst._meta.$relations[prop].targetEntity.$valueTemplate));
			}
		});
		return res;
	}
	var opt = options || {};
	options && options.tracer && options.tracer("ElasticIndex.createResource: enter: " + instance.$uuid);
	var entity = instance.getEntity(_);
	var facets = entity.getSearchFacets(_);
	var inst = instance;
	var data = {};
	(entity.getSearchFields(_) || []).forEach_(_, function(_, field) {
		var val = null;
		var p;
		if (p = entity.$properties[field]) {
			val = resourceHelpers.formatValue(p, inst[field](_));
		} else if (p = entity.$relations[field]) {
			var rel = entity.$relations[field];
			var relData = inst[field](_);
			var childOpt = opt;
			if (rel.isChild) {
				childOpt = _unfixFunctionsOptions(opt);
				childOpt.isChild = true;
			}
			if (rel.isPlural) relData.toArray(_).forEach_(_, function(_, item) {
				(val = val || []).push(rel.isChild ? _createInstanceIndexResource(_, item, endpoint, childOpt) : decodeTemplate(_, item, rel.targetEntity.$valueTemplate));
			});
			else if (relData) val = rel.isChild ? _createInstanceIndexResource(_, relData, endpoint, childOpt) : decodeTemplate(_, relData, rel.targetEntity.$valueTemplate);

		}
		options && options.tracer && options.tracer("ElasticIndex.createResource: compute field: " + field + "; value: " + val);
		//
		if (val) {
			data[field] = val;
			// facets is a structure like 
			// {
			//		classField: ["facet1Name", "facet2Name"]
			// }
			// one field can be part of several facets
			if (facets && facets[field]) facets[field].forEach(function(f) {
				options && options.tracer && options.tracer("ElasticIndex.createResource: field facet: " + f);
				data["facet_" + f] = val;
			});
		}
	});
	// add some data to the resource
	(opt.rawData || []).forEach_(_, function(_, relName) {
		options && options.tracer && options.tracer("ElasticIndex.createResource: set rawData for relation: " + relName);
		var rel = entity.$relations[relName];
		if (!rel) return;
		data["$rawData"] = data["$rawData"] || {};
		var relData = inst[relName](_);
		if (rel.isPlural) relData.toArray(_).forEach_(_, function(_, item) {
			(data.$rawData[relName] = data.$rawData[relName] || []).push(item.$uuid);
		});
		else if (relData) {
			data.$rawData[relName] = relData.$uuid;
			options && options.tracer && options.tracer("ElasticIndex.createResource: rawData found for " + relName + ": " + relData.$uuid);
		}
	});
	options && options.tracer && options.tracer("ElasticIndex.createResource: compute templates");
	if (!(options && options.isChild)) {
		data.$description = decodeTemplate(_, inst, entity.$summaryTemplate || entity.$valueTemplate);
		if (entity.$iconTemplate) data.$icon = decodeTemplate(_, inst, entity.$iconTemplate);
		//
		var url = (opt.computeUrl || _computeUrl)(_, instance);
		if (url) data.$url = url;
		var method = opt.computeUrlMethod && opt.computeUrlMethod(_, instance);
		if (method) data.$method = method;
	}
	//
	return data;
}

function _unfixFunctionsOptions(options) {
	options = options || {};
	var o = helpers.object.clone(options);
	o.rawData = null;
	o.computeUrl = null;
	o.computeUrlMethod = null;
	return o;
}

function _fixFunctionsOptions(options) {
	options = options || {};
	var o = helpers.object.clone(options);
	o.indexName = functionIndexName;
	o.indexTypeName = "function";
	o.indexTypeTitle = "Function";
	o.rawData = ["application", "endpoint"];
	o.computeUrl = function(_, instance) {
		return instance.getItemUrl(_);
	};
	o.computeUrlMethod = function(_, instance) {
		return instance.getMethod(_);
	};
	return o;
}

function ElasticIndex(ep, localeCode) {
	this._endpoint = ep;
	this._locale = localeCode || locale.current;
	this._locale = this._locale.toLowerCase();
}

exports.IndexHelper = helpers.defineClass(ElasticIndex, null, {
	getIndexName: function(_, opt) {
		var name = opt && opt.indexName ? opt.indexName + (this._locale ? "." + this._locale : "") : this._endpoint.getIndexName(_, this._locale);
		if (globals.context.tenantId) name = globals.context.tenantId + '.' + name;
		return name;
	},
	updateInstance: function(_, instance, options) {
		var opt = options || {};
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: enter: " + instance._meta.name + "." + instance.$uuid);
		// 
		var self = this;
		var _indexName = self.getIndexName(_, opt);
		var elasticBaseUrl = exports.serverConfig.baseUrl;
		if (!elasticHelpers.indexExists(_, elasticBaseUrl, _indexName, {
			silent: true
		})) return;
		//
		var entity = instance.getEntity(_);
		var f = entity.getSearchFields(_);
		if (!f || !f.length) return;

		var reqOptions = {
			url: [elasticBaseUrl, _indexName, opt.indexTypeName || entity.name, instance.computeKey()].join("/"),
			method: 'PUT'
		};
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: url: " + reqOptions.url);
		var req = streams.httpRequest(reqOptions);
		var data = _createInstanceIndexResource(_, instance, self._endpoint, options);
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: index data: " + sys.inspect(data));
		req.write(_, JSON.stringify(data));
		var resp = req.end().response(_);
		//
		var diag = JSON.parse(resp.readAll(_));
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: index response: " + sys.inspect(diag));
		if (options && options.diagnoses) {
			if (diag.ok) options.diagnoses.push({
				severity: "info",
				message: locale.format(module, "instanceUpdated", instance.getValue(_))
			});
			else if (diag.error) options.diagnoses.push({
				severity: "error",
				message: diag.error
			});
		}
	},
	updateEntity: function(_, entity, differential, options) {
		var opt = options || {};
		var diag = opt.diagnoses || [];
		opt.tracer && opt.tracer("ElasticIndex.updateEntity: enter: " + entity.name);
		//
		var self = this;
		var _indexName = self.getIndexName(_, opt);
		var elasticBaseUrl = exports.serverConfig.baseUrl;
		var db = self._endpoint.getOrm(_);

		opt.tracer && opt.tracer("ElasticIndex.updateEntity: mapping update");
		// update mapping
		_indexMappingUpdate(_, _indexName, entity, entity.getSearchFacets(_), opt);
		// update prototype info: TODO ? not now, maybe 7.1 ?
		//self.updatePrototype(_, entity, opt);
		// update data
		var where = null;
		if (differential && self._endpoint.lastIndexDate(_)) {
			where = {
				sdataWhere: "(" + db.getUpdDatePropName() + " gt \"" + self._endpoint.lastIndexDate(_).toJsDate().toISOString() + "\")"
			};
		}
		//
		opt.tracer && opt.tracer("ElasticIndex.updateEntity: fetching data");
		var cnt = 0;
		var cursor = db.createCursor(_, entity, where, "$search");
		var inst = cursor.next(_);
		if (inst) {
			var aborted = false;
			do {
				var _options = {
					url: elasticBaseUrl + "/_bulk",
					method: 'PUT'
				};
				var req = streams.httpRequest(_options);
				do {
					aborted = opt.tracker && opt.tracker.abortRequested;
					//
					var action = {
						index: {
							_index: _indexName,
							_type: opt.indexTypeName || entity.name,
							_id: inst.computeKey()
						}
					};
					req.write(_, JSON.stringify(action) + "\n");
					var data = _createInstanceIndexResource(_, inst, self._endpoint, opt);
					opt.tracer && opt.tracer("ElasticIndex.updateEntity: index data: " + sys.inspect(data));
					req.write(_, JSON.stringify(data) + "\n");
					cnt++;
					inst = cursor.next(_);
				} while (inst && (cnt % 1000 !== 0) && !aborted);
				var resp = req.end().response(_);
				//
				_processElasticResp(_, resp, null, diag, entity.name + " records updated");
			} while (inst && !aborted);
		}
		diag && diag.push({
			severity: "info",
			message: locale.format(module, "updateCount", cnt, entity.name)
		});
	},
	updateIndex: function(_, differential, options) {
		function _track(phase, detail, progress) {
			if (!opt.tracker) return;
			opt.tracker.phase = phase;
			opt.tracker.phaseDetail = detail;
			opt.tracker.progress = progress;
		}
		var opt = options || {};
		opt.diagnoses = opt.diagnoses || [];
		opt.tracer && opt.tracer("ElasticIndex.updateIndex enter");
		if (opt.locale) globals.context.sessionLocale = opt.locale;
		var self = this;
		var model = self._endpoint.getModel(_);
		var indexTime = datetime.now();
		var indexName = self.getIndexName(_, opt);
		//
		opt.tracer && opt.tracer("ElasticIndex.updateIndex creating index");
		adminHelpers.AdminHelper.logServerMessage(_, locale.format(module, "startIndexUpd", indexName), []);
		_track(locale.format(module, "startIndexUpd", indexName), "", 0);
		_indexCreate(_, self.getIndexName(_, opt), self._locale, model, opt);
		//
		var entities = [];
		/*		if(opt.representations && opt.representations.length) {
		opt.representations.forEach_(_, function(_, r) {
			// sanitize
			var ent = model.getRepresentation(_, r, "$search");
			if(ent)
				entities.push(ent);
			else
				opt.diagnoses.push({ severity: "warning", message: locale.format(module, "reprNotFound", r) });
		});
		} else
			entities = model.getIndexedEntities(_);*/
		if (opt.entities && opt.entities.length) {
			opt.entities.forEach_(_, function(_, r) {
				// sanitize
				var e = model.getEntity(_, r, "$search");
				if (e) entities.push(e);
				else opt.diagnoses.push({
					severity: "warning",
					message: locale.format(module, "entNotFound", r)
				});
			});
		} else entities = model.getIndexedEntities(_);
		// use some instead of forEach to be able to abort loop
		var idx = 0;
		entities.some_(_, function(_, entity) {
			_track(locale.format(module, "indexingEntity"), entity.name, Math.ceil(idx++ * 100 / entities.length));
			try {
				self.updateEntity(_, entity, differential, opt);
				// index menuItems as functions
				if (entity.name === "menuItem") {
					self.updateFunctions(_, entity, differential, opt);
				}
			} catch (e) {
				opt.diagnoses.push({
					severity: "error",
					message: e.message
				});
				opt.diagnoses.push({
					severity: "error",
					message: e.stack
				});
				//				adminHelpers.AdminHelper.logServerMessage(_, locale.format(module, "endIndexUpd", indexName), opt.diagnoses);
			}
			if (opt.tracker && opt.tracker.abortRequested) {

				return true;
			} else return false;
		});
		var msg = opt.tracker && opt.tracker.abortRequested ? locale.format(module, "indexUpdAborted") : locale.format(module, "endIndexUpd", indexName);
		opt.diagnoses.push({
			severity: "success",
			message: msg
		});
		_track("", msg, 100);
		opt.diagnoses && adminHelpers.AdminHelper.logServerMessage(_, msg, opt.diagnoses);

		//
		self._endpoint.lastIndexDate(_, indexTime);
		self._endpoint.save(_);
	},
	updateFunctions: function(_, menuItemEntity, differential, options) {
		var self = this;
		var entity = menuItemEntity;
		// ensure functions index
		_indexCreate(_, self.getIndexName(_, {
			indexName: functionIndexName
		}), self._locale, self._endpoint.getModel(_), options);
		//
		self.updateEntity(_, entity, differential, _fixFunctionsOptions(options));
	},
	updateFunctionInstance: function(_, instance, options) {
		var self = this;
		// ensure functions index
		_indexCreate(_, self.getIndexName(_, {
			indexName: functionIndexName
		}), self._locale, self._endpoint.getModel(_), options);
		//
		self.updateInstance(_, instance, _fixFunctionsOptions(options));
	},
	updatePrototype: function(_, entity, options) {
		var opt = options || {};
		options && options.tracer && options.tracer("ElasticIndex.updatePrototype: enter: " + entity.name);
		// 
		var self = this;
		var _indexName = self.getIndexName(_, opt);
		var elasticBaseUrl = exports.serverConfig.baseUrl;

		var reqOptions = {
			url: [elasticBaseUrl, _indexName, "$prototype", entity.name + ".$query"].join("/"),
			method: 'PUT'
		};
		options && options.tracer && options.tracer("ElasticIndex.updatePrototype: url: " + reqOptions.url);
		var req = streams.httpRequest(reqOptions);
		var data = entity.getPrototype(_, "$query"); // TODO
		options && options.tracer && options.tracer("ElasticIndex.updatePrototype: index data: " + sys.inspect(data));
		req.write(_, JSON.stringify(data));
		var resp = req.end().response(_);
		//
		var diag = JSON.parse(resp.readAll(_));
		options && options.tracer && options.tracer("ElasticIndex.updatePrototype: index response: " + sys.inspect(diag));
		if (options && options.diagnoses) {
			if (diag.ok) options.diagnoses.push({
				severity: "info",
				message: locale.format(module, "prototypeUpdated", entity.name)
			});
			else if (diag.error) options.diagnoses.push({
				severity: "error",
				message: diag.error
			});
		}
	}
});

function _processElasticResp(_, elasticResp, contextResp, diagnoses, okMessage) {
	if (diagnoses) {
		var diag = JSON.parse(elasticResp.readAll(_));
		if (diag.ok) diagnoses.push({
			severity: "info",
			message: okMessage
		});
		else if (diag.error) diagnoses.push({
			severity: "error",
			message: diag.error
		});
	} else {
		var buffer;
		while (buffer = elasticResp.read(_)) contextResp.write(_, buffer);
	}
}

function _addFacetFieldsMapping(searchFacets, entityName, mapping) {
	if (!searchFacets) return;
	forEachKey(searchFacets, function(classField, facets) {
		if (!facets) return;
		facets.forEach(function(f) {
			mapping[entityName].properties["facet_" + f] = {
				type: "string",
				analyzer: "keyword"
			};
		});
	});
}

function _indexMappingUpdate(_, indexName, entity, searchFacets, opt) {
	opt = opt || {};
	var entityName = opt.indexTypeName || entity.name;
	var diagnoses = opt && opt.diagnoses;
	var mapping = {};
	mapping[entityName] = {
		properties: {},
		_meta: {
			$classTitle: opt.indexTypeTitle || entity.$classTitle || (entity.$titleTemplate && entity.$titleTemplate.expression)
		}
	};
	var pm = mapping[entityName].properties;
	pm.$description = {
		type: "string",
		index: "no",
		include_in_all: false
	};
	pm.$title = {
		type: "string",
		index: "no",
		include_in_all: false
	};
	pm.$icon = {
		type: "string",
		index: "no",
		include_in_all: false
	};
	pm.$url = {
		type: "string",
		index: "no",
		include_in_all: false
	};
	// create a mapping for all localized properties
	// get all searchable locales
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	db.fetchInstances(_, db.getEntity(_, "localePreference"), {
		jsonWhere: {
			enabled: true,
			searchable: true
		}
	}).map_(_, function(_, l) {
		return l.code(_);
	});
	//
	_addFacetFieldsMapping(searchFacets, entityName, mapping);
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	var options = {
		url: elasticBaseUrl + "/" + indexName + "/" + entityName + "/_mapping",
		method: 'PUT'
	};
	var req = streams.httpRequest(options);
	req.write(_, JSON.stringify(mapping));
	var resp = req.end().response(_);
	exports.tracer && exports.tracer("elasticIndex.index exists status: " + resp.statusCode + "; entity: " + entityName);
	//
	_processElasticResp(_, resp, null, diagnoses, locale.format(module, "mappingUpdated", entityName));
}

// indexName already has localeCode
function _indexCreate(_, indexName, localeCode, model, options) {
	var opt = options || {};
	var diagnoses = opt.diagnoses;
	// check if index exists
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	if (!elasticHelpers.indexExists(_, elasticBaseUrl, indexName, opt)) {
		// create index
		var reqUrl = elasticBaseUrl + "/" + indexName;
		var par = {
			url: reqUrl,
			method: 'PUT'
		};
		var req = streams.httpRequest(par);
		var a;
		if (localeCode && (a = _analyzersMap[localeCode])) {
			req.write(_, JSON.stringify({
				"settings": {
					"index": {
						"analysis": {
							"analyzer": {
								"default": {
									"type": a
								}
							}
						}
					}
				}
			}));
		}
		var resp = req.end().response(_);
		opt.tracer && opt.tracer("elasticIndex.index put settings status: " + resp.statusCode);
		//
		_processElasticResp(_, resp, null, diagnoses, locale.format(module, "indexCreated", indexName));
		// add search facets: add to index a new type $facet, every entry should have code and description; the id is the code 
		// create a mapping
		var mapping = {
			$facet: {
				properties: {
					code: {
						type: "string",
						index: "no",
						include_in_all: false
					},
					description: {
						type: "string",
						index: "no",
						include_in_all: false
					}
				}
			}
		};
		var _options = {
			url: elasticBaseUrl + "/" + indexName + "/$facet/_mapping",
			method: 'PUT'
		};
		req = streams.httpRequest(_options);
		req.write(_, JSON.stringify(mapping));
		resp = req.end().response(_);
		//
		_processElasticResp(_, resp, null, diagnoses, locale.format(module, "mappingUpdated", "$facet"));
		// index facets
		// indexing facets one by one is easyier to make them non searchable than if we would add a map. 
		var facets = model.getSearchFacets(_);
		if (facets && facets.length) {
			opt.tracer && opt.tracer("ElasticIndex.updateFacets");
			//
			var _indexName = indexName;
			//
			_options = {
				url: elasticBaseUrl + "/_bulk",
				method: 'PUT'
			};
			req = streams.httpRequest(_options);
			//
			facets.forEach_(_, function(_, f) {
				var action = {
					index: {
						_index: _indexName,
						_type: "$facet",
						_id: f.code
					}
				};
				req.write(_, JSON.stringify(action) + "\n");
				opt.tracer && opt.tracer("ElasticIndex.updateFacets: index data: " + sys.inspect(f));
				req.write(_, JSON.stringify(f) + "\n");
			});
			resp = req.end().response(_);
			//
			_processElasticResp(_, resp, null, diagnoses, "$facets updated");
		}
		//
		exports.registerModelEvents(_, config.searchEngine);
	}
}

exports.deleteEndpointIndex = function(_, endpoint, localeCode, diagnoses) {
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	var indexName = endpoint.getIndexName(_, localeCode);
	if (!elasticHelpers.indexExists(_, elasticBaseUrl, indexName, {
		$diagnoses: diagnoses
	})) return;
	//
	var options = {
		url: elasticBaseUrl + "/" + indexName,
		method: "DELETE"
	};
	var req = streams.httpRequest(options);
	var resp = req.end().response(_);
	//
	_processElasticResp(_, resp, null, diagnoses, locale.format(module, "indexDeleted", indexName));
	//
	endpoint.lastIndexDate(_, null);
	endpoint.save(_);
};

exports.deleteIndex = function(_, context, indexName, diagnoses) {
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	if (!elasticHelpers.indexExists(_, elasticBaseUrl, indexName, {
		$diagnoses: diagnoses
	})) return;
	var options = {
		url: elasticBaseUrl + "/" + indexName,
		method: "DELETE"
	};
	var req = streams.httpRequest(options);
	var resp = req.end().response(_);
	//
	_processElasticResp(_, resp, context, diagnoses, locale.format(module, "indexDeleted", indexName));
};

exports.registerModelEvents = function(_, config) {
	var admOrm = adminHelpers.AdminHelper.getCollaborationOrm(_);
	var eps = admOrm.fetchInstances(_, admOrm.getEntity(_, "endPoint"), {});
	eps.forEach_(_, function(_, e) {
		// TODO: see later for x3 endpoints, the connect sequence must be properly managed
		if (e.protocol(_) !== "syracuse") return;
		//
		var elasticBaseUrl = exports.serverConfig.baseUrl;
		var indexName = e.getIndexName(_, locale.current);
		if (!elasticHelpers.indexExists(_, elasticBaseUrl, indexName, {
			silent: true
		})) return;
		//
		var indexer = new ElasticIndex(e);
		var model = e.getModel(_, false);
		model && model.registerEvent(_, "$afterSave", "searchIndexUpdate", function(_, instance) {
			// index data for search. Call without callback
			indexer.updateInstance(null, instance, config);
			if (instance.getEntity(_).name === "menuItem") indexer.updateFunctionInstance(null, instance, config);
			// TODO: review this _reindexInst thing as is an undesired dependance from factory to search
			flows.eachKey(_, instance._reindexInst, function(_, k, inst) {
				indexer.updateInstance(null, inst, config);
			});
		});
	});
};