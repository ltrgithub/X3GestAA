"use strict";

var globals = require('streamline/lib/globals');
var sdataRegistry = require("syracuse-sdata/lib/sdataRegistry");
var flows = require('streamline/lib/util/flows');
var helpers = require('syracuse-core/lib/helpers')
var forEachKey = helpers.object.forEachKey;
var dataModel = require("syracuse-orm/lib/dataModel");
var http = require("http");
var streams = require("streamline/lib/streams/streams");
var resourceHelpers = require("syracuse-core/lib/resource/util");
var resourceProxy = require("syracuse-core/lib/resource/resourceProxy");
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var datetime = require("syracuse-core/lib/types/datetime");
var locale = require("syracuse-core/lib/locale");
var elasticHelpers = require("syracuse-search/lib/helpers");
var sys = require("util");

exports.tracer = null;
//exports.tracer = console.log;
exports.serverConfig = null;

// defines
var functionIndexName = "sage.x3.functions";

// TODO: map all locales codes to supported elasticsearch analyzers
var _analyzersMap = {
	"en-us": "english",
	"en-gb": "english",
	"fr-fr": "french",
	"de-de": "german",
	"it-it": "italian",
	"es-es": "spanish"
}

function _createInstanceIndexResource(_, instance, endpoint, options) {
	function _computeUrl(_, inst) {
//		console.log("compute url: " + sys.inspect(entity.$urlTemplate));
		return entity.$urlTemplate && entity.$urlTemplate.resolve({
			$baseUrl: endpoint.getBaseUrl(_),
			$key: instance.computeKey()
		});
	}
	function decodeTemplate(_, inst, templ) {
		if (!templ) return;
		var template = templ;
		if(typeof templ === "string")
			template = new resourceProxy.Template(templ);
		var res = template.expression;
		template.matches.forEach_(_, function(_, match) {
			var prop = match.substring(1, match.length - 1);
			if (inst._meta.$properties[prop]) res = res.replace(match, resourceHelpers.formatValue(inst._meta.$properties[prop], inst[prop](_)) || "");
			else if (inst._meta.$relations[prop]) {
				if (inst._meta.$relations[prop].isPlural) res = res.replace(match, inst[prop](_).toArray(_).map_(_, function(_, elem) {
					return decodeTemplate(_, elem, inst._meta.$relations[prop].targetEntity.$valueTemplate);
				}).join(","));
				else res = res.replace(match, decodeTemplate(_, inst[prop](_), inst._meta.$relations[prop].targetEntity.$valueTemplate));
			}
		});
		return res;
	}
	var opt = options || {};
	options && options.tracer && options.tracer("ElasticIndex.createResource: enter: " + instance.$uuid);
	var entity = instance.getEntity();
	var facets = entity.getSearchFacets(_);
	var inst = instance;
	var data = {};
	(entity.getSearchFields(_) || []).forEach_(_, function(_, field) {
		var val = null;
		var p;
		if (p = entity.$properties[field]) {
			val = resourceHelpers.formatValue(p, inst[field](_));
		} else 
			if (p = entity.$relations[field]) {
				var rel = entity.$relations[field];
				var relData = inst[field](_);
				var childOpt = options;
				if(rel.isChild) {
					childOpt = helpers.object.clone(options, true);
					childOpt.computeUrl = null;
					childOpt.computeUrlMethod = null;
					childOpt.isChild = true;
				}
				if (rel.isPlural)
					relData.toArray(_).forEach_(_, function(_, item) {
						(val = val || []).push(rel.isChild ? _createInstanceIndexResource(_, item, endpoint, childOpt) : decodeTemplate(_, item, rel.targetEntity.$valueTemplate));
					});
				else
					if(relData) 
						val = rel.isChild ? _createInstanceIndexResource(_, relData, endpoint, childOpt) : decodeTemplate(_, relData, rel.targetEntity.$valueTemplate);
	
			}
		options && options.tracer && options.tracer("ElasticIndex.createResource: compute field: " + field + "; value: " + val);
		//
		if(val) {
			data[field] = val;
			// facets is a structure like 
			// {
			//		classField: ["facet1Name", "facet2Name"]
			// }
			// one field can be part of several facets
			if(facets && facets[field])
				facets[field].forEach(function(f) {
					options && options.tracer && options.tracer("ElasticIndex.createResource: field facet: " + f);
					data["facet_" + f] = val;
				});
		}
	});
	// add some data to the resource
	(opt.rawData || []).forEach_(_, function(_, relName) {
		options && options.tracer && options.tracer("ElasticIndex.createResource: set rawData for relation: " + relName);
		var rel = entity.$relations[relName];
		if(!rel) return;
		data["$rawData"] = data["$rawData"] || {};
		var relData = inst[relName](_);
		if (rel.isPlural)
			relData.toArray(_).forEach_(_, function(_, item) {
				(data.$rawData[relName] = data.$rawData[relName] || []).push(item.$uuid);
			});
		else
			if(relData) {
				data.$rawData[relName] = relData.$uuid;
				options && options.tracer && options.tracer("ElasticIndex.createResource: rawData found for " + relName + ": " + relData.$uuid);
			}
	});
	options && options.tracer && options.tracer("ElasticIndex.createResource: compute templates");
	if(!(options && options.isChild)) {
		data.$description = decodeTemplate(_, inst, entity.$summaryTemplate || entity.$valueTemplate);
		if(entity.$iconTemplate) data.$icon = decodeTemplate(_, inst, entity.$iconTemplate);
		//
		var url = (opt.computeUrl || _computeUrl)(_, instance);
		if(url) data.$url = url;
		var method = opt.computeUrlMethod && opt.computeUrlMethod(_, instance);
		if(method) data.$method = method;
	}
	//
	return data;
}

function _fixFunctionsOptions(options) {
	var o = helpers.object.clone(options);
	o.indexName = functionIndexName;
	o.indexTypeName = "function";
	o.indexTypeTitle = "Function";
	o.rawData = ["application", "endpoint"];
	o.computeUrl = function(_, instance) {
		return instance.getItemUrl(_);
	}
	o.computeUrlMethod = function(_, instance) {
		return instance.getMethod(_);
	}
	return o;
}

function ElasticIndex(ep, localeCode) {
	this._endpoint = ep;
	this._locale = localeCode || locale.current;
	this._locale = this._locale.toLowerCase();
}

exports.IndexHelper = helpers.defineClass(ElasticIndex, null, {
	getIndexName: function(_, opt) {
		return opt && opt.indexName ? opt.indexName + (this._locale ? "." + this._locale : "") : this._endpoint.getIndexName(_, this._locale);
	},
	updateInstance: function(_, instance, options) {
		var opt = options || {};
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: enter: " + instance._meta.name + "." +instance.$uuid);
		// 
		var self = this;
		var _indexName = self.getIndexName(_, opt);
		var elasticBaseUrl = exports.serverConfig.baseUrl;
		var entity = instance.getEntity();
//		if(!entity.getSearchFacets(_)) return;
		
		var reqOptions = {
			url: [elasticBaseUrl, _indexName, opt.indexTypeName || entity.name, instance.computeKey()].join("/"),
			method: 'PUT'
		};
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: url: " + reqOptions.url);
		var req = streams.httpRequest(reqOptions);
		var data = _createInstanceIndexResource(_, instance, self._endpoint, options);
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: index data: " + sys.inspect(data));
		req.write(_, JSON.stringify(data));
		var resp = req.end().response(_);
		//
		var diag = JSON.parse(resp.readAll(_));
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: index response: " + sys.inspect(diag));
		if(options && options.diagnoses) {
			if(diag.ok)
				options.diagnoses.push({severity:"info", message: okMessage});
			else
				if(diag.error)
					options.diagnoses.push({severity:"error", message: diag.error});
		}
	},
	updateEntity: function(_, entity, differential, options) {
		var opt = options || {};
		var diag = opt.diagnoses || [];
		opt.tracer && opt.tracer("ElasticIndex.updateEntity: enter: " + entity.name);
		//
		var self = this;
		var _indexName = self.getIndexName(_, opt);
		var elasticBaseUrl = exports.serverConfig.baseUrl;
		var db = self._endpoint.getOrm(_);

		opt.tracer && opt.tracer("ElasticIndex.updateEntity: mapping update");
		// update mapping
		_indexMappingUpdate(_, _indexName, entity, entity.getSearchFacets(_), opt);
		// update data
		var where = (differential && self._endpoint.lastIndexDate(_) ? {
			jsonWhere: {
				$updDate: {
					$gt: self._endpoint.lastIndexDate(_).toJsDate()
				}
			}
		} : null);
		//
		opt.tracer && opt.tracer("ElasticIndex.updateEntity: fetching data");
		var cnt = 0;
		var cursor = db.createCursor(_, entity, where, "$search");
		var inst = cursor.next(_);
		if(inst) {
			do {
				var options = {
						url: elasticBaseUrl + "/_bulk",
						method: 'PUT'
					};
				var req = streams.httpRequest(options);
				do {
					//
					var action = {
						index: {
							_index: _indexName,
							_type: opt.indexTypeName || entity.name,
							_id: inst.computeKey()
						}
					}
					req.write(_, JSON.stringify(action) + "\n");
					var data = _createInstanceIndexResource(_, inst, self._endpoint, opt);
					opt.tracer && opt.tracer("ElasticIndex.updateEntity: index data: " + sys.inspect(data));
					req.write(_, JSON.stringify(data) + "\n");
					cnt++;
					inst = cursor.next(_);
				} while(inst && (cnt % 1000 !== 0))
				var resp = req.end().response(_);
				//
				_processElasticResp(_, resp, null, diag, entity.name+" records updated");
			} while(inst);
		}
		diag && diag.push({
			severity: "info",
			message: locale.format(module, "updateCount", cnt, entity.name)
		})
	},
	updateIndex: function(_, differential, options) {
		var opt = options || {};
		opt.diagnoses = opt.diagnoses || [];
		opt.tracer && opt.tracer("ElasticIndex.updateIndex enter");
		if(opt.locale)
			globals.context.sessionLocale = opt.locale;
		var self = this;
		var model = self._endpoint.getModel(_);
		var indexTime = datetime.now();
		var indexName = self.getIndexName(_, opt);
		//
		opt.tracer && opt.tracer("ElasticIndex.updateIndex creating index");
		adminHelpers.AdminHelper.logServerMessage(_, locale.format(module, "startIndexUpd", indexName), []);
		_indexCreate(_, self.getIndexName(_, opt), self._locale, model, opt);
		//
		var entities = [];
		if(opt.representations && opt.representations.length) {
			opt.representations.forEach_(_, function(_, r) {
				// sanitize
				var ent = model.getRepresentation(_, r, "$search");
				if(ent)
					entities.push(ent);
				else
					opt.diagnoses.push({ severity: "warning", message: locale.format(module, "reprNotFound", r) });
			});
		} else
			entities = model.getIndexedEntities(_);
		//
		try {
			entities.forEach_(_, function(_, entity) {
				self.updateEntity(_, entity, differential, opt);
				// index menuItems as functions
				if(entity.name === "menuItem") {
					self.updateFunctions(_, entity, differential, opt);
				}
			});
		} catch(e) {
			opt.diagnoses.push({severity: "error", message: e.message});
			opt.diagnoses.push({severity: "error", message: e.stack});
			adminHelpers.AdminHelper.logServerMessage(_, locale.format(module, "endIndexUpd", indexName), opt.diagnoses);
			throw e;
		}
		opt.diagnoses && adminHelpers.AdminHelper.logServerMessage(_, locale.format(module, "endIndexUpd", indexName), opt.diagnoses)
		//
		self._endpoint.lastIndexDate(_, indexTime);
		self._endpoint.save(_);
	},
	updateFunctions: function(_, menuItemEntity, differential, options) {
		var self = this;
		var entity = menuItemEntity;
		// ensure functions index
		_indexCreate(_, self.getIndexName(_, {
			indexName: functionIndexName
		}), self._locale, self._endpoint.getModel(_), options);
		//
		self.updateEntity(_, entity, differential, _fixFunctionsOptions(options));
	},
	updateFunctionInstance: function(_, instance, options) {
		var self = this;
		// ensure functions index
		_indexCreate(_, self.getIndexName(_, {
			indexName: functionIndexName
		}), self._locale, self._endpoint.getModel(_), options);
		//
		self.updateInstance(_, instance, _fixFunctionsOptions(options));
	}
});

function _processElasticResp(_, elasticResp, contextResp, diagnoses, okMessage) {
	if(diagnoses) {
		var diag = JSON.parse(elasticResp.readAll(_));
		if(diag.ok)
			diagnoses.push({severity:"info", message: okMessage});
		else
			if(diag.error)
				diagnoses.push({severity:"error", message: diag.error});
	} else {
		var buffer;
		while(buffer = elasticResp.read(_)) contextResp.write(_, buffer);
	}
}

function _addFacetFieldsMapping(searchFacets, entityName, mapping) {
	if(!searchFacets) return;
	forEachKey(searchFacets, function(classField, facets) {
		if(!facets) return;
		facets.forEach(function(f) {
			mapping[entityName].properties["facet_"+f] = {
					type: "string",
					analyzer: "keyword"
				};
		});
	});
}

function _indexMappingUpdate(_, indexName, entity, searchFacets, opt) {
	var opt = opt || {};
	var entityName = opt.indexTypeName || entity.name;
	var diagnoses = opt && opt.diagnoses;
	var mapping = {};
	mapping[entityName] = {
		properties: {},
		_meta: {
			$classTitle: opt.indexTypeTitle || (entity.$titleTemplate && entity.$titleTemplate.expression) 
		}
	};
	var pm = mapping[entityName].properties;
	pm.$description = {
		type: "string",
		index: "no",
		include_in_all: false
	};
	pm.$title = {
		type: "string",
		index: "no",
		include_in_all: false
	};
	pm.$icon = {
		type: "string",
		index: "no",
		include_in_all: false
	};
	pm.$url = {
		type: "string",
		index: "no",
		include_in_all: false
	};
	// create a mapping for all localized properties
	// get all searchable locales
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	var localeCodes = db.fetchInstances(_, db.getEntity(_,"localePreference"), {
		jsonWhere: {
			enabled: true,
			searchable: true
		}
	}).map_(_, function(_, l) {
		return l.code(_);
	});
	//
	_addFacetFieldsMapping(searchFacets, entityName, mapping);
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	var options = {
		url: elasticBaseUrl + "/" + indexName + "/" + entityName + "/_mapping",
		method: 'PUT'
	};
	var req = streams.httpRequest(options);
	req.write(_, JSON.stringify(mapping));
	var resp = req.end().response(_);
	exports.tracer && exports.tracer("elasticIndex.index exists status: " + resp.statusCode + "; entity: " + entityName);
	//
	_processElasticResp(_, resp, null, diagnoses, locale.format(module, "mappingUpdated", entityName));
}

// indexName already has localeCode
function _indexCreate(_, indexName, localeCode, model, options) {
	var opt = options || {};
	var diagnoses = opt.diagnoses;
	// check if index exists
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	if(!elasticHelpers.indexExists(_, elasticBaseUrl, indexName, opt)) {
		// create index
		var reqUrl = elasticBaseUrl + "/" + indexName;
		var par = {
				url: reqUrl,
				method: 'PUT'
			};
		var req = streams.httpRequest(par);
		var a;
		if(localeCode && (a = _analyzersMap[localeCode])) {
			req.write(_, JSON.stringify({
				"settings": {
					"index": {
						"analysis": {
							"analyzer": {
								"default": {
									"type": a
								}
							}
						}
					}
				}
			}));
		}
		var resp = req.end().response(_);
		opt.tracer && opt.tracer("elasticIndex.index put settings status: "+resp.statusCode);
		//
		_processElasticResp(_, resp, null, diagnoses, locale.format(module, "indexCreated", indexName));
		// add search facets: add to index a new type $facet, every entry should have code and description; the id is the code 
		// create a mapping
		var mapping = {
			$facet: {
				properties: {
					code: {
						type: "string",
						index: "no",
						include_in_all: false
					},
					description: {
						type: "string",
						index: "no",
						include_in_all: false
					}
				}
			}
		};
		var options = {
			url: elasticBaseUrl + "/" + indexName + "/$facet/_mapping",
			method: 'PUT'
		};
		var req = streams.httpRequest(options);
		req.write(_, JSON.stringify(mapping));
		var resp = req.end().response(_);
		//
		_processElasticResp(_, resp, null, diagnoses, locale.format(module, "mappingUpdated", "$facet"));
		// index facets
		// indexing facets one by one is easyier to make them non searchable than if we would add a map. 
		var facets = model.getSearchFacets(_);
		if(facets && facets.length) {
			opt.tracer && opt.tracer("ElasticIndex.updateFacets");
			//
			var _indexName = indexName;
			//
			var options = {
					url: elasticBaseUrl + "/_bulk",
					method: 'PUT'
				};
			var req = streams.httpRequest(options);
			//
			facets.forEach_(_, function(_, f) {
				var action = {
					index: {
						_index: _indexName,
						_type: "$facet",
						_id: f.code
					}
				}
				req.write(_, JSON.stringify(action) + "\n");
				opt.tracer && opt.tracer("ElasticIndex.updateFacets: index data: " + sys.inspect(f));
				req.write(_, JSON.stringify(f) + "\n");
			});
			var resp = req.end().response(_);
			//
			_processElasticResp(_, resp, null, diagnoses, "$facets updated");
		}
	}
}

exports.deleteEndpointIndex = function(_, endpoint, localeCode, diagnoses) {
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	var options = {
		url: elasticBaseUrl + "/" + endpoint.getIndexName(_) + (localeCode ? "." + localeCode.toLowerCase() : ""),
		method: "DELETE"
	};
	var req = streams.httpRequest(options);
	var resp = req.end().response(_);
	//
	_processElasticResp(_, resp, null, diagnoses, locale.format(module, "indexDeleted", endpoint.getIndexName(_)));
}

exports.deleteIndex = function(_, context, indexName, diagnoses) {
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	var options = {
		url: elasticBaseUrl + "/" + indexName,
		method: "DELETE"
	};
	var req = streams.httpRequest(options);
	var resp = req.end().response(_);
	//
	_processElasticResp(_, resp, context, diagnoses, locale.format(module, "indexDeleted", indexName));
}

exports.registerModelEvents = function(_, config) {
	var admOrm = adminHelpers.AdminHelper.getCollaborationOrm(_);
	var eps = admOrm.fetchInstances(_, admOrm.getEntity(_, "endPoint"), {});
	eps.forEach_(_, function(_, e) {
		// TODO: see later for x3 endpoints, the connect sequence must be properly managed
		if(e.protocol(_) != "syracuse") return;
		//
		var model = e.getModel(_, false);
		model && model.registerEvent("$afterSave", function(_, instance) {
			// index data for search. Call without callback
			var indexer = new ElasticIndex(e);
//			(config = config || {}).tracer = console.log;
			indexer.updateInstance(null, instance, config);
			if(instance.getEntity().name === "menuItem")
				indexer.updateFunctionInstance(null, instance, config);
			// TODO: review this _reindexInst thing as is an undesired dependance from factory to search
			flows.eachKey(_, instance._reindexInst, function(_, k, inst) {
				indexer.updateInstance(null, inst, config);
			});
		});
	});
}
