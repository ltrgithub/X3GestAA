"use strict";

var config = require('config'); // must be first syracuse require
var globals = require('streamline-runtime').globals;
var flows = require('streamline-runtime').flows;
var helpers = require('@sage/syracuse-core').helpers;
var forEachKey = helpers.object.forEachKey;
var ez = require("ez-streams");
var resourceHelpers = require('@sage/syracuse-core').resource.util;
var resourceProxy = require('@sage/syracuse-core').resource.proxy;
var adminHelpers = require('@sage/syracuse-lib/src/collaboration/helpers').AdminHelper;
var datetime = require('@sage/syracuse-core').types.datetime;
var locale = require('streamline-locale');
var elasticHelpers = require('./helpers');
var sys = require("util");
var elasticVersion = require("./elasticVersion");
var searchEngine = require("./elasticSearch");
var httpClient = require("@sage/syracuse-lib/src/http-client/httpClient");

var elasticVersionFilter;
var tracer = require('@sage/syracuse-core').getTracer("search");

//exports.tracer = null;
//exports.tracer.trace = console.log;

// defines
var functionIndexName = "sage.x3.functions";

var full_stemmer = config.searchEngine && config.searchEngine.stemmer === "full";
var offStemmer = config.searchEngine && config.searchEngine.offStemmer;


// TODO: map all locales codes to supported elasticsearch analyzers
var _analyzersMap = {
	"de-de": {
		"stemmer": full_stemmer ? "german" : "minimal_german",
		"stop": "_german_"
	},
	"en-us": {
		"stemmer": full_stemmer ? "english" : "minimal_english",
		"stop": "_english_"
	},
	"es-es": {
		"stemmer": full_stemmer ? "spanish" : "light_spanish",
		"stop": "_spanish_"
	},
	"fr-fr": {
		"stemmer": full_stemmer ? "french" : "minimal_french",
		"stop": "_french_"
	},
	"it-it": {
		"stemmer": full_stemmer ? "italian" : "light_italian",
		"stop": "_italian_"
	},
	"pl-pl": {
		//		"stemmer": full_stemmer ? "polish" : "light_polish"
	},
	"pt-br": {
		"stemmer": full_stemmer ? "brazilian" : "light_brazilian",
		"stop": "_brazilian_"
	},
	"pt-pt": {
		"stemmer": full_stemmer ? "portuguese" : "minimal_portuguese",
		"stop": "_portuguese_"
	},
	"ru-ru": {
		"stemmer": full_stemmer ? "russian" : "light_russian",
		"stop": "_russian_"
	},
	"zh-cn": {
		"analyzer": "chinese"
	}
};

_analyzersMap["en-gb"] = _analyzersMap["en-us"];
_analyzersMap["zh-hk"] = _analyzersMap["zh-cn"];
_analyzersMap["zh-mo"] = _analyzersMap["zh-cn"];
_analyzersMap["zh-sg"] = _analyzersMap["zh-cn"];
_analyzersMap["zh-tw"] = _analyzersMap["zh-cn"];

// supported analyzers:
// arabic, armenian, basque, brazilian, bulgarian, catalan, chinese, cjk, czech, danish, dutch, english, finnish, french, galician, german, greek, hindi, hungarian, indonesian, italian, norwegian, persian, portuguese, romanian, russian, spanish, swedish, turkish, thai

function _createInstanceIndexResource(_, instance, endpoint, options, prototype) {
	function _getFacetVal(aVal) {
		return (typeof aVal === "object") ? aVal.$value : aVal;
	}

	function _computeUrl(_, inst) {
		var url = null;
		var device = "desktop"; // by default desktop
		if (prototype && prototype.$links) {
			// get the right default url for the device

			Object.keys(prototype.$links).map(function(key) {
				if (key.indexOf("$search") === 0 && prototype.$links[key].$devices === device && prototype.$links[key].$default && !url) {
					entity.$urlTemplate.expression = prototype.$links[key].$url;
					url = entity.$urlTemplate;

				}
			});
		}
		if (!url) {
			url = entity.$urlTemplate;
		}
		tracer.debug && tracer.debug("compute url: " + sys.inspect(entity.$urlTemplate));
		return url && url.resolve({
			$baseUrl: endpoint.getBaseUrl(_),
			$key: instance.computeKey()
		});
	}

	function _computeSite(_, inst) {
		if (prototype && inst && inst._data && prototype.$site && inst._data[prototype.$site]) {
			return inst._data[prototype.$site];
		}
		return null;
	}


	function decodeTemplate(_, inst, templ) {
		if (!templ) return;
		var template = templ;
		if (typeof templ === "string") template = new resourceProxy.Template(templ);
		var res = template.expression;
		if (!template.matches) return res;
		template.matches.forEach_(_, function(_, match) {
			var prop = match.substring(1, match.length - 1);
			if (inst._meta.$properties[prop]) res = res.replace(match, resourceHelpers.formatValue(inst._meta.$properties[prop], inst[prop](_)) || "");
			else if (inst._meta.$relations[prop]) {
				if (inst._meta.$relations[prop].isPlural) res = res.replace(match, inst[prop](_).toArray(_).map_(_, function(_, elem) {
					return decodeTemplate(_, elem, inst._meta.$relations[prop].targetEntity.$valueTemplate);
				}).join(","));
				else res = res.replace(match, decodeTemplate(_, inst[prop](_), inst._meta.$relations[prop].targetEntity.$valueTemplate));
			}
		});
		return res;
	}
	var opt = options || {};
	tracer.debug && tracer.debug("ElasticIndex.createResource: enter: " + instance.$uuid);
	var entity = instance.getEntity(_);
	// get prototype
	var facets = entity.getSearchFacets(_);
	var inst = instance;
	var data = {};
	var searchFields = entity.getSearchFields(_);
	// manage right
	try {
		elasticVersion.checkVersion(_, searchEngine.getBaseUrl());
		elasticVersionFilter = elasticVersionFilter || elasticVersion.getElasticVersion(_, searchEngine.getBaseUrl());
	} catch (e) {
		options.diagnoses && options.diagnoses.push({
			$severity: "error",
			$message: e.message
		});
	}
	(entity.getSearchFields(_) || []).forEach_(_, function(_, field) {
		var val = null;
		var p;

		var fieldElastic = field;
		if (field !== "$access" && (p = entity.$properties[field])) {
			val = resourceHelpers.formatValue(p, inst[field](_));
		} else if (p = entity.$relations[field]) {
			if (elasticVersionFilter && elasticVersionFilter[0] >= 2)
				fieldElastic = field + "_ref";
			var rel = entity.$relations[field];
			var relData = inst[field](_);
			var childOpt = opt;
			if (rel.getIsChild()) {
				childOpt = _unfixFunctionsOptions(opt);
				childOpt.isChild = true;
			}
			if (rel.isPlural) {
				relData.toArray(_).forEach_(_, function(_, item) {
					(val = val || []).push(rel.getIsChild() ? _createInstanceIndexResource(_, item, endpoint, childOpt, prototype) : {
						$key: item.computeKey(),
						$value: decodeTemplate(_, item, rel.targetEntity.$valueTemplate)
					});
				});
			} else {
				if (relData) {
					val = rel.getIsChild() ? _createInstanceIndexResource(_, relData, endpoint, childOpt, prototype) : {
						$key: relData.computeKey(),
						$value: decodeTemplate(_, relData, rel.targetEntity.$valueTemplate)
					};
				} else val = null;
			}

		}
		tracer.debug && tracer.debug("ElasticIndex.createResource: compute field: " + field + "; value: " + val);
		//
		if (val) {
			data[fieldElastic] = val;
			// facets is a structure like
			// {
			//		classField: ["facet1Name", "facet2Name"]
			// }
			// one field can be part of several facets
			if (facets && facets[fieldElastic]) facets[fieldElastic].forEach_(_, function(_, f) {
				tracer.debug && tracer.debug("ElasticIndex.createResource: field facet: " + f);
				data["facet_" + f] = Array.isArray(val) ? val.map(_getFacetVal) : _getFacetVal(val);
			});
		}
	});
	// add some data to the resource
	(opt.rawData || []).forEach_(_, function(_, relName) {
		tracer.debug && tracer.debug("ElasticIndex.createResource: set rawData for relation: " + relName);
		var rel = entity.$relations[relName];
		if (!rel) return;
		data["$rawData"] = data["$rawData"] || {};
		var relData = inst[relName](_);
		if (rel.isPlural) relData.toArray(_).forEach_(_, function(_, item) {
			(data.$rawData[relName] = data.$rawData[relName] || []).push(item.$uuid);
		});
		else if (relData) {
			data.$rawData[relName] = relData.$uuid;
			tracer.debug && tracer.debug("ElasticIndex.createResource: rawData found for " + relName + ": " + relData.$uuid);
		}
	});
	if (data && Object.keys(data).length !== 0) { // only if data is not empty to don't store un
		if (!options.isFunctionIndex) {
			data["$access"] = inst.$access ? inst.$access.toLowerCase() : "_all"; // regexp only work on lowercase
		} else {
			data["$access"] = data.fusionFunction ? data.fusionFunction.toLowerCase() : "_all"; // regexp only work on lowercase
		}

		if (!options.isFunctionIndex) {
			var siteVal = _computeSite(_, inst);
			data["$site"] = siteVal ? siteVal.toLowerCase() : "_all"; // regexp only work on lowercase

		}
	}
	tracer.debug && tracer.debug("ElasticIndex.createResource: compute templates");
	if (!(options && options.isChild)) {
		data.$description = decodeTemplate(_, inst, entity.$summaryTemplate || entity.$valueTemplate);
		if (entity.$iconTemplate) data.$icon = decodeTemplate(_, inst, entity.$iconTemplate);
		//
		var url = (opt.computeUrl || _computeUrl)(_, instance);
		if (url) data.$url = url; // default url

		var method = opt.computeUrlMethod && opt.computeUrlMethod(_, instance);
		if (method) data.$method = method;
	}
	//
	return data;
}

function _unfixFunctionsOptions(options) {
	options = options || {};
	var o = helpers.object.clone(options);
	o.rawData = null;
	o.computeUrl = null;
	o.computeUrlMethod = null;
	return o;
}

function _fixFunctionsOptions(e, indexName, options) {
	options = options || {};
	var o = helpers.object.clone(options);
	o.indexName = indexName;
	o.endpoint = e;
	o.isFunctionIndex = true;
	o.indexTypeName = "function";
	o.indexTypeTitle = "Function";
	o.rawData = ["application", "endpoint"];
	o.computeUrl = function(_, instance) {
		return instance.getItemUrl(_);
	};
	o.computeUrlMethod = function(_, instance) {
		return instance.getMethod(_);
	};
	return o;
}

function ElasticIndex(ep, localeCode) {
	this._endpoint = ep;
	this._locale = localeCode || locale.current;
	this._locale = this._locale.toLowerCase();
}

exports.IndexHelper = helpers.defineClass(ElasticIndex, null, {
	getIndexName: function(_, opt) {
		var name = opt && opt.indexName ? opt.indexName + (this._locale ? "." + this._locale : "") : this._endpoint.getIndexName(_, this._locale);
		return elasticHelpers.getFullIndexName(name);
	},
	getLastIndexDate: function(_, entityName) {
		var self = this;
		var elasticBaseUrl = searchEngine.getBaseUrl();
		//console.log("getlastindexdate ",elasticBaseUrl + "/" + self.getIndexName(_) + "_entities" + "/$entities/" + entityName);
		var par = {
			url: elasticBaseUrl + "/" + self.getIndexName(_) + "_entities" + "/$entities/" + entityName,
			method: 'GET'
		};

		//var resp = streams.httpRequest(par).end().response(_);
		var resp = httpClient.httpRequest(_, par).end().response(_);
		var content = resp.readAll(_);
		if (resp.statusCode === 200) {
			content = JSON.parse(content);
			return content._source && content._source.lastIndexDate;
		} else return null;
	},

	updateEntities: function(_, entityName, data, options) {
		var self = this;
		var elasticBaseUrl = searchEngine.getBaseUrl();
		var buf = new Buffer(JSON.stringify(data), "utf8");
		var idx = 0;
		var packetSize = 32768;

		var par = {
			url: elasticBaseUrl + "/" + self.getIndexName(_, options) + "_entities" + "/$entities/" + entityName,
			method: 'PUT',
			headers: {
				'content-type': 'application/json',
				'content-length': buf.length,
			}
		};

		var req = httpClient.httpRequest(_, par);
		while (idx < buf.length) {
			var newIdx = (buf.length - idx > packetSize) ? (idx + packetSize) : buf.length;
			req.write(_, buf.slice(idx, newIdx));
			idx = newIdx;
		}
		var resp = req.end().response(_);
		//var resp = streams.httpRequest(par).end(JSON.stringify(data)).response(_);
		var diag = JSON.parse(resp.readAll(_));
		tracer.debug && tracer.debug("ElasticIndex.updateInstance: index response: " + sys.inspect(diag));
		if (options && options.diagnoses) {
			if (diag.ok || diag.acknowledged || diag.created) options.diagnoses.push({
				$severity: "info",
				$message: locale.format(module, "instanceUpdated", entityName)
			});
			else if (diag.error) {
				//if (diag.error.indexOf("MapperParsingException") >= 0) {
				options.diagnoses.push({
					$severity: "error",
					$message: diag.error,
					$stackTrace: diag.$stackTrace ? diag.$stackTrace : ""

				});
			}
		}

	},
	updateInstance: function(_, instance, options) {
		var opt = options || {};
		tracer.debug && tracer.debug("ElasticIndex.updateInstance: enter: " + instance._meta.name + "." + instance.$uuid);
		//
		var self = this;
		var _indexName = self.getIndexName(_, opt);
		var elasticBaseUrl = searchEngine.getBaseUrl();
		if (!elasticHelpers.indexExists(_, elasticBaseUrl, _indexName, {
				silent: true
			})) return;
		//
		var entity = instance.getEntity(_);
		var f = entity.getSearchFields(_);
		if (!f || !f.length) return;

		var reqOptions = {
			url: [elasticBaseUrl, _indexName, opt.indexTypeName || entity.name, instance.computeKey()].join("/"),
			method: 'PUT'
		};
		tracer.debug && tracer.debug("ElasticIndex.updateInstance: url: " + reqOptions.url);
		var data = _createInstanceIndexResource(_, instance, self._endpoint, options, self.getPrototype(_, entity, opt));
		tracer.debug && tracer.debug("ElasticIndex.updateInstance: index data: " + sys.inspect(data));
		var req = httpClient.httpRequest(_, reqOptions);
		req.write(_, JSON.stringify(data));
		var resp = req.end().response(_);
		//
		var diag = JSON.parse(resp.readAll(_));
		tracer.debug && tracer.debug("ElasticIndex.updateInstance: index response: " + sys.inspect(diag));
		if (options && options.diagnoses) {
			if (diag.ok || diag.acknowledged || diag.created) options.diagnoses.push({
				$severity: "info",
				$message: locale.format(module, "instanceUpdated", instance.getValue(_))
			});
			else if (diag.error) {

				options.diagnoses.push({
					$severity: "error",
					$message: diag.error,
					$stackTrace: diag.$stackTrace ? diag.$stackTrace : ""

				});
			}
		}
	},
	updateEntity: function(_, entity, differential, options) {

		var opt = options || {};
		var diag = opt.diagnoses || [];
		//console.log("ElasticIndex.updateEntity: enter: " + entity.name);
		//
		var self = this;
		var _indexName = self.getIndexName(_, opt);
		var elasticBaseUrl = searchEngine.getBaseUrl();
		var db = options.isFunctionIndex ? options.fendpoint.getOrm(_) : self._endpoint.getOrm(_);

		//console.log("ElasticIndex.updateEntity: mapping update");
		// update mapping
		_indexMappingUpdate(_, _indexName, entity, entity.getSearchFacets(_), opt);

		// update data
		var where = null,
			lastIndex = null;
		if (differential) {
			lastIndex = self.getLastIndexDate(_, entity.name);
			if (lastIndex) {
				where = {
					sdataWhere: "(" + db.getUpdDatePropName() + " gt \"" + (new Date(lastIndex)).toISOString() + "\")"
				};
				tracer.debug && tracer.debug("ElasticIndex.updateEntity: differential where: " + where.sdataWhere);
			}
		}
		//
		tracer.debug && tracer.debug("ElasticIndex.updateEntity: fetching data");
		tracer.debug && tracer.debug("ElasticIndex.updateEntity: endpoint " + require('util').inspect(options));

		lastIndex = new Date();
		var cnt = 0;
		//console.log("indexname ");

		var cursor = db.createCursor(_, entity, where, "$search");
		var prototype = self.getPrototype(_, entity, opt);
		//console.log("indexname 2");
		var e = options.endpoint;
		var inst = cursor.next(_);
		var aborted = false;

		if (inst) {
			do {
				var _options = {
					url: elasticBaseUrl + "/_bulk",
					method: 'PUT'
				};

				//var req = streams.httpRequest(_options);

				var req = httpClient.httpRequest(_, _options);

				do {
					aborted = opt.tracker && opt.tracker.abortRequested;
					//
					var action = {
						index: {
							_index: _indexName,
							_type: opt.indexTypeName || entity.name,
							_id: inst.computeKey()
						}
					};
					tracer.debug && tracer.debug("ElasticIndex.updateEntity: action : " + sys.inspect(action));
					req.write(_, JSON.stringify(action) + "\n");
					tracer.debug && tracer.debug("write ok ");

					var data = _createInstanceIndexResource(_, inst, self._endpoint, opt, prototype);
					tracer.debug && tracer.debug("ElasticIndex.updateEntity: index data: " + sys.inspect(data));
					req.write(_, JSON.stringify(data) + "\n");
					cnt++;

					inst = cursor.next(_);
				} while (inst && (cnt % 1000 !== 0) && !aborted);
				if (cnt > 0) {
					var resp = req.end().response(_);
					//
					_processElasticResp(_, resp, null, diag, entity.name + " records updated");
				}
			} while (inst && !aborted);
		}
		//self.setLastIndexDate(_, entity.name, lastIndex);
		// update prototype info: TODO ? not now, maybe 7.1 ?
		tracer.debug && tracer.debug("entity " + entity.name);
		self.updateEntities(_, entity.name, {
			lastIndexDate: lastIndex,
			$prototype: prototype
		}, options);
		diag && diag.push({
			$severity: "info",
			$message: locale.format(module, "updateCount", cnt, entity.name)
		});
		return !aborted;
	},

	updateIndex: function(_, differential, options) {
		var result = options.result || {
			continu: true,
			curStep: 1,
			nbStep: 1
		};

		function _track(phase, detail, progress, indexName) {
			if (!opt.tracker) return;
			options.result.progress = options.result.progress || {}; // progress by index
			options.result.progress[result.curStep] = Math.ceil(progress / result.nbStep);

			opt.tracker.phase = phase;
			opt.tracker.phaseDetail = detail;
			// calcul globale progress
			opt.tracker.progress = 0;
			Object.keys(options.result.progress).map(function(k) {
				opt.tracker.progress = opt.tracker.progress + options.result.progress[k];
			});

		}
		var opt = options || {},
			currentLocal = null;
		opt.diagnoses = opt.diagnoses || [];
		tracer.debug && tracer.debug("ElasticIndex.updateIndex enter: locale=" + opt.locale);
		if (opt.locale) {
			currentLocal = locale.current;
			globals.context.sessionLocale = opt.locale;
		}
		var self = this;
		var model = self._endpoint.getModel(_);
		var indexTime = datetime.now();
		var indexName = self.getIndexName(_, opt);
		var pSlices = opt.progressSlices || 1;
		var pCrtSlice = opt.progressCurrentSlice || 1;
		//
		tracer.debug && tracer.debug("ElasticIndex.updateIndex creating index");
		adminHelpers.logServerMessage(_, locale.format(module, "startIndexUpd", indexName), []);
		_track(locale.format(module, "startIndexUpd", indexName), "", 0);
		_indexCreate(_, self.getIndexName(_, opt), self._locale, model, opt, false);
		//
		var entities = [];

		function _updateAllEntity(_) {
			var idx = 0;

			entities.some_(_, function(_, entity) {
				_track(locale.format(module, "indexingEntity", indexName), entity.name, Math.ceil(idx++ * pCrtSlice * 100 / (entities.length * pSlices)));
				try {
					result.continu = self.updateEntity(_, entity, differential, opt);
					// index menuItems as functions
					if (entity.name === "menuItem") {
						//self.updateFunctions2(_, entity, differential, opt);
					}
				} catch (e) {
					if (e.message === "MergeMappingException") { // throw error to stop the process if mergeMapping we have to restart
						// delete index and restart
						_deleteDataEntity(_, null, indexName, entity, opt.diagnoses); // delete index without add diagnoses and respond
						_deleteMappingEntity(_, null, indexName, entity, opt.diagnoses); // delete index without add diagnoses and respond
						result.continu = self.updateEntity(_, entity, false, opt);
						return;
					} else {
						opt.diagnoses.push({
							$severity: "error",
							$message: e.message,
							$stackTrace: e.$stackTrace || e.safeStack
						});
					}
				}
				return (opt.tracker && opt.tracker.abortRequested);
			});
		}
		model.resetCache && model.resetCache();
		if (opt.entities && opt.entities.length) {
			opt.entities.forEach_(_, function(_, r) {
				// sanitize
				try {

					var e = model.getEntity(_, r, "$search");
					if (e) entities.push(e);
					else opt.diagnoses.push({
						$severity: "warning",
						$message: locale.format(module, "entNotFound", r)
					});
				} catch (e) {
					opt.diagnoses.push({
						$severity: "error",
						$message: locale.format(module, "entError", r, e.message),
						$stackTrace: e.$stackTrace || e.safeStack
					});
				}
			});
		} else {
			entities = model.getIndexedEntities(_, opt);
		}
		// use some instead of forEach to be able to abort loop
		var idx = 0;
		_updateAllEntity(_);

		var msg = opt.tracker && opt.tracker.abortRequested ? locale.format(module, "indexUpdAborted") : locale.format(module, "endIndexUpd", indexName);
		opt.diagnoses.push({
			$severity: "success",
			$message: msg
		});
		if (result.curStep === result.nbStep)
			_track("", msg, Math.ceil(pCrtSlice * 100 / pSlices));
		opt.diagnoses && adminHelpers.logServerMessage(_, msg, opt.diagnoses);
		if (opt.locale) {
			globals.context.sessionLocale = currentLocal;
		}
		return result;
	},

	updateFunctionIndex: function(_, differential, options) {
		var self = this;
		var result = options.result || {
			continu: true
		};
		var currentLocal = locale.current;
		if (options.locale) {
			globals.context.sessionLocale = options.locale;
		}
		var endpointSyracuse = adminHelpers.getEndpoints(_, {
			dataset: "syracuse"
		})[0];
		var model = endpointSyracuse.getModel(_);
		var entity = model.getEntity(_, "menuItem", "$search");

		// ensure functions index
		//console.log("this "+require('util').inspect(self));
		var e = self._endpoint;
		var indexName = functionIndexName;

		_indexCreate(_, self.getIndexName(_, {
			indexName: indexName
		}), self._locale, endpointSyracuse.getModel(_), options, true);
		//
		var foptions = _fixFunctionsOptions(e, indexName, options);
		foptions.fendpoint = endpointSyracuse;
		try {
			result.continu = self.updateEntity(_, entity, differential, foptions);
		} catch (e) {
			// delete index and restart
			_deleteDataEntity(_, null, indexName, entity, options.diagnoses); // delete index without add diagnoses and respond
			_deleteMappingEntity(_, null, indexName, entity, options.diagnoses); // delete index without add diagnoses and respond
			result.continu = self.updateEntity(_, entity, false, options);

		}
		if (options.locale) {
			globals.context.sessionLocale = currentLocal;

		}
		return result;
	},

	/* No longer used ??*/
	updateFunctionInstance: function(_, instance, options) {
		var self = this;
		// ensure functions index for all application/endpoint
		var endpoints = adminHelpers.getEndpoints(_, {});
		endpoints.forEach_(_, function(_, e) {

			var indexName = functionIndexName;
			_indexCreate(_, self.getIndexName(_, {
				indexName: indexName
			}), self._locale, self._endpoint.getModel(_), options);
			//console.log("entity "+require('util').inspect(entity,null,2));

			//f
			self.updateInstance(_, instance, _fixFunctionsOptions(e, indexName, options));
		});
	},

	getPrototype: function(_, entity, options) {

		var opt = options || {};
		tracer.debug && tracer.debug("ElasticIndex.updatePrototype: enter: " + entity.name);
		//
		var self = this;

		tracer.debug && tracer.debug("ElasticIndex.updatePrototype: url: " + options.url);
		var facet = options.isFunctionIndex || this._endpoint.protocol(_) === "syracuse" ? "$summary" : "$search";
		var data = entity.getPrototype(_, entity.name, facet); // TODO
		//HACK due to elastic search issue -  remove $pattern property if exists
		for (var prop in data.$properties) {
			if (data.$properties[prop].$pattern) {
				delete data.$properties[prop].$pattern;
			}
		}
		var propSite = data["$facility"];
		var prototype = {
			$summary: facet === "$summary",
			$properties: data.$properties,
			$site: propSite && propSite.replace("{", "").replace("}", ""),
			$localization: data.$localization,
			$links: data.$links
		};
		//
		return prototype;

	}
});




function _processElasticResp(_, elasticResp, contextResp, diagnoses, okMessage) {
	if (diagnoses) {
		var r = elasticResp.readAll(_);
		var diag;
		try {
			diag = JSON.parse(r);
		} catch (e) {
			console.log(r);
			throw e;
		}
		if (diag.ok || diag.acknowledged || diag.created) diagnoses.push({
			$severity: "info",
			$message: okMessage
		});
		else if (diag.error) {
			// case of mergeMapping - we have to restart from scratch the index
			if (diag.error.indexOf("MergeMappingException") >= 0 || diag.error.indexOf("MapperParsingException") >= 0) {
				throw new Error("MergeMappingException");
			}
			diagnoses.push({
				$severity: "error",
				$message: diag.error,
				$stackTrace: diag.$stackTrace ? diag.$stackTrace : ""

			});

		}
	} else {
		var buffer;
		while (buffer = elasticResp.read(_)) contextResp.write(_, buffer);
	}
}

function _addFacetFieldsMapping(searchFacets, entityName, mapping) {
	if (!searchFacets) return;
	forEachKey(searchFacets, function(classField, facets) {
		if (!facets) return;
		facets.forEach(function(f) {
			mapping[entityName].properties["facet_" + f] = {
				type: "string",
				analyzer: "keyword"
			};
		});
	});
}

function _indexMappingUpdate(_, indexName, entity, searchFacets, opt) {

	opt = opt || {};
	var entityName = opt.indexTypeName || entity.name;
	var diagnoses = opt && opt.diagnoses;
	var mapping = {};
	// tracer.debug && tracer.debug("_indexMappingUpdate: entityName=" + entityName + ", entity=" + sys.inspect(entity));
	var entityTitle = entity.$classTitle || (entity.$titleTemplate && entity.$titleTemplate.expression),
		classTitle = opt.indexTypeTitle || (entity.contract && (entity.contract.localizedString(entityName, "$classTitle") || entity.contract.localizedString(entityName, "$titleTemplate"))) || entityTitle;
	tracer.debug && tracer.debug("ElasticIndex _indexMappingUpdate: contract: " + (entity.contract && entity.contract.application) + ", entityName=" + entityName + ", title=" + entityTitle + ", classTitle=" + classTitle);
	if (opt.tracer) {
		entity && Object.keys(entity).forEach_(_, function(_, key) {
			if ((key[0] === '$')) {
				tracer.debug && tracer.debug("   " + key + "=" + entity[key]);
			}
		});
	}

	// tracer.debug && tracer.debug("...title=" + entityTitle + ", classTitle=" + classTitle);
	mapping[entityName] = {
		properties: {},
		_meta: {
			$classTitle: classTitle
		}
	};
	var pm = mapping[entityName].properties;
	pm.$description = {
		type: "string",
		index: "no",
		include_in_all: false
	};
	pm.$access = {
		type: "string"
	};
	pm.$title = {
		type: "string",
		index: "no",
		include_in_all: false
	};
	pm.$icon = {
		type: "string",
		index: "no",
		include_in_all: false
	};
	pm.$url = {
		type: "string",
		index: "no",
		include_in_all: false
	};
	try {
		elasticVersion.checkVersion(_, searchEngine.getBaseUrl());
		elasticVersionFilter = elasticVersionFilter || elasticVersion.getElasticVersion(_, searchEngine.getBaseUrl());
	} catch (e) {
		diagnoses && diagnoses.push({
			$severity: "error",
			$message: e.message
		});
	}
	// add relations mapping
	var fields = entity.getSearchFields(_) || [];
	fields.forEach(function(ff) {
		if (entity.$relations[ff]) {
			if (elasticVersionFilter && elasticVersionFilter[0] >= 2)
				ff = ff + "_ref";
			pm[ff] = {
				properties: {
					$key: {
						type: "string",
						index: "not_analyzed",
						include_in_all: false
					}
				}
			};
		}
	});
	// create a mapping for all localized properties
	var db = adminHelpers.getCollaborationOrm(_);
	db.fetchInstances(_, db.getEntity(_, "localePreference"), {
		jsonWhere: {
			enabled: true
		}
	}).map_(_, function(_, l) {
		return l.code(_);
	});
	//
	_addFacetFieldsMapping(searchFacets, entityName, mapping);
	var elasticBaseUrl = searchEngine.getBaseUrl();
	var options = {
		url: elasticBaseUrl + "/" + indexName + "/" + entityName + "/_mapping",
		method: 'PUT'
	};
	//var req = streams.httpRequest(options);

	tracer.debug && tracer.debug("elasticIndex.index write mapping; entity: " + entityName + "; " + sys.inspect(mapping, null, 4));
	var req = httpClient.httpRequest(_, options);

	req.write(_, JSON.stringify(mapping));
	var resp = req.end().response(_);
	tracer.debug && tracer.debug("elasticIndex.index mapping update status: " + resp.statusCode + "; entity: " + entityName + "; diagnoses: " + sys.inspect(diagnoses));
	//
	_processElasticResp(_, resp, null, diagnoses, locale.format(module, "mappingUpdated", entityName));

}

// needs to export for unit tests
var _getIndexSettings = exports.getIndexSettings = function(localeCode, isFunctionIndex) {
	var ana = {};
	if (localeCode && _analyzersMap[localeCode]) {
		Object.keys(_analyzersMap[localeCode]).forEach(function(item) {
			if (item === "stemmer") {
				if (!offStemmer) {
					ana[item] = _analyzersMap[localeCode][item];
				}
			} else {
				ana[item] = _analyzersMap[localeCode][item];
			}
		});
	}
	var st = {
		"settings": {
			"index": {
				"analysis": {
					"analyzer": {
						"default": {}
					}
				}
			}
		}
	};
	if (ana) {
		var def = st.settings.index.analysis.analyzer.default;
		if (ana.analyzer) {
			def.type = ana.analyzer;
		} else {
			def.type = "custom";
			def.tokenizer = "whitespace";
			def.filter = ["syr_delimiter", "asciifolding", "lowercase", "elision"];
			var ft = st.settings.index.analysis.filter = {};
			ft.syr_delimiter = {
				"type": "word_delimiter",
				"split_on_numerics": false,
				"type_table": ["@ => ALPHANUM", ". => ALPHANUM", "- => ALPHA", "_ => ALPHANUM"] // add "-"
			};

			// Don't employ the stemmer for the functions index as it has an
			// undesired affect on the analysis of function codes.
			if (!isFunctionIndex) {
				if (ana.stemmer) {
					ft.syr_stemmer = {
						"type": "stemmer",
						"name": ana.stemmer
					};
					def.filter.push("syr_stemmer");
				}
			}
			if (ana.stop) {
				ft.syr_stop = {
					"type": "stop",
					"stopwords": ana.stop
				};
				def.filter.push("syr_stop");
			}
		}
		return st;
	} else return null;
};

// indexName already has localeCode

function _indexCreate(_, indexName, localeCode, model, options, isFunctionIndex) {
	var opt = options || {};
	var diagnoses = opt.diagnoses;
	// check if index exists
	var elasticBaseUrl = searchEngine.getBaseUrl();
	if (!elasticHelpers.indexExists(_, elasticBaseUrl, indexName, opt)) {
		// create index
		var reqUrl = elasticBaseUrl + "/" + indexName;
		var par = {
			url: reqUrl,
			method: 'PUT'
		};
		//var req = streams.httpRequest(par);
		var req = httpClient.httpRequest(_, par);

		var set = _getIndexSettings(localeCode, isFunctionIndex);
		set && req.write(_, JSON.stringify(set));
		var resp = req.end().response(_);
		tracer.debug && tracer.debug("elasticIndex.index put settings status: " + resp.statusCode);
		//
		_processElasticResp(_, resp, null, diagnoses, locale.format(module, "indexCreated", indexName));
		// add search facets: add to index a new type $facet, every entry should have code and description; the id is the code
		// create a mapping
		var mapping = {
			$facet: {
				properties: {
					code: {
						type: "string",
						index: "no",
						include_in_all: false
					},
					description: {
						type: "string",
						index: "no",
						include_in_all: false
					}
				}
			}
		};
		var _options = {
			url: elasticBaseUrl + "/" + indexName + "/$facet/_mapping",
			method: 'PUT'
		};
		//req = streams.httpRequest(_options);

		req = httpClient.httpRequest(_, _options);

		req.write(_, JSON.stringify(mapping));
		resp = req.end().response(_);
		//
		_processElasticResp(_, resp, null, diagnoses, locale.format(module, "mappingUpdated", "$facet"));
		// index facets
		// indexing facets one by one is easyier to make them non searchable than if we would add a map.
		var facets = model.getSearchFacets(_);
		if (facets && facets.length) {
			tracer.debug && tracer.debug("ElasticIndex.updateFacets");
			//
			var _indexName = indexName;
			//
			_options = {
				url: elasticBaseUrl + "/_bulk",
				method: 'PUT'
			};
			req = httpClient.httpRequest(_, _options);
			//
			facets.forEach_(_, function(_, f) {
				var action = {
					index: {
						_index: _indexName,
						_type: "$facet",
						_id: f.code
					}
				};
				req.write(_, JSON.stringify(action) + "\n");
				tracer.debug && tracer.debug("ElasticIndex.updateFacets: index data: " + sys.inspect(f));
				req.write(_, JSON.stringify(f) + "\n");
			});
			resp = req.end().response(_);
			//
			_processElasticResp(_, resp, null, diagnoses, "$facets updated");
		}
		//
		exports.registerModelEvents(_, config.searchEngine);
	}
}

exports.deleteEndpointIndex = function(_, endpoint, localeCode, diagnoses) {
	var elasticBaseUrl = searchEngine.getBaseUrl();
	var indexName = elasticHelpers.getFullIndexName(endpoint.getIndexName(_, localeCode));
	if (!elasticHelpers.indexExists(_, elasticBaseUrl, indexName, {
			$diagnoses: diagnoses
		})) {
		diagnoses.push({
			$severity: "info",
			$message: locale.format(module, "indexDeleted", indexName)
		});
		return;
	}
	//
	var options = {
		url: elasticBaseUrl + "/" + indexName,
		method: "DELETE"
	};
	//var req = streams.httpRequest(options);

	var req = httpClient.httpRequest(_, options);

	var resp = req.end().response(_);

	options = {
		url: elasticBaseUrl + "/" + indexName + "_entities/",
		method: "DELETE"
	};
	//var req = streams.httpRequest(options);
	req = httpClient.httpRequest(_, options);

	resp = req.end().response(_);
	//
	_processElasticResp(_, resp, null, diagnoses, locale.format(module, "indexDeleted", indexName));
};

exports.deleteAllIndex = function(_, context, diagnoses) {
	var elasticBaseUrl = searchEngine.getBaseUrl();

	var patternIndex = elasticHelpers.getFullIndexName("*");

	var options = {
		url: elasticBaseUrl + "/" + patternIndex,
		method: "DELETE"
	};
	var req = httpClient.httpRequest(_, options);
	var resp = req.end().response(_);
	//
	_processElasticResp(_, resp, context, diagnoses, locale.format(module, "indexDeleted", "all"));
};


function _deleteDataEntity(_, context, indexName, entityName, diagnoses) {
	var elasticBaseUrl = searchEngine.getBaseUrl();
	if (!elasticHelpers.indexExists(_, elasticBaseUrl, indexName, {
			$diagnoses: diagnoses
		})) {
		diagnoses.push({
			$severity: "info",
			$message: locale.format(module, "dataDeleted", indexName)
		});
		return;
	}
	var options = {
		url: elasticBaseUrl + "/" + indexName + "/" + entityName.name,
		method: "DELETE"
	};
	var req = httpClient.httpRequest(_, options);
	var resp = req.end().response(_);
	context && _processElasticResp(_, resp, context, diagnoses, locale.format(module, "dataDeleted", indexName));

}

function _deleteMappingEntity(_, context, indexName, entityName, diagnoses) {
	var elasticBaseUrl = searchEngine.getBaseUrl();
	if (!elasticHelpers.indexExists(_, elasticBaseUrl, indexName, {
			$diagnoses: diagnoses
		})) {
		diagnoses.push({
			$severity: "info",
			$message: locale.format(module, "mappingDeleted", indexName)
		});
		return;
	}
	var options = {
		url: elasticBaseUrl + "/" + indexName + "/" + entityName.name + "/_mapping",
		method: "DELETE"
	};
	var req = httpClient.httpRequest(_, options);
	var resp = req.end().response(_);
	context && _processElasticResp(_, resp, context, diagnoses, locale.format(module, "mappingDeleted", indexName));

}

function _deleteIndex(_, context, indexName, diagnoses) {

	var elasticBaseUrl = searchEngine.getBaseUrl();
	if (!elasticHelpers.indexExists(_, elasticBaseUrl, indexName, {
			$diagnoses: diagnoses
		})) {
		diagnoses.push({
			$severity: "info",
			$message: locale.format(module, "indexDeleted", indexName)
		});
		return;
	}
	var options = {
		url: elasticBaseUrl + "/" + indexName,
		method: "DELETE"
	};
	//var req = streams.httpRequest(options);

	var req = httpClient.httpRequest(_, options);

	var resp = req.end().response(_);
	//
	context && _processElasticResp(_, resp, context, diagnoses, locale.format(module, "indexDeleted", indexName));
}

exports.deleteIndex = _deleteIndex;


function _scheduleToIndex(_, runner, instance) {
	var ent = instance.getEntity(_);
	if (ent && ent.$searchIndex && ent.$searchIndex.$fields) {
		runner.scheduleAction(_, "reindex", instance.$uuid, instance.computeUrl(true));
	}
}

exports.registerModelEvents = function(_, config) {
	// only the administration endpoint can be indexed in real time for now
	var admEp = adminHelpers.getCollaborationEndpoint(_);
	if (!admEp) return; // in unit test environnement this may happen
	var db = admEp.getOrm(_);
	var runnerEnt = db.getEntity(_, "objectActionsRunner");
	var model = admEp.getModel(_, false);
	var runner = db.fetchInstance(_, runnerEnt, {});
	if (!runner) {
		runner = runnerEnt.createInstance(_, db);
		runner.save(_);
	}
	model && model.registerEvent(_, "$afterSave", "searchIndexUpdate", function(_, instance) {
		_scheduleToIndex(_, runner, instance);
		flows.eachKey(_, instance._reindexInst, function(_, k, inst) {
			_scheduleToIndex(_, runner, inst);
		});
	});
};