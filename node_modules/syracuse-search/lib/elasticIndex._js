"use strict";

var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var globals = require('streamline/lib/globals');
var flows = require('streamline/lib/util/flows');
var helpers = require('syracuse-core/lib/helpers');
var forEachKey = helpers.object.forEachKey;
var streams = require("streamline/lib/streams/streams");
var resourceHelpers = require("syracuse-core/lib/resource/util");
var resourceProxy = require("syracuse-core/lib/resource/resourceProxy");
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var datetime = require("syracuse-core/lib/types/datetime");
var locale = require("syracuse-core/lib/locale");
var elasticHelpers = require("syracuse-search/lib/helpers");
var sys = require("util");

exports.tracer = null;
//exports.tracer = console.log;
exports.serverConfig = null;

// defines
var functionIndexName = "sage.x3.functions";

// TODO: map all locales codes to supported elasticsearch analyzers
var _analyzersMap = {
	"de-de": {
		"stemmer": "german",
		"stop": "_german_"
	},
	"en-us": {
		"stemmer": "english",
		"stop": "_english_"
	},
	"es-es": {
		"stemmer": "spanish",
		"stop": "_spanish_"
	},
	"fr-fr": {
		"stemmer": "french",
		"stop": "_french_"
	},
	"it-it": {
		"stemmer": "italian",
		"stop": "_italian_"
	},
	"pl-pl": {
		"stemmer": "polish"
	},
	"pt-br": {
		"stemmer": "brazilian",
		"stop": "_brazilian_"
	},
	"pt-pt": {
		"stemmer": "portuguese",
		"stop": "_portuguese_"
	},
	"ru-ru": {
		"stemmer": "russian",
		"stop": "_russian_"
	},
	"zh-cn": {
		"analyzer": "chinese"
	}
};
_analyzersMap["en-gb"] = _analyzersMap["en-us"];
_analyzersMap["zh-hk"] = _analyzersMap["zh-cn"];
_analyzersMap["zh-mo"] = _analyzersMap["zh-cn"];
_analyzersMap["zh-sg"] = _analyzersMap["zh-cn"];
_analyzersMap["zh-tw"] = _analyzersMap["zh-cn"];

// supported analyzers:
// arabic, armenian, basque, brazilian, bulgarian, catalan, chinese, cjk, czech, danish, dutch, english, finnish, french, galician, german, greek, hindi, hungarian, indonesian, italian, norwegian, persian, portuguese, romanian, russian, spanish, swedish, turkish, thai

function _createInstanceIndexResource(_, instance, endpoint, options) {
	function _computeUrl(_, inst) {
		//		exports.tracer && exports.tracer("compute url: " + sys.inspect(entity.$urlTemplate));
		return entity.$urlTemplate && entity.$urlTemplate.resolve({
			$baseUrl: endpoint.getBaseUrl(_),
			$key: instance.computeKey()
		});
	}

	function decodeTemplate(_, inst, templ) {
		if (!templ) return;
		var template = templ;
		if (typeof templ === "string") template = new resourceProxy.Template(templ);
		var res = template.expression;
		if (!template.matches) return res;
		template.matches.forEach_(_, function(_, match) {
			var prop = match.substring(1, match.length - 1);
			if (inst._meta.$properties[prop]) res = res.replace(match, resourceHelpers.formatValue(inst._meta.$properties[prop], inst[prop](_)) || "");
			else if (inst._meta.$relations[prop]) {
				if (inst._meta.$relations[prop].isPlural) res = res.replace(match, inst[prop](_).toArray(_).map_(_, function(_, elem) {
					return decodeTemplate(_, elem, inst._meta.$relations[prop].targetEntity.$valueTemplate);
				}).join(","));
				else res = res.replace(match, decodeTemplate(_, inst[prop](_), inst._meta.$relations[prop].targetEntity.$valueTemplate));
			}
		});
		return res;
	}
	var opt = options || {};
	options && options.tracer && options.tracer("ElasticIndex.createResource: enter: " + instance.$uuid);
	var entity = instance.getEntity(_);
	var facets = entity.getSearchFacets(_);
	var inst = instance;
	var data = {};
	(entity.getSearchFields(_) || []).forEach_(_, function(_, field) {
		var val = null;
		var p;
		if (p = entity.$properties[field]) {
			val = resourceHelpers.formatValue(p, inst[field](_));
		} else if (p = entity.$relations[field]) {
			var rel = entity.$relations[field];
			var relData = inst[field](_);
			var childOpt = opt;
			if (rel.getIsChild()) {
				childOpt = _unfixFunctionsOptions(opt);
				childOpt.isChild = true;
			}
			if (rel.isPlural) relData.toArray(_).forEach_(_, function(_, item) {
				(val = val || []).push(rel.getIsChild() ? _createInstanceIndexResource(_, item, endpoint, childOpt) : decodeTemplate(_, item, rel.targetEntity.$valueTemplate));
			});
			else if (relData) val = rel.getIsChild() ? _createInstanceIndexResource(_, relData, endpoint, childOpt) : decodeTemplate(_, relData, rel.targetEntity.$valueTemplate);

		}
		options && options.tracer && options.tracer("ElasticIndex.createResource: compute field: " + field + "; value: " + val);
		//
		if (val) {
			data[field] = val;
			// facets is a structure like
			// {
			//		classField: ["facet1Name", "facet2Name"]
			// }
			// one field can be part of several facets
			if (facets && facets[field]) facets[field].forEach(function(f) {
				options && options.tracer && options.tracer("ElasticIndex.createResource: field facet: " + f);
				data["facet_" + f] = val;
			});
		}
	});
	// add some data to the resource
	(opt.rawData || []).forEach_(_, function(_, relName) {
		options && options.tracer && options.tracer("ElasticIndex.createResource: set rawData for relation: " + relName);
		var rel = entity.$relations[relName];
		if (!rel) return;
		data["$rawData"] = data["$rawData"] || {};
		var relData = inst[relName](_);
		if (rel.isPlural) relData.toArray(_).forEach_(_, function(_, item) {
			(data.$rawData[relName] = data.$rawData[relName] || []).push(item.$uuid);
		});
		else if (relData) {
			data.$rawData[relName] = relData.$uuid;
			options && options.tracer && options.tracer("ElasticIndex.createResource: rawData found for " + relName + ": " + relData.$uuid);
		}
	});
	options && options.tracer && options.tracer("ElasticIndex.createResource: compute templates");
	if (!(options && options.isChild)) {
		data.$description = decodeTemplate(_, inst, entity.$summaryTemplate || entity.$valueTemplate);
		if (entity.$iconTemplate) data.$icon = decodeTemplate(_, inst, entity.$iconTemplate);
		//
		var url = (opt.computeUrl || _computeUrl)(_, instance);
		if (url) data.$url = url;
		var method = opt.computeUrlMethod && opt.computeUrlMethod(_, instance);
		if (method) data.$method = method;
	}
	//
	return data;
}

function _unfixFunctionsOptions(options) {
	options = options || {};
	var o = helpers.object.clone(options);
	o.rawData = null;
	o.computeUrl = null;
	o.computeUrlMethod = null;
	return o;
}

function _fixFunctionsOptions(options) {
	options = options || {};
	var o = helpers.object.clone(options);
	o.indexName = functionIndexName;
	o.indexTypeName = "function";
	o.indexTypeTitle = "Function";
	o.rawData = ["application", "endpoint"];
	o.computeUrl = function(_, instance) {
		return instance.getItemUrl(_);
	};
	o.computeUrlMethod = function(_, instance) {
		return instance.getMethod(_);
	};
	return o;
}

function ElasticIndex(ep, localeCode) {
	this._endpoint = ep;
	this._locale = localeCode || locale.current;
	this._locale = this._locale.toLowerCase();
}

exports.IndexHelper = helpers.defineClass(ElasticIndex, null, {
	getIndexName: function(_, opt) {
		var name = opt && opt.indexName ? opt.indexName + (this._locale ? "." + this._locale : "") : this._endpoint.getIndexName(_, this._locale);
		if (globals.context.tenantId) name = globals.context.tenantId + '.' + name;
		return name;
	},
	getLastIndexDate: function(_, entityName) {
		var self = this;
		var elasticBaseUrl = exports.serverConfig.baseUrl;
		var par = {
			url: elasticBaseUrl + "/" + self.getIndexName(_) + "/$entities/" + entityName,
			method: 'GET'
		};
		var resp = streams.httpRequest(par).end().response(_);
		var content = resp.readAll(_);
		if (resp.statusCode === 200) {
			content = JSON.parse(content);
			return content._source && content._source.lastIndexDate;
		} else return null;
	},
	updateEntities: function(_, entityName, data, options) {
		var self = this;
		var elasticBaseUrl = exports.serverConfig.baseUrl;
		var par = {
			url: elasticBaseUrl + "/" + self.getIndexName(_) + "/$entities/" + entityName,
			method: 'PUT'
		};
		var resp = streams.httpRequest(par).end(JSON.stringify(data)).response(_);
		var diag = JSON.parse(resp.readAll(_));
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: index response: " + sys.inspect(diag));
		if (options && options.diagnoses) {
			if (diag.ok) options.diagnoses.push({
				$severity: "info",
				$message: locale.format(module, "instanceUpdated", entityName)
			});
			else if (diag.error) options.diagnoses.push({
				$severity: "error",
				$message: diag.error
			});
		}

	},
	setLastIndexDate: function(_, entityName, lastIndexDate) {
		var self = this;
		var elasticBaseUrl = exports.serverConfig.baseUrl;
		var par = {
			url: elasticBaseUrl + "/" + self.getIndexName(_) + "/$entities/" + entityName,
			method: 'PUT'
		};
		var resp = streams.httpRequest(par).end(JSON.stringify({
			lastIndexDate: lastIndexDate
		})).response(_);

	},
	updateInstance: function(_, instance, options) {
		var opt = options || {};
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: enter: " + instance._meta.name + "." + instance.$uuid);
		//
		var self = this;
		var _indexName = self.getIndexName(_, opt);
		var elasticBaseUrl = exports.serverConfig.baseUrl;
		if (!elasticHelpers.indexExists(_, elasticBaseUrl, _indexName, {
			silent: true
		})) return;
		//
		var entity = instance.getEntity(_);
		var f = entity.getSearchFields(_);
		if (!f || !f.length) return;

		var reqOptions = {
			url: [elasticBaseUrl, _indexName, opt.indexTypeName || entity.name, instance.computeKey()].join("/"),
			method: 'PUT'
		};
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: url: " + reqOptions.url);
		var req = streams.httpRequest(reqOptions);
		var data = _createInstanceIndexResource(_, instance, self._endpoint, options);
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: index data: " + sys.inspect(data));
		req.write(_, JSON.stringify(data));
		var resp = req.end().response(_);
		//
		var diag = JSON.parse(resp.readAll(_));
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: index response: " + sys.inspect(diag));
		if (options && options.diagnoses) {
			if (diag.ok) options.diagnoses.push({
				$severity: "info",
				$message: locale.format(module, "instanceUpdated", instance.getValue(_))
			});
			else if (diag.error) options.diagnoses.push({
				$severity: "error",
				$message: diag.error
			});
		}
	},
	updateEntity: function(_, entity, differential, options) {

		var opt = options || {};
		var diag = opt.diagnoses || [];
		opt.tracer && opt.tracer("ElasticIndex.updateEntity: enter: " + entity.name);
		//
		var self = this;
		var _indexName = self.getIndexName(_, opt);
		var elasticBaseUrl = exports.serverConfig.baseUrl;
		var db = self._endpoint.getOrm(_);

		opt.tracer && opt.tracer("ElasticIndex.updateEntity: mapping update");
		// update mapping
		_indexMappingUpdate(_, _indexName, entity, entity.getSearchFacets(_), opt);

		// update data
		var where = null,
			lastIndex = null;
		if (differential) {
			lastIndex = self.getLastIndexDate(_, entity.name);
			if (lastIndex) {
				where = {
					sdataWhere: "(" + db.getUpdDatePropName() + " gt \"" + (new Date(lastIndex)).toISOString() + "\")"
				};
				opt.tracer && opt.tracer("ElasticIndex.updateEntity: differential where: " + where.sdataWhere);
			}
		}
		//
		opt.tracer && opt.tracer("ElasticIndex.updateEntity: fetching data");
		lastIndex = new Date();
		var cnt = 0;
		console.log("indexname ");

		var cursor = db.createCursor(_, entity, where, "$search");

		console.log("indexname 2");

		var inst = cursor.next(_);
		console.log("instance " + require('util').inspect(inst));
		if (inst) {
			var aborted = false;
			do {
				var _options = {
					url: elasticBaseUrl + "/_bulk",
					method: 'PUT'
				};
				var req = streams.httpRequest(_options);
				do {
					aborted = opt.tracker && opt.tracker.abortRequested;
					//
					var action = {
						index: {
							_index: _indexName,
							_type: opt.indexTypeName || entity.name,
							_id: inst.computeKey()
						}
					};
					req.write(_, JSON.stringify(action) + "\n");
					var data = _createInstanceIndexResource(_, inst, self._endpoint, opt);
					opt.tracer && opt.tracer("ElasticIndex.updateEntity: index data: " + sys.inspect(data));
					req.write(_, JSON.stringify(data) + "\n");
					cnt++;
					inst = cursor.next(_);
				} while (inst && (cnt % 1000 !== 0) && !aborted);
				var resp = req.end().response(_);
				//
				_processElasticResp(_, resp, null, diag, entity.name + " records updated");
			} while (inst && !aborted);
		}
		//self.setLastIndexDate(_, entity.name, lastIndex);
		// update prototype info: TODO ? not now, maybe 7.1 ?
		exports.tracer && exports.tracer("entity " + entity.name);
		self.updateEntities(_, entity.name, {
			lastIndexDate: lastIndex,
			$prototype: self.getPrototype(_, entity, opt)
		}, options);
		diag && diag.push({
			$severity: "info",
			$message: locale.format(module, "updateCount", cnt, entity.name)
		});

	},
	updateIndex: function(_, differential, options) {
		function _track(phase, detail, progress) {
			if (!opt.tracker) return;
			opt.tracker.phase = phase;
			opt.tracker.phaseDetail = detail;
			opt.tracker.progress = progress;
		}
		var opt = options || {},
			currentLocal = null;
		opt.diagnoses = opt.diagnoses || [];
		opt.tracer && opt.tracer("ElasticIndex.updateIndex enter: locale=" + opt.locale);
		if (opt.locale) {
			currentLocal = globals.context.sessionLocale;
			globals.context.sessionLocale = opt.locale;
		}
		var self = this;
		var model = self._endpoint.getModel(_);
		var indexTime = datetime.now();
		var indexName = self.getIndexName(_, opt);
		var pSlices = opt.progressSlices || 1;
		var pCrtSlice = opt.progressCurrentSlice || 1;
		//
		opt.tracer && opt.tracer("ElasticIndex.updateIndex creating index");
		adminHelpers.AdminHelper.logServerMessage(_, locale.format(module, "startIndexUpd", indexName), []);
		_track(locale.format(module, "startIndexUpd", indexName), "", 0);
		_indexCreate(_, self.getIndexName(_, opt), self._locale, model, opt);
		//
		var entities = [];
		// model.resetCache();
		if (opt.entities && opt.entities.length) {
			opt.entities.forEach_(_, function(_, r) {
				// sanitize
				try {
					var e = model.getEntity(_, r, "$search");
					if (e) entities.push(e);
					else opt.diagnoses.push({
						$severity: "warning",
						$message: locale.format(module, "entNotFound", r)
					});
				} catch (e) {
					opt.diagnoses.push({
						$severity: "error",
						$message: locale.format(module, "entError", r, e.message),
						$stackTrace: e.$stackTrace || e.stack
					});
				}
			});
		} else {
			entities = model.getIndexedEntities(_, opt);
		}
		// use some instead of forEach to be able to abort loop
		var idx = 0;
		entities.some_(_, function(_, entity) {
			_track(locale.format(module, "indexingEntity"), entity.name, Math.ceil(idx++ * pCrtSlice * 100 / (entities.length * pSlices)));
			try {
				self.updateEntity(_, entity, differential, opt);
				// index menuItems as functions
				if (entity.name === "menuItem") {
					self.updateFunctions(_, entity, differential, opt);
				}
			} catch (e) {
				opt.diagnoses.push({
					$severity: "error",
					$message: e.message,
					$stackTrace: e.$stackTrace || e.stack
				});
			}
			return (opt.tracker && opt.tracker.abortRequested);
		});
		var msg = opt.tracker && opt.tracker.abortRequested ? locale.format(module, "indexUpdAborted") : locale.format(module, "endIndexUpd", indexName);
		opt.diagnoses.push({
			$severity: "success",
			$message: msg
		});
		_track("", msg, Math.ceil(pCrtSlice * 100 / pSlices));
		opt.diagnoses && adminHelpers.AdminHelper.logServerMessage(_, msg, opt.diagnoses);
		if (opt.locale) {
			globals.context.sessionLocale = currentLocal;
		}
	},
	updateFunctions: function(_, menuItemEntity, differential, options) {
		var self = this;
		var entity = menuItemEntity;
		// ensure functions index
		_indexCreate(_, self.getIndexName(_, {
			indexName: functionIndexName
		}), self._locale, self._endpoint.getModel(_), options);
		//
		self.updateEntity(_, entity, differential, _fixFunctionsOptions(options));
	},
	updateFunctionInstance: function(_, instance, options) {
		var self = this;
		// ensure functions index
		_indexCreate(_, self.getIndexName(_, {
			indexName: functionIndexName
		}), self._locale, self._endpoint.getModel(_), options);
		//
		self.updateInstance(_, instance, _fixFunctionsOptions(options));
	},
	getPrototype: function(_, entity, options) {
		var opt = options || {};
		options && options.tracer && options.tracer("ElasticIndex.updatePrototype: enter: " + entity.name);
		//
		var self = this;
		var _indexName = self.getIndexName(_, opt);
		var elasticBaseUrl = exports.serverConfig.baseUrl;

		options && options.tracer && options.tracer("ElasticIndex.updatePrototype: url: " + options.url);
		var data = entity.getPrototype(_, entity.name, "$search"); // TODO
		options && options.tracer && options.tracer("ElasticIndex.updatePrototype: index data: " + sys.inspect(data));
		var prototype = {
			$properties: data.$properties,
			$localization: data.$localization
		};
		//
		return prototype;
	}
});

function _processElasticResp(_, elasticResp, contextResp, diagnoses, okMessage) {
	if (diagnoses) {
		var diag = JSON.parse(elasticResp.readAll(_));
		if (diag.ok) diagnoses.push({
			$severity: "info",
			$message: okMessage
		});
		else if (diag.error) diagnoses.push({
			$severity: "error",
			$message: diag.error
		});
	} else {
		var buffer;
		while (buffer = elasticResp.read(_)) contextResp.write(_, buffer);
	}
}

function _addFacetFieldsMapping(searchFacets, entityName, mapping) {
	if (!searchFacets) return;
	forEachKey(searchFacets, function(classField, facets) {
		if (!facets) return;
		facets.forEach(function(f) {
			mapping[entityName].properties["facet_" + f] = {
				type: "string",
				analyzer: "keyword"
			};
		});
	});
}

function _indexMappingUpdate(_, indexName, entity, searchFacets, opt) {

	opt = opt || {};
	var entityName = opt.indexTypeName || entity.name;
	var diagnoses = opt && opt.diagnoses;
	var mapping = {};
	// opt.tracer && opt.tracer("_indexMappingUpdate: entityName=" + entityName + ", entity=" + sys.inspect(entity));
	var entityTitle = entity.$classTitle || entity.$titleTemplate || entity.$titleTemplate && entity.$titleTemplate.expression,
		classTitle = opt.indexTypeTitle || entity.contract && (entity.contract.localizedString(entityName, "$classTitle") || entity.contract.localizedString(entityName, "$titleTemplate")) || entityTitle;
	opt.tracer && opt.tracer("ElasticIndex _indexMappingUpdate: contract" + (entity.contract && entity.contract.application) + ", entityName=" + entityName + ", title=" + entityTitle + ", classTitle=" + classTitle);
	opt.tracer && entity && Object.keys(entity).forEach(function(key) {
		(key[0] === '$') && opt.tracer("   " + key + "=" + entity[key]);
	});

	// opt.tracer && opt.tracer("...title=" + entityTitle + ", classTitle=" + classTitle);
	mapping[entityName] = {
		properties: {},
		_meta: {
			$classTitle: classTitle
		}
	};
	var pm = mapping[entityName].properties;
	pm.$description = {
		type: "string",
		index: "no",
		include_in_all: false
	};
	pm.$title = {
		type: "string",
		index: "no",
		include_in_all: false
	};
	pm.$icon = {
		type: "string",
		index: "no",
		include_in_all: false
	};
	pm.$url = {
		type: "string",
		index: "no",
		include_in_all: false
	};
	// create a mapping for all localized properties
	// get all searchable locales
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	db.fetchInstances(_, db.getEntity(_, "localePreference"), {
		jsonWhere: {
			enabled: true,
			searchable: true
		}
	}).map_(_, function(_, l) {
		return l.code(_);
	});
	//
	_addFacetFieldsMapping(searchFacets, entityName, mapping);
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	var options = {
		url: elasticBaseUrl + "/" + indexName + "/" + entityName + "/_mapping",
		method: 'PUT'
	};
	var req = streams.httpRequest(options);
	req.write(_, JSON.stringify(mapping));
	var resp = req.end().response(_);
	exports.tracer && exports.tracer("elasticIndex.index exists status: " + resp.statusCode + "; entity: " + entityName);
	//
	_processElasticResp(_, resp, null, diagnoses, locale.format(module, "mappingUpdated", entityName));

}

// needs to export for unit tests
var _getIndexSettings = exports.getIndexSettings = function(localeCode) {
	var ana = (localeCode && _analyzersMap[localeCode]);
	var st = {
		"settings": {
			"index": {
				"analysis": {
					"analyzer": {
						"default": {}
					}
				}
			}
		}
	};
	if (ana) {
		var def = st.settings.index.analysis.analyzer.
		default;
		if (ana.analyzer) {
			def.type = ana.analyzer;
		} else {
			def.type = "custom";
			def.tokenizer = "whitespace";
			def.filter = ["syr_delimiter", "asciifolding", "lowercase", "elision"];
			var ft = st.settings.index.analysis.filter = {};
			ft.syr_delimiter = {
				"type": "word_delimiter",
				"type_table": ["@ => ALPHANUM", ". => ALPHANUM"]
			};
			if (ana.stemmer) {
				ft.syr_stemmer = {
					"type": "stemmer",
					"name": ana.stemmer
				};
				def.filter.push("syr_stemmer");
			}
			if (ana.stop) {
				ft.syr_stop = {
					"type": "stop",
					"stopwords": ana.stop
				};
				def.filter.push("syr_stop");
			}
		}
		return st;
	} else return null;
};

// indexName already has localeCode

function _indexCreate(_, indexName, localeCode, model, options) {
	var opt = options || {};
	var diagnoses = opt.diagnoses;
	// check if index exists
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	if (!elasticHelpers.indexExists(_, elasticBaseUrl, indexName, opt)) {
		// create index
		var reqUrl = elasticBaseUrl + "/" + indexName;
		var par = {
			url: reqUrl,
			method: 'PUT'
		};
		var req = streams.httpRequest(par);
		var set = _getIndexSettings(localeCode);
		set && req.write(_, JSON.stringify(set));
		var resp = req.end().response(_);
		opt.tracer && opt.tracer("elasticIndex.index put settings status: " + resp.statusCode);
		//
		_processElasticResp(_, resp, null, diagnoses, locale.format(module, "indexCreated", indexName));
		// add search facets: add to index a new type $facet, every entry should have code and description; the id is the code
		// create a mapping
		var mapping = {
			$facet: {
				properties: {
					code: {
						type: "string",
						index: "no",
						include_in_all: false
					},
					description: {
						type: "string",
						index: "no",
						include_in_all: false
					}
				}
			}
		};
		var _options = {
			url: elasticBaseUrl + "/" + indexName + "/$facet/_mapping",
			method: 'PUT'
		};
		req = streams.httpRequest(_options);
		req.write(_, JSON.stringify(mapping));
		resp = req.end().response(_);
		//
		_processElasticResp(_, resp, null, diagnoses, locale.format(module, "mappingUpdated", "$facet"));
		// index facets
		// indexing facets one by one is easyier to make them non searchable than if we would add a map.
		var facets = model.getSearchFacets(_);
		if (facets && facets.length) {
			opt.tracer && opt.tracer("ElasticIndex.updateFacets");
			//
			var _indexName = indexName;
			//
			_options = {
				url: elasticBaseUrl + "/_bulk",
				method: 'PUT'
			};
			req = streams.httpRequest(_options);
			//
			facets.forEach_(_, function(_, f) {
				var action = {
					index: {
						_index: _indexName,
						_type: "$facet",
						_id: f.code
					}
				};
				req.write(_, JSON.stringify(action) + "\n");
				opt.tracer && opt.tracer("ElasticIndex.updateFacets: index data: " + sys.inspect(f));
				req.write(_, JSON.stringify(f) + "\n");
			});
			resp = req.end().response(_);
			//
			_processElasticResp(_, resp, null, diagnoses, "$facets updated");
		}
		//
		exports.registerModelEvents(_, config.searchEngine);
	}
}

exports.deleteEndpointIndex = function(_, endpoint, localeCode, diagnoses) {
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	var indexName = endpoint.getIndexName(_, localeCode);
	if (!elasticHelpers.indexExists(_, elasticBaseUrl, indexName, {
		$diagnoses: diagnoses
	})) return;
	//
	var options = {
		url: elasticBaseUrl + "/" + indexName,
		method: "DELETE"
	};
	var req = streams.httpRequest(options);
	var resp = req.end().response(_);
	//
	_processElasticResp(_, resp, null, diagnoses, locale.format(module, "indexDeleted", indexName));
};

exports.deleteIndex = function(_, context, indexName, diagnoses) {
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	if (!elasticHelpers.indexExists(_, elasticBaseUrl, indexName, {
		$diagnoses: diagnoses
	})) return;
	var options = {
		url: elasticBaseUrl + "/" + indexName,
		method: "DELETE"
	};
	var req = streams.httpRequest(options);
	var resp = req.end().response(_);
	//
	_processElasticResp(_, resp, context, diagnoses, locale.format(module, "indexDeleted", indexName));
};

exports.registerModelEvents = function(_, config) {
	var admOrm = adminHelpers.AdminHelper.getCollaborationOrm(_);
	var eps = admOrm.fetchInstances(_, admOrm.getEntity(_, "endPoint"), {});
	eps.forEach_(_, function(_, e) {
		// TODO: see later for x3 endpoints, the connect sequence must be properly managed
		if (e.protocol(_) !== "syracuse") return;
		//
		var elasticBaseUrl = exports.serverConfig.baseUrl;
		var indexName = e.getIndexName(_, locale.current);
		if (!elasticHelpers.indexExists(_, elasticBaseUrl, indexName, {
			silent: true
		})) return;
		//
		var indexer = new ElasticIndex(e);
		var model = e.getModel(_, false);
		model && model.registerEvent(_, "$afterSave", "searchIndexUpdate", function(_, instance) {
			config.tracer && config.tracer("elasticIndex.$afterSave index " + instance._meta.name + "." + instance.$uuid);
			// index data for search. Call without callback
			indexer.updateInstance(!_, instance, config);
			if (instance.getEntity(_).name === "menuItem") indexer.updateFunctionInstance(!_, instance, config);
			// TODO: review this _reindexInst thing as is an undesired dependance from factory to search
			flows.eachKey(_, instance._reindexInst, function(_, k, inst) {
				indexer.updateInstance(!_, inst, config);
			});
		});
	});
};