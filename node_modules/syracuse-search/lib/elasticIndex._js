"use strict";

var sdataRegistry = require("syracuse-sdata/lib/sdataRegistry");
var flows = require('streamline/lib/util/flows');
var helpers = require('syracuse-core/lib/helpers')
var forEachKey = helpers.object.forEachKey;
var dataModel = require("syracuse-orm/lib/dataModel");
var http = require("http");
var streams = require("streamline/lib/streams/streams");
var resourceHelpers = require("syracuse-core/lib/resource/util");
var resourceProxy = require("syracuse-core/lib/resource/resourceProxy");
var indexMeta = require("syracuse-search/lib/indexMeta");
var sys = require("util");

exports.tracer = null;
exports.serverConfig = null;


function _createInstanceIndexResource(_, instance, options) {
	function decodeTemplate(_, inst, template) {
		if (!template) return;
		var res = template.expression;
		template.matches.forEach_(_, function(_, match) {
			var prop = match.substring(1, match.length - 1);
			if (inst._meta.$properties[prop]) res = res.replace(match, resourceHelpers.formatValue(inst._meta.$properties[prop], inst[prop](_)));
			else if (inst._meta.$relations[prop]) {
				if (inst._meta.$relations[prop].isPlural) res = res.replace(match, inst[prop](_).toArray(_).map_(_, function(_, elem) {
					return decodeTemplate(_, elem, inst._meta.$relations[prop].targetEntity.$valueTemplate);
				}).join(","));
				else res = res.replace(match, decodeTemplate(_, inst[prop](_), inst._meta.$relations[prop].targetEntity.$valueTemplate));
			}
		});
		return res;
	}
	options && options.tracer && options.tracer("ElasticIndex.createResource: enter: " + instance.$uuid);
	var entity = instance.getEntity();
	var facets = entity.getFacets(_);
	var inst = instance;
	var data = {};
	entity.$searchIndex.$fields.forEach_(_, function(_, field) {
		var val = null;
		if (entity.$properties[field]) {
			val = resourceHelpers.formatValue(entity.$properties[field], inst[field](_));
		} else if (entity.$relations[field]) {
			var rel = entity.$relations[field];
			var relData = inst[field](_);
			if (rel.isPlural)
				relData.toArray(_).forEach_(_, function(_, item) {
					(val = val || []).push(decodeTemplate(_, item, rel.targetEntity.$valueTemplate));
				});
			else
				if(relData) 
					val = decodeTemplate(_, relData, rel.targetEntity.$valueTemplate);

		}
		options && options.tracer && options.tracer("ElasticIndex.createResource: compute field: " + field + "; value: " + val);
		//
		if(val) {
			data[field] = val;
			// facets is a structure like 
			// {
			//		classField: ["facet1Name", "facet2Name"]
			// }
			// one field can be part of several facets
			if(facets && facets[field])
				facets[field].forEach(function(f) {
					options && options.tracer && options.tracer("ElasticIndex.createResource: field facet: " + f);
					data["facet_" + f] = val;
				});
		}
	});
	options && options.tracer && options.tracer("ElasticIndex.createResource: compute templates");
	data.$description = decodeTemplate(_, inst, entity.$summaryTemplate || entity.$valueTemplate);
	if(entity.$iconTemplate) data.$icon = decodeTemplate(_, inst, entity.$iconTemplate);
	//
	return data;
}

function ElasticIndex(ep) {
	this._endpoint = ep;
}

exports.ElasticIndex = helpers.defineClass(ElasticIndex, null, {
	updateInstance: function(_, instance, options) {
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: enter: " + instance._meta.name + "." +instance.$uuid);
		// 
		var self = this;
		var _indexName = self._endpoint.getIndexName(_);
		var elasticBaseUrl = exports.serverConfig.baseUrl;
		var entity = instance.getEntity();
		
		var reqOptions = {
			url: [elasticBaseUrl, _indexName, entity.name, instance.$uuid].join("/"),
			method: 'PUT'
		};
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: url: " + reqOptions.url);
		var req = streams.httpRequest(reqOptions);
		var data = _createInstanceIndexResource(_, instance, options);
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: index data: " + sys.inspect(data));
		req.write(_, JSON.stringify(data));
		var resp = req.end().response(_);
		//
		var diag = JSON.parse(resp.readAll(_));
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: index response: " + sys.inspect(diag));
		if(options && options.diagnoses) {
			if(diag.ok)
				options.diagnoses.push({severity:"info", message: okMessage});
			else
				if(diag.error)
					options.diagnoses.push({severity:"error", message: diag.error});
		}
	}
});


function _shortIndexName(indexName) {
	return indexName.split(".").slice(-3).slice(0, 2).join(".");
}

function _processElasticResp(_, elasticResp, contextResp, diagnoses, okMessage) {
	if(diagnoses) {
		var diag = JSON.parse(elasticResp.readAll(_));
		if(diag.ok)
			diagnoses.push({severity:"info", message: okMessage});
		else
			if(diag.error)
				diagnoses.push({severity:"error", message: diag.error});
	} else {
		var buffer;
		while(buffer = elasticResp.read(_)) contextResp.write(_, buffer);
	}
}

function _addFacetFieldsMapping(searchFacets, entityName, mapping) {
	if(!searchFacets) return;
	forEachKey(searchFacets, function(key, facet) {
		if(facet.$fields && facet.$fields[entityName])
			mapping[entityName].properties["facet_"+key] = {
				type: "string",
				analyzer: "keyword"
			};
	});
}

function _indexMappingUpdate(_, context, indexName, entityName, searchFacets, diagnoses) {
	var mapping = {};
	mapping[entityName] = {
		properties: {}
	};
	mapping[entityName].properties.$description = {
		type: "string",
		index: "no",
		include_in_all: false
	};
	mapping[entityName].properties.$title = {
			type: "string",
			index: "no",
			include_in_all: false
	};
	mapping[entityName].properties.$icon = {
			type: "string",
			index: "no",
			include_in_all: false
	};
	_addFacetFieldsMapping(searchFacets, entityName, mapping);
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	var options = {
		url: elasticBaseUrl + "/" + indexName + "/" + entityName + "/_mapping",
		method: 'PUT'
	};
	var req = streams.httpRequest(options);
	req.write(_, JSON.stringify(mapping));
	var resp = req.end().response(_);
	exports.tracer && exports.tracer("elasticIndex.index exists status: " + resp.statusCode + "; entity: " + entityName);
	//
	_processElasticResp(_, resp, context.response, diagnoses, entityName+" mapping updated");
}

function _indexCreate(_, context, indexName, diagnoses) {
	// check if index exists
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	var options = {
			url: elasticBaseUrl + "/" + indexName,
			method: 'HEAD'
		};
	var resp = streams.httpRequest(options).end().response(_);
	exports.tracer && exports.tracer("elasticIndex.index exists status(updateDataset): "+resp.statusCode);
	if(resp.statusCode == 404) {
		// create index
		var reqUrl = elasticBaseUrl + "/" + indexName;
		var options = {
				url: reqUrl,
				method: 'PUT'
			};
		var resp = streams.httpRequest(options).end().response(_);
		exports.tracer && exports.tracer("elasticIndex.index put settings status: "+resp.statusCode);
		//
		_processElasticResp(_, resp, context.response, diagnoses, "index created");
	}
}

function _updateEntityIndex(_, context, indexName, contract, entity, db, diagnoses) {
	function decodeTemplate(_, inst, template) {
		if (!template) return;
		var res = template.expression;
		template.matches.forEach_(_, function(_, match) {
			var prop = match.substring(1, match.length - 1);
			if (inst._meta.$properties[prop]) res = res.replace(match, resourceHelpers.formatValue(inst._meta.$properties[prop], inst[prop](_)));
			else if (inst._meta.$relations[prop]) {
				if (inst._meta.$relations[prop].isPlural) res = res.replace(match, inst[prop](_).toArray(_).map_(_, function(_, elem) {
					return decodeTemplate(_, elem, inst._meta.$relations[prop].targetEntity.$valueTemplate);
				}).join(","));
				else res = res.replace(match, decodeTemplate(_, inst[prop](_), inst._meta.$relations[prop].targetEntity.$valueTemplate));
			}
		});
		return res;
	}
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	// update mapping
	_indexMappingUpdate(_, context, indexName, entity.name, contract.searchFacets, diagnoses);
	// update data
	var instArray = db.fetchInstances(_, entity);
	if (!instArray.length) return;
	var options = {
		url: elasticBaseUrl + "/_bulk",
		method: 'PUT'
	};
	var req = streams.httpRequest(options);
	instArray.forEach_(_, function(_, inst) {
		//
		var action = {
			index: {
				_index: indexName,
				_type: entity.name,
				_id: inst.$uuid
			}
		}
		//		console.log("indexing: action: "+JSON.stringify(action));
		req.write(_, JSON.stringify(action) + "\n");
		var data = {};
		entity.$searchIndex.$fields.forEach_(_, function(_, field) {
			var val = null;
			if (entity.$properties[field]) {
				val = resourceHelpers.formatValue(entity.$properties[field], inst[field](_));
			} else if (entity.$relations[field]) {
				var rel = entity.$relations[field];
				var relData = inst[field](_);
				if (rel.isPlural)
					relData.toArray(_).forEach_(_, function(_, item) {
						(val = val || []).push(decodeTemplate(_, item, rel.targetEntity.$valueTemplate));
					});
				else
					if(relData) 
						val = decodeTemplate(_, relData, rel.targetEntity.$valueTemplate);

			}
			//
			if(val) {
				data[field] = val;
				// TODO: optimize this
				if(contract.searchFacets)
					forEachKey(contract.searchFacets, function(key, facet) {
						if(facet.$fields && facet.$fields[entity.name] && (facet.$fields[entity.name] === field))
							data["facet_"+key] = val;
					});
			}
		});
//		data.$title = decodeTemplate(_, inst, entity.$titleTemplate);
		data.$description = decodeTemplate(_, inst, entity.$valueTemplate);
//		console.log(entity.name + " icon template: "+entity.$iconTemplate);
		if(entity.$iconTemplate) data.$icon = decodeTemplate(_, inst, entity.$iconTemplate);
//		console.log(entity.name + " icon: "+sys.inspect(data.$icon));
//		console.log("indexing: data: "+JSON.stringify(data));
		req.write(_, JSON.stringify(data) + "\n");
	});
	var resp = req.end().response(_);
	//
	_processElasticResp(_, resp, context.response, diagnoses, entity.name+" records updated");
}

function _getDescription(_, indexName, type, item, prototype) {
	var descTemplate = indexMeta.index[_shortIndexName(indexName)] && indexMeta.index[_shortIndexName(indexName)].entities[type] 
		&& indexMeta.index[_shortIndexName(indexName)].entities[type].$resources.$item.$description;
	if(!descTemplate) return (item.$description || item.$value);
	var template = new resourceProxy.Template(descTemplate);
	var res = template.expression;
	(template.matches || []).forEach(function(match) {
		var prop = match.substring(1, match.length-1);
		var val;
		if(prototype[prop]) {
			switch(prototype[prop].$type) {
				case "application/x-choice":
					val = ((((prototype[prop].$value.$constraints || {}).$enum || []).filter(function(enumItem) {return enumItem.$value === item[prop]}) || [])[0] || {}).$title;
					break;
				default:
					val = item[prop];
			}
		} else
			val = item[prop];
		res = res.replace(match, val);
	});
	return res;
}

function _restUpdateEntityIndex(_, context, indexName, baseUrl, entityName, diagnoses) {
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	// update mapping
	_indexMappingUpdate(_, context, indexName, entityName, {}, diagnoses);
	// get prototype
	var options = {
			// TODO : implement $search representation
			url: baseUrl + "/$prototypes('" + entityName + ".$query')",
			method: 'GET',
			headers: {
				"content-type": "application/json",
				cookie: context.httpSession.cookie,
				accept: "application/json"
			}
		};
	exports.tracer && exports.tracer("elasticIndex prototype get url: "+options.url);
	var resp = streams.httpRequest(options).end().response(_);
	exports.tracer && exports.tracer("elasticIndex prototype get status: "+resp.statusCode+"; baseUrl: "+baseUrl);
	if(resp.statusCode != 200) {
		diagnoses && diagnoses.push({severity:"error", message: entityName + " prototype not found"});
		diagnoses && diagnoses.push({severity:"error", message: resp.readAll(_).toString("utf8")});
		return;
	}
	var prototype = JSON.parse(resp.readAll(_));
	exports.tracer && exports.tracer("elasticIndex prototype: "+sys.inspect(prototype, null, 4));
	var dataUrl = prototype.$url;
	var itemProto = prototype.$.$resources.$item;
	while (dataUrl) {
		dataUrl = dataUrl.replace("{$baseUrl}", prototype.$baseUrl);
		// get data
		var options = {
				// TODO : implement $search representation
				url: dataUrl,
				method: 'GET',
				headers: {
					"content-type": "application/json; vnd-sage=syracuse",
					cookie: context.httpSession.cookie,
					accept: "application/json"
				}
			};
		var resp = streams.httpRequest(options).end().response(_);
		exports.tracer && exports.tracer("elasticIndex data get status: "+resp.statusCode+"; dataUrl: "+dataUrl);
		if(resp.statusCode != 200) {
			diagnoses && diagnoses.push({severity:"error", message: entityName + " data fetch error"});
			diagnoses && diagnoses.push({severity:"error", message: resp.readAll(_).toString("utf8")});
			return;
		}
		//
		var data = JSON.parse(resp.readAll(_));
		if(!data.$resources || (data.$resources.length == 0))
			return;
		// pagination, get link for next page
		dataUrl = ((data.$links || {}).$next || {}).$url;
	//	console.log("index data: "+sys.inspect(data));
		var options = {
				url: elasticBaseUrl + "/_bulk",
				method: 'PUT'
			};
		var req = streams.httpRequest(options);
		data.$resources.forEach_(_, function(_, item) {
			//
			var action = {
				index: {
					_index: indexName,
					_type: entityName,
					_id: item.$uuid
				}
			}
			//		console.log("indexing: action: "+JSON.stringify(action));
			req.write(_, JSON.stringify(action) + "\n");
			var data = {};
			flows.eachKey(_, itemProto.$, function(_, key, field) {
				var val = null;
				switch(field.$type) {
					case "application/x-reference": 
						val = (item[key] || {}).$value;
						break;
					case "application/x-collection": 
						item[key] && item[key].forEach_(_, function(_, arrayData) {
							arrayData.$value && (val = val || []).push(arrayData.$value);
						});
						break;
					default:
						val = item[key];
						break;
				}
				//
				if(val) {
					data[key] = val;
					// TODO: facets!!!
				}
			});
	//		data.$title = item.$title;
			data.$description = _getDescription(_, indexName, entityName, item, itemProto.$);
			console.log("indexing: data: "+JSON.stringify(data));
			req.write(_, JSON.stringify(data) + "\n");
		});
		var resp = req.end().response(_);
		//
		_processElasticResp(_, resp, context.response, diagnoses, entityName+" records updated");
	}
}

function _updateDatasetIndex(_, context, contract, endpoint, entityName, diagnoses) {
	var model = dataModel.make(contract, endpoint.dataset(_));
	var db = dataModel.getOrm(_, model, contract.datasets[endpoint.dataset(_)]);
	var indexName = endpoint.getIndexName(_);
	//
	_indexCreate(_, context, indexName, diagnoses);
	// 
	if (entityName) _updateEntityIndex(_, context, indexName, contract, model.getEntity(entityName), db, diagnoses);
	else flows.eachKey(_, contract.entities, function(_, key, entity) {
		if (entity.$searchIndex && entity.$searchIndex.$fields) _updateEntityIndex(_, context, indexName, contract, model.getEntity(key), db, diagnoses);
	});
}

function _updateIndex(_, context, contract, endpoint, entityName, diagnoses) {
	_updateDatasetIndex(_, context, contract, endpoint, entityName, diagnoses);
/*	if (datasetName) _updateDatasetIndex(_, context, contract, contract.datasets[datasetName], entityName, diagnoses);
	else flows.eachKey(_, contract.datasets, function(_, dkey, dataset) {
		_updateDatasetIndex(_, context, contract, dataset, entityName, diagnoses);
	});
	*/
}

function _restUpdateIndex(_, context, indexName, baseUrl, entityName, diagnoses) {
	var shortIndexName = _shortIndexName(indexName);
	if(!indexMeta.index[shortIndexName]) return;
	var entityNames = Object.keys(indexMeta.index[shortIndexName].entities);
	//
	_indexCreate(_, context, indexName, diagnoses);
	//
	if(Array.isArray(entityNames))
		entityNames.forEach_(_, function(_, name) {
			_restUpdateEntityIndex(_, context, indexName, baseUrl, name, diagnoses);
		});
	else
		_restUpdateEntityIndex(_, context, indexName, baseUrl, entityNames, diagnoses);
}

exports.updateEndpointIndex = function(_, context, endpoint, entityName, diagnoses) {
	var contract = sdataRegistry.getContract(endpoint.application(_), endpoint.contract(_));
	//
	if(contract)
		_updateIndex(_, context, contract, endpoint, entityName, diagnoses);
	else
		_restUpdateIndex(_, context, endpoint.getIndexName(_), "http://"+context.request.headers.host+endpoint.getBaseUrl(_), entityName, diagnoses);
}

exports.updateIndex = function(_, context, contractName, applicationName, datasetName, entityName, diagnoses) {
/*	if (contractName && applicationName) _updateIndex(_, context, sdataRegistry.getContract(applicationName, contractName, true), datasetName, entityName, diagnoses);
	else flows.eachKey(_, sdataRegistry.applications, function(_, akey, application) {
		flows.eachKey(_, application.contracts, function(_, ckey, contract) {
			_updateIndex(_, context, contract, null, entityName, diagnoses);
		});
	});
	*/
}

exports.deleteEndpointIndex = function(_, context, endpoint, entityName, diagnoses) {
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	var options = {
		url: elasticBaseUrl + "/" + endpoint.getIndexName(_),
		method: "DELETE"
	};
	var req = streams.httpRequest(options);
	var resp = req.end().response(_);
	//
	_processElasticResp(_, resp, context.response, diagnoses, "index deleted");
}

exports.deleteIndex = function(_, context, contractName, applicationName, datasetName, entityName, diagnoses) {
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	var options = {
		url: elasticBaseUrl + "/" + applicationName + "." + contractName + "." + datasetName,
		method: "DELETE"
	};
	var req = streams.httpRequest(options);
	var resp = req.end().response(_);
	//
	_processElasticResp(_, resp, context.response, diagnoses, "index deleted");
}