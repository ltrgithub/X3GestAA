"use strict";

var sdataRegistry = require("syracuse-sdata/lib/sdataRegistry");
var flows = require('streamline/lib/util/flows');
var helpers = require('syracuse-core/lib/helpers')
var forEachKey = helpers.object.forEachKey;
var dataModel = require("syracuse-orm/lib/dataModel");
var http = require("http");
var streams = require("streamline/lib/streams/streams");
var resourceHelpers = require("syracuse-core/lib/resource/util");
var resourceProxy = require("syracuse-core/lib/resource/resourceProxy");
var indexMeta = require("syracuse-search/lib/indexMeta");
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var datetime = require("syracuse-core/lib/types/datetime");
var locale = require("syracuse-core/lib/locale");
var sys = require("util");

exports.tracer = null;
//exports.tracer = console.log;
exports.serverConfig = null;


function _createInstanceIndexResource(_, instance, endpoint, options) {
	function decodeTemplate(_, inst, templ) {
		if (!templ) return;
		var template = templ;
		if(typeof templ === "string")
			template = new resourceProxy.Template(templ);
		var res = template.expression;
		template.matches.forEach_(_, function(_, match) {
			var prop = match.substring(1, match.length - 1);
			if (inst._meta.$properties[prop]) res = res.replace(match, resourceHelpers.formatValue(inst._meta.$properties[prop], inst[prop](_)) || "");
			else if (inst._meta.$relations[prop]) {
				if (inst._meta.$relations[prop].isPlural) res = res.replace(match, inst[prop](_).toArray(_).map_(_, function(_, elem) {
					return decodeTemplate(_, elem, inst._meta.$relations[prop].targetEntity.$valueTemplate);
				}).join(","));
				else res = res.replace(match, decodeTemplate(_, inst[prop](_), inst._meta.$relations[prop].targetEntity.$valueTemplate));
			}
		});
		return res;
	}
	options && options.tracer && options.tracer("ElasticIndex.createResource: enter: " + instance.$uuid);
	var entity = instance.getEntity();
	var facets = entity.getSearchFacets(_);
	var inst = instance;
	var data = {};
	(entity.getSearchFields(_) || []).forEach_(_, function(_, field) {
		var val = null;
		if (entity.$properties[field]) {
			val = resourceHelpers.formatValue(entity.$properties[field], inst[field](_));
		} else if (entity.$relations[field]) {
			var rel = entity.$relations[field];
			var relData = inst[field](_);
			if (rel.isPlural)
				relData.toArray(_).forEach_(_, function(_, item) {
					(val = val || []).push(decodeTemplate(_, item, rel.targetEntity.$valueTemplate));
				});
			else
				if(relData) 
					val = decodeTemplate(_, relData, rel.targetEntity.$valueTemplate);

		}
		options && options.tracer && options.tracer("ElasticIndex.createResource: compute field: " + field + "; value: " + val);
		//
		if(val) {
			data[field] = val;
			// facets is a structure like 
			// {
			//		classField: ["facet1Name", "facet2Name"]
			// }
			// one field can be part of several facets
			if(facets && facets[field])
				facets[field].forEach(function(f) {
					options && options.tracer && options.tracer("ElasticIndex.createResource: field facet: " + f);
					data["facet_" + f] = val;
				});
		}
	});
	options && options.tracer && options.tracer("ElasticIndex.createResource: compute templates");
	data.$description = decodeTemplate(_, inst, entity.$summaryTemplate || entity.$valueTemplate);
	if(entity.$iconTemplate) data.$icon = decodeTemplate(_, inst, entity.$iconTemplate);
	if(entity.$urlTemplate)
		data.$url = entity.$urlTemplate.resolve({
			$baseUrl: endpoint.getBaseUrl(_),
			$key: instance.computeKey()
		});
	//
	return data;
}

function ElasticIndex(ep) {
	this._endpoint = ep;
}

exports.IndexHelper = helpers.defineClass(ElasticIndex, null, {
	updateInstance: function(_, instance, options) {
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: enter: " + instance._meta.name + "." +instance.$uuid);
		// 
		var self = this;
		var _indexName = self._endpoint.getIndexName(_);
		var elasticBaseUrl = exports.serverConfig.baseUrl;
		var entity = instance.getEntity();
		if(!entity.getSearchFacets(_)) return;
		
		var reqOptions = {
			url: [elasticBaseUrl, _indexName, entity.name, instance.$uuid].join("/"),
			method: 'PUT'
		};
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: url: " + reqOptions.url);
		var req = streams.httpRequest(reqOptions);
		var data = _createInstanceIndexResource(_, instance, self._endpoint, options);
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: index data: " + sys.inspect(data));
		req.write(_, JSON.stringify(data));
		var resp = req.end().response(_);
		//
		var diag = JSON.parse(resp.readAll(_));
		options && options.tracer && options.tracer("ElasticIndex.updateInstance: index response: " + sys.inspect(diag));
		if(options && options.diagnoses) {
			if(diag.ok)
				options.diagnoses.push({severity:"info", message: okMessage});
			else
				if(diag.error)
					options.diagnoses.push({severity:"error", message: diag.error});
		}
	},
	updateEntity: function(_, entity, searchFacets, differential, options) {
		var opt = options || {};
		var diag = opt.diagnoses || [];
		opt.tracer && opt.tracer("ElasticIndex.updateEntity: enter: " + entity.name);
		//
		var self = this;
		var _indexName = self._endpoint.getIndexName(_);
		var elasticBaseUrl = exports.serverConfig.baseUrl;
		var db = self._endpoint.getOrm(_);

		opt.tracer && opt.tracer("ElasticIndex.updateEntity: mapping update");
		// update mapping
		_indexMappingUpdate(_, {}, _indexName, entity.name, searchFacets, diag);
		// update data
		var where = (differential && self._endpoint.lastIndexDate(_) ? {
			jsonWhere: {
				$updDate: {
					$gt: self._endpoint.lastIndexDate(_).toJsDate()
				}
			}
		} : null);
		//
		opt.tracer && opt.tracer("ElasticIndex.updateEntity: fetching data");
		// TEMP: X3 doesn't support cursor yet, for now test cursor creation
		var cursor = db.createCursor(_, entity, where);
		var cnt = 0;
		if(cursor) {
			var inst = cursor.next(_);
			if(inst) {
				var options = {
						url: elasticBaseUrl + "/_bulk",
						method: 'PUT'
					};
				var req = streams.httpRequest(options);
				do {
					//
					var action = {
						index: {
							_index: _indexName,
							_type: entity.name,
							_id: inst.computeKey()
						}
					}
					req.write(_, JSON.stringify(action) + "\n");
					var data = _createInstanceIndexResource(_, inst, self._endpoint, opt);
					opt.tracer && opt.tracer("ElasticIndex.updateEntity: index data: " + sys.inspect(data));
					req.write(_, JSON.stringify(data) + "\n");
					cnt++;
					inst = cursor.next(_);
				} while(inst)
				var resp = req.end().response(_);
				//
				_processElasticResp(_, resp, null, diag, entity.name+" records updated");
			}
		} else {
			var insts = db.fetchInstances(_, entity, where);
			if(insts && insts.length) {
				var options = {
						url: elasticBaseUrl + "/_bulk",
						method: 'PUT'
					};
				var req = streams.httpRequest(options);
				insts.forEach_(_, function(_, inst) {
					//
					var action = {
						index: {
							_index: _indexName,
							_type: entity.name,
							_id: inst.computeKey()
						}
					}
					req.write(_, JSON.stringify(action) + "\n");
					var data = _createInstanceIndexResource(_, inst, self._endpoint, opt);
					opt.tracer && opt.tracer("ElasticIndex.updateEntity: index data: " + sys.inspect(data));
					req.write(_, JSON.stringify(data) + "\n");
				});
				var resp = req.end().response(_);
				//
				_processElasticResp(_, resp, null, diag, entity.name+" records updated");
			}
		}
		diag && diag.push({
			severity: "info",
			message: locale.format(module, "updateCount", cnt, entity.name)
		})
	},
	updateIndex: function(_, differential, options) {
		var opt = options || {};
		opt.tracer && opt.tracer("ElasticIndex.updateIndex enter");
		var self = this;
		var model = self._endpoint.getModel(_);
		var indexTime = datetime.now();
		var entities = model.getIndexedEntities(_);
		var facets = model.getSearchFacets(_);
		console.log("facets: "+sys.inspect(facets))
		//
		opt.tracer && opt.tracer("ElasticIndex.updateIndex creating index");
		_indexCreate(_, null, self._endpoint.getIndexName(_), opt);
		// 
		entities.forEach_(_, function(_, entity) {
			self.updateEntity(_, entity, facets, differential, opt);
		});
		//
		self._endpoint.lastIndexDate(_, indexTime);
		self._endpoint.save(_);
	}
});


function _shortIndexName(indexName) {
	return indexName.split(".").slice(-3).slice(0, 2).join(".");
}

function _processElasticResp(_, elasticResp, contextResp, diagnoses, okMessage) {
	if(diagnoses) {
		var diag = JSON.parse(elasticResp.readAll(_));
		if(diag.ok)
			diagnoses.push({severity:"info", message: okMessage});
		else
			if(diag.error)
				diagnoses.push({severity:"error", message: diag.error});
	} else {
		var buffer;
		while(buffer = elasticResp.read(_)) contextResp.write(_, buffer);
	}
}

function _addFacetFieldsMapping(searchFacets, entityName, mapping) {
	if(!searchFacets) return;
	forEachKey(searchFacets, function(key, facet) {
		if(facet.$fields && facet.$fields[entityName])
			mapping[entityName].properties["facet_"+key] = {
				type: "string",
				analyzer: "keyword"
			};
	});
}

function _indexMappingUpdate(_, context, indexName, entityName, searchFacets, diagnoses) {
	var mapping = {};
	mapping[entityName] = {
		properties: {}
	};
	mapping[entityName].properties.$description = {
		type: "string",
		index: "no",
		include_in_all: false
	};
	mapping[entityName].properties.$title = {
			type: "string",
			index: "no",
			include_in_all: false
	};
	mapping[entityName].properties.$icon = {
			type: "string",
			index: "no",
			include_in_all: false
	};
	mapping[entityName].properties.$url = {
			type: "string",
			index: "no",
			include_in_all: false
	};
	_addFacetFieldsMapping(searchFacets, entityName, mapping);
//	console.log("fields mapping "+entityName+"; "+sys.inspect(searchFacets)+"; "+sys.inspect(mapping));
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	var options = {
		url: elasticBaseUrl + "/" + indexName + "/" + entityName + "/_mapping",
		method: 'PUT'
	};
	var req = streams.httpRequest(options);
	req.write(_, JSON.stringify(mapping));
	var resp = req.end().response(_);
	exports.tracer && exports.tracer("elasticIndex.index exists status: " + resp.statusCode + "; entity: " + entityName);
	//
	_processElasticResp(_, resp, context.response, diagnoses, entityName+" mapping updated");
}

function _indexCreate(_, context, indexName, options) {
	var opt = options || {};
	var diagnoses = opt.diagnoses;
	// check if index exists
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	var par = {
			url: elasticBaseUrl + "/" + indexName,
			method: 'HEAD'
		};
	opt.tracer && opt.tracer("elasticIndex.index indexCreate: url: " + par.url);
	var resp = streams.httpRequest(par).end().response(_);
	opt.tracer && opt.tracer("elasticIndex.index exists status(updateDataset): "+resp.statusCode);
	if(resp.statusCode == 404) {
		// create index
		var reqUrl = elasticBaseUrl + "/" + indexName;
		var par = {
				url: reqUrl,
				method: 'PUT'
			};
		var resp = streams.httpRequest(par).end().response(_);
		opt.tracer && opt.tracer("elasticIndex.index put settings status: "+resp.statusCode);
		//
		_processElasticResp(_, resp, context && context.response, diagnoses, "index created");
	}
}

function _getDescription(_, indexName, type, item, prototype) {
	var descTemplate = indexMeta.index[_shortIndexName(indexName)] && indexMeta.index[_shortIndexName(indexName)].entities[type] 
		&& indexMeta.index[_shortIndexName(indexName)].entities[type].$resources.$item.$description;
	if(!descTemplate) return (item.$description || item.$value);
	var template = new resourceProxy.Template(descTemplate);
	var res = template.expression;
	(template.matches || []).forEach(function(match) {
		var prop = match.substring(1, match.length-1);
		var val;
		if(prototype[prop]) {
			switch(prototype[prop].$type) {
				case "application/x-choice":
					val = ((((prototype[prop].$value.$constraints || {}).$enum || []).filter(function(enumItem) {return enumItem.$value === item[prop]}) || [])[0] || {}).$title;
					break;
				default:
					val = item[prop];
			}
		} else
			val = item[prop];
		res = res.replace(match, val);
	});
	return res;
}

function _restUpdateEntityIndex(_, context, indexName, baseUrl, entityName, diagnoses) {
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	// update mapping
	_indexMappingUpdate(_, context, indexName, entityName, {}, diagnoses);
	// get prototype
	var options = {
			// TODO : implement $search representation
			url: baseUrl + "/$prototypes('" + entityName + ".$query')",
			method: 'GET',
			headers: {
				"content-type": "application/json",
				cookie: context.httpSession.cookie,
				accept: "application/json"
			}
		};
	exports.tracer && exports.tracer("elasticIndex prototype get url: "+options.url);
	var resp = streams.httpRequest(options).end().response(_);
	exports.tracer && exports.tracer("elasticIndex prototype get status: "+resp.statusCode+"; baseUrl: "+baseUrl);
	if(resp.statusCode != 200) {
		diagnoses && diagnoses.push({severity:"error", message: entityName + " prototype not found"});
		diagnoses && diagnoses.push({severity:"error", message: resp.readAll(_).toString("utf8")});
		return;
	}
	var prototype = JSON.parse(resp.readAll(_));
	exports.tracer && exports.tracer("elasticIndex prototype: "+sys.inspect(prototype, null, 4));
	var dataUrl = prototype.$url;
	var itemProto = prototype.$.$resources.$item;
	while (dataUrl) {
		dataUrl = dataUrl.replace("{$baseUrl}", prototype.$baseUrl);
		// get data
		var options = {
				// TODO : implement $search representation
				url: dataUrl,
				method: 'GET',
				headers: {
					"content-type": "application/json; vnd-sage=syracuse",
					cookie: context.httpSession.cookie,
					accept: "application/json"
				}
			};
		var resp = streams.httpRequest(options).end().response(_);
		exports.tracer && exports.tracer("elasticIndex data get status: "+resp.statusCode+"; dataUrl: "+dataUrl);
		if(resp.statusCode != 200) {
			diagnoses && diagnoses.push({severity:"error", message: entityName + " data fetch error"});
			diagnoses && diagnoses.push({severity:"error", message: resp.readAll(_).toString("utf8")});
			return;
		}
		//
		var data = JSON.parse(resp.readAll(_));
		if(!data.$resources || (data.$resources.length == 0))
			return;
		// pagination, get link for next page
		dataUrl = ((data.$links || {}).$next || {}).$url;
	//	console.log("index data: "+sys.inspect(data));
		var options = {
				url: elasticBaseUrl + "/_bulk",
				method: 'PUT'
			};
		var req = streams.httpRequest(options);
		data.$resources.forEach_(_, function(_, item) {
			//
			var action = {
				index: {
					_index: indexName,
					_type: entityName,
					_id: item.$uuid
				}
			}
			//		console.log("indexing: action: "+JSON.stringify(action));
			req.write(_, JSON.stringify(action) + "\n");
			var data = {};
			flows.eachKey(_, itemProto.$, function(_, key, field) {
				var val = null;
				switch(field.$type) {
					case "application/x-reference": 
						val = (item[key] || {}).$value;
						break;
					case "application/x-collection": 
						item[key] && item[key].forEach_(_, function(_, arrayData) {
							arrayData.$value && (val = val || []).push(arrayData.$value);
						});
						break;
					default:
						val = item[key];
						break;
				}
				//
				if(val) {
					data[key] = val;
					// TODO: facets!!!
				}
			});
	//		data.$title = item.$title;
			data.$description = _getDescription(_, indexName, entityName, item, itemProto.$);
	//		console.log("indexing: data: "+JSON.stringify(data));
			req.write(_, JSON.stringify(data) + "\n");
		});
		var resp = req.end().response(_);
		//
		_processElasticResp(_, resp, context.response, diagnoses, entityName+" records updated");
	}
}

function _restUpdateIndex(_, context, indexName, baseUrl, entityName, diagnoses) {
	var shortIndexName = _shortIndexName(indexName);
	if(!indexMeta.index[shortIndexName]) return;
	var entityNames = Object.keys(indexMeta.index[shortIndexName].entities);
	//
	_indexCreate(_, context, indexName, {
		diagnoses: diagnoses
	});
	//
	if(Array.isArray(entityNames))
		entityNames.forEach_(_, function(_, name) {
			_restUpdateEntityIndex(_, context, indexName, baseUrl, name, diagnoses);
		});
	else
		_restUpdateEntityIndex(_, context, indexName, baseUrl, entityNames, diagnoses);
}

exports.updateIndex = function(_, context, contractName, applicationName, datasetName, entityName, diagnoses) {
/*	if (contractName && applicationName) _updateIndex(_, context, sdataRegistry.getContract(applicationName, contractName, true), datasetName, entityName, diagnoses);
	else flows.eachKey(_, sdataRegistry.applications, function(_, akey, application) {
		flows.eachKey(_, application.contracts, function(_, ckey, contract) {
			_updateIndex(_, context, contract, null, entityName, diagnoses);
		});
	});
	*/
}

exports.deleteEndpointIndex = function(_, context, endpoint, entityName, diagnoses) {
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	var options = {
		url: elasticBaseUrl + "/" + endpoint.getIndexName(_),
		method: "DELETE"
	};
	var req = streams.httpRequest(options);
	var resp = req.end().response(_);
	//
	_processElasticResp(_, resp, context.response, diagnoses, "index deleted");
}

exports.deleteIndex = function(_, context, contractName, applicationName, datasetName, entityName, diagnoses) {
	var elasticBaseUrl = exports.serverConfig.baseUrl;
	var options = {
		url: elasticBaseUrl + "/" + applicationName + "." + contractName + "." + datasetName,
		method: "DELETE"
	};
	var req = streams.httpRequest(options);
	var resp = req.end().response(_);
	//
	_processElasticResp(_, resp, context.response, diagnoses, "index deleted");
}

exports.registerModelEvents = function(_, config) {
	var admOrm = adminHelpers.AdminHelper.getCollaborationOrm(_);
	var eps = admOrm.fetchInstances(_, admOrm.getEntity(_, "endPoint"), {});
	eps.forEach_(_, function(_, e) {
		// TODO: see later for x3 endpoints, the connect sequence must be properly managed
		if(e.applicationRef(_) && (e.applicationRef(_).protocol(_) != "syracuse")) return;
		//
		var model = e.getModel(_, false);
		model && model.registerEvent("$afterSave", function(_, instance) {
			// index data for search. Call without callback
			var indexer = new ElasticIndex(e);
//			(config = config || {}).tracer = console.log;
			indexer.updateInstance(null, instance, config);
			// TODO: review this _reindexInst thing as is an undesired dependance from factory to search
			flows.eachKey(_, instance._reindexInst, function(_, k, inst) {
				indexer.updateInstance(null, inst, config);
			});
		});
	});
}