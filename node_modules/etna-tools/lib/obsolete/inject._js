"use strict";
// Obsolete utility
// This tool was used to populate a mysql db from schemas generated with the impsql tool.
var fs = require('streamline-fs');
var streams = require("streamline-streams");
var readers = require("streamline-streams/lib/readers");

var t0 = Date.now();
try {
	var root = __dirname + "/../../../../../SUPERV";
	var driver = require('db-mysql');

	var db = new driver.Database({
		hostname: 'localhost',
		user: 'root',
		password: '',
		database: 'SUPERV'
	});
	db.connect(_);

	try {
		db.query().execute('CREATE DATABASE SUPERV', _);
	} catch (ex) {}

	var createTable = function(_, name) {
		//if (name[0] < 'S') return;
		var meta = JSON.parse(fs.readFile(root + "/schema/" + name, "utf8", _));
		console.log("creating table " + meta.name);
		db.query().execute("DROP TABLE IF EXISTS " + meta.name, [], _);
		var sql = "CREATE TABLE " + meta.name + " (";
		sql += Object.keys(meta.columns).map(function(name) {
			var col = meta.columns[name];
			var type = col.type.replace(' BYTE', '').replace('NUMBER', 'DECIMAL').replace('VARCHAR2', 'VARCHAR').replace('RAW', 'BINARY').replace('CLOB', 'TEXT');
			type = type.replace(/TIMESTAMP.*/, "DATETIME");
			//type = type.replace("BLOB", "BINARY");
			type = type.replace(/DECIMAL\(\*,0\)/, "INTEGER");
			return '`' + name + '` ' + type + (col.nullable ? "" : " NOT NULL");
		}).join(',') + ")";
		//console.log(sql);
		db.query().execute(sql, [], _);
	};

	var fillTable = function(_, name) {
		//if (name !== 'ALISTEL.json') return;
		var meta = JSON.parse(fs.readFile(root + "/schema/" + name, "utf8", _));
		var pfx = "inserting into " + meta.name + ": ";

		var fin = new streams.ReadableStream(fs.createReadStream(root + "/data/" + name));
		/*fin.emitter.on('data', function(d) {
				console.log("data event: " + d);
			}).on('error', function(e) {
				console.log("error event: " + e);
			}).on('close', function(v) {
				console.log("close event: " + v);
			})*/
		fin.setEncoding("utf8");
		var rd = new readers.Reader(fin);
		var colNames = Object.keys(meta.columns).filter(function(colName) {
			var col = meta.columns[colName];
			return col.type !== 'BLOB' && col.type !== 'CLOB';
		});
		var sql = "INSERT INTO `" + meta.name + "` (" + colNames.map(function(colName) {
			return '`' + colName + '`';
		}).join(',') + ") VALUES (" + //
		colNames.map(function() {
			return '?';
		}).join(',') + ')';

		db.query().execute("DELETE FROM `" + meta.name + "`", [], _);
		var count = 0;
		var line = rd.readItem(_); //skip first line
		while ((line = rd.readItem(_)) != null && line[line.length - 1] !== ']') {
			//console.log("line=" + line)
			if (count % 10000 === 0) console.log(pfx + count + " ...");
			if (line[line.length - 1] !== ',') throw new Error("bad data line: " + line);
			var data = JSON.parse(line.substring(0, line.length - 1));
			//console.log("data=" + data)
			var args = colNames.map(function(colName) {
				return data[colName];
			});
			//console.log(sql)
			db.query().execute(sql, args, _);
			count++;
		}
		//console.log("line=" + line)
		console.log(pfx + count + " (done)");
	};

	var createIndexes = function(_, name) {
		if (name <= 'ACLOB2.json') return;
		var meta = JSON.parse(fs.readFile(root + "/schema/" + name, "utf8", _));
		console.log("creating indexes for " + meta.name);

		meta.indexes.forEach_(_, function(_, index) {
			try {
				db.query().execute("ALTER IGNORE TABLE `" + meta.name + "` DROP INDEX `" + index.name + "`", [], _);
			} catch (ex) {}
			// disable unique indexes for now
			while (true) {
				try {
					var sql = "CREATE " + (index.unique ? "UNIQUE " : "") + "INDEX `" + index.name + "` ON `" + meta.name + "` (" + index.columns.map(function(col) {
						return "`" + col.substring(1) + "`" + (col[0] === '-' ? " DESC" : "");
					}).join(',') + ")";
					db.query().execute(sql, [], _);
					break;
				} catch (ex) {
					if (index.unique) {
						console.log("creation of unique index failed: " + ex);
						index.unique = false;
					} else throw ex;
				}
			}
		});
	};

	fs.readdir(root + "/schema", _).forEach_(_, createTable);
	fs.readdir(root + "/data", _).forEach_(_, fillTable);
	fs.readdir(root + "/schema", _).forEach_(_, createIndexes);
} catch (ex) {
	console.error(ex.stack || ex);
}
console.log("completed in " + (Date.now() - t0) / 1000 + " s");