"use strict";

var test_ = true;

var SPS_STATUS_OK = "OK"; 
var SPS_STATUS_ERROR = "ERROR"; 
var SPS_STATUS_INVALID = "INVALID"; 

var SPS_WAIT_STATUS_OK = "OK";
var SPS_WAIT_STATUS_WAIT = "WAIT";
var SPS_WAIT_STATUS_INVALID = "INVALID";

var SPS_TIMEOUT_VALUE = 300000; // 5 minutes

exports.$exported = true;
exports.$nonAuth = true;

var httpClient = require('syracuse-httpclient/lib/httpClient');
var	url = require('url');
var globals = require('streamline/lib/globals');
var crypto = require('crypto');

var config = require('config');
var os = require("os");
var fs = require('streamline-fs');

var spsCache = [];
//var notificationIDs = [{'id':'9999'}];
var notificationIDs = [];

exports.httpDispatch = function(_, request, response) {
	var parsed = url.parse(request.url, true);
	var segs = parsed.pathname.split('/');

	if (segs[3] === 'close-sps.html') {
		var html = fs.readFile(__dirname + '/close-sps.html', 'utf8', _);
		response.writeHead(200, {
			'content-type': 'text/html; charset=utf-8',
			'content-length': html.length
		});
		response.end(html, 'utf8');
	    return;
	}

	if (segs[3] !== 'notification') {
		response.writeHead(404, {});
		response.end('invalid URL: ' + request.url, 'utf8');
		return;
	}
	var id = parsed.query.id;
	var i = 0;
	while (i < notificationIDs.length) {
		var redir = notificationIDs[i];
		if (redir.id == id) {
			notificationIDs.splice(i, 1); // remove notification ID
			return notificationResponse(_, request, response);
		} else i++;
	}
	response.writeHead(404, {});
	response.end('Notification URL not found: ' + id, 'utf8');
};

exports.createTokenRequest = function(_, tokenReqJson, registrationOptions) {
	tokenReqJson.NotificationURL = getNotificationPostUrl();

	var spsRawResponse = postToSPS(_, tokenReqJson, registrationOptions);

	if (spsRawResponse) {
		cacheSPSData(_, spsRawResponse, tokenReqJson.Vendor);
	}
	return spsRawResponse;
};

exports.createPaymentRequest = function(_, paymentReqJson, registrationOptions) {
	paymentReqJson.NotificationURL = getNotificationPostUrl(); 

	var spsRawResponse = postToSPS(_, paymentReqJson, registrationOptions);

	if (spsRawResponse) {
		cacheSPSData(_, spsRawResponse, paymentReqJson.Vendor);
	}
	return spsRawResponse;
};

exports.createAbortRequest = function(_, abortReqJson, registrationOptions) {
	return postToSPS(_, abortReqJson, registrationOptions);
};

exports.createRefundRequest = function(_, refundReqJson, registrationOptions) {
	return postToSPS(_, refundReqJson, registrationOptions);
};

exports.createReleaseRequest = function(_, releaseReqJson, registrationOptions) {
	return postToSPS(_, releaseReqJson, registrationOptions);
};

exports.createVoidRequest = function(_, voidReqJson, registrationOptions) {
	return postToSPS(_, voidReqJson, registrationOptions);
};

exports.removeTokenRequest = function(_, removeTokenReqJson, registrationOptions) {
	return postToSPS(_, removeTokenReqJson, registrationOptions);
};

exports.getSPSResponse = function(_, VPSTxId) {

	if (test_) {
		console.log("calling getSPSResponse");
		console.log("calling getSPSResponse with VPSTxId=" + VPSTxId);
	}

	var responseX3;
	var spsData = getSpsCacheData(VPSTxId);
	if (spsData && spsData.WaitStatus) {
		if (spsData.WaitStatus == SPS_WAIT_STATUS_OK) {
			responseX3 = "WaitStatus=" + SPS_WAIT_STATUS_OK + '\r\n';
			responseX3 += "SecurityStatus=" + spsData.SecurityStatus + '\r\n';
			responseX3 += spsData.notificationPostData;

			if (test_) {
				console.log("getSPSResponse return value = " + responseX3);
			}
		} else {
			responseX3 = "WaitStatus=" + spsData.WaitStatus; // WAIT
		}
	} else {
		/*
		 * We've nothing cached for this VPSTxId, so return INVALID
		 */
		 responseX3 = "WaitStatus=" + SPS_WAIT_STATUS_INVALID;
	}

	if (spsData && spsData.WaitStatus !== SPS_WAIT_STATUS_WAIT) {
		deleteFromCache(VPSTxId);
	}

	return responseX3;
};

function postToSPS(_, requestJson, registrationOptions) {
	requestJson.NotificationURL = getNotificationPostUrl(); 

	var requestQueryStr = buildEncodedQueryReq(requestJson);

	if (test_) {
		console.log(requestQueryStr);
	}

  	var options = registrationOptions || {};
	options.url = options.url;
	options.method = options.method || 'POST';
	options.headers = options.headers || {
	    'content-type': 'application/x-www-form-urlencoded',
	    'content-length': requestQueryStr.length,
	};

	var request = httpClient.httpRequest(_, options);
	request.write(_, requestQueryStr, 'utf8');

	var response = request.end().response(_);
	if (response.statusCode != 200) {
		if (test_) {
			console.log(response.statusCode + ': ' + response.readAll(_));
			console.log(response.headers);
		}
		return null;
	} else {
		/*
		 * Encoding is as Name=Value pairs separated by carriage return and linefeeds (CRLF).
		 * We'll pass it directly to X3 in this format.
		 */
		var rawResponse = response.readAll(_);
		if (test_) {
			console.log ("rawResponse: " + rawResponse);
		}
		return rawResponse;
	}
}

function cacheSPSData(_, rawResponse, vendorName) {
	var values = {};
	rawResponse.split('\r\n').map(function(element) {
		var separatorPos = element.indexOf('=');
		if (separatorPos >= 0) {
			values[element.substring(0,separatorPos)] = element.substring(separatorPos+1);
		}
	});

	if (values.Status === SPS_STATUS_OK) {
		var VPSTxId = values.VPSTxId.replace(/{/g, '').replace(/}/g, '');// remove the outer {}
		var cacheValue = { 	'VPSTxId': VPSTxId,
							'VendorName': vendorName,
							'SecurityKey': values.SecurityKey || "", 
							'NextURL': values.NextURL || "",
							'WaitStatus': SPS_WAIT_STATUS_WAIT };

		cacheValue.timeout = function (VPSTxId) {
			/*
			 * Setup a timer that will clear the cache entry for this VPSTxID after the specified timeout
			 */
			 deleteFromCache(VPSTxId);
		};

		setTimeout.call(cacheValue, cacheValue.timeout, SPS_TIMEOUT_VALUE, VPSTxId);

		spsCache.push(cacheValue);

		if (test_) {
			Object.keys(cacheValue).map(function(key){
				console.log("cache value: " + key + " = " + cacheValue[key]);
			});
		}
	}
}

function notificationResponse(_, request, response) {
	var requestRaw = request.readAll(_).toString();
	var requestJson = {};
	requestRaw.split('&').map(function(element) {
		var nvp = element.split('=');
		requestJson[nvp[0]] = nvp[1];
	});

	if (test_) {
		console.log("notificationResponse.requestRaw = " + requestRaw);
	}

 	var spsResponseJson = replyToSPSResponse(_, request, requestJson, response);

 	/*
 	 * We've responded to SPS, so cache our notification POST request to the SPS cache.
 	 */
 	 if (spsCache && requestJson.VPSTxId) {

		requestJson.VPSTxId = decodeURIComponent(requestJson.VPSTxId).replace(/{/g, '').replace(/}/g, '');

 		for (var ii = 0, jj = spsCache.length; ii < jj; ii++) {
			if (spsCache[ii].VPSTxId == requestJson.VPSTxId) {
				var spsData = spsCache[ii];
				/*
				 * We don't want to return to X3 the raw response from SPS due to URL encoding of the token.
				 * So, rebuild the response without the encoding.
				 */
				requestJson.Token = decodeURIComponent(requestJson.Token);
				spsData.notificationPostData = buildDecodedQueryReq(requestJson);
				// spsData.notificationPostData = requestRaw;

				if (spsResponseJson.Status == SPS_STATUS_OK && requestJson.Status == SPS_STATUS_OK) {
					/*
					 * The MD5 and the notification POST status are both OK - success!
					 */
					spsData.WaitStatus = SPS_WAIT_STATUS_OK; 
				} else {
					spsData.WaitStatus = SPS_WAIT_STATUS_INVALID;
				}

				/*
				 * Set the SecurityStatus status to reflect the MD5 check
				 */
				spsData.SecurityStatus = spsResponseJson.Status;
				break;
			}
		}
 	 }
}

function replyToSPSResponse(_, request, requestJson, response) {
	/*
	 * get the content from the POST
	 */
	var postValidationJson = validateNotificationPost(_, requestJson);

	if (test_) {
		console.log("replyToSPSResponse.postValidationJson = " + JSON.stringify(postValidationJson));
	}

	var host = getHost();

	var responseJson = {
		'Status': postValidationJson.Status,
		'RedirectURL': host + '/bundles-non-auth/sage-pay/close-sps.html',
		'StatusDetail': postValidationJson.StatusDetail
	};
	
	/*
	 * Encoding must be as Name=Value fields separated by carriage-return line feeds (CRLF).
	 */
	response.writeHead(200, {
		'content-type': 'text/plain; charset=utf-8'
	});
	response.end(buildSPSResponse(responseJson), 'utf8');

	return responseJson;
}

function validateNotificationPost(_, reqJson) {
	/*
	 * A response status of OK should be sent in ALL circumstances where NO ERRORS occur in validating the Notification POST.
	 * So even if SPS sends a Status of ABORT or NOTAUTHED, we should reply with an OK Status and a RedirectURL 
	 * that points to a page informing the customer that the transaction did not complete.
	 */
	var validationJson = {};
	var spsData;
	if (reqJson && reqJson.VPSTxId) {
		if (test_) {
			console.log ("validateNotificationPost.reqJson.VPSTxId = " + reqJson.VPSTxId);
		}
		spsData = getSpsCacheData(decodeURIComponent(reqJson.VPSTxId).replace(/{/g, '').replace(/}/g, ''));// remove the outer {}; // could happen if the timeout has been reached and deleted the cache entry

		if (test_) {
			console.log ("validateNotificationPost.reqJson = " + JSON.stringify(reqJson));
		}
	}

 	if (spsData && reqJson.Status) {
 		var isValidMD5 = validateMD5(_, 
 				reqJson,
 				spsData);

 		if (test_){
			console.log("validateNotificationPost.isValidMD5 = " + isValidMD5);
		}

		if (isValidMD5) {
			validationJson.Status = SPS_STATUS_OK;
			validationJson.StatusDetail = "OK";
		} else {
			if (test_){
				console.log("validateNotificationPost.reqJson.VPSSignature = " + reqJson.VPSSignature);
				console.log("validateNotificationPost.reqJson.VPSTxId = " + reqJson.VPSTxId);
				console.log("validateNotificationPost.reqJson.VendorTxCode = " + reqJson.VendorTxCode);
				console.log("validateNotificationPost.reqJson.Status = " + reqJson.Status);
				console.log("validateNotificationPost.spsData.VendorName = " + spsData.VendorName);
				console.log("validateNotificationPost.reqJson.Token = " + decodeURIComponent(reqJson.Token));
				console.log("validateNotificationPost.spsData.SecurityKey = " + spsData.SecurityKey);
			}
			
			/*
			 * INVALID = Send this if the details received in the notification post were not consistent with expectations for this
			 * transaction. The RedirectURL must still be provided, and Sage Pay will still redirect the customer back to your
			 * site. This response status will cancel the transaction on SPS.
			 */
			validationJson.Status = SPS_STATUS_INVALID;
			validationJson.StatusDetail = "MD5 does not match VPSSignature";
		}
	} else {
		/*
		 * ERROR = An error has occurred during your Notification processing. The Sage Pay system will check for a
		 * RedirectURL, and if one is provided the customer will be redirected to your site. Only send this result if you
		 * want to cancel the transaction and report an ERROR to Sage Pay.
		 */
		 validationJson.Status = SPS_STATUS_ERROR;
		 validationJson.StatusDetail = "Notification Processing error - no status received";
	}
	return validationJson;
}

function validateMD5(_,  reqJson, spsData) { 
	var rawConcatenation;
	if (reqJson.TxType == "TOKEN") {
		/*
		 * VPSSignature - MD5 signature of the concatenation of the values of: 
		 *
		 * VPSTxId + VendorTxCode + Status + VendorName + { Token} + SecurityKey
		 */
		rawConcatenation = 		reqJson.VPSTxId + 
		 						reqJson.VendorTxCode + 
		 						reqJson.Status + 
		 						spsData.VendorName.toLowerCase() + 
		 						decodeURIComponent(reqJson.Token) + 
		 						spsData.SecurityKey;
	} else { // PAYMENT, DEFERRED...
		/*
		 * VPSSignature - MD5 signature of the concatenation of the values of: 
		 *
		 * {VPSTxId}+ VendorTxCode + Status + TxAuthNo + VendorName + AVSCV2 + 
		 * SecurityKey + AddressResult + PostCodeResult + CV2Result + GiftAid + 
		 * 3DSecureStatus + CAVV + AddressStatus + PayerStatus + CardType + 
		 * Last4Digits + DeclineCode + ExpiryDate + FraudResponse + BankAuthCode
		 */		
		rawConcatenation = 		reqJson.VPSTxId +			
								reqJson.VendorTxCode +
		 						reqJson.Status +
		 						reqJson.TxAuthNo +
		 						spsData.VendorName.toLowerCase() +
		 						(reqJson.AVSCV2 || "") +
		 						spsData.SecurityKey +
		 						(reqJson.AddressResult || "") +
		 						(reqJson.PostCodeResult || "") +
		 						(reqJson.CV2Result || "") +
		 						(reqJson.GiftAid || "") +
		 						(reqJson["3DSecureStatus"] || "") +
								(reqJson.CAVV || "") +
								(reqJson.AddressStatus || "") +
		 						(reqJson.PayerStatus || "") +
		 						(reqJson.CardType || "") +
		 						(reqJson.Last4Digits || "") +
		 						(reqJson.DeclineCode || "") +
		 						(reqJson.ExpiryDate || "") +
		 						(reqJson.FraudResponse || "") +
		 						(reqJson.BankAuthCode || "");
	}

	rawConcatenation = decodeURIComponent(rawConcatenation).replace(/\+/g, ' ');

	var hashMD5 = crypto.createHash('md5').update(rawConcatenation).digest('hex').toUpperCase();

	if (test_) {
		console.log("MD5 hash of " + rawConcatenation + " = " + hashMD5);
	}

	return hashMD5 && (hashMD5 === reqJson.VPSSignature);
}

function getNotificationPostUrl() {
	var id = require('syracuse-core/lib/uuid').generate('');
	notificationIDs.push({
		id: id
	});

	var host = getHost();
	var redirUrl;
	if (test_) {
		redirUrl = host + '/bundles-non-auth/sage-pay/notification?id=' + id; 
		//redirUrl = host + 'http://54.148.78.219'/bundles-non-auth/sage-pay/notification?id=' + 9999;
	} else {
		redirUrl = host + '/bundles-non-auth/sage-pay/notification?id=' + id;
	}
	return redirUrl;
}

function getSpsCacheData(VPSTxId) {
	if (spsCache && spsCache.length > 0) {
		for (var ii = 0, jj = spsCache.length; ii < jj; ii++) {
			if (spsCache[ii].VPSTxId == VPSTxId) {
				if (test_) {
					console.log("getSPSResponse.spsCache.VPSTxId=" + spsCache[ii].VPSTxId);
					console.log("getSPSResponse.spsCache.VendorName=" + spsCache[ii].VendorName);
					console.log("getSPSResponse.spsCache.SecurityKey=" + spsCache[ii].SecurityKey);
					console.log("getSPSResponse.spsCache.NextURL=" + spsCache[ii].NextURL);
					console.log("getSPSResponse.spsCache.WaitStatus=" + spsCache[ii].WaitStatus);
				}
				return spsCache[ii];
			}
		}
	}
	return null;
}

function deleteFromCache(VPSTxId) {
	if (spsCache && VPSTxId) {
		for (var ii = 0, jj = spsCache.length; ii < jj; ii++) {
			if (spsCache[ii].VPSTxId == VPSTxId) {
				if (test_) {
					console.log("Deleting cache for VPSTxId: " + VPSTxId);
				}
				spsCache.splice(ii, 1);
				break;
			}
		}
	}
}

function getHost() {
	var host = globals.context.session && globals.context.session.host;
	if (!host) {
		if (test_)
			host = 'http://54.148.78.219';
		else
			host = "http://" + os.hostname().toLowerCase() + ":" + config.port;
	}
	return host;
}

function buildEncodedQueryReq(values) {
	return Object.keys(values).map(function(key){ 
  		return encodeURIComponent(key) + '=' + encodeURIComponent(values[key]); 
	}).join('&');
}

function buildDecodedQueryReq(values) {
	return Object.keys(values).map(function(key){ 	
  		return key + '=' + decodeURIComponent(values[key]); 
	}).join('\r\n');
}

function buildSPSResponse(values) {
	return Object.keys(values).map(function(key){ 
  		return key + '=' + values[key]; 
	}).join('\r\n');
}