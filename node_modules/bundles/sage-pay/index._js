"use strict";

var SPS_STATUS_OK = "OK";
var SPS_STATUS_ERROR = "ERROR";
var SPS_STATUS_INVALID = "INVALID";

var SPS_STATUS_NOTAUTHED = "NOTAUTHED";
var SPS_STATUS_PENDING = "PENDING";
var SPS_STATUS_ABORT = "ABORT";
var SPS_STATUS_REJECTED = "REJECTED";
var SPS_STATUS_AUTHENTICATED = "AUTHENTICATED";
var SPS_STATUS_REGISTERED = "REGISTERED";

var SPS_WAIT_STATUS_OK = "OK";
var SPS_WAIT_STATUS_WAIT = "WAIT";
var SPS_WAIT_STATUS_INVALID = "INVALID";

var SPS_TIMEOUT_VALUE = 300000; // 5 minutes

exports.$exported = true;
exports.$nonAuth = true;

var httpClient = require('@sage/syracuse-lib/src/http-client/httpClient');
var url = require('url');
var globals = require('streamline-runtime').globals;
var crypto = require('crypto');
var tracer = require('@sage/syracuse-core').getTracer('sagePay');
var adminHelper = require("@sage/syracuse-lib/src/collaboration/helpers").AdminHelper;
var config = require('config');
var os = require("os");
var fs = require('streamline-fs');
var host_; // We need this, as the usual host in not available in the dispatcher's session during the callback from SPS

exports.httpDispatch = function(_, request, response) {
	var parsed = url.parse(request.url, true);
	var segs = parsed.pathname.split('/');

	if (segs[3] === 'close-sps.html') {
		var html = fs.readFile(__dirname + '/close-sps.html', 'utf8', _);
		response.writeHead(200, {
			'content-type': 'text/html; charset=utf-8',
			'content-length': html.length
		});
		response.end(html, 'utf8');
		return;
	}

	if (segs[3] !== 'notification') {
		response.writeHead(404, {});
		response.end('invalid URL: ' + request.url, 'utf8');
		return;
	}
	var id = parsed.query.id;

	var notification = _getSagePaySessionData(_, {
		sid: id
	});
	if (notification) {
		return _notificationResponse(_, request, response);
	}

	response.writeHead(404, {});

	response.end('Notification URL not found', 'utf8');
};

exports.createTokenRequest = function(_, tokenReqJson, registrationOptions) {

	var notificationItem = _getNotificationPostItem();
	tokenReqJson.NotificationURL = notificationItem.url;

	var spsRawResponse = _postToSPS(_, tokenReqJson, registrationOptions);

	if (spsRawResponse) {
		_storeSagePaySessionData(_, notificationItem.sid, notificationItem.host, spsRawResponse, tokenReqJson.Vendor, registrationOptions.timeout || SPS_TIMEOUT_VALUE);
	}
	return spsRawResponse;
};

exports.createPaymentRequest = function(_, paymentReqJson, registrationOptions) {

	var notificationItem = _getNotificationPostItem();
	paymentReqJson.NotificationURL = notificationItem.url;

	var spsRawResponse = _postToSPS(_, paymentReqJson, registrationOptions);

	if (spsRawResponse) {
		_storeSagePaySessionData(_, notificationItem.sid, notificationItem.host, spsRawResponse, paymentReqJson.Vendor, registrationOptions.timeout || SPS_TIMEOUT_VALUE);
	}
	return spsRawResponse;
};

exports.createAbortRequest = function(_, abortReqJson, registrationOptions) {
	return _postToSPS(_, abortReqJson, registrationOptions);
};

exports.createRefundRequest = function(_, refundReqJson, registrationOptions) {
	return _postToSPS(_, refundReqJson, registrationOptions);
};

exports.createReleaseRequest = function(_, releaseReqJson, registrationOptions) {
	return _postToSPS(_, releaseReqJson, registrationOptions);
};

exports.createVoidRequest = function(_, voidReqJson, registrationOptions) {
	return _postToSPS(_, voidReqJson, registrationOptions);
};

exports.removeTokenRequest = function(_, removeTokenReqJson, registrationOptions) {
	return _postToSPS(_, removeTokenReqJson, registrationOptions);
};

exports.getSPSResponse = function(_, VPSTxId) {

	tracer.debug && tracer.debug("calling getSPSResponse");

	var responseX3;
	var spsData = _getSagePaySessionData(_, {
		vpsTxId: VPSTxId
	});
	var waitStatus = spsData.waitStatus(_);
	if (spsData && waitStatus) {
		if (waitStatus === SPS_WAIT_STATUS_OK || waitStatus === SPS_WAIT_STATUS_INVALID) {
			responseX3 = "WaitStatus=" + waitStatus + '\r\n';
			responseX3 += "SecurityStatus=" + spsData.securityStatus(_) + '\r\n';
			responseX3 += spsData.notificationPostData(_);
		} else {
			responseX3 = "WaitStatus=" + spsData.waitStatus(_); // WAIT
		}
	} else {
		/*
		 * We've nothing cached for this VPSTxId - most likey due to a timeout.
		 * So just return INVALID and a blank SecurityStatus.
		 */
		responseX3 = "WaitStatus=" + SPS_WAIT_STATUS_INVALID + '\r\n';
		responseX3 += "SecurityStatus=";
	}

	if (spsData && waitStatus !== SPS_WAIT_STATUS_WAIT) {
		tracer.debug && tracer.debug("Deleting SagePay session: " + VPSTxId);
		_deleteSagePaySessionData(_, VPSTxId);
	}

	return responseX3;
};

function _postToSPS(_, requestJson, registrationOptions) {

	var requestQueryStr = _buildEncodedQueryReq(requestJson);

	var options = registrationOptions || {};
	options.url = options.url;
	options.method = options.method || 'POST';
	options.headers = options.headers || {
		'content-type': 'application/x-www-form-urlencoded',
		'content-length': requestQueryStr.length,
	};

	var request = httpClient.httpRequest(_, options);
	request.write(_, requestQueryStr, 'utf8');

	var response = request.end().response(_);
	if (response.statusCode != 200) {
		tracer.error && tracer.error(response.statusCode + ': ' + response.readAll(_));
		tracer.error && tracer.error(response.headers);
		return null;
	} else {
		/*
		 * Encoding is as Name=Value pairs separated by carriage return and linefeeds (CRLF).
		 * We'll pass it directly to X3 in this format.
		 */
		var rawResponse = response.readAll(_);
		return rawResponse;
	}
}

function _notificationResponse(_, request, response) {
	var requestRaw = request.readAll(_).toString();
	var requestJson = {};
	requestRaw.split('&').map(function(element) {
		var nvp = element.split('=');
		requestJson[nvp[0]] = nvp[1];
	});

	requestJson.VPSTxId = decodeURIComponent(requestJson.VPSTxId).replace(/{/g, '').replace(/}/g, '');
	var spsData = _getSagePaySessionData(_, {
		vpsTxId: requestJson.VPSTxId
	});

	requestJson.StatusDetail = decodeURIComponent(requestJson.StatusDetail).replace(/\+/g, ' '); // make the detail readable in X3

	var spsResponseJson = _replyToSPSResponse(_, request, requestJson, response, spsData);

	/*
	 * We've responded to SPS, so cache our notification POST request to the SPS cache.
	 */
	if (spsData) {
		/*
		 * We don't want to return to X3 the raw response from SPS due to URL encoding of the token.
		 * So, rebuild the response without the encoding.
		 */
		requestJson.Token = decodeURIComponent(requestJson.Token);
		spsData.notificationPostData(_, _buildDecodedQueryReq(requestJson));

		if (spsResponseJson.Status === SPS_STATUS_OK && requestJson.Status && [SPS_STATUS_OK,
				SPS_STATUS_NOTAUTHED,
				SPS_STATUS_PENDING,
				SPS_STATUS_ABORT,
				SPS_STATUS_REJECTED,
				SPS_STATUS_AUTHENTICATED,
				SPS_STATUS_REGISTERED,
				SPS_STATUS_ERROR
			].indexOf(requestJson.Status) > -1) {

			/*
			 * The MD5 and the notification POST status are both OK - success!
			 */
			spsData.waitStatus(_, SPS_WAIT_STATUS_OK);
		} else {
			spsData.waitStatus(_, SPS_WAIT_STATUS_INVALID);
		}

		/*
		 * Set the SecurityStatus status to reflect the MD5 check
		 */

		spsData.securityStatus(_, spsResponseJson.Status);
		spsData.save(_);

	}

}

function _replyToSPSResponse(_, request, requestJson, response, spsData) {
	/*
	 * get the content from the POST
	 */
	var postValidationJson = _validateNotificationPost(_, requestJson, spsData);

	var responseJson = {
		'Status': postValidationJson.Status,
		'StatusDetail': postValidationJson.StatusDetail
	};

	if (spsData) {
		responseJson.RedirectURL = spsData.host(_) + '/bundles-non-auth/sage-pay/close-sps.html';
	}

	/*
	 * Encoding must be as Name=Value fields separated by carriage-return line feeds (CRLF).
	 */
	response.writeHead(200, {
		'content-type': 'text/plain; charset=utf-8'
	});
	response.end(_buildSPSResponse(responseJson), 'utf8');

	return responseJson;
}

function _validateNotificationPost(_, reqJson, spsData) {
	/*
	 * A response status of OK should be sent in ALL circumstances where NO ERRORS occur in validating the Notification POST.
	 * So even if SPS sends a Status of ABORT or NOTAUTHED, we should reply with an OK Status and a RedirectURL 
	 * that points to a page informing the customer that the transaction did not complete.
	 */
	var validationJson = {};

	if (spsData && reqJson.Status) {
		var isValidMD5 = _validateMD5(_,
			reqJson,
			spsData);

		tracer.debug && tracer.debug("_validateNotificationPost.isValidMD5 = " + isValidMD5);

		if (isValidMD5) {
			validationJson.Status = SPS_STATUS_OK;
			validationJson.StatusDetail = "OK";
		} else {
			tracer.error && tracer.error("MD5 validation failed");

			/*
			 * INVALID = Send this if the details received in the notification post were not consistent with expectations for this
			 * transaction. The RedirectURL must still be provided, and Sage Pay will still redirect the customer back to your
			 * site. This response status will cancel the transaction on SPS.
			 */
			validationJson.Status = SPS_STATUS_INVALID;
			validationJson.StatusDetail = "MD5 does not match VPSSignature";
		}
	} else {
		/*
		 * ERROR = An error has occurred during your Notification processing. The Sage Pay system will check for a
		 * RedirectURL, and if one is provided the customer will be redirected to your site. Only send this result if you
		 * want to cancel the transaction and report an ERROR to Sage Pay.
		 */
		validationJson.Status = SPS_STATUS_ERROR;
		validationJson.StatusDetail = "Notification Processing error - no status received";
	}
	return validationJson;
}

function _validateMD5(_, reqJson, spsData) {
	var rawConcatenation;
	if (reqJson.TxType === "TOKEN") {
		/*
		 * VPSSignature - MD5 signature of the concatenation of the values of: 
		 *
		 * VPSTxId + VendorTxCode + Status + VendorName + { Token} + SecurityKey
		 */
		rawConcatenation = reqJson.VPSTxId +
			reqJson.VendorTxCode +
			reqJson.Status +
			spsData.vendorName(_).toLowerCase() +
			decodeURIComponent(reqJson.Token) +
			spsData.securityKey(_);
	} else { // PAYMENT, DEFERRED...
		/*
		 * VPSSignature - MD5 signature of the concatenation of the values of: 
		 *
		 * {VPSTxId}+ VendorTxCode + Status + TxAuthNo + VendorName + AVSCV2 + 
		 * SecurityKey + AddressResult + PostCodeResult + CV2Result + GiftAid + 
		 * 3DSecureStatus + CAVV + AddressStatus + PayerStatus + CardType + 
		 * Last4Digits + DeclineCode + ExpiryDate + FraudResponse + BankAuthCode
		 */
		rawConcatenation = (reqJson.VPSTxId.startsWith("{") ? reqJson.VPSTxId : ("{" + reqJson.VPSTxId + "}")) +
			reqJson.VendorTxCode +
			reqJson.Status +
			(reqJson.TxAuthNo || "") +
			spsData.vendorName(_).toLowerCase() +
			(reqJson.AVSCV2 || "") +
			spsData.securityKey(_) +
			(reqJson.AddressResult || "") +
			(reqJson.PostCodeResult || "") +
			(reqJson.CV2Result || "") +
			(reqJson.GiftAid || "") +
			(reqJson["3DSecureStatus"] || "") +
			(reqJson.CAVV || "") +
			(reqJson.AddressStatus || "") +
			(reqJson.PayerStatus || "") +
			(reqJson.CardType || "") +
			(reqJson.Last4Digits || "") +
			(reqJson.DeclineCode || "") +
			(reqJson.ExpiryDate || "") +
			(reqJson.FraudResponse || "") +
			(reqJson.BankAuthCode || "");
	}

	rawConcatenation = decodeURIComponent(rawConcatenation).replace(/\+/g, ' ');

	var hashMD5 = crypto.createHash('md5').update(rawConcatenation).digest('hex').toUpperCase();

	return hashMD5 && (hashMD5 === reqJson.VPSSignature);
}

function _getNotificationPostItem() {
	var id = require('@sage/syracuse-core').uuid.generate('');
	var host = _getHost();
	var url = host + '/bundles-non-auth/sage-pay/notification?id=' + id;
	var notificationItem = {
		sid: id,
		host: host,
		url: url
	};
	return notificationItem;
}

function _getHost() {
	if (!host_) {
		host_ = globals.context.session && globals.context.session.host;

		if (!host_)
			host_ = "http://" + os.hostname().toLowerCase() + ":" + config.port;
	}
	tracer.debug && tracer.debug("Host: " + host_);
	return host_;
}

function _buildEncodedQueryReq(values) {
	return Object.keys(values).map(function(key) {
		return encodeURIComponent(key) + '=' + encodeURIComponent(values[key]);
	}).join('&');
}

function _buildDecodedQueryReq(values) {
	return Object.keys(values).map(function(key) {
		return key + '=' + decodeURIComponent(values[key]);
	}).join('\r\n');
}

function _buildSPSResponse(values) {
	return Object.keys(values).map(function(key) {
		return key + '=' + values[key];
	}).join('\r\n');
}

function _deleteSagePaySessionData(_, vpsTxId) {
	var db = adminHelper.getCollaborationOrm(_);
	var sessionEnt = db.getEntity(_, "sagePaySession");
	var filter = {
		jsonWhere: {
			vpsTxId: vpsTxId
		}
	};
	var sessionIns = db.fetchInstance(_, sessionEnt, filter);
	sessionIns.deleteSelf(_);
}

function _storeSagePaySessionData(_, sid, host, rawResponse, vendorName, spsTimeout) {

	var db = adminHelper.getCollaborationOrm(_);
	var sessionEnt = db.getEntity(_, "sagePaySession");
	var filter = {
		jsonWhere: {
			sid: sid
		}
	};

	//Check if session instance already exists
	var sessionIns = db.fetchInstance(_, sessionEnt, filter);

	if (!sessionIns) {
		//Instance does not exist - create a new instance
		sessionIns = sessionEnt.createInstance(_, db);
		sessionIns.sid(_, sid);
		sessionIns.host(_, host);
	}

	//Read sps response
	var values = {};
	rawResponse.split('\r\n').map(function(element) {
		var separatorPos = element.indexOf('=');
		if (separatorPos >= 0) {
			values[element.substring(0, separatorPos)] = element.substring(separatorPos + 1);
		}
	});

	if (values.Status === SPS_STATUS_OK) {
		var VPSTxId = values.VPSTxId.replace(/{/g, '').replace(/}/g, ''); // remove the outer {}
		sessionIns.vpsTxId(_, VPSTxId);
		sessionIns.vendorName(_, vendorName);
		sessionIns.securityKey(_, values.SecurityKey || "");
		sessionIns.nextURL(_, values.NextURL || "");
		sessionIns.waitStatus(_, SPS_WAIT_STATUS_WAIT);
		//sessionIns.vpsProtocol(_, values.VPSProtocol || "");
	}
	sessionIns.$expire = spsTimeout; //Override
	sessionIns.save(_);

	return true;
}

function _getSagePaySessionData(_, jsonWhere) {
	var db = adminHelper.getCollaborationOrm(_);
	var sessionEnt = db.getEntity(_, "sagePaySession");
	var filter = {
		jsonWhere: jsonWhere
	};
	return db.fetchInstance(_, sessionEnt, filter);

}