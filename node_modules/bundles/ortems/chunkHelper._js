"use strict";
var writeTransform = require('./writeTransform');
var utils = require('./utils');

var tracer; //= console.log;

exports.getChunkData = function(_, parsedUrl, data) {
	return _getChunkData(_, parsedUrl, data);
};

exports.setNextChunkKey = function(_, commsObj) {
	_setNextChunkKey(_, commsObj);
};

exports.getChunkKey = function(_, parsedUrl, commsObj) {
	return _getChunkKey(_, parsedUrl, commsObj);
};

function _getChunkData(_, parsedUrl, data) {
	var transportMapping = utils.getTransportMapping(_, parsedUrl);

	var classSplits = transportMapping && transportMapping.JXTCLASS_SPLIT;
	var chunkSizes = transportMapping && transportMapping.JXTCLASS_SIZE;

	var chunks = [];
	if (classSplits) {
		var markers = [];
		classSplits.forEach(function(classSplit, index) {
			tracer && tracer("classSplit: " + classSplit);
			markers.push({
				tag: classSplit,
				size: chunkSizes.length > index ? chunkSizes[index] : 0
			});
		});

		markers && markers.forEach(function(marker, index, markers) {
			_processMarker(marker, index, markers, data, chunks);
		});
	} else {
		chunks.push(data);
	}
	return chunks;
}

function _processMarker(marker, index, markers, data, chunks) {
	if (marker.tag === '-') {
		index === 0 && markers.length > 1 && _createStartChunk(markers, data, chunks);
	} else {
		if (marker.size > 0) {
			_createDimensionChunks(marker, data, chunks);

			var objCount = _getObjectCount(marker, data);
			var chunkCount = Math.ceil(objCount / marker.size);

			for (var ii = 0, jj = chunkCount; ii < jj; ii++) {
				_createDimensionChunk(marker.tag, marker.size, data, ii * marker.size, chunks);
			}
		} else {
			_createChunk(marker.tag, data, chunks);
		}
	}
}

function _createDimensionChunks(marker, data, chunks) {
	var objCount = _getObjectCount(marker, data);
	var chunkCount = Math.ceil(objCount / marker.size);

	for (var ii = 0, jj = chunkCount; ii < jj; ii++) {
		chunks.push(_createDimensionChunk(marker.tag, marker.size, data, ii * marker.size));
	}
}

function _createDimensionChunk(tag, chunkSize, data, dataStartIndex) {
	var chunkPtr, chunk;
	chunkPtr = chunk = {};
	var dataPtr = data;

	tag.split('.').forEach(function(prop, index, props) {
		prop = _formatProperty(prop);
		if (index === props.length - 1) {
			var dataEndIndex = Math.min(dataStartIndex + chunkSize, dataPtr[prop].length);
			chunkPtr[prop] = [];
			for (var ii = dataStartIndex, jj = dataEndIndex; ii < jj; ii++) {
				chunkPtr[prop].push(dataPtr[prop][ii]);
			}
		} else {
			chunkPtr = chunk[prop] = chunk[prop] || {};
			dataPtr = data[prop];
		}
	});
	return chunk;
}

function _createChunk(tag, data, chunks) {
	var chunkPtr, chunk;
	chunkPtr = chunk = {};
	var dataPtr = data;

	tag.split('.').forEach(function(prop, index, props) {
		prop = _formatProperty(prop);
		if (index === props.length - 1) {
			chunkPtr[prop] = dataPtr && dataPtr[prop];
		} else {
			chunkPtr = chunk[prop] = chunk[prop] || {};
			dataPtr = data[prop];
		}
	});
	chunks.push(chunk);
}

function _createStartChunk(markers, data, chunks) {
	// get everything up to the next marker.
	var chunk = {};
	var nextMarker = markers && markers.length > 1 && _formatTag(markers[1].tag);
	var keys = Object.keys(data);
	for (var ii = 0, jj = keys.length; ii < jj; ii++) {
		var key = keys[ii];
		if (nextMarker && nextMarker.startsWith(key))
			break;

		chunk[key] = data[key];
	}
	chunks.push(chunk);
}

function _getObjectCount(marker, data) {
	var chunkCount = 0;
	var dataPtr = data;
	marker.tag.split('.').forEach(function(prop, index, props) {
		prop = _formatProperty(prop);
		if (index === props.length - 1) {
			chunkCount = dataPtr && dataPtr[prop].length;
		} else {
			dataPtr = dataPtr[prop];
		}
	});
	return chunkCount;
}

function _formatTag(tag) {
	var formattedTag = "";
	if (tag.indexOf('.') < 0) {
		formattedTag = tag;
	} else {
		tag.split('.').forEach(function(prop, index, props) {
			formattedTag += _formatProperty(prop);
			if (index < props.length - 1) {
				formattedTag += '.';
			}
		});
	}
	return formattedTag;
}

function _formatProperty(prop) {
	return prop.startsWith('{') ? prop.slice(1, -1) : prop;
}

function _setNextChunkKey(_, commsObj) {
	commsObj.nextKey = _getNextChunkKey(_, commsObj);
	tracer && tracer("setNextChunkKey: " + commsObj.nextKey);
}

function _getChunkKey(_, parsedUrl, commsObj) {
	var key;
	if (commsObj.transport) {
		key = commsObj.nextKey || _getStartChunkKey(_, writeTransform.transformKey(_, null, commsObj, parsedUrl.key), commsObj);
	} else {
		key = parsedUrl.key;
	}
	return key;
}

function _getNextChunkKey(_, commsObj) {
	var nextKey;
	if (commsObj.transport) {
		nextKey = "";
		var keys = commsObj.transport.X3KEYFMT.split('~');
		for (var ii = 0, jj = keys.length; ii < jj; ii++) {
			var key = keys[ii];
			var prop = commsObj.data[key];
			nextKey += ii ? ("~" + prop) : prop;
		}
	}
	return nextKey;
}

function _getStartChunkKey(_, key, commsObj) {
	tracer && tracer("_getStartChunkKey: " + key);
	var startKey = "";
	if (commsObj.transport) {
		var transportKeys = commsObj.transport.X3KEYFMT.split('~');
		var keys = key.split('~');
		for (var ii = 0, jj = transportKeys.length; ii < jj; ii++) {
			var transportKey = transportKeys[ii];
			var keyPart = keys.length > ii && keys[ii];
			if (!keyPart) {
				if (transportKey === 'MAXREC') {
					startKey += "~" + commsObj.transport.X3MAXREC;
					break;
				} else {
					startKey += "~";
				}
			} else {
				if (transportKey === 'MAXREC') {
					startKey = key;
					break;
				}
				startKey += ii ? "~" + keyPart : keyPart;
			}
		}
	}
	return startKey || key;
}