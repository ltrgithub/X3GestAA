"use strict";
var utils = require('./utils');

var tracer; // = console.log;

exports.getChunkData = function(_, parsedUrl, data) {
	var transportMapping = utils.getTransportMapping(_, parsedUrl);

	var classSplits = transportMapping && transportMapping.JXTCLASS_SPLIT;
	var chunkSizes = transportMapping && transportMapping.JXTCLASS_SIZE;

	console.log ("classSplits: " + JSON.stringify(classSplits));
	console.log ("classSizes: " + JSON.stringify(chunkSizes));

	var chunks = [];
	if (classSplits) {
		var markers = [];
		classSplits.forEach(function(classSplit, index) {
			tracer && tracer("classSplit: " + classSplit);
			markers.push({
				tag: classSplit,
				size: chunkSizes.length > index ? chunkSizes[index] : 0
			});
		});

		markers && markers.forEach(function(marker, index, markers) {
			_processMarker(marker, index, markers, data, chunks);
		});
	} else {
		chunks.push(data);
	}
	return chunks;
};

function _processMarker(marker, index, markers, data, chunks) {
	if (marker.tag === '-') {
		index === 0 && markers.length > 1 && _createStartChunk(markers, data, chunks);
	} else {
		if (marker.size > 0) {
			_createDimensionChunks(marker, data, chunks);

			var objCount = _getObjectCount(marker, data);
			var chunkCount = Math.ceil(objCount / marker.size);

			for (var ii = 0, jj = chunkCount; ii < jj; ii++) {
				_createDimensionChunk(marker.tag, marker.size, data, ii * marker.size, chunks);
			}
		} else {
			_createChunk(marker.tag, data, chunks);
		}
	}
}

function _createDimensionChunks(marker, data, chunks) {
	var objCount = _getObjectCount(marker, data);
	var chunkCount = Math.ceil(objCount / marker.size);

	for (var ii = 0, jj = chunkCount; ii < jj; ii++) {
		chunks.push(_createDimensionChunk(marker.tag, marker.size, data, ii * marker.size));
	}
}

function _createDimensionChunk(tag, chunkSize, data, dataStartIndex) {
	var chunkPtr, chunk;
	chunkPtr = chunk = {};
	var dataPtr = data;

	tag.split('.').forEach(function(prop, index, props) {
		prop = _formatProperty(prop);
		if (index === props.length - 1) {
			var dataEndIndex = Math.min(dataStartIndex + chunkSize, dataPtr[prop].length);
			chunkPtr[prop] = [];
			for (var ii = dataStartIndex, jj = dataEndIndex; ii < jj; ii++) {
				chunkPtr[prop].push(dataPtr[prop][ii]);
			}
		} else {
			chunkPtr = chunk[prop] = chunk[prop] || {};
			dataPtr = data[prop];
		}
	});
	return chunk;
}

function _createChunk(tag, data, chunks) {
	var chunkPtr, chunk;
	chunkPtr = chunk = {};
	var dataPtr = data;

	tag.split('.').forEach(function(prop, index, props) {
		prop = _formatProperty(prop);
		if (index === props.length - 1) {
			chunkPtr[prop] = dataPtr && dataPtr[prop];
		} else {
			chunkPtr = chunk[prop] = chunk[prop] || {};
			dataPtr = data[prop];
		}
	});
	chunks.push(chunk);
}

function _createStartChunk(markers, data, chunks) {
	// get everything up to the next marker.
	var chunk = {};
	var keys = Object.keys(data);
	for (var ii = 0, jj = keys.length; ii < jj; ii++) {
		var key = keys[ii];
		if (markers[1].tag.startsWith(key))
			break;

		chunk[key] = data[key];
	}
	chunks.push(chunk);
}

function _getObjectCount(marker, data) {
	var chunkCount = 0;
	var dataPtr = data;
	marker.tag.split('.').forEach(function(prop, index, props) {
		prop = _formatProperty(prop);
		if (index === props.length - 1) {
			chunkCount = dataPtr && dataPtr[prop].length;
		} else {
			dataPtr = dataPtr[prop];
		}
	});
	return chunkCount;
}

function _formatProperty(prop) {

	return prop.startsWith('{') ? prop.slice(1, -1) : prop;
}