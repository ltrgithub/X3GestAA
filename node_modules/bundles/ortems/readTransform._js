"use strict";

var utils =  require('./utils');
var tracer; // = console.log;

var TransformationRepresentation = "JSNX3HEAD";

exports.noTransform = function (_, parsedUrl, data) {
	return data;
};

exports.transformData = function (_, parsedUrl, data, commsObj) {
	return _transformData(_, parsedUrl, data, commsObj); 
};

exports.prepareReadTransform = function (_, parsedUrl, commsObj) {
	_prepareReadTransform(_, parsedUrl, commsObj);
};

function _transformData (_, parsedUrl, data, commsObj) {
	if (!data)
		return;

	tracer && tracer("Read transformData input: "+JSON.stringify(data,null,2));

	var transformationData;
	var prototype;
	if (commsObj && commsObj.proto && commsObj.transformationData) {
		transformationData = commsObj.transformationData;
		prototype = commsObj.proto;
	} else {
		var representationOnly = parsedUrl.representation.substr(0, parsedUrl.representation.lastIndexOf(parsedUrl.facet)-1);
		var transformationKey =  representationOnly + utils.getFacetShortName(_, parsedUrl.facet);
		transformationData = utils.getRecord(_, parsedUrl.endpoint, TransformationRepresentation, transformationKey);
		prototype = utils.getPrototype(_, parsedUrl);
	}

	var payload;
	try {
		var simpleProto = transformationData && _createSimplePrototype(transformationData, prototype);
		payload = simpleProto && _buildPayload(simpleProto, data);
	} catch (e) {
		payload = {
				"mess": "Transformation error: " + e.message + ((utils.$debug) ? "\n  at " + e.safeStack : ""),
				"sev": "error"
		};
	}

	tracer && tracer("Read transformData output: "+JSON.stringify(payload,null,2));
	tracer && tracer("=====================");

	return payload ? payload : data;
}

function _prepareReadTransform (_, parsedUrl, commsObj) {
	var representationOnly = parsedUrl.representation.substr(0, parsedUrl.representation.lastIndexOf(parsedUrl.facet)-1);
	var transformationKey =  representationOnly + utils.getFacetShortName(_, parsedUrl.facet);
	var transformationData = utils.getRecord(_, parsedUrl.endpoint, TransformationRepresentation, transformationKey);
	var prototype = utils.getPrototype(_, parsedUrl);
	
	// add a diagnoses property so that we can transform the diagnoses in the event of an error
	if (prototype.$properties && !prototype.$properties.$diagnoses) {
		prototype.$properties.$diagnoses = {
			"$type": "application/x-array",
        	"$item": {
          		"$type": "application/json",
				"$properties": {
            		"$message": {
              			"$type": "application/x-string"
              		},
            		"$severity": {
              			"$type": "application/x-string"
              		}
          		}
            }
		};
	}

	commsObj.proto = prototype;
	commsObj.transformationData = transformationData;
}

function _createSimplePrototype(mappings, prototype) {
	if (mappings.JXHJSNX3DET === undefined) return null;
	
	var proto = {};

	mappings.JXHJSNX3DET.forEach(function(element) {
		var pos = proto;
		var protoReference = prototype.$properties;
		var mappingRecord;
		var relJsonPath;
		if (element.X3REPPATH) {
			var splitX3RepPath = element.X3REPPATH.split('.');
			splitX3RepPath.forEach(function(pathElement, index) {
				if (pos[pathElement]) {
					pos = pos[pathElement];
				} else {
					pos[pathElement] = {};
					pos = pos[pathElement];
					pos.$prototype = protoReference[pathElement];
					relJsonPath = element.JSNPATH.split('.')[index];
					mappingRecord = {
						jsonPath: relJsonPath
					};
					(pos.$mappings || (pos.$mappings = [])).push(mappingRecord);
				}

				if (pos.$prototype) {
					protoReference = pos.$prototype.$item && pos.$prototype.$item.$properties;
				} else {
					throw new Error("Missing field in prototype: " + pathElement);
				}
			});
		} else {
			pos.$prototype = protoReference;
		}
		mappingRecord = {
			x3RepAlias: element.X3REPALIAS,
			jsonPath: element.relJsonPath, 
			jsonProp: element.JSNPROP,
			jsonFormat: element.JSNPROPFMT,
			jsonConfig: element.CONFIG
		};
		(pos.$mappings || (pos.$mappings = [])).push(mappingRecord);
	});
	return proto;
}

function _buildPayload(simpleProto, inputData, payloadIn) {
	var payload = payloadIn || {};
	Object.keys(simpleProto).forEach(function(key) {
		if (key === "$prototype") {	return;	}
		if (key === "$mappings") {
			 payload = _processMappings(simpleProto, inputData, payload, key);
		} else {
			if (simpleProto[key].$prototype.$type === "application/x-array") {
				inputData[key] && inputData[key].forEach(function(inputElement) {
					_buildPayload(simpleProto[key], inputElement, payload);
				});
			}
		}
	});
	return payload;
}

function _processMappings(simpleProto, inputData, payload, key) {
	simpleProto[key].forEach(function(mappingRecord) {
		var x3Data = inputData[mappingRecord.x3RepAlias];
		if (mappingRecord.jsonProp) {
			if (_hideProperty(simpleProto, x3Data, mappingRecord) === false) {
				payload[mappingRecord.jsonProp] = _formatJson(x3Data, mappingRecord.jsonFormat);
			}
		} else {
			var jsonKey;
			if (mappingRecord.jsonPath.startsWith('{')) {
				jsonKey = mappingRecord.jsonPath.slice(1, -1);
				payload = payload[jsonKey] = payload[jsonKey] || {}; 
			} else {
				jsonKey = mappingRecord.jsonPath;
				var newObj = {};
				(payload[jsonKey] = payload[jsonKey] || []).push(newObj);
				payload = newObj;
			}
		}
	});
	return payload;
}

function _formatJson(x3Data, jsonFormat) {
	var returnVal;
	switch (jsonFormat) {
		case 'posix':
			returnVal = new Date(x3Data).getTime() / 1000;
			break;
		case 'x-integer':
			returnVal = x3Data && x3Data.length ? parseInt(x3Data) : 0;
			break;
		case 'x-string':
			returnVal = x3Data === undefined ? "" : x3Data.toString();
			break;
		default: 
			returnVal = x3Data;
	}
	return returnVal;
}

function _hideProperty(simpleProto, x3Data, mappingRecord) {
	var hide = false;
	if (mappingRecord.jsonConfig && mappingRecord.jsonConfig === "blank") {
		var type = simpleProto["$prototype"].$item && simpleProto["$prototype"].$item.$properties[mappingRecord.x3RepAlias].$type;
		switch (type) {
			case "application/x-string":
				hide = x3Data === undefined || x3Data.length === 0;
				break;
			case "application/x-integer":
				hide = x3Data === undefined || x3Data === 0; 
				break;
			case "application/x-datetime":
				hide = x3Data === undefined || x3Data === "0000-00-00T00:00:00Z" || x3Data === "1899-11-30T00:00:00.000Z"; 
				break;
			case "application/x-date":
				hide = x3Data === undefined || x3Data === "0000-00-00" || x3Data === "1899-11-30"; 
				break;
			default:
				break;
		}
	}
	return hide; 
}