"use strict";

var readTransform = require('./readTransform');
var chunkHelper = require('./chunkHelper');
var utils = require('./utils');

var tracer; // = console.log;

var _commsCache = [];

const CACHE_TIMEOUT = 20000;

exports.replyToOrtems = function(_, response, commsObj, statusCode) {
	_replyToOrtems(_, response, commsObj, statusCode);
};

exports.sendToX3 = function(_, parsedUrl, commsObj) {
	_sendToX3(_, parsedUrl, commsObj);
};

exports.addToBuffer = function(_, parsedUrl, commsObj) {
	_addToBuffer(_, parsedUrl, commsObj);
};

exports.getFromBuffer = function(_, commsObj) {
	return commsObj.buffer;
};

exports.moreToCome = function(_, commsObj) {
	return commsObj.data && commsObj.data["MAXREC"];
};

exports.getCommsSession = function(_, trackingId, context, parsedUrl) {
	return _getCommsSession(_, trackingId, context, parsedUrl);
};

exports.deleteCommsSession = function(_, trackingId) {
	_deleteCommsSession(_, trackingId);
};

function _sendToX3(_, parsedUrl, commsObj) {
	commsObj.sentToX3 = true;
	var db = parsedUrl.endpoint.getOrm(_);
	var model = parsedUrl.endpoint.getModel(_);
	var entity = model.getEntity(_, parsedUrl.representationName);
	var chunkKey = chunkHelper.getChunkKey(_, parsedUrl, commsObj);
	tracer && tracer("chunkKey: " + chunkKey);
	var instance = entity && db.fetchInstance(_, entity, chunkKey);
	commsObj.data = instance && instance.serializeInstance(_);
}

function _replyToOrtems(_, response, commsObj, statusCode) {
	_sendResponse(_, response, commsObj.buffer && commsObj.buffer.length ? commsObj.buffer[0] : {}, statusCode, commsObj.parsedUrl, readTransform.noTransform);
	commsObj.buffer && commsObj.buffer.length && commsObj.buffer.splice(0, 1);
}

function _addToBuffer(_, parsedUrl, commsObj) {
	commsObj.buffer = commsObj.buffer || [];
	var data = readTransform.transformData(_, parsedUrl, commsObj.data, commsObj);
	commsObj.buffer.push(data);
}

function _getCommsSession(_, trackingId, context, parsedUrl) {
	var commsObj;
	for (var ii = 0, jj = _commsCache.length; ii < jj; ii++) {
		if (_commsCache[ii].trackingId === trackingId) {
			commsObj = _commsCache[ii];
			commsObj.context = context;
			commsObj.parsedUrl = parsedUrl;
			break;
		}
	}

	if (commsObj && _commsObjExpired(_, commsObj)) {
		tracer && tracer("trackingId #" + trackingId + " expired. Deleting cache item.");
		_deleteCommsSession(_, trackingId);
		return _getCommsSession(_, trackingId, context, parsedUrl);
	}

	commsObj = commsObj || _createCommsSession(_, trackingId, context, parsedUrl);
	commsObj.timeStamp = Date.now();

	return commsObj;
}

function _createCommsSession(_, trackingId, context, parsedUrl) {

	_deleteCommsSession(_, trackingId);

	var commsObj = {
		'trackingId': trackingId,
		'context': context,
		'parsedUrl': parsedUrl
	};

	/*
	 * We need to prepare the transform in order to work around an issue 
	 * of resolving globals in a timer callback.
	 */
	readTransform.prepareReadTransform(_, parsedUrl, commsObj);

	commsObj.transport = utils.getTransportMapping(_, parsedUrl);

	_commsCache.push(commsObj);

	return commsObj;
}

function _deleteCommsSession(_, trackingId) {
	for (var ii = 0, jj = _commsCache.length; ii < jj; ii++) {
		if (_commsCache[ii].trackingId === trackingId) {
			_commsCache.splice(ii, 1);
			break;
		}
	}
}

function _commsObjExpired(_, commsObj) {
	return commsObj.timeStamp && (Date.now() - commsObj.timeStamp > CACHE_TIMEOUT);
}

function _sendResponse(_, response, data, statusCode, parsedUrl, transformFunc) {
	var recDataStr = JSON.stringify(transformFunc(_, parsedUrl, data));

	response.writeHead(statusCode, {
		"content-type": "application/json"
	});

	response.end(recDataStr, "utf8");
}