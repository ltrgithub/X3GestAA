"use strict";

var readTransform = require('./readTransform');
var utils = require('./utils');

var TransportRepresentation = "JSNX3TRAN";

var _commsCache = [];

exports.replyToOrtems = function(_, response, commsObj, statusCode) {
	_sendResponse(_, response, commsObj.buffer && commsObj.buffer.length ? commsObj.buffer[0] : {}, statusCode, commsObj.parsedUrl, readTransform.noTransform);
};

exports.sendToX3 = function(_, parsedUrl, commsObj) {
	commsObj.sentToX3 = true;
	var db = parsedUrl.endpoint.getOrm(_);
	var model = parsedUrl.endpoint.getModel(_);
	var entity = model.getEntity(_, parsedUrl.representationName);
	var chunkKey = _getChunkKey(_, parsedUrl, commsObj);
	var instance = entity && db.fetchInstance(_, entity, chunkKey);
	commsObj.data = instance && instance.serializeInstance(_);
};

exports.addToBuffer = function(_, parsedUrl, commsObj) {
	commsObj.buffer = commsObj.buffer || [];
	var data = readTransform.transformData(_, parsedUrl, commsObj.data, commsObj);
	commsObj.buffer.push(data);
};

exports.getFromBuffer = function(_, commsObj) {
	return commsObj.buffer;
};

exports.setNextKey = function(_, commsObj) {
	commsObj.nextKey = exports.getNextKey(_, commsObj);
};

exports.getNextKey = function(_, commsObj) {
	var nextKey;
	if (commsObj.transport) {
		nextKey = "";
		var keys = commsObj.transport.X3KEYFMT.split('~');
		for (var ii = 0, jj = keys.length; ii < jj; ii++) {
			var key = keys[ii];
			var prop = commsObj.data[key];
			nextKey += ii ? ("~" + prop) : prop;
		}
	}
	return nextKey;
};

exports.moreToCome = function(_, commsObj) {
	return commsObj.data && commsObj.data["MAXREC"];
};

exports.getCommsSession = function(_, trackingId, context, parsedUrl) {
	var commsObj;
	for (var ii = 0, jj = _commsCache.length; ii < jj; ii++) {
		if (_commsCache[ii].trackingId === trackingId) {
			commsObj = _commsCache[ii];
			commsObj.context = context;
			commsObj.parsedUrl = parsedUrl;
			break;
		}
	}
	return commsObj || _createCommsSession(_, trackingId, context, parsedUrl);
};

exports.deleteCommsSession = function(_, trackingId) {
	for (var ii = 0, jj = _commsCache.length; ii < jj; ii++) {
		if (_commsCache[ii].trackingId === trackingId) {
			_commsCache.splice(ii, 1);
			break;
		}
	}
};

function _createCommsSession(_, trackingId, context, parsedUrl) {

	exports.deleteCommsSession(_, trackingId);

	var commsObj = {
		'trackingId': trackingId,
		'context': context,
		'parsedUrl': parsedUrl
	};

	/*
	 * We need to prepare the transform in order to work around an issue 
	 * of resolving globals in a timer callback.
	 */
	readTransform.prepareReadTransform(_, parsedUrl, commsObj);

	commsObj.transport = _getTransportMapping(_, parsedUrl);

	_commsCache.push(commsObj);

	return commsObj;
}

function _getTransportMapping(_, parsedUrl) {
	var representationOnly = parsedUrl.representation.substr(0, parsedUrl.representation.lastIndexOf(parsedUrl.facet) - 1);
	var transportKey = representationOnly + utils.getFacetShortName(_, parsedUrl.facet);
	return utils.getRecord(_, parsedUrl.endpoint, TransportRepresentation, transportKey);
}

function _sendResponse(_, response, data, statusCode, parsedUrl, transformFunc) {
	var recDataStr = JSON.stringify(transformFunc(_, parsedUrl, data));

	response.writeHead(statusCode, {
		"content-type": "application/json"
	});

	response.end(recDataStr, "utf8");
}

function _getChunkKey(_, parsedUrl, commsObj) {
	var key;
	if (commsObj.transport) {
		key = commsObj.nextKey || parsedUrl.key;
	} else {
		key = parsedUrl.key;
	}
	return key;
}