"use strict";

const helpers = require('@sage/syracuse-core').helpers;
var utils = require('./utils');
var tracer; // = console.log;
var TransformationRepresentation = "JSNX3HEAD";

exports.noTransform = function(_, parsedUrl, data) {
	return data;
};

exports.transformKey = function(_, parsedUrl, commsObj, keyIn) {
	return _transformKey(_, parsedUrl, commsObj, keyIn);
};

exports.transformData = function(_, parsedUrl, data) {
	return _transformData(_, parsedUrl, data);
};

function _transformKey(_, parsedUrl, commsObj, keyIn) {
	var transformationData = (commsObj && commsObj.transformationData) ? commsObj.transformationData : _getTransformationData(_, parsedUrl);

	var key = keyIn || parsedUrl.key;

	var transformedKey = "";
	if (key.indexOf("~") > 0 && transformationData.X3KEYFMT && transformationData.X3KEYFMT.length) {
		var splitKeys = key.split("~");
		var splitX3Keys = transformationData.X3KEYFMT.split("~");
		splitX3Keys.forEach(function(element, index, array) {
			if (element === "x-string") {
				transformedKey += splitKeys[index];
			} else {
				transformedKey += _formatJson(splitKeys[index], element);
			}
			if (index < array.length - 1) {
				transformedKey += "~";
			}
		});
	} else {
		transformedKey = key;
	}

	tracer && tracer("Write transformKey: " + transformedKey);

	return transformedKey;
}

function _transformData(_, parsedUrl, data) {
	if (!data)
		return;

	tracer && tracer("Write transformData input: " + JSON.stringify(data, null, 2));

	var transformationData = _getTransformationData(_, parsedUrl);
	var prototype = utils.getPrototype(_, parsedUrl);

	// add a diagnoses property so that we can transform the diagnoses in the event of an error
	if (prototype.$properties && !prototype.$properties.$diagnoses) {
		prototype.$properties.$diagnoses = {
			"$type": "application/x-array",
			"$item": {
				"$type": "application/json",
				"$properties": {
					"$message": {
						"$type": "application/x-string"
					},
					"$severity": {
						"$type": "application/x-string"
					}
				}
			}
		};
	}

	var payload;
	try {
		var simpleProto = transformationData && _createSimplePrototype(transformationData, prototype);
		payload = simpleProto && _buildPayload(simpleProto, data);
	} catch (e) {
		payload = {
			"mess": "Transformation error: " + e.message + ((utils.$debug) ? "\n  at " + e.safeStack : ""),
			"sev": "error"
		};
	}
	tracer && tracer("Write transformData output: " + JSON.stringify(payload, null, 2));
	tracer && tracer("=====================");

	return payload ? payload : data;
}

function _createSimplePrototype(mappings, prototype) {
	if (mappings.JXHJSNX3DET === undefined) return null;

	var proto = {};

	mappings.JXHJSNX3DET.forEach(function(element) {
		var pos = proto;
		var protoReference = prototype.$properties;
		var mappingRecord;
		var relX3Path;
		if (element.JSNPATH) {
			var splitJSONPath = element.JSNPATH.split('.');
			splitJSONPath.forEach(function(pathElement, index) {
				if (pos[pathElement]) {
					pos = pos[pathElement];
				} else {
					pos[pathElement] = {};
					pos = pos[pathElement];
					pos.$prototype = protoReference[element.X3REPPATH.split('.')[index]];
					relX3Path = element.X3REPPATH.split('.')[index];
					mappingRecord = {
						jsonPath: relX3Path
					};
					(pos.$mappings || (pos.$mappings = [])).push(mappingRecord);
				}

				if (pos.$prototype) {
					protoReference = pos.$prototype.$item && pos.$prototype.$item.$properties;
				} else {
					if (element.X3REPPATH !== "$diagnoses") {
						throw new Error("Missing field in prototype: " + pathElement);
					}
				}
			});
		} else {
			pos.$prototype = protoReference;
		}
		mappingRecord = {
			x3RepAlias: element.X3REPALIAS,
			x3Format: element.X3PROPFMT,
			jsonProp: element.JSNPROP,
			x3Config: element.CONFIG
		};
		(pos.$mappings || (pos.$mappings = [])).push(mappingRecord);
	});
	return proto;
}

function _buildPayload(simpleProto, inputData, payloadIn) {
	var payload = payloadIn || {};
	Object.keys(simpleProto).forEach(function(key) {
		if (key === "$prototype") {
			return;
		}
		if (key === "$mappings") {
			payload = _processMappings(simpleProto, inputData, payload, key);
		} else {
			if (key.startsWith('{')) {
				inputData[key.slice(1, -1)] && _buildPayload(simpleProto[key], inputData[key.slice(1, -1)], payload);
			} else {
				inputData[key] && inputData[key].forEach(function(inputElement) {
					_buildPayload(simpleProto[key], inputElement, payload);
				});
			}
		}
	});
	return payload;
}

function _processMappings(simpleProto, inputData, payload, key) {
	simpleProto[key].forEach(function(mappingRecord) {
		var jsonData = inputData[mappingRecord.jsonProp];
		if (mappingRecord.x3RepAlias) {
			if (_hideProperty(simpleProto, jsonData, mappingRecord) === false) {
				payload[mappingRecord.x3RepAlias] = _formatJson(jsonData, mappingRecord.x3Format, mappingRecord.x3Config);
			}
		} else {
			var jsonKey = mappingRecord.jsonPath;
			var newObj = {};
			(payload[jsonKey] = payload[jsonKey] || []).push(newObj);
			payload = newObj;
		}
	});
	return payload;
}

function _formatJson(jsonData, x3Format, x3Config) {
	var returnVal;
	switch (x3Format) {
		case 'YYYY-MM-DDT00:00:00Z':
			returnVal = new Date(jsonData * 1000).toISOString().split('.')[0] + "Z";
			break;
		case 'YYYY-MM-DD':
			returnVal = new Date(jsonData * 1000).toISOString().split('T')[0];
			break;
		case 'x-integer':
			returnVal = 0;
			if (jsonData) {
				returnVal = parseInt(jsonData);
				if (isNaN(returnVal)) {
					returnVal = (jsonData === true) ? 1 : 0;
				}
			}
			break;
		case 'x-string':
			returnVal = jsonData === undefined ? "" : jsonData.toString();
			break;
		case '$uuid':
			if (x3Config === "new") {
				returnVal = helpers.uuid.generate();
			} else {
				returnVal = jsonData;
			}
			break;
		default:
			returnVal = jsonData;
	}
	return returnVal;
}

function _hideProperty(simpleProto, x3Data, mappingRecord) {
	var hide = false;
	if (mappingRecord.x3Config && mappingRecord.x3Config === "blank") {
		var type = simpleProto["$prototype"].$item && simpleProto["$prototype"].$item.$properties[mappingRecord.x3RepAlias].$type;
		switch (type) {
			case "application/x-string":
				hide = x3Data === undefined || x3Data.length === 0;
				break;
			case "application/x-integer":
				hide = x3Data === undefined || x3Data === 0;
				break;
			case "application/x-datetime":
				hide = x3Data === undefined || x3Data === "0000-00-00T00:00:00Z" || x3Data === "1899-11-30T00:00:00.000Z";
				break;
			case "application/x-date":
				hide = x3Data === undefined || x3Data === "0000-00-00" || x3Data === "1899-11-30";
				break;
			default:
				break;
		}
	}
	return hide;
}

function _getTransformationData(_, parsedUrl) {
	var representationOnly = parsedUrl.representation.substr(0, parsedUrl.representation.lastIndexOf(parsedUrl.facet) - 1);
	var transformationKey = representationOnly + utils.getFacetShortName(_, parsedUrl.facet);
	return utils.getRecord(_, parsedUrl.endpoint, TransformationRepresentation, transformationKey);
}