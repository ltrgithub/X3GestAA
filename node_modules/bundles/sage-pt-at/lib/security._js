"use strict";

var crypto = require('crypto');
var path = require('path');
var fs = require('fs');
// require node.js constants module (not the local one)
var constants = require('constants');

var pubKeyPath = path.resolve(__dirname, "../certs");
	

exports.generateSecurityHeader = function(username, password, publicKeyName, publicKeyPassword, timestamp) {
	var aesKey = generateRequestKey();
	timestamp = timestamp || new Date().toISOString();
	return {
		header: {
			"wss:Security" : {
				"attributes": {
					"xmlns:wss": "http://schemas.xmlsoap.org/ws/2002/12/secext"
				},
				"wss:UsernameToken" : {
					"wss:Username" : username,
					"wss:Password" : cypherData(password, aesKey),
					"wss:Nonce" : cypherRequestKey(aesKey, getPublicKey(publicKeyName), publicKeyPassword),
					"wss:Created" : cypherData(timestamp, aesKey)
				}
			}
		},
		NonceAESKey: aesKey,
		createdDateTimeUTC: timestamp
	};
};

var generateRequestKey = function() {
	return _getRandom(16);
};

var cypherData = function(data, requestKey) {
	requestKey = requestKey || _getRandom(16);
	var cipher = crypto.createCipheriv("aes-128-ecb", requestKey, new Buffer(''));
	var encrypted = Buffer.concat([
       cipher.update(data, "utf-8"),
       cipher.final()
	]).toString('base64');
	return encrypted;
};

var cypherRequestKey = function(requestKey, publicKey, passphrase) {
	requestKey = requestKey || _getRandom(16);
	return crypto.publicEncrypt({
		key: publicKey,
		passphrase: passphrase,
		padding: constants.RSA_PKCS1_PADDING
	}, requestKey).toString('base64');
};

var decypherRequestKey = function(data, publicKey, passphrase) {
	return crypto.publicDecrypt({
		key: publicKey,
		passphrase: passphrase
	}, data).toString('base64');
};

var getPublicKey = function(publicKeyName) {
	return fs.readFileSync(path.resolve(__dirname, "../certs/" + (publicKeyName || "pubkey.pem")));
};

function _getRandom(length) {
	var result = new Buffer(length);
	for (var i = 0; i < length / 4; i++) {
		var n = Math.floor(Math.random() * (1 << 31));
		result.writeInt32LE(n, 4 * i);
	}
	return result;
}