"use strict";

var locale = require('syracuse-core/lib/locale');
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var crypto = require('crypto');
var check = require('syracuse-license/lib/check');
var globals = require('streamline/lib/globals');
var config = require("syracuse-main/lib/nodeconfig").config;
var authHelper = require("streamline-auth/lib/helpers");

exports.fromCertificate = function(_, session, login) {
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	// fetch user
	var user = db.fetchInstance(_, db.model.getEntity(_, "user"), {
		jsonWhere: {
			login: login,
			active: true
		}
	});
	if (!user) throw authHelper.unauthorized();

	// License check
	var p = user.preferences(_);
	// TODO: review this: why do we return ok if p is null?
	if (p) {
		// find out badges for current user
		var role = p.lastRole(_);
		var diagnoses = [];
		if (role && !check.checkConcurrent(_, session, role, user.login(_), session.device, diagnoses)) {
			throw authHelper.accessDenied("noLicense", user);
		}
		// force user locales: hack request accept-language header
		var l = p.lastLocaleCode(_); // check if locale exists
		if (globals.context && globals.context.request && l && user.getUserLocaleByCode(_, l)) globals.context.request.headers["accept-language"] = l;
	}
	session.setData("userID", user.$uuid);
	session.setData("userLogin", user.login(_));
};

/** check user (and password) for different authentication methods. User name must be in user table
 * parameters:
 * request: current request (request.session will receive data of current user in case of success
 * method: authentication method (basic, digest, oauth2...)
 * login: login user name
 * password: password of user (from basic authentication), or function to check the password
 * serverName: additional server name for oauth2
 */

exports.fromLoginPage = function(_, request, method, login, password, challenge, serverName) {
	var session = request.session;
	var standardSetting = authHelper.getStandardSetting(_);
	var user = null;
	var realm = config.session.realm;

	// fetch user in database
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	var filter = {};
	filter[login.indexOf('@') > 0 ? 'email' : 'login'] = login;
	var users = db.fetchInstances(_, db.model.getEntity(_, "user"), {
		jsonWhere: filter
	});
	if (users && users.length) user = users[0];

	// if no user, we are done
	if (!user) throw authHelper.unauthorized(challenge);

	// check that user is active
	if (!user.active(_)) throw authHelper.accessDenied("inactiveUser", user);

	// get auth configuration for this user
	var userAuthentication = user.authentication(_);
	var localConfig = {
		method: userAuthentication,
	};

	// combine user-level and global authentication settings
	switch (userAuthentication) {
		case "":
			localConfig = standardSetting;
			break;
		case "db":
			localConfig.method = authHelper.getDbMethod();
			localConfig.source = "db";
			break;
		case "ldap":
			localConfig.ldap = user.ldap(_)._data;
			break;
		case "oauth2":
			localConfig.oauth2 = user.oauth2(_)._data;
			break;
		case "sage-id":
			break;
		default:
			throw new Error("bad user authentication method: " + userAuthentication);
	}
	if (!localConfig.source) localConfig.source = localConfig.method;

	// check that we used the right method
	if (localConfig.method !== method) {
		throw authHelper.accessDenied("wrongAuth", user, method);
	}

	// Verify the password
	switch (localConfig.source) {
		case "db":
			if (typeof password === "function") {
				if (!password(user.password(_))) throw authHelper.unauthorized(challenge);
			} else {
				// compute hash of password using user name from user entity
				// apply hash function from RFC2617
				var hash = crypto.createHash('MD5');
				var a1 = user.login(_) + ":" + config.session.realm + ":" + password;
				hash.update(a1, 'binary');
				if (hash.digest("hex") !== user.password(_)) throw authHelper.unauthorized(challenge);
			}
			break;
		case "ldap":
			var ldapName = user.authenticationName(_) || user.login(_);
			if (!localConfig.ldap.active) { // server inactive: no authentication
				console.log("LDAP server inactive");
				throw authHelper.unauthorized(challenge);
			} else {
				var LdapAuth = require("syracuse-ldap").LdapAuth;
				localConfig.ldap.cache = false;
				var auth = new LdapAuth(localConfig.ldap);
				try {
					auth.authenticate(ldapName, password, ~_);
				} catch (e) {
					console.log("LDAP Authentication error: " + e.toString());
					throw authHelper.unauthorized(challenge);
				} finally {
					auth.close(~_);
				}
			}
			break;
		case "oauth2":
			if (serverName !== localConfig.oauth2.name) throw authHelper.accessDenied("wrongAuth", user, serverName);
			break;
		case "sage-id":
			// TODO: extra check on server name
			break;
		default:
			throw new Error("internal error: bad auth source " + localConfig.source);
	}

	var diagnoses = [];

	// check role
	var groups = user.groups(_).toArray(_);
	if (!groups.length) throw authHelper.accessDenied("noGroup", user);
	var p = user.preferences(_);
	var role;
	if (p) {
		// force user locales: hack request accept-language header
		var l = p.lastLocaleCode(_);
		// check if locale exists
		if (globals.context && globals.context.request && l && user.getUserLocaleByCode(_, l)) globals.context.request.headers["accept-language"] = l;
		// take last role from user preferences
		role = p.lastRole(_);
	}
	var role2 = role;
	if (role) {
		// test whether role is in current groups
		for (var j = 0; j < groups.length; j++) {
			var group = groups[j];
			role = group.role(_);
			if (role && role.$uuid === role2.$uuid) break; // role found
			role = null;
		}
	}
	// no role from user preferences - take role from groups
	if (!role) {
		if (!groups.length) throw authHelper.accessDenied("noGroup", user);
		for (var j = 0; j < groups.length; j++) {
			var group = groups[j];
			role = group.role(_);
			if (role) break; // role found
		}
	}
	if (!role) {
		throw authHelper.accessDenied("noRole", user);
	}
	if (role && !check.checkConcurrent(_, session, role, login, session.device, diagnoses, true)) { // try to find new session
		throw authHelper.accessDenied("noLicense", user);
	}

	// user is valid
	session.setData("userID", user.$uuid);
	session.setData("userLogin", login);
	return user;
};