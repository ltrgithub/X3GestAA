"use strict";

var locale = require('syracuse-core/lib/locale');
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var crypto = require('crypto');
var check = require('syracuse-license/lib/check');
var globals = require('streamline/lib/globals');
var config = require("syracuse-main/lib/nodeconfig").config;

exports.fromCertificate = function(_, session, login) {
	var user = null;
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	// fetch user
	user = db.fetchInstance(_, db.model.getEntity(_, "user"), {
		jsonWhere: {
			login: login,
			active: true
		}
	});
	if (user) {
		// License check
		var p;
		if (p = user.preferences(_)) {

			// find out badges for current user
			var role = p.lastRole(_);
			var diagnoses = [];
			if (role && !check.checkConcurrent(session, role, user.login(_), _, session.device, diagnoses)) {
				return 2;
			}
			// force user locales: hack request accept-language header
			var l = p.lastLocaleCode(_);
			// check if locale exists
			if (globals.context && globals.context.request && l && user.getUserLocaleByCode(_, l)) globals.context.request.headers["accept-language"] = l;
		}
		session.setData("userID", user.$uuid);
		session.setData("userLogin", user.login(_));
		return "ok";
	} else return "unAuthenticated";
};

var userRedirect = {};

function _clearRedir(request) {
	// console.log("CLR")
	if (request) {
		var cookie = request.headers.cookie;
		if (cookie) {
			var r = /\bclient\.id=([\w\-]+)/.exec(cookie);
			if (r) {
				var id = r[1];
				// console.log("IDl "+id+ " "+require('util').format(userRedirect));
				for (var login in userRedirect) {
					if (login.indexOf(id) === 0) delete userRedirect[login];
				}
			}
		}
	}
}
exports.clearRedir = _clearRedir;

//avoid redirect when same user wants to log in again (within 100 seconds)
// redirect will stay for at least 1.5 seconds, because sometimes it is not recognized by the client
// therefore double login will be avoided.
// this does not apply to OAuth2, because OAuth2 does not check authentication locally

function _redir(login, status, userAuthentication, request) {
	if (userAuthentication === "oauth2") return status;
	var now = Date.now();
	var compare = now - 100000; // 100 seconds
	for (var login1 in userRedirect) {
		if (userRedirect[login1] < compare) delete userRedirect[login1];
	}
	var id = "";
	if (request) {
		var cookie = request.headers.cookie;
		if (cookie) {
			var r = /\bclient\.id=([\w\-]+)/.exec(cookie);
			if (r) id = r[1];
			// console.log("ID "+id);
		}
	}
	login = id + "$" + login;
	var val = userRedirect[login];
	if (val && (now - val > 1500 || val > now)) {
		// console.log("del "+login)
		delete userRedirect[login];
		return "unAuthenticated";
	} else {
		// console.log("add "+login)
		if (!val) userRedirect[login] = now;
		return status;
	}
}


/** check user (and password) for different authentication methods. User name must be in user table
 * parameters:
 * session: current session (which will receive data of current user in case of success
 * login: login user name
 * password: password of user (from basic authentication)
 * passwordCheck: function which checks password (for digest authentication). It takes one parameter (the password from MongoDB) and returns
 *                true when the password is correct
 * method: authentication method (basic, digest, oauth2...)
 * standardSetting: standard setting singleton
 */

exports.fromLoginPage = function(_, session, login, password, passwordCheck, method, request) {
	var standardSetting = adminHelpers.AdminHelper.getStandardSetting(_);
	var user = null;
	var realm = config.session.realm;
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	// fetch user
	var whereClause = "(login eq \"" + login + "\")";
	var users = db.fetchInstances(_, db.model.getEntity(_, "user"), {
		sdataWhere: whereClause
	});
	if (users && users.length) {
		user = users[0];
	}
	if (user) {
		var localConfig = {};
		var userAuthentication = user.authentication(_);
		if (!userAuthentication) {
			// clone standardSetting
			var member;
			for (member in standardSetting) localConfig[member] = standardSetting[member];
		} else {
			switch (userAuthentication) {
				case "db":
					localConfig.method = config.session.auth;
					localConfig.source = "db";
					break;
				case "ldap":
					if (method === "digest") throw new Error("Configuration error: no HTTP digest authentication with LDAP");
					localConfig.method = "basic";
					localConfig.source = "ldap";
					localConfig.ldap = user.ldap(_)._data;
					break;
				case "oauth2":
					var localOAuth2 = user.oauth2(_)._data;
					localConfig.method = "oauth2-" + (localOAuth2.name || "");
					localConfig.oauth2 = localOAuth2;
					break;
				case "sage-id":
					localConfig.method = "sage-id";
					break;
				default:
					throw new Error("internal error: invalid auth method: " + userAuthentication);
			}
		}
		if (!user.active(_)) // no login for inactive users!
			return _redir(login, "inactiveUser", userAuthentication, request);

		// for OAuth2: when the chosen OAuth2 server does not match the OAuth2 server of the user, then login is not possible
		if (localConfig.method !== method && (localConfig.method.indexOf('oauth') >= 0 || method.indexOf('oauth') >= 0)) {
			console.log("Wrong OAuth2 server " + localConfig.method + " - " + method);
			return _redir(login, "wrongOAuth2", userAuthentication, request);
		} else if (localConfig.method !== method && (localConfig.method.indexOf('sage-id') >= 0 || method.indexOf('sage-id') >= 0)) {
			console.log("Wrong Sage ID authentication " + localConfig.method + " - " + method);
			user = null;
		} else if (localConfig.source == "db") {
			if (passwordCheck) {
				if (!passwordCheck(user.password(_))) user = null;
			} else {
				// compute hash of password using user name from user entity
				// apply hash function from RFC2617
				var hash = crypto.createHash('MD5');
				var a1 = user.login(_) + ":" + config.session.realm + ":" + password;
				hash.update(a1, 'binary');
				if (hash.digest("hex") !== user.password(_)) user = null;
			}
		} else if (localConfig.source == "ldap") {
			var ldapName = user.authenticationName(_) || user.login(_);
			if (!localConfig.ldap.active) { // server inactive: no authentication
				console.log("LDAP server inactive");
				user = null;
			} else {
				var LdapAuth = require("syracuse-ldap").LdapAuth;
				localConfig.ldap.cache = false;
				var auth = new LdapAuth(localConfig.ldap);
				try {
					auth.authenticate(ldapName, password, ~_);
				} catch (e) {
					console.log("LDAP Authentication error: " + e.toString());
					user = null;
				} finally {
					auth.close(~_);
				}
			}
		} else { // OAuth2 authentication
			// nothing to do because it has already been checked whether OAuth2 is correct
		}
		var diagnoses = [];
		// License check
		if (user) {
			// check role
			var groups = user.groups(_).toArray(_);
			if (!groups.length) return _redir(login, "noGroup", userAuthentication, request);
			var p = user.preferences(_);
			var role;
			if (p) {
				// force user locales: hack request accept-language header
				var l = p.lastLocaleCode(_);
				// check if locale exists
				if (globals.context && globals.context.request && l && user.getUserLocaleByCode(_, l)) globals.context.request.headers["accept-language"] = l;
				// take last role from user preferences
				role = p.lastRole(_);
			}
			var role2 = role;
			if (role) {
				// test whether role is in current groups
				for (var j = 0; j < groups.length; j++) {
					var group = groups[j];
					role = group.role(_);
					if (role && role.$uuid === role2.$uuid) break; // role found
					role = null;
				}
			}
			// no role from user preferences - take role from groups
			if (!role) {
				if (!groups.length) return "noGroup";
				for (var j = 0; j < groups.length; j++) {
					var group = groups[j];
					role = group.role(_);
					if (role) break; // role found
				}
			}
			if (!role) {
				return _redir(login, "noRole", userAuthentication, request); // no role
			}
			if (role && !check.checkConcurrent(session, role, login, _, session.device, diagnoses, true)) { // try to find new session
				return "noLicense";
			}

			// TODO: show diagnoses!!!!
		}
		if (user) {
			session.setData("userID", user.$uuid);
			session.setData("userLogin", login);
		}
	}
	if (user && user.changePassword(_)) {
		// redirect to other URL
		return "changePassword";
	}
	return (user == null ? "unAuthenticated" : "ok");
};