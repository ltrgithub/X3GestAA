"use strict";

var helpers = require('syracuse-core/lib/helpers');
var tracer = helpers.debug.tracer("session.trace");
var config = require('syracuse-main/lib/nodeconfig').config;
var fs = require('streamline-fs');
var crypto = require('crypto');
var locale = require('syracuse-core/lib/locale');


function setLocaleFromRequest(request, _) {
	var header = request.headers['accept-language'];
	if (header) {
		var loc = /^[-a-zA-Z]+/.exec(header);
		if (loc) {
			locale.setCurrent(_, loc[0]);
		}
	}
}

exports.noAccess = function(request, response, _, status, user) {
	setLocaleFromRequest(request, _);
	var message;
	var httpStatus = 403;
	switch (status) {
		case 2:
			message = locale.format(module, "nolicense");
			httpStatus = 402;
			break;
		case 4:
			message = locale.format(module, "userInactive", user);
			break;
		case 5:
			message = locale.format(module, "noGroup", user);
			break;
		case 6:
			message = locale.format(module, "noRole", user);
			break;
		case 7:
			message = locale.format(module, "wrongOAuth2", user);
			break;
	}
	if (request.headers && request.headers.accept && request.headers.accept.indexOf("application/json") >= 0) {
		// console.log("JSON " + status);
		response.writeHead(200, {
			"Content-Type": "application/json"
		});
		response.end(JSON.stringify({
			$diagnoses: [{
				$message: message,
				$severity: "error",
				$links: {
					continue: {
						$title: locale.format(module, "continue"),
						$type: "html",
						$target: "_self",
						$url: "/index.html"
					}
				}
			}]
		}));
	} else {
		response.writeHead(httpStatus, {
			"Content-Type": "text/html",
			"Content-Tncoding": "utf8"
		});
		response.end(message);
	}

};


exports.create = function(validatePassword) {
	return new function() {
		function _unAuthenticated(_, request, response) {
			if (request.unauthUseRedirect) {
				response.writeHead(307, {
					"location": self.loginBaseUrl + "?callbackUrl=" + encodeURIComponent(request.url)
				});
				response.end();
			} else {
				response.writeHead(401, {
					"Content-Type": "application/json",
					"WWW-Authenticate": "SageERPX3"
				});
				response.end(JSON.stringify({
					$diagnoses: [{
						$severity: "error",
						$message: locale.format(module, "unauth")
					}],
					$location: {
						$url: "/auth/login" // To Be Defined !!!
					}
				}));
			}
			return false;
		}

		function _unLicensed(request, response, _) {
			response.writeHead(402, {
				"Content-Type": "text/html; charset=utf-8"
			});
			response.end(locale.format(module, "nolicense"));
			return false;
		}

		var self = this;
		this.loginBaseUrl = "/auth/login";

		this.authenticate = function(request, response, session, _) {
			if (request.specialLogin) return true;
			var credentials = (request.headers.authorization || "").split(" ");
			if (!(credentials && credentials[1])) return _unAuthenticated(_, request, response);
			var usrpwd = new Buffer(credentials[1], "base64");
			// Chrome uses UTF8 for authentication
			var agent = request.headers["user-agent"];
			if (agent && (agent.indexOf(" Chrome/") >= 0)) {
				usrpwd = usrpwd.toString("utf8");
			} else {
				usrpwd = usrpwd.toString("binary");
			}
			var index = usrpwd.indexOf(':');
			if (index < 0) return _unAuthenticated(_, request, response);

			var user = usrpwd.substr(0, index);
			var pass = usrpwd.substr(index + 1);

			if (!(user && pass)) return _unAuthenticated(_, request, response);

			// var passHash = computeHash(user, pass);

			var status = validatePassword(_, request.session, user, pass, null, "sageerpx3", request);
			switch (status) {
				case 1:
					return _unAuthenticated(_, request, response);
				case 2:
				case 4:
				case 5:
				case 6:
					return exports.noAccess(request, response, _, status, user);
				case 3:
					return require('./changePassword').setPassword(request, response, user, _);
				case 0:
					break;
				default:
					// non-fatal error
					response.writeHead(406, {
						"Content-Type": "text/plain"
					});
					response.end("Status: " + status);
					return false;
			}

			tracer && tracer("User authenticated.");
			request.session && request.session.afterAuthentication({
				user: user,
				authorization: request.headers.authorization
			});
			return true;
		};
		this.unAuthenticated = function(request, response, _) {
			return _unAuthenticated(_, request, response);
		};

		this.forbidden = function(request, response, message) {
			response.writeHead(403, {
				"Content-Type": "text/plain"
			});
			response.end(message || locale.format(module, "unauth"));
		};
	};

};