"use strict";

var helpers = require('syracuse-core/lib/helpers');
var tracer = helpers.debug.tracer("session.trace");
var url = require("url");
var util = require('util');
var basic = require("./basic");
var querystring = require("querystring");
var OAuth2 = require("node-oauth").OAuth2;

//var tracer = console.log;

//OAuth2 authentication

exports.create = function(validateUser, config, standardConfig) {
	return new function() {
		var auth = new OAuth2(config.clientId, config.clientSecret, config.baseSite, config.authorizePath, config.accessTokenPath);
		var self = this;

		// wrapper for streamline (auth.get)

		this._wrapGet = _(function(dataRequestURL, access_token, cb) {
			auth.get(dataRequestURL, access_token, function(error, result, response) {
				tracer && tracer("_wrapGet " + util.format(result) + "----" + util.format(error));
				cb(error, result); // omit response parameter
			});
		}, 2);

		// wrapper for streamline (auth.getOAuthAccessToken)
		this._wrapGetToken = _(function(code, params, cb) {
			auth.getOAuthAccessToken(code, params, function(error, access_token, refresh_token, result) {
				tracer && tracer("_wrapGetToken " + util.format(result) + "----" + util.format(error));
				if (error) {
					cb(error.data);
				} else {
					cb(null, {
						"access_token": access_token,
						"refresh_token": refresh_token,
						"result": result
					});
				}
			});
		}, 2);

		/// first step of authentication: redirect to OAuth2 server
		this.authenticate = function(request, response, session, _) {
			if (config.inactive) { // server inactive: no authentication
				tracer && tracer("OAuth2 server inactive");
				self.forbidden(request, response, "OAuth2 server inactive");
				return false;
			}
			var params = {};
			params['redirect_uri'] = config.redirectUri;
			params['response_type'] = 'code';
			params['scope'] = config.scope;
			params['state'] = request.url;
			var redirectUrl = auth.getAuthorizeUrl(params);
			// console.log("REDIR"+redirectUrl);
			response.writeHead(303, {
				"Content-Type": "text/html",
				"Location": redirectUrl
			});
			response.end('<html>Use <a href="' + redirectUrl + '">Login</a> if redirect does not work automatically</html>');
			return false;
		};

		function _unLicensed(request, response) {
			response.writeHead(402, {
				"Content-Type": "text/plain"
			});
			response.end("No license");
			return false;
		}

		this.forbidden = function(request, response, error) {
			response.writeHead(403, {
				"Content-Type": "text/plain"
			});
			if (error) {
				response.end("Error in authentication: " + util.format(error));
			} else {
				response.end("Authorization Required");
			}
			return false;
		};

		/// second step of authentication: obtain access token and user name
		this.authenticate2 = function(request, response, _) {
			var parsed = url.parse(request.url);
			var queryData = querystring.parse(parsed.query);
			if (queryData.error) {
				self.forbidden(request, response, queryData.error);
				return false;
			}
			if (!queryData.code) {
				self.forbidden(request, response, "No authorization");
				return false;
			}
			var params = {};
			params['redirect_uri'] = config.redirectUri;
			// params['state'] = queryData.state;
			params['grant_type'] = 'authorization_code';

			try {
				tracer && tracer("Before getting access token");
				// get access token 
				var data = self._wrapGetToken(queryData.code, params, _);
				// get user name
				tracer && tracer("Result of access token " + util.format(data));
				var result = self._wrapGet(config.dataRequestURL, data.access_token, _);
				tracer && tracer("Result of user name " + util.format(result));
				var userField = config.userField || "user";
				var user = JSON.parse(result)[userField];
				var method = "oauth2-" + (config.name || "");
				var status = validateUser(request.session, user, "", null, method, standardConfig, _);

				switch (status) {
					case 1:
						return self.forbidden(request, response);
					case 2:
					case 4:
					case 5:
					case 6:
					case 7:
						return basic.noAccess(request, response, _, status, user);
					case 0:
						break;
					default:
						// non-fatal error
						response.writeHead(406, {
							"Content-Type": "text/plain"
						});
						response.end(status);
						return false;
				}

				request.session && request.session.afterAuthentication({
					user: user,
					password: data.access_token
				});

				return true;
			} catch (error) {
				self.forbidden(request, response, error);
			}
		};
	};
};