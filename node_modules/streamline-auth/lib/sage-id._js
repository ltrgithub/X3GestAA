'use strict';

var helpers = require('syracuse-core/lib/helpers');
var tracer = helpers.debug.tracer('session.trace');
var mongodb = require('streamline-mongodb');
var config = require("../../../nodelocal").config || {};
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var urlHelper = require('url');

// Temp for debugging
tracer = tracer || console.log;

// Extract pfx certificate and password
// Save to variables and pass as options in Sage ID methods
var path = require('path');
var fs = require('fs');
var pfxPath = path.join(__dirname, "../..") + '/streamline-auth/lib/pfx/Sage_ERP_X3_Development.pfx';
var pfx_object = fs.readFileSync(pfxPath);
var pfxTxtPath = path.join(__dirname, "../..") + '/streamline-auth/lib/pfx/Sage_ERP_X3_Development.txt';
var array = fs.readFileSync(pfxTxtPath).toString().split('\n');
var pass = "";
for (var i = 0; i < array.length; i++) {
	var text = array[i].replace(/(\r\n|\n|\r)/gm, "");
	if (text.indexOf("CertPwd") > -1) {
		pass = array[i].split("=")[1].trim();
	}
};

// Verify user authenicated into Sage ID exists in X3 users table in mongoDB
exports.verifyUser = function(request, response, data, _) {
	// Lookup user by email in users table
	var mongoConfig = config.mongo || {};
	var server = new mongodb.Server(mongoConfig.host || 'localhost', mongoConfig.port || 27017, {});
	var db = new mongodb.Db(mongoConfig.database || 'syracuse', server, {
		w: 1 // majority
	});

	// Find specific user based on email
	var filter = {
		email: '' + data.email
	};
	var user = db.open(_).collection('User', _).find(filter, _).toArray(_)[0];
	request.session.data.userID = user._id;
	db.close(_);

	// Finish authentication
	// Save token and user login in session
	request.session && request.session.afterAuthentication({
		user: user.login,
		password: data.accessToken
	});

	return true;
};

// Update session with new sessionId provided by Sage ID
// This is required as when the session is extended it will need to be able to find
// session to update accessToken
exports.updateSessionWithID = function(request, response, _sessions, cookie, data, _) {
	var session = _sessions[cookie];
	delete _sessions[cookie];
	session.id = data.sessionId;
	_sessions[data.sessionId] = session;
	return session;
};

// Accept sessionId from Sage ID
// Remove session from list of sessions and redirect to home page
exports.logoutSessionEnded = function(request, response, sessionId, _) {
	return sessionManager.logout(_, request, response, {
		sessionEnd: true,
		sessionId: sessionId
	});
};

// Determine which action is necessary for session based on last activity time and timeout
// Execute respected sage-id method to extend or end session
exports.extendSession = function(request, response, session, data, _) {
	if (data.notificationType === 'ExpiryDue') {
		var expirationDate = data.expireDate;
		var lastActivity = session.lastAccess;
		var newExpirationDate = new Date(lastActivity.getTime() + 1800000);
		if (newExpirationDate > expirationDate) return true;

		// Mark session as expiration due
		// If any activity is done, session must be extended
		session.expireDue = true;
		session.authData = null;
	}

	return false;
};

function redirect(_, response, url) {
	response.writeHead(307, {
		location: url,
	});
	response.end();
}

function logout(_, request, response) {
	var options = {
		sageIdBase: "https://services.sso.staging.services.sage.com/SSO",
		pfx_object: pfx_object,
		pass: pass,
		sessionEnd: false,
		sessionId: ""
	};
	if (require('sage-id').create(options).logout(request, response, request.session, _)) {
		// logout successful
		request.session.authData = null;
	}
}

exports.dispatch = function(_, request, response) {
	if (!sessionManager.ensureSession(_, request, response)) return false;

	var parsed = urlHelper.parse(request.url, true);
	var sageIdAuth = require("sage-id").create({
		httpClient: require('syracuse-httpclient/lib/httpClient').httpRequest,
		sageIdBase: "https://services.sso.staging.services.sage.com/SSO",
		prefix: "/auth/sage-id/",
		pfx_object: pfx_object,
		pass: pass,
		StartSignOnAttemptRequest: {
			SuccessUri: "http://" + request.headers.host + "/auth/sage-id/startSignOnAttemptSuccess/{0}" + parsed.search,
			FailureUri: "http://" + request.headers.host + "/auth/login",
			CancelAllowed: "true",
			State: "test",
			SessionLengthMinutes: 10
		},
		StartNewUserRegistrationAttemptRequest: {
			SuccessUri: "http://" + request.headers.host + "/auth/sage-id/startNewUserRegistrationAttemptSuccess/{0}",
			FailureUri: "http://" + request.headers.host + "/auth/login",
			CancelAllowed: "true",
			State: "test",
			SessionLengthMinutes: 10,
			SignOnAfterSuccess: true,
			ActivateAfterSuccess: true
		}
	});
	var authData = sageIdAuth.dispatch(request, response, request.session, _);
	if (!authData) return; // not authenticated yet but response has been sent.
	if (authData.auth) {
		authData.logout = logout;
		exports.verifyUser(request, response, authData, _);
		/* TODO: INVESTIGATE THIS
		var pck = helpers.http.parseCookie(request.headers.cookie) || {};
		var port = request.connection.localPort;
		var cookie = pck[_settings.key + "." + port];
		session = export.updateSessionWithID(request, response, _sessions, cookie, authData, _);
		*/
		request.session.getUserProfile(_);
		redirect(_, response, parsed.query.callbackUrl || '/');
	} else {
		// see later
	}
};