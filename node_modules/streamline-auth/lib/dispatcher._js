"use strict";

var adminHelpers = require('syracuse-collaboration/lib/helpers');
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var locale = require('syracuse-core/lib/locale');
var fs = require('streamline-fs');
var querystring = require('querystring');
var url = require('url');
var httpHelper = require('syracuse-sdata/lib/httpHelper');
var config = require("syracuse-main/lib/nodeconfig").config;
var crypto = require('crypto');
var globals = require('streamline/lib/globals');
var check = require('syracuse-license/lib/check');

var authMethods = config.session.auth || "basic";
if (!Array.isArray(authMethods)) authMethods = [authMethods];

/*
this code was after _setSessionCookie
				//
				tracer && tracer("sending 401 for session: " + cookie);
				var authModule = getAuthModule(request, false, _);
				_clearRedir(request);
				return (authModule && (!authModule.unAuthenticated || authModule.unAuthenticated(request, response, _))) || false;
*/

var cache = {};

function _certUserCheck(_, session, login) {
	var user = null;
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	// fetch user
	user = db.fetchInstance(_, db.model.getEntity(_, "user"), {
		jsonWhere: {
			login: login,
			active: true
		}
	});
	if (user) {
		// License check
		var p;
		if (p = user.preferences(_)) {

			// find out badges for current user
			var role = p.lastRole(_);
			var diagnoses = [];
			// console.error("ppppppppppppppppppppppppppppppppppppppppppDIAGD " + require('util').format(session.getUserprofile(_)));
			if (role && !check.checkConcurrent(session, role, user.login(_), _, session.device, diagnoses)) {
				return 2;
			}
			// console.error("DIAGDIAG2 " + require('util').format(diagnoses));
			// console.error("DIAGD " + require('util').format(session.getUserprofile(_)));
			// force user locales: hack request accept-language header
			var l = p.lastLocaleCode(_);
			// check if locale exists
			if (globals.context && globals.context.request && l && user.getUserLocaleByCode(_, l)) globals.context.request.headers["accept-language"] = l;
		}
		session.setData("userID", user.$uuid);
		session.setData("userLogin", user.login(_));
		return 0;
	} else return 1;
}

var userRedirect = {};

function _clearRedir(request) {
	// console.log("CLR")
	if (request) {
		var cookie = request.headers.cookie;
		if (cookie) {
			var r = /\bclient\.id=([\w\-]+)/.exec(cookie);
			if (r) {
				var id = r[1];
				// console.log("IDl "+id+ " "+require('util').format(userRedirect));
				for (var login in userRedirect) {
					if (login.indexOf(id) === 0) delete userRedirect[login];
				}
			}
		}
	}
}
exports.clearRedir = _clearRedir;

//avoid redirect when same user wants to log in again (within 100 seconds)
// redirect will stay for at least 1.5 seconds, because sometimes it is not recognized by the client
// therefore double login will be avoided.
// this does not apply to OAuth2, because OAuth2 does not check authentication locally

function _redir(login, status, userAuthentication, request) {
	if (userAuthentication === "oauth2") return status;
	var now = Date.now();
	var compare = now - 100000; // 100 seconds
	for (var login1 in userRedirect) {
		if (userRedirect[login1] < compare) delete userRedirect[login1];
	}
	var id = "";
	if (request) {
		var cookie = request.headers.cookie;
		if (cookie) {
			var r = /\bclient\.id=([\w\-]+)/.exec(cookie);
			if (r) id = r[1];
			// console.log("ID "+id);
		}
	}
	login = id + "$" + login;
	var val = userRedirect[login];
	if (val && (now - val > 1500 || val > now)) {
		// console.log("del "+login)
		delete userRedirect[login];
		return 1;
	} else {
		// console.log("add "+login)
		if (!val) userRedirect[login] = now;
		return status;
	}
}


/** check user (and password) for different authentication methods. User name must be in user table
 * parameters:
 * session: current session (which will receive data of current user in case of success
 * login: login user name
 * password: password of user (from basic authentication)
 * passwordCheck: function which checks password (for digest authentication). It takes one parameter (the password from MongoDB) and returns
 *                true when the password is correct
 * method: authentication method (basic, digest, oauth2...)
 * standardSetting: standard setting singleton
 * Return codes: 0 OK, 1 authentication failure, 2 no license, 3 change password, 4 user inactive, 5 no group, 6 no role, 7 wrong OAuth2 server
 */

function _userCheck(_, session, login, password, passwordCheck, method, request) {
	var standardSetting = adminHelpers.AdminHelper.getStandardSetting(_);
	var user = null;
	var realm = config.session.realm;
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	// fetch user
	var whereClause = "(login eq \"" + login + "\")";
	var users = db.fetchInstances(_, db.model.getEntity(_, "user"), {
		sdataWhere: whereClause
	});
	if (users && users.length) {
		user = users[0];
	}
	if (user) {
		var localConfig = {};
		var userAuthentication = user.authentication(_);
		if (!userAuthentication) {
			// clone standardSetting
			var member;
			for (member in standardSetting) localConfig[member] = standardSetting[member];
		} else {
			switch (userAuthentication) {
				case "db":
					localConfig.method = config.session.auth;
					localConfig.source = "db";
					break;
				case "ldap":
					if (method === "digest") return "No HTTP digest authentication with LDAP";
					localConfig.method = "basic";
					localConfig.source = "ldap";
					localConfig.ldap = user.ldap(_)._data;
					break;
				case "oauth2":
					var localOAuth2 = user.oauth2(_)._data;
					localConfig.method = "oauth2-" + (localOAuth2.name || "");
					localConfig.oauth2 = localOAuth2;
					break;
				case "sage-id":
					localConfig.method = "sage-id";
					break;
				default:
					// !!! error handling
					console.log("Wrong authentication method " + userAuthentication);
					return locale.format(module, "wrongAuth", userAuthentication);
			}
		}
		if (!user.active(_)) // no login for inactive users!
			return _redir(login, 4, userAuthentication, request);

		// for OAuth2: when the chosen OAuth2 server does not match the OAuth2 server of the user, then login is not possible
		if (localConfig.method !== method && (localConfig.method.indexOf('oauth') >= 0 || method.indexOf('oauth') >= 0)) {
			console.log("Wrong OAuth2 server " + localConfig.method + " - " + method);
			return _redir(login, 7, userAuthentication, request);
		} else if (localConfig.method !== method && (localConfig.method.indexOf('sage-id') >= 0 || method.indexOf('sage-id') >= 0)) {
			console.log("Wrong Sage ID authentication " + localConfig.method + " - " + method);
			user = null;
		} else if (localConfig.source == "db") {
			if (passwordCheck) {
				if (!passwordCheck(user.password(_))) user = null;
			} else {
				// compute hash of password using user name from user entity
				// apply hash function from RFC2617
				var hash = crypto.createHash('MD5');
				var a1 = user.login(_) + ":" + config.session.realm + ":" + password;
				hash.update(a1, 'binary');
				if (hash.digest("hex") !== user.password(_)) user = null;
			}
		} else if (localConfig.source == "ldap") {
			var ldapName = user.authenticationName(_) || user.login(_);
			if (!localConfig.ldap.active) { // server inactive: no authentication
				console.log("LDAP server inactive");
				user = null;
			} else {
				var LdapAuth = require("syracuse-ldap").LdapAuth;
				localConfig.ldap.cache = false;
				var auth = new LdapAuth(localConfig.ldap);
				try {
					auth.authenticate(ldapName, password, ~_);
				} catch (e) {
					console.log("LDAP Authentication error: " + e.toString());
					user = null;
				} finally {
					auth.close(~_);
				}
			}
		} else { // OAuth2 authentication
			// nothing to do because it has already been checked whether OAuth2 is correct
		}
		var diagnoses = [];
		// License check
		if (user) {
			// check role
			var groups = user.groups(_).toArray(_);
			if (!groups.length) return _redir(login, 5, userAuthentication, request);
			var p = user.preferences(_);
			var role;
			if (p) {
				// force user locales: hack request accept-language header
				var l = p.lastLocaleCode(_);
				// check if locale exists
				if (globals.context && globals.context.request && l && user.getUserLocaleByCode(_, l)) globals.context.request.headers["accept-language"] = l;
				// take last role from user preferences
				role = p.lastRole(_);
			}
			var role2 = role;
			if (role) {
				// test whether role is in current groups
				for (var j = 0; j < groups.length; j++) {
					var group = groups[j];
					role = group.role(_);
					if (role && role.$uuid === role2.$uuid) break; // role found
					role = null;
				}
			}
			// no role from user preferences - take role from groups
			if (!role) {
				if (!groups.length) return 5;
				for (var j = 0; j < groups.length; j++) {
					var group = groups[j];
					role = group.role(_);
					if (role) break; // role found
				}
			}
			if (!role) {
				return _redir(login, 6, userAuthentication, request); // no role
			}
			if (role && !check.checkConcurrent(session, role, login, _, session.device, diagnoses, true)) { // try to find new session
				return 2;
			}

			// TODO: show diagnoses!!!!
		}
		if (user) {
			session.setData("userID", user.$uuid);
			session.setData("userLogin", login);
		}
	}
	if (user && user.changePassword(_)) {
		// redirect to other URL
		return 3;
	}
	return (user == null ? 1 : 0);
}

function badRequest(_, request, response, message) {
	response.writeHead(400, {
		"content-type": "text/plain",
	});
	response.end(message);
	return false;
}

function notFound(_, request, response) {
	response.writeHead(404, {
		"content-type": "text/plain",
	});
	response.end("url not found: " + request.url);
	return false;
}

function getAuthModule(tok) {
	if (authMethods.indexOf(tok) < 0) return null;
	switch (tok) {
		case "basic":
			return require("streamline-auth/lib/basic").create(_userCheck);
		case "digest":
			return require("streamline-auth/lib/digest").create(_userCheck);
		case "certificate":
			return require("streamline-auth/lib/certificate").create(_certUserCheck);
		case "sage-id":
			return require("streamline-auth/lib/sage-id").create(_userCheck);
	}
	return null;
}

exports.ensureAuthenticated = function(_, request, response) {
	var session = request.session;
	if (!session) throw new Error("internal error: no session");

	// if session is already authenticated, invoke renew hook if any, otherwise we are ok
	if (session.authData) {
		if (!session.authData.renew) return true;
		return session.authData.renew(_, request, response);
	}

	// if request is authenticated by a client-side certificate, handle it
	if (request.connection.authorized) {
		var certAuth = getAuthModule("certificate");
		return certAuth.authenticate(request, response, request.session, _);
	}

	// if request carries an authorization header, handle it
	if (request.headers.authorization) {
		var tok = request.headers.authorization.split(' ')[0].toLowerCase();
		var authModule = getAuthModule(tok);
		if (authModule) return authModule.authenticate(request, response, request.session, _);
		else return badRequest(_, request, response, "invalid authentication method: " + tok);
	}

	// we are not authenticated
	var acceptHtml = httpHelper.parseAccept(request.headers.accept).some(function(elt) {
		return elt.type === "*" || elt.type === "html";
	});

	// TODO: localize
	if (acceptHtml) {
		// client is expecting HTML contents, redirect to login page
		var location = "/auth/login?callbackUrl=" + encodeURIComponent(request.url);
		response.writeHead(307, {
			"content-type": "text/html; charset=utf8",
			"location": location,
		});
		response.end('<html><head><title>Not authenticated</title></head>' + //
			'<body><a href="' + location + '">click here to login</a></body></html>', "utf8");
	} else {
		// AJAX (or similar) request - generate a diagnose
		response.writeHead(401, {
			"content-type": "application/json",
			"www-authenticate": "LoginPage",
		});
		response.end(JSON.stringify({
			$diagnoses: [{
				$message: "authentication required",
				$severity: "error",
				$links: {
					continue: {
						$title: "login page",
						//locale.format(module, "continue"),
						$type: "html",
						$target: "_self",
						$url: location,
					}
				}
			}]
		}), 'utf8');
	}
	return false;
};

function authenticateObsolete(_) {
	if (options.authRequired && session) {
		tracer && tracer("Session is auth: " + session.isAuthenticated());
		if (!session.isAuthenticated()) {
			var authRes = false;
			if (session.expireDue) {
				options.forceAuth = false;
				options.forceAuth2 = true;
				options.authType = "sage-id";
			}
			request.unauthUseRedirect = options.unauthUseRedirect;
			var authModule = getAuthModule(request, options.forceAuth2, _);
			if (options.forceAuth) {
				authRes = authModule.authenticate(request, response, session, _);
			} else if (options.forceAuth2) {
				if (options.authType == "sage-id") {
					var authData = "";
					if (session.expireDue) {
						//If session is due to expire and activity occurs, this section of code will be called
						// It will extend the session remove the expire mark and save user info in session
						authData = authModule.sessionExtend(request, response, session, _);
						require("streamline-auth/lib/sage-id").verifyUser(request, response, authData, _);
					} else {
						// Returned authData, contains email, accessToken, identityId, and auth
						// auth contains whether or not user was authenticated successfully
						authData = authModule.dispatch(request, response, session, _);
						// sessionNotify only apart of authData during notification handling
						// Extract session and determine whether or not to extend or end session
						if (authData.sessionNotify) {
							session = _sessions[authData.sessionId];
							var extend = require("streamline-auth/lib/sage-id").extendSession(request, response, session, authData, _);
							if (extend) authData = authModule.sessionExtend(request, response, session, _);
						}
					}
					authRes = authData.auth;
				} else authRes = authModule.authenticate2(request, response, _);
			} else authRes = authModule.forbidden(request, response);
			//
			if (authRes) {
				// TODO: this should be in session.afterAuthentication
				// force user profile loading
				// If SageID authentication successful, retrieve user from mongoDB and store info in session
				// Update session with new sessionId provided by Sage ID
				if (options.authType == "sage-id") {
					require("streamline-auth/lib/sage-id").verifyUser(request, response, authData, _);
					var pck = helpers.http.parseCookie(request.headers.cookie) || {};
					var port = request.connection.localPort;
					var cookie = pck[_settings.key + "." + port];
					session = require("streamline-auth/lib/sage-id").updateSessionWithID(request, response, _sessions, cookie, authData, _);
				}
				session.getUserProfile(_);
			}
			//
			return authRes;
		}
	}
	return true;
}


// obtain module for authentication from request url and standard configuration
exports.getAuthModuleObsolete = function(request, redirect, _) {
	// TODO: for now, if secure connection, use of client certificates having CN mapping to a valid user name
	// later, have a possibility of generic client certificate and / or ability to change user
	// certificate auth >>>
	// console.log("GET AUTH "+request.url);
	if (request.connection.authorized) return require("streamline-auth/lib/certificate").create(_certUserCheck);
	// certificate auth <<<
	var result;
	var parsed = url.parse(request.url);
	var pathname;
	if (redirect) { // use original URL
		pathname = querystring.parse(parsed.query).state;
		request.syracuseOriginalPath = pathname;
	} else {
		pathname = parsed.pathname;
	}
	var regexResult; // search authentication information in request.url
	var authmethod;
	var authserver;
	var setting; // either standard setting or (partial) setting derived from path:
	// authentication header in URL path: /auth/basic or /auth/oauth2-<Name>
	regexResult = /^\/auth\/(std|basic|digest|sageerpx3|oauth2-(\w*)|sage-id)(\-\-[0-9a-f]*)?/.exec(pathname);
	// authentication header may be of different method that in config, we accept it
	if (regexResult == null && request.headers.authorization) {
		// extract method from header
		regexResult = ["", (request.headers.authorization || "").split(" ")[0].toLowerCase()];
	}
	// temp hack, before the method gets into standard settings
	if (regexResult == null && config.session && config.session.auth === "sageerpx3") {
		regexResult = ["", "sageerpx3"];
		//		authmethod = "sageerpx3";
	}
	if (config.session && config.session.auth === "sage-id") {
		authmethod = "sage-id";
	} else if (Array.isArray(config.session.auth)) {
		var authMethods = config.session.auth;
		var path = request.url.split('/')[1];
		if (request.url.split('/')[2] === "sage-id" && authMethods.indexOf("sage-id") > -1) {
			authmethod = "sage-id";
		} else if (path === "sdata" && authMethods.indexOf("sageerpx3") > -1) {
			regexResult = ["", "sageerpx3"];
			authmethod = "sageerpx3";
		} else if (path === "auth" && authMethods.indexOf("oauth2") > -1) {
			// Enter oauth2 authentication methods here
			var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
			var authserverInstance = db.fetchInstance(_, db.model.getEntity(_, "oauth2"), {
				sdataWhere: '(name eq "' + regexResult[2] + '")'
			});
			if (!authserverInstance) {
				console.log("No OAuth2 server with name " + regexResult[2]);
				throw new Error(locale.format(module, "noOauth2N", regexResult[2]));
			}
			if (!authserverInstance.active(_)) {
				console.log("inactive OAuth2 server with name " + regexResult[2]);
				throw new Error(locale.format(module, "oauth2Inact", regexResult[2]));
			}
			// !!! not OK. How can I copy all attributes?
			authserver = authserverInstance._data;
		} else {
			authmethod = "basic";
		}
	} else if (regexResult == null || regexResult[1] === "oauth2-" || regexResult[1] === "std") {
		authmethod = standardSetting.method;
		if (regexResult && regexResult[1] === "oauth2-" && authmethod !== "oauth2-") {
			console.log("No OAuth2 server according to standard config file");
			throw new Error(locale.format(module, "noOauth2"));
		}
		authserver = standardSetting.oauth2;
	} else {
		authmethod = regexResult[1];
		if (authmethod && authmethod.indexOf("oauth2") === 0) {
			// get OAuth2 server from database
			var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
			var authserverInstance = db.fetchInstance(_, db.model.getEntity(_, "oauth2"), {
				sdataWhere: '(name eq "' + regexResult[2] + '")'
			});
			if (!authserverInstance) {
				console.log("No OAuth2 server with name " + regexResult[2]);
				throw new Error(locale.format(module, "noOauth2N", regexResult[2]));
			}
			if (!authserverInstance.active(_)) {
				console.log("inactive OAuth2 server with name " + regexResult[2]);
				throw new Error(locale.format(module, "oauth2Inact", regexResult[2]));
			}
			// !!! not OK. How can I copy all attributes?
			authserver = authserverInstance._data;
		}
	}
	if (regexResult && regexResult[1].indexOf("oauth2") < 0 && regexResult[3]) { // login with token
		var user = require("streamline-auth/lib/changePassword").getTempLogin(regexResult[3]);
		if (user) {
			return {
				authenticate: function(request, response, session, _) {
					request.session && request.session.afterAuthentication({
						user: user,
					});
					console.log("Authentication after change password");
					return true;
				}
			}; // no authentication necessary any more
		}
	}

	if (authmethod === "basic") {
		return require("streamline-auth/lib/basic").create(_userCheck);
	} else if (authmethod === "digest") {
		return require("streamline-auth/lib/digest").create(_userCheck);
	} else if (authmethod === "sageerpx3") {
		return require("streamline-auth/lib/sageerpx3").create(_userCheck);
	} else if (authmethod === "sage-id") {
		sageIdAuth.unAuthenticated = function(request, response, _) {
			return this.authenticate(request, response, request.session, _);
		};
		sageIdAuth.loginBaseUrl = "/index3.html";
		return sageIdAuth;
	} else {
		return require("streamline-auth/lib/oauth2").create(_userCheck, authserver);
	}
};

function genLoginPage(_, request, response) {
	var params = {};
	['basic', 'digest', 'sageerpx3', 'ldap', 'oauth2', 'sage-id'].forEach(function(method) {
		params[method + "Visibility"] = authMethods.indexOf(method) >= 0 ? 'visible' : 'hidden';
	});
	params.passwordVisibility = //
	params.basicVisibility || //
	params.digestVisibility || //
	params.sageerpx3Visibility || //
	params.ldapVisibility;

	var html = fs.readFile(__dirname + "/../html/login.html", "utf8", _);
	// keep only the sections for enabled auth methods
	html = html.replace(/\{\{([^\}]+)\}\}/g, function(all, name) {
		return params[name];
	});
	response.writeHead(200, {
		"content-type": "text/html"
	});
	response.end(html);
}

function submitLogin(_, request, response) {
	if (!sessionManager.ensureSession(_, request, response)) return;
	if (!exports.ensureAuthenticated(_, request, response)) return;

	response.writeHead(200, {
		"content-type": "application/json",
	});
	response.end(JSON.stringify({}));
}

exports.dispatcher = function(config) {
	var routes = {
		login: genLoginPage,
		submitLogin: submitLogin,
		'sage-id': require('streamline-auth/lib/sage-id').dispatch,
	};
	return function(_, request, response) {
		var token = request.url.split(/[\/\?]/)[2];
		var route = routes[token] || notFound;
		return route(_, request, response);
	};
};

function dispatcherObsolete(config) {
	return function(_, request, response) {
		// listing of all authentication methods
		if (/index2\.html$/.exec(request.url)) {
			var path = "/syracuse-main/html/main.html?url=" + encodeURIComponent("?representation=home.$navigation");
			response.writeHead(200, {
				"Content-type": "text/html"
			});
			response.write(_, '<html>Authentication methods:<br><a href="' + request.url.replace("/index2.html", path) + '">Standard</a><br>');
			response.write(_, '<html><a href="' + request.url.replace("/index2.html", '/auth/digest' + path) + '">Digest</a><br>');
			response.write(_, '<html><a href="' + request.url.replace("/index2.html", '/auth/basic' + path) + '">Basic</a><br>');
			var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
			// fetch OAuth2 server data
			var oauth2s = db.fetchInstances(_, db.model.getEntity(_, "oauth2"), {
				sdataWhere: ""
			});
			var i;
			for (i = 0; i < oauth2s.length; i++) {
				if (oauth2s[i].active(_)) {
					var name = oauth2s[i].name(_);
					var displayname = oauth2s[i].displayName(_) || name;
					response.write(_, '<html><a href="' + request.url.replace("/index2.html", "/auth/oauth2-" + name + path) + '">' + displayname + '</a><br>');
				}
			}
			// if there is not setting instance, also provide link for OAuth2 server in global configuration
			var setting = db.fetchInstance(_, db.model.getEntity(_, "setting"), {
				sdataWhere: ""
			});
			if (!setting && config.session.auth === "oauth2" && typeof(config.oauth2) != "undefined") {
				response.write(_, '<html><a href="' + request.url.replace("/index2.html", "/auth/oauth2-" + path) + '">Configured OAuth2 server</a><br>');
			}
			return response.end();
		}

		// OAuth2 redirect path equals "/redirect". In order to avoid parsing every url, it will be searched using a substring function first
		if (request.url.indexOf("/oauth2/redirect") >= 0 && url.parse(request.url).pathname === "/oauth2/redirect") {
			// second step of authentication
			if (!sessionManager.ensureSession(_, request, response, {
				authRequired: true,
				forceAuth2: true
			})) return;
			// redirect to start page
			response.writeHead(303, {
				"Content-Type": "text/html",
				"Location": request.syracuseOriginalPath
			});
			response.end('<html><a href="/test">Link</a></html>');
			return;
		}

		// Processing the password change dialog
		if (request.url.indexOf("/auth/pwd--") === 0) {
			var token = request.url.substr(9);
			var newUrl = "/";
			var changePasswordModule = require('streamline-auth/lib/changePassword');
			var tmpLogin = changePasswordModule.getTempLogin(token, request.method === "GET"); // do not delete token for get request, because it will be necessary for subsequent POST request
			if (tmpLogin) {
				console.log("Login found for user " + tmpLogin.user);
				if (request.method === "GET") {
					// try to set locale for given user
					var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
					if (db) {
						var whereClause = "(login eq \"" + tmpLogin.user + "\")";
						var user = db.fetchInstance(_, db.model.getEntity(_, "user"), {
							sdataWhere: whereClause
						});
						if (user) {
							var up = db.model.getEntity(_, "userProfile").factory.createInstance(_, null, db);
							up.loadUserProfile(_, user);
							var loc = up.selectedLocale(_);
							if (loc) {
								var code = loc.code(_);
								console.log("Set locale for password page " + code);
								if (code) locale.setCurrent(_, code);
							}
						}
					}
					// make changes in template for password page to enable localization
					var answer = fs.readFile(__dirname + "/../../syracuse-main/html/newPassword.html", "utf8", _);
					answer = changePasswordModule.localizeAnswer(answer, user);
					answer = answer.replace("{login}", user.login(_));
					answer = answer.replace("{realm}", config.session.realm);
					answer = answer.replace("{action}", "/auth/pwd" + token); // re-use token;
					response.writeHead(403, {
						"Content-Type": "text/html; charset=utf8"
					});
					response.end(answer);
					return;
				} else {
					// set new password
					var content = request.readAll(_);
					if (content) {
						var stringContent = content.toString("utf8");
						var query = querystring.parse(stringContent);
						var user;
						if (tmpLogin.user.toLowerCase() === query.login.toLowerCase()) {
							var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
							// fetch user
							var whereClause = "(login eq \"" + query.login + "\")";
							var users = db.fetchInstances(_, db.model.getEntity(_, "user"), {
								sdataWhere: whereClause
							});
							if (users && users.length) {
								// console.log("User found");
								user = users[0];
							}
						}
						if (user) {
							user.password(_, query.passwordHash);
							user.changePassword(_, false);
							user.save(_);
							// console.log("Password changed");
							/*
						var token = changePasswordModule.setTempLogin({
							user: query.login
						});
						// new url: replace or set authentication token in path, when it already starts with /auth/...,
						// otherwise add /auth/std prefix with authentication token
						/*						if (tmpLogin.url.substr(0, 6) === "/auth/") {
							newUrl = tmpLogin.url.replace(/^(\/auth\/(?:std|digest|basic|oauth2-\w*))(?:\-\-[0-9a-fA-F]*)?/, "$1" + token);
						} else {
							newUrl = "/auth/std" + token + tmpLogin.url;
						}*/
							newUrl = "/auth/std" + token + "/syracuse-main/html/main.html?url=%3Frepresentation%3Dhome.%24navigation";
						}
					}
				}
			}
			response.writeHead(303, {
				"Content-Type": "text/html",
				"Location": newUrl
			});
			response.end('<html><a href="/test">Link</a></html>');
			return;
		}

		if (request.url.indexOf("/sage-id/") >= 0) {
			var authTest = sessionManager.ensureSession(_, request, response, {
				authRequired: true,
				forceAuth: false,
				forceAuth2: true,
				authType: "sage-id"
			});
			if (authTest == true) {
				var host = request.headers.host;
				var path = "http://" + host + "/syracuse-main/html/main.html?url=%3Frepresentation%3Dhome.%24navigation";
				response.writeHead(303, {
					"Content-Type": "text/html",
					"Location": path,
				});
				response.end();
			}
			return;
		}

		// strip authentication header
		if (request.url.indexOf("/auth/") >= 0 && url.parse(request.url).pathname.indexOf("/auth/") === 0) {
			request.url = request.url.replace(/\/auth\/[\w-]+/, "");
			if (!request.url || request.url === "/") request.url = '/index.html';
			response.writeHead("301", {
				location: request.url,
			});
			return response.end();
		}

		if (/index3\.html$/.exec(request.url)) {
			var html = fs.readFile(__dirname + "/../../index3.html", "utf8", _);
			response.writeHead("200", {
				"Content-Type": "text/html"
			});
			response.write(_, html);
			return response.end();
		}
	};
};