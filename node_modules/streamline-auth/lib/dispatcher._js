"use strict";

var adminHelpers = require('syracuse-collaboration/lib/helpers');
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var locale = require('syracuse-core/lib/locale');
var fs = require('streamline-fs');
var querystring = require('querystring');
var url = require('url');
var httpHelper = require('syracuse-sdata/lib/httpHelper');
var config = require("syracuse-main/lib/nodeconfig").config;
var checkUser = require('streamline-auth/lib/checkUser');

var authMethods = config.session.auth || "basic";
if (!Array.isArray(authMethods)) authMethods = [authMethods];

/*
this code was after _setSessionCookie
				//
				tracer && tracer("sending 401 for session: " + cookie);
				var authModule = getAuthModule(request, false, _);
				_clearRedir(request);
				return (authModule && (!authModule.unAuthenticated || authModule.unAuthenticated(request, response, _))) || false;
*/

function badRequest(_, request, response, message) {
	response.writeHead(400, {
		"content-type": "text/plain",
	});
	response.end(message);
	return false;
}

function notFound(_, request, response) {
	response.writeHead(404, {
		"content-type": "text/plain",
	});
	response.end("url not found: " + request.url);
	return false;
}

function getAuthModule(tok) {
	if (authMethods.indexOf(tok) < 0) return null;
	switch (tok) {
		case "basic":
			return require("streamline-auth/lib/basic").create(checkUser.fromLoginPage);
		case "digest":
			return require("streamline-auth/lib/digest").create(checkUser.fromLoginPage);
		case "certificate":
			return require("streamline-auth/lib/certificate").create(checkUser.fromCertificate);
		case "sage-id":
			return require("streamline-auth/lib/sage-id").create(checkUser.fromLoginPage);
	}
	return null;
}

exports.ensureAuthenticated = function(_, request, response) {
	var session = request.session;
	if (!session) throw new Error("internal error: no session");

	// if session is already authenticated, invoke renew hook if any, otherwise we are ok
	if (session.authData) {
		if (!session.authData.renew) return true;
		return session.authData.renew(_, request, response);
	}

	// if request is authenticated by a client-side certificate, handle it
	if (request.connection.authorized) {
		var certAuth = getAuthModule("certificate");
		return certAuth.authenticate(request, response, request.session, _);
	}

	// if request carries an authorization header, handle it
	if (request.headers.authorization) {
		var tok = request.headers.authorization.split(' ')[0].toLowerCase();
		var authModule = getAuthModule(tok);
		if (authModule) return authModule.authenticate(request, response, request.session, _);
		else return badRequest(_, request, response, "invalid authentication method: " + tok);
	}

	// we are not authenticated
	var acceptHtml = httpHelper.parseAccept(request.headers.accept).some(function(elt) {
		return elt.type === "*" || elt.type === "html";
	});

	// TODO: localize
	if (acceptHtml) {
		// client is expecting HTML contents, redirect to login page
		var location = "/auth/login?callbackUrl=" + encodeURIComponent(request.url);
		response.writeHead(307, {
			"content-type": "text/html; charset=utf8",
			"location": location,
		});
		response.end('<html><head><title>Not authenticated</title></head>' + //
			'<body><a href="' + location + '">click here to login</a></body></html>', "utf8");
	} else {
		// AJAX (or similar) request - generate a diagnose
		response.writeHead(401, {
			"content-type": "application/json",
			"www-authenticate": "LoginPage",
		});
		response.end(JSON.stringify({
			$diagnoses: [{
				$message: "authentication required",
				$severity: "error",
				$links: {
					continue: {
						$title: "login page",
						//locale.format(module, "continue"),
						$type: "html",
						$target: "_self",
						$url: location,
					}
				}
			}]
		}), 'utf8');
	}
	return false;
};

function genLoginPage(_, request, response) {
	var params = {};
	['basic', 'digest', 'sageerpx3', 'ldap', 'oauth2', 'sage-id'].forEach(function(method) {
		params[method + "Visibility"] = authMethods.indexOf(method) >= 0 ? 'visible' : 'hidden';
	});
	params.passwordVisibility = //
	params.basicVisibility || //
	params.digestVisibility || //
	params.sageerpx3Visibility || //
	params.ldapVisibility;

	var html = fs.readFile(__dirname + "/../html/login.html", "utf8", _);
	// keep only the sections for enabled auth methods
	html = html.replace(/\{\{([^\}]+)\}\}/g, function(all, name) {
		return params[name];
	});
	response.writeHead(200, {
		"content-type": "text/html"
	});
	response.end(html);
}

function submitLogin(_, request, response) {
	if (!sessionManager.ensureSession(_, request, response)) return;
	if (!exports.ensureAuthenticated(_, request, response)) return;

	response.writeHead(200, {
		"content-type": "application/json",
	});
	response.end(JSON.stringify({}));
}

exports.dispatcher = function(config) {
	var routes = {
		login: genLoginPage,
		submitLogin: submitLogin,
		'sage-id': require('streamline-auth/lib/sage-id').dispatch,
	};
	return function(_, request, response) {
		var token = request.url.split(/[\/\?]/)[2];
		var route = routes[token] || notFound;
		return route(_, request, response);
	};
};