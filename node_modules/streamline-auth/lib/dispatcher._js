"use strict";

var adminHelpers = require('syracuse-collaboration/lib/helpers');
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var locale = require('syracuse-core/lib/locale');
var fs = require('streamline-fs');
var querystring = require('querystring');
var url = require('url');
var httpHelper = require('syracuse-sdata/lib/httpHelper');
var config = require("syracuse-main/lib/nodeconfig").config;
var authHelper = require('streamline-auth/lib/helpers');
var checkUser = require('streamline-auth/lib/checkUser');

function badRequest(_, request, response, message) {
	response.writeHead(400, {
		"content-type": "text/plain",
	});
	response.end(message);
	return false;
}

function notFound(_, request, response) {
	response.writeHead(404, {
		"content-type": "text/plain",
	});
	response.end("url not found: " + request.url);
	return false;
}

function invalidAuthMethod(_, request, response, tok) {
	return badRequest(_, request, response, "invalid authentication method: " + tok);
}

exports.ensureAuthenticated = function(_, request, response) {
	var session = request.session;
	if (!session) throw new Error("internal error: no session");

	// if session is already authenticated, invoke renew hook if any, otherwise we are ok
	if (session.authData) {
		if (!session.authData.renew) return true;
		return session.authData.renew(_, request, response);
	}

	// if request is authenticated by a client-side certificate, handle it
	if (request.connection.authorized) {
		var certAuth = authHelper.getAuthModule("certificate");
		if (!certAuth) return invalidAuthMethod(_, request, response, tok);
		return certAuth.authenticate(_, request, response, request.session);
	}

	// if request carries an authorization header, handle it
	if (request.headers.authorization) {
		var tok = request.headers.authorization.split(' ')[0].toLowerCase();
		var authModule = authHelper.getAuthModule(tok);
		if (!authModule) return invalidAuthMethod(_, request, response, tok);
		return authModule.authenticate(_, request, response, request.session);
	}

	// we are not authenticated - response depends on accept header
	var acceptHtml = httpHelper.parseAccept(request.headers.accept).some(function(elt) {
		return elt.type === "*" || elt.type === "html";
	});
	var location = "/auth/login?callbackUrl=" + encodeURIComponent(request.url);

	// TODO: localize
	if (acceptHtml) {
		// client is expecting HTML contents, redirect to login page
		response.writeHead(307, {
			"content-type": "text/html; charset=utf8",
			"location": location,
		});
		response.end('<html><head><title>Not authenticated</title></head>' + //
			'<body><a href="' + location + '">click here to login</a></body></html>', "utf8");
	} else {
		// AJAX (or similar) request - generate a diagnose with a link to the login page.
		response.writeHead(401, {
			"content-type": "application/json",
			"www-authenticate": "LoginPage",
		});
		response.end(JSON.stringify({
			$diagnoses: [{
				$message: "authentication required",
				$severity: "error",
				$links: {
					continue: {
						$title: "login page",
						//locale.format(module, "continue"),
						$type: "html",
						$target: "_self",
						$url: location,
					}
				}
			}]
		}), 'utf8');
	}
	return false;
};

function genLoginPage(_, request, response) {
	var params = {};
	// set visibility flags for the different authentication methods
	['basic', 'digest', 'sageerpx3', 'ldap', 'oauth2', 'sage-id'].forEach(function(method) {
		params[method + "Visibility"] = authHelper.isAllowed(method) ? 'visible' : 'hidden';
	});
	params.passwordVisibility = //
	params.basicVisibility || //
	params.digestVisibility || //
	params.sageerpx3Visibility || //
	params.ldapVisibility;

	params.oauth2s = JSON.stringify(require('streamline-auth/lib/oauth2').getServerList(_));

	// set error message if last authentication failed
	if (request.session && request.session.loginError) {
		params.loginError = request.session.loginError;
		// display it only once
		request.session.loginError = "";
	}

	var html = fs.readFile(__dirname + "/../html/login.html", "utf8", _);
	// keep only the sections for enabled auth methods
	html = html.replace(/\{\{([^\}]+)\}\}/g, function(all, name) {
		return params[name];
	});
	response.writeHead(200, {
		"content-type": "text/html"
	});
	response.end(html);
}

function submitLogin(_, request, response) {
	sessionManager.ensureSession(_, request, response);
	if (!exports.ensureAuthenticated(_, request, response)) return;

	response.writeHead(200, {
		"content-type": "application/json",
	});
	response.end(JSON.stringify({}));
}

function setLocaleFromRequest(_, request) {
	var header = request.headers['accept-language'];
	if (header) {
		var loc = /^[-a-zA-Z]+/.exec(header);
		if (loc) {
			locale.setCurrent(_, loc[0]);
		}
	}
}

exports.dispatcher = function(config) {
	var routes = {
		login: genLoginPage,
		submitLogin: submitLogin,
		'sage-id': require('streamline-auth/lib/sage-id').dispatch,
	};
	return function(_, request, response) {
		setLocaleFromRequest(_, request);
		var token = request.url.split(/[\/\?]/)[2];
		var route = routes[token] || notFound;
		return route(_, request, response);
	};
};