"use strict";

var helpers = require('syracuse-core/lib/helpers');
var tracer = helpers.debug.tracer("session.trace");
var config = require('syracuse-main/lib/nodeconfig').config

var basicMatchRegex = /^[Bb]asic\s([a-zA-Z0-9\+\/]+\=*)/;

exports.create = function(validatePassword, standardConfig) {
	return new function() {
		function _unAuthenticated(request, response, options) {
			response.writeHead(401, {
				"Content-Type": "text/plain",
				"WWW-Authenticate": 'Basic realm=' + config.session.realm
			});
			response.end("Authorization Required");
			return false;
		}

		function _unLicensed(request, response) {
			response.writeHead(402, {
				"Content-Type": "text/plain"
			});
			response.end("No license");
			return false;
		}

		this.authenticate = function(request, response, _) {
			var credentials = basicMatchRegex.exec(request.headers.authorization)
			if (!(credentials && credentials[1])) return _unAuthenticated(request, response);

			var usrpwd = new Buffer(credentials[1], "base64").toString("utf8").split(":");
			if (usrpwd.length < 2) return _unAuthenticated(request, response);

			var user = usrpwd[0];
			var pass = usrpwd[1];
			if (!(user && pass)) return _unAuthenticated(request, response);

			var status = validatePassword(request.session, user, pass, null, "basic", standardConfig, _);

			switch (status) {
			case 1: return _unAuthenticated(request, response);
			case 2: return _unLicensed(request, response);
			case 0: break;
			default: // non-fatal error
				response.writeHead(406, {
					"Content-Type": "text/plain"
				});
				response.end(status);
				return false;
			}


			tracer && tracer("User authenticated.");
			// TODO: should not keep password around!
			request.session && request.session.afterAuthentication({
				user: user,
//				password: pass
			});
			return true;
		};
		this.forbidden = function(request, response) {
			response.writeHead(403, {
				"Content-Type": "text/plain"
			});
			response.end("Authorization Required");
		};
	}

}