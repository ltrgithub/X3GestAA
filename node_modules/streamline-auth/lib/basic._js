"use strict";

var helpers = require('syracuse-core/lib/helpers');
var tracer = helpers.debug.tracer("session.trace");
var config = require('syracuse-main/lib/nodeconfig').config;
var fs = require('streamline-fs');
var crypto = require('crypto');

var basicMatchRegex = /^[Bb]asic\s([a-zA-Z0-9\+\/]+\=*)/;

exports.create = function(validatePassword, standardConfig) {
	return new function() {
		function _unAuthenticated(request, response, options) {
			response.writeHead(401, {
				"Content-Type": "text/plain",
				"WWW-Authenticate": 'Basic realm=' + config.session.realm
			});
			response.end("Authorization Required");
			return false;
		}

		// apply hash function from RFC2617
		function computeHash(user, password) {
			var hash = crypto.createHash('MD5');
			var a1 = user + ":" + config.session.realm + ":" + password;
			hash.update(a1, 'binary');
			return hash.digest("hex");
		}

		function _unLicensed(request, response) {
			response.writeHead(402, {
				"Content-Type": "text/plain"
			});
			response.end("No license");
			return false;
		}

		this.authenticate = function(request, response, _) {
			if (request.specialLogin) return true;
			var credentials = basicMatchRegex.exec(request.headers.authorization);
			if (!(credentials && credentials[1])) return _unAuthenticated(request, response);

			var usrpwd = new Buffer(credentials[1], "base64").toString("binary");
			var index = usrpwd.indexOf(':');
			if (index < 0) return _unAuthenticated(request, response);

			var user = usrpwd.substr(0, index);
			var pass = usrpwd.substr(index + 1);

			if (!(user && pass)) return _unAuthenticated(request, response);

			var passHash = computeHash(user, pass);

			var status = validatePassword(request.session, user, passHash, null, "basic", standardConfig, _);
			switch (status) {
				case 1:
					return _unAuthenticated(request, response);
				case 2:
					return _unLicensed(request, response);
				case 3:
					return require('./changePassword').setPassword(request, response, user, _);
				case 0:
					break;
				default:
					// non-fatal error
					response.writeHead(406, {
						"Content-Type": "text/plain"
					});
					response.end("Status: " + status);
					return false;
			}

			tracer && tracer("User authenticated.");
			// TODO: should not keep password around!
			request.session && request.session.afterAuthentication({
				user: user,
				//				password: pass
			});
			return true;
		};

	};

};