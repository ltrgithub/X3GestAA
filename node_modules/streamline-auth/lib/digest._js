"use strict";

var helpers = require('syracuse-core/lib/helpers');
var tracer = helpers.debug.tracer("session.trace");
var crypto = require('crypto')

// store a nonce for 10 minutes
var NONCE_STORE_THRESHOLD = 600000;

// store nonce and time
var nonces = [];

function pushNonce(nonce) {
	var now = Date.now();
	while (nonces.length > 0 && now - nonces[0] > NONCE_STORE_THRESHOLD) {
		nonces.splice(0, 2);
	}
	nonces.push(now, nonce);
}

function getNonce(nonce) {
	
	var now = Date.now();
	while (nonces.length > 0 && now - nonces[0] > NONCE_STORE_THRESHOLD) {
		nonces.splice(0, 2);
	}
	nonces.push(now, nonce);	
}




function randomHex(len) {
	var n = Math.floor(Math.random() * (1 << 32));
	var s = n.toString(16);
	return s.length >= len ? s.substring(0, len) : ("00000000".substring(0, len - s.length) + s);
};

// hash function from RFC2617
function h(value) {
    var hash = crypto.createHash('MD5');
    hash.update(value, "utf8");
    return hash.digest("hex");
}


exports.create = function(validatePassword, standardConfig) {
  return new function() {
    function _unAuthenticated(request, response, options) {
      if (!options) options = {}
      if (!options.realm) options.realm = '"Syracuse1"';
      var nonce = randomHex(8)+randomHex(8)+randomHex(8)+randomHex(8)
      pushNonce(nonce);
      response.writeHead(401, {
        "Content-Type": "text/plain",
        "WWW-Authenticate": 'Digest realm=' + options.realm+', qop="auth", algorithm="MD5", nonce="'+nonce+'" opaque="00"'
      });
      response.end("Authorization required");
      return false;
    }

    function _unLicensed(request, response) {
    	response.writeHead(402, {
        "Content-Type": "text/plain"
      });
      response.end("No license");
      return false;
    }

    this.authenticate = function(request, response, _) {
    	var header = request.headers.authorization;
    	var auth = {};
        var re = /(\w+)\=(?:(\w+)|\"([^\"]*)\")/g;
        var r;
        while (r = re.exec(header)) {
            auth[r[1]] = (r[2] || "") + (r[3] || "");
        }
    	
      if (!auth.cnonce || auth.nc*1 !== 1) return _unAuthenticated(request, response);

    var status = validatePassword(request.session, auth.username, null, function(passwd) {
   	        var a1 = auth.username+":"+auth.realm+":"+passwd
    	    var a2 = request.method+":"+auth.uri;
   	 //    console.log("a1 "+a1+" a2 "+a2+ " "+auth.nc)
    	    var  result = h(h(a1)+":"+auth.nonce+":"+auth.nc+":"+auth.cnonce+":"+auth.qop+":"+h(a2));
  //  	    console.log(result+" - "+auth.response)
    	    return result === auth.response;
      }, "digest", standardConfig, _);

      switch (status) {
      case 1: return _unAuthenticated(request, response);
      case 2: return _unLicensed(request, response);
      }

      tracer && tracer("User authenticated.");
      // TODO: should not keep password around!
      request.session && request.session.afterAuthentication({
        user: auth.username,
//        password: pass
      });
      return true;
    };
    this.forbidden = function(request, response) {
      response.writeHead(403, {
        "Content-Type": "text/plain"
      });
      response.end("Authorization Required");
    };
  }

}