"use strict";
// authentication using HTTP digest (RFC2617)

var helpers = require('syracuse-core/lib/helpers');
var tracer = helpers.debug.tracer("session.trace");
var crypto = require('crypto');
var util = require('util');
var config = require('syracuse-main/lib/nodeconfig').config;
var locale = require('syracuse-core/lib/locale');
var basic = require('./basic');

//	store a nonce for 20 minutes
var NONCE_STORE_THRESHOLD = 1200000;

//store nonce and time. Old nonces will be cleared after NONCE_STORE_THRESHOLD milliseconds
var nonces = [];

// store a new nonce (and throw away old nonces)

function pushNonce(nonce) {
	var now = Date.now();
	while (nonces.length > 0 && now - nonces[0] > NONCE_STORE_THRESHOLD) {
		nonces.splice(0, 2);
	}
	nonces.push(now, nonce);
}

// search for a given nonce (then throw away old nonces). Result: true, if the nonce has been found.
// The found nonce will be removed

function getNonce(nonce) {
	var found = false;
	for (var i = 1; i < nonces.length; i += 2) {
		if (nonces[i] === nonce) {
			nonces.splice(i - 1, 2);
			found = true;
			break;
		}
	}
	var now = Date.now();
	while (nonces.length > 0 && now - nonces[0] > NONCE_STORE_THRESHOLD) {
		nonces.splice(0, 2);
	}
	return found;
}

// generate random hex string

function randomHex(len) {
	var n = Math.floor(Math.random() * (1 << 24));
	var s = n.toString(16);
	return s.length >= len ? s.substring(0, len) : ("00000000".substring(0, len - s.length) + s);
};

//hash function from RFC2617

function h(value) {
	var hash = crypto.createHash('MD5');
	hash.update(value, "utf8");
	return hash.digest("hex");
}

exports.create = function(validatePassword) {
	return new function() {
		function _unAuthenticated(_, request, response, reason) {
			var nonce = randomHex(6) + randomHex(6) + randomHex(6) + randomHex(6) + randomHex(6);
			pushNonce(nonce);
			response.writeHead(401, {
				"Content-Type": "text/html; charset=utf-8",
				"WWW-Authenticate": 'Digest realm="' + config.session.realm + '", qop="auth", algorithm="MD5", nonce="' + nonce + '", opaque="00"'
			});
			response.end(reason || basic.textUnauth(request, _));
			return false;
		}

		function _unLicensed(request, response, _) {
			response.writeHead(402, {
				"Content-Type": "text/html; charset=utf-8"
			});
			response.end(basic.textUnlicensed(request, _));
			return false;
		}

		this.authenticate = function(request, response, session, _) {
			var header = request.headers.authorization;
			var auth = {};
			var re = /(\w+)\=(?:(\w+)|\"([^\"]*)\")/g;
			var r;
			// get all items and values from authorization header
			while (r = re.exec(header)) {
				auth[r[1]] = (r[2] || "") + (r[3] || "");
			}

			// nonce must have been created before and must not have been used before
			if (!getNonce(auth.nonce)) return _unAuthenticated(_, request, response);

			// client nonce count must be 1
			if (!auth.cnonce || auth.nc * 1 !== 1) return _unAuthenticated(_, request, response);

			var status = validatePassword(_, request.session, auth.username, null, function(hashPasswd) {
				var a2 = request.method + ":" + auth.uri;
				var result = h(hashPasswd + ":" + auth.nonce + ":" + auth.nc + ":" + auth.cnonce + ":" + auth.qop + ":" + h(a2));
				return result === auth.response;
			}, "digest", request);

			switch (status) {
				case "unAuthenticated":
					// console.log("xxx "+status)
					return _unAuthenticated(_, request, response);
				case "noLicense":
				case "inactiveUser":
				case "noGroup":
				case "noRole":
					return basic.noAccess(_, request, response, status, auth.username);
				case "changePassword":
					return require('./changePassword').setPassword(request, response, auth.username, _);
					/*				case 4:
					// TODO: should return forbidden but the browser won't ask for credential anymore so wait to implement a login form
					return _unAuthenticated(_, request, response, locale.format(module, "inactiveUser", auth.username));
					*/
				case "ok":
					break;
				default:
					// non-fatal error
					response.writeHead(401, {
						"Content-Type": "text/plain"
					});
					response.end("Status: " + status);
					return false;
			}

			tracer && tracer("User authenticated.");
			// TODO: should not keep password around!
			request.session && request.session.afterAuthentication({
				user: auth.username,
				authorization: request.headers.authorization
			});
			return true;
		};
		this.forbidden = function(request, response, message) {
			response.writeHead(403, {
				"Content-Type": "text/plain"
			});
			response.end(message || locale.format(module, "unauth"));
		};
		this.unAuthenticated = function(request, response, _) {
			return _unAuthenticated(_, request, response);
		};
	};

};