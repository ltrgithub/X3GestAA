"use strict";

var lowerLetter = {},
	digit = {},
	LF = '\n'.charCodeAt(0),
	SP = ' '.charCodeAt(0),
	BSLASH = '\\'.charCodeAt(0),
	OPEN = '{'.charCodeAt(0),
	CLOSE = '}'.charCodeAt(0),
	DASH = '-'.charCodeAt(0),
	QUOTE = "\'".charCodeAt(0),
	STAR = "*".charCodeAt(0);

var encodingCharsets = {
	'77': '10000', //Mac ,macintosh Î÷Å·×Ö·û(Mac)
	'128': '932', //Shift Jis ,ANSI/OEM - Japanese, Shift-JIS 
	'130': '1361', //Johab,Korean (Johab) 
	'134': '936', //GB2312
	'136': '10002', //Big5
	'161': '1253', //Greek
	'162': '1254', //Turkish
	'163': '1258', //Vietnamese,ANSI/OEM - Vietnamese 
	'177': '1255', //Hebrw
	'178': '864', //Arabic
	'179': '864', //Arabic Traditional
	'180': '864', //Arabic user
	'181': '864', //Hebrew user
	'186': '775', //Baltic
	'204': '866', //Russian
	'222': '874', //Thai
	'255': '437' //OEM
};

(function() {
	function add(clas, chs, i) {
		chs.split('').forEach(function(ch) {
			clas[ch.charCodeAt(0) + (i || 0)] = true;
		});
	}
	for (var i = 0; i <= 9; i++) add(digit, '0', i);
	for (var i = 0; i < 26; i++) add(lowerLetter, 'a', i);
})();

function builder(error) {
	var group = [],
		stack = [group],
		level = 0,
		createfontlist = false,
		fonts = [],
		font;
	return {
		open: function() {
			var g = [];
			group.push(g);
			stack.push(g);
			group = g;
			if (createfontlist) {
				level++;
			}
		},
		close: function() {
			if (stack.length <= 1) error("too many }");
			group = stack.pop();
			group = stack[stack.length - 1];
			if (createfontlist) {
				level--;
				if (level === 0) createfontlist = false;
			}
		},

		text: function(str) {
			group.push(str);
		},

		control: function(word, arg) {
			var obj = {
				word: word
			};
			if (arg != null) obj.arg = arg;
			group.push(obj);
			if (word == 'fonttbl') {
				createfontlist = true;
				level++;
			}
			if (createfontlist) {
				switch (word.toLowerCase()) {
					case "f":
						font = fonts[arg] = new Object;
						break;
					case "fcharset":
						font.charset = arg;
						break;
					case "cpg":
						font.codepage = arg;
						break;
				}
			}
		},
		/*star: function() {
			group.push({word: "*"});
		},*/
		getFont: function(index) {
			return createfontlist ? undefined : fonts && fonts[index];
		},
		getResult: function() {
			if (stack.length !== 1) error("missing }");
			return stack[0][0];
		}
	};
}

function loadIconv() {
	require.async("tedious/node_modules/iconv-lite/lib/index", function(error, module) {
		if (error) {
			syra_alert.error(error);
			return;
		}
		return new module.iconv();
	});
}
// returns tree. s
// intermediate nodes are arrays and correspond to rtf groups ({ ...})
// leaf nodes are either
// * strings (text elements)
// * control directives { word: w, arg: a }
exports.parse = function(str) {
	str = str.replace(/\r\n/g, '\n');
	var pos = 0,
		begText = 0,
		len = str.length,
		line = 1,
		bld = builder(error),
		currFont,
		iconv = loadIconv();

	function error(msg) {
		var end = str.indexOf(/[\n>]/, pos);
		if (end < 0) end = str.length;
		return new Error("Invalid RTF: " + msg + " at line " + line + " near " + str.substring(pos, end));
	}

	function flush() {
		if (pos > begText) bld.text(str.substring(begText, pos));
	}

	while (pos < len) {
		var ch = str.charCodeAt(pos);
		switch (ch) {
			case BSLASH:
				flush();
				var beg = ++pos;
				while (lowerLetter[ch = str.charCodeAt(pos)]) pos++;
				if (pos > beg) {
					var word = str.substring(beg, pos),
						arg = undefined;
					if (ch === DASH || digit[ch]) {
						beg = pos;
						pos++;
						while (digit[ch = str.charCodeAt(pos)]) pos++;
						arg = parseInt(str.substring(beg, pos), 10);
					}
					if (ch === SP || ch === LF || (word === "u" && ch !== BSLASH && ch !== OPEN && ch !== CLOSE)) {
						pos++;
					}
					if (word.toLowerCase() === 'f') currFont = bld.getFont(arg);
					bld.control(word, arg);
				} else if (ch === QUOTE) {
					if (currFont && currFont.charset && currFont.charset !== 0 && encodingCharsets[currFont.charset]) {
						var symb = str.substring(pos + 1, pos + 3);
						pos = pos + 3;
						//Cater for multibyte symbols
						while (str.charCodeAt(pos) === BSLASH && str.charCodeAt(pos + 1) === QUOTE) {
							symb += str.substring(pos + 2, pos + 4);
							pos = pos + 4;
						}
						var test = encodingCharsets[currFont.charset];
						//var decodedText = iconv.decode(new Buffer(symb, "hex"), encodingCharsets[currFont.charset]);
						//bld.text(decodedText);
						bld.text(symb);
					} else {
						var symb = String.fromCharCode(parseInt(str.substring(pos + 1, pos + 3), 16));
						bld.text(symb);
						pos = pos + 3;
					}
				} else if (ch === STAR) {
					bld.control("*");
					pos++;
				}
				begText = pos;
				break;
			case OPEN:
				flush();
				bld.open();
				begText = ++pos;
				break;
			case CLOSE:
				flush();
				bld.close();
				begText = ++pos;
				break;
			case LF:
				flush(); // to discard newline from output
				line++;
				begText = ++pos;
				break;
			default:
				pos++;
		}
	}
	flush();
	return bld.getResult();
};