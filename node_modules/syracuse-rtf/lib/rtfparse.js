"use strict";

var lowerLetter = {},
digit = {},
LF = '\n'.charCodeAt(0),
	SP = ' '.charCodeAt(0),
	BSLASH = '\\'.charCodeAt(0),
	OPEN = '{'.charCodeAt(0),
	CLOSE = '}'.charCodeAt(0),
	DASH = '-'.charCodeAt(0),
	QUOTE = "\'".charCodeAt(0),
	STAR = "*".charCodeAt(0);

(function() {
	function add(clas, chs, i) {
		chs.split('').forEach(function(ch) {
			clas[ch.charCodeAt(0) + (i || 0)] = true;
		})
	}
	for (var i = 0; i <= 9; i++) add(digit, '0', i);
	for (var i = 0; i < 26; i++) add(lowerLetter, 'a', i);
})();

function builder(error) {
	var group = [],
		stack = [group];
	return {
		open: function() {
			var g = [];
			group.push(g);
			stack.push(g);
			group = g;
		},
		close: function() {
			if (stack.length <= 1) error("too many }");
			group = stack.pop();
			group = stack[stack.length - 1];
		},

		text: function(str) {
			group.push(str);
		},

		control: function(word, arg) {
			var obj = {
				word: word
			};
			if (arg != null) obj.arg = arg;
			group.push(obj);
		},

		/*star: function() {
			group.push({word: "*"});
		},*/

		getResult: function() {
			if (stack.length !== 1) error("missing }");
			return stack[0][0];
		}
	};
}

// returns tree. 
// intermediate nodes are arrays and correspond to rtf groups ({ ...})
// leaf nodes are either
// * strings (text elements)
// * control directives { word: w, arg: a }
exports.parse = function(str) {
	str = str.replace(/\r\n/g, '\n');
	var pos = 0,
		begText = 0,
		len = str.length,
		line = 1,
		bld = builder(error);

	function error(msg) {
		var end = str.indexOf(/[\n>]/, pos);
		if (end < 0) end = str.length;
		return new Error("Invalid RTF: " + msg + " at line " + line + " near " + str.substring(pos, end));
	}

	function flush() {
		if (pos > begText) bld.text(str.substring(begText, pos));
	}
	while (pos < len) {
		var ch = str.charCodeAt(pos);
		switch (ch) {
			case BSLASH:
				flush();
				var beg = ++pos;
				while (lowerLetter[ch = str.charCodeAt(pos)]) pos++;
				if (pos > beg) {
					var word = str.substring(beg, pos),
						arg = undefined;
					if (ch === DASH || digit[ch]) {
						beg = pos;
						pos++;
						while (digit[ch = str.charCodeAt(pos)]) pos++;
						arg = parseInt(str.substring(beg, pos), 10);
					}
					if (ch === SP || ch === LF || (word === "u" && ch !== BSLASH && ch !== OPEN && ch !== CLOSE)) {
						pos++;
					}
					bld.control(word, arg);
				} else if (ch === QUOTE) {

					var symb = String.fromCharCode(parseInt(str.substring(pos + 1, pos + 3), 16));
					bld.text(symb);
					pos = pos + 3;
				} else if (ch === STAR) {
					bld.control("*");
					pos++;
				}

				begText = pos;
				break;
			case OPEN:
				flush();
				bld.open();
				begText = ++pos;
				break;
			case CLOSE:
				flush();
				bld.close();
				begText = ++pos;
				break;
			case LF:
				flush(); // to discard newline from output
				line++;
				begText = ++pos;
				break;
			default:
				pos++;
		}
	}
	flush();
	return bld.getResult();
}