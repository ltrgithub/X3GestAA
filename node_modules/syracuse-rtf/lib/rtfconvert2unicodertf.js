"use strict";

var iconv = require('syracuse-rtf/lib/iconv');

var lowerLetter = {},
	digit = {},
	LF = '\n'.charCodeAt(0),
	SP = ' '.charCodeAt(0),
	BSLASH = '\\'.charCodeAt(0),
	OPEN = '{'.charCodeAt(0),
	CLOSE = '}'.charCodeAt(0),
	DASH = '-'.charCodeAt(0),
	QUOTE = "\'".charCodeAt(0),
	STAR = "*".charCodeAt(0),
	ACTUALQUOTE = "\\'";

var encodingCharsets = {
	'77': '10000', //Mac ,macintosh Î÷Å·×Ö·û(Mac)
	'128': '932', //Shift Jis ,ANSI/OEM - Japanese, Shift-JIS 
	'130': '1361', //Johab,Korean (Johab) 
	'134': '936', //GB2312
	'136': '10002', //Big5
	'161': '1253', //Greek
	'162': '1254', //Turkish
	'163': '1258', //Vietnamese,ANSI/OEM - Vietnamese 
	'177': '1255', //Hebrw
	'178': '864', //Arabic
	'179': '864', //Arabic Traditional
	'180': '864', //Arabic user
	'181': '864', //Hebrew user
	'186': '775', //Baltic
	'204': '866', //Russian
	'222': '874', //Thai
	'255': '437' //OEM
};

(function() {
	function add(clas, chs, i) {
		chs.split('').forEach(function(ch) {
			clas[ch.charCodeAt(0) + (i || 0)] = true;
		});
	}
	for (var i = 0; i <= 9; i++) add(digit, '0', i);
	for (var i = 0; i < 26; i++) add(lowerLetter, 'a', i);
})();

function builder(error) {
	var level = 0,
		createfontlist = false,
		fonts = [],
		font;
	return {
		open: function() {
			if (createfontlist) {
				level++;
			}
		},
		close: function() {
			if (createfontlist) {
				level--;
				if (level === 0) createfontlist = false;
			}
		},
		control: function(word, arg) {
			var obj = {
				word: word
			};
			if (arg != null) obj.arg = arg;
			if (word == 'fonttbl') {
				createfontlist = true;
				level++;
			}
			if (createfontlist) {
				switch (word.toLowerCase()) {
					case "f":
						font = fonts[arg] = new Object;
						break;
					case "fcharset":
						font.charset = arg;
						break;
					case "cpg":
						font.codepage = arg;
						break;
				}
			}
		},
		getFont: function(index) {
			return createfontlist ? undefined : fonts && fonts[index];
		}
	};
}

exports.parse = function(str) {
	if (str.indexOf(ACTUALQUOTE) > 0 && str.search(/fcharset[1-9]/i) > 0) {
		str = str.replace(/\r\n/g, '\n');
		var pos = 0,
			posi = 0,
			begText = 0,
			len = str.length,
			line = 1,
			bld = builder(error),
			currFont,
			startpos = 0,
			replacementText = '';

		function error(msg) {
			var end = str.indexOf(/[\n>]/, pos);
			if (end < 0) end = str.length;
			return new Error("Invalid RTF: " + msg + " at line " + line + " near " + str.substring(pos, end));
		}

		while (pos < len) {
			var ch = str.charCodeAt(pos);
			switch (ch) {
				case BSLASH:
					var beg = ++pos;
					while (lowerLetter[ch = str.charCodeAt(pos)]) pos++;
					if (pos > beg) {
						var word = str.substring(beg, pos),
							arg = undefined;
						if (ch === DASH || digit[ch]) {
							beg = pos;
							pos++;
							while (digit[ch = str.charCodeAt(pos)]) pos++;
							arg = parseInt(str.substring(beg, pos), 10);
						}
						if (ch === SP || ch === LF || (word === "u" && ch !== BSLASH && ch !== OPEN && ch !== CLOSE)) {
							pos++;
						}
						if (word.toLowerCase() === 'f') currFont = bld.getFont(arg);
						bld.control(word, arg);
					} else if (ch === QUOTE) {
						if (currFont && currFont.charset && currFont.charset !== 0 && encodingCharsets[currFont.charset]) {
							var symb = str.substring(pos + 1, pos + 3);
							startpos = pos - 1;
							pos = pos + 3;
							//Cater for multibyte symbols
							while (str.charCodeAt(pos) === BSLASH && str.charCodeAt(pos + 1) === QUOTE) {
								symb += str.substring(pos + 2, pos + 4);
								pos = pos + 4;
							}
							var decodedText = iconv.decode(new Buffer(symb, "hex"), encodingCharsets[currFont.charset]);
							posi = 0;
							replacementText = '\\uc0';
							while (posi < decodedText.length) {
								replacementText += '\\u' + decodedText.charCodeAt(posi);
								posi++;
							}
							replacementText = replacementText + ' ';
							str = str.substring(0, startpos) + replacementText + str.substring(pos, str.length);
						}
					}
					begText = pos;
					break;
				case OPEN:
					bld.open();
					begText = ++pos;
					break;
				case CLOSE:
					bld.close();
					begText = ++pos;
					break;
				case LF:
					line++;
					begText = ++pos;
					break;
				default:
					pos++;
			}
		}
	}
	return str;
};