"use strict";

// ===================================================================================================================================================
// ===================================================================================================================================================
// ===================================================================================================================================================
// ===================================================================================================================================================
//	<div class="s-rtf-root">
//	<div class="s-rtf-section">
//		<p></p>
//		<p></p>
//	</div>
//	<div class="s-rtf-section">
//		<ul>
//			<li></li>
//			<li></li>
//			<li></li>
//		</ul>
//	</div>
//</div>
var styleName = {
	cf: "color",
	cb: "background-color",
	highlight: "background-color"
};

function rgbToHex(rgb) {
	if (rgb) {
		return toHex(rgb[0]) + toHex(rgb[1]) + toHex(rgb[2]);
	} else {
		return "000000"; //default color
	}
}

function toHex(n) {
	return ("00" + n.toString(16)).slice(-2);
}

function twipsToPoint(t) {
	return t / 20;
}

function indentCount(t) {
	return t / 600;
}

function indentBulletCount(t) {
	return t / 420;
}

function twipsToPixel(t) {
	return t / 15;
}

function builder(documentModel) {
	var rtffonts = documentModel.fonts,
		deffont = documentModel.deffont,
		colors = documentModel.colors,
		styles = documentModel.styles,
		htmltext = "",
		$rootdiv = $("<div>").addClass('s-rtf-root'),
		$current = null,
		$section = null,
		$worker = null,
		context;

	newSection();

	function newWorker() {
		$current = $worker = $("<div>").addClass('s-rtf-worker').addClass('s-rtf-clean');
		return $worker.appendTo($section);
	}

	function newSection() {
		$section = $("<div>").addClass('s-rtf-section').addClass('s-rtf-clean');
		newWorker();
		return $section.appendTo($rootdiv);
	}

	function characterFormatting(node) {
		switch (node.word) {

			case "f":
				/*case "pnf":*/
				var fontface = rtffonts[node.word + node.arg].name;
				return $("<font face='" + fontface + "'>");

			case "fs":
				//case "pnfs":
				return $("<span style='font-size: " + node.arg / 2 + "pt;'>");
			case "tab":
				//case "pnfs":
				//return $("<span style='margin-left: 10pt'>");//be  carrefull depending on navigator
				return $("<blockquote>"); //be  carrefull depending on navigator
			case "cf":
				//if(!node.arg) return null;
				return $("<span style='" + styleName[node.word] + ": #" + rgbToHex(colors[node.arg]) + ";'>");
			case "cb":
			case "highlight":
				if (!node.arg) return $("<span style='background-color: transparent;'>");
				// do not use css() because it converts hex value into rgb style
				// return $("<span>").css(styleName[node.word], "#" + rgbToHex(colors[node.arg]));
				return $("<span style='" + styleName[node.word] + ": #" + rgbToHex(colors[node.arg]) + ";'>");

			case "b":
				return $("<b>");
			case "i":
				return $("<i>");
			case "ul":
				return $("<u>");
			case "strike":
				return $("<s>");
				/*
		case "plain":
			return ["<pre>", "</pre>"];
		case "list":
			return ["<ul>", "</ul>"];
		case "pntext":*/
				/*case "bullet":
			return $("<li>");
		case "line":
			return $("<br>");*/
			default:
				// ; //$("");
		}
	}

	function paragraphFormatting(elt, node) {
		elt.addClass('s-rtf-format');

		dirty();

		switch (node.word) {
			case "ql":
				return elt.attr("align", "left");
			case "qc":
				return elt.attr("align", "center");
			case "qr":
				return elt.attr("align", "right");
			case "qj":
				return elt.attr("align", "justify");
			case "li":
				// return elt.css("margin-left", twipsToPixel(node.arg) + "px");
				if (node.arg > 0)
					return elt.css("margin-left", twipsToPoint(node.arg) + "pt");
				else
					return elt;
			case "ri":
				// return elt.css("margin-right", twipsToPixel(node.arg) + "px");
				if (node.arg > 0)
					return elt.css("margin-right", twipsToPoint(node.arg) + "pt");
				else
					return elt;
			default:
				return elt;
		}

	}

	function dirty() {
		$worker && $worker.removeClass("s-rtf-clean");
		// if we want to always have a paragraph, uncomment this line
		// $worker && $worker.addClass("s-rtf-paragraph");
		$section && $section.removeClass("s-rtf-clean");
	}

	function append(elt) {
		dirty();
		$current.append(elt);
	}

	function wrapIn(elt) {
		dirty();
		$current = elt.appendTo($current);
	}

	context = (function() {
		var stack = [{
			format: {}
		}],
			current = stack[0];

		function flattenFormat() {
			var f, fmt = {};
			stack.forEach(function(ctx) {
				f = ctx.format;
				Object.keys(f).forEach(function(key) {
					if (typeof(fmt[key]) === "undefined" || typeof(fmt[key]) === typeof(f[key])) {
						fmt[key] = f[key];
					}
				});
			});
			return fmt;
		}

		return {
			open: function() {
				stack.push(current = {
					format: {}
				});
			},

			close: function(idx, parent) {
				stack.pop();
				current = stack[stack.length - 1];
				if (idx < parent.length - 1) {
					this.pending = true;
				}
			},

			update: function(prop, el) {
				if (el === null) {
					delete current.format[prop];
				} else {
					current.format[prop] = el;
				}
			},

			startOver: function() {
				if (!this.pending) return;
				var fmt = flattenFormat();
				Object.keys(fmt).forEach(function(key) {
					$current = fmt[key].clone().appendTo($current);
				});
				this.pending = false;
			}
		};
	})();

	return {
		text: function(str) {
			dirty();
			context && context.startOver();
			var content = $current.html();
			// Safe as long as str is sanitized before calling
			$current.html(content + str);
		},

		open: function() {
			context.open();
		},

		close: function(idx, parent) {
			$current = $worker;
			if ($current.length === 0) $current = $rootdiv;
			context.close(idx, parent);
		},

		control: function(node) {
			switch (node.word) {

				case "par":
					dirty();
					$worker.removeClass("s-rtf-worker").addClass("s-rtf-paragraph");
					$current = $worker = newWorker();
					context && (context.pending = true);
					break;

				case "pard":
					if (!$section.hasClass("s-rtf-clean")) {
						$section = newSection();
						context && (context.pending = true);
					}
					break;

				case "pn":
					$section.addClass("s-rtf-list");
					break;

				case "u":
					this.unicodechar(node.arg);
					break;

				case "qc":
				case "ql":
				case "qr":
				case "qj":
				case "ri":
					paragraphFormatting($section, node);
					break;
				case "li":
					if ($section.hasClass("s-rtf-list")) {
						$section.attr("indent", indentBulletCount(node.arg));
					} else {
						if (!$section.hasClass("s-rtf-clean") && !$section.hasClass("s-rtf-format")) {
							$section = newSection();
							context && (context.pending = true);
						}
						$section.addClass("s-rtf-left-indent");
						$section.attr("indent", indentCount(node.arg));
					}
					break;
				case "lquote":
				case "rquote":
					this.text("'");
					break;

				case "line":
					append("<br>");
					break;
				case "bullet":
					// var el = $("<li>");
					// var dd = 1;
					// if ($current.is("li")) {
					//	$current.parent().append(el);
					// } else {
					//	$current.append(el);
					// }
					// $current = el;
					break;

				case "i":
				case "b":
				case "strike":
				case "ulnone":
				case "ul":
					if (node.arg === 0 || node.word === "ulnone") {
						var tagname;
						if (node.word === "strike") {
							tagname = "s";
						} else if (node.word === "ulnone") {
							tagname = "u";
							node.word = "ul";
						} else {
							tagname = node.word;
						}
						if ($current.is(tagname)) {
							$current = $current.parent();
						} else {
							if ($current.html() !== "") {
								var tag = $current.closest(tagname);
								$current = tag.parent();
							}
						}

						context.update(node.word, null);
						break;
					}
				default:
					var el = characterFormatting(node);

					if (el) {
						context.update(node.word, el.clone());
						!context.pending && wrapIn(el);
					}
			}
			//console.log(node.word + "\n"+$rootdiv.html())
		},
		unicodechar: function(code) {
			dirty();
			context && context.startOver();
			var content = $current.html();
			$current.html(content + String.fromCharCode(+code || 0xfffd));
		},
		getHtml: function() {
			//console.log($rootdiv.html())
			// cleanup
			$rootdiv.find(".s-rtf-clean").remove();
			// replace <div> by <ul>
			var sections = $rootdiv.find(".s-rtf-section.s-rtf-list") //.removeAttr("class");
			sections.map(function(i, e) {
				var $e = $(e);
				var i = parseInt($e.attr("indent"), 10);
				var w = [];
				while (w.length < i) {
					w.push("<ul>");
				}
				$e.wrap(w.join("")).contents();
				//$e.removeAttr("indent");
			});
			var workers = sections.find(".s-rtf-paragraph");
			workers.wrap("<li>").contents().unwrap();
			//sections.unwrap();
			var indent = $rootdiv.find(".s-rtf-section.s-rtf-left-indent").removeClass("s-rtf-left-indent");
			indent.map(function(i, e) {
				var $e = $(e);
				var i = parseInt($e.attr("indent"), 10);
				var w = [];
				while (w.length < i) {
					w.push("<blockquote>");
				}
				$e.wrap(w.join("")).contents();
				$e.removeAttr("indent");
			});



			sections = $rootdiv.find(".s-rtf-section");

			// replace <div> by <p>
			sections.find(".s-rtf-paragraph").removeAttr("class").wrap("<p>").contents().unwrap();
			sections.find("div:empty").remove();



			// cleanup
			sections.find(".s-rtf-worker:empty").remove();
			sections.filter(":not(.s-rtf-format)").contents().unwrap();
			while ($rootdiv.find("span:empty").length) {
				$rootdiv.find("span:empty").remove();
			};
			$rootdiv.find(".s-rtf-worker").removeAttr("class").contents().unwrap();
			$rootdiv.find(".s-rtf-format").removeAttr("class");

			return $rootdiv.html().replace(/<p><\/p>/gi, "<br>").replace(/  /gi, " &nbsp;");
		}
	};
}

// HTML builder
exports.buildHtml = function(root, documentModel) {
	var bld = builder(documentModel);

	function interpretNode(node, index, array) {
		if (typeof node == "string") {
			bld.text(node);
			return;
		}
		if (Array.isArray(node) && node.length > 0) {
			if (node[0]) {
				switch (node[0].word) {
					case 'fonttbl':
					case 'colortbl':
					case 'stylesheet':
					case 'pntxtb':
					case 'pntext':
					case 'pict':
						return;
				}
			}
			bld.open();
			node.forEach(interpretNode);
			bld.close(index, array);

			return;
		}

		if (typeof(node) === "object") {
			bld.control(node);

		}
	}

	interpretNode(root, 0, []);
	if (!root) return "";
	return bld.getHtml();
};