"use strict";
var alt = true;

function builder(documentModel) {
	var rtffonts;
	var deffont;
	var colors;
	var htmltext = "";

	var rootdiv = $("<div>"),
		current = rootdiv;

	//var context ;
	rtffonts = documentModel.fonts;
	deffont = documentModel.deffont;
	colors = documentModel.colors;


	function rgbToHex(r, g, b) {
		return toHex(r) + toHex(g) + toHex(b)
	}

	function toHex(n) {
		return ("00" + n.toString(16)).slice(-2);
	}

	function characterFormatting(node) {

		switch (node.word) {

		case "f":
			/*case "pnf":*/
			//return ["<span class='"+node.word+node.arg+"'>","</span>"] ;
			var fontface = rtffonts[node.word + node.arg].name;
			return $("<font face='" + fontface + "'>");

		case "fs":
			//case "pnfs":
			//return ["<span style='font-size:" + Math.round(node.arg / 2) + "pt'>", "</span>"];
			return $("<span style='font-size:" + node.arg / 2 + "pt;'>");

		case "cf":
			var hexcolor;
/*if (node.arg==0 )
				hexcolor =rgbToHex(0, 0, 0);
			else {*/
			var r = colors[node.arg][0];
			var g = colors[node.arg][1];
			var b = colors[node.arg][2];
			hexcolor = rgbToHex(r, g, b);
			//}
			// return $("<font color='#" + hexcolor + "'>");
			// return $("<span style='color:rgb(" + r + "," + g + "," + b + ");'>");
			return $("<span style='color:#" + hexcolor + ";'>");

		case "highlight":
			var hexcolor;
/*if (node.arg==0 )
				hexcolor =rgbToHex(0, 0, 0);
			else {*/
			var r = colors[node.arg][0];
			var g = colors[node.arg][1];
			var b = colors[node.arg][2];
			var hexcolor = rgbToHex(r, g, b);
			//}
			return $("<span style='background-color:#" + hexcolor + ";'>");

		case "b":
			return $("<b>");
		case "i":
			return $("<i>");
		case "ul":
			return $("<u>");
		case "strike":
			return $("<s>");
/*
		case "plain":
			return ["<pre>", "</pre>"];
		case "list":
			return ["<ul>", "</ul>"];
		case "pntext":*/
/*case "bullet":
			return $("<li>");
		case "line":
			return $("<br>");*/
		default:
			; //$("");
		}
	};

	function paragraphFormatting(node) {

		switch (node.word) {
		case "ql":
			return $("<div align='left'>");
		case "qc":
			return $("<div align='center'>");
		case "qr":
			return $("<div align='right'>");
		case "qj":
			return $("<div align='justify'>");
		case "li":
			return $("<div style='left-margin:'" + node.arg / 15 + "px>");
		case "ri":
			return $("<div style='right-margin:'" + node.arg / 15 + "px>");
		}
	};

	function paragraphFormattingStyle(node) {

		switch (node.word) {
		case "ql":
			return ["align", "left"];
		case "qc":
			return ["align", "center"];
		case "qr":
			return ["align", "right"];
		case "qj":
			return ["align", "justify"];
		case "li":
			return ["style", "left-margin:" + node.arg / 15 + "px"];
		case "ri":
			return ["style", "right-margin:" + node.arg / 15 + "px"];
		default:
			return ["", ""];
		}
	};


	function recoverContext() {

		var prop = this._getColor()
		if (prop != null) {
			var prop1 = prop.clone();
			current.append(prop1);
			current = prop1;
		}
		prop = this._getFontSize()
		if (prop != null) {
			var prop1 = prop.clone();
			current.append(prop1);
			current = prop1;
		}
		prop = this._getFontFace()
		if (prop != null) {
			var prop1 = prop.clone();
			current.append(prop1);
			current = prop1;
		}
		prop = this._getBold()
		if (prop != null) {
			var prop1 = prop.clone();
			current.append(prop1);
			current = prop1;
		}
		prop = this._getItalic()
		if (prop != null) {
			var prop1 = prop.clone();
			current.append(prop1);
			current = prop1;
		}
		prop = this._getUnderlined()
		if (prop != null) {
			var prop1 = prop.clone();
			current.append(prop1);
			current = prop1;
		}
		prop = this._getStrike()
		if (prop != null) {
			var prop1 = prop.clone();
			current.append(prop1);
			current = prop1;
		}
	};


	return {

		text: function(str) {
			var content = current.html();
			current.html(content + str);
		},
		open: function() {
			this.context = {
				parent: this.context || null,
				format: {}
			};

			// if (rootdiv === null) {
			// 	rootdiv = $("<div></div>");
			// 	current = rootdiv;
			// }
		},
		close: function(idx, parent) {
			this.context = this.context.parent;
			current = rootdiv.find("p:last");
			if (current.size() === 0) current = rootdiv;
			if (idx < parent.length - 1) recoverContext.apply(this);
		},

		_updateContext: function(prop, el) {
			this.context.format[prop] = el;
		},


		control: function(node, context) {
			switch (node.word) {

			case "par":
				var newpar = $("<p>");

				var cur = current.closest("div.parformat");
				if (cur.size() === 0) cur = rootdiv.find("p:last").parent();
				if (cur.size() === 0) cur = rootdiv;
				cur.append(newpar);
				current = newpar;

				recoverContext.apply(this);

				break;
			case "pard":
				var currentpar = rootdiv.find("p:last");

				if (false) {
					// TODO: review this because the test was wrong and the correction introduce a bug!
					// if (currentpar.size() === 0) {
					currentpar = $("<p>");
					current.append(currentpar);
				} else {
					var parent = currentpar.parent();
					if (parent.is("div.parformat")) {
						parent = parent.parent();
						currentpar.detach();
						parent.append(currentpar);
					}
				}
				break;

			case "u":
				this.unicodechar(node.arg);
				break;

			case "qc":
			case "ql":
			case "qr":
			case "qj":
			case "li":
			case "ri":

				var p = rootdiv.find("p:last");
				if (p.size() === 0) {
					p = $("<p>");
					current.append(p);
				}

				var pparent = p.parent();
				var el;
				if (pparent.is('div.parformat')) {
					el = pparent;
					var attribute = paragraphFormattingStyle(node);
					el.attr(attribute[0], attribute[1]);
				} else {
					el = paragraphFormatting(node);
					el.addClass('parformat');
					p.detach();
					el.append(p);
					pparent.append(el);
				}
				break;

			case "line":
				current.append("<br>");
				break;
			case "bullet":
				var el = $("<li>");
				var dd = 1;
				if (current.is("li")) current.parent().append(el);
				else current.append(el);
				current = el;
				break;

			case "i":
			case "b":
			case "strike":
			case "ulnone":
			case "ul":
				if (node.arg === 0 || node.word === "ulnone") {
					var tagname;
					if (node.word === "strike") tagname = "s";
					else if (node.word === "ulnone") tagname = "u";
					tagname = node.word;
					if (current.is(tagname)) {
						current = current.parent();
					} else {
						var tag = current.closest(tagname);
						current = tag.parent();
					}


					this._updateContext(node.word, null);

					break;
				}


			default:
				var el = characterFormatting(node);


				if (el != null) {
					var douplicat = characterFormatting(node);

					this._updateContext(node.word, douplicat);
					current.append(el);
					current = el;
				}
			}
		},
		unicodechar: function(code) {
			var content = current.html();
			current.html(content + String.fromCharCode(code));
		},

		getHtml: function() {
			$rootdiv.find(".parformat").removeClass("parformat");
			var ss = rootdiv.html();
			return rootdiv.html();
		},
		_getColor: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getColor(this.context);
			return context && (context.format.color || this._getColor(context.parent));
		},
		_getFontSize: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getFontSize(this.context);
			return context && (context.format.fs || this._getFontSize(context.parent));
		},
		_getFontFace: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getFontFace(this.context);
			return context && (context.format.f || this._getFontFace(context.parent));
		},
		_getBackgroundColor: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getBackgroundColor(this.context);
			return context && (context.format.highlight || this._getBackgroundColor(context.parent));
		},
		_getBold: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getBold(this.context);
			return context && (context.format.b || this._getBold(context.parent));
		},
		_getItalic: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getItalic(this.context);
			return context && (context.format.i || this._getItalic(context.parent));
		},
		_getUnderlined: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getUnderlined(this.context);
			return context && (context.format.u || this._getUnderlined(context.parent));
		},
		_getStrike: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getStrike(this.context);
			return context && (context.format.s || this._getStrike(context.parent));
		}
	};
};

// ===================================================================================================================================================
// ===================================================================================================================================================
// ===================================================================================================================================================
// ===================================================================================================================================================

function builder2(documentModel) {
	var rtffonts = documentModel.fonts,
		deffont = documentModel.deffont,
		colors = documentModel.colors,
		htmltext = "",
		$rootdiv = $("<div>").addClass('s-rtf-root'),
		$current = $rootdiv,
		$worker = newWorker(), // Gather elements
		$section = newSection(), // Gather formating
		paragraph = {};

	function newWorker(){
		return $("<div>").addClass('s-rtf-worker');
	}

	function newSection(){
		return $("<div>").addClass('s-rtf-section');
	}

	function rgbToHex(r, g, b) {
		return toHex(r) + toHex(g) + toHex(b)
	}

	function toHex(n) {
		return ("00" + n.toString(16)).slice(-2);
	}

	function characterFormatting(node) {

		switch (node.word) {

		case "f":
			/*case "pnf":*/
			//return ["<span class='"+node.word+node.arg+"'>","</span>"] ;
			var fontface = rtffonts[node.word + node.arg].name;
			return $("<font face='" + fontface + "'>");

		case "fs":
			//case "pnfs":
			//return ["<span style='font-size:" + Math.round(node.arg / 2) + "pt'>", "</span>"];
			return $("<span style='font-size:" + node.arg / 2 + "pt;'>");

		case "cf":
			var hexcolor;
/*if (node.arg==0 )
				hexcolor =rgbToHex(0, 0, 0);
			else {*/
			var r = colors[node.arg][0];
			var g = colors[node.arg][1];
			var b = colors[node.arg][2];
			hexcolor = rgbToHex(r, g, b);
			//}
			// return $("<font color='#" + hexcolor + "'>");
			// return $("<span style='color:rgb(" + r + "," + g + "," + b + ");'>");
			return $("<span style='color:#" + hexcolor + ";'>");

		case "highlight":
			var hexcolor;
/*if (node.arg==0 )
				hexcolor =rgbToHex(0, 0, 0);
			else {*/
			var r = colors[node.arg][0];
			var g = colors[node.arg][1];
			var b = colors[node.arg][2];
			var hexcolor = rgbToHex(r, g, b);
			//}
			return $("<span style='background-color:#" + hexcolor + ";'>");

		case "b":
			return $("<b>");
		case "i":
			return $("<i>");
		case "ul":
			return $("<u>");
		case "strike":
			return $("<s>");
/*
		case "plain":
			return ["<pre>", "</pre>"];
		case "list":
			return ["<ul>", "</ul>"];
		case "pntext":*/
/*case "bullet":
			return $("<li>");
		case "line":
			return $("<br>");*/
		default:
			; //$("");
		}
	};

	function paragraphFormatting(node) {

		switch (node.word) {
		case "ql":
			return $("<div align='left'>");
		case "qc":
			return $("<div align='center'>");
		case "qr":
			return $("<div align='right'>");
		case "qj":
			return $("<div align='justify'>");
		case "li":
			return $("<div style='left-margin:'" + node.arg / 15 + "px>");
		case "ri":
			return $("<div style='right-margin:'" + node.arg / 15 + "px>");
		}
	};

	function paragraphFormattingStyle(node) {

		switch (node.word) {
		case "ql":
			return ["align", "left"];
		case "qc":
			return ["align", "center"];
		case "qr":
			return ["align", "right"];
		case "qj":
			return ["align", "justify"];
		case "li":
			return ["style", "left-margin:" + node.arg / 15 + "px"];
		case "ri":
			return ["style", "right-margin:" + node.arg / 15 + "px"];
		default:
			return ["", ""];
		}
	};


	function recoverContext() {

		var prop = this._getColor()
		if (prop != null) {
			var prop1 = prop.clone();
			$current.append(prop1);
			$current = prop1;
		}
		prop = this._getFontSize()
		if (prop != null) {
			var prop1 = prop.clone();
			$current.append(prop1);
			$current = prop1;
		}
		prop = this._getFontFace()
		if (prop != null) {
			var prop1 = prop.clone();
			$current.append(prop1);
			$current = prop1;
		}
		prop = this._getBold()
		if (prop != null) {
			var prop1 = prop.clone();
			$current.append(prop1);
			$current = prop1;
		}
		prop = this._getItalic()
		if (prop != null) {
			var prop1 = prop.clone();
			$current.append(prop1);
			$current = prop1;
		}
		prop = this._getUnderlined()
		if (prop != null) {
			var prop1 = prop.clone();
			$current.append(prop1);
			$current = prop1;
		}
		prop = this._getStrike()
		if (prop != null) {
			var prop1 = prop.clone();
			$current.append(prop1);
			$current = prop1;
		}
	};


	return {

		text: function(str) {
			var content = $current.html();
			$current.html(content + str);
		},
		open: function() {
			this.context = {
				parent: this.context || null,
				format: {}
			};
		},
		close: function(idx, parent) {

			this.context = this.context.parent;
			$current = $rootdiv.find("p:last");
			if ($current.size() === 0) $current = $rootdiv;
			if (idx < parent.length - 1) recoverContext.apply(this);
		},

		_updateContext: function(prop, el) {
			this.context.format[prop] = el;
		},


		control: function(node, context) {
			switch (node.word) {

			case "par":
				var newpar = $("<p>");

				var cur = $current.closest("div.s-rtf-section");
				if (cur.size() === 0) cur = $rootdiv.find("p:last").parent();
				if (cur.size() === 0) cur = $rootdiv;
				if (paragraph.$$list) {
					var par = $current.closest("p");
					var li = null;
					if (par.size() === 0) {
						var p = paragraph.$$list.parent();
						// paragraph.$$list.detach();
						// li = $("<li>").append(cur.children());
						// p.prepend(paragraph.$$list);
					}
					// else
					// 	li = $("<li>").append(par.children());
					// paragraph.$$list.append(li);
				}

				cur.append(newpar);
				$current = newpar;

				recoverContext.apply(this);

				break;
			case "pard":
				var currentpar = $rootdiv.find("p:last");

				if (false) {
					// TODO: review this because the test was wrong and the correction introduce a bug!
					// if (currentpar.size() === 0) {
					currentpar = $("<p>");
					$current.append(currentpar);
				} else {
					var parent = currentpar.parent();
					if (parent.is("div.s-rtf-section")) {
						parent = parent.parent();
						currentpar.detach();
						parent.append(currentpar);
					}
				}
				paragraph.$$list = undefined;
				break;

			case "pn":
				var div = $current.closest("div.s-rtf-section");
				if (div.size() === 0) div = $rootdiv.find("p:last").parent();
				if (div.size() === 0) div = $rootdiv; //$current ;
				if (!paragraph.$$list) {
					paragraph.$$list = $("<ul>");
					div.append(paragraph.$$list);
				}
				break;


			case "u":
				this.unicodechar(node.arg);
				break;

			case "qc":
			case "ql":
			case "qr":
			case "qj":
			case "li":
			case "ri":

				var p = $rootdiv.find("p:last");
				if (p.size() === 0) {
					p = $("<p>");
					$current.append(p);
				}

				var pparent = p.parent();
				var el;
				if (pparent.is('div.s-rtf-section')) {
					el = pparent;
					var attribute = paragraphFormattingStyle(node);
					el.attr(attribute[0], attribute[1]);
				} else {
					el = paragraphFormatting(node);
					el.addClass('s-rtf-section');
					p.detach();
					el.append(p);
					pparent.append(el);
				}
				break;

			case "line":
				$current.append("<br>");
				break;
			case "bullet":
				var el = $("<li>");
				var dd = 1;
				if ($current.is("li")) $current.parent().append(el);
				else $current.append(el);
				$current = el;
				break;

			case "i":
			case "b":
			case "strike":
			case "ulnone":
			case "ul":
				if (node.arg === 0 || node.word === "ulnone") {
					var tagname;
					if (node.word === "strike") tagname = "s";
					else if (node.word === "ulnone") tagname = "u";
					tagname = node.word;
					if ($current.is(tagname)) {
						$current = $current.parent();
					} else {
						var tag = $current.closest(tagname);
						$current = tag.parent();
					}


					this._updateContext(node.word, null);

					break;
				}


			default:
				var el = characterFormatting(node);


				if (el != null) {
					var douplicat = characterFormatting(node);

					this._updateContext(node.word, douplicat);
					$current.append(el);
					$current = el;
				}
			}
		},
		unicodechar: function(code) {
			var content = $current.html();
			$current.html(content + String.fromCharCode(code));
		},

		getHtml: function() {
			$rootdiv.find(".s-rtf-section").removeClass("s-rtf-section");
			var ss = $rootdiv.html();
			return $rootdiv.html();
		},
		_getColor: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getColor(this.context);
			return context && (context.format.color || this._getColor(context.parent));
		},
		_getFontSize: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getFontSize(this.context);
			return context && (context.format.fs || this._getFontSize(context.parent));
		},
		_getFontFace: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getFontFace(this.context);
			return context && (context.format.f || this._getFontFace(context.parent));
		},
		_getBackgroundColor: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getBackgroundColor(this.context);
			return context && (context.format.highlight || this._getBackgroundColor(context.parent));
		},
		_getBold: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getBold(this.context);
			return context && (context.format.b || this._getBold(context.parent));
		},
		_getItalic: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getItalic(this.context);
			return context && (context.format.i || this._getItalic(context.parent));
		},
		_getUnderlined: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getUnderlined(this.context);
			return context && (context.format.u || this._getUnderlined(context.parent));
		},
		_getStrike: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getStrike(this.context);
			return context && (context.format.s || this._getStrike(context.parent));
		}
	};
}

// HTML builder
exports.buildHtml = function(root, documentModel) {
	var bld = alt ? builder2(documentModel) : builder(documentModel);
	var stack = [];
	var paragraphFormat = "";

	function interpretNode(node, index, array) {
		if (typeof node == "string") {
			bld.text(node);
			return;
		}
		if (Array.isArray(node) && node.length > 0) {
			if (node[0]) {
				switch (node[0].word) {
				case 'fonttbl':
				case 'colortbl':
				case 'pntxtb':
				case 'pntext':
					return;
				}
			}

			bld.open();
			node.forEach(interpretNode);
			bld.close(index, array);
		}

		if (typeof node === "object") {
			bld.control(node);
		}
	};

	interpretNode(root, 0, []);
	if (!root) return "<div></div>";
	return bld.getHtml();
};