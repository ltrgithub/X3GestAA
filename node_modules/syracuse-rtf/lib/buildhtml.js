"use strict";

function builder(documentModel) {
	var rtffonts;
	var deffont;
	var colors;
	var htmltext = "";

	var rootdiv = null;
	var current = null;

	//var context ;


	rtffonts = documentModel.fonts;
	deffont = documentModel.deffont;
	colors = documentModel.colors;



	function rgbToHex(r, g, b) {
		return toHex(r) + toHex(g) + toHex(b)
	}

	function toHex(n) {
		return ("00" + n.toString(16)).slice(-2);
	}

	function characterFormatting(node) {

		switch (node.word) {

		case "f":
			/*case "pnf":*/
			//return ["<span class='"+node.word+node.arg+"'>","</span>"] ;
			var fontface = rtffonts[node.
			word + node.arg].name;
			return $("<font face='" + fontface + "'>");
			//($(roothtml).children().filter("p:last")[0]).appendChild(el);
		case "fs":
			//case "pnfs":
			//return ["<span style='font-size:" + Math.round(node.arg / 2) + "pt'>", "</span>"];
			return $("<span style='font-size:" + node.arg / 2 + "pt'>");
			//return ["<span style= 'font-size:"+Math.round(node.arg/2)+"pt'>", "</span>"] ;
		case "cf":
			var hexcolor ;
			/*if (node.arg==0 )
				hexcolor =rgbToHex(0, 0, 0);
			else {*/
				var r = colors[node.arg][0];
				var g = colors[node.arg][1];
				var b = colors[node.arg][2];
				 hexcolor = rgbToHex(r, g, b);
			//}
			return $("<font color='#" + hexcolor + "'>");
		case "highlight":
		var hexcolor ;
			/*if (node.arg==0 )
				hexcolor =rgbToHex(0, 0, 0);
			else {*/
			var r = colors[node.arg][0];
			var g = colors[node.arg][1];
			var b = colors[node.arg][2];
			var  hexcolor = rgbToHex(r, g, b);
			//}
			return $("<span style='background-color:#" + hexcolor + "'>");

		case "b":
			return $("<b>");
		case "i":
			return $("<i>");
		case "ul":
			return $("<u>");
		case "strike":
			return $("<s>");
			/*
		case "plain":
			return ["<pre>", "</pre>"];
		case "list":
			return ["<ul>", "</ul>"];
		case "pntext":*/
		/*case "bullet":
			return $("<li>");
		case "line":
			return $("<br>");*/
		default:
			; //$("");
		}
	};

	function paragraphFormatting(node) {

		switch (node.word) {
		case "ql":
			return $("<div align='left'>");
		case "qc":
			return $("<div align='center'>");
		case "qr":
			return $("<div align='right'>");
		case "qj":
			return $("<div align='justify'>");
		case "li":
			return $("<div style='left-margin:'" + node.arg / 15 + "px>");
		case "ri":
			return $("<div style='right-margin:'" + node.arg / 15 + "px>");
			/*case "ri" :
			return $("<div style='right-margin:'"+node.arg/15+"px></div>");*/
		}
	};

	function paragraphFormattingStyle(node) {

		switch (node.word) {
		case "ql":
			return ["align", "left"];
		case "qc":
			return ["align", "center"];
		case "qr":
			return ["align", "right"];
		case "qj":
			return ["align", "justify"];
		case "li":
			return ["style", "left-margin:" + node.arg / 15 + "px"];
		case "ri":
			return ["style", "right-margin:" + node.arg / 15 + "px"];
			/*case "ri" :
			return $("<div style='right-margin:'"+node.arg/15+"px></div>");*/
		default:
			return ["", ""];
		}
	};



	function recoverContext() {

				var prop=this._getColor()
				if ( prop!=null) {
					var prop1=prop.clone() ;
					current.append (prop1) ;
					current=prop1 ;
				}
				 prop=this._getFontSize()
				if ( prop!=null) {
					var prop1=prop.clone() ;
					current.append (prop1) ;
					current=prop1 ;
				}
				prop=this._getFontFace()
				if ( prop!=null) {
					var prop1=prop.clone() ;
					current.append (prop1) ;
					current=prop1 ;
				}
				 prop=this._getBold()
				if ( prop!=null) {
					var prop1=prop.clone() ;
					current.append (prop1) ;
					current=prop1 ;
				}
				prop=this._getItalic()
				if ( prop!=null) {
					var prop1=prop.clone() ;
					current.append (prop1) ;
					current=prop1 ;
				}
				prop=this._getUnderlined()
				if ( prop!=null) {
					var prop1=prop.clone() ;
					current.append (prop1) ;
					current=prop1 ;
				}
				prop=this._getStrike()
				if ( prop!=null) {
					var prop1=prop.clone() ;
					current.append (prop1) ;
					current=prop1 ;
				}
			};


	return {

		text: function(str) {
			var content = current.html();
			current.html(content + str);
		},
		open: function() {
			this.context = {
				parent: this.context || null,
				format: {}
			};

			
			if (rootdiv === null) {
				rootdiv =  $("<div></div>");
				current=rootdiv ;
			}
		},
		close: function(idx,parent) {

			this.context = this.context.parent;
			current=rootdiv.find("p:last") ;
			if(current.size()===0)
				current=rootdiv ;
			if (idx < parent.length-1)
				recoverContext.apply(this) ;
		},

		_updateContext: function(prop,el) {
			this.context.format[prop] = el ;
		},

		

		control: function(node,context) {
			switch (node.word) {
			
			case "par":
				var newpar = $("<p></p>");

				var cur=current.closest("div.parformat") ;
				if (cur.size()===0 )
					cur=rootdiv.find("p:last").parent() ;
				if (cur.size()===0 )
					cur= rootdiv ;//current ;

				cur.append(newpar);
				current=newpar ;
				
				recoverContext.apply(this) ;

				break;
			case "pard":
				var currentpar = rootdiv.find("p:last");
				if (currentpar.size === 0) {
					currentpar = $("<p></p>");
					current.append(currentpar);
				} else {
					var parent = currentpar.parent();
					if (parent.is("div.parformat")) {
						parent = parent.parent();
						currentpar.detach();
						parent.append(currentpar);
					}
				}
				break;
			case "u" :
				this.unicodechar(node.arg) ;
				break ;

			case "qc":
			case "ql":
			case "qr":
			case "qj":
			case "li":
			case "ri":

				var p = rootdiv.find("p:last");
				if (p.size() === 0) {
					p = $("<p>");
					current.append(p);
				}

				var pparent = p.parent();
				var el;
				if (pparent.is('div.parformat') ){
					el = pparent;
					var attribute = paragraphFormattingStyle(node);
					el.attr(attribute[0], attribute[1]);
				} else {
					el = paragraphFormatting(node);
					el.addClass('parformat') ;
					p.detach();
					el.append(p);
					pparent.append(el);
				}
				break;

			case "line" :
				current.append("<br>") ;
				break ;
			case "bullet" :
				var el =$("<li>") ;
				var dd=1 ;
				if (current.is("li") )
					current.parent().append(el) ;
				else
					current.append(el) ;
				current=el ;
				break ;	

			case "i":
			case "b":
			case "strike":
			case "ulnone":
			case "ul":
				if (node.arg === 0 || node.word === "ulnone") {
					var tagname;
					if (node.word === "strike") tagname = "s";
					else if (node.word === "ulnone") tagname = "u";
					tagname = node.word;
					if (current.is(tagname)) {
						current = current.parent();
					} else {
						var tag = current.closest(tagname);
						current = tag.parent();
					}


					this._updateContext(node.word,null)  ;

					break;
				}
			

			default:
				var el = characterFormatting(node);
				
				
				

				if (el != null) {
					var douplicat = characterFormatting(node);

					this._updateContext(node.word,douplicat)  ;
					current.append(el);
					current = el;
				}
			}
		},
		unicodechar: function(code) {
			var content = current.html();
			current.html(content + String.fromCharCode(code));
		},

		getHtml: function() {
			var ss = rootdiv.html();
			return rootdiv.html();
		},
		_getColor: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getColor(this.context);
			return context && (context.format.color || this._getColor(context.parent));
		},
		_getFontSize: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getFontSize(this.context);
			return context && (context.format.fs || this._getFontSize(context.parent));
		},
		_getFontFace: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getFontFace(this.context);
			return context && (context.format.f || this._getFontFace(context.parent));
		},
		_getBackgroundColor: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getBackgroundColor(this.context);
			return context && (context.format.highlight || this._getBackgroundColor(context.parent));
		},
		_getBold: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getBold(this.context);
			return context && (context.format.b || this._getBold(context.parent));
		},
		_getItalic: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getItalic(this.context);
			return context && (context.format.i || this._getItalic(context.parent));
		},
		_getUnderlined: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getUnderlined(this.context);
			return context && (context.format.u || this._getUnderlined(context.parent));
		},
		_getStrike: function(context) {
			if (typeof(context) === "undefined") return this.context && this._getStrike(this.context);
			return context && (context.format.s || this._getStrike(context.parent));
		}
	};
}; //builder
exports.buildHtml = function(root, documentModel) {
	var bld = builder(documentModel);
	var stack = [];
	var paragraphFormat = "";

	function interpretNode(node, index, array) {
		if (typeof node == "string") {
			bld.text(node);
			return;
		}
		if (Array.isArray(node) && node.length > 0) {
			if (node[0] && (node[0].word === 'fonttbl' || node[0].word === 'colortbl')) return;

			if (node[0] && node[0].word === "pntxtb") return;

			bld.open();
			node.forEach(interpretNode);
			bld.close(index,array);
		}


		if (typeof node === "object") {
			bld.control(node);
		}
	};

	interpretNode(root,0,[]);
	return bld.getHtml();
};
