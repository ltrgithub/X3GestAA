"use strict";
var parser = require('./parser');
var expression = require('./expression');
var helpers = require('syracuse-core/lib/helpers');
var operator = require('./operator');
var date = require('syracuse-core/lib/types/date');

exports.SqlConverter = new function() {

	var self = this;

	function _resolve(viewContext, exp) {
		if (exp.type == "identifier") {
			exp.property = helpers.object.find(viewContext.view.properties, exp.value);
		} else {
			if (exp.children) {
				var property = null;
				exp.children.forEach(function(child) {
					_resolve(viewContext, child);
					property = property || child.property;
				});
				// propagate property from child to parent if operator if low level operator
				if (property && exp.type == "operator") {
					switch (exp.value.code) {
						case "and":
						case "or":
							break;
						default:
							exp.property = property;
							// propagate to literals
							exp.children.forEach(function(child) {
								if (child.type == "literal") child.property = property;
							});
					}
				}
			}
		}
	}

	self.toSql = function(viewContext, where) {
		if (where == null) {
			return null;
		}
		var exp = parser.Parser.parse(where);
		if (!exp.isPredicate()) {
			throw new Error("invalid where clause: not a predicate: " + where);
		}
		_resolve(viewContext, exp);
		return _convert(viewContext, exp);
	};

	function _convert(viewContext, exp) {
		switch (exp.type) {
			case "identifier":
				return self.convertIdentifier(viewContext, exp);
			case "literal":
				return _convertLiteral(viewContext, exp);
			case "operator":
				return _convertOperator(viewContext, exp);
			case "function":
				return self.convertFunction(viewContext, exp);
			default:
				throw new Error("internal error: expression type = " + exp.type);
		}
	}

	self.convertIdentifier = function(viewContext, exp) {
		return viewContext.database.syntax.mapQueryProperty(exp.property);
	};

	function _quote(str) {
		return "'" + str.replace("'", "''") + "'";
	}

	function _convertLiteral(viewContext, exp) {
		var val = exp.property ? viewContext.database.syntax.mapQueryLiteral(exp.property, exp.value) : exp.value;
		if (typeof val === 'string') {
			return _quote(val);
		} else if (typeof val === 'number') {
			return val + '';
		} else if (date.isDate(val)) {
			return _quote(val.toString('yyyyMMdd'));
		} else {
			throw new Error("unsupported data type " + typeof(val));
		}
	}

	function _convertPrefix(viewContext, exp, op) {
		return "(" + op + " " + _convert(viewContext, exp.children[0]) + ")";
	}

	function _convertInfix(viewContext, exp, op) {
		if (exp.children[1].value === 'null' && exp.children[1].type === "literal") {
			var not = op == '<>' ? ' NOT' : '';
			return "(" + _convert(viewContext, exp.children[0]) + " IS" + not + " NULL " + ")";
		}
		return "(" + _convert(viewContext, exp.children[0]) + " " + op + " " + _convert(viewContext, exp.children[1]) + ")";
	}

	function _convertBetween(viewContext, exp) {
		return "(" + _convert(viewContext, exp.children[0]) + " BETWEEN " + _convert(viewContext, exp.children[1]) +
			" AND " + _convert(viewContext, exp.children[2]) +
			")";
	}

	function _convertIn(viewContext, exp) {
		return "(" + _convert(viewContext, exp.children[0]) + _convertList(viewContext, " IN ", exp.children, 1) + ")";
	}

	// May be overriden to modify function names, reorder or alter parameters,
	// etc.
	self.convertFunction = function(viewContext, exp) {
		var name = exp.value;
		return _convertList(viewContext, name.toUpperCase(), exp.children, 0);
	};

	function _convertList(viewContext, name, list, start) {
		var sb = [];
		sb.push(name);
		sb.push("(");
		for (var i = start; i < list.length; i++) {
			if (i > start) {
				sb.push(", ");
			}
			sb.push(_convert(viewContext, list[i]));
		}
		sb.push(")");
		return sb.join('');
	}

	function _convertOperator(viewContext, exp) {
		var op = exp.value;
		switch (op.code) {
			case ".":
				throw new Error("unsupported operator " + op.text);
			case "-":
				return exp.children.length === 1 ? _convertPrefix(viewContext, exp, "-") : _convertInfix(viewContext, exp, "-");
			case "in":
				return _convertIn(viewContext, exp);
			case "like":
				return _convertInfix(viewContext, exp, "LIKE", true);
			case "between":
				return _convertBetween(viewContext, exp);
			default:
				return _convertInfix(viewContext, exp, op.code.toUpperCase());
		}
	}

	return self;

};