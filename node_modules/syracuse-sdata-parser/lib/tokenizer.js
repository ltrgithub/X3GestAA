"use strict";

var token = require('./token');
var operators = require('./operator');
var date = require('syracuse-core').types.date;
var datetime = require('syracuse-core').types.datetime;

exports.Tokenizer = new function() {
	var self = this;

	function _skipSpaces(chars, i) {
		while (i < chars.length && chars[i] === " ") {
			i++;
		}
		return i;
	}

	function _isDigit(str) {
		return /[0-9]/.test(str); // new RegExp('[0-9]').test(str);
	}

	function _isLetter(str) {
		return /[\$a-zA-Z%\']/.test(str); // new RegExp('[\$a-zA-Z%\']').test(str);
	}

	function _isWordChar(str) {
		return /[\$a-zA-Z0-9_%\']/.test(str); // new RegExp('[\$a-zA-Z0-9_%\']').test(str);
	}

	function _parseNumber(line, chars, i, tokens) {
		var end = i + 1;
		while (end < chars.length && _isDigit(chars[end])) {
			end++;
		}
		var val;
		if (end < chars.length && chars[end] === '.') {
			end++;
			while (end < chars.length && _isDigit(chars[end])) {
				end++;
			}
			val = parseFloat(line.substring(i, end));

		} else {
			val = parseInt(line.substring(i, end), 10);
		}
		tokens.push(new token.Token(token.tokenType.literal, line, i, end - i, val));
		return end;
	}

	var _literals = {
		"true": true,
		"false": false,
		"null": null,
	};

	function _parseWord(line, chars, i, tokens) {
		var end = i + 1;
		while (end < chars.length && _isWordChar(chars[end])) {
			end++;
		}
		var word = chars.substr(i, end - i);
		var op = operators.operators.operators[word.toLowerCase()];
		if (op != null) {
			tokens.push(new token.Token(token.tokenType.operator, line, i, end - i, op));
		} else {
			var lit;
			if ((lit = _literals[word]) !== undefined) {
				tokens.push(new token.Token(token.tokenType.literal, line, i, end - i, lit));
			} else {
				tokens.push(new token.Token(token.tokenType.identifier, line, i, end - i, word));
			}
		}
		return end;
	}

	function _parseQuotedString(line, chars, i, tokens) {
		var quote = chars[i];
		var end = i + 1;
		var dest = 0;
		var res = "";
		while (end < chars.length) {
			if (chars[end] === quote) {
				end++;
				if (end === chars.length || chars[end] !== quote) {
					tokens.push(new token.Token(token.tokenType.literal, line, i, end - i, res));
					return end;
				}
			}
			res += chars[end++];
		}
		throw new Error('quoted string not terminated: ' + line.substring(i));
	}

	function _parseOperator(line, ch, i, tokens) {
		var op = operators.operators.operators[ch];
		tokens.push(new token.Token(token.tokenType.operator, line, i, 1, op));
		return i + 1;
	}

	function _parseDateTime(line, chars, i, tokens) {
		var end = i + 1;
		while (end < chars.length && chars[end] !== '@') {
			end++;
		}
		if (end === chars.length) {
			throw new Error('date constant not terminated:' + line.substring(i, line.length));
		}
		var str = chars.substr(i + 1, end - i - 1);
		var dt = str.length > 0 ? (str.length == 10 ? date.parse(str) : datetime.parse(str)) : null;
		// crnit: we accept date=@@ syntax, so empty string should be interpret as null date
		//		if (dt != null) {
		tokens.push(new token.Token(token.tokenType.literal, line, i, end + 1 - i, dt));
		//		}
		return end + 1;
	}

	self.tokenize = function(line) {
		var tokens = [];
		var i = 0;
		while (i < line.length) {
			i = _skipSpaces(line, i);
			var ch = line[i];
			switch (ch) {
				case '@':
					i = _parseDateTime(line, line, i, tokens);
					break;
				case '"':
				case '\'':
					i = _parseQuotedString(line, line, i, tokens);
					break;
				case '.':
				case '-':
				case '+':
				case '(':
				case ')':
				case ',':
					i = _parseOperator(line, ch, i, tokens);
					break;
				default:
					if (_isLetter(ch)) {
						i = _parseWord(line, line, i, tokens);
					} else if (_isDigit(ch)) {
						i = _parseNumber(line, line, i, tokens);
					} else {
						throw new Error('invalid character: ' + line.substring(i));
					}
					break;
			}
		}

		return tokens;
	};

	return self;
};