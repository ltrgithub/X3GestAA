"use strict";

var datetime = require('syracuse-core/lib/types/datetime');
var ez = require('ez-streams');
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var traceHelper = require('syracuse-trace/lib/helper');
var config = require('config');
var zlib = require('zlib');
var queues = {};

function setRecord(_, instance) {
	instance.configs(_).toArray(_).forEach_(_, function(_, inst) {
		var name = inst.name(_);
		var conf = inst.serializeInstance(_);
		if (conf && conf.enabled) {
			if (conf.modules) {
				conf.modules.forEach_(_, function(_, mod) {
					if (mod.enabled) traceHelper.getTracer(name + "." + mod.name).records[instance.$uuid] = {
						queue: queues[instance.$uuid],
						config: {
							enabled: mod.enabled,
							level: traceHelper.methods.indexOf(mod.level)
						}
					};
				});
			} else {
				traceHelper.getTracer(name).records[instance.$uuid] = {
					queue: queues[instance.$uuid],
					config: {
						enabled: conf.enabled,
						level: traceHelper.methods.indexOf(conf.level)
					}
				};
			}
		}
	});
}

function unsetRecord(_, instance) {
	instance.configs(_).toArray(_).forEach_(_, function(_, inst) {
		var name = inst.name(_);
		var conf = inst.serializeInstance(_);
		var tracerRecords;
		if (conf.modules) {
			conf.modules.forEach_(_, function(_, mod) {
				tracerRecords = traceHelper.getTracer(name + "." + mod.name).records;
				if (tracerRecords[instance.$uuid]) {
					delete tracerRecords[instance.$uuid];
				}
			});
		} else {
			tracerRecords = traceHelper.getTracer(name).records;
			if (tracerRecords[instance.$uuid]) {
				delete tracerRecords[instance.$uuid];
			}
		}
	});
	delete queues[instance.$uuid];
}

exports.entity = {
	$titleTemplate: "Traces recording",
	$valueTemplate: "{description}",
	$descriptionTemplate: "Recording from {stamp}",
	$capabilities: "mailTemplate",
	$properties: {
		name: {
			$title: "Name",
			$isUnique: true,
			$isMandatory: true,
			$linksToDetails: true,
			$pattern: /^[A-Za-z_\-][A-Za-z_\-0-9]*$/,
			$isReadOnly: function(_, instance) {
				return instance.status(_) !== "created";
			},
		},
		stamp: {
			$title: "Timestamp",
			$type: "datetime",
			$isReadOnly: true,
			$isNullable: true,
		},
		pid: {
			$title: "Process ID",
			$type: "integer",
			$isReadOnly: true,
			$isNullable: true,
			$default: process.pid,
		},
		status: {
			$title: "Status",
			$enum: [{
				$title: "created",
				$value: "created",
			}, {
				$title: "running",
				$value: "running",
			}, {
				$title: "paused",
				$value: "paused",
			}, {
				$title: "complete",
				$value: "complete",
			}, {
				$title: "error",
				$value: "error",
			}],
			$default: "created",
			$isReadOnly: true,
		},
		size: {
			$title: "Size",
			$type: "integer",
			$compute: function(_, instance) {
				var recording = instance.recording(_);
				return recording.fileExists(_) ? recording.getProperties(_).length : null;
			},
		},
		recording: {
			$title: "Recording",
			$type: "binary",
			$isDisabled: false,
			$isReadOnly: true,
			$storage: "db_file",
		},
		transcript: {
			$title: "Transcript",
			$type: "text/plain",
			$isReadOnly: true,
			$default: "",
		}
	},
	$relations: {
		configs: {
			$title: "Configuration",
			$type: "traceConfigs",
			$isChild: true,
			$isReadOnly: function(_, instance) {
				return instance.status(_) !== "created";
			},
		}
	},
	$searchIndex: {
		$fields: ["name", "stamp"]
	},
	$functions: {
		log: function(_, message) {
			this.transcript(_, this.transcript(_) + '\n' + datetime.now() + ' ' + message);
		},
		startRecording: function(_) {
			if (this.status(_) !== "created") throw new Error("bad status: " + this.status(_));

			// create output stream
			var writer = this.recording(_).createWritableStream(_, {
				"contentType": "application/x-trace",
				"contentEncoding": "gzip",
				"fileName": this.name(_) + ".gz",
			});

			writer = ez.helpers.binary.writer(writer, {
				bufSize: 64000,
			});
			//

			var q = queues[this.$uuid] = ez.devices.queue({
				max: config.system.traceQueueMax || 100000,
			});

			q.put({
				//prototype: JSON.parse(fs.readFileSync(fsp.join(__dirname, '../prototypes/trace.json'), {encoding: "utf8"})),
				entity: require('syracuse-trace/lib/entities/trace._js').entity
			});

			setRecord(_, this);

			q.reader = q.reader.transform(ez.transforms.json.formatter());
			q.reader = q.reader.map(ez.mappers.convert.bufferify());
			q.reader = q.reader.nodeTransform(zlib.createGzip());
			q.reader.pipe(!_, writer);

			// update status and save
			this.status(_, "running");
			this.log(_, "recording started");
			this.save(_);
		},
		finishRecording: function(_, err) {
			err && console.error(err.stack);
			if (queues[this.$uuid]) {
				queues[this.$uuid].write(_);
				unsetRecord(_, this);
			}

			this.status(_, err ? "error" : "complete");
			this.log(_, err ? "recording failed: " + err.message : "recording complete");
			this.save(_);
		},
		stopRecording: function(_) {
			var err;
			try {

			} catch (e) {
				console.error("ERR: " + e.stack);
				err = e;
			}
			this.finishRecording(_, err);
		},
		pauseRecording: function(_) {
			if (this.status(_) !== "running") throw new Error("bad status: " + this.status(_));
			this.status(_, "paused");
			this.log(_, "recording paused");
			this.save(_);
		},
		resumeRecording: function(_) {
			if (this.status(_) !== "paused") throw new Error("bad status: " + this.status(_));
			this.status(_, "running");
			this.log(_, "recording resumed");
			this.save(_);
		},
	},
	$services: {
		start: {
			$title: "Start",
			$description: "Start recording",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "created";
			},
			$execute: function(_, context, instance) {
				instance.startRecording(_);
			},
		},
		stop: {
			$title: "Stop",
			$description: "Stop recording",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "running";
			},
			$execute: function(_, context, instance) {
				instance.stopRecording(_);
			},
		},
		pause: {
			$title: "Pause",
			$description: "Stop recording",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "running";
			},
			$execute: function(_, context, instance) {
				instance.pauseRecording(_);
			},
		},
		resume: {
			$title: "Resume",
			$description: "Stop recording",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "paused";
			},
			$execute: function(_, context, instance) {
				instance.resumeRecording(_);
			},
		},
	},
	$init: function(_, instance) {
		instance.stamp(_, datetime.now());
		var db = adminHelper.getCollaborationOrm(_);
		var settings = db.fetchInstances(_, db.model.getEntity(_, "traceSetting"))[0];
		var confs = settings && settings.configs(_);
		confs.toArray(_).forEach_(_, function(_, c) {
			instance.configs(_).set(_, c);
		});
	},
};