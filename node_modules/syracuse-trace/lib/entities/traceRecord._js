"use strict";

var globals = require("streamline/lib/globals");
var datetime = require('syracuse-core/lib/types/datetime');
var locale = require("syracuse-core/lib/locale");
var coreHelpers = require('syracuse-core/lib/helpers');
var ez = require('ez-streams');
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var traceHelper = require('syracuse-trace/lib/helper');
var config = require('config');
var mock = require('syracuse-load/lib/mock');
var zlib = require('zlib');
var tasks = {};
var zaehler = 0;
var devMode = config && config.system && config.system.enableDevelopmentFeatures;
var t1 = traceHelper.getTracer('test.1');
var t2 = traceHelper.getTracer('test.2');


function setRecord(_, instance) {
	var uuid = instance.sequence(_);
	var sid = instance.onlySid(_) ? globals.context.session && globals.context.session.id : null;
	// maybe wrapper object for transparent exchange of instance for auto records
	var task = tasks[uuid];
	var queue = task.q;
	if (instance.auto(_) && task.changeNeeded && task.performChange) {
		queue = _makeAutoQueue(task);
	}
	instance.configs(_).toArray(_).forEach_(_, function(_, inst) {
		var name = inst.name(_);
		var conf = inst.serializeInstance(_);
		if (conf.modules) {
			conf.modules.forEach(function(mod) {
				traceHelper.getTracer(name + "." + mod.name).addRecord(uuid, mod.level, queue, sid);
			});
		} else {
			traceHelper.getTracer(name).addRecord(uuid, conf.level, queue, sid);
		}
	});
}

function unsetRecord(_, instance, removeFromQueue) {
	var uuid = instance.sequence(_);
	instance.configs(_).toArray(_).forEach_(_, function(_, inst) {
		var name = inst.name(_);
		var conf = inst.serializeInstance(_);
		if (conf.modules) {
			conf.modules.forEach(function(mod) {
				traceHelper.getTracer(name + "." + mod.name).deleteRecord(uuid);
			});
		} else {
			traceHelper.getTracer(name).deleteRecord(uuid);
		}
		if (removeFromQueue) delete tasks[uuid];
	});
}

exports.entity = {
	$titleTemplate: "Traces recording",
	$valueTemplate: "{description}",
	$descriptionTemplate: "Recording from {stamp}",
	$capabilities: "mailTemplate",
	$properties: {
		name: {
			$title: "Name",
			$isUnique: true,
			$isMandatory: true,
			$linksToDetails: true,
			$isReadOnly: function(_, instance) {
				return instance.status(_) !== "created";
			},
		},
		stamp: {
			$title: "Timestamp",
			$type: "datetime",
			$isReadOnly: true,
			$isNullable: true,
		},
		auto: {
			$title: "Auto start",
			$type: "boolean",
			$default: false,
			$isHidden: true,
			$isDefined: false,
			$isReadOnly: true,
		},
		sequence: {
			$title: "Sequence number",
			$isHidden: true,
			$isReadOnly: true
		},
		pid: {
			$title: "Process ID",
			$type: "integer",
			$isReadOnly: true,
			$isNullable: true,
			$default: process.pid,
		},
		onlySid: {
			$title: "Only my session",
			$type: "boolean",
			$default: false,
		},
		status: {
			$title: "Status",
			$enum: [{
				$title: "created",
				$value: "created",
			}, {
				$title: "running",
				$value: "running",
			}, {
				$title: "paused",
				$value: "paused",
			}, {
				$title: "complete",
				$value: "complete",
			}, {
				$title: "error",
				$value: "error",
			}],
			$default: "created",
			$isReadOnly: true,
		},
		size: {
			$title: "Size",
			$type: "integer",
			$compute: function(_, instance) {
				var recording = instance.recording(_);
				return recording.fileExists(_) ? recording.getProperties(_).length : null;
			},
		},
		recording: {
			$title: "Recording",
			$type: "binary",
			$isDisabled: false,
			$isReadOnly: true,
			$storage: "db_file",
		},
		ticket: {
			$title: "Ticket number",
			$isDisabled: function(_, instance) {
				return instance.auto(_);
			},
		},
		transcript: {
			$title: "Transcript",
			$type: "text/plain",
			$isReadOnly: true,
			$default: "",
		}
	},
	$relations: {
		configs: {
			$title: "Configurations",
			$type: "traceConfigs",
			$isChild: true,
			$isReadOnly: function(_, instance) {
				return instance.status(_) !== "created";
			},
		}
	},
	$searchIndex: {
		$fields: ["name", "stamp"]
	},
	$functions: {
		// THIS DOES NOT WORK !!!
		$canDelete: function(_) {
			console.log("CAN DELETE?");
			var self = this;
			if (this.status(_) === "complete" || this.status(_) === "error") {
				self.deleteError = "Cannot delete active record";
				return false;
			} else return true;
		},
		log: function(_, message) {
			this.transcript(_, this.transcript(_) + '\n' + datetime.now() + ' ' + message);
		},
		removeQueue: function(_) {
			delete tasks[this.sequence(_)];
		},

		startRecording: function(_) {
			var self = this;
			if (self.status(_) !== "created") throw new Error("bad status: " + self.status(_));
			self.sequence(_, coreHelpers.uuid.generate());
			startInternal(_, self);

			// update status and save
			self.status(_, "running");
			self.log(_, "recording started");
			self.save(_);
		},
		finishRecording: function(_, err) { // EM: new implementation for auto records: should set a flag so that changeNeeded is true and put a message. Implementation must be synchronous
			err && console.error(err.stack);
			this.status(_, err ? "error" : "complete");
			if (err) {
				this.log(_, locale.format(module, "recordFailed", err.message));
			} else {
				this.log(_, locale.format(module, "recordCompleted"));
			}
			this.save(_);
			if (!err && this.auto(_)) {
				// Launch another auto record
				traceHelper.launchAutoTraceRecord(_);
			}
			// Write EOF
			stopInternal(_, this);
		},
		stopRecording: function(_, err) {
			try {

			} catch (e) {
				console.error("ERR: " + e.stack);
				err = e;
			}
			if (this.status(_) !== "error" && this.status(_) !== "complete") this.finishRecording(_, err);
		},
		pauseRecording: function(_) {
			if (this.status(_) !== "running") throw new Error("bad status: " + this.status(_));
			pauseInternal(_, this);
			this.status(_, "paused");
			this.log(_, locale.format(module, "recordPaused"));
			this.save(_);
		},
		resumeRecording: function(_) {
			if (this.status(_) !== "paused") throw new Error("bad status: " + this.status(_));
			resumeInternal(_, this);
			this.status(_, "running");
			this.log(_, locale.format(module, "recordResumed"));
			this.save(_);
		},
	},
	$services: {
		test: {
			$title: "Test",
			$description: "Test",
			$method: "POST",
			$isMethod: true,
			$isHidden: function(_, instance) {
				return !devMode;
			},
			$execute: function(_, context, instance) {
				testInternal(_, instance);
			},
		},
		testAll: {
			$title: "Test all",
			$description: "Test",
			$method: "POST",
			$isMethod: true,
			$isHidden: function(_, instance) {
				return !devMode;
			},
			$execute: function(_, context, instance) {
				testInternal(_, instance);
				if (!instance.onlySid(_)) console.log("Ergebnis test rec: " + _propagate(_, "POST", "test/" + instance.$uuid));
			},
		},
		start: {
			$title: "Start",
			$description: "Start recording",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.$created || instance.status(_) !== "created";
			},
			$execute: function(_, context, instance) {
				instance.startRecording(_);
				// propagate changes only for session independent loggers
				if (!instance.onlySid(_)) console.log("Ergebnis start rec: " + _propagate(_, "POST", "start/" + instance.$uuid));
			},
		},
		stop: {
			$title: "Stop",
			$description: "Stop recording",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "running";
			},
			$execute: function(_, context, instance) {
				// propagate changes only for session independent loggers
				if (!instance.onlySid(_)) console.log("Ergebnis stop rec: " + _propagate(_, "POST", "stop/" + instance.$uuid)); // stop other instances first
				instance.stopRecording(_);
			},
		},
		pause: {
			$title: "Pause",
			$description: "Pause recording",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.$created || instance.status(_) !== "running";
			},
			$execute: function(_, context, instance) {
				// propagate changes only for session independent loggers
				if (!instance.onlySid(_)) console.log("Ergebnis pause rec: " + _propagate(_, "POST", "pause/" + instance.$uuid)); // pause other instances first
				instance.pauseRecording(_);
			},
		},
		resume: {
			$title: "Resume",
			$description: "Resume recording",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.$created || instance.status(_) !== "paused";
			},
			$execute: function(_, context, instance) {
				instance.resumeRecording(_);
				// propagate changes only for session independent loggers
				if (!instance.onlySid(_)) console.log("Ergebnis resume rec: " + _propagate(_, "POST", "resume/" + instance.$uuid));
			},
		},
	},
	$init: function(_, instance) {
		// Every new instance will take default configuration from the only one traceSetting instance
		instance.stamp(_, datetime.now());
		var db = adminHelper.getCollaborationOrm(_);
		var settings = db.fetchInstances(_, db.model.getEntity(_, "traceSetting"))[0];
		var confs = settings && settings.configs(_);
		confs.toArray(_).forEach_(_, function(_, c) {
			instance.configs(_).set(_, c);
		});
	},
	$defaultOrder: [
		["stamp", false]
	]
};



// special queue which allows transparent change of underlying traceRecord via performChange function of the task object
function _makeAutoQueue(task) {
	var queue = task.q;
	var temp;
	var changeNeeded = task.changeNeeded.bind(task);
	var performChange = task.performChange.bind(task);
	return {
		put: function(data) {
			var self = this;
			if (temp) { // put in temporary cache
				temp.push(data);
				return true;
			}
			if (changeNeeded(data)) {
				temp = [data];
				process.nextTick(function() {
					performChange(_ >> function(err, inst) {
						if (err) { // change does not work: continue logging to console.error
							console.error("Error during implicit change of traceRecord " + err.stack);
							if (temp.length) {
								console.error("Log messages during change ");
								temp.forEach(function(item) {
									console.error(JSON.stringify(item));
								});
							}
							// no future changes of trace records any more, logging to console.error!
							changeNeeded = function() {
								return false;
							};
							queue = {
								put: function(data) {
									console.error(JSON.stringify(data));
									return true;
								}
							};
							temp = undefined;
						} else {
							// use new record
							queue = inst.q;
							var temp1 = temp;
							temp = undefined;
							if (temp1.length) {
								if (!queue.put(temp1.shift())) { // put first item directly into queue to avoid 'changeNeeded'
									console.error(JSON.stringify(item));
								}
								temp1.forEach(function(item) {
									if (!self.put(item)) {
										console.error(JSON.stringify(item));
									};
								});
							}
						}
					}, data);
				});
				return true;
			} else {
				return queue.put(data);
			}
		}
	};
}
exports._makeAutoQueue = _makeAutoQueue;

// this function will be executed on all nodes of a cluster when the traceRecord is started
// just start logging without any changes to the traceRecord (for use in cluster)
function startInternal(_, instance) {
	// create output stream
	var writer = instance.recording(_).createWritableStream(_, {
		"contentType": "application/x-trace",
		"contentEncoding": "gzip",
		"fileName": instance.name(_) + ".gz",
		"append": "w+"
	});
	var queueUuid = instance.sequence(_);
	console.log("Start int " + queueUuid);
	writer = ez.helpers.binary.writer(writer, {
		bufSize: 64000,
	});
	//

	var q = ez.devices.queue({
		max: config.system.traceQueueMax || 100000,
	});

	tasks[queueUuid] = {
		len: 0,
		ended: false,
		q: q,
		changeNeeded: function(data) {
			return false;
		},
		performChange: function(_, data) {
			// exchange trace record with new record
			setTimeout(~_, 1000);
			return this;
		},
	};

	// Put entity name
	q.put({
		entity: "trace"
	});
	// Put ticket number
	q.put({
		ticket: instance.ticket(_) || ""
	});
	setRecord(_, instance);
	q.reader = q.reader.transform(ez.transforms.json.formatter());
	q.reader = q.reader.map(ez.mappers.convert.bufferify());
	q.reader = q.reader.nodeTransform(zlib.createGzip());

	var isAuto = instance.auto(_);
	var maxSize = (config && config.traces && config.traces.maxSize) || "100m";
	maxSize = traceHelper.computeSize(maxSize);
	if (isAuto) {
		q.reader = q.reader.map(function(_, r) {
			var uuid = instance.sequence(_);
			tasks[uuid].len += r.length;
			if (tasks[uuid].len > maxSize) {
				if (!tasks[uuid].ended) {
					tasks[uuid].ended = true;
					instance.stopRecording(_);
				}
			}
			return r;
		});
	}
	//q.reader.pipe(!_, writer);
	q.reader.pipe(_ >> function(err) {
		if (err) {
			console.error(err.stack);
			q = null;
		}
		unsetRecord(function(err) {
			if (err) console.error(err.stack);
		}, instance, true);
		q = null;
	}, writer);
	console.log("Started internal " + instance.name(_));
}

//this function will be executed on all nodes of a cluster when the traceRecord is stopped
function stopInternal(_, instance) {
	var uuid = instance.sequence(_);
	console.log("Stop internal " + uuid + " " + instance.name(_));
	if (tasks[uuid] && tasks[uuid].q) {
		tasks[uuid].q.write(_);

	} else {
		//TODO: MUST FIND A WAY TO REPAIR CHUNKS WITH INSERTING EOF				
	}
}

//this function will be executed on all nodes of a cluster when the traceRecord is paused
function pauseInternal(_, instance) {
	console.log("Pause internal " + instance.sequence(_) + " " + instance.name(_));
	unsetRecord(_, instance);
}
// 

//this function will be executed on all nodes of a cluster when the traceRecord is resumed
function resumeInternal(_, instance) {
	console.log("Resume internal " + instance.sequence(_) + " " + instance.name(_));
	setRecord(_, instance);
}

//this function will be executed on all nodes of a cluster when the traceRecord is resumed
function testInternal(_, instance) {
	console.log("Test internal " + instance.sequence(_) + " " + instance.name(_));
	t1.info && t1.info("test 1 info");
	t1.debug && t1.debug("test 1 debug");
	t1.warn && t1.warn("test 1 warn");
	t1.error && t1.error("test 1 error", new Error("Error T1"));
	t2.info && t2.info("test 2 info");
	t2.debug && t2.debug("test 2 debug");
	t2.warn && t2.warn("test 2 warn");
	t2.error && t2.error("test 2 error", new Error("Error T2"));
}

var internals = {
	'stop': stopInternal,
	'start': startInternal,
	'pause': pauseInternal,
	'resume': resumeInternal,
	'test': testInternal
};
exports.handleChange = function(_, uuid, action) {
	console.log("Handle " + uuid + " " + action);
	var fun = internals[action];
	if (!fun) throw new Error("Invalid action");
	var db = adminHelper.getCollaborationOrm(_);
	var instance = db.fetchInstance(_, db.model.getEntity(_, "traceRecord"), {
		$jsonWhere: {
			$uuid: uuid
		}
	});
	if (!instance) throw new Error("Trace record not available");
	fun(_, instance);
};


function _propagate(_, method, path) { // propagation only when load balancer is available!
	if ("mockServer" in config) {
		var options = {
			path: "/nannyCommand/notifyAll/logging/" + path,
			method: method,
			hostname: "",
			port: 0,
			headers: {
				host: (globals.context.tenantId || "")
			}
		};
		options.headers[mock.BALANCER_HEADER] = config.port;
		try {
			return config.mockServer.mockClient.simpleRequest(options, "", _);
		} catch (e) {
			console.log("Error " + e.stack);
			return e.stack;
		}
	}
}