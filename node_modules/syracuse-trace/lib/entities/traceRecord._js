"use strict";

var globals = require('streamline-runtime').globals;
var datetime = require('syracuse-core').types.datetime;
var locale = require('streamline-locale');
var coreHelpers = require('syracuse-core').helpers;
var ez = require('ez-streams');
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var traceHelper = require('syracuse-trace/lib/helper');
var config = require('config');
var mock = require('syracuse-load/lib/mock');
var zlib = require('zlib');
var zip = require('streamline-zip');
var hostname = require('os').hostname();
var queues = {};

var devMode = config && config.system && config.system.enableDevelopmentFeatures;
var t1, t2;
if (devMode) {
	t1 = traceHelper.getTracer('test.1');
	t2 = traceHelper.getTracer('test.2');
}

var tracer; // = console.error;
var withTenant = (config.hosting && config.hosting.multiTenant);

var _getSequence;
if (withTenant) {
	_getSequence = function(sequence) {
		return sequence + "." + (globals.context.tenantId || "");
	};

} else {
	_getSequence = function(sequence) {
		return sequence;
	};
}



// get all temporary messages (for all tenants!)
exports.getTempMessages = function() {
	var output = "";
	for (var key in queues) {
		var queue = queues[key];
		if (queue.temp) queue.temp.forEach(function(content) {
			output += JSON.stringify(content) + "\n";
		});
	}
	return output;
};


// fetch traceRecord instance by $uuid
function _fetchRecord(_, uuid) {
	if (!uuid) throw new Error("No uuid for fetching traceRecord " + uuid);

	var db = adminHelper.getCollaborationOrm(_);
	var instance = db.fetchInstance(_, db.model.getEntity(_, "traceRecord"), {
		jsonWhere: {
			$uuid: uuid
		}
	});
	// console.log("Fetch "+uuid+" "+instance);
	return instance;
}

// change configuration of a tracer
function configChange(sequence, queue, newConfig) {
	var oldConfig = queue.levels;
	var messages = [],
		key, newLevel;
	for (key in oldConfig) {
		var oldLevel = oldConfig[key];
		newLevel = newConfig[key];
		if (oldLevel !== newLevel) {
			var tracer0 = traceHelper.getTracer(key);
			tracer0.deleteRecord(sequence);
			if (newLevel) {
				tracer0.addRecord(sequence, newLevel, queue, queue.sid, withTenant ? (globals.context.tenantId || "$$solo") : null);
				try {
					oldLevel = locale.format(module, oldLevel);
					newLevel = locale.format(module, newLevel);
				} catch (e) {
					console.error("Error localizing log levels " + e);
				}
				messages.push(locale.format(module, "levelChange", key, oldLevel, newLevel));
			} else {
				messages.push(locale.format(module, "removeLogging", key));
			}
		}
	}
	for (key in newConfig) {
		if (!(key in oldConfig)) {
			newLevel = newConfig[key];
			traceHelper.getTracer(key).addRecord(sequence, newLevel, queue, queue.sid, withTenant ? (globals.context.tenantId || "$$solo") : null);
			try {
				newLevel = locale.format(module, newLevel);
			} catch (e) {
				console.error("Error localizing log levels " + e);
			}
			messages.push(locale.format(module, "addLogging", key, newLevel));
		}
	}
	queue.levels = newConfig;
	return messages;
}

// put all module names and log levels to a simple object
function _grabLogLevels(serialized) {
	var result = {};
	serialized.configs.forEach(function(conf) {
		var name = conf.name;
		if (conf.modularized) {
			conf.modules.forEach(function(mod) {
				result[name + "." + mod.name] = mod.level;
			});
		} else {
			result[name] = conf.level;
		}
	});
	return result;
}

//close session specific trace records
exports.removeSessionTracers = function(_, sid) {
	// console.error("SID "+sid)
	Object.keys(queues).forEach_(_, function(_, key) {
		var queue = queues[key];
		if (queue && queue.sid === sid) {
			var uuid = queue.uuid;
			var instance = _fetchRecord(_, uuid);
			try {
				stopInternal(_, key, instance);
			} catch (e) {
				console.error("ERR " + e.stack);
			}
		}
	});
};

exports.entity = {
	$titleTemplate: "Traces recording",
	$valueTemplate: "{description}",
	$descriptionTemplate: "Recording from {stamp}",
	$capabilities: "mailTemplate",
	// must use optimistic locking although instances will be locked during update. Reason: 
	// edit mode must not block logging! $lockType: "pessimist",
	$uniqueConstraints: [
		["name", "host", "pid"]
	],

	$properties: {
		name: {
			$title: "Name",
			$isMandatory: true,
			$isUnique: true,
			$pattern: "^[-\\w]+$",
			$linksToDetails: true,
			$isReadOnly: function(_, instance) {
				return instance.status(_) !== "created";
			},
		},
		stamp: {
			$title: "Timestamp",
			$type: "datetime",
			$isReadOnly: true,
			$isNullable: true,
		},
		auto: {
			$title: "Auto start",
			$type: "boolean",
			$default: false,
			$isHidden: true,
			$isDefined: false,
			$isReadOnly: true,
		},
		sequence: {
			$title: "Sequence number",
			$isHidden: true,
			$isReadOnly: true
		},
		change: {
			$title: "Change",
			$type: "boolean",
			$compute: function(_, instance) {
				var status;
				return (instance.hostname(_) === hostname && instance.pid(_) === process.pid && (status = instance.status(_)) !== "complete" && status !== "error");
			}
		},
		hostname: {
			$title: "Host name",
			$isReadOnly: true,
			$default: hostname
		},
		pid: {
			$title: "Process ID",
			$type: "integer",
			$isReadOnly: true,
			$isNullable: true,
			$default: process.pid,
		},
		onlySid: {
			$title: "One session only",
			$description: "Only the creator's session actions are traced in this record",
			$type: "boolean",
			$default: true,
			$isReadOnly: function(_, instance) {
				return !instance.$created;
			},
			$propagate: function(_, instance, value) {
				if (value) instance.sessionId(_, globals.context.session && globals.context.session.id);
				else instance.sessionId(_, null);
			}
		},
		isSessionConcerned: {
			$title: "Current session concerned",
			$description: "Visual information that allows to know if the current session is concerned by the record.",
			$type: "boolean",
			$isReadOnly: true,
			$isHidden: function(_, instance) {
				return !instance.onlySid(_);
			},
			$compute: function(_, instance) {
				return instance.status(_) === "running" && (!instance.onlySid(_) || (instance.sessionId(_) === (globals.context.session && globals.context.session.id)));
			}
		},
		sessionId: {
			$title: "Traced session id",
			$isReadOnly: true,
			$isHidden: function(_, instance) {
				return !instance.onlySid(_);
			},
			$isNullable: true
		},
		status: {
			$title: "Status",
			$enum: [{
				$title: "created",
				$value: "created",
			}, {
				$title: "running",
				$value: "running",
			}, {
				$title: "halted", // special status for running instances which have been halted because the process has finished
				$value: "halted",
			}, {
				$title: "halted paused", // special status for paused instances which have been halted because the process has finished
				$value: "haltedpaused",
			}, {
				$title: "paused",
				$value: "paused",
			}, {
				$title: "complete",
				$value: "complete",
			}, {
				$title: "error",
				$value: "error",
			}],
			$default: "created",
			$isReadOnly: true,
		},
		ticket: {
			$title: "Ticket number",
			$isHidden: function(_, instance) {
				return instance.auto(_);
			},
			$isReadOnly: function(_, instance) {
				return !instance.$created;
			},
		},
		transcript: {
			$title: "Transcript",
			$type: "text/plain",
			$isReadOnly: true,
			$default: "",
		}
	},
	$relations: {
		contents: {
			$title: "Binaries",
			$type: "traceContents",
			$isChild: true,
			$capabilities: "sort",
			$cascadeDelete: true
		},
		configs: {
			$title: "Configurations",
			$type: "traceConfigs",
			$isChild: true,
			$isReadOnly: function(_, instance) {
				return !instance.change(_);
			},
			$capabilities: "sort"
		}
	},
	$functions: {
		$onDelete: function(_) {
			var self = this;
			if (self.status(_) === "running") throw new Error(locale.format(module, "deleteRunning"));
			stopInternal(_, self.sequence(_), self);
			return true;
		},
		log: function(_, message) {
			this.transcript(_, this.transcript(_) + '\n' + datetime.now() + ' ' + message);
		},
		haltRecording: function(_) { // halt recording for manual records, stop recording for autorecord
			stopInternal(_, this.sequence(_), this, false, !this.auto(_));
		},
		// create a new instance from this instance (only for manual records without 'onlySid')
		duplicateManual: function(_) {
			var newInstance = this.getEntity(_).createInstance(_, adminHelper.getCollaborationOrm(_), null);
			newInstance.name(_, this.name(_));
			newInstance.ticket(_, this.ticket(_));
			newInstance.sequence(_, this.sequence(_));
			newInstance.onlySid(_, false);
			var configs = newInstance.configs(_);
			configs.reset(_);
			_copyChildren(_, newInstance.configs(_), this.configs(_));
			return newInstance;
		},
		// return a writer. Assume that instance is already locked and will be saved later 
		startNewContent: function(_, index, maxFiles) {
			var recs = this.contents(_);
			var child;
			if (!maxFiles) { // for initialisation
				index = 0;
				maxFiles = 2;
			}
			if (index < maxFiles) {
				// add a new child
				child = recs.add(_);
			} else {
				// re-use 
				child = recs.toArray(_)[index % maxFiles];
				child.recording(_).deleteFile(_);
			}
			if (index > 0) this.log(_, locale.format(module, "newContent", index));
			var timestamp = datetime.now().toString();
			child.start(_, timestamp);

			var contentPrefix = this.name(_) + "_";
			if (globals.context.tenantId) contentPrefix += (globals.context.tenantId + "_");
			// create output stream - no append flag anymore for Gridfs 2.0
			var writer = child.recording(_).createWritableStream(_, {
				"contentType": "x-trace",
				"contentEncoding": "gzip",
				"fileName": contentPrefix + index + "_" + hostname + "-" + process.pid + ".gz",
			});
			return writer;
		},
		// pause: just enter 'paused' status
		// noLock: locking and saving of this instance will be handled by calling code
		// unsetConsole: remove console logger
		startRecording: function(_, pause, noLock, unsetConsole) {
			var self = this;
			if (!noLock) traceHelper.lockInstanceRetry(_, self);
			try {
				if (!noLock) _refreshInstance(_, self);
				_startRecording(_, self, pause, unsetConsole);
				if (!noLock) {
					self._noPropagate = true;
					self._noLock = true;
					self.save(_);
				}
			} finally {
				if (!noLock) adminHelper.getCollaborationOrm(_).unlockInstance(_, self);
			}
		},
		errorStopped: function(_, err) {
			var self = this;
			traceHelper.lockInstanceRetry(_, self);
			try {
				_refreshInstance(_, self);
				self.status(_, "error");
				self.log(_, err);
				self._noPropagate = true;
				self._noLock = true;
				self.save(_);
			} finally {
				adminHelper.getCollaborationOrm(_).unlockInstance(_, self);
			}
		},
		concatContents: function(_, t) {
			var outstream = {
				_data: [],
				emitter: true,
				write: function(_, data) {
					if (data) this._data.push(data);
				}
			};
			var archive = new zip.Zip(outstream, {
				zipMethod: zip.store
			}); // the contained zip archives cannot be compressed
			var conts = this.contents(_).toArray(_);
			for (var i = 0; i < conts.length; i++) {
				var rec = conts[i].recording(_);
				if (rec.fileExists(_)) {
					try {
						var buf = rec.createReadableStream(_).read(_, -1);
						if (t) {
							t.phaseDetail = "Add zip file " + i;
							t.progress = Math.round(95 * (i + 1) / conts.length);
						}
						archive.add(_, {
							name: i + ".gz",
							data: buf
						});
					} catch (e) {
						if (t) t.$diagnoses.push({
							$severity: "error",
							$message: "" + e
						});
						else this.$addError("" + e);
						console.log("Error " + e);
					}
				}
			}
			archive.finish(_);
			if (t) {
				t.phaseDetail = "Completed";
				t.progress = 100;
			}
			return Buffer.concat(outstream._data);
		},
	},
	$services: {
		start: {
			$title: "Start",
			$description: "Start recording",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return !instance.change(_) || instance.$created || instance.status(_) !== "created";
			},
			$execute: function(_, context, instance) {
				instance.startRecording(_);
				// propagate changes only for session independent loggers
				if (!instance.onlySid(_)) {
					var result = _propagate(_, "POST", "start?uuid=" + instance.$uuid);
					tracer && tracer("start rec: " + result);
				}
			},
		},
		stop: {
			$title: "Stop",
			$description: "Stop recording",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return !instance.change(_) || instance.auto(_) || instance.status(_) === "created";
			},
			$execute: function(_, context, instance) {
				// propagate changes only for session independent loggers
				if (!instance.onlySid(_)) {
					var result = _propagate(_, "POST", "stop?seq=" + instance.sequence(_));
					tracer && tracer("stop rec: " + result); // stop other instances first
				}
				stopInternal(_, instance.sequence(_), instance);
			},
		},
		pause: {
			$title: "Pause",
			$description: "Pause recording",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.auto(_) || !instance.change(_) || instance.$created || instance.status(_) !== "running";
			},
			$execute: function(_, context, instance) {
				// propagate changes only for session independent loggers
				if (!instance.onlySid(_)) {
					var result = _propagate(_, "POST", "pause?seq=" + instance.sequence(_));
					tracer && tracer("pause rec: " + result); // pause other instances first
				}
				pauseInternal(_, instance.sequence(_), instance);
			},
		},
		resume: {
			$title: "Resume",
			$description: "Resume recording",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return !instance.change(_) || instance.$created || instance.status(_) !== "paused";
			},
			$execute: function(_, context, instance) {
				resumeInternal(_, instance.sequence(_), instance);
				// propagate changes only for session independent loggers
				if (!instance.onlySid(_)) {
					var result = _propagate(_, "POST", "resume?seq=" + instance.sequence(_));
					tracer && tracer("resume rec: " + result);
				}
			},
		},
		flush: {
			$title: "Flush",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.$created || !instance.change(_) || (instance.status(_) !== "running" && instance.status(_) !== "paused");
			},
			$execute: function(_, context, instance) {
				// copy log and child records
				flushInternal(_, instance.sequence(_), instance);
				if (!instance.onlySid(_)) {
					var result = _propagate(_, "POST", "flush?seq=" + instance.sequence(_));
					tracer && tracer("test rec: " + result);
				}
			},
		},
		download: {
			$title: "Download all",
			$description: "Download all",
			$method: "GET",
			$isMethod: true,
			$type: "application/x-export",
			$invocationMode: "async",
			$isDisabled: function(_, instance) {
				return instance.contents(_).getLength() <= 1;
			},
			$execute: function(_, context, instance) {
				var t = context.tracker;
				if (t) {
					t.$diagnoses = t.$diagnoses || [];
					t.replyLink = "$download";
				}

				var recs = instance.concatContents(_, t);


				if (t) {
					t.$links = t.$links || {};
					t.$links.$download = {
						$title: "Download",
						$url: t.location + "?reply=true",
						$method: "GET",
						$type: "application/zip",
						$filename: instance.name(_) + ".zip"
					};
				}
				return recs;
			},
		},
		test: {
			$title: "Test",
			$description: "Test",
			$method: "POST",
			$isMethod: true,
			$isDefined: function(_, instance) {
				return devMode;
			},
			$execute: function(_, context, instance) {
				testInternal(_);
			},
		},
		testAll: {
			$title: "Test all",
			$description: "Test",
			$method: "POST",
			$isMethod: true,
			$isDefined: function(_, instance) {
				return devMode;
			},
			$execute: function(_, context, instance) {
				testInternal(_, instance);
				if (!instance.onlySid(_)) {
					var result = _propagate(_, "POST", "test");
					tracer && tracer("test rec: " + result);
				}
			},
		},
	},
	$init: function(_, instance) {
		// Every new instance will take default configuration from the only one traceSetting instance
		instance.stamp(_, datetime.now());
		initConfig(_, instance);
	},
	$defaultOrder: [
		["stamp", false]
	],
	$events: {
		$beforeSave: [

			function(_, instance) {
				if (!instance._noPropagate && !instance.change(_)) throw new Error(locale.format(module, "noChange"));
				if (instance.$created) instance._noLock = true; // do not lock freshly created instances
				if (!instance._noLock) {
					instance.lockInstance(_);
					_refreshInstance(_, instance);

				}
				var status = instance.status(_);
				if (status === "running" || status === "paused") {
					var queue = queues[_getSequence(instance.sequence(_))];
					if (!_updateQueue(_, queue, instance)) instance._noPropagate = true;
					else {
						// changing configuration of an autorecord also changes global configuration
						if (!instance._noPropagate && instance.auto(_)) {
							// set configuration from global configuration (for auto logger)
							var db = adminHelper.getCollaborationOrm(_);
							var settings = db.fetchInstances(_, db.model.getEntity(_, "traceSetting"))[0];
							var confs = settings && settings.configs(_);
							if (confs) {
								confs.reset(_);
								_copyChildren(_, confs, instance.configs(_));
								settings.save(_);
								console.error("Saved global config");
							}
						}
					}
				} else if (status === "created" && !instance.auto(_) && instance.pid(_) === process.pid && instance.name(_).indexOf("Record_") !== 0) {
					var pref = "Record_";
					if (globals.context && globals.context.session && globals.context.session.data && globals.context.session.data.userLogin) {
						pref = pref + globals.context.session.data.userLogin + "_";
					} else {
						pref = pref + "UNKNOW_";
					}
					instance.name(_, pref + instance.name(_));
				}
			}
		],
		$afterSave: [

			function(_, instance) {
				var status = instance.status(_);
				if (!instance._noLock) instance.unlockInstance(_);
				if (!instance._noPropagate && (status === "running" || status === "paused") && !instance.onlySid(_)) {
					var result = _propagate(_, "POST", "change?seq=" + instance.sequence(_) + "&uuid=" + instance.$uuid);
					tracer && tracer("change rec: " + result);
				}
			}
		],
		$errorSave: [

			function(_, instance) {
				if (!instance._noLock) instance.unlockInstance(_);
			}

		]

	}
};


// update queue with new trace settings and log them in instance unless 'notLog' is set
function _updateQueue(_, queue, instance, notLog) {
	var serialized = instance.serializeInstance(_);
	var newConfig = _grabLogLevels(serialized);
	var sequence = instance.sequence(_);
	var changes = configChange(sequence, queues[_getSequence(sequence)], newConfig);
	if (!notLog) {
		for (var i = 0; i < changes.length; i++)
			instance.log(_, changes[i]);
	}
	return changes.length;
}

// set configuration from global configuration (for auto logger)
function initConfig(_, instance) {
	var db = adminHelper.getCollaborationOrm(_);
	var settings = db.fetchInstances(_, db.model.getEntity(_, "traceSetting"))[0];
	var confs = settings && settings.configs(_);
	if (confs) _copyChildren(_, instance.configs(_), confs);
}

// make and register a queue, notify the loggers
// pause: go directly into 'paused' status
// unsetConsole: unset console queue
function _startRecording(_, instance, pause, unsetConsole) {
	if (instance.status(_) !== "created") throw new Error("bad status: " + instance.status(_));

	// set a sequence number if it does not exist yet	
	var isAuto = instance.auto(_);
	var sequence = instance.sequence(_);
	var currentDay;
	if (isAuto) currentDay = instance.name(_).substr(-10);
	if (!sequence) {
		sequence = isAuto ? "auto" : instance.$uuid;
		instance.sequence(_, sequence);
	}
	var serialized = instance.serializeInstance(_);
	var writer = instance.startNewContent(_);
	var queue = traceHelper.makeQueue(_, writer, instance.ticket(_));
	// wrap queue for autorecords to enable transparent change of underlying queue
	queue = new AutoQueue(queue, serialized, currentDay, traceHelper.getSettings(_));
	queues[_getSequence(sequence)] = queue;
	// update status and save
	instance.status(_, pause ? "paused" : "running");
	instance.log(_, locale.format(module, pause ? "recordPaused" : "recordStarted"));
	if (!pause) setRecord(sequence);
	if (unsetConsole) traceHelper.unsetConsole();
}

function setRecord(uuid) {
	var queue = queues[_getSequence(uuid)];
	if (!queue) throw new Error("Invalid sequence number" + uuid + " " + Object.keys(queues).join(","));
	for (var key in queue.levels) {
		traceHelper.getTracer(key).addRecord(uuid, queue.levels[key], queue, queue.sid, withTenant ? (globals.context.tenantId || "$$solo") : null);
	}
	return queue;
}

function unsetRecord(uuid) {
	var queue = queues[_getSequence(uuid)];
	if (!queue) throw new Error("Invalid sequence number");
	for (var key in queue.levels) {
		traceHelper.getTracer(key).deleteRecord(uuid);
	}
	return queue;
}


exports.Tracer = coreHelpers.defineClass(function(id, description, abrev) {
	this.config = {};
	this.id = id;
	this.description = description;
	this.abrev = abrev;
	this.traces = {};
	this.enabled = false;
}, null, {
	openTrace: function(_, type) {
		return this.traces[type];
	},
});

// transparent change of queue when the maximum size is exceeded
// change the logger each day when 'currentDay' is set. 'currentDay' must be a date string in the format YYYY-MM-DD.
var AutoQueue = coreHelpers.defineClass(function(queue, serialized, currentDay, settings) {
	this.size = 0; // current size of binary output stream
	this.index = 0; // index of binary output stream.
	this.maxFiles = settings.maxFiles || 5;
	this.maxSize = settings.maxSize || "100m";
	this.maxSize = traceHelper.computeSize(this.maxSize); // maximal size per binary output stream
	this.currentDay = currentDay; // current date string (for date comparison)
	this.requestChange = false; // autorecord has been closed, so that new autorecord has to be started
	this.temp = undefined; // temporary cache
	this.queue = queue; // current queue
	this.uuid = serialized.$uuid; // uuid of current traceRecord instance
	this.levels = _grabLogLevels(serialized);
	this.sequence = serialized.sequence;
	this.sid = serialized.onlySid ? globals.context.session && globals.context.session.id : null;
	this.errorOccurred = undefined; // change of queue failed: log to console.error
}, null, {
	// not complete implementation: just write to finish queue
	// instance: take this instance of traceRecord
	// function assumes that instance is already locked and will be saved outside
	finish: function(_, instance) {
		try {
			this.queue.write(_);
		} catch (e) {
			console.error("Error during queue close " + e);
		}
	},
	// change the child instance (when newDate is empty) or the trace record
	performChange: function(_, newDate, oldInstance) {
		var self = this;
		var newInstance;
		try {
			if (!oldInstance) {
				oldInstance = _fetchRecord(_, self.uuid);
			}
			if (oldInstance) {
				traceHelper.lockInstanceRetry(_, oldInstance);
				oldInstance._noPropagate = true;
				_refreshInstance(_, oldInstance);
				var writer;
				if (newDate) {
					self.index = 0;
					var sequence = self.sequence;
					stopInternal(_, sequence, oldInstance, true); // last parameter "true" is very important here!!;
					var db = adminHelper.getCollaborationOrm(_);
					// create new autorecord
					var recEntity = db.model.getEntity(_, "traceRecord");
					// no locking because new instance
					newInstance = recEntity.createInstance(_, db, null);

					var _name = "Auto_Record_" + newDate;

					newInstance.name(_, _name);
					newInstance.auto(_, oldInstance.auto(_));
					newInstance.onlySid(_, false);
					newInstance.sequence(_, sequence);
					newInstance.ticket(_, oldInstance.ticket(_));
					_updateQueue(_, self, newInstance, true); // change queue but 
					newInstance.log(_, locale.format(module, "recordStarted"));
					newInstance.status(_, "running");
					writer = newInstance.startNewContent(_, self.index, self.maxFiles);
					newInstance._noPropagate = true;
					newInstance._noLock = true;
					newInstance.save(_);
					self.uuid = newInstance.$uuid;

					// Remove old auto records following 'maxDays' configuration
					traceHelper.removeOldAutoRecords(_, db);
				} else {
					self.index++;
					// change child
					self.finish(_, oldInstance); // finish current queue
					writer = oldInstance.startNewContent(_, self.index, self.maxFiles);
					oldInstance._noLock = true;
					oldInstance._noPropagate = true;
					oldInstance.save(_);
				}
				self.size = 0; // start new writer with empty size
				// replace the queue
				self.queue = traceHelper.makeQueue(_, writer, oldInstance.ticket(_));

			} else {
				console.log("Previous running record [" + self.uuid + "] instance not available : " + self.sequence);
				if (self.size >= self.maxSize) {
					self.size -= 100000; // hack: make size smaller
					console.log("Size reduced to " + self.size);
				}
			}
			var temp1 = self.temp;
			this.temp = undefined;
			if (temp1.length) {
				var item = temp1.shift();
				if (!self.queue.put(item)) { // put first item directly into queue to avoid check for change of queue (and infinite loops...)
					console.error(JSON.stringify(item));
				}
				// put other items into queue via normal mechanism so that further changes can be triggered
				temp1.forEach(function(item) {
					if (!self.put(item)) {
						console.error(JSON.stringify(item));
					}
				});
			}
		} catch (e) {
			console.error("Error during change " + e.stack);
			// only log to console!
			self.errorOccurred = true;
			self.temp.forEach(function(item) {
				console.error(JSON.stringify(item));
			});
			self.temp = undefined;
			// mark old and new instance as error
			if (newInstance) {
				newInstance.status(_, "error");
				newInstance.log(_, locale.format(module, "errorChange", e.stack));
				newInstance._noLock = true;
				newInstance._noPropagate = true;
				newInstance.save(_);
			} else {
				if (oldInstance) {
					oldInstance.status(_, "error");
					oldInstance.log(_, locale.format(module, "errorChange", e.stack));
					oldInstance._noLock = true;
					oldInstance._noPropagate = true;
					oldInstance.save(_);
				}
			}
		} finally {
			if (oldInstance) adminHelper.getCollaborationOrm(_).unlockInstance(_, oldInstance);
			self.requestChange = false; // request change has been finished
		}
	},
	// force a change of the underlying trace record and wait until it has finished
	notify: function(_, instance) {
		if (!this.temp && !this.errorOccurred) { // trigger a chance of the underlying trace queue unless it is already being changed or it has change error
			this.requestChange = true;
			this.temp = []; // start temporary cache at once
			this.performChange(_, null, instance);
		} else return;
	},
	// queue function
	put: function(data) {
		var self = this;
		if (self.temp) { // just put in temporary cache if there is already a cache
			self.temp.push(data);
			return true;
		}
		if (this.errorOccurred) {
			console.error(JSON.stringify(data));
			return true;
		}
		// new day?
		if (data && this.currentDay && data.stamp && data.stamp.substr(0, 10) !== this.currentDay) {
			this.currentDay = data.stamp.substr(0, 10);
			if (!this.temp) this.temp = [data]; // start temporary cache at once
			this.performChange(!_, this.currentDay); // switch to new day
			return true;
		}
		// max size exceeded?
		this.size += JSON.stringify(data).length;
		if (this.size > this.maxSize) {
			if (!this.temp) this.temp = [data]; // start temporary cache at once
			this.performChange(!_);
			return true;
		}
		// normal logging!
		return this.queue.put(data);
	}
});

exports.AutoQueue = AutoQueue;

//copy children from one property to another property
function _copyChildren(_, copy, orig) {
	copy.reset(_);
	orig.toArray(_).forEach_(_, function(_, c) {
		copy.set(_, c);
	});
}

// functions for cluster
// special start function which duplicates the instance
// no locking necessary because new instance
function startInternal(_, uuid) {
	// obtain traceRecord
	var instance = _fetchRecord(_, uuid);
	if (!instance) throw new Error("Wrong uuid " + uuid);
	var db = adminHelper.getCollaborationOrm(_);
	var recEntity = db.model.getEntity(_, "traceRecord");
	// no locking, because instance is new
	var copy = recEntity.createInstance(_, db, null);
	// copy all configurations
	_copyChildren(_, copy.configs(_), instance.configs(_));
	copy.onlySid(_, false); // session dependent loggers are not transferred to another server
	copy.sequence(_, instance.sequence(_));
	copy.ticket(_, instance.ticket(_));
	copy.name(_, instance.name(_));
	_startRecording(_, copy, false);
	copy._noPropagate = true;
	copy._noLock = true;
	copy.save(_);
}

exports.startExternal = function(_, sequence, uuid) {
	startInternal(_, uuid);
};

// instance must already have been locked. Read current contents from database and replace transcript and contents from current database contents so
// that they can safely be changed (this function is interesting when a service is called - the instance may have changed internally since the instance has
// been loaded).
// statusError: throw an error when the instance status has changed inbetween
function _refreshInstance(_, instance, statusError) {
	var currentInstance = _fetchRecord(_, instance.$uuid);
	if (statusError && currentInstance.status(_) !== instance.status(_)) throw new Error(locale.format(module, "statusChanged", currentInstance.status(_)));
	var transcript = instance.transcript(_);
	var currentTranscript = currentInstance && currentInstance.transcript(_);
	if (transcript && currentTranscript && transcript !== currentTranscript) {
		instance.transcript(_, currentTranscript);
		// copy child records
		instance.contents(_).reset(_);
		_copyChildren(_, instance.contents(_), currentInstance.contents(_));
	}
}



function _getInstanceFromSequence(_, sequence) {
	var queue = queues[_getSequence(sequence)];
	if (!queue) throw new Error("Non existing queue " + sequence + " " + Object.keys(queues).join(","));
	var instance = _fetchRecord(_, queue.uuid);
	if (!instance) throw new Error("No instance for uuid " + queue.uuid);
	return instance;
}

function pauseInternal(_, sequence, instance) {
	var queue = unsetRecord(sequence);
	traceHelper.lockInstanceRetry(_, instance);
	try {
		_refreshInstance(_, instance, true); // reload certain contents from current instance
		if (instance.status(_) !== "running") throw new Error("bad status: " + instance.status(_));
		instance.status(_, "paused");
		instance.log(_, locale.format(module, "recordPaused"));
		instance._noPropagate = true;
		instance._noLock = true;
		instance.save(_);
	} finally {
		adminHelper.getCollaborationOrm(_).unlockInstance(_, instance);
	}
}

exports.pauseExternal = function(_, sequence) {
	var instance = _getInstanceFromSequence(_, sequence);
	pauseInternal(_, sequence, instance);
};

function resumeInternal(_, sequence, instance) {
	var queue = setRecord(sequence);
	traceHelper.lockInstanceRetry(_, instance);
	try {
		_refreshInstance(_, instance, true); // reload certain contents from current instance
		if (instance.status(_) !== "paused") throw new Error("bad status: " + instance.status(_));
		instance.status(_, "running");
		instance.log(_, locale.format(module, "recordResumed"));
		instance._noPropagate = true;
		instance._noLock = true;
		instance.save(_);
	} finally {
		adminHelper.getCollaborationOrm(_).unlockInstance(_, instance);
	}
}

exports.resumeExternal = function(_, sequence) {
	var instance = _getInstanceFromSequence(_, sequence);
	resumeInternal(_, sequence, instance);
};

// configuration change
function changeInternal(_, sequence, instance) {
	var queue = queues[_getSequence(sequence)];
	if (!queue) throw new Error("Invalid sequence " + sequence);
	var copy = _fetchRecord(_, queue.uuid);
	traceHelper.lockInstanceRetry(_, copy);
	try {
		_refreshInstance(_, copy, true); // reload certain contents from current instance
		_copyChildren(_, copy.configs(_), instance.configs(_));
		_updateQueue(_, queue, copy);
		copy._noPropagate = true;
		copy._noLock = true;
		copy.save(_);
	} finally {
		adminHelper.getCollaborationOrm(_).unlockInstance(_, copy);
	}
}

exports.changeExternal = function(_, sequence, uuid) {
	var instance = _fetchRecord(_, uuid);
	changeInternal(_, sequence, instance);
};

// finish current queue
function flushInternal(_, sequence, instance) {
	var queue = queues[_getSequence(sequence)];
	if (!queue) return;
	// must do the change of queues implicitly in order to avoid race conditions:
	// a new day or a new child may be started at the same time as the user stops the autorecord. 
	queue.notify(_, instance); // trigger change of internal queue and wait until the change has been done
	return;
}

exports.flushExternal = function(_, sequence) {
	var instance = _getInstanceFromSequence(_, sequence);
	flushInternal(_, sequence, instance);
};

// stopping the logging.
function stopInternal(_, sequence, instance, noUnset, halt) {
	var queue = queues[_getSequence(sequence)];

	if (!queue) return;
	traceHelper.lockInstanceRetry(_, instance);
	try {
		_refreshInstance(_, instance, true); // reload certain contents from current instance
		var status = instance.status(_);
		if (status !== "error" && status !== "complete" && status !== "halted" && status !== "haltedpaused") {
			if (!noUnset) unsetRecord(sequence);
			try {
				queue.finish(_, instance); // finish the queue

				instance.status(_, halt ? (status === "running" ? "halted" : "haltedpaused") : "complete");
				instance.log(_, locale.format(module, "recordCompleted"));
			} catch (e) {
				instance.status(_, halt ? (status === "running" ? "halted" : "haltedpaused") : "error");
				instance.log(_, "Error " + e);
			}
			instance._noPropagate = true;
			instance._noLock = true;
			instance.save(_);
			var diags = [];
			instance.getAllDiagnoses(_, diags);
			if (!noUnset) delete queues[_getSequence(sequence)];
		}
	} finally {
		adminHelper.getCollaborationOrm(_).unlockInstance(_, instance);
	}
}

exports.stopExternal = function(_, sequence) {
	var instance = _getInstanceFromSequence(_, sequence);
	stopInternal(_, sequence, instance);
};

//this function will be executed on all nodes of a cluster when the traceRecord is resumed
function testInternal(_) {
	t1.info && t1.info("test 1 info");
	t1.debug && t1.debug("test 1 debug");
	t1.warn && t1.warn("test 1 warn");
	t1.error && t1.error("test 1 error", new Error("Error T1"));
	t2.info && t2.info("test 2 info");
	t2.debug && t2.debug("test 2 debug");
	t2.warn && t2.warn("test 2 warn");
	t2.error && t2.error("test 2 error", new Error("Error T2"));
}

exports.testExternal = function(_) {
	testInternal(_);
};

function _propagate(_, method, path) { // propagation only when load balancer is available!
	if (withTenant) {
		path += ((path.indexOf('?') >= 0 ? '&' : '?') + 'tenantId=' + globals.context.tenantId);
		console.log("Set tenant " + path);
	}
	if ("mockServer" in config) {
		var options = {
			path: "/nannyCommand/notifyAll/logging/" + path,
			method: method,
			headers: {
				hostname: (globals.context.tenantId || "")
			},
		};
		options.headers[mock.BALANCER_HEADER] = config.port;
		// console.log("Propagate: "+util.format(options))
		try {
			return config.mockServer.mockClient.simpleRequest(options, "", _);
		} catch (e) {
			console.error("Error " + e.stack);
			return e.stack;
		}
	}
}