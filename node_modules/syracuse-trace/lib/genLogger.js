"use strict";

var helpers = require('syracuse-core/lib/helpers');
var tinytim = require('tinytim');
var dateFormat = require('dateformat');
var utils = require('./utils');
var path = require('path');
var defLogger = require('syracuse-trace/lib/defLogger').defLogger;
var saLogger = require('syracuse-trace/lib/saLogger').saLogger;

// Generic logging class
exports.genLogger = helpers.defineClass(function(config) {
	this._config = {
		format: "{{timestamp}} | <{{title}}> | {{file}}:{{line}} | {{message}}",
		inspectOpt: {
			showHidden: false, //if true then the object's non-enumerable properties will be shown too. Defaults to false
			depth: 2 //tells inspect how many times to recurse while formatting the object. This is useful for inspecting large complicated objects. Defaults to 2. To make it recurse indefinitely pass null.
		}
	};
	// Possible list of logging levels
	// emergency
	// alert
	// critical
	// error
	// warning
	// notice
	// info
	// debug
	this.methods = ['debug', 'info', 'warn', 'error'];
	this.defaultLevel = 'warn';
	this.dateformat = (config && config.dateformat) || "UTC:yyyy-mm-dd'T'HH:MM:ss.l'Z'";
	this.stackIndex = (config && config.stackIndex) || 1; // get the specified index of stack as file information. It is useful for development package.

	this.name = config.name;
	this.description = config.description;
}, null, {
	_loadConfig: function(config, mod) {

		this.name = config.name;
		this.description = config.description;
		this.level = this.methods.indexOf((config && config.level) || this.defaultLevel);
		this.enabled = (config && config.enabled) || false;
		if (this.enabled && mod) {
			mod = config.modules.filter(function(m) {
				return m.name === mod;
			})[0];
			if (mod) {
				this.module = mod.name;
				this.level = this.methods.indexOf((mod.level) || this.level);
				this.enabled = mod.enabled;
			}
		}
		this.transport = null;
		switch ((config && config.transport) || "console") {
			case "storagearea":
				this.expiry = (config && config.expiry) || 120;
				this.transport = new saLogger(this.name, this.expiry);
				break;
			case "mongo":
				// this.transport = new mdLogger(logType);
				// break;
			default: // console
				this.transport = new defLogger();
				break;
		}
		//console.log("Loaded tracer configuration [" + config.name + (mod ? (":" + mod.name) : "") + "] : " + JSON.stringify(this, null, 2));
	},
	_logMain: function(type, format, needstack, args) {
		var data = {
			timestamp: dateFormat(new Date(), this.dateformat),
			message: "",
			title: type.toUpperCase(),
			level: type,
			args: args
		};
		data.method = data.path = data.line = data.pos = data.file = '';

		if (needstack) {
			// get call stack, and analyze it
			// get all file,method and line number
			var stacklist = (new Error()).stack.split('\n').slice(3);
			// Stack trace format :
			// http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
			// DON'T Remove the regex expresses to outside of method, there is a BUG in node.js!!!
			var stackReg = /at\s+(.*)\s+\((.*):(\d*):(\d*)\)/gi;
			var stackReg2 = /at\s+()(.*):(\d*):(\d*)/gi;

			var s = stacklist[this.stackIndex] || stacklist[0],
				sp = stackReg.exec(s) || stackReg2.exec(s);
			if (sp && sp.length === 5) {
				data.method = sp[1];
				data.path = sp[2];
				data.line = sp[3];
				data.pos = sp[4];
				data.file = path.basename(data.path);
				data.stack = stacklist.join('\n');
			}
		}

		this.transport.preprocess(data);
		var msg = utils.format.apply(this._config, data.args);
		data.message = msg;

		// call micro-template to ouput
		data.output = tinytim.tim(format, data);

		// transport the final result
		return this.transport.trace(data);
	},
	initialise: function() {
		this.transport.initialise();
	},
	trace: function(type, len, msg) {
		if (len === 0) {
			var myLevel = this.methods.indexOf(type);
			return this.enabled && myLevel >= this.level;
		}
		var format = this._config.format;
		var needstack = /\{\{(method|path|line|pos|file)\}\}/i.test(format);
		return this._logMain(type, format, needstack, [msg]);
	},
	debug: function(msg) {
		return this.trace('debug', arguments.length, msg);
	},
	info: function(msg) {
		return this.trace('info', arguments.length, msg);
	},
	warn: function(msg) {
		return this.trace('warn', arguments.length, msg);
	},
	error: function(msg) {
		return this.trace('error', arguments.length, msg);
	},
	close: function() {
		this.transport.close();
	},
	toJSON: function() {
		return {
			name: this.name,
			module: this.module,
			title: this.description,
			enabled: this.enabled,
			level: this.methods[this.level],
			transport: this.transport
		};
	}
});