"use strict";

var helpers = require('syracuse-core/lib/helpers');
var tinytim = require('tinytim');
var dateFormat = require('dateformat');
var utils = require('./utils');
var path = require('path');
var util = require('util');
var uuid = require('syracuse-core/lib/uuid');

//Standard callback replace _ callback to be able to use this transport in not streamlined functions
var cb = function(err, result) {
	if (err) throw err;
	return result;
};

// Generic logging class
var genLogger = exports.genLogger = helpers.defineClass(function(config) {
	var self = this;
	this.uuid = uuid.generate();
	this._config = {
		format: "{{timestamp}} | <{{title}}> | {{file}}:{{line}} | {{message}}",
		inspectOpt: {
			showHidden: false, //if true then the object's non-enumerable properties will be shown too. Defaults to false
			depth: 2 //tells inspect how many times to recurse while formatting the object. This is useful for inspecting large complicated objects. Defaults to 2. To make it recurse indefinitely pass null.
		}
	};
	// Possible list of logging levels
	// emergency
	// alert
	// critical
	// error
	// warning
	// notice
	// info
	// debug
	this.methods = ['debug', 'info', 'warn', 'error'];
	this.defaultLevel = 'warn';
	this.dateformat = (config && config.dateformat) || "UTC:yyyy-mm-dd'T'HH:MM:ss.l'Z'";
	this.stackIndex = (config && config.stackIndex) || 1; // get the specified index of stack as file information. It is useful for development package.

	this._loadConfig(config);
	this.sessions = {};
	this.methods.forEach(function(m) {
		self._defineProperty(m);
	});
}, null, {
	_loadConfig: function(config, mod) {
		this.name = config.name;
		this.description = config.description;
		this.level = this.methods.indexOf((config && config.level) || this.defaultLevel);
		this.enabled = (config && config.enabled) || false;
		if (this.enabled && mod) {
			if (mod) {
				this.module = mod.name;
				this.level = this.methods.indexOf((mod.level) || this.level);
				this.enabled = mod.enabled;
			}
		}
		this.type = (config && config.transport) || "console";
	},
	_createLine: function(type, format, needstack, args, o) {
		var data = {
			timestamp: dateFormat(new Date(), this.dateformat),
			message: "",
			title: type.toUpperCase(),
			level: type,
			session: "",
			args: args
		};
		data.method = data.path = data.line = data.pos = data.file = '';

		if (needstack) {
			// get call stack, and analyze it
			// get all file,method and line number
			var stacklist = (new Error()).stack.split('\n').slice(3);
			// Stack trace format :
			// http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
			// DON'T Remove the regex expresses to outside of method, there is a BUG in node.js!!!
			var stackReg = /at\s+(.*)\s+\((.*):(\d*):(\d*)\)/gi;
			var stackReg2 = /at\s+()(.*):(\d*):(\d*)/gi;

			var s = stacklist[this.stackIndex] || stacklist[0],
				sp = stackReg.exec(s) || stackReg2.exec(s);
			if (sp && sp.length === 5) {
				data.method = sp[1];
				data.path = sp[2];
				data.line = sp[3];
				data.pos = sp[4];
				data.file = path.basename(data.path);
				data.stack = stacklist.join('\n');
			}
		}
		this.transport && this.transport.preprocess(cb, data);
		var msg = utils.format.apply(this._config, data.args);
		data.message = msg;

		// call micro-template to ouput
		data.output = tinytim.tim(format, data);
		return data;
	},
	isTraceEnabled: function(method) {
		var myLevel = this.methods.indexOf(method);
		var res = this.enabled && this.level != null && myLevel >= this.level;
		return res;
	},
	_defineProperty: function(type) {
		var self = this;
		Object.defineProperty(this, type, {
			get: function() {
				// Check main tracer
				var res = self.isTraceEnabled(type);
				// Check sessions tracers
				res = Object.keys(self.sessions).some(function(sessId) {
					return self.sessions[sessId].isTraceEnabled(type);
				}) || res;
				// If at least one tracer is enabled
				if (res) return self['_' + type];
				return null;
			},
			configurable: true
		});
	},
	_trace: function(type, data) {
		if (this.isTraceEnabled(type) && data) {
			// transport the final result
			if (!this.transport.device) this.transport.initialise(cb);
			this.transport && this.transport.write(cb, data);
		}
		this._defineProperty(type);
	},
	_traceAll: function(type, msg, o) {
		var format = this._config.format;
		var needstack = /\{\{(method|path|line|pos|file)\}\}/i.test(format);
		var data = this._createLine(type, format, needstack, [msg], o);
		var self = this;
		try {
			Object.keys(this.sessions).forEach(function(sessId) {
				self.sessions[sessId]._trace(type, data);
			});
		} finally {

			this._trace(type, data, o);
		}

	},
	_debug: function(msg, o) {
		this._traceAll('debug', msg, o);
	},
	_info: function(msg, o) {
		this._traceAll('info', msg, o);
	},
	_warn: function(msg, o) {
		this._traceAll('warn', msg, o);
	},
	_error: function(msg, o) {
		this._traceAll('error', msg, o);

	},
	fatal: function(msg, o) {

		// TODO: System.exit()
		// Log synchronously in separate file


	},
	toJSON: function() {
		return {
			uuid: this.uuid,
			name: this.name,
			module: this.module,
			title: this.description,
			enabled: this.enabled,
			level: this.methods[this.level],
			transport: this.transport
		};
	}
});


//Session logging class
exports.sessLogger = helpers.defineClass(function(config) {
	genLogger.call(this, config);
	this.stackIndex = (config && config.stackIndex) || 3; // get the specified index of stack as file information. It is useful for development package.
	this.sid = config.sid;
}, genLogger, {
	_loadConfig: function(config, mod) {
		genLogger.prototype._loadConfig.call(this, config, mod);
		if (!this.enabled && this.transport) {
			this.transport.write(cb, undefined);
			this.transport = null;
		}
	}
});