"use strict";
var ez = require('ez-streams');
var zlib = require('zlib');
var hostname = require('os').hostname();



/// !doc
///
/// # Logging/tracing helper function  
///
/// Create a logger with default or existing configuration, making it simple for the applications to
/// specify the correct logger without having to know anything about the options involved.
/// 
/// Auto traces records are launched automatically by default. To 

//methods should already be available from the beginning (because of circular reference)!
var tracers = exports.tracers = {};


var genLogger = require('syracuse-trace/lib/genLogger');
var GenLogger = genLogger.GenLogger;
exports.methods = genLogger.methods;
//called by each modules that use traces
exports.getTracer = function(name) {
	if (!tracers[name]) {
		tracers[name] = new GenLogger({
			name: name
		});
	}
	return tracers[name];
};



var locale = require("syracuse-core/lib/locale");
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var ez = require('ez-streams');
var config = require('config');


/// Usage : Developers need to declare a tracer like following in module header:  
/// 
/// To use a simple group of traces :  
/// 
/// ``` javascript
/// var tracer = traceHelper.getTracer('group');  
/// ```
/// 
/// Or to categorize with a submodule :  
/// 
/// ``` javascript
/// var tracer = traceHelper.getTracer('group.module');  
/// ```
/// 
/// Then the tracer can be used like following :  
/// 
/// ``` javascript
/// tracer.info && tracer.info("My 'info' message");  
/// tracer.debug && tracer.debug("My 'debug' message");  
/// tracer.warn && tracer.warn("My 'warning' message");  
/// tracer.error && tracer.error("My 'error' message", new Error("By this way I will embed the stack in the trace"));  
/// ```
/// 
// called by each modules that use traces
exports.getTracer = function(name) {
	if (!tracers[name]) {
		tracers[name] = new GenLogger({
			name: name
		});
		enableConsole(function(err, result) {
			if (err) throw err;
			return result;
		}, name);
	}
	return tracers[name];
};

//TODO : Call this function from Syracuse server stop entry point...
// stop all logging
exports.haltRecording = function(_) {
	var db = adminHelper.getCollaborationOrm(_);
	var records = db.fetchInstances(_, db.model.getEntity(_, "traceRecord"), {
		pid: process.pid,
		hostname: hostname
	});
	records.forEach_(_, function(_, record) {
		var status = record.status(_);
		if (status !== "complete" && status !== "error") {
			record.haltRecording(_);
		}
	});
};

// mark running records of finished records as error records. 
// parameter start: start manual records
var manageRunningRecords = function(_, start) {
	var db = adminHelper.getCollaborationOrm(_);
	var names = [];

	var cursor = db.createCursor(_, db.model.getEntity(_, "traceRecord"));
	var record;
	var pids = {}; // process must be stopped when the value for this entry is 'true'
	pids[process.pid] = false; // do not stop values of current process
	while (record = cursor.next(_)) {
		var status = record.status(_);
		if (status === "running" || status === "paused") {
			var mustStop = false;
			try {
				var pid = record.pid(_);
				var mustStop = pids[pid];
				if (mustStop === undefined) {
					// must still decide
					try {
						process.kill(pid, 0);
						pids[pid] = false;
					} catch (e) {
						// process does not exist any more
						mustStop = pids[pid] = true;
					}
				}
			} catch (e) {
				mustStop = true;
			}
			if (mustStop) record.errorStopped(_, new Error("Log '" + record.name(_) + "' can't be read because of process crash"));
		}
		// maybe start manual process
		var name = record.name(_);
		if (start && status !== "error" && status !== "complete" && names.indexOf(name) < 0 && !record.auto(_) && !record.onlySid(_)) {
			var instance = record.duplicateManual(_);
			names.push(name);
			switch (status) {
				case 'running':
				case 'halted':
					instance.startRecording(_);
					break;
				case 'haltedpaused':
				case 'paused':
					instance.startRecording(_, true);
					break;
				case 'created':
					instance.save(_);
					break;
				default:
					throw new Error("Wrong status " + status);
			}
		}
	};
};


var consoleQueue = null;

function enableConsole(_, name) {
	consoleQueue = consoleQueue || ez.devices.queue({
		max: config.system.traceQueueMax || 100000,
	});
	var tracesConfig = config && config.traces;
	var defLevel = "error";
	var tracerName, moduleName, level;
	if (name.indexOf('.') !== -1) {
		var parts = name.split('.');
		tracerName = parts[0];
		moduleName = parts[1];
		level = tracesConfig && tracesConfig.console ? (tracesConfig.levels && tracesConfig.levels[tracerName] && tracesConfig.levels[tracerName][moduleName]) || defLevel : defLevel;
	} else {
		tracerName = name;
		level = tracesConfig && tracesConfig.console ? (tracesConfig.levels && tracesConfig.levels[tracerName]) || defLevel : defLevel;
	}

	consoleQueue.reader = consoleQueue.reader.map(function(_, n) {
		return n.stamp + " | " + n.severity + " | " + n.message + (n.stack ? " | " + n.stack : "");
	});
	consoleQueue.reader.pipe(!_, ez.devices.console.log);
	// add record after finishing configuration of reader
	tracers[name].addRecord('console', level, consoleQueue);
}

exports.launchAutoTraceRecord = function(_) {
	var devMode = config && config.system && config.system.enableDevelopmentFeatures;
	var consoleMode = config.traces && config.traces.console;
	var db = adminHelper.getCollaborationOrm(_);
	var recEntity = db.model.getEntity(_, "traceRecord");
	if (!devMode || !consoleMode) {
		var autoRecord = recEntity.createInstance(_, db, null);

		var _date = autoRecord.stamp(_).year + "-" + autoRecord.stamp(_).month + "-" + autoRecord.stamp(_).day;
		var _name = "Auto_Record_" + _date;

		autoRecord.name(_, _name);
		autoRecord.auto(_, true);
		autoRecord.onlySid(_, false);
		autoRecord._noPropagate = true;
		autoRecord.save(_);

		return autoRecord.startRecording(_);
	}
	var records = db.fetchInstances(_, recEntity);
	records.forEach_(_, function(_, record) {
		if (record.status(_) === "running" || record.status(_) === "paused") {
			var mustStop = false;
			try {
				if (pids.indexOf(record.pid(_)) !== -1) {
					mustStop = true;
				} else {
					pids.push(record.pid(_));
					process.kill(record.pid(_), 0);
				}
			} catch (e) {
				mustStop = true;
			}
			if (mustStop) record.errorStopped(_, new Error("Log '" + record.name(_) + "' can't be read because of process crash"));
		}
	});

};

var checkNodelocal = function() {
	if (config && config.traces && config.traces.maxSize) {
		if (!/^(\d+)([mMkKgG]?)$/.test(config.traces.maxSize)) console.error("Traces maxSize pattern is not correct in nodelocal.js");
	}
};

exports.initializeTracers = function(_) {
	var db = adminHelper.getCollaborationOrm(_);
	// Check nodelocal config
	checkNodelocal();
	// Synchronize configurations
	syncConfigs(_, db);
	// Launch auto trace record
	exports.launchAutoTraceRecord(_);
	// Stop runnig records if processes associated do not exist anymore, start new manual records
	manageRunningRecords(_, true);
};

// close session specific trace records
exports.removeSessionTracers = function(_, sid) {
	require('./entities/traceRecord').removeSessionTracers(_, sid);
};


exports.resetConfigs = function(_, instance) {
	var db = adminHelper.getCollaborationOrm(_);
	instance.configs(_).reset(_);
	instance.save(_);
	return syncConfigs(_, db);
};

exports.computeSize = function(size) {
	var matches = /^(\d+)([mMkKgG]?)$/.exec("" + size);
	if (matches) {
		var n = +matches[1];
		var l = matches[2];
		switch (l) {
			case "K":
			case "k":
				return n * 1000;
			case "M":
			case "m":
				return n * 1000000;
			case "G":
			case "g":
				return n * 1000000000;
			case "":
				return n;
			default:
				break;
		}
	}
	return 102400000; // 100 Mo by default
};

// syncConfigs create or update default trace settings configurations
var syncConfigs = function(_, db) {
	var entity = db.model.getEntity(_, "traceConfig");
	var modEntity = db.model.getEntity(_, "traceConfigModule");
	var setEntity = db.model.getEntity(_, "traceSetting");
	var processedConfigs = [];
	var settings = db.fetchInstances(_, setEntity)[0];
	if (!settings) {
		settings = setEntity.createInstance(_, db, null);
		settings.code(_, "settings");
		settings.description(_, "Traces settings");
	}

	var confs = settings && settings.configs(_);

	function _getConfig(_, name) {
		if (confs && confs.getLength() > 0) return confs.filter(_, {
			sdataWhere: "name eq '" + name + "'"
		})[0];
		return null;
	}

	function _updateModules(_, _conf, modName) {
		if (modName) {
			// Delete modules that exist but must not
			if (tracers[_conf.name(_)] && tracers[_conf.name(_)].modules && tracers[_conf.name(_)].modules.getLength() > 0) {
				_conf.modules(_).forEach_(_, function(_, m) {
					if (m.name(_) === modName) _conf.modules(_).deleteInstance(_, m.$uuid);
				});
			}

			var mod;
			// Create modules that do not exist
			if (!_conf.modules(_).toArray(_).some_(_, function(_, mod) {
				return mod.name(_) === modName;
			})) {
				mod = modEntity.createInstance(_, db, null);
				mod.name(_, modName);
				var defLevel = config && config.traces && config.traces.levels && config.traces.levels[_conf.name(_)] && config.traces.levels[_conf.name(_)][modName];
				if (defLevel) mod.level(_, defLevel);
				_conf.modules(_).set(_, mod);
			}

			mod = mod || _conf.modules(_).filter(_, {
				sdataWhere: "name eq '" + modName + "'"
			})[0];

			var description;
			try {
				description = locale.format(module, _conf.name(_) + "." + modName);
			} catch (e) {
				if (config.system && config.system.enableDevelopmentFeatures) {
					console.error("Maybe a description is needed for tracer's module [" + _conf.name(_) + "." + modName + "] in 'syracuse-trace/lib/resources/helper-en.json");
				}
			}
			if (description !== mod.description(_)) {
				mod.description(_, description);
				_conf.modules(_).set(_, mod);
			}
		}
	}

	// Create or update configurations needed by tracers
	Object.keys(tracers).forEach_(_, function(_, name) {

		var tracerName, moduleName;
		if (name.indexOf('.') !== -1) {
			var parts = name.split('.');
			tracerName = parts[0];
			moduleName = parts[1];
		} else {
			tracerName = name;
		}

		var conf = _getConfig(_, tracerName);
		// If no configuration exists, create a default one
		if (!conf) {
			conf = entity.createInstance(_, db, null);
			conf.name(_, tracerName);
			var defLevel = config && config.traces && config.traces.levels && config.traces.levels[conf.name(_)];
			if (defLevel && typeof defLevel === "string") conf.level(_, defLevel);
			settings.configs(_).set(_, conf);
		}
		var description;
		try {
			description = locale.format(module, tracerName);
		} catch (e) {
			if (config.system && config.system.enableDevelopmentFeatures) {
				console.error("Maybe a description is needed for tracer [" + tracerName + "] in 'syracuse-trace/lib/resources/helper-en.json");
			}
		}
		if (description !== conf.description(_)) {
			conf.description(_, description);
		}

		_updateModules(_, conf, moduleName);
		processedConfigs.push(conf.$uuid);
	});

	// Remove or update configurations not needed by tracers
	confs.refresh(_);
	confs.toArray(_).filter_(_, function(_, c) {
		return processedConfigs.indexOf(c.$uuid) === -1;
	}).forEach_(_, function(_, c) {
		var removed = false;
		if (!Object.keys(tracers).some_(_, function(_, name) {
			return name === c.name(_) || name.indexOf(c.name(_) + ".") !== -1;
		})) {
			removed = true;
			confs.deleteInstance(_, c.$uuid);
			//c.deleteSelf(_);
		}
		if (!removed && c.modularized(_)) {
			if (c.modules(_).getLength() > 0) {
				c.modules(_).forEach_(_, function(_, m) {
					_updateModules(_, c, m.name(_));
				});
			}
		}
		//if (!removed) c.save(_);
	});
	settings.save(_);
	return settings;
};


// takes the writableStream of MongoDb and returns an ez-stream queue
exports.makeQueue = function(_, writer, ticket) {
	writer = ez.helpers.binary.writer(writer, {
		bufSize: 64000,
	});
	//

	var q = ez.devices.queue({
		max: config.system.traceQueueMax || 100000,
	});

	// Put entity name
	q.put({
		entity: "trace"
	});
	// Put ticket number
	q.put({
		ticket: ticket || ""
	});

	// Apply stream transformations
	q.reader = q.reader.transform(ez.transforms.json.formatter());
	q.reader = q.reader.map(ez.mappers.convert.bufferify());
	q.reader = q.reader.nodeTransform(zlib.createGzip());


	// q.reader.pipe(!_, writer);
	q.reader.pipe(_ >> function(err) {
		if (err) console.error("Error when closing queue: " + err.stack);
	}, writer);
	return q;
};