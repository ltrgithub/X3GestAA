"use strict";

/// !doc
///
/// # Logging/tracing helper function  
///
/// Create a logger with default or existing configuration, making it simple for the applications to
/// specify the correct logger without having to know anything about the options involved.
/// 
/// Auto traces records are launched automatically by default. To 

var locale = require("syracuse-core/lib/locale");
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var ez = require('ez-streams');

// methods should already be available from the beginning (because of circular reference)!
exports.methods = ['debug', 'info', 'warn', 'error', 'fatal'];

var genLogger = require('syracuse-trace/lib/genLogger').genLogger;
var config = require('config');

var tracers = exports.tracers = {};


/// Usage : Developers need to declare a tracer like following in module header :  
/// 
/// To use a simple group of traces :  
/// 
/// ``` javascript
/// var tracer = traceHelper.getTracer('group');  
/// ```
/// 
/// Or to categorize with a submodule :  
/// 
/// ``` javascript
/// var tracer = traceHelper.getTracer('group.module');  
/// ```
/// 
/// Then the tracer can be used like following :  
/// 
/// ``` javascript
/// tracer.info && tracer.info("My 'info' message");  
/// tracer.debug && tracer.debug("My 'debug' message");  
/// tracer.warn && tracer.warn("My 'warning' message");  
/// tracer.error && tracer.error("My 'error' message", new Error("By this way I will embed the stack in the trace"));  
/// ```
/// 
// called by each modules that use traces
exports.getTracer = function(name) {
	if (!tracers[name]) {
		tracers[name] = new genLogger({
			name: name
		});
		enableConsole(function(err, result) {
			if (err) throw err;
			return result;
		}, name);
	}
	return tracers[name];
};

// TODO : Call this function from Syracuse server stop entry point...
var stopRunningRecords = function(_) {
	var db = adminHelper.getCollaborationOrm(_);
	var records = db.fetchInstances(_, db.model.getEntity(_, "traceRecord"));
	var pids = [];
	records.forEach_(_, function(_, record) {
		if (record.status(_) === "running" || record.status(_) === "paused") {
			var mustStop = false;
			try {
				if (pids.indexOf(record.pid(_)) !== -1) {
					mustStop = true;
				} else {
					pids.push(record.pid(_));
					process.kill(record.pid(_), 0);
				}
			} catch (e) {
				mustStop = true;
			}
			if (mustStop) record.stopRecording(_, new Error("Log '" + record.name(_) + "' can't be read because of process crash"));
		}
	});
};


var consoleQueue = null;

function enableConsole(_, name) {
	consoleQueue = consoleQueue || ez.devices.queue({
		max: config.system.traceQueueMax || 100000,
	});
	var tracesConfig = config && config.traces;
	var defLevel = "error";
	var tracerName, moduleName, level;
	if (name.indexOf('.') !== -1) {
		var parts = name.split('.');
		tracerName = parts[0];
		moduleName = parts[1];
		level = tracesConfig && tracesConfig.console ? (tracesConfig.levels && tracesConfig.levels[tracerName] && tracesConfig.levels[tracerName][moduleName]) || defLevel : defLevel;
	} else {
		tracerName = name;
		level = tracesConfig && tracesConfig.console ? (tracesConfig.levels && tracesConfig.levels[tracerName]) || defLevel : defLevel;
	}
	tracers[name].addRecord('console', {
		level: level,
		queue: consoleQueue
	});

	consoleQueue.reader = consoleQueue.reader.map(function(_, n) {
		return n.stamp + " | " + n.severity + " | " + n.message + (n.stack ? " | " + n.stack : "");
	});
	consoleQueue.reader.pipe(!_, ez.devices.console.log);
}

exports.launchAutoTraceRecord = function(_) {
	function renameOldAutoRecord(_) {
		var recs = db.fetchInstances(_, recEntity, {
			sdataWhere: "name like '" + _name + "%'",
			orderBy: [{
				binding: "name",
				descending: true
			}]
		});

		var maxFiles = (config && config.traces && config.traces.maxFiles) || 10;
		if (recs.length >= maxFiles) {
			recs.shift().deleteSelf(_);
		}

		recs.forEach_(_, function(_, r) {
			var idx = r.name(_).indexOf('.');
			var id = 0;
			if (idx !== -1) {
				id = parseInt(r.name(_).substring(idx + 1), 10);
			}
			r.name(_, _name + "." + (id + 1));
			r.save(_);
		});
	}

	var devMode = config && config.system && config.system.enableDevelopmentFeatures;
	var consoleMode = config.traces && config.traces.console;
	if (!devMode || !consoleMode) {
		var db = adminHelper.getCollaborationOrm(_);
		var recEntity = db.model.getEntity(_, "traceRecord");
		var autoRecord = recEntity.createInstance(_, db, null);

		var _date = autoRecord.stamp(_).year + "-" + autoRecord.stamp(_).month + "-" + autoRecord.stamp(_).day;
		var _name = "Auto_Record_" + _date + "_PID-" + process.pid;

		renameOldAutoRecord(_);

		autoRecord.name(_, _name);
		autoRecord.auto(_, true);
		autoRecord.save(_);
		autoRecord.startRecording(_);
		return autoRecord.pid(_);
	}
};

var pattern = /^([0-9]*)([m|M|k|K|g|G]?)$/;
var checkNodelocal = function() {
	if (config && config.traces && config.traces.maxSize) {
		if (!pattern.test(config.traces.maxSize)) console.error("Traces maxSize pattern is not correct in nodelocal.js");
	}
};

exports.initializeTracers = function(_) {
	var db = adminHelper.getCollaborationOrm(_);
	// Check nodelocal config
	checkNodelocal();
	// Synchronize configurations
	syncConfigs(_, db);
	// Stop runnig records if processes associated do not exist anymore
	stopRunningRecords(_);
	// Launch auto trace record
	exports.launchAutoTraceRecord(_);
};

exports.resetConfigs = function(_, instance) {
	var db = adminHelper.getCollaborationOrm(_);
	instance.configs(_).reset(_);
	instance.save(_);
	return syncConfigs(_, db);
};

exports.computeSize = function(size) {
	var matches = pattern.exec(size);
	if (matches) {
		var n = parseInt(matches[1], 10) * 1024;
		var l = matches[2];
		switch (l.toUpperCase()) {
			case "K":
				return n;
			case "M":
				return n * 1000;
			case "G":
				return n * 1000000;
			default:
				break;
		}
	}
	return 102400000; // 100 Mo by default
};

// syncConfigs create or update default trace settings configurations
var syncConfigs = function(_, db) {
	var entity = db.model.getEntity(_, "traceConfig");
	var modEntity = db.model.getEntity(_, "traceConfigModule");
	var setEntity = db.model.getEntity(_, "traceSetting");
	var processedConfigs = [];
	var settings = db.fetchInstances(_, setEntity)[0];
	if (!settings) {
		settings = setEntity.createInstance(_, db, null);
		settings.code(_, "settings");
		settings.description(_, "Traces settings");
	}

	var confs = settings && settings.configs(_);

	function _getConfig(_, name) {
		if (confs && confs.getLength() > 0) return confs.filter(_, {
			sdataWhere: "name eq '" + name + "'"
		})[0];
		return null;
	}

	function _updateModules(_, _conf, modName) {
		if (modName) {
			// Delete modules that exist but must not
			if (tracers[_conf.name(_)] && tracers[_conf.name(_)].modules && tracers[_conf.name(_)].modules.getLength() > 0) {
				_conf.modules(_).forEach_(_, function(_, m) {
					if (m.name(_) === modName) _conf.modules(_).deleteInstance(_, m.$uuid);
				});
			}

			var mod;
			// Create modules that do not exist
			if (!_conf.modules(_).toArray(_).some_(_, function(_, mod) {
				return mod.name(_) === modName;
			})) {
				mod = modEntity.createInstance(_, db, null);
				mod.name(_, modName);
				var defLevel = config && config.traces && config.traces.levels && config.traces.levels[_conf.name(_)] && config.traces.levels[_conf.name(_)][modName];
				if (defLevel) mod.level(_, defLevel);
				_conf.modules(_).set(_, mod);
			}

			mod = mod || _conf.modules(_).filter(_, {
				sdataWhere: "name eq '" + modName + "'"
			})[0];

			var description;
			try {
				description = locale.format(module, _conf.name(_) + "." + modName);
			} catch (e) {
				if (config.system && config.system.enableDevelopmentFeatures) {
					console.error("Maybe a description is needed for tracer's module [" + _conf.name(_) + "." + modName + "] in 'syracuse-trace/lib/resources/helper-en.json");
				}
			}
			if (description !== mod.description(_)) {
				mod.description(_, description);
				_conf.modules(_).set(_, mod);
			}
		}
	}

	// Create or update configurations needed by tracers
	Object.keys(tracers).forEach_(_, function(_, name) {

		var tracerName, moduleName;
		if (name.indexOf('.') !== -1) {
			var parts = name.split('.');
			tracerName = parts[0];
			moduleName = parts[1];
		} else {
			tracerName = name;
		}

		var conf = _getConfig(_, tracerName);
		// If no configuration exists, create a default one
		if (!conf) {
			conf = entity.createInstance(_, db, null);
			conf.name(_, tracerName);
			var defLevel = config && config.traces && config.traces.levels && config.traces.levels[conf.name(_)];
			if (defLevel && typeof defLevel === "string") conf.level(_, defLevel);
			settings.configs(_).set(_, conf);
		}
		var description;
		try {
			description = locale.format(module, tracerName);
		} catch (e) {
			if (config.system && config.system.enableDevelopmentFeatures) {
				console.error("Maybe a description is needed for tracer [" + tracerName + "] in 'syracuse-trace/lib/resources/helper-en.json");
			}
		}
		if (description !== conf.description(_)) {
			conf.description(_, description);
		}

		_updateModules(_, conf, moduleName);
		processedConfigs.push(conf.$uuid);
	});

	// Remove or update configurations not needed by tracers
	confs.refresh(_);
	confs.toArray(_).filter_(_, function(_, c) {
		return processedConfigs.indexOf(c.$uuid) === -1;
	}).forEach_(_, function(_, c) {
		var removed = false;
		if (!Object.keys(tracers).some_(_, function(_, name) {
			return name === c.name(_) || name.indexOf(c.name(_) + ".") !== -1;
		})) {
			removed = true;
			confs.deleteInstance(_, c.$uuid);
			//c.deleteSelf(_);
		}
		if (!removed && c.modularized(_)) {
			if (c.modules(_).getLength() > 0) {
				c.modules(_).forEach_(_, function(_, m) {
					_updateModules(_, c, m.name(_));
				});
			}
		}
		//if (!removed) c.save(_);
	});
	settings.save(_);
	return settings;
};