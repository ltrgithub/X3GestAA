"use strict";

/// !doc
///
/// # Logging/tracing helper function  
///
/// Create a logger with default or existing configuration, making it simple for the applications to
/// specify the correct logger without having to know anything about
/// the options involved.

var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var genLogger = require('syracuse-trace/lib/genLogger').genLogger;

var tracers = exports.tracers = {};

// writer is set in traceSetting afterSave action.
exports.writer = null;

// called by each modules that use traces
exports.getTracer = function(name) {
	var tracerName, moduleName;
	if (name.indexOf('.') !== -1) {
		var parts = name.split('.');
		tracerName = parts[0];
		moduleName = parts[1];
	} else {
		tracerName = name;
	}
	//
	if (moduleName) {
		tracers[tracerName] = tracers[tracerName] || {};
		tracers[tracerName].modules = tracers[tracerName].modules || {};
		if (!tracers[tracerName].modules[moduleName]) {
			tracers[tracerName].modules[moduleName] = new genLogger({
				name: tracerName
			});
		}
		return tracers[tracerName].modules[moduleName];
	} else {
		tracers[tracerName] = tracers[tracerName] || new genLogger({
			name: tracerName
		});
		return tracers[tracerName];
	}
};

exports.removeSessionTracers = function(sid) {
	Object.keys(tracers).forEach(function(config) {
		var _tracer = tracers[config];
		if (_tracer.modules) {
			Object.keys(_tracer.modules).forEach(function(name) {
				if (_tracer.modules[name].sessions && _tracer.modules[name].sessions[sid]) {
					delete _tracer.modules[name].sessions[sid];
				}
			});
		} else {
			if (_tracer.sessions && _tracer.sessions[sid]) {
				delete _tracer.sessions[sid];
			}
		}
	});
};

// syncConfigs(_) method :
// - create 
// - remove obsoletes configurations (configs or modules)
// - save systematically each configurations -> by afterSave event
// TODO : must update descriptions if localizations available
exports.syncConfigs = function(_) {
	var db = adminHelper.getCollaborationOrm(_);
	var entity = db.model.getEntity(_, "traceConfig");
	var modEntity = db.model.getEntity(_, "traceConfigModule");

	var processedConfigs = [];
	var settings = db.fetchInstances(_, db.model.getEntity(_, "traceSetting"))[0];
	var confs = settings && settings.configs(_);

	function _getConfig(_, name) {
		if (confs && confs.getLength() > 0) return confs.filter(_, {
			sdataWhere: "name eq '" + name + "'"
		})[0];
		return null;

	}

	function _updateModules(_, _conf, mods) {
		_conf.modules(_).toArray(_).forEach_(_, function(_, m) {
			if (tracers[_conf.name(_)] && tracers[_conf.name(_)].modules && Object.keys(tracers[_conf.name(_)].modules).indexOf(m.name(_)) === -1) {
				_conf.modules(_).deleteInstance(_, m.$uuid);
			}
		});

		if (mods && Object.keys(mods).length !== 0) {
			//console.log("Modules: "+JSON.stringify(mods,null,2));
			Object.keys(mods).forEach_(_, function(_, mName) {
				if (!_conf.modules(_).toArray(_).some_(_, function(_, mod) {
					return mod.name(_) === mName;
				})) {
					var mod = modEntity.createInstance(_, db, null);
					mod.name(_, mName);
					_conf.modules(_).set(_, mod);
				}
			});
		}
	}

	// Create or update configurations needed by tracers
	Object.keys(tracers).forEach_(_, function(_, name) {
		var config = _getConfig(_, name);

		// If no configuration exists, create a default one
		if (!config) {
			config = entity.createInstance(_, db, null);
			config.name(_, name);
			//config.description(_, description);
			settings.configs(_).set(_, config);
		}
		_updateModules(_, config, tracers[name].modules);
		processedConfigs.push(config.$uuid);
	});

	// Remove or update configurations not needed by tracers
	confs.refresh(_);
	confs.toArray(_).filter_(_, function(_, c) {
		return processedConfigs.indexOf(c.$uuid) === -1;
	}).forEach_(_, function(_, c) {
		var removed = false;
		if (!Object.keys(tracers).some_(_, function(_, name) {
			return name === c.name(_) || name.indexOf(c.name(_) + ".") !== -1;
		})) {
			removed = true;
			confs.deleteInstance(_, c.$uuid);
			//c.deleteSelf(_);
		}

		if (!removed && c.modularized(_)) {
			_updateModules(_, c);
		}
		//if (!removed) c.save(_);
	});
	settings.save(_);
};