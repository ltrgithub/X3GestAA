"use strict";

/// !doc
///
/// # Logging/tracing helper function  
///
/// Create a logger with default or existing configuration, making it simple for the applications to
/// specify the correct logger without having to know anything about the options involved.
/// 

var locale = require("syracuse-core/lib/locale");
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;

// methods should already be available from the beginning (because of circular reference)!
exports.methods = ['debug', 'info', 'warn', 'error', 'fatal'];

var genLogger = require('syracuse-trace/lib/genLogger').genLogger;
var mock = require('syracuse-load/lib/mock');
var config = require('config');

var defaultTracesLevels = config.tracesLevels;

var tracers = exports.tracers = {};


// called by each modules that use traces
exports.getTracer = function(name) {
	if (!tracers[name]) {
		tracers[name] = new genLogger({
			name: name
		});
	}
	return tracers[name];
};

var getProcessesPids = function(_) {
	var list = [];
	if (config.mockServer) {
		var options = {
			path: "/nannyCommand/notifyNannies/pid",
			method: "GET"
		};
		//var test = mock.simpleRequest(config.mockServer.mockClient, options, null, _);
		//console.log("Pids: "+test);
		// then text will contain the answer. Note that this will contain a line with the host name first for each host
	}
	return list;
};

// TODO : Call this function from Syracuse server stop entry point...
exports.stopRunningRecords = function(_) {

	//	var pidList = getProcessesPids(_);
	//	console.log("pidList: "+JSON.stringify(pidList,null,2));
	var db = adminHelper.getCollaborationOrm(_);
	var records = db.fetchInstances(_, db.model.getEntity(_, "traceRecord"));
	records.forEach_(_, function(_, record) {
		//		if (pidList.indexOf(record.pid()) === -1 && record.status(_) === "running" || record.status(_) === "paused") {
		//			record.stopRecording(_, new Error("Log '"+record.name(_)+"' can't be read because of process crash"));
		//		}

		if (record.status(_) === "running" || record.status(_) === "paused") {
			var mustStop = false;
			try {
				console.log("PID: " + record.pid(_));
				process.kill(record.pid(_), 0);
			} catch (e) {
				mustStop = true;
			}
			if (mustStop) record.stopRecording(_, new Error("Log '" + record.name(_) + "' can't be read because of process crash"));
		}
	});
};

exports.launchAutoTraceRecord = function(_) {

	function renameOldAutoRecord(_) {
		var recs = db.fetchInstances(_, recEntity, {
			sdataWhere: "name like '" + _name + "%'",
			orderBy: [{
				binding: "name",
				descending: true
			}]
		});

		var maxFiles = (config && config.traces && config.traces.maxFiles) || 10;
		console.log("MAX: " + maxFiles);
		if (recs.length >= maxFiles) {
			recs.shift().deleteSelf(_);
		}

		recs.forEach_(_, function(_, r) {
			var idx = r.name(_).indexOf('.');
			var id = 0;
			if (idx !== -1) {
				id = parseInt(r.name(_).substring(idx + 1), 10);
			}
			r.name(_, _name + "." + (id + 1));
			r.save(_);
		});
	}

	var db = adminHelper.getCollaborationOrm(_);
	var recEntity = db.model.getEntity(_, "traceRecord");
	var autoRecord = recEntity.createInstance(_, db, null);

	var _date = autoRecord.stamp(_).year + "-" + autoRecord.stamp(_).month + "-" + autoRecord.stamp(_).day;
	var _name = "Auto_Record_" + _date + "_PID-" + process.pid;

	renameOldAutoRecord(_);

	autoRecord.name(_, _name);
	autoRecord.auto(_, true);
	autoRecord.save(_);
	autoRecord.startRecording(_);
	return autoRecord.pid(_);
};

exports.initializeTracers = function(_) {
	var db = adminHelper.getCollaborationOrm(_);
	// Synchronize configurations
	syncConfigs(_, db);

	// Stop running records (if server crashed)
	exports.stopRunningRecords(_);

	// Launch auto trace record
	exports.launchAutoTraceRecord(_);
};

exports.resetConfigs = function(_, instance) {
	var db = adminHelper.getCollaborationOrm(_);
	instance.configs(_).reset(_);
	instance.save(_);
	return syncConfigs(_, db);
};

// syncConfigs create or update default trace settings configurations
var syncConfigs = function(_, db) {
	var entity = db.model.getEntity(_, "traceConfig");
	var modEntity = db.model.getEntity(_, "traceConfigModule");
	var setEntity = db.model.getEntity(_, "traceSetting");
	var processedConfigs = [];
	var settings = db.fetchInstances(_, setEntity)[0];
	if (!settings) {
		settings = setEntity.createInstance(_, db, null);
		settings.code(_, "settings");
		settings.description(_, "Traces settings");
	}

	var confs = settings && settings.configs(_);

	function _getConfig(_, name) {
		if (confs && confs.getLength() > 0) return confs.filter(_, {
			sdataWhere: "name eq '" + name + "'"
		})[0];
		return null;
	}

	function _updateModules(_, _conf, modName) {
		if (modName) {
			// Delete modules that exist but must not
			if (tracers[_conf.name(_)] && tracers[_conf.name(_)].modules && tracers[_conf.name(_)].modules.getLength() > 0) {
				_conf.modules(_).forEach_(_, function(_, m) {
					if (m.name(_) === modName) _conf.modules(_).deleteInstance(_, m.$uuid);
				});
			}

			var mod;
			// Create modules that do not exist
			if (!_conf.modules(_).toArray(_).some_(_, function(_, mod) {
				return mod.name(_) === modName;
			})) {
				mod = modEntity.createInstance(_, db, null);
				mod.name(_, modName);
				var defLevel = defaultTracesLevels && defaultTracesLevels[_conf.name(_)] && defaultTracesLevels[_conf.name(_)][modName];
				if (defLevel) mod.level(_, defLevel);
				_conf.modules(_).set(_, mod);
			}

			mod = mod || _conf.modules(_).filter(_, {
				sdataWhere: "name eq '" + modName + "'"
			})[0];

			var description;
			try {
				description = locale.format(module, _conf.name(_) + "." + modName);
			} catch (e) {
				if (config.system && config.system.enableDevelopmentFeatures) {
					console.error("Maybe a description is needed for tracer's module [" + _conf.name(_) + "." + modName + "] in 'syracuse-trace/lib/resources/helper-en.json");
				}
			}
			if (description !== mod.description(_)) {
				mod.description(_, description);
				_conf.modules(_).set(_, mod);
			}
		}
	}

	// Create or update configurations needed by tracers
	Object.keys(tracers).forEach_(_, function(_, name) {

		var tracerName, moduleName;
		if (name.indexOf('.') !== -1) {
			var parts = name.split('.');
			tracerName = parts[0];
			moduleName = parts[1];
		} else {
			tracerName = name;
		}

		var conf = _getConfig(_, tracerName);
		// If no configuration exists, create a default one
		if (!conf) {
			conf = entity.createInstance(_, db, null);
			conf.name(_, tracerName);
			var defLevel = defaultTracesLevels && defaultTracesLevels[conf.name(_)];
			if (defLevel && typeof defLevel === "string") conf.level(_, defLevel);
			settings.configs(_).set(_, conf);
		}
		var description;
		try {
			description = locale.format(module, tracerName);
		} catch (e) {
			if (config.system && config.system.enableDevelopmentFeatures) {
				console.error("Maybe a description is needed for tracer [" + tracerName + "] in 'syracuse-trace/lib/resources/helper-en.json");
			}
		}
		if (description !== conf.description(_)) {
			conf.description(_, description);
		}

		_updateModules(_, conf, moduleName);
		processedConfigs.push(conf.$uuid);
	});

	// Remove or update configurations not needed by tracers
	confs.refresh(_);
	confs.toArray(_).filter_(_, function(_, c) {
		return processedConfigs.indexOf(c.$uuid) === -1;
	}).forEach_(_, function(_, c) {
		var removed = false;
		if (!Object.keys(tracers).some_(_, function(_, name) {
			return name === c.name(_) || name.indexOf(c.name(_) + ".") !== -1;
		})) {
			removed = true;
			confs.deleteInstance(_, c.$uuid);
			//c.deleteSelf(_);
		}
		if (!removed && c.modularized(_)) {
			if (c.modules(_).getLength() > 0) {
				c.modules(_).forEach_(_, function(_, m) {
					_updateModules(_, c, m.name(_));
				});
			}
		}
		//if (!removed) c.save(_);
	});
	settings.save(_);
	return settings;
};