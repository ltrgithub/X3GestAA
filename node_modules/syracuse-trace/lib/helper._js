"use strict";

/// !doc
///
/// # Logging/tracing helper function  
///
/// Create a logger with default or existing configuration, making it simple for the applications to
/// specify the correct logger without having to know anything about
/// the options involved.

var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var genLoggerHelper = require('syracuse-trace/lib/genLogger');
var genLogger = genLoggerHelper.genLogger;
var sessLogger = genLoggerHelper.sessLogger;
var defLogger = require('syracuse-trace/lib/defLogger').defLogger;
var saLogger = require('syracuse-trace/lib/saLogger').saLogger;
var mongoLogger = require('syracuse-trace/lib/mongoLogger').mongoLogger;

var tracers = {};
var sessionConfigs = {};
var syncDone = false;

// for internal traces
var _tracer; // = console.log;

// called by each modules that use traces
var getTracer = exports.getTracer = function(name) {
	var tracerName, moduleName;
	if (name.indexOf('.') !== -1) {
		var parts = name.split('.');
		tracerName = parts[0];
		moduleName = parts[1];
	} else {
		tracerName = name;
	}

	if (moduleName) {
		tracers[tracerName] = tracers[tracerName] || {};
		tracers[tracerName].modules = tracers[tracerName].modules || {};
		if (!tracers[tracerName].modules[moduleName]) {
			tracers[tracerName].modules[moduleName] = new genLogger({
				name: tracerName
			});
		}
		return tracers[tracerName].modules[moduleName];
	} else {
		tracers[tracerName] = tracers[tracerName] || new genLogger({
			name: tracerName
		});
		return tracers[tracerName];
	}
};

exports.loadTracerConfig = function(_, conf, name, mod) {
	var tracer = getTracer(name + (mod ? "." + mod : ""));
	if (tracer) {
		var serializedConf = conf.serializeInstance(_);
		mod = serializedConf.modules && serializedConf.modules.filter(function(m) {
			return m.name === mod;
		})[0];
		_tracer && _tracer("Load tracer configuration [" + serializedConf.name + (mod ? (":" + mod.name) : "") + "] : " + JSON.stringify(tracer, null, 2));
		tracer._loadConfig(serializedConf, mod);
		setTracerTransport(tracer);
	}
};


function setTracerTransport(tracer) {
	function setTransport() {
		switch (tracer && tracer.type) {
			case "storagearea":
				transport = new saLogger(tracer.name);
				break;
			case "mongo":
				transport = new mongoLogger(tracer.name);
				break;
			default: // console
				transport = new defLogger();
				break;
		}
		tracers[tracer.name]._transport = transport;
	}
	//
	var transport = tracers[tracer.name] && tracers[tracer.name]._transport;
	if (transport) {
		if (tracer.type !== transport.type) {
			transport.close();
			setTransport().initialise();
		}
	} else {
		setTransport().initialise();
	}
	tracer.transport = tracers[tracer.name]._transport;
}

// syncConfigs(_) method :
// - create 
// - remove obsoletes configurations (configs or modules)
// - save systematically each configurations -> by afterSave event
// TODO : must update descriptions if localizations available
exports.syncConfigs = function(_) {
	_tracer && _tracer("Tracers: " + JSON.stringify(tracers, null, 2));
	var db = adminHelper.getCollaborationOrm(_);
	var entity = db.model.getEntity(_, "traceConfig");
	var modEntity = db.model.getEntity(_, "traceConfigModule");

	var processedConfigs = [];

	function _getConfig(_, name) {
		var db = adminHelper.getCollaborationOrm(_);
		var inst = db.fetchInstance(_, db.model.getEntity(_, "traceConfig"), {
			sdataWhere: "name eq '" + name + "'"
		});
		return inst ? inst : null;
	}

	function _updateModules(_, _conf, mods) {
		_conf.modules(_).toArray(_).forEach_(_, function(_, m) {
			if (tracers[_conf.name(_)] && tracers[_conf.name(_)].modules && Object.keys(tracers[_conf.name(_)].modules).indexOf(m.name(_)) === -1) {
				_conf.modules(_).deleteInstance(_, m.$uuid);
			}
		});

		if (mods && Object.keys(mods).length !== 0) {
			//console.log("Modules: "+JSON.stringify(mods,null,2));
			Object.keys(mods).forEach_(_, function(_, mName) {
				if (!_conf.modules(_).toArray(_).some_(_, function(_, mod) {
					return mod.name(_) === mName;
				})) {
					var mod = modEntity.createInstance(_, db, null);
					mod.name(_, mName);
					_conf.modules(_).set(_, mod);
				}
			});
		}
	}

	// Create or update configurations needed by tracers
	Object.keys(tracers).forEach_(_, function(_, name) {
		_tracer && _tracer("\n*************");
		_tracer && _tracer("Create or update configurations needed by tracers : " + name);
		var config = _getConfig(_, name);

		// If no configuration exists, create a default one
		if (!config) {
			config = entity.createInstance(_, db, null);
			config.name(_, name);
			//config.description(_, description);
		}
		_updateModules(_, config, tracers[name].modules);

		config.save(_);
		processedConfigs.push(config.$uuid);
	});

	// Remove or update configurations not needed by tracers
	var configs = db.fetchInstances(_, entity);
	configs.filter_(_, function(_, c) {
		return processedConfigs.indexOf(c.$uuid) === -1;
	}).forEach_(_, function(_, c) {
		_tracer && _tracer("\n*************");
		_tracer && _tracer("Remove or update configurations not needed by tracers : " + c.name(_));
		var removed = false;
		if (!Object.keys(tracers).some_(_, function(_, name) {
			return name === c.name(_) || name.indexOf(c.name(_) + ".") !== -1;
		})) {
			removed = true;
			c.deleteSelf(_);
		}

		if (!removed && c.modularized(_)) {
			_updateModules(_, c);
		}
		if (!removed) c.save(_);
	});

	syncDone = true;
};

function genDefSessionConfig(sid, name) {
	var t = getTracer(name);
	var c = {
		name: name,
		sid: sid
	};
	if (t.modules) {
		c.modules = [];
		Object.keys(t.modules).forEach(function(mName) {
			c.modules.push({
				name: mName
			});
		});
	}
	return c;
}

var getSessionConfig = exports.getSessionConfig = function(sid, name) {
	if (sessionConfigs[sid] && sessionConfigs[sid][name]) {
		return sessionConfigs[sid][name];
	}
	if (sid && !sessionConfigs[sid]) {
		getSessionConfigs(sid);
	}
	sessionConfigs[sid][name] = genDefSessionConfig(sid, name);
	return sessionConfigs[sid][name];
};

var getSessionConfigs = exports.getSessionConfigs = function(sid) {
	//
	if (sessionConfigs[sid]) return sessionConfigs[sid];
	sessionConfigs[sid] = {};
	Object.keys(tracers).forEach(function(tName) {
		sessionConfigs[sid][tName] = getSessionConfig(sid, tName);
	});
	return sessionConfigs[sid];
};

exports.loadSessionConfig = function(_, inst) {
	function loadSessionTracer(tName, mod) {
		var tracer = getTracer(tName + (mod ? "." + mod.name : ""));
		if (!tracer.sessions[sid]) {
			tracer.sessions[sid] = new sessLogger({
				name: tName,
				sid: sid
			});
		}
		tracer.sessions[sid]._loadConfig(sessionConfigs[sid][name], mod);
		// Load transport if tracer is enabled(
		if (tracer.sessions[sid].enabled) {
			var transport = sessionConfigs[sid][name] && sessionConfigs[sid][name]._transport;
			if (!transport) {
				_tracer && _tracer("Create transport for session logger");
				sessionConfigs[sid][name]._transport = new saLogger(tracer.name);
				sessionConfigs[sid][name]._transport.sid = sid;

			} else {
				_tracer && _tracer("Reuse transport for session logger");
			}
			tracer.sessions[sid].transport = sessionConfigs[sid][name]._transport;
		}
	}
	//
	var sid = inst.sid(_);
	var name = inst.name(_);
	if (sessionConfigs[sid]) {
		sessionConfigs[sid][name] = inst.serializeInstance(_);
	}
	if (sessionConfigs[sid][name].modules) {
		sessionConfigs[sid][name].modules.forEach_(_, function(_, mod) {
			loadSessionTracer(name, mod);
		});
	} else {
		loadSessionTracer(name);
	}
};