"use strict";

/// !doc
///
/// # Logging/tracing helper function  
///
/// Create a logger with default or existing configuration, making it simple for the applications to
/// specify the correct logger without having to know anything about
/// the options involved.

var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var genLogger = require('syracuse-trace/lib/genLogger').genLogger;

var tracers = {};
var syncDone = false;

// for internal traces
var _tracer; // = console.log;

// called by each modules that use traces
exports.getTracer = function(name) {
	_tracer && _tracer("Register tracer: " + name);
	tracers[name] = tracers[name] || new genLogger({
		name: name
	});
	return tracers[name];
};

exports.loadTracerConfig = function(_, conf, name, mod) {
	var tracer = tracers[name + (mod ? "." + mod : "")];
	if (tracer) {
		var serializedConf = conf.serializeInstance(_);
		mod = serializedConf.modules && serializedConf.modules.filter(function(m) {
			return m.name === mod;
		})[0];
		_tracer && _tracer("Load tracer configuration [" + serializedConf.name + (mod ? (":" + mod.name) : "") + "] : " + JSON.stringify(tracer, null, 2));
		tracer._loadConfig(serializedConf, mod);
	}
};

function reduceTracers() {
	return Object.keys(tracers).reduce(function(obj, name) {
		var tracerName, moduleName;
		if (name.indexOf('.') !== -1) {
			var parts = name.split('.');
			tracerName = parts[0];
			moduleName = parts[1];
		} else {
			tracerName = name;
		}
		obj[tracerName] = obj[tracerName] || [];
		if (moduleName) obj[tracerName].push(moduleName);
		return obj;
	}, {});
}

// syncConfigs(_) method :
// - create 
// - remove obsoletes configurations (configs or modules)
// - save systematically each configurations -> by afterSave event
// TODO : must update descriptions if localizations available
exports.syncConfigs = function(_) {
	_tracer && _tracer("Tracers: " + JSON.stringify(Object.keys(tracers), null, 2));
	var db = adminHelper.getCollaborationOrm(_);
	var entity = db.model.getEntity(_, "traceConfig");
	var modEntity = db.model.getEntity(_, "traceConfigModule");

	var processedConfigs = [];

	function _getConfig(_, name) {
		var db = adminHelper.getCollaborationOrm(_);
		var inst = db.fetchInstance(_, db.model.getEntity(_, "traceConfig"), {
			sdataWhere: "name eq '" + name + "'"
		});
		return inst ? inst : null;
	}

	function _updateModules(_, _conf, mods) {
		_conf.modules(_).toArray(_).forEach_(_, function(_, m) {
			if (Object.keys(tracers).indexOf(_conf.name(_) + "." + m.name(_)) === -1) {
				_conf.modules(_).deleteInstance(_, m.$uuid);
			}
		});
		if (mods.length !== 0) {
			mods.forEach_(_, function(_, mName) {
				if (!_conf.modules(_).toArray(_).some_(_, function(_, mod) {
					return mod.name(_) === mName;
				})) {
					var mod = modEntity.createInstance(_, db, null);
					mod.name(_, mName);
					_conf.modules(_).set(_, mod);
				}
			});
		}
	}


	var _tracers = reduceTracers();

	// Create or update configurations needed by tracers
	Object.keys(_tracers).forEach_(_, function(_, name) {
		_tracer && _tracer("\n*************");
		_tracer && _tracer("Create or update configurations needed by tracers : " + name);
		var config = _getConfig(_, name);

		// If no configuration exists, create a default one
		if (!config) {
			config = entity.createInstance(_, db, null);
			config.name(_, name);
			//config.description(_, description);
		} else {
			_updateModules(_, config, _tracers[name]);
		}

		config.save(_);
		processedConfigs.push(config.$uuid);
	});

	// Remove or update configurations not needed by tracers
	var configs = db.fetchInstances(_, entity);
	configs.filter_(_, function(_, c) {
		return processedConfigs.indexOf(c.$uuid) === -1;
	}).forEach_(_, function(_, c) {
		_tracer && _tracer("\n*************");
		_tracer && _tracer("Remove or update configurations not needed by tracers : " + c.name(_));
		var removed = false;
		if (!Object.keys(tracers).some_(_, function(_, name) {
			return name === c.name(_) || name.indexOf(c.name(_) + ".") !== -1;
		})) {
			removed = true;
			c.deleteSelf(_);
		}

		if (!removed && c.modularized(_)) {
			_updateModules(_, c);
		}
		if (!removed) c.save(_);
	});

	syncDone = true;
};