"use strict";

/// !doc
///
/// # Logging/tracing helper function  
///
/// Create a logger with default or existing configuration, making it simple for the applications to
/// specify the correct logger without having to know anything about
/// the options involved.

var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var genLogger = require('syracuse-trace/lib/genLogger').genLogger;

var tracers = exports.tracers = {};

exports.methods = ['debug', 'info', 'warn', 'error'];

// called by each modules that use traces
exports.getTracer = function(name) {
	if (!tracers[name]) {
		tracers[name] = new genLogger({
			name: name
		});
	}
	return tracers[name];
};



exports.initializeTracers = function(_) {
	var db = adminHelper.getCollaborationOrm(_);
	// Synchronize configurations
	syncConfigs(_, db);

	// TODO : Instanciate a traces records with default traceSettings
	// Maybe adding a special property in traceRecord entity to say that is an always activated one...


	var records = db.fetchInstances(_, db.model.getEntity(_, "traceRecord"));
	records.forEach_(_, function(_, record) {
		if (record.status(_) === "running" || record.status(_) === "paused") {
			console.log("Stop record: " + record.name(_));
			record.abortRecording(_);
		}
	});

};





// syncConfigs(_) method :
// - create 
// - remove obsoletes configurations (configs or modules)
// - save systematically each configurations -> by afterSave event
// TODO : must update descriptions if localizations available
var syncConfigs = function(_, db) {
	var entity = db.model.getEntity(_, "traceConfig");
	var modEntity = db.model.getEntity(_, "traceConfigModule");

	var processedConfigs = [];
	var settings = db.fetchInstances(_, db.model.getEntity(_, "traceSetting"))[0];

	var confs = settings && settings.configs(_);

	function _getConfig(_, name) {
		if (confs && confs.getLength() > 0) return confs.filter(_, {
			sdataWhere: "name eq '" + name + "'"
		})[0];
		return null;

	}

	function _updateModules(_, _conf, modName) {
		if (modName) {
			if (tracers[_conf.name(_)] && tracers[_conf.name(_)].modules && tracers[_conf.name(_)].modules.getLength() > 0) {
				_conf.modules(_).forEach_(_, function(_, m) {
					if (m.name(_) === modName) _conf.modules(_).deleteInstance(_, m.$uuid);
				});
			}

			if (!_conf.modules(_).toArray(_).some_(_, function(_, mod) {
				return mod.name(_) === modName;
			})) {
				var mod = modEntity.createInstance(_, db, null);
				mod.name(_, modName);
				_conf.modules(_).set(_, mod);
			}
		}
	}

	// Create or update configurations needed by tracers
	Object.keys(tracers).forEach_(_, function(_, name) {

		var tracerName, moduleName;
		if (name.indexOf('.') !== -1) {
			var parts = name.split('.');
			tracerName = parts[0];
			moduleName = parts[1];
		} else {
			tracerName = name;
		}

		var config = _getConfig(_, tracerName);

		// If no configuration exists, create a default one
		if (!config) {
			config = entity.createInstance(_, db, null);
			config.name(_, tracerName);
			//config.description(_, description);
			settings.configs(_).set(_, config);
		}
		_updateModules(_, config, moduleName);
		processedConfigs.push(config.$uuid);
	});

	// Remove or update configurations not needed by tracers
	confs.refresh(_);
	confs.toArray(_).filter_(_, function(_, c) {
		return processedConfigs.indexOf(c.$uuid) === -1;
	}).forEach_(_, function(_, c) {
		var removed = false;
		if (!Object.keys(tracers).some_(_, function(_, name) {
			return name === c.name(_) || name.indexOf(c.name(_) + ".") !== -1;
		})) {
			removed = true;
			confs.deleteInstance(_, c.$uuid);
			//c.deleteSelf(_);
		}
		if (!removed && c.modularized(_)) {
			if (c.modules(_).getLength() > 0) {
				c.modules(_).forEach_(_, function(_, m) {
					_updateModules(_, c, m.name(_));
				});
			}
		}
		//if (!removed) c.save(_);
	});
	settings.save(_);
};