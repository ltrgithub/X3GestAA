"use strict";

/// !doc
///
/// # Logging/tracing helper function  
///
/// Create a logger with default or existing configuration, making it simple for the applications to
/// specify the correct logger without having to know anything about
/// the options involved.

var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var genLogger = require('syracuse-trace/lib/genLogger').genLogger;
var defLogger = require('syracuse-trace/lib/defLogger').defLogger;
var saLogger = require('syracuse-trace/lib/saLogger').saLogger;
var mongoLogger = require('syracuse-trace/lib/mongoLogger').mongoLogger;

var tracers = {};
var syncDone = false;

// for internal traces
var _tracer; // = console.log;

// called by each modules that use traces
var getTracer = exports.getTracer = function(name) {
	var tracerName, moduleName;
	if (name.indexOf('.') !== -1) {
		var parts = name.split('.');
		tracerName = parts[0];
		moduleName = parts[1];
	} else {
		tracerName = name;
	}

	if (moduleName) {
		tracers[tracerName] = tracers[tracerName] || {};
		tracers[tracerName].modules = tracers[tracerName].modules || {};
		if (!tracers[tracerName].modules[moduleName]) {
			tracers[tracerName].modules[moduleName] = new genLogger({
				name: tracerName
			});
		}
		return tracers[tracerName].modules[moduleName];
	} else {
		tracers[tracerName] = tracers[tracerName] || new genLogger({
			name: tracerName
		});
		return tracers[tracerName];
	}
};

exports.loadTracerConfig = function(_, conf, name, mod) {
	var tracer = getTracer(name + (mod ? "." + mod : ""));
	if (tracer) {
		var serializedConf = conf.serializeInstance(_);
		mod = serializedConf.modules && serializedConf.modules.filter(function(m) {
			return m.name === mod;
		})[0];
		_tracer && _tracer("Load tracer configuration [" + serializedConf.name + (mod ? (":" + mod.name) : "") + "] : " + JSON.stringify(tracer, null, 2));
		tracer._loadConfig(serializedConf, mod);
		setTracerTransport(tracer);
	}
};


function setTracerTransport(tracer) {
	function setTransport() {
		switch (tracer && tracer.type) {
			case "storagearea":
				transport = new saLogger(tracer.name);
				break;
			case "mongo":
				transport = new mongoLogger(tracer.name);
				break;
			default: // console
				transport = new defLogger();
				break;
		}
		tracers[tracer.name].transport = transport;
		return tracers[tracer.name].transport;
	}
	//
	var transport = tracers[tracer.name] && tracers[tracer.name].transport;
	if (transport) {
		if (tracer.type !== transport.type) {
			transport.close();
			setTransport().initialise();
		}
	} else {
		setTransport().initialise();
	}
	tracer.transport = tracers[tracer.name].transport;
}

// syncConfigs(_) method :
// - create 
// - remove obsoletes configurations (configs or modules)
// - save systematically each configurations -> by afterSave event
// TODO : must update descriptions if localizations available
exports.syncConfigs = function(_) {
	_tracer && _tracer("Tracers: " + JSON.stringify(tracers, null, 2));
	var db = adminHelper.getCollaborationOrm(_);
	var entity = db.model.getEntity(_, "traceConfig");
	var modEntity = db.model.getEntity(_, "traceConfigModule");

	var processedConfigs = [];

	function _getConfig(_, name) {
		var db = adminHelper.getCollaborationOrm(_);
		var inst = db.fetchInstance(_, db.model.getEntity(_, "traceConfig"), {
			sdataWhere: "name eq '" + name + "'"
		});
		return inst ? inst : null;
	}

	function _updateModules(_, _conf, mods) {
		_conf.modules(_).toArray(_).forEach_(_, function(_, m) {
			if (tracers[_conf.name(_)] && tracers[_conf.name(_)].modules && Object.keys(tracers[_conf.name(_)].modules).indexOf(m.name(_)) === -1) {
				_conf.modules(_).deleteInstance(_, m.$uuid);
			}
		});

		if (mods && Object.keys(mods).length !== 0) {
			//console.log("Modules: "+JSON.stringify(mods,null,2));
			Object.keys(mods).forEach_(_, function(_, mName) {
				if (!_conf.modules(_).toArray(_).some_(_, function(_, mod) {
					return mod.name(_) === mName;
				})) {
					var mod = modEntity.createInstance(_, db, null);
					mod.name(_, mName);
					_conf.modules(_).set(_, mod);
				}
			});
		}
	}


	//var _tracers = reduceTracers();

	// Create or update configurations needed by tracers
	Object.keys(tracers).forEach_(_, function(_, name) {
		_tracer && _tracer("\n*************");
		_tracer && _tracer("Create or update configurations needed by tracers : " + name);
		var config = _getConfig(_, name);

		// If no configuration exists, create a default one
		if (!config) {
			config = entity.createInstance(_, db, null);
			config.name(_, name);
			//config.description(_, description);
		}
		_updateModules(_, config, tracers[name].modules);

		config.save(_);
		processedConfigs.push(config.$uuid);
	});

	// Remove or update configurations not needed by tracers
	var configs = db.fetchInstances(_, entity);
	configs.filter_(_, function(_, c) {
		return processedConfigs.indexOf(c.$uuid) === -1;
	}).forEach_(_, function(_, c) {
		_tracer && _tracer("\n*************");
		_tracer && _tracer("Remove or update configurations not needed by tracers : " + c.name(_));
		var removed = false;
		if (!Object.keys(tracers).some_(_, function(_, name) {
			return name === c.name(_) || name.indexOf(c.name(_) + ".") !== -1;
		})) {
			removed = true;
			c.deleteSelf(_);
		}

		if (!removed && c.modularized(_)) {
			_updateModules(_, c);
		}
		if (!removed) c.save(_);
	});

	syncDone = true;
};