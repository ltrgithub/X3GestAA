"use strict";
var ez = require('ez-streams');
var zlib = require('zlib');
var hostname = require('os').hostname();
var globals = require('streamline-runtime').globals;
var locale = require('streamline-locale');
// take configuration directly from nodelocal.js (and not from 'config') because configuration must be available
// from the beginning
var config;
try {
	config = require("../../../nodelocal").config || {};
	config.streamline.fast = false;
} catch (ex) {
	console.log(ex);
	config = {};
}


/// !doc
///
/// # Logging/tracing helper function  
///
/// Create a logger with default or existing configuration, making it simple for the applications to
/// specify the correct logger without having to know anything about the options involved.
/// 
/// Auto traces records are launched automatically by default. To 

//methods should already be available from the beginning (because of circular reference)!
var tracers = exports.tracers = {};


var genLogger = require('syracuse-trace/lib/genLogger');
var GenLogger = genLogger.GenLogger;
var adminHelper;
exports.methods = genLogger.methods;



function _findLevel(config, name) {
	// find out log level
	var traces = config.traces;
	var level = "error";
	if (traces) {
		if (traces.defLevel) level = traces.defLevel;
		traces = traces.levels;
		if (traces) {
			var index = name.indexOf('.');
			if (index >= 0) {
				traces = traces[name.substr(0, index)];
				if (traces) traces = traces[name.substr(index + 1)];
			} else {
				traces = traces[name];
			}
		}
		if (traces) level = traces;
	}
	if (exports.methods.indexOf(level) < 0) throw new Error("Wrong log level " + level + " for " + name);
	return level;
}

// for unit tests
exports._findLevel = _findLevel;

// messages which are traced before the system is initialised, will be recorded in the startCache and traced again when the
// autorecorder has been created. This does not make sense when no autorecorder is started
var startCache;
if (!config.system || !config.system.enableDevelopmentFeatures || !config.traces || !config.traces.console) startCache = [];

var consoleQueue0 = {
	put: function(n) {
		console.error(n.stamp + " | " + n.severity + " | " + n.category + " | " + n.message + (n.stack ? " | " + n.stack : ""));
		if (startCache) startCache.push(n);
		return true;
	}
};

/// Usage : Developers need to declare a tracer like following in module header:  
/// 
/// To use a simple group of traces :  
/// 
/// ``` javascript
/// var tracer = traceHelper.getTracer('group');  
/// ```
/// 
/// Or to categorize with a submodule :  
/// 
/// ``` javascript
/// var tracer = traceHelper.getTracer('group.module');  
/// ```
/// 
/// Then the tracer can be used like following :  
/// 
/// ``` javascript
/// tracer.info && tracer.info("My 'info' message");  
/// tracer.debug && tracer.debug("My 'debug' message");  
/// tracer.warn && tracer.warn("My 'warning' message");  
/// tracer.error && tracer.error("My 'error' message", new Error("By this way I will embed the stack in the trace"));  
/// ```
/// 
//called by each modules that use traces
exports.getTracer = function(name) {
	if (!tracers[name]) {
		tracers[name] = new GenLogger({
			name: name
		});
		// add console logger when tracing system has not yet been initialized
		if (!adminHelper) {
			tracers[name].addRecord('console', _findLevel(config, name), consoleQueue0, undefined, (config.hosting && config.hosting.multiTenant ? (globals.context.tenantId || "$$solo") : ""));
		}
	}
	return tracers[name];
};
// override syracuse-core hook
require('syracuse-core').getTracer = exports.getTracer;


// unset console queue from all loggers
exports.unsetConsole = function() {
	for (var key in tracers) {
		tracers[key].deleteRecord('console');
	}
};

function _getCollaboration(_) {
	if (!adminHelper) adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
	return adminHelper.getCollaborationOrm(_);
}

//TODO : Call this function from Syracuse server stop entry point...
// stop all logging
exports.haltRecording = function(_) {
	if (config.hosting && config.hosting.multiTenant) {
		// stop recording for all tenants
		var activeTenants = require('syracuse-main/lib/syracuse').activeTenants();
		activeTenants.forEach_(_, _haltRecordingInt);
	} else {
		// stop recording
		_haltRecordingInt(_);
	}
};

// halt recording for a single tenant
function _haltRecordingInt(_, tenantId) {
	if (tenantId === "$$solo") tenantId = undefined;
	console.log("halt recording " + tenantId);
	globals.context.tenantId = tenantId;
	var db = _getCollaboration(_);
	var records = db.fetchInstances(_, db.model.getEntity(_, "traceRecord"), {
		jsonWhere: {
			pid: process.pid,
			hostname: hostname
		}
	});
	records.forEach_(_, function(_, record) {
		var status = record.status(_);
		if (status !== "complete" && status !== "error") {
			record.haltRecording(_);
		}
	});
}

// mark running records of finished records as error records. 
// parameter start: start manual records
var manageRunningRecords = function(_, start) {
	var db = _getCollaboration(_);
	var names = {};

	var cursor = db.createCursor(_, db.model.getEntity(_, "traceRecord"));
	var record;
	var pids = {}; // process must be stopped when the value for this entry is 'true'
	pids[process.pid] = false; // do not stop values of current process
	while ((record = cursor.next(_))) {
		var status = record.status(_);
		if (status === "running" || status === "paused") {
			var mustStop = false;
			try {
				var pid = record.pid(_);
				mustStop = pids[pid];
				if (mustStop === undefined) {
					// must still decide
					try {
						process.kill(pid, 0);
						pids[pid] = false;
					} catch (e) {
						// process does not exist any more
						mustStop = pids[pid] = true;
					}
				}
			} catch (e) {
				mustStop = true;
			}
			if (mustStop) {
				record._db.unlockInstance(_, record); // maybe a lock has remained because of server crash...
				record.errorStopped(_, new Error("Log '" + record.name(_) + "' can't be read because of process crash"));
				status = "error";
				continue;
			}
		}
		// maybe start manual process
		var name = record.sequence(_) || record.name(_);
		if (start && status !== "error") {
			if ((!(name in names) || status === "complete" || (status !== "created" && names[name] && names[name].status(_) === "created")) && !record.auto(_) && !record.onlySid(_)) {
				names[name] = (status === "complete" ? null : record);
			}
		}
	}
	// only start manual processes which have not already been stopped under the same sequence number or name
	for (var name in names) {
		var record = names[name];
		if (record) {
			var instance = record.duplicateManual(_);
			// no locking necessary because new instance
			switch (record.status(_)) {
				case 'running':
				case 'halted':
					instance.startRecording(_);
					break;
				case 'haltedpaused':
				case 'paused':
					instance.startRecording(_, true);
					break;
				case 'created':
					instance._noLock = true;
					instance._noPropagate = true;
					instance.save(_);
					break;
				default:
					throw new Error("Wrong status " + record.status(_));
			}
		}
	}
};

exports.removeOldAutoRecords = function(_, db, maxDays) {
	db = db || _getCollaboration(_);
	var records = db.createCursor(_, db.model.getEntity(_, "traceRecord"), {
		jsonWhere: {
			auto: true
		},
		orderBy: [{
			binding: "name",
			descending: true
		}]
	});
	maxDays = maxDays || exports.getSettings(_).maxDays;
	var currName;
	var count = 0,
		deleted = 0;
	var record;
	while ((record = records.next(_))) {

		if (count > maxDays) {
			db.deleteInstance(_, record);
			deleted++;
			continue;
		}
		var name = record.name(_);
		if (name !== currName) {
			currName = name;
			count++;
		}
		if (count > maxDays) {
			db.deleteInstance(_, record);
			deleted++;
		}
	}
	return deleted;
};

function _launchAutoTraceRecord(_) {
	var devMode = config && config.system && config.system.enableDevelopmentFeatures;
	var consoleMode = config.traces && config.traces.console;
	var db = _getCollaboration(_);
	var recEntity = db.model.getEntity(_, "traceRecord");
	if (!devMode || !consoleMode) {
		// no locking because new record
		var autoRecord = recEntity.createInstance(_, db, null);

		var _date = autoRecord.stamp(_).toString().substring(0, 10);
		var _name = "Auto_Record_" + _date;

		autoRecord.name(_, _name);
		autoRecord.auto(_, true);
		autoRecord.onlySid(_, false);
		autoRecord._noPropagate = true;
		autoRecord._noLock = true;
		autoRecord.startRecording(_, false, true, true); // do not save, unset console
		autoRecord.save(_);
		// replay all already logged messages
		if (startCache) {
			var tmp = startCache;
			startCache = undefined;
			if (tmp.length > 0) {
				console.log("Replay already logged messages (count " + tmp.length + ")");
				tmp.forEach(function(n) {
					var tr = tracers[n.category];
					if (tr[n.severity]) {
						tr[n.severity](null, n); // pass data object n directly to tracer, no invocation of _createLine in genLogger
					}
				});
			}
		}
		return;
	}
}

exports.getTempMessages = function() {
	return require('./entities/traceRecord').getTempMessages();
};

exports.initializeTracers = function(_) {
	try {
		var db = _getCollaboration(_);
		// Synchronize configurations
		syncConfigs(_, db);
		// Remove old auto records following 'maxDays' configuration
		exports.removeOldAutoRecords(_, db);
		// Launch auto trace record
		_launchAutoTraceRecord(_);
		// Stop runnig records if processes associated do not exist anymore, start new manual records
		manageRunningRecords(_, true);
	} catch (e) {
		console.error("Error when initializing tracers: " + e.safeStack);
	}
};

// close session specific trace records
exports.removeSessionTracers = function(_, sid) {
	require('./entities/traceRecord').removeSessionTracers(_, sid);
};



// TODO lock the instance, but retry it when it does not work out for the first time. This should be replaced when lockInstanceRetry of MongoDbHandle has moved
// from a feature branch to this branch.
exports.lockInstanceRetry = function(_, instance) {
	var start = new Date();
	var orm = instance._db;
	var lock = orm.lockInstance(_, instance);
	while ((lock.status !== "success") && (((new Date()) - start) < 60000)) {
		// wait some time, 50ms min
		setTimeout(_, Math.floor(Math.random() * 10000) + 50);
		//
		lock = orm.lockInstance(_, instance);
	}
	if (lock.status !== "success") throw new Error(locale.format(module, "instanceLockTimeout"));
	return lock;
};


exports.resetConfigs = function(_, instance) {
	var db = _getCollaboration(_);
	instance.configs(_).reset(_);
	instance.save(_);
	return syncConfigs(_, db);
};

exports.computeSize = function(size) {
	var matches = /^(\d+)([mMkKgG]?)$/.exec("" + size);
	if (matches) {
		var n = +matches[1];
		var l = matches[2];
		switch (l) {
			case "K":
			case "k":
				return n * 1000;
			case "M":
			case "m":
				return n * 1000000;
			case "G":
			case "g":
				return n * 1000000000;
			case "":
				return n;
			default:
				break;
		}
	}
	return 102400000; // 100 Mo by default
};

exports.getSettings = function(_) {
	var db = adminHelper.getCollaborationOrm(_);
	var setEntity = db.model.getEntity(_, "setting");
	var settings = db.fetchInstances(_, setEntity)[0];
	return {
		maxSize: settings.traceMaxSize(_),
		maxFiles: settings.traceMaxFiles(_),
		maxDays: settings.traceMaxDays(_)
	};
};

// syncConfigs create or update default trace settings configurations
var syncConfigs = function(_, db) {
	var globalSettings = db.fetchInstances(_, db.model.getEntity(_, "setting"))[0];
	if (globalSettings && (!globalSettings.traceMaxSize(_) || !globalSettings.traceMaxFiles(_) || !globalSettings.traceMaxDays(_))) {
		// Initialize default values
		globalSettings.traceMaxFiles(_, 5);
		globalSettings.traceMaxSize(_, "10m");
		globalSettings.traceMaxDays(_, 5);
		globalSettings.save(_);
	}

	var entity = db.model.getEntity(_, "traceConfig");
	var modEntity = db.model.getEntity(_, "traceConfigModule");
	var setEntity = db.model.getEntity(_, "traceSetting");
	var processedConfigs = [];
	var settings = db.fetchInstances(_, setEntity)[0];
	if (!settings) {
		settings = setEntity.createInstance(_, db, null);
		settings.code(_, "settings");
		settings.description(_, "Traces settings");
	}

	var confs = settings && settings.configs(_);

	function _getConfig(_, name) {
		if (confs && confs.getLength() > 0) return confs.filter(_, {
			sdataWhere: "name eq '" + name + "'"
		})[0];
		return null;
	}

	function _updateModules(_, _conf, modName) {
		if (modName) {
			// Delete modules that exist but must not
			if (tracers[_conf.name(_)] && tracers[_conf.name(_)].modules && tracers[_conf.name(_)].modules.getLength() > 0) {
				_conf.modules(_).forEach_(_, function(_, m) {
					if (m.name(_) === modName) _conf.modules(_).deleteInstance(_, m.$uuid);
				});
			}

			var mod;
			// Create modules that do not exist
			if (!_conf.modules(_).toArray(_).some_(_, function(_, mod) {
				return mod.name(_) === modName;
			})) {
				mod = modEntity.createInstance(_, db, null);
				mod.name(_, modName);
				var defLevel = config && config.traces && config.traces.levels && config.traces.levels[_conf.name(_)] && config.traces.levels[_conf.name(_)][modName];
				if (defLevel) mod.level(_, defLevel);
				_conf.modules(_).set(_, mod);
			}

			mod = mod || _conf.modules(_).filter(_, {
				sdataWhere: "name eq '" + modName + "'"
			})[0];

			var description;
			try {
				description = locale.formatAllIso(module, _conf.name(_) + "." + modName);
			} catch (e) {
				if (config.system && config.system.enableDevelopmentFeatures) {
					console.error("Maybe a description is needed for tracer's module [" + _conf.name(_) + "." + modName + "] in 'syracuse-trace/lib/resources/helper-en.json");
				}
			}
			if (description !== mod.description(_)) {
				mod.description(_, description);
				_conf.modules(_).set(_, mod);
			}
		}
	}

	// Create or update configurations needed by tracers
	Object.keys(tracers).forEach_(_, function(_, name) {

		var tracerName, moduleName;
		if (name.indexOf('.') !== -1) {
			var parts = name.split('.');
			tracerName = parts[0];
			moduleName = parts[1];
		} else {
			tracerName = name;
		}

		var conf = _getConfig(_, tracerName);
		// If no configuration exists, create a default one
		if (!conf) {
			conf = entity.createInstance(_, db, null);
			conf.name(_, tracerName);
			var defLevel = config && config.traces && config.traces.levels && config.traces.levels[conf.name(_)];
			if (defLevel && typeof defLevel === "string") conf.level(_, defLevel);
			settings.configs(_).set(_, conf);
		}
		var description;
		try {
			description = locale.formatAllIso(module, tracerName);
		} catch (e) {
			if (config.system && config.system.enableDevelopmentFeatures) {
				console.error("Maybe a description is needed for tracer [" + tracerName + "] in 'syracuse-trace/lib/resources/helper-en.json");
			}
		}
		if (description !== conf.description(_)) {
			conf.description(_, description);
		}

		_updateModules(_, conf, moduleName);
		processedConfigs.push(conf.$uuid);
	});

	// Remove or update configurations not needed by tracers
	confs.refresh(_);
	confs.toArray(_).filter_(_, function(_, c) {
		return processedConfigs.indexOf(c.$uuid) === -1;
	}).forEach_(_, function(_, c) {
		var removed = false;
		if (!Object.keys(tracers).some_(_, function(_, name) {
			return name === c.name(_) || name.indexOf(c.name(_) + ".") !== -1;
		})) {
			removed = true;
			confs.deleteInstance(_, c.$uuid);
			//c.deleteSelf(_);
		}
		if (!removed && c.modularized(_)) {
			if (c.modules(_).getLength() > 0) {
				c.modules(_).forEach_(_, function(_, m) {
					_updateModules(_, c, m.name(_));
				});
			}
		}
		//if (!removed) c.save(_);
	});
	settings.save(_);
	return settings;
};


// takes the writableStream of MongoDb and returns an ez-stream queue
exports.makeQueue = function(_, writer, ticket) {
	writer = ez.helpers.binary.writer(writer, {
		bufSize: 64000,
	});
	//

	var q = ez.devices.queue({
		max: config.system.traceQueueMax || 100000,
	});

	// Put entity name
	q.put({
		entity: "trace"
	});
	// Put ticket number
	q.put({
		ticket: ticket || ""
	});

	// Apply stream transformations
	q.reader = q.reader.transform(ez.transforms.json.formatter());
	q.reader = q.reader.map(ez.mappers.convert.bufferify());
	q.reader = q.reader.nodeTransform(zlib.createGzip());


	// q.reader.pipe(!_, writer);
	q.reader.pipe(function(err) {
		if (err) console.error("Error when closing queue: " + err.stack);
	}, writer);
	return q;
};