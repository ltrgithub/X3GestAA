"use strict";

var helpers = require('syracuse-core/lib/helpers');
var os = require('os');
var traceHelper = require('syracuse-trace/lib/helper');
var globals = require("streamline/lib/globals");

// Generic logging class
exports.genLogger = helpers.defineClass(function(config) {
	var self = this;
	this.name = config.name;
	this.defaultLevel = 'warn';
	this.records = {};
	// define property for each method
	traceHelper.methods.forEach(function(m) {
		self._defineProperty(m);
	});
}, null, {
	_createLine: function(severity, msg, obj) {
		// !! IMPORTANT : this object must properties that exist in trace entity 
		var data = {
			_id: helpers.uuid.generate(), // necessary to have 'uuid' instead of 'ObjectId(...)' in mongodb
			tag: this.tag,
			category: this.name, // Need to check if this will have the module part
			severity: severity,
			message: msg,
			args: {},
			file: "", // Can only get this from the module in the calling function
			stamp: new Date().toISOString(),
			stack: null, // only for error severity
			session: globals.context.session && globals.context.session.id,
			pid: null, // For Nannies
			hostname: os.hostname()
		};

		if (severity === "error" && typeof obj === "Error") {
			// Future development
			// Look at how the SHA1 can be incorporated here
			data.stack = obj.stack;
		} else {
			data.args = obj;
		}

		return data;
	},
	_isTraceEnabled: function(severity, conf) {
		console.log("Severity: " + severity);
		console.log('config: ' + JSON.stringify(conf));


		var myLevel = traceHelper.methods.indexOf(severity);
		var res = conf && conf.enabled && conf.level != null && myLevel >= conf.level;
		console.log('Result: ' + res);
		return res;
	},
	_defineProperty: function(severity) {
		var self = this;
		Object.defineProperty(this, severity, {
			get: function() {
				if (Object.keys(self.records).length > 0) return self['_' + severity];
				return null;
			},
			configurable: true
		});
	},
	_trace: function(severity, data) {
		var self = this;
		if (data) {
			var fails = false;
			Object.keys(self.records).forEach(function(recId) {
				var rec = self.records[recId];
				if (rec.config && rec.config && self._isTraceEnabled(severity, rec.config)) {
					fails = !(rec.queue && rec.queue.put(data));
				}
			});
			// prevent losing traces... if queue is full, redirect to stdout
			if (fails) console.log(JSON.stringify(data));
		}
	},
	_traceAll: function(severity, msg, obj) {
		var data = this._createLine(severity, msg, obj);
		var self = this;
		self._trace(severity, data);

	},
	_debug: function(msg, obj) {
		this._traceAll('debug', msg, obj);
	},
	_info: function(msg, obj) {
		this._traceAll('info', msg, obj);
	},
	_warn: function(msg, obj) {
		this._traceAll('warn', msg, obj);
	},
	_error: function(msg, obj) {
		this._traceAll('error', msg, obj);
	},
	fatal: function(msg, obj) {
		// TODO: System.exit()
		// Log synchronously in separate file
	},
	toJSON: function() {
		return {
			name: this.name,
			module: this.module,
			title: this.description,
			enabled: this.enabled,
			level: traceHelper.methods[this.level]
		};
	}
});