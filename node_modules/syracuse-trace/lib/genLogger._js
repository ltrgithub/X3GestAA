"use strict";

var globals = require('streamline/lib/globals');
var x3helper = require('syracuse-x3/lib/helpers');
var helpers = require('syracuse-core/lib/helpers');
var tinytim = require('tinytim');
var dateFormat = require('dateformat');
var utils = require('./utils');
var path = require('path');
var defLogger = require('syracuse-trace/lib/defLogger').defLogger;
var saLogger = require('syracuse-trace/lib/saLogger').saLogger;

// Generic logging class
exports.genLogger = helpers.defineClass(function(logType, config) {
	this._config = {
		format: "{{timestamp}} <{{title}}> {{file}}:{{line}} ({{method}}) {{message}}",
		inspectOpt: {
			showHidden: false, //if true then the object's non-enumerable properties will be shown too. Defaults to false
			depth: 2 //tells inspect how many times to recurse while formatting the object. This is useful for inspecting large complicated objects. Defaults to 2. To make it recurse indefinitely pass null.
		}
	};
	this.methods = ['debug', 'info', 'warn', 'error'];
	this.defaultLevel = 'warn';
	this.dateformat = (config && config.dateformat) || "UTC:yyyy-mm-dd'T'HH:MM:ss.l'Z'";
	this.stackIndex = (config && config.stackIndex) || 1; // get the specified index of stack as file information. It is userful for development package.

	this.logType = logType;
	var baseConfig = x3helper.config("traceConfig", globals.context.config);
	var traceConfig = x3helper.config(this.logType, baseConfig);
	this.level = this.methods.indexOf(traceConfig.level || this.defaultLevel);
	this.enabled = traceConfig.enabled;
	this.transport = null;
	switch (traceConfig.transport) {
		case "storagearea":
			this.transport = new saLogger(logType);
			break;
		case "mongo":
			// this.transport = new mdLogger(logType);
			// break;
		default: // console
			this.transport = new defLogger(logType);
			break;
	}
}, null, {
	logMain: function(_, type, format, needstack, args) {
		var data = {
			timestamp: dateFormat(new Date(), this.dateformat),
			message: "",
			title: type,
			level: type,
			args: args
		};
		data.method = data.path = data.line = data.pos = data.file = '';

		if (needstack) {
			// get call stack, and analyze it
			// get all file,method and line number
			var stacklist = (new Error()).stack.split('\n').slice(3);
			// Stack trace format :
			// http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
			// DON'T Remove the regex expresses to outside of method, there is a BUG in node.js!!!
			var stackReg = /at\s+(.*)\s+\((.*):(\d*):(\d*)\)/gi;
			var stackReg2 = /at\s+()(.*):(\d*):(\d*)/gi;

			var s = stacklist[this.stackIndex] || stacklist[0],
				sp = stackReg.exec(s) || stackReg2.exec(s);
			if (sp && sp.length === 5) {
				data.method = sp[1];
				data.path = sp[2];
				data.line = sp[3];
				data.pos = sp[4];
				data.file = path.basename(data.path);
				data.stack = stacklist.join('\n');
			}
		}

		this.transport.preprocess(_, data);
		var msg = utils.format.apply(this._config, data.args);
		data.message = msg;

		// call micro-template to ouput
		data.output = tinytim.tim(format, data);

		// transport the final result
		return this.transport.trace(_, data);
	},
	initialise: function(_) {
		this.transport.initialise(_);
	},
	trace: function(_, type, len) {
		if (len === 1) {
			var myLevel = this.methods.indexOf(type);
			return this.enabled && myLevel <= this.level;
		}
		var format = this._config.format;
		var needstack = /\{\{(method|path|line|pos|file)\}\}/i.test(format);

		return this.logMain(_, type, format, needstack, arguments);
	},
	debug: function(_) {
		return this.trace(_, 'debug', arguments.length, arguments);
	},
	info: function(_) {
		return this.trace(_, 'info', arguments.length, arguments);
	},
	warn: function(_) {
		return this.trace(_, 'warn', arguments.length, arguments);
	},
	error: function(_) {
		return this.trace(_, 'error', arguments.length, arguments);
	},
	close: function(_) {
		this.transport.close(_);
	}
});