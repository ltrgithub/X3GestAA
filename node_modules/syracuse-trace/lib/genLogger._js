"use strict";

var helpers = require('syracuse-core/lib/helpers');
var os = require('os');
var globals = require("streamline/lib/globals");
var methods = exports.methods = ['debug', 'info', 'warn', 'error', 'fatal'];

// Generic logging class
exports.GenLogger = helpers.defineClass(function(config) {
	var self = this;
	this.name = config.name; // name of that logger
	this._minLogLevel = methods.length; // minimum session independent log level
	this._records0 = []; // array with log records for each level. Contains array of objects with queue and log record uuid and session id
	this._logFunctions = []; // generated log functions for the log levels (cache, so that generation is necessary only once)
	this._sessions = []; // array with sessions for each level, when there are session dependent loggers. Extra property for performance reasons
	// a session will be contained also in higher levels, e. g. when a "info" record is registered, its session will also be
	// in "warning", "error", "fatal". This means that (!!this._session[i] === true) means that there are session dependent loggers
	// with numerical log level less or equal i. Therefore there is no counterpart of this._minLogLevel.
}, null, {
	_createLine: function(severity, msg, obj) {
		var data = {
			_id: helpers.uuid.generate(), // necessary to have 'uuid' instead of 'ObjectId(...)' in mongodb
			category: this.name, // Need to check if this will have the module part
			severity: severity,
			message: msg,
			args: {},
			stamp: new Date().toISOString(),
			stack: "", // only for error severity
			session: globals.context.session && globals.context.session.id,
			pid: process.pid, // For Nannies
			hostname: os.hostname()
		};

		if (severity === "error" && obj instanceof Error) {
			// Future development
			// Look at how the SHA1 can be incorporated here
			data.stack = obj.stack;
		} else {
			data.args = obj;
		}

		return data;
	},
	// THIS FUNCTION ALLOWS TO KNOW IF SOME SEVERITIES ARE ACTIVATED WITHOUT CALLING FUNCTION WITH ()
	_defineProperty: function(level, sessions, fun) {
		var self = this;
		Object.defineProperty(this, level, {
			get: function() {
				try {
					if (globals.context.session.id in sessions) return fun;
				} catch (e) {}; // ignore errors, e. g. when there is no session
				return null;
			},
			configurable: true
		});
	},
	// delete record with this uuid and maybe remove certain log levels
	deleteRecord: function(uuid) {
		var self = this;
		for (var ilevel = 0; ilevel < methods.length; ilevel++) {
			var recs = self._records0[ilevel];
			if (recs) {
				for (var j = recs.length - 1; j >= 0; j--) {
					if (recs[j].uuid === uuid) { // found
						var sid = recs[j].sid;
						recs.splice(j, 1); // remove this logger
						if (sid) { // remove session dependent logger
							for (var ilevel2 = ilevel; ilevel2 < methods.length; ilevel2++) {
								var sessions = self._sessions[ilevel2];
								if (sessions[sid] > 1) sessions[sid]--;
								else {
									if (Object.keys(sessions).length === 1) {
										// remove last entry: remove sessions for that level
										this._sessions[ilevel2] = undefined;
										var method2 = methods[ilevel2];
										// mark this log level as session independent
										delete self[method2]; // delete getter
										if (ilevel2 >= self._minLogLevel) { // replace session depending logging with session independent logging
											self[method2] = this._generateLog(ilevel2, method2);
										}
									} else delete sessions[sid];
								}
							}
						} else {
							if (ilevel === self._minLogLevel) {
								// is there no unconditional logging any more?
								for (var ilevel2 = ilevel; ilevel2 < methods.length && (!recs || !recs.some(function(item) {
									return !item.sid;
								})); ilevel2++) {
									var method2 = methods[ilevel2];
									delete self[method2]; // remove unconditional logging
									var sessions = this._sessions[ilevel2];
									if (sessions) { // maybe introduce sessions dependent logging
										this._defineProperty(method2, sessions, this._generateLog(ilevel2, method2));
									}
									self._minLogLevel++;
									recs = self._records0[ilevel2 + 1];
								}
							}
						}
						return;
					}
				}
			}
		}
	},
	// add this log record and maybe add new logging levels
	addRecord: function(uuid, level, queue, sid) {
		var ilevel = methods.indexOf(level);
		if (ilevel < 0) throw new Error("Wrong log level " + level);
		if (!queue) throw new Error("No queue in record " + uuid);
		var recs = (this._records0[ilevel] = this._records0[ilevel] || []);
		recs.push({
			uuid: uuid,
			queue: queue,
			sid: sid
		});
		if (sid) {
			for (var i = ilevel; i < methods.length; i++) {
				var sessions = (this._sessions[i] = this._sessions[i] || {});
				if (sid in sessions) sessions[sid]++;
				else sessions[sid] = 1;
				if (i < this._minLogLevel) { // only add session dependent properties for log levels less than _minLogLevel, because others will be logged anyway!
					this._defineProperty(methods[i], sessions, this._generateLog(i, methods[i]));
				}
			}
		} else {
			if (ilevel < this._minLogLevel) { // add more log methods
				for (var i = ilevel; i < this._minLogLevel; i++) {
					if (this._sessions[i]) delete this[methods[i]]; // remove 'setter' property of session depending logging
					this[methods[i]] = this._generateLog(i, methods[i]);
				}
				this._minLogLevel = ilevel;
			}
		}
	},
	// return or generate a logging function for given log level
	_generateLog: function(ilevel, level) {
		var fun = this._logFunctions[ilevel];
		if (fun) return fun;
		fun = function(msg, obj) { // level, ilevel will be stored in the closure
			var self = this;
			var data;
			var fails = false;
			for (var i = 0; i <= ilevel; i++) {
				var recs = self._records0[i];
				if (recs) {
					recs.forEach(function(rec) {
						data = data || self._createLine(level, msg, obj);
						fails = !rec.queue.put(data);
						if (rec.day && rec.inst && data.stamp) {
							if ((new Date(data.stamp)).getUTCDate() !== rec.day) {
								// If day changed, stop/start auto record
								rec.queue.put(self._createLine("info", "Day log rotation: new auto record has been created"));
								rec.inst.stopRecording(function(err) {
									if (err) throw err;
								});
							}
						}
					});
					if (fails) console.log(JSON.stringify(data));
				}
			}
		};
		this._logFunctions[ilevel] = fun;
		return fun;
	},
});