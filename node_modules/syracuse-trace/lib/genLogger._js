"use strict";

var helpers = require('syracuse-core/lib/helpers');
var tinytim = require('tinytim');
var dateFormat = require('dateformat');
var utils = require('./utils');
var path = require('path');
var flows = require('streamline/lib/util/flows');
var traceHelper = require('syracuse-trace/lib/helper');
var globals = require("streamline/lib/globals");

//Standard callback replace _ callback to be able to use this transport in not streamlined functions


var writeFunnel = flows.funnel(1);

// Generic logging class
exports.genLogger = helpers.defineClass(function(config) {
	var self = this;
	this.sid = config.sid;
	this._config = {
		format: "{{timestamp}} | <{{title}}> | {{file}}:{{line}} | {{message}}",
		inspectOpt: {
			showHidden: false, //if true then the object's non-enumerable properties will be shown too. Defaults to false
			depth: 2 //tells inspect how many times to recurse while formatting the object. This is useful for inspecting large complicated objects. Defaults to 2. To make it recurse indefinitely pass null.
		}
	};
	// Possible list of logging levels
	// emergency
	// alert
	// critical
	// error
	// warning
	// notice
	// info
	// debug
	this.methods = ['debug', 'info', 'warn', 'error'];
	this.defaultLevel = 'warn';
	this.dateformat = (config && config.dateformat) || "UTC:yyyy-mm-dd'T'HH:MM:ss.l'Z'";
	this.stackIndex = (config && config.stackIndex) || 1; // get the specified index of stack as file information. It is useful for development package.

	this._loadConfig(config);
	this.sessions = {};
	this.methods.forEach(function(m) {
		self._defineProperty(m);
	});
}, null, {
	_loadConfig: function(config, mod) {
		this.name = config.name;
		this.description = config.description;
		this.level = this.methods.indexOf((config && config.level) || this.defaultLevel);
		this.enabled = (config && config.enabled) || false;
		if (this.enabled && mod) {
			if (mod) {
				this.module = mod.name;
				this.level = this.methods.indexOf((mod.level) || this.level);
				this.enabled = mod.enabled;
			}
		}
		this.type = (config && config.transport) || "console";
	},
	_createLine: function(type, format, needstack, args, o) {
		var data = {
			timestamp: dateFormat(new Date(), this.dateformat),
			message: "",
			title: type.toUpperCase(),
			level: type,
			session: globals.context && globals.context.session && globals.context.session.id,
			args: args
		};
		data.method = data.path = data.line = data.pos = data.file = '';

		if (needstack) {
			// get call stack, and analyze it
			// get all file,method and line number
			var stacklist = (new Error()).stack.split('\n').slice(3);
			// Stack trace format :
			// http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
			// DON'T Remove the regex expresses to outside of method, there is a BUG in node.js!!!
			var stackReg = /at\s+(.*)\s+\((.*):(\d*):(\d*)\)/gi;
			var stackReg2 = /at\s+()(.*):(\d*):(\d*)/gi;

			var s = stacklist[this.stackIndex] || stacklist[0],
				sp = stackReg.exec(s) || stackReg2.exec(s);
			if (sp && sp.length === 5) {
				data.method = sp[1];
				data.path = sp[2];
				data.line = sp[3];
				data.pos = sp[4];
				data.file = path.basename(data.path);
				data.stack = stacklist.join('\n');
			}
		}
		//this.transport && this.transport.preprocess(cb, data);
		var msg = utils.format.apply(this._config, data.args);
		data.message = msg;

		// call micro-template to ouput
		data.output = tinytim.tim(format, data);
		return data;
	},
	isTraceEnabled: function(method) {
		var myLevel = this.methods.indexOf(method);
		var res = this.enabled && this.level != null && myLevel >= this.level;
		return res;
	},
	_defineProperty: function(type) {
		var self = this;
		Object.defineProperty(this, type, {
			get: function() {
				// Check main tracer
				self._mustTrace = self.isTraceEnabled(type);
				var res = self._mustTrace;
				// Check sessions tracers
				var sid = globals.context && globals.context.session && globals.context.session.id;
				if (sid && self.sessions[sid]) {
					self.sessions[sid]._mustTrace = self.sessions[sid].isTraceEnabled(type);
					res = self.sessions[sid]._mustTrace || res;
				}

				if (res) return self['_' + type];
				return null;
			},
			configurable: true
		});
	},
	_trace: function(_, type, obj) {
		var self = this;
		if (this.isTraceEnabled(type) && obj) {
			writeFunnel(_, function(_) {
				if (self._mustTrace) {
					var finalObj;
					// to be able to retrieve traces activated for a specific session
					if (self.sid) {
						// clone to not impact initial object that will be used again.
						finalObj = helpers.object.clone(obj, true);
						finalObj.session = self.sid;
						finalObj.sessionOnly = true;
					} else {
						finalObj = obj;
					}
					// call write method of selected device
					traceHelper.writer && traceHelper.writer.write(_, finalObj);
				}
			});
		}
		this._defineProperty(type);
	},
	_traceAll: function(_, type, msg, o) {
		try {
			var format = this._config.format;
			var needstack = /\{\{(method|path|line|pos|file)\}\}/i.test(format);
			var data = this._createLine(type, format, needstack, [msg], o);
			var self = this;
			// global traces
			this._trace(_, type, data);

			var sid = globals.context && globals.context.session && globals.context.session.id;
			if (sid && self.sessions[sid]) {
				self.sessions[sid]._trace(_, type, data, true);
			}
		} catch (e) {
			console.error("_traceAll error: " + e.stack);
			throw e;
		}

	},
	_debug: function(msg, o) {
		this._traceAll(!_, 'debug', msg, o);
	},
	_info: function(msg, o) {
		this._traceAll(!_, 'info', msg, o);
	},
	_warn: function(msg, o) {
		this._traceAll(!_, 'warn', msg, o);
	},
	_error: function(msg, o) {
		this._traceAll(!_, 'error', msg, o);
	},
	fatal: function(msg, o) {
		// TODO: System.exit()
		// Log synchronously in separate file
	},
	toJSON: function() {
		return {
			name: this.name,
			module: this.module,
			title: this.description,
			enabled: this.enabled,
			level: this.methods[this.level],
			transport: this.transport
		};
	}
});