"use strict";

var helpers = require('syracuse-core/lib/helpers');
var datetime = require("syracuse-core/lib/types/datetime");
var os = require('os');
var flows = require('streamline/lib/util/flows');
var traceHelper = require('syracuse-trace/lib/helper');
var globals = require("streamline/lib/globals");
var sys = require('util');

var writeFunnel = flows.funnel(1);

// Generic logging class
var genLogger = exports.genLogger = helpers.defineClass(function(config) {
	var self = this;
	// List of logging levels
	this.methods = ['debug', 'info', 'warn', 'error'];
	this.defaultLevel = 'warn';

	this._loadConfig(config);
	this.sessions = {};
	this.methods.forEach(function(m) {
		self._defineProperty(m);
	});
}, null, {
	_loadConfig: function(config, mod) {
		this.name = config.name;
		this.description = config.description;
		this.level = this.methods.indexOf((config && config.level) || this.defaultLevel);
		this.enabled = (config && config.enabled) || false;
		if (this.enabled && mod) {
			if (mod) {
				this.module = mod.name;
				this.level = this.methods.indexOf((mod.level) || this.level);
				this.enabled = mod.enabled;
			}
		}
	},
	_createLine: function(severity, msg, obj) {
		var data = {
			tag: this.tag,
			category: this.name, // Need to check if this will have the module part
			severity: severity,
			message: msg,
			args: {},
			file: "", // Can only get this from the module in the calling function
			stamp: datetime.now(),
			stack: null, // only for error severity
			session: null,
			pid: null, // For Nannies
			hostname: os.hostname()
		};

		if (severity === "error" && typeof obj === "Error") {
			// Future development
			// Look at how the SHA1 can be incorporated here
			data.stack = obj.stack;
		} else {
			data.args = obj;
		}

		return data;
	},
	isTraceEnabled: function(method) {
		var myLevel = this.methods.indexOf(method);
		var res = this.enabled && this.level != null && myLevel >= this.level;
		if (this.enabled) {
			console.log("Level: " + this.level + "/" + method + "(" + myLevel + ") Enabled: " + this.enabled + "Result: " + res);
		}
		return res;
	},
	_defineProperty: function(severity) {
		var self = this;
		Object.defineProperty(this, severity, {
			get: function() {
				// Check main tracer
				self._mustTrace = self.isTraceEnabled(severity);
				var res = self._mustTrace;
				// Check sessions tracers
				var sid = globals.context && globals.context.session && globals.context.session.id;
				if (sid && self.sessions[sid]) {
					self.sessions[sid]._mustTrace = self.sessions[sid].isTraceEnabled(severity);
					res = self.sessions[sid]._mustTrace || res;
				}

				if (res) {
					return self['_' + severity];
				}
				return null;
			},
			configurable: true
		});
	},
	_trace: function(_, severity, data) {
		var self = this;
		if (this.isTraceEnabled(severity) && data) {
			writeFunnel(_, function(_) {
				if (self._mustTrace) {
					var finalObj;
					// to be able to retrieve traces activated for a specific session
					if (self.sid) {
						// clone to not impact initial object that will be used again.
						finalObj = helpers.object.clone(data, true);
						finalObj.session = self.sid;
						finalObj.sessionOnly = true;
					} else {
						finalObj = data;
					}

					// call write method of selected device
					traceHelper.writer && traceHelper.writer.write(_, finalObj);
				}
			});
		}
		this._defineProperty(severity);
	},
	_traceAll: function(_, severity, msg, obj) {
		var data = this._createLine(severity, msg, obj);
		try {
			var self = this;
			// global traces
			this._trace(_, severity, data);

			var sid = globals.context && globals.context.session && globals.context.session.id;
			if (sid && self.sessions[sid]) {
				self.sessions[sid]._trace(_, severity, data, true);
			}
		} catch (e) {
			console.error("_traceAll error: " + e.stack);
			throw e;
		}

	},
	_debug: function(msg, obj) {
		this._traceAll(!_, 'debug', msg, obj);
	},
	_info: function(msg, obj) {
		this._traceAll(!_, 'info', msg, obj);
	},
	_warn: function(msg, obj) {
		this._traceAll(!_, 'warn', msg, obj);
	},
	_error: function(msg, obj) {
		this._traceAll(!_, 'error', msg, obj);
	},
	fatal: function(msg, obj) {
		// TODO: System.exit()
		// Log synchronously in separate file
	},
	toJSON: function() {
		return {
			name: this.name,
			module: this.module,
			title: this.description,
			enabled: this.enabled,
			level: this.methods[this.level],
			transport: this.transport
		};
	}
});

//Session logging class
exports.sessLogger = helpers.defineClass(function(config) {
	genLogger.call(this, config);
	this.stackIndex = (config && config.stackIndex) || 3; // get the specified index of stack as file information. It is useful for development package.
	this.sid = config.sid;
}, genLogger, {
	_loadConfig: function(config, mod) {
		genLogger.prototype._loadConfig.call(this, config, mod);
		if (!this.enabled && this.transport) {
			this.transport.close();
			this.transport = null;
		}
	}
});