"use strict";

var helpers = require('syracuse-core/lib/helpers');
var os = require('os');
var traceHelper = require('syracuse-trace/lib/helper');
var globals = require("streamline/lib/globals");

// Generic logging class
exports.genLogger = helpers.defineClass(function(config) {
	var self = this;
	this.name = config.name;
	this.records = {};
	// define property for each method
	traceHelper.methods.forEach(function(m) {
		self._defineProperty(m);
	});
}, null, {
	_createLine: function(severity, msg, obj) {
		var data = {
			_id: helpers.uuid.generate(), // necessary to have 'uuid' instead of 'ObjectId(...)' in mongodb
			category: this.name, // Need to check if this will have the module part
			severity: severity,
			message: msg,
			args: {},
			stamp: new Date().toISOString(),
			stack: "", // only for error severity
			session: globals.context.session && globals.context.session.id,
			pid: process.pid, // For Nannies
			hostname: os.hostname()
		};

		if (severity === "error" && obj instanceof Error) {
			// Future development
			// Look at how the SHA1 can be incorporated here
			data.stack = obj.stack;
		} else {
			data.args = obj;
		}

		return data;
	},
	_isTraceEnabled: function(severity, level) {
		if (severity === "error") return true;
		var myLevel = traceHelper.methods.indexOf(severity);
		var res = level != null && myLevel >= level;
		return res;
	},
	// THIS FUNCTION ALLOWS TO KNOW IF SOME SEVERITIES ARE ACTIVATED WITHOUT CALLING FUNCTION WITH ()
	_defineProperty: function(severity) {
		var self = this;
		Object.defineProperty(this, severity, {
			get: function() {
				if (Object.keys(self.records).length > 0) return self['_' + severity];
				return null;
			},
			configurable: true
		});
	},
	_trace: function(severity, msg, obj) {
		var self = this;
		var data;

		var fails = false;
		// trace all active records
		Object.keys(self.records).forEach(function(recId) {
			var rec = self.records[recId];
			if (rec.level && self._isTraceEnabled(severity, rec.level)) {
				data = data || self._createLine(severity, msg, obj);
				fails = !(rec.queue && rec.queue.put(data));
			}
		});
		// prevent losing traces... if queue is full, redirect to stdout
		if (fails) console.log(JSON.stringify(data));
	},
	_debug: function(msg, obj) {
		this._trace('debug', msg, obj);
	},
	_info: function(msg, obj) {
		this._trace('info', msg, obj);
	},
	_warn: function(msg, obj) {
		this._trace('warn', msg, obj);
	},
	_error: function(msg, obj) {
		this._trace('error', msg, obj);
	},
	_fatal: function(msg, obj) {
		// TODO: System.exit()
		// Log synchronously in separate file
	},
});