"use strict";

var config = require('config');
var helpers = require('syracuse-core/lib/helpers');
var os = require('os');
var flows = require('streamline/lib/util/flows');
var traceHelper = require('syracuse-trace/lib/helper');
var globals = require("streamline/lib/globals");

// log entries are written to this queue
var queue = flows.queue({
	max: config.system.traceQueueMax || 10000,
});

// process which dequeues log entries and sends them to log device
(function(_) {
	while (queue) {
		var item = queue.get(_);
		traceHelper.writer && traceHelper.writer.write(_, item);
	}
})(_ >> function(err) {
	if (err) {
		console.error(err.stack);
		queue = null;
	}
});

// Generic logging class
var genLogger = exports.genLogger = helpers.defineClass(function(config) {
	var self = this;
	this.sid = config.sid;
	// List of logging levels
	this.methods = ['debug', 'info', 'warn', 'error'];
	this.defaultLevel = 'warn';

	this._loadConfig(config);
	this.sessions = {};
	this.methods.forEach(function(m) {
		self._defineProperty(m);
	});
}, null, {
	_loadConfig: function(config, mod) {
		this.name = config.name;
		this.description = config.description;
		this.level = this.methods.indexOf((config && config.level) || this.defaultLevel);
		this.enabled = (config && config.enabled) || false;
		if (this.enabled && mod) {
			if (mod) {
				this.module = mod.name;
				this.level = this.methods.indexOf((mod.level) || this.level);
				this.enabled = mod.enabled;
			}
		}
	},
	_updateConfig: function(config) {
		// There are a limited number of things in the configuration that can
		// be udpated once the logger has been created.
		this.file = config.file;
		if (config.level) {
			this.level = config.level;
		}
	},
	_createLine: function(severity, msg, obj) {
		// !! IMPORTANT : this object must properties that exist in trace entity 
		var data = {
			_id: helpers.uuid.generate(), // necessary to have 'uuid' instead of 'ObjectId(...)' in mongodb
			tag: this.tag,
			category: this.name, // Need to check if this will have the module part
			severity: severity,
			message: msg,
			args: {},
			file: "", // Can only get this from the module in the calling function
			stamp: new Date().toISOString(),
			stack: null, // only for error severity
			session: globals.context.session && globals.context.session.id,
			pid: null, // For Nannies
			hostname: os.hostname()
		};

		if (severity === "error" && typeof obj === "Error") {
			// Future development
			// Look at how the SHA1 can be incorporated here
			data.stack = obj.stack;
		} else {
			data.args = obj;
		}

		return data;
	},
	isTraceEnabled: function(method) {
		var myLevel = this.methods.indexOf(method);
		var res = this.enabled && this.level != null && myLevel >= this.level;
		return res;
	},
	_defineProperty: function(severity) {
		var self = this;
		Object.defineProperty(this, severity, {
			get: function() {
				// Check main tracer
				self._mustTrace = self.isTraceEnabled(severity);
				var res = self._mustTrace;
				// Check sessions tracers
				var sid = globals.context && globals.context.session && globals.context.session.id;
				if (sid && self.sessions[sid]) {
					self.sessions[sid]._mustTrace = self.sessions[sid].isTraceEnabled(severity);
					res = self.sessions[sid]._mustTrace || res;
				}

				if (res) {
					return self['_' + severity];
				}
				return null;
			},
			configurable: true
		});
	},
	_trace: function(severity, data) {
		var self = this;

		if (this.isTraceEnabled(severity) && data) {
			var sessionTraced = false;
			if (self._mustTrace) {
				// check if it's session tracer
				if (self.sid) {
					// overwrite session id because it can be null in global cases
					data.session = self.sid;
					sessionTraced = true;
				}
				// call write method of selected device
				if (!(queue && queue.put(data))) console.log(JSON.stringify(data));
			}
			return sessionTraced;
		}
	},
	_traceAll: function(severity, msg, obj) {
		var data = this._createLine(severity, msg, obj);
		var self = this;
		// session traces
		var sid = globals.context && globals.context.session && globals.context.session.id;
		if (sid && self.sessions[sid]) {
			// Do not trace globals if session is already traced...
			if (self.sessions[sid]._trace(severity, data)) return;
		}
		// global traces
		this._trace(severity, data);
	},
	_debug: function(msg, obj) {
		this._traceAll('debug', msg, obj);
	},
	_info: function(msg, obj) {
		this._traceAll('info', msg, obj);
	},
	_warn: function(msg, obj) {
		this._traceAll('warn', msg, obj);
	},
	_error: function(msg, obj) {
		this._traceAll('error', msg, obj);
	},
	fatal: function(msg, obj) {
		// TODO: System.exit()
		// Log synchronously in separate file
	},
	toJSON: function() {
		return {
			name: this.name,
			module: this.module,
			title: this.description,
			enabled: this.enabled,
			level: this.methods[this.level],
			transport: this.transport
		};
	}
});