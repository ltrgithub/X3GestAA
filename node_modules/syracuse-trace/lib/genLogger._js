"use strict";

var helpers = require('syracuse-core/lib/helpers');
var os = require('os');
var globals = require("streamline/lib/globals");
var methods = exports.methods = ['debug', 'info', 'warn', 'error', 'fatal'];
var util = require('util');

// Generic logging class
exports.GenLogger = helpers.defineClass(function(config) {
	var self = this;
	this.name = config.name; // name of that logger
	this._records0 = []; // array with log records for each level. Contains array of objects with queue and log record uuid and session id
	this._logFunctions = []; // generated log functions for the log levels (cache, so that generation is necessary only once)
	this._sessions = []; // array with sessions for each level, when there are session dependent loggers. Extra property for performance reasons
	// a session will be contained also in higher levels, e. g. when a "info" record is registered, its session will also be
	// in "warning", "error", "fatal". This means that (!!this._session[i] === true) means that there are session dependent loggers
	// with numerical log level less or equal i. Therefore there is no counterpart of this._minLogLevel. Keys of the entries: sessionId, 
	// value: number of session dependent loggers for that session
	this._sessionTenants = []; // array with tenants for each level, when there are session dependent loggers for these tenants. Extra property for performance reasons
	this._tenants = []; // array with tenants for each level, when tenants are available. A tenant will also be contained in higher levels (cf. _sessions)
	this._selectionTypes = methods.map(function(item) {
		return 0;
	}); // array with type of getter for this log level: 0: always false, 1: tenant dependent, 2: session dependent, 3: session and tenant dependent, 7: always true
	// Keys of the entries: tenantIds, values: number of session independent loggers for that tenant
}, null, {
	_createLine: function(severity, msg, obj) {
		var data = {
			_id: helpers.uuid.generate(), // necessary to have 'uuid' instead of 'ObjectId(...)' in mongodb
			category: this.name, // Need to check if this will have the module part
			severity: severity,
			message: msg,
			args: {},
			stamp: new Date().toISOString(),
			stack: "", // only for error severity
			session: globals.context.session && globals.context.session.id,
			pid: process.pid, // For Nannies
			hostname: os.hostname()
		};

		if (severity === "error" && obj instanceof Error) {
			// Future development
			// Look at how the SHA1 can be incorporated here
			data.stack = obj.stack;
		} else {
			data.args = obj;
		}

		return data;
	},
	// THIS FUNCTION ALLOWS TO KNOW IF SOME SEVERITIES ARE ACTIVATED WITHOUT CALLING FUNCTION WITH ()
	_defineProperty: function(ilevel, sessions, tenants) {
		var level = methods[ilevel];
		var selectionType = this._selectionTypes[ilevel];
		var fun = this._generateLog(ilevel, level);
		if (sessions) {
			if (tenants) {
				if (selectionType !== 3) {
					Object.defineProperty(this, level, {
						get: function() {
							try {
								if (globals.context.session.id in sessions) return fun;
								if (globals.context.tenantId in tenants) return fun;
							} catch (e) {}; // ignore errors, e. g. when there is no session
							return null;
						},
						configurable: true
					});
					this._selectionTypes[ilevel] = 3;
				}
			} else {
				if (selectionType !== 2) {
					Object.defineProperty(this, level, {
						get: function() {
							try {
								if (globals.context.session.id in sessions) return fun;
							} catch (e) {}; // ignore errors, e. g. when there is no session
							return null;
						},
						configurable: true
					});
					this._selectionTypes[ilevel] = 2;
				}
			}
		} else {
			if (selectionType !== 1) {
				Object.defineProperty(this, level, {
					get: function() {
						try {
							if (globals.context.tenantId in tenants) return fun;
						} catch (e) {}; // ignore errors, e. g. when there is no session
						return null;
					},
					configurable: true
				});
				this._selectionTypes[ilevel] = 1;
			}
		}
	},
	// delete record with this sequence number and maybe remove certain log levels
	deleteRecord: function(uuid) {
		var self = this;
		var result;
		var ilevel;
		var sessionIndependent = false; // session independent logger found
		var maxTenants;
		var resultLevel;
		var resultSid;
		var resultTenant;
		var sessionTenants = []; // array of all tenants with session loggers but without tenant loggers for a certain log level
		for (ilevel = 0; ilevel < methods.length; ilevel++) {
			var recs = self._records0[ilevel];
			var tenants = self._tenants[ilevel];
			if (resultTenant && !resultSid) { // update tenants already before loop in order to have correct value of sessionTenants
				if (tenants[resultTenant] > 1) tenants[resultTenant]--;
				else {
					if (Object.keys(tenants).length === 1) {
						tenants = this._tenants[ilevel] = undefined;
					} else delete tenants[resultTenant];
				}
			}
			if (recs) {
				for (var j = recs.length - 1; j >= 0; j--) {
					var rec = recs[j];
					if (rec.uuid === uuid) { // found
						result = rec;
						recs.splice(j, 1); // remove this logger
						resultSid = rec.sid;
						resultTenant = rec.tenantId;
						resultLevel = ilevel;
						if (maxTenants = this._tenants[methods.length - 1]) {
							// by deleting this logger, the number of tenant loggers of maximum logging level will be decreased?
							var diff = (resultSid || maxTenants[resultTenant] > 1) ? 0 : 1;
							maxTenants = Object.keys(maxTenants).length - diff;
							// console.error("HIHI "+maxTenants+" "+diff)
						} else maxTenants = 0;
						if (!resultTenant && !sessionIndependent) break;
					} else {
						if (rec.tenantId) { // update list of session tenants
							var tenantId = rec.tenantId;
							// session dependent logger for which there is no tenant logger yet
							if (rec.sid && (!tenants || !(tenantId in tenants)) && sessionTenants.indexOf(tenantId) < 0) {
								sessionTenants.push(tenantId);
							} else { // tenant logger for this tenant: no session dependence any more!
								var ind = sessionTenants.indexOf(tenantId);
								if (ind >= 0) sessionTenants.splice(ind, 1);
							}
						} else if (!sessionIndependent && !rec.sid) sessionIndependent = true;
					}
				}
			}
			// update sessions and tenants
			if (result) {
				var sessions = this._sessions[ilevel];
				if (resultSid) {
					if (sessions[resultSid] > 1) sessions[resultSid]--;
					else {
						if (Object.keys(sessions).length === 1) {
							sessions = this._sessions[ilevel] = undefined;
						} else delete sessions[resultSid];
					}
				} else if (resultTenant && ilevel === resultLevel) {
					if (tenants[resultTenant] > 1) tenants[resultTenant]--;
					else {
						if (Object.keys(tenants).length === 1) {
							tenants = this._tenants[ilevel] = undefined;
						} else delete tenants[resultTenant];
						// maybe above evaluation of sessionTenants has been wrong. Therefore 
						// do it again for resultTenant
						if (recs && recs.some(function(rec) {
							return (rec.sid && (rec.tenantId === resultTenant));
						})) sessionTenants.push(resultTenant);
					}
				}
				// status update
				if (resultTenant) {
					this._updateStatus(ilevel, sessionTenants, sessions, tenants, maxTenants);
				} else { // no tenants
					// console.error("LEV "+ilevel+" "+sessionIndependent+" "+sessions)
					if (!sessionIndependent && sessions) this._defineProperty(ilevel, sessions);
					else {
						var types = this._selectionTypes[ilevel];
						var method = methods[ilevel];
						if (sessionIndependent) {
							if (types < 7) {
								delete this[method];
								this[method] = this._generateLog(ilevel, method);
								this._selectionTypes[ilevel] = 7;
							}
						} else {
							if (types > 0) {
								delete this[method];
								this._selectionTypes[ilevel] = 0;
							}
						}
					}
				}
			}
		}
		// maybe some status for lower logging levels for multitenant has to be updated: maybe by deleting this logger, unconditional logging will be established
		if (resultTenant) {
			if (sessionTenants.length) {
				if (resultSid) {
					// console.error("JJJJJ "+sessionTenants.length)
					// maybe there are session dependent loggers for higher levels and tenants for which there are no tenant loggers 
					for (var ilevel = methods.length - 1; ilevel >= resultLevel; ilevel--) {
						if (this._selectionTypes[ilevel] === 7) {
							this._defineProperty(ilevel, null, this._tenants[ilevel]);
						}
					}
				}
			} else {
				for (var ilevel = 0; ilevel < resultLevel; ilevel++) {
					if (this._selectionTypes[ilevel] === 1 && Object.keys(this._tenants[ilevel]).length === maxTenants) {
						var method = methods[ilevel];
						delete this[method];
						this[method] = this._generateLog(ilevel, method);
						this._selectionTypes[ilevel] = 7;
					}
				}

			}
		}
		// console.error("NACH DELETE "+util.format(this)+" "+util.format(this._records0))
	},
	// add this log record and maybe add new logging levels. The argument must be an object with properties:
	// uuid: sequence number (for further operations)
	// level: string level of logging
	// queue: queue to append to
	// sid (optional): tracing only for this session ID,
	// tenantId: tracing only for this tenant ID
	addRecord: function(uuid, level, queue, sid, tenantId) {
		var ilevel = methods.indexOf(level);
		if (ilevel < 0) throw new Error("Wrong log level " + level);
		if (!queue) throw new Error("No queue in record " + uuid);
		if (tenantId) { // special processing for multitenant. Loop over all records to simplify algorithm and to save space
			var sessionTenants = []; // array of all tenants with session loggers but without tenant loggers for a certain log level
			// find out number of tenants for highest logging level
			var tenants = this._tenants[methods.length - 1];
			var maxTenants = 0;
			if (tenants) {
				maxTenants = Object.keys(tenants).length;
				// when tenant logger is added which is not yet included in maxTenants, add it to maxTenants.
				if (!sid && !(tenantId in tenants)) maxTenants++;
			}
			for (var i = 0; i < methods.length; i++) {
				var recs = this._records0[i];
				if (!recs) {
					if (i < ilevel) continue;
					recs = this._records0[i] = [];
				}
				var tenants = this._tenants[i];
				// update sessions and tenants
				var sessions = this._sessions[i];
				if (i >= ilevel) {
					if (sid) {
						if (!sessions) sessions = this._sessions[i] = {};
						if (sid in sessions) sessions[sid]++;
						else sessions[sid] = 1;
					} else {
						if (!tenants) tenants = this._tenants[i] = {};
						if (tenantId in tenants) tenants[tenantId]++;
						else tenants[tenantId] = 1;
					}
				}
				if (ilevel === i) {
					recs.push({
						uuid: uuid,
						level: level,
						queue: queue,
						sid: sid,
						tenantId: tenantId
					});
				}
				recs.forEach(function(rec) {
					var tenantId0 = rec.tenantId;
					if (rec.sid && (!tenants || !(tenantId0 in tenants))) {
						if (sessionTenants.indexOf(tenantId0) < 0) sessionTenants.push(tenantId0);
					} else { // tenant logger for this tenant: no session dependence any more!
						var ind = sessionTenants.indexOf(tenantId0);
						if (ind >= 0) sessionTenants.splice(ind, 1);
					}
				});
				// update status
				this._updateStatus(i, sessionTenants, sessions, tenants, maxTenants);
				// maybe some status for lower logging levels for multitenant has to be updated: the highest level may have a session logger for a tenant without
				// tenant logger, so logging for lover levels must not be unconditional (7)

			}
			// maybe remove selection status 7 for lower levels when there are some session dependent tenants without tenant logger
			if (sessionTenants.length) {
				for (var i = methods.length - 2; i >= 0; i--) {
					if (this._selectionTypes[i] === 7) this._defineProperty(i, null, this._tenants[i]);
				}
			}
		} else {
			var recs = (this._records0[ilevel] = this._records0[ilevel] || []);
			recs.push({
				uuid: uuid,
				level: level,
				queue: queue,
				sid: sid,
				tenantId: tenantId
			});
			if (sid) {
				for (var i = ilevel; i < methods.length; i++) {
					var sessions = (this._sessions[i] = this._sessions[i] || {});
					// nothing to do when there is already a session logger for this session and level
					// add count for this session
					if (sid in sessions) {
						sessions[sid]++;
					} else {
						sessions[sid] = 1;
						// console.error(i+"SID "+sid+" "+this._selectionTypes[i])
						if (this._selectionTypes[i] < 2) { // add session dependent properties when there are no loggers yet
							this._defineProperty(i, sessions, null);
						}
						// console.error(i+"SIDx "+sid+" "+this._selectionTypes[i])
					}
				}
			} else {
				for (var i = ilevel; i < methods.length && this._selectionTypes[i] < 7; i++) {
					if (this._selectionTypes[i]) delete this[methods[i]];
					this[methods[i]] = this._generateLog(i, methods[i]);
					this._selectionTypes[i] = 7;
				}
			}
		}
		// console.error("NACH ADD "+util.format(this));
	},
	// return or generate a logging function for given log level
	_generateLog: function(ilevel, level) {
		var fun = this._logFunctions[ilevel];

		if (fun) return fun;
		fun = function(msg, obj) { // level, ilevel will be stored in the closure
			var self = this;
			// allow direct data object (for tracing again messages which are before the start of the tracing system) when message is 'null'.
			// see _launchAutoTraceRecord in helper.
			var data = (msg === null && obj && obj.category === self.name) ? obj : self._createLine(level, msg, obj);
			var fails = false;
			var empty = true;
			var tenantId = globals.context.tenantId;
			var sid = globals.context.session ? globals.context.session.id : "-";
			for (var i = 0; i <= ilevel; i++) {
				var recs = self._records0[i];
				if (recs) {
					recs.forEach(function(rec) {
						// for session dependent records, the SID must fit exactly (and then also the tenant must be OK)
						// for multitenant: all records are tenant dependent, log only when correct tenant
						if (rec.sid === sid || !rec.sid && (!tenantId || rec.tenantId === tenantId)) {
							fails = !rec.queue.put(data) || fails; // message will be written to console.log when at least one queue.put does not work
							empty = false;
						}
					});
				}
			}
			if (fails || empty) console.log(JSON.stringify(data));
		};
		this._logFunctions[ilevel] = fun;
		return fun;
	},
	_updateStatus: function(i, sessionTenants, sessions, tenants, maxTenants) {
		//console.error("US "+i+" "+sessionTenants.join(',')+" "+sessions+" "+tenants+" "+maxTenants)
		if (sessionTenants.length > 0) {
			this._defineProperty(i, sessions, tenants);
		} else {
			var type = this._selectionTypes[i];
			var method = methods[i];
			if (!tenants) {
				if (type > 0) {
					delete this[method];
					this._selectionTypes[i] = 0;
				}
			} else if (Object.keys(tenants).length >= maxTenants) {
				if (type < 7) {
					delete this[method];
					this[method] = this._generateLog(i, method);
					this._selectionTypes[i] = 7;
				}
			} else {
				this._defineProperty(i, null, tenants);
			}
		}
		// console.error("Nachher "+this._selectionTypes[i])
	}

});