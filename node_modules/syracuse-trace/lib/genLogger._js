"use strict";

var helpers = require('syracuse-core/lib/helpers');
var os = require('os');
var traceHelper = require('syracuse-trace/lib/helper');
var globals = require("streamline/lib/globals");
var methods = traceHelper.methods;

// Generic logging class
exports.genLogger = helpers.defineClass(function(config) {
	var self = this;
	this.name = config.name;
	this.minLogLevel = methods.length; // minimum session independent log level
	this.records0 = []; // array with log records for each level. Contains array of objects with queue and log record
	this._logFunctions = []; // generated log functions for the log levels
}, null, {
	_createLine: function(severity, msg, obj) {
		var data = {
			_id: helpers.uuid.generate(), // necessary to have 'uuid' instead of 'ObjectId(...)' in mongodb
			category: this.name, // Need to check if this will have the module part
			severity: severity,
			message: msg,
			args: {},
			stamp: new Date().toISOString(),
			stack: "", // only for error severity
			session: globals.context.session && globals.context.session.id,
			pid: process.pid, // For Nannies
			hostname: os.hostname()
		};

		if (severity === "error" && obj instanceof Error) {
			// Future development
			// Look at how the SHA1 can be incorporated here
			data.stack = obj.stack;
		} else {
			data.args = obj;
		}

		return data;
	},
	// THIS FUNCTION ALLOWS TO KNOW IF SOME SEVERITIES ARE ACTIVATED WITHOUT CALLING FUNCTION WITH ()
	_defineProperty: function(severity) {
		var self = this;
		/* Only necessary for session dependent logging
		Object.defineProperty(this, severity, {
			get: function() {
				if (Object.keys(self.records).length > 0) return self['_' + severity];
				return null;
			},
			configurable: true
		});
		*/
	},
	// delete record with this uuid and maybe remove certain log levels
	deleteRecord: function(uuid) {
		var self = this;
		for (var ilevel = self.minLogLevel; ilevel < methods.length; ilevel++) {
			var recs = self.records0[ilevel];
			if (recs) {
				for (var j = recs.length - 1; j >= 0; j--) {
					if (recs[j].uuid === uuid) {
						recs.splice(j, 1); // delete that record
						if (recs.length === 0 && ilevel === self.minLogLevel) {
							// no records any more for minimum log level: minimum log level has to be raised
							for (var ilevel2 = self.minLogLevel; ilevel2 < methods.length; ilevel2++) {
								recs = self.records0[ilevel2];
								if (!recs || recs.length === 0) {
									self.minLogLevel++;
									delete self[methods[ilevel2]];
								}
							}
						}
						return;
					}
				}
			}
		}
	},
	// add this log record and maybe add new logging levels
	addRecord: function(uuid, options) {
		var level = options.level;
		var queue = options.queue;
		var sid = options.sid;
		var ilevel = methods.indexOf(level);
		if (ilevel < 0) throw new Error("Wrong log level " + level);
		if (!queue) throw new Error("No queue in record " + uuid);
		var recs = (this.records0[ilevel] = this.records0[ilevel] || []);
		recs.push({
			uuid: uuid,
			queue: queue
		});
		if (ilevel < this.minLogLevel) { // add more log methods
			for (var i = ilevel; i < this.minLogLevel; i++) {
				this[methods[i]] = this._generateLog(i, methods[i]);
			}
			this.minLogLevel = ilevel;
		}
	},
	// return or generate a logging function for given log level
	_generateLog: function(ilevel, level) {
		var fun = this._logFunctions[ilevel];
		if (fun) return fun;
		fun = function(msg, obj) { // level, ilevel will be stored in the closure
			var self = this;
			var data;
			var fails = false;
			for (var i = 0; i <= ilevel; i++) {
				var recs = self.records0[i];
				if (recs) {
					recs.forEach(function(rec) {
						data = data || self._createLine(level, msg, obj);
						fails = !rec.queue.put(data);
					});
				}
			}
		};
		this._logFunctions[ilevel] = fun;
		return fun;
	},
});