"use strict";

const helpers = require('syracuse-core').helpers;
const config = require('config'); // must be first syracuse require
const globals = require('streamline-runtime').globals;
const flows = require('streamline-runtime').flows;
const jwt = require('jsonwebtoken');
const connAppHelper = require('syracuse-4gl-api/lib/connectedApp');
const adminTestFixtures = require("syracuse-collaboration/test/fixtures/adminTestFixtures");

const adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
const testAdmin = require('syracuse-core').apis.get('test-admin');


const port = (config.unit_test && config.unit_test.serverPort) || 3004;
const baseUrl = "http://localhost:" + port;

let tracer; // = console.log;

let doStop = false;
QUnit.module(module.id);

let db;
asyncTest("init server", 1, function(_) {
	//
	db = testAdmin.initializeTestEnvironnement(_);
	ok(db != null, "Environnement initialized");
	//
	start();
});

function onlyInfo(diags) {
	return testAdmin.onlyInfo(diags);
}

function hasErrors(body) {
	let hasErr = body.$diagnoses && body.$diagnoses.some(function(diag) {
		return diag.$severity == "error" || diag.severity === "error";
	});
	if (!hasErr) {
		for (let key in body) {
			if (typeof body[key] === "object") hasErr = hasErr || hasErrors(body[key]);
		};
	}
	//
	return hasErr;
}



let user = "admin";
globals.context = globals.context || {};
globals.context.session = {
	host: "http://localhost:3004",
	id: helpers.uuid.generate(),
	getUserLogin: function(_) {
		return user;
	},
	getUserProfile: function(_) {
		return {
			user: function(_) {
				let db = adminHelper.getCollaborationOrm(_);
				return db.fetchInstance(_, db.model.getEntity(_, "user"), {
					jsonWhere: {
						login: user
					}
				});
			},
			selectedLocale: function(_) {
				let db = adminHelper.getCollaborationOrm(_);
				let locale = db.fetchInstance(_, db.model.getEntity(_, "localePreference"), {
					code: "en-US"
				});
				return locale;
			},
		};
	},
	getSecurityProfile: function(_) {
		return null;
	},
	getData: function(code) {
		return null;
	}
};

let clientId, secret;
let tokens = [];
asyncTest("Create connected application", 5, function(_) {


	let connAppEntity = db.model.getEntity(_, "connectedApplication");
	let inst = connAppEntity.createInstance(_, db);
	inst.name(_, "My connected application");
	inst.url(_, "http://myconnectedapp:3000");
	inst.expiration(_, "2s");
	inst.save(_);

	strictEqual(inst.name(_), "My connected application", `Connected application name OK ${inst.name(_)}`);
	strictEqual(inst.url(_), "http://myconnectedapp:3000", `Connected application url OK ${inst.url(_)}`);
	strictEqual(inst.active(_), true, `Connected application active by default OK`);

	clientId = inst.clientId(_);
	secret = inst.secretCreated(_);
	ok(clientId != null, `Client ID generated OK ${clientId}`);
	ok(secret != null, `Secret generated OK ${secret}`);

	start();
});

asyncTest("generate tokens", 1, function(_) {

	let tokenParams1 = `auth: 
  - auth1
  - auth2
  - auth3
site: SITE1`;

	let token1 = connAppHelper.getConnectedAppToken(_, clientId, tokenParams1)
	tokens.push(token1);
	// generate a second token to be sure we can have several :)
	let tokenParams2 = `auth: 
  - auth3
  - auth4
site: SITE2`;
	let token2 = connAppHelper.getConnectedAppToken(_, clientId, tokenParams2);
	tokens.push(token2);

	ok(tokens != null && tokens.length === 2, "JWTs generated OK");

	start();
});

asyncTest("verify tokens", 22, function(_) {
	let db = adminHelper.getCollaborationOrm(_);
	let model = db.model;
	let entity = model.getEntity(_, "tokenInfo");
	let filter = {
		sdataWhere: "app.clientId eq '" + clientId + "'"
	};
	let tokenInfos = db.fetchInstances(_, entity, filter); //.toArray(_);
	ok(tokenInfos.length === 2, `Two tokens generated OK`);

	let tokenInst = tokenInfos[0];
	ok(tokenInst.jti(_) != null, `Token ID generated OK ${tokenInst.jti(_)}`);
	ok(tokenInst.clientId(_) != null, `Connected app ID linked to token OK ${tokenInst.clientId(_)}`);
	let info = tokenInst.info(_);
	ok(info.auth && info.auth.length === 3, `Auth info count OK ${info.auth.length}`);
	strictEqual(info.auth && info.auth[0], 'auth1', `Auth info first value OK ${info.auth[0]}`);
	strictEqual(info.auth && info.auth[1], 'auth2', `Auth info second value OK ${info.auth[1]}`);
	strictEqual(info.auth && info.auth[2], 'auth3', `Auth info third value OK ${info.auth[2]}`);
	strictEqual(info.site, 'SITE1', `Site info value OK ${info.site}`);

	let tokenToVerify = tokens[0];
	let decoded = jwt.verify(tokenToVerify, secret);

	strictEqual(decoded.jti, tokenInst.jti(_), `jti verified OK ${decoded.jti}`);
	strictEqual(decoded.sub, 'admin', `sub verified OK ${decoded.sub}`);
	ok(decoded.auth && decoded.auth.length === 3, `Auth decoded count verified OK ${decoded.auth.length}`);
	strictEqual(decoded.auth && decoded.auth[0], 'auth1', `Auth decoded first value verified OK ${decoded.auth[0]}`);
	strictEqual(decoded.auth && decoded.auth[1], 'auth2', `Auth decoded second value verified OK ${decoded.auth[1]}`);
	strictEqual(decoded.auth && decoded.auth[2], 'auth3', `Auth decoded third value verified OK ${decoded.auth[2]}`);
	strictEqual(decoded.site, 'SITE1', `Site decoded value OK ${decoded.site}`);

	let error;
	try {
		jwt.verify(tokenToVerify, "Bad secret");
	} catch (e) {
		error = e;
	} finally {
		ok(error != null, "First verification failed because of invalid secret OK");
		strictEqual(error.name, 'JsonWebTokenError', `Name of bad secret token error OK ${error.name}`);
		strictEqual(error.message, 'invalid signature', `Message of bad secret token error OK ${error.message}`);
	}
	error = null;

	flows.sleep(_, 3000);
	try {
		jwt.verify(tokenToVerify, secret);
	} catch (e) {
		error = e;
	} finally {
		ok(error != null, "Second verification failed because of expiration OK");
		strictEqual(error.name, 'TokenExpiredError', `Name of expiration token error OK ${error.name}`);
		strictEqual(error.message, 'jwt expired', `Message of expiration token error OK ${error.message}`);
		ok(error.expiredAt != null, `Date of expiration token error OK ${error.expiredAt}`);
	}
	error = null;

	start();
});

asyncTest("userinfo dispatch", 2, function(_) {
	let headers = {
		authorization: `Bearer ${tokens[0]}`
	}
	let res = adminTestFixtures.get(_, null, baseUrl + "/auth/userinfo", 401, false, headers)
	strictEqual(res.$diagnoses && res.$diagnoses[0] && res.$diagnoses[0].$message, "Error 3: Invalid token", "tokenInfo expired and deleted OK")

	// TODO: Test every cases where token validation should fail !


	start();
});

asyncTest("stop tests", 0, function(_) {
	doStop = true;

	start();
});