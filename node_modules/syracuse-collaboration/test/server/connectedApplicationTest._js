"use strict";

const helpers = require('syracuse-core').helpers;
const uuid = helpers.uuid;
const forEachKey = helpers.object.forEachKey;
const config = require('config'); // must be first syracuse require
const globals = require('streamline-runtime').globals;
const flows = require('streamline-runtime').flows;

var jwt = require('jsonwebtoken');


const adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
const testAdmin = require('syracuse-core').apis.get('test-admin');

helpers.pageFileStorage = false;

const port = (config.unit_test && config.unit_test.serverPort) || 3004;
const baseUrl = "http://localhost:" + port;

let tracer; // = console.log;
const testUrl = baseUrl + "/sdata/syracuse/collaboration/unit_test";

let doStop = false;
QUnit.module(module.id);

let db;
asyncTest("init server", 1, function(_) {
	//
	db = testAdmin.initializeTestEnvironnement(_);
	ok(db != null, "Environnement initialized");
	//
	start();
});

function onlyInfo(diags) {
	return testAdmin.onlyInfo(diags);
}

function hasErrors(body) {
	var hasErr = body.$diagnoses && body.$diagnoses.some(function(diag) {
		return diag.$severity == "error" || diag.severity === "error";
	});
	if (!hasErr) {
		for (var key in body) {
			if (typeof body[key] === "object") hasErr = hasErr || hasErrors(body[key]);
		};
	}
	//
	return hasErr;
}



var user = "admin";
globals.context = globals.context || {};
globals.context.session = {
	id: helpers.uuid.generate(),
	getUserLogin: function(_) {
		return user;
	},
	getUserProfile: function(_) {
		return {
			user: function(_) {
				var db = adminHelper.getCollaborationOrm(_);
				return db.fetchInstance(_, db.model.getEntity(_, "user"), {
					jsonWhere: {
						login: user
					}
				});
			},
			selectedLocale: function(_) {
				var db = adminHelper.getCollaborationOrm(_);
				var locale = db.fetchInstance(_, db.model.getEntity(_, "localePreference"), {});
				return locale;
			},
		};
	},
	getSecurityProfile: function(_) {
		return null;
	},
	getData: function(code) {
		return null;
	}
};

let clientId, secret;
asyncTest("Create connected application and generate token", 30, function(_) {


	let connAppEntity = db.model.getEntity(_, "connectedApplication");
	let inst = connAppEntity.createInstance(_, db);
	inst.name(_, "My connected application");
	inst.url(_, "http://myconnectedapp:3000");
	inst.save(_);

	strictEqual(inst.name(_), "My connected application", `Connected application name OK ${inst.name(_)}`);
	strictEqual(inst.url(_), "http://myconnectedapp:3000", `Connected application url OK ${inst.url(_)}`);
	strictEqual(inst.active(_), true, `Connected application active by default OK`);

	clientId = inst.clientId(_);
	secret = inst.secretCreated(_);
	ok(clientId != null, `Client ID generated OK ${clientId}`);
	ok(secret != null, `Secret generated OK ${secret}`);
	ok(inst.tokenInfos(_).toArray(_).length === 0, `Zero token created OK`);

	let tokenParams = `auth: 
  - auth1
  - auth2
  - auth3
site: SITE1`;

	let token = inst.generateToken(_, tokenParams, {
		expiration: "2s"
	});
	// generate a second token to be sure we can several :)
	inst.generateToken(_, tokenParams);
	ok(token != null, "JWT generated OK");
	let tokenInfos = inst.tokenInfos(_).toArray(_)
	ok(tokenInfos.length === 2, `Two tokens generated OK`);

	let tokenInst = tokenInfos[0];
	ok(tokenInst.jti(_) != null, `Token ID generated OK ${tokenInst.jti(_)}`);
	ok(tokenInst.clientId(_) != null, `Connected app ID linked to token OK ${tokenInst.clientId(_)}`);
	let info = tokenInst.info(_);
	ok(info.auth && info.auth.length === 3, `Auth info count OK ${info.auth.length}`);
	strictEqual(info.auth && info.auth[0], 'auth1', `Auth info first value OK ${info.auth[0]}`);
	strictEqual(info.auth && info.auth[1], 'auth2', `Auth info second value OK ${info.auth[1]}`);
	strictEqual(info.auth && info.auth[2], 'auth3', `Auth info third value OK ${info.auth[2]}`);
	strictEqual(info.site, 'SITE1', `Site info value OK ${info.site}`);

	var decoded = jwt.verify(token, secret);

	strictEqual(decoded.jwtid, tokenInst.jti(_), `jwtid verified OK ${decoded.jwtid}`);
	strictEqual(decoded.sub, 'admin', `sub verified OK ${decoded.sub}`);
	ok(decoded.auth && decoded.auth.length === 3, `Auth decoded count verified OK ${decoded.auth.length}`);
	strictEqual(decoded.auth && decoded.auth[0], 'auth1', `Auth decoded first value verified OK ${decoded.auth[0]}`);
	strictEqual(decoded.auth && decoded.auth[1], 'auth2', `Auth decoded second value verified OK ${decoded.auth[1]}`);
	strictEqual(decoded.auth && decoded.auth[2], 'auth3', `Auth decoded third value verified OK ${decoded.auth[2]}`);
	strictEqual(decoded.site, 'SITE1', `Site decoded value OK ${decoded.site}`);

	let error;
	try {
		jwt.verify(token, "Bad secret");
	} catch (e) {
		error = e;
	} finally {
		ok(error != null, "Second verification failed because of expiration OK");
		strictEqual(error.name, 'JsonWebTokenError', `Name of bad secret token error OK ${error.name}`);
		strictEqual(error.message, 'invalid signature', `Message of bad secret token error OK ${error.message}`);
	}
	error = null;

	flows.sleep(_, 3000);
	try {
		jwt.verify(token, secret);
	} catch (e) {
		error = e;
	} finally {
		ok(error != null, "Second verification failed because of expiration OK");
		strictEqual(error.name, 'TokenExpiredError', `Name of expiration token error OK ${error.name}`);
		strictEqual(error.message, 'jwt expired', `Message of expiration token error OK ${error.message}`);
		ok(error.expiredAt != null, `Date of expiration token error OK ${error.expiredAt}`);
	}
	error = null;





	start();
});

asyncTest("stop tests", 0, function(_) {
	doStop = true;

	start();
});