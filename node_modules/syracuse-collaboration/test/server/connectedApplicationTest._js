"use strict";

const helpers = require('syracuse-core').helpers;
const config = require('config'); // must be first syracuse require
const globals = require('streamline-runtime').globals;
const flows = require('streamline-runtime').flows;
const jwt = require('jsonwebtoken');
const connAppHelper = require('syracuse-4gl-api/lib/connectedApp');
const adminTestFixtures = require("syracuse-collaboration/test/fixtures/adminTestFixtures");

const adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
const testAdmin = require('syracuse-core').apis.get('test-admin');


const port = (config.unit_test && config.unit_test.serverPort) || 3004;
const baseUrl = "http://localhost:" + port;

let tracer; // = console.log;

let doStop = false;
QUnit.module(module.id);

let db;
asyncTest("init server", 1, function(_) {
	//
	db = testAdmin.initializeTestEnvironnement(_);
	ok(db != null, "Environnement initialized");
	//
	start();
});

function onlyInfo(diags) {
	return testAdmin.onlyInfo(diags);
}

function hasErrors(body) {
	let hasErr = body.$diagnoses && body.$diagnoses.some(function(diag) {
		return diag.$severity == "error" || diag.severity === "error";
	});
	if (!hasErr) {
		for (let key in body) {
			if (typeof body[key] === "object") hasErr = hasErr || hasErrors(body[key]);
		}
	}
	//
	return hasErr;
}



let user = "admin";
globals.context = globals.context || {};
globals.context.session = {
	host: "http://localhost:3004",
	id: helpers.uuid.generate(),
	getUserLogin: function(_) {
		return user;
	},
	getUserProfile: function(_) {
		return {
			user: function(_) {
				let db = adminHelper.getCollaborationOrm(_);
				return db.fetchInstance(_, db.model.getEntity(_, "user"), {
					jsonWhere: {
						login: user
					}
				});
			},
			selectedLocale: function(_) {
				let db = adminHelper.getCollaborationOrm(_);
				let loc = db.fetchInstance(_, db.model.getEntity(_, "localePreference"), {
					jsonWhere: {
						code: "en-US"
					}
				});
				return loc;
			},
		};
	},
	getSecurityProfile: function(_) {
		return null;
	},
	getData: function(code) {
		return null;
	}
};

let clientId, secret;
let token;
let appInst;
asyncTest("Create connected application", 5, function(_) {


	let connAppEntity = db.model.getEntity(_, "connectedApplication");
	appInst = connAppEntity.createInstance(_, db);
	appInst.name(_, "My connected application");
	appInst.url(_, "http://myconnectedapp:3000");
	appInst.expiration(_, "2s");
	appInst.save(_);

	strictEqual(appInst.name(_), "My connected application", `Connected application name OK ${appInst.name(_)}`);
	strictEqual(appInst.url(_), "http://myconnectedapp:3000", `Connected application url OK ${appInst.url(_)}`);
	strictEqual(appInst.active(_), true, `Connected application active by default OK`);

	clientId = appInst.clientId(_);
	secret = appInst.secretCreated(_);
	ok(clientId != null, `Client ID generated OK ${clientId}`);
	ok(secret != null, `Secret generated OK ${secret}`);

	start();
});

asyncTest("generate tokens", 2, function(_) {

	let tokenParams1 = `auth: 
  - auth1
  - auth2
  - auth3
site: SITE1`;

	token = connAppHelper.getConnectedAppToken(_, clientId, tokenParams1);
	ok(token != null, `Token generated OK ${token}`);

	// generate a second token to be sure we can have several :)
	let tokenParams2 = `auth: 
  - auth3
  - auth4
site: SITE2`;
	let formattedUrl = connAppHelper.formatConnectedAppUrl(_, clientId, "/path/to/resource", tokenParams2);

	ok(formattedUrl.indexOf('http://myconnectedapp:3000/path/to/resource') === 0, `Generated formatted URL OK ${formattedUrl}`);

	start();
});

asyncTest("verify tokens", 22, function(_) {
	let db = adminHelper.getCollaborationOrm(_);
	let model = db.model;
	let entity = model.getEntity(_, "tokenInfo");
	let filter = {
		sdataWhere: "app.clientId eq '" + clientId + "'"
	};
	let tokenInfos = db.fetchInstances(_, entity, filter);
	ok(tokenInfos.length === 2, `Two tokens generated OK`);

	let tokenInst = tokenInfos[0];
	ok(tokenInst.jti(_) != null, `Token ID generated OK ${tokenInst.jti(_)}`);
	ok(tokenInst.clientId(_) != null, `Connected app ID linked to token OK ${tokenInst.clientId(_)}`);
	let info = tokenInst.info(_);
	ok(info.auth && info.auth.length === 3, `Auth info count OK ${info.auth.length}`);
	strictEqual(info.auth && info.auth[0], 'auth1', `Auth info first value OK ${info.auth[0]}`);
	strictEqual(info.auth && info.auth[1], 'auth2', `Auth info second value OK ${info.auth[1]}`);
	strictEqual(info.auth && info.auth[2], 'auth3', `Auth info third value OK ${info.auth[2]}`);
	strictEqual(info.site, 'SITE1', `Site info value OK ${info.site}`);

	let tokenToVerify = token;
	let decoded = jwt.verify(tokenToVerify, secret);

	strictEqual(decoded.jti, tokenInst.jti(_), `jti verified OK ${decoded.jti}`);
	strictEqual(decoded.sub, 'admin', `sub verified OK ${decoded.sub}`);
	ok(decoded.auth && decoded.auth.length === 3, `Auth decoded count verified OK ${decoded.auth.length}`);
	strictEqual(decoded.auth && decoded.auth[0], 'auth1', `Auth decoded first value verified OK ${decoded.auth[0]}`);
	strictEqual(decoded.auth && decoded.auth[1], 'auth2', `Auth decoded second value verified OK ${decoded.auth[1]}`);
	strictEqual(decoded.auth && decoded.auth[2], 'auth3', `Auth decoded third value verified OK ${decoded.auth[2]}`);
	strictEqual(decoded.site, 'SITE1', `Site decoded value OK ${decoded.site}`);

	let error;
	try {
		jwt.verify(tokenToVerify, "Bad secret");
	} catch (e) {
		error = e;
	} finally {
		ok(error != null, "First verification failed because of invalid secret OK");
		strictEqual(error.name, 'JsonWebTokenError', `Name of bad secret token error OK ${error.name}`);
		strictEqual(error.message, 'invalid signature', `Message of bad secret token error OK ${error.message}`);
	}
	error = null;

	flows.sleep(_, 2000);
	try {
		jwt.verify(tokenToVerify, secret);
	} catch (e) {
		error = e;
	} finally {
		ok(error != null, "Second verification failed because of expiration OK");
		strictEqual(error.name, 'TokenExpiredError', `Name of expiration token error OK ${error.name}`);
		strictEqual(error.message, 'jwt expired', `Message of expiration token error OK ${error.message}`);
		ok(error.expiredAt != null, `Date of expiration token error OK ${error.expiredAt}`);
	}
	error = null;

	start();
});

asyncTest("userinfo dispatch failures", function(_) {
	let headers = {
		authorization: `Bearer ${token}`
	};
	let res = adminTestFixtures.get(_, null, baseUrl + "/auth/userinfo", 401, false, headers);
	strictEqual(res.$diagnoses && res.$diagnoses[0] && res.$diagnoses[0].$message, "Error 3: Invalid token", "tokenInfo expired and deleted OK");


	appInst.active(_, false);
	appInst.save(_);

	// regenerate a new token
	let tokenParams1 = `auth: 
  - auth5
  - auth6
site: SITE3`;

	token = connAppHelper.getConnectedAppToken(_, clientId, tokenParams1);
	ok(token != null, `Token generated OK ${token}`);

	let decoded = jwt.decode(token, secret);
	//////////
	// retrieve the tokenInfo in order to get his uuid and delete the event time associated (to prevent ttl delete)
	//////////
	let db = adminHelper.getCollaborationOrm(_);
	let model = db.model;
	let jti = decoded.jti;
	let entity = model.getEntity(_, "tokenInfo");
	let filter = {
		sdataWhere: "jti eq '" + jti + "'"
	};
	let tokenInfo = db.fetchInstance(_, entity, filter);
	let tiUuid = tokenInfo.$uuid;
	// delete eventTime
	let eventTimeEntity = model.getEntity(_, "eventTime");
	let filterET = {
		sdataWhere: `key eq 'tokenInfo_${tiUuid}_${tiUuid}'`
	};
	let eventTime = db.fetchInstance(_, eventTimeEntity, filterET);
	eventTime.deleteSelf(_);
	//////////
	//////////

	// try with missing jti
	let fakeData1 = helpers.object.clone(decoded);
	delete fakeData1.jti;
	headers.authorization = `Bearer ${jwt.sign(fakeData1, secret)}`;
	res = adminTestFixtures.get(_, null, baseUrl + "/auth/userinfo", 401, false, headers);
	strictEqual(res.$diagnoses && res.$diagnoses[0] && res.$diagnoses[0].$message, "Error 1: Invalid token", "token with missing jti should be rejected OK");


	// try with iat in the future
	let fakeData2 = helpers.object.clone(decoded);
	fakeData2.iat = (Date.now() + 20000) / 1000; // set iat in the future
	headers.authorization = `Bearer ${jwt.sign(fakeData2, secret)}`;
	res = adminTestFixtures.get(_, null, baseUrl + "/auth/userinfo", 401, false, headers);
	strictEqual(res.$diagnoses && res.$diagnoses[0] && res.$diagnoses[0].$message, "Error 2: Invalid token", "token with iat in the future should be rejected OK");

	// even with correct data it should be rejected because the app in inactive
	let fakeData3 = helpers.object.clone(decoded);
	headers.authorization = `Bearer ${jwt.sign(fakeData3, secret)}`;
	res = adminTestFixtures.get(_, null, baseUrl + "/auth/userinfo", 401, false, headers);
	strictEqual(res.$diagnoses && res.$diagnoses[0] && res.$diagnoses[0].$message, "Error 4: Invalid token", "token associated to inactive connected application should be rejected OK");


	// re-activate the conn app
	appInst.active(_, true);
	appInst.save(_);

	// try with missing sub
	let fakeData4 = helpers.object.clone(decoded);
	delete fakeData4.sub;
	headers.authorization = `Bearer ${jwt.sign(fakeData4, secret)}`;
	res = adminTestFixtures.get(_, null, baseUrl + "/auth/userinfo", 401, false, headers);
	strictEqual(res.$diagnoses && res.$diagnoses[0] && res.$diagnoses[0].$message, "Error 6: Invalid token", "token with missing sub should be rejected OK");

	// try with non existing sub
	let fakeData5 = helpers.object.clone(decoded);
	fakeData5.sub = "test";
	headers.authorization = `Bearer ${jwt.sign(fakeData5, secret)}`;
	res = adminTestFixtures.get(_, null, baseUrl + "/auth/userinfo", 401, false, headers);
	strictEqual(res.$diagnoses && res.$diagnoses[0] && res.$diagnoses[0].$message, "Error 7: Invalid token", "token with non existing user should be rejected OK");

	// change the secret without using generateSecret
	appInst.secret(_, "Secret modified");
	appInst.save(_);

	// try again with same data, it should be rejected as the secret is not the same
	res = adminTestFixtures.get(_, null, baseUrl + "/auth/userinfo", 401, false, headers);
	strictEqual(res.$diagnoses && res.$diagnoses[0] && res.$diagnoses[0].$message, "Error 5: Invalid token: JsonWebTokenError: invalid signature", "token with invalid signature should be rejected OK");

	// change the secret without using generateSecret to set the correct secret
	appInst.secret(_, secret);
	appInst.save(_);

	// wait for expiration
	flows.sleep(_, 2000);
	// try again with same data, it should be rejected as the secret is not the same
	res = adminTestFixtures.get(_, null, baseUrl + "/auth/userinfo", 401, false, headers);
	strictEqual(res.$diagnoses && res.$diagnoses[0] && res.$diagnoses[0].$message, "Error 5: Invalid token: TokenExpiredError: jwt expired", "token expired should be rejected OK");

	start();
});

asyncTest("userinfo dispatch success", function(_) {

	// regenerate a new token
	let tokenParams1 = `auth: 
  - auth7
  - auth8
site: SITE4`;

	token = connAppHelper.getConnectedAppToken(_, clientId, tokenParams1);
	ok(token != appInst, `Token generated OK ${token}`);

	// Validate userinfo call
	let headers = {
		authorization: `Bearer ${token}`
	};
	let res = adminTestFixtures.get(_, null, baseUrl + "/auth/userinfo", 200, false, headers);
	strictEqual(res.auth && res.auth.length, 2, "userinfo auth data length OK");
	strictEqual(res.auth && res.auth[0], "auth7", "userinfo auth entry 1 OK");
	strictEqual(res.auth && res.auth[1], "auth8", "userinfo auth entry 2 OK");
	strictEqual(res.site, "SITE4", "userinfo site OK");
	strictEqual(res.locale, "en-US", "locale OK");
	strictEqual(res.name, "Super administrator", "name OK");
	strictEqual(res.sub, "admin", "subject OK");


	start();
});

asyncTest("stop tests", 0, function(_) {
	doStop = true;

	start();
});