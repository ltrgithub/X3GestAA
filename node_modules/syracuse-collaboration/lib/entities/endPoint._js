"use strict";

var sys = require("util");
var x3pool = require("syracuse-x3/lib/pool");
var locale = require("syracuse-core/lib/locale");
var dataModel = require("syracuse-orm/lib/dataModel");
var registry = require("syracuse-sdata/lib/sdataRegistry");
var streams = require("streamline/lib/streams/streams");

function _makeDataset(_, ep) {
	return {
		driver: ep.databaseDriver(_),
		hostname: ep.databaseHost(_) || "localhost",
		port: ep.databasePort(_),
		database: ep.dataset(_)
	};
}

var _modelMap = {
	"syracuse": function(_, ep, failIfNull) {
		//
		var contract = registry.getContract(ep.applicationRef(_).application(_), ep.applicationRef(_).contract(_), failIfNull);
		if (!contract) return null;
		//			var ds = registry.getDataset(_, contract, ep.dataset(_));
		//			if (!ds) return null;
		return dataModel.make(contract, ep.dataset(_));
	},
	"x3": function(_, ep) {
		return require("syracuse-orm/lib/dbHandles/x3").makeModel(_, ep);
	}
};

var _ormMap = {
	"syracuse": function(_, ep, failIfNull) {
		//
		var model = ep.getModel(_, failIfNull);
		//
		return model && dataModel.getOrm(_, model, _makeDataset(_, ep));
	},
	"x3": function(_, ep) {
		return require("syracuse-orm/lib/dbHandles/x3").create(_, ep);
	}
};

function _getSolutionDescriptor(_, endpoint, silent) {
	if (endpoint._solutionDescriptor) return endpoint._solutionDescriptor;
	if (endpoint.x3SolutionName(_)) {
		var options = {
			url: endpoint.getWebServerBaseUrl(_) + "/solution.json",
			method: "GET"
		};
		var req = streams.httpRequest(options);
		var resp = req.end().response(_);
		if (resp.statusCode === 200) {
			return (endpoint._solutionDescriptor = JSON.parse(resp.readAll(_)));
		}
	}
	// if we're here, no solution descriptor was found
	if (silent) return null;
	throw new Error(locale.format(module, "solutionDescriptorNotFound", endpoint.description(_)));
	//	if(endpoint._solutionDescriptor) return endpoint._solutionDescriptor;
	//
	//	var config = require("syracuse-main/lib/nodeconfig").config;
	//	console.log("config.x3: " +sys.inspect(config));
	//	return config && config.x3 && config.x3.solutions && (endpoint._solutionDescriptor = config.x3.solutions[endpoint.x3server(_).serverHost(_)]);
}

exports.entity = {
	$titleTemplate: "Endpoint",
	$descriptionTemplate: "Endpoints describes services locations",
	$valueTemplate: "{description}",
	$helpPage: "Administration-reference-Endpoints",
	$properties: {
		description: {
			$title: "Description",
			$linksToDetails: true,
			$isLocalized: true,
			$isMandatory: true
		},
		application: {
			$title: "Application",
			$isMandatory: true,
			$isExcluded: true
		},
		contract: {
			$title: "Contract",
			$isMandatory: true,
			$isExcluded: true
		},
		protocol: {
			$title: "Protocol",
			$isMandatory: true,
			$isExcluded: true
		},
		dataset: {
			$title: "Name",
			$isMandatory: true,

			$isUnique: true
		},
		databaseDriver: {
			$title: "Database driver",
			$enum: [{
				$value: "mongodb",
				$title: "Mongodb"
			}],
			$isMandatory: function(_, instance) {
				return (instance.protocol(_) === "syracuse");
			},
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "syracuse");
			},
			$default: "mongodb"
		},
		databaseHost: {
			$title: "Database host",
			$isMandatory: function(_, instance) {
				return (instance.protocol(_) === "syracuse");
			},
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "syracuse");
			}
		},
		databasePort: {
			$title: "Database port",
			$type: "integer",
			$isMandatory: function(_, instance) {
				return (instance.protocol(_) === "syracuse");
			},
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "syracuse");
			}
		},
		x3ServerFolder: {
			$title: "Server folder",
			$isMandatory: function(_, instance) {
				return (instance.protocol(_) === "x3");
			},
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "x3");
			},
			// $default: "superv",
			$lookup: {
				entity: "lookupX3Folder",
				field: "name"
			}
		},
		x3SolutionName: {
			$title: "Solution name",
			/*$isMandatory: function(_, instance) {
				return (instance.protocol(_) === "x3");
			},*/
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "x3");
			}
		},
		transitionWebServer: {
			$title: "Transition web server",
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "x3");
			},
			$isDeveloppementFeature: true
		}
	},
	$relations: {
		groups: {
			$title: "Groups",
			$type: "groups",
			$inv: "endPoints",
			isComputed: true
		},
		// should rename as application
		applicationRef: {
			$title: "Application",
			$type: "application",
			$inv: "endpoints",
			$isMandatory: true,
			$propagate: function(_, instance, val) {
				if (!val) return;
				instance.application(_, val.application(_));
				instance.contract(_, val.contract(_));
				instance.protocol(_, val.protocol(_));
				//
				if (!val.defaultEndpoint(_)) {
					val.defaultEndpoint(_, instance);
					instance.addRelatedInstance(val);
				}
			}
		},
		x3server: {
			$title: "X3 server",
			$type: "x3server",
			$inv: "endpoints",
			$isMandatory: function(_, instance) {
				return (instance.protocol(_) === "x3");
			},
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "x3");
			}
		},
		menuProfileToRoles: {
			$title: "Menu profiles to roles mapping",
			$description: "Associate X3 menu profiles to roles",
			$type: "menuProfileToRoles",
			$isChild: true,
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "x3");
			}
		}
	},
	$functions: {
		$onDelete: function(_) {
			var self = this;
			var db = self._db;
			// cascade delete endpoint logins
			var users = db.fetchInstances(_, db.getEntity(_, "user"), {
				jsonWhere: {
					"endpoints.endpoint": self.$uuid
				}
			});
			users.forEach_(_, function(_, u) {
				var ueps = u.endpoints(_);
				ueps.toArray(_, true).forEach_(_, function(_, uep) {
					if (uep.endpoint(_) && (uep.endpoint(_).$uuid === self.$uuid)) {
						ueps.deleteInstance(_, uep.$uuid);
						self.addRelatedInstance(u);
					}
				});
			});
			// cascade remove binded vignettes from dashboards
			var dList = db.fetchInstances(_, db.getEntity(_, "dashboardDef"), {
				jsonWhere: {
					"variants.vignettes.endpoint": self.$uuid
				}
			});
			// delete vignette from variant
			dList.forEach_(_, function(_, d) {
				d.variants(_).toArray(_, true).forEach_(_, function(_, vr) {
					var vigns = vr.vignettes(_);
					vigns.toArray(_, true).forEach_(_, function(_, v) {
						if (v.endpoint(_) && (v.endpoint(_).$uuid === self.$uuid)) {
							vigns.deleteInstance(_, v.$uuid);
							self.addRelatedInstance(d);
						}
					});
				});
			});
		},
		isSame: function(_, application, contract, dataset, host, port) {
			// TODO: host and port
			return ((application === this.application(_)) && (contract === this.contract(_)) && (dataset === this.dataset(_)));
		},
		getBaseUrl: function(_) {
			return ["/sdata", this.application(_), this.contract(_), this.dataset(_)].join("/");
		},
		getIndexName: function(_, localeCode) {
			var parts = [this.application(_), this.contract(_), this.dataset(_)];
			if (localeCode) parts.push(localeCode);
			return (parts.join(".")).toLowerCase();
		},
		//
		getModel: function(_, failIfNull) {
			var p = this.protocol(_);
			return p && _modelMap[p](_, this, failIfNull);
		},
		getOrm: function(_, failIfNull) {
			var p = this.protocol(_);
			return p && _ormMap[p](_, this, failIfNull);
		},
		// X3 stuff
		getSolutionName: function(_) {
			if (this.x3SolutionName(_)) return this.x3SolutionName(_);
			throw new Error(locale.format(module, "solutionNameNotFound", this.description(_)));
			// COMPATIBILITY: load the solution descriptor
			//			var solutionDesc = _getSolutionDescriptor(_, this);
			//			return solutionDesc && solutionDesc.solution && solutionDesc.solution.name;
		},
		getX3FolderName: function(_) {
			return this.x3ServerFolder(_) || "";
		},
		getApplicationServerName: function(_) {
			var solutionDesc = _getSolutionDescriptor(_, this);
			return solutionDesc && solutionDesc.application && solutionDesc.application.server;
		},
		getApplicationServerBaseUrl: function(_, withFolder, secure) {
			var solutionDesc = _getSolutionDescriptor(_, this, true);
			var application = solutionDesc && solutionDesc.application;
			var x3server = this.x3server(_);
			var server = (application && application.server) || x3server.serverHost(_);
			var port = (application && application.mainPort) || x3server.webServerPort(_);
			return (secure ? "https://" : "http://") + [server + ":" + port, "Adonix_" + this.getSolutionName(_)].join("/") + (withFolder ? "/" + this.x3ServerFolder(_) : "");
		},
		getWebServerBaseUrl: function(_, withFolder, secure) {
			var x3server = this.x3server(_);
			return (secure ? "https://" : "http://") + [(x3server.webServer(_) || x3server.serverHost(_)) + ":" + x3server.webServerPort(_), "Adonix_" + this.getSolutionName(_)].join("/") + (withFolder ? "/" + this.x3ServerFolder(_) : "");
		},
		getFusionPrototypeUrl: function(_, options) {
			var opt = options || {};
			var x3server = this.x3server(_);
			if (!x3server) return null;
			var url = ["http:/"];
			var host = (x3server.webServer(_) || x3server.serverHost(_));
			if (!host || host.length == 0) throw new Error("Unexpected empty web server host");
			var port = x3server.webServerPort(_);
			if (port <= 0) throw new Error("Bad web server port");
			url.push(host + ":" + port);
			var sol = this.getSolutionName(_);
			if (!sol || sol.length == 0) throw new Error("Unexpected empty solution name");
			url.push("Adonix_" + sol);
			var localRoot = opt.prototypesLocalServerRoot;
			if (localRoot) url = [localRoot];
			var fldr = this.x3ServerFolder(_);
			if (!fldr || fldr.length == 0) throw new Error("Unexpected empty folder name");
			url.push(fldr);
			if (opt.prototypesFolder) {
				url.push(opt.prototypesFolder);
			} else {
				url.push("GEN");
				url.push("SYR");
				url.push((opt.langCode || locale.current).toUpperCase());
				url.push("FENJ");
			}
			if (opt.prototypeId) url.push(opt.prototypeId.split(".")[0] + ".json");
			return url.join("/") + "?salt=" + Math.floor(Math.random() * 100);
		},
		getFusionPrototype: function(_, options) {
			var url = this.getFusionPrototypeUrl(_, options);
			var opt = {
				url: url,
				method: "GET",
				headers: {
					"accept-charset": "utf-8"
				}
			};
			var response, respData;
			var request = streams.httpRequest(opt);
			try {
				response = request.end().response(_);
				//
				respData = response.readAll(_);
			} catch (e) {
				e.httpStatus = 500;
				e.message = locale.format(module, "prototypeServerError", options.prototypeId, respData && respData.toString("utf8"));
				throw e;
			}
			//
			switch (response.statusCode) {
				case 200:
					return this.tryParsePrototype(_, respData.toString("utf8"));
				case 500:
					throw new Error(locale.format(module, "prototypeServerError", options.prototypeId, respData && respData.toString("utf8")));
				default:
					return null;
			}
		},
		tryParsePrototype: function(_, s) {
			try {
				return JSON.parse(s);
			} catch (e) {
				throw new Error("Bad prototype: " + s);
			}
		},
		getFusionDataServerBaseUrl: function(_, secure) {
			var x3server = this.x3server(_);
			var solutionWebServer;
			if (!this.transitionWebServer || !this.transitionWebServer(_)) {
				var solutionDesc = _getSolutionDescriptor(_, this);
				solutionWebServer = this.transitionWebServer(_) || (solutionDesc && solutionDesc.webServers[0] && (solutionDesc.webServers[0].server + ":" + solutionDesc.webServers[0].mainPort)) || ((x3server.webServer(_) || x3server.serverHost(_)) + ":" + x3server.webServerPort(_));
			} else solutionWebServer = this.transitionWebServer(_);
			//
			return (secure ? "https://" : "http://") + [solutionWebServer, "sdata", "x3", "trans", "-"].join("/");
		}
	},
	$services: {
		makeDefaultEndpoint: {
			$title: "Set as default endpoint",
			$description: "This endpoint will be the default endpoint for application",
			$isMethod: true,
			$method: "POST",
			$execute: function(_, context, instance, parameters) {
				var app = instance.applicationRef(_);
				if (app) {
					app.defaultEndpoint(_, instance);
					app.save(_);
					// copy diags
					var diag = [];
					app.getAllDiagnoses(_, diag, {
						addPropName: true,
						addEntityName: true
					});
					diag.forEach(function(d) {
						instance.$addDiagnose(d.severity, d.message);
					});
					if (!diag.some(function(d) {
						return d.severity === "error";
					})) instance.$addDiagnose("info", locale.format(module, "setAsDefault", app.description(_)));
				}
			}
		},
		checkServer: {
			$title: "Check server settings",
			$description: "Attempts to connect to the server",
			$method: "GET",
			$isMethod: true,
			$execute: function(_, context, instance) {
				if (!instance.applicationRef(_)) return;
				if (instance.protocol(_) !== "x3") return;
				var server = instance.x3server(_);
				if (!server) return;
				try {
					instance.$diagnoses = require("syracuse-x3/lib/pool").checkServerSettings(_, {
						address: server.serverHost(_),
						port: server.serverPort(_),
						folder: instance.x3ServerFolder(_),
						applicationServer: server.serverName(_)
					});
				} catch (e) {
					(instance.$diagnoses = instance.$diagnoses || []).push({
						severity: "error",
						message: e.message
					});
				}
			}
		}
	},
	$searchIndex: {
		$fields: ["description", "applicationRef", "dataset", "groups", "x3server", "x3ServerFolder", "databaseDriver", "databaseHost"]
	}
};