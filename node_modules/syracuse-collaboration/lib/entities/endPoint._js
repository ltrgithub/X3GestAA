"use strict";

var sys = require("util");
var x3pool = require("syracuse-x3/lib/pool");
var locale = require("syracuse-core/lib/locale");
var dataModel = require("syracuse-orm/lib/dataModel");
var registry = require("syracuse-sdata/lib/sdataRegistry");
var streams = require("streamline/lib/streams/streams");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var config = require("syracuse-main/lib/nodeconfig").config;
var CvgCacheManager = require('syracuse-x3/lib/cvgCacheManager').CvgCacheManager;

var cacheMgr = new CvgCacheManager(_);


var _modelMap = {
	"syracuse": function(_, ep, failIfNull) {
		//
		var contract = registry.getContract(ep.applicationRef(_).application(_), ep.applicationRef(_).contract(_), failIfNull);
		if (!contract) return null;
		//			var ds = registry.getDataset(_, contract, ep.dataset(_));
		//			if (!ds) return null;
		return dataModel.make(contract, ep.dataset(_));
	},
	"x3": function(_, ep) {
		return require("syracuse-orm/lib/dbHandles/x3").makeModel(_, ep);
	}
};

var _ormMap = {
	"syracuse": function(_, ep, failIfNull) {
		//
		var model = ep.getModel(_, failIfNull);
		//
		return model && dataModel.getOrm(_, model, ep.makeDataset(_));
	},
	"x3": function(_, ep) {
		return require("syracuse-orm/lib/dbHandles/x3").create(_, ep);
	}
};

function getX3Rights(_, ep, user, role, handler) {
	var adminDb = adminHelper.getCollaborationOrm(_);
	var db = ep.getOrm(_);
	var cacheEnt = adminDb.getEntity(_, "x3RightsCache");
	var cache = adminDb.fetchInstance(_, cacheEnt, {
		jsonWhere: {
			user: user.$uuid,
			endpoint: ep.$uuid
		}
	});
	var rights;
	if (cache) {
		rights = cache.userRights(_);

		rights.$etag = cache.etag(_);
	}
	var res = {
		$mode: "authorize"
	};
	try {
		var db_rights = db.getUserRights(_, rights);
		if (db_rights && (db_rights.status === 200)) {
			if (!cache) {
				cache = cacheEnt.createInstance(_, adminDb);
				cache.user(_, user);
				cache.endpoint(_, ep);
			}
			cache.etag(_, db_rights.$etag);
			cache.userRights(_, db_rights);

			cache.save(_, {
				shallowSerialize: true
			});

			rights = db_rights;

		}
		// convert to functions structure
		if (rights) {
			if (rights.hasOwnProperty("$accessCodes")) {
				if (rights.$accessCodes === "*") { //
					res.$accessCodes = "*";
				} else {
					res.$accessCodes = rights.$accessCodes.split(",").reduce(function(prev, key) {

						prev[key] = true;
						return prev;
					}, {}) || {};
				}
			}
			if (rights.hasOwnProperty("$authorizedFunctions")) {
				if (rights.$authorizedFunctions !== "*") { //
					res.$functions = rights.$authorizedFunctions.split(",").reduce(function(prev, key) {
						prev[key] = true;
						return prev;
					}, {}) || {};
				} else {
					res.$functions = "*";
				}
			}
			if (rights.hasOwnProperty("$disabledFunctions")) {
				res.$disabledFunctions = rights.$disabledFunctions.split(",").reduce(function(prev, key) {
					prev[key] = true;
					return prev;
				}, {}) || {};
			}
			if (rights.hasOwnProperty("$authorizedRepresentations") && rights.$authorizedRepresentations !== "*") //
				res.$representations = rights.$authorizedRepresentations;

			if (rights.$etag)
				res.$etag = new Date(rights.$etag);
		}

	} catch (e) {
		if (e.$diagnoses) res.$diagnoses = e.$diagnoses;
		else res.$diagnoses = [{
			$severity: "error",
			$message: e.message
		}];
		res.$functions = {};
		res.$representations = {};
	}
	return res;
}


var _authRightSolverMap = {
	"syracuse": function(_, ep, user, role) {
		// compute forbidden representations from user rights
		var sp = role && role.securityProfile(_);
		return {
			$etag: role.$updDate > sp.$updDate ? role.$updDate : sp.$updDate,
			$mode: "restriction",
			$entities: sp && sp.getRestrictedEntities(_)
		};
	},
	"x3": function(_, ep, user, role) {
		return getX3Rights(_, ep, user, role);
	}
};

function _getSolutionDescriptor(_, endpoint, silent) {
	if (endpoint._solutionDescriptor) return endpoint._solutionDescriptor;
	if (endpoint.x3SolutionName(_)) {
		var options = {
			url: endpoint.getWebServerBaseUrl(_) + "/solution.json",
			method: "GET"
		};
		var req = streams.httpRequest(options);
		var resp = req.end().response(_);
		if (resp.statusCode === 200) {
			return (endpoint._solutionDescriptor = JSON.parse(resp.readAll(_)));
		}
	}
	// if we're here, no solution descriptor was found
	if (silent) return null;
	throw new Error(locale.format(module, "solutionDescriptorNotFound", endpoint.description(_)));
	//	if(endpoint._solutionDescriptor) return endpoint._solutionDescriptor;
	//
	//	var config = require("syracuse-main/lib/nodeconfig").config;
	//	console.log("config.x3: " +sys.inspect(config));
	//	return config && config.x3 && config.x3.solutions && (endpoint._solutionDescriptor = config.x3.solutions[endpoint.x3server(_).serverHost(_)]);
}

exports.entity = {
	$titleTemplate: "Endpoint",
	$descriptionTemplate: "Endpoints describes services locations",
	$valueTemplate: "{description}",
	$helpPage: "Administration-reference-Endpoints",
	$properties: {
		description: {
			$title: "Description",
			$linksToDetails: true,
			$isLocalized: true,
			$isMandatory: true
		},
		helpBaseUrl: {
			$title: "Help Base URL",
			$linksToDetails: true,
			$isLocalized: true,
			$isMandatory: false,
			$pattern: "^(http|https)\:\/\/[a-zA-Z0-9_\:\/\.\-]+\/$",
			$patternMessage: "Help base URL must be in the format http(s)://server(:port)/.../"
		},
		application: {
			$title: "Application",
			$isMandatory: true,
			$isExcluded: true
		},
		contract: {
			$title: "Contract",
			$isMandatory: true,
			$isExcluded: true
		},
		protocol: {
			$title: "Protocol",
			$isMandatory: true,
			$isExcluded: true
		},
		dataset: {
			$title: "Name",
			$isMandatory: true,
			$isUnique: true,
			$pattern: "^[a-zA-Z0-9_]*$",
			$patternMessage: "Endpoint name can only contain a to z, A to Z, 0 to 9 and _ caracters"
		},
		localDatabase: {
			$title: "Use local database settings",
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "syracuse");
			},
			$type: "boolean",
			$default: false
		},
		databaseDriver: {
			$title: "Database driver",
			$enum: [{
				$value: "mongodb",
				$title: "Mongodb"
			}],
			$isMandatory: function(_, instance) {
				return (instance.protocol(_) === "syracuse" && !instance.localDatabase(_));
			},
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "syracuse");
			},
			$isReadOnly: function(_, instance) {
				return (instance.localDatabase(_));
			},
			$default: "mongodb"
		},
		databaseHost: {
			$title: "Database host",
			$isMandatory: function(_, instance) {
				return (instance.protocol(_) === "syracuse" && !instance.localDatabase(_));
			},
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "syracuse");
			},
			$isReadOnly: function(_, instance) {
				return (instance.localDatabase(_));
			}
		},
		databasePort: {
			$title: "Database port",
			$type: "integer",
			$isMandatory: function(_, instance) {
				return (instance.protocol(_) === "syracuse" && !instance.localDatabase(_));
			},
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "syracuse");
			},
			$isReadOnly: function(_, instance) {
				return (instance.localDatabase(_));
			},
			$default: 27017
		},
		x3ServerFolder: {
			$title: "Server folder",
			$isMandatory: function(_, instance) {
				return (instance.protocol(_) === "x3");
			},
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "x3");
			},
			// $default: "superv",
			$lookup: {
				entity: "lookupX3Folder",
				field: "name"
			}
		},
		x3SolutionName: {
			$title: "Solution name",
			$isMandatory: function(_, instance) {
				return (instance.protocol(_) === "x3");
			},
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "x3");
			}
		},
		transitionWebServer: {
			$title: "Transition web server",
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "x3");
			},
			$isDeveloppementFeature: true
		}
	},
	$relations: {
		groups: {
			$title: "Groups",
			$type: "groups",
			$inv: "endPoints",
			isComputed: true,
			$nullOnDelete: true
		},
		// should rename as application
		applicationRef: {
			$title: "Application",
			$type: "application",
			$inv: "endpoints",
			$isMandatory: true,
			$propagate: function(_, instance, val) {
				if (!val) return;
				instance.application(_, val.application(_));
				instance.contract(_, val.contract(_));
				instance.protocol(_, val.protocol(_));
				//
				if (!val.defaultEndpoint(_)) {
					val.defaultEndpoint(_, instance);
					instance.addRelatedInstance(val);
				}
			}
		},
		x3server: {
			$title: "X3 server",
			$type: "x3server",
			$inv: "endpoints",
			$isMandatory: function(_, instance) {
				return (instance.protocol(_) === "x3");
			},
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "x3");
			}
		},
		menuProfileToRoles: {
			$title: "Menu profiles to roles mapping",
			$description: "Associate X3 menu profiles to roles",
			$type: "menuProfileToRoles",
			$isChild: true,
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "x3");
			}
		}
	},
	$functions: {
		$onDelete: function(_) {
			var self = this;
			var db = self._db;
			// cascade delete endpoint logins
			var users = db.fetchInstances(_, db.getEntity(_, "user"), {
				jsonWhere: {
					"endpoints.endpoint": self.$uuid
				}
			});
			users.forEach_(_, function(_, u) {
				var ueps = u.endpoints(_);
				ueps.toArray(_, true).forEach_(_, function(_, uep) {
					if (uep.endpoint(_) && (uep.endpoint(_).$uuid === self.$uuid)) {
						ueps.deleteInstance(_, uep.$uuid);
						self.addRelatedInstance(u);
					}
				});
			});
			// cascade remove binded vignettes from dashboards
			var dList = db.fetchInstances(_, db.getEntity(_, "dashboardDef"), {
				jsonWhere: {
					"variants.vignettes.endpoint": self.$uuid
				}
			});
			// delete vignette from variant
			dList.forEach_(_, function(_, d) {
				d.variants(_).toArray(_, true).forEach_(_, function(_, vr) {
					var vigns = vr.vignettes(_);
					vigns.toArray(_, true).forEach_(_, function(_, v) {
						if (v.endpoint(_) && (v.endpoint(_).$uuid === self.$uuid)) {
							vigns.deleteInstance(_, v.$uuid);
							self.addRelatedInstance(d);
						}
					});
				});
			});
		},
		makeDataset: function(_) {
			var self = this;
			// use data from config.collaboration when ep.localDatabase(_) is set. The equality of config.collaboration.database and the dataset of the 
			// collaboration endpoint is tested in syracuse._js within _initAsync().
			var db = self.dataset(_);
			if (self.localDatabase(_)) {
				return {
					driver: config.collaboration.driver,
					hostname: config.collaboration.hostname,
					port: config.collaboration.port,
					database: db
				};
			}
			return {
				driver: self.databaseDriver(_),
				hostname: self.databaseHost(_) || "localhost",
				port: self.databasePort(_),
				database: db
			};
		},
		isSame: function(_, application, contract, dataset, host, port) {
			// TODO: host and port
			return ((application === this.application(_)) && (contract === this.contract(_)) && (dataset === this.dataset(_)));
		},
		getBaseUrl: function(_, prefix) {
			return ["/" + (prefix || "sdata"), this.application(_), this.contract(_), this.dataset(_)].join("/");
		},
		getIndexName: function(_, localeCode) {
			var parts = [this.application(_), this.contract(_), this.dataset(_)];
			if (localeCode) parts.push(localeCode);
			return (parts.join(".")).toLowerCase().replace(" ", "_");
		},
		//
		getModel: function(_, failIfNull) {
			var p = this.protocol(_);
			return p && _modelMap[p](_, this, failIfNull);
		},
		getOrm: function(_, failIfNull) {
			var p = this.protocol(_);
			return p && _ormMap[p](_, this, failIfNull);
		},
		// X3 stuff
		getSolutionName: function(_) {
			if (this.x3SolutionName(_)) return this.x3SolutionName(_);
			throw new Error(locale.format(module, "solutionNameNotFound", this.description(_)));
			// COMPATIBILITY: load the solution descriptor
			//			var solutionDesc = _getSolutionDescriptor(_, this);
			//			return solutionDesc && solutionDesc.solution && solutionDesc.solution.name;
		},
		getX3FolderName: function(_) {
			return this.x3ServerFolder(_) || "";
		},
		getApplicationServerName: function(_) {
			var solutionDesc = _getSolutionDescriptor(_, this);
			return solutionDesc && solutionDesc.application && solutionDesc.application.server;
		},
		getApplicationServerBaseUrl: function(_, withFolder, secure) {
			var solutionDesc = _getSolutionDescriptor(_, this, true);
			var application = solutionDesc && solutionDesc.application;
			var x3server = this.x3server(_);
			var server = (application && application.server) || x3server.serverHost(_);
			var port = (application && application.mainPort) || x3server.webServerPort(_);
			return (secure ? "https://" : "http://") + [server + ":" + port, "Adonix_" + this.getSolutionName(_)].join("/") + (withFolder ? "/" + this.x3ServerFolder(_) : "");
		},
		getWebServerBaseUrl: function(_, withFolder, secure) {
			var x3server = this.x3server(_);
			return (secure ? "https://" : "http://") + [(x3server.webServer(_) || x3server.serverHost(_)) + ":" + x3server.webServerPort(_), "Adonix_" + this.getSolutionName(_)].join("/") + (withFolder ? "/" + this.x3ServerFolder(_) : "");
		},
		getFusionPrototypeUrl: function(_, options) {
			var opt = options || {};
			var x3server = this.x3server(_);
			if (!x3server) return null;
			var url = ["http:/"];
			var host = (x3server.webServer(_) || x3server.serverHost(_));
			if (!host || host.length == 0) throw new Error("Unexpected empty web server host");
			var port = x3server.webServerPort(_);
			if (port <= 0) throw new Error("Bad web server port");
			url.push(host + ":" + port);
			var sol = this.getSolutionName(_);
			if (!sol || sol.length == 0) throw new Error("Unexpected empty solution name");
			url.push("Adonix_" + sol);
			var localRoot = opt.prototypesLocalServerRoot;
			if (localRoot) url = [localRoot];
			var fldr = this.x3ServerFolder(_);
			if (!fldr || fldr.length == 0) throw new Error("Unexpected empty folder name");
			url.push(fldr);
			if (opt.prototypesFolder) {
				url.push(opt.prototypesFolder);
			} else {
				url.push("GEN");
				url.push("SYR");
				url.push((opt.langCode || locale.current).toUpperCase());
				url.push("FENJ");
			}
			if (opt.prototypeId) url.push(opt.prototypeId.split(".")[0] + ".json");
			return url.join("/");
		},
		getFusionPrototype: function(_, options) {
			var url = this.getFusionPrototypeUrl(_, options);
			var respData;
			try {
				respData = cacheMgr.getResource(_, url, {
					"accept-charset": "utf-8"
				});
				var pp = this.tryParsePrototype(_, respData.toString("utf8"));
				// TODO: need to change this to use the new base URL
				pp.$baseHelpUrl = [this.getBaseUrl(_, "help/" + locale.current), "{$category}", "{$keyword}"].join("/");
				return pp;
			} catch (e) {
				e.httpStatus = 500;
				e.message = locale.format(module, "prototypeServerError", options.prototypeId, respData && respData.toString("utf8"));
				throw e;
			}
		},
		getFusionPrototypeCacheInfos: function(_, options) {
			var url = this.getFusionPrototypeUrl(_, options);
			return cacheMgr.getInfos(url);
		},
		tryParsePrototype: function(_, s) {
			try {
				return JSON.parse(s);
			} catch (e) {
				throw new Error("Bad prototype: " + s);
			}
		},
		getFusionDataServerBaseUrl: function(_, secure) {
			var x3server = this.x3server(_);
			var solutionWebServer;
			if (!this.transitionWebServer || !this.transitionWebServer(_)) {
				var solutionDesc = _getSolutionDescriptor(_, this);
				solutionWebServer = this.transitionWebServer(_) || (solutionDesc && solutionDesc.webServers[0] && (solutionDesc.webServers[0].server + ":" + solutionDesc.webServers[0].mainPort)) || ((x3server.webServer(_) || x3server.serverHost(_)) + ":" + x3server.webServerPort(_));
			} else solutionWebServer = this.transitionWebServer(_);
			//
			return (secure ? "https://" : "http://") + [solutionWebServer, "sdata", "x3", "trans", "-"].join("/");
		},

		getAuthorizedAccessRight: function(_, user, role) {
			var p = this.protocol(_);
			return p && _authRightSolverMap[p](_, this, user, role);
		},
		getHelpBaseUrl: function(_) {
			var hs = this.helpServer(_);
			var hsp = this.helpServerPort(_);
			return (secure ? "https://" : "http://") + hs + ":" + hsp;
		}
	},
	$services: {
		makeDefaultEndpoint: {
			$title: "Set as default endpoint",
			$description: "This endpoint will be the default endpoint for application",
			$isMethod: true,
			$method: "POST",
			$execute: function(_, context, instance, parameters) {
				var app = instance.applicationRef(_);
				if (app) {
					app.defaultEndpoint(_, instance);
					app.save(_);
					// copy diags
					var diag = [];
					app.getAllDiagnoses(_, diag, {
						addPropName: true,
						addEntityName: true
					});
					diag.forEach(function(d) {
						instance.$addDiagnose(d.severity, d.message);
					});
					if (!diag.some(function(d) {
						return d.severity === "error";
					})) instance.$addDiagnose("info", locale.format(module, "setAsDefault", app.description(_)));
				}
			}
		},
		checkServer: {
			$title: "Check server settings",
			$description: "Attempts to connect to the server",
			$method: "GET",
			$isMethod: true,
			$execute: function(_, context, instance) {
				if (!instance.applicationRef(_)) return;
				if (instance.protocol(_) !== "x3") return;
				var server = instance.x3server(_);
				if (!server) return;
				try {
					instance.$diagnoses = require("syracuse-x3/lib/pool").checkServerSettings(_, {
						address: server.serverHost(_),
						port: server.serverPort(_),
						folder: instance.x3ServerFolder(_),
						applicationServer: server.serverName(_)
					});
				} catch (e) {
					(instance.$diagnoses = instance.$diagnoses || []).push({
						severity: "error",
						message: e.message
					});
				}
				var solution = instance.x3SolutionName(_);
				var des = _getSolutionDescriptor(_, instance);
				if (des.solution.name !== solution)
					throw new Error(locale.format(module, "differentSolution", solution, des.solution.name));
				var url = instance.getWebServerBaseUrl(_) + "/FOLDERS.json";
				var options = {
					url: url,
					method: "GET"
				};
				var req = streams.httpRequest(options);
				var resp = req.end().response(_);
				if (resp.statusCode < 400) {
					var folders = JSON.parse(resp.readAll(_));
					if (folders.solution !== solution)
						throw new Error(locale.format(module, "differentSolution2", solution, folders.solution));
					var x3ServerFolder = instance.x3ServerFolder(_);
					var i = folders.folders.length;
					while (--i >= 0) {
						if (folders.folders[i].name === x3ServerFolder) break;
					}
					if (i < 0) throw new Error(locale.format(module, "wrongFolder", x3ServerFolder));
				} else {
					var error;
					if (resp.statusCode === 404) {
						error = new Error(locale.format(module, "foldersNotFound", url));
					} else {
						error = new Error(resp.readAll(_));
					}
					error.statusCode = resp.statusCode;
					throw error;
				}
				instance.$addDiagnose("info", locale.format(module, "solutionFolderOK"));

			}
		},
		checkHelpBaseUrl: {
			$title: "Check help base URL",
			$description: "Attempts to verify the help URL",
			$method: "GET",
			$isMethod: true,
			$execute: function(_, context, instance) {
				if (!instance.helpBaseUrl(_)) return;
				var url = instance.helpBaseUrl(_);
				var opt = {
					url: url,
					method: "GET",
					headers: {
						"accept-charset": "utf-8"
					}
				};
				var response, respData;
				var request = streams.httpRequest(opt);
				try {
					response = request.end().response(_);
					//
					respData = response.readAll(_);
				} catch (e) {
					e.httpStatus = 500;
					e.message = locale.format(module, "helpUrlError", respData && respData.toString("utf8"));
					throw e;
				}
				//
				if (response.statusCode !== 200) {
					throw new Error(locale.format(module, "helpUrlError", respData && respData.toString("utf8")));
				}
			}
		}
	},
	$searchIndex: {
		$fields: ["description", "applicationRef", "dataset", "groups", "x3server", "x3ServerFolder", "databaseDriver", "databaseHost"]
	}
};