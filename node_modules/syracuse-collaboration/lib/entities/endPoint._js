"use strict";

var globals = require('streamline/lib/globals');
var sys = require("util");
var x3pool = require("syracuse-x3/lib/pool");
var locale = require("syracuse-core/lib/locale");
var dataModel = require("syracuse-orm/lib/dataModel");
var registry = require("syracuse-sdata/lib/sdataRegistry");
var streams = require("streamline/lib/streams/streams");
var httpClient = require('syracuse-httpclient/lib/httpClient');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var config = require('config');
var CvgCacheManager = require('syracuse-x3/lib/cvgCacheManager').CvgCacheManager;
var cacheMgr = new CvgCacheManager();

var IndexHelper = require("syracuse-search/lib/elasticIndex").IndexHelper;
var elasticVersion = require("syracuse-search/lib/elasticVersion");

function _getUrlSearchEngine() {
	var searchConf = config.searchEngine || {};
	return "http://" + (searchConf.hostname || "localhost") + ":" + (searchConf.port || 9200);
}

var _modelMap = {
	"syracuse": function(_, ep, failIfNull) {
		//
		var contract = registry.getContract(ep.applicationRef(_).application(_), ep.applicationRef(_).contract(_), failIfNull);
		if (!contract) return null;
		// var ds = registry.getDataset(_, contract, ep.dataset(_));
		// if (!ds) return null;
		return dataModel.make(contract, ep.dataset(_));
	},
	"x3": function(_, ep) {
		return require("syracuse-orm/lib/dbHandles/x3").makeModel(_, ep);
	}
};

var _ormMap = {
	"syracuse": function(_, ep, failIfNull) {
		//
		var model = ep.getModel(_, failIfNull);
		//
		return model && dataModel.getOrm(_, model, ep.makeDataset(_));
	},
	"x3": function(_, ep) {
		return require("syracuse-orm/lib/dbHandles/x3").create(_, ep);
	}
};

function getX3Rights(_, ep, user, role, handler) {
	var adminDb = adminHelper.getCollaborationOrm(_);
	var db = ep.getOrm(_);
	var cacheEnt = adminDb.getEntity(_, "x3RightsCache");
	var cache = adminDb.fetchInstance(_, cacheEnt, {
		jsonWhere: {
			user: user.$uuid,
			endpoint: ep.$uuid
		}
	});
	var rights;
	if (cache) {
		rights = cache.userRights(_);

		rights.$etag = cache.etag(_);
	}
	var res = {
		$mode: "authorize"
	};
	try {
		var db_rights = db.getUserRights(_, rights);
		if (db_rights && (db_rights.status === 200)) {
			if (!cache) {
				cache = cacheEnt.createInstance(_, adminDb);
				cache.user(_, user);
				cache.endpoint(_, ep);
			}
			cache.etag(_, db_rights.$etag);
			cache.userRights(_, db_rights);

			cache.save(_, {
				shallowSerialize: true
			});

			rights = db_rights;
			res.purgeCache = true;
		}
		// convert to functions structure
		if (rights) {
			if (rights.hasOwnProperty("$accessCodes")) {
				if (rights.$accessCodes === "*") { //
					res.$accessCodes = "*";
				} else {
					res.$accessCodes = rights.$accessCodes.split(",").reduce(function(prev, key) {
						prev[key] = true;
						return prev;
					}, {}) || {};
				}
			}
			if (rights.hasOwnProperty("$authorizedFunctions")) {
				if (rights.$authorizedFunctions !== "*") { //
					res.$functions = rights.$authorizedFunctions.split(",").reduce(function(prev, key) {
						prev[key] = true;
						return prev;
					}, {}) || {};
				} else {
					res.$functions = "*";
				}
			}
			if (rights.hasOwnProperty("$disabledFunctions")) {
				res.$disabledFunctions = rights.$disabledFunctions.split(",").reduce(function(prev, key) {
					prev[key] = true;
					return prev;
				}, {}) || {};
			}
			if (rights.hasOwnProperty("$authorizedRepresentations") && rights.$authorizedRepresentations !== "*") //
				res.$representations = rights.$authorizedRepresentations;

			if (rights.$etag) res.$etag = rights.$etag;
		}

	} catch (e) {
		if (e.$diagnoses) res.$diagnoses = e.$diagnoses;
		else res.$diagnoses = [{
			$severity: "error",
			$message: e.message
		}];
		res.$functions = {};
		res.$representations = {};
	}
	return res;
}

var _authRightSolverMap = {
	"syracuse": function(_, ep, user, role) {
		// compute forbidden representations from user rights
		var sp = role && role.securityProfile(_);

		var etag;
		var spDate = sp && sp.$updDate;
		var roleDate = role && role.$updDate;
		if (spDate && roleDate) {
			etag = roleDate > spDate ? roleDate : spDate;
		} else {
			etag = roleDate ? roleDate : (spDate ? spDate : null);
		}
		var rights = {
			$mode: "restriction",
			$entities: sp && sp.getRestrictedEntities(_)
		};
		if (etag) rights.$etag = etag;
		rights.purgeCache = true;
		return rights;
	},
	"x3": function(_, ep, user, role) {
		return getX3Rights(_, ep, user, role);
	}
};

function _getSolutionDescriptor(_, endpoint, silent) {
	if (endpoint._solutionDescriptor) return endpoint._solutionDescriptor;
	if (endpoint.x3SolutionName(_)) {
		var options = {
			url: endpoint.getWebServerBaseUrl(_) + "/solution.json",
			method: "GET"
		};
		var req = streams.httpRequest(options);
		var resp = req.end().response(_);
		if (resp.statusCode === 200) {
			return (endpoint._solutionDescriptor = JSON.parse(resp.readAll(_)));
		}
	}
	// if we're here, no solution descriptor was found
	if (silent) return null;
	throw new Error(locale.format(module, "solutionDescriptorNotFound", endpoint.description(_)));
	// if(endpoint._solutionDescriptor) return endpoint._solutionDescriptor;
	//
	// 	var config = require('config');
	// 	console.log("config.x3: " +sys.inspect(config));
	// 	return config && config.x3 && config.x3.solutions && (endpoint._solutionDescriptor = config.x3.solutions[endpoint.x3server(_).serverHost(_)]);
}

exports.entity = {
	$titleTemplate: "Endpoint",
	$descriptionTemplate: "Endpoints describes services locations",
	$valueTemplate: "{description}",
	$helpPage: "Administration-reference-Endpoints",
	$properties: {
		description: {
			$title: "Description",
			$linksToDetails: true,
			$isLocalized: true,
			$isMandatory: true,
			$isUnique: true
		},
		helpBaseUrl: {
			$title: "Help Base URL",
			$linksToDetails: true,
			$isLocalized: false,
			$isMandatory: false,
			$pattern: "^((http|https)\:\/\/[a-zA-Z0-9_\:\/\.\-]+\/)?$",
			$patternMessage: "Help base URL must be in the format http(s)://server(:port)/.../"
		},
		application: {
			$title: "Application",
			$isMandatory: true,
			$isExcluded: true
		},
		contract: {
			$title: "Contract",
			$isMandatory: true,
			$isExcluded: true
		},
		protocol: {
			$title: "Protocol",
			$isMandatory: true,
			$isExcluded: true
		},
		dataset: {
			$title: "Name",
			$isMandatory: true,
			$isUnique: true,
			$pattern: "^[a-zA-Z0-9_]*$",
			$patternMessage: "Endpoint name can only contain a to z, A to Z, 0 to 9 and _ caracters"
		},
		localDatabase: {
			$title: "Use local database settings",
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "syracuse");
			},
			$type: "boolean",
			$default: false
		},
		databaseDriver: {
			$title: "Database driver",
			$enum: [{
				$value: "mongodb",
				$title: "Mongodb"
			}],
			$isMandatory: function(_, instance) {
				return (instance.protocol(_) === "syracuse" && !instance.localDatabase(_));
			},
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "syracuse");
			},
			$isReadOnly: function(_, instance) {
				return (instance.localDatabase(_));
			},
			$default: "mongodb"
		},
		databaseHost: {
			$title: "Database host",
			$isMandatory: function(_, instance) {
				return (instance.protocol(_) === "syracuse" && !instance.localDatabase(_));
			},
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "syracuse");
			},
			$isReadOnly: function(_, instance) {
				return (instance.localDatabase(_));
			}
		},
		databasePort: {
			$title: "Database port",
			$type: "integer",
			$isMandatory: function(_, instance) {
				return (instance.protocol(_) === "syracuse" && !instance.localDatabase(_));
			},
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "syracuse");
			},
			$isReadOnly: function(_, instance) {
				return (instance.localDatabase(_));
			},
			$default: 27017
		},
		databaseName: {
			$title: "Database name",
			$isDefined: function(_, instance) {
				return (instance.protocol(_) !== "x3");
			},
			$isReadOnly: function(_, instance) {
				return (instance.localDatabase(_));
			}
		},
		x3ServerFolder: {
			$title: "Server folder",
			$isMandatory: function(_, instance) {
				return (instance.protocol(_) === "x3");
			},
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "x3");
			},
			// $default: "superv",
			$lookup: {
				entity: "lookupX3Folder",
				field: "name"
			}
		},
		x3SolutionName: {
			$title: "Solution name",
			$isMandatory: function(_, instance) {
				return (instance.protocol(_) === "x3");
			},
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "x3");
			}
		},
		transitionWebServer: {
			$title: "Transition web server",
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "x3");
			},
			$isDeveloppementFeature: true
		}
	},
	$relations: {
		groups: {
			$title: "Groups",
			$type: "groups",
			$inv: "endPoints",
			isComputed: true,
			$nullOnDelete: true
		},
		// should rename as application
		applicationRef: {
			$title: "Application",
			$type: "application",
			$inv: "endpoints",
			$isMandatory: true,
			$propagate: function(_, instance, val) {
				if (!val) return;
				instance.application(_, val.application(_));
				instance.contract(_, val.contract(_));
				instance.protocol(_, val.protocol(_));
				//
				if (!val.defaultEndpoint(_)) {
					val.defaultEndpoint(_, instance);
					instance.addRelatedInstance(val);
				}
			}
		},
		x3server: {
			$title: "X3 server",
			$type: "x3server",
			$inv: "endpoints",
			$isMandatory: function(_, instance) {
				return (instance.protocol(_) === "x3");
			},
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "x3");
			}
		},
		menuProfileToRoles: {
			$title: "Menu profiles to roles mapping",
			$description: "Associate X3 menu profiles to roles",
			$type: "menuProfileToRoles",
			$isChild: true,
			$isDefined: function(_, instance) {
				return (instance.protocol(_) === "x3");
			}
		}
	},
	$functions: {
		$onDelete: function(_) {
			var self = this;
			var db = self._db;
			// cascade delete endpoint logins
			var users = db.fetchInstances(_, db.getEntity(_, "user"), {
				jsonWhere: {
					"endpoints.endpoint": self.$uuid
				}
			});
			users.forEach_(_, function(_, u) {
				var ueps = u.endpoints(_);
				ueps.toArray(_, true).forEach_(_, function(_, uep) {
					if (uep.endpoint(_) && (uep.endpoint(_).$uuid === self.$uuid)) {
						ueps.deleteInstance(_, uep.$uuid);
						self.addRelatedInstance(u);
					}
				});
			});
			// cascade remove binded vignettes from dashboards
			var dList = db.fetchInstances(_, db.getEntity(_, "dashboardDef"), {
				jsonWhere: {
					"variants.vignettes.endpoint": self.$uuid
				}
			});
			// delete vignette from variant
			dList.forEach_(_, function(_, d) {
				d.variants(_).toArray(_, true).forEach_(_, function(_, vr) {
					var vigns = vr.vignettes(_);
					vigns.toArray(_, true).forEach_(_, function(_, v) {
						if (v.endpoint(_) && (v.endpoint(_).$uuid === self.$uuid)) {
							vigns.deleteInstance(_, v.$uuid);
							self.addRelatedInstance(d);
						}
					});
				});
			});
		},
		makeDataset: function(_) {
			var self = this;
			// use data from config.collaboration when ep.localDatabase(_) is
			// set. The equality of config.collaboration.database and the
			// dataset of the
			// collaboration endpoint is tested in syracuse._js within
			// _initAsync().
			var db = self.dataset(_);
			var dbname = self.databaseName(_);
			if (self.localDatabase(_)) {
				return {
					driver: config.collaboration.driver,
					hostname: config.collaboration.hostname,
					port: config.collaboration.port,
					database: db,
					databaseName: dbname
				};
			}
			return {
				driver: self.databaseDriver(_),
				hostname: self.databaseHost(_) || "localhost",
				port: self.databasePort(_),
				database: db,
				databaseName: dbname
			};
		},
		isSame: function(_, application, contract, dataset, host, port) {
			// TODO: host and port
			return ((application === this.application(_)) && (contract === this.contract(_)) && (dataset === this.dataset(_)));
		},
		getBaseUrl: function(_, prefix) {
			return ["/" + (prefix || "sdata"), this.application(_), this.contract(_), this.dataset(_)].join("/");
		},
		getIndexName: function(_, localeCode) {
			var parts = [this.application(_), this.contract(_),
				this.dataset(_)
			];
			if (localeCode) parts.push(localeCode);
			return (parts.join(".")).toLowerCase().replace(" ", "_");
		},
		//
		getModel: function(_, failIfNull) {
			var p = this.protocol(_);
			return p && _modelMap[p](_, this, failIfNull);
		},
		getOrm: function(_, failIfNull) {
			var p = this.protocol(_);
			return p && _ormMap[p](_, this, failIfNull);
		},
		// X3 stuff
		getSolutionName: function(_) {
			if (this.x3SolutionName(_)) return this.x3SolutionName(_);
			throw new Error(locale.format(module, "solutionNameNotFound", this.description(_)));
			// COMPATIBILITY: load the solution descriptor
			// var solutionDesc = _getSolutionDescriptor(_, this);
			// return solutionDesc && solutionDesc.solution &&
			// solutionDesc.solution.name;
		},
		getX3FolderName: function(_) {
			return this.x3ServerFolder(_) || "";
		},
		getApplicationServerName: function(_) {
			var solutionDesc = _getSolutionDescriptor(_, this);
			return solutionDesc && solutionDesc.application && solutionDesc.application.server;
		},
		getApplicationServerBaseUrl: function(_, withFolder, secure) {
			var solutionDesc = _getSolutionDescriptor(_, this, true);
			var application = solutionDesc && solutionDesc.application;
			var x3server = this.x3server(_);
			var server = (application && application.server) || x3server.serverHost(_);
			var port = (application && application.mainPort) || x3server.webServerPort(_);
			return (secure ? "https://" : "http://") + [server + ":" + port,
				"Adonix_" + this.getSolutionName(_)
			].join("/") + (withFolder ? "/" + this.x3ServerFolder(_) : "");
		},
		getWebServerBaseUrl: function(_, withFolder, secure) {
			var x3server = this.x3server(_);
			return (secure ? "https://" : "http://") + [
				(x3server.webServer(_) || x3server.serverHost(_)) + ":" + x3server.webServerPort(_),
				"Adonix_" + this.getSolutionName(_)
			].join("/") + (withFolder ? "/" + this.x3ServerFolder(_) : "");
		},
		getFusionPrototypeUrl: function(_, options) {
			var opt = options || {};
			var x3server = this.x3server(_);
			if (!x3server) return null;
			var url = ["http:/"];
			var host = (x3server.webServer(_) || x3server.serverHost(_));
			if (!host || host.length == 0) throw new Error("Unexpected empty web server host");
			var port = x3server.webServerPort(_);
			if (port <= 0) throw new Error("Bad web server port");
			url.push(host + ":" + port);
			var sol = this.getSolutionName(_);
			if (!sol || sol.length == 0) throw new Error("Unexpected empty solution name");
			url.push("Adonix_" + sol);
			var localRoot = opt.prototypesLocalServerRoot;
			if (localRoot) url = [localRoot];
			var fldr = this.x3ServerFolder(_);
			if (!fldr || fldr.length == 0) throw new Error("Unexpected empty folder name");
			url.push(fldr);
			if (opt.prototypesFolder) {
				url.push(opt.prototypesFolder);
			} else {
				url.push("GEN");
				url.push("SYR");
				url.push((opt.langCode || locale.current).toUpperCase());
				url.push("FENJ");
			}
			if (opt.prototypeId) url.push(opt.prototypeId.split(".")[0] + ".json");
			return url.join("/");
		},
		getFusionPrototype: function(_, options) {
			var url = this.getFusionPrototypeUrl(_, options);
			var respData;
			try {
				respData = cacheMgr.getResource(_, url, {
					"accept-charset": "utf-8"
				});
				var pp = this.tryParsePrototype(_, respData.toString("utf8"));
				// TODO: need to change this to use the new base URL
				pp.$baseHelpUrl = [
					this.getBaseUrl(_, "help/" + locale.current),
					"{$category}", "{$keyword}"
				].join("/");
				return pp;
			} catch (e) {
				e.httpStatus = 500;
				e.message = locale.format(module, "prototypeServerError", options.prototypeId, e.message);
				throw e;
			}
		},
		getFusionPrototypeCacheInfos: function(_, options) {
			var url = this.getFusionPrototypeUrl(_, options);
			return cacheMgr.getInfos(url);
		},
		tryParsePrototype: function(_, s) {
			try {
				return JSON.parse(s);
			} catch (e) {
				throw new Error("Bad prototype: " + s);
			}
		},
		getFusionDataServerBaseUrl: function(_, secure) {
			var x3server = this.x3server(_);
			var solutionWebServer;
			if (!this.transitionWebServer || !this.transitionWebServer(_)) {
				var solutionDesc = _getSolutionDescriptor(_, this);
				solutionWebServer = this.transitionWebServer(_) || (solutionDesc && solutionDesc.webServers[0] && (solutionDesc.webServers[0].server + ":" + solutionDesc.webServers[0].mainPort)) || ((x3server.webServer(_) || x3server.serverHost(_)) + ":" + x3server.webServerPort(_));
			} else solutionWebServer = this.transitionWebServer(_);
			//
			return (secure ? "https://" : "http://") + [solutionWebServer, "sdata", "x3", "trans", "-"].join("/");
		},

		getAuthorizedAccessRight: function(_, user, role) {
			var p = this.protocol(_);
			return p && _authRightSolverMap[p](_, this, user, role);
		},
		getHelpBaseUrl: function(_, secure) {
			var hs = this.helpServer(_);
			var hsp = this.helpServerPort(_);
			return (secure ? "https://" : "http://") + hs + ":" + hsp;
		}
	},
	$services: {
		makeDefaultEndpoint: {
			$title: "Set as default endpoint",
			$description: "This endpoint will be the default endpoint for application",
			$isMethod: true,
			$method: "POST",
			$execute: function(_, context, instance, parameters) {
				var app = instance.applicationRef(_);
				if (app) {
					app.defaultEndpoint(_, instance);
					app.save(_);
					// copy diags
					var diag = [];
					app.getAllDiagnoses(_, diag, {
						addPropName: true,
						addEntityName: true
					});
					diag.forEach(function(d) {
						instance.$addDiagnose(d.severity, d.message);
					});
					if (!diag.some(function(d) {
						return d.severity === "error";
					}))
						instance.$addDiagnose("info", locale.format(module, "setAsDefault", app.description(_)));
				}
			}
		},
		checkServer: {
			$title: "Check server settings",
			$description: "Attempts to connect to the server",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return !instance.applicationRef(_) || instance.protocol(_) !== "x3" || !instance.x3server(_);
			},
			$execute: function(_, context, instance) {
				if (!instance.applicationRef(_)) return;
				if (instance.protocol(_) !== "x3") return;
				var server = instance.x3server(_);
				var hasErrors = false;
				if (!server) return;
				try {
					instance.$diagnoses = require("syracuse-x3/lib/pool").checkServerSettings(_, {
						address: server.serverHost(_),
						port: server.serverPort(_),
						folder: instance.x3ServerFolder(_),
						applicationServer: server.serverName(_)
					});
				} catch (e) {
					(instance.$diagnoses = instance.$diagnoses || []).push({
						severity: "error",
						message: e.message
					});
					hasErrors = true;
				}
				var solution = instance.x3SolutionName(_);
				var des = _getSolutionDescriptor(_, instance);
				if (des.solution.name !== solution) instance.$addError(locale.format(module, "differentSolution", solution, des.solution.name));
				var url = instance.getWebServerBaseUrl(_) + "/FOLDERS.json";
				var options = {
					url: url,
					method: "GET"
				};
				var req = streams.httpRequest(options);
				var resp = req.end().response(_);
				if (resp.statusCode < 400) {
					var folders = JSON.parse(resp.readAll(_));
					if (folders.solution && folders.solution !== solution) {
						hasErrors = true;
						instance.$addError(locale.format(module, "differentSolution2", solution, folders.solution));
					}
					var x3ServerFolder = instance.x3ServerFolder(_);
					var i = folders.folders.length;
					while (--i >= 0) {
						if (folders.folders[i].name === x3ServerFolder) break;
					}
					if (i < 0) {
						hasErrors = true;
						instance.$addError(locale.format(module, "wrongFolder", x3ServerFolder));
					}
				} else {
					hasErrors = true;
					if (resp.statusCode === 404) {
						instance.$addError(locale.format(module, "foldersNotFound", url));
					} else {
						instance.$addError(resp.readAll(_));
					}
				}
				if (!hasErrors) {
					instance.$addDiagnose("info", locale.format(module, "solutionFolderOK"));
				}

			}
		},
		checkHelpBaseUrl: {
			$title: "Check help base URL",
			$description: "Attempts to verify the help URL",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return !instance.helpBaseUrl(_);
			},
			$execute: function(_, context, instance) {
				if (!instance.helpBaseUrl(_)) return;
				var baseUrl = instance.helpBaseUrl(_);
				var opt = {
					url: baseUrl,
					method: "GET",
					headers: {
						"accept-charset": "utf-8"
					}
				};

				function httpGet(_, url) {
					var resp, respData;
					opt.url = url;
					var request = httpClient.httpRequest(_, opt);
					try {
						resp = request.end().response(_);
						respData = resp.readAll(_);
					} catch (e) {
						(instance.$diagnoses = instance.$diagnoses || []).push({
							severity: "error",
							message: e.message
						});
						return {
							statusCode: 500,
							headers: [],
							body: e.message
						};
					}
					if (resp.statusCode === 301 && resp.headers["location"]) {
						return httpGet(_, resp.headers["location"]);
					}
					return {
						statusCode: resp.statusCode,
						headers: resp.headers,
						body: (respData || "").toString("utf8")
					};
				}
				var details = [],
					response, errors = 0,
					success = 0,
					urls = ["", "en-US/index.htm", "en-US/FCT/AIMP.htm", "en-US/FLD/A.htm"];
				urls.forEach_(_, function(_, path) {
					response = httpGet(_, baseUrl + path);
					details.push("GET /" + path + " -- status: " + response.statusCode);
					if (response.statusCode === 401) {
						// Server with authentication. We didn't sent token but the server is reachable
						instance.$addDiagnose("warning", locale.format(module, "helpUrlRequireAuthentication"));
					} else if (response.statusCode !== 200) {
						var msg = locale.format(module, "helpUrlError", response.statusCode + ": GET " + path);
						instance.$addError(msg, null, null, response.body);
						errors++;
					}
				});
				if (urls.length - errors > 0) {
					if (errors === 0)
						instance.$addDiagnose("info", locale.format(module, "helpUrlOK"), null, null, details.join("\n"));
					else
						instance.$addDiagnose("warning", locale.format(module, "helpUrlWarning"), null, null, details.join("\n"));
				}
			}
		},
		initSearchIndex: {
			$method: "POST",
			$title: "Init search index",
			$isMethod: true,
			$isHidden: true,
			$invocationMode: "async",
			$capabilities: "abort",
			$isDisabled: function(_, instance) {
				return !instance.$uuid;
			},
			$execute: function(_, context, instance) {
				elasticVersion.checkVersion(_, _getUrlSearchEngine(_));

				// launch first on syracuse administration endpoint
				var endpoint = instance._db.fetchInstance(_, instance._db.getEntity(_, "endPoint"), {
					jsonWhere: {
						description: "Syracuse administration"
					}
				});

				function _update(_, ep) {
					var helper = new IndexHelper(ep);

					// data
					var result = helper.updateIndex(_);
					// function
					result = result.continu && helper.updateFunctionIndex(_);
				}

				// launch update for syracuse endpoint
				_update(_, endpoint);

				// endpoint choice
				if (instance.dataset(_) !== "syracuse") _update(_, instance);
			}
		},
		/* #4199: hide extra functionality
		updateMappings: {
			$title: "Update profession code mappings",
			$isMethod: true,
			$isDisabled: true,
			$method: "POST",
			$execute: function(_, context, instance, parameters) {
				if (instance.protocol(_) !== "x3") {
					instance.$addError(locale.format(module, "noX3Endpoint"));
					return;
				}
				var orm = instance.getOrm(_);
				var ent = orm.getEntity(_, "ASYRMET");
				// console.error("T2 " + sys.format(ent)) 
				var insts = orm.fetchInstances(_, ent, {});
				var codes = [];
				insts.forEach_(_, function(_, inst) {
					codes.push(inst.CODMET(_));
				});
				var mappings0 =
					instance.menuProfileToRoles(_);
				var mappings = mappings0.toArray(_);
				mappings.forEach_(_, function(_, mapping) {
					var index = codes.indexOf(mapping.professionCode(_));
					if (index >= 0) {
						codes.splice(index, 1);
					} else { // delete role
						mappings0.deleteInstance(_, mapping.$uuid);
						mapping.getAllDiagnoses(_, instance.$diagnoses);
					}
				}); // add new instances 
				if (codes.length > 0) { // fetch arbitrary role 
					var adminDb = adminHelper.getCollaborationOrm(_);
					var role = adminDb.fetchInstance(_, adminDb.getEntity(_, "role"), {
						jsonWhere: {}
					});
					if (!role) {
						instance.$addError(locale.format(module, "noRole"));
						return;
					}
					codes.forEach_(_, function(_, code) {
						var mapping = mappings0.add(_);
						if ("menuProfile" in mapping) mapping.menuProfile(_, "Test");
						mapping.professionCode(_, code);
						mapping.role(_, role);
						mapping.save(_);
						mapping.getAllDiagnoses(_, instance.$diagnoses);
					});
				}
				instance.save(_);
			},
		}
		 */
	},
	$searchIndex: {
		$fields: ["description", "applicationRef", "dataset", "groups",
			"x3server", "x3ServerFolder", "databaseDriver", "databaseHost"
		]
	}
};